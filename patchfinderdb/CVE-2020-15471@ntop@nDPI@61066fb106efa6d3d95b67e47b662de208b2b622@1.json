{
  "cve_id": "CVE-2020-15471",
  "cve_desc": "In nDPI through 3.2, the packet parsing code is vulnerable to a heap-based buffer over-read in ndpi_parse_packet_line_info in lib/ndpi_main.c.",
  "repo": "ntop/nDPI",
  "patch_hash": "61066fb106efa6d3d95b67e47b662de208b2b622",
  "patch_info": {
    "commit_hash": "61066fb106efa6d3d95b67e47b662de208b2b622",
    "repo": "ntop/nDPI",
    "commit_url": "https://github.com/ntop/nDPI/commit/61066fb106efa6d3d95b67e47b662de208b2b622",
    "files": [
      "src/lib/ndpi_main.c"
    ],
    "message": "Added check for heap buffer overflow read",
    "before_after_code_files": [
      "src/lib/ndpi_main.c||src/lib/ndpi_main.c"
    ]
  },
  "patch_diff": {
    "src/lib/ndpi_main.c||src/lib/ndpi_main.c": [
      "File: src/lib/ndpi_main.c -> src/lib/ndpi_main.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "4870:  u_int32_t a1 = a + 4;",
      "4874:  if(diff > 0) {",
      "4875:    memcpy(&flow->initial_binary_bytes, &packet->payload[a1], diff);",
      "4876:    flow->initial_binary_bytes_len = diff;",
      "4877:  }",
      "",
      "[Removed Lines]",
      "4872:  diff = ndpi_min(packet->payload_packet_len-a1, sizeof(flow->initial_binary_bytes));",
      "",
      "[Added Lines]",
      "4877:  diff = packet->payload_packet_len - a1;",
      "4880:    diff = ndpi_min(diff, sizeof(flow->initial_binary_bytes));",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "e272db0f7fb0c599355e7a5aae993aea3c30db60",
      "candidate_info": {
        "commit_hash": "e272db0f7fb0c599355e7a5aae993aea3c30db60",
        "repo": "ntop/nDPI",
        "commit_url": "https://github.com/ntop/nDPI/commit/e272db0f7fb0c599355e7a5aae993aea3c30db60",
        "files": [
          "src/lib/ndpi_main.c"
        ],
        "message": "content type parsing fix",
        "before_after_code_files": [
          "src/lib/ndpi_main.c||src/lib/ndpi_main.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/lib/ndpi_main.c||src/lib/ndpi_main.c"
          ],
          "candidate": [
            "src/lib/ndpi_main.c||src/lib/ndpi_main.c"
          ]
        }
      },
      "candidate_diff": {
        "src/lib/ndpi_main.c||src/lib/ndpi_main.c": [
          "File: src/lib/ndpi_main.c -> src/lib/ndpi_main.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "5093:       if(packet->content_line.len > 0) {",
          "5098:    packet->content_line.len = c - (char*)packet->content_line.ptr;",
          "5099:  }",
          "5100:       }",
          "",
          "[Removed Lines]",
          "5095:  char *c = strchr((char*)packet->content_line.ptr, ';');",
          "5097:  if(c != NULL) {",
          "",
          "[Added Lines]",
          "5095:  char separator[] = { ';', '\\r', '\\0' };",
          "5096:  int i;",
          "5098:  for(i=0; separator[i] != '\\0'; i++) {",
          "5099:    char *c = strchr((char*)packet->content_line.ptr, separator[i]);",
          "5101:    if(c != NULL)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "2ab0433aca70bf591941df946f7605306bd0d407",
      "candidate_info": {
        "commit_hash": "2ab0433aca70bf591941df946f7605306bd0d407",
        "repo": "ntop/nDPI",
        "commit_url": "https://github.com/ntop/nDPI/commit/2ab0433aca70bf591941df946f7605306bd0d407",
        "files": [
          "src/lib/ndpi_main.c",
          "tests/result/KakaoTalk_talk.pcap.out",
          "tests/result/anyconnect-vpn.pcap.out",
          "tests/result/netflix.pcap.out"
        ],
        "message": "Updated content-type parsing",
        "before_after_code_files": [
          "src/lib/ndpi_main.c||src/lib/ndpi_main.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/lib/ndpi_main.c||src/lib/ndpi_main.c"
          ],
          "candidate": [
            "src/lib/ndpi_main.c||src/lib/ndpi_main.c"
          ]
        }
      },
      "candidate_diff": {
        "src/lib/ndpi_main.c||src/lib/ndpi_main.c": [
          "File: src/lib/ndpi_main.c -> src/lib/ndpi_main.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "5096:  int i;",
          "5098:  for(i=0; separator[i] != '\\0'; i++) {",
          "5101:    if(c != NULL)",
          "5103:  }",
          "5104:       }",
          "",
          "[Removed Lines]",
          "5099:    char *c = strchr((char*)packet->content_line.ptr, separator[i]);",
          "5102:    packet->content_line.len = c - (char*)packet->content_line.ptr;",
          "",
          "[Added Lines]",
          "5099:    char *c = memchr((char*)packet->content_line.ptr, separator[i], packet->content_line.len);",
          "5102:      packet->content_line.len = c - (char*)packet->content_line.ptr;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "7c788f0779c017f17110bff90da5467dece85638",
      "candidate_info": {
        "commit_hash": "7c788f0779c017f17110bff90da5467dece85638",
        "repo": "ntop/nDPI",
        "commit_url": "https://github.com/ntop/nDPI/commit/7c788f0779c017f17110bff90da5467dece85638",
        "files": [
          "example/ndpiReader.c",
          "src/lib/ndpi_main.c",
          "src/lib/protocols/dns.c"
        ],
        "message": "Fixed partial string matches",
        "before_after_code_files": [
          "example/ndpiReader.c||example/ndpiReader.c",
          "src/lib/ndpi_main.c||src/lib/ndpi_main.c",
          "src/lib/protocols/dns.c||src/lib/protocols/dns.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/lib/ndpi_main.c||src/lib/ndpi_main.c"
          ],
          "candidate": [
            "src/lib/ndpi_main.c||src/lib/ndpi_main.c"
          ]
        }
      },
      "candidate_diff": {
        "example/ndpiReader.c||example/ndpiReader.c": [
          "File: example/ndpiReader.c -> example/ndpiReader.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3462:   assert(ndpi_add_string_to_automa(automa, \"hello\") == 0);",
          "3463:   assert(ndpi_add_string_to_automa(automa, \"world\") == 0);",
          "3464:   ndpi_finalize_automa(automa);",
          "3467:   ndpi_free_automa(automa);",
          "3468: }",
          "",
          "[Removed Lines]",
          "3465:   assert(ndpi_match_string(automa, \"This is the wonderful world of nDPI\") == 0);",
          "",
          "[Added Lines]",
          "3465:   assert(ndpi_match_string(automa, \"This is the wonderful world of nDPI\") == 1);",
          "",
          "---------------"
        ],
        "src/lib/ndpi_main.c||src/lib/ndpi_main.c": [
          "File: src/lib/ndpi_main.c -> src/lib/ndpi_main.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1794:     if(whatfound",
          "1795:        && (whatfound != buf)",
          "1801:   }",
          "",
          "[Removed Lines]",
          "1798:        && (whatfound[-1] != '.')",
          "1799:        )",
          "1800:       return(0);",
          "",
          "[Added Lines]",
          "1797:        && strchr(m->patterns->astring, '.') /* The matched pattern has a . (e.g. numeric or sym IPs) */) {",
          "1798:       if(whatfound[-1] != '.') {",
          "1799:  return(0);",
          "1800:       } else {",
          "1803:       }",
          "1804:     }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2215:   rc = ac_automata_search(automa, &ac_input_text, &match);",
          "2216:   ac_automata_reset(automa);",
          "2218:   return(rc ? match.number : 0);",
          "2219: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2223:     As ac_automata_search can detect partial matches and continue the search process",
          "2224:     in case rc == 0 (i.e. no match), we need to check if there is a partial match",
          "2225:     and in this case return it",
          "2227:   if((rc == 0) && (match.number != 0)) rc = 1;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2236:   rc = ac_automata_search(automa, &ac_input_text, &match);",
          "2237:   ac_automata_reset(automa);",
          "2241:   return(*id != NDPI_PROTOCOL_UNKNOWN ? 0 : -1);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2251:     As ac_automata_search can detect partial matches and continue the search process",
          "2252:     in case rc == 0 (i.e. no match), we need to check if there is a partial match",
          "2253:     and in this case return it",
          "2255:   if((rc == 0) && (match.number != 0)) rc = 1;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "3543:   u_int8_t l4_result;",
          "3545:   if (!flow)",
          "3549:   flow->packet.payload_packet_len = 0;",
          "",
          "[Removed Lines]",
          "3546:     return 1;",
          "",
          "[Added Lines]",
          "3564:     return 1;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "6115:   rc = ac_automata_search(((AC_AUTOMATA_t*)automa->ac_automa), &ac_input_text, &match);",
          "6116:   ac_automata_reset(((AC_AUTOMATA_t*)automa->ac_automa));",
          "6118:   return(rc ? match.number : 0);",
          "6119: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6137:     As ac_automata_search can detect partial matches and continue the search process",
          "6138:     in case rc == 0 (i.e. no match), we need to check if there is a partial match",
          "6139:     and in this case return it",
          "6141:   if((rc == 0) && (match.number != 0)) rc = 1;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "6303:   flow->detected_protocol_stack[0],",
          "6304:   flow->detected_protocol_stack[1]);",
          "6305: #endif",
          "6307:   if(flow->check_extra_packets) return(1);",
          "6309:   switch(flow->detected_protocol_stack[0]) {",
          "6310:   case NDPI_PROTOCOL_TLS:",
          "6311:     if(!flow->l4.tcp.tls_srv_cert_fingerprint_processed)",
          "6312:       return(1);",
          "6313:     break;",
          "6315:   case NDPI_PROTOCOL_HTTP:",
          "6316:     if(flow->host_server_name[0] == '\\0')",
          "6317:       return(1);",
          "6318:     break;",
          "6320:   case NDPI_PROTOCOL_DNS:",
          "6321:     if((ndpi_struct->dns_dont_dissect_response == 0)",
          "6322:        && (flow->host_server_name[0] == '\\0'))",
          "6323:       return(1);",
          "6324:     break;",
          "6325:   }",
          "6328: }",
          "",
          "[Removed Lines]",
          "6327:   return(0);",
          "",
          "[Added Lines]",
          "6352:   return(0);",
          "",
          "---------------"
        ],
        "src/lib/protocols/dns.c||src/lib/protocols/dns.c": [
          "File: src/lib/protocols/dns.c -> src/lib/protocols/dns.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "264:     if(j > 0) {",
          "265:       ndpi_protocol_match_result ret_match;",
          "272:     }",
          "274: #ifdef DNS_DEBUG",
          "",
          "[Removed Lines]",
          "267:       ndpi_match_host_subprotocol(ndpi_struct, flow,",
          "268:       (char *)flow->host_server_name,",
          "269:       strlen((const char*)flow->host_server_name),",
          "270:       &ret_match,",
          "271:       NDPI_PROTOCOL_DNS);",
          "",
          "[Added Lines]",
          "266:       u_int32_t subproto = ndpi_match_host_subprotocol(ndpi_struct, flow,",
          "267:              (char *)flow->host_server_name,",
          "268:              strlen((const char*)flow->host_server_name),",
          "269:              &ret_match,",
          "270:              NDPI_PROTOCOL_DNS);",
          "272:       if(ret_match.protocol_category != NDPI_PROTOCOL_CATEGORY_UNSPECIFIED)",
          "273:  flow->category = ret_match.protocol_category;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "7da7ae622b2b77ea573319b1485018e8df6fdd6b",
      "candidate_info": {
        "commit_hash": "7da7ae622b2b77ea573319b1485018e8df6fdd6b",
        "repo": "ntop/nDPI",
        "commit_url": "https://github.com/ntop/nDPI/commit/7da7ae622b2b77ea573319b1485018e8df6fdd6b",
        "files": [
          "src/lib/ndpi_main.c",
          "src/lib/protocols/ntp.c",
          "src/lib/protocols/tls.c",
          "tests/result/1kxun.pcap.out",
          "tests/result/anyconnect-vpn.pcap.out",
          "tests/result/nest_log_sink.pcap.out",
          "tests/result/nintendo.pcap.out",
          "tests/result/skype.pcap.out",
          "tests/result/skype_no_unknown.pcap.out",
          "tests/result/whatsapp_login_call.pcap.out",
          "tests/result/whatsapp_login_chat.pcap.out",
          "tests/result/zoom.pcap.out"
        ],
        "message": "Improvements to stop dissection when the first protocol is detected Used IP-based detection to compute the application protocol Improved application detection",
        "before_after_code_files": [
          "src/lib/ndpi_main.c||src/lib/ndpi_main.c",
          "src/lib/protocols/ntp.c||src/lib/protocols/ntp.c",
          "src/lib/protocols/tls.c||src/lib/protocols/tls.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/lib/ndpi_main.c||src/lib/ndpi_main.c"
          ],
          "candidate": [
            "src/lib/ndpi_main.c||src/lib/ndpi_main.c"
          ]
        }
      },
      "candidate_diff": {
        "src/lib/ndpi_main.c||src/lib/ndpi_main.c": [
          "File: src/lib/ndpi_main.c -> src/lib/ndpi_main.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1766:        1 /* no subprotocol */, no_master,",
          "1767:        no_master, \"Bloomberg\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1768:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1770:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_CAPWAP,",
          "1771:        1 /* no subprotocol */, no_master,",
          "1772:        no_master, \"CAPWAP\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "",
          "[Removed Lines]",
          "1769:        ndpi_build_default_ports(ports_b, 0,   0, 0, 0, 0) /* UDP */);",
          "",
          "[Added Lines]",
          "1769:        ndpi_build_default_ports(ports_b, 0,   0, 0, 0, 0) /* UDP */);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1955:   Return: the number of entries loaded or -1 in case of error",
          "",
          "[Removed Lines]",
          "1953:   Load a file containing IPv4 addresses in CIDR format as 'protocol_id'",
          "",
          "[Added Lines]",
          "1953:   Load a file containing IPv4 addresses in CIDR format as 'protocol_id'",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "4055:  func = ndpi_str->proto_defaults[flow->guessed_protocol_id].func;",
          "4056:   }",
          "4074:   }",
          "4075: }",
          "",
          "[Removed Lines]",
          "4058:   for(a = 0; a < ndpi_str->callback_buffer_size_udp; a++) {",
          "4059:     if((func != ndpi_str->callback_buffer_udp[a].func)",
          "4060:        && (ndpi_str->callback_buffer_udp[a].ndpi_selection_bitmask & *ndpi_selection_packet) ==",
          "4061:        ndpi_str->callback_buffer_udp[a].ndpi_selection_bitmask",
          "4062:        && NDPI_BITMASK_COMPARE(flow->excluded_protocol_bitmask,",
          "4063:           ndpi_str->callback_buffer_udp[a].excluded_protocol_bitmask) == 0",
          "4064:        && NDPI_BITMASK_COMPARE(ndpi_str->callback_buffer_udp[a].detection_bitmask,",
          "4065:           detection_bitmask) != 0) {",
          "4066:       ndpi_str->callback_buffer_udp[a].func(ndpi_str, flow);",
          "4069:       if(flow->detected_protocol_stack[0] != NDPI_PROTOCOL_UNKNOWN)",
          "4071:     } else",
          "4072:       if(_ndpi_debug_callbacks) NDPI_LOG_DBG2(ndpi_str,",
          "4073:            \"[UDP,SKIP] dissector of protocol as callback_buffer idx =  %d\\n\",a);",
          "",
          "[Added Lines]",
          "4058:   if(flow->detected_protocol_stack[0] == NDPI_PROTOCOL_UNKNOWN) {",
          "4059:     for(a = 0; a < ndpi_str->callback_buffer_size_udp; a++) {",
          "4060:       if((func != ndpi_str->callback_buffer_udp[a].func)",
          "4061:   && (ndpi_str->callback_buffer_udp[a].ndpi_selection_bitmask & *ndpi_selection_packet) ==",
          "4062:   ndpi_str->callback_buffer_udp[a].ndpi_selection_bitmask",
          "4063:   && NDPI_BITMASK_COMPARE(flow->excluded_protocol_bitmask,",
          "4064:      ndpi_str->callback_buffer_udp[a].excluded_protocol_bitmask) == 0",
          "4065:   && NDPI_BITMASK_COMPARE(ndpi_str->callback_buffer_udp[a].detection_bitmask,",
          "4066:      detection_bitmask) != 0) {",
          "4067:  ndpi_str->callback_buffer_udp[a].func(ndpi_str, flow);",
          "4070:  if(flow->detected_protocol_stack[0] != NDPI_PROTOCOL_UNKNOWN)",
          "4072:       } else",
          "4073:  if(_ndpi_debug_callbacks) NDPI_LOG_DBG2(ndpi_str,",
          "4074:       \"[UDP,SKIP] dissector of protocol as callback_buffer idx =  %d\\n\",a);",
          "4075:     }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "4298:       ret.app_protocol = NDPI_PROTOCOL_HANGOUT_DUO;",
          "4299:     }",
          "4300:   }",
          "4302:   if(ret.app_protocol != NDPI_PROTOCOL_UNKNOWN)",
          "4305:   return(ret);",
          "4306: }",
          "",
          "[Removed Lines]",
          "4303:     ndpi_fill_protocol_category(ndpi_str, flow, &ret);",
          "",
          "[Added Lines]",
          "4305:     ndpi_fill_protocol_category(ndpi_str, flow, &ret);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "4816:    addr.s_addr = flow->packet.iph->daddr;",
          "4817:    flow->guessed_host_protocol_id = ndpi_network_ptree_match(ndpi_str, &addr);",
          "4818:  }",
          "4819:       }",
          "4820:     }",
          "4821:   }",
          "4823:   if(flow->guessed_host_protocol_id > NDPI_MAX_SUPPORTED_PROTOCOLS) {",
          "4848:     ndpi_check_flow_func(ndpi_str, flow, &ndpi_selection_packet);",
          "4849:     ndpi_fill_protocol_category(ndpi_str, flow, &ret);",
          "",
          "[Removed Lines]",
          "4825:     ret.master_protocol = NDPI_PROTOCOL_UNKNOWN, ret.app_protocol = flow->guessed_host_protocol_id;",
          "4827:     if(flow->packet.tcp && (ret.master_protocol == NDPI_PROTOCOL_UNKNOWN)) {",
          "4829:       int i;",
          "4831:       for(i=0; i<2; i++) {",
          "4832:  u_int16_t port = (i == 0) ? ntohs(flow->packet.tcp->dest) : ntohs(flow->packet.tcp->source);",
          "4834:  switch(port) {",
          "4835:  case 80:",
          "4836:    ret.master_protocol = NDPI_PROTOCOL_HTTP;",
          "4837:    break;",
          "4838:  case 443:",
          "4840:    break;",
          "4841:  }",
          "4843:  if(ret.master_protocol != NDPI_PROTOCOL_UNKNOWN)",
          "4844:    break;",
          "4845:       }",
          "4846:     }",
          "",
          "[Added Lines]",
          "4823:    We could implement a shortcut here skipping dissectors for",
          "4824:    protocols we have identified by other means such as with the IP",
          "4826:    However we do NOT stop here and skip invoking the dissectors",
          "4827:    because we want to dissect the flow (e.g. dissect the TLS)",
          "4828:    and extract metadata.",
          "4830: #if SKIP_INVOKING_THE_DISSECTORS",
          "4831:  if(flow->guessed_host_protocol_id != NDPI_PROTOCOL_UNKNOWN) {",
          "4833:      We have identified a protocol using the IP address so",
          "4834:      it is not worth to dissect the traffic as we already have",
          "4835:      the solution",
          "4837:    ret.master_protocol = flow->guessed_protocol_id,",
          "4838:      ret.app_protocol = flow->guessed_host_protocol_id;",
          "4839:  }",
          "4840: #endif",
          "4847:     ret.master_protocol = flow->guessed_protocol_id, ret.app_protocol = flow->guessed_host_protocol_id;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "4905:     ret = ndpi_detection_giveup(ndpi_str, flow, 0, &protocol_was_guessed);",
          "4906:   }",
          "4908:  invalidate_ptr:",
          "4910:      Invalidate packet memory to avoid accessing the pointers below",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4909:   if((ret.master_protocol == NDPI_PROTOCOL_UNKNOWN)",
          "4910:      && (ret.app_protocol != NDPI_PROTOCOL_UNKNOWN)",
          "4911:      && (flow->guessed_host_protocol_id != NDPI_PROTOCOL_UNKNOWN)) {",
          "4912:     ret.master_protocol = ret.app_protocol;",
          "4913:     ret.app_protocol = flow->guessed_host_protocol_id;",
          "4914:   }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "5186:  char separator[] = { ';', '\\r', '\\0' };",
          "5187:  int i;",
          "5190:    char *c = memchr((char*)packet->content_line.ptr, separator[i], packet->content_line.len);",
          "5192:    if(c != NULL)",
          "5193:      packet->content_line.len = c - (char*)packet->content_line.ptr;",
          "5194:  }",
          "5195:       }",
          "5198:       if(packet->line[packet->parsed_lines].len > 8",
          "5199:   && strncasecmp((const char *)packet->line[packet->parsed_lines].ptr, \"Accept: \", 8) == 0) {",
          "",
          "[Removed Lines]",
          "5189:  for(i=0; separator[i] != '\\0'; i++) {",
          "",
          "[Added Lines]",
          "5197:  for(i=0; separator[i] != '\\0'; i++) {",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "6615: ndpi_l4_proto_info ndpi_get_l4_proto_info(struct ndpi_detection_module_struct *ndpi_struct,",
          "6617:   if(ndpi_proto_id < ndpi_struct->ndpi_num_supported_protocols) {",
          "6618:     u_int16_t idx = ndpi_struct->proto_defaults[ndpi_proto_id].protoIdx;",
          "6619:     NDPI_SELECTION_BITMASK_PROTOCOL_SIZE bm = ndpi_struct->callback_buffer[idx].ndpi_selection_bitmask;",
          "",
          "[Removed Lines]",
          "6616:        u_int16_t ndpi_proto_id) {",
          "",
          "[Added Lines]",
          "6624:        u_int16_t ndpi_proto_id) {",
          "",
          "---------------"
        ],
        "src/lib/protocols/ntp.c||src/lib/protocols/ntp.c": [
          "File: src/lib/protocols/ntp.c -> src/lib/protocols/ntp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "58:       return;",
          "59:     }",
          "60:   }",
          "63: }",
          "",
          "[Removed Lines]",
          "61:   NDPI_EXCLUDE_PROTO(ndpi_struct, flow);",
          "",
          "[Added Lines]",
          "62:   NDPI_EXCLUDE_PROTO(ndpi_struct, flow);",
          "",
          "---------------"
        ],
        "src/lib/protocols/tls.c||src/lib/protocols/tls.c": [
          "File: src/lib/protocols/tls.c -> src/lib/protocols/tls.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1400:   u_int8_t ret, skip_cert_processing = 0;",
          "1402: #ifdef DEBUG_TLS",
          "1404: #endif",
          "1406:   if(packet->udp != NULL) {",
          "1408:     int rc = sslTryAndRetrieveServerCertificate(ndpi_struct, flow);",
          "1416:     if((rc == 0) && (flow->protos.stun_ssl.ssl.ssl_version != 0)) {",
          "1417:       flow->guessed_protocol_id = NDPI_PROTOCOL_TLS;",
          "",
          "[Removed Lines]",
          "1403:   printf(\"%s()\\n\", __FUNCTION__);",
          "1410: #ifdef DEBUG_TLS",
          "1411:     printf(\"==>> %u [rc: %d][len: %u][%s][version: %u]\\n\",",
          "1412:     flow->guessed_host_protocol_id, rc, packet->payload_packet_len, flow->protos.stun_ssl.ssl.ja3_server,",
          "1413:     flow->protos.stun_ssl.ssl.ssl_version);",
          "1414: #endif",
          "",
          "[Added Lines]",
          "1403:   printf(\"==>> %u [len: %u][version: %u]\\n\",",
          "1404:   flow->guessed_host_protocol_id,",
          "1405:   packet->payload_packet_len,",
          "1406:   flow->protos.stun_ssl.ssl.ssl_version);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "427002d14fbb4d42c30d38b5812e40142c96ff98",
      "candidate_info": {
        "commit_hash": "427002d14fbb4d42c30d38b5812e40142c96ff98",
        "repo": "ntop/nDPI",
        "commit_url": "https://github.com/ntop/nDPI/commit/427002d14fbb4d42c30d38b5812e40142c96ff98",
        "files": [
          "example/protos.txt",
          "src/include/ndpi_api.h",
          "src/lib/ndpi_main.c",
          "src/lib/third_party/include/ndpi_patricia.h"
        ],
        "message": "Reworked protocol handling chnging it is u_int16_t",
        "before_after_code_files": [
          "src/include/ndpi_api.h||src/include/ndpi_api.h",
          "src/lib/ndpi_main.c||src/lib/ndpi_main.c",
          "src/lib/third_party/include/ndpi_patricia.h||src/lib/third_party/include/ndpi_patricia.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/lib/ndpi_main.c||src/lib/ndpi_main.c"
          ],
          "candidate": [
            "src/lib/ndpi_main.c||src/lib/ndpi_main.c"
          ]
        }
      },
      "candidate_diff": {
        "src/include/ndpi_api.h||src/include/ndpi_api.h": [
          "File: src/include/ndpi_api.h -> src/include/ndpi_api.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "803:      u_int32_t daddr,",
          "804:      ndpi_protocol *ret);",
          "805:   int ndpi_match_custom_category(struct ndpi_detection_module_struct *ndpi_struct,",
          "807:   void ndpi_fill_protocol_category(struct ndpi_detection_module_struct *ndpi_struct,",
          "808:        struct ndpi_flow_struct *flow,",
          "809:        ndpi_protocol *ret);",
          "810:   int ndpi_get_custom_category_match(struct ndpi_detection_module_struct *ndpi_struct,",
          "812:   int ndpi_set_detection_preferences(struct ndpi_detection_module_struct *ndpi_mod,",
          "813:          ndpi_detection_preference pref,",
          "814:          int value);",
          "",
          "[Removed Lines]",
          "806:      char *name, u_int name_len, unsigned long *id);",
          "811:          char *name_or_ip, u_int name_len, unsigned long *id);",
          "",
          "[Added Lines]",
          "806:      char *name, u_int name_len, u_int16_t *id);",
          "811:          char *name_or_ip, u_int name_len, u_int16_t *id);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "846:   void set_ndpi_malloc(void* (*__ndpi_malloc)(size_t size));",
          "",
          "[Removed Lines]",
          "843:   int ndpi_match_string_id(void *_automa, char *string_to_match, u_int match_len, unsigned long *id);",
          "",
          "[Added Lines]",
          "843:   int ndpi_match_string_id(void *_automa, char *string_to_match, u_int match_len, u_int16_t *id);",
          "",
          "---------------"
        ],
        "src/lib/ndpi_main.c||src/lib/ndpi_main.c": [
          "File: src/lib/ndpi_main.c -> src/lib/ndpi_main.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "78: }",
          "85: }",
          "89: }",
          "102: }",
          "112: }",
          "122: }",
          "137: }",
          "151: }",
          "",
          "[Removed Lines]",
          "75: static inline uint8_t flow_is_proto(struct ndpi_flow_struct *flow, u_int16_t p)",
          "76: {",
          "77:     return ((flow->detected_protocol_stack[0] == p) || (flow->detected_protocol_stack[1] == p));",
          "82: void *ndpi_malloc(size_t size)",
          "83: {",
          "84:     return (_ndpi_malloc ? _ndpi_malloc(size) : malloc(size));",
          "86: void *ndpi_flow_malloc(size_t size)",
          "87: {",
          "88:     return (_ndpi_flow_malloc ? _ndpi_flow_malloc(size) : ndpi_malloc(size));",
          "93: void *ndpi_calloc(unsigned long count, size_t size)",
          "94: {",
          "95:     size_t len = count * size;",
          "96:     void *p = ndpi_malloc(len);",
          "98:     if (p)",
          "99:         memset(p, 0, len);",
          "101:     return (p);",
          "106: void ndpi_free(void *ptr)",
          "107: {",
          "108:     if (_ndpi_free)",
          "109:         _ndpi_free(ptr);",
          "110:     else",
          "111:         free(ptr);",
          "116: void ndpi_flow_free(void *ptr)",
          "117: {",
          "118:     if (_ndpi_flow_free)",
          "119:         _ndpi_flow_free(ptr);",
          "120:     else",
          "121:         ndpi_free_flow((struct ndpi_flow_struct *) ptr);",
          "126: void *ndpi_realloc(void *ptr, size_t old_size, size_t new_size)",
          "127: {",
          "128:     void *ret = ndpi_malloc(new_size);",
          "130:     if (!ret)",
          "131:         return (ret);",
          "132:     else {",
          "133:         memcpy(ret, ptr, old_size);",
          "134:         ndpi_free(ptr);",
          "135:         return (ret);",
          "136:     }",
          "140: char *ndpi_strdup(const char *s)",
          "141: {",
          "142:     int len = strlen(s);",
          "143:     char *m = ndpi_malloc(len + 1);",
          "145:     if (m) {",
          "146:         memcpy(m, s, len);",
          "147:         m[len] = '\\0';",
          "148:     }",
          "150:     return (m);",
          "",
          "[Added Lines]",
          "75: static inline uint8_t flow_is_proto(struct ndpi_flow_struct *flow, u_int16_t p) {",
          "76:   return((flow->detected_protocol_stack[0] == p) || (flow->detected_protocol_stack[1] == p));",
          "81: void *ndpi_malloc(size_t size) {",
          "82:   return(_ndpi_malloc ? _ndpi_malloc(size) : malloc(size));",
          "84: void *ndpi_flow_malloc(size_t size) {",
          "85:   return(_ndpi_flow_malloc ? _ndpi_flow_malloc(size) : ndpi_malloc(size));",
          "90: void *ndpi_calloc(unsigned long count, size_t size) {",
          "91:   size_t len = count * size;",
          "92:   void *p = ndpi_malloc(len);",
          "94:   if(p)",
          "95:     memset(p, 0, len);",
          "97:   return(p);",
          "102: void ndpi_free(void *ptr) {",
          "103:   if(_ndpi_free)",
          "104:     _ndpi_free(ptr);",
          "105:   else",
          "106:     free(ptr);",
          "111: void ndpi_flow_free(void *ptr) {",
          "112:   if(_ndpi_flow_free)",
          "113:     _ndpi_flow_free(ptr);",
          "114:   else",
          "115:     ndpi_free_flow((struct ndpi_flow_struct *) ptr);",
          "120: void *ndpi_realloc(void *ptr, size_t old_size, size_t new_size) {",
          "121:   void *ret = ndpi_malloc(new_size);",
          "123:   if(!ret)",
          "124:     return(ret);",
          "125:   else {",
          "126:     memcpy(ret, ptr, old_size);",
          "127:     ndpi_free(ptr);",
          "128:     return(ret);",
          "129:   }",
          "133: char *ndpi_strdup(const char *s) {",
          "134:   int len = strlen(s);",
          "135:   char *m = ndpi_malloc(len + 1);",
          "137:   if(m) {",
          "138:     memcpy(m, s, len);",
          "139:     m[len] = '\\0';",
          "140:   }",
          "142:   return(m);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "156: struct ndpi_ptree",
          "157: {",
          "160: };",
          "167: }",
          "174: }",
          "181: }",
          "188: }",
          "195: }",
          "208: }",
          "",
          "[Removed Lines]",
          "158:     patricia_tree_t *v4;",
          "159:     patricia_tree_t *v6;",
          "164: u_int32_t ndpi_detection_get_sizeof_ndpi_flow_struct(void)",
          "165: {",
          "166:     return (sizeof(struct ndpi_flow_struct));",
          "171: u_int32_t ndpi_detection_get_sizeof_ndpi_id_struct(void)",
          "172: {",
          "173:     return (sizeof(struct ndpi_id_struct));",
          "178: u_int32_t ndpi_detection_get_sizeof_ndpi_flow_tcp_struct(void)",
          "179: {",
          "180:     return (sizeof(struct ndpi_flow_tcp_struct));",
          "185: u_int32_t ndpi_detection_get_sizeof_ndpi_flow_udp_struct(void)",
          "186: {",
          "187:     return (sizeof(struct ndpi_flow_udp_struct));",
          "192: char *ndpi_get_proto_by_id(struct ndpi_detection_module_struct *ndpi_str, u_int id)",
          "193: {",
          "194:     return ((id >= ndpi_str->ndpi_num_supported_protocols) ? NULL : ndpi_str->proto_defaults[id].protoName);",
          "199: u_int16_t ndpi_get_proto_by_name(struct ndpi_detection_module_struct *ndpi_str, const char *name)",
          "200: {",
          "201:     u_int16_t i, num = ndpi_get_num_supported_protocols(ndpi_str);",
          "203:     for (i = 0; i < num; i++)",
          "204:         if (strcasecmp(ndpi_get_proto_by_id(ndpi_str, i), name) == 0)",
          "205:             return (i);",
          "207:     return (NDPI_PROTOCOL_UNKNOWN);",
          "",
          "[Added Lines]",
          "150:   patricia_tree_t *v4;",
          "151:   patricia_tree_t *v6;",
          "156: u_int32_t ndpi_detection_get_sizeof_ndpi_flow_struct(void) {",
          "157:   return(sizeof(struct ndpi_flow_struct));",
          "162: u_int32_t ndpi_detection_get_sizeof_ndpi_id_struct(void) {",
          "163:   return(sizeof(struct ndpi_id_struct));",
          "168: u_int32_t ndpi_detection_get_sizeof_ndpi_flow_tcp_struct(void) {",
          "169:   return(sizeof(struct ndpi_flow_tcp_struct));",
          "174: u_int32_t ndpi_detection_get_sizeof_ndpi_flow_udp_struct(void) {",
          "175:   return(sizeof(struct ndpi_flow_udp_struct));",
          "180: char *ndpi_get_proto_by_id(struct ndpi_detection_module_struct *ndpi_str, u_int id) {",
          "181:   return((id >= ndpi_str->ndpi_num_supported_protocols) ? NULL : ndpi_str->proto_defaults[id].protoName);",
          "186: u_int16_t ndpi_get_proto_by_name(struct ndpi_detection_module_struct *ndpi_str, const char *name) {",
          "187:   u_int16_t i, num = ndpi_get_num_supported_protocols(ndpi_str);",
          "189:   for (i = 0; i < num; i++)",
          "190:     if(strcasecmp(ndpi_get_proto_by_id(ndpi_str, i), name) == 0)",
          "191:       return(i);",
          "193:   return(NDPI_PROTOCOL_UNKNOWN);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "213: ndpi_port_range *ndpi_build_default_ports_range(ndpi_port_range *ports, u_int16_t portA_low, u_int16_t portA_high,",
          "214:                                                 u_int16_t portB_low, u_int16_t portB_high, u_int16_t portC_low,",
          "215:                                                 u_int16_t portC_high, u_int16_t portD_low, u_int16_t portD_high,",
          "231: }",
          "232: #endif",
          "236: ndpi_port_range *ndpi_build_default_ports(ndpi_port_range *ports, u_int16_t portA, u_int16_t portB, u_int16_t portC,",
          "252: }",
          "262: }",
          "266: void ndpi_set_proto_category(struct ndpi_detection_module_struct *ndpi_str, u_int16_t protoId,",
          "273: }",
          "",
          "[Removed Lines]",
          "216:                                                 u_int16_t portE_low, u_int16_t portE_high)",
          "217: {",
          "218:     int i = 0;",
          "220:     ports[i].port_low = portA_low, ports[i].port_high = portA_high;",
          "221:     i++;",
          "222:     ports[i].port_low = portB_low, ports[i].port_high = portB_high;",
          "223:     i++;",
          "224:     ports[i].port_low = portC_low, ports[i].port_high = portC_high;",
          "225:     i++;",
          "226:     ports[i].port_low = portD_low, ports[i].port_high = portD_high;",
          "227:     i++;",
          "228:     ports[i].port_low = portE_low, ports[i].port_high = portE_high;",
          "230:     return (ports);",
          "237:                                           u_int16_t portD, u_int16_t portE)",
          "238: {",
          "239:     int i = 0;",
          "241:     ports[i].port_low = portA, ports[i].port_high = portA;",
          "242:     i++;",
          "243:     ports[i].port_low = portB, ports[i].port_high = portB;",
          "244:     i++;",
          "245:     ports[i].port_low = portC, ports[i].port_high = portC;",
          "246:     i++;",
          "247:     ports[i].port_low = portD, ports[i].port_high = portD;",
          "248:     i++;",
          "249:     ports[i].port_low = portE, ports[i].port_high = portE;",
          "251:     return (ports);",
          "256: void ndpi_set_proto_breed(struct ndpi_detection_module_struct *ndpi_str, u_int16_t protoId, ndpi_protocol_breed_t breed)",
          "257: {",
          "258:     if (protoId >= NDPI_MAX_SUPPORTED_PROTOCOLS + NDPI_MAX_NUM_CUSTOM_PROTOCOLS)",
          "259:         return;",
          "260:     else",
          "261:         ndpi_str->proto_defaults[protoId].protoBreed = breed;",
          "267:                              ndpi_protocol_category_t protoCategory)",
          "268: {",
          "269:     if (protoId >= NDPI_MAX_SUPPORTED_PROTOCOLS + NDPI_MAX_NUM_CUSTOM_PROTOCOLS)",
          "270:         return;",
          "271:     else",
          "272:         ndpi_str->proto_defaults[protoId].protoCategory = protoCategory;",
          "",
          "[Added Lines]",
          "202:                                                 u_int16_t portE_low, u_int16_t portE_high) {",
          "203:   int i = 0;",
          "205:   ports[i].port_low = portA_low, ports[i].port_high = portA_high;",
          "206:   i++;",
          "207:   ports[i].port_low = portB_low, ports[i].port_high = portB_high;",
          "208:   i++;",
          "209:   ports[i].port_low = portC_low, ports[i].port_high = portC_high;",
          "210:   i++;",
          "211:   ports[i].port_low = portD_low, ports[i].port_high = portD_high;",
          "212:   i++;",
          "213:   ports[i].port_low = portE_low, ports[i].port_high = portE_high;",
          "215:   return(ports);",
          "222:                                           u_int16_t portD, u_int16_t portE) {",
          "223:   int i = 0;",
          "225:   ports[i].port_low = portA, ports[i].port_high = portA;",
          "226:   i++;",
          "227:   ports[i].port_low = portB, ports[i].port_high = portB;",
          "228:   i++;",
          "229:   ports[i].port_low = portC, ports[i].port_high = portC;",
          "230:   i++;",
          "231:   ports[i].port_low = portD, ports[i].port_high = portD;",
          "232:   i++;",
          "233:   ports[i].port_low = portE, ports[i].port_high = portE;",
          "235:   return(ports);",
          "240: void ndpi_set_proto_breed(struct ndpi_detection_module_struct *ndpi_str, u_int16_t protoId, ndpi_protocol_breed_t breed) {",
          "241:   if(protoId >= NDPI_MAX_SUPPORTED_PROTOCOLS + NDPI_MAX_NUM_CUSTOM_PROTOCOLS)",
          "242:     return;",
          "243:   else",
          "244:     ndpi_str->proto_defaults[protoId].protoBreed = breed;",
          "250:                              ndpi_protocol_category_t protoCategory) {",
          "251:   if(protoId >= NDPI_MAX_SUPPORTED_PROTOCOLS + NDPI_MAX_NUM_CUSTOM_PROTOCOLS)",
          "252:     return;",
          "253:   else",
          "254:     ndpi_str->proto_defaults[protoId].protoCategory = protoCategory;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "285:   - HTTP/SSL are NOT informative as SSL.Facebook (likely) means that this is",
          "286:   SSL (HTTPS) traffic containg Facebook traffic.",
          "302: }",
          "305: void ndpi_exclude_protocol(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,",
          "309: #ifdef NDPI_ENABLE_DEBUG_MESSAGES",
          "316:     }",
          "317: }",
          "",
          "[Removed Lines]",
          "288: u_int8_t ndpi_is_subprotocol_informative(struct ndpi_detection_module_struct *ndpi_str, u_int16_t protoId)",
          "289: {",
          "290:     if (protoId >= NDPI_MAX_SUPPORTED_PROTOCOLS + NDPI_MAX_NUM_CUSTOM_PROTOCOLS)",
          "291:         return (0);",
          "293:     switch (protoId) {",
          "295:         case NDPI_PROTOCOL_DNS:",
          "296:             return (1);",
          "297:             break;",
          "299:         default:",
          "300:             return (0);",
          "301:     }",
          "306:                            u_int16_t protocol_id, const char *_file, const char *_func, int _line)",
          "307: {",
          "308:     if (protocol_id < NDPI_MAX_SUPPORTED_PROTOCOLS + NDPI_MAX_NUM_CUSTOM_PROTOCOLS) {",
          "310:         if (ndpi_str && ndpi_str->ndpi_log_level >= NDPI_LOG_DEBUG && ndpi_str->ndpi_debug_printf != NULL) {",
          "311:             (*(ndpi_str->ndpi_debug_printf))(protocol_id, ndpi_str, NDPI_LOG_DEBUG, _file, _func, _line, \"exclude %s\\n\",",
          "312:                                              ndpi_get_proto_name(ndpi_str, protocol_id));",
          "313:         }",
          "314: #endif",
          "315:         NDPI_ADD_PROTOCOL_TO_BITMASK(flow->excluded_protocol_bitmask, protocol_id);",
          "",
          "[Added Lines]",
          "270: u_int8_t ndpi_is_subprotocol_informative(struct ndpi_detection_module_struct *ndpi_str, u_int16_t protoId) {",
          "271:   if(protoId >= NDPI_MAX_SUPPORTED_PROTOCOLS + NDPI_MAX_NUM_CUSTOM_PROTOCOLS)",
          "272:     return(0);",
          "274:   switch (protoId) {",
          "276:   case NDPI_PROTOCOL_DNS:",
          "277:     return(1);",
          "278:     break;",
          "280:   default:",
          "281:     return(0);",
          "282:   }",
          "287:                            u_int16_t protocol_id, const char *_file, const char *_func, int _line) {",
          "288:   if(protocol_id < NDPI_MAX_SUPPORTED_PROTOCOLS + NDPI_MAX_NUM_CUSTOM_PROTOCOLS) {",
          "290:     if(ndpi_str && ndpi_str->ndpi_log_level >= NDPI_LOG_DEBUG && ndpi_str->ndpi_debug_printf != NULL) {",
          "291:       (*(ndpi_str->ndpi_debug_printf))(protocol_id, ndpi_str, NDPI_LOG_DEBUG, _file, _func, _line, \"exclude %s\\n\",",
          "292:            ndpi_get_proto_name(ndpi_str, protocol_id));",
          "294: #endif",
          "295:     NDPI_ADD_PROTOCOL_TO_BITMASK(flow->excluded_protocol_bitmask, protocol_id);",
          "296:   }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "321: void ndpi_set_proto_defaults(struct ndpi_detection_module_struct *ndpi_str, ndpi_protocol_breed_t breed,",
          "322:                              u_int16_t protoId, u_int8_t can_have_a_subprotocol, u_int16_t tcp_master_protoId[2],",
          "323:                              u_int16_t udp_master_protoId[2], char *protoName, ndpi_protocol_category_t protoCategory,",
          "330: #ifdef DEBUG",
          "332: #endif",
          "337: #ifdef DEBUG",
          "339: #endif",
          "349:     ndpi_str->proto_defaults[protoId].protoId = protoId, ndpi_str->proto_defaults[protoId].protoBreed = breed;",
          "364: }",
          "376: }",
          "391: }",
          "395: static void addDefaultPort(struct ndpi_detection_module_struct *ndpi_str, ndpi_port_range *range,",
          "396:                            ndpi_proto_defaults_t *def, u_int8_t customUserProto, ndpi_default_ports_tree_node_t **root,",
          "422:     }",
          "423: }",
          "",
          "[Removed Lines]",
          "324:                              ndpi_port_range *tcpDefPorts, ndpi_port_range *udpDefPorts)",
          "325: {",
          "326:     char *name;",
          "327:     int j;",
          "329:     if (protoId >= NDPI_MAX_SUPPORTED_PROTOCOLS + NDPI_MAX_NUM_CUSTOM_PROTOCOLS) {",
          "331:         NDPI_LOG_ERR(ndpi_str, \"[NDPI] %s/protoId=%d: INTERNAL ERROR\\n\", protoName, protoId);",
          "333:         return;",
          "334:     }",
          "336:     if (ndpi_str->proto_defaults[protoId].protoName != NULL) {",
          "338:         NDPI_LOG_ERR(ndpi_str, \"[NDPI] %s/protoId=%d: already initialized. Ignoring it\\n\", protoName, protoId);",
          "340:         return;",
          "341:     }",
          "343:     name = ndpi_strdup(protoName);",
          "345:     if (ndpi_str->proto_defaults[protoId].protoName)",
          "346:         ndpi_free(ndpi_str->proto_defaults[protoId].protoName);",
          "348:     ndpi_str->proto_defaults[protoId].protoName = name, ndpi_str->proto_defaults[protoId].protoCategory = protoCategory,",
          "350:     ndpi_str->proto_defaults[protoId].can_have_a_subprotocol = can_have_a_subprotocol;",
          "352:     memcpy(&ndpi_str->proto_defaults[protoId].master_tcp_protoId, tcp_master_protoId, 2 * sizeof(u_int16_t));",
          "353:     memcpy(&ndpi_str->proto_defaults[protoId].master_udp_protoId, udp_master_protoId, 2 * sizeof(u_int16_t));",
          "355:     for (j = 0; j < MAX_DEFAULT_PORTS; j++) {",
          "356:         if (udpDefPorts[j].port_low != 0)",
          "357:             addDefaultPort(ndpi_str, &udpDefPorts[j], &ndpi_str->proto_defaults[protoId], 0, &ndpi_str->udpRoot,",
          "358:                            __FUNCTION__, __LINE__);",
          "360:         if (tcpDefPorts[j].port_low != 0)",
          "361:             addDefaultPort(ndpi_str, &tcpDefPorts[j], &ndpi_str->proto_defaults[protoId], 0, &ndpi_str->tcpRoot,",
          "362:                            __FUNCTION__, __LINE__);",
          "363:     }",
          "368: static int ndpi_default_ports_tree_node_t_cmp(const void *a, const void *b)",
          "369: {",
          "370:     ndpi_default_ports_tree_node_t *fa = (ndpi_default_ports_tree_node_t *) a;",
          "371:     ndpi_default_ports_tree_node_t *fb = (ndpi_default_ports_tree_node_t *) b;",
          "375:     return ((fa->default_port == fb->default_port) ? 0 : ((fa->default_port < fb->default_port) ? -1 : 1));",
          "380: void ndpi_default_ports_tree_node_t_walker(const void *node, const ndpi_VISIT which, const int depth)",
          "381: {",
          "382:     ndpi_default_ports_tree_node_t *f = *(ndpi_default_ports_tree_node_t **) node;",
          "384:     printf(\"<%d>Walk on node %s (%u)\\n\", depth,",
          "385:            which == ndpi_preorder ?",
          "386:                \"ndpi_preorder\" :",
          "387:                which == ndpi_postorder ?",
          "388:                \"ndpi_postorder\" :",
          "389:                which == ndpi_endorder ? \"ndpi_endorder\" : which == ndpi_leaf ? \"ndpi_leaf\" : \"unknown\",",
          "390:            f->default_port);",
          "397:                            const char *_func, int _line)",
          "398: {",
          "399:     u_int16_t port;",
          "401:     for (port = range->port_low; port <= range->port_high; port++) {",
          "402:         ndpi_default_ports_tree_node_t *node =",
          "403:             (ndpi_default_ports_tree_node_t *) ndpi_malloc(sizeof(ndpi_default_ports_tree_node_t));",
          "404:         ndpi_default_ports_tree_node_t *ret;",
          "406:         if (!node) {",
          "407:             NDPI_LOG_ERR(ndpi_str, \"%s:%d not enough memory\\n\", _func, _line);",
          "408:             break;",
          "409:         }",
          "411:         node->proto = def, node->default_port = port, node->customUserProto = customUserProto;",
          "412:         ret = (ndpi_default_ports_tree_node_t *) ndpi_tsearch(",
          "415:         if (ret != node) {",
          "416:             NDPI_LOG_DBG(ndpi_str, \"[NDPI] %s:%d found duplicate for port %u: overwriting it with new value\\n\", _func,",
          "417:                          _line, port);",
          "419:             ret->proto = def;",
          "420:             ndpi_free(node);",
          "421:         }",
          "",
          "[Added Lines]",
          "304:                              ndpi_port_range *tcpDefPorts, ndpi_port_range *udpDefPorts) {",
          "305:   char *name;",
          "306:   int j;",
          "308:   if(protoId >= NDPI_MAX_SUPPORTED_PROTOCOLS + NDPI_MAX_NUM_CUSTOM_PROTOCOLS) {",
          "310:     NDPI_LOG_ERR(ndpi_str, \"[NDPI] %s/protoId=%d: INTERNAL ERROR\\n\", protoName, protoId);",
          "312:     return;",
          "313:   }",
          "315:   if(ndpi_str->proto_defaults[protoId].protoName != NULL) {",
          "317:     NDPI_LOG_ERR(ndpi_str, \"[NDPI] %s/protoId=%d: already initialized. Ignoring it\\n\", protoName, protoId);",
          "319:     return;",
          "320:   }",
          "322:   name = ndpi_strdup(protoName);",
          "324:   if(ndpi_str->proto_defaults[protoId].protoName)",
          "325:     ndpi_free(ndpi_str->proto_defaults[protoId].protoName);",
          "327:   ndpi_str->proto_defaults[protoId].protoName = name, ndpi_str->proto_defaults[protoId].protoCategory = protoCategory,",
          "329:   ndpi_str->proto_defaults[protoId].can_have_a_subprotocol = can_have_a_subprotocol;",
          "331:   memcpy(&ndpi_str->proto_defaults[protoId].master_tcp_protoId, tcp_master_protoId, 2 * sizeof(u_int16_t));",
          "332:   memcpy(&ndpi_str->proto_defaults[protoId].master_udp_protoId, udp_master_protoId, 2 * sizeof(u_int16_t));",
          "334:   for (j = 0; j < MAX_DEFAULT_PORTS; j++) {",
          "335:     if(udpDefPorts[j].port_low != 0)",
          "336:       addDefaultPort(ndpi_str, &udpDefPorts[j], &ndpi_str->proto_defaults[protoId], 0, &ndpi_str->udpRoot,",
          "337:        __FUNCTION__, __LINE__);",
          "339:     if(tcpDefPorts[j].port_low != 0)",
          "340:       addDefaultPort(ndpi_str, &tcpDefPorts[j], &ndpi_str->proto_defaults[protoId], 0, &ndpi_str->tcpRoot,",
          "341:        __FUNCTION__, __LINE__);",
          "342:   }",
          "347: static int ndpi_default_ports_tree_node_t_cmp(const void *a, const void *b) {",
          "348:   ndpi_default_ports_tree_node_t *fa = (ndpi_default_ports_tree_node_t *) a;",
          "349:   ndpi_default_ports_tree_node_t *fb = (ndpi_default_ports_tree_node_t *) b;",
          "353:   return((fa->default_port == fb->default_port) ? 0 : ((fa->default_port < fb->default_port) ? -1 : 1));",
          "358: void ndpi_default_ports_tree_node_t_walker(const void *node, const ndpi_VISIT which, const int depth) {",
          "359:   ndpi_default_ports_tree_node_t *f = *(ndpi_default_ports_tree_node_t **) node;",
          "361:   printf(\"<%d>Walk on node %s (%u)\\n\", depth,",
          "362:   which == ndpi_preorder ?",
          "363:   \"ndpi_preorder\" :",
          "364:   which == ndpi_postorder ?",
          "365:   \"ndpi_postorder\" :",
          "366:   which == ndpi_endorder ? \"ndpi_endorder\" : which == ndpi_leaf ? \"ndpi_leaf\" : \"unknown\",",
          "367:   f->default_port);",
          "374:                            const char *_func, int _line) {",
          "375:   u_int16_t port;",
          "377:   for (port = range->port_low; port <= range->port_high; port++) {",
          "378:     ndpi_default_ports_tree_node_t *node =",
          "379:       (ndpi_default_ports_tree_node_t *) ndpi_malloc(sizeof(ndpi_default_ports_tree_node_t));",
          "380:     ndpi_default_ports_tree_node_t *ret;",
          "382:     if(!node) {",
          "383:       NDPI_LOG_ERR(ndpi_str, \"%s:%d not enough memory\\n\", _func, _line);",
          "384:       break;",
          "385:     }",
          "387:     node->proto = def, node->default_port = port, node->customUserProto = customUserProto;",
          "388:     ret = (ndpi_default_ports_tree_node_t *) ndpi_tsearch(",
          "391:     if(ret != node) {",
          "392:       NDPI_LOG_DBG(ndpi_str, \"[NDPI] %s:%d found duplicate for port %u: overwriting it with new value\\n\", _func,",
          "393:      _line, port);",
          "395:       ret->proto = def;",
          "396:       ndpi_free(node);",
          "398:   }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "430:   This function must be called with a semaphore set, this in order to avoid",
          "431:   changing the datastructures while using them",
          "449:     }",
          "452: }",
          "456: static int ndpi_string_to_automa(struct ndpi_detection_module_struct *ndpi_str, ndpi_automa *automa, char *value,",
          "457:                                  u_int16_t protocol_id, ndpi_protocol_category_t category, ndpi_protocol_breed_t breed,",
          "471:     ac_pattern.rep.breed = (u_int16_t) breed;",
          "473: #ifdef MATCH_DEBUG",
          "475: #endif",
          "489: }",
          "493: static int ndpi_add_host_url_subprotocol(struct ndpi_detection_module_struct *ndpi_str, char *_value, int protocol_id,",
          "502: #ifdef DEBUG",
          "504: #endif",
          "512: }",
          "516: #ifdef CODE_UNUSED",
          "517: int ndpi_add_content_subprotocol(struct ndpi_detection_module_struct *ndpi_str, char *value, int protocol_id,",
          "521: }",
          "522: #endif",
          "",
          "[Removed Lines]",
          "433: static int removeDefaultPort(ndpi_port_range *range, ndpi_proto_defaults_t *def, ndpi_default_ports_tree_node_t **root)",
          "434: {",
          "435:     ndpi_default_ports_tree_node_t node;",
          "436:     u_int16_t port;",
          "438:     for (port = range->port_low; port <= range->port_high; port++) {",
          "439:         ndpi_default_ports_tree_node_t *ret;",
          "441:         node.proto = def, node.default_port = port;",
          "442:         ret = (ndpi_default_ports_tree_node_t *) ndpi_tdelete(",
          "445:         if (ret != NULL) {",
          "446:             ndpi_free((ndpi_default_ports_tree_node_t *) ret);",
          "447:             return (0);",
          "448:         }",
          "451:     return (-1);",
          "458:                                  u_int8_t free_str_on_duplicate)",
          "459: {",
          "460:     AC_PATTERN_t ac_pattern;",
          "461:     AC_ERROR_t rc;",
          "463:     if ((value == NULL) || (protocol_id >= (NDPI_MAX_SUPPORTED_PROTOCOLS + NDPI_MAX_NUM_CUSTOM_PROTOCOLS))) {",
          "464:         NDPI_LOG_ERR(ndpi_str, \"[NDPI] protoId=%d: INTERNAL ERROR\\n\", protocol_id);",
          "465:         return (-1);",
          "466:     }",
          "468:     if (automa->ac_automa == NULL)",
          "469:         return (-2);",
          "470:     ac_pattern.astring = value, ac_pattern.rep.number = protocol_id, ac_pattern.rep.category = (u_int16_t) category,",
          "474:     printf(\"Adding to automa [%s][protocol_id: %u][category: %u][breed: %u]\\n\", value, protocol_id, category, breed);",
          "477:     if (value == NULL)",
          "478:         ac_pattern.length = 0;",
          "479:     else",
          "480:         ac_pattern.length = strlen(ac_pattern.astring);",
          "482:     rc = ac_automata_add(((AC_AUTOMATA_t *) automa->ac_automa), &ac_pattern);",
          "483:     if (rc != ACERR_DUPLICATE_PATTERN && rc != ACERR_SUCCESS)",
          "484:         return (-2);",
          "485:     if (rc == ACERR_DUPLICATE_PATTERN && free_str_on_duplicate)",
          "486:         ndpi_free(value);",
          "488:     return (0);",
          "494:                                          ndpi_protocol_category_t category, ndpi_protocol_breed_t breed)",
          "495: {",
          "496:     int rv;",
          "497:     char *value = ndpi_strdup(_value);",
          "499:     if (!value)",
          "500:         return (-1);",
          "503:     NDPI_LOG_DBG2(ndpi_str, \"[NDPI] Adding [%s][%d]\\n\", value, protocol_id);",
          "506:     rv = ndpi_string_to_automa(ndpi_str, &ndpi_str->host_automa, value, protocol_id, category, breed, 1);",
          "508:     if (rv != 0)",
          "509:         ndpi_free(value);",
          "511:     return (rv);",
          "518:                                  ndpi_protocol_category_t category, ndpi_protocol_breed_t breed)",
          "519: {",
          "520:     return (ndpi_string_to_automa(ndpi_str, &ndpi_str->content_automa, value, protocol_id, category, breed, 0));",
          "",
          "[Added Lines]",
          "409: static int removeDefaultPort(ndpi_port_range *range, ndpi_proto_defaults_t *def, ndpi_default_ports_tree_node_t **root) {",
          "410:   ndpi_default_ports_tree_node_t node;",
          "411:   u_int16_t port;",
          "413:   for (port = range->port_low; port <= range->port_high; port++) {",
          "414:     ndpi_default_ports_tree_node_t *ret;",
          "416:     node.proto = def, node.default_port = port;",
          "417:     ret = (ndpi_default_ports_tree_node_t *) ndpi_tdelete(",
          "420:     if(ret != NULL) {",
          "421:       ndpi_free((ndpi_default_ports_tree_node_t *) ret);",
          "422:       return(0);",
          "424:   }",
          "426:   return(-1);",
          "433:                                  u_int8_t free_str_on_duplicate) {",
          "434:   AC_PATTERN_t ac_pattern;",
          "435:   AC_ERROR_t rc;",
          "437:   if((value == NULL) || (protocol_id >= (NDPI_MAX_SUPPORTED_PROTOCOLS + NDPI_MAX_NUM_CUSTOM_PROTOCOLS))) {",
          "438:     NDPI_LOG_ERR(ndpi_str, \"[NDPI] protoId=%d: INTERNAL ERROR\\n\", protocol_id);",
          "439:     return(-1);",
          "440:   }",
          "442:   if(automa->ac_automa == NULL)",
          "443:     return(-2);",
          "444:   ac_pattern.astring = value, ac_pattern.rep.number = protocol_id, ac_pattern.rep.category = (u_int16_t) category,",
          "448:   printf(\"Adding to automa [%s][protocol_id: %u][category: %u][breed: %u]\\n\", value, protocol_id, category, breed);",
          "451:   if(value == NULL)",
          "452:     ac_pattern.length = 0;",
          "453:   else",
          "454:     ac_pattern.length = strlen(ac_pattern.astring);",
          "456:   rc = ac_automata_add(((AC_AUTOMATA_t *) automa->ac_automa), &ac_pattern);",
          "457:   if(rc != ACERR_DUPLICATE_PATTERN && rc != ACERR_SUCCESS)",
          "458:     return(-2);",
          "459:   if(rc == ACERR_DUPLICATE_PATTERN && free_str_on_duplicate)",
          "460:     ndpi_free(value);",
          "462:   return(0);",
          "468:                                          ndpi_protocol_category_t category, ndpi_protocol_breed_t breed) {",
          "469:   int rv;",
          "470:   char *value = ndpi_strdup(_value);",
          "472:   if(!value)",
          "473:     return(-1);",
          "476:   NDPI_LOG_DBG2(ndpi_str, \"[NDPI] Adding [%s][%d]\\n\", value, protocol_id);",
          "479:   rv = ndpi_string_to_automa(ndpi_str, &ndpi_str->host_automa, value, protocol_id, category, breed, 1);",
          "481:   if(rv != 0)",
          "482:     ndpi_free(value);",
          "484:   return(rv);",
          "491:                                  ndpi_protocol_category_t category, ndpi_protocol_breed_t breed) {",
          "492:   return(ndpi_string_to_automa(ndpi_str, &ndpi_str->content_automa, value, protocol_id, category, breed, 0));",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "529:   This function must be called with a semaphore set, this in order to avoid",
          "530:   changing the datastructures while using them",
          "536: }",
          "562: }",
          "566: #ifdef HAVE_HYPERSCAN",
          "587: }",
          "607: }",
          "658: #ifdef DEBUG",
          "660: #endif",
          "664:     }",
          "676: }",
          "687: }",
          "695: }",
          "697: #endif",
          "",
          "[Removed Lines]",
          "532: static int ndpi_remove_host_url_subprotocol(struct ndpi_detection_module_struct *ndpi_str, char *value, int protocol_id)",
          "533: {",
          "534:     NDPI_LOG_ERR(ndpi_str, \"[NDPI] Missing implementation for proto %s/%d\\n\", value, protocol_id);",
          "535:     return (-1);",
          "540: void ndpi_init_protocol_match(struct ndpi_detection_module_struct *ndpi_str, ndpi_protocol_match *match)",
          "541: {",
          "542:     u_int16_t no_master[2] = {NDPI_PROTOCOL_NO_MASTER_PROTO, NDPI_PROTOCOL_NO_MASTER_PROTO};",
          "543:     ndpi_port_range ports_a[MAX_DEFAULT_PORTS], ports_b[MAX_DEFAULT_PORTS];",
          "545:     if (ndpi_str->proto_defaults[match->protocol_id].protoName == NULL) {",
          "546:         ndpi_str->proto_defaults[match->protocol_id].protoName = ndpi_strdup(match->proto_name);",
          "548:         ndpi_str->proto_defaults[match->protocol_id].protoId = match->protocol_id;",
          "549:         ndpi_str->proto_defaults[match->protocol_id].protoCategory = match->protocol_category;",
          "550:         ndpi_str->proto_defaults[match->protocol_id].protoBreed = match->protocol_breed;",
          "552:         ndpi_set_proto_defaults(ndpi_str, ndpi_str->proto_defaults[match->protocol_id].protoBreed,",
          "553:                                 ndpi_str->proto_defaults[match->protocol_id].protoId, 0 /* can_have_a_subprotocol */,",
          "554:                                 no_master, no_master, ndpi_str->proto_defaults[match->protocol_id].protoName,",
          "555:                                 ndpi_str->proto_defaults[match->protocol_id].protoCategory,",
          "556:                                 ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "557:                                 ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "558:     }",
          "560:     ndpi_add_host_url_subprotocol(ndpi_str, match->string_to_match, match->protocol_id, match->protocol_category,",
          "561:                                   match->protocol_breed);",
          "568: static int hyperscan_load_patterns(struct hs *hs, u_int num_patterns, const char **expressions, unsigned int *ids)",
          "569: {",
          "570:     hs_compile_error_t *compile_err;",
          "572:     if (hs_compile_multi(expressions, NULL, ids, num_patterns, HS_MODE_BLOCK, NULL, &hs->database, &compile_err) !=",
          "573:         HS_SUCCESS) {",
          "574:         NDPI_LOG_ERR(ndpi_str, \"Unable to initialize hyperscan database\\n\");",
          "575:         hs_free_compile_error(compile_err);",
          "576:         return (-1);",
          "577:     }",
          "579:     hs->scratch = NULL;",
          "580:     if (hs_alloc_scratch(hs->database, &hs->scratch) != HS_SUCCESS) {",
          "581:         NDPI_LOG_ERR(ndpi_str, \"Unable to allocate hyperscan scratch space\\n\");",
          "582:         hs_free_database(hs->database);",
          "583:         return (-1);",
          "584:     }",
          "586:     return (0);",
          "591: static char *string2hex(const char *pat)",
          "592: {",
          "593:     u_int patlen, i;",
          "594:     char *hexbuf, *buf;",
          "596:     patlen = strlen(pat);",
          "597:     hexbuf = (char *) ndpi_calloc(sizeof(char), patlen * 4 + 1);",
          "598:     if (!hexbuf)",
          "599:         return (NULL);",
          "601:     for (i = 0, buf = hexbuf; i < patlen; i++, buf += 4) {",
          "602:         snprintf(buf, 5, \"\\\\x%02x\", (unsigned char) pat[i]);",
          "603:     }",
          "606:     return (hexbuf);",
          "611: static int init_hyperscan(struct ndpi_detection_module_struct *ndpi_str)",
          "612: {",
          "613:     u_int num_patterns = 0, i, j;",
          "614:     char **expressions;",
          "615:     unsigned int *ids;",
          "616:     unsigned char *need_to_be_free;",
          "617:     struct hs *hs;",
          "618:     int rc;",
          "620:     ndpi_str->hyperscan = (void *) ndpi_malloc(sizeof(struct hs));",
          "621:     if (!ndpi_str->hyperscan)",
          "622:         return (-1);",
          "623:     hs = (struct hs *) ndpi_str->hyperscan;",
          "625:     for (i = 0; (host_match[i].string_to_match != NULL) || (host_match[i].pattern_to_match != NULL); i++)",
          "626:         num_patterns++;",
          "628:     expressions = (char **) ndpi_calloc(sizeof(char *), num_patterns + 1);",
          "629:     if (!expressions)",
          "630:         return (-1);",
          "632:     ids = (unsigned int *) ndpi_calloc(sizeof(unsigned int), num_patterns + 1);",
          "633:     if (!ids) {",
          "634:         ndpi_free(expressions);",
          "635:         return (-1);",
          "636:     }",
          "638:     need_to_be_free = (unsigned char *) ndpi_calloc(sizeof(unsigned char), num_patterns + 1);",
          "639:     if (!need_to_be_free) {",
          "640:         ndpi_free(expressions);",
          "641:         ndpi_free(ids);",
          "642:         return (-1);",
          "643:     }",
          "645:     for (i = 0, j = 0; host_match[i].string_to_match != NULL || host_match[i].pattern_to_match != NULL; i++) {",
          "646:         if (host_match[i].pattern_to_match) {",
          "647:             expressions[j] = host_match[i].pattern_to_match;",
          "648:             ids[j] = host_match[i].protocol_id;",
          "649:             need_to_be_free[j] = 0;",
          "650:             ++j;",
          "651:         } else {",
          "652:             expressions[j] = string2hex(host_match[i].string_to_match);",
          "653:             if (expressions[j] != NULL) {",
          "654:                 ids[j] = host_match[i].protocol_id;",
          "655:                 need_to_be_free[j] = 1;",
          "656:                 ++j;",
          "657:             } else {",
          "659:                 printf(\"Fail to calloc memory for %s\\n\", host_match[i].string_to_match);",
          "661:             }",
          "662:         }",
          "666:     rc = hyperscan_load_patterns(hs, j, (const char **) expressions, ids);",
          "668:     for (i = 0; i < j; ++i)",
          "669:         if (need_to_be_free[i])",
          "670:             ndpi_free(expressions[i]);",
          "672:     ndpi_free(expressions), ndpi_free(ids);",
          "673:     ndpi_free(need_to_be_free);",
          "675:     return (rc);",
          "680: static void free_hyperscan_memory(struct hs *h)",
          "681: {",
          "682:     if (h) {",
          "683:         hs_free_scratch(h->scratch);",
          "684:         hs_free_database(h->database);",
          "685:         ndpi_free(h);",
          "686:     }",
          "691: static void destroy_hyperscan(struct ndpi_detection_module_struct *ndpi_str)",
          "692: {",
          "693:     if (ndpi_str->hyperscan)",
          "694:         free_hyperscan_memory((struct hs *) ndpi_str->hyperscan);",
          "",
          "[Added Lines]",
          "504: static int ndpi_remove_host_url_subprotocol(struct ndpi_detection_module_struct *ndpi_str, char *value, int protocol_id) {",
          "505:   NDPI_LOG_ERR(ndpi_str, \"[NDPI] Missing implementation for proto %s/%d\\n\", value, protocol_id);",
          "506:   return(-1);",
          "511: void ndpi_init_protocol_match(struct ndpi_detection_module_struct *ndpi_str, ndpi_protocol_match *match) {",
          "512:   u_int16_t no_master[2] = {NDPI_PROTOCOL_NO_MASTER_PROTO, NDPI_PROTOCOL_NO_MASTER_PROTO};",
          "513:   ndpi_port_range ports_a[MAX_DEFAULT_PORTS], ports_b[MAX_DEFAULT_PORTS];",
          "515:   if(ndpi_str->proto_defaults[match->protocol_id].protoName == NULL) {",
          "516:     ndpi_str->proto_defaults[match->protocol_id].protoName = ndpi_strdup(match->proto_name);",
          "518:     ndpi_str->proto_defaults[match->protocol_id].protoId = match->protocol_id;",
          "519:     ndpi_str->proto_defaults[match->protocol_id].protoCategory = match->protocol_category;",
          "520:     ndpi_str->proto_defaults[match->protocol_id].protoBreed = match->protocol_breed;",
          "522:     ndpi_set_proto_defaults(ndpi_str, ndpi_str->proto_defaults[match->protocol_id].protoBreed,",
          "523:        ndpi_str->proto_defaults[match->protocol_id].protoId, 0 /* can_have_a_subprotocol */,",
          "524:        no_master, no_master, ndpi_str->proto_defaults[match->protocol_id].protoName,",
          "525:        ndpi_str->proto_defaults[match->protocol_id].protoCategory,",
          "526:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "527:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "528:   }",
          "530:   ndpi_add_host_url_subprotocol(ndpi_str, match->string_to_match, match->protocol_id, match->protocol_category,",
          "531:     match->protocol_breed);",
          "538: static int hyperscan_load_patterns(struct hs *hs, u_int num_patterns, const char **expressions, unsigned int *ids) {",
          "539:   hs_compile_error_t *compile_err;",
          "541:   if(hs_compile_multi(expressions, NULL, ids, num_patterns, HS_MODE_BLOCK, NULL, &hs->database, &compile_err) !=",
          "542:      HS_SUCCESS) {",
          "543:     NDPI_LOG_ERR(ndpi_str, \"Unable to initialize hyperscan database\\n\");",
          "544:     hs_free_compile_error(compile_err);",
          "545:     return(-1);",
          "546:   }",
          "548:   hs->scratch = NULL;",
          "549:   if(hs_alloc_scratch(hs->database, &hs->scratch) != HS_SUCCESS) {",
          "550:     NDPI_LOG_ERR(ndpi_str, \"Unable to allocate hyperscan scratch space\\n\");",
          "551:     hs_free_database(hs->database);",
          "552:     return(-1);",
          "553:   }",
          "555:   return(0);",
          "560: static char *string2hex(const char *pat) {",
          "561:   u_int patlen, i;",
          "562:   char *hexbuf, *buf;",
          "564:   patlen = strlen(pat);",
          "565:   hexbuf = (char *) ndpi_calloc(sizeof(char), patlen * 4 + 1);",
          "566:   if(!hexbuf)",
          "567:     return(NULL);",
          "569:   for (i = 0, buf = hexbuf; i < patlen; i++, buf += 4) {",
          "570:     snprintf(buf, 5, \"\\\\x%02x\", (unsigned char) pat[i]);",
          "571:   }",
          "574:   return(hexbuf);",
          "579: static int init_hyperscan(struct ndpi_detection_module_struct *ndpi_str) {",
          "580:   u_int num_patterns = 0, i, j;",
          "581:   char **expressions;",
          "582:   unsigned int *ids;",
          "583:   unsigned char *need_to_be_free;",
          "584:   struct hs *hs;",
          "585:   int rc;",
          "587:   ndpi_str->hyperscan = (void *) ndpi_malloc(sizeof(struct hs));",
          "588:   if(!ndpi_str->hyperscan)",
          "589:     return(-1);",
          "590:   hs = (struct hs *) ndpi_str->hyperscan;",
          "592:   for (i = 0; (host_match[i].string_to_match != NULL) || (host_match[i].pattern_to_match != NULL); i++)",
          "593:     num_patterns++;",
          "595:   expressions = (char **) ndpi_calloc(sizeof(char *), num_patterns + 1);",
          "596:   if(!expressions)",
          "597:     return(-1);",
          "599:   ids = (unsigned int *) ndpi_calloc(sizeof(unsigned int), num_patterns + 1);",
          "600:   if(!ids) {",
          "601:     ndpi_free(expressions);",
          "602:     return(-1);",
          "603:   }",
          "605:   need_to_be_free = (unsigned char *) ndpi_calloc(sizeof(unsigned char), num_patterns + 1);",
          "606:   if(!need_to_be_free) {",
          "607:     ndpi_free(expressions);",
          "608:     ndpi_free(ids);",
          "609:     return(-1);",
          "610:   }",
          "612:   for (i = 0, j = 0; host_match[i].string_to_match != NULL || host_match[i].pattern_to_match != NULL; i++) {",
          "613:     if(host_match[i].pattern_to_match) {",
          "614:       expressions[j] = host_match[i].pattern_to_match;",
          "615:       ids[j] = host_match[i].protocol_id;",
          "616:       need_to_be_free[j] = 0;",
          "617:       ++j;",
          "618:     } else {",
          "619:       expressions[j] = string2hex(host_match[i].string_to_match);",
          "620:       if(expressions[j] != NULL) {",
          "621:  ids[j] = host_match[i].protocol_id;",
          "622:  need_to_be_free[j] = 1;",
          "623:  ++j;",
          "624:       } else {",
          "626:  printf(\"Fail to calloc memory for %s\\n\", host_match[i].string_to_match);",
          "628:       }",
          "631:   }",
          "633:   rc = hyperscan_load_patterns(hs, j, (const char **) expressions, ids);",
          "635:   for (i = 0; i < j; ++i)",
          "636:     if(need_to_be_free[i])",
          "637:       ndpi_free(expressions[i]);",
          "639:   ndpi_free(expressions), ndpi_free(ids);",
          "640:   ndpi_free(need_to_be_free);",
          "642:   return(rc);",
          "647: static void free_hyperscan_memory(struct hs *h) {",
          "648:   if(h) {",
          "649:     hs_free_scratch(h->scratch);",
          "650:     hs_free_database(h->database);",
          "651:     ndpi_free(h);",
          "652:   }",
          "657: static void destroy_hyperscan(struct ndpi_detection_module_struct *ndpi_str) {",
          "658:   if(ndpi_str->hyperscan)",
          "659:     free_hyperscan_memory((struct hs *) ndpi_str->hyperscan);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "715:     }",
          "716: }",
          "724: #ifdef HAVE_HYPERSCAN",
          "727: #endif",
          "734: #ifdef MATCH_DEBUG",
          "736: #endif",
          "744: }",
          "748: int ndpi_set_detection_preferences(struct ndpi_detection_module_struct *ndpi_str, ndpi_detection_preference pref,",
          "761: }",
          "781:     }",
          "782: }",
          "",
          "[Removed Lines]",
          "702: void ndpi_self_check_host_match()",
          "703: {",
          "704:     u_int32_t i, j;",
          "706:     for (i = 0; host_match[i].string_to_match != NULL; i++) {",
          "707:         for (j = 0; host_match[j].string_to_match != NULL; j++) {",
          "708:             if ((i != j) && (strcmp(host_match[i].string_to_match, host_match[j].string_to_match) == 0)) {",
          "709:                 printf(\"[INTERNAL ERROR]: Duplicate string detected '%s' [id: %u, id %u]\\n\",",
          "710:                        host_match[i].string_to_match, i, j);",
          "711:                 printf(\"\\nPlease fix host_match[] in ndpi_content_match.c.inc\\n\");",
          "712:                 exit(0);",
          "713:             }",
          "714:         }",
          "720: static void init_string_based_protocols(struct ndpi_detection_module_struct *ndpi_str)",
          "721: {",
          "722:     int i;",
          "726:     init_hyperscan(ndpi_str);",
          "729:     for (i = 0; host_match[i].string_to_match != NULL; i++)",
          "730:         ndpi_init_protocol_match(ndpi_str, &host_match[i]);",
          "732:     ndpi_enable_loaded_categories(ndpi_str);",
          "738:     for (i = 0; ndpi_en_bigrams[i] != NULL; i++)",
          "739:         ndpi_string_to_automa(ndpi_str, &ndpi_str->bigrams_automa, (char *) ndpi_en_bigrams[i], 1, 1, 1, 0);",
          "741:     for (i = 0; ndpi_en_impossible_bigrams[i] != NULL; i++)",
          "742:         ndpi_string_to_automa(ndpi_str, &ndpi_str->impossible_bigrams_automa, (char *) ndpi_en_impossible_bigrams[i], 1,",
          "743:                               1, 1, 0);",
          "749:                                    int value)",
          "750: {",
          "751:     switch (pref) {",
          "752:         case ndpi_pref_direction_detect_disable:",
          "753:             ndpi_str->direction_detect_disable = (u_int8_t) value;",
          "754:             break;",
          "756:         default:",
          "757:             return (-1);",
          "758:     }",
          "760:     return (0);",
          "765: static void ndpi_validate_protocol_initialization(struct ndpi_detection_module_struct *ndpi_str)",
          "766: {",
          "767:     int i;",
          "769:     for (i = 0; i < (int) ndpi_str->ndpi_num_supported_protocols; i++) {",
          "770:         if (ndpi_str->proto_defaults[i].protoName == NULL) {",
          "771:             NDPI_LOG_ERR(ndpi_str,",
          "772:                          \"[NDPI] INTERNAL ERROR missing protoName initialization for [protoId=%d]: recovering\\n\", i);",
          "773:         } else {",
          "774:             if ((i != NDPI_PROTOCOL_UNKNOWN) &&",
          "775:                 (ndpi_str->proto_defaults[i].protoCategory == NDPI_PROTOCOL_CATEGORY_UNSPECIFIED)) {",
          "776:                 NDPI_LOG_ERR(ndpi_str,",
          "777:                              \"[NDPI] INTERNAL ERROR missing category [protoId=%d/%s] initialization: recovering\\n\", i,",
          "778:                              ndpi_str->proto_defaults[i].protoName ? ndpi_str->proto_defaults[i].protoName : \"???\");",
          "779:             }",
          "780:         }",
          "",
          "[Added Lines]",
          "667: void ndpi_self_check_host_match() {",
          "668:   u_int32_t i, j;",
          "670:   for (i = 0; host_match[i].string_to_match != NULL; i++) {",
          "671:     for (j = 0; host_match[j].string_to_match != NULL; j++) {",
          "672:       if((i != j) && (strcmp(host_match[i].string_to_match, host_match[j].string_to_match) == 0)) {",
          "673:  printf(\"[INTERNAL ERROR]: Duplicate string detected '%s' [id: %u, id %u]\\n\",",
          "674:         host_match[i].string_to_match, i, j);",
          "675:  printf(\"\\nPlease fix host_match[] in ndpi_content_match.c.inc\\n\");",
          "676:  exit(0);",
          "677:       }",
          "679:   }",
          "684: static void init_string_based_protocols(struct ndpi_detection_module_struct *ndpi_str) {",
          "685:   int i;",
          "689:   init_hyperscan(ndpi_str);",
          "692:   for (i = 0; host_match[i].string_to_match != NULL; i++)",
          "693:     ndpi_init_protocol_match(ndpi_str, &host_match[i]);",
          "695:   ndpi_enable_loaded_categories(ndpi_str);",
          "701:   for (i = 0; ndpi_en_bigrams[i] != NULL; i++)",
          "702:     ndpi_string_to_automa(ndpi_str, &ndpi_str->bigrams_automa, (char *) ndpi_en_bigrams[i], 1, 1, 1, 0);",
          "704:   for (i = 0; ndpi_en_impossible_bigrams[i] != NULL; i++)",
          "705:     ndpi_string_to_automa(ndpi_str, &ndpi_str->impossible_bigrams_automa, (char *) ndpi_en_impossible_bigrams[i], 1,",
          "706:      1, 1, 0);",
          "712:                                    int value) {",
          "713:   switch (pref) {",
          "714:   case ndpi_pref_direction_detect_disable:",
          "715:     ndpi_str->direction_detect_disable = (u_int8_t) value;",
          "716:     break;",
          "718:   default:",
          "719:     return(-1);",
          "720:   }",
          "722:   return(0);",
          "727: static void ndpi_validate_protocol_initialization(struct ndpi_detection_module_struct *ndpi_str) {",
          "728:   int i;",
          "730:   for (i = 0; i < (int) ndpi_str->ndpi_num_supported_protocols; i++) {",
          "731:     if(ndpi_str->proto_defaults[i].protoName == NULL) {",
          "732:       NDPI_LOG_ERR(ndpi_str,",
          "733:      \"[NDPI] INTERNAL ERROR missing protoName initialization for [protoId=%d]: recovering\\n\", i);",
          "734:     } else {",
          "735:       if((i != NDPI_PROTOCOL_UNKNOWN) &&",
          "736:   (ndpi_str->proto_defaults[i].protoCategory == NDPI_PROTOCOL_CATEGORY_UNSPECIFIED)) {",
          "737:  NDPI_LOG_ERR(ndpi_str,",
          "738:        \"[NDPI] INTERNAL ERROR missing category [protoId=%d/%s] initialization: recovering\\n\", i,",
          "739:        ndpi_str->proto_defaults[i].protoName ? ndpi_str->proto_defaults[i].protoName : \"???\");",
          "740:       }",
          "742:   }",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "789:    Do NOT add web services (NDPI_SERVICE_xxx) here.",
          "1649: #ifdef CUSTOM_NDPI_PROTOCOLS",
          "1650: #include \"../../../nDPI-custom/custom_ndpi_main.c\"",
          "1651: #endif",
          "1657: }",
          "",
          "[Removed Lines]",
          "791: static void ndpi_init_protocol_defaults(struct ndpi_detection_module_struct *ndpi_str)",
          "792: {",
          "793:     ndpi_port_range ports_a[MAX_DEFAULT_PORTS], ports_b[MAX_DEFAULT_PORTS];",
          "794:     u_int16_t no_master[2] = {NDPI_PROTOCOL_NO_MASTER_PROTO, NDPI_PROTOCOL_NO_MASTER_PROTO}, custom_master[2];",
          "797:     memset(ndpi_str->proto_defaults, 0, sizeof(ndpi_str->proto_defaults));",
          "799:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_UNRATED, NDPI_PROTOCOL_UNKNOWN, 0 /* can_have_a_subprotocol */,",
          "800:                             no_master, no_master, \"Unknown\", NDPI_PROTOCOL_CATEGORY_UNSPECIFIED,",
          "801:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "802:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "803:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_UNSAFE, NDPI_PROTOCOL_FTP_CONTROL, 0 /* can_have_a_subprotocol */,",
          "804:                             no_master, no_master, \"FTP_CONTROL\", NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,",
          "805:                             ndpi_build_default_ports(ports_a, 21, 0, 0, 0, 0) /* TCP */,",
          "806:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "807:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_FTP_DATA, 0 /* can_have_a_subprotocol */,",
          "808:                             no_master, no_master, \"FTP_DATA\", NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,",
          "809:                             ndpi_build_default_ports(ports_a, 20, 0, 0, 0, 0) /* TCP */,",
          "810:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "811:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_UNSAFE, NDPI_PROTOCOL_MAIL_POP, 0 /* can_have_a_subprotocol */,",
          "812:                             no_master, no_master, \"POP3\", NDPI_PROTOCOL_CATEGORY_MAIL,",
          "813:                             ndpi_build_default_ports(ports_a, 110, 0, 0, 0, 0) /* TCP */,",
          "814:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "815:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_SAFE, NDPI_PROTOCOL_MAIL_POPS, 0 /* can_have_a_subprotocol */,",
          "816:                             no_master, no_master, \"POPS\", NDPI_PROTOCOL_CATEGORY_MAIL,",
          "817:                             ndpi_build_default_ports(ports_a, 995, 0, 0, 0, 0) /* TCP */,",
          "818:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "819:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_MAIL_SMTP, 0 /* can_have_a_subprotocol */,",
          "820:                             no_master, no_master, \"SMTP\", NDPI_PROTOCOL_CATEGORY_MAIL,",
          "821:                             ndpi_build_default_ports(ports_a, 25, 0, 0, 0, 0) /* TCP */,",
          "822:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "823:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_SAFE, NDPI_PROTOCOL_MAIL_SMTPS, 0 /* can_have_a_subprotocol */,",
          "824:                             no_master, no_master, \"SMTPS\", NDPI_PROTOCOL_CATEGORY_MAIL,",
          "825:                             ndpi_build_default_ports(ports_a, 465, 587, 0, 0, 0) /* TCP */,",
          "826:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "827:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_UNSAFE, NDPI_PROTOCOL_MAIL_IMAP, 0 /* can_have_a_subprotocol */,",
          "828:                             no_master, no_master, \"IMAP\", NDPI_PROTOCOL_CATEGORY_MAIL,",
          "829:                             ndpi_build_default_ports(ports_a, 143, 0, 0, 0, 0) /* TCP */,",
          "830:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "831:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_SAFE, NDPI_PROTOCOL_MAIL_IMAPS, 0 /* can_have_a_subprotocol */,",
          "832:                             no_master, no_master, \"IMAPS\", NDPI_PROTOCOL_CATEGORY_MAIL,",
          "833:                             ndpi_build_default_ports(ports_a, 993, 0, 0, 0, 0) /* TCP */,",
          "834:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "835:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_DNS, 1 /* can_have_a_subprotocol */,",
          "836:                             no_master, no_master, \"DNS\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "837:                             ndpi_build_default_ports(ports_a, 53, 0, 0, 0, 0) /* TCP */,",
          "838:                             ndpi_build_default_ports(ports_b, 53, 0, 0, 0, 0) /* UDP */);",
          "839:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_IPP, 0 /* can_have_a_subprotocol */,",
          "840:                             no_master, no_master, \"IPP\", NDPI_PROTOCOL_CATEGORY_SYSTEM_OS,",
          "841:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "842:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "843:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_IMO, 0 /* can_have_a_subprotocol */,",
          "844:                             no_master, no_master, \"IMO\", NDPI_PROTOCOL_CATEGORY_VOIP,",
          "845:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "846:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "847:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_HTTP, 1 /* can_have_a_subprotocol */,",
          "848:                             no_master, no_master, \"HTTP\", NDPI_PROTOCOL_CATEGORY_WEB,",
          "849:                             ndpi_build_default_ports(ports_a, 80, 0 /* ntop */, 0, 0, 0) /* TCP */,",
          "850:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "851:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_MDNS, 1 /* can_have_a_subprotocol */,",
          "852:                             no_master, no_master, \"MDNS\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "853:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "854:                             ndpi_build_default_ports(ports_b, 5353, 5354, 0, 0, 0) /* UDP */);",
          "855:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_NTP, 0 /* can_have_a_subprotocol */,",
          "856:                             no_master, no_master, \"NTP\", NDPI_PROTOCOL_CATEGORY_SYSTEM_OS,",
          "857:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "858:                             ndpi_build_default_ports(ports_b, 123, 0, 0, 0, 0) /* UDP */);",
          "859:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_NETBIOS, 0 /* can_have_a_subprotocol */,",
          "860:                             no_master, no_master, \"NetBIOS\", NDPI_PROTOCOL_CATEGORY_SYSTEM_OS,",
          "861:                             ndpi_build_default_ports(ports_a, 139, 0, 0, 0, 0) /* TCP */,",
          "862:                             ndpi_build_default_ports(ports_b, 137, 138, 139, 0, 0) /* UDP */);",
          "863:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_NFS, 0 /* can_have_a_subprotocol */,",
          "864:                             no_master, no_master, \"NFS\", NDPI_PROTOCOL_CATEGORY_DATA_TRANSFER,",
          "865:                             ndpi_build_default_ports(ports_a, 2049, 0, 0, 0, 0) /* TCP */,",
          "866:                             ndpi_build_default_ports(ports_b, 2049, 0, 0, 0, 0) /* UDP */);",
          "867:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_SSDP, 0 /* can_have_a_subprotocol */,",
          "868:                             no_master, no_master, \"SSDP\", NDPI_PROTOCOL_CATEGORY_SYSTEM_OS,",
          "869:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "870:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "871:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_BGP, 0 /* can_have_a_subprotocol */,",
          "872:                             no_master, no_master, \"BGP\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "873:                             ndpi_build_default_ports(ports_a, 179, 2605, 0, 0, 0) /* TCP */,",
          "874:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "875:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_SNMP, 0 /* can_have_a_subprotocol */,",
          "876:                             no_master, no_master, \"SNMP\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "877:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "878:                             ndpi_build_default_ports(ports_b, 161, 162, 0, 0, 0) /* UDP */);",
          "879:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_XDMCP, 0 /* can_have_a_subprotocol */,",
          "880:                             no_master, no_master, \"XDMCP\", NDPI_PROTOCOL_CATEGORY_REMOTE_ACCESS,",
          "881:                             ndpi_build_default_ports(ports_a, 177, 0, 0, 0, 0) /* TCP */,",
          "882:                             ndpi_build_default_ports(ports_b, 177, 0, 0, 0, 0) /* UDP */);",
          "883:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_DANGEROUS, NDPI_PROTOCOL_SMBV1, 0 /* can_have_a_subprotocol */,",
          "884:                             no_master, no_master, \"SMBv1\", NDPI_PROTOCOL_CATEGORY_SYSTEM_OS,",
          "885:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "886:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "887:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_SYSLOG, 0 /* can_have_a_subprotocol */,",
          "888:                             no_master, no_master, \"Syslog\", NDPI_PROTOCOL_CATEGORY_SYSTEM_OS,",
          "889:                             ndpi_build_default_ports(ports_a, 514, 0, 0, 0, 0) /* TCP */,",
          "890:                             ndpi_build_default_ports(ports_b, 514, 0, 0, 0, 0) /* UDP */);",
          "891:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_DHCP, 0 /* can_have_a_subprotocol */,",
          "892:                             no_master, no_master, \"DHCP\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "893:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "894:                             ndpi_build_default_ports(ports_b, 67, 68, 0, 0, 0) /* UDP */);",
          "895:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_POSTGRES, 0 /* can_have_a_subprotocol */,",
          "896:                             no_master, no_master, \"PostgreSQL\", NDPI_PROTOCOL_CATEGORY_DATABASE,",
          "897:                             ndpi_build_default_ports(ports_a, 5432, 0, 0, 0, 0) /* TCP */,",
          "898:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "899:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_MYSQL, 0 /* can_have_a_subprotocol */,",
          "900:                             no_master, no_master, \"MySQL\", NDPI_PROTOCOL_CATEGORY_DATABASE,",
          "901:                             ndpi_build_default_ports(ports_a, 3306, 0, 0, 0, 0) /* TCP */,",
          "902:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "903:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_POTENTIALLY_DANGEROUS, NDPI_PROTOCOL_DIRECT_DOWNLOAD_LINK,",
          "904:                             0 /* can_have_a_subprotocol */, no_master, no_master, \"Direct_Download_Link\",",
          "905:                             NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,",
          "906:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "907:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "908:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_POTENTIALLY_DANGEROUS, NDPI_PROTOCOL_APPLEJUICE,",
          "909:                             0 /* can_have_a_subprotocol */, no_master, no_master, \"AppleJuice\",",
          "910:                             NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,",
          "911:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "912:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "913:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_POTENTIALLY_DANGEROUS, NDPI_PROTOCOL_DIRECTCONNECT,",
          "914:                             0 /* can_have_a_subprotocol */, no_master, no_master, \"DirectConnect\",",
          "915:                             NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,",
          "916:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "917:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "918:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_NATS,",
          "919:                             0 /* can_have_a_subprotocol */, no_master, no_master, \"Nats\",",
          "920:                             NDPI_PROTOCOL_CATEGORY_RPC,",
          "921:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "922:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "923:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_SAFE, NDPI_PROTOCOL_NTOP, 0 /* can_have_a_subprotocol */, no_master,",
          "924:                             no_master, \"ntop\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "925:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "926:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "927:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_VMWARE, 0 /* can_have_a_subprotocol */,",
          "928:                             no_master, no_master, \"VMware\", NDPI_PROTOCOL_CATEGORY_REMOTE_ACCESS,",
          "929:                             ndpi_build_default_ports(ports_a, 903, 0, 0, 0, 0) /* TCP */,",
          "930:                             ndpi_build_default_ports(ports_b, 902, 903, 0, 0, 0) /* UDP */);",
          "931:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_SAFE, NDPI_PROTOCOL_FBZERO, 0 /* can_have_a_subprotocol */,",
          "932:                             no_master, no_master, \"FacebookZero\", NDPI_PROTOCOL_CATEGORY_SOCIAL_NETWORK,",
          "933:                             ndpi_build_default_ports(ports_a, 443, 0, 0, 0, 0) /* TCP */,",
          "934:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "935:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_POTENTIALLY_DANGEROUS, NDPI_PROTOCOL_KONTIKI,",
          "936:                             0 /* can_have_a_subprotocol */, no_master, no_master, \"Kontiki\",",
          "937:                             NDPI_PROTOCOL_CATEGORY_MEDIA, ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "938:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "939:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_POTENTIALLY_DANGEROUS, NDPI_PROTOCOL_OPENFT,",
          "940:                             0 /* can_have_a_subprotocol */, no_master, no_master, \"OpenFT\",",
          "941:                             NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,",
          "942:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "943:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "944:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_POTENTIALLY_DANGEROUS, NDPI_PROTOCOL_FASTTRACK,",
          "945:                             0 /* can_have_a_subprotocol */, no_master, no_master, \"FastTrack\",",
          "946:                             NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,",
          "947:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "948:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "949:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_POTENTIALLY_DANGEROUS, NDPI_PROTOCOL_GNUTELLA,",
          "950:                             0 /* can_have_a_subprotocol */, no_master, no_master, \"Gnutella\",",
          "951:                             NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,",
          "952:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "953:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "954:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_UNSAFE, NDPI_PROTOCOL_EDONKEY, 0 /* can_have_a_subprotocol */,",
          "955:                             no_master, no_master, \"eDonkey\", NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,",
          "956:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "957:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "958:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_UNSAFE, NDPI_PROTOCOL_BITTORRENT, 0 /* can_have_a_subprotocol */,",
          "959:                             no_master, no_master, \"BitTorrent\", NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,",
          "960:                             ndpi_build_default_ports(ports_a, 51413, 53646, 0, 0, 0) /* TCP */,",
          "961:                             ndpi_build_default_ports(ports_b, 6771, 51413, 0, 0, 0) /* UDP */);",
          "962:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_SKYPE, 0 /* can_have_a_subprotocol */,",
          "963:                             no_master, no_master, \"Skype\", NDPI_PROTOCOL_CATEGORY_VOIP,",
          "964:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "965:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "966:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_SKYPE_CALL,",
          "967:                             0 /* can_have_a_subprotocol */, no_master, no_master, \"SkypeCall\",",
          "968:                             NDPI_PROTOCOL_CATEGORY_VOIP, ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "969:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "970:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_TIKTOK, 0 /* can_have_a_subprotocol */,",
          "971:                             no_master, no_master, \"TikTok\", NDPI_PROTOCOL_CATEGORY_SOCIAL_NETWORK,",
          "972:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "973:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "974:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_TEREDO, 0 /* can_have_a_subprotocol */,",
          "975:                             no_master, no_master, \"Teredo\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "976:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "977:                             ndpi_build_default_ports(ports_b, 3544, 0, 0, 0, 0) /* UDP */);",
          "978:     ndpi_set_proto_defaults(",
          "980:         no_master, \"WeChat\", NDPI_PROTOCOL_CATEGORY_CHAT, ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "981:         ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "982:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_MEMCACHED, 0 /* can_have_a_subprotocol */,",
          "983:                             no_master, no_master, \"Memcached\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "984:                             ndpi_build_default_ports(ports_a, 11211, 0, 0, 0, 0) /* TCP */,",
          "985:                             ndpi_build_default_ports(ports_b, 11211, 0, 0, 0, 0) /* UDP */);",
          "986:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_SMBV23, 0 /* can_have_a_subprotocol */,",
          "987:                             no_master, no_master, \"SMBv23\", NDPI_PROTOCOL_CATEGORY_SYSTEM_OS,",
          "988:                             ndpi_build_default_ports(ports_a, 445, 0, 0, 0, 0) /* TCP */,",
          "989:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "990:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_UNSAFE, NDPI_PROTOCOL_MINING, 0 /* can_have_a_subprotocol */,",
          "991:                             no_master, no_master, \"Mining\", CUSTOM_CATEGORY_MINING,",
          "992:                             ndpi_build_default_ports(ports_a, 8333, 30303, 0, 0, 0) /* TCP */,",
          "993:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "994:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_NEST_LOG_SINK,",
          "995:                             0 /* can_have_a_subprotocol */, no_master, no_master, \"NestLogSink\",",
          "996:                             NDPI_PROTOCOL_CATEGORY_CLOUD,",
          "997:                             ndpi_build_default_ports(ports_a, 11095, 0, 0, 0, 0) /* TCP */,",
          "998:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "999:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_MODBUS, 1 /* no subprotocol */, no_master,",
          "1001:                             ndpi_build_default_ports(ports_a, 502, 0, 0, 0, 0) /* TCP */,",
          "1002:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1003:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_WHATSAPP_CALL,",
          "1004:                             0 /* can_have_a_subprotocol */, no_master, no_master, \"WhatsAppCall\",",
          "1005:                             NDPI_PROTOCOL_CATEGORY_VOIP, ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1006:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1007:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_DATASAVER, 0 /* can_have_a_subprotocol */,",
          "1008:                             no_master, no_master, \"DataSaver\", NDPI_PROTOCOL_CATEGORY_WEB /* dummy */,",
          "1009:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1010:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1011:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_SIGNAL, 0 /* can_have_a_subprotocol */,",
          "1013:                             no_master, \"Signal\", NDPI_PROTOCOL_CATEGORY_CHAT,",
          "1014:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1015:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1016:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_DOH_DOT, 0 /* can_have_a_subprotocol */,",
          "1017:                             no_master, no_master, \"DoH_DoT\", NDPI_PROTOCOL_CATEGORY_NETWORK /* dummy */,",
          "1018:                             ndpi_build_default_ports(ports_a, 853, 0, 0, 0, 0) /* TCP */,",
          "1019:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1020:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_FREE_205, 0 /* can_have_a_subprotocol */,",
          "1021:                             no_master, no_master, \"FREE_205\", NDPI_PROTOCOL_CATEGORY_VOIP,",
          "1022:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1023:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1024:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_WIREGUARD, 0 /* can_have_a_subprotocol */,",
          "1025:                             no_master, no_master, \"WireGuard\", NDPI_PROTOCOL_CATEGORY_VPN,",
          "1026:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1027:                             ndpi_build_default_ports(ports_b, 51820, 0, 0, 0, 0) /* UDP */);",
          "1028:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_PPSTREAM, 0 /* can_have_a_subprotocol */,",
          "1029:                             no_master, no_master, \"PPStream\", NDPI_PROTOCOL_CATEGORY_VIDEO,",
          "1030:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1031:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1032:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_XBOX, 0 /* can_have_a_subprotocol */, no_master,",
          "1033:                             no_master, \"Xbox\", NDPI_PROTOCOL_CATEGORY_GAME,",
          "1034:                             ndpi_build_default_ports(ports_a, 3074, 3076, 0, 0, 0) /* TCP */,",
          "1035:                             ndpi_build_default_ports(ports_b, 3074, 3076, 500, 3544, 4500) /* UDP */);",
          "1036:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_PLAYSTATION, 0 /* can_have_a_subprotocol */,",
          "1037:                             no_master, no_master, \"Playstation\", NDPI_PROTOCOL_CATEGORY_GAME,",
          "1038:                             ndpi_build_default_ports(ports_a, 1935, 3478, 3479, 3480, 0) /* TCP */,",
          "1039:                             ndpi_build_default_ports(ports_b, 3478, 3479, 0, 0, 0) /* UDP */);",
          "1040:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_QQ, 0 /* can_have_a_subprotocol */, no_master,",
          "1041:                             no_master, \"QQ\", NDPI_PROTOCOL_CATEGORY_CHAT,",
          "1042:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1043:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1044:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_RTSP, 0 /* can_have_a_subprotocol */, no_master,",
          "1045:                             no_master, \"RTSP\", NDPI_PROTOCOL_CATEGORY_MEDIA,",
          "1046:                             ndpi_build_default_ports(ports_a, 554, 0, 0, 0, 0) /* TCP */,",
          "1047:                             ndpi_build_default_ports(ports_b, 554, 0, 0, 0, 0) /* UDP */);",
          "1048:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_ICECAST, 0 /* can_have_a_subprotocol */,",
          "1049:                             no_master, no_master, \"IceCast\", NDPI_PROTOCOL_CATEGORY_MEDIA,",
          "1050:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1051:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1052:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_PPLIVE, 0 /* can_have_a_subprotocol */,",
          "1053:                             no_master, no_master, \"PPLive\", NDPI_PROTOCOL_CATEGORY_MEDIA,",
          "1054:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1055:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1056:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_PPSTREAM, 0 /* can_have_a_subprotocol */,",
          "1057:                             no_master, no_master, \"PPStream\", NDPI_PROTOCOL_CATEGORY_MEDIA,",
          "1058:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1059:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1060:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_ZATTOO, 0 /* can_have_a_subprotocol */,",
          "1061:                             no_master, no_master, \"Zattoo\", NDPI_PROTOCOL_CATEGORY_VIDEO,",
          "1062:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1063:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1064:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_SHOUTCAST, 0 /* can_have_a_subprotocol */,",
          "1065:                             no_master, no_master, \"ShoutCast\", NDPI_PROTOCOL_CATEGORY_MUSIC,",
          "1066:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1067:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1068:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_SOPCAST, 0 /* can_have_a_subprotocol */,",
          "1069:                             no_master, no_master, \"Sopcast\", NDPI_PROTOCOL_CATEGORY_VIDEO,",
          "1070:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1071:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1072:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_TVANTS, 0 /* can_have_a_subprotocol */,",
          "1073:                             no_master, no_master, \"Tvants\", NDPI_PROTOCOL_CATEGORY_VIDEO,",
          "1074:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1075:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1076:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_TVUPLAYER, 0 /* can_have_a_subprotocol */,",
          "1077:                             no_master, no_master, \"TVUplayer\", NDPI_PROTOCOL_CATEGORY_VIDEO,",
          "1078:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1079:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1080:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_HTTP_DOWNLOAD,",
          "1081:                             1 /* can_have_a_subprotocol */, no_master, no_master, \"HTTP_Download\",",
          "1082:                             NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,",
          "1083:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1084:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1085:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_QQLIVE, 0 /* can_have_a_subprotocol */,",
          "1086:                             no_master, no_master, \"QQLive\", NDPI_PROTOCOL_CATEGORY_VIDEO,",
          "1087:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1088:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1089:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_THUNDER, 0 /* can_have_a_subprotocol */,",
          "1090:                             no_master, no_master, \"Thunder\", NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,",
          "1091:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1092:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1093:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_SOULSEEK, 0 /* can_have_a_subprotocol */,",
          "1094:                             no_master, no_master, \"Soulseek\", NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,",
          "1095:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1096:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1098:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_PS_VUE, 0 /* can_have_a_subprotocol */,",
          "1099:                             no_master, no_master, \"PS_VUE\", NDPI_PROTOCOL_CATEGORY_VIDEO,",
          "1100:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1101:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1102:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_UNSAFE, NDPI_PROTOCOL_IRC, 0 /* can_have_a_subprotocol */,",
          "1103:                             no_master, no_master, \"IRC\", NDPI_PROTOCOL_CATEGORY_CHAT,",
          "1104:                             ndpi_build_default_ports(ports_a, 194, 0, 0, 0, 0) /* TCP */,",
          "1105:                             ndpi_build_default_ports(ports_b, 194, 0, 0, 0, 0) /* UDP */);",
          "1106:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_AYIYA, 0 /* can_have_a_subprotocol */,",
          "1107:                             no_master, no_master, \"Ayiya\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1108:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1109:                             ndpi_build_default_ports(ports_b, 5072, 0, 0, 0, 0) /* UDP */);",
          "1110:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_UNENCRYPTED_JABBER,",
          "1111:                             0 /* can_have_a_subprotocol */, no_master, no_master, \"Unencrypted_Jabber\",",
          "1112:                             NDPI_PROTOCOL_CATEGORY_WEB, ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1113:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1114:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_OSCAR, 0 /* can_have_a_subprotocol */,",
          "1115:                             no_master, no_master, \"Oscar\", NDPI_PROTOCOL_CATEGORY_CHAT,",
          "1116:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1117:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1118:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_BATTLEFIELD, 0 /* can_have_a_subprotocol */,",
          "1119:                             no_master, no_master, \"BattleField\", NDPI_PROTOCOL_CATEGORY_GAME,",
          "1120:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1121:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1122:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_IP_VRRP, 0 /* can_have_a_subprotocol */,",
          "1123:                             no_master, no_master, \"VRRP\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1124:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1125:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1126:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_STEAM, 0 /* can_have_a_subprotocol */, no_master,",
          "1127:                             no_master, \"Steam\", NDPI_PROTOCOL_CATEGORY_GAME,",
          "1128:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1129:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1130:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_HALFLIFE2, 0 /* can_have_a_subprotocol */,",
          "1131:                             no_master, no_master, \"HalfLife2\", NDPI_PROTOCOL_CATEGORY_GAME,",
          "1132:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1133:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1134:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_WORLDOFWARCRAFT, 0 /* can_have_a_subprotocol */,",
          "1135:                             no_master, no_master, \"WorldOfWarcraft\", NDPI_PROTOCOL_CATEGORY_GAME,",
          "1136:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1137:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1138:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_POTENTIALLY_DANGEROUS, NDPI_PROTOCOL_HOTSPOT_SHIELD,",
          "1139:                             0 /* can_have_a_subprotocol */, no_master, no_master, \"HotspotShield\",",
          "1140:                             NDPI_PROTOCOL_CATEGORY_VPN, ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1141:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1142:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_UNSAFE, NDPI_PROTOCOL_TELNET, 0 /* can_have_a_subprotocol */,",
          "1143:                             no_master, no_master, \"Telnet\", NDPI_PROTOCOL_CATEGORY_REMOTE_ACCESS,",
          "1144:                             ndpi_build_default_ports(ports_a, 23, 0, 0, 0, 0) /* TCP */,",
          "1145:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1147:     custom_master[0] = NDPI_PROTOCOL_SIP, custom_master[1] = NDPI_PROTOCOL_H323;",
          "1148:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_STUN, 0 /* can_have_a_subprotocol */,",
          "1149:                             no_master, custom_master, \"STUN\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1150:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1151:                             ndpi_build_default_ports(ports_b, 3478, 0, 0, 0, 0) /* UDP */);",
          "1152:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_SAFE, NDPI_PROTOCOL_IP_IPSEC, 0 /* can_have_a_subprotocol */,",
          "1153:                             no_master, no_master, \"IPsec\", NDPI_PROTOCOL_CATEGORY_VPN,",
          "1154:                             ndpi_build_default_ports(ports_a, 500, 0, 0, 0, 0) /* TCP */,",
          "1155:                             ndpi_build_default_ports(ports_b, 500, 4500, 0, 0, 0) /* UDP */);",
          "1156:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_IP_GRE, 0 /* can_have_a_subprotocol */,",
          "1157:                             no_master, no_master, \"GRE\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1158:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1159:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1160:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_IP_ICMP, 0 /* can_have_a_subprotocol */,",
          "1161:                             no_master, no_master, \"ICMP\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1162:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1163:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1164:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_IP_IGMP, 0 /* can_have_a_subprotocol */,",
          "1165:                             no_master, no_master, \"IGMP\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1166:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1167:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1168:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_IP_EGP, 0 /* can_have_a_subprotocol */,",
          "1169:                             no_master, no_master, \"EGP\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1170:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1171:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1172:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_IP_SCTP, 0 /* can_have_a_subprotocol */,",
          "1173:                             no_master, no_master, \"SCTP\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1174:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1175:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1176:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_IP_OSPF, 0 /* can_have_a_subprotocol */,",
          "1177:                             no_master, no_master, \"OSPF\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1178:                             ndpi_build_default_ports(ports_a, 2604, 0, 0, 0, 0) /* TCP */,",
          "1179:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1180:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_IP_IP_IN_IP,",
          "1181:                             0 /* can_have_a_subprotocol */, no_master, no_master, \"IP_in_IP\",",
          "1182:                             NDPI_PROTOCOL_CATEGORY_NETWORK, ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1183:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1184:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_RTP, 0 /* can_have_a_subprotocol */,",
          "1185:                             no_master, no_master, \"RTP\", NDPI_PROTOCOL_CATEGORY_MEDIA,",
          "1186:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1187:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1188:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_RDP, 0 /* can_have_a_subprotocol */,",
          "1189:                             no_master, no_master, \"RDP\", NDPI_PROTOCOL_CATEGORY_REMOTE_ACCESS,",
          "1190:                             ndpi_build_default_ports(ports_a, 3389, 0, 0, 0, 0) /* TCP */,",
          "1191:                             ndpi_build_default_ports(ports_b, 3389, 0, 0, 0, 0) /* UDP */);",
          "1192:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_VNC, 0 /* can_have_a_subprotocol */,",
          "1193:                             no_master, no_master, \"VNC\", NDPI_PROTOCOL_CATEGORY_REMOTE_ACCESS,",
          "1194:                             ndpi_build_default_ports(ports_a, 5900, 5901, 5800, 0, 0) /* TCP */,",
          "1195:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1196:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_PCANYWHERE,",
          "1197:                             0 /* can_have_a_subprotocol */, no_master, no_master, \"PcAnywhere\",",
          "1198:                             NDPI_PROTOCOL_CATEGORY_REMOTE_ACCESS,",
          "1199:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1200:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1201:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_ZOOM, 0 /* can_have_a_subprotocol */,",
          "1202:                             no_master, no_master, \"Zoom\", NDPI_PROTOCOL_CATEGORY_VIDEO,",
          "1203:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1204:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1205:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_WHATSAPP_FILES,",
          "1206:                             0 /* can_have_a_subprotocol */, no_master, no_master, \"WhatsAppFiles\",",
          "1207:                             NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,",
          "1208:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1209:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1210:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_WHATSAPP, 0 /* can_have_a_subprotocol */,",
          "1211:                             no_master, no_master, \"WhatsApp\", NDPI_PROTOCOL_CATEGORY_CHAT,",
          "1212:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1213:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1215:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_SAFE, NDPI_PROTOCOL_TLS, 1 /* can_have_a_subprotocol */, no_master,",
          "1216:                             no_master, \"TLS\", NDPI_PROTOCOL_CATEGORY_WEB,",
          "1217:                             ndpi_build_default_ports(ports_a, 443, 0, 0, 0, 0) /* TCP */,",
          "1218:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1219:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_SSH, 0 /* can_have_a_subprotocol */,",
          "1220:                             no_master, no_master, \"SSH\", NDPI_PROTOCOL_CATEGORY_REMOTE_ACCESS,",
          "1221:                             ndpi_build_default_ports(ports_a, 22, 0, 0, 0, 0) /* TCP */,",
          "1222:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1223:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_USENET, 0 /* can_have_a_subprotocol */,",
          "1224:                             no_master, no_master, \"Usenet\", NDPI_PROTOCOL_CATEGORY_WEB,",
          "1225:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1226:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1227:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_MGCP, 0 /* can_have_a_subprotocol */,",
          "1228:                             no_master, no_master, \"MGCP\", NDPI_PROTOCOL_CATEGORY_VOIP,",
          "1229:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1230:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1231:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_IAX, 0 /* can_have_a_subprotocol */,",
          "1232:                             no_master, no_master, \"IAX\", NDPI_PROTOCOL_CATEGORY_VOIP,",
          "1233:                             ndpi_build_default_ports(ports_a, 4569, 0, 0, 0, 0) /* TCP */,",
          "1234:                             ndpi_build_default_ports(ports_b, 4569, 0, 0, 0, 0) /* UDP */);",
          "1235:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_AFP, 0 /* can_have_a_subprotocol */,",
          "1236:                             no_master, no_master, \"AFP\", NDPI_PROTOCOL_CATEGORY_DATA_TRANSFER,",
          "1237:                             ndpi_build_default_ports(ports_a, 548, 0, 0, 0, 0) /* TCP */,",
          "1238:                             ndpi_build_default_ports(ports_b, 548, 0, 0, 0, 0) /* UDP */);",
          "1239:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_HULU, 0 /* can_have_a_subprotocol */, no_master,",
          "1240:                             no_master, \"Hulu\", NDPI_PROTOCOL_CATEGORY_STREAMING,",
          "1241:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1242:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1243:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_CHECKMK, 0 /* can_have_a_subprotocol */,",
          "1244:                             no_master, no_master, \"CHECKMK\", NDPI_PROTOCOL_CATEGORY_DATA_TRANSFER,",
          "1245:                             ndpi_build_default_ports(ports_a, 6556, 0, 0, 0, 0) /* TCP */,",
          "1246:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1247:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_POTENTIALLY_DANGEROUS, NDPI_PROTOCOL_STEALTHNET,",
          "1248:                             0 /* can_have_a_subprotocol */, no_master, no_master, \"Stealthnet\",",
          "1249:                             NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,",
          "1250:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1251:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1252:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_AIMINI, 0 /* can_have_a_subprotocol */,",
          "1253:                             no_master, no_master, \"Aimini\", NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,",
          "1254:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1255:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1256:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_SIP, 0 /* can_have_a_subprotocol */,",
          "1257:                             no_master, no_master, \"SIP\", NDPI_PROTOCOL_CATEGORY_VOIP,",
          "1258:                             ndpi_build_default_ports(ports_a, 5060, 5061, 0, 0, 0) /* TCP */,",
          "1259:                             ndpi_build_default_ports(ports_b, 5060, 5061, 0, 0, 0) /* UDP */);",
          "1260:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_TRUPHONE, 0 /* can_have_a_subprotocol */,",
          "1261:                             no_master, no_master, \"TruPhone\", NDPI_PROTOCOL_CATEGORY_VOIP,",
          "1262:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1263:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1264:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_IP_ICMPV6, 0 /* can_have_a_subprotocol */,",
          "1265:                             no_master, no_master, \"ICMPV6\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1266:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1267:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1268:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_DHCPV6, 0 /* can_have_a_subprotocol */,",
          "1269:                             no_master, no_master, \"DHCPV6\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1270:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1271:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1272:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_ARMAGETRON, 0 /* can_have_a_subprotocol */,",
          "1273:                             no_master, no_master, \"Armagetron\", NDPI_PROTOCOL_CATEGORY_GAME,",
          "1274:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1275:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1276:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_CROSSFIRE, 0 /* can_have_a_subprotocol */,",
          "1277:                             no_master, no_master, \"Crossfire\", NDPI_PROTOCOL_CATEGORY_RPC,",
          "1278:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1279:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1280:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_DOFUS, 0 /* can_have_a_subprotocol */, no_master,",
          "1281:                             no_master, \"Dofus\", NDPI_PROTOCOL_CATEGORY_GAME,",
          "1282:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1283:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1284:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_FIESTA, 0 /* can_have_a_subprotocol */,",
          "1285:                             no_master, no_master, \"Fiesta\", NDPI_PROTOCOL_CATEGORY_GAME,",
          "1286:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1287:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1288:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_FLORENSIA, 0 /* can_have_a_subprotocol */,",
          "1289:                             no_master, no_master, \"Florensia\", NDPI_PROTOCOL_CATEGORY_GAME,",
          "1290:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1291:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1292:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_GUILDWARS, 0 /* can_have_a_subprotocol */,",
          "1293:                             no_master, no_master, \"Guildwars\", NDPI_PROTOCOL_CATEGORY_GAME,",
          "1294:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1295:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1296:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_HTTP_ACTIVESYNC,",
          "1297:                             1 /* can_have_a_subprotocol */, no_master, no_master, \"HTTP_ActiveSync\",",
          "1298:                             NDPI_PROTOCOL_CATEGORY_CLOUD, ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1299:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1300:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_KERBEROS, 0 /* can_have_a_subprotocol */,",
          "1301:                             no_master, no_master, \"Kerberos\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1302:                             ndpi_build_default_ports(ports_a, 88, 0, 0, 0, 0) /* TCP */,",
          "1303:                             ndpi_build_default_ports(ports_b, 88, 0, 0, 0, 0) /* UDP */);",
          "1304:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_LDAP, 0 /* can_have_a_subprotocol */,",
          "1305:                             no_master, no_master, \"LDAP\", NDPI_PROTOCOL_CATEGORY_SYSTEM_OS,",
          "1306:                             ndpi_build_default_ports(ports_a, 389, 0, 0, 0, 0) /* TCP */,",
          "1307:                             ndpi_build_default_ports(ports_b, 389, 0, 0, 0, 0) /* UDP */);",
          "1308:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_MAPLESTORY, 0 /* can_have_a_subprotocol */,",
          "1309:                             no_master, no_master, \"MapleStory\", NDPI_PROTOCOL_CATEGORY_GAME,",
          "1310:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1311:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1312:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_MSSQL_TDS, 0 /* can_have_a_subprotocol */,",
          "1313:                             no_master, no_master, \"MsSQL-TDS\", NDPI_PROTOCOL_CATEGORY_DATABASE,",
          "1314:                             ndpi_build_default_ports(ports_a, 1433, 1434, 0, 0, 0) /* TCP */,",
          "1315:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1316:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_PPTP, 0 /* can_have_a_subprotocol */,",
          "1317:                             no_master, no_master, \"PPTP\", NDPI_PROTOCOL_CATEGORY_VPN,",
          "1318:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1319:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1320:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_WARCRAFT3, 0 /* can_have_a_subprotocol */,",
          "1321:                             no_master, no_master, \"Warcraft3\", NDPI_PROTOCOL_CATEGORY_GAME,",
          "1322:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1323:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1324:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_WORLD_OF_KUNG_FU, 0 /* can_have_a_subprotocol */,",
          "1325:                             no_master, no_master, \"WorldOfKungFu\", NDPI_PROTOCOL_CATEGORY_GAME,",
          "1326:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1327:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1328:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_DCERPC, 0 /* can_have_a_subprotocol */,",
          "1329:                             no_master, no_master, \"DCE_RPC\", NDPI_PROTOCOL_CATEGORY_RPC,",
          "1330:                             ndpi_build_default_ports(ports_a, 135, 0, 0, 0, 0) /* TCP */,",
          "1331:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1332:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_NETFLOW, 0 /* can_have_a_subprotocol */,",
          "1333:                             no_master, no_master, \"NetFlow\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1334:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1335:                             ndpi_build_default_ports(ports_b, 2055, 0, 0, 0, 0) /* UDP */);",
          "1336:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_SFLOW, 0 /* can_have_a_subprotocol */,",
          "1337:                             no_master, no_master, \"sFlow\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1338:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1339:                             ndpi_build_default_ports(ports_b, 6343, 0, 0, 0, 0) /* UDP */);",
          "1340:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_HTTP_CONNECT,",
          "1341:                             1 /* can_have_a_subprotocol */, no_master, no_master, \"HTTP_Connect\",",
          "1342:                             NDPI_PROTOCOL_CATEGORY_WEB, ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1343:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1344:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_HTTP_PROXY,",
          "1345:                             1 /* can_have_a_subprotocol */, no_master, no_master, \"HTTP_Proxy\",",
          "1346:                             NDPI_PROTOCOL_CATEGORY_WEB,",
          "1347:                             ndpi_build_default_ports(ports_a, 8080, 3128, 0, 0, 0) /* TCP */,",
          "1348:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1349:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_CITRIX, 0 /* can_have_a_subprotocol */,",
          "1350:                             no_master, no_master, \"Citrix\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1351:                             ndpi_build_default_ports(ports_a, 1494, 2598, 0, 0, 0) /* TCP */,",
          "1352:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1353:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_WEBEX, 0 /* can_have_a_subprotocol */,",
          "1354:                             no_master, no_master, \"Webex\", NDPI_PROTOCOL_CATEGORY_VOIP,",
          "1355:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1356:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1357:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_RADIUS, 0 /* can_have_a_subprotocol */,",
          "1358:                             no_master, no_master, \"Radius\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1359:                             ndpi_build_default_ports(ports_a, 1812, 1813, 0, 0, 0) /* TCP */,",
          "1360:                             ndpi_build_default_ports(ports_b, 1812, 1813, 0, 0, 0) /* UDP */);",
          "1361:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_TEAMVIEWER,",
          "1362:                             0 /* can_have_a_subprotocol */, no_master, no_master, \"TeamViewer\",",
          "1363:                             NDPI_PROTOCOL_CATEGORY_REMOTE_ACCESS,",
          "1364:                             ndpi_build_default_ports(ports_a, 5938, 0, 0, 0, 0) /* TCP */,",
          "1365:                             ndpi_build_default_ports(ports_b, 5938, 0, 0, 0, 0) /* UDP */);",
          "1366:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_LOTUS_NOTES,",
          "1367:                             0 /* can_have_a_subprotocol */, no_master, no_master, \"LotusNotes\",",
          "1368:                             NDPI_PROTOCOL_CATEGORY_COLLABORATIVE,",
          "1369:                             ndpi_build_default_ports(ports_a, 1352, 0, 0, 0, 0) /* TCP */,",
          "1370:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1371:     ndpi_set_proto_defaults(",
          "1372:         ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_SAP, 0 /* can_have_a_subprotocol */, no_master, no_master,",
          "1373:         \"SAP\", NDPI_PROTOCOL_CATEGORY_NETWORK, ndpi_build_default_ports(ports_a, 3201, 0, 0, 0, 0) /* TCP */,",
          "1375:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_GTP, 0 /* can_have_a_subprotocol */,",
          "1376:                             no_master, no_master, \"GTP\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1377:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1378:                             ndpi_build_default_ports(ports_b, 2152, 2123, 0, 0, 0) /* UDP */);",
          "1379:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_UPNP, 0 /* can_have_a_subprotocol */,",
          "1380:                             no_master, no_master, \"UPnP\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1381:                             ndpi_build_default_ports(ports_a, 1780, 0, 0, 0, 0) /* TCP */,",
          "1382:                             ndpi_build_default_ports(ports_b, 1900, 0, 0, 0, 0) /* UDP */);",
          "1383:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_TELEGRAM, 0 /* can_have_a_subprotocol */,",
          "1384:                             no_master, no_master, \"Telegram\", NDPI_PROTOCOL_CATEGORY_CHAT,",
          "1385:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1386:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1387:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_QUIC, 1 /* can_have_a_subprotocol */,",
          "1388:                             no_master, no_master, \"QUIC\", NDPI_PROTOCOL_CATEGORY_WEB,",
          "1389:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1390:                             ndpi_build_default_ports(ports_b, 443, 80, 0, 0, 0) /* UDP */);",
          "1391:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_DIAMETER, 0 /* can_have_a_subprotocol */,",
          "1392:                             no_master, no_master, \"Diameter\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1393:                             ndpi_build_default_ports(ports_a, 3868, 0, 0, 0, 0) /* TCP */,",
          "1394:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1395:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_APPLE_PUSH,",
          "1396:                             0 /* can_have_a_subprotocol */, no_master, no_master, \"ApplePush\",",
          "1397:                             NDPI_PROTOCOL_CATEGORY_CLOUD, ndpi_build_default_ports(ports_a, 1, 0, 0, 0, 0) /* TCP */,",
          "1398:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1399:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_DROPBOX, 0 /* can_have_a_subprotocol */,",
          "1400:                             no_master, no_master, \"Dropbox\", NDPI_PROTOCOL_CATEGORY_CLOUD,",
          "1401:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1402:                             ndpi_build_default_ports(ports_b, 17500, 0, 0, 0, 0) /* UDP */);",
          "1403:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_SPOTIFY, 0 /* can_have_a_subprotocol */,",
          "1404:                             no_master, no_master, \"Spotify\", NDPI_PROTOCOL_CATEGORY_MUSIC,",
          "1405:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1406:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1407:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_MESSENGER, 0 /* can_have_a_subprotocol */,",
          "1408:                             no_master, no_master, \"Messenger\", NDPI_PROTOCOL_CATEGORY_VOIP,",
          "1409:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1410:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1411:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_LISP, 0 /* can_have_a_subprotocol */,",
          "1412:                             no_master, no_master, \"LISP\", NDPI_PROTOCOL_CATEGORY_CLOUD,",
          "1413:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1414:                             ndpi_build_default_ports(ports_b, 4342, 4341, 0, 0, 0) /* UDP */);",
          "1415:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_EAQ, 0 /* can_have_a_subprotocol */,",
          "1416:                             no_master, no_master, \"EAQ\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1417:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1418:                             ndpi_build_default_ports(ports_b, 6000, 0, 0, 0, 0) /* UDP */);",
          "1419:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_KAKAOTALK_VOICE,",
          "1420:                             0 /* can_have_a_subprotocol */, no_master, no_master, \"KakaoTalk_Voice\",",
          "1421:                             NDPI_PROTOCOL_CATEGORY_VOIP, ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1422:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1423:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_MPEGTS, 0 /* can_have_a_subprotocol */,",
          "1424:                             no_master, no_master, \"MPEG_TS\", NDPI_PROTOCOL_CATEGORY_MEDIA,",
          "1425:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1426:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1428:     ndpi_set_proto_defaults(",
          "1429:         ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_LLMNR, 0 /* can_have_a_subprotocol */, no_master, no_master,",
          "1430:         \"LLMNR\", NDPI_PROTOCOL_CATEGORY_NETWORK, ndpi_build_default_ports(ports_a, 5355, 0, 0, 0, 0) /* TCP */,",
          "1432:     ndpi_set_proto_defaults(",
          "1433:         ndpi_str, NDPI_PROTOCOL_POTENTIALLY_DANGEROUS, NDPI_PROTOCOL_REMOTE_SCAN, 0 /* can_have_a_subprotocol */,",
          "1434:         no_master, no_master, \"RemoteScan\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1435:         ndpi_build_default_ports(ports_a, 6077, 0, 0, 0, 0) /* TCP */,",
          "1438:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_H323, 0 /* can_have_a_subprotocol */,",
          "1439:                             no_master, no_master, \"H323\", NDPI_PROTOCOL_CATEGORY_VOIP,",
          "1440:                             ndpi_build_default_ports(ports_a, 1719, 1720, 0, 0, 0) /* TCP */,",
          "1441:                             ndpi_build_default_ports(ports_b, 1719, 1720, 0, 0, 0) /* UDP */);",
          "1442:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_OPENVPN, 0 /* can_have_a_subprotocol */,",
          "1443:                             no_master, no_master, \"OpenVPN\", NDPI_PROTOCOL_CATEGORY_VPN,",
          "1444:                             ndpi_build_default_ports(ports_a, 1194, 0, 0, 0, 0) /* TCP */,",
          "1445:                             ndpi_build_default_ports(ports_b, 1194, 0, 0, 0, 0) /* UDP */);",
          "1446:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_NOE, 0 /* can_have_a_subprotocol */,",
          "1447:                             no_master, no_master, \"NOE\", NDPI_PROTOCOL_CATEGORY_VOIP,",
          "1448:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1449:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1450:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_CISCOVPN, 0 /* can_have_a_subprotocol */,",
          "1451:                             no_master, no_master, \"CiscoVPN\", NDPI_PROTOCOL_CATEGORY_VPN,",
          "1452:                             ndpi_build_default_ports(ports_a, 10000, 8008, 8009, 0, 0) /* TCP */,",
          "1453:                             ndpi_build_default_ports(ports_b, 10000, 0, 0, 0, 0) /* UDP */);",
          "1454:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_TEAMSPEAK, 0 /* can_have_a_subprotocol */,",
          "1455:                             no_master, no_master, \"TeamSpeak\", NDPI_PROTOCOL_CATEGORY_VOIP,",
          "1456:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1457:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1458:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_SKINNY, 0 /* can_have_a_subprotocol */,",
          "1459:                             no_master, no_master, \"CiscoSkinny\", NDPI_PROTOCOL_CATEGORY_VOIP,",
          "1460:                             ndpi_build_default_ports(ports_a, 2000, 0, 0, 0, 0) /* TCP */,",
          "1461:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1462:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_RTCP, 0 /* can_have_a_subprotocol */,",
          "1463:                             no_master, no_master, \"RTCP\", NDPI_PROTOCOL_CATEGORY_VOIP,",
          "1464:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1465:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1466:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_RSYNC, 0 /* can_have_a_subprotocol */,",
          "1467:                             no_master, no_master, \"RSYNC\", NDPI_PROTOCOL_CATEGORY_DATA_TRANSFER,",
          "1468:                             ndpi_build_default_ports(ports_a, 873, 0, 0, 0, 0) /* TCP */,",
          "1469:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1470:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_ORACLE, 0 /* can_have_a_subprotocol */,",
          "1471:                             no_master, no_master, \"Oracle\", NDPI_PROTOCOL_CATEGORY_DATABASE,",
          "1472:                             ndpi_build_default_ports(ports_a, 1521, 0, 0, 0, 0) /* TCP */,",
          "1473:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1474:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_CORBA, 0 /* can_have_a_subprotocol */,",
          "1475:                             no_master, no_master, \"Corba\", NDPI_PROTOCOL_CATEGORY_RPC,",
          "1476:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1477:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1478:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_UBUNTUONE, 0 /* can_have_a_subprotocol */,",
          "1479:                             no_master, no_master, \"UbuntuONE\", NDPI_PROTOCOL_CATEGORY_CLOUD,",
          "1480:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1481:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1482:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_WHOIS_DAS, 0 /* can_have_a_subprotocol */,",
          "1483:                             no_master, no_master, \"Whois-DAS\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1486:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_COLLECTD, 0 /* can_have_a_subprotocol */,",
          "1487:                             no_master, no_master, \"Collectd\", NDPI_PROTOCOL_CATEGORY_SYSTEM_OS,",
          "1490:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_SOCKS, 0 /* can_have_a_subprotocol */,",
          "1491:                             no_master, no_master, \"SOCKS\", NDPI_PROTOCOL_CATEGORY_WEB,",
          "1494:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_TFTP, 0 /* can_have_a_subprotocol */,",
          "1495:                             no_master, no_master, \"TFTP\", NDPI_PROTOCOL_CATEGORY_DATA_TRANSFER,",
          "1498:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_RTMP, 0 /* can_have_a_subprotocol */,",
          "1499:                             no_master, no_master, \"RTMP\", NDPI_PROTOCOL_CATEGORY_MEDIA,",
          "1502:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_PANDO, 0 /* can_have_a_subprotocol */, no_master,",
          "1503:                             no_master, \"Pando_Media_Booster\", NDPI_PROTOCOL_CATEGORY_WEB,",
          "1506:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_MEGACO, 0 /* can_have_a_subprotocol */,",
          "1507:                             no_master, no_master, \"Megaco\", NDPI_PROTOCOL_CATEGORY_VOIP,",
          "1510:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_REDIS, 0 /* can_have_a_subprotocol */,",
          "1511:                             no_master, no_master, \"Redis\", NDPI_PROTOCOL_CATEGORY_DATABASE,",
          "1514:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_ZMQ, 0 /* can_have_a_subprotocol */,",
          "1515:                             no_master, no_master, \"ZeroMQ\", NDPI_PROTOCOL_CATEGORY_RPC,",
          "1518:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_VHUA, 0 /* can_have_a_subprotocol */, no_master,",
          "1519:                             no_master, \"VHUA\", NDPI_PROTOCOL_CATEGORY_VOIP,",
          "1522:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_STARCRAFT, 0 /* can_have_a_subprotocol */,",
          "1523:                             no_master, no_master, \"Starcraft\", NDPI_PROTOCOL_CATEGORY_GAME,",
          "1526:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_SAFE, NDPI_PROTOCOL_UBNTAC2, 0 /* can_have_a_subprotocol */,",
          "1527:                             no_master, no_master, \"UBNTAC2\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1530:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_VIBER, 0 /* can_have_a_subprotocol */,",
          "1531:                             no_master, no_master, \"Viber\", NDPI_PROTOCOL_CATEGORY_VOIP,",
          "1534:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_SAFE, NDPI_PROTOCOL_COAP, 0 /* can_have_a_subprotocol */, no_master,",
          "1535:                             no_master, \"COAP\", NDPI_PROTOCOL_CATEGORY_RPC,",
          "1538:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_MQTT, 0 /* can_have_a_subprotocol */,",
          "1539:                             no_master, no_master, \"MQTT\", NDPI_PROTOCOL_CATEGORY_RPC,",
          "1542:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_SOMEIP, 0 /* can_have_a_subprotocol */,",
          "1543:                             no_master, no_master, \"SOMEIP\", NDPI_PROTOCOL_CATEGORY_RPC,",
          "1546:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_RX, 0 /* can_have_a_subprotocol */,",
          "1547:                             no_master, no_master, \"RX\", NDPI_PROTOCOL_CATEGORY_RPC,",
          "1550:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_SAFE, NDPI_PROTOCOL_GIT, 0 /* can_have_a_subprotocol */, no_master,",
          "1551:                             no_master, \"Git\", NDPI_PROTOCOL_CATEGORY_COLLABORATIVE,",
          "1554:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_DRDA, 0 /* can_have_a_subprotocol */,",
          "1555:                             no_master, no_master, \"DRDA\", NDPI_PROTOCOL_CATEGORY_DATABASE,",
          "1558:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_HANGOUT_DUO,",
          "1559:                             0 /* can_have_a_subprotocol */, no_master, no_master, \"GoogleHangoutDuo\",",
          "1560:                             NDPI_PROTOCOL_CATEGORY_VOIP, ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1561:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1562:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_BJNP, 0 /* can_have_a_subprotocol */,",
          "1563:                             no_master, no_master, \"BJNP\", NDPI_PROTOCOL_CATEGORY_SYSTEM_OS,",
          "1564:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1565:                             ndpi_build_default_ports(ports_b, 8612, 0, 0, 0, 0) /* UDP */);",
          "1566:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_SMPP, 0 /* can_have_a_subprotocol */,",
          "1567:                             no_master, no_master, \"SMPP\", NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,",
          "1570:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_SAFE, NDPI_PROTOCOL_OOKLA, 0 /* can_have_a_subprotocol */,",
          "1571:                             no_master, no_master, \"Ookla\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1574:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_AMQP, 0 /* can_have_a_subprotocol */,",
          "1575:                             no_master, no_master, \"AMQP\", NDPI_PROTOCOL_CATEGORY_RPC,",
          "1578:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_SAFE, NDPI_PROTOCOL_DNSCRYPT, 0 /* can_have_a_subprotocol */,",
          "1579:                             no_master, no_master, \"DNScrypt\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1582:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_TINC, 0 /* can_have_a_subprotocol */,",
          "1583:                             no_master, no_master, \"TINC\", NDPI_PROTOCOL_CATEGORY_VPN,",
          "1584:                             ndpi_build_default_ports(ports_a, 655, 0, 0, 0, 0) /* TCP */,",
          "1585:                             ndpi_build_default_ports(ports_b, 655, 0, 0, 0, 0) /* UDP */);",
          "1586:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_SAFE, NDPI_PROTOCOL_FIX, 0 /* can_have_a_subprotocol */, no_master,",
          "1587:                             no_master, \"FIX\", NDPI_PROTOCOL_CATEGORY_RPC,",
          "1588:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1589:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1590:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_NINTENDO, 0 /* can_have_a_subprotocol */,",
          "1591:                             no_master, no_master, \"Nintendo\", NDPI_PROTOCOL_CATEGORY_GAME,",
          "1592:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1593:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1594:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_CSGO, 0 /* can_have_a_subprotocol */, no_master,",
          "1595:                             no_master, \"CSGO\", NDPI_PROTOCOL_CATEGORY_GAME,",
          "1596:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1597:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1598:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_AJP, 0 /* can_have_a_subprotocol */,",
          "1599:                             no_master, no_master, \"AJP\", NDPI_PROTOCOL_CATEGORY_WEB,",
          "1600:                             ndpi_build_default_ports(ports_a, 8009, 0, 0, 0, 0) /* TCP */,",
          "1601:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1602:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_TARGUS_GETDATA,",
          "1603:                             0 /* can_have_a_subprotocol */, no_master, no_master, \"Targus Dataspeed\",",
          "1604:                             NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1605:                             ndpi_build_default_ports(ports_a, 5001, 5201, 0, 0, 0) /* TCP */,",
          "1606:                             ndpi_build_default_ports(ports_b, 5001, 5201, 0, 0, 0) /* UDP */);",
          "1607:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_AMAZON_VIDEO,",
          "1608:                             0 /* can_have_a_subprotocol */, no_master, no_master, \"AmazonVideo\",",
          "1609:                             NDPI_PROTOCOL_CATEGORY_CLOUD, ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1610:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1611:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_DNP3, 1 /* no subprotocol */, no_master,",
          "1612:                             no_master, \"DNP3\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1613:                             ndpi_build_default_ports(ports_a, 20000, 0, 0, 0, 0) /* TCP */,",
          "1614:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1615:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_IEC60870, 1 /* no subprotocol */,",
          "1616:                             no_master, no_master, \"IEC60870\",",
          "1618:                             ndpi_build_default_ports(ports_a, 2404, 0, 0, 0, 0) /* TCP */,",
          "1619:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1620:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_BLOOMBERG, 1 /* no subprotocol */,",
          "1621:                             no_master, no_master, \"Bloomberg\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1622:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1623:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1624:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_CAPWAP, 1 /* no subprotocol */, no_master,",
          "1625:                             no_master, \"CAPWAP\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1626:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1628:     );",
          "1629:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_ZABBIX, 1 /* no subprotocol */, no_master,",
          "1630:                             no_master, \"Zabbix\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1631:                             ndpi_build_default_ports(ports_a, 10050, 0, 0, 0, 0) /* TCP */,",
          "1633:     );",
          "1634:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_S7COMM, 1 /* no subprotocol */, no_master,",
          "1635:                             no_master, \"s7comm\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1636:                             ndpi_build_default_ports(ports_a, 102, 0, 0, 0, 0) /* TCP */,",
          "1637:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1638:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_SAFE, NDPI_PROTOCOL_MSTEAMS, 1 /* no subprotocol */, no_master,",
          "1639:                             no_master, \"Teams\", NDPI_PROTOCOL_CATEGORY_COLLABORATIVE,",
          "1640:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1642:     );",
          "1643:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_WEBSOCKET,",
          "1644:                             1 /* can_have_a_subprotocol */, no_master,",
          "1645:                             no_master, \"WebSocket\", NDPI_PROTOCOL_CATEGORY_WEB,",
          "1646:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1647:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1654:     init_string_based_protocols(ndpi_str);",
          "1656:     ndpi_validate_protocol_initialization(ndpi_str);",
          "",
          "[Added Lines]",
          "752: static void ndpi_init_protocol_defaults(struct ndpi_detection_module_struct *ndpi_str) {",
          "753:   ndpi_port_range ports_a[MAX_DEFAULT_PORTS], ports_b[MAX_DEFAULT_PORTS];",
          "754:   u_int16_t no_master[2] = {NDPI_PROTOCOL_NO_MASTER_PROTO, NDPI_PROTOCOL_NO_MASTER_PROTO}, custom_master[2];",
          "757:   memset(ndpi_str->proto_defaults, 0, sizeof(ndpi_str->proto_defaults));",
          "759:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_UNRATED, NDPI_PROTOCOL_UNKNOWN, 0 /* can_have_a_subprotocol */,",
          "760:      no_master, no_master, \"Unknown\", NDPI_PROTOCOL_CATEGORY_UNSPECIFIED,",
          "761:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "762:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "763:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_UNSAFE, NDPI_PROTOCOL_FTP_CONTROL, 0 /* can_have_a_subprotocol */,",
          "764:      no_master, no_master, \"FTP_CONTROL\", NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,",
          "765:      ndpi_build_default_ports(ports_a, 21, 0, 0, 0, 0) /* TCP */,",
          "766:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "767:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_FTP_DATA, 0 /* can_have_a_subprotocol */,",
          "768:      no_master, no_master, \"FTP_DATA\", NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,",
          "769:      ndpi_build_default_ports(ports_a, 20, 0, 0, 0, 0) /* TCP */,",
          "770:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "771:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_UNSAFE, NDPI_PROTOCOL_MAIL_POP, 0 /* can_have_a_subprotocol */,",
          "772:      no_master, no_master, \"POP3\", NDPI_PROTOCOL_CATEGORY_MAIL,",
          "773:      ndpi_build_default_ports(ports_a, 110, 0, 0, 0, 0) /* TCP */,",
          "774:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "775:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_SAFE, NDPI_PROTOCOL_MAIL_POPS, 0 /* can_have_a_subprotocol */,",
          "776:      no_master, no_master, \"POPS\", NDPI_PROTOCOL_CATEGORY_MAIL,",
          "777:      ndpi_build_default_ports(ports_a, 995, 0, 0, 0, 0) /* TCP */,",
          "778:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "779:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_MAIL_SMTP, 0 /* can_have_a_subprotocol */,",
          "780:      no_master, no_master, \"SMTP\", NDPI_PROTOCOL_CATEGORY_MAIL,",
          "781:      ndpi_build_default_ports(ports_a, 25, 0, 0, 0, 0) /* TCP */,",
          "782:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "783:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_SAFE, NDPI_PROTOCOL_MAIL_SMTPS, 0 /* can_have_a_subprotocol */,",
          "784:      no_master, no_master, \"SMTPS\", NDPI_PROTOCOL_CATEGORY_MAIL,",
          "785:      ndpi_build_default_ports(ports_a, 465, 587, 0, 0, 0) /* TCP */,",
          "786:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "787:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_UNSAFE, NDPI_PROTOCOL_MAIL_IMAP, 0 /* can_have_a_subprotocol */,",
          "788:      no_master, no_master, \"IMAP\", NDPI_PROTOCOL_CATEGORY_MAIL,",
          "789:      ndpi_build_default_ports(ports_a, 143, 0, 0, 0, 0) /* TCP */,",
          "790:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "791:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_SAFE, NDPI_PROTOCOL_MAIL_IMAPS, 0 /* can_have_a_subprotocol */,",
          "792:      no_master, no_master, \"IMAPS\", NDPI_PROTOCOL_CATEGORY_MAIL,",
          "793:      ndpi_build_default_ports(ports_a, 993, 0, 0, 0, 0) /* TCP */,",
          "794:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "795:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_DNS, 1 /* can_have_a_subprotocol */,",
          "796:      no_master, no_master, \"DNS\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "797:      ndpi_build_default_ports(ports_a, 53, 0, 0, 0, 0) /* TCP */,",
          "798:      ndpi_build_default_ports(ports_b, 53, 0, 0, 0, 0) /* UDP */);",
          "799:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_IPP, 0 /* can_have_a_subprotocol */,",
          "800:      no_master, no_master, \"IPP\", NDPI_PROTOCOL_CATEGORY_SYSTEM_OS,",
          "801:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "802:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "803:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_IMO, 0 /* can_have_a_subprotocol */,",
          "804:      no_master, no_master, \"IMO\", NDPI_PROTOCOL_CATEGORY_VOIP,",
          "805:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "806:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "807:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_HTTP, 1 /* can_have_a_subprotocol */,",
          "808:      no_master, no_master, \"HTTP\", NDPI_PROTOCOL_CATEGORY_WEB,",
          "809:      ndpi_build_default_ports(ports_a, 80, 0 /* ntop */, 0, 0, 0) /* TCP */,",
          "810:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "811:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_MDNS, 1 /* can_have_a_subprotocol */,",
          "812:      no_master, no_master, \"MDNS\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "813:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "814:      ndpi_build_default_ports(ports_b, 5353, 5354, 0, 0, 0) /* UDP */);",
          "815:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_NTP, 0 /* can_have_a_subprotocol */,",
          "816:      no_master, no_master, \"NTP\", NDPI_PROTOCOL_CATEGORY_SYSTEM_OS,",
          "817:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "818:      ndpi_build_default_ports(ports_b, 123, 0, 0, 0, 0) /* UDP */);",
          "819:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_NETBIOS, 0 /* can_have_a_subprotocol */,",
          "820:      no_master, no_master, \"NetBIOS\", NDPI_PROTOCOL_CATEGORY_SYSTEM_OS,",
          "821:      ndpi_build_default_ports(ports_a, 139, 0, 0, 0, 0) /* TCP */,",
          "822:      ndpi_build_default_ports(ports_b, 137, 138, 139, 0, 0) /* UDP */);",
          "823:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_NFS, 0 /* can_have_a_subprotocol */,",
          "824:      no_master, no_master, \"NFS\", NDPI_PROTOCOL_CATEGORY_DATA_TRANSFER,",
          "825:      ndpi_build_default_ports(ports_a, 2049, 0, 0, 0, 0) /* TCP */,",
          "826:      ndpi_build_default_ports(ports_b, 2049, 0, 0, 0, 0) /* UDP */);",
          "827:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_SSDP, 0 /* can_have_a_subprotocol */,",
          "828:      no_master, no_master, \"SSDP\", NDPI_PROTOCOL_CATEGORY_SYSTEM_OS,",
          "829:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "830:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "831:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_BGP, 0 /* can_have_a_subprotocol */,",
          "832:      no_master, no_master, \"BGP\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "833:      ndpi_build_default_ports(ports_a, 179, 2605, 0, 0, 0) /* TCP */,",
          "834:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "835:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_SNMP, 0 /* can_have_a_subprotocol */,",
          "836:      no_master, no_master, \"SNMP\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "837:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "838:      ndpi_build_default_ports(ports_b, 161, 162, 0, 0, 0) /* UDP */);",
          "839:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_XDMCP, 0 /* can_have_a_subprotocol */,",
          "840:      no_master, no_master, \"XDMCP\", NDPI_PROTOCOL_CATEGORY_REMOTE_ACCESS,",
          "841:      ndpi_build_default_ports(ports_a, 177, 0, 0, 0, 0) /* TCP */,",
          "842:      ndpi_build_default_ports(ports_b, 177, 0, 0, 0, 0) /* UDP */);",
          "843:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_DANGEROUS, NDPI_PROTOCOL_SMBV1, 0 /* can_have_a_subprotocol */,",
          "844:      no_master, no_master, \"SMBv1\", NDPI_PROTOCOL_CATEGORY_SYSTEM_OS,",
          "845:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "846:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "847:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_SYSLOG, 0 /* can_have_a_subprotocol */,",
          "848:      no_master, no_master, \"Syslog\", NDPI_PROTOCOL_CATEGORY_SYSTEM_OS,",
          "849:      ndpi_build_default_ports(ports_a, 514, 0, 0, 0, 0) /* TCP */,",
          "850:      ndpi_build_default_ports(ports_b, 514, 0, 0, 0, 0) /* UDP */);",
          "851:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_DHCP, 0 /* can_have_a_subprotocol */,",
          "852:      no_master, no_master, \"DHCP\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "853:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "854:      ndpi_build_default_ports(ports_b, 67, 68, 0, 0, 0) /* UDP */);",
          "855:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_POSTGRES, 0 /* can_have_a_subprotocol */,",
          "856:      no_master, no_master, \"PostgreSQL\", NDPI_PROTOCOL_CATEGORY_DATABASE,",
          "857:      ndpi_build_default_ports(ports_a, 5432, 0, 0, 0, 0) /* TCP */,",
          "858:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "859:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_MYSQL, 0 /* can_have_a_subprotocol */,",
          "860:      no_master, no_master, \"MySQL\", NDPI_PROTOCOL_CATEGORY_DATABASE,",
          "861:      ndpi_build_default_ports(ports_a, 3306, 0, 0, 0, 0) /* TCP */,",
          "862:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "863:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_POTENTIALLY_DANGEROUS, NDPI_PROTOCOL_DIRECT_DOWNLOAD_LINK,",
          "864:      0 /* can_have_a_subprotocol */, no_master, no_master, \"Direct_Download_Link\",",
          "865:      NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,",
          "866:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "867:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "868:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_POTENTIALLY_DANGEROUS, NDPI_PROTOCOL_APPLEJUICE,",
          "869:      0 /* can_have_a_subprotocol */, no_master, no_master, \"AppleJuice\",",
          "870:      NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,",
          "871:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "872:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "873:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_POTENTIALLY_DANGEROUS, NDPI_PROTOCOL_DIRECTCONNECT,",
          "874:      0 /* can_have_a_subprotocol */, no_master, no_master, \"DirectConnect\",",
          "875:      NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,",
          "876:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "877:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "878:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_NATS,",
          "879:      0 /* can_have_a_subprotocol */, no_master, no_master, \"Nats\",",
          "880:      NDPI_PROTOCOL_CATEGORY_RPC,",
          "881:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "882:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "883:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_SAFE, NDPI_PROTOCOL_NTOP, 0 /* can_have_a_subprotocol */, no_master,",
          "884:      no_master, \"ntop\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "885:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "886:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "887:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_VMWARE, 0 /* can_have_a_subprotocol */,",
          "888:      no_master, no_master, \"VMware\", NDPI_PROTOCOL_CATEGORY_REMOTE_ACCESS,",
          "889:      ndpi_build_default_ports(ports_a, 903, 0, 0, 0, 0) /* TCP */,",
          "890:      ndpi_build_default_ports(ports_b, 902, 903, 0, 0, 0) /* UDP */);",
          "891:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_SAFE, NDPI_PROTOCOL_FBZERO, 0 /* can_have_a_subprotocol */,",
          "892:      no_master, no_master, \"FacebookZero\", NDPI_PROTOCOL_CATEGORY_SOCIAL_NETWORK,",
          "893:      ndpi_build_default_ports(ports_a, 443, 0, 0, 0, 0) /* TCP */,",
          "894:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "895:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_POTENTIALLY_DANGEROUS, NDPI_PROTOCOL_KONTIKI,",
          "896:      0 /* can_have_a_subprotocol */, no_master, no_master, \"Kontiki\",",
          "897:      NDPI_PROTOCOL_CATEGORY_MEDIA, ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "898:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "899:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_POTENTIALLY_DANGEROUS, NDPI_PROTOCOL_OPENFT,",
          "900:      0 /* can_have_a_subprotocol */, no_master, no_master, \"OpenFT\",",
          "901:      NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,",
          "902:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "903:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "904:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_POTENTIALLY_DANGEROUS, NDPI_PROTOCOL_FASTTRACK,",
          "905:      0 /* can_have_a_subprotocol */, no_master, no_master, \"FastTrack\",",
          "906:      NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,",
          "907:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "908:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "909:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_POTENTIALLY_DANGEROUS, NDPI_PROTOCOL_GNUTELLA,",
          "910:      0 /* can_have_a_subprotocol */, no_master, no_master, \"Gnutella\",",
          "911:      NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,",
          "912:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "913:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "914:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_UNSAFE, NDPI_PROTOCOL_EDONKEY, 0 /* can_have_a_subprotocol */,",
          "915:      no_master, no_master, \"eDonkey\", NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,",
          "916:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "917:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "918:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_UNSAFE, NDPI_PROTOCOL_BITTORRENT, 0 /* can_have_a_subprotocol */,",
          "919:      no_master, no_master, \"BitTorrent\", NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,",
          "920:      ndpi_build_default_ports(ports_a, 51413, 53646, 0, 0, 0) /* TCP */,",
          "921:      ndpi_build_default_ports(ports_b, 6771, 51413, 0, 0, 0) /* UDP */);",
          "922:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_SKYPE, 0 /* can_have_a_subprotocol */,",
          "923:      no_master, no_master, \"Skype\", NDPI_PROTOCOL_CATEGORY_VOIP,",
          "924:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "925:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "926:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_SKYPE_CALL,",
          "927:      0 /* can_have_a_subprotocol */, no_master, no_master, \"SkypeCall\",",
          "928:      NDPI_PROTOCOL_CATEGORY_VOIP, ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "929:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "930:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_TIKTOK, 0 /* can_have_a_subprotocol */,",
          "931:      no_master, no_master, \"TikTok\", NDPI_PROTOCOL_CATEGORY_SOCIAL_NETWORK,",
          "932:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "933:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "934:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_TEREDO, 0 /* can_have_a_subprotocol */,",
          "935:      no_master, no_master, \"Teredo\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "936:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "937:      ndpi_build_default_ports(ports_b, 3544, 0, 0, 0, 0) /* UDP */);",
          "938:   ndpi_set_proto_defaults(",
          "940:      no_master, \"WeChat\", NDPI_PROTOCOL_CATEGORY_CHAT, ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "941:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "942:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_MEMCACHED, 0 /* can_have_a_subprotocol */,",
          "943:      no_master, no_master, \"Memcached\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "944:      ndpi_build_default_ports(ports_a, 11211, 0, 0, 0, 0) /* TCP */,",
          "945:      ndpi_build_default_ports(ports_b, 11211, 0, 0, 0, 0) /* UDP */);",
          "946:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_SMBV23, 0 /* can_have_a_subprotocol */,",
          "947:      no_master, no_master, \"SMBv23\", NDPI_PROTOCOL_CATEGORY_SYSTEM_OS,",
          "948:      ndpi_build_default_ports(ports_a, 445, 0, 0, 0, 0) /* TCP */,",
          "949:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "950:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_UNSAFE, NDPI_PROTOCOL_MINING, 0 /* can_have_a_subprotocol */,",
          "951:      no_master, no_master, \"Mining\", CUSTOM_CATEGORY_MINING,",
          "952:      ndpi_build_default_ports(ports_a, 8333, 30303, 0, 0, 0) /* TCP */,",
          "953:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "954:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_NEST_LOG_SINK,",
          "955:      0 /* can_have_a_subprotocol */, no_master, no_master, \"NestLogSink\",",
          "956:      NDPI_PROTOCOL_CATEGORY_CLOUD,",
          "957:      ndpi_build_default_ports(ports_a, 11095, 0, 0, 0, 0) /* TCP */,",
          "958:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "959:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_MODBUS, 1 /* no subprotocol */, no_master,",
          "961:      ndpi_build_default_ports(ports_a, 502, 0, 0, 0, 0) /* TCP */,",
          "962:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "963:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_WHATSAPP_CALL,",
          "964:      0 /* can_have_a_subprotocol */, no_master, no_master, \"WhatsAppCall\",",
          "965:      NDPI_PROTOCOL_CATEGORY_VOIP, ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "966:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "967:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_DATASAVER, 0 /* can_have_a_subprotocol */,",
          "968:      no_master, no_master, \"DataSaver\", NDPI_PROTOCOL_CATEGORY_WEB /* dummy */,",
          "969:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "970:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "971:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_SIGNAL, 0 /* can_have_a_subprotocol */,",
          "973:      no_master, \"Signal\", NDPI_PROTOCOL_CATEGORY_CHAT,",
          "974:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "975:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "976:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_DOH_DOT, 0 /* can_have_a_subprotocol */,",
          "977:      no_master, no_master, \"DoH_DoT\", NDPI_PROTOCOL_CATEGORY_NETWORK /* dummy */,",
          "978:      ndpi_build_default_ports(ports_a, 853, 0, 0, 0, 0) /* TCP */,",
          "979:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "980:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_FREE_205, 0 /* can_have_a_subprotocol */,",
          "981:      no_master, no_master, \"FREE_205\", NDPI_PROTOCOL_CATEGORY_VOIP,",
          "982:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "983:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "984:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_WIREGUARD, 0 /* can_have_a_subprotocol */,",
          "985:      no_master, no_master, \"WireGuard\", NDPI_PROTOCOL_CATEGORY_VPN,",
          "986:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "987:      ndpi_build_default_ports(ports_b, 51820, 0, 0, 0, 0) /* UDP */);",
          "988:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_PPSTREAM, 0 /* can_have_a_subprotocol */,",
          "989:      no_master, no_master, \"PPStream\", NDPI_PROTOCOL_CATEGORY_VIDEO,",
          "990:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "991:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "992:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_XBOX, 0 /* can_have_a_subprotocol */, no_master,",
          "993:      no_master, \"Xbox\", NDPI_PROTOCOL_CATEGORY_GAME,",
          "994:      ndpi_build_default_ports(ports_a, 3074, 3076, 0, 0, 0) /* TCP */,",
          "995:      ndpi_build_default_ports(ports_b, 3074, 3076, 500, 3544, 4500) /* UDP */);",
          "996:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_PLAYSTATION, 0 /* can_have_a_subprotocol */,",
          "997:      no_master, no_master, \"Playstation\", NDPI_PROTOCOL_CATEGORY_GAME,",
          "998:      ndpi_build_default_ports(ports_a, 1935, 3478, 3479, 3480, 0) /* TCP */,",
          "999:      ndpi_build_default_ports(ports_b, 3478, 3479, 0, 0, 0) /* UDP */);",
          "1000:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_QQ, 0 /* can_have_a_subprotocol */, no_master,",
          "1001:      no_master, \"QQ\", NDPI_PROTOCOL_CATEGORY_CHAT,",
          "1002:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1003:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1004:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_RTSP, 0 /* can_have_a_subprotocol */, no_master,",
          "1005:      no_master, \"RTSP\", NDPI_PROTOCOL_CATEGORY_MEDIA,",
          "1006:      ndpi_build_default_ports(ports_a, 554, 0, 0, 0, 0) /* TCP */,",
          "1007:      ndpi_build_default_ports(ports_b, 554, 0, 0, 0, 0) /* UDP */);",
          "1008:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_ICECAST, 0 /* can_have_a_subprotocol */,",
          "1009:      no_master, no_master, \"IceCast\", NDPI_PROTOCOL_CATEGORY_MEDIA,",
          "1010:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1011:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1012:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_PPLIVE, 0 /* can_have_a_subprotocol */,",
          "1013:      no_master, no_master, \"PPLive\", NDPI_PROTOCOL_CATEGORY_MEDIA,",
          "1014:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1015:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1016:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_PPSTREAM, 0 /* can_have_a_subprotocol */,",
          "1017:      no_master, no_master, \"PPStream\", NDPI_PROTOCOL_CATEGORY_MEDIA,",
          "1018:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1019:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1020:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_ZATTOO, 0 /* can_have_a_subprotocol */,",
          "1021:      no_master, no_master, \"Zattoo\", NDPI_PROTOCOL_CATEGORY_VIDEO,",
          "1022:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1023:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1024:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_SHOUTCAST, 0 /* can_have_a_subprotocol */,",
          "1025:      no_master, no_master, \"ShoutCast\", NDPI_PROTOCOL_CATEGORY_MUSIC,",
          "1026:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1027:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1028:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_SOPCAST, 0 /* can_have_a_subprotocol */,",
          "1029:      no_master, no_master, \"Sopcast\", NDPI_PROTOCOL_CATEGORY_VIDEO,",
          "1030:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1031:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1032:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_TVANTS, 0 /* can_have_a_subprotocol */,",
          "1033:      no_master, no_master, \"Tvants\", NDPI_PROTOCOL_CATEGORY_VIDEO,",
          "1034:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1035:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1036:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_TVUPLAYER, 0 /* can_have_a_subprotocol */,",
          "1037:      no_master, no_master, \"TVUplayer\", NDPI_PROTOCOL_CATEGORY_VIDEO,",
          "1038:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1039:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1040:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_HTTP_DOWNLOAD,",
          "1041:      1 /* can_have_a_subprotocol */, no_master, no_master, \"HTTP_Download\",",
          "1042:      NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,",
          "1043:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1044:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1045:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_QQLIVE, 0 /* can_have_a_subprotocol */,",
          "1046:      no_master, no_master, \"QQLive\", NDPI_PROTOCOL_CATEGORY_VIDEO,",
          "1047:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1048:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1049:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_THUNDER, 0 /* can_have_a_subprotocol */,",
          "1050:      no_master, no_master, \"Thunder\", NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,",
          "1051:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1052:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1053:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_SOULSEEK, 0 /* can_have_a_subprotocol */,",
          "1054:      no_master, no_master, \"Soulseek\", NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,",
          "1055:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1056:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1058:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_PS_VUE, 0 /* can_have_a_subprotocol */,",
          "1059:      no_master, no_master, \"PS_VUE\", NDPI_PROTOCOL_CATEGORY_VIDEO,",
          "1060:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1061:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1062:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_UNSAFE, NDPI_PROTOCOL_IRC, 0 /* can_have_a_subprotocol */,",
          "1063:      no_master, no_master, \"IRC\", NDPI_PROTOCOL_CATEGORY_CHAT,",
          "1064:      ndpi_build_default_ports(ports_a, 194, 0, 0, 0, 0) /* TCP */,",
          "1065:      ndpi_build_default_ports(ports_b, 194, 0, 0, 0, 0) /* UDP */);",
          "1066:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_AYIYA, 0 /* can_have_a_subprotocol */,",
          "1067:      no_master, no_master, \"Ayiya\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1068:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1069:      ndpi_build_default_ports(ports_b, 5072, 0, 0, 0, 0) /* UDP */);",
          "1070:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_UNENCRYPTED_JABBER,",
          "1071:      0 /* can_have_a_subprotocol */, no_master, no_master, \"Unencrypted_Jabber\",",
          "1072:      NDPI_PROTOCOL_CATEGORY_WEB, ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1073:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1074:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_OSCAR, 0 /* can_have_a_subprotocol */,",
          "1075:      no_master, no_master, \"Oscar\", NDPI_PROTOCOL_CATEGORY_CHAT,",
          "1076:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1077:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1078:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_BATTLEFIELD, 0 /* can_have_a_subprotocol */,",
          "1079:      no_master, no_master, \"BattleField\", NDPI_PROTOCOL_CATEGORY_GAME,",
          "1080:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1081:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1082:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_IP_VRRP, 0 /* can_have_a_subprotocol */,",
          "1083:      no_master, no_master, \"VRRP\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1084:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1085:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1086:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_STEAM, 0 /* can_have_a_subprotocol */, no_master,",
          "1087:      no_master, \"Steam\", NDPI_PROTOCOL_CATEGORY_GAME,",
          "1088:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1089:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1090:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_HALFLIFE2, 0 /* can_have_a_subprotocol */,",
          "1091:      no_master, no_master, \"HalfLife2\", NDPI_PROTOCOL_CATEGORY_GAME,",
          "1092:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1093:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1094:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_WORLDOFWARCRAFT, 0 /* can_have_a_subprotocol */,",
          "1095:      no_master, no_master, \"WorldOfWarcraft\", NDPI_PROTOCOL_CATEGORY_GAME,",
          "1096:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1097:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1098:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_POTENTIALLY_DANGEROUS, NDPI_PROTOCOL_HOTSPOT_SHIELD,",
          "1099:      0 /* can_have_a_subprotocol */, no_master, no_master, \"HotspotShield\",",
          "1100:      NDPI_PROTOCOL_CATEGORY_VPN, ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1101:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1102:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_UNSAFE, NDPI_PROTOCOL_TELNET, 0 /* can_have_a_subprotocol */,",
          "1103:      no_master, no_master, \"Telnet\", NDPI_PROTOCOL_CATEGORY_REMOTE_ACCESS,",
          "1104:      ndpi_build_default_ports(ports_a, 23, 0, 0, 0, 0) /* TCP */,",
          "1105:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1107:   custom_master[0] = NDPI_PROTOCOL_SIP, custom_master[1] = NDPI_PROTOCOL_H323;",
          "1108:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_STUN, 0 /* can_have_a_subprotocol */,",
          "1109:      no_master, custom_master, \"STUN\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1110:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1111:      ndpi_build_default_ports(ports_b, 3478, 0, 0, 0, 0) /* UDP */);",
          "1112:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_SAFE, NDPI_PROTOCOL_IP_IPSEC, 0 /* can_have_a_subprotocol */,",
          "1113:      no_master, no_master, \"IPsec\", NDPI_PROTOCOL_CATEGORY_VPN,",
          "1114:      ndpi_build_default_ports(ports_a, 500, 0, 0, 0, 0) /* TCP */,",
          "1115:      ndpi_build_default_ports(ports_b, 500, 4500, 0, 0, 0) /* UDP */);",
          "1116:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_IP_GRE, 0 /* can_have_a_subprotocol */,",
          "1117:      no_master, no_master, \"GRE\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1118:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1119:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1120:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_IP_ICMP, 0 /* can_have_a_subprotocol */,",
          "1121:      no_master, no_master, \"ICMP\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1122:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1123:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1124:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_IP_IGMP, 0 /* can_have_a_subprotocol */,",
          "1125:      no_master, no_master, \"IGMP\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1126:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1127:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1128:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_IP_EGP, 0 /* can_have_a_subprotocol */,",
          "1129:      no_master, no_master, \"EGP\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1130:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1131:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1132:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_IP_SCTP, 0 /* can_have_a_subprotocol */,",
          "1133:      no_master, no_master, \"SCTP\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1134:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1135:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1136:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_IP_OSPF, 0 /* can_have_a_subprotocol */,",
          "1137:      no_master, no_master, \"OSPF\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1138:      ndpi_build_default_ports(ports_a, 2604, 0, 0, 0, 0) /* TCP */,",
          "1139:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1140:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_IP_IP_IN_IP,",
          "1141:      0 /* can_have_a_subprotocol */, no_master, no_master, \"IP_in_IP\",",
          "1142:      NDPI_PROTOCOL_CATEGORY_NETWORK, ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1143:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1144:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_RTP, 0 /* can_have_a_subprotocol */,",
          "1145:      no_master, no_master, \"RTP\", NDPI_PROTOCOL_CATEGORY_MEDIA,",
          "1146:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1147:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1148:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_RDP, 0 /* can_have_a_subprotocol */,",
          "1149:      no_master, no_master, \"RDP\", NDPI_PROTOCOL_CATEGORY_REMOTE_ACCESS,",
          "1150:      ndpi_build_default_ports(ports_a, 3389, 0, 0, 0, 0) /* TCP */,",
          "1151:      ndpi_build_default_ports(ports_b, 3389, 0, 0, 0, 0) /* UDP */);",
          "1152:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_VNC, 0 /* can_have_a_subprotocol */,",
          "1153:      no_master, no_master, \"VNC\", NDPI_PROTOCOL_CATEGORY_REMOTE_ACCESS,",
          "1154:      ndpi_build_default_ports(ports_a, 5900, 5901, 5800, 0, 0) /* TCP */,",
          "1155:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1156:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_PCANYWHERE,",
          "1157:      0 /* can_have_a_subprotocol */, no_master, no_master, \"PcAnywhere\",",
          "1158:      NDPI_PROTOCOL_CATEGORY_REMOTE_ACCESS,",
          "1159:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1160:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1161:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_ZOOM, 0 /* can_have_a_subprotocol */,",
          "1162:      no_master, no_master, \"Zoom\", NDPI_PROTOCOL_CATEGORY_VIDEO,",
          "1163:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1164:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1165:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_WHATSAPP_FILES,",
          "1166:      0 /* can_have_a_subprotocol */, no_master, no_master, \"WhatsAppFiles\",",
          "1167:      NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,",
          "1168:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1169:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1170:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_WHATSAPP, 0 /* can_have_a_subprotocol */,",
          "1171:      no_master, no_master, \"WhatsApp\", NDPI_PROTOCOL_CATEGORY_CHAT,",
          "1172:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1173:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1175:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_SAFE, NDPI_PROTOCOL_TLS, 1 /* can_have_a_subprotocol */, no_master,",
          "1176:      no_master, \"TLS\", NDPI_PROTOCOL_CATEGORY_WEB,",
          "1177:      ndpi_build_default_ports(ports_a, 443, 0, 0, 0, 0) /* TCP */,",
          "1178:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1179:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_SSH, 0 /* can_have_a_subprotocol */,",
          "1180:      no_master, no_master, \"SSH\", NDPI_PROTOCOL_CATEGORY_REMOTE_ACCESS,",
          "1181:      ndpi_build_default_ports(ports_a, 22, 0, 0, 0, 0) /* TCP */,",
          "1182:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1183:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_USENET, 0 /* can_have_a_subprotocol */,",
          "1184:      no_master, no_master, \"Usenet\", NDPI_PROTOCOL_CATEGORY_WEB,",
          "1185:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1186:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1187:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_MGCP, 0 /* can_have_a_subprotocol */,",
          "1188:      no_master, no_master, \"MGCP\", NDPI_PROTOCOL_CATEGORY_VOIP,",
          "1189:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1190:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1191:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_IAX, 0 /* can_have_a_subprotocol */,",
          "1192:      no_master, no_master, \"IAX\", NDPI_PROTOCOL_CATEGORY_VOIP,",
          "1193:      ndpi_build_default_ports(ports_a, 4569, 0, 0, 0, 0) /* TCP */,",
          "1194:      ndpi_build_default_ports(ports_b, 4569, 0, 0, 0, 0) /* UDP */);",
          "1195:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_AFP, 0 /* can_have_a_subprotocol */,",
          "1196:      no_master, no_master, \"AFP\", NDPI_PROTOCOL_CATEGORY_DATA_TRANSFER,",
          "1197:      ndpi_build_default_ports(ports_a, 548, 0, 0, 0, 0) /* TCP */,",
          "1198:      ndpi_build_default_ports(ports_b, 548, 0, 0, 0, 0) /* UDP */);",
          "1199:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_HULU, 0 /* can_have_a_subprotocol */, no_master,",
          "1200:      no_master, \"Hulu\", NDPI_PROTOCOL_CATEGORY_STREAMING,",
          "1201:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1202:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1203:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_CHECKMK, 0 /* can_have_a_subprotocol */,",
          "1204:      no_master, no_master, \"CHECKMK\", NDPI_PROTOCOL_CATEGORY_DATA_TRANSFER,",
          "1205:      ndpi_build_default_ports(ports_a, 6556, 0, 0, 0, 0) /* TCP */,",
          "1206:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1207:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_POTENTIALLY_DANGEROUS, NDPI_PROTOCOL_STEALTHNET,",
          "1208:      0 /* can_have_a_subprotocol */, no_master, no_master, \"Stealthnet\",",
          "1209:      NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,",
          "1210:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1211:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1212:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_AIMINI, 0 /* can_have_a_subprotocol */,",
          "1213:      no_master, no_master, \"Aimini\", NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,",
          "1214:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1215:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1216:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_SIP, 0 /* can_have_a_subprotocol */,",
          "1217:      no_master, no_master, \"SIP\", NDPI_PROTOCOL_CATEGORY_VOIP,",
          "1218:      ndpi_build_default_ports(ports_a, 5060, 5061, 0, 0, 0) /* TCP */,",
          "1219:      ndpi_build_default_ports(ports_b, 5060, 5061, 0, 0, 0) /* UDP */);",
          "1220:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_TRUPHONE, 0 /* can_have_a_subprotocol */,",
          "1221:      no_master, no_master, \"TruPhone\", NDPI_PROTOCOL_CATEGORY_VOIP,",
          "1222:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1223:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1224:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_IP_ICMPV6, 0 /* can_have_a_subprotocol */,",
          "1225:      no_master, no_master, \"ICMPV6\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1226:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1227:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1228:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_DHCPV6, 0 /* can_have_a_subprotocol */,",
          "1229:      no_master, no_master, \"DHCPV6\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1230:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1231:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1232:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_ARMAGETRON, 0 /* can_have_a_subprotocol */,",
          "1233:      no_master, no_master, \"Armagetron\", NDPI_PROTOCOL_CATEGORY_GAME,",
          "1234:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1235:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1236:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_CROSSFIRE, 0 /* can_have_a_subprotocol */,",
          "1237:      no_master, no_master, \"Crossfire\", NDPI_PROTOCOL_CATEGORY_RPC,",
          "1238:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1239:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1240:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_DOFUS, 0 /* can_have_a_subprotocol */, no_master,",
          "1241:      no_master, \"Dofus\", NDPI_PROTOCOL_CATEGORY_GAME,",
          "1242:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1243:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1244:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_FIESTA, 0 /* can_have_a_subprotocol */,",
          "1245:      no_master, no_master, \"Fiesta\", NDPI_PROTOCOL_CATEGORY_GAME,",
          "1246:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1247:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1248:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_FLORENSIA, 0 /* can_have_a_subprotocol */,",
          "1249:      no_master, no_master, \"Florensia\", NDPI_PROTOCOL_CATEGORY_GAME,",
          "1250:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1251:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1252:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_GUILDWARS, 0 /* can_have_a_subprotocol */,",
          "1253:      no_master, no_master, \"Guildwars\", NDPI_PROTOCOL_CATEGORY_GAME,",
          "1254:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1255:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1256:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_HTTP_ACTIVESYNC,",
          "1257:      1 /* can_have_a_subprotocol */, no_master, no_master, \"HTTP_ActiveSync\",",
          "1258:      NDPI_PROTOCOL_CATEGORY_CLOUD, ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1259:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1260:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_KERBEROS, 0 /* can_have_a_subprotocol */,",
          "1261:      no_master, no_master, \"Kerberos\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1262:      ndpi_build_default_ports(ports_a, 88, 0, 0, 0, 0) /* TCP */,",
          "1263:      ndpi_build_default_ports(ports_b, 88, 0, 0, 0, 0) /* UDP */);",
          "1264:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_LDAP, 0 /* can_have_a_subprotocol */,",
          "1265:      no_master, no_master, \"LDAP\", NDPI_PROTOCOL_CATEGORY_SYSTEM_OS,",
          "1266:      ndpi_build_default_ports(ports_a, 389, 0, 0, 0, 0) /* TCP */,",
          "1267:      ndpi_build_default_ports(ports_b, 389, 0, 0, 0, 0) /* UDP */);",
          "1268:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_MAPLESTORY, 0 /* can_have_a_subprotocol */,",
          "1269:      no_master, no_master, \"MapleStory\", NDPI_PROTOCOL_CATEGORY_GAME,",
          "1270:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1271:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1272:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_MSSQL_TDS, 0 /* can_have_a_subprotocol */,",
          "1273:      no_master, no_master, \"MsSQL-TDS\", NDPI_PROTOCOL_CATEGORY_DATABASE,",
          "1274:      ndpi_build_default_ports(ports_a, 1433, 1434, 0, 0, 0) /* TCP */,",
          "1275:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1276:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_PPTP, 0 /* can_have_a_subprotocol */,",
          "1277:      no_master, no_master, \"PPTP\", NDPI_PROTOCOL_CATEGORY_VPN,",
          "1278:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1279:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1280:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_WARCRAFT3, 0 /* can_have_a_subprotocol */,",
          "1281:      no_master, no_master, \"Warcraft3\", NDPI_PROTOCOL_CATEGORY_GAME,",
          "1282:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1283:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1284:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_WORLD_OF_KUNG_FU, 0 /* can_have_a_subprotocol */,",
          "1285:      no_master, no_master, \"WorldOfKungFu\", NDPI_PROTOCOL_CATEGORY_GAME,",
          "1286:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1287:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1288:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_DCERPC, 0 /* can_have_a_subprotocol */,",
          "1289:      no_master, no_master, \"DCE_RPC\", NDPI_PROTOCOL_CATEGORY_RPC,",
          "1290:      ndpi_build_default_ports(ports_a, 135, 0, 0, 0, 0) /* TCP */,",
          "1291:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1292:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_NETFLOW, 0 /* can_have_a_subprotocol */,",
          "1293:      no_master, no_master, \"NetFlow\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1294:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1295:      ndpi_build_default_ports(ports_b, 2055, 0, 0, 0, 0) /* UDP */);",
          "1296:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_SFLOW, 0 /* can_have_a_subprotocol */,",
          "1297:      no_master, no_master, \"sFlow\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1298:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1299:      ndpi_build_default_ports(ports_b, 6343, 0, 0, 0, 0) /* UDP */);",
          "1300:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_HTTP_CONNECT,",
          "1301:      1 /* can_have_a_subprotocol */, no_master, no_master, \"HTTP_Connect\",",
          "1302:      NDPI_PROTOCOL_CATEGORY_WEB, ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1303:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1304:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_HTTP_PROXY,",
          "1305:      1 /* can_have_a_subprotocol */, no_master, no_master, \"HTTP_Proxy\",",
          "1306:      NDPI_PROTOCOL_CATEGORY_WEB,",
          "1307:      ndpi_build_default_ports(ports_a, 8080, 3128, 0, 0, 0) /* TCP */,",
          "1308:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1309:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_CITRIX, 0 /* can_have_a_subprotocol */,",
          "1310:      no_master, no_master, \"Citrix\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1311:      ndpi_build_default_ports(ports_a, 1494, 2598, 0, 0, 0) /* TCP */,",
          "1312:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1313:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_WEBEX, 0 /* can_have_a_subprotocol */,",
          "1314:      no_master, no_master, \"Webex\", NDPI_PROTOCOL_CATEGORY_VOIP,",
          "1315:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1316:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1317:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_RADIUS, 0 /* can_have_a_subprotocol */,",
          "1318:      no_master, no_master, \"Radius\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1319:      ndpi_build_default_ports(ports_a, 1812, 1813, 0, 0, 0) /* TCP */,",
          "1320:      ndpi_build_default_ports(ports_b, 1812, 1813, 0, 0, 0) /* UDP */);",
          "1321:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_TEAMVIEWER,",
          "1322:      0 /* can_have_a_subprotocol */, no_master, no_master, \"TeamViewer\",",
          "1323:      NDPI_PROTOCOL_CATEGORY_REMOTE_ACCESS,",
          "1324:      ndpi_build_default_ports(ports_a, 5938, 0, 0, 0, 0) /* TCP */,",
          "1325:      ndpi_build_default_ports(ports_b, 5938, 0, 0, 0, 0) /* UDP */);",
          "1326:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_LOTUS_NOTES,",
          "1327:      0 /* can_have_a_subprotocol */, no_master, no_master, \"LotusNotes\",",
          "1328:      NDPI_PROTOCOL_CATEGORY_COLLABORATIVE,",
          "1329:      ndpi_build_default_ports(ports_a, 1352, 0, 0, 0, 0) /* TCP */,",
          "1330:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1331:   ndpi_set_proto_defaults(",
          "1332:      ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_SAP, 0 /* can_have_a_subprotocol */, no_master, no_master,",
          "1333:      \"SAP\", NDPI_PROTOCOL_CATEGORY_NETWORK, ndpi_build_default_ports(ports_a, 3201, 0, 0, 0, 0) /* TCP */,",
          "1335:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_GTP, 0 /* can_have_a_subprotocol */,",
          "1336:      no_master, no_master, \"GTP\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1337:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1338:      ndpi_build_default_ports(ports_b, 2152, 2123, 0, 0, 0) /* UDP */);",
          "1339:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_UPNP, 0 /* can_have_a_subprotocol */,",
          "1340:      no_master, no_master, \"UPnP\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1341:      ndpi_build_default_ports(ports_a, 1780, 0, 0, 0, 0) /* TCP */,",
          "1342:      ndpi_build_default_ports(ports_b, 1900, 0, 0, 0, 0) /* UDP */);",
          "1343:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_TELEGRAM, 0 /* can_have_a_subprotocol */,",
          "1344:      no_master, no_master, \"Telegram\", NDPI_PROTOCOL_CATEGORY_CHAT,",
          "1345:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1346:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1347:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_QUIC, 1 /* can_have_a_subprotocol */,",
          "1348:      no_master, no_master, \"QUIC\", NDPI_PROTOCOL_CATEGORY_WEB,",
          "1349:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1350:      ndpi_build_default_ports(ports_b, 443, 80, 0, 0, 0) /* UDP */);",
          "1351:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_DIAMETER, 0 /* can_have_a_subprotocol */,",
          "1352:      no_master, no_master, \"Diameter\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1353:      ndpi_build_default_ports(ports_a, 3868, 0, 0, 0, 0) /* TCP */,",
          "1354:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1355:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_APPLE_PUSH,",
          "1356:      0 /* can_have_a_subprotocol */, no_master, no_master, \"ApplePush\",",
          "1357:      NDPI_PROTOCOL_CATEGORY_CLOUD, ndpi_build_default_ports(ports_a, 1, 0, 0, 0, 0) /* TCP */,",
          "1358:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1359:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_DROPBOX, 0 /* can_have_a_subprotocol */,",
          "1360:      no_master, no_master, \"Dropbox\", NDPI_PROTOCOL_CATEGORY_CLOUD,",
          "1361:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1362:      ndpi_build_default_ports(ports_b, 17500, 0, 0, 0, 0) /* UDP */);",
          "1363:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_SPOTIFY, 0 /* can_have_a_subprotocol */,",
          "1364:      no_master, no_master, \"Spotify\", NDPI_PROTOCOL_CATEGORY_MUSIC,",
          "1365:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1366:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1367:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_MESSENGER, 0 /* can_have_a_subprotocol */,",
          "1368:      no_master, no_master, \"Messenger\", NDPI_PROTOCOL_CATEGORY_VOIP,",
          "1369:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1370:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1371:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_LISP, 0 /* can_have_a_subprotocol */,",
          "1372:      no_master, no_master, \"LISP\", NDPI_PROTOCOL_CATEGORY_CLOUD,",
          "1373:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1374:      ndpi_build_default_ports(ports_b, 4342, 4341, 0, 0, 0) /* UDP */);",
          "1375:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_EAQ, 0 /* can_have_a_subprotocol */,",
          "1376:      no_master, no_master, \"EAQ\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1377:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1378:      ndpi_build_default_ports(ports_b, 6000, 0, 0, 0, 0) /* UDP */);",
          "1379:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_KAKAOTALK_VOICE,",
          "1380:      0 /* can_have_a_subprotocol */, no_master, no_master, \"KakaoTalk_Voice\",",
          "1381:      NDPI_PROTOCOL_CATEGORY_VOIP, ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1382:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1383:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_MPEGTS, 0 /* can_have_a_subprotocol */,",
          "1384:      no_master, no_master, \"MPEG_TS\", NDPI_PROTOCOL_CATEGORY_MEDIA,",
          "1385:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1386:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1388:   ndpi_set_proto_defaults(",
          "1389:      ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_LLMNR, 0 /* can_have_a_subprotocol */, no_master, no_master,",
          "1390:      \"LLMNR\", NDPI_PROTOCOL_CATEGORY_NETWORK, ndpi_build_default_ports(ports_a, 5355, 0, 0, 0, 0) /* TCP */,",
          "1392:   ndpi_set_proto_defaults(",
          "1393:      ndpi_str, NDPI_PROTOCOL_POTENTIALLY_DANGEROUS, NDPI_PROTOCOL_REMOTE_SCAN, 0 /* can_have_a_subprotocol */,",
          "1394:      no_master, no_master, \"RemoteScan\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1395:      ndpi_build_default_ports(ports_a, 6077, 0, 0, 0, 0) /* TCP */,",
          "1398:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_H323, 0 /* can_have_a_subprotocol */,",
          "1399:      no_master, no_master, \"H323\", NDPI_PROTOCOL_CATEGORY_VOIP,",
          "1400:      ndpi_build_default_ports(ports_a, 1719, 1720, 0, 0, 0) /* TCP */,",
          "1401:      ndpi_build_default_ports(ports_b, 1719, 1720, 0, 0, 0) /* UDP */);",
          "1402:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_OPENVPN, 0 /* can_have_a_subprotocol */,",
          "1403:      no_master, no_master, \"OpenVPN\", NDPI_PROTOCOL_CATEGORY_VPN,",
          "1404:      ndpi_build_default_ports(ports_a, 1194, 0, 0, 0, 0) /* TCP */,",
          "1405:      ndpi_build_default_ports(ports_b, 1194, 0, 0, 0, 0) /* UDP */);",
          "1406:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_NOE, 0 /* can_have_a_subprotocol */,",
          "1407:      no_master, no_master, \"NOE\", NDPI_PROTOCOL_CATEGORY_VOIP,",
          "1408:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1409:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1410:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_CISCOVPN, 0 /* can_have_a_subprotocol */,",
          "1411:      no_master, no_master, \"CiscoVPN\", NDPI_PROTOCOL_CATEGORY_VPN,",
          "1412:      ndpi_build_default_ports(ports_a, 10000, 8008, 8009, 0, 0) /* TCP */,",
          "1413:      ndpi_build_default_ports(ports_b, 10000, 0, 0, 0, 0) /* UDP */);",
          "1414:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_TEAMSPEAK, 0 /* can_have_a_subprotocol */,",
          "1415:      no_master, no_master, \"TeamSpeak\", NDPI_PROTOCOL_CATEGORY_VOIP,",
          "1416:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1417:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1418:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_SKINNY, 0 /* can_have_a_subprotocol */,",
          "1419:      no_master, no_master, \"CiscoSkinny\", NDPI_PROTOCOL_CATEGORY_VOIP,",
          "1420:      ndpi_build_default_ports(ports_a, 2000, 0, 0, 0, 0) /* TCP */,",
          "1421:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1422:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_RTCP, 0 /* can_have_a_subprotocol */,",
          "1423:      no_master, no_master, \"RTCP\", NDPI_PROTOCOL_CATEGORY_VOIP,",
          "1424:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1425:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1426:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_RSYNC, 0 /* can_have_a_subprotocol */,",
          "1427:      no_master, no_master, \"RSYNC\", NDPI_PROTOCOL_CATEGORY_DATA_TRANSFER,",
          "1428:      ndpi_build_default_ports(ports_a, 873, 0, 0, 0, 0) /* TCP */,",
          "1429:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1430:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_ORACLE, 0 /* can_have_a_subprotocol */,",
          "1431:      no_master, no_master, \"Oracle\", NDPI_PROTOCOL_CATEGORY_DATABASE,",
          "1432:      ndpi_build_default_ports(ports_a, 1521, 0, 0, 0, 0) /* TCP */,",
          "1433:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1434:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_CORBA, 0 /* can_have_a_subprotocol */,",
          "1435:      no_master, no_master, \"Corba\", NDPI_PROTOCOL_CATEGORY_RPC,",
          "1436:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1437:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1438:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_UBUNTUONE, 0 /* can_have_a_subprotocol */,",
          "1439:      no_master, no_master, \"UbuntuONE\", NDPI_PROTOCOL_CATEGORY_CLOUD,",
          "1440:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1441:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1442:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_WHOIS_DAS, 0 /* can_have_a_subprotocol */,",
          "1443:      no_master, no_master, \"Whois-DAS\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1446:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_COLLECTD, 0 /* can_have_a_subprotocol */,",
          "1447:      no_master, no_master, \"Collectd\", NDPI_PROTOCOL_CATEGORY_SYSTEM_OS,",
          "1450:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_SOCKS, 0 /* can_have_a_subprotocol */,",
          "1451:      no_master, no_master, \"SOCKS\", NDPI_PROTOCOL_CATEGORY_WEB,",
          "1454:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_TFTP, 0 /* can_have_a_subprotocol */,",
          "1455:      no_master, no_master, \"TFTP\", NDPI_PROTOCOL_CATEGORY_DATA_TRANSFER,",
          "1458:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_RTMP, 0 /* can_have_a_subprotocol */,",
          "1459:      no_master, no_master, \"RTMP\", NDPI_PROTOCOL_CATEGORY_MEDIA,",
          "1462:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_PANDO, 0 /* can_have_a_subprotocol */, no_master,",
          "1463:      no_master, \"Pando_Media_Booster\", NDPI_PROTOCOL_CATEGORY_WEB,",
          "1466:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_MEGACO, 0 /* can_have_a_subprotocol */,",
          "1467:      no_master, no_master, \"Megaco\", NDPI_PROTOCOL_CATEGORY_VOIP,",
          "1470:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_REDIS, 0 /* can_have_a_subprotocol */,",
          "1471:      no_master, no_master, \"Redis\", NDPI_PROTOCOL_CATEGORY_DATABASE,",
          "1474:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_ZMQ, 0 /* can_have_a_subprotocol */,",
          "1475:      no_master, no_master, \"ZeroMQ\", NDPI_PROTOCOL_CATEGORY_RPC,",
          "1478:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_VHUA, 0 /* can_have_a_subprotocol */, no_master,",
          "1479:      no_master, \"VHUA\", NDPI_PROTOCOL_CATEGORY_VOIP,",
          "1482:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_STARCRAFT, 0 /* can_have_a_subprotocol */,",
          "1483:      no_master, no_master, \"Starcraft\", NDPI_PROTOCOL_CATEGORY_GAME,",
          "1486:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_SAFE, NDPI_PROTOCOL_UBNTAC2, 0 /* can_have_a_subprotocol */,",
          "1487:      no_master, no_master, \"UBNTAC2\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1490:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_VIBER, 0 /* can_have_a_subprotocol */,",
          "1491:      no_master, no_master, \"Viber\", NDPI_PROTOCOL_CATEGORY_VOIP,",
          "1494:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_SAFE, NDPI_PROTOCOL_COAP, 0 /* can_have_a_subprotocol */, no_master,",
          "1495:      no_master, \"COAP\", NDPI_PROTOCOL_CATEGORY_RPC,",
          "1498:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_MQTT, 0 /* can_have_a_subprotocol */,",
          "1499:      no_master, no_master, \"MQTT\", NDPI_PROTOCOL_CATEGORY_RPC,",
          "1502:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_SOMEIP, 0 /* can_have_a_subprotocol */,",
          "1503:      no_master, no_master, \"SOMEIP\", NDPI_PROTOCOL_CATEGORY_RPC,",
          "1506:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_RX, 0 /* can_have_a_subprotocol */,",
          "1507:      no_master, no_master, \"RX\", NDPI_PROTOCOL_CATEGORY_RPC,",
          "1510:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_SAFE, NDPI_PROTOCOL_GIT, 0 /* can_have_a_subprotocol */, no_master,",
          "1511:      no_master, \"Git\", NDPI_PROTOCOL_CATEGORY_COLLABORATIVE,",
          "1514:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_DRDA, 0 /* can_have_a_subprotocol */,",
          "1515:      no_master, no_master, \"DRDA\", NDPI_PROTOCOL_CATEGORY_DATABASE,",
          "1518:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_HANGOUT_DUO,",
          "1519:      0 /* can_have_a_subprotocol */, no_master, no_master, \"GoogleHangoutDuo\",",
          "1520:      NDPI_PROTOCOL_CATEGORY_VOIP, ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1521:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1522:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_BJNP, 0 /* can_have_a_subprotocol */,",
          "1523:      no_master, no_master, \"BJNP\", NDPI_PROTOCOL_CATEGORY_SYSTEM_OS,",
          "1524:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1525:      ndpi_build_default_ports(ports_b, 8612, 0, 0, 0, 0) /* UDP */);",
          "1526:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_SMPP, 0 /* can_have_a_subprotocol */,",
          "1527:      no_master, no_master, \"SMPP\", NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,",
          "1530:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_SAFE, NDPI_PROTOCOL_OOKLA, 0 /* can_have_a_subprotocol */,",
          "1531:      no_master, no_master, \"Ookla\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1534:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_AMQP, 0 /* can_have_a_subprotocol */,",
          "1535:      no_master, no_master, \"AMQP\", NDPI_PROTOCOL_CATEGORY_RPC,",
          "1538:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_SAFE, NDPI_PROTOCOL_DNSCRYPT, 0 /* can_have_a_subprotocol */,",
          "1539:      no_master, no_master, \"DNScrypt\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1542:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_TINC, 0 /* can_have_a_subprotocol */,",
          "1543:      no_master, no_master, \"TINC\", NDPI_PROTOCOL_CATEGORY_VPN,",
          "1544:      ndpi_build_default_ports(ports_a, 655, 0, 0, 0, 0) /* TCP */,",
          "1545:      ndpi_build_default_ports(ports_b, 655, 0, 0, 0, 0) /* UDP */);",
          "1546:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_SAFE, NDPI_PROTOCOL_FIX, 0 /* can_have_a_subprotocol */, no_master,",
          "1547:      no_master, \"FIX\", NDPI_PROTOCOL_CATEGORY_RPC,",
          "1548:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1549:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1550:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_NINTENDO, 0 /* can_have_a_subprotocol */,",
          "1551:      no_master, no_master, \"Nintendo\", NDPI_PROTOCOL_CATEGORY_GAME,",
          "1552:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1553:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1554:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_CSGO, 0 /* can_have_a_subprotocol */, no_master,",
          "1555:      no_master, \"CSGO\", NDPI_PROTOCOL_CATEGORY_GAME,",
          "1556:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1557:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1558:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_AJP, 0 /* can_have_a_subprotocol */,",
          "1559:      no_master, no_master, \"AJP\", NDPI_PROTOCOL_CATEGORY_WEB,",
          "1560:      ndpi_build_default_ports(ports_a, 8009, 0, 0, 0, 0) /* TCP */,",
          "1561:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1562:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_TARGUS_GETDATA,",
          "1563:      0 /* can_have_a_subprotocol */, no_master, no_master, \"Targus Dataspeed\",",
          "1564:      NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1565:      ndpi_build_default_ports(ports_a, 5001, 5201, 0, 0, 0) /* TCP */,",
          "1566:      ndpi_build_default_ports(ports_b, 5001, 5201, 0, 0, 0) /* UDP */);",
          "1567:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_AMAZON_VIDEO,",
          "1568:      0 /* can_have_a_subprotocol */, no_master, no_master, \"AmazonVideo\",",
          "1569:      NDPI_PROTOCOL_CATEGORY_CLOUD, ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1570:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1571:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_DNP3, 1 /* no subprotocol */, no_master,",
          "1572:      no_master, \"DNP3\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1573:      ndpi_build_default_ports(ports_a, 20000, 0, 0, 0, 0) /* TCP */,",
          "1574:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1575:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_IEC60870, 1 /* no subprotocol */,",
          "1576:      no_master, no_master, \"IEC60870\",",
          "1578:      ndpi_build_default_ports(ports_a, 2404, 0, 0, 0, 0) /* TCP */,",
          "1579:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1580:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_BLOOMBERG, 1 /* no subprotocol */,",
          "1581:      no_master, no_master, \"Bloomberg\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1582:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1583:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1584:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_CAPWAP, 1 /* no subprotocol */, no_master,",
          "1585:      no_master, \"CAPWAP\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1586:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1588:      );",
          "1589:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_ZABBIX, 1 /* no subprotocol */, no_master,",
          "1590:      no_master, \"Zabbix\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1591:      ndpi_build_default_ports(ports_a, 10050, 0, 0, 0, 0) /* TCP */,",
          "1593:      );",
          "1594:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_S7COMM, 1 /* no subprotocol */, no_master,",
          "1595:      no_master, \"s7comm\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1596:      ndpi_build_default_ports(ports_a, 102, 0, 0, 0, 0) /* TCP */,",
          "1597:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1598:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_SAFE, NDPI_PROTOCOL_MSTEAMS, 1 /* no subprotocol */, no_master,",
          "1599:      no_master, \"Teams\", NDPI_PROTOCOL_CATEGORY_COLLABORATIVE,",
          "1600:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1602:      );",
          "1603:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_WEBSOCKET,",
          "1604:      1 /* can_have_a_subprotocol */, no_master,",
          "1605:      no_master, \"WebSocket\", NDPI_PROTOCOL_CATEGORY_WEB,",
          "1606:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1607:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1614:   init_string_based_protocols(ndpi_str);",
          "1616:   ndpi_validate_protocol_initialization(ndpi_str);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1677: #ifdef MATCH_DEBUG",
          "1681: #endif",
          "1685: #ifdef MATCH_DEBUG",
          "1688: #endif",
          "1692:       The patch below allows in case of pattern ws.amazon.com",
          "1693:       to avoid matching aws.amazon.com whereas a.ws.amazon.com",
          "1694:       has to match",
          "1708:     }",
          "1711:     Return 1 for stopping to the first match.",
          "1712:     We might consider searching for the more",
          "1713:     specific match, paying more cpu cycles.",
          "1720: #ifdef MATCH_DEBUG",
          "1725: #endif",
          "1728: #ifdef MATCH_DEBUG",
          "1730: #endif",
          "1733: }",
          "1751: }",
          "1757: #ifdef PATRICIA_IPV6",
          "1765: #else",
          "1767: #endif",
          "1768: }",
          "1772: u_int16_t ndpi_network_ptree_match(struct ndpi_detection_module_struct *ndpi_str,",
          "1783: }",
          "",
          "[Removed Lines]",
          "1667: static int ac_match_handler(AC_MATCH_t *m, AC_TEXT_t *txt, AC_REP_t *match)",
          "1668: {",
          "1669:     int min_len = (txt->length < m->patterns->length) ? txt->length : m->patterns->length;",
          "1670:     char buf[64] = {'\\0'}, *whatfound;",
          "1671:     int min_buf_len = (txt->length > 63 /* sizeof(buf)-1 */) ? 63 : txt->length;",
          "1672:     u_int buf_len = strlen(buf);",
          "1674:     strncpy(buf, txt->astring, min_buf_len);",
          "1675:     buf[min_buf_len] = '\\0';",
          "1678:     printf(\"Searching [to search: %s/%u][pattern: %s/%u] [len: %d][match_num: %u][%s]\\n\", buf,",
          "1679:            (unigned int) txt->length, m->patterns->astring, (unigned int) m->patterns->length, min_len, m->match_num,",
          "1680:            m->patterns->astring);",
          "1683:     whatfound = strstr(buf, m->patterns->astring);",
          "1686:     printf(\"[NDPI] %s() [searching=%s][pattern=%s][%s][%c]\\n\", __FUNCTION__, buf, m->patterns->astring,",
          "1687:            whatfound ? whatfound : \"<NULL>\", whatfound[-1]);",
          "1690:     if (whatfound) {",
          "1697:             && strchr(m->patterns->astring, '.') /* The matched pattern has a . (e.g. numeric or sym IPs) */) {",
          "1698:             int len = strlen(m->patterns->astring);",
          "1700:             if ((whatfound[-1] != '.') || ((m->patterns->astring[len - 1] != '.') &&",
          "1701:                                            (whatfound[len] != '\\0') /* endsWith does not hold here */)) {",
          "1702:                 return (0);",
          "1703:             } else {",
          "1706:             }",
          "1707:         }",
          "1715:     memcpy(match, &m->patterns[0].rep, sizeof(AC_REP_t));",
          "1717:     if (((buf_len >= min_len) && (strncmp(&buf[buf_len - min_len], m->patterns->astring, min_len) == 0)) ||",
          "1719:     ) {",
          "1721:         printf(\"Found match [%s][%s] [len: %d]\"",
          "1723:                \"\\n\",",
          "1724:                buf, m->patterns->astring, min_len /* , *matching_protocol_id */);",
          "1727:     } else {",
          "1729:         printf(\"NO match found: continue\\n\");",
          "1732:     }",
          "1737: static int fill_prefix_v4(prefix_t *p, const struct in_addr *a, int b, int mb)",
          "1738: {",
          "1739:     do {",
          "1740:         if (b < 0 || b > mb)",
          "1741:             return (-1);",
          "1743:         memset(p, 0, sizeof(prefix_t));",
          "1744:         memcpy(&p->add.sin, a, (mb + 7) / 8);",
          "1745:         p->family = AF_INET;",
          "1746:         p->bitlen = b;",
          "1747:         p->ref_count = 0;",
          "1748:     } while (0);",
          "1750:     return (0);",
          "1755: static int fill_prefix_v6(prefix_t *prefix, const struct in6_addr *addr, int bits, int maxbits)",
          "1756: {",
          "1758:     if (bits < 0 || bits > maxbits)",
          "1759:         return -1;",
          "1761:     memcpy(&prefix->add.sin6, addr, (maxbits + 7) / 8);",
          "1762:     prefix->family = AF_INET6, prefix->bitlen = bits, prefix->ref_count = 0;",
          "1764:     return 0;",
          "1766:     return (-1);",
          "1773:                                    struct in_addr *pin /* network byte order */)",
          "1774: {",
          "1775:     prefix_t prefix;",
          "1776:     patricia_node_t *node;",
          "1779:     fill_prefix_v4(&prefix, pin, 32, ((patricia_tree_t *) ndpi_str->protocols_ptree)->maxbits);",
          "1780:     node = ndpi_patricia_search_best(ndpi_str->protocols_ptree, &prefix);",
          "1782:     return (node ? node->value.user_value : NDPI_PROTOCOL_UNKNOWN);",
          "",
          "[Added Lines]",
          "1627: static int ac_match_handler(AC_MATCH_t *m, AC_TEXT_t *txt, AC_REP_t *match) {",
          "1628:   int min_len = (txt->length < m->patterns->length) ? txt->length : m->patterns->length;",
          "1629:   char buf[64] = {'\\0'}, *whatfound;",
          "1630:   int min_buf_len = (txt->length > 63 /* sizeof(buf)-1 */) ? 63 : txt->length;",
          "1631:   u_int buf_len = strlen(buf);",
          "1633:   strncpy(buf, txt->astring, min_buf_len);",
          "1634:   buf[min_buf_len] = '\\0';",
          "1637:   printf(\"Searching [to search: %s/%u][pattern: %s/%u] [len: %d][match_num: %u][%s]\\n\", buf,",
          "1638:   (unigned int) txt->length, m->patterns->astring, (unigned int) m->patterns->length, min_len, m->match_num,",
          "1639:   m->patterns->astring);",
          "1642:   whatfound = strstr(buf, m->patterns->astring);",
          "1645:   printf(\"[NDPI] %s() [searching=%s][pattern=%s][%s][%c]\\n\", __FUNCTION__, buf, m->patterns->astring,",
          "1646:   whatfound ? whatfound : \"<NULL>\", whatfound[-1]);",
          "1649:   if(whatfound) {",
          "1656:        && strchr(m->patterns->astring, '.') /* The matched pattern has a . (e.g. numeric or sym IPs) */) {",
          "1657:       int len = strlen(m->patterns->astring);",
          "1659:       if((whatfound[-1] != '.') || ((m->patterns->astring[len - 1] != '.') &&",
          "1660:         (whatfound[len] != '\\0') /* endsWith does not hold here */)) {",
          "1661:  return(0);",
          "1662:       } else {",
          "1665:       }",
          "1667:   }",
          "1674:   memcpy(match, &m->patterns[0].rep, sizeof(AC_REP_t));",
          "1676:   if(((buf_len >= min_len) && (strncmp(&buf[buf_len - min_len], m->patterns->astring, min_len) == 0)) ||",
          "1678:      ) {",
          "1680:     printf(\"Found match [%s][%s] [len: %d]\"",
          "1682:     \"\\n\",",
          "1683:     buf, m->patterns->astring, min_len /* , *matching_protocol_id */);",
          "1686:   } else {",
          "1688:     printf(\"NO match found: continue\\n\");",
          "1691:   }",
          "1696: static int fill_prefix_v4(prefix_t *p, const struct in_addr *a, int b, int mb) {",
          "1697:   do {",
          "1698:     if(b < 0 || b > mb)",
          "1699:       return(-1);",
          "1701:     memset(p, 0, sizeof(prefix_t));",
          "1702:     memcpy(&p->add.sin, a, (mb + 7) / 8);",
          "1703:     p->family = AF_INET;",
          "1704:     p->bitlen = b;",
          "1705:     p->ref_count = 0;",
          "1706:   } while (0);",
          "1708:   return(0);",
          "1713: static int fill_prefix_v6(prefix_t *prefix, const struct in6_addr *addr, int bits, int maxbits) {",
          "1715:   if(bits < 0 || bits > maxbits)",
          "1716:     return -1;",
          "1718:   memcpy(&prefix->add.sin6, addr, (maxbits + 7) / 8);",
          "1719:   prefix->family = AF_INET6, prefix->bitlen = bits, prefix->ref_count = 0;",
          "1721:   return 0;",
          "1723:   return(-1);",
          "1730:                                    struct in_addr *pin /* network byte order */) {",
          "1731:   prefix_t prefix;",
          "1732:   patricia_node_t *node;",
          "1735:   fill_prefix_v4(&prefix, pin, 32, ((patricia_tree_t *) ndpi_str->protocols_ptree)->maxbits);",
          "1736:   node = ndpi_patricia_search_best(ndpi_str->protocols_ptree, &prefix);",
          "1738:   return(node ? node->value.user_value : NDPI_PROTOCOL_UNKNOWN);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1804:     }",
          "1807: }",
          "1821: }",
          "",
          "[Removed Lines]",
          "1795: u_int8_t ndpi_is_tor_flow(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow)",
          "1796: {",
          "1797:     struct ndpi_packet_struct *packet = &flow->packet;",
          "1799:     if (packet->tcp != NULL) {",
          "1800:         if (packet->iph) {",
          "1801:             if (flow->guessed_host_protocol_id == NDPI_PROTOCOL_TOR)",
          "1802:                 return (1);",
          "1803:         }",
          "1806:     return (0);",
          "1811: static patricia_node_t *add_to_ptree(patricia_tree_t *tree, int family, void *addr, int bits)",
          "1812: {",
          "1813:     prefix_t prefix;",
          "1814:     patricia_node_t *node;",
          "1816:     fill_prefix_v4(&prefix, (struct in_addr *) addr, bits, tree->maxbits);",
          "1818:     node = ndpi_patricia_lookup(tree, &prefix);",
          "1820:     return (node);",
          "",
          "[Added Lines]",
          "1751: u_int8_t ndpi_is_tor_flow(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow) {",
          "1752:   struct ndpi_packet_struct *packet = &flow->packet;",
          "1754:   if(packet->tcp != NULL) {",
          "1755:     if(packet->iph) {",
          "1756:       if(flow->guessed_host_protocol_id == NDPI_PROTOCOL_TOR)",
          "1757:  return(1);",
          "1759:   }",
          "1761:   return(0);",
          "1766: static patricia_node_t *add_to_ptree(patricia_tree_t *tree, int family, void *addr, int bits) {",
          "1767:   prefix_t prefix;",
          "1768:   patricia_node_t *node;",
          "1770:   fill_prefix_v4(&prefix, (struct in_addr *) addr, bits, tree->maxbits);",
          "1772:   node = ndpi_patricia_lookup(tree, &prefix);",
          "1774:   return(node);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1828:   Return: the number of entries loaded or -1 in case of error",
          "1869:     }",
          "1873: }",
          "1893: }",
          "1917: }",
          "1922: }",
          "1926: }",
          "1931: }",
          "1935: }",
          "1937: void ndpi_debug_printf(unsigned int proto, struct ndpi_detection_module_struct *ndpi_str, ndpi_log_level_t log_level,",
          "1940: #ifdef NDPI_ENABLE_DEBUG_MESSAGES",
          "1942: #define MAX_STR_LEN 250",
          "1956: #endif",
          "1957: }",
          "1961: #ifdef NDPI_ENABLE_DEBUG_MESSAGES",
          "1963: #endif",
          "1964: }",
          "",
          "[Removed Lines]",
          "1830: int ndpi_load_ipv4_ptree(struct ndpi_detection_module_struct *ndpi_str, const char *path, u_int16_t protocol_id)",
          "1831: {",
          "1832:     char buffer[128], *line, *addr, *cidr, *saveptr;",
          "1833:     FILE *fd;",
          "1834:     int len;",
          "1835:     u_int num_loaded = 0;",
          "1837:     fd = fopen(path, \"r\");",
          "1839:     if (fd == NULL) {",
          "1840:         NDPI_LOG_ERR(ndpi_str, \"Unable to open file %s [%s]\\n\", path, strerror(errno));",
          "1841:         return (-1);",
          "1842:     }",
          "1844:     while (1) {",
          "1845:         line = fgets(buffer, sizeof(buffer), fd);",
          "1847:         if (line == NULL)",
          "1848:             break;",
          "1850:         len = strlen(line);",
          "1852:         if ((len <= 1) || (line[0] == '#'))",
          "1853:             continue;",
          "1855:         line[len - 1] = '\\0';",
          "1856:         addr = strtok_r(line, \"/\", &saveptr);",
          "1858:         if (addr) {",
          "1859:             struct in_addr pin;",
          "1860:             patricia_node_t *node;",
          "1862:             cidr = strtok_r(NULL, \"\\n\", &saveptr);",
          "1864:             pin.s_addr = inet_addr(addr);",
          "1865:             if ((node = add_to_ptree(ndpi_str->protocols_ptree, AF_INET, &pin, cidr ? atoi(cidr) : 32 /* bits */)) !=",
          "1866:                 NULL)",
          "1867:                 node->value.user_value = protocol_id, num_loaded++;",
          "1868:         }",
          "1871:     fclose(fd);",
          "1872:     return (num_loaded);",
          "1877: static void ndpi_init_ptree_ipv4(struct ndpi_detection_module_struct *ndpi_str, void *ptree, ndpi_network host_list[],",
          "1878:                                  u_int8_t skip_tor_hosts)",
          "1879: {",
          "1880:     int i;",
          "1882:     for (i = 0; host_list[i].network != 0x0; i++) {",
          "1883:         struct in_addr pin;",
          "1884:         patricia_node_t *node;",
          "1886:         if (skip_tor_hosts && (host_list[i].value == NDPI_PROTOCOL_TOR))",
          "1887:             continue;",
          "1889:         pin.s_addr = htonl(host_list[i].network);",
          "1890:         if ((node = add_to_ptree(ptree, AF_INET, &pin, host_list[i].cidr /* bits */)) != NULL)",
          "1891:             node->value.user_value = host_list[i].value;",
          "1892:     }",
          "1897: static int ndpi_add_host_ip_subprotocol(struct ndpi_detection_module_struct *ndpi_str, char *value, int protocol_id)",
          "1898: {",
          "1899:     patricia_node_t *node;",
          "1900:     struct in_addr pin;",
          "1901:     int bits = 32;",
          "1902:     char *ptr = strrchr(value, '/');",
          "1904:     if (ptr) {",
          "1905:         ptr[0] = '\\0';",
          "1906:         ptr++;",
          "1907:         if (atoi(ptr) >= 0 && atoi(ptr) <= 32)",
          "1908:             bits = atoi(ptr);",
          "1909:     }",
          "1911:     inet_pton(AF_INET, value, &pin);",
          "1913:     if ((node = add_to_ptree(ndpi_str->protocols_ptree, AF_INET, &pin, bits)) != NULL)",
          "1914:         node->value.user_value = protocol_id;",
          "1916:     return (0);",
          "1919: void set_ndpi_malloc(void *(*__ndpi_malloc)(size_t size))",
          "1920: {",
          "1921:     _ndpi_malloc = __ndpi_malloc;",
          "1923: void set_ndpi_flow_malloc(void *(*__ndpi_flow_malloc)(size_t size))",
          "1924: {",
          "1925:     _ndpi_flow_malloc = __ndpi_flow_malloc;",
          "1928: void set_ndpi_free(void (*__ndpi_free)(void *ptr))",
          "1929: {",
          "1930:     _ndpi_free = __ndpi_free;",
          "1932: void set_ndpi_flow_free(void (*__ndpi_flow_free)(void *ptr))",
          "1933: {",
          "1934:     _ndpi_flow_free = __ndpi_flow_free;",
          "1938:                        const char *file_name, const char *func_name, int line_number, const char *format, ...)",
          "1939: {",
          "1941:     va_list args;",
          "1943:     char str[MAX_STR_LEN];",
          "1944:     if (ndpi_str != NULL && log_level > NDPI_LOG_ERROR && proto > 0 && proto < NDPI_MAX_SUPPORTED_PROTOCOLS &&",
          "1945:         !NDPI_ISSET(&ndpi_str->debug_bitmask, proto))",
          "1946:         return;",
          "1947:     va_start(args, format);",
          "1948:     vsnprintf(str, sizeof(str) - 1, format, args);",
          "1949:     va_end(args);",
          "1951:     if (ndpi_str != NULL) {",
          "1952:         printf(\"%s:%s:%-3d - [%s]: %s\", file_name, func_name, line_number, ndpi_get_proto_name(ndpi_str, proto), str);",
          "1953:     } else {",
          "1954:         printf(\"Proto: %u, %s\", proto, str);",
          "1955:     }",
          "1959: void set_ndpi_debug_function(struct ndpi_detection_module_struct *ndpi_str, ndpi_debug_function_ptr ndpi_debug_printf)",
          "1960: {",
          "1962:     ndpi_str->ndpi_debug_printf = ndpi_debug_printf;",
          "",
          "[Added Lines]",
          "1784: int ndpi_load_ipv4_ptree(struct ndpi_detection_module_struct *ndpi_str,",
          "1785:     const char *path, u_int16_t protocol_id) {",
          "1786:   char buffer[128], *line, *addr, *cidr, *saveptr;",
          "1787:   FILE *fd;",
          "1788:   int len;",
          "1789:   u_int num_loaded = 0;",
          "1791:   fd = fopen(path, \"r\");",
          "1793:   if(fd == NULL) {",
          "1794:     NDPI_LOG_ERR(ndpi_str, \"Unable to open file %s [%s]\\n\", path, strerror(errno));",
          "1795:     return(-1);",
          "1796:   }",
          "1798:   while (1) {",
          "1799:     line = fgets(buffer, sizeof(buffer), fd);",
          "1801:     if(line == NULL)",
          "1802:       break;",
          "1804:     len = strlen(line);",
          "1806:     if((len <= 1) || (line[0] == '#'))",
          "1807:       continue;",
          "1809:     line[len - 1] = '\\0';",
          "1810:     addr = strtok_r(line, \"/\", &saveptr);",
          "1812:     if(addr) {",
          "1813:       struct in_addr pin;",
          "1814:       patricia_node_t *node;",
          "1816:       cidr = strtok_r(NULL, \"\\n\", &saveptr);",
          "1818:       pin.s_addr = inet_addr(addr);",
          "1819:       if((node = add_to_ptree(ndpi_str->protocols_ptree, AF_INET, &pin, cidr ? atoi(cidr) : 32 /* bits */)) != NULL)",
          "1820:  node->value.user_value = protocol_id, node->value.user_value2 = 0 /* port */, num_loaded++;",
          "1822:   }",
          "1824:   fclose(fd);",
          "1825:   return(num_loaded);",
          "1830: static void ndpi_init_ptree_ipv4(struct ndpi_detection_module_struct *ndpi_str,",
          "1831:      void *ptree, ndpi_network host_list[],",
          "1832:                                  u_int8_t skip_tor_hosts) {",
          "1833:   int i;",
          "1835:   for (i = 0; host_list[i].network != 0x0; i++) {",
          "1836:     struct in_addr pin;",
          "1837:     patricia_node_t *node;",
          "1839:     if(skip_tor_hosts && (host_list[i].value == NDPI_PROTOCOL_TOR))",
          "1840:       continue;",
          "1842:     pin.s_addr = htonl(host_list[i].network);",
          "1843:     if((node = add_to_ptree(ptree, AF_INET, &pin, host_list[i].cidr /* bits */)) != NULL)",
          "1844:       node->value.user_value = host_list[i].value, node->value.user_value2 = 0;",
          "1845:   }",
          "1850: static int ndpi_add_host_ip_subprotocol(struct ndpi_detection_module_struct *ndpi_str,",
          "1851:      char *value, u_int16_t protocol_id) {",
          "1852:   patricia_node_t *node;",
          "1853:   struct in_addr pin;",
          "1854:   int bits = 32;",
          "1855:   char *ptr = strrchr(value, '/');",
          "1857:   char *double_column;",
          "1859:   if(ptr) {",
          "1860:     ptr[0] = '\\0';",
          "1861:     ptr++;",
          "1863:     if((double_column = strrchr(ptr, ':')) != NULL) {",
          "1864:       double_column[0] = '\\0';",
          "1865:       port = atoi(&double_column[1]);",
          "1866:     }",
          "1868:     if(atoi(ptr) >= 0 && atoi(ptr) <= 32)",
          "1869:       bits = atoi(ptr);",
          "1870:   } else {",
          "1872:       Let's check if there is the port defined",
          "1873:       Example: ip:8.248.73.247:443@AmazonPrime",
          "1875:     double_column = strrchr(value, ':');",
          "1877:     if(double_column)",
          "1878:       port = atoi(&double_column[1]);",
          "1879:   }",
          "1881:   inet_pton(AF_INET, value, &pin);",
          "1883:   if((node = add_to_ptree(ndpi_str->protocols_ptree, AF_INET, &pin, bits)) != NULL)",
          "1884:     node->value.user_value = protocol_id, node->value.user_value2 = port;",
          "1886:   return(0);",
          "1889: void set_ndpi_malloc(void *(*__ndpi_malloc)(size_t size)) {",
          "1890:   _ndpi_malloc = __ndpi_malloc;",
          "1892: void set_ndpi_flow_malloc(void *(*__ndpi_flow_malloc)(size_t size)) {",
          "1893:   _ndpi_flow_malloc = __ndpi_flow_malloc;",
          "1896: void set_ndpi_free(void (*__ndpi_free)(void *ptr)) {",
          "1897:   _ndpi_free = __ndpi_free;",
          "1899: void set_ndpi_flow_free(void (*__ndpi_flow_free)(void *ptr)) {",
          "1900:   _ndpi_flow_free = __ndpi_flow_free;",
          "1904:                        const char *file_name, const char *func_name, int line_number, const char *format, ...) {",
          "1906:   va_list args;",
          "1908:   char str[MAX_STR_LEN];",
          "1909:   if(ndpi_str != NULL && log_level > NDPI_LOG_ERROR && proto > 0 && proto < NDPI_MAX_SUPPORTED_PROTOCOLS &&",
          "1910:      !NDPI_ISSET(&ndpi_str->debug_bitmask, proto))",
          "1911:     return;",
          "1912:   va_start(args, format);",
          "1913:   vsnprintf(str, sizeof(str) - 1, format, args);",
          "1914:   va_end(args);",
          "1916:   if(ndpi_str != NULL) {",
          "1917:     printf(\"%s:%s:%-3d - [%s]: %s\", file_name, func_name, line_number, ndpi_get_proto_name(ndpi_str, proto), str);",
          "1918:   } else {",
          "1919:     printf(\"Proto: %u, %s\", proto, str);",
          "1920:   }",
          "1924: void set_ndpi_debug_function(struct ndpi_detection_module_struct *ndpi_str, ndpi_debug_function_ptr ndpi_debug_printf) {",
          "1926:   ndpi_str->ndpi_debug_printf = ndpi_debug_printf;",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1969: static const char *categories[] = {",
          "2076: };",
          "2086: #ifdef NDPI_ENABLE_DEBUG_MESSAGES",
          "2094: #ifdef NDPI_ENABLE_DEBUG_MESSAGES",
          "2102: #ifdef NDPI_ENABLE_DEBUG_MESSAGES",
          "2104: #endif",
          "2142: #ifdef HAVE_HYPERSCAN",
          "2145: #else",
          "2148: #endif",
          "2163: }",
          "2200:     }",
          "2201: }",
          "2209: }",
          "2227: }",
          "2232: }",
          "2237: }",
          "2241: }",
          "2259:     As ac_automata_search can detect partial matches and continue the search process",
          "2260:     in case rc == 0 (i.e. no match), we need to check if there is a partial match",
          "2261:     and in this case return it",
          "2267: }",
          "2286:     As ac_automata_search can detect partial matches and continue the search process",
          "2287:     in case rc == 0 (i.e. no match), we need to check if there is a partial match",
          "2288:     and in this case return it",
          "2296: }",
          "",
          "[Removed Lines]",
          "1970:     \"Unspecified\",",
          "1971:     \"Media\",",
          "1972:     \"VPN\",",
          "1973:     \"Email\",",
          "1974:     \"DataTransfer\",",
          "1975:     \"Web\",",
          "1976:     \"SocialNetwork\",",
          "1977:     \"Download-FileTransfer-FileSharing\",",
          "1978:     \"Game\",",
          "1979:     \"Chat\",",
          "1980:     \"VoIP\",",
          "1981:     \"Database\",",
          "1982:     \"RemoteAccess\",",
          "1983:     \"Cloud\",",
          "1984:     \"Network\",",
          "1985:     \"Collaborative\",",
          "1986:     \"RPC\",",
          "1987:     \"Streaming\",",
          "1988:     \"System\",",
          "1989:     \"SoftwareUpdate\",",
          "1990:     \"\",",
          "1991:     \"\",",
          "1992:     \"\",",
          "1993:     \"\",",
          "1994:     \"\",",
          "1995:     \"Music\",",
          "1996:     \"Video\",",
          "1997:     \"Shopping\",",
          "1998:     \"Productivity\",",
          "1999:     \"FileSharing\",",
          "2000:     \"\",",
          "2001:     \"\",",
          "2002:     \"\",",
          "2003:     \"\",",
          "2004:     \"\",",
          "2005:     \"\",",
          "2006:     \"\",",
          "2007:     \"\",",
          "2008:     \"\",",
          "2009:     \"\",",
          "2010:     \"\",",
          "2011:     \"\",",
          "2012:     \"\",",
          "2013:     \"\",",
          "2014:     \"\",",
          "2015:     \"\",",
          "2016:     \"\",",
          "2017:     \"\",",
          "2018:     \"\",",
          "2019:     \"\",",
          "2020:     \"\",",
          "2021:     \"\",",
          "2022:     \"\",",
          "2023:     \"\",",
          "2024:     \"\",",
          "2025:     \"\",",
          "2026:     \"\",",
          "2027:     \"\",",
          "2028:     \"\",",
          "2029:     \"\",",
          "2030:     \"\",",
          "2031:     \"\",",
          "2032:     \"\",",
          "2033:     \"\",",
          "2034:     \"\",",
          "2035:     \"\",",
          "2036:     \"\",",
          "2037:     \"\",",
          "2038:     \"\",",
          "2039:     \"\",",
          "2040:     \"\",",
          "2041:     \"\",",
          "2042:     \"\",",
          "2043:     \"\",",
          "2044:     \"\",",
          "2045:     \"\",",
          "2046:     \"\",",
          "2047:     \"\",",
          "2048:     \"\",",
          "2049:     \"\",",
          "2050:     \"\",",
          "2051:     \"\",",
          "2052:     \"\",",
          "2053:     \"\",",
          "2054:     \"\",",
          "2055:     \"\",",
          "2056:     \"\",",
          "2057:     \"\",",
          "2058:     \"\",",
          "2059:     \"\",",
          "2060:     \"\",",
          "2061:     \"\",",
          "2062:     \"\",",
          "2063:     \"\",",
          "2064:     \"\",",
          "2065:     \"\",",
          "2066:     \"\",",
          "2067:     \"\",",
          "2068:     \"\",",
          "2070:     \"Malware\",",
          "2071:     \"Advertisement\",",
          "2072:     \"Banned_Site\",",
          "2073:     \"Site_Unavailable\",",
          "2074:     \"Allowed_Site\",",
          "2075:     \"Antimalware\",",
          "2080: struct ndpi_detection_module_struct *ndpi_init_detection_module(ndpi_init_prefs prefs)",
          "2081: {",
          "2082:     struct ndpi_detection_module_struct *ndpi_str = ndpi_malloc(sizeof(struct ndpi_detection_module_struct));",
          "2083:     int i;",
          "2085:     if (ndpi_str == NULL) {",
          "2087:         NDPI_LOG_ERR(ndpi_str, \"ndpi_init_detection_module initial malloc failed for ndpi_str\\n\");",
          "2089:         return (NULL);",
          "2090:     }",
          "2092:     memset(ndpi_str, 0, sizeof(struct ndpi_detection_module_struct));",
          "2095:     set_ndpi_debug_function(ndpi_str, (ndpi_debug_function_ptr) ndpi_debug_printf);",
          "2098:     if ((ndpi_str->protocols_ptree = ndpi_New_Patricia(32 /* IPv4 */)) != NULL)",
          "2099:         ndpi_init_ptree_ipv4(ndpi_str, ndpi_str->protocols_ptree, host_protocol_list, prefs & ndpi_dont_load_tor_hosts);",
          "2101:     NDPI_BITMASK_RESET(ndpi_str->detection_bitmask);",
          "2103:     ndpi_str->user_data = NULL;",
          "2107:     ndpi_str->tcp_max_retransmission_window_size = NDPI_DEFAULT_MAX_TCP_RETRANSMISSION_WINDOW_SIZE;",
          "2108:     ndpi_str->directconnect_connection_ip_tick_timeout =",
          "2109:         NDPI_DIRECTCONNECT_CONNECTION_IP_TICK_TIMEOUT * ndpi_str->ticks_per_second;",
          "2111:     ndpi_str->rtsp_connection_timeout = NDPI_RTSP_CONNECTION_TIMEOUT * ndpi_str->ticks_per_second;",
          "2112:     ndpi_str->tvants_connection_timeout = NDPI_TVANTS_CONNECTION_TIMEOUT * ndpi_str->ticks_per_second;",
          "2113:     ndpi_str->irc_timeout = NDPI_IRC_CONNECTION_TIMEOUT * ndpi_str->ticks_per_second;",
          "2114:     ndpi_str->gnutella_timeout = NDPI_GNUTELLA_CONNECTION_TIMEOUT * ndpi_str->ticks_per_second;",
          "2116:     ndpi_str->battlefield_timeout = NDPI_BATTLEFIELD_CONNECTION_TIMEOUT * ndpi_str->ticks_per_second;",
          "2118:     ndpi_str->thunder_timeout = NDPI_THUNDER_CONNECTION_TIMEOUT * ndpi_str->ticks_per_second;",
          "2119:     ndpi_str->yahoo_detect_http_connections = NDPI_YAHOO_DETECT_HTTP_CONNECTIONS;",
          "2121:     ndpi_str->yahoo_lan_video_timeout = NDPI_YAHOO_LAN_VIDEO_TIMEOUT * ndpi_str->ticks_per_second;",
          "2122:     ndpi_str->zattoo_connection_timeout = NDPI_ZATTOO_CONNECTION_TIMEOUT * ndpi_str->ticks_per_second;",
          "2123:     ndpi_str->jabber_stun_timeout = NDPI_JABBER_STUN_TIMEOUT * ndpi_str->ticks_per_second;",
          "2124:     ndpi_str->jabber_file_transfer_timeout = NDPI_JABBER_FT_TIMEOUT * ndpi_str->ticks_per_second;",
          "2125:     ndpi_str->soulseek_connection_ip_tick_timeout =",
          "2126:         NDPI_SOULSEEK_CONNECTION_IP_TICK_TIMEOUT * ndpi_str->ticks_per_second;",
          "2128:     ndpi_str->ndpi_num_supported_protocols = NDPI_MAX_SUPPORTED_PROTOCOLS;",
          "2129:     ndpi_str->ndpi_num_custom_protocols = 0;",
          "2131:     ndpi_str->host_automa.ac_automa = ac_automata_init(ac_match_handler);",
          "2132:     ndpi_str->content_automa.ac_automa = ac_automata_init(ac_match_handler);",
          "2133:     ndpi_str->bigrams_automa.ac_automa = ac_automata_init(ac_match_handler);",
          "2134:     ndpi_str->impossible_bigrams_automa.ac_automa = ac_automata_init(ac_match_handler);",
          "2136:     if ((sizeof(categories) / sizeof(char *)) != NDPI_PROTOCOL_NUM_CATEGORIES) {",
          "2137:         NDPI_LOG_ERR(ndpi_str, \"[NDPI] invalid categories length: expected %u, got %u\\n\", NDPI_PROTOCOL_NUM_CATEGORIES,",
          "2138:                      (unsigned int) (sizeof(categories) / sizeof(char *)));",
          "2139:         return (NULL);",
          "2140:     }",
          "2143:     ndpi_str->custom_categories.num_to_load = 0, ndpi_str->custom_categories.to_load = NULL;",
          "2144:     ndpi_str->custom_categories.hostnames = NULL;",
          "2146:     ndpi_str->custom_categories.hostnames.ac_automa = ac_automata_init(ac_match_handler);",
          "2147:     ndpi_str->custom_categories.hostnames_shadow.ac_automa = ac_automata_init(ac_match_handler);",
          "2150:     ndpi_str->custom_categories.ipAddresses = ndpi_New_Patricia(32 /* IPv4 */);",
          "2151:     ndpi_str->custom_categories.ipAddresses_shadow = ndpi_New_Patricia(32 /* IPv4 */);",
          "2153:     if ((ndpi_str->custom_categories.ipAddresses == NULL) || (ndpi_str->custom_categories.ipAddresses_shadow == NULL))",
          "2154:         return (NULL);",
          "2156:     ndpi_init_protocol_defaults(ndpi_str);",
          "2158:     for (i = 0; i < NUM_CUSTOM_CATEGORIES; i++)",
          "2159:         snprintf(ndpi_str->custom_category_labels[i], CUSTOM_CATEGORY_LABEL_LEN, \"User custom category %u\",",
          "2160:                  (unsigned int) (i + 1));",
          "2162:     return (ndpi_str);",
          "2167: void ndpi_finalize_initalization(struct ndpi_detection_module_struct *ndpi_str)",
          "2168: {",
          "2169:     u_int i;",
          "2171:     for (i = 0; i < 4; i++) {",
          "2172:         ndpi_automa *automa;",
          "2174:         switch (i) {",
          "2175:             case 0:",
          "2176:                 automa = &ndpi_str->host_automa;",
          "2177:                 break;",
          "2179:             case 1:",
          "2180:                 automa = &ndpi_str->content_automa;",
          "2181:                 break;",
          "2183:             case 2:",
          "2184:                 automa = &ndpi_str->bigrams_automa;",
          "2185:                 break;",
          "2187:             case 3:",
          "2188:                 automa = &ndpi_str->impossible_bigrams_automa;",
          "2189:                 break;",
          "2191:             default:",
          "2192:                 automa = NULL;",
          "2193:                 break;",
          "2194:         }",
          "2196:         if (automa) {",
          "2197:             ac_automata_finalize((AC_AUTOMATA_t *) automa->ac_automa);",
          "2198:             automa->ac_automa_finalized = 1;",
          "2199:         }",
          "2206: void *ndpi_init_automa(void)",
          "2207: {",
          "2208:     return (ac_automata_init(ac_match_handler));",
          "2211: int ndpi_add_string_value_to_automa(void *_automa, char *str, unsigned long num)",
          "2212: {",
          "2213:     AC_PATTERN_t ac_pattern;",
          "2214:     AC_AUTOMATA_t *automa = (AC_AUTOMATA_t *) _automa;",
          "2215:     AC_ERROR_t rc;",
          "2217:     if (automa == NULL)",
          "2218:         return (-1);",
          "2220:     memset(&ac_pattern, 0, sizeof(ac_pattern));",
          "2221:     ac_pattern.astring = str;",
          "2222:     ac_pattern.rep.number = num;",
          "2223:     ac_pattern.length = strlen(ac_pattern.astring);",
          "2225:     rc = ac_automata_add(automa, &ac_pattern);",
          "2226:     return (rc == ACERR_SUCCESS || rc == ACERR_DUPLICATE_PATTERN ? 0 : -1);",
          "2229: int ndpi_add_string_to_automa(void *_automa, char *str)",
          "2230: {",
          "2231:     return (ndpi_add_string_value_to_automa(_automa, str, 1));",
          "2234: void ndpi_free_automa(void *_automa)",
          "2235: {",
          "2236:     ac_automata_release((AC_AUTOMATA_t *) _automa, 0);",
          "2238: void ndpi_finalize_automa(void *_automa)",
          "2239: {",
          "2240:     ac_automata_finalize((AC_AUTOMATA_t *) _automa);",
          "2245: int ndpi_match_string(void *_automa, char *string_to_match)",
          "2246: {",
          "2247:     AC_REP_t match = {NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED, NDPI_PROTOCOL_UNRATED};",
          "2248:     AC_TEXT_t ac_input_text;",
          "2249:     AC_AUTOMATA_t *automa = (AC_AUTOMATA_t *) _automa;",
          "2250:     int rc;",
          "2252:     if ((automa == NULL) || (string_to_match == NULL) || (string_to_match[0] == '\\0'))",
          "2253:         return (-2);",
          "2255:     ac_input_text.astring = string_to_match, ac_input_text.length = strlen(string_to_match);",
          "2256:     rc = ac_automata_search(automa, &ac_input_text, &match);",
          "2263:     if ((rc == 0) && (match.number != 0))",
          "2264:         rc = 1;",
          "2266:     return (rc ? match.number : 0);",
          "2271: int ndpi_match_string_id(void *_automa, char *string_to_match, u_int match_len, unsigned long *id)",
          "2272: {",
          "2273:     AC_TEXT_t ac_input_text;",
          "2274:     AC_AUTOMATA_t *automa = (AC_AUTOMATA_t *) _automa;",
          "2275:     AC_REP_t match = {NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED, NDPI_PROTOCOL_UNRATED};",
          "2276:     int rc;",
          "2279:     if ((automa == NULL) || (string_to_match == NULL) || (string_to_match[0] == '\\0'))",
          "2280:         return (-2);",
          "2282:     ac_input_text.astring = string_to_match, ac_input_text.length = match_len;",
          "2283:     rc = ac_automata_search(automa, &ac_input_text, &match);",
          "2290:     if ((rc == 0) && (match.number != 0))",
          "2291:         rc = 1;",
          "2295:     return (*id != NDPI_PROTOCOL_UNKNOWN ? 0 : -1);",
          "",
          "[Added Lines]",
          "1934:        \"Unspecified\",",
          "1935:        \"Media\",",
          "1936:        \"VPN\",",
          "1937:        \"Email\",",
          "1938:        \"DataTransfer\",",
          "1939:        \"Web\",",
          "1940:        \"SocialNetwork\",",
          "1941:        \"Download-FileTransfer-FileSharing\",",
          "1942:        \"Game\",",
          "1943:        \"Chat\",",
          "1944:        \"VoIP\",",
          "1945:        \"Database\",",
          "1946:        \"RemoteAccess\",",
          "1947:        \"Cloud\",",
          "1948:        \"Network\",",
          "1949:        \"Collaborative\",",
          "1950:        \"RPC\",",
          "1951:        \"Streaming\",",
          "1952:        \"System\",",
          "1953:        \"SoftwareUpdate\",",
          "1954:        \"\",",
          "1955:        \"\",",
          "1956:        \"\",",
          "1957:        \"\",",
          "1958:        \"\",",
          "1959:        \"Music\",",
          "1960:        \"Video\",",
          "1961:        \"Shopping\",",
          "1962:        \"Productivity\",",
          "1963:        \"FileSharing\",",
          "1964:        \"\",",
          "1965:        \"\",",
          "1966:        \"\",",
          "1967:        \"\",",
          "1968:        \"\",",
          "1969:        \"\",",
          "1970:        \"\",",
          "1971:        \"\",",
          "1972:        \"\",",
          "1973:        \"\",",
          "1974:        \"\",",
          "1975:        \"\",",
          "1976:        \"\",",
          "1977:        \"\",",
          "1978:        \"\",",
          "1979:        \"\",",
          "1980:        \"\",",
          "1981:        \"\",",
          "1982:        \"\",",
          "1983:        \"\",",
          "1984:        \"\",",
          "1985:        \"\",",
          "1986:        \"\",",
          "1987:        \"\",",
          "1988:        \"\",",
          "1989:        \"\",",
          "1990:        \"\",",
          "1991:        \"\",",
          "1992:        \"\",",
          "1993:        \"\",",
          "1994:        \"\",",
          "1995:        \"\",",
          "1996:        \"\",",
          "1997:        \"\",",
          "1998:        \"\",",
          "1999:        \"\",",
          "2000:        \"\",",
          "2001:        \"\",",
          "2002:        \"\",",
          "2003:        \"\",",
          "2004:        \"\",",
          "2005:        \"\",",
          "2006:        \"\",",
          "2007:        \"\",",
          "2008:        \"\",",
          "2009:        \"\",",
          "2010:        \"\",",
          "2011:        \"\",",
          "2012:        \"\",",
          "2013:        \"\",",
          "2014:        \"\",",
          "2015:        \"\",",
          "2016:        \"\",",
          "2017:        \"\",",
          "2018:        \"\",",
          "2019:        \"\",",
          "2020:        \"\",",
          "2021:        \"\",",
          "2022:        \"\",",
          "2023:        \"\",",
          "2024:        \"\",",
          "2025:        \"\",",
          "2026:        \"\",",
          "2027:        \"\",",
          "2028:        \"\",",
          "2029:        \"\",",
          "2030:        \"\",",
          "2031:        \"\",",
          "2032:        \"\",",
          "2034:        \"Malware\",",
          "2035:        \"Advertisement\",",
          "2036:        \"Banned_Site\",",
          "2037:        \"Site_Unavailable\",",
          "2038:        \"Allowed_Site\",",
          "2039:        \"Antimalware\",",
          "2044: struct ndpi_detection_module_struct *ndpi_init_detection_module(ndpi_init_prefs prefs) {",
          "2045:   struct ndpi_detection_module_struct *ndpi_str = ndpi_malloc(sizeof(struct ndpi_detection_module_struct));",
          "2046:   int i;",
          "2048:   if(ndpi_str == NULL) {",
          "2050:     NDPI_LOG_ERR(ndpi_str, \"ndpi_init_detection_module initial malloc failed for ndpi_str\\n\");",
          "2052:     return(NULL);",
          "2053:   }",
          "2055:   memset(ndpi_str, 0, sizeof(struct ndpi_detection_module_struct));",
          "2058:   set_ndpi_debug_function(ndpi_str, (ndpi_debug_function_ptr) ndpi_debug_printf);",
          "2061:   if((ndpi_str->protocols_ptree = ndpi_New_Patricia(32 /* IPv4 */)) != NULL)",
          "2062:     ndpi_init_ptree_ipv4(ndpi_str, ndpi_str->protocols_ptree, host_protocol_list, prefs & ndpi_dont_load_tor_hosts);",
          "2064:   NDPI_BITMASK_RESET(ndpi_str->detection_bitmask);",
          "2066:   ndpi_str->user_data = NULL;",
          "2070:   ndpi_str->tcp_max_retransmission_window_size = NDPI_DEFAULT_MAX_TCP_RETRANSMISSION_WINDOW_SIZE;",
          "2071:   ndpi_str->directconnect_connection_ip_tick_timeout =",
          "2072:     NDPI_DIRECTCONNECT_CONNECTION_IP_TICK_TIMEOUT * ndpi_str->ticks_per_second;",
          "2074:   ndpi_str->rtsp_connection_timeout = NDPI_RTSP_CONNECTION_TIMEOUT * ndpi_str->ticks_per_second;",
          "2075:   ndpi_str->tvants_connection_timeout = NDPI_TVANTS_CONNECTION_TIMEOUT * ndpi_str->ticks_per_second;",
          "2076:   ndpi_str->irc_timeout = NDPI_IRC_CONNECTION_TIMEOUT * ndpi_str->ticks_per_second;",
          "2077:   ndpi_str->gnutella_timeout = NDPI_GNUTELLA_CONNECTION_TIMEOUT * ndpi_str->ticks_per_second;",
          "2079:   ndpi_str->battlefield_timeout = NDPI_BATTLEFIELD_CONNECTION_TIMEOUT * ndpi_str->ticks_per_second;",
          "2081:   ndpi_str->thunder_timeout = NDPI_THUNDER_CONNECTION_TIMEOUT * ndpi_str->ticks_per_second;",
          "2082:   ndpi_str->yahoo_detect_http_connections = NDPI_YAHOO_DETECT_HTTP_CONNECTIONS;",
          "2084:   ndpi_str->yahoo_lan_video_timeout = NDPI_YAHOO_LAN_VIDEO_TIMEOUT * ndpi_str->ticks_per_second;",
          "2085:   ndpi_str->zattoo_connection_timeout = NDPI_ZATTOO_CONNECTION_TIMEOUT * ndpi_str->ticks_per_second;",
          "2086:   ndpi_str->jabber_stun_timeout = NDPI_JABBER_STUN_TIMEOUT * ndpi_str->ticks_per_second;",
          "2087:   ndpi_str->jabber_file_transfer_timeout = NDPI_JABBER_FT_TIMEOUT * ndpi_str->ticks_per_second;",
          "2088:   ndpi_str->soulseek_connection_ip_tick_timeout =",
          "2089:     NDPI_SOULSEEK_CONNECTION_IP_TICK_TIMEOUT * ndpi_str->ticks_per_second;",
          "2091:   ndpi_str->ndpi_num_supported_protocols = NDPI_MAX_SUPPORTED_PROTOCOLS;",
          "2092:   ndpi_str->ndpi_num_custom_protocols = 0;",
          "2094:   ndpi_str->host_automa.ac_automa = ac_automata_init(ac_match_handler);",
          "2095:   ndpi_str->content_automa.ac_automa = ac_automata_init(ac_match_handler);",
          "2096:   ndpi_str->bigrams_automa.ac_automa = ac_automata_init(ac_match_handler);",
          "2097:   ndpi_str->impossible_bigrams_automa.ac_automa = ac_automata_init(ac_match_handler);",
          "2099:   if((sizeof(categories) / sizeof(char *)) != NDPI_PROTOCOL_NUM_CATEGORIES) {",
          "2100:     NDPI_LOG_ERR(ndpi_str, \"[NDPI] invalid categories length: expected %u, got %u\\n\", NDPI_PROTOCOL_NUM_CATEGORIES,",
          "2101:    (unsigned int) (sizeof(categories) / sizeof(char *)));",
          "2102:     return(NULL);",
          "2103:   }",
          "2106:   ndpi_str->custom_categories.num_to_load = 0, ndpi_str->custom_categories.to_load = NULL;",
          "2107:   ndpi_str->custom_categories.hostnames = NULL;",
          "2109:   ndpi_str->custom_categories.hostnames.ac_automa = ac_automata_init(ac_match_handler);",
          "2110:   ndpi_str->custom_categories.hostnames_shadow.ac_automa = ac_automata_init(ac_match_handler);",
          "2113:   ndpi_str->custom_categories.ipAddresses = ndpi_New_Patricia(32 /* IPv4 */);",
          "2114:   ndpi_str->custom_categories.ipAddresses_shadow = ndpi_New_Patricia(32 /* IPv4 */);",
          "2116:   if((ndpi_str->custom_categories.ipAddresses == NULL) || (ndpi_str->custom_categories.ipAddresses_shadow == NULL))",
          "2117:     return(NULL);",
          "2119:   ndpi_init_protocol_defaults(ndpi_str);",
          "2121:   for (i = 0; i < NUM_CUSTOM_CATEGORIES; i++)",
          "2122:     snprintf(ndpi_str->custom_category_labels[i], CUSTOM_CATEGORY_LABEL_LEN, \"User custom category %u\",",
          "2123:       (unsigned int) (i + 1));",
          "2125:   return(ndpi_str);",
          "2130: void ndpi_finalize_initalization(struct ndpi_detection_module_struct *ndpi_str) {",
          "2131:   u_int i;",
          "2133:   for (i = 0; i < 4; i++) {",
          "2134:     ndpi_automa *automa;",
          "2136:     switch (i) {",
          "2137:     case 0:",
          "2138:       automa = &ndpi_str->host_automa;",
          "2139:       break;",
          "2141:     case 1:",
          "2142:       automa = &ndpi_str->content_automa;",
          "2143:       break;",
          "2145:     case 2:",
          "2146:       automa = &ndpi_str->bigrams_automa;",
          "2147:       break;",
          "2149:     case 3:",
          "2150:       automa = &ndpi_str->impossible_bigrams_automa;",
          "2151:       break;",
          "2153:     default:",
          "2154:       automa = NULL;",
          "2155:       break;",
          "2156:     }",
          "2158:     if(automa) {",
          "2159:       ac_automata_finalize((AC_AUTOMATA_t *) automa->ac_automa);",
          "2160:       automa->ac_automa_finalized = 1;",
          "2162:   }",
          "2168: void *ndpi_init_automa(void) {",
          "2169:   return(ac_automata_init(ac_match_handler));",
          "2172: int ndpi_add_string_value_to_automa(void *_automa, char *str, unsigned long num) {",
          "2173:   AC_PATTERN_t ac_pattern;",
          "2174:   AC_AUTOMATA_t *automa = (AC_AUTOMATA_t *) _automa;",
          "2175:   AC_ERROR_t rc;",
          "2177:   if(automa == NULL)",
          "2178:     return(-1);",
          "2180:   memset(&ac_pattern, 0, sizeof(ac_pattern));",
          "2181:   ac_pattern.astring = str;",
          "2182:   ac_pattern.rep.number = num;",
          "2183:   ac_pattern.length = strlen(ac_pattern.astring);",
          "2185:   rc = ac_automata_add(automa, &ac_pattern);",
          "2186:   return(rc == ACERR_SUCCESS || rc == ACERR_DUPLICATE_PATTERN ? 0 : -1);",
          "2189: int ndpi_add_string_to_automa(void *_automa, char *str) {",
          "2190:   return(ndpi_add_string_value_to_automa(_automa, str, 1));",
          "2193: void ndpi_free_automa(void *_automa) {",
          "2194:   ac_automata_release((AC_AUTOMATA_t *) _automa, 0);",
          "2196: void ndpi_finalize_automa(void *_automa) {",
          "2197:   ac_automata_finalize((AC_AUTOMATA_t *) _automa);",
          "2202: int ndpi_match_string(void *_automa, char *string_to_match) {",
          "2203:   AC_REP_t match = {NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED, NDPI_PROTOCOL_UNRATED};",
          "2204:   AC_TEXT_t ac_input_text;",
          "2205:   AC_AUTOMATA_t *automa = (AC_AUTOMATA_t *) _automa;",
          "2206:   int rc;",
          "2208:   if((automa == NULL) || (string_to_match == NULL) || (string_to_match[0] == '\\0'))",
          "2209:     return(-2);",
          "2211:   ac_input_text.astring = string_to_match, ac_input_text.length = strlen(string_to_match);",
          "2212:   rc = ac_automata_search(automa, &ac_input_text, &match);",
          "2219:   if((rc == 0) && (match.number != 0))",
          "2220:     rc = 1;",
          "2222:   return(rc ? match.number : 0);",
          "2227: int ndpi_match_string_id(void *_automa, char *string_to_match, u_int match_len, u_int16_t *id) {",
          "2228:   AC_TEXT_t ac_input_text;",
          "2229:   AC_AUTOMATA_t *automa = (AC_AUTOMATA_t *) _automa;",
          "2230:   AC_REP_t match = {NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED, NDPI_PROTOCOL_UNRATED};",
          "2231:   int rc;",
          "2234:   if((automa == NULL) || (string_to_match == NULL) || (string_to_match[0] == '\\0'))",
          "2235:     return(-2);",
          "2237:   ac_input_text.astring = string_to_match, ac_input_text.length = match_len;",
          "2238:   rc = ac_automata_search(automa, &ac_input_text, &match);",
          "2245:   if((rc == 0) && (match.number != 0))",
          "2246:     rc = 1;",
          "2250:   return(*id != NDPI_PROTOCOL_UNKNOWN ? 0 : -1);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "2300: #ifdef HAVE_HYPERSCAN",
          "2302: static int hyperscanCustomEventHandler(unsigned int id, unsigned long long from, unsigned long long to,",
          "2307: #ifdef DEBUG",
          "2309: #endif",
          "2312: }",
          "2313: #endif",
          "2320: #ifdef HAVE_HYPERSCAN",
          "2332: #ifdef DEBUG",
          "2334: #endif",
          "2339: #else",
          "2341: #endif",
          "2342: }",
          "2385: }",
          "2392: }",
          "2437: #ifdef HAVE_HYPERSCAN",
          "2449: #else",
          "2457: #endif",
          "2467: }",
          "2471: int ndpi_get_protocol_id_master_proto(struct ndpi_detection_module_struct *ndpi_str, u_int16_t protocol_id,",
          "2484: }",
          "2488: static ndpi_default_ports_tree_node_t *ndpi_get_guessed_protocol_id(struct ndpi_detection_module_struct *ndpi_str,",
          "2510:     }",
          "2513: }",
          "",
          "[Removed Lines]",
          "2303:                                        unsigned int flags, void *ctx)",
          "2304: {",
          "2308:     printf(\"[HS] Found category %u\\n\", id);",
          "2311:     return (HS_SCAN_TERMINATED);",
          "2317: int ndpi_match_custom_category(struct ndpi_detection_module_struct *ndpi_str, char *name, u_int name_len,",
          "2318:                                unsigned long *id)",
          "2319: {",
          "2321:     if (ndpi_str->custom_categories.hostnames == NULL)",
          "2322:         return (-1);",
          "2323:     else {",
          "2324:         hs_error_t rc;",
          "2328:         rc = hs_scan(ndpi_str->custom_categories.hostnames->database, name, name_len, 0,",
          "2329:                      ndpi_str->custom_categories.hostnames->scratch, hyperscanCustomEventHandler, id);",
          "2331:         if (rc == HS_SCAN_TERMINATED) {",
          "2333:             printf(\"[HS] Found category %lu for %s\\n\", *id, name);",
          "2335:             return (0);",
          "2336:         } else",
          "2337:             return (-1);",
          "2338:     }",
          "2340:     return (ndpi_match_string_id(ndpi_str->custom_categories.hostnames.ac_automa, name, name_len, id));",
          "2346: int ndpi_get_custom_category_match(struct ndpi_detection_module_struct *ndpi_str, char *name_or_ip, u_int name_len,",
          "2347:                                    unsigned long *id)",
          "2348: {",
          "2349:     char ipbuf[64], *ptr;",
          "2350:     struct in_addr pin;",
          "2351:     u_int cp_len = ndpi_min(sizeof(ipbuf) - 1, name_len);",
          "2353:     if (!ndpi_str->custom_categories.categories_loaded)",
          "2354:         return (-1);",
          "2356:     if (cp_len > 0) {",
          "2357:         memcpy(ipbuf, name_or_ip, cp_len);",
          "2358:         ipbuf[cp_len] = '\\0';",
          "2359:     } else",
          "2360:         ipbuf[0] = '\\0';",
          "2362:     ptr = strrchr(ipbuf, '/');",
          "2364:     if (ptr)",
          "2365:         ptr[0] = '\\0';",
          "2367:     if (inet_pton(AF_INET, ipbuf, &pin) == 1) {",
          "2369:         prefix_t prefix;",
          "2370:         patricia_node_t *node;",
          "2373:         fill_prefix_v4(&prefix, &pin, 32, ((patricia_tree_t *) ndpi_str->protocols_ptree)->maxbits);",
          "2374:         node = ndpi_patricia_search_best(ndpi_str->custom_categories.ipAddresses, &prefix);",
          "2376:         if (node) {",
          "2378:             return (0);",
          "2379:         }",
          "2381:         return (-1);",
          "2382:     } else",
          "2384:         return (ndpi_match_custom_category(ndpi_str, name_or_ip, name_len, id));",
          "2389: static void free_ptree_data(void *data)",
          "2390: {",
          "2391:     ;",
          "2396: void ndpi_exit_detection_module(struct ndpi_detection_module_struct *ndpi_str)",
          "2397: {",
          "2398:     if (ndpi_str != NULL) {",
          "2399:         int i;",
          "2401:         for (i = 0; i < (NDPI_MAX_SUPPORTED_PROTOCOLS + NDPI_MAX_NUM_CUSTOM_PROTOCOLS); i++) {",
          "2402:             if (ndpi_str->proto_defaults[i].protoName)",
          "2403:                 ndpi_free(ndpi_str->proto_defaults[i].protoName);",
          "2404:         }",
          "2407:         if (ndpi_str->tinc_cache)",
          "2408:             cache_free((cache_t)(ndpi_str->tinc_cache));",
          "2410:         if (ndpi_str->ookla_cache)",
          "2411:             ndpi_lru_free_cache(ndpi_str->ookla_cache);",
          "2413:         if (ndpi_str->stun_cache)",
          "2414:             ndpi_lru_free_cache(ndpi_str->stun_cache);",
          "2416:         if (ndpi_str->protocols_ptree)",
          "2417:             ndpi_Destroy_Patricia((patricia_tree_t *) ndpi_str->protocols_ptree, free_ptree_data);",
          "2419:         if (ndpi_str->udpRoot != NULL)",
          "2420:             ndpi_tdestroy(ndpi_str->udpRoot, ndpi_free);",
          "2421:         if (ndpi_str->tcpRoot != NULL)",
          "2422:             ndpi_tdestroy(ndpi_str->tcpRoot, ndpi_free);",
          "2424:         if (ndpi_str->host_automa.ac_automa != NULL)",
          "2425:             ac_automata_release((AC_AUTOMATA_t *) ndpi_str->host_automa.ac_automa,",
          "2426:                                 1 /* free patterns strings memory */);",
          "2428:         if (ndpi_str->content_automa.ac_automa != NULL)",
          "2429:             ac_automata_release((AC_AUTOMATA_t *) ndpi_str->content_automa.ac_automa, 0);",
          "2431:         if (ndpi_str->bigrams_automa.ac_automa != NULL)",
          "2432:             ac_automata_release((AC_AUTOMATA_t *) ndpi_str->bigrams_automa.ac_automa, 0);",
          "2434:         if (ndpi_str->impossible_bigrams_automa.ac_automa != NULL)",
          "2435:             ac_automata_release((AC_AUTOMATA_t *) ndpi_str->impossible_bigrams_automa.ac_automa, 0);",
          "2438:         destroy_hyperscan(ndpi_str);",
          "2440:         while (ndpi_str->custom_categories.to_load != NULL) {",
          "2441:             struct hs_list *next = ndpi_str->custom_categories.to_load->next;",
          "2443:             ndpi_free(ndpi_str->custom_categories.to_load->expression);",
          "2444:             ndpi_free(ndpi_str->custom_categories.to_load);",
          "2445:             ndpi_str->custom_categories.to_load = next;",
          "2446:         }",
          "2448:         free_hyperscan_memory(ndpi_str->custom_categories.hostnames);",
          "2450:         if (ndpi_str->custom_categories.hostnames.ac_automa != NULL)",
          "2451:             ac_automata_release((AC_AUTOMATA_t *) ndpi_str->custom_categories.hostnames.ac_automa,",
          "2452:                                 1 /* free patterns strings memory */);",
          "2454:         if (ndpi_str->custom_categories.hostnames_shadow.ac_automa != NULL)",
          "2455:             ac_automata_release((AC_AUTOMATA_t *) ndpi_str->custom_categories.hostnames_shadow.ac_automa,",
          "2456:                                 1 /* free patterns strings memory */);",
          "2459:         if (ndpi_str->custom_categories.ipAddresses != NULL)",
          "2460:             ndpi_Destroy_Patricia((patricia_tree_t *) ndpi_str->custom_categories.ipAddresses, free_ptree_data);",
          "2462:         if (ndpi_str->custom_categories.ipAddresses_shadow != NULL)",
          "2463:             ndpi_Destroy_Patricia((patricia_tree_t *) ndpi_str->custom_categories.ipAddresses_shadow, free_ptree_data);",
          "2465:         ndpi_free(ndpi_str);",
          "2466:     }",
          "2472:                                       u_int16_t **tcp_master_proto, u_int16_t **udp_master_proto)",
          "2473: {",
          "2474:     if (protocol_id >= (NDPI_MAX_SUPPORTED_PROTOCOLS + NDPI_MAX_NUM_CUSTOM_PROTOCOLS)) {",
          "2477:         return (-1);",
          "2478:     }",
          "2483:     return (0);",
          "2489:                                                                     u_int8_t proto, u_int16_t sport, u_int16_t dport)",
          "2490: {",
          "2491:     ndpi_default_ports_tree_node_t node;",
          "2493:     if (sport && dport) {",
          "2494:         int low = ndpi_min(sport, dport);",
          "2495:         int high = ndpi_max(sport, dport);",
          "2496:         const void *ret;",
          "2499:         ret = ndpi_tfind(&node, (proto == IPPROTO_TCP) ? (void *) &ndpi_str->tcpRoot : (void *) &ndpi_str->udpRoot,",
          "2500:                          ndpi_default_ports_tree_node_t_cmp);",
          "2502:         if (ret == NULL) {",
          "2503:             node.default_port = high;",
          "2504:             ret = ndpi_tfind(&node, (proto == IPPROTO_TCP) ? (void *) &ndpi_str->tcpRoot : (void *) &ndpi_str->udpRoot,",
          "2505:                              ndpi_default_ports_tree_node_t_cmp);",
          "2506:         }",
          "2508:         if (ret)",
          "2509:             return (*(ndpi_default_ports_tree_node_t **) ret);",
          "2512:     return (NULL);",
          "",
          "[Added Lines]",
          "2258:                                        unsigned int flags, void *ctx) {",
          "2262:   printf(\"[HS] Found category %u\\n\", id);",
          "2265:   return(HS_SCAN_TERMINATED);",
          "2271: int ndpi_match_custom_category(struct ndpi_detection_module_struct *ndpi_str,",
          "2272:           char *name, u_int name_len,",
          "2273:                                u_int16_t *id) {",
          "2275:   if(ndpi_str->custom_categories.hostnames == NULL)",
          "2276:     return(-1);",
          "2277:   else {",
          "2278:     hs_error_t rc;",
          "2282:     rc = hs_scan(ndpi_str->custom_categories.hostnames->database, name, name_len, 0,",
          "2283:    ndpi_str->custom_categories.hostnames->scratch, hyperscanCustomEventHandler, id);",
          "2285:     if(rc == HS_SCAN_TERMINATED) {",
          "2287:       printf(\"[HS] Found category %lu for %s\\n\", *id, name);",
          "2289:       return(0);",
          "2290:     } else",
          "2291:       return(-1);",
          "2292:   }",
          "2294:   return(ndpi_match_string_id(ndpi_str->custom_categories.hostnames.ac_automa,",
          "2295:           name, name_len, id));",
          "2301: int ndpi_get_custom_category_match(struct ndpi_detection_module_struct *ndpi_str,",
          "2302:        char *name_or_ip, u_int name_len, u_int16_t *id) {",
          "2303:   char ipbuf[64], *ptr;",
          "2304:   struct in_addr pin;",
          "2305:   u_int cp_len = ndpi_min(sizeof(ipbuf) - 1, name_len);",
          "2307:   if(!ndpi_str->custom_categories.categories_loaded)",
          "2308:     return(-1);",
          "2310:   if(cp_len > 0) {",
          "2311:     memcpy(ipbuf, name_or_ip, cp_len);",
          "2312:     ipbuf[cp_len] = '\\0';",
          "2313:   } else",
          "2314:     ipbuf[0] = '\\0';",
          "2316:   ptr = strrchr(ipbuf, '/');",
          "2318:   if(ptr)",
          "2319:     ptr[0] = '\\0';",
          "2321:   if(inet_pton(AF_INET, ipbuf, &pin) == 1) {",
          "2323:     prefix_t prefix;",
          "2324:     patricia_node_t *node;",
          "2327:     fill_prefix_v4(&prefix, &pin, 32, ((patricia_tree_t *) ndpi_str->protocols_ptree)->maxbits);",
          "2328:     node = ndpi_patricia_search_best(ndpi_str->custom_categories.ipAddresses, &prefix);",
          "2330:     if(node) {",
          "2333:       return(0);",
          "2334:     }",
          "2336:     return(-1);",
          "2337:   } else",
          "2339:     return(ndpi_match_custom_category(ndpi_str, name_or_ip, name_len, id));",
          "2344: static void free_ptree_data(void *data) {",
          "2345:   ;",
          "2350: void ndpi_exit_detection_module(struct ndpi_detection_module_struct *ndpi_str) {",
          "2351:   if(ndpi_str != NULL) {",
          "2352:     int i;",
          "2354:     for (i = 0; i < (NDPI_MAX_SUPPORTED_PROTOCOLS + NDPI_MAX_NUM_CUSTOM_PROTOCOLS); i++) {",
          "2355:       if(ndpi_str->proto_defaults[i].protoName)",
          "2356:  ndpi_free(ndpi_str->proto_defaults[i].protoName);",
          "2357:     }",
          "2360:     if(ndpi_str->tinc_cache)",
          "2361:       cache_free((cache_t)(ndpi_str->tinc_cache));",
          "2363:     if(ndpi_str->ookla_cache)",
          "2364:       ndpi_lru_free_cache(ndpi_str->ookla_cache);",
          "2366:     if(ndpi_str->stun_cache)",
          "2367:       ndpi_lru_free_cache(ndpi_str->stun_cache);",
          "2369:     if(ndpi_str->protocols_ptree)",
          "2370:       ndpi_Destroy_Patricia((patricia_tree_t *) ndpi_str->protocols_ptree, free_ptree_data);",
          "2372:     if(ndpi_str->udpRoot != NULL)",
          "2373:       ndpi_tdestroy(ndpi_str->udpRoot, ndpi_free);",
          "2374:     if(ndpi_str->tcpRoot != NULL)",
          "2375:       ndpi_tdestroy(ndpi_str->tcpRoot, ndpi_free);",
          "2377:     if(ndpi_str->host_automa.ac_automa != NULL)",
          "2378:       ac_automata_release((AC_AUTOMATA_t *) ndpi_str->host_automa.ac_automa,",
          "2379:      1 /* free patterns strings memory */);",
          "2381:     if(ndpi_str->content_automa.ac_automa != NULL)",
          "2382:       ac_automata_release((AC_AUTOMATA_t *) ndpi_str->content_automa.ac_automa, 0);",
          "2384:     if(ndpi_str->bigrams_automa.ac_automa != NULL)",
          "2385:       ac_automata_release((AC_AUTOMATA_t *) ndpi_str->bigrams_automa.ac_automa, 0);",
          "2387:     if(ndpi_str->impossible_bigrams_automa.ac_automa != NULL)",
          "2388:       ac_automata_release((AC_AUTOMATA_t *) ndpi_str->impossible_bigrams_automa.ac_automa, 0);",
          "2391:     destroy_hyperscan(ndpi_str);",
          "2393:     while (ndpi_str->custom_categories.to_load != NULL) {",
          "2394:       struct hs_list *next = ndpi_str->custom_categories.to_load->next;",
          "2396:       ndpi_free(ndpi_str->custom_categories.to_load->expression);",
          "2397:       ndpi_free(ndpi_str->custom_categories.to_load);",
          "2398:       ndpi_str->custom_categories.to_load = next;",
          "2399:     }",
          "2401:     free_hyperscan_memory(ndpi_str->custom_categories.hostnames);",
          "2403:     if(ndpi_str->custom_categories.hostnames.ac_automa != NULL)",
          "2404:       ac_automata_release((AC_AUTOMATA_t *) ndpi_str->custom_categories.hostnames.ac_automa,",
          "2405:      1 /* free patterns strings memory */);",
          "2407:     if(ndpi_str->custom_categories.hostnames_shadow.ac_automa != NULL)",
          "2408:       ac_automata_release((AC_AUTOMATA_t *) ndpi_str->custom_categories.hostnames_shadow.ac_automa,",
          "2409:      1 /* free patterns strings memory */);",
          "2412:     if(ndpi_str->custom_categories.ipAddresses != NULL)",
          "2413:       ndpi_Destroy_Patricia((patricia_tree_t *) ndpi_str->custom_categories.ipAddresses, free_ptree_data);",
          "2415:     if(ndpi_str->custom_categories.ipAddresses_shadow != NULL)",
          "2416:       ndpi_Destroy_Patricia((patricia_tree_t *) ndpi_str->custom_categories.ipAddresses_shadow, free_ptree_data);",
          "2418:     ndpi_free(ndpi_str);",
          "2419:   }",
          "2425:                                       u_int16_t **tcp_master_proto, u_int16_t **udp_master_proto) {",
          "2426:   if(protocol_id >= (NDPI_MAX_SUPPORTED_PROTOCOLS + NDPI_MAX_NUM_CUSTOM_PROTOCOLS)) {",
          "2429:     return(-1);",
          "2430:   }",
          "2435:   return(0);",
          "2441:                                                                     u_int8_t proto, u_int16_t sport, u_int16_t dport) {",
          "2442:   ndpi_default_ports_tree_node_t node;",
          "2444:   if(sport && dport) {",
          "2445:     int low = ndpi_min(sport, dport);",
          "2446:     int high = ndpi_max(sport, dport);",
          "2447:     const void *ret;",
          "2450:     ret = ndpi_tfind(&node, (proto == IPPROTO_TCP) ? (void *) &ndpi_str->tcpRoot : (void *) &ndpi_str->udpRoot,",
          "2451:        ndpi_default_ports_tree_node_t_cmp);",
          "2453:     if(ret == NULL) {",
          "2454:       node.default_port = high;",
          "2455:       ret = ndpi_tfind(&node, (proto == IPPROTO_TCP) ? (void *) &ndpi_str->tcpRoot : (void *) &ndpi_str->udpRoot,",
          "2456:          ndpi_default_ports_tree_node_t_cmp);",
          "2459:     if(ret)",
          "2460:       return(*(ndpi_default_ports_tree_node_t **) ret);",
          "2461:   }",
          "2463:   return(NULL);",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "2519:   and thus that if have NOT been detected they cannot be guessed",
          "2520:   as they have been excluded",
          "2533: }",
          "2537: u_int16_t ndpi_guess_protocol_id(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,",
          "2594:     }",
          "2597: }",
          "2604: }",
          "2608: #ifdef WIN32",
          "2620: }",
          "2621: #endif",
          "2731:     }",
          "2734: }",
          "",
          "[Removed Lines]",
          "2522: u_int8_t is_udp_guessable_protocol(u_int16_t l7_guessed_proto)",
          "2523: {",
          "2524:     switch (l7_guessed_proto) {",
          "2525:         case NDPI_PROTOCOL_QUIC:",
          "2526:         case NDPI_PROTOCOL_SNMP:",
          "2527:         case NDPI_PROTOCOL_NETFLOW:",
          "2529:             return (1);",
          "2530:     }",
          "2532:     return (0);",
          "2538:                                  u_int8_t proto, u_int16_t sport, u_int16_t dport, u_int8_t *user_defined_proto)",
          "2539: {",
          "2542:     if (sport && dport) {",
          "2543:         ndpi_default_ports_tree_node_t *found = ndpi_get_guessed_protocol_id(ndpi_str, proto, sport, dport);",
          "2545:         if (found != NULL) {",
          "2546:             u_int16_t guessed_proto = found->proto->protoId;",
          "2549:             if (flow && (proto == IPPROTO_UDP) &&",
          "2550:                 NDPI_COMPARE_PROTOCOL_TO_BITMASK(flow->excluded_protocol_bitmask, guessed_proto) &&",
          "2551:                 is_udp_guessable_protocol(guessed_proto))",
          "2552:                 return (NDPI_PROTOCOL_UNKNOWN);",
          "2553:             else {",
          "2555:                 return (guessed_proto);",
          "2556:             }",
          "2557:         }",
          "2558:     } else {",
          "2561:         switch (proto) {",
          "2562:             case NDPI_IPSEC_PROTOCOL_ESP:",
          "2563:             case NDPI_IPSEC_PROTOCOL_AH:",
          "2564:                 return (NDPI_PROTOCOL_IP_IPSEC);",
          "2565:                 break;",
          "2566:             case NDPI_GRE_PROTOCOL_TYPE:",
          "2567:                 return (NDPI_PROTOCOL_IP_GRE);",
          "2568:                 break;",
          "2569:             case NDPI_ICMP_PROTOCOL_TYPE:",
          "2570:                 return (NDPI_PROTOCOL_IP_ICMP);",
          "2571:                 break;",
          "2572:             case NDPI_IGMP_PROTOCOL_TYPE:",
          "2573:                 return (NDPI_PROTOCOL_IP_IGMP);",
          "2574:                 break;",
          "2575:             case NDPI_EGP_PROTOCOL_TYPE:",
          "2576:                 return (NDPI_PROTOCOL_IP_EGP);",
          "2577:                 break;",
          "2578:             case NDPI_SCTP_PROTOCOL_TYPE:",
          "2579:                 return (NDPI_PROTOCOL_IP_SCTP);",
          "2580:                 break;",
          "2581:             case NDPI_OSPF_PROTOCOL_TYPE:",
          "2582:                 return (NDPI_PROTOCOL_IP_OSPF);",
          "2583:                 break;",
          "2584:             case NDPI_IPIP_PROTOCOL_TYPE:",
          "2585:                 return (NDPI_PROTOCOL_IP_IP_IN_IP);",
          "2586:                 break;",
          "2587:             case NDPI_ICMPV6_PROTOCOL_TYPE:",
          "2588:                 return (NDPI_PROTOCOL_IP_ICMPV6);",
          "2589:                 break;",
          "2590:             case 112:",
          "2591:                 return (NDPI_PROTOCOL_IP_VRRP);",
          "2592:                 break;",
          "2593:         }",
          "2596:     return (NDPI_PROTOCOL_UNKNOWN);",
          "2601: u_int ndpi_get_num_supported_protocols(struct ndpi_detection_module_struct *ndpi_str)",
          "2602: {",
          "2603:     return (ndpi_str->ndpi_num_supported_protocols);",
          "2609: char *strsep(char **sp, char *sep)",
          "2610: {",
          "2611:     char *p, *s;",
          "2612:     if (sp == NULL || *sp == NULL || **sp == '\\0')",
          "2613:         return (NULL);",
          "2614:     s = *sp;",
          "2615:     p = s + strcspn(s, sep);",
          "2616:     if (*p != '\\0')",
          "2619:     return (s);",
          "2625: int ndpi_handle_rule(struct ndpi_detection_module_struct *ndpi_str, char *rule, u_int8_t do_add)",
          "2626: {",
          "2627:     char *at, *proto, *elem;",
          "2628:     ndpi_proto_defaults_t *def;",
          "2629:     int subprotocol_id, i;",
          "2631:     at = strrchr(rule, '@');",
          "2632:     if (at == NULL) {",
          "2633:         NDPI_LOG_ERR(ndpi_str, \"Invalid rule '%s'\\n\", rule);",
          "2634:         return (-1);",
          "2635:     } else",
          "2636:         at[0] = 0, proto = &at[1];",
          "2638:     for (i = 0; proto[i] != '\\0'; i++) {",
          "2639:         switch (proto[i]) {",
          "2640:             case '/':",
          "2641:             case '&':",
          "2642:             case '^':",
          "2643:             case ':':",
          "2644:             case ';':",
          "2645:             case '\\'':",
          "2646:             case '\"':",
          "2647:             case ' ':",
          "2648:                 proto[i] = '_';",
          "2649:                 break;",
          "2650:         }",
          "2651:     }",
          "2653:     for (i = 0, def = NULL; i < (int) ndpi_str->ndpi_num_supported_protocols; i++) {",
          "2654:         if (ndpi_str->proto_defaults[i].protoName && strcasecmp(ndpi_str->proto_defaults[i].protoName, proto) == 0) {",
          "2655:             def = &ndpi_str->proto_defaults[i];",
          "2656:             subprotocol_id = i;",
          "2657:             break;",
          "2658:         }",
          "2659:     }",
          "2661:     if (def == NULL) {",
          "2662:         if (!do_add) {",
          "2664:             NDPI_LOG_ERR(ndpi_str, \"Unable to find protocol '%s': skipping rule '%s'\\n\", proto, rule);",
          "2665:             return (-3);",
          "2666:         } else {",
          "2667:             ndpi_port_range ports_a[MAX_DEFAULT_PORTS], ports_b[MAX_DEFAULT_PORTS];",
          "2668:             u_int16_t no_master[2] = {NDPI_PROTOCOL_NO_MASTER_PROTO, NDPI_PROTOCOL_NO_MASTER_PROTO};",
          "2670:             if (ndpi_str->ndpi_num_custom_protocols >= (NDPI_MAX_NUM_CUSTOM_PROTOCOLS - 1)) {",
          "2671:                 NDPI_LOG_ERR(ndpi_str, \"Too many protocols defined (%u): skipping protocol %s\\n\",",
          "2672:                              ndpi_str->ndpi_num_custom_protocols, proto);",
          "2673:                 return (-2);",
          "2674:             }",
          "2676:             ndpi_set_proto_defaults(",
          "2677:                 ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, ndpi_str->ndpi_num_supported_protocols,",
          "2678:                 0 /* can_have_a_subprotocol */, no_master, no_master, proto,",
          "2680:                 ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "2681:                 ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "2682:             def = &ndpi_str->proto_defaults[ndpi_str->ndpi_num_supported_protocols];",
          "2683:             subprotocol_id = ndpi_str->ndpi_num_supported_protocols;",
          "2684:             ndpi_str->ndpi_num_supported_protocols++, ndpi_str->ndpi_num_custom_protocols++;",
          "2685:         }",
          "2686:     }",
          "2688:     while ((elem = strsep(&rule, \",\")) != NULL) {",
          "2689:         char *attr = elem, *value = NULL;",
          "2690:         ndpi_port_range range;",
          "2691:         int is_tcp = 0, is_udp = 0, is_ip = 0;",
          "2693:         if (strncmp(attr, \"tcp:\", 4) == 0)",
          "2694:             is_tcp = 1, value = &attr[4];",
          "2695:         else if (strncmp(attr, \"udp:\", 4) == 0)",
          "2696:             is_udp = 1, value = &attr[4];",
          "2697:         else if (strncmp(attr, \"ip:\", 3) == 0)",
          "2698:             is_ip = 1, value = &attr[3];",
          "2699:         else if (strncmp(attr, \"host:\", 5) == 0) {",
          "2701:             value = &attr[5];",
          "2702:             if (value[0] == '\"')",
          "2704:             if (value[strlen(value) - 1] == '\"')",
          "2706:         }",
          "2708:         if (is_tcp || is_udp) {",
          "2709:             u_int p_low, p_high;",
          "2711:             if (sscanf(value, \"%u-%u\", &p_low, &p_high) == 2)",
          "2712:                 range.port_low = p_low, range.port_high = p_high;",
          "2713:             else",
          "2714:                 range.port_low = range.port_high = atoi(&elem[4]);",
          "2716:             if (do_add)",
          "2717:                 addDefaultPort(ndpi_str, &range, def, 1 /* Custom user proto */,",
          "2718:                                is_tcp ? &ndpi_str->tcpRoot : &ndpi_str->udpRoot, __FUNCTION__, __LINE__);",
          "2719:             else",
          "2720:                 removeDefaultPort(&range, def, is_tcp ? &ndpi_str->tcpRoot : &ndpi_str->udpRoot);",
          "2721:         } else if (is_ip) {",
          "2723:             ndpi_add_host_ip_subprotocol(ndpi_str, value, subprotocol_id);",
          "2724:         } else {",
          "2725:             if (do_add)",
          "2726:                 ndpi_add_host_url_subprotocol(ndpi_str, value, subprotocol_id, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED,",
          "2727:                                               NDPI_PROTOCOL_ACCEPTABLE);",
          "2728:             else",
          "2729:                 ndpi_remove_host_url_subprotocol(ndpi_str, value, subprotocol_id);",
          "2730:         }",
          "2733:     return (0);",
          "",
          "[Added Lines]",
          "2473: u_int8_t is_udp_guessable_protocol(u_int16_t l7_guessed_proto) {",
          "2474:   switch (l7_guessed_proto) {",
          "2475:   case NDPI_PROTOCOL_QUIC:",
          "2476:   case NDPI_PROTOCOL_SNMP:",
          "2477:   case NDPI_PROTOCOL_NETFLOW:",
          "2479:     return(1);",
          "2480:   }",
          "2482:   return(0);",
          "2488:                                  u_int8_t proto, u_int16_t sport, u_int16_t dport, u_int8_t *user_defined_proto) {",
          "2491:   if(sport && dport) {",
          "2492:     ndpi_default_ports_tree_node_t *found = ndpi_get_guessed_protocol_id(ndpi_str, proto, sport, dport);",
          "2494:     if(found != NULL) {",
          "2495:       u_int16_t guessed_proto = found->proto->protoId;",
          "2498:       if(flow && (proto == IPPROTO_UDP) &&",
          "2499:   NDPI_COMPARE_PROTOCOL_TO_BITMASK(flow->excluded_protocol_bitmask, guessed_proto) &&",
          "2500:   is_udp_guessable_protocol(guessed_proto))",
          "2501:  return(NDPI_PROTOCOL_UNKNOWN);",
          "2502:       else {",
          "2504:  return(guessed_proto);",
          "2505:       }",
          "2507:   } else {",
          "2510:     switch (proto) {",
          "2511:     case NDPI_IPSEC_PROTOCOL_ESP:",
          "2512:     case NDPI_IPSEC_PROTOCOL_AH:",
          "2513:       return(NDPI_PROTOCOL_IP_IPSEC);",
          "2514:       break;",
          "2515:     case NDPI_GRE_PROTOCOL_TYPE:",
          "2516:       return(NDPI_PROTOCOL_IP_GRE);",
          "2517:       break;",
          "2518:     case NDPI_ICMP_PROTOCOL_TYPE:",
          "2519:       return(NDPI_PROTOCOL_IP_ICMP);",
          "2520:       break;",
          "2521:     case NDPI_IGMP_PROTOCOL_TYPE:",
          "2522:       return(NDPI_PROTOCOL_IP_IGMP);",
          "2523:       break;",
          "2524:     case NDPI_EGP_PROTOCOL_TYPE:",
          "2525:       return(NDPI_PROTOCOL_IP_EGP);",
          "2526:       break;",
          "2527:     case NDPI_SCTP_PROTOCOL_TYPE:",
          "2528:       return(NDPI_PROTOCOL_IP_SCTP);",
          "2529:       break;",
          "2530:     case NDPI_OSPF_PROTOCOL_TYPE:",
          "2531:       return(NDPI_PROTOCOL_IP_OSPF);",
          "2532:       break;",
          "2533:     case NDPI_IPIP_PROTOCOL_TYPE:",
          "2534:       return(NDPI_PROTOCOL_IP_IP_IN_IP);",
          "2535:       break;",
          "2536:     case NDPI_ICMPV6_PROTOCOL_TYPE:",
          "2537:       return(NDPI_PROTOCOL_IP_ICMPV6);",
          "2538:       break;",
          "2539:     case 112:",
          "2540:       return(NDPI_PROTOCOL_IP_VRRP);",
          "2541:       break;",
          "2542:     }",
          "2543:   }",
          "2545:   return(NDPI_PROTOCOL_UNKNOWN);",
          "2550: u_int ndpi_get_num_supported_protocols(struct ndpi_detection_module_struct *ndpi_str) {",
          "2551:   return(ndpi_str->ndpi_num_supported_protocols);",
          "2557: char *strsep(char **sp, char *sep) {",
          "2558:   char *p, *s;",
          "2559:   if(sp == NULL || *sp == NULL || **sp == '\\0')",
          "2560:     return(NULL);",
          "2561:   s = *sp;",
          "2562:   p = s + strcspn(s, sep);",
          "2563:   if(*p != '\\0')",
          "2566:   return(s);",
          "2572: int ndpi_handle_rule(struct ndpi_detection_module_struct *ndpi_str, char *rule, u_int8_t do_add) {",
          "2573:   char *at, *proto, *elem;",
          "2574:   ndpi_proto_defaults_t *def;",
          "2575:   u_int16_t subprotocol_id, i;",
          "2577:   at = strrchr(rule, '@');",
          "2578:   if(at == NULL) {",
          "2579:     NDPI_LOG_ERR(ndpi_str, \"Invalid rule '%s'\\n\", rule);",
          "2580:     return(-1);",
          "2581:   } else",
          "2582:     at[0] = 0, proto = &at[1];",
          "2584:   for (i = 0; proto[i] != '\\0'; i++) {",
          "2585:     switch (proto[i]) {",
          "2586:     case '/':",
          "2587:     case '&':",
          "2588:     case '^':",
          "2589:     case ':':",
          "2590:     case ';':",
          "2591:     case '\\'':",
          "2592:     case '\"':",
          "2593:     case ' ':",
          "2594:       proto[i] = '_';",
          "2595:       break;",
          "2596:     }",
          "2597:   }",
          "2599:   for (i = 0, def = NULL; i < (int) ndpi_str->ndpi_num_supported_protocols; i++) {",
          "2600:     if(ndpi_str->proto_defaults[i].protoName && strcasecmp(ndpi_str->proto_defaults[i].protoName, proto) == 0) {",
          "2601:       def = &ndpi_str->proto_defaults[i];",
          "2602:       subprotocol_id = i;",
          "2603:       break;",
          "2604:     }",
          "2605:   }",
          "2607:   if(def == NULL) {",
          "2608:     if(!do_add) {",
          "2610:       NDPI_LOG_ERR(ndpi_str, \"Unable to find protocol '%s': skipping rule '%s'\\n\", proto, rule);",
          "2611:       return(-3);",
          "2612:     } else {",
          "2613:       ndpi_port_range ports_a[MAX_DEFAULT_PORTS], ports_b[MAX_DEFAULT_PORTS];",
          "2614:       u_int16_t no_master[2] = {NDPI_PROTOCOL_NO_MASTER_PROTO, NDPI_PROTOCOL_NO_MASTER_PROTO};",
          "2616:       if(ndpi_str->ndpi_num_custom_protocols >= (NDPI_MAX_NUM_CUSTOM_PROTOCOLS - 1)) {",
          "2617:  NDPI_LOG_ERR(ndpi_str, \"Too many protocols defined (%u): skipping protocol %s\\n\",",
          "2618:        ndpi_str->ndpi_num_custom_protocols, proto);",
          "2619:  return(-2);",
          "2620:       }",
          "2622:       ndpi_set_proto_defaults(",
          "2623:          ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, ndpi_str->ndpi_num_supported_protocols,",
          "2624:          0 /* can_have_a_subprotocol */, no_master, no_master, proto,",
          "2626:          ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "2627:          ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "2628:       def = &ndpi_str->proto_defaults[ndpi_str->ndpi_num_supported_protocols];",
          "2629:       subprotocol_id = ndpi_str->ndpi_num_supported_protocols;",
          "2630:       ndpi_str->ndpi_num_supported_protocols++, ndpi_str->ndpi_num_custom_protocols++;",
          "2631:     }",
          "2632:   }",
          "2634:   while ((elem = strsep(&rule, \",\")) != NULL) {",
          "2635:     char *attr = elem, *value = NULL;",
          "2636:     ndpi_port_range range;",
          "2637:     int is_tcp = 0, is_udp = 0, is_ip = 0;",
          "2639:     if(strncmp(attr, \"tcp:\", 4) == 0)",
          "2640:       is_tcp = 1, value = &attr[4];",
          "2641:     else if(strncmp(attr, \"udp:\", 4) == 0)",
          "2642:       is_udp = 1, value = &attr[4];",
          "2643:     else if(strncmp(attr, \"ip:\", 3) == 0)",
          "2644:       is_ip = 1, value = &attr[3];",
          "2645:     else if(strncmp(attr, \"host:\", 5) == 0) {",
          "2647:       value = &attr[5];",
          "2648:       if(value[0] == '\"')",
          "2650:       if(value[strlen(value) - 1] == '\"')",
          "2652:     }",
          "2654:     if(is_tcp || is_udp) {",
          "2655:       u_int p_low, p_high;",
          "2657:       if(sscanf(value, \"%u-%u\", &p_low, &p_high) == 2)",
          "2658:  range.port_low = p_low, range.port_high = p_high;",
          "2659:       else",
          "2660:  range.port_low = range.port_high = atoi(&elem[4]);",
          "2662:       if(do_add)",
          "2663:  addDefaultPort(ndpi_str, &range, def, 1 /* Custom user proto */,",
          "2664:          is_tcp ? &ndpi_str->tcpRoot : &ndpi_str->udpRoot, __FUNCTION__, __LINE__);",
          "2665:       else",
          "2666:  removeDefaultPort(&range, def, is_tcp ? &ndpi_str->tcpRoot : &ndpi_str->udpRoot);",
          "2667:     } else if(is_ip) {",
          "2669:       ndpi_add_host_ip_subprotocol(ndpi_str, value, subprotocol_id);",
          "2670:     } else {",
          "2671:       if(do_add)",
          "2672:  ndpi_add_host_url_subprotocol(ndpi_str, value, subprotocol_id, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED,",
          "2673:           NDPI_PROTOCOL_ACCEPTABLE);",
          "2674:       else",
          "2675:  ndpi_remove_host_url_subprotocol(ndpi_str, value, subprotocol_id);",
          "2677:   }",
          "2679:   return(0);",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "2784:     }",
          "2790: }",
          "",
          "[Removed Lines]",
          "2747: int ndpi_load_categories_file(struct ndpi_detection_module_struct *ndpi_str, const char *path)",
          "2748: {",
          "2749:     char buffer[512], *line, *name, *category, *saveptr;",
          "2750:     FILE *fd;",
          "2751:     int len, num = 0;",
          "2753:     fd = fopen(path, \"r\");",
          "2755:     if (fd == NULL) {",
          "2756:         NDPI_LOG_ERR(ndpi_str, \"Unable to open file %s [%s]\\n\", path, strerror(errno));",
          "2757:         return (-1);",
          "2758:     }",
          "2760:     while (1) {",
          "2761:         line = fgets(buffer, sizeof(buffer), fd);",
          "2763:         if (line == NULL)",
          "2764:             break;",
          "2766:         len = strlen(line);",
          "2768:         if ((len <= 1) || (line[0] == '#'))",
          "2769:             continue;",
          "2771:         line[len - 1] = '\\0';",
          "2772:         name = strtok_r(line, \"\\t\", &saveptr);",
          "2774:         if (name) {",
          "2775:             category = strtok_r(NULL, \"\\t\", &saveptr);",
          "2777:             if (category) {",
          "2778:                 int rc = ndpi_load_category(ndpi_str, name, (ndpi_protocol_category_t) atoi(category));",
          "2780:                 if (rc >= 0)",
          "2781:                     num++;",
          "2782:             }",
          "2783:         }",
          "2786:     fclose(fd);",
          "2787:     ndpi_enable_loaded_categories(ndpi_str);",
          "2789:     return (num);",
          "",
          "[Added Lines]",
          "2693: int ndpi_load_categories_file(struct ndpi_detection_module_struct *ndpi_str, const char *path) {",
          "2694:   char buffer[512], *line, *name, *category, *saveptr;",
          "2695:   FILE *fd;",
          "2696:   int len, num = 0;",
          "2698:   fd = fopen(path, \"r\");",
          "2700:   if(fd == NULL) {",
          "2701:     NDPI_LOG_ERR(ndpi_str, \"Unable to open file %s [%s]\\n\", path, strerror(errno));",
          "2702:     return(-1);",
          "2703:   }",
          "2705:   while (1) {",
          "2706:     line = fgets(buffer, sizeof(buffer), fd);",
          "2708:     if(line == NULL)",
          "2709:       break;",
          "2711:     len = strlen(line);",
          "2713:     if((len <= 1) || (line[0] == '#'))",
          "2714:       continue;",
          "2716:     line[len - 1] = '\\0';",
          "2717:     name = strtok_r(line, \"\\t\", &saveptr);",
          "2719:     if(name) {",
          "2720:       category = strtok_r(NULL, \"\\t\", &saveptr);",
          "2722:       if(category) {",
          "2723:  int rc = ndpi_load_category(ndpi_str, name, (ndpi_protocol_category_t) atoi(category));",
          "2725:  if(rc >= 0)",
          "2726:    num++;",
          "2727:       }",
          "2729:   }",
          "2731:   fclose(fd);",
          "2732:   ndpi_enable_loaded_categories(ndpi_str);",
          "2734:   return(num);",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "2806:   udp:139@NETBIOS",
          "2873: }",
          "",
          "[Removed Lines]",
          "2809: int ndpi_load_protocols_file(struct ndpi_detection_module_struct *ndpi_str, const char *path)",
          "2810: {",
          "2811:     FILE *fd;",
          "2812:     char *buffer, *old_buffer;",
          "2813:     int chunk_len = 512, buffer_len = chunk_len, old_buffer_len;",
          "2814:     int i, rc = -1;",
          "2816:     fd = fopen(path, \"r\");",
          "2818:     if (fd == NULL) {",
          "2819:         NDPI_LOG_ERR(ndpi_str, \"Unable to open file %s [%s]\\n\", path, strerror(errno));",
          "2820:         goto error;",
          "2821:     }",
          "2823:     buffer = ndpi_malloc(buffer_len);",
          "2825:     if (buffer == NULL) {",
          "2826:         NDPI_LOG_ERR(ndpi_str, \"Memory allocation failure\\n\");",
          "2827:         goto close_fd;",
          "2828:     }",
          "2830:     while (1) {",
          "2831:         char *line = buffer;",
          "2832:         int line_len = buffer_len;",
          "2834:         while ((line = fgets(line, line_len, fd)) != NULL && line[strlen(line) - 1] != '\\n') {",
          "2835:             i = strlen(line);",
          "2836:             old_buffer = buffer;",
          "2837:             old_buffer_len = buffer_len;",
          "2838:             buffer_len += chunk_len;",
          "2840:             buffer = ndpi_realloc(old_buffer, old_buffer_len, buffer_len);",
          "2842:             if (buffer == NULL) {",
          "2843:                 NDPI_LOG_ERR(ndpi_str, \"Memory allocation failure\\n\");",
          "2844:                 ndpi_free(old_buffer);",
          "2845:                 goto close_fd;",
          "2846:             }",
          "2848:             line = &buffer[i];",
          "2849:             line_len = chunk_len;",
          "2850:         }",
          "2853:             break;",
          "2855:         i = strlen(buffer);",
          "2856:         if ((i <= 1) || (buffer[0] == '#'))",
          "2857:             continue;",
          "2858:         else",
          "2859:             buffer[i - 1] = '\\0';",
          "2861:         ndpi_handle_rule(ndpi_str, buffer, 1);",
          "2862:     }",
          "2864:     rc = 0;",
          "2866:     ndpi_free(buffer);",
          "2868: close_fd:",
          "2869:     fclose(fd);",
          "2871: error:",
          "2872:     return (rc);",
          "",
          "[Added Lines]",
          "2754: int ndpi_load_protocols_file(struct ndpi_detection_module_struct *ndpi_str, const char *path) {",
          "2755:   FILE *fd;",
          "2756:   char *buffer, *old_buffer;",
          "2757:   int chunk_len = 512, buffer_len = chunk_len, old_buffer_len;",
          "2758:   int i, rc = -1;",
          "2760:   fd = fopen(path, \"r\");",
          "2762:   if(fd == NULL) {",
          "2763:     NDPI_LOG_ERR(ndpi_str, \"Unable to open file %s [%s]\\n\", path, strerror(errno));",
          "2764:     goto error;",
          "2765:   }",
          "2767:   buffer = ndpi_malloc(buffer_len);",
          "2769:   if(buffer == NULL) {",
          "2770:     NDPI_LOG_ERR(ndpi_str, \"Memory allocation failure\\n\");",
          "2771:     goto close_fd;",
          "2772:   }",
          "2774:   while (1) {",
          "2775:     char *line = buffer;",
          "2776:     int line_len = buffer_len;",
          "2778:     while ((line = fgets(line, line_len, fd)) != NULL && line[strlen(line) - 1] != '\\n') {",
          "2779:       i = strlen(line);",
          "2780:       old_buffer = buffer;",
          "2781:       old_buffer_len = buffer_len;",
          "2782:       buffer_len += chunk_len;",
          "2784:       buffer = ndpi_realloc(old_buffer, old_buffer_len, buffer_len);",
          "2786:       if(buffer == NULL) {",
          "2787:  NDPI_LOG_ERR(ndpi_str, \"Memory allocation failure\\n\");",
          "2788:  ndpi_free(old_buffer);",
          "2789:  goto close_fd;",
          "2790:       }",
          "2792:       line = &buffer[i];",
          "2793:       line_len = chunk_len;",
          "2794:     }",
          "2797:       break;",
          "2799:     i = strlen(buffer);",
          "2800:     if((i <= 1) || (buffer[0] == '#'))",
          "2801:       continue;",
          "2802:     else",
          "2803:       buffer[i - 1] = '\\0';",
          "2805:     ndpi_handle_rule(ndpi_str, buffer, 1);",
          "2806:   }",
          "2808:   rc = 0;",
          "2810:   ndpi_free(buffer);",
          "2812:  close_fd:",
          "2813:   fclose(fd);",
          "2815:  error:",
          "2816:   return(rc);",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "2881:                                          void (*func)(struct ndpi_detection_module_struct *,",
          "2882:                                                       struct ndpi_flow_struct *flow),",
          "2883:                                          const NDPI_SELECTION_BITMASK_PROTOCOL_SIZE ndpi_selection_bitmask,",
          "2887:     Compare specify protocol bitmask with main detection bitmask",
          "2890: #ifdef DEBUG",
          "2895: #endif",
          "2900: #ifdef DEBUG",
          "2903: #endif",
          "2907:       Set function and index protocol within proto_default structure for port protocol detection",
          "2908:       and callback_buffer function for DPI protocol detection",
          "2914:       Set ndpi_selection_bitmask for protocol",
          "2919:       Reset protocol detection bitmask via NDPI_PROTOCOL_UNKNOWN and than add specify protocol bitmast to callback",
          "2920:       buffer.",
          "2929: }",
          "2933: void ndpi_set_protocol_detection_bitmask2(struct ndpi_detection_module_struct *ndpi_str,",
          "3429:   init_websocket_dissector(ndpi_str, &a, detection_bitmask);",
          "",
          "[Removed Lines]",
          "2884:                                          u_int8_t b_save_bitmask_unknow, u_int8_t b_add_detection_bitmask)",
          "2885: {",
          "2889:     if (NDPI_COMPARE_PROTOCOL_TO_BITMASK(*detection_bitmask, ndpi_protocol_id) != 0) {",
          "2891:         NDPI_LOG_DBG2(ndpi_str,",
          "2892:                       \"[NDPI] ndpi_set_bitmask_protocol_detection: %s : [callback_buffer] idx= %u, [proto_defaults] \"",
          "2893:                       \"protocol_id=%u\\n\",",
          "2894:                       label, idx, ndpi_protocol_id);",
          "2897:         if (ndpi_str->proto_defaults[ndpi_protocol_id].protoIdx != 0) {",
          "2898:             NDPI_LOG_DBG2(ndpi_str, \"[NDPI] Internal error: protocol %s/%u has been already registered\\n\", label,",
          "2899:                           ndpi_protocol_id);",
          "2901:         } else {",
          "2902:             NDPI_LOG_DBG2(ndpi_str, \"[NDPI] Adding %s with protocol id %d\\n\", label, ndpi_protocol_id);",
          "2904:         }",
          "2910:         ndpi_str->proto_defaults[ndpi_protocol_id].protoIdx = idx;",
          "2911:         ndpi_str->proto_defaults[ndpi_protocol_id].func = ndpi_str->callback_buffer[idx].func = func;",
          "2916:         ndpi_str->callback_buffer[idx].ndpi_selection_bitmask = ndpi_selection_bitmask;",
          "2922:         if (b_save_bitmask_unknow)",
          "2923:             NDPI_SAVE_AS_BITMASK(ndpi_str->callback_buffer[idx].detection_bitmask, NDPI_PROTOCOL_UNKNOWN);",
          "2924:         if (b_add_detection_bitmask)",
          "2925:             NDPI_ADD_PROTOCOL_TO_BITMASK(ndpi_str->callback_buffer[idx].detection_bitmask, ndpi_protocol_id);",
          "2927:         NDPI_SAVE_AS_BITMASK(ndpi_str->callback_buffer[idx].excluded_protocol_bitmask, ndpi_protocol_id);",
          "2928:     }",
          "2934:                                           const NDPI_PROTOCOL_BITMASK *dbm)",
          "2935: {",
          "2936:     NDPI_PROTOCOL_BITMASK detection_bitmask_local;",
          "2937:     NDPI_PROTOCOL_BITMASK *detection_bitmask = &detection_bitmask_local;",
          "2938:     u_int32_t a = 0;",
          "2940:     NDPI_BITMASK_SET(detection_bitmask_local, *dbm);",
          "2941:     NDPI_BITMASK_SET(ndpi_str->detection_bitmask, *dbm);",
          "2944:     ndpi_str->callback_buffer_size = 0;",
          "2947:     init_http_dissector(ndpi_str, &a, detection_bitmask);",
          "2950:     init_starcraft_dissector(ndpi_str, &a, detection_bitmask);",
          "2953:     init_tls_dissector(ndpi_str, &a, detection_bitmask);",
          "2956:     init_stun_dissector(ndpi_str, &a, detection_bitmask);",
          "2959:     init_rtp_dissector(ndpi_str, &a, detection_bitmask);",
          "2962:     init_rtsp_dissector(ndpi_str, &a, detection_bitmask);",
          "2965:     init_rdp_dissector(ndpi_str, &a, detection_bitmask);",
          "2968:     init_sip_dissector(ndpi_str, &a, detection_bitmask);",
          "2971:     init_imo_dissector(ndpi_str, &a, detection_bitmask);",
          "2974:     init_teredo_dissector(ndpi_str, &a, detection_bitmask);",
          "2977:     init_edonkey_dissector(ndpi_str, &a, detection_bitmask);",
          "2980:     init_fasttrack_dissector(ndpi_str, &a, detection_bitmask);",
          "2983:     init_gnutella_dissector(ndpi_str, &a, detection_bitmask);",
          "2986:     init_directconnect_dissector(ndpi_str, &a, detection_bitmask);",
          "2989:     init_nats_dissector(ndpi_str, &a, detection_bitmask);",
          "2992:     init_yahoo_dissector(ndpi_str, &a, detection_bitmask);",
          "2995:     init_oscar_dissector(ndpi_str, &a, detection_bitmask);",
          "2998:     init_applejuice_dissector(ndpi_str, &a, detection_bitmask);",
          "3001:     init_soulseek_dissector(ndpi_str, &a, detection_bitmask);",
          "3004:     init_socks_dissector(ndpi_str, &a, detection_bitmask);",
          "3007:     init_irc_dissector(ndpi_str, &a, detection_bitmask);",
          "3010:     init_jabber_dissector(ndpi_str, &a, detection_bitmask);",
          "3013:     init_mail_pop_dissector(ndpi_str, &a, detection_bitmask);",
          "3016:     init_mail_imap_dissector(ndpi_str, &a, detection_bitmask);",
          "3019:     init_mail_smtp_dissector(ndpi_str, &a, detection_bitmask);",
          "3022:     init_usenet_dissector(ndpi_str, &a, detection_bitmask);",
          "3025:     init_dns_dissector(ndpi_str, &a, detection_bitmask);",
          "3028:     init_fbzero_dissector(ndpi_str, &a, detection_bitmask);",
          "3031:     init_vmware_dissector(ndpi_str, &a, detection_bitmask);",
          "3034:     init_non_tcp_udp_dissector(ndpi_str, &a, detection_bitmask);",
          "3037:     init_tvants_dissector(ndpi_str, &a, detection_bitmask);",
          "3040:     init_sopcast_dissector(ndpi_str, &a, detection_bitmask);",
          "3043:     init_tvuplayer_dissector(ndpi_str, &a, detection_bitmask);",
          "3046:     init_ppstream_dissector(ndpi_str, &a, detection_bitmask);",
          "3049:     init_pplive_dissector(ndpi_str, &a, detection_bitmask);",
          "3052:     init_iax_dissector(ndpi_str, &a, detection_bitmask);",
          "3055:     init_mgpc_dissector(ndpi_str, &a, detection_bitmask);",
          "3058:     init_zattoo_dissector(ndpi_str, &a, detection_bitmask);",
          "3061:     init_qq_dissector(ndpi_str, &a, detection_bitmask);",
          "3064:     init_ssh_dissector(ndpi_str, &a, detection_bitmask);",
          "3067:     init_ayiya_dissector(ndpi_str, &a, detection_bitmask);",
          "3070:     init_thunder_dissector(ndpi_str, &a, detection_bitmask);",
          "3073:     init_vnc_dissector(ndpi_str, &a, detection_bitmask);",
          "3076:     init_teamviewer_dissector(ndpi_str, &a, detection_bitmask);",
          "3079:     init_dhcp_dissector(ndpi_str, &a, detection_bitmask);",
          "3082:     init_steam_dissector(ndpi_str, &a, detection_bitmask);",
          "3085:     init_halflife2_dissector(ndpi_str, &a, detection_bitmask);",
          "3088:     init_xbox_dissector(ndpi_str, &a, detection_bitmask);",
          "3091:     init_http_activesync_dissector(ndpi_str, &a, detection_bitmask);",
          "3094:     init_smb_dissector(ndpi_str, &a, detection_bitmask);",
          "3097:     init_mining_dissector(ndpi_str, &a, detection_bitmask);",
          "3100:     init_telnet_dissector(ndpi_str, &a, detection_bitmask);",
          "3103:     init_ntp_dissector(ndpi_str, &a, detection_bitmask);",
          "3106:     init_nfs_dissector(ndpi_str, &a, detection_bitmask);",
          "3109:     init_ssdp_dissector(ndpi_str, &a, detection_bitmask);",
          "3112:     init_world_of_warcraft_dissector(ndpi_str, &a, detection_bitmask);",
          "3115:     init_postgres_dissector(ndpi_str, &a, detection_bitmask);",
          "3118:     init_mysql_dissector(ndpi_str, &a, detection_bitmask);",
          "3121:     init_bgp_dissector(ndpi_str, &a, detection_bitmask);",
          "3124:     init_battlefield_dissector(ndpi_str, &a, detection_bitmask);",
          "3127:     init_pcanywhere_dissector(ndpi_str, &a, detection_bitmask);",
          "3130:     init_snmp_dissector(ndpi_str, &a, detection_bitmask);",
          "3133:     init_kontiki_dissector(ndpi_str, &a, detection_bitmask);",
          "3136:     init_icecast_dissector(ndpi_str, &a, detection_bitmask);",
          "3139:     init_shoutcast_dissector(ndpi_str, &a, detection_bitmask);",
          "3142:     init_kerberos_dissector(ndpi_str, &a, detection_bitmask);",
          "3145:     init_openft_dissector(ndpi_str, &a, detection_bitmask);",
          "3148:     init_syslog_dissector(ndpi_str, &a, detection_bitmask);",
          "3151:     init_directdownloadlink_dissector(ndpi_str, &a, detection_bitmask);",
          "3154:     init_netbios_dissector(ndpi_str, &a, detection_bitmask);",
          "3157:     init_mdns_dissector(ndpi_str, &a, detection_bitmask);",
          "3160:     init_ipp_dissector(ndpi_str, &a, detection_bitmask);",
          "3163:     init_ldap_dissector(ndpi_str, &a, detection_bitmask);",
          "3166:     init_warcraft3_dissector(ndpi_str, &a, detection_bitmask);",
          "3169:     init_xdmcp_dissector(ndpi_str, &a, detection_bitmask);",
          "3172:     init_tftp_dissector(ndpi_str, &a, detection_bitmask);",
          "3175:     init_mssql_tds_dissector(ndpi_str, &a, detection_bitmask);",
          "3178:     init_pptp_dissector(ndpi_str, &a, detection_bitmask);",
          "3181:     init_stealthnet_dissector(ndpi_str, &a, detection_bitmask);",
          "3184:     init_dhcpv6_dissector(ndpi_str, &a, detection_bitmask);",
          "3187:     init_afp_dissector(ndpi_str, &a, detection_bitmask);",
          "3190:     init_checkmk_dissector(ndpi_str, &a, detection_bitmask);",
          "3193:     init_aimini_dissector(ndpi_str, &a, detection_bitmask);",
          "3196:     init_florensia_dissector(ndpi_str, &a, detection_bitmask);",
          "3199:     init_maplestory_dissector(ndpi_str, &a, detection_bitmask);",
          "3202:     init_dofus_dissector(ndpi_str, &a, detection_bitmask);",
          "3205:     init_world_of_kung_fu_dissector(ndpi_str, &a, detection_bitmask);",
          "3208:     init_fiesta_dissector(ndpi_str, &a, detection_bitmask);",
          "3211:     init_crossfire_dissector(ndpi_str, &a, detection_bitmask);",
          "3214:     init_guildwars_dissector(ndpi_str, &a, detection_bitmask);",
          "3217:     init_armagetron_dissector(ndpi_str, &a, detection_bitmask);",
          "3220:     init_dropbox_dissector(ndpi_str, &a, detection_bitmask);",
          "3223:     init_spotify_dissector(ndpi_str, &a, detection_bitmask);",
          "3226:     init_radius_dissector(ndpi_str, &a, detection_bitmask);",
          "3229:     init_citrix_dissector(ndpi_str, &a, detection_bitmask);",
          "3232:     init_lotus_notes_dissector(ndpi_str, &a, detection_bitmask);",
          "3235:     init_gtp_dissector(ndpi_str, &a, detection_bitmask);",
          "3238:     init_dcerpc_dissector(ndpi_str, &a, detection_bitmask);",
          "3241:     init_netflow_dissector(ndpi_str, &a, detection_bitmask);",
          "3244:     init_sflow_dissector(ndpi_str, &a, detection_bitmask);",
          "3247:     init_h323_dissector(ndpi_str, &a, detection_bitmask);",
          "3250:     init_openvpn_dissector(ndpi_str, &a, detection_bitmask);",
          "3253:     init_noe_dissector(ndpi_str, &a, detection_bitmask);",
          "3256:     init_ciscovpn_dissector(ndpi_str, &a, detection_bitmask);",
          "3259:     init_teamspeak_dissector(ndpi_str, &a, detection_bitmask);",
          "3262:     init_tor_dissector(ndpi_str, &a, detection_bitmask);",
          "3265:     init_skinny_dissector(ndpi_str, &a, detection_bitmask);",
          "3268:     init_rtcp_dissector(ndpi_str, &a, detection_bitmask);",
          "3271:     init_rsync_dissector(ndpi_str, &a, detection_bitmask);",
          "3274:     init_whois_das_dissector(ndpi_str, &a, detection_bitmask);",
          "3277:     init_oracle_dissector(ndpi_str, &a, detection_bitmask);",
          "3280:     init_corba_dissector(ndpi_str, &a, detection_bitmask);",
          "3283:     init_rtmp_dissector(ndpi_str, &a, detection_bitmask);",
          "3286:     init_ftp_control_dissector(ndpi_str, &a, detection_bitmask);",
          "3289:     init_ftp_data_dissector(ndpi_str, &a, detection_bitmask);",
          "3292:     init_pando_dissector(ndpi_str, &a, detection_bitmask);",
          "3295:     init_megaco_dissector(ndpi_str, &a, detection_bitmask);",
          "3298:     init_redis_dissector(ndpi_str, &a, detection_bitmask);",
          "3301:     init_upnp_dissector(ndpi_str, &a, detection_bitmask);",
          "3304:     init_vhua_dissector(ndpi_str, &a, detection_bitmask);",
          "3307:     init_zmq_dissector(ndpi_str, &a, detection_bitmask);",
          "3310:     init_telegram_dissector(ndpi_str, &a, detection_bitmask);",
          "3313:     init_quic_dissector(ndpi_str, &a, detection_bitmask);",
          "3316:     init_diameter_dissector(ndpi_str, &a, detection_bitmask);",
          "3319:     init_apple_push_dissector(ndpi_str, &a, detection_bitmask);",
          "3322:     init_eaq_dissector(ndpi_str, &a, detection_bitmask);",
          "3325:     init_kakaotalk_voice_dissector(ndpi_str, &a, detection_bitmask);",
          "3328:     init_mpegts_dissector(ndpi_str, &a, detection_bitmask);",
          "3331:     init_ubntac2_dissector(ndpi_str, &a, detection_bitmask);",
          "3334:     init_coap_dissector(ndpi_str, &a, detection_bitmask);",
          "3337:     init_mqtt_dissector(ndpi_str, &a, detection_bitmask);",
          "3340:     init_someip_dissector(ndpi_str, &a, detection_bitmask);",
          "3343:     init_rx_dissector(ndpi_str, &a, detection_bitmask);",
          "3346:     init_git_dissector(ndpi_str, &a, detection_bitmask);",
          "3349:     init_hangout_dissector(ndpi_str, &a, detection_bitmask);",
          "3352:     init_drda_dissector(ndpi_str, &a, detection_bitmask);",
          "3355:     init_bjnp_dissector(ndpi_str, &a, detection_bitmask);",
          "3358:     init_smpp_dissector(ndpi_str, &a, detection_bitmask);",
          "3361:     init_tinc_dissector(ndpi_str, &a, detection_bitmask);",
          "3364:     init_fix_dissector(ndpi_str, &a, detection_bitmask);",
          "3367:     init_nintendo_dissector(ndpi_str, &a, detection_bitmask);",
          "3370:     init_modbus_dissector(ndpi_str, &a, detection_bitmask);",
          "3373:     init_capwap_dissector(ndpi_str, &a, detection_bitmask);",
          "3376:     init_zabbix_dissector(ndpi_str, &a, detection_bitmask);",
          "3381:     init_viber_dissector(ndpi_str, &a, detection_bitmask);",
          "3384:     init_skype_dissector(ndpi_str, &a, detection_bitmask);",
          "3387:     init_bittorrent_dissector(ndpi_str, &a, detection_bitmask);",
          "3390:     init_whatsapp_dissector(ndpi_str, &a, detection_bitmask);",
          "3393:     init_ookla_dissector(ndpi_str, &a, detection_bitmask);",
          "3396:     init_amqp_dissector(ndpi_str, &a, detection_bitmask);",
          "3399:     init_csgo_dissector(ndpi_str, &a, detection_bitmask);",
          "3402:     init_lisp_dissector(ndpi_str, &a, detection_bitmask);",
          "3405:     init_ajp_dissector(ndpi_str, &a, detection_bitmask);",
          "3408:     init_memcached_dissector(ndpi_str, &a, detection_bitmask);",
          "3411:     init_nest_log_sink_dissector(ndpi_str, &a, detection_bitmask);",
          "3414:     init_wireguard_dissector(ndpi_str, &a, detection_bitmask);",
          "3417:     init_amazon_video_dissector(ndpi_str, &a, detection_bitmask);",
          "3420:     init_targus_getdata_dissector(ndpi_str, &a, detection_bitmask);",
          "3423:     init_s7comm_dissector(ndpi_str, &a, detection_bitmask);",
          "3426:     init_104_dissector(ndpi_str, &a, detection_bitmask);",
          "",
          "[Added Lines]",
          "2828:                                          u_int8_t b_save_bitmask_unknow, u_int8_t b_add_detection_bitmask) {",
          "2832:   if(NDPI_COMPARE_PROTOCOL_TO_BITMASK(*detection_bitmask, ndpi_protocol_id) != 0) {",
          "2834:     NDPI_LOG_DBG2(ndpi_str,",
          "2835:     \"[NDPI] ndpi_set_bitmask_protocol_detection: %s : [callback_buffer] idx= %u, [proto_defaults] \"",
          "2836:     \"protocol_id=%u\\n\",",
          "2837:     label, idx, ndpi_protocol_id);",
          "2840:     if(ndpi_str->proto_defaults[ndpi_protocol_id].protoIdx != 0) {",
          "2841:       NDPI_LOG_DBG2(ndpi_str, \"[NDPI] Internal error: protocol %s/%u has been already registered\\n\", label,",
          "2842:       ndpi_protocol_id);",
          "2844:     } else {",
          "2845:       NDPI_LOG_DBG2(ndpi_str, \"[NDPI] Adding %s with protocol id %d\\n\", label, ndpi_protocol_id);",
          "2847:     }",
          "2853:     ndpi_str->proto_defaults[ndpi_protocol_id].protoIdx = idx;",
          "2854:     ndpi_str->proto_defaults[ndpi_protocol_id].func = ndpi_str->callback_buffer[idx].func = func;",
          "2859:     ndpi_str->callback_buffer[idx].ndpi_selection_bitmask = ndpi_selection_bitmask;",
          "2865:     if(b_save_bitmask_unknow)",
          "2866:       NDPI_SAVE_AS_BITMASK(ndpi_str->callback_buffer[idx].detection_bitmask, NDPI_PROTOCOL_UNKNOWN);",
          "2867:     if(b_add_detection_bitmask)",
          "2868:       NDPI_ADD_PROTOCOL_TO_BITMASK(ndpi_str->callback_buffer[idx].detection_bitmask, ndpi_protocol_id);",
          "2870:     NDPI_SAVE_AS_BITMASK(ndpi_str->callback_buffer[idx].excluded_protocol_bitmask, ndpi_protocol_id);",
          "2871:   }",
          "2877:                                           const NDPI_PROTOCOL_BITMASK *dbm) {",
          "2878:   NDPI_PROTOCOL_BITMASK detection_bitmask_local;",
          "2879:   NDPI_PROTOCOL_BITMASK *detection_bitmask = &detection_bitmask_local;",
          "2880:   u_int32_t a = 0;",
          "2882:   NDPI_BITMASK_SET(detection_bitmask_local, *dbm);",
          "2883:   NDPI_BITMASK_SET(ndpi_str->detection_bitmask, *dbm);",
          "2886:   ndpi_str->callback_buffer_size = 0;",
          "2889:   init_http_dissector(ndpi_str, &a, detection_bitmask);",
          "2892:   init_starcraft_dissector(ndpi_str, &a, detection_bitmask);",
          "2895:   init_tls_dissector(ndpi_str, &a, detection_bitmask);",
          "2898:   init_stun_dissector(ndpi_str, &a, detection_bitmask);",
          "2901:   init_rtp_dissector(ndpi_str, &a, detection_bitmask);",
          "2904:   init_rtsp_dissector(ndpi_str, &a, detection_bitmask);",
          "2907:   init_rdp_dissector(ndpi_str, &a, detection_bitmask);",
          "2910:   init_sip_dissector(ndpi_str, &a, detection_bitmask);",
          "2913:   init_imo_dissector(ndpi_str, &a, detection_bitmask);",
          "2916:   init_teredo_dissector(ndpi_str, &a, detection_bitmask);",
          "2919:   init_edonkey_dissector(ndpi_str, &a, detection_bitmask);",
          "2922:   init_fasttrack_dissector(ndpi_str, &a, detection_bitmask);",
          "2925:   init_gnutella_dissector(ndpi_str, &a, detection_bitmask);",
          "2928:   init_directconnect_dissector(ndpi_str, &a, detection_bitmask);",
          "2931:   init_nats_dissector(ndpi_str, &a, detection_bitmask);",
          "2934:   init_yahoo_dissector(ndpi_str, &a, detection_bitmask);",
          "2937:   init_oscar_dissector(ndpi_str, &a, detection_bitmask);",
          "2940:   init_applejuice_dissector(ndpi_str, &a, detection_bitmask);",
          "2943:   init_soulseek_dissector(ndpi_str, &a, detection_bitmask);",
          "2946:   init_socks_dissector(ndpi_str, &a, detection_bitmask);",
          "2949:   init_irc_dissector(ndpi_str, &a, detection_bitmask);",
          "2952:   init_jabber_dissector(ndpi_str, &a, detection_bitmask);",
          "2955:   init_mail_pop_dissector(ndpi_str, &a, detection_bitmask);",
          "2958:   init_mail_imap_dissector(ndpi_str, &a, detection_bitmask);",
          "2961:   init_mail_smtp_dissector(ndpi_str, &a, detection_bitmask);",
          "2964:   init_usenet_dissector(ndpi_str, &a, detection_bitmask);",
          "2967:   init_dns_dissector(ndpi_str, &a, detection_bitmask);",
          "2970:   init_fbzero_dissector(ndpi_str, &a, detection_bitmask);",
          "2973:   init_vmware_dissector(ndpi_str, &a, detection_bitmask);",
          "2976:   init_non_tcp_udp_dissector(ndpi_str, &a, detection_bitmask);",
          "2979:   init_tvants_dissector(ndpi_str, &a, detection_bitmask);",
          "2982:   init_sopcast_dissector(ndpi_str, &a, detection_bitmask);",
          "2985:   init_tvuplayer_dissector(ndpi_str, &a, detection_bitmask);",
          "2988:   init_ppstream_dissector(ndpi_str, &a, detection_bitmask);",
          "2991:   init_pplive_dissector(ndpi_str, &a, detection_bitmask);",
          "2994:   init_iax_dissector(ndpi_str, &a, detection_bitmask);",
          "2997:   init_mgpc_dissector(ndpi_str, &a, detection_bitmask);",
          "3000:   init_zattoo_dissector(ndpi_str, &a, detection_bitmask);",
          "3003:   init_qq_dissector(ndpi_str, &a, detection_bitmask);",
          "3006:   init_ssh_dissector(ndpi_str, &a, detection_bitmask);",
          "3009:   init_ayiya_dissector(ndpi_str, &a, detection_bitmask);",
          "3012:   init_thunder_dissector(ndpi_str, &a, detection_bitmask);",
          "3015:   init_vnc_dissector(ndpi_str, &a, detection_bitmask);",
          "3018:   init_teamviewer_dissector(ndpi_str, &a, detection_bitmask);",
          "3021:   init_dhcp_dissector(ndpi_str, &a, detection_bitmask);",
          "3024:   init_steam_dissector(ndpi_str, &a, detection_bitmask);",
          "3027:   init_halflife2_dissector(ndpi_str, &a, detection_bitmask);",
          "3030:   init_xbox_dissector(ndpi_str, &a, detection_bitmask);",
          "3033:   init_http_activesync_dissector(ndpi_str, &a, detection_bitmask);",
          "3036:   init_smb_dissector(ndpi_str, &a, detection_bitmask);",
          "3039:   init_mining_dissector(ndpi_str, &a, detection_bitmask);",
          "3042:   init_telnet_dissector(ndpi_str, &a, detection_bitmask);",
          "3045:   init_ntp_dissector(ndpi_str, &a, detection_bitmask);",
          "3048:   init_nfs_dissector(ndpi_str, &a, detection_bitmask);",
          "3051:   init_ssdp_dissector(ndpi_str, &a, detection_bitmask);",
          "3054:   init_world_of_warcraft_dissector(ndpi_str, &a, detection_bitmask);",
          "3057:   init_postgres_dissector(ndpi_str, &a, detection_bitmask);",
          "3060:   init_mysql_dissector(ndpi_str, &a, detection_bitmask);",
          "3063:   init_bgp_dissector(ndpi_str, &a, detection_bitmask);",
          "3066:   init_battlefield_dissector(ndpi_str, &a, detection_bitmask);",
          "3069:   init_pcanywhere_dissector(ndpi_str, &a, detection_bitmask);",
          "3072:   init_snmp_dissector(ndpi_str, &a, detection_bitmask);",
          "3075:   init_kontiki_dissector(ndpi_str, &a, detection_bitmask);",
          "3078:   init_icecast_dissector(ndpi_str, &a, detection_bitmask);",
          "3081:   init_shoutcast_dissector(ndpi_str, &a, detection_bitmask);",
          "3084:   init_kerberos_dissector(ndpi_str, &a, detection_bitmask);",
          "3087:   init_openft_dissector(ndpi_str, &a, detection_bitmask);",
          "3090:   init_syslog_dissector(ndpi_str, &a, detection_bitmask);",
          "3093:   init_directdownloadlink_dissector(ndpi_str, &a, detection_bitmask);",
          "3096:   init_netbios_dissector(ndpi_str, &a, detection_bitmask);",
          "3099:   init_mdns_dissector(ndpi_str, &a, detection_bitmask);",
          "3102:   init_ipp_dissector(ndpi_str, &a, detection_bitmask);",
          "3105:   init_ldap_dissector(ndpi_str, &a, detection_bitmask);",
          "3108:   init_warcraft3_dissector(ndpi_str, &a, detection_bitmask);",
          "3111:   init_xdmcp_dissector(ndpi_str, &a, detection_bitmask);",
          "3114:   init_tftp_dissector(ndpi_str, &a, detection_bitmask);",
          "3117:   init_mssql_tds_dissector(ndpi_str, &a, detection_bitmask);",
          "3120:   init_pptp_dissector(ndpi_str, &a, detection_bitmask);",
          "3123:   init_stealthnet_dissector(ndpi_str, &a, detection_bitmask);",
          "3126:   init_dhcpv6_dissector(ndpi_str, &a, detection_bitmask);",
          "3129:   init_afp_dissector(ndpi_str, &a, detection_bitmask);",
          "3132:   init_checkmk_dissector(ndpi_str, &a, detection_bitmask);",
          "3135:   init_aimini_dissector(ndpi_str, &a, detection_bitmask);",
          "3138:   init_florensia_dissector(ndpi_str, &a, detection_bitmask);",
          "3141:   init_maplestory_dissector(ndpi_str, &a, detection_bitmask);",
          "3144:   init_dofus_dissector(ndpi_str, &a, detection_bitmask);",
          "3147:   init_world_of_kung_fu_dissector(ndpi_str, &a, detection_bitmask);",
          "3150:   init_fiesta_dissector(ndpi_str, &a, detection_bitmask);",
          "3153:   init_crossfire_dissector(ndpi_str, &a, detection_bitmask);",
          "3156:   init_guildwars_dissector(ndpi_str, &a, detection_bitmask);",
          "3159:   init_armagetron_dissector(ndpi_str, &a, detection_bitmask);",
          "3162:   init_dropbox_dissector(ndpi_str, &a, detection_bitmask);",
          "3165:   init_spotify_dissector(ndpi_str, &a, detection_bitmask);",
          "3168:   init_radius_dissector(ndpi_str, &a, detection_bitmask);",
          "3171:   init_citrix_dissector(ndpi_str, &a, detection_bitmask);",
          "3174:   init_lotus_notes_dissector(ndpi_str, &a, detection_bitmask);",
          "3177:   init_gtp_dissector(ndpi_str, &a, detection_bitmask);",
          "3180:   init_dcerpc_dissector(ndpi_str, &a, detection_bitmask);",
          "3183:   init_netflow_dissector(ndpi_str, &a, detection_bitmask);",
          "3186:   init_sflow_dissector(ndpi_str, &a, detection_bitmask);",
          "3189:   init_h323_dissector(ndpi_str, &a, detection_bitmask);",
          "3192:   init_openvpn_dissector(ndpi_str, &a, detection_bitmask);",
          "3195:   init_noe_dissector(ndpi_str, &a, detection_bitmask);",
          "3198:   init_ciscovpn_dissector(ndpi_str, &a, detection_bitmask);",
          "3201:   init_teamspeak_dissector(ndpi_str, &a, detection_bitmask);",
          "3204:   init_tor_dissector(ndpi_str, &a, detection_bitmask);",
          "3207:   init_skinny_dissector(ndpi_str, &a, detection_bitmask);",
          "3210:   init_rtcp_dissector(ndpi_str, &a, detection_bitmask);",
          "3213:   init_rsync_dissector(ndpi_str, &a, detection_bitmask);",
          "3216:   init_whois_das_dissector(ndpi_str, &a, detection_bitmask);",
          "3219:   init_oracle_dissector(ndpi_str, &a, detection_bitmask);",
          "3222:   init_corba_dissector(ndpi_str, &a, detection_bitmask);",
          "3225:   init_rtmp_dissector(ndpi_str, &a, detection_bitmask);",
          "3228:   init_ftp_control_dissector(ndpi_str, &a, detection_bitmask);",
          "3231:   init_ftp_data_dissector(ndpi_str, &a, detection_bitmask);",
          "3234:   init_pando_dissector(ndpi_str, &a, detection_bitmask);",
          "3237:   init_megaco_dissector(ndpi_str, &a, detection_bitmask);",
          "3240:   init_redis_dissector(ndpi_str, &a, detection_bitmask);",
          "3243:   init_upnp_dissector(ndpi_str, &a, detection_bitmask);",
          "3246:   init_vhua_dissector(ndpi_str, &a, detection_bitmask);",
          "3249:   init_zmq_dissector(ndpi_str, &a, detection_bitmask);",
          "3252:   init_telegram_dissector(ndpi_str, &a, detection_bitmask);",
          "3255:   init_quic_dissector(ndpi_str, &a, detection_bitmask);",
          "3258:   init_diameter_dissector(ndpi_str, &a, detection_bitmask);",
          "3261:   init_apple_push_dissector(ndpi_str, &a, detection_bitmask);",
          "3264:   init_eaq_dissector(ndpi_str, &a, detection_bitmask);",
          "3267:   init_kakaotalk_voice_dissector(ndpi_str, &a, detection_bitmask);",
          "3270:   init_mpegts_dissector(ndpi_str, &a, detection_bitmask);",
          "3273:   init_ubntac2_dissector(ndpi_str, &a, detection_bitmask);",
          "3276:   init_coap_dissector(ndpi_str, &a, detection_bitmask);",
          "3279:   init_mqtt_dissector(ndpi_str, &a, detection_bitmask);",
          "3282:   init_someip_dissector(ndpi_str, &a, detection_bitmask);",
          "3285:   init_rx_dissector(ndpi_str, &a, detection_bitmask);",
          "3288:   init_git_dissector(ndpi_str, &a, detection_bitmask);",
          "3291:   init_hangout_dissector(ndpi_str, &a, detection_bitmask);",
          "3294:   init_drda_dissector(ndpi_str, &a, detection_bitmask);",
          "3297:   init_bjnp_dissector(ndpi_str, &a, detection_bitmask);",
          "3300:   init_smpp_dissector(ndpi_str, &a, detection_bitmask);",
          "3303:   init_tinc_dissector(ndpi_str, &a, detection_bitmask);",
          "3306:   init_fix_dissector(ndpi_str, &a, detection_bitmask);",
          "3309:   init_nintendo_dissector(ndpi_str, &a, detection_bitmask);",
          "3312:   init_modbus_dissector(ndpi_str, &a, detection_bitmask);",
          "3315:   init_capwap_dissector(ndpi_str, &a, detection_bitmask);",
          "3318:   init_zabbix_dissector(ndpi_str, &a, detection_bitmask);",
          "3323:   init_viber_dissector(ndpi_str, &a, detection_bitmask);",
          "3326:   init_skype_dissector(ndpi_str, &a, detection_bitmask);",
          "3329:   init_bittorrent_dissector(ndpi_str, &a, detection_bitmask);",
          "3332:   init_whatsapp_dissector(ndpi_str, &a, detection_bitmask);",
          "3335:   init_ookla_dissector(ndpi_str, &a, detection_bitmask);",
          "3338:   init_amqp_dissector(ndpi_str, &a, detection_bitmask);",
          "3341:   init_csgo_dissector(ndpi_str, &a, detection_bitmask);",
          "3344:   init_lisp_dissector(ndpi_str, &a, detection_bitmask);",
          "3347:   init_ajp_dissector(ndpi_str, &a, detection_bitmask);",
          "3350:   init_memcached_dissector(ndpi_str, &a, detection_bitmask);",
          "3353:   init_nest_log_sink_dissector(ndpi_str, &a, detection_bitmask);",
          "3356:   init_wireguard_dissector(ndpi_str, &a, detection_bitmask);",
          "3359:   init_amazon_video_dissector(ndpi_str, &a, detection_bitmask);",
          "3362:   init_targus_getdata_dissector(ndpi_str, &a, detection_bitmask);",
          "3365:   init_s7comm_dissector(ndpi_str, &a, detection_bitmask);",
          "3368:   init_104_dissector(ndpi_str, &a, detection_bitmask);",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "3432: #include \"../../../nDPI-custom/custom_ndpi_main_init.c\"",
          "3433: #endif",
          "3460:                         ndpi_str,",
          "3461:                         \"\\tcallback_buffer_tcp_no_payload, additional adding buffer %u to no_payload process\\n\", a);",
          "3468:     }",
          "3483:     }",
          "3500:     }",
          "3501: }",
          "3503: #ifdef NDPI_DETECTION_SUPPORT_IPV6",
          "",
          "[Removed Lines]",
          "3437:     ndpi_str->callback_buffer_size = a;",
          "3439:     NDPI_LOG_DBG2(ndpi_str, \"callback_buffer_size is %u\\n\", ndpi_str->callback_buffer_size);",
          "3442:     ndpi_str->callback_buffer_size_tcp_payload = 0;",
          "3443:     ndpi_str->callback_buffer_size_tcp_no_payload = 0;",
          "3444:     for (a = 0; a < ndpi_str->callback_buffer_size; a++) {",
          "3445:         if ((ndpi_str->callback_buffer[a].ndpi_selection_bitmask &",
          "3446:              (NDPI_SELECTION_BITMASK_PROTOCOL_INT_TCP | NDPI_SELECTION_BITMASK_PROTOCOL_INT_TCP_OR_UDP |",
          "3447:               NDPI_SELECTION_BITMASK_PROTOCOL_COMPLETE_TRAFFIC)) != 0) {",
          "3448:             if (_ndpi_debug_callbacks)",
          "3449:                 NDPI_LOG_DBG2(ndpi_str, \"callback_buffer_tcp_payload, adding buffer %u as entry %u\\n\", a,",
          "3450:                               ndpi_str->callback_buffer_size_tcp_payload);",
          "3452:             memcpy(&ndpi_str->callback_buffer_tcp_payload[ndpi_str->callback_buffer_size_tcp_payload],",
          "3453:                    &ndpi_str->callback_buffer[a], sizeof(struct ndpi_call_function_struct));",
          "3454:             ndpi_str->callback_buffer_size_tcp_payload++;",
          "3456:             if ((ndpi_str->callback_buffer[a].ndpi_selection_bitmask & NDPI_SELECTION_BITMASK_PROTOCOL_HAS_PAYLOAD) ==",
          "3457:                 0) {",
          "3458:                 if (_ndpi_debug_callbacks)",
          "3459:                     NDPI_LOG_DBG2(",
          "3463:                 memcpy(&ndpi_str->callback_buffer_tcp_no_payload[ndpi_str->callback_buffer_size_tcp_no_payload],",
          "3464:                        &ndpi_str->callback_buffer[a], sizeof(struct ndpi_call_function_struct));",
          "3465:                 ndpi_str->callback_buffer_size_tcp_no_payload++;",
          "3466:             }",
          "3467:         }",
          "3470:     ndpi_str->callback_buffer_size_udp = 0;",
          "3471:     for (a = 0; a < ndpi_str->callback_buffer_size; a++) {",
          "3472:         if ((ndpi_str->callback_buffer[a].ndpi_selection_bitmask &",
          "3473:              (NDPI_SELECTION_BITMASK_PROTOCOL_INT_UDP | NDPI_SELECTION_BITMASK_PROTOCOL_INT_TCP_OR_UDP |",
          "3474:               NDPI_SELECTION_BITMASK_PROTOCOL_COMPLETE_TRAFFIC)) != 0) {",
          "3475:             if (_ndpi_debug_callbacks)",
          "3476:                 NDPI_LOG_DBG2(ndpi_str, \"callback_buffer_size_udp: adding buffer : %u as entry %u\\n\", a,",
          "3477:                               ndpi_str->callback_buffer_size_udp);",
          "3479:             memcpy(&ndpi_str->callback_buffer_udp[ndpi_str->callback_buffer_size_udp], &ndpi_str->callback_buffer[a],",
          "3480:                    sizeof(struct ndpi_call_function_struct));",
          "3481:             ndpi_str->callback_buffer_size_udp++;",
          "3482:         }",
          "3485:     ndpi_str->callback_buffer_size_non_tcp_udp = 0;",
          "3486:     for (a = 0; a < ndpi_str->callback_buffer_size; a++) {",
          "3487:         if ((ndpi_str->callback_buffer[a].ndpi_selection_bitmask &",
          "3488:              (NDPI_SELECTION_BITMASK_PROTOCOL_INT_TCP | NDPI_SELECTION_BITMASK_PROTOCOL_INT_UDP |",
          "3489:               NDPI_SELECTION_BITMASK_PROTOCOL_INT_TCP_OR_UDP)) == 0 ||",
          "3490:             (ndpi_str->callback_buffer[a].ndpi_selection_bitmask & NDPI_SELECTION_BITMASK_PROTOCOL_COMPLETE_TRAFFIC) !=",
          "3491:                 0) {",
          "3492:             if (_ndpi_debug_callbacks)",
          "3493:                 NDPI_LOG_DBG2(ndpi_str, \"callback_buffer_non_tcp_udp: adding buffer : %u as entry %u\\n\", a,",
          "3494:                               ndpi_str->callback_buffer_size_non_tcp_udp);",
          "3496:             memcpy(&ndpi_str->callback_buffer_non_tcp_udp[ndpi_str->callback_buffer_size_non_tcp_udp],",
          "3497:                    &ndpi_str->callback_buffer[a], sizeof(struct ndpi_call_function_struct));",
          "3498:             ndpi_str->callback_buffer_size_non_tcp_udp++;",
          "3499:         }",
          "",
          "[Added Lines]",
          "3379:   ndpi_str->callback_buffer_size = a;",
          "3381:   NDPI_LOG_DBG2(ndpi_str, \"callback_buffer_size is %u\\n\", ndpi_str->callback_buffer_size);",
          "3384:   ndpi_str->callback_buffer_size_tcp_payload = 0;",
          "3385:   ndpi_str->callback_buffer_size_tcp_no_payload = 0;",
          "3386:   for (a = 0; a < ndpi_str->callback_buffer_size; a++) {",
          "3387:     if((ndpi_str->callback_buffer[a].ndpi_selection_bitmask &",
          "3388:  (NDPI_SELECTION_BITMASK_PROTOCOL_INT_TCP | NDPI_SELECTION_BITMASK_PROTOCOL_INT_TCP_OR_UDP |",
          "3389:   NDPI_SELECTION_BITMASK_PROTOCOL_COMPLETE_TRAFFIC)) != 0) {",
          "3390:       if(_ndpi_debug_callbacks)",
          "3391:  NDPI_LOG_DBG2(ndpi_str, \"callback_buffer_tcp_payload, adding buffer %u as entry %u\\n\", a,",
          "3392:         ndpi_str->callback_buffer_size_tcp_payload);",
          "3394:       memcpy(&ndpi_str->callback_buffer_tcp_payload[ndpi_str->callback_buffer_size_tcp_payload],",
          "3395:       &ndpi_str->callback_buffer[a], sizeof(struct ndpi_call_function_struct));",
          "3396:       ndpi_str->callback_buffer_size_tcp_payload++;",
          "3398:       if((ndpi_str->callback_buffer[a].ndpi_selection_bitmask & NDPI_SELECTION_BITMASK_PROTOCOL_HAS_PAYLOAD) ==",
          "3399:   0) {",
          "3400:  if(_ndpi_debug_callbacks)",
          "3401:    NDPI_LOG_DBG2(",
          "3405:  memcpy(&ndpi_str->callback_buffer_tcp_no_payload[ndpi_str->callback_buffer_size_tcp_no_payload],",
          "3406:         &ndpi_str->callback_buffer[a], sizeof(struct ndpi_call_function_struct));",
          "3407:  ndpi_str->callback_buffer_size_tcp_no_payload++;",
          "3408:       }",
          "3410:   }",
          "3412:   ndpi_str->callback_buffer_size_udp = 0;",
          "3413:   for (a = 0; a < ndpi_str->callback_buffer_size; a++) {",
          "3414:     if((ndpi_str->callback_buffer[a].ndpi_selection_bitmask &",
          "3415:  (NDPI_SELECTION_BITMASK_PROTOCOL_INT_UDP | NDPI_SELECTION_BITMASK_PROTOCOL_INT_TCP_OR_UDP |",
          "3416:   NDPI_SELECTION_BITMASK_PROTOCOL_COMPLETE_TRAFFIC)) != 0) {",
          "3417:       if(_ndpi_debug_callbacks)",
          "3418:  NDPI_LOG_DBG2(ndpi_str, \"callback_buffer_size_udp: adding buffer : %u as entry %u\\n\", a,",
          "3419:         ndpi_str->callback_buffer_size_udp);",
          "3421:       memcpy(&ndpi_str->callback_buffer_udp[ndpi_str->callback_buffer_size_udp], &ndpi_str->callback_buffer[a],",
          "3422:       sizeof(struct ndpi_call_function_struct));",
          "3423:       ndpi_str->callback_buffer_size_udp++;",
          "3425:   }",
          "3427:   ndpi_str->callback_buffer_size_non_tcp_udp = 0;",
          "3428:   for (a = 0; a < ndpi_str->callback_buffer_size; a++) {",
          "3429:     if((ndpi_str->callback_buffer[a].ndpi_selection_bitmask &",
          "3430:  (NDPI_SELECTION_BITMASK_PROTOCOL_INT_TCP | NDPI_SELECTION_BITMASK_PROTOCOL_INT_UDP |",
          "3431:   NDPI_SELECTION_BITMASK_PROTOCOL_INT_TCP_OR_UDP)) == 0 ||",
          "3432:        (ndpi_str->callback_buffer[a].ndpi_selection_bitmask & NDPI_SELECTION_BITMASK_PROTOCOL_COMPLETE_TRAFFIC) !=",
          "3433:        0) {",
          "3434:       if(_ndpi_debug_callbacks)",
          "3435:  NDPI_LOG_DBG2(ndpi_str, \"callback_buffer_non_tcp_udp: adding buffer : %u as entry %u\\n\", a,",
          "3436:         ndpi_str->callback_buffer_size_non_tcp_udp);",
          "3438:       memcpy(&ndpi_str->callback_buffer_non_tcp_udp[ndpi_str->callback_buffer_size_non_tcp_udp],",
          "3439:       &ndpi_str->callback_buffer[a], sizeof(struct ndpi_call_function_struct));",
          "3440:       ndpi_str->callback_buffer_size_non_tcp_udp++;",
          "3442:   }",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "3515: int ndpi_handle_ipv6_extension_headers(struct ndpi_detection_module_struct *ndpi_str, const u_int8_t **l4ptr,",
          "3552: }",
          "3565: }",
          "3567: static u_int8_t ndpi_detection_get_l4_internal(struct ndpi_detection_module_struct *ndpi_str, const u_int8_t *l3,",
          "3568:                                                u_int16_t l3_len, const u_int8_t **l4_return, u_int16_t *l4_len_return,",
          "3572: #ifdef NDPI_DETECTION_SUPPORT_IPV6",
          "3574: #endif",
          "3588: #ifdef NDPI_DETECTION_SUPPORT_IPV6",
          "3594: #endif",
          "3603: #ifdef NDPI_DETECTION_SUPPORT_IPV6",
          "3608: #endif",
          "3622: #ifdef NDPI_DETECTION_SUPPORT_IPV6",
          "3633:     }",
          "3634: #endif",
          "3652: }",
          "3658: }",
          "3660: static int ndpi_init_packet_header(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,",
          "3680: #ifdef NDPI_DETECTION_SUPPORT_IPV6",
          "3688: #ifdef NDPI_DETECTION_SUPPORT_IPV6",
          "3694: #ifdef NDPI_DETECTION_SUPPORT_IPV6",
          "3701: #ifdef NDPI_DETECTION_SUPPORT_IPV6",
          "3708: #endif",
          "3792:     } else {",
          "3794:     }",
          "3797: }",
          "3807: #ifdef NDPI_DETECTION_SUPPORT_IPV6",
          "3809: #endif",
          "3821: #ifdef NDPI_DETECTION_SUPPORT_IPV6",
          "3824: #endif",
          "3879:         analyzer which require this info can make use of this info",
          "3889:     actual_payload_len is initialized to payload_packet_len during tcp header parsing itself.",
          "3919:     }",
          "3927:     }",
          "3947:     }",
          "3962:     }",
          "3963: }",
          "4005: }",
          "4007: void check_ndpi_tcp_flow_func(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,",
          "4078: }",
          "4082: void ndpi_check_flow_func(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,",
          "4091: }",
          "4111:     }",
          "4114: }",
          "4118: ndpi_protocol ndpi_detection_giveup(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,",
          "4220:     }",
          "4235:     }",
          "4240:     }",
          "4243: }",
          "4247: void ndpi_process_extra_packet(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,",
          "4248:                                const unsigned char *packet, const unsigned short packetlen,",
          "4285: }",
          "4289: int ndpi_load_ip_category(struct ndpi_detection_module_struct *ndpi_str, const char *ip_address_and_mask,",
          "4317: }",
          "4321: int ndpi_load_hostname_category(struct ndpi_detection_module_struct *ndpi_str, const char *name_to_add,",
          "4334: #if 0",
          "4335:   printf(\"===> %s() Loading %s as %u\\n\", __FUNCTION__, name, category);",
          "4336: #endif",
          "4338: #ifdef HAVE_HYPERSCAN",
          "4351:     }",
          "4352: #else",
          "4373: #endif",
          "4376: }",
          "4381: int ndpi_load_category(struct ndpi_detection_module_struct *ndpi_struct, const char *ip_or_name,",
          "4395: }",
          "4407: #ifdef HAVE_HYPERSCAN",
          "4425: #ifdef DEBUG",
          "4427: #endif",
          "4467:     }",
          "4468: #else",
          "4481: #endif",
          "4492: }",
          "4496: int ndpi_fill_ip_protocol_category(struct ndpi_detection_module_struct *ndpi_str, u_int32_t saddr, u_int32_t daddr,",
          "4524:     }",
          "4529: }",
          "4533: void ndpi_fill_protocol_category(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,",
          "4565:     }",
          "4568: }",
          "4575:     packet->host_line.len = 0, packet->referer_line.ptr = NULL, packet->referer_line.len = 0,",
          "4576:     packet->content_line.ptr = NULL, packet->content_line.len = 0, packet->accept_line.ptr = NULL,",
          "4577:     packet->accept_line.len = 0, packet->user_agent_line.ptr = NULL, packet->user_agent_line.len = 0,",
          "",
          "[Removed Lines]",
          "3516:                                        u_int16_t *l4len, u_int8_t *nxt_hdr)",
          "3517: {",
          "3518:     while ((*nxt_hdr == 0 || *nxt_hdr == 43 || *nxt_hdr == 44 || *nxt_hdr == 60 || *nxt_hdr == 135 || *nxt_hdr == 59)) {",
          "3519:         u_int16_t ehdr_len;",
          "3522:         if (*nxt_hdr == 59) {",
          "3523:             return (1);",
          "3524:         }",
          "3526:         if (*nxt_hdr == 44) {",
          "3527:             if (*l4len < 8) {",
          "3528:                 return (1);",
          "3529:             }",
          "3532:             (*l4ptr) += 8;",
          "3533:             continue;",
          "3534:         }",
          "3537:         if (*l4len < 2) {",
          "3538:             return (1);",
          "3539:         }",
          "3540:         ehdr_len = (*l4ptr)[1];",
          "3541:         ehdr_len *= 8;",
          "3542:         ehdr_len += 8;",
          "3544:         if (*l4len < ehdr_len) {",
          "3545:             return (1);",
          "3546:         }",
          "3549:         (*l4ptr) += ehdr_len;",
          "3550:     }",
          "3551:     return (0);",
          "3555: static u_int8_t ndpi_iph_is_valid_and_not_fragmented(const struct ndpi_iphdr *iph, const u_int16_t ipsize)",
          "3556: {",
          "3558:     if (ipsize < iph->ihl * 4 || ipsize < ntohs(iph->tot_len) || ntohs(iph->tot_len) < iph->ihl * 4 ||",
          "3559:         (iph->frag_off & htons(0x1FFF)) != 0) {",
          "3560:         return (0);",
          "3561:     }",
          "3564:     return (1);",
          "3569:                                                u_int8_t *l4_protocol_return, u_int32_t flags)",
          "3570: {",
          "3571:     const struct ndpi_iphdr *iph = NULL;",
          "3573:     const struct ndpi_ipv6hdr *iph_v6 = NULL;",
          "3575:     u_int16_t l4len = 0;",
          "3576:     const u_int8_t *l4ptr = NULL;",
          "3577:     u_int8_t l4protocol = 0;",
          "3579:     if (l3 == NULL || l3_len < sizeof(struct ndpi_iphdr))",
          "3580:         return (1);",
          "3582:     if ((iph = (const struct ndpi_iphdr *) l3) == NULL)",
          "3583:         return (1);",
          "3585:     if (iph->version == IPVERSION && iph->ihl >= 5) {",
          "3586:         NDPI_LOG_DBG2(ndpi_str, \"ipv4 header\\n\");",
          "3587:     }",
          "3589:     else if (iph->version == 6 && l3_len >= sizeof(struct ndpi_ipv6hdr)) {",
          "3590:         NDPI_LOG_DBG2(ndpi_str, \"ipv6 header\\n\");",
          "3591:         iph_v6 = (const struct ndpi_ipv6hdr *) l3;",
          "3592:         iph = NULL;",
          "3593:     }",
          "3595:     else {",
          "3596:         return (1);",
          "3597:     }",
          "3599:     if ((flags & NDPI_DETECTION_ONLY_IPV6) && iph != NULL) {",
          "3600:         NDPI_LOG_DBG2(ndpi_str, \"ipv4 header found but excluded by flag\\n\");",
          "3601:         return (1);",
          "3602:     }",
          "3604:     else if ((flags & NDPI_DETECTION_ONLY_IPV4) && iph_v6 != NULL) {",
          "3605:         NDPI_LOG_DBG2(ndpi_str, \"ipv6 header found but excluded by flag\\n\");",
          "3606:         return (1);",
          "3607:     }",
          "3610:     if (iph != NULL && ndpi_iph_is_valid_and_not_fragmented(iph, l3_len)) {",
          "3611:         u_int16_t len = ntohs(iph->tot_len);",
          "3612:         u_int16_t hlen = (iph->ihl * 4);",
          "3614:         l4ptr = (((const u_int8_t *) iph) + iph->ihl * 4);",
          "3616:         if (len == 0)",
          "3617:             len = l3_len;",
          "3619:         l4len = (len > hlen) ? (len - hlen) : 0;",
          "3620:         l4protocol = iph->protocol;",
          "3621:     }",
          "3623:     else if (iph_v6 != NULL && (l3_len - sizeof(struct ndpi_ipv6hdr)) >= ntohs(iph_v6->ip6_hdr.ip6_un1_plen)) {",
          "3624:         l4ptr = (((const u_int8_t *) iph_v6) + sizeof(struct ndpi_ipv6hdr));",
          "3625:         l4len = ntohs(iph_v6->ip6_hdr.ip6_un1_plen);",
          "3626:         l4protocol = iph_v6->ip6_hdr.ip6_un1_nxt;",
          "3629:         if (ndpi_handle_ipv6_extension_headers(ndpi_str, &l4ptr, &l4len, &l4protocol) != 0) {",
          "3630:             return (1);",
          "3631:         }",
          "3635:     else {",
          "3636:         return (1);",
          "3637:     }",
          "3639:     if (l4_return != NULL) {",
          "3641:     }",
          "3643:     if (l4_len_return != NULL) {",
          "3645:     }",
          "3647:     if (l4_protocol_return != NULL) {",
          "3649:     }",
          "3651:     return (0);",
          "3654: void ndpi_apply_flow_protocol_to_packet(struct ndpi_flow_struct *flow, struct ndpi_packet_struct *packet)",
          "3655: {",
          "3656:     memcpy(&packet->detected_protocol_stack, &flow->detected_protocol_stack, sizeof(packet->detected_protocol_stack));",
          "3657:     memcpy(&packet->protocol_stack_info, &flow->protocol_stack_info, sizeof(packet->protocol_stack_info));",
          "3661:                                    unsigned short packetlen)",
          "3662: {",
          "3663:     const struct ndpi_iphdr *decaps_iph = NULL;",
          "3664:     u_int16_t l3len;",
          "3665:     u_int16_t l4len;",
          "3666:     const u_int8_t *l4ptr;",
          "3667:     u_int8_t l4protocol;",
          "3668:     u_int8_t l4_result;",
          "3670:     if (!flow)",
          "3671:         return (1);",
          "3674:     flow->packet.payload_packet_len = 0;",
          "3675:     flow->packet.l4_packet_len = 0;",
          "3676:     flow->packet.l3_packet_len = packetlen;",
          "3678:     flow->packet.tcp = NULL, flow->packet.udp = NULL;",
          "3679:     flow->packet.generic_l4_ptr = NULL;",
          "3681:     flow->packet.iphv6 = NULL;",
          "3684:     ndpi_apply_flow_protocol_to_packet(flow, &flow->packet);",
          "3686:     l3len = flow->packet.l3_packet_len;",
          "3689:     if (flow->packet.iph != NULL) {",
          "3692:         decaps_iph = flow->packet.iph;",
          "3695:     }",
          "3698:     if (decaps_iph && decaps_iph->version == IPVERSION && decaps_iph->ihl >= 5) {",
          "3699:         NDPI_LOG_DBG2(ndpi_str, \"ipv4 header\\n\");",
          "3700:     }",
          "3702:     else if (decaps_iph && decaps_iph->version == 6 && l3len >= sizeof(struct ndpi_ipv6hdr) &&",
          "3703:              (ndpi_str->ip_version_limit & NDPI_DETECTION_ONLY_IPV4) == 0) {",
          "3704:         NDPI_LOG_DBG2(ndpi_str, \"ipv6 header\\n\");",
          "3705:         flow->packet.iphv6 = (struct ndpi_ipv6hdr *) flow->packet.iph;",
          "3706:         flow->packet.iph = NULL;",
          "3707:     }",
          "3709:     else {",
          "3710:         flow->packet.iph = NULL;",
          "3711:         return (1);",
          "3712:     }",
          "3720:     l4ptr = NULL;",
          "3721:     l4len = 0;",
          "3722:     l4protocol = 0;",
          "3724:     l4_result =",
          "3725:         ndpi_detection_get_l4_internal(ndpi_str, (const u_int8_t *) decaps_iph, l3len, &l4ptr, &l4len, &l4protocol, 0);",
          "3727:     if (l4_result != 0) {",
          "3728:         return (1);",
          "3729:     }",
          "3731:     flow->packet.l4_protocol = l4protocol;",
          "3732:     flow->packet.l4_packet_len = l4len;",
          "3733:     flow->l4_proto = l4protocol;",
          "3736:     if (l4protocol == IPPROTO_TCP && flow->packet.l4_packet_len >= 20 /* min size of tcp */) {",
          "3738:         flow->packet.tcp = (struct ndpi_tcphdr *) l4ptr;",
          "3739:         if (flow->packet.l4_packet_len >= flow->packet.tcp->doff * 4) {",
          "3740:             flow->packet.payload_packet_len = flow->packet.l4_packet_len - flow->packet.tcp->doff * 4;",
          "3741:             flow->packet.actual_payload_len = flow->packet.payload_packet_len;",
          "3742:             flow->packet.payload = ((u_int8_t *) flow->packet.tcp) + (flow->packet.tcp->doff * 4);",
          "3747:             if (flow->packet.tcp->syn != 0 && flow->packet.tcp->ack == 0 && flow->init_finished != 0 &&",
          "3748:                 flow->detected_protocol_stack[0] == NDPI_PROTOCOL_UNKNOWN) {",
          "3749:                 u_int8_t backup;",
          "3750:                 u_int16_t backup1, backup2;",
          "3752:                 if (flow->http.url) {",
          "3753:                     ndpi_free(flow->http.url);",
          "3754:                     flow->http.url = NULL;",
          "3755:                 }",
          "3756:                 if (flow->http.content_type) {",
          "3757:                     ndpi_free(flow->http.content_type);",
          "3758:                     flow->http.content_type = NULL;",
          "3759:                 }",
          "3760:                 if (flow->http.user_agent) {",
          "3761:                     ndpi_free(flow->http.user_agent);",
          "3762:                     flow->http.user_agent = NULL;",
          "3763:                 }",
          "3764:                 if (flow->kerberos_buf.pktbuf) {",
          "3765:                     ndpi_free(flow->kerberos_buf.pktbuf);",
          "3766:                     flow->kerberos_buf.pktbuf = NULL;",
          "3767:                 }",
          "3768:                 if (flow->l4.tcp.tls.message.buffer) {",
          "3769:                     ndpi_free(flow->l4.tcp.tls.message.buffer);",
          "3770:                     flow->l4.tcp.tls.message.buffer = NULL;",
          "3771:                     flow->l4.tcp.tls.message.buffer_len = flow->l4.tcp.tls.message.buffer_used = 0;",
          "3772:                 }",
          "3774:                 backup = flow->num_processed_pkts;",
          "3775:                 backup1 = flow->guessed_protocol_id;",
          "3776:                 backup2 = flow->guessed_host_protocol_id;",
          "3777:                 memset(flow, 0, sizeof(*(flow)));",
          "3778:                 flow->num_processed_pkts = backup;",
          "3779:                 flow->guessed_protocol_id = backup1;",
          "3780:                 flow->guessed_host_protocol_id = backup2;",
          "3782:                 NDPI_LOG_DBG(ndpi_str, \"tcp syn packet for unknown protocol, reset detection state\\n\");",
          "3783:             }",
          "3784:         } else {",
          "3786:             flow->packet.tcp = NULL;",
          "3787:         }",
          "3788:     } else if (l4protocol == IPPROTO_UDP && flow->packet.l4_packet_len >= 8 /* size of udp */) {",
          "3789:         flow->packet.udp = (struct ndpi_udphdr *) l4ptr;",
          "3790:         flow->packet.payload_packet_len = flow->packet.l4_packet_len - 8;",
          "3791:         flow->packet.payload = ((u_int8_t *) flow->packet.udp) + 8;",
          "3793:         flow->packet.generic_l4_ptr = l4ptr;",
          "3796:     return (0);",
          "3799: void ndpi_connection_tracking(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow)",
          "3800: {",
          "3801:     if (!flow) {",
          "3802:         return;",
          "3803:     } else {",
          "3805:         struct ndpi_packet_struct *packet = &flow->packet;",
          "3806:         const struct ndpi_iphdr *iph = packet->iph;",
          "3808:         const struct ndpi_ipv6hdr *iphv6 = packet->iphv6;",
          "3810:         const struct ndpi_tcphdr *tcph = packet->tcp;",
          "3811:         const struct ndpi_udphdr *udph = flow->packet.udp;",
          "3813:         packet->tcp_retransmission = 0, packet->packet_direction = 0;",
          "3815:         if (ndpi_str->direction_detect_disable) {",
          "3816:             packet->packet_direction = flow->packet_direction;",
          "3817:         } else {",
          "3818:             if (iph != NULL && ntohl(iph->saddr) < ntohl(iph->daddr))",
          "3819:                 packet->packet_direction = 1;",
          "3822:             if (iphv6 != NULL && NDPI_COMPARE_IPV6_ADDRESS_STRUCTS(&iphv6->ip6_src, &iphv6->ip6_dst) != 0)",
          "3823:                 packet->packet_direction = 1;",
          "3825:         }",
          "3827:         packet->packet_lines_parsed_complete = 0;",
          "3829:         if (flow->init_finished == 0) {",
          "3830:             flow->init_finished = 1;",
          "3831:             flow->setup_packet_direction = packet->packet_direction;",
          "3832:         }",
          "3834:         if (tcph != NULL) {",
          "3836:             packet->num_retried_bytes = 0;",
          "3838:             if (!ndpi_str->direction_detect_disable)",
          "3839:                 packet->packet_direction = (ntohs(tcph->source) < ntohs(tcph->dest)) ? 1 : 0;",
          "3841:             if (tcph->syn != 0 && tcph->ack == 0 && flow->l4.tcp.seen_syn == 0 && flow->l4.tcp.seen_syn_ack == 0 &&",
          "3842:                 flow->l4.tcp.seen_ack == 0) {",
          "3843:                 flow->l4.tcp.seen_syn = 1;",
          "3844:             }",
          "3845:             if (tcph->syn != 0 && tcph->ack != 0 && flow->l4.tcp.seen_syn == 1 && flow->l4.tcp.seen_syn_ack == 0 &&",
          "3846:                 flow->l4.tcp.seen_ack == 0) {",
          "3847:                 flow->l4.tcp.seen_syn_ack = 1;",
          "3848:             }",
          "3849:             if (tcph->syn == 0 && tcph->ack == 1 && flow->l4.tcp.seen_syn == 1 && flow->l4.tcp.seen_syn_ack == 1 &&",
          "3850:                 flow->l4.tcp.seen_ack == 0) {",
          "3851:                 flow->l4.tcp.seen_ack = 1;",
          "3852:             }",
          "3853:             if ((flow->next_tcp_seq_nr[0] == 0 && flow->next_tcp_seq_nr[1] == 0) ||",
          "3854:                 (flow->next_tcp_seq_nr[0] == 0 || flow->next_tcp_seq_nr[1] == 0)) {",
          "3863:                 if (tcph->ack != 0) {",
          "3864:                     flow->next_tcp_seq_nr[flow->packet.packet_direction] =",
          "3865:                         ntohl(tcph->seq) + (tcph->syn ? 1 : packet->payload_packet_len);",
          "3867:                     flow->next_tcp_seq_nr[1 - flow->packet.packet_direction] = ntohl(tcph->ack_seq);",
          "3868:                 }",
          "3869:             } else if (packet->payload_packet_len > 0) {",
          "3871:                 if (((u_int32_t)(ntohl(tcph->seq) - flow->next_tcp_seq_nr[packet->packet_direction])) >",
          "3872:                     ndpi_str->tcp_max_retransmission_window_size) {",
          "3873:                     packet->tcp_retransmission = 1;",
          "3876:                     if ((flow->next_tcp_seq_nr[packet->packet_direction] - ntohl(tcph->seq) <",
          "3877:                          packet->payload_packet_len)) {",
          "3881:                         packet->num_retried_bytes =",
          "3882:                             (u_int16_t)(flow->next_tcp_seq_nr[packet->packet_direction] - ntohl(tcph->seq));",
          "3883:                         packet->actual_payload_len = packet->payload_packet_len - packet->num_retried_bytes;",
          "3884:                         flow->next_tcp_seq_nr[packet->packet_direction] = ntohl(tcph->seq) + packet->payload_packet_len;",
          "3885:                     }",
          "3886:                 }",
          "3891:                 else {",
          "3892:                     packet->num_retried_bytes = 0;",
          "3893:                     flow->next_tcp_seq_nr[packet->packet_direction] = ntohl(tcph->seq) + packet->payload_packet_len;",
          "3894:                 }",
          "3895:             }",
          "3897:             if (tcph->rst) {",
          "3898:                 flow->next_tcp_seq_nr[0] = 0;",
          "3899:                 flow->next_tcp_seq_nr[1] = 0;",
          "3900:             }",
          "3901:         } else if (udph != NULL) {",
          "3902:             if (!ndpi_str->direction_detect_disable)",
          "3903:                 packet->packet_direction = (htons(udph->source) < htons(udph->dest)) ? 1 : 0;",
          "3904:         }",
          "3906:         if (flow->packet_counter < MAX_PACKET_COUNTER && packet->payload_packet_len) {",
          "3907:             flow->packet_counter++;",
          "3908:         }",
          "3910:         if (flow->packet_direction_counter[packet->packet_direction] < MAX_PACKET_COUNTER &&",
          "3911:             packet->payload_packet_len) {",
          "3912:             flow->packet_direction_counter[packet->packet_direction]++;",
          "3913:         }",
          "3915:         if (flow->byte_counter[packet->packet_direction] + packet->payload_packet_len >",
          "3916:             flow->byte_counter[packet->packet_direction]) {",
          "3917:             flow->byte_counter[packet->packet_direction] += packet->payload_packet_len;",
          "3918:         }",
          "3920: }",
          "3922: void check_ndpi_other_flow_func(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,",
          "3923:                                 NDPI_SELECTION_BITMASK_PROTOCOL_SIZE *ndpi_selection_packet)",
          "3924: {",
          "3925:     if (!flow) {",
          "3926:         return;",
          "3929:     void *func = NULL;",
          "3930:     u_int32_t a;",
          "3931:     u_int16_t proto_index = ndpi_str->proto_defaults[flow->guessed_protocol_id].protoIdx;",
          "3932:     int16_t proto_id = ndpi_str->proto_defaults[flow->guessed_protocol_id].protoId;",
          "3933:     NDPI_PROTOCOL_BITMASK detection_bitmask;",
          "3935:     NDPI_SAVE_AS_BITMASK(detection_bitmask, flow->packet.detected_protocol_stack[0]);",
          "3937:     if ((proto_id != NDPI_PROTOCOL_UNKNOWN) &&",
          "3938:         NDPI_BITMASK_COMPARE(flow->excluded_protocol_bitmask,",
          "3939:                              ndpi_str->callback_buffer[proto_index].excluded_protocol_bitmask) == 0 &&",
          "3940:         NDPI_BITMASK_COMPARE(ndpi_str->callback_buffer[proto_index].detection_bitmask, detection_bitmask) != 0 &&",
          "3941:         (ndpi_str->callback_buffer[proto_index].ndpi_selection_bitmask & *ndpi_selection_packet) ==",
          "3942:             ndpi_str->callback_buffer[proto_index].ndpi_selection_bitmask) {",
          "3943:         if ((flow->guessed_protocol_id != NDPI_PROTOCOL_UNKNOWN) &&",
          "3944:             (ndpi_str->proto_defaults[flow->guessed_protocol_id].func != NULL))",
          "3945:             ndpi_str->proto_defaults[flow->guessed_protocol_id].func(ndpi_str, flow),",
          "3946:                 func = ndpi_str->proto_defaults[flow->guessed_protocol_id].func;",
          "3949:     for (a = 0; a < ndpi_str->callback_buffer_size_non_tcp_udp; a++) {",
          "3950:         if ((func != ndpi_str->callback_buffer_non_tcp_udp[a].func) &&",
          "3951:             (ndpi_str->callback_buffer_non_tcp_udp[a].ndpi_selection_bitmask & *ndpi_selection_packet) ==",
          "3952:                 ndpi_str->callback_buffer_non_tcp_udp[a].ndpi_selection_bitmask &&",
          "3953:             NDPI_BITMASK_COMPARE(flow->excluded_protocol_bitmask,",
          "3954:                                  ndpi_str->callback_buffer_non_tcp_udp[a].excluded_protocol_bitmask) == 0 &&",
          "3955:             NDPI_BITMASK_COMPARE(ndpi_str->callback_buffer_non_tcp_udp[a].detection_bitmask, detection_bitmask) != 0) {",
          "3956:             if (ndpi_str->callback_buffer_non_tcp_udp[a].func != NULL)",
          "3957:                 ndpi_str->callback_buffer_non_tcp_udp[a].func(ndpi_str, flow);",
          "3959:             if (flow->detected_protocol_stack[0] != NDPI_PROTOCOL_UNKNOWN)",
          "3961:         }",
          "3965: void check_ndpi_udp_flow_func(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,",
          "3966:                               NDPI_SELECTION_BITMASK_PROTOCOL_SIZE *ndpi_selection_packet)",
          "3967: {",
          "3968:     void *func = NULL;",
          "3969:     u_int32_t a;",
          "3970:     u_int16_t proto_index = ndpi_str->proto_defaults[flow->guessed_protocol_id].protoIdx;",
          "3971:     int16_t proto_id = ndpi_str->proto_defaults[flow->guessed_protocol_id].protoId;",
          "3972:     NDPI_PROTOCOL_BITMASK detection_bitmask;",
          "3974:     NDPI_SAVE_AS_BITMASK(detection_bitmask, flow->packet.detected_protocol_stack[0]);",
          "3976:     if ((proto_id != NDPI_PROTOCOL_UNKNOWN) &&",
          "3977:         NDPI_BITMASK_COMPARE(flow->excluded_protocol_bitmask,",
          "3978:                              ndpi_str->callback_buffer[proto_index].excluded_protocol_bitmask) == 0 &&",
          "3979:         NDPI_BITMASK_COMPARE(ndpi_str->callback_buffer[proto_index].detection_bitmask, detection_bitmask) != 0 &&",
          "3980:         (ndpi_str->callback_buffer[proto_index].ndpi_selection_bitmask & *ndpi_selection_packet) ==",
          "3981:             ndpi_str->callback_buffer[proto_index].ndpi_selection_bitmask) {",
          "3982:         if ((flow->guessed_protocol_id != NDPI_PROTOCOL_UNKNOWN) &&",
          "3983:             (ndpi_str->proto_defaults[flow->guessed_protocol_id].func != NULL))",
          "3984:             ndpi_str->proto_defaults[flow->guessed_protocol_id].func(ndpi_str, flow),",
          "3985:                 func = ndpi_str->proto_defaults[flow->guessed_protocol_id].func;",
          "3986:     }",
          "3988:     if (flow->detected_protocol_stack[0] == NDPI_PROTOCOL_UNKNOWN) {",
          "3989:         for (a = 0; a < ndpi_str->callback_buffer_size_udp; a++) {",
          "3990:             if ((func != ndpi_str->callback_buffer_udp[a].func) &&",
          "3991:                 (ndpi_str->callback_buffer_udp[a].ndpi_selection_bitmask & *ndpi_selection_packet) ==",
          "3992:                     ndpi_str->callback_buffer_udp[a].ndpi_selection_bitmask &&",
          "3993:                 NDPI_BITMASK_COMPARE(flow->excluded_protocol_bitmask,",
          "3994:                                      ndpi_str->callback_buffer_udp[a].excluded_protocol_bitmask) == 0 &&",
          "3995:                 NDPI_BITMASK_COMPARE(ndpi_str->callback_buffer_udp[a].detection_bitmask, detection_bitmask) != 0) {",
          "3996:                 ndpi_str->callback_buffer_udp[a].func(ndpi_str, flow);",
          "3999:                 if (flow->detected_protocol_stack[0] != NDPI_PROTOCOL_UNKNOWN)",
          "4001:             } else if (_ndpi_debug_callbacks)",
          "4002:                 NDPI_LOG_DBG2(ndpi_str, \"[UDP,SKIP] dissector of protocol as callback_buffer idx =  %d\\n\", a);",
          "4003:         }",
          "4004:     }",
          "4008:                               NDPI_SELECTION_BITMASK_PROTOCOL_SIZE *ndpi_selection_packet)",
          "4009: {",
          "4010:     void *func = NULL;",
          "4011:     u_int32_t a;",
          "4012:     u_int16_t proto_index = ndpi_str->proto_defaults[flow->guessed_protocol_id].protoIdx;",
          "4013:     int16_t proto_id = ndpi_str->proto_defaults[flow->guessed_protocol_id].protoId;",
          "4014:     NDPI_PROTOCOL_BITMASK detection_bitmask;",
          "4016:     NDPI_SAVE_AS_BITMASK(detection_bitmask, flow->packet.detected_protocol_stack[0]);",
          "4018:     if (flow->packet.payload_packet_len != 0) {",
          "4019:         if ((proto_id != NDPI_PROTOCOL_UNKNOWN) &&",
          "4020:             NDPI_BITMASK_COMPARE(flow->excluded_protocol_bitmask,",
          "4021:                                  ndpi_str->callback_buffer[proto_index].excluded_protocol_bitmask) == 0 &&",
          "4022:             NDPI_BITMASK_COMPARE(ndpi_str->callback_buffer[proto_index].detection_bitmask, detection_bitmask) != 0 &&",
          "4023:             (ndpi_str->callback_buffer[proto_index].ndpi_selection_bitmask & *ndpi_selection_packet) ==",
          "4024:                 ndpi_str->callback_buffer[proto_index].ndpi_selection_bitmask) {",
          "4025:             if ((flow->guessed_protocol_id != NDPI_PROTOCOL_UNKNOWN) &&",
          "4026:                 (ndpi_str->proto_defaults[flow->guessed_protocol_id].func != NULL))",
          "4027:                 ndpi_str->proto_defaults[flow->guessed_protocol_id].func(ndpi_str, flow),",
          "4028:                     func = ndpi_str->proto_defaults[flow->guessed_protocol_id].func;",
          "4029:         }",
          "4031:         if (flow->detected_protocol_stack[0] == NDPI_PROTOCOL_UNKNOWN) {",
          "4032:             for (a = 0; a < ndpi_str->callback_buffer_size_tcp_payload; a++) {",
          "4033:                 if ((func != ndpi_str->callback_buffer_tcp_payload[a].func) &&",
          "4034:                     (ndpi_str->callback_buffer_tcp_payload[a].ndpi_selection_bitmask & *ndpi_selection_packet) ==",
          "4035:                         ndpi_str->callback_buffer_tcp_payload[a].ndpi_selection_bitmask &&",
          "4036:                     NDPI_BITMASK_COMPARE(flow->excluded_protocol_bitmask,",
          "4037:                                          ndpi_str->callback_buffer_tcp_payload[a].excluded_protocol_bitmask) == 0 &&",
          "4038:                     NDPI_BITMASK_COMPARE(ndpi_str->callback_buffer_tcp_payload[a].detection_bitmask,",
          "4039:                                          detection_bitmask) != 0) {",
          "4040:                     ndpi_str->callback_buffer_tcp_payload[a].func(ndpi_str, flow);",
          "4042:                     if (flow->detected_protocol_stack[0] != NDPI_PROTOCOL_UNKNOWN)",
          "4044:                 }",
          "4045:             }",
          "4046:         }",
          "4047:     } else {",
          "4049:         if ((proto_id != NDPI_PROTOCOL_UNKNOWN) &&",
          "4050:             NDPI_BITMASK_COMPARE(flow->excluded_protocol_bitmask,",
          "4051:                                  ndpi_str->callback_buffer[proto_index].excluded_protocol_bitmask) == 0 &&",
          "4052:             NDPI_BITMASK_COMPARE(ndpi_str->callback_buffer[proto_index].detection_bitmask, detection_bitmask) != 0 &&",
          "4053:             (ndpi_str->callback_buffer[proto_index].ndpi_selection_bitmask & *ndpi_selection_packet) ==",
          "4054:                 ndpi_str->callback_buffer[proto_index].ndpi_selection_bitmask) {",
          "4055:             if ((flow->guessed_protocol_id != NDPI_PROTOCOL_UNKNOWN) &&",
          "4056:                 (ndpi_str->proto_defaults[flow->guessed_protocol_id].func != NULL) &&",
          "4057:                 ((ndpi_str->callback_buffer[flow->guessed_protocol_id].ndpi_selection_bitmask &",
          "4058:                   NDPI_SELECTION_BITMASK_PROTOCOL_HAS_PAYLOAD) == 0))",
          "4059:                 ndpi_str->proto_defaults[flow->guessed_protocol_id].func(ndpi_str, flow),",
          "4060:                     func = ndpi_str->proto_defaults[flow->guessed_protocol_id].func;",
          "4061:         }",
          "4063:         for (a = 0; a < ndpi_str->callback_buffer_size_tcp_no_payload; a++) {",
          "4064:             if ((func != ndpi_str->callback_buffer_tcp_payload[a].func) &&",
          "4065:                 (ndpi_str->callback_buffer_tcp_no_payload[a].ndpi_selection_bitmask & *ndpi_selection_packet) ==",
          "4066:                     ndpi_str->callback_buffer_tcp_no_payload[a].ndpi_selection_bitmask &&",
          "4067:                 NDPI_BITMASK_COMPARE(flow->excluded_protocol_bitmask,",
          "4068:                                      ndpi_str->callback_buffer_tcp_no_payload[a].excluded_protocol_bitmask) == 0 &&",
          "4069:                 NDPI_BITMASK_COMPARE(ndpi_str->callback_buffer_tcp_no_payload[a].detection_bitmask,",
          "4070:                                      detection_bitmask) != 0) {",
          "4071:                 ndpi_str->callback_buffer_tcp_no_payload[a].func(ndpi_str, flow);",
          "4073:                 if (flow->detected_protocol_stack[0] != NDPI_PROTOCOL_UNKNOWN)",
          "4075:             }",
          "4076:         }",
          "4077:     }",
          "4083:                           NDPI_SELECTION_BITMASK_PROTOCOL_SIZE *ndpi_selection_packet)",
          "4084: {",
          "4085:     if (flow->packet.tcp != NULL)",
          "4086:         check_ndpi_tcp_flow_func(ndpi_str, flow, ndpi_selection_packet);",
          "4087:     else if (flow->packet.udp != NULL)",
          "4088:         check_ndpi_udp_flow_func(ndpi_str, flow, ndpi_selection_packet);",
          "4089:     else",
          "4090:         check_ndpi_other_flow_func(ndpi_str, flow, ndpi_selection_packet);",
          "4095: u_int16_t ndpi_guess_host_protocol_id(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow)",
          "4096: {",
          "4097:     u_int16_t ret = NDPI_PROTOCOL_UNKNOWN;",
          "4099:     if (flow->packet.iph) {",
          "4100:         struct in_addr addr;",
          "4102:         addr.s_addr = flow->packet.iph->saddr;",
          "4105:         ret = ndpi_network_ptree_match(ndpi_str, &addr);",
          "4107:         if (ret == NDPI_PROTOCOL_UNKNOWN) {",
          "4108:             addr.s_addr = flow->packet.iph->daddr;",
          "4109:             ret = ndpi_network_ptree_match(ndpi_str, &addr);",
          "4110:         }",
          "4113:     return (ret);",
          "4119:                                     u_int8_t enable_guess, u_int8_t *protocol_was_guessed)",
          "4120: {",
          "4121:     ndpi_protocol ret = {NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED};",
          "4125:     if (flow == NULL)",
          "4126:         return (ret);",
          "4129:     ret.master_protocol = flow->detected_protocol_stack[1], ret.app_protocol = flow->detected_protocol_stack[0];",
          "4130:     ret.category = flow->category;",
          "4133:     if ((ret.master_protocol != NDPI_PROTOCOL_UNKNOWN) && (ret.app_protocol != NDPI_PROTOCOL_UNKNOWN))",
          "4134:         return (ret);",
          "4137:     if (flow->detected_protocol_stack[0] == NDPI_PROTOCOL_UNKNOWN) {",
          "4138:         u_int16_t guessed_protocol_id = NDPI_PROTOCOL_UNKNOWN, guessed_host_protocol_id = NDPI_PROTOCOL_UNKNOWN;",
          "4140:         if (flow->guessed_protocol_id == NDPI_PROTOCOL_STUN)",
          "4141:             goto check_stun_export;",
          "4142:         else if ((flow->guessed_protocol_id == NDPI_PROTOCOL_HANGOUT_DUO) ||",
          "4143:                  (flow->guessed_protocol_id == NDPI_PROTOCOL_MESSENGER) ||",
          "4144:                  (flow->guessed_protocol_id == NDPI_PROTOCOL_WHATSAPP_CALL)) {",
          "4146:             ndpi_set_detected_protocol(ndpi_str, flow, flow->guessed_protocol_id, NDPI_PROTOCOL_UNKNOWN);",
          "4147:         }",
          "4148:         else if ((flow->l4.tcp.tls.hello_processed == 1) &&",
          "4149:                  (flow->protos.stun_ssl.ssl.client_requested_server_name[0] != '\\0')) {",
          "4151:             ndpi_set_detected_protocol(ndpi_str, flow, NDPI_PROTOCOL_TLS, NDPI_PROTOCOL_UNKNOWN);",
          "4152:         } else if (enable_guess) {",
          "4153:             if ((flow->guessed_protocol_id == NDPI_PROTOCOL_UNKNOWN) && (flow->packet.l4_protocol == IPPROTO_TCP) &&",
          "4154:                 flow->l4.tcp.tls.hello_processed)",
          "4155:                 flow->guessed_protocol_id = NDPI_PROTOCOL_TLS;",
          "4157:             guessed_protocol_id = flow->guessed_protocol_id, guessed_host_protocol_id = flow->guessed_host_protocol_id;",
          "4159:             if ((guessed_host_protocol_id != NDPI_PROTOCOL_UNKNOWN) &&",
          "4160:                 ((flow->packet.l4_protocol == IPPROTO_UDP) &&",
          "4161:                  NDPI_ISSET(&flow->excluded_protocol_bitmask, guessed_host_protocol_id) &&",
          "4162:                  is_udp_guessable_protocol(guessed_host_protocol_id)))",
          "4163:                 flow->guessed_host_protocol_id = guessed_host_protocol_id = NDPI_PROTOCOL_UNKNOWN;",
          "4166:             if ((guessed_protocol_id != NDPI_PROTOCOL_UNKNOWN)",
          "4168:                 && (flow->packet.l4_protocol == IPPROTO_UDP) &&",
          "4169:                 NDPI_ISSET(&flow->excluded_protocol_bitmask, guessed_protocol_id) &&",
          "4170:                 is_udp_guessable_protocol(guessed_protocol_id))",
          "4171:                 flow->guessed_protocol_id = guessed_protocol_id = NDPI_PROTOCOL_UNKNOWN;",
          "4173:             if ((guessed_protocol_id != NDPI_PROTOCOL_UNKNOWN) || (guessed_host_protocol_id != NDPI_PROTOCOL_UNKNOWN)) {",
          "4174:                 if ((guessed_protocol_id == 0) && (flow->protos.stun_ssl.stun.num_binding_requests > 0) &&",
          "4175:                     (flow->protos.stun_ssl.stun.num_processed_pkts > 0))",
          "4176:                     guessed_protocol_id = NDPI_PROTOCOL_STUN;",
          "4178:                 if (flow->host_server_name[0] != '\\0') {",
          "4179:                     ndpi_protocol_match_result ret_match;",
          "4181:                     memset(&ret_match, 0, sizeof(ret_match));",
          "4183:                     ndpi_match_host_subprotocol(ndpi_str, flow, (char *) flow->host_server_name,",
          "4184:                                                 strlen((const char *) flow->host_server_name), &ret_match,",
          "4185:                                                 NDPI_PROTOCOL_DNS);",
          "4187:                     if (ret_match.protocol_id != NDPI_PROTOCOL_UNKNOWN)",
          "4188:                         guessed_host_protocol_id = ret_match.protocol_id;",
          "4189:                 }",
          "4192:                 ndpi_int_change_protocol(ndpi_str, flow, guessed_host_protocol_id, guessed_protocol_id);",
          "4193:             }",
          "4194:         }",
          "4195:     } else if (enable_guess) {",
          "4196:         if (flow->guessed_protocol_id != NDPI_PROTOCOL_UNKNOWN) {",
          "4198:             flow->detected_protocol_stack[1] = flow->guessed_protocol_id;",
          "4199:         }",
          "4201:         if (flow->guessed_host_protocol_id != NDPI_PROTOCOL_UNKNOWN) {",
          "4203:             flow->detected_protocol_stack[0] = flow->guessed_host_protocol_id;",
          "4204:         }",
          "4206:         if (flow->detected_protocol_stack[1] == flow->detected_protocol_stack[0]) {",
          "4208:             flow->detected_protocol_stack[1] = flow->guessed_host_protocol_id;",
          "4209:         }",
          "4210:     }",
          "4212:     if ((flow->detected_protocol_stack[0] == NDPI_PROTOCOL_UNKNOWN) &&",
          "4213:         (flow->guessed_protocol_id == NDPI_PROTOCOL_STUN)) {",
          "4214:     check_stun_export:",
          "4215:         if (flow->protos.stun_ssl.stun.num_processed_pkts || flow->protos.stun_ssl.stun.num_udp_pkts) {",
          "4218:             ndpi_set_detected_protocol(ndpi_str, flow, flow->guessed_host_protocol_id, NDPI_PROTOCOL_STUN);",
          "4219:         }",
          "4222:     ret.master_protocol = flow->detected_protocol_stack[1], ret.app_protocol = flow->detected_protocol_stack[0];",
          "4224:     if (ret.master_protocol == NDPI_PROTOCOL_STUN) {",
          "4225:         if (ret.app_protocol == NDPI_PROTOCOL_FACEBOOK)",
          "4226:             ret.app_protocol = NDPI_PROTOCOL_MESSENGER;",
          "4227:         else if (ret.app_protocol == NDPI_PROTOCOL_GOOGLE) {",
          "4229:             As Google has recently introduced Duo,",
          "4230:             we need to distinguish between it and hangout",
          "4231:             thing that should be handled by the STUN dissector",
          "4233:             ret.app_protocol = NDPI_PROTOCOL_HANGOUT_DUO;",
          "4234:         }",
          "4237:     if (ret.app_protocol != NDPI_PROTOCOL_UNKNOWN) {",
          "4239:         ndpi_fill_protocol_category(ndpi_str, flow, &ret);",
          "4242:     return (ret);",
          "4249:                                const u_int64_t current_tick_l, struct ndpi_id_struct *src, struct ndpi_id_struct *dst)",
          "4250: {",
          "4251:     if (flow == NULL)",
          "4252:         return;",
          "4254:     if (flow->server_id == NULL)",
          "4258:     if (packetlen < 20) {",
          "4259:         return;",
          "4260:     }",
          "4262:     flow->packet.tick_timestamp_l = current_tick_l;",
          "4263:     flow->packet.tick_timestamp = (u_int32_t)(current_tick_l / ndpi_str->ticks_per_second);",
          "4266:     flow->packet.iph = (struct ndpi_iphdr *) packet;",
          "4270:     if (ndpi_init_packet_header(ndpi_str, flow, packetlen) != 0)",
          "4271:         return;",
          "4274:     flow->src = src, flow->dst = dst;",
          "4275:     ndpi_connection_tracking(ndpi_str, flow);",
          "4278:     if (flow->extra_packets_func) {",
          "4279:         if ((flow->extra_packets_func(ndpi_str, flow)) == 0)",
          "4280:             flow->check_extra_packets = 0;",
          "4282:         if (++flow->num_extra_packets_checked == flow->max_extra_packets_to_check)",
          "4284:     }",
          "4290:                           ndpi_protocol_category_t category)",
          "4291: {",
          "4292:     patricia_node_t *node;",
          "4293:     struct in_addr pin;",
          "4294:     int bits = 32;",
          "4295:     char *ptr;",
          "4296:     char ipbuf[64];",
          "4298:     strncpy(ipbuf, ip_address_and_mask, sizeof(ipbuf));",
          "4299:     ipbuf[sizeof(ipbuf) - 1] = '\\0';",
          "4301:     ptr = strrchr(ipbuf, '/');",
          "4303:     if (ptr) {",
          "4305:         if (atoi(ptr) >= 0 && atoi(ptr) <= 32)",
          "4306:             bits = atoi(ptr);",
          "4307:     }",
          "4309:     if (inet_pton(AF_INET, ipbuf, &pin) != 1) {",
          "4310:         NDPI_LOG_DBG2(ndpi_str, \"Invalid ip/ip+netmask: %s\\n\", ip_address_and_mask);",
          "4311:         return (-1);",
          "4312:     }",
          "4314:     if ((node = add_to_ptree(ndpi_str->custom_categories.ipAddresses_shadow, AF_INET, &pin, bits)) != NULL)",
          "4315:         node->value.user_value = (int) category;",
          "4316:     return (0);",
          "4322:                                 ndpi_protocol_category_t category)",
          "4323: {",
          "4324:     char *name;",
          "4326:     if (name_to_add == NULL)",
          "4327:         return (-1);",
          "4329:     name = ndpi_strdup(name_to_add);",
          "4331:     if (name == NULL)",
          "4332:         return (-1);",
          "4339:     {",
          "4340:         struct hs_list *h = (struct hs_list *) ndpi_malloc(sizeof(struct hs_list));",
          "4342:         if (h) {",
          "4343:             h->expression = name, h->id = (unsigned int) category;",
          "4344:             h->next = ndpi_str->custom_categories.to_load;",
          "4345:             ndpi_str->custom_categories.to_load = h;",
          "4346:             ndpi_str->custom_categories.num_to_load++;",
          "4347:         } else {",
          "4348:             free(name);",
          "4349:             return (-1);",
          "4350:         }",
          "4353:     AC_PATTERN_t ac_pattern;",
          "4354:     AC_ERROR_t rc;",
          "4356:     memset(&ac_pattern, 0, sizeof(ac_pattern));",
          "4358:     if (ndpi_str->custom_categories.hostnames_shadow.ac_automa == NULL) {",
          "4359:         free(name);",
          "4360:         return (-1);",
          "4361:     }",
          "4363:     ac_pattern.astring = name, ac_pattern.length = strlen(ac_pattern.astring);",
          "4364:     ac_pattern.rep.number = (int) category;",
          "4366:     rc = ac_automata_add(ndpi_str->custom_categories.hostnames_shadow.ac_automa, &ac_pattern);",
          "4367:     if (rc != ACERR_DUPLICATE_PATTERN && rc != ACERR_SUCCESS) {",
          "4368:         free(name);",
          "4369:         return (-1);",
          "4370:     }",
          "4371:     if (rc == ACERR_DUPLICATE_PATTERN)",
          "4372:         free(name);",
          "4375:     return (0);",
          "4382:                        ndpi_protocol_category_t category)",
          "4383: {",
          "4384:     int rv;",
          "4387:     rv = ndpi_load_ip_category(ndpi_struct, ip_or_name, category);",
          "4389:     if (rv < 0) {",
          "4391:         rv = ndpi_load_hostname_category(ndpi_struct, ip_or_name, category);",
          "4392:     }",
          "4394:     return (rv);",
          "4399: int ndpi_enable_loaded_categories(struct ndpi_detection_module_struct *ndpi_str)",
          "4400: {",
          "4401:     int i;",
          "4404:     for (i = 0; category_match[i].string_to_match != NULL; i++)",
          "4405:         ndpi_load_category(ndpi_str, category_match[i].string_to_match, category_match[i].protocol_category);",
          "4408:     if (ndpi_str->custom_categories.num_to_load > 0) {",
          "4409:         const char **expressions;",
          "4410:         unsigned int *ids;",
          "4411:         int rc;",
          "4412:         struct hs_list *head = ndpi_str->custom_categories.to_load;",
          "4414:         expressions = (const char **) ndpi_calloc(sizeof(char *), ndpi_str->custom_categories.num_to_load + 1);",
          "4415:         if (!expressions)",
          "4416:             return (-1);",
          "4418:         ids = (unsigned int *) ndpi_calloc(sizeof(unsigned int), ndpi_str->custom_categories.num_to_load + 1);",
          "4419:         if (!ids) {",
          "4420:             ndpi_free(expressions);",
          "4421:             return (-1);",
          "4422:         }",
          "4424:         for (i = 0; head != NULL; i++) {",
          "4426:             printf(\"[HS] Loading category %u for %s\\n\", head->id, head->expression);",
          "4428:             expressions[i] = head->expression, ids[i] = head->id;",
          "4429:             head = head->next;",
          "4430:         }",
          "4432:         if (i != ndpi_str->custom_categories.num_to_load) {",
          "4433:             ndpi_free(expressions);",
          "4434:             return (-1);",
          "4435:         }",
          "4437:         free_hyperscan_memory(ndpi_str->custom_categories.hostnames);",
          "4438:         ndpi_str->custom_categories.hostnames = (struct hs *) ndpi_malloc(sizeof(struct hs));",
          "4440:         if (ndpi_str->custom_categories.hostnames == NULL) {",
          "4441:             ndpi_free(expressions);",
          "4442:             ndpi_free(ids);",
          "4444:         }",
          "4446:         rc = hyperscan_load_patterns(ndpi_str->custom_categories.hostnames, ndpi_str->custom_categories.num_to_load,",
          "4447:                                      expressions, ids);",
          "4448:         ndpi_free(expressions), ndpi_free(ids);",
          "4450:         head = ndpi_str->custom_categories.to_load;",
          "4451:         while (head != NULL) {",
          "4452:             struct hs_list *next = head->next;",
          "4454:             ndpi_free(head->expression);",
          "4455:             ndpi_free(head);",
          "4457:             head = next;",
          "4458:         }",
          "4460:         ndpi_str->custom_categories.to_load = NULL;",
          "4461:         ndpi_str->custom_categories.num_to_load = 0;",
          "4463:         if (rc < 0) {",
          "4464:             ndpi_free(ndpi_str->custom_categories.hostnames);",
          "4465:             ndpi_str->custom_categories.hostnames = NULL;",
          "4466:         }",
          "4470:     ac_automata_release((AC_AUTOMATA_t *) ndpi_str->custom_categories.hostnames.ac_automa,",
          "4471:                         1 /* free patterns strings memory */);",
          "4474:     ac_automata_finalize((AC_AUTOMATA_t *) ndpi_str->custom_categories.hostnames_shadow.ac_automa);",
          "4477:     ndpi_str->custom_categories.hostnames.ac_automa = ndpi_str->custom_categories.hostnames_shadow.ac_automa;",
          "4480:     ndpi_str->custom_categories.hostnames_shadow.ac_automa = ac_automata_init(ac_match_handler);",
          "4483:     if (ndpi_str->custom_categories.ipAddresses != NULL)",
          "4484:         ndpi_Destroy_Patricia((patricia_tree_t *) ndpi_str->custom_categories.ipAddresses, free_ptree_data);",
          "4486:     ndpi_str->custom_categories.ipAddresses = ndpi_str->custom_categories.ipAddresses_shadow;",
          "4487:     ndpi_str->custom_categories.ipAddresses_shadow = ndpi_New_Patricia(32 /* IPv4 */);",
          "4489:     ndpi_str->custom_categories.categories_loaded = 1;",
          "4491:     return (0);",
          "4497:                                    ndpi_protocol *ret)",
          "4498: {",
          "4499:     if (ndpi_str->custom_categories.categories_loaded) {",
          "4500:         prefix_t prefix;",
          "4501:         patricia_node_t *node;",
          "4503:         if (saddr == 0)",
          "4504:             node = NULL;",
          "4505:         else {",
          "4507:             fill_prefix_v4(&prefix, (struct in_addr *) &saddr, 32,",
          "4508:                            ((patricia_tree_t *) ndpi_str->protocols_ptree)->maxbits);",
          "4509:             node = ndpi_patricia_search_best(ndpi_str->custom_categories.ipAddresses, &prefix);",
          "4510:         }",
          "4512:         if (!node) {",
          "4513:             if (daddr != 0) {",
          "4514:                 fill_prefix_v4(&prefix, (struct in_addr *) &daddr, 32,",
          "4515:                                ((patricia_tree_t *) ndpi_str->protocols_ptree)->maxbits);",
          "4516:                 node = ndpi_patricia_search_best(ndpi_str->custom_categories.ipAddresses, &prefix);",
          "4517:             }",
          "4518:         }",
          "4520:         if (node) {",
          "4521:             ret->category = (ndpi_protocol_category_t) node->value.user_value;",
          "4522:             return (1);",
          "4523:         }",
          "4526:     ret->category = ndpi_get_proto_category(ndpi_str, *ret);",
          "4528:     return (0);",
          "4534:                                  ndpi_protocol *ret)",
          "4535: {",
          "4536:     if (ndpi_str->custom_categories.categories_loaded) {",
          "4537:         if (flow->guessed_header_category != NDPI_PROTOCOL_CATEGORY_UNSPECIFIED) {",
          "4538:             flow->category = ret->category = flow->guessed_header_category;",
          "4539:             return;",
          "4540:         }",
          "4542:         if (flow->host_server_name[0] != '\\0') {",
          "4543:             unsigned long id;",
          "4544:             int rc = ndpi_match_custom_category(ndpi_str, (char *) flow->host_server_name,",
          "4545:                                                 strlen((char *) flow->host_server_name), &id);",
          "4547:             if (rc == 0) {",
          "4548:                 flow->category = ret->category = (ndpi_protocol_category_t) id;",
          "4549:                 return;",
          "4550:             }",
          "4551:         }",
          "4553:         if (flow->l4.tcp.tls.hello_processed == 1 &&",
          "4554:             flow->protos.stun_ssl.ssl.client_requested_server_name[0] != '\\0') {",
          "4555:             unsigned long id;",
          "4556:             int rc =",
          "4557:                 ndpi_match_custom_category(ndpi_str, (char *) flow->protos.stun_ssl.ssl.client_requested_server_name,",
          "4558:                                            strlen(flow->protos.stun_ssl.ssl.client_requested_server_name), &id);",
          "4560:             if (rc == 0) {",
          "4561:                 flow->category = ret->category = (ndpi_protocol_category_t) id;",
          "4562:                 return;",
          "4563:             }",
          "4564:         }",
          "4567:     flow->category = ret->category = ndpi_get_proto_category(ndpi_str, *ret);",
          "4572: static void ndpi_reset_packet_line_info(struct ndpi_packet_struct *packet)",
          "4573: {",
          "4574:     packet->parsed_lines = 0, packet->empty_line_position_set = 0, packet->host_line.ptr = NULL,",
          "",
          "[Added Lines]",
          "3458:                                        u_int16_t *l4len, u_int8_t *nxt_hdr) {",
          "3459:   while ((*nxt_hdr == 0 || *nxt_hdr == 43 || *nxt_hdr == 44 || *nxt_hdr == 60 || *nxt_hdr == 135 || *nxt_hdr == 59)) {",
          "3460:     u_int16_t ehdr_len;",
          "3463:     if(*nxt_hdr == 59) {",
          "3464:       return(1);",
          "3465:     }",
          "3467:     if(*nxt_hdr == 44) {",
          "3468:       if(*l4len < 8) {",
          "3469:  return(1);",
          "3470:       }",
          "3473:       (*l4ptr) += 8;",
          "3474:       continue;",
          "3475:     }",
          "3478:     if(*l4len < 2) {",
          "3479:       return(1);",
          "3480:     }",
          "3481:     ehdr_len = (*l4ptr)[1];",
          "3482:     ehdr_len *= 8;",
          "3483:     ehdr_len += 8;",
          "3485:     if(*l4len < ehdr_len) {",
          "3486:       return(1);",
          "3487:     }",
          "3490:     (*l4ptr) += ehdr_len;",
          "3491:   }",
          "3492:   return(0);",
          "3496: static u_int8_t ndpi_iph_is_valid_and_not_fragmented(const struct ndpi_iphdr *iph, const u_int16_t ipsize) {",
          "3498:   if(ipsize < iph->ihl * 4 || ipsize < ntohs(iph->tot_len) || ntohs(iph->tot_len) < iph->ihl * 4 ||",
          "3499:      (iph->frag_off & htons(0x1FFF)) != 0) {",
          "3500:     return(0);",
          "3501:   }",
          "3504:   return(1);",
          "3509:                                                u_int8_t *l4_protocol_return, u_int32_t flags) {",
          "3510:   const struct ndpi_iphdr *iph = NULL;",
          "3512:   const struct ndpi_ipv6hdr *iph_v6 = NULL;",
          "3514:   u_int16_t l4len = 0;",
          "3515:   const u_int8_t *l4ptr = NULL;",
          "3516:   u_int8_t l4protocol = 0;",
          "3518:   if(l3 == NULL || l3_len < sizeof(struct ndpi_iphdr))",
          "3519:     return(1);",
          "3521:   if((iph = (const struct ndpi_iphdr *) l3) == NULL)",
          "3522:     return(1);",
          "3524:   if(iph->version == IPVERSION && iph->ihl >= 5) {",
          "3525:     NDPI_LOG_DBG2(ndpi_str, \"ipv4 header\\n\");",
          "3526:   }",
          "3528:   else if(iph->version == 6 && l3_len >= sizeof(struct ndpi_ipv6hdr)) {",
          "3529:     NDPI_LOG_DBG2(ndpi_str, \"ipv6 header\\n\");",
          "3530:     iph_v6 = (const struct ndpi_ipv6hdr *) l3;",
          "3531:     iph = NULL;",
          "3532:   }",
          "3534:   else {",
          "3535:     return(1);",
          "3536:   }",
          "3538:   if((flags & NDPI_DETECTION_ONLY_IPV6) && iph != NULL) {",
          "3539:     NDPI_LOG_DBG2(ndpi_str, \"ipv4 header found but excluded by flag\\n\");",
          "3540:     return(1);",
          "3541:   }",
          "3543:   else if((flags & NDPI_DETECTION_ONLY_IPV4) && iph_v6 != NULL) {",
          "3544:     NDPI_LOG_DBG2(ndpi_str, \"ipv6 header found but excluded by flag\\n\");",
          "3545:     return(1);",
          "3546:   }",
          "3549:   if(iph != NULL && ndpi_iph_is_valid_and_not_fragmented(iph, l3_len)) {",
          "3550:     u_int16_t len = ntohs(iph->tot_len);",
          "3551:     u_int16_t hlen = (iph->ihl * 4);",
          "3553:     l4ptr = (((const u_int8_t *) iph) + iph->ihl * 4);",
          "3555:     if(len == 0)",
          "3556:       len = l3_len;",
          "3558:     l4len = (len > hlen) ? (len - hlen) : 0;",
          "3559:     l4protocol = iph->protocol;",
          "3560:   }",
          "3562:   else if(iph_v6 != NULL && (l3_len - sizeof(struct ndpi_ipv6hdr)) >= ntohs(iph_v6->ip6_hdr.ip6_un1_plen)) {",
          "3563:     l4ptr = (((const u_int8_t *) iph_v6) + sizeof(struct ndpi_ipv6hdr));",
          "3564:     l4len = ntohs(iph_v6->ip6_hdr.ip6_un1_plen);",
          "3565:     l4protocol = iph_v6->ip6_hdr.ip6_un1_nxt;",
          "3568:     if(ndpi_handle_ipv6_extension_headers(ndpi_str, &l4ptr, &l4len, &l4protocol) != 0) {",
          "3569:       return(1);",
          "3572:   }",
          "3574:   else {",
          "3575:     return(1);",
          "3576:   }",
          "3578:   if(l4_return != NULL) {",
          "3580:   }",
          "3582:   if(l4_len_return != NULL) {",
          "3584:   }",
          "3586:   if(l4_protocol_return != NULL) {",
          "3588:   }",
          "3590:   return(0);",
          "3593: void ndpi_apply_flow_protocol_to_packet(struct ndpi_flow_struct *flow, struct ndpi_packet_struct *packet) {",
          "3594:   memcpy(&packet->detected_protocol_stack, &flow->detected_protocol_stack, sizeof(packet->detected_protocol_stack));",
          "3595:   memcpy(&packet->protocol_stack_info, &flow->protocol_stack_info, sizeof(packet->protocol_stack_info));",
          "3599:                                    unsigned short packetlen) {",
          "3600:   const struct ndpi_iphdr *decaps_iph = NULL;",
          "3601:   u_int16_t l3len;",
          "3602:   u_int16_t l4len;",
          "3603:   const u_int8_t *l4ptr;",
          "3604:   u_int8_t l4protocol;",
          "3605:   u_int8_t l4_result;",
          "3607:   if(!flow)",
          "3608:     return(1);",
          "3611:   flow->packet.payload_packet_len = 0;",
          "3612:   flow->packet.l4_packet_len = 0;",
          "3613:   flow->packet.l3_packet_len = packetlen;",
          "3615:   flow->packet.tcp = NULL, flow->packet.udp = NULL;",
          "3616:   flow->packet.generic_l4_ptr = NULL;",
          "3618:   flow->packet.iphv6 = NULL;",
          "3621:   ndpi_apply_flow_protocol_to_packet(flow, &flow->packet);",
          "3623:   l3len = flow->packet.l3_packet_len;",
          "3626:   if(flow->packet.iph != NULL) {",
          "3629:     decaps_iph = flow->packet.iph;",
          "3632:   }",
          "3635:   if(decaps_iph && decaps_iph->version == IPVERSION && decaps_iph->ihl >= 5) {",
          "3636:     NDPI_LOG_DBG2(ndpi_str, \"ipv4 header\\n\");",
          "3637:   }",
          "3639:   else if(decaps_iph && decaps_iph->version == 6 && l3len >= sizeof(struct ndpi_ipv6hdr) &&",
          "3640:    (ndpi_str->ip_version_limit & NDPI_DETECTION_ONLY_IPV4) == 0) {",
          "3641:     NDPI_LOG_DBG2(ndpi_str, \"ipv6 header\\n\");",
          "3642:     flow->packet.iphv6 = (struct ndpi_ipv6hdr *) flow->packet.iph;",
          "3643:     flow->packet.iph = NULL;",
          "3644:   }",
          "3646:   else {",
          "3647:     flow->packet.iph = NULL;",
          "3648:     return(1);",
          "3649:   }",
          "3657:   l4ptr = NULL;",
          "3658:   l4len = 0;",
          "3659:   l4protocol = 0;",
          "3661:   l4_result =",
          "3662:     ndpi_detection_get_l4_internal(ndpi_str, (const u_int8_t *) decaps_iph, l3len, &l4ptr, &l4len, &l4protocol, 0);",
          "3664:   if(l4_result != 0) {",
          "3665:     return(1);",
          "3666:   }",
          "3668:   flow->packet.l4_protocol = l4protocol;",
          "3669:   flow->packet.l4_packet_len = l4len;",
          "3670:   flow->l4_proto = l4protocol;",
          "3673:   if(l4protocol == IPPROTO_TCP && flow->packet.l4_packet_len >= 20 /* min size of tcp */) {",
          "3675:     flow->packet.tcp = (struct ndpi_tcphdr *) l4ptr;",
          "3676:     if(flow->packet.l4_packet_len >= flow->packet.tcp->doff * 4) {",
          "3677:       flow->packet.payload_packet_len = flow->packet.l4_packet_len - flow->packet.tcp->doff * 4;",
          "3678:       flow->packet.actual_payload_len = flow->packet.payload_packet_len;",
          "3679:       flow->packet.payload = ((u_int8_t *) flow->packet.tcp) + (flow->packet.tcp->doff * 4);",
          "3684:       if(flow->packet.tcp->syn != 0 && flow->packet.tcp->ack == 0 && flow->init_finished != 0 &&",
          "3685:   flow->detected_protocol_stack[0] == NDPI_PROTOCOL_UNKNOWN) {",
          "3686:  u_int8_t backup;",
          "3687:  u_int16_t backup1, backup2;",
          "3689:  if(flow->http.url) {",
          "3690:    ndpi_free(flow->http.url);",
          "3691:    flow->http.url = NULL;",
          "3692:  }",
          "3693:  if(flow->http.content_type) {",
          "3694:    ndpi_free(flow->http.content_type);",
          "3695:    flow->http.content_type = NULL;",
          "3696:  }",
          "3697:  if(flow->http.user_agent) {",
          "3698:    ndpi_free(flow->http.user_agent);",
          "3699:    flow->http.user_agent = NULL;",
          "3700:  }",
          "3701:  if(flow->kerberos_buf.pktbuf) {",
          "3702:    ndpi_free(flow->kerberos_buf.pktbuf);",
          "3703:    flow->kerberos_buf.pktbuf = NULL;",
          "3704:  }",
          "3705:  if(flow->l4.tcp.tls.message.buffer) {",
          "3706:    ndpi_free(flow->l4.tcp.tls.message.buffer);",
          "3707:    flow->l4.tcp.tls.message.buffer = NULL;",
          "3708:    flow->l4.tcp.tls.message.buffer_len = flow->l4.tcp.tls.message.buffer_used = 0;",
          "3709:  }",
          "3711:  backup = flow->num_processed_pkts;",
          "3712:  backup1 = flow->guessed_protocol_id;",
          "3713:  backup2 = flow->guessed_host_protocol_id;",
          "3714:  memset(flow, 0, sizeof(*(flow)));",
          "3715:  flow->num_processed_pkts = backup;",
          "3716:  flow->guessed_protocol_id = backup1;",
          "3717:  flow->guessed_host_protocol_id = backup2;",
          "3719:  NDPI_LOG_DBG(ndpi_str, \"tcp syn packet for unknown protocol, reset detection state\\n\");",
          "3720:       }",
          "3723:       flow->packet.tcp = NULL;",
          "3725:   } else if(l4protocol == IPPROTO_UDP && flow->packet.l4_packet_len >= 8 /* size of udp */) {",
          "3726:     flow->packet.udp = (struct ndpi_udphdr *) l4ptr;",
          "3727:     flow->packet.payload_packet_len = flow->packet.l4_packet_len - 8;",
          "3728:     flow->packet.payload = ((u_int8_t *) flow->packet.udp) + 8;",
          "3729:   } else {",
          "3730:     flow->packet.generic_l4_ptr = l4ptr;",
          "3731:   }",
          "3733:   return(0);",
          "3736: void ndpi_connection_tracking(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow) {",
          "3737:   if(!flow) {",
          "3738:     return;",
          "3739:   } else {",
          "3741:     struct ndpi_packet_struct *packet = &flow->packet;",
          "3742:     const struct ndpi_iphdr *iph = packet->iph;",
          "3744:     const struct ndpi_ipv6hdr *iphv6 = packet->iphv6;",
          "3746:     const struct ndpi_tcphdr *tcph = packet->tcp;",
          "3747:     const struct ndpi_udphdr *udph = flow->packet.udp;",
          "3749:     packet->tcp_retransmission = 0, packet->packet_direction = 0;",
          "3751:     if(ndpi_str->direction_detect_disable) {",
          "3752:       packet->packet_direction = flow->packet_direction;",
          "3753:     } else {",
          "3754:       if(iph != NULL && ntohl(iph->saddr) < ntohl(iph->daddr))",
          "3755:  packet->packet_direction = 1;",
          "3758:       if(iphv6 != NULL && NDPI_COMPARE_IPV6_ADDRESS_STRUCTS(&iphv6->ip6_src, &iphv6->ip6_dst) != 0)",
          "3759:  packet->packet_direction = 1;",
          "3761:     }",
          "3763:     packet->packet_lines_parsed_complete = 0;",
          "3765:     if(flow->init_finished == 0) {",
          "3766:       flow->init_finished = 1;",
          "3767:       flow->setup_packet_direction = packet->packet_direction;",
          "3768:     }",
          "3770:     if(tcph != NULL) {",
          "3772:       packet->num_retried_bytes = 0;",
          "3774:       if(!ndpi_str->direction_detect_disable)",
          "3775:  packet->packet_direction = (ntohs(tcph->source) < ntohs(tcph->dest)) ? 1 : 0;",
          "3777:       if(tcph->syn != 0 && tcph->ack == 0 && flow->l4.tcp.seen_syn == 0 && flow->l4.tcp.seen_syn_ack == 0 &&",
          "3778:   flow->l4.tcp.seen_ack == 0) {",
          "3779:  flow->l4.tcp.seen_syn = 1;",
          "3780:       }",
          "3781:       if(tcph->syn != 0 && tcph->ack != 0 && flow->l4.tcp.seen_syn == 1 && flow->l4.tcp.seen_syn_ack == 0 &&",
          "3782:   flow->l4.tcp.seen_ack == 0) {",
          "3783:  flow->l4.tcp.seen_syn_ack = 1;",
          "3784:       }",
          "3785:       if(tcph->syn == 0 && tcph->ack == 1 && flow->l4.tcp.seen_syn == 1 && flow->l4.tcp.seen_syn_ack == 1 &&",
          "3786:   flow->l4.tcp.seen_ack == 0) {",
          "3787:  flow->l4.tcp.seen_ack = 1;",
          "3788:       }",
          "3789:       if((flow->next_tcp_seq_nr[0] == 0 && flow->next_tcp_seq_nr[1] == 0) ||",
          "3790:   (flow->next_tcp_seq_nr[0] == 0 || flow->next_tcp_seq_nr[1] == 0)) {",
          "3799:  if(tcph->ack != 0) {",
          "3800:    flow->next_tcp_seq_nr[flow->packet.packet_direction] =",
          "3801:      ntohl(tcph->seq) + (tcph->syn ? 1 : packet->payload_packet_len);",
          "3803:    flow->next_tcp_seq_nr[1 - flow->packet.packet_direction] = ntohl(tcph->ack_seq);",
          "3804:  }",
          "3805:       } else if(packet->payload_packet_len > 0) {",
          "3807:  if(((u_int32_t)(ntohl(tcph->seq) - flow->next_tcp_seq_nr[packet->packet_direction])) >",
          "3808:     ndpi_str->tcp_max_retransmission_window_size) {",
          "3809:    packet->tcp_retransmission = 1;",
          "3812:    if((flow->next_tcp_seq_nr[packet->packet_direction] - ntohl(tcph->seq) <",
          "3813:        packet->payload_packet_len)) {",
          "3817:      packet->num_retried_bytes =",
          "3818:        (u_int16_t)(flow->next_tcp_seq_nr[packet->packet_direction] - ntohl(tcph->seq));",
          "3819:      packet->actual_payload_len = packet->payload_packet_len - packet->num_retried_bytes;",
          "3820:      flow->next_tcp_seq_nr[packet->packet_direction] = ntohl(tcph->seq) + packet->payload_packet_len;",
          "3821:    }",
          "3822:  }",
          "3827:  else {",
          "3828:    packet->num_retried_bytes = 0;",
          "3829:    flow->next_tcp_seq_nr[packet->packet_direction] = ntohl(tcph->seq) + packet->payload_packet_len;",
          "3830:  }",
          "3831:       }",
          "3833:       if(tcph->rst) {",
          "3834:  flow->next_tcp_seq_nr[0] = 0;",
          "3835:  flow->next_tcp_seq_nr[1] = 0;",
          "3836:       }",
          "3837:     } else if(udph != NULL) {",
          "3838:       if(!ndpi_str->direction_detect_disable)",
          "3839:  packet->packet_direction = (htons(udph->source) < htons(udph->dest)) ? 1 : 0;",
          "3842:     if(flow->packet_counter < MAX_PACKET_COUNTER && packet->payload_packet_len) {",
          "3843:       flow->packet_counter++;",
          "3846:     if(flow->packet_direction_counter[packet->packet_direction] < MAX_PACKET_COUNTER &&",
          "3847:        packet->payload_packet_len) {",
          "3848:       flow->packet_direction_counter[packet->packet_direction]++;",
          "3851:     if(flow->byte_counter[packet->packet_direction] + packet->payload_packet_len >",
          "3852:        flow->byte_counter[packet->packet_direction]) {",
          "3853:       flow->byte_counter[packet->packet_direction] += packet->payload_packet_len;",
          "3855:   }",
          "3858: void check_ndpi_other_flow_func(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,",
          "3859:                                 NDPI_SELECTION_BITMASK_PROTOCOL_SIZE *ndpi_selection_packet) {",
          "3860:   if(!flow) {",
          "3861:     return;",
          "3862:   }",
          "3864:   void *func = NULL;",
          "3865:   u_int32_t a;",
          "3866:   u_int16_t proto_index = ndpi_str->proto_defaults[flow->guessed_protocol_id].protoIdx;",
          "3867:   int16_t proto_id = ndpi_str->proto_defaults[flow->guessed_protocol_id].protoId;",
          "3868:   NDPI_PROTOCOL_BITMASK detection_bitmask;",
          "3870:   NDPI_SAVE_AS_BITMASK(detection_bitmask, flow->packet.detected_protocol_stack[0]);",
          "3872:   if((proto_id != NDPI_PROTOCOL_UNKNOWN) &&",
          "3873:      NDPI_BITMASK_COMPARE(flow->excluded_protocol_bitmask,",
          "3874:      ndpi_str->callback_buffer[proto_index].excluded_protocol_bitmask) == 0 &&",
          "3875:      NDPI_BITMASK_COMPARE(ndpi_str->callback_buffer[proto_index].detection_bitmask, detection_bitmask) != 0 &&",
          "3876:      (ndpi_str->callback_buffer[proto_index].ndpi_selection_bitmask & *ndpi_selection_packet) ==",
          "3877:      ndpi_str->callback_buffer[proto_index].ndpi_selection_bitmask) {",
          "3878:     if((flow->guessed_protocol_id != NDPI_PROTOCOL_UNKNOWN) &&",
          "3879:        (ndpi_str->proto_defaults[flow->guessed_protocol_id].func != NULL))",
          "3880:       ndpi_str->proto_defaults[flow->guessed_protocol_id].func(ndpi_str, flow),",
          "3881:  func = ndpi_str->proto_defaults[flow->guessed_protocol_id].func;",
          "3882:   }",
          "3884:   for (a = 0; a < ndpi_str->callback_buffer_size_non_tcp_udp; a++) {",
          "3885:     if((func != ndpi_str->callback_buffer_non_tcp_udp[a].func) &&",
          "3886:        (ndpi_str->callback_buffer_non_tcp_udp[a].ndpi_selection_bitmask & *ndpi_selection_packet) ==",
          "3887:        ndpi_str->callback_buffer_non_tcp_udp[a].ndpi_selection_bitmask &&",
          "3888:        NDPI_BITMASK_COMPARE(flow->excluded_protocol_bitmask,",
          "3889:        ndpi_str->callback_buffer_non_tcp_udp[a].excluded_protocol_bitmask) == 0 &&",
          "3890:        NDPI_BITMASK_COMPARE(ndpi_str->callback_buffer_non_tcp_udp[a].detection_bitmask, detection_bitmask) != 0) {",
          "3891:       if(ndpi_str->callback_buffer_non_tcp_udp[a].func != NULL)",
          "3892:  ndpi_str->callback_buffer_non_tcp_udp[a].func(ndpi_str, flow);",
          "3894:       if(flow->detected_protocol_stack[0] != NDPI_PROTOCOL_UNKNOWN)",
          "3896:     }",
          "3897:   }",
          "3898: }",
          "3900: void check_ndpi_udp_flow_func(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,",
          "3901:                               NDPI_SELECTION_BITMASK_PROTOCOL_SIZE *ndpi_selection_packet) {",
          "3902:   void *func = NULL;",
          "3903:   u_int32_t a;",
          "3904:   u_int16_t proto_index = ndpi_str->proto_defaults[flow->guessed_protocol_id].protoIdx;",
          "3905:   int16_t proto_id = ndpi_str->proto_defaults[flow->guessed_protocol_id].protoId;",
          "3906:   NDPI_PROTOCOL_BITMASK detection_bitmask;",
          "3908:   NDPI_SAVE_AS_BITMASK(detection_bitmask, flow->packet.detected_protocol_stack[0]);",
          "3910:   if((proto_id != NDPI_PROTOCOL_UNKNOWN) &&",
          "3911:      NDPI_BITMASK_COMPARE(flow->excluded_protocol_bitmask,",
          "3912:      ndpi_str->callback_buffer[proto_index].excluded_protocol_bitmask) == 0 &&",
          "3913:      NDPI_BITMASK_COMPARE(ndpi_str->callback_buffer[proto_index].detection_bitmask, detection_bitmask) != 0 &&",
          "3914:      (ndpi_str->callback_buffer[proto_index].ndpi_selection_bitmask & *ndpi_selection_packet) ==",
          "3915:      ndpi_str->callback_buffer[proto_index].ndpi_selection_bitmask) {",
          "3916:     if((flow->guessed_protocol_id != NDPI_PROTOCOL_UNKNOWN) &&",
          "3917:        (ndpi_str->proto_defaults[flow->guessed_protocol_id].func != NULL))",
          "3918:       ndpi_str->proto_defaults[flow->guessed_protocol_id].func(ndpi_str, flow),",
          "3919:  func = ndpi_str->proto_defaults[flow->guessed_protocol_id].func;",
          "3920:   }",
          "3922:   if(flow->detected_protocol_stack[0] == NDPI_PROTOCOL_UNKNOWN) {",
          "3923:     for (a = 0; a < ndpi_str->callback_buffer_size_udp; a++) {",
          "3924:       if((func != ndpi_str->callback_buffer_udp[a].func) &&",
          "3925:   (ndpi_str->callback_buffer_udp[a].ndpi_selection_bitmask & *ndpi_selection_packet) ==",
          "3926:   ndpi_str->callback_buffer_udp[a].ndpi_selection_bitmask &&",
          "3927:   NDPI_BITMASK_COMPARE(flow->excluded_protocol_bitmask,",
          "3928:          ndpi_str->callback_buffer_udp[a].excluded_protocol_bitmask) == 0 &&",
          "3929:   NDPI_BITMASK_COMPARE(ndpi_str->callback_buffer_udp[a].detection_bitmask, detection_bitmask) != 0) {",
          "3930:  ndpi_str->callback_buffer_udp[a].func(ndpi_str, flow);",
          "3933:  if(flow->detected_protocol_stack[0] != NDPI_PROTOCOL_UNKNOWN)",
          "3935:       } else if(_ndpi_debug_callbacks)",
          "3936:  NDPI_LOG_DBG2(ndpi_str, \"[UDP,SKIP] dissector of protocol as callback_buffer idx =  %d\\n\", a);",
          "3937:     }",
          "3938:   }",
          "3942:                               NDPI_SELECTION_BITMASK_PROTOCOL_SIZE *ndpi_selection_packet) {",
          "3943:   void *func = NULL;",
          "3944:   u_int32_t a;",
          "3945:   u_int16_t proto_index = ndpi_str->proto_defaults[flow->guessed_protocol_id].protoIdx;",
          "3946:   int16_t proto_id = ndpi_str->proto_defaults[flow->guessed_protocol_id].protoId;",
          "3947:   NDPI_PROTOCOL_BITMASK detection_bitmask;",
          "3949:   NDPI_SAVE_AS_BITMASK(detection_bitmask, flow->packet.detected_protocol_stack[0]);",
          "3951:   if(flow->packet.payload_packet_len != 0) {",
          "3952:     if((proto_id != NDPI_PROTOCOL_UNKNOWN) &&",
          "3953:        NDPI_BITMASK_COMPARE(flow->excluded_protocol_bitmask,",
          "3954:        ndpi_str->callback_buffer[proto_index].excluded_protocol_bitmask) == 0 &&",
          "3955:        NDPI_BITMASK_COMPARE(ndpi_str->callback_buffer[proto_index].detection_bitmask, detection_bitmask) != 0 &&",
          "3956:        (ndpi_str->callback_buffer[proto_index].ndpi_selection_bitmask & *ndpi_selection_packet) ==",
          "3957:        ndpi_str->callback_buffer[proto_index].ndpi_selection_bitmask) {",
          "3958:       if((flow->guessed_protocol_id != NDPI_PROTOCOL_UNKNOWN) &&",
          "3959:   (ndpi_str->proto_defaults[flow->guessed_protocol_id].func != NULL))",
          "3960:  ndpi_str->proto_defaults[flow->guessed_protocol_id].func(ndpi_str, flow),",
          "3961:    func = ndpi_str->proto_defaults[flow->guessed_protocol_id].func;",
          "3962:     }",
          "3964:     if(flow->detected_protocol_stack[0] == NDPI_PROTOCOL_UNKNOWN) {",
          "3965:       for (a = 0; a < ndpi_str->callback_buffer_size_tcp_payload; a++) {",
          "3966:  if((func != ndpi_str->callback_buffer_tcp_payload[a].func) &&",
          "3967:     (ndpi_str->callback_buffer_tcp_payload[a].ndpi_selection_bitmask & *ndpi_selection_packet) ==",
          "3968:     ndpi_str->callback_buffer_tcp_payload[a].ndpi_selection_bitmask &&",
          "3969:     NDPI_BITMASK_COMPARE(flow->excluded_protocol_bitmask,",
          "3970:     ndpi_str->callback_buffer_tcp_payload[a].excluded_protocol_bitmask) == 0 &&",
          "3971:     NDPI_BITMASK_COMPARE(ndpi_str->callback_buffer_tcp_payload[a].detection_bitmask,",
          "3972:     detection_bitmask) != 0) {",
          "3973:    ndpi_str->callback_buffer_tcp_payload[a].func(ndpi_str, flow);",
          "3975:    if(flow->detected_protocol_stack[0] != NDPI_PROTOCOL_UNKNOWN)",
          "3977:  }",
          "3978:       }",
          "3979:     }",
          "3980:   } else {",
          "3982:     if((proto_id != NDPI_PROTOCOL_UNKNOWN) &&",
          "3983:        NDPI_BITMASK_COMPARE(flow->excluded_protocol_bitmask,",
          "3984:        ndpi_str->callback_buffer[proto_index].excluded_protocol_bitmask) == 0 &&",
          "3985:        NDPI_BITMASK_COMPARE(ndpi_str->callback_buffer[proto_index].detection_bitmask, detection_bitmask) != 0 &&",
          "3986:        (ndpi_str->callback_buffer[proto_index].ndpi_selection_bitmask & *ndpi_selection_packet) ==",
          "3987:        ndpi_str->callback_buffer[proto_index].ndpi_selection_bitmask) {",
          "3988:       if((flow->guessed_protocol_id != NDPI_PROTOCOL_UNKNOWN) &&",
          "3989:   (ndpi_str->proto_defaults[flow->guessed_protocol_id].func != NULL) &&",
          "3990:   ((ndpi_str->callback_buffer[flow->guessed_protocol_id].ndpi_selection_bitmask &",
          "3991:     NDPI_SELECTION_BITMASK_PROTOCOL_HAS_PAYLOAD) == 0))",
          "3992:  ndpi_str->proto_defaults[flow->guessed_protocol_id].func(ndpi_str, flow),",
          "3993:    func = ndpi_str->proto_defaults[flow->guessed_protocol_id].func;",
          "3994:     }",
          "3996:     for (a = 0; a < ndpi_str->callback_buffer_size_tcp_no_payload; a++) {",
          "3997:       if((func != ndpi_str->callback_buffer_tcp_payload[a].func) &&",
          "3998:   (ndpi_str->callback_buffer_tcp_no_payload[a].ndpi_selection_bitmask & *ndpi_selection_packet) ==",
          "3999:   ndpi_str->callback_buffer_tcp_no_payload[a].ndpi_selection_bitmask &&",
          "4000:   NDPI_BITMASK_COMPARE(flow->excluded_protocol_bitmask,",
          "4001:          ndpi_str->callback_buffer_tcp_no_payload[a].excluded_protocol_bitmask) == 0 &&",
          "4002:   NDPI_BITMASK_COMPARE(ndpi_str->callback_buffer_tcp_no_payload[a].detection_bitmask,",
          "4003:          detection_bitmask) != 0) {",
          "4004:  ndpi_str->callback_buffer_tcp_no_payload[a].func(ndpi_str, flow);",
          "4006:  if(flow->detected_protocol_stack[0] != NDPI_PROTOCOL_UNKNOWN)",
          "4008:       }",
          "4009:     }",
          "4010:   }",
          "4016:                           NDPI_SELECTION_BITMASK_PROTOCOL_SIZE *ndpi_selection_packet) {",
          "4017:   if(flow->packet.tcp != NULL)",
          "4018:     check_ndpi_tcp_flow_func(ndpi_str, flow, ndpi_selection_packet);",
          "4019:   else if(flow->packet.udp != NULL)",
          "4020:     check_ndpi_udp_flow_func(ndpi_str, flow, ndpi_selection_packet);",
          "4021:   else",
          "4022:     check_ndpi_other_flow_func(ndpi_str, flow, ndpi_selection_packet);",
          "4027: u_int16_t ndpi_guess_host_protocol_id(struct ndpi_detection_module_struct *ndpi_str,",
          "4028:           struct ndpi_flow_struct *flow) {",
          "4029:   u_int16_t ret = NDPI_PROTOCOL_UNKNOWN;",
          "4031:   if(flow->packet.iph) {",
          "4032:     struct in_addr addr;",
          "4034:     addr.s_addr = flow->packet.iph->saddr;",
          "4037:     ret = ndpi_network_ptree_match(ndpi_str, &addr);",
          "4039:     if(ret == NDPI_PROTOCOL_UNKNOWN) {",
          "4040:       addr.s_addr = flow->packet.iph->daddr;",
          "4041:       ret = ndpi_network_ptree_match(ndpi_str, &addr);",
          "4043:   }",
          "4045:   return(ret);",
          "4051:                                     u_int8_t enable_guess, u_int8_t *protocol_was_guessed) {",
          "4052:   ndpi_protocol ret = {NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED};",
          "4056:   if(flow == NULL)",
          "4057:     return(ret);",
          "4060:   ret.master_protocol = flow->detected_protocol_stack[1], ret.app_protocol = flow->detected_protocol_stack[0];",
          "4061:   ret.category = flow->category;",
          "4064:   if((ret.master_protocol != NDPI_PROTOCOL_UNKNOWN) && (ret.app_protocol != NDPI_PROTOCOL_UNKNOWN))",
          "4065:     return(ret);",
          "4068:   if(flow->detected_protocol_stack[0] == NDPI_PROTOCOL_UNKNOWN) {",
          "4069:     u_int16_t guessed_protocol_id = NDPI_PROTOCOL_UNKNOWN, guessed_host_protocol_id = NDPI_PROTOCOL_UNKNOWN;",
          "4071:     if(flow->guessed_protocol_id == NDPI_PROTOCOL_STUN)",
          "4072:       goto check_stun_export;",
          "4073:     else if((flow->guessed_protocol_id == NDPI_PROTOCOL_HANGOUT_DUO) ||",
          "4074:      (flow->guessed_protocol_id == NDPI_PROTOCOL_MESSENGER) ||",
          "4075:      (flow->guessed_protocol_id == NDPI_PROTOCOL_WHATSAPP_CALL)) {",
          "4077:       ndpi_set_detected_protocol(ndpi_str, flow, flow->guessed_protocol_id, NDPI_PROTOCOL_UNKNOWN);",
          "4078:     }",
          "4079:     else if((flow->l4.tcp.tls.hello_processed == 1) &&",
          "4080:      (flow->protos.stun_ssl.ssl.client_requested_server_name[0] != '\\0')) {",
          "4082:       ndpi_set_detected_protocol(ndpi_str, flow, NDPI_PROTOCOL_TLS, NDPI_PROTOCOL_UNKNOWN);",
          "4083:     } else if(enable_guess) {",
          "4084:       if((flow->guessed_protocol_id == NDPI_PROTOCOL_UNKNOWN) && (flow->packet.l4_protocol == IPPROTO_TCP) &&",
          "4085:   flow->l4.tcp.tls.hello_processed)",
          "4086:  flow->guessed_protocol_id = NDPI_PROTOCOL_TLS;",
          "4088:       guessed_protocol_id = flow->guessed_protocol_id, guessed_host_protocol_id = flow->guessed_host_protocol_id;",
          "4090:       if((guessed_host_protocol_id != NDPI_PROTOCOL_UNKNOWN) &&",
          "4091:   ((flow->packet.l4_protocol == IPPROTO_UDP) &&",
          "4092:    NDPI_ISSET(&flow->excluded_protocol_bitmask, guessed_host_protocol_id) &&",
          "4093:    is_udp_guessable_protocol(guessed_host_protocol_id)))",
          "4094:  flow->guessed_host_protocol_id = guessed_host_protocol_id = NDPI_PROTOCOL_UNKNOWN;",
          "4097:       if((guessed_protocol_id != NDPI_PROTOCOL_UNKNOWN)",
          "4099:   && (flow->packet.l4_protocol == IPPROTO_UDP) &&",
          "4100:   NDPI_ISSET(&flow->excluded_protocol_bitmask, guessed_protocol_id) &&",
          "4101:   is_udp_guessable_protocol(guessed_protocol_id))",
          "4102:  flow->guessed_protocol_id = guessed_protocol_id = NDPI_PROTOCOL_UNKNOWN;",
          "4104:       if((guessed_protocol_id != NDPI_PROTOCOL_UNKNOWN) || (guessed_host_protocol_id != NDPI_PROTOCOL_UNKNOWN)) {",
          "4105:  if((guessed_protocol_id == 0) && (flow->protos.stun_ssl.stun.num_binding_requests > 0) &&",
          "4106:     (flow->protos.stun_ssl.stun.num_processed_pkts > 0))",
          "4107:    guessed_protocol_id = NDPI_PROTOCOL_STUN;",
          "4109:  if(flow->host_server_name[0] != '\\0') {",
          "4110:    ndpi_protocol_match_result ret_match;",
          "4112:    memset(&ret_match, 0, sizeof(ret_match));",
          "4114:    ndpi_match_host_subprotocol(ndpi_str, flow, (char *) flow->host_server_name,",
          "4115:           strlen((const char *) flow->host_server_name), &ret_match,",
          "4116:           NDPI_PROTOCOL_DNS);",
          "4118:    if(ret_match.protocol_id != NDPI_PROTOCOL_UNKNOWN)",
          "4119:      guessed_host_protocol_id = ret_match.protocol_id;",
          "4120:  }",
          "4123:  ndpi_int_change_protocol(ndpi_str, flow, guessed_host_protocol_id, guessed_protocol_id);",
          "4124:       }",
          "4125:     }",
          "4126:   } else if(enable_guess) {",
          "4127:     if(flow->guessed_protocol_id != NDPI_PROTOCOL_UNKNOWN) {",
          "4129:       flow->detected_protocol_stack[1] = flow->guessed_protocol_id;",
          "4132:     if(flow->guessed_host_protocol_id != NDPI_PROTOCOL_UNKNOWN) {",
          "4134:       flow->detected_protocol_stack[0] = flow->guessed_host_protocol_id;",
          "4135:     }",
          "4137:     if(flow->detected_protocol_stack[1] == flow->detected_protocol_stack[0]) {",
          "4139:       flow->detected_protocol_stack[1] = flow->guessed_host_protocol_id;",
          "4141:   }",
          "4143:   if((flow->detected_protocol_stack[0] == NDPI_PROTOCOL_UNKNOWN) &&",
          "4144:      (flow->guessed_protocol_id == NDPI_PROTOCOL_STUN)) {",
          "4145:   check_stun_export:",
          "4146:     if(flow->protos.stun_ssl.stun.num_processed_pkts || flow->protos.stun_ssl.stun.num_udp_pkts) {",
          "4149:       ndpi_set_detected_protocol(ndpi_str, flow, flow->guessed_host_protocol_id, NDPI_PROTOCOL_STUN);",
          "4151:   }",
          "4153:   ret.master_protocol = flow->detected_protocol_stack[1], ret.app_protocol = flow->detected_protocol_stack[0];",
          "4155:   if(ret.master_protocol == NDPI_PROTOCOL_STUN) {",
          "4156:     if(ret.app_protocol == NDPI_PROTOCOL_FACEBOOK)",
          "4157:       ret.app_protocol = NDPI_PROTOCOL_MESSENGER;",
          "4158:     else if(ret.app_protocol == NDPI_PROTOCOL_GOOGLE) {",
          "4160:  As Google has recently introduced Duo,",
          "4161:  we need to distinguish between it and hangout",
          "4162:  thing that should be handled by the STUN dissector",
          "4164:       ret.app_protocol = NDPI_PROTOCOL_HANGOUT_DUO;",
          "4165:     }",
          "4166:   }",
          "4168:   if(ret.app_protocol != NDPI_PROTOCOL_UNKNOWN) {",
          "4170:     ndpi_fill_protocol_category(ndpi_str, flow, &ret);",
          "4171:   }",
          "4173:   return(ret);",
          "4180:                                const u_int64_t current_tick_l, struct ndpi_id_struct *src, struct ndpi_id_struct *dst) {",
          "4181:   if(flow == NULL)",
          "4182:     return;",
          "4184:   if(flow->server_id == NULL)",
          "4188:   if(packetlen < 20) {",
          "4189:     return;",
          "4190:   }",
          "4192:   flow->packet.tick_timestamp_l = current_tick_l;",
          "4193:   flow->packet.tick_timestamp = (u_int32_t)(current_tick_l / ndpi_str->ticks_per_second);",
          "4196:   flow->packet.iph = (struct ndpi_iphdr *) packet;",
          "4200:   if(ndpi_init_packet_header(ndpi_str, flow, packetlen) != 0)",
          "4201:     return;",
          "4204:   flow->src = src, flow->dst = dst;",
          "4205:   ndpi_connection_tracking(ndpi_str, flow);",
          "4208:   if(flow->extra_packets_func) {",
          "4209:     if((flow->extra_packets_func(ndpi_str, flow)) == 0)",
          "4210:       flow->check_extra_packets = 0;",
          "4212:     if(++flow->num_extra_packets_checked == flow->max_extra_packets_to_check)",
          "4214:   }",
          "4220:                           ndpi_protocol_category_t category) {",
          "4221:   patricia_node_t *node;",
          "4222:   struct in_addr pin;",
          "4223:   int bits = 32;",
          "4224:   char *ptr;",
          "4225:   char ipbuf[64];",
          "4227:   strncpy(ipbuf, ip_address_and_mask, sizeof(ipbuf));",
          "4228:   ipbuf[sizeof(ipbuf) - 1] = '\\0';",
          "4230:   ptr = strrchr(ipbuf, '/');",
          "4232:   if(ptr) {",
          "4234:     if(atoi(ptr) >= 0 && atoi(ptr) <= 32)",
          "4235:       bits = atoi(ptr);",
          "4236:   }",
          "4238:   if(inet_pton(AF_INET, ipbuf, &pin) != 1) {",
          "4239:     NDPI_LOG_DBG2(ndpi_str, \"Invalid ip/ip+netmask: %s\\n\", ip_address_and_mask);",
          "4240:     return(-1);",
          "4241:   }",
          "4243:   if((node = add_to_ptree(ndpi_str->custom_categories.ipAddresses_shadow, AF_INET, &pin, bits)) != NULL)",
          "4244:     node->value.user_value = (u_int16_t)category, node->value.user_value2 = 0;",
          "4246:   return(0);",
          "4253:                                 ndpi_protocol_category_t category) {",
          "4254:   char *name;",
          "4256:   if(name_to_add == NULL)",
          "4257:     return(-1);",
          "4259:   name = ndpi_strdup(name_to_add);",
          "4261:   if(name == NULL)",
          "4262:     return(-1);",
          "4269:   {",
          "4270:     struct hs_list *h = (struct hs_list *) ndpi_malloc(sizeof(struct hs_list));",
          "4272:     if(h) {",
          "4273:       h->expression = name, h->id = (unsigned int) category;",
          "4274:       h->next = ndpi_str->custom_categories.to_load;",
          "4275:       ndpi_str->custom_categories.to_load = h;",
          "4276:       ndpi_str->custom_categories.num_to_load++;",
          "4277:     } else {",
          "4278:       free(name);",
          "4279:       return(-1);",
          "4281:   }",
          "4283:   AC_PATTERN_t ac_pattern;",
          "4284:   AC_ERROR_t rc;",
          "4286:   memset(&ac_pattern, 0, sizeof(ac_pattern));",
          "4288:   if(ndpi_str->custom_categories.hostnames_shadow.ac_automa == NULL) {",
          "4289:     free(name);",
          "4290:     return(-1);",
          "4291:   }",
          "4293:   ac_pattern.astring = name, ac_pattern.length = strlen(ac_pattern.astring);",
          "4294:   ac_pattern.rep.number = (int) category;",
          "4296:   rc = ac_automata_add(ndpi_str->custom_categories.hostnames_shadow.ac_automa, &ac_pattern);",
          "4297:   if(rc != ACERR_DUPLICATE_PATTERN && rc != ACERR_SUCCESS) {",
          "4298:     free(name);",
          "4299:     return(-1);",
          "4300:   }",
          "4301:   if(rc == ACERR_DUPLICATE_PATTERN)",
          "4302:     free(name);",
          "4305:   return(0);",
          "4312:                        ndpi_protocol_category_t category) {",
          "4313:   int rv;",
          "4316:   rv = ndpi_load_ip_category(ndpi_struct, ip_or_name, category);",
          "4318:   if(rv < 0) {",
          "4320:     rv = ndpi_load_hostname_category(ndpi_struct, ip_or_name, category);",
          "4321:   }",
          "4323:   return(rv);",
          "4328: int ndpi_enable_loaded_categories(struct ndpi_detection_module_struct *ndpi_str) {",
          "4329:   int i;",
          "4332:   for (i = 0; category_match[i].string_to_match != NULL; i++)",
          "4333:     ndpi_load_category(ndpi_str, category_match[i].string_to_match, category_match[i].protocol_category);",
          "4336:   if(ndpi_str->custom_categories.num_to_load > 0) {",
          "4337:     const char **expressions;",
          "4338:     unsigned int *ids;",
          "4339:     int rc;",
          "4340:     struct hs_list *head = ndpi_str->custom_categories.to_load;",
          "4342:     expressions = (const char **) ndpi_calloc(sizeof(char *), ndpi_str->custom_categories.num_to_load + 1);",
          "4343:     if(!expressions)",
          "4344:       return(-1);",
          "4346:     ids = (unsigned int *) ndpi_calloc(sizeof(unsigned int), ndpi_str->custom_categories.num_to_load + 1);",
          "4347:     if(!ids) {",
          "4348:       ndpi_free(expressions);",
          "4349:       return(-1);",
          "4350:     }",
          "4352:     for (i = 0; head != NULL; i++) {",
          "4354:       printf(\"[HS] Loading category %u for %s\\n\", head->id, head->expression);",
          "4356:       expressions[i] = head->expression, ids[i] = head->id;",
          "4357:       head = head->next;",
          "4358:     }",
          "4360:     if(i != ndpi_str->custom_categories.num_to_load) {",
          "4361:       ndpi_free(expressions);",
          "4362:       return(-1);",
          "4363:     }",
          "4365:     free_hyperscan_memory(ndpi_str->custom_categories.hostnames);",
          "4366:     ndpi_str->custom_categories.hostnames = (struct hs *) ndpi_malloc(sizeof(struct hs));",
          "4368:     if(ndpi_str->custom_categories.hostnames == NULL) {",
          "4369:       ndpi_free(expressions);",
          "4370:       ndpi_free(ids);",
          "4372:     }",
          "4374:     rc = hyperscan_load_patterns(ndpi_str->custom_categories.hostnames, ndpi_str->custom_categories.num_to_load,",
          "4375:      expressions, ids);",
          "4376:     ndpi_free(expressions), ndpi_free(ids);",
          "4378:     head = ndpi_str->custom_categories.to_load;",
          "4379:     while (head != NULL) {",
          "4380:       struct hs_list *next = head->next;",
          "4382:       ndpi_free(head->expression);",
          "4383:       ndpi_free(head);",
          "4385:       head = next;",
          "4386:     }",
          "4388:     ndpi_str->custom_categories.to_load = NULL;",
          "4389:     ndpi_str->custom_categories.num_to_load = 0;",
          "4391:     if(rc < 0) {",
          "4392:       ndpi_free(ndpi_str->custom_categories.hostnames);",
          "4393:       ndpi_str->custom_categories.hostnames = NULL;",
          "4395:   }",
          "4398:   ac_automata_release((AC_AUTOMATA_t *) ndpi_str->custom_categories.hostnames.ac_automa,",
          "4399:         1 /* free patterns strings memory */);",
          "4402:   ac_automata_finalize((AC_AUTOMATA_t *) ndpi_str->custom_categories.hostnames_shadow.ac_automa);",
          "4405:   ndpi_str->custom_categories.hostnames.ac_automa = ndpi_str->custom_categories.hostnames_shadow.ac_automa;",
          "4408:   ndpi_str->custom_categories.hostnames_shadow.ac_automa = ac_automata_init(ac_match_handler);",
          "4411:   if(ndpi_str->custom_categories.ipAddresses != NULL)",
          "4412:     ndpi_Destroy_Patricia((patricia_tree_t *) ndpi_str->custom_categories.ipAddresses, free_ptree_data);",
          "4414:   ndpi_str->custom_categories.ipAddresses = ndpi_str->custom_categories.ipAddresses_shadow;",
          "4415:   ndpi_str->custom_categories.ipAddresses_shadow = ndpi_New_Patricia(32 /* IPv4 */);",
          "4417:   ndpi_str->custom_categories.categories_loaded = 1;",
          "4419:   return(0);",
          "4425:                                    ndpi_protocol *ret) {",
          "4426:   if(ndpi_str->custom_categories.categories_loaded) {",
          "4427:     prefix_t prefix;",
          "4428:     patricia_node_t *node;",
          "4430:     if(saddr == 0)",
          "4431:       node = NULL;",
          "4432:     else {",
          "4434:       fill_prefix_v4(&prefix, (struct in_addr *) &saddr, 32,",
          "4435:        ((patricia_tree_t *) ndpi_str->protocols_ptree)->maxbits);",
          "4436:       node = ndpi_patricia_search_best(ndpi_str->custom_categories.ipAddresses, &prefix);",
          "4437:     }",
          "4439:     if(!node) {",
          "4440:       if(daddr != 0) {",
          "4441:  fill_prefix_v4(&prefix, (struct in_addr *) &daddr, 32,",
          "4442:          ((patricia_tree_t *) ndpi_str->protocols_ptree)->maxbits);",
          "4443:  node = ndpi_patricia_search_best(ndpi_str->custom_categories.ipAddresses, &prefix);",
          "4444:       }",
          "4447:     if(node) {",
          "4448:       ret->category = (ndpi_protocol_category_t) node->value.user_value;",
          "4450:       return(1);",
          "4451:     }",
          "4452:   }",
          "4454:   ret->category = ndpi_get_proto_category(ndpi_str, *ret);",
          "4456:   return(0);",
          "4462:                                  ndpi_protocol *ret) {",
          "4463:   if(ndpi_str->custom_categories.categories_loaded) {",
          "4464:     if(flow->guessed_header_category != NDPI_PROTOCOL_CATEGORY_UNSPECIFIED) {",
          "4465:       flow->category = ret->category = flow->guessed_header_category;",
          "4466:       return;",
          "4467:     }",
          "4469:     if(flow->host_server_name[0] != '\\0') {",
          "4470:       u_int16_t id;",
          "4471:       int rc = ndpi_match_custom_category(ndpi_str, (char *) flow->host_server_name,",
          "4472:        strlen((char *) flow->host_server_name), &id);",
          "4474:       if(rc == 0) {",
          "4475:  flow->category = ret->category = (ndpi_protocol_category_t) id;",
          "4476:  return;",
          "4477:       }",
          "4478:     }",
          "4480:     if(flow->l4.tcp.tls.hello_processed == 1 &&",
          "4481:        flow->protos.stun_ssl.ssl.client_requested_server_name[0] != '\\0') {",
          "4482:       u_int16_t id;",
          "4483:       int rc = ndpi_match_custom_category(ndpi_str, (char *) flow->protos.stun_ssl.ssl.client_requested_server_name,",
          "4484:        strlen(flow->protos.stun_ssl.ssl.client_requested_server_name), &id);",
          "4486:       if(rc == 0) {",
          "4487:  flow->category = ret->category = (ndpi_protocol_category_t) id;",
          "4488:  return;",
          "4489:       }",
          "4491:   }",
          "4493:   flow->category = ret->category = ndpi_get_proto_category(ndpi_str, *ret);",
          "4498: static void ndpi_reset_packet_line_info(struct ndpi_packet_struct *packet) {",
          "4499:   packet->parsed_lines = 0, packet->empty_line_position_set = 0, packet->host_line.ptr = NULL,",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "4589: ndpi_protocol ndpi_detection_process_packet(struct ndpi_detection_module_struct *ndpi_str,",
          "4590:                                             struct ndpi_flow_struct *flow, const unsigned char *packet,",
          "4591:                                             const unsigned short packetlen, const u_int64_t current_tick_l,",
          "4667: #ifdef NDPI_DETECTION_SUPPORT_IPV6",
          "4673: #ifdef NDPI_DETECTION_SUPPORT_IPV6",
          "4675: #endif",
          "4683: #ifdef NDPI_DETECTION_SUPPORT_IPV6",
          "4687: #endif",
          "4744:    We could implement a shortcut here skipping dissectors for",
          "4745:    protocols we have identified by other means such as with the IP",
          "4747:    However we do NOT stop here and skip invoking the dissectors",
          "4748:    because we want to dissect the flow (e.g. dissect the TLS)",
          "4749:    and extract metadata.",
          "4751: #if SKIP_INVOKING_THE_DISSECTORS",
          "4754:      We have identified a protocol using the IP address so",
          "4755:      it is not worth to dissect the traffic as we already have",
          "4756:      the solution",
          "4760: #endif",
          "4763:     }",
          "4774:     ndpi_check_flow_func(ndpi_str, flow, &ndpi_selection_packet);",
          "4791:     }",
          "4814:       This is a TCP flow",
          "4815:       - whose first packet is NOT a SYN",
          "4816:       - no protocol has been detected",
          "",
          "[Removed Lines]",
          "4592:                                             struct ndpi_id_struct *src, struct ndpi_id_struct *dst)",
          "4593: {",
          "4594:     NDPI_SELECTION_BITMASK_PROTOCOL_SIZE ndpi_selection_packet;",
          "4595:     u_int32_t a;",
          "4596:     ndpi_protocol ret = {NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED};",
          "4598:     if (ndpi_str->ndpi_log_level >= NDPI_LOG_TRACE)",
          "4599:         NDPI_LOG(flow ? flow->detected_protocol_stack[0] : NDPI_PROTOCOL_UNKNOWN, ndpi_str, NDPI_LOG_TRACE,",
          "4600:                  \"START packet processing\\n\");",
          "4602:     if (flow == NULL)",
          "4603:         return (ret);",
          "4604:     else",
          "4605:         ret.category = flow->category;",
          "4607:     flow->num_processed_pkts++;",
          "4610:     ret.master_protocol = flow->detected_protocol_stack[1], ret.app_protocol = flow->detected_protocol_stack[0];",
          "4612:     if (flow->server_id == NULL)",
          "4615:     if (flow->detected_protocol_stack[0] != NDPI_PROTOCOL_UNKNOWN) {",
          "4616:         if (flow->check_extra_packets) {",
          "4617:             ndpi_process_extra_packet(ndpi_str, flow, packet, packetlen, current_tick_l, src, dst);",
          "4619:             ret.master_protocol = flow->detected_protocol_stack[1], ret.app_protocol = flow->detected_protocol_stack[0],",
          "4620:             ret.category = flow->category;",
          "4621:             goto invalidate_ptr;",
          "4622:         } else",
          "4623:             goto ret_protocols;",
          "4624:     }",
          "4627:     if (packetlen < 20) {",
          "4629:         ndpi_int_reset_packet_protocol(&flow->packet);",
          "4630:         goto invalidate_ptr;",
          "4631:     }",
          "4633:     flow->packet.tick_timestamp_l = current_tick_l;",
          "4634:     flow->packet.tick_timestamp = (u_int32_t)(current_tick_l / ndpi_str->ticks_per_second);",
          "4637:     flow->packet.iph = (struct ndpi_iphdr *) packet;",
          "4640:     if (ndpi_init_packet_header(ndpi_str, flow, packetlen) != 0)",
          "4641:         goto invalidate_ptr;",
          "4644:     flow->src = src, flow->dst = dst;",
          "4646:     ndpi_connection_tracking(ndpi_str, flow);",
          "4649:     ndpi_selection_packet = NDPI_SELECTION_BITMASK_PROTOCOL_COMPLETE_TRAFFIC;",
          "4650:     if (flow->packet.iph != NULL)",
          "4651:         ndpi_selection_packet |= NDPI_SELECTION_BITMASK_PROTOCOL_IP | NDPI_SELECTION_BITMASK_PROTOCOL_IPV4_OR_IPV6;",
          "4653:     if (flow->packet.tcp != NULL)",
          "4654:         ndpi_selection_packet |=",
          "4655:             (NDPI_SELECTION_BITMASK_PROTOCOL_INT_TCP | NDPI_SELECTION_BITMASK_PROTOCOL_INT_TCP_OR_UDP);",
          "4657:     if (flow->packet.udp != NULL)",
          "4658:         ndpi_selection_packet |=",
          "4659:             (NDPI_SELECTION_BITMASK_PROTOCOL_INT_UDP | NDPI_SELECTION_BITMASK_PROTOCOL_INT_TCP_OR_UDP);",
          "4661:     if (flow->packet.payload_packet_len != 0)",
          "4662:         ndpi_selection_packet |= NDPI_SELECTION_BITMASK_PROTOCOL_HAS_PAYLOAD;",
          "4664:     if (flow->packet.tcp_retransmission == 0)",
          "4665:         ndpi_selection_packet |= NDPI_SELECTION_BITMASK_PROTOCOL_NO_TCP_RETRANSMISSION;",
          "4668:     if (flow->packet.iphv6 != NULL)",
          "4669:         ndpi_selection_packet |= NDPI_SELECTION_BITMASK_PROTOCOL_IPV6 | NDPI_SELECTION_BITMASK_PROTOCOL_IPV4_OR_IPV6;",
          "4672:     if ((!flow->protocol_id_already_guessed) && (",
          "4674:                                                     flow->packet.iphv6 ||",
          "4676:                                                     flow->packet.iph)) {",
          "4677:         u_int16_t sport, dport;",
          "4678:         u_int8_t protocol;",
          "4679:         u_int8_t user_defined_proto;",
          "4681:         flow->protocol_id_already_guessed = 1;",
          "4684:         if (flow->packet.iphv6 != NULL) {",
          "4685:             protocol = flow->packet.iphv6->ip6_hdr.ip6_un1_nxt;",
          "4686:         } else",
          "4688:         {",
          "4689:             protocol = flow->packet.iph->protocol;",
          "4690:         }",
          "4692:         if (flow->packet.udp)",
          "4693:             sport = ntohs(flow->packet.udp->source), dport = ntohs(flow->packet.udp->dest);",
          "4694:         else if (flow->packet.tcp)",
          "4695:             sport = ntohs(flow->packet.tcp->source), dport = ntohs(flow->packet.tcp->dest);",
          "4696:         else",
          "4697:             sport = dport = 0;",
          "4700:         flow->guessed_protocol_id =",
          "4701:             (int16_t) ndpi_guess_protocol_id(ndpi_str, flow, protocol, sport, dport, &user_defined_proto);",
          "4702:         flow->guessed_host_protocol_id = ndpi_guess_host_protocol_id(ndpi_str, flow);",
          "4704:         if (ndpi_str->custom_categories.categories_loaded && flow->packet.iph) {",
          "4705:             ndpi_fill_ip_protocol_category(ndpi_str, flow->packet.iph->saddr, flow->packet.iph->daddr, &ret);",
          "4706:             flow->guessed_header_category = ret.category;",
          "4707:         } else",
          "4708:             flow->guessed_header_category = NDPI_PROTOCOL_CATEGORY_UNSPECIFIED;",
          "4710:         if (flow->guessed_protocol_id >= NDPI_MAX_SUPPORTED_PROTOCOLS) {",
          "4712:             ret.master_protocol = NDPI_PROTOCOL_UNKNOWN,",
          "4713:             ret.app_protocol = flow->guessed_protocol_id ? flow->guessed_protocol_id : flow->guessed_host_protocol_id;",
          "4714:             ndpi_fill_protocol_category(ndpi_str, flow, &ret);",
          "4715:             goto invalidate_ptr;",
          "4716:         }",
          "4718:         if (user_defined_proto && flow->guessed_protocol_id != NDPI_PROTOCOL_UNKNOWN) {",
          "4719:             if (flow->packet.iph) {",
          "4720:                 if (flow->guessed_host_protocol_id != NDPI_PROTOCOL_UNKNOWN) {",
          "4721:                     u_int8_t protocol_was_guessed;",
          "4724:                     ret = ndpi_detection_giveup(ndpi_str, flow, 0, &protocol_was_guessed);",
          "4725:                 }",
          "4727:                 ndpi_fill_protocol_category(ndpi_str, flow, &ret);",
          "4728:                 goto invalidate_ptr;",
          "4729:             }",
          "4730:         } else {",
          "4732:             if (flow->packet.iph) {",
          "4733:                 struct in_addr addr;",
          "4735:                 addr.s_addr = flow->packet.iph->saddr;",
          "4736:                 flow->guessed_host_protocol_id = ndpi_network_ptree_match(ndpi_str, &addr);",
          "4738:                 if (flow->guessed_host_protocol_id == NDPI_PROTOCOL_UNKNOWN) {",
          "4739:                     addr.s_addr = flow->packet.iph->daddr;",
          "4740:                     flow->guessed_host_protocol_id = ndpi_network_ptree_match(ndpi_str, &addr);",
          "4741:                 }",
          "4752:                 if (flow->guessed_host_protocol_id != NDPI_PROTOCOL_UNKNOWN) {",
          "4758:                     ret.master_protocol = flow->guessed_protocol_id, ret.app_protocol = flow->guessed_host_protocol_id;",
          "4759:                 }",
          "4761:             }",
          "4762:         }",
          "4765:     if (flow->guessed_host_protocol_id >= NDPI_MAX_SUPPORTED_PROTOCOLS) {",
          "4767:         ret.master_protocol = flow->guessed_protocol_id, ret.app_protocol = flow->guessed_host_protocol_id;",
          "4769:         ndpi_check_flow_func(ndpi_str, flow, &ndpi_selection_packet);",
          "4770:         ndpi_fill_protocol_category(ndpi_str, flow, &ret);",
          "4771:         goto invalidate_ptr;",
          "4772:     }",
          "4776:     a = flow->packet.detected_protocol_stack[0];",
          "4777:     if (NDPI_COMPARE_PROTOCOL_TO_BITMASK(ndpi_str->detection_bitmask, a) == 0)",
          "4778:         a = NDPI_PROTOCOL_UNKNOWN;",
          "4780:     if (a != NDPI_PROTOCOL_UNKNOWN) {",
          "4781:         int i;",
          "4783:         for (i = 0; i < sizeof(flow->host_server_name); i++) {",
          "4784:             if (flow->host_server_name[i] != '\\0')",
          "4785:                 flow->host_server_name[i] = tolower(flow->host_server_name[i]);",
          "4786:             else {",
          "4787:                 flow->host_server_name[i] = '\\0';",
          "4788:                 break;",
          "4789:             }",
          "4790:         }",
          "4793: ret_protocols:",
          "4794:     if (flow->detected_protocol_stack[1] != NDPI_PROTOCOL_UNKNOWN) {",
          "4795:         ret.master_protocol = flow->detected_protocol_stack[1], ret.app_protocol = flow->detected_protocol_stack[0];",
          "4797:         if (ret.app_protocol == ret.master_protocol)",
          "4798:             ret.master_protocol = NDPI_PROTOCOL_UNKNOWN;",
          "4799:     } else",
          "4800:         ret.app_protocol = flow->detected_protocol_stack[0];",
          "4803:     if ((flow->category == NDPI_PROTOCOL_CATEGORY_UNSPECIFIED) && (ret.app_protocol != NDPI_PROTOCOL_UNKNOWN))",
          "4804:         ndpi_fill_protocol_category(ndpi_str, flow, &ret);",
          "4805:     else",
          "4806:         ret.category = flow->category;",
          "4808:     if ((flow->num_processed_pkts == 1) && (ret.master_protocol == NDPI_PROTOCOL_UNKNOWN) &&",
          "4809:         (ret.app_protocol == NDPI_PROTOCOL_UNKNOWN) && flow->packet.tcp && (flow->packet.tcp->syn == 0) &&",
          "4810:         (flow->guessed_protocol_id == 0)) {",
          "4811:         u_int8_t protocol_was_guessed;",
          "",
          "[Added Lines]",
          "4517:                                             struct ndpi_id_struct *src, struct ndpi_id_struct *dst) {",
          "4518:   NDPI_SELECTION_BITMASK_PROTOCOL_SIZE ndpi_selection_packet;",
          "4519:   u_int32_t a;",
          "4520:   ndpi_protocol ret = {NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED};",
          "4522:   if(ndpi_str->ndpi_log_level >= NDPI_LOG_TRACE)",
          "4523:     NDPI_LOG(flow ? flow->detected_protocol_stack[0] : NDPI_PROTOCOL_UNKNOWN, ndpi_str, NDPI_LOG_TRACE,",
          "4524:       \"START packet processing\\n\");",
          "4526:   if(flow == NULL)",
          "4527:     return(ret);",
          "4528:   else",
          "4529:     ret.category = flow->category;",
          "4531:   flow->num_processed_pkts++;",
          "4534:   ret.master_protocol = flow->detected_protocol_stack[1], ret.app_protocol = flow->detected_protocol_stack[0];",
          "4536:   if(flow->server_id == NULL)",
          "4539:   if(flow->detected_protocol_stack[0] != NDPI_PROTOCOL_UNKNOWN) {",
          "4540:     if(flow->check_extra_packets) {",
          "4541:       ndpi_process_extra_packet(ndpi_str, flow, packet, packetlen, current_tick_l, src, dst);",
          "4543:       ret.master_protocol = flow->detected_protocol_stack[1], ret.app_protocol = flow->detected_protocol_stack[0],",
          "4544:  ret.category = flow->category;",
          "4545:       goto invalidate_ptr;",
          "4546:     } else",
          "4547:       goto ret_protocols;",
          "4548:   }",
          "4551:   if(packetlen < 20) {",
          "4553:     ndpi_int_reset_packet_protocol(&flow->packet);",
          "4554:     goto invalidate_ptr;",
          "4555:   }",
          "4557:   flow->packet.tick_timestamp_l = current_tick_l;",
          "4558:   flow->packet.tick_timestamp = (u_int32_t)(current_tick_l / ndpi_str->ticks_per_second);",
          "4561:   flow->packet.iph = (struct ndpi_iphdr *) packet;",
          "4564:   if(ndpi_init_packet_header(ndpi_str, flow, packetlen) != 0)",
          "4565:     goto invalidate_ptr;",
          "4568:   flow->src = src, flow->dst = dst;",
          "4570:   ndpi_connection_tracking(ndpi_str, flow);",
          "4573:   ndpi_selection_packet = NDPI_SELECTION_BITMASK_PROTOCOL_COMPLETE_TRAFFIC;",
          "4574:   if(flow->packet.iph != NULL)",
          "4575:     ndpi_selection_packet |= NDPI_SELECTION_BITMASK_PROTOCOL_IP | NDPI_SELECTION_BITMASK_PROTOCOL_IPV4_OR_IPV6;",
          "4577:   if(flow->packet.tcp != NULL)",
          "4578:     ndpi_selection_packet |=",
          "4579:       (NDPI_SELECTION_BITMASK_PROTOCOL_INT_TCP | NDPI_SELECTION_BITMASK_PROTOCOL_INT_TCP_OR_UDP);",
          "4581:   if(flow->packet.udp != NULL)",
          "4582:     ndpi_selection_packet |=",
          "4583:       (NDPI_SELECTION_BITMASK_PROTOCOL_INT_UDP | NDPI_SELECTION_BITMASK_PROTOCOL_INT_TCP_OR_UDP);",
          "4585:   if(flow->packet.payload_packet_len != 0)",
          "4586:     ndpi_selection_packet |= NDPI_SELECTION_BITMASK_PROTOCOL_HAS_PAYLOAD;",
          "4588:   if(flow->packet.tcp_retransmission == 0)",
          "4589:     ndpi_selection_packet |= NDPI_SELECTION_BITMASK_PROTOCOL_NO_TCP_RETRANSMISSION;",
          "4592:   if(flow->packet.iphv6 != NULL)",
          "4593:     ndpi_selection_packet |= NDPI_SELECTION_BITMASK_PROTOCOL_IPV6 | NDPI_SELECTION_BITMASK_PROTOCOL_IPV4_OR_IPV6;",
          "4596:   if((!flow->protocol_id_already_guessed) && (",
          "4598:            flow->packet.iphv6 ||",
          "4600:            flow->packet.iph)) {",
          "4601:     u_int16_t sport, dport;",
          "4602:     u_int8_t protocol;",
          "4603:     u_int8_t user_defined_proto;",
          "4605:     flow->protocol_id_already_guessed = 1;",
          "4608:     if(flow->packet.iphv6 != NULL) {",
          "4609:       protocol = flow->packet.iphv6->ip6_hdr.ip6_un1_nxt;",
          "4610:     } else",
          "4612:       {",
          "4613:  protocol = flow->packet.iph->protocol;",
          "4614:       }",
          "4616:     if(flow->packet.udp)",
          "4617:       sport = ntohs(flow->packet.udp->source), dport = ntohs(flow->packet.udp->dest);",
          "4618:     else if(flow->packet.tcp)",
          "4619:       sport = ntohs(flow->packet.tcp->source), dport = ntohs(flow->packet.tcp->dest);",
          "4620:     else",
          "4621:       sport = dport = 0;",
          "4624:     flow->guessed_protocol_id =",
          "4625:       (int16_t) ndpi_guess_protocol_id(ndpi_str, flow, protocol, sport, dport, &user_defined_proto);",
          "4626:     flow->guessed_host_protocol_id = ndpi_guess_host_protocol_id(ndpi_str, flow);",
          "4628:     if(ndpi_str->custom_categories.categories_loaded && flow->packet.iph) {",
          "4629:       ndpi_fill_ip_protocol_category(ndpi_str, flow->packet.iph->saddr, flow->packet.iph->daddr, &ret);",
          "4630:       flow->guessed_header_category = ret.category;",
          "4631:     } else",
          "4632:       flow->guessed_header_category = NDPI_PROTOCOL_CATEGORY_UNSPECIFIED;",
          "4634:     if(flow->guessed_protocol_id >= NDPI_MAX_SUPPORTED_PROTOCOLS) {",
          "4636:       ret.master_protocol = NDPI_PROTOCOL_UNKNOWN,",
          "4637:  ret.app_protocol = flow->guessed_protocol_id ? flow->guessed_protocol_id : flow->guessed_host_protocol_id;",
          "4638:       ndpi_fill_protocol_category(ndpi_str, flow, &ret);",
          "4639:       goto invalidate_ptr;",
          "4640:     }",
          "4642:     if(user_defined_proto && flow->guessed_protocol_id != NDPI_PROTOCOL_UNKNOWN) {",
          "4643:       if(flow->packet.iph) {",
          "4644:  if(flow->guessed_host_protocol_id != NDPI_PROTOCOL_UNKNOWN) {",
          "4645:    u_int8_t protocol_was_guessed;",
          "4648:    ret = ndpi_detection_giveup(ndpi_str, flow, 0, &protocol_was_guessed);",
          "4649:  }",
          "4651:  ndpi_fill_protocol_category(ndpi_str, flow, &ret);",
          "4652:  goto invalidate_ptr;",
          "4653:       }",
          "4654:     } else {",
          "4656:       if(flow->packet.iph) {",
          "4657:  struct in_addr addr;",
          "4659:  addr.s_addr = flow->packet.iph->saddr;",
          "4660:  flow->guessed_host_protocol_id = ndpi_network_ptree_match(ndpi_str, &addr);",
          "4662:  if(flow->guessed_host_protocol_id == NDPI_PROTOCOL_UNKNOWN) {",
          "4663:    addr.s_addr = flow->packet.iph->daddr;",
          "4664:    flow->guessed_host_protocol_id = ndpi_network_ptree_match(ndpi_str, &addr);",
          "4665:  }",
          "4676:  if(flow->guessed_host_protocol_id != NDPI_PROTOCOL_UNKNOWN) {",
          "4682:    ret.master_protocol = flow->guessed_protocol_id, ret.app_protocol = flow->guessed_host_protocol_id;",
          "4683:  }",
          "4685:       }",
          "4687:   }",
          "4689:   if(flow->guessed_host_protocol_id >= NDPI_MAX_SUPPORTED_PROTOCOLS) {",
          "4691:     ret.master_protocol = flow->guessed_protocol_id, ret.app_protocol = flow->guessed_host_protocol_id;",
          "4694:     ndpi_fill_protocol_category(ndpi_str, flow, &ret);",
          "4695:     goto invalidate_ptr;",
          "4696:   }",
          "4698:   ndpi_check_flow_func(ndpi_str, flow, &ndpi_selection_packet);",
          "4700:   a = flow->packet.detected_protocol_stack[0];",
          "4701:   if(NDPI_COMPARE_PROTOCOL_TO_BITMASK(ndpi_str->detection_bitmask, a) == 0)",
          "4702:     a = NDPI_PROTOCOL_UNKNOWN;",
          "4704:   if(a != NDPI_PROTOCOL_UNKNOWN) {",
          "4705:     int i;",
          "4707:     for (i = 0; i < sizeof(flow->host_server_name); i++) {",
          "4708:       if(flow->host_server_name[i] != '\\0')",
          "4709:  flow->host_server_name[i] = tolower(flow->host_server_name[i]);",
          "4710:       else {",
          "4711:  flow->host_server_name[i] = '\\0';",
          "4712:  break;",
          "4713:       }",
          "4715:   }",
          "4717:  ret_protocols:",
          "4718:   if(flow->detected_protocol_stack[1] != NDPI_PROTOCOL_UNKNOWN) {",
          "4719:     ret.master_protocol = flow->detected_protocol_stack[1], ret.app_protocol = flow->detected_protocol_stack[0];",
          "4721:     if(ret.app_protocol == ret.master_protocol)",
          "4722:       ret.master_protocol = NDPI_PROTOCOL_UNKNOWN;",
          "4723:   } else",
          "4724:     ret.app_protocol = flow->detected_protocol_stack[0];",
          "4727:   if((flow->category == NDPI_PROTOCOL_CATEGORY_UNSPECIFIED) && (ret.app_protocol != NDPI_PROTOCOL_UNKNOWN))",
          "4728:     ndpi_fill_protocol_category(ndpi_str, flow, &ret);",
          "4729:   else",
          "4730:     ret.category = flow->category;",
          "4732:   if((flow->num_processed_pkts == 1) && (ret.master_protocol == NDPI_PROTOCOL_UNKNOWN) &&",
          "4733:      (ret.app_protocol == NDPI_PROTOCOL_UNKNOWN) && flow->packet.tcp && (flow->packet.tcp->syn == 0) &&",
          "4734:      (flow->guessed_protocol_id == 0)) {",
          "4735:     u_int8_t protocol_was_guessed;",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "4818:       We don't see how future packets can match anything",
          "4819:       hence we giveup here",
          "4839: }",
          "4858: }",
          "4862: #ifdef CODE_UNUSED",
          "4895: }",
          "4897: #endif",
          "4914: }",
          "4918: u_int64_t ndpi_bytestream_dec_or_hex_to_number64(const u_int8_t *str, u_int16_t max_chars_to_read,",
          "4949: }",
          "4987: }",
          "5235: }",
          "5277:     }",
          "5278: }",
          "5282: u_int16_t ndpi_check_for_email_address(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,",
          "5359: }",
          "5361: #ifdef NDPI_ENABLE_DEBUG_MESSAGES",
          "5364: void ndpi_debug_get_last_log_function_line(struct ndpi_detection_module_struct *ndpi_str, const char **file,",
          "5377: }",
          "5378: #endif",
          "5382: u_int8_t ndpi_detection_get_l4(const u_int8_t *l3, u_int16_t l3_len, const u_int8_t **l4_return,",
          "5386: }",
          "5390: void ndpi_set_detected_protocol(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,",
          "5410: }",
          "5417: }",
          "5421: void ndpi_int_change_flow_protocol(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,",
          "5428:     flow->detected_protocol_stack[1] = lower_detected_protocol;",
          "5429: }",
          "5433: void ndpi_int_change_packet_protocol(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,",
          "5446:     packet->detected_protocol_stack[1] = lower_detected_protocol;",
          "5447: }",
          "",
          "[Removed Lines]",
          "4821:         ret = ndpi_detection_giveup(ndpi_str, flow, 0, &protocol_was_guessed);",
          "4822:     }",
          "4824:     if ((ret.master_protocol == NDPI_PROTOCOL_UNKNOWN) && (ret.app_protocol != NDPI_PROTOCOL_UNKNOWN) &&",
          "4825:         (flow->guessed_host_protocol_id != NDPI_PROTOCOL_UNKNOWN)) {",
          "4826:         ret.master_protocol = ret.app_protocol;",
          "4827:         ret.app_protocol = flow->guessed_host_protocol_id;",
          "4828:     }",
          "4830: invalidate_ptr:",
          "4832:      Invalidate packet memory to avoid accessing the pointers below",
          "4833:      when the packet is no longer accessible",
          "4835:     flow->packet.iph = NULL, flow->packet.tcp = NULL, flow->packet.udp = NULL, flow->packet.payload = NULL;",
          "4836:     ndpi_reset_packet_line_info(&flow->packet);",
          "4838:     return (ret);",
          "4843: u_int32_t ndpi_bytestream_to_number(const u_int8_t *str, u_int16_t max_chars_to_read, u_int16_t *bytes_read)",
          "4844: {",
          "4845:     u_int32_t val;",
          "4846:     val = 0;",
          "4849:     while (*str >= '0' && *str <= '9' && max_chars_to_read > 0) {",
          "4850:         val *= 10;",
          "4851:         val += *str - '0';",
          "4852:         str++;",
          "4853:         max_chars_to_read = max_chars_to_read - 1;",
          "4855:     }",
          "4857:     return (val);",
          "4863: u_int32_t ndpi_bytestream_dec_or_hex_to_number(const u_int8_t *str, u_int16_t max_chars_to_read, u_int16_t *bytes_read)",
          "4864: {",
          "4865:     u_int32_t val;",
          "4866:     val = 0;",
          "4867:     if (max_chars_to_read <= 2 || str[0] != '0' || str[1] != 'x') {",
          "4868:         return (ndpi_bytestream_to_number(str, max_chars_to_read, bytes_read));",
          "4869:     } else {",
          "4871:         str += 2;",
          "4872:         max_chars_to_read -= 2;",
          "4875:         while (max_chars_to_read > 0) {",
          "4876:             if (*str >= '0' && *str <= '9') {",
          "4877:                 val *= 16;",
          "4878:                 val += *str - '0';",
          "4879:             } else if (*str >= 'a' && *str <= 'f') {",
          "4880:                 val *= 16;",
          "4881:                 val += *str + 10 - 'a';",
          "4882:             } else if (*str >= 'A' && *str <= 'F') {",
          "4883:                 val *= 16;",
          "4884:                 val += *str + 10 - 'A';",
          "4885:             } else {",
          "4886:                 break;",
          "4887:             }",
          "4888:             str++;",
          "4889:             max_chars_to_read = max_chars_to_read - 1;",
          "4891:         }",
          "4892:     }",
          "4894:     return (val);",
          "4901: u_int64_t ndpi_bytestream_to_number64(const u_int8_t *str, u_int16_t max_chars_to_read, u_int16_t *bytes_read)",
          "4902: {",
          "4903:     u_int64_t val;",
          "4904:     val = 0;",
          "4906:     while (max_chars_to_read > 0 && *str >= '0' && *str <= '9') {",
          "4907:         val *= 10;",
          "4908:         val += *str - '0';",
          "4909:         str++;",
          "4910:         max_chars_to_read = max_chars_to_read - 1;",
          "4912:     }",
          "4913:     return (val);",
          "4919:                                                  u_int16_t *bytes_read)",
          "4920: {",
          "4921:     u_int64_t val;",
          "4922:     val = 0;",
          "4923:     if (max_chars_to_read <= 2 || str[0] != '0' || str[1] != 'x') {",
          "4924:         return (ndpi_bytestream_to_number64(str, max_chars_to_read, bytes_read));",
          "4925:     } else {",
          "4927:         str += 2;",
          "4928:         max_chars_to_read -= 2;",
          "4930:         while (max_chars_to_read > 0) {",
          "4931:             if (*str >= '0' && *str <= '9') {",
          "4932:                 val *= 16;",
          "4933:                 val += *str - '0';",
          "4934:             } else if (*str >= 'a' && *str <= 'f') {",
          "4935:                 val *= 16;",
          "4936:                 val += *str + 10 - 'a';",
          "4937:             } else if (*str >= 'A' && *str <= 'F') {",
          "4938:                 val *= 16;",
          "4939:                 val += *str + 10 - 'A';",
          "4940:             } else {",
          "4941:                 break;",
          "4942:             }",
          "4943:             str++;",
          "4944:             max_chars_to_read = max_chars_to_read - 1;",
          "4946:         }",
          "4947:     }",
          "4948:     return (val);",
          "4953: u_int32_t ndpi_bytestream_to_ipv4(const u_int8_t *str, u_int16_t max_chars_to_read, u_int16_t *bytes_read)",
          "4954: {",
          "4955:     u_int32_t val;",
          "4956:     u_int16_t read = 0;",
          "4957:     u_int16_t oldread;",
          "4958:     u_int32_t c;",
          "4960:     oldread = read;",
          "4961:     c = ndpi_bytestream_to_number(str, max_chars_to_read, &read);",
          "4962:     if (c > 255 || oldread == read || max_chars_to_read == read || str[read] != '.')",
          "4963:         return (0);",
          "4964:     read++;",
          "4965:     val = c << 24;",
          "4966:     oldread = read;",
          "4967:     c = ndpi_bytestream_to_number(&str[read], max_chars_to_read - read, &read);",
          "4968:     if (c > 255 || oldread == read || max_chars_to_read == read || str[read] != '.')",
          "4969:         return (0);",
          "4970:     read++;",
          "4971:     val = val + (c << 16);",
          "4972:     oldread = read;",
          "4973:     c = ndpi_bytestream_to_number(&str[read], max_chars_to_read - read, &read);",
          "4974:     if (c > 255 || oldread == read || max_chars_to_read == read || str[read] != '.')",
          "4975:         return (0);",
          "4976:     read++;",
          "4977:     val = val + (c << 8);",
          "4978:     oldread = read;",
          "4979:     c = ndpi_bytestream_to_number(&str[read], max_chars_to_read - read, &read);",
          "4980:     if (c > 255 || oldread == read || max_chars_to_read == read)",
          "4981:         return (0);",
          "4982:     val = val + c;",
          "4986:     return (htonl(val));",
          "4992: void ndpi_parse_packet_line_info(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow)",
          "4993: {",
          "4994:     u_int32_t a;",
          "4995:     struct ndpi_packet_struct *packet = &flow->packet;",
          "4997:     if (packet->packet_lines_parsed_complete != 0)",
          "4998:         return;",
          "5000:     packet->packet_lines_parsed_complete = 1;",
          "5001:     ndpi_reset_packet_line_info(packet);",
          "5003:     if ((packet->payload_packet_len < 3) || (packet->payload == NULL))",
          "5004:         return;",
          "5006:     packet->line[packet->parsed_lines].ptr = packet->payload;",
          "5007:     packet->line[packet->parsed_lines].len = 0;",
          "5009:     for (a = 0; (a < packet->payload_packet_len) && (packet->parsed_lines < NDPI_MAX_PARSE_LINES_PER_PACKET); a++) {",
          "5010:         if ((a + 1) >= packet->payload_packet_len)",
          "5013:         if (get_u_int16_t(packet->payload, a) ==",
          "5015:             packet->line[packet->parsed_lines].len = (u_int16_t)(",
          "5016:                 ((unsigned long) &packet->payload[a]) - ((unsigned long) packet->line[packet->parsed_lines].ptr));",
          "5019:             if (packet->parsed_lines == 0 && packet->line[0].len >= NDPI_STATICSTRING_LEN(\"HTTP/1.X 200 \") &&",
          "5020:                 strncasecmp((const char *) packet->line[0].ptr, \"HTTP/1.\", NDPI_STATICSTRING_LEN(\"HTTP/1.\")) == 0 &&",
          "5022:                 packet->line[0].ptr[NDPI_STATICSTRING_LEN(\"HTTP/1.X \")] < '6') {",
          "5023:                 packet->http_response.ptr = &packet->line[0].ptr[NDPI_STATICSTRING_LEN(\"HTTP/1.1 \")];",
          "5024:                 packet->http_response.len = packet->line[0].len - NDPI_STATICSTRING_LEN(\"HTTP/1.1 \");",
          "5025:                 packet->http_num_headers++;",
          "5028:                 if (packet->payload_packet_len >= 12) {",
          "5029:                     char buf[4];",
          "5032:                     strncpy(buf, (char *) &packet->payload[9], 3);",
          "5033:                     buf[3] = '\\0';",
          "5035:                     flow->http.response_status_code = atoi(buf);",
          "5037:                     if ((flow->http.response_status_code < 100) || (flow->http.response_status_code > 509))",
          "5039:                 }",
          "5040:             }",
          "5043:             if (packet->line[packet->parsed_lines].len > NDPI_STATICSTRING_LEN(\"Server:\") + 1 &&",
          "5044:                 strncasecmp((const char *) packet->line[packet->parsed_lines].ptr,",
          "5045:                             \"Server:\", NDPI_STATICSTRING_LEN(\"Server:\")) == 0) {",
          "5047:                 if (packet->line[packet->parsed_lines].ptr[NDPI_STATICSTRING_LEN(\"Server:\")] == ' ') {",
          "5048:                     packet->server_line.ptr =",
          "5049:                         &packet->line[packet->parsed_lines].ptr[NDPI_STATICSTRING_LEN(\"Server:\") + 1];",
          "5050:                     packet->server_line.len =",
          "5051:                         packet->line[packet->parsed_lines].len - (NDPI_STATICSTRING_LEN(\"Server:\") + 1);",
          "5052:                 } else {",
          "5053:                     packet->server_line.ptr = &packet->line[packet->parsed_lines].ptr[NDPI_STATICSTRING_LEN(\"Server:\")];",
          "5054:                     packet->server_line.len = packet->line[packet->parsed_lines].len - NDPI_STATICSTRING_LEN(\"Server:\");",
          "5055:                 }",
          "5056:                 packet->http_num_headers++;",
          "5057:             }",
          "5059:             if (packet->line[packet->parsed_lines].len > 6 &&",
          "5060:                 strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Host:\", 5) == 0) {",
          "5062:                 if (packet->line[packet->parsed_lines].ptr[5] == ' ') {",
          "5063:                     packet->host_line.ptr = &packet->line[packet->parsed_lines].ptr[6];",
          "5064:                     packet->host_line.len = packet->line[packet->parsed_lines].len - 6;",
          "5065:                 } else {",
          "5066:                     packet->host_line.ptr = &packet->line[packet->parsed_lines].ptr[5];",
          "5067:                     packet->host_line.len = packet->line[packet->parsed_lines].len - 5;",
          "5068:                 }",
          "5069:                 packet->http_num_headers++;",
          "5070:             }",
          "5072:             if (packet->line[packet->parsed_lines].len > 17 &&",
          "5073:                 strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"X-Forwarded-For:\", 16) == 0) {",
          "5075:                 if (packet->line[packet->parsed_lines].ptr[16] == ' ') {",
          "5076:                     packet->forwarded_line.ptr = &packet->line[packet->parsed_lines].ptr[17];",
          "5077:                     packet->forwarded_line.len = packet->line[packet->parsed_lines].len - 17;",
          "5078:                 } else {",
          "5079:                     packet->forwarded_line.ptr = &packet->line[packet->parsed_lines].ptr[16];",
          "5080:                     packet->forwarded_line.len = packet->line[packet->parsed_lines].len - 16;",
          "5081:                 }",
          "5082:                 packet->http_num_headers++;",
          "5083:             }",
          "5085:             if (packet->line[packet->parsed_lines].len > 14 &&",
          "5086:                 (strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Content-Type: \", 14) == 0 ||",
          "5087:                  strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Content-type: \", 14) == 0)) {",
          "5088:                 packet->content_line.ptr = &packet->line[packet->parsed_lines].ptr[14];",
          "5089:                 packet->content_line.len = packet->line[packet->parsed_lines].len - 14;",
          "5091:                 while ((packet->content_line.len > 0) && (packet->content_line.ptr[0] == ' '))",
          "5092:                     packet->content_line.len--, packet->content_line.ptr++;",
          "5094:                 packet->http_num_headers++;",
          "5095:             }",
          "5097:             if ((packet->content_line.len == 0) && (packet->line[packet->parsed_lines].len > 13) &&",
          "5098:                 (strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Content-type:\", 13) == 0)) {",
          "5099:                 packet->content_line.ptr = &packet->line[packet->parsed_lines].ptr[13];",
          "5100:                 packet->content_line.len = packet->line[packet->parsed_lines].len - 13;",
          "5101:                 packet->http_num_headers++;",
          "5102:             }",
          "5104:             if (packet->content_line.len > 0) {",
          "5106:                 char separator[] = {';', '\\r', '\\0'};",
          "5107:                 int i;",
          "5109:                 for (i = 0; separator[i] != '\\0'; i++) {",
          "5110:                     char *c = memchr((char *) packet->content_line.ptr, separator[i], packet->content_line.len);",
          "5112:                     if (c != NULL)",
          "5113:                         packet->content_line.len = c - (char *) packet->content_line.ptr;",
          "5114:                 }",
          "5115:             }",
          "5118:             if (packet->line[packet->parsed_lines].len > 8 &&",
          "5119:                 strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Accept: \", 8) == 0) {",
          "5120:                 packet->accept_line.ptr = &packet->line[packet->parsed_lines].ptr[8];",
          "5121:                 packet->accept_line.len = packet->line[packet->parsed_lines].len - 8;",
          "5122:                 packet->http_num_headers++;",
          "5123:             }",
          "5125:             if (packet->line[packet->parsed_lines].len > 9 &&",
          "5126:                 strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Referer: \", 9) == 0) {",
          "5127:                 packet->referer_line.ptr = &packet->line[packet->parsed_lines].ptr[9];",
          "5128:                 packet->referer_line.len = packet->line[packet->parsed_lines].len - 9;",
          "5129:                 packet->http_num_headers++;",
          "5130:             }",
          "5132:             if (packet->line[packet->parsed_lines].len > 12 &&",
          "5133:                 (strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"User-Agent: \", 12) == 0 ||",
          "5134:                  strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"User-agent: \", 12) == 0)) {",
          "5135:                 packet->user_agent_line.ptr = &packet->line[packet->parsed_lines].ptr[12];",
          "5136:                 packet->user_agent_line.len = packet->line[packet->parsed_lines].len - 12;",
          "5137:                 packet->http_num_headers++;",
          "5138:             }",
          "5140:             if (packet->line[packet->parsed_lines].len > 18 &&",
          "5141:                 strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Content-Encoding: \", 18) == 0) {",
          "5142:                 packet->http_encoding.ptr = &packet->line[packet->parsed_lines].ptr[18];",
          "5143:                 packet->http_encoding.len = packet->line[packet->parsed_lines].len - 18;",
          "5144:                 packet->http_num_headers++;",
          "5145:             }",
          "5147:             if (packet->line[packet->parsed_lines].len > 19 &&",
          "5148:                 strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Transfer-Encoding: \", 19) == 0) {",
          "5149:                 packet->http_transfer_encoding.ptr = &packet->line[packet->parsed_lines].ptr[19];",
          "5150:                 packet->http_transfer_encoding.len = packet->line[packet->parsed_lines].len - 19;",
          "5151:                 packet->http_num_headers++;",
          "5152:             }",
          "5154:             if (packet->line[packet->parsed_lines].len > 16 &&",
          "5155:                 ((strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Content-Length: \", 16) == 0) ||",
          "5156:                  (strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"content-length: \", 16) == 0))) {",
          "5157:                 packet->http_contentlen.ptr = &packet->line[packet->parsed_lines].ptr[16];",
          "5158:                 packet->http_contentlen.len = packet->line[packet->parsed_lines].len - 16;",
          "5159:                 packet->http_num_headers++;",
          "5160:             }",
          "5162:             if (packet->line[packet->parsed_lines].len > 8 &&",
          "5163:                 strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Cookie: \", 8) == 0) {",
          "5164:                 packet->http_cookie.ptr = &packet->line[packet->parsed_lines].ptr[8];",
          "5165:                 packet->http_cookie.len = packet->line[packet->parsed_lines].len - 8;",
          "5166:                 packet->http_num_headers++;",
          "5167:             }",
          "5169:             if (packet->line[packet->parsed_lines].len > 8 &&",
          "5170:                 strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Origin: \", 8) == 0) {",
          "5171:                 packet->http_origin.ptr = &packet->line[packet->parsed_lines].ptr[8];",
          "5172:                 packet->http_origin.len = packet->line[packet->parsed_lines].len - 8;",
          "5173:                 packet->http_num_headers++;",
          "5174:             }",
          "5176:             if (packet->line[packet->parsed_lines].len > 16 &&",
          "5177:                 strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"X-Session-Type: \", 16) == 0) {",
          "5178:                 packet->http_x_session_type.ptr = &packet->line[packet->parsed_lines].ptr[16];",
          "5179:                 packet->http_x_session_type.len = packet->line[packet->parsed_lines].len - 16;",
          "5180:                 packet->http_num_headers++;",
          "5181:             }",
          "5188:             if ((packet->line[packet->parsed_lines].len > 6 &&",
          "5189:                  (strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Date: \", 6) == 0 ||",
          "5190:                   strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Vary: \", 6) == 0 ||",
          "5191:                   strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"ETag: \", 6) == 0)) ||",
          "5192:                 (packet->line[packet->parsed_lines].len > 8 &&",
          "5193:                  strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Pragma: \", 8) == 0) ||",
          "5194:                 (packet->line[packet->parsed_lines].len > 9 &&",
          "5195:                  strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Expires: \", 9) == 0) ||",
          "5196:                 (packet->line[packet->parsed_lines].len > 12 &&",
          "5197:                  (strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Set-Cookie: \", 12) == 0 ||",
          "5198:                   strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Keep-Alive: \", 12) == 0 ||",
          "5199:                   strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Connection: \", 12) == 0)) ||",
          "5200:                 (packet->line[packet->parsed_lines].len > 15 &&",
          "5201:                  (strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Last-Modified: \", 15) == 0 ||",
          "5202:                   strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Accept-Ranges: \", 15) == 0)) ||",
          "5203:                 (packet->line[packet->parsed_lines].len > 17 &&",
          "5204:                  (strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Accept-Language: \", 17) == 0 ||",
          "5205:                   strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Accept-Encoding: \", 17) == 0)) ||",
          "5206:                 (packet->line[packet->parsed_lines].len > 27 &&",
          "5207:                  strncasecmp((const char *) packet->line[packet->parsed_lines].ptr,",
          "5208:                              \"Upgrade-Insecure-Requests: \", 27) == 0)) {",
          "5210:                 packet->http_num_headers++;",
          "5211:             }",
          "5213:             if (packet->line[packet->parsed_lines].len == 0) {",
          "5214:                 packet->empty_line_position = a;",
          "5215:                 packet->empty_line_position_set = 1;",
          "5216:             }",
          "5218:             if (packet->parsed_lines >= (NDPI_MAX_PARSE_LINES_PER_PACKET - 1))",
          "5219:                 return;",
          "5221:             packet->parsed_lines++;",
          "5222:             packet->line[packet->parsed_lines].ptr = &packet->payload[a + 2];",
          "5223:             packet->line[packet->parsed_lines].len = 0;",
          "5226:         }",
          "5227:     }",
          "5229:     if (packet->parsed_lines >= 1) {",
          "5230:         packet->line[packet->parsed_lines].len =",
          "5231:             (u_int16_t)(((unsigned long) &packet->payload[packet->payload_packet_len]) -",
          "5232:                         ((unsigned long) packet->line[packet->parsed_lines].ptr));",
          "5233:         packet->parsed_lines++;",
          "5234:     }",
          "5239: void ndpi_parse_packet_line_info_any(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow)",
          "5240: {",
          "5241:     struct ndpi_packet_struct *packet = &flow->packet;",
          "5242:     u_int32_t a;",
          "5243:     u_int16_t end = packet->payload_packet_len;",
          "5245:     if (packet->packet_lines_parsed_complete != 0)",
          "5246:         return;",
          "5248:     packet->packet_lines_parsed_complete = 1;",
          "5249:     packet->parsed_lines = 0;",
          "5251:     if (packet->payload_packet_len == 0)",
          "5252:         return;",
          "5254:     packet->line[packet->parsed_lines].ptr = packet->payload;",
          "5255:     packet->line[packet->parsed_lines].len = 0;",
          "5257:     for (a = 0; a < end; a++) {",
          "5258:         if (packet->payload[a] == 0x0a) {",
          "5259:             packet->line[packet->parsed_lines].len = (u_int16_t)(",
          "5260:                 ((unsigned long) &packet->payload[a]) - ((unsigned long) packet->line[packet->parsed_lines].ptr));",
          "5262:             if (a > 0 && packet->payload[a - 1] == 0x0d)",
          "5263:                 packet->line[packet->parsed_lines].len--;",
          "5265:             if (packet->parsed_lines >= (NDPI_MAX_PARSE_LINES_PER_PACKET - 1))",
          "5266:                 break;",
          "5268:             packet->parsed_lines++;",
          "5269:             packet->line[packet->parsed_lines].ptr = &packet->payload[a + 1];",
          "5270:             packet->line[packet->parsed_lines].len = 0;",
          "5272:             if ((a + 1) >= packet->payload_packet_len)",
          "5273:                 break;",
          "5276:         }",
          "5283:                                        u_int16_t counter)",
          "5284: {",
          "5285:     struct ndpi_packet_struct *packet = &flow->packet;",
          "5287:     NDPI_LOG_DBG2(ndpi_str, \"called ndpi_check_for_email_address\\n\");",
          "5289:     if (packet->payload_packet_len > counter && ((packet->payload[counter] >= 'a' && packet->payload[counter] <= 'z') ||",
          "5290:                                                  (packet->payload[counter] >= 'A' && packet->payload[counter] <= 'Z') ||",
          "5291:                                                  (packet->payload[counter] >= '0' && packet->payload[counter] <= '9') ||",
          "5292:                                                  packet->payload[counter] == '-' || packet->payload[counter] == '_')) {",
          "5293:         NDPI_LOG_DBG2(ndpi_str, \"first letter\\n\");",
          "5294:         counter++;",
          "5295:         while (packet->payload_packet_len > counter &&",
          "5296:                ((packet->payload[counter] >= 'a' && packet->payload[counter] <= 'z') ||",
          "5297:                 (packet->payload[counter] >= 'A' && packet->payload[counter] <= 'Z') ||",
          "5298:                 (packet->payload[counter] >= '0' && packet->payload[counter] <= '9') ||",
          "5299:                 packet->payload[counter] == '-' || packet->payload[counter] == '_' ||",
          "5300:                 packet->payload[counter] == '.')) {",
          "5301:             NDPI_LOG_DBG2(ndpi_str, \"further letter\\n\");",
          "5302:             counter++;",
          "5303:             if (packet->payload_packet_len > counter && packet->payload[counter] == '@') {",
          "5304:                 NDPI_LOG_DBG2(ndpi_str, \"@\\n\");",
          "5305:                 counter++;",
          "5306:                 while (packet->payload_packet_len > counter &&",
          "5307:                        ((packet->payload[counter] >= 'a' && packet->payload[counter] <= 'z') ||",
          "5308:                         (packet->payload[counter] >= 'A' && packet->payload[counter] <= 'Z') ||",
          "5309:                         (packet->payload[counter] >= '0' && packet->payload[counter] <= '9') ||",
          "5310:                         packet->payload[counter] == '-' || packet->payload[counter] == '_')) {",
          "5311:                     NDPI_LOG_DBG2(ndpi_str, \"letter\\n\");",
          "5312:                     counter++;",
          "5313:                     if (packet->payload_packet_len > counter && packet->payload[counter] == '.') {",
          "5314:                         NDPI_LOG_DBG2(ndpi_str, \".\\n\");",
          "5315:                         counter++;",
          "5316:                         if (packet->payload_packet_len > counter + 1 &&",
          "5317:                             ((packet->payload[counter] >= 'a' && packet->payload[counter] <= 'z') &&",
          "5318:                              (packet->payload[counter + 1] >= 'a' && packet->payload[counter + 1] <= 'z'))) {",
          "5319:                             NDPI_LOG_DBG2(ndpi_str, \"two letters\\n\");",
          "5320:                             counter += 2;",
          "5321:                             if (packet->payload_packet_len > counter &&",
          "5322:                                 (packet->payload[counter] == ' ' || packet->payload[counter] == ';')) {",
          "5323:                                 NDPI_LOG_DBG2(ndpi_str, \"whitespace1\\n\");",
          "5324:                                 return (counter);",
          "5325:                             } else if (packet->payload_packet_len > counter && packet->payload[counter] >= 'a' &&",
          "5326:                                        packet->payload[counter] <= 'z') {",
          "5327:                                 NDPI_LOG_DBG2(ndpi_str, \"one letter\\n\");",
          "5328:                                 counter++;",
          "5329:                                 if (packet->payload_packet_len > counter &&",
          "5330:                                     (packet->payload[counter] == ' ' || packet->payload[counter] == ';')) {",
          "5331:                                     NDPI_LOG_DBG2(ndpi_str, \"whitespace2\\n\");",
          "5332:                                     return (counter);",
          "5333:                                 } else if (packet->payload_packet_len > counter && packet->payload[counter] >= 'a' &&",
          "5334:                                            packet->payload[counter] <= 'z') {",
          "5335:                                     counter++;",
          "5336:                                     if (packet->payload_packet_len > counter &&",
          "5337:                                         (packet->payload[counter] == ' ' || packet->payload[counter] == ';')) {",
          "5338:                                         NDPI_LOG_DBG2(ndpi_str, \"whitespace3\\n\");",
          "5339:                                         return (counter);",
          "5340:                                     } else {",
          "5341:                                         return (0);",
          "5342:                                     }",
          "5343:                                 } else {",
          "5344:                                     return (0);",
          "5345:                                 }",
          "5346:                             } else {",
          "5347:                                 return (0);",
          "5348:                             }",
          "5349:                         } else {",
          "5350:                             return (0);",
          "5351:                         }",
          "5352:                     }",
          "5353:                 }",
          "5354:                 return (0);",
          "5355:             }",
          "5356:         }",
          "5357:     }",
          "5358:     return (0);",
          "5365:                                            const char **func, u_int32_t *line)",
          "5366: {",
          "5370:     if (ndpi_str->ndpi_debug_print_file != NULL)",
          "5373:     if (ndpi_str->ndpi_debug_print_function != NULL)",
          "5383:                                u_int16_t *l4_len_return, u_int8_t *l4_protocol_return, u_int32_t flags)",
          "5384: {",
          "5385:     return (ndpi_detection_get_l4_internal(NULL, l3, l3_len, l4_return, l4_len_return, l4_protocol_return, flags));",
          "5391:                                 u_int16_t upper_detected_protocol, u_int16_t lower_detected_protocol)",
          "5392: {",
          "5393:     struct ndpi_id_struct *src = flow->src, *dst = flow->dst;",
          "5395:     ndpi_int_change_protocol(ndpi_str, flow, upper_detected_protocol, lower_detected_protocol);",
          "5397:     if (src != NULL) {",
          "5398:         NDPI_ADD_PROTOCOL_TO_BITMASK(src->detected_protocol_bitmask, upper_detected_protocol);",
          "5400:         if (lower_detected_protocol != NDPI_PROTOCOL_UNKNOWN)",
          "5401:             NDPI_ADD_PROTOCOL_TO_BITMASK(src->detected_protocol_bitmask, lower_detected_protocol);",
          "5402:     }",
          "5404:     if (dst != NULL) {",
          "5405:         NDPI_ADD_PROTOCOL_TO_BITMASK(dst->detected_protocol_bitmask, upper_detected_protocol);",
          "5407:         if (lower_detected_protocol != NDPI_PROTOCOL_UNKNOWN)",
          "5408:             NDPI_ADD_PROTOCOL_TO_BITMASK(dst->detected_protocol_bitmask, lower_detected_protocol);",
          "5409:     }",
          "5414: u_int16_t ndpi_get_flow_masterprotocol(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow)",
          "5415: {",
          "5416:     return (flow->detected_protocol_stack[1]);",
          "5422:                                    u_int16_t upper_detected_protocol, u_int16_t lower_detected_protocol)",
          "5423: {",
          "5424:     if (!flow)",
          "5425:         return;",
          "5427:     flow->detected_protocol_stack[0] = upper_detected_protocol,",
          "5434:                                      u_int16_t upper_detected_protocol, u_int16_t lower_detected_protocol)",
          "5435: {",
          "5436:     struct ndpi_packet_struct *packet = &flow->packet;",
          "5442:     if (!packet)",
          "5443:         return;",
          "5445:     packet->detected_protocol_stack[0] = upper_detected_protocol,",
          "",
          "[Added Lines]",
          "4745:     ret = ndpi_detection_giveup(ndpi_str, flow, 0, &protocol_was_guessed);",
          "4746:   }",
          "4748:   if((ret.master_protocol == NDPI_PROTOCOL_UNKNOWN) && (ret.app_protocol != NDPI_PROTOCOL_UNKNOWN) &&",
          "4749:      (flow->guessed_host_protocol_id != NDPI_PROTOCOL_UNKNOWN)) {",
          "4750:     ret.master_protocol = ret.app_protocol;",
          "4751:     ret.app_protocol = flow->guessed_host_protocol_id;",
          "4752:   }",
          "4754:  invalidate_ptr:",
          "4756:     Invalidate packet memory to avoid accessing the pointers below",
          "4757:     when the packet is no longer accessible",
          "4759:   flow->packet.iph = NULL, flow->packet.tcp = NULL, flow->packet.udp = NULL, flow->packet.payload = NULL;",
          "4760:   ndpi_reset_packet_line_info(&flow->packet);",
          "4762:   return(ret);",
          "4767: u_int32_t ndpi_bytestream_to_number(const u_int8_t *str, u_int16_t max_chars_to_read, u_int16_t *bytes_read) {",
          "4768:   u_int32_t val;",
          "4769:   val = 0;",
          "4772:   while (*str >= '0' && *str <= '9' && max_chars_to_read > 0) {",
          "4773:     val *= 10;",
          "4774:     val += *str - '0';",
          "4775:     str++;",
          "4776:     max_chars_to_read = max_chars_to_read - 1;",
          "4778:   }",
          "4780:   return(val);",
          "4786: u_int32_t ndpi_bytestream_dec_or_hex_to_number(const u_int8_t *str, u_int16_t max_chars_to_read, u_int16_t *bytes_read) {",
          "4787:   u_int32_t val;",
          "4788:   val = 0;",
          "4789:   if(max_chars_to_read <= 2 || str[0] != '0' || str[1] != 'x') {",
          "4790:     return(ndpi_bytestream_to_number(str, max_chars_to_read, bytes_read));",
          "4791:   } else {",
          "4793:     str += 2;",
          "4794:     max_chars_to_read -= 2;",
          "4797:     while (max_chars_to_read > 0) {",
          "4798:       if(*str >= '0' && *str <= '9') {",
          "4799:  val *= 16;",
          "4800:  val += *str - '0';",
          "4801:       } else if(*str >= 'a' && *str <= 'f') {",
          "4802:  val *= 16;",
          "4803:  val += *str + 10 - 'a';",
          "4804:       } else if(*str >= 'A' && *str <= 'F') {",
          "4805:  val *= 16;",
          "4806:  val += *str + 10 - 'A';",
          "4807:       } else {",
          "4808:  break;",
          "4809:       }",
          "4810:       str++;",
          "4811:       max_chars_to_read = max_chars_to_read - 1;",
          "4813:     }",
          "4814:   }",
          "4816:   return(val);",
          "4823: u_int64_t ndpi_bytestream_to_number64(const u_int8_t *str, u_int16_t max_chars_to_read, u_int16_t *bytes_read) {",
          "4824:   u_int64_t val;",
          "4825:   val = 0;",
          "4827:   while (max_chars_to_read > 0 && *str >= '0' && *str <= '9') {",
          "4828:     val *= 10;",
          "4829:     val += *str - '0';",
          "4830:     str++;",
          "4831:     max_chars_to_read = max_chars_to_read - 1;",
          "4833:   }",
          "4834:   return(val);",
          "4840:                                                  u_int16_t *bytes_read) {",
          "4841:   u_int64_t val;",
          "4842:   val = 0;",
          "4843:   if(max_chars_to_read <= 2 || str[0] != '0' || str[1] != 'x') {",
          "4844:     return(ndpi_bytestream_to_number64(str, max_chars_to_read, bytes_read));",
          "4845:   } else {",
          "4847:     str += 2;",
          "4848:     max_chars_to_read -= 2;",
          "4850:     while (max_chars_to_read > 0) {",
          "4851:       if(*str >= '0' && *str <= '9') {",
          "4852:  val *= 16;",
          "4853:  val += *str - '0';",
          "4854:       } else if(*str >= 'a' && *str <= 'f') {",
          "4855:  val *= 16;",
          "4856:  val += *str + 10 - 'a';",
          "4857:       } else if(*str >= 'A' && *str <= 'F') {",
          "4858:  val *= 16;",
          "4859:  val += *str + 10 - 'A';",
          "4860:       } else {",
          "4861:  break;",
          "4862:       }",
          "4863:       str++;",
          "4864:       max_chars_to_read = max_chars_to_read - 1;",
          "4866:     }",
          "4867:   }",
          "4868:   return(val);",
          "4873: u_int32_t ndpi_bytestream_to_ipv4(const u_int8_t *str, u_int16_t max_chars_to_read, u_int16_t *bytes_read) {",
          "4874:   u_int32_t val;",
          "4875:   u_int16_t read = 0;",
          "4876:   u_int16_t oldread;",
          "4877:   u_int32_t c;",
          "4879:   oldread = read;",
          "4880:   c = ndpi_bytestream_to_number(str, max_chars_to_read, &read);",
          "4881:   if(c > 255 || oldread == read || max_chars_to_read == read || str[read] != '.')",
          "4882:     return(0);",
          "4883:   read++;",
          "4884:   val = c << 24;",
          "4885:   oldread = read;",
          "4886:   c = ndpi_bytestream_to_number(&str[read], max_chars_to_read - read, &read);",
          "4887:   if(c > 255 || oldread == read || max_chars_to_read == read || str[read] != '.')",
          "4888:     return(0);",
          "4889:   read++;",
          "4890:   val = val + (c << 16);",
          "4891:   oldread = read;",
          "4892:   c = ndpi_bytestream_to_number(&str[read], max_chars_to_read - read, &read);",
          "4893:   if(c > 255 || oldread == read || max_chars_to_read == read || str[read] != '.')",
          "4894:     return(0);",
          "4895:   read++;",
          "4896:   val = val + (c << 8);",
          "4897:   oldread = read;",
          "4898:   c = ndpi_bytestream_to_number(&str[read], max_chars_to_read - read, &read);",
          "4899:   if(c > 255 || oldread == read || max_chars_to_read == read)",
          "4900:     return(0);",
          "4901:   val = val + c;",
          "4905:   return(htonl(val));",
          "4911: void ndpi_parse_packet_line_info(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow) {",
          "4912:   u_int32_t a;",
          "4913:   struct ndpi_packet_struct *packet = &flow->packet;",
          "4915:   if(packet->packet_lines_parsed_complete != 0)",
          "4916:     return;",
          "4918:   packet->packet_lines_parsed_complete = 1;",
          "4919:   ndpi_reset_packet_line_info(packet);",
          "4921:   if((packet->payload_packet_len < 3) || (packet->payload == NULL))",
          "4922:     return;",
          "4924:   packet->line[packet->parsed_lines].ptr = packet->payload;",
          "4925:   packet->line[packet->parsed_lines].len = 0;",
          "4927:   for (a = 0; (a < packet->payload_packet_len) && (packet->parsed_lines < NDPI_MAX_PARSE_LINES_PER_PACKET); a++) {",
          "4928:     if((a + 1) >= packet->payload_packet_len)",
          "4931:     if(get_u_int16_t(packet->payload, a) ==",
          "4933:       packet->line[packet->parsed_lines].len = (u_int16_t)(",
          "4934:           ((unsigned long) &packet->payload[a]) - ((unsigned long) packet->line[packet->parsed_lines].ptr));",
          "4937:       if(packet->parsed_lines == 0 && packet->line[0].len >= NDPI_STATICSTRING_LEN(\"HTTP/1.X 200 \") &&",
          "4938:   strncasecmp((const char *) packet->line[0].ptr, \"HTTP/1.\", NDPI_STATICSTRING_LEN(\"HTTP/1.\")) == 0 &&",
          "4940:   packet->line[0].ptr[NDPI_STATICSTRING_LEN(\"HTTP/1.X \")] < '6') {",
          "4941:  packet->http_response.ptr = &packet->line[0].ptr[NDPI_STATICSTRING_LEN(\"HTTP/1.1 \")];",
          "4942:  packet->http_response.len = packet->line[0].len - NDPI_STATICSTRING_LEN(\"HTTP/1.1 \");",
          "4943:  packet->http_num_headers++;",
          "4946:  if(packet->payload_packet_len >= 12) {",
          "4947:    char buf[4];",
          "4950:    strncpy(buf, (char *) &packet->payload[9], 3);",
          "4951:    buf[3] = '\\0';",
          "4953:    flow->http.response_status_code = atoi(buf);",
          "4955:    if((flow->http.response_status_code < 100) || (flow->http.response_status_code > 509))",
          "4957:  }",
          "4958:       }",
          "4961:       if(packet->line[packet->parsed_lines].len > NDPI_STATICSTRING_LEN(\"Server:\") + 1 &&",
          "4962:   strncasecmp((const char *) packet->line[packet->parsed_lines].ptr,",
          "4963:        \"Server:\", NDPI_STATICSTRING_LEN(\"Server:\")) == 0) {",
          "4965:  if(packet->line[packet->parsed_lines].ptr[NDPI_STATICSTRING_LEN(\"Server:\")] == ' ') {",
          "4966:    packet->server_line.ptr =",
          "4967:      &packet->line[packet->parsed_lines].ptr[NDPI_STATICSTRING_LEN(\"Server:\") + 1];",
          "4968:    packet->server_line.len =",
          "4969:      packet->line[packet->parsed_lines].len - (NDPI_STATICSTRING_LEN(\"Server:\") + 1);",
          "4970:  } else {",
          "4971:    packet->server_line.ptr = &packet->line[packet->parsed_lines].ptr[NDPI_STATICSTRING_LEN(\"Server:\")];",
          "4972:    packet->server_line.len = packet->line[packet->parsed_lines].len - NDPI_STATICSTRING_LEN(\"Server:\");",
          "4973:  }",
          "4974:  packet->http_num_headers++;",
          "4975:       }",
          "4977:       if(packet->line[packet->parsed_lines].len > 6 &&",
          "4978:   strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Host:\", 5) == 0) {",
          "4980:  if(packet->line[packet->parsed_lines].ptr[5] == ' ') {",
          "4981:    packet->host_line.ptr = &packet->line[packet->parsed_lines].ptr[6];",
          "4982:    packet->host_line.len = packet->line[packet->parsed_lines].len - 6;",
          "4983:  } else {",
          "4984:    packet->host_line.ptr = &packet->line[packet->parsed_lines].ptr[5];",
          "4985:    packet->host_line.len = packet->line[packet->parsed_lines].len - 5;",
          "4986:  }",
          "4987:  packet->http_num_headers++;",
          "4988:       }",
          "4990:       if(packet->line[packet->parsed_lines].len > 17 &&",
          "4991:   strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"X-Forwarded-For:\", 16) == 0) {",
          "4993:  if(packet->line[packet->parsed_lines].ptr[16] == ' ') {",
          "4994:    packet->forwarded_line.ptr = &packet->line[packet->parsed_lines].ptr[17];",
          "4995:    packet->forwarded_line.len = packet->line[packet->parsed_lines].len - 17;",
          "4996:  } else {",
          "4997:    packet->forwarded_line.ptr = &packet->line[packet->parsed_lines].ptr[16];",
          "4998:    packet->forwarded_line.len = packet->line[packet->parsed_lines].len - 16;",
          "4999:  }",
          "5000:  packet->http_num_headers++;",
          "5001:       }",
          "5003:       if(packet->line[packet->parsed_lines].len > 14 &&",
          "5004:   (strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Content-Type: \", 14) == 0 ||",
          "5005:    strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Content-type: \", 14) == 0)) {",
          "5006:  packet->content_line.ptr = &packet->line[packet->parsed_lines].ptr[14];",
          "5007:  packet->content_line.len = packet->line[packet->parsed_lines].len - 14;",
          "5009:  while ((packet->content_line.len > 0) && (packet->content_line.ptr[0] == ' '))",
          "5010:    packet->content_line.len--, packet->content_line.ptr++;",
          "5012:  packet->http_num_headers++;",
          "5013:       }",
          "5015:       if((packet->content_line.len == 0) && (packet->line[packet->parsed_lines].len > 13) &&",
          "5016:   (strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Content-type:\", 13) == 0)) {",
          "5017:  packet->content_line.ptr = &packet->line[packet->parsed_lines].ptr[13];",
          "5018:  packet->content_line.len = packet->line[packet->parsed_lines].len - 13;",
          "5019:  packet->http_num_headers++;",
          "5020:       }",
          "5022:       if(packet->content_line.len > 0) {",
          "5024:  char separator[] = {';', '\\r', '\\0'};",
          "5025:  int i;",
          "5027:  for (i = 0; separator[i] != '\\0'; i++) {",
          "5028:    char *c = memchr((char *) packet->content_line.ptr, separator[i], packet->content_line.len);",
          "5030:    if(c != NULL)",
          "5031:      packet->content_line.len = c - (char *) packet->content_line.ptr;",
          "5032:  }",
          "5033:       }",
          "5036:       if(packet->line[packet->parsed_lines].len > 8 &&",
          "5037:   strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Accept: \", 8) == 0) {",
          "5038:  packet->accept_line.ptr = &packet->line[packet->parsed_lines].ptr[8];",
          "5039:  packet->accept_line.len = packet->line[packet->parsed_lines].len - 8;",
          "5040:  packet->http_num_headers++;",
          "5041:       }",
          "5043:       if(packet->line[packet->parsed_lines].len > 9 &&",
          "5044:   strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Referer: \", 9) == 0) {",
          "5045:  packet->referer_line.ptr = &packet->line[packet->parsed_lines].ptr[9];",
          "5046:  packet->referer_line.len = packet->line[packet->parsed_lines].len - 9;",
          "5047:  packet->http_num_headers++;",
          "5048:       }",
          "5050:       if(packet->line[packet->parsed_lines].len > 12 &&",
          "5051:   (strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"User-Agent: \", 12) == 0 ||",
          "5052:    strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"User-agent: \", 12) == 0)) {",
          "5053:  packet->user_agent_line.ptr = &packet->line[packet->parsed_lines].ptr[12];",
          "5054:  packet->user_agent_line.len = packet->line[packet->parsed_lines].len - 12;",
          "5055:  packet->http_num_headers++;",
          "5056:       }",
          "5058:       if(packet->line[packet->parsed_lines].len > 18 &&",
          "5059:   strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Content-Encoding: \", 18) == 0) {",
          "5060:  packet->http_encoding.ptr = &packet->line[packet->parsed_lines].ptr[18];",
          "5061:  packet->http_encoding.len = packet->line[packet->parsed_lines].len - 18;",
          "5062:  packet->http_num_headers++;",
          "5063:       }",
          "5065:       if(packet->line[packet->parsed_lines].len > 19 &&",
          "5066:   strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Transfer-Encoding: \", 19) == 0) {",
          "5067:  packet->http_transfer_encoding.ptr = &packet->line[packet->parsed_lines].ptr[19];",
          "5068:  packet->http_transfer_encoding.len = packet->line[packet->parsed_lines].len - 19;",
          "5069:  packet->http_num_headers++;",
          "5070:       }",
          "5072:       if(packet->line[packet->parsed_lines].len > 16 &&",
          "5073:   ((strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Content-Length: \", 16) == 0) ||",
          "5074:    (strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"content-length: \", 16) == 0))) {",
          "5075:  packet->http_contentlen.ptr = &packet->line[packet->parsed_lines].ptr[16];",
          "5076:  packet->http_contentlen.len = packet->line[packet->parsed_lines].len - 16;",
          "5077:  packet->http_num_headers++;",
          "5078:       }",
          "5080:       if(packet->line[packet->parsed_lines].len > 8 &&",
          "5081:   strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Cookie: \", 8) == 0) {",
          "5082:  packet->http_cookie.ptr = &packet->line[packet->parsed_lines].ptr[8];",
          "5083:  packet->http_cookie.len = packet->line[packet->parsed_lines].len - 8;",
          "5084:  packet->http_num_headers++;",
          "5085:       }",
          "5087:       if(packet->line[packet->parsed_lines].len > 8 &&",
          "5088:   strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Origin: \", 8) == 0) {",
          "5089:  packet->http_origin.ptr = &packet->line[packet->parsed_lines].ptr[8];",
          "5090:  packet->http_origin.len = packet->line[packet->parsed_lines].len - 8;",
          "5091:  packet->http_num_headers++;",
          "5092:       }",
          "5094:       if(packet->line[packet->parsed_lines].len > 16 &&",
          "5095:   strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"X-Session-Type: \", 16) == 0) {",
          "5096:  packet->http_x_session_type.ptr = &packet->line[packet->parsed_lines].ptr[16];",
          "5097:  packet->http_x_session_type.len = packet->line[packet->parsed_lines].len - 16;",
          "5098:  packet->http_num_headers++;",
          "5099:       }",
          "5106:       if((packet->line[packet->parsed_lines].len > 6 &&",
          "5107:    (strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Date: \", 6) == 0 ||",
          "5108:     strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Vary: \", 6) == 0 ||",
          "5109:     strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"ETag: \", 6) == 0)) ||",
          "5110:   (packet->line[packet->parsed_lines].len > 8 &&",
          "5111:    strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Pragma: \", 8) == 0) ||",
          "5112:   (packet->line[packet->parsed_lines].len > 9 &&",
          "5113:    strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Expires: \", 9) == 0) ||",
          "5114:   (packet->line[packet->parsed_lines].len > 12 &&",
          "5115:    (strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Set-Cookie: \", 12) == 0 ||",
          "5116:     strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Keep-Alive: \", 12) == 0 ||",
          "5117:     strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Connection: \", 12) == 0)) ||",
          "5118:   (packet->line[packet->parsed_lines].len > 15 &&",
          "5119:    (strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Last-Modified: \", 15) == 0 ||",
          "5120:     strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Accept-Ranges: \", 15) == 0)) ||",
          "5121:   (packet->line[packet->parsed_lines].len > 17 &&",
          "5122:    (strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Accept-Language: \", 17) == 0 ||",
          "5123:     strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Accept-Encoding: \", 17) == 0)) ||",
          "5124:   (packet->line[packet->parsed_lines].len > 27 &&",
          "5125:    strncasecmp((const char *) packet->line[packet->parsed_lines].ptr,",
          "5126:         \"Upgrade-Insecure-Requests: \", 27) == 0)) {",
          "5128:  packet->http_num_headers++;",
          "5129:       }",
          "5131:       if(packet->line[packet->parsed_lines].len == 0) {",
          "5132:  packet->empty_line_position = a;",
          "5133:  packet->empty_line_position_set = 1;",
          "5134:       }",
          "5136:       if(packet->parsed_lines >= (NDPI_MAX_PARSE_LINES_PER_PACKET - 1))",
          "5137:  return;",
          "5139:       packet->parsed_lines++;",
          "5140:       packet->line[packet->parsed_lines].ptr = &packet->payload[a + 2];",
          "5141:       packet->line[packet->parsed_lines].len = 0;",
          "5144:     }",
          "5145:   }",
          "5147:   if(packet->parsed_lines >= 1) {",
          "5148:     packet->line[packet->parsed_lines].len =",
          "5149:       (u_int16_t)(((unsigned long) &packet->payload[packet->payload_packet_len]) -",
          "5150:     ((unsigned long) packet->line[packet->parsed_lines].ptr));",
          "5151:     packet->parsed_lines++;",
          "5152:   }",
          "5157: void ndpi_parse_packet_line_info_any(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow) {",
          "5158:   struct ndpi_packet_struct *packet = &flow->packet;",
          "5159:   u_int32_t a;",
          "5160:   u_int16_t end = packet->payload_packet_len;",
          "5162:   if(packet->packet_lines_parsed_complete != 0)",
          "5163:     return;",
          "5165:   packet->packet_lines_parsed_complete = 1;",
          "5166:   packet->parsed_lines = 0;",
          "5168:   if(packet->payload_packet_len == 0)",
          "5169:     return;",
          "5171:   packet->line[packet->parsed_lines].ptr = packet->payload;",
          "5172:   packet->line[packet->parsed_lines].len = 0;",
          "5174:   for (a = 0; a < end; a++) {",
          "5175:     if(packet->payload[a] == 0x0a) {",
          "5176:       packet->line[packet->parsed_lines].len = (u_int16_t)(",
          "5177:           ((unsigned long) &packet->payload[a]) - ((unsigned long) packet->line[packet->parsed_lines].ptr));",
          "5179:       if(a > 0 && packet->payload[a - 1] == 0x0d)",
          "5180:  packet->line[packet->parsed_lines].len--;",
          "5182:       if(packet->parsed_lines >= (NDPI_MAX_PARSE_LINES_PER_PACKET - 1))",
          "5183:  break;",
          "5185:       packet->parsed_lines++;",
          "5186:       packet->line[packet->parsed_lines].ptr = &packet->payload[a + 1];",
          "5187:       packet->line[packet->parsed_lines].len = 0;",
          "5189:       if((a + 1) >= packet->payload_packet_len)",
          "5190:  break;",
          "5194:   }",
          "5200:                                        u_int16_t counter) {",
          "5201:   struct ndpi_packet_struct *packet = &flow->packet;",
          "5203:   NDPI_LOG_DBG2(ndpi_str, \"called ndpi_check_for_email_address\\n\");",
          "5205:   if(packet->payload_packet_len > counter && ((packet->payload[counter] >= 'a' && packet->payload[counter] <= 'z') ||",
          "5206:            (packet->payload[counter] >= 'A' && packet->payload[counter] <= 'Z') ||",
          "5207:            (packet->payload[counter] >= '0' && packet->payload[counter] <= '9') ||",
          "5208:            packet->payload[counter] == '-' || packet->payload[counter] == '_')) {",
          "5209:     NDPI_LOG_DBG2(ndpi_str, \"first letter\\n\");",
          "5210:     counter++;",
          "5211:     while (packet->payload_packet_len > counter &&",
          "5212:     ((packet->payload[counter] >= 'a' && packet->payload[counter] <= 'z') ||",
          "5213:      (packet->payload[counter] >= 'A' && packet->payload[counter] <= 'Z') ||",
          "5214:      (packet->payload[counter] >= '0' && packet->payload[counter] <= '9') ||",
          "5215:      packet->payload[counter] == '-' || packet->payload[counter] == '_' ||",
          "5216:      packet->payload[counter] == '.')) {",
          "5217:       NDPI_LOG_DBG2(ndpi_str, \"further letter\\n\");",
          "5218:       counter++;",
          "5219:       if(packet->payload_packet_len > counter && packet->payload[counter] == '@') {",
          "5220:  NDPI_LOG_DBG2(ndpi_str, \"@\\n\");",
          "5221:  counter++;",
          "5222:  while (packet->payload_packet_len > counter &&",
          "5223:         ((packet->payload[counter] >= 'a' && packet->payload[counter] <= 'z') ||",
          "5224:   (packet->payload[counter] >= 'A' && packet->payload[counter] <= 'Z') ||",
          "5225:   (packet->payload[counter] >= '0' && packet->payload[counter] <= '9') ||",
          "5226:   packet->payload[counter] == '-' || packet->payload[counter] == '_')) {",
          "5227:    NDPI_LOG_DBG2(ndpi_str, \"letter\\n\");",
          "5228:    counter++;",
          "5229:    if(packet->payload_packet_len > counter && packet->payload[counter] == '.') {",
          "5230:      NDPI_LOG_DBG2(ndpi_str, \".\\n\");",
          "5231:      counter++;",
          "5232:      if(packet->payload_packet_len > counter + 1 &&",
          "5233:         ((packet->payload[counter] >= 'a' && packet->payload[counter] <= 'z') &&",
          "5234:   (packet->payload[counter + 1] >= 'a' && packet->payload[counter + 1] <= 'z'))) {",
          "5235:        NDPI_LOG_DBG2(ndpi_str, \"two letters\\n\");",
          "5236:        counter += 2;",
          "5237:        if(packet->payload_packet_len > counter &&",
          "5238:    (packet->payload[counter] == ' ' || packet->payload[counter] == ';')) {",
          "5239:   NDPI_LOG_DBG2(ndpi_str, \"whitespace1\\n\");",
          "5240:   return(counter);",
          "5241:        } else if(packet->payload_packet_len > counter && packet->payload[counter] >= 'a' &&",
          "5242:    packet->payload[counter] <= 'z') {",
          "5243:   NDPI_LOG_DBG2(ndpi_str, \"one letter\\n\");",
          "5244:   counter++;",
          "5245:   if(packet->payload_packet_len > counter &&",
          "5246:      (packet->payload[counter] == ' ' || packet->payload[counter] == ';')) {",
          "5247:     NDPI_LOG_DBG2(ndpi_str, \"whitespace2\\n\");",
          "5248:     return(counter);",
          "5249:   } else if(packet->payload_packet_len > counter && packet->payload[counter] >= 'a' &&",
          "5250:      packet->payload[counter] <= 'z') {",
          "5251:     counter++;",
          "5252:     if(packet->payload_packet_len > counter &&",
          "5253:        (packet->payload[counter] == ' ' || packet->payload[counter] == ';')) {",
          "5254:       NDPI_LOG_DBG2(ndpi_str, \"whitespace3\\n\");",
          "5255:       return(counter);",
          "5256:     } else {",
          "5257:       return(0);",
          "5258:     }",
          "5259:   } else {",
          "5260:     return(0);",
          "5261:   }",
          "5262:        } else {",
          "5263:   return(0);",
          "5264:        }",
          "5265:      } else {",
          "5266:        return(0);",
          "5267:      }",
          "5268:    }",
          "5269:  }",
          "5270:  return(0);",
          "5271:       }",
          "5272:     }",
          "5273:   }",
          "5274:   return(0);",
          "5281:                                            const char **func, u_int32_t *line) {",
          "5285:   if(ndpi_str->ndpi_debug_print_file != NULL)",
          "5288:   if(ndpi_str->ndpi_debug_print_function != NULL)",
          "5298:                                u_int16_t *l4_len_return, u_int8_t *l4_protocol_return, u_int32_t flags) {",
          "5299:   return(ndpi_detection_get_l4_internal(NULL, l3, l3_len, l4_return, l4_len_return, l4_protocol_return, flags));",
          "5305:                                 u_int16_t upper_detected_protocol, u_int16_t lower_detected_protocol) {",
          "5306:   struct ndpi_id_struct *src = flow->src, *dst = flow->dst;",
          "5308:   ndpi_int_change_protocol(ndpi_str, flow, upper_detected_protocol, lower_detected_protocol);",
          "5310:   if(src != NULL) {",
          "5311:     NDPI_ADD_PROTOCOL_TO_BITMASK(src->detected_protocol_bitmask, upper_detected_protocol);",
          "5313:     if(lower_detected_protocol != NDPI_PROTOCOL_UNKNOWN)",
          "5314:       NDPI_ADD_PROTOCOL_TO_BITMASK(src->detected_protocol_bitmask, lower_detected_protocol);",
          "5315:   }",
          "5317:   if(dst != NULL) {",
          "5318:     NDPI_ADD_PROTOCOL_TO_BITMASK(dst->detected_protocol_bitmask, upper_detected_protocol);",
          "5320:     if(lower_detected_protocol != NDPI_PROTOCOL_UNKNOWN)",
          "5321:       NDPI_ADD_PROTOCOL_TO_BITMASK(dst->detected_protocol_bitmask, lower_detected_protocol);",
          "5322:   }",
          "5327: u_int16_t ndpi_get_flow_masterprotocol(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow) {",
          "5328:   return(flow->detected_protocol_stack[1]);",
          "5334:                                    u_int16_t upper_detected_protocol, u_int16_t lower_detected_protocol) {",
          "5335:   if(!flow)",
          "5336:     return;",
          "5338:   flow->detected_protocol_stack[0] = upper_detected_protocol,",
          "5345:                                      u_int16_t upper_detected_protocol, u_int16_t lower_detected_protocol) {",
          "5346:   struct ndpi_packet_struct *packet = &flow->packet;",
          "5352:   if(!packet)",
          "5353:     return;",
          "5355:   packet->detected_protocol_stack[0] = upper_detected_protocol,",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "5457: void ndpi_int_change_protocol(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,",
          "5474:     }",
          "5478: }",
          "5482: void ndpi_int_change_category(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,",
          "5486: }",
          "5497: }",
          "5509: }",
          "5516: }",
          "5520: #ifdef CODE_UNUSED",
          "5525: }",
          "5526: #endif",
          "",
          "[Removed Lines]",
          "5458:                               u_int16_t upper_detected_protocol, u_int16_t lower_detected_protocol)",
          "5459: {",
          "5460:     if ((upper_detected_protocol == NDPI_PROTOCOL_UNKNOWN) && (lower_detected_protocol != NDPI_PROTOCOL_UNKNOWN))",
          "5461:         upper_detected_protocol = lower_detected_protocol;",
          "5463:     if (upper_detected_protocol == lower_detected_protocol)",
          "5464:         lower_detected_protocol = NDPI_PROTOCOL_UNKNOWN;",
          "5466:     if ((upper_detected_protocol != NDPI_PROTOCOL_UNKNOWN) && (lower_detected_protocol == NDPI_PROTOCOL_UNKNOWN)) {",
          "5467:         if ((flow->guessed_host_protocol_id != NDPI_PROTOCOL_UNKNOWN) &&",
          "5468:             (upper_detected_protocol != flow->guessed_host_protocol_id)) {",
          "5469:             if (ndpi_str->proto_defaults[upper_detected_protocol].can_have_a_subprotocol) {",
          "5470:                 lower_detected_protocol = upper_detected_protocol;",
          "5471:                 upper_detected_protocol = flow->guessed_host_protocol_id;",
          "5472:             }",
          "5473:         }",
          "5476:     ndpi_int_change_flow_protocol(ndpi_str, flow, upper_detected_protocol, lower_detected_protocol);",
          "5477:     ndpi_int_change_packet_protocol(ndpi_str, flow, upper_detected_protocol, lower_detected_protocol);",
          "5483:                               ndpi_protocol_category_t protocol_category)",
          "5484: {",
          "5485:     flow->category = protocol_category;",
          "5491: void ndpi_int_reset_packet_protocol(struct ndpi_packet_struct *packet)",
          "5492: {",
          "5493:     int a;",
          "5495:     for (a = 0; a < NDPI_PROTOCOL_SIZE; a++)",
          "5496:         packet->detected_protocol_stack[a] = NDPI_PROTOCOL_UNKNOWN;",
          "5501: void ndpi_int_reset_protocol(struct ndpi_flow_struct *flow)",
          "5502: {",
          "5503:     if (flow) {",
          "5504:         int a;",
          "5506:         for (a = 0; a < NDPI_PROTOCOL_SIZE; a++)",
          "5507:             flow->detected_protocol_stack[a] = NDPI_PROTOCOL_UNKNOWN;",
          "5508:     }",
          "5513: void NDPI_PROTOCOL_IP_clear(ndpi_ip_addr_t *ip)",
          "5514: {",
          "5515:     memset(ip, 0, sizeof(ndpi_ip_addr_t));",
          "5522: int NDPI_PROTOCOL_IP_is_set(const ndpi_ip_addr_t *ip)",
          "5523: {",
          "5524:     return (memcmp(ip, \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\", sizeof(ndpi_ip_addr_t)) != 0);",
          "",
          "[Added Lines]",
          "5368:                               u_int16_t upper_detected_protocol, u_int16_t lower_detected_protocol) {",
          "5369:   if((upper_detected_protocol == NDPI_PROTOCOL_UNKNOWN) && (lower_detected_protocol != NDPI_PROTOCOL_UNKNOWN))",
          "5370:     upper_detected_protocol = lower_detected_protocol;",
          "5372:   if(upper_detected_protocol == lower_detected_protocol)",
          "5373:     lower_detected_protocol = NDPI_PROTOCOL_UNKNOWN;",
          "5375:   if((upper_detected_protocol != NDPI_PROTOCOL_UNKNOWN) && (lower_detected_protocol == NDPI_PROTOCOL_UNKNOWN)) {",
          "5376:     if((flow->guessed_host_protocol_id != NDPI_PROTOCOL_UNKNOWN) &&",
          "5377:        (upper_detected_protocol != flow->guessed_host_protocol_id)) {",
          "5378:       if(ndpi_str->proto_defaults[upper_detected_protocol].can_have_a_subprotocol) {",
          "5379:  lower_detected_protocol = upper_detected_protocol;",
          "5380:  upper_detected_protocol = flow->guessed_host_protocol_id;",
          "5381:       }",
          "5383:   }",
          "5385:   ndpi_int_change_flow_protocol(ndpi_str, flow, upper_detected_protocol, lower_detected_protocol);",
          "5386:   ndpi_int_change_packet_protocol(ndpi_str, flow, upper_detected_protocol, lower_detected_protocol);",
          "5392:                               ndpi_protocol_category_t protocol_category) {",
          "5393:   flow->category = protocol_category;",
          "5399: void ndpi_int_reset_packet_protocol(struct ndpi_packet_struct *packet) {",
          "5400:   int a;",
          "5402:   for (a = 0; a < NDPI_PROTOCOL_SIZE; a++)",
          "5403:     packet->detected_protocol_stack[a] = NDPI_PROTOCOL_UNKNOWN;",
          "5408: void ndpi_int_reset_protocol(struct ndpi_flow_struct *flow) {",
          "5409:   if(flow) {",
          "5410:     int a;",
          "5412:     for (a = 0; a < NDPI_PROTOCOL_SIZE; a++)",
          "5413:       flow->detected_protocol_stack[a] = NDPI_PROTOCOL_UNKNOWN;",
          "5414:   }",
          "5419: void NDPI_PROTOCOL_IP_clear(ndpi_ip_addr_t *ip) {",
          "5420:   memset(ip, 0, sizeof(ndpi_ip_addr_t));",
          "5427: int NDPI_PROTOCOL_IP_is_set(const ndpi_ip_addr_t *ip) {",
          "5428:   return(memcmp(ip, \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\", sizeof(ndpi_ip_addr_t)) != 0);",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "5534: #ifdef NDPI_DETECTION_SUPPORT_IPV6",
          "5546: #endif",
          "5552: }",
          "5559: #ifdef NDPI_DETECTION_SUPPORT_IPV6",
          "5571: #endif",
          "5578: }",
          "5588: #ifdef NDPI_DETECTION_SUPPORT_IPV6",
          "5598: #endif",
          "5602: }",
          "5612: #ifdef NDPI_DETECTION_SUPPORT_IPV6",
          "5622: #endif",
          "5625: }",
          "5631: #ifdef NDPI_DETECTION_SUPPORT_IPV6",
          "5634: #else",
          "5636: #endif",
          "5637: }",
          "5645: #ifdef NDPI_DETECTION_SUPPORT_IPV6",
          "5652: #endif",
          "5657: }",
          "5670: #ifdef NDPI_DETECTION_SUPPORT_IPV6",
          "5674: #endif",
          "5678: }",
          "5686: }",
          "5693: }",
          "5700: }",
          "",
          "[Removed Lines]",
          "5532: int ndpi_packet_src_ip_eql(const struct ndpi_packet_struct *packet, const ndpi_ip_addr_t *ip)",
          "5533: {",
          "5537:     if (packet->iphv6 != NULL) {",
          "5538:         if (packet->iphv6->ip6_src.u6_addr.u6_addr32[0] == ip->ipv6.u6_addr.u6_addr32[0] &&",
          "5539:             packet->iphv6->ip6_src.u6_addr.u6_addr32[1] == ip->ipv6.u6_addr.u6_addr32[1] &&",
          "5540:             packet->iphv6->ip6_src.u6_addr.u6_addr32[2] == ip->ipv6.u6_addr.u6_addr32[2] &&",
          "5541:             packet->iphv6->ip6_src.u6_addr.u6_addr32[3] == ip->ipv6.u6_addr.u6_addr32[3])",
          "5542:             return (1);",
          "5544:         return (0);",
          "5545:     }",
          "5549:     if (packet->iph->saddr == ip->ipv4)",
          "5550:         return (1);",
          "5551:     return (0);",
          "5557: int ndpi_packet_dst_ip_eql(const struct ndpi_packet_struct *packet, const ndpi_ip_addr_t *ip)",
          "5558: {",
          "5562:     if (packet->iphv6 != NULL) {",
          "5563:         if (packet->iphv6->ip6_dst.u6_addr.u6_addr32[0] == ip->ipv6.u6_addr.u6_addr32[0] &&",
          "5564:             packet->iphv6->ip6_dst.u6_addr.u6_addr32[1] == ip->ipv6.u6_addr.u6_addr32[1] &&",
          "5565:             packet->iphv6->ip6_dst.u6_addr.u6_addr32[2] == ip->ipv6.u6_addr.u6_addr32[2] &&",
          "5566:             packet->iphv6->ip6_dst.u6_addr.u6_addr32[3] == ip->ipv6.u6_addr.u6_addr32[3])",
          "5567:             return (1);",
          "5569:         return (0);",
          "5570:     }",
          "5574:     if (packet->iph->saddr == ip->ipv4)",
          "5575:         return (1);",
          "5577:     return (0);",
          "5584: void ndpi_packet_src_ip_get(const struct ndpi_packet_struct *packet, ndpi_ip_addr_t *ip)",
          "5585: {",
          "5586:     NDPI_PROTOCOL_IP_clear(ip);",
          "5591:     if (packet->iphv6 != NULL) {",
          "5592:         ip->ipv6.u6_addr.u6_addr32[0] = packet->iphv6->ip6_src.u6_addr.u6_addr32[0];",
          "5593:         ip->ipv6.u6_addr.u6_addr32[1] = packet->iphv6->ip6_src.u6_addr.u6_addr32[1];",
          "5594:         ip->ipv6.u6_addr.u6_addr32[2] = packet->iphv6->ip6_src.u6_addr.u6_addr32[2];",
          "5595:         ip->ipv6.u6_addr.u6_addr32[3] = packet->iphv6->ip6_src.u6_addr.u6_addr32[3];",
          "5597:     } else",
          "5601:         ip->ipv4 = packet->iph->saddr;",
          "5608: void ndpi_packet_dst_ip_get(const struct ndpi_packet_struct *packet, ndpi_ip_addr_t *ip)",
          "5609: {",
          "5610:     NDPI_PROTOCOL_IP_clear(ip);",
          "5614:     if (packet->iphv6 != NULL) {",
          "5615:         ip->ipv6.u6_addr.u6_addr32[0] = packet->iphv6->ip6_dst.u6_addr.u6_addr32[0];",
          "5616:         ip->ipv6.u6_addr.u6_addr32[1] = packet->iphv6->ip6_dst.u6_addr.u6_addr32[1];",
          "5617:         ip->ipv6.u6_addr.u6_addr32[2] = packet->iphv6->ip6_dst.u6_addr.u6_addr32[2];",
          "5618:         ip->ipv6.u6_addr.u6_addr32[3] = packet->iphv6->ip6_dst.u6_addr.u6_addr32[3];",
          "5620:     } else",
          "5624:         ip->ipv4 = packet->iph->daddr;",
          "5629: u_int8_t ndpi_is_ipv6(const ndpi_ip_addr_t *ip)",
          "5630: {",
          "5632:     return (ip->ipv6.u6_addr.u6_addr32[1] != 0 || ip->ipv6.u6_addr.u6_addr32[2] != 0 ||",
          "5633:             ip->ipv6.u6_addr.u6_addr32[3] != 0);",
          "5635:     return (0);",
          "5641: char *ndpi_get_ip_string(const ndpi_ip_addr_t *ip, char *buf, u_int buf_len)",
          "5642: {",
          "5643:     const u_int8_t *a = (const u_int8_t *) &ip->ipv4;",
          "5646:     if (ndpi_is_ipv6(ip)) {",
          "5647:         if (inet_ntop(AF_INET6, &ip->ipv6.u6_addr, buf, buf_len) == NULL)",
          "5648:             buf[0] = '\\0';",
          "5650:         return (buf);",
          "5651:     }",
          "5654:     snprintf(buf, buf_len, \"%u.%u.%u.%u\", a[0], a[1], a[2], a[3]);",
          "5656:     return (buf);",
          "5662: int ndpi_parse_ip_string(const char *ip_str, ndpi_ip_addr_t *parsed_ip)",
          "5663: {",
          "5664:     int rv = -1;",
          "5665:     memset(parsed_ip, 0, sizeof(*parsed_ip));",
          "5667:     if (strchr(ip_str, '.')) {",
          "5668:         if (inet_pton(AF_INET, ip_str, &parsed_ip->ipv4) > 0)",
          "5669:             rv = 4;",
          "5671:     } else {",
          "5672:         if (inet_pton(AF_INET6, ip_str, &parsed_ip->ipv6) > 0)",
          "5673:             rv = 6;",
          "5675:     }",
          "5677:     return (rv);",
          "5682: u_int16_t ntohs_ndpi_bytestream_to_number(const u_int8_t *str, u_int16_t max_chars_to_read, u_int16_t *bytes_read)",
          "5683: {",
          "5684:     u_int16_t val = ndpi_bytestream_to_number(str, max_chars_to_read, bytes_read);",
          "5685:     return (ntohs(val));",
          "5690: u_int8_t ndpi_is_proto(ndpi_protocol proto, u_int16_t p)",
          "5691: {",
          "5692:     return (((proto.app_protocol == p) || (proto.master_protocol == p)) ? 1 : 0);",
          "5697: u_int16_t ndpi_get_lower_proto(ndpi_protocol proto)",
          "5698: {",
          "5699:     return ((proto.master_protocol != NDPI_PROTOCOL_UNKNOWN) ? proto.master_protocol : proto.app_protocol);",
          "",
          "[Added Lines]",
          "5436: int ndpi_packet_src_ip_eql(const struct ndpi_packet_struct *packet, const ndpi_ip_addr_t *ip) {",
          "5440:   if(packet->iphv6 != NULL) {",
          "5441:     if(packet->iphv6->ip6_src.u6_addr.u6_addr32[0] == ip->ipv6.u6_addr.u6_addr32[0] &&",
          "5442:        packet->iphv6->ip6_src.u6_addr.u6_addr32[1] == ip->ipv6.u6_addr.u6_addr32[1] &&",
          "5443:        packet->iphv6->ip6_src.u6_addr.u6_addr32[2] == ip->ipv6.u6_addr.u6_addr32[2] &&",
          "5444:        packet->iphv6->ip6_src.u6_addr.u6_addr32[3] == ip->ipv6.u6_addr.u6_addr32[3])",
          "5445:       return(1);",
          "5447:     return(0);",
          "5448:   }",
          "5452:   if(packet->iph->saddr == ip->ipv4)",
          "5453:     return(1);",
          "5454:   return(0);",
          "5460: int ndpi_packet_dst_ip_eql(const struct ndpi_packet_struct *packet, const ndpi_ip_addr_t *ip) {",
          "5464:   if(packet->iphv6 != NULL) {",
          "5465:     if(packet->iphv6->ip6_dst.u6_addr.u6_addr32[0] == ip->ipv6.u6_addr.u6_addr32[0] &&",
          "5466:        packet->iphv6->ip6_dst.u6_addr.u6_addr32[1] == ip->ipv6.u6_addr.u6_addr32[1] &&",
          "5467:        packet->iphv6->ip6_dst.u6_addr.u6_addr32[2] == ip->ipv6.u6_addr.u6_addr32[2] &&",
          "5468:        packet->iphv6->ip6_dst.u6_addr.u6_addr32[3] == ip->ipv6.u6_addr.u6_addr32[3])",
          "5469:       return(1);",
          "5471:     return(0);",
          "5472:   }",
          "5476:   if(packet->iph->saddr == ip->ipv4)",
          "5477:     return(1);",
          "5479:   return(0);",
          "5486: void ndpi_packet_src_ip_get(const struct ndpi_packet_struct *packet, ndpi_ip_addr_t *ip) {",
          "5487:   NDPI_PROTOCOL_IP_clear(ip);",
          "5492:   if(packet->iphv6 != NULL) {",
          "5493:     ip->ipv6.u6_addr.u6_addr32[0] = packet->iphv6->ip6_src.u6_addr.u6_addr32[0];",
          "5494:     ip->ipv6.u6_addr.u6_addr32[1] = packet->iphv6->ip6_src.u6_addr.u6_addr32[1];",
          "5495:     ip->ipv6.u6_addr.u6_addr32[2] = packet->iphv6->ip6_src.u6_addr.u6_addr32[2];",
          "5496:     ip->ipv6.u6_addr.u6_addr32[3] = packet->iphv6->ip6_src.u6_addr.u6_addr32[3];",
          "5498:   } else",
          "5502:     ip->ipv4 = packet->iph->saddr;",
          "5509: void ndpi_packet_dst_ip_get(const struct ndpi_packet_struct *packet, ndpi_ip_addr_t *ip) {",
          "5510:   NDPI_PROTOCOL_IP_clear(ip);",
          "5514:   if(packet->iphv6 != NULL) {",
          "5515:     ip->ipv6.u6_addr.u6_addr32[0] = packet->iphv6->ip6_dst.u6_addr.u6_addr32[0];",
          "5516:     ip->ipv6.u6_addr.u6_addr32[1] = packet->iphv6->ip6_dst.u6_addr.u6_addr32[1];",
          "5517:     ip->ipv6.u6_addr.u6_addr32[2] = packet->iphv6->ip6_dst.u6_addr.u6_addr32[2];",
          "5518:     ip->ipv6.u6_addr.u6_addr32[3] = packet->iphv6->ip6_dst.u6_addr.u6_addr32[3];",
          "5520:   } else",
          "5524:     ip->ipv4 = packet->iph->daddr;",
          "5529: u_int8_t ndpi_is_ipv6(const ndpi_ip_addr_t *ip) {",
          "5531:   return(ip->ipv6.u6_addr.u6_addr32[1] != 0 || ip->ipv6.u6_addr.u6_addr32[2] != 0 ||",
          "5532:    ip->ipv6.u6_addr.u6_addr32[3] != 0);",
          "5534:   return(0);",
          "5540: char *ndpi_get_ip_string(const ndpi_ip_addr_t *ip, char *buf, u_int buf_len) {",
          "5541:   const u_int8_t *a = (const u_int8_t *) &ip->ipv4;",
          "5544:   if(ndpi_is_ipv6(ip)) {",
          "5545:     if(inet_ntop(AF_INET6, &ip->ipv6.u6_addr, buf, buf_len) == NULL)",
          "5546:       buf[0] = '\\0';",
          "5548:     return(buf);",
          "5549:   }",
          "5552:   snprintf(buf, buf_len, \"%u.%u.%u.%u\", a[0], a[1], a[2], a[3]);",
          "5554:   return(buf);",
          "5560: int ndpi_parse_ip_string(const char *ip_str, ndpi_ip_addr_t *parsed_ip) {",
          "5561:   int rv = -1;",
          "5562:   memset(parsed_ip, 0, sizeof(*parsed_ip));",
          "5564:   if(strchr(ip_str, '.')) {",
          "5565:     if(inet_pton(AF_INET, ip_str, &parsed_ip->ipv4) > 0)",
          "5566:       rv = 4;",
          "5568:   } else {",
          "5569:     if(inet_pton(AF_INET6, ip_str, &parsed_ip->ipv6) > 0)",
          "5570:       rv = 6;",
          "5572:   }",
          "5574:   return(rv);",
          "5579: u_int16_t ntohs_ndpi_bytestream_to_number(const u_int8_t *str,",
          "5580:        u_int16_t max_chars_to_read, u_int16_t *bytes_read) {",
          "5581:   u_int16_t val = ndpi_bytestream_to_number(str, max_chars_to_read, bytes_read);",
          "5582:   return(ntohs(val));",
          "5587: u_int8_t ndpi_is_proto(ndpi_protocol proto, u_int16_t p) {",
          "5588:   return(((proto.app_protocol == p) || (proto.master_protocol == p)) ? 1 : 0);",
          "5593: u_int16_t ndpi_get_lower_proto(ndpi_protocol proto) {",
          "5594:   return((proto.master_protocol != NDPI_PROTOCOL_UNKNOWN) ? proto.master_protocol : proto.app_protocol);",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "5704: ndpi_protocol ndpi_guess_undetected_protocol(struct ndpi_detection_module_struct *ndpi_str,",
          "5705:                                              struct ndpi_flow_struct *flow, u_int8_t proto,",
          "5706:                                              u_int32_t shost /* host byte order */, u_int16_t sport,",
          "5764: }",
          "5779: }",
          "5795: }",
          "5814: }",
          "5848: }",
          "5883: }",
          "5901: }",
          "5913: }",
          "5925: }",
          "5955: }",
          "5968: }",
          "5984: }",
          "5997: }",
          "",
          "[Removed Lines]",
          "5707:                                              u_int32_t dhost /* host byte order */, u_int16_t dport)",
          "5708: {",
          "5709:     u_int32_t rc;",
          "5710:     struct in_addr addr;",
          "5711:     ndpi_protocol ret = {NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED};",
          "5712:     u_int8_t user_defined_proto;",
          "5714:     if ((proto == IPPROTO_TCP) || (proto == IPPROTO_UDP)) {",
          "5715:         rc = ndpi_search_tcp_or_udp_raw(ndpi_str, flow, proto, shost, dhost, sport, dport);",
          "5717:         if (rc != NDPI_PROTOCOL_UNKNOWN) {",
          "5718:             if (flow && (proto == IPPROTO_UDP) &&",
          "5719:                 NDPI_COMPARE_PROTOCOL_TO_BITMASK(flow->excluded_protocol_bitmask, rc) && is_udp_guessable_protocol(rc))",
          "5720:                 ;",
          "5721:             else {",
          "5722:                 ret.app_protocol = rc,",
          "5723:                 ret.master_protocol = ndpi_guess_protocol_id(ndpi_str, flow, proto, sport, dport, &user_defined_proto);",
          "5725:                 if (ret.app_protocol == ret.master_protocol)",
          "5726:                     ret.master_protocol = NDPI_PROTOCOL_UNKNOWN;",
          "5728:                 ret.category = ndpi_get_proto_category(ndpi_str, ret);",
          "5729:                 return (ret);",
          "5730:             }",
          "5731:         }",
          "5733:         rc = ndpi_guess_protocol_id(ndpi_str, flow, proto, sport, dport, &user_defined_proto);",
          "5734:         if (rc != NDPI_PROTOCOL_UNKNOWN) {",
          "5735:             if (flow && (proto == IPPROTO_UDP) &&",
          "5736:                 NDPI_COMPARE_PROTOCOL_TO_BITMASK(flow->excluded_protocol_bitmask, rc) && is_udp_guessable_protocol(rc))",
          "5737:                 ;",
          "5738:             else {",
          "5739:                 ret.app_protocol = rc;",
          "5741:                 if (rc == NDPI_PROTOCOL_TLS)",
          "5742:                     goto check_guessed_skype;",
          "5743:                 else {",
          "5744:                     ret.category = ndpi_get_proto_category(ndpi_str, ret);",
          "5745:                     return (ret);",
          "5746:                 }",
          "5747:             }",
          "5748:         }",
          "5750:     check_guessed_skype:",
          "5751:         addr.s_addr = htonl(shost);",
          "5752:         if (ndpi_network_ptree_match(ndpi_str, &addr) == NDPI_PROTOCOL_SKYPE) {",
          "5753:             ret.app_protocol = NDPI_PROTOCOL_SKYPE;",
          "5754:         } else {",
          "5755:             addr.s_addr = htonl(dhost);",
          "5756:             if (ndpi_network_ptree_match(ndpi_str, &addr) == NDPI_PROTOCOL_SKYPE)",
          "5757:                 ret.app_protocol = NDPI_PROTOCOL_SKYPE;",
          "5758:         }",
          "5759:     } else",
          "5760:         ret.app_protocol = ndpi_guess_protocol_id(ndpi_str, flow, proto, sport, dport, &user_defined_proto);",
          "5762:     ret.category = ndpi_get_proto_category(ndpi_str, ret);",
          "5763:     return (ret);",
          "5768: char *ndpi_protocol2id(struct ndpi_detection_module_struct *ndpi_str, ndpi_protocol proto, char *buf, u_int buf_len)",
          "5769: {",
          "5770:     if ((proto.master_protocol != NDPI_PROTOCOL_UNKNOWN) && (proto.master_protocol != proto.app_protocol)) {",
          "5771:         if (proto.app_protocol != NDPI_PROTOCOL_UNKNOWN)",
          "5772:             snprintf(buf, buf_len, \"%u.%u\", proto.master_protocol, proto.app_protocol);",
          "5773:         else",
          "5774:             snprintf(buf, buf_len, \"%u\", proto.master_protocol);",
          "5775:     } else",
          "5776:         snprintf(buf, buf_len, \"%u\", proto.app_protocol);",
          "5778:     return (buf);",
          "5783: char *ndpi_protocol2name(struct ndpi_detection_module_struct *ndpi_str, ndpi_protocol proto, char *buf, u_int buf_len)",
          "5784: {",
          "5785:     if ((proto.master_protocol != NDPI_PROTOCOL_UNKNOWN) && (proto.master_protocol != proto.app_protocol)) {",
          "5786:         if (proto.app_protocol != NDPI_PROTOCOL_UNKNOWN)",
          "5787:             snprintf(buf, buf_len, \"%s.%s\", ndpi_get_proto_name(ndpi_str, proto.master_protocol),",
          "5788:                      ndpi_get_proto_name(ndpi_str, proto.app_protocol));",
          "5789:         else",
          "5790:             snprintf(buf, buf_len, \"%s\", ndpi_get_proto_name(ndpi_str, proto.master_protocol));",
          "5791:     } else",
          "5792:         snprintf(buf, buf_len, \"%s\", ndpi_get_proto_name(ndpi_str, proto.app_protocol));",
          "5794:     return (buf);",
          "5799: int ndpi_is_custom_category(ndpi_protocol_category_t category)",
          "5800: {",
          "5801:     switch (category) {",
          "5802:         case NDPI_PROTOCOL_CATEGORY_CUSTOM_1:",
          "5803:         case NDPI_PROTOCOL_CATEGORY_CUSTOM_2:",
          "5804:         case NDPI_PROTOCOL_CATEGORY_CUSTOM_3:",
          "5805:         case NDPI_PROTOCOL_CATEGORY_CUSTOM_4:",
          "5806:         case NDPI_PROTOCOL_CATEGORY_CUSTOM_5:",
          "5807:             return (1);",
          "5808:             break;",
          "5810:         default:",
          "5811:             return (0);",
          "5812:             break;",
          "5813:     }",
          "5818: void ndpi_category_set_name(struct ndpi_detection_module_struct *ndpi_str, ndpi_protocol_category_t category,",
          "5819:                             char *name)",
          "5820: {",
          "5821:     if (!name)",
          "5822:         return;",
          "5824:     switch (category) {",
          "5825:         case NDPI_PROTOCOL_CATEGORY_CUSTOM_1:",
          "5826:             snprintf(ndpi_str->custom_category_labels[0], CUSTOM_CATEGORY_LABEL_LEN, \"%s\", name);",
          "5827:             break;",
          "5829:         case NDPI_PROTOCOL_CATEGORY_CUSTOM_2:",
          "5830:             snprintf(ndpi_str->custom_category_labels[1], CUSTOM_CATEGORY_LABEL_LEN, \"%s\", name);",
          "5831:             break;",
          "5833:         case NDPI_PROTOCOL_CATEGORY_CUSTOM_3:",
          "5834:             snprintf(ndpi_str->custom_category_labels[2], CUSTOM_CATEGORY_LABEL_LEN, \"%s\", name);",
          "5835:             break;",
          "5837:         case NDPI_PROTOCOL_CATEGORY_CUSTOM_4:",
          "5838:             snprintf(ndpi_str->custom_category_labels[3], CUSTOM_CATEGORY_LABEL_LEN, \"%s\", name);",
          "5839:             break;",
          "5841:         case NDPI_PROTOCOL_CATEGORY_CUSTOM_5:",
          "5842:             snprintf(ndpi_str->custom_category_labels[4], CUSTOM_CATEGORY_LABEL_LEN, \"%s\", name);",
          "5843:             break;",
          "5845:         default:",
          "5846:             break;",
          "5847:     }",
          "5852: const char *ndpi_category_get_name(struct ndpi_detection_module_struct *ndpi_str, ndpi_protocol_category_t category)",
          "5853: {",
          "5854:     if ((!ndpi_str) || (category >= NDPI_PROTOCOL_NUM_CATEGORIES)) {",
          "5855:         static char b[24];",
          "5857:         if (!ndpi_str)",
          "5858:             snprintf(b, sizeof(b), \"NULL nDPI\");",
          "5859:         else",
          "5860:             snprintf(b, sizeof(b), \"Invalid category %d\", (int) category);",
          "5861:         return (b);",
          "5862:     }",
          "5864:     if ((category >= NDPI_PROTOCOL_CATEGORY_CUSTOM_1) && (category <= NDPI_PROTOCOL_CATEGORY_CUSTOM_5)) {",
          "5865:         switch (category) {",
          "5866:             case NDPI_PROTOCOL_CATEGORY_CUSTOM_1:",
          "5867:                 return (ndpi_str->custom_category_labels[0]);",
          "5868:             case NDPI_PROTOCOL_CATEGORY_CUSTOM_2:",
          "5869:                 return (ndpi_str->custom_category_labels[1]);",
          "5870:             case NDPI_PROTOCOL_CATEGORY_CUSTOM_3:",
          "5871:                 return (ndpi_str->custom_category_labels[2]);",
          "5872:             case NDPI_PROTOCOL_CATEGORY_CUSTOM_4:",
          "5873:                 return (ndpi_str->custom_category_labels[3]);",
          "5874:             case NDPI_PROTOCOL_CATEGORY_CUSTOM_5:",
          "5875:                 return (ndpi_str->custom_category_labels[4]);",
          "5876:             case NDPI_PROTOCOL_NUM_CATEGORIES:",
          "5877:                 return (\"Code should not use this internal constant\");",
          "5878:             default:",
          "5879:                 return (\"Unspecified\");",
          "5880:         }",
          "5881:     } else",
          "5882:         return (categories[category]);",
          "5887: ndpi_protocol_category_t ndpi_get_proto_category(struct ndpi_detection_module_struct *ndpi_str, ndpi_protocol proto)",
          "5888: {",
          "5889:     if (proto.category != NDPI_PROTOCOL_CATEGORY_UNSPECIFIED)",
          "5890:         return (proto.category);",
          "5893:     else if ((proto.master_protocol == NDPI_PROTOCOL_UNKNOWN) ||",
          "5894:              (ndpi_str->proto_defaults[proto.app_protocol].protoCategory != NDPI_PROTOCOL_CATEGORY_UNSPECIFIED)) {",
          "5895:         if (proto.app_protocol < (NDPI_MAX_SUPPORTED_PROTOCOLS + NDPI_MAX_NUM_CUSTOM_PROTOCOLS))",
          "5896:             return (ndpi_str->proto_defaults[proto.app_protocol].protoCategory);",
          "5897:     } else if (proto.master_protocol < (NDPI_MAX_SUPPORTED_PROTOCOLS + NDPI_MAX_NUM_CUSTOM_PROTOCOLS))",
          "5898:         return (ndpi_str->proto_defaults[proto.master_protocol].protoCategory);",
          "5900:     return (NDPI_PROTOCOL_CATEGORY_UNSPECIFIED);",
          "5905: char *ndpi_get_proto_name(struct ndpi_detection_module_struct *ndpi_str, u_int16_t proto_id)",
          "5906: {",
          "5907:     if ((proto_id >= ndpi_str->ndpi_num_supported_protocols) ||",
          "5908:         (proto_id >= (NDPI_MAX_SUPPORTED_PROTOCOLS + NDPI_MAX_NUM_CUSTOM_PROTOCOLS)) ||",
          "5909:         (ndpi_str->proto_defaults[proto_id].protoName == NULL))",
          "5910:         proto_id = NDPI_PROTOCOL_UNKNOWN;",
          "5912:     return (ndpi_str->proto_defaults[proto_id].protoName);",
          "5917: ndpi_protocol_breed_t ndpi_get_proto_breed(struct ndpi_detection_module_struct *ndpi_str, u_int16_t proto_id)",
          "5918: {",
          "5919:     if ((proto_id >= ndpi_str->ndpi_num_supported_protocols) ||",
          "5920:         (proto_id >= (NDPI_MAX_SUPPORTED_PROTOCOLS + NDPI_MAX_NUM_CUSTOM_PROTOCOLS)) ||",
          "5921:         (ndpi_str->proto_defaults[proto_id].protoName == NULL))",
          "5922:         proto_id = NDPI_PROTOCOL_UNKNOWN;",
          "5924:     return (ndpi_str->proto_defaults[proto_id].protoBreed);",
          "5929: char *ndpi_get_proto_breed_name(struct ndpi_detection_module_struct *ndpi_str, ndpi_protocol_breed_t breed_id)",
          "5930: {",
          "5931:     switch (breed_id) {",
          "5932:         case NDPI_PROTOCOL_SAFE:",
          "5933:             return (\"Safe\");",
          "5934:             break;",
          "5935:         case NDPI_PROTOCOL_ACCEPTABLE:",
          "5936:             return (\"Acceptable\");",
          "5937:             break;",
          "5938:         case NDPI_PROTOCOL_FUN:",
          "5939:             return (\"Fun\");",
          "5940:             break;",
          "5941:         case NDPI_PROTOCOL_UNSAFE:",
          "5942:             return (\"Unsafe\");",
          "5943:             break;",
          "5944:         case NDPI_PROTOCOL_POTENTIALLY_DANGEROUS:",
          "5945:             return (\"Potentially Dangerous\");",
          "5946:             break;",
          "5947:         case NDPI_PROTOCOL_DANGEROUS:",
          "5948:             return (\"Dangerous\");",
          "5949:             break;",
          "5950:         case NDPI_PROTOCOL_UNRATED:",
          "5951:         default:",
          "5952:             return (\"Unrated\");",
          "5953:             break;",
          "5954:     }",
          "5959: int ndpi_get_protocol_id(struct ndpi_detection_module_struct *ndpi_str, char *proto)",
          "5960: {",
          "5961:     int i;",
          "5963:     for (i = 0; i < (int) ndpi_str->ndpi_num_supported_protocols; i++)",
          "5964:         if (strcasecmp(proto, ndpi_str->proto_defaults[i].protoName) == 0)",
          "5965:             return (i);",
          "5967:     return (-1);",
          "5972: int ndpi_get_category_id(struct ndpi_detection_module_struct *ndpi_str, char *cat)",
          "5973: {",
          "5974:     int i;",
          "5976:     for (i = 0; i < NDPI_PROTOCOL_NUM_CATEGORIES; i++) {",
          "5977:         const char *name = ndpi_category_get_name(ndpi_str, i);",
          "5979:         if (strcasecmp(cat, name) == 0)",
          "5980:             return (i);",
          "5981:     }",
          "5983:     return (-1);",
          "5988: void ndpi_dump_protocols(struct ndpi_detection_module_struct *ndpi_str)",
          "5989: {",
          "5990:     int i;",
          "5992:     for (i = 0; i < (int) ndpi_str->ndpi_num_supported_protocols; i++)",
          "5993:         printf(\"%3d %-22s %-8s %-12s %s\\n\", i, ndpi_str->proto_defaults[i].protoName,",
          "5994:                ndpi_get_l4_proto_name(ndpi_get_l4_proto_info(ndpi_str, i)),",
          "5995:                ndpi_get_proto_breed_name(ndpi_str, ndpi_str->proto_defaults[i].protoBreed),",
          "5996:                ndpi_category_get_name(ndpi_str, ndpi_str->proto_defaults[i].protoCategory));",
          "",
          "[Added Lines]",
          "5602:                                              u_int32_t dhost /* host byte order */, u_int16_t dport) {",
          "5603:   u_int32_t rc;",
          "5604:   struct in_addr addr;",
          "5605:   ndpi_protocol ret = {NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED};",
          "5606:   u_int8_t user_defined_proto;",
          "5608:   if((proto == IPPROTO_TCP) || (proto == IPPROTO_UDP)) {",
          "5609:     rc = ndpi_search_tcp_or_udp_raw(ndpi_str, flow, proto, shost, dhost, sport, dport);",
          "5611:     if(rc != NDPI_PROTOCOL_UNKNOWN) {",
          "5612:       if(flow && (proto == IPPROTO_UDP) &&",
          "5613:   NDPI_COMPARE_PROTOCOL_TO_BITMASK(flow->excluded_protocol_bitmask, rc) && is_udp_guessable_protocol(rc))",
          "5614:  ;",
          "5615:       else {",
          "5616:  ret.app_protocol = rc,",
          "5617:    ret.master_protocol = ndpi_guess_protocol_id(ndpi_str, flow, proto, sport, dport, &user_defined_proto);",
          "5619:  if(ret.app_protocol == ret.master_protocol)",
          "5620:    ret.master_protocol = NDPI_PROTOCOL_UNKNOWN;",
          "5622:  ret.category = ndpi_get_proto_category(ndpi_str, ret);",
          "5623:  return(ret);",
          "5624:       }",
          "5625:     }",
          "5627:     rc = ndpi_guess_protocol_id(ndpi_str, flow, proto, sport, dport, &user_defined_proto);",
          "5628:     if(rc != NDPI_PROTOCOL_UNKNOWN) {",
          "5629:       if(flow && (proto == IPPROTO_UDP) &&",
          "5630:   NDPI_COMPARE_PROTOCOL_TO_BITMASK(flow->excluded_protocol_bitmask, rc) && is_udp_guessable_protocol(rc))",
          "5631:  ;",
          "5632:       else {",
          "5633:  ret.app_protocol = rc;",
          "5635:  if(rc == NDPI_PROTOCOL_TLS)",
          "5636:    goto check_guessed_skype;",
          "5637:  else {",
          "5638:    ret.category = ndpi_get_proto_category(ndpi_str, ret);",
          "5639:    return(ret);",
          "5640:  }",
          "5641:       }",
          "5642:     }",
          "5644:   check_guessed_skype:",
          "5645:     addr.s_addr = htonl(shost);",
          "5646:     if(ndpi_network_ptree_match(ndpi_str, &addr) == NDPI_PROTOCOL_SKYPE) {",
          "5647:       ret.app_protocol = NDPI_PROTOCOL_SKYPE;",
          "5648:     } else {",
          "5649:       addr.s_addr = htonl(dhost);",
          "5650:       if(ndpi_network_ptree_match(ndpi_str, &addr) == NDPI_PROTOCOL_SKYPE)",
          "5651:  ret.app_protocol = NDPI_PROTOCOL_SKYPE;",
          "5652:     }",
          "5653:   } else",
          "5654:     ret.app_protocol = ndpi_guess_protocol_id(ndpi_str, flow, proto, sport, dport, &user_defined_proto);",
          "5656:   ret.category = ndpi_get_proto_category(ndpi_str, ret);",
          "5657:   return(ret);",
          "5662: char *ndpi_protocol2id(struct ndpi_detection_module_struct *ndpi_str,",
          "5663:          ndpi_protocol proto, char *buf, u_int buf_len) {",
          "5664:   if((proto.master_protocol != NDPI_PROTOCOL_UNKNOWN) && (proto.master_protocol != proto.app_protocol)) {",
          "5665:     if(proto.app_protocol != NDPI_PROTOCOL_UNKNOWN)",
          "5666:       snprintf(buf, buf_len, \"%u.%u\", proto.master_protocol, proto.app_protocol);",
          "5667:     else",
          "5668:       snprintf(buf, buf_len, \"%u\", proto.master_protocol);",
          "5669:   } else",
          "5670:     snprintf(buf, buf_len, \"%u\", proto.app_protocol);",
          "5672:   return(buf);",
          "5677: char *ndpi_protocol2name(struct ndpi_detection_module_struct *ndpi_str,",
          "5678:     ndpi_protocol proto, char *buf, u_int buf_len) {",
          "5679:   if((proto.master_protocol != NDPI_PROTOCOL_UNKNOWN) && (proto.master_protocol != proto.app_protocol)) {",
          "5680:     if(proto.app_protocol != NDPI_PROTOCOL_UNKNOWN)",
          "5681:       snprintf(buf, buf_len, \"%s.%s\", ndpi_get_proto_name(ndpi_str, proto.master_protocol),",
          "5682:         ndpi_get_proto_name(ndpi_str, proto.app_protocol));",
          "5683:     else",
          "5684:       snprintf(buf, buf_len, \"%s\", ndpi_get_proto_name(ndpi_str, proto.master_protocol));",
          "5685:   } else",
          "5686:     snprintf(buf, buf_len, \"%s\", ndpi_get_proto_name(ndpi_str, proto.app_protocol));",
          "5688:   return(buf);",
          "5693: int ndpi_is_custom_category(ndpi_protocol_category_t category) {",
          "5694:   switch (category) {",
          "5695:   case NDPI_PROTOCOL_CATEGORY_CUSTOM_1:",
          "5696:   case NDPI_PROTOCOL_CATEGORY_CUSTOM_2:",
          "5697:   case NDPI_PROTOCOL_CATEGORY_CUSTOM_3:",
          "5698:   case NDPI_PROTOCOL_CATEGORY_CUSTOM_4:",
          "5699:   case NDPI_PROTOCOL_CATEGORY_CUSTOM_5:",
          "5700:     return(1);",
          "5701:     break;",
          "5703:   default:",
          "5704:     return(0);",
          "5705:     break;",
          "5706:   }",
          "5711: void ndpi_category_set_name(struct ndpi_detection_module_struct *ndpi_str,",
          "5712:        ndpi_protocol_category_t category,",
          "5713:                             char *name) {",
          "5714:   if(!name)",
          "5715:     return;",
          "5717:   switch (category) {",
          "5718:   case NDPI_PROTOCOL_CATEGORY_CUSTOM_1:",
          "5719:     snprintf(ndpi_str->custom_category_labels[0], CUSTOM_CATEGORY_LABEL_LEN, \"%s\", name);",
          "5720:     break;",
          "5722:   case NDPI_PROTOCOL_CATEGORY_CUSTOM_2:",
          "5723:     snprintf(ndpi_str->custom_category_labels[1], CUSTOM_CATEGORY_LABEL_LEN, \"%s\", name);",
          "5724:     break;",
          "5726:   case NDPI_PROTOCOL_CATEGORY_CUSTOM_3:",
          "5727:     snprintf(ndpi_str->custom_category_labels[2], CUSTOM_CATEGORY_LABEL_LEN, \"%s\", name);",
          "5728:     break;",
          "5730:   case NDPI_PROTOCOL_CATEGORY_CUSTOM_4:",
          "5731:     snprintf(ndpi_str->custom_category_labels[3], CUSTOM_CATEGORY_LABEL_LEN, \"%s\", name);",
          "5732:     break;",
          "5734:   case NDPI_PROTOCOL_CATEGORY_CUSTOM_5:",
          "5735:     snprintf(ndpi_str->custom_category_labels[4], CUSTOM_CATEGORY_LABEL_LEN, \"%s\", name);",
          "5736:     break;",
          "5738:   default:",
          "5739:     break;",
          "5740:   }",
          "5745: const char *ndpi_category_get_name(struct ndpi_detection_module_struct *ndpi_str,",
          "5746:        ndpi_protocol_category_t category) {",
          "5747:   if((!ndpi_str) || (category >= NDPI_PROTOCOL_NUM_CATEGORIES)) {",
          "5748:     static char b[24];",
          "5750:     if(!ndpi_str)",
          "5751:       snprintf(b, sizeof(b), \"NULL nDPI\");",
          "5752:     else",
          "5753:       snprintf(b, sizeof(b), \"Invalid category %d\", (int) category);",
          "5754:     return(b);",
          "5755:   }",
          "5757:   if((category >= NDPI_PROTOCOL_CATEGORY_CUSTOM_1) && (category <= NDPI_PROTOCOL_CATEGORY_CUSTOM_5)) {",
          "5758:     switch (category) {",
          "5759:     case NDPI_PROTOCOL_CATEGORY_CUSTOM_1:",
          "5760:       return(ndpi_str->custom_category_labels[0]);",
          "5761:     case NDPI_PROTOCOL_CATEGORY_CUSTOM_2:",
          "5762:       return(ndpi_str->custom_category_labels[1]);",
          "5763:     case NDPI_PROTOCOL_CATEGORY_CUSTOM_3:",
          "5764:       return(ndpi_str->custom_category_labels[2]);",
          "5765:     case NDPI_PROTOCOL_CATEGORY_CUSTOM_4:",
          "5766:       return(ndpi_str->custom_category_labels[3]);",
          "5767:     case NDPI_PROTOCOL_CATEGORY_CUSTOM_5:",
          "5768:       return(ndpi_str->custom_category_labels[4]);",
          "5769:     case NDPI_PROTOCOL_NUM_CATEGORIES:",
          "5770:       return(\"Code should not use this internal constant\");",
          "5771:     default:",
          "5772:       return(\"Unspecified\");",
          "5773:     }",
          "5774:   } else",
          "5775:     return(categories[category]);",
          "5780: ndpi_protocol_category_t ndpi_get_proto_category(struct ndpi_detection_module_struct *ndpi_str,",
          "5781:        ndpi_protocol proto) {",
          "5782:   if(proto.category != NDPI_PROTOCOL_CATEGORY_UNSPECIFIED)",
          "5783:     return(proto.category);",
          "5786:   else if((proto.master_protocol == NDPI_PROTOCOL_UNKNOWN) ||",
          "5787:    (ndpi_str->proto_defaults[proto.app_protocol].protoCategory != NDPI_PROTOCOL_CATEGORY_UNSPECIFIED)) {",
          "5788:     if(proto.app_protocol < (NDPI_MAX_SUPPORTED_PROTOCOLS + NDPI_MAX_NUM_CUSTOM_PROTOCOLS))",
          "5789:       return(ndpi_str->proto_defaults[proto.app_protocol].protoCategory);",
          "5790:   } else if(proto.master_protocol < (NDPI_MAX_SUPPORTED_PROTOCOLS + NDPI_MAX_NUM_CUSTOM_PROTOCOLS))",
          "5791:     return(ndpi_str->proto_defaults[proto.master_protocol].protoCategory);",
          "5793:   return(NDPI_PROTOCOL_CATEGORY_UNSPECIFIED);",
          "5798: char *ndpi_get_proto_name(struct ndpi_detection_module_struct *ndpi_str,",
          "5799:      u_int16_t proto_id) {",
          "5800:   if((proto_id >= ndpi_str->ndpi_num_supported_protocols) ||",
          "5801:      (proto_id >= (NDPI_MAX_SUPPORTED_PROTOCOLS + NDPI_MAX_NUM_CUSTOM_PROTOCOLS)) ||",
          "5802:      (ndpi_str->proto_defaults[proto_id].protoName == NULL))",
          "5803:     proto_id = NDPI_PROTOCOL_UNKNOWN;",
          "5805:   return(ndpi_str->proto_defaults[proto_id].protoName);",
          "5810: ndpi_protocol_breed_t ndpi_get_proto_breed(struct ndpi_detection_module_struct *ndpi_str,",
          "5811:         u_int16_t proto_id) {",
          "5812:   if((proto_id >= ndpi_str->ndpi_num_supported_protocols) ||",
          "5813:      (proto_id >= (NDPI_MAX_SUPPORTED_PROTOCOLS + NDPI_MAX_NUM_CUSTOM_PROTOCOLS)) ||",
          "5814:      (ndpi_str->proto_defaults[proto_id].protoName == NULL))",
          "5815:     proto_id = NDPI_PROTOCOL_UNKNOWN;",
          "5817:   return(ndpi_str->proto_defaults[proto_id].protoBreed);",
          "5822: char *ndpi_get_proto_breed_name(struct ndpi_detection_module_struct *ndpi_str,",
          "5823:     ndpi_protocol_breed_t breed_id) {",
          "5824:   switch (breed_id) {",
          "5825:   case NDPI_PROTOCOL_SAFE:",
          "5826:     return(\"Safe\");",
          "5827:     break;",
          "5828:   case NDPI_PROTOCOL_ACCEPTABLE:",
          "5829:     return(\"Acceptable\");",
          "5830:     break;",
          "5831:   case NDPI_PROTOCOL_FUN:",
          "5832:     return(\"Fun\");",
          "5833:     break;",
          "5834:   case NDPI_PROTOCOL_UNSAFE:",
          "5835:     return(\"Unsafe\");",
          "5836:     break;",
          "5837:   case NDPI_PROTOCOL_POTENTIALLY_DANGEROUS:",
          "5838:     return(\"Potentially Dangerous\");",
          "5839:     break;",
          "5840:   case NDPI_PROTOCOL_DANGEROUS:",
          "5841:     return(\"Dangerous\");",
          "5842:     break;",
          "5843:   case NDPI_PROTOCOL_UNRATED:",
          "5844:   default:",
          "5845:     return(\"Unrated\");",
          "5846:     break;",
          "5847:   }",
          "5852: int ndpi_get_protocol_id(struct ndpi_detection_module_struct *ndpi_str, char *proto) {",
          "5853:   int i;",
          "5855:   for (i = 0; i < (int) ndpi_str->ndpi_num_supported_protocols; i++)",
          "5856:     if(strcasecmp(proto, ndpi_str->proto_defaults[i].protoName) == 0)",
          "5857:       return(i);",
          "5859:   return(-1);",
          "5864: int ndpi_get_category_id(struct ndpi_detection_module_struct *ndpi_str, char *cat) {",
          "5865:   int i;",
          "5867:   for (i = 0; i < NDPI_PROTOCOL_NUM_CATEGORIES; i++) {",
          "5868:     const char *name = ndpi_category_get_name(ndpi_str, i);",
          "5870:     if(strcasecmp(cat, name) == 0)",
          "5871:       return(i);",
          "5872:   }",
          "5874:   return(-1);",
          "5879: void ndpi_dump_protocols(struct ndpi_detection_module_struct *ndpi_str) {",
          "5880:   int i;",
          "5882:   for (i = 0; i < (int) ndpi_str->ndpi_num_supported_protocols; i++)",
          "5883:     printf(\"%3d %-22s %-8s %-12s %s\\n\", i, ndpi_str->proto_defaults[i].protoName,",
          "5884:     ndpi_get_l4_proto_name(ndpi_get_l4_proto_info(ndpi_str, i)),",
          "5885:     ndpi_get_proto_breed_name(ndpi_str, ndpi_str->proto_defaults[i].protoBreed),",
          "5886:     ndpi_category_get_name(ndpi_str, ndpi_str->proto_defaults[i].protoCategory));",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "6026: }",
          "",
          "[Removed Lines]",
          "6005: char *ndpi_strnstr(const char *s, const char *find, size_t slen)",
          "6006: {",
          "6007:     char c;",
          "6008:     size_t len;",
          "6010:     if ((c = *find++) != '\\0') {",
          "6011:         len = strnlen(find, slen);",
          "6012:         do {",
          "6013:             char sc;",
          "6015:             do {",
          "6016:                 if (slen-- < 1 || (sc = *s++) == '\\0')",
          "6017:                     return (NULL);",
          "6018:             } while (sc != c);",
          "6019:             if (len > slen)",
          "6020:                 return (NULL);",
          "6021:         } while (strncmp(s, find, len) != 0);",
          "6022:         s--;",
          "6023:     }",
          "6025:     return ((char *) s);",
          "",
          "[Added Lines]",
          "5895: char *ndpi_strnstr(const char *s, const char *find, size_t slen) {",
          "5896:   char c;",
          "5897:   size_t len;",
          "5899:   if((c = *find++) != '\\0') {",
          "5900:     len = strnlen(find, slen);",
          "5901:     do {",
          "5902:       char sc;",
          "5904:       do {",
          "5905:  if(slen-- < 1 || (sc = *s++) == '\\0')",
          "5906:    return(NULL);",
          "5907:       } while (sc != c);",
          "5908:       if(len > slen)",
          "5909:  return(NULL);",
          "5910:     } while (strncmp(s, find, len) != 0);",
          "5911:     s--;",
          "5912:   }",
          "5914:   return((char *) s);",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "6055: }",
          "6064: }",
          "6068: int ndpi_match_string_subprotocol(struct ndpi_detection_module_struct *ndpi_str, char *string_to_match,",
          "6069:                                   u_int string_to_match_len, ndpi_protocol_match_result *ret_match,",
          "6089:     As ac_automata_search can detect partial matches and continue the search process",
          "6090:     in case rc == 0 (i.e. no match), we need to check if there is a partial match",
          "6091:     and in this case return it",
          "6098:     ret_match->protocol_breed = match.breed;",
          "6101: }",
          "6103: #ifdef HAVE_HYPERSCAN",
          "",
          "[Removed Lines]",
          "6033: char *ndpi_strncasestr(const char *s, const char *find, size_t slen)",
          "6034: {",
          "6035:     char c;",
          "6036:     size_t len;",
          "6038:     if ((c = *find++) != '\\0') {",
          "6039:         len = strlen(find);",
          "6040:         do {",
          "6041:             char sc;",
          "6043:             do {",
          "6044:                 if (slen-- < 1 || (sc = *s++) == '\\0')",
          "6045:                     return (NULL);",
          "6046:             } while (sc != c);",
          "6048:             if (len > slen)",
          "6049:                 return (NULL);",
          "6050:         } while (strncasecmp(s, find, len) != 0);",
          "6052:         s--;",
          "6053:     }",
          "6054:     return ((char *) s);",
          "6059: int ndpi_match_prefix(const u_int8_t *payload, size_t payload_len, const char *str, size_t str_len)",
          "6060: {",
          "6061:     int rc = str_len <= payload_len ? memcmp(payload, str, str_len) == 0 : 0;",
          "6063:     return (rc);",
          "6070:                                   u_int8_t is_host_match)",
          "6071: {",
          "6072:     AC_TEXT_t ac_input_text;",
          "6073:     ndpi_automa *automa = is_host_match ? &ndpi_str->host_automa : &ndpi_str->content_automa;",
          "6074:     AC_REP_t match = {NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED, NDPI_PROTOCOL_UNRATED};",
          "6075:     int rc;",
          "6077:     if ((automa->ac_automa == NULL) || (string_to_match_len == 0))",
          "6078:         return (NDPI_PROTOCOL_UNKNOWN);",
          "6080:     if (!automa->ac_automa_finalized) {",
          "6081:         printf(\"[%s:%d] [NDPI] Internal error: please call ndpi_finalize_initalization()\\n\", __FILE__, __LINE__);",
          "6083:     }",
          "6085:     ac_input_text.astring = string_to_match, ac_input_text.length = string_to_match_len;",
          "6086:     rc = ac_automata_search(((AC_AUTOMATA_t *) automa->ac_automa), &ac_input_text, &match);",
          "6093:     if ((rc == 0) && (match.number != 0))",
          "6094:         rc = 1;",
          "6097:     ret_match->protocol_id = match.number, ret_match->protocol_category = match.category,",
          "6100:     return (rc ? match.number : 0);",
          "",
          "[Added Lines]",
          "5922: char *ndpi_strncasestr(const char *s, const char *find, size_t slen) {",
          "5923:   char c;",
          "5924:   size_t len;",
          "5926:   if((c = *find++) != '\\0') {",
          "5927:     len = strlen(find);",
          "5928:     do {",
          "5929:       char sc;",
          "5931:       do {",
          "5932:  if(slen-- < 1 || (sc = *s++) == '\\0')",
          "5933:    return(NULL);",
          "5934:       } while (sc != c);",
          "5936:       if(len > slen)",
          "5937:  return(NULL);",
          "5938:     } while (strncasecmp(s, find, len) != 0);",
          "5940:     s--;",
          "5941:   }",
          "5942:   return((char *) s);",
          "5947: int ndpi_match_prefix(const u_int8_t *payload,",
          "5948:         size_t payload_len, const char *str, size_t str_len) {",
          "5949:   int rc = str_len <= payload_len ? memcmp(payload, str, str_len) == 0 : 0;",
          "5951:   return(rc);",
          "5958:                                   u_int8_t is_host_match) {",
          "5959:   AC_TEXT_t ac_input_text;",
          "5960:   ndpi_automa *automa = is_host_match ? &ndpi_str->host_automa : &ndpi_str->content_automa;",
          "5961:   AC_REP_t match = {NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED, NDPI_PROTOCOL_UNRATED};",
          "5962:   int rc;",
          "5964:   if((automa->ac_automa == NULL) || (string_to_match_len == 0))",
          "5965:     return(NDPI_PROTOCOL_UNKNOWN);",
          "5967:   if(!automa->ac_automa_finalized) {",
          "5968:     printf(\"[%s:%d] [NDPI] Internal error: please call ndpi_finalize_initalization()\\n\", __FILE__, __LINE__);",
          "5970:   }",
          "5972:   ac_input_text.astring = string_to_match, ac_input_text.length = string_to_match_len;",
          "5973:   rc = ac_automata_search(((AC_AUTOMATA_t *) automa->ac_automa), &ac_input_text, &match);",
          "5980:   if((rc == 0) && (match.number != 0))",
          "5981:     rc = 1;",
          "5984:   ret_match->protocol_id = match.number, ret_match->protocol_category = match.category,",
          "5987:   return(rc ? match.number : 0);",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "6107: static int hyperscanEventHandler(unsigned int id, unsigned long long from, unsigned long long to, unsigned int flags,",
          "6116: }",
          "6118: #endif",
          "6137: }",
          "",
          "[Removed Lines]",
          "6108:                                  void *ctx)",
          "6109: {",
          "6112:     NDPI_LOG_DBG2(ndpi_str, \"[NDPI] Match with: %d [from: %llu][to: %llu]\\n\", id, from, to);",
          "6122: static u_int8_t ndpi_is_more_generic_protocol(u_int16_t previous_proto, u_int16_t new_proto)",
          "6123: {",
          "6126:     if ((previous_proto == NDPI_PROTOCOL_UNKNOWN) || (previous_proto == new_proto))",
          "6127:         return (0);",
          "6129:     switch (previous_proto) {",
          "6130:         case NDPI_PROTOCOL_WHATSAPP_CALL:",
          "6131:         case NDPI_PROTOCOL_WHATSAPP_FILES:",
          "6132:             if (new_proto == NDPI_PROTOCOL_WHATSAPP)",
          "6133:                 return (1);",
          "6134:     }",
          "6136:     return (0);",
          "",
          "[Added Lines]",
          "5995:                                  void *ctx) {",
          "5998:   NDPI_LOG_DBG2(ndpi_str, \"[NDPI] Match with: %d [from: %llu][to: %llu]\\n\", id, from, to);",
          "6008: static u_int8_t ndpi_is_more_generic_protocol(u_int16_t previous_proto, u_int16_t new_proto) {",
          "6011:   if((previous_proto == NDPI_PROTOCOL_UNKNOWN) || (previous_proto == new_proto))",
          "6012:     return(0);",
          "6014:   switch (previous_proto) {",
          "6015:   case NDPI_PROTOCOL_WHATSAPP_CALL:",
          "6016:   case NDPI_PROTOCOL_WHATSAPP_FILES:",
          "6017:     if(new_proto == NDPI_PROTOCOL_WHATSAPP)",
          "6018:       return(1);",
          "6019:   }",
          "6021:   return(0);",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "6141: static u_int16_t ndpi_automa_match_string_subprotocol(struct ndpi_detection_module_struct *ndpi_str,",
          "6142:                                                       struct ndpi_flow_struct *flow, char *string_to_match,",
          "6143:                                                       u_int string_to_match_len, u_int16_t master_protocol_id,",
          "6149: #ifndef HAVE_HYPERSCAN",
          "6152: #else",
          "6158:     TODO HYPERSCAN",
          "6159:     In case of match fill up ret_match and set flow protocol + category",
          "6175:     ret_match->protocol_category = ndpi_str->proto_defaults[matching_protocol_id].protoCategory,",
          "6176:     ret_match->protocol_breed = ndpi_str->proto_defaults[matching_protocol_id].protoBreed;",
          "6177: #endif",
          "6179: #ifdef DEBUG",
          "6190: #endif",
          "6207: #ifdef DEBUG",
          "6210: #endif",
          "6213:     ret_match->protocol_breed = NDPI_PROTOCOL_UNRATED;",
          "6216: }",
          "6220: u_int16_t ndpi_match_host_subprotocol(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,",
          "6221:                                       char *string_to_match, u_int string_to_match_len,",
          "6233:     }",
          "6236: }",
          "6240: int ndpi_match_hostname_protocol(struct ndpi_detection_module_struct *ndpi_struct, struct ndpi_flow_struct *flow,",
          "6260: }",
          "6265:                                          char *string_to_match, u_int string_to_match_len,",
          "6270: }",
          "6292:     As ac_automata_search can detect partial matches and continue the search process",
          "6293:     in case rc == 0 (i.e. no match), we need to check if there is a partial match",
          "6294:     and in this case return it",
          "6300: }",
          "6336:     }",
          "6337: }",
          "6344: }",
          "",
          "[Removed Lines]",
          "6144:                                                       ndpi_protocol_match_result *ret_match, u_int8_t is_host_match)",
          "6145: {",
          "6146:     int matching_protocol_id;",
          "6147:     struct ndpi_packet_struct *packet = &flow->packet;",
          "6150:     matching_protocol_id =",
          "6151:         ndpi_match_string_subprotocol(ndpi_str, string_to_match, string_to_match_len, ret_match, is_host_match);",
          "6153:     struct hs *hs = (struct hs *) ndpi_str->hyperscan;",
          "6154:     hs_error_t status;",
          "6156:     matching_protocol_id = NDPI_PROTOCOL_UNKNOWN;",
          "6161:     status = hs_scan(hs->database, string_to_match, string_to_match_len, 0, hs->scratch, hyperscanEventHandler,",
          "6162:                      &matching_protocol_id);",
          "6164:     if (status == HS_SUCCESS) {",
          "6165:         NDPI_LOG_DBG2(ndpi_str, \"[NDPI] Hyperscan engine completed normally. Result: %s [%d][%s]\\n\",",
          "6166:                       ndpi_get_proto_name(ndpi_str, matching_protocol_id), matching_protocol_id, string_to_match);",
          "6167:     } else if (status == HS_SCAN_TERMINATED) {",
          "6168:         NDPI_LOG_DBG2(ndpi_str, \"[NDPI] Hyperscan engine was terminated by callback. Result: %s [%d][%s]\\n\",",
          "6169:                       ndpi_get_proto_name(ndpi_str, matching_protocol_id), matching_protocol_id, string_to_match);",
          "6170:     } else {",
          "6171:         NDPI_LOG_DBG2(ndpi_str, \"[NDPI] Hyperscan returned with error.\\n\");",
          "6172:     }",
          "6174:     ret_match->protocol_id = matching_protocol_id,",
          "6180:     {",
          "6181:         char m[256];",
          "6182:         int len = ndpi_min(sizeof(m), string_to_match_len);",
          "6184:         strncpy(m, string_to_match, len);",
          "6185:         m[len] = '\\0';",
          "6187:         NDPI_LOG_DBG2(ndpi_str, \"[NDPI] ndpi_match_host_subprotocol(%s): %s\\n\", m,",
          "6188:                       ndpi_str->proto_defaults[matching_protocol_id].protoName);",
          "6189:     }",
          "6192:     if ((matching_protocol_id != NDPI_PROTOCOL_UNKNOWN) &&",
          "6193:         (!ndpi_is_more_generic_protocol(packet->detected_protocol_stack[0], matching_protocol_id))) {",
          "6195:         packet->detected_protocol_stack[1] = master_protocol_id,",
          "6196:         packet->detected_protocol_stack[0] = matching_protocol_id;",
          "6198:         flow->detected_protocol_stack[0] = packet->detected_protocol_stack[0],",
          "6199:         flow->detected_protocol_stack[1] = packet->detected_protocol_stack[1];",
          "6201:         if (flow->category == NDPI_PROTOCOL_CATEGORY_UNSPECIFIED)",
          "6202:             flow->category = ret_match->protocol_category;",
          "6204:         return (packet->detected_protocol_stack[0]);",
          "6205:     }",
          "6208:     string_to_match[string_to_match_len] = '\\0';",
          "6209:     NDPI_LOG_DBG2(ndpi_str, \"[NTOP] Unable to find a match for '%s'\\n\", string_to_match);",
          "6212:     ret_match->protocol_id = NDPI_PROTOCOL_UNKNOWN, ret_match->protocol_category = NDPI_PROTOCOL_CATEGORY_UNSPECIFIED,",
          "6215:     return (NDPI_PROTOCOL_UNKNOWN);",
          "6222:                                       ndpi_protocol_match_result *ret_match, u_int16_t master_protocol_id)",
          "6223: {",
          "6224:     u_int16_t rc = ndpi_automa_match_string_subprotocol(ndpi_str, flow, string_to_match, string_to_match_len,",
          "6225:                                                         master_protocol_id, ret_match, 1);",
          "6226:     unsigned long id = ret_match->protocol_category;",
          "6228:     if (ndpi_get_custom_category_match(ndpi_str, string_to_match, string_to_match_len, &id) != -1) {",
          "6229:         if (id != -1) {",
          "6230:             flow->category = ret_match->protocol_category = id;",
          "6231:             rc = master_protocol_id;",
          "6232:         }",
          "6235:     return (rc);",
          "6241:                                  u_int16_t master_protocol, char *name, u_int name_len)",
          "6242: {",
          "6243:     ndpi_protocol_match_result ret_match;",
          "6244:     u_int16_t subproto, what_len;",
          "6245:     char *what;",
          "6247:     if ((name_len > 2) && (name[0] == '*') && (name[1] == '.'))",
          "6248:         what = &name[1], what_len = name_len - 1;",
          "6249:     else",
          "6250:         what = name, what_len = name_len;",
          "6252:     subproto = ndpi_match_host_subprotocol(ndpi_struct, flow, what, what_len, &ret_match, master_protocol);",
          "6254:     if (subproto != NDPI_PROTOCOL_UNKNOWN) {",
          "6255:         ndpi_set_detected_protocol(ndpi_struct, flow, subproto, master_protocol);",
          "6256:         ndpi_int_change_category(ndpi_struct, flow, ret_match.protocol_category);",
          "6257:         return (1);",
          "6258:     } else",
          "6259:         return (0);",
          "6264: u_int16_t ndpi_match_content_subprotocol(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,",
          "6266:                                          ndpi_protocol_match_result *ret_match, u_int16_t master_protocol_id)",
          "6267: {",
          "6268:     return (ndpi_automa_match_string_subprotocol(ndpi_str, flow, string_to_match, string_to_match_len,",
          "6269:                                                  master_protocol_id, ret_match, 0));",
          "6274: int ndpi_match_bigram(struct ndpi_detection_module_struct *ndpi_str, ndpi_automa *automa, char *bigram_to_match)",
          "6275: {",
          "6276:     AC_TEXT_t ac_input_text;",
          "6277:     AC_REP_t match = {NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED, NDPI_PROTOCOL_UNRATED};",
          "6278:     int rc;",
          "6280:     if ((automa->ac_automa == NULL) || (bigram_to_match == NULL))",
          "6281:         return (-1);",
          "6283:     if (!automa->ac_automa_finalized) {",
          "6284:         printf(\"[%s:%d] [NDPI] Internal error: please call ndpi_finalize_initalization()\\n\", __FILE__, __LINE__);",
          "6286:     }",
          "6288:     ac_input_text.astring = bigram_to_match, ac_input_text.length = 2;",
          "6289:     rc = ac_automata_search(((AC_AUTOMATA_t *) automa->ac_automa), &ac_input_text, &match);",
          "6296:     if ((rc == 0) && (match.number != 0))",
          "6297:         rc = 1;",
          "6299:     return (rc ? match.number : 0);",
          "6304: void ndpi_free_flow(struct ndpi_flow_struct *flow)",
          "6305: {",
          "6306:     if (flow) {",
          "6307:         if (flow->http.url)",
          "6308:             ndpi_free(flow->http.url);",
          "6309:         if (flow->http.content_type)",
          "6310:             ndpi_free(flow->http.content_type);",
          "6311:         if (flow->http.user_agent)",
          "6312:             ndpi_free(flow->http.user_agent);",
          "6313:         if (flow->kerberos_buf.pktbuf)",
          "6314:             ndpi_free(flow->kerberos_buf.pktbuf);",
          "6316:         if (flow_is_proto(flow, NDPI_PROTOCOL_TLS)) {",
          "6317:             if (flow->protos.stun_ssl.ssl.server_names)",
          "6318:                 ndpi_free(flow->protos.stun_ssl.ssl.server_names);",
          "6320:             if (flow->protos.stun_ssl.ssl.alpn)",
          "6321:                 ndpi_free(flow->protos.stun_ssl.ssl.alpn);",
          "6323:             if (flow->protos.stun_ssl.ssl.tls_supported_versions)",
          "6324:                 ndpi_free(flow->protos.stun_ssl.ssl.tls_supported_versions);",
          "6326:             if (flow->l4.tcp.tls.srv_cert_fingerprint_ctx)",
          "6327:                 ndpi_free(flow->l4.tcp.tls.srv_cert_fingerprint_ctx);",
          "6328:         }",
          "6330:         if (flow->l4_proto == IPPROTO_TCP) {",
          "6331:             if (flow->l4.tcp.tls.message.buffer)",
          "6332:                 ndpi_free(flow->l4.tcp.tls.message.buffer);",
          "6333:         }",
          "6335:         ndpi_free(flow);",
          "6341: char *ndpi_revision()",
          "6342: {",
          "6343:     return (NDPI_GIT_RELEASE);",
          "",
          "[Added Lines]",
          "6029:                                                       ndpi_protocol_match_result *ret_match, u_int8_t is_host_match) {",
          "6030:   int matching_protocol_id;",
          "6031:   struct ndpi_packet_struct *packet = &flow->packet;",
          "6034:   matching_protocol_id =",
          "6035:     ndpi_match_string_subprotocol(ndpi_str, string_to_match, string_to_match_len, ret_match, is_host_match);",
          "6037:   struct hs *hs = (struct hs *) ndpi_str->hyperscan;",
          "6038:   hs_error_t status;",
          "6040:   matching_protocol_id = NDPI_PROTOCOL_UNKNOWN;",
          "6045:   status = hs_scan(hs->database, string_to_match, string_to_match_len, 0, hs->scratch, hyperscanEventHandler,",
          "6046:      &matching_protocol_id);",
          "6048:   if(status == HS_SUCCESS) {",
          "6049:     NDPI_LOG_DBG2(ndpi_str, \"[NDPI] Hyperscan engine completed normally. Result: %s [%d][%s]\\n\",",
          "6050:     ndpi_get_proto_name(ndpi_str, matching_protocol_id), matching_protocol_id, string_to_match);",
          "6051:   } else if(status == HS_SCAN_TERMINATED) {",
          "6052:     NDPI_LOG_DBG2(ndpi_str, \"[NDPI] Hyperscan engine was terminated by callback. Result: %s [%d][%s]\\n\",",
          "6053:     ndpi_get_proto_name(ndpi_str, matching_protocol_id), matching_protocol_id, string_to_match);",
          "6054:   } else {",
          "6055:     NDPI_LOG_DBG2(ndpi_str, \"[NDPI] Hyperscan returned with error.\\n\");",
          "6056:   }",
          "6058:   ret_match->protocol_id = matching_protocol_id,",
          "6064:   {",
          "6065:     char m[256];",
          "6066:     int len = ndpi_min(sizeof(m), string_to_match_len);",
          "6068:     strncpy(m, string_to_match, len);",
          "6069:     m[len] = '\\0';",
          "6071:     NDPI_LOG_DBG2(ndpi_str, \"[NDPI] ndpi_match_host_subprotocol(%s): %s\\n\", m,",
          "6072:     ndpi_str->proto_defaults[matching_protocol_id].protoName);",
          "6073:   }",
          "6076:   if((matching_protocol_id != NDPI_PROTOCOL_UNKNOWN) &&",
          "6077:      (!ndpi_is_more_generic_protocol(packet->detected_protocol_stack[0], matching_protocol_id))) {",
          "6079:     packet->detected_protocol_stack[1] = master_protocol_id,",
          "6080:       packet->detected_protocol_stack[0] = matching_protocol_id;",
          "6082:     flow->detected_protocol_stack[0] = packet->detected_protocol_stack[0],",
          "6083:       flow->detected_protocol_stack[1] = packet->detected_protocol_stack[1];",
          "6085:     if(flow->category == NDPI_PROTOCOL_CATEGORY_UNSPECIFIED)",
          "6086:       flow->category = ret_match->protocol_category;",
          "6088:     return(packet->detected_protocol_stack[0]);",
          "6089:   }",
          "6092:   string_to_match[string_to_match_len] = '\\0';",
          "6093:   NDPI_LOG_DBG2(ndpi_str, \"[NTOP] Unable to find a match for '%s'\\n\", string_to_match);",
          "6096:   ret_match->protocol_id = NDPI_PROTOCOL_UNKNOWN, ret_match->protocol_category = NDPI_PROTOCOL_CATEGORY_UNSPECIFIED,",
          "6099:   return(NDPI_PROTOCOL_UNKNOWN);",
          "6106:                                       ndpi_protocol_match_result *ret_match, u_int16_t master_protocol_id) {",
          "6107:   u_int16_t rc = ndpi_automa_match_string_subprotocol(ndpi_str, flow, string_to_match, string_to_match_len,",
          "6108:             master_protocol_id, ret_match, 1);",
          "6109:   u_int16_t id = ret_match->protocol_category;",
          "6111:   if(ndpi_get_custom_category_match(ndpi_str, string_to_match, string_to_match_len, &id) != -1) {",
          "6113:       flow->category = ret_match->protocol_category = id;",
          "6114:       rc = master_protocol_id;",
          "6116:   }",
          "6118:   return(rc);",
          "6124:                                  u_int16_t master_protocol, char *name, u_int name_len) {",
          "6125:   ndpi_protocol_match_result ret_match;",
          "6126:   u_int16_t subproto, what_len;",
          "6127:   char *what;",
          "6129:   if((name_len > 2) && (name[0] == '*') && (name[1] == '.'))",
          "6130:     what = &name[1], what_len = name_len - 1;",
          "6131:   else",
          "6132:     what = name, what_len = name_len;",
          "6134:   subproto = ndpi_match_host_subprotocol(ndpi_struct, flow, what, what_len, &ret_match, master_protocol);",
          "6136:   if(subproto != NDPI_PROTOCOL_UNKNOWN) {",
          "6137:     ndpi_set_detected_protocol(ndpi_struct, flow, subproto, master_protocol);",
          "6138:     ndpi_int_change_category(ndpi_struct, flow, ret_match.protocol_category);",
          "6139:     return(1);",
          "6140:   } else",
          "6141:     return(0);",
          "6146: u_int16_t ndpi_match_content_subprotocol(struct ndpi_detection_module_struct *ndpi_str,",
          "6147:       struct ndpi_flow_struct *flow,",
          "6149:                                          ndpi_protocol_match_result *ret_match,",
          "6150:       u_int16_t master_protocol_id) {",
          "6151:   return(ndpi_automa_match_string_subprotocol(ndpi_str, flow, string_to_match, string_to_match_len,",
          "6152:             master_protocol_id, ret_match, 0));",
          "6157: int ndpi_match_bigram(struct ndpi_detection_module_struct *ndpi_str,",
          "6158:         ndpi_automa *automa, char *bigram_to_match) {",
          "6159:   AC_TEXT_t ac_input_text;",
          "6160:   AC_REP_t match = {NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED, NDPI_PROTOCOL_UNRATED};",
          "6161:   int rc;",
          "6163:   if((automa->ac_automa == NULL) || (bigram_to_match == NULL))",
          "6164:     return(-1);",
          "6166:   if(!automa->ac_automa_finalized) {",
          "6167:     printf(\"[%s:%d] [NDPI] Internal error: please call ndpi_finalize_initalization()\\n\", __FILE__, __LINE__);",
          "6169:   }",
          "6171:   ac_input_text.astring = bigram_to_match, ac_input_text.length = 2;",
          "6172:   rc = ac_automata_search(((AC_AUTOMATA_t *) automa->ac_automa), &ac_input_text, &match);",
          "6179:   if((rc == 0) && (match.number != 0))",
          "6180:     rc = 1;",
          "6182:   return(rc ? match.number : 0);",
          "6187: void ndpi_free_flow(struct ndpi_flow_struct *flow) {",
          "6188:   if(flow) {",
          "6189:     if(flow->http.url)",
          "6190:       ndpi_free(flow->http.url);",
          "6191:     if(flow->http.content_type)",
          "6192:       ndpi_free(flow->http.content_type);",
          "6193:     if(flow->http.user_agent)",
          "6194:       ndpi_free(flow->http.user_agent);",
          "6195:     if(flow->kerberos_buf.pktbuf)",
          "6196:       ndpi_free(flow->kerberos_buf.pktbuf);",
          "6198:     if(flow_is_proto(flow, NDPI_PROTOCOL_TLS)) {",
          "6199:       if(flow->protos.stun_ssl.ssl.server_names)",
          "6200:  ndpi_free(flow->protos.stun_ssl.ssl.server_names);",
          "6202:       if(flow->protos.stun_ssl.ssl.alpn)",
          "6203:  ndpi_free(flow->protos.stun_ssl.ssl.alpn);",
          "6205:       if(flow->protos.stun_ssl.ssl.tls_supported_versions)",
          "6206:  ndpi_free(flow->protos.stun_ssl.ssl.tls_supported_versions);",
          "6208:       if(flow->l4.tcp.tls.srv_cert_fingerprint_ctx)",
          "6209:  ndpi_free(flow->l4.tcp.tls.srv_cert_fingerprint_ctx);",
          "6210:     }",
          "6212:     if(flow->l4_proto == IPPROTO_TCP) {",
          "6213:       if(flow->l4.tcp.tls.message.buffer)",
          "6214:  ndpi_free(flow->l4.tcp.tls.message.buffer);",
          "6217:     ndpi_free(flow);",
          "6218:   }",
          "6223: char *ndpi_revision() {",
          "6224:   return(NDPI_GIT_RELEASE);",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "6348: #ifdef WIN32",
          "6370: }",
          "6371: #endif",
          "6383: }",
          "6385: #ifdef CODE_UNUSED",
          "6395: }",
          "6404: }",
          "6405: #endif",
          "6410: }",
          "6415: }",
          "6420: }",
          "6425: }",
          "6430: }",
          "6435: }",
          "6456: }",
          "6462: }",
          "6475: }",
          "6482: }",
          "6496: #if 0",
          "6497:   printf(\"[DEBUG] %s(%u.%u): %u\\n\", __FUNCTION__,",
          "6498:   flow->detected_protocol_stack[0],",
          "6499:   flow->detected_protocol_stack[1],",
          "6501: #endif",
          "6539: }",
          "6564: }",
          "6583: }",
          "6599:     }",
          "6602: }",
          "6616: }",
          "6649: }",
          "6674: }",
          "6685: }",
          "",
          "[Removed Lines]",
          "6351: int gettimeofday(struct timeval *tp, struct timezone *tzp)",
          "6352: {",
          "6356:     static const uint64_t EPOCH = ((uint64_t) 116444736000000000ULL);",
          "6358:     SYSTEMTIME system_time;",
          "6359:     FILETIME file_time;",
          "6360:     uint64_t time;",
          "6362:     GetSystemTime(&system_time);",
          "6363:     SystemTimeToFileTime(&system_time, &file_time);",
          "6364:     time = ((uint64_t) file_time.dwLowDateTime);",
          "6365:     time += ((uint64_t) file_time.dwHighDateTime) << 32;",
          "6367:     tp->tv_sec = (long) ((time - EPOCH) / 10000000L);",
          "6368:     tp->tv_usec = (long) (system_time.wMilliseconds * 1000);",
          "6369:     return (0);",
          "6373: int NDPI_BITMASK_COMPARE(NDPI_PROTOCOL_BITMASK a, NDPI_PROTOCOL_BITMASK b)",
          "6374: {",
          "6375:     int i;",
          "6377:     for (i = 0; i < NDPI_NUM_FDS_BITS; i++) {",
          "6378:         if (a.fds_bits[i] & b.fds_bits[i])",
          "6379:             return (1);",
          "6380:     }",
          "6382:     return (0);",
          "6386: int NDPI_BITMASK_IS_EMPTY(NDPI_PROTOCOL_BITMASK a)",
          "6387: {",
          "6388:     int i;",
          "6390:     for (i = 0; i < NDPI_NUM_FDS_BITS; i++)",
          "6391:         if (a.fds_bits[i] != 0)",
          "6392:             return (0);",
          "6394:     return (1);",
          "6397: void NDPI_DUMP_BITMASK(NDPI_PROTOCOL_BITMASK a)",
          "6398: {",
          "6399:     int i;",
          "6400:     for (i = 0; i < NDPI_NUM_FDS_BITS; i++)",
          "6401:         printf(\"[%d=%u]\", i, a.fds_bits[i]);",
          "6403:     printf(\"\\n\");",
          "6407: u_int16_t ndpi_get_api_version()",
          "6408: {",
          "6409:     return (NDPI_API_VERSION);",
          "6412: ndpi_proto_defaults_t *ndpi_get_proto_defaults(struct ndpi_detection_module_struct *ndpi_str)",
          "6413: {",
          "6414:     return (ndpi_str->proto_defaults);",
          "6417: u_int ndpi_get_ndpi_num_supported_protocols(struct ndpi_detection_module_struct *ndpi_str)",
          "6418: {",
          "6419:     return (ndpi_str->ndpi_num_supported_protocols);",
          "6422: u_int ndpi_get_ndpi_num_custom_protocols(struct ndpi_detection_module_struct *ndpi_str)",
          "6423: {",
          "6424:     return (ndpi_str->ndpi_num_custom_protocols);",
          "6427: u_int ndpi_get_ndpi_detection_module_size()",
          "6428: {",
          "6429:     return (sizeof(struct ndpi_detection_module_struct));",
          "6432: void ndpi_set_log_level(struct ndpi_detection_module_struct *ndpi_str, u_int l)",
          "6433: {",
          "6434:     ndpi_str->ndpi_log_level = l;",
          "6440: struct ndpi_lru_cache *ndpi_lru_cache_init(u_int32_t num_entries)",
          "6441: {",
          "6442:     struct ndpi_lru_cache *c = (struct ndpi_lru_cache *) ndpi_malloc(sizeof(struct ndpi_lru_cache));",
          "6444:     if (!c)",
          "6445:         return (NULL);",
          "6447:     c->entries = (struct ndpi_lru_cache_entry *) ndpi_calloc(num_entries, sizeof(struct ndpi_lru_cache_entry));",
          "6449:     if (!c->entries) {",
          "6450:         ndpi_free(c);",
          "6451:         return (NULL);",
          "6452:     } else",
          "6453:         c->num_entries = num_entries;",
          "6455:     return (c);",
          "6458: void ndpi_lru_free_cache(struct ndpi_lru_cache *c)",
          "6459: {",
          "6460:     ndpi_free(c->entries);",
          "6461:     ndpi_free(c);",
          "6464: u_int8_t ndpi_lru_find_cache(struct ndpi_lru_cache *c, u_int32_t key, u_int16_t *value, u_int8_t clean_key_when_found)",
          "6465: {",
          "6466:     u_int32_t slot = key % c->num_entries;",
          "6468:     if (c->entries[slot].is_full) {",
          "6470:         if (clean_key_when_found)",
          "6471:             c->entries[slot].is_full = 0;",
          "6472:         return (1);",
          "6473:     } else",
          "6474:         return (0);",
          "6477: void ndpi_lru_add_to_cache(struct ndpi_lru_cache *c, u_int32_t key, u_int16_t value)",
          "6478: {",
          "6479:     u_int32_t slot = key % c->num_entries;",
          "6481:     c->entries[slot].is_full = 1, c->entries[slot].key = key, c->entries[slot].value = value;",
          "6487:    This function tells if it's possible to further dissect a given flow",
          "6488:    0 - All possible dissection has been completed",
          "6489:    1 - Additional dissection is possible",
          "6491: u_int8_t ndpi_extra_dissection_possible(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow)",
          "6492: {",
          "6493:     u_int16_t proto =",
          "6494:         flow->detected_protocol_stack[1] ? flow->detected_protocol_stack[1] : flow->detected_protocol_stack[0];",
          "6500:    proto);",
          "6503:     switch (proto) {",
          "6504:         case NDPI_PROTOCOL_TLS:",
          "6505:             if (!flow->l4.tcp.tls.certificate_processed)",
          "6507:             break;",
          "6509:         case NDPI_PROTOCOL_HTTP:",
          "6510:             if ((flow->host_server_name[0] == '\\0') || (flow->http.response_status_code == 0))",
          "6511:                 return (1);",
          "6512:             break;",
          "6514:         case NDPI_PROTOCOL_DNS:",
          "6515:             if (flow->protos.dns.num_answers == 0)",
          "6516:                 return (1);",
          "6517:             break;",
          "6519:         case NDPI_PROTOCOL_FTP_CONTROL:",
          "6520:         case NDPI_PROTOCOL_MAIL_POP:",
          "6521:         case NDPI_PROTOCOL_MAIL_IMAP:",
          "6522:         case NDPI_PROTOCOL_MAIL_SMTP:",
          "6523:             if (flow->protos.ftp_imap_pop_smtp.password[0] == '\\0')",
          "6524:                 return (1);",
          "6525:             break;",
          "6527:         case NDPI_PROTOCOL_SSH:",
          "6528:             if ((flow->protos.ssh.hassh_client[0] == '\\0') || (flow->protos.ssh.hassh_server[0] == '\\0'))",
          "6529:                 return (1);",
          "6530:             break;",
          "6532:         case NDPI_PROTOCOL_TELNET:",
          "6533:             if (!flow->protos.telnet.password_detected)",
          "6534:                 return (1);",
          "6535:             break;",
          "6536:     }",
          "6538:     return (0);",
          "6543: const char *ndpi_get_l4_proto_name(ndpi_l4_proto_info proto)",
          "6544: {",
          "6545:     switch (proto) {",
          "6546:         case ndpi_l4_proto_unknown:",
          "6547:             return (\"\");",
          "6548:             break;",
          "6550:         case ndpi_l4_proto_tcp_only:",
          "6551:             return (\"TCP\");",
          "6552:             break;",
          "6554:         case ndpi_l4_proto_udp_only:",
          "6555:             return (\"UDP\");",
          "6556:             break;",
          "6558:         case ndpi_l4_proto_tcp_and_udp:",
          "6559:             return (\"TCP/UDP\");",
          "6560:             break;",
          "6561:     }",
          "6563:     return (\"\");",
          "6568: ndpi_l4_proto_info ndpi_get_l4_proto_info(struct ndpi_detection_module_struct *ndpi_struct, u_int16_t ndpi_proto_id)",
          "6569: {",
          "6570:     if (ndpi_proto_id < ndpi_struct->ndpi_num_supported_protocols) {",
          "6571:         u_int16_t idx = ndpi_struct->proto_defaults[ndpi_proto_id].protoIdx;",
          "6572:         NDPI_SELECTION_BITMASK_PROTOCOL_SIZE bm = ndpi_struct->callback_buffer[idx].ndpi_selection_bitmask;",
          "6574:         if (bm & NDPI_SELECTION_BITMASK_PROTOCOL_INT_TCP)",
          "6575:             return (ndpi_l4_proto_tcp_only);",
          "6576:         else if (bm & NDPI_SELECTION_BITMASK_PROTOCOL_INT_UDP)",
          "6577:             return (ndpi_l4_proto_udp_only);",
          "6578:         else if (bm & NDPI_SELECTION_BITMASK_PROTOCOL_INT_TCP_OR_UDP)",
          "6579:             return (ndpi_l4_proto_tcp_and_udp);",
          "6580:     }",
          "6587: ndpi_ptree_t *ndpi_ptree_create(void)",
          "6588: {",
          "6589:     ndpi_ptree_t *tree = (ndpi_ptree_t *) ndpi_malloc(sizeof(ndpi_ptree_t));",
          "6591:     if (tree) {",
          "6592:         tree->v4 = ndpi_New_Patricia(32);",
          "6593:         tree->v6 = ndpi_New_Patricia(128);",
          "6595:         if ((!tree->v4) || (!tree->v6)) {",
          "6596:             ndpi_ptree_destroy(tree);",
          "6597:             return (NULL);",
          "6598:         }",
          "6601:     return (tree);",
          "6606: void ndpi_ptree_destroy(ndpi_ptree_t *tree)",
          "6607: {",
          "6608:     if (tree) {",
          "6609:         if (tree->v4)",
          "6610:             ndpi_Destroy_Patricia(tree->v4, free_ptree_data);",
          "6611:         if (tree->v6)",
          "6612:             ndpi_Destroy_Patricia(tree->v6, free_ptree_data);",
          "6614:         ndpi_free(tree);",
          "6615:     }",
          "6620: int ndpi_ptree_insert(ndpi_ptree_t *tree, const ndpi_ip_addr_t *addr, u_int8_t bits, uint user_data)",
          "6621: {",
          "6622:     u_int8_t is_v6 = ndpi_is_ipv6(addr);",
          "6623:     patricia_tree_t *ptree = is_v6 ? tree->v6 : tree->v4;",
          "6624:     prefix_t prefix;",
          "6625:     patricia_node_t *node;",
          "6627:     if (bits > ptree->maxbits)",
          "6628:         return (-1);",
          "6630:     if (is_v6)",
          "6631:         fill_prefix_v6(&prefix, (const struct in6_addr *) &addr->ipv6, bits, ptree->maxbits);",
          "6632:     else",
          "6633:         fill_prefix_v4(&prefix, (const struct in_addr *) &addr->ipv4, bits, ptree->maxbits);",
          "6636:     node = ndpi_patricia_search_best(ptree, &prefix);",
          "6638:     if (node && (node->prefix->bitlen == bits))",
          "6639:         return (-2);",
          "6641:     node = ndpi_patricia_lookup(ptree, &prefix);",
          "6643:     if (node != NULL) {",
          "6644:         node->value.user_value = user_data;",
          "6645:         return (0);",
          "6646:     }",
          "6648:     return (-3);",
          "6653: int ndpi_ptree_match_addr(ndpi_ptree_t *tree, const ndpi_ip_addr_t *addr, uint *user_data)",
          "6654: {",
          "6655:     u_int8_t is_v6 = ndpi_is_ipv6(addr);",
          "6656:     patricia_tree_t *ptree = is_v6 ? tree->v6 : tree->v4;",
          "6657:     prefix_t prefix;",
          "6658:     patricia_node_t *node;",
          "6659:     int bits = ptree->maxbits;",
          "6661:     if (is_v6)",
          "6662:         fill_prefix_v6(&prefix, (const struct in6_addr *) &addr->ipv6, bits, ptree->maxbits);",
          "6663:     else",
          "6664:         fill_prefix_v4(&prefix, (const struct in_addr *) &addr->ipv4, bits, ptree->maxbits);",
          "6666:     node = ndpi_patricia_search_best(ptree, &prefix);",
          "6668:     if (node) {",
          "6670:         return (0);",
          "6671:     }",
          "6673:     return (-1);",
          "6678: void ndpi_md5(const u_char *data, size_t data_len, u_char hash[16])",
          "6679: {",
          "6680:     ndpi_MD5_CTX ctx;",
          "6682:     ndpi_MD5Init(&ctx);",
          "6683:     ndpi_MD5Update(&ctx, data, data_len);",
          "6684:     ndpi_MD5Final(hash, &ctx);",
          "",
          "[Added Lines]",
          "6232: int gettimeofday(struct timeval *tp, struct timezone *tzp) {",
          "6236:   static const uint64_t EPOCH = ((uint64_t) 116444736000000000ULL);",
          "6238:   SYSTEMTIME system_time;",
          "6239:   FILETIME file_time;",
          "6240:   uint64_t time;",
          "6242:   GetSystemTime(&system_time);",
          "6243:   SystemTimeToFileTime(&system_time, &file_time);",
          "6244:   time = ((uint64_t) file_time.dwLowDateTime);",
          "6245:   time += ((uint64_t) file_time.dwHighDateTime) << 32;",
          "6247:   tp->tv_sec = (long) ((time - EPOCH) / 10000000L);",
          "6248:   tp->tv_usec = (long) (system_time.wMilliseconds * 1000);",
          "6249:   return(0);",
          "6253: int NDPI_BITMASK_COMPARE(NDPI_PROTOCOL_BITMASK a, NDPI_PROTOCOL_BITMASK b) {",
          "6254:   int i;",
          "6256:   for (i = 0; i < NDPI_NUM_FDS_BITS; i++) {",
          "6257:     if(a.fds_bits[i] & b.fds_bits[i])",
          "6258:       return(1);",
          "6259:   }",
          "6261:   return(0);",
          "6265: int NDPI_BITMASK_IS_EMPTY(NDPI_PROTOCOL_BITMASK a) {",
          "6266:   int i;",
          "6268:   for (i = 0; i < NDPI_NUM_FDS_BITS; i++)",
          "6269:     if(a.fds_bits[i] != 0)",
          "6270:       return(0);",
          "6272:   return(1);",
          "6275: void NDPI_DUMP_BITMASK(NDPI_PROTOCOL_BITMASK a) {",
          "6276:   int i;",
          "6278:   for (i = 0; i < NDPI_NUM_FDS_BITS; i++)",
          "6279:     printf(\"[%d=%u]\", i, a.fds_bits[i]);",
          "6281:   printf(\"\\n\");",
          "6285: u_int16_t ndpi_get_api_version() {",
          "6286:   return(NDPI_API_VERSION);",
          "6289: ndpi_proto_defaults_t *ndpi_get_proto_defaults(struct ndpi_detection_module_struct *ndpi_str) {",
          "6290:   return(ndpi_str->proto_defaults);",
          "6293: u_int ndpi_get_ndpi_num_supported_protocols(struct ndpi_detection_module_struct *ndpi_str) {",
          "6294:   return(ndpi_str->ndpi_num_supported_protocols);",
          "6297: u_int ndpi_get_ndpi_num_custom_protocols(struct ndpi_detection_module_struct *ndpi_str) {",
          "6298:   return(ndpi_str->ndpi_num_custom_protocols);",
          "6301: u_int ndpi_get_ndpi_detection_module_size() {",
          "6302:   return(sizeof(struct ndpi_detection_module_struct));",
          "6305: void ndpi_set_log_level(struct ndpi_detection_module_struct *ndpi_str, u_int l){",
          "6306:   ndpi_str->ndpi_log_level = l;",
          "6312: struct ndpi_lru_cache *ndpi_lru_cache_init(u_int32_t num_entries) {",
          "6313:   struct ndpi_lru_cache *c = (struct ndpi_lru_cache *) ndpi_malloc(sizeof(struct ndpi_lru_cache));",
          "6315:   if(!c)",
          "6316:     return(NULL);",
          "6318:   c->entries = (struct ndpi_lru_cache_entry *) ndpi_calloc(num_entries, sizeof(struct ndpi_lru_cache_entry));",
          "6320:   if(!c->entries) {",
          "6321:     ndpi_free(c);",
          "6322:     return(NULL);",
          "6323:   } else",
          "6324:     c->num_entries = num_entries;",
          "6326:   return(c);",
          "6329: void ndpi_lru_free_cache(struct ndpi_lru_cache *c) {",
          "6330:   ndpi_free(c->entries);",
          "6331:   ndpi_free(c);",
          "6334: u_int8_t ndpi_lru_find_cache(struct ndpi_lru_cache *c, u_int32_t key,",
          "6335:         u_int16_t *value, u_int8_t clean_key_when_found) {",
          "6336:   u_int32_t slot = key % c->num_entries;",
          "6338:   if(c->entries[slot].is_full) {",
          "6340:     if(clean_key_when_found)",
          "6341:       c->entries[slot].is_full = 0;",
          "6342:     return(1);",
          "6343:   } else",
          "6344:     return(0);",
          "6347: void ndpi_lru_add_to_cache(struct ndpi_lru_cache *c, u_int32_t key, u_int16_t value) {",
          "6348:   u_int32_t slot = key % c->num_entries;",
          "6350:   c->entries[slot].is_full = 1, c->entries[slot].key = key, c->entries[slot].value = value;",
          "6356:   This function tells if it's possible to further dissect a given flow",
          "6357:   0 - All possible dissection has been completed",
          "6358:   1 - Additional dissection is possible",
          "6360: u_int8_t ndpi_extra_dissection_possible(struct ndpi_detection_module_struct *ndpi_str,",
          "6361:      struct ndpi_flow_struct *flow) {",
          "6362:   u_int16_t proto =",
          "6363:     flow->detected_protocol_stack[1] ? flow->detected_protocol_stack[1] : flow->detected_protocol_stack[0];",
          "6369:   proto);",
          "6372:   switch (proto) {",
          "6373:   case NDPI_PROTOCOL_TLS:",
          "6374:     if(!flow->l4.tcp.tls.certificate_processed)",
          "6376:     break;",
          "6378:   case NDPI_PROTOCOL_HTTP:",
          "6379:     if((flow->host_server_name[0] == '\\0') || (flow->http.response_status_code == 0))",
          "6380:       return(1);",
          "6381:     break;",
          "6383:   case NDPI_PROTOCOL_DNS:",
          "6384:     if(flow->protos.dns.num_answers == 0)",
          "6385:       return(1);",
          "6386:     break;",
          "6388:   case NDPI_PROTOCOL_FTP_CONTROL:",
          "6389:   case NDPI_PROTOCOL_MAIL_POP:",
          "6390:   case NDPI_PROTOCOL_MAIL_IMAP:",
          "6391:   case NDPI_PROTOCOL_MAIL_SMTP:",
          "6392:     if(flow->protos.ftp_imap_pop_smtp.password[0] == '\\0')",
          "6393:       return(1);",
          "6394:     break;",
          "6396:   case NDPI_PROTOCOL_SSH:",
          "6397:     if((flow->protos.ssh.hassh_client[0] == '\\0') || (flow->protos.ssh.hassh_server[0] == '\\0'))",
          "6398:       return(1);",
          "6399:     break;",
          "6401:   case NDPI_PROTOCOL_TELNET:",
          "6402:     if(!flow->protos.telnet.password_detected)",
          "6403:       return(1);",
          "6404:     break;",
          "6405:   }",
          "6407:   return(0);",
          "6412: const char *ndpi_get_l4_proto_name(ndpi_l4_proto_info proto) {",
          "6413:   switch (proto) {",
          "6414:   case ndpi_l4_proto_unknown:",
          "6415:     return(\"\");",
          "6416:     break;",
          "6418:   case ndpi_l4_proto_tcp_only:",
          "6419:     return(\"TCP\");",
          "6420:     break;",
          "6422:   case ndpi_l4_proto_udp_only:",
          "6423:     return(\"UDP\");",
          "6424:     break;",
          "6426:   case ndpi_l4_proto_tcp_and_udp:",
          "6427:     return(\"TCP/UDP\");",
          "6428:     break;",
          "6429:   }",
          "6431:   return(\"\");",
          "6436: ndpi_l4_proto_info ndpi_get_l4_proto_info(struct ndpi_detection_module_struct *ndpi_struct,",
          "6437:        u_int16_t ndpi_proto_id) {",
          "6438:   if(ndpi_proto_id < ndpi_struct->ndpi_num_supported_protocols) {",
          "6439:     u_int16_t idx = ndpi_struct->proto_defaults[ndpi_proto_id].protoIdx;",
          "6440:     NDPI_SELECTION_BITMASK_PROTOCOL_SIZE bm = ndpi_struct->callback_buffer[idx].ndpi_selection_bitmask;",
          "6442:     if(bm & NDPI_SELECTION_BITMASK_PROTOCOL_INT_TCP)",
          "6443:       return(ndpi_l4_proto_tcp_only);",
          "6444:     else if(bm & NDPI_SELECTION_BITMASK_PROTOCOL_INT_UDP)",
          "6445:       return(ndpi_l4_proto_udp_only);",
          "6446:     else if(bm & NDPI_SELECTION_BITMASK_PROTOCOL_INT_TCP_OR_UDP)",
          "6447:       return(ndpi_l4_proto_tcp_and_udp);",
          "6448:   }",
          "6455: ndpi_ptree_t *ndpi_ptree_create(void) {",
          "6456:   ndpi_ptree_t *tree = (ndpi_ptree_t *) ndpi_malloc(sizeof(ndpi_ptree_t));",
          "6458:   if(tree) {",
          "6459:     tree->v4 = ndpi_New_Patricia(32);",
          "6460:     tree->v6 = ndpi_New_Patricia(128);",
          "6462:     if((!tree->v4) || (!tree->v6)) {",
          "6463:       ndpi_ptree_destroy(tree);",
          "6464:       return(NULL);",
          "6466:   }",
          "6468:   return(tree);",
          "6473: void ndpi_ptree_destroy(ndpi_ptree_t *tree) {",
          "6474:   if(tree) {",
          "6475:     if(tree->v4)",
          "6476:       ndpi_Destroy_Patricia(tree->v4, free_ptree_data);",
          "6477:     if(tree->v6)",
          "6478:       ndpi_Destroy_Patricia(tree->v6, free_ptree_data);",
          "6480:     ndpi_free(tree);",
          "6481:   }",
          "6486: int ndpi_ptree_insert(ndpi_ptree_t *tree, const ndpi_ip_addr_t *addr,",
          "6487:         u_int8_t bits, uint user_data) {",
          "6488:   u_int8_t is_v6 = ndpi_is_ipv6(addr);",
          "6489:   patricia_tree_t *ptree = is_v6 ? tree->v6 : tree->v4;",
          "6490:   prefix_t prefix;",
          "6491:   patricia_node_t *node;",
          "6493:   if(bits > ptree->maxbits)",
          "6494:     return(-1);",
          "6496:   if(is_v6)",
          "6497:     fill_prefix_v6(&prefix, (const struct in6_addr *) &addr->ipv6, bits, ptree->maxbits);",
          "6498:   else",
          "6499:     fill_prefix_v4(&prefix, (const struct in_addr *) &addr->ipv4, bits, ptree->maxbits);",
          "6502:   node = ndpi_patricia_search_best(ptree, &prefix);",
          "6504:   if(node && (node->prefix->bitlen == bits))",
          "6505:     return(-2);",
          "6507:   node = ndpi_patricia_lookup(ptree, &prefix);",
          "6509:   if(node != NULL) {",
          "6510:     node->value.user_value = user_data, node->value.user_value2 = 0;",
          "6512:     return(0);",
          "6513:   }",
          "6515:   return(-3);",
          "6520: int ndpi_ptree_match_addr(ndpi_ptree_t *tree,",
          "6521:      const ndpi_ip_addr_t *addr, uint *user_data) {",
          "6522:   u_int8_t is_v6 = ndpi_is_ipv6(addr);",
          "6523:   patricia_tree_t *ptree = is_v6 ? tree->v6 : tree->v4;",
          "6524:   prefix_t prefix;",
          "6525:   patricia_node_t *node;",
          "6526:   int bits = ptree->maxbits;",
          "6528:   if(is_v6)",
          "6529:     fill_prefix_v6(&prefix, (const struct in6_addr *) &addr->ipv6, bits, ptree->maxbits);",
          "6530:   else",
          "6531:     fill_prefix_v4(&prefix, (const struct in_addr *) &addr->ipv4, bits, ptree->maxbits);",
          "6533:   node = ndpi_patricia_search_best(ptree, &prefix);",
          "6535:   if(node) {",
          "6538:     return(0);",
          "6539:   }",
          "6541:   return(-1);",
          "6546: void ndpi_md5(const u_char *data, size_t data_len, u_char hash[16]) {",
          "6547:   ndpi_MD5_CTX ctx;",
          "6549:   ndpi_MD5Init(&ctx);",
          "6550:   ndpi_MD5Update(&ctx, data, data_len);",
          "6551:   ndpi_MD5Final(hash, &ctx);",
          "",
          "---------------"
        ],
        "src/lib/third_party/include/ndpi_patricia.h||src/lib/third_party/include/ndpi_patricia.h": [
          "File: src/lib/third_party/include/ndpi_patricia.h -> src/lib/third_party/include/ndpi_patricia.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "103: union patricia_node_value_t {",
          "104:   void *user_data;",
          "106: };",
          "108: typedef struct _patricia_node_t {",
          "",
          "[Removed Lines]",
          "105:   unsigned int user_value;",
          "",
          "[Added Lines]",
          "107:   u_int16_t user_value;",
          "108:   u_int16_t user_value2;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
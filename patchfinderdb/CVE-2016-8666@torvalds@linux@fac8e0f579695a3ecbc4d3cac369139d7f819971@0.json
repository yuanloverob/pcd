{
  "cve_id": "CVE-2016-8666",
  "cve_desc": "The IP stack in the Linux kernel before 4.6 allows remote attackers to cause a denial of service (stack consumption and panic) or possibly have unspecified other impact by triggering use of the GRO path for packets with tunnel stacking, as demonstrated by interleaved IPv4 headers and GRE headers, a related issue to CVE-2016-7039.",
  "repo": "torvalds/linux",
  "patch_hash": "fac8e0f579695a3ecbc4d3cac369139d7f819971",
  "patch_info": {
    "commit_hash": "fac8e0f579695a3ecbc4d3cac369139d7f819971",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/fac8e0f579695a3ecbc4d3cac369139d7f819971",
    "files": [
      "include/linux/netdevice.h",
      "net/core/dev.c",
      "net/ipv4/af_inet.c",
      "net/ipv4/gre_offload.c",
      "net/ipv4/udp_offload.c",
      "net/ipv6/ip6_offload.c"
    ],
    "message": "tunnels: Don't apply GRO to multiple layers of encapsulation.\n\nWhen drivers express support for TSO of encapsulated packets, they\nonly mean that they can do it for one layer of encapsulation.\nSupporting additional levels would mean updating, at a minimum,\nmore IP length fields and they are unaware of this.\n\nNo encapsulation device expresses support for handling offloaded\nencapsulated packets, so we won't generate these types of frames\nin the transmit path. However, GRO doesn't have a check for\nmultiple levels of encapsulation and will attempt to build them.\n\nUDP tunnel GRO actually does prevent this situation but it only\nhandles multiple UDP tunnels stacked on top of each other. This\ngeneralizes that solution to prevent any kind of tunnel stacking\nthat would cause problems.\n\nFixes: bf5a755f (\"net-gre-gro: Add GRE support to the GRO stack\")\nSigned-off-by: Jesse Gross <jesse@kernel.org>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
    "before_after_code_files": [
      "include/linux/netdevice.h||include/linux/netdevice.h",
      "net/core/dev.c||net/core/dev.c",
      "net/ipv4/af_inet.c||net/ipv4/af_inet.c",
      "net/ipv4/gre_offload.c||net/ipv4/gre_offload.c",
      "net/ipv4/udp_offload.c||net/ipv4/udp_offload.c",
      "net/ipv6/ip6_offload.c||net/ipv6/ip6_offload.c"
    ]
  },
  "patch_diff": {
    "include/linux/netdevice.h||include/linux/netdevice.h": [
      "File: include/linux/netdevice.h -> include/linux/netdevice.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "2097:  u8 same_flow:1;",
      "2103:  u8 csum_valid:1;",
      "",
      "[Removed Lines]",
      "2100:  u8 udp_mark:1;",
      "",
      "[Added Lines]",
      "2100:  u8 encap_mark:1;",
      "",
      "---------------"
    ],
    "net/core/dev.c||net/core/dev.c": [
      "File: net/core/dev.c -> net/core/dev.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "4438:   NAPI_GRO_CB(skb)->same_flow = 0;",
      "4439:   NAPI_GRO_CB(skb)->flush = 0;",
      "4440:   NAPI_GRO_CB(skb)->free = 0;",
      "4442:   NAPI_GRO_CB(skb)->gro_remcsum_start = 0;",
      "",
      "[Removed Lines]",
      "4441:   NAPI_GRO_CB(skb)->udp_mark = 0;",
      "",
      "[Added Lines]",
      "4441:   NAPI_GRO_CB(skb)->encap_mark = 0;",
      "",
      "---------------"
    ],
    "net/ipv4/af_inet.c||net/ipv4/af_inet.c": [
      "File: net/ipv4/af_inet.c -> net/ipv4/af_inet.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1380:  return pp;",
      "1381: }",
      "1383: #define SECONDS_PER_DAY 86400",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1383: static struct sk_buff **ipip_gro_receive(struct sk_buff **head,",
      "1384:       struct sk_buff *skb)",
      "1385: {",
      "1386:  if (NAPI_GRO_CB(skb)->encap_mark) {",
      "1387:   NAPI_GRO_CB(skb)->flush = 1;",
      "1388:   return NULL;",
      "1389:  }",
      "1391:  NAPI_GRO_CB(skb)->encap_mark = 1;",
      "1393:  return inet_gro_receive(head, skb);",
      "1394: }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1682: static const struct net_offload ipip_offload = {",
      "1683:  .callbacks = {",
      "1684:   .gso_segment = inet_gso_segment,",
      "1686:   .gro_complete = ipip_gro_complete,",
      "1687:  },",
      "1688: };",
      "",
      "[Removed Lines]",
      "1685:   .gro_receive = inet_gro_receive,",
      "",
      "[Added Lines]",
      "1698:   .gro_receive = ipip_gro_receive,",
      "",
      "---------------"
    ],
    "net/ipv4/gre_offload.c||net/ipv4/gre_offload.c": [
      "File: net/ipv4/gre_offload.c -> net/ipv4/gre_offload.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "126:  struct packet_offload *ptype;",
      "127:  __be16 type;",
      "129:  off = skb_gro_offset(skb);",
      "130:  hlen = off + sizeof(*greh);",
      "131:  greh = skb_gro_header_fast(skb, off);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "129:  if (NAPI_GRO_CB(skb)->encap_mark)",
      "130:   goto out;",
      "132:  NAPI_GRO_CB(skb)->encap_mark = 1;",
      "",
      "---------------"
    ],
    "net/ipv4/udp_offload.c||net/ipv4/udp_offload.c": [
      "File: net/ipv4/udp_offload.c -> net/ipv4/udp_offload.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "311:  unsigned int off = skb_gro_offset(skb);",
      "312:  int flush = 1;",
      "315:      (skb->ip_summed != CHECKSUM_PARTIAL &&",
      "316:       NAPI_GRO_CB(skb)->csum_cnt == 0 &&",
      "317:       !NAPI_GRO_CB(skb)->csum_valid))",
      "318:   goto out;",
      "323:  rcu_read_lock();",
      "324:  uo_priv = rcu_dereference(udp_offload_base);",
      "",
      "[Removed Lines]",
      "314:  if (NAPI_GRO_CB(skb)->udp_mark ||",
      "321:  NAPI_GRO_CB(skb)->udp_mark = 1;",
      "",
      "[Added Lines]",
      "314:  if (NAPI_GRO_CB(skb)->encap_mark ||",
      "321:  NAPI_GRO_CB(skb)->encap_mark = 1;",
      "",
      "---------------"
    ],
    "net/ipv6/ip6_offload.c||net/ipv6/ip6_offload.c": [
      "File: net/ipv6/ip6_offload.c -> net/ipv6/ip6_offload.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "258:  return pp;",
      "259: }",
      "261: static int ipv6_gro_complete(struct sk_buff *skb, int nhoff)",
      "262: {",
      "263:  const struct net_offload *ops;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "261: static struct sk_buff **sit_gro_receive(struct sk_buff **head,",
      "262:      struct sk_buff *skb)",
      "263: {",
      "264:  if (NAPI_GRO_CB(skb)->encap_mark) {",
      "265:   NAPI_GRO_CB(skb)->flush = 1;",
      "266:   return NULL;",
      "267:  }",
      "269:  NAPI_GRO_CB(skb)->encap_mark = 1;",
      "271:  return ipv6_gro_receive(head, skb);",
      "272: }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "302: static const struct net_offload sit_offload = {",
      "303:  .callbacks = {",
      "304:   .gso_segment = ipv6_gso_segment,",
      "306:   .gro_complete   = sit_gro_complete,",
      "307:  },",
      "308: };",
      "",
      "[Removed Lines]",
      "305:   .gro_receive    = ipv6_gro_receive,",
      "",
      "[Added Lines]",
      "318:   .gro_receive    = sit_gro_receive,",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "815d22e55b0eba3bfb8f0ba532ce9ae364fee556",
      "candidate_info": {
        "commit_hash": "815d22e55b0eba3bfb8f0ba532ce9ae364fee556",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/815d22e55b0eba3bfb8f0ba532ce9ae364fee556",
        "files": [
          "net/ipv6/ip6_offload.c",
          "net/ipv6/ip6_tunnel.c"
        ],
        "message": "ip6ip6: Support for GSO/GRO\n\nSigned-off-by: Tom Herbert <tom@herbertland.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "net/ipv6/ip6_offload.c||net/ipv6/ip6_offload.c",
          "net/ipv6/ip6_tunnel.c||net/ipv6/ip6_tunnel.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "net/ipv6/ip6_offload.c||net/ipv6/ip6_offload.c"
          ],
          "candidate": [
            "net/ipv6/ip6_offload.c||net/ipv6/ip6_offload.c"
          ]
        }
      },
      "candidate_diff": {
        "net/ipv6/ip6_offload.c||net/ipv6/ip6_offload.c": [
          "File: net/ipv6/ip6_offload.c -> net/ipv6/ip6_offload.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "253:  return pp;",
          "254: }",
          "258: {",
          "259:  if (NAPI_GRO_CB(skb)->encap_mark) {",
          "260:   NAPI_GRO_CB(skb)->flush = 1;",
          "261:   return NULL;",
          "",
          "[Removed Lines]",
          "256: static struct sk_buff **sit_gro_receive(struct sk_buff **head,",
          "257:      struct sk_buff *skb)",
          "",
          "[Added Lines]",
          "256: static struct sk_buff **sit_ip6ip6_gro_receive(struct sk_buff **head,",
          "257:             struct sk_buff *skb)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "298:  return ipv6_gro_complete(skb, nhoff);",
          "299: }",
          "301: static struct packet_offload ipv6_packet_offload __read_mostly = {",
          "302:  .type = cpu_to_be16(ETH_P_IPV6),",
          "303:  .callbacks = {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "303: static int ip6ip6_gro_complete(struct sk_buff *skb, int nhoff)",
          "304: {",
          "305:  skb->encapsulation = 1;",
          "306:  skb_shinfo(skb)->gso_type |= SKB_GSO_IPXIP6;",
          "307:  return ipv6_gro_complete(skb, nhoff);",
          "308: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "310: static const struct net_offload sit_offload = {",
          "311:  .callbacks = {",
          "312:   .gso_segment = ipv6_gso_segment,",
          "314:   .gro_complete   = sit_gro_complete,",
          "315:  },",
          "316: };",
          "318: static int __init ipv6_offload_init(void)",
          "319: {",
          "",
          "[Removed Lines]",
          "313:   .gro_receive    = sit_gro_receive,",
          "",
          "[Added Lines]",
          "322:   .gro_receive    = sit_ip6ip6_gro_receive,",
          "327: static const struct net_offload ip6ip6_offload = {",
          "328:  .callbacks = {",
          "329:   .gso_segment = ipv6_gso_segment,",
          "330:   .gro_receive    = sit_ip6ip6_gro_receive,",
          "331:   .gro_complete   = ip6ip6_gro_complete,",
          "332:  },",
          "333: };",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "326:  dev_add_offload(&ipv6_packet_offload);",
          "328:  inet_add_offload(&sit_offload, IPPROTO_IPV6);",
          "330:  return 0;",
          "331: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "346:  inet6_add_offload(&ip6ip6_offload, IPPROTO_IPV6);",
          "",
          "---------------"
        ],
        "net/ipv6/ip6_tunnel.c||net/ipv6/ip6_tunnel.c": [
          "File: net/ipv6/ip6_tunnel.c -> net/ipv6/ip6_tunnel.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1242:  if (t->parms.flags & IP6_TNL_F_USE_ORIG_FWMARK)",
          "1243:   fl6.flowi6_mark = skb->mark;",
          "1245:  err = ip6_tnl_xmit(skb, dev, dsfield, &fl6, encap_limit, &mtu,",
          "1246:       IPPROTO_IPV6);",
          "1247:  if (err != 0) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1245:  if (iptunnel_handle_offloads(skb, SKB_GSO_IPXIP6))",
          "1246:   return -1;",
          "1248:  skb_set_inner_ipproto(skb, IPPROTO_IPV6);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "feec0cb3f20b837f8ca36e974267918d7a4497f8",
      "candidate_info": {
        "commit_hash": "feec0cb3f20b837f8ca36e974267918d7a4497f8",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/feec0cb3f20b837f8ca36e974267918d7a4497f8",
        "files": [
          "net/ipv6/ip6_offload.c"
        ],
        "message": "ipv6: gro: support sit protocol\n\nTom Herbert added SIT support to GRO with commit\n19424e052fb4 (\"sit: Add gro callbacks to sit_offload\"),\nlater reverted by Herbert Xu.\n\nThe problem came because Tom patch was building GRO\npackets without proper meta data : If packets were locally\ndelivered, we would not care.\n\nBut if packets needed to be forwarded, GSO engine was not\nable to segment individual segments.\n\nWith the following patch, we correctly set skb->encapsulation\nand inner network header. We also update gso_type.\n\nTested:\n\nServer :\nnetserver\nmodprobe dummy\nifconfig dummy0 8.0.0.1 netmask 255.255.255.0 up\narp -s 8.0.0.100 4e:32:51:04:47:e5\niptables -I INPUT -s 10.246.7.151 -j TEE --gateway 8.0.0.100\nifconfig sixtofour0\nsixtofour0 Link encap:IPv6-in-IPv4\n          inet6 addr: 2002:af6:798::1/128 Scope:Global\n          inet6 addr: 2002:af6:798::/128 Scope:Global\n          UP RUNNING NOARP  MTU:1480  Metric:1\n          RX packets:411169 errors:0 dropped:0 overruns:0 frame:0\n          TX packets:409414 errors:0 dropped:0 overruns:0 carrier:0\n          collisions:0 txqueuelen:0\n          RX bytes:20319631739 (20.3 GB)  TX bytes:29529556 (29.5 MB)\n\nClient :\nnetperf -H 2002:af6:798::1 -l 1000 &\n\nChecked on server traffic copied on dummy0 and verify segments were\nproperly rebuilt, with proper IP headers, TCP checksums...\n\ntcpdump on eth0 shows proper GRO aggregation takes place.\n\nSigned-off-by: Eric Dumazet <edumazet@google.com>\nAcked-by: Tom Herbert <tom@herbertland.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "net/ipv6/ip6_offload.c||net/ipv6/ip6_offload.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "net/ipv6/ip6_offload.c||net/ipv6/ip6_offload.c"
          ],
          "candidate": [
            "net/ipv6/ip6_offload.c||net/ipv6/ip6_offload.c"
          ]
        }
      },
      "candidate_diff": {
        "net/ipv6/ip6_offload.c||net/ipv6/ip6_offload.c": [
          "File: net/ipv6/ip6_offload.c -> net/ipv6/ip6_offload.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "264:  struct ipv6hdr *iph = (struct ipv6hdr *)(skb->data + nhoff);",
          "265:  int err = -ENOSYS;",
          "267:  iph->payload_len = htons(skb->len - nhoff - sizeof(*iph));",
          "269:  rcu_read_lock();",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "267:  if (skb->encapsulation)",
          "268:   skb_set_inner_network_header(skb, nhoff);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "280:  return err;",
          "281: }",
          "283: static struct packet_offload ipv6_packet_offload __read_mostly = {",
          "284:  .type = cpu_to_be16(ETH_P_IPV6),",
          "285:  .callbacks = {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "286: static int sit_gro_complete(struct sk_buff *skb, int nhoff)",
          "287: {",
          "288:  skb->encapsulation = 1;",
          "289:  skb_shinfo(skb)->gso_type |= SKB_GSO_SIT;",
          "290:  return ipv6_gro_complete(skb, nhoff);",
          "291: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "292: static const struct net_offload sit_offload = {",
          "293:  .callbacks = {",
          "294:   .gso_segment = ipv6_gso_segment,",
          "295:  },",
          "296: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "305:   .gro_receive    = ipv6_gro_receive,",
          "306:   .gro_complete   = sit_gro_complete,",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2020-10751",
  "cve_desc": "A flaw was found in the Linux kernels SELinux LSM hook implementation before version 5.7, where it incorrectly assumed that an skb would only contain a single netlink message. The hook would incorrectly only validate the first netlink message in the skb and allow or deny the rest of the messages within the skb with the granted permission without further processing.",
  "repo": "torvalds/linux",
  "patch_hash": "fb73974172ffaaf57a7c42f35424d9aece1a5af6",
  "patch_info": {
    "commit_hash": "fb73974172ffaaf57a7c42f35424d9aece1a5af6",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/fb73974172ffaaf57a7c42f35424d9aece1a5af6",
    "files": [
      "security/selinux/hooks.c"
    ],
    "message": "selinux: properly handle multiple messages in selinux_netlink_send()\n\nFix the SELinux netlink_send hook to properly handle multiple netlink\nmessages in a single sk_buff; each message is parsed and subject to\nSELinux access control.  Prior to this patch, SELinux only inspected\nthe first message in the sk_buff.\n\nCc: stable@vger.kernel.org\nReported-by: Dmitry Vyukov <dvyukov@google.com>\nReviewed-by: Stephen Smalley <stephen.smalley.work@gmail.com>\nSigned-off-by: Paul Moore <paul@paul-moore.com>",
    "before_after_code_files": [
      "security/selinux/hooks.c||security/selinux/hooks.c"
    ]
  },
  "patch_diff": {
    "security/selinux/hooks.c||security/selinux/hooks.c": [
      "File: security/selinux/hooks.c -> security/selinux/hooks.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "5843: static int selinux_netlink_send(struct sock *sk, struct sk_buff *skb)",
      "5844: {",
      "5847:  struct nlmsghdr *nlh;",
      "5848:  struct sk_security_struct *sksec = sk->sk_security;",
      "5859:    pr_warn_ratelimited(\"SELinux: unrecognized netlink\"",
      "5868:   }",
      "5874:  }",
      "5879: }",
      "5881: static void ipc_init_security(struct ipc_security_struct *isec, u16 sclass)",
      "",
      "[Removed Lines]",
      "5845:  int err = 0;",
      "5846:  u32 perm;",
      "5850:  if (skb->len < NLMSG_HDRLEN) {",
      "5851:   err = -EINVAL;",
      "5852:   goto out;",
      "5853:  }",
      "5854:  nlh = nlmsg_hdr(skb);",
      "5856:  err = selinux_nlmsg_lookup(sksec->sclass, nlh->nlmsg_type, &perm);",
      "5857:  if (err) {",
      "5858:   if (err == -EINVAL) {",
      "5860:           \" message: protocol=%hu nlmsg_type=%hu sclass=%s\"",
      "5861:           \" pid=%d comm=%s\\n\",",
      "5862:           sk->sk_protocol, nlh->nlmsg_type,",
      "5863:           secclass_map[sksec->sclass - 1].name,",
      "5864:           task_pid_nr(current), current->comm);",
      "5865:    if (!enforcing_enabled(&selinux_state) ||",
      "5866:        security_get_allow_unknown(&selinux_state))",
      "5867:     err = 0;",
      "5871:   if (err == -ENOENT)",
      "5872:    err = 0;",
      "5873:   goto out;",
      "5876:  err = sock_has_perm(sk, perm);",
      "5877: out:",
      "5878:  return err;",
      "",
      "[Added Lines]",
      "5845:  int rc = 0;",
      "5846:  unsigned int msg_len;",
      "5847:  unsigned int data_len = skb->len;",
      "5848:  unsigned char *data = skb->data;",
      "5851:  u16 sclass = sksec->sclass;",
      "5852:  u32 perm;",
      "5854:  while (data_len >= nlmsg_total_size(0)) {",
      "5855:   nlh = (struct nlmsghdr *)data;",
      "5863:   if (nlh->nlmsg_len < NLMSG_HDRLEN || nlh->nlmsg_len > data_len)",
      "5864:    return 0;",
      "5866:   rc = selinux_nlmsg_lookup(sclass, nlh->nlmsg_type, &perm);",
      "5867:   if (rc == 0) {",
      "5868:    rc = sock_has_perm(sk, perm);",
      "5869:    if (rc)",
      "5870:     return rc;",
      "5871:   } else if (rc == -EINVAL) {",
      "5874:     \" message: protocol=%hu nlmsg_type=%hu sclass=%s\"",
      "5875:     \" pid=%d comm=%s\\n\",",
      "5876:     sk->sk_protocol, nlh->nlmsg_type,",
      "5877:     secclass_map[sclass - 1].name,",
      "5878:     task_pid_nr(current), current->comm);",
      "5879:    if (enforcing_enabled(&selinux_state) &&",
      "5880:        !security_get_allow_unknown(&selinux_state))",
      "5881:     return rc;",
      "5882:    rc = 0;",
      "5883:   } else if (rc == -ENOENT) {",
      "5885:    rc = 0;",
      "5886:   } else {",
      "5887:    return rc;",
      "5891:   msg_len = NLMSG_ALIGN(nlh->nlmsg_len);",
      "5892:   if (msg_len >= data_len)",
      "5893:    return 0;",
      "5894:   data_len -= msg_len;",
      "5895:   data += msg_len;",
      "5898:  return rc;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "df4779b5d2732eb7550fe35249e82db1b3d4fb95",
      "candidate_info": {
        "commit_hash": "df4779b5d2732eb7550fe35249e82db1b3d4fb95",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/df4779b5d2732eb7550fe35249e82db1b3d4fb95",
        "files": [
          "security/selinux/hooks.c"
        ],
        "message": "selinux: remove redundant selinux_nlmsg_perm\n\nselinux_nlmsg_perm is used for only by selinux_netlink_send. Remove\nthe redundant function to simplify the code.\n\nFix a typo by suggestion from Stephen.\n\nSigned-off-by: Huaisheng Ye <yehs1@lenovo.com>\nAcked-by: Stephen Smalley <sds@tycho.nsa.gov>\nSigned-off-by: Paul Moore <paul@paul-moore.com>",
        "before_after_code_files": [
          "security/selinux/hooks.c||security/selinux/hooks.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "security/selinux/hooks.c||security/selinux/hooks.c"
          ],
          "candidate": [
            "security/selinux/hooks.c||security/selinux/hooks.c"
          ]
        }
      },
      "candidate_diff": {
        "security/selinux/hooks.c||security/selinux/hooks.c": [
          "File: security/selinux/hooks.c -> security/selinux/hooks.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "5520:  return 0;",
          "5521: }",
          "5561: #ifdef CONFIG_NETFILTER",
          "5563: static unsigned int selinux_ip_forward(struct sk_buff *skb,",
          "",
          "[Removed Lines]",
          "5523: static int selinux_nlmsg_perm(struct sock *sk, struct sk_buff *skb)",
          "5524: {",
          "5525:  int err = 0;",
          "5526:  u32 perm;",
          "5527:  struct nlmsghdr *nlh;",
          "5528:  struct sk_security_struct *sksec = sk->sk_security;",
          "5530:  if (skb->len < NLMSG_HDRLEN) {",
          "5531:   err = -EINVAL;",
          "5532:   goto out;",
          "5533:  }",
          "5534:  nlh = nlmsg_hdr(skb);",
          "5536:  err = selinux_nlmsg_lookup(sksec->sclass, nlh->nlmsg_type, &perm);",
          "5537:  if (err) {",
          "5538:   if (err == -EINVAL) {",
          "5539:    pr_warn_ratelimited(\"SELinux: unrecognized netlink\"",
          "5540:           \" message: protocol=%hu nlmsg_type=%hu sclass=%s\"",
          "5541:           \" pig=%d comm=%s\\n\",",
          "5542:           sk->sk_protocol, nlh->nlmsg_type,",
          "5543:           secclass_map[sksec->sclass - 1].name,",
          "5544:           task_pid_nr(current), current->comm);",
          "5545:    if (!enforcing_enabled(&selinux_state) ||",
          "5546:        security_get_allow_unknown(&selinux_state))",
          "5547:     err = 0;",
          "5548:   }",
          "5551:   if (err == -ENOENT)",
          "5552:    err = 0;",
          "5553:   goto out;",
          "5554:  }",
          "5556:  err = sock_has_perm(sk, perm);",
          "5557: out:",
          "5558:  return err;",
          "5559: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "5887: static int selinux_netlink_send(struct sock *sk, struct sk_buff *skb)",
          "5888: {",
          "5890: }",
          "5892: static void ipc_init_security(struct ipc_security_struct *isec, u16 sclass)",
          "",
          "[Removed Lines]",
          "5889:  return selinux_nlmsg_perm(sk, skb);",
          "",
          "[Added Lines]",
          "5851:  int err = 0;",
          "5852:  u32 perm;",
          "5853:  struct nlmsghdr *nlh;",
          "5854:  struct sk_security_struct *sksec = sk->sk_security;",
          "5856:  if (skb->len < NLMSG_HDRLEN) {",
          "5857:   err = -EINVAL;",
          "5858:   goto out;",
          "5859:  }",
          "5860:  nlh = nlmsg_hdr(skb);",
          "5862:  err = selinux_nlmsg_lookup(sksec->sclass, nlh->nlmsg_type, &perm);",
          "5863:  if (err) {",
          "5864:   if (err == -EINVAL) {",
          "5865:    pr_warn_ratelimited(\"SELinux: unrecognized netlink\"",
          "5866:           \" message: protocol=%hu nlmsg_type=%hu sclass=%s\"",
          "5867:           \" pid=%d comm=%s\\n\",",
          "5868:           sk->sk_protocol, nlh->nlmsg_type,",
          "5869:           secclass_map[sksec->sclass - 1].name,",
          "5870:           task_pid_nr(current), current->comm);",
          "5871:    if (!enforcing_enabled(&selinux_state) ||",
          "5872:        security_get_allow_unknown(&selinux_state))",
          "5873:     err = 0;",
          "5874:   }",
          "5877:   if (err == -ENOENT)",
          "5878:    err = 0;",
          "5879:   goto out;",
          "5880:  }",
          "5882:  err = sock_has_perm(sk, perm);",
          "5883: out:",
          "5884:  return err;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
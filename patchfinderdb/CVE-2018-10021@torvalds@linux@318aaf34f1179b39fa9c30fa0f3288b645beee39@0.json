{
  "cve_id": "CVE-2018-10021",
  "cve_desc": "drivers/scsi/libsas/sas_scsi_host.c in the Linux kernel before 4.16 allows local users to cause a denial of service (ata qc leak) by triggering certain failure conditions. NOTE: a third party disputes the relevance of this report because the failure can only occur for physically proximate attackers who unplug SAS Host Bus Adapter cables",
  "repo": "torvalds/linux",
  "patch_hash": "318aaf34f1179b39fa9c30fa0f3288b645beee39",
  "patch_info": {
    "commit_hash": "318aaf34f1179b39fa9c30fa0f3288b645beee39",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/318aaf34f1179b39fa9c30fa0f3288b645beee39",
    "files": [
      "drivers/scsi/libsas/sas_scsi_host.c"
    ],
    "message": "scsi: libsas: defer ata device eh commands to libata\n\nWhen ata device doing EH, some commands still attached with tasks are\nnot passed to libata when abort failed or recover failed, so libata did\nnot handle these commands. After these commands done, sas task is freed,\nbut ata qc is not freed. This will cause ata qc leak and trigger a\nwarning like below:\n\nWARNING: CPU: 0 PID: 28512 at drivers/ata/libata-eh.c:4037\nata_eh_finish+0xb4/0xcc\nCPU: 0 PID: 28512 Comm: kworker/u32:2 Tainted: G     W  OE 4.14.0#1\n......\nCall trace:\n[<ffff0000088b7bd0>] ata_eh_finish+0xb4/0xcc\n[<ffff0000088b8420>] ata_do_eh+0xc4/0xd8\n[<ffff0000088b8478>] ata_std_error_handler+0x44/0x8c\n[<ffff0000088b8068>] ata_scsi_port_error_handler+0x480/0x694\n[<ffff000008875fc4>] async_sas_ata_eh+0x4c/0x80\n[<ffff0000080f6be8>] async_run_entry_fn+0x4c/0x170\n[<ffff0000080ebd70>] process_one_work+0x144/0x390\n[<ffff0000080ec100>] worker_thread+0x144/0x418\n[<ffff0000080f2c98>] kthread+0x10c/0x138\n[<ffff0000080855dc>] ret_from_fork+0x10/0x18\n\nIf ata qc leaked too many, ata tag allocation will fail and io blocked\nfor ever.\n\nAs suggested by Dan Williams, defer ata device commands to libata and\nmerge sas_eh_finish_cmd() with sas_eh_defer_cmd(). libata will handle\nata qcs correctly after this.\n\nSigned-off-by: Jason Yan <yanaijie@huawei.com>\nCC: Xiaofei Tan <tanxiaofei@huawei.com>\nCC: John Garry <john.garry@huawei.com>\nCC: Dan Williams <dan.j.williams@intel.com>\nReviewed-by: Dan Williams <dan.j.williams@intel.com>\nSigned-off-by: Martin K. Petersen <martin.petersen@oracle.com>",
    "before_after_code_files": [
      "drivers/scsi/libsas/sas_scsi_host.c||drivers/scsi/libsas/sas_scsi_host.c"
    ]
  },
  "patch_diff": {
    "drivers/scsi/libsas/sas_scsi_host.c||drivers/scsi/libsas/sas_scsi_host.c": [
      "File: drivers/scsi/libsas/sas_scsi_host.c -> drivers/scsi/libsas/sas_scsi_host.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "223: static void sas_eh_finish_cmd(struct scsi_cmnd *cmd)",
      "224: {",
      "225:  struct sas_ha_struct *sas_ha = SHOST_TO_SAS_HA(cmd->device->host);",
      "226:  struct sas_task *task = TO_SAS_TASK(cmd);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "226:  struct domain_device *dev = cmd_to_domain_dev(cmd);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "232:  sas_end_task(cmd, task);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "235:  if (dev_is_sata(dev)) {",
      "239:   list_move_tail(&cmd->eh_entry, &sas_ha->eh_ata_q);",
      "240:   return;",
      "241:  }",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "238:  scsi_eh_finish_cmd(cmd, &sas_ha->eh_done_q);",
      "239: }",
      "257: static void sas_scsi_clear_queue_lu(struct list_head *error_q, struct scsi_cmnd *my_cmd)",
      "258: {",
      "259:  struct scsi_cmnd *cmd, *n;",
      "",
      "[Removed Lines]",
      "241: static void sas_eh_defer_cmd(struct scsi_cmnd *cmd)",
      "242: {",
      "243:  struct domain_device *dev = cmd_to_domain_dev(cmd);",
      "244:  struct sas_ha_struct *ha = dev->port->ha;",
      "245:  struct sas_task *task = TO_SAS_TASK(cmd);",
      "247:  if (!dev_is_sata(dev)) {",
      "248:   sas_eh_finish_cmd(cmd);",
      "249:   return;",
      "250:  }",
      "253:  sas_end_task(cmd, task);",
      "254:  list_move_tail(&cmd->eh_entry, &ha->eh_ata_q);",
      "255: }",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "261:  list_for_each_entry_safe(cmd, n, error_q, eh_entry) {",
      "262:   if (cmd->device->sdev_target == my_cmd->device->sdev_target &&",
      "263:       cmd->device->lun == my_cmd->device->lun)",
      "265:  }",
      "266: }",
      "",
      "[Removed Lines]",
      "264:    sas_eh_defer_cmd(cmd);",
      "",
      "[Added Lines]",
      "257:    sas_eh_finish_cmd(cmd);",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "618:   case TASK_IS_DONE:",
      "619:    SAS_DPRINTK(\"%s: task 0x%p is done\\n\", __func__,",
      "620:         task);",
      "622:    continue;",
      "623:   case TASK_IS_ABORTED:",
      "624:    SAS_DPRINTK(\"%s: task 0x%p is aborted\\n\",",
      "625:         __func__, task);",
      "627:    continue;",
      "628:   case TASK_IS_AT_LU:",
      "629:    SAS_DPRINTK(\"task 0x%p is at LU: lu recover\\n\", task);",
      "",
      "[Removed Lines]",
      "621:    sas_eh_defer_cmd(cmd);",
      "626:    sas_eh_defer_cmd(cmd);",
      "",
      "[Added Lines]",
      "614:    sas_eh_finish_cmd(cmd);",
      "619:    sas_eh_finish_cmd(cmd);",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "634:          \"recovered\\n\",",
      "635:          SAS_ADDR(task->dev),",
      "636:          cmd->device->lun);",
      "638:     sas_scsi_clear_queue_lu(work_q, cmd);",
      "639:     goto Again;",
      "640:    }",
      "",
      "[Removed Lines]",
      "637:     sas_eh_defer_cmd(cmd);",
      "",
      "[Added Lines]",
      "630:     sas_eh_finish_cmd(cmd);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "2975d5de6428ff6d9317e9948f0968f7d42e5d74",
      "candidate_info": {
        "commit_hash": "2975d5de6428ff6d9317e9948f0968f7d42e5d74",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/2975d5de6428ff6d9317e9948f0968f7d42e5d74",
        "files": [
          "drivers/infiniband/core/ucma.c"
        ],
        "message": "RDMA/ucma: Check AF family prior resolving address\n\nGarbage supplied by user will cause to UCMA module provide zero\nmemory size for memcpy(), because it wasn't checked, it will\nproduce unpredictable results in rdma_resolve_addr().\n\n[   42.873814] BUG: KASAN: null-ptr-deref in rdma_resolve_addr+0xc8/0xfb0\n[   42.874816] Write of size 28 at addr 00000000000000a0 by task resaddr/1044\n[   42.876765]\n[   42.876960] CPU: 1 PID: 1044 Comm: resaddr Not tainted 4.16.0-rc1-00057-gaa56a5293d7e #34\n[   42.877840] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.11.0-0-g63451fca13-prebuilt.qemu-project.org 04/01/2014\n[   42.879691] Call Trace:\n[   42.880236]  dump_stack+0x5c/0x77\n[   42.880664]  kasan_report+0x163/0x380\n[   42.881354]  ? rdma_resolve_addr+0xc8/0xfb0\n[   42.881864]  memcpy+0x34/0x50\n[   42.882692]  rdma_resolve_addr+0xc8/0xfb0\n[   42.883366]  ? deref_stack_reg+0x88/0xd0\n[   42.883856]  ? vsnprintf+0x31a/0x770\n[   42.884686]  ? rdma_bind_addr+0xc40/0xc40\n[   42.885327]  ? num_to_str+0x130/0x130\n[   42.885773]  ? deref_stack_reg+0x88/0xd0\n[   42.886217]  ? __read_once_size_nocheck.constprop.6+0x10/0x10\n[   42.887698]  ? unwind_get_return_address_ptr+0x50/0x50\n[   42.888302]  ? replace_slot+0x147/0x170\n[   42.889176]  ? delete_node+0x12c/0x340\n[   42.890223]  ? __radix_tree_lookup+0xa9/0x160\n[   42.891196]  ? ucma_resolve_ip+0xb7/0x110\n[   42.891917]  ucma_resolve_ip+0xb7/0x110\n[   42.893003]  ? ucma_resolve_addr+0x190/0x190\n[   42.893531]  ? _copy_from_user+0x5e/0x90\n[   42.894204]  ucma_write+0x174/0x1f0\n[   42.895162]  ? ucma_resolve_route+0xf0/0xf0\n[   42.896309]  ? dequeue_task_fair+0x67e/0xd90\n[   42.897192]  ? put_prev_entity+0x7d/0x170\n[   42.897870]  ? ring_buffer_record_is_on+0xd/0x20\n[   42.898439]  ? tracing_record_taskinfo_skip+0x20/0x50\n[   42.899686]  __vfs_write+0xc4/0x350\n[   42.900142]  ? kernel_read+0xa0/0xa0\n[   42.900602]  ? firmware_map_remove+0xdf/0xdf\n[   42.901135]  ? do_task_dead+0x5d/0x60\n[   42.901598]  ? do_exit+0xcc6/0x1220\n[   42.902789]  ? __fget+0xa8/0xf0\n[   42.903190]  vfs_write+0xf7/0x280\n[   42.903600]  SyS_write+0xa1/0x120\n[   42.904206]  ? SyS_read+0x120/0x120\n[   42.905710]  ? compat_start_thread+0x60/0x60\n[   42.906423]  ? SyS_read+0x120/0x120\n[   42.908716]  do_syscall_64+0xeb/0x250\n[   42.910760]  entry_SYSCALL_64_after_hwframe+0x21/0x86\n[   42.912735] RIP: 0033:0x7f138b0afe99\n[   42.914734] RSP: 002b:00007f138b799e98 EFLAGS: 00000287 ORIG_RAX: 0000000000000001\n[   42.917134] RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007f138b0afe99\n[   42.919487] RDX: 000000000000002e RSI: 0000000020000c40 RDI: 0000000000000004\n[   42.922393] RBP: 00007f138b799ec0 R08: 00007f138b79a700 R09: 0000000000000000\n[   42.925266] R10: 00007f138b79a700 R11: 0000000000000287 R12: 00007f138b799fc0\n[   42.927570] R13: 0000000000000000 R14: 00007ffdbae757c0 R15: 00007f138b79a9c0\n[   42.930047]\n[   42.932681] Disabling lock debugging due to kernel taint\n[   42.934795] BUG: unable to handle kernel NULL pointer dereference at 00000000000000a0\n[   42.936939] IP: memcpy_erms+0x6/0x10\n[   42.938864] PGD 80000001bea92067 P4D 80000001bea92067 PUD 1bea96067 PMD 0\n[   42.941576] Oops: 0002 [#1] SMP KASAN PTI\n[   42.943952] CPU: 1 PID: 1044 Comm: resaddr Tainted: G    B 4.16.0-rc1-00057-gaa56a5293d7e #34\n[   42.946964] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.11.0-0-g63451fca13-prebuilt.qemu-project.org 04/01/2014\n[   42.952336] RIP: 0010:memcpy_erms+0x6/0x10\n[   42.954707] RSP: 0018:ffff8801c8b479c8 EFLAGS: 00010286\n[   42.957227] RAX: 00000000000000a0 RBX: ffff8801c8b47ba0 RCX: 000000000000001c\n[   42.960543] RDX: 000000000000001c RSI: ffff8801c8b47bbc RDI: 00000000000000a0\n[   42.963867] RBP: ffff8801c8b47b60 R08: 0000000000000000 R09: ffffed0039168ed1\n[   42.967303] R10: 0000000000000001 R11: ffffed0039168ed0 R12: ffff8801c8b47bbc\n[   42.970685] R13: 00000000000000a0 R14: 1ffff10039168f4a R15: 0000000000000000\n[   42.973631] FS:  00007f138b79a700(0000) GS:ffff8801e5d00000(0000) knlGS:0000000000000000\n[   42.976831] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[   42.979239] CR2: 00000000000000a0 CR3: 00000001be908002 CR4: 00000000003606a0\n[   42.982060] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n[   42.984877] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n[   42.988033] Call Trace:\n[   42.990487]  rdma_resolve_addr+0xc8/0xfb0\n[   42.993202]  ? deref_stack_reg+0x88/0xd0\n[   42.996055]  ? vsnprintf+0x31a/0x770\n[   42.998707]  ? rdma_bind_addr+0xc40/0xc40\n[   43.000985]  ? num_to_str+0x130/0x130\n[   43.003410]  ? deref_stack_reg+0x88/0xd0\n[   43.006302]  ? __read_once_size_nocheck.constprop.6+0x10/0x10\n[   43.008780]  ? unwind_get_return_address_ptr+0x50/0x50\n[   43.011178]  ? replace_slot+0x147/0x170\n[   43.013517]  ? delete_node+0x12c/0x340\n[   43.016019]  ? __radix_tree_lookup+0xa9/0x160\n[   43.018755]  ? ucma_resolve_ip+0xb7/0x110\n[   43.021270]  ucma_resolve_ip+0xb7/0x110\n[   43.023968]  ? ucma_resolve_addr+0x190/0x190\n[   43.026312]  ? _copy_from_user+0x5e/0x90\n[   43.029384]  ucma_write+0x174/0x1f0\n[   43.031861]  ? ucma_resolve_route+0xf0/0xf0\n[   43.034782]  ? dequeue_task_fair+0x67e/0xd90\n[   43.037483]  ? put_prev_entity+0x7d/0x170\n[   43.040215]  ? ring_buffer_record_is_on+0xd/0x20\n[   43.042990]  ? tracing_record_taskinfo_skip+0x20/0x50\n[   43.045595]  __vfs_write+0xc4/0x350\n[   43.048624]  ? kernel_read+0xa0/0xa0\n[   43.051604]  ? firmware_map_remove+0xdf/0xdf\n[   43.055379]  ? do_task_dead+0x5d/0x60\n[   43.058000]  ? do_exit+0xcc6/0x1220\n[   43.060783]  ? __fget+0xa8/0xf0\n[   43.063133]  vfs_write+0xf7/0x280\n[   43.065677]  SyS_write+0xa1/0x120\n[   43.068647]  ? SyS_read+0x120/0x120\n[   43.071179]  ? compat_start_thread+0x60/0x60\n[   43.074025]  ? SyS_read+0x120/0x120\n[   43.076705]  do_syscall_64+0xeb/0x250\n[   43.079006]  entry_SYSCALL_64_after_hwframe+0x21/0x86\n[   43.081606] RIP: 0033:0x7f138b0afe99\n[   43.083679] RSP: 002b:00007f138b799e98 EFLAGS: 00000287 ORIG_RAX: 0000000000000001\n[   43.086802] RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007f138b0afe99\n[   43.089989] RDX: 000000000000002e RSI: 0000000020000c40 RDI: 0000000000000004\n[   43.092866] RBP: 00007f138b799ec0 R08: 00007f138b79a700 R09: 0000000000000000\n[   43.096233] R10: 00007f138b79a700 R11: 0000000000000287 R12: 00007f138b799fc0\n[   43.098913] R13: 0000000000000000 R14: 00007ffdbae757c0 R15: 00007f138b79a9c0\n[   43.101809] Code: 90 90 90 90 90 eb 1e 0f 1f 00 48 89 f8 48 89 d1 48\nc1 e9 03 83 e2 07 f3 48 a5 89 d1 f3 a4 c3 66 0f 1f 44 00 00 48 89 f8 48\n89 d1 <f3> a4 c3 0f 1f 80 00 00 00 00 48 89 f8 48 83 fa 20 72 7e 40 38\n[   43.107950] RIP: memcpy_erms+0x6/0x10 RSP: ffff8801c8b479c8\n\nReported-by: <syzbot+1d8c43206853b369d00c@syzkaller.appspotmail.com>\nFixes: 75216638572f (\"RDMA/cma: Export rdma cm interface to userspace\")\nSigned-off-by: Leon Romanovsky <leonro@mellanox.com>\nReviewed-by: Sean Hefty <sean.hefty@intel.com>\nSigned-off-by: Jason Gunthorpe <jgg@mellanox.com>",
        "before_after_code_files": [
          "drivers/infiniband/core/ucma.c||drivers/infiniband/core/ucma.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/infiniband/core/ucma.c||drivers/infiniband/core/ucma.c": [
          "File: drivers/infiniband/core/ucma.c -> drivers/infiniband/core/ucma.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "664:           int in_len, int out_len)",
          "665: {",
          "666:  struct rdma_ucm_resolve_ip cmd;",
          "667:  struct ucma_context *ctx;",
          "668:  int ret;",
          "670:  if (copy_from_user(&cmd, inbuf, sizeof(cmd)))",
          "671:   return -EFAULT;",
          "673:  ctx = ucma_get_ctx(file, cmd.id);",
          "674:  if (IS_ERR(ctx))",
          "675:   return PTR_ERR(ctx);",
          "680:  ucma_put_ctx(ctx);",
          "681:  return ret;",
          "682: }",
          "",
          "[Removed Lines]",
          "677:  ret = rdma_resolve_addr(ctx->cm_id, (struct sockaddr *) &cmd.src_addr,",
          "678:     (struct sockaddr *) &cmd.dst_addr,",
          "679:     cmd.timeout_ms);",
          "",
          "[Added Lines]",
          "667:  struct sockaddr *src, *dst;",
          "674:  src = (struct sockaddr *) &cmd.src_addr;",
          "675:  dst = (struct sockaddr *) &cmd.dst_addr;",
          "676:  if (!rdma_addr_size(src) || !rdma_addr_size(dst))",
          "677:   return -EINVAL;",
          "683:  ret = rdma_resolve_addr(ctx->cm_id, src, dst, cmd.timeout_ms);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "f3f134f5260ae9ee1f5a4d0a8cc625c6c77655b4",
      "candidate_info": {
        "commit_hash": "f3f134f5260ae9ee1f5a4d0a8cc625c6c77655b4",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/f3f134f5260ae9ee1f5a4d0a8cc625c6c77655b4",
        "files": [
          "drivers/infiniband/hw/mlx5/mr.c"
        ],
        "message": "RDMA/mlx5: Fix crash while accessing garbage pointer and freed memory\n\nThe failure in rereg_mr flow caused to set garbage value (error value)\ninto mr->umem pointer. This pointer is accessed at the release stage\nand it causes to the following crash.\n\nThere is not enough to simply change umem to point to NULL, because the\nMR struct is needed to be accessed during MR deregistration phase, so\ndelay kfree too.\n\n[    6.237617] BUG: unable to handle kernel NULL pointer dereference a 0000000000000228\n[    6.238756] IP: ib_dereg_mr+0xd/0x30\n[    6.239264] PGD 80000000167eb067 P4D 80000000167eb067 PUD 167f9067 PMD 0\n[    6.240320] Oops: 0000 [#1] SMP PTI\n[    6.240782] CPU: 0 PID: 367 Comm: dereg Not tainted 4.16.0-rc1-00029-gc198fafe0453 #183\n[    6.242120] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.7.5-0-ge51488c-20140602_164612-nilsson.home.kraxel.org 04/01/2014\n[    6.244504] RIP: 0010:ib_dereg_mr+0xd/0x30\n[    6.245253] RSP: 0018:ffffaf5d001d7d68 EFLAGS: 00010246\n[    6.246100] RAX: 0000000000000000 RBX: ffff95d4172daf00 RCX: 0000000000000000\n[    6.247414] RDX: 00000000ffffffff RSI: 0000000000000001 RDI: ffff95d41a317600\n[    6.248591] RBP: 0000000000000001 R08: 0000000000000000 R09: 0000000000000000\n[    6.249810] R10: ffff95d417033c10 R11: 0000000000000000 R12: ffff95d4172c3a80\n[    6.251121] R13: ffff95d4172c3720 R14: ffff95d4172c3a98 R15: 00000000ffffffff\n[    6.252437] FS:  0000000000000000(0000) GS:ffff95d41fc00000(0000) knlGS:0000000000000000\n[    6.253887] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[    6.254814] CR2: 0000000000000228 CR3: 00000000172b4000 CR4: 00000000000006b0\n[    6.255943] Call Trace:\n[    6.256368]  remove_commit_idr_uobject+0x1b/0x80\n[    6.257118]  uverbs_cleanup_ucontext+0xe4/0x190\n[    6.257855]  ib_uverbs_cleanup_ucontext.constprop.14+0x19/0x40\n[    6.258857]  ib_uverbs_close+0x2a/0x100\n[    6.259494]  __fput+0xca/0x1c0\n[    6.259938]  task_work_run+0x84/0xa0\n[    6.260519]  do_exit+0x312/0xb40\n[    6.261023]  ? __do_page_fault+0x24d/0x490\n[    6.261707]  do_group_exit+0x3a/0xa0\n[    6.262267]  SyS_exit_group+0x10/0x10\n[    6.262802]  do_syscall_64+0x75/0x180\n[    6.263391]  entry_SYSCALL_64_after_hwframe+0x21/0x86\n[    6.264253] RIP: 0033:0x7f1b39c49488\n[    6.264827] RSP: 002b:00007ffe2de05b68 EFLAGS: 00000246 ORIG_RAX: 00000000000000e7\n[    6.266049] RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007f1b39c49488\n[    6.267187] RDX: 0000000000000000 RSI: 000000000000003c RDI: 0000000000000000\n[    6.268377] RBP: 00007f1b39f258e0 R08: 00000000000000e7 R09: ffffffffffffff98\n[    6.269640] R10: 00007f1b3a147260 R11: 0000000000000246 R12: 00007f1b39f258e0\n[    6.270783] R13: 00007f1b39f2ac20 R14: 0000000000000000 R15: 0000000000000000\n[    6.271943] Code: 74 07 31 d2 e9 25 d8 6c 00 b8 da ff ff ff c3 0f 1f\n44 00 00 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 44 00 00 48 8b 07 53 48 8b\n5f 08 <48> 8b 80 28 02 00 00 e8 f7 d7 6c 00 85 c0 75 04 3e ff 4b 18 5b\n[    6.274927] RIP: ib_dereg_mr+0xd/0x30 RSP: ffffaf5d001d7d68\n[    6.275760] CR2: 0000000000000228\n[    6.276200] ---[ end trace a35641f1c474bd20 ]---\n\nFixes: e126ba97dba9 (\"mlx5: Add driver for Mellanox Connect-IB adapters\")\nCc: syzkaller <syzkaller@googlegroups.com>\nCc: <stable@vger.kernel.org>\nReported-by: Noa Osherovich <noaos@mellanox.com>\nSigned-off-by: Leon Romanovsky <leonro@mellanox.com>\nSigned-off-by: Doug Ledford <dledford@redhat.com>",
        "before_after_code_files": [
          "drivers/infiniband/hw/mlx5/mr.c||drivers/infiniband/hw/mlx5/mr.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/infiniband/hw/mlx5/mr.c||drivers/infiniband/hw/mlx5/mr.c": [
          "File: drivers/infiniband/hw/mlx5/mr.c -> drivers/infiniband/hw/mlx5/mr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "839:        access_flags, 0);",
          "840:  err = PTR_ERR_OR_ZERO(*umem);",
          "842:   mlx5_ib_err(dev, \"umem get failed (%d)\\n\", err);",
          "843:   return err;",
          "844:  }",
          "",
          "[Removed Lines]",
          "841:  if (err < 0) {",
          "",
          "[Added Lines]",
          "841:  if (err) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1415:   if (err) {",
          "1416:    mlx5_ib_warn(dev, \"Failed to rereg UMR\\n\");",
          "1417:    ib_umem_release(mr->umem);",
          "1418:    clean_mr(dev, mr);",
          "1419:    return err;",
          "1420:   }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1419:    mr->umem = NULL;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1498:   u32 key = mr->mmkey.key;",
          "1500:   err = destroy_mkey(dev, mr);",
          "1502:   if (err) {",
          "1503:    mlx5_ib_warn(dev, \"failed to destroy mkey 0x%x (%d)\\n\",",
          "1504:          key, err);",
          "1505:    return err;",
          "1506:   }",
          "1509:  }",
          "1511:  return 0;",
          "",
          "[Removed Lines]",
          "1501:   kfree(mr);",
          "1507:  } else {",
          "1508:   mlx5_mr_cache_free(dev, mr);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1548:   atomic_sub(npages, &dev->mdev->priv.reg_pages);",
          "1549:  }",
          "1551:  return 0;",
          "1552: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1550:  if (!mr->allocated_from_cache)",
          "1551:   kfree(mr);",
          "1552:  else",
          "1553:   mlx5_mr_cache_free(dev, mr);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "e1368d0c9edbc366e45216e7295fd61ae55c2b12",
      "candidate_info": {
        "commit_hash": "e1368d0c9edbc366e45216e7295fd61ae55c2b12",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/e1368d0c9edbc366e45216e7295fd61ae55c2b12",
        "files": [
          "arch/powerpc/xmon/xmon.c"
        ],
        "message": "powerpc/xmon: Setup debugger hooks when first break-point is set\n\nPresently sysrq key for xmon('x') is registered during kernel init\nirrespective of the value of kernel param 'xmon'. Thus xmon is enabled\neven if 'xmon=off' is passed on the kernel command line. However this\ndoesn't enable the kernel debugger hooks needed for instruction or\ndata breakpoints. Thus when a break-point is hit with xmon=off a\nkernel oops of the form below is reported:\n\n  Oops: Exception in kernel mode, sig: 5 [#1]\n  < snip >\n  Trace/breakpoint trap\n\nTo fix this the patch checks and enables debugger hooks when an\ninstruction or data break-point is set via xmon console.\n\nSigned-off-by: Vaibhav Jain <vaibhav@linux.vnet.ibm.com>\nReviewed-by: Balbir Singh <bsingharora@gmail.com>\n[mpe: Just printf directly, no need for static const char[]]\nSigned-off-by: Michael Ellerman <mpe@ellerman.id.au>",
        "before_after_code_files": [
          "arch/powerpc/xmon/xmon.c||arch/powerpc/xmon/xmon.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "arch/powerpc/xmon/xmon.c||arch/powerpc/xmon/xmon.c": [
          "File: arch/powerpc/xmon/xmon.c -> arch/powerpc/xmon/xmon.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1273:  return 1;",
          "1274: }",
          "1276: static char *breakpoint_help_string =",
          "1277:     \"Breakpoint command usage:\\n\"",
          "1278:     \"b                show breakpoints\\n\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1277: static inline void force_enable_xmon(void)",
          "1278: {",
          "1280:  if (!xmon_on) {",
          "1281:   printf(\"xmon: Enabling debugger hooks\\n\");",
          "1282:   xmon_on = 1;",
          "1283:  }",
          "1284: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1315:    dabr.address &= ~HW_BRK_TYPE_DABR;",
          "1316:    dabr.enabled = mode | BP_DABR;",
          "1317:   }",
          "1318:   break;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1329:   force_enable_xmon();",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1335:   if (bp != NULL) {",
          "1336:    bp->enabled |= BP_CIABR;",
          "1337:    iabr = bp;",
          "1338:   }",
          "1339:   break;",
          "1340: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1350:    force_enable_xmon();",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1399:   if (!check_bp_loc(a))",
          "1400:    break;",
          "1401:   bp = new_breakpoint(a);",
          "1403:    bp->enabled |= BP_TRAP;",
          "1404:   break;",
          "1405:  }",
          "1406: }",
          "",
          "[Removed Lines]",
          "1402:   if (bp != NULL)",
          "",
          "[Added Lines]",
          "1415:   if (bp != NULL) {",
          "1417:    force_enable_xmon();",
          "1418:   }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "4058ebf33cb0be88ca516f968eda24ab7b6b93e4",
      "candidate_info": {
        "commit_hash": "4058ebf33cb0be88ca516f968eda24ab7b6b93e4",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/4058ebf33cb0be88ca516f968eda24ab7b6b93e4",
        "files": [
          "drivers/usb/gadget/function/f_fs.c"
        ],
        "message": "usb: gadget: ffs: Execute copy_to_user() with USER_DS set\n\nWhen using a AIO read() operation on the function FS gadget driver a URB is\nsubmitted asynchronously and on URB completion the received data is copied\nto the userspace buffer associated with the read operation.\n\nThis is done from a kernel worker thread invoking copy_to_user() (through\ncopy_to_iter()). And while the user space process memory is made available\nto the kernel thread using use_mm(), some architecture require in addition\nto this that the operation runs with USER_DS set. Otherwise the userspace\nmemory access will fail.\n\nFor example on ARM64 with Privileged Access Never (PAN) and User Access\nOverride (UAO) enabled the following crash occurs.\n\n\tInternal error: Accessing user space memory with fs=KERNEL_DS: 9600004f [#1] SMP\n\tModules linked in:\n\tCPU: 2 PID: 1636 Comm: kworker/2:1 Not tainted 4.9.0-04081-g8ab2dfb-dirty #487\n\tHardware name: ZynqMP ZCU102 Rev1.0 (DT)\n\tWorkqueue: events ffs_user_copy_worker\n\ttask: ffffffc87afc8080 task.stack: ffffffc87a00c000\n\tPC is at __arch_copy_to_user+0x190/0x220\n\tLR is at copy_to_iter+0x78/0x3c8\n\t[...]\n\t[<ffffff800847b790>] __arch_copy_to_user+0x190/0x220\n\t[<ffffff80086f25d8>] ffs_user_copy_worker+0x70/0x130\n\t[<ffffff80080b8c64>] process_one_work+0x1dc/0x460\n\t[<ffffff80080b8f38>] worker_thread+0x50/0x4b0\n\t[<ffffff80080bf5a0>] kthread+0xd8/0xf0\n\t[<ffffff8008083680>] ret_from_fork+0x10/0x50\n\nAddress this by placing a set_fs(USER_DS) before of the copy operation\nand revert it again once the copy operation has finished.\n\nThis patch is analogous to commit d7ffde35e31a (\"vhost: use USER_DS in\nvhost_worker thread\") which addresses the same underlying issue.\n\nSigned-off-by: Lars-Peter Clausen <lars@metafoo.de>\nSigned-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>",
        "before_after_code_files": [
          "drivers/usb/gadget/function/f_fs.c||drivers/usgadget/function/f_fs.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/usb/gadget/function/f_fs.c||drivers/usgadget/function/f_fs.c": [
          "File: drivers/usb/gadget/function/f_fs.c -> drivers/usgadget/function/f_fs.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "758:  bool kiocb_has_eventfd = io_data->kiocb->ki_flags & IOCB_EVENTFD;",
          "760:  if (io_data->read && ret > 0) {",
          "761:   use_mm(io_data->mm);",
          "762:   ret = ffs_copy_to_iter(io_data->buf, ret, &io_data->data);",
          "763:   unuse_mm(io_data->mm);",
          "764:  }",
          "766:  io_data->kiocb->ki_complete(io_data->kiocb, ret, ret);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "6b0ef92fee2a3189eba6d6b827b247cb4f6da7e9",
      "candidate_info": {
        "commit_hash": "6b0ef92fee2a3189eba6d6b827b247cb4f6da7e9",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/6b0ef92fee2a3189eba6d6b827b247cb4f6da7e9",
        "files": [
          "kernel/locking/rtmutex.c"
        ],
        "message": "rtmutex: Make rt_mutex_futex_unlock() safe for irq-off callsites\n\nWhen running rcutorture with TREE03 config, CONFIG_PROVE_LOCKING=y, and\nkernel cmdline argument \"rcutorture.gp_exp=1\", lockdep reports a\nHARDIRQ-safe->HARDIRQ-unsafe deadlock:\n\n ================================\n WARNING: inconsistent lock state\n 4.16.0-rc4+ #1 Not tainted\n --------------------------------\n inconsistent {IN-HARDIRQ-W} -> {HARDIRQ-ON-W} usage.\n takes:\n __schedule+0xbe/0xaf0\n {IN-HARDIRQ-W} state was registered at:\n   _raw_spin_lock+0x2a/0x40\n   scheduler_tick+0x47/0xf0\n...\n other info that might help us debug this:\n  Possible unsafe locking scenario:\n        CPU0\n        ----\n   lock(&rq->lock);\n   <Interrupt>\n     lock(&rq->lock);\n  *** DEADLOCK ***\n 1 lock held by rcu_torture_rea/724:\n rcu_torture_read_lock+0x0/0x70\n stack backtrace:\n CPU: 2 PID: 724 Comm: rcu_torture_rea Not tainted 4.16.0-rc4+ #1\n Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.11.0-20171110_100015-anatol 04/01/2014\n Call Trace:\n  lock_acquire+0x90/0x200\n  ? __schedule+0xbe/0xaf0\n  _raw_spin_lock+0x2a/0x40\n  ? __schedule+0xbe/0xaf0\n  __schedule+0xbe/0xaf0\n  preempt_schedule_irq+0x2f/0x60\n  retint_kernel+0x1b/0x2d\n RIP: 0010:rcu_read_unlock_special+0x0/0x680\n  ? rcu_torture_read_unlock+0x60/0x60\n  __rcu_read_unlock+0x64/0x70\n  rcu_torture_read_unlock+0x17/0x60\n  rcu_torture_reader+0x275/0x450\n  ? rcutorture_booster_init+0x110/0x110\n  ? rcu_torture_stall+0x230/0x230\n  ? kthread+0x10e/0x130\n  kthread+0x10e/0x130\n  ? kthread_create_worker_on_cpu+0x70/0x70\n  ? call_usermodehelper_exec_async+0x11a/0x150\n  ret_from_fork+0x3a/0x50\n\nThis happens with the following even sequence:\n\n\tpreempt_schedule_irq();\n\t  local_irq_enable();\n\t  __schedule():\n\t    local_irq_disable(); // irq off\n\t    ...\n\t    rcu_note_context_switch():\n\t      rcu_note_preempt_context_switch():\n\t        rcu_read_unlock_special():\n\t          local_irq_save(flags);\n\t          ...\n\t\t  raw_spin_unlock_irqrestore(...,flags); // irq remains off\n\t          rt_mutex_futex_unlock():\n\t            raw_spin_lock_irq();\n\t            ...\n\t            raw_spin_unlock_irq(); // accidentally set irq on\n\n\t    <return to __schedule()>\n\t    rq_lock():\n\t      raw_spin_lock(); // acquiring rq->lock with irq on\n\nwhich means rq->lock becomes a HARDIRQ-unsafe lock, which can cause\ndeadlocks in scheduler code.\n\nThis problem was introduced by commit 02a7c234e540 (\"rcu: Suppress\nlockdep false-positive ->boost_mtx complaints\"). That brought the user\nof rt_mutex_futex_unlock() with irq off.\n\nTo fix this, replace the *lock_irq() in rt_mutex_futex_unlock() with\n*lock_irq{save,restore}() to make it safe to call rt_mutex_futex_unlock()\nwith irq off.\n\nFixes: 02a7c234e540 (\"rcu: Suppress lockdep false-positive ->boost_mtx complaints\")\nSigned-off-by: Boqun Feng <boqun.feng@gmail.com>\nSigned-off-by: Thomas Gleixner <tglx@linutronix.de>\nCc: Peter Zijlstra <peterz@infradead.org>\nCc: Lai Jiangshan <jiangshanlai@gmail.com>\nCc: Steven Rostedt <rostedt@goodmis.org>\nCc: Josh Triplett <josh@joshtriplett.org>\nCc: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>\nCc: \"Paul E . McKenney\" <paulmck@linux.vnet.ibm.com>\nLink: https://lkml.kernel.org/r/20180309065630.8283-1-boqun.feng@gmail.com",
        "before_after_code_files": [
          "kernel/locking/rtmutex.c||kernel/locking/rtmutex.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "kernel/locking/rtmutex.c||kernel/locking/rtmutex.c": [
          "File: kernel/locking/rtmutex.c -> kernel/locking/rtmutex.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1616: void __sched rt_mutex_futex_unlock(struct rt_mutex *lock)",
          "1617: {",
          "1618:  DEFINE_WAKE_Q(wake_q);",
          "1619:  bool postunlock;",
          "1622:  postunlock = __rt_mutex_futex_unlock(lock, &wake_q);",
          "1625:  if (postunlock)",
          "1626:   rt_mutex_postunlock(&wake_q);",
          "",
          "[Removed Lines]",
          "1621:  raw_spin_lock_irq(&lock->wait_lock);",
          "1623:  raw_spin_unlock_irq(&lock->wait_lock);",
          "",
          "[Added Lines]",
          "1619:  unsigned long flags;",
          "1622:  raw_spin_lock_irqsave(&lock->wait_lock, flags);",
          "1624:  raw_spin_unlock_irqrestore(&lock->wait_lock, flags);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
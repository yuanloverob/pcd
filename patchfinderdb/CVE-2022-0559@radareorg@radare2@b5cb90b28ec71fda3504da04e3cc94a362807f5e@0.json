{
  "cve_id": "CVE-2022-0559",
  "cve_desc": "Use After Free in GitHub repository radareorg/radare2 prior to 5.6.2.",
  "repo": "radareorg/radare2",
  "patch_hash": "b5cb90b28ec71fda3504da04e3cc94a362807f5e",
  "patch_info": {
    "commit_hash": "b5cb90b28ec71fda3504da04e3cc94a362807f5e",
    "repo": "radareorg/radare2",
    "commit_url": "https://github.com/radareorg/radare2/commit/b5cb90b28ec71fda3504da04e3cc94a362807f5e",
    "files": [
      "libr/io/io_bank.c",
      "libr/util/new_rbtree.c"
    ],
    "message": "Prefer memleak over usaf in io.bank's rbtree bug ##crash\n\n* That's a workaround, proper fix will come later\n* Reproducer: bins/fuzzed/iobank-crash\n* Reported by Akyne Choi via huntr.dev",
    "before_after_code_files": [
      "libr/io/io_bank.c||libr/io/io_bank.c",
      "libr/util/new_rbtree.c||libr/util/new_rbtree.c"
    ]
  },
  "patch_diff": {
    "libr/io/io_bank.c||libr/io/io_bank.c": [
      "File: libr/io/io_bank.c -> libr/io/io_bank.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "226:   r_io_submap_set_to (bd, r_io_submap_from (sm) - 1);",
      "227:   entry = r_rbnode_next (entry);",
      "228:  }",
      "231:   RRBNode *next = r_rbnode_next (entry);",
      "233:   bool a = r_crbtree_delete (bank->submaps, entry->data, _find_sm_by_from_vaddr_cb, NULL);",
      "234:   if (!a) {",
      "235:    break;",
      "236:   }",
      "237:   entry = next;",
      "",
      "[Removed Lines]",
      "229:  while (entry && r_io_submap_to (((RIOSubMap *)entry->data)) <= r_io_submap_to (sm)) {",
      "",
      "[Added Lines]",
      "229:  ut64 smto = r_io_submap_to (sm);",
      "230:  while (entry && r_io_submap_to (((RIOSubMap *)entry->data)) <= smto) {",
      "235:   void *smfree = bank->submaps->free;",
      "236:   bank->submaps->free = NULL;",
      "238:   bank->submaps->free = smfree;",
      "240:    entry = NULL;",
      "",
      "---------------"
    ],
    "libr/util/new_rbtree.c||libr/util/new_rbtree.c": [
      "File: libr/util/new_rbtree.c -> libr/util/new_rbtree.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "138:  r_return_val_if_fail (tree && data && cmp, false);",
      "139:  bool inserted = false;",
      "142:   tree->root = _node_new (data, NULL);",
      "144:    return false;",
      "145:   }",
      "146:   inserted = true;",
      "",
      "[Removed Lines]",
      "141:  if (tree->root == NULL) {",
      "143:   if (tree->root == NULL) {",
      "",
      "[Added Lines]",
      "141:  if (!tree->root) {",
      "143:   if (!tree->root) {",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "cd8a4267c09cd1ce5d53cb681d41886db046dc9c",
      "candidate_info": {
        "commit_hash": "cd8a4267c09cd1ce5d53cb681d41886db046dc9c",
        "repo": "radareorg/radare2",
        "commit_url": "https://github.com/radareorg/radare2/commit/cd8a4267c09cd1ce5d53cb681d41886db046dc9c",
        "files": [
          "libr/include/r_util.h",
          "libr/include/r_util/r_new_rbtree.h",
          "libr/util/Makefile",
          "libr/util/new_rbtree.c"
        ],
        "message": "Port https://github.com/leiless/jw_rbtree to r_util (#19252) ##util",
        "before_after_code_files": [
          "libr/include/r_util.h||libr/include/r_util.h",
          "libr/include/r_util/r_new_rbtree.h||libr/include/r_util/r_new_rbtree.h",
          "libr/util/new_rbtree.c||libr/util/new_rbtree.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libr/util/new_rbtree.c||libr/util/new_rbtree.c"
          ],
          "candidate": [
            "libr/util/new_rbtree.c||libr/util/new_rbtree.c"
          ]
        }
      },
      "candidate_diff": {
        "libr/include/r_util.h||libr/include/r_util.h": [
          "File: libr/include/r_util.h -> libr/include/r_util.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "32: #include \"r_util/r_signal.h\"",
          "33: #include \"r_util/r_alloc.h\"",
          "34: #include \"r_util/r_rbtree.h\"",
          "35: #include \"r_util/r_intervaltree.h\"",
          "36: #include \"r_util/r_big.h\"",
          "37: #include \"r_util/r_base64.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "35: #include \"r_util/r_new_rbtree.h\"",
          "",
          "---------------"
        ],
        "libr/include/r_util/r_new_rbtree.h||libr/include/r_util/r_new_rbtree.h": [
          "File: libr/include/r_util/r_new_rbtree.h -> libr/include/r_util/r_new_rbtree.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2: BSD 2-Clause License",
          "4: Copyright (c) 2018, lynnl",
          "6: Cleaned up and refactored for r2 in 2021: condret",
          "8: All rights reserved.",
          "10: Redistribution and use in source and binary forms, with or without",
          "11: modification, are permitted provided that the following conditions are met:",
          "14:   list of conditions and the following disclaimer.",
          "17:   this list of conditions and the following disclaimer in the documentation",
          "18:   and/or other materials provided with the distribution.",
          "20: THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"",
          "21: AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE",
          "22: IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE",
          "23: DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE",
          "24: FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL",
          "25: DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR",
          "26: SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER",
          "27: CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,",
          "28: OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE",
          "29: OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.",
          "32: #ifndef RBTREE_H",
          "33: #define RBTREE_H",
          "35: #include <r_util.h>",
          "37: #ifdef __cplusplus",
          "38: extern \"C\" {",
          "39: #endif",
          "41: typedef struct r_rbtree_node {",
          "42:  struct r_rbtree_node *link[2];",
          "43:  struct r_rbtree_node *parent;",
          "44:  ut32 red;",
          "45:  void *data;",
          "46: } RRBNode;",
          "48: typedef int (*RRBComparator) (void *incoming, void *in, void *user);",
          "49: typedef void (*RRBFree) (void *data);",
          "51: typedef struct r_rbtree_t {",
          "52:  RRBNode *root;",
          "53:  size_t size;",
          "54:  RRBFree free;",
          "55: } RRBTree;",
          "57: R_API RBTree *r_rbtree_new(RRBFree freefn);",
          "58: R_API void r_rbtree_clear(RRBTree *tree);",
          "59: R_API void r_rbtree_free(RRBTree *tree);",
          "60: R_API RRBNode *r_rbtree_find_node(RRBTree *tree, void *data, RRBComparator cmp, void *user);",
          "61: R_API void *r_rbtree_find(RRBTree *tree, void *data, RRBComparator cmp, void *user);",
          "62: R_API bool r_rbtree_insert(RRBTree *tree, void *data, RRBComparator cmp, void *user);",
          "63: R_API bool r_rbtree_delete(RRBTree *tree, void *data, RRBComparator cmp, void *user);",
          "64: R_API RRBNode *r_rbtree_first_node(RRBTree *tree);",
          "65: R_API RRBNode *r_rbtree_last_node(RRBTree *tree);",
          "66: R_API RRBNode *r_rbnode_next(RRBNode *node);",
          "67: R_API RRBNode *r_rbnode_prev(RRBNode *node);",
          "69: #ifdef __cplusplus",
          "70: }",
          "71: #endif",
          "",
          "---------------"
        ],
        "libr/util/new_rbtree.c||libr/util/new_rbtree.c": [
          "File: libr/util/new_rbtree.c -> libr/util/new_rbtree.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2: BSD 2-Clause License",
          "4: Copyright (c) 2018, lynnl",
          "6: Cleaned up and refactored for r2 in 2021: condret",
          "8: All rights reserved.",
          "10: Redistribution and use in source and binary forms, with or without",
          "11: modification, are permitted provided that the following conditions are met:",
          "14:   list of conditions and the following disclaimer.",
          "17:   this list of conditions and the following disclaimer in the documentation",
          "18:   and/or other materials provided with the distribution.",
          "20: THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"",
          "21: AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE",
          "22: IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE",
          "23: DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE",
          "24: FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL",
          "25: DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR",
          "26: SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER",
          "27: CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,",
          "28: OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE",
          "29: OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.",
          "32: #include <r_util.h>",
          "34: static void _set_link(RRBNode *parent, RRBNode *child, const int dir) {",
          "35:  if (parent) {",
          "36:   parent->link[dir] = child;",
          "37:  }",
          "38:  if (child) {",
          "39:   child->parent = parent;",
          "40:  }",
          "41: }",
          "43: R_API RRBTree *r_rbtree_new(RRBFree freefn) {",
          "44:  RRBTree *tree = R_NEW0 (RRBTree);",
          "45:  if (tree) {",
          "46:   tree->free = freefn;",
          "47:  }",
          "48:  return tree;",
          "49: }",
          "51: R_API void r_rbtree_clear(RRBTree *tree) {",
          "52:  if (!tree) {",
          "53:   return;",
          "54:  }",
          "55:  RRBNode *iter = tree->root, *save = NULL;",
          "59:  while (iter) {",
          "60:   if (!iter->link[0]) {",
          "61:    save = iter->link[1];",
          "62:    if (tree->free) {",
          "63:     tree->free (iter->data);",
          "64:    }",
          "65:    free (iter);",
          "66:    tree->size--;",
          "67:    size1++;",
          "68:   } else {",
          "69:    save = iter->link[0];",
          "70:    _set_link (iter, save->link[1], 0);",
          "71:    _set_link (save, iter, 1);",
          "72:   }",
          "73:   iter = save;",
          "74:  }",
          "75:  tree->root = NULL;",
          "76: }",
          "78: R_API void r_rbtree_free(RRBTree *tree) {",
          "79:  if (!tree) {",
          "80:   return;",
          "81:  }",
          "82:  r_rbtree_clear (tree);",
          "83:  free (tree);",
          "84: }",
          "86: R_API RRBNode *r_rbtree_find_node(RRBTree *tree, void *data, RRBComparator cmp, void *user) {",
          "87:  r_return_val_if_fail (tree && cmp, NULL);",
          "89:  RRBNode *iter = tree->root;",
          "90:  while (iter) {",
          "91:   const int dir = cmp (data, iter->data, user);",
          "92:   if (!dir) {",
          "93:    return iter;",
          "94:   }",
          "95:   iter = iter->link[dir > 0];",
          "96:  }",
          "97:  return NULL;",
          "98: }",
          "100: R_API void *r_rbtree_find(RRBTree *tree, void *data, RRBComparator cmp, void *user) {",
          "101:  r_return_val_if_fail (tree && cmp, NULL);",
          "102:  RRBNode *node = r_rbtree_find_node (tree, data, cmp, user);",
          "103:  return node ? node->data : NULL;",
          "104: }",
          "106: static RRBNode *_node_new(void *data, RRBNode *parent) {",
          "107:  RRBNode *node = R_NEW0 (RRBNode);",
          "108:  r_return_val_if_fail (n, NULL);",
          "110:  node->red = 1;",
          "111:  node->data = data;",
          "112:  node->parent = parent;",
          "114:  return node;",
          "115: }",
          "117: #define IS_RED(n) ((n) != NULL && (n)->red == 1)",
          "119: static RRBNode *_rot_once(RRBNode *root, int dir) {",
          "120:  r_return_val_if_fail (root, NULL);",
          "123:  RRBNode *save = root->link[!dir];",
          "124:  _set_link (root, save->link[dir], !dir);",
          "125:  _set_link (save, root, dir);",
          "127:  root->red = 1;",
          "128:  save->red = 0;",
          "130:  return save;",
          "131: }",
          "133: static RRBNode *_rot_twice(RRBNode *root, int dir) {",
          "134:  r_return_val_if_fail (root, NULL);",
          "136:  _set_link (root, _rot_once (root->link[!dir], !dir), !dir);",
          "137:  return _rot_once (root, dir);",
          "138: }",
          "140: R_API bool r_rbtree_insert(RRBTree *tree, void *data, RRBComparator cmp, void *user) {",
          "141:  r_return_val_if_fail (tree && datai && cmp, false);",
          "142:  bool inserted = false;",
          "144:  if (tree->root == NULL) {",
          "145:   tree->root = _node_new (data, NULL);",
          "146:   if (tree->root == NULL) {",
          "147:    return false;",
          "148:   }",
          "149:   inserted = true;",
          "150:   goto out_exit;",
          "151:  }",
          "158:  _set_link (parent, q, 1);",
          "160:  while (1) {",
          "161:   if (q == NULL) {",
          "163:    q = _node_new (data, p);",
          "164:    if (!q) {",
          "165:     return false",
          "166:    }",
          "167:    p->link[dir] = q;",
          "168:    inserted = true;",
          "169:   } else if (IS_RED (q->link[0]) && IS_RED (q->link[1])) {",
          "171:    q->red = 1;",
          "172:    q->link[0]->red = 0;",
          "173:    q->link[1]->red = 0;",
          "174:   }",
          "176:   if (IS_RED (q) && IS_RED (p)) {",
          "178:    if (!parent) {",
          "179:     return false;",
          "180:    }",
          "181:    int dir2 = parent->link[1] == g;",
          "182:    if (q == p->link[last]) {",
          "183:     _set_link (parent, _rot_once (g, !last), dir2);",
          "184:    } else {",
          "185:     _set_link (parent, _rot_twice (g, !last), dir2);",
          "186:    }",
          "187:   }",
          "189:   if (inserted) {",
          "190:    break;",
          "191:   }",
          "193:   last = dir;",
          "194:   dir = cmp (data, q->data, user) >= 0;",
          "196:   if (g != NULL) {",
          "197:    parent = g;",
          "198:   }",
          "200:   g = p;",
          "201:   p = q;",
          "202:   q = q->link[dir];",
          "203:  }",
          "206:  tree->root = head.link[1];",
          "208: out_exit:",
          "210:  tree->root->red = 0;",
          "211:  tree->root->parent = NULL;",
          "212:  if (inserted) {",
          "213:   tree->size++;",
          "214:  }",
          "216:  return inserted;",
          "217: }",
          "219: R_API bool r_rbtree_delete(RRBTree *tree, void *data, RRBComparator cmp, void *user) {",
          "220:  r_return_val_if_fail (tree && data && tree->size && tree->root && cmp, false);",
          "222:  RRBNode head = { .red = 0 };",
          "223:  RRBNode *q = &head, *p = NULL, *g = NULL;",
          "224:  RRBNode *found = NULL;",
          "225:  int dir = 1, last;",
          "227:  _set_link (q, tree->root, 1);",
          "230:  while (q->link[dir] != NULL) {",
          "231:   last = dir;",
          "233:   g = p;",
          "234:   p = q;",
          "235:   q = q->link[dir];",
          "237:   dir = cmp (data, q->data, user);",
          "238:   if (dir == 0) {",
          "239:    found = q;",
          "240:   }",
          "242:   dir = dir > 0;",
          "244:   if (!IS_RED (q) && !IS_RED (q->link[dir])) {",
          "245:    if (IS_RED (q->link[!dir])) {",
          "246:     _set_link (p, _rot_once (q, dir), last);",
          "247:     p = p->link[last];",
          "248:    } else {",
          "249:     RRBNode *s = p->link[!last];",
          "251:     if (s != NULL) {",
          "252:      if (!IS_RED (s->link[!last]) && !IS_RED (s->link[last])) {",
          "254:       p->red = 0;",
          "255:       s->red = 1;",
          "256:       q->red = 1;",
          "257:      } else {",
          "258:       int dir2 = g->link[1] == p;",
          "260:       if (IS_RED (s->link[last])) {",
          "261:        _set_link (g, _rot_twice (p, last), dir2);",
          "262:       } else {",
          "263:        _set_link (g, _rot_once (p, last), dir2);",
          "264:       }",
          "267:       q->red = g->link[dir2]->red = 1;",
          "268:       g->link[dir2]->link[0]->red = 0;",
          "269:       g->link[dir2]->link[1]->red = 0;",
          "270:      }",
          "271:     }",
          "272:    }",
          "273:   }",
          "274:  }",
          "277:  if (found) {",
          "278:   found->data = q->data;",
          "279:   _set_link (p, q->link[q->link[0] == NULL], p->link[1] == q);",
          "280:   tree->free (q->data);",
          "281:   free (q);",
          "282:   tree->size--;",
          "283:  }",
          "286:  tree->root = head.link[1];",
          "287:  if (tree->root) {",
          "288:   tree->root->red = 0;",
          "289:  } else {",
          "290:   r_return_val_if_fail (tree->size == 0, false);",
          "291:  }",
          "292:  return !!found;",
          "293: }",
          "295: R_API RRBNode *r_rbtree_first_node(RRBTree *tree) {",
          "296:  r_return_val_if_fail (tree, NULL);",
          "297:  if (!tree->root) {",
          "299:   return NULL;",
          "300:  }",
          "301:  RRBNode *node = tree->root;",
          "302:  while (node->link[0]) {",
          "303:   node = node->link[0];",
          "304:  }",
          "305:  return node;",
          "306: }",
          "308: R_API RRBNode *r_rbtree_last_node(RRBTree *tree) {",
          "309:  r_return_val_if_fail (tree, NULL);",
          "310:  if (!tree->root) {",
          "312:   return NULL;",
          "313:  }",
          "314:  RRBNode *node = tree->root;",
          "315:  while (node->link[1]) {",
          "316:   node = node->link[1];",
          "317:  }",
          "318:  return node;",
          "319: }",
          "321: R_API RRBNode *r_rbnode_next(RRBNode *node) {",
          "322:  r_return_val_if_fail (node, NULL);",
          "323:  if (node->link[1]) {",
          "324:   node = node->link[1];",
          "325:   while (node->link[0]) {",
          "326:    node = node->link[0];",
          "327:   }",
          "328:   return node;",
          "329:  }",
          "330:  RRBNode *parent = node->parent;",
          "331:  while (parent->link[1] == node) {",
          "332:   node = parent;",
          "333:   parent = node->parent;",
          "334:   if (!parent) {",
          "335:    return NULL;",
          "336:   }",
          "337:  }",
          "338:  return parent;",
          "339: }",
          "341: R_API RRBNode *r_rbnode_prev(RRBNode *node) {",
          "342:  r_return_val_if_fail (node, NULL);",
          "343:  if (node->link[0]) {",
          "344:   node = node->link[0];",
          "345:   while (node->link[1]) {",
          "346:    node = node->link[1];",
          "347:   }",
          "348:   return node;",
          "349:  }",
          "350:  RRBNode *parent = node->parent;",
          "351:  while (parent->link[0] == node) {",
          "352:   node = parent;",
          "353:   parent = node->parent;",
          "354:   if (!parent) {",
          "355:    return NULL;",
          "356:   }",
          "357:  }",
          "358:  return parent;",
          "359: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "0dce1c7be516108ba8cbebdf306ba73868b80e5e",
      "candidate_info": {
        "commit_hash": "0dce1c7be516108ba8cbebdf306ba73868b80e5e",
        "repo": "radareorg/radare2",
        "commit_url": "https://github.com/radareorg/radare2/commit/0dce1c7be516108ba8cbebdf306ba73868b80e5e",
        "files": [
          "libr/include/r_io.h",
          "libr/io/io_bank.c"
        ],
        "message": "Imnplement r_io_bank_map_priorize (siol eternal) ##io",
        "before_after_code_files": [
          "libr/include/r_io.h||libr/include/r_io.h",
          "libr/io/io_bank.c||libr/io/io_bank.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libr/io/io_bank.c||libr/io/io_bank.c"
          ],
          "candidate": [
            "libr/io/io_bank.c||libr/io/io_bank.c"
          ]
        }
      },
      "candidate_diff": {
        "libr/include/r_io.h||libr/include/r_io.h": [
          "File: libr/include/r_io.h -> libr/include/r_io.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "360: R_API void r_io_bank_fini(RIO *io);",
          "361: R_API RIOBank *r_io_bank_get(RIO *io, ut32 bankid);",
          "362: R_API bool r_io_bank_map_add_top(RIO *io, ut32 bankid, ut32 mapid);",
          "363: R_API bool r_io_bank_locate(RIO *io, ut32 bankid, const ut64 size, ut64 *addr);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "363: R_API bool r_io_bank_map_priorize (RIO *io, const ut32 bankid, const ut32 mapid);",
          "",
          "---------------"
        ],
        "libr/io/io_bank.c||libr/io/io_bank.c": [
          "File: libr/io/io_bank.c -> libr/io/io_bank.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "137:   free (sm);",
          "138:   return true;",
          "139:  }",
          "140:  if (r_io_submap_from (bd) < r_io_submap_from (sm) &&",
          "141:   r_io_submap_to (sm) < r_io_submap_to (bd)) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "140:  if (r_io_submap_from (bd) < r_io_submap_from (sm) &&",
          "141:   r_io_submap_to (sm) < r_io_submap_to (bd)) {",
          "143:   RIOSubMap *bdsm = R_NEW (RIOSubMap);",
          "144:   if (!bdsm) {",
          "145:    free (sm);",
          "146:    return false;",
          "147:   }",
          "148:   bdsm->mapref = bd->mapref;",
          "149:   bdsm->itv.addr = r_io_submap_to (sm) + 1;",
          "150:   bdsm->itv.size = r_io_submap_to (bd) - bdsm->itv.addr + 1;",
          "151:   bd->itv.size = r_io_submap_from (sm) - r_io_submap_from (bd);",
          "153:   return r_rbtree_cont_insert (bank->submaps, sm, _find_sm_by_vaddr_cb, NULL) &",
          "154:    r_rbtree_cont_insert (bank->submaps, bdsm, _find_sm_by_vaddr_cb, NULL);",
          "155:  }",
          "157:  bd->itv.size = r_io_submap_from (sm) - r_io_submap_from (bd);",
          "158:  entry = r_rbtree_cont_node_next (entry);",
          "159:  while (entry && r_io_submap_to (((RIOSubMap *)entry->data)) <= r_io_submap_to (sm)) {",
          "161:   RContRBNode *next = r_rbtree_cont_node_next (entry);",
          "163:   r_rbtree_cont_delete (bank->submaps, entry->data, _find_sm_by_vaddr_cb, NULL);",
          "164:   entry = next;",
          "165:  }",
          "166:  if (entry && r_io_submap_from (((RIOSubMap *)entry->data)) <= r_io_submap_to (sm)) {",
          "167:   bd = (RIOSubMap *)entry->data;",
          "168:   bd->itv.size = r_io_submap_to (bd) - r_io_submap_to (sm);",
          "169:   bd->itv.addr = r_io_submap_to (sm) + 1;",
          "170:  }",
          "171:  return r_rbtree_cont_insert (bank->submaps, sm, _find_sm_by_vaddr_cb, NULL);",
          "172: }",
          "175: R_API bool r_io_bank_map_priorize (RIO *io, const ut32 bankid, const ut32 mapid) {",
          "176:  RIOBank *bank = r_io_bank_get (io, bankid);",
          "177:  r_return_val_if_fail (io && bank, false);",
          "178:  RListIter *iter;",
          "179:  RIOMapRef *mapref;",
          "180:  r_list_foreach (bank->maprefs, iter, mapref) {",
          "181:   if (mapref->id == mapid) {",
          "182:    goto found;",
          "183:   }",
          "184:  }",
          "185:  return false;",
          "186: found:",
          "187:  if (iter == bank->maprefs->head) {",
          "188:   return r_io_map_get_by_ref (io, mapref) ? true : false;",
          "189:  }",
          "190:  RIOSubMap *sm = r_io_submap_new (io, mapref);",
          "191:  if (!sm) {",
          "192:   return false;",
          "193:  }",
          "194:  RContRBNode *entry = _find_entry_submap_node (bank, sm);",
          "195:  if (!entry) {",
          "197:   free (sm);",
          "198:   return false;",
          "199:  }",
          "200:  RIOSubMap *bd = (RIOSubMap *)entry->data;",
          "201:  if (r_itv_eq (bd->itv, sm->itv)) {",
          "202:   bd->mapref = *mapref;",
          "203:   free (sm);",
          "204:   return true;",
          "205:  }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "154:    r_rbtree_cont_insert (bank->submaps, bdsm, _find_sm_by_vaddr_cb, NULL);",
          "155:  }",
          "158:  entry = r_rbtree_cont_node_next (entry);",
          "159:  while (entry && r_io_submap_to (((RIOSubMap *)entry->data)) <= r_io_submap_to (sm)) {",
          "",
          "[Removed Lines]",
          "157:  bd->itv.size = sm->itv.addr - bd->itv.addr;",
          "",
          "[Added Lines]",
          "223:  bd->itv.size = r_io_submap_from (sm) - r_io_submap_from (bd);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "163:   r_rbtree_cont_delete (bank->submaps, entry->data, _find_sm_by_vaddr_cb, NULL);",
          "164:   entry = next;",
          "165:  }",
          "167:   bd = (RIOSubMap *)entry->data;",
          "168:   bd->itv.size = r_io_submap_to (bd) - r_io_submap_to (sm);",
          "169:   bd->itv.addr = r_io_submap_to (sm) + 1;",
          "",
          "[Removed Lines]",
          "166:  if (entry) {",
          "",
          "[Added Lines]",
          "232:  if (entry && r_io_submap_from (((RIOSubMap *)entry->data)) <= r_io_submap_to (sm)) {",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "ead0cee8265df7d019065b82d36284addbf05a75",
      "candidate_info": {
        "commit_hash": "ead0cee8265df7d019065b82d36284addbf05a75",
        "repo": "radareorg/radare2",
        "commit_url": "https://github.com/radareorg/radare2/commit/ead0cee8265df7d019065b82d36284addbf05a75",
        "files": [
          "libr/io/io_bank.c",
          "libr/util/new_rbtree.c"
        ],
        "message": "Revert \"Prefer memleak over usaf in io.bank's rbtree bug ##crash\"\n\nThis reverts commit b5cb90b28ec71fda3504da04e3cc94a362807f5e.",
        "before_after_code_files": [
          "libr/io/io_bank.c||libr/io/io_bank.c",
          "libr/util/new_rbtree.c||libr/util/new_rbtree.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libr/io/io_bank.c||libr/io/io_bank.c",
            "libr/util/new_rbtree.c||libr/util/new_rbtree.c"
          ],
          "candidate": [
            "libr/io/io_bank.c||libr/io/io_bank.c",
            "libr/util/new_rbtree.c||libr/util/new_rbtree.c"
          ]
        }
      },
      "candidate_diff": {
        "libr/io/io_bank.c||libr/io/io_bank.c": [
          "File: libr/io/io_bank.c -> libr/io/io_bank.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "232:   r_io_submap_set_to (bd, r_io_submap_from (sm) - 1);",
          "233:   entry = r_rbnode_next (entry);",
          "234:  }",
          "238:   RRBNode *next = r_rbnode_next (entry);",
          "243:   bool a = r_crbtree_delete (bank->submaps, entry->data, _find_sm_by_from_vaddr_cb, NULL);",
          "245:   if (!a) {",
          "247:    break;",
          "248:   }",
          "249:   entry = next;",
          "",
          "[Removed Lines]",
          "235:  ut64 smto = r_io_submap_to (sm);",
          "236:  while (entry && r_io_submap_to (((RIOSubMap *)entry->data)) <= smto) {",
          "241:   void *smfree = bank->submaps->free;",
          "242:   bank->submaps->free = NULL;",
          "244:   bank->submaps->free = smfree;",
          "246:    entry = NULL;",
          "",
          "[Added Lines]",
          "235:  while (entry && r_io_submap_to (((RIOSubMap *)entry->data)) <= r_io_submap_to (sm)) {",
          "",
          "---------------"
        ],
        "libr/util/new_rbtree.c||libr/util/new_rbtree.c": [
          "File: libr/util/new_rbtree.c -> libr/util/new_rbtree.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "138:  r_return_val_if_fail (tree && data && cmp, false);",
          "139:  bool inserted = false;",
          "142:   tree->root = _node_new (data, NULL);",
          "144:    return false;",
          "145:   }",
          "146:   inserted = true;",
          "",
          "[Removed Lines]",
          "141:  if (!tree->root) {",
          "143:   if (!tree->root) {",
          "",
          "[Added Lines]",
          "141:  if (tree->root == NULL) {",
          "143:   if (tree->root == NULL) {",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "14189710859c27981adb4c2c2aed2863c1859ec5",
      "candidate_info": {
        "commit_hash": "14189710859c27981adb4c2c2aed2863c1859ec5",
        "repo": "radareorg/radare2",
        "commit_url": "https://github.com/radareorg/radare2/commit/14189710859c27981adb4c2c2aed2863c1859ec5",
        "files": [
          "libr/util/new_rbtree.c"
        ],
        "message": "Redo minor cleanup in new_rbtree",
        "before_after_code_files": [
          "libr/util/new_rbtree.c||libr/util/new_rbtree.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libr/util/new_rbtree.c||libr/util/new_rbtree.c"
          ],
          "candidate": [
            "libr/util/new_rbtree.c||libr/util/new_rbtree.c"
          ]
        }
      },
      "candidate_diff": {
        "libr/util/new_rbtree.c||libr/util/new_rbtree.c": [
          "File: libr/util/new_rbtree.c -> libr/util/new_rbtree.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "138:  r_return_val_if_fail (tree && data && cmp, false);",
          "139:  bool inserted = false;",
          "142:   tree->root = _node_new (data, NULL);",
          "144:    return false;",
          "145:   }",
          "146:   inserted = true;",
          "",
          "[Removed Lines]",
          "141:  if (tree->root == NULL) {",
          "143:   if (tree->root == NULL) {",
          "",
          "[Added Lines]",
          "141:  if (!tree->root) {",
          "143:   if (!tree->root) {",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "3345147916b9bb3da225248d571cdbac690c0c4d",
      "candidate_info": {
        "commit_hash": "3345147916b9bb3da225248d571cdbac690c0c4d",
        "repo": "radareorg/radare2",
        "commit_url": "https://github.com/radareorg/radare2/commit/3345147916b9bb3da225248d571cdbac690c0c4d",
        "files": [
          "libr/io/io_bank.c"
        ],
        "message": "Properly fix the UAF in r_io_bank_map_add_top ##crash\n\n* Associated with the CVE-2022-0559\n* Reported by alkyne Choi via huntr.dev",
        "before_after_code_files": [
          "libr/io/io_bank.c||libr/io/io_bank.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libr/io/io_bank.c||libr/io/io_bank.c"
          ],
          "candidate": [
            "libr/io/io_bank.c||libr/io/io_bank.c"
          ]
        }
      },
      "candidate_diff": {
        "libr/io/io_bank.c||libr/io/io_bank.c": [
          "File: libr/io/io_bank.c -> libr/io/io_bank.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "227:   entry = r_rbnode_next (entry);",
          "228:  }",
          "229:  ut64 smto = r_io_submap_to (sm);",
          "242:   }",
          "244:  }",
          "245:  if (entry && r_io_submap_from (((RIOSubMap *)entry->data)) <= r_io_submap_to (sm)) {",
          "246:   bd = (RIOSubMap *)entry->data;",
          "",
          "[Removed Lines]",
          "230:  while (entry && r_io_submap_to (((RIOSubMap *)entry->data)) <= smto) {",
          "232:   RRBNode *next = r_rbnode_next (entry);",
          "235:   void *smfree = bank->submaps->free;",
          "236:   bank->submaps->free = NULL;",
          "237:   bool a = r_crbtree_delete (bank->submaps, entry->data, _find_sm_by_from_vaddr_cb, NULL);",
          "238:   bank->submaps->free = smfree;",
          "239:   if (!a) {",
          "240:    entry = NULL;",
          "241:    break;",
          "243:   entry = next;",
          "",
          "[Added Lines]",
          "230:  if (entry) {",
          "231:   ut64 ento = r_io_submap_to (((RIOSubMap*)entry->data));",
          "232:   while (entry && ento <= smto) {",
          "234:    RRBNode *next = r_rbnode_next (entry);",
          "237:    ento = r_io_submap_to (((RIOSubMap*)entry->data));",
          "238:    bool a = r_crbtree_delete (bank->submaps, entry->data, _find_sm_by_from_vaddr_cb, NULL);",
          "239:    if (!a) {",
          "240:     next = NULL;",
          "241:    }",
          "242:    entry = next;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
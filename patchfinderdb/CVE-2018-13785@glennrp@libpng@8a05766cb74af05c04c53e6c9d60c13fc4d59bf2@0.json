{
  "cve_id": "CVE-2018-13785",
  "cve_desc": "In libpng 1.6.34, a wrong calculation of row_factor in the png_check_chunk_length function (pngrutil.c) may trigger an integer overflow and resultant divide-by-zero while processing a crafted PNG file, leading to a denial of service.",
  "repo": "glennrp/libpng",
  "patch_hash": "8a05766cb74af05c04c53e6c9d60c13fc4d59bf2",
  "patch_info": {
    "commit_hash": "8a05766cb74af05c04c53e6c9d60c13fc4d59bf2",
    "repo": "glennrp/libpng",
    "commit_url": "https://github.com/glennrp/libpng/commit/8a05766cb74af05c04c53e6c9d60c13fc4d59bf2",
    "files": [
      "pngrutil.c"
    ],
    "message": "[libpng16] Fix the calculation of row_factor in png_check_chunk_length\n\n(Bug report by Thuan Pham, SourceForge issue #278)",
    "before_after_code_files": [
      "pngrutil.c||pngrutil.c"
    ]
  },
  "patch_diff": {
    "pngrutil.c||pngrutil.c": [
      "File: pngrutil.c -> pngrutil.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "3167:    {",
      "3168:       png_alloc_size_t idat_limit = PNG_UINT_31_MAX;",
      "3169:       size_t row_factor =",
      "3172:       if (png_ptr->height > PNG_UINT_32_MAX/row_factor)",
      "3174:       else",
      "3175:          idat_limit = png_ptr->height * row_factor;",
      "3176:       row_factor = row_factor > 32566? 32566 : row_factor;",
      "",
      "[Removed Lines]",
      "3170:          (png_ptr->width * png_ptr->channels * (png_ptr->bit_depth > 8? 2: 1)",
      "3171:           + 1 + (png_ptr->interlaced? 6: 0));",
      "3173:          idat_limit=PNG_UINT_31_MAX;",
      "",
      "[Added Lines]",
      "3170:          (size_t)png_ptr->width",
      "3173:          + 1",
      "3174:          + (png_ptr->interlaced? 6: 0);",
      "3176:          idat_limit = PNG_UINT_31_MAX;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "2471434d29a8a006e8ca8e5b286c37b8604263b1",
      "candidate_info": {
        "commit_hash": "2471434d29a8a006e8ca8e5b286c37b8604263b1",
        "repo": "glennrp/libpng",
        "commit_url": "https://github.com/glennrp/libpng/commit/2471434d29a8a006e8ca8e5b286c37b8604263b1",
        "files": [
          "pngwrite.c"
        ],
        "message": "[libpng16] Added missing parentheses to a macro definition\n\n(Contributed by github.com/irwir)",
        "before_after_code_files": [
          "pngwrite.c||pngwrite.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/pnggroup/libpng/pull/232"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "pngwrite.c||pngwrite.c": [
          "File: pngwrite.c -> pngwrite.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1641: static png_byte",
          "1642: png_unpremultiply(png_uint_32 component, png_uint_32 alpha,",
          "",
          "[Removed Lines]",
          "1639: #   define UNP_RECIPROCAL(alpha) ((((0xffff*0xff)<<7)+(alpha>>1))/alpha)",
          "",
          "[Added Lines]",
          "1639: #   define UNP_RECIPROCAL(alpha) ((((0xffff*0xff)<<7)+((alpha)>>1))/(alpha))",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "2dca15686fadb1b8951cb29b02bad4cae73448da",
      "candidate_info": {
        "commit_hash": "2dca15686fadb1b8951cb29b02bad4cae73448da",
        "repo": "glennrp/libpng",
        "commit_url": "https://github.com/glennrp/libpng/commit/2dca15686fadb1b8951cb29b02bad4cae73448da",
        "files": [
          "ANNOUNCE",
          "CHANGES",
          "pngpread.c",
          "pngpriv.h",
          "pngrutil.c"
        ],
        "message": "[libpng16] Moved chunk-length check into a png_check_chunk_length() private\n\nfunction (Suggested by Max Stepin).",
        "before_after_code_files": [
          "pngpread.c||pngpread.c",
          "pngpriv.h||pngpriv.h",
          "pngrutil.c||pngrutil.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "pngrutil.c||pngrutil.c"
          ],
          "candidate": [
            "pngrutil.c||pngrutil.c"
          ]
        }
      },
      "candidate_diff": {
        "pngpread.c||pngpread.c": [
          "File: pngpread.c -> pngpread.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "190:       png_crc_read(png_ptr, chunk_tag, 4);",
          "191:       png_ptr->chunk_name = PNG_CHUNK_FROM_STRING(chunk_tag);",
          "192:       png_check_chunk_name(png_ptr, png_ptr->chunk_name);",
          "193:       png_ptr->mode |= PNG_HAVE_CHUNK_HEADER;",
          "194:    }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "193:       png_check_chunk_length(png_ptr, png_ptr->chunk_name,",
          "194:           png_ptr->push_length);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "224:          png_benign_error(png_ptr, \"Too many IDATs found\");",
          "225:    }",
          "259:    if (chunk_name == png_IHDR)",
          "260:    {",
          "261:       if (png_ptr->push_length != 13)",
          "",
          "[Removed Lines]",
          "227:    if (chunk_name == png_IDAT)",
          "228:    {",
          "229:       size_t row_factor =",
          "230:          (png_ptr->width * png_ptr->channels * (png_ptr->bit_depth > 8? 2: 1)",
          "231:           + 1 + (png_ptr->interlaced? 6: 0));",
          "232:       if (png_ptr->height > PNG_UINT_32_MAX/row_factor)",
          "233:          limit=PNG_UINT_31_MAX;",
          "234:       else",
          "235:          limit = png_ptr->height * row_factor;",
          "237:       limit=limit < PNG_UINT_31_MAX? limit : PNG_UINT_31_MAX;",
          "238:    }",
          "239:    else",
          "240:    {",
          "241: # ifdef PNG_SET_USER_LIMITS_SUPPORTED",
          "242:       if (png_ptr->user_chunk_malloc_max > 0 &&",
          "243:           png_ptr->user_chunk_malloc_max < limit)",
          "244:          limit = png_ptr->user_chunk_malloc_max;",
          "245: # elif PNG_USER_CHUNK_MALLOC_MAX > 0",
          "246:       if (PNG_USER_CHUNK_MALLOC_MAX < limit)",
          "247:          limit = PNG_USER_CHUNK_MALLOC_MAX;",
          "248: # endif",
          "249:    }",
          "250:    if (png_ptr->push_length > limit)",
          "251:    {",
          "252:       printf(\" png_ptr->push_length = %lu, limit = %lu\\n\",",
          "253:          (unsigned long)png_ptr->push_length,(unsigned long)limit);",
          "254:       png_debug2(0,\" png_ptr->push_length = %lu, limit = %lu\",",
          "255:          (unsigned long)png_ptr->push_length,(unsigned long)limit);",
          "256:       png_chunk_error(png_ptr, \"chunk data is too large\");",
          "257:    }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "pngpriv.h||pngpriv.h": [
          "File: pngpriv.h -> pngpriv.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "1530: PNG_INTERNAL_FUNCTION(void,png_check_chunk_name,(png_structrp png_ptr,",
          "1531:     png_uint_32 chunk_name),PNG_EMPTY);",
          "1533: PNG_INTERNAL_FUNCTION(void,png_handle_unknown,(png_structrp png_ptr,",
          "1534:     png_inforp info_ptr, png_uint_32 length, int keep),PNG_EMPTY);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1533: PNG_INTERNAL_FUNCTION(void,png_check_chunk_length,(png_structrp png_ptr,",
          "1534:     png_uint_32 chunk_name, png_uint_32 chunk_length),PNG_EMPTY);",
          "",
          "---------------"
        ],
        "pngrutil.c||pngrutil.c": [
          "File: pngrutil.c -> pngrutil.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "157: {",
          "158:    png_byte buf[8];",
          "159:    png_uint_32 length;",
          "162: #ifdef PNG_IO_STATE_SUPPORTED",
          "163:    png_ptr->io_state = PNG_IO_READING | PNG_IO_CHUNK_HDR;",
          "",
          "[Removed Lines]",
          "160:    png_alloc_size_t limit = PNG_UINT_31_MAX;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "183:    png_check_chunk_name(png_ptr, png_ptr->chunk_name);",
          "217: #ifdef PNG_IO_STATE_SUPPORTED",
          "218:    png_ptr->io_state = PNG_IO_READING | PNG_IO_CHUNK_DATA;",
          "",
          "[Removed Lines]",
          "186:    if (png_ptr->chunk_name != png_IDAT)",
          "187:    {",
          "188: # ifdef PNG_SET_USER_LIMITS_SUPPORTED",
          "189:       if (png_ptr->user_chunk_malloc_max > 0 &&",
          "190:           png_ptr->user_chunk_malloc_max < limit)",
          "191:          limit = png_ptr->user_chunk_malloc_max;",
          "192: # elif PNG_USER_CHUNK_MALLOC_MAX > 0",
          "193:       if (PNG_USER_CHUNK_MALLOC_MAX < limit)",
          "194:          limit = PNG_USER_CHUNK_MALLOC_MAX;",
          "195: # endif",
          "196:    }",
          "197:    else",
          "198:    {",
          "199:       size_t row_factor =",
          "200:          (png_ptr->width * png_ptr->channels * (png_ptr->bit_depth > 8? 2: 1)",
          "201:           + 1 + (png_ptr->interlaced? 6: 0));",
          "202:       if (png_ptr->height > PNG_UINT_32_MAX/row_factor)",
          "203:          limit=PNG_UINT_31_MAX;",
          "204:       else",
          "205:          limit = png_ptr->height * row_factor;",
          "207:       limit=limit < PNG_UINT_31_MAX? limit : PNG_UINT_31_MAX;",
          "208:    }",
          "210:    if (length > limit)",
          "211:    {",
          "212:       png_debug2(0,\" length = %lu, limit = %lu\",",
          "213:          (unsigned long)length,(unsigned long)limit);",
          "214:       png_chunk_error(png_ptr, \"chunk data is too large\");",
          "215:    }",
          "",
          "[Added Lines]",
          "185:    png_check_chunk_length(png_ptr, png_ptr->chunk_name, length);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3134:    }",
          "3135: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3108: png_check_chunk_length(png_structrp png_ptr, png_uint_32 chunk_name,",
          "3109:    png_uint_32 length)",
          "3110: {",
          "3111:    png_alloc_size_t limit = PNG_UINT_31_MAX;",
          "3113:    if (png_ptr->chunk_name != png_IDAT)",
          "3114:    {",
          "3115: # ifdef PNG_SET_USER_LIMITS_SUPPORTED",
          "3116:       if (png_ptr->user_chunk_malloc_max > 0 &&",
          "3117:           png_ptr->user_chunk_malloc_max < limit)",
          "3118:          limit = png_ptr->user_chunk_malloc_max;",
          "3119: # elif PNG_USER_CHUNK_MALLOC_MAX > 0",
          "3120:       if (PNG_USER_CHUNK_MALLOC_MAX < limit)",
          "3121:          limit = PNG_USER_CHUNK_MALLOC_MAX;",
          "3122: # endif",
          "3123:    }",
          "3124:    else",
          "3125:    {",
          "3126:       size_t row_factor =",
          "3127:          (png_ptr->width * png_ptr->channels * (png_ptr->bit_depth > 8? 2: 1)",
          "3128:           + 1 + (png_ptr->interlaced? 6: 0));",
          "3129:       if (png_ptr->height > PNG_UINT_32_MAX/row_factor)",
          "3130:          limit=PNG_UINT_31_MAX;",
          "3131:       else",
          "3132:          limit = png_ptr->height * row_factor;",
          "3134:       limit=limit < PNG_UINT_31_MAX? limit : PNG_UINT_31_MAX;",
          "3135:    }",
          "3137:    if (length > limit)",
          "3138:    {",
          "3139:       png_debug2(0,\" length = %lu, limit = %lu\",",
          "3140:          (unsigned long)length,(unsigned long)limit);",
          "3141:       png_chunk_error(png_ptr, \"chunk data is too large\");",
          "3142:    }",
          "3143: }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2018-7330",
  "cve_desc": "In Wireshark 2.4.0 to 2.4.4 and 2.2.0 to 2.2.12, epan/dissectors/packet-thread.c had an infinite loop that was addressed by using a correct integer data type.",
  "repo": "wireshark/wireshark",
  "patch_hash": "49e331c4cec96a1ca2637eed48f67553bc53a5b9",
  "patch_info": {
    "commit_hash": "49e331c4cec96a1ca2637eed48f67553bc53a5b9",
    "repo": "wireshark/wireshark",
    "commit_url": "https://github.com/wireshark/wireshark/commit/49e331c4cec96a1ca2637eed48f67553bc53a5b9",
    "files": [
      "epan/dissectors/packet-thread.c"
    ],
    "message": "Thread: use wider variables to prevent overflow and infinite loops\n\nBug: 14428\nChange-Id: I5536bdca23b24e41c13c0837d1f50d9db26f864a\nReviewed-on: https://code.wireshark.org/review/25832\nReviewed-by: Pascal Quantin <pascal.quantin@gmail.com>\nPetri-Dish: Pascal Quantin <pascal.quantin@gmail.com>\nTested-by: Petri Dish Buildbot\nReviewed-by: Michael Mann <mmann78@netscape.net>",
    "before_after_code_files": [
      "epan/dissectors/packet-thread.c||epan/dissectors/packet-thread.c"
    ]
  },
  "patch_diff": {
    "epan/dissectors/packet-thread.c||epan/dissectors/packet-thread.c": [
      "File: epan/dissectors/packet-thread.c -> epan/dissectors/packet-thread.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "885:                     int i, j;",
      "886:                     guint8 entries = 0;",
      "887:                     gint32 check_len = tlv_len;",
      "892:                     while (check_len > 0) {",
      "",
      "[Removed Lines]",
      "889:                     guint8 masklen;",
      "",
      "[Added Lines]",
      "889:                     guint16 masklen;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1729:                     int i;",
      "1730:                     guint8 entries = 0;",
      "1731:                     gint32 check_len = tlv_len;",
      "1736:                     while (check_len > 0) {",
      "",
      "[Removed Lines]",
      "1733:                     guint8 masklen;",
      "",
      "[Added Lines]",
      "1733:                     guint16 masklen;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "8ad0c5b3683a17d9e2e16bbf25869140fd5c1c66",
      "candidate_info": {
        "commit_hash": "8ad0c5b3683a17d9e2e16bbf25869140fd5c1c66",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/8ad0c5b3683a17d9e2e16bbf25869140fd5c1c66",
        "files": [
          "epan/dissectors/packet-thread.c"
        ],
        "message": "Thread: use wider variables to prevent overflow and infinite loops\n\nBug: 14428\nChange-Id: I5536bdca23b24e41c13c0837d1f50d9db26f864a\nReviewed-on: https://code.wireshark.org/review/25832\nReviewed-by: Pascal Quantin <pascal.quantin@gmail.com>\nPetri-Dish: Pascal Quantin <pascal.quantin@gmail.com>\nTested-by: Petri Dish Buildbot\nReviewed-by: Michael Mann <mmann78@netscape.net>\n(cherry picked from commit 49e331c4cec96a1ca2637eed48f67553bc53a5b9)\nReviewed-on: https://code.wireshark.org/review/25833\nPetri-Dish: Michael Mann <mmann78@netscape.net>",
        "before_after_code_files": [
          "epan/dissectors/packet-thread.c||epan/dissectors/packet-thread.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "epan/dissectors/packet-thread.c||epan/dissectors/packet-thread.c"
          ],
          "candidate": [
            "epan/dissectors/packet-thread.c||epan/dissectors/packet-thread.c"
          ]
        }
      },
      "candidate_diff": {
        "epan/dissectors/packet-thread.c||epan/dissectors/packet-thread.c": [
          "File: epan/dissectors/packet-thread.c -> epan/dissectors/packet-thread.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "899:                     int i, j;",
          "900:                     guint8 entries = 0;",
          "901:                     gint32 check_len = tlv_len;",
          "906:                     while (check_len > 0) {",
          "",
          "[Removed Lines]",
          "903:                     guint8 masklen;",
          "",
          "[Added Lines]",
          "903:                     guint16 masklen;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1743:                     int i;",
          "1744:                     guint8 entries = 0;",
          "1745:                     gint32 check_len = tlv_len;",
          "1750:                     while (check_len > 0) {",
          "",
          "[Removed Lines]",
          "1747:                     guint8 masklen;",
          "",
          "[Added Lines]",
          "1747:                     guint16 masklen;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "14ba81598da88390d26d3082da735743d6d41074",
      "candidate_info": {
        "commit_hash": "14ba81598da88390d26d3082da735743d6d41074",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/14ba81598da88390d26d3082da735743d6d41074",
        "files": [
          "docbook/release-notes.asciidoc",
          "epan/dissectors/CMakeLists.txt",
          "epan/dissectors/Makefile.am",
          "epan/dissectors/packet-ieee802154.c",
          "epan/dissectors/packet-mle.c",
          "epan/dissectors/packet-mle.h",
          "epan/dissectors/packet-openthread.c",
          "epan/dissectors/packet-thread.c",
          "tools/checkfiltername.pl"
        ],
        "message": "MLE and Thread: Additional dissectors\n\nAdditional dissectors for Mesh Link Establishment (MLE) and Thread CoAP\nTMF messages. MLE is also used in ZigBee IP.\n\nChange-Id: I5b9c224d7df48855b79ccac67dca7661a51d0a9b\nBug: 13495\nReviewed-on: https://code.wireshark.org/review/20594\nReviewed-by: Stig Bj\u00f8rlykke <stig@bjorlykke.org>\nPetri-Dish: Stig Bj\u00f8rlykke <stig@bjorlykke.org>\nTested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>\nReviewed-by: Michael Mann <mmann78@netscape.net>",
        "before_after_code_files": [
          "docbook/release-notes.asciidoc||docbook/release-notes.asciidoc",
          "epan/dissectors/Makefile.am||epan/dissectors/Makefile.am",
          "epan/dissectors/packet-ieee802154.c||epan/dissectors/packet-ieee802154.c",
          "epan/dissectors/packet-mle.c||epan/dissectors/packet-mle.c",
          "epan/dissectors/packet-mle.h||epan/dissectors/packet-mle.h",
          "epan/dissectors/packet-openthread.c||epan/dissectors/packet-openthread.c",
          "epan/dissectors/packet-thread.c||epan/dissectors/packet-thread.c",
          "tools/checkfiltername.pl||tools/checkfiltername.pl"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "epan/dissectors/packet-thread.c||epan/dissectors/packet-thread.c"
          ],
          "candidate": [
            "epan/dissectors/packet-thread.c||epan/dissectors/packet-thread.c"
          ]
        }
      },
      "candidate_diff": {
        "docbook/release-notes.asciidoc||docbook/release-notes.asciidoc": [
          "File: docbook/release-notes.asciidoc -> docbook/release-notes.asciidoc",
          "--- Hunk 1 ---",
          "[Context before]",
          "69: ISO 15765",
          "70: Local Service Discovery (LSD)",
          "71: M2 Application Protocol",
          "72: Nordic BLE Sniffer",
          "73: NVMe Fabrics RDMA",
          "74: NVMe",
          "75: RFTap Protocol",
          "76: SCTE-35 Digital Program Insertion Messages",
          "77: Snort Post-dissector",
          "78: Unified Diagnostic Services (UDS)",
          "79: vSocket",
          "80: Windows Cluster Management API (clusapi)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "72: Mesh Link Establishment (MLE)",
          "76: OpenThread simulator",
          "80: Thread CoAP",
          "",
          "---------------"
        ],
        "epan/dissectors/Makefile.am||epan/dissectors/Makefile.am": [
          "File: epan/dissectors/Makefile.am -> epan/dissectors/Makefile.am",
          "--- Hunk 1 ---",
          "[Context before]",
          "913:  packet-mip.c  \\",
          "914:  packet-mip6.c  \\",
          "915:  packet-mka.c  \\",
          "916:  packet-mmse.c  \\",
          "917:  packet-mndp.c  \\",
          "918:  packet-mojito.c  \\",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "916:  packet-mle.c  \\",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1035:  packet-openflow_v4.c \\",
          "1036:  packet-openflow_v5.c \\",
          "1037:  packet-opensafety.c \\",
          "1038:  packet-openvpn.c \\",
          "1039:  packet-openwire.c \\",
          "1040:  packet-opsi.c  \\",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1039:  packet-openthread.c \\",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1284:  packet-text-media.c \\",
          "1285:  packet-tfp.c  \\",
          "1286:  packet-tftp.c  \\",
          "1287:  packet-thrift.c  \\",
          "1288:  packet-time.c  \\",
          "1289:  packet-tipc.c  \\",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1289:  packet-thread.c \\",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1629:  packet-mbim.h  \\",
          "1630:  packet-mbtcp.h  \\",
          "1631:  packet-mgcp.h  \\",
          "1632:  packet-mms.h  \\",
          "1633:  packet-mount.h  \\",
          "1634:  packet-mp4ves.h  \\",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1635:  packet-mle.h  \\",
          "",
          "---------------"
        ],
        "epan/dissectors/packet-ieee802154.c||epan/dissectors/packet-ieee802154.c": [
          "File: epan/dissectors/packet-ieee802154.c -> epan/dissectors/packet-ieee802154.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "240:     const ieee802154_key_t* old_record = (const ieee802154_key_t*)o;",
          "242:     new_record->pref_key = g_strdup(old_record->pref_key);",
          "244:     return new_record;",
          "245: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "243:     new_record->key_index = old_record->key_index;",
          "244:     new_record->hash_type = old_record->hash_type;",
          "",
          "---------------"
        ],
        "epan/dissectors/packet-mle.c||epan/dissectors/packet-mle.c": [
          "File: epan/dissectors/packet-mle.c -> epan/dissectors/packet-mle.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "33: #include \"config.h\"",
          "35: #include <glib.h>",
          "36: #include <math.h>",
          "37: #include <epan/packet.h>",
          "38: #include <epan/conversation.h>",
          "39: #include <epan/proto_data.h>",
          "40: #include <epan/wmem/wmem.h>",
          "41: #include <epan/expert.h>",
          "42: #include <epan/prefs.h>",
          "43: #include <epan/strutil.h>",
          "44: #include <epan/to_str.h>",
          "45: #include \"packet-ieee802154.h\"",
          "46: #include \"packet-mle.h\"",
          "48: #define MLE_32768_TO_NSEC_FACTOR ((double)30517.578125)",
          "51: void proto_register_mle(void);",
          "52: void proto_reg_handoff_mle(void);",
          "54: static int proto_mle = -1;",
          "58: static int hf_mle_security_suite = -1;",
          "59: static int hf_mle_mic = -1;",
          "61: static int hf_mle_command = -1;",
          "62: static int hf_mle_tlv = -1;",
          "63: static int hf_mle_tlv_type = -1;",
          "64: static int hf_mle_tlv_length = -1;",
          "65: static int hf_mle_tlv_source_addr = -1;",
          "66: static int hf_mle_tlv_mode_device_type = -1;",
          "67: static int hf_mle_tlv_mode_idle_rx = -1;",
          "68: static int hf_mle_tlv_mode_sec_data_req = -1;",
          "69: static int hf_mle_tlv_mode_nwk_data = -1;",
          "70: static int hf_mle_tlv_timeout = -1;",
          "71: static int hf_mle_tlv_challenge = -1;",
          "72: static int hf_mle_tlv_response = -1;",
          "73: static int hf_mle_tlv_ll_frm_cntr = -1;",
          "74: static int hf_mle_tlv_lqi_c = -1;",
          "75: static int hf_mle_tlv_lqi_size = -1;",
          "76: static int hf_mle_tlv_neighbor = -1;",
          "77: static int hf_mle_tlv_neighbor_flagI = -1;",
          "78: static int hf_mle_tlv_neighbor_flagO = -1;",
          "79: static int hf_mle_tlv_neighbor_flagP = -1;",
          "80: static int hf_mle_tlv_neighbor_idr = -1;",
          "81: static int hf_mle_tlv_neighbor_addr = -1;",
          "82: static int hf_mle_tlv_network_param_id = -1;",
          "83: static int hf_mle_tlv_network_delay = -1;",
          "84: static int hf_mle_tlv_network_channel = -1;",
          "85: static int hf_mle_tlv_network_pan_id = -1;",
          "86: static int hf_mle_tlv_network_pmt_join = -1;",
          "87: static int hf_mle_tlv_network_bcn_payload = -1;",
          "88: static int hf_mle_tlv_network_unknown = -1;",
          "89: static int hf_mle_tlv_mle_frm_cntr = -1;",
          "90: static int hf_mle_tlv_unknown = -1;",
          "91: static int hf_mle_tlv_route64_id_seq = -1;",
          "92: static int hf_mle_tlv_route64_id_mask = -1;",
          "93: static int hf_mle_tlv_route64_entry = -1;",
          "94: static int hf_mle_tlv_route64_nbr_out = -1;",
          "95: static int hf_mle_tlv_route64_nbr_in = -1;",
          "96: static int hf_mle_tlv_route64_cost = -1;",
          "97: #if 0",
          "98: static int hf_mle_tlv_route64_unknown = -1;",
          "99: #endif",
          "100: static int hf_mle_tlv_addr16 = -1;",
          "101: static int hf_mle_tlv_leader_data_partition_id = -1;",
          "102: static int hf_mle_tlv_leader_data_weighting = -1;",
          "103: static int hf_mle_tlv_leader_data_version = -1;",
          "104: static int hf_mle_tlv_leader_data_stable_version = -1;",
          "105: static int hf_mle_tlv_leader_data_router_id = -1;",
          "106: #if 0",
          "107: static int hf_mle_tlv_network_data = -1;",
          "108: #endif",
          "109: static int hf_mle_tlv_scan_mask_r = -1;",
          "110: static int hf_mle_tlv_scan_mask_e = -1;",
          "111: static int hf_mle_tlv_conn_max_child_cnt = -1;",
          "112: static int hf_mle_tlv_conn_child_cnt = -1;",
          "113: static int hf_mle_tlv_conn_flags = -1;",
          "114: static int hf_mle_tlv_conn_flags_pp = -1;",
          "115: static int hf_mle_tlv_conn_lq3 = -1;",
          "116: static int hf_mle_tlv_conn_lq2 = -1;",
          "117: static int hf_mle_tlv_conn_lq1 = -1;",
          "118: static int hf_mle_tlv_conn_leader_cost = -1;",
          "119: static int hf_mle_tlv_conn_id_seq = -1;",
          "120: static int hf_mle_tlv_conn_active_rtrs = -1;",
          "121: static int hf_mle_tlv_conn_sed_buf_size = -1;",
          "122: static int hf_mle_tlv_conn_sed_dgram_cnt = -1;",
          "123: static int hf_mle_tlv_link_margin = -1;",
          "124: static int hf_mle_tlv_status = -1;",
          "125: static int hf_mle_tlv_version = -1;",
          "126: static int hf_mle_tlv_addr_reg_entry = -1;",
          "127: static int hf_mle_tlv_addr_reg_iid_type = -1;",
          "128: static int hf_mle_tlv_addr_reg_cid = -1;",
          "129: static int hf_mle_tlv_addr_reg_iid = -1;",
          "130: static int hf_mle_tlv_addr_reg_ipv6 = -1;",
          "131: #if 0",
          "132: static int hf_mle_tlv_hold_time = -1;",
          "133: #endif",
          "139: #if 0",
          "142: #endif",
          "144: static gint ett_mle = -1;",
          "145: static gint ett_mle_tlv = -1;",
          "146: static gint ett_mle_neighbor = -1;",
          "147: static gint ett_mle_router = -1;",
          "148: static gint ett_mle_addr_reg = -1;",
          "149: static gint ett_mle_conn_flg = -1;",
          "150: static gint ett_mle_thread_nwd = -1;",
          "151: static gint ett_mle_auxiliary_security = -1;",
          "152: static gint ett_mle_aux_sec_control = -1;",
          "153: static gint ett_mle_aux_sec_key_id = -1;",
          "155: static expert_field ei_mle_cbc_mac_failed = EI_INIT;",
          "156: static expert_field ei_mle_packet_too_small = EI_INIT;",
          "157: static expert_field ei_mle_no_key = EI_INIT;",
          "158: static expert_field ei_mle_decrypt_failed = EI_INIT;",
          "159: static expert_field ei_mle_mic_check_failed = EI_INIT;",
          "160: static expert_field ei_mle_tlv_length_failed = EI_INIT;",
          "161: static expert_field ei_mle_len_size_mismatch = EI_INIT;",
          "163: static dissector_handle_t mle_handle;",
          "164: static dissector_handle_t thread_nwd_handle;",
          "165: static dissector_handle_t thread_mc_handle;",
          "170: static gboolean mle_mic_ok = FALSE;",
          "172: static wmem_tree_t* mle_key_hash_handlers;",
          "174: static const value_string mle_sec_suite_names[] = {",
          "175:     { 0,   \"802.15.4 Security\" },",
          "176:     { 255, \"No Security\" },",
          "177:     { 0, NULL }",
          "178: };",
          "180: static const value_string mle_status_tlv_enums[] = {",
          "181:     { 1, \"Error\" },",
          "182:     { 2, \"Duplicate Address Detected\" },",
          "183:     { 0, NULL }",
          "184: };",
          "186: static const value_string mle_conn_tlv_flags_pp_enums[] = {",
          "187:     { 1, \"High\" },",
          "188:     { 0, \"Medium\" },",
          "189:     { -1, \"Low\" },",
          "190:     { 0, NULL }",
          "191: };",
          "193: #define MLE_CMD_REQUEST               0",
          "194: #define MLE_CMD_ACCEPT                1",
          "195: #define MLE_CMD_ACCEPTREQ             2",
          "196: #define MLE_CMD_REJECT                3",
          "197: #define MLE_CMD_ADVERTISE             4",
          "198: #define MLE_CMD_UPDATE                5",
          "199: #define MLE_CMD_UPDATE_REQUEST        6",
          "200: #define MLE_CMD_DATA_REQUEST          7",
          "201: #define MLE_CMD_DATA_RESPONSE         8",
          "202: #define MLE_CMD_PARENT_REQUEST        9",
          "203: #define MLE_CMD_PARENT_RESPONSE       10",
          "204: #define MLE_CMD_CHILD_ID_REQUEST      11",
          "205: #define MLE_CMD_CHILD_ID_RESPONSE     12",
          "206: #define MLE_CMD_CHILD_UPDATE_REQUEST  13",
          "207: #define MLE_CMD_CHILD_UPDATE_RESPONSE 14",
          "208: #define MLE_CMD_ANNOUNCE              15",
          "209: #define MLE_CMD_DISCOVERY_REQUEST     16",
          "210: #define MLE_CMD_DISCOVERY_RESPONSE    17",
          "212: static const value_string mle_command_vals[] = {",
          "213:     { MLE_CMD_REQUEST,                  \"Link Request\" },",
          "214:     { MLE_CMD_ACCEPT,                   \"Link Accept\" },",
          "215:     { MLE_CMD_ACCEPTREQ,                \"Link Accept and Request\" },",
          "216:     { MLE_CMD_REJECT,                   \"Link Reject\" },",
          "217:     { MLE_CMD_ADVERTISE,                \"Advertisement\" },",
          "218:     { MLE_CMD_UPDATE,                   \"Update\" },",
          "219:     { MLE_CMD_UPDATE_REQUEST,           \"Update Request\" },",
          "220:     { MLE_CMD_DATA_REQUEST,             \"Data Request\" },",
          "221:     { MLE_CMD_DATA_RESPONSE,            \"Data Response\" },",
          "222:     { MLE_CMD_PARENT_REQUEST,           \"Parent Request\" },",
          "223:     { MLE_CMD_PARENT_RESPONSE,          \"Parent Response\" },",
          "224:     { MLE_CMD_CHILD_ID_REQUEST,         \"Child ID Request\" },",
          "225:     { MLE_CMD_CHILD_ID_RESPONSE,        \"Child ID Response\" },",
          "226:     { MLE_CMD_CHILD_UPDATE_REQUEST,     \"Child Update Request\" },",
          "227:     { MLE_CMD_CHILD_UPDATE_RESPONSE,    \"Child Update Response\" },",
          "228:     { MLE_CMD_ANNOUNCE,                 \"Announce\" },",
          "229:     { MLE_CMD_DISCOVERY_REQUEST,        \"Discovery Request\" },",
          "230:     { MLE_CMD_DISCOVERY_RESPONSE,       \"Discovery Response\" },",
          "231:     { 0, NULL}",
          "232: };",
          "234: #define MLE_TLV_SOURCE_ADDRESS              0",
          "236: #define MLE_TLV_TIMEOUT                     2",
          "237: #define MLE_TLV_CHALLENGE                   3",
          "238: #define MLE_TLV_RESPONSE                    4",
          "239: #define MLE_TLV_LINK_LAYER_FRAME_COUNTER    5",
          "240: #define MLE_TLV_LINK_QUALITY                6",
          "241: #define MLE_TLV_NETWORK_PARAMETER           7",
          "242: #define MLE_TLV_MLE_FRAME_COUNTER           8",
          "262: static const value_string mle_tlv_vals[] = {",
          "263:     { MLE_TLV_SOURCE_ADDRESS,           \"Source Address\" },",
          "264:     { MLE_TLV_MODE,                     \"Mode\" },",
          "265:     { MLE_TLV_TIMEOUT,                  \"Timeout\" },",
          "266:     { MLE_TLV_CHALLENGE,                \"Challenge\" },",
          "267:     { MLE_TLV_RESPONSE,                 \"Response\" },",
          "268:     { MLE_TLV_LINK_LAYER_FRAME_COUNTER, \"Link Layer Frame Counter\"},",
          "269:     { MLE_TLV_LINK_QUALITY,             \"Link Quality\"},",
          "270:     { MLE_TLV_NETWORK_PARAMETER,        \"Network Parameter\"},",
          "271:     { MLE_TLV_MLE_FRAME_COUNTER,        \"MLE Frame Counter\"},",
          "272:     { MLE_TLV_ROUTE64,                  \"Route64\"},",
          "273:     { MLE_TLV_ADDRESS16,                \"Address16\"},",
          "274:     { MLE_TLV_LEADER_DATA,              \"Leader Data\"},",
          "275:     { MLE_TLV_NETWORK_DATA,             \"Network Data\"},",
          "276:     { MLE_TLV_TLV_REQUEST,              \"TLV Request\"},",
          "277:     { MLE_TLV_SCAN_MASK,                \"Scan Mask\"},",
          "278:     { MLE_TLV_CONNECTIVITY,             \"Connectivity\"},",
          "279:     { MLE_TLV_LINK_MARGIN,              \"Link Margin\"},",
          "280:     { MLE_TLV_STATUS,                   \"Status\"},",
          "281:     { MLE_TLV_VERSION,                  \"Version\"},",
          "282:     { MLE_TLV_ADDRESS_REGISTRATION,     \"Address Registration\"},",
          "283:     { MLE_TLV_CHANNEL,                  \"Channel\"},",
          "284:     { MLE_TLV_PAN_ID,                   \"PAN ID\"},",
          "285:     { MLE_TLV_ACTIVE_TSTAMP,            \"Active Timestamp\"},",
          "286:     { MLE_TLV_PENDING_TSTAMP,           \"Pending Timestamp\"},",
          "287:     { MLE_TLV_ACTIVE_OP_DATASET,        \"Active Operational Dataset\"},",
          "288:     { MLE_TLV_PENDING_OP_DATASET,       \"Pending Operational Dataset\"},",
          "289:     { MLE_TLV_THREAD_DISCOVERY,         \"Thread Discovery\"},",
          "290:     { 0, NULL}",
          "291: };",
          "293: #define LQI_FLAGS_C         0x80",
          "294: #define LQI_FLAGS_SIZE      0x0F",
          "296: #define NEIGHBOR_FLAG_I     0x80",
          "297: #define NEIGHBOR_FLAG_O     0x40",
          "298: #define NEIGHBOR_FLAG_P     0x20",
          "300: #define NETWORK_PARAM_ID_CHANNEL        0",
          "301: #define NETWORK_PARAM_ID_PAN_ID         1",
          "302: #define NETWORK_PARAM_ID_PERMIT_JOIN    2",
          "303: #define NETWORK_PARAM_ID_BCN_PAYLOAD    3",
          "305: static const value_string mle_tlv_nwk_param_vals[] = {",
          "306:     { NETWORK_PARAM_ID_CHANNEL,     \"Channel\" },",
          "307:     { NETWORK_PARAM_ID_PAN_ID,      \"PAN ID\" },",
          "308:     { NETWORK_PARAM_ID_PERMIT_JOIN, \"Permit Join\" },",
          "309:     { NETWORK_PARAM_ID_BCN_PAYLOAD, \"Beacon Payload\" },",
          "310:     { 0, NULL}",
          "311: };",
          "313: static const true_false_string mle_tlv_mode_device_type = {",
          "314:     \"FFD\",",
          "315:     \"RFD\"",
          "316: };",
          "317: static const true_false_string mle_tlv_mode_nwk_data = {",
          "318:     \"Full\",",
          "319:     \"Stable\"",
          "320: };",
          "321: static const true_false_string mle_tlv_addr_reg_iid_type = {",
          "322:     \"Compressed\",",
          "323:     \"Full\"",
          "324: };",
          "326: #define ROUTE_TBL_OUT_MASK          0xC0",
          "327: #define ROUTE_TBL_IN_MASK           0x30",
          "328: #define ROUTE_TBL_COST_MASK         0x0F",
          "330: #define SCAN_MASK_R_MASK            0x80",
          "331: #define SCAN_MASK_D_MASK            0x40",
          "333: #define CONN_MASK_FLAGS_PP_MASK     0xC0",
          "335: #define ADDR_REG_MASK_IID_TYPE_MASK 0x80",
          "336: #define ADDR_REG_MASK_CID_MASK      0x0F",
          "338: #define MLE_CMD_CINFO_SEC_DATA_REQ  0x04",
          "339: #define MLE_CMD_CINFO_NWK_DATA      0x01",
          "356: static tvbuff_t *",
          "357: dissect_mle_decrypt(tvbuff_t * tvb,",
          "358:                     guint offset,",
          "359:                     packet_info * pinfo,",
          "360:                     ieee802154_packet * packet,",
          "361:                     ieee802154_payload_info_t* payload_info)",
          "362: {",
          "363:     tvbuff_t *          ptext_tvb;",
          "364:     gboolean            have_mic = FALSE;",
          "365:     guint64             srcAddr;",
          "366:     unsigned char       tmp[16];",
          "367:     guint               M;",
          "368:     gint                captured_len;",
          "369:     gint                reported_len;",
          "372:     memset(payload_info->rx_mic, 0, 16);",
          "375:     if (packet->security_level > 0) {",
          "376:         M = IEEE802154_MIC_LENGTH(packet->security_level);",
          "377:     }",
          "378:     else {",
          "379:         M = 0;",
          "380:     }",
          "382:     reported_len = tvb_reported_length_remaining(tvb, offset) - M;",
          "383:     if (reported_len < 0) {",
          "385:         return NULL;",
          "386:     }",
          "388:     if (tvb_bytes_exist(tvb, offset, reported_len)) {",
          "389:         captured_len = reported_len;",
          "390:     }",
          "391:     else {",
          "392:         captured_len = tvb_captured_length_remaining(tvb, offset);",
          "393:     }",
          "395:     if (packet->security_level > 0) {",
          "397:         have_mic = tvb_bytes_exist(tvb, offset + reported_len, M);",
          "398:         if (have_mic) {",
          "399:             tvb_memcpy(tvb, payload_info->rx_mic, offset + reported_len, M);",
          "400:         }",
          "401:     }",
          "407:     if (packet->src_addr_mode == IEEE802154_FCF_ADDR_EXT) {",
          "410:     }",
          "411:     else {",
          "414:         return NULL;",
          "415:     }",
          "422:     ccm_init_block(tmp, FALSE, 0, srcAddr, packet->frame_counter, packet->security_level, 0);",
          "425:     if (IEEE802154_IS_ENCRYPTED(packet->security_level) && captured_len) {",
          "426:         gchar *text;",
          "434:         text = (gchar *)tvb_memdup(pinfo->pool, tvb, offset, captured_len);",
          "437:         if (!ccm_ctr_encrypt(payload_info->key, tmp, payload_info->rx_mic, text, captured_len)) {",
          "439:             return NULL;",
          "440:         }",
          "443:         ptext_tvb = tvb_new_real_data((const guint8 *)text, captured_len, reported_len);",
          "444:         tvb_set_child_real_data_tvbuff(tvb, ptext_tvb);",
          "445:         add_new_data_source(pinfo, ptext_tvb, \"Decrypted MLE payload\");",
          "447:     }",
          "449:     else {",
          "451:         if (have_mic) {",
          "452:             if (!ccm_ctr_encrypt(payload_info->key, tmp, payload_info->rx_mic, NULL, 0)) {",
          "454:                 return NULL;",
          "455:             }",
          "456:         }",
          "459:         ptext_tvb = tvb_new_subset_length_caplen(tvb, offset, captured_len, reported_len);",
          "461:     }",
          "468:     if (have_mic) {",
          "469:         unsigned char           dec_mic[16];",
          "470:         guint                   l_m = captured_len;",
          "471:         guint                   l_a;",
          "472:         guint8                  d_a[256];",
          "474:         DISSECTOR_ASSERT(pinfo->src.len == 16);",
          "475:         DISSECTOR_ASSERT(pinfo->dst.len == 16);",
          "476:         memcpy(d_a, (guint8 *)pinfo->src.data, pinfo->src.len);",
          "477:         memcpy(d_a+16, (guint8 *)pinfo->dst.data, pinfo->dst.len);",
          "479:         tvb_memcpy(tvb, d_a+32, payload_info->aux_offset, payload_info->aux_length);",
          "480:         l_a = 32 + payload_info->aux_length;",
          "483:         if (!IEEE802154_IS_ENCRYPTED(packet->security_level)) {",
          "484:             l_a += l_m;",
          "485:             l_m = 0;",
          "486:         }",
          "489:         ccm_init_block(tmp, TRUE, M, srcAddr, packet->frame_counter, packet->security_level, l_m);",
          "499:         if (!ccm_cbc_mac(payload_info->key, tmp, d_a, l_a, tvb_get_ptr(ptext_tvb, 0, l_m), l_m, dec_mic)) {",
          "501:         }",
          "503:         else if (memcmp(payload_info->rx_mic, dec_mic, M) != 0) {",
          "505:         }",
          "506:     }",
          "511:     return ptext_tvb;",
          "514: void register_mle_key_hash_handler(guint hash_identifier, ieee802154_set_mac_key_func key_func)",
          "515: {",
          "517:     DISSECTOR_ASSERT(wmem_tree_lookup32(mle_key_hash_handlers, hash_identifier) == NULL);",
          "519:     wmem_tree_insert32(mle_key_hash_handlers, hash_identifier, (void*)key_func);",
          "520: }",
          "523: static gboolean ieee802154_set_mle_key(ieee802154_packet *packet, unsigned char *key, unsigned char *alt_key, ieee802154_key_t* uat_key)",
          "524: {",
          "525:     mle_set_mle_key_func func = (mle_set_mle_key_func)wmem_tree_lookup32(mle_key_hash_handlers, uat_key->hash_type);",
          "527:     if (func != NULL)",
          "528:         return func(packet, key, alt_key, uat_key);",
          "532:     if (packet->key_index == uat_key->key_index)",
          "533:     {",
          "534:         memcpy(key, uat_key->key, IEEE802154_CIPHER_SIZE);",
          "535:         return TRUE;",
          "536:     }",
          "538:     return FALSE;",
          "539: }",
          "541: static int",
          "542: dissect_mle(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)",
          "543: {",
          "544:     tvbuff_t                *volatile payload_tvb = NULL;",
          "545:     proto_tree              *volatile mle_tree = NULL;",
          "546:     proto_item              *volatile proto_root = NULL;",
          "548:     guint                   offset = 0;",
          "549:     guint                   aux_header_offset = 0;",
          "550:     ws_decrypt_status       status;",
          "552:     proto_item              *ti;",
          "553:     proto_item              *mic_item = NULL;",
          "554:     proto_tree              *header_tree = NULL;",
          "555:     guint8                  security_suite;",
          "556:     guint                   aux_length = 0;",
          "557:     ieee802154_packet       *packet = (ieee802154_packet *)wmem_alloc(wmem_packet_scope(), sizeof(ieee802154_packet));",
          "558:     ieee802154_packet       *original_packet;",
          "559:     ieee802154_payload_info_t payload_info;",
          "560:     ieee802154_hints_t      *ieee_hints;",
          "561:     gboolean                mic_ok=TRUE;",
          "563:     unsigned char           rx_mic[16];",
          "564:     unsigned int            rx_mic_len = 0;",
          "566:     guint8                  cmd;",
          "567:     guint8                  tlv_type, tlv_len;",
          "568:     proto_tree              *tlv_tree;",
          "570:     col_set_str(pinfo->cinfo, COL_PROTOCOL, \"MLE\");",
          "571:     col_clear(pinfo->cinfo,   COL_INFO);",
          "573:     ieee_hints = (ieee802154_hints_t *)p_get_proto_data(wmem_file_scope(), pinfo, proto_ieee802154, 0);",
          "574:     original_packet = (ieee802154_packet *)ieee_hints->packet;",
          "577:     packet->src_addr_mode = original_packet->src_addr_mode;",
          "578:     if (packet->src_addr_mode == IEEE802154_FCF_ADDR_EXT) {",
          "579:         packet->src64 = original_packet->src64;",
          "580:     } else {",
          "581:         packet->src16 = original_packet->src16;",
          "582:     }",
          "585:     packet->src_pan = original_packet->src_pan;",
          "588:     proto_root = proto_tree_add_item(tree, proto_mle, tvb, 0, tvb_reported_length(tvb), ENC_NA);",
          "589:     mle_tree = proto_item_add_subtree(proto_root, ett_mle);",
          "593:     security_suite = tvb_get_guint8(tvb, offset);",
          "594:     proto_tree_add_item(mle_tree, hf_mle_security_suite, tvb, offset, 1, security_suite);",
          "595:     offset++;",
          "597:     aux_header_offset = offset;",
          "600:     if (security_suite == 0) {",
          "601:         dissect_ieee802154_aux_sec_header_and_key(tvb, pinfo, mle_tree, packet, &offset);",
          "602:         aux_length = offset-aux_header_offset;",
          "603:     } else {",
          "604:         packet->security_level = SECURITY_LEVEL_NONE;",
          "605:     }",
          "607:     payload_info.key_number = 0;",
          "610:     if (packet->security_level > SECURITY_LEVEL_NONE) {",
          "613:         payload_info.rx_mic = rx_mic;",
          "614:         payload_info.rx_mic_length = &rx_mic_len;",
          "615:         payload_info.aux_offset = aux_header_offset;",
          "616:         payload_info.aux_length = aux_length;",
          "617:         payload_info.status = &status;",
          "620:         payload_tvb = dissect_ieee802154_payload(tvb, offset, pinfo, header_tree, packet, &payload_info,",
          "621:                                      ieee802154_set_mle_key, dissect_mle_decrypt);",
          "622:         if (status == DECRYPT_PACKET_MIC_CHECK_FAILED)",
          "623:             expert_add_info(pinfo, proto_root, &ei_mle_cbc_mac_failed);",
          "626:         mic_item = NULL;",
          "627:         if (rx_mic_len) {",
          "628:             mic_item = proto_tree_add_bytes(header_tree, hf_mle_mic, tvb, 0, rx_mic_len, rx_mic);",
          "629:             PROTO_ITEM_SET_GENERATED(mic_item);",
          "630:         }",
          "631:     } else {",
          "632:         status = DECRYPT_NOT_ENCRYPTED;",
          "633:     }",
          "636:     if (!payload_tvb) {",
          "638:         gint reported_len = tvb_reported_length_remaining(tvb, offset);",
          "639:         gint captured_len = tvb_captured_length_remaining(tvb, offset);",
          "640:         if (reported_len < captured_len) captured_len = reported_len;",
          "641:         payload_tvb = tvb_new_subset_length_caplen(tvb, offset, captured_len, reported_len);",
          "642:     }",
          "645:     switch (status) {",
          "646:     case DECRYPT_PACKET_SUCCEEDED:",
          "648:         proto_item_append_text(mic_item, \" [correct (key no. %d)]\", payload_info.key_number);",
          "649:         break;",
          "651:     case DECRYPT_PACKET_TOO_SMALL:",
          "652:         expert_add_info(pinfo, proto_root, &ei_mle_packet_too_small);",
          "653:         call_data_dissector(payload_tvb, pinfo, tree);",
          "654:         return tvb_captured_length(tvb);",
          "656:     case DECRYPT_PACKET_NO_KEY:",
          "657:         expert_add_info(pinfo, proto_root, &ei_mle_no_key);",
          "658:         call_data_dissector(payload_tvb, pinfo, tree);",
          "659:         return tvb_captured_length(tvb);",
          "661:     case DECRYPT_PACKET_DECRYPT_FAILED:",
          "662:         expert_add_info(pinfo, proto_root, &ei_mle_decrypt_failed);",
          "663:         call_data_dissector(payload_tvb, pinfo, tree);",
          "664:         return tvb_captured_length(tvb);",
          "666:     case DECRYPT_PACKET_MIC_CHECK_FAILED:",
          "667:         expert_add_info(pinfo, proto_root, &ei_mle_mic_check_failed);",
          "668:         proto_item_append_text(mic_item, \" [incorrect]\");",
          "673:         if (IEEE802154_IS_ENCRYPTED(packet->security_level)) {",
          "674:             mic_ok = FALSE;",
          "675:         }",
          "676:         break;",
          "677:     case DECRYPT_NOT_ENCRYPTED:",
          "678:     default:",
          "679:         break;",
          "680:     }",
          "682:     if (!mic_ok && mle_mic_ok) {",
          "683:         call_data_dissector(payload_tvb, pinfo, tree);",
          "684:         col_add_fstr(pinfo->cinfo, COL_INFO, \"MIC Failed\");",
          "685:         return tvb_captured_length(tvb);",
          "686:     }",
          "690:     offset = 0;",
          "693:     proto_tree_add_item(mle_tree, hf_mle_command, payload_tvb, offset, 1, ENC_BIG_ENDIAN);",
          "695:     cmd = tvb_get_guint8(payload_tvb, offset);",
          "696:     col_add_str(pinfo->cinfo, COL_INFO, val_to_str(cmd, mle_command_vals, \"Unknown (%x)\"));",
          "698:     offset++;",
          "701:     while (tvb_offset_exists(payload_tvb, offset)) {",
          "705:         tlv_len = tvb_get_guint8(payload_tvb, offset+1);",
          "707:         ti = proto_tree_add_item(mle_tree, hf_mle_tlv, payload_tvb, offset, tlv_len+2, ENC_NA);",
          "708:         tlv_tree = proto_item_add_subtree(ti, ett_mle_tlv);",
          "711:         proto_tree_add_item(tlv_tree, hf_mle_tlv_type, payload_tvb, offset, 1, ENC_NA);",
          "712:         tlv_type = tvb_get_guint8(payload_tvb, offset);",
          "713:         offset++;",
          "716:         proto_item_append_text(ti, \" (%s\", val_to_str(tlv_type, mle_tlv_vals, \"Unknown (%d)\"));",
          "719:         proto_tree_add_item(tlv_tree, hf_mle_tlv_length, payload_tvb, offset, 1, ENC_BIG_ENDIAN);",
          "720:         offset++;",
          "722:         switch(tlv_type){",
          "723:             case MLE_TLV_SOURCE_ADDRESS:",
          "724:                 {",
          "725:                     gboolean haveShortTLV = FALSE;",
          "726:                     guint16 shortAddr = 0;",
          "728:                     if (!((tlv_len == 2) || (tlv_len == 8))) {",
          "730:                         expert_add_info(pinfo, proto_root, &ei_mle_tlv_length_failed);",
          "731:                         proto_tree_add_item(tlv_tree, hf_mle_tlv_unknown, payload_tvb, offset, tlv_len, ENC_NA);",
          "732:                         offset += tlv_len;",
          "733:                     } else {",
          "734:                         if (tlv_len == 2) {",
          "735:                             haveShortTLV = TRUE;",
          "736:                             shortAddr = tvb_get_ntohs(payload_tvb, offset);",
          "737:                         }",
          "739:                         proto_tree_add_item(tlv_tree, hf_mle_tlv_source_addr, payload_tvb, offset, tlv_len, ENC_NA);",
          "740:                         proto_item_append_text(ti, \" = \");",
          "741:                         while (tlv_len) {",
          "742:                             guint8 addr;",
          "743:                             addr = tvb_get_guint8(payload_tvb, offset);",
          "744:                             proto_item_append_text(ti, \"%02x\", addr);",
          "745:                             if (--tlv_len) {",
          "746:                                 proto_item_append_text(ti, \":\");",
          "747:                             }",
          "748:                             offset++;",
          "749:                         }",
          "750:                         if ((original_packet->src_addr_mode == IEEE802154_FCF_ADDR_EXT) && haveShortTLV) {",
          "752:                             ieee802154_addr_update(&ieee802154_map, shortAddr, original_packet->src_pan, original_packet->src64, pinfo->current_proto, pinfo->fd->num);",
          "753:                         }",
          "754:                     }",
          "755:                     proto_item_append_text(ti, \")\");",
          "756:                 }",
          "757:                 break;",
          "759:             case MLE_TLV_MODE:",
          "760:                 if (tlv_len == 1) {",
          "761:                     guint8 capability;",
          "763:                     capability = tvb_get_guint8(payload_tvb, offset);",
          "764:                     proto_item_append_text(ti, \" = %02x)\", capability);",
          "766:                     proto_tree_add_item(tlv_tree, hf_mle_tlv_mode_nwk_data, payload_tvb, offset, 1, ENC_BIG_ENDIAN);",
          "767:                     proto_tree_add_item(tlv_tree, hf_mle_tlv_mode_device_type, payload_tvb, offset, 1, ENC_BIG_ENDIAN);",
          "768:                     proto_tree_add_item(tlv_tree, hf_mle_tlv_mode_sec_data_req, payload_tvb, offset, 1, ENC_BIG_ENDIAN);",
          "769:                     proto_tree_add_item(tlv_tree, hf_mle_tlv_mode_idle_rx, payload_tvb, offset, 1, ENC_BIG_ENDIAN);",
          "770:                 }",
          "771:                 else {",
          "773:                     expert_add_info(pinfo, proto_root, &ei_mle_tlv_length_failed);",
          "774:                     proto_tree_add_item(tlv_tree, hf_mle_tlv_unknown, payload_tvb, offset, tlv_len, ENC_NA);",
          "775:                 }",
          "776:                 offset += tlv_len;",
          "777:                 break;",
          "779:             case MLE_TLV_TIMEOUT:",
          "780:                 if (tlv_len != 4) {",
          "782:                     expert_add_info(pinfo, proto_root, &ei_mle_tlv_length_failed);",
          "783:                     proto_tree_add_item(tlv_tree, hf_mle_tlv_unknown, payload_tvb, offset, tlv_len, ENC_NA);",
          "784:                 } else {",
          "785:                     guint32 to_data = 0;",
          "786:                     proto_tree_add_item_ret_uint(tlv_tree, hf_mle_tlv_timeout, payload_tvb, offset, 4, ENC_BIG_ENDIAN, &to_data);",
          "787:                     proto_item_append_text(ti, \" = %d\", (guint16)to_data);",
          "788:                 }",
          "789:                 proto_item_append_text(ti, \")\");",
          "790:                 offset += tlv_len;",
          "791:                 break;",
          "793:             case MLE_TLV_CHALLENGE:",
          "794:                 proto_tree_add_item(tlv_tree, hf_mle_tlv_challenge, payload_tvb, offset, tlv_len, ENC_NA);",
          "795:                 proto_item_append_text(ti, \" = %s)\", tvb_bytes_to_str(wmem_packet_scope(), tvb, offset, tlv_len));",
          "796:                 offset += tlv_len;",
          "797:                 break;",
          "799:             case MLE_TLV_RESPONSE:",
          "800:                 proto_tree_add_item(tlv_tree, hf_mle_tlv_response, payload_tvb, offset, tlv_len, ENC_NA);",
          "801:                 proto_item_append_text(ti, \" = %s)\", tvb_bytes_to_str(wmem_packet_scope(), tvb, offset, tlv_len));",
          "802:                 offset += tlv_len;",
          "803:                 break;",
          "805:             case MLE_TLV_LINK_LAYER_FRAME_COUNTER:",
          "806:             case MLE_TLV_MLE_FRAME_COUNTER:",
          "807:                 if (tlv_len != 4) {",
          "809:                     expert_add_info(pinfo, proto_root, &ei_mle_tlv_length_failed);",
          "810:                     proto_tree_add_item(tlv_tree, hf_mle_tlv_unknown, payload_tvb, offset, tlv_len, ENC_NA);",
          "811:                 } else {",
          "812:                     guint32 cntr;",
          "814:                     if (tlv_type == MLE_TLV_LINK_LAYER_FRAME_COUNTER) {",
          "815:                         proto_tree_add_item_ret_uint(tlv_tree, hf_mle_tlv_ll_frm_cntr, payload_tvb, offset, tlv_len, ENC_BIG_ENDIAN, &cntr);",
          "816:                     } else {",
          "817:                         proto_tree_add_item_ret_uint(tlv_tree, hf_mle_tlv_mle_frm_cntr, payload_tvb, offset, tlv_len, ENC_BIG_ENDIAN, &cntr);",
          "818:                     }",
          "819:                     proto_item_append_text(ti, \" = %u\", cntr);",
          "820:                 }",
          "821:                 proto_item_append_text(ti, \")\");",
          "822:                 offset += tlv_len;",
          "823:                 break;",
          "825:             case MLE_TLV_LINK_QUALITY:",
          "826:                 {",
          "827:                     guint numNeighbors;",
          "828:                     guint8 size = tvb_get_guint8(payload_tvb, offset) & LQI_FLAGS_SIZE;",
          "829:                     proto_tree *neig_tree;",
          "830:                     proto_tree_add_item(tlv_tree, hf_mle_tlv_lqi_c, payload_tvb, offset, 1, ENC_BIG_ENDIAN);",
          "831:                     proto_tree_add_item(tlv_tree, hf_mle_tlv_lqi_size, payload_tvb, offset, 1, ENC_BIG_ENDIAN);",
          "832:                     offset++;",
          "834:                     if ((tlv_len - 1) % (size + 3)) {",
          "835:                         expert_add_info(pinfo, proto_root, &ei_mle_len_size_mismatch);",
          "836:                         proto_tree_add_item(tlv_tree, hf_mle_tlv_unknown, payload_tvb, offset, tlv_len, ENC_NA);",
          "837:                         numNeighbors = 0;",
          "838:                     } else {",
          "839:                         numNeighbors = (tlv_len - 1) / (size + 3);",
          "840:                     }",
          "842:                     if (numNeighbors == 0) {",
          "843:                         proto_item_append_text(ti, \")\");",
          "844:                     } else if (numNeighbors == 1) {",
          "845:                         proto_item_append_text(ti, \": 1 Neighbor)\");",
          "846:                     } else {",
          "847:                         proto_item_append_text(ti, \": %d Neighbors)\", numNeighbors);",
          "848:                     }",
          "853:                     size++;",
          "855:                     while (numNeighbors) {",
          "856:                         ti = proto_tree_add_item(tlv_tree, hf_mle_tlv_neighbor, payload_tvb, offset, size+2, ENC_NA);",
          "857:                         neig_tree = proto_item_add_subtree(ti, ett_mle_neighbor);",
          "859:                         proto_tree_add_item(neig_tree, hf_mle_tlv_neighbor_flagI, payload_tvb, offset, 1, ENC_BIG_ENDIAN);",
          "860:                         proto_tree_add_item(neig_tree, hf_mle_tlv_neighbor_flagO, payload_tvb, offset, 1, ENC_BIG_ENDIAN);",
          "861:                         proto_tree_add_item(neig_tree, hf_mle_tlv_neighbor_flagP, payload_tvb, offset, 1, ENC_BIG_ENDIAN);",
          "862:                         offset++;",
          "864:                         proto_tree_add_item(neig_tree, hf_mle_tlv_neighbor_idr, payload_tvb, offset, 1, ENC_BIG_ENDIAN);",
          "865:                         offset++;",
          "867:                         proto_tree_add_item(neig_tree, hf_mle_tlv_neighbor_addr, payload_tvb, offset,size, ENC_NA);",
          "868:                         offset += size;",
          "870:                         numNeighbors--;",
          "871:                     }",
          "872:                 }",
          "873:                 break;",
          "875:             case MLE_TLV_NETWORK_PARAMETER:",
          "876:                 {",
          "877:                     guint8 param_id = tvb_get_guint8(payload_tvb, offset);",
          "879:                     proto_item_append_text(ti, \" = %s)\", val_to_str(param_id, mle_tlv_nwk_param_vals, \"Unknown (%d)\"));",
          "881:                     proto_tree_add_item(tlv_tree, hf_mle_tlv_network_param_id, payload_tvb, offset, 1, ENC_BIG_ENDIAN);",
          "882:                     offset++;",
          "883:                     proto_tree_add_item(tlv_tree, hf_mle_tlv_network_delay, payload_tvb, offset, 4, ENC_BIG_ENDIAN);",
          "884:                     offset += 4;",
          "886:                     switch (param_id) {",
          "887:                     case NETWORK_PARAM_ID_CHANNEL:",
          "888:                         proto_tree_add_item(tlv_tree, hf_mle_tlv_network_channel, payload_tvb, offset, 2, ENC_BIG_ENDIAN);",
          "889:                         offset += 2;",
          "890:                         break;",
          "891:                     case NETWORK_PARAM_ID_PAN_ID:",
          "892:                         proto_tree_add_item(tlv_tree, hf_mle_tlv_network_pan_id, payload_tvb, offset, 2, ENC_BIG_ENDIAN);",
          "893:                         offset += 2;",
          "894:                         break;",
          "895:                     case NETWORK_PARAM_ID_PERMIT_JOIN:",
          "896:                         proto_tree_add_item(tlv_tree, hf_mle_tlv_network_pmt_join, payload_tvb, offset, 1, ENC_BIG_ENDIAN);",
          "897:                         offset++;",
          "898:                         break;",
          "899:                     case NETWORK_PARAM_ID_BCN_PAYLOAD:",
          "900:                         proto_tree_add_item(tlv_tree, hf_mle_tlv_network_bcn_payload, payload_tvb, offset, tlv_len-5, ENC_NA);",
          "901:                         offset += tlv_len-5;",
          "902:                         break;",
          "903:                     default:",
          "904:                         proto_tree_add_item(tlv_tree, hf_mle_tlv_network_unknown, payload_tvb, offset, tlv_len-5, ENC_NA);",
          "905:                         offset += tlv_len-5;",
          "906:                         break;",
          "907:                     }",
          "908:                 }",
          "909:                 break;",
          "911:             case MLE_TLV_ROUTE64:",
          "912:                 {",
          "913:                     proto_tree *rtr_tree;",
          "914:                     guint i, j;",
          "915:                     guint8 count;",
          "916:                     guint64 id_mask, test_mask;",
          "918:                     proto_item_append_text(ti, \")\");",
          "919:                     proto_tree_add_item(tlv_tree, hf_mle_tlv_route64_id_seq, payload_tvb, offset, 1, ENC_BIG_ENDIAN);",
          "920:                     offset++;",
          "923:                     count = 0;",
          "925:                         guint8 id_mask_octet = tvb_get_guint8(payload_tvb, offset + i);",
          "926:                         for (j = 0; j < 8; j++) {",
          "927:                             if (id_mask_octet & (1 << j)) {",
          "928:                                 count++;",
          "929:                             }",
          "930:                         }",
          "931:                     }",
          "943:                     id_mask = tvb_get_ntoh64(payload_tvb, offset);",
          "946:                     proto_tree_add_item(tlv_tree, hf_mle_tlv_route64_id_mask, payload_tvb, offset, 8, ENC_NA);",
          "947:                     offset += 8;",
          "949:                     if (count != (tlv_len - 9))",
          "950:                     {",
          "951:                         expert_add_info(pinfo, proto_root, &ei_mle_tlv_length_failed);",
          "952:                         proto_tree_add_item(tlv_tree, hf_mle_tlv_unknown, payload_tvb, offset, tlv_len, ENC_NA);",
          "953:                         offset += (tlv_len - 9);",
          "954:                     } else {",
          "956:                         for (i = 0; i < count; i++) {",
          "958:                             for (j = 0, test_mask = (G_GUINT64_CONSTANT(1) << 63); test_mask != 1; test_mask >>= 1, j++) {",
          "959:                                 if (test_mask & id_mask) {",
          "960:                                     id_mask &= ~test_mask;",
          "961:                                     break;",
          "962:                                 }",
          "963:                             }",
          "964:                             ti = proto_tree_add_item(tlv_tree, hf_mle_tlv_route64_entry, payload_tvb, offset, 1, ENC_BIG_ENDIAN);",
          "965:                             proto_item_append_text(ti, \" (%d)\", j);",
          "966:                             rtr_tree = proto_item_add_subtree(ti, ett_mle_router);",
          "968:                             proto_tree_add_item(rtr_tree, hf_mle_tlv_route64_nbr_out, payload_tvb, offset, 1, ENC_BIG_ENDIAN);",
          "969:                             proto_tree_add_item(rtr_tree, hf_mle_tlv_route64_nbr_in, payload_tvb, offset, 1, ENC_BIG_ENDIAN);",
          "970:                             proto_tree_add_item(rtr_tree, hf_mle_tlv_route64_cost, payload_tvb, offset, 1, ENC_BIG_ENDIAN);",
          "971:                             offset++;",
          "972:                         }",
          "973:                     }",
          "974:                 }",
          "975:                 break;",
          "977:             case MLE_TLV_ADDRESS16:",
          "978:                 if (tlv_len != 2) {",
          "980:                     expert_add_info(pinfo, proto_root, &ei_mle_tlv_length_failed);",
          "981:                     proto_tree_add_item(tlv_tree, hf_mle_tlv_unknown, payload_tvb, offset, tlv_len, ENC_NA);",
          "982:                 } else {",
          "983:                     guint16 addr16 = tvb_get_ntohs(payload_tvb, offset);",
          "984:                     proto_item_append_text(ti, \" = \");",
          "985:                     {",
          "987:                         guint stroffset = offset;",
          "989:                         while (a16_len) {",
          "990:                             guint8 a16_data;",
          "991:                             a16_data = tvb_get_guint8(payload_tvb, stroffset);",
          "992:                             proto_item_append_text(ti, \"%02x\", a16_data);",
          "993:                             if (--a16_len) {",
          "994:                                 proto_item_append_text(ti, \":\");",
          "995:                             }",
          "996:                             stroffset++;",
          "997:                         }",
          "998:                     }",
          "999:                     proto_tree_add_item(tlv_tree, hf_mle_tlv_addr16, payload_tvb, offset, 2, ENC_NA);",
          "1000:                     if (original_packet->dst_addr_mode == IEEE802154_FCF_ADDR_EXT) {",
          "1002:                         ieee802154_addr_update(&ieee802154_map, addr16, original_packet->dst_pan, original_packet->dst64, pinfo->current_proto, pinfo->fd->num);",
          "1003:                     }",
          "1004:                 }",
          "1005:                 proto_item_append_text(ti, \")\");",
          "1006:                 offset += tlv_len;",
          "1007:                 break;",
          "1009:             case MLE_TLV_LEADER_DATA:",
          "1010:                 proto_item_append_text(ti, \")\");",
          "1011:                 if (tlv_len != 8) {",
          "1013:                     expert_add_info(pinfo, proto_root, &ei_mle_tlv_length_failed);",
          "1014:                     proto_tree_add_item(tlv_tree, hf_mle_tlv_unknown, payload_tvb, offset, tlv_len, ENC_NA);",
          "1015:                     offset += tlv_len;",
          "1016:                 } else {",
          "1017:                     proto_tree_add_item(tlv_tree, hf_mle_tlv_leader_data_partition_id, payload_tvb, offset, 4, ENC_BIG_ENDIAN);",
          "1018:                     offset += 4;",
          "1019:                     proto_tree_add_item(tlv_tree, hf_mle_tlv_leader_data_weighting, payload_tvb, offset, 1, ENC_BIG_ENDIAN);",
          "1020:                     offset++;",
          "1021:                     proto_tree_add_item(tlv_tree, hf_mle_tlv_leader_data_version, payload_tvb, offset, 1, ENC_BIG_ENDIAN);",
          "1022:                     offset++;",
          "1023:                     proto_tree_add_item(tlv_tree, hf_mle_tlv_leader_data_stable_version, payload_tvb, offset, 1, ENC_BIG_ENDIAN);",
          "1024:                     offset++;",
          "1025:                     proto_tree_add_item(tlv_tree, hf_mle_tlv_leader_data_router_id, payload_tvb, offset, 1, ENC_BIG_ENDIAN);",
          "1026:                     offset++;",
          "1027:                 }",
          "1028:                 break;",
          "1030:             case MLE_TLV_NETWORK_DATA:",
          "1031:                 {",
          "1032:                     tvbuff_t *sub_tvb;",
          "1033:                     proto_item_append_text(ti, \")\");",
          "1034:                     if (tlv_len > 0) {",
          "1035:                         sub_tvb = tvb_new_subset_length(payload_tvb, offset, tlv_len);",
          "1036:                         call_dissector(thread_nwd_handle, sub_tvb, pinfo, tlv_tree);",
          "1037:                     }",
          "1038:                     offset += tlv_len;",
          "1039:                 }",
          "1040:                 break;",
          "1042:             case MLE_TLV_ACTIVE_OP_DATASET:",
          "1043:             case MLE_TLV_PENDING_OP_DATASET:",
          "1044:             case MLE_TLV_THREAD_DISCOVERY:",
          "1045:                 {",
          "1046:                     tvbuff_t *sub_tvb;",
          "1047:                     proto_item_append_text(ti, \")\");",
          "1048:                     if (tlv_len > 0) {",
          "1049:                         sub_tvb = tvb_new_subset_length(payload_tvb, offset, tlv_len);",
          "1050:                         call_dissector(thread_mc_handle, sub_tvb, pinfo, tlv_tree);",
          "1051:                     }",
          "1052:                     offset += tlv_len;",
          "1053:                 }",
          "1054:                 break;",
          "1056:             case MLE_TLV_TLV_REQUEST:",
          "1057:                 proto_item_append_text(ti, \")\");",
          "1058:                 while (tlv_len) {",
          "1059:                     proto_tree_add_item(tlv_tree, hf_mle_tlv_type, payload_tvb, offset, 1, ENC_NA);",
          "1060:                     offset++;",
          "1061:                     tlv_len--;",
          "1062:                 }",
          "1063:                 break;",
          "1065:             case MLE_TLV_SCAN_MASK:",
          "1066:                 if (tlv_len != 1) {",
          "1068:                     proto_item_append_text(ti, \")\");",
          "1069:                     expert_add_info(pinfo, proto_root, &ei_mle_tlv_length_failed);",
          "1070:                     proto_tree_add_item(tlv_tree, hf_mle_tlv_unknown, payload_tvb, offset, tlv_len, ENC_NA);",
          "1071:                 } else {",
          "1072:                     guint8 mask;",
          "1074:                     mask = tvb_get_guint8(payload_tvb, offset);",
          "1075:                     proto_item_append_text(ti, \" = %02x)\", mask);",
          "1076:                     proto_tree_add_item(tlv_tree, hf_mle_tlv_scan_mask_r, payload_tvb, offset, 1, ENC_BIG_ENDIAN);",
          "1077:                     proto_tree_add_item(tlv_tree, hf_mle_tlv_scan_mask_e, payload_tvb, offset, 1, ENC_BIG_ENDIAN);",
          "1078:                 }",
          "1079:                 offset += tlv_len;",
          "1080:                 break;",
          "1082:             case MLE_TLV_CONNECTIVITY:",
          "1083:                 if (tlv_len == 7) {",
          "1085:                     proto_tree_add_item(tlv_tree, hf_mle_tlv_conn_max_child_cnt, payload_tvb, offset, 1, ENC_BIG_ENDIAN);",
          "1086:                     offset++;",
          "1087:                     proto_tree_add_item(tlv_tree, hf_mle_tlv_conn_child_cnt, payload_tvb, offset, 1, ENC_BIG_ENDIAN);",
          "1088:                     offset++;",
          "1089:                     proto_tree_add_item(tlv_tree, hf_mle_tlv_conn_lq3, payload_tvb, offset, 1, ENC_BIG_ENDIAN);",
          "1090:                     offset++;",
          "1091:                     proto_tree_add_item(tlv_tree, hf_mle_tlv_conn_lq2, payload_tvb, offset, 1, ENC_BIG_ENDIAN);",
          "1092:                     offset++;",
          "1093:                     proto_tree_add_item(tlv_tree, hf_mle_tlv_conn_lq1, payload_tvb, offset, 1, ENC_BIG_ENDIAN);",
          "1094:                     offset++;",
          "1095:                     proto_tree_add_item(tlv_tree, hf_mle_tlv_conn_leader_cost, payload_tvb, offset, 1, ENC_BIG_ENDIAN);",
          "1096:                     offset++;",
          "1097:                     proto_tree_add_item(tlv_tree, hf_mle_tlv_conn_id_seq, payload_tvb, offset, 1, ENC_BIG_ENDIAN);",
          "1098:                     offset++;",
          "1099:                 } else if (tlv_len == 10) {",
          "1101:                     proto_tree *fl_tree;",
          "1103:                     ti = proto_tree_add_item(tlv_tree, hf_mle_tlv_conn_flags, payload_tvb, offset, 1, ENC_NA);",
          "1104:                     fl_tree = proto_item_add_subtree(ti, ett_mle_conn_flg);",
          "1105:                     proto_tree_add_item(fl_tree, hf_mle_tlv_conn_flags_pp, payload_tvb, offset, 1, ENC_BIG_ENDIAN);",
          "1106:                     offset++;",
          "1107:                     proto_tree_add_item(tlv_tree, hf_mle_tlv_conn_lq3, payload_tvb, offset, 1, ENC_BIG_ENDIAN);",
          "1108:                     offset++;",
          "1109:                     proto_tree_add_item(tlv_tree, hf_mle_tlv_conn_lq2, payload_tvb, offset, 1, ENC_BIG_ENDIAN);",
          "1110:                     offset++;",
          "1111:                     proto_tree_add_item(tlv_tree, hf_mle_tlv_conn_lq1, payload_tvb, offset, 1, ENC_BIG_ENDIAN);",
          "1112:                     offset++;",
          "1113:                     proto_tree_add_item(tlv_tree, hf_mle_tlv_conn_leader_cost, payload_tvb, offset, 1, ENC_BIG_ENDIAN);",
          "1114:                     offset++;",
          "1115:                     proto_tree_add_item(tlv_tree, hf_mle_tlv_conn_id_seq, payload_tvb, offset, 1, ENC_BIG_ENDIAN);",
          "1116:                     offset++;",
          "1117:                     proto_tree_add_item(tlv_tree, hf_mle_tlv_conn_active_rtrs, payload_tvb, offset, 1, ENC_BIG_ENDIAN);",
          "1118:                     offset++;",
          "1119:                     proto_tree_add_item(tlv_tree, hf_mle_tlv_conn_sed_buf_size, payload_tvb, offset, 2, ENC_BIG_ENDIAN);",
          "1120:                     offset += 2;",
          "1121:                     proto_tree_add_item(tlv_tree, hf_mle_tlv_conn_sed_dgram_cnt, payload_tvb, offset, 1, ENC_BIG_ENDIAN);",
          "1122:                     offset++;",
          "1123:                 } else {",
          "1125:                     expert_add_info(pinfo, proto_root, &ei_mle_tlv_length_failed);",
          "1126:                     proto_tree_add_item(tlv_tree, hf_mle_tlv_unknown, payload_tvb, offset, tlv_len, ENC_NA);",
          "1127:                     offset += tlv_len;",
          "1128:                 }",
          "1129:                 proto_item_append_text(ti, \")\");",
          "1130:                 break;",
          "1132:             case MLE_TLV_LINK_MARGIN:",
          "1133:                 if (tlv_len != 1) {",
          "1135:                     proto_item_append_text(ti, \")\");",
          "1136:                     expert_add_info(pinfo, proto_root, &ei_mle_tlv_length_failed);",
          "1137:                     proto_tree_add_item(tlv_tree, hf_mle_tlv_unknown, payload_tvb, offset, tlv_len, ENC_NA);",
          "1138:                 } else {",
          "1139:                     guint8 link_margin;",
          "1141:                     link_margin = tvb_get_guint8(payload_tvb, offset);",
          "1142:                     proto_item_append_text(ti, \" = %udB)\", link_margin);",
          "1143:                     proto_tree_add_item(tlv_tree, hf_mle_tlv_link_margin, payload_tvb, offset, tlv_len, ENC_BIG_ENDIAN);",
          "1144:                 }",
          "1145:                 offset += tlv_len;",
          "1146:                 break;",
          "1148:             case MLE_TLV_STATUS:",
          "1149:                 if (tlv_len != 1) {",
          "1151:                     proto_item_append_text(ti, \")\");",
          "1152:                     expert_add_info(pinfo, proto_root, &ei_mle_tlv_length_failed);",
          "1153:                     proto_tree_add_item(tlv_tree, hf_mle_tlv_unknown, payload_tvb, offset, tlv_len, ENC_NA);",
          "1154:                 } else {",
          "1155:                     guint8 stat;",
          "1157:                     stat = tvb_get_guint8(payload_tvb, offset);",
          "1158:                     proto_item_append_text(ti, \" = %d)\", stat);",
          "1159:                     proto_tree_add_item(tlv_tree, hf_mle_tlv_status, payload_tvb, offset, tlv_len, ENC_BIG_ENDIAN);",
          "1160:                 }",
          "1161:                 offset += tlv_len;",
          "1162:                 break;",
          "1164:             case MLE_TLV_VERSION:",
          "1165:                 if (tlv_len != 2) {",
          "1167:                     proto_item_append_text(ti, \")\");",
          "1168:                     expert_add_info(pinfo, proto_root, &ei_mle_tlv_length_failed);",
          "1169:                     proto_tree_add_item(tlv_tree, hf_mle_tlv_unknown, payload_tvb, offset, tlv_len, ENC_NA);",
          "1170:                 } else {",
          "1171:                     guint16 version;",
          "1173:                     version = tvb_get_ntohs(payload_tvb, offset);",
          "1174:                     proto_item_append_text(ti, \" = %d)\", version);",
          "1175:                     proto_tree_add_item(tlv_tree, hf_mle_tlv_version, payload_tvb, offset, tlv_len, ENC_BIG_ENDIAN);",
          "1176:                 }",
          "1177:                 offset += tlv_len;",
          "1178:                 break;",
          "1180:             case MLE_TLV_ADDRESS_REGISTRATION:",
          "1181:                 {",
          "1182:                     guint8 iid_type, i;",
          "1183:                     guint8 entries = 0;",
          "1184:                     guint8 check_len = tlv_len;",
          "1185:                     guint8 check_offset = offset;",
          "1188:                     while (check_len > 0) {",
          "1189:                         guint8 ar_len;",
          "1191:                         iid_type = tvb_get_guint8(payload_tvb, check_offset);",
          "1192:                         if (iid_type & ADDR_REG_MASK_IID_TYPE_MASK) {",
          "1193:                             ar_len = 9;",
          "1194:                         } else {",
          "1195:                             ar_len = 17;",
          "1196:                         }",
          "1197:                         check_offset += ar_len;",
          "1198:                         check_len -= ar_len;",
          "1199:                         entries++;",
          "1200:                     }",
          "1202:                     proto_item_append_text(ti, \")\");",
          "1203:                     if (check_len != 0) {",
          "1205:                         expert_add_info(pinfo, proto_root, &ei_mle_tlv_length_failed);",
          "1206:                         proto_tree_add_item(tlv_tree, hf_mle_tlv_unknown, payload_tvb, offset, tlv_len, ENC_NA);",
          "1207:                         offset += tlv_len;",
          "1208:                     } else {",
          "1209:                         for (i = 0; i < entries; i++) {",
          "1210:                             proto_tree *ar_tree;",
          "1212:                             ti = proto_tree_add_item(tlv_tree, hf_mle_tlv_addr_reg_entry, payload_tvb, offset, 1, ENC_NA);",
          "1213:                             ar_tree = proto_item_add_subtree(ti, ett_mle_addr_reg);",
          "1214:                             iid_type = tvb_get_guint8(payload_tvb, offset);",
          "1215:                             if (iid_type & ADDR_REG_MASK_IID_TYPE_MASK) {",
          "1216:                                 proto_tree_add_item(ar_tree, hf_mle_tlv_addr_reg_iid_type, payload_tvb, offset, 1, ENC_BIG_ENDIAN);",
          "1217:                                 proto_tree_add_item(ar_tree, hf_mle_tlv_addr_reg_cid, payload_tvb, offset, 1, ENC_BIG_ENDIAN);",
          "1218:                                 offset++;",
          "1219:                                 proto_tree_add_item(ar_tree, hf_mle_tlv_addr_reg_iid, payload_tvb, offset, 8, ENC_NA);",
          "1220:                                 offset += 8;",
          "1221:                             } else {",
          "1222:                                 proto_tree_add_item(ar_tree, hf_mle_tlv_addr_reg_iid_type, payload_tvb, offset, 1, ENC_BIG_ENDIAN);",
          "1223:                                 offset++;",
          "1224:                                 proto_tree_add_item(ar_tree, hf_mle_tlv_addr_reg_ipv6, payload_tvb, offset, 16, ENC_NA);",
          "1225:                                 offset += 16;",
          "1226:                             }",
          "1227:                         }",
          "1228:                     }",
          "1229:                 }",
          "1230:                 break;",
          "1232:             case MLE_TLV_CHANNEL:",
          "1233:                 {",
          "1234:                     proto_item_append_text(ti, \")\");",
          "1237:                     if (tlv_len != 3) {",
          "1238:                         expert_add_info(pinfo, proto_root, &ei_mle_tlv_length_failed);",
          "1239:                         proto_tree_add_item(tlv_tree, hf_mle_tlv_unknown, payload_tvb, offset, tlv_len, ENC_NA);",
          "1240:                     } else {",
          "1242:                         proto_tree_add_item(tlv_tree, hf_mle_tlv_channel_page, payload_tvb, offset, 1, ENC_BIG_ENDIAN);",
          "1244:                         proto_tree_add_item(tlv_tree, hf_mle_tlv_channel, payload_tvb, offset+1, 2, ENC_BIG_ENDIAN);",
          "1245:                     }",
          "1246:                     offset += tlv_len;",
          "1247:                 }",
          "1248:                 break;",
          "1250:             case MLE_TLV_PAN_ID:",
          "1251:                 {",
          "1252:                     proto_item_append_text(ti, \")\");",
          "1255:                     if (tlv_len != 2) {",
          "1256:                         expert_add_info(pinfo, proto_root, &ei_mle_tlv_length_failed);",
          "1257:                         proto_tree_add_item(tlv_tree, hf_mle_tlv_unknown, payload_tvb, offset, tlv_len, ENC_NA);",
          "1258:                     } else {",
          "1260:                         proto_tree_add_item(tlv_tree, hf_mle_tlv_pan_id, payload_tvb, offset, tlv_len, ENC_BIG_ENDIAN);",
          "1261:                     }",
          "1262:                     offset += tlv_len;",
          "1263:                 }",
          "1264:                 break;",
          "1266:             case MLE_TLV_ACTIVE_TSTAMP:",
          "1267:             case MLE_TLV_PENDING_TSTAMP:",
          "1268:                 {",
          "1269:                     nstime_t timestamp;",
          "1271:                     proto_item_append_text(ti, \")\");",
          "1273:                     if (tlv_len != 8) {",
          "1274:                         expert_add_info(pinfo, proto_root, &ei_mle_tlv_length_failed);",
          "1275:                         proto_tree_add_item(tlv_tree, hf_mle_tlv_unknown, payload_tvb, offset, tlv_len, ENC_NA);",
          "1276:                     } else {",
          "1278:                         timestamp.secs = (time_t)tvb_get_ntoh48(payload_tvb, offset);",
          "1279:                         timestamp.nsecs = (int)lround((double)(tvb_get_ntohs(payload_tvb, offset + 6) >> 1) * MLE_32768_TO_NSEC_FACTOR);",
          "1280:                         if (tlv_type == MLE_TLV_ACTIVE_TSTAMP) {",
          "1281:                             proto_tree_add_time(tlv_tree, hf_mle_tlv_active_tstamp, payload_tvb, offset, 8, &timestamp);",
          "1282:                         } else {",
          "1283:                             proto_tree_add_time(tlv_tree, hf_mle_tlv_pending_tstamp, payload_tvb, offset, 8, &timestamp);",
          "1284:                         }",
          "1285:                     }",
          "1286:                     offset += tlv_len;",
          "1287:                 }",
          "1288:                 break;",
          "1290:             default:",
          "1291:                 proto_item_append_text(ti, \")\");",
          "1292:                 proto_tree_add_item(tlv_tree, hf_mle_tlv_unknown, payload_tvb, offset, tlv_len, ENC_NA);",
          "1293:                 offset += tlv_len;",
          "1294:         }",
          "1295:     }",
          "1297:     return tvb_captured_length(tvb);",
          "1298: }",
          "1300: void",
          "1301: proto_register_mle(void)",
          "1302: {",
          "1303:   static hf_register_info hf[] = {",
          "1307:     { &hf_mle_security_suite,",
          "1308:       { \"Security Suite\",",
          "1309:         \"wpan.aux_sec.sec_suite\",",
          "1310:         FT_UINT8, BASE_HEX, VALS(mle_sec_suite_names), 0x0,",
          "1311:         \"The Security Suite of the frame\",",
          "1312:         HFILL",
          "1313:       }",
          "1314:     },",
          "1316:     { &hf_mle_mic,",
          "1317:       { \"Decrypted MIC\",",
          "1318:         \"mle.mic\",",
          "1319:         FT_BYTES, BASE_NONE, NULL, 0x0,",
          "1320:         \"The decrypted MIC\",",
          "1321:         HFILL",
          "1322:       }",
          "1323:     },",
          "1326:     { &hf_mle_command,",
          "1327:       { \"Command\",",
          "1328:         \"mle.cmd\",",
          "1329:         FT_UINT8, BASE_DEC, VALS(mle_command_vals), 0x0,",
          "1330:         \"MLE command type\",",
          "1331:         HFILL",
          "1332:       }",
          "1333:     },",
          "1336:     { &hf_mle_tlv,",
          "1337:       { \"TLV\",",
          "1338:         \"mle.tlv\",",
          "1339:         FT_NONE, BASE_NONE, NULL, 0x0,",
          "1340:         \"Type-Length-Value\",",
          "1341:         HFILL",
          "1342:       }",
          "1343:     },",
          "1345:     { &hf_mle_tlv_type,",
          "1346:       { \"Type\",",
          "1347:         \"mle.tlv.type\",",
          "1348:         FT_UINT8, BASE_DEC, VALS(mle_tlv_vals), 0x0,",
          "1349:         \"Type of value\",",
          "1350:         HFILL",
          "1351:       }",
          "1352:     },",
          "1354:     { &hf_mle_tlv_length,",
          "1355:       { \"Length\",",
          "1356:         \"mle.tlv.len\",",
          "1357:         FT_UINT8, BASE_DEC, NULL, 0x0,",
          "1358:         \"Length of value\",",
          "1359:         HFILL",
          "1360:       }",
          "1361:     },",
          "1364:     { &hf_mle_tlv_source_addr,",
          "1365:       { \"Address\",",
          "1366:         \"mle.tlv.source_addr\",",
          "1367:         FT_BYTES, BASE_NONE, NULL, 0x0,",
          "1368:         \"Source address\",",
          "1369:         HFILL",
          "1370:       }",
          "1371:     },",
          "1374:     { &hf_mle_tlv_mode_nwk_data,",
          "1375:       { \"Network Data\",",
          "1376:         \"mle.tlv.mode.nwk_data\",",
          "1377:         FT_BOOLEAN, 8, TFS(&mle_tlv_mode_nwk_data), MLE_CMD_CINFO_NWK_DATA,",
          "1378:         NULL,",
          "1379:         HFILL",
          "1380:       }",
          "1381:     },",
          "1383:     { &hf_mle_tlv_mode_device_type,",
          "1384:       { \"Device Type\",",
          "1385:         \"mle.tlv.mode.device_type\",",
          "1386:         FT_BOOLEAN, 8, TFS(&mle_tlv_mode_device_type), IEEE802154_CMD_CINFO_DEVICE_TYPE,",
          "1387:         NULL,",
          "1388:         HFILL",
          "1389:       }",
          "1390:     },",
          "1392:     { &hf_mle_tlv_mode_sec_data_req,",
          "1393:       { \"Secure Data Requests\",",
          "1394:         \"mle.tlv.mode.sec_data_req\",",
          "1395:         FT_BOOLEAN, 8, NULL, MLE_CMD_CINFO_SEC_DATA_REQ,",
          "1396:         NULL,",
          "1397:         HFILL",
          "1398:       }",
          "1399:     },",
          "1401:     { &hf_mle_tlv_mode_idle_rx,",
          "1402:       { \"Receive On When Idle\",",
          "1403:         \"mle.tlv.mode.idle_rx\",",
          "1404:         FT_BOOLEAN, 8, NULL, IEEE802154_CMD_CINFO_IDLE_RX,",
          "1405:         NULL,",
          "1406:         HFILL",
          "1407:       }",
          "1408:     },",
          "1410:     { &hf_mle_tlv_timeout,",
          "1411:       { \"Timeout\",",
          "1412:         \"mle.tlv.timeout\",",
          "1413:         FT_UINT32, BASE_DEC, NULL, 0x0,",
          "1414:         \"Expected interval between transmissions in seconds\",",
          "1415:         HFILL",
          "1416:       }",
          "1417:     },",
          "1419:     { &hf_mle_tlv_challenge,",
          "1420:       { \"Challenge\",",
          "1421:         \"mle.tlv.challenge\",",
          "1422:         FT_BYTES, BASE_NONE, NULL, 0x0,",
          "1423:         \"Challenge to be echoed back\",",
          "1424:         HFILL",
          "1425:       }",
          "1426:     },",
          "1428:     { &hf_mle_tlv_response,",
          "1429:       { \"Response\",",
          "1430:         \"mle.tlv.response\",",
          "1431:         FT_BYTES, BASE_NONE, NULL, 0x0,",
          "1432:         \"Response to a challenge\",",
          "1433:         HFILL",
          "1434:       }",
          "1435:     },",
          "1437:     { &hf_mle_tlv_ll_frm_cntr,",
          "1438:       { \"Link Layer Frame Counter\",",
          "1439:         \"mle.tlv.ll_frm_cntr\",",
          "1440:         FT_UINT32, BASE_DEC, NULL, 0x0,",
          "1441:         \"The Link layer frame counter\",",
          "1442:         HFILL",
          "1443:       }",
          "1444:     },",
          "1446:     { &hf_mle_tlv_mle_frm_cntr,",
          "1447:       { \"MLE Frame Counter\",",
          "1448:         \"mle.tlv.mle_frm_cntr\",",
          "1449:         FT_UINT32, BASE_DEC, NULL, 0x0,",
          "1450:         \"The MLE frame counter\",",
          "1451:         HFILL",
          "1452:       }",
          "1453:     },",
          "1455:     { &hf_mle_tlv_unknown,",
          "1456:       { \"Unknown\",",
          "1457:         \"mle.tlv.unknown\",",
          "1458:         FT_BYTES, BASE_NONE, NULL, 0x0,",
          "1459:         \"Unknown TLV, raw value\",",
          "1460:         HFILL",
          "1461:       }",
          "1462:     },",
          "1464:     { &hf_mle_tlv_lqi_c,",
          "1465:       { \"Complete Flag\",",
          "1466:         \"mle.tlv.lqi.complete\",",
          "1467:         FT_BOOLEAN, 8, NULL, LQI_FLAGS_C,",
          "1468:         NULL,",
          "1469:         HFILL",
          "1470:       }",
          "1471:     },",
          "1473:     { &hf_mle_tlv_lqi_size,",
          "1474:       { \"Address Size\",",
          "1475:         \"mle.tlv.lqi.size\",",
          "1476:         FT_UINT8, BASE_DEC, NULL, LQI_FLAGS_SIZE,",
          "1477:         NULL,",
          "1478:         HFILL",
          "1479:       }",
          "1480:     },",
          "1482:     { &hf_mle_tlv_neighbor,",
          "1483:       { \"Neighbor Record\",",
          "1484:         \"mle.tlv.neighbor\",",
          "1485:         FT_NONE, BASE_NONE, NULL, 0x0,",
          "1486:         NULL,",
          "1487:         HFILL",
          "1488:       }",
          "1489:     },",
          "1491:     { &hf_mle_tlv_neighbor_flagI,",
          "1492:       { \"Incoming\",",
          "1493:         \"mle.tlv.neighbor.flagI\",",
          "1494:         FT_BOOLEAN, 8, NULL, NEIGHBOR_FLAG_I,",
          "1495:         \"Set if the sender has configured its link with this neighbor and will accept incoming messages from them.\",",
          "1496:         HFILL",
          "1497:       }",
          "1498:     },",
          "1500:     { &hf_mle_tlv_neighbor_flagO,",
          "1501:       { \"Outgoing\",",
          "1502:         \"mle.tlv.neighbor.flagO\",",
          "1503:         FT_BOOLEAN, 8, NULL, NEIGHBOR_FLAG_O,",
          "1504:         \"Set if the sender believes that the neighbor has configured its link with the sender and will accept incoming messages from the sender.\",",
          "1505:         HFILL",
          "1506:       }",
          "1507:     },",
          "1509:     { &hf_mle_tlv_neighbor_flagP,",
          "1510:       { \"Priority\",",
          "1511:         \"mle.tlv.neighbor.flagP\",",
          "1512:         FT_BOOLEAN, 8, NULL, NEIGHBOR_FLAG_P,",
          "1513:         \"Set if the sender expects to use this link for sending messages to this neighbor.\",",
          "1514:         HFILL",
          "1515:       }",
          "1516:     },",
          "1518:     { &hf_mle_tlv_neighbor_idr,",
          "1519:       { \"Inverse Delivery Ratio\",",
          "1520:         \"mle.tlv.neighbor.idr\",",
          "1521:         FT_UINT8, BASE_DEC, NULL, 0x0,",
          "1522:         NULL,",
          "1523:         HFILL",
          "1524:       }",
          "1525:     },",
          "1527:     { &hf_mle_tlv_neighbor_addr,",
          "1528:       { \"Address\",",
          "1529:         \"mle.tlv.neighbor.addr\",",
          "1530:         FT_BYTES, BASE_NONE, NULL, 0x0,",
          "1531:         NULL,",
          "1532:         HFILL",
          "1533:       }",
          "1534:     },",
          "1536:     { &hf_mle_tlv_network_param_id,",
          "1537:       { \"Parameter ID\",",
          "1538:         \"mle.tlv.network.param_id\",",
          "1539:         FT_UINT8, BASE_DEC, NULL, 0x0,",
          "1540:         NULL,",
          "1541:         HFILL",
          "1542:       }",
          "1543:     },",
          "1545:     { &hf_mle_tlv_network_delay,",
          "1546:       { \"Delay\",",
          "1547:         \"mle.tlv.network.delay\",",
          "1548:         FT_UINT32, BASE_DEC, NULL, 0x0,",
          "1549:         NULL,",
          "1550:         HFILL",
          "1551:       }",
          "1552:     },",
          "1554:     { &hf_mle_tlv_network_channel,",
          "1555:       { \"Channel\",",
          "1556:         \"mle.tlv.network.channel\",",
          "1557:         FT_UINT16, BASE_DEC, NULL, 0x0,",
          "1558:         NULL,",
          "1559:         HFILL",
          "1560:       }",
          "1561:     },",
          "1563:     { &hf_mle_tlv_network_pan_id,",
          "1564:       { \"PAN ID\",",
          "1565:         \"mle.tlv.network.pan_id\",",
          "1566:         FT_UINT16, BASE_HEX, NULL, 0x0,",
          "1567:         NULL,",
          "1568:         HFILL",
          "1569:       }",
          "1570:     },",
          "1572:     { &hf_mle_tlv_network_pmt_join,",
          "1573:       { \"Permit Join\",",
          "1574:         \"mle.tlv.network.pmt_join\",",
          "1575:         FT_BOOLEAN, 8, NULL, 0x1,",
          "1576:         NULL,",
          "1577:         HFILL",
          "1578:       }",
          "1579:     },",
          "1581:     { &hf_mle_tlv_network_bcn_payload,",
          "1582:       { \"Beacon Payload\",",
          "1583:         \"mle.tlv.network.bcn_payload\",",
          "1584:         FT_BYTES, BASE_NONE, NULL, 0x0,",
          "1585:         NULL,",
          "1586:         HFILL",
          "1587:       }",
          "1588:     },",
          "1590:     { &hf_mle_tlv_route64_id_seq,",
          "1591:       { \"ID Sequence\",",
          "1592:         \"mle.tlv.route64.id_seq\",",
          "1593:         FT_UINT8, BASE_DEC, NULL, 0x0,",
          "1594:         NULL,",
          "1595:         HFILL",
          "1596:       }",
          "1597:     },",
          "1599:     { &hf_mle_tlv_route64_id_mask,",
          "1600:       { \"Assigned Router ID Mask\",",
          "1601:         \"mle.tlv.route64.id_mask\",",
          "1602:         FT_BYTES, BASE_NONE, NULL, 0x0,",
          "1603:         NULL,",
          "1604:         HFILL",
          "1605:       }",
          "1606:     },",
          "1608:     { &hf_mle_tlv_route64_entry,",
          "1609:       { \"Routing Table Entry\",",
          "1610:         \"mle.tlv.route64\",",
          "1611:         FT_UINT8, BASE_HEX, NULL, 0x0,",
          "1612:         NULL,",
          "1613:         HFILL",
          "1614:       }",
          "1615:     },",
          "1617:     { &hf_mle_tlv_route64_nbr_out,",
          "1618:       { \"Neighbor Out Link Quality\",",
          "1619:         \"mle.tlv.route64.nbr_out\",",
          "1620:         FT_UINT8, BASE_DEC, NULL, ROUTE_TBL_OUT_MASK,",
          "1621:         NULL,",
          "1622:         HFILL",
          "1623:       }",
          "1624:     },",
          "1626:     { &hf_mle_tlv_route64_nbr_in,",
          "1627:       { \"Neighbor In Link Quality\",",
          "1628:         \"mle.tlv.route64.nbr_in\",",
          "1629:         FT_UINT8, BASE_DEC, NULL, ROUTE_TBL_IN_MASK,",
          "1630:         NULL,",
          "1631:         HFILL",
          "1632:       }",
          "1633:     },",
          "1635:     { &hf_mle_tlv_route64_cost,",
          "1636:       { \"Router Cost\",",
          "1637:         \"mle.tlv.route64.cost\",",
          "1638:         FT_UINT8, BASE_DEC, NULL, ROUTE_TBL_COST_MASK,",
          "1639:         NULL,",
          "1640:         HFILL",
          "1641:       }",
          "1642:     },",
          "1643: #if 0",
          "1644:     { &hf_mle_tlv_route64_unknown,",
          "1645:       { \"(unknown)\",",
          "1646:         \"mle.tlv.route64.unknown\",",
          "1647:         FT_BYTES, BASE_NONE, NULL, 0x0,",
          "1648:         NULL,",
          "1649:         HFILL",
          "1650:       }",
          "1651:     },",
          "1652: #endif",
          "1653:     { &hf_mle_tlv_addr16,",
          "1654:       { \"Address16\",",
          "1655:         \"mle.tlv.addr16\",",
          "1656:         FT_BYTES, BASE_NONE, NULL, 0x0,",
          "1657:         NULL,",
          "1658:         HFILL",
          "1659:       }",
          "1660:     },",
          "1662:     { &hf_mle_tlv_leader_data_partition_id,",
          "1663:       { \"Partition ID\",",
          "1664:         \"mle.tlv.leader_data.partition_id\",",
          "1665:         FT_UINT32, BASE_HEX, NULL, 0x0,",
          "1666:         NULL,",
          "1667:         HFILL",
          "1668:       }",
          "1669:     },",
          "1671:     { &hf_mle_tlv_leader_data_weighting,",
          "1672:       { \"Weighting\",",
          "1673:         \"mle.tlv.leader_data.weighting\",",
          "1674:         FT_UINT8, BASE_DEC, NULL, 0x0,",
          "1675:         NULL,",
          "1676:         HFILL",
          "1677:       }",
          "1678:     },",
          "1680:     { &hf_mle_tlv_leader_data_version,",
          "1681:       { \"Data Version\",",
          "1682:         \"mle.tlv.leader_data.data_version\",",
          "1683:         FT_UINT8, BASE_DEC, NULL, 0x0,",
          "1684:         NULL,",
          "1685:         HFILL",
          "1686:       }",
          "1687:     },",
          "1689:     { &hf_mle_tlv_leader_data_stable_version,",
          "1690:       { \"Stable Data Version\",",
          "1691:         \"mle.tlv.leader_data.stable_data_version\",",
          "1692:         FT_UINT8, BASE_DEC, NULL, 0x0,",
          "1693:         NULL,",
          "1694:         HFILL",
          "1695:       }",
          "1696:     },",
          "1698:     { &hf_mle_tlv_leader_data_router_id,",
          "1699:       { \"Leader Router ID\",",
          "1700:         \"mle.tlv.leader_data.router_id\",",
          "1701:         FT_UINT8, BASE_DEC, NULL, 0x0,",
          "1702:         NULL,",
          "1703:         HFILL",
          "1704:       }",
          "1705:     },",
          "1706: #if 0",
          "1707:     { &hf_mle_tlv_network_data,",
          "1708:       { \"Network Data\",",
          "1709:         \"mle.tlv.network_data\",",
          "1710:         FT_BYTES, BASE_NONE, NULL, 0x0,",
          "1711:         \"Network data (opaque data)\",",
          "1712:         HFILL",
          "1713:       }",
          "1714:     },",
          "1715: #endif",
          "1716:     { &hf_mle_tlv_scan_mask_r,",
          "1717:       { \"Router\",",
          "1718:         \"mle.tlv.scan_mask.r\",",
          "1719:         FT_BOOLEAN, 8, NULL, SCAN_MASK_R_MASK,",
          "1720:         NULL,",
          "1721:         HFILL",
          "1722:       }",
          "1723:     },",
          "1725:     { &hf_mle_tlv_scan_mask_e,",
          "1726:       { \"End Device\",",
          "1727:         \"mle.tlv.scan_mask.e\",",
          "1728:         FT_BOOLEAN, 8, NULL, SCAN_MASK_D_MASK,",
          "1729:         NULL,",
          "1730:         HFILL",
          "1731:       }",
          "1732:     },",
          "1734:     { &hf_mle_tlv_conn_max_child_cnt,",
          "1735:       { \"Max Child Count\",",
          "1736:         \"mle.tlv.conn.max_child_cnt\",",
          "1737:         FT_UINT8, BASE_DEC, NULL, 0x0,",
          "1738:         NULL,",
          "1739:         HFILL",
          "1740:       }",
          "1741:     },",
          "1743:     { &hf_mle_tlv_conn_child_cnt,",
          "1744:       { \"Child Count\",",
          "1745:         \"mle.tlv.conn.child_cnt\",",
          "1746:         FT_UINT8, BASE_DEC, NULL, 0x0,",
          "1747:         NULL,",
          "1748:         HFILL",
          "1749:       }",
          "1750:     },",
          "1752:     { &hf_mle_tlv_conn_flags,",
          "1753:       { \"Flags\",",
          "1754:         \"mle.tlv.conn.flags\",",
          "1755:         FT_NONE, BASE_NONE, NULL, 0x0,",
          "1756:         NULL,",
          "1757:         HFILL",
          "1758:       }",
          "1759:     },",
          "1761:     { &hf_mle_tlv_conn_flags_pp,",
          "1762:       { \"Parent Priority\",",
          "1763:         \"mle.tlv.conn.flags.pp\",",
          "1764:         FT_INT8, BASE_DEC, VALS(mle_conn_tlv_flags_pp_enums), CONN_MASK_FLAGS_PP_MASK,",
          "1765:         NULL,",
          "1766:         HFILL",
          "1767:       }",
          "1768:     },",
          "1770:     { &hf_mle_tlv_conn_lq3,",
          "1771:       { \"Link Quality 3\",",
          "1772:         \"mle.tlv.conn.lq3\",",
          "1773:         FT_UINT8, BASE_DEC, NULL, 0x0,",
          "1774:         NULL,",
          "1775:         HFILL",
          "1776:       }",
          "1777:     },",
          "1779:     { &hf_mle_tlv_conn_lq2,",
          "1780:       { \"Link Quality 2\",",
          "1781:         \"mle.tlv.conn.lq2\",",
          "1782:         FT_UINT8, BASE_DEC, NULL, 0x0,",
          "1783:         NULL,",
          "1784:         HFILL",
          "1785:       }",
          "1786:     },",
          "1788:     { &hf_mle_tlv_conn_lq1,",
          "1789:       { \"Link Quality 1\",",
          "1790:         \"mle.tlv.conn.lq1\",",
          "1791:         FT_UINT8, BASE_DEC, NULL, 0x0,",
          "1792:         NULL,",
          "1793:         HFILL",
          "1794:       }",
          "1795:     },",
          "1797:     { &hf_mle_tlv_conn_leader_cost,",
          "1798:       { \"Leader Cost\",",
          "1799:         \"mle.tlv.conn.leader_cost\",",
          "1800:         FT_UINT8, BASE_DEC, NULL, 0x0,",
          "1801:         NULL,",
          "1802:         HFILL",
          "1803:       }",
          "1804:     },",
          "1806:     { &hf_mle_tlv_conn_id_seq,",
          "1807:       { \"ID Sequence\",",
          "1808:         \"mle.tlv.conn.id_seq\",",
          "1809:         FT_UINT8, BASE_DEC, NULL, 0x0,",
          "1810:         NULL,",
          "1811:         HFILL",
          "1812:       }",
          "1813:     },",
          "1815:     { &hf_mle_tlv_conn_active_rtrs,",
          "1816:       { \"Active Routers\",",
          "1817:         \"mle.tlv.conn.active_rtrs\",",
          "1818:         FT_UINT8, BASE_DEC, NULL, 0x0,",
          "1819:         NULL,",
          "1820:         HFILL",
          "1821:       }",
          "1822:     },",
          "1824:     { &hf_mle_tlv_conn_sed_buf_size,",
          "1825:       { \"SED Buffer Size\",",
          "1826:         \"mle.tlv.conn.sed_buf_size\",",
          "1827:         FT_UINT16, BASE_DEC, NULL, 0x0,",
          "1828:         NULL,",
          "1829:         HFILL",
          "1830:       }",
          "1831:     },",
          "1833:     { &hf_mle_tlv_conn_sed_dgram_cnt,",
          "1834:       { \"SED Datagram Count\",",
          "1835:         \"mle.tlv.conn.sed_dgram_cnt\",",
          "1836:         FT_UINT8, BASE_DEC, NULL, 0x0,",
          "1837:         NULL,",
          "1838:         HFILL",
          "1839:       }",
          "1840:     },",
          "1842:     { &hf_mle_tlv_link_margin,",
          "1843:       { \"Link Margin\",",
          "1844:         \"mle.tlv.link_margin\",",
          "1845:         FT_UINT8, BASE_DEC, NULL, 0,",
          "1846:         \"Link margin in dB\",",
          "1847:         HFILL",
          "1848:       }",
          "1849:     },",
          "1851:     { &hf_mle_tlv_status,",
          "1852:       { \"Status\",",
          "1853:         \"mle.tlv.status\",",
          "1854:         FT_UINT8, BASE_DEC, VALS(mle_status_tlv_enums), 0,",
          "1855:         NULL,",
          "1856:         HFILL",
          "1857:       }",
          "1858:     },",
          "1860:     { &hf_mle_tlv_version,",
          "1861:       { \"Version\",",
          "1862:         \"mle.tlv.version\",",
          "1863:         FT_UINT16, BASE_DEC, NULL, 0,",
          "1864:         NULL,",
          "1865:         HFILL",
          "1866:       }",
          "1867:     },",
          "1869:     { &hf_mle_tlv_addr_reg_entry,",
          "1870:       { \"Address Registration Entry\",",
          "1871:         \"mle.tlv.addr_reg\",",
          "1872:         FT_NONE, BASE_NONE, NULL, 0x0,",
          "1873:         NULL,",
          "1874:         HFILL",
          "1875:       }",
          "1876:     },",
          "1878:     { &hf_mle_tlv_addr_reg_iid_type,",
          "1879:       { \"IID type\",",
          "1880:         \"mle.tlv.addr_reg_iid_type\",",
          "1881:         FT_BOOLEAN, 8, TFS(&mle_tlv_addr_reg_iid_type), ADDR_REG_MASK_IID_TYPE_MASK,",
          "1882:         \"Context ID\",",
          "1883:         HFILL",
          "1884:       }",
          "1885:     },",
          "1887:     { &hf_mle_tlv_addr_reg_cid,",
          "1888:       { \"Context ID\",",
          "1889:         \"mle.tlv.addr_reg_cid\",",
          "1890:         FT_UINT8, BASE_DEC, NULL, ADDR_REG_MASK_CID_MASK,",
          "1891:         \"6LoWPAN Context ID\",",
          "1892:         HFILL",
          "1893:       }",
          "1894:     },",
          "1896:     { &hf_mle_tlv_addr_reg_iid,",
          "1897:       { \"IID\",",
          "1898:         \"mle.tlv.addr_reg_iid\",",
          "1899:         FT_BYTES, BASE_NONE, NULL, 0x0,",
          "1900:         \"Interface identifier\",",
          "1901:         HFILL",
          "1902:       }",
          "1903:     },",
          "1905:     { &hf_mle_tlv_addr_reg_ipv6,",
          "1906:       { \"IPv6 Address\",",
          "1907:         \"mle.tlv.addr_reg_ipv6\",",
          "1908:         FT_IPv6, BASE_NONE, NULL, 0x0,",
          "1909:         \"IID\",",
          "1910:         HFILL",
          "1911:       }",
          "1912:     },",
          "1913: #if 0",
          "1914:     { &hf_mle_tlv_hold_time,",
          "1915:       { \"Hold Time\",",
          "1916:         \"mle.tlv.hold_time\",",
          "1917:         FT_UINT16, BASE_DEC, NULL, 0,",
          "1918:         NULL,",
          "1919:         HFILL",
          "1920:       }",
          "1921:     },",
          "1922: #endif",
          "1923:     { &hf_mle_tlv_network_unknown,",
          "1924:       { \"(unknown)\",",
          "1925:         \"mle.tlv.network.unknown\",",
          "1926:         FT_BYTES, BASE_NONE, NULL, 0x0,",
          "1927:         NULL,",
          "1928:         HFILL",
          "1929:       }",
          "1930:     },",
          "1932:     { &hf_mle_tlv_channel_page,",
          "1933:       { \"Channel Page\",",
          "1934:         \"mle.tlv.channel_page\",",
          "1935:         FT_UINT8, BASE_DEC, NULL, 0x0,",
          "1936:         NULL,",
          "1937:         HFILL",
          "1938:       }",
          "1939:     },",
          "1941:     { &hf_mle_tlv_channel,",
          "1942:       { \"Channel\",",
          "1943:         \"mle.tlv.channel\",",
          "1944:         FT_UINT16, BASE_DEC, NULL, 0x0,",
          "1945:         NULL,",
          "1946:         HFILL",
          "1947:       }",
          "1948:     },",
          "1950:     { &hf_mle_tlv_pan_id,",
          "1951:       { \"PAN ID\",",
          "1952:         \"mle.tlv.pan_id\",",
          "1953:         FT_UINT16, BASE_HEX, NULL, 0x0,",
          "1954:         NULL,",
          "1955:         HFILL",
          "1956:       }",
          "1957:     },",
          "1959:     { &hf_mle_tlv_active_tstamp,",
          "1960:       { \"Active Timestamp\",",
          "1961:         \"mle.tlv.active_tstamp\",",
          "1962:         FT_ABSOLUTE_TIME, ABSOLUTE_TIME_LOCAL, NULL, 0x0,",
          "1963:         NULL,",
          "1964:         HFILL",
          "1965:       }",
          "1966:     },",
          "1968:     { &hf_mle_tlv_pending_tstamp,",
          "1969:       { \"Pending Timestamp\",",
          "1970:         \"mle.tlv.pending_tstamp\",",
          "1971:         FT_ABSOLUTE_TIME, ABSOLUTE_TIME_LOCAL, NULL, 0x0,",
          "1972:         NULL,",
          "1973:         HFILL",
          "1974:       }",
          "1975:     },",
          "1976: #if 0",
          "1977:     { &hf_mle_tlv_active_op_dataset,",
          "1978:       { \"Active Operational Dataset\",",
          "1979:         \"mle.tlv.active_op_dataset\",",
          "1980:         FT_BYTES, BASE_NONE, NULL, 0x0,",
          "1981:         \"Thread Active Operational Dataset\",",
          "1982:         HFILL",
          "1983:       }",
          "1984:     },",
          "1985:     { &hf_mle_tlv_pending_op_dataset,",
          "1986:       { \"Pending Operational Dataset\",",
          "1987:         \"mle.tlv.active_op_dataset\",",
          "1988:         FT_BYTES, BASE_NONE, NULL, 0x0,",
          "1989:         \"Thread Pending Operational Dataset\",",
          "1990:         HFILL",
          "1991:       }",
          "1992:     },",
          "1993: #endif",
          "1994:   };",
          "1996:   static gint *ett[] = {",
          "1997:     &ett_mle,",
          "1998:     &ett_mle_auxiliary_security,",
          "1999:     &ett_mle_aux_sec_control,",
          "2000:     &ett_mle_aux_sec_key_id,",
          "2001:     &ett_mle_tlv,",
          "2002:     &ett_mle_neighbor,",
          "2003:     &ett_mle_router,",
          "2004:     &ett_mle_addr_reg,",
          "2005:     &ett_mle_conn_flg,",
          "2006:     &ett_mle_thread_nwd",
          "2007: };",
          "2009:   static ei_register_info ei[] = {",
          "2010:     { &ei_mle_cbc_mac_failed, { \"mle.cbc_mac_failed\", PI_UNDECODED, PI_WARN, \"Call to ccm_cbc_mac() failed\", EXPFILL }},",
          "2011:     { &ei_mle_packet_too_small, { \"mle.packet_too_small\", PI_UNDECODED, PI_WARN, \"Packet was too small to include the CRC and MIC\", EXPFILL }},",
          "2012:     { &ei_mle_no_key, { \"mle.no_key\", PI_UNDECODED, PI_WARN, \"No encryption key set - can't decrypt\", EXPFILL }},",
          "2013:     { &ei_mle_decrypt_failed, { \"mle.decrypt_failed\", PI_UNDECODED, PI_WARN, \"Decrypt failed\", EXPFILL }},",
          "2014:     { &ei_mle_mic_check_failed, { \"mle.mic_check_failed\", PI_UNDECODED, PI_WARN, \"MIC check failed\", EXPFILL }},",
          "2015:     { &ei_mle_tlv_length_failed, { \"mle.tlv_length_failed\", PI_UNDECODED, PI_WARN, \"TLV Length inconsistent\", EXPFILL }},",
          "2016:     { &ei_mle_len_size_mismatch, { \"mle.len_size_mismatch\", PI_UNDECODED, PI_WARN, \"TLV Length & Size field disagree\", EXPFILL }},",
          "2017:   };",
          "2019:   module_t *mle_module;",
          "2020:   expert_module_t* expert_mle;",
          "2022:   proto_mle = proto_register_protocol(\"Mesh Link Establishment\", \"MLE\", \"mle\");",
          "2023:   proto_register_field_array(proto_mle, hf, array_length(hf));",
          "2024:   proto_register_subtree_array(ett, array_length(ett));",
          "2025:   expert_mle = expert_register_protocol(proto_mle);",
          "2026:   expert_register_field_array(expert_mle, ei, array_length(ei));",
          "2028:   mle_handle = register_dissector(\"mle\", dissect_mle, proto_mle);",
          "2030:   mle_module = prefs_register_protocol(proto_mle, NULL);",
          "2032:   prefs_register_bool_preference(mle_module, \"meshlink_mic_ok\",",
          "2033:                   \"Dissect only good MIC\",",
          "2034:                   \"Dissect payload only if MIC is valid.\",",
          "2035:                    &mle_mic_ok);",
          "2038:     mle_key_hash_handlers = wmem_tree_new(wmem_epan_scope());",
          "2039: }",
          "2041: void",
          "2042: proto_reg_handoff_mle(void)",
          "2043: {",
          "2044:     thread_nwd_handle = find_dissector_add_dependency(\"thread_nwd\", proto_mle);",
          "2045:     thread_mc_handle = find_dissector_add_dependency(\"thread_meshcop\", proto_mle);",
          "2049:     dissector_add_uint_range_with_preference(\"udp.port\", UDP_PORT_MLE_RANGE, mle_handle);",
          "2051:     proto_ieee802154 = proto_get_id_by_filter_name(IEEE802154_PROTOABBREV_WPAN);",
          "2052: }",
          "",
          "---------------"
        ],
        "epan/dissectors/packet-mle.h||epan/dissectors/packet-mle.h": [
          "File: epan/dissectors/packet-mle.h -> epan/dissectors/packet-mle.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "24: #ifndef __PACKET_MLE_H__",
          "25: #define __PACKET_MLE_H__",
          "27: #include \"packet-ieee802154.h\"",
          "29: typedef gboolean (*mle_set_mle_key_func) (ieee802154_packet * packet, unsigned char* key, unsigned char* alt_key, ieee802154_key_t* uat_key);",
          "30: extern void register_mle_key_hash_handler(guint hash_identifier, mle_set_mle_key_func key_func);",
          "32: #endif",
          "",
          "---------------"
        ],
        "epan/dissectors/packet-openthread.c||epan/dissectors/packet-openthread.c": [
          "File: epan/dissectors/packet-openthread.c -> epan/dissectors/packet-openthread.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "25: #include \"config.h\"",
          "27: #include <epan/packet.h>",
          "30: void proto_register_openthread(void);",
          "31: void proto_reg_handoff_openthread(void);",
          "33: static int proto_openthread = -1;",
          "35: static dissector_handle_t openthread_handle;",
          "36: static dissector_handle_t wpan_handle;",
          "38: static int hf_openthread_channel = -1;",
          "41: static gint ett_openthread = -1;",
          "43: static int",
          "44: dissect_openthread(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)",
          "45: {",
          "46:     proto_item  *proto_root;",
          "47:     proto_tree  *openthread_tree;",
          "48:     tvbuff_t    *sub_tvb;",
          "51:     proto_root = proto_tree_add_item(tree, proto_openthread, tvb, 0, -1, ENC_NA);",
          "52:     openthread_tree = proto_item_add_subtree(proto_root, ett_openthread);",
          "54:     proto_tree_add_item(openthread_tree, hf_openthread_channel, tvb, 0, 1, ENC_NA);",
          "56:     call_dissector(wpan_handle, sub_tvb, pinfo, tree);",
          "58:     return tvb_captured_length(tvb);",
          "59: }",
          "61: void",
          "62: proto_register_openthread(void)",
          "63: {",
          "64:     static hf_register_info hf[] = {",
          "67:         { &hf_openthread_channel,",
          "68:             { \"Channel\",",
          "69:             \"openthread.channel\",",
          "70:             FT_UINT8, BASE_DEC, NULL, 0x0,",
          "71:             NULL,",
          "72:             HFILL }",
          "73:         },",
          "74: #if 0",
          "75:         { &hf_openthread_psdu,",
          "76:             { \"PSDU\",",
          "77:             \"openthread.psdu\",",
          "78:             FT_NONE, BASE_NONE, NULL, 0x0,",
          "79:             NULL,",
          "80:             HFILL }",
          "81:         }",
          "82: #endif",
          "83:     };",
          "85:     static gint *ett[] = {",
          "86:         &ett_openthread",
          "87:     };",
          "89:     proto_openthread = proto_register_protocol(\"OpenThread\", \"OpenThread\", \"openthread\");",
          "90:     proto_register_field_array(proto_openthread, hf, array_length(hf));",
          "91:     proto_register_subtree_array(ett, array_length(ett));",
          "92:     openthread_handle = register_dissector(\"openthread\", dissect_openthread, proto_openthread);",
          "93: }",
          "95: void",
          "96: proto_reg_handoff_openthread(void)",
          "97: {",
          "98:     wpan_handle = find_dissector_add_dependency(\"wpan_nofcs\", proto_openthread);",
          "99:     dissector_add_for_decode_as(\"udp.port\", openthread_handle);",
          "100: }",
          "",
          "---------------"
        ],
        "epan/dissectors/packet-thread.c||epan/dissectors/packet-thread.c": [
          "File: epan/dissectors/packet-thread.c -> epan/dissectors/packet-thread.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "25: #include \"config.h\"",
          "26: #include <glib.h>",
          "27: #include <stdlib.h>",
          "28: #include <math.h>",
          "29: #include <epan/packet.h>",
          "30: #include <epan/conversation.h>",
          "31: #include <epan/proto_data.h>",
          "32: #include <epan/wmem/wmem.h>",
          "33: #include <epan/expert.h>",
          "34: #include <epan/range.h>",
          "35: #include <epan/oui.h>",
          "36: #include <epan/prefs.h>",
          "37: #include <epan/strutil.h>",
          "38: #include <epan/to_str.h>",
          "39: #include \"packet-coap.h\"",
          "40: #include \"packet-ieee802154.h\"",
          "41: #include \"packet-mle.h\"",
          "44: #include <wsutil/wsgcrypt.h>",
          "47: void proto_register_thread_coap(void);",
          "48: void proto_reg_handoff_thread_coap(void);",
          "50: void proto_register_thread_address(void);",
          "51: void proto_reg_handoff_thread_address(void);",
          "53: void proto_register_thread_dg(void);",
          "54: void proto_reg_handoff_thread_dg(void);",
          "56: void proto_register_thread_mc(void);",
          "57: void proto_reg_handoff_thread_mc(void);",
          "59: void proto_register_thread_nwd(void);",
          "61: void proto_register_thread_bcn(void);",
          "62: void proto_reg_handoff_thread_bcn(void);",
          "64: void proto_register_thread(void);",
          "65: void proto_reg_handoff_thread(void);",
          "67: static int proto_thread_address = -1;",
          "68: static int proto_thread_dg = -1;",
          "69: static int proto_thread_mc = -1;",
          "70: static int proto_thread_nwd = -1;",
          "71: static int proto_thread_coap = -1;",
          "72: static int proto_thread_bcn = -1;",
          "73: static int proto_thread = -1;",
          "74: static int proto_coap = -1;",
          "80: static int hf_thread_address_tlv = -1;",
          "81: static int hf_thread_address_tlv_type = -1;",
          "82: static int hf_thread_address_tlv_length = -1;",
          "83: static int hf_thread_address_tlv_unknown = -1;",
          "87: static int hf_thread_address_tlv_target_eid = -1;",
          "90: static int hf_thread_address_tlv_ext_mac_addr = -1;",
          "93: static int hf_thread_address_tlv_rloc16 = -1;",
          "96: static int hf_thread_address_tlv_ml_eid = -1;",
          "99: static int hf_thread_address_tlv_status = -1;",
          "105: static int hf_thread_address_tlv_last_transaction_time = -1;",
          "108: static int hf_thread_address_tlv_router_mask_id_seq = -1;",
          "109: static int hf_thread_address_tlv_router_mask_assigned = -1;",
          "112: static int hf_thread_address_tlv_nd_option = -1;",
          "115: static int hf_thread_address_tlv_nd_data = -1;",
          "119: static int hf_thread_dg_tlv = -1;",
          "120: static int hf_thread_dg_tlv_type = -1;",
          "121: static int hf_thread_dg_tlv_length8 = -1;",
          "122: static int hf_thread_dg_tlv_length16 = -1;",
          "123: static int hf_thread_dg_tlv_general = -1;",
          "124: static int hf_thread_dg_tlv_unknown = -1;",
          "126: #if 0",
          "128: static int hf_thread_dg_tlv_source_addr = -1;",
          "129: static int hf_thread_dg_tlv_mode_device_type = -1;",
          "130: static int hf_thread_dg_tlv_mode_idle_rx = -1;",
          "131: static int hf_thread_dg_tlv_mode_sec_data_req = -1;",
          "132: static int hf_thread_dg_tlv_mode_nwk_data = -1;",
          "133: static int hf_thread_dg_tlv_timeout = -1;",
          "134: static int hf_thread_dg_tlv_lqi_c = -1;",
          "135: static int hf_thread_dg_tlv_lqi_size = -1;",
          "136: static int hf_thread_dg_tlv_neighbor = -1;",
          "137: static int hf_thread_dg_tlv_neighbor_flagI = -1;",
          "138: static int hf_thread_dg_tlv_neighbor_flagO = -1;",
          "139: static int hf_thread_dg_tlv_neighbor_flagP = -1;",
          "140: static int hf_thread_dg_tlv_neighbor_idr = -1;",
          "141: static int hf_thread_dg_tlv_neighbor_addr = -1;",
          "142: static int hf_thread_dg_tlv_network_param_id = -1;",
          "143: static int hf_thread_dg_tlv_network_delay = -1;",
          "144: static int hf_thread_dg_tlv_network_channel = -1;",
          "145: static int hf_thread_dg_tlv_network_pan_id = -1;",
          "146: static int hf_thread_dg_tlv_network_pmt_join = -1;",
          "147: static int hf_thread_dg_tlv_network_bcn_payload = -1;",
          "148: static int hf_thread_dg_tlv_network_unknown = -1;",
          "149: static int hf_thread_dg_tlv_mle_frm_cntr = -1;",
          "150: static int hf_thread_dg_tlv_route_tbl_id_seq = -1;",
          "151: static int hf_thread_dg_tlv_route_tbl_id_mask = -1;",
          "152: static int hf_thread_dg_tlv_route_tbl_entry = -1;",
          "153: static int hf_thread_dg_tlv_route_tbl_nbr_out = -1;",
          "154: static int hf_thread_dg_tlv_route_tbl_nbr_in = -1;",
          "155: static int hf_thread_dg_tlv_route_tbl_cost = -1;",
          "156: static int hf_thread_dg_tlv_route_tbl_unknown = -1;",
          "157: static int hf_thread_dg_tlv_addr_16 = -1;",
          "158: static int hf_thread_dg_tlv_leader_data_partition_id = -1;",
          "159: static int hf_thread_dg_tlv_leader_data_weighting = -1;",
          "160: static int hf_thread_dg_tlv_leader_data_version = -1;",
          "161: static int hf_thread_dg_tlv_leader_data_stable_version = -1;",
          "162: static int hf_thread_dg_tlv_leader_data_router_id = -1;",
          "163: static int hf_thread_dg_tlv_network_data = -1;",
          "164: static int hf_thread_dg_tlv_scan_mask_r = -1;",
          "165: static int hf_thread_dg_tlv_scan_mask_e = -1;",
          "166: static int hf_thread_dg_tlv_conn_max_child_cnt = -1;",
          "167: static int hf_thread_dg_tlv_conn_child_cnt = -1;",
          "168: static int hf_thread_dg_tlv_conn_lq3 = -1;",
          "169: static int hf_thread_dg_tlv_conn_lq2 = -1;",
          "170: static int hf_thread_dg_tlv_conn_lq1 = -1;",
          "171: static int hf_thread_dg_tlv_conn_leader_cost = -1;",
          "172: static int hf_thread_dg_tlv_conn_id_seq = -1;",
          "173: static int hf_thread_dg_tlv_link_margin = -1;",
          "174: static int hf_thread_dg_tlv_status = -1;",
          "175: static int hf_thread_dg_tlv_version = -1;",
          "176: static int hf_thread_dg_tlv_addr_reg_entry = -1;",
          "177: static int hf_thread_dg_tlv_addr_reg_iid_type = -1;",
          "178: static int hf_thread_dg_tlv_addr_reg_cid = -1;",
          "179: static int hf_thread_dg_tlv_addr_reg_iid = -1;",
          "180: static int hf_thread_dg_tlv_addr_reg_ipv6 = -1;",
          "181: static int hf_thread_dg_tlv_hold_time = -1;",
          "182: #endif",
          "186: static int hf_thread_mc_tlv = -1;",
          "187: static int hf_thread_mc_tlv_type = -1;",
          "188: static int hf_thread_mc_tlv_length8 = -1;",
          "189: static int hf_thread_mc_tlv_length16 = -1;",
          "190: static int hf_thread_mc_tlv_unknown = -1;",
          "194: static int hf_thread_mc_tlv_channel_page = -1;",
          "195: static int hf_thread_mc_tlv_channel = -1;",
          "198: static int hf_thread_mc_tlv_pan_id = -1;",
          "201: static int hf_thread_mc_tlv_xpan_id = -1;",
          "204: static int hf_thread_mc_tlv_net_name = -1;",
          "207: static int hf_thread_mc_tlv_pskc = -1;",
          "210: static int hf_thread_mc_tlv_master_key = -1;",
          "213: static int hf_thread_mc_tlv_net_key_seq_ctr = -1;",
          "216: static int hf_thread_mc_tlv_ml_prefix = -1;",
          "219: static int hf_thread_mc_tlv_steering_data = -1;",
          "222: static int hf_thread_mc_tlv_ba_locator = -1;",
          "225: static int hf_thread_mc_tlv_commissioner_id = -1;",
          "228: static int hf_thread_mc_tlv_commissioner_sess_id = -1;",
          "231: static int hf_thread_mc_tlv_sec_policy_rot = -1;",
          "232: static int hf_thread_mc_tlv_sec_policy_o = -1;",
          "233: static int hf_thread_mc_tlv_sec_policy_n = -1;",
          "234: static int hf_thread_mc_tlv_sec_policy_r = -1;",
          "235: static int hf_thread_mc_tlv_sec_policy_c = -1;",
          "236: static int hf_thread_mc_tlv_sec_policy_b = -1;",
          "239: static int hf_thread_mc_tlv_state = -1;",
          "242: static int hf_thread_mc_tlv_active_tstamp = -1;",
          "243: static int hf_thread_mc_tlv_pending_tstamp = -1;",
          "246: static int hf_thread_mc_tlv_delay_timer = -1;",
          "249: static int hf_thread_mc_tlv_udp_encap_src_port = -1;",
          "250: static int hf_thread_mc_tlv_udp_encap_dst_port = -1;",
          "253: static int hf_thread_mc_tlv_ipv6_addr = -1;",
          "256: static int hf_thread_mc_tlv_udp_port = -1;",
          "259: static int hf_thread_mc_tlv_iid = -1;",
          "262: static int hf_thread_mc_tlv_jr_locator = -1;",
          "265: static int hf_thread_mc_tlv_kek = -1;",
          "268: static int hf_thread_mc_tlv_provisioning_url = -1;",
          "271: static int hf_thread_mc_tlv_vendor_name = -1;",
          "272: static int hf_thread_mc_tlv_vendor_model = -1;",
          "273: static int hf_thread_mc_tlv_vendor_sw_ver = -1;",
          "274: static int hf_thread_mc_tlv_vendor_data = -1;",
          "275: static int hf_thread_mc_tlv_vendor_stack_ver_oui = -1;",
          "276: static int hf_thread_mc_tlv_vendor_stack_ver_build = -1;",
          "277: static int hf_thread_mc_tlv_vendor_stack_ver_rev = -1;",
          "278: static int hf_thread_mc_tlv_vendor_stack_ver_min = -1;",
          "279: static int hf_thread_mc_tlv_vendor_stack_ver_maj = -1;",
          "282: static int hf_thread_mc_tlv_chan_mask = -1;",
          "283: static int hf_thread_mc_tlv_chan_mask_page = -1;",
          "284: static int hf_thread_mc_tlv_chan_mask_len = -1;",
          "285: static int hf_thread_mc_tlv_chan_mask_mask = -1;",
          "288: static int hf_thread_mc_tlv_count = -1;",
          "291: static int hf_thread_mc_tlv_period = -1;",
          "294: static int hf_thread_mc_tlv_scan_duration = -1;",
          "297: static int hf_thread_mc_tlv_energy_list = -1;",
          "298: static int hf_thread_mc_tlv_el_count = -1;",
          "301: static int hf_thread_mc_tlv_discovery_req_ver = -1;",
          "302: static int hf_thread_mc_tlv_discovery_req_j = -1;",
          "305: static int hf_thread_mc_tlv_discovery_rsp_ver = -1;",
          "306: static int hf_thread_mc_tlv_discovery_rsp_n = -1;",
          "310: static int hf_thread_nwd_tlv = -1;",
          "311: static int hf_thread_nwd_tlv_type = -1;",
          "312: static int hf_thread_nwd_tlv_stable = -1;",
          "313: static int hf_thread_nwd_tlv_length = -1;",
          "314: static int hf_thread_nwd_tlv_unknown = -1;",
          "315: static int hf_thread_nwd_tlv_sub_tlvs = -1;",
          "318: static int hf_thread_nwd_tlv_has_route = -1;",
          "319: static int hf_thread_nwd_tlv_has_route_br_16 = -1;",
          "320: static int hf_thread_nwd_tlv_has_route_pref = -1;",
          "323: static int hf_thread_nwd_tlv_prefix = -1;",
          "324: static int hf_thread_nwd_tlv_prefix_domain_id = -1;",
          "325: static int hf_thread_nwd_tlv_prefix_length = -1;",
          "328: static int hf_thread_nwd_tlv_border_router = -1;",
          "329: static int hf_thread_nwd_tlv_border_router_16 = -1;",
          "330: static int hf_thread_nwd_tlv_border_router_pref = -1;",
          "331: static int hf_thread_nwd_tlv_border_router_p = -1;",
          "332: static int hf_thread_nwd_tlv_border_router_s = -1;",
          "333: static int hf_thread_nwd_tlv_border_router_d = -1;",
          "334: static int hf_thread_nwd_tlv_border_router_c = -1;",
          "335: static int hf_thread_nwd_tlv_border_router_r = -1;",
          "336: static int hf_thread_nwd_tlv_border_router_o = -1;",
          "337: static int hf_thread_nwd_tlv_border_router_n = -1;",
          "340: static int hf_thread_nwd_tlv_6lowpan_id_6co_context_length = -1;",
          "341: static int hf_thread_nwd_tlv_6lowpan_id_6co_flag = -1;",
          "342: static int hf_thread_nwd_tlv_6lowpan_id_6co_flag_c = -1;",
          "343: static int hf_thread_nwd_tlv_6lowpan_id_6co_flag_cid = -1;",
          "344: static int hf_thread_nwd_tlv_6lowpan_id_6co_flag_reserved = -1;",
          "350: static int hf_thread_nwd_tlv_service_t = -1;",
          "351: static int hf_thread_nwd_tlv_service_s_id = -1;",
          "352: static int hf_thread_nwd_tlv_service_s_ent_num = -1;",
          "353: static int hf_thread_nwd_tlv_service_s_data_len = -1;",
          "354: static int hf_thread_nwd_tlv_service_s_data = -1;",
          "357: static int hf_thread_nwd_tlv_server_16 = -1;",
          "358: static int hf_thread_nwd_tlv_server_data = -1;",
          "362: static int hf_thread_bcn_protocol = -1;",
          "363: static int hf_thread_bcn_joining = -1;",
          "364: static int hf_thread_bcn_native = -1;",
          "365: static int hf_thread_bcn_version = -1;",
          "366: static int hf_thread_bcn_network_id = -1;",
          "367: static int hf_thread_bcn_epid = -1;",
          "368: static int hf_thread_bcn_tlv = -1;",
          "369: static int hf_thread_bcn_tlv_type = -1;",
          "370: static int hf_thread_bcn_tlv_length = -1;",
          "371: static int hf_thread_bcn_tlv_steering_data = -1;",
          "372: static int hf_thread_bcn_tlv_unknown = -1;",
          "376: static gint ett_thread_address = -1;",
          "377: static gint ett_thread_address_tlv = -1;",
          "378: static gint ett_thread_dg = -1;",
          "379: static gint ett_thread_dg_tlv = -1;",
          "380: static gint ett_thread_mc = -1;",
          "381: static gint ett_thread_mc_tlv = -1;",
          "382: static gint ett_thread_mc_chan_mask = -1;",
          "383: static gint ett_thread_mc_el_count = -1;",
          "384: static gint ett_thread_nwd = -1;",
          "385: static gint ett_thread_nwd_tlv = -1;",
          "386: static gint ett_thread_nwd_has_route = -1;",
          "387: static gint ett_thread_nwd_6co_flag = -1;",
          "388: static gint ett_thread_nwd_border_router = -1;",
          "389: static gint ett_thread_nwd_prefix_sub_tlvs = -1;",
          "390: static gint ett_thread_bcn = -1;",
          "391: static gint ett_thread_bcn_tlv = -1;",
          "396: static expert_field ei_thread_address_len_size_mismatch = EI_INIT;",
          "399: static expert_field ei_thread_mc_tlv_length_failed = EI_INIT;",
          "400: static expert_field ei_thread_mc_len_size_mismatch = EI_INIT;",
          "401: static expert_field ei_thread_mc_len_too_long      = EI_INIT;",
          "403: static expert_field ei_thread_nwd_len_size_mismatch = EI_INIT;",
          "405: static dissector_table_t thread_coap_namespace;",
          "408: static dissector_handle_t thread_address_nwd_handle;",
          "409: static dissector_handle_t thread_dg_handle;",
          "410: static dissector_handle_t thread_mc_handle;",
          "411: static dissector_handle_t thread_dtls_handle;",
          "412: static dissector_handle_t thread_udp_handle;",
          "413: static dissector_handle_t thread_coap_handle;",
          "414: static dissector_handle_t thread_address_handle;",
          "416: #define THREAD_TLV_LENGTH_ESC  0xFF",
          "418: #define THREAD_MC_32768_TO_NSEC_FACTOR ((double)30517.578125)",
          "419: #define THREAD_MC_TSTAMP_MASK_U_MASK 0x80",
          "420: #define THREAD_MC_SEC_POLICY_MASK_O_MASK 0x80",
          "421: #define THREAD_MC_SEC_POLICY_MASK_N_MASK 0x40",
          "422: #define THREAD_MC_SEC_POLICY_MASK_R_MASK 0x20",
          "423: #define THREAD_MC_SEC_POLICY_MASK_C_MASK 0x10",
          "424: #define THREAD_MC_SEC_POLICY_MASK_B_MASK 0x08",
          "425: #define THREAD_MC_STACK_VER_REV_MASK 0x0F",
          "426: #define THREAD_MC_STACK_VER_MIN_MASK 0xF0",
          "427: #define THREAD_MC_STACK_VER_MAJ_MASK 0x0F",
          "428: #define THREAD_MC_DISCOVERY_REQ_MASK_VER_MASK 0xF0",
          "429: #define THREAD_MC_DISCOVERY_REQ_MASK_J_MASK 0x08",
          "430: #define THREAD_MC_DISCOVERY_RSP_MASK_VER_MASK 0xF0",
          "431: #define THREAD_MC_DISCOVERY_RSP_MASK_N_MASK 0x08",
          "432: #define THREAD_MC_INVALID_CHAN_COUNT 0xFFFF",
          "434: #define THREAD_NWD_TLV_HAS_ROUTE_PREF       0xC0",
          "435: #define THREAD_NWD_TLV_HAS_ROUTE_SIZE       3",
          "437: #define THREAD_NWD_TLV_BORDER_ROUTER_PREF   0xC0",
          "438: #define THREAD_NWD_TLV_BORDER_ROUTER_P      0x20",
          "439: #define THREAD_NWD_TLV_BORDER_ROUTER_S      0x10",
          "440: #define THREAD_NWD_TLV_BORDER_ROUTER_D      0x08",
          "441: #define THREAD_NWD_TLV_BORDER_ROUTER_C      0x04",
          "442: #define THREAD_NWD_TLV_BORDER_ROUTER_R      0x02",
          "443: #define THREAD_NWD_TLV_BORDER_ROUTER_O      0x01",
          "444: #define THREAD_NWD_TLV_BORDER_ROUTER_N      0x80",
          "446: #define THREAD_BCN_PROTOCOL_ID              0x03",
          "447: #define THREAD_BCN_JOINING                  0x01",
          "448: #define THREAD_BCN_NATIVE                   0x08",
          "449: #define THREAD_BCN_PROTOCOL_VERSION         0xf0",
          "450: #define THREAD_BCN_TLV_STEERING_DATA_S      0x80",
          "451: #define THREAD_BCN_TLV_STEERING_DATA        8",
          "453: #define ND_OPT_6CO_FLAG_C        0x10",
          "454: #define ND_OPT_6CO_FLAG_CID      0x0F",
          "455: #define ND_OPT_6CO_FLAG_RESERVED 0xE0",
          "457: #define THREAD_NWD_TLV_SERVICE_T    0x80",
          "458: #define THREAD_NWD_TLV_SERVICE_S_ID 0x0F",
          "460: typedef enum {",
          "461:     TLV_LEN_LEN8 = 1,",
          "462:     TLV_LEN_LEN16 = 3",
          "463: } tlv_len_len_e;",
          "465: typedef struct {",
          "466:     guint16 src_port;",
          "467:     guint16 dst_port;",
          "468:     guint16 length;",
          "469:     guint16 checksum;",
          "470: } udp_hdr_t;",
          "474: #define THREAD_ADDRESS_TLV_TARGET_EID               0",
          "475: #define THREAD_ADDRESS_TLV_EXT_MAC_ADDR             1",
          "476: #define THREAD_ADDRESS_TLV_RLOC16                   2",
          "477: #define THREAD_ADDRESS_TLV_ML_EID                   3",
          "478: #define THREAD_ADDRESS_TLV_STATUS                   4",
          "480: #define THREAD_ADDRESS_TLV_LAST_TRANSACTION_TIME    6",
          "481: #define THREAD_ADDRESS_TLV_ROUTER_MASK              7",
          "482: #define THREAD_ADDRESS_TLV_ND_OPTION                8",
          "483: #define THREAD_ADDRESS_TLV_ND_DATA                  9",
          "484: #define THREAD_ADDRESS_TLV_THREAD_NETWORK_DATA      10",
          "486: static const value_string thread_address_tlv_vals[] = {",
          "487: { THREAD_ADDRESS_TLV_TARGET_EID,            \"Target EID\" },",
          "488: { THREAD_ADDRESS_TLV_EXT_MAC_ADDR,          \"Extended MAC Address\" },",
          "489: { THREAD_ADDRESS_TLV_RLOC16,                \"RLOC16\" },",
          "490: { THREAD_ADDRESS_TLV_ML_EID,                \"ML-EID\" },",
          "491: { THREAD_ADDRESS_TLV_STATUS,                \"Status\" },",
          "493: { THREAD_ADDRESS_TLV_LAST_TRANSACTION_TIME, \"Last Transaction Time\" },",
          "494: { THREAD_ADDRESS_TLV_ND_OPTION,             \"ND Option\" },",
          "495: { THREAD_ADDRESS_TLV_ND_DATA,               \"ND Data\" },",
          "496: { THREAD_ADDRESS_TLV_THREAD_NETWORK_DATA,   \"Thread Network Data\" },",
          "497: { 0, NULL }",
          "498: };",
          "500: static const value_string thread_address_tlv_status_vals[] = {",
          "501: { 0, \"Success\" },",
          "502: { 1, \"No Address Available\" },",
          "503: { 0, NULL }",
          "504: };",
          "517: #define THREAD_DG_TLV_IPV6_ADDR_LIST        8",
          "518: #define THREAD_DG_TLV_MAC_COUNTERS          9",
          "520: #define THREAD_DG_TLV_BATTERY_LEVEL         14",
          "521: #define THREAD_DG_TLV_VOLTAGE               15",
          "522: #define THREAD_DG_TLV_CHILD_TABLE           16",
          "523: #define THREAD_DG_TLV_CHANNEL_PAGES         17",
          "524: #define THREAD_DG_TLV_TYPE_LIST             18",
          "525: #define THREAD_DG_TLV_UNKNOWN               255",
          "527: static const value_string thread_dg_tlv_vals[] = {",
          "529: { THREAD_DG_TLV_EXT_MAC_ADDR,          \"Extended MAC Address\" },",
          "531: { THREAD_DG_TLV_ADDRESS16,             \"Address16\" },",
          "532: { THREAD_DG_TLV_MODE,                  \"Mode\" },",
          "533: { THREAD_DG_TLV_TIMEOUT,               \"Timeout\" },",
          "534: { THREAD_DG_TLV_CONNECTIVITY,          \"Connectivity\" },",
          "535: { THREAD_DG_TLV_ROUTE64,               \"Route64\" },",
          "536: { THREAD_DG_TLV_LEADER_DATA,           \"Leader Data\" },",
          "537: { THREAD_DG_TLV_NETWORK_DATA,          \"Network Data\" },",
          "539: { THREAD_DG_TLV_IPV6_ADDR_LIST,        \"IPv6 Address List\" },",
          "540: { THREAD_DG_TLV_MAC_COUNTERS,          \"MAC Counters\" },",
          "542: { THREAD_DG_TLV_BATTERY_LEVEL,         \"Battery level (%)\" },",
          "543: { THREAD_DG_TLV_VOLTAGE,               \"Voltage (mV)\" },",
          "544: { THREAD_DG_TLV_CHILD_TABLE,           \"Child Table\" },",
          "545: { THREAD_DG_TLV_CHANNEL_PAGES,         \"Channel Pages\" },",
          "546: { THREAD_DG_TLV_TYPE_LIST,             \"Type List\" },",
          "547: { THREAD_DG_TLV_UNKNOWN,               \"Unknown\" },",
          "548: { 0, NULL }",
          "549: };",
          "552: #define THREAD_MC_TLV_PANID                        1",
          "553: #define THREAD_MC_TLV_XPANID                       2",
          "554: #define THREAD_MC_TLV_NETWORK_NAME                 3",
          "555: #define THREAD_MC_TLV_PSKC                         4",
          "556: #define THREAD_MC_TLV_NETWORK_MASTER_KEY           5",
          "557: #define THREAD_MC_TLV_NETWORK_KEY_SEQ_CTR          6",
          "558: #define THREAD_MC_TLV_NETWORK_ML_PREFIX            7",
          "559: #define THREAD_MC_TLV_STEERING_DATA                8",
          "560: #define THREAD_MC_TLV_BORDER_AGENT_LOCATOR         9",
          "561: #define THREAD_MC_TLV_COMMISSIONER_ID              10",
          "562: #define THREAD_MC_TLV_COMMISSIONER_SESSION_ID      11",
          "563: #define THREAD_MC_TLV_SECURITY_POLICY              12",
          "564: #define THREAD_MC_TLV_GET                          13",
          "566: #define THREAD_MC_TLV_COMMISSIONER_UDP_PORT        15",
          "567: #define THREAD_MC_TLV_STATE                        16",
          "568: #define THREAD_MC_TLV_JOINER_DTLS_ENCAP            17",
          "569: #define THREAD_MC_TLV_JOINER_UDP_PORT              18",
          "570: #define THREAD_MC_TLV_JOINER_IID                   19",
          "571: #define THREAD_MC_TLV_JOINER_ROUTER_LOCATOR        20",
          "572: #define THREAD_MC_TLV_JOINER_KEK                   21",
          "574: #define THREAD_MC_TLV_PROVISIONING_URL             32",
          "575: #define THREAD_MC_TLV_VENDOR_NAME                  33",
          "576: #define THREAD_MC_TLV_VENDOR_MODEL                 34",
          "577: #define THREAD_MC_TLV_VENDOR_SW_VERSION            35",
          "578: #define THREAD_MC_TLV_VENDOR_DATA                  36",
          "579: #define THREAD_MC_TLV_VENDOR_STACK_VERSION         37",
          "581: #define THREAD_MC_TLV_UDP_ENCAPSULATION            48",
          "582: #define THREAD_MC_TLV_IPV6_ADDRESS                 49",
          "585: #define THREAD_MC_TLV_PENDING_TSTAMP               51",
          "586: #define THREAD_MC_TLV_DELAY_TIMER                  52",
          "587: #define THREAD_MC_TLV_CHANNEL_MASK                 53",
          "588: #define THREAD_MC_TLV_COUNT                        54",
          "589: #define THREAD_MC_TLV_PERIOD                       55",
          "590: #define THREAD_MC_TLV_SCAN_DURATION                56",
          "591: #define THREAD_MC_TLV_ENERGY_LIST                  57",
          "594: #define THREAD_MC_TLV_DISCOVERY_REQUEST            128",
          "595: #define THREAD_MC_TLV_DISCOVERY_RESPONSE           129",
          "597: static const value_string thread_mc_tlv_vals[] = {",
          "598: { THREAD_MC_TLV_CHANNEL,                   \"Channel\" },",
          "599: { THREAD_MC_TLV_PANID,                     \"PAN ID\" },",
          "600: { THREAD_MC_TLV_XPANID,                    \"Extended PAN ID\" },",
          "601: { THREAD_MC_TLV_NETWORK_NAME,              \"Network Name\" },",
          "602: { THREAD_MC_TLV_PSKC,                      \"PSKc\" },",
          "603: { THREAD_MC_TLV_NETWORK_MASTER_KEY,        \"Network Master Key\" },",
          "604: { THREAD_MC_TLV_NETWORK_KEY_SEQ_CTR,       \"Network Key Sequence Counter\" },",
          "605: { THREAD_MC_TLV_NETWORK_ML_PREFIX,         \"Mesh Local ULA Prefix\" },",
          "606: { THREAD_MC_TLV_STEERING_DATA,             \"Steering Data\" },",
          "607: { THREAD_MC_TLV_BORDER_AGENT_LOCATOR,      \"Border Agent Locator\" },",
          "608: { THREAD_MC_TLV_COMMISSIONER_ID,           \"Commissioner ID\" },",
          "609: { THREAD_MC_TLV_COMMISSIONER_SESSION_ID,   \"Commissioner Session ID\" },",
          "610: { THREAD_MC_TLV_SECURITY_POLICY,           \"Security Policy\" },",
          "611: { THREAD_MC_TLV_GET,                       \"Get\" },",
          "612: { THREAD_MC_TLV_ACTIVE_TSTAMP,             \"Active Timestamp\" },",
          "613: { THREAD_MC_TLV_COMMISSIONER_UDP_PORT,     \"Commissioner UDP Port\" },",
          "614: { THREAD_MC_TLV_STATE,                     \"State\" },",
          "615: { THREAD_MC_TLV_JOINER_DTLS_ENCAP,         \"Joiner DTLS Encapsulation\" },",
          "616: { THREAD_MC_TLV_JOINER_UDP_PORT,           \"Joiner UDP Port\" },",
          "617: { THREAD_MC_TLV_JOINER_IID,                \"Joiner IID\" },",
          "618: { THREAD_MC_TLV_JOINER_ROUTER_LOCATOR,     \"Joiner Router Locator\" },",
          "619: { THREAD_MC_TLV_JOINER_KEK,                \"Joiner KEK\" },",
          "620: { THREAD_MC_TLV_PROVISIONING_URL,          \"Provisioning URL\" },",
          "621: { THREAD_MC_TLV_VENDOR_NAME,               \"Vendor Name\" },",
          "622: { THREAD_MC_TLV_VENDOR_MODEL,              \"Vendor Model\" },",
          "623: { THREAD_MC_TLV_VENDOR_SW_VERSION,         \"Vendor Software Version\" },",
          "624: { THREAD_MC_TLV_VENDOR_DATA,               \"Vendor Data\" },",
          "625: { THREAD_MC_TLV_VENDOR_STACK_VERSION,      \"Vendor Stack Version\" },",
          "626: { THREAD_MC_TLV_UDP_ENCAPSULATION,         \"UDP Encapsulation\" },",
          "627: { THREAD_MC_TLV_IPV6_ADDRESS,              \"IPv6 Address\" },",
          "629: { THREAD_MC_TLV_PENDING_TSTAMP,            \"Pending Timestamp\" },",
          "630: { THREAD_MC_TLV_DELAY_TIMER,               \"Delay Timer\" },",
          "631: { THREAD_MC_TLV_CHANNEL_MASK,              \"Channel Mask\" },",
          "632: { THREAD_MC_TLV_COUNT,                     \"Count\" },",
          "633: { THREAD_MC_TLV_PERIOD,                    \"Period\" },",
          "634: { THREAD_MC_TLV_SCAN_DURATION,             \"Scan Duration\" },",
          "635: { THREAD_MC_TLV_ENERGY_LIST,               \"Energy List\" },",
          "637: { THREAD_MC_TLV_DISCOVERY_REQUEST,         \"Discovery Request\" },",
          "638: { THREAD_MC_TLV_DISCOVERY_RESPONSE,        \"Discovery Response\" },",
          "639: { 0, NULL}",
          "640: };",
          "642: static const value_string thread_mc_state_vals[] = {",
          "643: { -1, \"Reject\" },",
          "644: { 0, \"Pending\" },",
          "645: { 1, \"Accept\" },",
          "646: { 0, NULL}",
          "647: };",
          "649: static const true_false_string thread_mc_tlv_join_intent = {",
          "650:     \"Intending\",",
          "651:     \"Not Intending\"",
          "652: };",
          "654: #define THREAD_NWD_TLV_HAS_ROUTE                    0",
          "655: #define THREAD_NWD_TLV_PREFIX                       1",
          "656: #define THREAD_NWD_TLV_BORDER_ROUTER                2",
          "657: #define THREAD_NWD_TLV_6LOWPAN_ID                   3",
          "658: #define THREAD_NWD_TLV_COMMISSIONING_DATA           4",
          "659: #define THREAD_NWD_TLV_SERVICE                      5",
          "660: #define THREAD_NWD_TLV_SERVER                       6",
          "662: static const value_string thread_nwd_tlv_vals[] = {",
          "663: { THREAD_NWD_TLV_HAS_ROUTE,                 \"Has Route\" },",
          "664: { THREAD_NWD_TLV_PREFIX,                    \"Prefix\" },",
          "665: { THREAD_NWD_TLV_BORDER_ROUTER,             \"Border Router\" },",
          "666: { THREAD_NWD_TLV_6LOWPAN_ID,                \"6LoWPAN ID\" },",
          "667: { THREAD_NWD_TLV_COMMISSIONING_DATA,        \"Commissioning Data\" },",
          "668: { THREAD_NWD_TLV_SERVICE,                   \"Service\" },",
          "669: { THREAD_NWD_TLV_SERVER,                    \"Server\" },",
          "670: { 0, NULL}",
          "671: };",
          "673: #define THREAD_NWD_TLV_TYPE_M       0xFE",
          "674: #define THREAD_NWD_TLV_STABLE_M     0x01",
          "676: static const true_false_string tfs_thread_nwd_tlv_border_router_p = {",
          "677:     \"Autoconfigured preferred\",",
          "678:     \"Autoconfigured deprecated\"",
          "679: };",
          "681: static const true_false_string tfs_thread_nwd_tlv_border_router_c = {",
          "682:     \"Additional config. data\",",
          "683:     \"No additional config. data\"",
          "684: };",
          "686: static const true_false_string tfs_thread_nwd_tlv_border_router_o = {",
          "687:     \"On mesh\",",
          "688:     \"Not on mesh\"",
          "689: };",
          "692: static const value_string thread_bcn_tlv_vals[] = {",
          "693:     { THREAD_BCN_TLV_STEERING_DATA, \"Steering Data\" },",
          "694:     { 0, NULL }",
          "695: };",
          "698: static gboolean thread_coap_decode = FALSE;",
          "699: static gboolean thread_use_pan_id_in_key = FALSE;",
          "700: static const gchar *thread_seq_ctr_str = NULL;",
          "701: static gboolean thread_auto_acq_seq_ctr = TRUE;",
          "704: static gboolean thread_seq_ctr_acqd = FALSE;",
          "705: static guint8 thread_seq_ctr_bytes[4];",
          "706: static const guint8 thread_well_known_key[IEEE802154_CIPHER_SIZE] =",
          "707: { 0x78, 0x58, 0x16, 0x86, 0xfd, 0xb4, 0x58, 0x0f, 0xb0, 0x92, 0x54, 0x6a, 0xec, 0xbd, 0x15, 0x66 };",
          "709: static GByteArray *set_thread_seq_ctr_from_key_index(guint8 key_index)",
          "710: {",
          "711:     GByteArray *seq_ctr_bytes = NULL;",
          "713:     seq_ctr_bytes = g_byte_array_new();",
          "714:     if (thread_seq_ctr_acqd) {",
          "715:         seq_ctr_bytes = g_byte_array_set_size(seq_ctr_bytes, 4);",
          "716:         memcpy(seq_ctr_bytes->data, thread_seq_ctr_bytes, 4);",
          "717:     } else {",
          "718:         hex_str_to_bytes(thread_seq_ctr_str, seq_ctr_bytes, FALSE);",
          "719:         if (seq_ctr_bytes->len != 4) {",
          "721:             seq_ctr_bytes = g_byte_array_set_size(seq_ctr_bytes, 4);",
          "722:             memset(seq_ctr_bytes->data, 0, 4);",
          "723:         }",
          "724:     }",
          "726:     seq_ctr_bytes->data[3] = (seq_ctr_bytes->data[3] & 0x80) + ((key_index - 1) & 0x7F);",
          "728:     return seq_ctr_bytes;",
          "729: }",
          "731: static void create_thread_temp_keys(GByteArray *seq_ctr_bytes, guint16 src_pan, ieee802154_key_t* key, unsigned char *mac_key, unsigned char *mle_key)",
          "732: {",
          "733:     GByteArray *bytes;",
          "734:     char       buffer[10];",
          "735:     gboolean   res;",
          "736:     gboolean   key_valid;",
          "737:     gboolean   verbatim_key = TRUE;",
          "740:     bytes = g_byte_array_new();",
          "741:     res = hex_str_to_bytes(key->pref_key, bytes, FALSE);",
          "742:     key_valid = (res && bytes->len >= IEEE802154_CIPHER_SIZE);",
          "743:     if (key_valid) {",
          "744:         if (thread_use_pan_id_in_key) {",
          "746:             bytes->data[0] = (guint8)(src_pan & 0xFF);",
          "747:             bytes->data[1] = (guint8)(src_pan >> 8);",
          "748:         }",
          "749:         if (key->hash_type != KEY_HASH_NONE) {",
          "750:             char digest[32];",
          "752:             if (key->hash_type == KEY_HASH_THREAD) {",
          "753:                 memcpy(buffer, seq_ctr_bytes->data, 4);",
          "756:                 if (!ws_hmac_buffer(GCRY_MD_SHA256, digest, buffer, 10, bytes->data, IEEE802154_CIPHER_SIZE)) {",
          "758:                     if (mac_key) {",
          "759:                         memcpy(mac_key, &digest[IEEE802154_CIPHER_SIZE], IEEE802154_CIPHER_SIZE);",
          "760:                     }",
          "762:                     if (mle_key) {",
          "763:                         memcpy(mle_key, digest, IEEE802154_CIPHER_SIZE);",
          "764:                     }",
          "765:                     verbatim_key = FALSE;",
          "766:                 }",
          "767:             }",
          "768:         }",
          "769:         if (verbatim_key) {",
          "771:             if (mac_key) {",
          "772:                 memcpy(mac_key, bytes->data, IEEE802154_CIPHER_SIZE);",
          "773:             }",
          "774:             if (mle_key) {",
          "775:                 memcpy(mle_key, bytes->data, IEEE802154_CIPHER_SIZE);",
          "776:             }",
          "777:         }",
          "778:     }",
          "779:     g_byte_array_free(bytes, TRUE);",
          "780: }",
          "783: static gboolean set_thread_mac_key(ieee802154_packet * packet, unsigned char* key, unsigned char* alt_key, ieee802154_key_t* uat_key)",
          "784: {",
          "785:     GByteArray *seq_ctr_bytes = NULL;",
          "787:     if (packet->key_id_mode == KEY_ID_MODE_KEY_INDEX) {",
          "788:         seq_ctr_bytes = set_thread_seq_ctr_from_key_index(packet->key_index);",
          "789:     } else if ((packet->key_id_mode == KEY_ID_MODE_KEY_EXPLICIT_4) &&",
          "790:                (packet->key_index == IEEE802154_THR_WELL_KNOWN_KEY_INDEX) &&",
          "791:                (packet->key_source.addr32 == IEEE802154_THR_WELL_KNOWN_KEY_SRC))",
          "792:     {",
          "794:         memcpy(key, thread_well_known_key, IEEE802154_CIPHER_SIZE);",
          "795:         return TRUE;",
          "796:     }",
          "797:     if (seq_ctr_bytes != NULL) {",
          "798:         create_thread_temp_keys(seq_ctr_bytes, packet->src_pan, uat_key, key, NULL);",
          "800:         seq_ctr_bytes->data[3] ^= 0x80;",
          "801:         create_thread_temp_keys(seq_ctr_bytes, packet->src_pan, uat_key, alt_key, NULL);",
          "802:         g_byte_array_free(seq_ctr_bytes, TRUE);",
          "803:         return TRUE;",
          "804:     }",
          "806:     return FALSE;",
          "807: }",
          "810: static gboolean set_thread_mle_key(ieee802154_packet * packet, unsigned char* key, unsigned char* alt_key, ieee802154_key_t* uat_key)",
          "811: {",
          "812:     GByteArray *seq_ctr_bytes = NULL;",
          "813:     if (packet->key_id_mode == KEY_ID_MODE_KEY_INDEX) {",
          "814:         seq_ctr_bytes = set_thread_seq_ctr_from_key_index(packet->key_index);",
          "815:     }",
          "816:     else if (packet->key_id_mode == KEY_ID_MODE_KEY_EXPLICIT_4) {",
          "818:         seq_ctr_bytes = g_byte_array_new();",
          "819:         seq_ctr_bytes = g_byte_array_set_size(seq_ctr_bytes, 4);",
          "820:         seq_ctr_bytes->data[0] = (packet->key_source.addr32 >> 24) & 0xFF;",
          "821:         seq_ctr_bytes->data[1] = (packet->key_source.addr32 >> 16) & 0xFF;",
          "822:         seq_ctr_bytes->data[2] = (packet->key_source.addr32 >> 8) & 0xFF;",
          "823:         seq_ctr_bytes->data[3] = packet->key_source.addr32 & 0xFF;",
          "825:         if (thread_auto_acq_seq_ctr && !thread_seq_ctr_acqd) {",
          "826:             memcpy(thread_seq_ctr_bytes, seq_ctr_bytes->data, 4);",
          "827:             thread_seq_ctr_acqd = TRUE;",
          "828:         }",
          "829:     }",
          "830:     if (seq_ctr_bytes != NULL) {",
          "831:         create_thread_temp_keys(seq_ctr_bytes, packet->src_pan, uat_key, NULL, key);",
          "833:         seq_ctr_bytes->data[3] ^= 0x80;",
          "834:         create_thread_temp_keys(seq_ctr_bytes, packet->src_pan, uat_key, NULL, alt_key);",
          "835:         g_byte_array_free(seq_ctr_bytes, TRUE);",
          "836:         return TRUE;",
          "837:     }",
          "839:     return FALSE;",
          "840: }",
          "842: static guint",
          "843: count_bits_in_byte(guint8 byte)",
          "844: {",
          "860:                                    4  /* 0b1111 */};",
          "861:     return lut[byte >> 4] + lut[byte & 0xf];",
          "862: }",
          "864: static guint",
          "865: get_chancount(tvbuff_t *tvb)",
          "866: {",
          "867:     guint         offset;",
          "868:     guint8        tlv_type;",
          "869:     guint16       tlv_len;",
          "870:     tlv_len_len_e tlv_len_len;",
          "871:     guint         chancount = THREAD_MC_INVALID_CHAN_COUNT;",
          "873:     offset = 0;",
          "876:     while (tvb_offset_exists(tvb, offset)) {",
          "880:         tlv_type = tvb_get_guint8(tvb, offset);",
          "881:         tlv_len = (guint16)tvb_get_guint8(tvb, offset + 1);",
          "884:         if (THREAD_TLV_LENGTH_ESC == tlv_len) {",
          "886:             tlv_len = tvb_get_ntohs(tvb, offset + 2);",
          "887:             tlv_len_len = TLV_LEN_LEN16;",
          "888:         } else {",
          "889:             tlv_len_len = TLV_LEN_LEN8;",
          "890:         }",
          "893:         offset += 1 + tlv_len_len;",
          "895:         switch(tlv_type) {",
          "897:             case THREAD_MC_TLV_CHANNEL_MASK:",
          "898:                 {",
          "899:                     int i, j;",
          "900:                     guint8 entries = 0;",
          "901:                     guint16 check_len = tlv_len;",
          "903:                     guint8 masklen;",
          "906:                     while (check_len > 0) {",
          "908:                         masklen = tvb_get_guint8(tvb, check_offset);",
          "909:                         if (masklen == 0) {",
          "911:                         }",
          "913:                         check_offset += masklen;",
          "914:                         check_len -= masklen;",
          "915:                         entries++;",
          "916:                     }",
          "918:                     if (check_len != 0) {",
          "921:                         return chancount;",
          "922:                     } else {",
          "923:                         chancount = 0;",
          "924:                         for (i = 0; i < entries; i++) {",
          "926:                             offset++;",
          "927:                             masklen = tvb_get_guint8(tvb, offset);",
          "928:                             offset++;",
          "930:                             for (j = 0; j < masklen; j++) {",
          "931:                                 chancount += count_bits_in_byte(tvb_get_guint8(tvb, offset));",
          "932:                                 offset++;",
          "933:                             }",
          "934:                         }",
          "935:                     }",
          "936:                 }",
          "937:                 break;",
          "939:             default:",
          "941:                 offset += tlv_len;",
          "942:         }",
          "943:     }",
          "944:     return chancount;",
          "945: }",
          "947: static int",
          "948: dissect_thread_address(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)",
          "949: {",
          "950:     proto_item  *proto_root;",
          "951:     proto_tree  *thread_address_tree;",
          "952:     proto_tree  *tlv_tree;",
          "953:     tvbuff_t    *sub_tvb;",
          "954:     guint       offset = 0;",
          "955:     proto_item  *ti;",
          "956:     guint8      tlv_type, tlv_len;",
          "959:     proto_root = proto_tree_add_item(tree, proto_thread_address, tvb, 0, tvb_reported_length(tvb), ENC_NA);",
          "960:     thread_address_tree = proto_item_add_subtree(proto_root, ett_thread_address);",
          "963:     while (tvb_offset_exists(tvb, offset)) {",
          "967:         tlv_len = tvb_get_guint8(tvb, offset + 1);",
          "969:         ti = proto_tree_add_item(thread_address_tree, hf_thread_address_tlv, tvb, offset, tlv_len+2, ENC_NA);",
          "970:         tlv_tree = proto_item_add_subtree(ti, ett_thread_address_tlv);",
          "973:         proto_tree_add_item(tlv_tree, hf_thread_address_tlv_type, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "974:         tlv_type = tvb_get_guint8(tvb, offset);",
          "975:         offset++;",
          "978:         proto_item_append_text(ti, \" (%s)\", val_to_str(tlv_type, thread_address_tlv_vals, \"Unknown (%d)\"));",
          "981:         proto_tree_add_item(tlv_tree, hf_thread_address_tlv_length, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "982:         offset++;",
          "984:         switch(tlv_type) {",
          "985:             case THREAD_ADDRESS_TLV_TARGET_EID:",
          "986:                 {",
          "988:                     if (tlv_len != 16) {",
          "989:                         expert_add_info(pinfo, proto_root, &ei_thread_address_len_size_mismatch);",
          "990:                         proto_tree_add_item(tlv_tree, hf_thread_address_tlv_unknown, tvb, offset, tlv_len, ENC_NA);",
          "991:                     } else {",
          "993:                         proto_tree_add_item(tlv_tree, hf_thread_address_tlv_target_eid, tvb, offset, tlv_len, ENC_NA);",
          "994:                     }",
          "995:                     offset += tlv_len;",
          "996:                 }",
          "997:                 break;",
          "999:             case THREAD_ADDRESS_TLV_EXT_MAC_ADDR:",
          "1000:                 {",
          "1002:                     if (tlv_len != 8) {",
          "1003:                         expert_add_info(pinfo, proto_root, &ei_thread_address_len_size_mismatch);",
          "1004:                         proto_tree_add_item(tlv_tree, hf_thread_address_tlv_unknown, tvb, offset, tlv_len, ENC_NA);",
          "1005:                     } else {",
          "1007:                         proto_tree_add_item(tlv_tree, hf_thread_address_tlv_ext_mac_addr, tvb, offset, tlv_len, ENC_BIG_ENDIAN);",
          "1008:                     }",
          "1009:                     offset += tlv_len;",
          "1010:                 }",
          "1011:                 break;",
          "1013:             case THREAD_ADDRESS_TLV_RLOC16:",
          "1014:                 {",
          "1016:                     if (tlv_len != 2) {",
          "1017:                         expert_add_info(pinfo, proto_root, &ei_thread_address_len_size_mismatch);",
          "1018:                         proto_tree_add_item(tlv_tree, hf_thread_address_tlv_unknown, tvb, offset, tlv_len, ENC_NA);",
          "1019:                     } else {",
          "1021:                         proto_tree_add_item(tlv_tree, hf_thread_address_tlv_rloc16, tvb, offset, tlv_len, ENC_BIG_ENDIAN);",
          "1022:                     }",
          "1023:                     offset += tlv_len;",
          "1024:                 }",
          "1025:                 break;",
          "1027:             case THREAD_ADDRESS_TLV_ML_EID:",
          "1028:                 {",
          "1030:                     if (tlv_len != 8) {",
          "1031:                         expert_add_info(pinfo, proto_root, &ei_thread_address_len_size_mismatch);",
          "1032:                         proto_tree_add_item(tlv_tree, hf_thread_address_tlv_unknown, tvb, offset, tlv_len, ENC_NA);",
          "1033:                     } else {",
          "1035:                         proto_tree_add_item(tlv_tree, hf_thread_address_tlv_ml_eid, tvb, offset, tlv_len, ENC_NA);",
          "1036:                     }",
          "1037:                     offset += tlv_len;",
          "1038:                 }",
          "1039:                 break;",
          "1041:             case THREAD_ADDRESS_TLV_STATUS:",
          "1042:                 {",
          "1044:                     if (tlv_len != 1) {",
          "1045:                         expert_add_info(pinfo, proto_root, &ei_thread_address_len_size_mismatch);",
          "1046:                         proto_tree_add_item(tlv_tree, hf_thread_address_tlv_unknown, tvb, offset, tlv_len, ENC_NA);",
          "1047:                     } else {",
          "1049:                         proto_tree_add_item(tlv_tree, hf_thread_address_tlv_status, tvb, offset, tlv_len, ENC_BIG_ENDIAN);",
          "1050:                     }",
          "1051:                     offset += tlv_len;",
          "1052:                 }",
          "1053:                 break;",
          "1055:             case THREAD_ADDRESS_TLV_LAST_TRANSACTION_TIME:",
          "1056:                 {",
          "1058:                     if (tlv_len != 4) {",
          "1059:                         expert_add_info(pinfo, proto_root, &ei_thread_address_len_size_mismatch);",
          "1060:                         proto_tree_add_item(tlv_tree, hf_thread_address_tlv_unknown, tvb, offset, tlv_len, ENC_NA);",
          "1061:                     } else {",
          "1063:                         proto_tree_add_item(tlv_tree, hf_thread_address_tlv_last_transaction_time, tvb, offset, tlv_len, ENC_BIG_ENDIAN);",
          "1064:                     }",
          "1065:                     offset += tlv_len;",
          "1066:                 }",
          "1067:                 break;",
          "1069:             case THREAD_ADDRESS_TLV_ROUTER_MASK:",
          "1070:                 {",
          "1072:                     if (tlv_len != 9) {",
          "1073:                         expert_add_info(pinfo, proto_root, &ei_thread_address_len_size_mismatch);",
          "1074:                         proto_tree_add_item(tlv_tree, hf_thread_address_tlv_unknown, tvb, offset, tlv_len, ENC_NA);",
          "1075:                         offset += tlv_len;",
          "1076:                     } else {",
          "1078:                         proto_tree_add_item(tlv_tree, hf_thread_address_tlv_router_mask_id_seq, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "1079:                         offset++;",
          "1092:                         proto_tree_add_item(tlv_tree, hf_thread_address_tlv_router_mask_assigned, tvb, offset, 8, ENC_NA);",
          "1093:                         offset += 8;",
          "1094:                     }",
          "1095:                 }",
          "1096:                 break;",
          "1098:             case THREAD_ADDRESS_TLV_ND_OPTION:",
          "1100:                 proto_tree_add_item(tlv_tree, hf_thread_address_tlv_nd_option, tvb, offset, tlv_len, ENC_NA);",
          "1101:                 offset += tlv_len;",
          "1102:                 break;",
          "1104:             case THREAD_ADDRESS_TLV_ND_DATA:",
          "1106:                 proto_tree_add_item(tlv_tree, hf_thread_address_tlv_nd_data, tvb, offset, tlv_len, ENC_NA);",
          "1107:                 offset += tlv_len;",
          "1108:                 break;",
          "1110:             case THREAD_ADDRESS_TLV_THREAD_NETWORK_DATA:",
          "1111:                 if (tlv_len > 0) {",
          "1112:                     sub_tvb = tvb_new_subset_length(tvb, offset, tlv_len);",
          "1113:                     call_dissector(thread_address_nwd_handle, sub_tvb, pinfo, tlv_tree);",
          "1114:                 }",
          "1115:                 offset += tlv_len;",
          "1116:                 break;",
          "1118:             default:",
          "1119:                 proto_tree_add_item(tlv_tree, hf_thread_address_tlv_unknown, tvb, offset, tlv_len, ENC_NA);",
          "1120:                 offset += tlv_len;",
          "1121:         }",
          "1122:     }",
          "1123:     return tvb_captured_length(tvb);",
          "1124: }",
          "1126: static int",
          "1127: dissect_thread_dg(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void *data _U_)",
          "1128: {",
          "1129:     proto_item    *proto_root;",
          "1130:     proto_tree    *thread_dg_tree;",
          "1131:     proto_tree    *tlv_tree;",
          "1132:     guint         offset = 0;",
          "1133:     proto_item    *ti;",
          "1134:     guint8        tlv_type;",
          "1135:     guint16       tlv_len;",
          "1136:     tlv_len_len_e tlv_len_len;",
          "1139:     proto_root = proto_tree_add_item(tree, proto_thread_dg, tvb, 0, tvb_reported_length(tvb), ENC_NA);",
          "1140:     thread_dg_tree = proto_item_add_subtree(proto_root, ett_thread_dg);",
          "1143:     while (tvb_offset_exists(tvb, offset)) {",
          "1147:         tlv_type = tvb_get_guint8(tvb, offset);",
          "1148:         tlv_len = (guint16)tvb_get_guint8(tvb, offset + 1);",
          "1151:         if (THREAD_TLV_LENGTH_ESC == tlv_len) {",
          "1153:             tlv_len = tvb_get_ntohs(tvb, offset + 2);",
          "1154:             tlv_len_len = TLV_LEN_LEN16;",
          "1155:         } else {",
          "1156:             tlv_len_len = TLV_LEN_LEN8;",
          "1157:         }",
          "1160:         ti = proto_tree_add_item(thread_dg_tree, hf_thread_dg_tlv, tvb, offset, 1 + tlv_len_len + tlv_len, ENC_NA);",
          "1161:         tlv_tree = proto_item_add_subtree(ti, ett_thread_dg_tlv);",
          "1164:         proto_tree_add_item(tlv_tree, hf_thread_dg_tlv_type, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "1165:         offset++;",
          "1168:         proto_item_append_text(ti, \" (%s)\", val_to_str(tlv_type, thread_dg_tlv_vals, \"Unknown (%d)\"));",
          "1171:         switch (tlv_len_len) {",
          "1172:             case TLV_LEN_LEN8:",
          "1173:                 proto_tree_add_item(tlv_tree, hf_thread_dg_tlv_length8, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "1174:                 break;",
          "1175:             case TLV_LEN_LEN16:",
          "1176:                 proto_tree_add_item(tlv_tree, hf_thread_dg_tlv_length16, tvb, offset + 1, 2, ENC_BIG_ENDIAN);",
          "1177:                 break;",
          "1178:             default:",
          "1179:                 break;",
          "1180:         }",
          "1181:         offset += tlv_len_len;",
          "1183:         switch(tlv_type) {",
          "1184:             case THREAD_DG_TLV_TYPE_LIST:",
          "1185:                 {",
          "1186:                     int i;",
          "1188:                     for (i = 0; i < tlv_len; i++) {",
          "1189:                         proto_tree_add_item(tlv_tree, hf_thread_dg_tlv_type, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "1190:                         offset++;",
          "1191:                     }",
          "1192:                 }",
          "1193:                 break;",
          "1195:             case THREAD_DG_TLV_EXT_MAC_ADDR:",
          "1196:             case THREAD_DG_TLV_ADDRESS16:",
          "1197:             case THREAD_DG_TLV_MODE:",
          "1198:             case THREAD_DG_TLV_TIMEOUT:",
          "1199:             case THREAD_DG_TLV_CONNECTIVITY:",
          "1200:             case THREAD_DG_TLV_ROUTE64:",
          "1201:             case THREAD_DG_TLV_LEADER_DATA:",
          "1202:             case THREAD_DG_TLV_NETWORK_DATA:",
          "1203:             case THREAD_DG_TLV_IPV6_ADDR_LIST:",
          "1205:             case THREAD_DG_TLV_MAC_COUNTERS:",
          "1206:             case THREAD_DG_TLV_BATTERY_LEVEL:",
          "1207:             case THREAD_DG_TLV_VOLTAGE:",
          "1208:             case THREAD_DG_TLV_CHILD_TABLE:",
          "1209:             case THREAD_DG_TLV_CHANNEL_PAGES:",
          "1210:                 proto_tree_add_item(tlv_tree, hf_thread_dg_tlv_general, tvb, offset, tlv_len, ENC_NA);",
          "1211:                 offset += tlv_len;",
          "1212:                 break;",
          "1214:             default:",
          "1215:                 proto_tree_add_item(tlv_tree, hf_thread_dg_tlv_unknown, tvb, offset, tlv_len, ENC_NA);",
          "1216:                 offset += tlv_len;",
          "1217:         }",
          "1218:     }",
          "1219:     return tvb_captured_length(tvb);",
          "1220: }",
          "1222: static int",
          "1223: dissect_thread_mc(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)",
          "1224: {",
          "1225:     proto_item    *proto_root;",
          "1226:     proto_tree    *thread_mc_tree;",
          "1227:     proto_tree    *tlv_tree;",
          "1228:     guint         offset = 0;",
          "1229:     proto_item    *ti;",
          "1230:     proto_item    *pi;",
          "1231:     guint8        tlv_type;",
          "1232:     guint16       tlv_len;",
          "1233:     tlv_len_len_e tlv_len_len;",
          "1234:     guint         chancount;",
          "1238:     proto_root = proto_tree_add_item(tree, proto_thread_mc, tvb, 0, tvb_reported_length(tvb), ENC_NA);",
          "1239:     thread_mc_tree = proto_item_add_subtree(proto_root, ett_thread_mc);",
          "1242:     chancount = get_chancount(tvb);",
          "1245:     while (tvb_offset_exists(tvb, offset)) {",
          "1249:         tlv_type = tvb_get_guint8(tvb, offset);",
          "1250:         tlv_len = (guint16)tvb_get_guint8(tvb, offset + 1);",
          "1253:         if (THREAD_TLV_LENGTH_ESC == tlv_len) {",
          "1255:             tlv_len = tvb_get_ntohs(tvb, offset + 2);",
          "1256:             tlv_len_len = TLV_LEN_LEN16;",
          "1257:         } else {",
          "1258:             tlv_len_len = TLV_LEN_LEN8;",
          "1259:         }",
          "1262:         ti = proto_tree_add_item(thread_mc_tree, hf_thread_mc_tlv, tvb, offset, 1 + tlv_len_len + tlv_len, ENC_NA);",
          "1263:         tlv_tree = proto_item_add_subtree(ti, ett_thread_mc_tlv);",
          "1266:         proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_type, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "1267:         offset++;",
          "1270:         proto_item_append_text(ti, \" (%s)\", val_to_str(tlv_type, thread_mc_tlv_vals, \"Unknown (%d)\"));",
          "1273:         switch (tlv_len_len) {",
          "1274:             case TLV_LEN_LEN8:",
          "1275:                 proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_length8, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "1276:                 break;",
          "1277:             case TLV_LEN_LEN16:",
          "1278:                 proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_length16, tvb, offset + 1, 2, ENC_BIG_ENDIAN);",
          "1279:                 break;",
          "1280:             default:",
          "1281:                 break;",
          "1282:         }",
          "1283:         offset += tlv_len_len;",
          "1285:         switch(tlv_type) {",
          "1286:             case THREAD_MC_TLV_CHANNEL:",
          "1287:                 {",
          "1289:                     if (tlv_len != 3) {",
          "1290:                         expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);",
          "1291:                         proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);",
          "1292:                     } else {",
          "1294:                         proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_channel_page, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "1296:                         proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_channel, tvb, offset+1, 2, ENC_BIG_ENDIAN);",
          "1297:                     }",
          "1298:                     offset += tlv_len;",
          "1299:                 }",
          "1300:                 break;",
          "1302:             case THREAD_MC_TLV_PANID:",
          "1303:                 {",
          "1305:                     if (tlv_len != 2) {",
          "1306:                         expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);",
          "1307:                         proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);",
          "1308:                     } else {",
          "1310:                         proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_pan_id, tvb, offset, tlv_len, ENC_BIG_ENDIAN);",
          "1311:                     }",
          "1312:                     offset += tlv_len;",
          "1313:                 }",
          "1314:                 break;",
          "1316:             case THREAD_MC_TLV_XPANID:",
          "1317:                 {",
          "1319:                     if (tlv_len != 8) {",
          "1320:                         expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);",
          "1321:                         proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);",
          "1322:                     } else {",
          "1324:                         proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_xpan_id, tvb, offset, tlv_len, ENC_BIG_ENDIAN);",
          "1325:                     }",
          "1326:                     offset += tlv_len;",
          "1327:                 }",
          "1328:                 break;",
          "1330:             case THREAD_MC_TLV_NETWORK_NAME:",
          "1331:                 {",
          "1333:                     if (tlv_len > 16) {",
          "1334:                         expert_add_info(pinfo, proto_root, &ei_thread_mc_len_too_long);",
          "1335:                         proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);",
          "1336:                     } else {",
          "1337:                         proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_net_name, tvb, offset, tlv_len, ENC_NA|ENC_UTF_8);",
          "1338:                     }",
          "1339:                     offset += tlv_len;",
          "1340:                 }",
          "1341:                 break;",
          "1343:             case THREAD_MC_TLV_PSKC:",
          "1344:                 {",
          "1346:                     if (tlv_len != 16) {",
          "1347:                         expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);",
          "1348:                         proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);",
          "1349:                     } else {",
          "1350:                         proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_pskc, tvb, offset, tlv_len, ENC_NA);",
          "1351:                     }",
          "1352:                     offset += tlv_len;",
          "1353:                 }",
          "1354:                 break;",
          "1356:             case THREAD_MC_TLV_NETWORK_MASTER_KEY:",
          "1357:                 {",
          "1359:                     if (tlv_len != 16) {",
          "1360:                         expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);",
          "1361:                         proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);",
          "1362:                     } else {",
          "1363:                         proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_master_key, tvb, offset, tlv_len, ENC_NA);",
          "1364:                     }",
          "1365:                     offset += tlv_len;",
          "1366:                 }",
          "1367:                 break;",
          "1369:             case THREAD_MC_TLV_NETWORK_KEY_SEQ_CTR:",
          "1370:                 {",
          "1372:                     if (tlv_len != 4) {",
          "1373:                         expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);",
          "1374:                         proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);",
          "1375:                     } else {",
          "1376:                         proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_net_key_seq_ctr, tvb, offset, tlv_len, ENC_NA);",
          "1377:                     }",
          "1378:                     offset += tlv_len;",
          "1379:                 }",
          "1380:                 break;",
          "1382:             case THREAD_MC_TLV_NETWORK_ML_PREFIX:",
          "1383:                 {",
          "1385:                     if (tlv_len != 8) {",
          "1386:                         expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);",
          "1387:                         proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);",
          "1388:                     } else {",
          "1389:                         struct e_in6_addr prefix;",
          "1391:                         memset(&prefix, 0, sizeof(prefix));",
          "1392:                         tvb_memcpy(tvb, (guint8 *)&prefix.bytes, offset, tlv_len);",
          "1393:                         pi = proto_tree_add_ipv6(tlv_tree, hf_thread_mc_tlv_ml_prefix, tvb, offset, tlv_len, &prefix);",
          "1394:                         proto_item_append_text(pi, \"/%d\", tlv_len * 8);",
          "1395:                     }",
          "1396:                     offset += tlv_len;",
          "1397:                 }",
          "1398:                 break;",
          "1400:             case THREAD_MC_TLV_STEERING_DATA:",
          "1401:                 {",
          "1403:                     if (tlv_len > 16) {",
          "1404:                         expert_add_info(pinfo, proto_root, &ei_thread_mc_len_too_long);",
          "1405:                         proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);",
          "1406:                     } else {",
          "1408:                         proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_steering_data, tvb, offset, tlv_len, ENC_NA);",
          "1409:                     }",
          "1410:                     offset += tlv_len;",
          "1411:                 }",
          "1412:                 break;",
          "1414:             case THREAD_MC_TLV_BORDER_AGENT_LOCATOR:",
          "1415:                 {",
          "1417:                     if (tlv_len != 2) {",
          "1418:                         expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);",
          "1419:                         proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);",
          "1420:                     } else {",
          "1421:                         proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_ba_locator, tvb, offset, tlv_len, ENC_NA);",
          "1422:                     }",
          "1423:                     offset += tlv_len;",
          "1424:                 }",
          "1425:                 break;",
          "1427:             case THREAD_MC_TLV_COMMISSIONER_ID:",
          "1428:                 {",
          "1430:                     if (tlv_len > 64) {",
          "1431:                         expert_add_info(pinfo, proto_root, &ei_thread_mc_len_too_long);",
          "1432:                         proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);",
          "1433:                     } else {",
          "1434:                         proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_commissioner_id, tvb, offset, tlv_len, ENC_NA|ENC_UTF_8);",
          "1435:                     }",
          "1436:                     offset += tlv_len;",
          "1437:                 }",
          "1438:                 break;",
          "1440:             case THREAD_MC_TLV_COMMISSIONER_SESSION_ID:",
          "1441:                 {",
          "1443:                     if (tlv_len != 2) {",
          "1444:                         expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);",
          "1445:                         proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);",
          "1446:                     } else {",
          "1447:                         proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_commissioner_sess_id, tvb, offset, tlv_len, ENC_NA);",
          "1448:                     }",
          "1449:                     offset += tlv_len;",
          "1450:                 }",
          "1451:                 break;",
          "1453:             case THREAD_MC_TLV_SECURITY_POLICY:",
          "1454:                 {",
          "1456:                     if (tlv_len != 3) {",
          "1457:                         expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);",
          "1458:                         proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);",
          "1459:                         offset += tlv_len;",
          "1460:                     } else {",
          "1461:                         proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_sec_policy_rot, tvb, offset, 2, ENC_BIG_ENDIAN);",
          "1462:                         offset += 2;",
          "1463:                         proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_sec_policy_o, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "1464:                         proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_sec_policy_n, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "1465:                         proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_sec_policy_r, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "1466:                         proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_sec_policy_c, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "1467:                         proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_sec_policy_b, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "1468:                         offset++;",
          "1469:                     }",
          "1470:                 }",
          "1471:                 break;",
          "1473:             case THREAD_MC_TLV_GET:",
          "1474:                 {",
          "1475:                     int i;",
          "1477:                     for (i = 0; i < tlv_len; i++) {",
          "1478:                         proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_type, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "1479:                         offset++;",
          "1480:                     }",
          "1481:                 }",
          "1482:                 break;",
          "1484:             case THREAD_MC_TLV_ACTIVE_TSTAMP:",
          "1485:             case THREAD_MC_TLV_PENDING_TSTAMP:",
          "1486:                 {",
          "1487:                     nstime_t timestamp;",
          "1489:                     if (tlv_len != 8) {",
          "1490:                         expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);",
          "1491:                         proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);",
          "1492:                     } else {",
          "1494:                         timestamp.secs = (time_t)tvb_get_ntoh48(tvb, offset);",
          "1495:                         timestamp.nsecs = (int)lround((double)(tvb_get_ntohs(tvb, offset + 6) >> 1) * THREAD_MC_32768_TO_NSEC_FACTOR);",
          "1496:                         if (tlv_type == THREAD_MC_TLV_ACTIVE_TSTAMP) {",
          "1497:                             proto_tree_add_time(tlv_tree, hf_thread_mc_tlv_active_tstamp, tvb, offset, 8, &timestamp);",
          "1498:                         } else {",
          "1499:                             proto_tree_add_time(tlv_tree, hf_thread_mc_tlv_pending_tstamp, tvb, offset, 8, &timestamp);",
          "1500:                         }",
          "1501:                     }",
          "1502:                     offset += tlv_len;",
          "1503:                 }",
          "1504:                 break;",
          "1506:             case THREAD_MC_TLV_STATE:",
          "1507:                 {",
          "1509:                     if (tlv_len != 1) {",
          "1510:                         expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);",
          "1511:                         proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);",
          "1512:                     } else {",
          "1513:                         proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_state, tvb, offset, tlv_len, ENC_BIG_ENDIAN);",
          "1514:                     }",
          "1515:                     offset += tlv_len;",
          "1516:                 }",
          "1517:                 break;",
          "1519:             case THREAD_MC_TLV_JOINER_DTLS_ENCAP:",
          "1520:                 {",
          "1521:                     tvbuff_t *sub_tvb;",
          "1523:                     if (tlv_len > 0) {",
          "1524:                         sub_tvb = tvb_new_subset_length(tvb, offset, tlv_len);",
          "1525:                         call_dissector(thread_dtls_handle, sub_tvb, pinfo, tree);",
          "1526:                     }",
          "1527:                     offset += tlv_len;",
          "1528:                 }",
          "1529:                 break;",
          "1531:             case THREAD_MC_TLV_COMMISSIONER_UDP_PORT:",
          "1532:             case THREAD_MC_TLV_JOINER_UDP_PORT:",
          "1533:                 {",
          "1534:                     if (tlv_len != 2) {",
          "1535:                         expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);",
          "1536:                         proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);",
          "1537:                     } else {",
          "1539:                         proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_udp_port, tvb, offset, tlv_len, ENC_BIG_ENDIAN);",
          "1540:                     }",
          "1541:                     offset += tlv_len;",
          "1542:                 }",
          "1543:                 break;",
          "1545:             case THREAD_MC_TLV_JOINER_IID:",
          "1546:                 {",
          "1547:                     if (tlv_len != 8) {",
          "1548:                         expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);",
          "1549:                         proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);",
          "1550:                     } else {",
          "1552:                         proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_iid, tvb, offset, tlv_len, ENC_NA);",
          "1553:                     }",
          "1554:                     offset += tlv_len;",
          "1555:                 }",
          "1556:                 break;",
          "1558:             case THREAD_MC_TLV_JOINER_ROUTER_LOCATOR:",
          "1559:                 {",
          "1560:                     if (tlv_len != 2) {",
          "1561:                         expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);",
          "1562:                         proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);",
          "1563:                     } else {",
          "1564:                         proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_jr_locator, tvb, offset, tlv_len, ENC_NA);",
          "1565:                     }",
          "1566:                     offset += tlv_len;",
          "1567:                 }",
          "1568:                 break;",
          "1570:             case THREAD_MC_TLV_JOINER_KEK:",
          "1571:                 {",
          "1572:                     if (tlv_len != 16) {",
          "1573:                         expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);",
          "1574:                         proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);",
          "1575:                     } else {",
          "1576:                         proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_kek, tvb, offset, tlv_len, ENC_NA);",
          "1577:                     }",
          "1578:                     offset += tlv_len;",
          "1579:                 }",
          "1580:                 break;",
          "1582:             case THREAD_MC_TLV_PROVISIONING_URL:",
          "1583:                 {",
          "1585:                     if (tlv_len > 64) {",
          "1586:                         expert_add_info(pinfo, proto_root, &ei_thread_mc_len_too_long);",
          "1587:                         proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);",
          "1588:                     } else {",
          "1589:                         proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_provisioning_url, tvb, offset, tlv_len, ENC_NA|ENC_UTF_8);",
          "1590:                     }",
          "1591:                     offset += tlv_len;",
          "1592:                 }",
          "1593:                 break;",
          "1595:             case THREAD_MC_TLV_VENDOR_NAME:",
          "1596:                 {",
          "1598:                     if (tlv_len > 32) {",
          "1599:                         expert_add_info(pinfo, proto_root, &ei_thread_mc_len_too_long);",
          "1600:                         proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);",
          "1601:                     } else {",
          "1602:                         proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_vendor_name, tvb, offset, tlv_len, ENC_NA|ENC_UTF_8);",
          "1603:                     }",
          "1604:                     offset += tlv_len;",
          "1605:                 }",
          "1606:                 break;",
          "1608:             case THREAD_MC_TLV_VENDOR_MODEL:",
          "1609:                 {",
          "1611:                     if (tlv_len > 32) {",
          "1612:                         expert_add_info(pinfo, proto_root, &ei_thread_mc_len_too_long);",
          "1613:                         proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);",
          "1614:                     } else {",
          "1615:                         proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_vendor_model, tvb, offset, tlv_len, ENC_NA|ENC_UTF_8);",
          "1616:                     }",
          "1617:                     offset += tlv_len;",
          "1618:                 }",
          "1619:                 break;",
          "1621:             case THREAD_MC_TLV_VENDOR_SW_VERSION:",
          "1622:                 {",
          "1624:                     if (tlv_len > 16) {",
          "1625:                         expert_add_info(pinfo, proto_root, &ei_thread_mc_len_too_long);",
          "1626:                         proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);",
          "1627:                     } else {",
          "1628:                         proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_vendor_sw_ver, tvb, offset, tlv_len, ENC_NA|ENC_UTF_8);",
          "1629:                     }",
          "1630:                     offset += tlv_len;",
          "1631:                 }",
          "1632:                 break;",
          "1634:             case THREAD_MC_TLV_VENDOR_DATA:",
          "1635:                 {",
          "1637:                     if (tlv_len > 64) {",
          "1638:                         expert_add_info(pinfo, proto_root, &ei_thread_mc_len_too_long);",
          "1639:                         proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);",
          "1640:                     } else {",
          "1642:                         proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_vendor_data, tvb, offset, tlv_len, ENC_ASCII|ENC_NA);",
          "1643:                     }",
          "1644:                     offset += tlv_len;",
          "1645:                 }",
          "1646:                 break;",
          "1648:             case THREAD_MC_TLV_VENDOR_STACK_VERSION:",
          "1649:                 {",
          "1651:                     if (tlv_len != 6) {",
          "1652:                         expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);",
          "1653:                         proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);",
          "1654:                         offset += tlv_len;",
          "1655:                     } else {",
          "1656:                         guint8 build_u8;",
          "1657:                         guint16 build;",
          "1659:                         proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_vendor_stack_ver_oui, tvb, offset, 3, ENC_BIG_ENDIAN);",
          "1660:                         offset += 3;",
          "1661:                         build_u8 = tvb_get_guint8(tvb, offset);",
          "1662:                         offset++;",
          "1663:                         build = (guint16)build_u8 << 4;",
          "1664:                         build_u8 = tvb_get_guint8(tvb, offset);",
          "1665:                         build |= (guint16)build_u8 >> 4;",
          "1666:                         pi = proto_tree_add_uint(tlv_tree, hf_thread_mc_tlv_vendor_stack_ver_build, tvb, 0, 0, build);",
          "1667:                         PROTO_ITEM_SET_GENERATED(pi);",
          "1668:                         proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_vendor_stack_ver_rev, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "1669:                         offset++;",
          "1670:                         proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_vendor_stack_ver_min, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "1671:                         proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_vendor_stack_ver_maj, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "1672:                         offset++;",
          "1673:                     }",
          "1674:                 }",
          "1675:                 break;",
          "1677:             case THREAD_MC_TLV_UDP_ENCAPSULATION:",
          "1678:                 {",
          "1679:                     tvbuff_t *sub_tvb;",
          "1680:                     guint16 src_port;",
          "1681:                     guint16 dst_port;",
          "1682:                     udp_hdr_t *udp_hdr;",
          "1683:                     guint8 *buffer;",
          "1685:                     src_port = tvb_get_ntohs(tvb, offset);",
          "1686:                     proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_udp_encap_src_port, tvb, offset, 2, ENC_BIG_ENDIAN);",
          "1687:                     offset += 2;",
          "1688:                     dst_port = tvb_get_ntohs(tvb, offset);",
          "1689:                     proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_udp_encap_dst_port, tvb, offset, 2, ENC_BIG_ENDIAN);",
          "1690:                     offset += 2;",
          "1692:                     if (tlv_len >= 4)",
          "1693:                     {",
          "1695:                         buffer = (guint8 *)wmem_alloc(pinfo->pool, sizeof(udp_hdr_t) + (tlv_len - 4));",
          "1698:                         udp_hdr = (udp_hdr_t *)buffer;",
          "1699:                         udp_hdr->src_port = g_htons(src_port);",
          "1700:                         udp_hdr->dst_port = g_htons(dst_port);",
          "1702:                         udp_hdr->checksum = 0;",
          "1704:                         tvb_memcpy(tvb, udp_hdr + 1, offset, tlv_len - 4);",
          "1706:                         sub_tvb = tvb_new_child_real_data(tvb, buffer, tlv_len + 4, tvb_reported_length(tvb) + 4);",
          "1707:                         call_dissector(thread_udp_handle, sub_tvb, pinfo, tree);",
          "1708:                     }",
          "1709:                     offset += (tlv_len-4);",
          "1710:                 }",
          "1711:                 break;",
          "1713:             case THREAD_MC_TLV_IPV6_ADDRESS:",
          "1714:                 {",
          "1716:                     if (tlv_len != 16) {",
          "1717:                         expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);",
          "1718:                         proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);",
          "1719:                     } else {",
          "1720:                         proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_ipv6_addr, tvb, offset, tlv_len, ENC_NA);",
          "1721:                     }",
          "1722:                     offset += tlv_len;",
          "1723:                 }",
          "1724:                 break;",
          "1728:             case THREAD_MC_TLV_DELAY_TIMER:",
          "1729:                 {",
          "1730:                     if (tlv_len != 4) {",
          "1731:                         expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);",
          "1732:                         proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);",
          "1733:                     } else {",
          "1734:                         proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_delay_timer, tvb, offset, tlv_len, ENC_BIG_ENDIAN);",
          "1735:                     }",
          "1736:                     offset += tlv_len;",
          "1737:                 }",
          "1738:                 break;",
          "1740:             case THREAD_MC_TLV_CHANNEL_MASK:",
          "1741:                 {",
          "1742:                     proto_tree *cm_tree;",
          "1743:                     int i;",
          "1744:                     guint8 entries = 0;",
          "1745:                     guint16 check_len = tlv_len;",
          "1747:                     guint8 masklen;",
          "1750:                     while (check_len > 0) {",
          "1752:                         masklen = tvb_get_guint8(tvb, check_offset);",
          "1753:                         if (masklen == 0) {",
          "1755:                         }",
          "1757:                         check_offset += masklen;",
          "1758:                         check_len -= masklen;",
          "1759:                         entries++;",
          "1760:                     }",
          "1762:                     if (check_len != 0) {",
          "1764:                         expert_add_info(pinfo, proto_root, &ei_thread_mc_tlv_length_failed);",
          "1765:                         proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);",
          "1766:                         offset += tlv_len;",
          "1767:                     } else {",
          "1768:                         for (i = 0; i < entries; i++) {",
          "1769:                             pi = proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_chan_mask, tvb, offset, 1, ENC_NA);",
          "1770:                             cm_tree = proto_item_add_subtree(pi, ett_thread_mc_chan_mask);",
          "1771:                             proto_tree_add_item(cm_tree, hf_thread_mc_tlv_chan_mask_page, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "1772:                             offset++;",
          "1773:                             masklen = tvb_get_guint8(tvb, offset);",
          "1774:                             proto_tree_add_item(cm_tree, hf_thread_mc_tlv_chan_mask_len, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "1775:                             offset++;",
          "1776:                             proto_tree_add_item(cm_tree, hf_thread_mc_tlv_chan_mask_mask, tvb, offset, masklen, ENC_NA);",
          "1777:                             offset += masklen;",
          "1778:                         }",
          "1779:                     }",
          "1780:                 }",
          "1781:                 break;",
          "1783:             case THREAD_MC_TLV_COUNT:",
          "1784:                 {",
          "1785:                     if (tlv_len != 1) {",
          "1786:                         expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);",
          "1787:                         proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);",
          "1788:                     } else {",
          "1789:                         proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_count, tvb, offset, tlv_len, ENC_BIG_ENDIAN);",
          "1790:                     }",
          "1791:                     offset += tlv_len;",
          "1792:                 }",
          "1793:                 break;",
          "1795:             case THREAD_MC_TLV_PERIOD:",
          "1796:                 {",
          "1797:                     if (tlv_len != 2) {",
          "1798:                         expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);",
          "1799:                         proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);",
          "1800:                     } else {",
          "1801:                         proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_period, tvb, offset, tlv_len, ENC_BIG_ENDIAN);",
          "1802:                     }",
          "1803:                     offset += tlv_len;",
          "1804:                 }",
          "1805:                 break;",
          "1807:             case THREAD_MC_TLV_SCAN_DURATION:",
          "1808:                 {",
          "1809:                     if (tlv_len != 2) {",
          "1810:                         expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);",
          "1811:                         proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);",
          "1812:                     } else {",
          "1813:                         proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_scan_duration, tvb, offset, tlv_len, ENC_BIG_ENDIAN);",
          "1814:                     }",
          "1815:                     offset += tlv_len;",
          "1816:                 }",
          "1817:                 break;",
          "1819:             case THREAD_MC_TLV_ENERGY_LIST:",
          "1820:                 {",
          "1821:                     proto_tree *it_tree;",
          "1822:                     int i;",
          "1824:                     if ((chancount != THREAD_MC_INVALID_CHAN_COUNT) && ((tlv_len % chancount) == 0)) {",
          "1826:                         for (i = 0; i < (int)(tlv_len / (guint16)chancount); i++) {",
          "1827:                             pi = proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_el_count, tvb, offset, 1, ENC_NA);",
          "1828:                             proto_item_append_text(pi, \" %d\", i + 1);",
          "1829:                             it_tree = proto_item_add_subtree(pi, ett_thread_mc_el_count);",
          "1830:                             proto_tree_add_item(it_tree, hf_thread_mc_tlv_energy_list, tvb, offset, chancount, ENC_NA);",
          "1831:                             offset += chancount;",
          "1832:                         }",
          "1833:                     } else {",
          "1836:                         proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_energy_list, tvb, offset, tlv_len, ENC_NA);",
          "1837:                     }",
          "1838:                     offset += tlv_len;",
          "1839:                 }",
          "1840:                 break;",
          "1842:             case THREAD_MC_TLV_DISCOVERY_REQUEST:",
          "1843:                 {",
          "1845:                     if (tlv_len != 2) {",
          "1846:                         expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);",
          "1847:                         proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);",
          "1848:                     } else {",
          "1849:                         proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_discovery_req_ver, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "1850:                         proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_discovery_req_j, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "1851:                     }",
          "1852:                     offset += tlv_len;",
          "1853:                 }",
          "1854:                 break;",
          "1856:             case THREAD_MC_TLV_DISCOVERY_RESPONSE:",
          "1857:                 {",
          "1859:                     if (tlv_len != 2) {",
          "1860:                         expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);",
          "1861:                         proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);",
          "1862:                     } else {",
          "1863:                         proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_discovery_rsp_ver, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "1864:                         proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_discovery_rsp_n, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "1865:                     }",
          "1866:                     offset += tlv_len;",
          "1867:                 }",
          "1868:                 break;",
          "1870:             default:",
          "1871:                 proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);",
          "1872:                 offset += tlv_len;",
          "1873:         }",
          "1874:     }",
          "1875:     return tvb_captured_length(tvb);",
          "1876: }",
          "1878: static int",
          "1879: dissect_thread_nwd(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)",
          "1880: {",
          "1881:     proto_item  *proto_root;",
          "1882:     proto_tree  *thread_nwd_tree;",
          "1883:     proto_tree  *tlv_tree;",
          "1884:     tvbuff_t    *sub_tvb;",
          "1885:     guint       offset = 0, tlv_offset;",
          "1886:     proto_item  *ti;",
          "1887:     guint8      tlv_type, tlv_len;",
          "1890:     proto_root = proto_tree_add_item(tree, proto_thread_nwd, tvb, 0, tvb_reported_length(tvb), ENC_NA);",
          "1891:     thread_nwd_tree = proto_item_add_subtree(proto_root, ett_thread_nwd);",
          "1894:     while (tvb_offset_exists(tvb, offset)) {",
          "1898:         tlv_len = tvb_get_guint8(tvb, offset + 1);",
          "1900:         ti = proto_tree_add_item(thread_nwd_tree, hf_thread_nwd_tlv, tvb, offset, tlv_len+2, ENC_NA);",
          "1901:         tlv_tree = proto_item_add_subtree(ti, ett_thread_nwd_tlv);",
          "1904:         proto_tree_add_item(tlv_tree, hf_thread_nwd_tlv_type, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "1905:         tlv_type = tvb_get_guint8(tvb, offset) >> 1;",
          "1908:         proto_tree_add_item(tlv_tree, hf_thread_nwd_tlv_stable, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "1909:         offset++;",
          "1912:         proto_item_append_text(ti, \" (%s)\", val_to_str(tlv_type, thread_nwd_tlv_vals, \"Unknown (%d)\"));",
          "1915:         proto_tree_add_item(tlv_tree, hf_thread_nwd_tlv_length, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "1916:         offset++;",
          "1918:         switch(tlv_type) {",
          "1919:             case THREAD_NWD_TLV_HAS_ROUTE:",
          "1920:                 {",
          "1924:                     if ((tlv_len % THREAD_NWD_TLV_HAS_ROUTE_SIZE) != 0)",
          "1925:                     {",
          "1926:                         expert_add_info(pinfo, proto_root, &ei_thread_nwd_len_size_mismatch);",
          "1927:                         proto_tree_add_item(tlv_tree, hf_thread_nwd_tlv_unknown, tvb, offset, tlv_len, ENC_NA);",
          "1928:                         offset += tlv_len;",
          "1929:                     } else {",
          "1930:                         proto_tree *has_route_tree;",
          "1931:                         guint i;",
          "1932:                         guint count = tlv_len / THREAD_NWD_TLV_HAS_ROUTE_SIZE;",
          "1935:                         for (i = 0; i < count; i++) {",
          "1936:                             ti = proto_tree_add_item(tlv_tree, hf_thread_nwd_tlv_has_route, tvb, offset, 1, ENC_NA);",
          "1937:                             has_route_tree = proto_item_add_subtree(ti, ett_thread_nwd_has_route);",
          "1938:                             proto_tree_add_item(has_route_tree, hf_thread_nwd_tlv_has_route_br_16, tvb, offset, 2, ENC_BIG_ENDIAN);",
          "1939:                             offset += 2;",
          "1940:                             proto_tree_add_item(has_route_tree, hf_thread_nwd_tlv_has_route_pref, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "1941:                             offset += 1;",
          "1942:                         }",
          "1943:                     }",
          "1944:                 }",
          "1945:                 break;",
          "1947:             case THREAD_NWD_TLV_PREFIX:",
          "1948:                 {",
          "1949:                     guint8 prefix_len;",
          "1950:                     guint8 prefix_byte_len;",
          "1951:                     struct e_in6_addr prefix;",
          "1952:                     address prefix_addr;",
          "1955:                     proto_tree_add_item(tlv_tree, hf_thread_nwd_tlv_prefix_domain_id, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "1956:                     offset++;",
          "1957:                     tlv_offset = 1;",
          "1960:                     proto_tree_add_item(tlv_tree, hf_thread_nwd_tlv_prefix_length, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "1961:                     prefix_len = tvb_get_guint8(tvb, offset);",
          "1962:                     prefix_byte_len = (prefix_len + 7) / 8;",
          "1963:                     offset++;",
          "1964:                     tlv_offset++;",
          "1967:                     memset(&prefix.bytes, 0, sizeof(prefix));",
          "1968:                     if (prefix_byte_len <= sizeof(prefix))",
          "1969:                         tvb_memcpy(tvb, (guint8 *)&prefix.bytes, offset, prefix_byte_len);",
          "1970:                     proto_tree_add_ipv6(tlv_tree, hf_thread_nwd_tlv_prefix, tvb, offset, prefix_byte_len, &prefix);",
          "1971:                     set_address(&prefix_addr, AT_IPv6, 16, prefix.bytes);",
          "1972:                     proto_item_append_text(ti, \" = %s/%d\", address_to_str(wmem_packet_scope(), &prefix_addr), prefix_len);",
          "1973:                     offset += prefix_byte_len;",
          "1974:                     tlv_offset += prefix_byte_len;",
          "1976:                     if (tlv_offset < tlv_len) {",
          "1977:                         proto_tree *sub_tlv_tree;",
          "1978:                         guint remainder = tlv_len - tlv_offset;",
          "1980:                         ti = proto_tree_add_item(tlv_tree, hf_thread_nwd_tlv_sub_tlvs, tvb, offset, 1, ENC_NA);",
          "1981:                         sub_tlv_tree = proto_item_add_subtree(ti, ett_thread_nwd_prefix_sub_tlvs);",
          "1984:                         dissect_thread_nwd(sub_tvb, pinfo, sub_tlv_tree, data);",
          "1985:                         offset += remainder;",
          "1986:                     }",
          "1987:                 }",
          "1988:                 break;",
          "1990:             case THREAD_NWD_TLV_BORDER_ROUTER:",
          "1991:                 {",
          "1995:                     if ((tlv_len % 4) != 0)",
          "1996:                     {",
          "1997:                         expert_add_info(pinfo, proto_root, &ei_thread_nwd_len_size_mismatch);",
          "1998:                         proto_tree_add_item(tlv_tree, hf_thread_nwd_tlv_unknown, tvb, offset, tlv_len, ENC_NA);",
          "1999:                         offset += tlv_len;",
          "2000:                     } else {",
          "2001:                         proto_tree *border_router_tree;",
          "2002:                         guint i;",
          "2003:                         guint count = tlv_len / 4;",
          "2006:                         for (i = 0; i < count; i++) {",
          "2007:                             ti = proto_tree_add_item(tlv_tree, hf_thread_nwd_tlv_border_router, tvb, offset, 1, ENC_NA);",
          "2008:                             border_router_tree = proto_item_add_subtree(ti, ett_thread_nwd_border_router);",
          "2010:                             proto_tree_add_item(border_router_tree, hf_thread_nwd_tlv_border_router_16, tvb, offset, 2, ENC_BIG_ENDIAN);",
          "2011:                             offset += 2;",
          "2012:                             proto_tree_add_item(border_router_tree, hf_thread_nwd_tlv_border_router_pref, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "2013:                             proto_tree_add_item(border_router_tree, hf_thread_nwd_tlv_border_router_p, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "2014:                             proto_tree_add_item(border_router_tree, hf_thread_nwd_tlv_border_router_s, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "2015:                             proto_tree_add_item(border_router_tree, hf_thread_nwd_tlv_border_router_d, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "2016:                             proto_tree_add_item(border_router_tree, hf_thread_nwd_tlv_border_router_c, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "2017:                             proto_tree_add_item(border_router_tree, hf_thread_nwd_tlv_border_router_r, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "2018:                             proto_tree_add_item(border_router_tree, hf_thread_nwd_tlv_border_router_o, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "2019:                             offset++;",
          "2020:                             proto_tree_add_item(border_router_tree, hf_thread_nwd_tlv_border_router_n, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "2021:                             offset++;",
          "2022:                         }",
          "2023:                     }",
          "2024:                 }",
          "2025:                 break;",
          "2027:             case THREAD_NWD_TLV_6LOWPAN_ID:",
          "2028:                 {",
          "2029:                     static const int * nwd_6lowpan_flags[] = {",
          "2030:                         &hf_thread_nwd_tlv_6lowpan_id_6co_flag_reserved,",
          "2031:                         &hf_thread_nwd_tlv_6lowpan_id_6co_flag_c,",
          "2032:                         &hf_thread_nwd_tlv_6lowpan_id_6co_flag_cid,",
          "2033:                         NULL",
          "2034:                     };",
          "2037:                     proto_tree_add_bitmask(tlv_tree, tvb, offset, hf_thread_nwd_tlv_6lowpan_id_6co_flag, ett_thread_nwd_6co_flag, nwd_6lowpan_flags, ENC_BIG_ENDIAN);",
          "2038:                     offset++;",
          "2041:                     proto_tree_add_item(tlv_tree, hf_thread_nwd_tlv_6lowpan_id_6co_context_length, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "2042:                     offset++;",
          "2043:                 }",
          "2044:                 break;",
          "2046:             case THREAD_NWD_TLV_COMMISSIONING_DATA:",
          "2047:                 {",
          "2048:                     if (tlv_len > 0) {",
          "2049:                         sub_tvb = tvb_new_subset_length(tvb, offset, tlv_len);",
          "2050:                         call_dissector(thread_mc_handle, sub_tvb, pinfo, tlv_tree);",
          "2051:                     }",
          "2052:                     offset += tlv_len;",
          "2053:                 }",
          "2054:                 break;",
          "2056:             case THREAD_NWD_TLV_SERVICE:",
          "2057:                 {",
          "2058:                     guint8 flags;",
          "2059:                     guint8 s_data_len;",
          "2062:                     flags = tvb_get_guint8(tvb, offset);",
          "2063:                     proto_tree_add_item(tlv_tree, hf_thread_nwd_tlv_service_t, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "2064:                     proto_tree_add_item(tlv_tree, hf_thread_nwd_tlv_service_s_id, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "2065:                     offset++;",
          "2066:                     tlv_offset = 1;",
          "2069:                     if ((flags & THREAD_NWD_TLV_SERVICE_T) == 0) {",
          "2070:                         proto_tree_add_item(tlv_tree, hf_thread_nwd_tlv_service_s_ent_num, tvb, offset, 4, ENC_BIG_ENDIAN);",
          "2071:                         offset += 4;",
          "2072:                         tlv_offset += 4;",
          "2073:                     }",
          "2076:                     s_data_len = tvb_get_guint8(tvb, offset);",
          "2077:                     proto_tree_add_item(tlv_tree, hf_thread_nwd_tlv_service_s_data_len, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "2078:                     offset++;",
          "2079:                     tlv_offset++;",
          "2080:                     proto_tree_add_item(tlv_tree, hf_thread_nwd_tlv_service_s_data, tvb, offset, s_data_len, ENC_NA);",
          "2081:                     offset += s_data_len;",
          "2082:                     tlv_offset += s_data_len;",
          "2085:                     if (tlv_offset < tlv_len) {",
          "2086:                         proto_tree *sub_tlv_tree;",
          "2087:                         guint remainder = tlv_len - tlv_offset;",
          "2089:                         ti = proto_tree_add_item(tlv_tree, hf_thread_nwd_tlv_sub_tlvs, tvb, offset, 1, ENC_NA);",
          "2090:                         sub_tlv_tree = proto_item_add_subtree(ti, ett_thread_nwd_prefix_sub_tlvs);",
          "2093:                         dissect_thread_nwd(sub_tvb, pinfo, sub_tlv_tree, data);",
          "2094:                         offset += remainder;",
          "2095:                     }",
          "2096:                 }",
          "2097:                 break;",
          "2099:             case THREAD_NWD_TLV_SERVER:",
          "2100:                 {",
          "2101:                     proto_tree_add_item(tlv_tree, hf_thread_nwd_tlv_server_16, tvb, offset, 2, ENC_BIG_ENDIAN);",
          "2102:                     offset += 2;",
          "2103:                     proto_tree_add_item(tlv_tree, hf_thread_nwd_tlv_server_data, tvb, offset, tlv_len - 2, ENC_NA);",
          "2104:                     offset += tlv_len - 2;",
          "2105:                 }",
          "2106:                 break;",
          "2108:             default:",
          "2109:                 proto_tree_add_item(tlv_tree, hf_thread_nwd_tlv_unknown, tvb, offset, tlv_len, ENC_NA);",
          "2110:                 offset += tlv_len;",
          "2111:         }",
          "2112:     }",
          "2113:     return tvb_captured_length(tvb);",
          "2114: }",
          "2116: static int",
          "2117: dissect_thread_coap(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)",
          "2118: {",
          "2119:     coap_info           *coinfo;",
          "2120:     gchar               *uri;",
          "2121:     gchar               **tokens;",
          "2124:     coinfo = (coap_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_coap, 0);",
          "2125:     uri = (gchar *)wmem_strbuf_get_str(coinfo->uri_str_strbuf);",
          "2127:     tokens = g_strsplit(uri, \"/\", 3);",
          "2128:     if ((tokens[0] != NULL) && (tokens[1] != NULL)) {",
          "2130:         dissector_try_string(thread_coap_namespace, tokens[1], tvb, pinfo, tree, NULL);",
          "2131:     }",
          "2132:     g_strfreev(tokens);",
          "2134:     return tvb_captured_length(tvb);",
          "2135: }",
          "2137: static int dissect_thread_bcn(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)",
          "2138: {",
          "2139:     ieee802154_packet   *packet = (ieee802154_packet *)data;",
          "2141:     proto_item  *ti, *beacon_root;",
          "2142:     proto_tree  *beacon_tree;",
          "2143:     guint       offset = 0;",
          "2144:     const guint8  *ssid;",
          "2145:     guint8      tlv_type, tlv_len;",
          "2146:     proto_tree  *tlv_tree = NULL;",
          "2149:     if (!packet) return 0;",
          "2152:     col_set_str(pinfo->cinfo, COL_PROTOCOL, \"Thread\");",
          "2154:     beacon_root = proto_tree_add_item(tree, proto_thread_bcn, tvb, 0, -1, ENC_NA);",
          "2155:     beacon_tree = proto_item_add_subtree(beacon_root, ett_thread_bcn);",
          "2158:     col_clear(pinfo->cinfo, COL_INFO);",
          "2159:     col_append_fstr(pinfo->cinfo, COL_INFO, \"Beacon, Src: 0x%04x\", packet->src16);",
          "2162:     proto_tree_add_item(beacon_tree, hf_thread_bcn_protocol, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "2163:     offset += 1;",
          "2166:     proto_tree_add_item(beacon_tree, hf_thread_bcn_joining, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "2167:     proto_tree_add_item(beacon_tree, hf_thread_bcn_native, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "2168:     proto_tree_add_item(beacon_tree, hf_thread_bcn_version, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "2169:     offset += 1;",
          "2172:     proto_tree_add_item_ret_string(beacon_tree, hf_thread_bcn_network_id, tvb, offset, 16, ENC_ASCII|ENC_NA, wmem_packet_scope(), &ssid);",
          "2173:     col_append_fstr(pinfo->cinfo, COL_INFO, \", Network ID: %s\", ssid);",
          "2174:     offset += 16;",
          "2177:     if (offset >= tvb_captured_length(tvb)) {",
          "2178:         return tvb_captured_length(tvb);",
          "2179:     }",
          "2182:     proto_tree_add_item(beacon_tree, hf_thread_bcn_epid, tvb, offset, 8, ENC_BIG_ENDIAN);",
          "2183:     offset += 8;",
          "2186:     if (offset >= tvb_captured_length(tvb)) {",
          "2187:         return tvb_captured_length(tvb);",
          "2188:     }",
          "2194:     tlv_len = tvb_get_guint8(tvb, offset+1);",
          "2197:     ti = proto_tree_add_item(beacon_tree, hf_thread_bcn_tlv, tvb, offset, tlv_len+2, ENC_NA);",
          "2198:     tlv_tree = proto_item_add_subtree(ti, ett_thread_bcn_tlv);",
          "2199:     proto_tree_add_item(tlv_tree, hf_thread_bcn_tlv_type, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "2201:     tlv_type = tvb_get_guint8(tvb, offset);",
          "2202:     offset++;",
          "2205:     proto_item_append_text(ti, \" (%s)\", val_to_str(tlv_type, thread_bcn_tlv_vals, \"Unknown (%d)\"));",
          "2208:     proto_tree_add_item(tlv_tree, hf_thread_bcn_tlv_length, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "2209:     offset++;",
          "2212:         switch (tlv_type) {",
          "2213:             case THREAD_BCN_TLV_STEERING_DATA:",
          "2214:                 proto_tree_add_item(tlv_tree, hf_thread_bcn_tlv_steering_data, tvb, offset, tlv_len, ENC_NA);",
          "2216:                 break;",
          "2217:             default:",
          "2218:                 proto_tree_add_item(tlv_tree, hf_thread_bcn_tlv_unknown, tvb, offset, tlv_len, ENC_NA);",
          "2220:                 break;",
          "2221:         }",
          "2222:     }",
          "2223:     return tvb_captured_length(tvb);",
          "2224: }",
          "2226: static gboolean",
          "2227: dissect_thread_bcn_heur(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)",
          "2228: {",
          "2229:     ieee802154_packet   *packet = (ieee802154_packet *)data;",
          "2232:     if (!packet) return FALSE;",
          "2233:     if (!((packet->src_addr_mode == IEEE802154_FCF_ADDR_SHORT) ||",
          "2234:           (packet->src_addr_mode == IEEE802154_FCF_ADDR_EXT))) return FALSE;",
          "2236:     if (tvb_captured_length(tvb) > 0) {",
          "2238:         if (tvb_get_guint8(tvb, 0) != THREAD_BCN_PROTOCOL_ID) return FALSE;",
          "2239:         dissect_thread_bcn(tvb, pinfo, tree, packet);",
          "2240:         return TRUE;",
          "2241:     }",
          "2242:     return FALSE;",
          "2243: }",
          "2245: void",
          "2246: proto_register_thread_address(void)",
          "2247: {",
          "2248:     static hf_register_info hf[] = {",
          "2251:         { &hf_thread_address_tlv,",
          "2252:             { \"TLV\",",
          "2253:             \"thread_address.tlv\",",
          "2254:             FT_NONE, BASE_NONE, NULL, 0x0,",
          "2255:             \"Type-Length-Value\",",
          "2256:             HFILL }",
          "2257:         },",
          "2259:         { &hf_thread_address_tlv_type,",
          "2260:             { \"Type\",",
          "2261:             \"thread_address.tlv.type\",",
          "2262:             FT_UINT8, BASE_DEC, VALS(thread_address_tlv_vals), 0x0,",
          "2263:             \"Type of value\",",
          "2264:             HFILL }",
          "2265:         },",
          "2267:         { &hf_thread_address_tlv_length,",
          "2268:             { \"Length\",",
          "2269:             \"thread_address.tlv.len\",",
          "2270:             FT_UINT8, BASE_DEC, NULL, 0x0,",
          "2271:             \"Length of value\",",
          "2272:             HFILL }",
          "2273:         },",
          "2275:         { &hf_thread_address_tlv_unknown,",
          "2276:             { \"Unknown\",",
          "2277:             \"thread_address.tlv.unknown\",",
          "2278:             FT_BYTES, BASE_NONE, NULL, 0x0,",
          "2279:             \"Unknown TLV, raw value\",",
          "2280:             HFILL }",
          "2281:         },",
          "2282: #if 0",
          "2283:         { &hf_thread_address_tlv_sub_tlvs,",
          "2284:             { \"Sub-TLV(s)\",",
          "2285:             \"thread_address.tlv.sub_tlvs\",",
          "2286:             FT_NONE, BASE_NONE, NULL, 0x0,",
          "2287:             NULL,",
          "2288:             HFILL }",
          "2289:         },",
          "2290: #endif",
          "2292:         { &hf_thread_address_tlv_target_eid,",
          "2293:             { \"Target EID\",",
          "2294:             \"thread_address.tlv.target_eid\",",
          "2295:             FT_IPv6, BASE_NONE, NULL, 0x0,",
          "2296:             NULL,",
          "2297:             HFILL }",
          "2298:         },",
          "2300:         { &hf_thread_address_tlv_ext_mac_addr,",
          "2301:             { \"Extended MAC Address\",",
          "2302:             \"thread_address.tlv.ext_mac_addr\",",
          "2303:             FT_EUI64, BASE_NONE, NULL, 0x0,",
          "2304:             NULL,",
          "2305:             HFILL }",
          "2306:         },",
          "2308:         { &hf_thread_address_tlv_rloc16,",
          "2309:             { \"RLOC16\",",
          "2310:             \"thread_address.tlv.rloc16\",",
          "2311:             FT_UINT16, BASE_HEX, NULL, 0x0,",
          "2312:             NULL,",
          "2313:             HFILL }",
          "2314:         },",
          "2316:         { &hf_thread_address_tlv_ml_eid,",
          "2317:             { \"ML-EID\",",
          "2318:             \"thread_address.tlv.ml_eid\",",
          "2319:             FT_BYTES, BASE_NONE, NULL, 0x0,",
          "2320:             NULL,",
          "2321:             HFILL }",
          "2322:         },",
          "2324:         { &hf_thread_address_tlv_status,",
          "2325:             { \"Status\",",
          "2326:             \"thread_address.tlv.status\",",
          "2327:             FT_UINT8, BASE_DEC, VALS(thread_address_tlv_status_vals), 0x0,",
          "2328:             NULL,",
          "2329:             HFILL }",
          "2330:         },",
          "2331: #if 0",
          "2332:         { &hf_thread_address_tlv_attached_time,",
          "2333:             { \"Attached Time\",",
          "2334:             \"thread_address.tlv.attached_time\",",
          "2335:             FT_UINT32, BASE_DEC, NULL, 0x0,",
          "2336:             NULL,",
          "2337:             HFILL }",
          "2338:         },",
          "2339: #endif",
          "2340:         { &hf_thread_address_tlv_last_transaction_time,",
          "2341:             { \"Last Transaction Time\",",
          "2342:             \"thread_address.tlv.last_transaction_time\",",
          "2343:             FT_UINT32, BASE_DEC, NULL, 0x0,",
          "2344:             NULL,",
          "2345:             HFILL }",
          "2346:         },",
          "2348:         { &hf_thread_address_tlv_router_mask_id_seq,",
          "2349:             { \"ID Sequence\",",
          "2350:             \"thread_address.tlv.router_mask_id_seq\",",
          "2351:             FT_UINT8, BASE_DEC, NULL, 0x0,",
          "2352:             NULL,",
          "2353:             HFILL }",
          "2354:         },",
          "2356:         { &hf_thread_address_tlv_router_mask_assigned,",
          "2357:             { \"Assigned Router ID Mask\",",
          "2358:             \"thread_address.tlv.router_mask_assigned\",",
          "2359:             FT_BYTES, BASE_NONE, NULL, 0x0,",
          "2360:             NULL,",
          "2361:             HFILL }",
          "2362:         },",
          "2364:         { &hf_thread_address_tlv_nd_option,",
          "2365:             { \"ND Option\",",
          "2366:             \"thread_address.tlv.nd_option\",",
          "2367:             FT_BYTES, BASE_NONE, NULL, 0x0,",
          "2368:             NULL,",
          "2369:             HFILL }",
          "2370:         },",
          "2372:         { &hf_thread_address_tlv_nd_data,",
          "2373:             { \"ND Data\",",
          "2374:             \"thread_address.tlv.nd_data\",",
          "2375:             FT_BYTES, BASE_NONE, NULL, 0x0,",
          "2376:             NULL,",
          "2377:             HFILL }",
          "2378:         }",
          "2379:     };",
          "2381:     static gint *ett[] = {",
          "2382:         &ett_thread_address,",
          "2383:         &ett_thread_address_tlv,",
          "2384:     };",
          "2386:     static ei_register_info ei[] = {",
          "2387: #if 0",
          "2388:         { &ei_thread_address_tlv_length_failed, { \"thread_address.tlv_length_failed\", PI_UNDECODED, PI_WARN, \"TLV Length inconsistent\", EXPFILL }},",
          "2389: #endif",
          "2390:         { &ei_thread_address_len_size_mismatch, { \"thread_address.len_size_mismatch\", PI_UNDECODED, PI_WARN, \"TLV Length & Size field disagree\", EXPFILL }},",
          "2391:     };",
          "2393:     expert_module_t* expert_thread_address;",
          "2395:     proto_thread_address = proto_register_protocol(\"Thread Address\", \"Thread Address\", \"thread_address\");",
          "2396:     proto_register_field_array(proto_thread_address, hf, array_length(hf));",
          "2397:     proto_register_subtree_array(ett, array_length(ett));",
          "2398:     expert_thread_address = expert_register_protocol(proto_thread_address);",
          "2399:     expert_register_field_array(expert_thread_address, ei, array_length(ei));",
          "2401:     thread_address_handle = register_dissector(\"thread_address\", dissect_thread_address, proto_thread_address);",
          "2402: }",
          "2404: void",
          "2405: proto_register_thread_dg(void)",
          "2406: {",
          "2407:     static hf_register_info hf[] = {",
          "2410:         { &hf_thread_dg_tlv,",
          "2411:             { \"TLV\",",
          "2412:             \"thread_diagnostic.tlv\",",
          "2413:             FT_NONE, BASE_NONE, NULL, 0x0,",
          "2414:             \"Type-Length-Value\",",
          "2415:             HFILL }",
          "2416:         },",
          "2418:         { &hf_thread_dg_tlv_type,",
          "2419:             { \"Type\",",
          "2420:             \"thread_diagnostic.tlv.type\",",
          "2421:             FT_UINT8, BASE_DEC, VALS(thread_dg_tlv_vals), 0x0,",
          "2422:             \"Type of value\",",
          "2423:             HFILL }",
          "2424:         },",
          "2426:         { &hf_thread_dg_tlv_length8,",
          "2427:             { \"Length\",",
          "2428:             \"thread_diagnostic.tlv.len8\",",
          "2429:             FT_UINT8, BASE_DEC, NULL, 0x0,",
          "2430:             \"Length of value (8-bit)\",",
          "2431:             HFILL }",
          "2432:         },",
          "2434:         { &hf_thread_dg_tlv_length16,",
          "2435:             { \"Length\",",
          "2436:             \"thread_diagnostic.tlv.len16\",",
          "2437:             FT_UINT16, BASE_DEC, NULL, 0x0,",
          "2438:             \"Length of value (16-bit)\",",
          "2439:             HFILL }",
          "2440:         },",
          "2442:         { &hf_thread_dg_tlv_general,",
          "2443:             { \"General\",",
          "2444:             \"thread_diagnostic.tlv.general\",",
          "2445:             FT_BYTES, BASE_NONE, NULL, 0x0,",
          "2446:             \"General TLV, raw value\",",
          "2447:             HFILL }",
          "2448:         },",
          "2450:         { &hf_thread_dg_tlv_unknown,",
          "2451:             { \"Unknown\",",
          "2452:             \"thread_diagnostic.tlv.unknown\",",
          "2453:             FT_BYTES, BASE_NONE, NULL, 0x0,",
          "2454:             \"Unknown TLV, raw value\",",
          "2455:             HFILL }",
          "2456:         }",
          "2457:     };",
          "2459:     static gint *ett[] = {",
          "2460:         &ett_thread_dg,",
          "2461:         &ett_thread_dg_tlv,",
          "2462:     };",
          "2464: #if 0",
          "2465:     static ei_register_info ei[] = {",
          "2466:         { &ei_thread_dg_tlv_length_failed, { \"thread_diagnostic.tlv_length_failed\", PI_UNDECODED, PI_WARN, \"TLV Length inconsistent\", EXPFILL }},",
          "2467:         { &ei_thread_dg_len_size_mismatch, { \"thread_diagnostic.len_size_mismatch\", PI_UNDECODED, PI_WARN, \"TLV Length & Size field disagree\", EXPFILL }},",
          "2468:     };",
          "2470:     expert_module_t* expert_thread_dg;",
          "2471: #endif",
          "2473:     proto_thread_dg = proto_register_protocol(\"Thread Diagnostics\", \"Thread Diagnostics\", \"thread_diagnostic\");",
          "2474:     proto_register_field_array(proto_thread_dg, hf, array_length(hf));",
          "2475:     proto_register_subtree_array(ett, array_length(ett));",
          "2476: #if 0",
          "2477:     expert_thread_dg = expert_register_protocol(proto_thread_dg);",
          "2478:     expert_register_field_array(expert_thread_dg, ei, array_length(ei));",
          "2479: #endif",
          "2481:     thread_dg_handle = register_dissector(\"thread_diagnostic\", dissect_thread_dg, proto_thread_dg);",
          "2482: }",
          "2484: void",
          "2485: proto_register_thread_mc(void)",
          "2486: {",
          "2487:     static hf_register_info hf[] = {",
          "2490:         { &hf_thread_mc_tlv,",
          "2491:             { \"TLV\",",
          "2492:             \"thread_meshcop.tlv\",",
          "2493:             FT_NONE, BASE_NONE, NULL, 0x0,",
          "2494:             \"Type-Length-Value\",",
          "2495:             HFILL }",
          "2496:         },",
          "2498:         { &hf_thread_mc_tlv_type,",
          "2499:             { \"Type\",",
          "2500:             \"thread_meshcop.tlv.type\",",
          "2501:             FT_UINT8, BASE_DEC, VALS(thread_mc_tlv_vals), 0x0,",
          "2502:             \"Type of value\",",
          "2503:             HFILL }",
          "2504:         },",
          "2506:         { &hf_thread_mc_tlv_length8,",
          "2507:             { \"Length\",",
          "2508:             \"thread_meshcop.tlv.len8\",",
          "2509:             FT_UINT8, BASE_DEC, NULL, 0x0,",
          "2510:             \"Length of value (8-bit)\",",
          "2511:             HFILL }",
          "2512:         },",
          "2514:         { &hf_thread_mc_tlv_length16,",
          "2515:             { \"Length\",",
          "2516:             \"thread_meshcop.tlv.len16\",",
          "2517:             FT_UINT16, BASE_DEC, NULL, 0x0,",
          "2518:             \"Length of value (16-bit)\",",
          "2519:             HFILL }",
          "2520:         },",
          "2522:         { &hf_thread_mc_tlv_unknown,",
          "2523:             { \"Unknown\",",
          "2524:             \"thread_meshcop.tlv.unknown\",",
          "2525:             FT_BYTES, BASE_NONE, NULL, 0x0,",
          "2526:             \"Unknown TLV, raw value\",",
          "2527:             HFILL }",
          "2528:         },",
          "2529: #if 0",
          "2530:         { &hf_thread_mc_tlv_sub_tlvs,",
          "2531:             { \"Sub-TLV(s)\",",
          "2532:             \"thread_meshcop.tlv.sub_tlvs\",",
          "2533:             FT_NONE, BASE_NONE, NULL, 0x0,",
          "2534:             NULL,",
          "2535:             HFILL }",
          "2536:         },",
          "2537: #endif",
          "2539:         { &hf_thread_mc_tlv_channel_page,",
          "2540:             { \"Channel Page\",",
          "2541:             \"thread_meshcop.tlv.channel_page\",",
          "2542:             FT_UINT8, BASE_DEC, NULL, 0x0,",
          "2543:             NULL,",
          "2544:             HFILL }",
          "2545:         },",
          "2547:         { &hf_thread_mc_tlv_channel,",
          "2548:             { \"Channel\",",
          "2549:             \"thread_meshcop.tlv.channel\",",
          "2550:             FT_UINT16, BASE_DEC, NULL, 0x0,",
          "2551:             NULL,",
          "2552:             HFILL }",
          "2553:         },",
          "2555:         { &hf_thread_mc_tlv_pan_id,",
          "2556:             { \"PAN ID\",",
          "2557:             \"thread_meshcop.tlv.pan_id\",",
          "2558:             FT_UINT16, BASE_HEX, NULL, 0x0,",
          "2559:             NULL,",
          "2560:             HFILL }",
          "2561:         },",
          "2563:         { &hf_thread_mc_tlv_xpan_id,",
          "2564:             { \"Extended PAN ID\",",
          "2565:             \"thread_meshcop.tlv.xpan_id\",",
          "2566:             FT_UINT64, BASE_HEX, NULL, 0x0,",
          "2567:             NULL,",
          "2568:             HFILL }",
          "2569:         },",
          "2571:         { &hf_thread_mc_tlv_net_name,",
          "2572:             { \"Network Name\",",
          "2573:             \"thread_meshcop.tlv.net_name\",",
          "2574:             FT_STRING, BASE_NONE, NULL, 0x0,",
          "2575:             NULL,",
          "2576:             HFILL }",
          "2577:         },",
          "2579:         { &hf_thread_mc_tlv_pskc,",
          "2580:             { \"PSKc\",",
          "2581:             \"thread_meshcop.tlv.pskc\",",
          "2582:             FT_BYTES, BASE_NONE, NULL, 0x0,",
          "2583:             NULL,",
          "2584:             HFILL }",
          "2585:         },",
          "2587:         { &hf_thread_mc_tlv_master_key,",
          "2588:             { \"Master Key\",",
          "2589:             \"thread_meshcop.tlv.master_key\",",
          "2590:             FT_BYTES, BASE_NONE, NULL, 0x0,",
          "2591:             NULL,",
          "2592:             HFILL }",
          "2593:         },",
          "2595:         { &hf_thread_mc_tlv_net_key_seq_ctr,",
          "2596:             { \"Network Key Sequence Counter\",",
          "2597:             \"thread_meshcop.tlv.net_key_seq_ctr\",",
          "2598:             FT_BYTES, BASE_NONE, NULL, 0x0,",
          "2599:             NULL,",
          "2600:             HFILL }",
          "2601:         },",
          "2603:         { &hf_thread_mc_tlv_ml_prefix,",
          "2604:             { \"Mesh Local Prefix\",",
          "2605:             \"thread_meshcop.tlv.ml_prefix\",",
          "2606:             FT_IPv6, BASE_NONE, NULL, 0x0,",
          "2607:             NULL,",
          "2608:             HFILL }",
          "2609:         },",
          "2611:         { &hf_thread_mc_tlv_steering_data,",
          "2612:             { \"Steering Data\",",
          "2613:             \"thread_meshcop.tlv.steering_data\",",
          "2614:             FT_BYTES, BASE_NONE, NULL, 0x0,",
          "2615:             NULL,",
          "2616:             HFILL }",
          "2617:         },",
          "2619:         { &hf_thread_mc_tlv_ba_locator,",
          "2620:             { \"Border Agent Locator\",",
          "2621:             \"thread_meshcop.tlv.ba_locator\",",
          "2622:             FT_BYTES, BASE_NONE, NULL, 0x0,",
          "2623:             NULL,",
          "2624:             HFILL }",
          "2625:         },",
          "2627:         { &hf_thread_mc_tlv_commissioner_id,",
          "2628:             { \"Commissioner ID\",",
          "2629:             \"thread_meshcop.tlv.commissioner_id\",",
          "2630:             FT_STRING, BASE_NONE, NULL, 0x0,",
          "2631:             NULL,",
          "2632:             HFILL }",
          "2633:         },",
          "2635:         { &hf_thread_mc_tlv_commissioner_sess_id,",
          "2636:             { \"Commissioner Session ID\",",
          "2637:             \"thread_meshcop.tlv.commissioner_sess_id\",",
          "2638:             FT_BYTES, BASE_NONE, NULL, 0x0,",
          "2639:             NULL,",
          "2640:             HFILL }",
          "2641:         },",
          "2643:         { &hf_thread_mc_tlv_sec_policy_rot,",
          "2644:             { \"Rotation Time\",",
          "2645:             \"thread_meshcop.tlv.sec_policy_rot\",",
          "2646:             FT_UINT16, BASE_DEC, NULL, 0x0,",
          "2647:             NULL,",
          "2648:             HFILL }",
          "2649:         },",
          "2651:         { &hf_thread_mc_tlv_sec_policy_o,",
          "2652:             { \"Out-of-band Commissioning\",",
          "2653:             \"thread_meshcop.tlv.sec_policy_o\",",
          "2654:             FT_BOOLEAN, 8, TFS(&tfs_allowed_not_allowed), THREAD_MC_SEC_POLICY_MASK_O_MASK,",
          "2655:             NULL,",
          "2656:             HFILL }",
          "2657:         },",
          "2659:         { &hf_thread_mc_tlv_sec_policy_n,",
          "2660:             { \"Native Commissioning\",",
          "2661:             \"thread_meshcop.tlv.sec_policy_n\",",
          "2662:             FT_BOOLEAN, 8, TFS(&tfs_allowed_not_allowed), THREAD_MC_SEC_POLICY_MASK_N_MASK,",
          "2663:             NULL,",
          "2664:             HFILL }",
          "2665:         },",
          "2667:         { &hf_thread_mc_tlv_sec_policy_r,",
          "2668:             { \"Thread 1.x Routers\",",
          "2669:             \"thread_meshcop.tlv.sec_policy_r\",",
          "2670:             FT_BOOLEAN, 8, TFS(&tfs_enabled_disabled), THREAD_MC_SEC_POLICY_MASK_R_MASK,",
          "2671:             NULL,",
          "2672:             HFILL }",
          "2673:         },",
          "2675:         { &hf_thread_mc_tlv_sec_policy_c,",
          "2676:             { \"PSKc-based Commissioning\",",
          "2677:             \"thread_meshcop.tlv.sec_policy_c\",",
          "2678:             FT_BOOLEAN, 8, TFS(&tfs_allowed_not_allowed), THREAD_MC_SEC_POLICY_MASK_C_MASK,",
          "2679:             NULL,",
          "2680:             HFILL }",
          "2681:         },",
          "2683:         { &hf_thread_mc_tlv_sec_policy_b,",
          "2684:             { \"Thread 1.x Beacons\",",
          "2685:             \"thread_meshcop.tlv.sec_policy_b\",",
          "2686:             FT_BOOLEAN, 8, TFS(&tfs_allowed_not_allowed), THREAD_MC_SEC_POLICY_MASK_B_MASK,",
          "2687:             NULL,",
          "2688:             HFILL }",
          "2689:         },",
          "2691:         { &hf_thread_mc_tlv_state,",
          "2692:             { \"State\",",
          "2693:             \"thread_meshcop.tlv.state\",",
          "2694:             FT_INT8, BASE_DEC, VALS(thread_mc_state_vals), 0x0,",
          "2695:             NULL,",
          "2696:             HFILL }",
          "2697:         },",
          "2699:         { &hf_thread_mc_tlv_active_tstamp,",
          "2700:             { \"Active Timestamp\",",
          "2701:             \"thread_meshcop.tlv.active_tstamp\",",
          "2702:             FT_ABSOLUTE_TIME, ABSOLUTE_TIME_LOCAL, NULL, 0x0,",
          "2703:             NULL,",
          "2704:             HFILL }",
          "2705:         },",
          "2707:         { &hf_thread_mc_tlv_pending_tstamp,",
          "2708:             { \"Pending Timestamp\",",
          "2709:             \"thread_meshcop.tlv.pending_tstamp\",",
          "2710:             FT_ABSOLUTE_TIME, ABSOLUTE_TIME_LOCAL, NULL, 0x0,",
          "2711:             NULL,",
          "2712:             HFILL }",
          "2713:         },",
          "2715:         { &hf_thread_mc_tlv_udp_port,",
          "2716:             { \"UDP Port\",",
          "2717:             \"thread_meshcop.tlv.udp_port\",",
          "2718:             FT_UINT16, BASE_DEC, NULL, 0x0,",
          "2719:             NULL,",
          "2720:             HFILL }",
          "2721:         },",
          "2723:         { &hf_thread_mc_tlv_iid,",
          "2724:             { \"Interface Identifier\",",
          "2725:             \"thread_meshcop.tlv.iid\",",
          "2726:             FT_BYTES, BASE_NONE, NULL, 0x0,",
          "2727:             NULL,",
          "2728:             HFILL }",
          "2729:         },",
          "2731:         { &hf_thread_mc_tlv_jr_locator,",
          "2732:             { \"Joiner Router Locator\",",
          "2733:             \"thread_meshcop.tlv.jr_locator\",",
          "2734:             FT_BYTES, BASE_NONE, NULL, 0x0,",
          "2735:             NULL,",
          "2736:             HFILL }",
          "2737:         },",
          "2739:         { &hf_thread_mc_tlv_kek,",
          "2740:             { \"Key Encryption Key (KEK)\",",
          "2741:             \"thread_meshcop.tlv.kek\",",
          "2742:             FT_BYTES, BASE_NONE, NULL, 0x0,",
          "2743:             NULL,",
          "2744:             HFILL }",
          "2745:         },",
          "2747:         { &hf_thread_mc_tlv_provisioning_url,",
          "2748:             { \"Provisioning URL\",",
          "2749:             \"thread_meshcop.tlv.provisioning_url\",",
          "2750:             FT_STRING, BASE_NONE, NULL, 0x0,",
          "2751:             NULL,",
          "2752:             HFILL }",
          "2753:         },",
          "2755:         { &hf_thread_mc_tlv_vendor_name,",
          "2756:             { \"Vendor Name\",",
          "2757:             \"thread_meshcop.tlv.vendor_name\",",
          "2758:             FT_STRING, BASE_NONE, NULL, 0x0,",
          "2759:             NULL,",
          "2760:             HFILL }",
          "2761:         },",
          "2763:         { &hf_thread_mc_tlv_vendor_model,",
          "2764:             { \"Vendor Model\",",
          "2765:             \"thread_meshcop.tlv.vendor_model\",",
          "2766:             FT_STRING, BASE_NONE, NULL, 0x0,",
          "2767:             NULL,",
          "2768:             HFILL }",
          "2769:         },",
          "2771:         { &hf_thread_mc_tlv_vendor_sw_ver,",
          "2772:             { \"Vendor Software Version\",",
          "2773:             \"thread_meshcop.tlv.vendor_sw_ver\",",
          "2774:             FT_STRING, BASE_NONE, NULL, 0x0,",
          "2775:             NULL,",
          "2776:             HFILL }",
          "2777:         },",
          "2779:         { &hf_thread_mc_tlv_vendor_data,",
          "2780:             { \"Vendor Data\",",
          "2781:             \"thread_meshcop.tlv.vendor_model\",",
          "2782:             FT_STRING, BASE_NONE, NULL, 0x0,",
          "2783:             NULL,",
          "2784:             HFILL }",
          "2785:         },",
          "2787:         { &hf_thread_mc_tlv_vendor_stack_ver_oui,",
          "2788:             { \"OUI\",",
          "2789:             \"thread_meshcop.tlv.vendor_stack_ver_oui\",",
          "2790:             FT_UINT24, BASE_HEX, VALS(oui_vals), 0x0,",
          "2791:             NULL,",
          "2792:             HFILL }",
          "2793:         },",
          "2795:         { &hf_thread_mc_tlv_vendor_stack_ver_build,",
          "2796:             { \"Build\",",
          "2797:             \"thread_meshcop.tlv.vendor_stack_ver_build\",",
          "2798:             FT_UINT16, BASE_DEC, NULL, 0x0,",
          "2799:             NULL,",
          "2800:             HFILL }",
          "2801:         },",
          "2803:         { &hf_thread_mc_tlv_vendor_stack_ver_rev,",
          "2804:             { \"Revision\",",
          "2805:             \"thread_meshcop.tlv.vendor_stack_ver_rev\",",
          "2806:             FT_UINT8, BASE_DEC, NULL, THREAD_MC_STACK_VER_REV_MASK,",
          "2807:             NULL,",
          "2808:             HFILL }",
          "2809:         },",
          "2811:         { &hf_thread_mc_tlv_vendor_stack_ver_min,",
          "2812:             { \"Minor\",",
          "2813:             \"thread_meshcop.tlv.vendor_stack_ver_min\",",
          "2814:             FT_UINT8, BASE_DEC, NULL, THREAD_MC_STACK_VER_MIN_MASK,",
          "2815:             NULL,",
          "2816:             HFILL }",
          "2817:         },",
          "2819:         { &hf_thread_mc_tlv_vendor_stack_ver_maj,",
          "2820:             { \"Major\",",
          "2821:             \"thread_meshcop.tlv.vendor_stack_ver_maj\",",
          "2822:             FT_UINT8, BASE_DEC, NULL, THREAD_MC_STACK_VER_MAJ_MASK,",
          "2823:             NULL,",
          "2824:             HFILL }",
          "2825:         },",
          "2827:         { &hf_thread_mc_tlv_udp_encap_src_port,",
          "2828:             { \"Source UDP Port\",",
          "2829:             \"thread_meshcop.tlv.udp_encap_src_port\",",
          "2830:             FT_UINT16, BASE_DEC, NULL, 0x0,",
          "2831:             NULL,",
          "2832:             HFILL }",
          "2833:         },",
          "2835:         { &hf_thread_mc_tlv_udp_encap_dst_port,",
          "2836:             { \"Destination UDP Port\",",
          "2837:             \"thread_meshcop.tlv.udp_encap_dst_port\",",
          "2838:             FT_UINT16, BASE_DEC, NULL, 0x0,",
          "2839:             NULL,",
          "2840:             HFILL }",
          "2841:         },",
          "2843:         { &hf_thread_mc_tlv_ipv6_addr,",
          "2844:             { \"IPv6 Address\",",
          "2845:             \"thread_meshcop.tlv.ipv6_addr\",",
          "2846:             FT_IPv6, BASE_NONE, NULL, 0x0,",
          "2847:             NULL,",
          "2848:             HFILL }",
          "2849:         },",
          "2851:         { &hf_thread_mc_tlv_delay_timer,",
          "2852:             { \"Delay Timer\",",
          "2853:             \"thread_meshcop.tlv.delay_timer\",",
          "2854:             FT_UINT32, BASE_DEC, NULL, 0x0,",
          "2855:             NULL,",
          "2856:             HFILL }",
          "2857:         },",
          "2859:         { &hf_thread_mc_tlv_chan_mask,",
          "2860:             { \"Channel Mask\",",
          "2861:             \"thread_meshcop.tlv.chan_mask\",",
          "2862:             FT_NONE, BASE_NONE, NULL, 0x0,",
          "2863:             NULL,",
          "2864:             HFILL }",
          "2865:         },",
          "2867:         { &hf_thread_mc_tlv_chan_mask_page,",
          "2868:             { \"Channel Page\",",
          "2869:             \"thread_meshcop.tlv.chan_mask_page\",",
          "2870:             FT_UINT8, BASE_DEC, NULL, 0,",
          "2871:             NULL,",
          "2872:             HFILL }",
          "2873:         },",
          "2875:         { &hf_thread_mc_tlv_chan_mask_len,",
          "2876:             { \"Mask Length\",",
          "2877:             \"thread_meshcop.tlv.chan_mask_len\",",
          "2878:             FT_UINT8, BASE_DEC, NULL, 0,",
          "2879:             NULL,",
          "2880:             HFILL }",
          "2881:         },",
          "2883:         { &hf_thread_mc_tlv_chan_mask_mask,",
          "2884:             { \"Mask\",",
          "2885:             \"thread_meshcop.tlv.chan_mask_mask\",",
          "2886:             FT_BYTES, BASE_NONE, NULL, 0x0,",
          "2887:             NULL,",
          "2888:             HFILL }",
          "2889:         },",
          "2891:         { &hf_thread_mc_tlv_el_count,",
          "2892:             { \"Count\",",
          "2893:             \"thread_meshcop.tlv.el_count\",",
          "2894:             FT_NONE, BASE_NONE, NULL, 0x0,",
          "2895:             NULL,",
          "2896:             HFILL }",
          "2897:         },",
          "2899:         { &hf_thread_mc_tlv_count,",
          "2900:             { \"Count\",",
          "2901:             \"thread_meshcop.tlv.count\",",
          "2902:             FT_UINT8, BASE_DEC, NULL, 0,",
          "2903:             NULL,",
          "2904:             HFILL }",
          "2905:         },",
          "2907:         { &hf_thread_mc_tlv_period,",
          "2908:             { \"Period\",",
          "2909:             \"thread_meshcop.tlv.period\",",
          "2910:             FT_UINT16, BASE_DEC, NULL, 0,",
          "2911:             NULL,",
          "2912:             HFILL }",
          "2913:         },",
          "2915:         { &hf_thread_mc_tlv_scan_duration,",
          "2916:             { \"Scan Duration\",",
          "2917:             \"thread_meshcop.tlv.scan_duration\",",
          "2918:             FT_UINT16, BASE_DEC, NULL, 0,",
          "2919:             NULL,",
          "2920:             HFILL }",
          "2921:         },",
          "2923:         { &hf_thread_mc_tlv_energy_list,",
          "2924:             { \"Energy List\",",
          "2925:             \"thread_meshcop.tlv.energy_list\",",
          "2926:             FT_BYTES, BASE_NONE, NULL, 0x0,",
          "2927:             NULL,",
          "2928:             HFILL }",
          "2929:         },",
          "2931:         { &hf_thread_mc_tlv_discovery_req_ver,",
          "2932:             { \"Version\",",
          "2933:             \"thread_meshcop.tlv.discovery_req_ver\",",
          "2934:             FT_UINT8, BASE_DEC, NULL, THREAD_MC_DISCOVERY_REQ_MASK_VER_MASK,",
          "2935:             NULL,",
          "2936:             HFILL }",
          "2937:         },",
          "2939:         { &hf_thread_mc_tlv_discovery_req_j,",
          "2940:             { \"Joiner Flag\",",
          "2941:             \"thread_meshcop.tlv.discovery_req_j\",",
          "2942:             FT_BOOLEAN, 8, TFS(&thread_mc_tlv_join_intent), THREAD_MC_DISCOVERY_REQ_MASK_J_MASK,",
          "2943:             NULL,",
          "2944:             HFILL }",
          "2945:         },",
          "2947:         { &hf_thread_mc_tlv_discovery_rsp_ver,",
          "2948:             { \"Version\",",
          "2949:             \"thread_meshcop.tlv.discovery_rsp_ver\",",
          "2950:             FT_UINT8, BASE_DEC, NULL, THREAD_MC_DISCOVERY_RSP_MASK_VER_MASK,",
          "2951:             NULL,",
          "2952:             HFILL }",
          "2953:         },",
          "2955:         { &hf_thread_mc_tlv_discovery_rsp_n,",
          "2956:             { \"Native Commissioning\",",
          "2957:             \"thread_meshcop.tlv.discovery_rsp_n\",",
          "2958:             FT_BOOLEAN, 8, TFS(&tfs_allowed_not_allowed), THREAD_MC_DISCOVERY_RSP_MASK_N_MASK,",
          "2959:             NULL,",
          "2960:             HFILL }",
          "2961:         }",
          "2962:     };",
          "2964:     static gint *ett[] = {",
          "2965:         &ett_thread_mc,",
          "2966:         &ett_thread_mc_tlv,",
          "2967:         &ett_thread_mc_chan_mask,",
          "2968:         &ett_thread_mc_el_count",
          "2969:     };",
          "2971:     static ei_register_info ei[] = {",
          "2972:         { &ei_thread_mc_tlv_length_failed, { \"thread_meshcop.tlv_length_failed\", PI_UNDECODED, PI_WARN, \"TLV Length inconsistent\", EXPFILL }},",
          "2973:         { &ei_thread_mc_len_size_mismatch, { \"thread_meshcop.len_size_mismatch\", PI_UNDECODED, PI_WARN, \"TLV Length & Size field disagree\", EXPFILL }},",
          "2974:         { &ei_thread_mc_len_too_long, { \"thread_meshcop.len_too_long\", PI_UNDECODED, PI_WARN, \"TLV Length too long\", EXPFILL }}",
          "2975:     };",
          "2977:     expert_module_t* expert_thread_mc;",
          "2979:     proto_thread_mc = proto_register_protocol(\"Thread MeshCoP\", \"Thread MeshCoP\", \"thread_meshcop\");",
          "2980:     proto_register_field_array(proto_thread_mc, hf, array_length(hf));",
          "2981:     proto_register_subtree_array(ett, array_length(ett));",
          "2982:     expert_thread_mc = expert_register_protocol(proto_thread_mc);",
          "2983:     expert_register_field_array(expert_thread_mc, ei, array_length(ei));",
          "2985:     thread_mc_handle = register_dissector(\"thread_meshcop\", dissect_thread_mc, proto_thread_mc);",
          "2986: }",
          "2988: void",
          "2989: proto_register_thread_nwd(void)",
          "2990: {",
          "2991:     static hf_register_info hf[] = {",
          "2994:         { &hf_thread_nwd_tlv,",
          "2995:             { \"TLV\",",
          "2996:             \"thread_nwd.tlv\",",
          "2997:             FT_NONE, BASE_NONE, NULL, 0x0,",
          "2998:             \"Type-Length-Value\",",
          "2999:             HFILL }",
          "3000:         },",
          "3002:         { &hf_thread_nwd_tlv_type,",
          "3003:             { \"Type\",",
          "3004:             \"thread_nwd.tlv.type\",",
          "3005:             FT_UINT8, BASE_DEC, VALS(thread_nwd_tlv_vals), THREAD_NWD_TLV_TYPE_M,",
          "3006:             \"Type of value\",",
          "3007:             HFILL }",
          "3008:         },",
          "3010:         { &hf_thread_nwd_tlv_stable,",
          "3011:             { \"Stable\",",
          "3012:             \"thread_nwd.tlv.stable\",",
          "3013:             FT_BOOLEAN, 8, NULL, THREAD_NWD_TLV_STABLE_M,",
          "3014:             \"Stability or transience of network data\",",
          "3015:             HFILL }",
          "3016:         },",
          "3018:         { &hf_thread_nwd_tlv_length,",
          "3019:             { \"Length\",",
          "3020:             \"thread_nwd.tlv.len\",",
          "3021:             FT_UINT8, BASE_DEC, NULL, 0x0,",
          "3022:             \"Length of value\",",
          "3023:             HFILL }",
          "3024:         },",
          "3026:         { &hf_thread_nwd_tlv_unknown,",
          "3027:             { \"Unknown\",",
          "3028:             \"thread_nwd.tlv.unknown\",",
          "3029:             FT_BYTES, BASE_NONE, NULL, 0x0,",
          "3030:             \"Unknown TLV, raw value\",",
          "3031:             HFILL }",
          "3032:         },",
          "3034:         { &hf_thread_nwd_tlv_sub_tlvs,",
          "3035:             { \"Sub-TLV(s)\",",
          "3036:             \"thread_nwd.tlv.sub_tlvs\",",
          "3037:             FT_NONE, BASE_NONE, NULL, 0x0,",
          "3038:             NULL,",
          "3039:             HFILL }",
          "3040:         },",
          "3043:         { &hf_thread_nwd_tlv_has_route,",
          "3044:             { \"Has Route\",",
          "3045:             \"thread_nwd.tlv.has_route\",",
          "3046:             FT_NONE, BASE_NONE, NULL, 0x0,",
          "3047:             NULL,",
          "3048:             HFILL }",
          "3049:         },",
          "3051:         { &hf_thread_nwd_tlv_has_route_br_16,",
          "3052:             { \"Border Router 16\",",
          "3053:             \"thread_nwd.tlv.has_route.br_16\",",
          "3054:             FT_UINT16, BASE_HEX, NULL, 0x0,",
          "3055:             \"Has Route Border Router 16-bit address\",",
          "3056:             HFILL }",
          "3057:         },",
          "3059:         { &hf_thread_nwd_tlv_has_route_pref,",
          "3060:             { \"Preference\",",
          "3061:             \"thread_nwd.tlv.has_route.pref\",",
          "3062:             FT_UINT8, BASE_DEC, NULL, THREAD_NWD_TLV_HAS_ROUTE_PREF,",
          "3063:             \"Has Route preference\",",
          "3064:             HFILL }",
          "3065:         },",
          "3067:         { &hf_thread_nwd_tlv_prefix_domain_id,",
          "3068:             { \"Domain ID\",",
          "3069:             \"thread_nwd.tlv.prefix.domain_id\",",
          "3070:             FT_UINT8, BASE_DEC, NULL, 0x0,",
          "3071:             \"Prefix Domain ID\",",
          "3072:             HFILL }",
          "3073:         },",
          "3075:         { &hf_thread_nwd_tlv_prefix_length,",
          "3076:             { \"Prefix Length\",",
          "3077:             \"thread_nwd.tlv.prefix.length\",",
          "3078:             FT_UINT8, BASE_DEC, NULL, 0x0,",
          "3079:             \"Length of Prefix\",",
          "3080:             HFILL }",
          "3081:         },",
          "3083:         { &hf_thread_nwd_tlv_prefix,",
          "3084:             { \"Prefix\",",
          "3085:             \"thread_nwd.tlv.prefix\",",
          "3086:             FT_IPv6, BASE_NONE, NULL, 0x0,",
          "3087:             \"IPv6 prefix\",",
          "3088:             HFILL }",
          "3089:         },",
          "3091:         { &hf_thread_nwd_tlv_border_router,",
          "3092:             { \"Border Router\",",
          "3093:             \"thread_nwd.tlv.border_router\",",
          "3094:             FT_NONE, BASE_NONE, NULL, 0x0,",
          "3095:             NULL,",
          "3096:             HFILL }",
          "3097:         },",
          "3099:         { &hf_thread_nwd_tlv_border_router_16,",
          "3100:             { \"Border Router 16\",",
          "3101:             \"thread_nwd.tlv.border_router.16\",",
          "3102:             FT_UINT16, BASE_HEX, NULL, 0x0,",
          "3103:             \"Border Router 16-bit address\",",
          "3104:             HFILL }",
          "3105:         },",
          "3107:         { &hf_thread_nwd_tlv_border_router_pref,",
          "3108:             { \"Preference\",",
          "3109:             \"thread_nwd.tlv.border_router.pref\",",
          "3110:             FT_UINT8, BASE_DEC, NULL, THREAD_NWD_TLV_BORDER_ROUTER_PREF,",
          "3111:             \"Value of P_preference\",",
          "3112:             HFILL }",
          "3113:         },",
          "3115:         { &hf_thread_nwd_tlv_border_router_p,",
          "3116:             { \"P Flag\",",
          "3117:             \"thread_nwd.tlv.border_router.flag.p\",",
          "3118:             FT_BOOLEAN, 8, TFS(&tfs_thread_nwd_tlv_border_router_p), THREAD_NWD_TLV_BORDER_ROUTER_P,",
          "3119:             \"Value of P_preferred\",",
          "3120:             HFILL }",
          "3121:         },",
          "3123:         { &hf_thread_nwd_tlv_border_router_s,",
          "3124:             { \"SLAAC\",",
          "3125:             \"thread_nwd.tlv.border_router.flag.s\",",
          "3126:             FT_BOOLEAN, 8, TFS(&tfs_allowed_not_allowed), THREAD_NWD_TLV_BORDER_ROUTER_S,",
          "3127:             \"Value of P_slaac\",",
          "3128:             HFILL }",
          "3129:         },",
          "3131:         { &hf_thread_nwd_tlv_border_router_d,",
          "3132:             { \"DHCPv6\",",
          "3133:             \"thread_nwd.tlv.border_router.flag.d\",",
          "3134:             FT_BOOLEAN, 8, TFS(&tfs_allowed_not_allowed), THREAD_NWD_TLV_BORDER_ROUTER_D,",
          "3135:             \"Value of P_dhcp\",",
          "3136:             HFILL }",
          "3137:         },",
          "3139:         { &hf_thread_nwd_tlv_border_router_c,",
          "3140:             { \"C Flag\",",
          "3141:             \"thread_nwd.tlv.border_router.flag.c\",",
          "3142:             FT_BOOLEAN, 8, TFS(&tfs_thread_nwd_tlv_border_router_c), THREAD_NWD_TLV_BORDER_ROUTER_C,",
          "3143:             \"Value of P_configure\",",
          "3144:             HFILL }",
          "3145:         },",
          "3147:         { &hf_thread_nwd_tlv_border_router_r,",
          "3148:             { \"Default route\",",
          "3149:             \"thread_nwd.tlv.border_router.flag.r\",",
          "3150:             FT_BOOLEAN, 8, TFS(&tfs_yes_no), THREAD_NWD_TLV_BORDER_ROUTER_R,",
          "3151:             \"Value of P_default\",",
          "3152:             HFILL }",
          "3153:         },",
          "3155:         { &hf_thread_nwd_tlv_border_router_o,",
          "3156:             { \"O Flag\",",
          "3157:             \"thread_nwd.tlv.border_router.flag.o\",",
          "3158:             FT_BOOLEAN, 8, TFS(&tfs_thread_nwd_tlv_border_router_o), THREAD_NWD_TLV_BORDER_ROUTER_O,",
          "3159:             \"Value of P_on_mesh\",",
          "3160:             HFILL }",
          "3161:         },",
          "3163:         { &hf_thread_nwd_tlv_border_router_n,",
          "3164:             { \"DNS\",",
          "3165:             \"thread_nwd.tlv.border_router.flag.n\",",
          "3166:             FT_BOOLEAN, 8, TFS(&tfs_available_not_available), THREAD_NWD_TLV_BORDER_ROUTER_N,",
          "3167:             \"Value of P_nd_dns\",",
          "3168:             HFILL }",
          "3169:         },",
          "3171:         { &hf_thread_nwd_tlv_6lowpan_id_6co_flag,",
          "3172:             { \"Flag\",",
          "3173:             \"thread_nwd.tlv.6co.flag\",",
          "3174:             FT_UINT8, BASE_HEX, NULL, 0x00,",
          "3175:             NULL,",
          "3176:             HFILL }",
          "3177:         },",
          "3179:         { &hf_thread_nwd_tlv_6lowpan_id_6co_flag_c,",
          "3180:             { \"Compression Flag\",",
          "3181:             \"thread_nwd.tlv.6co.flag.c\",",
          "3182:             FT_BOOLEAN, 8, TFS(&tfs_set_notset), ND_OPT_6CO_FLAG_C,",
          "3183:             \"This flag indicates if the context is valid for use in compression\",",
          "3184:             HFILL }",
          "3185:         },",
          "3187:         { &hf_thread_nwd_tlv_6lowpan_id_6co_flag_cid,",
          "3188:             { \"CID\",",
          "3189:             \"thread_nwd.tlv.6co.flag.cid\",",
          "3190:             FT_UINT8, BASE_DEC, NULL, ND_OPT_6CO_FLAG_CID,",
          "3191:             \"Context Identifier for this prefix information\",",
          "3192:             HFILL }",
          "3193:         },",
          "3195:         { &hf_thread_nwd_tlv_6lowpan_id_6co_flag_reserved,",
          "3196:             { \"Reserved\",",
          "3197:             \"thread_nwd.tlv.6co.flag.reserved\",",
          "3198:             FT_UINT8, BASE_DEC, NULL, ND_OPT_6CO_FLAG_RESERVED,",
          "3199:             \"Must be zero\",",
          "3200:             HFILL }",
          "3201:         },",
          "3203:         { &hf_thread_nwd_tlv_6lowpan_id_6co_context_length,",
          "3204:             { \"Context Length\",",
          "3205:             \"thread_nwd.tlv.6co.context_length\",",
          "3206:             FT_UINT8, BASE_DEC, NULL, 0x00,",
          "3207:             \"The number of leading bits in the Context Prefix field that are valid\",",
          "3208:             HFILL }",
          "3209:         },",
          "3210: #if 0",
          "3211:         { &hf_thread_nwd_tlv_comm_data,",
          "3212:             { \"Commissioning Data\",",
          "3213:             \"thread_nwd.tlv.comm_data\",",
          "3214:             FT_BYTES, BASE_NONE, NULL, 0x0,",
          "3215:             \"Contains Thread Commissioning data\",",
          "3216:             HFILL }",
          "3217:         },",
          "3218: #endif",
          "3219:         { &hf_thread_nwd_tlv_service_t,",
          "3220:             { \"T flag\",",
          "3221:             \"thread_nwd.tlv.service.t\",",
          "3222:             FT_UINT8, BASE_HEX, NULL, THREAD_NWD_TLV_SERVICE_T,",
          "3223:             NULL,",
          "3224:             HFILL }",
          "3225:         },",
          "3227:         { &hf_thread_nwd_tlv_service_s_id,",
          "3228:             { \"Service Type ID\",",
          "3229:             \"thread_nwd.tlv.service.s_id\",",
          "3230:             FT_UINT8, BASE_HEX, NULL, THREAD_NWD_TLV_SERVICE_S_ID,",
          "3231:             NULL,",
          "3232:             HFILL }",
          "3233:         },",
          "3235:         { &hf_thread_nwd_tlv_service_s_ent_num,",
          "3236:             { \"Enterprise Number\",",
          "3237:             \"thread_nwd.tlv.service.s_ent_num\",",
          "3238:             FT_UINT32, BASE_DEC, NULL, 0,",
          "3239:             NULL,",
          "3240:             HFILL }",
          "3241:         },",
          "3243:         { &hf_thread_nwd_tlv_service_s_data_len,",
          "3244:             { \"Service Data Length\",",
          "3245:             \"thread_nwd.tlv.service.s_data_len\",",
          "3246:             FT_UINT8, BASE_DEC, NULL, 0,",
          "3247:             NULL,",
          "3248:             HFILL }",
          "3249:         },",
          "3251:         { &hf_thread_nwd_tlv_service_s_data,",
          "3252:             { \"Service Data\",",
          "3253:             \"thread_nwd.tlv.service.s_data\",",
          "3254:             FT_BYTES, BASE_NONE, NULL, 0x0,",
          "3255:             \"Service data in raw bytes\",",
          "3256:             HFILL }",
          "3257:         },",
          "3259:         { &hf_thread_nwd_tlv_server_16,",
          "3260:             { \"Server 16\",",
          "3261:             \"thread_nwd.tlv.server.16\",",
          "3262:             FT_UINT16, BASE_HEX, NULL, 0x0,",
          "3263:             \"Server 16-bit address\",",
          "3264:             HFILL }",
          "3265:         },",
          "3267:         { &hf_thread_nwd_tlv_server_data,",
          "3268:             { \"Server Data\",",
          "3269:             \"thread_nwd.tlv.server.data\",",
          "3270:             FT_BYTES, BASE_NONE, NULL, 0x0,",
          "3271:             \"Server data in raw bytes\",",
          "3272:             HFILL }",
          "3273:         }",
          "3274:     };",
          "3276:     static gint *ett[] = {",
          "3277:         &ett_thread_nwd,",
          "3278:         &ett_thread_nwd_tlv,",
          "3279:         &ett_thread_nwd_has_route,",
          "3280:         &ett_thread_nwd_6co_flag,",
          "3281:         &ett_thread_nwd_border_router,",
          "3282:         &ett_thread_nwd_prefix_sub_tlvs",
          "3283:     };",
          "3285:     static ei_register_info ei[] = {",
          "3286: #if 0",
          "3287:         { &ei_thread_nwd_tlv_length_failed, { \"thread_nwd.tlv_length_failed\", PI_UNDECODED, PI_WARN, \"TLV Length inconsistent\", EXPFILL }},",
          "3288: #endif",
          "3289:         { &ei_thread_nwd_len_size_mismatch, { \"thread_nwd.len_size_mismatch\", PI_UNDECODED, PI_WARN, \"TLV Length & Size field disagree\", EXPFILL }},",
          "3290:     };",
          "3292:     expert_module_t* expert_thread_nwd;",
          "3294:     proto_thread_nwd = proto_register_protocol(\"Thread Network Data\", \"Thread NWD\", \"thread_nwd\");",
          "3295:     proto_register_field_array(proto_thread_nwd, hf, array_length(hf));",
          "3296:     proto_register_subtree_array(ett, array_length(ett));",
          "3297:     expert_thread_nwd = expert_register_protocol(proto_thread_nwd);",
          "3298:     expert_register_field_array(expert_thread_nwd, ei, array_length(ei));",
          "3300:     thread_address_nwd_handle = register_dissector(\"thread_nwd\", dissect_thread_nwd, proto_thread_nwd);",
          "3301: }",
          "3303: void proto_register_thread_bcn(void)",
          "3304: {",
          "3305:     static hf_register_info hf[] = {",
          "3307:         { &hf_thread_bcn_protocol,",
          "3308:         { \"Protocol ID\",          \"thread_bcn.protocol\", FT_UINT8, BASE_DEC, NULL, 0x0,",
          "3309:           NULL, HFILL }},",
          "3311:         { &hf_thread_bcn_joining,",
          "3312:         { \"Joining\",              \"thread_bcn.joining\", FT_BOOLEAN, 8, NULL, THREAD_BCN_JOINING,",
          "3313:           NULL, HFILL }},",
          "3315:         { &hf_thread_bcn_native,",
          "3316:         { \"Native\",               \"thread_bcn.native\", FT_BOOLEAN, 8, NULL, THREAD_BCN_NATIVE,",
          "3317:           NULL, HFILL }},",
          "3319:         { &hf_thread_bcn_version,",
          "3320:         { \"Version\",              \"thread_bcn.version\", FT_UINT8, BASE_DEC, NULL, THREAD_BCN_PROTOCOL_VERSION,",
          "3321:           NULL, HFILL }},",
          "3323:         { &hf_thread_bcn_network_id,",
          "3324:         { \"Network Name\",         \"thread_bcn.network_name\", FT_STRING, BASE_NONE, NULL, 0x0,",
          "3325:           \"A string that uniquely identifies this network.\", HFILL }},",
          "3327:         { &hf_thread_bcn_epid,",
          "3328:         { \"Extended PAN ID\",      \"thread_bcn.epid\", FT_EUI64, BASE_NONE, NULL, 0x0,",
          "3329:           NULL, HFILL }},",
          "3331:         { &hf_thread_bcn_tlv,",
          "3332:         { \"TLV\",                  \"thread_bcn.tlv\", FT_NONE, BASE_NONE, NULL, 0x0,",
          "3333:           \"Type-Length-Value\", HFILL }},",
          "3335:         { &hf_thread_bcn_tlv_type,",
          "3336:         { \"Type\",                 \"thread_bcn.tlv.type\", FT_UINT8, BASE_DEC, VALS(thread_bcn_tlv_vals), 0x0,",
          "3337:           \"Type of Value\", HFILL }},",
          "3339:         { &hf_thread_bcn_tlv_length,",
          "3340:         { \"Length\",               \"thread_bcn.tlv.len\", FT_UINT8, BASE_DEC, NULL, 0x0,",
          "3341:           \"Length of Value\", HFILL }},",
          "3343:         { &hf_thread_bcn_tlv_steering_data,",
          "3344:         { \"Steering Data\",         \"thread_bcn.tlv.steering_data\", FT_BYTES, BASE_NONE, NULL, 0x0,",
          "3345:           \"Steering data for joining devices\", HFILL }},",
          "3347:         { &hf_thread_bcn_tlv_unknown,",
          "3348:         { \"Unknown\",              \"thread_bcn.tlv.unknown\", FT_BYTES, BASE_NONE, NULL, 0x0,",
          "3349:           \"Unknown TLV, raw value\", HFILL }}",
          "3350:     };",
          "3353:     static gint *ett[] = {",
          "3354:         &ett_thread_bcn,",
          "3355:         &ett_thread_bcn_tlv",
          "3356:     };",
          "3359:     proto_thread_bcn = proto_register_protocol(\"Thread Beacon\", \"Thread Beacon\", \"thread_bcn\");",
          "3360:     proto_register_field_array(proto_thread_bcn, hf, array_length(hf));",
          "3361:     proto_register_subtree_array(ett, array_length(ett));",
          "3364:     register_dissector(\"thread_bcn\", dissect_thread_bcn, proto_thread_bcn);",
          "3365: }",
          "3367: static void",
          "3368: proto_init_thread(void)",
          "3369: {",
          "3371:     thread_seq_ctr_acqd = FALSE;",
          "3372:     memset(thread_seq_ctr_bytes, 0, 4);",
          "3373: }",
          "3375: void",
          "3376: proto_register_thread(void)",
          "3377: {",
          "3378:     module_t *thread_module;",
          "3380:     proto_thread = proto_register_protocol(\"Thread\", \"Thread\", \"thread\");",
          "3382:     thread_module = prefs_register_protocol(proto_thread, proto_reg_handoff_thread);",
          "3383:     prefs_register_bool_preference(thread_module, \"thr_coap_decode\",",
          "3384:                                    \"Decode CoAP for Thread\",",
          "3385:                                    \"Try to decode CoAP for Thread\",",
          "3386:                                    &thread_coap_decode);",
          "3388:     prefs_register_string_preference(thread_module, \"thr_seq_ctr\",",
          "3389:                                      \"Thread sequence counter\",",
          "3390:                                      \"32-bit sequence counter for hash\",",
          "3391:                                      (const char **)&thread_seq_ctr_str);",
          "3393:     prefs_register_bool_preference(thread_module, \"thr_use_pan_id_in_key\",",
          "3394:                                    \"Use PAN ID as first two octets of master key\",",
          "3395:                                    \"Set if the PAN ID should be used as the first two octets of the master key (PAN ID LSB), (PAN ID MSB), Key[2]...\",",
          "3396:                                    &thread_use_pan_id_in_key);",
          "3398:     prefs_register_bool_preference(thread_module, \"thr_auto_acq_thr_seq_ctr\",",
          "3399:                                    \"Automatically acquire Thread sequence counter\",",
          "3400:                                    \"Set if the Thread sequence counter should be automatically acquired from Key ID mode 2 MLE messages.\",",
          "3401:                                    &thread_auto_acq_seq_ctr);",
          "3403:     register_init_routine(proto_init_thread);",
          "3404: }",
          "3406: void",
          "3407: proto_register_thread_coap(void)",
          "3408: {",
          "3409:     proto_thread_coap = proto_register_protocol(\"Thread CoAP\", \"Thread CoAP\", \"thread_coap\");",
          "3410:     thread_coap_handle = register_dissector(\"thread_coap\", dissect_thread_coap, proto_thread_coap);",
          "3412:     thread_coap_namespace = register_dissector_table(\"thread.coap_namespace\", \"Thread CoAP namespace\", proto_thread_coap, FT_STRING, BASE_NONE);",
          "3413: }",
          "3415: void",
          "3416: proto_reg_handoff_thread_mc(void)",
          "3417: {",
          "3418:     thread_dtls_handle = find_dissector_add_dependency(\"dtls\", proto_thread_mc);",
          "3419:     thread_udp_handle = find_dissector_add_dependency(\"udp\", proto_thread_mc);",
          "3421:     dissector_add_string(\"thread.coap_namespace\", \"c\", thread_mc_handle);",
          "3422: }",
          "3424: void",
          "3425: proto_reg_handoff_thread_address(void)",
          "3426: {",
          "3427:     dissector_add_string(\"thread.coap_namespace\", \"a\", thread_address_handle);",
          "3428:     dissector_add_string(\"thread.coap_namespace\", \"n\", thread_address_handle);",
          "3429: }",
          "3431: void",
          "3432: proto_reg_handoff_thread_dg(void)",
          "3433: {",
          "3434:     dissector_add_string(\"thread.coap_namespace\", \"d\", thread_dg_handle);",
          "3435: }",
          "3437: void proto_reg_handoff_thread_bcn(void)",
          "3438: {",
          "3440:     heur_dissector_add(IEEE802154_PROTOABBREV_WPAN_BEACON, dissect_thread_bcn_heur, \"Thread Beacon\", \"thread_wlan_beacon\", proto_thread_bcn, HEURISTIC_ENABLE);",
          "3442:     register_mle_key_hash_handler(KEY_HASH_THREAD, set_thread_mle_key);",
          "3443:     register_ieee802154_mac_key_hash_handler(KEY_HASH_THREAD, set_thread_mac_key);",
          "3444: }",
          "3446: void",
          "3447: proto_reg_handoff_thread(void)",
          "3448: {",
          "3450:     if (thread_coap_decode) {",
          "3451:         dissector_add_string(\"media_type\", \"application/octet-stream\", thread_coap_handle);",
          "3452:     } else {",
          "3453:         dissector_delete_string(\"media_type\", \"application/octet-stream\", thread_coap_handle);",
          "3454:     }",
          "3456:     proto_coap = proto_get_id_by_filter_name(\"coap\");",
          "3457: }",
          "",
          "---------------"
        ],
        "tools/checkfiltername.pl||tools/checkfiltername.pl": [
          "File: tools/checkfiltername.pl -> tools/checkfiltername.pl",
          "--- Hunk 1 ---",
          "[Context before]",
          "420:  if (($proto_filename eq \"packet-k12.c\") && (index($_[0], \"aal2\") >= 0)) {return 1;}",
          "421:  if (($proto_filename eq \"packet-k12.c\") && (index($_[0], \"atm\") >= 0)) {return 1;}",
          "422:  if (($proto_filename eq \"packet-m3ua.c\") && (index($_[0], \"mtp3\") >= 0)) {return 1;}",
          "423:  if (($proto_filename eq \"packet-mpeg-dsmcc.c\") && (index($_[0], \"mpeg_sect\") >= 0)) {return 1;}",
          "424:  if (($proto_filename eq \"packet-mpeg-dsmcc.c\") && (index($_[0], \"etv.dsmcc\") >= 0)) {return 1;}",
          "425:  if (($proto_filename eq \"packet-mpeg1.c\") && (index($_[0], \"rtp.payload_mpeg_\") >= 0)) {return 1;}",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "423:  if (($proto_filename eq \"packet-mle.c\") && (index($_[0], \"wpan\") >= 0)) {return 1;}",
          "",
          "---------------"
        ]
      }
    }
  ]
}
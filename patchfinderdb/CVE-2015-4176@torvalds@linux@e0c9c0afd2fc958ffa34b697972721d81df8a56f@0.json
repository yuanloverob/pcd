{
  "cve_id": "CVE-2015-4176",
  "cve_desc": "fs/namespace.c in the Linux kernel before 4.0.2 does not properly support mount connectivity, which allows local users to read arbitrary files by leveraging user-namespace root access for deletion of a file or directory.",
  "repo": "torvalds/linux",
  "patch_hash": "e0c9c0afd2fc958ffa34b697972721d81df8a56f",
  "patch_info": {
    "commit_hash": "e0c9c0afd2fc958ffa34b697972721d81df8a56f",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/e0c9c0afd2fc958ffa34b697972721d81df8a56f",
    "files": [
      "fs/namespace.c"
    ],
    "message": "mnt: Update detach_mounts to leave mounts connected\n\nNow that it is possible to lazily unmount an entire mount tree and\nleave the individual mounts connected to each other add a new flag\nUMOUNT_CONNECTED to umount_tree to force this behavior and use\nthis flag in detach_mounts.\n\nThis closes a bug where the deletion of a file or directory could\ntrigger an unmount and reveal data under a mount point.\n\nCc: stable@vger.kernel.org\nSigned-off-by: \"Eric W. Biederman\" <ebiederm@xmission.com>",
    "before_after_code_files": [
      "fs/namespace.c||fs/namespace.c"
    ]
  },
  "patch_diff": {
    "fs/namespace.c||fs/namespace.c": [
      "File: fs/namespace.c -> fs/namespace.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1348: enum umount_tree_flags {",
      "1349:  UMOUNT_SYNC = 1,",
      "1350:  UMOUNT_PROPAGATE = 2,",
      "1351: };",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1351:  UMOUNT_CONNECTED = 4,",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1386:   if (how & UMOUNT_SYNC)",
      "1387:    p->mnt.mnt_flags |= MNT_SYNC_UMOUNT;",
      "1391:   pin_insert_group(&p->mnt_umount, &p->mnt_parent->mnt,",
      "1392:      disconnect ? &unmounted : NULL);",
      "",
      "[Removed Lines]",
      "1389:   disconnect = !IS_MNT_LOCKED_AND_LAZY(p);",
      "",
      "[Added Lines]",
      "1390:   disconnect = !(((how & UMOUNT_CONNECTED) &&",
      "1391:     mnt_has_parent(p) &&",
      "1392:     (p->mnt_parent->mnt.mnt_flags & MNT_UMOUNT)) ||",
      "1393:           IS_MNT_LOCKED_AND_LAZY(p));",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1529:     umount_mnt(p);",
      "1530:    }",
      "1531:   }",
      "1533:  }",
      "1534:  unlock_mount_hash();",
      "1535:  put_mountpoint(mp);",
      "",
      "[Removed Lines]",
      "1532:   else umount_tree(mnt, 0);",
      "",
      "[Added Lines]",
      "1536:   else umount_tree(mnt, UMOUNT_CONNECTED);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "87b95ce0964c016ede92763be9c164e49f1019e9",
      "candidate_info": {
        "commit_hash": "87b95ce0964c016ede92763be9c164e49f1019e9",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/87b95ce0964c016ede92763be9c164e49f1019e9",
        "files": [
          "fs/fs_pin.c",
          "fs/mount.h",
          "fs/namespace.c"
        ],
        "message": "switch the IO-triggering parts of umount to fs_pin\n\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>",
        "before_after_code_files": [
          "fs/fs_pin.c||fs/fs_pin.c",
          "fs/mount.h||fs/mount.h",
          "fs/namespace.c||fs/namespace.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/namespace.c||fs/namespace.c"
          ],
          "candidate": [
            "fs/namespace.c||fs/namespace.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/fs_pin.c||fs/fs_pin.c": [
          "File: fs/fs_pin.c -> fs/fs_pin.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: #include <linux/fs.h>",
          "2: #include <linux/sched.h>",
          "3: #include <linux/slab.h>",
          "5: #include \"internal.h\"",
          "6: #include \"mount.h\"",
          "",
          "[Removed Lines]",
          "4: #include <linux/fs_pin.h>",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "fs/mount.h||fs/mount.h": [
          "File: fs/mount.h -> fs/mount.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "2: #include <linux/seq_file.h>",
          "3: #include <linux/poll.h>",
          "4: #include <linux/ns_common.h>",
          "6: struct mnt_namespace {",
          "7:  atomic_t  count;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5: #include <linux/fs_pin.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "64:  struct hlist_head mnt_pins;",
          "66: };",
          "",
          "[Removed Lines]",
          "65:  struct path mnt_ex_mountpoint;",
          "",
          "[Added Lines]",
          "66:  struct fs_pin mnt_umount;",
          "67:  struct dentry *mnt_ex_mountpoint;",
          "",
          "---------------"
        ],
        "fs/namespace.c||fs/namespace.c": [
          "File: fs/namespace.c -> fs/namespace.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "190: #endif",
          "191: }",
          "193: static struct mount *alloc_vfsmnt(const char *name)",
          "194: {",
          "195:  struct mount *mnt = kmem_cache_zalloc(mnt_cache, GFP_KERNEL);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "193: static void drop_mountpoint(struct fs_pin *p)",
          "194: {",
          "195:  struct mount *m = container_of(p, struct mount, mnt_umount);",
          "196:  dput(m->mnt_ex_mountpoint);",
          "197:  pin_remove(p);",
          "198:  mntput(&m->mnt);",
          "199: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "229: #ifdef CONFIG_FSNOTIFY",
          "230:   INIT_HLIST_HEAD(&mnt->mnt_fsnotify_marks);",
          "231: #endif",
          "232:  }",
          "233:  return mnt;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "240:   init_fs_pin(&mnt->mnt_umount, drop_mountpoint);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1290: static void namespace_unlock(void)",
          "1291: {",
          "1293:  struct hlist_head head = unmounted;",
          "1295:  if (likely(hlist_empty(&head))) {",
          "",
          "[Removed Lines]",
          "1292:  struct mount *mnt;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1300:  head.first->pprev = &head.first;",
          "1301:  INIT_HLIST_HEAD(&unmounted);",
          "1308:  up_write(&namespace_sem);",
          "1310:  synchronize_rcu();",
          "1319: }",
          "1321: static inline void namespace_lock(void)",
          "",
          "[Removed Lines]",
          "1304:  hlist_for_each_entry(mnt, &head, mnt_hash)",
          "1305:   if (mnt->mnt_ex_mountpoint.mnt)",
          "1306:    mntget(mnt->mnt_ex_mountpoint.mnt);",
          "1312:  while (!hlist_empty(&head)) {",
          "1313:   mnt = hlist_entry(head.first, struct mount, mnt_hash);",
          "1314:   hlist_del_init(&mnt->mnt_hash);",
          "1315:   if (mnt->mnt_ex_mountpoint.mnt)",
          "1316:    path_put(&mnt->mnt_ex_mountpoint);",
          "1317:   mntput(&mnt->mnt);",
          "1318:  }",
          "",
          "[Added Lines]",
          "1314:  group_pin_kill(&head);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1334: {",
          "1335:  HLIST_HEAD(tmp_list);",
          "1336:  struct mount *p;",
          "1339:  for (p = mnt; p; p = next_mnt(p, mnt)) {",
          "1340:   hlist_del_init_rcu(&p->mnt_hash);",
          "",
          "[Removed Lines]",
          "1337:  struct mount *last = NULL;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1347:  if (how)",
          "1348:   propagate_umount(&tmp_list);",
          "1351:   list_del_init(&p->mnt_expire);",
          "1352:   list_del_init(&p->mnt_list);",
          "1353:   __touch_mnt_namespace(p->mnt_ns);",
          "1354:   p->mnt_ns = NULL;",
          "1355:   if (how < 2)",
          "1356:    p->mnt.mnt_flags |= MNT_SYNC_UMOUNT;",
          "1357:   if (mnt_has_parent(p)) {",
          "1358:    hlist_del_init(&p->mnt_mp_list);",
          "1359:    put_mountpoint(p->mnt_mp);",
          "1360:    mnt_add_count(p->mnt_parent, -1);",
          "1364:    p->mnt_mountpoint = p->mnt.mnt_root;",
          "1365:    p->mnt_parent = p;",
          "1366:    p->mnt_mp = NULL;",
          "1367:   }",
          "1368:   change_mnt_propagation(p, MS_PRIVATE);",
          "1377:  }",
          "1378: }",
          "",
          "[Removed Lines]",
          "1350:  hlist_for_each_entry(p, &tmp_list, mnt_hash) {",
          "1362:    p->mnt_ex_mountpoint.dentry = p->mnt_mountpoint;",
          "1363:    p->mnt_ex_mountpoint.mnt = &p->mnt_parent->mnt;",
          "1369:   last = p;",
          "1370:  }",
          "1371:  if (last) {",
          "1372:   last->mnt_hash.next = unmounted.first;",
          "1373:   if (unmounted.first)",
          "1374:    unmounted.first->pprev = &last->mnt_hash.next;",
          "1375:   unmounted.first = tmp_list.first;",
          "1376:   unmounted.first->pprev = &unmounted.first;",
          "",
          "[Added Lines]",
          "1345:  while (!hlist_empty(&tmp_list)) {",
          "1346:   p = hlist_entry(tmp_list.first, struct mount, mnt_hash);",
          "1347:   hlist_del_init_rcu(&p->mnt_hash);",
          "1355:   pin_insert_group(&p->mnt_umount, &p->mnt_parent->mnt, &unmounted);",
          "1361:    p->mnt_ex_mountpoint = p->mnt_mountpoint;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "f2d0a123bcf16d1a9cf7942ddc98e0ef77862c2b",
      "candidate_info": {
        "commit_hash": "f2d0a123bcf16d1a9cf7942ddc98e0ef77862c2b",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/f2d0a123bcf16d1a9cf7942ddc98e0ef77862c2b",
        "files": [
          "fs/namespace.c",
          "fs/pnode.h"
        ],
        "message": "mnt: Clarify and correct the disconnect logic in umount_tree\n\nrmdir mntpoint will result in an infinite loop when there is\na mount locked on the mountpoint in another mount namespace.\n\nThis is because the logic to test to see if a mount should\nbe disconnected in umount_tree is buggy.\n\nMove the logic to decide if a mount should remain connected to\nit's mountpoint into it's own function disconnect_mount so that\nclarity of expression instead of terseness of expression becomes\na virtue.\n\nWhen the conditions where it is invalid to leave a mount connected\nare first ruled out, the logic for deciding if a mount should\nbe disconnected becomes much clearer and simpler.\n\nFixes: e0c9c0afd2fc958ffa34b697972721d81df8a56f mnt: Update detach_mounts to leave mounts connected\nFixes: ce07d891a0891d3c0d0c2d73d577490486b809e1 mnt: Honor MNT_LOCKED when detaching mounts\nCc: stable@vger.kernel.org\nSigned-off-by: \"Eric W. Biederman\" <ebiederm@xmission.com>",
        "before_after_code_files": [
          "fs/namespace.c||fs/namespace.c",
          "fs/pnode.h||fs/pnode.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/namespace.c||fs/namespace.c"
          ],
          "candidate": [
            "fs/namespace.c||fs/namespace.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/namespace.c||fs/namespace.c": [
          "File: fs/namespace.c -> fs/namespace.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1361:  UMOUNT_PROPAGATE = 2,",
          "1362:  UMOUNT_CONNECTED = 4,",
          "1363: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1365: static bool disconnect_mount(struct mount *mnt, enum umount_tree_flags how)",
          "1366: {",
          "1368:  if (how & UMOUNT_SYNC)",
          "1369:   return true;",
          "1372:  if (!mnt_has_parent(mnt))",
          "1373:   return true;",
          "1379:  if (!(mnt->mnt_parent->mnt.mnt_flags & MNT_UMOUNT))",
          "1380:   return true;",
          "1383:  if (how & UMOUNT_CONNECTED)",
          "1384:   return false;",
          "1387:  if (IS_MNT_LOCKED(mnt))",
          "1388:   return false;",
          "1391:  return true;",
          "1392: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1398:   if (how & UMOUNT_SYNC)",
          "1399:    p->mnt.mnt_flags |= MNT_SYNC_UMOUNT;",
          "1406:   pin_insert_group(&p->mnt_umount, &p->mnt_parent->mnt,",
          "1407:      disconnect ? &unmounted : NULL);",
          "",
          "[Removed Lines]",
          "1401:   disconnect = !(((how & UMOUNT_CONNECTED) &&",
          "1402:     mnt_has_parent(p) &&",
          "1403:     (p->mnt_parent->mnt.mnt_flags & MNT_UMOUNT)) ||",
          "1404:           IS_MNT_LOCKED_AND_LAZY(p));",
          "",
          "[Added Lines]",
          "1431:   disconnect = disconnect_mount(p, how);",
          "",
          "---------------"
        ],
        "fs/pnode.h||fs/pnode.h": [
          "File: fs/pnode.h -> fs/pnode.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "20: #define SET_MNT_MARK(m) ((m)->mnt.mnt_flags |= MNT_MARKED)",
          "21: #define CLEAR_MNT_MARK(m) ((m)->mnt.mnt_flags &= ~MNT_MARKED)",
          "22: #define IS_MNT_LOCKED(m) ((m)->mnt.mnt_flags & MNT_LOCKED)",
          "26: #define CL_EXPIRE      0x01",
          "27: #define CL_SLAVE       0x02",
          "",
          "[Removed Lines]",
          "23: #define IS_MNT_LOCKED_AND_LAZY(m) \\",
          "24:  (((m)->mnt.mnt_flags & (MNT_LOCKED|MNT_SYNC_UMOUNT)) == MNT_LOCKED)",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "80b5dce8c59b0de1ed6e403b8298e02dcb4db64b",
      "candidate_info": {
        "commit_hash": "80b5dce8c59b0de1ed6e403b8298e02dcb4db64b",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/80b5dce8c59b0de1ed6e403b8298e02dcb4db64b",
        "files": [
          "fs/mount.h",
          "fs/namespace.c"
        ],
        "message": "vfs: Add a function to lazily unmount all mounts from any dentry.\n\nThe new function detach_mounts comes in two pieces.  The first piece\nis a static inline test of d_mounpoint that returns immediately\nwithout taking any locks if d_mounpoint is not set.  In the common\ncase when mountpoints are absent this allows the vfs to continue\nrunning with it's same cacheline foot print.\n\nThe second piece of detach_mounts __detach_mounts actually does the\nwork and it assumes that a mountpoint is present so it is slow and\ntakes namespace_sem for write, and then locks the mount hash (aka\nmount_lock) after a struct mountpoint has been found.\n\nWith those two locks held each entry on the list of mounts on a\nmountpoint is selected and lazily unmounted until all of the mount\nhave been lazily unmounted.\n\nv7: Wrote a proper change description and removed the changelog\n    documenting deleted wrong turns.\n\nSigned-off-by: Eric W. Biederman <ebiederman@twitter.com>\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>",
        "before_after_code_files": [
          "fs/mount.h||fs/mount.h",
          "fs/namespace.c||fs/namespace.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/namespace.c||fs/namespace.c"
          ],
          "candidate": [
            "fs/namespace.c||fs/namespace.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/mount.h||fs/mount.h": [
          "File: fs/mount.h -> fs/mount.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "88: extern bool legitimize_mnt(struct vfsmount *, unsigned);",
          "90: static inline void get_mnt_ns(struct mnt_namespace *ns)",
          "91: {",
          "92:  atomic_inc(&ns->count);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "90: extern void __detach_mounts(struct dentry *dentry);",
          "92: static inline void detach_mounts(struct dentry *dentry)",
          "93: {",
          "94:  if (!d_mountpoint(dentry))",
          "95:   return;",
          "96:  __detach_mounts(dentry);",
          "97: }",
          "",
          "---------------"
        ],
        "fs/namespace.c||fs/namespace.c": [
          "File: fs/namespace.c -> fs/namespace.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1468:  return retval;",
          "1469: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1481: void __detach_mounts(struct dentry *dentry)",
          "1482: {",
          "1483:  struct mountpoint *mp;",
          "1484:  struct mount *mnt;",
          "1486:  namespace_lock();",
          "1487:  mp = lookup_mountpoint(dentry);",
          "1488:  if (!mp)",
          "1489:   goto out_unlock;",
          "1491:  lock_mount_hash();",
          "1492:  while (!hlist_empty(&mp->m_list)) {",
          "1493:   mnt = hlist_entry(mp->m_list.first, struct mount, mnt_mp_list);",
          "1494:   umount_tree(mnt, 2);",
          "1495:  }",
          "1496:  unlock_mount_hash();",
          "1497:  put_mountpoint(mp);",
          "1498: out_unlock:",
          "1499:  namespace_unlock();",
          "1500: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "ce07d891a0891d3c0d0c2d73d577490486b809e1",
      "candidate_info": {
        "commit_hash": "ce07d891a0891d3c0d0c2d73d577490486b809e1",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/ce07d891a0891d3c0d0c2d73d577490486b809e1",
        "files": [
          "fs/namespace.c",
          "fs/pnode.h"
        ],
        "message": "mnt: Honor MNT_LOCKED when detaching mounts\n\nModify umount(MNT_DETACH) to keep mounts in the hash table that are\nlocked to their parent mounts, when the parent is lazily unmounted.\n\nIn mntput_no_expire detach the children from the hash table, depending\non mnt_pin_kill in cleanup_mnt to decrement the mnt_count of the children.\n\nIn __detach_mounts if there are any mounts that have been unmounted\nbut still are on the list of mounts of a mountpoint, remove their\nchildren from the mount hash table and those children to the unmounted\nlist so they won't linger potentially indefinitely waiting for their\nfinal mntput, now that the mounts serve no purpose.\n\nCc: stable@vger.kernel.org\nSigned-off-by: \"Eric W. Biederman\" <ebiederm@xmission.com>",
        "before_after_code_files": [
          "fs/namespace.c||fs/namespace.c",
          "fs/pnode.h||fs/pnode.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/namespace.c||fs/namespace.c"
          ],
          "candidate": [
            "fs/namespace.c||fs/namespace.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/namespace.c||fs/namespace.c": [
          "File: fs/namespace.c -> fs/namespace.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1099:  rcu_read_unlock();",
          "1101:  list_del(&mnt->mnt_instance);",
          "1102:  unlock_mount_hash();",
          "1104:  if (likely(!(mnt->mnt.mnt_flags & MNT_INTERNAL))) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1103:  if (unlikely(!list_empty(&mnt->mnt_mounts))) {",
          "1104:   struct mount *p, *tmp;",
          "1105:   list_for_each_entry_safe(p, tmp, &mnt->mnt_mounts,  mnt_child) {",
          "1106:    umount_mnt(p);",
          "1107:   }",
          "1108:  }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1370:   propagate_umount(&tmp_list);",
          "1372:  while (!list_empty(&tmp_list)) {",
          "1373:   p = list_first_entry(&tmp_list, struct mount, mnt_list);",
          "1374:   list_del_init(&p->mnt_expire);",
          "1375:   list_del_init(&p->mnt_list);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1380:   bool disconnect;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1378:   if (how & UMOUNT_SYNC)",
          "1379:    p->mnt.mnt_flags |= MNT_SYNC_UMOUNT;",
          "1382:   if (mnt_has_parent(p)) {",
          "1383:    mnt_add_count(p->mnt_parent, -1);",
          "1385:   }",
          "1386:   change_mnt_propagation(p, MS_PRIVATE);",
          "1387:  }",
          "",
          "[Removed Lines]",
          "1381:   pin_insert_group(&p->mnt_umount, &p->mnt_parent->mnt, &unmounted);",
          "1384:    umount_mnt(p);",
          "",
          "[Added Lines]",
          "1389:   disconnect = !IS_MNT_LOCKED_AND_LAZY(p);",
          "1391:   pin_insert_group(&p->mnt_umount, &p->mnt_parent->mnt,",
          "1392:      disconnect ? &unmounted : NULL);",
          "1395:    if (!disconnect) {",
          "1397:     list_add_tail(&p->mnt_child, &p->mnt_parent->mnt_mounts);",
          "1398:    } else {",
          "1399:     umount_mnt(p);",
          "1400:    }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1506:  lock_mount_hash();",
          "1507:  while (!hlist_empty(&mp->m_list)) {",
          "1508:   mnt = hlist_entry(mp->m_list.first, struct mount, mnt_mp_list);",
          "1510:  }",
          "1511:  unlock_mount_hash();",
          "1512:  put_mountpoint(mp);",
          "",
          "[Removed Lines]",
          "1509:   umount_tree(mnt, 0);",
          "",
          "[Added Lines]",
          "1525:   if (mnt->mnt.mnt_flags & MNT_UMOUNT) {",
          "1526:    struct mount *p, *tmp;",
          "1527:    list_for_each_entry_safe(p, tmp, &mnt->mnt_mounts,  mnt_child) {",
          "1528:     hlist_add_head(&p->mnt_umount.s_list, &unmounted);",
          "1529:     umount_mnt(p);",
          "1530:    }",
          "1531:   }",
          "1532:   else umount_tree(mnt, 0);",
          "",
          "---------------"
        ],
        "fs/pnode.h||fs/pnode.h": [
          "File: fs/pnode.h -> fs/pnode.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "20: #define SET_MNT_MARK(m) ((m)->mnt.mnt_flags |= MNT_MARKED)",
          "21: #define CLEAR_MNT_MARK(m) ((m)->mnt.mnt_flags &= ~MNT_MARKED)",
          "22: #define IS_MNT_LOCKED(m) ((m)->mnt.mnt_flags & MNT_LOCKED)",
          "24: #define CL_EXPIRE      0x01",
          "25: #define CL_SLAVE       0x02",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "23: #define IS_MNT_LOCKED_AND_LAZY(m) \\",
          "24:  (((m)->mnt.mnt_flags & (MNT_LOCKED|MNT_SYNC_UMOUNT)) == MNT_LOCKED)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "e819f152104c9f7c9fe50e1aecce6f5d4bf06d65",
      "candidate_info": {
        "commit_hash": "e819f152104c9f7c9fe50e1aecce6f5d4bf06d65",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/e819f152104c9f7c9fe50e1aecce6f5d4bf06d65",
        "files": [
          "fs/namespace.c",
          "fs/pnode.h"
        ],
        "message": "mnt: Improve the umount_tree flags\n\n- Remove the unneeded declaration from pnode.h\n- Mark umount_tree static as it has no callers outside of namespace.c\n- Define an enumeration of umount_tree's flags.\n- Pass umount_tree's flags in by name\n\nThis removes the magic numbers 0, 1 and 2 making the code a little\nclearer and makes it possible for there to be lazy unmounts that don't\npropagate.  Which is what __detach_mounts actually wants for example.\n\nCc: stable@vger.kernel.org\nSigned-off-by: \"Eric W. Biederman\" <ebiederm@xmission.com>",
        "before_after_code_files": [
          "fs/namespace.c||fs/namespace.c",
          "fs/pnode.h||fs/pnode.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/namespace.c||fs/namespace.c"
          ],
          "candidate": [
            "fs/namespace.c||fs/namespace.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/namespace.c||fs/namespace.c": [
          "File: fs/namespace.c -> fs/namespace.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1317:  down_write(&namespace_sem);",
          "1318: }",
          "1328: {",
          "1329:  HLIST_HEAD(tmp_list);",
          "1330:  struct mount *p;",
          "",
          "[Removed Lines]",
          "1327: void umount_tree(struct mount *mnt, int how)",
          "",
          "[Added Lines]",
          "1320: enum umount_tree_flags {",
          "1321:  UMOUNT_SYNC = 1,",
          "1322:  UMOUNT_PROPAGATE = 2,",
          "1323: };",
          "1328: static void umount_tree(struct mount *mnt, enum umount_tree_flags how)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1337:  hlist_for_each_entry(p, &tmp_list, mnt_hash)",
          "1338:   list_del_init(&p->mnt_child);",
          "1341:   propagate_umount(&tmp_list);",
          "1343:  while (!hlist_empty(&tmp_list)) {",
          "",
          "[Removed Lines]",
          "1340:  if (how)",
          "",
          "[Added Lines]",
          "1341:  if (how & UMOUNT_PROPAGATE)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1347:   list_del_init(&p->mnt_list);",
          "1348:   __touch_mnt_namespace(p->mnt_ns);",
          "1349:   p->mnt_ns = NULL;",
          "1351:    p->mnt.mnt_flags |= MNT_SYNC_UMOUNT;",
          "1353:   pin_insert_group(&p->mnt_umount, &p->mnt_parent->mnt, &unmounted);",
          "",
          "[Removed Lines]",
          "1350:   if (how < 2)",
          "",
          "[Added Lines]",
          "1351:   if (how & UMOUNT_SYNC)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1446:  if (flags & MNT_DETACH) {",
          "1447:   if (!list_empty(&mnt->mnt_list))",
          "1449:   retval = 0;",
          "1450:  } else {",
          "1451:   shrink_submounts(mnt);",
          "1452:   retval = -EBUSY;",
          "1453:   if (!propagate_mount_busy(mnt, 2)) {",
          "1454:    if (!list_empty(&mnt->mnt_list))",
          "1456:    retval = 0;",
          "1457:   }",
          "1458:  }",
          "",
          "[Removed Lines]",
          "1448:    umount_tree(mnt, 2);",
          "1455:     umount_tree(mnt, 1);",
          "",
          "[Added Lines]",
          "1449:    umount_tree(mnt, UMOUNT_PROPAGATE);",
          "1456:     umount_tree(mnt, UMOUNT_PROPAGATE|UMOUNT_SYNC);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1484:  lock_mount_hash();",
          "1485:  while (!hlist_empty(&mp->m_list)) {",
          "1486:   mnt = hlist_entry(mp->m_list.first, struct mount, mnt_mp_list);",
          "1488:  }",
          "1489:  unlock_mount_hash();",
          "1490:  put_mountpoint(mp);",
          "",
          "[Removed Lines]",
          "1487:   umount_tree(mnt, 2);",
          "",
          "[Added Lines]",
          "1488:   umount_tree(mnt, UMOUNT_PROPAGATE);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1646: out:",
          "1647:  if (res) {",
          "1648:   lock_mount_hash();",
          "1650:   unlock_mount_hash();",
          "1651:  }",
          "1652:  return q;",
          "",
          "[Removed Lines]",
          "1649:   umount_tree(res, 0);",
          "",
          "[Added Lines]",
          "1650:   umount_tree(res, UMOUNT_SYNC);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1670: {",
          "1671:  namespace_lock();",
          "1672:  lock_mount_hash();",
          "1674:  unlock_mount_hash();",
          "1675:  namespace_unlock();",
          "1676: }",
          "",
          "[Removed Lines]",
          "1673:  umount_tree(real_mount(mnt), 0);",
          "",
          "[Added Lines]",
          "1674:  umount_tree(real_mount(mnt), UMOUNT_SYNC);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1853:  out_cleanup_ids:",
          "1854:  while (!hlist_empty(&tree_list)) {",
          "1855:   child = hlist_entry(tree_list.first, struct mount, mnt_hash);",
          "1857:  }",
          "1858:  unlock_mount_hash();",
          "1859:  cleanup_group_ids(source_mnt, NULL);",
          "",
          "[Removed Lines]",
          "1856:   umount_tree(child, 0);",
          "",
          "[Added Lines]",
          "1857:   umount_tree(child, UMOUNT_SYNC);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "2033:  err = graft_tree(mnt, parent, mp);",
          "2034:  if (err) {",
          "2035:   lock_mount_hash();",
          "2037:   unlock_mount_hash();",
          "2038:  }",
          "2039: out2:",
          "",
          "[Removed Lines]",
          "2036:   umount_tree(mnt, 0);",
          "",
          "[Added Lines]",
          "2037:   umount_tree(mnt, UMOUNT_SYNC);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "2404:  while (!list_empty(&graveyard)) {",
          "2405:   mnt = list_first_entry(&graveyard, struct mount, mnt_expire);",
          "2406:   touch_mnt_namespace(mnt->mnt_ns);",
          "2408:  }",
          "2409:  unlock_mount_hash();",
          "2410:  namespace_unlock();",
          "",
          "[Removed Lines]",
          "2407:   umount_tree(mnt, 1);",
          "",
          "[Added Lines]",
          "2408:   umount_tree(mnt, UMOUNT_PROPAGATE|UMOUNT_SYNC);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "2475:    m = list_first_entry(&graveyard, struct mount,",
          "2476:       mnt_expire);",
          "2477:    touch_mnt_namespace(m->mnt_ns);",
          "2479:   }",
          "2480:  }",
          "2481: }",
          "",
          "[Removed Lines]",
          "2478:    umount_tree(m, 1);",
          "",
          "[Added Lines]",
          "2479:    umount_tree(m, UMOUNT_PROPAGATE|UMOUNT_SYNC);",
          "",
          "---------------"
        ],
        "fs/pnode.h||fs/pnode.h": [
          "File: fs/pnode.h -> fs/pnode.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "47: unsigned int mnt_get_count(struct mount *mnt);",
          "48: void mnt_set_mountpoint(struct mount *, struct mountpoint *,",
          "49:    struct mount *);",
          "51: struct mount *copy_tree(struct mount *, struct dentry *, int);",
          "52: bool is_path_reachable(struct mount *, struct dentry *,",
          "53:     const struct path *root);",
          "",
          "[Removed Lines]",
          "50: void umount_tree(struct mount *, int);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2016-2105",
  "cve_desc": "Integer overflow in the EVP_EncodeUpdate function in crypto/evp/encode.c in OpenSSL before 1.0.1t and 1.0.2 before 1.0.2h allows remote attackers to cause a denial of service (heap memory corruption) via a large amount of binary data.",
  "repo": "openssl/openssl",
  "patch_hash": "ee1e3cac2e83abc77bcc8ff98729ca1e10fcc920",
  "patch_info": {
    "commit_hash": "ee1e3cac2e83abc77bcc8ff98729ca1e10fcc920",
    "repo": "openssl/openssl",
    "commit_url": "https://github.com/openssl/openssl/commit/ee1e3cac2e83abc77bcc8ff98729ca1e10fcc920",
    "files": [
      "crypto/evp/encode.c"
    ],
    "message": "Avoid overflow in EVP_EncodeUpdate\n\nAn overflow can occur in the EVP_EncodeUpdate function which is used for\nBase64 encoding of binary data. If an attacker is able to supply very large\namounts of input data then a length check can overflow resulting in a heap\ncorruption. Due to the very large amounts of data involved this will most\nlikely result in a crash.\n\nInternally to OpenSSL the EVP_EncodeUpdate function is primarly used by the\nPEM_write_bio* family of functions. These are mainly used within the\nOpenSSL command line applications, so any application which processes\ndata from an untrusted source and outputs it as a PEM file should be\nconsidered vulnerable to this issue.\n\nUser applications that call these APIs directly with large amounts of\nuntrusted data may also be vulnerable.\n\nIssue reported by Guido Vranken.\n\nCVE-2016-2105\n\nReviewed-by: Richard Levitte <levitte@openssl.org>",
    "before_after_code_files": [
      "crypto/evp/encode.c||crypto/evp/encode.c"
    ]
  },
  "patch_diff": {
    "crypto/evp/encode.c||crypto/evp/encode.c": [
      "File: crypto/evp/encode.c -> crypto/evp/encode.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "171:     if (inl <= 0)",
      "172:         return;",
      "173:     OPENSSL_assert(ctx->length <= (int)sizeof(ctx->enc_data));",
      "175:         memcpy(&(ctx->enc_data[ctx->num]), in, inl);",
      "176:         ctx->num += inl;",
      "177:         return;",
      "",
      "[Removed Lines]",
      "174:     if ((ctx->num + inl) < ctx->length) {",
      "",
      "[Added Lines]",
      "174:     if (ctx->length - ctx->num > inl) {",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "172c6e1e14defe7d49d62f5fc9ea6a79b225424f",
      "candidate_info": {
        "commit_hash": "172c6e1e14defe7d49d62f5fc9ea6a79b225424f",
        "repo": "openssl/openssl",
        "commit_url": "https://github.com/openssl/openssl/commit/172c6e1e14defe7d49d62f5fc9ea6a79b225424f",
        "files": [
          "crypto/evp/encode.c"
        ],
        "message": "Avoid overflow in EVP_EncodeUpdate\n\nAn overflow can occur in the EVP_EncodeUpdate function which is used for\nBase64 encoding of binary data. If an attacker is able to supply very large\namounts of input data then a length check can overflow resulting in a heap\ncorruption. Due to the very large amounts of data involved this will most\nlikely result in a crash.\n\nInternally to OpenSSL the EVP_EncodeUpdate function is primarly used by the\nPEM_write_bio* family of functions. These are mainly used within the\nOpenSSL command line applications, so any application which processes\ndata from an untrusted source and outputs it as a PEM file should be\nconsidered vulnerable to this issue.\n\nUser applications that call these APIs directly with large amounts of\nuntrusted data may also be vulnerable.\n\nIssue reported by Guido Vranken.\n\nCVE-2016-2105\n\nReviewed-by: Richard Levitte <levitte@openssl.org>",
        "before_after_code_files": [
          "crypto/evp/encode.c||crypto/evp/encode.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "crypto/evp/encode.c||crypto/evp/encode.c"
          ],
          "candidate": [
            "crypto/evp/encode.c||crypto/evp/encode.c"
          ]
        }
      },
      "candidate_diff": {
        "crypto/evp/encode.c||crypto/evp/encode.c": [
          "File: crypto/evp/encode.c -> crypto/evp/encode.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "157:     if (inl <= 0)",
          "158:         return;",
          "159:     OPENSSL_assert(ctx->length <= (int)sizeof(ctx->enc_data));",
          "161:         memcpy(&(ctx->enc_data[ctx->num]), in, inl);",
          "162:         ctx->num += inl;",
          "163:         return;",
          "",
          "[Removed Lines]",
          "160:     if ((ctx->num + inl) < ctx->length) {",
          "",
          "[Added Lines]",
          "160:     if (ctx->length - ctx->num > inl) {",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "5b814481f3573fa9677f3a31ee51322e2a22ee6a",
      "candidate_info": {
        "commit_hash": "5b814481f3573fa9677f3a31ee51322e2a22ee6a",
        "repo": "openssl/openssl",
        "commit_url": "https://github.com/openssl/openssl/commit/5b814481f3573fa9677f3a31ee51322e2a22ee6a",
        "files": [
          "crypto/evp/encode.c"
        ],
        "message": "Avoid overflow in EVP_EncodeUpdate\n\nAn overflow can occur in the EVP_EncodeUpdate function which is used for\nBase64 encoding of binary data. If an attacker is able to supply very large\namounts of input data then a length check can overflow resulting in a heap\ncorruption. Due to the very large amounts of data involved this will most\nlikely result in a crash.\n\nInternally to OpenSSL the EVP_EncodeUpdate function is primarly used by the\nPEM_write_bio* family of functions. These are mainly used within the\nOpenSSL command line applications, so any application which processes\ndata from an untrusted source and outputs it as a PEM file should be\nconsidered vulnerable to this issue.\n\nUser applications that call these APIs directly with large amounts of\nuntrusted data may also be vulnerable.\n\nIssue reported by Guido Vranken.\n\nCVE-2016-2105\n\nReviewed-by: Richard Levitte <levitte@openssl.org>",
        "before_after_code_files": [
          "crypto/evp/encode.c||crypto/evp/encode.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "crypto/evp/encode.c||crypto/evp/encode.c"
          ],
          "candidate": [
            "crypto/evp/encode.c||crypto/evp/encode.c"
          ]
        }
      },
      "candidate_diff": {
        "crypto/evp/encode.c||crypto/evp/encode.c": [
          "File: crypto/evp/encode.c -> crypto/evp/encode.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "157:     if (inl <= 0)",
          "158:         return;",
          "159:     OPENSSL_assert(ctx->length <= (int)sizeof(ctx->enc_data));",
          "161:         memcpy(&(ctx->enc_data[ctx->num]), in, inl);",
          "162:         ctx->num += inl;",
          "163:         return;",
          "",
          "[Removed Lines]",
          "160:     if ((ctx->num + inl) < ctx->length) {",
          "",
          "[Added Lines]",
          "160:     if (ctx->length - ctx->num > inl) {",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2020-36407",
  "cve_desc": "libavif 0.8.0 and 0.8.1 has an out-of-bounds write in avifDecoderDataFillImageGrid.",
  "repo": "AOMediaCodec/libavif",
  "patch_hash": "0a8e7244d494ae98e9756355dfbfb6697ded2ff9",
  "patch_info": {
    "commit_hash": "0a8e7244d494ae98e9756355dfbfb6697ded2ff9",
    "repo": "AOMediaCodec/libavif",
    "commit_url": "https://github.com/AOMediaCodec/libavif/commit/0a8e7244d494ae98e9756355dfbfb6697ded2ff9",
    "files": [
      "include/avif/internal.h",
      "src/read.c"
    ],
    "message": "Set max image size to 16384 * 16384\n\nFix https://crbug.com/oss-fuzz/24728 and\nhttps://crbug.com/oss-fuzz/24734.",
    "before_after_code_files": [
      "include/avif/internal.h||include/avif/internal.h",
      "src/read.c||src/read.c"
    ]
  },
  "patch_diff": {
    "include/avif/internal.h||include/avif/internal.h": [
      "File: include/avif/internal.h -> include/avif/internal.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "241: } avifSequenceHeader;",
      "242: avifBool avifSequenceHeaderParse(avifSequenceHeader * header, const avifROData * sample);",
      "244: #ifdef __cplusplus",
      "245: } // extern \"C\"",
      "246: #endif",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "246: #define AVIF_MAX_IMAGE_SIZE (16384 * 16384)",
      "",
      "---------------"
    ],
    "src/read.c||src/read.c": [
      "File: src/read.c -> src/read.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "980:         CHECK(avifROStreamReadU32(&s, &grid->outputWidth));  // unsigned int(FieldLength) output_width;",
      "981:         CHECK(avifROStreamReadU32(&s, &grid->outputHeight)); // unsigned int(FieldLength) output_height;",
      "982:     }",
      "983:     return AVIF_TRUE;",
      "984: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "983:     if (grid->outputWidth > AVIF_MAX_IMAGE_SIZE / grid->outputHeight) {",
      "984:         return AVIF_FALSE;",
      "985:     }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "bc35a5f0123ab00f7515ad5b10f56a37dc3bf16b",
      "candidate_info": {
        "commit_hash": "bc35a5f0123ab00f7515ad5b10f56a37dc3bf16b",
        "repo": "AOMediaCodec/libavif",
        "commit_url": "https://github.com/AOMediaCodec/libavif/commit/bc35a5f0123ab00f7515ad5b10f56a37dc3bf16b",
        "files": [
          "src/read.c"
        ],
        "message": "Change conditional expressions to prevalent style (#273)\n\nAdd parentheses around binary operators in conditional expressions.\n\nTest memcmp(...) instead of memcmp(...) != 0 and\n!memcmp(...) instead of memcmp(...) == 0.",
        "before_after_code_files": [
          "src/read.c||src/read.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/read.c||src/read.c"
          ],
          "candidate": [
            "src/read.c||src/read.c"
          ]
        }
      },
      "candidate_diff": {
        "src/read.c||src/read.c": [
          "File: src/read.c -> src/read.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "692:         if ((tile->image->width != firstTile->image->width) || (tile->image->height != firstTile->image->height) ||",
          "693:             (tile->image->depth != firstTile->image->depth) || (tile->image->yuvFormat != firstTile->image->yuvFormat) ||",
          "694:             (tile->image->yuvRange != firstTile->image->yuvRange) || (uvPresent != firstTileUVPresent) ||",
          "698:             return AVIF_FALSE;",
          "699:         }",
          "700:     }",
          "",
          "[Removed Lines]",
          "695:             ((tile->image->colorPrimaries != firstTile->image->colorPrimaries) ||",
          "696:              (tile->image->transferCharacteristics != firstTile->image->transferCharacteristics) ||",
          "697:              (tile->image->matrixCoefficients != firstTile->image->matrixCoefficients))) {",
          "",
          "[Added Lines]",
          "695:             (tile->image->colorPrimaries != firstTile->image->colorPrimaries) ||",
          "696:             (tile->image->transferCharacteristics != firstTile->image->transferCharacteristics) ||",
          "697:             (tile->image->matrixCoefficients != firstTile->image->matrixCoefficients)) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "707:         return AVIF_FALSE;",
          "708:     }",
          "712:         return AVIF_FALSE;",
          "713:     }",
          "718:         return AVIF_FALSE;",
          "719:     }",
          "720:     if (!alpha) {",
          "724:                 return AVIF_FALSE;",
          "725:             }",
          "726:         }",
          "727:         if (firstTile->image->yuvFormat == AVIF_PIXEL_FORMAT_YUV420) {",
          "730:                 return AVIF_FALSE;",
          "731:             }",
          "732:         }",
          "",
          "[Removed Lines]",
          "706:     if (firstTile->image->width * grid->columns < grid->outputWidth || firstTile->image->height * grid->rows < grid->outputHeight) {",
          "710:     if (firstTile->image->width * (grid->columns - 1) >= grid->outputWidth ||",
          "711:         firstTile->image->height * (grid->rows - 1) >= grid->outputHeight) {",
          "717:     if (firstTile->image->width < 64 || firstTile->image->height < 64) {",
          "721:         if (firstTile->image->yuvFormat == AVIF_PIXEL_FORMAT_YUV422 || firstTile->image->yuvFormat == AVIF_PIXEL_FORMAT_YUV420) {",
          "723:             if ((firstTile->image->width & 1) != 0 || (grid->outputWidth & 1) != 0) {",
          "729:             if ((firstTile->image->height & 1) != 0 || (grid->outputHeight & 1) != 0) {",
          "",
          "[Added Lines]",
          "706:     if (((firstTile->image->width * grid->columns) < grid->outputWidth) ||",
          "707:         ((firstTile->image->height * grid->rows) < grid->outputHeight)) {",
          "711:     if (((firstTile->image->width * (grid->columns - 1)) >= grid->outputWidth) ||",
          "712:         ((firstTile->image->height * (grid->rows - 1)) >= grid->outputHeight)) {",
          "718:     if ((firstTile->image->width < 64) || (firstTile->image->height < 64)) {",
          "722:         if ((firstTile->image->yuvFormat == AVIF_PIXEL_FORMAT_YUV422) || (firstTile->image->yuvFormat == AVIF_PIXEL_FORMAT_YUV420)) {",
          "724:             if (((firstTile->image->width & 1) != 0) || ((grid->outputWidth & 1) != 0)) {",
          "730:             if (((firstTile->image->height & 1) != 0) || ((grid->outputHeight & 1) != 0)) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1010:         CHECK(avifROStreamReadU32(&s, &grid->outputWidth));  // unsigned int(FieldLength) output_width;",
          "1011:         CHECK(avifROStreamReadU32(&s, &grid->outputHeight)); // unsigned int(FieldLength) output_height;",
          "1012:     }",
          "1014:         return AVIF_FALSE;",
          "1015:     }",
          "1016:     return avifROStreamRemainingBytes(&s) == 0;",
          "",
          "[Removed Lines]",
          "1013:     if (grid->outputWidth == 0 || grid->outputHeight == 0 || grid->outputWidth > AVIF_MAX_IMAGE_SIZE / grid->outputHeight) {",
          "",
          "[Added Lines]",
          "1014:     if ((grid->outputWidth == 0) || (grid->outputHeight == 0) || (grid->outputWidth > (AVIF_MAX_IMAGE_SIZE / grid->outputHeight))) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1333:     avifBoxHeader ipcoHeader;",
          "1334:     CHECK(avifROStreamReadBoxHeader(&s, &ipcoHeader));",
          "1336:         return AVIF_FALSE;",
          "1337:     }",
          "",
          "[Removed Lines]",
          "1335:     if (memcmp(ipcoHeader.type, \"ipco\", 4) != 0) {",
          "",
          "[Added Lines]",
          "1336:     if (memcmp(ipcoHeader.type, \"ipco\", 4)) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1903: static avifBool avifFileTypeIsCompatible(avifFileType * ftyp)",
          "1904: {",
          "1906:     if (!avifCompatible) {",
          "1907:         for (int compatibleBrandIndex = 0; compatibleBrandIndex < ftyp->compatibleBrandsCount; ++compatibleBrandIndex) {",
          "1908:             const uint8_t * compatibleBrand = &ftyp->compatibleBrands[4 * compatibleBrandIndex];",
          "",
          "[Removed Lines]",
          "1905:     avifBool avifCompatible = (memcmp(ftyp->majorBrand, \"avif\", 4) == 0 || memcmp(ftyp->majorBrand, \"avis\", 4) == 0);",
          "",
          "[Added Lines]",
          "1906:     avifBool avifCompatible = (!memcmp(ftyp->majorBrand, \"avif\", 4) || !memcmp(ftyp->majorBrand, \"avis\", 4));",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1922:     avifBoxHeader header;",
          "1923:     CHECK(avifROStreamReadBoxHeader(&s, &header));",
          "1925:         return AVIF_FALSE;",
          "1926:     }",
          "",
          "[Removed Lines]",
          "1924:     if (memcmp(header.type, \"ftyp\", 4) != 0) {",
          "",
          "[Added Lines]",
          "1925:     if (memcmp(header.type, \"ftyp\", 4)) {",
          "",
          "---------------"
        ]
      }
    }
  ]
}
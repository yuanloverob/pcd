{
  "cve_id": "CVE-2015-7551",
  "cve_desc": "The Fiddle::Handle implementation in ext/fiddle/handle.c in Ruby before 2.0.0-p648, 2.1 before 2.1.8, and 2.2 before 2.2.4, as distributed in Apple OS X before 10.11.4 and other products, mishandles tainting, which allows context-dependent attackers to execute arbitrary code or cause a denial of service (application crash) via a crafted string, related to the DL module and the libffi library.  NOTE: this vulnerability exists because of a CVE-2009-5147 regression.",
  "repo": "ruby/ruby",
  "patch_hash": "339e11a7f178312d937b7c95dd3115ce7236597a",
  "patch_info": {
    "commit_hash": "339e11a7f178312d937b7c95dd3115ce7236597a",
    "repo": "ruby/ruby",
    "commit_url": "https://github.com/ruby/ruby/commit/339e11a7f178312d937b7c95dd3115ce7236597a",
    "files": [
      "ChangeLog",
      "ext/fiddle/handle.c",
      "test/fiddle/test_handle.rb",
      "version.h"
    ],
    "message": "merge revision(s): 53153 and 23405@ruby_1_9_1\n\n\t* ext/fiddle/handle.c: check tainted string arguments.\n\t  Patch provided by tenderlove and nobu.\n\n\t* test/fiddle/test_handle.rb (class TestHandle): add test for above.\n\n\t* ext/dl/handle.c (rb_dlhandle_initialize): prohibits DL::dlopen\n\t  with a tainted name of library.\n\t  Patch by sheepman <sheepman AT sheepman.sakura.ne.jp>.\n\n\t* ext/dl/handle.c (rb_dlhandle_sym): ditto\n\n\n\ngit-svn-id: svn+ssh://ci.ruby-lang.org/ruby/branches/ruby_2_1@53156 b2dd03c8-39d4-4d8f-98ff-823fe69b080e",
    "before_after_code_files": [
      "ext/fiddle/handle.c||ext/fiddle/handle.c",
      "test/fiddle/test_handle.rb||test/fiddle/test_handle.rb",
      "version.h||version.h"
    ]
  },
  "patch_diff": {
    "ext/fiddle/handle.c||ext/fiddle/handle.c": [
      "File: ext/fiddle/handle.c -> ext/fiddle/handle.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1: #include <ruby.h>",
      "2: #include <fiddle.h>",
      "4: VALUE rb_cHandle;",
      "6: struct dl_handle {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "4: #define SafeStringValueCStr(v) (rb_check_safe_obj(rb_string_value(&v)), StringValueCStr(v))",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "143:  cflag = RTLD_LAZY | RTLD_GLOBAL;",
      "144:  break;",
      "145:       case 1:",
      "147:  cflag = RTLD_LAZY | RTLD_GLOBAL;",
      "148:  break;",
      "149:       case 2:",
      "151:  cflag = NUM2INT(flag);",
      "152:  break;",
      "153:       default:",
      "",
      "[Removed Lines]",
      "146:  clib = NIL_P(lib) ? NULL : StringValuePtr(lib);",
      "150:  clib = NIL_P(lib) ? NULL : StringValuePtr(lib);",
      "",
      "[Added Lines]",
      "148:  clib = NIL_P(lib) ? NULL : SafeStringValueCStr(lib);",
      "152:  clib = NIL_P(lib) ? NULL : SafeStringValueCStr(lib);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "263:     return PTR2NUM(fiddle_handle);",
      "264: }",
      "",
      "[Removed Lines]",
      "266: static VALUE fiddle_handle_sym(void *handle, const char *symbol);",
      "",
      "[Added Lines]",
      "268: static VALUE fiddle_handle_sym(void *handle, VALUE symbol);",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "282:  rb_raise(rb_eFiddleError, \"closed handle\");",
      "283:     }",
      "286: }",
      "288: #ifndef RTLD_NEXT",
      "",
      "[Removed Lines]",
      "285:     return fiddle_handle_sym(fiddle_handle->ptr, StringValueCStr(sym));",
      "",
      "[Added Lines]",
      "287:     return fiddle_handle_sym(fiddle_handle->ptr, sym);",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "305: static VALUE",
      "306: rb_fiddle_handle_s_sym(VALUE self, VALUE sym)",
      "307: {",
      "309: }",
      "311: static VALUE",
      "313: {",
      "314: #if defined(HAVE_DLERROR)",
      "315:     const char *err;",
      "",
      "[Removed Lines]",
      "308:     return fiddle_handle_sym(RTLD_NEXT, StringValueCStr(sym));",
      "312: fiddle_handle_sym(void *handle, const char *name)",
      "",
      "[Added Lines]",
      "310:     return fiddle_handle_sym(RTLD_NEXT, sym);",
      "314: fiddle_handle_sym(void *handle, VALUE symbol)",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "318: # define CHECK_DLERROR",
      "319: #endif",
      "320:     void (*func)();",
      "322:     rb_secure(2);",
      "323: #ifdef HAVE_DLERROR",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "323:     const char *name = SafeStringValueCStr(symbol);",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "367:     }",
      "368: #endif",
      "369:     if( !func ){",
      "371:     }",
      "373:     return PTR2NUM(func);",
      "",
      "[Removed Lines]",
      "370:  rb_raise(rb_eFiddleError, \"unknown symbol \\\"%s\\\"\", name);",
      "",
      "[Added Lines]",
      "373:  rb_raise(rb_eFiddleError, \"unknown symbol \\\"%\"PRIsVALUE\"\\\"\", symbol);",
      "",
      "---------------"
    ],
    "test/fiddle/test_handle.rb||test/fiddle/test_handle.rb": [
      "File: test/fiddle/test_handle.rb -> test/fiddle/test_handle.rb",
      "--- Hunk 1 ---",
      "[Context before]",
      "11:     include Test::Unit::Assertions",
      "13:     def test_to_i",
      "14:       handle = Fiddle::Handle.new(LIBC_SO)",
      "15:       assert_kind_of Integer, handle.to_i",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "13:     def test_safe_handle_open",
      "14:       t = Thread.new do",
      "15:         $SAFE = 1",
      "16:         Fiddle::Handle.new(LIBC_SO.taint)",
      "17:       end",
      "18:       assert_raise(SecurityError) { t.value }",
      "19:     end",
      "21:     def test_safe_function_lookup",
      "22:       t = Thread.new do",
      "23:         h = Fiddle::Handle.new(LIBC_SO)",
      "24:         $SAFE = 1",
      "25:         h[\"qsort\".taint]",
      "26:       end",
      "27:       assert_raise(SecurityError) { t.value }",
      "28:     end",
      "",
      "---------------"
    ],
    "version.h||version.h": [
      "File: version.h -> version.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "1: #define RUBY_VERSION \"2.1.8\"",
      "2: #define RUBY_RELEASE_DATE \"2015-12-16\"",
      "5: #define RUBY_RELEASE_YEAR 2015",
      "6: #define RUBY_RELEASE_MONTH 12",
      "",
      "[Removed Lines]",
      "3: #define RUBY_PATCHLEVEL 438",
      "",
      "[Added Lines]",
      "3: #define RUBY_PATCHLEVEL 439",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "8e210f995f37222facee57555996c205fb4fe390",
      "candidate_info": {
        "commit_hash": "8e210f995f37222facee57555996c205fb4fe390",
        "repo": "ruby/ruby",
        "commit_url": "https://github.com/ruby/ruby/commit/8e210f995f37222facee57555996c205fb4fe390",
        "files": [
          "ChangeLog",
          "ext/socket/getaddrinfo.c",
          "ext/socket/raddrinfo.c",
          "version.h"
        ],
        "message": "merge revision(s) r49543,r49557: [Backport #10854]\n\n\t* ext/socket/getaddrinfo.c (get_addr): reject too long hostname to\n\t  get rid of GHOST vulnerability on very old platforms.\n\n\t* ext/socket/raddrinfo.c (make_hostent_internal): ditto, paranoic\n\t  check for the canonnical name.\n\t  check for the canonical name.\n\n\ngit-svn-id: svn+ssh://ci.ruby-lang.org/ruby/branches/ruby_2_1@49600 b2dd03c8-39d4-4d8f-98ff-823fe69b080e",
        "before_after_code_files": [
          "ext/socket/getaddrinfo.c||ext/socket/getaddrinfo.c",
          "ext/socket/raddrinfo.c||ext/socket/raddrinfo.c",
          "version.h||version.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "version.h||version.h"
          ],
          "candidate": [
            "version.h||version.h"
          ]
        }
      },
      "candidate_diff": {
        "ext/socket/getaddrinfo.c||ext/socket/getaddrinfo.c": [
          "File: ext/socket/getaddrinfo.c -> ext/socket/getaddrinfo.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "593:  } else",
          "594:   hp = getipnodebyname(hostname, af, AI_ADDRCONFIG, &h_error);",
          "595: #else",
          "596:  hp = gethostbyname((char*)hostname);",
          "597:  h_error = h_errno;",
          "598: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "596:  if (strlen(hostname) >= NI_MAXHOST) ERR(EAI_NODATA);",
          "",
          "---------------"
        ],
        "ext/socket/raddrinfo.c||ext/socket/raddrinfo.c": [
          "File: ext/socket/raddrinfo.c -> ext/socket/raddrinfo.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "617:     }",
          "618:     rb_ary_push(ary, rb_str_new2(hostp));",
          "621:         names = rb_ary_new();",
          "622:         if (h->h_aliases != NULL) {",
          "623:             for (pch = h->h_aliases; *pch; pch++) {",
          "",
          "[Removed Lines]",
          "620:     if (addr->ai_canonname && (h = gethostbyname(addr->ai_canonname))) {",
          "",
          "[Added Lines]",
          "620:     if (addr->ai_canonname && strlen(addr->ai_canonname) < NI_MAXHOST &&",
          "621:  (h = gethostbyname(addr->ai_canonname))) {",
          "",
          "---------------"
        ],
        "version.h||version.h": [
          "File: version.h -> version.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: #define RUBY_VERSION \"2.1.5\"",
          "5: #define RUBY_RELEASE_YEAR 2015",
          "6: #define RUBY_RELEASE_MONTH 2",
          "9: #include \"ruby/version.h\"",
          "",
          "[Removed Lines]",
          "2: #define RUBY_RELEASE_DATE \"2015-02-13\"",
          "3: #define RUBY_PATCHLEVEL 292",
          "7: #define RUBY_RELEASE_DAY 13",
          "",
          "[Added Lines]",
          "2: #define RUBY_RELEASE_DATE \"2015-02-15\"",
          "3: #define RUBY_PATCHLEVEL 293",
          "7: #define RUBY_RELEASE_DAY 15",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "190241f371d68506dc267a598caf344583fb41dd",
      "candidate_info": {
        "commit_hash": "190241f371d68506dc267a598caf344583fb41dd",
        "repo": "ruby/ruby",
        "commit_url": "https://github.com/ruby/ruby/commit/190241f371d68506dc267a598caf344583fb41dd",
        "files": [
          "ChangeLog",
          "lib/net/ftp.rb",
          "test/net/ftp/test_ftp.rb",
          "version.h"
        ],
        "message": "merge revision(s) 51046: [Backport #11260]\n\n\t* lib/net/ftp.rb (makeport): close the TCPServer\n\t  when sending the port fails.\n\n\t* test/net/ftp/test_ftp.rb: test for above.\n\n\ngit-svn-id: svn+ssh://ci.ruby-lang.org/ruby/branches/ruby_2_1@51610 b2dd03c8-39d4-4d8f-98ff-823fe69b080e",
        "before_after_code_files": [
          "lib/net/ftp.rb||lib/net/ftp.rb",
          "test/net/ftp/test_ftp.rb||test/net/ftp/test_ftp.rb",
          "version.h||version.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "version.h||version.h"
          ],
          "candidate": [
            "version.h||version.h"
          ]
        }
      },
      "candidate_diff": {
        "lib/net/ftp.rb||lib/net/ftp.rb": [
          "File: lib/net/ftp.rb -> lib/net/ftp.rb",
          "--- Hunk 1 ---",
          "[Context before]",
          "377:     end",
          "378:     private :sendport",
          "383:     def makeport # :nodoc:",
          "389:     end",
          "390:     private :makeport",
          "",
          "[Removed Lines]",
          "380:     # Constructs a TCPServer socket, and sends it the PORT command",
          "381:     #",
          "382:     # Returns the constructed TCPServer socket",
          "384:       sock = TCPServer.open(@sock.addr[3], 0)",
          "385:       port = sock.addr[1]",
          "386:       host = sock.addr[3]",
          "387:       sendport(host, port)",
          "388:       return sock",
          "",
          "[Added Lines]",
          "380:     # Constructs a TCPServer socket",
          "382:       TCPServer.open(@sock.addr[3], 0)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "421:       else",
          "422:         sock = makeport",
          "423:         begin",
          "424:           if @resume and rest_offset",
          "425:             resp = sendcmd(\"REST \" + rest_offset.to_s)",
          "426:             if resp[0] != ?3",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "418:           sendport(sock.addr[3], sock.addr[1])",
          "",
          "---------------"
        ],
        "test/net/ftp/test_ftp.rb||test/net/ftp/test_ftp.rb": [
          "File: test/net/ftp/test_ftp.rb -> test/net/ftp/test_ftp.rb",
          "--- Hunk 1 ---",
          "[Context before]",
          "477:     end",
          "478:   end",
          "480:   def test_retrbinary_read_timeout_exceeded",
          "481:     commands = []",
          "482:     binary_data = (0..0xff).map {|i| i.chr}.join * 4 * 3",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "480:   def test_open_data_port_fail_no_leak",
          "481:     commands = []",
          "482:     server = create_ftp_server { |sock|",
          "483:       sock.print(\"220 (test_ftp).\\r\\n\")",
          "484:       commands.push(sock.gets)",
          "485:       sock.print(\"331 Please specify the password.\\r\\n\")",
          "486:       commands.push(sock.gets)",
          "487:       sock.print(\"230 Login successful.\\r\\n\")",
          "488:       commands.push(sock.gets)",
          "489:       sock.print(\"200 Switching to Binary mode.\\r\\n\")",
          "490:       commands.push(sock.gets)",
          "491:       sock.print(\"200 Switching to ASCII mode.\\r\\n\")",
          "492:       line = sock.gets",
          "493:       commands.push(line)",
          "494:       sock.print(\"421 Service not available, closing control connection.\\r\\n\")",
          "495:       commands.push(sock.gets)",
          "496:       sock.print(\"200 Switching to Binary mode.\\r\\n\")",
          "497:     }",
          "498:     begin",
          "499:       begin",
          "500:         ftp = Net::FTP.new",
          "501:         ftp.read_timeout = 0.2",
          "502:         ftp.connect(SERVER_ADDR, server.port)",
          "503:         ftp.login",
          "504:         assert_match(/\\AUSER /, commands.shift)",
          "505:         assert_match(/\\APASS /, commands.shift)",
          "506:         assert_equal(\"TYPE I\\r\\n\", commands.shift)",
          "507:         assert_raise(Net::FTPTempError){ ftp.list }",
          "508:         assert_equal(\"TYPE A\\r\\n\", commands.shift)",
          "509:         assert_match(/\\APORT /, commands.shift)",
          "510:         assert_equal(\"TYPE I\\r\\n\", commands.shift)",
          "511:         assert_equal(nil, commands.shift)",
          "512:       ensure",
          "513:         ftp.close if ftp",
          "514:       end",
          "515:     ensure",
          "516:       server.close",
          "517:     end",
          "518:   end",
          "",
          "---------------"
        ],
        "version.h||version.h": [
          "File: version.h -> version.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: #define RUBY_VERSION \"2.1.7\"",
          "2: #define RUBY_RELEASE_DATE \"2015-08-17\"",
          "5: #define RUBY_RELEASE_YEAR 2015",
          "6: #define RUBY_RELEASE_MONTH 8",
          "",
          "[Removed Lines]",
          "3: #define RUBY_PATCHLEVEL 392",
          "",
          "[Added Lines]",
          "3: #define RUBY_PATCHLEVEL 393",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "3233891d3670562bfa5aac2483e46f6c45851cad",
      "candidate_info": {
        "commit_hash": "3233891d3670562bfa5aac2483e46f6c45851cad",
        "repo": "ruby/ruby",
        "commit_url": "https://github.com/ruby/ruby/commit/3233891d3670562bfa5aac2483e46f6c45851cad",
        "files": [
          "ChangeLog",
          "version.h",
          "vm_trace.c"
        ],
        "message": "merge revision(s) 52476,52477: [Backport #11603]\n\n\t* vm_trace.c (rb_threadptr_exec_event_hooks_orig): \n\t  maintain trace_running counter on internal events.\n\t  This patch is made by Takashi Kokubun <takashikkbn@gmail.com>.\n\t  [Bug #11603] https://github.com/ruby/ruby/pull/1059\n\n\t* vm_trace.c (rb_threadptr_exec_event_hooks_orig):\n\n\ngit-svn-id: svn+ssh://ci.ruby-lang.org/ruby/branches/ruby_2_1@52641 b2dd03c8-39d4-4d8f-98ff-823fe69b080e",
        "before_after_code_files": [
          "version.h||version.h",
          "vm_trace.c||vm_trace.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "version.h||version.h"
          ],
          "candidate": [
            "version.h||version.h"
          ]
        }
      },
      "candidate_diff": {
        "version.h||version.h": [
          "File: version.h -> version.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: #define RUBY_VERSION \"2.1.8\"",
          "2: #define RUBY_RELEASE_DATE \"2015-11-18\"",
          "5: #define RUBY_RELEASE_YEAR 2015",
          "6: #define RUBY_RELEASE_MONTH 11",
          "",
          "[Removed Lines]",
          "3: #define RUBY_PATCHLEVEL 416",
          "",
          "[Added Lines]",
          "3: #define RUBY_PATCHLEVEL 417",
          "",
          "---------------"
        ],
        "vm_trace.c||vm_trace.c": [
          "File: vm_trace.c -> vm_trace.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "324:  }",
          "325:  else {",
          "326:      rb_trace_arg_t *prev_trace_arg = th->trace_arg;",
          "327:      th->trace_arg = trace_arg;",
          "328:      exec_hooks_unprotected(th, &th->event_hooks, trace_arg);",
          "329:      exec_hooks_unprotected(th, &th->vm->event_hooks, trace_arg);",
          "330:      th->trace_arg = prev_trace_arg;",
          "331:  }",
          "332:     }",
          "333:     else {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "327:      th->vm->trace_running++;",
          "332:      th->vm->trace_running--;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "a4e761b7650340314180cc2559b7d2a631a3db16",
      "candidate_info": {
        "commit_hash": "a4e761b7650340314180cc2559b7d2a631a3db16",
        "repo": "ruby/ruby",
        "commit_url": "https://github.com/ruby/ruby/commit/a4e761b7650340314180cc2559b7d2a631a3db16",
        "files": [
          "ChangeLog",
          "lib/ipaddr.rb",
          "test/test_ipaddr.rb",
          "version.h"
        ],
        "message": "merge revision(s) 52244: [Backport #11513]\n\n\t* lib/ipaddr.rb, test/test_ipaddr.rb: Reject invalid address contained\n\t  EOL string. Patch by @kachick [fix GH-942][Bug #11513]\n\n\ngit-svn-id: svn+ssh://ci.ruby-lang.org/ruby/branches/ruby_2_1@52360 b2dd03c8-39d4-4d8f-98ff-823fe69b080e",
        "before_after_code_files": [
          "lib/ipaddr.rb||liipaddr.rb",
          "test/test_ipaddr.rb||test/test_ipaddr.rb",
          "version.h||version.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "version.h||version.h"
          ],
          "candidate": [
            "version.h||version.h"
          ]
        }
      },
      "candidate_diff": {
        "lib/ipaddr.rb||liipaddr.rb": [
          "File: lib/ipaddr.rb -> liipaddr.rb",
          "--- Hunk 1 ---",
          "[Context before]",
          "410:   # Set current netmask to given mask.",
          "411:   def mask!(mask)",
          "412:     if mask.kind_of?(String)",
          "414:         prefixlen = mask.to_i",
          "415:       else",
          "416:         m = IPAddr.new(mask)",
          "",
          "[Removed Lines]",
          "413:       if mask =~ /^\\d+$/",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "478:       end",
          "479:     end",
          "480:     prefix, prefixlen = addr.split('/')",
          "482:       prefix = $1",
          "483:       family = Socket::AF_INET6",
          "484:     end",
          "",
          "[Removed Lines]",
          "481:     if prefix =~ /^\\[(.*)\\]$/i",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "656:     end",
          "657:   end",
          "658: end",
          "",
          "[Removed Lines]",
          "660: if $0 == __FILE__",
          "661:   eval DATA.read, nil, $0, __LINE__+4",
          "662: end",
          "664: __END__",
          "666: require 'test/unit'",
          "668: class TC_IPAddr < Test::Unit::TestCase",
          "669:   def test_s_new",
          "670:     [",
          "671:       [\"3FFE:505:ffff::/48\"],",
          "672:       [\"0:0:0:1::\"],",
          "673:       [\"2001:200:300::/48\"],",
          "674:       [\"2001:200:300::192.168.1.2/48\"],",
          "675:       [\"1:2:3:4:5:6:7::\"],",
          "676:       [\"::2:3:4:5:6:7:8\"],",
          "677:     ].each { |args|",
          "678:       assert_nothing_raised {",
          "679:         IPAddr.new(*args)",
          "680:       }",
          "681:     }",
          "683:     a = IPAddr.new",
          "684:     assert_equal(\"::\", a.to_s)",
          "685:     assert_equal(\"0000:0000:0000:0000:0000:0000:0000:0000\", a.to_string)",
          "686:     assert_equal(Socket::AF_INET6, a.family)",
          "688:     a = IPAddr.new(\"0123:4567:89ab:cdef:0ABC:DEF0:1234:5678\")",
          "689:     assert_equal(\"123:4567:89ab:cdef:abc:def0:1234:5678\", a.to_s)",
          "690:     assert_equal(\"0123:4567:89ab:cdef:0abc:def0:1234:5678\", a.to_string)",
          "691:     assert_equal(Socket::AF_INET6, a.family)",
          "693:     a = IPAddr.new(\"3ffe:505:2::/48\")",
          "694:     assert_equal(\"3ffe:505:2::\", a.to_s)",
          "695:     assert_equal(\"3ffe:0505:0002:0000:0000:0000:0000:0000\", a.to_string)",
          "696:     assert_equal(Socket::AF_INET6, a.family)",
          "697:     assert_equal(false, a.ipv4?)",
          "698:     assert_equal(true, a.ipv6?)",
          "699:     assert_equal(\"#<IPAddr: IPv6:3ffe:0505:0002:0000:0000:0000:0000:0000/ffff:ffff:ffff:0000:0000:0000:0000:0000>\", a.inspect)",
          "701:     a = IPAddr.new(\"3ffe:505:2::/ffff:ffff:ffff::\")",
          "702:     assert_equal(\"3ffe:505:2::\", a.to_s)",
          "703:     assert_equal(\"3ffe:0505:0002:0000:0000:0000:0000:0000\", a.to_string)",
          "704:     assert_equal(Socket::AF_INET6, a.family)",
          "706:     a = IPAddr.new(\"0.0.0.0\")",
          "707:     assert_equal(\"0.0.0.0\", a.to_s)",
          "708:     assert_equal(\"0.0.0.0\", a.to_string)",
          "709:     assert_equal(Socket::AF_INET, a.family)",
          "711:     a = IPAddr.new(\"192.168.1.2\")",
          "712:     assert_equal(\"192.168.1.2\", a.to_s)",
          "713:     assert_equal(\"192.168.1.2\", a.to_string)",
          "714:     assert_equal(Socket::AF_INET, a.family)",
          "715:     assert_equal(true, a.ipv4?)",
          "716:     assert_equal(false, a.ipv6?)",
          "718:     a = IPAddr.new(\"192.168.1.2/24\")",
          "719:     assert_equal(\"192.168.1.0\", a.to_s)",
          "720:     assert_equal(\"192.168.1.0\", a.to_string)",
          "721:     assert_equal(Socket::AF_INET, a.family)",
          "722:     assert_equal(\"#<IPAddr: IPv4:192.168.1.0/255.255.255.0>\", a.inspect)",
          "724:     a = IPAddr.new(\"192.168.1.2/255.255.255.0\")",
          "725:     assert_equal(\"192.168.1.0\", a.to_s)",
          "726:     assert_equal(\"192.168.1.0\", a.to_string)",
          "727:     assert_equal(Socket::AF_INET, a.family)",
          "729:     assert_equal(\"0:0:0:1::\", IPAddr.new(\"0:0:0:1::\").to_s)",
          "730:     assert_equal(\"2001:200:300::\", IPAddr.new(\"2001:200:300::/48\").to_s)",
          "732:     assert_equal(\"2001:200:300::\", IPAddr.new(\"[2001:200:300::]/48\").to_s)",
          "733:     assert_equal(\"1:2:3:4:5:6:7:0\", IPAddr.new(\"1:2:3:4:5:6:7::\").to_s)",
          "734:     assert_equal(\"0:2:3:4:5:6:7:8\", IPAddr.new(\"::2:3:4:5:6:7:8\").to_s)",
          "736:     assert_raises(IPAddr::InvalidAddressError) { IPAddr.new(\"192.168.0.256\") }",
          "737:     assert_raises(IPAddr::InvalidAddressError) { IPAddr.new(\"192.168.0.011\") }",
          "738:     assert_raises(IPAddr::InvalidAddressError) { IPAddr.new(\"fe80::1%fxp0\") }",
          "739:     assert_raises(IPAddr::InvalidAddressError) { IPAddr.new(\"[192.168.1.2]/120\") }",
          "740:     assert_raises(IPAddr::InvalidPrefixError) { IPAddr.new(\"::1/255.255.255.0\") }",
          "741:     assert_raises(IPAddr::InvalidPrefixError) { IPAddr.new(\"::1/129\") }",
          "742:     assert_raises(IPAddr::InvalidPrefixError) { IPAddr.new(\"192.168.0.1/33\") }",
          "743:     assert_raises(IPAddr::AddressFamilyError) { IPAddr.new(1) }",
          "744:     assert_raises(IPAddr::AddressFamilyError) { IPAddr.new(\"::ffff:192.168.1.2/120\", Socket::AF_INET) }",
          "745:   end",
          "747:   def test_s_new_ntoh",
          "748:     addr = ''",
          "749:     IPAddr.new(\"1234:5678:9abc:def0:1234:5678:9abc:def0\").hton.each_byte { |c|",
          "750:       addr += sprintf(\"%02x\", c)",
          "751:     }",
          "752:     assert_equal(\"123456789abcdef0123456789abcdef0\", addr)",
          "753:     addr = ''",
          "754:     IPAddr.new(\"123.45.67.89\").hton.each_byte { |c|",
          "755:       addr += sprintf(\"%02x\", c)",
          "756:     }",
          "757:     assert_equal(sprintf(\"%02x%02x%02x%02x\", 123, 45, 67, 89), addr)",
          "758:     a = IPAddr.new(\"3ffe:505:2::\")",
          "759:     assert_equal(\"3ffe:505:2::\", IPAddr.new_ntoh(a.hton).to_s)",
          "760:     a = IPAddr.new(\"192.168.2.1\")",
          "761:     assert_equal(\"192.168.2.1\", IPAddr.new_ntoh(a.hton).to_s)",
          "762:   end",
          "764:   def test_ipv4_compat",
          "765:     a = IPAddr.new(\"::192.168.1.2\")",
          "766:     assert_equal(\"::192.168.1.2\", a.to_s)",
          "767:     assert_equal(\"0000:0000:0000:0000:0000:0000:c0a8:0102\", a.to_string)",
          "768:     assert_equal(Socket::AF_INET6, a.family)",
          "769:     assert_equal(true, a.ipv4_compat?)",
          "770:     b = a.native",
          "771:     assert_equal(\"192.168.1.2\", b.to_s)",
          "772:     assert_equal(Socket::AF_INET, b.family)",
          "773:     assert_equal(false, b.ipv4_compat?)",
          "775:     a = IPAddr.new(\"192.168.1.2\")",
          "776:     b = a.ipv4_compat",
          "777:     assert_equal(\"::192.168.1.2\", b.to_s)",
          "778:     assert_equal(Socket::AF_INET6, b.family)",
          "779:   end",
          "781:   def test_ipv4_mapped",
          "782:     a = IPAddr.new(\"::ffff:192.168.1.2\")",
          "783:     assert_equal(\"::ffff:192.168.1.2\", a.to_s)",
          "784:     assert_equal(\"0000:0000:0000:0000:0000:ffff:c0a8:0102\", a.to_string)",
          "785:     assert_equal(Socket::AF_INET6, a.family)",
          "786:     assert_equal(true, a.ipv4_mapped?)",
          "787:     b = a.native",
          "788:     assert_equal(\"192.168.1.2\", b.to_s)",
          "789:     assert_equal(Socket::AF_INET, b.family)",
          "790:     assert_equal(false, b.ipv4_mapped?)",
          "792:     a = IPAddr.new(\"192.168.1.2\")",
          "793:     b = a.ipv4_mapped",
          "794:     assert_equal(\"::ffff:192.168.1.2\", b.to_s)",
          "795:     assert_equal(Socket::AF_INET6, b.family)",
          "796:   end",
          "798:   def test_reverse",
          "799:     assert_equal(\"f.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.2.0.0.0.5.0.5.0.e.f.f.3.ip6.arpa\", IPAddr.new(\"3ffe:505:2::f\").reverse)",
          "800:     assert_equal(\"1.2.168.192.in-addr.arpa\", IPAddr.new(\"192.168.2.1\").reverse)",
          "801:   end",
          "803:   def test_ip6_arpa",
          "804:     assert_equal(\"f.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.2.0.0.0.5.0.5.0.e.f.f.3.ip6.arpa\", IPAddr.new(\"3ffe:505:2::f\").ip6_arpa)",
          "805:     assert_raises(IPAddr::InvalidAddressError) {",
          "806:       IPAddr.new(\"192.168.2.1\").ip6_arpa",
          "807:     }",
          "808:   end",
          "810:   def test_ip6_int",
          "811:     assert_equal(\"f.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.2.0.0.0.5.0.5.0.e.f.f.3.ip6.int\", IPAddr.new(\"3ffe:505:2::f\").ip6_int)",
          "812:     assert_raises(IPAddr::InvalidAddressError) {",
          "813:       IPAddr.new(\"192.168.2.1\").ip6_int",
          "814:     }",
          "815:   end",
          "817:   def test_to_s",
          "818:     assert_equal(\"3ffe:0505:0002:0000:0000:0000:0000:0001\", IPAddr.new(\"3ffe:505:2::1\").to_string)",
          "819:     assert_equal(\"3ffe:505:2::1\", IPAddr.new(\"3ffe:505:2::1\").to_s)",
          "820:   end",
          "821: end",
          "823: class TC_Operator < Test::Unit::TestCase",
          "825:   IN6MASK32  = \"ffff:ffff::\"",
          "826:   IN6MASK128 = \"ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff\"",
          "828:   def setup",
          "829:     @in6_addr_any = IPAddr.new()",
          "830:     @a = IPAddr.new(\"3ffe:505:2::/48\")",
          "831:     @b = IPAddr.new(\"0:0:0:1::\")",
          "832:     @c = IPAddr.new(IN6MASK32)",
          "833:   end",
          "834:   alias set_up setup",
          "836:   def test_or",
          "837:     assert_equal(\"3ffe:505:2:1::\", (@a | @b).to_s)",
          "838:     a = @a",
          "839:     a |= @b",
          "840:     assert_equal(\"3ffe:505:2:1::\", a.to_s)",
          "841:     assert_equal(\"3ffe:505:2::\", @a.to_s)",
          "842:     assert_equal(\"3ffe:505:2:1::\",",
          "843:                  (@a | 0x00000000000000010000000000000000).to_s)",
          "844:   end",
          "846:   def test_and",
          "847:     assert_equal(\"3ffe:505::\", (@a & @c).to_s)",
          "848:     a = @a",
          "849:     a &= @c",
          "850:     assert_equal(\"3ffe:505::\", a.to_s)",
          "851:     assert_equal(\"3ffe:505:2::\", @a.to_s)",
          "852:     assert_equal(\"3ffe:505::\", (@a & 0xffffffff000000000000000000000000).to_s)",
          "853:   end",
          "855:   def test_shift_right",
          "856:     assert_equal(\"0:3ffe:505:2::\", (@a >> 16).to_s)",
          "857:     a = @a",
          "858:     a >>= 16",
          "859:     assert_equal(\"0:3ffe:505:2::\", a.to_s)",
          "860:     assert_equal(\"3ffe:505:2::\", @a.to_s)",
          "861:   end",
          "863:   def test_shift_left",
          "864:     assert_equal(\"505:2::\", (@a << 16).to_s)",
          "865:     a = @a",
          "866:     a <<= 16",
          "867:     assert_equal(\"505:2::\", a.to_s)",
          "868:     assert_equal(\"3ffe:505:2::\", @a.to_s)",
          "869:   end",
          "871:   def test_carrot",
          "872:     a = ~@in6_addr_any",
          "873:     assert_equal(IN6MASK128, a.to_s)",
          "874:     assert_equal(\"::\", @in6_addr_any.to_s)",
          "875:   end",
          "877:   def test_equal",
          "878:     assert_equal(true, @a == IPAddr.new(\"3FFE:505:2::\"))",
          "879:     assert_equal(true, @a == IPAddr.new(\"3ffe:0505:0002::\"))",
          "880:     assert_equal(true, @a == IPAddr.new(\"3ffe:0505:0002:0:0:0:0:0\"))",
          "881:     assert_equal(false, @a == IPAddr.new(\"3ffe:505:3::\"))",
          "882:     assert_equal(true, @a != IPAddr.new(\"3ffe:505:3::\"))",
          "883:     assert_equal(false, @a != IPAddr.new(\"3ffe:505:2::\"))",
          "884:   end",
          "886:   def test_mask",
          "887:     a = @a.mask(32)",
          "888:     assert_equal(\"3ffe:505::\", a.to_s)",
          "889:     assert_equal(\"3ffe:505:2::\", @a.to_s)",
          "890:   end",
          "892:   def test_include?",
          "893:     assert_equal(true, @a.include?(IPAddr.new(\"3ffe:505:2::\")))",
          "894:     assert_equal(true, @a.include?(IPAddr.new(\"3ffe:505:2::1\")))",
          "895:     assert_equal(false, @a.include?(IPAddr.new(\"3ffe:505:3::\")))",
          "896:     net1 = IPAddr.new(\"192.168.2.0/24\")",
          "897:     assert_equal(true, net1.include?(IPAddr.new(\"192.168.2.0\")))",
          "898:     assert_equal(true, net1.include?(IPAddr.new(\"192.168.2.255\")))",
          "899:     assert_equal(false, net1.include?(IPAddr.new(\"192.168.3.0\")))",
          "900:     # test with integer parameter",
          "901:     int = (192 << 24) + (168 << 16) + (2 << 8) + 13",
          "903:     assert_equal(true, net1.include?(int))",
          "904:     assert_equal(false, net1.include?(int+255))",
          "906:   end",
          "908:   def test_hash",
          "909:     a1 = IPAddr.new('192.168.2.0')",
          "910:     a2 = IPAddr.new('192.168.2.0')",
          "911:     a3 = IPAddr.new('3ffe:505:2::1')",
          "912:     a4 = IPAddr.new('3ffe:505:2::1')",
          "913:     a5 = IPAddr.new('127.0.0.1')",
          "914:     a6 = IPAddr.new('::1')",
          "915:     a7 = IPAddr.new('192.168.2.0/25')",
          "916:     a8 = IPAddr.new('192.168.2.0/25')",
          "918:     h = { a1 => 'ipv4', a2 => 'ipv4', a3 => 'ipv6', a4 => 'ipv6', a5 => 'ipv4', a6 => 'ipv6', a7 => 'ipv4', a8 => 'ipv4'}",
          "919:     assert_equal(5, h.size)",
          "920:     assert_equal('ipv4', h[a1])",
          "921:     assert_equal('ipv4', h[a2])",
          "922:     assert_equal('ipv6', h[a3])",
          "923:     assert_equal('ipv6', h[a4])",
          "925:     require 'set'",
          "926:     s = Set[a1, a2, a3, a4, a5, a6, a7, a8]",
          "927:     assert_equal(5, s.size)",
          "928:     assert_equal(true, s.include?(a1))",
          "929:     assert_equal(true, s.include?(a2))",
          "930:     assert_equal(true, s.include?(a3))",
          "931:     assert_equal(true, s.include?(a4))",
          "932:     assert_equal(true, s.include?(a5))",
          "933:     assert_equal(true, s.include?(a6))",
          "934:   end",
          "935: end",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "test/test_ipaddr.rb||test/test_ipaddr.rb": [
          "File: test/test_ipaddr.rb -> test/test_ipaddr.rb",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: require_relative 'inlinetest.rb'",
          "2: target = __FILE__[/test_(.*\\.rb)$/, 1]",
          "3: InlineTest.loadtest__END__part(target)",
          "",
          "[Added Lines]",
          "1: require 'test/unit'",
          "2: require 'ipaddr'",
          "4: class TC_IPAddr < Test::Unit::TestCase",
          "5:   def test_s_new",
          "6:     [",
          "7:       [\"3FFE:505:ffff::/48\"],",
          "8:       [\"0:0:0:1::\"],",
          "9:       [\"2001:200:300::/48\"],",
          "10:       [\"2001:200:300::192.168.1.2/48\"],",
          "11:       [\"1:2:3:4:5:6:7::\"],",
          "12:       [\"::2:3:4:5:6:7:8\"],",
          "13:     ].each { |args|",
          "14:       assert_nothing_raised {",
          "15:         IPAddr.new(*args)",
          "16:       }",
          "17:     }",
          "19:     a = IPAddr.new",
          "20:     assert_equal(\"::\", a.to_s)",
          "21:     assert_equal(\"0000:0000:0000:0000:0000:0000:0000:0000\", a.to_string)",
          "22:     assert_equal(Socket::AF_INET6, a.family)",
          "24:     a = IPAddr.new(\"0123:4567:89ab:cdef:0ABC:DEF0:1234:5678\")",
          "25:     assert_equal(\"123:4567:89ab:cdef:abc:def0:1234:5678\", a.to_s)",
          "26:     assert_equal(\"0123:4567:89ab:cdef:0abc:def0:1234:5678\", a.to_string)",
          "27:     assert_equal(Socket::AF_INET6, a.family)",
          "29:     a = IPAddr.new(\"3ffe:505:2::/48\")",
          "30:     assert_equal(\"3ffe:505:2::\", a.to_s)",
          "31:     assert_equal(\"3ffe:0505:0002:0000:0000:0000:0000:0000\", a.to_string)",
          "32:     assert_equal(Socket::AF_INET6, a.family)",
          "33:     assert_equal(false, a.ipv4?)",
          "34:     assert_equal(true, a.ipv6?)",
          "35:     assert_equal(\"#<IPAddr: IPv6:3ffe:0505:0002:0000:0000:0000:0000:0000/ffff:ffff:ffff:0000:0000:0000:0000:0000>\", a.inspect)",
          "37:     a = IPAddr.new(\"3ffe:505:2::/ffff:ffff:ffff::\")",
          "38:     assert_equal(\"3ffe:505:2::\", a.to_s)",
          "39:     assert_equal(\"3ffe:0505:0002:0000:0000:0000:0000:0000\", a.to_string)",
          "40:     assert_equal(Socket::AF_INET6, a.family)",
          "42:     a = IPAddr.new(\"0.0.0.0\")",
          "43:     assert_equal(\"0.0.0.0\", a.to_s)",
          "44:     assert_equal(\"0.0.0.0\", a.to_string)",
          "45:     assert_equal(Socket::AF_INET, a.family)",
          "47:     a = IPAddr.new(\"192.168.1.2\")",
          "48:     assert_equal(\"192.168.1.2\", a.to_s)",
          "49:     assert_equal(\"192.168.1.2\", a.to_string)",
          "50:     assert_equal(Socket::AF_INET, a.family)",
          "51:     assert_equal(true, a.ipv4?)",
          "52:     assert_equal(false, a.ipv6?)",
          "54:     a = IPAddr.new(\"192.168.1.2/24\")",
          "55:     assert_equal(\"192.168.1.0\", a.to_s)",
          "56:     assert_equal(\"192.168.1.0\", a.to_string)",
          "57:     assert_equal(Socket::AF_INET, a.family)",
          "58:     assert_equal(\"#<IPAddr: IPv4:192.168.1.0/255.255.255.0>\", a.inspect)",
          "60:     a = IPAddr.new(\"192.168.1.2/255.255.255.0\")",
          "61:     assert_equal(\"192.168.1.0\", a.to_s)",
          "62:     assert_equal(\"192.168.1.0\", a.to_string)",
          "63:     assert_equal(Socket::AF_INET, a.family)",
          "65:     assert_equal(\"0:0:0:1::\", IPAddr.new(\"0:0:0:1::\").to_s)",
          "66:     assert_equal(\"2001:200:300::\", IPAddr.new(\"2001:200:300::/48\").to_s)",
          "68:     assert_equal(\"2001:200:300::\", IPAddr.new(\"[2001:200:300::]/48\").to_s)",
          "69:     assert_equal(\"1:2:3:4:5:6:7:0\", IPAddr.new(\"1:2:3:4:5:6:7::\").to_s)",
          "70:     assert_equal(\"0:2:3:4:5:6:7:8\", IPAddr.new(\"::2:3:4:5:6:7:8\").to_s)",
          "72:     assert_raise(IPAddr::InvalidAddressError) { IPAddr.new(\"192.168.0.256\") }",
          "73:     assert_raise(IPAddr::InvalidAddressError) { IPAddr.new(\"192.168.0.011\") }",
          "74:     assert_raise(IPAddr::InvalidAddressError) { IPAddr.new(\"fe80::1%fxp0\") }",
          "75:     assert_raise(IPAddr::InvalidAddressError) { IPAddr.new(\"[192.168.1.2]/120\") }",
          "76:     assert_raise(IPAddr::InvalidAddressError) { IPAddr.new(\"[2001:200:300::]\\nINVALID\") }",
          "77:     assert_raise(IPAddr::InvalidAddressError) { IPAddr.new(\"192.168.0.1/32\\nINVALID\") }",
          "78:     assert_raise(IPAddr::InvalidPrefixError) { IPAddr.new(\"::1/255.255.255.0\") }",
          "79:     assert_raise(IPAddr::InvalidPrefixError) { IPAddr.new(\"::1/129\") }",
          "80:     assert_raise(IPAddr::InvalidPrefixError) { IPAddr.new(\"192.168.0.1/33\") }",
          "81:     assert_raise(IPAddr::AddressFamilyError) { IPAddr.new(1) }",
          "82:     assert_raise(IPAddr::AddressFamilyError) { IPAddr.new(\"::ffff:192.168.1.2/120\", Socket::AF_INET) }",
          "83:   end",
          "85:   def test_s_new_ntoh",
          "86:     addr = ''",
          "87:     IPAddr.new(\"1234:5678:9abc:def0:1234:5678:9abc:def0\").hton.each_byte { |c|",
          "88:       addr += sprintf(\"%02x\", c)",
          "89:     }",
          "90:     assert_equal(\"123456789abcdef0123456789abcdef0\", addr)",
          "91:     addr = ''",
          "92:     IPAddr.new(\"123.45.67.89\").hton.each_byte { |c|",
          "93:       addr += sprintf(\"%02x\", c)",
          "94:     }",
          "95:     assert_equal(sprintf(\"%02x%02x%02x%02x\", 123, 45, 67, 89), addr)",
          "96:     a = IPAddr.new(\"3ffe:505:2::\")",
          "97:     assert_equal(\"3ffe:505:2::\", IPAddr.new_ntoh(a.hton).to_s)",
          "98:     a = IPAddr.new(\"192.168.2.1\")",
          "99:     assert_equal(\"192.168.2.1\", IPAddr.new_ntoh(a.hton).to_s)",
          "100:   end",
          "102:   def test_ipv4_compat",
          "103:     a = IPAddr.new(\"::192.168.1.2\")",
          "104:     assert_equal(\"::192.168.1.2\", a.to_s)",
          "105:     assert_equal(\"0000:0000:0000:0000:0000:0000:c0a8:0102\", a.to_string)",
          "106:     assert_equal(Socket::AF_INET6, a.family)",
          "107:     assert_equal(true, a.ipv4_compat?)",
          "108:     b = a.native",
          "109:     assert_equal(\"192.168.1.2\", b.to_s)",
          "110:     assert_equal(Socket::AF_INET, b.family)",
          "111:     assert_equal(false, b.ipv4_compat?)",
          "113:     a = IPAddr.new(\"192.168.1.2\")",
          "114:     b = a.ipv4_compat",
          "115:     assert_equal(\"::192.168.1.2\", b.to_s)",
          "116:     assert_equal(Socket::AF_INET6, b.family)",
          "117:   end",
          "119:   def test_ipv4_mapped",
          "120:     a = IPAddr.new(\"::ffff:192.168.1.2\")",
          "121:     assert_equal(\"::ffff:192.168.1.2\", a.to_s)",
          "122:     assert_equal(\"0000:0000:0000:0000:0000:ffff:c0a8:0102\", a.to_string)",
          "123:     assert_equal(Socket::AF_INET6, a.family)",
          "124:     assert_equal(true, a.ipv4_mapped?)",
          "125:     b = a.native",
          "126:     assert_equal(\"192.168.1.2\", b.to_s)",
          "127:     assert_equal(Socket::AF_INET, b.family)",
          "128:     assert_equal(false, b.ipv4_mapped?)",
          "130:     a = IPAddr.new(\"192.168.1.2\")",
          "131:     b = a.ipv4_mapped",
          "132:     assert_equal(\"::ffff:192.168.1.2\", b.to_s)",
          "133:     assert_equal(Socket::AF_INET6, b.family)",
          "134:   end",
          "136:   def test_reverse",
          "137:     assert_equal(\"f.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.2.0.0.0.5.0.5.0.e.f.f.3.ip6.arpa\", IPAddr.new(\"3ffe:505:2::f\").reverse)",
          "138:     assert_equal(\"1.2.168.192.in-addr.arpa\", IPAddr.new(\"192.168.2.1\").reverse)",
          "139:   end",
          "141:   def test_ip6_arpa",
          "142:     assert_equal(\"f.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.2.0.0.0.5.0.5.0.e.f.f.3.ip6.arpa\", IPAddr.new(\"3ffe:505:2::f\").ip6_arpa)",
          "143:     assert_raise(IPAddr::InvalidAddressError) {",
          "144:       IPAddr.new(\"192.168.2.1\").ip6_arpa",
          "145:     }",
          "146:   end",
          "148:   def test_ip6_int",
          "149:     assert_equal(\"f.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.2.0.0.0.5.0.5.0.e.f.f.3.ip6.int\", IPAddr.new(\"3ffe:505:2::f\").ip6_int)",
          "150:     assert_raise(IPAddr::InvalidAddressError) {",
          "151:       IPAddr.new(\"192.168.2.1\").ip6_int",
          "152:     }",
          "153:   end",
          "155:   def test_to_s",
          "156:     assert_equal(\"3ffe:0505:0002:0000:0000:0000:0000:0001\", IPAddr.new(\"3ffe:505:2::1\").to_string)",
          "157:     assert_equal(\"3ffe:505:2::1\", IPAddr.new(\"3ffe:505:2::1\").to_s)",
          "158:   end",
          "159: end",
          "161: class TC_Operator < Test::Unit::TestCase",
          "163:   IN6MASK32  = \"ffff:ffff::\"",
          "164:   IN6MASK128 = \"ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff\"",
          "166:   def setup",
          "167:     @in6_addr_any = IPAddr.new()",
          "168:     @a = IPAddr.new(\"3ffe:505:2::/48\")",
          "169:     @b = IPAddr.new(\"0:0:0:1::\")",
          "170:     @c = IPAddr.new(IN6MASK32)",
          "171:   end",
          "172:   alias set_up setup",
          "174:   def test_or",
          "175:     assert_equal(\"3ffe:505:2:1::\", (@a | @b).to_s)",
          "176:     a = @a",
          "177:     a |= @b",
          "178:     assert_equal(\"3ffe:505:2:1::\", a.to_s)",
          "179:     assert_equal(\"3ffe:505:2::\", @a.to_s)",
          "180:     assert_equal(\"3ffe:505:2:1::\",",
          "181:                  (@a | 0x00000000000000010000000000000000).to_s)",
          "182:   end",
          "184:   def test_and",
          "185:     assert_equal(\"3ffe:505::\", (@a & @c).to_s)",
          "186:     a = @a",
          "187:     a &= @c",
          "188:     assert_equal(\"3ffe:505::\", a.to_s)",
          "189:     assert_equal(\"3ffe:505:2::\", @a.to_s)",
          "190:     assert_equal(\"3ffe:505::\", (@a & 0xffffffff000000000000000000000000).to_s)",
          "191:   end",
          "193:   def test_shift_right",
          "194:     assert_equal(\"0:3ffe:505:2::\", (@a >> 16).to_s)",
          "195:     a = @a",
          "196:     a >>= 16",
          "197:     assert_equal(\"0:3ffe:505:2::\", a.to_s)",
          "198:     assert_equal(\"3ffe:505:2::\", @a.to_s)",
          "199:   end",
          "201:   def test_shift_left",
          "202:     assert_equal(\"505:2::\", (@a << 16).to_s)",
          "203:     a = @a",
          "204:     a <<= 16",
          "205:     assert_equal(\"505:2::\", a.to_s)",
          "206:     assert_equal(\"3ffe:505:2::\", @a.to_s)",
          "207:   end",
          "209:   def test_carrot",
          "210:     a = ~@in6_addr_any",
          "211:     assert_equal(IN6MASK128, a.to_s)",
          "212:     assert_equal(\"::\", @in6_addr_any.to_s)",
          "213:   end",
          "215:   def test_equal",
          "216:     assert_equal(true, @a == IPAddr.new(\"3FFE:505:2::\"))",
          "217:     assert_equal(true, @a == IPAddr.new(\"3ffe:0505:0002::\"))",
          "218:     assert_equal(true, @a == IPAddr.new(\"3ffe:0505:0002:0:0:0:0:0\"))",
          "219:     assert_equal(false, @a == IPAddr.new(\"3ffe:505:3::\"))",
          "220:     assert_equal(true, @a != IPAddr.new(\"3ffe:505:3::\"))",
          "221:     assert_equal(false, @a != IPAddr.new(\"3ffe:505:2::\"))",
          "222:   end",
          "224:   def test_mask",
          "225:     a = @a.mask(32)",
          "226:     assert_equal(\"3ffe:505::\", a.to_s)",
          "227:     assert_equal(\"3ffe:505:2::\", @a.to_s)",
          "228:   end",
          "230:   def test_include?",
          "231:     assert_equal(true, @a.include?(IPAddr.new(\"3ffe:505:2::\")))",
          "232:     assert_equal(true, @a.include?(IPAddr.new(\"3ffe:505:2::1\")))",
          "233:     assert_equal(false, @a.include?(IPAddr.new(\"3ffe:505:3::\")))",
          "234:     net1 = IPAddr.new(\"192.168.2.0/24\")",
          "235:     assert_equal(true, net1.include?(IPAddr.new(\"192.168.2.0\")))",
          "236:     assert_equal(true, net1.include?(IPAddr.new(\"192.168.2.255\")))",
          "237:     assert_equal(false, net1.include?(IPAddr.new(\"192.168.3.0\")))",
          "238:     # test with integer parameter",
          "239:     int = (192 << 24) + (168 << 16) + (2 << 8) + 13",
          "241:     assert_equal(true, net1.include?(int))",
          "242:     assert_equal(false, net1.include?(int+255))",
          "244:   end",
          "246:   def test_hash",
          "247:     a1 = IPAddr.new('192.168.2.0')",
          "248:     a2 = IPAddr.new('192.168.2.0')",
          "249:     a3 = IPAddr.new('3ffe:505:2::1')",
          "250:     a4 = IPAddr.new('3ffe:505:2::1')",
          "251:     a5 = IPAddr.new('127.0.0.1')",
          "252:     a6 = IPAddr.new('::1')",
          "253:     a7 = IPAddr.new('192.168.2.0/25')",
          "254:     a8 = IPAddr.new('192.168.2.0/25')",
          "256:     h = { a1 => 'ipv4', a2 => 'ipv4', a3 => 'ipv6', a4 => 'ipv6', a5 => 'ipv4', a6 => 'ipv6', a7 => 'ipv4', a8 => 'ipv4'}",
          "257:     assert_equal(5, h.size)",
          "258:     assert_equal('ipv4', h[a1])",
          "259:     assert_equal('ipv4', h[a2])",
          "260:     assert_equal('ipv6', h[a3])",
          "261:     assert_equal('ipv6', h[a4])",
          "263:     require 'set'",
          "264:     s = Set[a1, a2, a3, a4, a5, a6, a7, a8]",
          "265:     assert_equal(5, s.size)",
          "266:     assert_equal(true, s.include?(a1))",
          "267:     assert_equal(true, s.include?(a2))",
          "268:     assert_equal(true, s.include?(a3))",
          "269:     assert_equal(true, s.include?(a4))",
          "270:     assert_equal(true, s.include?(a5))",
          "271:     assert_equal(true, s.include?(a6))",
          "272:   end",
          "273: end",
          "",
          "---------------"
        ],
        "version.h||version.h": [
          "File: version.h -> version.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: #define RUBY_VERSION \"2.1.8\"",
          "2: #define RUBY_RELEASE_DATE \"2015-10-29\"",
          "5: #define RUBY_RELEASE_YEAR 2015",
          "6: #define RUBY_RELEASE_MONTH 10",
          "",
          "[Removed Lines]",
          "3: #define RUBY_PATCHLEVEL 409",
          "",
          "[Added Lines]",
          "3: #define RUBY_PATCHLEVEL 410",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "f0680bdee869d37c0b654d0226ae665e6adc934e",
      "candidate_info": {
        "commit_hash": "f0680bdee869d37c0b654d0226ae665e6adc934e",
        "repo": "ruby/ruby",
        "commit_url": "https://github.com/ruby/ruby/commit/f0680bdee869d37c0b654d0226ae665e6adc934e",
        "files": [
          "ChangeLog",
          "encoding.c",
          "internal.h",
          "marshal.c",
          "object.c",
          "test/ruby/test_encoding.rb",
          "version.h"
        ],
        "message": "merge revision(s) 52856,52906: [Backport #11760]\n\n\t* encoding.c (enc_m_loader): defer finding encoding object not to\n\t  be infected by marshal source.  [ruby-core:71793] [Bug #11760]\n\n\t* marshal.c (r_object0): enable compatible loader on USERDEF\n\t  class.  the loader function is called with the class itself,\n\t  instead of an allocated object, and the loaded data.\n\n\t* marshal.c (compat_allocator_table): intialize\n\t  compat_allocator_tbl on demand.\n\n\t* object.c (rb_undefined_alloc): extract from rb_obj_alloc.\n\n\t* marshal.c (compat_allocator_table): initialize\n\n\ngit-svn-id: svn+ssh://ci.ruby-lang.org/ruby/branches/ruby_2_1@52933 b2dd03c8-39d4-4d8f-98ff-823fe69b080e",
        "before_after_code_files": [
          "encoding.c||encoding.c",
          "internal.h||internal.h",
          "marshal.c||marshal.c",
          "object.c||object.c",
          "test/ruby/test_encoding.rb||test/ruby/test_encoding.rb",
          "version.h||version.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "version.h||version.h"
          ],
          "candidate": [
            "version.h||version.h"
          ]
        }
      },
      "candidate_diff": {
        "encoding.c||encoding.c": [
          "File: encoding.c -> encoding.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1208:     return rb_enc_from_encoding(enc);",
          "1209: }",
          "1212: static VALUE",
          "1213: enc_dump(int argc, VALUE *argv, VALUE self)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1212: static VALUE",
          "1213: enc_s_alloc(VALUE klass)",
          "1214: {",
          "1215:     rb_undefined_alloc(klass);",
          "1216:     return Qnil;",
          "1217: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1220: static VALUE",
          "1221: enc_load(VALUE klass, VALUE str)",
          "1222: {",
          "1223:     return enc_find(klass, str);",
          "1224: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1230: {",
          "1231:     return str;",
          "1232: }",
          "1235: static VALUE",
          "1236: enc_m_loader(VALUE klass, VALUE str)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1879:     int i;",
          "1881:     rb_cEncoding = rb_define_class(\"Encoding\", rb_cObject);",
          "1883:     rb_undef_method(CLASS_OF(rb_cEncoding), \"new\");",
          "1884:     rb_define_method(rb_cEncoding, \"to_s\", enc_name, 0);",
          "1885:     rb_define_method(rb_cEncoding, \"inspect\", enc_inspect, 0);",
          "",
          "[Removed Lines]",
          "1882:     rb_undef_alloc_func(rb_cEncoding);",
          "",
          "[Added Lines]",
          "1897:     rb_define_alloc_func(rb_cEncoding, enc_s_alloc);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1911:     for (i = 0; i < enc_table.count; ++i) {",
          "1912:  rb_ary_push(list, enc_new(enc_table.list[i].enc));",
          "1913:     }",
          "1914: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1930:     rb_marshal_define_compat(rb_cEncoding, Qnil, NULL, enc_m_loader);",
          "",
          "---------------"
        ],
        "internal.h||internal.h": [
          "File: internal.h -> internal.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "599: void rb_obj_copy_ivar(VALUE dest, VALUE obj);",
          "600: VALUE rb_obj_equal(VALUE obj1, VALUE obj2);",
          "601: VALUE rb_class_search_ancestor(VALUE klass, VALUE super);",
          "603: struct RBasicRaw {",
          "604:     VALUE flags;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "602: NORETURN(void rb_undefined_alloc(VALUE klass));",
          "",
          "---------------"
        ],
        "marshal.c||marshal.c": [
          "File: marshal.c -> marshal.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "109:     st_foreach(tbl, mark_marshal_compat_i, 0);",
          "110: }",
          "112: void",
          "113: rb_marshal_define_compat(VALUE newclass, VALUE oldclass, VALUE (*dumper)(VALUE), VALUE (*loader)(VALUE, VALUE))",
          "114: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "112: static st_table *compat_allocator_table(void);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "127:     compat->dumper = dumper;",
          "128:     compat->loader = loader;",
          "131: }",
          "133: #define MARSHAL_INFECTION FL_TAINT",
          "",
          "[Removed Lines]",
          "130:     st_insert(compat_allocator_tbl, (st_data_t)allocator, (st_data_t)compat);",
          "",
          "[Added Lines]",
          "132:     st_insert(compat_allocator_table(), (st_data_t)allocator, (st_data_t)compat);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1753:         {",
          "1754:      VALUE klass = path2class(r_unique(arg));",
          "1755:      VALUE data;",
          "1757:      if (!rb_obj_respond_to(klass, s_load, TRUE)) {",
          "1758:   rb_raise(rb_eTypeError, \"class %s needs to have method `_load'\",",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1758:      st_data_t d;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1766:      v = rb_funcall2(klass, s_load, 1, &data);",
          "1767:      check_load_arg(arg, s_load);",
          "1768:      v = r_entry(v, arg);",
          "1770:  }",
          "1771:         break;",
          "",
          "[Removed Lines]",
          "1769:             v = r_leave(v, arg);",
          "",
          "[Added Lines]",
          "1772:      if (st_lookup(compat_allocator_tbl, (st_data_t)rb_get_alloc_func(klass), &d)) {",
          "1773:   marshal_compat_t *compat = (marshal_compat_t*)d;",
          "1774:   v = compat->loader(klass, v);",
          "1775:      }",
          "1776:      v = r_post_proc(v, arg);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2128:     rb_define_const(rb_mMarshal, \"MAJOR_VERSION\", INT2FIX(MARSHAL_MAJOR));",
          "2130:     rb_define_const(rb_mMarshal, \"MINOR_VERSION\", INT2FIX(MARSHAL_MINOR));",
          "2132:     compat_allocator_tbl = st_init_numtable();",
          "2133:     compat_allocator_tbl_wrapper =",
          "2134:  Data_Wrap_Struct(rb_cData, mark_marshal_compat_t, 0, compat_allocator_tbl);",
          "2135:     rb_gc_register_mark_object(compat_allocator_tbl_wrapper);",
          "2136: }",
          "2138: VALUE",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2138: }",
          "2140: static st_table *",
          "2141: compat_allocator_table(void)",
          "2142: {",
          "2143:     if (compat_allocator_tbl) return compat_allocator_tbl;",
          "2148:     return compat_allocator_tbl;",
          "",
          "---------------"
        ],
        "object.c||object.c": [
          "File: object.c -> object.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1771:     return klass;",
          "1772: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1774: void",
          "1775: rb_undefined_alloc(VALUE klass)",
          "1776: {",
          "1777:     rb_raise(rb_eTypeError, \"allocator undefined for %\"PRIsVALUE,",
          "1778:       klass);",
          "1779: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1807:     }",
          "1808:     allocator = rb_get_alloc_func(klass);",
          "1809:     if (!allocator) {",
          "1812:     }",
          "1814: #if !defined(DTRACE_PROBES_DISABLED) || !DTRACE_PROBES_DISABLED",
          "",
          "[Removed Lines]",
          "1810:  rb_raise(rb_eTypeError, \"allocator undefined for %\"PRIsVALUE,",
          "1811:    klass);",
          "",
          "[Added Lines]",
          "1817:  rb_undefined_alloc(klass);",
          "",
          "---------------"
        ],
        "test/ruby/test_encoding.rb||test/ruby/test_encoding.rb": [
          "File: test/ruby/test_encoding.rb -> test/ruby/test_encoding.rb",
          "--- Hunk 1 ---",
          "[Context before]",
          "34:       assert_raise(TypeError) { e.dup }",
          "35:       assert_raise(TypeError) { e.clone }",
          "36:       assert_equal(e.object_id, Marshal.load(Marshal.dump(e)).object_id)",
          "37:     end",
          "38:   end",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "37:       assert_not_predicate(e, :tainted?)",
          "38:       Marshal.load(Marshal.dump(e).taint)",
          "39:       assert_not_predicate(e, :tainted?, '[ruby-core:71793] [Bug #11760]')",
          "",
          "---------------"
        ],
        "version.h||version.h": [
          "File: version.h -> version.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: #define RUBY_VERSION \"2.1.8\"",
          "5: #define RUBY_RELEASE_YEAR 2015",
          "6: #define RUBY_RELEASE_MONTH 12",
          "9: #include \"ruby/version.h\"",
          "",
          "[Removed Lines]",
          "2: #define RUBY_RELEASE_DATE \"2015-12-04\"",
          "3: #define RUBY_PATCHLEVEL 432",
          "7: #define RUBY_RELEASE_DAY 4",
          "",
          "[Added Lines]",
          "2: #define RUBY_RELEASE_DATE \"2015-12-08\"",
          "3: #define RUBY_PATCHLEVEL 433",
          "7: #define RUBY_RELEASE_DAY 8",
          "",
          "---------------"
        ]
      }
    }
  ]
}
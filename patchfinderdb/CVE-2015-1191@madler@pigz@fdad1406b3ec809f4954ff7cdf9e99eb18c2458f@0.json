{
  "cve_id": "CVE-2015-1191",
  "cve_desc": "Multiple directory traversal vulnerabilities in pigz 2.3.1 allow remote attackers to write to arbitrary files via a (1) full pathname or (2) .. (dot dot) in an archive.",
  "repo": "madler/pigz",
  "patch_hash": "fdad1406b3ec809f4954ff7cdf9e99eb18c2458f",
  "patch_info": {
    "commit_hash": "fdad1406b3ec809f4954ff7cdf9e99eb18c2458f",
    "repo": "madler/pigz",
    "commit_url": "https://github.com/madler/pigz/commit/fdad1406b3ec809f4954ff7cdf9e99eb18c2458f",
    "files": [
      "pigz.c"
    ],
    "message": "When decompressing with -N or -NT, strip any path from header name.\n\nThis uses the path of the compressed file combined with the name\nfrom the header as the name of the decompressed output file.  Any\npath information in the header name is stripped.  This avoids a\npossible vulnerability where absolute or descending paths are put\nin the gzip header.",
    "before_after_code_files": [
      "pigz.c||pigz.c"
    ]
  },
  "patch_diff": {
    "pigz.c||pigz.c": [
      "File: pigz.c -> pigz.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "3520:                  \" (use -f to force)\");",
      "3521:     }",
      "3522:     else {",
      "3530:         }",
      "3537:         if (g.outf == NULL)",
      "3538:             bail(\"not enough memory\", \"\");",
      "3541:         g.outd = open(g.outf, O_CREAT | O_TRUNC | O_WRONLY |",
      "3545:         if (g.outd < 0 && errno == EEXIST && isatty(0) && g.verbosity) {",
      "",
      "[Removed Lines]",
      "3523:         char *to, *repl;",
      "3526:         to = g.inf;",
      "3527:         if (g.decode && (g.headis & 1) != 0 && g.hname != NULL) {",
      "3528:             to = g.hname;",
      "3529:             len = strlen(g.hname);",
      "3533:         repl = g.decode && strcmp(to + len, \".tgz\") ? \"\" : \".tar\";",
      "3536:         g.outf = MALLOC(len + (g.decode ? strlen(repl) : strlen(g.sufx)) + 1);",
      "3539:         memcpy(g.outf, to, len);",
      "3540:         strcpy(g.outf + len, g.decode ? repl : g.sufx);",
      "3542:                              (g.force ? 0 : O_EXCL), 0600);",
      "",
      "[Added Lines]",
      "3523:         char *to = g.inf, *sufx = \"\";",
      "3524:         size_t pre = 0;",
      "3527:         if (g.decode) {",
      "3530:             if ((g.headis & 1) != 0 && g.hname != NULL) {",
      "3531:                 pre = justname(g.inf) - g.inf;",
      "3532:                 to = justname(g.hname);",
      "3533:                 len = strlen(to);",
      "3534:             }",
      "3536:             else if (strcmp(to + len, \".tgz\") == 0)",
      "3537:                 sufx = \".tar\";",
      "3539:         else",
      "3541:             sufx = g.sufx;",
      "3544:         g.outf = MALLOC(pre + len + strlen(sufx) + 1);",
      "3547:         memcpy(g.outf, g.inf, pre);",
      "3548:         memcpy(g.outf + pre, to, len);",
      "3549:         strcpy(g.outf + pre + len, sufx);",
      "3551:                               (g.force ? 0 : O_EXCL), 0600);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "1fc7241eb595b762d8fdedd830af3202794e53f0",
      "candidate_info": {
        "commit_hash": "1fc7241eb595b762d8fdedd830af3202794e53f0",
        "repo": "madler/pigz",
        "commit_url": "https://github.com/madler/pigz/commit/1fc7241eb595b762d8fdedd830af3202794e53f0",
        "files": [
          "Makefile",
          "pigz.c",
          "try.c",
          "try.h",
          "yarn.c",
          "yarn.h"
        ],
        "message": "Do not abort on inflate data error -- continue to process files.\n\nThis introduces try/catch/throw for error handling throughout pigz.\nEach thread has its own try stack for error handling.  If a throw\nmakes it to the top try in a thread, then the entire program is\naborted.  Data errors caught during decoding and decompression\npermit the process to continue with subsequent files.",
        "before_after_code_files": [
          "pigz.c||pigz.c",
          "try.c||try.c",
          "try.h||try.h",
          "yarn.c||yarn.c",
          "yarn.h||yarn.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "pigz.c||pigz.c"
          ],
          "candidate": [
            "pigz.c||pigz.c"
          ]
        }
      },
      "candidate_diff": {
        "pigz.c||pigz.c": [
          "File: pigz.c -> pigz.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "524:     return 0;",
          "525: }",
          "537: #ifdef DEBUG",
          "",
          "[Removed Lines]",
          "528: local int bail(char *why, char *what)",
          "529: {",
          "530:     if (g.outd != -1 && g.outf != NULL)",
          "531:         unlink(g.outf);",
          "532:     complain(\"abort: %s%s\", why, what);",
          "533:     exit(1);",
          "534:     return 0;",
          "535: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "635: #define ZALLOC zlib_alloc",
          "636: #define ZFREE zlib_free",
          "639: local struct timeval start;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "633: #define MALLOC malloc",
          "634: #define REALLOC realloc",
          "635: #define FREE free",
          "636: #define OPAQUE Z_NULL",
          "637: #define ZALLOC Z_NULL",
          "638: #define ZFREE Z_NULL",
          "640: #endif",
          "643: local void *alloc(void *ptr, size_t size)",
          "644: {",
          "645:     ptr = REALLOC(ptr, size);",
          "646:     if (ptr == NULL)",
          "647:         throw(ENOMEM, \"not enough memory\");",
          "648:     return ptr;",
          "649: }",
          "651: #if DEBUG",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "677:     char msg[MAXMSG];",
          "679:     gettimeofday(&now, NULL);",
          "683:     me->when = now;",
          "684:     va_start(ap, fmt);",
          "685:     vsnprintf(msg, MAXMSG, fmt, ap);",
          "686:     va_end(ap);",
          "692:     strcpy(me->msg, msg);",
          "693:     me->next = NULL;",
          "694: #ifndef NOTHREAD",
          "",
          "[Removed Lines]",
          "680:     me = MALLOC(sizeof(struct log));",
          "681:     if (me == NULL)",
          "682:         bail(\"not enough memory\", \"\");",
          "687:     me->msg = MALLOC(strlen(msg) + 1);",
          "688:     if (me->msg == NULL) {",
          "689:         FREE(me);",
          "690:         bail(\"not enough memory\", \"\");",
          "691:     }",
          "",
          "[Added Lines]",
          "697:     me = alloc(NULL, sizeof(struct log));",
          "702:     me->msg = alloc(NULL, strlen(msg) + 1);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "800: #define log_dump()",
          "801: #define Trace(x)",
          "803: #endif",
          "806:    next power of 2 if close (three applications results in doubling) -- if",
          "",
          "[Removed Lines]",
          "793: #define MALLOC malloc",
          "794: #define REALLOC realloc",
          "795: #define FREE free",
          "796: #define OPAQUE Z_NULL",
          "797: #define ZALLOC Z_NULL",
          "798: #define ZFREE Z_NULL",
          "",
          "[Added Lines]",
          "810: local void cut_short(int sig)",
          "811: {",
          "812:     if (sig == SIGINT)",
          "813:         Trace((\"termination by user\"));",
          "814:     if (g.outd != -1 && g.outf != NULL)",
          "815:         unlink(g.outf);",
          "816:     RELEASE(g.outf);",
          "817:     log_dump();",
          "818:     _exit(sig < 0 ? -sig : ECANCELED);",
          "819: }",
          "822: #define THREADABORT(ball) \\",
          "823:     do { \\",
          "824:         complain(\"abort: %s\", (ball).why); \\",
          "825:         drop(ball); \\",
          "826:         cut_short(-(ball).code); \\",
          "827:     } while (0)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "830:                             void *cpy, size_t len)",
          "831: {",
          "832:     size_t need;",
          "835:     need = off + len;",
          "836:     if (need < off)",
          "838:     if (need > *size) {",
          "839:         need = grow(need);",
          "843:             RELEASE(*mem);",
          "846:         }",
          "851:     }",
          "852:     memcpy(*mem + off, cpy, len);",
          "",
          "[Removed Lines]",
          "833:     char *bigger;",
          "837:         bail(\"overflow\", \"\");",
          "840:         if (off)",
          "841:             bigger = REALLOC(*mem, need);",
          "842:         else {",
          "845:             bigger = MALLOC(need);",
          "847:         if (bigger == NULL)",
          "848:             bail(\"not enough memory\", \"\");",
          "",
          "[Added Lines]",
          "860:         throw(EOVERFLOW, \"overflow\");",
          "863:         if (off == 0) {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "871:     while (len) {",
          "872:         ret = read(desc, buf, len);",
          "873:         if (ret < 0)",
          "875:         if (ret == 0)",
          "876:             break;",
          "877:         buf += ret;",
          "",
          "[Removed Lines]",
          "874:             bail(\"read error on \", g.inf);",
          "",
          "[Added Lines]",
          "892:             throw(errno, \"read error on %s (%s)\", g.inf, strerror(errno));",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "889:     while (len) {",
          "890:         ret = write(desc, buf, len);",
          "895:         buf += ret;",
          "896:         len -= ret;",
          "897:     }",
          "",
          "[Removed Lines]",
          "891:         if (ret < 1) {",
          "892:             complain(\"write error code %d\", errno);",
          "893:             bail(\"write error on \", g.outf);",
          "894:         }",
          "",
          "[Added Lines]",
          "909:         if (ret < 1)",
          "910:             throw(errno, \"write error on %s (%s)\", g.outf, strerror(errno));",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1246:         pool->limit--;",
          "1247:     pool->made++;",
          "1248:     release(pool->have);",
          "1256:     space->size = pool->size;",
          "1257:     space->len = 0;",
          "",
          "[Removed Lines]",
          "1249:     space = MALLOC(sizeof(struct space));",
          "1250:     if (space == NULL)",
          "1251:         bail(\"not enough memory\", \"\");",
          "1253:     space->buf = MALLOC(pool->size);",
          "1254:     if (space->buf == NULL)",
          "1255:         bail(\"not enough memory\", \"\");",
          "",
          "[Added Lines]",
          "1265:     space = alloc(NULL, sizeof(struct space));",
          "1267:     space->buf = alloc(NULL, pool->size);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1268:     more = grow(space->size);",
          "1269:     if (more == space->size)",
          "1276:     space->size = more;",
          "1277: }",
          "",
          "[Removed Lines]",
          "1270:         bail(\"not enough memory\", \"\");",
          "1273:     space->buf = REALLOC(space->buf, more);",
          "1274:     if (space->buf == NULL)",
          "1275:         bail(\"not enough memory\", \"\");",
          "",
          "[Added Lines]",
          "1282:         throw(EOVERFLOW, \"overflow\");",
          "1285:     space->buf = alloc(space->buf, more);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1290:     int use;",
          "1291:     struct pool *pool;",
          "1293:     possess(space->use);",
          "1294:     use = peek_lock(space->use);",
          "1295:     assert(use != 0);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1303:     if (space == NULL)",
          "1304:         return;",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1463: #endif",
          "1467:     (void)dummy;",
          "1512:             else {",
          "1515:             }",
          "1549:             }",
          "1552:             if (g.level <= 9) {",
          "1561:                 }",
          "1568: #if ZLIB_VERNUM >= 0x1260",
          "1581:                         deflate_engine(&strm, job->out, Z_BLOCK);",
          "1583: #else",
          "1585: #endif",
          "1586:                 }",
          "1609:                             job->out->buf[job->out->len++] = 0;",
          "1618:                             job->out->buf[job->out->len++] = 0;",
          "1621:                     }",
          "1622:                 }",
          "1629:             drop_space(job->lens);",
          "1630:             job->lens = NULL;",
          "1659:         }",
          "1668:     }",
          "1673: }",
          "",
          "[Removed Lines]",
          "1470:     strm.zfree = ZFREE;",
          "1471:     strm.zalloc = ZALLOC;",
          "1472:     strm.opaque = OPAQUE;",
          "1473:     if (deflateInit2(&strm, 6, Z_DEFLATED, -15, 8, Z_DEFAULT_STRATEGY) != Z_OK)",
          "1474:         bail(\"not enough memory\", \"\");",
          "1477:     for (;;) {",
          "1479:         possess(compress_have);",
          "1480:         wait_for(compress_have, NOT_TO_BE, 0);",
          "1481:         job = compress_head;",
          "1482:         assert(job != NULL);",
          "1483:         if (job->seq == -1)",
          "1484:             break;",
          "1485:         compress_head = job->next;",
          "1486:         if (job->next == NULL)",
          "1487:             compress_tail = &compress_head;",
          "1488:         twist(compress_have, BY, -1);",
          "1491:            deflateParams() is called immediately after deflateReset(), there is",
          "1493:         Trace((\"-- compressing #%ld\", job->seq));",
          "1494:         if (g.level <= 9) {",
          "1495:             (void)deflateReset(&strm);",
          "1496:             (void)deflateParams(&strm, g.level, Z_DEFAULT_STRATEGY);",
          "1497:         }",
          "1498:         else {",
          "1499:             temp = get_space(&out_pool);",
          "1500:             temp->len = 0;",
          "1501:         }",
          "1504:            (not NULL if g.setdict is true and if this is not the first work",
          "1506:         if (job->out != NULL) {",
          "1507:             len = job->out->len;",
          "1508:             left = len < DICT ? len : DICT;",
          "1509:             if (g.level <= 9)",
          "1510:                 deflateSetDictionary(&strm, job->out->buf + (len - left),",
          "1511:                                      left);",
          "1513:                 memcpy(temp->buf, job->out->buf + (len - left), left);",
          "1514:                 temp->len = left;",
          "1516:             drop_space(job->out);",
          "1517:         }",
          "1520:         job->out = get_space(&out_pool);",
          "1521:         if (g.level <= 9) {",
          "1522:             strm.next_in = job->in->buf;",
          "1523:             strm.next_out = job->out->buf;",
          "1524:         }",
          "1525:         else",
          "1526:             memcpy(temp->buf + temp->len, job->in->buf, job->in->len);",
          "1529:         next = job->lens == NULL ? NULL : job->lens->buf;",
          "1530:         left = job->in->len;",
          "1531:         job->out->len = 0;",
          "1532:         do {",
          "1534:             len = next == NULL ? 128 : *next++;",
          "1536:                 len = (len << 8) + (*next++) + 64;",
          "1538:                 len = left;",
          "1540:                 len &= 0x3f;",
          "1542:                 len = ((len & 0x1f) << 16) + (*next++ << 8);",
          "1543:                 len += *next++ + 32832U;",
          "1544:             }",
          "1546:                 len = ((len & 0x1f) << 24) + (*next++ << 16);",
          "1547:                 len += *next++ << 8;",
          "1548:                 len += *next++ + 2129984UL;",
          "1550:             left -= len;",
          "1554:                    loop is needed for those cases where the unsigned type is",
          "1555:                    smaller than the size_t type, or when len is close to the",
          "1557:                 while (len > MAXP2) {",
          "1558:                     strm.avail_in = MAXP2;",
          "1559:                     deflate_engine(&strm, job->out, Z_NO_FLUSH);",
          "1560:                     len -= MAXP2;",
          "1564:                    boundary, using a sync marker if necessary, or finish the",
          "1566:                 strm.avail_in = (unsigned)len;",
          "1567:                 if (left || job->more) {",
          "1569:                     deflate_engine(&strm, job->out, Z_BLOCK);",
          "1572:                     (void)deflatePending(&strm, Z_NULL, &bits);",
          "1573:                     if (bits & 1)",
          "1574:                         deflate_engine(&strm, job->out, Z_SYNC_FLUSH);",
          "1575:                     else if (bits & 7) {",
          "1577:                             bits = deflatePrime(&strm, 10, 2);",
          "1578:                             assert(bits == Z_OK);",
          "1579:                             (void)deflatePending(&strm, Z_NULL, &bits);",
          "1580:                         } while (bits & 7);",
          "1582:                     }",
          "1584:                     deflate_engine(&strm, job->out, Z_SYNC_FLUSH);",
          "1587:                 else",
          "1588:                     deflate_engine(&strm, job->out, Z_FINISH);",
          "1589:             }",
          "1590:             else {",
          "1592:                 unsigned char bits, *out;",
          "1593:                 size_t outsize;",
          "1595:                 out = NULL;",
          "1596:                 outsize = 0;",
          "1597:                 bits = 0;",
          "1598:                 ZopfliDeflatePart(&g.zopts, 2, !(left || job->more),",
          "1599:                                   temp->buf, temp->len, temp->len + len,",
          "1600:                                   &bits, &out, &outsize);",
          "1601:                 assert(job->out->len + outsize + 5 <= job->out->size);",
          "1602:                 memcpy(job->out->buf + job->out->len, out, outsize);",
          "1603:                 free(out);",
          "1604:                 job->out->len += outsize;",
          "1605:                 if (left || job->more) {",
          "1606:                     bits &= 7;",
          "1607:                     if (bits & 1) {",
          "1608:                         if (bits == 7)",
          "1610:                         job->out->buf[job->out->len++] = 0;",
          "1611:                         job->out->buf[job->out->len++] = 0;",
          "1612:                         job->out->buf[job->out->len++] = 0xff;",
          "1613:                         job->out->buf[job->out->len++] = 0xff;",
          "1614:                     }",
          "1615:                     else if (bits) {",
          "1616:                         do {",
          "1617:                             job->out->buf[job->out->len - 1] += 2 << bits;",
          "1619:                             bits += 2;",
          "1620:                         } while (bits < 8);",
          "1623:                 temp->len += len;",
          "1624:             }",
          "1625:         } while (left);",
          "1626:         if (g.level > 9)",
          "1627:             drop_space(temp);",
          "1628:         if (job->lens != NULL) {",
          "1631:         }",
          "1632:         Trace((\"-- compressed #%ld%s\", job->seq, job->more ? \"\" : \" (last)\"));",
          "1635:         use_space(job->in);",
          "1638:         possess(write_first);",
          "1639:         prior = &write_head;",
          "1640:         while ((here = *prior) != NULL) {",
          "1641:             if (here->seq > job->seq)",
          "1642:                 break;",
          "1643:             prior = &(here->next);",
          "1644:         }",
          "1645:         job->next = here;",
          "1647:         twist(write_first, TO, write_head->seq);",
          "1650:            thread that the calculation is complete, and drop this usage of the",
          "1652:         len = job->in->len;",
          "1653:         next = job->in->buf;",
          "1654:         check = CHECK(0L, Z_NULL, 0);",
          "1655:         while (len > MAXP2) {",
          "1656:             check = CHECK(check, next, MAXP2);",
          "1657:             len -= MAXP2;",
          "1658:             next += MAXP2;",
          "1660:         check = CHECK(check, next, (unsigned)len);",
          "1661:         drop_space(job->in);",
          "1662:         job->check = check;",
          "1663:         Trace((\"-- checked #%ld%s\", job->seq, job->more ? \"\" : \" (last)\"));",
          "1664:         possess(job->calc);",
          "1665:         twist(job->calc, TO, 1);",
          "1671:     release(compress_have);",
          "1672:     (void)deflateEnd(&strm);",
          "",
          "[Added Lines]",
          "1483:     try {",
          "1485:         strm.zfree = ZFREE;",
          "1486:         strm.zalloc = ZALLOC;",
          "1487:         strm.opaque = OPAQUE;",
          "1488:         ret = deflateInit2(&strm, 6, Z_DEFLATED, -15, 8, Z_DEFAULT_STRATEGY);",
          "1489:         if (ret == Z_MEM_ERROR)",
          "1490:             throw(ENOMEM, \"not enough memory\");",
          "1491:         if (ret != Z_OK)",
          "1492:             throw(EINVAL, \"internal error\");",
          "1495:         for (;;) {",
          "1497:             possess(compress_have);",
          "1498:             wait_for(compress_have, NOT_TO_BE, 0);",
          "1499:             job = compress_head;",
          "1500:             assert(job != NULL);",
          "1501:             if (job->seq == -1)",
          "1502:                 break;",
          "1503:             compress_head = job->next;",
          "1504:             if (job->next == NULL)",
          "1505:                 compress_tail = &compress_head;",
          "1506:             twist(compress_have, BY, -1);",
          "1509:                if deflateParams() is called immediately after deflateReset(),",
          "1511:             Trace((\"-- compressing #%ld\", job->seq));",
          "1512:             if (g.level <= 9) {",
          "1513:                 (void)deflateReset(&strm);",
          "1514:                 (void)deflateParams(&strm, g.level, Z_DEFAULT_STRATEGY);",
          "1515:             }",
          "1517:                 if (temp == NULL)",
          "1518:                     temp = get_space(&out_pool);",
          "1519:                 temp->len = 0;",
          "1523:                buffer (not NULL if g.setdict is true and if this is not the",
          "1525:             if (job->out != NULL) {",
          "1526:                 len = job->out->len;",
          "1527:                 left = len < DICT ? len : DICT;",
          "1528:                 if (g.level <= 9)",
          "1529:                     deflateSetDictionary(&strm, job->out->buf + (len - left),",
          "1530:                                          left);",
          "1531:                 else {",
          "1532:                     memcpy(temp->buf, job->out->buf + (len - left), left);",
          "1533:                     temp->len = left;",
          "1534:                 }",
          "1535:                 drop_space(job->out);",
          "1539:             job->out = get_space(&out_pool);",
          "1541:                 strm.next_in = job->in->buf;",
          "1542:                 strm.next_out = job->out->buf;",
          "1543:             }",
          "1544:             else",
          "1545:                 memcpy(temp->buf + temp->len, job->in->buf, job->in->len);",
          "1548:             next = job->lens == NULL ? NULL : job->lens->buf;",
          "1549:             left = job->in->len;",
          "1550:             job->out->len = 0;",
          "1551:             do {",
          "1553:                 len = next == NULL ? 128 : *next++;",
          "1555:                     len = (len << 8) + (*next++) + 64;",
          "1557:                     len = left;",
          "1559:                     len &= 0x3f;",
          "1561:                     len = ((len & 0x1f) << 16) + (*next++ << 8);",
          "1562:                     len += *next++ + 32832U;",
          "1565:                     len = ((len & 0x1f) << 24) + (*next++ << 16);",
          "1566:                     len += *next++ << 8;",
          "1567:                     len += *next++ + 2129984UL;",
          "1568:                 }",
          "1569:                 left -= len;",
          "1571:                 if (g.level <= 9) {",
          "1573:                        loop is needed for those cases where the unsigned type",
          "1574:                        is smaller than the size_t type, or when len is close to",
          "1576:                     while (len > MAXP2) {",
          "1577:                         strm.avail_in = MAXP2;",
          "1578:                         deflate_engine(&strm, job->out, Z_NO_FLUSH);",
          "1579:                         len -= MAXP2;",
          "1580:                     }",
          "1583:                        boundary, using a sync marker if necessary, or finish",
          "1585:                     strm.avail_in = (unsigned)len;",
          "1586:                     if (left || job->more) {",
          "1591:                         (void)deflatePending(&strm, Z_NULL, &bits);",
          "1592:                         if (bits & 1)",
          "1593:                             deflate_engine(&strm, job->out, Z_SYNC_FLUSH);",
          "1594:                         else if (bits & 7) {",
          "1596:                                 bits = deflatePrime(&strm, 10, 2);",
          "1597:                                 assert(bits == Z_OK);",
          "1598:                                 (void)deflatePending(&strm, Z_NULL, &bits);",
          "1599:                             } while (bits & 7);",
          "1600:                             deflate_engine(&strm, job->out, Z_BLOCK);",
          "1601:                         }",
          "1603:                         deflate_engine(&strm, job->out, Z_SYNC_FLUSH);",
          "1605:                     }",
          "1606:                     else",
          "1607:                         deflate_engine(&strm, job->out, Z_FINISH);",
          "1609:                 else {",
          "1611:                     unsigned char bits, *out;",
          "1612:                     size_t outsize;",
          "1614:                     out = NULL;",
          "1615:                     outsize = 0;",
          "1616:                     bits = 0;",
          "1617:                     ZopfliDeflatePart(&g.zopts, 2, !(left || job->more),",
          "1618:                                       temp->buf, temp->len, temp->len + len,",
          "1619:                                       &bits, &out, &outsize);",
          "1620:                     assert(job->out->len + outsize + 5 <= job->out->size);",
          "1621:                     memcpy(job->out->buf + job->out->len, out, outsize);",
          "1622:                     free(out);",
          "1623:                     job->out->len += outsize;",
          "1624:                     if (left || job->more) {",
          "1625:                         bits &= 7;",
          "1626:                         if (bits & 1) {",
          "1627:                             if (bits == 7)",
          "1628:                                 job->out->buf[job->out->len++] = 0;",
          "1631:                             job->out->buf[job->out->len++] = 0xff;",
          "1632:                             job->out->buf[job->out->len++] = 0xff;",
          "1633:                         }",
          "1634:                         else if (bits) {",
          "1635:                             do {",
          "1636:                                 job->out->buf[job->out->len - 1] += 2 << bits;",
          "1637:                                 job->out->buf[job->out->len++] = 0;",
          "1638:                                 bits += 2;",
          "1639:                             } while (bits < 8);",
          "1640:                         }",
          "1642:                     temp->len += len;",
          "1644:             } while (left);",
          "1647:             Trace((\"-- compressed #%ld%s\", job->seq,",
          "1648:                    job->more ? \"\" : \" (last)\"));",
          "1651:             use_space(job->in);",
          "1654:             possess(write_first);",
          "1655:             prior = &write_head;",
          "1656:             while ((here = *prior) != NULL) {",
          "1657:                 if (here->seq > job->seq)",
          "1658:                     break;",
          "1659:                 prior = &(here->next);",
          "1660:             }",
          "1661:             job->next = here;",
          "1663:             twist(write_first, TO, write_head->seq);",
          "1666:                write thread that the calculation is complete, and drop this",
          "1668:             len = job->in->len;",
          "1669:             next = job->in->buf;",
          "1670:             check = CHECK(0L, Z_NULL, 0);",
          "1671:             while (len > MAXP2) {",
          "1672:                 check = CHECK(check, next, MAXP2);",
          "1673:                 len -= MAXP2;",
          "1674:                 next += MAXP2;",
          "1675:             }",
          "1676:             check = CHECK(check, next, (unsigned)len);",
          "1677:             drop_space(job->in);",
          "1678:             job->check = check;",
          "1679:             Trace((\"-- checked #%ld%s\", job->seq, job->more ? \"\" : \" (last)\"));",
          "1680:             possess(job->calc);",
          "1681:             twist(job->calc, TO, 1);",
          "1687:         drop_space(temp);",
          "1688:         release(compress_have);",
          "1689:         (void)deflateEnd(&strm);",
          "1690:     }",
          "1691:     catch (err) {",
          "1692:         THREADABORT(err);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1689:     (void)dummy;",
          "1745: }",
          "",
          "[Removed Lines]",
          "1692:     Trace((\"-- write thread running\"));",
          "1693:     head = put_header();",
          "1696:     ulen = clen = 0;",
          "1697:     check = CHECK(0L, Z_NULL, 0);",
          "1698:     seq = 0;",
          "1699:     do {",
          "1701:         possess(write_first);",
          "1702:         wait_for(write_first, TO_BE, seq);",
          "1703:         job = write_head;",
          "1704:         write_head = job->next;",
          "1705:         twist(write_first, TO, write_head == NULL ? -1 : write_head->seq);",
          "1708:         more = job->more;",
          "1709:         len = job->in->len;",
          "1710:         drop_space(job->in);",
          "1711:         ulen += (unsigned long)len;",
          "1712:         clen += (unsigned long)(job->out->len);",
          "1715:         Trace((\"-- writing #%ld\", seq));",
          "1716:         writen(g.outd, job->out->buf, job->out->len);",
          "1717:         drop_space(job->out);",
          "1718:         Trace((\"-- wrote #%ld%s\", seq, more ? \"\" : \" (last)\"));",
          "1722:         possess(job->calc);",
          "1723:         wait_for(job->calc, TO_BE, 1);",
          "1724:         release(job->calc);",
          "1725:         check = COMB(check, job->check, len);",
          "1728:         free_lock(job->calc);",
          "1729:         FREE(job);",
          "1732:         seq++;",
          "1733:     } while (more);",
          "1736:     put_trailer(ulen, clen, check, head);",
          "1739:     possess(compress_have);",
          "1740:     assert(compress_head == NULL && peek_lock(compress_have) == 0);",
          "1741:     release(compress_have);",
          "1742:     possess(write_first);",
          "1743:     assert(write_head == NULL);",
          "1744:     twist(write_first, TO, -1);",
          "",
          "[Added Lines]",
          "1713:     try {",
          "1715:         Trace((\"-- write thread running\"));",
          "1716:         head = put_header();",
          "1719:         ulen = clen = 0;",
          "1720:         check = CHECK(0L, Z_NULL, 0);",
          "1721:         seq = 0;",
          "1722:         do {",
          "1724:             possess(write_first);",
          "1725:             wait_for(write_first, TO_BE, seq);",
          "1726:             job = write_head;",
          "1727:             write_head = job->next;",
          "1728:             twist(write_first, TO, write_head == NULL ? -1 : write_head->seq);",
          "1731:             more = job->more;",
          "1732:             len = job->in->len;",
          "1733:             drop_space(job->in);",
          "1734:             ulen += (unsigned long)len;",
          "1735:             clen += (unsigned long)(job->out->len);",
          "1738:             Trace((\"-- writing #%ld\", seq));",
          "1739:             writen(g.outd, job->out->buf, job->out->len);",
          "1740:             drop_space(job->out);",
          "1741:             Trace((\"-- wrote #%ld%s\", seq, more ? \"\" : \" (last)\"));",
          "1745:             possess(job->calc);",
          "1746:             wait_for(job->calc, TO_BE, 1);",
          "1747:             release(job->calc);",
          "1748:             check = COMB(check, job->check, len);",
          "1751:             free_lock(job->calc);",
          "1752:             FREE(job);",
          "1755:             seq++;",
          "1756:         } while (more);",
          "1759:         put_trailer(ulen, clen, check, head);",
          "1762:         possess(compress_have);",
          "1763:         assert(compress_head == NULL && peek_lock(compress_have) == 0);",
          "1764:         release(compress_have);",
          "1765:         possess(write_first);",
          "1766:         assert(write_head == NULL);",
          "1767:         twist(write_first, TO, -1);",
          "1768:     }",
          "1769:     catch (err) {",
          "1770:         THREADABORT(err);",
          "1771:     }",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1815:     left = 0;",
          "1816:     do {",
          "1821:         job->calc = new_lock(0);",
          "",
          "[Removed Lines]",
          "1818:         job = MALLOC(sizeof(struct job));",
          "1819:         if (job == NULL)",
          "1820:             bail(\"not enough memory\", \"\");",
          "",
          "[Added Lines]",
          "1845:         job = alloc(NULL, sizeof(struct job));",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "1935:         job->seq = seq;",
          "1936:         Trace((\"-- read #%ld%s\", seq, more ? \"\" : \" (last)\"));",
          "1937:         if (++seq < 1)",
          "1941:         if (cthreads < seq && cthreads < g.procs) {",
          "",
          "[Removed Lines]",
          "1938:             bail(\"input too long: \", g.inf);",
          "",
          "[Added Lines]",
          "1963:             throw(EOVERFLOW, \"overflow\");",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "2013:     if (strm == NULL) {",
          "2014:         out_size = g.block > MAXP2 ? MAXP2 : (unsigned)g.block;",
          "2020:         strm->zfree = ZFREE;",
          "2021:         strm->zalloc = ZALLOC;",
          "2022:         strm->opaque = OPAQUE;",
          "2026:     }",
          "",
          "[Removed Lines]",
          "2015:         if ((in = MALLOC(g.block + DICT)) == NULL ||",
          "2016:             (next = MALLOC(g.block + DICT)) == NULL ||",
          "2017:             (out = MALLOC(out_size)) == NULL ||",
          "2018:             (strm = MALLOC(sizeof(z_stream))) == NULL)",
          "2019:             bail(\"not enough memory\", \"\");",
          "2023:         if (deflateInit2(strm, 6, Z_DEFLATED, -15, 8, Z_DEFAULT_STRATEGY) !=",
          "2024:                          Z_OK)",
          "2025:             bail(\"not enough memory\", \"\");",
          "",
          "[Added Lines]",
          "2042:         in = alloc(NULL, g.block + DICT);",
          "2043:         next = alloc(NULL, g.block + DICT);",
          "2044:         out = alloc(NULL, out_size);",
          "2045:         strm = alloc(NULL, sizeof(z_stream));",
          "2049:         ret = deflateInit2(strm, 6, Z_DEFLATED, -15, 8, Z_DEFAULT_STRATEGY);",
          "2050:         if (ret == Z_MEM_ERROR)",
          "2051:             throw(ENOMEM, \"not enough memory\");",
          "2052:         if (ret != Z_OK)",
          "2053:             throw(EINVAL, \"internal error\");",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "2219: local void load_read(void *dummy)",
          "2220: {",
          "2221:     size_t len;",
          "2223:     (void)dummy;",
          "2225:     Trace((\"-- launched decompress read thread\"));",
          "2233:     Trace((\"-- exited decompress read thread\"));",
          "2234: }",
          "2235: #endif",
          "",
          "[Removed Lines]",
          "2226:     do {",
          "2227:         possess(g.load_state);",
          "2228:         wait_for(g.load_state, TO_BE, 1);",
          "2229:         g.in_len = len = readn(g.ind, g.in_which ? g.in_buf : g.in_buf2, BUF);",
          "2230:         Trace((\"-- decompress read thread read %lu bytes\", len));",
          "2231:         twist(g.load_state, TO, 0);",
          "2232:     } while (len == BUF);",
          "",
          "[Added Lines]",
          "2255:     try {",
          "2256:         do {",
          "2257:             possess(g.load_state);",
          "2258:             wait_for(g.load_state, TO_BE, 1);",
          "2259:             g.in_len = len = readn(g.ind, g.in_which ? g.in_buf : g.in_buf2,",
          "2260:                                    BUF);",
          "2261:             Trace((\"-- decompress read thread read %lu bytes\", len));",
          "2262:             twist(g.load_state, TO, 0);",
          "2263:         } while (len == BUF);",
          "2264:     }",
          "2265:     catch (err) {",
          "2266:         THREADABORT(err);",
          "2267:     }",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "2482:         fname = GET2();",
          "2483:         extra = GET2();",
          "2484:         if (save) {",
          "2488:             while (fname > g.in_left) {",
          "2489:                 memcpy(next, g.in_next, g.in_left);",
          "2490:                 fname -= g.in_left;",
          "",
          "[Removed Lines]",
          "2485:             char *next = g.hname = MALLOC(fname + 1);",
          "2486:             if (g.hname == NULL)",
          "2487:                 bail(\"not enough memory\", \"\");",
          "",
          "[Added Lines]",
          "2520:             char *next = g.hname = alloc(NULL, fname + 1);",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "2709:     if (method < 0) {",
          "2710:         RELEASE(g.hname);",
          "2711:         if (method != -1 && g.verbosity > 1)",
          "2713:         return;",
          "2714:     }",
          "",
          "[Removed Lines]",
          "2712:             complain(\"%s not a compressed file -- skipping\", g.inf);",
          "",
          "[Added Lines]",
          "2745:             complain(\"skipping: %s not a compressed file\", g.inf);",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "2762:         if (g.in_left < 8) {",
          "2764:             return;",
          "2765:         }",
          "",
          "[Removed Lines]",
          "2763:             complain(\"%s not a valid gzip file -- skipping\", g.inf);",
          "",
          "[Added Lines]",
          "2796:             complain(\"skipping: %s not a valid gzip file\", g.inf);",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "2780:         if (g.in_left < 8) {",
          "2781:             if (n + g.in_left < 8) {",
          "2783:                 return;",
          "2784:             }",
          "2785:             if (g.in_left) {",
          "",
          "[Removed Lines]",
          "2782:                 complain(\"%s not a valid gzip file -- skipping\", g.inf);",
          "",
          "[Added Lines]",
          "2815:                 complain(\"skipping: %s not a valid gzip file\", g.inf);",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "2793:         g.in_tot -= at + 8;",
          "2794:     }",
          "2795:     if (g.in_tot < 2) {",
          "2797:         return;",
          "2798:     }",
          "",
          "[Removed Lines]",
          "2796:         complain(\"%s not a valid gzip file -- skipping\", g.inf);",
          "",
          "[Added Lines]",
          "2829:         complain(\"skipping: %s not a valid gzip file\", g.inf);",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "2853: local void outb_write(void *dummy)",
          "2854: {",
          "2855:     size_t len;",
          "2857:     (void)dummy;",
          "2859:     Trace((\"-- launched decompress write thread\"));",
          "2869:     Trace((\"-- exited decompress write thread\"));",
          "2870: }",
          "",
          "[Removed Lines]",
          "2860:     do {",
          "2861:         possess(outb_write_more);",
          "2862:         wait_for(outb_write_more, TO_BE, 1);",
          "2863:         len = out_len;",
          "2864:         if (len && g.decode == 1)",
          "2865:             writen(g.outd, out_copy, len);",
          "2866:         Trace((\"-- decompress wrote %lu bytes\", len));",
          "2867:         twist(outb_write_more, TO, 0);",
          "2868:     } while (len);",
          "",
          "[Added Lines]",
          "2894:     try {",
          "2895:         do {",
          "2896:             possess(outb_write_more);",
          "2897:             wait_for(outb_write_more, TO_BE, 1);",
          "2898:             len = out_len;",
          "2899:             if (len && g.decode == 1)",
          "2900:                 writen(g.outd, out_copy, len);",
          "2901:             Trace((\"-- decompress wrote %lu bytes\", len));",
          "2902:             twist(outb_write_more, TO, 0);",
          "2903:         } while (len);",
          "2904:     }",
          "2905:     catch (err) {",
          "2906:         THREADABORT(err);",
          "2907:     }",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "2873: local void outb_check(void *dummy)",
          "2874: {",
          "2875:     size_t len;",
          "2877:     (void)dummy;",
          "2879:     Trace((\"-- launched decompress check thread\"));",
          "2888:     Trace((\"-- exited decompress check thread\"));",
          "2889: }",
          "2890: #endif",
          "",
          "[Removed Lines]",
          "2880:     do {",
          "2881:         possess(outb_check_more);",
          "2882:         wait_for(outb_check_more, TO_BE, 1);",
          "2883:         len = out_len;",
          "2884:         g.out_check = CHECK(g.out_check, out_copy, len);",
          "2885:         Trace((\"-- decompress checked %lu bytes\", len));",
          "2886:         twist(outb_check_more, TO, 0);",
          "2887:     } while (len);",
          "",
          "[Added Lines]",
          "2920:     try {",
          "2921:         do {",
          "2922:             possess(outb_check_more);",
          "2923:             wait_for(outb_check_more, TO_BE, 1);",
          "2924:             len = out_len;",
          "2925:             g.out_check = CHECK(g.out_check, out_copy, len);",
          "2926:             Trace((\"-- decompress checked %lu bytes\", len));",
          "2927:             twist(outb_check_more, TO, 0);",
          "2928:         } while (len);",
          "2929:     }",
          "2930:     catch (err) {",
          "2931:         THREADABORT(err);",
          "2932:     }",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "2972:         strm.zfree = ZFREE;",
          "2973:         strm.opaque = OPAQUE;",
          "2974:         ret = inflateBackInit(&strm, 15, out_buf);",
          "2975:         if (ret != Z_OK)",
          "2979:         strm.avail_in = g.in_left;",
          "2980:         strm.next_in = g.in_next;",
          "2981:         ret = inflateBack(&strm, inb, NULL, outb, NULL);",
          "2982:         if (ret != Z_STREAM_END)",
          "2984:         g.in_left = strm.avail_in;",
          "2985:         g.in_next = strm.next_in;",
          "",
          "[Removed Lines]",
          "2976:             bail(\"not enough memory\", \"\");",
          "2983:             bail(\"corrupted input -- invalid deflate data: \", g.inf);",
          "2986:         inflateBackEnd(&strm);",
          "",
          "[Added Lines]",
          "3020:         if (ret == Z_MEM_ERROR)",
          "3021:             throw(ENOMEM, \"not enough memory\");",
          "3023:             throw(EINVAL, \"internal error\");",
          "3029:         inflateBackEnd(&strm);",
          "3030:         if (ret == Z_DATA_ERROR)",
          "3031:             throw(EFTYPE, \"%s: corrupted -- invalid deflate data (%s)\",",
          "3032:                   g.inf, strm.msg);",
          "3033:         if (ret == Z_BUF_ERROR)",
          "3034:             throw(EFTYPE, \"%s: corrupted -- incomplete deflate data\", g.inf);",
          "3036:             throw(EINVAL, \"internal error\");",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "2997:                 g.zip_clen = GET4();",
          "2998:                 g.zip_ulen = GET4();",
          "2999:                 if (g.in_eof)",
          "3003:                 if (g.zip_crc != g.out_check) {",
          "3004:                     if (g.zip_crc != 0x08074b50UL || g.zip_clen != g.out_check)",
          "3006:                     g.zip_crc = g.zip_clen;",
          "3007:                     g.zip_clen = g.zip_ulen;",
          "3008:                     g.zip_ulen = GET4();",
          "",
          "[Removed Lines]",
          "3000:                     bail(\"corrupted zip entry -- missing trailer: \", g.inf);",
          "3005:                         bail(\"corrupted zip entry -- crc32 mismatch: \", g.inf);",
          "",
          "[Added Lines]",
          "3052:                     throw(EFTYPE, \"%s: corrupted entry -- missing trailer\",",
          "3053:                           g.inf);",
          "3058:                         throw(EFTYPE, \"%s: corrupted entry -- crc32 mismatch\",",
          "3059:                               g.inf);",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "3024:                     (void)GET4();",
          "3025:                 }",
          "3026:                 if (g.in_eof)",
          "3028:             }",
          "3029:             if (g.zip_clen != (clen & LOW32) ||",
          "3030:                 g.zip_ulen != (g.out_tot & LOW32))",
          "3032:             check = g.zip_crc;",
          "3033:         }",
          "",
          "[Removed Lines]",
          "3027:                     bail(\"corrupted zip entry -- missing trailer: \", g.inf);",
          "3031:                 bail(\"corrupted zip entry -- length mismatch: \", g.inf);",
          "",
          "[Added Lines]",
          "3081:                     throw(EFTYPE, \"%s: corrupted entry -- missing trailer\",",
          "3082:                           g.inf);",
          "3086:                 throw(EFTYPE, \"%s: corrupted entry -- length mismatch\",",
          "3087:                       g.inf);",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "3037:             check += (unsigned)(GET()) << 8;",
          "3038:             check += GET();",
          "3039:             if (g.in_eof)",
          "3041:             if (check != g.out_check)",
          "3043:         }",
          "3045:             check = GET4();",
          "3046:             len = GET4();",
          "3047:             if (g.in_eof)",
          "3049:             if (check != g.out_check)",
          "3051:             if (len != (g.out_tot & LOW32))",
          "3053:         }",
          "",
          "[Removed Lines]",
          "3040:                 bail(\"corrupted zlib stream -- missing trailer: \", g.inf);",
          "3042:                 bail(\"corrupted zlib stream -- adler32 mismatch: \", g.inf);",
          "3048:                 bail(\"corrupted gzip stream -- missing trailer: \", g.inf);",
          "3050:                 bail(\"corrupted gzip stream -- crc32 mismatch: \", g.inf);",
          "3052:                 bail(\"corrupted gzip stream -- length mismatch: \", g.inf);",
          "",
          "[Added Lines]",
          "3096:                 throw(EFTYPE, \"%s: corrupted -- missing trailer\", g.inf);",
          "3098:                 throw(EFTYPE, \"%s: corrupted -- adler32 mismatch\", g.inf);",
          "3104:                 throw(EFTYPE, \"%s: corrupted -- missing trailer\", g.inf);",
          "3106:                 throw(EFTYPE, \"%s: corrupted -- crc32 mismatch\", g.inf);",
          "3108:                 throw(EFTYPE, \"%s: corrupted -- length mismatch\", g.inf);",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "3069:         !g.list)",
          "3070:         cat();",
          "3071:     else if (was > 1 && get_header(0) != -5)",
          "3073:     else if ((was == 0 && ret != -1) || (was == 1 && (GET(), !g.in_eof)))",
          "3075: }",
          "",
          "[Removed Lines]",
          "3072:         complain(\"entries after the first in %s were ignored\", g.inf);",
          "3074:         complain(\"%s OK, has trailing junk which was ignored\", g.inf);",
          "",
          "[Added Lines]",
          "3128:         complain(\"warning: %s: entries after the first were ignored\", g.inf);",
          "3130:         complain(\"warning: %s: trailing junk was ignored\", g.inf);",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "3111:     g.out_tot = 0;",
          "3112:     if (NOMORE())",
          "3114:     flags = NEXT();",
          "3115:     if (flags & 0x60)",
          "3117:     max = flags & 0x1f;",
          "3118:     if (max < 9 || max > 16)",
          "3121:         max = 10;",
          "",
          "[Removed Lines]",
          "3113:         bail(\"lzw premature end: \", g.inf);",
          "3116:         bail(\"unknown lzw flags set: \", g.inf);",
          "3119:         bail(\"lzw bits out of range: \", g.inf);",
          "",
          "[Added Lines]",
          "3169:         throw(EFTYPE, \"%s: lzw premature end\", g.inf);",
          "3172:         throw(EFTYPE, \"%s: unknown lzw flags set\", g.inf);",
          "3175:         throw(EFTYPE, \"%s: lzw bits out of range\", g.inf);",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "3135:         return;",
          "3136:     buf = NEXT();",
          "3137:     if (NOMORE())",
          "3139:     buf += NEXT() << 8;",
          "3141:     buf >>= bits;",
          "3142:     left = 16 - bits;",
          "3143:     if (prev > 255)",
          "3146:     outcnt = 1;",
          "",
          "[Removed Lines]",
          "3144:         bail(\"invalid lzw code: \", g.inf);",
          "",
          "[Added Lines]",
          "3200:         throw(EFTYPE, \"%s: invalid lzw code\", g.inf);",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "3185:         left += 8;",
          "3186:         if (left < bits) {",
          "3187:             if (NOMORE())",
          "3189:             buf += (bits_t)(NEXT()) << left;",
          "3190:             left += 8;",
          "3191:         }",
          "",
          "[Removed Lines]",
          "3188:                 bail(\"lzw premature end: \", g.inf);",
          "",
          "[Added Lines]",
          "3244:                 throw(EFTYPE, \"%s: lzw premature end\", g.inf);",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "3229:                    code we drop through (prev) will be a valid index so that",
          "3231:                 if (code != end + 1 || prev > end)",
          "3233:                 match[stack++] = final;",
          "3234:                 code = prev;",
          "3235:             }",
          "",
          "[Removed Lines]",
          "3232:                     bail(\"invalid lzw code: \", g.inf);",
          "",
          "[Added Lines]",
          "3288:                     throw(EFTYPE, \"%s: invalid lzw code\", g.inf);",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "3363:             }",
          "3364: #ifdef EOVERFLOW",
          "3365:             if (errno == EOVERFLOW || errno == EFBIG)",
          "3368: #endif",
          "3369:             if (errno) {",
          "3370:                 g.inf[len] = 0;",
          "3372:                 return;",
          "3373:             }",
          "3374:             len = strlen(g.inf);",
          "",
          "[Removed Lines]",
          "3366:                 bail(g.inf,",
          "3367:                     \" too large -- not compiled with large file support\");",
          "3371:                 complain(\"%s does not exist -- skipping\", g.inf);",
          "",
          "[Added Lines]",
          "3423:                 throw(EFTYPE, \"%s too large -- \"",
          "3424:                       \"not compiled with large file support\", g.inf);",
          "3428:                 complain(\"skipping: %s does not exist\", g.inf);",
          "",
          "---------------",
          "--- Hunk 34 ---",
          "[Context before]",
          "3379:         if ((st.st_mode & S_IFMT) != S_IFREG &&",
          "3380:             (st.st_mode & S_IFMT) != S_IFLNK &&",
          "3381:             (st.st_mode & S_IFMT) != S_IFDIR) {",
          "3383:             return;",
          "3384:         }",
          "3385:         if ((st.st_mode & S_IFMT) == S_IFLNK && !g.force && !g.pipeout) {",
          "3387:             return;",
          "3388:         }",
          "3389:         if ((st.st_mode & S_IFMT) == S_IFDIR && !g.recurse) {",
          "3391:             return;",
          "3392:         }",
          "",
          "[Removed Lines]",
          "3382:             complain(\"%s is a special file or device -- skipping\", g.inf);",
          "3386:             complain(\"%s is a symbolic link -- skipping\", g.inf);",
          "3390:             complain(\"%s is a directory -- skipping\", g.inf);",
          "",
          "[Added Lines]",
          "3439:             complain(\"skipping: %s is a special file or device\", g.inf);",
          "3443:             complain(\"skipping: %s is a symbolic link\", g.inf);",
          "3447:             complain(\"skipping: %s is a directory\", g.inf);",
          "",
          "---------------",
          "--- Hunk 35 ---",
          "[Context before]",
          "3431:         if (!(g.force || g.list || g.decode) && len >= strlen(g.sufx) &&",
          "3432:                 strcmp(g.inf + len - strlen(g.sufx), g.sufx) == 0) {",
          "3434:             return;",
          "3435:         }",
          "",
          "[Removed Lines]",
          "3433:             complain(\"%s ends with %s -- skipping\", g.inf, g.sufx);",
          "",
          "[Added Lines]",
          "3490:             complain(\"skipping: %s ends with %s\", g.inf, g.sufx);",
          "",
          "---------------",
          "--- Hunk 36 ---",
          "[Context before]",
          "3438:         if (g.decode == 1 && !g.pipeout && !g.list) {",
          "3439:             int suf = compressed_suffix(g.inf);",
          "3440:             if (suf == 0) {",
          "3442:                          g.inf);",
          "3443:                 return;",
          "3444:             }",
          "",
          "[Removed Lines]",
          "3441:                 complain(\"%s does not have compressed suffix -- skipping\",",
          "",
          "[Added Lines]",
          "3498:                 complain(\"skipping: %s does not have compressed suffix\",",
          "",
          "---------------",
          "--- Hunk 37 ---",
          "[Context before]",
          "3449:         g.ind = open(g.inf, O_RDONLY, 0);",
          "3450:         if (g.ind < 0)",
          "3454:         g.name = g.headis & 1 ? justname(g.inf) : NULL;",
          "",
          "[Removed Lines]",
          "3451:             bail(\"read error on \", g.inf);",
          "",
          "[Added Lines]",
          "3508:             throw(errno, \"read error on %s (%s)\", g.inf, strerror(errno));",
          "",
          "---------------",
          "--- Hunk 38 ---",
          "[Context before]",
          "3469:             if (g.ind != 0)",
          "3470:                 close(g.ind);",
          "3471:             if (method != -1)",
          "3474:                          g.inf);",
          "3475:             return;",
          "3476:         }",
          "3479:         if (g.decode == 2) {",
          "3487:                 }",
          "3488:             }",
          "3489:             RELEASE(g.hname);",
          "3490:             if (g.ind != 0)",
          "3491:                 close(g.ind);",
          "",
          "[Removed Lines]",
          "3472:                 complain(method < 0 ? \"%s is not compressed -- skipping\" :",
          "3473:                          \"%s has unknown compression method -- skipping\",",
          "3480:             if (method == 8)",
          "3481:                 infchk();",
          "3482:             else {",
          "3483:                 unlzw();",
          "3484:                 if (g.list) {",
          "3485:                     g.in_tot -= 3;",
          "3486:                     show_info(method, 0, g.out_tot, 0);",
          "",
          "[Added Lines]",
          "3529:                 complain(method < 0 ? \"skipping: %s is not compressed\" :",
          "3530:                          \"skipping: %s has unknown compression method\",",
          "3537:             try {",
          "3538:                 if (method == 8)",
          "3539:                     infchk();",
          "3540:                 else {",
          "3541:                     unlzw();",
          "3542:                     if (g.list) {",
          "3543:                         g.in_tot -= 3;",
          "3544:                         show_info(method, 0, g.out_tot, 0);",
          "3545:                     }",
          "3548:             catch (err) {",
          "3549:                 if (err.code != EFTYPE)",
          "3550:                     punt(err);",
          "3551:                 complain(\"skipping: %s\", err.why);",
          "3552:                 drop(err);",
          "3553:             }",
          "",
          "---------------",
          "--- Hunk 39 ---",
          "[Context before]",
          "3506:     if (path == NULL || g.pipeout) {",
          "3511:         strcpy(g.outf, \"<stdout>\");",
          "3512:         g.outd = 1;",
          "3513:         if (!g.decode && !g.force && isatty(g.outd))",
          "3516:     }",
          "3517:     else {",
          "3518:         char *to = g.inf, *sufx = \"\";",
          "",
          "[Removed Lines]",
          "3508:         g.outf = MALLOC(strlen(\"<stdout>\") + 1);",
          "3509:         if (g.outf == NULL)",
          "3510:             bail(\"not enough memory\", \"\");",
          "3514:             bail(\"trying to write compressed data to a terminal\",",
          "3515:                  \" (use -f to force)\");",
          "",
          "[Added Lines]",
          "3573:         g.outf = alloc(NULL, strlen(\"<stdout>\") + 1);",
          "3577:             throw(EINVAL, \"trying to write compressed data to a terminal\"",
          "3578:                           \" (use -f to force)\");",
          "",
          "---------------",
          "--- Hunk 40 ---",
          "[Context before]",
          "3536:             sufx = g.sufx;",
          "3542:         memcpy(g.outf, g.inf, pre);",
          "3543:         memcpy(g.outf + pre, to, len);",
          "3544:         strcpy(g.outf + pre + len, sufx);",
          "",
          "[Removed Lines]",
          "3539:         g.outf = MALLOC(pre + len + strlen(sufx) + 1);",
          "3540:         if (g.outf == NULL)",
          "3541:             bail(\"not enough memory\", \"\");",
          "",
          "[Added Lines]",
          "3602:         g.outf = alloc(NULL, pre + len + strlen(sufx) + 1);",
          "",
          "---------------",
          "--- Hunk 41 ---",
          "[Context before]",
          "3566:         if (g.outd < 0 && errno == EEXIST) {",
          "3568:             RELEASE(g.outf);",
          "3569:             RELEASE(g.hname);",
          "3570:             if (g.ind != 0)",
          "",
          "[Removed Lines]",
          "3567:             complain(\"%s exists -- skipping\", g.outf);",
          "",
          "[Added Lines]",
          "3628:             complain(\"skipping: %s exists\", g.outf);",
          "",
          "---------------",
          "--- Hunk 42 ---",
          "[Context before]",
          "3576:         if (g.outd < 0)",
          "3578:     }",
          "3579:     SET_BINARY_MODE(g.outd);",
          "3580:     RELEASE(g.hname);",
          "",
          "[Removed Lines]",
          "3577:             bail(\"write error on \", g.outf);",
          "",
          "[Added Lines]",
          "3638:             throw(errno, \"write error on %s (%s)\", g.outf, strerror(errno));",
          "",
          "---------------",
          "--- Hunk 43 ---",
          "[Context before]",
          "3583:     if (g.verbosity > 1)",
          "3584:         fprintf(stderr, \"%s to %s \", g.inf, g.outf);",
          "3585:     if (g.decode) {",
          "3592:     }",
          "3593: #ifndef NOTHREAD",
          "3594:     else if (g.procs > 1)",
          "",
          "[Removed Lines]",
          "3586:         if (method == 8)",
          "3587:             infchk();",
          "3588:         else if (method == 257)",
          "3589:             unlzw();",
          "3590:         else",
          "3591:             cat();",
          "",
          "[Added Lines]",
          "3647:         try {",
          "3648:             if (method == 8)",
          "3649:                 infchk();",
          "3650:             else if (method == 257)",
          "3651:                 unlzw();",
          "3652:             else",
          "3653:                 cat();",
          "3654:         }",
          "3655:         catch (err) {",
          "3656:             if (err.code != EFTYPE)",
          "3657:                 punt(err);",
          "3658:             complain(\"skipping: %s\", err.why);",
          "3659:             drop(err);",
          "3660:         }",
          "",
          "---------------",
          "--- Hunk 44 ---",
          "[Context before]",
          "3606:         close(g.ind);",
          "3607:     if (g.outd != 1) {",
          "3608:         if (close(g.outd))",
          "3611:         if (g.ind != 0) {",
          "3612:             copymeta(g.inf, g.outf);",
          "",
          "[Removed Lines]",
          "3609:             bail(\"write error on \", g.outf);",
          "",
          "[Added Lines]",
          "3678:             throw(errno, \"write error on %s (%s)\", g.outf, strerror(errno));",
          "",
          "---------------",
          "--- Hunk 45 ---",
          "[Context before]",
          "3768:     size_t val = 0;",
          "3770:     if (*str == 0)",
          "3772:     do {",
          "3773:         if (*str < '0' || *str > '9' ||",
          "3774:             (val && ((~(size_t)0) - (*str - '0')) / val < 10))",
          "3776:         val = val * 10 + (*str - '0');",
          "3777:     } while (*++str);",
          "3778:     return val;",
          "",
          "[Removed Lines]",
          "3771:         bail(\"internal error: empty parameter\", \"\");",
          "3775:             bail(\"invalid numeric parameter: \", arg);",
          "",
          "[Added Lines]",
          "3840:         throw(EINVAL, \"internal error: empty parameter\");",
          "3844:             throw(EINVAL, \"invalid numeric parameter: %s\", arg);",
          "",
          "---------------",
          "--- Hunk 46 ---",
          "[Context before]",
          "3788:     if (get && (arg == NULL || *arg == '-')) {",
          "3789:         bad[1] = \"bpSIM\"[get - 1];",
          "3791:     }",
          "3792:     if (arg == NULL)",
          "3793:         return 0;",
          "",
          "[Removed Lines]",
          "3790:         bail(\"missing parameter after \", bad);",
          "",
          "[Added Lines]",
          "3859:         throw(EINVAL, \"missing parameter after %s\", bad);",
          "",
          "---------------",
          "--- Hunk 47 ---",
          "[Context before]",
          "3809:                     break;",
          "3810:                 }",
          "3811:             if (j < 0)",
          "3813:         }",
          "",
          "[Removed Lines]",
          "3812:                 bail(\"invalid option: \", arg - 2);",
          "",
          "[Added Lines]",
          "3881:                 throw(EINVAL, \"invalid option: %s\", arg - 2);",
          "",
          "---------------",
          "--- Hunk 48 ---",
          "[Context before]",
          "3819:             if (get) {",
          "3820:                 if (get == 3)",
          "3823:             }",
          "",
          "[Removed Lines]",
          "3821:                     bail(\"invalid usage: -s must be followed by space\", \"\");",
          "",
          "[Added Lines]",
          "3890:                     throw(EINVAL, \"invalid usage: \"",
          "3891:                                   \"-s must be followed by space\");",
          "",
          "---------------",
          "--- Hunk 49 ---",
          "[Context before]",
          "3830:                 g.level = *arg - '0';",
          "3831:                 while (arg[1] >= '0' && arg[1] <= '9') {",
          "3832:                     if (g.level && (INT_MAX - (arg[1] - '0')) / g.level < 10)",
          "3834:                     g.level = g.level * 10 + *++arg - '0';",
          "3835:                 }",
          "3836:                 if (g.level == 10 || g.level > 11)",
          "3838:                 new_opts();",
          "3839:                 break;",
          "3840:             case 'F':  g.zopts.blocksplittinglast = 1;  break;",
          "",
          "[Removed Lines]",
          "3833:                         bail(\"only levels 0..9 and 11 are allowed\", \"\");",
          "3837:                     bail(\"only levels 0..9 and 11 are allowed\", \"\");",
          "",
          "[Added Lines]",
          "3903:                         throw(EINVAL, \"only levels 0..9 and 11 are allowed\");",
          "3907:                     throw(EINVAL, \"only levels 0..9 and 11 are allowed\");",
          "",
          "---------------",
          "--- Hunk 50 ---",
          "[Context before]",
          "3857:             case 'T':  g.headis &= ~0xa;  break;",
          "3858:             case 'V':  fputs(VERSION, stderr);  exit(0);",
          "3859:             case 'Z':",
          "3861:             case 'a':",
          "3863:             case 'b':  get = 1;  break;",
          "3864:             case 'c':  g.pipeout = 1;  break;",
          "3865:             case 'd':  if (!g.decode) g.headis >>= 2;  g.decode = 1;  break;",
          "",
          "[Removed Lines]",
          "3860:                 bail(\"invalid option: LZW output not supported: \", bad);",
          "3862:                 bail(\"invalid option: ascii conversion not supported: \", bad);",
          "",
          "[Added Lines]",
          "3930:                 throw(EINVAL, \"invalid option: LZW output not supported: %s\",",
          "3931:                       bad);",
          "3933:                 throw(EINVAL, \"invalid option: no ascii conversion: %s\",",
          "3934:                       bad);",
          "",
          "---------------",
          "--- Hunk 51 ---",
          "[Context before]",
          "3876:             case 'v':  g.verbosity++;  break;",
          "3877:             case 'z':  g.form = 1;  g.sufx = \".zz\";  break;",
          "3878:             default:",
          "3880:             }",
          "3881:         } while (*++arg);",
          "3882:         if (*arg == 0)",
          "",
          "[Removed Lines]",
          "3879:                 bail(\"invalid option: \", bad);",
          "",
          "[Added Lines]",
          "3951:                 throw(EINVAL, \"invalid option: %s\", bad);",
          "",
          "---------------",
          "--- Hunk 52 ---",
          "[Context before]",
          "3891:             n = num(arg);",
          "3893:             if (g.block < DICT)",
          "3895:             if (n != g.block >> 10 ||",
          "3896:                 OUTPOOL(g.block) < g.block ||",
          "3897:                 (ssize_t)OUTPOOL(g.block) < 0 ||",
          "3900:             new_opts();",
          "3901:         }",
          "3902:         else if (get == 2) {",
          "3903:             n = num(arg);",
          "3905:             if (g.procs < 1)",
          "3907:             if ((size_t)g.procs != n || INBUFS(g.procs) < 1)",
          "3909: #ifdef NOTHREAD",
          "3910:             if (g.procs > 1)",
          "3912: #endif",
          "3913:             new_opts();",
          "3914:         }",
          "",
          "[Removed Lines]",
          "3894:                 bail(\"block size too small (must be >= 32K)\", \"\");",
          "3899:                 bail(\"block size too large: \", arg);",
          "3906:                 bail(\"invalid number of processes: \", arg);",
          "3908:                 bail(\"too many processes: \", arg);",
          "3911:                 bail(\"compiled without threads\", \"\");",
          "",
          "[Added Lines]",
          "3966:                 throw(EINVAL, \"block size too small (must be >= 32K)\");",
          "3971:                 throw(EINVAL, \"block size too large: %s\", arg);",
          "3978:                 throw(EINVAL, \"invalid number of processes: %s\", arg);",
          "3980:                 throw(EINVAL, \"too many processes: %s\", arg);",
          "3983:                 throw(EINVAL, \"compiled without threads\");",
          "",
          "---------------",
          "--- Hunk 53 ---",
          "[Context before]",
          "3926:     return 1;",
          "3927: }",
          "3931: {",
          "3938: }",
          "3943: int main(int argc, char **argv)",
          "3944: {",
          "3964: #ifndef NOTHREAD",
          "3967: #endif",
          "3968: #ifdef DEBUG",
          "3971: #endif",
          "3990:         }",
          "4008:         }",
          "4035:         }",
          "4042:         }",
          "4053:     log_dump();",
          "4054:     return 0;",
          "4055: }",
          "",
          "[Removed Lines]",
          "3930: local void cut_short(int sig)",
          "3932:     (void)sig;",
          "3933:     Trace((\"termination by user\"));",
          "3934:     if (g.outd != -1 && g.outf != NULL)",
          "3935:         unlink(g.outf);",
          "3936:     log_dump();",
          "3937:     _exit(1);",
          "3941:    least two in order to provide a dictionary in one work unit for the other",
          "3951:     g.inf = NULL;",
          "3952:     g.inz = 0;",
          "3953:     g.outf = NULL;",
          "3954:     g.first = 1;",
          "3955:     g.hname = NULL;",
          "3958:     p = strrchr(argv[0], '/');",
          "3959:     p = p == NULL ? argv[0] : p + 1;",
          "3960:     g.prog = *p ? p : \"pigz\";",
          "3963:     signal(SIGINT, cut_short);",
          "3974:     defaults();",
          "3977:     opts = getenv(\"GZIP\");",
          "3978:     if (opts != NULL) {",
          "3979:         while (*opts) {",
          "3980:             while (*opts == ' ' || *opts == '\\t')",
          "3981:                 opts++;",
          "3982:             p = opts;",
          "3983:             while (*p && *p != ' ' && *p != '\\t')",
          "3984:                 p++;",
          "3985:             n = *p;",
          "3987:             if (option(opts))",
          "3988:                 bail(\"cannot provide files in GZIP environment variable\", \"\");",
          "3989:             opts = p + (n ? 1 : 0);",
          "3991:         option(NULL);",
          "3992:     }",
          "3995:     opts = getenv(\"PIGZ\");",
          "3996:     if (opts != NULL) {",
          "3997:         while (*opts) {",
          "3998:             while (*opts == ' ' || *opts == '\\t')",
          "3999:                 opts++;",
          "4000:             p = opts;",
          "4001:             while (*p && *p != ' ' && *p != '\\t')",
          "4002:                 p++;",
          "4003:             n = *p;",
          "4005:             if (option(opts))",
          "4006:                 bail(\"cannot provide files in PIGZ environment variable\", \"\");",
          "4007:             opts = p + (n ? 1 : 0);",
          "4009:         option(NULL);",
          "4010:     }",
          "4013:     if (strcmp(g.prog, \"unpigz\") == 0 || strcmp(g.prog, \"gunzip\") == 0) {",
          "4014:         if (!g.decode)",
          "4015:             g.headis >>= 2;",
          "4016:         g.decode = 1;",
          "4017:     }",
          "4018:     if ((n = strlen(g.prog)) > 2 && strcmp(g.prog + n - 3, \"cat\") == 0) {",
          "4019:         if (!g.decode)",
          "4020:             g.headis >>= 2;",
          "4021:         g.decode = 1;",
          "4022:         g.pipeout = 1;",
          "4023:     }",
          "4026:     if (argc < 2 && isatty(g.decode ? 0 : 1))",
          "4027:         help();",
          "4030:     done = noop = 0;",
          "4031:     for (n = 1; n < argc; n++)",
          "4032:         if (noop == 0 && strcmp(argv[n], \"--\") == 0) {",
          "4033:             noop = 1;",
          "4034:             option(NULL);",
          "4037:             if (done == 1 && g.pipeout && !g.decode && !g.list && g.form > 1)",
          "4038:                 complain(\"warning: output will be concatenated zip files -- \"",
          "4039:                          \"will not be able to extract\");",
          "4040:             process(strcmp(argv[n], \"-\") ? argv[n] : NULL);",
          "4041:             done++;",
          "4043:     option(NULL);",
          "4046:     if (done == 0)",
          "4047:         process(NULL);",
          "4050:     RELEASE(g.inf);",
          "4051:     g.inz = 0;",
          "4052:     new_opts();",
          "",
          "[Added Lines]",
          "4001: #ifndef NOTHREAD",
          "4003: local void cut_yarn(int err)",
          "4005:     throw(err, err == ENOMEM ? \"not enough memory\" : \"internal threads error\");",
          "4007: #endif",
          "4018:     try {",
          "4020:         g.inf = NULL;",
          "4021:         g.inz = 0;",
          "4022:         g.outf = NULL;",
          "4023:         g.first = 1;",
          "4024:         g.hname = NULL;",
          "4027:         p = strrchr(argv[0], '/');",
          "4028:         p = p == NULL ? argv[0] : p + 1;",
          "4029:         g.prog = *p ? p : \"pigz\";",
          "4032:         signal(SIGINT, cut_short);",
          "4043:         defaults();",
          "4046:         opts = getenv(\"GZIP\");",
          "4047:         if (opts != NULL) {",
          "4048:             while (*opts) {",
          "4049:                 while (*opts == ' ' || *opts == '\\t')",
          "4050:                     opts++;",
          "4051:                 p = opts;",
          "4052:                 while (*p && *p != ' ' && *p != '\\t')",
          "4053:                     p++;",
          "4054:                 n = *p;",
          "4056:                 if (option(opts))",
          "4057:                     throw(EINVAL, \"cannot provide files in \"",
          "4058:                                   \"GZIP environment variable\");",
          "4059:                 opts = p + (n ? 1 : 0);",
          "4060:             }",
          "4061:             option(NULL);",
          "4065:         opts = getenv(\"PIGZ\");",
          "4066:         if (opts != NULL) {",
          "4067:             while (*opts) {",
          "4068:                 while (*opts == ' ' || *opts == '\\t')",
          "4069:                     opts++;",
          "4070:                 p = opts;",
          "4071:                 while (*p && *p != ' ' && *p != '\\t')",
          "4072:                     p++;",
          "4073:                 n = *p;",
          "4075:                 if (option(opts))",
          "4076:                     throw(EINVAL, \"cannot provide files in \"",
          "4077:                                   \"PIGZ environment variable\");",
          "4078:                 opts = p + (n ? 1 : 0);",
          "4079:             }",
          "4080:             option(NULL);",
          "4084:         if (strcmp(g.prog, \"unpigz\") == 0 || strcmp(g.prog, \"gunzip\") == 0) {",
          "4085:             if (!g.decode)",
          "4086:                 g.headis >>= 2;",
          "4087:             g.decode = 1;",
          "4089:         if ((n = strlen(g.prog)) > 2 && strcmp(g.prog + n - 3, \"cat\") == 0) {",
          "4090:             if (!g.decode)",
          "4091:                 g.headis >>= 2;",
          "4092:             g.decode = 1;",
          "4093:             g.pipeout = 1;",
          "4097:         if (argc < 2 && isatty(g.decode ? 0 : 1))",
          "4098:             help();",
          "4101:         done = noop = 0;",
          "4102:         for (n = 1; n < argc; n++)",
          "4104:             if (noop == 0 && strcmp(argv[n], \"--\") == 0) {",
          "4105:                 noop = 1;",
          "4106:                 option(NULL);",
          "4107:             }",
          "4109:             else if (noop || option(argv[n])) {",
          "4111:                 if (done == 1 && g.pipeout && !g.decode && !g.list &&",
          "4112:                     g.form > 1)",
          "4113:                     complain(\"warning: output will be concatenated zip files\"",
          "4114:                              \" -- %s will not be able to extract\", g.prog);",
          "4115:                 process(strcmp(argv[n], \"-\") ? argv[n] : NULL);",
          "4116:                 done++;",
          "4117:             }",
          "4118:         option(NULL);",
          "4121:         if (done == 0)",
          "4122:             process(NULL);",
          "4123:     }",
          "4124:     always {",
          "4126:         RELEASE(g.inf);",
          "4127:         g.inz = 0;",
          "4128:         new_opts();",
          "4129:     }",
          "4130:     catch (err) {",
          "4131:         THREADABORT(err);",
          "4132:     }",
          "",
          "---------------"
        ],
        "try.c||try.c": [
          "File: try.c -> try.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "8:    and the functions needed by throw().  The pointer is thread-unique if",
          "11: #include \"try.h\"",
          "12: #include <stdio.h>",
          "13: #include <string.h>",
          "14: #include <stdarg.h>",
          "18: #ifdef PTHREAD_ONCE_INIT",
          "19:     pthread_key_t try_key_;",
          "20:     static pthread_once_t try_once_ = PTHREAD_ONCE_INIT;",
          "21:     static void try_create_(void)",
          "22:     {",
          "23:         int ret = pthread_key_create(&try_key_, NULL);",
          "24:         assert(ret == 0 && \"try: pthread_key_create() failed\");",
          "25:     }",
          "26:     void try_setup_(void)",
          "27:     {",
          "28:         int ret = pthread_once(&try_once_, try_create_);",
          "29:         assert(ret == 0 && \"try: pthread_once() failed\");",
          "30:     }",
          "32:     try_t_ *try_stack_ = NULL;",
          "36:    second argument can be a NULL.  The throw() macro is permitted to have one",
          "38: void try_throw_(int code, char *fmt, ...)",
          "39: {",
          "41:     try_setup_();",
          "42:     assert(try_stack_ != NULL && \"try: naked throw\");",
          "43:     try_stack_->ball.code = code;",
          "44:     try_stack_->ball.free = 0;",
          "45:     try_stack_->ball.why = fmt;",
          "48:        commands, process them with the subsequent arguments of throw, saving",
          "49:        the result in allocated memory -- this if statement and clause must be",
          "50:        updated for a different interpretation of the throw() arguments and",
          "52:     if (fmt != NULL && strchr(fmt, '%') != NULL) {",
          "53:         char *why, nul[1];",
          "54:         size_t len;",
          "55:         va_list ap1, ap2;",
          "57:         va_start(ap1, fmt);",
          "58:         va_copy(ap2, ap1);",
          "59:         len = vsnprintf(nul, 1, fmt, ap1);",
          "60:         va_end(ap1);",
          "61:         why = malloc(len + 1);",
          "62:         if (why == NULL)",
          "63:             try_stack_->ball.why = \"try: out of memory\";",
          "64:         else {",
          "65:             vsnprintf(why, len + 1, fmt, ap2);",
          "66:             va_end(ap2);",
          "67:             try_stack_->ball.free = 1;",
          "68:             try_stack_->ball.why = why;",
          "69:         }",
          "70:     }",
          "73:     longjmp(try_stack_->env, 2);",
          "74: }",
          "",
          "---------------"
        ],
        "try.h||try.h": [
          "File: try.h -> try.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2:   Copyright (C) 2013, 2015 Mark Adler",
          "3:   Version 1.2  19 January 2015",
          "5:   This software is provided 'as-is', without any express or implied",
          "6:   warranty.  In no event will the author be held liable for any damages",
          "7:   arising from the use of this software.",
          "9:   Permission is granted to anyone to use this software for any purpose,",
          "10:   including commercial applications, and to alter it and redistribute it",
          "11:   freely, subject to the following restrictions:",
          "13:   1. The origin of this software must not be misrepresented; you must not",
          "14:      claim that you wrote the original software. If you use this software",
          "15:      in a product, an acknowledgment in the product documentation would be",
          "16:      appreciated but is not required.",
          "17:   2. Altered source versions must be plainly marked as such, and must not be",
          "18:      misrepresented as being the original software.",
          "19:   3. This notice may not be removed or altered from any source distribution.",
          "21:   Mark Adler    madler@alumni.caltech.edu",
          "25:     Version History",
          "26:     1.0    7 Jan 2013   - First version",
          "27:     1.1    2 Nov 2013   - Use variadic macros and functions instead of partial",
          "28:                           structure assignment, allowing arbitrary arguments",
          "29:                           to printf()",
          "30:     1.2   19 Jan 2015   - Obey setjmp() invocation limits from C standard",
          "34:    compile and link try.c.  If pthread threads are used, then there must be an",
          "35:    #include <pthread.h> in try.h to make the exception handling thread-safe.",
          "36:    (Uncomment the include below.)  If threads other than pthread are being",
          "37:    used, then try.h and try.c must be modified to use that environment's",
          "38:    thread-local storage for the try_stack_ pointer.  try.h and try.c assume",
          "39:    that the compiler and library conform to the C99 standard, at least with",
          "43:    try.h provides a try / catch / throw exception handler, which allows",
          "44:    catching exceptions across any number of levels of function calls.  try",
          "45:    blocks can be nested as desired, with a throw going to the end of the",
          "46:    innermost enclosing try, passing the thrown information to the associated",
          "47:    catch block.  A global try stack is used, to avoid having to pass exception",
          "48:    handler information through all of the functions down to the invocations of",
          "49:    throw.  The try stack is thread-unique if requested by uncommenting the",
          "50:    pthread.h include below.  In addition to the macros try, catch, and throw,",
          "51:    the macros always, retry, punt, and drop, and the type ball_t are created.",
          "52:    All other symbols are of the form try_*_ or TRY_*_, where the final",
          "53:    underscore should avoid conflicts with application symbols. The eight",
          "54:    exposed names can be changed easily in #defines below.",
          "56:    A try block encloses code that may throw an exception with the throw()",
          "57:    macro, either directly in the try block or in any function called directly",
          "58:    or indirectly from the try block.  throw() must have at least one argument,",
          "59:    which is an integer.  The try block is followed by a catch block whose code",
          "60:    will be executed when throw() is called with a non-zero first argument.  If",
          "61:    the first argument of throw() is zero, then execution continues after the",
          "62:    catch block.  If the try block completes normally, with no throw() being",
          "63:    called, then execution continues normally after the catch block.",
          "65:    There can be only one catch block.  catch has one argument which must be a",
          "66:    ball_t type variable declared in the current function or block containing",
          "67:    the try and catch.  That variable is loaded with the information sent by the",
          "68:    throw() for use in the catch block.",
          "70:    throw() may optionally include more information that is passed to the catch",
          "71:    block in the ball_t structure.  throw() can have one or more arguments,",
          "72:    where the first (possibly only) argument is an integer code.  The second",
          "73:    argument can be a pointer, which will be replaced by NULL in the ball_t",
          "74:    structure if not provided.  The implementation of throw() in try.c assumes",
          "75:    that if the second argument is present and is not NULL, that it is a string.",
          "76:    If that string has any percent (%) signs in it, then throw() will run that",
          "77:    string through vsnprintf() with any other arguments provided after the",
          "78:    string in the throw() invocation, and save the resulting formatted string in",
          "79:    the ball_t structure.  Information on whether or not the string was",
          "80:    allocated is also maintained in the ball_t structure.",
          "82:    throw() in try.c can be modified to not assume that the second argument is a",
          "83:    string.  For example, an application may want to assume instead that the",
          "84:    second argument is a pointer to a set of information for use in the catch",
          "85:    block.",
          "87:    The catch block may conditionally do a punt(), where the argument of punt()",
          "88:    is the argument of catch.  This passes the exception on to the next",
          "89:    enclosing try/catch handler.",
          "91:    If a catch block does not always end with a punt(), it should contain a",
          "92:    drop(), where the argument of drop() is the argument of catch.  This frees",
          "93:    the allocated string made if vsnprintf() was used by throw() to generate the",
          "94:    string.  If printf() format strings are never used, then drop() is not",
          "95:    required.",
          "97:    An always block may be placed between the try and catch block.  The",
          "98:    statements in that block will be executed regardless of whether or not the",
          "99:    try block completed normally.  As indicated by the ordering, the always",
          "100:    block will be executed before the catch block.  This block is not named",
          "101:    \"finally\", since it is different from the finally block in other languages",
          "102:    which is executed after the catch block.",
          "104:    A naked break or continue in a try or always block will go directly to the",
          "105:    end of that block.",
          "107:    A retry from the try block or from any function called from the try block at",
          "108:    any level of nesting will restart the try block from the beginning.",
          "110:    try is thread-safe when compiled with pthread.h.  A throw() in a thread can",
          "111:    only be caught in the same thread.  If a throw() is attempted from a thread",
          "112:    without an enclosing try in that thread, even if in another thread there is",
          "113:    a try around the pthread_create() that spawned this thread, then the throw",
          "114:    will fail on an assert.  Each thread has its own thread-unique try stack,",
          "115:    which starts off empty.",
          "117:    If an intermediate function does not have a need for operations in a catch",
          "118:    block other than punt, and does not need an always block, then that function",
          "119:    does not need a try block.  \"try { block } catch (err) { punt(err); }\" is",
          "120:    the same as just \"block\".  More precisely, it's equivalent to \"do { block }",
          "121:    while (0);\", which replicates the behavior of a naked break or continue in a",
          "122:    block when it follows try.  throw() can be used from a function that has no",
          "123:    try.  All that is necessary is that there is a try somewhere up the function",
          "124:    chain that called the current function in the current thread.",
          "126:    There must not be a return in any try block, nor a goto in any try block",
          "127:    that leaves that block.  The always block does not catch a return from the",
          "128:    try block.  There is no check or protection for an improper use of return or",
          "129:    goto.  It is up to the user to assure that this doesn't happen. If it does",
          "130:    happen, then the reference to the current try block is left on the try",
          "131:    stack, and the next throw which is supposed to go to an enclosing try would",
          "132:    instead go to this try, possibly after the enclosing function has returned.",
          "133:    Mayhem will then ensue.  This may be caught by the longjmp() implementation,",
          "134:    which would report \"longjmp botch\" and then abort.",
          "136:    Any automatic storage variables that are modified in the try block and used",
          "137:    in the catch or always block must be declared volatile.  Otherwise their",
          "138:    value in the catch or always block is indeterminate.",
          "140:    Any statements between try and always, between try and catch if there is no",
          "141:    always, or between always and catch are part of those respective try or",
          "142:    always blocks.  Use of { } to enclose those blocks is optional, but { }",
          "143:    should be used anyway for clarity, style, and to inform smart source editors",
          "144:    that the enclosed code is to be indented.  Enclosing the catch block with {",
          "145:    } is not optional if there is more than one statement in the block.",
          "146:    However, even if there is just one statement in the catch block, it should",
          "147:    be enclosed in { } anyway for style and editing convenience.",
          "149:    The contents of the ball_t structure after the first element (int code) can",
          "150:    be customized for the application.  If ball_t is customized, then the code",
          "151:    in try.c should be updated accordingly.  If there is no memory allocation in",
          "152:    throw(), then drop() can be eliminated.",
          "154:    Example usage:",
          "156:     ball_t err;",
          "157:     volatile char *temp = NULL;",
          "158:     try {",
          "159:         ... do something ...",
          "160:         if (ret == -1)",
          "161:             throw(1, \"bad thing happened to %s\\n\", me);",
          "162:         temp = malloc(sizeof(me) + 1);",
          "163:         if (temp == NULL)",
          "164:             throw(2, \"out of memory\");",
          "165:         ... do more ...",
          "166:         if (ret == -1)",
          "167:             throw(3, \"worse thing happened to %s\\n\", temp);",
          "168:         ... some more code ...",
          "169:     }",
          "170:     always {",
          "171:         free(temp);",
          "172:     }",
          "173:     catch (err) {",
          "174:         fputs(err.why, stderr);",
          "175:         drop(err);",
          "176:         return err.code;",
          "177:     }",
          "178:     ... end up here if nothing bad happened ...",
          "181:    More involved example:",
          "183:     void check_part(void)",
          "184:     {",
          "185:         ball_t err;",
          "187:         try {",
          "188:             ...",
          "189:             if (part == bad1)",
          "190:                 throw(1);",
          "191:             ...",
          "192:             if (part == bad2)",
          "193:                 throw(1);",
          "194:             ...",
          "195:         }",
          "196:         catch (err) {",
          "197:             drop(err);",
          "198:             throw(3, \"part was bad\");",
          "199:         }",
          "200:     }",
          "202:     void check_input(void)",
          "203:     {",
          "204:         ...",
          "205:         if (input == wrong)",
          "206:             throw(4, \"input was wrong\");",
          "207:         ...",
          "208:         if (input == stupid)",
          "209:             throw(5, \"input was stupid\");",
          "210:         ...",
          "211:         check_part();",
          "212:         ...",
          "213:     }",
          "215:     void *build_something(void)",
          "216:     {",
          "217:         ball_t err;",
          "218:         volatile void *thing;",
          "219:         try {",
          "220:             thing = malloc(sizeof(struct thing));",
          "221:             ... build up thing ...",
          "222:             check_input();",
          "223:             ... finish building it ...",
          "224:         }",
          "225:         catch (err) {",
          "226:             free(thing);",
          "227:             punt(err);",
          "228:         }",
          "229:         return thing;",
          "230:     }",
          "232:     int grand_central(void)",
          "233:     {",
          "234:         ball_t err;",
          "235:         void *thing;",
          "236:         try {",
          "237:             thing = build_something();",
          "238:         }",
          "239:         catch (err) {",
          "240:             fputs(err.why, stderr);",
          "241:             drop(err);",
          "242:             return err.code;",
          "243:         }",
          "244:         ... use thing ...",
          "245:         free(thing);",
          "246:         return 0;",
          "247:     }",
          "251: #ifndef _TRY_H",
          "252: #define _TRY_H",
          "254: #include <stdlib.h>",
          "255: #include <string.h>",
          "256: #include <assert.h>",
          "257: #include <setjmp.h>",
          "260: #ifndef NOTHREAD",
          "261: #  include <pthread.h>",
          "262: #endif",
          "265: #define ball_t try_ball_t_",
          "266: #define try TRY_TRY_",
          "267: #define always TRY_ALWAYS_",
          "268: #define catch TRY_CATCH_",
          "269: #define throw TRY_THROW_",
          "270: #define retry TRY_RETRY_",
          "271: #define punt TRY_PUNT_",
          "272: #define drop TRY_DROP_",
          "275:    why is a string with information to be displayed to indicate why an",
          "276:    exception was thrown.  free is true if why was allocated and should be freed",
          "277:    when no longer needed.  This structure can be customized as needed, but it",
          "278:    must start with an int code.  If it is customized, the try_throw_() function",
          "279:    in try.c must also be updated accordingly.  As an example, why could be a",
          "281: typedef struct {",
          "285: } try_ball_t_;",
          "288: typedef struct try_s_ try_t_;",
          "289: struct try_s_ {",
          "293: };",
          "296:    pointer.  Use thread-local storage if pthread.h is included before this.",
          "297:    Note that a throw can only be caught within the same thread.  A new and",
          "298:    unique try stack is created for each thread, so any attempt to throw across",
          "299:    threads will fail with an assert, by virtue of reaching the end of the",
          "301: #ifdef PTHREAD_ONCE_INIT",
          "302:     extern pthread_key_t try_key_;",
          "303:     void try_setup_(void);",
          "304: #   define try_stack_ ((try_t_ *)pthread_getspecific(try_key_))",
          "305: #   define try_stack_set_(next) \\",
          "306:         do { \\",
          "307:             int try_ret_ = pthread_setspecific(try_key_, next); \\",
          "308:             assert(try_ret_ == 0 && \"try: pthread_setspecific() failed\"); \\",
          "309:         } while (0)",
          "311:     extern try_t_ *try_stack_;",
          "312: #   define try_setup_()",
          "313: #   define try_stack_set_(next) try_stack_ = (next)",
          "317:    The block must be immediately followed by an always or a catch.  You must",
          "318:    not goto or return out of the try block.  A naked break or continue in the",
          "320: #define TRY_TRY_ \\",
          "321:     do { \\",
          "322:         try_t_ try_this_; \\",
          "323:         int try_pushed_ = 1; \\",
          "324:         try_this_.ball.code = 0; \\",
          "325:         try_this_.ball.free = 0; \\",
          "326:         try_this_.ball.why = NULL; \\",
          "327:         try_setup_(); \\",
          "328:         try_this_.next = try_stack_; \\",
          "329:         try_stack_set_(&try_this_); \\",
          "330:         if (setjmp(try_this_.env) < 2) \\",
          "331:             do { \\",
          "334:    thrown.  An always block is optional.  If present, the always block must",
          "335:    follow a try block and be followed by a catch block.  The always block",
          "336:    should be enclosed in { }.  A naked break or continue in the always block",
          "337:    will go to the end of the block.  It is permitted to use throw in the always",
          "338:    block, which will fall up to the next enclosing try.  However this will",
          "339:    result in a memory leak if the original throw() allocated space for the",
          "340:    informational string.  So it's best to not throw() in an always block.  Keep",
          "341:    the always block simple.",
          "343:    Great care must be taken if the always block uses an automatic storage",
          "344:    variable local to the enclosing function that can be modified in the try",
          "345:    block.  Such variables must be declared volatile.  If such a variable is not",
          "346:    declared volatile, and if the compiler elects to keep that variable in a",
          "347:    register, then the throw will restore that variable to its state at the",
          "348:    beginning of the try block, wiping out any change that occurred in the try",
          "349:    block.  This can cause very confusing bugs until you remember that you",
          "351: #define TRY_ALWAYS_ \\",
          "352:             } while (0); \\",
          "353:         if (try_pushed_) { \\",
          "354:             try_stack_set_(try_this_.next); \\",
          "355:             try_pushed_ = 0; \\",
          "356:         } \\",
          "357:             do {",
          "360:    follow catch and its parameter, and must be enclosed in { }.  The catch must",
          "361:    immediately follow the try or always block.  It is permitted to use throw()",
          "362:    in the catch block, which will fall up to the next enclosing try.  However",
          "363:    the ball_t passed by throw() must be freed using drop() before doing another",
          "364:    throw, to avoid a potential memory leak. The parameter of catch must be a",
          "365:    ball_t declared in the function or block containing the catch.  It is set to",
          "366:    the parameters of the throw() that jumped to the catch.  The catch block is",
          "367:    not executed if the first parameter of the throw() was zero.",
          "369:    A catch block should end with either a punt() or a drop().",
          "371:    Great care must be taken if the catch block uses an automatic storage",
          "372:    variable local to the enclosing function that can be modified in the try",
          "373:    block.  Such variables must be declared volatile.  If such a variable is not",
          "374:    declared volatile, and if the compiler elects to keep that variable in a",
          "375:    register, then the throw will restore that variable to its state at the",
          "376:    beginning of the try block, wiping out any change that occurred in the try",
          "377:    block.  This can cause very confusing bugs until you remember that you",
          "379: #define TRY_CATCH_(try_ball_) \\",
          "380:             } while (0); \\",
          "381:         if (try_pushed_) { \\",
          "382:             try_stack_set_(try_this_.next); \\",
          "383:             try_pushed_ = 0; \\",
          "384:         } \\",
          "385:         try_ball_ = try_this_.ball; \\",
          "386:     } while (0); \\",
          "387:     if (try_ball_.code)",
          "390:    the try block, at any level of nesting.  This will fall back to the end of",
          "391:    the first enclosing try block in the same thread, invoking the associated",
          "392:    catch block with a ball_t set to the arguments of throw().  throw() will",
          "393:    abort the program with an assert() if there is no nesting try.  Make sure",
          "394:    that there's a nesting try!",
          "396:    try may have one or more arguments, where the first argument is an int, the",
          "397:    optional second argument is a string, and the remaining optional arguments",
          "398:    are referred to by printf() formatting commands in the string.  If there are",
          "399:    formatting commands in the string, i.e. any percent (%) signs, then",
          "400:    vsnprintf() is used to generate the formatted string from the arguments",
          "401:    before jumping to the enclosing try block.  This allows throw() to use",
          "402:    information on the stack in the scope of the throw() statement, which will",
          "403:    be lost after jumping back to the enclosing try block.  That formatted",
          "404:    string will use allocated memory, which is why it is important to use drop()",
          "405:    in catch blocks to free that memory, or punt() to pass the string on to",
          "406:    another catch block.  Eventually some catch block down the chain will have",
          "407:    to drop() it.",
          "409:    If a memory allocation fails during the execution of a throw(), then the",
          "410:    string provided to the catch block is not the formatted string at all, but",
          "411:    rather the string: \"try: out of memory\", with the integer code from the",
          "412:    throw() unchanged.",
          "414:    If the first argument of throw is zero, then the catch block is not",
          "415:    executed.  A throw(0) from a function called in the try block is equivalent",
          "416:    to a break or continue in the try block.  A throw(0) should not have any",
          "417:    other arguments, to avoid a potential memory leak.  There is no opportunity",
          "418:    to make use of any arguments after the 0 anyway.",
          "421: void try_throw_(int code, char *fmt, ...);",
          "422: #define TRY_THROW_(...) try_throw_(__VA_ARGS__, NULL)",
          "425:    block.  This can be used in the try block or in any function called from the",
          "426:    try block at any level of nesting, just like throw.  retry has no argument.",
          "427:    If there is a retry in the always or catch block, then it will retry the",
          "428:    next enclosing try, not the immediately preceding try.",
          "430:    If you use this, make sure you have carefully thought through how it will",
          "431:    work.  It can be tricky to correctly rerun a chunk of code that has been",
          "432:    partially executed.  Especially if there are different degrees of progress",
          "433:    that could have been made.  Also note that automatic variables changed in",
          "434:    the try block and not declared volatile will have indeterminate values.",
          "436:    We use 1 here instead of 0, since some implementations prevent returning a",
          "438: #define TRY_RETRY_ \\",
          "439:     do { \\",
          "440:         try_setup_(); \\",
          "441:         assert(try_stack_ != NULL && \"try: naked retry\"); \\",
          "442:         longjmp(try_stack_->env, 1); \\",
          "443:     } while (0)",
          "447: #define TRY_PUNT_(try_ball_) \\",
          "448:     do { \\",
          "449:         try_setup_(); \\",
          "450:         assert(try_stack_ != NULL && \"try: naked punt\"); \\",
          "451:         try_stack_->ball = try_ball_; \\",
          "452:         longjmp(try_stack_->env, 2); \\",
          "453:     } while (0)",
          "456: #define TRY_DROP_(try_ball_) \\",
          "457:     do { \\",
          "458:         if (try_ball_.free) { \\",
          "459:             free(try_ball_.why); \\",
          "460:             try_ball_.free = 0; \\",
          "461:             try_ball_.why = NULL; \\",
          "462:         } \\",
          "463:     } while (0)",
          "",
          "---------------"
        ],
        "yarn.c||yarn.c": [
          "File: yarn.c -> yarn.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "17:    1.3    13 Jan 2012  Add large file #define for consistency with pigz.c",
          "18:                        Update thread portability #defines per IEEE 1003.1-2008",
          "19:                        Fix documentation in yarn.h for yarn_prefix",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "20:    1.4    19 Jan 2015  Allow yarn_abort() to avoid error message to stderr",
          "21:                        Accept and do nothing for NULL argument to free_lock()",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "55: local void fail(int err)",
          "56: {",
          "59:     if (yarn_abort != NULL)",
          "60:         yarn_abort(err);",
          "61:     exit(err == ENOMEM || err == EAGAIN ? err : EINVAL);",
          "62: }",
          "",
          "[Removed Lines]",
          "57:     fprintf(stderr, \"%s: %s (%d) -- aborting\\n\", yarn_prefix,",
          "58:             err == ENOMEM ? \"out of memory\" : \"internal pthread error\", err);",
          "",
          "[Added Lines]",
          "61:     fprintf(stderr, \"%s: %s (%d) -- aborting\\n\", yarn_prefix,",
          "62:             err == ENOMEM ? \"out of memory\" : \"internal pthread error\", err);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "172: void free_lock(lock *bolt)",
          "173: {",
          "174:     int ret;",
          "175:     if ((ret = pthread_cond_destroy(&(bolt->cond))) ||",
          "176:         (ret = pthread_mutex_destroy(&(bolt->mutex))))",
          "177:         fail(ret);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "178:     if (bolt == NULL)",
          "179:         return;",
          "",
          "---------------"
        ],
        "yarn.h||yarn.h": [
          "File: yarn.h -> yarn.h"
        ]
      }
    },
    {
      "candidate_hash": "5651eefb388df39b74fdfde2954eeb31377c10a7",
      "candidate_info": {
        "commit_hash": "5651eefb388df39b74fdfde2954eeb31377c10a7",
        "repo": "madler/pigz",
        "commit_url": "https://github.com/madler/pigz/commit/5651eefb388df39b74fdfde2954eeb31377c10a7",
        "files": [
          "pigz.c"
        ],
        "message": "Fix typo.",
        "before_after_code_files": [
          "pigz.c||pigz.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "pigz.c||pigz.c"
          ],
          "candidate": [
            "pigz.c||pigz.c"
          ]
        }
      },
      "candidate_diff": {
        "pigz.c||pigz.c": [
          "File: pigz.c -> pigz.c"
        ]
      }
    }
  ]
}
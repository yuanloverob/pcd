{
  "cve_id": "CVE-2019-14934",
  "cve_desc": "An issue was discovered in PDFResurrect before 0.18. pdf_load_pages_kids in pdf.c doesn't validate a certain size value, which leads to a malloc failure and out-of-bounds write.",
  "repo": "enferex/pdfresurrect",
  "patch_hash": "0c4120fffa3dffe97b95c486a120eded82afe8a6",
  "patch_info": {
    "commit_hash": "0c4120fffa3dffe97b95c486a120eded82afe8a6",
    "repo": "enferex/pdfresurrect",
    "commit_url": "https://github.com/enferex/pdfresurrect/commit/0c4120fffa3dffe97b95c486a120eded82afe8a6",
    "files": [
      "main.c",
      "main.h",
      "pdf.c"
    ],
    "message": "Zero and sanity check all dynamic allocs.\n\nThis addresses the memory issues in Issue #6 expressed in\ncalloc_some.pdf and malloc_some.pdf",
    "before_after_code_files": [
      "main.c||main.c",
      "main.h||main.h",
      "pdf.c||pdf.c"
    ]
  },
  "patch_diff": {
    "main.c||main.c": [
      "File: main.c -> main.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "73:     if ((c = strstr(fname, \".pdf\")))",
      "76:     snprintf(new_fname, strlen(fname) + strlen(dirname) + 16,",
      "77:              \"%s/%s-version-%d.pdf\", dirname, fname, xref->version);",
      "",
      "[Removed Lines]",
      "75:     new_fname = malloc(strlen(fname) + strlen(dirname) + 16);",
      "",
      "[Added Lines]",
      "75:     new_fname = safe_calloc(strlen(fname) + strlen(dirname) + 16);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "213: }",
      "216: int main(int argc, char **argv)",
      "217: {",
      "218:     int         i, n_valid, do_write, do_scrub;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "216: void *safe_calloc(size_t size) {",
      "217:   void *addr;",
      "219:   if (!size)",
      "220:   {",
      "221:     ERR(\"Invalid allocation size.\\n\");",
      "222:     exit(EXIT_FAILURE);",
      "223:   }",
      "224:   if (!(addr = calloc(1, size)))",
      "225:   {",
      "226:       ERR(\"Failed to allocate requested number of bytes, out of memory?\\n\");",
      "227:       exit(EXIT_FAILURE);",
      "228:   }",
      "229:   return addr;",
      "230: }",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "295:         if ((c = strrchr(name, '.')))",
      "299:         sprintf(dname, \"%s-versions\", name);",
      "300:         if (!(dir = opendir(dname)))",
      "301:           mkdir(dname, S_IRWXU);",
      "",
      "[Removed Lines]",
      "298:         dname = malloc(strlen(name) + 16);",
      "",
      "[Added Lines]",
      "315:         dname = safe_calloc(strlen(name) + 16);",
      "",
      "---------------"
    ],
    "main.h||main.h": [
      "File: main.h -> main.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "40: #define TAG \"[pdfresurrect]\"",
      "41: #define ERR(...) {fprintf(stderr, TAG\" -- Error -- \" __VA_ARGS__);}",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "44: extern void *safe_calloc(size_t bytes);",
      "",
      "---------------"
    ],
    "pdf.c||pdf.c": [
      "File: pdf.c -> pdf.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "122:     const char *n;",
      "123:     pdf_t      *pdf;",
      "127:     if (name)",
      "128:     {",
      "",
      "[Removed Lines]",
      "125:     pdf = calloc(1, sizeof(pdf_t));",
      "",
      "[Added Lines]",
      "125:     pdf = safe_calloc(sizeof(pdf_t));",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "132:         else",
      "133:           n = name;",
      "136:         strcpy(pdf->name, n);",
      "137:     }",
      "139:     {",
      "141:         strcpy(pdf->name, \"Unknown\");",
      "142:     }",
      "",
      "[Removed Lines]",
      "135:         pdf->name = malloc(strlen(n) + 1);",
      "140:         pdf->name = malloc(strlen(\"Unknown\") + 1);",
      "",
      "[Added Lines]",
      "135:         pdf->name = safe_calloc(strlen(n) + 1);",
      "140:         pdf->name = safe_calloc(strlen(\"Unknown\") + 1);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "218:     fseek(fp, 0, SEEK_SET);",
      "220:     ver = 1;",
      "221:     for (i=0; i<pdf->n_xrefs; i++)",
      "222:     {",
      "",
      "[Removed Lines]",
      "219:     pdf->xrefs = calloc(1, sizeof(xref_t) * pdf->n_xrefs);",
      "",
      "[Added Lines]",
      "219:     pdf->xrefs = safe_calloc(sizeof(xref_t) * pdf->n_xrefs);",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "316:             sz = pdf->xrefs[i].end - ftell(fp);",
      "318:             SAFE_E(fread(buf, 1, sz, fp), sz, \"Failed to load /Root.\\n\");",
      "319:             buf[sz] = '\\0';",
      "320:             if (!(c = strstr(buf, \"/Root\")))",
      "",
      "[Removed Lines]",
      "317:             buf = malloc(sz + 1);",
      "",
      "[Added Lines]",
      "317:             buf = safe_calloc(sz + 1);",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "445:     if (name)",
      "446:     {",
      "448:         sprintf(dst_name, \"%s/%s\", name, name);",
      "450:         if ((c = strrchr(dst_name, '.')) && (strncmp(c, \".pdf\", 4) == 0))",
      "",
      "[Removed Lines]",
      "447:         dst_name = malloc(strlen(name) * 2 + 16);",
      "",
      "[Added Lines]",
      "447:         dst_name = safe_calloc(strlen(name) * 2 + 16);",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "644:     SAFE_E(fread(buf, 1, 21, fp), 21, \"Failed to load entry Size string.\\n\");",
      "645:     xref->n_entries = atoi(buf + strlen(\"ize \"));",
      "649:     obj_id = 0;",
      "",
      "[Removed Lines]",
      "646:     xref->entries = calloc(1, xref->n_entries * sizeof(struct _xref_entry));",
      "",
      "[Added Lines]",
      "646:     xref->entries = safe_calloc(xref->n_entries * sizeof(struct _xref_entry));",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "810:         {\"Trapped\",      \"\"},",
      "811:     };",
      "814:     memcpy(daddy, creator_template, sizeof(creator_template));",
      "816:     if (n_elements)",
      "",
      "[Removed Lines]",
      "813:     daddy = malloc(sizeof(creator_template));",
      "",
      "[Added Lines]",
      "813:     daddy = safe_calloc(sizeof(creator_template));",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "1101:     n_blks = 1;",
      "1106:     stream = 0;",
      "",
      "[Removed Lines]",
      "1102:     data = malloc(blk_sz * n_blks);",
      "1103:     memset(data, 0, blk_sz * n_blks);",
      "",
      "[Added Lines]",
      "1102:     data = safe_calloc(blk_sz * n_blks);",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "1267: static char *get_header(FILE *fp)",
      "1268: {",
      "1277:     fseek(fp, 0, SEEK_SET);",
      "1278:     SAFE_E(fread(header, 1, 1023, fp), 1023, \"Failed to load PDF header.\\n\");",
      "1279:     fseek(fp, start, SEEK_SET);",
      "1281:     return header;",
      "1282: }",
      "",
      "[Removed Lines]",
      "1269:     long start;",
      "1272:     char *header;",
      "1274:     header = calloc(1, 1024);",
      "1276:     start = ftell(fp);",
      "",
      "[Added Lines]",
      "1269:     char *header = safe_calloc(1024);",
      "1270:     long start = ftell(fp);",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "1293:     if (str[0] == '(')",
      "1294:     {",
      "1296:         strncpy(ascii, str, strlen(str) + 1);",
      "1297:         return ascii;",
      "1298:     }",
      "",
      "[Removed Lines]",
      "1295:         ascii = malloc(strlen(str) + 1);",
      "",
      "[Added Lines]",
      "1288:         ascii = safe_calloc(strlen(str) + 1);",
      "",
      "---------------",
      "--- Hunk 11 ---",
      "[Context before]",
      "1314:       return NULL;",
      "1318:     for ( ; idx<str_len; ++idx)",
      "1319:     {",
      "1320:         hex_buf[0] = str[idx++];",
      "",
      "[Removed Lines]",
      "1317:     ascii = malloc(str_len);",
      "",
      "[Added Lines]",
      "1310:     ascii = safe_calloc(str_len);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "8d5bea0d18408f52cf2195964020c4c6d312afe4",
      "candidate_info": {
        "commit_hash": "8d5bea0d18408f52cf2195964020c4c6d312afe4",
        "repo": "enferex/pdfresurrect",
        "commit_url": "https://github.com/enferex/pdfresurrect/commit/8d5bea0d18408f52cf2195964020c4c6d312afe4",
        "files": [
          "pdf.c"
        ],
        "message": "Fix a memory leak.\n\nThanks to @rtfing for pointing this out in Issue #6.  This fixes bugs\nidentified by memory_leak memleak2.pdf",
        "before_after_code_files": [
          "pdf.c||pdf.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [
            "pdf.c||pdf.c"
          ],
          "candidate": [
            "pdf.c||pdf.c"
          ]
        }
      },
      "candidate_diff": {
        "pdf.c||pdf.c": [
          "File: pdf.c -> pdf.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "605:         if (c && xref->is_stream)",
          "606:         {",
          "608:             pdf->has_xref_streams = 1;",
          "609:             is_valid = 1;",
          "610:         }",
          "611:     }",
          "613:     fseek(fp, start, SEEK_SET);",
          "",
          "[Removed Lines]",
          "607:             free(c);",
          "",
          "[Added Lines]",
          "610:         free(c);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "61c67be6bc41aeb015e0825ee7f1596df9f6f4fa",
      "candidate_info": {
        "commit_hash": "61c67be6bc41aeb015e0825ee7f1596df9f6f4fa",
        "repo": "enferex/pdfresurrect",
        "commit_url": "https://github.com/enferex/pdfresurrect/commit/61c67be6bc41aeb015e0825ee7f1596df9f6f4fa",
        "files": [
          "pdf.c"
        ],
        "message": "Zero and extend a buffer.\n\nThis should fix one of the ASAN discovered overflows in Issue #6.\nThe test case is stackoverflow_some.pdf in that issue.  Thanks\nto @rtfingc for finding and reporting this.",
        "before_after_code_files": [
          "pdf.c||pdf.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [
            "pdf.c||pdf.c"
          ],
          "candidate": [
            "pdf.c||pdf.c"
          ]
        }
      },
      "candidate_diff": {
        "pdf.c||pdf.c": [
          "File: pdf.c -> pdf.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "627: static void load_xref_from_plaintext(FILE *fp, xref_t *xref)",
          "628: {",
          "629:     int  i, buf_idx, obj_id, added_entries;",
          "631:     long start, pos;",
          "633:     start = ftell(fp);",
          "",
          "[Removed Lines]",
          "630:     char c, buf[21];",
          "",
          "[Added Lines]",
          "630:     char c, buf[32] = {0};",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "43339ca3fd32537c5218e560599252278245f517",
      "candidate_info": {
        "commit_hash": "43339ca3fd32537c5218e560599252278245f517",
        "repo": "enferex/pdfresurrect",
        "commit_url": "https://github.com/enferex/pdfresurrect/commit/43339ca3fd32537c5218e560599252278245f517",
        "files": [
          "pdf.c"
        ],
        "message": "Initialize a buffer and ensure the last item is never written to.\n\nThis should fix the item in Issue #6 exposed by stackoverflow2.pdf\nThanks to @rtfingc for finding and reporting this issue.",
        "before_after_code_files": [
          "pdf.c||pdf.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [
            "pdf.c||pdf.c"
          ],
          "candidate": [
            "pdf.c||pdf.c"
          ]
        }
      },
      "candidate_diff": {
        "pdf.c||pdf.c": [
          "File: pdf.c -> pdf.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "831: static void load_creator(FILE *fp, pdf_t *pdf)",
          "832: {",
          "833:     int    i, buf_idx;",
          "835:     long   start;",
          "836:     size_t sz;",
          "",
          "[Removed Lines]",
          "834:     char   c, *buf, obj_id_buf[32];",
          "",
          "[Added Lines]",
          "834:     char   c, *buf, obj_id_buf[32] = {0};",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "874:         buf_idx = 0;",
          "875:         obj_id_buf[buf_idx++] = c;",
          "877:           obj_id_buf[buf_idx++] = c;",
          "879:         END_OF_TRAILER(c, start, fp);",
          "884:         buf = get_object(fp, atoll(obj_id_buf), &pdf->xrefs[i], &sz, NULL);",
          "",
          "[Removed Lines]",
          "876:         while (SAFE_F(fp, (!isspace(c = fgetc(fp)) && (c != '>'))))",
          "881:         obj_id_buf[buf_idx] = '\\0';",
          "",
          "[Added Lines]",
          "876:         while ((buf_idx < (sizeof(obj_id_buf) - 1)) &&",
          "877:                SAFE_F(fp, (!isspace(c = fgetc(fp)) && (c != '>'))))",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "305c6018540f680be92cfde57edb4306abf0ca44",
      "candidate_info": {
        "commit_hash": "305c6018540f680be92cfde57edb4306abf0ca44",
        "repo": "enferex/pdfresurrect",
        "commit_url": "https://github.com/enferex/pdfresurrect/commit/305c6018540f680be92cfde57edb4306abf0ca44",
        "files": [
          "AUTHORS",
          "pdf.c"
        ],
        "message": "Remove strlen calc in str manipulation routine.\n\nThanks Farncois Marier for pointing this out!",
        "before_after_code_files": [
          "pdf.c||pdf.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "pdf.c||pdf.c"
          ],
          "candidate": [
            "pdf.c||pdf.c"
          ]
        }
      },
      "candidate_diff": {
        "pdf.c||pdf.c": [
          "File: pdf.c -> pdf.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1063:       }",
          "1065:     xref->creator = info;",
          "1066:     xref->n_creator_entries = n_eles;",
          "",
          "[Removed Lines]",
          "1058:     for (i=0; i<n_eles; ++i)",
          "1059:       if ((ascii = decode_text_string(info[i].value, strlen(info[i].value))))",
          "1060:       {",
          "1061:           strncpy(info[i].value, ascii, strlen(info[i].value));",
          "1062:           free(ascii);",
          "",
          "[Added Lines]",
          "1058:     for (i = 0; i < n_eles; ++i) {",
          "1059:       const size_t val_str_len = strnlen(info[i].value, KV_MAX_VALUE_LENGTH);",
          "1060:       if ((ascii = decode_text_string(info[i].value, val_str_len))) {",
          "1061:         strncpy(info[i].value, ascii, val_str_len);",
          "1062:         free(ascii);",
          "1064:     }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1341:     if (str[0] == '(')",
          "1342:     {",
          "1345:         return ascii;",
          "1346:     }",
          "1347:     else if (str[0] == '<')",
          "",
          "[Removed Lines]",
          "1343:         ascii = safe_calloc(strlen(str) + 1);",
          "1344:         strncpy(ascii, str, strlen(str) + 1);",
          "",
          "[Added Lines]",
          "1344:         ascii = safe_calloc(str_len + 1);",
          "1345:         strncpy(ascii, str, str_len + 1);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "c5d7ff6daa9cdc9536fa483770f5dc5eed5a37a0",
      "candidate_info": {
        "commit_hash": "c5d7ff6daa9cdc9536fa483770f5dc5eed5a37a0",
        "repo": "enferex/pdfresurrect",
        "commit_url": "https://github.com/enferex/pdfresurrect/commit/c5d7ff6daa9cdc9536fa483770f5dc5eed5a37a0",
        "files": [
          "main.c",
          "pdf.c",
          "pdf.h"
        ],
        "message": "Remove kidpage loading.\n\nKid pages were never used in pdfresurrect.  This was originally for\nmapping object to page numbers (if I recally correctly). However, I'd\nprefer to rewrite that logic than resurrect the unused components.",
        "before_after_code_files": [
          "main.c||main.c",
          "pdf.c||pdf.c",
          "pdf.h||pdf.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "main.c||main.c",
            "pdf.c||pdf.c"
          ],
          "candidate": [
            "main.c||main.c",
            "pdf.c||pdf.c"
          ]
        }
      },
      "candidate_diff": {
        "main.c||main.c": [
          "File: main.c -> main.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "73:     if ((c = strstr(fname, \".pdf\")))",
          "77:              \"%s/%s-version-%d.pdf\", dirname, fname, xref->version);",
          "79:     if (!(new_fp = fopen(new_fname, \"w\")))",
          "",
          "[Removed Lines]",
          "75:     new_fname = safe_calloc(strlen(fname) + strlen(dirname) + 16);",
          "76:     snprintf(new_fname, strlen(fname) + strlen(dirname) + 16,",
          "",
          "[Added Lines]",
          "75:     new_fname = safe_calloc(strlen(fname) + strlen(dirname) + 32);",
          "76:     snprintf(new_fname, strlen(fname) + strlen(dirname) + 32,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "207:       pdf_delete(pdf);",
          "208:       return NULL;",
          "209:     }",
          "212:     return pdf;",
          "213: }",
          "",
          "[Removed Lines]",
          "210:     pdf_load_pages_kids(fp, pdf);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "pdf.c||pdf.c": [
          "File: pdf.c -> pdf.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "118:     size_t       *size,",
          "119:     int          *is_stream);",
          "124: static const char *get_type(FILE *fp, int obj_id, const xref_t *xref);",
          "126: static char *get_header(FILE *fp);",
          "",
          "[Removed Lines]",
          "121: static void add_kid(int id, xref_t *xref);",
          "122: static void load_kids(FILE *fp, int pages_id, xref_t *xref);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "169:     {",
          "170:         free(pdf->xrefs[i].creator);",
          "171:         free(pdf->xrefs[i].entries);",
          "173:     }",
          "175:     free(pdf->name);",
          "",
          "[Removed Lines]",
          "172:         free(pdf->xrefs[i].kids);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "362: char pdf_get_object_status(",
          "363:     const pdf_t *pdf,",
          "364:     int          xref_idx,",
          "",
          "[Removed Lines]",
          "313: void pdf_load_pages_kids(FILE *fp, pdf_t *pdf)",
          "314: {",
          "315:     int     i, id, dummy;",
          "316:     char   *buf, *c;",
          "317:     long    start, sz;",
          "319:     start = ftell(fp);",
          "322:     for (i=0; i<pdf->n_xrefs; i++)",
          "323:     {",
          "324:         if (pdf->xrefs[i].version && (pdf->xrefs[i].end != 0))",
          "325:         {",
          "326:             fseek(fp, pdf->xrefs[i].start, SEEK_SET);",
          "327:             while (SAFE_F(fp, (fgetc(fp) != 't')))",
          "331:             sz = pdf->xrefs[i].end - ftell(fp);",
          "332:             buf = safe_calloc(sz + 1);",
          "333:             SAFE_E(fread(buf, 1, sz, fp), sz, \"Failed to load /Root.\\n\");",
          "334:             buf[sz] = '\\0';",
          "335:             if (!(c = strstr(buf, \"/Root\")))",
          "336:             {",
          "337:                 free(buf);",
          "338:                 continue;",
          "339:             }",
          "342:             id = atoi(c + strlen(\"/Root\") + 1);",
          "343:             free(buf);",
          "344:             buf = get_object(fp, id, &pdf->xrefs[i], NULL, &dummy);",
          "345:             if (!buf || !(c = strstr(buf, \"/Pages\")))",
          "346:             {",
          "347:                 free(buf);",
          "348:                 continue;",
          "349:             }",
          "352:             id = atoi(c + strlen(\"/Pages\") + 1);",
          "353:             load_kids(fp, id, &pdf->xrefs[i]);",
          "354:             free(buf);",
          "355:         }",
          "356:     }",
          "358:     fseek(fp, start, SEEK_SET);",
          "359: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1208: }",
          "1266: static const char *get_type(FILE *fp, int obj_id, const xref_t *xref)",
          "1267: {",
          "1268:     int          is_stream;",
          "",
          "[Removed Lines]",
          "1211: static void add_kid(int id, xref_t *xref)",
          "1212: {",
          "1214:     if (((xref->n_kids + 1) * KID_SIZE) > (xref->n_kids_allocs*KIDS_PER_ALLOC))",
          "1215:       xref->kids = realloc(",
          "1216:           xref->kids, (++xref->n_kids_allocs)*(KIDS_PER_ALLOC * KID_SIZE));",
          "1218:     xref->kids[xref->n_kids++] = id;",
          "1219: }",
          "1223: static void load_kids(FILE *fp, int pages_id, xref_t *xref)",
          "1224: {",
          "1225:     int   dummy, buf_idx, kid_id;",
          "1226:     char *data, *c, buf[32];",
          "1229:     data = get_object(fp, pages_id, xref, NULL, &dummy);",
          "1230:     if (!data || !(c = strstr(data, \"/Kids\")))",
          "1231:     {",
          "1232:         free(data);",
          "1233:         return;",
          "1234:     }",
          "1236:     c = strchr(c, '[');",
          "1237:     if (c == NULL)",
          "1238:     {",
          "1239:         free(data);",
          "1240:         return;",
          "1241:     }",
          "1242:     buf_idx = 0;",
          "1243:     memset(buf, 0, sizeof(buf));",
          "1244:     while (*(++c) != ']')",
          "1245:     {",
          "1246:         if (isdigit(*c) || (*c == ' '))",
          "1247:           buf[buf_idx++] = *c;",
          "1248:         else if (isalpha(*c))",
          "1249:         {",
          "1250:             kid_id = atoi(buf);",
          "1251:             add_kid(kid_id, xref);",
          "1252:             buf_idx = 0;",
          "1253:             memset(buf, 0, sizeof(buf));",
          "1256:             load_kids(fp, kid_id, xref);",
          "1257:         }",
          "1258:         else if (*c == ']')",
          "1259:           break;",
          "1260:     }",
          "1262:     free(data);",
          "1263: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1332: }",
          "1349: static char *get_header(FILE *fp)",
          "1350: {",
          "",
          "[Removed Lines]",
          "1336: static int get_page(int obj_id, const xref_t *xref)",
          "1337: {",
          "1338:     int i;",
          "1340:     for (i=0; i<xref->n_kids; i++)",
          "1341:       if (xref->kids[i] == obj_id)",
          "1342:         break;",
          "1344:     return i;",
          "1345: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "pdf.h||pdf.h": [
          "File: pdf.h -> pdf.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "63: } xref_entry_t;",
          "68: typedef struct _xref_t",
          "69: {",
          "70:     long start;",
          "",
          "[Removed Lines]",
          "66: #define KIDS_PER_ALLOC 64",
          "67: #define KID_SIZE sizeof(int)",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "77:     int n_entries;",
          "78:     xref_entry_t *entries;",
          "85:     int is_stream;",
          "",
          "[Removed Lines]",
          "80:     int  n_kids;",
          "81:     int *kids;",
          "82:     int  n_kids_allocs;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "113: extern void pdf_get_version(FILE *fp, pdf_t *pdf);",
          "115: extern int pdf_load_xrefs(FILE *fp, pdf_t *pdf);",
          "118: extern char pdf_get_object_status(",
          "119:     const pdf_t *pdf,",
          "",
          "[Removed Lines]",
          "116: extern void pdf_load_pages_kids(FILE *fp, pdf_t *pdf);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    }
  ]
}
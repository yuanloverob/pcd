{
  "cve_id": "CVE-2014-7841",
  "cve_desc": "The sctp_process_param function in net/sctp/sm_make_chunk.c in the SCTP implementation in the Linux kernel before 3.17.4, when ASCONF is used, allows remote attackers to cause a denial of service (NULL pointer dereference and system crash) via a malformed INIT chunk.",
  "repo": "torvalds/linux",
  "patch_hash": "e40607cbe270a9e8360907cb1e62ddf0736e4864",
  "patch_info": {
    "commit_hash": "e40607cbe270a9e8360907cb1e62ddf0736e4864",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/e40607cbe270a9e8360907cb1e62ddf0736e4864",
    "files": [
      "net/sctp/sm_make_chunk.c"
    ],
    "message": "net: sctp: fix NULL pointer dereference in af->from_addr_param on malformed packet\n\nAn SCTP server doing ASCONF will panic on malformed INIT ping-of-death\nin the form of:\n\n  ------------ INIT[PARAM: SET_PRIMARY_IP] ------------>\n\nWhile the INIT chunk parameter verification dissects through many things\nin order to detect malformed input, it misses to actually check parameters\ninside of parameters. E.g. RFC5061, section 4.2.4 proposes a 'set primary\nIP address' parameter in ASCONF, which has as a subparameter an address\nparameter.\n\nSo an attacker may send a parameter type other than SCTP_PARAM_IPV4_ADDRESS\nor SCTP_PARAM_IPV6_ADDRESS, param_type2af() will subsequently return 0\nand thus sctp_get_af_specific() returns NULL, too, which we then happily\ndereference unconditionally through af->from_addr_param().\n\nThe trace for the log:\n\nBUG: unable to handle kernel NULL pointer dereference at 0000000000000078\nIP: [<ffffffffa01e9c62>] sctp_process_init+0x492/0x990 [sctp]\nPGD 0\nOops: 0000 [#1] SMP\n[...]\nPid: 0, comm: swapper Not tainted 2.6.32-504.el6.x86_64 #1 Bochs Bochs\nRIP: 0010:[<ffffffffa01e9c62>]  [<ffffffffa01e9c62>] sctp_process_init+0x492/0x990 [sctp]\n[...]\nCall Trace:\n <IRQ>\n [<ffffffffa01f2add>] ? sctp_bind_addr_copy+0x5d/0xe0 [sctp]\n [<ffffffffa01e1fcb>] sctp_sf_do_5_1B_init+0x21b/0x340 [sctp]\n [<ffffffffa01e3751>] sctp_do_sm+0x71/0x1210 [sctp]\n [<ffffffffa01e5c09>] ? sctp_endpoint_lookup_assoc+0xc9/0xf0 [sctp]\n [<ffffffffa01e61f6>] sctp_endpoint_bh_rcv+0x116/0x230 [sctp]\n [<ffffffffa01ee986>] sctp_inq_push+0x56/0x80 [sctp]\n [<ffffffffa01fcc42>] sctp_rcv+0x982/0xa10 [sctp]\n [<ffffffffa01d5123>] ? ipt_local_in_hook+0x23/0x28 [iptable_filter]\n [<ffffffff8148bdc9>] ? nf_iterate+0x69/0xb0\n [<ffffffff81496d10>] ? ip_local_deliver_finish+0x0/0x2d0\n [<ffffffff8148bf86>] ? nf_hook_slow+0x76/0x120\n [<ffffffff81496d10>] ? ip_local_deliver_finish+0x0/0x2d0\n[...]\n\nA minimal way to address this is to check for NULL as we do on all\nother such occasions where we know sctp_get_af_specific() could\npossibly return with NULL.\n\nFixes: d6de3097592b (\"[SCTP]: Add the handling of \"Set Primary IP Address\" parameter to INIT\")\nSigned-off-by: Daniel Borkmann <dborkman@redhat.com>\nCc: Vlad Yasevich <vyasevich@gmail.com>\nAcked-by: Neil Horman <nhorman@tuxdriver.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
    "before_after_code_files": [
      "net/sctp/sm_make_chunk.c||net/sctp/sm_make_chunk.c"
    ]
  },
  "patch_diff": {
    "net/sctp/sm_make_chunk.c||net/sctp/sm_make_chunk.c": [
      "File: net/sctp/sm_make_chunk.c -> net/sctp/sm_make_chunk.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "2609:   addr_param = param.v + sizeof(sctp_addip_param_t);",
      "2611:   af = sctp_get_af_specific(param_type2af(param.p->type));",
      "2612:   af->from_addr_param(&addr, addr_param,",
      "2613:         htons(asoc->peer.port), 0);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2612:   if (af == NULL)",
      "2613:    break;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "ee81f4ee2a3632a2d7928f680c4af8243a18762f",
      "candidate_info": {
        "commit_hash": "ee81f4ee2a3632a2d7928f680c4af8243a18762f",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/ee81f4ee2a3632a2d7928f680c4af8243a18762f",
        "files": [
          "drivers/clk/mmp/Makefile",
          "drivers/clk/mmp/clk-mix.c",
          "drivers/clk/mmp/clk.h"
        ],
        "message": "clk: mmp: add clock type mix\n\nThe clock type mix is a kind of clock combines \"div\" and \"mux\".\nThis kind of clock can not allow to change div first then\nmux or change mux first or div.\nThe reason is\n1. Some clock has frequency change bit. Each time want to change\n   the frequency, there are some operations based on this bit, and\n   these operations are time-cost.\n   Seperating div and mux change will make the process longer, and\n   waste more time.\n2. Seperting the div and mux may generate middle clock that the\n   peripharals do not support. It may make the peripharals hang.\n\nThere are three kinds of this type of clock in all SOCes.\n1. The clock has bit to trigger the frequency change.\n2. Same as #1, but the operations for the bit is different\n3. Do not have frequency change bit.\n\nSo this type of clock has implemented the callbacks\n->determine_rate\n->set_rate_and_parent\nThese callbacks can help to change the div and mux together.\n\nSigned-off-by: Chao Xie <chao.xie@marvell.com>\nAcked-by: Haojian Zhuang <haojian.zhuang@gmail.com>\nSigned-off-by: Michael Turquette <mturquette@linaro.org>",
        "before_after_code_files": [
          "drivers/clk/mmp/clk-mix.c||drivers/clk/mmp/clk-mix.c",
          "drivers/clk/mmp/clk.h||drivers/clk/mmp/clk.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/clk/mmp/clk-mix.c||drivers/clk/mmp/clk-mix.c": [
          "File: drivers/clk/mmp/clk-mix.c -> drivers/clk/mmp/clk-mix.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "12: #include <linux/clk-provider.h>",
          "13: #include <linux/slab.h>",
          "14: #include <linux/io.h>",
          "15: #include <linux/err.h>",
          "17: #include \"clk.h\"",
          "25: #define to_clk_mix(hw) container_of(hw, struct mmp_clk_mix, hw)",
          "27: static unsigned int _get_maxdiv(struct mmp_clk_mix *mix)",
          "28: {",
          "29:  unsigned int div_mask = (1 << mix->reg_info.width_div) - 1;",
          "30:  unsigned int maxdiv = 0;",
          "31:  struct clk_div_table *clkt;",
          "33:  if (mix->div_flags & CLK_DIVIDER_ONE_BASED)",
          "34:   return div_mask;",
          "35:  if (mix->div_flags & CLK_DIVIDER_POWER_OF_TWO)",
          "36:   return 1 << div_mask;",
          "37:  if (mix->div_table) {",
          "38:   for (clkt = mix->div_table; clkt->div; clkt++)",
          "39:    if (clkt->div > maxdiv)",
          "40:     maxdiv = clkt->div;",
          "41:   return maxdiv;",
          "42:  }",
          "43:  return div_mask + 1;",
          "44: }",
          "46: static unsigned int _get_div(struct mmp_clk_mix *mix, unsigned int val)",
          "47: {",
          "48:  struct clk_div_table *clkt;",
          "50:  if (mix->div_flags & CLK_DIVIDER_ONE_BASED)",
          "51:   return val;",
          "52:  if (mix->div_flags & CLK_DIVIDER_POWER_OF_TWO)",
          "53:   return 1 << val;",
          "54:  if (mix->div_table) {",
          "55:   for (clkt = mix->div_table; clkt->div; clkt++)",
          "56:    if (clkt->val == val)",
          "57:     return clkt->div;",
          "58:   if (clkt->div == 0)",
          "59:    return 0;",
          "60:  }",
          "61:  return val + 1;",
          "62: }",
          "64: static unsigned int _get_mux(struct mmp_clk_mix *mix, unsigned int val)",
          "65: {",
          "66:  int num_parents = __clk_get_num_parents(mix->hw.clk);",
          "67:  int i;",
          "69:  if (mix->mux_flags & CLK_MUX_INDEX_BIT)",
          "70:   return ffs(val) - 1;",
          "71:  if (mix->mux_flags & CLK_MUX_INDEX_ONE)",
          "72:   return val - 1;",
          "73:  if (mix->mux_table) {",
          "74:   for (i = 0; i < num_parents; i++)",
          "75:    if (mix->mux_table[i] == val)",
          "76:     return i;",
          "77:   if (i == num_parents)",
          "78:    return 0;",
          "79:  }",
          "81:  return val;",
          "82: }",
          "83: static unsigned int _get_div_val(struct mmp_clk_mix *mix, unsigned int div)",
          "84: {",
          "85:  struct clk_div_table *clkt;",
          "87:  if (mix->div_flags & CLK_DIVIDER_ONE_BASED)",
          "88:   return div;",
          "89:  if (mix->div_flags & CLK_DIVIDER_POWER_OF_TWO)",
          "90:   return __ffs(div);",
          "91:  if (mix->div_table) {",
          "92:   for (clkt = mix->div_table; clkt->div; clkt++)",
          "93:    if (clkt->div == div)",
          "94:     return clkt->val;",
          "95:   if (clkt->div == 0)",
          "96:    return 0;",
          "97:  }",
          "99:  return div - 1;",
          "100: }",
          "102: static unsigned int _get_mux_val(struct mmp_clk_mix *mix, unsigned int mux)",
          "103: {",
          "104:  if (mix->mux_table)",
          "105:   return mix->mux_table[mux];",
          "107:  return mux;",
          "108: }",
          "110: static void _filter_clk_table(struct mmp_clk_mix *mix,",
          "111:     struct mmp_clk_mix_clk_table *table,",
          "112:     unsigned int table_size)",
          "113: {",
          "114:  int i;",
          "115:  struct mmp_clk_mix_clk_table *item;",
          "116:  struct clk *parent, *clk;",
          "117:  unsigned long parent_rate;",
          "119:  clk = mix->hw.clk;",
          "121:  for (i = 0; i < table_size; i++) {",
          "122:   item = &table[i];",
          "123:   parent = clk_get_parent_by_index(clk, item->parent_index);",
          "124:   parent_rate = __clk_get_rate(parent);",
          "125:   if (parent_rate % item->rate) {",
          "126:    item->valid = 0;",
          "127:   } else {",
          "128:    item->divisor = parent_rate / item->rate;",
          "129:    item->valid = 1;",
          "130:   }",
          "131:  }",
          "132: }",
          "134: static int _set_rate(struct mmp_clk_mix *mix, u32 mux_val, u32 div_val,",
          "135:    unsigned int change_mux, unsigned int change_div)",
          "136: {",
          "137:  struct mmp_clk_mix_reg_info *ri = &mix->reg_info;",
          "138:  u8 width, shift;",
          "139:  u32 mux_div, fc_req;",
          "140:  int ret, timeout = 50;",
          "141:  unsigned long flags = 0;",
          "143:  if (!change_mux && !change_div)",
          "144:   return -EINVAL;",
          "146:  if (mix->lock)",
          "147:   spin_lock_irqsave(mix->lock, flags);",
          "149:  if (mix->type == MMP_CLK_MIX_TYPE_V1",
          "150:   || mix->type == MMP_CLK_MIX_TYPE_V2)",
          "151:   mux_div = readl(ri->reg_clk_ctrl);",
          "152:  else",
          "153:   mux_div = readl(ri->reg_clk_sel);",
          "155:  if (change_div) {",
          "156:   width = ri->width_div;",
          "157:   shift = ri->shift_div;",
          "158:   mux_div &= ~MMP_CLK_BITS_MASK(width, shift);",
          "159:   mux_div |= MMP_CLK_BITS_SET_VAL(div_val, width, shift);",
          "160:  }",
          "162:  if (change_mux) {",
          "163:   width = ri->width_mux;",
          "164:   shift = ri->shift_mux;",
          "165:   mux_div &= ~MMP_CLK_BITS_MASK(width, shift);",
          "166:   mux_div |= MMP_CLK_BITS_SET_VAL(mux_val, width, shift);",
          "167:  }",
          "169:  if (mix->type == MMP_CLK_MIX_TYPE_V1) {",
          "170:   writel(mux_div, ri->reg_clk_ctrl);",
          "171:  } else if (mix->type == MMP_CLK_MIX_TYPE_V2) {",
          "172:   mux_div |= (1 << ri->bit_fc);",
          "173:   writel(mux_div, ri->reg_clk_ctrl);",
          "175:   do {",
          "176:    fc_req = readl(ri->reg_clk_ctrl);",
          "177:    timeout--;",
          "178:    if (!(fc_req & (1 << ri->bit_fc)))",
          "179:     break;",
          "180:   } while (timeout);",
          "182:   if (timeout == 0) {",
          "183:    pr_err(\"%s:%s cannot do frequency change\\n\",",
          "184:     __func__, __clk_get_name(mix->hw.clk));",
          "185:    ret = -EBUSY;",
          "186:    goto error;",
          "187:   }",
          "188:  } else {",
          "189:   fc_req = readl(ri->reg_clk_ctrl);",
          "190:   fc_req |= 1 << ri->bit_fc;",
          "191:   writel(fc_req, ri->reg_clk_ctrl);",
          "192:   writel(mux_div, ri->reg_clk_sel);",
          "193:   fc_req &= ~(1 << ri->bit_fc);",
          "194:  }",
          "196:  ret = 0;",
          "197: error:",
          "198:  if (mix->lock)",
          "199:   spin_unlock_irqrestore(mix->lock, flags);",
          "201:  return ret;",
          "202: }",
          "204: static long mmp_clk_mix_determine_rate(struct clk_hw *hw, unsigned long rate,",
          "205:      unsigned long *best_parent_rate,",
          "206:      struct clk **best_parent_clk)",
          "207: {",
          "208:  struct mmp_clk_mix *mix = to_clk_mix(hw);",
          "209:  struct mmp_clk_mix_clk_table *item;",
          "210:  struct clk *parent, *parent_best, *mix_clk;",
          "211:  unsigned long parent_rate, mix_rate, mix_rate_best, parent_rate_best;",
          "212:  unsigned long gap, gap_best;",
          "213:  u32 div_val_max;",
          "214:  unsigned int div;",
          "215:  int i, j;",
          "217:  mix_clk = hw->clk;",
          "219:  parent = NULL;",
          "220:  mix_rate_best = 0;",
          "221:  parent_rate_best = 0;",
          "222:  gap_best = rate;",
          "223:  parent_best = NULL;",
          "225:  if (mix->table) {",
          "226:   for (i = 0; i < mix->table_size; i++) {",
          "227:    item = &mix->table[i];",
          "228:    if (item->valid == 0)",
          "229:     continue;",
          "230:    parent = clk_get_parent_by_index(mix_clk,",
          "231:        item->parent_index);",
          "232:    parent_rate = __clk_get_rate(parent);",
          "233:    mix_rate = parent_rate / item->divisor;",
          "234:    gap = abs(mix_rate - rate);",
          "235:    if (parent_best == NULL || gap < gap_best) {",
          "236:     parent_best = parent;",
          "237:     parent_rate_best = parent_rate;",
          "238:     mix_rate_best = mix_rate;",
          "239:     gap_best = gap;",
          "240:     if (gap_best == 0)",
          "241:      goto found;",
          "242:    }",
          "243:   }",
          "244:  } else {",
          "245:   for (i = 0; i < __clk_get_num_parents(mix_clk); i++) {",
          "246:    parent = clk_get_parent_by_index(mix_clk, i);",
          "247:    parent_rate = __clk_get_rate(parent);",
          "248:    div_val_max = _get_maxdiv(mix);",
          "249:    for (j = 0; j < div_val_max; j++) {",
          "250:     div = _get_div(mix, j);",
          "251:     mix_rate = parent_rate / div;",
          "252:     gap = abs(mix_rate - rate);",
          "253:     if (parent_best == NULL || gap < gap_best) {",
          "254:      parent_best = parent;",
          "255:      parent_rate_best = parent_rate;",
          "256:      mix_rate_best = mix_rate;",
          "257:      gap_best = gap;",
          "258:      if (gap_best == 0)",
          "259:       goto found;",
          "260:     }",
          "261:    }",
          "262:   }",
          "263:  }",
          "265: found:",
          "269:  return mix_rate_best;",
          "270: }",
          "272: static int mmp_clk_mix_set_rate_and_parent(struct clk_hw *hw,",
          "273:       unsigned long rate,",
          "274:       unsigned long parent_rate,",
          "275:       u8 index)",
          "276: {",
          "277:  struct mmp_clk_mix *mix = to_clk_mix(hw);",
          "278:  unsigned int div;",
          "279:  u32 div_val, mux_val;",
          "281:  div = parent_rate / rate;",
          "282:  div_val = _get_div_val(mix, div);",
          "283:  mux_val = _get_mux_val(mix, index);",
          "285:  return _set_rate(mix, mux_val, div_val, 1, 1);",
          "286: }",
          "288: static u8 mmp_clk_mix_get_parent(struct clk_hw *hw)",
          "289: {",
          "290:  struct mmp_clk_mix *mix = to_clk_mix(hw);",
          "291:  struct mmp_clk_mix_reg_info *ri = &mix->reg_info;",
          "292:  unsigned long flags = 0;",
          "293:  u32 mux_div = 0;",
          "294:  u8 width, shift;",
          "295:  u32 mux_val;",
          "297:  if (mix->lock)",
          "298:   spin_lock_irqsave(mix->lock, flags);",
          "300:  if (mix->type == MMP_CLK_MIX_TYPE_V1",
          "301:   || mix->type == MMP_CLK_MIX_TYPE_V2)",
          "302:   mux_div = readl(ri->reg_clk_ctrl);",
          "303:  else",
          "304:   mux_div = readl(ri->reg_clk_sel);",
          "306:  if (mix->lock)",
          "307:   spin_unlock_irqrestore(mix->lock, flags);",
          "309:  width = mix->reg_info.width_mux;",
          "310:  shift = mix->reg_info.shift_mux;",
          "312:  mux_val = MMP_CLK_BITS_GET_VAL(mux_div, width, shift);",
          "314:  return _get_mux(mix, mux_val);",
          "315: }",
          "317: static unsigned long mmp_clk_mix_recalc_rate(struct clk_hw *hw,",
          "318:      unsigned long parent_rate)",
          "319: {",
          "320:  struct mmp_clk_mix *mix = to_clk_mix(hw);",
          "321:  struct mmp_clk_mix_reg_info *ri = &mix->reg_info;",
          "322:  unsigned long flags = 0;",
          "323:  u32 mux_div = 0;",
          "324:  u8 width, shift;",
          "325:  unsigned int div;",
          "327:  if (mix->lock)",
          "328:   spin_lock_irqsave(mix->lock, flags);",
          "330:  if (mix->type == MMP_CLK_MIX_TYPE_V1",
          "331:   || mix->type == MMP_CLK_MIX_TYPE_V2)",
          "332:   mux_div = readl(ri->reg_clk_ctrl);",
          "333:  else",
          "334:   mux_div = readl(ri->reg_clk_sel);",
          "336:  if (mix->lock)",
          "337:   spin_unlock_irqrestore(mix->lock, flags);",
          "339:  width = mix->reg_info.width_div;",
          "340:  shift = mix->reg_info.shift_div;",
          "342:  div = _get_div(mix, MMP_CLK_BITS_GET_VAL(mux_div, width, shift));",
          "344:  return parent_rate / div;",
          "345: }",
          "347: static int mmp_clk_set_parent(struct clk_hw *hw, u8 index)",
          "348: {",
          "349:  struct mmp_clk_mix *mix = to_clk_mix(hw);",
          "350:  struct mmp_clk_mix_clk_table *item;",
          "351:  int i;",
          "352:  u32 div_val, mux_val;",
          "354:  if (mix->table) {",
          "355:   for (i = 0; i < mix->table_size; i++) {",
          "356:    item = &mix->table[i];",
          "357:    if (item->valid == 0)",
          "358:     continue;",
          "359:    if (item->parent_index == index)",
          "360:     break;",
          "361:   }",
          "362:   if (i < mix->table_size) {",
          "363:    div_val = _get_div_val(mix, item->divisor);",
          "364:    mux_val = _get_mux_val(mix, item->parent_index);",
          "365:   } else",
          "366:    return -EINVAL;",
          "367:  } else {",
          "368:   mux_val = _get_mux_val(mix, index);",
          "369:   div_val = 0;",
          "370:  }",
          "372:  return _set_rate(mix, mux_val, div_val, 1, div_val ? 1 : 0);",
          "373: }",
          "375: static int mmp_clk_set_rate(struct clk_hw *hw, unsigned long rate,",
          "376:     unsigned long best_parent_rate)",
          "377: {",
          "378:  struct mmp_clk_mix *mix = to_clk_mix(hw);",
          "379:  struct mmp_clk_mix_clk_table *item;",
          "380:  unsigned long parent_rate;",
          "381:  unsigned int best_divisor;",
          "382:  struct clk *mix_clk, *parent;",
          "383:  int i;",
          "385:  best_divisor = best_parent_rate / rate;",
          "387:  mix_clk = hw->clk;",
          "388:  if (mix->table) {",
          "389:   for (i = 0; i < mix->table_size; i++) {",
          "390:    item = &mix->table[i];",
          "391:    if (item->valid == 0)",
          "392:     continue;",
          "393:    parent = clk_get_parent_by_index(mix_clk,",
          "394:        item->parent_index);",
          "395:    parent_rate = __clk_get_rate(parent);",
          "396:    if (parent_rate == best_parent_rate",
          "397:     && item->divisor == best_divisor)",
          "398:     break;",
          "399:   }",
          "400:   if (i < mix->table_size)",
          "401:    return _set_rate(mix,",
          "402:      _get_mux_val(mix, item->parent_index),",
          "403:      _get_div_val(mix, item->divisor),",
          "404:      1, 1);",
          "405:   else",
          "406:    return -EINVAL;",
          "407:  } else {",
          "408:   for (i = 0; i < __clk_get_num_parents(mix_clk); i++) {",
          "409:    parent = clk_get_parent_by_index(mix_clk, i);",
          "410:    parent_rate = __clk_get_rate(parent);",
          "411:    if (parent_rate == best_parent_rate)",
          "412:     break;",
          "413:   }",
          "414:   if (i < __clk_get_num_parents(mix_clk))",
          "415:    return _set_rate(mix, _get_mux_val(mix, i),",
          "416:      _get_div_val(mix, best_divisor), 1, 1);",
          "417:   else",
          "418:    return -EINVAL;",
          "419:  }",
          "420: }",
          "422: static void mmp_clk_mix_init(struct clk_hw *hw)",
          "423: {",
          "424:  struct mmp_clk_mix *mix = to_clk_mix(hw);",
          "426:  if (mix->table)",
          "427:   _filter_clk_table(mix, mix->table, mix->table_size);",
          "428: }",
          "430: const struct clk_ops mmp_clk_mix_ops = {",
          "431:  .determine_rate = mmp_clk_mix_determine_rate,",
          "432:  .set_rate_and_parent = mmp_clk_mix_set_rate_and_parent,",
          "433:  .set_rate = mmp_clk_set_rate,",
          "434:  .set_parent = mmp_clk_set_parent,",
          "435:  .get_parent = mmp_clk_mix_get_parent,",
          "436:  .recalc_rate = mmp_clk_mix_recalc_rate,",
          "437:  .init = mmp_clk_mix_init,",
          "438: };",
          "440: struct clk *mmp_clk_register_mix(struct device *dev,",
          "441:      const char *name,",
          "442:      const char **parent_names,",
          "443:      u8 num_parents,",
          "444:      unsigned long flags,",
          "445:      struct mmp_clk_mix_config *config,",
          "446:      spinlock_t *lock)",
          "447: {",
          "448:  struct mmp_clk_mix *mix;",
          "449:  struct clk *clk;",
          "450:  struct clk_init_data init;",
          "451:  size_t table_bytes;",
          "453:  mix = kzalloc(sizeof(*mix), GFP_KERNEL);",
          "454:  if (!mix) {",
          "455:   pr_err(\"%s:%s: could not allocate mmp mix clk\\n\",",
          "456:    __func__, name);",
          "457:   return ERR_PTR(-ENOMEM);",
          "458:  }",
          "460:  init.name = name;",
          "461:  init.flags = flags | CLK_GET_RATE_NOCACHE;",
          "462:  init.parent_names = parent_names;",
          "463:  init.num_parents = num_parents;",
          "464:  init.ops = &mmp_clk_mix_ops;",
          "466:  memcpy(&mix->reg_info, &config->reg_info, sizeof(config->reg_info));",
          "467:  if (config->table) {",
          "468:   table_bytes = sizeof(*config->table) * config->table_size;",
          "469:   mix->table = kzalloc(table_bytes, GFP_KERNEL);",
          "470:   if (!mix->table) {",
          "471:    pr_err(\"%s:%s: could not allocate mmp mix table\\n\",",
          "472:     __func__, name);",
          "473:    kfree(mix);",
          "474:    return ERR_PTR(-ENOMEM);",
          "475:   }",
          "476:   memcpy(mix->table, config->table, table_bytes);",
          "477:   mix->table_size = config->table_size;",
          "478:  }",
          "480:  if (config->mux_table) {",
          "481:   table_bytes = sizeof(u32) * num_parents;",
          "482:   mix->mux_table = kzalloc(table_bytes, GFP_KERNEL);",
          "483:   if (!mix->mux_table) {",
          "484:    pr_err(\"%s:%s: could not allocate mmp mix mux-table\\n\",",
          "485:     __func__, name);",
          "486:    kfree(mix->table);",
          "487:    kfree(mix);",
          "488:    return ERR_PTR(-ENOMEM);",
          "489:   }",
          "490:   memcpy(mix->mux_table, config->mux_table, table_bytes);",
          "491:  }",
          "493:  mix->div_flags = config->div_flags;",
          "494:  mix->mux_flags = config->mux_flags;",
          "495:  mix->lock = lock;",
          "496:  mix->hw.init = &init;",
          "498:  if (config->reg_info.bit_fc >= 32)",
          "499:   mix->type = MMP_CLK_MIX_TYPE_V1;",
          "500:  else if (config->reg_info.reg_clk_sel)",
          "501:   mix->type = MMP_CLK_MIX_TYPE_V3;",
          "502:  else",
          "503:   mix->type = MMP_CLK_MIX_TYPE_V2;",
          "504:  clk = clk_register(dev, &mix->hw);",
          "506:  if (IS_ERR(clk)) {",
          "507:   kfree(mix->mux_table);",
          "508:   kfree(mix->table);",
          "509:   kfree(mix);",
          "510:  }",
          "512:  return clk;",
          "513: }",
          "",
          "---------------"
        ],
        "drivers/clk/mmp/clk.h||drivers/clk/mmp/clk.h": [
          "File: drivers/clk/mmp/clk.h -> drivers/clk/mmp/clk.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "37:   struct mmp_clk_factor_tbl *ftbl, unsigned int ftbl_cnt,",
          "38:   spinlock_t *lock);",
          "40: extern struct clk *mmp_clk_register_pll2(const char *name,",
          "41:   const char *parent_name, unsigned long flags);",
          "42: extern struct clk *mmp_clk_register_apbc(const char *name,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "41: #define MMP_CLK_BITS_MASK(width, shift)   \\",
          "42:   (((1 << (width)) - 1) << (shift))",
          "43: #define MMP_CLK_BITS_GET_VAL(data, width, shift) \\",
          "44:   ((data & MMP_CLK_BITS_MASK(width, shift)) >> (shift))",
          "45: #define MMP_CLK_BITS_SET_VAL(val, width, shift)  \\",
          "46:   (((val) << (shift)) & MMP_CLK_BITS_MASK(width, shift))",
          "48: enum {",
          "49:  MMP_CLK_MIX_TYPE_V1,",
          "50:  MMP_CLK_MIX_TYPE_V2,",
          "51:  MMP_CLK_MIX_TYPE_V3,",
          "52: };",
          "55: struct mmp_clk_mix_reg_info {",
          "56:  void __iomem *reg_clk_ctrl;",
          "57:  void __iomem *reg_clk_sel;",
          "58:  u8 width_div;",
          "59:  u8 shift_div;",
          "60:  u8 width_mux;",
          "61:  u8 shift_mux;",
          "62:  u8 bit_fc;",
          "63: };",
          "66: struct mmp_clk_mix_clk_table {",
          "67:  unsigned long rate;",
          "68:  u8 parent_index;",
          "69:  unsigned int divisor;",
          "70:  unsigned int valid;",
          "71: };",
          "73: struct mmp_clk_mix_config {",
          "74:  struct mmp_clk_mix_reg_info reg_info;",
          "75:  struct mmp_clk_mix_clk_table *table;",
          "76:  unsigned int table_size;",
          "77:  u32 *mux_table;",
          "78:  struct clk_div_table *div_table;",
          "79:  u8 div_flags;",
          "80:  u8 mux_flags;",
          "81: };",
          "83: struct mmp_clk_mix {",
          "84:  struct clk_hw hw;",
          "85:  struct mmp_clk_mix_reg_info reg_info;",
          "86:  struct mmp_clk_mix_clk_table *table;",
          "87:  u32 *mux_table;",
          "88:  struct clk_div_table *div_table;",
          "89:  unsigned int table_size;",
          "90:  u8 div_flags;",
          "91:  u8 mux_flags;",
          "92:  unsigned int type;",
          "93:  spinlock_t *lock;",
          "94: };",
          "96: extern const struct clk_ops mmp_clk_mix_ops;",
          "97: extern struct clk *mmp_clk_register_mix(struct device *dev,",
          "98:      const char *name,",
          "99:      u8 num_parents,",
          "100:      const char **parent_names,",
          "101:      unsigned long flags,",
          "102:      struct mmp_clk_mix_config *config,",
          "103:      spinlock_t *lock);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "09712f557b31838092e1f22a5f2dd131a843a3de",
      "candidate_info": {
        "commit_hash": "09712f557b31838092e1f22a5f2dd131a843a3de",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/09712f557b31838092e1f22a5f2dd131a843a3de",
        "files": [
          "drivers/cpufreq/cpufreq.c"
        ],
        "message": "cpufreq: Avoid crash in resume on SMP without OPP\n\nWhen resuming from s2ram on an SMP system without cpufreq operating\npoints (e.g. there's no \"operating-points\" property for the CPU node in\nDT, or the platform doesn't use DT yet), the kernel crashes when\nbringing CPU 1 online:\n\n    Enabling non-boot CPUs ...\n    CPU1: Booted secondary processor\n    Unable to handle kernel NULL pointer dereference at virtual address 0000003c\n    pgd = ee5e6b00\n    [0000003c] *pgd=6e579003, *pmd=6e588003, *pte=00000000\n    Internal error: Oops: a07 [#1] SMP ARM\n    Modules linked in:\n    CPU: 0 PID: 1246 Comm: s2ram Tainted: G        W      3.18.0-rc3-koelsch-01614-g0377af242bb175c8-dirty #589\n    task: eeec5240 ti: ee704000 task.ti: ee704000\n    PC is at __cpufreq_add_dev.isra.24+0x24c/0x77c\n    LR is at __cpufreq_add_dev.isra.24+0x244/0x77c\n    pc : [<c0298efc>]    lr : [<c0298ef4>]    psr: 60000153\n    sp : ee705d48  ip : ee705d48  fp : ee705d84\n    r10: c04e0450  r9 : 00000000  r8 : 00000001\n    r7 : c05426a8  r6 : 00000001  r5 : 00000001  r4 : 00000000\n    r3 : 00000000  r2 : 00000000  r1 : 20000153  r0 : c0542734\n\nVerify that policy is not NULL before dereferencing it to fix this.\n\nSigned-off-by: Geert Uytterhoeven <geert+renesas@glider.be>\nFixes: 8414809c6a1e (cpufreq: Preserve policy structure across suspend/resume)\nCc: 3.12+ <stable@vger.kernel.org> # 3.12+\nSigned-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>",
        "before_after_code_files": [
          "drivers/cpufreq/cpufreq.c||drivers/cpufreq/cpufreq.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/cpufreq/cpufreq.c||drivers/cpufreq/cpufreq.c": [
          "File: drivers/cpufreq/cpufreq.c -> drivers/cpufreq/cpufreq.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1023:  read_unlock_irqrestore(&cpufreq_driver_lock, flags);",
          "1027:  return policy;",
          "1028: }",
          "",
          "[Removed Lines]",
          "1025:  policy->governor = NULL;",
          "",
          "[Added Lines]",
          "1025:  if (policy)",
          "1026:   policy->governor = NULL;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b5c16a60e5ecd57b7b854cc7f9d875d0cc62034c",
      "candidate_info": {
        "commit_hash": "b5c16a60e5ecd57b7b854cc7f9d875d0cc62034c",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/b5c16a60e5ecd57b7b854cc7f9d875d0cc62034c",
        "files": [
          "drivers/mmc/host/mmci.c"
        ],
        "message": "mmc: mmci: fix mmci_post_request\n\nIf the post request is cancelling the channel and descriptor and which are\nequal to host->dma_current and host->dma_desc_current respectively, then it\nmakes sense to reset these pointers to NULL, so that the driver does not\nreference it.\n\nAlso the host_cookie can be reset to 0 in cases of error, so that the\ncore could reissue the same mmc_request.\n\nThis patch was tested with 'mmc: core: fix prepared requests while doing\nbkops' to fix the below issue.\n\nmmci-pl18x 12400000.sdcc: error during DMA transfer!\nUnable to handle kernel paging request at virtual address 40000000\npgd = c0204000\n[40000000] *pgd=00000000\nInternal error: Oops: 805 [#1] SMP ARM\nModules linked in: ipv6 ath6kl_sdio ath6kl_core\nCPU: 0 PID: 0 Comm: swapper/0 Tainted: G        W      3.17.0-rc7-linaro-multi-v7 #1\ntask: c0c9d7e0 ti: c0c92000 task.ti: c0c92000\nPC is at v7_dma_inv_range+0x34/0x4c\nLR is at __dma_page_dev_to_cpu+0x80/0x100\npc : [<c021efc0>]    lr : [<c021af18>]    psr: 400f0193\nsp : c0c93e20  ip : c0c9a478  fp : c08ea538\nr10: c0c9f548  r9 : 00000002  r8 : e97d9000\nr7 : 00000200  r6 : c0c9d504  r5 : c0db0880  r4 : 00000000\nr3 : 0000003f  r2 : 00000040  r1 : 40000200  r0 : 40000000\nFlags: nZcv  IRQs off  FIQs on  Mode SVC_32  ISA ARM  Segment kernel\nControl: 10c5787d  Table: a9ef406a  DAC: 00000015\nProcess swapper/0 (pid: 0, stack limit = 0xc0c92250)\nStack: (0xc0c93e20 to 0xc0c94000)\n3e20: c021f058 e9a17178 e9a171bc e99dfd6c 00000001 00000001 e995de10 00000002\n3e40: 00000000 c021b574 00000000 c04bc4a4 00000000 e9b49ac0 c0ce6e6c e99dfda4\n3e60: 00000088 e9810780 c0d8291c c072ea58 00000000 c072d3fc 00000000 c072f534\n3e80: 00000000 e9b49ac0 00000100 c0c9a444 00000088 c072f6b4 c072f5d4 e9d40080\n3ea0: e98107dc 00000000 00000000 c0280a60 00000000 7d55bf61 e9810780 e98107dc\n3ec0: 00000000 f0002000 c0d460e8 c0d460e8 c0c92000 c0280b60 e9810780 c0ce7190\n3ee0: 00000000 c028369c c02835f4 00000088 00000088 c0280278 c0c8ec70 c020f080\n3f00: f000200c c0c9a958 c0c93f28 c02088e4 c04bd630 c04bd5bc 200f0013 ffffffff\n3f20: c0c93f5c c0212800 00000001 a987c000 c0c93f3c c04bd574 00000000 0000015b\n3f40: ea7a0e40 00000000 c0d460e8 c0d460e8 c0c92000 c08ea538 29b12000 c0c93f70\n3f60: c04bd630 c04bd5bc 200f0013 ffffffff c04bd574 c071bd24 7d50c9b4 c0719a44\n3f80: 7d50c9b4 0000015b c0c9a498 c0c92028 c0c9a498 c0c9a4fc ea7a0e40 c0c8ee38\n3fa0: c0d460e8 c0276198 00000000 c0d8291a 00000000 c0c9a400 00000000 c0be0bc4\n3fc0: ffffffff ffffffff c0be05f8 00000000 00000000 c0c533d8 c0d82ed4 c0c9a47c\n3fe0: c0c533d4 c0c9e870 8020406a 511f06f0 00000000 80208074 00000000 00000000\n[<c021efc0>] (v7_dma_inv_range) from [<c021af18>] (__dma_page_dev_to_cpu+0x80/0x100)\n[<c021af18>] (__dma_page_dev_to_cpu) from [<c021b574>] (arm_dma_unmap_sg+0x5c/0x84)\n[<c021b574>] (arm_dma_unmap_sg) from [<c072ea58>] (mmci_dma_unmap.isra.16+0x60/0x74)\n[<c072ea58>] (mmci_dma_unmap.isra.16) from [<c072f534>] (mmci_data_irq+0x1fc/0x29c)\n[<c072f534>] (mmci_data_irq) from [<c072f6b4>] (mmci_irq+0xe0/0x114)\n[<c072f6b4>] (mmci_irq) from [<c0280a60>] (handle_irq_event_percpu+0x78/0x134)\n[<c0280a60>] (handle_irq_event_percpu) from [<c0280b60>] (handle_irq_event+0x44/0x64)\n[<c0280b60>] (handle_irq_event) from [<c028369c>] (handle_fasteoi_irq+0xa8/0x1a8)\n[<c028369c>] (handle_fasteoi_irq) from [<c0280278>] (generic_handle_irq+0x2c/0x3c)\n[<c0280278>] (generic_handle_irq) from [<c020f080>] (handle_IRQ+0x40/0x90)\n[<c020f080>] (handle_IRQ) from [<c02088e4>] (gic_handle_irq+0x38/0x68)\n[<c02088e4>] (gic_handle_irq) from [<c0212800>] (__irq_svc+0x40/0x54)\nException stack(0xc0c93f28 to 0xc0c93f70)\n3f20:                   00000001 a987c000 c0c93f3c c04bd574 00000000 0000015b\n3f40: ea7a0e40 00000000 c0d460e8 c0d460e8 c0c92000 c08ea538 29b12000 c0c93f70\n3f60: c04bd630 c04bd5bc 200f0013 ffffffff\n[<c0212800>] (__irq_svc) from [<c04bd5bc>] (msm_cpu_pm_enter_sleep+0x48/0x4c)\n[<c04bd5bc>] (msm_cpu_pm_enter_sleep) from [<c071bd24>] (qcom_lpm_enter_spc+0x20/0x2c)\n[<c071bd24>] (qcom_lpm_enter_spc) from [<c0719a44>] (cpuidle_enter_state+0x44/0xf0)\n[<c0719a44>] (cpuidle_enter_state) from [<c0276198>] (cpu_startup_entry+0x1f4/0x238)\n[<c0276198>] (cpu_startup_entry) from [<c0be0bc4>] (start_kernel+0x384/0x390)\nCode: 1e070f3e e1110003 e1c11003 1e071f3e (ee070f36)\n---[ end trace cf6cb3f6432c9834 ]---\nKernel panic - not syncing: Fatal exception in interrupt\n\nSigned-off-by: Srinivas Kandagatla <srinivas.kandagatla@linaro.org>\nSigned-off-by: Ulf Hansson <ulf.hansson@linaro.org>",
        "before_after_code_files": [
          "drivers/mmc/host/mmci.c||drivers/mmc/host/mmci.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/mmc/host/mmci.c||drivers/mmc/host/mmci.c": [
          "File: drivers/mmc/host/mmci.c -> drivers/mmc/host/mmci.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "736:    chan = host->dma_tx_channel;",
          "737:   dmaengine_terminate_all(chan);",
          "739:   next->dma_desc = NULL;",
          "740:   next->dma_chan = NULL;",
          "741:  }",
          "742: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "739:   if (host->dma_desc_current == next->dma_desc)",
          "740:    host->dma_desc_current = NULL;",
          "742:   if (host->dma_current == next->dma_chan)",
          "743:    host->dma_current = NULL;",
          "747:   data->host_cookie = 0;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
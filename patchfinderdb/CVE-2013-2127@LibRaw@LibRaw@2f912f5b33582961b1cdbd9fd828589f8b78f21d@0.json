{
  "cve_id": "CVE-2013-2127",
  "cve_desc": "Buffer overflow in the exposure correction code in LibRaw before 0.15.1 allows context-dependent attackers to cause a denial of service (crash) and possibly execute arbitrary code via unspecified vectors.",
  "repo": "LibRaw/LibRaw",
  "patch_hash": "2f912f5b33582961b1cdbd9fd828589f8b78f21d",
  "patch_info": {
    "commit_hash": "2f912f5b33582961b1cdbd9fd828589f8b78f21d",
    "repo": "LibRaw/LibRaw",
    "commit_url": "https://github.com/LibRaw/LibRaw/commit/2f912f5b33582961b1cdbd9fd828589f8b78f21d",
    "files": [
      "src/libraw_cxx.cpp"
    ],
    "message": "fixed wrong data_maximum calcluation; prevent out-of-buffer in exp_bef",
    "before_after_code_files": [
      "src/libraw_cxx.cpp||src/libraw_cxx.cpp"
    ]
  },
  "patch_diff": {
    "src/libraw_cxx.cpp||src/libraw_cxx.cpp": [
      "File: src/libraw_cxx.cpp -> src/libraw_cxx.cpp",
      "--- Hunk 1 ---",
      "[Context before]",
      "2336: #define MAX(a,b) ((a) > (b) ? (a) : (b))",
      "2337: #define LIM(x,min,max) MAX(min,MIN(x,max))",
      "2338: #define CLIP(x) LIM(x,0,65535)",
      "2341:               {",
      "2342:                 int val = imgdata.image[0][i];",
      "2343:                 val -= cblk[i & 3];",
      "2344:                 imgdata.image[0][i] = CLIP(val);",
      "2346:               }",
      "2347: #undef MIN",
      "2348: #undef MAX",
      "2349: #undef LIM",
      "",
      "[Removed Lines]",
      "2340:             for(i=0; i< size*4; i++)",
      "2345:                 if(C.data_maximum < val) C.data_maximum = val;",
      "",
      "[Added Lines]",
      "2339:    int dmax = 0;",
      "2340:    for(i=0; i< size*4; i++)",
      "2345:                 if(dmax < val) dmax = val;",
      "2347:    C.data_maximum = dmax & 0xffff;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "2360:           int idx;",
      "2361:           ushort *p = (ushort*)imgdata.image;",
      "2363:           for(idx=0;idx<S.iheight*S.iwidth*4;idx++)",
      "2365:         }",
      "2366:   return 0;",
      "2367:  }",
      "",
      "[Removed Lines]",
      "2362:           C.data_maximum = 0;",
      "2364:             if(C.data_maximum < p[idx]) C.data_maximum = p[idx];",
      "",
      "[Added Lines]",
      "2363:     int dmax = 0;",
      "2365:             if(dmax < p[idx]) dmax = p[idx];",
      "2366:     C.data_maximum = dmax;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "2421:             imgdata.image[i][3] = lut[imgdata.image[i][3]];",
      "2422:         }",
      "2427:     free(lut);",
      "2428: }",
      "",
      "[Removed Lines]",
      "2424:     C.data_maximum = lut[C.data_maximum];",
      "2425:     C.maximum = lut[C.maximum];",
      "",
      "[Added Lines]",
      "2426:  if(C.data_maximum <=TBLN)",
      "2427:   C.data_maximum = lut[C.data_maximum];",
      "2428:  if(C.maximum <= TBLN)",
      "2429:   C.maximum = lut[C.maximum];",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "2531:         raw2image_ex(subtract_inline); // allocate imgdata.image and copy data!",
      "2535:         if (IO.zero_is_bad)",
      "2536:           {",
      "",
      "[Removed Lines]",
      "2533:         int save_4color = O.four_color_rgb;",
      "",
      "[Added Lines]",
      "2537:   int save_4color = O.four_color_rgb;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "d7fda156ff7e54f1b93bc24ce921f73c8f7109ec",
      "candidate_info": {
        "commit_hash": "d7fda156ff7e54f1b93bc24ce921f73c8f7109ec",
        "repo": "LibRaw/LibRaw",
        "commit_url": "https://github.com/LibRaw/LibRaw/commit/d7fda156ff7e54f1b93bc24ce921f73c8f7109ec",
        "files": [
          "Changelog.txt",
          "libraw/libraw_types.h",
          "src/libraw_cxx.cpp"
        ],
        "message": "subtract_black() works again",
        "before_after_code_files": [
          "libraw/libraw_types.h||libraw/libraw_types.h",
          "src/libraw_cxx.cpp||src/libraw_cxx.cpp"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/libraw_cxx.cpp||src/libraw_cxx.cpp"
          ],
          "candidate": [
            "src/libraw_cxx.cpp||src/libraw_cxx.cpp"
          ]
        }
      },
      "candidate_diff": {
        "libraw/libraw_types.h||libraw/libraw_types.h": [
          "File: libraw/libraw_types.h -> libraw/libraw_types.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "185: typedef struct",
          "186: {",
          "204: }libraw_colordata_t;",
          "206: typedef struct",
          "",
          "[Removed Lines]",
          "187:  ushort      curve[0x10000];",
          "188:  unsigned    cblack[4];",
          "189:  unsigned    black;",
          "190:  unsigned    maximum;",
          "191:  unsigned    channel_maximum[4];",
          "192:     ushort      white[8][8];",
          "193:     float       cam_mul[4];",
          "194:     float       pre_mul[4];",
          "195:     float       cmatrix[3][4];",
          "196:     float       rgb_cam[3][4];",
          "197:     float       cam_xyz[4][3];",
          "198:     struct ph1_t       phase_one_data;",
          "199:     float       flash_used;",
          "200:     float       canon_ev;",
          "201:     char        model2[64];",
          "202:     void        *profile;",
          "203:     unsigned    profile_length;",
          "",
          "[Added Lines]",
          "187:   ushort      curve[0x10000];",
          "188:   unsigned    cblack[4];",
          "189:   unsigned    black;",
          "190:   unsigned    data_maximum;",
          "191:   unsigned    maximum;",
          "192:   ushort      white[8][8];",
          "193:   float       cam_mul[4];",
          "194:   float       pre_mul[4];",
          "195:   float       cmatrix[3][4];",
          "196:   float       rgb_cam[3][4];",
          "197:   float       cam_xyz[4][3];",
          "198:   struct ph1_t       phase_one_data;",
          "199:   float       flash_used;",
          "200:   float       canon_ev;",
          "201:   char        model2[64];",
          "202:   void        *profile;",
          "203:   unsigned    profile_length;",
          "",
          "---------------"
        ],
        "src/libraw_cxx.cpp||src/libraw_cxx.cpp": [
          "File: src/libraw_cxx.cpp -> src/libraw_cxx.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "481:             d_info->decoder_name = \"sony_arw2_load_raw()\";",
          "482:             d_info->decoder_flags = LIBRAW_DECODER_FLATFIELD;",
          "483:             d_info->decoder_flags |= LIBRAW_DECODER_HASCURVE;",
          "485:         }",
          "486:     else if (load_raw == &LibRaw::smal_v6_load_raw )",
          "487:         {",
          "",
          "[Removed Lines]",
          "484:    d_info->decoder_flags |= LIBRAW_DECODER_ITSASONY;",
          "",
          "[Added Lines]",
          "484:             d_info->decoder_flags |= LIBRAW_DECODER_ITSASONY;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "533:         auto_threshold = O.adjust_maximum_thr;",
          "541:     if (real_max > 0 && real_max < C.maximum && real_max > C.maximum* auto_threshold)",
          "542:         {",
          "543:             C.maximum = real_max;",
          "",
          "[Removed Lines]",
          "536:     real_max = C.channel_maximum[0];",
          "537:     for(i = 1; i< 4; i++)",
          "538:         if(real_max < C.channel_maximum[i])",
          "539:             real_max = C.channel_maximum[i];",
          "",
          "[Added Lines]",
          "536:     real_max = C.data_maximum;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "826:                 imgdata.rawdata.color_image = (ushort (*)[4]) imgdata.rawdata.raw_alloc;",
          "827:             }",
          "883:         S.iwidth = save_iwidth;",
          "884:         S.iheight = save_iheight;",
          "",
          "[Removed Lines]",
          "830:         {",
          "831:             for(int c=0;c<4;c++) C.channel_maximum[c] = 0;",
          "832:             if(decoder_info.decoder_flags & LIBRAW_DECODER_LEGACY)",
          "833:                 {",
          "834:                     for(int rc = 0; rc < S.iwidth*S.iheight; rc++)",
          "835:                         {",
          "836:                             if(C.channel_maximum[0]<imgdata.rawdata.color_image[rc][0])",
          "837:                                 C.channel_maximum[0]=imgdata.rawdata.color_image[rc][0];",
          "838:                             if(C.channel_maximum[1]<imgdata.rawdata.color_image[rc][1])",
          "839:                                 C.channel_maximum[1]=imgdata.rawdata.color_image[rc][1];",
          "840:                             if(C.channel_maximum[2]<imgdata.rawdata.color_image[rc][2])",
          "841:                                 C.channel_maximum[2]=imgdata.rawdata.color_image[rc][2];",
          "842:                             if(C.channel_maximum[3]<imgdata.rawdata.color_image[rc][3])",
          "843:                                 C.channel_maximum[3]=imgdata.rawdata.color_image[rc][3];",
          "844:                         }",
          "845:                 }",
          "846:             else if (decoder_info.decoder_flags &  LIBRAW_DECODER_FLATFIELD)",
          "847:                 {",
          "848:                   if(IO.fuji_width)",
          "849:                     {",
          "850:                       for(int row=0; row < S.raw_height-S.top_margin*2; row++)",
          "851:                             {",
          "852:                                 int colors[4];",
          "853:                                 for (int xx=0;xx<4;xx++)",
          "854:                                   colors[xx] = FCF(row,xx);",
          "855:                                 for(int col=0; col < IO.fuji_width << !libraw_internal_data.unpacker_data.fuji_layout; col++)",
          "856:                                     {",
          "857:                                       int cc = colors[col&3];",
          "858:                                         if(C.channel_maximum[cc]",
          "859:                                            < imgdata.rawdata.raw_image[(row+S.top_margin)*S.raw_width+(col+S.left_margin)])",
          "860:                                           C.channel_maximum[cc] =",
          "861:                                                 imgdata.rawdata.raw_image[(row+S.top_margin)*S.raw_width+(col+S.left_margin)];",
          "862:                                     }",
          "863:                             }",
          "864:                     }",
          "865:                   else",
          "866:                     {",
          "867:                       for (int row=0; row < S.height; row++)",
          "868:                         {",
          "869:                                 int colors[48];",
          "870:                                 for (int xx=0;xx<48;xx++)",
          "871:                                   colors[xx] =fcol(row,xx);",
          "872:                                 for (int col=0; col < S.width; col++)",
          "873:                                   {",
          "874:                                       int cc = colors[col%48];",
          "875:                                       if(C.channel_maximum[cc]  < imgdata.rawdata.raw_image[(row+S.top_margin)*S.raw_width+(col+S.left_margin)])",
          "876:                                         C.channel_maximum[cc]  = imgdata.rawdata.raw_image[(row+S.top_margin)*S.raw_width+(col+S.left_margin)];",
          "877:                                   }",
          "878:                         }",
          "879:                     }",
          "880:                 }",
          "881:         }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1025:         EXCEPTION_HANDLER(err);",
          "1026:     }",
          "1027: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "972: int LibRaw::raw2image_ex(void)",
          "973: {",
          "975:     CHECK_ORDER_LOW(LIBRAW_PROGRESS_LOAD_RAW);",
          "977:     try {",
          "978:         raw2image_start();",
          "981:         if(imgdata.image)",
          "982:             {",
          "983:                 imgdata.image = (ushort (*)[4]) realloc (imgdata.image,S.iheight*S.iwidth *sizeof (*imgdata.image));",
          "984:                 memset(imgdata.image,0,S.iheight*S.iwidth *sizeof (*imgdata.image));",
          "985:             }",
          "986:         else",
          "987:             imgdata.image = (ushort (*)[4]) calloc (S.iheight*S.iwidth, sizeof (*imgdata.image));",
          "989:         merror (imgdata.image, \"raw2image_ex()\");",
          "991:         libraw_decoder_info_t decoder_info;",
          "992:         get_decoder_info(&decoder_info);",
          "995:         if(decoder_info.decoder_flags & LIBRAW_DECODER_FLATFIELD)",
          "996:             {",
          "997:               if (IO.fuji_width) {",
          "998:                 unsigned r,c;",
          "999:                 int row,col;",
          "1000:                 for (row=0; row < S.raw_height-S.top_margin*2; row++)",
          "1001:                   {",
          "1002:                     for (col=0; col < IO.fuji_width << !libraw_internal_data.unpacker_data.fuji_layout; col++)",
          "1003:                       {",
          "1004:                         if (libraw_internal_data.unpacker_data.fuji_layout) {",
          "1005:                           r = IO.fuji_width - 1 - col + (row >> 1);",
          "1006:                           c = col + ((row+1) >> 1);",
          "1007:                         } else {",
          "1008:                           r = IO.fuji_width - 1 + row - (col >> 1);",
          "1009:                           c = row + ((col+1) >> 1);",
          "1010:                         }",
          "1011:                         if (r < S.height && c < S.width)",
          "1012:                           {",
          "1013:                             imgdata.image[((r)>>IO.shrink)*S.iwidth+((c)>>IO.shrink)][FC(r,c)]",
          "1014:                               = imgdata.rawdata.raw_image[(row+S.top_margin)*S.raw_width+(col+S.left_margin)];",
          "1015:                           }",
          "1016:                       }",
          "1017:                   }",
          "1018:               } // end Fuji",
          "1019:               else {",
          "1020:                 int row,col;",
          "1021:                 for (row=0; row < S.height; row++)",
          "1022:                   for (col=0; col < S.width; col++)",
          "1023:                     imgdata.image[((row) >> IO.shrink)*S.iwidth + ((col) >> IO.shrink)][fcol(row,col)]",
          "1024:                         = imgdata.rawdata.raw_image[(row+S.top_margin)*S.raw_width+(col+S.left_margin)];",
          "1025:               }",
          "1026:             }",
          "1027:         else if(decoder_info.decoder_flags & LIBRAW_DECODER_LEGACY)",
          "1028:             {",
          "1030:                 memmove(imgdata.image,imgdata.rawdata.color_image,S.width*S.height*sizeof(*imgdata.image));",
          "1031:             }",
          "1034:         imgdata.progress_flags",
          "1035:             = LIBRAW_PROGRESS_START|LIBRAW_PROGRESS_OPEN",
          "1036:             |LIBRAW_PROGRESS_IDENTIFY|LIBRAW_PROGRESS_SIZE_ADJUST|LIBRAW_PROGRESS_LOAD_RAW;",
          "1037:         return 0;",
          "1038:     }",
          "1039:     catch ( LibRaw_exceptions err) {",
          "1040:         EXCEPTION_HANDLER(err);",
          "1041:     }",
          "1042: }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1620: void LibRaw::subtract_black()",
          "1621: {",
          "1625:     if((C.cblack[0] || C.cblack[1] || C.cblack[2] || C.cblack[3]))",
          "1626:         {",
          "1627:             int cblk[4],i,row,col,val,cc;",
          "1628:             for(i=0;i<4;i++)",
          "1629:                 cblk[i] = C.cblack[i];",
          "1632:             for(row=0;row<S.height;row++)",
          "1633:                 for(col=0;col<S.width;col++)",
          "",
          "[Removed Lines]",
          "1622: #if 1",
          "1623: #define BAYERC(row,col,c) imgdata.image[((row) >> IO.shrink)*S.iwidth + ((col) >> IO.shrink)][c]",
          "1630:             ZERO(C.channel_maximum);",
          "",
          "[Added Lines]",
          "1640: #define BAYERC(row,col,c) imgdata.image[((row) >> IO.shrink)*S.iwidth + ((col) >> IO.shrink)][c]",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1638:                             val -= cblk[cc];",
          "1639:                         else",
          "1640:                             val = 0;",
          "1642:                         BAYERC(row,col,cc) = val;",
          "1643:                     }",
          "1644:             C.maximum -= C.black;",
          "1645:             ZERO(C.cblack);",
          "1646:             C.black = 0;",
          "1647:         }",
          "1648:     else",
          "1649:         {",
          "1664:         }",
          "1667: }",
          "1669: #define TBLN 65535",
          "",
          "[Removed Lines]",
          "1641:                         if(C.channel_maximum[cc] < val) C.channel_maximum[cc] = val;",
          "1651: #if 0",
          "1653:             int row,col,cc;",
          "1654:             ZERO(C.channel_maximum);",
          "1655:             for(row=0;row<S.height;row++)",
          "1656:                 for(col=0;col<S.width;col++)",
          "1657:                     for(cc = 0; cc< 4; cc++)",
          "1658:                         {",
          "1659:                             int val = BAYERC(row,col,cc);",
          "1660:                             if(C.channel_maximum[cc] < val) C.channel_maximum[cc] = val;",
          "1661:                         }",
          "1662: #endif",
          "1665: #undef BAYERC",
          "1666: #endif",
          "",
          "[Added Lines]",
          "1654:                         if(C.data_maximum < val) C.data_maximum = val;",
          "1660: #undef BAYERC",
          "1666:             int idx;",
          "1667:             ushort *p = (ushort*)imgdata.image;",
          "1668:             C.data_maximum = 0;",
          "1669:             for(idx=0;idx<S.height*S.width*4;idx++)",
          "1670:               if(C.data_maximum < p[idx]) C.data_maximum = p[idx];",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1715:             imgdata.image[i][2] = lut[imgdata.image[i][2]];",
          "1716:             imgdata.image[i][3] = lut[imgdata.image[i][3]];",
          "1717:         }",
          "1720:     C.maximum = lut[C.maximum];",
          "1722:     free(lut);",
          "",
          "[Removed Lines]",
          "1718:     for(int i=0;i<4;i++)",
          "1719:         C.channel_maximum[i] = lut[C.channel_maximum[i]];",
          "",
          "[Added Lines]",
          "1724:     C.data_maximum = lut[C.data_maximum];",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1787:         if (~O.cropbox[2] && ~O.cropbox[3])",
          "1788:             no_crop=0;",
          "1789: #endif",
          "1792:         int save_4color = O.four_color_rgb;",
          "",
          "[Removed Lines]",
          "1790:         raw2image(); // allocate imgdata.image and copy data!",
          "",
          "[Added Lines]",
          "1796:         raw2image_ex(); // allocate imgdata.image and copy data!",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1822:         if (O.user_qual >= 0) quality = O.user_qual;",
          "1825:         i = C.cblack[3];",
          "1826:         int c;",
          "1827:         for(c=0;c<3;c++) if (i > C.cblack[c]) i = C.cblack[c];",
          "",
          "[Removed Lines]",
          "1824: #if 1",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1830:         if (O.user_black >= 0) C.black = O.user_black;",
          "1831:         for(c=0;c<4;c++) C.cblack[c] += C.black;",
          "1841:         adjust_maximum();",
          "",
          "[Removed Lines]",
          "1833:         printf(\"I'm here!\\n\");",
          "1834: #endif",
          "1836: #if 1",
          "1837:         if(!IO.fuji_width)",
          "1838:           subtract_black();",
          "1839: #endif",
          "",
          "[Added Lines]",
          "1838:         printf(\"cblack calculated again: %d %d %d %d\\n\",C.cblack[0],C.cblack[1],C.cblack[2],C.cblack[3]);",
          "1840:         subtract_black();",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "0871f9f0a3c7dd565442b4cfcf88fda3ba39d333",
      "candidate_info": {
        "commit_hash": "0871f9f0a3c7dd565442b4cfcf88fda3ba39d333",
        "repo": "LibRaw/LibRaw",
        "commit_url": "https://github.com/LibRaw/LibRaw/commit/0871f9f0a3c7dd565442b4cfcf88fda3ba39d333",
        "files": [
          "src/libraw_cxx.cpp"
        ],
        "message": "libraw_cxx formatted",
        "before_after_code_files": [
          "src/libraw_cxx.cpp||src/libraw_cxx.cpp"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/libraw_cxx.cpp||src/libraw_cxx.cpp"
          ],
          "candidate": [
            "src/libraw_cxx.cpp||src/libraw_cxx.cpp"
          ]
        }
      },
      "candidate_diff": {
        "src/libraw_cxx.cpp||src/libraw_cxx.cpp": [
          "File: src/libraw_cxx.cpp -> src/libraw_cxx.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "49: extern \"C\"",
          "50: {",
          "51: #endif",
          "100: #ifdef __cplusplus",
          "101: }",
          "",
          "[Removed Lines]",
          "52:     void default_memory_callback(void *,const char *file,const char *where)",
          "53:     {",
          "54:         fprintf (stderr,\"%s: Out of memory in %s\\n\", file?file:\"unknown file\", where);",
          "55:     }",
          "57:     void default_data_callback(void*,const char *file, const int offset)",
          "58:     {",
          "59:         if(offset < 0)",
          "60:             fprintf (stderr,\"%s: Unexpected end of file\\n\", file?file:\"unknown file\");",
          "61:         else",
          "62:             fprintf (stderr,\"%s: data corrupted at %d\\n\",file?file:\"unknown file\",offset);",
          "63:     }",
          "64:     const char *libraw_strerror(int e)",
          "65:     {",
          "66:         enum LibRaw_errors errorcode = (LibRaw_errors)e;",
          "67:         switch(errorcode)",
          "68:             {",
          "69:             case        LIBRAW_SUCCESS:",
          "70:                 return \"No error\";",
          "71:             case        LIBRAW_UNSPECIFIED_ERROR:",
          "72:                 return \"Unspecified error\";",
          "73:             case        LIBRAW_FILE_UNSUPPORTED:",
          "74:                 return \"Unsupported file format or not RAW file\";",
          "75:             case        LIBRAW_REQUEST_FOR_NONEXISTENT_IMAGE:",
          "76:                 return \"Request for nonexisting image number\";",
          "77:             case        LIBRAW_OUT_OF_ORDER_CALL:",
          "78:                 return \"Out of order call of libraw function\";",
          "79:             case    LIBRAW_NO_THUMBNAIL:",
          "80:                 return \"No thumbnail in file\";",
          "81:             case    LIBRAW_UNSUPPORTED_THUMBNAIL:",
          "82:                 return \"Unsupported thumbnail format\";",
          "83:    case LIBRAW_INPUT_CLOSED:",
          "84:     return \"No input stream, or input stream closed\";",
          "85:             case    LIBRAW_UNSUFFICIENT_MEMORY:",
          "86:                 return \"Unsufficient memory\";",
          "87:             case    LIBRAW_DATA_ERROR:",
          "88:                 return \"Corrupted data or unexpected EOF\";",
          "89:             case    LIBRAW_IO_ERROR:",
          "90:                 return \"Input/output error\";",
          "91:             case LIBRAW_CANCELLED_BY_CALLBACK:",
          "92:                 return \"Cancelled by user callback\";",
          "93:             case LIBRAW_BAD_CROP:",
          "94:                 return \"Bad crop box\";",
          "95:             default:",
          "96:                 return \"Unknown error code\";",
          "97:         }",
          "98:     }",
          "",
          "[Added Lines]",
          "52:   void default_memory_callback(void *,const char *file,const char *where)",
          "53:   {",
          "54:     fprintf (stderr,\"%s: Out of memory in %s\\n\", file?file:\"unknown file\", where);",
          "55:   }",
          "57:   void default_data_callback(void*,const char *file, const int offset)",
          "58:   {",
          "59:     if(offset < 0)",
          "60:       fprintf (stderr,\"%s: Unexpected end of file\\n\", file?file:\"unknown file\");",
          "61:     else",
          "62:       fprintf (stderr,\"%s: data corrupted at %d\\n\",file?file:\"unknown file\",offset);",
          "63:   }",
          "64:   const char *libraw_strerror(int e)",
          "65:   {",
          "66:     enum LibRaw_errors errorcode = (LibRaw_errors)e;",
          "67:     switch(errorcode)",
          "68:       {",
          "69:       case        LIBRAW_SUCCESS:",
          "70:         return \"No error\";",
          "71:       case        LIBRAW_UNSPECIFIED_ERROR:",
          "72:         return \"Unspecified error\";",
          "73:       case        LIBRAW_FILE_UNSUPPORTED:",
          "74:         return \"Unsupported file format or not RAW file\";",
          "75:       case        LIBRAW_REQUEST_FOR_NONEXISTENT_IMAGE:",
          "76:         return \"Request for nonexisting image number\";",
          "77:       case        LIBRAW_OUT_OF_ORDER_CALL:",
          "78:         return \"Out of order call of libraw function\";",
          "79:       case    LIBRAW_NO_THUMBNAIL:",
          "80:         return \"No thumbnail in file\";",
          "81:       case    LIBRAW_UNSUPPORTED_THUMBNAIL:",
          "82:         return \"Unsupported thumbnail format\";",
          "83:       case LIBRAW_INPUT_CLOSED:",
          "84:         return \"No input stream, or input stream closed\";",
          "85:       case    LIBRAW_UNSUFFICIENT_MEMORY:",
          "86:         return \"Unsufficient memory\";",
          "87:       case    LIBRAW_DATA_ERROR:",
          "88:         return \"Corrupted data or unexpected EOF\";",
          "89:       case    LIBRAW_IO_ERROR:",
          "90:         return \"Input/output error\";",
          "91:       case LIBRAW_CANCELLED_BY_CALLBACK:",
          "92:         return \"Cancelled by user callback\";",
          "93:       case LIBRAW_BAD_CROP:",
          "94:         return \"Bad crop box\";",
          "95:       default:",
          "96:         return \"Unknown error code\";",
          "97:       }",
          "98:   }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "120: #define ID libraw_internal_data.internal_data",
          "122: #define EXCEPTION_HANDLER(e) do{                        \\",
          "151: const char* LibRaw::version() { return LIBRAW_VERSION_STR;}",
          "152: int LibRaw::versionNumber() { return LIBRAW_VERSION; }",
          "",
          "[Removed Lines]",
          "124:         switch(e)                                       \\",
          "125:             {                                           \\",
          "126:             case LIBRAW_EXCEPTION_ALLOC:                \\",
          "127:                 recycle();                              \\",
          "128:                 return LIBRAW_UNSUFFICIENT_MEMORY;      \\",
          "129:             case LIBRAW_EXCEPTION_DECODE_RAW:           \\",
          "130:             case LIBRAW_EXCEPTION_DECODE_JPEG:          \\",
          "131:                 recycle();                              \\",
          "132:                 return LIBRAW_DATA_ERROR;               \\",
          "133:             case LIBRAW_EXCEPTION_DECODE_JPEG2000:      \\",
          "134:                 recycle();                              \\",
          "135:                 return LIBRAW_DATA_ERROR;               \\",
          "136:             case LIBRAW_EXCEPTION_IO_EOF:               \\",
          "137:             case LIBRAW_EXCEPTION_IO_CORRUPT:           \\",
          "138:                 recycle();                              \\",
          "139:                 return LIBRAW_IO_ERROR;                 \\",
          "140:             case LIBRAW_EXCEPTION_CANCELLED_BY_CALLBACK:\\",
          "141:                 recycle();                              \\",
          "142:                 return LIBRAW_CANCELLED_BY_CALLBACK;    \\",
          "143:             case LIBRAW_EXCEPTION_BAD_CROP:             \\",
          "144:                 recycle();                              \\",
          "145:                 return LIBRAW_BAD_CROP;                 \\",
          "146:             default:                                    \\",
          "147:                 return LIBRAW_UNSPECIFIED_ERROR;        \\",
          "148:             } \\",
          "149:     }while(0)",
          "",
          "[Added Lines]",
          "124:     switch(e)                                           \\",
          "125:       {                                                 \\",
          "126:       case LIBRAW_EXCEPTION_ALLOC:                      \\",
          "127:         recycle();                                      \\",
          "128:         return LIBRAW_UNSUFFICIENT_MEMORY;              \\",
          "129:       case LIBRAW_EXCEPTION_DECODE_RAW:                 \\",
          "130:       case LIBRAW_EXCEPTION_DECODE_JPEG:                \\",
          "131:         recycle();                                      \\",
          "132:         return LIBRAW_DATA_ERROR;                       \\",
          "133:       case LIBRAW_EXCEPTION_DECODE_JPEG2000:            \\",
          "134:         recycle();                                      \\",
          "135:         return LIBRAW_DATA_ERROR;                       \\",
          "136:       case LIBRAW_EXCEPTION_IO_EOF:                     \\",
          "137:       case LIBRAW_EXCEPTION_IO_CORRUPT:                 \\",
          "138:         recycle();                                      \\",
          "139:         return LIBRAW_IO_ERROR;                                 \\",
          "140:       case LIBRAW_EXCEPTION_CANCELLED_BY_CALLBACK:              \\",
          "141:         recycle();                                              \\",
          "142:         return LIBRAW_CANCELLED_BY_CALLBACK;                    \\",
          "143:       case LIBRAW_EXCEPTION_BAD_CROP:                           \\",
          "144:         recycle();                                              \\",
          "145:         return LIBRAW_BAD_CROP;                                 \\",
          "146:       default:                                                  \\",
          "147:         return LIBRAW_UNSPECIFIED_ERROR;                        \\",
          "148:       }                                                         \\",
          "149:   }while(0)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "156: void LibRaw::derror()",
          "157: {",
          "159:         {",
          "173:         }",
          "175: }",
          "177: void LibRaw::dcraw_clear_mem(libraw_processed_image_t* p)",
          "",
          "[Removed Lines]",
          "158:     if (!libraw_internal_data.unpacker_data.data_error && libraw_internal_data.internal_data.input)",
          "160:             if (libraw_internal_data.internal_data.input->eof())",
          "161:                 {",
          "162:                     if(callbacks.data_cb)(*callbacks.data_cb)(callbacks.datacb_data,",
          "163:                                                               libraw_internal_data.internal_data.input->fname(),-1);",
          "164:                     throw LIBRAW_EXCEPTION_IO_EOF;",
          "165:                 }",
          "166:             else",
          "167:                 {",
          "168:                     if(callbacks.data_cb)(*callbacks.data_cb)(callbacks.datacb_data,",
          "169:                                                               libraw_internal_data.internal_data.input->fname(),",
          "170:                                                               libraw_internal_data.internal_data.input->tell());",
          "171:                     throw LIBRAW_EXCEPTION_IO_CORRUPT;",
          "172:                 }",
          "174:     libraw_internal_data.unpacker_data.data_error++;",
          "",
          "[Added Lines]",
          "158:   if (!libraw_internal_data.unpacker_data.data_error && libraw_internal_data.internal_data.input)",
          "159:     {",
          "160:       if (libraw_internal_data.internal_data.input->eof())",
          "162:           if(callbacks.data_cb)(*callbacks.data_cb)(callbacks.datacb_data,",
          "163:                                                     libraw_internal_data.internal_data.input->fname(),-1);",
          "164:           throw LIBRAW_EXCEPTION_IO_EOF;",
          "165:         }",
          "166:       else",
          "167:         {",
          "168:           if(callbacks.data_cb)(*callbacks.data_cb)(callbacks.datacb_data,",
          "169:                                                     libraw_internal_data.internal_data.input->fname(),",
          "170:                                                     libraw_internal_data.internal_data.input->tell());",
          "171:           throw LIBRAW_EXCEPTION_IO_CORRUPT;",
          "173:     }",
          "174:   libraw_internal_data.unpacker_data.data_error++;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "184: class CameraMetaDataLR : public CameraMetaData",
          "185: {",
          "186: public:",
          "190: };",
          "192: CameraMetaDataLR::CameraMetaDataLR(char *data, int sz) : CameraMetaData() {",
          "",
          "[Removed Lines]",
          "187:  CameraMetaDataLR() : CameraMetaData() {}",
          "188:  CameraMetaDataLR(char *filename) : CameraMetaData(filename){}",
          "189:  CameraMetaDataLR(char *data, int sz);",
          "",
          "[Added Lines]",
          "187:   CameraMetaDataLR() : CameraMetaData() {}",
          "188:   CameraMetaDataLR(char *filename) : CameraMetaData(filename){}",
          "189:   CameraMetaDataLR(char *data, int sz);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "277: LibRaw:: LibRaw(unsigned int flags)",
          "278: {",
          "283: #ifdef DCRAW_VERBOSE",
          "285: #else",
          "287: #endif",
          "294: #ifdef USE_RAWSPEED",
          "297: #endif",
          "325: }",
          "327: int LibRaw::set_rawspeed_camerafile(char *filename)",
          "",
          "[Removed Lines]",
          "279:     double aber[4] = {1,1,1,1};",
          "280:     double gamm[6] = { 0.45,4.5,0,0,0,0 };",
          "281:     unsigned greybox[4] =  { 0, 0, UINT_MAX, UINT_MAX };",
          "282:     unsigned cropbox[4] =  { 0, 0, UINT_MAX, UINT_MAX };",
          "284:     verbose = 1;",
          "286:     verbose = 0;",
          "288:     ZERO(imgdata);",
          "289:     ZERO(libraw_internal_data);",
          "290:     ZERO(callbacks);",
          "292:     _rawspeed_camerameta = _rawspeed_decoder = NULL;",
          "295:  CameraMetaDataLR *camerameta = make_camera_metadata(); // May be NULL in case of exception in make_camera_metadata()",
          "296:  _rawspeed_camerameta = static_cast<void*>(camerameta);",
          "298:     callbacks.mem_cb = (flags & LIBRAW_OPIONS_NO_MEMERR_CALLBACK) ? NULL:  &default_memory_callback;",
          "299:     callbacks.data_cb = (flags & LIBRAW_OPIONS_NO_DATAERR_CALLBACK)? NULL : &default_data_callback;",
          "300:     memmove(&imgdata.params.aber,&aber,sizeof(aber));",
          "301:     memmove(&imgdata.params.gamm,&gamm,sizeof(gamm));",
          "302:     memmove(&imgdata.params.greybox,&greybox,sizeof(greybox));",
          "303:     memmove(&imgdata.params.cropbox,&cropbox,sizeof(cropbox));",
          "305:     imgdata.params.bright=1;",
          "306:     imgdata.params.use_camera_matrix=-1;",
          "307:     imgdata.params.user_flip=-1;",
          "308:     imgdata.params.user_black=-1;",
          "309:  imgdata.params.user_cblack[0]=imgdata.params.user_cblack[1]=imgdata.params.user_cblack[2]=imgdata.params.user_cblack[3]=-1000001;",
          "310:     imgdata.params.user_sat=-1;",
          "311:     imgdata.params.user_qual=-1;",
          "312:     imgdata.params.output_color=1;",
          "313:     imgdata.params.output_bps=8;",
          "314:     imgdata.params.use_fuji_rotate=1;",
          "315:     imgdata.params.exp_shift = 1.0;",
          "316:     imgdata.params.auto_bright_thr = LIBRAW_DEFAULT_AUTO_BRIGHTNESS_THRESHOLD;",
          "317:     imgdata.params.adjust_maximum_thr= LIBRAW_DEFAULT_ADJUST_MAXIMUM_THRESHOLD;",
          "318:     imgdata.params.use_rawspeed = 1;",
          "319:     imgdata.params.no_auto_scale = 0;",
          "320:     imgdata.params.green_matching = 0;",
          "321:     imgdata.parent_class = this;",
          "322:     imgdata.progress_flags = 0;",
          "323:     tls = new LibRaw_TLS;",
          "324:     tls->init();",
          "",
          "[Added Lines]",
          "279:   double aber[4] = {1,1,1,1};",
          "280:   double gamm[6] = { 0.45,4.5,0,0,0,0 };",
          "281:   unsigned greybox[4] =  { 0, 0, UINT_MAX, UINT_MAX };",
          "282:   unsigned cropbox[4] =  { 0, 0, UINT_MAX, UINT_MAX };",
          "284:   verbose = 1;",
          "286:   verbose = 0;",
          "288:   ZERO(imgdata);",
          "289:   ZERO(libraw_internal_data);",
          "290:   ZERO(callbacks);",
          "292:   _rawspeed_camerameta = _rawspeed_decoder = NULL;",
          "295:   CameraMetaDataLR *camerameta = make_camera_metadata(); // May be NULL in case of exception in make_camera_metadata()",
          "296:   _rawspeed_camerameta = static_cast<void*>(camerameta);",
          "298:   callbacks.mem_cb = (flags & LIBRAW_OPIONS_NO_MEMERR_CALLBACK) ? NULL:  &default_memory_callback;",
          "299:   callbacks.data_cb = (flags & LIBRAW_OPIONS_NO_DATAERR_CALLBACK)? NULL : &default_data_callback;",
          "300:   memmove(&imgdata.params.aber,&aber,sizeof(aber));",
          "301:   memmove(&imgdata.params.gamm,&gamm,sizeof(gamm));",
          "302:   memmove(&imgdata.params.greybox,&greybox,sizeof(greybox));",
          "303:   memmove(&imgdata.params.cropbox,&cropbox,sizeof(cropbox));",
          "305:   imgdata.params.bright=1;",
          "306:   imgdata.params.use_camera_matrix=-1;",
          "307:   imgdata.params.user_flip=-1;",
          "308:   imgdata.params.user_black=-1;",
          "309:   imgdata.params.user_cblack[0]=imgdata.params.user_cblack[1]=imgdata.params.user_cblack[2]=imgdata.params.user_cblack[3]=-1000001;",
          "310:   imgdata.params.user_sat=-1;",
          "311:   imgdata.params.user_qual=-1;",
          "312:   imgdata.params.output_color=1;",
          "313:   imgdata.params.output_bps=8;",
          "314:   imgdata.params.use_fuji_rotate=1;",
          "315:   imgdata.params.exp_shift = 1.0;",
          "316:   imgdata.params.auto_bright_thr = LIBRAW_DEFAULT_AUTO_BRIGHTNESS_THRESHOLD;",
          "317:   imgdata.params.adjust_maximum_thr= LIBRAW_DEFAULT_ADJUST_MAXIMUM_THRESHOLD;",
          "318:   imgdata.params.use_rawspeed = 1;",
          "319:   imgdata.params.no_auto_scale = 0;",
          "320:   imgdata.params.green_matching = 0;",
          "321:   imgdata.parent_class = this;",
          "322:   imgdata.progress_flags = 0;",
          "323:   tls = new LibRaw_TLS;",
          "324:   tls->init();",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "740: int LibRaw::open_file(const char *fname, INT64 max_buf_size)",
          "741: {",
          "742: #ifndef WIN32",
          "747: #else",
          "752: #endif",
          "778:     else",
          "784: }",
          "786: #if defined(WIN32) && !defined(__MINGW32__)",
          "787: int LibRaw::open_file(const wchar_t *fname, INT64 max_buf_size)",
          "788: {",
          "824: }",
          "825: #endif",
          "827: int LibRaw::open_buffer(void *buffer, size_t size)",
          "828: {",
          "836:     }",
          "859: }",
          "861: void LibRaw::hasselblad_full_load_raw()",
          "",
          "[Removed Lines]",
          "743:     struct stat st;",
          "744:     if(stat(fname,&st))",
          "745:         return LIBRAW_IO_ERROR;",
          "746:     int big = (st.st_size > max_buf_size)?1:0;",
          "748:  struct _stati64 st;",
          "749:     if(_stati64(fname,&st))",
          "750:         return LIBRAW_IO_ERROR;",
          "751:     int big = (st.st_size > max_buf_size)?1:0;",
          "754:     LibRaw_abstract_datastream *stream;",
          "755:     try {",
          "756:         if(big)",
          "757:          stream = new LibRaw_bigfile_datastream(fname);",
          "758:         else",
          "759:          stream = new LibRaw_file_datastream(fname);",
          "760:     }",
          "762:     catch (std::bad_alloc)",
          "763:         {",
          "764:             recycle();",
          "765:             return LIBRAW_UNSUFFICIENT_MEMORY;",
          "766:         }",
          "767:     if(!stream->valid())",
          "768:         {",
          "769:             delete stream;",
          "770:             return LIBRAW_IO_ERROR;",
          "771:         }",
          "772:     ID.input_internal = 0; // preserve from deletion on error",
          "773:     int ret = open_datastream(stream);",
          "774:     if (ret == LIBRAW_SUCCESS)",
          "775:         {",
          "776:             ID.input_internal =1 ; // flag to delete datastream on recycle",
          "777:         }",
          "779:         {",
          "780:             delete stream;",
          "781:             ID.input_internal = 0;",
          "782:         }",
          "783:     return ret;",
          "789:  struct _stati64 st;",
          "790:  if(_wstati64(fname,&st))",
          "791:   return LIBRAW_IO_ERROR;",
          "792:  int big = (st.st_size > max_buf_size)?1:0;",
          "794:  LibRaw_abstract_datastream *stream;",
          "795:  try {",
          "796:   if(big)",
          "797:    stream = new LibRaw_bigfile_datastream(fname);",
          "798:   else",
          "799:    stream = new LibRaw_file_datastream(fname);",
          "800:  }",
          "802:  catch (std::bad_alloc)",
          "803:  {",
          "804:   recycle();",
          "805:   return LIBRAW_UNSUFFICIENT_MEMORY;",
          "806:  }",
          "807:  if(!stream->valid())",
          "808:  {",
          "809:   delete stream;",
          "810:   return LIBRAW_IO_ERROR;",
          "811:  }",
          "812:  ID.input_internal = 0; // preserve from deletion on error",
          "813:  int ret = open_datastream(stream);",
          "814:  if (ret == LIBRAW_SUCCESS)",
          "815:  {",
          "816:   ID.input_internal =1 ; // flag to delete datastream on recycle",
          "817:  }",
          "818:  else",
          "819:  {",
          "820:   delete stream;",
          "821:   ID.input_internal = 0;",
          "822:  }",
          "823:  return ret;",
          "830:     if(!buffer  || buffer==(void*)-1)",
          "831:         return LIBRAW_IO_ERROR;",
          "833:     LibRaw_buffer_datastream *stream;",
          "834:     try {",
          "835:         stream = new LibRaw_buffer_datastream(buffer,size);",
          "837:     catch (std::bad_alloc)",
          "838:         {",
          "839:             recycle();",
          "840:             return LIBRAW_UNSUFFICIENT_MEMORY;",
          "841:         }",
          "842:     if(!stream->valid())",
          "843:         {",
          "844:             delete stream;",
          "845:             return LIBRAW_IO_ERROR;",
          "846:         }",
          "847:     ID.input_internal = 0; // preserve from deletion on error",
          "848:     int ret = open_datastream(stream);",
          "849:     if (ret == LIBRAW_SUCCESS)",
          "850:         {",
          "851:             ID.input_internal =1 ; // flag to delete datastream on recycle",
          "852:         }",
          "853:     else",
          "854:         {",
          "855:             delete stream;",
          "856:             ID.input_internal = 0;",
          "857:         }",
          "858:     return ret;",
          "",
          "[Added Lines]",
          "744:   struct stat st;",
          "745:   if(stat(fname,&st))",
          "746:     return LIBRAW_IO_ERROR;",
          "747:   int big = (st.st_size > max_buf_size)?1:0;",
          "749:   struct _stati64 st;",
          "750:   if(_stati64(fname,&st))",
          "751:     return LIBRAW_IO_ERROR;",
          "752:   int big = (st.st_size > max_buf_size)?1:0;",
          "755:   LibRaw_abstract_datastream *stream;",
          "756:   try {",
          "757:     if(big)",
          "758:       stream = new LibRaw_bigfile_datastream(fname);",
          "760:       stream = new LibRaw_file_datastream(fname);",
          "761:   }",
          "763:   catch (std::bad_alloc)",
          "764:     {",
          "765:       recycle();",
          "766:       return LIBRAW_UNSUFFICIENT_MEMORY;",
          "767:     }",
          "768:   if(!stream->valid())",
          "769:     {",
          "770:       delete stream;",
          "771:       return LIBRAW_IO_ERROR;",
          "772:     }",
          "773:   ID.input_internal = 0; // preserve from deletion on error",
          "774:   int ret = open_datastream(stream);",
          "775:   if (ret == LIBRAW_SUCCESS)",
          "776:     {",
          "777:       ID.input_internal =1 ; // flag to delete datastream on recycle",
          "778:     }",
          "779:   else",
          "780:     {",
          "781:       delete stream;",
          "782:       ID.input_internal = 0;",
          "783:     }",
          "784:   return ret;",
          "790:   struct _stati64 st;",
          "791:   if(_wstati64(fname,&st))",
          "792:     return LIBRAW_IO_ERROR;",
          "793:   int big = (st.st_size > max_buf_size)?1:0;",
          "795:   LibRaw_abstract_datastream *stream;",
          "796:   try {",
          "797:     if(big)",
          "798:       stream = new LibRaw_bigfile_datastream(fname);",
          "799:     else",
          "800:       stream = new LibRaw_file_datastream(fname);",
          "801:   }",
          "803:   catch (std::bad_alloc)",
          "804:     {",
          "805:       recycle();",
          "806:       return LIBRAW_UNSUFFICIENT_MEMORY;",
          "807:     }",
          "808:   if(!stream->valid())",
          "809:     {",
          "810:       delete stream;",
          "811:       return LIBRAW_IO_ERROR;",
          "812:     }",
          "813:   ID.input_internal = 0; // preserve from deletion on error",
          "814:   int ret = open_datastream(stream);",
          "815:   if (ret == LIBRAW_SUCCESS)",
          "816:     {",
          "817:       ID.input_internal =1 ; // flag to delete datastream on recycle",
          "818:     }",
          "819:   else",
          "820:     {",
          "821:       delete stream;",
          "822:       ID.input_internal = 0;",
          "823:     }",
          "824:   return ret;",
          "831:   if(!buffer  || buffer==(void*)-1)",
          "832:     return LIBRAW_IO_ERROR;",
          "834:   LibRaw_buffer_datastream *stream;",
          "835:   try {",
          "836:     stream = new LibRaw_buffer_datastream(buffer,size);",
          "837:   }",
          "838:   catch (std::bad_alloc)",
          "839:     {",
          "840:       recycle();",
          "841:       return LIBRAW_UNSUFFICIENT_MEMORY;",
          "843:   if(!stream->valid())",
          "844:     {",
          "845:       delete stream;",
          "846:       return LIBRAW_IO_ERROR;",
          "847:     }",
          "848:   ID.input_internal = 0; // preserve from deletion on error",
          "849:   int ret = open_datastream(stream);",
          "850:   if (ret == LIBRAW_SUCCESS)",
          "851:     {",
          "852:       ID.input_internal =1 ; // flag to delete datastream on recycle",
          "853:     }",
          "854:   else",
          "855:     {",
          "856:       delete stream;",
          "857:       ID.input_internal = 0;",
          "858:     }",
          "859:   return ret;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "875: int LibRaw::open_datastream(LibRaw_abstract_datastream *stream)",
          "876: {",
          "892: #if 0",
          "908: #endif",
          "955: }",
          "957: #ifdef USE_RAWSPEED",
          "",
          "[Removed Lines]",
          "878:     if(!stream)",
          "879:         return ENOENT;",
          "880:     if(!stream->valid())",
          "881:         return LIBRAW_IO_ERROR;",
          "882:     recycle();",
          "884:     try {",
          "885:         ID.input = stream;",
          "886:         SET_PROC_FLAG(LIBRAW_PROGRESS_OPEN);",
          "888:         if (O.use_camera_matrix < 0)",
          "889:             O.use_camera_matrix = O.use_camera_wb;",
          "891:         identify();",
          "893:         size_t bytes = ID.input->size()-libraw_internal_data.unpacker_data.data_offset;",
          "894:         float bpp = float(bytes)/float(S.raw_width)/float(S.raw_height);",
          "895:         float bpp2 = float(bytes)/float(S.width)/float(S.height);",
          "896:         printf(\"RawSize: %dx%d data offset: %d data size:%d bpp: %g bpp2: %g\\n\",S.raw_width,S.raw_height,libraw_internal_data.unpacker_data.data_offset,bytes,bpp,bpp2);",
          "897:         if(!strcasecmp(imgdata.idata.make,\"Hasselblad\") && bpp == 6.0f)",
          "898:           {",
          "899:             load_raw = &LibRaw::hasselblad_full_load_raw;",
          "900:             S.width = S.raw_width;",
          "901:             S.height = S.raw_height;",
          "902:             P1.filters = 0;",
          "903:             P1.colors=3;",
          "904:             P1.raw_count=1;",
          "905:             C.maximum=0xffff;",
          "906:             printf(\"3 channel hassy found\\n\");",
          "907:           }",
          "909:         if(C.profile_length)",
          "910:             {",
          "911:                 if(C.profile) free(C.profile);",
          "912:                 C.profile = malloc(C.profile_length);",
          "913:                 merror(C.profile,\"LibRaw::open_file()\");",
          "914:                 ID.input->seek(ID.profile_offset,SEEK_SET);",
          "915:                 ID.input->read(C.profile,C.profile_length,1);",
          "916:             }",
          "918:         SET_PROC_FLAG(LIBRAW_PROGRESS_IDENTIFY);",
          "919:     }",
          "920:     catch ( LibRaw_exceptions err) {",
          "921:         EXCEPTION_HANDLER(err);",
          "922:     }",
          "923:     catch (std::exception ee) {",
          "924:         EXCEPTION_HANDLER(LIBRAW_EXCEPTION_IO_CORRUPT);",
          "925:     }",
          "927:     if(P1.raw_count < 1)",
          "928:         return LIBRAW_FILE_UNSUPPORTED;",
          "931:     write_fun = &LibRaw::write_ppm_tiff;",
          "933:     if (load_raw == &LibRaw::kodak_ycbcr_load_raw)",
          "934:         {",
          "935:             S.height += S.height & 1;",
          "936:             S.width  += S.width  & 1;",
          "937:         }",
          "939:     IO.shrink = P1.filters && (O.half_size ||",
          "940:  ((O.threshold || O.aber[0] != 1 || O.aber[2] != 1) ));",
          "942:     S.iheight = (S.height + IO.shrink) >> IO.shrink;",
          "943:     S.iwidth  = (S.width  + IO.shrink) >> IO.shrink;",
          "946:     memmove(&imgdata.rawdata.color,&imgdata.color,sizeof(imgdata.color));",
          "947:     memmove(&imgdata.rawdata.sizes,&imgdata.sizes,sizeof(imgdata.sizes));",
          "948:     memmove(&imgdata.rawdata.iparams,&imgdata.idata,sizeof(imgdata.idata));",
          "949:     memmove(&imgdata.rawdata.ioparams,&libraw_internal_data.internal_output_params,sizeof(libraw_internal_data.internal_output_params));",
          "951:     SET_PROC_FLAG(LIBRAW_PROGRESS_SIZE_ADJUST);",
          "954:     return LIBRAW_SUCCESS;",
          "",
          "[Added Lines]",
          "879:   if(!stream)",
          "880:     return ENOENT;",
          "881:   if(!stream->valid())",
          "882:     return LIBRAW_IO_ERROR;",
          "883:   recycle();",
          "885:   try {",
          "886:     ID.input = stream;",
          "887:     SET_PROC_FLAG(LIBRAW_PROGRESS_OPEN);",
          "889:     if (O.use_camera_matrix < 0)",
          "890:       O.use_camera_matrix = O.use_camera_wb;",
          "892:     identify();",
          "894:     size_t bytes = ID.input->size()-libraw_internal_data.unpacker_data.data_offset;",
          "895:     float bpp = float(bytes)/float(S.raw_width)/float(S.raw_height);",
          "896:     float bpp2 = float(bytes)/float(S.width)/float(S.height);",
          "897:     printf(\"RawSize: %dx%d data offset: %d data size:%d bpp: %g bpp2: %g\\n\",S.raw_width,S.raw_height,libraw_internal_data.unpacker_data.data_offset,bytes,bpp,bpp2);",
          "898:     if(!strcasecmp(imgdata.idata.make,\"Hasselblad\") && bpp == 6.0f)",
          "899:       {",
          "900:         load_raw = &LibRaw::hasselblad_full_load_raw;",
          "901:         S.width = S.raw_width;",
          "902:         S.height = S.raw_height;",
          "903:         P1.filters = 0;",
          "904:         P1.colors=3;",
          "905:         P1.raw_count=1;",
          "906:         C.maximum=0xffff;",
          "907:         printf(\"3 channel hassy found\\n\");",
          "908:       }",
          "910:     if(C.profile_length)",
          "911:       {",
          "912:         if(C.profile) free(C.profile);",
          "913:         C.profile = malloc(C.profile_length);",
          "914:         merror(C.profile,\"LibRaw::open_file()\");",
          "915:         ID.input->seek(ID.profile_offset,SEEK_SET);",
          "916:         ID.input->read(C.profile,C.profile_length,1);",
          "917:       }",
          "919:     SET_PROC_FLAG(LIBRAW_PROGRESS_IDENTIFY);",
          "920:   }",
          "921:   catch ( LibRaw_exceptions err) {",
          "922:     EXCEPTION_HANDLER(err);",
          "923:   }",
          "924:   catch (std::exception ee) {",
          "925:     EXCEPTION_HANDLER(LIBRAW_EXCEPTION_IO_CORRUPT);",
          "926:   }",
          "928:   if(P1.raw_count < 1)",
          "929:     return LIBRAW_FILE_UNSUPPORTED;",
          "932:   write_fun = &LibRaw::write_ppm_tiff;",
          "934:   if (load_raw == &LibRaw::kodak_ycbcr_load_raw)",
          "935:     {",
          "936:       S.height += S.height & 1;",
          "937:       S.width  += S.width  & 1;",
          "938:     }",
          "940:   IO.shrink = P1.filters && (O.half_size ||",
          "941:                              ((O.threshold || O.aber[0] != 1 || O.aber[2] != 1) ));",
          "943:   S.iheight = (S.height + IO.shrink) >> IO.shrink;",
          "944:   S.iwidth  = (S.width  + IO.shrink) >> IO.shrink;",
          "947:   memmove(&imgdata.rawdata.color,&imgdata.color,sizeof(imgdata.color));",
          "948:   memmove(&imgdata.rawdata.sizes,&imgdata.sizes,sizeof(imgdata.sizes));",
          "949:   memmove(&imgdata.rawdata.iparams,&imgdata.idata,sizeof(imgdata.idata));",
          "950:   memmove(&imgdata.rawdata.ioparams,&libraw_internal_data.internal_output_params,sizeof(libraw_internal_data.internal_output_params));",
          "952:   SET_PROC_FLAG(LIBRAW_PROGRESS_SIZE_ADJUST);",
          "955:   return LIBRAW_SUCCESS;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "981: int LibRaw::unpack(void)",
          "982: {",
          "1038: #ifdef USE_RAWSPEED",
          "1041:           {",
          "1096:             }",
          "1104:               {",
          "1107:               }",
          "1109:               {",
          "1119:               }",
          "1129:               {",
          "1138:               }",
          "1139:           }",
          "1182: }",
          "1184: void LibRaw::free_image(void)",
          "1185: {",
          "1194: }",
          "1197: void LibRaw::raw2image_start()",
          "1198: {",
          "1222: }",
          "",
          "[Removed Lines]",
          "983:     CHECK_ORDER_HIGH(LIBRAW_PROGRESS_LOAD_RAW);",
          "984:     CHECK_ORDER_LOW(LIBRAW_PROGRESS_IDENTIFY);",
          "985:     try {",
          "987:  if(!libraw_internal_data.internal_data.input)",
          "988:           return LIBRAW_INPUT_CLOSED;",
          "990:         RUN_CALLBACK(LIBRAW_PROGRESS_LOAD_RAW,0,2);",
          "991:         if (O.shot_select >= P1.raw_count)",
          "992:             return LIBRAW_REQUEST_FOR_NONEXISTENT_IMAGE;",
          "994:         if(!load_raw)",
          "995:             return LIBRAW_UNSPECIFIED_ERROR;",
          "997:         if (O.use_camera_matrix && C.cmatrix[0][0] > 0.25)",
          "998:             {",
          "999:                 memcpy (C.rgb_cam, C.cmatrix, sizeof (C.cmatrix));",
          "1000:                 IO.raw_color = 0;",
          "1001:             }",
          "1003:         if(imgdata.image)",
          "1004:             {",
          "1005:                 free(imgdata.image);",
          "1006:                 imgdata.image = 0;",
          "1007:             }",
          "1008:         if(imgdata.rawdata.raw_alloc)",
          "1009:           {",
          "1010:             free(imgdata.rawdata.raw_alloc);",
          "1011:             imgdata.rawdata.raw_alloc = 0;",
          "1012:           }",
          "1013:         if (libraw_internal_data.unpacker_data.meta_length)",
          "1014:             {",
          "1015:                 libraw_internal_data.internal_data.meta_data =",
          "1016:                     (char *) malloc (libraw_internal_data.unpacker_data.meta_length);",
          "1017:                 merror (libraw_internal_data.internal_data.meta_data, \"LibRaw::unpack()\");",
          "1018:             }",
          "1020:         libraw_decoder_info_t decoder_info;",
          "1021:         get_decoder_info(&decoder_info);",
          "1023:         int save_iwidth = S.iwidth, save_iheight = S.iheight, save_shrink = IO.shrink;",
          "1025:         int rwidth = S.raw_width, rheight = S.raw_height;",
          "1026:         if( !IO.fuji_width)",
          "1027:             {",
          "1029:                 if(rwidth < S.width + S.left_margin)",
          "1030:                     rwidth = S.width + S.left_margin;",
          "1031:                 if(rheight < S.height + S.top_margin)",
          "1032:                     rheight = S.height + S.top_margin;",
          "1033:             }",
          "1034:         S.raw_pitch = S.raw_width*2;",
          "1035:         imgdata.rawdata.raw_image = 0;",
          "1036:         imgdata.rawdata.color4_image = 0;",
          "1037:  imgdata.rawdata.color3_image = 0;",
          "1040:         if(O.use_rawspeed && (decoder_info.decoder_flags & LIBRAW_DECODER_TRYRAWSPEED) && _rawspeed_camerameta)",
          "1042:             INT64 spos = ID.input->tell();",
          "1043:             try",
          "1044:               {",
          "1046:                 ID.input->seek(0,SEEK_SET);",
          "1047:                 INT64 _rawspeed_buffer_sz = ID.input->size()+32;",
          "1048:                 void *_rawspeed_buffer = malloc(_rawspeed_buffer_sz);",
          "1049:                 if(!_rawspeed_buffer) throw LIBRAW_EXCEPTION_ALLOC;",
          "1050:                 ID.input->read(_rawspeed_buffer,_rawspeed_buffer_sz,1);",
          "1051:                 FileMap map((uchar8*)_rawspeed_buffer,_rawspeed_buffer_sz);",
          "1052:                 RawParser t(&map);",
          "1053:                 RawDecoder *d = 0;",
          "1054:                 CameraMetaDataLR *meta = static_cast<CameraMetaDataLR*>(_rawspeed_camerameta);",
          "1055:                 d = t.getDecoder();",
          "1056:                 try {",
          "1057:                   d->checkSupport(meta);",
          "1058:                 }",
          "1059:                 catch (const RawDecoderException& e)",
          "1060:                   {",
          "1061:                     imgdata.process_warnings |= LIBRAW_WARN_RAWSPEED_UNSUPPORTED;",
          "1062:                     throw e;",
          "1063:                   }",
          "1064:                 d->decodeRaw();",
          "1065:                 d->decodeMetaData(meta);",
          "1066:                 RawImage r = d->mRaw;",
          "1067:                 if (r->isCFA) {",
          "1069:                   _rawspeed_decoder = static_cast<void*>(d);",
          "1070:                   imgdata.rawdata.raw_image = (ushort*) r->getDataUncropped(0,0);",
          "1071:                   S.raw_pitch = r->pitch;",
          "1072:                   fix_after_rawspeed(r->blackLevel);",
          "1073:                 } else if(r->getCpp()==4) {",
          "1074:                   _rawspeed_decoder = static_cast<void*>(d);",
          "1075:                   imgdata.rawdata.color4_image = (ushort(*)[4]) r->getDataUncropped(0,0);",
          "1076:                   S.raw_pitch = r->pitch;",
          "1077:                   C.maximum = r->whitePoint;",
          "1078:                   fix_after_rawspeed(r->blackLevel);",
          "1079:                 } else if(r->getCpp() == 3)",
          "1080:                   {",
          "1081:                     _rawspeed_decoder = static_cast<void*>(d);",
          "1082:                     imgdata.rawdata.color3_image = (ushort(*)[3]) r->getDataUncropped(0,0);",
          "1083:                     S.raw_pitch = r->pitch;",
          "1084:                     C.maximum = r->whitePoint;",
          "1085:                     fix_after_rawspeed(r->blackLevel);",
          "1086:                   }",
          "1087:                 else",
          "1088:                   {",
          "1089:                     delete d;",
          "1090:                   }",
          "1091:                 free(_rawspeed_buffer);",
          "1092:                 imgdata.process_warnings |= LIBRAW_WARN_RAWSPEED_PROCESSED;",
          "1093:               } catch (...) {",
          "1094:               imgdata.process_warnings |= LIBRAW_WARN_RAWSPEED_PROBLEM;",
          "1097:             ID.input->seek(spos,SEEK_SET);",
          "1098:           }",
          "1099: #endif",
          "1100:         if(!imgdata.rawdata.raw_image && !imgdata.rawdata.color4_image && !imgdata.rawdata.color3_image) // RawSpeed failed!",
          "1101:           {",
          "1103:             if(decoder_info.decoder_flags &  LIBRAW_DECODER_FLATFIELD)",
          "1105:                 imgdata.rawdata.raw_alloc = malloc(rwidth*(rheight+7)*sizeof(imgdata.rawdata.raw_image[0]));",
          "1106:                 imgdata.rawdata.raw_image = (ushort*) imgdata.rawdata.raw_alloc;",
          "1108:             else if (decoder_info.decoder_flags & LIBRAW_DECODER_LEGACY)",
          "1112:                 S.iwidth = S.width;",
          "1113:                 S.iheight= S.height;",
          "1114:                 IO.shrink = 0;",
          "1115:   S.raw_pitch = S.width*8;",
          "1117:                 imgdata.rawdata.raw_alloc = 0;",
          "1118:                 imgdata.image = (ushort (*)[4]) calloc(S.iwidth*S.iheight,sizeof(*imgdata.image));",
          "1120:             ID.input->seek(libraw_internal_data.unpacker_data.data_offset, SEEK_SET);",
          "1122:             unsigned m_save = C.maximum;",
          "1123:             if(load_raw == &LibRaw::unpacked_load_raw && !strcasecmp(imgdata.idata.make,\"Nikon\"))",
          "1124:               C.maximum=65535;",
          "1125:             (this->*load_raw)();",
          "1126:             if(load_raw == &LibRaw::unpacked_load_raw && !strcasecmp(imgdata.idata.make,\"Nikon\"))",
          "1127:               C.maximum = m_save;",
          "1128:             if (decoder_info.decoder_flags & LIBRAW_DECODER_LEGACY)",
          "1131:                 imgdata.rawdata.raw_alloc = imgdata.image;",
          "1132:                 imgdata.image = 0;",
          "1134:                 S.raw_width = S.width;",
          "1135:                 S.left_margin = 0;",
          "1136:                 S.raw_height = S.height;",
          "1137:                 S.top_margin = 0;",
          "1141:         if(imgdata.rawdata.raw_image)",
          "1142:           crop_masked_pixels(); // calculate black levels",
          "1145:         if( (decoder_info.decoder_flags & LIBRAW_DECODER_LEGACY) && !imgdata.rawdata.color4_image)",
          "1146:             {",
          "1147:                 imgdata.image = 0;",
          "1148:                 imgdata.rawdata.color4_image = (ushort (*)[4]) imgdata.rawdata.raw_alloc;",
          "1149:             }",
          "1152:         S.iwidth = save_iwidth;",
          "1153:         S.iheight = save_iheight;",
          "1154:         IO.shrink = save_shrink;",
          "1157:         unsigned int i = C.cblack[3];",
          "1158:         unsigned int c;",
          "1159:         for(c=0;c<3;c++)",
          "1160:             if (i > C.cblack[c]) i = C.cblack[c];",
          "1161:         for (c=0;c<4;c++)",
          "1162:             C.cblack[c] -= i;",
          "1163:         C.black += i;",
          "1166:         memmove(&imgdata.rawdata.color,&imgdata.color,sizeof(imgdata.color));",
          "1167:         memmove(&imgdata.rawdata.sizes,&imgdata.sizes,sizeof(imgdata.sizes));",
          "1168:         memmove(&imgdata.rawdata.iparams,&imgdata.idata,sizeof(imgdata.idata));",
          "1169:         memmove(&imgdata.rawdata.ioparams,&libraw_internal_data.internal_output_params,sizeof(libraw_internal_data.internal_output_params));",
          "1171:         SET_PROC_FLAG(LIBRAW_PROGRESS_LOAD_RAW);",
          "1172:         RUN_CALLBACK(LIBRAW_PROGRESS_LOAD_RAW,1,2);",
          "1174:         return 0;",
          "1175:     }",
          "1176:     catch ( LibRaw_exceptions err) {",
          "1177:         EXCEPTION_HANDLER(err);",
          "1178:     }",
          "1179:     catch (std::exception ee) {",
          "1180:         EXCEPTION_HANDLER(LIBRAW_EXCEPTION_IO_CORRUPT);",
          "1181:     }",
          "1186:     if(imgdata.image)",
          "1187:         {",
          "1188:             free(imgdata.image);",
          "1189:             imgdata.image = 0;",
          "1190:             imgdata.progress_flags",
          "1191:                 = LIBRAW_PROGRESS_START|LIBRAW_PROGRESS_OPEN",
          "1192:                 |LIBRAW_PROGRESS_IDENTIFY|LIBRAW_PROGRESS_SIZE_ADJUST|LIBRAW_PROGRESS_LOAD_RAW;",
          "1193:         }",
          "1200:         memmove(&imgdata.color,&imgdata.rawdata.color,sizeof(imgdata.color));",
          "1201:         memmove(&imgdata.sizes,&imgdata.rawdata.sizes,sizeof(imgdata.sizes));",
          "1202:         memmove(&imgdata.idata,&imgdata.rawdata.iparams,sizeof(imgdata.idata));",
          "1203:         memmove(&libraw_internal_data.internal_output_params,&imgdata.rawdata.ioparams,sizeof(libraw_internal_data.internal_output_params));",
          "1205:         if (O.user_flip >= 0)",
          "1206:             S.flip = O.user_flip;",
          "1208:         switch ((S.flip+3600) % 360)",
          "1209:             {",
          "1210:             case 270:  S.flip = 5;  break;",
          "1211:             case 180:  S.flip = 3;  break;",
          "1212:             case  90:  S.flip = 6;  break;",
          "1213:             }",
          "1216:         IO.shrink = P1.filters && (O.half_size ||",
          "1217:                                    ((O.threshold || O.aber[0] != 1 || O.aber[2] != 1) ));",
          "1219:         S.iheight = (S.height + IO.shrink) >> IO.shrink;",
          "1220:         S.iwidth  = (S.width  + IO.shrink) >> IO.shrink;",
          "",
          "[Added Lines]",
          "984:   CHECK_ORDER_HIGH(LIBRAW_PROGRESS_LOAD_RAW);",
          "985:   CHECK_ORDER_LOW(LIBRAW_PROGRESS_IDENTIFY);",
          "986:   try {",
          "988:     if(!libraw_internal_data.internal_data.input)",
          "989:       return LIBRAW_INPUT_CLOSED;",
          "991:     RUN_CALLBACK(LIBRAW_PROGRESS_LOAD_RAW,0,2);",
          "992:     if (O.shot_select >= P1.raw_count)",
          "993:       return LIBRAW_REQUEST_FOR_NONEXISTENT_IMAGE;",
          "995:     if(!load_raw)",
          "996:       return LIBRAW_UNSPECIFIED_ERROR;",
          "998:     if (O.use_camera_matrix && C.cmatrix[0][0] > 0.25)",
          "999:       {",
          "1000:         memcpy (C.rgb_cam, C.cmatrix, sizeof (C.cmatrix));",
          "1001:         IO.raw_color = 0;",
          "1002:       }",
          "1004:     if(imgdata.image)",
          "1005:       {",
          "1006:         free(imgdata.image);",
          "1007:         imgdata.image = 0;",
          "1008:       }",
          "1009:     if(imgdata.rawdata.raw_alloc)",
          "1010:       {",
          "1011:         free(imgdata.rawdata.raw_alloc);",
          "1012:         imgdata.rawdata.raw_alloc = 0;",
          "1013:       }",
          "1014:     if (libraw_internal_data.unpacker_data.meta_length)",
          "1015:       {",
          "1016:         libraw_internal_data.internal_data.meta_data =",
          "1017:           (char *) malloc (libraw_internal_data.unpacker_data.meta_length);",
          "1018:         merror (libraw_internal_data.internal_data.meta_data, \"LibRaw::unpack()\");",
          "1019:       }",
          "1021:     libraw_decoder_info_t decoder_info;",
          "1022:     get_decoder_info(&decoder_info);",
          "1024:     int save_iwidth = S.iwidth, save_iheight = S.iheight, save_shrink = IO.shrink;",
          "1026:     int rwidth = S.raw_width, rheight = S.raw_height;",
          "1027:     if( !IO.fuji_width)",
          "1028:       {",
          "1030:         if(rwidth < S.width + S.left_margin)",
          "1031:           rwidth = S.width + S.left_margin;",
          "1032:         if(rheight < S.height + S.top_margin)",
          "1033:           rheight = S.height + S.top_margin;",
          "1034:       }",
          "1035:     S.raw_pitch = S.raw_width*2;",
          "1036:     imgdata.rawdata.raw_image = 0;",
          "1037:     imgdata.rawdata.color4_image = 0;",
          "1038:     imgdata.rawdata.color3_image = 0;",
          "1041:     if(O.use_rawspeed && (decoder_info.decoder_flags & LIBRAW_DECODER_TRYRAWSPEED) && _rawspeed_camerameta)",
          "1042:       {",
          "1043:         INT64 spos = ID.input->tell();",
          "1044:         try",
          "1047:             ID.input->seek(0,SEEK_SET);",
          "1048:             INT64 _rawspeed_buffer_sz = ID.input->size()+32;",
          "1049:             void *_rawspeed_buffer = malloc(_rawspeed_buffer_sz);",
          "1050:             if(!_rawspeed_buffer) throw LIBRAW_EXCEPTION_ALLOC;",
          "1051:             ID.input->read(_rawspeed_buffer,_rawspeed_buffer_sz,1);",
          "1052:             FileMap map((uchar8*)_rawspeed_buffer,_rawspeed_buffer_sz);",
          "1053:             RawParser t(&map);",
          "1054:             RawDecoder *d = 0;",
          "1055:             CameraMetaDataLR *meta = static_cast<CameraMetaDataLR*>(_rawspeed_camerameta);",
          "1056:             d = t.getDecoder();",
          "1057:             try {",
          "1058:               d->checkSupport(meta);",
          "1060:             catch (const RawDecoderException& e)",
          "1062:                 imgdata.process_warnings |= LIBRAW_WARN_RAWSPEED_UNSUPPORTED;",
          "1063:                 throw e;",
          "1065:             d->decodeRaw();",
          "1066:             d->decodeMetaData(meta);",
          "1067:             RawImage r = d->mRaw;",
          "1068:             if (r->isCFA) {",
          "1070:               _rawspeed_decoder = static_cast<void*>(d);",
          "1071:               imgdata.rawdata.raw_image = (ushort*) r->getDataUncropped(0,0);",
          "1072:               S.raw_pitch = r->pitch;",
          "1073:               fix_after_rawspeed(r->blackLevel);",
          "1074:             } else if(r->getCpp()==4) {",
          "1075:               _rawspeed_decoder = static_cast<void*>(d);",
          "1076:               imgdata.rawdata.color4_image = (ushort(*)[4]) r->getDataUncropped(0,0);",
          "1077:               S.raw_pitch = r->pitch;",
          "1078:               C.maximum = r->whitePoint;",
          "1079:               fix_after_rawspeed(r->blackLevel);",
          "1080:             } else if(r->getCpp() == 3)",
          "1082:                 _rawspeed_decoder = static_cast<void*>(d);",
          "1083:                 imgdata.rawdata.color3_image = (ushort(*)[3]) r->getDataUncropped(0,0);",
          "1084:                 S.raw_pitch = r->pitch;",
          "1085:                 C.maximum = r->whitePoint;",
          "1086:                 fix_after_rawspeed(r->blackLevel);",
          "1088:             else",
          "1090:                 delete d;",
          "1092:             free(_rawspeed_buffer);",
          "1093:             imgdata.process_warnings |= LIBRAW_WARN_RAWSPEED_PROCESSED;",
          "1094:           } catch (...) {",
          "1095:           imgdata.process_warnings |= LIBRAW_WARN_RAWSPEED_PROBLEM;",
          "1097:         }",
          "1098:         ID.input->seek(spos,SEEK_SET);",
          "1099:       }",
          "1100: #endif",
          "1101:     if(!imgdata.rawdata.raw_image && !imgdata.rawdata.color4_image && !imgdata.rawdata.color3_image) // RawSpeed failed!",
          "1102:       {",
          "1104:         if(decoder_info.decoder_flags &  LIBRAW_DECODER_FLATFIELD)",
          "1105:           {",
          "1106:             imgdata.rawdata.raw_alloc = malloc(rwidth*(rheight+7)*sizeof(imgdata.rawdata.raw_image[0]));",
          "1107:             imgdata.rawdata.raw_image = (ushort*) imgdata.rawdata.raw_alloc;",
          "1108:           }",
          "1109:         else if (decoder_info.decoder_flags & LIBRAW_DECODER_LEGACY)",
          "1110:           {",
          "1113:             S.iwidth = S.width;",
          "1114:             S.iheight= S.height;",
          "1115:             IO.shrink = 0;",
          "1116:             S.raw_pitch = S.width*8;",
          "1118:             imgdata.rawdata.raw_alloc = 0;",
          "1119:             imgdata.image = (ushort (*)[4]) calloc(S.iwidth*S.iheight,sizeof(*imgdata.image));",
          "1121:         ID.input->seek(libraw_internal_data.unpacker_data.data_offset, SEEK_SET);",
          "1123:         unsigned m_save = C.maximum;",
          "1124:         if(load_raw == &LibRaw::unpacked_load_raw && !strcasecmp(imgdata.idata.make,\"Nikon\"))",
          "1125:           C.maximum=65535;",
          "1126:         (this->*load_raw)();",
          "1127:         if(load_raw == &LibRaw::unpacked_load_raw && !strcasecmp(imgdata.idata.make,\"Nikon\"))",
          "1128:           C.maximum = m_save;",
          "1129:         if (decoder_info.decoder_flags & LIBRAW_DECODER_LEGACY)",
          "1130:           {",
          "1132:             imgdata.rawdata.raw_alloc = imgdata.image;",
          "1133:             imgdata.image = 0;",
          "1135:             S.raw_width = S.width;",
          "1136:             S.left_margin = 0;",
          "1137:             S.raw_height = S.height;",
          "1138:             S.top_margin = 0;",
          "1139:           }",
          "1140:       }",
          "1142:     if(imgdata.rawdata.raw_image)",
          "1143:       crop_masked_pixels(); // calculate black levels",
          "1146:     if( (decoder_info.decoder_flags & LIBRAW_DECODER_LEGACY) && !imgdata.rawdata.color4_image)",
          "1147:       {",
          "1148:         imgdata.image = 0;",
          "1149:         imgdata.rawdata.color4_image = (ushort (*)[4]) imgdata.rawdata.raw_alloc;",
          "1150:       }",
          "1153:     S.iwidth = save_iwidth;",
          "1154:     S.iheight = save_iheight;",
          "1155:     IO.shrink = save_shrink;",
          "1158:     unsigned int i = C.cblack[3];",
          "1159:     unsigned int c;",
          "1160:     for(c=0;c<3;c++)",
          "1161:       if (i > C.cblack[c]) i = C.cblack[c];",
          "1162:     for (c=0;c<4;c++)",
          "1163:       C.cblack[c] -= i;",
          "1164:     C.black += i;",
          "1167:     memmove(&imgdata.rawdata.color,&imgdata.color,sizeof(imgdata.color));",
          "1168:     memmove(&imgdata.rawdata.sizes,&imgdata.sizes,sizeof(imgdata.sizes));",
          "1169:     memmove(&imgdata.rawdata.iparams,&imgdata.idata,sizeof(imgdata.idata));",
          "1170:     memmove(&imgdata.rawdata.ioparams,&libraw_internal_data.internal_output_params,sizeof(libraw_internal_data.internal_output_params));",
          "1172:     SET_PROC_FLAG(LIBRAW_PROGRESS_LOAD_RAW);",
          "1173:     RUN_CALLBACK(LIBRAW_PROGRESS_LOAD_RAW,1,2);",
          "1175:     return 0;",
          "1176:   }",
          "1177:   catch ( LibRaw_exceptions err) {",
          "1178:     EXCEPTION_HANDLER(err);",
          "1179:   }",
          "1180:   catch (std::exception ee) {",
          "1181:     EXCEPTION_HANDLER(LIBRAW_EXCEPTION_IO_CORRUPT);",
          "1182:   }",
          "1187:   if(imgdata.image)",
          "1188:     {",
          "1189:       free(imgdata.image);",
          "1190:       imgdata.image = 0;",
          "1191:       imgdata.progress_flags",
          "1192:         = LIBRAW_PROGRESS_START|LIBRAW_PROGRESS_OPEN",
          "1193:         |LIBRAW_PROGRESS_IDENTIFY|LIBRAW_PROGRESS_SIZE_ADJUST|LIBRAW_PROGRESS_LOAD_RAW;",
          "1194:     }",
          "1201:   memmove(&imgdata.color,&imgdata.rawdata.color,sizeof(imgdata.color));",
          "1202:   memmove(&imgdata.sizes,&imgdata.rawdata.sizes,sizeof(imgdata.sizes));",
          "1203:   memmove(&imgdata.idata,&imgdata.rawdata.iparams,sizeof(imgdata.idata));",
          "1204:   memmove(&libraw_internal_data.internal_output_params,&imgdata.rawdata.ioparams,sizeof(libraw_internal_data.internal_output_params));",
          "1206:   if (O.user_flip >= 0)",
          "1207:     S.flip = O.user_flip;",
          "1209:   switch ((S.flip+3600) % 360)",
          "1210:     {",
          "1211:     case 270:  S.flip = 5;  break;",
          "1212:     case 180:  S.flip = 3;  break;",
          "1213:     case  90:  S.flip = 6;  break;",
          "1214:     }",
          "1217:   IO.shrink = P1.filters && (O.half_size ||",
          "1218:                              ((O.threshold || O.aber[0] != 1 || O.aber[2] != 1) ));",
          "1220:   S.iheight = (S.height + IO.shrink) >> IO.shrink;",
          "1221:   S.iwidth  = (S.width  + IO.shrink) >> IO.shrink;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1229: int LibRaw::raw2image(void)",
          "1230: {",
          "1285:               }",
          "1286:             }",
          "1325:           {",
          "1327:           }",
          "1331:           {",
          "1333:           }",
          "1343: }",
          "1345: void LibRaw::phase_one_allocate_tempbuffer()",
          "",
          "[Removed Lines]",
          "1232:     CHECK_ORDER_LOW(LIBRAW_PROGRESS_LOAD_RAW);",
          "1234:     try {",
          "1235:         raw2image_start();",
          "1237:         if (is_phaseone_compressed())",
          "1238:           {",
          "1239:      phase_one_allocate_tempbuffer();",
          "1240:      phase_one_subtract_black((ushort*)imgdata.rawdata.raw_alloc,imgdata.rawdata.raw_image);",
          "1241:            phase_one_correct();",
          "1242:           }",
          "1245:         if(imgdata.image)",
          "1246:             {",
          "1247:                 imgdata.image = (ushort (*)[4]) realloc (imgdata.image,S.iheight*S.iwidth *sizeof (*imgdata.image));",
          "1248:                 memset(imgdata.image,0,S.iheight*S.iwidth *sizeof (*imgdata.image));",
          "1249:             }",
          "1250:         else",
          "1251:             imgdata.image = (ushort (*)[4]) calloc (S.iheight*S.iwidth, sizeof (*imgdata.image));",
          "1253:         merror (imgdata.image, \"raw2image()\");",
          "1255:         libraw_decoder_info_t decoder_info;",
          "1256:         get_decoder_info(&decoder_info);",
          "1259:         if(decoder_info.decoder_flags & LIBRAW_DECODER_FLATFIELD)",
          "1260:             {",
          "1261:               if (IO.fuji_width) {",
          "1262:                 unsigned r,c;",
          "1263:                 int row,col;",
          "1264:                 for (row=0; row < S.raw_height-S.top_margin*2; row++) {",
          "1265:                   for (col=0; col < IO.fuji_width << !libraw_internal_data.unpacker_data.fuji_layout; col++) {",
          "1266:                     if (libraw_internal_data.unpacker_data.fuji_layout) {",
          "1267:                       r = IO.fuji_width - 1 - col + (row >> 1);",
          "1268:                       c = col + ((row+1) >> 1);",
          "1269:                     } else {",
          "1270:                       r = IO.fuji_width - 1 + row - (col >> 1);",
          "1271:                       c = row + ((col+1) >> 1);",
          "1272:                     }",
          "1273:                     if (r < S.height && c < S.width)",
          "1274:                       imgdata.image[((r)>>IO.shrink)*S.iwidth+((c)>>IO.shrink)][FC(r,c)]",
          "1275:                         = imgdata.rawdata.raw_image[(row+S.top_margin)*S.raw_pitch/2+(col+S.left_margin)];",
          "1276:                   }",
          "1277:                 }",
          "1278:               }",
          "1279:               else {",
          "1280:                 int row,col;",
          "1281:                 for (row=0; row < S.height; row++)",
          "1282:                   for (col=0; col < S.width; col++)",
          "1283:                     imgdata.image[((row) >> IO.shrink)*S.iwidth + ((col) >> IO.shrink)][fcol(row,col)]",
          "1284:                         = imgdata.rawdata.raw_image[(row+S.top_margin)*S.raw_pitch/2+(col+S.left_margin)];",
          "1287:         else if(decoder_info.decoder_flags & LIBRAW_DECODER_LEGACY)",
          "1288:             {",
          "1289:               if(imgdata.rawdata.color4_image)",
          "1290:                 {",
          "1291:                   if(S.width*8 == S.raw_pitch)",
          "1292:                     memmove(imgdata.image,imgdata.rawdata.color4_image,S.width*S.height*sizeof(*imgdata.image));",
          "1293:                   else",
          "1294:                     {",
          "1295:                       for(int row = 0; row < S.height; row++)",
          "1296:                         memmove(&imgdata.image[row*S.width],",
          "1297:                                 &imgdata.rawdata.color4_image[(row+S.top_margin)*S.raw_pitch/8+S.left_margin],",
          "1298:                                 S.width*sizeof(*imgdata.image));",
          "1299:                     }",
          "1300:                 }",
          "1301:               else if(imgdata.rawdata.color3_image)",
          "1302:                 {",
          "1303:                   unsigned char *c3image = (unsigned char*) imgdata.rawdata.color3_image;",
          "1304:                   for(int row = 0; row < S.height; row++)",
          "1305:                     {",
          "1306:                       ushort (*srcrow)[3] = (ushort (*)[3]) &c3image[(row+S.top_margin)*S.raw_pitch];",
          "1307:                       ushort (*dstrow)[4] = (ushort (*)[4]) &imgdata.image[row*S.width];",
          "1308:                       for(int col=0; col < S.width; col++)",
          "1309:                         {",
          "1310:                           for(int c=0; c< 3; c++)",
          "1311:                             dstrow[col][c] = srcrow[S.left_margin+col][c];",
          "1312:                           dstrow[col][3]=0;",
          "1313:                         }",
          "1314:                     }",
          "1315:                 }",
          "1316:               else",
          "1317:                 {",
          "1319:                   throw LIBRAW_EXCEPTION_DECODE_RAW;",
          "1320:                 }",
          "1321:             }",
          "1324:         if (is_phaseone_compressed())",
          "1326:      phase_one_free_tempbuffer();",
          "1330:         if (load_raw == &CLASS canon_600_load_raw && S.width < S.raw_width)",
          "1332:             canon_600_correct();",
          "1335:         imgdata.progress_flags",
          "1336:             = LIBRAW_PROGRESS_START|LIBRAW_PROGRESS_OPEN | LIBRAW_PROGRESS_RAW2_IMAGE",
          "1337:             |LIBRAW_PROGRESS_IDENTIFY|LIBRAW_PROGRESS_SIZE_ADJUST|LIBRAW_PROGRESS_LOAD_RAW;",
          "1338:         return 0;",
          "1339:     }",
          "1340:     catch ( LibRaw_exceptions err) {",
          "1341:         EXCEPTION_HANDLER(err);",
          "1342:     }",
          "",
          "[Added Lines]",
          "1233:   CHECK_ORDER_LOW(LIBRAW_PROGRESS_LOAD_RAW);",
          "1235:   try {",
          "1236:     raw2image_start();",
          "1238:     if (is_phaseone_compressed())",
          "1239:       {",
          "1240:         phase_one_allocate_tempbuffer();",
          "1241:         phase_one_subtract_black((ushort*)imgdata.rawdata.raw_alloc,imgdata.rawdata.raw_image);",
          "1242:         phase_one_correct();",
          "1243:       }",
          "1246:     if(imgdata.image)",
          "1247:       {",
          "1248:         imgdata.image = (ushort (*)[4]) realloc (imgdata.image,S.iheight*S.iwidth *sizeof (*imgdata.image));",
          "1249:         memset(imgdata.image,0,S.iheight*S.iwidth *sizeof (*imgdata.image));",
          "1250:       }",
          "1251:     else",
          "1252:       imgdata.image = (ushort (*)[4]) calloc (S.iheight*S.iwidth, sizeof (*imgdata.image));",
          "1254:     merror (imgdata.image, \"raw2image()\");",
          "1256:     libraw_decoder_info_t decoder_info;",
          "1257:     get_decoder_info(&decoder_info);",
          "1260:     if(decoder_info.decoder_flags & LIBRAW_DECODER_FLATFIELD)",
          "1261:       {",
          "1262:         if (IO.fuji_width) {",
          "1263:           unsigned r,c;",
          "1264:           int row,col;",
          "1265:           for (row=0; row < S.raw_height-S.top_margin*2; row++) {",
          "1266:             for (col=0; col < IO.fuji_width << !libraw_internal_data.unpacker_data.fuji_layout; col++) {",
          "1267:               if (libraw_internal_data.unpacker_data.fuji_layout) {",
          "1268:                 r = IO.fuji_width - 1 - col + (row >> 1);",
          "1269:                 c = col + ((row+1) >> 1);",
          "1270:               } else {",
          "1271:                 r = IO.fuji_width - 1 + row - (col >> 1);",
          "1272:                 c = row + ((col+1) >> 1);",
          "1274:               if (r < S.height && c < S.width)",
          "1275:                 imgdata.image[((r)>>IO.shrink)*S.iwidth+((c)>>IO.shrink)][FC(r,c)]",
          "1276:                   = imgdata.rawdata.raw_image[(row+S.top_margin)*S.raw_pitch/2+(col+S.left_margin)];",
          "1278:           }",
          "1279:         }",
          "1280:         else {",
          "1281:           int row,col;",
          "1282:           for (row=0; row < S.height; row++)",
          "1283:             for (col=0; col < S.width; col++)",
          "1284:               imgdata.image[((row) >> IO.shrink)*S.iwidth + ((col) >> IO.shrink)][fcol(row,col)]",
          "1285:                 = imgdata.rawdata.raw_image[(row+S.top_margin)*S.raw_pitch/2+(col+S.left_margin)];",
          "1286:         }",
          "1287:       }",
          "1288:     else if(decoder_info.decoder_flags & LIBRAW_DECODER_LEGACY)",
          "1289:       {",
          "1290:         if(imgdata.rawdata.color4_image)",
          "1292:             if(S.width*8 == S.raw_pitch)",
          "1293:               memmove(imgdata.image,imgdata.rawdata.color4_image,S.width*S.height*sizeof(*imgdata.image));",
          "1294:             else",
          "1295:               {",
          "1296:                 for(int row = 0; row < S.height; row++)",
          "1297:                   memmove(&imgdata.image[row*S.width],",
          "1298:                           &imgdata.rawdata.color4_image[(row+S.top_margin)*S.raw_pitch/8+S.left_margin],",
          "1299:                           S.width*sizeof(*imgdata.image));",
          "1300:               }",
          "1302:         else if(imgdata.rawdata.color3_image)",
          "1304:             unsigned char *c3image = (unsigned char*) imgdata.rawdata.color3_image;",
          "1305:             for(int row = 0; row < S.height; row++)",
          "1306:               {",
          "1307:                 ushort (*srcrow)[3] = (ushort (*)[3]) &c3image[(row+S.top_margin)*S.raw_pitch];",
          "1308:                 ushort (*dstrow)[4] = (ushort (*)[4]) &imgdata.image[row*S.width];",
          "1309:                 for(int col=0; col < S.width; col++)",
          "1310:                   {",
          "1311:                     for(int c=0; c< 3; c++)",
          "1312:                       dstrow[col][c] = srcrow[S.left_margin+col][c];",
          "1313:                     dstrow[col][3]=0;",
          "1314:                   }",
          "1315:               }",
          "1316:           }",
          "1317:         else",
          "1318:           {",
          "1320:             throw LIBRAW_EXCEPTION_DECODE_RAW;",
          "1322:       }",
          "1325:     if (is_phaseone_compressed())",
          "1326:       {",
          "1327:         phase_one_free_tempbuffer();",
          "1328:       }",
          "1331:     if (load_raw == &CLASS canon_600_load_raw && S.width < S.raw_width)",
          "1332:       {",
          "1333:         canon_600_correct();",
          "1334:       }",
          "1336:     imgdata.progress_flags",
          "1337:       = LIBRAW_PROGRESS_START|LIBRAW_PROGRESS_OPEN | LIBRAW_PROGRESS_RAW2_IMAGE",
          "1338:       |LIBRAW_PROGRESS_IDENTIFY|LIBRAW_PROGRESS_SIZE_ADJUST|LIBRAW_PROGRESS_LOAD_RAW;",
          "1339:     return 0;",
          "1340:   }",
          "1341:   catch ( LibRaw_exceptions err) {",
          "1342:     EXCEPTION_HANDLER(err);",
          "1343:   }",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1488:     if (is_phaseone_compressed())",
          "1489:       {",
          "1493:       }",
          "",
          "[Removed Lines]",
          "1490:     phase_one_allocate_tempbuffer();",
          "1491:     phase_one_subtract_black((ushort*)imgdata.rawdata.raw_alloc,imgdata.rawdata.raw_image);",
          "1492:           phase_one_correct();",
          "",
          "[Added Lines]",
          "1491:         phase_one_allocate_tempbuffer();",
          "1492:         phase_one_subtract_black((ushort*)imgdata.rawdata.raw_alloc,imgdata.rawdata.raw_image);",
          "1493:         phase_one_correct();",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1713: libraw_processed_image_t * LibRaw::dcraw_make_mem_thumb(int *errcode)",
          "1714: {",
          "1729:         {",
          "1749:         }",
          "1751:         {",
          "1791:         }",
          "1793:         {",
          "1797:         }",
          "1798: }",
          "",
          "[Removed Lines]",
          "1715:     if(!T.thumb)",
          "1716:       {",
          "1717:         if ( !ID.toffset)",
          "1718:           {",
          "1719:             if(errcode) *errcode= LIBRAW_NO_THUMBNAIL;",
          "1720:           }",
          "1721:         else",
          "1722:           {",
          "1723:             if(errcode) *errcode= LIBRAW_OUT_OF_ORDER_CALL;",
          "1724:           }",
          "1725:         return NULL;",
          "1726:       }",
          "1728:     if (T.tformat == LIBRAW_THUMBNAIL_BITMAP)",
          "1730:             libraw_processed_image_t * ret =",
          "1731:                 (libraw_processed_image_t *)::malloc(sizeof(libraw_processed_image_t)+T.tlength);",
          "1733:             if(!ret)",
          "1734:                 {",
          "1735:                     if(errcode) *errcode= ENOMEM;",
          "1736:                     return NULL;",
          "1737:                 }",
          "1739:             memset(ret,0,sizeof(libraw_processed_image_t));",
          "1740:             ret->type   = LIBRAW_IMAGE_BITMAP;",
          "1741:             ret->height = T.theight;",
          "1742:             ret->width  = T.twidth;",
          "1743:             ret->colors = 3;",
          "1744:             ret->bits   = 8;",
          "1745:             ret->data_size = T.tlength;",
          "1746:             memmove(ret->data,T.thumb,T.tlength);",
          "1747:             if(errcode) *errcode= 0;",
          "1748:             return ret;",
          "1750:     else if (T.tformat == LIBRAW_THUMBNAIL_JPEG)",
          "1752:             ushort exif[5];",
          "1753:             int mk_exif = 0;",
          "1754:             if(strcmp(T.thumb+6,\"Exif\")) mk_exif = 1;",
          "1756:             int dsize = T.tlength + mk_exif * (sizeof(exif)+sizeof(tiff_hdr));",
          "1758:             libraw_processed_image_t * ret =",
          "1759:                 (libraw_processed_image_t *)::malloc(sizeof(libraw_processed_image_t)+dsize);",
          "1761:             if(!ret)",
          "1762:                 {",
          "1763:                     if(errcode) *errcode= ENOMEM;",
          "1764:                     return NULL;",
          "1765:                 }",
          "1767:             memset(ret,0,sizeof(libraw_processed_image_t));",
          "1769:             ret->type = LIBRAW_IMAGE_JPEG;",
          "1770:             ret->data_size = dsize;",
          "1772:             ret->data[0] = 0xff;",
          "1773:             ret->data[1] = 0xd8;",
          "1774:             if(mk_exif)",
          "1775:                 {",
          "1776:                     struct tiff_hdr th;",
          "1777:                     memcpy (exif, \"\\xff\\xe1  Exif\\0\\0\", 10);",
          "1778:                     exif[1] = htons (8 + sizeof th);",
          "1779:                     memmove(ret->data+2,exif,sizeof(exif));",
          "1780:                     tiff_head (&th, 0);",
          "1781:                     memmove(ret->data+(2+sizeof(exif)),&th,sizeof(th));",
          "1782:                     memmove(ret->data+(2+sizeof(exif)+sizeof(th)),T.thumb+2,T.tlength-2);",
          "1783:                 }",
          "1784:             else",
          "1785:                 {",
          "1786:                     memmove(ret->data+2,T.thumb+2,T.tlength-2);",
          "1787:                 }",
          "1788:             if(errcode) *errcode= 0;",
          "1789:             return ret;",
          "1792:     else",
          "1794:             if(errcode) *errcode= LIBRAW_UNSUPPORTED_THUMBNAIL;",
          "1795:             return NULL;",
          "",
          "[Added Lines]",
          "1716:   if(!T.thumb)",
          "1717:     {",
          "1718:       if ( !ID.toffset)",
          "1720:           if(errcode) *errcode= LIBRAW_NO_THUMBNAIL;",
          "1722:       else",
          "1723:         {",
          "1724:           if(errcode) *errcode= LIBRAW_OUT_OF_ORDER_CALL;",
          "1725:         }",
          "1726:       return NULL;",
          "1727:     }",
          "1729:   if (T.tformat == LIBRAW_THUMBNAIL_BITMAP)",
          "1730:     {",
          "1731:       libraw_processed_image_t * ret =",
          "1732:         (libraw_processed_image_t *)::malloc(sizeof(libraw_processed_image_t)+T.tlength);",
          "1734:       if(!ret)",
          "1736:           if(errcode) *errcode= ENOMEM;",
          "1737:           return NULL;",
          "1738:         }",
          "1740:       memset(ret,0,sizeof(libraw_processed_image_t));",
          "1741:       ret->type   = LIBRAW_IMAGE_BITMAP;",
          "1742:       ret->height = T.theight;",
          "1743:       ret->width  = T.twidth;",
          "1744:       ret->colors = 3;",
          "1745:       ret->bits   = 8;",
          "1746:       ret->data_size = T.tlength;",
          "1747:       memmove(ret->data,T.thumb,T.tlength);",
          "1748:       if(errcode) *errcode= 0;",
          "1749:       return ret;",
          "1750:     }",
          "1751:   else if (T.tformat == LIBRAW_THUMBNAIL_JPEG)",
          "1752:     {",
          "1753:       ushort exif[5];",
          "1754:       int mk_exif = 0;",
          "1755:       if(strcmp(T.thumb+6,\"Exif\")) mk_exif = 1;",
          "1757:       int dsize = T.tlength + mk_exif * (sizeof(exif)+sizeof(tiff_hdr));",
          "1759:       libraw_processed_image_t * ret =",
          "1760:         (libraw_processed_image_t *)::malloc(sizeof(libraw_processed_image_t)+dsize);",
          "1762:       if(!ret)",
          "1763:         {",
          "1764:           if(errcode) *errcode= ENOMEM;",
          "1765:           return NULL;",
          "1766:         }",
          "1768:       memset(ret,0,sizeof(libraw_processed_image_t));",
          "1770:       ret->type = LIBRAW_IMAGE_JPEG;",
          "1771:       ret->data_size = dsize;",
          "1773:       ret->data[0] = 0xff;",
          "1774:       ret->data[1] = 0xd8;",
          "1775:       if(mk_exif)",
          "1776:         {",
          "1777:           struct tiff_hdr th;",
          "1778:           memcpy (exif, \"\\xff\\xe1  Exif\\0\\0\", 10);",
          "1779:           exif[1] = htons (8 + sizeof th);",
          "1780:           memmove(ret->data+2,exif,sizeof(exif));",
          "1781:           tiff_head (&th, 0);",
          "1782:           memmove(ret->data+(2+sizeof(exif)),&th,sizeof(th));",
          "1783:           memmove(ret->data+(2+sizeof(exif)+sizeof(th)),T.thumb+2,T.tlength-2);",
          "1785:       else",
          "1787:           memmove(ret->data+2,T.thumb+2,T.tlength-2);",
          "1789:       if(errcode) *errcode= 0;",
          "1790:       return ret;",
          "1792:     }",
          "1793:   else",
          "1794:     {",
          "1795:       if(errcode) *errcode= LIBRAW_UNSUPPORTED_THUMBNAIL;",
          "1796:       return NULL;",
          "1797:     }",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1807: void LibRaw::get_mem_image_format(int* width, int* height, int* colors, int* bps) const",
          "1809: {",
          "1820: }",
          "1822: int LibRaw::copy_mem_image(void* scan0, int stride, int bgr)",
          "",
          "[Removed Lines]",
          "1810:     if (S.flip & 4) {",
          "1813:     }",
          "1814:     else {",
          "1817:     }",
          "",
          "[Added Lines]",
          "1810:   if (S.flip & 4) {",
          "1813:   }",
          "1814:   else {",
          "1817:   }",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1827:         return LIBRAW_OUT_OF_ORDER_CALL;",
          "1829:     if(libraw_internal_data.output_data.histogram)",
          "1843:     int s_iheight = S.iheight;",
          "1844:     int s_iwidth = S.iwidth;",
          "1845:     int s_width = S.width;",
          "",
          "[Removed Lines]",
          "1830:         {",
          "1831:           int perc, val, total, t_white=0x2000,c;",
          "1833:           if (IO.fuji_width) perc /= 2;",
          "1834:           if (!((O.highlight & ~2) || O.no_auto_bright))",
          "1835:             for (t_white=c=0; c < P1.colors; c++) {",
          "1836:               for (val=0x2000, total=0; --val > 32; )",
          "1837:                 if ((total += libraw_internal_data.output_data.histogram[c][val]) > perc) break;",
          "1838:               if (t_white < val) t_white = val;",
          "1839:             }",
          "1840:           gamma_curve (O.gamm[0], O.gamm[1], 2, (t_white << 3)/O.bright);",
          "1841:         }",
          "",
          "[Added Lines]",
          "1830:       {",
          "1831:         int perc, val, total, t_white=0x2000,c;",
          "1833:         if (IO.fuji_width) perc /= 2;",
          "1834:         if (!((O.highlight & ~2) || O.no_auto_bright))",
          "1835:           for (t_white=c=0; c < P1.colors; c++) {",
          "1836:             for (val=0x2000, total=0; --val > 32; )",
          "1837:               if ((total += libraw_internal_data.output_data.histogram[c][val]) > perc) break;",
          "1838:             if (t_white < val) t_white = val;",
          "1839:           }",
          "1840:         gamma_curve (O.gamm[0], O.gamm[1], 2, (t_white << 3)/O.bright);",
          "1841:       }",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "1936: int LibRaw::dcraw_ppm_tiff_writer(const char *filename)",
          "1937: {",
          "1968: }",
          "1970: void LibRaw::kodak_thumb_loader()",
          "1971: {",
          "1997: #define MIN(a,b) ((a) < (b) ? (a) : (b))",
          "1998: #define MAX(a,b) ((a) > (b) ? (a) : (b))",
          "1999: #define LIM(x,min,max) MAX(min,MIN(x,max))",
          "2000: #define CLIP(x) LIM(x,0,65535)",
          "2001: #define SWAP(a,b) { a ^= b; a ^= (b ^= a); }",
          "2131: }",
          "2132: #undef MIN",
          "2133: #undef MAX",
          "",
          "[Removed Lines]",
          "1938:     CHECK_ORDER_LOW(LIBRAW_PROGRESS_LOAD_RAW);",
          "1940:     if(!imgdata.image)",
          "1941:         return LIBRAW_OUT_OF_ORDER_CALL;",
          "1943:     if(!filename)",
          "1944:         return ENOENT;",
          "1945:     FILE *f = fopen(filename,\"wb\");",
          "1947:     if(!f)",
          "1948:         return errno;",
          "1950:     try {",
          "1951:         if(!libraw_internal_data.output_data.histogram)",
          "1952:             {",
          "1953:                 libraw_internal_data.output_data.histogram =",
          "1954:                     (int (*)[LIBRAW_HISTOGRAM_SIZE]) malloc(sizeof(*libraw_internal_data.output_data.histogram)*4);",
          "1955:                 merror(libraw_internal_data.output_data.histogram,\"LibRaw::dcraw_ppm_tiff_writer()\");",
          "1956:             }",
          "1957:         libraw_internal_data.internal_data.output = f;",
          "1958:         write_ppm_tiff();",
          "1959:         SET_PROC_FLAG(LIBRAW_PROGRESS_FLIP);",
          "1960:         libraw_internal_data.internal_data.output = NULL;",
          "1961:         fclose(f);",
          "1962:         return 0;",
          "1963:     }",
          "1964:     catch ( LibRaw_exceptions err) {",
          "1965:         fclose(f);",
          "1966:         EXCEPTION_HANDLER(err);",
          "1967:     }",
          "1973:     ushort s_height = S.height, s_width = S.width,s_iwidth = S.iwidth,s_iheight=S.iheight;",
          "1974:     int s_colors = P1.colors;",
          "1975:     unsigned s_filters = P1.filters;",
          "1976:     ushort (*s_image)[4] = imgdata.image;",
          "1979:     S.height = T.theight;",
          "1980:     S.width  = T.twidth;",
          "1981:     P1.filters = 0;",
          "1983:     if (thumb_load_raw == &CLASS kodak_ycbcr_load_raw)",
          "1984:         {",
          "1985:             S.height += S.height & 1;",
          "1986:             S.width  += S.width  & 1;",
          "1987:         }",
          "1989:     imgdata.image = (ushort (*)[4]) calloc (S.iheight*S.iwidth, sizeof (*imgdata.image));",
          "1990:     merror (imgdata.image, \"LibRaw::kodak_thumb_loader()\");",
          "1992:     ID.input->seek(ID.toffset, SEEK_SET);",
          "1994:     (this->*thumb_load_raw)();",
          "2004:     {",
          "2005:         double   dmax;",
          "2006:         float scale_mul[4];",
          "2007:         int c,val;",
          "2008:         for (dmax=DBL_MAX, c=0; c < 3; c++)",
          "2009:                 if (dmax > C.pre_mul[c])",
          "2010:                     dmax = C.pre_mul[c];",
          "2012:         for( c=0; c< 3; c++)",
          "2013:                 scale_mul[c] = (C.pre_mul[c] / dmax) * 65535.0 / C.maximum;",
          "2014:         scale_mul[3] = scale_mul[1];",
          "2016:         size_t size = S.height * S.width;",
          "2017:         for (unsigned i=0; i < size*4 ; i++)",
          "2018:             {",
          "2019:                 val = imgdata.image[0][i];",
          "2020:                 if(!val) continue;",
          "2021:                 val *= scale_mul[i & 3];",
          "2022:                 imgdata.image[0][i] = CLIP(val);",
          "2023:             }",
          "2024:     }",
          "2027:     ushort *img;",
          "2028:     int row,col;",
          "2030:     int  (*t_hist)[LIBRAW_HISTOGRAM_SIZE] =  (int (*)[LIBRAW_HISTOGRAM_SIZE]) calloc(sizeof(*t_hist),4);",
          "2031:     merror (t_hist, \"LibRaw::kodak_thumb_loader()\");",
          "2033:     float out[3],",
          "2034:         out_cam[3][4] =",
          "2035:         {",
          "2036:             {2.81761312, -1.98369181, 0.166078627, 0},",
          "2037:             {-0.111855984, 1.73688626, -0.625030339, 0},",
          "2038:             {-0.0379119813, -0.891268849, 1.92918086, 0}",
          "2039:         };",
          "2041:     for (img=imgdata.image[0], row=0; row < S.height; row++)",
          "2042:         for (col=0; col < S.width; col++, img+=4)",
          "2043:             {",
          "2044:                 out[0] = out[1] = out[2] = 0;",
          "2045:                 int c;",
          "2046:                 for(c=0;c<3;c++)",
          "2047:                     {",
          "2048:                         out[0] += out_cam[0][c] * img[c];",
          "2049:                         out[1] += out_cam[1][c] * img[c];",
          "2050:                         out[2] += out_cam[2][c] * img[c];",
          "2051:                     }",
          "2052:                 for(c=0; c<3; c++)",
          "2053:                     img[c] = CLIP((int) out[c]);",
          "2054:                 for(c=0; c<P1.colors;c++)",
          "2055:                     t_hist[c][img[c] >> 3]++;",
          "2057:             }",
          "2060:     int  (*save_hist)[LIBRAW_HISTOGRAM_SIZE] = libraw_internal_data.output_data.histogram;",
          "2061:     libraw_internal_data.output_data.histogram = t_hist;",
          "2064:     ushort (*t_curve) = (ushort*) calloc(sizeof(C.curve),1);",
          "2065:     merror (t_curve, \"LibRaw::kodak_thumb_loader()\");",
          "2066:     memmove(t_curve,C.curve,sizeof(C.curve));",
          "2067:     memset(C.curve,0,sizeof(C.curve));",
          "2068:         {",
          "2069:             int perc, val, total, t_white=0x2000,c;",
          "2072:             if (IO.fuji_width) perc /= 2;",
          "2073:             if (!((O.highlight & ~2) || O.no_auto_bright))",
          "2074:                 for (t_white=c=0; c < P1.colors; c++) {",
          "2075:                     for (val=0x2000, total=0; --val > 32; )",
          "2076:                         if ((total += libraw_internal_data.output_data.histogram[c][val]) > perc) break;",
          "2077:                     if (t_white < val) t_white = val;",
          "2078:                 }",
          "2079:             gamma_curve (O.gamm[0], O.gamm[1], 2, (t_white << 3)/O.bright);",
          "2080:         }",
          "2082:     libraw_internal_data.output_data.histogram = save_hist;",
          "2083:     free(t_hist);",
          "2087:     S.iheight = S.height;",
          "2088:     S.iwidth  = S.width;",
          "2089:     if (S.flip & 4) SWAP(S.height,S.width);",
          "2091:     if(T.thumb) free(T.thumb);",
          "2092:     T.thumb = (char*) calloc (S.width * S.height, P1.colors);",
          "2093:     merror (T.thumb, \"LibRaw::kodak_thumb_loader()\");",
          "2094:     T.tlength = S.width * S.height * P1.colors;",
          "2097:     {",
          "2098:         int soff  = flip_index (0, 0);",
          "2099:         int cstep = flip_index (0, 1) - soff;",
          "2100:         int rstep = flip_index (1, 0) - flip_index (0, S.width);",
          "2102:         for (int row=0; row < S.height; row++, soff += rstep)",
          "2103:             {",
          "2104:                 char *ppm = T.thumb + row*S.width*P1.colors;",
          "2105:                 for (int col=0; col < S.width; col++, soff += cstep)",
          "2106:                     for(int c = 0; c < P1.colors; c++)",
          "2107:                         ppm [col*P1.colors+c] = imgdata.color.curve[imgdata.image[soff][c]]>>8;",
          "2108:             }",
          "2109:     }",
          "2111:     memmove(C.curve,t_curve,sizeof(C.curve));",
          "2112:     free(t_curve);",
          "2115:     free(imgdata.image);",
          "2116:     imgdata.image  = s_image;",
          "2118:     T.twidth = S.width;",
          "2119:     S.width = s_width;",
          "2121:     S.iwidth = s_iwidth;",
          "2122:     S.iheight = s_iheight;",
          "2124:     T.theight = S.height;",
          "2125:     S.height = s_height;",
          "2127:     T.tcolors = P1.colors;",
          "2128:     P1.colors = s_colors;",
          "2130:     P1.filters = s_filters;",
          "",
          "[Added Lines]",
          "1938:   CHECK_ORDER_LOW(LIBRAW_PROGRESS_LOAD_RAW);",
          "1940:   if(!imgdata.image)",
          "1941:     return LIBRAW_OUT_OF_ORDER_CALL;",
          "1943:   if(!filename)",
          "1944:     return ENOENT;",
          "1945:   FILE *f = fopen(filename,\"wb\");",
          "1947:   if(!f)",
          "1948:     return errno;",
          "1950:   try {",
          "1951:     if(!libraw_internal_data.output_data.histogram)",
          "1952:       {",
          "1953:         libraw_internal_data.output_data.histogram =",
          "1954:           (int (*)[LIBRAW_HISTOGRAM_SIZE]) malloc(sizeof(*libraw_internal_data.output_data.histogram)*4);",
          "1955:         merror(libraw_internal_data.output_data.histogram,\"LibRaw::dcraw_ppm_tiff_writer()\");",
          "1956:       }",
          "1957:     libraw_internal_data.internal_data.output = f;",
          "1958:     write_ppm_tiff();",
          "1959:     SET_PROC_FLAG(LIBRAW_PROGRESS_FLIP);",
          "1960:     libraw_internal_data.internal_data.output = NULL;",
          "1961:     fclose(f);",
          "1962:     return 0;",
          "1963:   }",
          "1964:   catch ( LibRaw_exceptions err) {",
          "1965:     fclose(f);",
          "1966:     EXCEPTION_HANDLER(err);",
          "1967:   }",
          "1973:   ushort s_height = S.height, s_width = S.width,s_iwidth = S.iwidth,s_iheight=S.iheight;",
          "1974:   int s_colors = P1.colors;",
          "1975:   unsigned s_filters = P1.filters;",
          "1976:   ushort (*s_image)[4] = imgdata.image;",
          "1979:   S.height = T.theight;",
          "1980:   S.width  = T.twidth;",
          "1981:   P1.filters = 0;",
          "1983:   if (thumb_load_raw == &CLASS kodak_ycbcr_load_raw)",
          "1984:     {",
          "1985:       S.height += S.height & 1;",
          "1986:       S.width  += S.width  & 1;",
          "1987:     }",
          "1989:   imgdata.image = (ushort (*)[4]) calloc (S.iheight*S.iwidth, sizeof (*imgdata.image));",
          "1990:   merror (imgdata.image, \"LibRaw::kodak_thumb_loader()\");",
          "1992:   ID.input->seek(ID.toffset, SEEK_SET);",
          "1994:   (this->*thumb_load_raw)();",
          "2004:   {",
          "2005:     double   dmax;",
          "2006:     float scale_mul[4];",
          "2007:     int c,val;",
          "2008:     for (dmax=DBL_MAX, c=0; c < 3; c++)",
          "2009:       if (dmax > C.pre_mul[c])",
          "2010:         dmax = C.pre_mul[c];",
          "2012:     for( c=0; c< 3; c++)",
          "2013:       scale_mul[c] = (C.pre_mul[c] / dmax) * 65535.0 / C.maximum;",
          "2014:     scale_mul[3] = scale_mul[1];",
          "2016:     size_t size = S.height * S.width;",
          "2017:     for (unsigned i=0; i < size*4 ; i++)",
          "2018:       {",
          "2019:         val = imgdata.image[0][i];",
          "2020:         if(!val) continue;",
          "2021:         val *= scale_mul[i & 3];",
          "2022:         imgdata.image[0][i] = CLIP(val);",
          "2023:       }",
          "2024:   }",
          "2027:   ushort *img;",
          "2028:   int row,col;",
          "2030:   int  (*t_hist)[LIBRAW_HISTOGRAM_SIZE] =  (int (*)[LIBRAW_HISTOGRAM_SIZE]) calloc(sizeof(*t_hist),4);",
          "2031:   merror (t_hist, \"LibRaw::kodak_thumb_loader()\");",
          "2033:   float out[3],",
          "2034:     out_cam[3][4] =",
          "2035:     {",
          "2036:       {2.81761312, -1.98369181, 0.166078627, 0},",
          "2037:       {-0.111855984, 1.73688626, -0.625030339, 0},",
          "2038:       {-0.0379119813, -0.891268849, 1.92918086, 0}",
          "2039:     };",
          "2041:   for (img=imgdata.image[0], row=0; row < S.height; row++)",
          "2042:     for (col=0; col < S.width; col++, img+=4)",
          "2043:       {",
          "2044:         out[0] = out[1] = out[2] = 0;",
          "2045:         int c;",
          "2046:         for(c=0;c<3;c++)",
          "2047:           {",
          "2048:             out[0] += out_cam[0][c] * img[c];",
          "2049:             out[1] += out_cam[1][c] * img[c];",
          "2050:             out[2] += out_cam[2][c] * img[c];",
          "2051:           }",
          "2052:         for(c=0; c<3; c++)",
          "2053:           img[c] = CLIP((int) out[c]);",
          "2054:         for(c=0; c<P1.colors;c++)",
          "2055:           t_hist[c][img[c] >> 3]++;",
          "2057:       }",
          "2060:   int  (*save_hist)[LIBRAW_HISTOGRAM_SIZE] = libraw_internal_data.output_data.histogram;",
          "2061:   libraw_internal_data.output_data.histogram = t_hist;",
          "2064:   ushort (*t_curve) = (ushort*) calloc(sizeof(C.curve),1);",
          "2065:   merror (t_curve, \"LibRaw::kodak_thumb_loader()\");",
          "2066:   memmove(t_curve,C.curve,sizeof(C.curve));",
          "2067:   memset(C.curve,0,sizeof(C.curve));",
          "2068:   {",
          "2069:     int perc, val, total, t_white=0x2000,c;",
          "2072:     if (IO.fuji_width) perc /= 2;",
          "2073:     if (!((O.highlight & ~2) || O.no_auto_bright))",
          "2074:       for (t_white=c=0; c < P1.colors; c++) {",
          "2075:         for (val=0x2000, total=0; --val > 32; )",
          "2076:           if ((total += libraw_internal_data.output_data.histogram[c][val]) > perc) break;",
          "2077:         if (t_white < val) t_white = val;",
          "2078:       }",
          "2079:     gamma_curve (O.gamm[0], O.gamm[1], 2, (t_white << 3)/O.bright);",
          "2080:   }",
          "2082:   libraw_internal_data.output_data.histogram = save_hist;",
          "2083:   free(t_hist);",
          "2087:   S.iheight = S.height;",
          "2088:   S.iwidth  = S.width;",
          "2089:   if (S.flip & 4) SWAP(S.height,S.width);",
          "2091:   if(T.thumb) free(T.thumb);",
          "2092:   T.thumb = (char*) calloc (S.width * S.height, P1.colors);",
          "2093:   merror (T.thumb, \"LibRaw::kodak_thumb_loader()\");",
          "2094:   T.tlength = S.width * S.height * P1.colors;",
          "2097:   {",
          "2098:     int soff  = flip_index (0, 0);",
          "2099:     int cstep = flip_index (0, 1) - soff;",
          "2100:     int rstep = flip_index (1, 0) - flip_index (0, S.width);",
          "2102:     for (int row=0; row < S.height; row++, soff += rstep)",
          "2103:       {",
          "2104:         char *ppm = T.thumb + row*S.width*P1.colors;",
          "2105:         for (int col=0; col < S.width; col++, soff += cstep)",
          "2106:           for(int c = 0; c < P1.colors; c++)",
          "2107:             ppm [col*P1.colors+c] = imgdata.color.curve[imgdata.image[soff][c]]>>8;",
          "2108:       }",
          "2109:   }",
          "2111:   memmove(C.curve,t_curve,sizeof(C.curve));",
          "2112:   free(t_curve);",
          "2115:   free(imgdata.image);",
          "2116:   imgdata.image  = s_image;",
          "2118:   T.twidth = S.width;",
          "2119:   S.width = s_width;",
          "2121:   S.iwidth = s_iwidth;",
          "2122:   S.iheight = s_iheight;",
          "2124:   T.theight = S.height;",
          "2125:   S.height = s_height;",
          "2127:   T.tcolors = P1.colors;",
          "2128:   P1.colors = s_colors;",
          "2130:   P1.filters = s_filters;",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "2140: int LibRaw::unpack_thumb(void)",
          "2141: {",
          "2229: }",
          "",
          "[Removed Lines]",
          "2142:     CHECK_ORDER_LOW(LIBRAW_PROGRESS_IDENTIFY);",
          "2143:     CHECK_ORDER_BIT(LIBRAW_PROGRESS_THUMB_LOAD);",
          "2145:     try {",
          "2146:   if(!libraw_internal_data.internal_data.input)",
          "2147:    return LIBRAW_INPUT_CLOSED;",
          "2149:         if ( !ID.toffset)",
          "2150:             {",
          "2151:                 return LIBRAW_NO_THUMBNAIL;",
          "2152:             }",
          "2153:         else if (thumb_load_raw)",
          "2154:             {",
          "2155:                 kodak_thumb_loader();",
          "2156:                 T.tformat = LIBRAW_THUMBNAIL_BITMAP;",
          "2157:                 SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);",
          "2158:                 return 0;",
          "2159:             }",
          "2160:         else",
          "2161:             {",
          "2162:                 ID.input->seek(ID.toffset, SEEK_SET);",
          "2163:                 if ( write_thumb == &LibRaw::jpeg_thumb)",
          "2164:                     {",
          "2165:                         if(T.thumb) free(T.thumb);",
          "2166:                         T.thumb = (char *) malloc (T.tlength);",
          "2167:                         merror (T.thumb, \"jpeg_thumb()\");",
          "2168:                         ID.input->read (T.thumb, 1, T.tlength);",
          "2169:                         T.tcolors = 3;",
          "2170:                         T.tformat = LIBRAW_THUMBNAIL_JPEG;",
          "2171:                         SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);",
          "2172:                         return 0;",
          "2173:                     }",
          "2174:                 else if (write_thumb == &LibRaw::ppm_thumb)",
          "2175:                     {",
          "2176:                         T.tlength = T.twidth * T.theight*3;",
          "2177:                         if(T.thumb) free(T.thumb);",
          "2179:                         T.thumb = (char *) malloc (T.tlength);",
          "2180:                         merror (T.thumb, \"ppm_thumb()\");",
          "2182:                         ID.input->read(T.thumb, 1, T.tlength);",
          "2184:                         T.tformat = LIBRAW_THUMBNAIL_BITMAP;",
          "2185:                         SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);",
          "2186:                         return 0;",
          "2188:                     }",
          "2189:                 else if (write_thumb == &LibRaw::ppm16_thumb)",
          "2190:                     {",
          "2191:                         T.tlength = T.twidth * T.theight*3;",
          "2192:                         ushort *t_thumb = (ushort*)calloc(T.tlength,2);",
          "2193:                         ID.input->read(t_thumb,2,T.tlength);",
          "2194:                         if ((libraw_internal_data.unpacker_data.order= 0x4949) == (ntohs(0x1234) == 0x1234))",
          "2195:                           swab ((char*)t_thumb, (char*)t_thumb, T.tlength*2);",
          "2197:                         if(T.thumb) free(T.thumb);",
          "2198:                         T.thumb = (char *) malloc (T.tlength);",
          "2199:                         merror (T.thumb, \"ppm_thumb()\");",
          "2200:                         for (int i=0; i < T.tlength; i++)",
          "2201:                           T.thumb[i] = t_thumb[i] >> 8;",
          "2202:                         free(t_thumb);",
          "2203:                         T.tformat = LIBRAW_THUMBNAIL_BITMAP;",
          "2204:                         SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);",
          "2205:                         return 0;",
          "2207:                     }",
          "2208:                 else if (write_thumb == &LibRaw::foveon_thumb)",
          "2209:                     {",
          "2210:                         foveon_thumb_loader();",
          "2213:                         SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);",
          "2214:                         return 0;",
          "2215:                     }",
          "2217:                 else",
          "2218:                     {",
          "2219:                         return LIBRAW_UNSUPPORTED_THUMBNAIL;",
          "2220:                     }",
          "2221:             }",
          "2223:         return LIBRAW_UNSUPPORTED_THUMBNAIL;",
          "2224:     }",
          "2225:     catch ( LibRaw_exceptions err) {",
          "2226:         EXCEPTION_HANDLER(err);",
          "2227:     }",
          "",
          "[Added Lines]",
          "2142:   CHECK_ORDER_LOW(LIBRAW_PROGRESS_IDENTIFY);",
          "2143:   CHECK_ORDER_BIT(LIBRAW_PROGRESS_THUMB_LOAD);",
          "2145:   try {",
          "2146:     if(!libraw_internal_data.internal_data.input)",
          "2147:       return LIBRAW_INPUT_CLOSED;",
          "2149:     if ( !ID.toffset)",
          "2150:       {",
          "2151:         return LIBRAW_NO_THUMBNAIL;",
          "2152:       }",
          "2153:     else if (thumb_load_raw)",
          "2154:       {",
          "2155:         kodak_thumb_loader();",
          "2156:         T.tformat = LIBRAW_THUMBNAIL_BITMAP;",
          "2157:         SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);",
          "2158:         return 0;",
          "2159:       }",
          "2160:     else",
          "2161:       {",
          "2162:         ID.input->seek(ID.toffset, SEEK_SET);",
          "2163:         if ( write_thumb == &LibRaw::jpeg_thumb)",
          "2164:           {",
          "2165:             if(T.thumb) free(T.thumb);",
          "2166:             T.thumb = (char *) malloc (T.tlength);",
          "2167:             merror (T.thumb, \"jpeg_thumb()\");",
          "2168:             ID.input->read (T.thumb, 1, T.tlength);",
          "2169:             T.tcolors = 3;",
          "2170:             T.tformat = LIBRAW_THUMBNAIL_JPEG;",
          "2171:             SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);",
          "2172:             return 0;",
          "2173:           }",
          "2174:         else if (write_thumb == &LibRaw::ppm_thumb)",
          "2175:           {",
          "2176:             T.tlength = T.twidth * T.theight*3;",
          "2177:             if(T.thumb) free(T.thumb);",
          "2179:             T.thumb = (char *) malloc (T.tlength);",
          "2180:             merror (T.thumb, \"ppm_thumb()\");",
          "2182:             ID.input->read(T.thumb, 1, T.tlength);",
          "2184:             T.tformat = LIBRAW_THUMBNAIL_BITMAP;",
          "2185:             SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);",
          "2186:             return 0;",
          "2188:           }",
          "2189:         else if (write_thumb == &LibRaw::ppm16_thumb)",
          "2190:           {",
          "2191:             T.tlength = T.twidth * T.theight*3;",
          "2192:             ushort *t_thumb = (ushort*)calloc(T.tlength,2);",
          "2193:             ID.input->read(t_thumb,2,T.tlength);",
          "2194:             if ((libraw_internal_data.unpacker_data.order= 0x4949) == (ntohs(0x1234) == 0x1234))",
          "2195:               swab ((char*)t_thumb, (char*)t_thumb, T.tlength*2);",
          "2197:             if(T.thumb) free(T.thumb);",
          "2198:             T.thumb = (char *) malloc (T.tlength);",
          "2199:             merror (T.thumb, \"ppm_thumb()\");",
          "2200:             for (int i=0; i < T.tlength; i++)",
          "2201:               T.thumb[i] = t_thumb[i] >> 8;",
          "2202:             free(t_thumb);",
          "2203:             T.tformat = LIBRAW_THUMBNAIL_BITMAP;",
          "2204:             SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);",
          "2205:             return 0;",
          "2207:           }",
          "2208:         else if (write_thumb == &LibRaw::foveon_thumb)",
          "2209:           {",
          "2210:             foveon_thumb_loader();",
          "2213:             SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);",
          "2214:             return 0;",
          "2215:           }",
          "2217:         else",
          "2218:           {",
          "2219:             return LIBRAW_UNSUPPORTED_THUMBNAIL;",
          "2220:           }",
          "2221:       }",
          "2223:     return LIBRAW_UNSUPPORTED_THUMBNAIL;",
          "2224:   }",
          "2225:   catch ( LibRaw_exceptions err) {",
          "2226:     EXCEPTION_HANDLER(err);",
          "2227:   }",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "2232: {",
          "2265:     }",
          "2267:         fclose(tfp);",
          "2270: }",
          "2272: int LibRaw::adjust_sizes_info_only(void)",
          "2273: {",
          "2278:         {",
          "2293:         {",
          "2298:         }",
          "2300: }",
          "2303: int LibRaw::subtract_black()",
          "2304: {",
          "2308:     if(!is_phaseone_compressed() && (C.cblack[0] || C.cblack[1] || C.cblack[2] || C.cblack[3]))",
          "2310: #define BAYERC(row,col,c) imgdata.image[((row) >> IO.shrink)*S.iwidth + ((col) >> IO.shrink)][c]",
          "2316: #define MIN(a,b) ((a) < (b) ? (a) : (b))",
          "2317: #define MAX(a,b) ((a) > (b) ? (a) : (b))",
          "2318: #define LIM(x,min,max) MAX(min,MIN(x,max))",
          "2319: #define CLIP(x) LIM(x,0,65535)",
          "2329: #undef MIN",
          "2330: #undef MAX",
          "2331: #undef LIM",
          "2332: #undef CLIP",
          "2336: #undef BAYERC",
          "2338:     else",
          "2355: }",
          "",
          "[Removed Lines]",
          "2235:     if(!fname)",
          "2236:         return ENOENT;",
          "2238:     FILE *tfp = fopen(fname,\"wb\");",
          "2240:     if(!tfp)",
          "2241:         return errno;",
          "2243:     if(!T.thumb)",
          "2244:  {",
          "2245:   fclose(tfp);",
          "2246:          return LIBRAW_OUT_OF_ORDER_CALL;",
          "2247:  }",
          "2249:     try {",
          "2250:         switch (T.tformat)",
          "2251:             {",
          "2252:             case LIBRAW_THUMBNAIL_JPEG:",
          "2253:                 jpeg_thumb_writer (tfp,T.thumb,T.tlength);",
          "2254:                 break;",
          "2255:             case LIBRAW_THUMBNAIL_BITMAP:",
          "2256:                 fprintf (tfp, \"P6\\n%d %d\\n255\\n\", T.twidth, T.theight);",
          "2257:                 fwrite (T.thumb, 1, T.tlength, tfp);",
          "2258:                 break;",
          "2259:             default:",
          "2260:                 fclose(tfp);",
          "2261:                 return LIBRAW_UNSUPPORTED_THUMBNAIL;",
          "2262:            }",
          "2263:         fclose(tfp);",
          "2264:         return 0;",
          "2266:     catch ( LibRaw_exceptions err) {",
          "2268:         EXCEPTION_HANDLER(err);",
          "2269:     }",
          "2274:     CHECK_ORDER_LOW(LIBRAW_PROGRESS_IDENTIFY);",
          "2276:     raw2image_start();",
          "2277:     if (O.use_fuji_rotate)",
          "2279:             if (IO.fuji_width)",
          "2280:                 {",
          "2281:                     IO.fuji_width = (IO.fuji_width - 1 + IO.shrink) >> IO.shrink;",
          "2282:                     S.iwidth = (ushort)(IO.fuji_width / sqrt(0.5));",
          "2283:                     S.iheight = (ushort)( (S.iheight - IO.fuji_width) / sqrt(0.5));",
          "2284:                 }",
          "2285:             else",
          "2286:                 {",
          "2287:                     if (S.pixel_aspect < 1) S.iheight = (ushort)( S.iheight / S.pixel_aspect + 0.5);",
          "2288:                     if (S.pixel_aspect > 1) S.iwidth  = (ushort) (S.iwidth  * S.pixel_aspect + 0.5);",
          "2289:                 }",
          "2290:         }",
          "2291:     SET_PROC_FLAG(LIBRAW_PROGRESS_FUJI_ROTATE);",
          "2292:     if ( S.flip & 4)",
          "2294:             unsigned short t = S.iheight;",
          "2295:             S.iheight=S.iwidth;",
          "2296:             S.iwidth = t;",
          "2297:             SET_PROC_FLAG(LIBRAW_PROGRESS_FLIP);",
          "2299:     return 0;",
          "2305:  CHECK_ORDER_LOW(LIBRAW_PROGRESS_RAW2_IMAGE);",
          "2307:  try {",
          "2309:         {",
          "2311:             int cblk[4],i;",
          "2312:             for(i=0;i<4;i++)",
          "2313:                 cblk[i] = C.cblack[i];",
          "2315:             int size = S.iheight * S.iwidth;",
          "2320:    int dmax = 0;",
          "2321:    for(i=0; i< size*4; i++)",
          "2322:               {",
          "2323:                 int val = imgdata.image[0][i];",
          "2324:                 val -= cblk[i & 3];",
          "2325:                 imgdata.image[0][i] = CLIP(val);",
          "2326:                 if(dmax < val) dmax = val;",
          "2327:               }",
          "2328:    C.data_maximum = dmax & 0xffff;",
          "2333:             C.maximum -= C.black;",
          "2334:             ZERO(C.cblack);",
          "2335:             C.black = 0;",
          "2337:         }",
          "2339:         {",
          "2342:           int idx;",
          "2343:           ushort *p = (ushort*)imgdata.image;",
          "2344:     int dmax = 0;",
          "2345:           for(idx=0;idx<S.iheight*S.iwidth*4;idx++)",
          "2346:             if(dmax < p[idx]) dmax = p[idx];",
          "2347:     C.data_maximum = dmax;",
          "2348:         }",
          "2349:   return 0;",
          "2350:  }",
          "2351:  catch ( LibRaw_exceptions err) {",
          "2352:   EXCEPTION_HANDLER(err);",
          "2353:  }",
          "",
          "[Added Lines]",
          "2235:   if(!fname)",
          "2236:     return ENOENT;",
          "2238:   FILE *tfp = fopen(fname,\"wb\");",
          "2240:   if(!tfp)",
          "2241:     return errno;",
          "2243:   if(!T.thumb)",
          "2244:     {",
          "2245:       fclose(tfp);",
          "2246:       return LIBRAW_OUT_OF_ORDER_CALL;",
          "2249:   try {",
          "2250:     switch (T.tformat)",
          "2251:       {",
          "2252:       case LIBRAW_THUMBNAIL_JPEG:",
          "2253:         jpeg_thumb_writer (tfp,T.thumb,T.tlength);",
          "2254:         break;",
          "2255:       case LIBRAW_THUMBNAIL_BITMAP:",
          "2256:         fprintf (tfp, \"P6\\n%d %d\\n255\\n\", T.twidth, T.theight);",
          "2257:         fwrite (T.thumb, 1, T.tlength, tfp);",
          "2258:         break;",
          "2259:       default:",
          "2261:         return LIBRAW_UNSUPPORTED_THUMBNAIL;",
          "2262:       }",
          "2263:     fclose(tfp);",
          "2264:     return 0;",
          "2265:   }",
          "2266:   catch ( LibRaw_exceptions err) {",
          "2267:     fclose(tfp);",
          "2268:     EXCEPTION_HANDLER(err);",
          "2269:   }",
          "2274:   CHECK_ORDER_LOW(LIBRAW_PROGRESS_IDENTIFY);",
          "2276:   raw2image_start();",
          "2277:   if (O.use_fuji_rotate)",
          "2278:     {",
          "2279:       if (IO.fuji_width)",
          "2281:           IO.fuji_width = (IO.fuji_width - 1 + IO.shrink) >> IO.shrink;",
          "2282:           S.iwidth = (ushort)(IO.fuji_width / sqrt(0.5));",
          "2283:           S.iheight = (ushort)( (S.iheight - IO.fuji_width) / sqrt(0.5));",
          "2284:         }",
          "2285:       else",
          "2287:           if (S.pixel_aspect < 1) S.iheight = (ushort)( S.iheight / S.pixel_aspect + 0.5);",
          "2288:           if (S.pixel_aspect > 1) S.iwidth  = (ushort) (S.iwidth  * S.pixel_aspect + 0.5);",
          "2290:     }",
          "2291:   SET_PROC_FLAG(LIBRAW_PROGRESS_FUJI_ROTATE);",
          "2292:   if ( S.flip & 4)",
          "2293:     {",
          "2294:       unsigned short t = S.iheight;",
          "2295:       S.iheight=S.iwidth;",
          "2296:       S.iwidth = t;",
          "2297:       SET_PROC_FLAG(LIBRAW_PROGRESS_FLIP);",
          "2298:     }",
          "2299:   return 0;",
          "2305:   CHECK_ORDER_LOW(LIBRAW_PROGRESS_RAW2_IMAGE);",
          "2307:   try {",
          "2309:       {",
          "2311:         int cblk[4],i;",
          "2312:         for(i=0;i<4;i++)",
          "2313:           cblk[i] = C.cblack[i];",
          "2315:         int size = S.iheight * S.iwidth;",
          "2320:         int dmax = 0;",
          "2321:         for(i=0; i< size*4; i++)",
          "2322:           {",
          "2323:             int val = imgdata.image[0][i];",
          "2324:             val -= cblk[i & 3];",
          "2325:             imgdata.image[0][i] = CLIP(val);",
          "2326:             if(dmax < val) dmax = val;",
          "2327:           }",
          "2328:         C.data_maximum = dmax & 0xffff;",
          "2333:         C.maximum -= C.black;",
          "2334:         ZERO(C.cblack);",
          "2335:         C.black = 0;",
          "2337:       }",
          "2339:       {",
          "2342:         int idx;",
          "2343:         ushort *p = (ushort*)imgdata.image;",
          "2344:         int dmax = 0;",
          "2345:         for(idx=0;idx<S.iheight*S.iwidth*4;idx++)",
          "2346:           if(dmax < p[idx]) dmax = p[idx];",
          "2347:         C.data_maximum = dmax;",
          "2348:       }",
          "2349:     return 0;",
          "2350:   }",
          "2351:   catch ( LibRaw_exceptions err) {",
          "2352:     EXCEPTION_HANDLER(err);",
          "2353:   }",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "2359: void LibRaw::exp_bef(float shift, float smooth)",
          "2360: {",
          "2400:         {",
          "2405:         }",
          "2413: }",
          "2415: #define MIN(a,b) ((a) < (b) ? (a) : (b))",
          "",
          "[Removed Lines]",
          "2362:     if(shift>8) shift = 8;",
          "2363:     if(shift<0.25) shift = 0.25;",
          "2364:     if(smooth < 0.0) smooth = 0.0;",
          "2365:     if(smooth > 1.0) smooth = 1.0;",
          "2367:     unsigned short *lut = (ushort*)malloc((TBLN+1)*sizeof(unsigned short));",
          "2369:     if(shift <=1.0)",
          "2370:         {",
          "2371:             for(int i=0;i<=TBLN;i++)",
          "2372:                 lut[i] = (unsigned short)((float)i*shift);",
          "2373:         }",
          "2374:     else",
          "2375:         {",
          "2376:             float x1,x2,y1,y2;",
          "2378:             float cstops = log(shift)/log(2.0f);",
          "2379:             float room = cstops*2;",
          "2380:             float roomlin = powf(2.0f,room);",
          "2381:             x2 = (float)TBLN;",
          "2382:             x1 = (x2+1)/roomlin-1;",
          "2383:             y1 = x1*shift;",
          "2384:             y2 = x2*(1+(1-smooth)*(shift-1));",
          "2385:             float sq3x=powf(x1*x1*x2,1.0f/3.0f);",
          "2386:             float B = (y2-y1+shift*(3*x1-3.0f*sq3x)) / (x2+2.0f*x1-3.0f*sq3x);",
          "2387:             float A = (shift - B)*3.0f*powf(x1*x1,1.0f/3.0f);",
          "2388:             float CC = y2 - A*powf(x2,1.0f/3.0f)-B*x2;",
          "2389:             for(int i=0;i<=TBLN;i++)",
          "2390:                 {",
          "2391:                     float X = (float)i;",
          "2392:                     float Y = A*powf(X,1.0f/3.0f)+B*X+CC;",
          "2393:                     if(i<x1)",
          "2394:                         lut[i] = (unsigned short)((float)i*shift);",
          "2395:                     else",
          "2396:                         lut[i] = Y<0?0:(Y>TBLN?TBLN:(unsigned short)(Y));",
          "2397:                 }",
          "2398:         }",
          "2399:     for(int i=0; i< S.height*S.width; i++)",
          "2401:             imgdata.image[i][0] = lut[imgdata.image[i][0]];",
          "2402:             imgdata.image[i][1] = lut[imgdata.image[i][1]];",
          "2403:             imgdata.image[i][2] = lut[imgdata.image[i][2]];",
          "2404:             imgdata.image[i][3] = lut[imgdata.image[i][3]];",
          "2407:  if(C.data_maximum <=TBLN)",
          "2408:   C.data_maximum = lut[C.data_maximum];",
          "2409:  if(C.maximum <= TBLN)",
          "2410:   C.maximum = lut[C.maximum];",
          "2412:     free(lut);",
          "",
          "[Added Lines]",
          "2362:   if(shift>8) shift = 8;",
          "2363:   if(shift<0.25) shift = 0.25;",
          "2364:   if(smooth < 0.0) smooth = 0.0;",
          "2365:   if(smooth > 1.0) smooth = 1.0;",
          "2367:   unsigned short *lut = (ushort*)malloc((TBLN+1)*sizeof(unsigned short));",
          "2369:   if(shift <=1.0)",
          "2370:     {",
          "2371:       for(int i=0;i<=TBLN;i++)",
          "2372:         lut[i] = (unsigned short)((float)i*shift);",
          "2373:     }",
          "2374:   else",
          "2375:     {",
          "2376:       float x1,x2,y1,y2;",
          "2378:       float cstops = log(shift)/log(2.0f);",
          "2379:       float room = cstops*2;",
          "2380:       float roomlin = powf(2.0f,room);",
          "2381:       x2 = (float)TBLN;",
          "2382:       x1 = (x2+1)/roomlin-1;",
          "2383:       y1 = x1*shift;",
          "2384:       y2 = x2*(1+(1-smooth)*(shift-1));",
          "2385:       float sq3x=powf(x1*x1*x2,1.0f/3.0f);",
          "2386:       float B = (y2-y1+shift*(3*x1-3.0f*sq3x)) / (x2+2.0f*x1-3.0f*sq3x);",
          "2387:       float A = (shift - B)*3.0f*powf(x1*x1,1.0f/3.0f);",
          "2388:       float CC = y2 - A*powf(x2,1.0f/3.0f)-B*x2;",
          "2389:       for(int i=0;i<=TBLN;i++)",
          "2391:           float X = (float)i;",
          "2392:           float Y = A*powf(X,1.0f/3.0f)+B*X+CC;",
          "2393:           if(i<x1)",
          "2394:             lut[i] = (unsigned short)((float)i*shift);",
          "2395:           else",
          "2396:             lut[i] = Y<0?0:(Y>TBLN?TBLN:(unsigned short)(Y));",
          "2398:     }",
          "2399:   for(int i=0; i< S.height*S.width; i++)",
          "2400:     {",
          "2401:       imgdata.image[i][0] = lut[imgdata.image[i][0]];",
          "2402:       imgdata.image[i][1] = lut[imgdata.image[i][1]];",
          "2403:       imgdata.image[i][2] = lut[imgdata.image[i][2]];",
          "2404:       imgdata.image[i][3] = lut[imgdata.image[i][3]];",
          "2405:     }",
          "2407:   if(C.data_maximum <=TBLN)",
          "2408:     C.data_maximum = lut[C.data_maximum];",
          "2409:   if(C.maximum <= TBLN)",
          "2410:     C.maximum = lut[C.maximum];",
          "2412:   free(lut);",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "2421: void LibRaw::convert_to_rgb_loop(float out_cam[3][4])",
          "2422: {",
          "2441: }",
          "",
          "[Removed Lines]",
          "2423:  int row,col,c;",
          "2424:  float out[3];",
          "2425:  ushort *img;",
          "2426:  memset(libraw_internal_data.output_data.histogram,0,sizeof(int)*LIBRAW_HISTOGRAM_SIZE*4);",
          "2427:  for (img=imgdata.image[0], row=0; row < S.height; row++)",
          "2428:   for (col=0; col < S.width; col++, img+=4) {",
          "2429:    if (!libraw_internal_data.internal_output_params.raw_color) {",
          "2430:     out[0] = out[1] = out[2] = 0;",
          "2431:     for(c=0; c< imgdata.idata.colors; c++) {",
          "2432:      out[0] += out_cam[0][c] * img[c];",
          "2433:      out[1] += out_cam[1][c] * img[c];",
          "2434:      out[2] += out_cam[2][c] * img[c];",
          "2435:     }",
          "2436:     for(c=0;c<3;c++) img[c] = CLIP((int) out[c]);",
          "2437:    }",
          "2438:    for(c=0; c< imgdata.idata.colors; c++) libraw_internal_data.output_data.histogram[c][img[c] >> 3]++;",
          "2439:   }",
          "",
          "[Added Lines]",
          "2423:   int row,col,c;",
          "2424:   float out[3];",
          "2425:   ushort *img;",
          "2426:   memset(libraw_internal_data.output_data.histogram,0,sizeof(int)*LIBRAW_HISTOGRAM_SIZE*4);",
          "2427:   for (img=imgdata.image[0], row=0; row < S.height; row++)",
          "2428:     for (col=0; col < S.width; col++, img+=4) {",
          "2429:       if (!libraw_internal_data.internal_output_params.raw_color) {",
          "2430:         out[0] = out[1] = out[2] = 0;",
          "2431:         for(c=0; c< imgdata.idata.colors; c++) {",
          "2432:           out[0] += out_cam[0][c] * img[c];",
          "2433:           out[1] += out_cam[1][c] * img[c];",
          "2434:           out[2] += out_cam[2][c] * img[c];",
          "2435:         }",
          "2436:         for(c=0;c<3;c++) img[c] = CLIP((int) out[c]);",
          "2437:       }",
          "2438:       for(c=0; c< imgdata.idata.colors; c++) libraw_internal_data.output_data.histogram[c][img[c] >> 3]++;",
          "2439:     }",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "2487: int LibRaw::dcraw_process(void)",
          "2488: {",
          "2666:             }",
          "2691: #ifndef NO_LCMS",
          "2697: #endif",
          "2714: }",
          "",
          "[Removed Lines]",
          "2489:     int quality,i;",
          "2491:     int iterations=-1, dcb_enhance=1, noiserd=0;",
          "2492:     int eeci_refine_fl=0, es_med_passes_fl=0;",
          "2493:     float cared=0,cablue=0;",
          "2494:     float linenoise=0;",
          "2495:     float lclean=0,cclean=0;",
          "2496:     float thresh=0;",
          "2497:     float preser=0;",
          "2498:     float expos=1.0;",
          "2501:     CHECK_ORDER_LOW(LIBRAW_PROGRESS_LOAD_RAW);",
          "2504:     try {",
          "2506:         int no_crop = 1;",
          "2508:         if (~O.cropbox[2] && ~O.cropbox[3])",
          "2509:             no_crop=0;",
          "2511:         libraw_decoder_info_t di;",
          "2512:         get_decoder_info(&di);",
          "2514:         int subtract_inline = !O.bad_pixels && !O.dark_frame && !O.wf_debanding && !(di.decoder_flags & LIBRAW_DECODER_LEGACY) && !IO.zero_is_bad;",
          "2516:         raw2image_ex(subtract_inline); // allocate imgdata.image and copy data!",
          "2518:   int save_4color = O.four_color_rgb;",
          "2520:         if (IO.zero_is_bad)",
          "2521:           {",
          "2522:                 remove_zeroes();",
          "2523:                 SET_PROC_FLAG(LIBRAW_PROGRESS_REMOVE_ZEROES);",
          "2524:             }",
          "2526:         if(O.bad_pixels && no_crop)",
          "2527:             {",
          "2528:                 bad_pixels(O.bad_pixels);",
          "2529:                 SET_PROC_FLAG(LIBRAW_PROGRESS_BAD_PIXELS);",
          "2530:             }",
          "2532:         if (O.dark_frame && no_crop)",
          "2533:             {",
          "2534:                 subtract (O.dark_frame);",
          "2535:                 SET_PROC_FLAG(LIBRAW_PROGRESS_DARK_FRAME);",
          "2536:             }",
          "2538:  if (O.wf_debanding)",
          "2539:  {",
          "2540:   wf_remove_banding();",
          "2541:  }",
          "2543:         quality = 2 + !IO.fuji_width;",
          "2545:         if (O.user_qual >= 0) quality = O.user_qual;",
          "2547:         if(!subtract_inline || !C.data_maximum)",
          "2548:           {",
          "2549:             adjust_bl();",
          "2550:             subtract_black();",
          "2551:           }",
          "2553:         adjust_maximum();",
          "2555:         if (O.user_sat > 0) C.maximum = O.user_sat;",
          "2557:         if (P1.is_foveon)",
          "2558:             {",
          "2559:               if(load_raw == &LibRaw::foveon_dp_load_raw)",
          "2560:                 {",
          "2561:                   for (int i=0; i < S.height*S.width*4; i++)",
          "2562:                     if ((short) imgdata.image[0][i] < 0) imgdata.image[0][i] = 0;",
          "2563:                 }",
          "2564:               else",
          "2565:                 foveon_interpolate();",
          "2566:                 SET_PROC_FLAG(LIBRAW_PROGRESS_FOVEON_INTERPOLATE);",
          "2567:             }",
          "2569:         if (O.green_matching && !O.half_size)",
          "2570:             {",
          "2571:                 green_matching();",
          "2572:             }",
          "2574:         if (!P1.is_foveon && !O.no_auto_scale)",
          "2575:             {",
          "2576:                 scale_colors();",
          "2577:                 SET_PROC_FLAG(LIBRAW_PROGRESS_SCALE_COLORS);",
          "2578:             }",
          "2580:         pre_interpolate();",
          "2582:         SET_PROC_FLAG(LIBRAW_PROGRESS_PRE_INTERPOLATE);",
          "2584:         if (O.dcb_iterations >= 0) iterations = O.dcb_iterations;",
          "2585:         if (O.dcb_enhance_fl >=0 ) dcb_enhance = O.dcb_enhance_fl;",
          "2586:         if (O.fbdd_noiserd >=0 ) noiserd = O.fbdd_noiserd;",
          "2587:         if (O.eeci_refine >=0 ) eeci_refine_fl = O.eeci_refine;",
          "2588:         if (O.es_med_passes >0 ) es_med_passes_fl = O.es_med_passes;",
          "2592:         if (!O.half_size && O.cfa_green >0) {thresh=O.green_thresh ;green_equilibrate(thresh);}",
          "2593:         if (O.exp_correc >0) {expos=O.exp_shift ; preser=O.exp_preser; exp_bef(expos,preser);}",
          "2594:         if (O.ca_correc >0 ) {cablue=O.cablue; cared=O.cared; CA_correct_RT(cablue, cared);}",
          "2595:         if (O.cfaline >0 ) {linenoise=O.linenoise; cfa_linedn(linenoise);}",
          "2596:         if (O.cfa_clean >0 ) {lclean=O.lclean; cclean=O.cclean; cfa_impulse_gauss(lclean,cclean);}",
          "2598:         if (P1.filters)",
          "2599:             {",
          "2600:                 if (noiserd>0 && P1.colors==3 && P1.filters) fbdd(noiserd);",
          "2601:                 if (quality == 0)",
          "2602:                     lin_interpolate();",
          "2603:                 else if (quality == 1 || P1.colors > 3)",
          "2604:                     vng_interpolate();",
          "2605:                 else if (quality == 2 && P1.filters > 1000)",
          "2606:                     ppg_interpolate();",
          "2607:                 else if (P1.filters == 9)",
          "2608:                   {",
          "2610:                     fprintf(stderr,\"Xtrans int\\n\");",
          "2611:                     xtrans_interpolate(quality>2?3:1);",
          "2612:                   }",
          "2613:                 else if (quality == 3)",
          "2614:                   ahd_interpolate(); // really don't need it here due to fallback op",
          "2615:                 else if (quality == 4)",
          "2616:                   dcb(iterations, dcb_enhance);",
          "2618:                 else if (quality == 5)",
          "2619:                   ahd_interpolate_mod();",
          "2620:                 else if (quality == 6)",
          "2621:                   afd_interpolate_pl(2,1);",
          "2622:                 else if (quality == 7)",
          "2623:                   vcd_interpolate(0);",
          "2624:                 else if (quality == 8)",
          "2625:                   vcd_interpolate(12);",
          "2626:                 else if (quality == 9)",
          "2627:                   lmmse_interpolate(1);",
          "2630:                 else if (quality == 10)",
          "2631:                   amaze_demosaic_RT();",
          "2633:                 else if (quality == 11)",
          "2634:                   dht_interpolate();",
          "2635:                 else if (quality == 12)",
          "2636:                   aahd_interpolate();",
          "2638:                 else",
          "2639:                   ahd_interpolate();",
          "2641:                 SET_PROC_FLAG(LIBRAW_PROGRESS_INTERPOLATE);",
          "2642:             }",
          "2643:         if (IO.mix_green)",
          "2644:             {",
          "2645:                 for (P1.colors=3, i=0; i < S.height * S.width; i++)",
          "2646:                     imgdata.image[i][1] = (imgdata.image[i][1] + imgdata.image[i][3]) >> 1;",
          "2647:                 SET_PROC_FLAG(LIBRAW_PROGRESS_MIX_GREEN);",
          "2648:             }",
          "2650:         if(!P1.is_foveon)",
          "2651:             {",
          "2652:                 if (P1.colors == 3)",
          "2653:                     {",
          "2655:                         if (quality == 8)",
          "2656:                             {",
          "2657:                                 if (eeci_refine_fl == 1) refinement();",
          "2658:                                 if (O.med_passes > 0)    median_filter_new();",
          "2659:                                 if (es_med_passes_fl > 0) es_median_filter();",
          "2660:                             }",
          "2661:                         else {",
          "2662:                             median_filter();",
          "2663:                         }",
          "2664:                         SET_PROC_FLAG(LIBRAW_PROGRESS_MEDIAN_FILTER);",
          "2665:                     }",
          "2668:         if (O.highlight == 2)",
          "2669:             {",
          "2670:                 blend_highlights();",
          "2671:                 SET_PROC_FLAG(LIBRAW_PROGRESS_HIGHLIGHTS);",
          "2672:             }",
          "2674:         if (O.highlight > 2)",
          "2675:             {",
          "2676:                 recover_highlights();",
          "2677:                 SET_PROC_FLAG(LIBRAW_PROGRESS_HIGHLIGHTS);",
          "2678:             }",
          "2680:         if (O.use_fuji_rotate)",
          "2681:             {",
          "2682:                 fuji_rotate();",
          "2683:                 SET_PROC_FLAG(LIBRAW_PROGRESS_FUJI_ROTATE);",
          "2684:             }",
          "2686:         if(!libraw_internal_data.output_data.histogram)",
          "2687:             {",
          "2688:                 libraw_internal_data.output_data.histogram = (int (*)[LIBRAW_HISTOGRAM_SIZE]) malloc(sizeof(*libraw_internal_data.output_data.histogram)*4);",
          "2689:                 merror(libraw_internal_data.output_data.histogram,\"LibRaw::dcraw_process()\");",
          "2690:             }",
          "2692:  if(O.camera_profile)",
          "2693:             {",
          "2694:                 apply_profile(O.camera_profile,O.output_profile);",
          "2695:                 SET_PROC_FLAG(LIBRAW_PROGRESS_APPLY_PROFILE);",
          "2696:             }",
          "2699:         convert_to_rgb();",
          "2700:         SET_PROC_FLAG(LIBRAW_PROGRESS_CONVERT_RGB);",
          "2702:         if (O.use_fuji_rotate)",
          "2703:             {",
          "2704:                 stretch();",
          "2705:                 SET_PROC_FLAG(LIBRAW_PROGRESS_STRETCH);",
          "2706:             }",
          "2707:         O.four_color_rgb = save_4color; // also, restore",
          "2709:         return 0;",
          "2710:     }",
          "2711:     catch ( LibRaw_exceptions err) {",
          "2712:         EXCEPTION_HANDLER(err);",
          "2713:     }",
          "",
          "[Added Lines]",
          "2489:   int quality,i;",
          "2491:   int iterations=-1, dcb_enhance=1, noiserd=0;",
          "2492:   int eeci_refine_fl=0, es_med_passes_fl=0;",
          "2493:   float cared=0,cablue=0;",
          "2494:   float linenoise=0;",
          "2495:   float lclean=0,cclean=0;",
          "2496:   float thresh=0;",
          "2497:   float preser=0;",
          "2498:   float expos=1.0;",
          "2501:   CHECK_ORDER_LOW(LIBRAW_PROGRESS_LOAD_RAW);",
          "2504:   try {",
          "2506:     int no_crop = 1;",
          "2508:     if (~O.cropbox[2] && ~O.cropbox[3])",
          "2509:       no_crop=0;",
          "2511:     libraw_decoder_info_t di;",
          "2512:     get_decoder_info(&di);",
          "2514:     int subtract_inline = !O.bad_pixels && !O.dark_frame && !O.wf_debanding && !(di.decoder_flags & LIBRAW_DECODER_LEGACY) && !IO.zero_is_bad;",
          "2516:     raw2image_ex(subtract_inline); // allocate imgdata.image and copy data!",
          "2518:     int save_4color = O.four_color_rgb;",
          "2520:     if (IO.zero_is_bad)",
          "2521:       {",
          "2522:         remove_zeroes();",
          "2523:         SET_PROC_FLAG(LIBRAW_PROGRESS_REMOVE_ZEROES);",
          "2524:       }",
          "2526:     if(O.bad_pixels && no_crop)",
          "2527:       {",
          "2528:         bad_pixels(O.bad_pixels);",
          "2529:         SET_PROC_FLAG(LIBRAW_PROGRESS_BAD_PIXELS);",
          "2530:       }",
          "2532:     if (O.dark_frame && no_crop)",
          "2533:       {",
          "2534:         subtract (O.dark_frame);",
          "2535:         SET_PROC_FLAG(LIBRAW_PROGRESS_DARK_FRAME);",
          "2536:       }",
          "2538:     if (O.wf_debanding)",
          "2539:       {",
          "2540:         wf_remove_banding();",
          "2541:       }",
          "2543:     quality = 2 + !IO.fuji_width;",
          "2545:     if (O.user_qual >= 0) quality = O.user_qual;",
          "2547:     if(!subtract_inline || !C.data_maximum)",
          "2548:       {",
          "2549:         adjust_bl();",
          "2550:         subtract_black();",
          "2551:       }",
          "2553:     adjust_maximum();",
          "2555:     if (O.user_sat > 0) C.maximum = O.user_sat;",
          "2557:     if (P1.is_foveon)",
          "2558:       {",
          "2559:         if(load_raw == &LibRaw::foveon_dp_load_raw)",
          "2560:           {",
          "2561:             for (int i=0; i < S.height*S.width*4; i++)",
          "2562:               if ((short) imgdata.image[0][i] < 0) imgdata.image[0][i] = 0;",
          "2563:           }",
          "2564:         else",
          "2565:           foveon_interpolate();",
          "2566:         SET_PROC_FLAG(LIBRAW_PROGRESS_FOVEON_INTERPOLATE);",
          "2567:       }",
          "2569:     if (O.green_matching && !O.half_size)",
          "2570:       {",
          "2571:         green_matching();",
          "2572:       }",
          "2574:     if (!P1.is_foveon && !O.no_auto_scale)",
          "2575:       {",
          "2576:         scale_colors();",
          "2577:         SET_PROC_FLAG(LIBRAW_PROGRESS_SCALE_COLORS);",
          "2578:       }",
          "2580:     pre_interpolate();",
          "2582:     SET_PROC_FLAG(LIBRAW_PROGRESS_PRE_INTERPOLATE);",
          "2584:     if (O.dcb_iterations >= 0) iterations = O.dcb_iterations;",
          "2585:     if (O.dcb_enhance_fl >=0 ) dcb_enhance = O.dcb_enhance_fl;",
          "2586:     if (O.fbdd_noiserd >=0 ) noiserd = O.fbdd_noiserd;",
          "2587:     if (O.eeci_refine >=0 ) eeci_refine_fl = O.eeci_refine;",
          "2588:     if (O.es_med_passes >0 ) es_med_passes_fl = O.es_med_passes;",
          "2592:     if (!O.half_size && O.cfa_green >0) {thresh=O.green_thresh ;green_equilibrate(thresh);}",
          "2593:     if (O.exp_correc >0) {expos=O.exp_shift ; preser=O.exp_preser; exp_bef(expos,preser);}",
          "2594:     if (O.ca_correc >0 ) {cablue=O.cablue; cared=O.cared; CA_correct_RT(cablue, cared);}",
          "2595:     if (O.cfaline >0 ) {linenoise=O.linenoise; cfa_linedn(linenoise);}",
          "2596:     if (O.cfa_clean >0 ) {lclean=O.lclean; cclean=O.cclean; cfa_impulse_gauss(lclean,cclean);}",
          "2598:     if (P1.filters)",
          "2599:       {",
          "2600:         if (noiserd>0 && P1.colors==3 && P1.filters) fbdd(noiserd);",
          "2601:         if (quality == 0)",
          "2602:           lin_interpolate();",
          "2603:         else if (quality == 1 || P1.colors > 3)",
          "2604:           vng_interpolate();",
          "2605:         else if (quality == 2 && P1.filters > 1000)",
          "2606:           ppg_interpolate();",
          "2607:         else if (P1.filters == 9)",
          "2608:           {",
          "2610:             fprintf(stderr,\"Xtrans int\\n\");",
          "2611:             xtrans_interpolate(quality>2?3:1);",
          "2612:           }",
          "2613:         else if (quality == 3)",
          "2614:           ahd_interpolate(); // really don't need it here due to fallback op",
          "2615:         else if (quality == 4)",
          "2616:           dcb(iterations, dcb_enhance);",
          "2618:         else if (quality == 5)",
          "2619:           ahd_interpolate_mod();",
          "2620:         else if (quality == 6)",
          "2621:           afd_interpolate_pl(2,1);",
          "2622:         else if (quality == 7)",
          "2623:           vcd_interpolate(0);",
          "2624:         else if (quality == 8)",
          "2625:           vcd_interpolate(12);",
          "2626:         else if (quality == 9)",
          "2627:           lmmse_interpolate(1);",
          "2630:         else if (quality == 10)",
          "2631:           amaze_demosaic_RT();",
          "2633:         else if (quality == 11)",
          "2634:           dht_interpolate();",
          "2635:         else if (quality == 12)",
          "2636:           aahd_interpolate();",
          "2638:         else",
          "2639:           ahd_interpolate();",
          "2641:         SET_PROC_FLAG(LIBRAW_PROGRESS_INTERPOLATE);",
          "2642:       }",
          "2643:     if (IO.mix_green)",
          "2644:       {",
          "2645:         for (P1.colors=3, i=0; i < S.height * S.width; i++)",
          "2646:           imgdata.image[i][1] = (imgdata.image[i][1] + imgdata.image[i][3]) >> 1;",
          "2647:         SET_PROC_FLAG(LIBRAW_PROGRESS_MIX_GREEN);",
          "2648:       }",
          "2650:     if(!P1.is_foveon)",
          "2651:       {",
          "2652:         if (P1.colors == 3)",
          "2653:           {",
          "2655:             if (quality == 8)",
          "2656:               {",
          "2657:                 if (eeci_refine_fl == 1) refinement();",
          "2658:                 if (O.med_passes > 0)    median_filter_new();",
          "2659:                 if (es_med_passes_fl > 0) es_median_filter();",
          "2660:               }",
          "2661:             else {",
          "2662:               median_filter();",
          "2664:             SET_PROC_FLAG(LIBRAW_PROGRESS_MEDIAN_FILTER);",
          "2665:           }",
          "2666:       }",
          "2668:     if (O.highlight == 2)",
          "2669:       {",
          "2670:         blend_highlights();",
          "2671:         SET_PROC_FLAG(LIBRAW_PROGRESS_HIGHLIGHTS);",
          "2672:       }",
          "2674:     if (O.highlight > 2)",
          "2675:       {",
          "2676:         recover_highlights();",
          "2677:         SET_PROC_FLAG(LIBRAW_PROGRESS_HIGHLIGHTS);",
          "2678:       }",
          "2680:     if (O.use_fuji_rotate)",
          "2681:       {",
          "2682:         fuji_rotate();",
          "2683:         SET_PROC_FLAG(LIBRAW_PROGRESS_FUJI_ROTATE);",
          "2684:       }",
          "2686:     if(!libraw_internal_data.output_data.histogram)",
          "2687:       {",
          "2688:         libraw_internal_data.output_data.histogram = (int (*)[LIBRAW_HISTOGRAM_SIZE]) malloc(sizeof(*libraw_internal_data.output_data.histogram)*4);",
          "2689:         merror(libraw_internal_data.output_data.histogram,\"LibRaw::dcraw_process()\");",
          "2690:       }",
          "2692:     if(O.camera_profile)",
          "2693:       {",
          "2694:         apply_profile(O.camera_profile,O.output_profile);",
          "2695:         SET_PROC_FLAG(LIBRAW_PROGRESS_APPLY_PROFILE);",
          "2696:       }",
          "2699:     convert_to_rgb();",
          "2700:     SET_PROC_FLAG(LIBRAW_PROGRESS_CONVERT_RGB);",
          "2702:     if (O.use_fuji_rotate)",
          "2703:       {",
          "2704:         stretch();",
          "2705:         SET_PROC_FLAG(LIBRAW_PROGRESS_STRETCH);",
          "2706:       }",
          "2707:     O.four_color_rgb = save_4color; // also, restore",
          "2709:     return 0;",
          "2710:   }",
          "2711:   catch ( LibRaw_exceptions err) {",
          "2712:     EXCEPTION_HANDLER(err);",
          "2713:   }",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "3279: const char * LibRaw::strprogress(enum LibRaw_progress p)",
          "3280: {",
          "3328: }",
          "",
          "[Removed Lines]",
          "3281:     switch(p)",
          "3282:         {",
          "3283:         case LIBRAW_PROGRESS_START:",
          "3284:             return \"Starting\";",
          "3285:         case LIBRAW_PROGRESS_OPEN :",
          "3286:             return \"Opening file\";",
          "3287:         case LIBRAW_PROGRESS_IDENTIFY :",
          "3288:             return \"Reading metadata\";",
          "3289:         case LIBRAW_PROGRESS_SIZE_ADJUST:",
          "3290:             return \"Adjusting size\";",
          "3291:         case LIBRAW_PROGRESS_LOAD_RAW:",
          "3292:             return \"Reading RAW data\";",
          "3293:         case LIBRAW_PROGRESS_REMOVE_ZEROES:",
          "3294:             return \"Clearing zero values\";",
          "3295:         case LIBRAW_PROGRESS_BAD_PIXELS :",
          "3296:             return \"Removing dead pixels\";",
          "3297:         case LIBRAW_PROGRESS_DARK_FRAME:",
          "3298:             return \"Subtracting dark frame data\";",
          "3299:         case LIBRAW_PROGRESS_FOVEON_INTERPOLATE:",
          "3300:             return \"Interpolating Foveon sensor data\";",
          "3301:         case LIBRAW_PROGRESS_SCALE_COLORS:",
          "3302:             return \"Scaling colors\";",
          "3303:         case LIBRAW_PROGRESS_PRE_INTERPOLATE:",
          "3304:             return \"Pre-interpolating\";",
          "3305:         case LIBRAW_PROGRESS_INTERPOLATE:",
          "3306:             return \"Interpolating\";",
          "3307:         case LIBRAW_PROGRESS_MIX_GREEN :",
          "3308:             return \"Mixing green channels\";",
          "3309:         case LIBRAW_PROGRESS_MEDIAN_FILTER   :",
          "3310:             return \"Median filter\";",
          "3311:         case LIBRAW_PROGRESS_HIGHLIGHTS:",
          "3312:             return \"Highlight recovery\";",
          "3313:         case LIBRAW_PROGRESS_FUJI_ROTATE :",
          "3314:             return \"Rotating Fuji diagonal data\";",
          "3315:         case LIBRAW_PROGRESS_FLIP :",
          "3316:             return \"Flipping image\";",
          "3317:         case LIBRAW_PROGRESS_APPLY_PROFILE:",
          "3318:             return \"ICC conversion\";",
          "3319:         case LIBRAW_PROGRESS_CONVERT_RGB:",
          "3320:             return \"Converting to RGB\";",
          "3321:         case LIBRAW_PROGRESS_STRETCH:",
          "3322:             return \"Stretching image\";",
          "3323:         case LIBRAW_PROGRESS_THUMB_LOAD:",
          "3324:             return \"Loading thumbnail\";",
          "3325:         default:",
          "3326:             return \"Some strange things\";",
          "3327:         }",
          "",
          "[Added Lines]",
          "3281:   switch(p)",
          "3282:     {",
          "3283:     case LIBRAW_PROGRESS_START:",
          "3284:       return \"Starting\";",
          "3285:     case LIBRAW_PROGRESS_OPEN :",
          "3286:       return \"Opening file\";",
          "3287:     case LIBRAW_PROGRESS_IDENTIFY :",
          "3288:       return \"Reading metadata\";",
          "3289:     case LIBRAW_PROGRESS_SIZE_ADJUST:",
          "3290:       return \"Adjusting size\";",
          "3291:     case LIBRAW_PROGRESS_LOAD_RAW:",
          "3292:       return \"Reading RAW data\";",
          "3293:     case LIBRAW_PROGRESS_REMOVE_ZEROES:",
          "3294:       return \"Clearing zero values\";",
          "3295:     case LIBRAW_PROGRESS_BAD_PIXELS :",
          "3296:       return \"Removing dead pixels\";",
          "3297:     case LIBRAW_PROGRESS_DARK_FRAME:",
          "3298:       return \"Subtracting dark frame data\";",
          "3299:     case LIBRAW_PROGRESS_FOVEON_INTERPOLATE:",
          "3300:       return \"Interpolating Foveon sensor data\";",
          "3301:     case LIBRAW_PROGRESS_SCALE_COLORS:",
          "3302:       return \"Scaling colors\";",
          "3303:     case LIBRAW_PROGRESS_PRE_INTERPOLATE:",
          "3304:       return \"Pre-interpolating\";",
          "3305:     case LIBRAW_PROGRESS_INTERPOLATE:",
          "3306:       return \"Interpolating\";",
          "3307:     case LIBRAW_PROGRESS_MIX_GREEN :",
          "3308:       return \"Mixing green channels\";",
          "3309:     case LIBRAW_PROGRESS_MEDIAN_FILTER   :",
          "3310:       return \"Median filter\";",
          "3311:     case LIBRAW_PROGRESS_HIGHLIGHTS:",
          "3312:       return \"Highlight recovery\";",
          "3313:     case LIBRAW_PROGRESS_FUJI_ROTATE :",
          "3314:       return \"Rotating Fuji diagonal data\";",
          "3315:     case LIBRAW_PROGRESS_FLIP :",
          "3316:       return \"Flipping image\";",
          "3317:     case LIBRAW_PROGRESS_APPLY_PROFILE:",
          "3318:       return \"ICC conversion\";",
          "3319:     case LIBRAW_PROGRESS_CONVERT_RGB:",
          "3320:       return \"Converting to RGB\";",
          "3321:     case LIBRAW_PROGRESS_STRETCH:",
          "3322:       return \"Stretching image\";",
          "3323:     case LIBRAW_PROGRESS_THUMB_LOAD:",
          "3324:       return \"Loading thumbnail\";",
          "3325:     default:",
          "3326:       return \"Some strange things\";",
          "3327:     }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "7bc160b4ca61389194d4655ab2673817f4b693c0",
      "candidate_info": {
        "commit_hash": "7bc160b4ca61389194d4655ab2673817f4b693c0",
        "repo": "LibRaw/LibRaw",
        "commit_url": "https://github.com/LibRaw/LibRaw/commit/7bc160b4ca61389194d4655ab2673817f4b693c0",
        "files": [
          "dcraw/dcraw.c",
          "internal/dcraw_common.cpp",
          "internal/dcraw_fileio.cpp",
          "src/libraw_cxx.cpp"
        ],
        "message": "no 1-pass subtract black for zero_is_bad cameras",
        "before_after_code_files": [
          "dcraw/dcraw.c||dcraw/dcraw.c",
          "internal/dcraw_common.cpp||internal/dcraw_common.cpp",
          "internal/dcraw_fileio.cpp||internal/dcraw_fileio.cpp",
          "src/libraw_cxx.cpp||src/libraw_cxx.cpp"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/libraw_cxx.cpp||src/libraw_cxx.cpp"
          ],
          "candidate": [
            "src/libraw_cxx.cpp||src/libraw_cxx.cpp"
          ]
        }
      },
      "candidate_diff": {
        "dcraw/dcraw.c||dcraw/dcraw.c": [
          "File: dcraw/dcraw.c -> dcraw/dcraw.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3946:   if (load_raw == &CLASS canon_600_load_raw && width < raw_width) {",
          "3947:     black = (mblack[0]+mblack[1]+mblack[2]+mblack[3]) /",
          "3948:      (mblack[4]+mblack[5]+mblack[6]+mblack[7]) - 4;",
          "3949:     canon_600_correct();",
          "3950:   } else if (zero < mblack[4] && mblack[5] && mblack[6] && mblack[7])",
          "3951:     FORC4 cblack[c] = mblack[c] / mblack[4+c];",
          "3952: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3949: #ifndef LIBRAW_LIBRARY_BUILD",
          "3951: #endif",
          "",
          "---------------"
        ],
        "internal/dcraw_common.cpp||internal/dcraw_common.cpp": [
          "File: internal/dcraw_common.cpp -> internal/dcraw_common.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "2970:   if (load_raw == &CLASS canon_600_load_raw && width < raw_width) {",
          "2971:     black = (mblack[0]+mblack[1]+mblack[2]+mblack[3]) /",
          "2972:      (mblack[4]+mblack[5]+mblack[6]+mblack[7]) - 4;",
          "2973:     canon_600_correct();",
          "2974:   } else if (zero < mblack[4] && mblack[5] && mblack[6] && mblack[7])",
          "2975:     FORC4 cblack[c] = mblack[c] / mblack[4+c];",
          "2976: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2973: #ifndef LIBRAW_LIBRARY_BUILD",
          "2975: #endif",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2998:   RUN_CALLBACK(LIBRAW_PROGRESS_REMOVE_ZEROES,1,2);",
          "2999: #endif",
          "3000: }",
          "3002: void CLASS gamma_curve (double pwr, double ts, int mode, int imax)",
          "3003: {",
          "3004:   int i;",
          "",
          "[Removed Lines]",
          "3001: #line 4143 \"dcraw/dcraw.c\"",
          "",
          "[Added Lines]",
          "3003: #line 4145 \"dcraw/dcraw.c\"",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "4496:     fseek (ifp, save, SEEK_SET);",
          "4497:   }",
          "4498: }",
          "4500: void CLASS parse_makernote (int base, int uptag)",
          "4501: {",
          "4502:   static const uchar xlat[2][256] = {",
          "",
          "[Removed Lines]",
          "4499: #line 5645 \"dcraw/dcraw.c\"",
          "",
          "[Added Lines]",
          "4501: #line 5647 \"dcraw/dcraw.c\"",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "5011:     fseek (ifp, save, SEEK_SET);",
          "5012:   }",
          "5013: }",
          "5015: int CLASS parse_tiff_ifd (int base)",
          "5016: {",
          "5017:   unsigned entries, tag, type, len, plen=16, save;",
          "",
          "[Removed Lines]",
          "5014: #line 6165 \"dcraw/dcraw.c\"",
          "",
          "[Added Lines]",
          "5016: #line 6167 \"dcraw/dcraw.c\"",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "6255:     data_offset = get4();",
          "6256:   }",
          "6257: }",
          "6259: char * CLASS foveon_gets (int offset, char *str, int len)",
          "6260: {",
          "6261:   int i;",
          "",
          "[Removed Lines]",
          "6258: #line 7411 \"dcraw/dcraw.c\"",
          "",
          "[Added Lines]",
          "6260: #line 7413 \"dcraw/dcraw.c\"",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "6356:   }",
          "6357:   is_foveon = 1;",
          "6358: }",
          "6361:    All matrices are from Adobe DNG Converter unless otherwise noted.",
          "",
          "[Removed Lines]",
          "6359: #line 7514 \"dcraw/dcraw.c\"",
          "",
          "[Added Lines]",
          "6361: #line 7516 \"dcraw/dcraw.c\"",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "8799: }",
          "8803: void CLASS convert_to_rgb()",
          "8804: {",
          "8805: #ifndef LIBRAW_LIBRARY_BUILD",
          "",
          "[Removed Lines]",
          "8802: #line 10048 \"dcraw/dcraw.c\"",
          "",
          "[Added Lines]",
          "8804: #line 10050 \"dcraw/dcraw.c\"",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "9030:   if (flip & 1) col = iwidth  - 1 - col;",
          "9031:   return row * iwidth + col;",
          "9032: }",
          "9034: void CLASS tiff_set (ushort *ntag,",
          "9035:  ushort tag, ushort type, int count, int val)",
          "9036: {",
          "",
          "[Removed Lines]",
          "9033: #line 10304 \"dcraw/dcraw.c\"",
          "",
          "[Added Lines]",
          "9035: #line 10306 \"dcraw/dcraw.c\"",
          "",
          "---------------"
        ],
        "internal/dcraw_fileio.cpp||internal/dcraw_fileio.cpp": [
          "File: internal/dcraw_fileio.cpp -> internal/dcraw_fileio.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "21:    for more information",
          "25: #include <math.h>",
          "26: #define CLASS LibRaw::",
          "27: #include \"libraw/libraw_types.h\"",
          "",
          "[Removed Lines]",
          "24: #line 3980 \"dcraw/dcraw.c\"",
          "",
          "[Added Lines]",
          "24: #line 3982 \"dcraw/dcraw.c\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "29: #include \"libraw/libraw.h\"",
          "30: #include \"internal/defines.h\"",
          "31: #include \"internal/var_defines.h\"",
          "34:    Seach from the current directory up to the root looking for",
          "35:    a \".badpixels\" file, and fix those pixels now.",
          "",
          "[Removed Lines]",
          "32: #line 3991 \"dcraw/dcraw.c\"",
          "",
          "[Added Lines]",
          "32: #line 3993 \"dcraw/dcraw.c\"",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "54: #endif",
          "55:   if (cfname)",
          "56:     fp = fopen (cfname, \"r\");",
          "58:   if (!fp)",
          "59:       {",
          "60: #ifdef LIBRAW_LIBRARY_BUILD",
          "",
          "[Removed Lines]",
          "57: #line 4041 \"dcraw/dcraw.c\"",
          "",
          "[Added Lines]",
          "57: #line 4043 \"dcraw/dcraw.c\"",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "154:   RUN_CALLBACK(LIBRAW_PROGRESS_DARK_FRAME,1,2);",
          "155: #endif",
          "156: }",
          "158: #ifndef NO_LCMS",
          "159: void CLASS apply_profile (const char *input, const char *output)",
          "160: {",
          "",
          "[Removed Lines]",
          "157: #line 9959 \"dcraw/dcraw.c\"",
          "",
          "[Added Lines]",
          "157: #line 9961 \"dcraw/dcraw.c\"",
          "",
          "---------------"
        ],
        "src/libraw_cxx.cpp||src/libraw_cxx.cpp": [
          "File: src/libraw_cxx.cpp -> src/libraw_cxx.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "972:      phase_one_free_tempbuffer();",
          "973:           }",
          "975:         imgdata.progress_flags",
          "976:             = LIBRAW_PROGRESS_START|LIBRAW_PROGRESS_OPEN",
          "977:             |LIBRAW_PROGRESS_IDENTIFY|LIBRAW_PROGRESS_SIZE_ADJUST|LIBRAW_PROGRESS_LOAD_RAW;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "976:         if (load_raw == &CLASS canon_600_load_raw && S.width < S.raw_width)",
          "977:           {",
          "978:             canon_600_correct();",
          "979:           }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1300:       {",
          "1301:     phase_one_free_tempbuffer();",
          "1302:       }",
          "1304:     if(do_subtract_black)",
          "1305:       {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1309:     if (load_raw == &CLASS canon_600_load_raw && S.width < S.raw_width)",
          "1310:       {",
          "1311:         canon_600_correct();",
          "1312:       }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2108:         libraw_decoder_info_t di;",
          "2109:         get_decoder_info(&di);",
          "2113:         raw2image_ex(subtract_inline); // allocate imgdata.image and copy data!",
          "2115:         int save_4color = O.four_color_rgb;",
          "2117:         if (IO.zero_is_bad)",
          "2119:                 remove_zeroes();",
          "2120:                 SET_PROC_FLAG(LIBRAW_PROGRESS_REMOVE_ZEROES);",
          "2121:             }",
          "",
          "[Removed Lines]",
          "2111:         int subtract_inline = !O.bad_pixels && !O.dark_frame && !O.wf_debanding && !(di.decoder_flags & LIBRAW_DECODER_LEGACY);",
          "2118:             {",
          "",
          "[Added Lines]",
          "2121:         int subtract_inline = !O.bad_pixels && !O.dark_frame && !O.wf_debanding && !(di.decoder_flags & LIBRAW_DECODER_LEGACY) && !IO.zero_is_bad;",
          "2128:           {",
          "2129:             printf(\"Removing zeroes\\n\");",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "159b5d6910aa6b126afd3ce433f1ae96256674b6",
      "candidate_info": {
        "commit_hash": "159b5d6910aa6b126afd3ce433f1ae96256674b6",
        "repo": "LibRaw/LibRaw",
        "commit_url": "https://github.com/LibRaw/LibRaw/commit/159b5d6910aa6b126afd3ce433f1ae96256674b6",
        "files": [
          "libraw/libraw.h",
          "src/libraw_cxx.cpp"
        ],
        "message": "black subctraction/max calculation on raw2image_ex()",
        "before_after_code_files": [
          "libraw/libraw.h||libraw/libraw.h",
          "src/libraw_cxx.cpp||src/libraw_cxx.cpp"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/libraw_cxx.cpp||src/libraw_cxx.cpp"
          ],
          "candidate": [
            "src/libraw_cxx.cpp||src/libraw_cxx.cpp"
          ]
        }
      },
      "candidate_diff": {
        "libraw/libraw.h||libraw/libraw.h": [
          "File: libraw/libraw.h -> libraw/libraw.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "110:     int                         adjust_sizes_info_only(void);",
          "111:     void                        subtract_black();",
          "112:     int                         raw2image();",
          "114:     void                        raw2image_start();",
          "115:     void                        free_image();",
          "116:     int                         adjust_maximum();",
          "",
          "[Removed Lines]",
          "113:     int                         raw2image_ex();",
          "",
          "[Added Lines]",
          "113:     int                         raw2image_ex(int do_subtract_black);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "169:         return FC(rr,cc);",
          "170:     }",
          "174:     void*        malloc(size_t t);",
          "175:     void*        calloc(size_t n,size_t t);",
          "176:     void*        realloc(void *p, size_t s);",
          "",
          "[Removed Lines]",
          "172:     virtual void copy_fuji_uncropped();",
          "173:     virtual void copy_bayer();",
          "",
          "[Added Lines]",
          "172:     void adjust_bl();",
          "173:     virtual void copy_fuji_uncropped(unsigned short cblack[4], unsigned short *dmaxp);",
          "174:     virtual void copy_bayer(unsigned short cblack[4], unsigned short *dmaxp);",
          "",
          "---------------"
        ],
        "src/libraw_cxx.cpp||src/libraw_cxx.cpp": [
          "File: src/libraw_cxx.cpp -> src/libraw_cxx.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "1006:     }",
          "1007: }",
          "1010: {",
          "1011:                 int row;",
          "1012: #if defined(LIBRAW_USE_OPENMP)",
          "",
          "[Removed Lines]",
          "1009: void LibRaw::copy_fuji_uncropped(void)",
          "",
          "[Added Lines]",
          "1009: void LibRaw::copy_fuji_uncropped(unsigned short cblack[4],unsigned short *dmaxp)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1015:                 for (row=0; row < S.raw_height-S.top_margin*2; row++)",
          "1016:                   {",
          "1017:                     int col;",
          "1018:                     for (col=0; col < IO.fuji_width << !libraw_internal_data.unpacker_data.fuji_layout; col++)",
          "1019:                       {",
          "1020:                         unsigned r,c;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1018:                     unsigned short ldmax = 0;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1027:                         }",
          "1028:                         if (r < S.height && c < S.width)",
          "1029:                           {",
          "1032:                           }",
          "1033:                       }",
          "1034:                   }",
          "1035: }",
          "1038: {",
          "1040:   int row;",
          "",
          "[Removed Lines]",
          "1030:                             imgdata.image[((r)>>IO.shrink)*S.iwidth+((c)>>IO.shrink)][FC(r,c)]",
          "1031:                               = imgdata.rawdata.raw_image[(row+S.top_margin)*S.raw_width+(col+S.left_margin)];",
          "1037: void LibRaw::copy_bayer(void)",
          "",
          "[Added Lines]",
          "1031:                             unsigned short val = imgdata.rawdata.raw_image[(row+S.top_margin)*S.raw_width+(col+S.left_margin)];",
          "1032:                             int cc = FC(r,c);",
          "1033:                             if(val>cblack[cc])",
          "1034:                               {",
          "1035:                                 val-=cblack[cc];",
          "1036:                                 if(val>ldmax)ldmax = val;",
          "1037:                               }",
          "1038:                             else",
          "1039:                               val = 0;",
          "1040:                             imgdata.image[((r)>>IO.shrink)*S.iwidth+((c)>>IO.shrink)][cc] = val;",
          "1043: #if defined(LIBRAW_USE_OPENMP)",
          "1044: #pragma omp critical(dataupdate)",
          "1045: #endif",
          "1046:                     {",
          "1047:                       if(*dmaxp < ldmax)",
          "1049:                     }",
          "1053: void LibRaw::copy_bayer(unsigned short cblack[4],unsigned short *dmaxp)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1044:   for (row=0; row < S.height; row++)",
          "1045:     {",
          "1046:       int col;",
          "1047:       for (col=0; col < S.width; col++)",
          "1050:     }",
          "1051: }",
          "1055: {",
          "1057:   CHECK_ORDER_LOW(LIBRAW_PROGRESS_LOAD_RAW);",
          "",
          "[Removed Lines]",
          "1048:         imgdata.image[((row) >> IO.shrink)*S.iwidth + ((col) >> IO.shrink)][fcol(row,col)]",
          "1049:           = imgdata.rawdata.raw_image[(row+S.top_margin)*S.raw_width+(col+S.left_margin)];",
          "1054: int LibRaw::raw2image_ex(void)",
          "",
          "[Added Lines]",
          "1063:       unsigned short ldmax = 0;",
          "1065:         {",
          "1066:           unsigned short val = imgdata.rawdata.raw_image[(row+S.top_margin)*S.raw_width+(col+S.left_margin)];",
          "1067:           int cc = fcol(row,col);",
          "1068:           if(val>cblack[cc])",
          "1069:             {",
          "1070:               val-=cblack[cc];",
          "1071:               if(val>ldmax)ldmax = val;",
          "1072:             }",
          "1073:           else",
          "1074:             val = 0;",
          "1075:           imgdata.image[((row) >> IO.shrink)*S.iwidth + ((col) >> IO.shrink)][cc] = val;",
          "1076:         }",
          "1077: #if defined(LIBRAW_USE_OPENMP)",
          "1078: #pragma omp critical(dataupdate)",
          "1079: #endif",
          "1080:       {",
          "1081:         if(*dmaxp < ldmax)",
          "1083:       }",
          "1088: int LibRaw::raw2image_ex(int do_subtract_black)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1150:     libraw_decoder_info_t decoder_info;",
          "1151:     get_decoder_info(&decoder_info);",
          "1154:     if(decoder_info.decoder_flags & LIBRAW_DECODER_FLATFIELD)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1188:     unsigned short cblack[4]={0,0,0,0};",
          "1189:     unsigned short dmax = 0;",
          "1190:     if(do_subtract_black)",
          "1191:       {",
          "1192:         adjust_bl();",
          "1193:         for(int i=0; i< 4; i++)",
          "1194:           cblack[i] = (unsigned short)C.cblack[i];",
          "1195:       }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1175:                           c = row + ((col+1) >> 1);",
          "1176:                         }",
          "1179:                                                             +(col+S.left_margin)];",
          "1180:                         int cc = FCF(row,col);",
          "1181:                         imgdata.image[((r) >> IO.shrink)*alloc_width + ((c) >> IO.shrink)][cc] = val;",
          "1182:                       }",
          "1183:                   }",
          "",
          "[Removed Lines]",
          "1178:                         int val = imgdata.rawdata.raw_image[(row+S.top_margin)*S.raw_width",
          "",
          "[Added Lines]",
          "1222:                         unsigned short val = imgdata.rawdata.raw_image[(row+S.top_margin)*S.raw_width",
          "1225:                         if(val > cblack[cc])",
          "1226:                           {",
          "1227:                             val-=cblack[cc];",
          "1228:                             if(dmax < val) dmax = val;",
          "1229:                           }",
          "1230:                         else",
          "1231:                           val = 0;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1189:               }",
          "1190:             else",
          "1191:               {",
          "1193:               }",
          "1194:           } // end Fuji",
          "1195:         else",
          "1196:           {",
          "1198:           }",
          "1199:       }",
          "1200:     else if(decoder_info.decoder_flags & LIBRAW_DECODER_LEGACY)",
          "",
          "[Removed Lines]",
          "1192:                 copy_fuji_uncropped();",
          "1197:             copy_bayer();",
          "",
          "[Added Lines]",
          "1243:                 copy_fuji_uncropped(cblack,&dmax);",
          "1248:             copy_bayer(cblack,&dmax);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1220:         imgdata.rawdata.raw_image = (ushort*) imgdata.rawdata.raw_alloc;",
          "1221:       }",
          "1224:     imgdata.progress_flags",
          "1225:       = LIBRAW_PROGRESS_START|LIBRAW_PROGRESS_OPEN",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1274:     if(do_subtract_black)",
          "1275:       {",
          "1276:         C.data_maximum = (int)dmax;",
          "1277:         C.maximum -= C.black;",
          "1278:         ZERO(C.cblack);",
          "1279:         C.black = 0;",
          "1280:       }",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1974:     }",
          "1975: }",
          "1977: int LibRaw::dcraw_process(void)",
          "1978: {",
          "1979:     int quality,i;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2036: void LibRaw::adjust_bl()",
          "2037: {",
          "2038:   int i = C.cblack[3];",
          "2039:   int c;",
          "2040:   for(c=0;c<3;c++) if (i > C.cblack[c]) i = C.cblack[c];",
          "2041:   for(c=0;c<4;c++) C.cblack[c] -= i;",
          "2042:   C.black += i;",
          "2043:   if (O.user_black >= 0) C.black = O.user_black;",
          "2044:   for(c=0;c<4;c++) C.cblack[c] += C.black;",
          "2045: }",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1998:         if (~O.cropbox[2] && ~O.cropbox[3])",
          "1999:             no_crop=0;",
          "2003:         int save_4color = O.four_color_rgb;",
          "",
          "[Removed Lines]",
          "2001:         raw2image_ex(); // allocate imgdata.image and copy data!",
          "",
          "[Added Lines]",
          "2071:         libraw_decoder_info_t di;",
          "2072:         get_decoder_info(&di);",
          "2074:         int subtract_inline = !O.bad_pixels && !O.dark_frame && !O.wf_debanding && !(di.decoder_flags & LIBRAW_DECODER_LEGACY);",
          "2076:         raw2image_ex(subtract_inline); // allocate imgdata.image and copy data!",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "2033:         if (O.user_qual >= 0) quality = O.user_qual;",
          "2045:         adjust_maximum();",
          "",
          "[Removed Lines]",
          "2035:         i = C.cblack[3];",
          "2036:         int c;",
          "2037:         for(c=0;c<3;c++) if (i > C.cblack[c]) i = C.cblack[c];",
          "2038:         for(c=0;c<4;c++) C.cblack[c] -= i;",
          "2039:         C.black += i;",
          "2040:         if (O.user_black >= 0) C.black = O.user_black;",
          "2041:         for(c=0;c<4;c++) C.cblack[c] += C.black;",
          "2043:         subtract_black();",
          "",
          "[Added Lines]",
          "2110:         if(!subtract_inline || !C.data_maximum)",
          "2111:           {",
          "2112:             adjust_bl();",
          "2113:             subtract_black();",
          "2114:           }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "0cba248c1cc726487b481bf19bec48e2d896d26b",
      "candidate_info": {
        "commit_hash": "0cba248c1cc726487b481bf19bec48e2d896d26b",
        "repo": "LibRaw/LibRaw",
        "commit_url": "https://github.com/LibRaw/LibRaw/commit/0cba248c1cc726487b481bf19bec48e2d896d26b",
        "files": [
          "dcraw/dcraw.c",
          "internal/dcraw_common.cpp",
          "libraw/libraw_types.h",
          "samples/dcraw_emu.cpp",
          "samples/postprocessing_benchmark.cpp",
          "src/libraw_cxx.cpp"
        ],
        "message": "everything but lossy DNGs works OK",
        "before_after_code_files": [
          "dcraw/dcraw.c||dcraw/dcraw.c",
          "internal/dcraw_common.cpp||internal/dcraw_common.cpp",
          "libraw/libraw_types.h||libraw/libraw_types.h",
          "samples/dcraw_emu.cpp||samples/dcraw_emu.cpp",
          "samples/postprocessing_benchmark.cpp||samples/postprocessing_benchmark.cpp",
          "src/libraw_cxx.cpp||src/libraw_cxx.cpp"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/libraw_cxx.cpp||src/libraw_cxx.cpp"
          ],
          "candidate": [
            "src/libraw_cxx.cpp||src/libraw_cxx.cpp"
          ]
        }
      },
      "candidate_diff": {
        "dcraw/dcraw.c||dcraw/dcraw.c": [
          "File: dcraw/dcraw.c -> dcraw/dcraw.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4267:   }",
          "4268: #endif",
          "4269:   size = iheight*iwidth;",
          "4271:   scale_colors_loop(scale_mul);",
          "4272: #else",
          "4273:   for (i=0; i < size*4; i++) {",
          "",
          "[Removed Lines]",
          "4270: #ifdef LIBRAW_LIBRARY_BUILD",
          "",
          "[Added Lines]",
          "4270: #ifdef LIBRAW_LIBRARY_BUILD__1",
          "",
          "---------------"
        ],
        "internal/dcraw_common.cpp||internal/dcraw_common.cpp": [
          "File: internal/dcraw_common.cpp -> internal/dcraw_common.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "3127:   }",
          "3128: #endif",
          "3129:   size = iheight*iwidth;",
          "3131:   scale_colors_loop(scale_mul);",
          "3132: #else",
          "3133:   for (i=0; i < size*4; i++) {",
          "",
          "[Removed Lines]",
          "3130: #ifdef LIBRAW_LIBRARY_BUILD",
          "",
          "[Added Lines]",
          "3130: #ifdef LIBRAW_LIBRARY_BUILD__1",
          "",
          "---------------"
        ],
        "libraw/libraw_types.h||libraw/libraw_types.h": [
          "File: libraw/libraw_types.h -> libraw/libraw_types.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "107:     unsigned    zero_is_bad;",
          "108:     ushort      shrink;",
          "109:     ushort      fuji_width;",
          "111: } libraw_internal_output_params_t;",
          "",
          "[Removed Lines]",
          "110:     ushort      fwidth,fheight;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "173:                 iwidth;",
          "174:     double      pixel_aspect;",
          "175:     int         flip;",
          "178: } libraw_image_sizes_t;",
          "",
          "[Removed Lines]",
          "176:   int         mask[8][4];",
          "",
          "[Added Lines]",
          "175:     int         mask[8][4];",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "186: typedef struct",
          "187: {",
          "188:  ushort      curve[0x10000];",
          "190:  unsigned    black;",
          "191:  unsigned    maximum;",
          "192:  unsigned    channel_maximum[4];",
          "",
          "[Removed Lines]",
          "189:  unsigned    cblack[8];",
          "",
          "[Added Lines]",
          "188:  unsigned    cblack[4];",
          "",
          "---------------"
        ],
        "samples/dcraw_emu.cpp||samples/dcraw_emu.cpp": [
          "File: samples/dcraw_emu.cpp -> samples/dcraw_emu.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "284:                       }",
          "285:                   break;",
          "286:               case 'A':  for(c=0; c<4;c++) OUT.greybox[c]  = atoi(argv[arg++]); break;",
          "288:               case 'a':",
          "289:                   if(!strcmp(optstr,\"-aexpo\"))",
          "290:                       {",
          "",
          "[Removed Lines]",
          "287:               case 'B':  for(c=0; c<4;c++) OUT.cropbox[c]  = atoi(argv[arg++]); break;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "samples/postprocessing_benchmark.cpp||samples/postprocessing_benchmark.cpp": [
          "File: samples/postprocessing_benchmark.cpp -> samples/postprocessing_benchmark.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "106:                     OUT.shot_select = abs(atoi(argv[arg++]));",
          "107:                     break;",
          "108:                 case 'B':",
          "110:                     break;",
          "111:                 case 'R':",
          "112:                     rep = abs(atoi(argv[arg++]));",
          "",
          "[Removed Lines]",
          "109:                     for(c=0; c<4;c++) OUT.cropbox[c]  = atoi(argv[arg++]);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "157:             if(c==rep) // no failure",
          "158:                 {",
          "159:                     unsigned int crop[4];",
          "160:                     for(int i=0;i<4;i++) crop[i] = (OUT.cropbox[i])>>shrink;",
          "161:                     if(crop[0]+crop[2]>S.iwidth) crop[2] = S.iwidth-crop[0];",
          "162:                     if(crop[1]+crop[3]>S.iheight) crop[3] = S.iheight-crop[1];",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "160: #if 0",
          "162: #else",
          "163:                     bzero(crop,sizeof(crop));",
          "164: #endif",
          "",
          "---------------"
        ],
        "src/libraw_cxx.cpp||src/libraw_cxx.cpp": [
          "File: src/libraw_cxx.cpp -> src/libraw_cxx.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "189:     memmove(&imgdata.params.aber,&aber,sizeof(aber));",
          "190:     memmove(&imgdata.params.gamm,&gamm,sizeof(gamm));",
          "191:     memmove(&imgdata.params.greybox,&greybox,sizeof(greybox));",
          "194:     imgdata.params.bright=1;",
          "195:     imgdata.params.use_camera_matrix=-1;",
          "",
          "[Removed Lines]",
          "192:     memmove(&imgdata.params.cropbox,&cropbox,sizeof(cropbox));",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "239:     memmgr.free(p);",
          "240: }",
          "268: void LibRaw:: recycle()",
          "269: {",
          "",
          "[Removed Lines]",
          "242: #if 0",
          "243: int LibRaw:: fc (int row, int col)",
          "244: {",
          "245:     static const char filter[16][16] =",
          "246:         { { 2,1,1,3,2,3,2,0,3,2,3,0,1,2,1,0 },",
          "247:           { 0,3,0,2,0,1,3,1,0,1,1,2,0,3,3,2 },",
          "248:           { 2,3,3,2,3,1,1,3,3,1,2,1,2,0,0,3 },",
          "249:           { 0,1,0,1,0,2,0,2,2,0,3,0,1,3,2,1 },",
          "250:           { 3,1,1,2,0,1,0,2,1,3,1,3,0,1,3,0 },",
          "251:           { 2,0,0,3,3,2,3,1,2,0,2,0,3,2,2,1 },",
          "252:           { 2,3,3,1,2,1,2,1,2,1,1,2,3,0,0,1 },",
          "253:           { 1,0,0,2,3,0,0,3,0,3,0,3,2,1,2,3 },",
          "254:           { 2,3,3,1,1,2,1,0,3,2,3,0,2,3,1,3 },",
          "255:           { 1,0,2,0,3,0,3,2,0,1,1,2,0,1,0,2 },",
          "256:           { 0,1,1,3,3,2,2,1,1,3,3,0,2,1,3,2 },",
          "257:           { 2,3,2,0,0,1,3,0,2,0,1,2,3,0,1,0 },",
          "258:           { 1,3,1,2,3,2,3,2,0,2,0,1,1,0,3,0 },",
          "259:           { 0,2,0,3,1,0,0,1,1,3,3,2,3,2,2,1 },",
          "260:           { 2,1,3,2,3,1,2,1,0,3,0,2,0,2,0,2 },",
          "261:           { 0,3,1,0,0,2,0,3,2,1,3,1,1,3,1,3 } };",
          "263:     if (imgdata.idata.filters != 1) return FC(row,col);",
          "264:     return filter[(row+imgdata.sizes.top_margin) & 15][(col+imgdata.sizes.left_margin) & 15];",
          "265: }",
          "266: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "725:         identify();",
          "736:         if(C.profile_length)",
          "737:             {",
          "738:                 if(C.profile) free(C.profile);",
          "",
          "[Removed Lines]",
          "727:         if(IO.fuji_width)",
          "728:             {",
          "729:                 IO.fwidth = S.width;",
          "730:                 IO.fheight = S.height;",
          "731:                 S.iwidth = S.width = IO.fuji_width << (int)(!libraw_internal_data.unpacker_data.fuji_layout);",
          "732:                 S.iheight = S.height = S.raw_height;",
          "733:                 S.raw_height += 2*S.top_margin;",
          "734:             }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "878:                 }",
          "879:             else if (decoder_info.decoder_flags &  LIBRAW_DECODER_FLATFIELD)",
          "880:                 {",
          "882:                             {",
          "883:                                 int colors[4];",
          "884:                                 for (int xx=0;xx<4;xx++)",
          "887:                                     {",
          "889:                                         if(C.channel_maximum[cc]",
          "895:                                     }",
          "896:                             }",
          "897:                 }",
          "898:         }",
          "",
          "[Removed Lines]",
          "881:                         for(int row = 0; row < S.height; row++)",
          "885:                                     colors[xx] = COLOR(row,xx);",
          "886:                                 for(int col = 0; col < S.width; col++)",
          "888:                                         int cc = colors[col&3];",
          "890:                                            < imgdata.rawdata.raw_image[(row+S.top_margin)*S.raw_width",
          "891:                                                                        +(col+S.left_margin)])",
          "892:                                             C.channel_maximum[cc] =",
          "893:                                                 imgdata.rawdata.raw_image[(row+S.top_margin)*S.raw_width",
          "894:                                                                           +(col+S.left_margin)];",
          "",
          "[Added Lines]",
          "848:                   if(IO.fuji_width)",
          "849:                     {",
          "850:                       for(int row=0; row < S.raw_height-S.top_margin*2; row++)",
          "854:                                   colors[xx] = FCF(row,xx);",
          "855:                                 for(int col=0; col < IO.fuji_width << !libraw_internal_data.unpacker_data.fuji_layout; col++)",
          "857:                                       int cc = colors[col&3];",
          "859:                                            < imgdata.rawdata.raw_image[(row+S.top_margin)*S.raw_width+(col+S.left_margin)])",
          "860:                                           C.channel_maximum[cc] =",
          "861:                                                 imgdata.rawdata.raw_image[(row+S.top_margin)*S.raw_width+(col+S.left_margin)];",
          "864:                     }",
          "865:                   else",
          "866:                     {",
          "867:                       for (int row=0; row < S.height; row++)",
          "868:                         {",
          "869:                                 int colors[48];",
          "870:                                 for (int xx=0;xx<48;xx++)",
          "871:                                   colors[xx] =fcol(row,xx);",
          "872:                                 for (int col=0; col < S.width; col++)",
          "873:                                   {",
          "874:                                       int cc = colors[col%48];",
          "875:                                       if(C.channel_maximum[cc]  < imgdata.rawdata.raw_image[(row+S.top_margin)*S.raw_width+(col+S.left_margin)])",
          "876:                                         C.channel_maximum[cc]  = imgdata.rawdata.raw_image[(row+S.top_margin)*S.raw_width+(col+S.left_margin)];",
          "877:                                   }",
          "878:                         }",
          "879:                     }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "975:     C.cblack[i] = O.user_cblack[i];",
          "976: }",
          "1163: int LibRaw::raw2image(void)",
          "1164: {",
          "",
          "[Removed Lines]",
          "981: #ifndef MIN",
          "982: #define MIN(a,b) ((a) < (b) ? (a) : (b))",
          "983: #endif",
          "984: int LibRaw::raw2image_ex(void)",
          "985: {",
          "986:     CHECK_ORDER_LOW(LIBRAW_PROGRESS_LOAD_RAW);",
          "988:     raw2image_start();",
          "991:     int do_crop = 0;",
          "992:     unsigned save_width = S.width;",
          "993:     if (~O.cropbox[2] && ~O.cropbox[3])",
          "994:         {",
          "995:             int crop[4],c,filt;",
          "996:             for(int c=0;c<4;c++)",
          "997:                 {",
          "998:                     crop[c] = O.cropbox[c];",
          "999:                     if(crop[c]<0)",
          "1000:                         crop[c]=0;",
          "1001:                 }",
          "1002:             if(IO.fwidth)",
          "1003:                 {",
          "1004:                     crop[0] = (crop[0]/4)*4;",
          "1005:                     crop[1] = (crop[1]/4)*4;",
          "1006:                 }",
          "1007:             do_crop = 1;",
          "1008:             crop[2] = MIN (crop[2], (signed) S.width-crop[0]);",
          "1009:             crop[3] = MIN (crop[3], (signed) S.height-crop[1]);",
          "1010:             if (crop[2] <= 0 || crop[3] <= 0)",
          "1011:                 throw LIBRAW_EXCEPTION_BAD_CROP;",
          "1014:             S.left_margin+=crop[0];",
          "1015:             S.top_margin+=crop[1];",
          "1016:             S.width=crop[2];",
          "1017:             S.height=crop[3];",
          "1019:             S.iheight = (S.height + IO.shrink) >> IO.shrink;",
          "1020:             S.iwidth  = (S.width  + IO.shrink) >> IO.shrink;",
          "1021:             if(!IO.fwidth && imgdata.idata.filters)",
          "1022:                 {",
          "1023:                     for (filt=c=0; c < 16; c++)",
          "1024:                         filt |= FC((c >> 1)+(crop[1]),",
          "1025:                                    (c &  1)+(crop[0])) << c*2;",
          "1026:                     imgdata.idata.filters = filt;",
          "1027:                 }",
          "1028:         }",
          "1030:     if(IO.fwidth)",
          "1031:         {",
          "1032:             ushort fiwidth,fiheight;",
          "1033:             if(do_crop)",
          "1034:                 {",
          "1035:                     IO.fuji_width = S.width >> !libraw_internal_data.unpacker_data.fuji_layout;",
          "1036:                     IO.fwidth = (S.height >> libraw_internal_data.unpacker_data.fuji_layout) + IO.fuji_width;",
          "1037:                     IO.fheight = IO.fwidth - 1;",
          "1038:                 }",
          "1040:             fiheight = (IO.fheight + IO.shrink) >> IO.shrink;",
          "1041:             fiwidth = (IO.fwidth + IO.shrink) >> IO.shrink;",
          "1042:             if(imgdata.image)",
          "1043:                     {",
          "1044:                         imgdata.image = (ushort (*)[4])realloc(imgdata.image,fiheight*fiwidth*sizeof (*imgdata.image));",
          "1045:                         memset(imgdata.image,0,fiheight*fiwidth *sizeof (*imgdata.image));",
          "1046:                     }",
          "1047:                 else",
          "1048:                     imgdata.image = (ushort (*)[4]) calloc (fiheight*fiwidth, sizeof (*imgdata.image));",
          "1049:             merror (imgdata.image, \"raw2image_ex()\");",
          "1051:             int cblk[4],i;",
          "1052:             for(i=0;i<4;i++)",
          "1053:                 cblk[i] = C.cblack[i]+C.black;",
          "1054:             ZERO(C.channel_maximum);",
          "1056:             int row,col;",
          "1057:             for(row=0;row<S.height;row++)",
          "1058:                 {",
          "1059:                     for(col=0;col<S.width;col++)",
          "1060:                         {",
          "1061:                             int r,c;",
          "1062:                             if (libraw_internal_data.unpacker_data.fuji_layout) {",
          "1063:                                 r = IO.fuji_width - 1 - col + (row >> 1);",
          "1064:                                 c = col + ((row+1) >> 1);",
          "1065:                             } else {",
          "1066:                                 r = IO.fuji_width - 1 + row - (col >> 1);",
          "1067:                                 c = row + ((col+1) >> 1);",
          "1068:                             }",
          "1070:                             int val = imgdata.rawdata.raw_image[(row+S.top_margin)*S.raw_width",
          "1071:                                                             +(col+S.left_margin)];",
          "1072:                             int cc = FCF(row,col);",
          "1073:                             if(val > cblk[cc])",
          "1074:                                 val -= cblk[cc];",
          "1075:                             else",
          "1076:                                 val = 0;",
          "1077:                             imgdata.image[((r) >> IO.shrink)*fiwidth + ((c) >> IO.shrink)][cc] = val;",
          "1078:                             if(C.channel_maximum[cc] < val) C.channel_maximum[cc] = val;",
          "1079:                         }",
          "1080:                 }",
          "1081:             C.maximum -= C.black;",
          "1082:             ZERO(C.cblack);",
          "1083:             C.black = 0;",
          "1086:             S.height = IO.fheight;",
          "1087:             S.width = IO.fwidth;",
          "1088:             S.iheight = (S.height + IO.shrink) >> IO.shrink;",
          "1089:             S.iwidth  = (S.width  + IO.shrink) >> IO.shrink;",
          "1090:             S.raw_height -= 2*S.top_margin;",
          "1091:         }",
          "1092:     else",
          "1093:         {",
          "1095:                 if(imgdata.image)",
          "1096:                     {",
          "1097:                         imgdata.image = (ushort (*)[4]) realloc (imgdata.image,S.iheight*S.iwidth",
          "1099:                         memset(imgdata.image,0,S.iheight*S.iwidth *sizeof (*imgdata.image));",
          "1100:                     }",
          "1101:                 else",
          "1102:                     imgdata.image = (ushort (*)[4]) calloc (S.iheight*S.iwidth, sizeof (*imgdata.image));",
          "1104:                 merror (imgdata.image, \"raw2image_ex()\");",
          "1106:                 libraw_decoder_info_t decoder_info;",
          "1107:                 get_decoder_info(&decoder_info);",
          "1110:                 if(decoder_info.decoder_flags & LIBRAW_DECODER_FLATFIELD)",
          "1111:                     {",
          "1112:                         if(decoder_info.decoder_flags & LIBRAW_DECODER_USEBAYER2)",
          "1113: #if defined(LIBRAW_USE_OPENMP)",
          "1114: #pragma omp parallel for default(shared)",
          "1115: #endif",
          "1116:                             for(int row = 0; row < S.height; row++)",
          "1117:                                 for(int col = 0; col < S.width; col++)",
          "1118:                                     imgdata.image[(row >> IO.shrink)*S.iwidth + (col>>IO.shrink)][fcol(row,col)]",
          "1119:                                         = imgdata.rawdata.raw_image[(row+S.top_margin)*S.raw_width",
          "1120:                                                                     +(col+S.left_margin)];",
          "1121:                         else",
          "1122: #if defined(LIBRAW_USE_OPENMP)",
          "1123: #pragma omp parallel for default(shared)",
          "1124: #endif",
          "1125:                             for(int row = 0; row < S.height; row++)",
          "1126:                                 {",
          "1127:                                     int colors[2];",
          "1128:                                     for (int xx=0;xx<2;xx++)",
          "1129:                                         colors[xx] = COLOR(row,xx);",
          "1130:                                     for(int col = 0; col < S.width; col++)",
          "1131:                                         {",
          "1132:                                             int cc = colors[col&1];",
          "1133:                                             imgdata.image[(row >> IO.shrink)*S.iwidth + (col>>IO.shrink)][cc] =",
          "1134:                                                 imgdata.rawdata.raw_image[(row+S.top_margin)*S.raw_width",
          "1135:                                                                           +(col+S.left_margin)];",
          "1136:                                         }",
          "1137:                                 }",
          "1138:                     }",
          "1139:                 else if(decoder_info.decoder_flags & LIBRAW_DECODER_LEGACY)",
          "1140:                     {",
          "1141:                         if(do_crop)",
          "1142: #if defined(LIBRAW_USE_OPENMP)",
          "1143: #pragma omp parallel for default(shared)",
          "1144: #endif",
          "1145:                             for(int row = 0; row < S.height; row++)",
          "1146:                                 memmove(&imgdata.image[row*S.width],",
          "1147:                                         &imgdata.rawdata.color_image[(row+S.top_margin)*save_width+S.left_margin],",
          "1148:                                         S.width*sizeof(*imgdata.image));",
          "1150:                         else",
          "1151:                             memmove(imgdata.image,imgdata.rawdata.color_image,",
          "1152:                                     S.width*S.height*sizeof(*imgdata.image));",
          "1153:                     }",
          "1154:             }",
          "1155:     return LIBRAW_SUCCESS;",
          "1156: }",
          "1158: #undef MIN",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1186:         if(decoder_info.decoder_flags & LIBRAW_DECODER_FLATFIELD)",
          "1187:             {",
          "1211:                     }",
          "1212:             }",
          "1214:         else if(decoder_info.decoder_flags & LIBRAW_DECODER_LEGACY)",
          "1215:             {",
          "",
          "[Removed Lines]",
          "1188:                 if(decoder_info.decoder_flags & LIBRAW_DECODER_USEBAYER2)",
          "1189:                     {",
          "1190:                         for(int row = 0; row < S.height; row++)",
          "1191:                             for(int col = 0; col < S.width; col++)",
          "1192:                                 imgdata.image[(row >> IO.shrink)*S.iwidth + (col>>IO.shrink)][fcol(row,col)]",
          "1193:                                 = imgdata.rawdata.raw_image[(row+S.top_margin)*S.raw_width",
          "1194:                                                                            +(col+S.left_margin)];",
          "1195:                     }",
          "1196:                 else",
          "1197:                     {",
          "1198:                         for(int row = 0; row < S.height; row++)",
          "1199:                             {",
          "1200:                                 int colors[4];",
          "1201:                                 for (int xx=0;xx<4;xx++)",
          "1202:                                     colors[xx] = COLOR(row,xx);",
          "1203:                                 for(int col = 0; col < S.width; col++)",
          "1204:                                     {",
          "1205:                                         int cc = colors[col&3];",
          "1206:                                         imgdata.image[(row >> IO.shrink)*S.iwidth + (col>>IO.shrink)][cc] =",
          "1207:                                             imgdata.rawdata.raw_image[(row+S.top_margin)*S.raw_width+(col",
          "1208:                                                                                                       +S.left_margin)];",
          "1209:                                     }",
          "1210:                             }",
          "",
          "[Added Lines]",
          "986:               if (IO.fuji_width) {",
          "987:                 unsigned r,c;",
          "988:                 int row,col;",
          "989:                 for (row=0; row < S.raw_height-S.top_margin*2; row++) {",
          "990:                   for (col=0; col < IO.fuji_width << !libraw_internal_data.unpacker_data.fuji_layout; col++) {",
          "991:                     if (libraw_internal_data.unpacker_data.fuji_layout) {",
          "992:                       r = IO.fuji_width - 1 - col + (row >> 1);",
          "993:                       c = col + ((row+1) >> 1);",
          "994:                     } else {",
          "995:                       r = IO.fuji_width - 1 + row - (col >> 1);",
          "996:                       c = row + ((col+1) >> 1);",
          "998:                     if (r < S.height && c < S.width)",
          "999:                       imgdata.image[((r)>>IO.shrink)*S.iwidth+((c)>>IO.shrink)][FC(r,c)]",
          "1000:                         = imgdata.rawdata.raw_image[(row+S.top_margin)*S.raw_width+(col+S.left_margin)];",
          "1001:                   }",
          "1002:                 }",
          "1003:               }",
          "1004:               else {",
          "1005:                 int row,col;",
          "1006:                 for (row=0; row < S.height; row++)",
          "1007:                   for (col=0; col < S.width; col++)",
          "1008:                     imgdata.image[((row) >> IO.shrink)*S.iwidth + ((col) >> IO.shrink)][fcol(row,col)]",
          "1009:                         = imgdata.rawdata.raw_image[(row+S.top_margin)*S.raw_width+(col+S.left_margin)];",
          "1010:               }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1797:         {",
          "1798:             if (IO.fuji_width)",
          "1799:                 {",
          "1811:                     IO.fuji_width = (IO.fuji_width - 1 + IO.shrink) >> IO.shrink;",
          "1812:                     S.iwidth = (ushort)(IO.fuji_width / sqrt(0.5));",
          "1813:                     S.iheight = (ushort)( (S.iheight - IO.fuji_width) / sqrt(0.5));",
          "",
          "[Removed Lines]",
          "1801:                     if(IO.fheight)",
          "1802:                         {",
          "1803:                             S.height = IO.fheight;",
          "1804:                             S.width = IO.fwidth;",
          "1805:                             S.iheight = (S.height + IO.shrink) >> IO.shrink;",
          "1806:                             S.iwidth  = (S.width  + IO.shrink) >> IO.shrink;",
          "1807:                             S.raw_height -= 2*S.top_margin;",
          "1808:                             IO.fheight = IO.fwidth = 0; // prevent repeated calls",
          "1809:                         }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1833: void LibRaw::subtract_black()",
          "1834: {",
          "1836: #define BAYERC(row,col,c) imgdata.image[((row) >> IO.shrink)*S.iwidth + ((col) >> IO.shrink)][c]",
          "1838:     if((C.black || C.cblack[0] || C.cblack[1] || C.cblack[2] || C.cblack[3]))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1622: #if 0",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1845:             for(row=0;row<S.height;row++)",
          "1846:                 for(col=0;col<S.width;col++)",
          "1847:                     {",
          "1849:                         val = BAYERC(row,col,cc);",
          "1850:                         if(val > cblk[cc])",
          "1851:                             val -= cblk[cc];",
          "",
          "[Removed Lines]",
          "1848:                         cc=COLOR(row,col);",
          "",
          "[Added Lines]",
          "1635:                         cc=fcol(row,col);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1874:         }",
          "1875: #undef BAYERC",
          "1876: }",
          "1878: #define TBLN 65535",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1663: #endif",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1993:         int no_crop = 1;",
          "1995:         if (~O.cropbox[2] && ~O.cropbox[3])",
          "1996:             no_crop=0;",
          "2000:         int save_4color = O.four_color_rgb;",
          "",
          "[Removed Lines]",
          "1998:         raw2image_ex(); // raw2image+crop+rotate_fuji_raw + subtract_black for fuji",
          "",
          "[Added Lines]",
          "1783: #if 0",
          "1786: #endif",
          "1787:         raw2image(); // allocate imgdata.image and copy data!",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "2005:                 SET_PROC_FLAG(LIBRAW_PROGRESS_REMOVE_ZEROES);",
          "2006:             }",
          "2011:         if(O.half_size)",
          "2012:             O.four_color_rgb = 1;",
          "",
          "[Removed Lines]",
          "2008:         if(!IO.fuji_width) // PhaseOne only, all other cases handled at raw2image_ex()",
          "2009:             subtract_black();",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "2033:         if (O.user_qual >= 0) quality = O.user_qual;",
          "2035:         adjust_maximum();",
          "2037:         if (O.user_sat > 0) C.maximum = O.user_sat;",
          "2039:         if (P1.is_foveon)",
          "2040:             {",
          "2041:                 foveon_interpolate();",
          "2042:                 SET_PROC_FLAG(LIBRAW_PROGRESS_FOVEON_INTERPOLATE);",
          "2043:             }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1821: #if 1",
          "1822:         i = C.cblack[3];",
          "1823:         int c;",
          "1824:         for(c=0;c<3;c++) if (i > C.cblack[c]) i = C.cblack[c];",
          "1825:         for(c=0;c<4;c++) C.cblack[c] -= i;",
          "1826:         C.black += i;",
          "1827:         if (O.user_black >= 0) C.black = O.user_black;",
          "1828:         for(c=0;c<4;c++) C.cblack[c] += C.black;",
          "1830: #else",
          "1831:         subtract_black();",
          "1832: #endif",
          "1840:               if(load_raw == &LibRaw::foveon_dp_load_raw)",
          "1841:                 {",
          "1842:                   for (int i=0; i < S.height*S.width*4; i++)",
          "1843:                     if ((short) imgdata.image[0][i] < 0) imgdata.image[0][i] = 0;",
          "1844:                 }",
          "1845:               else",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "2078:                 if (quality == 0)",
          "2079:                     lin_interpolate();",
          "2081:                     vng_interpolate();",
          "2082:                 else if (quality == 2)",
          "2083:                     ppg_interpolate();",
          "",
          "[Removed Lines]",
          "2080:                 else if (quality == 1 || P1.colors > 3)",
          "",
          "[Added Lines]",
          "1885:                 else if (quality == 1 || P1.colors > 3 || P1.filters < 1000)",
          "",
          "---------------"
        ]
      }
    }
  ]
}
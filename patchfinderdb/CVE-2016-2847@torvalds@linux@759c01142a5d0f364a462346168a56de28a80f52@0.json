{
  "cve_id": "CVE-2016-2847",
  "cve_desc": "fs/pipe.c in the Linux kernel before 4.5 does not limit the amount of unread data in pipes, which allows local users to cause a denial of service (memory consumption) by creating many pipes with non-default sizes.",
  "repo": "torvalds/linux",
  "patch_hash": "759c01142a5d0f364a462346168a56de28a80f52",
  "patch_info": {
    "commit_hash": "759c01142a5d0f364a462346168a56de28a80f52",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/759c01142a5d0f364a462346168a56de28a80f52",
    "files": [
      "Documentation/sysctl/fs.txt",
      "fs/pipe.c",
      "include/linux/pipe_fs_i.h",
      "include/linux/sched.h",
      "kernel/sysctl.c"
    ],
    "message": "pipe: limit the per-user amount of pages allocated in pipes\n\nOn no-so-small systems, it is possible for a single process to cause an\nOOM condition by filling large pipes with data that are never read. A\ntypical process filling 4000 pipes with 1 MB of data will use 4 GB of\nmemory. On small systems it may be tricky to set the pipe max size to\nprevent this from happening.\n\nThis patch makes it possible to enforce a per-user soft limit above\nwhich new pipes will be limited to a single page, effectively limiting\nthem to 4 kB each, as well as a hard limit above which no new pipes may\nbe created for this user. This has the effect of protecting the system\nagainst memory abuse without hurting other users, and still allowing\npipes to work correctly though with less data at once.\n\nThe limit are controlled by two new sysctls : pipe-user-pages-soft, and\npipe-user-pages-hard. Both may be disabled by setting them to zero. The\ndefault soft limit allows the default number of FDs per process (1024)\nto create pipes of the default size (64kB), thus reaching a limit of 64MB\nbefore starting to create only smaller pipes. With 256 processes limited\nto 1024 FDs each, this results in 1024*64kB + (256*1024 - 1024) * 4kB =\n1084 MB of memory allocated for a user. The hard limit is disabled by\ndefault to avoid breaking existing applications that make intensive use\nof pipes (eg: for splicing).\n\nReported-by: socketpair@gmail.com\nReported-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>\nMitigates: CVE-2013-4312 (Linux 2.0+)\nSuggested-by: Linus Torvalds <torvalds@linux-foundation.org>\nSigned-off-by: Willy Tarreau <w@1wt.eu>\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>",
    "before_after_code_files": [
      "fs/pipe.c||fs/pipe.c",
      "include/linux/pipe_fs_i.h||include/linux/pipe_fs_i.h",
      "include/linux/sched.h||include/linux/sched.h",
      "kernel/sysctl.c||kernel/sysctl.c"
    ]
  },
  "patch_diff": {
    "fs/pipe.c||fs/pipe.c": [
      "File: fs/pipe.c -> fs/pipe.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "39: unsigned int pipe_min_size = PAGE_SIZE;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "44: unsigned long pipe_user_pages_hard;",
      "45: unsigned long pipe_user_pages_soft = PIPE_DEF_BUFFERS * INR_OPEN_CUR;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "583:  return retval;",
      "584: }",
      "586: struct pipe_inode_info *alloc_pipe_info(void)",
      "587: {",
      "588:  struct pipe_inode_info *pipe;",
      "590:  pipe = kzalloc(sizeof(struct pipe_inode_info), GFP_KERNEL);",
      "591:  if (pipe) {",
      "593:   if (pipe->bufs) {",
      "594:    init_waitqueue_head(&pipe->wait);",
      "595:    pipe->r_counter = pipe->w_counter = 1;",
      "597:    mutex_init(&pipe->mutex);",
      "598:    return pipe;",
      "599:   }",
      "600:   kfree(pipe);",
      "601:  }",
      "",
      "[Removed Lines]",
      "592:   pipe->bufs = kzalloc(sizeof(struct pipe_buffer) * PIPE_DEF_BUFFERS, GFP_KERNEL);",
      "596:    pipe->buffers = PIPE_DEF_BUFFERS;",
      "",
      "[Added Lines]",
      "592: static void account_pipe_buffers(struct pipe_inode_info *pipe,",
      "593:                                  unsigned long old, unsigned long new)",
      "594: {",
      "595:  atomic_long_add(new - old, &pipe->user->pipe_bufs);",
      "596: }",
      "598: static bool too_many_pipe_buffers_soft(struct user_struct *user)",
      "599: {",
      "600:  return pipe_user_pages_soft &&",
      "601:         atomic_long_read(&user->pipe_bufs) >= pipe_user_pages_soft;",
      "602: }",
      "604: static bool too_many_pipe_buffers_hard(struct user_struct *user)",
      "605: {",
      "606:  return pipe_user_pages_hard &&",
      "607:         atomic_long_read(&user->pipe_bufs) >= pipe_user_pages_hard;",
      "608: }",
      "616:   unsigned long pipe_bufs = PIPE_DEF_BUFFERS;",
      "617:   struct user_struct *user = get_current_user();",
      "619:   if (!too_many_pipe_buffers_hard(user)) {",
      "620:    if (too_many_pipe_buffers_soft(user))",
      "621:     pipe_bufs = 1;",
      "622:    pipe->bufs = kzalloc(sizeof(struct pipe_buffer) * pipe_bufs, GFP_KERNEL);",
      "623:   }",
      "628:    pipe->buffers = pipe_bufs;",
      "629:    pipe->user = user;",
      "630:    account_pipe_buffers(pipe, 0, pipe_bufs);",
      "634:   free_uid(user);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "607: {",
      "608:  int i;",
      "610:  for (i = 0; i < pipe->buffers; i++) {",
      "611:   struct pipe_buffer *buf = pipe->bufs + i;",
      "612:   if (buf->ops)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "645:  account_pipe_buffers(pipe, pipe->buffers, 0);",
      "646:  free_uid(pipe->user);",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "998:    memcpy(bufs + head, pipe->bufs, tail * sizeof(struct pipe_buffer));",
      "999:  }",
      "1001:  pipe->curbuf = 0;",
      "1002:  kfree(pipe->bufs);",
      "1003:  pipe->bufs = bufs;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1038:  account_pipe_buffers(pipe, pipe->buffers, nr_pages);",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "1069:   if (!capable(CAP_SYS_RESOURCE) && size > pipe_max_size) {",
      "1070:    ret = -EPERM;",
      "1071:    goto out;",
      "1072:   }",
      "1073:   ret = pipe_set_size(pipe, nr_pages);",
      "1074:   break;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1110:   } else if ((too_many_pipe_buffers_hard(pipe->user) ||",
      "1111:        too_many_pipe_buffers_soft(pipe->user)) &&",
      "1112:              !capable(CAP_SYS_RESOURCE) && !capable(CAP_SYS_ADMIN)) {",
      "1113:    ret = -EPERM;",
      "1114:    goto out;",
      "",
      "---------------"
    ],
    "include/linux/pipe_fs_i.h||include/linux/pipe_fs_i.h": [
      "File: include/linux/pipe_fs_i.h -> include/linux/pipe_fs_i.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "57:  struct fasync_struct *fasync_readers;",
      "58:  struct fasync_struct *fasync_writers;",
      "59:  struct pipe_buffer *bufs;",
      "60: };",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "61:  struct user_struct *user;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "123: void pipe_double_lock(struct pipe_inode_info *, struct pipe_inode_info *);",
      "125: extern unsigned int pipe_max_size, pipe_min_size;",
      "126: int pipe_proc_fn(struct ctl_table *, int, void __user *, size_t *, loff_t *);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "128: extern unsigned long pipe_user_pages_hard;",
      "129: extern unsigned long pipe_user_pages_soft;",
      "",
      "---------------"
    ],
    "include/linux/sched.h||include/linux/sched.h": [
      "File: include/linux/sched.h -> include/linux/sched.h"
    ],
    "kernel/sysctl.c||kernel/sysctl.c": [
      "File: kernel/sysctl.c -> kernel/sysctl.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1757:   .proc_handler = &pipe_proc_fn,",
      "1758:   .extra1  = &pipe_min_size,",
      "1759:  },",
      "1760:  { }",
      "1761: };",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1760:  {",
      "1761:   .procname = \"pipe-user-pages-hard\",",
      "1762:   .data  = &pipe_user_pages_hard,",
      "1763:   .maxlen  = sizeof(pipe_user_pages_hard),",
      "1764:   .mode  = 0644,",
      "1765:   .proc_handler = proc_doulongvec_minmax,",
      "1766:  },",
      "1767:  {",
      "1768:   .procname = \"pipe-user-pages-soft\",",
      "1769:   .data  = &pipe_user_pages_soft,",
      "1770:   .maxlen  = sizeof(pipe_user_pages_soft),",
      "1771:   .mode  = 0644,",
      "1772:   .proc_handler = proc_doulongvec_minmax,",
      "1773:  },",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "3734a13b96ebf039b293d8d37a934fd1bd9e03ab",
      "candidate_info": {
        "commit_hash": "3734a13b96ebf039b293d8d37a934fd1bd9e03ab",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/3734a13b96ebf039b293d8d37a934fd1bd9e03ab",
        "files": [
          "fs/pipe.c"
        ],
        "message": "pipe: refactor argument for account_pipe_buffers()\n\nThis is a preparatory patch for following work. account_pipe_buffers()\nperforms accounting in the 'user_struct'. There is no need to pass a\npointer to a 'pipe_inode_info' struct (which is then dereferenced to\nobtain a pointer to the 'user' field). Instead, pass a pointer directly\nto the 'user_struct'. This change is needed in preparation for a\nsubsequent patch that the fixes the limit checking in alloc_pipe_info()\n(and the resulting code is a little more logical).\n\nLink: http://lkml.kernel.org/r/7277bf8c-a6fc-4a7d-659c-f5b145c981ab@gmail.com\nSigned-off-by: Michael Kerrisk <mtk.manpages@gmail.com>\nReviewed-by: Vegard Nossum <vegard.nossum@oracle.com>\nCc: Willy Tarreau <w@1wt.eu>\nCc: <socketpair@gmail.com>\nCc: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>\nCc: Jens Axboe <axboe@fb.com>\nCc: Al Viro <viro@zeniv.linux.org.uk>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "fs/pipe.c||fs/pipe.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/pipe.c||fs/pipe.c"
          ],
          "candidate": [
            "fs/pipe.c||fs/pipe.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/pipe.c||fs/pipe.c": [
          "File: fs/pipe.c -> fs/pipe.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "601:  return retval;",
          "602: }",
          "605:                                  unsigned long old, unsigned long new)",
          "606: {",
          "608: }",
          "610: static bool too_many_pipe_buffers_soft(struct user_struct *user)",
          "",
          "[Removed Lines]",
          "604: static void account_pipe_buffers(struct pipe_inode_info *pipe,",
          "607:  atomic_long_add(new - old, &pipe->user->pipe_bufs);",
          "",
          "[Added Lines]",
          "604: static void account_pipe_buffers(struct user_struct *user,",
          "607:  atomic_long_add(new - old, &user->pipe_bufs);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "641:    pipe->r_counter = pipe->w_counter = 1;",
          "642:    pipe->buffers = pipe_bufs;",
          "643:    pipe->user = user;",
          "645:    mutex_init(&pipe->mutex);",
          "646:    return pipe;",
          "647:   }",
          "",
          "[Removed Lines]",
          "644:    account_pipe_buffers(pipe, 0, pipe_bufs);",
          "",
          "[Added Lines]",
          "644:    account_pipe_buffers(user, 0, pipe_bufs);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "656: {",
          "657:  int i;",
          "660:  free_uid(pipe->user);",
          "661:  for (i = 0; i < pipe->buffers; i++) {",
          "662:   struct pipe_buffer *buf = pipe->bufs + i;",
          "",
          "[Removed Lines]",
          "659:  account_pipe_buffers(pipe, pipe->buffers, 0);",
          "",
          "[Added Lines]",
          "659:  account_pipe_buffers(pipe->user, pipe->buffers, 0);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1077:    memcpy(bufs + head, pipe->bufs, tail * sizeof(struct pipe_buffer));",
          "1078:  }",
          "1081:  pipe->curbuf = 0;",
          "1082:  kfree(pipe->bufs);",
          "1083:  pipe->bufs = bufs;",
          "",
          "[Removed Lines]",
          "1080:  account_pipe_buffers(pipe, pipe->buffers, nr_pages);",
          "",
          "[Added Lines]",
          "1080:  account_pipe_buffers(pipe->user, pipe->buffers, nr_pages);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "d37d41666408102bf0ac8e48d8efdce7b809e5f6",
      "candidate_info": {
        "commit_hash": "d37d41666408102bf0ac8e48d8efdce7b809e5f6",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/d37d41666408102bf0ac8e48d8efdce7b809e5f6",
        "files": [
          "fs/pipe.c"
        ],
        "message": "pipe: move limit checking logic into pipe_set_size()\n\nThis is a preparatory patch for following work. Move the F_SETPIPE_SZ\nlimit-checking logic from pipe_fcntl() into pipe_set_size().  This\nsimplifies the code a little, and allows for reworking required in\na later patch that fixes the limit checking in pipe_set_size()\n\nLink: http://lkml.kernel.org/r/3701b2c5-2c52-2c3e-226d-29b9deb29b50@gmail.com\nSigned-off-by: Michael Kerrisk <mtk.manpages@gmail.com>\nReviewed-by: Vegard Nossum <vegard.nossum@oracle.com>\nCc: Willy Tarreau <w@1wt.eu>\nCc: <socketpair@gmail.com>\nCc: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>\nCc: Jens Axboe <axboe@fb.com>\nCc: Al Viro <viro@zeniv.linux.org.uk>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "fs/pipe.c||fs/pipe.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/pipe.c||fs/pipe.c"
          ],
          "candidate": [
            "fs/pipe.c||fs/pipe.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/pipe.c||fs/pipe.c": [
          "File: fs/pipe.c -> fs/pipe.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1027: {",
          "1028:  struct pipe_buffer *bufs;",
          "",
          "[Removed Lines]",
          "1026: static long pipe_set_size(struct pipe_inode_info *pipe, unsigned long nr_pages)",
          "",
          "[Added Lines]",
          "1026: static long pipe_set_size(struct pipe_inode_info *pipe, unsigned long arg)",
          "1029:  unsigned int size, nr_pages;",
          "1031:  size = round_pipe_size(arg);",
          "1032:  nr_pages = size >> PAGE_SHIFT;",
          "1034:  if (!nr_pages)",
          "1035:   return -EINVAL;",
          "1037:  if (!capable(CAP_SYS_RESOURCE) && size > pipe_max_size)",
          "1038:   return -EPERM;",
          "1040:  if ((too_many_pipe_buffers_hard(pipe->user) ||",
          "1041:    too_many_pipe_buffers_soft(pipe->user)) &&",
          "1042:    !capable(CAP_SYS_RESOURCE) && !capable(CAP_SYS_ADMIN))",
          "1043:   return -EPERM;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1109:  __pipe_lock(pipe);",
          "1111:  switch (cmd) {",
          "1132:   break;",
          "1134:  case F_GETPIPE_SZ:",
          "1135:   ret = pipe->buffers * PAGE_SIZE;",
          "1136:   break;",
          "",
          "[Removed Lines]",
          "1112:  case F_SETPIPE_SZ: {",
          "1113:   unsigned int size, nr_pages;",
          "1115:   size = round_pipe_size(arg);",
          "1116:   nr_pages = size >> PAGE_SHIFT;",
          "1118:   ret = -EINVAL;",
          "1119:   if (!nr_pages)",
          "1120:    goto out;",
          "1122:   if (!capable(CAP_SYS_RESOURCE) && size > pipe_max_size) {",
          "1123:    ret = -EPERM;",
          "1124:    goto out;",
          "1125:   } else if ((too_many_pipe_buffers_hard(pipe->user) ||",
          "1126:        too_many_pipe_buffers_soft(pipe->user)) &&",
          "1127:              !capable(CAP_SYS_RESOURCE) && !capable(CAP_SYS_ADMIN)) {",
          "1128:    ret = -EPERM;",
          "1129:    goto out;",
          "1130:   }",
          "1131:   ret = pipe_set_size(pipe, nr_pages);",
          "1133:   }",
          "",
          "[Added Lines]",
          "1127:  case F_SETPIPE_SZ:",
          "1128:   ret = pipe_set_size(pipe, arg);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1139:   break;",
          "1140:  }",
          "1143:  __pipe_unlock(pipe);",
          "1144:  return ret;",
          "1145: }",
          "",
          "[Removed Lines]",
          "1142: out:",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "9c87bcf0a31b338dc8a69a5d251a037565a94e13",
      "candidate_info": {
        "commit_hash": "9c87bcf0a31b338dc8a69a5d251a037565a94e13",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/9c87bcf0a31b338dc8a69a5d251a037565a94e13",
        "files": [
          "fs/pipe.c"
        ],
        "message": "pipe: make account_pipe_buffers() return a value, and use it\n\nThis is an optional patch, to provide a small performance\nimprovement.  Alter account_pipe_buffers() so that it returns the\nnew value in user->pipe_bufs. This means that we can refactor\ntoo_many_pipe_buffers_soft() and too_many_pipe_buffers_hard() to\navoid the costs of repeated use of atomic_long_read() to get the\nvalue user->pipe_bufs.\n\nLink: http://lkml.kernel.org/r/93e5f193-1e5e-3e1f-3a20-eae79b7e1310@gmail.com\nSigned-off-by: Michael Kerrisk <mtk.manpages@gmail.com>\nReviewed-by: Vegard Nossum <vegard.nossum@oracle.com>\nCc: Willy Tarreau <w@1wt.eu>\nCc: <socketpair@gmail.com>\nCc: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>\nCc: Jens Axboe <axboe@fb.com>\nCc: Al Viro <viro@zeniv.linux.org.uk>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "fs/pipe.c||fs/pipe.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/pipe.c||fs/pipe.c"
          ],
          "candidate": [
            "fs/pipe.c||fs/pipe.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/pipe.c||fs/pipe.c": [
          "File: fs/pipe.c -> fs/pipe.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "601:  return retval;",
          "602: }",
          "605:                                  unsigned long old, unsigned long new)",
          "606: {",
          "608: }",
          "611: {",
          "614: }",
          "617: {",
          "620: }",
          "622: struct pipe_inode_info *alloc_pipe_info(void)",
          "",
          "[Removed Lines]",
          "604: static void account_pipe_buffers(struct user_struct *user,",
          "607:  atomic_long_add(new - old, &user->pipe_bufs);",
          "610: static bool too_many_pipe_buffers_soft(struct user_struct *user)",
          "612:  return pipe_user_pages_soft &&",
          "613:         atomic_long_read(&user->pipe_bufs) >= pipe_user_pages_soft;",
          "616: static bool too_many_pipe_buffers_hard(struct user_struct *user)",
          "618:  return pipe_user_pages_hard &&",
          "619:         atomic_long_read(&user->pipe_bufs) >= pipe_user_pages_hard;",
          "",
          "[Added Lines]",
          "604: static unsigned long account_pipe_buffers(struct user_struct *user,",
          "607:  return atomic_long_add_return(new - old, &user->pipe_bufs);",
          "610: static bool too_many_pipe_buffers_soft(unsigned long user_bufs)",
          "612:  return pipe_user_pages_soft && user_bufs >= pipe_user_pages_soft;",
          "615: static bool too_many_pipe_buffers_hard(unsigned long user_bufs)",
          "617:  return pipe_user_pages_hard && user_bufs >= pipe_user_pages_hard;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "624:  struct pipe_inode_info *pipe;",
          "625:  unsigned long pipe_bufs = PIPE_DEF_BUFFERS;",
          "626:  struct user_struct *user = get_current_user();",
          "628:  pipe = kzalloc(sizeof(struct pipe_inode_info), GFP_KERNEL_ACCOUNT);",
          "629:  if (pipe == NULL)",
          "630:   goto out_free_uid;",
          "636:   pipe_bufs = 1;",
          "637:  }",
          "640:   goto out_revert_acct;",
          "642:  pipe->bufs = kcalloc(pipe_bufs, sizeof(struct pipe_buffer),",
          "",
          "[Removed Lines]",
          "632:  account_pipe_buffers(user, 0, pipe_bufs);",
          "634:  if (too_many_pipe_buffers_soft(user)) {",
          "635:   account_pipe_buffers(user, pipe_bufs, 1);",
          "639:  if (too_many_pipe_buffers_hard(user))",
          "",
          "[Added Lines]",
          "625:  unsigned long user_bufs;",
          "631:  user_bufs = account_pipe_buffers(user, 0, pipe_bufs);",
          "633:  if (too_many_pipe_buffers_soft(user_bufs)) {",
          "634:   user_bufs = account_pipe_buffers(user, pipe_bufs, 1);",
          "638:  if (too_many_pipe_buffers_hard(user_bufs))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "652:  }",
          "654: out_revert_acct:",
          "656:  kfree(pipe);",
          "657: out_free_uid:",
          "658:  free_uid(user);",
          "",
          "[Removed Lines]",
          "655:  account_pipe_buffers(user, pipe_bufs, 0);",
          "",
          "[Added Lines]",
          "654:  (void) account_pipe_buffers(user, pipe_bufs, 0);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "663: {",
          "664:  int i;",
          "667:  free_uid(pipe->user);",
          "668:  for (i = 0; i < pipe->buffers; i++) {",
          "669:   struct pipe_buffer *buf = pipe->bufs + i;",
          "",
          "[Removed Lines]",
          "666:  account_pipe_buffers(pipe->user, pipe->buffers, 0);",
          "",
          "[Added Lines]",
          "665:  (void) account_pipe_buffers(pipe->user, pipe->buffers, 0);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1034: {",
          "1035:  struct pipe_buffer *bufs;",
          "1036:  unsigned int size, nr_pages;",
          "1037:  long ret = 0;",
          "1039:  size = round_pipe_size(arg);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1036:  unsigned long user_bufs;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1053:    size > pipe_max_size && !capable(CAP_SYS_RESOURCE))",
          "1054:   return -EPERM;",
          "1058:  if (nr_pages > pipe->buffers &&",
          "1061:    !capable(CAP_SYS_RESOURCE) && !capable(CAP_SYS_ADMIN)) {",
          "1062:   ret = -EPERM;",
          "1063:   goto out_revert_acct;",
          "",
          "[Removed Lines]",
          "1056:  account_pipe_buffers(pipe->user, pipe->buffers, nr_pages);",
          "1059:    (too_many_pipe_buffers_hard(pipe->user) ||",
          "1060:     too_many_pipe_buffers_soft(pipe->user)) &&",
          "",
          "[Added Lines]",
          "1056:  user_bufs = account_pipe_buffers(pipe->user, pipe->buffers, nr_pages);",
          "1059:    (too_many_pipe_buffers_hard(user_bufs) ||",
          "1060:     too_many_pipe_buffers_soft(user_bufs)) &&",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1109:  return nr_pages * PAGE_SIZE;",
          "1111: out_revert_acct:",
          "1113:  return ret;",
          "1114: }",
          "",
          "[Removed Lines]",
          "1112:  account_pipe_buffers(pipe->user, nr_pages, pipe->buffers);",
          "",
          "[Added Lines]",
          "1112:  (void) account_pipe_buffers(pipe->user, nr_pages, pipe->buffers);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "09b4d1990094dd22c27fb0163534db419458569c",
      "candidate_info": {
        "commit_hash": "09b4d1990094dd22c27fb0163534db419458569c",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/09b4d1990094dd22c27fb0163534db419458569c",
        "files": [
          "fs/pipe.c"
        ],
        "message": "pipe: simplify logic in alloc_pipe_info()\n\nReplace an 'if' block that covers most of the code in this function\nwith a 'goto'. This makes the code a little simpler to read, and also\nsimplifies the next patch (fix limit checking in alloc_pipe_info())\n\nLink: http://lkml.kernel.org/r/aef030c1-0257-98a9-4988-186efa48530c@gmail.com\nSigned-off-by: Michael Kerrisk <mtk.manpages@gmail.com>\nReviewed-by: Vegard Nossum <vegard.nossum@oracle.com>\nCc: Willy Tarreau <w@1wt.eu>\nCc: <socketpair@gmail.com>\nCc: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>\nCc: Jens Axboe <axboe@fb.com>\nCc: Al Viro <viro@zeniv.linux.org.uk>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "fs/pipe.c||fs/pipe.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/pipe.c||fs/pipe.c"
          ],
          "candidate": [
            "fs/pipe.c||fs/pipe.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/pipe.c||fs/pipe.c": [
          "File: fs/pipe.c -> fs/pipe.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "622: struct pipe_inode_info *alloc_pipe_info(void)",
          "623: {",
          "624:  struct pipe_inode_info *pipe;",
          "626:  pipe = kzalloc(sizeof(struct pipe_inode_info), GFP_KERNEL_ACCOUNT);",
          "650:  }",
          "652:  return NULL;",
          "653: }",
          "",
          "[Removed Lines]",
          "627:  if (pipe) {",
          "628:   unsigned long pipe_bufs = PIPE_DEF_BUFFERS;",
          "629:   struct user_struct *user = get_current_user();",
          "631:   if (!too_many_pipe_buffers_hard(user)) {",
          "632:    if (too_many_pipe_buffers_soft(user))",
          "633:     pipe_bufs = 1;",
          "634:    pipe->bufs = kcalloc(pipe_bufs,",
          "635:           sizeof(struct pipe_buffer),",
          "636:           GFP_KERNEL_ACCOUNT);",
          "637:   }",
          "639:   if (pipe->bufs) {",
          "640:    init_waitqueue_head(&pipe->wait);",
          "641:    pipe->r_counter = pipe->w_counter = 1;",
          "642:    pipe->buffers = pipe_bufs;",
          "643:    pipe->user = user;",
          "644:    account_pipe_buffers(user, 0, pipe_bufs);",
          "645:    mutex_init(&pipe->mutex);",
          "646:    return pipe;",
          "647:   }",
          "648:   free_uid(user);",
          "649:   kfree(pipe);",
          "",
          "[Added Lines]",
          "625:  unsigned long pipe_bufs = PIPE_DEF_BUFFERS;",
          "626:  struct user_struct *user = get_current_user();",
          "629:  if (pipe == NULL)",
          "630:   goto out_free_uid;",
          "632:  if (!too_many_pipe_buffers_hard(user)) {",
          "633:   if (too_many_pipe_buffers_soft(user))",
          "634:    pipe_bufs = 1;",
          "635:   pipe->bufs = kcalloc(pipe_bufs,",
          "636:          sizeof(struct pipe_buffer),",
          "637:          GFP_KERNEL_ACCOUNT);",
          "638:  }",
          "640:  if (pipe->bufs) {",
          "641:   init_waitqueue_head(&pipe->wait);",
          "642:   pipe->r_counter = pipe->w_counter = 1;",
          "643:   pipe->buffers = pipe_bufs;",
          "644:   pipe->user = user;",
          "645:   account_pipe_buffers(user, 0, pipe_bufs);",
          "646:   mutex_init(&pipe->mutex);",
          "647:   return pipe;",
          "650:  kfree(pipe);",
          "651: out_free_uid:",
          "652:  free_uid(user);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "d86133bd396f5e4a8d5629c1b853b574de4faf32",
      "candidate_info": {
        "commit_hash": "d86133bd396f5e4a8d5629c1b853b574de4faf32",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/d86133bd396f5e4a8d5629c1b853b574de4faf32",
        "files": [
          "fs/pipe.c"
        ],
        "message": "pipe: account to kmemcg\n\nPipes can consume a significant amount of system memory, hence they\nshould be accounted to kmemcg.\n\nThis patch marks pipe_inode_info and anonymous pipe buffer page\nallocations as __GFP_ACCOUNT so that they would be charged to kmemcg.\nNote, since a pipe buffer page can be \"stolen\" and get reused for other\npurposes, including mapping to userspace, we clear PageKmemcg thus\nresetting page->_mapcount and uncharge it in anon_pipe_buf_steal, which\nis introduced by this patch.\n\nA note regarding anon_pipe_buf_steal implementation.  We allow to steal\nthe page if its ref count equals 1.  It looks racy, but it is correct\nfor anonymous pipe buffer pages, because:\n\n - We lock out all other pipe users, because ->steal is called with\n   pipe_lock held, so the page can't be spliced to another pipe from\n   under us.\n\n - The page is not on LRU and it never was.\n\n - Thus a parallel thread can access it only by PFN. Although this is\n   quite possible (e.g. see page_idle_get_page and balloon_page_isolate)\n   this is not dangerous, because all such functions do is increase page\n   ref count, check if the page is the one they are looking for, and\n   decrease ref count if it isn't. Since our page is clean except for\n   PageKmemcg mark, which doesn't conflict with other _mapcount users,\n   the worst that can happen is we see page_count > 2 due to a transient\n   ref, in which case we false-positively abort ->steal, which is still\n   fine, because ->steal is not guaranteed to succeed.\n\nLink: http://lkml.kernel.org/r/20160527150313.GD26059@esperanza\nSigned-off-by: Vladimir Davydov <vdavydov@virtuozzo.com>\nCc: Alexander Viro <viro@zeniv.linux.org.uk>\nCc: Johannes Weiner <hannes@cmpxchg.org>\nCc: Michal Hocko <mhocko@kernel.org>\nCc: Eric Dumazet <eric.dumazet@gmail.com>\nCc: Minchan Kim <minchan@kernel.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "fs/pipe.c||fs/pipe.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/pipe.c||fs/pipe.c"
          ],
          "candidate": [
            "fs/pipe.c||fs/pipe.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/pipe.c||fs/pipe.c": [
          "File: fs/pipe.c -> fs/pipe.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "21: #include <linux/audit.h>",
          "22: #include <linux/syscalls.h>",
          "23: #include <linux/fcntl.h>",
          "25: #include <asm/uaccess.h>",
          "26: #include <asm/ioctls.h>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "24: #include <linux/memcontrol.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "137:   put_page(page);",
          "138: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "141: static int anon_pipe_buf_steal(struct pipe_inode_info *pipe,",
          "142:           struct pipe_buffer *buf)",
          "143: {",
          "144:  struct page *page = buf->page;",
          "146:  if (page_count(page) == 1) {",
          "147:   if (memcg_kmem_enabled()) {",
          "148:    memcg_kmem_uncharge(page, 0);",
          "149:    __ClearPageKmemcg(page);",
          "150:   }",
          "151:   __SetPageLocked(page);",
          "152:   return 0;",
          "153:  }",
          "154:  return 1;",
          "155: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "219:  .can_merge = 1,",
          "220:  .confirm = generic_pipe_buf_confirm,",
          "221:  .release = anon_pipe_buf_release,",
          "223:  .get = generic_pipe_buf_get,",
          "224: };",
          "",
          "[Removed Lines]",
          "222:  .steal = generic_pipe_buf_steal,",
          "",
          "[Added Lines]",
          "239:  .steal = anon_pipe_buf_steal,",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "227:  .can_merge = 0,",
          "228:  .confirm = generic_pipe_buf_confirm,",
          "229:  .release = anon_pipe_buf_release,",
          "231:  .get = generic_pipe_buf_get,",
          "232: };",
          "",
          "[Removed Lines]",
          "230:  .steal = generic_pipe_buf_steal,",
          "",
          "[Added Lines]",
          "247:  .steal = anon_pipe_buf_steal,",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "405:    int copied;",
          "407:    if (!page) {",
          "409:     if (unlikely(!page)) {",
          "410:      ret = ret ? : -ENOMEM;",
          "411:      break;",
          "",
          "[Removed Lines]",
          "408:     page = alloc_page(GFP_HIGHUSER);",
          "",
          "[Added Lines]",
          "425:     page = alloc_page(GFP_HIGHUSER | __GFP_ACCOUNT);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "611: {",
          "612:  struct pipe_inode_info *pipe;",
          "615:  if (pipe) {",
          "616:   unsigned long pipe_bufs = PIPE_DEF_BUFFERS;",
          "617:   struct user_struct *user = get_current_user();",
          "",
          "[Removed Lines]",
          "614:  pipe = kzalloc(sizeof(struct pipe_inode_info), GFP_KERNEL);",
          "",
          "[Added Lines]",
          "631:  pipe = kzalloc(sizeof(struct pipe_inode_info), GFP_KERNEL_ACCOUNT);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "619:   if (!too_many_pipe_buffers_hard(user)) {",
          "620:    if (too_many_pipe_buffers_soft(user))",
          "621:     pipe_bufs = 1;",
          "623:   }",
          "625:   if (pipe->bufs) {",
          "",
          "[Removed Lines]",
          "622:    pipe->bufs = kzalloc(sizeof(struct pipe_buffer) * pipe_bufs, GFP_KERNEL);",
          "",
          "[Added Lines]",
          "639:    pipe->bufs = kcalloc(pipe_bufs,",
          "640:           sizeof(struct pipe_buffer),",
          "641:           GFP_KERNEL_ACCOUNT);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1010:  if (nr_pages < pipe->nrbufs)",
          "1011:   return -EBUSY;",
          "1014:  if (unlikely(!bufs))",
          "1015:   return -ENOMEM;",
          "",
          "[Removed Lines]",
          "1013:  bufs = kcalloc(nr_pages, sizeof(*bufs), GFP_KERNEL | __GFP_NOWARN);",
          "",
          "[Added Lines]",
          "1032:  bufs = kcalloc(nr_pages, sizeof(*bufs),",
          "1033:          GFP_KERNEL_ACCOUNT | __GFP_NOWARN);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2019-19922",
  "cve_desc": "kernel/sched/fair.c in the Linux kernel before 5.3.9, when cpu.cfs_quota_us is used (e.g., with Kubernetes), allows attackers to cause a denial of service against non-cpu-bound applications by generating a workload that triggers unwanted slice expiration, aka CID-de53fd7aedb1. (In other words, although this slice expiration would typically be seen with benign workloads, it is possible that an attacker could calculate how many stray requests are required to force an entire Kubernetes cluster into a low-performance state caused by slice expiration, and ensure that a DDoS attack sent that number of stray requests. An attack does not affect the stability of the kernel; it only causes mismanagement of application execution.)",
  "repo": "torvalds/linux",
  "patch_hash": "de53fd7aedb100f03e5d2231cfce0e4993282425",
  "patch_info": {
    "commit_hash": "de53fd7aedb100f03e5d2231cfce0e4993282425",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/de53fd7aedb100f03e5d2231cfce0e4993282425",
    "files": [
      "Documentation/scheduler/sched-bwc.rst",
      "kernel/sched/fair.c",
      "kernel/sched/sched.h"
    ],
    "message": "sched/fair: Fix low cpu usage with high throttling by removing expiration of cpu-local slices\n\nIt has been observed, that highly-threaded, non-cpu-bound applications\nrunning under cpu.cfs_quota_us constraints can hit a high percentage of\nperiods throttled while simultaneously not consuming the allocated\namount of quota. This use case is typical of user-interactive non-cpu\nbound applications, such as those running in kubernetes or mesos when\nrun on multiple cpu cores.\n\nThis has been root caused to cpu-local run queue being allocated per cpu\nbandwidth slices, and then not fully using that slice within the period.\nAt which point the slice and quota expires. This expiration of unused\nslice results in applications not being able to utilize the quota for\nwhich they are allocated.\n\nThe non-expiration of per-cpu slices was recently fixed by\n'commit 512ac999d275 (\"sched/fair: Fix bandwidth timer clock drift\ncondition\")'. Prior to that it appears that this had been broken since\nat least 'commit 51f2176d74ac (\"sched/fair: Fix unlocked reads of some\ncfs_b->quota/period\")' which was introduced in v3.16-rc1 in 2014. That\nadded the following conditional which resulted in slices never being\nexpired.\n\nif (cfs_rq->runtime_expires != cfs_b->runtime_expires) {\n\t/* extend local deadline, drift is bounded above by 2 ticks */\n\tcfs_rq->runtime_expires += TICK_NSEC;\n\nBecause this was broken for nearly 5 years, and has recently been fixed\nand is now being noticed by many users running kubernetes\n(https://github.com/kubernetes/kubernetes/issues/67577) it is my opinion\nthat the mechanisms around expiring runtime should be removed\naltogether.\n\nThis allows quota already allocated to per-cpu run-queues to live longer\nthan the period boundary. This allows threads on runqueues that do not\nuse much CPU to continue to use their remaining slice over a longer\nperiod of time than cpu.cfs_period_us. However, this helps prevent the\nabove condition of hitting throttling while also not fully utilizing\nyour cpu quota.\n\nThis theoretically allows a machine to use slightly more than its\nallotted quota in some periods. This overflow would be bounded by the\nremaining quota left on each per-cpu runqueueu. This is typically no\nmore than min_cfs_rq_runtime=1ms per cpu. For CPU bound tasks this will\nchange nothing, as they should theoretically fully utilize all of their\nquota in each period. For user-interactive tasks as described above this\nprovides a much better user/application experience as their cpu\nutilization will more closely match the amount they requested when they\nhit throttling. This means that cpu limits no longer strictly apply per\nperiod for non-cpu bound applications, but that they are still accurate\nover longer timeframes.\n\nThis greatly improves performance of high-thread-count, non-cpu bound\napplications with low cfs_quota_us allocation on high-core-count\nmachines. In the case of an artificial testcase (10ms/100ms of quota on\n80 CPU machine), this commit resulted in almost 30x performance\nimprovement, while still maintaining correct cpu quota restrictions.\nThat testcase is available at https://github.com/indeedeng/fibtest.\n\nFixes: 512ac999d275 (\"sched/fair: Fix bandwidth timer clock drift condition\")\nSigned-off-by: Dave Chiluk <chiluk+linux@indeed.com>\nSigned-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>\nReviewed-by: Phil Auld <pauld@redhat.com>\nReviewed-by: Ben Segall <bsegall@google.com>\nCc: Ingo Molnar <mingo@redhat.com>\nCc: John Hammond <jhammond@indeed.com>\nCc: Jonathan Corbet <corbet@lwn.net>\nCc: Kyle Anderson <kwa@yelp.com>\nCc: Gabriel Munos <gmunoz@netflix.com>\nCc: Peter Oskolkov <posk@posk.io>\nCc: Cong Wang <xiyou.wangcong@gmail.com>\nCc: Brendan Gregg <bgregg@netflix.com>\nLink: https://lkml.kernel.org/r/1563900266-19734-2-git-send-email-chiluk+linux@indeed.com",
    "before_after_code_files": [
      "kernel/sched/fair.c||kernel/sched/fair.c",
      "kernel/sched/sched.h||kernel/sched/sched.h"
    ]
  },
  "patch_diff": {
    "kernel/sched/fair.c||kernel/sched/fair.c": [
      "File: kernel/sched/fair.c -> kernel/sched/fair.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "4372:  now = sched_clock_cpu(smp_processor_id());",
      "4373:  cfs_b->runtime = cfs_b->quota;",
      "4376: }",
      "4378: static inline struct cfs_bandwidth *tg_cfs_bandwidth(struct task_group *tg)",
      "",
      "[Removed Lines]",
      "4374:  cfs_b->runtime_expires = now + ktime_to_ns(cfs_b->period);",
      "4375:  cfs_b->expires_seq++;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "4394: {",
      "4395:  struct task_group *tg = cfs_rq->tg;",
      "4396:  struct cfs_bandwidth *cfs_b = tg_cfs_bandwidth(tg);",
      "4401:  min_amount = sched_cfs_bandwidth_slice() - cfs_rq->runtime_remaining;",
      "",
      "[Removed Lines]",
      "4397:  u64 amount = 0, min_amount, expires;",
      "4398:  int expires_seq;",
      "",
      "[Added Lines]",
      "4395:  u64 amount = 0, min_amount;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "4412:    cfs_b->idle = 0;",
      "4413:   }",
      "4414:  }",
      "4417:  raw_spin_unlock(&cfs_b->lock);",
      "4419:  cfs_rq->runtime_remaining += amount;",
      "4430:  return cfs_rq->runtime_remaining > 0;",
      "4431: }",
      "4465: static void __account_cfs_rq_runtime(struct cfs_rq *cfs_rq, u64 delta_exec)",
      "4466: {",
      "4468:  cfs_rq->runtime_remaining -= delta_exec;",
      "4471:  if (likely(cfs_rq->runtime_remaining > 0))",
      "4472:   return;",
      "",
      "[Removed Lines]",
      "4415:  expires_seq = cfs_b->expires_seq;",
      "4416:  expires = cfs_b->runtime_expires;",
      "4425:  if (cfs_rq->expires_seq != expires_seq) {",
      "4426:   cfs_rq->expires_seq = expires_seq;",
      "4427:   cfs_rq->runtime_expires = expires;",
      "4428:  }",
      "4437: static void expire_cfs_rq_runtime(struct cfs_rq *cfs_rq)",
      "4438: {",
      "4439:  struct cfs_bandwidth *cfs_b = tg_cfs_bandwidth(cfs_rq->tg);",
      "4442:  if (likely((s64)(rq_clock(rq_of(cfs_rq)) - cfs_rq->runtime_expires) < 0))",
      "4443:   return;",
      "4445:  if (cfs_rq->runtime_remaining < 0)",
      "4446:   return;",
      "4456:  if (cfs_rq->expires_seq == cfs_b->expires_seq) {",
      "4458:   cfs_rq->runtime_expires += TICK_NSEC;",
      "4459:  } else {",
      "4461:   cfs_rq->runtime_remaining = 0;",
      "4462:  }",
      "4463: }",
      "4469:  expire_cfs_rq_runtime(cfs_rq);",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "4661:   resched_curr(rq);",
      "4662: }",
      "4666: {",
      "4667:  struct cfs_rq *cfs_rq;",
      "4668:  u64 runtime;",
      "",
      "[Removed Lines]",
      "4664: static u64 distribute_cfs_runtime(struct cfs_bandwidth *cfs_b,",
      "4665:   u64 remaining, u64 expires)",
      "",
      "[Added Lines]",
      "4617: static u64 distribute_cfs_runtime(struct cfs_bandwidth *cfs_b, u64 remaining)",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "4684:   remaining -= runtime;",
      "4686:   cfs_rq->runtime_remaining += runtime;",
      "4690:   if (cfs_rq->runtime_remaining > 0)",
      "",
      "[Removed Lines]",
      "4687:   cfs_rq->runtime_expires = expires;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "4710: static int do_sched_cfs_period_timer(struct cfs_bandwidth *cfs_b, int overrun, unsigned long flags)",
      "4711: {",
      "4713:  int throttled;",
      "",
      "[Removed Lines]",
      "4712:  u64 runtime, runtime_expires;",
      "",
      "[Added Lines]",
      "4663:  u64 runtime;",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "4738:  cfs_b->nr_throttled += overrun;",
      "",
      "[Removed Lines]",
      "4740:  runtime_expires = cfs_b->runtime_expires;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "4751:   cfs_b->distribute_running = 1;",
      "4752:   raw_spin_unlock_irqrestore(&cfs_b->lock, flags);",
      "4756:   raw_spin_lock_irqsave(&cfs_b->lock, flags);",
      "4758:   cfs_b->distribute_running = 0;",
      "",
      "[Removed Lines]",
      "4754:   runtime = distribute_cfs_runtime(cfs_b, runtime,",
      "4755:        runtime_expires);",
      "",
      "[Added Lines]",
      "4703:   runtime = distribute_cfs_runtime(cfs_b, runtime);",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "4834:   return;",
      "4836:  raw_spin_lock(&cfs_b->lock);",
      "4839:   cfs_b->runtime += slack_runtime;",
      "",
      "[Removed Lines]",
      "4837:  if (cfs_b->quota != RUNTIME_INF &&",
      "4838:      cfs_rq->runtime_expires == cfs_b->runtime_expires) {",
      "",
      "[Added Lines]",
      "4785:  if (cfs_b->quota != RUNTIME_INF) {",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "4868: {",
      "4869:  u64 runtime = 0, slice = sched_cfs_bandwidth_slice();",
      "4870:  unsigned long flags;",
      "4874:  raw_spin_lock_irqsave(&cfs_b->lock, flags);",
      "",
      "[Removed Lines]",
      "4871:  u64 expires;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 11 ---",
      "[Context before]",
      "4886:  if (cfs_b->quota != RUNTIME_INF && cfs_b->runtime > slice)",
      "4887:   runtime = cfs_b->runtime;",
      "4890:  if (runtime)",
      "4891:   cfs_b->distribute_running = 1;",
      "",
      "[Removed Lines]",
      "4889:  expires = cfs_b->runtime_expires;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 12 ---",
      "[Context before]",
      "4895:  if (!runtime)",
      "4896:   return;",
      "4900:  raw_spin_lock_irqsave(&cfs_b->lock, flags);",
      "4903:  cfs_b->distribute_running = 0;",
      "4904:  raw_spin_unlock_irqrestore(&cfs_b->lock, flags);",
      "4905: }",
      "",
      "[Removed Lines]",
      "4898:  runtime = distribute_cfs_runtime(cfs_b, runtime, expires);",
      "4901:  if (expires == cfs_b->runtime_expires)",
      "4902:   lsub_positive(&cfs_b->runtime, runtime);",
      "",
      "[Added Lines]",
      "4843:  runtime = distribute_cfs_runtime(cfs_b, runtime);",
      "4846:  lsub_positive(&cfs_b->runtime, runtime);",
      "",
      "---------------",
      "--- Hunk 13 ---",
      "[Context before]",
      "5057:  cfs_b->period_active = 1;",
      "5058:  overrun = hrtimer_forward_now(&cfs_b->period_timer, cfs_b->period);",
      "5061:  hrtimer_start_expires(&cfs_b->period_timer, HRTIMER_MODE_ABS_PINNED);",
      "5062: }",
      "",
      "[Removed Lines]",
      "5059:  cfs_b->runtime_expires += (overrun + 1) * ktime_to_ns(cfs_b->period);",
      "5060:  cfs_b->expires_seq++;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "kernel/sched/sched.h||kernel/sched/sched.h": [
      "File: kernel/sched/sched.h -> kernel/sched/sched.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "335:  u64   quota;",
      "336:  u64   runtime;",
      "337:  s64   hierarchical_quota;",
      "341:  u8   idle;",
      "342:  u8   period_active;",
      "",
      "[Removed Lines]",
      "338:  u64   runtime_expires;",
      "339:  int   expires_seq;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "558: #ifdef CONFIG_CFS_BANDWIDTH",
      "559:  int   runtime_enabled;",
      "562:  s64   runtime_remaining;",
      "564:  u64   throttled_clock;",
      "",
      "[Removed Lines]",
      "560:  int   expires_seq;",
      "561:  u64   runtime_expires;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "66567fcbaecac455caa1b13643155d686b51ce63",
      "candidate_info": {
        "commit_hash": "66567fcbaecac455caa1b13643155d686b51ce63",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/66567fcbaecac455caa1b13643155d686b51ce63",
        "files": [
          "kernel/sched/fair.c",
          "kernel/sched/sched.h"
        ],
        "message": "sched/fair: Don't push cfs_bandwith slack timers forward\n\nWhen a cfs_rq sleeps and returns its quota, we delay for 5ms before\nwaking any throttled cfs_rqs to coalesce with other cfs_rqs going to\nsleep, as this has to be done outside of the rq lock we hold.\n\nThe current code waits for 5ms without any sleeps, instead of waiting\nfor 5ms from the first sleep, which can delay the unthrottle more than\nwe want. Switch this around so that we can't push this forward forever.\n\nThis requires an extra flag rather than using hrtimer_active, since we\nneed to start a new timer if the current one is in the process of\nfinishing.\n\nSigned-off-by: Ben Segall <bsegall@google.com>\nSigned-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>\nReviewed-by: Xunlei Pang <xlpang@linux.alibaba.com>\nAcked-by: Phil Auld <pauld@redhat.com>\nCc: Linus Torvalds <torvalds@linux-foundation.org>\nCc: Peter Zijlstra <peterz@infradead.org>\nCc: Thomas Gleixner <tglx@linutronix.de>\nLink: https://lkml.kernel.org/r/xm26a7euy6iq.fsf_-_@bsegall-linux.svl.corp.google.com\nSigned-off-by: Ingo Molnar <mingo@kernel.org>",
        "before_after_code_files": [
          "kernel/sched/fair.c||kernel/sched/fair.c",
          "kernel/sched/sched.h||kernel/sched/sched.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "kernel/sched/fair.c||kernel/sched/fair.c",
            "kernel/sched/sched.h||kernel/sched/sched.h"
          ],
          "candidate": [
            "kernel/sched/fair.c||kernel/sched/fair.c",
            "kernel/sched/sched.h||kernel/sched/sched.h"
          ]
        }
      },
      "candidate_diff": {
        "kernel/sched/fair.c||kernel/sched/fair.c": [
          "File: kernel/sched/fair.c -> kernel/sched/fair.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4729:  if (runtime_refresh_within(cfs_b, min_left))",
          "4730:   return;",
          "4732:  hrtimer_start(&cfs_b->slack_timer,",
          "4733:    ns_to_ktime(cfs_bandwidth_slack_period),",
          "4734:    HRTIMER_MODE_REL);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4733:  if (cfs_b->slack_started)",
          "4734:   return;",
          "4735:  cfs_b->slack_started = true;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "4784:  raw_spin_lock_irqsave(&cfs_b->lock, flags);",
          "4785:  if (cfs_b->distribute_running) {",
          "4786:   raw_spin_unlock_irqrestore(&cfs_b->lock, flags);",
          "4787:   return;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4790:  cfs_b->slack_started = false;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "4945:  hrtimer_init(&cfs_b->slack_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);",
          "4946:  cfs_b->slack_timer.function = sched_cfs_slack_timer;",
          "4947:  cfs_b->distribute_running = 0;",
          "4948: }",
          "4950: static void init_cfs_rq_runtime(struct cfs_rq *cfs_rq)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4954:  cfs_b->slack_started = false;",
          "",
          "---------------"
        ],
        "kernel/sched/sched.h||kernel/sched/sched.h": [
          "File: kernel/sched/sched.h -> kernel/sched/sched.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "338:  u64   runtime_expires;",
          "339:  int   expires_seq;",
          "343:  struct hrtimer  period_timer;",
          "344:  struct hrtimer  slack_timer;",
          "345:  struct list_head throttled_cfs_rq;",
          "",
          "[Removed Lines]",
          "341:  short   idle;",
          "342:  short   period_active;",
          "",
          "[Added Lines]",
          "341:  u8   idle;",
          "342:  u8   period_active;",
          "343:  u8   distribute_running;",
          "344:  u8   slack_started;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "348:  int   nr_periods;",
          "349:  int   nr_throttled;",
          "350:  u64   throttled_time;",
          "353: #endif",
          "354: };",
          "",
          "[Removed Lines]",
          "352:  bool                    distribute_running;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "e98fa02c4f2ea4991dae422ac7e34d102d2f0599",
      "candidate_info": {
        "commit_hash": "e98fa02c4f2ea4991dae422ac7e34d102d2f0599",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/e98fa02c4f2ea4991dae422ac7e34d102d2f0599",
        "files": [
          "kernel/sched/fair.c"
        ],
        "message": "sched/fair: Eliminate bandwidth race between throttling and distribution\n\nThere is a race window in which an entity begins throttling before quota\nis added to the pool, but does not finish throttling until after we have\nfinished with distribute_cfs_runtime(). This entity is not observed by\ndistribute_cfs_runtime() because it was not on the throttled list at the\ntime that distribution was running. This race manifests as rare\nperiod-length statlls for such entities.\n\nRather than heavy-weight the synchronization with the progress of\ndistribution, we can fix this by aborting throttling if bandwidth has\nbecome available. Otherwise, we immediately add the entity to the\nthrottled list so that it can be observed by a subsequent distribution.\n\nAdditionally, we can remove the case of adding the throttled entity to\nthe head of the throttled list, and simply always add to the tail.\nThanks to 26a8b12747c97, distribute_cfs_runtime() no longer holds onto\nits own pool of runtime. This means that if we do hit the !assign and\ndistribute_running case, we know that distribution is about to end.\n\nSigned-off-by: Paul Turner <pjt@google.com>\nSigned-off-by: Ben Segall <bsegall@google.com>\nSigned-off-by: Josh Don <joshdon@google.com>\nSigned-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>\nReviewed-by: Phil Auld <pauld@redhat.com>\nLink: https://lkml.kernel.org/r/20200410225208.109717-2-joshdon@google.com",
        "before_after_code_files": [
          "kernel/sched/fair.c||kernel/sched/fair.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "kernel/sched/fair.c||kernel/sched/fair.c"
          ],
          "candidate": [
            "kernel/sched/fair.c||kernel/sched/fair.c"
          ]
        }
      },
      "candidate_diff": {
        "kernel/sched/fair.c||kernel/sched/fair.c": [
          "File: kernel/sched/fair.c -> kernel/sched/fair.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4588: }",
          "4592: {",
          "4601:  if (cfs_b->quota == RUNTIME_INF)",
          "4602:   amount = min_amount;",
          "4603:  else {",
          "",
          "[Removed Lines]",
          "4591: static int assign_cfs_rq_runtime(struct cfs_rq *cfs_rq)",
          "4593:  struct task_group *tg = cfs_rq->tg;",
          "4594:  struct cfs_bandwidth *cfs_b = tg_cfs_bandwidth(tg);",
          "4595:  u64 amount = 0, min_amount;",
          "4598:  min_amount = sched_cfs_bandwidth_slice() - cfs_rq->runtime_remaining;",
          "4600:  raw_spin_lock(&cfs_b->lock);",
          "",
          "[Added Lines]",
          "4591: static int __assign_cfs_rq_runtime(struct cfs_bandwidth *cfs_b,",
          "4592:        struct cfs_rq *cfs_rq, u64 target_runtime)",
          "4594:  u64 min_amount, amount = 0;",
          "4596:  lockdep_assert_held(&cfs_b->lock);",
          "4599:  min_amount = target_runtime - cfs_rq->runtime_remaining;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "4609:    cfs_b->idle = 0;",
          "4610:   }",
          "4611:  }",
          "4614:  cfs_rq->runtime_remaining += amount;",
          "4616:  return cfs_rq->runtime_remaining > 0;",
          "4617: }",
          "4619: static void __account_cfs_rq_runtime(struct cfs_rq *cfs_rq, u64 delta_exec)",
          "4620: {",
          "",
          "[Removed Lines]",
          "4612:  raw_spin_unlock(&cfs_b->lock);",
          "",
          "[Added Lines]",
          "4619: static int assign_cfs_rq_runtime(struct cfs_rq *cfs_rq)",
          "4620: {",
          "4621:  struct cfs_bandwidth *cfs_b = tg_cfs_bandwidth(cfs_rq->tg);",
          "4622:  int ret;",
          "4624:  raw_spin_lock(&cfs_b->lock);",
          "4625:  ret = __assign_cfs_rq_runtime(cfs_b, cfs_rq, sched_cfs_bandwidth_slice());",
          "4626:  raw_spin_unlock(&cfs_b->lock);",
          "4628:  return ret;",
          "4629: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "4704:  return 0;",
          "4705: }",
          "4708: {",
          "4709:  struct rq *rq = rq_of(cfs_rq);",
          "4710:  struct cfs_bandwidth *cfs_b = tg_cfs_bandwidth(cfs_rq->tg);",
          "4711:  struct sched_entity *se;",
          "4712:  long task_delta, idle_task_delta, dequeue = 1;",
          "4715:  se = cfs_rq->tg->se[cpu_of(rq_of(cfs_rq))];",
          "",
          "[Removed Lines]",
          "4707: static void throttle_cfs_rq(struct cfs_rq *cfs_rq)",
          "4713:  bool empty;",
          "",
          "[Added Lines]",
          "4719: static bool throttle_cfs_rq(struct cfs_rq *cfs_rq)",
          "4726:  raw_spin_lock(&cfs_b->lock);",
          "4728:  if (__assign_cfs_rq_runtime(cfs_b, cfs_rq, 1)) {",
          "4737:   dequeue = 0;",
          "4738:  } else {",
          "4739:   list_add_tail_rcu(&cfs_rq->throttled_list,",
          "4740:       &cfs_b->throttled_cfs_rq);",
          "4741:  }",
          "4742:  raw_spin_unlock(&cfs_b->lock);",
          "4744:  if (!dequeue)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "4744:  if (!se)",
          "4745:   sub_nr_running(rq, task_delta);",
          "4770: }",
          "4772: void unthrottle_cfs_rq(struct cfs_rq *cfs_rq)",
          "",
          "[Removed Lines]",
          "4747:  cfs_rq->throttled = 1;",
          "4748:  cfs_rq->throttled_clock = rq_clock(rq);",
          "4749:  raw_spin_lock(&cfs_b->lock);",
          "4750:  empty = list_empty(&cfs_b->throttled_cfs_rq);",
          "4757:  if (cfs_b->distribute_running)",
          "4758:   list_add_rcu(&cfs_rq->throttled_list, &cfs_b->throttled_cfs_rq);",
          "4759:  else",
          "4760:   list_add_tail_rcu(&cfs_rq->throttled_list, &cfs_b->throttled_cfs_rq);",
          "4766:  if (empty)",
          "4767:   start_cfs_bandwidth(cfs_b);",
          "4769:  raw_spin_unlock(&cfs_b->lock);",
          "",
          "[Added Lines]",
          "4783:  cfs_rq->throttled = 1;",
          "4784:  cfs_rq->throttled_clock = rq_clock(rq);",
          "4785:  return true;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "5121:  if (cfs_rq_throttled(cfs_rq))",
          "5122:   return true;",
          "5126: }",
          "5128: static enum hrtimer_restart sched_cfs_slack_timer(struct hrtimer *timer)",
          "",
          "[Removed Lines]",
          "5124:  throttle_cfs_rq(cfs_rq);",
          "5125:  return true;",
          "",
          "[Added Lines]",
          "5140:  return throttle_cfs_rq(cfs_rq);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "c0ad4aa4d8416a39ad262a2bd68b30acd951bf0e",
      "candidate_info": {
        "commit_hash": "c0ad4aa4d8416a39ad262a2bd68b30acd951bf0e",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/c0ad4aa4d8416a39ad262a2bd68b30acd951bf0e",
        "files": [
          "kernel/sched/fair.c"
        ],
        "message": "sched/fair: Robustify CFS-bandwidth timer locking\n\nTraditionally hrtimer callbacks were run with IRQs disabled, but with\nthe introduction of HRTIMER_MODE_SOFT it is possible they run from\nSoftIRQ context, which does _NOT_ have IRQs disabled.\n\nAllow for the CFS bandwidth timers (period_timer and slack_timer) to\nbe ran from SoftIRQ context; this entails removing the assumption that\nIRQs are already disabled from the locking.\n\nWhile mainline doesn't strictly need this, -RT forces all timers not\nexplicitly marked with MODE_HARD into MODE_SOFT and trips over this.\nAnd marking these timers as MODE_HARD doesn't make sense as they're\nnot required for RT operation and can potentially be quite expensive.\n\nReported-by: Tom Putzeys <tom.putzeys@be.atlascopco.com>\nTested-by: Mike Galbraith <efault@gmx.de>\nSigned-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>\nCc: Linus Torvalds <torvalds@linux-foundation.org>\nCc: Peter Zijlstra <peterz@infradead.org>\nCc: Sebastian Andrzej Siewior <bigeasy@linutronix.de>\nCc: Thomas Gleixner <tglx@linutronix.de>\nLink: https://lkml.kernel.org/r/20190107125231.GE14122@hirez.programming.kicks-ass.net\nSigned-off-by: Ingo Molnar <mingo@kernel.org>",
        "before_after_code_files": [
          "kernel/sched/fair.c||kernel/sched/fair.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "kernel/sched/fair.c||kernel/sched/fair.c"
          ],
          "candidate": [
            "kernel/sched/fair.c||kernel/sched/fair.c"
          ]
        }
      },
      "candidate_diff": {
        "kernel/sched/fair.c||kernel/sched/fair.c": [
          "File: kernel/sched/fair.c -> kernel/sched/fair.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4565:   struct rq *rq = rq_of(cfs_rq);",
          "4566:   struct rq_flags rf;",
          "4569:   if (!cfs_rq_throttled(cfs_rq))",
          "4570:    goto next;",
          "",
          "[Removed Lines]",
          "4568:   rq_lock(rq, &rf);",
          "",
          "[Added Lines]",
          "4568:   rq_lock_irqsave(rq, &rf);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "4582:    unthrottle_cfs_rq(cfs_rq);",
          "4584: next:",
          "4587:   if (!remaining)",
          "4588:    break;",
          "",
          "[Removed Lines]",
          "4585:   rq_unlock(rq, &rf);",
          "",
          "[Added Lines]",
          "4585:   rq_unlock_irqrestore(rq, &rf);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "4602: {",
          "4603:  u64 runtime, runtime_expires;",
          "4604:  int throttled;",
          "",
          "[Removed Lines]",
          "4601: static int do_sched_cfs_period_timer(struct cfs_bandwidth *cfs_b, int overrun)",
          "",
          "[Added Lines]",
          "4601: static int do_sched_cfs_period_timer(struct cfs_bandwidth *cfs_b, int overrun, unsigned long flags)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "4640:  while (throttled && cfs_b->runtime > 0 && !cfs_b->distribute_running) {",
          "4641:   runtime = cfs_b->runtime;",
          "4642:   cfs_b->distribute_running = 1;",
          "4645:   runtime = distribute_cfs_runtime(cfs_b, runtime,",
          "4646:        runtime_expires);",
          "4649:   cfs_b->distribute_running = 0;",
          "4650:   throttled = !list_empty(&cfs_b->throttled_cfs_rq);",
          "",
          "[Removed Lines]",
          "4643:   raw_spin_unlock(&cfs_b->lock);",
          "4647:   raw_spin_lock(&cfs_b->lock);",
          "",
          "[Added Lines]",
          "4643:   raw_spin_unlock_irqrestore(&cfs_b->lock, flags);",
          "4647:   raw_spin_lock_irqsave(&cfs_b->lock, flags);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "4753: static void do_sched_cfs_slack_timer(struct cfs_bandwidth *cfs_b)",
          "4754: {",
          "4755:  u64 runtime = 0, slice = sched_cfs_bandwidth_slice();",
          "4756:  u64 expires;",
          "4760:  if (cfs_b->distribute_running) {",
          "4762:   return;",
          "4763:  }",
          "4765:  if (runtime_refresh_within(cfs_b, min_bandwidth_expiration)) {",
          "4767:   return;",
          "4768:  }",
          "",
          "[Removed Lines]",
          "4759:  raw_spin_lock(&cfs_b->lock);",
          "4761:   raw_spin_unlock(&cfs_b->lock);",
          "4766:   raw_spin_unlock(&cfs_b->lock);",
          "",
          "[Added Lines]",
          "4756:  unsigned long flags;",
          "4760:  raw_spin_lock_irqsave(&cfs_b->lock, flags);",
          "4762:   raw_spin_unlock_irqrestore(&cfs_b->lock, flags);",
          "4767:   raw_spin_unlock_irqrestore(&cfs_b->lock, flags);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "4774:  if (runtime)",
          "4775:   cfs_b->distribute_running = 1;",
          "4779:  if (!runtime)",
          "4780:   return;",
          "4782:  runtime = distribute_cfs_runtime(cfs_b, runtime, expires);",
          "4785:  if (expires == cfs_b->runtime_expires)",
          "4786:   lsub_positive(&cfs_b->runtime, runtime);",
          "4787:  cfs_b->distribute_running = 0;",
          "4789: }",
          "",
          "[Removed Lines]",
          "4777:  raw_spin_unlock(&cfs_b->lock);",
          "4784:  raw_spin_lock(&cfs_b->lock);",
          "4788:  raw_spin_unlock(&cfs_b->lock);",
          "",
          "[Added Lines]",
          "4778:  raw_spin_unlock_irqrestore(&cfs_b->lock, flags);",
          "4785:  raw_spin_lock_irqsave(&cfs_b->lock, flags);",
          "4789:  raw_spin_unlock_irqrestore(&cfs_b->lock, flags);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "4863: {",
          "4864:  struct cfs_bandwidth *cfs_b =",
          "4865:   container_of(timer, struct cfs_bandwidth, period_timer);",
          "4866:  int overrun;",
          "4867:  int idle = 0;",
          "4870:  for (;;) {",
          "4871:   overrun = hrtimer_forward_now(timer, cfs_b->period);",
          "4872:   if (!overrun)",
          "4873:    break;",
          "4876:  }",
          "4877:  if (idle)",
          "4878:   cfs_b->period_active = 0;",
          "4881:  return idle ? HRTIMER_NORESTART : HRTIMER_RESTART;",
          "4882: }",
          "",
          "[Removed Lines]",
          "4869:  raw_spin_lock(&cfs_b->lock);",
          "4875:   idle = do_sched_cfs_period_timer(cfs_b, overrun);",
          "4879:  raw_spin_unlock(&cfs_b->lock);",
          "",
          "[Added Lines]",
          "4867:  unsigned long flags;",
          "4871:  raw_spin_lock_irqsave(&cfs_b->lock, flags);",
          "4877:   idle = do_sched_cfs_period_timer(cfs_b, overrun, flags);",
          "4881:  raw_spin_unlock_irqrestore(&cfs_b->lock, flags);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "26a8b12747c975b33b4a82d62e4a307e1c07f31b",
      "candidate_info": {
        "commit_hash": "26a8b12747c975b33b4a82d62e4a307e1c07f31b",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/26a8b12747c975b33b4a82d62e4a307e1c07f31b",
        "files": [
          "kernel/sched/fair.c"
        ],
        "message": "sched/fair: Fix race between runtime distribution and assignment\n\nCurrently, there is a potential race between distribute_cfs_runtime()\nand assign_cfs_rq_runtime(). Race happens when cfs_b->runtime is read,\ndistributes without holding lock and finds out there is not enough\nruntime to charge against after distribution. Because\nassign_cfs_rq_runtime() might be called during distribution, and use\ncfs_b->runtime at the same time.\n\nFibtest is the tool to test this race. Assume all gcfs_rq is throttled\nand cfs period timer runs, slow threads might run and sleep, returning\nunused cfs_rq runtime and keeping min_cfs_rq_runtime in their local\npool. If all this happens sufficiently quickly, cfs_b->runtime will drop\na lot. If runtime distributed is large too, over-use of runtime happens.\n\nA runtime over-using by about 70 percent of quota is seen when we\ntest fibtest on a 96-core machine. We run fibtest with 1 fast thread and\n95 slow threads in test group, configure 10ms quota for this group and\nsee the CPU usage of fibtest is 17.0%, which is far more than the\nexpected 10%.\n\nOn a smaller machine with 32 cores, we also run fibtest with 96\nthreads. CPU usage is more than 12%, which is also more than expected\n10%. This shows that on similar workloads, this race do affect CPU\nbandwidth control.\n\nSolve this by holding lock inside distribute_cfs_runtime().\n\nFixes: c06f04c70489 (\"sched: Fix potential near-infinite distribute_cfs_runtime() loop\")\nReviewed-by: Ben Segall <bsegall@google.com>\nSigned-off-by: Huaixin Chang <changhuaixin@linux.alibaba.com>\nSigned-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>\nSigned-off-by: Ingo Molnar <mingo@kernel.org>\nLink: https://lore.kernel.org/lkml/20200325092602.22471-1-changhuaixin@linux.alibaba.com/",
        "before_after_code_files": [
          "kernel/sched/fair.c||kernel/sched/fair.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "kernel/sched/fair.c||kernel/sched/fair.c"
          ],
          "candidate": [
            "kernel/sched/fair.c||kernel/sched/fair.c"
          ]
        }
      },
      "candidate_diff": {
        "kernel/sched/fair.c||kernel/sched/fair.c": [
          "File: kernel/sched/fair.c -> kernel/sched/fair.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4836:   resched_curr(rq);",
          "4837: }",
          "4840: {",
          "4841:  struct cfs_rq *cfs_rq;",
          "4845:  rcu_read_lock();",
          "4846:  list_for_each_entry_rcu(cfs_rq, &cfs_b->throttled_cfs_rq,",
          "",
          "[Removed Lines]",
          "4839: static u64 distribute_cfs_runtime(struct cfs_bandwidth *cfs_b, u64 remaining)",
          "4842:  u64 runtime;",
          "4843:  u64 starting_runtime = remaining;",
          "",
          "[Added Lines]",
          "4839: static void distribute_cfs_runtime(struct cfs_bandwidth *cfs_b)",
          "4842:  u64 runtime, remaining = 1;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "4856:   SCHED_WARN_ON(cfs_rq->runtime_remaining > 0);",
          "4858:   runtime = -cfs_rq->runtime_remaining + 1;",
          "4863:   cfs_rq->runtime_remaining += runtime;",
          "",
          "[Removed Lines]",
          "4859:   if (runtime > remaining)",
          "4860:    runtime = remaining;",
          "4861:   remaining -= runtime;",
          "",
          "[Added Lines]",
          "4857:   raw_spin_lock(&cfs_b->lock);",
          "4859:   if (runtime > cfs_b->runtime)",
          "4860:    runtime = cfs_b->runtime;",
          "4861:   cfs_b->runtime -= runtime;",
          "4862:   remaining = cfs_b->runtime;",
          "4863:   raw_spin_unlock(&cfs_b->lock);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "4873:    break;",
          "4874:  }",
          "4875:  rcu_read_unlock();",
          "4878: }",
          "",
          "[Removed Lines]",
          "4877:  return starting_runtime - remaining;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "4886: static int do_sched_cfs_period_timer(struct cfs_bandwidth *cfs_b, int overrun, unsigned long flags)",
          "4887: {",
          "4889:  int throttled;",
          "",
          "[Removed Lines]",
          "4888:  u64 runtime;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "4914:  cfs_b->nr_throttled += overrun;",
          "4923:  while (throttled && cfs_b->runtime > 0 && !cfs_b->distribute_running) {",
          "4925:   cfs_b->distribute_running = 1;",
          "4926:   raw_spin_unlock_irqrestore(&cfs_b->lock, flags);",
          "4929:   raw_spin_lock_irqsave(&cfs_b->lock, flags);",
          "4931:   cfs_b->distribute_running = 0;",
          "4932:   throttled = !list_empty(&cfs_b->throttled_cfs_rq);",
          "4935:  }",
          "",
          "[Removed Lines]",
          "4924:   runtime = cfs_b->runtime;",
          "4928:   runtime = distribute_cfs_runtime(cfs_b, runtime);",
          "4934:   lsub_positive(&cfs_b->runtime, runtime);",
          "",
          "[Added Lines]",
          "4922:   distribute_cfs_runtime(cfs_b);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "5065:  if (!runtime)",
          "5066:   return;",
          "5070:  raw_spin_lock_irqsave(&cfs_b->lock, flags);",
          "5072:  cfs_b->distribute_running = 0;",
          "5073:  raw_spin_unlock_irqrestore(&cfs_b->lock, flags);",
          "5074: }",
          "",
          "[Removed Lines]",
          "5068:  runtime = distribute_cfs_runtime(cfs_b, runtime);",
          "5071:  lsub_positive(&cfs_b->runtime, runtime);",
          "",
          "[Added Lines]",
          "5060:  distribute_cfs_runtime(cfs_b);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "baa9be4ffb55876923dc9716abc0a448e510ba30",
      "candidate_info": {
        "commit_hash": "baa9be4ffb55876923dc9716abc0a448e510ba30",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/baa9be4ffb55876923dc9716abc0a448e510ba30",
        "files": [
          "kernel/sched/fair.c",
          "kernel/sched/sched.h"
        ],
        "message": "sched/fair: Fix throttle_list starvation with low CFS quota\n\nWith a very low cpu.cfs_quota_us setting, such as the minimum of 1000,\ndistribute_cfs_runtime may not empty the throttled_list before it runs\nout of runtime to distribute. In that case, due to the change from\nc06f04c7048 to put throttled entries at the head of the list, later entries\non the list will starve.  Essentially, the same X processes will get pulled\noff the list, given CPU time and then, when expired, get put back on the\nhead of the list where distribute_cfs_runtime will give runtime to the same\nset of processes leaving the rest.\n\nFix the issue by setting a bit in struct cfs_bandwidth when\ndistribute_cfs_runtime is running, so that the code in throttle_cfs_rq can\ndecide to put the throttled entry on the tail or the head of the list.  The\nbit is set/cleared by the callers of distribute_cfs_runtime while they hold\ncfs_bandwidth->lock.\n\nThis is easy to reproduce with a handful of CPU consumers. I use 'crash' on\nthe live system. In some cases you can simply look at the throttled list and\nsee the later entries are not changing:\n\n  crash> list cfs_rq.throttled_list -H 0xffff90b54f6ade40 -s cfs_rq.runtime_remaining | paste - - | awk '{print $1\"  \"$4}' | pr -t -n3\n    1     ffff90b56cb2d200  -976050\n    2     ffff90b56cb2cc00  -484925\n    3     ffff90b56cb2bc00  -658814\n    4     ffff90b56cb2ba00  -275365\n    5     ffff90b166a45600  -135138\n    6     ffff90b56cb2da00  -282505\n    7     ffff90b56cb2e000  -148065\n    8     ffff90b56cb2fa00  -872591\n    9     ffff90b56cb2c000  -84687\n   10     ffff90b56cb2f000  -87237\n   11     ffff90b166a40a00  -164582\n\n  crash> list cfs_rq.throttled_list -H 0xffff90b54f6ade40 -s cfs_rq.runtime_remaining | paste - - | awk '{print $1\"  \"$4}' | pr -t -n3\n    1     ffff90b56cb2d200  -994147\n    2     ffff90b56cb2cc00  -306051\n    3     ffff90b56cb2bc00  -961321\n    4     ffff90b56cb2ba00  -24490\n    5     ffff90b166a45600  -135138\n    6     ffff90b56cb2da00  -282505\n    7     ffff90b56cb2e000  -148065\n    8     ffff90b56cb2fa00  -872591\n    9     ffff90b56cb2c000  -84687\n   10     ffff90b56cb2f000  -87237\n   11     ffff90b166a40a00  -164582\n\nSometimes it is easier to see by finding a process getting starved and looking\nat the sched_info:\n\n  crash> task ffff8eb765994500 sched_info\n  PID: 7800   TASK: ffff8eb765994500  CPU: 16  COMMAND: \"cputest\"\n    sched_info = {\n      pcount = 8,\n      run_delay = 697094208,\n      last_arrival = 240260125039,\n      last_queued = 240260327513\n    },\n  crash> task ffff8eb765994500 sched_info\n  PID: 7800   TASK: ffff8eb765994500  CPU: 16  COMMAND: \"cputest\"\n    sched_info = {\n      pcount = 8,\n      run_delay = 697094208,\n      last_arrival = 240260125039,\n      last_queued = 240260327513\n    },\n\nSigned-off-by: Phil Auld <pauld@redhat.com>\nReviewed-by: Ben Segall <bsegall@google.com>\nCc: Linus Torvalds <torvalds@linux-foundation.org>\nCc: Peter Zijlstra <peterz@infradead.org>\nCc: Thomas Gleixner <tglx@linutronix.de>\nCc: stable@vger.kernel.org\nFixes: c06f04c70489 (\"sched: Fix potential near-infinite distribute_cfs_runtime() loop\")\nLink: http://lkml.kernel.org/r/20181008143639.GA4019@pauld.bos.csb\nSigned-off-by: Ingo Molnar <mingo@kernel.org>",
        "before_after_code_files": [
          "kernel/sched/fair.c||kernel/sched/fair.c",
          "kernel/sched/sched.h||kernel/sched/sched.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "kernel/sched/fair.c||kernel/sched/fair.c",
            "kernel/sched/sched.h||kernel/sched/sched.h"
          ],
          "candidate": [
            "kernel/sched/fair.c||kernel/sched/fair.c",
            "kernel/sched/sched.h||kernel/sched/sched.h"
          ]
        }
      },
      "candidate_diff": {
        "kernel/sched/fair.c||kernel/sched/fair.c": [
          "File: kernel/sched/fair.c -> kernel/sched/fair.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "4481:  list_add_rcu(&cfs_rq->throttled_list, &cfs_b->throttled_cfs_rq);",
          "",
          "[Added Lines]",
          "4482:  if (cfs_b->distribute_running)",
          "4483:   list_add_rcu(&cfs_rq->throttled_list, &cfs_b->throttled_cfs_rq);",
          "4484:  else",
          "4485:   list_add_tail_rcu(&cfs_rq->throttled_list, &cfs_b->throttled_cfs_rq);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "4626:   runtime = cfs_b->runtime;",
          "4627:   raw_spin_unlock(&cfs_b->lock);",
          "4629:   runtime = distribute_cfs_runtime(cfs_b, runtime,",
          "4630:        runtime_expires);",
          "4631:   raw_spin_lock(&cfs_b->lock);",
          "4633:   throttled = !list_empty(&cfs_b->throttled_cfs_rq);",
          "4635:   cfs_b->runtime -= min(runtime, cfs_b->runtime);",
          "",
          "[Removed Lines]",
          "4625:  while (throttled && cfs_b->runtime > 0) {",
          "",
          "[Added Lines]",
          "4629:  while (throttled && cfs_b->runtime > 0 && !cfs_b->distribute_running) {",
          "4631:   cfs_b->distribute_running = 1;",
          "4638:   cfs_b->distribute_running = 0;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "4742:  raw_spin_lock(&cfs_b->lock);",
          "4743:  if (runtime_refresh_within(cfs_b, min_bandwidth_expiration)) {",
          "4744:   raw_spin_unlock(&cfs_b->lock);",
          "4745:   return;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4749:  if (cfs_b->distribute_running) {",
          "4750:   raw_spin_unlock(&cfs_b->lock);",
          "4751:   return;",
          "4752:  }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "4749:   runtime = cfs_b->runtime;",
          "4751:  expires = cfs_b->runtime_expires;",
          "4752:  raw_spin_unlock(&cfs_b->lock);",
          "4754:  if (!runtime)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4763:  if (runtime)",
          "4764:   cfs_b->distribute_running = 1;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "4759:  raw_spin_lock(&cfs_b->lock);",
          "4760:  if (expires == cfs_b->runtime_expires)",
          "4761:   cfs_b->runtime -= min(runtime, cfs_b->runtime);",
          "4762:  raw_spin_unlock(&cfs_b->lock);",
          "4763: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4776:  cfs_b->distribute_running = 0;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "4867:  cfs_b->period_timer.function = sched_cfs_period_timer;",
          "4868:  hrtimer_init(&cfs_b->slack_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);",
          "4869:  cfs_b->slack_timer.function = sched_cfs_slack_timer;",
          "4870: }",
          "4872: static void init_cfs_rq_runtime(struct cfs_rq *cfs_rq)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4885:  cfs_b->distribute_running = 0;",
          "",
          "---------------"
        ],
        "kernel/sched/sched.h||kernel/sched/sched.h": [
          "File: kernel/sched/sched.h -> kernel/sched/sched.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "346:  int   nr_periods;",
          "347:  int   nr_throttled;",
          "348:  u64   throttled_time;",
          "349: #endif",
          "350: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "350:  bool                    distribute_running;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
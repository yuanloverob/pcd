{
  "cve_id": "CVE-2013-4483",
  "cve_desc": "The ipc_rcu_putref function in ipc/util.c in the Linux kernel before 3.10 does not properly manage a reference count, which allows local users to cause a denial of service (memory consumption or system crash) via a crafted application.",
  "repo": "torvalds/linux",
  "patch_hash": "6062a8dc0517bce23e3c2f7d2fea5e22411269a3",
  "patch_info": {
    "commit_hash": "6062a8dc0517bce23e3c2f7d2fea5e22411269a3",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/6062a8dc0517bce23e3c2f7d2fea5e22411269a3",
    "files": [
      "ipc/msg.c",
      "ipc/sem.c",
      "ipc/util.c",
      "ipc/util.h"
    ],
    "message": "ipc,sem: fine grained locking for semtimedop\n\nIntroduce finer grained locking for semtimedop, to handle the common case\nof a program wanting to manipulate one semaphore from an array with\nmultiple semaphores.\n\nIf the call is a semop manipulating just one semaphore in an array with\nmultiple semaphores, only take the lock for that semaphore itself.\n\nIf the call needs to manipulate multiple semaphores, or another caller is\nin a transaction that manipulates multiple semaphores, the sem_array lock\nis taken, as well as all the locks for the individual semaphores.\n\nOn a 24 CPU system, performance numbers with the semop-multi\ntest with N threads and N semaphores, look like this:\n\n\tvanilla\t\tDavidlohr's\tDavidlohr's +\tDavidlohr's +\nthreads\t\t\tpatches\t\trwlock patches\tv3 patches\n10\t610652\t\t726325\t\t1783589\t\t2142206\n20\t341570\t\t365699\t\t1520453\t\t1977878\n30\t288102\t\t307037\t\t1498167\t\t2037995\n40\t290714\t\t305955\t\t1612665\t\t2256484\n50\t288620\t\t312890\t\t1733453\t\t2650292\n60\t289987\t\t306043\t\t1649360\t\t2388008\n70\t291298\t\t306347\t\t1723167\t\t2717486\n80\t290948\t\t305662\t\t1729545\t\t2763582\n90\t290996\t\t306680\t\t1736021\t\t2757524\n100\t292243\t\t306700\t\t1773700\t\t3059159\n\n[davidlohr.bueso@hp.com: do not call sem_lock when bogus sma]\n[davidlohr.bueso@hp.com: make refcounter atomic]\nSigned-off-by: Rik van Riel <riel@redhat.com>\nSuggested-by: Linus Torvalds <torvalds@linux-foundation.org>\nAcked-by: Davidlohr Bueso <davidlohr.bueso@hp.com>\nCc: Chegu Vinod <chegu_vinod@hp.com>\nCc: Jason Low <jason.low2@hp.com>\nReviewed-by: Michel Lespinasse <walken@google.com>\nCc: Peter Hurley <peter@hurleysoftware.com>\nCc: Stanislav Kinsbursky <skinsbursky@parallels.com>\nTested-by: Emmanuel Benisty <benisty.e@gmail.com>\nTested-by: Sedat Dilek <sedat.dilek@gmail.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
    "before_after_code_files": [
      "ipc/msg.c||ipc/msg.c",
      "ipc/sem.c||ipc/sem.c",
      "ipc/util.c||ipc/util.c",
      "ipc/util.h||ipc/util.h"
    ]
  },
  "patch_diff": {
    "ipc/msg.c||ipc/msg.c": [
      "File: ipc/msg.c -> ipc/msg.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "687:    goto out_unlock_free;",
      "688:   }",
      "689:   ss_add(msq, &s);",
      "691:   msg_unlock(msq);",
      "692:   schedule();",
      "",
      "[Removed Lines]",
      "690:   ipc_rcu_getref(msq);",
      "",
      "[Added Lines]",
      "691:   if (!ipc_rcu_getref(msq)) {",
      "692:    err = -EIDRM;",
      "693:    goto out_unlock_free;",
      "694:   }",
      "",
      "---------------"
    ],
    "ipc/sem.c||ipc/sem.c": [
      "File: ipc/sem.c -> ipc/sem.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "138: #define sem_ids(ns) ((ns)->ids[IPC_SEM_IDS])",
      "141: #define sem_checkid(sma, semid) ipc_checkid(&sma->sem_perm, semid)",
      "143: static int newary(struct ipc_namespace *, struct ipc_params *);",
      "",
      "[Removed Lines]",
      "140: #define sem_unlock(sma)  ipc_unlock(&(sma)->sem_perm)",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "189:     IPC_SEM_IDS, sysvipc_sem_proc_show);",
      "190: }",
      "197: {",
      "198:  struct kern_ipc_perm *ipcp;",
      "199:  struct sem_array *sma;",
      "",
      "[Removed Lines]",
      "196: static inline struct sem_array *sem_obtain_lock(struct ipc_namespace *ns, int id)",
      "",
      "[Added Lines]",
      "208: static inline int sem_lock(struct sem_array *sma, struct sembuf *sops,",
      "209:          int nsops)",
      "210: {",
      "211:  int locknum;",
      "212:  again:",
      "213:  if (nsops == 1 && !sma->complex_count) {",
      "214:   struct sem *sem = sma->sem_base + sops->sem_num;",
      "217:   spin_lock(&sem->lock);",
      "223:   if (unlikely(sma->complex_count)) {",
      "224:    spin_unlock(&sem->lock);",
      "225:    goto lock_array;",
      "226:   }",
      "233:   if (unlikely(spin_is_locked(&sma->sem_perm.lock))) {",
      "234:    spin_unlock(&sem->lock);",
      "235:    spin_unlock_wait(&sma->sem_perm.lock);",
      "236:    goto again;",
      "237:   }",
      "239:   locknum = sops->sem_num;",
      "240:  } else {",
      "241:   int i;",
      "248:  lock_array:",
      "249:   spin_lock(&sma->sem_perm.lock);",
      "250:   for (i = 0; i < sma->sem_nsems; i++) {",
      "251:    struct sem *sem = sma->sem_base + i;",
      "252:    spin_unlock_wait(&sem->lock);",
      "253:   }",
      "254:   locknum = -1;",
      "255:  }",
      "256:  return locknum;",
      "257: }",
      "259: static inline void sem_unlock(struct sem_array *sma, int locknum)",
      "260: {",
      "261:  if (locknum == -1) {",
      "262:   spin_unlock(&sma->sem_perm.lock);",
      "263:  } else {",
      "264:   struct sem *sem = sma->sem_base + locknum;",
      "265:   spin_unlock(&sem->lock);",
      "266:  }",
      "267:  rcu_read_unlock();",
      "268: }",
      "274: static inline struct sem_array *sem_obtain_lock(struct ipc_namespace *ns,",
      "275:    int id, struct sembuf *sops, int nsops, int *locknum)",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "205:   goto err;",
      "206:  }",
      "",
      "[Removed Lines]",
      "208:  spin_lock(&ipcp->lock);",
      "",
      "[Added Lines]",
      "287:  sma = container_of(ipcp, struct sem_array, sem_perm);",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "213:  if (!ipcp->deleted)",
      "214:   return container_of(ipcp, struct sem_array, sem_perm);",
      "217:  sma = ERR_PTR(-EINVAL);",
      "218: err:",
      "219:  rcu_read_unlock();",
      "",
      "[Removed Lines]",
      "216:  spin_unlock(&ipcp->lock);",
      "",
      "[Added Lines]",
      "296:  sem_unlock(sma, *locknum);",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "230:  return container_of(ipcp, struct sem_array, sem_perm);",
      "231: }",
      "244: static inline struct sem_array *sem_obtain_object_check(struct ipc_namespace *ns,",
      "245:        int id)",
      "246: {",
      "",
      "[Removed Lines]",
      "233: static inline struct sem_array *sem_lock_check(struct ipc_namespace *ns,",
      "234:       int id)",
      "235: {",
      "236:  struct kern_ipc_perm *ipcp = ipc_lock_check(&sem_ids(ns), id);",
      "238:  if (IS_ERR(ipcp))",
      "239:   return ERR_CAST(ipcp);",
      "241:  return container_of(ipcp, struct sem_array, sem_perm);",
      "242: }",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "255: static inline void sem_lock_and_putref(struct sem_array *sma)",
      "256: {",
      "258:  ipc_rcu_putref(sma);",
      "259: }",
      "261: static inline void sem_getref_and_unlock(struct sem_array *sma)",
      "262: {",
      "265: }",
      "267: static inline void sem_putref(struct sem_array *sma)",
      "268: {",
      "272: }",
      "",
      "[Removed Lines]",
      "257:  ipc_lock_by_ptr(&sma->sem_perm);",
      "263:  ipc_rcu_getref(sma);",
      "264:  ipc_unlock(&(sma)->sem_perm);",
      "269:  ipc_lock_by_ptr(&sma->sem_perm);",
      "270:  ipc_rcu_putref(sma);",
      "271:  ipc_unlock(&(sma)->sem_perm);",
      "",
      "[Added Lines]",
      "326:  rcu_read_lock();",
      "327:  sem_lock(sma, NULL, -1);",
      "333:  WARN_ON_ONCE(!ipc_rcu_getref(sma));",
      "334:  sem_unlock(sma, -1);",
      "339:  sem_lock_and_putref(sma);",
      "340:  sem_unlock(sma, -1);",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "277: static inline void sem_getref(struct sem_array *sma)",
      "278: {",
      "282: }",
      "284: static inline void sem_rmid(struct ipc_namespace *ns, struct sem_array *s)",
      "",
      "[Removed Lines]",
      "279:  spin_lock(&(sma)->sem_perm.lock);",
      "280:  ipc_rcu_getref(sma);",
      "281:  ipc_unlock(&(sma)->sem_perm);",
      "",
      "[Added Lines]",
      "348:  sem_lock(sma, NULL, -1);",
      "349:  WARN_ON_ONCE(!ipc_rcu_getref(sma));",
      "350:  sem_unlock(sma, -1);",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "372:  sma->sem_base = (struct sem *) &sma[1];",
      "375:   INIT_LIST_HEAD(&sma->sem_base[i].sem_pending);",
      "377:  sma->complex_count = 0;",
      "378:  INIT_LIST_HEAD(&sma->sem_pending);",
      "379:  INIT_LIST_HEAD(&sma->list_id);",
      "380:  sma->sem_nsems = nsems;",
      "381:  sma->sem_ctime = get_seconds();",
      "384:  return sma->sem_perm.id;",
      "385: }",
      "",
      "[Removed Lines]",
      "374:  for (i = 0; i < nsems; i++)",
      "382:  sem_unlock(sma);",
      "",
      "[Added Lines]",
      "443:  for (i = 0; i < nsems; i++) {",
      "445:   spin_lock_init(&sma->sem_base[i].lock);",
      "446:  }",
      "453:  sem_unlock(sma, -1);",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "820:  sem_rmid(ns, sma);",
      "823:  wake_up_sem_queue_do(&tasks);",
      "824:  ns->used_sems -= sma->sem_nsems;",
      "",
      "[Removed Lines]",
      "821:  sem_unlock(sma);",
      "",
      "[Added Lines]",
      "892:  sem_unlock(sma, -1);",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "947:  struct sem_array *sma;",
      "948:  struct sem* curr;",
      "949:  int err;",
      "951:  struct list_head tasks;",
      "952:  int val;",
      "953: #if defined(CONFIG_64BIT) && defined(__BIG_ENDIAN)",
      "",
      "[Removed Lines]",
      "950:  int nsems;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 11 ---",
      "[Context before]",
      "958:  val = arg;",
      "959: #endif",
      "965:  INIT_LIST_HEAD(&tasks);",
      "972:  err = security_sem_semctl(sma, SETVAL);",
      "980:  curr = &sma->sem_base[semnum];",
      "986:  assert_spin_locked(&sma->sem_perm.lock);",
      "987:  list_for_each_entry(un, &sma->list_id, list_id)",
      "988:   un->semadj[semnum] = 0;",
      "",
      "[Removed Lines]",
      "961:  sma = sem_lock_check(ns, semid);",
      "962:  if (IS_ERR(sma))",
      "963:   return PTR_ERR(sma);",
      "966:  nsems = sma->sem_nsems;",
      "968:  err = -EACCES;",
      "969:  if (ipcperms(ns, &sma->sem_perm, S_IWUGO))",
      "970:   goto out_unlock;",
      "973:  if (err)",
      "974:   goto out_unlock;",
      "976:  err = -EINVAL;",
      "977:  if(semnum < 0 || semnum >= nsems)",
      "978:   goto out_unlock;",
      "982:  err = -ERANGE;",
      "983:  if (val > SEMVMX || val < 0)",
      "984:   goto out_unlock;",
      "",
      "[Added Lines]",
      "1031:  if (val > SEMVMX || val < 0)",
      "1032:   return -ERANGE;",
      "1036:  rcu_read_lock();",
      "1037:  sma = sem_obtain_object_check(ns, semid);",
      "1038:  if (IS_ERR(sma)) {",
      "1039:   rcu_read_unlock();",
      "1040:   return PTR_ERR(sma);",
      "1041:  }",
      "1043:  if (semnum < 0 || semnum >= sma->sem_nsems) {",
      "1044:   rcu_read_unlock();",
      "1045:   return -EINVAL;",
      "1046:  }",
      "1049:  if (ipcperms(ns, &sma->sem_perm, S_IWUGO)) {",
      "1050:   rcu_read_unlock();",
      "1051:   return -EACCES;",
      "1052:  }",
      "1055:  if (err) {",
      "1056:   rcu_read_unlock();",
      "1057:   return -EACCES;",
      "1058:  }",
      "1060:  sem_lock(sma, NULL, -1);",
      "",
      "---------------",
      "--- Hunk 12 ---",
      "[Context before]",
      "992:  sma->sem_ctime = get_seconds();",
      "994:  do_smart_update(sma, NULL, 0, 0, &tasks);",
      "998:  wake_up_sem_queue_do(&tasks);",
      "1000: }",
      "1002: static int semctl_main(struct ipc_namespace *ns, int semid, int semnum,",
      "",
      "[Removed Lines]",
      "995:  err = 0;",
      "996: out_unlock:",
      "997:  sem_unlock(sma);",
      "999:  return err;",
      "",
      "[Added Lines]",
      "1073:  sem_unlock(sma, -1);",
      "1075:  return 0;",
      "",
      "---------------",
      "--- Hunk 13 ---",
      "[Context before]",
      "1052:    sem_lock_and_putref(sma);",
      "1053:    if (sma->sem_perm.deleted) {",
      "1055:     err = -EIDRM;",
      "1056:     goto out_free;",
      "1057:    }",
      "1061:   for (i = 0; i < sma->sem_nsems; i++)",
      "1062:    sem_io[i] = sma->sem_base[i].semval;",
      "1064:   err = 0;",
      "1065:   if(copy_to_user(array, sem_io, nsems*sizeof(ushort)))",
      "1066:    err = -EFAULT;",
      "",
      "[Removed Lines]",
      "1054:     sem_unlock(sma);",
      "1058:   }",
      "1060:   spin_lock(&sma->sem_perm.lock);",
      "1063:   sem_unlock(sma);",
      "",
      "[Added Lines]",
      "1130:     sem_unlock(sma, -1);",
      "1134:   } else",
      "1135:    sem_lock(sma, NULL, -1);",
      "1139:   sem_unlock(sma, -1);",
      "",
      "---------------",
      "--- Hunk 14 ---",
      "[Context before]",
      "1071:   int i;",
      "1072:   struct sem_undo *un;",
      "1075:   rcu_read_unlock();",
      "1077:   if(nsems > SEMMSL_FAST) {",
      "",
      "[Removed Lines]",
      "1074:   ipc_rcu_getref(sma);",
      "",
      "[Added Lines]",
      "1150:   if (!ipc_rcu_getref(sma)) {",
      "1151:    rcu_read_unlock();",
      "1152:    return -EIDRM;",
      "1153:   }",
      "",
      "---------------",
      "--- Hunk 15 ---",
      "[Context before]",
      "1097:   }",
      "1098:   sem_lock_and_putref(sma);",
      "1099:   if (sma->sem_perm.deleted) {",
      "1101:    err = -EIDRM;",
      "1102:    goto out_free;",
      "1103:   }",
      "",
      "[Removed Lines]",
      "1100:    sem_unlock(sma);",
      "",
      "[Added Lines]",
      "1179:    sem_unlock(sma, -1);",
      "",
      "---------------",
      "--- Hunk 16 ---",
      "[Context before]",
      "1124:   goto out_wakeup;",
      "1125:  }",
      "1128:  curr = &sma->sem_base[semnum];",
      "1130:  switch (cmd) {",
      "",
      "[Removed Lines]",
      "1127:  spin_lock(&sma->sem_perm.lock);",
      "",
      "[Added Lines]",
      "1206:  sem_lock(sma, NULL, -1);",
      "",
      "---------------",
      "--- Hunk 17 ---",
      "[Context before]",
      "1143:  }",
      "1145: out_unlock:",
      "1147: out_wakeup:",
      "1148:  wake_up_sem_queue_do(&tasks);",
      "1149: out_free:",
      "",
      "[Removed Lines]",
      "1146:  sem_unlock(sma);",
      "",
      "[Added Lines]",
      "1225:  sem_unlock(sma, -1);",
      "",
      "---------------",
      "--- Hunk 18 ---",
      "[Context before]",
      "1212:  switch(cmd){",
      "1213:  case IPC_RMID:",
      "1215:   freeary(ns, ipcp);",
      "1216:   goto out_up;",
      "1217:  case IPC_SET:",
      "1219:   err = ipc_update_perm(&semid64.sem_perm, ipcp);",
      "1220:   if (err)",
      "1221:    goto out_unlock;",
      "",
      "[Removed Lines]",
      "1214:   ipc_lock_object(&sma->sem_perm);",
      "1218:   ipc_lock_object(&sma->sem_perm);",
      "",
      "[Added Lines]",
      "1293:   sem_lock(sma, NULL, -1);",
      "1297:   sem_lock(sma, NULL, -1);",
      "",
      "---------------",
      "--- Hunk 19 ---",
      "[Context before]",
      "1228:  }",
      "1230: out_unlock:",
      "1232: out_up:",
      "1233:  up_write(&sem_ids(ns).rw_mutex);",
      "1234:  return err;",
      "",
      "[Removed Lines]",
      "1231:  sem_unlock(sma);",
      "",
      "[Added Lines]",
      "1310:  sem_unlock(sma, -1);",
      "",
      "---------------",
      "--- Hunk 20 ---",
      "[Context before]",
      "1340:  struct sem_array *sma;",
      "1341:  struct sem_undo_list *ulp;",
      "1342:  struct sem_undo *un, *new;",
      "1346:  error = get_undo_list(&ulp);",
      "1347:  if (error)",
      "",
      "[Removed Lines]",
      "1343:  int nsems;",
      "1344:  int error;",
      "",
      "[Added Lines]",
      "1422:  int nsems, error;",
      "",
      "---------------",
      "--- Hunk 21 ---",
      "[Context before]",
      "1363:  }",
      "1365:  nsems = sma->sem_nsems;",
      "1367:  rcu_read_unlock();",
      "",
      "[Removed Lines]",
      "1366:  ipc_rcu_getref(sma);",
      "",
      "[Added Lines]",
      "1444:  if (!ipc_rcu_getref(sma)) {",
      "1445:   rcu_read_unlock();",
      "1446:   un = ERR_PTR(-EIDRM);",
      "1447:   goto out;",
      "1448:  }",
      "",
      "---------------",
      "--- Hunk 22 ---",
      "[Context before]",
      "1377:  sem_lock_and_putref(sma);",
      "1378:  if (sma->sem_perm.deleted) {",
      "1380:   kfree(new);",
      "1381:   un = ERR_PTR(-EIDRM);",
      "1382:   goto out;",
      "",
      "[Removed Lines]",
      "1379:   sem_unlock(sma);",
      "",
      "[Added Lines]",
      "1461:   sem_unlock(sma, -1);",
      "",
      "---------------",
      "--- Hunk 23 ---",
      "[Context before]",
      "1404: success:",
      "1405:  spin_unlock(&ulp->lock);",
      "1406:  rcu_read_lock();",
      "1408: out:",
      "1409:  return un;",
      "1410: }",
      "",
      "[Removed Lines]",
      "1407:  sem_unlock(sma);",
      "",
      "[Added Lines]",
      "1489:  sem_unlock(sma, -1);",
      "",
      "---------------",
      "--- Hunk 24 ---",
      "[Context before]",
      "1444:  struct sembuf fast_sops[SEMOPM_FAST];",
      "1445:  struct sembuf* sops = fast_sops, *sop;",
      "1446:  struct sem_undo *un;",
      "1448:  struct sem_queue queue;",
      "1449:  unsigned long jiffies_left = 0;",
      "1450:  struct ipc_namespace *ns;",
      "",
      "[Removed Lines]",
      "1447:  int undos = 0, alter = 0, max;",
      "",
      "[Added Lines]",
      "1529:  int undos = 0, alter = 0, max, locknum;",
      "",
      "---------------",
      "--- Hunk 25 ---",
      "[Context before]",
      "1488:    alter = 1;",
      "1489:  }",
      "1491:  if (undos) {",
      "1492:   un = find_alloc_undo(ns, semid);",
      "1493:   if (IS_ERR(un)) {",
      "1494:    error = PTR_ERR(un);",
      "1495:    goto out_free;",
      "1496:   }",
      "1498:   un = NULL;",
      "1503:  sma = sem_obtain_object_check(ns, semid);",
      "1504:  if (IS_ERR(sma)) {",
      "1507:   error = PTR_ERR(sma);",
      "1508:   goto out_free;",
      "1509:  }",
      "",
      "[Removed Lines]",
      "1497:  } else",
      "1500:  INIT_LIST_HEAD(&tasks);",
      "1502:  rcu_read_lock();",
      "1505:   if (un)",
      "1506:    rcu_read_unlock();",
      "",
      "[Added Lines]",
      "1573:  INIT_LIST_HEAD(&tasks);",
      "1582:  } else {",
      "1584:   rcu_read_lock();",
      "1585:  }",
      "1589:   rcu_read_unlock();",
      "",
      "---------------",
      "--- Hunk 26 ---",
      "[Context before]",
      "1536:  error = -EIDRM;",
      "1555:  error = try_atomic_semop (sma, sops, nsops, un, task_tgid_vnr(current));",
      "1556:  if (error <= 0) {",
      "",
      "[Removed Lines]",
      "1537:  ipc_lock_object(&sma->sem_perm);",
      "1538:  if (un) {",
      "1539:   if (un->semid == -1) {",
      "1540:    rcu_read_unlock();",
      "1541:    goto out_unlock_free;",
      "1542:   } else {",
      "1551:    rcu_read_unlock();",
      "1552:   }",
      "1553:  }",
      "",
      "[Added Lines]",
      "1620:  locknum = sem_lock(sma, sops, nsops);",
      "1621:  if (un && un->semid == -1)",
      "1622:   goto out_unlock_free;",
      "",
      "---------------",
      "--- Hunk 27 ---",
      "[Context before]",
      "1592: sleep_again:",
      "1593:  current->state = TASK_INTERRUPTIBLE;",
      "1596:  if (timeout)",
      "1597:   jiffies_left = schedule_timeout(jiffies_left);",
      "",
      "[Removed Lines]",
      "1594:  sem_unlock(sma);",
      "",
      "[Added Lines]",
      "1663:  sem_unlock(sma, locknum);",
      "",
      "---------------",
      "--- Hunk 28 ---",
      "[Context before]",
      "1613:   goto out_free;",
      "1614:  }",
      "",
      "[Removed Lines]",
      "1616:  sma = sem_obtain_lock(ns, semid);",
      "",
      "[Added Lines]",
      "1685:  sma = sem_obtain_lock(ns, semid, sops, nsops, &locknum);",
      "",
      "---------------",
      "--- Hunk 29 ---",
      "[Context before]",
      "1652:  unlink_queue(sma, &queue);",
      "1654: out_unlock_free:",
      "1656: out_wakeup:",
      "1657:  wake_up_sem_queue_do(&tasks);",
      "1658: out_free:",
      "",
      "[Removed Lines]",
      "1655:  sem_unlock(sma);",
      "",
      "[Added Lines]",
      "1724:  sem_unlock(sma, locknum);",
      "",
      "---------------",
      "--- Hunk 30 ---",
      "[Context before]",
      "1716:   struct sem_array *sma;",
      "1717:   struct sem_undo *un;",
      "1718:   struct list_head tasks;",
      "1722:   rcu_read_lock();",
      "1723:   un = list_entry_rcu(ulp->list_proc.next,",
      "",
      "[Removed Lines]",
      "1719:   int semid;",
      "1720:   int i;",
      "",
      "[Added Lines]",
      "1788:   int semid, i;",
      "",
      "---------------",
      "--- Hunk 31 ---",
      "[Context before]",
      "1726:    semid = -1;",
      "1727:    else",
      "1728:    semid = un->semid;",
      "1732:    break;",
      "1738:    continue;",
      "1740:   un = __lookup_undo(ulp, semid);",
      "1741:   if (un == NULL) {",
      "1746:    continue;",
      "1747:   }",
      "",
      "[Removed Lines]",
      "1729:   rcu_read_unlock();",
      "1731:   if (semid == -1)",
      "1734:   sma = sem_lock_check(tsk->nsproxy->ipc_ns, un->semid);",
      "1737:   if (IS_ERR(sma))",
      "1745:    sem_unlock(sma);",
      "",
      "[Added Lines]",
      "1798:   if (semid == -1) {",
      "1799:    rcu_read_unlock();",
      "1801:   }",
      "1803:   sma = sem_obtain_object_check(tsk->nsproxy->ipc_ns, un->semid);",
      "1805:   if (IS_ERR(sma)) {",
      "1806:    rcu_read_unlock();",
      "1808:   }",
      "1810:   sem_lock(sma, NULL, -1);",
      "1816:    sem_unlock(sma, -1);",
      "",
      "---------------",
      "--- Hunk 32 ---",
      "[Context before]",
      "1783:   INIT_LIST_HEAD(&tasks);",
      "1784:   do_smart_update(sma, NULL, 0, 1, &tasks);",
      "1786:   wake_up_sem_queue_do(&tasks);",
      "1788:   kfree_rcu(un, rcu);",
      "",
      "[Removed Lines]",
      "1785:   sem_unlock(sma);",
      "",
      "[Added Lines]",
      "1856:   sem_unlock(sma, -1);",
      "",
      "---------------"
    ],
    "ipc/util.c||ipc/util.c": [
      "File: ipc/util.c -> ipc/util.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "443: {",
      "445:  if(size > PAGE_SIZE)",
      "446:   out = vmalloc(size);",
      "447:  else",
      "",
      "[Removed Lines]",
      "442: void* ipc_alloc(int size)",
      "444:  void* out;",
      "",
      "[Added Lines]",
      "442: void *ipc_alloc(int size)",
      "444:  void *out;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "479: struct ipc_rcu_hdr",
      "480: {",
      "482:  int is_vmalloc;",
      "483:  void *data[0];",
      "484: };",
      "",
      "[Removed Lines]",
      "481:  int refcount;",
      "",
      "[Added Lines]",
      "481:  atomic_t refcount;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "524: {",
      "530:  if (rcu_use_vmalloc(size)) {",
      "531:   out = vmalloc(HDRLEN_VMALLOC + size);",
      "537:  } else {",
      "538:   out = kmalloc(HDRLEN_KMALLOC + size, GFP_KERNEL);",
      "544:  }",
      "546:  return out;",
      "547: }",
      "550: {",
      "552: }",
      "554: static void ipc_do_vfree(struct work_struct *work)",
      "",
      "[Removed Lines]",
      "523: void* ipc_rcu_alloc(int size)",
      "525:  void* out;",
      "532:   if (out) {",
      "533:    out += HDRLEN_VMALLOC;",
      "534:    container_of(out, struct ipc_rcu_hdr, data)->is_vmalloc = 1;",
      "535:    container_of(out, struct ipc_rcu_hdr, data)->refcount = 1;",
      "536:   }",
      "539:   if (out) {",
      "540:    out += HDRLEN_KMALLOC;",
      "541:    container_of(out, struct ipc_rcu_hdr, data)->is_vmalloc = 0;",
      "542:    container_of(out, struct ipc_rcu_hdr, data)->refcount = 1;",
      "543:   }",
      "549: void ipc_rcu_getref(void *ptr)",
      "551:  container_of(ptr, struct ipc_rcu_hdr, data)->refcount++;",
      "",
      "[Added Lines]",
      "521: void *ipc_rcu_alloc(int size)",
      "523:  void *out;",
      "531:   if (!out)",
      "532:    goto done;",
      "534:   out += HDRLEN_VMALLOC;",
      "535:   container_of(out, struct ipc_rcu_hdr, data)->is_vmalloc = 1;",
      "538:   if (!out)",
      "539:    goto done;",
      "541:   out += HDRLEN_KMALLOC;",
      "542:   container_of(out, struct ipc_rcu_hdr, data)->is_vmalloc = 0;",
      "546:  atomic_set(&container_of(out, struct ipc_rcu_hdr, data)->refcount, 1);",
      "547: done:",
      "551: int ipc_rcu_getref(void *ptr)",
      "553:  return atomic_inc_not_zero(&container_of(ptr, struct ipc_rcu_hdr, data)->refcount);",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "579: void ipc_rcu_putref(void *ptr)",
      "580: {",
      "582:   return;",
      "584:  if (container_of(ptr, struct ipc_rcu_hdr, data)->is_vmalloc) {",
      "",
      "[Removed Lines]",
      "581:  if (--container_of(ptr, struct ipc_rcu_hdr, data)->refcount > 0)",
      "",
      "[Added Lines]",
      "583:  if (!atomic_dec_and_test(&container_of(ptr, struct ipc_rcu_hdr, data)->refcount))",
      "",
      "---------------"
    ],
    "ipc/util.h||ipc/util.h": [
      "File: ipc/util.h -> ipc/util.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "121: void* ipc_rcu_alloc(int size);",
      "123: void ipc_rcu_putref(void *ptr);",
      "125: struct kern_ipc_perm *ipc_lock(struct ipc_ids *, int);",
      "",
      "[Removed Lines]",
      "122: void ipc_rcu_getref(void *ptr);",
      "",
      "[Added Lines]",
      "122: int ipc_rcu_getref(void *ptr);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "cf9d5d78d05bca96df7618dfc3a5ee4414dcae58",
      "candidate_info": {
        "commit_hash": "cf9d5d78d05bca96df7618dfc3a5ee4414dcae58",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/cf9d5d78d05bca96df7618dfc3a5ee4414dcae58",
        "files": [
          "ipc/msg.c",
          "ipc/sem.c",
          "ipc/shm.c",
          "ipc/util.h"
        ],
        "message": "ipc: close open coded spin lock calls\n\nSigned-off-by: Davidlohr Bueso <davidlohr.bueso@hp.com>\nCc: Andi Kleen <andi@firstfloor.org>\nCc: Rik van Riel <riel@redhat.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "ipc/msg.c||ipc/msg.c",
          "ipc/sem.c||ipc/sem.c",
          "ipc/shm.c||ipc/shm.c",
          "ipc/util.h||ipc/util.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "ipc/msg.c||ipc/msg.c",
            "ipc/sem.c||ipc/sem.c",
            "ipc/util.h||ipc/util.h"
          ],
          "candidate": [
            "ipc/msg.c||ipc/msg.c",
            "ipc/sem.c||ipc/sem.c",
            "ipc/util.h||ipc/util.h"
          ]
        }
      },
      "candidate_diff": {
        "ipc/msg.c||ipc/msg.c": [
          "File: ipc/msg.c -> ipc/msg.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "216:  INIT_LIST_HEAD(&msq->q_receivers);",
          "217:  INIT_LIST_HEAD(&msq->q_senders);",
          "220:  rcu_read_unlock();",
          "222:  return msq->q_perm.id;",
          "",
          "[Removed Lines]",
          "219:  spin_unlock(&msq->q_perm.lock);",
          "",
          "[Added Lines]",
          "219:  ipc_unlock_object(&msq->q_perm);",
          "",
          "---------------"
        ],
        "ipc/sem.c||ipc/sem.c": [
          "File: ipc/sem.c -> ipc/sem.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "248:  lock_array:",
          "250:   for (i = 0; i < sma->sem_nsems; i++) {",
          "251:    struct sem *sem = sma->sem_base + i;",
          "252:    spin_unlock_wait(&sem->lock);",
          "",
          "[Removed Lines]",
          "249:   spin_lock(&sma->sem_perm.lock);",
          "",
          "[Added Lines]",
          "249:   ipc_lock_object(&sma->sem_perm);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "259: static inline void sem_unlock(struct sem_array *sma, int locknum)",
          "260: {",
          "261:  if (locknum == -1) {",
          "263:  } else {",
          "264:   struct sem *sem = sma->sem_base + locknum;",
          "265:   spin_unlock(&sem->lock);",
          "",
          "[Removed Lines]",
          "262:   spin_unlock(&sma->sem_perm.lock);",
          "",
          "[Added Lines]",
          "262:   ipc_unlock_object(&sma->sem_perm);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "872:  int i;",
          "876:  list_for_each_entry_safe(un, tu, &sma->list_id, list_id) {",
          "877:   list_del(&un->list_id);",
          "878:   spin_lock(&un->ulp->lock);",
          "",
          "[Removed Lines]",
          "875:  assert_spin_locked(&sma->sem_perm.lock);",
          "",
          "[Added Lines]",
          "875:  ipc_assert_locked_object(&sma->sem_perm);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1071:  curr = &sma->sem_base[semnum];",
          "1074:  list_for_each_entry(un, &sma->list_id, list_id)",
          "1075:   un->semadj[semnum] = 0;",
          "",
          "[Removed Lines]",
          "1073:  assert_spin_locked(&sma->sem_perm.lock);",
          "",
          "[Added Lines]",
          "1073:  ipc_assert_locked_object(&sma->sem_perm);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1199:   for (i = 0; i < nsems; i++)",
          "1200:    sma->sem_base[i].semval = sem_io[i];",
          "1203:   list_for_each_entry(un, &sma->list_id, list_id) {",
          "1204:    for (i = 0; i < nsems; i++)",
          "1205:     un->semadj[i] = 0;",
          "",
          "[Removed Lines]",
          "1202:   assert_spin_locked(&sma->sem_perm.lock);",
          "",
          "[Added Lines]",
          "1202:   ipc_assert_locked_object(&sma->sem_perm);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1496:  new->semid = semid;",
          "1497:  assert_spin_locked(&ulp->lock);",
          "1498:  list_add_rcu(&new->list_proc, &ulp->list_proc);",
          "1500:  list_add(&new->list_id, &sma->list_id);",
          "1501:  un = new;",
          "",
          "[Removed Lines]",
          "1499:  assert_spin_locked(&sma->sem_perm.lock);",
          "",
          "[Added Lines]",
          "1499:  ipc_assert_locked_object(&sma->sem_perm);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1833:   }",
          "1837:   list_del(&un->list_id);",
          "1839:   spin_lock(&ulp->lock);",
          "",
          "[Removed Lines]",
          "1836:   assert_spin_locked(&sma->sem_perm.lock);",
          "",
          "[Added Lines]",
          "1836:   ipc_assert_locked_object(&sma->sem_perm);",
          "",
          "---------------"
        ],
        "ipc/shm.c||ipc/shm.c": [
          "File: ipc/shm.c -> ipc/shm.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "141: static inline void shm_lock_by_ptr(struct shmid_kernel *ipcp)",
          "142: {",
          "143:  rcu_read_lock();",
          "145: }",
          "147: static inline struct shmid_kernel *shm_lock_check(struct ipc_namespace *ns,",
          "",
          "[Removed Lines]",
          "144:  spin_lock(&ipcp->shm_perm.lock);",
          "",
          "[Added Lines]",
          "144:  ipc_lock_object(&ipcp->shm_perm);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "545:  ns->shm_tot += numpages;",
          "546:  error = shp->shm_perm.id;",
          "549:  rcu_read_unlock();",
          "550:  return error;",
          "",
          "[Removed Lines]",
          "548:  spin_unlock(&shp->shm_perm.lock);",
          "",
          "[Added Lines]",
          "548:  ipc_unlock_object(&shp->shm_perm);",
          "",
          "---------------"
        ],
        "ipc/util.h||ipc/util.h": [
          "File: ipc/util.h -> ipc/util.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "177: static inline void ipc_lock_by_ptr(struct kern_ipc_perm *perm)",
          "178: {",
          "179:  rcu_read_lock();",
          "181: }",
          "183: static inline void ipc_unlock(struct kern_ipc_perm *perm)",
          "184: {",
          "186:  rcu_read_unlock();",
          "187: }",
          "",
          "[Removed Lines]",
          "180:  spin_lock(&perm->lock);",
          "185:  spin_unlock(&perm->lock);",
          "",
          "[Added Lines]",
          "180:  ipc_lock_object(perm);",
          "185:  ipc_unlock_object(perm);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "ce857229e0c3adc211944a13a5579ef84fd7b4af",
      "candidate_info": {
        "commit_hash": "ce857229e0c3adc211944a13a5579ef84fd7b4af",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/ce857229e0c3adc211944a13a5579ef84fd7b4af",
        "files": [
          "ipc/sem.c"
        ],
        "message": "ipc: fix GETALL/IPC_RM race for sysv semaphores\n\nWe can step on WARN_ON_ONCE() in sem_getref() if a semaphore is removed\njust as we are about to call sem_getref() from semctl_main(); results\nare not pretty.\n\nWe should fail with -EIDRM, same as if IPC_RM happened while we'd been\ndoing allocation there.  This also expands sem_getref() at its only\ncallsite (and fixed there), while sem_getref_and_unlock() is simply\nkilled off - it has no callers at all.\n\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>\nAcked-by: Davidlohr Bueso <davidlohr.bueso@hp.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "ipc/sem.c||ipc/sem.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "ipc/sem.c||ipc/sem.c"
          ],
          "candidate": [
            "ipc/sem.c||ipc/sem.c"
          ]
        }
      },
      "candidate_diff": {
        "ipc/sem.c||ipc/sem.c": [
          "File: ipc/sem.c -> ipc/sem.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "328:  ipc_rcu_putref(sma);",
          "329: }",
          "337: static inline void sem_putref(struct sem_array *sma)",
          "338: {",
          "339:  sem_lock_and_putref(sma);",
          "340:  sem_unlock(sma, -1);",
          "341: }",
          "353: static inline void sem_rmid(struct ipc_namespace *ns, struct sem_array *s)",
          "354: {",
          "355:  ipc_rmid(&sem_ids(ns), &s->sem_perm);",
          "",
          "[Removed Lines]",
          "331: static inline void sem_getref_and_unlock(struct sem_array *sma)",
          "332: {",
          "333:  WARN_ON_ONCE(!ipc_rcu_getref(sma));",
          "334:  sem_unlock(sma, -1);",
          "335: }",
          "346: static inline void sem_getref(struct sem_array *sma)",
          "347: {",
          "348:  sem_lock(sma, NULL, -1);",
          "349:  WARN_ON_ONCE(!ipc_rcu_getref(sma));",
          "350:  sem_unlock(sma, -1);",
          "351: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1116:   ushort __user *array = p;",
          "1117:   int i;",
          "1119:   if(nsems > SEMMSL_FAST) {",
          "1122:    sem_io = ipc_alloc(sizeof(ushort)*nsems);",
          "1123:    if(sem_io == NULL) {",
          "1124:     sem_putref(sma);",
          "",
          "[Removed Lines]",
          "1120:    sem_getref(sma);",
          "",
          "[Added Lines]",
          "1103:   sem_lock(sma, NULL, -1);",
          "1105:    if (!ipc_rcu_getref(sma)) {",
          "1106:     sem_unlock(sma, -1);",
          "1107:     err = -EIDRM;",
          "1108:     goto out_free;",
          "1109:    }",
          "1110:    sem_unlock(sma, -1);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1131:     err = -EIDRM;",
          "1132:     goto out_free;",
          "1133:    }",
          "1137:   for (i = 0; i < sma->sem_nsems; i++)",
          "1138:    sem_io[i] = sma->sem_base[i].semval;",
          "1139:   sem_unlock(sma, -1);",
          "",
          "[Removed Lines]",
          "1134:   } else",
          "1135:    sem_lock(sma, NULL, -1);",
          "",
          "[Added Lines]",
          "1123:   }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "6e224f94597842c5eb17f1fc2208d20b6f7f7d49",
      "candidate_info": {
        "commit_hash": "6e224f94597842c5eb17f1fc2208d20b6f7f7d49",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/6e224f94597842c5eb17f1fc2208d20b6f7f7d49",
        "files": [
          "ipc/sem.c"
        ],
        "message": "ipc/sem.c: synchronize semop and semctl with IPC_RMID\n\nAfter acquiring the semlock spinlock, operations must test that the\narray is still valid.\n\n - semctl() and exit_sem() would walk stale linked lists (ugly, but\n   should be ok: all lists are empty)\n\n - semtimedop() would sleep forever - and if woken up due to a signal -\n   access memory after free.\n\nThe patch also:\n - standardizes the tests for .deleted, so that all tests in one\n   function leave the function with the same approach.\n - unconditionally tests for .deleted immediately after every call to\n   sem_lock - even it it means that for semctl(GETALL), .deleted will be\n   tested twice.\n\nBoth changes make the review simpler: After every sem_lock, there must\nbe a test of .deleted, followed by a goto to the cleanup code (if the\nfunction uses \"goto cleanup\").\n\nThe only exception is semctl_down(): If sem_ids().rwsem is locked, then\nthe presence in ids->ipcs_idr is equivalent to !.deleted, thus no\nadditional test is required.\n\nSigned-off-by: Manfred Spraul <manfred@colorfullife.com>\nCc: Mike Galbraith <efault@gmx.de>\nAcked-by: Davidlohr Bueso <davidlohr@hp.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "ipc/sem.c||ipc/sem.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "ipc/sem.c||ipc/sem.c"
          ],
          "candidate": [
            "ipc/sem.c||ipc/sem.c"
          ]
        }
      },
      "candidate_diff": {
        "ipc/sem.c||ipc/sem.c": [
          "File: ipc/sem.c -> ipc/sem.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1283:  sem_lock(sma, NULL, -1);",
          "1285:  curr = &sma->sem_base[semnum];",
          "1287:  ipc_assert_locked_object(&sma->sem_perm);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1285:  if (sma->sem_perm.deleted) {",
          "1286:   sem_unlock(sma, -1);",
          "1287:   rcu_read_unlock();",
          "1288:   return -EIDRM;",
          "1289:  }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1336:   int i;",
          "1338:   sem_lock(sma, NULL, -1);",
          "1339:   if(nsems > SEMMSL_FAST) {",
          "1340:    if (!ipc_rcu_getref(sma)) {",
          "1343:     err = -EIDRM;",
          "1345:    }",
          "1346:    sem_unlock(sma, -1);",
          "1347:    rcu_read_unlock();",
          "",
          "[Removed Lines]",
          "1341:     sem_unlock(sma, -1);",
          "1342:     rcu_read_unlock();",
          "1344:     goto out_free;",
          "",
          "[Added Lines]",
          "1345:   if (sma->sem_perm.deleted) {",
          "1346:    err = -EIDRM;",
          "1347:    goto out_unlock;",
          "1348:   }",
          "1352:     goto out_unlock;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1354:    rcu_read_lock();",
          "1355:    sem_lock_and_putref(sma);",
          "1356:    if (sma->sem_perm.deleted) {",
          "1359:     err = -EIDRM;",
          "1361:    }",
          "1362:   }",
          "1363:   for (i = 0; i < sma->sem_nsems; i++)",
          "",
          "[Removed Lines]",
          "1357:     sem_unlock(sma, -1);",
          "1358:     rcu_read_unlock();",
          "1360:     goto out_free;",
          "",
          "[Added Lines]",
          "1366:     goto out_unlock;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1375:   struct sem_undo *un;",
          "1377:   if (!ipc_rcu_getref(sma)) {",
          "1380:   }",
          "1381:   rcu_read_unlock();",
          "",
          "[Removed Lines]",
          "1378:    rcu_read_unlock();",
          "1379:    return -EIDRM;",
          "",
          "[Added Lines]",
          "1384:    err = -EIDRM;",
          "1385:    goto out_rcu_wakeup;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1404:   rcu_read_lock();",
          "1405:   sem_lock_and_putref(sma);",
          "1406:   if (sma->sem_perm.deleted) {",
          "1409:    err = -EIDRM;",
          "1411:   }",
          "1413:   for (i = 0; i < nsems; i++)",
          "",
          "[Removed Lines]",
          "1407:    sem_unlock(sma, -1);",
          "1408:    rcu_read_unlock();",
          "1410:    goto out_free;",
          "",
          "[Added Lines]",
          "1414:    goto out_unlock;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1431:   goto out_rcu_wakeup;",
          "1433:  sem_lock(sma, NULL, -1);",
          "1434:  curr = &sma->sem_base[semnum];",
          "1436:  switch (cmd) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1438:  if (sma->sem_perm.deleted) {",
          "1439:   err = -EIDRM;",
          "1440:   goto out_unlock;",
          "1441:  }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1836:  if (error)",
          "1837:   goto out_rcu_wakeup;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1847:  error = -EIDRM;",
          "1848:  locknum = sem_lock(sma, sops, nsops);",
          "1849:  if (sma->sem_perm.deleted)",
          "1850:   goto out_unlock_free;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1848:  if (un && un->semid == -1)",
          "1849:   goto out_unlock_free;",
          "",
          "[Removed Lines]",
          "1846:  error = -EIDRM;",
          "1847:  locknum = sem_lock(sma, sops, nsops);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "2057:   }",
          "2059:   sem_lock(sma, NULL, -1);",
          "2060:   un = __lookup_undo(ulp, semid);",
          "2061:   if (un == NULL) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2071:   if (sma->sem_perm.deleted) {",
          "2072:    sem_unlock(sma, -1);",
          "2073:    rcu_read_unlock();",
          "2074:    continue;",
          "2075:   }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "73b29505c36eeb4751eccad41f6aad78562521f8",
      "candidate_info": {
        "commit_hash": "73b29505c36eeb4751eccad41f6aad78562521f8",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/73b29505c36eeb4751eccad41f6aad78562521f8",
        "files": [
          "ipc/sem.c"
        ],
        "message": "ipc: sem_putref() does not need the semaphore lock any more\n\nipc_rcu_putref() uses atomics for the refcount, and the games to lock\nand unlock the semaphore just to try to keep the reference counting\nworking are no longer useful.\n\nAcked-by: Davidlohr Bueso <davidlohr.bueso@hp.com>\nCc: Rik van Riel <riel@redhat.com>\nCc: Al Viro <viro@zeniv.linux.org.uk>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "ipc/sem.c||ipc/sem.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "ipc/sem.c||ipc/sem.c"
          ],
          "candidate": [
            "ipc/sem.c||ipc/sem.c"
          ]
        }
      },
      "candidate_diff": {
        "ipc/sem.c||ipc/sem.c": [
          "File: ipc/sem.c -> ipc/sem.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "330: static inline void sem_putref(struct sem_array *sma)",
          "331: {",
          "335: }",
          "337: static inline void sem_rmid(struct ipc_namespace *ns, struct sem_array *s)",
          "",
          "[Removed Lines]",
          "332:  sem_lock_and_putref(sma);",
          "333:  sem_unlock(sma, -1);",
          "334:  rcu_read_unlock();",
          "",
          "[Added Lines]",
          "332:  ipc_rcu_putref(sma);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "e1fd1f490fa4213bd3060efa823a39d299538f72",
      "candidate_info": {
        "commit_hash": "e1fd1f490fa4213bd3060efa823a39d299538f72",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/e1fd1f490fa4213bd3060efa823a39d299538f72",
        "files": [
          "arch/parisc/kernel/sys_parisc32.c",
          "arch/parisc/kernel/syscall_table.S",
          "arch/sparc/kernel/sys_sparc_64.c",
          "include/linux/syscalls.h",
          "ipc/compat.c",
          "ipc/sem.c",
          "ipc/syscall.c"
        ],
        "message": "get rid of union semop in sys_semctl(2) arguments\n\njust have the bugger take unsigned long and deal with SETVAL\ncase (when we use an int member in the union) explicitly.\n\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>",
        "before_after_code_files": [
          "arch/parisc/kernel/sys_parisc32.c||arch/parisc/kernel/sys_parisc32.c",
          "arch/parisc/kernel/syscall_table.S||arch/parisc/kernel/syscall_table.S",
          "arch/sparc/kernel/sys_sparc_64.c||arch/sparc/kernel/sys_sparc_64.c",
          "include/linux/syscalls.h||include/linux/syscalls.h",
          "ipc/compat.c||ipc/compat.c",
          "ipc/sem.c||ipc/sem.c",
          "ipc/syscall.c||ipc/syscall.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "ipc/sem.c||ipc/sem.c"
          ],
          "candidate": [
            "ipc/sem.c||ipc/sem.c"
          ]
        }
      },
      "candidate_diff": {
        "arch/parisc/kernel/sys_parisc32.c||arch/parisc/kernel/sys_parisc32.c": [
          "File: arch/parisc/kernel/sys_parisc32.c -> arch/parisc/kernel/sys_parisc32.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "60:     return -ENOSYS;",
          "61: }",
          "78: asmlinkage long compat_sys_fanotify_mark(int fan_fd, int flags, u32 mask_hi,",
          "79:       u32 mask_lo, int fd,",
          "80:       const char __user *pathname)",
          "",
          "[Removed Lines]",
          "63: asmlinkage long sys32_semctl(int semid, int semnum, int cmd, union semun arg)",
          "64: {",
          "65:         union semun u;",
          "67:         if (cmd == SETVAL) {",
          "72:                 u.val = *((int *)&arg + 1);",
          "73:                 return sys_semctl (semid, semnum, cmd, u);",
          "74:  }",
          "75:  return sys_semctl (semid, semnum, cmd, arg);",
          "76: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "arch/parisc/kernel/syscall_table.S||arch/parisc/kernel/syscall_table.S": [
          "File: arch/parisc/kernel/syscall_table.S -> arch/parisc/kernel/syscall_table.S",
          "--- Hunk 1 ---",
          "[Context before]",
          "282:  ENTRY_COMP(recvmsg)",
          "284:  ENTRY_SAME(semget)",
          "286:  ENTRY_COMP(msgsnd)",
          "287:  ENTRY_COMP(msgrcv)",
          "",
          "[Removed Lines]",
          "285:  ENTRY_DIFF(semctl)",
          "",
          "[Added Lines]",
          "285:  ENTRY_COMP(semctl)",
          "",
          "---------------"
        ],
        "arch/sparc/kernel/sys_sparc_64.c||arch/sparc/kernel/sys_sparc_64.c": [
          "File: arch/sparc/kernel/sys_sparc_64.c -> arch/sparc/kernel/sys_sparc_64.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "353:   case SEMCTL: {",
          "354:    err = sys_semctl(first, second,",
          "355:       (int)third | IPC_64,",
          "357:    goto out;",
          "358:   }",
          "359:   default:",
          "",
          "[Removed Lines]",
          "356:       (union semun) ptr);",
          "",
          "[Added Lines]",
          "356:       (unsigned long) ptr);",
          "",
          "---------------"
        ],
        "include/linux/syscalls.h||include/linux/syscalls.h": [
          "File: include/linux/syscalls.h -> include/linux/syscalls.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "657: asmlinkage long sys_semget(key_t key, int nsems, int semflg);",
          "658: asmlinkage long sys_semop(int semid, struct sembuf __user *sops,",
          "659:     unsigned nsops);",
          "661: asmlinkage long sys_semtimedop(int semid, struct sembuf __user *sops,",
          "662:     unsigned nsops,",
          "663:     const struct timespec __user *timeout);",
          "",
          "[Removed Lines]",
          "660: asmlinkage long sys_semctl(int semid, int semnum, int cmd, union semun arg);",
          "",
          "[Added Lines]",
          "660: asmlinkage long sys_semctl(int semid, int semnum, int cmd, unsigned long arg);",
          "",
          "---------------"
        ],
        "ipc/compat.c||ipc/compat.c": [
          "File: ipc/compat.c -> ipc/compat.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "241: static long do_compat_semctl(int first, int second, int third, u32 pad)",
          "242: {",
          "244:  int err, err2;",
          "245:  struct semid64_ds s64;",
          "246:  struct semid64_ds __user *up64;",
          "",
          "[Removed Lines]",
          "243:  union semun fourth;",
          "",
          "[Added Lines]",
          "243:  unsigned long fourth;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "249:  memset(&s64, 0, sizeof(s64));",
          "251:  if ((third & (~IPC_64)) == SETVAL)",
          "253:  else",
          "255:  switch (third & (~IPC_64)) {",
          "256:  case IPC_INFO:",
          "257:  case IPC_RMID:",
          "",
          "[Removed Lines]",
          "252:   fourth.val = (int) pad;",
          "254:   fourth.__pad = compat_ptr(pad);",
          "",
          "[Added Lines]",
          "252: #ifdef __BIG_ENDIAN",
          "253:   fourth = (unsigned long)pad << 32;",
          "254: #else",
          "255:   fourth = pad;",
          "256: #endif",
          "258:   fourth = (unsigned long)compat_ptr(pad);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "269:  case IPC_STAT:",
          "270:  case SEM_STAT:",
          "271:   up64 = compat_alloc_user_space(sizeof(s64));",
          "273:   err = sys_semctl(first, second, third, fourth);",
          "274:   if (err < 0)",
          "275:    break;",
          "",
          "[Removed Lines]",
          "272:   fourth.__pad = up64;",
          "",
          "[Added Lines]",
          "276:   fourth = (unsigned long)up64;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "295:   if (err)",
          "296:    break;",
          "299:   err = sys_semctl(first, second, third, fourth);",
          "300:   break;",
          "",
          "[Removed Lines]",
          "298:   fourth.__pad = up64;",
          "",
          "[Added Lines]",
          "302:   fourth = (unsigned long)up64;",
          "",
          "---------------"
        ],
        "ipc/sem.c||ipc/sem.c": [
          "File: ipc/sem.c -> ipc/sem.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "799: }",
          "801: static int semctl_nolock(struct ipc_namespace *ns, int semid,",
          "803: {",
          "804:  int err;",
          "805:  struct sem_array *sma;",
          "",
          "[Removed Lines]",
          "802:     int cmd, int version, union semun arg)",
          "",
          "[Added Lines]",
          "802:     int cmd, int version, void __user *p)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "834:   }",
          "835:   max_id = ipc_get_maxid(&sem_ids(ns));",
          "836:   up_read(&sem_ids(ns).rw_mutex);",
          "838:    return -EFAULT;",
          "839:   return (max_id < 0) ? 0: max_id;",
          "840:  }",
          "",
          "[Removed Lines]",
          "837:   if (copy_to_user (arg.__buf, &seminfo, sizeof(struct seminfo)))",
          "",
          "[Added Lines]",
          "837:   if (copy_to_user(p, &seminfo, sizeof(struct seminfo)))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "871:   tbuf.sem_ctime  = sma->sem_ctime;",
          "872:   tbuf.sem_nsems  = sma->sem_nsems;",
          "873:   sem_unlock(sma);",
          "875:    return -EFAULT;",
          "876:   return id;",
          "877:  }",
          "",
          "[Removed Lines]",
          "874:   if (copy_semid_to_user (arg.buf, &tbuf, version))",
          "",
          "[Added Lines]",
          "874:   if (copy_semid_to_user(p, &tbuf, version))",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "883:  return err;",
          "884: }",
          "886: static int semctl_main(struct ipc_namespace *ns, int semid, int semnum,",
          "888: {",
          "889:  struct sem_array *sma;",
          "890:  struct sem* curr;",
          "",
          "[Removed Lines]",
          "887:   int cmd, int version, union semun arg)",
          "",
          "[Added Lines]",
          "886: static int semctl_setval(struct ipc_namespace *ns, int semid, int semnum,",
          "887:   unsigned long arg)",
          "888: {",
          "889:  struct sem_undo *un;",
          "890:  struct sem_array *sma;",
          "891:  struct sem* curr;",
          "892:  int err;",
          "893:  int nsems;",
          "894:  struct list_head tasks;",
          "895:  int val;",
          "896: #if defined(CONFIG_64BIT) && defined(__BIG_ENDIAN)",
          "898:  val = arg >> 32;",
          "899: #else",
          "901:  val = arg;",
          "902: #endif",
          "904:  sma = sem_lock_check(ns, semid);",
          "905:  if (IS_ERR(sma))",
          "906:   return PTR_ERR(sma);",
          "908:  INIT_LIST_HEAD(&tasks);",
          "909:  nsems = sma->sem_nsems;",
          "911:  err = -EACCES;",
          "912:  if (ipcperms(ns, &sma->sem_perm, S_IWUGO))",
          "913:   goto out_unlock;",
          "915:  err = security_sem_semctl(sma, SETVAL);",
          "916:  if (err)",
          "917:   goto out_unlock;",
          "919:  err = -EINVAL;",
          "920:  if(semnum < 0 || semnum >= nsems)",
          "921:   goto out_unlock;",
          "923:  curr = &sma->sem_base[semnum];",
          "925:  err = -ERANGE;",
          "926:  if (val > SEMVMX || val < 0)",
          "927:   goto out_unlock;",
          "929:  assert_spin_locked(&sma->sem_perm.lock);",
          "930:  list_for_each_entry(un, &sma->list_id, list_id)",
          "931:   un->semadj[semnum] = 0;",
          "933:  curr->semval = val;",
          "934:  curr->sempid = task_tgid_vnr(current);",
          "935:  sma->sem_ctime = get_seconds();",
          "937:  do_smart_update(sma, NULL, 0, 0, &tasks);",
          "938:  err = 0;",
          "939: out_unlock:",
          "940:  sem_unlock(sma);",
          "941:  wake_up_sem_queue_do(&tasks);",
          "942:  return err;",
          "943: }",
          "946:   int cmd, void __user *p)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "904:  err = -EACCES;",
          "905:  if (ipcperms(ns, &sma->sem_perm,",
          "907:   goto out_unlock;",
          "909:  err = security_sem_semctl(sma, cmd);",
          "",
          "[Removed Lines]",
          "906:    (cmd == SETVAL || cmd == SETALL) ? S_IWUGO : S_IRUGO))",
          "",
          "[Added Lines]",
          "965:    cmd == SETALL ? S_IWUGO : S_IRUGO))",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "914:  switch (cmd) {",
          "915:  case GETALL:",
          "916:  {",
          "918:   int i;",
          "920:   if(nsems > SEMMSL_FAST) {",
          "",
          "[Removed Lines]",
          "917:   ushort __user *array = arg.array;",
          "",
          "[Added Lines]",
          "976:   ushort __user *array = p;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "957:    }",
          "958:   }",
          "961:    sem_putref(sma);",
          "962:    err = -EFAULT;",
          "963:    goto out_free;",
          "",
          "[Removed Lines]",
          "960:   if (copy_from_user (sem_io, arg.array, nsems*sizeof(ushort))) {",
          "",
          "[Added Lines]",
          "1019:   if (copy_from_user (sem_io, p, nsems*sizeof(ushort))) {",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1012:  case GETZCNT:",
          "1013:   err = count_semzcnt(sma,semnum);",
          "1014:   goto out_unlock;",
          "1036:  }",
          "1037: out_unlock:",
          "1038:  sem_unlock(sma);",
          "",
          "[Removed Lines]",
          "1015:  case SETVAL:",
          "1016:  {",
          "1017:   int val = arg.val;",
          "1018:   struct sem_undo *un;",
          "1020:   err = -ERANGE;",
          "1021:   if (val > SEMVMX || val < 0)",
          "1022:    goto out_unlock;",
          "1024:   assert_spin_locked(&sma->sem_perm.lock);",
          "1025:   list_for_each_entry(un, &sma->list_id, list_id)",
          "1026:    un->semadj[semnum] = 0;",
          "1028:   curr->semval = val;",
          "1029:   curr->sempid = task_tgid_vnr(current);",
          "1030:   sma->sem_ctime = get_seconds();",
          "1032:   do_smart_update(sma, NULL, 0, 0, &tasks);",
          "1033:   err = 0;",
          "1034:   goto out_unlock;",
          "1035:  }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1078: static int semctl_down(struct ipc_namespace *ns, int semid,",
          "1080: {",
          "1081:  struct sem_array *sma;",
          "1082:  int err;",
          "",
          "[Removed Lines]",
          "1079:          int cmd, int version, union semun arg)",
          "",
          "[Added Lines]",
          "1117:          int cmd, int version, void __user *p)",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1084:  struct kern_ipc_perm *ipcp;",
          "1086:  if(cmd == IPC_SET) {",
          "1088:    return -EFAULT;",
          "1089:  }",
          "",
          "[Removed Lines]",
          "1087:   if (copy_semid_from_user(&semid64, arg.buf, version))",
          "",
          "[Added Lines]",
          "1125:   if (copy_semid_from_user(&semid64, p, version))",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1120:  return err;",
          "1121: }",
          "1124: {",
          "1126:  int version;",
          "1127:  struct ipc_namespace *ns;",
          "1129:  if (semid < 0)",
          "1130:   return -EINVAL;",
          "",
          "[Removed Lines]",
          "1123: SYSCALL_DEFINE(semctl)(int semid, int semnum, int cmd, union semun arg)",
          "1125:  int err = -EINVAL;",
          "",
          "[Added Lines]",
          "1161: SYSCALL_DEFINE4(semctl, int, semid, int, semnum, int, cmd, unsigned long, arg)",
          "1165:  void __user *p = (void __user *)arg;",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1137:  case SEM_INFO:",
          "1138:  case IPC_STAT:",
          "1139:  case SEM_STAT:",
          "1142:  case GETALL:",
          "1143:  case GETVAL:",
          "1144:  case GETPID:",
          "1145:  case GETNCNT:",
          "1146:  case GETZCNT:",
          "1148:  case SETALL:",
          "1151:  case IPC_RMID:",
          "1152:  case IPC_SET:",
          "1155:  default:",
          "1156:   return -EINVAL;",
          "1157:  }",
          "1158: }",
          "",
          "[Removed Lines]",
          "1140:   err = semctl_nolock(ns, semid, cmd, version, arg);",
          "1141:   return err;",
          "1147:  case SETVAL:",
          "1149:   err = semctl_main(ns,semid,semnum,cmd,version,arg);",
          "1150:   return err;",
          "1153:   err = semctl_down(ns, semid, cmd, version, arg);",
          "1154:   return err;",
          "1159: asmlinkage long SyS_semctl(int semid, int semnum, int cmd, union semun arg)",
          "1160: {",
          "1161:  return SYSC_semctl((int) semid, (int) semnum, (int) cmd, arg);",
          "1162: }",
          "1163: SYSCALL_ALIAS(sys_semctl, SyS_semctl);",
          "",
          "[Added Lines]",
          "1178:   return semctl_nolock(ns, semid, cmd, version, p);",
          "1185:   return semctl_main(ns, semid, semnum, cmd, p);",
          "1186:  case SETVAL:",
          "1187:   return semctl_setval(ns, semid, semnum, arg);",
          "1190:   return semctl_down(ns, semid, cmd, version, p);",
          "",
          "---------------"
        ],
        "ipc/syscall.c||ipc/syscall.c": [
          "File: ipc/syscall.c -> ipc/syscall.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "33:  case SEMGET:",
          "34:   return sys_semget(first, second, third);",
          "35:  case SEMCTL: {",
          "37:   if (!ptr)",
          "38:    return -EINVAL;",
          "40:    return -EFAULT;",
          "42:  }",
          "44:  case MSGSND:",
          "",
          "[Removed Lines]",
          "36:   union semun fourth;",
          "39:   if (get_user(fourth.__pad, (void __user * __user *) ptr))",
          "41:   return sys_semctl(first, second, third, fourth);",
          "",
          "[Added Lines]",
          "36:   unsigned long arg;",
          "39:   if (get_user(arg, (unsigned long __user *) ptr))",
          "41:   return sys_semctl(first, second, third, arg);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
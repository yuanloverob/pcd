{
  "cve_id": "CVE-2015-8839",
  "cve_desc": "Multiple race conditions in the ext4 filesystem implementation in the Linux kernel before 4.5 allow local users to cause a denial of service (disk corruption) by writing to a page that is associated with a different user's file after unsynchronized hole punching and page-fault handling.",
  "repo": "torvalds/linux",
  "patch_hash": "ea3d7209ca01da209cda6f0dea8be9cc4b7a933b",
  "patch_info": {
    "commit_hash": "ea3d7209ca01da209cda6f0dea8be9cc4b7a933b",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/ea3d7209ca01da209cda6f0dea8be9cc4b7a933b",
    "files": [
      "fs/ext4/ext4.h",
      "fs/ext4/extents.c",
      "fs/ext4/file.c",
      "fs/ext4/inode.c",
      "fs/ext4/super.c",
      "fs/ext4/truncate.h"
    ],
    "message": "ext4: fix races between page faults and hole punching\n\nCurrently, page faults and hole punching are completely unsynchronized.\nThis can result in page fault faulting in a page into a range that we\nare punching after truncate_pagecache_range() has been called and thus\nwe can end up with a page mapped to disk blocks that will be shortly\nfreed. Filesystem corruption will shortly follow. Note that the same\nrace is avoided for truncate by checking page fault offset against\ni_size but there isn't similar mechanism available for punching holes.\n\nFix the problem by creating new rw semaphore i_mmap_sem in inode and\ngrab it for writing over truncate, hole punching, and other functions\nremoving blocks from extent tree and for read over page faults. We\ncannot easily use i_data_sem for this since that ranks below transaction\nstart and we need something ranking above it so that it can be held over\nthe whole truncate / hole punching operation. Also remove various\nworkarounds we had in the code to reduce race window when page fault\ncould have created pages with stale mapping information.\n\nSigned-off-by: Jan Kara <jack@suse.com>\nSigned-off-by: Theodore Ts'o <tytso@mit.edu>",
    "before_after_code_files": [
      "fs/ext4/ext4.h||fs/ext4/ext4.h",
      "fs/ext4/extents.c||fs/ext4/extents.c",
      "fs/ext4/file.c||fs/ext4/file.c",
      "fs/ext4/inode.c||fs/ext4/inode.c",
      "fs/ext4/super.c||fs/ext4/super.c",
      "fs/ext4/truncate.h||fs/ext4/truncate.h"
    ]
  },
  "patch_diff": {
    "fs/ext4/ext4.h||fs/ext4/ext4.h": [
      "File: fs/ext4/ext4.h -> fs/ext4/ext4.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "912:  struct rw_semaphore i_data_sem;",
      "913:  struct inode vfs_inode;",
      "914:  struct jbd2_inode *jinode;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "921:  struct rw_semaphore i_mmap_sem;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "2484: extern int ext4_zero_partial_blocks(handle_t *handle, struct inode *inode,",
      "2485:         loff_t lstart, loff_t lend);",
      "2486: extern int ext4_page_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf);",
      "2487: extern qsize_t *ext4_get_reserved_space(struct inode *inode);",
      "2488: extern void ext4_da_update_reserve_space(struct inode *inode,",
      "2489:      int used, int quota_claim);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2496: extern int ext4_filemap_fault(struct vm_area_struct *vma, struct vm_fault *vmf);",
      "",
      "---------------"
    ],
    "fs/ext4/extents.c||fs/ext4/extents.c": [
      "File: fs/ext4/extents.c -> fs/ext4/extents.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "4770:  int partial_begin, partial_end;",
      "4771:  loff_t start, end;",
      "4772:  ext4_lblk_t lblk;",
      "4774:  unsigned int blkbits = inode->i_blkbits;",
      "4776:  trace_ext4_zero_range(inode, offset, len, mode);",
      "",
      "[Removed Lines]",
      "4773:  struct address_space *mapping = inode->i_mapping;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "4785:    return ret;",
      "4786:  }",
      "",
      "[Removed Lines]",
      "4792:  if (mapping->nrpages && mapping_tagged(mapping, PAGECACHE_TAG_DIRTY)) {",
      "4793:   ret = filemap_write_and_wait_range(mapping, offset,",
      "4794:          offset + len - 1);",
      "4795:   if (ret)",
      "4796:    return ret;",
      "4797:  }",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "4856:   flags |= (EXT4_GET_BLOCKS_CONVERT_UNWRITTEN |",
      "4857:      EXT4_EX_NOCACHE);",
      "4864:   ext4_inode_block_unlocked_dio(inode);",
      "4865:   inode_dio_wait(inode);",
      "4867:   ret = ext4_alloc_file_blocks(file, lblk, max_blocks, new_size,",
      "4868:           flags, mode);",
      "4869:   if (ret)",
      "4870:    goto out_dio;",
      "4871:  }",
      "",
      "[Removed Lines]",
      "4860:   truncate_pagecache_range(inode, start, end - 1);",
      "4861:   inode->i_mtime = inode->i_ctime = ext4_current_time(inode);",
      "",
      "[Added Lines]",
      "4855:   down_write(&EXT4_I(inode)->i_mmap_sem);",
      "4857:   truncate_pagecache_range(inode, start, end - 1);",
      "4858:   inode->i_mtime = inode->i_ctime = ext4_current_time(inode);",
      "4862:   up_write(&EXT4_I(inode)->i_mmap_sem);",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "5524:   goto out_mutex;",
      "5525:  }",
      "5530:  ext4_inode_block_unlocked_dio(inode);",
      "5531:  inode_dio_wait(inode);",
      "5533:  credits = ext4_writepage_trans_blocks(inode);",
      "5534:  handle = ext4_journal_start(inode, EXT4_HT_TRUNCATE, credits);",
      "5535:  if (IS_ERR(handle)) {",
      "5536:   ret = PTR_ERR(handle);",
      "5538:  }",
      "5540:  down_write(&EXT4_I(inode)->i_data_sem);",
      "",
      "[Removed Lines]",
      "5527:  truncate_pagecache(inode, ioffset);",
      "5537:   goto out_dio;",
      "",
      "[Added Lines]",
      "5529:  down_write(&EXT4_I(inode)->i_mmap_sem);",
      "5530:  truncate_pagecache(inode, ioffset);",
      "5536:   goto out_mmap;",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "5574: out_stop:",
      "5575:  ext4_journal_stop(handle);",
      "5577:  ext4_inode_resume_unlocked_dio(inode);",
      "5578: out_mutex:",
      "5579:  mutex_unlock(&inode->i_mutex);",
      "",
      "[Removed Lines]",
      "5576: out_dio:",
      "",
      "[Added Lines]",
      "5575: out_mmap:",
      "5576:  up_write(&EXT4_I(inode)->i_mmap_sem);",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "5660:   goto out_mutex;",
      "5661:  }",
      "5666:  ext4_inode_block_unlocked_dio(inode);",
      "5667:  inode_dio_wait(inode);",
      "5669:  credits = ext4_writepage_trans_blocks(inode);",
      "5670:  handle = ext4_journal_start(inode, EXT4_HT_TRUNCATE, credits);",
      "5671:  if (IS_ERR(handle)) {",
      "5672:   ret = PTR_ERR(handle);",
      "5674:  }",
      "",
      "[Removed Lines]",
      "5663:  truncate_pagecache(inode, ioffset);",
      "5673:   goto out_dio;",
      "",
      "[Added Lines]",
      "5671:  down_write(&EXT4_I(inode)->i_mmap_sem);",
      "5672:  truncate_pagecache(inode, ioffset);",
      "5678:   goto out_mmap;",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "5742: out_stop:",
      "5743:  ext4_journal_stop(handle);",
      "5745:  ext4_inode_resume_unlocked_dio(inode);",
      "5746: out_mutex:",
      "5747:  mutex_unlock(&inode->i_mutex);",
      "",
      "[Removed Lines]",
      "5744: out_dio:",
      "",
      "[Added Lines]",
      "5749: out_mmap:",
      "5750:  up_write(&EXT4_I(inode)->i_mmap_sem);",
      "",
      "---------------"
    ],
    "fs/ext4/file.c||fs/ext4/file.c": [
      "File: fs/ext4/file.c -> fs/ext4/file.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "209: {",
      "210:  int result;",
      "211:  handle_t *handle = NULL;",
      "213:  bool write = vmf->flags & FAULT_FLAG_WRITE;",
      "215:  if (write) {",
      "216:   sb_start_pagefault(sb);",
      "217:   file_update_time(vma->vm_file);",
      "218:   handle = ext4_journal_start_sb(sb, EXT4_HT_WRITE_PAGE,",
      "219:       EXT4_DATA_TRANS_BLOCKS(sb));",
      "222:  if (IS_ERR(handle))",
      "223:   result = VM_FAULT_SIGBUS;",
      "",
      "[Removed Lines]",
      "212:  struct super_block *sb = file_inode(vma->vm_file)->i_sb;",
      "220:  }",
      "",
      "[Added Lines]",
      "212:  struct inode *inode = file_inode(vma->vm_file);",
      "213:  struct super_block *sb = inode->i_sb;",
      "219:   down_read(&EXT4_I(inode)->i_mmap_sem);",
      "222:  } else",
      "223:   down_read(&EXT4_I(inode)->i_mmap_sem);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "228:  if (write) {",
      "229:   if (!IS_ERR(handle))",
      "230:    ext4_journal_stop(handle);",
      "231:   sb_end_pagefault(sb);",
      "234:  return result;",
      "235: }",
      "",
      "[Removed Lines]",
      "232:  }",
      "",
      "[Added Lines]",
      "234:   up_read(&EXT4_I(inode)->i_mmap_sem);",
      "236:  } else",
      "237:   up_read(&EXT4_I(inode)->i_mmap_sem);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "246:  if (write) {",
      "247:   sb_start_pagefault(sb);",
      "248:   file_update_time(vma->vm_file);",
      "249:   handle = ext4_journal_start_sb(sb, EXT4_HT_WRITE_PAGE,",
      "250:     ext4_chunk_trans_blocks(inode,",
      "251:        PMD_SIZE / PAGE_SIZE));",
      "254:  if (IS_ERR(handle))",
      "255:   result = VM_FAULT_SIGBUS;",
      "",
      "[Removed Lines]",
      "252:  }",
      "",
      "[Added Lines]",
      "254:   down_read(&EXT4_I(inode)->i_mmap_sem);",
      "258:  } else",
      "259:   down_read(&EXT4_I(inode)->i_mmap_sem);",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "260:  if (write) {",
      "261:   if (!IS_ERR(handle))",
      "262:    ext4_journal_stop(handle);",
      "263:   sb_end_pagefault(sb);",
      "266:  return result;",
      "267: }",
      "269: static int ext4_dax_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf)",
      "270: {",
      "273: }",
      "275: static const struct vm_operations_struct ext4_dax_vm_ops = {",
      "276:  .fault  = ext4_dax_fault,",
      "277:  .pmd_fault = ext4_dax_pmd_fault,",
      "278:  .page_mkwrite = ext4_dax_mkwrite,",
      "280: };",
      "281: #else",
      "282: #define ext4_dax_vm_ops ext4_file_vm_ops",
      "283: #endif",
      "285: static const struct vm_operations_struct ext4_file_vm_ops = {",
      "287:  .map_pages = filemap_map_pages,",
      "288:  .page_mkwrite   = ext4_page_mkwrite,",
      "289: };",
      "",
      "[Removed Lines]",
      "264:  }",
      "271:  return dax_mkwrite(vma, vmf, ext4_get_block_dax,",
      "272:     ext4_end_io_unwritten);",
      "279:  .pfn_mkwrite = dax_pfn_mkwrite,",
      "286:  .fault  = filemap_fault,",
      "",
      "[Added Lines]",
      "270:   up_read(&EXT4_I(inode)->i_mmap_sem);",
      "272:  } else",
      "273:   up_read(&EXT4_I(inode)->i_mmap_sem);",
      "280:  int err;",
      "281:  struct inode *inode = file_inode(vma->vm_file);",
      "283:  sb_start_pagefault(inode->i_sb);",
      "284:  file_update_time(vma->vm_file);",
      "285:  down_read(&EXT4_I(inode)->i_mmap_sem);",
      "286:  err = __dax_mkwrite(vma, vmf, ext4_get_block_dax,",
      "287:        ext4_end_io_unwritten);",
      "288:  up_read(&EXT4_I(inode)->i_mmap_sem);",
      "289:  sb_end_pagefault(inode->i_sb);",
      "291:  return err;",
      "292: }",
      "303: static int ext4_dax_pfn_mkwrite(struct vm_area_struct *vma,",
      "304:     struct vm_fault *vmf)",
      "305: {",
      "306:  struct inode *inode = file_inode(vma->vm_file);",
      "307:  struct super_block *sb = inode->i_sb;",
      "308:  int ret = VM_FAULT_NOPAGE;",
      "309:  loff_t size;",
      "311:  sb_start_pagefault(sb);",
      "312:  file_update_time(vma->vm_file);",
      "313:  down_read(&EXT4_I(inode)->i_mmap_sem);",
      "314:  size = (i_size_read(inode) + PAGE_SIZE - 1) >> PAGE_SHIFT;",
      "315:  if (vmf->pgoff >= size)",
      "316:   ret = VM_FAULT_SIGBUS;",
      "317:  up_read(&EXT4_I(inode)->i_mmap_sem);",
      "318:  sb_end_pagefault(sb);",
      "320:  return ret;",
      "327:  .pfn_mkwrite = ext4_dax_pfn_mkwrite,",
      "334:  .fault  = ext4_filemap_fault,",
      "",
      "---------------"
    ],
    "fs/ext4/inode.c||fs/ext4/inode.c": [
      "File: fs/ext4/inode.c -> fs/ext4/inode.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "3624:  }",
      "3626:  first_block_offset = round_up(offset, sb->s_blocksize);",
      "3627:  last_block_offset = round_down((offset + length), sb->s_blocksize) - 1;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "3627:  ext4_inode_block_unlocked_dio(inode);",
      "3628:  inode_dio_wait(inode);",
      "3634:  down_write(&EXT4_I(inode)->i_mmap_sem);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "3631:   truncate_pagecache_range(inode, first_block_offset,",
      "3632:       last_block_offset);",
      "3638:  if (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))",
      "3639:   credits = ext4_writepage_trans_blocks(inode);",
      "3640:  else",
      "",
      "[Removed Lines]",
      "3635:  ext4_inode_block_unlocked_dio(inode);",
      "3636:  inode_dio_wait(inode);",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "3680:  if (IS_SYNC(inode))",
      "3681:   ext4_handle_sync(handle);",
      "3688:  inode->i_mtime = inode->i_ctime = ext4_current_time(inode);",
      "3689:  ext4_mark_inode_dirty(handle, inode);",
      "3690: out_stop:",
      "3691:  ext4_journal_stop(handle);",
      "3692: out_dio:",
      "3693:  ext4_inode_resume_unlocked_dio(inode);",
      "3694: out_mutex:",
      "3695:  mutex_unlock(&inode->i_mutex);",
      "",
      "[Removed Lines]",
      "3684:  if (last_block_offset > first_block_offset)",
      "3685:   truncate_pagecache_range(inode, first_block_offset,",
      "3686:       last_block_offset);",
      "",
      "[Added Lines]",
      "3693:  up_write(&EXT4_I(inode)->i_mmap_sem);",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "4823:    } else",
      "4824:     ext4_wait_for_tail_page_commit(inode);",
      "4825:   }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "4827:   down_write(&EXT4_I(inode)->i_mmap_sem);",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "4830:   truncate_pagecache(inode, inode->i_size);",
      "4831:   if (shrink)",
      "4832:    ext4_truncate(inode);",
      "4833:  }",
      "4835:  if (!rc) {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "4835:   up_write(&EXT4_I(inode)->i_mmap_sem);",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "5279:  sb_start_pagefault(inode->i_sb);",
      "5280:  file_update_time(vma->vm_file);",
      "5282:  if (test_opt(inode->i_sb, DELALLOC) &&",
      "5283:      !ext4_should_journal_data(inode) &&",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "5285:  down_read(&EXT4_I(inode)->i_mmap_sem);",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "5347: out_ret:",
      "5348:  ret = block_page_mkwrite_return(ret);",
      "5349: out:",
      "5350:  sb_end_pagefault(inode->i_sb);",
      "5351:  return ret;",
      "5352: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "5355:  up_read(&EXT4_I(inode)->i_mmap_sem);",
      "5360: int ext4_filemap_fault(struct vm_area_struct *vma, struct vm_fault *vmf)",
      "5361: {",
      "5362:  struct inode *inode = file_inode(vma->vm_file);",
      "5363:  int err;",
      "5365:  down_read(&EXT4_I(inode)->i_mmap_sem);",
      "5366:  err = filemap_fault(vma, vmf);",
      "5367:  up_read(&EXT4_I(inode)->i_mmap_sem);",
      "5369:  return err;",
      "5370: }",
      "",
      "---------------"
    ],
    "fs/ext4/super.c||fs/ext4/super.c": [
      "File: fs/ext4/super.c -> fs/ext4/super.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "958:  INIT_LIST_HEAD(&ei->i_orphan);",
      "959:  init_rwsem(&ei->xattr_sem);",
      "960:  init_rwsem(&ei->i_data_sem);",
      "961:  inode_init_once(&ei->vfs_inode);",
      "962: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "961:  init_rwsem(&ei->i_mmap_sem);",
      "",
      "---------------"
    ],
    "fs/ext4/truncate.h||fs/ext4/truncate.h": [
      "File: fs/ext4/truncate.h -> fs/ext4/truncate.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "11: static inline void ext4_truncate_failed_write(struct inode *inode)",
      "12: {",
      "13:  truncate_inode_pages(inode->i_mapping, inode->i_size);",
      "14:  ext4_truncate(inode);",
      "15: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "13:  down_write(&EXT4_I(inode)->i_mmap_sem);",
      "16:  up_write(&EXT4_I(inode)->i_mmap_sem);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "ed923b5776a2d2e949bd5b20f3956d68f3c826b7",
      "candidate_info": {
        "commit_hash": "ed923b5776a2d2e949bd5b20f3956d68f3c826b7",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/ed923b5776a2d2e949bd5b20f3956d68f3c826b7",
        "files": [
          "fs/ext4/ext4.h",
          "fs/ext4/file.c",
          "fs/ext4/inode.c"
        ],
        "message": "ext4: add ext4_get_block_dax()\n\nDAX wants different semantics from any currently-existing ext4 get_block\ncallback.  Unlike ext4_get_block_write(), it needs to honour the\n'create' flag, and unlike ext4_get_block(), it needs to be able to\nreturn unwritten extents.  So introduce a new ext4_get_block_dax() which\nhas those semantics.\n\nWe could also change ext4_get_block_write() to honour the 'create' flag,\nbut that might have consequences on other users that I do not currently\nunderstand.\n\nSigned-off-by: Matthew Wilcox <willy@linux.intel.com>\nCc: Theodore Ts'o <tytso@mit.edu>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "fs/ext4/ext4.h||fs/ext4/ext4.h",
          "fs/ext4/file.c||fs/ext4/file.c",
          "fs/ext4/inode.c||fs/ext4/inode.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/ext4/ext4.h||fs/ext4/ext4.h",
            "fs/ext4/file.c||fs/ext4/file.c",
            "fs/ext4/inode.c||fs/ext4/inode.c"
          ],
          "candidate": [
            "fs/ext4/ext4.h||fs/ext4/ext4.h",
            "fs/ext4/file.c||fs/ext4/file.c",
            "fs/ext4/inode.c||fs/ext4/inode.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/ext4/ext4.h||fs/ext4/ext4.h": [
          "File: fs/ext4/ext4.h -> fs/ext4/ext4.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "2272: struct buffer_head *ext4_bread(handle_t *, struct inode *, ext4_lblk_t, int);",
          "2273: int ext4_get_block_write(struct inode *inode, sector_t iblock,",
          "2274:     struct buffer_head *bh_result, int create);",
          "2275: int ext4_get_block(struct inode *inode, sector_t iblock,",
          "2276:     struct buffer_head *bh_result, int create);",
          "2277: int ext4_da_get_block_prep(struct inode *inode, sector_t iblock,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2275: int ext4_get_block_dax(struct inode *inode, sector_t iblock,",
          "2276:     struct buffer_head *bh_result, int create);",
          "",
          "---------------"
        ],
        "fs/ext4/file.c||fs/ext4/file.c": [
          "File: fs/ext4/file.c -> fs/ext4/file.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "208: static int ext4_dax_fault(struct vm_area_struct *vma, struct vm_fault *vmf)",
          "209: {",
          "211: }",
          "213: static int ext4_dax_pmd_fault(struct vm_area_struct *vma, unsigned long addr,",
          "214:       pmd_t *pmd, unsigned int flags)",
          "215: {",
          "217:     ext4_end_io_unwritten);",
          "218: }",
          "220: static int ext4_dax_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf)",
          "221: {",
          "223:     ext4_end_io_unwritten);",
          "224: }",
          "",
          "[Removed Lines]",
          "210:  return dax_fault(vma, vmf, ext4_get_block_write, ext4_end_io_unwritten);",
          "216:  return dax_pmd_fault(vma, addr, pmd, flags, ext4_get_block_write,",
          "222:  return dax_mkwrite(vma, vmf, ext4_get_block_write,",
          "",
          "[Added Lines]",
          "210:  return dax_fault(vma, vmf, ext4_get_block_dax, ext4_end_io_unwritten);",
          "216:  return dax_pmd_fault(vma, addr, pmd, flags, ext4_get_block_dax,",
          "222:  return dax_mkwrite(vma, vmf, ext4_get_block_dax,",
          "",
          "---------------"
        ],
        "fs/ext4/inode.c||fs/ext4/inode.c": [
          "File: fs/ext4/inode.c -> fs/ext4/inode.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3021:           EXT4_GET_BLOCKS_NO_LOCK);",
          "3022: }",
          "3024: static void ext4_end_io_dio(struct kiocb *iocb, loff_t offset,",
          "3025:        ssize_t size, void *private)",
          "3026: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3024: int ext4_get_block_dax(struct inode *inode, sector_t iblock,",
          "3025:      struct buffer_head *bh_result, int create)",
          "3026: {",
          "3027:  int flags = EXT4_GET_BLOCKS_PRE_IO | EXT4_GET_BLOCKS_UNWRIT_EXT;",
          "3028:  if (create)",
          "3029:   flags |= EXT4_GET_BLOCKS_CREATE;",
          "3030:  ext4_debug(\"ext4_get_block_dax: inode %lu, create flag %d\\n\",",
          "3031:      inode->i_ino, create);",
          "3032:  return _ext4_get_block(inode, iblock, bh_result, flags);",
          "3033: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "ba5843f51d468644b094674c0317c9ab95632caa",
      "candidate_info": {
        "commit_hash": "ba5843f51d468644b094674c0317c9ab95632caa",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/ba5843f51d468644b094674c0317c9ab95632caa",
        "files": [
          "fs/ext4/ext4.h",
          "fs/ext4/file.c",
          "fs/ext4/inode.c"
        ],
        "message": "ext4: use pre-zeroed blocks for DAX page faults\n\nMake DAX fault path use pre-zeroed blocks to avoid races with extent\nconversion and zeroing when two page faults to the same block happen.\n\nSigned-off-by: Jan Kara <jack@suse.com>\nSigned-off-by: Theodore Ts'o <tytso@mit.edu>",
        "before_after_code_files": [
          "fs/ext4/ext4.h||fs/ext4/ext4.h",
          "fs/ext4/file.c||fs/ext4/file.c",
          "fs/ext4/inode.c||fs/ext4/inode.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/ext4/ext4.h||fs/ext4/ext4.h",
            "fs/ext4/file.c||fs/ext4/file.c",
            "fs/ext4/inode.c||fs/ext4/inode.c"
          ],
          "candidate": [
            "fs/ext4/ext4.h||fs/ext4/ext4.h",
            "fs/ext4/file.c||fs/ext4/file.c",
            "fs/ext4/inode.c||fs/ext4/inode.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/ext4/ext4.h||fs/ext4/ext4.h": [
          "File: fs/ext4/ext4.h -> fs/ext4/ext4.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "2452: struct buffer_head *ext4_bread(handle_t *, struct inode *, ext4_lblk_t, int);",
          "2453: int ext4_get_block_write(struct inode *inode, sector_t iblock,",
          "2454:     struct buffer_head *bh_result, int create);",
          "2457: int ext4_get_block(struct inode *inode, sector_t iblock,",
          "2458:     struct buffer_head *bh_result, int create);",
          "2459: int ext4_da_get_block_prep(struct inode *inode, sector_t iblock,",
          "",
          "[Removed Lines]",
          "2455: int ext4_get_block_dax(struct inode *inode, sector_t iblock,",
          "2456:     struct buffer_head *bh_result, int create);",
          "",
          "[Added Lines]",
          "2455: int ext4_dax_mmap_get_block(struct inode *inode, sector_t iblock,",
          "2456:        struct buffer_head *bh_result, int create);",
          "",
          "---------------"
        ],
        "fs/ext4/file.c||fs/ext4/file.c": [
          "File: fs/ext4/file.c -> fs/ext4/file.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "193: }",
          "195: #ifdef CONFIG_FS_DAX",
          "208: static int ext4_dax_fault(struct vm_area_struct *vma, struct vm_fault *vmf)",
          "209: {",
          "210:  int result;",
          "",
          "[Removed Lines]",
          "196: static void ext4_end_io_unwritten(struct buffer_head *bh, int uptodate)",
          "197: {",
          "198:  struct inode *inode = bh->b_assoc_map->host;",
          "200:  loff_t offset = (loff_t)(uintptr_t)bh->b_private << inode->i_blkbits;",
          "201:  int err;",
          "202:  if (!uptodate)",
          "203:   return;",
          "204:  WARN_ON(!buffer_unwritten(bh));",
          "205:  err = ext4_convert_unwritten_extents(NULL, inode, offset, bh->b_size);",
          "206: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "225:  if (IS_ERR(handle))",
          "226:   result = VM_FAULT_SIGBUS;",
          "227:  else",
          "231:  if (write) {",
          "232:   if (!IS_ERR(handle))",
          "",
          "[Removed Lines]",
          "228:   result = __dax_fault(vma, vmf, ext4_get_block_dax,",
          "229:       ext4_end_io_unwritten);",
          "",
          "[Added Lines]",
          "216:   result = __dax_fault(vma, vmf, ext4_dax_mmap_get_block, NULL);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "262:   result = VM_FAULT_SIGBUS;",
          "263:  else",
          "264:   result = __dax_pmd_fault(vma, addr, pmd, flags,",
          "267:  if (write) {",
          "268:   if (!IS_ERR(handle))",
          "",
          "[Removed Lines]",
          "265:     ext4_get_block_dax, ext4_end_io_unwritten);",
          "",
          "[Added Lines]",
          "252:     ext4_dax_mmap_get_block, NULL);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "283:  sb_start_pagefault(inode->i_sb);",
          "284:  file_update_time(vma->vm_file);",
          "285:  down_read(&EXT4_I(inode)->i_mmap_sem);",
          "288:  up_read(&EXT4_I(inode)->i_mmap_sem);",
          "289:  sb_end_pagefault(inode->i_sb);",
          "",
          "[Removed Lines]",
          "286:  err = __dax_mkwrite(vma, vmf, ext4_get_block_dax,",
          "287:        ext4_end_io_unwritten);",
          "",
          "[Added Lines]",
          "273:  err = __dax_mkwrite(vma, vmf, ext4_dax_mmap_get_block, NULL);",
          "",
          "---------------"
        ],
        "fs/ext4/inode.c||fs/ext4/inode.c": [
          "File: fs/ext4/inode.c -> fs/ext4/inode.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "724:   map_bh(bh, inode->i_sb, map.m_pblk);",
          "725:   bh->b_state = (bh->b_state & ~EXT4_MAP_FLAGS) | map.m_flags;",
          "736:   if (io_end && io_end->flag & EXT4_IO_END_UNWRITTEN)",
          "737:    set_buffer_defer_completion(bh);",
          "738:   bh->b_size = inode->i_sb->s_blocksize * map.m_len;",
          "",
          "[Removed Lines]",
          "726:   if (IS_DAX(inode) && buffer_unwritten(bh)) {",
          "732:    WARN_ON_ONCE(io_end);",
          "733:    bh->b_assoc_map = inode->i_mapping;",
          "734:    bh->b_private = (void *)(unsigned long)iblock;",
          "735:   }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3097:  return ret;",
          "3098: }",
          "3102: {",
          "3108:      inode->i_ino, create);",
          "3110: }",
          "3112: static void ext4_end_io_dio(struct kiocb *iocb, loff_t offset,",
          "3113:        ssize_t size, void *private)",
          "",
          "[Removed Lines]",
          "3100: int ext4_get_block_dax(struct inode *inode, sector_t iblock,",
          "3101:      struct buffer_head *bh_result, int create)",
          "3103:  int flags = EXT4_GET_BLOCKS_PRE_IO | EXT4_GET_BLOCKS_UNWRIT_EXT;",
          "3105:  if (create)",
          "3106:   flags |= EXT4_GET_BLOCKS_CREATE;",
          "3107:  ext4_debug(\"ext4_get_block_dax: inode %lu, create flag %d\\n\",",
          "3109:  return _ext4_get_block(inode, iblock, bh_result, flags);",
          "",
          "[Added Lines]",
          "3090: #ifdef CONFIG_FS_DAX",
          "3091: int ext4_dax_mmap_get_block(struct inode *inode, sector_t iblock,",
          "3092:        struct buffer_head *bh_result, int create)",
          "3094:  int ret, err;",
          "3095:  int credits;",
          "3096:  struct ext4_map_blocks map;",
          "3097:  handle_t *handle = NULL;",
          "3098:  int flags = 0;",
          "3100:  ext4_debug(\"ext4_dax_mmap_get_block: inode %lu, create flag %d\\n\",",
          "3102:  map.m_lblk = iblock;",
          "3103:  map.m_len = bh_result->b_size >> inode->i_blkbits;",
          "3104:  credits = ext4_chunk_trans_blocks(inode, map.m_len);",
          "3105:  if (create) {",
          "3106:   flags |= EXT4_GET_BLOCKS_PRE_IO | EXT4_GET_BLOCKS_CREATE_ZERO;",
          "3107:   handle = ext4_journal_start(inode, EXT4_HT_MAP_BLOCKS, credits);",
          "3108:   if (IS_ERR(handle)) {",
          "3109:    ret = PTR_ERR(handle);",
          "3110:    return ret;",
          "3111:   }",
          "3112:  }",
          "3114:  ret = ext4_map_blocks(handle, inode, &map, flags);",
          "3115:  if (create) {",
          "3116:   err = ext4_journal_stop(handle);",
          "3117:   if (ret >= 0 && err < 0)",
          "3118:    ret = err;",
          "3119:  }",
          "3120:  if (ret <= 0)",
          "3121:   goto out;",
          "3122:  if (map.m_flags & EXT4_MAP_UNWRITTEN) {",
          "3123:   int err2;",
          "3132:   handle = ext4_journal_start(inode, EXT4_HT_MAP_BLOCKS, credits);",
          "3133:   if (IS_ERR(handle)) {",
          "3134:    ret = PTR_ERR(handle);",
          "3135:    goto out;",
          "3136:   }",
          "3138:   err = ext4_map_blocks(handle, inode, &map,",
          "3139:         EXT4_GET_BLOCKS_CONVERT | EXT4_GET_BLOCKS_CREATE_ZERO);",
          "3140:   if (err < 0)",
          "3141:    ret = err;",
          "3142:   err2 = ext4_journal_stop(handle);",
          "3143:   if (err2 < 0 && ret > 0)",
          "3144:    ret = err2;",
          "3145:  }",
          "3146: out:",
          "3147:  WARN_ON_ONCE(ret == 0 && create);",
          "3148:  if (ret > 0) {",
          "3149:   map_bh(bh_result, inode->i_sb, map.m_pblk);",
          "3150:   bh_result->b_state = (bh_result->b_state & ~EXT4_MAP_FLAGS) |",
          "3151:      map.m_flags;",
          "3156:   bh_result->b_state &= ~(1 << BH_New);",
          "3157:   bh_result->b_size = map.m_len << inode->i_blkbits;",
          "3158:   ret = 0;",
          "3159:  }",
          "3160:  return ret;",
          "3162: #endif",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "331573febb6a224bc50322e3670da326cb7f4cfc",
      "candidate_info": {
        "commit_hash": "331573febb6a224bc50322e3670da326cb7f4cfc",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/331573febb6a224bc50322e3670da326cb7f4cfc",
        "files": [
          "fs/ext4/ext4.h",
          "fs/ext4/extents.c",
          "include/trace/events/ext4.h"
        ],
        "message": "ext4: Add support FALLOC_FL_INSERT_RANGE for fallocate\n\nThis patch implements fallocate's FALLOC_FL_INSERT_RANGE for Ext4.\n\n1) Make sure that both offset and len are block size aligned.\n2) Update the i_size of inode by len bytes.\n3) Compute the file's logical block number against offset. If the computed\n   block number is not the starting block of the extent, split the extent\n   such that the block number is the starting block of the extent.\n4) Shift all the extents which are lying between [offset, last allocated extent]\n   towards right by len bytes. This step will make a hole of len bytes\n   at offset.\n\nSigned-off-by: Namjae Jeon <namjae.jeon@samsung.com>\nSigned-off-by: Ashish Sangwan <a.sangwan@samsung.com>",
        "before_after_code_files": [
          "fs/ext4/ext4.h||fs/ext4/ext4.h",
          "fs/ext4/extents.c||fs/ext4/extents.c",
          "include/trace/events/ext4.h||include/trace/events/ext4.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/ext4/ext4.h||fs/ext4/ext4.h",
            "fs/ext4/extents.c||fs/ext4/extents.c"
          ],
          "candidate": [
            "fs/ext4/ext4.h||fs/ext4/ext4.h",
            "fs/ext4/extents.c||fs/ext4/extents.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/ext4/ext4.h||fs/ext4/ext4.h": [
          "File: fs/ext4/ext4.h -> fs/ext4/ext4.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "91: typedef unsigned int ext4_group_t;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "93: enum SHIFT_DIRECTION {",
          "94:  SHIFT_LEFT = 0,",
          "95:  SHIFT_RIGHT,",
          "96: };",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2947:    __u64 start, __u64 len);",
          "2948: extern int ext4_ext_precache(struct inode *inode);",
          "2949: extern int ext4_collapse_range(struct inode *inode, loff_t offset, loff_t len);",
          "2950: extern int ext4_swap_extents(handle_t *handle, struct inode *inode1,",
          "2951:     struct inode *inode2, ext4_lblk_t lblk1,",
          "2952:         ext4_lblk_t lblk2,  ext4_lblk_t count,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2955: extern int ext4_insert_range(struct inode *inode, loff_t offset, loff_t len);",
          "",
          "---------------"
        ],
        "fs/ext4/extents.c||fs/ext4/extents.c": [
          "File: fs/ext4/extents.c -> fs/ext4/extents.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4914:  if (ext4_encrypted_inode(inode) &&",
          "4916:   return -EOPNOTSUPP;",
          "4919:  if (mode & ~(FALLOC_FL_KEEP_SIZE | FALLOC_FL_PUNCH_HOLE |",
          "4921:   return -EOPNOTSUPP;",
          "4923:  if (mode & FALLOC_FL_PUNCH_HOLE)",
          "",
          "[Removed Lines]",
          "4915:      (mode & (FALLOC_FL_COLLAPSE_RANGE | FALLOC_FL_ZERO_RANGE)))",
          "4920:        FALLOC_FL_COLLAPSE_RANGE | FALLOC_FL_ZERO_RANGE))",
          "",
          "[Added Lines]",
          "4915:      (mode & (FALLOC_FL_COLLAPSE_RANGE | FALLOC_FL_INSERT_RANGE |",
          "4916:        FALLOC_FL_ZERO_RANGE)))",
          "4921:        FALLOC_FL_COLLAPSE_RANGE | FALLOC_FL_ZERO_RANGE |",
          "4922:        FALLOC_FL_INSERT_RANGE))",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "4930:  if (mode & FALLOC_FL_COLLAPSE_RANGE)",
          "4931:   return ext4_collapse_range(inode, offset, len);",
          "4933:  if (mode & FALLOC_FL_ZERO_RANGE)",
          "4934:   return ext4_zero_range(file, offset, len, mode);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4935:  if (mode & FALLOC_FL_INSERT_RANGE)",
          "4936:   return ext4_insert_range(inode, offset, len);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "5230: static int",
          "5231: ext4_ext_shift_path_extents(struct ext4_ext_path *path, ext4_lblk_t shift,",
          "5232:        struct inode *inode, handle_t *handle,",
          "5234: {",
          "5235:  int depth, err = 0;",
          "5236:  struct ext4_extent *ex_start, *ex_last;",
          "",
          "[Removed Lines]",
          "5233:        ext4_lblk_t *start)",
          "",
          "[Added Lines]",
          "5238:        enum SHIFT_DIRECTION SHIFT)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "5252:    if (ex_start == EXT_FIRST_EXTENT(path[depth].p_hdr))",
          "5253:     update = 1;",
          "5258:    while (ex_start <= ex_last) {",
          "5265:      ex_last--;",
          "5268:    }",
          "5269:    err = ext4_ext_dirty(handle, inode, path + depth);",
          "5270:    if (err)",
          "",
          "[Removed Lines]",
          "5256:     ext4_ext_get_actual_len(ex_last);",
          "5259:     le32_add_cpu(&ex_start->ee_block, -shift);",
          "5261:     if ((ex_start >",
          "5262:          EXT_FIRST_EXTENT(path[depth].p_hdr)) &&",
          "5263:         ext4_ext_try_to_merge_right(inode,",
          "5264:        path, ex_start - 1))",
          "5266:     else",
          "5267:      ex_start++;",
          "",
          "[Added Lines]",
          "5261:     if (SHIFT == SHIFT_LEFT) {",
          "5262:      le32_add_cpu(&ex_start->ee_block,",
          "5263:       -shift);",
          "5265:      if ((ex_start >",
          "5266:          EXT_FIRST_EXTENT(path[depth].p_hdr))",
          "5267:          &&",
          "5268:          ext4_ext_try_to_merge_right(inode,",
          "5269:          path, ex_start - 1))",
          "5270:       ex_last--;",
          "5271:      else",
          "5272:       ex_start++;",
          "5273:     } else {",
          "5274:      le32_add_cpu(&ex_last->ee_block, shift);",
          "5275:      ext4_ext_try_to_merge_right(inode, path,",
          "5276:       ex_last);",
          "5278:     }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "5279:   if (err)",
          "5280:    goto out;",
          "5283:   err = ext4_ext_dirty(handle, inode, path + depth);",
          "5284:   if (err)",
          "5285:    goto out;",
          "",
          "[Removed Lines]",
          "5282:   le32_add_cpu(&path[depth].p_idx->ei_block, -shift);",
          "",
          "[Added Lines]",
          "5293:   if (SHIFT == SHIFT_LEFT)",
          "5294:    le32_add_cpu(&path[depth].p_idx->ei_block, -shift);",
          "5295:   else",
          "5296:    le32_add_cpu(&path[depth].p_idx->ei_block, shift);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "5304: static int",
          "5305: ext4_ext_shift_extents(struct inode *inode, handle_t *handle,",
          "5307: {",
          "5308:  struct ext4_ext_path *path;",
          "5309:  int ret = 0, depth;",
          "5310:  struct ext4_extent *extent;",
          "5315:  path = ext4_find_extent(inode, EXT_MAX_BLOCKS - 1, NULL, 0);",
          "",
          "[Removed Lines]",
          "5306:          ext4_lblk_t start, ext4_lblk_t shift)",
          "5311:  ext4_lblk_t stop_block;",
          "5312:  ext4_lblk_t ex_start, ex_end;",
          "",
          "[Added Lines]",
          "5321:          ext4_lblk_t start, ext4_lblk_t shift,",
          "5322:          enum SHIFT_DIRECTION SHIFT)",
          "5327:  ext4_lblk_t stop, *iterator, ex_start, ex_end;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "5321:  if (!extent)",
          "5322:   goto out;",
          "5325:    ext4_ext_get_actual_len(extent);",
          "5347:  }",
          "5356:   if (IS_ERR(path))",
          "5357:    return PTR_ERR(path);",
          "5358:   depth = path->p_depth;",
          "5359:   extent = path[depth].p_ext;",
          "5360:   if (!extent) {",
          "5361:    EXT4_ERROR_INODE(inode, \"unexpected hole at %lu\",",
          "5363:    return -EIO;",
          "5364:   }",
          "5367:    if (extent < EXT_LAST_EXTENT(path[depth].p_hdr)) {",
          "5368:     path[depth].p_ext++;",
          "5369:    } else {",
          "5371:     continue;",
          "5372:    }",
          "5373:   }",
          "5374:   ret = ext4_ext_shift_path_extents(path, shift, inode,",
          "5376:   if (ret)",
          "5377:    break;",
          "5378:  }",
          "",
          "[Removed Lines]",
          "5324:  stop_block = le32_to_cpu(extent->ee_block) +",
          "5328:  if (start >= stop_block)",
          "5329:   goto out;",
          "5335:  path = ext4_find_extent(inode, start - 1, &path, 0);",
          "5336:  if (IS_ERR(path))",
          "5337:   return PTR_ERR(path);",
          "5338:  depth = path->p_depth;",
          "5339:  extent =  path[depth].p_ext;",
          "5340:  if (extent) {",
          "5341:   ex_start = le32_to_cpu(extent->ee_block);",
          "5342:   ex_end = le32_to_cpu(extent->ee_block) +",
          "5343:    ext4_ext_get_actual_len(extent);",
          "5344:  } else {",
          "5345:   ex_start = 0;",
          "5346:   ex_end = 0;",
          "5349:  if ((start == ex_start && shift > ex_start) ||",
          "5350:      (shift > start - ex_end))",
          "5351:   return -EINVAL;",
          "5354:  while (start < stop_block) {",
          "5355:   path = ext4_find_extent(inode, start, &path, 0);",
          "5362:       (unsigned long) start);",
          "5365:   if (start > le32_to_cpu(extent->ee_block)) {",
          "5370:     start = ext4_ext_next_allocated_block(path);",
          "5375:     handle, &start);",
          "",
          "[Added Lines]",
          "5339:  stop = le32_to_cpu(extent->ee_block) +",
          "5346:  if (SHIFT == SHIFT_LEFT) {",
          "5347:   path = ext4_find_extent(inode, start - 1, &path, 0);",
          "5348:   if (IS_ERR(path))",
          "5349:    return PTR_ERR(path);",
          "5350:   depth = path->p_depth;",
          "5351:   extent =  path[depth].p_ext;",
          "5352:   if (extent) {",
          "5353:    ex_start = le32_to_cpu(extent->ee_block);",
          "5354:    ex_end = le32_to_cpu(extent->ee_block) +",
          "5355:     ext4_ext_get_actual_len(extent);",
          "5356:   } else {",
          "5357:    ex_start = 0;",
          "5358:    ex_end = 0;",
          "5359:   }",
          "5361:   if ((start == ex_start && shift > ex_start) ||",
          "5362:       (shift > start - ex_end)) {",
          "5363:    ext4_ext_drop_refs(path);",
          "5364:    kfree(path);",
          "5365:    return -EINVAL;",
          "5366:   }",
          "5374:  if (SHIFT == SHIFT_LEFT)",
          "5375:   iterator = &start;",
          "5376:  else",
          "5377:   iterator = &stop;",
          "5380:  while (start < stop) {",
          "5381:   path = ext4_find_extent(inode, *iterator, &path, 0);",
          "5388:       (unsigned long) *iterator);",
          "5391:   if (SHIFT == SHIFT_LEFT && *iterator >",
          "5392:       le32_to_cpu(extent->ee_block)) {",
          "5402:   if (SHIFT == SHIFT_LEFT) {",
          "5403:    extent = EXT_LAST_EXTENT(path[depth].p_hdr);",
          "5405:      ext4_ext_get_actual_len(extent);",
          "5406:   } else {",
          "5407:    extent = EXT_FIRST_EXTENT(path[depth].p_hdr);",
          "5409:     le32_to_cpu(extent->ee_block) - 1 : 0;",
          "5411:    while (le32_to_cpu(extent->ee_block) < start)",
          "5412:     extent++;",
          "5413:    path[depth].p_ext = extent;",
          "5414:   }",
          "5416:     handle, SHIFT);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "5485:  ext4_discard_preallocations(inode);",
          "5487:  ret = ext4_ext_shift_extents(inode, handle, punch_stop,",
          "5489:  if (ret) {",
          "5490:   up_write(&EXT4_I(inode)->i_data_sem);",
          "5491:   goto out_stop;",
          "",
          "[Removed Lines]",
          "5488:          punch_stop - punch_start);",
          "",
          "[Added Lines]",
          "5529:          punch_stop - punch_start, SHIFT_LEFT);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "5510:  return ret;",
          "5511: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5562: int ext4_insert_range(struct inode *inode, loff_t offset, loff_t len)",
          "5563: {",
          "5564:  struct super_block *sb = inode->i_sb;",
          "5565:  handle_t *handle;",
          "5566:  struct ext4_ext_path *path;",
          "5567:  struct ext4_extent *extent;",
          "5568:  ext4_lblk_t offset_lblk, len_lblk, ee_start_lblk = 0;",
          "5569:  unsigned int credits, ee_len;",
          "5570:  int ret = 0, depth, split_flag = 0;",
          "5571:  loff_t ioffset;",
          "5578:  if (!ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))",
          "5579:   return -EOPNOTSUPP;",
          "5582:  if (offset & (EXT4_CLUSTER_SIZE(sb) - 1) ||",
          "5583:    len & (EXT4_CLUSTER_SIZE(sb) - 1))",
          "5584:   return -EINVAL;",
          "5586:  if (!S_ISREG(inode->i_mode))",
          "5587:   return -EOPNOTSUPP;",
          "5589:  trace_ext4_insert_range(inode, offset, len);",
          "5591:  offset_lblk = offset >> EXT4_BLOCK_SIZE_BITS(sb);",
          "5592:  len_lblk = len >> EXT4_BLOCK_SIZE_BITS(sb);",
          "5595:  if (ext4_should_journal_data(inode)) {",
          "5596:   ret = ext4_force_commit(inode->i_sb);",
          "5597:   if (ret)",
          "5598:    return ret;",
          "5599:  }",
          "5605:  ioffset = round_down(offset, PAGE_SIZE);",
          "5608:  ret = filemap_write_and_wait_range(inode->i_mapping, ioffset,",
          "5609:    LLONG_MAX);",
          "5610:  if (ret)",
          "5611:   return ret;",
          "5614:  mutex_lock(&inode->i_mutex);",
          "5617:  if (!ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)) {",
          "5618:   ret = -EOPNOTSUPP;",
          "5619:   goto out_mutex;",
          "5620:  }",
          "5623:  if (inode->i_size + len > inode->i_sb->s_maxbytes) {",
          "5624:   ret = -EFBIG;",
          "5625:   goto out_mutex;",
          "5626:  }",
          "5629:  if (offset >= i_size_read(inode)) {",
          "5630:   ret = -EINVAL;",
          "5631:   goto out_mutex;",
          "5632:  }",
          "5634:  truncate_pagecache(inode, ioffset);",
          "5637:  ext4_inode_block_unlocked_dio(inode);",
          "5638:  inode_dio_wait(inode);",
          "5640:  credits = ext4_writepage_trans_blocks(inode);",
          "5641:  handle = ext4_journal_start(inode, EXT4_HT_TRUNCATE, credits);",
          "5642:  if (IS_ERR(handle)) {",
          "5643:   ret = PTR_ERR(handle);",
          "5644:   goto out_dio;",
          "5645:  }",
          "5648:  inode->i_size += len;",
          "5649:  EXT4_I(inode)->i_disksize += len;",
          "5650:  inode->i_mtime = inode->i_ctime = ext4_current_time(inode);",
          "5651:  ret = ext4_mark_inode_dirty(handle, inode);",
          "5652:  if (ret)",
          "5653:   goto out_stop;",
          "5655:  down_write(&EXT4_I(inode)->i_data_sem);",
          "5656:  ext4_discard_preallocations(inode);",
          "5658:  path = ext4_find_extent(inode, offset_lblk, NULL, 0);",
          "5659:  if (IS_ERR(path)) {",
          "5660:   up_write(&EXT4_I(inode)->i_data_sem);",
          "5661:   goto out_stop;",
          "5662:  }",
          "5664:  depth = ext_depth(inode);",
          "5665:  extent = path[depth].p_ext;",
          "5666:  if (extent) {",
          "5667:   ee_start_lblk = le32_to_cpu(extent->ee_block);",
          "5668:   ee_len = ext4_ext_get_actual_len(extent);",
          "5674:   if ((offset_lblk > ee_start_lblk) &&",
          "5675:     (offset_lblk < (ee_start_lblk + ee_len))) {",
          "5676:    if (ext4_ext_is_unwritten(extent))",
          "5677:     split_flag = EXT4_EXT_MARK_UNWRIT1 |",
          "5678:      EXT4_EXT_MARK_UNWRIT2;",
          "5679:    ret = ext4_split_extent_at(handle, inode, &path,",
          "5680:      offset_lblk, split_flag,",
          "5681:      EXT4_EX_NOCACHE |",
          "5682:      EXT4_GET_BLOCKS_PRE_IO |",
          "5683:      EXT4_GET_BLOCKS_METADATA_NOFAIL);",
          "5684:   }",
          "5686:   ext4_ext_drop_refs(path);",
          "5687:   kfree(path);",
          "5688:   if (ret < 0) {",
          "5689:    up_write(&EXT4_I(inode)->i_data_sem);",
          "5690:    goto out_stop;",
          "5691:   }",
          "5692:  }",
          "5694:  ret = ext4_es_remove_extent(inode, offset_lblk,",
          "5695:    EXT_MAX_BLOCKS - offset_lblk);",
          "5696:  if (ret) {",
          "5697:   up_write(&EXT4_I(inode)->i_data_sem);",
          "5698:   goto out_stop;",
          "5699:  }",
          "5705:  ret = ext4_ext_shift_extents(inode, handle,",
          "5706:   ee_start_lblk > offset_lblk ? ee_start_lblk : offset_lblk,",
          "5707:   len_lblk, SHIFT_RIGHT);",
          "5709:  up_write(&EXT4_I(inode)->i_data_sem);",
          "5710:  if (IS_SYNC(inode))",
          "5711:   ext4_handle_sync(handle);",
          "5713: out_stop:",
          "5714:  ext4_journal_stop(handle);",
          "5715: out_dio:",
          "5716:  ext4_inode_resume_unlocked_dio(inode);",
          "5717: out_mutex:",
          "5718:  mutex_unlock(&inode->i_mutex);",
          "5719:  return ret;",
          "5720: }",
          "",
          "---------------"
        ],
        "include/trace/events/ext4.h||include/trace/events/ext4.h": [
          "File: include/trace/events/ext4.h -> include/trace/events/ext4.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "2478:     __entry->offset, __entry->len)",
          "2479: );",
          "2481: TRACE_EVENT(ext4_es_shrink,",
          "2482:  TP_PROTO(struct super_block *sb, int nr_shrunk, u64 scan_time,",
          "2483:    int nr_skipped, int retried),",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2478:     __entry->offset, __entry->len)",
          "2479: );",
          "2481: TRACE_EVENT(ext4_insert_range,",
          "2482:  TP_PROTO(struct inode *inode, loff_t offset, loff_t len),",
          "2484:  TP_ARGS(inode, offset, len),",
          "2486:  TP_STRUCT__entry(",
          "2487:   __field(dev_t, dev)",
          "2488:   __field(ino_t, ino)",
          "2489:   __field(loff_t, offset)",
          "2490:   __field(loff_t, len)",
          "2491:  ),",
          "2493:  TP_fast_assign(",
          "2494:   __entry->dev = inode->i_sb->s_dev;",
          "2495:   __entry->ino = inode->i_ino;",
          "2496:   __entry->offset = offset;",
          "2497:   __entry->len = len;",
          "2498:  ),",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "01a33b4ace68bc35679a347f21d5ed6e222e30dc",
      "candidate_info": {
        "commit_hash": "01a33b4ace68bc35679a347f21d5ed6e222e30dc",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/01a33b4ace68bc35679a347f21d5ed6e222e30dc",
        "files": [
          "fs/ext4/file.c"
        ],
        "message": "ext4: start transaction before calling into DAX\n\nJan Kara pointed out that in the case where we are writing to a hole, we\ncan end up with a lock inversion between the page lock and the journal\nlock.  We can avoid this by starting the transaction in ext4 before\ncalling into DAX.  The journal lock nests inside the superblock\npagefault lock, so we have to duplicate that code from dax_fault, like\nXFS does.\n\nSigned-off-by: Matthew Wilcox <willy@linux.intel.com>\nCc: Jan Kara <jack@suse.cz>\nCc: Theodore Ts'o <tytso@mit.edu>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "fs/ext4/file.c||fs/ext4/file.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/ext4/file.c||fs/ext4/file.c"
          ],
          "candidate": [
            "fs/ext4/file.c||fs/ext4/file.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/ext4/file.c||fs/ext4/file.c": [
          "File: fs/ext4/file.c -> fs/ext4/file.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "208: static int ext4_dax_fault(struct vm_area_struct *vma, struct vm_fault *vmf)",
          "209: {",
          "211: }",
          "213: static int ext4_dax_pmd_fault(struct vm_area_struct *vma, unsigned long addr,",
          "214:       pmd_t *pmd, unsigned int flags)",
          "215: {",
          "218: }",
          "220: static int ext4_dax_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf)",
          "",
          "[Removed Lines]",
          "210:  return dax_fault(vma, vmf, ext4_get_block_dax, ext4_end_io_unwritten);",
          "216:  return dax_pmd_fault(vma, addr, pmd, flags, ext4_get_block_dax,",
          "217:     ext4_end_io_unwritten);",
          "",
          "[Added Lines]",
          "210:  int result;",
          "211:  handle_t *handle = NULL;",
          "212:  struct super_block *sb = file_inode(vma->vm_file)->i_sb;",
          "213:  bool write = vmf->flags & FAULT_FLAG_WRITE;",
          "215:  if (write) {",
          "216:   sb_start_pagefault(sb);",
          "217:   file_update_time(vma->vm_file);",
          "218:   handle = ext4_journal_start_sb(sb, EXT4_HT_WRITE_PAGE,",
          "219:       EXT4_DATA_TRANS_BLOCKS(sb));",
          "220:  }",
          "222:  if (IS_ERR(handle))",
          "223:   result = VM_FAULT_SIGBUS;",
          "224:  else",
          "225:   result = __dax_fault(vma, vmf, ext4_get_block_dax,",
          "226:       ext4_end_io_unwritten);",
          "228:  if (write) {",
          "229:   if (!IS_ERR(handle))",
          "230:    ext4_journal_stop(handle);",
          "231:   sb_end_pagefault(sb);",
          "232:  }",
          "234:  return result;",
          "240:  int result;",
          "241:  handle_t *handle = NULL;",
          "242:  struct inode *inode = file_inode(vma->vm_file);",
          "243:  struct super_block *sb = inode->i_sb;",
          "244:  bool write = flags & FAULT_FLAG_WRITE;",
          "246:  if (write) {",
          "247:   sb_start_pagefault(sb);",
          "248:   file_update_time(vma->vm_file);",
          "249:   handle = ext4_journal_start_sb(sb, EXT4_HT_WRITE_PAGE,",
          "250:     ext4_chunk_trans_blocks(inode,",
          "251:        PMD_SIZE / PAGE_SIZE));",
          "252:  }",
          "254:  if (IS_ERR(handle))",
          "255:   result = VM_FAULT_SIGBUS;",
          "256:  else",
          "257:   result = __dax_pmd_fault(vma, addr, pmd, flags,",
          "258:     ext4_get_block_dax, ext4_end_io_unwritten);",
          "260:  if (write) {",
          "261:   if (!IS_ERR(handle))",
          "262:    ext4_journal_stop(handle);",
          "263:   sb_end_pagefault(sb);",
          "264:  }",
          "266:  return result;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "e842f2903908934187af7232fb5b21da527d1757",
      "candidate_info": {
        "commit_hash": "e842f2903908934187af7232fb5b21da527d1757",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/e842f2903908934187af7232fb5b21da527d1757",
        "files": [
          "fs/dax.c",
          "fs/ext2/file.c",
          "fs/ext4/file.c",
          "fs/ext4/inode.c",
          "include/linux/fs.h"
        ],
        "message": "dax: don't abuse get_block mapping for endio callbacks\n\ndax_fault() currently relies on the get_block callback to attach an\nio completion callback to the mapping buffer head so that it can\nrun unwritten extent conversion after zeroing allocated blocks.\n\nInstead of this hack, pass the conversion callback directly into\ndax_fault() similar to the get_block callback. When the filesystem\nallocates unwritten extents, it will set the buffer_unwritten()\nflag, and hence the dax_fault code can call the completion function\nin the contexts where it is necessary without overloading the\nmapping buffer head.\n\nNote: The changes to ext4 to use this interface are suspect at best.\nIn fact, the way ext4 did this end_io assignment in the first place\nlooks suspect because it only set a completion callback when there\nwasn't already some other write() call taking place on the same\ninode. The ext4 end_io code looks rather intricate and fragile with\nall it's reference counting and passing to different contexts for\nmodification via inode private pointers that aren't protected by\nlocks...\n\nSigned-off-by: Dave Chinner <dchinner@redhat.com>\nAcked-by: Jan Kara <jack@suse.cz>\nSigned-off-by: Dave Chinner <david@fromorbit.com>",
        "before_after_code_files": [
          "fs/dax.c||fs/dax.c",
          "fs/ext2/file.c||fs/ext2/file.c",
          "fs/ext4/file.c||fs/ext4/file.c",
          "fs/ext4/inode.c||fs/ext4/inode.c",
          "include/linux/fs.h||include/linux/fs.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/ext4/file.c||fs/ext4/file.c",
            "fs/ext4/inode.c||fs/ext4/inode.c"
          ],
          "candidate": [
            "fs/ext4/file.c||fs/ext4/file.c",
            "fs/ext4/inode.c||fs/ext4/inode.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/dax.c||fs/dax.c": [
          "File: fs/dax.c -> fs/dax.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "309:  out:",
          "310:  i_mmap_unlock_read(mapping);",
          "315:  return error;",
          "316: }",
          "318: static int do_dax_fault(struct vm_area_struct *vma, struct vm_fault *vmf,",
          "320: {",
          "321:  struct file *file = vma->vm_file;",
          "322:  struct address_space *mapping = file->f_mapping;",
          "",
          "[Removed Lines]",
          "312:  if (bh->b_end_io)",
          "313:   bh->b_end_io(bh, 1);",
          "319:    get_block_t get_block)",
          "",
          "[Added Lines]",
          "316:    get_block_t get_block, dax_iodone_t complete_unwritten)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "417:   page_cache_release(page);",
          "418:  }",
          "420:  error = dax_insert_mapping(inode, &bh, vma, vmf);",
          "422:  out:",
          "423:  if (error == -ENOMEM)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "428:  if (buffer_unwritten(&bh))",
          "429:   complete_unwritten(&bh, !error);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "447: int dax_fault(struct vm_area_struct *vma, struct vm_fault *vmf,",
          "449: {",
          "450:  int result;",
          "451:  struct super_block *sb = file_inode(vma->vm_file)->i_sb;",
          "",
          "[Removed Lines]",
          "448:    get_block_t get_block)",
          "",
          "[Added Lines]",
          "457:        get_block_t get_block, dax_iodone_t complete_unwritten)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "454:   sb_start_pagefault(sb);",
          "455:   file_update_time(vma->vm_file);",
          "456:  }",
          "458:  if (vmf->flags & FAULT_FLAG_WRITE)",
          "459:   sb_end_pagefault(sb);",
          "",
          "[Removed Lines]",
          "457:  result = do_dax_fault(vma, vmf, get_block);",
          "",
          "[Added Lines]",
          "466:  result = do_dax_fault(vma, vmf, get_block, complete_unwritten);",
          "",
          "---------------"
        ],
        "fs/ext2/file.c||fs/ext2/file.c": [
          "File: fs/ext2/file.c -> fs/ext2/file.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "28: #ifdef CONFIG_FS_DAX",
          "29: static int ext2_dax_fault(struct vm_area_struct *vma, struct vm_fault *vmf)",
          "30: {",
          "32: }",
          "34: static int ext2_dax_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf)",
          "35: {",
          "37: }",
          "39: static const struct vm_operations_struct ext2_dax_vm_ops = {",
          "",
          "[Removed Lines]",
          "31:  return dax_fault(vma, vmf, ext2_get_block);",
          "36:  return dax_mkwrite(vma, vmf, ext2_get_block);",
          "",
          "[Added Lines]",
          "31:  return dax_fault(vma, vmf, ext2_get_block, NULL);",
          "36:  return dax_mkwrite(vma, vmf, ext2_get_block, NULL);",
          "",
          "---------------"
        ],
        "fs/ext4/file.c||fs/ext4/file.c": [
          "File: fs/ext4/file.c -> fs/ext4/file.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "192: }",
          "194: #ifdef CONFIG_FS_DAX",
          "195: static int ext4_dax_fault(struct vm_area_struct *vma, struct vm_fault *vmf)",
          "196: {",
          "199: }",
          "201: static int ext4_dax_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf)",
          "202: {",
          "204: }",
          "206: static const struct vm_operations_struct ext4_dax_vm_ops = {",
          "",
          "[Removed Lines]",
          "197:  return dax_fault(vma, vmf, ext4_get_block);",
          "203:  return dax_mkwrite(vma, vmf, ext4_get_block);",
          "",
          "[Added Lines]",
          "195: static void ext4_end_io_unwritten(struct buffer_head *bh, int uptodate)",
          "196: {",
          "197:  struct inode *inode = bh->b_assoc_map->host;",
          "199:  loff_t offset = (loff_t)(uintptr_t)bh->b_private << inode->i_blkbits;",
          "200:  int err;",
          "201:  if (!uptodate)",
          "202:   return;",
          "203:  WARN_ON(!buffer_unwritten(bh));",
          "204:  err = ext4_convert_unwritten_extents(NULL, inode, offset, bh->b_size);",
          "205: }",
          "209:  return dax_fault(vma, vmf, ext4_get_block, ext4_end_io_unwritten);",
          "215:  return dax_mkwrite(vma, vmf, ext4_get_block, ext4_end_io_unwritten);",
          "",
          "---------------"
        ],
        "fs/ext4/inode.c||fs/ext4/inode.c": [
          "File: fs/ext4/inode.c -> fs/ext4/inode.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "656:  return retval;",
          "657: }",
          "672: #define DIO_MAX_BLOCKS 4096",
          "",
          "[Removed Lines]",
          "659: static void ext4_end_io_unwritten(struct buffer_head *bh, int uptodate)",
          "660: {",
          "661:  struct inode *inode = bh->b_assoc_map->host;",
          "663:  loff_t offset = (loff_t)(uintptr_t)bh->b_private << inode->i_blkbits;",
          "664:  int err;",
          "665:  if (!uptodate)",
          "666:   return;",
          "667:  WARN_ON(!buffer_unwritten(bh));",
          "668:  err = ext4_convert_unwritten_extents(NULL, inode, offset, bh->b_size);",
          "669: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "706:   map_bh(bh, inode->i_sb, map.m_pblk);",
          "707:   bh->b_state = (bh->b_state & ~EXT4_MAP_FLAGS) | map.m_flags;",
          "709:    bh->b_assoc_map = inode->i_mapping;",
          "710:    bh->b_private = (void *)(unsigned long)iblock;",
          "712:   }",
          "713:   if (io_end && io_end->flag & EXT4_IO_END_UNWRITTEN)",
          "714:    set_buffer_defer_completion(bh);",
          "",
          "[Removed Lines]",
          "708:   if (IS_DAX(inode) && buffer_unwritten(bh) && !io_end) {",
          "711:    bh->b_end_io = ext4_end_io_unwritten;",
          "",
          "[Added Lines]",
          "696:   if (IS_DAX(inode) && buffer_unwritten(bh)) {",
          "702:    WARN_ON_ONCE(io_end);",
          "",
          "---------------"
        ],
        "include/linux/fs.h||include/linux/fs.h": [
          "File: include/linux/fs.h -> include/linux/fs.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "70:    struct buffer_head *bh_result, int create);",
          "71: typedef void (dio_iodone_t)(struct kiocb *iocb, loff_t offset,",
          "72:    ssize_t bytes, void *private);",
          "74: #define MAY_EXEC  0x00000001",
          "75: #define MAY_WRITE  0x00000002",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "73: typedef void (dax_iodone_t)(struct buffer_head *bh_map, int uptodate);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2627: int dax_clear_blocks(struct inode *, sector_t block, long size);",
          "2628: int dax_zero_page_range(struct inode *, loff_t from, unsigned len, get_block_t);",
          "2629: int dax_truncate_page(struct inode *, loff_t from, get_block_t);",
          "2631: int dax_pfn_mkwrite(struct vm_area_struct *, struct vm_fault *);",
          "2634: #ifdef CONFIG_BLOCK",
          "2635: typedef void (dio_submit_t)(int rw, struct bio *bio, struct inode *inode,",
          "",
          "[Removed Lines]",
          "2630: int dax_fault(struct vm_area_struct *, struct vm_fault *, get_block_t);",
          "2632: #define dax_mkwrite(vma, vmf, gb) dax_fault(vma, vmf, gb)",
          "",
          "[Added Lines]",
          "2631: int dax_fault(struct vm_area_struct *, struct vm_fault *, get_block_t,",
          "2632:   dax_iodone_t);",
          "2634: #define dax_mkwrite(vma, vmf, gb, iod) dax_fault(vma, vmf, gb, iod)",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2019-19923",
  "cve_desc": "flattenSubquery in select.c in SQLite 3.30.1 mishandles certain uses of SELECT DISTINCT involving a LEFT JOIN in which the right-hand side is a view. This can cause a NULL pointer dereference (or incorrect results).",
  "repo": "sqlite/sqlite",
  "patch_hash": "396afe6f6aa90a31303c183e11b2b2d4b7956b35",
  "patch_info": {
    "commit_hash": "396afe6f6aa90a31303c183e11b2b2d4b7956b35",
    "repo": "sqlite/sqlite",
    "commit_url": "https://github.com/sqlite/sqlite/commit/396afe6f6aa90a31303c183e11b2b2d4b7956b35",
    "files": [
      "manifest",
      "manifest.uuid",
      "src/select.c",
      "test/join.test"
    ],
    "message": "Continue to back away from the LEFT JOIN optimization of check-in [41c27bc0ff1d3135] by disallowing query flattening if the outer query is DISTINCT.  Without this fix, if an index scan is run on the table within the view on the right-hand side of the LEFT JOIN, stale result registers might be accessed yielding incorrect results, and/or an OP_IfNullRow opcode might be invoked on the un-opened table, resulting in a NULL-pointer dereference.  This problem was found by the Yongheng and Rui fuzzer.\n\nFossilOrigin-Name: 862974312edf00e9d1068115d1a39b7235b7db68b6d86b81d38a12f025a4748e",
    "before_after_code_files": [
      "manifest.uuid||manifest.uuid",
      "src/select.c||src/select.c",
      "test/join.test||test/join.test"
    ]
  },
  "patch_diff": {
    "manifest.uuid||manifest.uuid": [
      "File: manifest.uuid -> manifest.uuid",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "1: 289158aa24b066c453d2bce4bc2dead1c56fb0b23c3f7c4810b34b13627cef34",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "src/select.c||src/select.c": [
      "File: src/select.c -> src/select.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "3797:   if( (pSubitem->fg.jointype & JT_OUTER)!=0 ){",
      "3798:     isLeftJoin = 1;",
      "3801:       return 0;",
      "3802:     }",
      "3803:   }",
      "",
      "[Removed Lines]",
      "3799:     if( pSubSrc->nSrc>1 || isAgg || IsVirtual(pSubSrc->a[0].pTab) ){",
      "",
      "[Added Lines]",
      "3804:     ){",
      "",
      "---------------"
    ],
    "test/join.test||test/join.test": [
      "File: test/join.test -> test/join.test",
      "--- Hunk 1 ---",
      "[Context before]",
      "975:   SELECT 24, * FROM t1 LEFT JOIN t0 ON +aa ISNULL;",
      "976: } {13 1 {} 14 1 {} 23 1 {} 24 1 {}}",
      "978: finish_test",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "978: # 2019-12-18 problem with a LEFT JOIN where the RHS is a view.",
      "979: # Detected by Yongheng and Rui.",
      "980: # Follows from the optimization attempt of check-in 41c27bc0ff1d3135",
      "981: # on 2017-04-18",
      "982: #",
      "983: reset_db",
      "984: do_execsql_test join-22.10 {",
      "985:   CREATE TABLE t0(a, b);",
      "986:   CREATE INDEX t0a ON t0(a);",
      "987:   INSERT INTO t0 VALUES(10,10),(10,11),(10,12);",
      "988:   SELECT DISTINCT c FROM t0 LEFT JOIN (SELECT a+1 AS c FROM t0) ORDER BY c ;",
      "989: } {11}",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "d0f820a7e61a22197d9fed275973c3e425aa7927",
      "candidate_info": {
        "commit_hash": "d0f820a7e61a22197d9fed275973c3e425aa7927",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/d0f820a7e61a22197d9fed275973c3e425aa7927",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/vacuum.c",
          "test/vacuum-into.test"
        ],
        "message": "Enhance the VACUUM INTO command so that it works on read-only databases.\n\nFossilOrigin-Name: 55be6d0a9fa8a64b9c9c5ed51a2b9144304f7f0870a13b92d5864ac4d54491b6",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/vacuum.c||src/vacuum.c",
          "test/vacuum-into.test||test/vacuum-into.test"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: d5acf3af65f9608d4096b9b78289d84b21cd1ea463457f858ffeb20d5bd5d123",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/vacuum.c||src/vacuum.c": [
          "File: src/vacuum.c -> src/vacuum.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "168:     sqlite3SetString(pzErrMsg, db,\"cannot VACUUM - SQL statements in progress\");",
          "169:     return SQLITE_ERROR;",
          "170:   }",
          "171:   if( pOut ){",
          "172:     if( sqlite3_value_type(pOut)!=SQLITE_TEXT ){",
          "173:       sqlite3SetString(pzErrMsg, db, \"non-text filename\");",
          "174:       return SQLITE_ERROR;",
          "175:     }",
          "176:     zOut = (const char*)sqlite3_value_text(pOut);",
          "177:   }else{",
          "178:     zOut = \"\";",
          "179:   }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "172:   saved_openFlags = db->openFlags;",
          "179:     db->openFlags &= ~SQLITE_OPEN_READONLY;",
          "180:     db->openFlags |= SQLITE_OPEN_CREATE|SQLITE_OPEN_READWRITE;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "213:   nDb = db->nDb;",
          "214:   rc = execSqlF(db, pzErrMsg, \"ATTACH %Q AS vacuum_db\", zOut);",
          "215:   if( rc!=SQLITE_OK ) goto end_of_vacuum;",
          "216:   assert( (db->nDb-1)==nDb );",
          "217:   pDb = &db->aDb[nDb];",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "219:   db->openFlags = saved_openFlags;",
          "",
          "---------------"
        ],
        "test/vacuum-into.test||test/vacuum-into.test": [
          "File: test/vacuum-into.test -> test/vacuum-into.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "86:   VACUUM INTO target2()",
          "87: } {1 {no such function: target2}}",
          "90: finish_test",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "89: # The ability to VACUUM INTO a read-only database",
          "90: db close",
          "91: sqlite3 db test.db -readonly 1",
          "92: forcedelete test.db2",
          "93: do_execsql_test vacuum-into-500 {",
          "94:   VACUUM INTO 'test.db2';",
          "95: }",
          "96: sqlite3 db2 test.db2",
          "97: do_test vacuum-into-510 {",
          "98:   db2 eval {SELECT name FROM sqlite_master ORDER BY 1}",
          "99: } {t1 t1b t2}",
          "100: db2 close",
          "101: db close",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "bffdd636339b32c706253e8c791ccca8b3f88f19",
      "candidate_info": {
        "commit_hash": "bffdd636339b32c706253e8c791ccca8b3f88f19",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/bffdd636339b32c706253e8c791ccca8b3f88f19",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/expr.c",
          "test/check.test",
          "test/indexexpr1.test"
        ],
        "message": "When computing an expression value for an index-on-expression or a CHECK constraint and the expressions uses a REAL table column, but the value of that column is an integer (in other words, when it is using the store-real-as-integer optimization) be sure to promote the value to real before evaluating the expression.  Ticket [57af00b6642ecd68].\n\nFossilOrigin-Name: 0658c16e311393c8a347b1bd41fa5dbfd2e184aa75d84c011aa8dbac79b632e9",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/expr.c||src/expr.c",
          "test/check.test||test/check.test",
          "test/indexexpr1.test||test/indexexpr1.test"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: f6d8956cf8b5993a4332b9330e89d5c3d5f8872ea5a2ce3d2e91127406cc1839",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/expr.c||src/expr.c": [
          "File: src/expr.c -> src/expr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3532:       if( iTab<0 ){",
          "3533:         if( pParse->iSelfTab<0 ){",
          "3536:         }else{",
          "",
          "[Removed Lines]",
          "3535:           return pExpr->iColumn - pParse->iSelfTab;",
          "",
          "[Added Lines]",
          "3535:           assert( pExpr->y.pTab!=0 );",
          "3536:           assert( pExpr->iColumn>=XN_ROWID );",
          "3537:           assert( pExpr->iColumn<pExpr->y.pTab->nCol );",
          "3538:           if( pExpr->iColumn>=0",
          "3539:             && pExpr->y.pTab->aCol[pExpr->iColumn].affinity==SQLITE_AFF_REAL",
          "3540:           ){",
          "3541:             sqlite3VdbeAddOp2(v, OP_SCopy, pExpr->iColumn - pParse->iSelfTab,",
          "3542:                               target);",
          "3543:             sqlite3VdbeAddOp1(v, OP_RealAffinity, target);",
          "3544:             return target;",
          "3545:           }else{",
          "3546:             return pExpr->iColumn - pParse->iSelfTab;",
          "3547:           }",
          "",
          "---------------"
        ],
        "test/check.test||test/check.test": [
          "File: test/check.test -> test/check.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "123:       y REAL CONSTRAINT two CHECK( typeof(coalesce(y,0.1))=='real' ),",
          "124:       z TEXT CONSTRAINT three CHECK( typeof(coalesce(z,''))=='text' )",
          "125:     );",
          "126:     PRAGMA writable_schema = 0;",
          "127:   }",
          "128: } {}",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "126:     CREATE TABLE t2n(",
          "127:       x INTEGER CONSTRAINT one CHECK( typeof(coalesce(x,0))==\"integer\" ),",
          "128:       y NUMERIC CONSTRAINT two CHECK( typeof(coalesce(y,0.1))=='real' ),",
          "129:       z TEXT CONSTRAINT three CHECK( typeof(coalesce(z,''))=='text' )",
          "130:     );",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "146:   }",
          "147: } {1 {CHECK constraint failed: one}}",
          "148: do_test check-2.5 {",
          "149:   catchsql {",
          "150:     INSERT INTO t2 VALUES(NULL, 5, NULL);",
          "151:   }",
          "152: } {1 {CHECK constraint failed: two}}",
          "153: do_test check-2.6 {",
          "154:   catchsql {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "154:   # The 5 gets automatically promoted to 5.0 because the column type is REAL",
          "158: } {0 {}}",
          "159: do_test check-2.5b {",
          "160:   # This time the column type is NUMERIC, so not automatic promption to REAL",
          "161:   # occurs and the constraint fails.",
          "162:   catchsql {",
          "163:     INSERT INTO t2n VALUES(NULL, 5, NULL);",
          "164:   }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "195:   execsql {",
          "196:     DROP TABLE IF EXISTS t2b;",
          "197:     DROP TABLE IF EXISTS t2c;",
          "198:   }",
          "199: } {}",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "211:     DROP TABLE IF EXISTS t2n;",
          "",
          "---------------"
        ],
        "test/indexexpr1.test||test/indexexpr1.test": [
          "File: test/indexexpr1.test -> test/indexexpr1.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "457:   SELECT * FROM t0 WHERE ((NULL IS FALSE) IS FALSE);",
          "458: } {0}",
          "460: finish_test",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "460: # 2019-09-02 https://www.sqlite.org/src/tktview/57af00b6642ecd6848",
          "461: # When the expression of an an index-on-expression references a",
          "462: # table column of type REAL that is actually holding an MEM_IntReal",
          "463: # value, be sure to use the REAL value and not the INT value when",
          "464: # computing the expression.",
          "465: #",
          "466: do_execsql_test indexexpr-1800 {",
          "467:   DROP TABLE IF EXISTS t0;",
          "468:   CREATE TABLE t0(c0 REAL, c1 TEXT);",
          "469:   CREATE INDEX i0 ON t0(+c0, c0);",
          "470:   INSERT INTO t0(c0) VALUES(0);",
          "471:   SELECT CAST(+ t0.c0 AS BLOB) LIKE 0 FROM t0;",
          "472: } {0}",
          "473: do_execsql_test indexexpr-1810 {",
          "474:   SELECT CAST(+ t0.c0 AS BLOB) LIKE '0.0' FROM t0;",
          "475: } {1}",
          "476: do_execsql_test indexexpr-1820 {",
          "477:   DROP TABLE IF EXISTS t1;",
          "478:   CREATE TABLE t1(x REAL);",
          "479:   CREATE INDEX t1x ON t1(x, +x);",
          "480:   INSERT INTO t1(x) VALUES(2);",
          "481:   SELECT +x FROM t1 WHERE x=2;",
          "482: } {2.0}",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "7fe2fc0dcb0bb214fe83a8a8fcdeb553fb20b97d",
      "candidate_info": {
        "commit_hash": "7fe2fc0dcb0bb214fe83a8a8fcdeb553fb20b97d",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/7fe2fc0dcb0bb214fe83a8a8fcdeb553fb20b97d",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/build.c",
          "src/expr.c",
          "test/gencol1.test"
        ],
        "message": "Fix a problem with foreign keys and generated columns discovered by Manuel Rigger.\n\nFossilOrigin-Name: 27c0fdab1ba4d4993b164eb4b777c63e82aa247c3fa406121dc8ed94970a0b35",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/build.c||src/build.c",
          "src/expr.c||src/expr.c",
          "test/gencol1.test||test/gencol1.test"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: ef73107f475e40e6bdd8b722e96992070f81fd2b7a3cb718ec8f251c89ca3e81",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/build.c||src/build.c": [
          "File: src/build.c -> src/build.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "952: i16 sqlite3TableColumnToStorage(Table *pTab, i16 iCol){",
          "953:   int i;",
          "954:   i16 n;",
          "955:   assert( iCol<pTab->nCol );",
          "957:   for(i=0, n=0; i<iCol; i++){",
          "958:     if( (pTab->aCol[i].colFlags & COLFLAG_VIRTUAL)==0 ) n++;",
          "959:   }",
          "",
          "[Removed Lines]",
          "956:   if( (pTab->tabFlags & TF_HasVirtual)==0 ) return iCol;",
          "",
          "[Added Lines]",
          "958:   if( (pTab->tabFlags & TF_HasVirtual)==0 || iCol<0 ) return iCol;",
          "",
          "---------------"
        ],
        "src/expr.c||src/expr.c": [
          "File: src/expr.c -> src/expr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4136:       Table *pTab = pExpr->y.pTab;",
          "4137:       int iCol = pExpr->iColumn;",
          "4138:       int p1 = pExpr->iTable * (pTab->nCol+1) + 1",
          "4141:       assert( pExpr->iTable==0 || pExpr->iTable==1 );",
          "4142:       assert( iCol>=-1 && iCol<pTab->nCol );",
          "",
          "[Removed Lines]",
          "4139:                      + (iCol>=0 ? sqlite3TableColumnToStorage(pTab, iCol) : -1);",
          "",
          "[Added Lines]",
          "4139:                      + sqlite3TableColumnToStorage(pTab, iCol);",
          "",
          "---------------"
        ],
        "test/gencol1.test||test/gencol1.test": [
          "File: test/gencol1.test -> test/gencol1.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "272:   PRAGMA integrity_check;",
          "273: } {ok}",
          "275: finish_test",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "275: # 2019-12-06 Found by mrigger",
          "276: #",
          "277: sqlite3 db :memory:",
          "278: do_execsql_test gencol1-11.10 {",
          "279:   PRAGMA foreign_keys = true;",
          "280:   CREATE TABLE t0(",
          "281:     c0,",
          "282:     c1 INTEGER PRIMARY KEY,",
          "283:     c2 BLOB UNIQUE DEFAULT x'00',",
          "284:     c3 BLOB GENERATED ALWAYS AS (1),",
          "285:     FOREIGN KEY(c1) REFERENCES t0(c2)",
          "286:   );",
          "287: }",
          "288: do_catchsql_test gencol1-11.20 {",
          "289:   INSERT OR REPLACE INTO t0(c0, c1) VALUES (2, 1), (1, 0)",
          "290: } {1 {FOREIGN KEY constraint failed}}",
          "291: do_execsql_test gencol1-11.30 {",
          "292:   DROP TABLE t0;",
          "293:   CREATE TABLE t0(",
          "294:     c0,",
          "295:     c1 INTEGER PRIMARY KEY,",
          "296:     c3 BLOB GENERATED ALWAYS AS (1),",
          "297:     c2 BLOB UNIQUE DEFAULT x'00',",
          "298:     FOREIGN KEY(c1) REFERENCES t0(c2)",
          "299:   );",
          "300: }",
          "301: do_catchsql_test gencol1-11.40 {",
          "302:   INSERT OR REPLACE INTO t0(c0, c1) VALUES (2, 1), (1, 0)",
          "303: } {1 {FOREIGN KEY constraint failed}}",
          "304: do_execsql_test gencol1-11.50 {",
          "305:   DROP TABLE t0;",
          "306:   CREATE TABLE t0(",
          "307:     c0,",
          "308:     c3 BLOB GENERATED ALWAYS AS (1),",
          "309:     c1 INTEGER PRIMARY KEY,",
          "310:     c2 BLOB UNIQUE DEFAULT x'00',",
          "311:     FOREIGN KEY(c1) REFERENCES t0(c2)",
          "312:   );",
          "313: }",
          "314: do_catchsql_test gencol1-11.60 {",
          "315:   INSERT OR REPLACE INTO t0(c0, c1) VALUES (2, 1), (1, 0)",
          "316: } {1 {FOREIGN KEY constraint failed}}",
          "317: do_execsql_test gencol1-11.70 {",
          "318:   DROP TABLE t0;",
          "319:   CREATE TABLE t0(",
          "320:     c3 BLOB GENERATED ALWAYS AS (1),",
          "321:     c0,",
          "322:     c1 INTEGER PRIMARY KEY,",
          "323:     c2 BLOB UNIQUE DEFAULT x'00',",
          "324:     FOREIGN KEY(c1) REFERENCES t0(c2)",
          "325:   );",
          "326: }",
          "327: do_catchsql_test gencol1-11.80 {",
          "328:   INSERT OR REPLACE INTO t0(c0, c1) VALUES (2, 1), (1, 0)",
          "329: } {1 {FOREIGN KEY constraint failed}}",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "d0fb7960cea5d26a40a0a7ca00c4274545e96efe",
      "candidate_info": {
        "commit_hash": "d0fb7960cea5d26a40a0a7ca00c4274545e96efe",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/d0fb7960cea5d26a40a0a7ca00c4274545e96efe",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/vdbe.c"
        ],
        "message": "Small changes to the OP_OpenEphemeral opcode to improve testability.\n\nFossilOrigin-Name: f856676c8438dbf52d299e78f6dd6148d929755dc05cdcabafd17d9a86439435",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/vdbe.c||src/vdbe.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 4678cb1044f0b4dc813e48f3bd0f85240a66e2ecf8763280d66726cc031c93a7",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/vdbe.c||src/vdbe.c": [
          "File: src/vdbe.c -> src/vdbe.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3669:     rc = sqlite3BtreeClearTable(pCx->pBtx, pCx->pgnoRoot, 0);",
          "3698:       }",
          "3705:     }",
          "3706:   }",
          "3707:   if( rc ) goto abort_due_to_error;",
          "3709:   break;",
          "3710: }",
          "",
          "[Removed Lines]",
          "3670:     if( rc ) goto abort_due_to_error;",
          "3671:     break;",
          "3672:   }",
          "3673:   pCx = allocateCursor(p, pOp->p1, pOp->p2, -1, CURTYPE_BTREE);",
          "3674:   if( pCx==0 ) goto no_mem;",
          "3675:   pCx->nullRow = 1;",
          "3676:   pCx->isEphemeral = 1;",
          "3677:   rc = sqlite3BtreeOpen(db->pVfs, 0, db, &pCx->pBtx,",
          "3678:                         BTREE_OMIT_JOURNAL | BTREE_SINGLE | pOp->p5, vfsFlags);",
          "3679:   if( rc==SQLITE_OK ){",
          "3680:     rc = sqlite3BtreeBeginTrans(pCx->pBtx, 1, 0);",
          "3681:   }",
          "3682:   if( rc==SQLITE_OK ){",
          "3688:     if( (pCx->pKeyInfo = pKeyInfo = pOp->p4.pKeyInfo)!=0 ){",
          "3689:       assert( pOp->p4type==P4_KEYINFO );",
          "3690:       rc = sqlite3BtreeCreateTable(pCx->pBtx, (int*)&pCx->pgnoRoot,",
          "3691:                                    BTREE_BLOBKEY | pOp->p5);",
          "3692:       if( rc==SQLITE_OK ){",
          "3693:         assert( pCx->pgnoRoot==MASTER_ROOT+1 );",
          "3694:         assert( pKeyInfo->db==db );",
          "3695:         assert( pKeyInfo->enc==ENC(db) );",
          "3696:         rc = sqlite3BtreeCursor(pCx->pBtx, pCx->pgnoRoot, BTREE_WRCSR,",
          "3697:                                 pKeyInfo, pCx->uc.pCursor);",
          "3699:       pCx->isTable = 0;",
          "3700:     }else{",
          "3701:       pCx->pgnoRoot = MASTER_ROOT;",
          "3702:       rc = sqlite3BtreeCursor(pCx->pBtx, MASTER_ROOT, BTREE_WRCSR,",
          "3703:                               0, pCx->uc.pCursor);",
          "3704:       pCx->isTable = 1;",
          "3708:   pCx->isOrdered = (pOp->p5!=BTREE_UNORDERED);",
          "",
          "[Added Lines]",
          "3670:   }else{",
          "3671:     pCx = allocateCursor(p, pOp->p1, pOp->p2, -1, CURTYPE_BTREE);",
          "3672:     if( pCx==0 ) goto no_mem;",
          "3673:     pCx->nullRow = 1;",
          "3674:     pCx->isEphemeral = 1;",
          "3675:     rc = sqlite3BtreeOpen(db->pVfs, 0, db, &pCx->pBtx,",
          "3676:                           BTREE_OMIT_JOURNAL | BTREE_SINGLE | pOp->p5,",
          "3677:                           vfsFlags);",
          "3678:     if( rc==SQLITE_OK ){",
          "3679:       rc = sqlite3BtreeBeginTrans(pCx->pBtx, 1, 0);",
          "3680:     }",
          "3681:     if( rc==SQLITE_OK ){",
          "3687:       if( (pCx->pKeyInfo = pKeyInfo = pOp->p4.pKeyInfo)!=0 ){",
          "3688:         assert( pOp->p4type==P4_KEYINFO );",
          "3689:         rc = sqlite3BtreeCreateTable(pCx->pBtx, (int*)&pCx->pgnoRoot,",
          "3690:                                      BTREE_BLOBKEY | pOp->p5);",
          "3691:         if( rc==SQLITE_OK ){",
          "3692:           assert( pCx->pgnoRoot==MASTER_ROOT+1 );",
          "3693:           assert( pKeyInfo->db==db );",
          "3694:           assert( pKeyInfo->enc==ENC(db) );",
          "3695:           rc = sqlite3BtreeCursor(pCx->pBtx, pCx->pgnoRoot, BTREE_WRCSR,",
          "3696:                                   pKeyInfo, pCx->uc.pCursor);",
          "3697:         }",
          "3698:         pCx->isTable = 0;",
          "3699:       }else{",
          "3700:         pCx->pgnoRoot = MASTER_ROOT;",
          "3701:         rc = sqlite3BtreeCursor(pCx->pBtx, MASTER_ROOT, BTREE_WRCSR,",
          "3702:                                 0, pCx->uc.pCursor);",
          "3703:         pCx->isTable = 1;",
          "3706:     pCx->isOrdered = (pOp->p5!=BTREE_UNORDERED);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "3ecc05bc3fb414a0a184b4d69d5ecc38ddb24951",
      "candidate_info": {
        "commit_hash": "3ecc05bc3fb414a0a184b4d69d5ecc38ddb24951",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/3ecc05bc3fb414a0a184b4d69d5ecc38ddb24951",
        "files": [
          "manifest",
          "manifest.uuid",
          "tool/lemon.c"
        ],
        "message": "Fix goofy string formatting in lemon.c that dates from the K&amp;R-C days.\n\nFossilOrigin-Name: 48ba5e5a2227257cebafacbb09e9dd91d9b89ab2d52a8b4e4113c1d017d95f41",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "tool/lemon.c||tool/lemon.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 4d6d2fc046d586a1e5989bbb2757f13d0371fbfad0acf45a0e2fd77dffd8d8f9",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "tool/lemon.c||tool/lemon.c": [
          "File: tool/lemon.c -> tool/lemon.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "910:     sp = Symbol_find(lemp->start);",
          "911:     if( sp==0 ){",
          "912:       ErrorMsg(lemp->filename,0,",
          "916:       lemp->errorcnt++;",
          "917:       sp = lemp->startRule->lhs;",
          "918:     }",
          "",
          "[Removed Lines]",
          "913: \"The specified start symbol \\\"%s\\\" is not \\",
          "914: in a nonterminal of the grammar.  \\\"%s\\\" will be used as the start \\",
          "915: symbol instead.\",lemp->start,lemp->startRule->lhs->name);",
          "",
          "[Added Lines]",
          "913:         \"The specified start symbol \\\"%s\\\" is not \"",
          "914:         \"in a nonterminal of the grammar.  \\\"%s\\\" will be used as the start \"",
          "915:         \"symbol instead.\",lemp->start,lemp->startRule->lhs->name);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "928:     for(i=0; i<rp->nrhs; i++){",
          "930:         ErrorMsg(lemp->filename,0,",
          "934:         lemp->errorcnt++;",
          "935:       }",
          "936:     }",
          "",
          "[Removed Lines]",
          "931: \"The start symbol \\\"%s\\\" occurs on the \\",
          "932: right-hand side of a rule. This will result in a parser which \\",
          "933: does not work properly.\",sp->name);",
          "",
          "[Added Lines]",
          "931:           \"The start symbol \\\"%s\\\" occurs on the \"",
          "932:           \"right-hand side of a rule. This will result in a parser which \"",
          "933:           \"does not work properly.\",sp->name);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2274:       }else if( x[0]=='{' ){",
          "2275:         if( psp->prevrule==0 ){",
          "2276:           ErrorMsg(psp->filename,psp->tokenlineno,",
          "2279:           psp->errorcnt++;",
          "2280:         }else if( psp->prevrule->code!=0 ){",
          "2281:           ErrorMsg(psp->filename,psp->tokenlineno,",
          "2284:           psp->errorcnt++;",
          "2285:         }else if( strcmp(x, \"{NEVER-REDUCE\")==0 ){",
          "2286:           psp->prevrule->neverReduce = 1;",
          "",
          "[Removed Lines]",
          "2277: \"There is no prior rule upon which to attach the code \\",
          "2278: fragment which begins on this line.\");",
          "2282: \"Code fragment beginning on this line is not the first \\",
          "2283: to follow the previous rule.\");",
          "",
          "[Added Lines]",
          "2277:             \"There is no prior rule upon which to attach the code \"",
          "2278:             \"fragment which begins on this line.\");",
          "2282:             \"Code fragment beginning on this line is not the first \"",
          "2283:             \"to follow the previous rule.\");",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2309:         psp->errorcnt++;",
          "2310:       }else if( psp->prevrule->precsym!=0 ){",
          "2311:         ErrorMsg(psp->filename,psp->tokenlineno,",
          "2314:         psp->errorcnt++;",
          "2315:       }else{",
          "2316:         psp->prevrule->precsym = Symbol_new(x);",
          "",
          "[Removed Lines]",
          "2312: \"Precedence mark on this line is not the first \\",
          "2313: to follow the previous rule.\");",
          "",
          "[Added Lines]",
          "2312:           \"Precedence mark on this line is not the first \"",
          "2313:           \"to follow the previous rule.\");",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2913:       }",
          "2914:       if( c==0 ){",
          "2915:         ErrorMsg(ps.filename,startline,",
          "2917:         ps.errorcnt++;",
          "2918:         nextcp = cp;",
          "2919:       }else{",
          "",
          "[Removed Lines]",
          "2916: \"String starting on this line is not terminated before the end of the file.\");",
          "",
          "[Added Lines]",
          "2916:             \"String starting on this line is not terminated before \"",
          "2917:             \"the end of the file.\");",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2952:       }",
          "2953:       if( c==0 ){",
          "2954:         ErrorMsg(ps.filename,ps.tokenlineno,",
          "2956:         ps.errorcnt++;",
          "2957:         nextcp = cp;",
          "2958:       }else{",
          "",
          "[Removed Lines]",
          "2955: \"C code starting on this line is not terminated before the end of the file.\");",
          "",
          "[Added Lines]",
          "2956:           \"C code starting on this line is not terminated before \"",
          "2957:           \"the end of the file.\");",
          "",
          "---------------"
        ]
      }
    }
  ]
}
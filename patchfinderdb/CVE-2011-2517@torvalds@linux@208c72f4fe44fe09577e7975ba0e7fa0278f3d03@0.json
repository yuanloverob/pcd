{
  "cve_id": "CVE-2011-2517",
  "cve_desc": "Multiple buffer overflows in net/wireless/nl80211.c in the Linux kernel before 2.6.39.2 allow local users to gain privileges by leveraging the CAP_NET_ADMIN capability during scan operations with a long SSID value.",
  "repo": "torvalds/linux",
  "patch_hash": "208c72f4fe44fe09577e7975ba0e7fa0278f3d03",
  "patch_info": {
    "commit_hash": "208c72f4fe44fe09577e7975ba0e7fa0278f3d03",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/208c72f4fe44fe09577e7975ba0e7fa0278f3d03",
    "files": [
      "net/wireless/nl80211.c"
    ],
    "message": "nl80211: fix check for valid SSID size in scan operations\n\nIn both trigger_scan and sched_scan operations, we were checking for\nthe SSID length before assigning the value correctly.  Since the\nmemory was just kzalloc'ed, the check was always failing and SSID with\nover 32 characters were allowed to go through.\n\nThis was causing a buffer overflow when copying the actual SSID to the\nproper place.\n\nThis bug has been there since 2.6.29-rc4.\n\nCc: stable@kernel.org\nSigned-off-by: Luciano Coelho <coelho@ti.com>\nSigned-off-by: John W. Linville <linville@tuxdriver.com>",
    "before_after_code_files": [
      "net/wireless/nl80211.c||net/wireless/nl80211.c"
    ]
  },
  "patch_diff": {
    "net/wireless/nl80211.c||net/wireless/nl80211.c": [
      "File: net/wireless/nl80211.c -> net/wireless/nl80211.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "3406:  i = 0;",
      "3407:  if (info->attrs[NL80211_ATTR_SCAN_SSIDS]) {",
      "3408:   nla_for_each_nested(attr, info->attrs[NL80211_ATTR_SCAN_SSIDS], tmp) {",
      "3409:    if (request->ssids[i].ssid_len > IEEE80211_MAX_SSID_LEN) {",
      "3410:     err = -EINVAL;",
      "3411:     goto out_free;",
      "3412:    }",
      "3413:    memcpy(request->ssids[i].ssid, nla_data(attr), nla_len(attr));",
      "3415:    i++;",
      "3416:   }",
      "3417:  }",
      "",
      "[Removed Lines]",
      "3414:    request->ssids[i].ssid_len = nla_len(attr);",
      "",
      "[Added Lines]",
      "3409:    request->ssids[i].ssid_len = nla_len(attr);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "3572:  if (info->attrs[NL80211_ATTR_SCAN_SSIDS]) {",
      "3573:   nla_for_each_nested(attr, info->attrs[NL80211_ATTR_SCAN_SSIDS],",
      "3574:         tmp) {",
      "3575:    if (request->ssids[i].ssid_len >",
      "3576:        IEEE80211_MAX_SSID_LEN) {",
      "3577:     err = -EINVAL;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "3575:    request->ssids[i].ssid_len = nla_len(attr);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "3579:    }",
      "3580:    memcpy(request->ssids[i].ssid, nla_data(attr),",
      "3581:           nla_len(attr));",
      "3583:    i++;",
      "3584:   }",
      "3585:  }",
      "",
      "[Removed Lines]",
      "3582:    request->ssids[i].ssid_len = nla_len(attr);",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "57a27e1d6a3bb9ad4efeebd3a8c71156d6207536",
      "candidate_info": {
        "commit_hash": "57a27e1d6a3bb9ad4efeebd3a8c71156d6207536",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/57a27e1d6a3bb9ad4efeebd3a8c71156d6207536",
        "files": [
          "net/wireless/nl80211.c"
        ],
        "message": "nl80211: fix overflow in ssid_len\n\nWhen one of the SSID's length passed in a scan or sched_scan request\nis larger than 255, there will be an overflow in the u8 that is used\nto store the length before checking.  This causes the check to fail\nand we overrun the buffer when copying the SSID.\n\nFix this by checking the nl80211 attribute length before copying it to\nthe struct.\n\nThis is a follow up for the previous commit\n208c72f4fe44fe09577e7975ba0e7fa0278f3d03, which didn't fix the problem\nentirely.\n\nReported-by: Ido Yariv <ido@wizery.com>\nSigned-off-by: Luciano Coelho <coelho@ti.com>\nSigned-off-by: John W. Linville <linville@tuxdriver.com>",
        "before_after_code_files": [
          "net/wireless/nl80211.c||net/wireless/nl80211.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "net/wireless/nl80211.c||net/wireless/nl80211.c"
          ],
          "candidate": [
            "net/wireless/nl80211.c||net/wireless/nl80211.c"
          ]
        }
      },
      "candidate_diff": {
        "net/wireless/nl80211.c||net/wireless/nl80211.c": [
          "File: net/wireless/nl80211.c -> net/wireless/nl80211.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3406:  i = 0;",
          "3407:  if (info->attrs[NL80211_ATTR_SCAN_SSIDS]) {",
          "3408:   nla_for_each_nested(attr, info->attrs[NL80211_ATTR_SCAN_SSIDS], tmp) {",
          "3411:     err = -EINVAL;",
          "3412:     goto out_free;",
          "3413:    }",
          "3414:    memcpy(request->ssids[i].ssid, nla_data(attr), nla_len(attr));",
          "3415:    i++;",
          "3416:   }",
          "",
          "[Removed Lines]",
          "3409:    request->ssids[i].ssid_len = nla_len(attr);",
          "3410:    if (request->ssids[i].ssid_len > IEEE80211_MAX_SSID_LEN) {",
          "",
          "[Added Lines]",
          "3409:    if (nla_len(attr) > IEEE80211_MAX_SSID_LEN) {",
          "3413:    request->ssids[i].ssid_len = nla_len(attr);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3572:  if (info->attrs[NL80211_ATTR_SCAN_SSIDS]) {",
          "3573:   nla_for_each_nested(attr, info->attrs[NL80211_ATTR_SCAN_SSIDS],",
          "3574:         tmp) {",
          "3578:     err = -EINVAL;",
          "3579:     goto out_free;",
          "3580:    }",
          "3581:    memcpy(request->ssids[i].ssid, nla_data(attr),",
          "3582:           nla_len(attr));",
          "3583:    i++;",
          "",
          "[Removed Lines]",
          "3575:    request->ssids[i].ssid_len = nla_len(attr);",
          "3576:    if (request->ssids[i].ssid_len >",
          "3577:        IEEE80211_MAX_SSID_LEN) {",
          "",
          "[Added Lines]",
          "3575:    if (nla_len(attr) > IEEE80211_MAX_SSID_LEN) {",
          "3579:    request->ssids[i].ssid_len = nla_len(attr);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "807f8a8c300435d5483e8d78df9dcdbc27333166",
      "candidate_info": {
        "commit_hash": "807f8a8c300435d5483e8d78df9dcdbc27333166",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/807f8a8c300435d5483e8d78df9dcdbc27333166",
        "files": [
          "include/linux/nl80211.h",
          "include/net/cfg80211.h",
          "net/wireless/core.c",
          "net/wireless/core.h",
          "net/wireless/nl80211.c",
          "net/wireless/nl80211.h",
          "net/wireless/scan.c"
        ],
        "message": "cfg80211/nl80211: add support for scheduled scans\n\nImplement new functionality for scheduled scan offload.  With this feature we\ncan scan automatically at certain intervals.\n\nThe idea is that the hardware can perform scan automatically and filter on\ndesired results without waking up the host unnecessarily.\n\nAdd NL80211_CMD_START_SCHED_SCAN and NL80211_CMD_STOP_SCHED_SCAN\ncommands to the nl80211 interface.  When results are available they are\nreported by NL80211_CMD_SCHED_SCAN_RESULTS events.  The userspace is\ninformed when the scheduled scan has stopped with a\nNL80211_CMD_SCHED_SCAN_STOPPED event, which can be triggered either by\nthe driver or by a call to NL80211_CMD_STOP_SCHED_SCAN.\n\nSigned-off-by: Luciano Coelho <coelho@ti.com>\nSigned-off-by: John W. Linville <linville@tuxdriver.com>",
        "before_after_code_files": [
          "include/linux/nl80211.h||include/linux/nl80211.h",
          "include/net/cfg80211.h||include/net/cfg80211.h",
          "net/wireless/core.c||net/wireless/core.c",
          "net/wireless/core.h||net/wireless/core.h",
          "net/wireless/nl80211.c||net/wireless/nl80211.c",
          "net/wireless/nl80211.h||net/wireless/nl80211.h",
          "net/wireless/scan.c||net/wireless/scan.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "net/wireless/nl80211.c||net/wireless/nl80211.c"
          ],
          "candidate": [
            "net/wireless/nl80211.c||net/wireless/nl80211.c"
          ]
        }
      },
      "candidate_diff": {
        "include/linux/nl80211.h||include/linux/nl80211.h": [
          "File: include/linux/nl80211.h -> include/linux/nl80211.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "545:  NL80211_CMD_GET_WOWLAN,",
          "546:  NL80211_CMD_SET_WOWLAN,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "568:  NL80211_CMD_START_SCHED_SCAN,",
          "569:  NL80211_CMD_STOP_SCHED_SCAN,",
          "570:  NL80211_CMD_SCHED_SCAN_RESULTS,",
          "571:  NL80211_CMD_SCHED_SCAN_STOPPED,",
          "",
          "---------------"
        ],
        "include/net/cfg80211.h||include/net/cfg80211.h": [
          "File: include/net/cfg80211.h -> include/net/cfg80211.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "823:  struct ieee80211_channel *channels[0];",
          "824: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "838: struct cfg80211_sched_scan_request {",
          "839:  struct cfg80211_ssid *ssids;",
          "840:  int n_ssids;",
          "841:  u32 n_channels;",
          "842:  const u8 *ie;",
          "843:  size_t ie_len;",
          "846:  struct wiphy *wiphy;",
          "847:  struct net_device *dev;",
          "850:  struct ieee80211_channel *channels[0];",
          "851: };",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1478:  int (*set_ringparam)(struct wiphy *wiphy, u32 tx, u32 rx);",
          "1479:  void (*get_ringparam)(struct wiphy *wiphy,",
          "1480:      u32 *tx, u32 *tx_max, u32 *rx, u32 *rx_max);",
          "1481: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1513:  int (*sched_scan_start)(struct wiphy *wiphy,",
          "1514:     struct net_device *dev,",
          "1515:     struct cfg80211_sched_scan_request *request);",
          "1516:  int (*sched_scan_stop)(struct wiphy *wiphy, struct net_device *dev,",
          "1517:        bool driver_initiated);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1534:  WIPHY_FLAG_CONTROL_PORT_PROTOCOL = BIT(7),",
          "1535:  WIPHY_FLAG_IBSS_RSN   = BIT(8),",
          "1536:  WIPHY_FLAG_MESH_AUTH   = BIT(10),",
          "1537: };",
          "1539: struct mac_address {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1575:  WIPHY_FLAG_SUPPORTS_SCHED_SCAN  = BIT(11),",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2355: void cfg80211_scan_done(struct cfg80211_scan_request *request, bool aborted);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2401: void cfg80211_sched_scan_results(struct wiphy *wiphy);",
          "2412: void cfg80211_sched_scan_stopped(struct wiphy *wiphy);",
          "",
          "---------------"
        ],
        "net/wireless/core.c||net/wireless/core.c": [
          "File: net/wireless/core.c -> net/wireless/core.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "370:  spin_lock_init(&rdev->bss_lock);",
          "371:  INIT_LIST_HEAD(&rdev->bss_list);",
          "372:  INIT_WORK(&rdev->scan_done_wk, __cfg80211_scan_done);",
          "374: #ifdef CONFIG_CFG80211_WEXT",
          "375:  rdev->wiphy.wext = &cfg80211_wext_handler;",
          "376: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "373:  INIT_WORK(&rdev->sched_scan_results_wk, __cfg80211_sched_scan_results);",
          "374:  INIT_WORK(&rdev->sched_scan_stopped_wk, __cfg80211_sched_scan_stopped);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "672:   ___cfg80211_scan_done(rdev, true);",
          "673:  }",
          "675:  cfg80211_unlock_rdev(rdev);",
          "677:  mutex_lock(&rdev->devlist_mtx);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "676:  if (WARN_ON(rdev->sched_scan_req &&",
          "677:       rdev->sched_scan_req->dev == wdev->netdev)) {",
          "678:   __cfg80211_stop_sched_scan(rdev, false);",
          "679:  }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "759:    break;",
          "760:   case NL80211_IFTYPE_P2P_CLIENT:",
          "761:   case NL80211_IFTYPE_STATION:",
          "762:    wdev_lock(wdev);",
          "763: #ifdef CONFIG_CFG80211_WEXT",
          "764:    kfree(wdev->wext.ie);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "768:    cfg80211_lock_rdev(rdev);",
          "769:    __cfg80211_stop_sched_scan(rdev, false);",
          "770:    cfg80211_unlock_rdev(rdev);",
          "",
          "---------------"
        ],
        "net/wireless/core.h||net/wireless/core.h": [
          "File: net/wireless/core.h -> net/wireless/core.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "60:  struct rb_root bss_tree;",
          "61:  u32 bss_generation;",
          "63:  unsigned long suspend_at;",
          "64:  struct work_struct scan_done_wk;",
          "66: #ifdef CONFIG_NL80211_TESTMODE",
          "67:  struct genl_info *testmode_info;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "63:  struct cfg80211_sched_scan_request *sched_scan_req;",
          "66:  struct work_struct sched_scan_results_wk;",
          "67:  struct work_struct sched_scan_stopped_wk;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "411: void cfg80211_sme_disassoc(struct net_device *dev, int idx);",
          "412: void __cfg80211_scan_done(struct work_struct *wk);",
          "413: void ___cfg80211_scan_done(struct cfg80211_registered_device *rdev, bool leak);",
          "414: void cfg80211_upload_connect_keys(struct wireless_dev *wdev);",
          "415: int cfg80211_change_iface(struct cfg80211_registered_device *rdev,",
          "416:      struct net_device *dev, enum nl80211_iftype ntype,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "417: void __cfg80211_sched_scan_results(struct work_struct *wk);",
          "418: int __cfg80211_stop_sched_scan(struct cfg80211_registered_device *rdev,",
          "419:           bool driver_initiated);",
          "420: void __cfg80211_sched_scan_stopped(struct work_struct *wk);",
          "",
          "---------------"
        ],
        "net/wireless/nl80211.c||net/wireless/nl80211.c": [
          "File: net/wireless/nl80211.c -> net/wireless/nl80211.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "761:  }",
          "762:  CMD(set_channel, SET_CHANNEL);",
          "763:  CMD(set_wds_peer, SET_WDS_PEER);",
          "765: #undef CMD",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "764:  if (dev->wiphy.flags & WIPHY_FLAG_SUPPORTS_SCHED_SCAN)",
          "765:   CMD(sched_scan_start, START_SCHED_SCAN);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3357:  return err;",
          "3358: }",
          "3360: static int nl80211_send_bss(struct sk_buff *msg, u32 pid, u32 seq, int flags,",
          "3361:        struct cfg80211_registered_device *rdev,",
          "3362:        struct wireless_dev *wdev,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3362: static int nl80211_start_sched_scan(struct sk_buff *skb,",
          "3363:         struct genl_info *info)",
          "3364: {",
          "3365:  struct cfg80211_sched_scan_request *request;",
          "3366:  struct cfg80211_registered_device *rdev = info->user_ptr[0];",
          "3367:  struct net_device *dev = info->user_ptr[1];",
          "3368:  struct cfg80211_ssid *ssid;",
          "3369:  struct ieee80211_channel *channel;",
          "3370:  struct nlattr *attr;",
          "3371:  struct wiphy *wiphy;",
          "3372:  int err, tmp, n_ssids = 0, n_channels, i;",
          "3373:  enum ieee80211_band band;",
          "3374:  size_t ie_len;",
          "3376:  if (!(rdev->wiphy.flags & WIPHY_FLAG_SUPPORTS_SCHED_SCAN) ||",
          "3377:      !rdev->ops->sched_scan_start)",
          "3378:   return -EOPNOTSUPP;",
          "3380:  if (!is_valid_ie_attr(info->attrs[NL80211_ATTR_IE]))",
          "3381:   return -EINVAL;",
          "3383:  if (rdev->sched_scan_req)",
          "3384:   return -EINPROGRESS;",
          "3386:  wiphy = &rdev->wiphy;",
          "3388:  if (info->attrs[NL80211_ATTR_SCAN_FREQUENCIES]) {",
          "3389:   n_channels = validate_scan_freqs(",
          "3390:     info->attrs[NL80211_ATTR_SCAN_FREQUENCIES]);",
          "3391:   if (!n_channels)",
          "3392:    return -EINVAL;",
          "3393:  } else {",
          "3394:   n_channels = 0;",
          "3396:   for (band = 0; band < IEEE80211_NUM_BANDS; band++)",
          "3397:    if (wiphy->bands[band])",
          "3398:     n_channels += wiphy->bands[band]->n_channels;",
          "3399:  }",
          "3401:  if (info->attrs[NL80211_ATTR_SCAN_SSIDS])",
          "3402:   nla_for_each_nested(attr, info->attrs[NL80211_ATTR_SCAN_SSIDS],",
          "3403:         tmp)",
          "3404:    n_ssids++;",
          "3406:  if (n_ssids > wiphy->max_scan_ssids)",
          "3407:   return -EINVAL;",
          "3409:  if (info->attrs[NL80211_ATTR_IE])",
          "3410:   ie_len = nla_len(info->attrs[NL80211_ATTR_IE]);",
          "3411:  else",
          "3412:   ie_len = 0;",
          "3414:  if (ie_len > wiphy->max_scan_ie_len)",
          "3415:   return -EINVAL;",
          "3417:  request = kzalloc(sizeof(*request)",
          "3418:    + sizeof(*ssid) * n_ssids",
          "3419:    + sizeof(channel) * n_channels",
          "3420:    + ie_len, GFP_KERNEL);",
          "3421:  if (!request)",
          "3422:   return -ENOMEM;",
          "3424:  if (n_ssids)",
          "3425:   request->ssids = (void *)&request->channels[n_channels];",
          "3426:  request->n_ssids = n_ssids;",
          "3427:  if (ie_len) {",
          "3428:   if (request->ssids)",
          "3429:    request->ie = (void *)(request->ssids + n_ssids);",
          "3430:   else",
          "3431:    request->ie = (void *)(request->channels + n_channels);",
          "3432:  }",
          "3434:  i = 0;",
          "3435:  if (info->attrs[NL80211_ATTR_SCAN_FREQUENCIES]) {",
          "3437:   nla_for_each_nested(attr,",
          "3438:         info->attrs[NL80211_ATTR_SCAN_FREQUENCIES],",
          "3439:         tmp) {",
          "3440:    struct ieee80211_channel *chan;",
          "3442:    chan = ieee80211_get_channel(wiphy, nla_get_u32(attr));",
          "3444:    if (!chan) {",
          "3445:     err = -EINVAL;",
          "3446:     goto out_free;",
          "3447:    }",
          "3450:    if (chan->flags & IEEE80211_CHAN_DISABLED)",
          "3451:     continue;",
          "3453:    request->channels[i] = chan;",
          "3454:    i++;",
          "3455:   }",
          "3456:  } else {",
          "3458:   for (band = 0; band < IEEE80211_NUM_BANDS; band++) {",
          "3459:    int j;",
          "3460:    if (!wiphy->bands[band])",
          "3461:     continue;",
          "3462:    for (j = 0; j < wiphy->bands[band]->n_channels; j++) {",
          "3463:     struct ieee80211_channel *chan;",
          "3465:     chan = &wiphy->bands[band]->channels[j];",
          "3467:     if (chan->flags & IEEE80211_CHAN_DISABLED)",
          "3468:      continue;",
          "3470:     request->channels[i] = chan;",
          "3471:     i++;",
          "3472:    }",
          "3473:   }",
          "3474:  }",
          "3476:  if (!i) {",
          "3477:   err = -EINVAL;",
          "3478:   goto out_free;",
          "3479:  }",
          "3481:  request->n_channels = i;",
          "3483:  i = 0;",
          "3484:  if (info->attrs[NL80211_ATTR_SCAN_SSIDS]) {",
          "3485:   nla_for_each_nested(attr, info->attrs[NL80211_ATTR_SCAN_SSIDS],",
          "3486:         tmp) {",
          "3487:    if (request->ssids[i].ssid_len >",
          "3488:        IEEE80211_MAX_SSID_LEN) {",
          "3489:     err = -EINVAL;",
          "3490:     goto out_free;",
          "3491:    }",
          "3492:    memcpy(request->ssids[i].ssid, nla_data(attr),",
          "3493:           nla_len(attr));",
          "3494:    request->ssids[i].ssid_len = nla_len(attr);",
          "3495:    i++;",
          "3496:   }",
          "3497:  }",
          "3499:  if (info->attrs[NL80211_ATTR_IE]) {",
          "3500:   request->ie_len = nla_len(info->attrs[NL80211_ATTR_IE]);",
          "3501:   memcpy((void *)request->ie,",
          "3502:          nla_data(info->attrs[NL80211_ATTR_IE]),",
          "3503:          request->ie_len);",
          "3504:  }",
          "3506:  request->dev = dev;",
          "3507:  request->wiphy = &rdev->wiphy;",
          "3509:  err = rdev->ops->sched_scan_start(&rdev->wiphy, dev, request);",
          "3510:  if (!err) {",
          "3511:   rdev->sched_scan_req = request;",
          "3512:   nl80211_send_sched_scan(rdev, dev,",
          "3513:      NL80211_CMD_START_SCHED_SCAN);",
          "3514:   goto out;",
          "3515:  }",
          "3517: out_free:",
          "3518:  kfree(request);",
          "3519: out:",
          "3520:  return err;",
          "3521: }",
          "3523: static int nl80211_stop_sched_scan(struct sk_buff *skb,",
          "3524:        struct genl_info *info)",
          "3525: {",
          "3526:  struct cfg80211_registered_device *rdev = info->user_ptr[0];",
          "3528:  if (!(rdev->wiphy.flags & WIPHY_FLAG_SUPPORTS_SCHED_SCAN) ||",
          "3529:      !rdev->ops->sched_scan_stop)",
          "3530:   return -EOPNOTSUPP;",
          "3532:  return __cfg80211_stop_sched_scan(rdev, false);",
          "3533: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "5326:   .policy = nl80211_policy,",
          "5327:   .dumpit = nl80211_dump_scan,",
          "5328:  },",
          "5329:  {",
          "5330:   .cmd = NL80211_CMD_AUTHENTICATE,",
          "5331:   .doit = nl80211_authenticate,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5504:  {",
          "5505:   .cmd = NL80211_CMD_START_SCHED_SCAN,",
          "5506:   .doit = nl80211_start_sched_scan,",
          "5507:   .policy = nl80211_policy,",
          "5508:   .flags = GENL_ADMIN_PERM,",
          "5509:   .internal_flags = NL80211_FLAG_NEED_NETDEV_UP |",
          "5510:       NL80211_FLAG_NEED_RTNL,",
          "5511:  },",
          "5512:  {",
          "5513:   .cmd = NL80211_CMD_STOP_SCHED_SCAN,",
          "5514:   .doit = nl80211_stop_sched_scan,",
          "5515:   .policy = nl80211_policy,",
          "5516:   .flags = GENL_ADMIN_PERM,",
          "5517:   .internal_flags = NL80211_FLAG_NEED_NETDEV_UP |",
          "5518:       NL80211_FLAG_NEED_RTNL,",
          "5519:  },",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "5652:  return -EMSGSIZE;",
          "5653: }",
          "5655: void nl80211_send_scan_start(struct cfg80211_registered_device *rdev,",
          "5656:         struct net_device *netdev)",
          "5657: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5846: static int",
          "5847: nl80211_send_sched_scan_msg(struct sk_buff *msg,",
          "5848:        struct cfg80211_registered_device *rdev,",
          "5849:        struct net_device *netdev,",
          "5850:        u32 pid, u32 seq, int flags, u32 cmd)",
          "5851: {",
          "5852:  void *hdr;",
          "5854:  hdr = nl80211hdr_put(msg, pid, seq, flags, cmd);",
          "5855:  if (!hdr)",
          "5856:   return -1;",
          "5858:  NLA_PUT_U32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx);",
          "5859:  NLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex);",
          "5861:  return genlmsg_end(msg, hdr);",
          "5863:  nla_put_failure:",
          "5864:  genlmsg_cancel(msg, hdr);",
          "5865:  return -EMSGSIZE;",
          "5866: }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "5709:     nl80211_scan_mcgrp.id, GFP_KERNEL);",
          "5710: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5925: void nl80211_send_sched_scan_results(struct cfg80211_registered_device *rdev,",
          "5926:          struct net_device *netdev)",
          "5927: {",
          "5928:  struct sk_buff *msg;",
          "5930:  msg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);",
          "5931:  if (!msg)",
          "5932:   return;",
          "5934:  if (nl80211_send_sched_scan_msg(msg, rdev, netdev, 0, 0, 0,",
          "5935:      NL80211_CMD_SCHED_SCAN_RESULTS) < 0) {",
          "5936:   nlmsg_free(msg);",
          "5937:   return;",
          "5938:  }",
          "5940:  genlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,",
          "5941:     nl80211_scan_mcgrp.id, GFP_KERNEL);",
          "5942: }",
          "5944: void nl80211_send_sched_scan(struct cfg80211_registered_device *rdev,",
          "5945:         struct net_device *netdev, u32 cmd)",
          "5946: {",
          "5947:  struct sk_buff *msg;",
          "5949:  msg = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);",
          "5950:  if (!msg)",
          "5951:   return;",
          "5953:  if (nl80211_send_sched_scan_msg(msg, rdev, netdev, 0, 0, 0, cmd) < 0) {",
          "5954:   nlmsg_free(msg);",
          "5955:   return;",
          "5956:  }",
          "5958:  genlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,",
          "5959:     nl80211_scan_mcgrp.id, GFP_KERNEL);",
          "5960: }",
          "",
          "---------------"
        ],
        "net/wireless/nl80211.h||net/wireless/nl80211.h": [
          "File: net/wireless/nl80211.h -> net/wireless/nl80211.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "12:        struct net_device *netdev);",
          "13: void nl80211_send_scan_aborted(struct cfg80211_registered_device *rdev,",
          "14:           struct net_device *netdev);",
          "15: void nl80211_send_reg_change_event(struct regulatory_request *request);",
          "16: void nl80211_send_rx_auth(struct cfg80211_registered_device *rdev,",
          "17:      struct net_device *netdev,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "15: void nl80211_send_sched_scan(struct cfg80211_registered_device *rdev,",
          "16:         struct net_device *netdev, u32 cmd);",
          "17: void nl80211_send_sched_scan_results(struct cfg80211_registered_device *rdev,",
          "18:          struct net_device *netdev);",
          "",
          "---------------"
        ],
        "net/wireless/scan.c||net/wireless/scan.c": [
          "File: net/wireless/scan.c -> net/wireless/scan.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "93: }",
          "94: EXPORT_SYMBOL(cfg80211_scan_done);",
          "96: static void bss_release(struct kref *ref)",
          "97: {",
          "98:  struct cfg80211_internal_bss *bss;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "96: void __cfg80211_sched_scan_results(struct work_struct *wk)",
          "97: {",
          "98:  struct cfg80211_registered_device *rdev;",
          "100:  rdev = container_of(wk, struct cfg80211_registered_device,",
          "101:        sched_scan_results_wk);",
          "103:  cfg80211_lock_rdev(rdev);",
          "106:  if (rdev->sched_scan_req)",
          "107:   nl80211_send_sched_scan_results(rdev,",
          "108:       rdev->sched_scan_req->dev);",
          "110:  cfg80211_unlock_rdev(rdev);",
          "111: }",
          "113: void cfg80211_sched_scan_results(struct wiphy *wiphy)",
          "114: {",
          "116:  if (wiphy_to_dev(wiphy)->sched_scan_req)",
          "117:   queue_work(cfg80211_wq,",
          "118:       &wiphy_to_dev(wiphy)->sched_scan_results_wk);",
          "119: }",
          "120: EXPORT_SYMBOL(cfg80211_sched_scan_results);",
          "122: void __cfg80211_sched_scan_stopped(struct work_struct *wk)",
          "123: {",
          "124:  struct cfg80211_registered_device *rdev;",
          "126:  rdev = container_of(wk, struct cfg80211_registered_device,",
          "127:        sched_scan_stopped_wk);",
          "129:  cfg80211_lock_rdev(rdev);",
          "130:  __cfg80211_stop_sched_scan(rdev, true);",
          "131:  cfg80211_unlock_rdev(rdev);",
          "132: }",
          "134: void cfg80211_sched_scan_stopped(struct wiphy *wiphy)",
          "135: {",
          "136:  queue_work(cfg80211_wq, &wiphy_to_dev(wiphy)->sched_scan_stopped_wk);",
          "137: }",
          "138: EXPORT_SYMBOL(cfg80211_sched_scan_stopped);",
          "140: int __cfg80211_stop_sched_scan(struct cfg80211_registered_device *rdev,",
          "141:           bool driver_initiated)",
          "142: {",
          "143:  int err;",
          "144:  struct net_device *dev;",
          "146:  ASSERT_RDEV_LOCK(rdev);",
          "148:  if (!rdev->sched_scan_req)",
          "149:   return 0;",
          "151:  dev = rdev->sched_scan_req->dev;",
          "153:  err = rdev->ops->sched_scan_stop(&rdev->wiphy, dev,",
          "154:       driver_initiated);",
          "155:  if (err)",
          "156:   return err;",
          "158:  nl80211_send_sched_scan(rdev, dev, NL80211_CMD_SCHED_SCAN_STOPPED);",
          "160:  kfree(rdev->sched_scan_req);",
          "161:  rdev->sched_scan_req = NULL;",
          "163:  return err;",
          "164: }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
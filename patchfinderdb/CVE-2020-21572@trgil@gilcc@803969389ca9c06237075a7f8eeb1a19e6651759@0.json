{
  "cve_id": "CVE-2020-21572",
  "cve_desc": "Buffer overflow vulnerability in function src_parser_trans_stage_1_2_3 trgil gilcc before commit 803969389ca9c06237075a7f8eeb1a19e6651759, allows attackers to cause a denial of service.",
  "repo": "trgil/gilcc",
  "patch_hash": "803969389ca9c06237075a7f8eeb1a19e6651759",
  "patch_info": {
    "commit_hash": "803969389ca9c06237075a7f8eeb1a19e6651759",
    "repo": "trgil/gilcc",
    "commit_url": "https://github.com/trgil/gilcc/commit/803969389ca9c06237075a7f8eeb1a19e6651759",
    "files": [
      "src/src_parser.c"
    ],
    "message": "Fix parser tmp-buffer overflow issue",
    "before_after_code_files": [
      "src/src_parser.c||src/src_parser.c"
    ]
  },
  "patch_diff": {
    "src/src_parser.c||src/src_parser.c": [
      "File: src/src_parser.c -> src/src_parser.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "171:                             (PBUF_TMP_PREV_CHAR(pbuf) == ' ' || PBUF_TMP_PREV_CHAR(pbuf) == '\\t' ||",
      "172:                              PBUF_TMP_PREV_CHAR(pbuf) == '\\n')) {",
      "173:                         pbuf.f_indx++;",
      "175:                             (PBUF_TMP_PREV_CHAR(pbuf) == '\\\\')) {",
      "176:                         pbuf.tmp_indx--;",
      "177:                         pbuf.f_indx++;",
      "",
      "[Removed Lines]",
      "174:                     } else if (pbuf.tmp_indx &&",
      "",
      "[Added Lines]",
      "174:                     } else if (pbuf.tmp_indx &&",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "182:                     continue;",
      "184:                 case '\\\\':",
      "185:                     p_buf_push_tmp_char(&pbuf, '\\\\');",
      "186:                     continue;",
      "188:                 case '/':",
      "189:                     p_buf_push_tmp_char(&pbuf, '/');",
      "190:                     continue;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "185:                     p_buf_write_tmp(&pbuf, tmp_fd);",
      "190:                     p_buf_write_tmp(&pbuf, tmp_fd);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "925f1c706a040193274589a786fbbdf71b743820",
      "candidate_info": {
        "commit_hash": "925f1c706a040193274589a786fbbdf71b743820",
        "repo": "trgil/gilcc",
        "commit_url": "https://github.com/trgil/gilcc/commit/925f1c706a040193274589a786fbbdf71b743820",
        "files": [
          "src/gilcc.c",
          "src/src_parser.c",
          "src/src_parser.h"
        ],
        "message": "Add basic source parser flow",
        "before_after_code_files": [
          "src/gilcc.c||src/gilcc.c",
          "src/src_parser.c||src/src_parser.c",
          "src/src_parser.h||src/src_parser.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/src_parser.c||src/src_parser.c"
          ],
          "candidate": [
            "src/src_parser.c||src/src_parser.c"
          ]
        }
      },
      "candidate_diff": {
        "src/gilcc.c||src/gilcc.c": [
          "File: src/gilcc.c -> src/gilcc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "22: #include \"gilcc.h\"",
          "23: #include \"std_comp.h\"",
          "25: static char *srcs[GILCC_SRCS_MAX_NUM];",
          "26: static int srcs_num;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "24: #include \"src_parser.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "37: #define SET_STD_FLAG(STD) (1-(STD<<1))",
          "42: static void print_usage(void)",
          "43: {",
          "44:     printf( \"usage: gilcc [OPTIONS] [Input files]\\n\"",
          "",
          "[Removed Lines]",
          "39: #define TMP_FILE_NAME \".gilcc-tmpfile-XXXXXX\"",
          "40: #define TMP_FILE_SIZE 22",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "56:     printf(\"gilcc - Gil's Code Cleanup, version %.1f\\n\", GILCC_VERSION);",
          "57: }",
          "60: {",
          "61:     fprintf(stderr, \"Invalid standard configuration.\\n\");",
          "62:     return -1;",
          "",
          "[Removed Lines]",
          "59: static inline int std_error()",
          "",
          "[Added Lines]",
          "57: static inline int std_error(void)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "206: int main(int argc, char** argv)",
          "207: {",
          "211:     if(parse_cmd(--argc, ++argv) < 0)",
          "",
          "[Removed Lines]",
          "208:     int fd;",
          "209:     char fname[TMP_FILE_SIZE];",
          "",
          "[Added Lines]",
          "206:     const struct trans_config cfg;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "231:         }",
          "233:         printf(\"Processing file [ %s ]:\\n\", srcs[srcs_num]);",
          "245:     }",
          "247:     return 0;",
          "",
          "[Removed Lines]",
          "235:         strncpy(fname, TMP_FILE_NAME, TMP_FILE_SIZE);",
          "236:         fd = mkstemp(fname);",
          "237:         if (fd == -1) {",
          "238:             fprintf(stderr, \"**Error: could not create a working file.\\n\");",
          "239:             return -1;",
          "240:         }",
          "244:         unlink(fname);",
          "",
          "[Added Lines]",
          "231:         src_parser_cpp(srcs[srcs_num], cfg);",
          "",
          "---------------"
        ],
        "src/src_parser.c||src/src_parser.c": [
          "File: src/src_parser.c -> src/src_parser.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "17: #include <unistd.h>",
          "18: #include <string.h>",
          "19: #include <fcntl.h>",
          "20: #include <stdio.h>",
          "21: #include <stdlib.h>",
          "23: #include \"src_parser.h\"",
          "25: #define TMP_FILE_NAME           \".gilcc-tmpfile-XXXXXX\"",
          "26: #define TMP_FILE_NAME_SIZE      22",
          "29: #define P_STATE_CODE        0",
          "30: #define P_STATE_COMMENT_C   1",
          "34: #define SRC_PARSER_F_BUF_SIZE   200",
          "35: #define SRC_PARSER_TMP_BUF_SIZE 5",
          "37: struct parser_buf {",
          "38:     char f_buf[SRC_PARSER_F_BUF_SIZE];",
          "39:     char tmp_buf[SRC_PARSER_TMP_BUF_SIZE];",
          "41:     int f_indx;",
          "42:     int tmp_indx;",
          "43:     int f_read_size;",
          "44: };",
          "46: #define PBUF_F_CHAR(BUF) (BUF.f_buf[BUF.f_indx])",
          "47: #define PBUF_F_REMD(BUF) (BUF.f_read_size - BUF.f_indx)",
          "49: #define PBUF_TMP_PREV_CHAR(BUF) (BUF.tmp_buf[BUF.tmp_indx-1])",
          "51: static inline int p_buf_refill(struct parser_buf *buf, const int input_fd)",
          "52: {",
          "53:     int read_size;",
          "55:     read_size = read(input_fd, buf->f_buf, SRC_PARSER_F_BUF_SIZE);",
          "56:     buf->f_indx = 0;",
          "57:     buf->f_read_size = read_size;",
          "58:     return read_size;",
          "59: }",
          "61: static inline int p_buf_push_tmp_char(struct parser_buf *buf, const char c)",
          "62: {",
          "63:     buf->tmp_buf[buf->tmp_indx++] = c;",
          "64:     buf->f_indx++;",
          "65:     return buf->tmp_indx;",
          "66: }",
          "68: static inline int p_buf_write_tmp(struct parser_buf *buf, const int output_fd)",
          "69: {",
          "70:     int write_size;",
          "72:     if (!buf->tmp_indx)",
          "73:         return 0;",
          "75:     write_size = write(output_fd, buf->tmp_buf, buf->tmp_indx);",
          "76:     buf->tmp_indx = 0;",
          "78:     return write_size;",
          "79: }",
          "81: static inline int p_buf_write_f_char(struct parser_buf *buf, const int output_fd)",
          "82: {",
          "83:     return write(output_fd, &buf->f_buf[buf->f_indx++], 1);",
          "84: }",
          "88: static void print_file_full(int fd)",
          "89: {",
          "90:     char f_buf[SRC_PARSER_F_BUF_SIZE];",
          "91:     int read_size;",
          "93:     if (lseek(fd, 0, SEEK_SET)) {",
          "94:         fprintf(stderr, \"**Error: Could not set offset.\\n\");",
          "95:         return;",
          "96:     }",
          "98:     while ((read_size = read(fd, f_buf, SRC_PARSER_F_BUF_SIZE)) > 0) {",
          "99:         int read_indx = 0;",
          "101:         while (read_indx < read_size)",
          "102:             putchar(f_buf[read_indx++]);",
          "103:     }",
          "104: }",
          "106: static int src_parser_trans_stage_1_2_3(const int tmp_fd, const char *src, const struct trans_config cfg)",
          "107: {",
          "108:     struct parser_buf pbuf = {",
          "109:         .f_indx = 0,",
          "110:         .tmp_indx = 0,",
          "111:         .f_read_size = 0",
          "112:     };",
          "114:     int write_count = 0;",
          "115:     int src_fd;",
          "116:     int p_state = P_STATE_CODE;",
          "118:     src_fd = open(src, O_RDONLY);",
          "119:     if (src_fd == -1) {",
          "120:         fprintf(stderr, \"**Error: Could not open source file: %s.\\n\", src);",
          "121:         return -1;",
          "122:     }",
          "124:     while (p_buf_refill(&pbuf, src_fd) > 0) {",
          "126:         while (PBUF_F_REMD(pbuf)) {",
          "130:             switch (p_state) {",
          "131:             case P_STATE_COMMENT_C:",
          "133:                 switch (PBUF_F_CHAR(pbuf)) {",
          "134:                 case '*':",
          "135:                     p_buf_push_tmp_char(&pbuf, '*');",
          "136:                     continue;",
          "138:                 case '/':",
          "139:                     if (pbuf.tmp_indx && (PBUF_TMP_PREV_CHAR(pbuf) == '*')) {",
          "140:                         pbuf.tmp_indx--;",
          "141:                         p_state = P_STATE_CODE;",
          "142:                     }",
          "143:                     break;",
          "145:                 default:",
          "146:                     if (pbuf.tmp_indx && (PBUF_TMP_PREV_CHAR(pbuf) == '*'))",
          "147:                         pbuf.tmp_indx--;",
          "148:                     break;",
          "149:                 }",
          "151:                 pbuf.f_indx++;",
          "153:             case P_STATE_CODE:",
          "154:             default:",
          "158:                 switch (PBUF_F_CHAR(pbuf)) {",
          "159:                 case ' ':",
          "160:                 case '\\t':",
          "161:                     if (pbuf.tmp_indx &&",
          "162:                             (PBUF_TMP_PREV_CHAR(pbuf) == ' ' || PBUF_TMP_PREV_CHAR(pbuf) == '\\t' ||",
          "163:                              PBUF_TMP_PREV_CHAR(pbuf) == '\\n'))",
          "164:                         pbuf.f_indx++;",
          "165:                     else",
          "166:                         p_buf_push_tmp_char(&pbuf, ' ');",
          "168:                     continue;",
          "170:                 case '\\r':",
          "171:                 case '\\n':",
          "172:                     if (pbuf.tmp_indx &&",
          "173:                             (PBUF_TMP_PREV_CHAR(pbuf) == ' ' || PBUF_TMP_PREV_CHAR(pbuf) == '\\t' ||",
          "174:                              PBUF_TMP_PREV_CHAR(pbuf) == '\\n')) {",
          "175:                         pbuf.f_indx++;",
          "176:                     } else if (pbuf.tmp_indx &&",
          "177:                             (PBUF_TMP_PREV_CHAR(pbuf) == '\\\\')) {",
          "178:                         pbuf.tmp_indx--;",
          "179:                         pbuf.f_indx++;",
          "180:                     } else {",
          "181:                         p_buf_push_tmp_char(&pbuf, '\\n');",
          "182:                     }",
          "184:                     continue;",
          "186:                 case '\\\\':",
          "187:                     p_buf_push_tmp_char(&pbuf, '\\\\');",
          "188:                     continue;",
          "190:                 case '/':",
          "191:                     p_buf_push_tmp_char(&pbuf, '/');",
          "192:                     continue;",
          "194:                 case '*':",
          "195:                     if (pbuf.tmp_indx &&",
          "196:                             (PBUF_TMP_PREV_CHAR(pbuf) == '/')) {",
          "197:                         pbuf.tmp_indx--;",
          "198:                         pbuf.f_indx++;",
          "199:                         p_state = P_STATE_COMMENT_C;",
          "200:                         continue;",
          "201:                     }",
          "203:                 default:",
          "204:                     break;",
          "205:                 }",
          "208:                 p_buf_write_tmp(&pbuf, tmp_fd);",
          "209:                 p_buf_write_f_char(&pbuf, tmp_fd);",
          "210:             }",
          "211:         }",
          "212:     }",
          "214:     p_buf_write_tmp(&pbuf, tmp_fd);",
          "215:     return 0;",
          "216: }",
          "218: int src_parser_cpp(const char *src, const struct trans_config cfg)",
          "219: {",
          "220:     int tmp_fd;",
          "221:     char fname[TMP_FILE_NAME_SIZE];",
          "223:     strncpy(fname, TMP_FILE_NAME, TMP_FILE_NAME_SIZE);",
          "224:     tmp_fd = mkstemp(fname);",
          "225:     if (tmp_fd == -1) {",
          "226:         fprintf(stderr, \"**Error: could not create a working file.\\n\");",
          "227:         return -1;",
          "228:     }",
          "230:     src_parser_trans_stage_1_2_3(tmp_fd, src, cfg);",
          "232:     print_file_full(tmp_fd);",
          "234:     unlink(fname);",
          "235: }",
          "",
          "---------------"
        ],
        "src/src_parser.h||src/src_parser.h": [
          "File: src/src_parser.h -> src/src_parser.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "17: #ifndef _SRC_PARSER_H__",
          "18: #define _SRC_PARSER_H__",
          "20: #include \"std_comp.h\"",
          "23: int src_parser_cpp(const char *src, const struct trans_config cfg);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "ed14708ecbe04623c5b07d45b8cd0f15ca18f433",
      "candidate_info": {
        "commit_hash": "ed14708ecbe04623c5b07d45b8cd0f15ca18f433",
        "repo": "trgil/gilcc",
        "commit_url": "https://github.com/trgil/gilcc/commit/ed14708ecbe04623c5b07d45b8cd0f15ca18f433",
        "files": [
          "src/gilcc.c",
          "src/src_parser.c",
          "src/src_parser.h"
        ],
        "message": "Refactor src parser flow to use a stack\n\nSigned-off-by: gil <tkks085@gmail.com>",
        "before_after_code_files": [
          "src/gilcc.c||src/gilcc.c",
          "src/src_parser.c||src/src_parser.c",
          "src/src_parser.h||src/src_parser.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/src_parser.c||src/src_parser.c"
          ],
          "candidate": [
            "src/src_parser.c||src/src_parser.c"
          ]
        }
      },
      "candidate_diff": {
        "src/gilcc.c||src/gilcc.c": [
          "File: src/gilcc.c -> src/gilcc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "228:         }",
          "230:         printf(\"Processing file [ %s ]:\\n\", srcs[srcs_num]);",
          "232:     }",
          "234:     return 0;",
          "",
          "[Removed Lines]",
          "231:         src_parser_cpp(srcs[srcs_num], cfg);",
          "",
          "[Added Lines]",
          "231:         if (src_parser_cpp(srcs[srcs_num], &cfg) < 0)",
          "232:             return 1;",
          "",
          "---------------"
        ],
        "src/src_parser.c||src/src_parser.c": [
          "File: src/src_parser.c -> src/src_parser.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "29: #define P_STATE_CODE        0",
          "30: #define P_STATE_COMMENT_C   1",
          "44: };",
          "52: {",
          "53:     int read_size;",
          "58:     return read_size;",
          "59: }",
          "62: {",
          "66: }",
          "69: {",
          "70:     int write_size;",
          "73:         return 0;",
          "78:     return write_size;",
          "79: }",
          "82: {",
          "88: static void print_file_full(int fd)",
          "89: {",
          "91:     int read_size;",
          "93:     if (lseek(fd, 0, SEEK_SET)) {",
          "",
          "[Removed Lines]",
          "34: #define SRC_PARSER_F_BUF_SIZE   200",
          "35: #define SRC_PARSER_TMP_BUF_SIZE 5",
          "37: struct parser_buf {",
          "38:     char f_buf[SRC_PARSER_F_BUF_SIZE];",
          "39:     char tmp_buf[SRC_PARSER_TMP_BUF_SIZE];",
          "41:     int f_indx;",
          "42:     int tmp_indx;",
          "43:     int f_read_size;",
          "46: #define PBUF_F_CHAR(BUF) (BUF.f_buf[BUF.f_indx])",
          "47: #define PBUF_F_REMD(BUF) (BUF.f_read_size - BUF.f_indx)",
          "49: #define PBUF_TMP_PREV_CHAR(BUF) (BUF.tmp_buf[BUF.tmp_indx-1])",
          "51: static inline int p_buf_refill(struct parser_buf *buf, const int input_fd)",
          "55:     read_size = read(input_fd, buf->f_buf, SRC_PARSER_F_BUF_SIZE);",
          "56:     buf->f_indx = 0;",
          "57:     buf->f_read_size = read_size;",
          "61: static inline int p_buf_push_tmp_char(struct parser_buf *buf, const char c)",
          "63:     buf->tmp_buf[buf->tmp_indx++] = c;",
          "64:     buf->f_indx++;",
          "65:     return buf->tmp_indx;",
          "68: static inline int p_buf_write_tmp(struct parser_buf *buf, const int output_fd)",
          "72:     if (!buf->tmp_indx)",
          "75:     write_size = write(output_fd, buf->tmp_buf, buf->tmp_indx);",
          "76:     buf->tmp_indx = 0;",
          "81: static inline int p_buf_write_f_char(struct parser_buf *buf, const int output_fd)",
          "83:     return write(output_fd, &buf->f_buf[buf->f_indx++], 1);",
          "84: }",
          "90:     char f_buf[SRC_PARSER_F_BUF_SIZE];",
          "",
          "[Added Lines]",
          "33: #define PSTACK_BUF_SIZE     2",
          "34: #define PARSER_BUF_SIZE     200",
          "36: struct pbuf {",
          "37:     char pbuf_buf[PARSER_BUF_SIZE];",
          "38:     int pbuf_content_size;",
          "39:     int pbuf_indx;",
          "42: #define PBUF_CUR_CHAR(B) (B->pbuf_buf[B->pbuf_indx])",
          "43: #define PBUF_DATA_SIZE(B) (B->pbuf_content_size - B->pbuf_indx)",
          "44: #define PBUF_ADVN(B) (B->pbuf_indx++)",
          "45: #define PBUF_CLEAR(B) (B->pbuf_indx = 0)",
          "46: #define PBUF_EMPTY(B) (!(PBUF_DATA_SIZE(B)))",
          "47: #define PBUF_NOT_EMPTY(B) (!(PBUF_EMPTY(B)))",
          "49: static int pbuf_fill(struct pbuf *buf, const int ifd)",
          "53:     if (PBUF_NOT_EMPTY(buf))",
          "54:         return PBUF_DATA_SIZE(buf);",
          "56:     read_size = read(ifd, buf->pbuf_buf, PARSER_BUF_SIZE);",
          "57:     buf->pbuf_indx = 0;",
          "58:     buf->pbuf_content_size = read_size;",
          "63: static inline int pbuf_write_char(struct pbuf *buf, const int ofd)",
          "65:     return write(ofd, &buf->pbuf_buf[buf->pbuf_indx], 1);",
          "68: struct pstack {",
          "69:     char pstack_buf[PSTACK_BUF_SIZE];",
          "70:     int pstack_indx;",
          "71: };",
          "73: #define PSTACK_DATA_SIZE(S) (S.pstack_indx)",
          "74: #define PSTACK_EMPTY(S) (!(PSTACK_DATA_SIZE(S)))",
          "75: #define PSTACK_NOT_EMPTY(S) (!(PSTACK_EMPTY(S)))",
          "76: #define PSTACK_PUSH_CHAR(S, C) (S.pstack_buf[S.pstack_indx++] = C)",
          "77: #define PSTACK_POP_N(S, N) (S.pstack_indx -= N)",
          "78: #define PSTACK_CLEAR(S) (S.pstack_indx = 0)",
          "79: #define PSTACK_GET_ELEMENT(S, L) (S.pstack_buf[L - 1])",
          "80: #define PSTACK_GET_ELEMENT_REV(S, L) (S.pstack_buf[S.pstack_indx - L])",
          "82: static inline int pstack_write(struct pstack *stk, const int ofd)",
          "86:     if (!stk->pstack_indx)",
          "89:     if ((write_size = write(ofd, stk->pstack_buf, stk->pstack_indx)) < 0)",
          "90:         return write_size;",
          "92:     stk->pstack_indx = 0;",
          "97: static inline int pstack_shift_write_n(struct pstack *stk, const int ofd, const int n)",
          "99:     int write_size;",
          "100:     int i;",
          "102:     if (!stk->pstack_indx)",
          "103:         return 0;",
          "105:     if (n > stk->pstack_indx)",
          "106:         return -1;",
          "108:     if ((write_size = write(ofd, stk->pstack_buf, n)) < 0)",
          "109:         return write_size;",
          "111:     for (i = 0; (i + n) < stk->pstack_indx; i++)",
          "112:         stk->pstack_buf[i] = stk->pstack_buf[(i + n)];",
          "114:     stk->pstack_indx -= n;",
          "116:     return write_size;",
          "117: }",
          "121:     char f_buf[PARSER_BUF_SIZE];",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "95:         return;",
          "96:     }",
          "99:         int read_indx = 0;",
          "101:         while (read_indx < read_size)",
          "",
          "[Removed Lines]",
          "98:     while ((read_size = read(fd, f_buf, SRC_PARSER_F_BUF_SIZE)) > 0) {",
          "",
          "[Added Lines]",
          "129:     while ((read_size = read(fd, f_buf, PARSER_BUF_SIZE)) > 0) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "103:     }",
          "104: }",
          "107: {",
          "112:     };",
          "115:     int src_fd;",
          "118:     src_fd = open(src, O_RDONLY);",
          "119:     if (src_fd == -1) {",
          "",
          "[Removed Lines]",
          "106: static int src_parser_trans_stage_1_2_3(const int tmp_fd, const char *src, const struct trans_config cfg)",
          "108:     struct parser_buf pbuf = {",
          "109:         .f_indx = 0,",
          "110:         .tmp_indx = 0,",
          "111:         .f_read_size = 0",
          "114:     int write_count = 0;",
          "116:     int p_state = P_STATE_CODE;",
          "",
          "[Added Lines]",
          "137: static int src_parser_tstage_1_2_3_c_cmnt(  const int tmp_fd,",
          "138:                                             const int src_fd,",
          "139:                                             struct pbuf *buf,",
          "140:                                             const struct trans_config *cfg)",
          "141: {",
          "142:     struct pstack stk = {",
          "143:         .pstack_indx = 0",
          "144:     };",
          "146:     while (PBUF_DATA_SIZE(buf) || (pbuf_fill(buf, src_fd) > 0)) {",
          "147:         switch (PBUF_CUR_CHAR(buf)) {",
          "148:         case '*':",
          "149:             PSTACK_PUSH_CHAR(stk, '*');",
          "150:             break;",
          "152:         case '/':",
          "153:             PSTACK_PUSH_CHAR(stk, '/');",
          "154:             break;",
          "156:         default:",
          "157:             PSTACK_CLEAR(stk);",
          "158:             break;",
          "159:         }",
          "161:         if (PSTACK_DATA_SIZE(stk) > 1) {",
          "162:             if (    (PSTACK_GET_ELEMENT_REV(stk, 2) == '*') &&",
          "163:                     (PSTACK_GET_ELEMENT_REV(stk, 1) == '/')) {",
          "164:                 PBUF_ADVN(buf);",
          "165:                 return 0;",
          "166:             } else {",
          "167:                 if (pstack_shift_write_n(&stk, tmp_fd, 1) < 0)",
          "168:                     return -1;",
          "169:             }",
          "170:         }",
          "172:         PBUF_ADVN(buf);",
          "173:     }",
          "179:     return -1;",
          "180: }",
          "182: static int src_parser_tstage_1_2_3_default( const int tmp_fd,",
          "183:                                             const int src_fd,",
          "184:                                             struct pbuf *buf,",
          "185:                                             const struct trans_config *cfg)",
          "187:     struct pstack stk = {",
          "188:         .pstack_indx = 0",
          "189:     };",
          "191:     pbuf_fill(buf, src_fd);",
          "193:     while (PBUF_DATA_SIZE(buf) || (pbuf_fill(buf, src_fd) > 0)) {",
          "195:         switch (PBUF_CUR_CHAR(buf)) {",
          "196:         case ' ':",
          "197:         case '\\t':",
          "198:             PSTACK_PUSH_CHAR(stk, ' ');",
          "199:             break;",
          "201:         case '\\r':",
          "202:         case '\\n':",
          "203:             PSTACK_PUSH_CHAR(stk, '\\n');",
          "204:             break;",
          "206:         case '\\\\':",
          "207:             PSTACK_PUSH_CHAR(stk, '\\\\');",
          "208:             break;",
          "210:         case '/':",
          "211:             PSTACK_PUSH_CHAR(stk, '/');",
          "212:             break;",
          "214:         case '*':",
          "215:             PSTACK_PUSH_CHAR(stk, '*');",
          "216:             break;",
          "218:         default:",
          "219:             pstack_write(&stk, tmp_fd);",
          "220:             pbuf_write_char(buf, tmp_fd);",
          "221:             PBUF_ADVN(buf);",
          "222:             continue;",
          "223:         }",
          "225:         if (PSTACK_DATA_SIZE(stk) > 1) {",
          "226:             if ((PSTACK_GET_ELEMENT_REV(stk, 2) == ' ') &&",
          "227:                 (PSTACK_GET_ELEMENT_REV(stk, 1) == ' ')) {",
          "228:                 PSTACK_POP_N(stk, 1);",
          "230:             } else if ( (PSTACK_GET_ELEMENT_REV(stk, 2) == '\\n') &&",
          "231:                         (PSTACK_GET_ELEMENT_REV(stk, 1) == '\\n')) {",
          "232:                 PSTACK_POP_N(stk, 1);",
          "234:             } else if ( (PSTACK_GET_ELEMENT_REV(stk, 2) == '\\n') &&",
          "235:                         (PSTACK_GET_ELEMENT_REV(stk, 1) == ' ')) {",
          "236:                 PSTACK_POP_N(stk, 1);",
          "238:             } else if ( (PSTACK_GET_ELEMENT_REV(stk, 2) == ' ') &&",
          "239:                         (PSTACK_GET_ELEMENT_REV(stk, 1) == '\\n')) {",
          "240:                 PSTACK_POP_N(stk, 2);",
          "241:                 PSTACK_PUSH_CHAR(stk, '\\n');",
          "243:             } else if ( (PSTACK_GET_ELEMENT_REV(stk, 2) == '/') &&",
          "244:                         (PSTACK_GET_ELEMENT_REV(stk, 1) == '*')) {",
          "245:                 PSTACK_POP_N(stk, 2);",
          "246:                 if (src_parser_tstage_1_2_3_c_cmnt(tmp_fd, src_fd, buf, cfg) < 0)",
          "247:                     return -1;",
          "249:             } else if ( (PSTACK_GET_ELEMENT_REV(stk, 2) == '\\\\') &&",
          "250:                         (PSTACK_GET_ELEMENT_REV(stk, 1) == '\\n')) {",
          "251:                 PSTACK_POP_N(stk, 2);",
          "253:             } else {",
          "255:                 if (pstack_shift_write_n(&stk, tmp_fd, 1) < 0)",
          "256:                     return -1;",
          "257:             }",
          "258:         }",
          "260:         PBUF_ADVN(buf);",
          "261:     }",
          "263:     return 0;",
          "264: }",
          "266: static int src_parser_tstage_1_2_3(const int tmp_fd, const char *src, const struct trans_config *cfg)",
          "267: {",
          "268:     struct pbuf buf = {",
          "269:         .pbuf_indx = 0,",
          "270:         .pbuf_content_size = 0",
          "274:     int ret_val;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "121:         return -1;",
          "122:     }",
          "216: }",
          "219: {",
          "220:     int tmp_fd;",
          "221:     char fname[TMP_FILE_NAME_SIZE];",
          "223:     strncpy(fname, TMP_FILE_NAME, TMP_FILE_NAME_SIZE);",
          "224:     tmp_fd = mkstemp(fname);",
          "",
          "[Removed Lines]",
          "124:     while (p_buf_refill(&pbuf, src_fd) > 0) {",
          "126:         while (PBUF_F_REMD(pbuf)) {",
          "128:             switch (p_state) {",
          "129:             case P_STATE_COMMENT_C:",
          "131:                 switch (PBUF_F_CHAR(pbuf)) {",
          "132:                 case '*':",
          "133:                     p_buf_push_tmp_char(&pbuf, '*');",
          "134:                     continue;",
          "136:                 case '/':",
          "137:                     if (pbuf.tmp_indx && (PBUF_TMP_PREV_CHAR(pbuf) == '*')) {",
          "138:                         pbuf.tmp_indx--;",
          "139:                         p_state = P_STATE_CODE;",
          "140:                     }",
          "141:                     break;",
          "143:                 default:",
          "144:                     if (pbuf.tmp_indx && (PBUF_TMP_PREV_CHAR(pbuf) == '*'))",
          "145:                         pbuf.tmp_indx--;",
          "146:                     break;",
          "147:                 }",
          "149:                 pbuf.f_indx++;",
          "151:             case P_STATE_CODE:",
          "152:             default:",
          "156:                 switch (PBUF_F_CHAR(pbuf)) {",
          "157:                 case ' ':",
          "158:                 case '\\t':",
          "159:                     if (pbuf.tmp_indx &&",
          "160:                             (PBUF_TMP_PREV_CHAR(pbuf) == ' ' || PBUF_TMP_PREV_CHAR(pbuf) == '\\t' ||",
          "161:                              PBUF_TMP_PREV_CHAR(pbuf) == '\\n'))",
          "162:                         pbuf.f_indx++;",
          "163:                     else",
          "164:                         p_buf_push_tmp_char(&pbuf, ' ');",
          "166:                     continue;",
          "168:                 case '\\r':",
          "169:                 case '\\n':",
          "170:                     if (pbuf.tmp_indx &&",
          "171:                             (PBUF_TMP_PREV_CHAR(pbuf) == ' ' || PBUF_TMP_PREV_CHAR(pbuf) == '\\t' ||",
          "172:                              PBUF_TMP_PREV_CHAR(pbuf) == '\\n')) {",
          "173:                         pbuf.f_indx++;",
          "174:                     } else if (pbuf.tmp_indx &&",
          "175:                             (PBUF_TMP_PREV_CHAR(pbuf) == '\\\\')) {",
          "176:                         pbuf.tmp_indx--;",
          "177:                         pbuf.f_indx++;",
          "178:                     } else {",
          "179:                         p_buf_push_tmp_char(&pbuf, '\\n');",
          "180:                     }",
          "182:                     continue;",
          "184:                 case '\\\\':",
          "185:                     p_buf_write_tmp(&pbuf, tmp_fd);",
          "186:                     p_buf_push_tmp_char(&pbuf, '\\\\');",
          "187:                     continue;",
          "189:                 case '/':",
          "190:                     p_buf_write_tmp(&pbuf, tmp_fd);",
          "191:                     p_buf_push_tmp_char(&pbuf, '/');",
          "192:                     continue;",
          "194:                 case '*':",
          "195:                     if (pbuf.tmp_indx &&",
          "196:                             (PBUF_TMP_PREV_CHAR(pbuf) == '/')) {",
          "197:                         pbuf.tmp_indx--;",
          "198:                         pbuf.f_indx++;",
          "199:                         p_state = P_STATE_COMMENT_C;",
          "200:                         continue;",
          "201:                     }",
          "203:                 default:",
          "204:                     break;",
          "205:                 }",
          "208:                 p_buf_write_tmp(&pbuf, tmp_fd);",
          "209:                 p_buf_write_f_char(&pbuf, tmp_fd);",
          "210:             }",
          "211:         }",
          "212:     }",
          "214:     p_buf_write_tmp(&pbuf, tmp_fd);",
          "215:     return 0;",
          "218: int src_parser_cpp(const char *src, const struct trans_config cfg)",
          "",
          "[Added Lines]",
          "282:     ret_val = src_parser_tstage_1_2_3_default(tmp_fd, src_fd, &buf, cfg);",
          "284:     close(src_fd);",
          "286:     return ret_val;",
          "289: int src_parser_cpp(const char *src, const struct trans_config *cfg)",
          "293:     int ret_val;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "227:         return -1;",
          "228:     }",
          "232:     print_file_full(tmp_fd);",
          "234:     unlink(fname);",
          "235: }",
          "",
          "[Removed Lines]",
          "230:     src_parser_trans_stage_1_2_3(tmp_fd, src, cfg);",
          "",
          "[Added Lines]",
          "302:     ret_val = src_parser_tstage_1_2_3(tmp_fd, src, cfg);",
          "303:     if (ret_val < 0)",
          "304:         return ret_val;",
          "309:     return 0;",
          "",
          "---------------"
        ],
        "src/src_parser.h||src/src_parser.h": [
          "File: src/src_parser.h -> src/src_parser.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "20: #include \"std_comp.h\"",
          "",
          "[Removed Lines]",
          "23: int src_parser_cpp(const char *src, const struct trans_config cfg);",
          "",
          "[Added Lines]",
          "22: extern struct trans_config TRANS_CFG;",
          "25: int src_parser_cpp(const char *src, const struct trans_config *cfg);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "58e88fdd5d925f5c9d623a5831d6e765ea2893da",
      "candidate_info": {
        "commit_hash": "58e88fdd5d925f5c9d623a5831d6e765ea2893da",
        "repo": "trgil/gilcc",
        "commit_url": "https://github.com/trgil/gilcc/commit/58e88fdd5d925f5c9d623a5831d6e765ea2893da",
        "files": [
          "src/src_parser.c",
          "src/std_comp.h"
        ],
        "message": "Change PP parsing flow to separate state-machine parsing.",
        "before_after_code_files": [
          "src/src_parser.c||src/src_parser.c",
          "src/std_comp.h||src/std_comp.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/src_parser.c||src/src_parser.c"
          ],
          "candidate": [
            "src/src_parser.c||src/src_parser.c"
          ]
        }
      },
      "candidate_diff": {
        "src/src_parser.c||src/src_parser.c": [
          "File: src/src_parser.c -> src/src_parser.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "35:     int pbuf_indx;",
          "36: };",
          "44: static int pbuf_fill(struct pbuf *buf, const int ifd)",
          "45: {",
          "46:     int read_size;",
          "51:     read_size = read(ifd, buf->pbuf_buf, PARSER_BUF_SIZE);",
          "52:     buf->pbuf_indx = 0;",
          "",
          "[Removed Lines]",
          "38: #define PBUF_CUR_CHAR(B) (B->pbuf_buf[B->pbuf_indx])",
          "39: #define PBUF_DATA_SIZE(B) (B->pbuf_content_size - B->pbuf_indx)",
          "40: #define PBUF_ADVN(B) (B->pbuf_indx++)",
          "41: #define PBUF_EMPTY(B) (!(PBUF_DATA_SIZE(B)))",
          "42: #define PBUF_NOT_EMPTY(B) (!(PBUF_EMPTY(B)))",
          "48:     if (PBUF_NOT_EMPTY(buf))",
          "49:         return PBUF_DATA_SIZE(buf);",
          "",
          "[Added Lines]",
          "38: #define PBUF_CUR_CHAR(B) (B.pbuf_buf[B.pbuf_indx])",
          "39: #define PBUF_DATA_SIZE(B) (B.pbuf_content_size - B.pbuf_indx)",
          "40: #define PBUF_ADVN(B) (B.pbuf_indx++)",
          "46:     if (buf->pbuf_content_size - buf->pbuf_indx)",
          "47:         return (buf->pbuf_content_size - buf->pbuf_indx);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "68: #define PSTACK_DATA_SIZE(S) (S.pstack_indx)",
          "69: #define PSTACK_PUSH_CHAR(S, C) (S.pstack_buf[S.pstack_indx++] = C)",
          "71: #define PSTACK_CLEAR(S) (S.pstack_indx = 0)",
          "74: static inline int pstack_write(struct pstack *stk, const int ofd)",
          "75: {",
          "",
          "[Removed Lines]",
          "70: #define PSTACK_POP_N(S, N) (S.pstack_indx -= N)",
          "72: #define PSTACK_GET_ELEMENT_REV(S, L) (S.pstack_buf[S.pstack_indx - L])",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "78:     if (!stk->pstack_indx)",
          "79:         return 0;",
          "108:     return write_size;",
          "109: }",
          "",
          "[Removed Lines]",
          "81:     if ((write_size = write(ofd, stk->pstack_buf, stk->pstack_indx)) < 0)",
          "82:         return write_size;",
          "84:     stk->pstack_indx = 0;",
          "86:     return write_size;",
          "87: }",
          "89: static inline int pstack_shift_write_n(struct pstack *stk, const int ofd, const int n)",
          "90: {",
          "91:     int write_size;",
          "92:     int i;",
          "94:     if (!stk->pstack_indx)",
          "95:         return 0;",
          "97:     if (n > stk->pstack_indx)",
          "98:         return -1;",
          "100:     if ((write_size = write(ofd, stk->pstack_buf, n)) < 0)",
          "101:         return write_size;",
          "103:     for (i = 0; (i + n) < stk->pstack_indx; i++)",
          "104:         stk->pstack_buf[i] = stk->pstack_buf[(i + n)];",
          "106:     stk->pstack_indx -= n;",
          "",
          "[Added Lines]",
          "77:     if ((write_size = write(ofd, stk->pstack_buf, stk->pstack_indx)) > 0)",
          "78:         stk->pstack_indx = 0;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "124:         while (read_indx < read_size)",
          "125:             putchar(f_buf[read_indx++]);",
          "126:     }",
          "127: }",
          "133: {",
          "134:     struct pstack stk = {",
          "135:         .pstack_indx = 0",
          "136:     };",
          "142:             break;",
          "146:             break;",
          "150:             break;",
          "156:                 PBUF_ADVN(buf);",
          "158:             } else {",
          "161:             }",
          "172: }",
          "178: {",
          "181:     };",
          "200:             break;",
          "208:             break;",
          "210:         default:",
          "215:         }",
          "249:             }",
          "250:         }",
          "252:     }",
          "254:     return 0;",
          "255: }",
          "258: {",
          "264:     int src_fd;",
          "265:     int ret_val;",
          "267:     src_fd = open(src, O_RDONLY);",
          "268:     if (src_fd == -1) {",
          "269:         fprintf(stderr, \"**Error: Could not open source file: %s.\\n\", src);",
          "270:         return -1;",
          "271:     }",
          "275:     close(src_fd);",
          "289:         fprintf(stderr, \"**Error: could not create a working file.\\n\");",
          "290:         return -1;",
          "291:     }",
          "294:     if (ret_val < 0)",
          "295:         return ret_val;",
          "300:     return 0;",
          "301: }",
          "",
          "[Removed Lines]",
          "129: static int src_parser_tstage_1_2_3_c_cmnt(  const int tmp_fd,",
          "130:                                             const int src_fd,",
          "131:                                             struct pbuf *buf,",
          "132:                                             const struct trans_config *cfg)",
          "138:     while (PBUF_DATA_SIZE(buf) || (pbuf_fill(buf, src_fd) > 0)) {",
          "139:         switch (PBUF_CUR_CHAR(buf)) {",
          "140:         case '*':",
          "141:             PSTACK_PUSH_CHAR(stk, '*');",
          "144:         case '/':",
          "145:             PSTACK_PUSH_CHAR(stk, '/');",
          "148:         default:",
          "149:             PSTACK_CLEAR(stk);",
          "151:         }",
          "153:         if (PSTACK_DATA_SIZE(stk) > 1) {",
          "154:             if (    (PSTACK_GET_ELEMENT_REV(stk, 2) == '*') &&",
          "155:                     (PSTACK_GET_ELEMENT_REV(stk, 1) == '/')) {",
          "157:                 return 0;",
          "159:                 if (pstack_shift_write_n(&stk, tmp_fd, 1) < 0)",
          "160:                     return -1;",
          "162:         }",
          "164:         PBUF_ADVN(buf);",
          "165:     }",
          "171:     return -1;",
          "174: static int src_parser_tstage_1_2_3_default( const int tmp_fd,",
          "175:                                             const int src_fd,",
          "176:                                             struct pbuf *buf,",
          "177:                                             const struct trans_config *cfg)",
          "179:     struct pstack stk = {",
          "180:         .pstack_indx = 0",
          "183:     pbuf_fill(buf, src_fd);",
          "185:     while (PBUF_DATA_SIZE(buf) || (pbuf_fill(buf, src_fd) > 0)) {",
          "187:         switch (PBUF_CUR_CHAR(buf)) {",
          "188:         case ' ':",
          "189:         case '\\t':",
          "190:             PSTACK_PUSH_CHAR(stk, ' ');",
          "191:             break;",
          "193:         case '\\r':",
          "194:         case '\\n':",
          "195:             PSTACK_PUSH_CHAR(stk, '\\n');",
          "196:             break;",
          "198:         case '\\\\':",
          "199:             PSTACK_PUSH_CHAR(stk, '\\\\');",
          "202:         case '/':",
          "203:             PSTACK_PUSH_CHAR(stk, '/');",
          "204:             break;",
          "206:         case '*':",
          "207:             PSTACK_PUSH_CHAR(stk, '*');",
          "211:             pstack_write(&stk, tmp_fd);",
          "212:             pbuf_write_char(buf, tmp_fd);",
          "213:             PBUF_ADVN(buf);",
          "214:             continue;",
          "217:         if (PSTACK_DATA_SIZE(stk) > 1) {",
          "218:             if ((PSTACK_GET_ELEMENT_REV(stk, 2) == ' ') &&",
          "219:                 (PSTACK_GET_ELEMENT_REV(stk, 1) == ' ')) {",
          "220:                 PSTACK_POP_N(stk, 1);",
          "222:             } else if ( (PSTACK_GET_ELEMENT_REV(stk, 2) == '\\n') &&",
          "223:                         (PSTACK_GET_ELEMENT_REV(stk, 1) == '\\n')) {",
          "224:                 PSTACK_POP_N(stk, 1);",
          "226:             } else if ( (PSTACK_GET_ELEMENT_REV(stk, 2) == '\\n') &&",
          "227:                         (PSTACK_GET_ELEMENT_REV(stk, 1) == ' ')) {",
          "228:                 PSTACK_POP_N(stk, 1);",
          "230:             } else if ( (PSTACK_GET_ELEMENT_REV(stk, 2) == ' ') &&",
          "231:                         (PSTACK_GET_ELEMENT_REV(stk, 1) == '\\n')) {",
          "232:                 PSTACK_POP_N(stk, 2);",
          "233:                 PSTACK_PUSH_CHAR(stk, '\\n');",
          "235:             } else if ( (PSTACK_GET_ELEMENT_REV(stk, 2) == '/') &&",
          "236:                         (PSTACK_GET_ELEMENT_REV(stk, 1) == '*')) {",
          "237:                 PSTACK_POP_N(stk, 2);",
          "238:                 if (src_parser_tstage_1_2_3_c_cmnt(tmp_fd, src_fd, buf, cfg) < 0)",
          "239:                     return -1;",
          "241:             } else if ( (PSTACK_GET_ELEMENT_REV(stk, 2) == '\\\\') &&",
          "242:                         (PSTACK_GET_ELEMENT_REV(stk, 1) == '\\n')) {",
          "243:                 PSTACK_POP_N(stk, 2);",
          "245:             } else {",
          "247:                 if (pstack_shift_write_n(&stk, tmp_fd, 1) < 0)",
          "248:                     return -1;",
          "251:         PBUF_ADVN(buf);",
          "257: static int src_parser_tstage_1_2_3(const int tmp_fd, const char *src, const struct trans_config *cfg)",
          "259:     struct pbuf buf = {",
          "260:         .pbuf_indx = 0,",
          "261:         .pbuf_content_size = 0",
          "262:     };",
          "273:     ret_val = src_parser_tstage_1_2_3_default(tmp_fd, src_fd, &buf, cfg);",
          "277:     return ret_val;",
          "278: }",
          "280: int src_parser_cpp(const char *src, const struct trans_config *cfg)",
          "281: {",
          "282:     int tmp_fd;",
          "283:     char fname[TMP_FILE_NAME_SIZE];",
          "284:     int ret_val;",
          "286:     strncpy(fname, TMP_FILE_NAME, TMP_FILE_NAME_SIZE);",
          "287:     tmp_fd = mkstemp(fname);",
          "288:     if (tmp_fd == -1) {",
          "293:     ret_val = src_parser_tstage_1_2_3(tmp_fd, src, cfg);",
          "297:     print_file_full(tmp_fd);",
          "298:     unlink(fname);",
          "",
          "[Added Lines]",
          "99:     printf(\"\\n\");",
          "102: static inline int write_char(const char c, const int ofd)",
          "104:     return write(ofd, &c, 1);",
          "105: }",
          "107: static int src_parser_tstage_1( const int dst_fd,",
          "108:                                 const int src_fd,",
          "109:                                 const bool exp_trigraphs)",
          "110: {",
          "111:     struct pbuf buf = {",
          "112:         .pbuf_indx = 0,",
          "113:         .pbuf_content_size = 0",
          "114:     };",
          "120:     int state = 0;",
          "137:     pbuf_fill(&buf, src_fd);",
          "138:     while (PBUF_DATA_SIZE(buf) || (pbuf_fill(&buf, src_fd) > 0)) {",
          "139:         switch(state) {",
          "140:         case 0:",
          "141:             switch (PBUF_CUR_CHAR(buf)) {",
          "142:             case '\\r':",
          "143:                 state++;",
          "144:             case '\\n':",
          "145:                 state++;",
          "146:             case 30:",
          "147:                 write_char('\\n', dst_fd);",
          "148:                 PBUF_ADVN(buf);",
          "149:                 break;",
          "151:             case '?':",
          "152:                 if (exp_trigraphs == true) {",
          "153:                     PSTACK_PUSH_CHAR(stk, '?');",
          "154:                     PBUF_ADVN(buf);",
          "155:                     state = 3;",
          "156:                     break;",
          "157:                 }",
          "158:             default:",
          "159:                 pbuf_write_char(&buf, dst_fd);",
          "160:                 PBUF_ADVN(buf);",
          "161:             }",
          "165:         case 1:",
          "166:             if (PBUF_CUR_CHAR(buf) == '\\r')",
          "167:                 PBUF_ADVN(buf);",
          "168:             state = 0;",
          "171:         case 2:",
          "172:             if (PBUF_CUR_CHAR(buf) == '\\n')",
          "173:                 PBUF_ADVN(buf);",
          "174:             state = 0;",
          "177:         case 3:",
          "178:             if (PBUF_CUR_CHAR(buf) == '?') {",
          "179:                 PSTACK_PUSH_CHAR(stk, '?');",
          "181:                 state = 4;",
          "183:                 pstack_write(&stk, dst_fd);",
          "184:                 state = 0;",
          "186:             break;",
          "188:         case 4:",
          "189:             {",
          "190:                 char c;",
          "192:                 switch (PBUF_CUR_CHAR(buf)) {",
          "193:                 case '=':",
          "194:                     c = '#';",
          "195:                     break;",
          "196:                 case '(':",
          "197:                     c = '[';",
          "198:                     break;",
          "199:                 case ')':",
          "200:                     c = ']';",
          "201:                     break;",
          "202:                 case '/':",
          "203:                     c = '\\\\';",
          "204:                     break;",
          "205:                 case '\\'':",
          "206:                     c = '^';",
          "207:                     break;",
          "208:                 case '<':",
          "209:                     c = '{';",
          "210:                     break;",
          "211:                 case '>':",
          "212:                     c = '}';",
          "213:                     break;",
          "214:                 case '!':",
          "215:                     c = '|';",
          "216:                     break;",
          "217:                 case '-':",
          "218:                     c = '~';",
          "219:                     break;",
          "220:                 default:",
          "221:                     c = '\\0';",
          "222:                     break;",
          "223:                 }",
          "225:                 if (c) {",
          "226:                     write_char(c, dst_fd);",
          "227:                     PSTACK_CLEAR(stk);",
          "228:                     PBUF_ADVN(buf);",
          "229:                 } else {",
          "230:                     pstack_write(&stk, dst_fd);",
          "231:                 }",
          "232:             }",
          "234:             state = 0;",
          "235:             break;",
          "237:         default:",
          "238:             return -1;",
          "239:         }",
          "240:     }",
          "242:     return 0;",
          "245: static int src_parser_tstage_2( const int dst_fd,",
          "246:                                 const int src_fd)",
          "248:     struct pbuf buf = {",
          "249:         .pbuf_indx = 0,",
          "250:         .pbuf_content_size = 0",
          "253:     int state = 0;",
          "259:     pbuf_fill(&buf, src_fd);",
          "260:     while (PBUF_DATA_SIZE(buf) || (pbuf_fill(&buf, src_fd) > 0)) {",
          "261:         switch (state) {",
          "262:         case 0:",
          "263:             if (PBUF_CUR_CHAR(buf) == '\\\\')",
          "264:                 state = 1;",
          "265:             else",
          "266:                 pbuf_write_char(&buf, dst_fd);",
          "268:             PBUF_ADVN(buf);",
          "271:         case 1:",
          "272:             if (PBUF_CUR_CHAR(buf) == '\\n')",
          "273:                 PBUF_ADVN(buf);",
          "274:             else",
          "275:                 write_char('\\\\', dst_fd);",
          "277:             state = 0;",
          "281:             return -1;",
          "283:     }",
          "286:     return 0;",
          "287: }",
          "289: static int src_parser_tstage_3( const int dst_fd,",
          "290:                                 const int src_fd,",
          "291:                                 const bool exp_cpp_cmnts)",
          "292: {",
          "293:     struct pbuf buf = {",
          "294:         .pbuf_indx = 0,",
          "295:         .pbuf_content_size = 0",
          "296:     };",
          "298:     int state = 0;",
          "299:     bool in_string = false;",
          "309:     pbuf_fill(&buf, src_fd);",
          "310:     while (PBUF_DATA_SIZE(buf) || (pbuf_fill(&buf, src_fd) > 0)) {",
          "311:         switch (state) {",
          "312:         case 0:",
          "313:             switch (PBUF_CUR_CHAR(buf)) {",
          "314:             case '/':",
          "315:                 state = 1;",
          "316:                 break;",
          "318:             case ' ':",
          "319:             case '\\t':",
          "320:                 if (in_string) {",
          "321:                     pbuf_write_char(&buf, dst_fd);",
          "322:                 } else {",
          "323:                     write_char(' ', dst_fd);",
          "324:                     state = 5;",
          "325:                 }",
          "326:                 PBUF_ADVN(buf);",
          "327:                 break;",
          "329:             case '\\n':",
          "330:                 if (in_string) {",
          "331:                     pbuf_write_char(&buf, dst_fd);",
          "332:                 } else {",
          "333:                     write_char('\\n', dst_fd);",
          "334:                     state = 6;",
          "335:                 }",
          "336:                 PBUF_ADVN(buf);",
          "337:                 break;",
          "339:             case '\\\"':",
          "340:                 in_string = (in_string)?false:true;",
          "342:             default:",
          "343:                 pbuf_write_char(&buf, dst_fd);",
          "344:                 PBUF_ADVN(buf);",
          "345:             }",
          "346:             break;",
          "348:         case 1:",
          "349:             switch (PBUF_CUR_CHAR(buf)) {",
          "350:             case '*':",
          "351:                 state = 2;",
          "352:                 PBUF_ADVN(buf);",
          "353:                 break;",
          "355:             case '/':",
          "356:                 if (exp_cpp_cmnts == true) {",
          "357:                     state = 4;",
          "358:                     PBUF_ADVN(buf);",
          "359:                     break;",
          "360:                 }",
          "362:             default:",
          "363:                 write_char('/', dst_fd);",
          "364:                 state = 0;",
          "366:             break;",
          "368:         case 2:",
          "369:             if (PBUF_CUR_CHAR(buf) == '*')",
          "370:                 state = 3;",
          "371:             PBUF_ADVN(buf);",
          "372:             break;",
          "374:         case 3:",
          "375:             if (PBUF_CUR_CHAR(buf) == '/')",
          "376:                 state = 0;",
          "377:             else",
          "378:                 state = 2;",
          "379:             PBUF_ADVN(buf);",
          "380:             break;",
          "382:         case 4:",
          "383:             if (PBUF_CUR_CHAR(buf) == '\\n')",
          "384:                 state = 0;",
          "385:             PBUF_ADVN(buf);",
          "386:             break;",
          "388:         case 5:",
          "389:             if ((PBUF_CUR_CHAR(buf) == ' ') || (PBUF_CUR_CHAR(buf) == '\\t'))",
          "390:                 PBUF_ADVN(buf);",
          "391:             else",
          "392:                 state = 0;",
          "393:             break;",
          "395:         case 6:",
          "396:             if (PBUF_CUR_CHAR(buf) == '\\n')",
          "397:                 PBUF_ADVN(buf);",
          "398:             else",
          "399:                 state = 0;",
          "400:             break;",
          "402:         default:",
          "403:             return -1;",
          "411: int src_parser_cpp(const char *src, const struct trans_config *cfg)",
          "413:     int tmp_fd1, tmp_fd2, tmp_fd3;",
          "415:     char fname1[TMP_FILE_NAME_SIZE];",
          "416:     char fname2[TMP_FILE_NAME_SIZE];",
          "417:     char fname3[TMP_FILE_NAME_SIZE];",
          "428:     strncpy(fname1, TMP_FILE_NAME, TMP_FILE_NAME_SIZE);",
          "429:     tmp_fd1 = mkstemp(fname1);",
          "430:     if (tmp_fd1 == -1) {",
          "431:         fprintf(stderr, \"**Error: could not create a working file.\\n\");",
          "432:         return -1;",
          "433:     }",
          "436:     ret_val = src_parser_tstage_1(tmp_fd1, src_fd, cfg->exp_trigraphs);",
          "437:     if (ret_val < 0)",
          "438:         return ret_val;",
          "444:     strncpy(fname2, TMP_FILE_NAME, TMP_FILE_NAME_SIZE);",
          "445:     tmp_fd2 = mkstemp(fname2);",
          "446:     if (tmp_fd2 == -1) {",
          "447:         fprintf(stderr, \"**Error: could not create a working file.\\n\");",
          "448:         return -1;",
          "449:     }",
          "452:     if (lseek(tmp_fd1, 0, SEEK_SET)) {",
          "453:         fprintf(stderr, \"**Error: Could not set offset.\\n\");",
          "454:         return -1;",
          "455:     }",
          "458:     ret_val = src_parser_tstage_2(tmp_fd2, tmp_fd1);",
          "459:     if (ret_val < 0)",
          "460:         return ret_val;",
          "463:     unlink(fname1);",
          "466:     strncpy(fname3, TMP_FILE_NAME, TMP_FILE_NAME_SIZE);",
          "467:     tmp_fd3 = mkstemp(fname3);",
          "468:     if (tmp_fd2 == -1) {",
          "474:     if (lseek(tmp_fd2, 0, SEEK_SET)) {",
          "475:         fprintf(stderr, \"**Error: Could not set offset.\\n\");",
          "476:         return -1;",
          "477:     }",
          "480:     ret_val = src_parser_tstage_3(tmp_fd3, tmp_fd2, cfg->exp_cpp_cmnts);",
          "485:     unlink(fname2);",
          "486:     printf(\"Stage 3 output:\\n\");",
          "487:     print_file_full(tmp_fd3);",
          "490:     unlink(fname3);",
          "",
          "---------------"
        ],
        "src/std_comp.h||src/std_comp.h": [
          "File: src/std_comp.h -> src/std_comp.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "113:     bool exp_trigraphs;",
          "114: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "114:     bool exp_cpp_cmnts;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
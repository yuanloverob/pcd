{
  "cve_id": "CVE-2018-11376",
  "cve_desc": "The r_read_le32() function in radare2 2.5.0 allows remote attackers to cause a denial of service (heap-based out-of-bounds read and application crash) via a crafted ELF file.",
  "repo": "radare/radare2",
  "patch_hash": "1f37c04f2a762500222dda2459e6a04646feeedf",
  "patch_info": {
    "commit_hash": "1f37c04f2a762500222dda2459e6a04646feeedf",
    "repo": "radare/radare2",
    "commit_url": "https://github.com/radare/radare2/commit/1f37c04f2a762500222dda2459e6a04646feeedf",
    "files": [
      "libr/bin/p/bin_elf.c",
      "libr/core/cbin.c"
    ],
    "message": "Fix #9904 - crash in r2_hoobr_r_read_le32 (over 9000 entrypoints) and read_le oobread (#9923)",
    "before_after_code_files": [
      "libr/bin/p/bin_elf.c||libr/bin/p/bin_elf.c",
      "libr/core/cbin.c||libr/core/cbin.c"
    ]
  },
  "patch_diff": {
    "libr/bin/p/bin_elf.c||libr/bin/p/bin_elf.c": [
      "File: libr/bin/p/bin_elf.c -> libr/bin/p/bin_elf.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "348:    }",
      "349:    (void)r_buf_read_at (bf->buf, sec->paddr, buf, sec->size);",
      "350:    if (bits == 32) {",
      "352:      ut32 addr32 = r_read_le32 (buf + i);",
      "353:      if (addr32) {",
      "354:       RBinAddr *ba = newEntry (sec->paddr + i, (ut64)addr32, type, bits);",
      "",
      "[Removed Lines]",
      "351:     for (i = 0; i < sec->size; i += 4) {",
      "",
      "[Added Lines]",
      "351:     for (i = 0; (i + 3) < sec->size; i += 4) {",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "356:      }",
      "357:     }",
      "358:    } else {",
      "360:      ut64 addr64 = r_read_le64 (buf + i);",
      "361:      if (addr64) {",
      "362:       RBinAddr *ba = newEntry (sec->paddr + i, addr64, type, bits);",
      "",
      "[Removed Lines]",
      "359:     for (i = 0; i < sec->size; i += 8) {",
      "",
      "[Added Lines]",
      "359:     for (i = 0; (i + 7) < sec->size; i += 8) {",
      "",
      "---------------"
    ],
    "libr/core/cbin.c||libr/core/cbin.c": [
      "File: libr/core/cbin.c -> libr/core/cbin.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1044:    r_cons_printf (\"[Entrypoints]\\n\");",
      "1045:   }",
      "1046:  }",
      "1048:  r_list_foreach (entries, iter, entry) {",
      "1049:   ut64 paddr = entry->paddr;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1047:  if (r_list_length (entries) > 1024) {",
      "1048:   eprintf (\"Too many entrypoints (%d)\\n\", r_list_length (entries));",
      "1049:   return false;",
      "1050:  }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "7eca86f5789f752eb7bc8dee9ca9c7ade123ba66",
      "candidate_info": {
        "commit_hash": "7eca86f5789f752eb7bc8dee9ca9c7ade123ba66",
        "repo": "radare/radare2",
        "commit_url": "https://github.com/radare/radare2/commit/7eca86f5789f752eb7bc8dee9ca9c7ade123ba66",
        "files": [
          "libr/bin/p/bin_elf.c"
        ],
        "message": "Implement ELF constructors/destructors parsing",
        "before_after_code_files": [
          "libr/bin/p/bin_elf.c||libr/bin/p/bin_elf.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libr/bin/p/bin_elf.c||libr/bin/p/bin_elf.c"
          ],
          "candidate": [
            "libr/bin/p/bin_elf.c||libr/bin/p/bin_elf.c"
          ]
        }
      },
      "candidate_diff": {
        "libr/bin/p/bin_elf.c||libr/bin/p/bin_elf.c": [
          "File: libr/bin/p/bin_elf.c -> libr/bin/p/bin_elf.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "9: #include <r_cons.h>",
          "10: #include \"elf/elf.h\"",
          "15: static void setsymord(ELFOBJ* eobj, ut32 ord, RBinSymbol *ptr) {",
          "",
          "[Removed Lines]",
          "12: static RBinInfo* info(RBinFile *arch);",
          "",
          "[Added Lines]",
          "12: static RBinInfo* info(RBinFile *bf);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "42:  return NULL;",
          "43: }",
          "46:  struct Elf_(r_bin_elf_obj_t) *res;",
          "47:  char *elf_type;",
          "48:  RBuffer *tbuf;",
          "",
          "[Removed Lines]",
          "45: static void * load_bytes(RBinFile *arch, const ut8 *buf, ut64 sz, ut64 loadaddr, Sdb *sdb) {",
          "",
          "[Added Lines]",
          "45: static void * load_bytes(RBinFile *bf, const ut8 *buf, ut64 sz, ut64 loadaddr, Sdb *sdb) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "52:  }",
          "53:  tbuf = r_buf_new ();",
          "54:  r_buf_set_bytes (tbuf, buf, sz);",
          "56:  if (res) {",
          "57:   sdb_ns_set (sdb, \"info\", res->kv);",
          "58:  }",
          "",
          "[Removed Lines]",
          "55:  res = Elf_(r_bin_elf_new_buf) (tbuf, arch->rbin->verbose);",
          "",
          "[Added Lines]",
          "55:  res = Elf_(r_bin_elf_new_buf) (tbuf, bf->rbin->verbose);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "73:  return res;",
          "74: }",
          "80:   return false;",
          "81:  }",
          "84: }",
          "87:  int i;",
          "89:  if (eobj && eobj->imports_by_ord) {",
          "90:   for (i = 0; i < eobj->imports_by_ord_size; i++) {",
          "91:    RBinImport *imp = eobj->imports_by_ord[i];",
          "",
          "[Removed Lines]",
          "76: static bool load(RBinFile *arch) {",
          "77:  const ut8 *bytes = arch ? r_buf_buffer (arch->buf) : NULL;",
          "78:  ut64 sz = arch ? r_buf_size (arch->buf): 0;",
          "79:  if (!arch || !arch->o) {",
          "82:  arch->o->bin_obj = load_bytes (arch, bytes, sz, arch->o->loadaddr, arch->sdb);",
          "83:  return arch->o->bin_obj != NULL;",
          "86: static int destroy(RBinFile *arch) {",
          "88:  ELFOBJ* eobj = arch->o->bin_obj;",
          "",
          "[Added Lines]",
          "76: static bool load(RBinFile *bf) {",
          "77:  const ut8 *bytes = bf ? r_buf_buffer (bf->buf) : NULL;",
          "78:  ut64 sz = bf ? r_buf_size (bf->buf): 0;",
          "79:  if (!bf || !bf->o) {",
          "82:  bf->o->bin_obj = load_bytes (bf, bytes, sz, bf->o->loadaddr, bf->sdb);",
          "83:  return bf->o->bin_obj != NULL;",
          "86: static int destroy(RBinFile *bf) {",
          "88:  ELFOBJ* eobj = bf->o->bin_obj;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "97:   }",
          "98:   R_FREE (eobj->imports_by_ord);",
          "99:  }",
          "102:  return true;",
          "103: }",
          "107: }",
          "111: }",
          "115:  RBinAddr *ret = NULL;",
          "116:  ut64 addr = 0LL;",
          "118:  switch (sym) {",
          "119:  case R_BIN_SYM_ENTRY:",
          "121:   break;",
          "122:  case R_BIN_SYM_MAIN:",
          "124:   break;",
          "125:  case R_BIN_SYM_INIT:",
          "127:   break;",
          "128:  case R_BIN_SYM_FINI:",
          "130:   break;",
          "131:  }",
          "132:  if (addr && addr != UT64_MAX && (ret = R_NEW0 (RBinAddr))) {",
          "134:   bool is_arm = bin->ehdr.e_machine == EM_ARM;",
          "135:   ret->paddr = addr;",
          "136:   ret->vaddr = Elf_(r_bin_elf_p2v) (obj, addr);",
          "",
          "[Removed Lines]",
          "101:  Elf_(r_bin_elf_free) ((struct Elf_(r_bin_elf_obj_t)*)arch->o->bin_obj);",
          "105: static ut64 baddr(RBinFile *arch) {",
          "106:  return Elf_(r_bin_elf_get_baddr) (arch->o->bin_obj);",
          "109: static ut64 boffset(RBinFile *arch) {",
          "110:  return Elf_(r_bin_elf_get_boffset) (arch->o->bin_obj);",
          "113: static RBinAddr* binsym(RBinFile *arch, int sym) {",
          "114:  struct Elf_(r_bin_elf_obj_t)* obj = arch->o->bin_obj;",
          "120:   addr = Elf_(r_bin_elf_get_entry_offset) (arch->o->bin_obj);",
          "123:   addr = Elf_(r_bin_elf_get_main_offset) (arch->o->bin_obj);",
          "126:   addr = Elf_(r_bin_elf_get_init_offset) (arch->o->bin_obj);",
          "129:   addr = Elf_(r_bin_elf_get_fini_offset) (arch->o->bin_obj);",
          "133:   struct Elf_(r_bin_elf_obj_t) *bin = arch->o->bin_obj;",
          "",
          "[Added Lines]",
          "100:  Elf_(r_bin_elf_free) ((struct Elf_(r_bin_elf_obj_t)*)bf->o->bin_obj);",
          "104: static ut64 baddr(RBinFile *bf) {",
          "105:  return Elf_(r_bin_elf_get_baddr) (bf->o->bin_obj);",
          "108: static ut64 boffset(RBinFile *bf) {",
          "109:  return Elf_(r_bin_elf_get_boffset) (bf->o->bin_obj);",
          "112: static RBinAddr* binsym(RBinFile *bf, int sym) {",
          "113:  struct Elf_(r_bin_elf_obj_t)* obj = bf->o->bin_obj;",
          "119:   addr = Elf_(r_bin_elf_get_entry_offset) (bf->o->bin_obj);",
          "122:   addr = Elf_(r_bin_elf_get_main_offset) (bf->o->bin_obj);",
          "125:   addr = Elf_(r_bin_elf_get_init_offset) (bf->o->bin_obj);",
          "128:   addr = Elf_(r_bin_elf_get_fini_offset) (bf->o->bin_obj);",
          "132:   struct Elf_(r_bin_elf_obj_t) *bin = bf->o->bin_obj;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "143:  return ret;",
          "144: }",
          "208:  struct r_bin_elf_section_t *section = NULL;",
          "209:  int i, num, found_load = 0;",
          "210:  Elf_(Phdr)* phdr = NULL;",
          "",
          "[Removed Lines]",
          "146: static RList* entries(RBinFile *arch) {",
          "147:  struct Elf_(r_bin_elf_obj_t)* obj;",
          "148:  RBinAddr *ptr = NULL;",
          "149:  struct r_bin_elf_symbol_t *symbol;",
          "150:  RList *ret;",
          "151:  int i;",
          "153:  if (!arch || !arch->o || !arch->o->bin_obj) {",
          "154:   return NULL;",
          "155:  }",
          "156:  obj = arch->o->bin_obj;",
          "157:  if (!(ret = r_list_newf ((RListFree)free))) {",
          "158:   return NULL;",
          "159:  }",
          "160:  if (!(ptr = R_NEW0 (RBinAddr))) {",
          "161:   return ret;",
          "162:  }",
          "163:  ptr->paddr = Elf_(r_bin_elf_get_entry_offset) (obj);",
          "164:  ptr->vaddr = Elf_(r_bin_elf_p2v) (obj, ptr->paddr);",
          "165:  ptr->haddr = 0x18;",
          "167:  if (obj->ehdr.e_machine == EM_ARM) {",
          "168:   int bin_bits = Elf_(r_bin_elf_get_bits) (obj);",
          "169:   if (bin_bits != 64) {",
          "170:    ptr->bits = 32;",
          "171:    if (ptr->vaddr & 1) {",
          "172:     ptr->vaddr--;",
          "173:     ptr->bits = 16;",
          "174:    }",
          "175:    if (ptr->paddr & 1) {",
          "176:     ptr->paddr--;",
          "177:     ptr->bits = 16;",
          "178:    }",
          "179:   }",
          "180:  }",
          "181:  r_list_append (ret, ptr);",
          "185:  if (!(symbol = Elf_(r_bin_elf_get_symbols) (obj))) {",
          "186:   return ret;",
          "187:  }",
          "188:  for (i = 0; !symbol[i].last; i++) {",
          "189:   if (!strncmp (symbol[i].name, \"Java\", 4)) {",
          "190:    if (r_str_endswith (symbol[i].name, \"_init\")) {",
          "191:     if (!(ptr = R_NEW0 (RBinAddr))) {",
          "192:      return ret;",
          "193:     }",
          "194:     ptr->paddr = symbol[i].offset;",
          "195:     ptr->vaddr = Elf_(r_bin_elf_p2v) (obj, ptr->paddr);",
          "196:     ptr->haddr = UT64_MAX;",
          "197:     ptr->type = R_BIN_ENTRY_TYPE_INIT;",
          "198:     r_list_append (ret, ptr);",
          "199:     break;",
          "200:    }",
          "201:   }",
          "202:  }",
          "203:  return ret;",
          "204: }",
          "206: static RList* sections(RBinFile *arch) {",
          "207:  struct Elf_(r_bin_elf_obj_t)* obj = arch && arch->o ? arch->o->bin_obj : NULL;",
          "",
          "[Added Lines]",
          "145: static RList* sections(RBinFile *bf) {",
          "146:  struct Elf_(r_bin_elf_obj_t)* obj = (bf && bf->o)? bf->o->bin_obj : NULL;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "302:  }",
          "304:  if (r_list_empty (ret)) {",
          "308:   }",
          "309:   if (found_load == 0) {",
          "310:    if (!(ptr = R_NEW0 (RBinSection))) {",
          "311:     return ret;",
          "312:    }",
          "313:    sprintf (ptr->name, \"uphdr\");",
          "316:    ptr->paddr = 0;",
          "317:    ptr->vaddr = 0x10000;",
          "318:    ptr->add = true;",
          "",
          "[Removed Lines]",
          "305:   if (!arch->size) {",
          "306:    struct Elf_(r_bin_elf_obj_t) *bin = arch->o->bin_obj;",
          "307:    arch->size = bin? bin->size: 0x9999;",
          "314:    ptr->size = arch->size;",
          "315:    ptr->vsize = arch->size;",
          "",
          "[Added Lines]",
          "244:   if (!bf->size) {",
          "245:    struct Elf_(r_bin_elf_obj_t) *bin = bf->o->bin_obj;",
          "246:    bf->size = bin? bin->size: 0x9999;",
          "253:    ptr->size = bf->size;",
          "254:    ptr->vsize = bf->size;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "325:  ptr = R_NEW0 (RBinSection);",
          "326:  if (ptr) {",
          "327:   ut64 ehdr_size = sizeof (obj->ehdr);",
          "330:   }",
          "331:   sprintf (ptr->name, \"ehdr\");",
          "332:   ptr->paddr = 0;",
          "",
          "[Removed Lines]",
          "328:   if (arch->size < ehdr_size) {",
          "329:    ehdr_size = arch->size;",
          "",
          "[Added Lines]",
          "267:   if (bf->size < ehdr_size) {",
          "268:    ehdr_size = bf->size;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "343:  return ret;",
          "344: }",
          "347: static void _set_arm_thumb_bits(struct Elf_(r_bin_elf_obj_t) *bin, RBinSymbol **sym) {",
          "348:  int bin_bits = Elf_(r_bin_elf_get_bits) (bin);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "285: static RBinAddr* newEntry(ut64 haddr, ut64 paddr, int type, int bits) {",
          "286:  RBinAddr *ptr = R_NEW0 (RBinAddr);",
          "287:  if (ptr) {",
          "288:   ptr->paddr = paddr;",
          "289:   ptr->vaddr = paddr;",
          "290:   ptr->haddr = haddr;",
          "291:   ptr->bits = bits;",
          "292:   ptr->type = type;",
          "294:   if (bits == 16 && ptr->vaddr & 1) {",
          "295:    ptr->paddr--;",
          "296:    ptr->vaddr--;",
          "297:   }",
          "298:  }",
          "299:  return ptr;",
          "300: }",
          "302: static void process_constructors (RBinFile *bf, RList *ret, int bits) {",
          "303:  RList *secs = sections (bf);",
          "304:  RListIter *iter;",
          "305:  RBinSection *sec;",
          "306:  int i, type;",
          "307:  r_list_foreach (secs, iter, sec) {",
          "308:   type = -1;",
          "309:   if (!strcmp (sec->name, \".fini_array\")) {",
          "310:    type  = R_BIN_ENTRY_TYPE_FINI;",
          "311:   } else if (!strcmp (sec->name, \".init_array\")) {",
          "312:    type  = R_BIN_ENTRY_TYPE_INIT;",
          "313:   }",
          "314:   if (type != -1) {",
          "315:    ut8 *buf = calloc (sec->size, 1);",
          "316:    if (!buf) {",
          "317:     continue;",
          "318:    }",
          "319:    (void)r_buf_read_at (bf->buf, sec->paddr, buf, sec->size);",
          "320:    if (bits == 32) {",
          "321:     for (i = 0; i < sec->size; i += 4) {",
          "322:      ut32 addr32 = r_read_le32 (buf + i);",
          "323:      if (addr32) {",
          "324:       RBinAddr *ba = newEntry (sec->paddr + i, (ut64)addr32, type, bits);",
          "325:       r_list_append (ret, ba);",
          "326:      }",
          "327:     }",
          "328:    } else {",
          "329:     for (i = 0; i < sec->size; i += 8) {",
          "330:      ut64 addr64 = r_read_le64 (buf + i);",
          "331:      if (addr64) {",
          "332:       RBinAddr *ba = newEntry (sec->paddr + i, addr64, type, bits);",
          "333:       r_list_append (ret, ba);",
          "334:      }",
          "335:     }",
          "336:    }",
          "337:   }",
          "338:  }",
          "339: }",
          "341: static RList* entries(RBinFile *bf) {",
          "342:  struct Elf_(r_bin_elf_obj_t)* obj;",
          "343:  RBinAddr *ptr = NULL;",
          "344:  struct r_bin_elf_symbol_t *symbol;",
          "345:  RList *ret;",
          "346:  int i;",
          "348:  if (!bf || !bf->o || !bf->o->bin_obj) {",
          "349:   return NULL;",
          "350:  }",
          "351:  obj = bf->o->bin_obj;",
          "352:  if (!(ret = r_list_newf ((RListFree)free))) {",
          "353:   return NULL;",
          "354:  }",
          "355:  if (!(ptr = R_NEW0 (RBinAddr))) {",
          "356:   return ret;",
          "357:  }",
          "358:  ptr->paddr = Elf_(r_bin_elf_get_entry_offset) (obj);",
          "359:  ptr->vaddr = Elf_(r_bin_elf_p2v) (obj, ptr->paddr);",
          "360:  ptr->haddr = 0x18;",
          "362:  if (obj->ehdr.e_machine == EM_ARM) {",
          "363:   int bin_bits = Elf_(r_bin_elf_get_bits) (obj);",
          "364:   if (bin_bits != 64) {",
          "365:    ptr->bits = 32;",
          "366:    if (ptr->vaddr & 1) {",
          "367:     ptr->vaddr--;",
          "368:     ptr->bits = 16;",
          "369:    }",
          "370:    if (ptr->paddr & 1) {",
          "371:     ptr->paddr--;",
          "372:     ptr->bits = 16;",
          "373:    }",
          "374:   }",
          "375:  }",
          "376:  r_list_append (ret, ptr);",
          "380:  if (!(symbol = Elf_(r_bin_elf_get_symbols) (obj))) {",
          "381:   return ret;",
          "382:  }",
          "383:  for (i = 0; !symbol[i].last; i++) {",
          "384:   if (!strncmp (symbol[i].name, \"Java\", 4)) {",
          "385:    if (r_str_endswith (symbol[i].name, \"_init\")) {",
          "386:     if (!(ptr = R_NEW0 (RBinAddr))) {",
          "387:      return ret;",
          "388:     }",
          "389:     ptr->paddr = symbol[i].offset;",
          "390:     ptr->vaddr = Elf_(r_bin_elf_p2v) (obj, ptr->paddr);",
          "391:     ptr->haddr = UT64_MAX;",
          "392:     ptr->type = R_BIN_ENTRY_TYPE_INIT;",
          "393:     r_list_append (ret, ptr);",
          "394:     break;",
          "395:    }",
          "396:   }",
          "397:  }",
          "398:  int bin_bits = Elf_(r_bin_elf_get_bits) (bf->o->bin_obj);",
          "399:  process_constructors (bf, ret, bin_bits);",
          "400:  return ret;",
          "401: }",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "384:  }",
          "385: }",
          "388:  struct Elf_(r_bin_elf_obj_t) *bin;",
          "389:  struct r_bin_elf_symbol_t *symbol = NULL;",
          "390:  RBinSymbol *ptr = NULL;",
          "391:  RList *ret = NULL;",
          "392:  int i;",
          "395:   return NULL;",
          "396:  }",
          "399:  ret = r_list_newf (free);",
          "400:  if (!ret) {",
          "401:   return NULL;",
          "",
          "[Removed Lines]",
          "387: static RList* symbols(RBinFile *arch) {",
          "394:  if (!arch || !arch->o || !arch->o->bin_obj) {",
          "398:  bin = arch->o->bin_obj;",
          "",
          "[Added Lines]",
          "443: static RList* symbols(RBinFile *bf) {",
          "450:  if (!bf|| !bf->o || !bf->o->bin_obj) {",
          "454:  bin = bf->o->bin_obj;",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "461:  return ret;",
          "462: }",
          "465:  struct Elf_(r_bin_elf_obj_t) *bin = NULL;",
          "466:  RBinElfSymbol *import = NULL;",
          "467:  RBinImport *ptr = NULL;",
          "468:  RList *ret = NULL;",
          "469:  int i;",
          "472:   return NULL;",
          "473:  }",
          "475:  if (!(ret = r_list_newf (r_bin_import_free))) {",
          "476:   return NULL;",
          "477:  }",
          "",
          "[Removed Lines]",
          "464: static RList* imports(RBinFile *arch) {",
          "471:  if (!arch || !arch->o || !arch->o->bin_obj) {",
          "474:  bin = arch->o->bin_obj;",
          "",
          "[Added Lines]",
          "520: static RList* imports(RBinFile *bf) {",
          "527:  if (!bf || !bf->o || !bf->o->bin_obj) {",
          "530:  bin = bf->o->bin_obj;",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "493:  return ret;",
          "494: }",
          "497:  struct r_bin_elf_lib_t *libs = NULL;",
          "498:  RList *ret = NULL;",
          "499:  char *ptr = NULL;",
          "500:  int i;",
          "503:   return NULL;",
          "505:   return NULL;",
          "507:   return ret;",
          "508:  for (i = 0; !libs[i].last; i++) {",
          "509:   ptr = strdup (libs[i].name);",
          "510:   r_list_append (ret, ptr);",
          "",
          "[Removed Lines]",
          "496: static RList* libs(RBinFile *arch) {",
          "502:  if (!arch || !arch->o || !arch->o->bin_obj)",
          "504:  if (!(ret = r_list_newf (free)))",
          "506:  if (!(libs = Elf_(r_bin_elf_get_libs) (arch->o->bin_obj)))",
          "",
          "[Added Lines]",
          "552: static RList* libs(RBinFile *bf) {",
          "558:  if (!bf || !bf->o || !bf->o->bin_obj) {",
          "560:  }",
          "561:  if (!(ret = r_list_newf (free))) {",
          "563:  }",
          "564:  if (!(libs = Elf_(r_bin_elf_get_libs) (bf->o->bin_obj))) {",
          "566:  }",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "607:  return 0;",
          "608: }",
          "611:  RList *ret = NULL;",
          "612:  RBinReloc *ptr = NULL;",
          "613:  RBinElfReloc *relocs = NULL;",
          "614:  struct Elf_(r_bin_elf_obj_t) *bin = NULL;",
          "615:  ut64 got_addr;",
          "616:  int i;",
          "618:   return NULL;",
          "619:  }",
          "621:  if (!(ret = r_list_newf (free))) {",
          "622:   return NULL;",
          "623:  }",
          "627:  if ((got_addr = Elf_(r_bin_elf_get_section_addr) (bin, \".got\")) == -1) {",
          "628:   got_addr = Elf_(r_bin_elf_get_section_addr) (bin, \".got.plt\");",
          "629:   if (got_addr == -1) {",
          "",
          "[Removed Lines]",
          "610: static RList* relocs(RBinFile *arch) {",
          "617:  if (!arch || !arch->o || !arch->o->bin_obj) {",
          "620:  bin = arch->o->bin_obj;",
          "626:  r_list_free (imports (arch));",
          "",
          "[Added Lines]",
          "669: static RList* relocs(RBinFile *bf) {",
          "676:  if (!bf || !bf->o || !bf->o->bin_obj) {",
          "679:  bin = bf->o->bin_obj;",
          "685:  r_list_free (imports (bf));",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "636:    got_addr = 0;",
          "637:   }",
          "638:  }",
          "640:   if (!(relocs = Elf_(r_bin_elf_get_relocs) (bin))) {",
          "641:    return ret;",
          "642:   }",
          "",
          "[Removed Lines]",
          "639:  if (arch->o) {",
          "",
          "[Added Lines]",
          "698:  if (bf->o) {",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "867:  return ret;",
          "868: }",
          "871:  bool ret = false;",
          "873:  RListIter *iter;",
          "874:  RBinImport *import;",
          "875:  if (imports_list) {",
          "",
          "[Removed Lines]",
          "870: static bool has_canary(RBinFile *arch) {",
          "872:  RList* imports_list = imports (arch);",
          "",
          "[Added Lines]",
          "929: static bool has_canary(RBinFile *bf) {",
          "931:  RList* imports_list = imports (bf);",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "885:  return ret;",
          "886: }",
          "889:  RBinInfo *ret = NULL;",
          "890:  char *str;",
          "",
          "[Removed Lines]",
          "888: static RBinInfo* info(RBinFile *arch) {",
          "",
          "[Added Lines]",
          "947: static RBinInfo* info(RBinFile *bf) {",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "893:   return NULL;",
          "894:  }",
          "895:  ret->lang = \"c\";",
          "898:   : NULL;",
          "900:   ret->rpath = strdup (str);",
          "901:   free (str);",
          "902:  } else {",
          "903:   ret->rpath = strdup (\"NONE\");",
          "904:  }",
          "906:   free (ret);",
          "907:   return NULL;",
          "908:  }",
          "909:  ret->type = str;",
          "910:  ret->has_pi = (strstr (str, \"DYN\"))? 1: 0;",
          "911:  ret->has_lit = true;",
          "914:   free (ret);",
          "915:   return NULL;",
          "916:  }",
          "917:  ret->bclass = str;",
          "919:   free (ret);",
          "920:   return NULL;",
          "921:  }",
          "922:  ret->os = str;",
          "924:   free (ret);",
          "925:   return NULL;",
          "926:  }",
          "927:  ret->subsystem = str;",
          "929:   free (ret);",
          "930:   return NULL;",
          "931:  }",
          "932:  ret->machine = str;",
          "934:   free (ret);",
          "935:   return NULL;",
          "936:  }",
          "937:  ret->arch = str;",
          "938:  ret->rclass = strdup (\"elf\");",
          "940:  if (!strcmp (ret->arch, \"avr\")) {",
          "941:   ret->bits = 16;",
          "942:  }",
          "947:  ret->dbg_info = 0;",
          "949:   ret->dbg_info |= R_BIN_DBG_LINENUMS | R_BIN_DBG_SYMS | R_BIN_DBG_RELOCS;",
          "950:  } else {",
          "951:   ret->dbg_info |= R_BIN_DBG_STRIPPED;",
          "952:  }",
          "954:   ret->dbg_info |= R_BIN_DBG_STATIC;",
          "955:  }",
          "956:  return ret;",
          "957: }",
          "960:  RList *ret = NULL;",
          "961:  RBinField *ptr = NULL;",
          "962:  struct r_bin_elf_field_t *field = NULL;",
          "",
          "[Removed Lines]",
          "896:  ret->file = arch->file",
          "897:   ? strdup (arch->file)",
          "899:  if ((str = Elf_(r_bin_elf_get_rpath)(arch->o->bin_obj))) {",
          "905:  if (!(str = Elf_(r_bin_elf_get_file_type) (arch->o->bin_obj))) {",
          "912:  ret->has_canary = has_canary (arch);",
          "913:  if (!(str = Elf_(r_bin_elf_get_elf_class) (arch->o->bin_obj))) {",
          "918:  if (!(str = Elf_(r_bin_elf_get_osabi_name) (arch->o->bin_obj))) {",
          "923:  if (!(str = Elf_(r_bin_elf_get_osabi_name) (arch->o->bin_obj))) {",
          "928:  if (!(str = Elf_(r_bin_elf_get_machine_name) (arch->o->bin_obj))) {",
          "933:  if (!(str = Elf_(r_bin_elf_get_arch) (arch->o->bin_obj))) {",
          "939:  ret->bits = Elf_(r_bin_elf_get_bits) (arch->o->bin_obj);",
          "943:  ret->big_endian = Elf_(r_bin_elf_is_big_endian) (arch->o->bin_obj);",
          "944:  ret->has_va = Elf_(r_bin_elf_has_va) (arch->o->bin_obj);",
          "945:  ret->has_nx = Elf_(r_bin_elf_has_nx) (arch->o->bin_obj);",
          "946:  ret->intrp = Elf_(r_bin_elf_intrp) (arch->o->bin_obj);",
          "948:  if (!Elf_(r_bin_elf_get_stripped) (arch->o->bin_obj)) {",
          "953:  if (Elf_(r_bin_elf_get_static) (arch->o->bin_obj)) {",
          "959: static RList* fields(RBinFile *arch) {",
          "",
          "[Added Lines]",
          "955:  ret->file = bf->file",
          "956:   ? strdup (bf->file)",
          "958:  if ((str = Elf_(r_bin_elf_get_rpath)(bf->o->bin_obj))) {",
          "964:  if (!(str = Elf_(r_bin_elf_get_file_type) (bf->o->bin_obj))) {",
          "971:  ret->has_canary = has_canary (bf);",
          "972:  if (!(str = Elf_(r_bin_elf_get_elf_class) (bf->o->bin_obj))) {",
          "977:  if (!(str = Elf_(r_bin_elf_get_osabi_name) (bf->o->bin_obj))) {",
          "982:  if (!(str = Elf_(r_bin_elf_get_osabi_name) (bf->o->bin_obj))) {",
          "987:  if (!(str = Elf_(r_bin_elf_get_machine_name) (bf->o->bin_obj))) {",
          "992:  if (!(str = Elf_(r_bin_elf_get_arch) (bf->o->bin_obj))) {",
          "998:  ret->bits = Elf_(r_bin_elf_get_bits) (bf->o->bin_obj);",
          "1002:  ret->big_endian = Elf_(r_bin_elf_is_big_endian) (bf->o->bin_obj);",
          "1003:  ret->has_va = Elf_(r_bin_elf_has_va) (bf->o->bin_obj);",
          "1004:  ret->has_nx = Elf_(r_bin_elf_has_nx) (bf->o->bin_obj);",
          "1005:  ret->intrp = Elf_(r_bin_elf_intrp) (bf->o->bin_obj);",
          "1007:  if (!Elf_(r_bin_elf_get_stripped) (bf->o->bin_obj)) {",
          "1012:  if (Elf_(r_bin_elf_get_static) (bf->o->bin_obj)) {",
          "1018: static RList* fields(RBinFile *bf) {",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "966:   return NULL;",
          "967:  }",
          "968:  ret->free = free;",
          "970:   return ret;",
          "971:  }",
          "972:  for (i = 0; !field[i].last; i++) {",
          "",
          "[Removed Lines]",
          "969:  if (!(field = Elf_(r_bin_elf_get_fields) (arch->o->bin_obj))) {",
          "",
          "[Added Lines]",
          "1028:  if (!(field = Elf_(r_bin_elf_get_fields) (bf->o->bin_obj))) {",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "983:  return ret;",
          "984: }",
          "987:  ut64 off = 0;",
          "988:  ut64 len = 0;",
          "990:   RListIter *iter;",
          "991:   RBinSection *section;",
          "994:    if (section->paddr > off) {",
          "995:     off = section->paddr;",
          "996:     len = section->size;",
          "997:    }",
          "998:   }",
          "999:  }",
          "1001: }",
          "1003: #if !R_BIN_ELF64 && !R_BIN_CGC",
          "1008:  p (\"0x00000000  ELF MAGIC   0x%08x\\n\", r_read_le32 (buf));",
          "1009:  p (\"0x00000004  Type        0x%04x\\n\", r_read_le16 (buf + 4));",
          "1010:  p (\"0x00000006  Machine     0x%04x\\n\", r_read_le16 (buf + 6));",
          "",
          "[Removed Lines]",
          "986: static ut64 size(RBinFile *arch) {",
          "989:  if (!arch->o->sections) {",
          "992:   arch->o->sections = sections (arch);",
          "993:   r_list_foreach (arch->o->sections, iter, section) {",
          "1000:  return off+len;",
          "1005: static void headers32(RBinFile *arch) {",
          "1006: #define p arch->rbin->cb_printf",
          "1007:  const ut8 *buf = r_buf_get_at (arch->buf, 0, NULL);",
          "",
          "[Added Lines]",
          "1045: static ut64 size(RBinFile *bf) {",
          "1048:  if (!bf->o->sections) {",
          "1051:   bf->o->sections = sections (bf);",
          "1052:   r_list_foreach (bf->o->sections, iter, section) {",
          "1059:  return off + len;",
          "1064: static void headers32(RBinFile *bf) {",
          "1065: #define p bf->rbin->cb_printf",
          "1066:  const ut8 *buf = r_buf_get_at (bf->buf, 0, NULL);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "2df06bd8704edaaba57c00781d99aa04e6e4e87d",
      "candidate_info": {
        "commit_hash": "2df06bd8704edaaba57c00781d99aa04e6e4e87d",
        "repo": "radare/radare2",
        "commit_url": "https://github.com/radare/radare2/commit/2df06bd8704edaaba57c00781d99aa04e6e4e87d",
        "files": [
          "libr/bin/bin.c",
          "libr/bin/format/elf/elf.c",
          "libr/bin/format/elf/elf.h",
          "libr/bin/format/mdmp/mdmp_pe.c",
          "libr/bin/format/nxo/nxo.c",
          "libr/bin/format/objc/mach0_classes.c",
          "libr/bin/p/bin_coff.c",
          "libr/bin/p/bin_dex.c",
          "libr/bin/p/bin_dyldcache.c",
          "libr/bin/p/bin_elf.c",
          "libr/bin/p/bin_mach0.c",
          "libr/bin/p/bin_pe.c",
          "libr/bin/p/bin_wasm.c",
          "libr/core/canal.c",
          "libr/core/cbin.c",
          "libr/core/cmd_debug.c",
          "libr/include/r_bin.h",
          "libr/include/r_util/r_str.h",
          "shlr/java/class.c"
        ],
        "message": "Fix ELF issue with null SHT entries (#10449)\n\n* format/elf: extract function to avoid duplicated code\n* format/elf: use ut64 to avoid errors in ELF32\n\nOtherwise, while analyzing ELF32, -1 will be interpreted as the unsigned\nvalue 0xffffffff, which is very different from -1 (0xffffffffffffffff).\n\n* format/elf: fix symbols with shndx == SHT_NULL\n\nSymbols with shndx == SHT_NULL should not be listed as symbols but they\nshould be available when other ELF structures (imports, relocs, etc.)\nreference them.\n\nThis patch adds those symbols in the symbols_by_ord table but not to the\nlist of available symbols. Imports/relocs/etc. work by indexing symbols\nby symbol index, so they are going to use the symbols_by_ord table and\nmake everything work.\n\nMoreover, it refactors a bit the relocs function to avoid duplicated\ncode.\n\n* bin: setimportd/setsymbold should clone the import/symbol\n* bin/bin.c: free fields only when sym is not NULL\n* format/elf: do not filter out symbols with size == 0 and consider sht_null symbols in shdr too.\n* bin/bin.c: create R_STR_DUP macro and use it in _clone functions\n* format/elf: when parsing symbols from phdr, stop at first UNK type/bind\n* create some R_BIN defines to handle strings related to TYPE and BIND\n  in RBinSymbols\n* format/elf: add a doc",
        "before_after_code_files": [
          "libr/bin/bin.c||libr/bin/bin.c",
          "libr/bin/format/elf/elf.c||libr/bin/format/elf/elf.c",
          "libr/bin/format/elf/elf.h||libr/bin/format/elf/elf.h",
          "libr/bin/format/mdmp/mdmp_pe.c||libr/bin/format/mdmp/mdmp_pe.c",
          "libr/bin/format/nxo/nxo.c||libr/bin/format/nxo/nxo.c",
          "libr/bin/format/objc/mach0_classes.c||libr/bin/format/objc/mach0_classes.c",
          "libr/bin/p/bin_coff.c||libr/bin/p/bin_coff.c",
          "libr/bin/p/bin_dex.c||libr/bin/p/bin_dex.c",
          "libr/bin/p/bin_dyldcache.c||libr/bin/p/bin_dyldcache.c",
          "libr/bin/p/bin_elf.c||libr/bin/p/bin_elf.c",
          "libr/bin/p/bin_mach0.c||libr/bin/p/bin_mach0.c",
          "libr/bin/p/bin_pe.c||libr/bin/p/bin_pe.c",
          "libr/bin/p/bin_wasm.c||libr/bin/p/bin_wasm.c",
          "libr/core/canal.c||libr/core/canal.c",
          "libr/core/cbin.c||libr/core/cbin.c",
          "libr/core/cmd_debug.c||libr/core/cmd_debug.c",
          "libr/include/r_bin.h||libr/include/r_bin.h",
          "libr/include/r_util/r_str.h||libr/include/r_util/r_str.h",
          "shlr/javclass.c||shlr/java/class.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libr/bin/p/bin_elf.c||libr/bin/p/bin_elf.c",
            "libr/core/cbin.c||libr/core/cbin.c"
          ],
          "candidate": [
            "libr/bin/p/bin_elf.c||libr/bin/p/bin_elf.c",
            "libr/core/cbin.c||libr/core/cbin.c"
          ]
        }
      },
      "candidate_diff": {
        "libr/bin/bin.c||libr/bin/bin.c": [
          "File: libr/bin/bin.c -> libr/bin/bin.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "168:  free (rb);",
          "169: }",
          "171: R_API void r_bin_import_free(void *_imp) {",
          "172:  RBinImport *imp = (RBinImport *)_imp;",
          "173:  if (imp) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "171: R_API RBinImport *r_bin_import_clone(RBinImport *o) {",
          "172:  RBinImport *res = r_mem_dup (o, sizeof (*o));",
          "173:  if (!res) {",
          "174:   return NULL;",
          "175:  }",
          "176:  res->name = R_STR_DUP (o->name);",
          "177:  res->classname = R_STR_DUP (o->classname);",
          "178:  res->descriptor = R_STR_DUP (o->descriptor);",
          "179:  return res;",
          "180: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "178:  }",
          "179: }",
          "181: R_API void r_bin_symbol_free(void *_sym) {",
          "182:  RBinSymbol *sym = (RBinSymbol *)_sym;",
          "186: }",
          "188: R_API void r_bin_string_free(void *_str) {",
          "",
          "[Removed Lines]",
          "183:  free (sym->name);",
          "184:  free (sym->classname);",
          "185:  free (sym);",
          "",
          "[Added Lines]",
          "192: R_API RBinSymbol *r_bin_symbol_clone(RBinSymbol *o) {",
          "193:  RBinSymbol *res = r_mem_dup (o, sizeof (*o));",
          "194:  if (!res) {",
          "195:   return NULL;",
          "196:  }",
          "197:  res->name = R_STR_DUP (o->name);",
          "198:  res->dname = R_STR_DUP (o->dname);",
          "199:  res->classname = R_STR_DUP (o->classname);",
          "200:  return res;",
          "201: }",
          "205:  if (sym) {",
          "206:   free (sym->name);",
          "207:   free (sym->classname);",
          "208:   free (sym);",
          "209:  }",
          "",
          "---------------"
        ],
        "libr/bin/format/elf/elf.c||libr/bin/format/elf/elf.c": [
          "File: libr/bin/format/elf/elf.c -> libr/bin/format/elf/elf.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1208:  ut8 rl[sizeof (Elf_(Rel))] = {0};",
          "1209:  ut8 rla[sizeof (Elf_(Rela))] = {0};",
          "1210:  RBinElfSection *rel_sec = NULL;",
          "1212:  ut64 got_addr, got_offset;",
          "1213:  ut64 plt_addr;",
          "1214:  int j, k, tsize, len, nrel;",
          "",
          "[Removed Lines]",
          "1211:  Elf_(Addr) plt_sym_addr = -1;",
          "",
          "[Added Lines]",
          "1211:  ut64 plt_sym_addr = -1;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2404:  if (!ret) {",
          "2405:   return NULL;",
          "2406:  }",
          "2413:  for (i = 0, rel = 0; !bin->g_sections[i].last && rel < reloc_num ; i++) {",
          "2414:   bool is_rela = 0 == strncmp (bin->g_sections[i].name, \".rela.\", strlen (\".rela.\"));",
          "2415:   bool is_rel  = 0 == strncmp (bin->g_sections[i].name, \".rel.\",  strlen (\".rel.\"));",
          "",
          "[Removed Lines]",
          "2407: #if DEAD_CODE",
          "2408:  ut64 section_text_offset = Elf_(r_bin_elf_get_section_offset) (bin, \".text\");",
          "2409:  if (section_text_offset == -1) {",
          "2410:   section_text_offset = 0;",
          "2411:  }",
          "2412: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2502:  int i, num_sections = 0;",
          "2503:  ut64 reldyn = 0, relava = 0, pltgotva = 0, relva = 0;",
          "2504:  ut64 reldynsz = 0, relasz = 0, pltgotsz = 0;",
          "2506:   return NULL;",
          "2508:  for (i = 0; i < bin->dyn_entries; i++) {",
          "2509:   switch (bin->dyn_buf[i].d_tag) {",
          "",
          "[Removed Lines]",
          "2505:  if (!bin || !bin->phdr || !bin->ehdr.e_phnum)",
          "",
          "[Added Lines]",
          "2499:  if (!bin || !bin->phdr || !bin->ehdr.e_phnum) {",
          "2501:  }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2636:  return ret;",
          "2637: }",
          "2642:  switch (ELF_ST_BIND(sym->st_info)) {",
          "2652:  }",
          "2653:  switch (ELF_ST_TYPE (sym->st_info)) {",
          "2667:  }",
          "2668: }",
          "2670: static RBinElfSymbol* get_symbols_from_phdr(ELFOBJ *bin, int type) {",
          "2671:  Elf_(Sym) *sym = NULL;",
          "2672:  Elf_(Addr) addr_sym_table = 0;",
          "",
          "[Removed Lines]",
          "2639: static void fill_symbol_bind_and_type (struct r_bin_elf_symbol_t *ret, Elf_(Sym) *sym) {",
          "2640:  #define s_bind(x) ret->bind = x",
          "2641:  #define s_type(x) ret->type = x",
          "2643:  case STB_LOCAL:  s_bind (\"LOCAL\"); break;",
          "2644:  case STB_GLOBAL: s_bind (\"GLOBAL\"); break;",
          "2645:  case STB_WEAK:   s_bind (\"WEAK\"); break;",
          "2646:  case STB_NUM:    s_bind (\"NUM\"); break;",
          "2647:  case STB_LOOS:   s_bind (\"LOOS\"); break;",
          "2648:  case STB_HIOS:   s_bind (\"HIOS\"); break;",
          "2649:  case STB_LOPROC: s_bind (\"LOPROC\"); break;",
          "2650:  case STB_HIPROC: s_bind (\"HIPROC\"); break;",
          "2651:  default:         s_bind (\"UNKNOWN\");",
          "2654:  case STT_NOTYPE:  s_type (\"NOTYPE\"); break;",
          "2655:  case STT_OBJECT:  s_type (\"OBJ\"); break;",
          "2656:  case STT_FUNC:    s_type (\"FUNC\"); break;",
          "2657:  case STT_SECTION: s_type (\"SECT\"); break;",
          "2658:  case STT_FILE:    s_type (\"FILE\"); break;",
          "2659:  case STT_COMMON:  s_type (\"COMMON\"); break;",
          "2660:  case STT_TLS:     s_type (\"TLS\"); break;",
          "2661:  case STT_NUM:     s_type (\"NUM\"); break;",
          "2662:  case STT_LOOS:    s_type (\"LOOS\"); break;",
          "2663:  case STT_HIOS:    s_type (\"HIOS\"); break;",
          "2664:  case STT_LOPROC:  s_type (\"LOPROC\"); break;",
          "2665:  case STT_HIPROC:  s_type (\"HIPROC\"); break;",
          "2666:  default:          s_type (\"UNK\");",
          "",
          "[Added Lines]",
          "2634: static const char *bind2str(Elf_(Sym) *sym) {",
          "2636:  case STB_LOCAL:  return R_BIN_BIND_LOCAL_STR;",
          "2637:  case STB_GLOBAL: return R_BIN_BIND_GLOBAL_STR;",
          "2638:  case STB_WEAK:   return R_BIN_BIND_WEAK_STR;",
          "2639:  case STB_NUM:    return R_BIN_BIND_NUM_STR;",
          "2640:  case STB_LOOS:   return R_BIN_BIND_LOOS_STR;",
          "2641:  case STB_HIOS:   return R_BIN_BIND_HIOS_STR;",
          "2642:  case STB_LOPROC: return R_BIN_BIND_LOPROC_STR;",
          "2643:  case STB_HIPROC: return R_BIN_BIND_HIPROC_STR;",
          "2644:  default:         return R_BIN_BIND_UNKNOWN_STR;",
          "2646: }",
          "2648: static const char *type2str(Elf_(Sym) *sym) {",
          "2650:  case STT_NOTYPE:  return R_BIN_TYPE_NOTYPE_STR;",
          "2651:  case STT_OBJECT:  return R_BIN_TYPE_OBJECT_STR;",
          "2652:  case STT_FUNC:    return R_BIN_TYPE_FUNC_STR;",
          "2653:  case STT_SECTION: return R_BIN_TYPE_SECTION_STR;",
          "2654:  case STT_FILE:    return R_BIN_TYPE_FILE_STR;",
          "2655:  case STT_COMMON:  return R_BIN_TYPE_COMMON_STR;",
          "2656:  case STT_TLS:     return R_BIN_TYPE_TLS_STR;",
          "2657:  case STT_NUM:     return R_BIN_TYPE_NUM_STR;",
          "2658:  case STT_LOOS:    return R_BIN_TYPE_LOOS_STR;",
          "2659:  case STT_HIOS:    return R_BIN_TYPE_HIOS_STR;",
          "2660:  case STT_LOPROC:  return R_BIN_TYPE_LOPROC_STR;",
          "2661:  case STT_HIPROC:  return R_BIN_TYPE_HIPROC_STR;",
          "2662:  default:          return R_BIN_TYPE_UNKNOWN_STR;",
          "2666: static void fill_symbol_bind_and_type (struct r_bin_elf_symbol_t *ret, Elf_(Sym) *sym) {",
          "2667:  ret->bind = bind2str (sym);",
          "2668:  ret->type = type2str (sym);",
          "2669: }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2758:   sym[i].st_other = READ8 (s, j);",
          "2759:   sym[i].st_shndx = READ16 (s, j);",
          "2760: #endif",
          "2764:    if (sym[i].st_value) {",
          "2765:     toffset = sym[i].st_value;",
          "2766:    } else if ((toffset = get_import_addr (bin, i)) == -1){",
          "",
          "[Removed Lines]",
          "2763:   if (type == R_BIN_ELF_IMPORTS && sym[i].st_shndx == STN_UNDEF) {",
          "",
          "[Added Lines]",
          "2762:   bool is_sht_null = false;",
          "2765:   if (type == R_BIN_ELF_IMPORTS && sym[i].st_shndx == SHT_NULL) {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2770:   } else if (type == R_BIN_ELF_SYMBOLS) {",
          "2771:    tsize = sym[i].st_size;",
          "2772:    toffset = (ut64) sym[i].st_value;",
          "2773:   } else {",
          "2774:    continue;",
          "2775:   }",
          "2776:   tmp_offset = Elf_(r_bin_elf_v2p) (bin, toffset);",
          "2777:   if (tmp_offset > bin->size) {",
          "2778:    goto done;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2775:    is_sht_null = sym[i].st_shndx == SHT_NULL;",
          "2781:   if (!strcmp (bind2str (&sym[i]), R_BIN_BIND_UNKNOWN_STR) ||",
          "2782:       !strcmp (type2str (&sym[i]), R_BIN_TYPE_UNKNOWN_STR)) {",
          "2783:    goto done;",
          "2784:   }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "2800:   ret[ret_ctr].in_shdr = false;",
          "2801:   ret[ret_ctr].name[ELF_STRING_LENGTH - 2] = '\\0';",
          "2802:   fill_symbol_bind_and_type (&ret[ret_ctr], &sym[i]);",
          "2803:   ret[ret_ctr].last = 0;",
          "2804:   ret_ctr++;",
          "2805:  }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2812:   ret[ret_ctr].is_sht_null = is_sht_null;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "2867:  return bin->phdr_imports;",
          "2868: }",
          "2870: static int Elf_(fix_symbols)(ELFOBJ *bin, int nsym, int type, RBinElfSymbol **sym) {",
          "2871:  int count = 0;",
          "2872:  RBinElfSymbol *ret = *sym;",
          "2876:  RBinElfSymbol *tmp, *p;",
          "2877:  if (phdr_symbols) {",
          "2878:   RBinElfSymbol *d = ret;",
          "",
          "[Removed Lines]",
          "2873:  RBinElfSymbol *phdr_symbols = (type == R_BIN_ELF_SYMBOLS)",
          "2874:     ? Elf_(r_bin_elf_get_phdr_symbols) (bin)",
          "2875:     : Elf_(r_bin_elf_get_phdr_imports) (bin);",
          "",
          "[Added Lines]",
          "2880: static RBinElfSymbol *Elf_(get_phdr_symbols)(ELFOBJ *bin, int type) {",
          "2881:  return (type == R_BIN_ELF_SYMBOLS)",
          "2882:   ? Elf_(r_bin_elf_get_phdr_symbols) (bin)",
          "2883:   : Elf_(r_bin_elf_get_phdr_imports) (bin);",
          "2884: }",
          "2889:  RBinElfSymbol *phdr_symbols = Elf_(get_phdr_symbols) (bin, type);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "2934:  char *strtab = NULL;",
          "2936:  if (!bin || !bin->shdr || !bin->ehdr.e_shnum || bin->ehdr.e_shnum == 0xffff) {",
          "2940:  }",
          "2941:  if (!UT32_MUL (&shdr_size, bin->ehdr.e_shnum, sizeof (Elf_(Shdr)))) {",
          "2942:   return false;",
          "",
          "[Removed Lines]",
          "2937:   return (type == R_BIN_ELF_SYMBOLS)",
          "2938:     ? Elf_(r_bin_elf_get_phdr_symbols) (bin)",
          "2939:     : Elf_(r_bin_elf_get_phdr_imports) (bin);",
          "",
          "[Added Lines]",
          "2951:   return Elf_(get_phdr_symbols) (bin, type);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "3034:     goto beach;",
          "3035:    }",
          "3036:    for (k = 1, ret_ctr = 0; k < nsym; k++) {",
          "3037:     if (type == R_BIN_ELF_IMPORTS && sym[k].st_shndx == STN_UNDEF) {",
          "3038:      if (sym[k].st_value) {",
          "3039:       toffset = sym[k].st_value;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3049:     bool is_sht_null = false;",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "3041:       toffset = 0;",
          "3042:      }",
          "3043:      tsize = 16;",
          "3047:      tsize = sym[k].st_size;",
          "3048:      toffset = (ut64)sym[k].st_value;",
          "3049:     } else {",
          "3050:      continue;",
          "3051:     }",
          "",
          "[Removed Lines]",
          "3044:     } else if (type == R_BIN_ELF_SYMBOLS &&",
          "3045:         sym[k].st_shndx != STN_UNDEF) {",
          "",
          "[Added Lines]",
          "3057:     } else if (type == R_BIN_ELF_SYMBOLS) {",
          "3060:      is_sht_null = sym[k].st_shndx == SHT_NULL;",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "3074:     ret[ret_ctr].ordinal = k;",
          "3075:     ret[ret_ctr].name[ELF_STRING_LENGTH - 2] = '\\0';",
          "3076:     fill_symbol_bind_and_type (&ret[ret_ctr], &sym[k]);",
          "3077:     ret[ret_ctr].last = 0;",
          "3078:     ret_ctr++;",
          "3079:    }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3089:     ret[ret_ctr].is_sht_null = is_sht_null;",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "3083:   }",
          "3084:  }",
          "3085:  if (!ret) {",
          "3089:  }",
          "3090:  int max = -1;",
          "3091:  RBinElfSymbol *aux = NULL;",
          "",
          "[Removed Lines]",
          "3086:   return (type == R_BIN_ELF_SYMBOLS)",
          "3087:     ? Elf_(r_bin_elf_get_phdr_symbols) (bin)",
          "3088:     : Elf_(r_bin_elf_get_phdr_imports) (bin);",
          "",
          "[Added Lines]",
          "3099:   return Elf_(get_phdr_symbols) (bin, type);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "3348:    }",
          "3349:    ut64 i = bin->phdr[ph].p_offset + offset;",
          "3350:    ut64 n_maps;",
          "3352:    if (bits == 64) {",
          "3353:     n_maps = BREAD64 (bin->b, i);",
          "3355:    } else {",
          "3356:     n_maps = BREAD32 (bin->b, i);",
          "3358:    }",
          "3359:    ut64 jump = ((size_of * 3) * n_maps) + i;",
          "3360:    int len_str = 0;",
          "",
          "[Removed Lines]",
          "3351:    ut64 page_size;",
          "3354:     page_size = BREAD64 (bin->b, i);",
          "3357:     page_size = BREAD32 (bin->b, i);",
          "",
          "[Added Lines]",
          "3364:     (void)BREAD64 (bin->b, i);",
          "3367:     (void)BREAD32 (bin->b, i);",
          "",
          "---------------"
        ],
        "libr/bin/format/elf/elf.h||libr/bin/format/elf/elf.h": [
          "File: libr/bin/format/elf/elf.h -> libr/bin/format/elf/elf.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "38:  char name[ELF_STRING_LENGTH];",
          "39:  int last;",
          "40:  bool in_shdr;",
          "41: } RBinElfSymbol;",
          "43: typedef struct r_bin_elf_reloc_t {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "41:  bool is_sht_null;",
          "",
          "---------------"
        ],
        "libr/bin/format/mdmp/mdmp_pe.c||libr/bin/format/mdmp/mdmp_pe.c": [
          "File: libr/bin/format/mdmp/mdmp_pe.c -> libr/bin/format/mdmp/mdmp_pe.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "109:   filter_import (imports[i].name);",
          "110:   ptr->name = strdup ((char*)imports[i].name);",
          "111:   ptr->bind = r_str_const (\"NONE\");",
          "113:   ptr->ordinal = imports[i].ordinal;",
          "114:   r_list_append (ret, ptr);",
          "",
          "[Removed Lines]",
          "112:   ptr->type = r_str_const (\"FUNC\");",
          "",
          "[Added Lines]",
          "112:   ptr->type = r_str_const (R_BIN_TYPE_FUNC_STR);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "228:    }",
          "229:    ptr->name = strdup ((char *)symbols[i].name);",
          "230:    ptr->forwarder = r_str_const ((char *)symbols[i].forwarder);",
          "233:    ptr->size = 0;",
          "234:    ptr->vaddr = offset + pe_bin->vaddr;",
          "235:    ptr->paddr = symbols[i].paddr + pe_bin->paddr;",
          "",
          "[Removed Lines]",
          "231:    ptr->bind = r_str_const (\"GLOBAL\");",
          "232:    ptr->type = r_str_const (\"FUNC\");",
          "",
          "[Added Lines]",
          "231:    ptr->bind = r_str_const (R_BIN_BIND_GLOBAL_STR);",
          "232:    ptr->type = r_str_const (R_BIN_TYPE_FUNC_STR);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "251:    }",
          "252:    ptr->name = r_str_newf (\"imp.%s\", imports[i].name);",
          "253:    ptr->bind = r_str_const (\"NONE\");",
          "255:    ptr->size = 0;",
          "256:    ptr->vaddr = offset + pe_bin->vaddr;",
          "257:    ptr->paddr = imports[i].paddr + pe_bin->paddr;",
          "",
          "[Removed Lines]",
          "254:    ptr->type = r_str_const (\"FUNC\");",
          "",
          "[Added Lines]",
          "254:    ptr->type = r_str_const (R_BIN_TYPE_FUNC_STR);",
          "",
          "---------------"
        ],
        "libr/bin/format/nxo/nxo.c||libr/bin/format/nxo/nxo.c": [
          "File: libr/bin/format/nxo/nxo.c -> libr/bin/format/nxo/nxo.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "62:   if (!sym) {",
          "63:    break;",
          "64:   }",
          "66:   sym->bind = r_str_const (\"NONE\");",
          "67:   sym->size = size;",
          "",
          "[Removed Lines]",
          "65:   sym->type = r_str_const (\"FUNC\");",
          "",
          "[Added Lines]",
          "65:   sym->type = r_str_const (R_BIN_TYPE_FUNC_STR);",
          "",
          "---------------"
        ],
        "libr/bin/format/objc/mach0_classes.c||libr/bin/format/objc/mach0_classes.c": [
          "File: libr/bin/format/objc/mach0_classes.c -> libr/bin/format/objc/mach0_classes.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "613:   }",
          "615:   method->vaddr = m.imp;",
          "617:   if (is_static) {",
          "618:    method->method_flags |= R_BIN_METH_CLASS;",
          "619:   }",
          "",
          "[Removed Lines]",
          "616:   method->type = is_static ? \"FUNC\" : \"METH\";",
          "",
          "[Added Lines]",
          "616:   method->type = is_static ? R_BIN_TYPE_FUNC_STR : \"METH\";",
          "",
          "---------------"
        ],
        "libr/bin/p/bin_coff.c||libr/bin/p/bin_coff.c": [
          "File: libr/bin/p/bin_coff.c -> libr/bin/p/bin_coff.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "76:  switch (s->n_sclass) {",
          "77:  case COFF_SYM_CLASS_FUNCTION:",
          "79:   break;",
          "80:  case COFF_SYM_CLASS_FILE:",
          "81:   ptr->type = r_str_const (\"FILE\");",
          "82:   break;",
          "83:  case COFF_SYM_CLASS_SECTION:",
          "85:   break;",
          "86:  case COFF_SYM_CLASS_EXTERNAL:",
          "87:   ptr->type = r_str_const (\"EXTERNAL\");",
          "",
          "[Removed Lines]",
          "78:   ptr->type = r_str_const (\"FUNC\");",
          "84:   ptr->type = r_str_const (\"SECTION\");",
          "",
          "[Added Lines]",
          "78:   ptr->type = r_str_const (R_BIN_TYPE_FUNC_STR);",
          "84:   ptr->type = r_str_const (R_BIN_TYPE_SECTION_STR);",
          "",
          "---------------"
        ],
        "libr/bin/p/bin_dex.c||libr/bin/p/bin_dex.c": [
          "File: libr/bin/p/bin_dex.c -> libr/bin/p/bin_dex.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1279:    if (MC > 0) {",
          "1281:     sym->paddr = MC;// + 0x10;",
          "1282:     sym->vaddr = MC;// + 0x10;",
          "1283:    } else {",
          "",
          "[Removed Lines]",
          "1280:     sym->type = r_str_const (\"FUNC\");",
          "",
          "[Added Lines]",
          "1280:     sym->type = r_str_const (R_BIN_TYPE_FUNC_STR);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1286:     sym->vaddr = encoded_method_addr - binfile->buf->buf;",
          "1287:    }",
          "1288:    if ((MA & 0x1) == 0x1) {",
          "1290:    } else {",
          "1292:    }",
          "1294:    sym->method_flags = get_method_flags (MA);",
          "",
          "[Removed Lines]",
          "1289:     sym->bind = r_str_const (\"GLOBAL\");",
          "1291:     sym->bind = r_str_const (\"LOCAL\");",
          "",
          "[Added Lines]",
          "1289:     sym->bind = r_str_const (R_BIN_BIND_GLOBAL_STR);",
          "1291:     sym->bind = r_str_const (R_BIN_BIND_LOCAL_STR);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1705:      return false;",
          "1706:     }",
          "1707:     sym->name = r_str_newf (\"imp.%s\", imp->name);",
          "1709:     sym->bind = r_str_const (\"NONE\");",
          "",
          "[Removed Lines]",
          "1708:     sym->type = r_str_const (\"FUNC\");",
          "",
          "[Added Lines]",
          "1708:     sym->type = r_str_const (R_BIN_TYPE_FUNC_STR);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1790:  r_list_foreach (bin->methods_list, iter, m) {",
          "1791:   if (strlen (m->name) > 30 && m->bind &&",
          "1793:       !strcmp (m->name + strlen (m->name) - 31,",
          "1794:         \".onCreate(Landroid/os/Bundle;)V\")) {",
          "1795:    if (!already_entry (ret, m->paddr)) {",
          "",
          "[Removed Lines]",
          "1792:    (!strcmp (m->bind, \"LOCAL\") || !strcmp (m->bind, \"GLOBAL\")) &&",
          "",
          "[Added Lines]",
          "1792:    (!strcmp (m->bind, R_BIN_BIND_LOCAL_STR) || !strcmp (m->bind, R_BIN_BIND_GLOBAL_STR)) &&",
          "",
          "---------------"
        ],
        "libr/bin/p/bin_dyldcache.c||libr/bin/p/bin_dyldcache.c": [
          "File: libr/bin/p/bin_dyldcache.c -> libr/bin/p/bin_dyldcache.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "977:   }",
          "978:   sym->forwarder = r_str_const (\"NONE\");",
          "979:   sym->bind = r_str_const ((symbols[i].type == R_BIN_MACH0_SYMBOL_TYPE_LOCAL)?",
          "982:   sym->paddr = symbols[i].offset + bf->o->boffset;",
          "983:   sym->size = symbols[i].size;",
          "984:   sym->ordinal = i;",
          "",
          "[Removed Lines]",
          "980:    \"LOCAL\": \"GLOBAL\");",
          "981:   sym->type = r_str_const (\"FUNC\");",
          "",
          "[Added Lines]",
          "980:    R_BIN_BIND_LOCAL_STR: R_BIN_BIND_GLOBAL_STR);",
          "981:   sym->type = r_str_const (R_BIN_TYPE_FUNC_STR);",
          "",
          "---------------"
        ],
        "libr/bin/p/bin_elf.c||libr/bin/p/bin_elf.c": [
          "File: libr/bin/p/bin_elf.c -> libr/bin/p/bin_elf.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "51:  if (!eobj->symbols_by_ord || ord >= eobj->symbols_by_ord_size) {",
          "52:   return;",
          "53:  }",
          "56: }",
          "59:  if (!eobj->imports_by_ord || ord >= eobj->imports_by_ord_size) {",
          "65:  }",
          "69: }",
          "71: static Sdb* get_sdb(RBinFile *bf) {",
          "",
          "[Removed Lines]",
          "54:  free (eobj->symbols_by_ord[ord]);",
          "55:  eobj->symbols_by_ord[ord] = r_mem_dup (ptr, sizeof (RBinSymbol));",
          "58: static inline bool setimpord(ELFOBJ* eobj, ut32 ord, RBinImport *ptr) {",
          "60:   return false;",
          "61:  }",
          "62:  if (eobj->imports_by_ord[ord]) {",
          "63:   free (eobj->imports_by_ord[ord]->name);",
          "64:   free (eobj->imports_by_ord[ord]);",
          "66:  eobj->imports_by_ord[ord] = r_mem_dup (ptr, sizeof (RBinImport));",
          "67:  eobj->imports_by_ord[ord]->name = strdup (ptr->name);",
          "68:  return true;",
          "",
          "[Added Lines]",
          "54:  r_bin_symbol_free (eobj->symbols_by_ord[ord]);",
          "55:  eobj->symbols_by_ord[ord] = r_bin_symbol_clone (ptr);",
          "58: static void setimpord(ELFOBJ* eobj, ut32 ord, RBinImport *ptr) {",
          "60:   return;",
          "62:  r_bin_import_free (eobj->imports_by_ord[ord]);",
          "63:  eobj->imports_by_ord[ord] = r_bin_import_clone (ptr);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "475:  }",
          "476: }",
          "478: static RList* symbols(RBinFile *bf) {",
          "479:  struct Elf_(r_bin_elf_obj_t) *bin;",
          "480:  struct r_bin_elf_symbol_t *symbol = NULL;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "473: static RBinSymbol *convert_symbol(struct Elf_(r_bin_elf_obj_t) *bin,",
          "474:       struct r_bin_elf_symbol_t *symbol,",
          "475:       const char *namefmt) {",
          "476:  ut64 paddr = symbol->offset;",
          "477:  ut64 vaddr = Elf_(r_bin_elf_p2v) (bin, paddr);",
          "478:  RBinSymbol *ptr = NULL;",
          "480:  if (!(ptr = R_NEW0 (RBinSymbol))) {",
          "481:   return NULL;",
          "482:  }",
          "483:  ptr->name = symbol->name[0] ? r_str_newf (namefmt, &symbol->name[0]) : strdup(\"\");",
          "484:  ptr->forwarder = r_str_const (\"NONE\");",
          "485:  ptr->bind = r_str_const (symbol->bind);",
          "486:  ptr->type = r_str_const (symbol->type);",
          "487:  ptr->paddr = paddr;",
          "488:  ptr->vaddr = vaddr;",
          "489:  ptr->size = symbol->size;",
          "490:  ptr->ordinal = symbol->ordinal;",
          "492:  if (bin->ehdr.e_machine == EM_ARM && *ptr->name) {",
          "493:   _set_arm_thumb_bits (bin, &ptr);",
          "494:  }",
          "496:  return ptr;",
          "497: }",
          "499: static void insert_symbol(struct Elf_(r_bin_elf_obj_t) *bin,",
          "500:      RBinSymbol *ptr,",
          "501:      bool is_sht_null,",
          "502:      RList *ret) {",
          "504:  setsymord (bin, ptr->ordinal, ptr);",
          "506:  if (is_sht_null) {",
          "507:   r_bin_symbol_free (ptr);",
          "508:  } else {",
          "509:   r_list_append (ret, ptr);",
          "510:  }",
          "511: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "491:  if (!ret) {",
          "492:   return NULL;",
          "493:  }",
          "494:  if (!(symbol = Elf_(r_bin_elf_get_symbols) (bin))) {",
          "495:   return ret;",
          "496:  }",
          "497:  for (i = 0; !symbol[i].last; i++) {",
          "501:    break;",
          "502:   }",
          "516:  }",
          "517:  if (!(symbol = Elf_(r_bin_elf_get_imports) (bin))) {",
          "518:   return ret;",
          "519:  }",
          "520:  for (i = 0; !symbol[i].last; i++) {",
          "523:   if (!symbol[i].size) {",
          "524:    continue;",
          "525:   }",
          "527:    break;",
          "528:   }",
          "539:   if (ptr->vaddr == UT32_MAX) {",
          "540:    ptr->paddr = 0;",
          "541:    ptr->vaddr = 0;",
          "542:   }",
          "551:  }",
          "552:  return ret;",
          "553: }",
          "",
          "[Removed Lines]",
          "498:   ut64 paddr = symbol[i].offset;",
          "499:   ut64 vaddr = Elf_(r_bin_elf_p2v) (bin, paddr);",
          "500:   if (!(ptr = R_NEW0 (RBinSymbol))) {",
          "503:   ptr->name = strdup (symbol[i].name);",
          "504:   ptr->forwarder = r_str_const (\"NONE\");",
          "505:   ptr->bind = r_str_const (symbol[i].bind);",
          "506:   ptr->type = r_str_const (symbol[i].type);",
          "507:   ptr->paddr = paddr;",
          "508:   ptr->vaddr = vaddr;",
          "509:   ptr->size = symbol[i].size;",
          "510:   ptr->ordinal = symbol[i].ordinal;",
          "511:   setsymord (bin, ptr->ordinal, ptr);",
          "512:   if (bin->ehdr.e_machine == EM_ARM && *ptr->name) {",
          "513:    _set_arm_thumb_bits (bin, &ptr);",
          "514:   }",
          "515:   r_list_append (ret, ptr);",
          "521:   ut64 paddr = symbol[i].offset;",
          "522:   ut64 vaddr = Elf_(r_bin_elf_p2v) (bin, paddr);",
          "526:   if (!(ptr = R_NEW0 (RBinSymbol))) {",
          "531:   ptr->name = r_str_newf (\"imp.%s\", symbol[i].name);",
          "532:   ptr->forwarder = r_str_const (\"NONE\");",
          "534:   ptr->bind = r_str_const (symbol[i].bind);",
          "535:   ptr->type = r_str_const (symbol[i].type);",
          "536:   ptr->paddr = paddr;",
          "537:   ptr->vaddr = vaddr;",
          "543:   ptr->size = symbol[i].size;",
          "544:   ptr->ordinal = symbol[i].ordinal;",
          "545:   setsymord (bin, ptr->ordinal, ptr);",
          "547:   if (bin->ehdr.e_machine == EM_ARM) {",
          "548:    _set_arm_thumb_bits (bin, &ptr);",
          "549:   }",
          "550:   r_list_append (ret, ptr);",
          "",
          "[Added Lines]",
          "535:   ptr = convert_symbol (bin, &symbol[i], \"%s\");",
          "536:   if (!ptr) {",
          "539:   insert_symbol (bin, ptr, symbol[i].is_sht_null, ret);",
          "551:   ptr = convert_symbol (bin, &symbol[i], \"imp.%s\");",
          "552:   if (!ptr) {",
          "562:   insert_symbol (bin, ptr, symbol[i].is_sht_null, ret);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "578:   ptr->bind = r_str_const (import[i].bind);",
          "579:   ptr->type = r_str_const (import[i].type);",
          "580:   ptr->ordinal = import[i].ordinal;",
          "582:   r_list_append (ret, ptr);",
          "583:  }",
          "584:  return ret;",
          "",
          "[Removed Lines]",
          "581:   (void)setimpord (bin, ptr->ordinal, ptr);",
          "",
          "[Added Lines]",
          "593:   setimpord (bin, ptr->ordinal, ptr);",
          "",
          "---------------"
        ],
        "libr/bin/p/bin_mach0.c||libr/bin/p/bin_mach0.c": [
          "File: libr/bin/p/bin_mach0.c -> libr/bin/p/bin_mach0.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "309:   }",
          "310:   ptr->forwarder = r_str_const (\"NONE\");",
          "311:   ptr->bind = r_str_const ((symbols[i].type == R_BIN_MACH0_SYMBOL_TYPE_LOCAL)?",
          "314:   ptr->vaddr = symbols[i].addr;",
          "315:   ptr->paddr = symbols[i].offset + obj->boffset;",
          "316:   ptr->size = symbols[i].size;",
          "",
          "[Removed Lines]",
          "312:     \"LOCAL\": \"GLOBAL\");",
          "313:   ptr->type = r_str_const (\"FUNC\");",
          "",
          "[Added Lines]",
          "312:     R_BIN_BIND_LOCAL_STR: R_BIN_BIND_GLOBAL_STR);",
          "313:   ptr->type = r_str_const (R_BIN_TYPE_FUNC_STR);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "343:    ptr->paddr = address;",
          "344:    ptr->size = 0;",
          "345:    ptr->name = r_str_newf (\"func.%08\"PFMT64x, ptr->vaddr);",
          "347:    ptr->forwarder = \"NONE\";",
          "349:    ptr->ordinal = i++;",
          "350:    if (bin->hdr.cputype == CPU_TYPE_ARM && wordsize < 64) {",
          "351:     _handle_arm_thumb (bin, &ptr);",
          "",
          "[Removed Lines]",
          "346:    ptr->type = \"FUNC\";",
          "348:    ptr->bind = \"LOCAL\";",
          "",
          "[Added Lines]",
          "346:    ptr->type = R_BIN_TYPE_FUNC_STR;",
          "348:    ptr->bind = R_BIN_BIND_LOCAL_STR;",
          "",
          "---------------"
        ],
        "libr/bin/p/bin_pe.c||libr/bin/p/bin_pe.c": [
          "File: libr/bin/p/bin_pe.c -> libr/bin/p/bin_pe.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "246:    ptr->name = strdup ((char *)symbols[i].name);",
          "247:    ptr->forwarder = r_str_const ((char *)symbols[i].forwarder);",
          "251:    ptr->size = 0;",
          "252:    ptr->vaddr = symbols[i].vaddr;",
          "253:    ptr->paddr = symbols[i].paddr;",
          "",
          "[Removed Lines]",
          "249:    ptr->bind = r_str_const (\"GLOBAL\");",
          "250:    ptr->type = r_str_const (\"FUNC\");",
          "",
          "[Added Lines]",
          "249:    ptr->bind = r_str_const (R_BIN_BIND_GLOBAL_STR);",
          "250:    ptr->type = r_str_const (R_BIN_TYPE_FUNC_STR);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "267:    ptr->name = r_str_newf (\"imp.%s\", imports[i].name);",
          "269:    ptr->bind = r_str_const (\"NONE\");",
          "271:    ptr->size = 0;",
          "272:    ptr->vaddr = imports[i].vaddr;",
          "273:    ptr->paddr = imports[i].paddr;",
          "",
          "[Removed Lines]",
          "270:    ptr->type = r_str_const (\"FUNC\");",
          "",
          "[Added Lines]",
          "270:    ptr->type = r_str_const (R_BIN_TYPE_FUNC_STR);",
          "",
          "---------------"
        ],
        "libr/bin/p/bin_wasm.c||libr/bin/p/bin_wasm.c": [
          "File: libr/bin/p/bin_wasm.c -> libr/bin/p/bin_wasm.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "137:   ptr->forwarder = r_str_const (\"NONE\");",
          "138:   ptr->bind = r_str_const (\"NONE\");",
          "139:   switch (imp->kind) {",
          "141:   case 1: ptr->type = r_str_const (\"TABLE\"); break;",
          "142:   case 2: ptr->type = r_str_const (\"MEMORY\"); break;",
          "144:   }",
          "145:   ptr->size = 0;",
          "146:   ptr->vaddr = -1;",
          "",
          "[Removed Lines]",
          "140:   case 0: ptr->type = r_str_const (\"FUNC\"); break;",
          "143:   case 3: ptr->type = r_str_const (\"GLOBAL\"); break;",
          "",
          "[Added Lines]",
          "140:   case 0: ptr->type = r_str_const (R_BIN_TYPE_FUNC_STR); break;",
          "143:   case 3: ptr->type = r_str_const (R_BIN_BIND_GLOBAL_STR); break;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "160:   ptr->name = strdup(tmp);",
          "161:   ptr->forwarder = r_str_const (\"NONE\");",
          "162:   ptr->bind = r_str_const (\"NONE\");",
          "164:   ptr->size = func->len;",
          "165:   ptr->vaddr = (ut64)func->code;",
          "166:   ptr->paddr = (ut64)func->code;",
          "",
          "[Removed Lines]",
          "163:   ptr->type = r_str_const (\"FUNC\");",
          "",
          "[Added Lines]",
          "163:   ptr->type = r_str_const (R_BIN_TYPE_FUNC_STR);",
          "",
          "---------------"
        ],
        "libr/core/canal.c||libr/core/canal.c": [
          "File: libr/core/canal.c -> libr/core/canal.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3187: static bool isValidSymbol(RBinSymbol *symbol) {",
          "3188:  if (symbol && symbol->type) {",
          "3189:   const char *type = symbol->type;",
          "3191:  }",
          "3192:  return false;",
          "3193: }",
          "",
          "[Removed Lines]",
          "3190:   return (!strcmp (type, \"FUNC\") || !strcmp (type, \"METH\"));",
          "",
          "[Added Lines]",
          "3190:   return (!strcmp (type, R_BIN_TYPE_FUNC_STR) || !strcmp (type, \"METH\"));",
          "",
          "---------------"
        ],
        "libr/core/cbin.c||libr/core/cbin.c": [
          "File: libr/core/cbin.c -> libr/core/cbin.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1330:  if (!s || *s->name) {",
          "1331:   return false;",
          "1332:  }",
          "1334: }",
          "1336: static bool is_section_reloc(RBinReloc *r) {",
          "",
          "[Removed Lines]",
          "1333:  return (s->type && !strcmp (s->type, \"SECTION\"));",
          "",
          "[Added Lines]",
          "1333:  return (s->type && !strcmp (s->type, R_BIN_TYPE_SECTION_STR));",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1340: static bool is_file_symbol(RBinSymbol *s) {",
          "1343: }",
          "1345: static bool is_file_reloc(RBinReloc *r) {",
          "",
          "[Removed Lines]",
          "1342:  return (s && s->type && !strcmp (s->type, \"FILE\"));",
          "",
          "[Added Lines]",
          "1342:  return (s && s->type && !strcmp (s->type, R_BIN_TYPE_FILE_STR));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1677: static const char *getPrefixFor(const char *s) {",
          "1678:  if (s) {",
          "1680:    return \"loc\";",
          "1681:   }",
          "1683:    return \"obj\";",
          "1684:   }",
          "1685:  }",
          "",
          "[Removed Lines]",
          "1679:   if (!strcmp (s, \"NOTYPE\")) {",
          "1682:   if (!strcmp (s, \"OBJ\")) {",
          "",
          "[Added Lines]",
          "1680:   if (!strcmp (s, R_BIN_TYPE_NOTYPE_STR)) {",
          "1683:   if (!strcmp (s, R_BIN_TYPE_OBJECT_STR)) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1753:  if (!strncmp (s->name, \"imp.\", 4)) {",
          "1754:   return false;",
          "1755:  }",
          "1757: }",
          "1759: static int bin_symbols_internal(RCore *r, int mode, ut64 laddr, int va, ut64 at, const char *name, bool exponly, const char *args) {",
          "",
          "[Removed Lines]",
          "1756:  return (s->bind && !strcmp (s->bind, \"GLOBAL\"));",
          "",
          "[Added Lines]",
          "1757:  return (s->bind && !strcmp (s->bind, R_BIN_BIND_GLOBAL_STR));",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1879:    } else {",
          "1880:     const char *fn, *n;",
          "1881:     RFlagItem *fi;",
          "1897:     } else {",
          "1899:     }",
          "1900:    }",
          "1901:    if (sn.demname) {",
          "1902:     r_meta_add (r->anal, R_META_TYPE_COMMENT,",
          "",
          "[Removed Lines]",
          "1882:     if (*sn.name && symbol->paddr) {",
          "1883:      n = sn.demname ? sn.demname : sn.name;",
          "1884:      fn = sn.demflag ? sn.demflag : sn.nameflag;",
          "1885:      char *fnp = (r->bin->prefix) ?",
          "1886:       r_str_newf (\"%s.%s\", r->bin->prefix, fn):",
          "1887:       strdup (fn);",
          "1888:      fi = r_flag_set (r->flags, fnp, addr, symbol->size);",
          "1889:      if (fi) {",
          "1890:       r_flag_item_set_realname (fi, n);",
          "1891:      } else {",
          "1892:       if (fn) {",
          "1893:        eprintf (\"[Warning] Can't find flag (%s)\\n\", fn);",
          "1894:       }",
          "1895:      }",
          "1896:      free (fnp);",
          "",
          "[Added Lines]",
          "1883:     n = sn.demname ? sn.demname : sn.name;",
          "1884:     fn = sn.demflag ? sn.demflag : sn.nameflag;",
          "1885:     char *fnp = (r->bin->prefix) ?",
          "1886:      r_str_newf (\"%s.%s\", r->bin->prefix, fn):",
          "1887:      strdup (fn);",
          "1888:     fi = r_flag_set (r->flags, fnp, addr, symbol->size);",
          "1889:     if (fi) {",
          "1890:      r_flag_item_set_realname (fi, n);",
          "1892:      if (fn) {",
          "1893:       eprintf (\"[Warning] Can't find flag (%s)\\n\", fn);",
          "1894:      }",
          "1896:     free (fnp);",
          "",
          "---------------"
        ],
        "libr/core/cmd_debug.c||libr/core/cmd_debug.c": [
          "File: libr/core/cmd_debug.c -> libr/core/cmd_debug.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2969:   RList *symbols = r_bin_get_symbols (core->bin);",
          "2970:   RBinSymbol *symbol;",
          "2971:   r_list_foreach (symbols, iter, symbol) {",
          "2973:     if (r_anal_noreturn_at (core->anal, symbol->vaddr)) {",
          "2974:      bpi = r_debug_bp_add (core->dbg, symbol->vaddr, hwbp, false, 0, NULL, 0);",
          "2975:      if (bpi) {",
          "",
          "[Removed Lines]",
          "2972:    if (symbol->type && !strcmp (symbol->type, \"FUNC\")) {",
          "",
          "[Added Lines]",
          "2972:    if (symbol->type && !strcmp (symbol->type, R_BIN_TYPE_FUNC_STR)) {",
          "",
          "---------------"
        ],
        "libr/include/r_bin.h||libr/include/r_bin.h": [
          "File: libr/include/r_bin.h -> libr/include/r_bin.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "92: #define R_BIN_METH_CONSTRUCTOR 0x0000000000100000L",
          "93: #define R_BIN_METH_DECLARED_SYNCHRONIZED 0x0000000000200000L",
          "95: enum {",
          "96:  R_BIN_SYM_ENTRY,",
          "97:  R_BIN_SYM_INIT,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "95: #define R_BIN_BIND_LOCAL_STR \"LOCAL\"",
          "96: #define R_BIN_BIND_GLOBAL_STR \"GLOBAL\"",
          "97: #define R_BIN_BIND_WEAK_STR \"WEAK\"",
          "98: #define R_BIN_BIND_NUM_STR \"NUM\"",
          "99: #define R_BIN_BIND_LOOS_STR \"LOOS\"",
          "100: #define R_BIN_BIND_HIOS_STR \"HIOS\"",
          "101: #define R_BIN_BIND_LOPROC_STR \"LOPROC\"",
          "102: #define R_BIN_BIND_HIPROC_STR \"HIPROC\"",
          "103: #define R_BIN_BIND_UNKNOWN_STR \"UNKNOWN\"",
          "105: #define R_BIN_TYPE_NOTYPE_STR \"NOTYPE\"",
          "106: #define R_BIN_TYPE_OBJECT_STR \"OBJ\"",
          "107: #define R_BIN_TYPE_FUNC_STR \"FUNC\"",
          "108: #define R_BIN_TYPE_SECTION_STR \"SECT\"",
          "109: #define R_BIN_TYPE_FILE_STR \"FILE\"",
          "110: #define R_BIN_TYPE_COMMON_STR \"COMMON\"",
          "111: #define R_BIN_TYPE_TLS_STR \"TLS\"",
          "112: #define R_BIN_TYPE_NUM_STR \"NUM\"",
          "113: #define R_BIN_TYPE_LOOS_STR \"LOOS\"",
          "114: #define R_BIN_TYPE_HIOS_STR \"HIOS\"",
          "115: #define R_BIN_TYPE_LOPROC_STR \"LOPROC\"",
          "116: #define R_BIN_TYPE_HIPROC_STR \"HIPROC\"",
          "117: #define R_BIN_TYPE_UNKNOWN_STR \"UNK\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "590:  char *name; // or comment :?",
          "591: } RBinOptions;",
          "593: R_API RBinOptions *r_bin_options_new (ut64 offset, ut64 baddr, int rawstr);",
          "594: R_API void r_bin_options_free(RBinOptions *bo);",
          "595: R_API int r_bin_open(RBin *bin, const char *filename, RBinOptions *bo);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "617: R_API RBinImport *r_bin_import_clone(RBinImport *o);",
          "618: R_API RBinSymbol *r_bin_symbol_clone(RBinSymbol *o);",
          "",
          "---------------"
        ],
        "libr/include/r_util/r_str.h||libr/include/r_util/r_str.h": [
          "File: libr/include/r_util/r_str.h -> libr/include/r_util/r_str.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "25:    memmove (s, s+1, strlen (s));",
          "26:  }",
          "27: }",
          "28: #define r_str_array(x,y) ((y>=0 && y<(sizeof(x)/sizeof(*x)))?x[y]:\"\")",
          "29: R_API const char *r_str_pad(const char ch, int len);",
          "30: R_API const char *r_str_rstr(const char *base, const char *p);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "29: #define R_STR_DUP(x) ((x) ? strdup ((x)) : NULL)",
          "",
          "---------------"
        ],
        "shlr/javclass.c||shlr/java/class.c": [
          "File: shlr/javclass.c -> shlr/java/class.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2546:    sym->type = r_str_const (R_BIN_TYPE_FUNC_STR);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2557:    sym->bind = r_str_const (R_BIN_BIND_LOCAL_STR);",
          "2559:    sym->bind = r_str_const (R_BIN_BIND_LOCAL_STR);",
          "2561:    sym->bind = r_str_const (R_BIN_BIND_GLOBAL_STR);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2593:   sym->bind = r_str_const (R_BIN_BIND_LOCAL_STR);",
          "2595:   sym->bind = r_str_const (R_BIN_BIND_LOCAL_STR);",
          "2597:   sym->bind = r_str_const (R_BIN_BIND_GLOBAL_STR);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "80d5d26704d899f0e31bb44e558a139a21638748",
      "candidate_info": {
        "commit_hash": "80d5d26704d899f0e31bb44e558a139a21638748",
        "repo": "radare/radare2",
        "commit_url": "https://github.com/radare/radare2/commit/80d5d26704d899f0e31bb44e558a139a21638748",
        "files": [
          "libr/bin/p/bin_elf.c",
          "libr/core/cbin.c",
          "libr/include/r_bin.h"
        ],
        "message": "iS ELF: differentiate between sections and segments",
        "before_after_code_files": [
          "libr/bin/p/bin_elf.c||libr/bin/p/bin_elf.c",
          "libr/core/cbin.c||libr/core/cbin.c",
          "libr/include/r_bin.h||libr/include/r_bin.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libr/bin/p/bin_elf.c||libr/bin/p/bin_elf.c",
            "libr/core/cbin.c||libr/core/cbin.c"
          ],
          "candidate": [
            "libr/bin/p/bin_elf.c||libr/bin/p/bin_elf.c",
            "libr/core/cbin.c||libr/core/cbin.c"
          ]
        }
      },
      "candidate_diff": {
        "libr/bin/p/bin_elf.c||libr/bin/p/bin_elf.c": [
          "File: libr/bin/p/bin_elf.c -> libr/bin/p/bin_elf.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "228:    ptr->paddr = phdr[i].p_offset;",
          "229:    ptr->vaddr = phdr[i].p_vaddr;",
          "230:    ptr->srwx = phdr[i].p_flags;",
          "231:    switch (phdr[i].p_type) {",
          "232:    case PT_DYNAMIC:",
          "233:     strncpy (ptr->name, \"DYNAMIC\", R_BIN_SIZEOF_STRINGS);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "231:    ptr->is_segment = true;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "304:    ptr->add = true;",
          "305:   }",
          "306:   ptr->srwx = R_BIN_SCN_READABLE | R_BIN_SCN_WRITABLE;",
          "307:   r_list_append (ret, ptr);",
          "308:  }",
          "309:  return ret;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "308:   ptr->is_segment = true;",
          "",
          "---------------"
        ],
        "libr/core/cbin.c||libr/core/cbin.c": [
          "File: libr/core/cbin.c -> libr/core/cbin.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2092:  bool inDebugger = r_config_get_i (r->config, \"cfg.debug\");",
          "2093:  SdbHash *dup_chk_ht = ht_new (NULL, NULL, NULL);",
          "2094:  bool ret = false;",
          "2096:  if (!dup_chk_ht) {",
          "2097:   return false;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2095:  bool has_segments = false;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2340:    } else {",
          "2341:     str[0] = 0;",
          "2342:    }",
          "2343:    if (r->bin->prefix) {",
          "2344: #if 0",
          "2345:     r_cons_printf (\"idx=%02i vaddr=0x%08\"PFMT64x\" paddr=0x%08\"PFMT64x\" sz=%\"PFMT64d\" vsz=%\"PFMT64d\" \"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2344:    if (section->is_segment && !has_segments) {",
          "2345:     r_cons_printf (\"\\n[Segments]\\n\");",
          "2346:     has_segments = true;",
          "2347:     i = 0;",
          "2348:    }",
          "",
          "---------------"
        ],
        "libr/include/r_bin.h||libr/include/r_bin.h": [
          "File: libr/include/r_bin.h -> libr/include/r_bin.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "423:  bool has_strings;",
          "424:  bool add; // indicates when you want to add the section to io `S` command",
          "425:  bool is_data;",
          "426: } RBinSection;",
          "428: typedef struct r_bin_class_t {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "426:  bool is_segment;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "7d8293c59e22533acf0c923857e43cdf58010928",
      "candidate_info": {
        "commit_hash": "7d8293c59e22533acf0c923857e43cdf58010928",
        "repo": "radare/radare2",
        "commit_url": "https://github.com/radare/radare2/commit/7d8293c59e22533acf0c923857e43cdf58010928",
        "files": [
          "libr/bin/p/bin_elf.c",
          "libr/bin/p/bin_pe.c"
        ],
        "message": "Fix ihj PE (#10119)",
        "before_after_code_files": [
          "libr/bin/p/bin_elf.c||libr/bin/p/bin_elf.c",
          "libr/bin/p/bin_pe.c||libr/bin/p/bin_pe.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libr/bin/p/bin_elf.c||libr/bin/p/bin_elf.c"
          ],
          "candidate": [
            "libr/bin/p/bin_elf.c||libr/bin/p/bin_elf.c"
          ]
        }
      },
      "candidate_diff": {
        "libr/bin/p/bin_elf.c||libr/bin/p/bin_elf.c": [
          "File: libr/bin/p/bin_elf.c -> libr/bin/p/bin_elf.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1131:   #define ROW(nam,siz,val,fmt) \\",
          "1132:   r_list_append (ret, r_bin_field_new (addr, addr, siz, nam, sdb_fmt (\"0x%08x\", val), fmt));",
          "1133:   ut64 addr = 0;",
          "1135:   ROW (\"ELF\", 4, r_read_le32 (buf), \"x\"); addr+=0x10;",
          "1136:   ROW (\"Type\", 2, r_read_le16 (buf + addr), \"x\"); addr+=0x2;",
          "1137:   ROW (\"Machine\", 2, r_read_le16 (buf + addr), \"x\"); addr+=0x2;",
          "",
          "[Removed Lines]",
          "1134:   const ut8 *buf = r_buf_get_at (bf->buf, 0, NULL);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "libr/bin/p/bin_pe.c||libr/bin/p/bin_pe.c": [
          "File: libr/bin/p/bin_pe.c -> libr/bin/p/bin_pe.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "676:  return c;",
          "677: }",
          "686: static RList *fields(RBinFile *bf) {",
          "690:   return NULL;",
          "691:  }",
          "704: }",
          "706: static void header(RBinFile *bf) {",
          "",
          "[Removed Lines]",
          "679: static RBinField *newField(const char *name, ut64 addr) {",
          "680:  RBinField *bf = R_NEW0 (RBinField);",
          "681:  bf->name = strdup (name);",
          "682:  bf->vaddr = bf->paddr = addr;",
          "683:  return bf;",
          "684: }",
          "687:  const ut8 *buf = bf ? r_buf_buffer (bf->buf) : NULL;",
          "689:  if (!buf) {",
          "692:  RList *list = r_list_new ();",
          "693:  struct PE_(r_bin_pe_obj_t) * bin = bf->o->bin_obj;",
          "696:  ut64 at = r_offsetof (PE_(image_nt_headers), Signature);",
          "697:  r_list_append (list, newField (\"signature\", at));",
          "699:  at = r_offsetof (PE_(image_optional_header), AddressOfEntryPoint);",
          "700:  at += bin->dos_header->e_lfanew;",
          "701:  r_list_append (list, newField (\"entrypoint\", at));",
          "703:  return list;",
          "",
          "[Added Lines]",
          "680:  RList *ret = NULL;",
          "681:  const ut8 *buf = NULL;",
          "683:  buf = bf ? r_buf_buffer (bf->buf) : NULL;",
          "684:  ret  = r_list_new ();",
          "686:  if (!buf || !ret) {",
          "690:  #define ROWL(nam,siz,val,fmt) \\",
          "691:  r_list_append (ret, r_bin_field_new (addr, addr, siz, nam, sdb_fmt (\"0x%08x\", val), fmt));",
          "692:  ut64 addr = 128;",
          "694:  struct PE_(r_bin_pe_obj_t) * bin = bf->o->bin_obj;",
          "695:  ROWL (\"Signature\", 4, bin->nt_headers->Signature, \"x\"); addr += 4;",
          "696:  ROWL (\"Machine\", 2, bin->nt_headers->file_header.Machine, \"x\"); addr += 2;",
          "697:  ROWL (\"NumberOfSections\", 2, bin->nt_headers->file_header.NumberOfSections, \"x\"); addr += 2;",
          "698:  ROWL (\"TimeDateStamp\", 4, bin->nt_headers->file_header.TimeDateStamp, \"x\"); addr += 4;",
          "699:  ROWL (\"PointerToSymbolTable\", 4, bin->nt_headers->file_header.PointerToSymbolTable, \"x\"); addr += 4;",
          "700:  ROWL (\"NumberOfSymbols \", 4, bin->nt_headers->file_header.NumberOfSymbols, \"x\"); addr += 4;",
          "701:  ROWL (\"SizeOfOptionalHeader\", 2, bin->nt_headers->file_header.SizeOfOptionalHeader, \"x\"); addr += 2;",
          "702:  ROWL (\"Characteristics\", 2, bin->nt_headers->file_header.Characteristics, \"x\"); addr += 2;",
          "703:  ROWL (\"Magic\", 2, bin->nt_headers->optional_header.Magic, \"x\"); addr += 2;",
          "704:  ROWL (\"MajorLinkerVersion\", 1, bin->nt_headers->optional_header.MajorLinkerVersion, \"x\"); addr += 1;",
          "705:  ROWL (\"MinorLinkerVersion\", 1, bin->nt_headers->optional_header.MinorLinkerVersion, \"x\"); addr += 1;",
          "706:  ROWL (\"SizeOfCode\", 4, bin->nt_headers->optional_header.SizeOfCode, \"x\"); addr += 4;",
          "707:  ROWL (\"SizeOfInitializedData\", 4, bin->nt_headers->optional_header.SizeOfInitializedData, \"x\"); addr += 4;",
          "708:  ROWL (\"SizeOfUninitializedData\", 4, bin->nt_headers->optional_header.SizeOfUninitializedData, \"x\"); addr += 4;",
          "709:  ROWL (\"AddressOfEntryPoint\", 4, bin->nt_headers->optional_header.AddressOfEntryPoint, \"x\"); addr += 4;",
          "710:  ROWL (\"BaseOfCode\", 4, bin->nt_headers->optional_header.BaseOfCode, \"x\"); addr += 4;",
          "711:  ROWL (\"BaseOfData\", 4, bin->nt_headers->optional_header.BaseOfData, \"x\"); addr += 4;",
          "712:  ROWL (\"ImageBase\", 4, bin->nt_headers->optional_header.ImageBase, \"x\"); addr += 4;",
          "713:  ROWL (\"SectionAlignment\", 4, bin->nt_headers->optional_header.SectionAlignment, \"x\"); addr += 4;",
          "714:  ROWL (\"FileAlignment\", 4, bin->nt_headers->optional_header.FileAlignment, \"x\"); addr += 4;",
          "715:  ROWL (\"MajorOperatingSystemVersion\", 2, bin->nt_headers->optional_header.MajorOperatingSystemVersion, \"x\"); addr += 2;",
          "716:  ROWL (\"MinorOperatingSystemVersion\", 2, bin->nt_headers->optional_header.MinorOperatingSystemVersion, \"x\"); addr += 2;",
          "717:  ROWL (\"MajorImageVersion\", 2, bin->nt_headers->optional_header.MajorImageVersion, \"x\"); addr += 2;",
          "718:  ROWL (\"MinorImageVersion\", 2, bin->nt_headers->optional_header.MinorImageVersion, \"x\"); addr += 2;",
          "719:  ROWL (\"MajorSubsystemVersion\", 2, bin->nt_headers->optional_header.MajorSubsystemVersion, \"x\"); addr += 2;",
          "720:  ROWL (\"MinorSubsystemVersion\", 2, bin->nt_headers->optional_header.MinorSubsystemVersion, \"x\"); addr += 2;",
          "721:  ROWL (\"Win32VersionValue\", 4, bin->nt_headers->optional_header.Win32VersionValue, \"x\"); addr += 4;",
          "722:  ROWL (\"SizeOfImage\", 4, bin->nt_headers->optional_header.SizeOfImage, \"x\"); addr += 4;",
          "723:  ROWL (\"SizeOfHeaders\", 4, bin->nt_headers->optional_header.SizeOfHeaders, \"x\"); addr += 4;",
          "724:  ROWL (\"CheckSum\", 4, bin->nt_headers->optional_header.CheckSum, \"x\"); addr += 4;",
          "725:  ROWL (\"Subsystem\",24, bin->nt_headers->optional_header.Subsystem, \"x\"); addr += 2;",
          "726:  ROWL (\"DllCharacteristics\", 2, bin->nt_headers->optional_header.DllCharacteristics, \"x\"); addr += 2;",
          "727:  ROWL (\"SizeOfStackReserve\", 4, bin->nt_headers->optional_header.SizeOfStackReserve, \"x\"); addr += 4;",
          "728:  ROWL (\"SizeOfStackCommit\", 4, bin->nt_headers->optional_header.SizeOfStackCommit, \"x\"); addr += 4;",
          "729:  ROWL (\"SizeOfHeapReserve\", 4, bin->nt_headers->optional_header.SizeOfHeapReserve, \"x\"); addr += 4;",
          "730:  ROWL (\"SizeOfHeapCommit\", 4, bin->nt_headers->optional_header.SizeOfHeapCommit, \"x\"); addr += 4;",
          "731:  ROWL (\"LoaderFlags\", 4, bin->nt_headers->optional_header.LoaderFlags, \"x\"); addr += 4;",
          "732:  ROWL (\"NumberOfRvaAndSizes\", 4, bin->nt_headers->optional_header.NumberOfRvaAndSizes, \"x\"); addr += 4;",
          "734:  int i;",
          "735:  ut64 tmp = addr;",
          "736:  for (i = 0; i < PE_IMAGE_DIRECTORY_ENTRIES - 1; i++) {",
          "737:   if (bin->nt_headers->optional_header.DataDirectory[i].Size > 0) {",
          "738:    addr = tmp + i*8;",
          "739:    switch (i) {",
          "740:    case PE_IMAGE_DIRECTORY_ENTRY_EXPORT:",
          "741:     ROWL (\"IMAGE_DIRECTORY_ENTRY_EXPORT\", 4, \\",
          "742:     bin->nt_headers->optional_header.DataDirectory[i].VirtualAddress, \"x\");",
          "743:     addr += 4;",
          "744:     ROWL (\"SIZE_IMAGE_DIRECTORY_ENTRY_EXPORT\", 4, \\",
          "745:     bin->nt_headers->optional_header.DataDirectory[i].Size, \"x\");",
          "746:     break;",
          "747:    case PE_IMAGE_DIRECTORY_ENTRY_IMPORT:",
          "748:     ROWL (\"IMAGE_DIRECTORY_ENTRY_IMPORT\", 4, \\",
          "749:     bin->nt_headers->optional_header.DataDirectory[i].VirtualAddress, \"x\");",
          "750:     addr += 4;",
          "751:     ROWL (\"SIZE_IMAGE_DIRECTORY_ENTRY_IMPORT\", 4, \\",
          "752:     bin->nt_headers->optional_header.DataDirectory[i].Size, \"x\");",
          "753:     break;",
          "754:    case PE_IMAGE_DIRECTORY_ENTRY_RESOURCE:",
          "755:     ROWL (\"IMAGE_DIRECTORY_ENTRY_RESOURCE\", 4, \\",
          "756:     bin->nt_headers->optional_header.DataDirectory[i].VirtualAddress, \"x\");",
          "757:     addr += 4;",
          "758:     ROWL (\"SIZE_IMAGE_DIRECTORY_ENTRY_RESOURCE\", 4, \\",
          "759:     bin->nt_headers->optional_header.DataDirectory[i].Size, \"x\");",
          "760:     break;",
          "761:    case PE_IMAGE_DIRECTORY_ENTRY_EXCEPTION:",
          "762:     ROWL (\"IMAGE_DIRECTORY_ENTRY_EXCEPTION\", 4, \\",
          "763:     bin->nt_headers->optional_header.DataDirectory[i].VirtualAddress, \"x\");",
          "764:     addr += 4;",
          "765:     ROWL (\"SIZE_IMAGE_DIRECTORY_ENTRY_EXCEPTION\", 4, \\",
          "766:     bin->nt_headers->optional_header.DataDirectory[i].Size, \"x\");",
          "767:     break;",
          "768:    case PE_IMAGE_DIRECTORY_ENTRY_SECURITY:",
          "769:     ROWL (\"IMAGE_DIRECTORY_ENTRY_SECURITY\", 4, \\",
          "770:     bin->nt_headers->optional_header.DataDirectory[i].VirtualAddress, \"x\");",
          "771:     addr += 4;",
          "772:     ROWL (\"SIZE_IMAGE_DIRECTORY_ENTRY_SECURITY\", 4, \\",
          "773:     bin->nt_headers->optional_header.DataDirectory[i].Size, \"x\");",
          "774:     break;",
          "775:    case PE_IMAGE_DIRECTORY_ENTRY_BASERELOC:",
          "776:     ROWL (\"IMAGE_DIRECTORY_ENTRY_BASERELOC\", 4, \\",
          "777:     bin->nt_headers->optional_header.DataDirectory[i].VirtualAddress, \"x\");",
          "778:     addr += 4;",
          "779:     ROWL (\"SIZE_IMAGE_DIRECTORY_ENTRY_BASERELOC\", 4, \\",
          "780:     bin->nt_headers->optional_header.DataDirectory[i].Size, \"x\");",
          "781:     break;",
          "782:    case PE_IMAGE_DIRECTORY_ENTRY_DEBUG:",
          "783:     ROWL (\"IMAGE_DIRECTORY_ENTRY_DEBUG\", 4, \\",
          "784:     bin->nt_headers->optional_header.DataDirectory[i].VirtualAddress, \"x\");",
          "785:     addr += 4;",
          "786:     ROWL (\"SIZE_IMAGE_DIRECTORY_ENTRY_DEBUG\", 4, \\",
          "787:     bin->nt_headers->optional_header.DataDirectory[i].Size, \"x\");",
          "788:     break;",
          "789:    case PE_IMAGE_DIRECTORY_ENTRY_COPYRIGHT:",
          "790:     ROWL (\"IMAGE_DIRECTORY_ENTRY_COPYRIGHT\", 4, \\",
          "791:     bin->nt_headers->optional_header.DataDirectory[i].VirtualAddress, \"x\");",
          "792:     addr += 4;",
          "793:     ROWL (\"SIZE_IMAGE_DIRECTORY_ENTRY_COPYRIGHT\", 4, \\",
          "794:     bin->nt_headers->optional_header.DataDirectory[i].Size, \"x\");",
          "795:     break;",
          "796:    case PE_IMAGE_DIRECTORY_ENTRY_GLOBALPTR:",
          "797:     ROWL (\"IMAGE_DIRECTORY_ENTRY_GLOBALPTR\", 4, \\",
          "798:     bin->nt_headers->optional_header.DataDirectory[i].VirtualAddress, \"x\");",
          "799:     addr += 4;",
          "800:     ROWL (\"SIZE_IMAGE_DIRECTORY_ENTRY_GLOBALPTR\", 4, \\",
          "801:     bin->nt_headers->optional_header.DataDirectory[i].Size, \"x\");",
          "802:     break;",
          "803:    case PE_IMAGE_DIRECTORY_ENTRY_TLS:",
          "804:     ROWL (\"IMAGE_DIRECTORY_ENTRY_TLS\", 4, \\",
          "805:     bin->nt_headers->optional_header.DataDirectory[i].VirtualAddress, \"x\");",
          "806:     addr += 4;",
          "807:     ROWL (\"SIZE_IMAGE_DIRECTORY_ENTRY_TLS\", 4, \\",
          "808:     bin->nt_headers->optional_header.DataDirectory[i].Size, \"x\");",
          "809:     break;",
          "810:    case PE_IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG:",
          "811:     ROWL (\"IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG\", 4, \\",
          "812:     bin->nt_headers->optional_header.DataDirectory[i].VirtualAddress, \"x\");",
          "813:     addr += 4;",
          "814:     ROWL (\"SIZE_IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG\", 4, \\",
          "815:     bin->nt_headers->optional_header.DataDirectory[i].Size, \"x\");",
          "816:     break;",
          "817:    case PE_IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT:",
          "818:     ROWL (\"IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT\", 4, \\",
          "819:     bin->nt_headers->optional_header.DataDirectory[i].VirtualAddress, \"x\");",
          "820:     addr += 4;",
          "821:     ROWL (\"SIZE_IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT\", 4, \\",
          "822:     bin->nt_headers->optional_header.DataDirectory[i].Size, \"x\");",
          "823:     break;",
          "824:    case PE_IMAGE_DIRECTORY_ENTRY_IAT:",
          "825:     ROWL (\"IMAGE_DIRECTORY_ENTRY_IAT\", 4, \\",
          "826:     bin->nt_headers->optional_header.DataDirectory[i].VirtualAddress, \"x\");",
          "827:     addr += 4;",
          "828:     ROWL (\"SIZE_IMAGE_DIRECTORY_ENTRY_IAT\", 4, \\",
          "829:     bin->nt_headers->optional_header.DataDirectory[i].Size, \"x\");",
          "830:     break;",
          "831:    case PE_IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT:",
          "832:     ROWL (\"IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT\", 4, \\",
          "833:     bin->nt_headers->optional_header.DataDirectory[i].VirtualAddress, \"x\");",
          "834:     addr += 4;",
          "835:     ROWL (\"SIZE_IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT\", 4, \\",
          "836:     bin->nt_headers->optional_header.DataDirectory[i].Size, \"x\");",
          "837:     break;",
          "838:    case PE_IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR:",
          "839:     ROWL (\"IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR\", 4, \\",
          "840:     bin->nt_headers->optional_header.DataDirectory[i].VirtualAddress, \"x\");",
          "841:     addr += 4;",
          "842:     ROWL (\"SIZE_IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR\", 4, \\",
          "843:     bin->nt_headers->optional_header.DataDirectory[i].Size, \"x\");",
          "844:     break;",
          "845:    }",
          "846:   }",
          "847:  }",
          "849:  return ret;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "855faff5f436adf41166cc22c9f2b0f261f7ca6c",
      "candidate_info": {
        "commit_hash": "855faff5f436adf41166cc22c9f2b0f261f7ca6c",
        "repo": "radare/radare2",
        "commit_url": "https://github.com/radare/radare2/commit/855faff5f436adf41166cc22c9f2b0f261f7ca6c",
        "files": [
          "libr/bin/p/bin_elf.c"
        ],
        "message": "Added clarifying comment",
        "before_after_code_files": [
          "libr/bin/p/bin_elf.c||libr/bin/p/bin_elf.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libr/bin/p/bin_elf.c||libr/bin/p/bin_elf.c"
          ],
          "candidate": [
            "libr/bin/p/bin_elf.c||libr/bin/p/bin_elf.c"
          ]
        }
      },
      "candidate_diff": {
        "libr/bin/p/bin_elf.c||libr/bin/p/bin_elf.c": [
          "File: libr/bin/p/bin_elf.c -> libr/bin/p/bin_elf.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "390:  }",
          "391:  ptr->paddr = Elf_(r_bin_elf_get_entry_offset) (obj);",
          "392:  ptr->vaddr = Elf_(r_bin_elf_p2v) (obj, ptr->paddr);",
          "395:  if (obj->ehdr.e_machine == EM_ARM) {",
          "396:   int bin_bits = Elf_(r_bin_elf_get_bits) (obj);",
          "",
          "[Removed Lines]",
          "393:  ptr->hpaddr = 0x18;",
          "",
          "[Added Lines]",
          "393:  ptr->hpaddr = 0x18;  // e_entry offset",
          "",
          "---------------"
        ]
      }
    }
  ]
}
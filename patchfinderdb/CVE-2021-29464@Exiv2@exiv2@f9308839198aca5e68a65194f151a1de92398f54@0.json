{
  "cve_id": "CVE-2021-29464",
  "cve_desc": "Exiv2 is a command-line utility and C++ library for reading, writing, deleting, and modifying the metadata of image files. A heap buffer overflow was found in Exiv2 versions v0.27.3 and earlier. The heap overflow is triggered when Exiv2 is used to write metadata into a crafted image file. An attacker could potentially exploit the vulnerability to gain code execution, if they can trick the victim into running Exiv2 on a crafted image file. Note that this bug is only triggered when writing the metadata, which is a less frequently used Exiv2 operation than reading the metadata. For example, to trigger the bug in the Exiv2 command-line application, you need to add an extra command-line argument such as `insert`. The bug is fixed in version v0.27.4.",
  "repo": "Exiv2/exiv2",
  "patch_hash": "f9308839198aca5e68a65194f151a1de92398f54",
  "patch_info": {
    "commit_hash": "f9308839198aca5e68a65194f151a1de92398f54",
    "repo": "Exiv2/exiv2",
    "commit_url": "https://github.com/Exiv2/exiv2/commit/f9308839198aca5e68a65194f151a1de92398f54",
    "files": [
      "src/jp2image.cpp"
    ],
    "message": "Better bounds checking in Jp2Image::encodeJp2Header()",
    "before_after_code_files": [
      "src/jp2image.cpp||src/jp2image.cpp"
    ]
  },
  "patch_diff": {
    "src/jp2image.cpp||src/jp2image.cpp": [
      "File: src/jp2image.cpp -> src/jp2image.cpp",
      "--- Hunk 1 ---",
      "[Context before]",
      "646:     void Jp2Image::encodeJp2Header(const DataBuf& boxBuf,DataBuf& outBuf)",
      "647:     {",
      "648:         DataBuf output(boxBuf.size_ + iccProfile_.size_ + 100); // allocate sufficient space",
      "651:         Jp2BoxHeader* pBox   = (Jp2BoxHeader*) boxBuf.pData_;",
      "654:         char*         p      = (char*) boxBuf.pData_;",
      "655:         bool          bWroteColor = false ;",
      "",
      "[Removed Lines]",
      "649:         int     outlen = sizeof(Jp2BoxHeader) ; // now many bytes have we written to output?",
      "650:         int      inlen = sizeof(Jp2BoxHeader) ; // how many bytes have we read from boxBuf?",
      "652:         int32_t       length = getLong((byte*)&pBox->length, bigEndian);",
      "653:         int32_t       count  = sizeof (Jp2BoxHeader);",
      "",
      "[Added Lines]",
      "649:         long    outlen = sizeof(Jp2BoxHeader) ; // now many bytes have we written to output?",
      "650:         long    inlen = sizeof(Jp2BoxHeader) ; // how many bytes have we read from boxBuf?",
      "652:         uint32_t      length = getLong((byte*)&pBox->length, bigEndian);",
      "653:         uint32_t      count  = sizeof (Jp2BoxHeader);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "667: #ifdef EXIV2_DEBUG_MESSAGES",
      "668:                 std::cout << \"Jp2Image::encodeJp2Header subbox: \"<< toAscii(subBox.type) << \" length = \" << subBox.length << std::endl;",
      "669: #endif",
      "670:                 count        += subBox.length;",
      "671:                 newBox.type   = subBox.type;",
      "672:             } else {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "670:                 enforce(subBox.length <= length - count, Exiv2::kerCorruptedMetadata);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "675:                 count = length;",
      "676:             }",
      "679:             if ( newBox.type == kJp2BoxTypeColorHeader ) {",
      "680:                 bWroteColor = true ;",
      "681:                 if ( ! iccProfileDefined() ) {",
      "682:                     const char* pad   = \"\\x01\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x05\\x1cuuid\";",
      "683:                     uint32_t    psize = 15;",
      "684:                     newlen            = sizeof(newBox) + psize ;",
      "685:                     ul2Data((byte*)&newBox.length,psize      ,bigEndian);",
      "686:                     ul2Data((byte*)&newBox.type  ,newBox.type,bigEndian);",
      "687:                     ::memcpy(output.pData_+outlen                     ,&newBox            ,sizeof(newBox));",
      "",
      "[Removed Lines]",
      "678:             int32_t newlen = subBox.length;",
      "",
      "[Added Lines]",
      "679:             uint32_t newlen = subBox.length;",
      "686:                     enforce(newlen <= output.size_ - outlen, Exiv2::kerCorruptedMetadata);",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "690:                     const char* pad   = \"\\x02\\x00\\x00\";",
      "691:                     uint32_t    psize = 3;",
      "692:                     newlen            = sizeof(newBox) + psize + iccProfile_.size_;",
      "693:                     ul2Data((byte*)&newBox.length,newlen,bigEndian);",
      "694:                     ul2Data((byte*)&newBox.type,newBox.type,bigEndian);",
      "695:                     ::memcpy(output.pData_+outlen                     ,&newBox            ,sizeof(newBox)  );",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "695:                     enforce(newlen <= output.size_ - outlen, Exiv2::kerCorruptedMetadata);",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "697:                     ::memcpy(output.pData_+outlen+sizeof(newBox)+psize,iccProfile_.pData_,iccProfile_.size_);",
      "698:                 }",
      "699:             } else {",
      "700:                 ::memcpy(output.pData_+outlen,boxBuf.pData_+inlen,subBox.length);",
      "701:             }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "703:                 enforce(newlen <= output.size_ - outlen, Exiv2::kerCorruptedMetadata);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "e1686ebc3893db3b5a3b9842e8b047473dde5b72",
      "candidate_info": {
        "commit_hash": "e1686ebc3893db3b5a3b9842e8b047473dde5b72",
        "repo": "Exiv2/exiv2",
        "commit_url": "https://github.com/Exiv2/exiv2/commit/e1686ebc3893db3b5a3b9842e8b047473dde5b72",
        "files": [
          "test/data/issue_ghsa_jgm9_5fw5_pw9p_poc.exv",
          "test/data/issue_ghsa_jgm9_5fw5_pw9p_poc.jp2",
          "tests/bugfixes/github/test_issue_ghsa_jgm9_5fw5_pw9p.py"
        ],
        "message": "Regression test for https://github.com/Exiv2/exiv2/security/advisories/GHSA-jgm9-5fw5-pw9p",
        "before_after_code_files": [
          "tests/bugfixes/github/test_issue_ghsa_jgm9_5fw5_pw9p.py||tests/bugfixes/githutest_issue_ghsa_jgm9_5fw5_pw9p.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/Exiv2/exiv2/pull/1578"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "tests/bugfixes/github/test_issue_ghsa_jgm9_5fw5_pw9p.py||tests/bugfixes/githutest_issue_ghsa_jgm9_5fw5_pw9p.py": [
          "File: tests/bugfixes/github/test_issue_ghsa_jgm9_5fw5_pw9p.py -> tests/bugfixes/githutest_issue_ghsa_jgm9_5fw5_pw9p.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "941017d281733991a9aed1a3dd4d8d674cfd48c2",
      "candidate_info": {
        "commit_hash": "941017d281733991a9aed1a3dd4d8d674cfd48c2",
        "repo": "Exiv2/exiv2",
        "commit_url": "https://github.com/Exiv2/exiv2/commit/941017d281733991a9aed1a3dd4d8d674cfd48c2",
        "files": [
          "src/bmffimage.cpp",
          "src/datasets.cpp",
          "src/jp2image.cpp",
          "src/properties.cpp",
          "src/tags.cpp",
          "tests/bash_tests/testcases.py"
        ],
        "message": "Fix issues on ARM builds (#2205)\n\n* Specify base class initialization in Copy Constructor\n\n* Fix printing of uint64_t variable in ARM 32bits\n\nUse cinttypes\n\n* Fix alignment issues on ARM 32 bits\n\n* tests: add assertion with custom message",
        "before_after_code_files": [
          "src/bmffimage.cpp||src/bmffimage.cpp",
          "src/datasets.cpp||src/datasets.cpp",
          "src/jp2image.cpp||src/jp2image.cpp",
          "src/properties.cpp||src/properties.cpp",
          "src/tags.cpp||src/tags.cpp",
          "tests/bash_tests/testcases.py||tests/bash_tests/testcases.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/jp2image.cpp||src/jp2image.cpp"
          ],
          "candidate": [
            "src/jp2image.cpp||src/jp2image.cpp"
          ]
        }
      },
      "candidate_diff": {
        "src/bmffimage.cpp||src/bmffimage.cpp": [
          "File: src/bmffimage.cpp -> src/bmffimage.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "16: #include \"types.hpp\"",
          "19: #include <cstdio>",
          "20: #include <cstring>",
          "21: #include <iostream>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "19: #include <cinttypes>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "184:   if (bTrace) {",
          "185:     bLF = true;",
          "186:     out << indent(depth) << \"Exiv2::BmffImage::boxHandler: \" << toAscii(box_type)",
          "188:   }",
          "190:   if (box_length == 1) {",
          "",
          "[Removed Lines]",
          "187:         << Internal::stringFormat(\" %8ld->%lu \", address, box_length);",
          "",
          "[Added Lines]",
          "188:         << Internal::stringFormat(\" %8ld->%\" PRIu64 \" \", address, box_length);",
          "",
          "---------------"
        ],
        "src/datasets.cpp||src/datasets.cpp": [
          "File: src/datasets.cpp -> src/datasets.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "508:   makeKey();",
          "509: }",
          "512: }",
          "514: std::string IptcKey::key() const {",
          "",
          "[Removed Lines]",
          "511: IptcKey::IptcKey(const IptcKey& rhs) : tag_(rhs.tag_), record_(rhs.record_), key_(rhs.key_) {",
          "",
          "[Added Lines]",
          "511: IptcKey::IptcKey(const IptcKey& rhs) : Key(), tag_(rhs.tag_), record_(rhs.record_), key_(rhs.key_) {",
          "",
          "---------------"
        ],
        "src/jp2image.cpp||src/jp2image.cpp": [
          "File: src/jp2image.cpp -> src/jp2image.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "604:   size_t outlen = boxHSize;                                  // now many bytes have we written to output?",
          "605:   size_t inlen = boxHSize;                                   // how many bytes have we read from boxBuf?",
          "606:   enforce(boxHSize <= output.size(), ErrorCode::kerCorruptedMetadata);",
          "609:   enforce(length <= output.size(), ErrorCode::kerCorruptedMetadata);",
          "610:   uint32_t count = boxHSize;",
          "612:   bool bWroteColor = false;",
          "614:   while (count < length && !bWroteColor) {",
          "615:     enforce(boxHSize <= length - count, ErrorCode::kerCorruptedMetadata);",
          "619:     Internal::Jp2BoxHeader subBox;",
          "621:     Internal::Jp2BoxHeader newBox = subBox;",
          "623:     if (count < length) {",
          "626: #ifdef EXIV2_DEBUG_MESSAGES",
          "627:       std::cout << \"Jp2Image::encodeJp2Header subbox: \" << toAscii(subBox.type) << \" length = \" << subBox.length",
          "628:                 << std::endl;",
          "",
          "[Removed Lines]",
          "607:   auto pBox = reinterpret_cast<const Internal::Jp2BoxHeader*>(boxBuf.c_data());",
          "608:   uint32_t length = getLong(reinterpret_cast<const byte*>(&pBox->length), bigEndian);",
          "611:   auto p = boxBuf.c_str();",
          "616:     auto pSubBox = reinterpret_cast<const Internal::Jp2BoxHeader*>(p + count);",
          "620:     memcpy(&subBox, pSubBox, boxHSize);",
          "624:       subBox.length = getLong(reinterpret_cast<byte*>(&subBox.length), bigEndian);",
          "625:       subBox.type = getLong(reinterpret_cast<byte*>(&subBox.type), bigEndian);",
          "",
          "[Added Lines]",
          "607:   uint32_t length = getLong(boxBuf.c_data(0), bigEndian);",
          "615:     memcpy(&subBox, boxBuf.c_data(count), boxHSize);",
          "619:       subBox.length = getLong(boxBuf.c_data(count), bigEndian);",
          "620:       subBox.type = getLong(boxBuf.c_data(count + 4), bigEndian);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "672:   outBuf.alloc(outlen);",
          "673:   std::copy_n(output.c_data(), outlen, outBuf.begin());",
          "677: }",
          "679: #ifdef __clang__",
          "",
          "[Removed Lines]",
          "674:   auto oBox = reinterpret_cast<Internal::Jp2BoxHeader*>(outBuf.data());",
          "675:   ul2Data(reinterpret_cast<byte*>(&oBox->type), kJp2BoxTypeHeader, bigEndian);",
          "676:   ul2Data(reinterpret_cast<byte*>(&oBox->length), static_cast<uint32_t>(outlen), bigEndian);",
          "",
          "[Added Lines]",
          "669:   ul2Data(outBuf.data(0), static_cast<uint32_t>(outlen), bigEndian);",
          "670:   ul2Data(outBuf.data(4), kJp2BoxTypeHeader, bigEndian);",
          "",
          "---------------"
        ],
        "src/properties.cpp||src/properties.cpp": [
          "File: src/properties.cpp -> src/properties.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "5098: XmpKey::~XmpKey() = default;",
          "5101: }",
          "5103: XmpKey& XmpKey::operator=(const XmpKey& rhs) {",
          "",
          "[Removed Lines]",
          "5100: XmpKey::XmpKey(const XmpKey& rhs) : p_(std::make_unique<Impl>(*rhs.p_)) {",
          "",
          "[Added Lines]",
          "5100: XmpKey::XmpKey(const XmpKey& rhs) : Key(), p_(std::make_unique<Impl>(*rhs.p_)) {",
          "",
          "---------------"
        ],
        "src/tags.cpp||src/tags.cpp": [
          "File: src/tags.cpp -> src/tags.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "266:   p_->decomposeKey(key);",
          "267: }",
          "270: }",
          "272: ExifKey::~ExifKey() = default;",
          "",
          "[Removed Lines]",
          "269: ExifKey::ExifKey(const ExifKey& rhs) : p_(std::make_unique<Impl>(*rhs.p_)) {",
          "",
          "[Added Lines]",
          "269: ExifKey::ExifKey(const ExifKey& rhs) : Key(), p_(std::make_unique<Impl>(*rhs.p_)) {",
          "",
          "---------------"
        ],
        "tests/bash_tests/testcases.py||tests/bash_tests/testcases.py": [
          "File: tests/bash_tests/testcases.py -> tests/bash_tests/testcases.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "484:             BT.copyTestFile('large.icc', iccname)",
          "485:             out      += BT.Executer('exiv2 -iC          {img}', vars())",
          "486:             e         = BT.Executer('exiv2 -pC          {img}', vars(), compatible_output=False, decode_output=False)",
          "487:             BT.save(e.stdout, stub + '_large_1.icc')",
          "488:             out      += BT.Executer('exiv2 -pS          {img}', vars())",
          "489:             out      += BT.Executer('exiv2 -eC --force  {img}', vars())",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "487:             self.assertIsNotNone(e.stdout, msg=\"Empty ICC profile in {}\".format(img))",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "d30c95d07e647535f4c9fe6fe4a559e978d25891",
      "candidate_info": {
        "commit_hash": "d30c95d07e647535f4c9fe6fe4a559e978d25891",
        "repo": "Exiv2/exiv2",
        "commit_url": "https://github.com/Exiv2/exiv2/commit/d30c95d07e647535f4c9fe6fe4a559e978d25891",
        "files": [
          "src/jp2image.cpp",
          "test/data/issue_ghsa_mxw9_qx4c_6m8v_poc.jp2",
          "tests/bugfixes/github/test_issue_ghsa_8949_hhfh_j7rj.py",
          "tests/bugfixes/github/test_issue_ghsa_mxw9_qx4c_6m8v.py"
        ],
        "message": "fix incorrect loop condition (#1752)",
        "before_after_code_files": [
          "src/jp2image.cpp||src/jp2image.cpp",
          "tests/bugfixes/github/test_issue_ghsa_8949_hhfh_j7rj.py||tests/bugfixes/githutest_issue_ghsa_8949_hhfh_j7rj.py",
          "tests/bugfixes/github/test_issue_ghsa_mxw9_qx4c_6m8v.py||tests/bugfixes/githutest_issue_ghsa_mxw9_qx4c_6m8v.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/jp2image.cpp||src/jp2image.cpp"
          ],
          "candidate": [
            "src/jp2image.cpp||src/jp2image.cpp"
          ]
        }
      },
      "candidate_diff": {
        "src/jp2image.cpp||src/jp2image.cpp": [
          "File: src/jp2image.cpp -> src/jp2image.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "655:         auto p = reinterpret_cast<char*>(boxBuf.pData_);",
          "656:         bool          bWroteColor = false ;",
          "659:             enforce(sizeof(Jp2BoxHeader) <= length - count, Exiv2::kerCorruptedMetadata);",
          "660:             auto pSubBox = reinterpret_cast<Jp2BoxHeader*>(p + count);",
          "",
          "[Removed Lines]",
          "658:         while ( count < length || !bWroteColor ) {",
          "",
          "[Added Lines]",
          "658:         while ( count < length && !bWroteColor ) {",
          "",
          "---------------"
        ],
        "tests/bugfixes/github/test_issue_ghsa_8949_hhfh_j7rj.py||tests/bugfixes/githutest_issue_ghsa_8949_hhfh_j7rj.py": [
          "File: tests/bugfixes/github/test_issue_ghsa_8949_hhfh_j7rj.py -> tests/bugfixes/githutest_issue_ghsa_8949_hhfh_j7rj.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: # -*- coding: utf-8 -*-",
          "6: class Jp2ImageEncodeJp2HeaderOutOfBoundsRead(metaclass=CaseMeta):",
          "7:     \"\"\"",
          "",
          "[Removed Lines]",
          "3: from system_tests import CaseMeta, path",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "10:     \"\"\"",
          "11:     url = \"https://github.com/Exiv2/exiv2/security/advisories/GHSA-8949-hhfh-j7rj\"",
          "15:     commands = [\"$exiv2 in $filename1\"]",
          "16:     stdout = [\"\"]",
          "17:     stderr = [",
          "18: \"\"\"Error: XMP Toolkit error 201: XML parsing failure",
          "19: Warning: Failed to decode XMP metadata.",
          "21: \"\"\"]",
          "",
          "[Removed Lines]",
          "13:     filename1 = path(\"$data_path/issue_ghsa_8949_hhfh_j7rj_poc.jp2\")",
          "14:     filename2 = path(\"$data_path/issue_ghsa_8949_hhfh_j7rj_poc.exv\")",
          "20: $filename1: Could not write metadata to file: $kerCorruptedMetadata",
          "22:     retval = [1]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "tests/bugfixes/github/test_issue_ghsa_mxw9_qx4c_6m8v.py||tests/bugfixes/githutest_issue_ghsa_mxw9_qx4c_6m8v.py": [
          "File: tests/bugfixes/github/test_issue_ghsa_mxw9_qx4c_6m8v.py -> tests/bugfixes/githutest_issue_ghsa_mxw9_qx4c_6m8v.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "e7478f744d91f6fe59166271b4c9e3629cc1a93a",
      "candidate_info": {
        "commit_hash": "e7478f744d91f6fe59166271b4c9e3629cc1a93a",
        "repo": "Exiv2/exiv2",
        "commit_url": "https://github.com/Exiv2/exiv2/commit/e7478f744d91f6fe59166271b4c9e3629cc1a93a",
        "files": [
          "src/jp2image.cpp",
          "test/data/test_reference_files/icc-test.out"
        ],
        "message": "Jp2Image: Implement more checks from JP2 standard + fix bug\n\n- add debug info when parsing Signature box\n- Move definitions & static stuff to anonymous namespace\n- cleanup while studying code\n- Make exceptions more similar to other formats",
        "before_after_code_files": [
          "src/jp2image.cpp||src/jp2image.cpp"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/jp2image.cpp||src/jp2image.cpp"
          ],
          "candidate": [
            "src/jp2image.cpp||src/jp2image.cpp"
          ]
        }
      },
      "candidate_diff": {
        "src/jp2image.cpp||src/jp2image.cpp": [
          "File: src/jp2image.cpp -> src/jp2image.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "17: #include <array>",
          "18: #include <iostream>",
          "63:     0x00, 0x00, 0x00, 0x0c, 0x6a, 0x50, 0x20, 0x20, 0x0d, 0x0a, 0x87, 0x0a,",
          "64: };",
          "67:     0x00, 0x00, 0x00, 0x0c, 0x6a, 0x50, 0x20, 0x20, 0x0d, 0x0a, 0x87, 0x0a, 0x00, 0x00, 0x00, 0x14, 0x66, 0x74,",
          "68:     0x79, 0x70, 0x6a, 0x70, 0x32, 0x20, 0x00, 0x00, 0x00, 0x00, 0x6a, 0x70, 0x32, 0x20, 0x00, 0x00, 0x00, 0x2d,",
          "69:     0x6a, 0x70, 0x32, 0x68, 0x00, 0x00, 0x00, 0x16, 0x69, 0x68, 0x64, 0x72, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,",
          "",
          "[Removed Lines]",
          "21: static constexpr uint32_t kJp2BoxTypeJp2Header = 0x6a703268;    // 'jp2h'",
          "22: static constexpr uint32_t kJp2BoxTypeImageHeader = 0x69686472;  // 'ihdr'",
          "23: static constexpr uint32_t kJp2BoxTypeColorHeader = 0x636f6c72;  // 'colr'",
          "24: static constexpr uint32_t kJp2BoxTypeUuid = 0x75756964;         // 'uuid'",
          "25: static constexpr uint32_t kJp2BoxTypeClose = 0x6a703263;        // 'jp2c'",
          "57: static constexpr unsigned char kJp2UuidExif[] = \"JpgTiffExif->JP2\";",
          "58: static constexpr unsigned char kJp2UuidIptc[] = \"\\x33\\xc7\\xa4\\xd2\\xb8\\x1d\\x47\\x23\\xa0\\xba\\xf1\\xa3\\xe0\\x97\\xad\\x38\";",
          "59: static constexpr unsigned char kJp2UuidXmp[] = \"\\xbe\\x7a\\xcf\\xcb\\x97\\xa9\\x42\\xe8\\x9c\\x71\\x99\\x94\\x91\\xe3\\xaf\\xac\";",
          "62: static constexpr unsigned char Jp2Signature[] = {",
          "66: static constexpr unsigned char Jp2Blank[] = {",
          "",
          "[Added Lines]",
          "20: namespace Exiv2 {",
          "21: namespace {",
          "23: constexpr uint32_t kJp2BoxTypeSignature = 0x6a502020;    // signature box, required,",
          "24: constexpr uint32_t kJp2BoxTypeFileTypeBox = 0x66747970;  // File type box, required",
          "25: constexpr uint32_t kJp2BoxTypeHeader = 0x6a703268;       // Jp2 Header Box, required, Superbox",
          "26: constexpr uint32_t kJp2BoxTypeImageHeader = 0x69686472;  // Image Header Box ('ihdr'), required,",
          "27: constexpr uint32_t kJp2BoxTypeColorSpec = 0x636f6c72;    // Color Specification box ('colr'), required",
          "28: constexpr uint32_t kJp2BoxTypeUuid = 0x75756964;         // 'uuid'",
          "29: constexpr uint32_t kJp2BoxTypeClose = 0x6a703263;        // 'jp2c'",
          "31: const uint32_t brandJp2 = 0x6a703220;",
          "38: constexpr unsigned char kJp2UuidExif[] = \"JpgTiffExif->JP2\";",
          "39: constexpr unsigned char kJp2UuidIptc[] = \"\\x33\\xc7\\xa4\\xd2\\xb8\\x1d\\x47\\x23\\xa0\\xba\\xf1\\xa3\\xe0\\x97\\xad\\x38\";",
          "40: constexpr unsigned char kJp2UuidXmp[] = \"\\xbe\\x7a\\xcf\\xcb\\x97\\xa9\\x42\\xe8\\x9c\\x71\\x99\\x94\\x91\\xe3\\xaf\\xac\";",
          "43: constexpr unsigned char Jp2Signature[] = {",
          "47: constexpr unsigned char Jp2Blank[] = {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "90:   uint32_t imageHeight;",
          "91:   uint32_t imageWidth;",
          "92:   uint16_t componentCount;",
          "98: };",
          "100: struct Jp2UuidBox {",
          "101:   uint8_t uuid[16];",
          "102: };",
          "134:   if (bLF) {",
          "135:     out << std::endl;",
          "136:     out.flush();",
          "",
          "[Removed Lines]",
          "93:   uint8_t bitsPerComponent;",
          "94:   uint8_t compressionType;",
          "95:   uint8_t colorspaceIsUnknown;",
          "96:   uint8_t intellectualPropertyFlag;",
          "97:   uint16_t compressionTypeProfile;",
          "107: namespace Exiv2 {",
          "108: Jp2Image::Jp2Image(BasicIo::UniquePtr io, bool create) : Image(ImageType::jp2, mdExif | mdIptc | mdXmp, std::move(io)) {",
          "109:   if (create) {",
          "110:     if (io_->open() == 0) {",
          "111: #ifdef EXIV2_DEBUG_MESSAGES",
          "112:       std::cerr << \"Exiv2::Jp2Image:: Creating JPEG2000 image to memory\" << std::endl;",
          "113: #endif",
          "114:       IoCloser closer(*io_);",
          "115:       if (io_->write(Jp2Blank, sizeof(Jp2Blank)) != sizeof(Jp2Blank)) {",
          "116: #ifdef EXIV2_DEBUG_MESSAGES",
          "117:         std::cerr << \"Exiv2::Jp2Image:: Failed to create JPEG2000 image on memory\" << std::endl;",
          "118: #endif",
          "119:       }",
          "120:     }",
          "121:   }",
          "122: }  // Jp2Image::Jp2Image",
          "124: std::string Jp2Image::mimeType() const {",
          "125:   return \"image/jp2\";",
          "126: }",
          "128: void Jp2Image::setComment(std::string_view /*comment*/) {",
          "130:   throw(Error(ErrorCode::kerInvalidSettingForImage, \"Image comment\", \"JP2\"));",
          "131: }",
          "133: static void lf(std::ostream& out, bool& bLF) {",
          "",
          "[Added Lines]",
          "73:   uint8_t bpc;   //<! Bits per component",
          "74:   uint8_t c;     //<! Compression type",
          "75:   uint8_t unkC;  //<! Colourspace unknown",
          "76:   uint8_t ipr;   //<! Intellectual property",
          "83: const size_t boxHSize = sizeof(Jp2BoxHeader);",
          "85: void lf(std::ostream& out, bool& bLF) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "138:   }",
          "139: }",
          "142:   union {",
          "143:     uint32_t i;",
          "144:     char c[4];",
          "",
          "[Removed Lines]",
          "141: static bool isBigEndian() {",
          "",
          "[Added Lines]",
          "93: bool isBigEndian() {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "147:   return e.c[0] != 0;",
          "148: }",
          "151:   const auto p = reinterpret_cast<const char*>(&n);",
          "152:   std::string result;",
          "153:   bool bBigEndian = isBigEndian();",
          "",
          "[Removed Lines]",
          "150: static std::string toAscii(long n) {",
          "",
          "[Added Lines]",
          "103: std::string toAscii(long n) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "157:   return result;",
          "158: }",
          "161:   if (b > m) {",
          "162: #ifdef EXIV2_DEBUG_MESSAGES",
          "163:     std::cout << \"Exiv2::Jp2Image::readMetadata box maximum exceeded\" << std::endl;",
          "",
          "[Removed Lines]",
          "160: static void boxes_check(size_t b, size_t m) {",
          "",
          "[Added Lines]",
          "113: void boxes_check(size_t b, size_t m) {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "166:   }",
          "167: }",
          "169: void Jp2Image::readMetadata() {",
          "170: #ifdef EXIV2_DEBUG_MESSAGES",
          "171:   std::cerr << \"Exiv2::Jp2Image::readMetadata: Reading JPEG-2000 file \" << io_->path() << std::endl;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "122: }  // namespace",
          "124: Jp2Image::Jp2Image(BasicIo::UniquePtr io, bool create) : Image(ImageType::jp2, mdExif | mdIptc | mdXmp, std::move(io)) {",
          "125:   if (create) {",
          "126:     if (io_->open() == 0) {",
          "127: #ifdef EXIV2_DEBUG_MESSAGES",
          "128:       std::cerr << \"Exiv2::Jp2Image:: Creating JPEG2000 image to memory\" << std::endl;",
          "129: #endif",
          "130:       IoCloser closer(*io_);",
          "131:       if (io_->write(Jp2Blank, sizeof(Jp2Blank)) != sizeof(Jp2Blank)) {",
          "132: #ifdef EXIV2_DEBUG_MESSAGES",
          "133:         std::cerr << \"Exiv2::Jp2Image:: Failed to create JPEG2000 image on memory\" << std::endl;",
          "134: #endif",
          "135:       }",
          "136:     }",
          "137:   }",
          "138: }",
          "140: std::string Jp2Image::mimeType() const {",
          "141:   return \"image/jp2\";",
          "142: }",
          "144: void Jp2Image::setComment(std::string_view /*comment*/) {",
          "145:   throw(Error(ErrorCode::kerInvalidSettingForImage, \"Image comment\", \"JP2\"));",
          "146: }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "181:   Jp2BoxHeader box = {0, 0};",
          "182:   Jp2BoxHeader subBox = {0, 0};",
          "184:   Jp2UuidBox uuid = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}};",
          "186:   size_t boxem = 1000;  // boxes max",
          "190:     long position = io_->tell();",
          "191:     box.length = getLong(reinterpret_cast<byte*>(&box.length), bigEndian);",
          "192:     box.type = getLong(reinterpret_cast<byte*>(&box.type), bigEndian);",
          "",
          "[Removed Lines]",
          "183:   Jp2ImageHeaderBox ihdr = {0, 0, 0, 0, 0, 0, 0, 0};",
          "185:   size_t boxes = 0;",
          "188:   while (io_->read(reinterpret_cast<byte*>(&box), sizeof(box)) == sizeof(box)) {",
          "189:     boxes_check(boxes++, boxem);",
          "",
          "[Added Lines]",
          "162:   Jp2ImageHeaderBox ihdr = {0, 0, 0, 0, 0, 0, 0};",
          "164:   size_t boxesCount = 0;",
          "167:   while (io_->read(reinterpret_cast<byte*>(&box), boxHSize) == boxHSize) {",
          "168:     boxes_check(boxesCount++, boxem);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "195:               << \"Position: \" << position << \" box type: \" << toAscii(box.type) << \" length: \" << box.length",
          "196:               << std::endl;",
          "197: #endif",
          "200:     if (box.length == 0)",
          "201:       return;",
          "203:     if (box.length == 1) {",
          "205:     }",
          "207:     switch (box.type) {",
          "209: #ifdef EXIV2_DEBUG_MESSAGES",
          "210:         std::cout << \"Exiv2::Jp2Image::readMetadata: JP2Header box found\" << std::endl;",
          "211: #endif",
          "212:         long restore = io_->tell();",
          "216:           subBox.length = getLong(reinterpret_cast<byte*>(&subBox.length), bigEndian);",
          "217:           subBox.type = getLong(reinterpret_cast<byte*>(&subBox.type), bigEndian);",
          "218:           if (subBox.length > io_->size()) {",
          "",
          "[Removed Lines]",
          "198:     enforce(box.length <= sizeof(box) + io_->size() - io_->tell(), Exiv2::ErrorCode::kerCorruptedMetadata);",
          "208:       case kJp2BoxTypeJp2Header: {",
          "214:         while (io_->read(reinterpret_cast<byte*>(&subBox), sizeof(subBox)) == sizeof(subBox) && subBox.length) {",
          "215:           boxes_check(boxes++, boxem);",
          "",
          "[Added Lines]",
          "177:     enforce(box.length <= boxHSize + io_->size() - io_->tell(), ErrorCode::kerCorruptedMetadata);",
          "187:       case kJp2BoxTypeSignature: {",
          "188: #ifdef EXIV2_DEBUG_MESSAGES",
          "189:         std::cout << \"Exiv2::Jp2Image::readMetadata: JPEG 2000 Signature box found\" << std::endl;",
          "190: #endif",
          "191:         break;",
          "192:       }",
          "193:       case kJp2BoxTypeFileTypeBox: {",
          "196:         assert(box.length >= 20);  // 8 (box) + 4 (BR) + 4(MinV) + >=4 (CLn)",
          "197:         DataBuf data(box.length - boxHSize);",
          "198:         io_->read(data.data(), data.size());",
          "199:         const uint32_t brand = data.read_uint32(0, bigEndian);",
          "200:         const uint32_t minorVersion = data.read_uint32(4, bigEndian);",
          "201:         const uint32_t compatibilityList = data.read_uint32(8, bigEndian);",
          "206:         if (brand != brandJp2 || minorVersion != 0 || compatibilityList != brandJp2)",
          "207:           throw Error(ErrorCode::kerCorruptedMetadata);",
          "208:         break;",
          "209:       }",
          "210:       case kJp2BoxTypeHeader: {",
          "216:         while (io_->read(reinterpret_cast<byte*>(&subBox), boxHSize) == boxHSize && subBox.length) {",
          "217:           boxes_check(boxesCount++, boxem);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "222:           std::cout << \"Exiv2::Jp2Image::readMetadata: \"",
          "223:                     << \"subBox = \" << toAscii(subBox.type) << \" length = \" << subBox.length << std::endl;",
          "224: #endif",
          "226: #ifdef EXIV2_DEBUG_MESSAGES",
          "227:             std::cout << \"Exiv2::Jp2Image::readMetadata: \"",
          "228:                       << \"Color data found\" << std::endl;",
          "",
          "[Removed Lines]",
          "225:           if (subBox.type == kJp2BoxTypeColorHeader && subBox.length != 15) {",
          "",
          "[Added Lines]",
          "227:           if (subBox.type == kJp2BoxTypeColorSpec && subBox.length != 15) {",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "265:             ihdr.imageHeight = getLong(reinterpret_cast<byte*>(&ihdr.imageHeight), bigEndian);",
          "266:             ihdr.imageWidth = getLong(reinterpret_cast<byte*>(&ihdr.imageWidth), bigEndian);",
          "267:             ihdr.componentCount = getShort(reinterpret_cast<byte*>(&ihdr.componentCount), bigEndian);",
          "270:             pixelWidth_ = ihdr.imageWidth;",
          "271:             pixelHeight_ = ihdr.imageHeight;",
          "272:           }",
          "274:           io_->seek(restore, BasicIo::beg);",
          "276:             throw Error(ErrorCode::kerCorruptedMetadata);",
          "277:           }",
          "278:           restore = io_->tell();",
          "",
          "[Removed Lines]",
          "268:             ihdr.compressionTypeProfile = getShort(reinterpret_cast<byte*>(&ihdr.compressionTypeProfile), bigEndian);",
          "275:           if (io_->seek(subBox.length, Exiv2::BasicIo::cur) != 0) {",
          "",
          "[Added Lines]",
          "270:             enforce(ihdr.c == 7, ErrorCode::kerCorruptedMetadata);",
          "277:           if (io_->seek(subBox.length, BasicIo::cur) != 0) {",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "296: #ifdef EXIV2_DEBUG_MESSAGES",
          "297:             std::cout << \"Exiv2::Jp2Image::readMetadata: Exif data found\" << std::endl;",
          "298: #endif",
          "301:             bufRead = io_->read(rawData.data(), rawData.size());",
          "302:             if (io_->error())",
          "303:               throw Error(ErrorCode::kerFailedToReadImageData);",
          "",
          "[Removed Lines]",
          "299:             enforce(box.length >= sizeof(box) + sizeof(uuid), ErrorCode::kerCorruptedMetadata);",
          "300:             rawData.alloc(box.length - (sizeof(box) + sizeof(uuid)));",
          "",
          "[Added Lines]",
          "301:             enforce(box.length >= boxHSize + sizeof(uuid), ErrorCode::kerCorruptedMetadata);",
          "302:             rawData.alloc(box.length - (boxHSize + sizeof(uuid)));",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "343: #ifdef EXIV2_DEBUG_MESSAGES",
          "344:             std::cout << \"Exiv2::Jp2Image::readMetadata: Iptc data found\" << std::endl;",
          "345: #endif",
          "348:             bufRead = io_->read(rawData.data(), rawData.size());",
          "349:             if (io_->error())",
          "350:               throw Error(ErrorCode::kerFailedToReadImageData);",
          "",
          "[Removed Lines]",
          "346:             enforce(box.length >= sizeof(box) + sizeof(uuid), ErrorCode::kerCorruptedMetadata);",
          "347:             rawData.alloc(box.length - (sizeof(box) + sizeof(uuid)));",
          "",
          "[Added Lines]",
          "348:             enforce(box.length >= boxHSize + sizeof(uuid), ErrorCode::kerCorruptedMetadata);",
          "349:             rawData.alloc(box.length - (boxHSize + sizeof(uuid)));",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "363: #ifdef EXIV2_DEBUG_MESSAGES",
          "364:             std::cout << \"Exiv2::Jp2Image::readMetadata: Xmp data found\" << std::endl;",
          "365: #endif",
          "368:             bufRead = io_->read(rawData.data(), rawData.size());",
          "369:             if (io_->error())",
          "370:               throw Error(ErrorCode::kerFailedToReadImageData);",
          "",
          "[Removed Lines]",
          "366:             enforce(box.length >= sizeof(box) + sizeof(uuid), ErrorCode::kerCorruptedMetadata);",
          "367:             rawData.alloc(box.length - (sizeof(box) + sizeof(uuid)));",
          "",
          "[Added Lines]",
          "368:             enforce(box.length >= boxHSize + sizeof(uuid), ErrorCode::kerCorruptedMetadata);",
          "369:             rawData.alloc(box.length - (boxHSize + sizeof(uuid)));",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "397:     }",
          "401:     if (io_->error())",
          "402:       throw Error(ErrorCode::kerFailedToReadImageData);",
          "403:   }",
          "",
          "[Removed Lines]",
          "400:     io_->seek(static_cast<long>(position - sizeof(box) + box.length), BasicIo::beg);",
          "",
          "[Added Lines]",
          "402:     io_->seek(static_cast<long>(position - boxHSize + box.length), BasicIo::beg);",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "430:     bool bLF = false;",
          "432:     while (box.length && box.type != kJp2BoxTypeClose &&",
          "434:       long position = io_->tell();",
          "435:       box.length = getLong(reinterpret_cast<byte*>(&box.length), bigEndian);",
          "436:       box.type = getLong(reinterpret_cast<byte*>(&box.type), bigEndian);",
          "439:       if (bPrint) {",
          "441:             << toAscii(box.type) << \"      | \";",
          "442:         bLF = true;",
          "443:         if (box.type == kJp2BoxTypeClose)",
          "",
          "[Removed Lines]",
          "433:            io_->read(reinterpret_cast<byte*>(&box), sizeof(box)) == sizeof(box)) {",
          "437:       enforce(box.length <= sizeof(box) + io_->size() - io_->tell(), Exiv2::ErrorCode::kerCorruptedMetadata);",
          "440:         out << Internal::stringFormat(\"%8ld | %8ld | \", position - sizeof(box), static_cast<size_t>(box.length))",
          "",
          "[Added Lines]",
          "438:            io_->read(reinterpret_cast<byte*>(&box), boxHSize) == boxHSize) {",
          "442:       enforce(box.length <= boxHSize + io_->size() - io_->tell(), ErrorCode::kerCorruptedMetadata);",
          "445:         out << Internal::stringFormat(\"%8ld | %8ld | \", position - boxHSize, static_cast<size_t>(box.length))",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "447:         break;",
          "449:       switch (box.type) {",
          "451:           lf(out, bLF);",
          "454:                  io_->tell() < position + static_cast<long>(box.length))  // don't read beyond the box!",
          "455:           {",
          "457:             subBox.length = getLong(reinterpret_cast<byte*>(&subBox.length), bigEndian);",
          "458:             subBox.type = getLong(reinterpret_cast<byte*>(&subBox.type), bigEndian);",
          "461:               throw Error(ErrorCode::kerCorruptedMetadata);",
          "462:             }",
          "465:             io_->read(data.data(), data.size());",
          "466:             if (bPrint) {",
          "467:               out << Internal::stringFormat(\"%8ld | %8ld |  sub:\", address, subBox.length) << toAscii(subBox.type)",
          "",
          "[Removed Lines]",
          "450:         case kJp2BoxTypeJp2Header: {",
          "453:           while (io_->read(reinterpret_cast<byte*>(&subBox), sizeof(subBox)) == sizeof(subBox) &&",
          "456:             const size_t address = io_->tell() - sizeof(subBox);",
          "460:             if (subBox.length < sizeof(box) || subBox.length > io_->size() - io_->tell()) {",
          "464:             DataBuf data(subBox.length - sizeof(box));",
          "",
          "[Added Lines]",
          "455:         case kJp2BoxTypeSignature: {",
          "457:           assert(box.length == 12);",
          "458:           DataBuf data(4);",
          "459:           io_->read(data.data(), data.size());",
          "460:           if (data.read_uint32(0, bigEndian) != 0x0D0A870A) {",
          "461:             throw Error(ErrorCode::kerCorruptedMetadata);",
          "462:           }",
          "463:           break;",
          "464:         }",
          "465:         case kJp2BoxTypeFileTypeBox: {",
          "468:           DataBuf data(12);",
          "469:           io_->read(data.data(), data.size());",
          "470:           uint32_t brand = data.read_uint32(0, bigEndian);",
          "471:           uint32_t minorVersion = data.read_uint32(4, bigEndian);",
          "472:           uint32_t compatibilityList = data.read_uint32(8, bigEndian);",
          "473:           if (brand != brandJp2 || minorVersion != 0 || compatibilityList != brandJp2)",
          "474:             throw Error(ErrorCode::kerCorruptedMetadata);",
          "475:           break;",
          "476:         }",
          "477:         case kJp2BoxTypeHeader: {",
          "481:           while (io_->read(reinterpret_cast<byte*>(&subBox), boxHSize) == boxHSize &&",
          "484:             const size_t address = io_->tell() - boxHSize;",
          "488:             if (subBox.length < boxHSize || subBox.length > io_->size() - io_->tell()) {",
          "492:             DataBuf data(subBox.length - boxHSize);",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "470:               bLF = true;",
          "471:             }",
          "474:               const size_t pad = 3;  // don't know why there are 3 padding bytes",
          "477:               enforce(data.size() >= pad + 4, ErrorCode::kerCorruptedMetadata);",
          "492:               }",
          "493:             }",
          "494:             lf(out, bLF);",
          "",
          "[Removed Lines]",
          "473:             if (subBox.type == kJp2BoxTypeColorHeader) {",
          "479:               if (bPrint) {",
          "480:                 out << \" | pad:\";",
          "481:                 for (int i = 0; i < 3; i++)",
          "482:                   out << \" \" << static_cast<int>(data.read_uint8(i));",
          "483:               }",
          "485:               const size_t iccLength = data.read_uint32(pad, bigEndian);",
          "486:               if (bPrint) {",
          "487:                 out << \" | iccLength:\" << iccLength;",
          "488:               }",
          "489:               enforce(iccLength <= data.size() - pad, ErrorCode::kerCorruptedMetadata);",
          "490:               if (bICC) {",
          "491:                 out.write(data.c_str(pad), iccLength);",
          "",
          "[Added Lines]",
          "501:             if (subBox.type == kJp2BoxTypeImageHeader) {",
          "502:               assert(subBox.length == 22);",
          "504:               auto compressionType = data.read_uint8(11);",
          "505:               auto unkC = data.read_uint8(12);",
          "506:               auto ipr = data.read_uint8(13);",
          "507:               if (compressionType != 7 || unkC > 1 || ipr > 1) {",
          "508:                 throw Error(ErrorCode::kerCorruptedMetadata);",
          "509:               }",
          "510:             } else if (subBox.type == kJp2BoxTypeColorSpec) {",
          "517:               auto METH = data.read_uint8(0);",
          "520:               if (METH == 1) {  // Enumerated Colourspace",
          "521:                 auto enumCS = data.read_uint32(3, bigEndian);",
          "522:                 if (enumCS != 16 && enumCS != 17) {",
          "523:                   throw Error(ErrorCode::kerCorruptedMetadata);",
          "524:                 }",
          "525:               } else {  // Restricted ICC Profile",
          "527:                 const size_t iccLength = data.read_uint32(pad, bigEndian);",
          "528:                 if (bPrint) {",
          "529:                   out << \" | iccLength:\" << iccLength;",
          "530:                 }",
          "531:                 enforce(iccLength <= data.size() - pad, ErrorCode::kerCorruptedMetadata);",
          "532:                 if (bICC) {",
          "533:                   out.write(data.c_str(pad), iccLength);",
          "534:                 }",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "515:             }",
          "517:             DataBuf rawData;",
          "520:             const size_t bufRead = io_->read(rawData.data(), rawData.size());",
          "521:             if (io_->error())",
          "522:               throw Error(ErrorCode::kerFailedToReadImageData);",
          "",
          "[Removed Lines]",
          "518:             enforce(box.length >= sizeof(uuid) + sizeof(box), ErrorCode::kerCorruptedMetadata);",
          "519:             rawData.alloc(box.length - sizeof(uuid) - sizeof(box));",
          "",
          "[Added Lines]",
          "561:             enforce(box.length >= sizeof(uuid) + boxHSize, ErrorCode::kerCorruptedMetadata);",
          "562:             rawData.alloc(box.length - sizeof(uuid) - boxHSize);",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "553:       }",
          "557:       if (io_->error())",
          "558:         throw Error(ErrorCode::kerFailedToReadImageData);",
          "559:       if (bPrint)",
          "560:         lf(out, bLF);",
          "561:     }",
          "562:   }",
          "565: void Jp2Image::writeMetadata() {",
          "566:   if (io_->open() != 0) {",
          "",
          "[Removed Lines]",
          "556:       io_->seek(static_cast<long>(position - sizeof(box) + box.length), BasicIo::beg);",
          "563: }  // JpegBase::printStructure",
          "",
          "[Added Lines]",
          "599:       io_->seek(static_cast<long>(position - boxHSize + box.length), BasicIo::beg);",
          "606: }",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "584: void Jp2Image::encodeJp2Header(const DataBuf& boxBuf, DataBuf& outBuf) {",
          "585:   DataBuf output(boxBuf.size() + iccProfile_.size() + 100);  // allocate sufficient space",
          "589:   auto pBox = reinterpret_cast<const Jp2BoxHeader*>(boxBuf.c_data());",
          "590:   uint32_t length = getLong(reinterpret_cast<const byte*>(&pBox->length), bigEndian);",
          "593:   auto p = boxBuf.c_str();",
          "594:   bool bWroteColor = false;",
          "596:   while (count < length && !bWroteColor) {",
          "598:     auto pSubBox = reinterpret_cast<const Jp2BoxHeader*>(p + count);",
          "601:     Jp2BoxHeader subBox;",
          "603:     Jp2BoxHeader newBox = subBox;",
          "605:     if (count < length) {",
          "",
          "[Removed Lines]",
          "586:   size_t outlen = sizeof(Jp2BoxHeader);                      // now many bytes have we written to output?",
          "587:   long inlen = sizeof(Jp2BoxHeader);                         // how many bytes have we read from boxBuf?",
          "588:   enforce(sizeof(Jp2BoxHeader) <= output.size(), Exiv2::ErrorCode::kerCorruptedMetadata);",
          "591:   enforce(length <= output.size(), Exiv2::ErrorCode::kerCorruptedMetadata);",
          "592:   uint32_t count = sizeof(Jp2BoxHeader);",
          "597:     enforce(sizeof(Jp2BoxHeader) <= length - count, Exiv2::ErrorCode::kerCorruptedMetadata);",
          "602:     memcpy(&subBox, pSubBox, sizeof(subBox));",
          "",
          "[Added Lines]",
          "629:   size_t outlen = boxHSize;                                  // now many bytes have we written to output?",
          "630:   long inlen = boxHSize;                                     // how many bytes have we read from boxBuf?",
          "631:   enforce(boxHSize <= output.size(), ErrorCode::kerCorruptedMetadata);",
          "634:   enforce(length <= output.size(), ErrorCode::kerCorruptedMetadata);",
          "635:   uint32_t count = boxHSize;",
          "640:     enforce(boxHSize <= length - count, ErrorCode::kerCorruptedMetadata);",
          "645:     memcpy(&subBox, pSubBox, boxHSize);",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "609:       std::cout << \"Jp2Image::encodeJp2Header subbox: \" << toAscii(subBox.type) << \" length = \" << subBox.length",
          "610:                 << std::endl;",
          "611: #endif",
          "614:       count += subBox.length;",
          "615:       newBox.type = subBox.type;",
          "616:     } else {",
          "617:       subBox.length = 0;",
          "619:       count = length;",
          "620:     }",
          "622:     size_t newlen = subBox.length;",
          "624:       bWroteColor = true;",
          "625:       if (!iccProfileDefined()) {",
          "626:         const char* pad = \"\\x01\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x05\\x1cuuid\";",
          "627:         uint32_t psize = 15;",
          "630:         ul2Data(reinterpret_cast<byte*>(&newBox.length), psize, bigEndian);",
          "631:         ul2Data(reinterpret_cast<byte*>(&newBox.type), newBox.type, bigEndian);",
          "632:         output.copyBytes(outlen, &newBox, sizeof(newBox));",
          "",
          "[Removed Lines]",
          "612:       enforce(subBox.length > 0, Exiv2::ErrorCode::kerCorruptedMetadata);",
          "613:       enforce(subBox.length <= length - count, Exiv2::ErrorCode::kerCorruptedMetadata);",
          "618:       newBox.type = kJp2BoxTypeColorHeader;",
          "623:     if (newBox.type == kJp2BoxTypeColorHeader) {",
          "628:         newlen = sizeof(newBox) + psize;",
          "629:         enforce(newlen <= output.size() - outlen, Exiv2::ErrorCode::kerCorruptedMetadata);",
          "",
          "[Added Lines]",
          "655:       enforce(subBox.length > 0, ErrorCode::kerCorruptedMetadata);",
          "656:       enforce(subBox.length <= length - count, ErrorCode::kerCorruptedMetadata);",
          "661:       newBox.type = kJp2BoxTypeColorSpec;",
          "666:     if (newBox.type == kJp2BoxTypeColorSpec) {",
          "671:         enforce(newlen <= output.size() - outlen, ErrorCode::kerCorruptedMetadata);",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "635:         const char* pad = \"\\x02\\x00\\x00\";",
          "636:         uint32_t psize = 3;",
          "637:         newlen = sizeof(newBox) + psize + iccProfile_.size();",
          "639:         ul2Data(reinterpret_cast<byte*>(&newBox.length), static_cast<uint32_t>(newlen), bigEndian);",
          "640:         ul2Data(reinterpret_cast<byte*>(&newBox.type), newBox.type, bigEndian);",
          "641:         output.copyBytes(outlen, &newBox, sizeof(newBox));",
          "",
          "[Removed Lines]",
          "638:         enforce(newlen <= static_cast<size_t>(output.size() - outlen), Exiv2::ErrorCode::kerCorruptedMetadata);",
          "",
          "[Added Lines]",
          "680:         enforce(newlen <= static_cast<size_t>(output.size() - outlen), ErrorCode::kerCorruptedMetadata);",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "643:         output.copyBytes(outlen + sizeof(newBox) + psize, iccProfile_.c_data(), iccProfile_.size());",
          "644:       }",
          "645:     } else {",
          "647:       output.copyBytes(outlen, boxBuf.c_data(inlen), subBox.length);",
          "648:     }",
          "",
          "[Removed Lines]",
          "646:       enforce(newlen <= static_cast<size_t>(output.size() - outlen), Exiv2::ErrorCode::kerCorruptedMetadata);",
          "",
          "[Added Lines]",
          "688:       enforce(newlen <= static_cast<size_t>(output.size() - outlen), ErrorCode::kerCorruptedMetadata);",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "655:   outBuf.alloc(outlen);",
          "656:   outBuf.copyBytes(0, output.c_data(), outlen);",
          "657:   auto oBox = reinterpret_cast<Jp2BoxHeader*>(outBuf.data());",
          "659:   ul2Data(reinterpret_cast<byte*>(&oBox->length), static_cast<uint32_t>(outlen), bigEndian);",
          "660: }",
          "",
          "[Removed Lines]",
          "658:   ul2Data(reinterpret_cast<byte*>(&oBox->type), kJp2BoxTypeJp2Header, bigEndian);",
          "",
          "[Added Lines]",
          "700:   ul2Data(reinterpret_cast<byte*>(&oBox->type), kJp2BoxTypeHeader, bigEndian);",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "678:   if (!isJp2Type(*io_, true)) {",
          "681:     throw Error(ErrorCode::kerNoImageInInputData);",
          "682:   }",
          "685:   if (outIo.write(Jp2Signature, 12) != 12)",
          "686:     throw Error(ErrorCode::kerImageWriteFailed);",
          "688:   Jp2BoxHeader box = {0, 0};",
          "690:   byte boxDataSize[4];",
          "691:   byte boxUUIDtype[4];",
          "697:   while (io_->tell() < static_cast<long>(io_->size())) {",
          "698: #ifdef EXIV2_DEBUG_MESSAGES",
          "",
          "[Removed Lines]",
          "679:     if (io_->error() || io_->eof())",
          "680:       throw Error(ErrorCode::kerInputDataReadFailed);",
          "692:   DataBuf bheaderBuf(8);  // Box header : 4 bytes (data size) + 4 bytes (box type).",
          "",
          "[Added Lines]",
          "728: #ifdef EXIV2_DEBUG_MESSAGES",
          "729:   std::cout << \"Jp2Image::doWriteMetadata: JPEG 2000 Signature box written\" << std::endl;",
          "730: #endif",
          "736:   DataBuf bheaderBuf(8);",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "700: #endif",
          "711:     box.length = bheaderBuf.read_uint32(0, bigEndian);",
          "712:     box.type = bheaderBuf.read_uint32(4, bigEndian);",
          "",
          "[Removed Lines]",
          "703:     size_t bufRead = io_->read(bheaderBuf.data(), bheaderBuf.size());",
          "704:     if (io_->error())",
          "705:       throw Error(ErrorCode::kerFailedToReadImageData);",
          "706:     if (bufRead != bheaderBuf.size())",
          "707:       throw Error(ErrorCode::kerInputDataReadFailed);",
          "",
          "[Added Lines]",
          "744:     io_->readOrThrow(bheaderBuf.data(), bheaderBuf.size(), ErrorCode::kerInputDataReadFailed);",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "733:     enforce(box.length - 8 <= static_cast<size_t>(io_->size() - io_->tell()), ErrorCode::kerCorruptedMetadata);",
          "754:     switch (box.type) {",
          "756:         DataBuf newBuf;",
          "757:         encodeJp2Header(boxBuf, newBuf);",
          "758: #ifdef EXIV2_DEBUG_MESSAGES",
          "",
          "[Removed Lines]",
          "736:     DataBuf boxBuf(box.length);                           // Box header (8 bytes) + box data.",
          "737:     boxBuf.copyBytes(0, bheaderBuf.c_data(), 8);          // Copy header.",
          "738:     bufRead = io_->read(boxBuf.data(8), box.length - 8);  // Extract box data.",
          "739:     if (io_->error()) {",
          "740: #ifdef EXIV2_DEBUG_MESSAGES",
          "741:       std::cout << \"Exiv2::Jp2Image::doWriteMetadata: Error reading source file\" << std::endl;",
          "742: #endif",
          "744:       throw Error(ErrorCode::kerFailedToReadImageData);",
          "745:     }",
          "747:     if (bufRead != (box.length - 8)) {",
          "748: #ifdef EXIV2_DEBUG_MESSAGES",
          "749:       std::cout << \"Exiv2::Jp2Image::doWriteMetadata: Cannot read source file data\" << std::endl;",
          "750: #endif",
          "751:       throw Error(ErrorCode::kerInputDataReadFailed);",
          "752:     }",
          "755:       case kJp2BoxTypeJp2Header: {",
          "",
          "[Added Lines]",
          "772:     DataBuf boxBuf(box.length);                   // Box header (8 bytes) + box data.",
          "773:     boxBuf.copyBytes(0, bheaderBuf.c_data(), 8);  // Copy header.",
          "774:     io_->readOrThrow(boxBuf.data(8), box.length - 8, ErrorCode::kerInputDataReadFailed);  // Extract box data.",
          "777:       case kJp2BoxTypeHeader: {",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "774:             rawExif.copyBytes(0, &blob[0], blob.size());",
          "776:             DataBuf boxData(8 + 16 + rawExif.size());",
          "779:             boxData.copyBytes(0, boxDataSize, 4);",
          "780:             boxData.copyBytes(4, boxUUIDtype, 4);",
          "781:             boxData.copyBytes(8, kJp2UuidExif, 16);",
          "",
          "[Removed Lines]",
          "777:             ul2Data(boxDataSize, static_cast<uint32_t>(boxData.size()), Exiv2::bigEndian);",
          "778:             ul2Data(boxUUIDtype, kJp2BoxTypeUuid, Exiv2::bigEndian);",
          "",
          "[Added Lines]",
          "799:             ul2Data(boxDataSize, static_cast<uint32_t>(boxData.size()), bigEndian);",
          "800:             ul2Data(boxUUIDtype, kJp2BoxTypeUuid, bigEndian);",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "796:           DataBuf rawIptc = IptcParser::encode(iptcData_);",
          "797:           if (!rawIptc.empty()) {",
          "798:             DataBuf boxData(8 + 16 + rawIptc.size());",
          "801:             boxData.copyBytes(0, boxDataSize, 4);",
          "802:             boxData.copyBytes(4, boxUUIDtype, 4);",
          "803:             boxData.copyBytes(8, kJp2UuidIptc, 16);",
          "",
          "[Removed Lines]",
          "799:             ul2Data(boxDataSize, static_cast<uint32_t>(boxData.size()), Exiv2::bigEndian);",
          "800:             ul2Data(boxUUIDtype, kJp2BoxTypeUuid, Exiv2::bigEndian);",
          "",
          "[Added Lines]",
          "821:             ul2Data(boxDataSize, static_cast<uint32_t>(boxData.size()), bigEndian);",
          "822:             ul2Data(boxUUIDtype, kJp2BoxTypeUuid, bigEndian);",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "825:           DataBuf xmp(reinterpret_cast<const byte*>(xmpPacket_.data()), xmpPacket_.size());",
          "826:           DataBuf boxData(8 + 16 + xmp.size());",
          "829:           boxData.copyBytes(0, boxDataSize, 4);",
          "830:           boxData.copyBytes(4, boxUUIDtype, 4);",
          "831:           boxData.copyBytes(8, kJp2UuidXmp, 16);",
          "",
          "[Removed Lines]",
          "827:           ul2Data(boxDataSize, static_cast<uint32_t>(boxData.size()), Exiv2::bigEndian);",
          "828:           ul2Data(boxUUIDtype, kJp2BoxTypeUuid, Exiv2::bigEndian);",
          "",
          "[Added Lines]",
          "849:           ul2Data(boxDataSize, static_cast<uint32_t>(boxData.size()), bigEndian);",
          "850:           ul2Data(boxUUIDtype, kJp2BoxTypeUuid, bigEndian);",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "843:       }",
          "845:       case kJp2BoxTypeUuid: {",
          "847:         if (boxBuf.cmpBytes(8, kJp2UuidExif, 16) == 0) {",
          "848: #ifdef EXIV2_DEBUG_MESSAGES",
          "849:           std::cout << \"Exiv2::Jp2Image::doWriteMetadata: strip Exif Uuid box\" << std::endl;",
          "",
          "[Removed Lines]",
          "846:         enforce(boxBuf.size() >= 24, Exiv2::ErrorCode::kerCorruptedMetadata);",
          "",
          "[Added Lines]",
          "868:         enforce(boxBuf.size() >= 24, ErrorCode::kerCorruptedMetadata);",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "897: bool isJp2Type(BasicIo& iIo, bool advance) {",
          "898:   const int32_t len = 12;",
          "899:   byte buf[len];",
          "902:     return false;",
          "903:   }",
          "904:   bool matched = (memcmp(buf, Jp2Signature, len) == 0);",
          "905:   if (!advance || !matched) {",
          "907:   }",
          "908:   return matched;",
          "909: }",
          "",
          "[Removed Lines]",
          "900:   iIo.read(buf, len);",
          "901:   if (iIo.error() || iIo.eof()) {",
          "906:     iIo.seek(-len, BasicIo::cur);",
          "",
          "[Added Lines]",
          "922:   const size_t bytesRead = iIo.read(buf, len);",
          "923:   if (iIo.error() || iIo.eof() || bytesRead != len) {",
          "928:     iIo.seek(-len, BasicIo::cur);  // Return to original position",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "23c1cda99d8ea0ea324b3dd29a89353d17406c44",
      "candidate_info": {
        "commit_hash": "23c1cda99d8ea0ea324b3dd29a89353d17406c44",
        "repo": "Exiv2/exiv2",
        "commit_url": "https://github.com/Exiv2/exiv2/commit/23c1cda99d8ea0ea324b3dd29a89353d17406c44",
        "files": [
          "src/jp2image.cpp"
        ],
        "message": "Fix signed/unsigned compiler warnings.",
        "before_after_code_files": [
          "src/jp2image.cpp||src/jp2image.cpp"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/jp2image.cpp||src/jp2image.cpp"
          ],
          "candidate": [
            "src/jp2image.cpp||src/jp2image.cpp"
          ]
        }
      },
      "candidate_diff": {
        "src/jp2image.cpp||src/jp2image.cpp": [
          "File: src/jp2image.cpp -> src/jp2image.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "683:                     const char* pad   = \"\\x01\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x05\\x1cuuid\";",
          "684:                     uint32_t    psize = 15;",
          "685:                     newlen            = sizeof(newBox) + psize ;",
          "687:                     ul2Data((byte*)&newBox.length,psize      ,bigEndian);",
          "688:                     ul2Data((byte*)&newBox.type  ,newBox.type,bigEndian);",
          "689:                     ::memcpy(output.pData_+outlen                     ,&newBox            ,sizeof(newBox));",
          "",
          "[Removed Lines]",
          "686:                     enforce(newlen <= output.size_ - outlen, Exiv2::kerCorruptedMetadata);",
          "",
          "[Added Lines]",
          "686:                     enforce(newlen <= static_cast<size_t>(output.size_ - outlen), Exiv2::kerCorruptedMetadata);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "692:                     const char* pad   = \"\\x02\\x00\\x00\";",
          "693:                     uint32_t    psize = 3;",
          "694:                     newlen            = sizeof(newBox) + psize + iccProfile_.size_;",
          "696:                     ul2Data((byte*)&newBox.length,newlen,bigEndian);",
          "697:                     ul2Data((byte*)&newBox.type,newBox.type,bigEndian);",
          "698:                     ::memcpy(output.pData_+outlen                     ,&newBox            ,sizeof(newBox)  );",
          "",
          "[Removed Lines]",
          "695:                     enforce(newlen <= output.size_ - outlen, Exiv2::kerCorruptedMetadata);",
          "",
          "[Added Lines]",
          "695:                     enforce(newlen <= static_cast<size_t>(output.size_ - outlen), Exiv2::kerCorruptedMetadata);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "700:                     ::memcpy(output.pData_+outlen+sizeof(newBox)+psize,iccProfile_.pData_,iccProfile_.size_);",
          "701:                 }",
          "702:             } else {",
          "704:                 ::memcpy(output.pData_+outlen,boxBuf.pData_+inlen,subBox.length);",
          "705:             }",
          "",
          "[Removed Lines]",
          "703:                 enforce(newlen <= output.size_ - outlen, Exiv2::kerCorruptedMetadata);",
          "",
          "[Added Lines]",
          "703:                 enforce(newlen <= static_cast<size_t>(output.size_ - outlen), Exiv2::kerCorruptedMetadata);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
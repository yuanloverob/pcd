{
  "cve_id": "CVE-2015-4652",
  "cve_desc": "epan/dissectors/packet-gsm_a_dtap.c in the GSM DTAP dissector in Wireshark 1.12.x before 1.12.6 does not properly validate digit characters, which allows remote attackers to cause a denial of service (application crash) via a crafted packet, related to the de_emerg_num_list and de_bcd_num functions.",
  "repo": "wireshark/wireshark",
  "patch_hash": "d93be95fc0e7011e8b4ade9171e7e66146063296",
  "patch_info": {
    "commit_hash": "d93be95fc0e7011e8b4ade9171e7e66146063296",
    "repo": "wireshark/wireshark",
    "commit_url": "https://github.com/wireshark/wireshark/commit/d93be95fc0e7011e8b4ade9171e7e66146063296",
    "files": [
      "epan/dissectors/packet-gsm_a_dtap.c"
    ],
    "message": "Clean up handling of BDC coded numbers a bit.\n\nChange-Id: Ic3d523664e3c78b4ed289b7e5acf3f53614c6d54\nReviewed-on: https://code.wireshark.org/review/5027\nReviewed-by: Anders Broman <a.broman58@gmail.com>",
    "before_after_code_files": [
      "epan/dissectors/packet-gsm_a_dtap.c||epan/dissectors/packet-gsm_a_dtap.c"
    ]
  },
  "patch_diff": {
    "epan/dissectors/packet-gsm_a_dtap.c||epan/dissectors/packet-gsm_a_dtap.c": [
      "File: epan/dissectors/packet-gsm_a_dtap.c -> epan/dissectors/packet-gsm_a_dtap.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1065: de_emerg_num_list(tvbuff_t *tvb, proto_tree *tree, packet_info *pinfo, guint32 offset, guint len _U_, gchar *add_string _U_, int string_len _U_)",
      "1066: {",
      "1067:     guint32     curr_offset;",
      "1069:     guint8      count;",
      "1071:     proto_tree *subtree;",
      "1072:     proto_item *item;",
      "1075:     curr_offset = offset;",
      "",
      "[Removed Lines]",
      "1068:     guint8      en_len, oct, i;",
      "1070:     guint8     *poctets;",
      "1073:     gboolean    malformed_number;",
      "",
      "[Added Lines]",
      "1068:     guint8      en_len;",
      "1072:     const char *digit_str;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1101:         curr_offset++;",
      "1102:         en_len--;",
      "1130:             expert_add_info(pinfo, item, &ei_gsm_a_dtap_end_mark_unexpected);",
      "1132:         curr_offset = curr_offset + en_len;",
      "1133:         count++;",
      "",
      "[Removed Lines]",
      "1104:         poctets = (guint8 *)tvb_memdup(wmem_packet_scope(), tvb, curr_offset, en_len);",
      "1106:         my_dgt_tbcd_unpack(a_bigbuf, poctets, en_len, &Dgt_mbcd);",
      "1108:         item = proto_tree_add_string_format(subtree, hf_gsm_a_dtap_emergency_bcd_num,",
      "1109:             tvb, curr_offset, en_len,",
      "1110:             a_bigbuf,",
      "1111:             \"BCD Digits: %s\",",
      "1112:             a_bigbuf);",
      "1114:         malformed_number = FALSE;",
      "1115:         for(i = 0; i < en_len - 1; i++)",
      "1116:         {",
      "1117:             oct = poctets[i];",
      "1118:             if (((oct & 0xf0) == 0xf0) || ((oct & 0x0f) == 0x0f))",
      "1119:             {",
      "1120:                 malformed_number = TRUE;",
      "1121:                 break;",
      "1122:             }",
      "1123:         }",
      "1125:         oct = poctets[en_len - 1];",
      "1126:         if ((oct & 0x0f) == 0x0f)",
      "1127:             malformed_number = TRUE;",
      "1129:         if (malformed_number)",
      "",
      "[Added Lines]",
      "1103:         digit_str = tvb_bcd_dig_to_wmem_packet_str(tvb, curr_offset, en_len, NULL, FALSE);",
      "1104:         item = proto_tree_add_string(subtree, hf_gsm_a_dtap_emergency_bcd_num, tvb, curr_offset, en_len, digit_str);",
      "1111:         if(strchr(digit_str,'?')){",
      "1113:         }",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "2151: de_bcd_num(tvbuff_t *tvb, proto_tree *tree, packet_info *pinfo, guint32 offset, guint len, int header_field, gboolean *address_extracted)",
      "2152: {",
      "2153:     guint8     *poctets;",
      "2156:     proto_item *item;",
      "2160:     curr_offset = offset;",
      "",
      "[Removed Lines]",
      "2154:     guint8      extension, oct;",
      "2155:     guint32     curr_offset, i, num_string_len;",
      "2157:     gboolean    malformed_number;",
      "",
      "[Added Lines]",
      "2137:     guint8      extension;",
      "2138:     guint32     curr_offset, num_string_len;",
      "2140:     const char *digit_str;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "2183:     my_dgt_tbcd_unpack(a_bigbuf, poctets, num_string_len,",
      "2184:         &Dgt_mbcd);",
      "2186:     item = proto_tree_add_string_format(tree, header_field,",
      "2187:         tvb, curr_offset, num_string_len,",
      "2188:         a_bigbuf,",
      "2189:         \"BCD Digits: %s\",",
      "2190:         a_bigbuf);",
      "2208:         expert_add_info(pinfo, item, &ei_gsm_a_dtap_end_mark_unexpected);",
      "2210:     return (len);",
      "2211: }",
      "",
      "[Removed Lines]",
      "2192:     malformed_number = FALSE;",
      "2193:     for(i = 0; i < num_string_len - 1; i++)",
      "2194:     {",
      "2195:         oct = poctets[i];",
      "2196:         if (((oct & 0xf0) == 0xf0) || ((oct & 0x0f) == 0x0f))",
      "2197:         {",
      "2198:             malformed_number = TRUE;",
      "2199:             break;",
      "2200:         }",
      "2201:     }",
      "2203:     oct = poctets[num_string_len - 1];",
      "2204:     if ((oct & 0x0f) == 0x0f)",
      "2205:         malformed_number = TRUE;",
      "2207:     if (malformed_number)",
      "",
      "[Added Lines]",
      "2169:     digit_str = tvb_bcd_dig_to_wmem_packet_str(tvb, curr_offset, num_string_len, NULL, FALSE);",
      "2170:     item = proto_tree_add_string(tree, header_field, tvb, curr_offset, num_string_len, digit_str);",
      "2182:     if(strchr(digit_str,'?')){",
      "2184:     }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "959a29096122705153acfdea6de555e12cec3096",
      "candidate_info": {
        "commit_hash": "959a29096122705153acfdea6de555e12cec3096",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/959a29096122705153acfdea6de555e12cec3096",
        "files": [
          "epan/dissectors/packet-gsm_a_dtap.c",
          "tools/convert_proto_tree_add_text.pl"
        ],
        "message": "proto_tree_add_text -> proto_tree_add_xxx conversion.\n\nsvn path=/trunk/; revision=54274",
        "before_after_code_files": [
          "epan/dissectors/packet-gsm_a_dtap.c||epan/dissectors/packet-gsm_a_dtap.c",
          "tools/convert_proto_tree_add_text.pl||tools/convert_proto_tree_add_text.pl"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "epan/dissectors/packet-gsm_a_dtap.c||epan/dissectors/packet-gsm_a_dtap.c"
          ],
          "candidate": [
            "epan/dissectors/packet-gsm_a_dtap.c||epan/dissectors/packet-gsm_a_dtap.c"
          ]
        }
      },
      "candidate_diff": {
        "epan/dissectors/packet-gsm_a_dtap.c||epan/dissectors/packet-gsm_a_dtap.c": [
          "File: epan/dissectors/packet-gsm_a_dtap.c -> epan/dissectors/packet-gsm_a_dtap.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "397:  { 0, NULL }",
          "398: };",
          "401: #define DTAP_PD_MASK  0x0f",
          "402: #define DTAP_SKIP_MASK  0xf0",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "400: static const true_false_string tfs_acceptable_not_acceptable = { \"Acceptable\", \"Not Acceptable\" };",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "516: static int hf_gsm_a_dtap_epc_horizontal_speed = -1;",
          "517: static int hf_gsm_a_dtap_epc_gnss_tod_msec = -1;",
          "520: static gint ett_dtap_msg = -1;",
          "521: static gint ett_dtap_oct_1 = -1;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "522: static int hf_gsm_a_dtap_maximum_number_of_supported_bearers = -1;",
          "523: static int hf_gsm_a_dtap_edge_channel_codings = -1;",
          "524: static int hf_gsm_a_dtap_acceptable_channel_codings_TCH_F9_6 = -1;",
          "525: static int hf_gsm_a_dtap_assignor_assignee = -1;",
          "526: static int hf_gsm_a_dtap_configuration = -1;",
          "527: static int hf_gsm_a_dtap_de_cause_coding_standard = -1;",
          "528: static int hf_gsm_a_dtap_ss_version_indicator = -1;",
          "529: static int hf_gsm_a_dtap_mode_of_operation = -1;",
          "530: static int hf_gsm_a_dtap_bearer_cap_coding_standard = -1;",
          "531: static int hf_gsm_a_dtap_nirr = -1;",
          "532: static int hf_gsm_a_dtap_other_rate_adaption = -1;",
          "533: static int hf_gsm_a_dtap_connection_element = -1;",
          "534: static int hf_gsm_a_dtap_nic_on_tx = -1;",
          "535: static int hf_gsm_a_dtap_user_rate = -1;",
          "536: static int hf_gsm_a_dtap_protocol_discriminator = -1;",
          "537: static int hf_gsm_a_dtap_cp_cause = -1;",
          "538: static int hf_gsm_a_dtap_rate_adaption_header = -1;",
          "539: static int hf_gsm_a_dtap_synchronous = -1;",
          "540: static int hf_gsm_a_dtap_logical_link_identifier_negotiation = -1;",
          "541: static int hf_gsm_a_dtap_multi_party_auxiliary_state = -1;",
          "542: static int hf_gsm_a_dtap_parity_information = -1;",
          "543: static int hf_gsm_a_dtap_channel_coding03 = -1;",
          "544: static int hf_gsm_a_dtap_channel_coding30 = -1;",
          "545: static int hf_gsm_a_dtap_acceptable_channel_codings_ext_TCH_F43_2 = -1;",
          "546: static int hf_gsm_a_dtap_ue_positioning_technology = -1;",
          "547: static int hf_gsm_a_dtap_acceptable_channel_codings_TCH_F4_8 = -1;",
          "548: static int hf_gsm_a_dtap_number_of_spare_bits = -1;",
          "549: static int hf_gsm_a_dtap_tie = -1;",
          "550: static int hf_gsm_a_dtap_updating_type = -1;",
          "551: static int hf_gsm_a_dtap_multiple_frame_establishment_support = -1;",
          "552: static int hf_gsm_a_dtap_maximum_number_of_traffic_channels = -1;",
          "553: static int hf_gsm_a_dtap_compression = -1;",
          "554: static int hf_gsm_a_dtap_compression_up = -1;",
          "555: static int hf_gsm_a_dtap_downlink_timeslot_offset = -1;",
          "556: static int hf_gsm_a_dtap_acceptable_channel_codings_ext_TCH_F32_0 = -1;",
          "557: static int hf_gsm_a_dtap_tio = -1;",
          "558: static int hf_gsm_a_dtap_other_modem_type = -1;",
          "559: static int hf_gsm_a_dtap_other_itc = -1;",
          "560: static int hf_gsm_a_dtap_negotiation = -1;",
          "561: static int hf_gsm_a_dtap_rate_adaption = -1;",
          "562: static int hf_gsm_a_dtap_ms_positioning_technology = -1;",
          "563: static int hf_gsm_a_dtap_number_of_data_bits = -1;",
          "564: static int hf_gsm_a_dtap_follow_on_request = -1;",
          "565: static int hf_gsm_a_dtap_repeat_indicator = -1;",
          "566: static int hf_gsm_a_dtap_dst_adjustment = -1;",
          "567: static int hf_gsm_a_dtap_pcp = -1;",
          "568: static int hf_gsm_a_dtap_user_information_layer_2_protocol = -1;",
          "569: static int hf_gsm_a_dtap_structure = -1;",
          "570: static int hf_gsm_a_dtap_congestion_level = -1;",
          "571: static int hf_gsm_a_dtap_access_identity = -1;",
          "572: static int hf_gsm_a_dtap_modem_type = -1;",
          "573: static int hf_gsm_a_dtap_test_loop = -1;",
          "574: static int hf_gsm_a_dtap_layer_1_identity = -1;",
          "575: static int hf_gsm_a_dtap_ciphering_key_sequence_number70 = -1;",
          "576: static int hf_gsm_a_dtap_tp_pdu_description = -1;",
          "577: static int hf_gsm_a_dtap_dtmf = -1;",
          "578: static int hf_gsm_a_dtap_coding = -1;",
          "579: static int hf_gsm_a_dtap_nic_on_rx = -1;",
          "580: static int hf_gsm_a_dtap_emergency_number_information = -1;",
          "581: static int hf_gsm_a_dtap_uimi = -1;",
          "582: static int hf_gsm_a_dtap_number_of_stop_bits = -1;",
          "583: static int hf_gsm_a_dtap_acceptable_channel_codings_spare78 = -1;",
          "584: static int hf_gsm_a_dtap_type_of_identity = -1;",
          "585: static int hf_gsm_a_dtap_ciphering_key_sequence_number = -1;",
          "586: static int hf_gsm_a_dtap_recommendation = -1;",
          "587: static int hf_gsm_a_dtap_max_num_of_speech_bearers = -1;",
          "588: static int hf_gsm_a_dtap_keypad_information = -1;",
          "589: static int hf_gsm_a_dtap_signalling_access_protocol = -1;",
          "590: static int hf_gsm_a_dtap_user_information_layer_1_protocol = -1;",
          "591: static int hf_gsm_a_dtap_wanted_air_interface_user_rate = -1;",
          "592: static int hf_gsm_a_dtap_hold_auxiliary_state = -1;",
          "593: static int hf_gsm_a_dtap_radio_channel_requirement = -1;",
          "594: static int hf_gsm_a_dtap_channel_coding_asymmetry_indication = -1;",
          "595: static int hf_gsm_a_dtap_service_type = -1;",
          "596: static int hf_gsm_a_dtap_text_string = -1;",
          "597: static int hf_gsm_a_dtap_tp_tested_device = -1;",
          "598: static int hf_gsm_a_dtap_fixed_network_user_rate = -1;",
          "599: static int hf_gsm_a_dtap_coding_scheme = -1;",
          "600: static int hf_gsm_a_dtap_acceptable_channel_codings_ext_TCH_F28_8 = -1;",
          "601: static int hf_gsm_a_dtap_v110_x30_rate_adaptation = -1;",
          "602: static int hf_gsm_a_dtap_transfer_mode = -1;",
          "603: static int hf_gsm_a_dtap_layer_2_identity = -1;",
          "604: static int hf_gsm_a_dtap_add_ci = -1;",
          "605: static int hf_gsm_a_dtap_mm_timer = -1;",
          "606: static int hf_gsm_a_dtap_in_out_band = -1;",
          "607: static int hf_gsm_a_dtap_data = -1;",
          "608: static int hf_gsm_a_dtap_acceptable_channel_codings_TCH_F14_4 = -1;",
          "609: static int hf_gsm_a_dtap_ti_flag = -1;",
          "610: static int hf_gsm_a_dtap_time_zone_time = -1;",
          "611: static int hf_gsm_a_dtap_acceptable_channel_codings_spare20 = -1;",
          "612: static int hf_gsm_a_dtap_establishment = -1;",
          "613: static int hf_gsm_a_dtap_duplex_mode = -1;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "673: static guint16",
          "674: de_network_name(tvbuff_t *tvb, proto_tree *tree, packet_info *pinfo, guint32 offset, guint len, gchar *add_string _U_, int string_len _U_)",
          "675: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "769: static const value_string gsm_a_dtap_number_of_spare_bits_vals[] = {",
          "770:  { 0, \"this field carries no information about the number of spare bits in octet n\"},",
          "771:  { 1, \"bit 8 is spare and set to '0' in octet n\"},",
          "772:  { 2, \"bits 7 and 8 are spare and set to '0' in octet n\"},",
          "773:  { 3, \"bits 6 to 8(inclusive) are spare and set to '0' in octet n\"},",
          "774:  { 4, \"bits 5 to 8(inclusive) are spare and set to '0' in octet n\"},",
          "775:  { 5, \"bits 4 to 8(inclusive) are spare and set to '0' in octet n\"},",
          "776:  { 6, \"bits 3 to 8(inclusive) are spare and set to '0' in octet n\"},",
          "777:  { 7, \"bits 2 to 8(inclusive) are spare and set to '0' in octet n\"},",
          "778:  { 0, NULL }",
          "779: };",
          "781: const true_false_string tfs_add_ci = { \"The MS should add the letters for the Country's Initials and a separator (e.g. a space) to the text string\",",
          "782:                                        \"The MS should not add the letters for the Country's Initials to the text string\" };",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "697:  break;",
          "698:  }",
          "716:  num_spare_bits = oct & 0x07;",
          "738:  curr_offset++;",
          "740:  NO_MORE_DATA_CHECK(len);",
          "",
          "[Removed Lines]",
          "700:  other_decode_bitfield_value(a_bigbuf, oct, 0x70, 8);",
          "701:  proto_tree_add_text(tree,",
          "702:   tvb, curr_offset, 1,",
          "703:   \"%s = Coding Scheme: %s\",",
          "704:   a_bigbuf,",
          "705:   str);",
          "707:  other_decode_bitfield_value(a_bigbuf, oct, 0x08, 8);",
          "708:  proto_tree_add_text(tree,",
          "709:   tvb, curr_offset, 1,",
          "710:   \"%s = Add CI: The MS should %s\",",
          "711:   a_bigbuf,",
          "712:   (oct & 0x08) ?",
          "713:    \"add the letters for the Country's Initials and a separator (e.g. a space) to the text string\" :",
          "714:    \"not add the letters for the Country's Initials to the text string\");",
          "717:  switch (num_spare_bits)",
          "718:  {",
          "719:  case 1: str = \"bit 8 is spare and set to '0' in octet n\"; break;",
          "720:  case 2: str = \"bits 7 and 8 are spare and set to '0' in octet n\"; break;",
          "721:  case 3: str = \"bits 6 to 8(inclusive) are spare and set to '0' in octet n\"; break;",
          "722:  case 4: str = \"bits 5 to 8(inclusive) are spare and set to '0' in octet n\"; break;",
          "723:  case 5: str = \"bits 4 to 8(inclusive) are spare and set to '0' in octet n\"; break;",
          "724:  case 6: str = \"bits 3 to 8(inclusive) are spare and set to '0' in octet n\"; break;",
          "725:  case 7: str = \"bits 2 to 8(inclusive) are spare and set to '0' in octet n\"; break;",
          "726:  default:",
          "727:   str = \"this field carries no information about the number of spare bits in octet n\";",
          "728:  break;",
          "729:  }",
          "731:  other_decode_bitfield_value(a_bigbuf, oct, 0x07, 8);",
          "732:  item = proto_tree_add_text(tree,",
          "733:   tvb, curr_offset, 1,",
          "734:   \"%s = Number of spare bits in last octet: %s\",",
          "735:   a_bigbuf,",
          "736:   str);",
          "",
          "[Added Lines]",
          "811:  proto_tree_add_uint_format_value(tree, hf_gsm_a_dtap_coding_scheme, tvb, curr_offset, 1, oct, \"%s\", str);",
          "812:  proto_tree_add_item(tree, hf_gsm_a_dtap_add_ci, tvb, curr_offset, 1, ENC_NA);",
          "815:  item = proto_tree_add_item(tree, hf_gsm_a_dtap_number_of_spare_bits, tvb, curr_offset, 1, ENC_NA);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "758:    num_chars--;",
          "759:   a_bigbuf[num_chars] = '\\0';",
          "760:   net_name = gsm_sms_chars_to_utf8(a_bigbuf, num_chars);",
          "762:   break;",
          "763:  case 1:",
          "764:   net_name = tvb_get_string_enc(wmem_packet_scope(), tvb, curr_offset, (len - 1), ENC_UCS_2|ENC_BIG_ENDIAN);",
          "766:   break;",
          "767:  default:",
          "768:   proto_tree_add_text(tree,",
          "",
          "[Removed Lines]",
          "761:   proto_tree_add_text(tree, tvb , curr_offset, len - 1, \"Text String: %s\", net_name);",
          "765:   proto_tree_add_text(tree, tvb, curr_offset, len - 1, \"Text String: %s\", net_name);",
          "",
          "[Added Lines]",
          "839:   proto_tree_add_string(tree, hf_gsm_a_dtap_text_string, tvb, curr_offset, len - 1, net_name);",
          "843:   proto_tree_add_string(tree, hf_gsm_a_dtap_text_string, tvb, curr_offset, len - 1, net_name);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "879: static guint16",
          "880: de_time_zone_time(tvbuff_t *tvb, proto_tree *tree, packet_info *pinfo _U_, guint32 offset, guint len _U_, gchar *add_string _U_, int string_len _U_)",
          "881: {",
          "883:  guint32 curr_offset;",
          "884:  char    sign;",
          "886:  curr_offset = offset;",
          "904:  oct = tvb_get_guint8(tvb, curr_offset);",
          "",
          "[Removed Lines]",
          "882:  guint8 oct, oct2, oct3;",
          "888:  oct = tvb_get_guint8(tvb, curr_offset);",
          "889:  oct2 = tvb_get_guint8(tvb, curr_offset+1);",
          "890:  oct3 = tvb_get_guint8(tvb, curr_offset+2);",
          "892:  proto_tree_add_text(tree,",
          "893:   tvb, curr_offset, 3,",
          "894:   \"Year %u%u, Month %u%u, Day %u%u\",",
          "895:   oct & 0x0f,",
          "896:   (oct & 0xf0) >> 4,",
          "897:   oct2 & 0x0f,",
          "898:   (oct2 & 0xf0) >> 4,",
          "899:   oct3 & 0x0f,",
          "900:   (oct3 & 0xf0) >> 4);",
          "902:  curr_offset += 3;",
          "905:  oct2 = tvb_get_guint8(tvb, curr_offset+1);",
          "906:  oct3 = tvb_get_guint8(tvb, curr_offset+2);",
          "908:  proto_tree_add_text(tree,",
          "909:   tvb, curr_offset, 3,",
          "910:   \"Hour %u%u, Minutes %u%u, Seconds %u%u\",",
          "911:   oct & 0x0f,",
          "912:   (oct & 0xf0) >> 4,",
          "913:   oct2 & 0x0f,",
          "914:   (oct2 & 0xf0) >> 4,",
          "915:   oct3 & 0x0f,",
          "916:   (oct3 & 0xf0) >> 4);",
          "918:  curr_offset += 3;",
          "",
          "[Added Lines]",
          "960:  guint8 oct;",
          "963:  nstime_t tv;",
          "964:     struct tm tm;",
          "969:     tm.tm_wday = 0;",
          "970:     tm.tm_yday = 0;",
          "971:     tm.tm_isdst = -1;",
          "974:     tm.tm_year = (oct & 0x0f) + (((oct & 0xf0) >> 4)*10) + 100;",
          "975:  oct = tvb_get_guint8(tvb, curr_offset+1);",
          "976:     tm.tm_mon = (oct & 0x0f) + (((oct & 0xf0) >> 4)*10);",
          "977:  oct = tvb_get_guint8(tvb, curr_offset+2);",
          "978:     tm.tm_mday = (oct & 0x0f) + (((oct & 0xf0) >> 4)*10);",
          "979:  oct = tvb_get_guint8(tvb, curr_offset+3);",
          "980:     tm.tm_hour = (oct & 0x0f) + (((oct & 0xf0) >> 4)*10);",
          "981:  oct = tvb_get_guint8(tvb, curr_offset+4);",
          "982:     tm.tm_min = (oct & 0x0f) + (((oct & 0xf0) >> 4)*10);",
          "983:  oct = tvb_get_guint8(tvb, curr_offset+5);",
          "984:     tm.tm_sec = (oct & 0x0f) + (((oct & 0xf0) >> 4)*10);",
          "986:     tv.secs = mktime(&tm);",
          "987:     tv.nsecs = 0;",
          "989:     proto_tree_add_time(tree, hf_gsm_a_dtap_time_zone_time, tvb, curr_offset, 6, &tv);",
          "990:  curr_offset += 6;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "975: static guint16",
          "976: de_day_saving_time(tvbuff_t *tvb, proto_tree *tree, packet_info *pinfo _U_, guint32 offset, guint len, gchar *add_string _U_, int string_len _U_)",
          "977: {",
          "979:  guint32      curr_offset;",
          "982:  curr_offset = offset;",
          "986:  proto_tree_add_bits_item(tree, hf_gsm_a_spare_bits, tvb, curr_offset<<3, 6, ENC_BIG_ENDIAN);",
          "1005:  curr_offset++;",
          "1007:  EXTRANEOUS_DATA_CHECK(len, curr_offset - offset);",
          "",
          "[Removed Lines]",
          "978:  guint8       oct;",
          "980:  const gchar *str;",
          "984:  oct = tvb_get_guint8(tvb, curr_offset);",
          "988:  switch (oct & 0x03)",
          "989:  {",
          "990:  case 0: str = \"No adjustment for Daylight Saving Time\"; break;",
          "991:  case 1: str = \"+1 hour adjustment for Daylight Saving Time\"; break;",
          "992:  case 2: str = \"+2 hours adjustment for Daylight Saving Time\"; break;",
          "993:  default:",
          "994:   str = \"Reserved\";",
          "995:   break;",
          "996:  }",
          "998:  other_decode_bitfield_value(a_bigbuf, oct, 0x03, 8);",
          "999:  proto_tree_add_text(tree,",
          "1000:   tvb, curr_offset, 1,",
          "1001:   \"%s = %s\",",
          "1002:   a_bigbuf,",
          "1003:   str);",
          "",
          "[Added Lines]",
          "1047: static const value_string gsm_a_dtap_dst_adjustment_vals[] = {",
          "1048:  { 0, \"No adjustment for Daylight Saving Time\"},",
          "1049:  { 1, \"+1 hour adjustment for Daylight Saving Time\"},",
          "1050:  { 2, \"+2 hours adjustment for Daylight Saving Time\"},",
          "1051:  { 3, \"Reserved\"},",
          "1052:  { 0, NULL }",
          "1053: };",
          "1064:  proto_tree_add_item(tree, hf_gsm_a_dtap_dst_adjustment, tvb, curr_offset, 1, ENC_NA);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1034:   en_len = tvb_get_guint8(tvb, curr_offset);",
          "1039:   subtree = proto_item_add_subtree(item, ett_gsm_dtap_elem[DE_EMERGENCY_NUM_LIST]);",
          "1040:   proto_tree_add_item(subtree, hf_gsm_a_dtap_emerg_num_info_length, tvb, curr_offset, 1, ENC_BIG_ENDIAN);",
          "",
          "[Removed Lines]",
          "1036:   item = proto_tree_add_text(tree,",
          "1037:    tvb, curr_offset, en_len + 1,",
          "1038:    \"Emergency Number Information %u\", count);",
          "",
          "[Added Lines]",
          "1096:   item = proto_tree_add_uint(tree, hf_gsm_a_dtap_emergency_number_information,",
          "1097:    tvb, curr_offset, en_len + 1, count);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1144:   case 1:  str = \"min\"; break;",
          "1145:   case 2:  str = \"min\"; val*=6; break;",
          "1146:   case 7:  str = \"\";",
          "1149:    break;",
          "1150:   default:  str = \"min\";",
          "1151:  }",
          "1153:  if (item == NULL) {",
          "1156:  }",
          "1158:  subtree = proto_item_add_subtree(item, ett_mm_timer);",
          "",
          "[Removed Lines]",
          "1147:    item = proto_tree_add_text(tree, tvb, offset, 1,",
          "1148:                               \"MM Timer: timer is deactivated\");",
          "1154:   item = proto_tree_add_text(tree, tvb, offset, 1,",
          "1155:                              \"MM Timer: %u %s\", val, str);",
          "",
          "[Added Lines]",
          "1206:    item = proto_tree_add_uint_format_value(tree, hf_gsm_a_dtap_mm_timer, tvb, offset, 1,",
          "1207:                               oct, \"timer is deactivated\");",
          "1213:   item = proto_tree_add_uint_format_value(tree, hf_gsm_a_dtap_mm_timer, tvb, offset, 1, val,",
          "1214:                              \"%u %s\", val, str);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1168: static guint16",
          "1169: de_aux_states(tvbuff_t *tvb, proto_tree *tree, packet_info *pinfo _U_, guint32 offset, guint len, gchar *add_string _U_, int string_len _U_)",
          "1170: {",
          "1172:  guint32      curr_offset;",
          "1175:  curr_offset = offset;",
          "1179:  proto_tree_add_item(tree, hf_gsm_a_extension, tvb, curr_offset, 1, ENC_BIG_ENDIAN);",
          "1181:  proto_tree_add_bits_item(tree, hf_gsm_a_spare_bits, tvb, (curr_offset<<3)+1, 3, ENC_BIG_ENDIAN);",
          "1217:  curr_offset++;",
          "1219:  EXTRANEOUS_DATA_CHECK(len, curr_offset - offset);",
          "",
          "[Removed Lines]",
          "1171:  guint8       oct;",
          "1173:  const gchar *str;",
          "1177:  oct = tvb_get_guint8(tvb, curr_offset);",
          "1183:  switch ((oct & 0x0c) >> 2)",
          "1184:  {",
          "1185:  case 0: str = \"Idle\"; break;",
          "1186:  case 1: str = \"Hold request\"; break;",
          "1187:  case 2: str = \"Call held\"; break;",
          "1188:  default:",
          "1189:   str = \"Retrieve request\";",
          "1190:   break;",
          "1191:  }",
          "1193:  other_decode_bitfield_value(a_bigbuf, oct, 0x0c, 8);",
          "1194:  proto_tree_add_text(tree,",
          "1195:   tvb, curr_offset, 1,",
          "1196:   \"%s = Hold auxiliary state: %s\",",
          "1197:   a_bigbuf,",
          "1198:   str);",
          "1200:  switch (oct & 0x03)",
          "1201:  {",
          "1202:  case 0: str = \"Idle\"; break;",
          "1203:  case 1: str = \"MPTY request\"; break;",
          "1204:  case 2: str = \"Call in MPTY\"; break;",
          "1205:  default:",
          "1206:   str = \"Split request\";",
          "1207:   break;",
          "1208:  }",
          "1210:  other_decode_bitfield_value(a_bigbuf, oct, 0x03, 8);",
          "1211:  proto_tree_add_text(tree,",
          "1212:   tvb, curr_offset, 1,",
          "1213:   \"%s = Multi party auxiliary state: %s\",",
          "1214:   a_bigbuf,",
          "1215:   str);",
          "",
          "[Added Lines]",
          "1228: static const value_string gsm_a_dtap_hold_auxilary_state_vals[] = {",
          "1229:  { 0x00, \"Idle\" },",
          "1230:  { 0x01, \"Hold request\" },",
          "1231:  { 0x02, \"Call held\" },",
          "1232:  { 0x03, \"Retrieve request\" },",
          "1233:  { 0, NULL }",
          "1234: };",
          "1236: static const value_string gsm_a_dtap_multi_party_auxilary_state_vals[] = {",
          "1237:  { 0x00, \"Idle\" },",
          "1238:  { 0x01, \"MPTY request\" },",
          "1239:  { 0x02, \"Call in MPTY\" },",
          "1240:  { 0x03, \"Split request\" },",
          "1241:  { 0, NULL }",
          "1242: };",
          "1254:  proto_tree_add_item(tree, hf_gsm_a_dtap_hold_auxiliary_state, tvb, curr_offset, 1, ENC_NA);",
          "1255:  proto_tree_add_item(tree, hf_gsm_a_dtap_multi_party_auxiliary_state, tvb, curr_offset, 1, ENC_NA);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1263:  { 0, NULL }",
          "1264: };",
          "1266: guint16",
          "1267: de_bearer_cap(tvbuff_t *tvb, proto_tree *tree, packet_info *pinfo _U_, guint32 offset, guint len, gchar *add_string, int string_len)",
          "1268: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1305: static const value_string gsm_a_dtap_structure_vals[] = {",
          "1306:  { 0x0, \"Service data unit integrity\" },",
          "1307:  { 0x1, \"Reserved\" },",
          "1308:  { 0x2, \"Reserved\" },",
          "1309:  { 0x3, \"Unstructured\" },",
          "1310:  { 0, NULL }",
          "1311: };",
          "1313: static const value_string gsm_a_dtap_access_identity_vals[] = {",
          "1314:  { 0x0, \"Octet identifier\" },",
          "1315:  { 0x1, \"Octet identifier\" },",
          "1316:  { 0x2, \"Octet identifier\" },",
          "1317:  { 0x3, \"Reserved\" },",
          "1318:  { 0, NULL }",
          "1319: };",
          "1321: static const value_string gsm_a_dtap_rate_adaption_vals[] = {",
          "1322:  { 0x0, \"No rate adaption\" },",
          "1323:  { 0x1, \"Rate adaptation according to ITU-T Rec. V.110 and ITU-T Rec. X.30\" },",
          "1324:  { 0x2, \"Flag stuffing according to ITU-T Rec. X.31\" },",
          "1325:  { 0x3, \"Other rate adaption (see octet 5a)\" },",
          "1326:  { 0, NULL }",
          "1327: };",
          "1329: static const value_string gsm_a_dtap_signal_access_protocol_vals[] = {",
          "1330:  { 0x0, \"Reserved\" },",
          "1331:  { 0x1, \"Rate adaptation according to ITU-T Rec. V.110 and ITU-T Rec. X.30\" },",
          "1332:  { 0x2, \"Flag stuffing according to ITU-T Rec. X.31\" },",
          "1333:  { 0x3, \"Other rate adaption (see octet 5a)\" },",
          "1334:  { 0x4, \"No rate adaption\" },",
          "1335:  { 0x5, \"Rate adaptation according to ITU-T Rec. V.110 and ITU-T Rec. X.30\" },",
          "1336:  { 0x6, \"Flag stuffing according to ITU-T Rec. X.31\" },",
          "1337:  { 0x7, \"Reserved\" },",
          "1338:  { 0, NULL }",
          "1339: };",
          "1341: static const value_string gsm_a_dtap_other_itc_vals[] = {",
          "1342:  { 0x0, \"Restricted digital information\" },",
          "1343:  { 0x1, \"Restricted digital information\" },",
          "1344:  { 0x2, \"Restricted digital information\" },",
          "1345:  { 0x3, \"Reserved\" },",
          "1346:  { 0, NULL }",
          "1347: };",
          "1349: static const value_string gsm_a_dtap_other_rate_adaption_vals[] = {",
          "1350:  { 0x0, \"According to ITU-T Rec. V.120\" },",
          "1351:  { 0x1, \"According to ITU-T Rec. H.223 and ITU-T Rec. H.245\" },",
          "1352:  { 0x2, \"PIAFS\" },",
          "1353:  { 0x3, \"Reserved\" },",
          "1354:  { 0, NULL }",
          "1355: };",
          "1357: static const value_string gsm_a_dtap_user_rate_vals[] = {",
          "1358:  { 0x1, \"0.3 kbit/s (according to ITU-T Rec. X.1 and ITU-T Rec. V.110)\" },",
          "1359:  { 0x2, \"1.2 kbit/s (according to ITU-T Rec. X.1 and ITU-T Rec. V.110)\" },",
          "1360:  { 0x3, \"2.4 kbit/s (according to ITU-T Rec. X.1 and ITU-T Rec. V.110)\" },",
          "1361:  { 0x4, \"4.8 kbit/s (according to ITU-T Rec. X.1 and ITU-T Rec. V.110)\" },",
          "1362:  { 0x5, \"9.6 kbit/s (according to ITU-T Rec. X.1 and ITU-T Rec. V.110)\" },",
          "1363:  { 0x6, \"12.0 kbit/s transparent (non compliance with ITU-T Rec. X.1 and ITU-T Rec. V.110)\" },",
          "1364:  { 0x7, \"Reserved: was allocated in earlier phases of the protocol\" },",
          "1365:  { 0, NULL }",
          "1366: };",
          "1368: static const value_string gsm_a_dtap_v110_x30_rate_adaptation_vals[] = {",
          "1369:  { 0x0, \"Reserved\" },",
          "1370:  { 0x1, \"Reserved\" },",
          "1371:  { 0x2, \"8 kbit/s\" },",
          "1372:  { 0x3, \"16 kbit/s\" },",
          "1373:  { 0, NULL }",
          "1374: };",
          "1376: static const value_string gsm_a_dtap_parity_info_vals[] = {",
          "1377:  { 0x0, \"Odd\" },",
          "1378:  { 0x1, \"Reserved\" },",
          "1379:  { 0x2, \"Even\" },",
          "1380:  { 0x3, \"None\" },",
          "1381:  { 0x4, \"Forced to 0\" },",
          "1382:  { 0x5, \"Forced to 1\" },",
          "1383:  { 0x6, \"Reserved\" },",
          "1384:  { 0x7, \"Reserved\" },",
          "1385:  { 0, NULL }",
          "1386: };",
          "1388: static const value_string gsm_a_dtap_connection_element_vals[] = {",
          "1389:  { 0x0, \"Transparent\" },",
          "1390:  { 0x1, \"Non transparent (RLP)\" },",
          "1391:  { 0x2, \"Both, transparent preferred\" },",
          "1392:  { 0x3, \"Both, non transparent preferred\" },",
          "1393:  { 0, NULL }",
          "1394: };",
          "1396: static const value_string gsm_a_dtap_modem_type_vals[] = {",
          "1397:  { 0x0, \"None\" },",
          "1398:  { 0x1, \"According to ITU-T Rec. V.21\" },",
          "1399:  { 0x2, \"According to ITU-T Rec. V.22\" },",
          "1400:  { 0x3, \"According to ITU-T Rec. V.22 bis\" },",
          "1401:  { 0x4, \"Reserved: was allocated in earlier phases of the protocol\" },",
          "1402:  { 0x5, \"According to ITU-T Rec. V.26 ter\" },",
          "1403:  { 0x6, \"According to ITU-T Rec. V.32\" },",
          "1404:  { 0x7, \"Modem for undefined interface\" },",
          "1405:  { 0x8, \"Autobauding type 1\" },",
          "1406:  { 0, NULL }",
          "1407: };",
          "1409: static const value_string gsm_a_dtap_other_modem_type_vals[] = {",
          "1410:  { 0x0, \"No other modem type specified in this field\" },",
          "1411:  { 0x1, \"Reserved\" },",
          "1412:  { 0x2, \"According to ITU-T Rec. V.34\" },",
          "1413:  { 0x3, \"Reserved\" },",
          "1414:  { 0, NULL }",
          "1415: };",
          "1417: static const value_string gsm_a_dtap_fixed_network_user_rate_vals[] = {",
          "1418:     { 0x00, \"Fixed network user rate not applicable/No meaning is associated with this value\"},",
          "1419:  { 0x01, \"9.6 kbit/s (according to ITU-T Rec. X.1 and ITU-T Rec. V.110)\"},",
          "1420:  { 0x02, \"14.4 kbit/s (according to ITU-T Rec. X.1 and ITU-T Rec. V.110)\"},",
          "1421:  { 0x03, \"19.2 kbit/s (according to ITU-T Rec. X.1 and ITU-T Rec. V.110)\"},",
          "1422:  { 0x04, \"28.8 kbit/s (according to ITU-T Rec. X.1 and ITU-T Rec. V.110)\"},",
          "1423:  { 0x05, \"38.4 kbit/s (according to ITU-T Rec. X.1 and ITU-T Rec. V.110)\"},",
          "1424:  { 0x06, \"48.0 kbit/s (according to ITU-T Rec. X.1 and ITU-T Rec. V.110 (synch))\"},",
          "1425:  { 0x07, \"56.0 kbit/s (according to ITU-T Rec. X.1 and ITU-T Rec. V.110 (synch) /bit transparent)\"},",
          "1426:  { 0x08, \"64.0 kbit/s bit transparent\"},",
          "1427:  { 0x09, \"33.6 kbit/s bit transparent\"},",
          "1428:  { 0x0a, \"32.0 kbit/s (according to ITU-T Rec. I.460)\"},",
          "1429:  { 0x0b, \"31.2 kbit/s (according to ITU-T Rec. V.34)\"},",
          "1430:  { 0, NULL }",
          "1431: };",
          "1433: static const value_string gsm_a_dtap_uimi_vals[] = {",
          "1434:  { 0x0, \"not allowed/required/applicable\" },",
          "1435:  { 0x1, \"up to 1 TCH/F allowed/may be requested\" },",
          "1436:  { 0x2, \"up to 2 TCH/F allowed/may be requested\" },",
          "1437:  { 0x3, \"up to 3 TCH/F allowed/may be requested\" },",
          "1438:  { 0x4, \"up to 4 TCH/F allowed/may be requested\" },",
          "1439:  { 0x5, \"up to 4 TCH/F may be requested\" },",
          "1440:  { 0x6, \"up to 4 TCH/F may be requested\" },",
          "1441:  { 0x7, \"up to 4 TCH/F may be requested\" },",
          "1442:  { 0, NULL }",
          "1443: };",
          "1445: static const value_string gsm_a_dtap_wanted_air_rate_vals[] = {",
          "1446:  { 0x0, \"Air interface user rate not applicable/No meaning associated with this value\" },",
          "1447:  { 0x1, \"9.6 kbit/s\" },",
          "1448:  { 0x2, \"14.4 kbit/s\" },",
          "1449:  { 0x3, \"19.2 kbit/s\" },",
          "1450:  { 0x4, \"Reserved\" },",
          "1451:  { 0x5, \"28.8 kbit/s\" },",
          "1452:  { 0x6, \"38.4 kbit/s\" },",
          "1453:  { 0x7, \"43.2 kbit/s\" },",
          "1454:  { 0x8, \"57.6 kbit/s\" },",
          "1455:  { 0x9, \"interpreted by the network as 38.4 kbit/s in this version of the protocol\" },",
          "1456:  { 0xa, \"interpreted by the network as 38.4 kbit/s in this version of the protocol\" },",
          "1457:  { 0xb, \"interpreted by the network as 38.4 kbit/s in this version of the protocol\" },",
          "1458:  { 0xc, \"interpreted by the network as 38.4 kbit/s in this version of the protocol\" },",
          "1459:  { 0xd, \"Reserved\" },",
          "1460:  { 0xe, \"Reserved\" },",
          "1461:  { 0xf, \"Reserved\" },",
          "1462:  { 0, NULL }",
          "1463: };",
          "1465: static const value_string gsm_a_dtap_channel_coding_asymmetry_ind_vals[] = {",
          "1466:  { 0x0, \"Channel coding symmetry preferred\" },",
          "1467:  { 0x1, \"Uplink biased channel coding asymmetry is preferred\" },",
          "1468:  { 0x2, \"Downlink biased channel coding asymmetry is preferred\" },",
          "1469:  { 0x3, \"Unused, treat as Channel coding symmetry preferred\" },",
          "1470:  { 0, NULL }",
          "1471: };",
          "1473: static const value_string gsm_a_dtap_user_info_layer2_vals[] = {",
          "1474:  { 0x06, \"Reserved: was allocated in earlier phases of the protocol\" },",
          "1475:  { 0x08, \"According to ISO/IEC 6429, codeset 0 (DC1/DC3)\" },",
          "1476:  { 0x09, \"Reserved: was allocated but never used in earlier phases of the protocol\" },",
          "1477:  { 0x0a, \"Videotex profile 1\" },",
          "1478:  { 0x0c, \"COPnoFlCt (Character oriented Protocol with no Flow Control mechanism)\" },",
          "1479:  { 0x0d, \"Reserved: was allocated in earlier phases of the protocol\" },",
          "1480:  { 0, NULL }",
          "1481: };",
          "1483: static const true_false_string tfs_bearer_cap_coding_standard = { \"reserved\", \"GSM standardized coding\" };",
          "1484: static const true_false_string tfs_bearer_cap_transfer_mode = { \"packet\", \"circuit\" };",
          "1485: static const true_false_string tfs_bearer_cap_coding = { \"octet used for other extension of octet 3\", \"octet used for extension of information transfer capability\" };",
          "1486: static const true_false_string tfs_possible_not_possible = { \"Possible\", \"Not Possible\" };",
          "1487: static const true_false_string tfs_duplex_mode = { \"Full\", \"Half\" };",
          "1488: static const true_false_string tfs_bearer_cap_configuration = { \"Reserved\", \"Point-to-point\" };",
          "1489: static const true_false_string tfs_nirr = { \"Data up to and including 4.8 kb/s, full rate, non-transparent, 6 kb/s radio interface rate is requested\",",
          "1490:                                                              \"No meaning is associated with this value\" };",
          "1491: static const true_false_string tfs_bearer_cap_establishment = { \"Reserved\", \"Demand\" };",
          "1492: static const true_false_string tfs_included_not_included = { \"Included\", \"Not Included\" };",
          "1493: static const true_false_string tfs_frame_est_supported_not_supported = { \"Supported\", \"Not supported, only UI frames allowed\" };",
          "1494: static const true_false_string tfs_mode_of_operation = { \"Protocol sensitive\", \"Bit transparent\" };",
          "1495: static const true_false_string tfs_log_link_neg = { \"Full protocol negotiation\", \"Default, LLI=256 only\" };",
          "1496: static const true_false_string tfs_assignor_assignee = { \"Message originator is assignor only\", \"Message originator is default assignee\" };",
          "1497: static const true_false_string tfs_in_out_band = { \"Negotiation is done with USER INFORMATION messages on a temporary signalling connection\",",
          "1498:                                                    \"Negotiation is done in-band using logical link zero\" };",
          "1499: static const true_false_string tfs_asynchronous_synchronous = { \"Asynchronous\", \"Synchronous\" };",
          "1500: static const true_false_string tfs_stop_bits = { \"2\", \"1\" };",
          "1501: static const true_false_string tfs_negotiation = { \"Reserved\", \"In-band negotiation not possible\" };",
          "1502: static const true_false_string tfs_parity_bits = { \"8\", \"7\" };",
          "1503: static const true_false_string tfs_nic_on_tx = { \"requires to send data with network independent clock\",",
          "1504:                                                  \"does not require to send data with network independent clock\" };",
          "1505: static const true_false_string tfs_nic_on_rx = { \"can accept data with network independent clock\",",
          "1506:                                                  \"cannot accept data with network independent clock\" };",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1361:    break;",
          "1362:   }",
          "1385:  proto_tree_add_item(subtree, hf_gsm_a_dtap_itc, tvb, curr_offset, 1, ENC_BIG_ENDIAN);",
          "",
          "[Removed Lines]",
          "1364:  other_decode_bitfield_value(a_bigbuf, oct, 0x60, 8);",
          "1365:  proto_tree_add_text(subtree,",
          "1366:   tvb, curr_offset, 1,",
          "1367:   \"%s = Radio channel requirement: %s\",",
          "1368:   a_bigbuf,",
          "1369:   str);",
          "1371:  other_decode_bitfield_value(a_bigbuf, oct, 0x10, 8);",
          "1372:  proto_tree_add_text(subtree,",
          "1373:   tvb, curr_offset, 1,",
          "1374:   \"%s = Coding standard: %s\",",
          "1375:   a_bigbuf,",
          "1376:   (oct & 0x10) ? \"reserved\" : \"GSM standardized coding\");",
          "1378:  other_decode_bitfield_value(a_bigbuf, oct, 0x08, 8);",
          "1379:  proto_tree_add_text(subtree,",
          "1380:   tvb, curr_offset, 1,",
          "1381:   \"%s = Transfer mode: %s\",",
          "1382:   a_bigbuf,",
          "1383:   (oct & 0x08) ? \"packet\" : \"circuit\");",
          "",
          "[Added Lines]",
          "1606:  proto_tree_add_uint_format_value(subtree, hf_gsm_a_dtap_radio_channel_requirement, tvb, curr_offset, 1,",
          "1607:                                oct, \"%s\", str);",
          "1609:  proto_tree_add_item(subtree, hf_gsm_a_dtap_bearer_cap_coding_standard, tvb, curr_offset, 1, ENC_NA);",
          "1610:  proto_tree_add_item(subtree, hf_gsm_a_dtap_transfer_mode, tvb, curr_offset, 1, ENC_NA);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1412:    extended = (oct & 0x80) ? FALSE : TRUE;",
          "1414:    proto_tree_add_item(subtree, hf_gsm_a_extension, tvb, curr_offset, 1, ENC_BIG_ENDIAN);",
          "1424:    proto_tree_add_bits_item(subtree, hf_gsm_a_spare_bits, tvb, (curr_offset<<3)+2, 2, ENC_BIG_ENDIAN);",
          "1426:    proto_tree_add_item(subtree, hf_gsm_a_dtap_speech_vers_ind, tvb, curr_offset, 1, ENC_BIG_ENDIAN);",
          "1427:    curr_offset++;",
          "1428:   }",
          "",
          "[Removed Lines]",
          "1416:    other_decode_bitfield_value(a_bigbuf, oct, 0x40, 8);",
          "1417:    proto_tree_add_text(subtree,",
          "1418:     tvb, curr_offset, 1,",
          "1419:     \"%s = Coding: octet used for %s\",",
          "1420:     a_bigbuf,",
          "1421:     (oct & 0x40) ? \"other extension of octet 3\" :",
          "1422:     \"extension of information transfer capability\");",
          "",
          "[Added Lines]",
          "1642:    proto_tree_add_item(subtree, hf_gsm_a_dtap_coding, tvb, curr_offset, 1, ENC_NA);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "1445:   oct = tvb_get_guint8(tvb, curr_offset);",
          "1447:   proto_tree_add_item(subtree, hf_gsm_a_extension, tvb, curr_offset, 1, ENC_BIG_ENDIAN);",
          "1503:   curr_offset++;",
          "1505:  NO_MORE_DATA_CHECK(len);",
          "",
          "[Removed Lines]",
          "1449:   other_decode_bitfield_value(a_bigbuf, oct, 0x40, 8);",
          "1450:   proto_tree_add_text(subtree,",
          "1451:    tvb, curr_offset, 1,",
          "1452:    \"%s = Compression: data compression %s%s\",",
          "1453:    a_bigbuf,",
          "1454:    (oct & 0x40) ? \"\" : \"not \",",
          "1455:    is_uplink ? \"allowed\" : \"possible\");",
          "1457:   switch ((oct & 0x30) >> 4)",
          "1458:   {",
          "1459:   case 0x00: str = \"Service data unit integrity\"; break;",
          "1460:   case 0x03: str = \"Unstructured\"; break;",
          "1461:   default:",
          "1462:    str = \"Reserved\";",
          "1463:    break;",
          "1464:   }",
          "1466:   other_decode_bitfield_value(a_bigbuf, oct, 0x30, 8);",
          "1467:   proto_tree_add_text(subtree,",
          "1468:    tvb, curr_offset, 1,",
          "1469:    \"%s = Structure: %s\",",
          "1470:    a_bigbuf,",
          "1471:    str);",
          "1473:   other_decode_bitfield_value(a_bigbuf, oct, 0x08, 8);",
          "1474:   proto_tree_add_text(subtree,",
          "1475:    tvb, curr_offset, 1,",
          "1476:    \"%s = Duplex mode: %s\",",
          "1477:    a_bigbuf,",
          "1478:    (oct & 0x08) ? \"Full\" : \"Half\");",
          "1480:   other_decode_bitfield_value(a_bigbuf, oct, 0x04, 8);",
          "1481:   proto_tree_add_text(subtree,",
          "1482:    tvb, curr_offset, 1,",
          "1483:    \"%s = Configuration: %s\",",
          "1484:    a_bigbuf,",
          "1485:    (oct & 0x04) ? \"Reserved\" : \"Point-to-point\");",
          "1487:   other_decode_bitfield_value(a_bigbuf, oct, 0x02, 8);",
          "1488:   proto_tree_add_text(subtree,",
          "1489:    tvb, curr_offset, 1,",
          "1490:    \"%s = NIRR: %s\",",
          "1491:    a_bigbuf,",
          "1492:    (oct & 0x02) ?",
          "1493:    \"Data up to and including 4.8 kb/s, full rate, non-transparent, 6 kb/s radio interface rate is requested\" :",
          "1494:    \"No meaning is associated with this value\");",
          "1496:   other_decode_bitfield_value(a_bigbuf, oct, 0x01, 8);",
          "1497:   proto_tree_add_text(subtree,",
          "1498:    tvb, curr_offset, 1,",
          "1499:    \"%s = Establishment: %s\",",
          "1500:    a_bigbuf,",
          "1501:    (oct & 0x01) ? \"Reserved\" : \"Demand\");",
          "",
          "[Added Lines]",
          "1666:   proto_tree_add_item(subtree, is_uplink ? hf_gsm_a_dtap_compression_up : hf_gsm_a_dtap_compression,",
          "1667:    tvb, curr_offset, 1, ENC_NA);",
          "1669:   proto_tree_add_item(subtree, hf_gsm_a_dtap_structure, tvb, curr_offset, 1, ENC_NA);",
          "1670:   proto_tree_add_item(subtree, hf_gsm_a_dtap_duplex_mode, tvb, curr_offset, 1, ENC_NA);",
          "1671:   proto_tree_add_item(subtree, hf_gsm_a_dtap_configuration, tvb, curr_offset, 1, ENC_NA);",
          "1672:   proto_tree_add_item(subtree, hf_gsm_a_dtap_nirr, tvb, curr_offset, 1, ENC_NA);",
          "1673:   proto_tree_add_item(subtree, hf_gsm_a_dtap_establishment, tvb, curr_offset, 1, ENC_NA);",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "1518:  extended = (oct & 0x80) ? FALSE : TRUE;",
          "1520:  proto_tree_add_item(subtree, hf_gsm_a_extension, tvb, curr_offset, 1, ENC_BIG_ENDIAN);",
          "1566:  curr_offset++;",
          "1568:  NO_MORE_DATA_CHECK(len);",
          "",
          "[Removed Lines]",
          "1522:  other_decode_bitfield_value(a_bigbuf, oct, 0x60, 8);",
          "1523:  proto_tree_add_text(subtree,",
          "1524:   tvb, curr_offset, 1,",
          "1525:   \"%s = Access Identity: %s\",",
          "1526:   a_bigbuf,",
          "1527:   (oct & 0x60) ? \"Reserved\" : \"Octet identifier\");",
          "1529:  switch ((oct & 0x18) >> 3)",
          "1530:  {",
          "1531:  case 0x00: str = \"No rate adaption\"; break;",
          "1532:  case 0x01: str = \"Rate adaptation according to ITU-T Rec. V.110 and ITU-T Rec. X.30\"; break;",
          "1533:  case 0x02: str = \"Flag stuffing according to ITU-T Rec. X.31\"; break;",
          "1534:  default:",
          "1535:   str = \"Other rate adaption (see octet 5a)\";",
          "1536:   break;",
          "1537:  }",
          "1539:  other_decode_bitfield_value(a_bigbuf, oct, 0x18, 8);",
          "1540:  proto_tree_add_text(subtree,",
          "1541:   tvb, curr_offset, 1,",
          "1542:   \"%s = Rate Adaption: %s\",",
          "1543:   a_bigbuf,",
          "1544:   str);",
          "1546:  switch (oct & 0x07)",
          "1547:  {",
          "1548:  case 0x01: str = \"According to ITU-T Rec. Q.920 and ITU-T Rec. Q.930\"; break;",
          "1549:  case 0x02: str = \"Reserved: was allocated in earlier phases of the protocol\"; break;",
          "1550:  case 0x03: str = \"Reserved: was allocated in earlier phases of the protocol\"; break;",
          "1551:  case 0x04: str = \"Reserved: was allocated in earlier phases of the protocol\"; break;",
          "1552:  case 0x05: str = \"Reserved: was allocated in earlier phases of the protocol\"; break;",
          "1553:  case 0x06: str = \"Reserved: was allocated in earlier phases of the protocol\"; break;",
          "1554:  default:",
          "1555:   str = \"Reserved\";",
          "1556:   break;",
          "1557:  }",
          "1559:  other_decode_bitfield_value(a_bigbuf, oct, 0x07, 8);",
          "1560:  proto_tree_add_text(subtree,",
          "1561:   tvb, curr_offset, 1,",
          "1562:   \"%s = Signalling Access Protocol: %s\",",
          "1563:   a_bigbuf,",
          "1564:   str);",
          "",
          "[Added Lines]",
          "1692:  proto_tree_add_item(subtree, hf_gsm_a_dtap_access_identity, tvb, curr_offset, 1, ENC_NA);",
          "1693:  proto_tree_add_item(subtree, hf_gsm_a_dtap_rate_adaption, tvb, curr_offset, 1, ENC_NA);",
          "1694:  proto_tree_add_item(subtree, hf_gsm_a_dtap_signalling_access_protocol, tvb, curr_offset, 1, ENC_NA);",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "1583:  extended = (oct & 0x80) ? FALSE : TRUE;",
          "1585:  proto_tree_add_item(subtree, hf_gsm_a_extension, tvb, curr_offset, 1, ENC_BIG_ENDIAN);",
          "1611:  proto_tree_add_bits_item(tree, hf_gsm_a_spare_bits, tvb, (curr_offset<<3)+5, 3, ENC_BIG_ENDIAN);",
          "1613:  curr_offset++;",
          "1615:  NO_MORE_DATA_CHECK(len);",
          "",
          "[Removed Lines]",
          "1587:  other_decode_bitfield_value(a_bigbuf, oct, 0x60, 8);",
          "1588:  proto_tree_add_text(subtree,",
          "1589:   tvb, curr_offset, 1,",
          "1590:   \"%s = Other ITC: %s\",",
          "1591:   a_bigbuf,",
          "1592:   (oct & 0x60) ? \"Reserved\" : \"Restricted digital information\");",
          "1594:  switch ((oct & 0x18) >> 3)",
          "1595:  {",
          "1596:  case 0x00: str = \"According to ITU-T Rec. V.120\"; break;",
          "1597:  case 0x01: str = \"According to ITU-T Rec. H.223 and ITU-T Rec. H.245\"; break;",
          "1598:  case 0x02: str = \"PIAFS\"; break;",
          "1599:  default:",
          "1600:   str = \"Reserved\";",
          "1601:   break;",
          "1602:  }",
          "1604:  other_decode_bitfield_value(a_bigbuf, oct, 0x18, 8);",
          "1605:  proto_tree_add_text(subtree,",
          "1606:   tvb, curr_offset, 1,",
          "1607:   \"%s = Other Rate Adaption: %s\",",
          "1608:   a_bigbuf,",
          "1609:   str);",
          "",
          "[Added Lines]",
          "1715:  proto_tree_add_item(subtree, hf_gsm_a_dtap_other_itc, tvb, curr_offset, 1, ENC_NA);",
          "1716:  proto_tree_add_item(subtree, hf_gsm_a_dtap_other_rate_adaption, tvb, curr_offset, 1, ENC_NA);",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "1628:  oct = tvb_get_guint8(tvb, curr_offset);",
          "1630:  proto_tree_add_item(subtree, hf_gsm_a_extension, tvb, curr_offset, 1, ENC_BIG_ENDIAN);",
          "1676:  proto_tree_add_bits_item(tree, hf_gsm_a_spare_bits, tvb, (curr_offset<<3)+7, 1, ENC_BIG_ENDIAN);",
          "1678:  curr_offset++;",
          "",
          "[Removed Lines]",
          "1632:  other_decode_bitfield_value(a_bigbuf, oct, 0x40, 8);",
          "1633:  proto_tree_add_text(subtree,",
          "1634:   tvb, curr_offset, 1,",
          "1635:   \"%s = Rate Adaption Header: %sincluded\",",
          "1636:   a_bigbuf,",
          "1637:   (oct & 0x40) ? \"\" : \"not \");",
          "1639:  other_decode_bitfield_value(a_bigbuf, oct, 0x20, 8);",
          "1640:  proto_tree_add_text(subtree,",
          "1641:   tvb, curr_offset, 1,",
          "1642:   \"%s = Multiple frame establishment support in data link: %s\",",
          "1643:   a_bigbuf,",
          "1644:   (oct & 0x20) ? \"Supported\" : \"Not supported, only UI frames allowed\");",
          "1646:  other_decode_bitfield_value(a_bigbuf, oct, 0x10, 8);",
          "1647:  proto_tree_add_text(subtree,",
          "1648:   tvb, curr_offset, 1,",
          "1649:   \"%s = Mode of operation: %s\",",
          "1650:   a_bigbuf,",
          "1651:   (oct & 0x10) ? \"Protocol sensitive\" : \"Bit transparent\");",
          "1653:  other_decode_bitfield_value(a_bigbuf, oct, 0x08, 8);",
          "1654:  proto_tree_add_text(subtree,",
          "1655:   tvb, curr_offset, 1,",
          "1656:   \"%s = Logical link identifier negotiation: %s\",",
          "1657:   a_bigbuf,",
          "1658:   (oct & 0x08) ? \"Full protocol negotiation\" : \"Default, LLI=256 only\");",
          "1660:  other_decode_bitfield_value(a_bigbuf, oct, 0x04, 8);",
          "1661:  proto_tree_add_text(subtree,",
          "1662:   tvb, curr_offset, 1,",
          "1663:   \"%s = Assignor/Assignee: Message originator is '%s'\",",
          "1664:   a_bigbuf,",
          "1665:   (oct & 0x04) ? \"assignor only\" : \"default assignee\");",
          "1667:  other_decode_bitfield_value(a_bigbuf, oct, 0x02, 8);",
          "1668:  proto_tree_add_text(subtree,",
          "1669:   tvb, curr_offset, 1,",
          "1670:   \"%s = In band/Out of band negotiation: Negotiation is done %s\",",
          "1671:   a_bigbuf,",
          "1672:   (oct & 0x02) ?",
          "1673:   \"with USER INFORMATION messages on a temporary signalling connection\" :",
          "1674:   \"in-band using logical link zero\");",
          "",
          "[Added Lines]",
          "1736:  proto_tree_add_item(subtree, hf_gsm_a_dtap_rate_adaption_header, tvb, curr_offset, 1, ENC_NA);",
          "1737:  proto_tree_add_item(subtree, hf_gsm_a_dtap_multiple_frame_establishment_support, tvb, curr_offset, 1, ENC_NA);",
          "1738:  proto_tree_add_item(subtree, hf_gsm_a_dtap_mode_of_operation, tvb, curr_offset, 1, ENC_NA);",
          "1739:  proto_tree_add_item(subtree, hf_gsm_a_dtap_logical_link_identifier_negotiation, tvb, curr_offset, 1, ENC_NA);",
          "1740:  proto_tree_add_item(subtree, hf_gsm_a_dtap_assignor_assignee, tvb, curr_offset, 1, ENC_NA);",
          "1741:  proto_tree_add_item(subtree, hf_gsm_a_dtap_in_out_band, tvb, curr_offset, 1, ENC_NA);",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "1697:  proto_tree_add_item(subtree, hf_gsm_a_extension, tvb, curr_offset, 1, ENC_BIG_ENDIAN);",
          "1711:   (oct & 0x1e) ? \"Reserved\" : \"Default layer 1 protocol\");",
          "1720:  curr_offset++;",
          "1722:  NO_MORE_DATA_CHECK(len);",
          "",
          "[Removed Lines]",
          "1699:  other_decode_bitfield_value(a_bigbuf, oct, 0x60, 8);",
          "1700:  proto_tree_add_text(subtree,",
          "1701:   tvb, curr_offset, 1,",
          "1702:   \"%s = Layer 1 Identity: %s\",",
          "1703:   a_bigbuf,",
          "1704:   ((oct & 0x60) == 0x20) ? \"Octet identifier\" : \"Reserved\");",
          "1706:  other_decode_bitfield_value(a_bigbuf, oct, 0x1e, 8);",
          "1707:  proto_tree_add_text(subtree,",
          "1708:   tvb, curr_offset, 1,",
          "1709:   \"%s = User information layer 1 protocol: %s\",",
          "1710:   a_bigbuf,",
          "1713:  other_decode_bitfield_value(a_bigbuf, oct, 0x01, 8);",
          "1714:  proto_tree_add_text(subtree,",
          "1715:   tvb, curr_offset, 1,",
          "1716:   \"%s = Synchronous/asynchronous: %s\",",
          "1717:   a_bigbuf,",
          "1718:   (oct & 0x01) ? \"Asynchronous\" : \"Synchronous\");",
          "",
          "[Added Lines]",
          "1765:  proto_tree_add_uint_format_value(subtree, hf_gsm_a_dtap_layer_1_identity, tvb, curr_offset, 1, oct,",
          "1766:   \"%s\", ((oct & 0x60) == 0x20) ? \"Octet identifier\" : \"Reserved\");",
          "1768:  proto_tree_add_uint_format_value(subtree, hf_gsm_a_dtap_user_information_layer_1_protocol,",
          "1769:   tvb, curr_offset, 1, oct, \"%s\",",
          "1772:  proto_tree_add_item(subtree, hf_gsm_a_dtap_synchronous, tvb, curr_offset, 1, ENC_NA);",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "1737:  extended = (oct & 0x80) ? FALSE : TRUE;",
          "1739:  proto_tree_add_item(subtree, hf_gsm_a_extension, tvb, curr_offset, 1, ENC_BIG_ENDIAN);",
          "1783:  curr_offset++;",
          "",
          "[Removed Lines]",
          "1741:  other_decode_bitfield_value(a_bigbuf, oct, 0x40, 8);",
          "1742:  proto_tree_add_text(subtree,",
          "1743:   tvb, curr_offset, 1,",
          "1744:   \"%s = Number of Stop Bits: %s\",",
          "1745:   a_bigbuf,",
          "1746:   (oct & 0x40) ? \"2\" : \"1\");",
          "1748:  other_decode_bitfield_value(a_bigbuf, oct, 0x20, 8);",
          "1749:  proto_tree_add_text(subtree,",
          "1750:   tvb, curr_offset, 1,",
          "1751:   \"%s = Negotiation: %s\",",
          "1752:   a_bigbuf,",
          "1753:   (oct & 0x20) ? \"Reserved\" : \"In-band negotiation not possible\");",
          "1755:  other_decode_bitfield_value(a_bigbuf, oct, 0x10, 8);",
          "1756:  proto_tree_add_text(subtree,",
          "1757:   tvb, curr_offset, 1,",
          "1758:   \"%s = Number of data bits excluding parity bit if present: %s\",",
          "1759:   a_bigbuf,",
          "1760:   (oct & 0x10) ? \"8\" : \"7\");",
          "1762:  switch (oct & 0x0f)",
          "1763:  {",
          "1764:  case 0x01: str = \"0.3 kbit/s (according to ITU-T Rec. X.1 and ITU-T Rec. V.110)\"; break;",
          "1765:  case 0x02: str = \"1.2 kbit/s (according to ITU-T Rec. X.1 and ITU-T Rec. V.110)\"; break;",
          "1766:  case 0x03: str = \"2.4 kbit/s (according to ITU-T Rec. X.1 and ITU-T Rec. V.110)\"; break;",
          "1767:  case 0x04: str = \"4.8 kbit/s (according to ITU-T Rec. X.1 and ITU-T Rec. V.110)\"; break;",
          "1768:  case 0x05: str = \"9.6 kbit/s (according to ITU-T Rec. X.1 and ITU-T Rec. V.110)\"; break;",
          "1769:  case 0x06: str = \"12.0 kbit/s transparent (non compliance with ITU-T Rec. X.1 and ITU-T Rec. V.110)\"; break;",
          "1770:  case 0x07: str = \"Reserved: was allocated in earlier phases of the protocol\"; break;",
          "1771:  default:",
          "1772:   str = \"Reserved\";",
          "1773:   break;",
          "1774:  }",
          "1776:  other_decode_bitfield_value(a_bigbuf, oct, 0x0f, 8);",
          "1777:  proto_tree_add_text(subtree,",
          "1778:   tvb, curr_offset, 1,",
          "1779:   \"%s = User rate: %s\",",
          "1780:   a_bigbuf,",
          "1781:   str);",
          "",
          "[Added Lines]",
          "1793:  proto_tree_add_item(subtree, hf_gsm_a_dtap_number_of_stop_bits, tvb, curr_offset, 1, ENC_NA);",
          "1794:  proto_tree_add_item(subtree, hf_gsm_a_dtap_negotiation, tvb, curr_offset, 1, ENC_NA);",
          "1795:  proto_tree_add_item(subtree, hf_gsm_a_dtap_number_of_data_bits, tvb, curr_offset, 1, ENC_NA);",
          "1797:  proto_tree_add_uint_format_value(subtree, hf_gsm_a_dtap_user_rate,",
          "1798:   tvb, curr_offset, 1, oct, \"%s\", val_to_str_const(oct & 0xF, gsm_a_dtap_user_rate_vals, \"Reserved\"));",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "1800:  extended = (oct & 0x80) ? FALSE : TRUE;",
          "1802:  proto_tree_add_item(subtree, hf_gsm_a_extension, tvb, curr_offset, 1, ENC_BIG_ENDIAN);",
          "1853:  curr_offset++;",
          "1855:  NO_MORE_DATA_CHECK(len);",
          "",
          "[Removed Lines]",
          "1804:  switch ((oct & 0x60) >> 5)",
          "1805:  {",
          "1806:  case 0x02: str = \"8 kbit/s\"; break;",
          "1807:  case 0x03: str = \"16 kbit/s\"; break;",
          "1808:  default:",
          "1809:   str = \"Reserved\";",
          "1810:   break;",
          "1811:  }",
          "1813:  other_decode_bitfield_value(a_bigbuf, oct, 0x60, 8);",
          "1814:  proto_tree_add_text(subtree,",
          "1815:   tvb, curr_offset, 1,",
          "1816:   \"%s = V.110/X.30 rate adaptation Intermediate rate: %s\",",
          "1817:   a_bigbuf,",
          "1818:   str);",
          "1820:  other_decode_bitfield_value(a_bigbuf, oct, 0x10, 8);",
          "1821:  proto_tree_add_text(subtree,",
          "1822:   tvb, curr_offset, 1,",
          "1823:   \"%s = Network independent clock (NIC) on transmission (Tx): %s to send data with network independent clock\",",
          "1824:   a_bigbuf,",
          "1825:   (oct & 0x10) ? \"requires\" : \"does not require\");",
          "1827:  other_decode_bitfield_value(a_bigbuf, oct, 0x08, 8);",
          "1828:  proto_tree_add_text(subtree,",
          "1829:   tvb, curr_offset, 1,",
          "1830:   \"%s = Network independent clock (NIC) on reception (Rx): %s accept data with network independent clock\",",
          "1831:   a_bigbuf,",
          "1832:   (oct & 0x08) ? \"can\" : \"cannot\");",
          "1834:  switch (oct & 0x07)",
          "1835:  {",
          "1836:  case 0x00: str = \"Odd\"; break;",
          "1837:  case 0x02: str = \"Even\"; break;",
          "1838:  case 0x03: str = \"None\"; break;",
          "1839:  case 0x04: str = \"Forced to 0\"; break;",
          "1840:  case 0x05: str = \"Forced to 1\"; break;",
          "1841:  default:",
          "1842:   str = \"Reserved\";",
          "1843:   break;",
          "1844:  }",
          "1846:  other_decode_bitfield_value(a_bigbuf, oct, 0x07, 8);",
          "1847:  proto_tree_add_text(subtree,",
          "1848:   tvb, curr_offset, 1,",
          "1849:   \"%s = Parity information: %s\",",
          "1850:   a_bigbuf,",
          "1851:   str);",
          "",
          "[Added Lines]",
          "1820:  proto_tree_add_item(subtree, hf_gsm_a_dtap_v110_x30_rate_adaptation, tvb, curr_offset, 1, ENC_NA);",
          "1821:  proto_tree_add_item(subtree, hf_gsm_a_dtap_nic_on_tx, tvb, curr_offset, 1, ENC_NA);",
          "1822:  proto_tree_add_item(subtree, hf_gsm_a_dtap_nic_on_rx, tvb, curr_offset, 1, ENC_NA);",
          "1823:  proto_tree_add_item(subtree, hf_gsm_a_dtap_parity_information, tvb, curr_offset, 1, ENC_NA);",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "1870:  extended = (oct & 0x80) ? FALSE : TRUE;",
          "1872:  proto_tree_add_item(subtree, hf_gsm_a_extension, tvb, curr_offset, 1, ENC_BIG_ENDIAN);",
          "1914:  curr_offset++;",
          "",
          "[Removed Lines]",
          "1874:  switch ((oct & 0x60) >> 5)",
          "1875:  {",
          "1876:  case 0x01: str = \"Non transparent (RLP)\"; break;",
          "1877:  case 0x02: str = \"Both, transparent preferred\"; break;",
          "1878:  case 0x03: str = \"Both, non transparent preferred\"; break;",
          "1879:  default:",
          "1880:   str = \"Transparent\";",
          "1881:   break;",
          "1882:  }",
          "1884:  other_decode_bitfield_value(a_bigbuf, oct, 0x60, 8);",
          "1885:  proto_tree_add_text(subtree,",
          "1886:   tvb, curr_offset, 1,",
          "1887:   \"%s = Connection element: %s\",",
          "1888:   a_bigbuf,",
          "1889:   str);",
          "1891:  switch (oct & 0x1f)",
          "1892:  {",
          "1893:  case 0x00: str = \"None\"; break;",
          "1894:  case 0x01: str = \"According to ITU-T Rec. V.21\"; break;",
          "1895:  case 0x02: str = \"According to ITU-T Rec. V.22\"; break;",
          "1896:  case 0x03: str = \"According to ITU-T Rec. V.22 bis\"; break;",
          "1897:  case 0x04: str = \"Reserved: was allocated in earlier phases of the protocol\"; break;",
          "1898:  case 0x05: str = \"According to ITU-T Rec. V.26 ter\"; break;",
          "1899:  case 0x06: str = \"According to ITU-T Rec. V.32\"; break;",
          "1900:  case 0x07: str = \"Modem for undefined interface\"; break;",
          "1901:  case 0x08: str = \"Autobauding type 1\"; break;",
          "1902:  default:",
          "1903:   str = \"Reserved\";",
          "1904:   break;",
          "1905:  }",
          "1907:  other_decode_bitfield_value(a_bigbuf, oct, 0x1f, 8);",
          "1908:  proto_tree_add_text(subtree,",
          "1909:   tvb, curr_offset, 1,",
          "1910:   \"%s = Modem type: %s\",",
          "1911:   a_bigbuf,",
          "1912:   str);",
          "",
          "[Added Lines]",
          "1844:  proto_tree_add_item(subtree, hf_gsm_a_dtap_connection_element, tvb, curr_offset, 1, ENC_NA);",
          "1845:  proto_tree_add_uint_format_value(subtree, hf_gsm_a_dtap_modem_type, tvb, curr_offset, 1,",
          "1846:   oct, \"%s\", val_to_str_const(oct & 0x1f, gsm_a_dtap_modem_type_vals, \"Reserved\"));",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "1931:  extended = (oct & 0x80) ? FALSE : TRUE;",
          "1933:  proto_tree_add_item(subtree, hf_gsm_a_extension, tvb, curr_offset, 1, ENC_BIG_ENDIAN);",
          "1977:  curr_offset++;",
          "1979:  NO_MORE_DATA_CHECK(len);",
          "",
          "[Removed Lines]",
          "1935:  switch ((oct & 0x60) >> 5)",
          "1936:  {",
          "1937:  case 0x00: str = \"No other modem type specified in this field\"; break;",
          "1938:  case 0x02: str = \"According to ITU-T Rec. V.34\"; break;",
          "1939:  default:",
          "1940:   str = \"Reserved\";",
          "1941:   break;",
          "1942:  }",
          "1944:  other_decode_bitfield_value(a_bigbuf, oct, 0x60, 8);",
          "1945:  proto_tree_add_text(subtree,",
          "1946:   tvb, curr_offset, 1,",
          "1947:   \"%s = Other modem type: %s\",",
          "1948:   a_bigbuf,",
          "1949:   str);",
          "1951:  switch (oct & 0x1f)",
          "1952:  {",
          "1953:  case 0x00: str = \"Fixed network user rate not applicable/No meaning is associated with this value\"; break;",
          "1954:  case 0x01: str = \"9.6 kbit/s (according to ITU-T Rec. X.1 and ITU-T Rec. V.110)\"; break;",
          "1955:  case 0x02: str = \"14.4 kbit/s (according to ITU-T Rec. X.1 and ITU-T Rec. V.110)\"; break;",
          "1956:  case 0x03: str = \"19.2 kbit/s (according to ITU-T Rec. X.1 and ITU-T Rec. V.110)\"; break;",
          "1957:  case 0x04: str = \"28.8 kbit/s (according to ITU-T Rec. X.1 and ITU-T Rec. V.110)\"; break;",
          "1958:  case 0x05: str = \"38.4 kbit/s (according to ITU-T Rec. X.1 and ITU-T Rec. V.110)\"; break;",
          "1959:  case 0x06: str = \"48.0 kbit/s (according to ITU-T Rec. X.1 and ITU-T Rec. V.110 (synch))\"; break;",
          "1960:  case 0x07: str = \"56.0 kbit/s (according to ITU-T Rec. X.1 and ITU-T Rec. V.110 (synch) /bit transparent)\"; break;",
          "1961:  case 0x08: str = \"64.0 kbit/s bit transparent\"; break;",
          "1962:  case 0x09: str = \"33.6 kbit/s bit transparent\"; break;",
          "1963:  case 0x0a: str = \"32.0 kbit/s (according to ITU-T Rec. I.460)\"; break;",
          "1964:  case 0x0b: str = \"31.2 kbit/s (according to ITU-T Rec. V.34)\"; break;",
          "1965:  default:",
          "1966:   str = \"Reserved\";",
          "1967:   break;",
          "1968:  }",
          "1970:  other_decode_bitfield_value(a_bigbuf, oct, 0x1f, 8);",
          "1971:  proto_tree_add_text(subtree,",
          "1972:   tvb, curr_offset, 1,",
          "1973:   \"%s = Fixed network user rate: %s\",",
          "1974:   a_bigbuf,",
          "1975:   str);",
          "",
          "[Added Lines]",
          "1868:  proto_tree_add_item(subtree, hf_gsm_a_dtap_other_modem_type, tvb, curr_offset, 1, ENC_NA);",
          "1869:  proto_tree_add_uint_format_value(subtree, hf_gsm_a_dtap_fixed_network_user_rate, tvb, curr_offset, 1,",
          "1870:   oct, \"%s\", val_to_str_const(oct & 0x1f, gsm_a_dtap_fixed_network_user_rate_vals, \"Reserved\"));",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "1998:  if (is_uplink == IS_UPLINK_TRUE)",
          "1999:  {",
          "2033:  }",
          "2034:  else",
          "2035:  {",
          "2047:  }",
          "2049:  curr_offset++;",
          "",
          "[Removed Lines]",
          "2000:   other_decode_bitfield_value(a_bigbuf, oct, 0x40, 8);",
          "2001:   proto_tree_add_text(subtree,",
          "2002:   tvb, curr_offset, 1,",
          "2003:   \"%s = Acceptable channel codings: TCH/F14.4 %sacceptable\",",
          "2004:   a_bigbuf,",
          "2005:   (oct & 0x40) ? \"\" : \"not \");",
          "2007:   other_decode_bitfield_value(a_bigbuf, oct, 0x20, 8);",
          "2008:   proto_tree_add_text(subtree,",
          "2009:   tvb, curr_offset, 1,",
          "2010:   \"%s = Acceptable channel codings: Spare\",",
          "2011:   a_bigbuf);",
          "2013:   other_decode_bitfield_value(a_bigbuf, oct, 0x10, 8);",
          "2014:   proto_tree_add_text(subtree,",
          "2015:   tvb, curr_offset, 1,",
          "2016:   \"%s = Acceptable channel codings: TCH/F9.6 %sacceptable\",",
          "2017:   a_bigbuf,",
          "2018:   (oct & 0x10) ? \"\" : \"not \");",
          "2020:   other_decode_bitfield_value(a_bigbuf, oct, 0x08, 8);",
          "2021:   proto_tree_add_text(subtree,",
          "2022:   tvb, curr_offset, 1,",
          "2023:   \"%s = Acceptable channel codings: TCH/F4.8 %sacceptable\",",
          "2024:   a_bigbuf,",
          "2025:   (oct & 0x08) ? \"\" : \"not \");",
          "2027:   other_decode_bitfield_value(a_bigbuf, oct, 0x07, 8);",
          "2028:   proto_tree_add_text(subtree,",
          "2029:   tvb, curr_offset, 1,",
          "2030:   \"%s = Maximum number of traffic channels: %u TCH\",",
          "2031:   a_bigbuf,",
          "2032:   (oct & 0x07) + 1);",
          "2036:   other_decode_bitfield_value(a_bigbuf, oct, 0x78, 8);",
          "2037:   proto_tree_add_text(subtree,",
          "2038:   tvb, curr_offset, 1,",
          "2039:   \"%s = Acceptable channel codings: Spare\",",
          "2040:   a_bigbuf);",
          "2042:   other_decode_bitfield_value(a_bigbuf, oct, 0x07, 8);",
          "2043:   proto_tree_add_text(subtree,",
          "2044:   tvb, curr_offset, 1,",
          "2045:   \"%s = Maximum number of traffic channels: Spare\",",
          "2046:   a_bigbuf);",
          "",
          "[Added Lines]",
          "1894:   proto_tree_add_item(subtree, hf_gsm_a_dtap_acceptable_channel_codings_TCH_F14_4, tvb, curr_offset, 1, ENC_NA);",
          "1895:   proto_tree_add_item(subtree, hf_gsm_a_dtap_acceptable_channel_codings_spare20, tvb, curr_offset, 1, ENC_NA);",
          "1896:   proto_tree_add_item(subtree, hf_gsm_a_dtap_acceptable_channel_codings_TCH_F9_6, tvb, curr_offset, 1, ENC_NA);",
          "1897:   proto_tree_add_item(subtree, hf_gsm_a_dtap_acceptable_channel_codings_TCH_F4_8, tvb, curr_offset, 1, ENC_NA);",
          "1899:   proto_tree_add_uint_format_value(subtree, hf_gsm_a_dtap_maximum_number_of_traffic_channels, tvb, curr_offset, 1,",
          "1900:             (oct & 0x07) + 1, \"%u TCH\", (oct & 0x07) + 1);",
          "1904:   proto_tree_add_uint_format_value(subtree, hf_gsm_a_dtap_acceptable_channel_codings_spare78, tvb, curr_offset, 1,",
          "1905:             oct, \"Spare\");",
          "1906:   proto_tree_add_uint_format_value(subtree, hf_gsm_a_dtap_maximum_number_of_traffic_channels, tvb, curr_offset, 1,",
          "1907:             oct, \"Spare\");",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "2066:  extended = (oct & 0x80) ? FALSE : TRUE;",
          "2068:  proto_tree_add_item(subtree, hf_gsm_a_extension, tvb, curr_offset, 1, ENC_BIG_ENDIAN);",
          "2089:  if (is_uplink == IS_UPLINK_TRUE)",
          "2090:  {",
          "2116:  }",
          "2117:  else",
          "2118:  {",
          "2124:  }",
          "2126:  curr_offset++;",
          "",
          "[Removed Lines]",
          "2070:  switch ((oct & 0x70) >> 4)",
          "2071:  {",
          "2072:  case 0x00: str = \"not allowed/required/applicable\"; break;",
          "2073:  case 0x01: str = \"up to 1 TCH/F allowed/may be requested\"; break;",
          "2074:  case 0x02: str = \"up to 2 TCH/F allowed/may be requested\"; break;",
          "2075:  case 0x03: str = \"up to 3 TCH/F allowed/may be requested\"; break;",
          "2076:  case 0x04: str = \"up to 4 TCH/F allowed/may be requested\"; break;",
          "2077:  default:",
          "2078:   str = \"up to 4 TCH/F may be requested\";",
          "2079:   break;",
          "2080:  }",
          "2082:  other_decode_bitfield_value(a_bigbuf, oct, 0x70, 8);",
          "2083:  proto_tree_add_text(subtree,",
          "2084:   tvb, curr_offset, 1,",
          "2085:   \"%s = UIMI, User initiated modification indication: %s\",",
          "2086:   a_bigbuf,",
          "2087:   str);",
          "2091:   switch (oct & 0x0f)",
          "2092:   {",
          "2093:   case 0x00: str = \"Air interface user rate not applicable/No meaning associated with this value\"; break;",
          "2094:   case 0x01: str = \"9.6 kbit/s\"; break;",
          "2095:   case 0x02: str = \"14.4 kbit/s\"; break;",
          "2096:   case 0x03: str = \"19.2 kbit/s\"; break;",
          "2097:   case 0x05: str = \"28.8 kbit/s\"; break;",
          "2098:   case 0x06: str = \"38.4 kbit/s\"; break;",
          "2099:   case 0x07: str = \"43.2 kbit/s\"; break;",
          "2100:   case 0x08: str = \"57.6 kbit/s\"; break;",
          "2101:   case 0x09: str = \"interpreted by the network as 38.4 kbit/s in this version of the protocol\"; break;",
          "2102:   case 0x0a: str = \"interpreted by the network as 38.4 kbit/s in this version of the protocol\"; break;",
          "2103:   case 0x0b: str = \"interpreted by the network as 38.4 kbit/s in this version of the protocol\"; break;",
          "2104:   case 0x0c: str = \"interpreted by the network as 38.4 kbit/s in this version of the protocol\"; break;",
          "2105:   default:",
          "2106:   str = \"Reserved\";",
          "2107:   break;",
          "2108:   }",
          "2110:   other_decode_bitfield_value(a_bigbuf, oct, 0x0f, 8);",
          "2111:   proto_tree_add_text(subtree,",
          "2112:   tvb, curr_offset, 1,",
          "2113:   \"%s = Wanted air interface user rate: %s\",",
          "2114:   a_bigbuf,",
          "2115:   str);",
          "2119:   other_decode_bitfield_value(a_bigbuf, oct, 0x0f, 8);",
          "2120:   proto_tree_add_text(subtree,",
          "2121:   tvb, curr_offset, 1,",
          "2122:   \"%s = Wanted air interface user rate: Spare\",",
          "2123:   a_bigbuf);",
          "",
          "[Added Lines]",
          "1930:  proto_tree_add_item(subtree, hf_gsm_a_dtap_uimi, tvb, curr_offset, 1, ENC_NA);",
          "1934:   proto_tree_add_item(subtree, hf_gsm_a_dtap_wanted_air_interface_user_rate, tvb, curr_offset, 1, ENC_NA);",
          "1938:   proto_tree_add_uint_format_value(subtree, hf_gsm_a_dtap_wanted_air_interface_user_rate, tvb, curr_offset, 1,",
          "1939:             oct, \"Spare\");",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "2145:  if (is_uplink == IS_UPLINK_TRUE)",
          "2146:  {",
          "2191:  }",
          "2192:  else",
          "2193:  {",
          "2199:  }",
          "2201:  proto_tree_add_bits_item(tree, hf_gsm_a_spare_bits, tvb, (curr_offset<<3)+6, 2, ENC_BIG_ENDIAN);",
          "",
          "[Removed Lines]",
          "2147:   other_decode_bitfield_value(a_bigbuf, oct, 0x40, 8);",
          "2148:   proto_tree_add_text(subtree,",
          "2149:   tvb, curr_offset, 1,",
          "2150:   \"%s = Acceptable channel codings extended: TCH/F28.8 %sacceptable\",",
          "2151:   a_bigbuf,",
          "2152:   (oct & 0x40) ? \"\" : \"not \");",
          "2154:   other_decode_bitfield_value(a_bigbuf, oct, 0x20, 8);",
          "2155:   proto_tree_add_text(subtree,",
          "2156:   tvb, curr_offset, 1,",
          "2157:   \"%s = Acceptable channel codings extended: TCH/F32.0 %sacceptable\",",
          "2158:   a_bigbuf,",
          "2159:   (oct & 0x20) ? \"\" : \"not \");",
          "2161:   other_decode_bitfield_value(a_bigbuf, oct, 0x10, 8);",
          "2162:   proto_tree_add_text(subtree,",
          "2163:   tvb, curr_offset, 1,",
          "2164:   \"%s = Acceptable channel codings extended: TCH/F43.2 %sacceptable\",",
          "2165:   a_bigbuf,",
          "2166:   (oct & 0x10) ? \"\" : \"not \");",
          "2168:   other_decode_bitfield_value(a_bigbuf, oct, 0x10, 8);",
          "2169:   proto_tree_add_text(subtree,",
          "2170:   tvb, curr_offset, 1,",
          "2171:   \"%s = Acceptable channel codings extended: TCH/F43.2 %sacceptable\",",
          "2172:   a_bigbuf,",
          "2173:   (oct & 0x10) ? \"\" : \"not \");",
          "2175:   switch ((oct & 0x0c) >> 2)",
          "2176:   {",
          "2177:   case 0: str = \"Channel coding symmetry preferred\"; break;",
          "2178:   case 2: str = \"Downlink biased channel coding asymmetry is preferred\"; break;",
          "2179:   case 1: str = \"Uplink biased channel coding asymmetry is preferred\"; break;",
          "2180:   default:",
          "2181:   str = \"Unused, treat as Channel coding symmetry preferred\";",
          "2182:   break;",
          "2183:   }",
          "2185:   other_decode_bitfield_value(a_bigbuf, oct, 0x0c, 8);",
          "2186:   proto_tree_add_text(subtree,",
          "2187:   tvb, curr_offset, 1,",
          "2188:   \"%s = Channel Coding Asymmetry Indication: %s\",",
          "2189:   a_bigbuf,",
          "2190:   str);",
          "2194:   other_decode_bitfield_value(a_bigbuf, oct, 0x7c, 8);",
          "2195:   proto_tree_add_text(subtree,",
          "2196:   tvb, curr_offset, 1,",
          "2197:   \"%s = EDGE Channel Codings: Spare\",",
          "2198:   a_bigbuf);",
          "",
          "[Added Lines]",
          "1963:   proto_tree_add_item(subtree, hf_gsm_a_dtap_acceptable_channel_codings_ext_TCH_F28_8, tvb, curr_offset, 1, ENC_NA);",
          "1964:   proto_tree_add_item(subtree, hf_gsm_a_dtap_acceptable_channel_codings_ext_TCH_F32_0, tvb, curr_offset, 1, ENC_NA);",
          "1965:   proto_tree_add_item(subtree, hf_gsm_a_dtap_acceptable_channel_codings_ext_TCH_F43_2, tvb, curr_offset, 1, ENC_NA);",
          "1966:   proto_tree_add_item(subtree, hf_gsm_a_dtap_channel_coding_asymmetry_indication, tvb, curr_offset, 1, ENC_NA);",
          "1970:   proto_tree_add_uint_format_value(subtree, hf_gsm_a_dtap_edge_channel_codings, tvb, curr_offset, 1, oct, \"Spare\");",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "2215:  subtree = proto_item_add_subtree(item, ett_bc_oct_7);",
          "2216:   oct = tvb_get_guint8(tvb, curr_offset);",
          "2246:  break;",
          "2247:  }",
          "",
          "[Removed Lines]",
          "2218:   proto_tree_add_item(subtree, hf_gsm_a_extension, tvb, curr_offset, 1, ENC_BIG_ENDIAN);",
          "2220:  other_decode_bitfield_value(a_bigbuf, oct, 0x60, 8);",
          "2221:  proto_tree_add_text(subtree,",
          "2222:   tvb, curr_offset, 1,",
          "2223:   \"%s = Layer 2 Identity: %s\",",
          "2224:   a_bigbuf,",
          "2225:   ((oct & 0x60) == 0x40) ? \"Octet identifier\" : \"Reserved\");",
          "2227:  switch (oct & 0x1f)",
          "2228:  {",
          "2229:  case 0x06: str = \"Reserved: was allocated in earlier phases of the protocol\"; break;",
          "2230:  case 0x08: str = \"According to ISO/IEC 6429, codeset 0 (DC1/DC3)\"; break;",
          "2231:  case 0x09: str = \"Reserved: was allocated but never used in earlier phases of the protocol\"; break;",
          "2232:  case 0x0a: str = \"Videotex profile 1\"; break;",
          "2233:  case 0x0c: str = \"COPnoFlCt (Character oriented Protocol with no Flow Control mechanism)\"; break;",
          "2234:  case 0x0d: str = \"Reserved: was allocated in earlier phases of the protocol\"; break;",
          "2235:  default:",
          "2236:   str = \"Reserved\";",
          "2237:   break;",
          "2238:  }",
          "2240:  other_decode_bitfield_value(a_bigbuf, oct, 0x1f, 8);",
          "2241:  proto_tree_add_text(subtree,",
          "2242:   tvb, curr_offset, 1,",
          "2243:   \"%s = User information layer 2 protocol: %s\",",
          "2244:   a_bigbuf,",
          "2245:   str);",
          "",
          "[Added Lines]",
          "1990:  proto_tree_add_item(subtree, hf_gsm_a_extension, tvb, curr_offset, 1, ENC_BIG_ENDIAN);",
          "1992:  proto_tree_add_uint_format_value(subtree, hf_gsm_a_dtap_layer_2_identity, tvb, curr_offset, 1, oct,",
          "1993:   \"%s\", ((oct & 0x60) == 0x40) ? \"Octet identifier\" : \"Reserved\");",
          "1995:  proto_tree_add_uint_format_value(subtree, hf_gsm_a_dtap_user_information_layer_2_protocol, tvb, curr_offset, 1,",
          "1996:         oct, \"%s\", val_to_str_const(oct & 0x1F, gsm_a_dtap_user_info_layer2_vals, \"Reserved\"));",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "2273:  \"The mobile station does not support the Enhanced Network-initiated In-Call Modification procedure\"",
          "2274: };",
          "2276: static guint16",
          "2277: de_cc_cap(tvbuff_t *tvb, proto_tree *tree, packet_info *pinfo _U_, guint32 offset, guint len, gchar *add_string _U_, int string_len _U_){",
          "2278:  guint8 oct;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2027: const true_false_string gsm_a_dtap_dtmf_value = {",
          "2028:  \"the mobile station supports DTMF as specified in subclause 5.5.7 of TS 24.008\",",
          "2029:  \"reserved for earlier versions of the protocol\"",
          "2030: };",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "2283:  oct = tvb_get_guint8(tvb, curr_offset);",
          "2305:  proto_tree_add_item(tree, hf_gsm_a_dtap_mcat, tvb, curr_offset, 1, ENC_BIG_ENDIAN);",
          "2306:  proto_tree_add_item(tree, hf_gsm_a_dtap_enicm, tvb, curr_offset, 1, ENC_BIG_ENDIAN);",
          "2324:  curr_offset++;",
          "2326:  NO_MORE_DATA_CHECK(len);",
          "2330:  proto_tree_add_bits_item(tree, hf_gsm_a_spare_bits, tvb, curr_offset<<3, 4, ENC_BIG_ENDIAN);",
          "2339:  curr_offset++;",
          "",
          "[Removed Lines]",
          "2285:  other_decode_bitfield_value(a_bigbuf, oct, 0xf0, 8);",
          "2287:  switch ((oct & 0xf0) >> 4)",
          "2288:  {",
          "2289:  case 0:",
          "2290:  proto_tree_add_text(tree,",
          "2291:   tvb, curr_offset, 1,",
          "2292:   \"%s = Maximum number of supported bearers: 1\",",
          "2293:   a_bigbuf);",
          "2294:  break;",
          "2296:  default:",
          "2297:  proto_tree_add_text(tree,",
          "2298:   tvb, curr_offset, 1,",
          "2299:   \"%s =  Maximum number of supported bearers: %u\",",
          "2300:   a_bigbuf,",
          "2301:   (oct & 0xf0) >> 4);",
          "2302:  break;",
          "2303:  }",
          "2308:  other_decode_bitfield_value(a_bigbuf, oct, 0x02, 8);",
          "2309:   proto_tree_add_text(tree,",
          "2310:   tvb, curr_offset, 1,",
          "2311:   \"%s = PCP: the mobile station %s the Prolonged Clearing Procedure\",",
          "2312:   a_bigbuf,",
          "2313:   (oct & 0x02) ? \"supports\" : \"does not support\");",
          "2315:  other_decode_bitfield_value(a_bigbuf, oct, 0x01, 8);",
          "2316:  proto_tree_add_text(tree,",
          "2317:   tvb, curr_offset, 1,",
          "2318:   \"%s = DTMF: %s\",",
          "2319:   a_bigbuf,",
          "2320:   (oct & 0x01) ?",
          "2321:    \"the mobile station supports DTMF as specified in subclause 5.5.7 of TS 24.008\" :",
          "2322:    \"reserved for earlier versions of the protocol\");",
          "2328:  oct = tvb_get_guint8(tvb, curr_offset);",
          "2332:  other_decode_bitfield_value(a_bigbuf, oct, 0x0f, 8);",
          "2333:  proto_tree_add_text(tree,",
          "2334:   tvb, curr_offset, 1,",
          "2335:   \"%s = Maximum number of speech bearers: %u\",",
          "2336:   a_bigbuf,",
          "2337:   oct & 0x0f);",
          "",
          "[Added Lines]",
          "2041:     if (((oct & 0xf0) >> 4) == 0)",
          "2042:     {",
          "2043:      proto_tree_add_uint_format_value(tree, hf_gsm_a_dtap_maximum_number_of_supported_bearers, tvb, curr_offset, 1, 0, \"1\");",
          "2044:     }",
          "2045:     else",
          "2046:     {",
          "2047:      proto_tree_add_item(tree, hf_gsm_a_dtap_maximum_number_of_supported_bearers, tvb, curr_offset, 1, ENC_NA);",
          "2048:     }",
          "2052:  proto_tree_add_item(tree, hf_gsm_a_dtap_pcp, tvb, curr_offset, 1, ENC_NA);",
          "2053:  proto_tree_add_item(tree, hf_gsm_a_dtap_dtmf, tvb, curr_offset, 1, ENC_NA);",
          "2060:  proto_tree_add_item(tree, hf_gsm_a_dtap_max_num_of_speech_bearers, tvb, curr_offset, 1, ENC_NA);",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "2698:  { 0, NULL }",
          "2699: };",
          "2701: static guint16",
          "2702: de_cause(tvbuff_t *tvb, proto_tree *tree, packet_info *pinfo _U_, guint32 offset, guint len, gchar *add_string, int string_len)",
          "2703: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2424: static const value_string gsm_a_dtap_de_cause_coding_standard_vals[] = {",
          "2425:  { 0x00, \"Coding as specified in ITU-T Rec. Q.931\" },",
          "2426:  { 0x01, \"Reserved for other international standards\" },",
          "2427:  { 0x02, \"National standard\" },",
          "2428:  { 0x03, \"Standard defined for the GSM PLMNS\" },",
          "2429:  { 0, NULL }",
          "2430: };",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "2714:  oct = tvb_get_guint8(tvb, curr_offset);",
          "2716:  proto_tree_add_item(tree, hf_gsm_a_extension, tvb, curr_offset, 1, ENC_BIG_ENDIAN);",
          "2735:  proto_tree_add_bits_item(tree, hf_gsm_a_spare_bits, tvb, (curr_offset<<3)+3, 1, ENC_BIG_ENDIAN);",
          "2759:  curr_offset++;",
          "2761:  oct = tvb_get_guint8(tvb, curr_offset);",
          "",
          "[Removed Lines]",
          "2718:  switch ((oct & 0x60) >> 5)",
          "2719:  {",
          "2720:  case 0: str = \"Coding as specified in ITU-T Rec. Q.931\"; break;",
          "2721:  case 1: str = \"Reserved for other international standards\"; break;",
          "2722:  case 2: str = \"National standard\"; break;",
          "2723:  default:",
          "2724:   str = \"Standard defined for the GSM PLMNS\";",
          "2725:   break;",
          "2726:  }",
          "2728:  other_decode_bitfield_value(a_bigbuf, oct, 0x60, 8);",
          "2729:  proto_tree_add_text(tree,",
          "2730:  tvb, curr_offset, 1,",
          "2731:  \"%s = Coding standard: %s\",",
          "2732:  a_bigbuf,",
          "2733:  str);",
          "2737:  switch (oct & 0x0f)",
          "2738:  {",
          "2739:  case 0: str = \"User\"; break;",
          "2740:  case 1: str = \"Private network serving the local user\"; break;",
          "2741:  case 2: str = \"Public network serving the local user\"; break;",
          "2742:  case 3: str = \"Transit network\"; break;",
          "2743:  case 4: str = \"Public network serving the remote user\"; break;",
          "2744:  case 5: str = \"Private network serving the remote user\"; break;",
          "2745:  case 7: str = \"International network\"; break;",
          "2746:  case 10: str = \"Network beyond interworking point\"; break;",
          "2747:  default:",
          "2748:   str = \"Reserved\";",
          "2749:   break;",
          "2750:  }",
          "2752:  other_decode_bitfield_value(a_bigbuf, oct, 0x0f, 8);",
          "2753:  proto_tree_add_text(tree,",
          "2754:   tvb, curr_offset, 1,",
          "2755:   \"%s = Location: %s\",",
          "2756:   a_bigbuf,",
          "2757:   str);",
          "",
          "[Added Lines]",
          "2448:  proto_tree_add_item(tree, hf_gsm_a_dtap_de_cause_coding_standard, tvb, curr_offset, 1, ENC_NA);",
          "2452:  proto_tree_add_item(tree, hf_gsm_a_dtap_location, tvb, curr_offset, 1, ENC_NA);",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "2763:  if (!(oct & 0x80))",
          "2764:  {",
          "2765:  proto_tree_add_item(tree, hf_gsm_a_extension, tvb, curr_offset, 1, ENC_BIG_ENDIAN);",
          "2773:  curr_offset++;",
          "",
          "[Removed Lines]",
          "2767:  other_decode_bitfield_value(a_bigbuf, oct, 0x7f, 8);",
          "2768:  proto_tree_add_text(tree,",
          "2769:   tvb, curr_offset, 1,",
          "2770:   \"%s = Recommendation\",",
          "2771:   a_bigbuf);",
          "",
          "[Added Lines]",
          "2460:  proto_tree_add_item(tree, hf_gsm_a_dtap_recommendation, tvb, curr_offset, 1, ENC_NA);",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "2841:   break;",
          "2842:  }",
          "2846:   tvb, curr_offset, 1, cause,",
          "2849:   cause,",
          "2850:   str);",
          "",
          "[Removed Lines]",
          "2844:  other_decode_bitfield_value(a_bigbuf, oct, 0x7f, 8);",
          "2845:  proto_tree_add_uint_format(tree, hf_gsm_a_dtap_cause,",
          "2847:   \"%s = Cause: (%u) %s\",",
          "2848:   a_bigbuf,",
          "",
          "[Added Lines]",
          "2533:  proto_tree_add_uint_format_value(tree, hf_gsm_a_dtap_cause,",
          "2535:   \"Cause: (%u) %s\",",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "2880:  else",
          "2881:  {",
          "2882:   diag_length = len - (curr_offset - offset);",
          "2885:   curr_offset += diag_length;",
          "2886:  }",
          "",
          "[Removed Lines]",
          "2883:   proto_tree_add_text(subtree, tvb, curr_offset, diag_length,",
          "2884:    \"Data: %s\", tvb_bytes_to_ep_str(tvb, curr_offset, diag_length));",
          "",
          "[Added Lines]",
          "2570:   proto_tree_add_item(subtree, hf_gsm_a_dtap_data, tvb, curr_offset, diag_length, ENC_NA);",
          "",
          "---------------",
          "--- Hunk 34 ---",
          "[Context before]",
          "3002: static guint16",
          "3003: de_keypad_facility(tvbuff_t *tvb, proto_tree *tree, packet_info *pinfo, guint32 offset, guint len _U_, gchar *add_string, int string_len)",
          "3004: {",
          "3006:  guint32     curr_offset;",
          "3007:  proto_item *item;",
          "3009:  curr_offset = offset;",
          "3014:  proto_tree_add_bits_item(tree, hf_gsm_a_spare_bits, tvb, curr_offset<<3, 1, ENC_BIG_ENDIAN);",
          "3023:  if (((keypad_char < '0') || (keypad_char > '9')) &&",
          "3024:   ((keypad_char < 'A') || (keypad_char > 'D')) &&",
          "",
          "[Removed Lines]",
          "3005:  guint8      oct, keypad_char;",
          "3011:  oct = tvb_get_guint8(tvb, curr_offset);",
          "3012:  keypad_char = oct & 0x7f;",
          "3016:  other_decode_bitfield_value(a_bigbuf, oct, 0x7f, 8);",
          "3017:  item = proto_tree_add_text(tree,",
          "3018:   tvb, curr_offset, 1,",
          "3019:   \"%s = Keypad information: %c\",",
          "3020:   a_bigbuf,",
          "3021:   keypad_char);",
          "",
          "[Added Lines]",
          "2691:  guint8      keypad_char;",
          "2697:  keypad_char = tvb_get_guint8(tvb, curr_offset) & 0x7f;",
          "2701:  item = proto_tree_add_uint_format_value(tree, hf_gsm_a_dtap_keypad_information, tvb, curr_offset, 1,",
          "2702:                     keypad_char, \"%c\", keypad_char);",
          "",
          "---------------",
          "--- Hunk 35 ---",
          "[Context before]",
          "3079:  { 0x00, \"User\" },",
          "3080:  { 0x01, \"Private network serving the local user\" },",
          "3081:  { 0x02, \"Public network serving the local user\" },",
          "3082:  { 0x04, \"Public network serving the remote user\" },",
          "3083:  { 0x05, \"Private network serving the remote user\" },",
          "3084:  { 0x0a, \"Network beyond interworking point\" },",
          "3085:  { 0, NULL }",
          "3086: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2763:  { 0x03, \"Transit network\" },",
          "2766:  { 0x07, \"International network\" },",
          "",
          "---------------",
          "--- Hunk 36 ---",
          "[Context before]",
          "3199: static guint16",
          "3200: de_repeat_ind(tvbuff_t *tvb, proto_tree *tree, packet_info *pinfo _U_, guint32 offset, guint len _U_, gchar *add_string _U_, int string_len _U_)",
          "3201: {",
          "3202:  guint8 oct;",
          "3203:  guint32 curr_offset;",
          "3206:  curr_offset = offset;",
          "3208:  oct = tvb_get_guint8(tvb, curr_offset);",
          "3227:  curr_offset++;",
          "",
          "[Removed Lines]",
          "3204:  const gchar *str;",
          "3210:  switch (oct & 0x0f)",
          "3211:  {",
          "3212:  case 1: str = \"Circular for successive selection 'mode 1 alternate mode 2'\"; break;",
          "3213:  case 2: str = \"Support of fallback mode 1 preferred, mode 2 selected if setup of mode 1 fails\"; break;",
          "3214:  case 3: str = \"Reserved: was allocated in earlier phases of the protocol\"; break;",
          "3215:  default:",
          "3216:   str = \"Reserved\";",
          "3217:   break;",
          "3218:  }",
          "3220:  other_decode_bitfield_value(a_bigbuf, oct, 0x0f, 8);",
          "3221:  proto_tree_add_text(tree,",
          "3222:   tvb, curr_offset, 1,",
          "3223:   \"%s = %s\",",
          "3224:   a_bigbuf,",
          "3225:   str);",
          "",
          "[Added Lines]",
          "2882: static const value_string gsm_a_dtap_repeat_indicator_vals[] = {",
          "2883:  { 0x01, \"Circular for successive selection 'mode 1 alternate mode 2'\" },",
          "2884:  { 0x02, \"Support of fallback mode 1 preferred, mode 2 selected if setup of mode 1 fails\" },",
          "2885:  { 0x03, \"Reserved: was allocated in earlier phases of the protocol\" },",
          "2886:  { 0, NULL }",
          "2887: };",
          "2899:  proto_tree_add_uint_format_value(tree, hf_gsm_a_dtap_repeat_indicator, tvb, curr_offset, 1, oct,",
          "2900:             \"%s\", val_to_str_const(oct & 0xF, gsm_a_dtap_repeat_indicator_vals, \"Reserved\"));",
          "",
          "---------------",
          "--- Hunk 37 ---",
          "[Context before]",
          "3280: static guint16",
          "3281: de_ss_ver_ind(tvbuff_t *tvb, proto_tree *tree, packet_info *pinfo _U_, guint32 offset, guint len, gchar *add_string _U_, int string_len _U_)",
          "3282: {",
          "3283:  guint8       oct;",
          "3284:  guint32      curr_offset;",
          "3287:  curr_offset = offset;",
          "3289:  oct = tvb_get_guint8(tvb, curr_offset);",
          "3305:  curr_offset++;",
          "3307:  EXTRANEOUS_DATA_CHECK(len, curr_offset - offset);",
          "",
          "[Removed Lines]",
          "3285:  const gchar *str;",
          "3291:  switch (oct)",
          "3292:  {",
          "3293:  case 0: str = \"Phase 2 service, ellipsis notation, and phase 2 error handling is supported\"; break;",
          "3294:  case 1: str = \"SS-Protocol version 3 is supported, and phase 2 error handling is supported\"; break;",
          "3295:  default:",
          "3296:   str = \"Reserved\";",
          "3297:   break;",
          "3298:  }",
          "3300:  proto_tree_add_text(tree,",
          "3301:   tvb, curr_offset, 1,",
          "3302:   \"%s\",",
          "3303:   str);",
          "",
          "[Added Lines]",
          "2954: static const value_string gsm_a_dtap_ss_ver_ind_vals[] = {",
          "2955:  { 0x00, \"Phase 2 service, ellipsis notation, and phase 2 error handling is supported\" },",
          "2956:  { 0x01, \"SS-Protocol version 3 is supported, and phase 2 error handling is supported\" },",
          "2957:  { 0, NULL }",
          "2958: };",
          "2970:  proto_tree_add_uint_format_value(tree, hf_gsm_a_dtap_ss_version_indicator, tvb, curr_offset, 1,",
          "2971:                         oct, \"%s\", val_to_str_const(oct, gsm_a_dtap_ss_ver_ind_vals, \"Reserved\"));",
          "",
          "---------------",
          "--- Hunk 38 ---",
          "[Context before]",
          "3367:  item = proto_tree_add_text(tree, tvb, curr_offset, len - 1, \"User-user information\");",
          "3368:  subtree = proto_item_add_subtree(item, ett_gsm_dtap_elem[DE_USER_USER]);",
          "3372:  return(len);",
          "3373: }",
          "",
          "[Removed Lines]",
          "3369:  proto_tree_add_text(subtree, tvb, curr_offset, len - 1,",
          "3370:    \"Data: %s\", tvb_bytes_to_ep_str(tvb, curr_offset, len - 1));",
          "",
          "[Added Lines]",
          "3036:  proto_tree_add_item(subtree, hf_gsm_a_dtap_data, tvb, curr_offset, len - 1, ENC_NA);",
          "",
          "---------------",
          "--- Hunk 39 ---",
          "[Context before]",
          "3693: static guint16",
          "3694: de_cp_cause(tvbuff_t *tvb, proto_tree *tree, packet_info *pinfo _U_, guint32 offset, guint len _U_, gchar *add_string, int string_len)",
          "3695: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3360: static const value_string gsm_a_dtap_cp_cause_values[] = {",
          "3361:     { 17, \"Network failure\"},",
          "3362:  { 22, \"Congestion\"},",
          "3363:  { 81, \"Invalid Transaction Identifier value\"},",
          "3364:  { 95, \"Semantically incorrect message\"},",
          "3365:  { 96, \"Invalid mandatory information\"},",
          "3366:  { 97, \"Message type non-existent or not implemented\"},",
          "3367:  { 98, \"Message not compatible with the short message protocol state\"},",
          "3368:  { 99, \"Information element non-existent or not implemented\"},",
          "3369:  { 111, \"Protocol error, unspecified\"},",
          "3370:  { 0, NULL }",
          "3371: };",
          "",
          "---------------",
          "--- Hunk 40 ---",
          "[Context before]",
          "3700:  curr_offset = offset;",
          "3702:  oct = tvb_get_guint8(tvb, curr_offset);",
          "3726:  curr_offset++;",
          "3728:  if (add_string)",
          "",
          "[Removed Lines]",
          "3704:  switch (oct)",
          "3705:  {",
          "3706:  case 17: str = \"Network failure\"; break;",
          "3707:  case 22: str = \"Congestion\"; break;",
          "3708:  case 81: str = \"Invalid Transaction Identifier value\"; break;",
          "3709:  case 95: str = \"Semantically incorrect message\"; break;",
          "3710:  case 96: str = \"Invalid mandatory information\"; break;",
          "3711:  case 97: str = \"Message type non-existent or not implemented\"; break;",
          "3712:  case 98: str = \"Message not compatible with the short message protocol state\"; break;",
          "3713:  case 99: str = \"Information element non-existent or not implemented\"; break;",
          "3714:  case 111: str = \"Protocol error, unspecified\"; break;",
          "3715:  default:",
          "3716:   str = \"Reserved, treat as Protocol error, unspecified\";",
          "3717:   break;",
          "3718:  }",
          "3720:  proto_tree_add_text(tree,",
          "3721:   tvb, curr_offset, 1,",
          "3722:   \"Cause: (%u) %s\",",
          "3723:   oct,",
          "3724:   str);",
          "",
          "[Added Lines]",
          "3383:     str = val_to_str_const(oct, gsm_a_dtap_cp_cause_values, \"Reserved, treat as Protocol error, unspecified\");",
          "3384:  proto_tree_add_uint_format_value(tree, hf_gsm_a_dtap_cp_cause, tvb, curr_offset, 1,",
          "3385:         oct, \"(%u) %s\", oct, str);",
          "",
          "---------------",
          "--- Hunk 41 ---",
          "[Context before]",
          "3760:  else",
          "3761:   str = \"unknown\";",
          "3767:  if (oct & 0x01)",
          "3768:   proto_tree_add_text(tree,",
          "",
          "[Removed Lines]",
          "3763:  proto_tree_add_text(tree,",
          "3764:   tvb, curr_offset, 1,",
          "3765:   \"Test Loop %s\",str);",
          "",
          "[Added Lines]",
          "3423:  proto_tree_add_uint_format_value(tree, hf_gsm_a_dtap_test_loop, tvb, curr_offset, 1,",
          "3424:                 oct, \"%s\", str);",
          "",
          "---------------",
          "--- Hunk 42 ---",
          "[Context before]",
          "3798:  return(curr_offset - offset);",
          "3799: }",
          "3801: static guint16",
          "3802: de_tp_loop_type(tvbuff_t *tvb, proto_tree *tree, packet_info *pinfo _U_, guint32 offset, guint len _U_, gchar *add_string _U_, int string_len _U_)",
          "3803: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3460: static const value_string gsm_channel_coding_vals[] = {",
          "3461:  { 0x00, \"not needed. The Burst-by-Burst loop is activated, type G\" },",
          "3462:  { 0x01, \"Channel coding needed. Frame erasure is to be signalled, type H\" },",
          "3463:  { 0x02, \"reserved\" },",
          "3464:  { 0x03, \"reserved\" },",
          "3465:  { 0, NULL }",
          "3466: };",
          "",
          "---------------",
          "--- Hunk 43 ---",
          "[Context before]",
          "3809:  oct = tvb_get_guint8(tvb, curr_offset);",
          "3824:  switch (oct & 0x1c)",
          "3825:  {",
          "",
          "[Removed Lines]",
          "3811:  switch (oct & 0x03)",
          "3812:  {",
          "3813:   case 0x00:",
          "3814:    proto_tree_add_text(tree, tvb, curr_offset, 1, \"Channel coding not needed. The Burst-by-Burst loop is activated, type G\");",
          "3815:    break;",
          "3816:   case 0x01:",
          "3817:    proto_tree_add_text(tree, tvb, curr_offset, 1, \"Channel coding needed. Frame erasure is to be signalled, type H\");",
          "3818:    break;",
          "3819:   default:",
          "3820:    proto_tree_add_text(tree, tvb, curr_offset, 1, \"Channel coding reserved (%d)\",oct & 0x03);",
          "3821:    break;",
          "3822:  }",
          "",
          "[Added Lines]",
          "3478:     proto_tree_add_item(tree, hf_gsm_a_dtap_channel_coding03, tvb, curr_offset, 1, ENC_NA);",
          "",
          "---------------",
          "--- Hunk 44 ---",
          "[Context before]",
          "3851:  oct = tvb_get_guint8(tvb, curr_offset);",
          "3866:  switch (oct & 0x0e)",
          "3867:  {",
          "",
          "[Removed Lines]",
          "3853:  switch (oct & 0x30)",
          "3854:  {",
          "3855:   case 0x00:",
          "3856:    proto_tree_add_text(tree, tvb, curr_offset, 1, \"Channel coding not needed. The Burst-by-Burst loop is activated, type G\");",
          "3857:    break;",
          "3858:   case 0x10:",
          "3859:    proto_tree_add_text(tree, tvb, curr_offset, 1, \"Channel coding needed. Frame erasure is to be signalled, type H\");",
          "3860:    break;",
          "3861:   default:",
          "3862:    proto_tree_add_text(tree, tvb, curr_offset, 1, \"Channel coding reserved (%d)\",(oct & 0x30)>>4);",
          "3863:    break;",
          "3864:  }",
          "",
          "[Added Lines]",
          "3509:     proto_tree_add_item(tree, hf_gsm_a_dtap_channel_coding30, tvb, curr_offset, 1, ENC_NA);",
          "",
          "---------------",
          "--- Hunk 45 ---",
          "[Context before]",
          "3886:  return(curr_offset - offset);",
          "3887: }",
          "3889: static guint16",
          "3890: de_tp_tested_device(tvbuff_t *tvb, proto_tree *tree, packet_info *pinfo _U_, guint32 offset, guint len _U_, gchar *add_string _U_, int string_len _U_)",
          "3891: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3534: static const value_string gsm_tp_tested_device_vals[] = {",
          "3535:  { 0x00, \"Normal operation (no tested device via DAI)\" },",
          "3536:  { 0x01, \"Test of speech decoder / DTX functions (downlink)\" },",
          "3537:  { 0x02, \"Test of speech encoder / DTX functions (uplink)\" },",
          "3538:  { 0x03, \"Test of acoustic devices and A/D & D/A\" },",
          "3539:  { 0, NULL }",
          "3540: };",
          "",
          "---------------",
          "--- Hunk 46 ---",
          "[Context before]",
          "3895:  curr_offset = offset;",
          "3897:  oct = tvb_get_guint8(tvb, curr_offset);",
          "3918:  curr_offset+= 1;",
          "3920:  return(curr_offset - offset);",
          "",
          "[Removed Lines]",
          "3899:  switch (oct)",
          "3900:  {",
          "3901:   case 0:",
          "3902:    proto_tree_add_text(tree, tvb, curr_offset, 1, \"Normal operation (no tested device via DAI)\");",
          "3903:    break;",
          "3904:   case 1:",
          "3905:    proto_tree_add_text(tree, tvb, curr_offset, 1, \"Test of speech decoder / DTX functions (downlink)\");",
          "3906:    break;",
          "3907:   case 2:",
          "3908:    proto_tree_add_text(tree, tvb, curr_offset, 1, \"Test of speech encoder / DTX functions (uplink)\");",
          "3909:    break;",
          "3910:   case 4:",
          "3911:    proto_tree_add_text(tree, tvb, curr_offset, 1, \"Test of acoustic devices and A/D & D/A\");",
          "3912:    break;",
          "3913:   default:",
          "3914:    proto_tree_add_text(tree, tvb, curr_offset, 1, \"Tested device reserved (%d)\",oct);",
          "3915:    break;",
          "3916:  }",
          "",
          "[Added Lines]",
          "3551:     proto_tree_add_uint_format_value(tree, hf_gsm_a_dtap_tp_tested_device, tvb, curr_offset, 1,",
          "3552:                 oct, \"%s\", val_to_str(oct, gsm_tp_tested_device_vals, \"Reserved (%d)\"));",
          "",
          "---------------",
          "--- Hunk 47 ---",
          "[Context before]",
          "3934:  if (value & 0x8000)",
          "3935:  {",
          "3936:   if ((value & 0xfff) == 0)",
          "3938:   else",
          "3940:  }",
          "3941:  else",
          "3944:  return(curr_offset - offset);",
          "3945: }",
          "",
          "[Removed Lines]",
          "3937:    proto_tree_add_text(tree, tvb, curr_offset, 1, \"Infinite number of PDUs to be transmitted in the TBF\");",
          "3939:    proto_tree_add_text(tree, tvb, curr_offset, 1, \"%d PDUs to be transmitted in the TBF\",value & 0xfff);",
          "3942:   proto_tree_add_text(tree, tvb, curr_offset, 1, \"PDU description reserved\");",
          "",
          "[Added Lines]",
          "3572:    proto_tree_add_uint_format_value(tree, hf_gsm_a_dtap_tp_pdu_description,",
          "3573:                     tvb, curr_offset, 2, value, \"Infinite number of PDUs to be transmitted in the TBF\");",
          "3575:    proto_tree_add_uint_format_value(tree, hf_gsm_a_dtap_tp_pdu_description,",
          "3576:                     tvb, curr_offset, 2, value & 0xfff, \"%d PDUs to be transmitted in the TBF\", value & 0xfff);",
          "3579:   proto_tree_add_uint_format_value(tree, hf_gsm_a_dtap_tp_pdu_description,",
          "3580:                     tvb, curr_offset, 2, value, \"reserved\");",
          "",
          "---------------",
          "--- Hunk 48 ---",
          "[Context before]",
          "3959:  else",
          "3960:   proto_tree_add_text(tree, tvb, curr_offset, 1, \"MS shall itself generate the pseudorandom data\");",
          "3964:  curr_offset+= 1;",
          "",
          "[Removed Lines]",
          "3962:  proto_tree_add_text(tree, tvb, curr_offset, 1, \"Downlink Timeslot Offset: timeslot number %d\",(oct & 0x0e)>>1);",
          "",
          "[Added Lines]",
          "3600:  proto_tree_add_item(tree, hf_gsm_a_dtap_downlink_timeslot_offset, tvb, curr_offset, 1, ENC_NA);",
          "",
          "---------------",
          "--- Hunk 49 ---",
          "[Context before]",
          "3981:  else",
          "3982:   proto_tree_add_text(tree, tvb, curr_offset, 1, \"MS loops back blocks on the uplink using either GMSK or 8-PSK modulation following the detected received modulation\");",
          "3986:  curr_offset+= 1;",
          "3988:  return(curr_offset - offset);",
          "3989: }",
          "3991: static guint16",
          "3992: de_tp_ms_positioning_technology(tvbuff_t *tvb, proto_tree *tree, packet_info *pinfo _U_, guint32 offset, guint len _U_, gchar *add_string _U_, int string_len _U_)",
          "3993: {",
          "",
          "[Removed Lines]",
          "3984:  proto_tree_add_text(tree, tvb, curr_offset, 1, \"Downlink Timeslot Offset: timeslot number %d\",(oct & 0x0e)>>1);",
          "",
          "[Added Lines]",
          "3622:  proto_tree_add_item(tree, hf_gsm_a_dtap_downlink_timeslot_offset, tvb, curr_offset, 1, ENC_NA);",
          "3629: static const value_string gsm_positioning_technology_vals[] = {",
          "3630:  { 0x00, \"AGPS\" },",
          "3631:  { 0x01, \"AGNSS\" },",
          "3632:  { 0, NULL }",
          "3633: };",
          "",
          "---------------",
          "--- Hunk 50 ---",
          "[Context before]",
          "3997:  curr_offset = offset;",
          "3999:  oct = tvb_get_guint8(tvb, curr_offset);",
          "4014:  curr_offset+= 1;",
          "4016:  return(curr_offset - offset);",
          "",
          "[Removed Lines]",
          "4001:  switch (oct)",
          "4002:  {",
          "4003:   case 0:",
          "4004:    proto_tree_add_text(tree, tvb, curr_offset, 1, \"AGPS\");",
          "4005:    break;",
          "4006:   case 1:",
          "4007:    proto_tree_add_text(tree, tvb, curr_offset, 1, \"AGNSS\");",
          "4008:    break;",
          "4009:   default:",
          "4010:    proto_tree_add_text(tree, tvb, curr_offset, 1, \"MS positioning technology reserved (%d)\",oct);",
          "4011:    break;",
          "4012:  }",
          "",
          "[Added Lines]",
          "3644:  proto_tree_add_uint_format_value(tree, hf_gsm_a_dtap_ms_positioning_technology, tvb, curr_offset, 1,",
          "3645:         oct, \"%s\", val_to_str(oct, gsm_positioning_technology_vals, \"Reserved (%d)\"));",
          "",
          "---------------",
          "--- Hunk 51 ---",
          "[Context before]",
          "4076:  oct = tvb_get_guint8(tvb, curr_offset);",
          "4091:  curr_offset+= 1;",
          "4093:  return(curr_offset - offset);",
          "",
          "[Removed Lines]",
          "4078:  switch (oct)",
          "4079:  {",
          "4080:   case 0:",
          "4081:    proto_tree_add_text(tree, tvb, curr_offset, 1, \"AGPS\");",
          "4082:    break;",
          "4083:   case 1:",
          "4084:    proto_tree_add_text(tree, tvb, curr_offset, 1, \"AGNSS\");",
          "4085:    break;",
          "4086:   default:",
          "4087:    proto_tree_add_text(tree, tvb, curr_offset, 1, \"UE positioning technology reserved (%d)\",oct);",
          "4088:    break;",
          "4089:  }",
          "",
          "[Added Lines]",
          "3710:  proto_tree_add_uint_format_value(tree, hf_gsm_a_dtap_ue_positioning_technology, tvb, curr_offset, 1,",
          "3711:         oct, \"%s\", val_to_str(oct, gsm_positioning_technology_vals, \"Reserved (%d)\"));",
          "",
          "---------------",
          "--- Hunk 52 ---",
          "[Context before]",
          "4104:  value = tvb_get_ntohl(tvb, curr_offset);",
          "4105:  curr_offset+= 4;",
          "4109:  return(curr_offset - offset);",
          "4110: }",
          "",
          "[Removed Lines]",
          "4107:  proto_tree_add_text(tree, tvb, curr_offset, 1, \"UE received RLC SDU counter value %d\",value);",
          "",
          "[Added Lines]",
          "3728:  proto_tree_add_text(tree, tvb, curr_offset, 1, \"UE received RLC SDU counter value: %d\",value);",
          "",
          "---------------",
          "--- Hunk 53 ---",
          "[Context before]",
          "4415:  proto_tree_add_bits_item(subtree, hf_gsm_a_spare_bits, tvb, (curr_offset<<3)+4, 1, ENC_BIG_ENDIAN);",
          "4419:  switch (oct & 0x07)",
          "4420:  {",
          "4421:  case 0x07:",
          "4426:   break;",
          "4428:  default:",
          "4434:   break;",
          "4435:  }",
          "",
          "[Removed Lines]",
          "4417:  other_decode_bitfield_value(a_bigbuf, oct, 0x07, 8);",
          "4422:   proto_tree_add_text(subtree,",
          "4423:    tvb, curr_offset, 1,",
          "4424:    \"%s = Ciphering Key Sequence Number: No key is available\",",
          "4425:    a_bigbuf);",
          "4429:   proto_tree_add_text(subtree,",
          "4430:    tvb, curr_offset, 1,",
          "4431:    \"%s = Ciphering Key Sequence Number: %u\",",
          "4432:    a_bigbuf,",
          "4433:    oct & 0x07);",
          "",
          "[Added Lines]",
          "4042:         proto_tree_add_uint_format_value(subtree, hf_gsm_a_dtap_ciphering_key_sequence_number, tvb, curr_offset, 1,",
          "4043:                                         oct, \"No key is available\");",
          "4047:   proto_tree_add_item(subtree, hf_gsm_a_dtap_ciphering_key_sequence_number, tvb, curr_offset, 1, ENC_NA);",
          "",
          "---------------",
          "--- Hunk 54 ---",
          "[Context before]",
          "4525:  proto_tree_add_bits_item(subtree, hf_gsm_a_spare_bits, tvb, (curr_offset<<3)+4, 1, ENC_BIG_ENDIAN);",
          "4529:  switch (oct & 0x07)",
          "4530:  {",
          "4531:  case 0x07:",
          "4536:   break;",
          "4538:  default:",
          "4544:   break;",
          "4545:  }",
          "",
          "[Removed Lines]",
          "4527:  other_decode_bitfield_value(a_bigbuf, oct, 0x07, 8);",
          "4532:   proto_tree_add_text(subtree,",
          "4533:    tvb, curr_offset, 1,",
          "4534:    \"%s = Ciphering Key Sequence Number: No key is available\",",
          "4535:    a_bigbuf);",
          "4539:   proto_tree_add_text(subtree,",
          "4540:    tvb, curr_offset, 1,",
          "4541:    \"%s = Ciphering Key Sequence Number: %u\",",
          "4542:    a_bigbuf,",
          "4543:    oct & 0x07);",
          "",
          "[Added Lines]",
          "4144:         proto_tree_add_uint_format_value(subtree, hf_gsm_a_dtap_ciphering_key_sequence_number, tvb, curr_offset, 1,",
          "4145:                                         oct, \"No key is available\");",
          "4149:   proto_tree_add_item(subtree, hf_gsm_a_dtap_ciphering_key_sequence_number, tvb, curr_offset, 1, ENC_NA);",
          "",
          "---------------",
          "--- Hunk 55 ---",
          "[Context before]",
          "4629: static void",
          "4630: dtap_mm_cm_srvc_req(tvbuff_t *tvb, proto_tree *tree, packet_info *pinfo _U_, guint32 offset, guint len)",
          "4631: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4235: static const value_string gsm_a_dtap_service_type_vals[] = {",
          "4236:  { 0x00, \"Reserved\"},",
          "4237:     { 0x01, \"Mobile originating call establishment or packet mode connection establishment\"},",
          "4238:  { 0x02, \"Emergency call establishment\"},",
          "4239:  { 0x03, \"Reserved\"},",
          "4240:  { 0x04, \"Short message service\"},",
          "4241:  { 0x05, \"Reserved\"},",
          "4242:  { 0x06, \"Reserved\"},",
          "4243:  { 0x07, \"Reserved\"},",
          "4244:  { 0x08, \"Supplementary service activation\"},",
          "4245:  { 0x09, \"Voice group call establishment\"},",
          "4246:  { 0x0a, \"Voice broadcast call establishment\"},",
          "4247:  { 0x0b, \"Location Services\"},",
          "4248:  { 0x0c, \"Reserved\"},",
          "4249:  { 0x0d, \"Reserved\"},",
          "4250:  { 0x0e, \"Reserved\"},",
          "4251:  { 0x0f, \"Reserved\"},",
          "4252:  { 0, NULL }",
          "4253: };",
          "",
          "---------------",
          "--- Hunk 56 ---",
          "[Context before]",
          "4635:  guint8       oct;",
          "4636:  proto_tree  *subtree;",
          "4637:  proto_item  *item;",
          "4640:  curr_offset = offset;",
          "4641:  curr_len = len;",
          "",
          "[Removed Lines]",
          "4638:  const gchar *str;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 57 ---",
          "[Context before]",
          "4655:  subtree = proto_item_add_subtree(item, ett_gsm_common_elem[DE_CIPH_KEY_SEQ_NUM]);",
          "4657:  proto_tree_add_bits_item(subtree, hf_gsm_a_spare_bits, tvb, curr_offset<<3, 1, ENC_BIG_ENDIAN);",
          "4660:  switch ((oct & 0x70) >> 4)",
          "4661:  {",
          "4662:  case 0x07:",
          "4667:   break;",
          "4669:  default:",
          "4675:   break;",
          "4676:  }",
          "",
          "[Removed Lines]",
          "4658:  other_decode_bitfield_value(a_bigbuf, oct, 0x70, 8);",
          "4663:   proto_tree_add_text(subtree,",
          "4664:    tvb, curr_offset, 1,",
          "4665:    \"%s = Ciphering Key Sequence Number: No key is available\",",
          "4666:    a_bigbuf);",
          "4670:   proto_tree_add_text(subtree,",
          "4671:    tvb, curr_offset, 1,",
          "4672:    \"%s = Ciphering Key Sequence Number: %u\",",
          "4673:    a_bigbuf,",
          "4674:    (oct & 0x70) >> 4);",
          "",
          "[Added Lines]",
          "4287:         proto_tree_add_uint_format_value(subtree, hf_gsm_a_dtap_ciphering_key_sequence_number70, tvb, curr_offset, 1,",
          "4288:                                         oct, \"No key is available\");",
          "4292:   proto_tree_add_item(subtree, hf_gsm_a_dtap_ciphering_key_sequence_number70, tvb, curr_offset, 1, ENC_NA);",
          "",
          "---------------",
          "--- Hunk 58 ---",
          "[Context before]",
          "4683:  subtree = proto_item_add_subtree(item, ett_gsm_dtap_elem[DE_CM_SRVC_TYPE]);",
          "4707:  curr_offset++;",
          "4708:  curr_len--;",
          "",
          "[Removed Lines]",
          "4685:  switch (oct & 0x0f)",
          "4686:  {",
          "4687:  case 0x01: str = \"Mobile originating call establishment or packet mode connection establishment\"; break;",
          "4688:  case 0x02: str = \"Emergency call establishment\"; break;",
          "4689:  case 0x04: str = \"Short message service\"; break;",
          "4690:  case 0x08: str = \"Supplementary service activation\"; break;",
          "4691:  case 0x09: str = \"Voice group call establishment\"; break;",
          "4692:  case 0x0a: str = \"Voice broadcast call establishment\"; break;",
          "4693:  case 0x0b: str = \"Location Services\"; break;",
          "4694:  default:",
          "4695:   str = \"Reserved\";",
          "4696:   break;",
          "4697:  }",
          "4699:  other_decode_bitfield_value(a_bigbuf, oct, 0x0f, 8);",
          "4700:  proto_tree_add_text(subtree,",
          "4701:   tvb, curr_offset, 1,",
          "4702:   \"%s = Service Type: (%u) %s\",",
          "4703:   a_bigbuf,",
          "4704:   oct & 0x0f,",
          "4705:   str);",
          "",
          "[Added Lines]",
          "4303:  proto_tree_add_item(subtree, hf_gsm_a_dtap_service_type, tvb, curr_offset, 1, ENC_NA);",
          "",
          "---------------",
          "--- Hunk 59 ---",
          "[Context before]",
          "4728: static void",
          "4729: dtap_mm_id_req(tvbuff_t *tvb, proto_tree *tree, packet_info *pinfo _U_, guint32 offset, guint len)",
          "4730: {",
          "4732:  guint32      curr_offset;",
          "4733:  guint        curr_len;",
          "4734:  proto_tree  *subtree;",
          "4735:  proto_item  *item;",
          "4738:  curr_offset = offset;",
          "4739:  curr_len = len;",
          "",
          "[Removed Lines]",
          "4731:  guint8       oct;",
          "4736:  const gchar *str;",
          "",
          "[Added Lines]",
          "4326: static const value_string gsm_a_dtap_type_of_identity_vals[] = {",
          "4327:  { 0x00, \"Reserved\"},",
          "4328:     { 0x01, \"IMSI\"},",
          "4329:  { 0x02, \"IMEI\"},",
          "4330:  { 0x03, \"IMEISV\"},",
          "4331:  { 0x04, \"TMSI\"},",
          "4332:  { 0x05, \"P-TMSI, RAI, P-TMSI signature\"},",
          "4333:  { 0x06, \"Reserved\"},",
          "4334:  { 0x07, \"Reserved\"},",
          "4335:  { 0, NULL }",
          "4336: };",
          "",
          "---------------",
          "--- Hunk 60 ---",
          "[Context before]",
          "4748:  proto_tree_add_bits_item(tree, hf_gsm_a_spare_bits, tvb, curr_offset<<3, 4, ENC_BIG_ENDIAN);",
          "4750:  item =",
          "",
          "[Removed Lines]",
          "4746:  oct = tvb_get_guint8(tvb, curr_offset);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 61 ---",
          "[Context before]",
          "4755:  subtree = proto_item_add_subtree(item, ett_gsm_dtap_elem[DE_ID_TYPE]);",
          "4757:  proto_tree_add_bits_item(subtree, hf_gsm_a_spare_bits, tvb, (curr_offset<<3)+4, 1, ENC_BIG_ENDIAN);",
          "4778:  curr_offset++;",
          "4779:  curr_len--;",
          "",
          "[Removed Lines]",
          "4759:  switch (oct & 0x07)",
          "4760:  {",
          "4761:  case 1: str = \"IMSI\"; break;",
          "4762:  case 2: str = \"IMEI\"; break;",
          "4763:  case 3: str = \"IMEISV\"; break;",
          "4764:  case 4: str = \"TMSI\"; break;",
          "4765:  case 5: str = \"P-TMSI, RAI, P-TMSI signature\"; break;",
          "4766:  default:",
          "4767:   str = \"Reserved\";",
          "4768:   break;",
          "4769:  }",
          "4771:  other_decode_bitfield_value(a_bigbuf, oct, 0x07, 8);",
          "4772:  proto_tree_add_text(subtree,",
          "4773:   tvb, curr_offset, 1,",
          "4774:   \"%s = Type of identity: %s\",",
          "4775:   a_bigbuf,",
          "4776:   str);",
          "",
          "[Added Lines]",
          "4364:  proto_tree_add_item(subtree, hf_gsm_a_dtap_type_of_identity, tvb, curr_offset, 1, ENC_NA);",
          "",
          "---------------",
          "--- Hunk 62 ---",
          "[Context before]",
          "4892: static void",
          "4893: dtap_mm_loc_upd_req(tvbuff_t *tvb, proto_tree *tree, packet_info *pinfo _U_, guint32 offset, guint len)",
          "4894: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4480: static const value_string gsm_a_dtap_updating_type_vals[] = {",
          "4481:  { 0x00, \"Normal\"},",
          "4482:     { 0x01, \"Periodic\"},",
          "4483:  { 0x02, \"IMSI attach\"},",
          "4484:  { 0x03, \"Reserved\"},",
          "4485:  { 0, NULL }",
          "4486: };",
          "4488: static const true_false_string tfs_follow_on_request_value = {",
          "4489:  \"Follow-on request pending\",",
          "4490:  \"No follow-on request pending\"",
          "4491: };",
          "",
          "---------------",
          "--- Hunk 63 ---",
          "[Context before]",
          "4898:  guint8 oct;",
          "4899:  proto_tree *subtree;",
          "4900:  proto_item *item;",
          "4903:  curr_offset = offset;",
          "4904:  curr_len = len;",
          "",
          "[Removed Lines]",
          "4901:  const gchar *str;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 64 ---",
          "[Context before]",
          "4920:  proto_tree_add_bits_item(subtree, hf_gsm_a_spare_bits, tvb, curr_offset<<3, 1, ENC_BIG_ENDIAN);",
          "4924:  switch ((oct & 0x70) >> 4)",
          "4925:  {",
          "4926:  case 0x07:",
          "4931:   break;",
          "4933:  default:",
          "4939:   break;",
          "4940:  }",
          "",
          "[Removed Lines]",
          "4922:  other_decode_bitfield_value(a_bigbuf, oct, 0x70, 8);",
          "4927:   proto_tree_add_text(subtree,",
          "4928:    tvb, curr_offset, 1,",
          "4929:    \"%s = Ciphering Key Sequence Number: No key is available\",",
          "4930:    a_bigbuf);",
          "4934:   proto_tree_add_text(subtree,",
          "4935:    tvb, curr_offset, 1,",
          "4936:    \"%s = Ciphering Key Sequence Number: %u\",",
          "4937:    a_bigbuf,",
          "4938:    (oct & 0x70) >> 4);",
          "",
          "[Added Lines]",
          "4525:         proto_tree_add_uint_format_value(subtree, hf_gsm_a_dtap_ciphering_key_sequence_number70, tvb, curr_offset, 1,",
          "4526:                                         oct, \"No key is available\");",
          "4530:   proto_tree_add_item(subtree, hf_gsm_a_dtap_ciphering_key_sequence_number70, tvb, curr_offset, 1, ENC_NA);",
          "",
          "---------------",
          "--- Hunk 65 ---",
          "[Context before]",
          "4947:  subtree = proto_item_add_subtree(item, ett_gsm_dtap_elem[DE_LOC_UPD_TYPE]);",
          "4956:  proto_tree_add_bits_item(subtree, hf_gsm_a_spare_bits, tvb, (curr_offset<<3)+5, 1, ENC_BIG_ENDIAN);",
          "4977:  curr_offset++;",
          "4978:  curr_len--;",
          "",
          "[Removed Lines]",
          "4949:  other_decode_bitfield_value(a_bigbuf, oct, 0x08, 8);",
          "4950:  proto_tree_add_text(subtree,",
          "4951:   tvb, curr_offset, 1,",
          "4952:   \"%s = Follow-On Request (FOR): %s\",",
          "4953:   a_bigbuf,",
          "4954:   (oct & 0x08) ? \"Follow-on request pending\" : \"No follow-on request pending\");",
          "4958:  switch (oct & 0x03)",
          "4959:  {",
          "4960:  case 0: str = \"Normal\"; break;",
          "4961:  case 1: str = \"Periodic\"; break;",
          "4962:  case 2: str = \"IMSI attach\"; break;",
          "4963:  default:",
          "4964:   str = \"Reserved\";",
          "4965:   break;",
          "4966:  }",
          "4968:  other_decode_bitfield_value(a_bigbuf, oct, 0x03, 8);",
          "4969:  proto_tree_add_text(subtree,",
          "4970:   tvb, curr_offset, 1,",
          "4971:   \"%s = Updating Type: %s\",",
          "4972:   a_bigbuf,",
          "4973:   str);",
          "4975:  proto_item_append_text(item, \" - %s\", str);",
          "",
          "[Added Lines]",
          "4541:  proto_tree_add_item(subtree, hf_gsm_a_dtap_follow_on_request, tvb, curr_offset, 1, ENC_NA);",
          "4545:  proto_tree_add_item(subtree, hf_gsm_a_dtap_updating_type, tvb, curr_offset, 1, ENC_NA);",
          "4547:  proto_item_append_text(item, \" - %s\", val_to_str_const(oct & 0x03, gsm_a_dtap_updating_type_vals, \"Reserved\"));",
          "",
          "---------------",
          "--- Hunk 66 ---",
          "[Context before]",
          "5176: static void",
          "5177: dtap_cc_congestion_control(tvbuff_t *tvb, proto_tree *tree, packet_info *pinfo _U_, guint32 offset, guint len)",
          "5178: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4748: static const value_string gsm_a_dtap_congestion_level_vals[] = {",
          "4749:  { 0, \"Receiver ready\"},",
          "4750:  { 15, \"Receiver not ready\"},",
          "4751:  { 0, NULL }",
          "4752: };",
          "",
          "---------------",
          "--- Hunk 67 ---",
          "[Context before]",
          "5182:  guint8       oct;",
          "5183:  proto_tree  *subtree;",
          "5184:  proto_item  *item;",
          "5187:  curr_offset = offset;",
          "5188:  curr_len = len;",
          "",
          "[Removed Lines]",
          "5185:  const gchar *str;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 68 ---",
          "[Context before]",
          "5204:  subtree = proto_item_add_subtree(item, ett_gsm_dtap_elem[DE_CONGESTION]);",
          "5222:  curr_offset++;",
          "5223:  curr_len--;",
          "",
          "[Removed Lines]",
          "5206:  switch (oct & 0x0f)",
          "5207:  {",
          "5208:  case 0: str = \"Receiver ready\"; break;",
          "5209:  case 15: str = \"Receiver not ready\"; break;",
          "5210:  default:",
          "5211:   str = \"Reserved\";",
          "5212:   break;",
          "5213:  }",
          "5215:  other_decode_bitfield_value(a_bigbuf, oct, 0x0f, 8);",
          "5216:  proto_tree_add_text(subtree,",
          "5217:   tvb, curr_offset, 1,",
          "5218:   \"%s = Congestion level: %s\",",
          "5219:   a_bigbuf,",
          "5220:   str);",
          "",
          "[Added Lines]",
          "4783:  proto_tree_add_uint_format_value(subtree, hf_gsm_a_dtap_congestion_level, tvb, curr_offset, 1,",
          "4784:             oct, \"%s\", val_to_str_const(oct & 0xF, gsm_a_dtap_congestion_level_vals, \"Reserved\"));",
          "",
          "---------------",
          "--- Hunk 69 ---",
          "[Context before]",
          "6338: static void",
          "6339: dissect_dtap(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)",
          "6340: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5902: static const true_false_string tfs_ti_flags = { \"allocated by receiver\", \"allocated by sender\"};",
          "",
          "---------------",
          "--- Hunk 70 ---",
          "[Context before]",
          "6542:   col_set_fence(pinfo->cinfo, COL_INFO);",
          "6543:  }",
          "6551:  pd_tree = proto_item_add_subtree(oct_1_item, ett_dtap_oct_1);",
          "6552:  proto_tree_add_item(pd_tree, hf_gsm_a_L3_protocol_discriminator, tvb, 0, 1, ENC_BIG_ENDIAN);",
          "6554:  if (ti == -1)",
          "",
          "[Removed Lines]",
          "6545:  oct_1_item =",
          "6546:  proto_tree_add_text(dtap_tree,",
          "6547:   tvb, 0, 1,",
          "6548:   \"Protocol Discriminator: %s\",",
          "6549:   val_to_str(pd, protocol_discriminator_vals, \"Unknown (%u)\"));",
          "",
          "[Added Lines]",
          "6111:  oct_1_item = proto_tree_add_uint(dtap_tree, hf_gsm_a_dtap_protocol_discriminator, tvb, 0, 1, pd);",
          "",
          "---------------",
          "--- Hunk 71 ---",
          "[Context before]",
          "6557:  }",
          "6558:  else",
          "6559:  {",
          "6567:   if ((ti & DTAP_TIE_PRES_MASK) == DTAP_TIE_PRES_MASK)",
          "6568:   {",
          "6576:   }",
          "6577:   else",
          "6578:   {",
          "6585:   }",
          "6586:  }",
          "",
          "[Removed Lines]",
          "6560:   other_decode_bitfield_value(a_bigbuf, oct_1, 0x80, 8);",
          "6561:   proto_tree_add_text(pd_tree,",
          "6562:    tvb, 0, 1,",
          "6563:    \"%s = TI flag: %s\",",
          "6564:    a_bigbuf,",
          "6565:    ((oct_1 & 0x80) ?  \"allocated by receiver\" : \"allocated by sender\"));",
          "6571:    other_decode_bitfield_value(a_bigbuf, oct_1, 0x70, 8);",
          "6572:    proto_tree_add_text(pd_tree,",
          "6573:     tvb, 0, 1,",
          "6574:     \"%s = TIO: The TI value is given by the TIE in octet 2\",",
          "6575:     a_bigbuf);",
          "6579:    other_decode_bitfield_value(a_bigbuf, oct_1, 0x70, 8);",
          "6580:    proto_tree_add_text(pd_tree,",
          "6581:     tvb, 0, 1,",
          "6582:     \"%s = TIO: %u\",",
          "6583:     a_bigbuf,",
          "6584:     ti & DTAP_TIE_PRES_MASK);",
          "",
          "[Added Lines]",
          "6123:   proto_tree_add_item(pd_tree, hf_gsm_a_dtap_ti_flag, tvb, 0, 1, ENC_NA);",
          "6128:    proto_tree_add_uint_format_value(pd_tree, hf_gsm_a_dtap_tio, tvb, 0, 1,",
          "6129:                     oct_1, \"The TI value is given by the TIE in octet 2\");",
          "6133:    proto_tree_add_item(pd_tree, hf_gsm_a_dtap_tio, tvb, 0, 1, ENC_NA);",
          "",
          "---------------",
          "--- Hunk 72 ---",
          "[Context before]",
          "6589:   (ti & DTAP_TIE_PRES_MASK) == DTAP_TIE_PRES_MASK)",
          "6590:  {",
          "6591:   proto_tree_add_item(tree, hf_gsm_a_extension, tvb, 1, 1, ENC_BIG_ENDIAN);",
          "6599:  }",
          "",
          "[Removed Lines]",
          "6593:   other_decode_bitfield_value(a_bigbuf, oct_2, DTAP_TIE_MASK, 8);",
          "6594:   proto_tree_add_text(pd_tree,",
          "6595:    tvb, 1, 1,",
          "6596:    \"%s = TIE: %u\",",
          "6597:    a_bigbuf,",
          "6598:    oct_2 & DTAP_TIE_MASK);",
          "",
          "[Added Lines]",
          "6141:   proto_tree_add_item(pd_tree, hf_gsm_a_dtap_tie, tvb, 1, 1, ENC_NA);",
          "",
          "---------------",
          "--- Hunk 73 ---",
          "[Context before]",
          "6717:  },",
          "6718:  { &hf_gsm_a_dtap_cause,",
          "6719:   { \"DTAP Cause\", \"gsm_a.dtap.cause\",",
          "6721:   NULL, HFILL }",
          "6722:  },",
          "6723:  { &hf_gsm_a_dtap_type_of_number,",
          "",
          "[Removed Lines]",
          "6720:   FT_UINT8, BASE_HEX, 0, 0x0,",
          "",
          "[Added Lines]",
          "6263:   FT_UINT8, BASE_HEX, 0, 0x7f,",
          "",
          "---------------",
          "--- Hunk 74 ---",
          "[Context before]",
          "7140:   FT_UINT24, BASE_DEC, NULL, 0x0,",
          "7141:   NULL, HFILL }",
          "7142:  },",
          "7143:  };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6687:       { &hf_gsm_a_dtap_coding_scheme, { \"Coding Scheme\", \"gsm_a.dtap.coding_scheme\", FT_UINT8, BASE_DEC, NULL, 0x70, NULL, HFILL }},",
          "6688:       { &hf_gsm_a_dtap_add_ci, { \"Add CI\", \"gsm_a.dtap.add_ci\", FT_BOOLEAN, 8, TFS(&tfs_add_ci), 0x08, NULL, HFILL }},",
          "6689:       { &hf_gsm_a_dtap_number_of_spare_bits, { \"Number of spare bits in last octet\", \"gsm_a.dtap.number_of_spare_bits\", FT_UINT8, BASE_DEC, VALS(gsm_a_dtap_number_of_spare_bits_vals), 0x07, NULL, HFILL }},",
          "6690:       { &hf_gsm_a_dtap_text_string, { \"Text String\", \"gsm_a.dtap.text_string\", FT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL }},",
          "6691:       { &hf_gsm_a_dtap_time_zone_time, { \"Timezone time\", \"gsm_a.dtap.time_zone_time\", FT_ABSOLUTE_TIME, ABSOLUTE_TIME_LOCAL, NULL, 0x0, NULL, HFILL }},",
          "6692:       { &hf_gsm_a_dtap_dst_adjustment, { \"DST Adjustment\", \"gsm_a.dtap.dst_adjustment\", FT_UINT8, BASE_DEC, VALS(gsm_a_dtap_dst_adjustment_vals), 0x03, NULL, HFILL }},",
          "6693:       { &hf_gsm_a_dtap_emergency_number_information, { \"Emergency Number Information\", \"gsm_a.dtap.emergency_number_information\", FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL }},",
          "6694:       { &hf_gsm_a_dtap_mm_timer, { \"MM Timer\", \"gsm_a.dtap.mm_timer\", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},",
          "6695:       { &hf_gsm_a_dtap_hold_auxiliary_state, { \"Hold auxiliary state\", \"gsm_a.dtap.hold_auxiliary_state\", FT_UINT8, BASE_DEC, VALS(gsm_a_dtap_hold_auxilary_state_vals), 0x0C, NULL, HFILL }},",
          "6696:       { &hf_gsm_a_dtap_multi_party_auxiliary_state, { \"Multi party auxiliary state\", \"gsm_a.dtap.multi_party_auxiliary_state\", FT_UINT8, BASE_DEC, VALS(gsm_a_dtap_multi_party_auxilary_state_vals), 0x03, NULL, HFILL }},",
          "6697:       { &hf_gsm_a_dtap_radio_channel_requirement, { \"Radio channel requirement\", \"gsm_a.dtap.radio_channel_requirement\", FT_UINT8, BASE_DEC, NULL, 0x60, NULL, HFILL }},",
          "6698:       { &hf_gsm_a_dtap_bearer_cap_coding_standard, { \"Coding standard\", \"gsm_a.dtap.coding_standard\", FT_BOOLEAN, 8, TFS(&tfs_bearer_cap_coding_standard), 0x10, NULL, HFILL }},",
          "6699:       { &hf_gsm_a_dtap_transfer_mode, { \"Transfer mode\", \"gsm_a.dtap.transfer_mode\", FT_BOOLEAN, 8, TFS(&tfs_bearer_cap_transfer_mode), 0x08, NULL, HFILL }},",
          "6700:       { &hf_gsm_a_dtap_coding, { \"Coding\", \"gsm_a.dtap.coding\", FT_BOOLEAN, 8, TFS(&tfs_bearer_cap_coding), 0x40, NULL, HFILL }},",
          "6701:       { &hf_gsm_a_dtap_compression, { \"Compression\", \"gsm_a.dtap.compression\", FT_BOOLEAN, 8, TFS(&tfs_possible_not_possible), 0x40, NULL, HFILL }},",
          "6702:       { &hf_gsm_a_dtap_compression_up, { \"Compression\", \"gsm_a.dtap.compression\", FT_BOOLEAN, 8, TFS(&tfs_allowed_not_allowed), 0x40, NULL, HFILL }},",
          "6703:       { &hf_gsm_a_dtap_structure, { \"Structure\", \"gsm_a.dtap.structure\", FT_UINT8, BASE_DEC, VALS(gsm_a_dtap_structure_vals), 0x30, NULL, HFILL }},",
          "6704:       { &hf_gsm_a_dtap_duplex_mode, { \"Duplex mode\", \"gsm_a.dtap.duplex_mode\", FT_BOOLEAN, 8, TFS(&tfs_duplex_mode), 0x08, NULL, HFILL }},",
          "6705:       { &hf_gsm_a_dtap_configuration, { \"Configuration\", \"gsm_a.dtap.configuration\", FT_BOOLEAN, 8, TFS(&tfs_bearer_cap_configuration), 0x04, NULL, HFILL }},",
          "6706:       { &hf_gsm_a_dtap_nirr, { \"NIRR\", \"gsm_a.dtap.nirr\", FT_BOOLEAN, 8, TFS(&tfs_nirr), 0x02, NULL, HFILL }},",
          "6707:       { &hf_gsm_a_dtap_establishment, { \"Establishment\", \"gsm_a.dtap.establishment\", FT_BOOLEAN, 8, TFS(&tfs_bearer_cap_establishment), 0x01, NULL, HFILL }},",
          "6708:       { &hf_gsm_a_dtap_access_identity, { \"Access Identity\", \"gsm_a.dtap.access_identity\", FT_UINT8, BASE_DEC, VALS(&gsm_a_dtap_access_identity_vals), 0x60, NULL, HFILL }},",
          "6709:       { &hf_gsm_a_dtap_rate_adaption, { \"Rate Adaption\", \"gsm_a.dtap.rate_adaption\", FT_UINT8, BASE_DEC, VALS(&gsm_a_dtap_rate_adaption_vals), 0x18, NULL, HFILL }},",
          "6710:       { &hf_gsm_a_dtap_signalling_access_protocol, { \"Signalling Access Protocol\", \"gsm_a.dtap.signalling_access_protocol\", FT_UINT8, BASE_DEC, VALS(&gsm_a_dtap_signal_access_protocol_vals), 0x07, NULL, HFILL }},",
          "6711:       { &hf_gsm_a_dtap_other_itc, { \"Other ITC\", \"gsm_a.dtap.other_itc\", FT_UINT8, BASE_DEC, VALS(gsm_a_dtap_other_itc_vals), 0x60, NULL, HFILL }},",
          "6712:       { &hf_gsm_a_dtap_other_rate_adaption, { \"Other Rate Adaption\", \"gsm_a.dtap.other_rate_adaption\", FT_UINT8, BASE_DEC, VALS(gsm_a_dtap_other_rate_adaption_vals), 0x18, NULL, HFILL }},",
          "6713:       { &hf_gsm_a_dtap_rate_adaption_header, { \"Rate Adaption Header\", \"gsm_a.dtap.rate_adaption_header\", FT_BOOLEAN, 8, TFS(&tfs_included_not_included), 0x40, NULL, HFILL }},",
          "6714:       { &hf_gsm_a_dtap_multiple_frame_establishment_support, { \"Multiple frame establishment support in data link\", \"gsm_a.dtap.multiple_frame_establishment_support\", FT_BOOLEAN, 8, TFS(&tfs_frame_est_supported_not_supported), 0x20, NULL, HFILL }},",
          "6715:       { &hf_gsm_a_dtap_mode_of_operation, { \"Mode of operation\", \"gsm_a.dtap.mode_of_operation\", FT_BOOLEAN, 8, TFS(&tfs_mode_of_operation), 0x10, NULL, HFILL }},",
          "6716:       { &hf_gsm_a_dtap_logical_link_identifier_negotiation, { \"Logical link identifier negotiation\", \"gsm_a.dtap.logical_link_identifier_negotiation\", FT_BOOLEAN, 8, TFS(&tfs_log_link_neg), 0x08, NULL, HFILL }},",
          "6717:       { &hf_gsm_a_dtap_assignor_assignee, { \"Assignor/Assignee\", \"gsm_a.dtap.assignor_assignee\", FT_BOOLEAN, 8, TFS(&tfs_assignor_assignee), 0x04, NULL, HFILL }},",
          "6718:       { &hf_gsm_a_dtap_in_out_band, { \"In band/Out of band negotiation\", \"gsm_a.dtap.in_out_band\", FT_BOOLEAN, 8, TFS(&tfs_in_out_band), 0x02, NULL, HFILL }},",
          "6719:       { &hf_gsm_a_dtap_layer_1_identity, { \"Layer 1 Identity\", \"gsm_a.dtap.layer_1_identity\", FT_UINT8, BASE_DEC, NULL, 0x60, NULL, HFILL }},",
          "6720:       { &hf_gsm_a_dtap_user_information_layer_1_protocol, { \"User information layer 1 protocol\", \"gsm_a.dtap.user_information_layer_1_protocol\", FT_UINT8, BASE_DEC, NULL, 0x1e, NULL, HFILL }},",
          "6721:       { &hf_gsm_a_dtap_synchronous, { \"Synchronous/asynchronous\", \"gsm_a.dtap.synchronous\", FT_BOOLEAN, 8, TFS(&tfs_asynchronous_synchronous), 0x01, NULL, HFILL }},",
          "6722:       { &hf_gsm_a_dtap_number_of_stop_bits, { \"Number of Stop Bits\", \"gsm_a.dtap.number_of_stop_bits\", FT_BOOLEAN, 8, TFS(&tfs_stop_bits), 0x40, NULL, HFILL }},",
          "6723:       { &hf_gsm_a_dtap_negotiation, { \"Negotiation\", \"gsm_a.dtap.negotiation\", FT_BOOLEAN, 8, TFS(&tfs_negotiation), 0x20, NULL, HFILL }},",
          "6724:       { &hf_gsm_a_dtap_number_of_data_bits, { \"Number of data bits excluding parity bit if present\", \"gsm_a.dtap.number_of_data_bits\", FT_BOOLEAN, 8, TFS(&tfs_parity_bits), 0x10, NULL, HFILL }},",
          "6725:       { &hf_gsm_a_dtap_user_rate, { \"User rate\", \"gsm_a.dtap.user_rate\", FT_UINT8, BASE_DEC, VALS(gsm_a_dtap_user_rate_vals), 0x0F, NULL, HFILL }},",
          "6726:       { &hf_gsm_a_dtap_v110_x30_rate_adaptation, { \"V.110/X.30 rate adaptation Intermediate rate\", \"gsm_a.dtap.v110_x30_rate_adaptation\", FT_UINT8, BASE_DEC, VALS(gsm_a_dtap_v110_x30_rate_adaptation_vals), 0x60, NULL, HFILL }},",
          "6727:       { &hf_gsm_a_dtap_nic_on_tx, { \"Network independent clock (NIC) on transmission (Tx)\", \"gsm_a.dtap.nic_on_tx\", FT_BOOLEAN, 8, TFS(&tfs_nic_on_tx), 0x10, NULL, HFILL }},",
          "6728:       { &hf_gsm_a_dtap_nic_on_rx, { \"Network independent clock (NIC) on reception (Rx)\", \"gsm_a.dtap.nic_on_rx\", FT_BOOLEAN, 8, TFS(&tfs_nic_on_rx), 0x08, NULL, HFILL }},",
          "6729:       { &hf_gsm_a_dtap_parity_information, { \"Parity information\", \"gsm_a.dtap.parity_information\", FT_UINT8, BASE_DEC, VALS(gsm_a_dtap_parity_info_vals), 0x07, NULL, HFILL }},",
          "6730:       { &hf_gsm_a_dtap_connection_element, { \"Connection element\", \"gsm_a.dtap.connection_element\", FT_UINT8, BASE_DEC, VALS(gsm_a_dtap_connection_element_vals), 0x60, NULL, HFILL }},",
          "6731:       { &hf_gsm_a_dtap_modem_type, { \"Modem type\", \"gsm_a.dtap.modem_type\", FT_UINT8, BASE_DEC, NULL, 0x1f, NULL, HFILL }},",
          "6732:       { &hf_gsm_a_dtap_other_modem_type, { \"Other modem type\", \"gsm_a.dtap.other_modem_type\", FT_UINT8, BASE_DEC, VALS(gsm_a_dtap_other_modem_type_vals), 0x60, NULL, HFILL }},",
          "6733:       { &hf_gsm_a_dtap_fixed_network_user_rate, { \"Fixed network user rate\", \"gsm_a.dtap.fixed_network_user_rate\", FT_UINT8, BASE_DEC, NULL, 0x1f, NULL, HFILL }},",
          "6734:       { &hf_gsm_a_dtap_acceptable_channel_codings_TCH_F14_4, { \"Acceptable channel codings (TCH/F14.4)\", \"gsm_a.dtap.acceptable_channel_codings.TCH_F14_4\", FT_BOOLEAN, 8, TFS(&tfs_acceptable_not_acceptable), 0x40, NULL, HFILL }},",
          "6735:       { &hf_gsm_a_dtap_acceptable_channel_codings_spare20, { \"Acceptable channel codings (Spare)\", \"gsm_a.dtap.acceptable_channel_codings.spare\", FT_BOOLEAN, 8, NULL, 0x20, NULL, HFILL }},",
          "6736:       { &hf_gsm_a_dtap_acceptable_channel_codings_TCH_F9_6, { \"Acceptable channel codings (TCH/F9.6)\", \"gsm_a.dtap.acceptable_channel_codings.TCH_F9_6\", FT_BOOLEAN, 8, TFS(&tfs_acceptable_not_acceptable), 0x10, NULL, HFILL }},",
          "6737:       { &hf_gsm_a_dtap_acceptable_channel_codings_TCH_F4_8, { \"Acceptable channel codings (TCH/F4.8)\", \"gsm_a.dtap.acceptable_channel_codings.TCH_F4_8\", FT_BOOLEAN, 8, TFS(&tfs_acceptable_not_acceptable), 0x08, NULL, HFILL }},",
          "6738:       { &hf_gsm_a_dtap_maximum_number_of_traffic_channels, { \"Maximum number of traffic channels\", \"gsm_a.dtap.maximum_number_of_traffic_channels\", FT_UINT8, BASE_DEC, NULL, 0x07, NULL, HFILL }},",
          "6739:       { &hf_gsm_a_dtap_acceptable_channel_codings_spare78, { \"Acceptable channel codings\", \"gsm_a.dtap.acceptable_channel_codings\", FT_UINT8, BASE_DEC, NULL, 0x78, NULL, HFILL }},",
          "6740:       { &hf_gsm_a_dtap_uimi, { \"UIMI, User initiated modification indication\", \"gsm_a.dtap.uimi\", FT_UINT8, BASE_DEC, VALS(gsm_a_dtap_uimi_vals), 0x70, NULL, HFILL }},",
          "6741:       { &hf_gsm_a_dtap_wanted_air_interface_user_rate, { \"Wanted air interface user rate\", \"gsm_a.dtap.wanted_air_interface_user_rate\", FT_UINT8, BASE_DEC, VALS(gsm_a_dtap_wanted_air_rate_vals), 0x0F, NULL, HFILL }},",
          "6742:       { &hf_gsm_a_dtap_acceptable_channel_codings_ext_TCH_F28_8, { \"Acceptable channel codings extended (TCH/F28.8)\", \"gsm_a.dtap.acceptable_channel_codings_ext.TCH_F28_8\", FT_BOOLEAN, 8, TFS(&tfs_acceptable_not_acceptable), 0x40, NULL, HFILL }},",
          "6743:       { &hf_gsm_a_dtap_acceptable_channel_codings_ext_TCH_F32_0, { \"Acceptable channel codings extended (TCH/F32.0)\", \"gsm_a.dtap.acceptable_channel_codings_ext.TCH_F32_0\", FT_BOOLEAN, 8, TFS(&tfs_acceptable_not_acceptable), 0x20, NULL, HFILL }},",
          "6744:       { &hf_gsm_a_dtap_acceptable_channel_codings_ext_TCH_F43_2, { \"Acceptable channel codings extended (TCH/F43.2)\", \"gsm_a.dtap.acceptable_channel_codings_ext.TCH_F43_2\", FT_BOOLEAN, 8, TFS(&tfs_acceptable_not_acceptable), 0x10, NULL, HFILL }},",
          "6745:       { &hf_gsm_a_dtap_channel_coding_asymmetry_indication, { \"Channel Coding Asymmetry Indication\", \"gsm_a.dtap.channel_coding_asymmetry_indication\", FT_UINT8, BASE_DEC, VALS(gsm_a_dtap_channel_coding_asymmetry_ind_vals), 0x0c, NULL, HFILL }},",
          "6746:       { &hf_gsm_a_dtap_edge_channel_codings, { \"EDGE Channel Codings\", \"gsm_a.dtap.edge_channel_codings\", FT_UINT8, BASE_DEC, NULL, 0x7c, NULL, HFILL }},",
          "6747:       { &hf_gsm_a_dtap_layer_2_identity, { \"Layer 2 Identity\", \"gsm_a.dtap.layer_2_identity\", FT_UINT8, BASE_DEC, NULL, 0x60, NULL, HFILL }},",
          "6748:       { &hf_gsm_a_dtap_user_information_layer_2_protocol, { \"User information layer 2 protocol\", \"gsm_a.dtap.user_information_layer_2_protocol\", FT_UINT8, BASE_DEC, NULL, 0x1f, NULL, HFILL }},",
          "6749:       { &hf_gsm_a_dtap_maximum_number_of_supported_bearers, { \"Maximum number of supported bearers\", \"gsm_a.dtap.maximum_number_of_supported_bearers\", FT_UINT8, BASE_DEC, NULL, 0xf0, NULL, HFILL }},",
          "6750:       { &hf_gsm_a_dtap_pcp, { \"Prolonged Clearing Procedure\", \"gsm_a.dtap.pcp\", FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x02, NULL, HFILL }},",
          "6751:       { &hf_gsm_a_dtap_dtmf, { \"DTMF\", \"gsm_a.dtap.dtmf\", FT_BOOLEAN, 8, TFS(&gsm_a_dtap_dtmf_value), 0x01, NULL, HFILL }},",
          "6752:       { &hf_gsm_a_dtap_max_num_of_speech_bearers, { \"Maximum number of speech bearers\", \"gsm_a.dtap.max_num_of_speech_bearers\", FT_UINT8, BASE_DEC, NULL, 0x0f, NULL, HFILL }},",
          "6753:       { &hf_gsm_a_dtap_de_cause_coding_standard, { \"Coding standard\", \"gsm_a.dtap.coding_standard\", FT_UINT8, BASE_DEC, VALS(gsm_a_dtap_de_cause_coding_standard_vals), 0x60, NULL, HFILL }},",
          "6754:       { &hf_gsm_a_dtap_recommendation, { \"Recommendation\", \"gsm_a.dtap.recommendation\", FT_UINT8, BASE_DEC, NULL, 0x7f, NULL, HFILL }},",
          "6755:       { &hf_gsm_a_dtap_data, { \"Data\", \"gsm_a.dtap.data\", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},",
          "6756:       { &hf_gsm_a_dtap_keypad_information, { \"Keypad information\", \"gsm_a.dtap.keypad_information\", FT_UINT8, BASE_DEC, NULL, 0x7f, NULL, HFILL }},",
          "6757:       { &hf_gsm_a_dtap_repeat_indicator, { \"Repeat Indicator\", \"gsm_a.dtap.repeat_indicator\", FT_UINT8, BASE_DEC, NULL, 0x0f, NULL, HFILL }},",
          "6758:       { &hf_gsm_a_dtap_ss_version_indicator, { \"SS Version Indicator\", \"gsm_a.dtap.ss_version_indicator\", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},",
          "6759:       { &hf_gsm_a_dtap_cp_cause, { \"Cause\", \"gsm_a.dtap.cp_cause\", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},",
          "6760:       { &hf_gsm_a_dtap_test_loop, { \"Test Loop\", \"gsm_a.dtap.test_loop\", FT_UINT8, BASE_DEC, NULL, 0x3f, NULL, HFILL }},",
          "6761:       { &hf_gsm_a_dtap_channel_coding03, { \"Channel coding\", \"gsm_a.dtap.channel_coding\", FT_UINT8, BASE_DEC, VALS(gsm_channel_coding_vals), 0x03, NULL, HFILL }},",
          "6762:       { &hf_gsm_a_dtap_channel_coding30, { \"Channel coding\", \"gsm_a.dtap.channel_coding\", FT_UINT8, BASE_DEC, VALS(gsm_channel_coding_vals), 0x30, NULL, HFILL }},",
          "6763:       { &hf_gsm_a_dtap_tp_tested_device, { \"Tested device\", \"gsm_a.dtap.tp_tested_device\", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},",
          "6764:       { &hf_gsm_a_dtap_tp_pdu_description, { \"PDUs transmitted\", \"gsm_a.dtap.tp_pdu_description\", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }},",
          "6765:       { &hf_gsm_a_dtap_downlink_timeslot_offset, { \"Downlink Timeslot Offset\", \"gsm_a.dtap.downlink_timeslot_offset\", FT_UINT8, BASE_DEC, NULL, 0x0E, NULL, HFILL }},",
          "6766:       { &hf_gsm_a_dtap_ms_positioning_technology, { \"MS positioning technology\", \"gsm_a.dtap.ms_positioning_technology\", FT_UINT8, BASE_DEC, VALS(gsm_positioning_technology_vals), 0x0, NULL, HFILL }},",
          "6767:       { &hf_gsm_a_dtap_ue_positioning_technology, { \"UE positioning technology\", \"gsm_a.dtap.ue_positioning_technology\", FT_UINT8, BASE_DEC, VALS(gsm_positioning_technology_vals), 0x0, NULL, HFILL }},",
          "6768:       { &hf_gsm_a_dtap_ciphering_key_sequence_number, { \"Ciphering Key Sequence Number\", \"gsm_a.dtap.ciphering_key_sequence_number\", FT_UINT8, BASE_DEC, NULL, 0x07, NULL, HFILL }},",
          "6769:       { &hf_gsm_a_dtap_ciphering_key_sequence_number70, { \"Ciphering Key Sequence Number\", \"gsm_a.dtap.ciphering_key_sequence_number\", FT_UINT8, BASE_DEC, NULL, 0x70, NULL, HFILL }},",
          "6770:       { &hf_gsm_a_dtap_service_type, { \"Service Type\", \"gsm_a.dtap.service_type\", FT_UINT8, BASE_DEC, VALS(gsm_a_dtap_service_type_vals), 0x0F, NULL, HFILL }},",
          "6771:       { &hf_gsm_a_dtap_type_of_identity, { \"Type of identity\", \"gsm_a.dtap.type_of_identity\", FT_UINT8, BASE_DEC, VALS(gsm_a_dtap_type_of_identity_vals), 0x07, NULL, HFILL }},",
          "6772:       { &hf_gsm_a_dtap_follow_on_request, { \"Follow-On Request (FOR)\", \"gsm_a.dtap.follow_on_request\", FT_BOOLEAN, 8, TFS(&tfs_follow_on_request_value ), 0x08, NULL, HFILL }},",
          "6773:       { &hf_gsm_a_dtap_updating_type, { \"Updating Type\", \"gsm_a.dtap.updating_type\", FT_UINT8, BASE_DEC, VALS(gsm_a_dtap_updating_type_vals), 0x03, NULL, HFILL }},",
          "6774:       { &hf_gsm_a_dtap_congestion_level, { \"Congestion level\", \"gsm_a.dtap.congestion_level\", FT_UINT8, BASE_DEC, NULL, 0x0F, NULL, HFILL }},",
          "6775:       { &hf_gsm_a_dtap_protocol_discriminator, { \"Protocol Discriminator\", \"gsm_a.dtap.protocol_discriminator\", FT_UINT8, BASE_DEC, VALS(protocol_discriminator_vals), 0x0, NULL, HFILL }},",
          "6776:       { &hf_gsm_a_dtap_ti_flag, { \"TI flag\", \"gsm_a.dtap.ti_flag\", FT_BOOLEAN, 8, TFS(&tfs_ti_flags), 0x80, NULL, HFILL }},",
          "6777:       { &hf_gsm_a_dtap_tio, { \"TIO\", \"gsm_a.dtap.tio\", FT_UINT8, BASE_DEC, NULL, 0x70, NULL, HFILL }},",
          "6778:       { &hf_gsm_a_dtap_tie, { \"TIE\", \"gsm_a.dtap.tie\", FT_UINT8, BASE_DEC, NULL, DTAP_TIE_MASK, NULL, HFILL }},",
          "",
          "---------------"
        ],
        "tools/convert_proto_tree_add_text.pl||tools/convert_proto_tree_add_text.pl": [
          "File: tools/convert_proto_tree_add_text.pl -> tools/convert_proto_tree_add_text.pl",
          "--- Hunk 1 ---",
          "[Context before]",
          "65:         'BASE_DEC_HEX' => \"BASE_DEC_HEX\",",
          "66:         'BASE_HEX_DEC' => \"BASE_HEX_DEC\",",
          "67:         'BASE_EXT_STRING' => \"BASE_EXT_STRING\",",
          "68:         'BASE_CUSTOM' => \"BASE_CUSTOM\");",
          "70: my %ENCODINGS = ('ENC_BIG_ENDIAN' => \"ENC_BIG_ENDIAN\",",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "68:         'ABSOLUTE_TIME_LOCAL' => \"ABSOLUTE_TIME_LOCAL\",",
          "69:         'ABSOLUTE_TIME_UTC' => \"ABSOLUTE_TIME_UTC\",",
          "70:         'ABSOLUTE_TIME_DOY_UTC' => \"ABSOLUTE_TIME_DOY_UTC\",",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2019-19244",
  "cve_desc": "sqlite3Select in select.c in SQLite 3.30.1 allows a crash if a sub-select uses both DISTINCT and window functions, and also has certain ORDER BY usage.",
  "repo": "sqlite/sqlite",
  "patch_hash": "e59c562b3f6894f84c715772c4b116d7b5c01348",
  "patch_info": {
    "commit_hash": "e59c562b3f6894f84c715772c4b116d7b5c01348",
    "repo": "sqlite/sqlite",
    "commit_url": "https://github.com/sqlite/sqlite/commit/e59c562b3f6894f84c715772c4b116d7b5c01348",
    "files": [
      "manifest",
      "manifest.uuid",
      "src/select.c",
      "test/window1.test"
    ],
    "message": "Fix a crash that could occur if a sub-select that uses both DISTINCT and window functions also used an ORDER BY that is the same as its select list.\n\nFossilOrigin-Name: bcdd66c1691955c697f3d756c2b035acfe98f6aad72e90b0021bab6e9023b3ba",
    "before_after_code_files": [
      "manifest.uuid||manifest.uuid",
      "src/select.c||src/select.c",
      "test/window1.test||test/window1.test"
    ]
  },
  "patch_diff": {
    "manifest.uuid||manifest.uuid": [
      "File: manifest.uuid -> manifest.uuid",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "1: 6a64fb6a2da6c98f1e87b55ad5689967e1db4eae2e08345471d95e28cd567e0f",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "src/select.c||src/select.c": [
      "File: src/select.c -> src/select.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "6065:   if( (p->selFlags & (SF_Distinct|SF_Aggregate))==SF_Distinct",
      "6066:    && sqlite3ExprListCompare(sSort.pOrderBy, pEList, -1)==0",
      "6067:   ){",
      "6068:     p->selFlags &= ~SF_Distinct;",
      "6069:     pGroupBy = p->pGroupBy = sqlite3ExprListDup(db, pEList, 0);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "6067:    && p->pWin==0",
      "",
      "---------------"
    ],
    "test/window1.test||test/window1.test": [
      "File: test/window1.test -> test/window1.test",
      "--- Hunk 1 ---",
      "[Context before]",
      "1243:   ALTER TABLE a0 RENAME TO S;",
      "1244: } {1 {error in view a: 1st ORDER BY term does not match any column in the result set}}",
      "1246: finish_test",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1246: reset_db",
      "1247: do_execsql_test 33.1 {",
      "1248:   CREATE TABLE t1(aa, bb);",
      "1249:   INSERT INTO t1 VALUES(1, 2);",
      "1250:   INSERT INTO t1 VALUES(5, 6);",
      "1251:   CREATE TABLE t2(x);",
      "1252:   INSERT INTO t2 VALUES(1);",
      "1253: }",
      "1254: do_execsql_test 33.2 {",
      "1255:   SELECT (SELECT DISTINCT sum(aa) OVER() FROM t1 ORDER BY 1), x FROM t2",
      "1256:   ORDER BY 1;",
      "1257: } {6 1}",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "920cf596e67ecccecb497cfa60cc65945048f866",
      "candidate_info": {
        "commit_hash": "920cf596e67ecccecb497cfa60cc65945048f866",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/920cf596e67ecccecb497cfa60cc65945048f866",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/analyze.c",
          "src/attach.c",
          "src/expr.c",
          "src/vdbe.c",
          "src/vdbe.h",
          "src/vdbeaux.c"
        ],
        "message": "Simplify the bytecode generation for SQL function calls such that the OP_Function or OP_PureFunc opcodes are coded directly, rather than using the intermediate OP_Function0 or OP_PureFunc0 - opcodes that are now removed.\n\nFossilOrigin-Name: 84e02d773d60cffe619104991d21d7f0c68616c0f6bb99686bf54f5306c756d0",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/analyze.c||src/analyze.c",
          "src/attach.c||src/attach.c",
          "src/expr.c||src/expr.c",
          "src/vdbe.c||src/vdbe.c",
          "src/vdbe.h||src/vdbe.h",
          "src/vdbeaux.c||src/vdbeaux.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 13fe6978b7de208d2e27460d824f7fc778cf6ea0aabfe566b32bb410b8816f63",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/analyze.c||src/analyze.c": [
          "File: src/analyze.c -> src/analyze.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "916:   {0}",
          "917: };",
          "921: #ifdef SQLITE_ENABLE_STAT4",
          "923: #elif SQLITE_DEBUG",
          "924:   assert( iParam==STAT_GET_STAT1 );",
          "925: #else",
          "926:   UNUSED_PARAMETER( iParam );",
          "927: #endif",
          "931: }",
          "",
          "[Removed Lines]",
          "919: static void callStatGet(Vdbe *v, int regStat4, int iParam, int regOut){",
          "920:   assert( regOut!=regStat4 && regOut!=regStat4+1 );",
          "922:   sqlite3VdbeAddOp2(v, OP_Integer, iParam, regStat4+1);",
          "928:   sqlite3VdbeAddOp4(v, OP_Function0, 0, regStat4, regOut,",
          "929:                     (char*)&statGetFuncdef, P4_FUNCDEF);",
          "930:   sqlite3VdbeChangeP5(v, 1 + IsStat4);",
          "",
          "[Added Lines]",
          "919: static void callStatGet(Parse *pParse, int regStat4, int iParam, int regOut){",
          "921:   sqlite3VdbeAddOp2(pParse->pVdbe, OP_Integer, iParam, regStat4+1);",
          "927:   assert( regOut!=regStat4 && regOut!=regStat4+1 );",
          "928:   sqlite3VdbeAddFunctionCall(pParse, 0, regStat4, regOut, 1+IsStat4,",
          "929:                              &statGetFuncdef, 0);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1095: #endif",
          "1096:     sqlite3VdbeAddOp2(v, OP_Integer, nCol, regStat4+1);",
          "1097:     sqlite3VdbeAddOp2(v, OP_Integer, pIdx->nKeyCol, regStat4+2);",
          "",
          "[Removed Lines]",
          "1098:     sqlite3VdbeAddOp4(v, OP_Function0, 0, regStat4+1, regStat4,",
          "1099:                      (char*)&statInitFuncdef, P4_FUNCDEF);",
          "1100:     sqlite3VdbeChangeP5(v, 2+IsStat4);",
          "",
          "[Added Lines]",
          "1097:     sqlite3VdbeAddFunctionCall(pParse, 0, regStat4+1, regStat4, 2+IsStat4,",
          "1098:                                &statInitFuncdef, 0);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1192:     }",
          "1193: #endif",
          "1194:     assert( regChng==(regStat4+1) );",
          "1198:     sqlite3VdbeAddOp2(v, OP_Next, iIdxCur, addrNextRow); VdbeCoverage(v);",
          "1202:     assert( \"BBB\"[0]==SQLITE_AFF_TEXT );",
          "1203:     sqlite3VdbeAddOp4(v, OP_MakeRecord, regTabname, 3, regTemp, \"BBB\", 0);",
          "1204:     sqlite3VdbeAddOp2(v, OP_NewRowid, iStatCur, regNewRowid);",
          "",
          "[Removed Lines]",
          "1195:     sqlite3VdbeAddOp4(v, OP_Function0, 1, regStat4, regTemp,",
          "1196:                      (char*)&statPushFuncdef, P4_FUNCDEF);",
          "1197:     sqlite3VdbeChangeP5(v, 2+IsStat4);",
          "1201:     callStatGet(v, regStat4, STAT_GET_STAT1, regStat1);",
          "",
          "[Added Lines]",
          "1193:     sqlite3VdbeAddFunctionCall(pParse, 1, regStat4, regTemp, 2+IsStat4,",
          "1194:                                &statPushFuncdef, 0);",
          "1198:     callStatGet(pParse, regStat4, STAT_GET_STAT1, regStat1);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1224:       pParse->nMem = MAX(pParse->nMem, regCol+nCol);",
          "1226:       addrNext = sqlite3VdbeCurrentAddr(v);",
          "1228:       addrIsNull = sqlite3VdbeAddOp1(v, OP_IsNull, regSampleRowid);",
          "1229:       VdbeCoverage(v);",
          "1233:       sqlite3VdbeAddOp4Int(v, seekOp, iTabCur, addrNext, regSampleRowid, 0);",
          "1234:       VdbeCoverage(v);",
          "1235:       for(i=0; i<nCol; i++){",
          "",
          "[Removed Lines]",
          "1227:       callStatGet(v, regStat4, STAT_GET_ROWID, regSampleRowid);",
          "1230:       callStatGet(v, regStat4, STAT_GET_NEQ, regEq);",
          "1231:       callStatGet(v, regStat4, STAT_GET_NLT, regLt);",
          "1232:       callStatGet(v, regStat4, STAT_GET_NDLT, regDLt);",
          "",
          "[Added Lines]",
          "1224:       callStatGet(pParse, regStat4, STAT_GET_ROWID, regSampleRowid);",
          "1227:       callStatGet(pParse, regStat4, STAT_GET_NEQ, regEq);",
          "1228:       callStatGet(pParse, regStat4, STAT_GET_NLT, regLt);",
          "1229:       callStatGet(pParse, regStat4, STAT_GET_NDLT, regDLt);",
          "",
          "---------------"
        ],
        "src/attach.c||src/attach.c": [
          "File: src/attach.c -> src/attach.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "402:   assert( v || db->mallocFailed );",
          "403:   if( v ){",
          "",
          "[Removed Lines]",
          "404:     sqlite3VdbeAddOp4(v, OP_Function0, 0, regArgs+3-pFunc->nArg, regArgs+3,",
          "405:                       (char *)pFunc, P4_FUNCDEF);",
          "406:     assert( pFunc->nArg==-1 || (pFunc->nArg&0xff)==pFunc->nArg );",
          "407:     sqlite3VdbeChangeP5(v, (u8)(pFunc->nArg));",
          "",
          "[Added Lines]",
          "404:     sqlite3VdbeAddFunctionCall(pParse, 0, regArgs+3-pFunc->nArg, regArgs+3,",
          "405:                                pFunc->nArg, pFunc, 0);",
          "",
          "---------------"
        ],
        "src/expr.c||src/expr.c": [
          "File: src/expr.c -> src/expr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4032:       }else",
          "4033: #endif",
          "4034:       {",
          "4038:       }",
          "4039:       if( nFarg && constMask==0 ){",
          "4040:         sqlite3ReleaseTempRange(pParse, r1, nFarg);",
          "",
          "[Removed Lines]",
          "4035:         sqlite3VdbeAddOp4(v, pParse->iSelfTab ? OP_PureFunc0 : OP_Function0,",
          "4036:                           constMask, r1, target, (char*)pDef, P4_FUNCDEF);",
          "4037:         sqlite3VdbeChangeP5(v, (u8)nFarg);",
          "",
          "[Added Lines]",
          "4035:         sqlite3VdbeAddFunctionCall(pParse, constMask, r1, target, nFarg,",
          "4036:                                    pDef, pParse->iSelfTab);",
          "",
          "---------------"
        ],
        "src/vdbe.c||src/vdbe.c": [
          "File: src/vdbe.c -> src/vdbe.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "7513:   int i;",
          "",
          "[Removed Lines]",
          "7488:   int n;",
          "7489:   sqlite3_context *pCtx;",
          "7491:   assert( pOp->p4type==P4_FUNCDEF );",
          "7492:   n = pOp->p5;",
          "7493:   assert( pOp->p3>0 && pOp->p3<=(p->nMem+1 - p->nCursor) );",
          "7494:   assert( n==0 || (pOp->p2>0 && pOp->p2+n<=(p->nMem+1 - p->nCursor)+1) );",
          "7495:   assert( pOp->p3<pOp->p2 || pOp->p3>=pOp->p2+n );",
          "7496:   pCtx = sqlite3DbMallocRawNN(db, sizeof(*pCtx) + (n-1)*sizeof(sqlite3_value*));",
          "7497:   if( pCtx==0 ) goto no_mem;",
          "7498:   pCtx->pOut = 0;",
          "7499:   pCtx->pFunc = pOp->p4.pFunc;",
          "7500:   pCtx->iOp = (int)(pOp - aOp);",
          "7501:   pCtx->pVdbe = p;",
          "7502:   pCtx->isError = 0;",
          "7503:   pCtx->argc = n;",
          "7504:   pOp->p4type = P4_FUNCCTX;",
          "7505:   pOp->p4.pCtx = pCtx;",
          "7506:   assert( OP_PureFunc == OP_PureFunc0+2 );",
          "7507:   assert( OP_Function == OP_Function0+2 );",
          "7508:   pOp->opcode += 2;",
          "7510: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "7523:   pOut = &aMem[pOp->p3];",
          "7524:   if( pCtx->pOut != pOut ){",
          "7525:     pCtx->pOut = pOut;",
          "7526:     for(i=pCtx->argc-1; i>=0; i--) pCtx->argv[i] = &aMem[pOp->p2+i];",
          "7527:   }",
          "7529:   memAboutToChange(p, pOut);",
          "7530: #ifdef SQLITE_DEBUG",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "7505:     pCtx->pVdbe = p;",
          "7509:   assert( pCtx->pVdbe==p );",
          "",
          "---------------"
        ],
        "src/vdbe.h||src/vdbe.h": [
          "File: src/vdbe.h -> src/vdbe.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "190: int sqlite3VdbeAddOp4(Vdbe*,int,int,int,int,const char *zP4,int);",
          "191: int sqlite3VdbeAddOp4Dup8(Vdbe*,int,int,int,int,const u8*,int);",
          "192: int sqlite3VdbeAddOp4Int(Vdbe*,int,int,int,int,int);",
          "193: void sqlite3VdbeEndCoroutine(Vdbe*,int);",
          "194: #if defined(SQLITE_DEBUG) && !defined(SQLITE_TEST_REALLOC_STRESS)",
          "195:   void sqlite3VdbeVerifyNoMallocRequired(Vdbe *p, int N);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "193: int sqlite3VdbeAddFunctionCall(Parse*,int,int,int,int,const FuncDef*,int);",
          "",
          "---------------"
        ],
        "src/vdbeaux.c||src/vdbeaux.c": [
          "File: src/vdbeaux.c -> src/vdbeaux.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "15: #include \"sqliteInt.h\"",
          "16: #include \"vdbeInt.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "19: static void freeEphemeralFunction(sqlite3 *db, FuncDef *pDef);",
          "20: static void vdbeFreeOpArray(sqlite3 *, Op *, int);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "328:   return addr;",
          "329: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "345: int sqlite3VdbeAddFunctionCall(",
          "353: ){",
          "354:   Vdbe *v = pParse->pVdbe;",
          "355:   int nByte;",
          "356:   int addr;",
          "357:   sqlite3_context *pCtx;",
          "358:   assert( v );",
          "359:   nByte = sizeof(*pCtx) + (nArg-1)*sizeof(sqlite3_value*);",
          "360:   pCtx = sqlite3DbMallocRawNN(pParse->db, nByte);",
          "361:   if( pCtx==0 ){",
          "362:     assert( pParse->db->mallocFailed );",
          "363:     freeEphemeralFunction(pParse->db, (FuncDef*)pFunc);",
          "364:     return 0;",
          "365:   }",
          "366:   pCtx->pOut = 0;",
          "367:   pCtx->pFunc = (FuncDef*)pFunc;",
          "368:   pCtx->pVdbe = v;",
          "369:   pCtx->isError = 0;",
          "370:   pCtx->argc = nArg;",
          "371:   addr = sqlite3VdbeAddOp4(v, eCallCtx ? OP_PureFunc : OP_Function,",
          "372:                            p1, p2, p3, (char*)pCtx, P4_FUNCCTX);",
          "373:   pCtx->iOp = addr;",
          "374:   return addr;",
          "375: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1020:   }",
          "1021: }",
          "",
          "[Removed Lines]",
          "1023: static void vdbeFreeOpArray(sqlite3 *, Op *, int);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1031: }",
          "1032: static SQLITE_NOINLINE void freeP4FuncCtx(sqlite3 *db, sqlite3_context *p){",
          "1033:   freeEphemeralFunction(db, p->pFunc);",
          "1035: }",
          "1036: static void freeP4(sqlite3 *db, int p4type, void *p4){",
          "1037:   assert( db );",
          "",
          "[Removed Lines]",
          "1034:  sqlite3DbFreeNN(db, p);",
          "",
          "[Added Lines]",
          "1078:   sqlite3DbFreeNN(db, p);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1537:       sqlite3_str_appendf(&x, \"%s(%d)\", pDef->zName, pDef->nArg);",
          "1538:       break;",
          "1539:     }",
          "1541:     case P4_FUNCCTX: {",
          "1542:       FuncDef *pDef = pOp->p4.pCtx->pFunc;",
          "1543:       sqlite3_str_appendf(&x, \"%s(%d)\", pDef->zName, pDef->nArg);",
          "1544:       break;",
          "1545:     }",
          "1547:     case P4_INT64: {",
          "1548:       sqlite3_str_appendf(&x, \"%lld\", *pOp->p4.pI64);",
          "1549:       break;",
          "",
          "[Removed Lines]",
          "1540: #if defined(SQLITE_DEBUG) || defined(VDBE_PROFILE)",
          "1546: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "4961:   if( pCtx->pVdbe==0 ) return 1;",
          "4962: #endif",
          "4963:   if( pCtx->pVdbe->aOp[pCtx->iOp].opcode==OP_PureFunc ){",
          "4964:     sqlite3_result_error(pCtx,",
          "4965:        \"non-deterministic function in index expression or CHECK constraint\",",
          "4966:        -1);",
          "4967:     return 0;",
          "4968:   }",
          "4969:   return 1;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5006: #if 0",
          "5007:     char *zMsg = sqlite3_mprintf(",
          "5008:        \"non-deterministic use of %s() in an index, CHECK constraint, \"",
          "5009:        \"or generated column\", pCtx->pFunc->zName);",
          "5010:     sqlite3_result_error(pCtx, zMsg, -1);",
          "5011:     sqlite3_free(zMsg);",
          "5012: #else",
          "5016: #endif",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "a7c3b93fa634109dafd4170373d838faf6008d8a",
      "candidate_info": {
        "commit_hash": "a7c3b93fa634109dafd4170373d838faf6008d8a",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/a7c3b93fa634109dafd4170373d838faf6008d8a",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/insert.c",
          "src/update.c"
        ],
        "message": "On an INSERT or UPDATE, generate the new table record prior to running foreign key checks, in case the foreign key checks changes datatypes on the registers holding column values.  Proposed fix for ticket [e63cbcfd3378afe6980d626].\n\nFossilOrigin-Name: 3f1c8051648a341db4dffad66d3b1f9980d8a2b314cb0ce879cb2a10d1779b84",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/insert.c||src/insert.c",
          "src/update.c||src/update.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 8b6691f619ed9a56f6aecbd878ebb447c40984f8767508b248494fd9ec68fbaa",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/insert.c||src/insert.c": [
          "File: src/insert.c -> src/insert.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "814:     int nIdx;",
          "815:     nIdx = sqlite3OpenTableAndIndices(pParse, pTab, OP_OpenWrite, 0, -1, 0,",
          "816:                                       &iDataCur, &iIdxCur);",
          "818:     if( aRegIdx==0 ){",
          "819:       goto insert_cleanup;",
          "820:     }",
          "",
          "[Removed Lines]",
          "817:     aRegIdx = sqlite3DbMallocRawNN(db, sizeof(int)*(nIdx+1));",
          "",
          "[Added Lines]",
          "817:     aRegIdx = sqlite3DbMallocRawNN(db, sizeof(int)*(nIdx+2));",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1845:     sqlite3VdbeJumpHere(v, ipkBottom);",
          "1846:   }",
          "1849:   VdbeModuleComment((v, \"END: GenCnstCks(%d)\", seenReplace));",
          "1850: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1858:   if( HasRowid(pTab) ){",
          "1859:     int regRec = aRegIdx[ix];",
          "1860:     sqlite3VdbeAddOp3(v, OP_MakeRecord, regNewData+1, pTab->nCol, regRec);",
          "1861:     sqlite3SetMakeRecordP5(v, pTab);",
          "1862:     if( !bAffinityDone ){",
          "1863:       sqlite3TableAffinity(v, pTab, 0);",
          "1864:     }",
          "1865:   }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1910:   for(i=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, i++){",
          "1911:     if( aRegIdx[i]==0 ) continue;",
          "1913:     if( pIdx->pPartIdxWhere ){",
          "1914:       sqlite3VdbeAddOp2(v, OP_IsNull, aRegIdx[i], sqlite3VdbeCurrentAddr(v)+2);",
          "1915:       VdbeCoverage(v);",
          "",
          "[Removed Lines]",
          "1912:     bAffinityDone = 1;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1937:     sqlite3VdbeChangeP5(v, pik_flags);",
          "1938:   }",
          "1939:   if( !HasRowid(pTab) ) return;",
          "1947:   if( pParse->nested ){",
          "1948:     pik_flags = 0;",
          "1949:   }else{",
          "",
          "[Removed Lines]",
          "1940:   regData = regNewData + 1;",
          "1941:   regRec = sqlite3GetTempReg(pParse);",
          "1942:   sqlite3VdbeAddOp3(v, OP_MakeRecord, regData, pTab->nCol, regRec);",
          "1943:   sqlite3SetMakeRecordP5(v, pTab);",
          "1944:   if( !bAffinityDone ){",
          "1945:     sqlite3TableAffinity(v, pTab, 0);",
          "1946:   }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1956:   if( useSeekResult ){",
          "1957:     pik_flags |= OPFLAG_USESEEKRESULT;",
          "1958:   }",
          "1960:   if( !pParse->nested ){",
          "1961:     sqlite3VdbeAppendP4(v, pTab, P4_TABLE);",
          "1962:   }",
          "",
          "[Removed Lines]",
          "1959:   sqlite3VdbeAddOp3(v, OP_Insert, iDataCur, regRec, regNewData);",
          "",
          "[Added Lines]",
          "1967:   sqlite3VdbeAddOp3(v, OP_Insert, iDataCur, aRegIdx[i], regNewData);",
          "",
          "---------------"
        ],
        "src/update.c||src/update.c": [
          "File: src/update.c -> src/update.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "277:   if( aXRef==0 ) goto update_cleanup;",
          "278:   aRegIdx = aXRef+pTab->nCol;",
          "280:   memset(aToOpen, 1, nIdx+1);",
          "281:   aToOpen[nIdx+1] = 0;",
          "282:   for(i=0; i<pTab->nCol; i++) aXRef[i] = -1;",
          "",
          "[Removed Lines]",
          "276:   aXRef = sqlite3DbMallocRawNN(db, sizeof(int) * (pTab->nCol+nIdx) + nIdx+2 );",
          "279:   aToOpen = (u8*)(aRegIdx+nIdx);",
          "",
          "[Added Lines]",
          "276:   aXRef = sqlite3DbMallocRawNN(db, sizeof(int) * (pTab->nCol+nIdx+1) + nIdx+2 );",
          "279:   aToOpen = (u8*)(aRegIdx+nIdx+1);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "1cf197583de15d352dc169437f619d2e4631cf4b",
      "candidate_info": {
        "commit_hash": "1cf197583de15d352dc169437f619d2e4631cf4b",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/1cf197583de15d352dc169437f619d2e4631cf4b",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/malloc.c",
          "src/sqliteInt.h",
          "src/tokenize.c"
        ],
        "message": "Give the sqlite3 object a pointer to the current Parse so that if an OOM occurs, it can automatically set the Parse.rc value to SQLITE_NOMEM.  This avoids a frequent extra test of db.mallocFailed in the innermost parser loop.\n\nFossilOrigin-Name: 5c6638040b3017c6be016441422d965a3ca00dd6ae1f78cadc0b54562978f64e",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/malloc.c||src/malloc.c",
          "src/sqliteInt.h||src/sqliteInt.h",
          "src/tokenize.c||src/tokenize.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 440a7cda000164d3b46109caf2e1dde80681ba9b0d94ba9be6847d2b917445cf",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/malloc.c||src/malloc.c": [
          "File: src/malloc.c -> src/malloc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "661:       db->u1.isInterrupted = 1;",
          "662:     }",
          "663:     db->lookaside.bDisable++;",
          "664:   }",
          "665: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "664:     if( db->pParse ){",
          "665:       db->pParse->rc = SQLITE_NOMEM_BKPT;",
          "666:     }",
          "",
          "---------------"
        ],
        "src/sqliteInt.h||src/sqliteInt.h": [
          "File: src/sqliteInt.h -> src/sqliteInt.h"
        ],
        "src/tokenize.c||src/tokenize.c": [
          "File: src/tokenize.c -> src/tokenize.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "563: #ifdef sqlite3Parser_ENGINEALWAYSONSTACK",
          "565: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "563:   VVA_ONLY( u8 startedWithOom = db->mallocFailed );",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "594:   assert( pParse->pNewTrigger==0 );",
          "595:   assert( pParse->nVar==0 );",
          "596:   assert( pParse->pVList==0 );",
          "597:   while( 1 ){",
          "598:     n = sqlite3GetToken((u8*)zSql, &tokenType);",
          "599:     mxSqlLen -= n;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "598:   pParse->pParentParse = db->pParse;",
          "599:   db->pParse = pParse;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "650:     sqlite3Parser(pEngine, tokenType, pParse->sLastToken);",
          "651:     lastTokenParsed = tokenType;",
          "652:     zSql += n;",
          "654:   }",
          "655:   assert( nErr==0 );",
          "656: #ifdef YYTRACKMAXSTACKDEPTH",
          "",
          "[Removed Lines]",
          "653:     if( pParse->rc!=SQLITE_OK || db->mallocFailed ) break;",
          "",
          "[Added Lines]",
          "656:     assert( db->mallocFailed==0 || pParse->rc!=SQLITE_OK || startedWithOom );",
          "657:     if( pParse->rc!=SQLITE_OK ) break;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "718:     pParse->pZombieTab = p->pNextZombie;",
          "719:     sqlite3DeleteTable(db, p);",
          "720:   }",
          "721:   assert( nErr==0 || pParse->rc!=SQLITE_OK );",
          "722:   return nErr;",
          "723: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "725:   db->pParse = pParse->pParentParse;",
          "726:   pParse->pParentParse = 0;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "9c3bb59f76bd1cc196e6a5609017555b228eb64c",
      "candidate_info": {
        "commit_hash": "9c3bb59f76bd1cc196e6a5609017555b228eb64c",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/9c3bb59f76bd1cc196e6a5609017555b228eb64c",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/vdbe.c"
        ],
        "message": "Fix the build for when -DSQLITE_SMALL_STACK is used.\n\nFossilOrigin-Name: b9eda2249ab5cf523093e4849c317d9a4b1743f7e15d96bdd6bb6cc423302914",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/vdbe.c||src/vdbe.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 89bf0399e87be76e7b264e0a35e8a6d3af0f9e71123a929c20754882b636ca70",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/vdbe.c||src/vdbe.c": [
          "File: src/vdbe.c -> src/vdbe.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2984:     }else if( pRec->flags & (MEM_Int|MEM_IntReal) ){",
          "2986:       i64 i = pRec->u.i;",
          "2988:       testcase( pRec->flags & MEM_Int );",
          "2989:       testcase( pRec->flags & MEM_IntReal );",
          "2990:       if( i<0 ){",
          "2992:       }else{",
          "2994:       }",
          "2995:       nHdr++;",
          "3002:         if( (i&1)==i && file_format>=4 ){",
          "3004:         }else{",
          "3005:           nData++;",
          "3006:           pRec->uTemp = 1;",
          "3007:         }",
          "3009:         nData += 2;",
          "3010:         pRec->uTemp = 2;",
          "3012:         nData += 3;",
          "3013:         pRec->uTemp = 3;",
          "3015:         nData += 4;",
          "3016:         pRec->uTemp = 4;",
          "3018:         nData += 6;",
          "3019:         pRec->uTemp = 5;",
          "3020:       }else{",
          "",
          "[Removed Lines]",
          "2987:       u64 u;",
          "2991:         u = ~i;",
          "2993:         u = i;",
          "2996:       testcase( u==127 );               testcase( u==128 );",
          "2997:       testcase( u==32767 );             testcase( u==32768 );",
          "2998:       testcase( u==8388607 );           testcase( u==8388608 );",
          "2999:       testcase( u==2147483647 );        testcase( u==2147483648 );",
          "3000:       testcase( u==140737488355327LL ); testcase( u==140737488355328LL );",
          "3001:       if( u<=127 ){",
          "3003:           pRec->uTemp = 8+(u32)u;",
          "3008:       }else if( u<=32767 ){",
          "3011:       }else if( u<=8388607 ){",
          "3014:       }else if( u<=2147483647 ){",
          "3017:       }else if( u<=140737488355327LL ){",
          "",
          "[Added Lines]",
          "2987:       u64 uu;",
          "2991:         uu = ~i;",
          "2993:         uu = i;",
          "2996:       testcase( uu==127 );               testcase( uu==128 );",
          "2997:       testcase( uu==32767 );             testcase( uu==32768 );",
          "2998:       testcase( uu==8388607 );           testcase( uu==8388608 );",
          "2999:       testcase( uu==2147483647 );        testcase( uu==2147483648 );",
          "3000:       testcase( uu==140737488355327LL ); testcase( uu==140737488355328LL );",
          "3001:       if( uu<=127 ){",
          "3003:           pRec->uTemp = 8+(u32)uu;",
          "3008:       }else if( uu<=32767 ){",
          "3011:       }else if( uu<=8388607 ){",
          "3014:       }else if( uu<=2147483647 ){",
          "3017:       }else if( uu<=140737488355327LL ){",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b0ea9432a12c01597951967a18e530df1b4bffd1",
      "candidate_info": {
        "commit_hash": "b0ea9432a12c01597951967a18e530df1b4bffd1",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/b0ea9432a12c01597951967a18e530df1b4bffd1",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/btree.c",
          "src/btreeInt.h"
        ],
        "message": "Defer computing the MemPage.nFree value of an in-memory btree page until it is actually needed, since for many pages it is never needed. This checkin works sufficiently to prove the concept, but still has issues with exception handling.\n\nFossilOrigin-Name: 1d43ee4000b71f5c6d49244dee96358c567f09ba3451b9d22895a796d3f61ad6",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/btree.c||src/btree.c",
          "src/btreeInt.h||src/btreeInt.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: db74a56af73d92b7a9d43ceda7e4540915c580c68a0266b4ddefb9e0d5cbcbeb",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/btree.c||src/btree.c": [
          "File: src/btree.c -> src/btree.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1506:   data[hdr+7] = 0;",
          "1508:  defragment_out:",
          "1509:   if( data[hdr+7]+cbrk-iCellFirst!=pPage->nFree ){",
          "1510:     return SQLITE_CORRUPT_PAGE(pPage);",
          "1511:   }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1509:   assert( pPage->nFree>=0 );",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1657:   testcase( gap+2+nByte==top );",
          "1658:   if( gap+2+nByte>top ){",
          "1659:     assert( pPage->nCell>0 || CORRUPT_DB );",
          "1660:     rc = defragmentPage(pPage, MIN(4, pPage->nFree - (2+nByte)));",
          "1661:     if( rc ) return rc;",
          "1662:     top = get2byteNotZero(&data[hdr+5]);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1661:     assert( pPage->nFree>=0 );",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1845:   return SQLITE_OK;",
          "1846: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1854: static int btreeComputeFreeSpace(MemPage *pPage){",
          "1864:   assert( pPage->pBt!=0 );",
          "1865:   assert( pPage->pBt->db!=0 );",
          "1866:   assert( sqlite3_mutex_held(pPage->pBt->mutex) );",
          "1867:   assert( pPage->pgno==sqlite3PagerPagenumber(pPage->pDbPage) );",
          "1868:   assert( pPage == sqlite3PagerGetExtra(pPage->pDbPage) );",
          "1869:   assert( pPage->aData == sqlite3PagerGetData(pPage->pDbPage) );",
          "1870:   assert( pPage->isInit==1 );",
          "1871:   assert( pPage->nFree<0 );",
          "1873:   usableSize = pPage->pBt->usableSize;",
          "1874:   hdr = pPage->hdrOffset;",
          "1875:   data = pPage->aData;",
          "1879:   top = get2byteNotZero(&data[hdr+5]);",
          "1880:   iCellFirst = hdr + 8 + pPage->childPtrSize + 2*pPage->nCell;",
          "1881:   iCellLast = usableSize - 4;",
          "1887:   pc = get2byte(&data[hdr+1]);",
          "1889:   if( pc>0 ){",
          "1890:     u32 next, size;",
          "1891:     if( pc<iCellFirst ){",
          "1895:       return SQLITE_CORRUPT_PAGE(pPage);",
          "1896:     }",
          "1897:     while( 1 ){",
          "1898:       if( pc>iCellLast ){",
          "1900:         return SQLITE_CORRUPT_PAGE(pPage);",
          "1901:       }",
          "1902:       next = get2byte(&data[pc]);",
          "1903:       size = get2byte(&data[pc+2]);",
          "1904:       nFree = nFree + size;",
          "1905:       if( next<=pc+size+3 ) break;",
          "1906:       pc = next;",
          "1907:     }",
          "1908:     if( next>0 ){",
          "1910:       return SQLITE_CORRUPT_PAGE(pPage);",
          "1911:     }",
          "1912:     if( pc+size>(unsigned int)usableSize ){",
          "1914:       return SQLITE_CORRUPT_PAGE(pPage);",
          "1915:     }",
          "1916:   }",
          "1925:   if( nFree>usableSize ){",
          "1926:     return SQLITE_CORRUPT_PAGE(pPage);",
          "1927:   }",
          "1928:   pPage->nFree = (u16)(nFree - iCellFirst);",
          "1929:   return SQLITE_OK;",
          "1930: }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1890:   pPage->aDataEnd = &data[usableSize];",
          "1891:   pPage->aCellIdx = &data[cellOffset];",
          "1892:   pPage->aDataOfst = &data[pPage->childPtrSize];",
          "1899:   pPage->nCell = get2byte(&data[hdr+3]);",
          "",
          "[Removed Lines]",
          "1896:   top = get2byteNotZero(&data[hdr+5]);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1909:   assert( pPage->nCell>0 || top==usableSize || CORRUPT_DB );",
          "",
          "[Added Lines]",
          "1987:   assert( pPage->nCell>0",
          "1988:        || get2byteNotZero(&data[hdr+5])==usableSize",
          "1989:        || CORRUPT_DB );",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1937:     }",
          "1938:     if( !pPage->leaf ) iCellLast++;",
          "1939:   }",
          "1987:   pPage->isInit = 1;",
          "1988:   return SQLITE_OK;",
          "1989: }",
          "",
          "[Removed Lines]",
          "1945:   pc = get2byte(&data[hdr+1]);",
          "1947:   if( pc>0 ){",
          "1948:     u32 next, size;",
          "1949:     if( pc<iCellFirst ){",
          "1953:       return SQLITE_CORRUPT_PAGE(pPage);",
          "1954:     }",
          "1955:     while( 1 ){",
          "1956:       if( pc>iCellLast ){",
          "1958:         return SQLITE_CORRUPT_PAGE(pPage);",
          "1959:       }",
          "1960:       next = get2byte(&data[pc]);",
          "1961:       size = get2byte(&data[pc+2]);",
          "1962:       nFree = nFree + size;",
          "1963:       if( next<=pc+size+3 ) break;",
          "1964:       pc = next;",
          "1965:     }",
          "1966:     if( next>0 ){",
          "1968:       return SQLITE_CORRUPT_PAGE(pPage);",
          "1969:     }",
          "1970:     if( pc+size>(unsigned int)usableSize ){",
          "1972:       return SQLITE_CORRUPT_PAGE(pPage);",
          "1973:     }",
          "1974:   }",
          "1983:   if( nFree>usableSize ){",
          "1984:     return SQLITE_CORRUPT_PAGE(pPage);",
          "1985:   }",
          "1986:   pPage->nFree = (u16)(nFree - iCellFirst);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "2128:   if( pgno>btreePagecount(pBt) ){",
          "2129:     rc = SQLITE_CORRUPT_BKPT;",
          "2131:   }",
          "2132:   rc = sqlite3PagerGet(pBt->pPager, pgno, (DbPage**)&pDbPage, bReadOnly);",
          "2133:   if( rc ){",
          "2135:   }",
          "2137:   if( (*ppPage)->isInit==0 ){",
          "2138:     btreePageFromDbPage(pDbPage, pgno, pBt);",
          "2139:     rc = btreeInitPage(*ppPage);",
          "2140:     if( rc!=SQLITE_OK ){",
          "2143:     }",
          "2144:   }",
          "2145:   assert( (*ppPage)->pgno==pgno );",
          "",
          "[Removed Lines]",
          "2130:     goto getAndInitPage_error;",
          "2134:     goto getAndInitPage_error;",
          "2141:       releasePage(*ppPage);",
          "2142:       goto getAndInitPage_error;",
          "",
          "[Added Lines]",
          "2164:     goto getAndInitPage_error1;",
          "2168:     goto getAndInitPage_error1;",
          "2175:       goto getAndInitPage_error2;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "2150:   if( pCur && ((*ppPage)->nCell<1 || (*ppPage)->intKey!=pCur->curIntKey) ){",
          "2151:     rc = SQLITE_CORRUPT_PGNO(pgno);",
          "2154:   }",
          "2155:   return SQLITE_OK;",
          "2158:   if( pCur ){",
          "2159:     pCur->iPage--;",
          "2160:     pCur->pPage = pCur->apPage[pCur->iPage];",
          "",
          "[Removed Lines]",
          "2152:     releasePage(*ppPage);",
          "2153:     goto getAndInitPage_error;",
          "2157: getAndInitPage_error:",
          "",
          "[Added Lines]",
          "2185:     goto getAndInitPage_error2;",
          "2189: getAndInitPage_error2:",
          "2190:   releasePage(*ppPage);",
          "2191: getAndInitPage_error1:",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "6566:   assert( CORRUPT_DB || sz==cellSize(pPage, idx) );",
          "6567:   assert( sqlite3PagerIswriteable(pPage->pDbPage) );",
          "6568:   assert( sqlite3_mutex_held(pPage->pBt->mutex) );",
          "6569:   data = pPage->aData;",
          "6570:   ptr = &pPage->aCellIdx[2*idx];",
          "6571:   pc = get2byte(ptr);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6603:   assert( pPage->nFree>=0 );",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "6638:   assert( sz==pPage->xCellSize(pPage, pCell) || (sz==8 && iChild>0) );",
          "6639:   if( pPage->nOverflow || sz+2>pPage->nFree ){",
          "6640:     if( pTemp ){",
          "6641:       memcpy(pTemp, pCell, sz);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6674:   assert( pPage->nFree>=0 );",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "7187:   assert( sqlite3_mutex_held(pPage->pBt->mutex) );",
          "7188:   assert( sqlite3PagerIswriteable(pParent->pDbPage) );",
          "7189:   assert( pPage->nOverflow==1 );",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "7228:   if( pPage->nFree<0 ){",
          "7229:     rc = btreeComputeFreeSpace(pPage);",
          "7230:     if( rc ) return rc;",
          "7231:   }",
          "7232:   if( pParent->nFree<0 ){",
          "7233:     rc = btreeComputeFreeSpace(pParent);",
          "7234:     if( rc ) return rc;",
          "7235:   }",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "7466:   if( !aOvflSpace ){",
          "7467:     return SQLITE_NOMEM_BKPT;",
          "7468:   }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "7514:   if( pParent->nFree<0 ){",
          "7515:     rc = btreeComputeFreeSpace(pParent);",
          "7516:     if( rc ) return rc;",
          "7517:   }",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "7501:   pgno = get4byte(pRight);",
          "7502:   while( 1 ){",
          "7503:     rc = getAndInitPage(pBt, pgno, &apOld[i], 0, 0);",
          "7504:     if( rc ){",
          "7505:       memset(apOld, 0, (i+1)*sizeof(MemPage*));",
          "7506:       goto balance_cleanup;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "7553:     if( rc==0 && apOld[i]->nFree<0 ){",
          "7554:       rc = btreeComputeFreeSpace(apOld[i]);",
          "7555:     }",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "7704:       b.apEnd[k] = pParent->aDataEnd;",
          "7705:       b.ixNx[k] = cntOld[i]+1;",
          "7706:     }",
          "7707:     szNew[i] = usableSpace - p->nFree;",
          "7708:     for(j=0; j<p->nOverflow; j++){",
          "7709:       szNew[i] += 2 + p->xCellSize(p, p->apOvfl[j]);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "7759:     assert( p->nFree>=0 );",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "8247:     int iPage = pCur->iPage;",
          "8248:     MemPage *pPage = pCur->pPage;",
          "8250:     if( iPage==0 ){",
          "8251:       if( pPage->nOverflow ){",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "8303:     if( pPage->nFree<0 ){",
          "8304:       rc = btreeComputeFreeSpace(pPage);",
          "8305:       if( rc ) break;",
          "8306:     }",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "8621:   pPage = pCur->pPage;",
          "8622:   assert( pPage->intKey || pX->nKey>=0 );",
          "8623:   assert( pPage->leaf || !pPage->intKey );",
          "8625:   TRACE((\"INSERT: table=%d nkey=%lld ndata=%d page=%d %s\\n\",",
          "8626:           pCur->pgnoRoot, pX->nKey, pX->nData, pPage->pgno,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "8681:   if( pPage->nFree<0 ){",
          "8682:     rc = btreeComputeFreeSpace(pPage);",
          "8683:     if( rc ) return rc;",
          "8684:   }",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "8771:   iCellIdx = pCur->ix;",
          "8772:   pPage = pCur->pPage;",
          "8773:   pCell = findCell(pPage, iCellIdx);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "8835:   if( pPage->nFree<0 && btreeComputeFreeSpace(pPage) ) return SQLITE_CORRUPT;",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "8841:     Pgno n;",
          "8842:     unsigned char *pTmp;",
          "8844:     if( iCellDepth<pCur->iPage-1 ){",
          "8845:       n = pCur->apPage[iCellDepth+1]->pgno;",
          "8846:     }else{",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "8906:     if( pLeaf->nFree<0 ){",
          "8907:       rc = btreeComputeFreeSpace(pLeaf);",
          "8908:       if( rc ) return rc;",
          "8909:     }",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "9732:                    \"btreeInitPage() returns error code %d\", rc);",
          "9733:     goto end_of_check;",
          "9734:   }",
          "9735:   data = pPage->aData;",
          "9736:   hdr = pPage->hdrOffset;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "9801:   if( (rc = btreeComputeFreeSpace(pPage))!=0 ){",
          "9802:     assert( rc==SQLITE_CORRUPT );",
          "9803:     checkAppendMsg(pCheck, \"free space corruption\", rc);",
          "9804:     goto end_of_check;",
          "9805:   }",
          "",
          "---------------"
        ],
        "src/btreeInt.h||src/btreeInt.h": [
          "File: src/btreeInt.h -> src/btreeInt.h"
        ]
      }
    }
  ]
}
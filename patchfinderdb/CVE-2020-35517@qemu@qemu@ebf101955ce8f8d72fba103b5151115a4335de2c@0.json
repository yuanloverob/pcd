{
  "cve_id": "CVE-2020-35517",
  "cve_desc": "A flaw was found in qemu. A host privilege escalation issue was found in the virtio-fs shared file system daemon where a privileged guest user is able to create a device special file in the shared directory and use it to r/w access host devices.",
  "repo": "qemu/qemu",
  "patch_hash": "ebf101955ce8f8d72fba103b5151115a4335de2c",
  "patch_info": {
    "commit_hash": "ebf101955ce8f8d72fba103b5151115a4335de2c",
    "repo": "qemu/qemu",
    "commit_url": "https://github.com/qemu/qemu/commit/ebf101955ce8f8d72fba103b5151115a4335de2c",
    "files": [
      "tools/virtiofsd/passthrough_ll.c"
    ],
    "message": "virtiofsd: avoid /proc/self/fd tempdir\n\nIn order to prevent /proc/self/fd escapes a temporary directory is\ncreated where /proc/self/fd is bind-mounted. This doesn't work on\nread-only file systems.\n\nAvoid the temporary directory by bind-mounting /proc/self/fd over /proc.\nThis does not affect other processes since we remounted / with MS_REC |\nMS_SLAVE. /proc must exist and virtiofsd does not use it so it's safe to\ndo this.\n\nPath traversal can be tested with the following function:\n\n  static void test_proc_fd_escape(struct lo_data *lo)\n  {\n      int fd;\n      int level = 0;\n      ino_t last_ino = 0;\n\n      fd = lo->proc_self_fd;\n      for (;;) {\n          struct stat st;\n\n          if (fstat(fd, &st) != 0) {\n              perror(\"fstat\");\n              return;\n          }\n          if (last_ino && st.st_ino == last_ino) {\n              fprintf(stderr, \"inode number unchanged, stopping\\n\");\n              return;\n          }\n          last_ino = st.st_ino;\n\n          fprintf(stderr, \"Level %d dev %lu ino %lu\\n\", level,\n                  (unsigned long)st.st_dev,\n                  (unsigned long)last_ino);\n          fd = openat(fd, \"..\", O_PATH | O_DIRECTORY | O_NOFOLLOW);\n          level++;\n      }\n  }\n\nBefore and after this patch only Level 0 is displayed. Without\n/proc/self/fd bind-mount protection it is possible to traverse parent\ndirectories.\n\nFixes: 397ae982f4df4 (\"virtiofsd: jail lo->proc_self_fd\")\nCc: Miklos Szeredi <mszeredi@redhat.com>\nCc: Jens Freimann <jfreimann@redhat.com>\nSigned-off-by: Stefan Hajnoczi <stefanha@redhat.com>\nMessage-Id: <20201006095826.59813-1-stefanha@redhat.com>\nReviewed-by: Dr. David Alan Gilbert <dgilbert@redhat.com>\nTested-by: Jens Freimann <jfreimann@redhat.com>\nReviewed-by: Jens Freimann <jfreimann@redhat.com>\nSigned-off-by: Dr. David Alan Gilbert <dgilbert@redhat.com>",
    "before_after_code_files": [
      "tools/virtiofsd/passthrough_ll.c||tools/virtiofsd/passthrough_ll.c"
    ]
  },
  "patch_diff": {
    "tools/virtiofsd/passthrough_ll.c||tools/virtiofsd/passthrough_ll.c": [
      "File: tools/virtiofsd/passthrough_ll.c -> tools/virtiofsd/passthrough_ll.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "2393: static void setup_namespaces(struct lo_data *lo, struct fuse_session *se)",
      "2394: {",
      "2395:     pid_t child;",
      "",
      "[Removed Lines]",
      "2396:     char template[] = \"virtiofsd-XXXXXX\";",
      "2397:     char *tmpdir;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "2458:         exit(1);",
      "2459:     }",
      "2470:         exit(1);",
      "2471:     }",
      "2475:     if (lo->proc_self_fd == -1) {",
      "2477:         exit(1);",
      "2478:     }",
      "2488: }",
      "",
      "[Removed Lines]",
      "2461:     tmpdir = mkdtemp(template);",
      "2462:     if (!tmpdir) {",
      "2463:         fuse_log(FUSE_LOG_ERR, \"tmpdir(%s): %m\\n\", template);",
      "2464:         exit(1);",
      "2465:     }",
      "2467:     if (mount(\"/proc/self/fd\", tmpdir, NULL, MS_BIND, NULL) < 0) {",
      "2468:         fuse_log(FUSE_LOG_ERR, \"mount(/proc/self/fd, %s, MS_BIND): %m\\n\",",
      "2469:                  tmpdir);",
      "2474:     lo->proc_self_fd = open(tmpdir, O_PATH);",
      "2476:         fuse_log(FUSE_LOG_ERR, \"open(%s, O_PATH): %m\\n\", tmpdir);",
      "2480:     if (umount2(tmpdir, MNT_DETACH) < 0) {",
      "2481:         fuse_log(FUSE_LOG_ERR, \"umount2(%s, MNT_DETACH): %m\\n\", tmpdir);",
      "2482:         exit(1);",
      "2483:     }",
      "2485:     if (rmdir(tmpdir) < 0) {",
      "2486:         fuse_log(FUSE_LOG_ERR, \"rmdir(%s): %m\\n\", tmpdir);",
      "2487:     }",
      "",
      "[Added Lines]",
      "2465:     if (mount(\"/proc/self/fd\", \"/proc\", NULL, MS_BIND, NULL) < 0) {",
      "2466:         fuse_log(FUSE_LOG_ERR, \"mount(/proc/self/fd, MS_BIND): %m\\n\");",
      "2471:     lo->proc_self_fd = open(\"/proc\", O_PATH);",
      "2473:         fuse_log(FUSE_LOG_ERR, \"open(/proc, O_PATH): %m\\n\");",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "8e1d4ef231d8327be219f7aea7aa15d181375bbc",
      "candidate_info": {
        "commit_hash": "8e1d4ef231d8327be219f7aea7aa15d181375bbc",
        "repo": "qemu/qemu",
        "commit_url": "https://github.com/qemu/qemu/commit/8e1d4ef231d8327be219f7aea7aa15d181375bbc",
        "files": [
          "tools/virtiofsd/passthrough_ll.c"
        ],
        "message": "virtiofsd: move to a new pid namespace\n\nvirtiofsd needs access to /proc/self/fd.  Let's move to a new pid\nnamespace so that a compromised process cannot see another other\nprocesses running on the system.\n\nOne wrinkle in this approach: unshare(CLONE_NEWPID) affects *child*\nprocesses and not the current process.  Therefore we need to fork the\npid 1 process that will actually run virtiofsd and leave a parent in\nwaitpid(2).  This is not the same thing as daemonization and parent\nprocesses should not notice a difference.\n\nSigned-off-by: Stefan Hajnoczi <stefanha@redhat.com>\nReviewed-by: Daniel P. Berrang\u00e9 <berrange@redhat.com>\nSigned-off-by: Dr. David Alan Gilbert <dgilbert@redhat.com>",
        "before_after_code_files": [
          "tools/virtiofsd/passthrough_ll.c||tools/virtiofsd/passthrough_ll.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "tools/virtiofsd/passthrough_ll.c||tools/virtiofsd/passthrough_ll.c"
          ],
          "candidate": [
            "tools/virtiofsd/passthrough_ll.c||tools/virtiofsd/passthrough_ll.c"
          ]
        }
      },
      "candidate_diff": {
        "tools/virtiofsd/passthrough_ll.c||tools/virtiofsd/passthrough_ll.c": [
          "File: tools/virtiofsd/passthrough_ll.c -> tools/virtiofsd/passthrough_ll.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "51: #include <string.h>",
          "52: #include <sys/file.h>",
          "53: #include <sys/mount.h>",
          "54: #include <sys/syscall.h>",
          "55: #include <sys/xattr.h>",
          "56: #include <unistd.h>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "54: #include <sys/prctl.h>",
          "56: #include <sys/types.h>",
          "57: #include <sys/wait.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1945: }",
          "1953: {",
          "1956:         exit(1);",
          "1957:     }",
          "1958: }",
          "1962: {",
          "1963:     int oldroot;",
          "1964:     int newroot;",
          "1966:     oldroot = open(\"/\", O_DIRECTORY | O_RDONLY | O_CLOEXEC);",
          "1967:     if (oldroot < 0) {",
          "1968:         fuse_log(FUSE_LOG_ERR, \"open(/): %m\\n\");",
          "",
          "[Removed Lines]",
          "1952: static void setup_net_namespace(void)",
          "1954:     if (unshare(CLONE_NEWNET) != 0) {",
          "1955:         fuse_log(FUSE_LOG_ERR, \"unshare(CLONE_NEWNET): %m\\n\");",
          "1961: static void setup_pivot_root(const char *source)",
          "",
          "[Added Lines]",
          "1953: static void setup_namespaces(struct lo_data *lo, struct fuse_session *se)",
          "1955:     pid_t child;",
          "1967:     if (unshare(CLONE_NEWPID | CLONE_NEWNS | CLONE_NEWNET) != 0) {",
          "1968:         fuse_log(FUSE_LOG_ERR, \"unshare(CLONE_NEWPID | CLONE_NEWNS): %m\\n\");",
          "1969:         exit(1);",
          "1970:     }",
          "1972:     child = fork();",
          "1973:     if (child < 0) {",
          "1974:         fuse_log(FUSE_LOG_ERR, \"fork() failed: %m\\n\");",
          "1975:         exit(1);",
          "1976:     }",
          "1977:     if (child > 0) {",
          "1978:         pid_t waited;",
          "1979:         int wstatus;",
          "1982:         do {",
          "1983:             waited = waitpid(child, &wstatus, 0);",
          "1984:         } while (waited < 0 && errno == EINTR && !se->exited);",
          "1987:         if (se->exited) {",
          "1988:             exit(0);",
          "1989:         }",
          "1991:         if (WIFEXITED(wstatus)) {",
          "1992:             exit(WEXITSTATUS(wstatus));",
          "1993:         }",
          "1995:         exit(1);",
          "1996:     }",
          "1999:     prctl(PR_SET_PDEATHSIG, SIGTERM);",
          "2005:     if (mount(NULL, \"/\", NULL, MS_REC | MS_SLAVE, NULL) < 0) {",
          "2006:         fuse_log(FUSE_LOG_ERR, \"mount(/, MS_REC|MS_SLAVE): %m\\n\");",
          "2007:         exit(1);",
          "2008:     }",
          "2011:     if (mount(\"proc\", \"/proc\", \"proc\",",
          "2012:               MS_NODEV | MS_NOEXEC | MS_NOSUID | MS_RELATIME, NULL) < 0) {",
          "2013:         fuse_log(FUSE_LOG_ERR, \"mount(/proc): %m\\n\");",
          "2014:         exit(1);",
          "2015:     }",
          "2018:     lo->proc_self_fd = open(\"/proc/self/fd\", O_PATH);",
          "2019:     if (lo->proc_self_fd == -1) {",
          "2020:         fuse_log(FUSE_LOG_ERR, \"open(/proc/self/fd, O_PATH): %m\\n\");",
          "2029: static void setup_mounts(const char *source)",
          "2034:     if (mount(source, source, NULL, MS_BIND, NULL) < 0) {",
          "2035:         fuse_log(FUSE_LOG_ERR, \"mount(%s, %s, MS_BIND): %m\\n\", source, source);",
          "2036:         exit(1);",
          "2037:     }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2009:     close(oldroot);",
          "2010: }",
          "2050: {",
          "2053: }",
          "2055: int main(int argc, char *argv[])",
          "",
          "[Removed Lines]",
          "2012: static void setup_proc_self_fd(struct lo_data *lo)",
          "2013: {",
          "2014:     lo->proc_self_fd = open(\"/proc/self/fd\", O_PATH);",
          "2015:     if (lo->proc_self_fd == -1) {",
          "2016:         fuse_log(FUSE_LOG_ERR, \"open(/proc/self/fd, O_PATH): %m\\n\");",
          "2017:         exit(1);",
          "2018:     }",
          "2019: }",
          "2025: static void setup_mount_namespace(const char *source)",
          "2026: {",
          "2027:     if (unshare(CLONE_NEWNS) != 0) {",
          "2028:         fuse_log(FUSE_LOG_ERR, \"unshare(CLONE_NEWNS): %m\\n\");",
          "2029:         exit(1);",
          "2030:     }",
          "2032:     if (mount(NULL, \"/\", NULL, MS_REC | MS_SLAVE, NULL) < 0) {",
          "2033:         fuse_log(FUSE_LOG_ERR, \"mount(/, MS_REC|MS_PRIVATE): %m\\n\");",
          "2034:         exit(1);",
          "2035:     }",
          "2037:     if (mount(source, source, NULL, MS_BIND, NULL) < 0) {",
          "2038:         fuse_log(FUSE_LOG_ERR, \"mount(%s, %s, MS_BIND): %m\\n\", source, source);",
          "2039:         exit(1);",
          "2040:     }",
          "2042:     setup_pivot_root(source);",
          "2043: }",
          "2049: static void setup_sandbox(struct lo_data *lo)",
          "2051:     setup_net_namespace();",
          "2052:     setup_mount_namespace(lo->source);",
          "",
          "[Added Lines]",
          "2090: static void setup_sandbox(struct lo_data *lo, struct fuse_session *se)",
          "2092:     setup_namespaces(lo, se);",
          "2093:     setup_mounts(lo->source);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2174:     fuse_daemonize(opts.foreground);",
          "2182:     ret = virtio_loop(se);",
          "",
          "[Removed Lines]",
          "2177:     setup_proc_self_fd(&lo);",
          "2179:     setup_sandbox(&lo);",
          "",
          "[Added Lines]",
          "2217:     setup_sandbox(&lo, se);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "2405f3c0d19eb4d516a88aa4e5c54e5f9c6bbea3",
      "candidate_info": {
        "commit_hash": "2405f3c0d19eb4d516a88aa4e5c54e5f9c6bbea3",
        "repo": "qemu/qemu",
        "commit_url": "https://github.com/qemu/qemu/commit/2405f3c0d19eb4d516a88aa4e5c54e5f9c6bbea3",
        "files": [
          "Makefile",
          "tools/virtiofsd/passthrough_ll.c"
        ],
        "message": "virtiofsd: cap-ng helpers\n\nlibcap-ng reads /proc during capng_get_caps_process, and virtiofsd's\nsandboxing doesn't have /proc mounted; thus we have to do the\ncaps read before we sandbox it and save/restore the state.\n\nSigned-off-by: Dr. David Alan Gilbert <dgilbert@redhat.com>\nReviewed-by: Daniel P. Berrang\u00e9 <berrange@redhat.com>\nSigned-off-by: Dr. David Alan Gilbert <dgilbert@redhat.com>",
        "before_after_code_files": [
          "tools/virtiofsd/passthrough_ll.c||tools/virtiofsd/passthrough_ll.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "tools/virtiofsd/passthrough_ll.c||tools/virtiofsd/passthrough_ll.c"
          ],
          "candidate": [
            "tools/virtiofsd/passthrough_ll.c||tools/virtiofsd/passthrough_ll.c"
          ]
        }
      },
      "candidate_diff": {
        "tools/virtiofsd/passthrough_ll.c||tools/virtiofsd/passthrough_ll.c": [
          "File: tools/virtiofsd/passthrough_ll.c -> tools/virtiofsd/passthrough_ll.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "39: #include \"fuse_virtio.h\"",
          "40: #include \"fuse_lowlevel.h\"",
          "41: #include <assert.h>",
          "42: #include <dirent.h>",
          "43: #include <errno.h>",
          "44: #include <inttypes.h>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "42: #include <cap-ng.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "140: static void unref_inode(struct lo_data *lo, struct lo_inode *inode, uint64_t n);",
          "142: static struct lo_inode *lo_find(struct lo_data *lo, struct stat *st);",
          "144: static int is_dot_or_dotdot(const char *name)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "143: static struct {",
          "144:     pthread_mutex_t mutex;",
          "145:     void *saved;",
          "146: } cap;",
          "148: static __thread bool cap_loaded = 0;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "162:     return (struct lo_data *)fuse_req_userdata(req);",
          "163: }",
          "165: static void lo_map_init(struct lo_map *map)",
          "166: {",
          "167:     map->elems = NULL;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "178: static int load_capng(void)",
          "179: {",
          "180:     if (!cap_loaded) {",
          "181:         pthread_mutex_lock(&cap.mutex);",
          "182:         capng_restore_state(&cap.saved);",
          "187:         cap.saved = capng_save_state();",
          "188:         if (!cap.saved) {",
          "189:             fuse_log(FUSE_LOG_ERR, \"capng_save_state (thread)\\n\");",
          "190:             return -EINVAL;",
          "191:         }",
          "192:         pthread_mutex_unlock(&cap.mutex);",
          "198:         capng_setpid(syscall(SYS_gettid));",
          "199:         cap_loaded = true;",
          "200:     }",
          "201:     return 0;",
          "202: }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2023:     }",
          "2024: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2069: static void setup_capng(void)",
          "2070: {",
          "2072:     if (capng_get_caps_process()) {",
          "2073:         fuse_log(FUSE_LOG_ERR, \"capng_get_caps_process\\n\");",
          "2074:         exit(1);",
          "2075:     }",
          "2076:     pthread_mutex_init(&cap.mutex, NULL);",
          "2077:     pthread_mutex_lock(&cap.mutex);",
          "2078:     cap.saved = capng_save_state();",
          "2079:     if (!cap.saved) {",
          "2080:         fuse_log(FUSE_LOG_ERR, \"capng_save_state\\n\");",
          "2081:         exit(1);",
          "2082:     }",
          "2083:     pthread_mutex_unlock(&cap.mutex);",
          "2084: }",
          "2086: static void cleanup_capng(void)",
          "2087: {",
          "2088:     free(cap.saved);",
          "2089:     cap.saved = NULL;",
          "2090:     pthread_mutex_destroy(&cap.mutex);",
          "2091: }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2217:     fuse_daemonize(opts.foreground);",
          "2219:     setup_sandbox(&lo, se);",
          "2222:     ret = virtio_loop(se);",
          "2224:     fuse_session_unmount(se);",
          "2225: err_out3:",
          "2226:     fuse_remove_signal_handlers(se);",
          "2227: err_out2:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2288:     setup_capng();",
          "2296:     cleanup_capng();",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "d74830d12ae233186ff74ddf64c552d26bb39e50",
      "candidate_info": {
        "commit_hash": "d74830d12ae233186ff74ddf64c552d26bb39e50",
        "repo": "qemu/qemu",
        "commit_url": "https://github.com/qemu/qemu/commit/d74830d12ae233186ff74ddf64c552d26bb39e50",
        "files": [
          "tools/virtiofsd/passthrough_ll.c"
        ],
        "message": "virtiofsd: move to an empty network namespace\n\nIf the process is compromised there should be no network access.  Use an\nempty network namespace to sandbox networking.\n\nSigned-off-by: Stefan Hajnoczi <stefanha@redhat.com>\nReviewed-by: Daniel P. Berrang\u00e9 <berrange@redhat.com>\nSigned-off-by: Dr. David Alan Gilbert <dgilbert@redhat.com>",
        "before_after_code_files": [
          "tools/virtiofsd/passthrough_ll.c||tools/virtiofsd/passthrough_ll.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "tools/virtiofsd/passthrough_ll.c||tools/virtiofsd/passthrough_ll.c"
          ],
          "candidate": [
            "tools/virtiofsd/passthrough_ll.c||tools/virtiofsd/passthrough_ll.c"
          ]
        }
      },
      "candidate_diff": {
        "tools/virtiofsd/passthrough_ll.c||tools/virtiofsd/passthrough_ll.c": [
          "File: tools/virtiofsd/passthrough_ll.c -> tools/virtiofsd/passthrough_ll.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1944:     printf(\"}\\n\");",
          "1945: }",
          "1948: static void setup_pivot_root(const char *source)",
          "1949: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1952: static void setup_net_namespace(void)",
          "1953: {",
          "1954:     if (unshare(CLONE_NEWNET) != 0) {",
          "1955:         fuse_log(FUSE_LOG_ERR, \"unshare(CLONE_NEWNET): %m\\n\");",
          "1956:         exit(1);",
          "1957:     }",
          "1958: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2036: static void setup_sandbox(struct lo_data *lo)",
          "2037: {",
          "2038:     setup_mount_namespace(lo->source);",
          "2039: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2051:     setup_net_namespace();",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "397ae982f4df46e7d4b2625c431062c9146f3b83",
      "candidate_info": {
        "commit_hash": "397ae982f4df46e7d4b2625c431062c9146f3b83",
        "repo": "qemu/qemu",
        "commit_url": "https://github.com/qemu/qemu/commit/397ae982f4df46e7d4b2625c431062c9146f3b83",
        "files": [
          "tools/virtiofsd/passthrough_ll.c"
        ],
        "message": "virtiofsd: jail lo->proc_self_fd\n\nWhile it's not possible to escape the proc filesystem through\nlo->proc_self_fd, it is possible to escape to the root of the proc\nfilesystem itself through \"../..\".\n\nUse a temporary mount for opening lo->proc_self_fd, that has it's root at\n/proc/self/fd/, preventing access to the ancestor directories.\n\nSigned-off-by: Miklos Szeredi <mszeredi@redhat.com>\nMessage-Id: <20200429124733.22488-1-mszeredi@redhat.com>\nReviewed-by: Stefan Hajnoczi <stefanha@redhat.com>\nSigned-off-by: Dr. David Alan Gilbert <dgilbert@redhat.com>",
        "before_after_code_files": [
          "tools/virtiofsd/passthrough_ll.c||tools/virtiofsd/passthrough_ll.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "tools/virtiofsd/passthrough_ll.c||tools/virtiofsd/passthrough_ll.c"
          ],
          "candidate": [
            "tools/virtiofsd/passthrough_ll.c||tools/virtiofsd/passthrough_ll.c"
          ]
        }
      },
      "candidate_diff": {
        "tools/virtiofsd/passthrough_ll.c||tools/virtiofsd/passthrough_ll.c": [
          "File: tools/virtiofsd/passthrough_ll.c -> tools/virtiofsd/passthrough_ll.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2536: static void setup_namespaces(struct lo_data *lo, struct fuse_session *se)",
          "2537: {",
          "2538:     pid_t child;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2539:     char template[] = \"virtiofsd-XXXXXX\";",
          "2540:     char *tmpdir;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2597:         exit(1);",
          "2598:     }",
          "2602:     if (lo->proc_self_fd == -1) {",
          "2604:         exit(1);",
          "2605:     }",
          "2606: }",
          "",
          "[Removed Lines]",
          "2601:     lo->proc_self_fd = open(\"/proc/self/fd\", O_PATH);",
          "2603:         fuse_log(FUSE_LOG_ERR, \"open(/proc/self/fd, O_PATH): %m\\n\");",
          "",
          "[Added Lines]",
          "2602:     tmpdir = mkdtemp(template);",
          "2603:     if (!tmpdir) {",
          "2604:         fuse_log(FUSE_LOG_ERR, \"tmpdir(%s): %m\\n\", template);",
          "2605:         exit(1);",
          "2606:     }",
          "2608:     if (mount(\"/proc/self/fd\", tmpdir, NULL, MS_BIND, NULL) < 0) {",
          "2609:         fuse_log(FUSE_LOG_ERR, \"mount(/proc/self/fd, %s, MS_BIND): %m\\n\",",
          "2610:                  tmpdir);",
          "2611:         exit(1);",
          "2612:     }",
          "2615:     lo->proc_self_fd = open(tmpdir, O_PATH);",
          "2617:         fuse_log(FUSE_LOG_ERR, \"open(%s, O_PATH): %m\\n\", tmpdir);",
          "2621:     if (umount2(tmpdir, MNT_DETACH) < 0) {",
          "2622:         fuse_log(FUSE_LOG_ERR, \"umount2(%s, MNT_DETACH): %m\\n\", tmpdir);",
          "2623:         exit(1);",
          "2624:     }",
          "2626:     if (rmdir(tmpdir) < 0) {",
          "2627:         fuse_log(FUSE_LOG_ERR, \"rmdir(%s): %m\\n\", tmpdir);",
          "2628:     }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
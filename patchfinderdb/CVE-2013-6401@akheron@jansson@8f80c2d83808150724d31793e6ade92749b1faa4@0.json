{
  "cve_id": "CVE-2013-6401",
  "cve_desc": "Jansson, possibly 2.4 and earlier, does not restrict the ability to trigger hash collisions predictably, which allows context-dependent attackers to cause a denial of service (CPU consumption) via a crafted JSON document.",
  "repo": "akheron/jansson",
  "patch_hash": "8f80c2d83808150724d31793e6ade92749b1faa4",
  "patch_info": {
    "commit_hash": "8f80c2d83808150724d31793e6ade92749b1faa4",
    "repo": "akheron/jansson",
    "commit_url": "https://github.com/akheron/jansson/commit/8f80c2d83808150724d31793e6ade92749b1faa4",
    "files": [
      "CMakeLists.txt",
      "cmake/config.h.cmake",
      "configure.ac",
      "src/Makefile.am",
      "src/hashtable.c",
      "src/hashtable.h",
      "src/hashtable_seed.c",
      "src/jansson.def",
      "src/jansson.h",
      "src/lookup3.h",
      "src/utf.h",
      "src/value.c",
      "test/bin/json_process.c",
      "test/suites/api/test_memory_funcs.c",
      "test/suites/api/test_object.c",
      "test/suites/encoding-flags/compact-object/env",
      "test/suites/encoding-flags/indent-compact-object/env",
      "test/suites/encoding-flags/indent-object/env",
      "test/suites/encoding-flags/object/env"
    ],
    "message": "CVE-2013-6401: Change hash function, randomize hashes\n\nThanks to Florian Weimer and Eric Sesterhenn for reporting, reviewing\nand testing.",
    "before_after_code_files": [
      "cmake/config.h.cmake||cmake/config.h.cmake",
      "configure.ac||configure.ac",
      "src/Makefile.am||src/Makefile.am",
      "src/hashtable.c||src/hashtable.c",
      "src/hashtable.h||src/hashtable.h",
      "src/hashtable_seed.c||src/hashtable_seed.c",
      "src/jansson.def||src/jansson.def",
      "src/jansson.h||src/jansson.h",
      "src/lookup3.h||src/lookup3.h",
      "src/utf.h||src/utf.h",
      "src/value.c||src/value.c",
      "test/bin/json_process.c||test/bin/json_process.c",
      "test/suites/api/test_memory_funcs.c||test/suites/api/test_memory_funcs.c",
      "test/suites/api/test_object.c||test/suites/api/test_object.c"
    ]
  },
  "patch_diff": {
    "cmake/config.h.cmake||cmake/config.h.cmake": [
      "File: cmake/config.h.cmake -> cmake/config.h.cmake",
      "--- Hunk 1 ---",
      "[Context before]",
      "6: #cmakedefine HAVE_SYS_TYPES_H 1",
      "23: #cmakedefine HAVE_SETLOCALE 1",
      "27: #cmakedefine HAVE_INT32_T 1",
      "29: #ifndef HAVE_INT32_T",
      "30: #  define int32_t @JSON_INT32@",
      "31: #endif",
      "33: #cmakedefine HAVE_SSIZE_T 1",
      "35: #ifndef HAVE_SSIZE_T",
      "",
      "[Removed Lines]",
      "4: #cmakedefine HAVE_INTTYPES_H 1",
      "5: #cmakedefine HAVE_STDINT_H 1",
      "9:    the integer type, which in MSVC2010 will be in stdint.h",
      "11: #if defined(HAVE_STDINT_H)",
      "12: #  include <stdint.h>",
      "13: #elif defined(HAVE_INTTYPES_H)",
      "14: #  include <inttypes.h>",
      "15: #elif defined(HAVE_SYS_TYPES_H)",
      "16: #  include <sys/types.h>",
      "17: #endif",
      "20: #cmakedefine HAVE_LOCALE_H 1",
      "",
      "[Added Lines]",
      "1: #cmakedefine HAVE_ENDIAN_H 1",
      "2: #cmakedefine HAVE_FCNTL_H 1",
      "3: #cmakedefine HAVE_SCHED_H 1",
      "4: #cmakedefine HAVE_UNISTD_H 1",
      "5: #cmakedefine HAVE_SYS_PARAM_H 1",
      "6: #cmakedefine HAVE_SYS_STAT_H 1",
      "7: #cmakedefine HAVE_SYS_TIME_H 1",
      "9: #cmakedefine HAVE_STDINT_H 1",
      "11: #cmakedefine HAVE_CLOSE 1",
      "12: #cmakedefine HAVE_GETPID 1",
      "13: #cmakedefine HAVE_GETTIMEOFDAY 1",
      "14: #cmakedefine HAVE_OPEN 1",
      "15: #cmakedefine HAVE_READ 1",
      "16: #cmakedefine HAVE_SCHED_YIELD 1",
      "18: #cmakedefine HAVE_SYNC_BUILTINS 1",
      "19: #cmakedefine HAVE_ATOMIC_BUILTINS 1",
      "21: #cmakedefine HAVE_LOCALE_H 1",
      "29: #cmakedefine HAVE_UINT32_T 1",
      "30: #ifndef HAVE_UINT32_T",
      "31: #  define uint32_t @JSON_UINT32@",
      "32: #endif",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "43: #endif",
      "45: #cmakedefine HAVE_VSNPRINTF",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "48: #cmakedefine USE_URANDOM 1",
      "49: #cmakedefine USE_WINDOWS_CRYPTOAPI 1",
      "",
      "---------------"
    ],
    "configure.ac||configure.ac": [
      "File: configure.ac -> configure.ac",
      "--- Hunk 1 ---",
      "[Context before]",
      "14: # Checks for libraries.",
      "16: # Checks for header files.",
      "19: # Checks for typedefs, structures, and compiler characteristics.",
      "20: AC_TYPE_INT32_T",
      "21: AC_TYPE_LONG_LONG_INT",
      "23: AC_C_INLINE",
      "",
      "[Removed Lines]",
      "17: AC_CHECK_HEADERS([locale.h])",
      "",
      "[Added Lines]",
      "17: AC_CHECK_HEADERS([endian.h fcntl.h locale.h sched.h unistd.h sys/param.h sys/stat.h sys/time.h sys/types.h])",
      "21: AC_TYPE_UINT32_T",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "29: AC_SUBST([json_inline])",
      "31: # Checks for library functions.",
      "34: case \"$ac_cv_type_long_long_int$ac_cv_func_strtoll\" in",
      "35:      yesyes) json_have_long_long=1;;",
      "",
      "[Removed Lines]",
      "32: AC_CHECK_FUNCS([strtoll localeconv])",
      "",
      "[Added Lines]",
      "33: AC_CHECK_FUNCS([close getpid gettimeofday localeconv open read sched_yield strtoll])",
      "35: AC_MSG_CHECKING([for gcc __sync builtins])",
      "36: have_sync_builtins=no",
      "37: AC_TRY_LINK(",
      "38:   [], [unsigned long val; __sync_bool_compare_and_swap(&val, 0, 1);],",
      "39:   [have_sync_builtins=yes],",
      "40: )",
      "41: if test \"x$have_sync_builtins\" = \"xyes\"; then",
      "42:   AC_DEFINE([HAVE_SYNC_BUILTINS], [1],",
      "43:     [Define to 1 if gcc's __sync builtins are available])",
      "44: fi",
      "45: AC_MSG_RESULT([$have_sync_builtins])",
      "47: AC_MSG_CHECKING([for gcc __atomic builtins])",
      "48: have_atomic_builtins=no",
      "49: AC_TRY_LINK(",
      "50:   [], [char l; unsigned long v; __atomic_test_and_set(&l, __ATOMIC_RELAXED); __atomic_store_n(&v, 1, __ATOMIC_ACQ_REL); __atomic_load_n(&v, __ATOMIC_ACQUIRE);],",
      "51:   [have_atomic_builtins=yes],",
      "52: )",
      "53: if test \"x$have_atomic_builtins\" = \"xyes\"; then",
      "54:   AC_DEFINE([HAVE_ATOMIC_BUILTINS], [1],",
      "55:     [Define to 1 if gcc's __atomic builtins are available])",
      "56: fi",
      "57: AC_MSG_RESULT([$have_atomic_builtins])",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "43: esac",
      "44: AC_SUBST([json_have_localeconv])",
      "46: AC_CONFIG_FILES([",
      "47:         jansson.pc",
      "48:         Makefile",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "71: # Features",
      "72: AC_ARG_ENABLE([urandom],",
      "73:   [AS_HELP_STRING([--disable-urandom],",
      "74:     [Don't use /dev/urandom to seed the hash function])],",
      "75:   [use_urandom=$enableval], [use_urandom=yes])",
      "77: if test \"x$use_urandom\" = xyes; then",
      "78: AC_DEFINE([USE_URANDOM], [1],",
      "79:   [Define to 1 if /dev/urandom should be used for seeding the hash function])",
      "80: fi",
      "82: AC_ARG_ENABLE([windows-cryptoapi],",
      "83:   [AS_HELP_STRING([--disable-windows-cryptoapi],",
      "84:     [Don't use CryptGenRandom to seed the hash function])],",
      "85:   [use_windows_cryptoapi=$enableval], [use_windows_cryptoapi=yes])",
      "87: if test \"x$use_windows_cryptoapi\" = xyes; then",
      "88: AC_DEFINE([USE_WINDOWS_CRYPTOAPI], [1],",
      "89:   [Define to 1 if CryptGenRandom should be used for seeding the hash function])",
      "90: fi",
      "",
      "---------------"
    ],
    "src/Makefile.am||src/Makefile.am": [
      "File: src/Makefile.am -> src/Makefile.am",
      "--- Hunk 1 ---",
      "[Context before]",
      "8:  error.c \\",
      "9:  hashtable.c \\",
      "10:  hashtable.h \\",
      "11:  jansson_private.h \\",
      "12:  load.c \\",
      "13:  memory.c \\",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "11:  hashtable_seed.c \\",
      "",
      "---------------"
    ],
    "src/hashtable.c||src/hashtable.c": [
      "File: src/hashtable.c -> src/hashtable.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "8: #include <stdlib.h>",
      "9: #include <string.h>",
      "12: #include \"hashtable.h\"",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "8: #if HAVE_CONFIG_H",
      "9: #include <config.h>",
      "10: #endif",
      "15: #if HAVE_STDINT_H",
      "16: #include <stdint.h>",
      "17: #endif",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "15: typedef struct hashtable_pair pair_t;",
      "16: typedef struct hashtable_bucket bucket_t;",
      "37: static JSON_INLINE void list_init(list_t *list)",
      "38: {",
      "",
      "[Removed Lines]",
      "18: #define list_to_pair(list_)  container_of(list_, pair_t, list)",
      "21: static size_t hash_str(const void *ptr)",
      "22: {",
      "23:     const char *str = (const char *)ptr;",
      "25:     size_t hash = 5381;",
      "26:     size_t c;",
      "28:     while((c = (size_t)*str))",
      "29:     {",
      "30:         hash = ((hash << 5) + hash) + c;",
      "31:         str++;",
      "32:     }",
      "34:     return hash;",
      "35: }",
      "",
      "[Added Lines]",
      "27: extern volatile uint32_t hashtable_seed;",
      "30: #include \"lookup3.h\"",
      "32: #define list_to_pair(list_)  container_of(list_, pair_t, list)",
      "33: #define hash_str(key)        ((size_t)hashlittle((key), strlen(key), hashtable_seed))",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "74:     }",
      "75: }",
      "90: static pair_t *hashtable_find_pair(hashtable_t *hashtable, bucket_t *bucket,",
      "91:                                    const char *key, size_t hash)",
      "92: {",
      "",
      "[Removed Lines]",
      "77: static const size_t primes[] = {",
      "78:     5, 13, 23, 53, 97, 193, 389, 769, 1543, 3079, 6151, 12289, 24593,",
      "79:     49157, 98317, 196613, 393241, 786433, 1572869, 3145739, 6291469,",
      "80:     12582917, 25165843, 50331653, 100663319, 201326611, 402653189,",
      "81:     805306457, 1610612741",
      "82: };",
      "84: static JSON_INLINE size_t num_buckets(hashtable_t *hashtable)",
      "85: {",
      "86:     return primes[hashtable->num_buckets];",
      "87: }",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "120:     bucket_t *bucket;",
      "121:     size_t index;",
      "124:     bucket = &hashtable->buckets[index];",
      "126:     pair = hashtable_find_pair(hashtable, bucket, key, hash);",
      "",
      "[Removed Lines]",
      "123:     index = hash % num_buckets(hashtable);",
      "",
      "[Added Lines]",
      "108:     index = hash & hashmask(hashtable->order);",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "168:     jsonp_free(hashtable->buckets);",
      "173:     hashtable->buckets = jsonp_malloc(new_size * sizeof(bucket_t));",
      "174:     if(!hashtable->buckets)",
      "175:         return -1;",
      "178:     {",
      "179:         hashtable->buckets[i].first = hashtable->buckets[i].last =",
      "180:             &hashtable->list;",
      "",
      "[Removed Lines]",
      "170:     hashtable->num_buckets++;",
      "171:     new_size = num_buckets(hashtable);",
      "177:     for(i = 0; i < num_buckets(hashtable); i++)",
      "",
      "[Added Lines]",
      "155:     hashtable->order++;",
      "156:     new_size = hashsize(hashtable->order);",
      "162:     for(i = 0; i < hashsize(hashtable->order); i++)",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "199:     size_t i;",
      "201:     hashtable->size = 0;",
      "204:     if(!hashtable->buckets)",
      "205:         return -1;",
      "207:     list_init(&hashtable->list);",
      "210:     {",
      "211:         hashtable->buckets[i].first = hashtable->buckets[i].last =",
      "212:             &hashtable->list;",
      "",
      "[Removed Lines]",
      "203:     hashtable->buckets = jsonp_malloc(num_buckets(hashtable) * sizeof(bucket_t));",
      "209:     for(i = 0; i < num_buckets(hashtable); i++)",
      "",
      "[Added Lines]",
      "187:     hashtable->order = 3;",
      "188:     hashtable->buckets = jsonp_malloc(hashsize(hashtable->order) * sizeof(bucket_t));",
      "194:     for(i = 0; i < hashsize(hashtable->order); i++)",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "230:     size_t hash, index;",
      "234:         if(hashtable_do_rehash(hashtable))",
      "235:             return -1;",
      "237:     hash = hash_str(key);",
      "239:     bucket = &hashtable->buckets[index];",
      "240:     pair = hashtable_find_pair(hashtable, bucket, key, hash);",
      "",
      "[Removed Lines]",
      "233:     if(hashtable->size >= num_buckets(hashtable))",
      "238:     index = hash % num_buckets(hashtable);",
      "",
      "[Added Lines]",
      "218:     if(hashtable->size >= hashsize(hashtable->order))",
      "223:     index = hash & hashmask(hashtable->order);",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "273:     bucket_t *bucket;",
      "275:     hash = hash_str(key);",
      "278:     pair = hashtable_find_pair(hashtable, bucket, key, hash);",
      "279:     if(!pair)",
      "",
      "[Removed Lines]",
      "276:     bucket = &hashtable->buckets[hash % num_buckets(hashtable)];",
      "",
      "[Added Lines]",
      "261:     bucket = &hashtable->buckets[hash & hashmask(hashtable->order)];",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "295:     hashtable_do_clear(hashtable);",
      "298:     {",
      "299:         hashtable->buckets[i].first = hashtable->buckets[i].last =",
      "300:             &hashtable->list;",
      "",
      "[Removed Lines]",
      "297:     for(i = 0; i < num_buckets(hashtable); i++)",
      "",
      "[Added Lines]",
      "282:     for(i = 0; i < hashsize(hashtable->order); i++)",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "316:     bucket_t *bucket;",
      "318:     hash = hash_str(key);",
      "321:     pair = hashtable_find_pair(hashtable, bucket, key, hash);",
      "322:     if(!pair)",
      "",
      "[Removed Lines]",
      "319:     bucket = &hashtable->buckets[hash % num_buckets(hashtable)];",
      "",
      "[Added Lines]",
      "304:     bucket = &hashtable->buckets[hash & hashmask(hashtable->order)];",
      "",
      "---------------"
    ],
    "src/hashtable.h||src/hashtable.h": [
      "File: src/hashtable.h -> src/hashtable.h"
    ],
    "src/hashtable_seed.c||src/hashtable_seed.c": [
      "File: src/hashtable_seed.c -> src/hashtable_seed.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2:    the hash function.",
      "5: #ifdef HAVE_CONFIG_H",
      "6: #include <config.h>",
      "7: #endif",
      "9: #include <stdio.h>",
      "10: #include <time.h>",
      "12: #ifdef HAVE_STDINT_H",
      "13: #include <stdint.h>",
      "14: #endif",
      "16: #ifdef HAVE_FCNTL_H",
      "17: #include <fcntl.h>",
      "18: #endif",
      "20: #ifdef HAVE_SCHED_H",
      "21: #include <sched.h>",
      "22: #endif",
      "24: #ifdef HAVE_UNISTD_H",
      "25: #include <unistd.h>",
      "26: #endif",
      "28: #ifdef HAVE_SYS_STAT_H",
      "29: #include <sys/stat.h>",
      "30: #endif",
      "32: #ifdef HAVE_SYS_TIME_H",
      "33: #include <sys/time.h>",
      "34: #endif",
      "36: #ifdef HAVE_SYS_TYPES_H",
      "37: #include <sys/types.h>",
      "38: #endif",
      "40: #if defined(_WIN32)",
      "42: #include <process.h>",
      "43: #endif",
      "45: #include \"jansson.h\"",
      "48: static uint32_t buf_to_uint32(char *data) {",
      "49:     size_t i;",
      "50:     uint32_t result = 0;",
      "52:     for (i = 0; i < sizeof(uint32_t); i++)",
      "53:         result = (result << 8) | (unsigned char)data[i];",
      "55:     return result;",
      "56: }",
      "61: #if !defined(_WIN32) && defined(USE_URANDOM)",
      "62: static int seed_from_urandom(uint32_t *seed) {",
      "66:     char data[sizeof(uint32_t)];",
      "67:     int ok;",
      "69: #if defined(HAVE_OPEN) && defined(HAVE_CLOSE) && defined(HAVE_READ)",
      "70:     int urandom;",
      "71:     urandom = open(\"/dev/urandom\", O_RDONLY);",
      "72:     if (urandom == -1)",
      "73:         return 1;",
      "75:     ok = read(urandom, data, sizeof(uint32_t)) == sizeof(uint32_t);",
      "76:     close(urandom);",
      "77: #else",
      "78:     FILE *urandom;",
      "80:     urandom = fopen(\"/dev/urandom\", \"rb\");",
      "81:     if (!urandom)",
      "82:         return 1;",
      "84:     ok = fread(data, 1, sizeof(uint32_t), urandom) == sizeof(uint32_t);",
      "85:     fclose(urandom);",
      "86: #endif",
      "88:     if (!ok)",
      "89:         return 1;",
      "92:     return 0;",
      "93: }",
      "94: #endif",
      "97: #if defined(_WIN32) && defined(USE_WINDOWS_CRYPTOAPI)",
      "98: #include <windows.h>",
      "99: #include <wincrypt.h>",
      "101: typedef BOOL (WINAPI *CRYPTACQUIRECONTEXTA)(HCRYPTPROV *phProv, LPCSTR pszContainer, LPCSTR pszProvider, DWORD dwProvType, DWORD dwFlags);",
      "102: typedef BOOL (WINAPI *CRYPTGENRANDOM)(HCRYPTPROV hProv, DWORD dwLen, BYTE *pbBuffer);",
      "103: typedef BOOL (WINAPI *CRYPTRELEASECONTEXT)(HCRYPTPROV hProv, DWORD dwFlags);",
      "105: static int seed_from_windows_cryptoapi(uint32_t *seed)",
      "106: {",
      "107:     HINSTANCE hAdvAPI32 = NULL;",
      "108:     CRYPTACQUIRECONTEXTA pCryptAcquireContext = NULL;",
      "109:     CRYPTGENRANDOM pCryptGenRandom = NULL;",
      "110:     CRYPTRELEASECONTEXT pCryptReleaseContext = NULL;",
      "111:     HCRYPTPROV hCryptProv = 0;",
      "112:     BYTE data[sizeof(uint32_t)];",
      "113:     int ok;",
      "115:     hAdvAPI32 = GetModuleHandle(\"advapi32.dll\");",
      "116:     if(hAdvAPI32 == NULL)",
      "117:         return 1;",
      "119:     pCryptAcquireContext = (CRYPTACQUIRECONTEXTA)GetProcAddress(hAdvAPI32, \"CryptAcquireContextA\");",
      "120:     if (!pCryptAcquireContext)",
      "121:         return 1;",
      "123:     pCryptGenRandom = (CRYPTGENRANDOM)GetProcAddress(hAdvAPI32, \"CryptGenRandom\");",
      "124:     if (!pCryptGenRandom)",
      "125:         return 1;",
      "127:     pCryptReleaseContext = (CRYPTRELEASECONTEXT)GetProcAddress(hAdvAPI32, \"CryptReleaseContext\");",
      "128:     if (!pCryptReleaseContext)",
      "129:         return 1;",
      "131:     if (!pCryptAcquireContext(&hCryptProv, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT))",
      "132:         return 1;",
      "134:     ok = CryptGenRandom(hCryptProv, sizeof(uint32_t), data);",
      "135:     pCryptReleaseContext(hCryptProv, 0);",
      "137:     if (!ok)",
      "138:         return 1;",
      "141:     return 0;",
      "142: }",
      "143: #endif",
      "146: static int seed_from_timestamp_and_pid(uint32_t *seed) {",
      "147: #ifdef HAVE_GETTIMEOFDAY",
      "149:     struct timeval tv;",
      "150:     gettimeofday(&tv, NULL);",
      "152: #else",
      "155: #endif",
      "158: #if defined(_WIN32)",
      "160: #elif defined(HAVE_GETPID)",
      "162: #endif",
      "164:     return 0;",
      "165: }",
      "167: static uint32_t generate_seed() {",
      "168:     uint32_t seed;",
      "169:     int done = 0;",
      "171: #if !defined(_WIN32) && defined(USE_URANDOM)",
      "172:     if (!done && seed_from_urandom(&seed) == 0)",
      "173:         done = 1;",
      "174: #endif",
      "176: #if defined(_WIN32) && defined(USE_WINDOWS_CRYPTOAPI)",
      "177:     if (!done && seed_from_windows_cryptoapi(&seed) == 0)",
      "178:         done = 1;",
      "179: #endif",
      "181:     if (!done) {",
      "184:         seed_from_timestamp_and_pid(&seed);",
      "185:     }",
      "188:     if (seed == 0)",
      "189:         seed = 1;",
      "191:     return seed;",
      "192: }",
      "195: volatile uint32_t hashtable_seed = 0;",
      "197: #if defined(HAVE_ATOMIC_BUILTINS) && (defined(HAVE_SCHED_YIELD) || !defined(_WIN32))",
      "198: static volatile char seed_initialized = 0;",
      "200: void json_object_seed(size_t seed) {",
      "201:     uint32_t new_seed = (uint32_t)seed;",
      "203:     if (hashtable_seed == 0) {",
      "204:         if (__atomic_test_and_set(&seed_initialized, __ATOMIC_RELAXED) == 0) {",
      "206:             if (new_seed == 0)",
      "207:                 new_seed = generate_seed();",
      "209:             __atomic_store_n(&hashtable_seed, new_seed, __ATOMIC_ACQ_REL);",
      "210:         } else {",
      "212:             do {",
      "213: #ifdef HAVE_SCHED_YIELD",
      "214:                 sched_yield();",
      "215: #endif",
      "216:             } while(__atomic_load_n(&hashtable_seed, __ATOMIC_ACQUIRE) == 0);",
      "217:         }",
      "218:     }",
      "219: }",
      "220: #elif defined(HAVE_SYNC_BUILTINS) && (defined(HAVE_SCHED_YIELD) || !defined(_WIN32))",
      "221: void json_object_seed(size_t seed) {",
      "222:     uint32_t new_seed = (uint32_t)seed;",
      "224:     if (hashtable_seed == 0) {",
      "225:         if (new_seed == 0) {",
      "227:                __sync builtins, so every thread getting here has to",
      "228:                generate the seed value.",
      "230:             new_seed = generate_seed();",
      "231:         }",
      "233:         do {",
      "234:             if (__sync_bool_compare_and_swap(&hashtable_seed, 0, new_seed)) {",
      "236:                 break;",
      "237:             } else {",
      "239: #ifdef HAVE_SCHED_YIELD",
      "240:                 sched_yield();",
      "241: #endif",
      "242:             }",
      "243:         } while(hashtable_seed == 0);",
      "244:     }",
      "245: }",
      "246: #elif defined(_WIN32)",
      "247: static long seed_initialized = 0;",
      "248: void json_object_seed(size_t seed) {",
      "249:     uint32_t new_seed = (uint32_t)seed;",
      "251:     if (hashtable_seed == 0) {",
      "252:         if (InterlockedIncrement(&seed_initialized) == 1) {",
      "254:             if (new_seed == 0)",
      "255:                 new_seed = generate_seed();",
      "257:             hashtable_seed = new_seed;",
      "258:         } else {",
      "260:             do {",
      "261:                 SwitchToThread();",
      "262:             } while (hashtable_seed == 0);",
      "263:         }",
      "264:     }",
      "265: }",
      "266: #else",
      "268: void json_object_seed(size_t seed) {",
      "269:     uint32_t new_seed = (uint32_t)seed;",
      "271:     if (hashtable_seed == 0) {",
      "272:         if (new_seed == 0)",
      "273:             new_seed = generate_seed();",
      "275:         hashtable_seed = new_seed;",
      "276:     }",
      "277: }",
      "278: #endif",
      "",
      "---------------"
    ],
    "src/jansson.def||src/jansson.def": [
      "File: src/jansson.def -> src/jansson.def",
      "--- Hunk 1 ---",
      "[Context before]",
      "41:     json_object_iter_value",
      "42:     json_object_iter_set_new",
      "43:     json_object_key_to_iter",
      "44:     json_dumps",
      "45:     json_dumpf",
      "46:     json_dump_file",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "44:     json_object_seed",
      "",
      "---------------"
    ],
    "src/jansson.h||src/jansson.h": [
      "File: src/jansson.h -> src/jansson.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "129: size_t json_object_size(const json_t *object);",
      "130: json_t *json_object_get(const json_t *object, const char *key);",
      "131: int json_object_set_new(json_t *object, const char *key, json_t *value);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "129: void json_object_seed(size_t seed);",
      "",
      "---------------"
    ],
    "src/lookup3.h||src/lookup3.h": [
      "File: src/lookup3.h -> src/lookup3.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2: -------------------------------------------------------------------------------",
      "3: lookup3.c, by Bob Jenkins, May 2006, Public Domain.",
      "5: These are functions for producing 32-bit hashes for hash table lookup.",
      "6: hashword(), hashlittle(), hashlittle2(), hashbig(), mix(), and final()",
      "7: are externally useful functions.  Routines to test the hash are included",
      "8: if SELF_TEST is defined.  You can use this free for any purpose.  It's in",
      "9: the public domain.  It has no warranty.",
      "11: You probably want to use hashlittle().  hashlittle() and hashbig()",
      "12: hash byte arrays.  hashlittle() is is faster than hashbig() on",
      "13: little-endian machines.  Intel and AMD are little-endian machines.",
      "14: On second thought, you probably want hashlittle2(), which is identical to",
      "15: hashlittle() except it returns two 32-bit hashes for the price of one.",
      "16: You could implement hashbig2() if you wanted but I haven't bothered here.",
      "18: If you want to find a hash of, say, exactly 7 integers, do",
      "19:   a = i1;  b = i2;  c = i3;",
      "20:   mix(a,b,c);",
      "21:   a += i4; b += i5; c += i6;",
      "22:   mix(a,b,c);",
      "23:   a += i7;",
      "24:   final(a,b,c);",
      "25: then use c as the hash value.  If you have a variable length array of",
      "26: 4-byte integers to hash, use hashword().  If you have a byte array (like",
      "27: a character string), use hashlittle().  If you have several byte arrays, or",
      "28: a mix of things, see the comments above hashlittle().",
      "30: Why is this so big?  I read 12 bytes at a time into 3 4-byte integers,",
      "31: then mix those integers.  This is fast (you can do a lot more thorough",
      "32: mixing with 12*3 instructions on 3 integers than you can with 3 instructions",
      "33: on 1 byte), but shoehorning those bytes into integers efficiently is messy.",
      "34: -------------------------------------------------------------------------------",
      "37: #include <stdlib.h>",
      "39: #ifdef HAVE_CONFIG_H",
      "40: #include <config.h>",
      "41: #endif",
      "43: #ifdef HAVE_STDINT_H",
      "45: #endif",
      "47: #ifdef HAVE_SYS_PARAM_H",
      "49: #endif",
      "51: #ifdef HAVE_ENDIAN_H",
      "53: #endif",
      "59: #if (defined(__BYTE_ORDER) && defined(__LITTLE_ENDIAN) && \\",
      "60:      __BYTE_ORDER == __LITTLE_ENDIAN) || \\",
      "61:     (defined(i386) || defined(__i386__) || defined(__i486__) || \\",
      "62:      defined(__i586__) || defined(__i686__) || defined(vax) || defined(MIPSEL))",
      "63: # define HASH_LITTLE_ENDIAN 1",
      "64: # define HASH_BIG_ENDIAN 0",
      "65: #elif (defined(__BYTE_ORDER) && defined(__BIG_ENDIAN) && \\",
      "66:        __BYTE_ORDER == __BIG_ENDIAN) || \\",
      "67:       (defined(sparc) || defined(POWERPC) || defined(mc68000) || defined(sel))",
      "68: # define HASH_LITTLE_ENDIAN 0",
      "69: # define HASH_BIG_ENDIAN 1",
      "70: #else",
      "71: # define HASH_LITTLE_ENDIAN 0",
      "72: # define HASH_BIG_ENDIAN 0",
      "73: #endif",
      "75: #define hashsize(n) ((uint32_t)1<<(n))",
      "76: #define hashmask(n) (hashsize(n)-1)",
      "77: #define rot(x,k) (((x)<<(k)) | ((x)>>(32-(k))))",
      "80: -------------------------------------------------------------------------------",
      "81: mix -- mix 3 32-bit values reversibly.",
      "83: This is reversible, so any information in (a,b,c) before mix() is",
      "84: still in (a,b,c) after mix().",
      "86: If four pairs of (a,b,c) inputs are run through mix(), or through",
      "87: mix() in reverse, there are at least 32 bits of the output that",
      "88: are sometimes the same for one pair and different for another pair.",
      "89: This was tested for:",
      "91:   of top bits of (a,b,c), or in any combination of bottom bits of",
      "92:   (a,b,c).",
      "94:   the output delta to a Gray code (a^(a>>1)) so a string of 1's (as",
      "95:   is commonly produced by subtraction) look like a single 1-bit",
      "96:   difference.",
      "98:   all zero plus a counter that starts at zero.",
      "100: Some k values for my \"a-=c; a^=rot(c,k); c+=b;\" arrangement that",
      "101: satisfy this are",
      "102:     4  6  8 16 19  4",
      "103:     9 15  3 18 27 15",
      "104:    14  9  3  7 17  3",
      "105: Well, \"9 15 3 18 27 15\" didn't quite get 32 bits diffing",
      "106: for \"differ\" defined as + with a one-bit base and a two-bit delta.  I",
      "107: used http://burtleburtle.net/bob/hash/avalanche.html to choose",
      "108: the operations, constants, and arrangements of the variables.",
      "110: This does not achieve avalanche.  There are input bits of (a,b,c)",
      "111: that fail to affect some output bits of (a,b,c), especially of a.  The",
      "112: most thoroughly mixed value is c, but it doesn't really even achieve",
      "113: avalanche in c.",
      "115: This allows some parallelism.  Read-after-writes are good at doubling",
      "116: the number of bits affected, so the goal of mixing pulls in the opposite",
      "117: direction as the goal of parallelism.  I did what I could.  Rotates",
      "118: seem to cost as much as shifts on every machine I could lay my hands",
      "119: on, and rotates are much kinder to the top and bottom bits, so I used",
      "120: rotates.",
      "121: -------------------------------------------------------------------------------",
      "123: #define mix(a,b,c) \\",
      "124: { \\",
      "125:   a -= c;  a ^= rot(c, 4);  c += b; \\",
      "126:   b -= a;  b ^= rot(a, 6);  a += c; \\",
      "127:   c -= b;  c ^= rot(b, 8);  b += a; \\",
      "128:   a -= c;  a ^= rot(c,16);  c += b; \\",
      "129:   b -= a;  b ^= rot(a,19);  a += c; \\",
      "130:   c -= b;  c ^= rot(b, 4);  b += a; \\",
      "131: }",
      "134: -------------------------------------------------------------------------------",
      "135: final -- final mixing of 3 32-bit values (a,b,c) into c",
      "137: Pairs of (a,b,c) values differing in only a few bits will usually",
      "138: produce values of c that look totally different.  This was tested for",
      "140:   of top bits of (a,b,c), or in any combination of bottom bits of",
      "141:   (a,b,c).",
      "143:   the output delta to a Gray code (a^(a>>1)) so a string of 1's (as",
      "144:   is commonly produced by subtraction) look like a single 1-bit",
      "145:   difference.",
      "147:   all zero plus a counter that starts at zero.",
      "149: These constants passed:",
      "150:  14 11 25 16 4 14 24",
      "151:  12 14 25 16 4 14 24",
      "152: and these came close:",
      "153:   4  8 15 26 3 22 24",
      "154:  10  8 15 26 3 22 24",
      "155:  11  8 15 26 3 22 24",
      "156: -------------------------------------------------------------------------------",
      "158: #define final(a,b,c) \\",
      "159: { \\",
      "160:   c ^= b; c -= rot(b,14); \\",
      "161:   a ^= c; a -= rot(c,11); \\",
      "162:   b ^= a; b -= rot(a,25); \\",
      "163:   c ^= b; c -= rot(b,16); \\",
      "164:   a ^= c; a -= rot(c,4);  \\",
      "165:   b ^= a; b -= rot(a,14); \\",
      "166:   c ^= b; c -= rot(b,24); \\",
      "167: }",
      "170: -------------------------------------------------------------------------------",
      "171: hashlittle() -- hash a variable-length key into a 32-bit value",
      "172:   k       : the key (the unaligned variable-length array of bytes)",
      "173:   length  : the length of the key, counting by bytes",
      "174:   initval : can be any 4-byte value",
      "175: Returns a 32-bit value.  Every bit of the key affects every bit of",
      "176: the return value.  Two keys differing by one or two bits will have",
      "177: totally different hash values.",
      "179: The best hash table sizes are powers of 2.  There is no need to do",
      "180: mod a prime (mod is sooo slow!).  If you need less than 32 bits,",
      "181: use a bitmask.  For example, if you need only 10 bits, do",
      "182:   h = (h & hashmask(10));",
      "183: In which case, the hash table should have hashsize(10) elements.",
      "185: If you are hashing n strings (uint8_t **)k, do it like this:",
      "186:   for (i=0, h=0; i<n; ++i) h = hashlittle( k[i], len[i], h);",
      "188: By Bob Jenkins, 2006.  bob_jenkins@burtleburtle.net.  You may use this",
      "189: code any way you wish, private, educational, or commercial.  It's free.",
      "191: Use for hash table lookup, or anything where one collision in 2^^32 is",
      "192: acceptable.  Do NOT use for cryptographic purposes.",
      "193: -------------------------------------------------------------------------------",
      "196: static uint32_t hashlittle(const void *key, size_t length, uint32_t initval)",
      "197: {",
      "202:   a = b = c = 0xdeadbeef + ((uint32_t)length) + initval;",
      "204:   u.ptr = key;",
      "205:   if (HASH_LITTLE_ENDIAN && ((u.i & 0x3) == 0)) {",
      "208: #ifdef VALGRIND",
      "209:     const uint8_t  *k8;",
      "210: #endif",
      "213:     while (length > 12)",
      "214:     {",
      "215:       a += k[0];",
      "216:       b += k[1];",
      "217:       c += k[2];",
      "218:       mix(a,b,c);",
      "219:       length -= 12;",
      "220:       k += 3;",
      "221:     }",
      "233: #ifndef VALGRIND",
      "235:     switch(length)",
      "236:     {",
      "237:     case 12: c+=k[2]; b+=k[1]; a+=k[0]; break;",
      "238:     case 11: c+=k[2]&0xffffff; b+=k[1]; a+=k[0]; break;",
      "239:     case 10: c+=k[2]&0xffff; b+=k[1]; a+=k[0]; break;",
      "240:     case 9 : c+=k[2]&0xff; b+=k[1]; a+=k[0]; break;",
      "241:     case 8 : b+=k[1]; a+=k[0]; break;",
      "242:     case 7 : b+=k[1]&0xffffff; a+=k[0]; break;",
      "243:     case 6 : b+=k[1]&0xffff; a+=k[0]; break;",
      "244:     case 5 : b+=k[1]&0xff; a+=k[0]; break;",
      "245:     case 4 : a+=k[0]; break;",
      "246:     case 3 : a+=k[0]&0xffffff; break;",
      "247:     case 2 : a+=k[0]&0xffff; break;",
      "248:     case 1 : a+=k[0]&0xff; break;",
      "250:     }",
      "254:     k8 = (const uint8_t *)k;",
      "255:     switch(length)",
      "256:     {",
      "257:     case 12: c+=k[2]; b+=k[1]; a+=k[0]; break;",
      "261:     case 8 : b+=k[1]; a+=k[0]; break;",
      "265:     case 4 : a+=k[0]; break;",
      "268:     case 1 : a+=k8[0]; break;",
      "269:     case 0 : return c;",
      "270:     }",
      "274:   } else if (HASH_LITTLE_ENDIAN && ((u.i & 0x1) == 0)) {",
      "276:     const uint8_t  *k8;",
      "279:     while (length > 12)",
      "280:     {",
      "281:       a += k[0] + (((uint32_t)k[1])<<16);",
      "282:       b += k[2] + (((uint32_t)k[3])<<16);",
      "283:       c += k[4] + (((uint32_t)k[5])<<16);",
      "284:       mix(a,b,c);",
      "285:       length -= 12;",
      "286:       k += 6;",
      "287:     }",
      "290:     k8 = (const uint8_t *)k;",
      "291:     switch(length)",
      "292:     {",
      "293:     case 12: c+=k[4]+(((uint32_t)k[5])<<16);",
      "294:              b+=k[2]+(((uint32_t)k[3])<<16);",
      "295:              a+=k[0]+(((uint32_t)k[1])<<16);",
      "296:              break;",
      "298:     case 10: c+=k[4];",
      "299:              b+=k[2]+(((uint32_t)k[3])<<16);",
      "300:              a+=k[0]+(((uint32_t)k[1])<<16);",
      "301:              break;",
      "303:     case 8 : b+=k[2]+(((uint32_t)k[3])<<16);",
      "304:              a+=k[0]+(((uint32_t)k[1])<<16);",
      "305:              break;",
      "307:     case 6 : b+=k[2];",
      "308:              a+=k[0]+(((uint32_t)k[1])<<16);",
      "309:              break;",
      "311:     case 4 : a+=k[0]+(((uint32_t)k[1])<<16);",
      "312:              break;",
      "314:     case 2 : a+=k[0];",
      "315:              break;",
      "316:     case 1 : a+=k8[0];",
      "317:              break;",
      "319:     }",
      "322:     const uint8_t *k = (const uint8_t *)key;",
      "325:     while (length > 12)",
      "326:     {",
      "327:       a += k[0];",
      "328:       a += ((uint32_t)k[1])<<8;",
      "329:       a += ((uint32_t)k[2])<<16;",
      "330:       a += ((uint32_t)k[3])<<24;",
      "331:       b += k[4];",
      "332:       b += ((uint32_t)k[5])<<8;",
      "333:       b += ((uint32_t)k[6])<<16;",
      "334:       b += ((uint32_t)k[7])<<24;",
      "335:       c += k[8];",
      "336:       c += ((uint32_t)k[9])<<8;",
      "337:       c += ((uint32_t)k[10])<<16;",
      "338:       c += ((uint32_t)k[11])<<24;",
      "339:       mix(a,b,c);",
      "340:       length -= 12;",
      "341:       k += 12;",
      "342:     }",
      "346:     {",
      "347:     case 12: c+=((uint32_t)k[11])<<24;",
      "348:     case 11: c+=((uint32_t)k[10])<<16;",
      "349:     case 10: c+=((uint32_t)k[9])<<8;",
      "350:     case 9 : c+=k[8];",
      "351:     case 8 : b+=((uint32_t)k[7])<<24;",
      "352:     case 7 : b+=((uint32_t)k[6])<<16;",
      "353:     case 6 : b+=((uint32_t)k[5])<<8;",
      "354:     case 5 : b+=k[4];",
      "355:     case 4 : a+=((uint32_t)k[3])<<24;",
      "356:     case 3 : a+=((uint32_t)k[2])<<16;",
      "357:     case 2 : a+=((uint32_t)k[1])<<8;",
      "358:     case 1 : a+=k[0];",
      "359:              break;",
      "360:     case 0 : return c;",
      "361:     }",
      "362:   }",
      "364:   final(a,b,c);",
      "365:   return c;",
      "366: }",
      "",
      "---------------"
    ],
    "src/utf.h||src/utf.h": [
      "File: src/utf.h -> src/utf.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "11: #ifdef HAVE_CONFIG_H",
      "12: #include <config.h>",
      "31: int utf8_encode(int codepoint, char *buffer, int *size);",
      "",
      "[Removed Lines]",
      "14: #ifdef HAVE_INTTYPES_H",
      "16: no need to include stdint.h separately. If inttypes.h doesn't define",
      "18: #include <inttypes.h>",
      "22: #ifdef _WIN32",
      "23: typedef int int32_t;",
      "26: #include <inttypes.h>",
      "",
      "[Added Lines]",
      "13: #endif",
      "15: #ifdef HAVE_STDINT_H",
      "16: #include <stdint.h>",
      "17: #endif",
      "",
      "---------------"
    ],
    "src/value.c||src/value.c": [
      "File: src/value.c -> src/value.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "9: #define _GNU_SOURCE",
      "10: #endif",
      "12: #include <stddef.h>",
      "13: #include <stdlib.h>",
      "14: #include <string.h>",
      "15: #include <math.h>",
      "17: #include \"jansson.h\"",
      "18: #include \"hashtable.h\"",
      "19: #include \"jansson_private.h\"",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "12: #ifdef HAVE_CONFIG_H",
      "13: #include <config.h>",
      "14: #endif",
      "21: #ifdef HAVE_STDINT_H",
      "22: #include <stdint.h>",
      "23: #endif",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "39: json_t *json_object(void)",
      "40: {",
      "41:     json_object_t *object = jsonp_malloc(sizeof(json_object_t));",
      "42:     if(!object)",
      "43:         return NULL;",
      "44:     json_init(&object->json, JSON_OBJECT);",
      "46:     if(hashtable_init(&object->hashtable))",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "47: extern volatile uint32_t hashtable_seed;",
      "55:     if (!hashtable_seed) {",
      "57:         json_object_seed(0);",
      "58:     }",
      "",
      "---------------"
    ],
    "test/bin/json_process.c||test/bin/json_process.c": [
      "File: test/bin/json_process.c -> test/bin/json_process.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "37:     int sort_keys;",
      "38:     int strip;",
      "39:     int use_env;",
      "40: } conf;",
      "42: #define l_isspace(c) ((c) == ' ' || (c) == '\\n' || (c) == '\\r' || (c) == '\\t')",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "40:     int have_hashseed;",
      "41:     int hashseed;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "108:             conf.sort_keys = atoi(val);",
      "109:         if (!strcmp(line, \"STRIP\"))",
      "110:             conf.strip = atoi(val);",
      "111:     }",
      "113:     free(buffer);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "113:         if (!strcmp(line, \"HASHSEED\")) {",
      "114:             conf.have_hashseed = 1;",
      "115:             conf.hashseed = atoi(val);",
      "116:         } else {",
      "117:             conf.have_hashseed = 0;",
      "118:         }",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "188:     if (conf.sort_keys)",
      "189:         flags |= JSON_SORT_KEYS;",
      "191:     if (conf.strip) {",
      "193:         buffer = loadfile(infile);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "199:     if (conf.have_hashseed)",
      "200:         json_object_seed(conf.hashseed);",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "265:         flags |= JSON_PRESERVE_ORDER;",
      "267:     if(getenv_int(\"JSON_SORT_KEYS\"))",
      "270:     if(getenv_int(\"STRIP\")) {",
      "",
      "[Removed Lines]",
      "268:          flags |= JSON_SORT_KEYS;",
      "",
      "[Added Lines]",
      "279:         flags |= JSON_SORT_KEYS;",
      "281:     if(getenv(\"HASHSEED\"))",
      "282:         json_object_seed(getenv_int(\"HASHSEED\"));",
      "",
      "---------------"
    ],
    "test/suites/api/test_memory_funcs.c||test/suites/api/test_memory_funcs.c": [
      "File: test/suites/api/test_memory_funcs.c -> test/suites/api/test_memory_funcs.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "25: static void *my_malloc(size_t size)",
      "26: {",
      "28:     return malloc(size);",
      "29: }",
      "31: static void my_free(void *ptr)",
      "32: {",
      "34:     free(ptr);",
      "35: }",
      "",
      "[Removed Lines]",
      "27:     malloc_called += 1;",
      "33:     free_called += 1;",
      "",
      "[Added Lines]",
      "27:     malloc_called = 1;",
      "33:     free_called = 1;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "39:     json_set_alloc_funcs(my_malloc, my_free);",
      "40:     create_and_free_complex_object();",
      "43:         fail(\"Custom allocation failed\");",
      "44: }",
      "",
      "[Removed Lines]",
      "42:     if(malloc_called != 20 || free_called != 20)",
      "",
      "[Added Lines]",
      "42:     if(malloc_called != 1 || free_called != 1)",
      "",
      "---------------"
    ],
    "test/suites/api/test_object.c||test/suites/api/test_object.c": [
      "File: test/suites/api/test_object.c -> test/suites/api/test_object.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "250: static void test_iterators()",
      "251: {",
      "252:     json_t *object, *foo, *bar, *baz;",
      "253:     void *iter;",
      "255:     if(json_object_iter(NULL))",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "252:     int i;",
      "254:     const char *iter_keys[3];",
      "255:     int have_key[3] = { 0, 0, 0 };",
      "256:     json_t *iter_values[3];",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "276:     iter = json_object_iter(object);",
      "277:     if(!iter)",
      "278:         fail(\"unable to get iterator\");",
      "284:     iter = json_object_iter_next(object, iter);",
      "285:     if(!iter)",
      "286:         fail(\"unable to increment iterator\");",
      "292:     iter = json_object_iter_next(object, iter);",
      "293:     if(!iter)",
      "294:         fail(\"unable to increment iterator\");",
      "300:     if(json_object_iter_next(object, iter) != NULL)",
      "301:         fail(\"able to iterate over the end\");",
      "303:     if(json_object_iter_at(object, \"foo\"))",
      "304:         fail(\"json_object_iter_at() succeeds for non-existent key\");",
      "",
      "[Removed Lines]",
      "279:     if(strcmp(json_object_iter_key(iter), \"a\"))",
      "280:         fail(\"iterating failed: wrong key\");",
      "281:     if(json_object_iter_value(iter) != foo)",
      "282:         fail(\"iterating failed: wrong value\");",
      "287:     if(strcmp(json_object_iter_key(iter), \"b\"))",
      "288:         fail(\"iterating failed: wrong key\");",
      "289:     if(json_object_iter_value(iter) != bar)",
      "290:         fail(\"iterating failed: wrong value\");",
      "295:     if(strcmp(json_object_iter_key(iter), \"c\"))",
      "296:         fail(\"iterating failed: wrong key\");",
      "297:     if(json_object_iter_value(iter) != baz)",
      "298:         fail(\"iterating failed: wrong value\");",
      "",
      "[Added Lines]",
      "283:     iter_keys[0] = json_object_iter_key(iter);",
      "284:     iter_values[0] = json_object_iter_value(iter);",
      "289:     iter_keys[1] = json_object_iter_key(iter);",
      "290:     iter_values[1] = json_object_iter_value(iter);",
      "295:     iter_keys[2] = json_object_iter_key(iter);",
      "296:     iter_values[2] = json_object_iter_value(iter);",
      "302:     for (i = 0; i < 3; i++) {",
      "303:         if (strcmp(iter_keys[i], \"a\") == 0) {",
      "304:             if (iter_values[i] != foo)",
      "305:                 fail(\"wrong value for iter key a\");",
      "306:             else",
      "307:                 have_key[0] = 1;",
      "308:         } else if (strcmp(iter_keys[i], \"b\") == 0) {",
      "309:             if (iter_values[i] != bar)",
      "310:                 fail(\"wrong value for iter key b\");",
      "311:             else",
      "312:                 have_key[1] = 1;",
      "313:         } else if (strcmp(iter_keys[i], \"c\") == 0) {",
      "314:             if (iter_values[i] != baz)",
      "315:                 fail(\"wrong value for iter key c\");",
      "316:             else",
      "317:                 have_key[2] = 1;",
      "318:         }",
      "319:     }",
      "322:     for(i = 0; i < 3; i++) {",
      "323:         if(!have_key[i])",
      "324:             fail(\"a key wasn't iterated over\");",
      "325:     }",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "312:     if(json_object_iter_value(iter) != bar)",
      "313:         fail(\"iterating failed: wrong value\");",
      "324:         fail(\"unable to set value at iterator\");",
      "327:         fail(\"json_object_iter_key() fails after json_object_iter_set()\");",
      "329:         fail(\"json_object_iter_value() fails after json_object_iter_set()\");",
      "331:         fail(\"json_object_get() fails after json_object_iter_set()\");",
      "333:     json_decref(object);",
      "",
      "[Removed Lines]",
      "315:     iter = json_object_iter_next(object, iter);",
      "316:     if(!iter)",
      "317:         fail(\"unable to increment iterator\");",
      "318:     if(strcmp(json_object_iter_key(iter), \"c\"))",
      "319:         fail(\"iterating failed: wrong key\");",
      "320:     if(json_object_iter_value(iter) != baz)",
      "321:         fail(\"iterating failed: wrong value\");",
      "323:     if(json_object_iter_set(object, iter, bar))",
      "326:     if(strcmp(json_object_iter_key(iter), \"c\"))",
      "328:     if(json_object_iter_value(iter) != bar)",
      "330:     if(json_object_get(object, \"c\") != bar)",
      "",
      "[Added Lines]",
      "339:     if(json_object_iter_set(object, iter, baz))",
      "342:     if(strcmp(json_object_iter_key(iter), \"b\"))",
      "344:     if(json_object_iter_value(iter) != baz)",
      "346:     if(json_object_get(object, \"b\") != baz)",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "42016a35c8907e477be73b0b5d06cc09af231ee4",
      "candidate_info": {
        "commit_hash": "42016a35c8907e477be73b0b5d06cc09af231ee4",
        "repo": "akheron/jansson",
        "commit_url": "https://github.com/akheron/jansson/commit/42016a35c8907e477be73b0b5d06cc09af231ee4",
        "files": [
          "src/hashtable_seed.c"
        ],
        "message": "Oops, ATOMIC_ACQ_REL is not a correct memmodel for __atomic_store_n",
        "before_after_code_files": [
          "src/hashtable_seed.c||src/hashtable_seed.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/hashtable_seed.c||src/hashtable_seed.c"
          ],
          "candidate": [
            "src/hashtable_seed.c||src/hashtable_seed.c"
          ]
        }
      },
      "candidate_diff": {
        "src/hashtable_seed.c||src/hashtable_seed.c": [
          "File: src/hashtable_seed.c -> src/hashtable_seed.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "206:             if (new_seed == 0)",
          "207:                 new_seed = generate_seed();",
          "210:         } else {",
          "212:             do {",
          "",
          "[Removed Lines]",
          "209:             __atomic_store_n(&hashtable_seed, new_seed, __ATOMIC_ACQ_REL);",
          "",
          "[Added Lines]",
          "209:             __atomic_store_n(&hashtable_seed, new_seed, __ATOMIC_RELEASE);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "946531bd7b3f6f53fecca8cdabe71218f9cf12a8",
      "candidate_info": {
        "commit_hash": "946531bd7b3f6f53fecca8cdabe71218f9cf12a8",
        "repo": "akheron/jansson",
        "commit_url": "https://github.com/akheron/jansson/commit/946531bd7b3f6f53fecca8cdabe71218f9cf12a8",
        "files": [
          "src/hashtable_seed.c"
        ],
        "message": "Merge pull request #162 from nmlgc/master\n\nThree fixes for hashtable seeding on Windows",
        "before_after_code_files": [
          "src/hashtable_seed.c||src/hashtable_seed.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/hashtable_seed.c||src/hashtable_seed.c"
          ],
          "candidate": [
            "src/hashtable_seed.c||src/hashtable_seed.c"
          ]
        }
      },
      "candidate_diff": {
        "src/hashtable_seed.c||src/hashtable_seed.c": [
          "File: src/hashtable_seed.c -> src/hashtable_seed.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "38: #endif",
          "40: #if defined(_WIN32)",
          "43: #endif",
          "45: #include \"jansson.h\"",
          "",
          "[Removed Lines]",
          "42: #include <process.h>",
          "",
          "[Added Lines]",
          "42: #include <windows.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "97: #if defined(_WIN32) && defined(USE_WINDOWS_CRYPTOAPI)",
          "99: #include <wincrypt.h>",
          "101: typedef BOOL (WINAPI *CRYPTACQUIRECONTEXTA)(HCRYPTPROV *phProv, LPCSTR pszContainer, LPCSTR pszProvider, DWORD dwProvType, DWORD dwFlags);",
          "",
          "[Removed Lines]",
          "98: #include <windows.h>",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "112:     BYTE data[sizeof(uint32_t)];",
          "113:     int ok;",
          "116:     if(hAdvAPI32 == NULL)",
          "117:         return 1;",
          "",
          "[Removed Lines]",
          "115:     hAdvAPI32 = GetModuleHandle(\"advapi32.dll\");",
          "",
          "[Added Lines]",
          "114:     hAdvAPI32 = GetModuleHandle(TEXT(\"advapi32.dll\"));",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "131:     if (!pCryptAcquireContext(&hCryptProv, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT))",
          "132:         return 1;",
          "135:     pCryptReleaseContext(hCryptProv, 0);",
          "137:     if (!ok)",
          "",
          "[Removed Lines]",
          "134:     ok = CryptGenRandom(hCryptProv, sizeof(uint32_t), data);",
          "",
          "[Added Lines]",
          "133:     ok = pCryptGenRandom(hCryptProv, sizeof(uint32_t), data);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "50a811ca076f9466f337b21e160fc79b06b07c4a",
      "candidate_info": {
        "commit_hash": "50a811ca076f9466f337b21e160fc79b06b07c4a",
        "repo": "akheron/jansson",
        "commit_url": "https://github.com/akheron/jansson/commit/50a811ca076f9466f337b21e160fc79b06b07c4a",
        "files": [
          "CMakeLists.txt",
          "configure.ac"
        ],
        "message": "Fix feature checks to use correct __ATOMIC flags",
        "before_after_code_files": [
          "configure.ac||configure.ac"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "configure.ac||configure.ac"
          ],
          "candidate": [
            "configure.ac||configure.ac"
          ]
        }
      },
      "candidate_diff": {
        "configure.ac||configure.ac": [
          "File: configure.ac -> configure.ac",
          "--- Hunk 1 ---",
          "[Context before]",
          "47: AC_MSG_CHECKING([for gcc __atomic builtins])",
          "48: have_atomic_builtins=no",
          "49: AC_TRY_LINK(",
          "51:   [have_atomic_builtins=yes],",
          "52: )",
          "53: if test \"x$have_atomic_builtins\" = \"xyes\"; then",
          "",
          "[Removed Lines]",
          "50:   [], [char l; unsigned long v; __atomic_test_and_set(&l, __ATOMIC_RELAXED); __atomic_store_n(&v, 1, __ATOMIC_ACQ_REL); __atomic_load_n(&v, __ATOMIC_ACQUIRE);],",
          "",
          "[Added Lines]",
          "50:   [], [char l; unsigned long v; __atomic_test_and_set(&l, __ATOMIC_RELAXED); __atomic_store_n(&v, 1, __ATOMIC_RELEASE); __atomic_load_n(&v, __ATOMIC_ACQUIRE);],",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "569295fe3026f1deecfd6cc2e851054e6c9f9469",
      "candidate_info": {
        "commit_hash": "569295fe3026f1deecfd6cc2e851054e6c9f9469",
        "repo": "akheron/jansson",
        "commit_url": "https://github.com/akheron/jansson/commit/569295fe3026f1deecfd6cc2e851054e6c9f9469",
        "files": [
          "CMakeLists.txt",
          "configure.ac"
        ],
        "message": "Fix feature checks to use correct __ATOMIC flags",
        "before_after_code_files": [
          "configure.ac||configure.ac"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "configure.ac||configure.ac"
          ],
          "candidate": [
            "configure.ac||configure.ac"
          ]
        }
      },
      "candidate_diff": {
        "configure.ac||configure.ac": [
          "File: configure.ac -> configure.ac",
          "--- Hunk 1 ---",
          "[Context before]",
          "47: AC_MSG_CHECKING([for gcc __atomic builtins])",
          "48: have_atomic_builtins=no",
          "49: AC_TRY_LINK(",
          "51:   [have_atomic_builtins=yes],",
          "52: )",
          "53: if test \"x$have_atomic_builtins\" = \"xyes\"; then",
          "",
          "[Removed Lines]",
          "50:   [], [char l; unsigned long v; __atomic_test_and_set(&l, __ATOMIC_RELAXED); __atomic_store_n(&v, 1, __ATOMIC_ACQ_REL); __atomic_load_n(&v, __ATOMIC_ACQUIRE);],",
          "",
          "[Added Lines]",
          "50:   [], [char l; unsigned long v; __atomic_test_and_set(&l, __ATOMIC_RELAXED); __atomic_store_n(&v, 1, __ATOMIC_RELEASE); __atomic_load_n(&v, __ATOMIC_ACQUIRE);],",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "abaae7630ec9df0adca1ec012ddbcc4b211e54f1",
      "candidate_info": {
        "commit_hash": "abaae7630ec9df0adca1ec012ddbcc4b211e54f1",
        "repo": "akheron/jansson",
        "commit_url": "https://github.com/akheron/jansson/commit/abaae7630ec9df0adca1ec012ddbcc4b211e54f1",
        "files": [
          "CMakeLists.txt",
          "cmake/jansson_private_config.h.cmake",
          "configure.ac",
          "src/hashtable.c"
        ],
        "message": "Make it possible to set initial hashtable size\n\nFixes #213.",
        "before_after_code_files": [
          "cmake/jansson_private_config.h.cmake||cmake/jansson_private_config.h.cmake",
          "configure.ac||configure.ac",
          "src/hashtable.c||src/hashtable.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "configure.ac||configure.ac",
            "src/hashtable.c||src/hashtable.c"
          ],
          "candidate": [
            "configure.ac||configure.ac",
            "src/hashtable.c||src/hashtable.c"
          ]
        }
      },
      "candidate_diff": {
        "cmake/jansson_private_config.h.cmake||cmake/jansson_private_config.h.cmake": [
          "File: cmake/jansson_private_config.h.cmake -> cmake/jansson_private_config.h.cmake",
          "--- Hunk 1 ---",
          "[Context before]",
          "58: #cmakedefine USE_URANDOM 1",
          "59: #cmakedefine USE_WINDOWS_CRYPTOAPI 1",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "61: #define INITIAL_HASHTABLE_ORDER @JANSSON_INITIAL_HASHTABLE_ORDER@",
          "",
          "---------------"
        ],
        "configure.ac||configure.ac": [
          "File: configure.ac -> configure.ac",
          "--- Hunk 1 ---",
          "[Context before]",
          "92:   [Define to 1 if CryptGenRandom should be used for seeding the hash function])",
          "93: fi",
          "95: if test x$GCC = xyes; then",
          "96:     AM_CFLAGS=\"-Wall -Wextra -Wdeclaration-after-statement\"",
          "97: fi",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "95: AC_ARG_ENABLE([initial-hashtable-order],",
          "96:   [AS_HELP_STRING([--enable-initial-hashtable-order=VAL],",
          "97:     [Number of buckets new object hashtables contain is 2 raised to this power. The default is 3, so empty hashtables contain 2^3 = 8 buckets.])],",
          "98:   [initial_hashtable_order=$enableval], [initial_hashtable_order=3])",
          "99: AC_DEFINE_UNQUOTED([INITIAL_HASHTABLE_ORDER], [$initial_hashtable_order],",
          "100:   [Number of buckets new object hashtables contain is 2 raised to this power. E.g. 3 -> 2^3 = 8.])",
          "",
          "---------------"
        ],
        "src/hashtable.c||src/hashtable.c": [
          "File: src/hashtable.c -> src/hashtable.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "21: #include \"hashtable.h\"",
          "23: typedef struct hashtable_list list_t;",
          "24: typedef struct hashtable_pair pair_t;",
          "25: typedef struct hashtable_bucket bucket_t;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "23: #ifndef INITIAL_HASHTABLE_ORDER",
          "24: #define INITIAL_HASHTABLE_ORDER 3",
          "25: #endif",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "184:     size_t i;",
          "186:     hashtable->size = 0;",
          "188:     hashtable->buckets = jsonp_malloc(hashsize(hashtable->order) * sizeof(bucket_t));",
          "189:     if(!hashtable->buckets)",
          "190:         return -1;",
          "",
          "[Removed Lines]",
          "187:     hashtable->order = 3;",
          "",
          "[Added Lines]",
          "191:     hashtable->order = INITIAL_HASHTABLE_ORDER;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
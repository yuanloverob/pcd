{
  "cve_id": "CVE-2021-32672",
  "cve_desc": "Redis is an open source, in-memory database that persists on disk. When using the Redis Lua Debugger, users can send malformed requests that cause the debugger\u2019s protocol parser to read data beyond the actual buffer. This issue affects all versions of Redis with Lua debugging support (3.2 or newer). The problem is fixed in versions 6.2.6, 6.0.16 and 5.0.14.",
  "repo": "redis/redis",
  "patch_hash": "6ac3c0b7abd35f37201ed2d6298ecef4ea1ae1dd",
  "patch_info": {
    "commit_hash": "6ac3c0b7abd35f37201ed2d6298ecef4ea1ae1dd",
    "repo": "redis/redis",
    "commit_url": "https://github.com/redis/redis/commit/6ac3c0b7abd35f37201ed2d6298ecef4ea1ae1dd",
    "files": [
      "src/scripting.c",
      "tests/unit/scripting.tcl"
    ],
    "message": "Fix protocol parsing on 'ldbReplParseCommand' (CVE-2021-32672)\n\nThe protocol parsing on 'ldbReplParseCommand' (LUA debugging)\nAssumed protocol correctness. This means that if the following\nis given:\n*1\n$100\ntest\nThe parser will try to read additional 94 unallocated bytes after\nthe client buffer.\nThis commit fixes this issue by validating that there are actually enough\nbytes to read. It also limits the amount of data that can be sent by\nthe debugger client to 1M so the client will not be able to explode\nthe memory.",
    "before_after_code_files": [
      "src/scripting.c||src/scripting.c",
      "tests/unit/scripting.tcl||tests/unit/scripting.tcl"
    ]
  },
  "patch_diff": {
    "src/scripting.c||src/scripting.c": [
      "File: src/scripting.c -> src/scripting.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "2030:     sds *argv = NULL;",
      "2031:     int argc = 0;",
      "2032:     if (sdslen(ldb.cbuf) == 0) return NULL;",
      "",
      "[Removed Lines]",
      "2029: sds *ldbReplParseCommand(int *argcp) {",
      "",
      "[Added Lines]",
      "2029: sds *ldbReplParseCommand(int *argcp, char** err) {",
      "2030:     static char* protocol_error = \"protocol error\";",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "2044:     p = strchr(p,'*'); if (!p) goto protoerr;",
      "2049:     if (*argcp <= 0 || *argcp > 1024) goto protoerr;",
      "",
      "[Removed Lines]",
      "2046:     p = strstr(p,\"\\r\\n\"); if (!p) goto protoerr;",
      "",
      "[Added Lines]",
      "2047:     p = strstr(p,\"\\r\\n\"); if (!p) goto keep_reading;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "2052:     argv = zmalloc(sizeof(sds)*(*argcp));",
      "2053:     argc = 0;",
      "2054:     while(argc < *argcp) {",
      "2055:         if (*p != '$') goto protoerr;",
      "2060:         if (slen <= 0 || slen > 1024) goto protoerr;",
      "2061:         argv[argc++] = sdsnewlen(p,slen);",
      "2063:         if (p[0] != '\\r' || p[1] != '\\n') goto protoerr;",
      "",
      "[Removed Lines]",
      "2057:         p = strstr(p,\"\\r\\n\"); if (!p) goto protoerr;",
      "",
      "[Added Lines]",
      "2057:         if (*p == '\\0') goto keep_reading;",
      "2061:         p = strstr(p,\"\\r\\n\"); if (!p) goto keep_reading;",
      "2065:         if ((size_t)(p + slen + 2 - copy) > sdslen(copy) ) goto keep_reading;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "2067:     return argv;",
      "2069: protoerr:",
      "2070:     sdsfreesplitres(argv,argc);",
      "2071:     sdsfree(copy);",
      "2072:     return NULL;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2076: keep_reading:",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "2555: int ldbRepl(lua_State *lua) {",
      "2556:     sds *argv;",
      "2557:     int argc;",
      "2561:     while(1) {",
      "2563:             char buf[1024];",
      "2564:             int nread = connRead(ldb.conn,buf,sizeof(buf));",
      "2565:             if (nread <= 0) {",
      "",
      "[Removed Lines]",
      "2562:         while((argv = ldbReplParseCommand(&argc)) == NULL) {",
      "",
      "[Added Lines]",
      "2565:     char* err = NULL;",
      "2570:         while((argv = ldbReplParseCommand(&argc, &err)) == NULL) {",
      "2572:             if (err) {",
      "2573:                 lua_pushstring(lua, err);",
      "2574:                 lua_error(lua);",
      "2575:             }",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "2570:                 return C_ERR;",
      "2571:             }",
      "2572:             ldb.cbuf = sdscatlen(ldb.cbuf,buf,nread);",
      "2573:         }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2588:             if (sdslen(ldb.cbuf) > 1<<20) {",
      "2589:                 sdsfree(ldb.cbuf);",
      "2590:                 ldb.cbuf = sdsempty();",
      "2591:                 lua_pushstring(lua, \"max client buffer reached\");",
      "2592:                 lua_error(lua);",
      "2593:             }",
      "",
      "---------------"
    ],
    "tests/unit/scripting.tcl||tests/unit/scripting.tcl": [
      "File: tests/unit/scripting.tcl -> tests/unit/scripting.tcl",
      "--- Hunk 1 ---",
      "[Context before]",
      "820:     r eval {return 'hello'} 0",
      "821:     r eval {return 'hello'} 0",
      "822: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "824: start_server {tags {\"scripting needs:debug external:skip\"}} {",
      "825:     test {Test scripting debug protocol parsing} {",
      "826:         r script debug sync",
      "827:         r eval {return 'hello'} 0",
      "828:         catch {r 'hello\\0world'} e",
      "829:         assert_match {*Unknown Redis Lua debugger command*} $e",
      "830:         catch {r 'hello\\0'} e",
      "831:         assert_match {*Unknown Redis Lua debugger command*} $e",
      "832:         catch {r '\\0hello'} e",
      "833:         assert_match {*Unknown Redis Lua debugger command*} $e",
      "834:         catch {r '\\0hello\\0'} e",
      "835:         assert_match {*Unknown Redis Lua debugger command*} $e",
      "836:     }",
      "837: }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "5895d119b1c2825ff0394f30e246e036c3972bc5",
      "candidate_info": {
        "commit_hash": "5895d119b1c2825ff0394f30e246e036c3972bc5",
        "repo": "redis/redis",
        "commit_url": "https://github.com/redis/redis/commit/5895d119b1c2825ff0394f30e246e036c3972bc5",
        "files": [
          "00-RELEASENOTES",
          "src/version.h"
        ],
        "message": "Redis 6.0.16",
        "before_after_code_files": [
          "src/version.h||src/version.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/redis/redis/pull/9584"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/version.h||src/version.h": [
          "File: src/version.h -> src/version.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: #define REDIS_VERSION \"6.0.15\"",
          "2: #define REDIS_VERSION_NUM 0x0006000f",
          "",
          "[Added Lines]",
          "1: #define REDIS_VERSION \"6.0.16\"",
          "2: #define REDIS_VERSION_NUM 0x00060010",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "f6a40570fa63d5afdd596c78083d754081d80ae3",
      "candidate_info": {
        "commit_hash": "f6a40570fa63d5afdd596c78083d754081d80ae3",
        "repo": "redis/redis",
        "commit_url": "https://github.com/redis/redis/commit/f6a40570fa63d5afdd596c78083d754081d80ae3",
        "files": [
          "src/geo.c",
          "src/listpack.c",
          "src/quicklist.c",
          "src/rdb.c",
          "src/server.h",
          "src/t_hash.c",
          "src/t_list.c",
          "src/t_stream.c",
          "src/t_zset.c",
          "src/ziplist.c",
          "src/ziplist.h",
          "tests/support/util.tcl",
          "tests/unit/violations.tcl"
        ],
        "message": "Fix ziplist and listpack overflows and truncations (CVE-2021-32627, CVE-2021-32628)\n\n- fix possible heap corruption in ziplist and listpack resulting by trying to\n  allocate more than the maximum size of 4GB.\n- prevent ziplist (hash and zset) from reaching size of above 1GB, will be\n  converted to HT encoding, that's not a useful size.\n- prevent listpack (stream) from reaching size of above 1GB.\n- XADD will start a new listpack if the new record may cause the previous\n  listpack to grow over 1GB.\n- XADD will respond with an error if a single stream record is over 1GB\n- List type (ziplist in quicklist) was truncating strings that were over 4GB,\n  now it'll respond with an error.",
        "before_after_code_files": [
          "src/geo.c||src/geo.c",
          "src/listpack.c||src/listpack.c",
          "src/quicklist.c||src/quicklist.c",
          "src/rdb.c||src/rdb.c",
          "src/server.h||src/server.h",
          "src/t_hash.c||src/t_hash.c",
          "src/t_list.c||src/t_list.c",
          "src/t_stream.c||src/t_stream.c",
          "src/t_zset.c||src/t_zset.c",
          "src/ziplist.c||src/ziplist.c",
          "src/ziplist.h||src/ziplist.h",
          "tests/support/util.tcl||tests/support/util.tcl",
          "tests/unit/violations.tcl||tests/unit/violations.tcl"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/redis/redis/pull/9584"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/geo.c||src/geo.c": [
          "File: src/geo.c -> src/geo.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "635:         robj *zobj;",
          "636:         zset *zs;",
          "637:         int i;",
          "640:         if (returned_items) {",
          "641:             zobj = createZsetObject();",
          "",
          "[Removed Lines]",
          "638:         size_t maxelelen = 0;",
          "",
          "[Added Lines]",
          "638:         size_t maxelelen = 0, totelelen = 0;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "650:             size_t elelen = sdslen(gp->member);",
          "652:             if (maxelelen < elelen) maxelelen = elelen;",
          "653:             znode = zslInsert(zs->zsl,score,gp->member);",
          "654:             serverAssert(dictAdd(zs->dict,gp->member,&znode->score) == DICT_OK);",
          "655:             gp->member = NULL;",
          "656:         }",
          "658:         if (returned_items) {",
          "660:             setKey(c,c->db,storekey,zobj);",
          "661:             decrRefCount(zobj);",
          "662:             notifyKeyspaceEvent(NOTIFY_ZSET,\"georadiusstore\",storekey,",
          "",
          "[Removed Lines]",
          "659:             zsetConvertToZiplistIfNeeded(zobj,maxelelen);",
          "",
          "[Added Lines]",
          "653:             totelelen += elelen;",
          "660:             zsetConvertToZiplistIfNeeded(zobj,maxelelen,totelelen);",
          "",
          "---------------"
        ],
        "src/listpack.c||src/listpack.c": [
          "File: src/listpack.c -> src/listpack.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "283:     } else {",
          "284:         if (size < 64) *enclen = 1+size;",
          "285:         else if (size < 4096) *enclen = 2+size;",
          "287:         return LP_ENCODING_STRING;",
          "288:     }",
          "289: }",
          "",
          "[Removed Lines]",
          "286:         else *enclen = 5+size;",
          "",
          "[Added Lines]",
          "286:         else *enclen = 5+(uint64_t)size;",
          "",
          "---------------"
        ],
        "src/quicklist.c||src/quicklist.c": [
          "File: src/quicklist.c -> src/quicklist.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "32: #include \"quicklist.h\"",
          "33: #include \"zmalloc.h\"",
          "34: #include \"ziplist.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "32: #include \"redisassert.h\"",
          "",
          "---------------"
        ],
        "src/rdb.c||src/rdb.c": [
          "File: src/rdb.c -> src/rdb.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1561:     } else if (rdbtype == RDB_TYPE_ZSET_2 || rdbtype == RDB_TYPE_ZSET) {",
          "1563:         uint64_t zsetlen;",
          "1565:         zset *zs;",
          "1567:         if ((zsetlen = rdbLoadLen(rdb,NULL)) == RDB_LENERR) return NULL;",
          "",
          "[Removed Lines]",
          "1564:         size_t maxelelen = 0;",
          "",
          "[Added Lines]",
          "1564:         size_t maxelelen = 0, totelelen = 0;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1600:             if (sdslen(sdsele) > maxelelen) maxelelen = sdslen(sdsele);",
          "1602:             znode = zslInsert(zs->zsl,score,sdsele);",
          "1603:             dictAdd(zs->dict,sdsele,&znode->score);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1601:             totelelen += sdslen(sdsele);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1607:         if (zsetLength(o) <= server.zset_max_ziplist_entries &&",
          "1610:     } else if (rdbtype == RDB_TYPE_HASH) {",
          "1611:         uint64_t len;",
          "1612:         int ret;",
          "",
          "[Removed Lines]",
          "1608:             maxelelen <= server.zset_max_ziplist_value)",
          "1609:                 zsetConvert(o,OBJ_ENCODING_ZIPLIST);",
          "",
          "[Added Lines]",
          "1609:             maxelelen <= server.zset_max_ziplist_value &&",
          "1610:             ziplistSafeToAdd(NULL, totelelen))",
          "1611:         {",
          "1612:             zsetConvert(o,OBJ_ENCODING_ZIPLIST);",
          "1613:         }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1635:                 return NULL;",
          "1636:             }",
          "1645:             if (sdslen(field) > server.hash_max_ziplist_value ||",
          "1647:             {",
          "1650:                 hashTypeConvert(o, OBJ_ENCODING_HT);",
          "1651:                 break;",
          "1652:             }",
          "1653:             sdsfree(field);",
          "1654:             sdsfree(value);",
          "1655:         }",
          "",
          "[Removed Lines]",
          "1639:             o->ptr = ziplistPush(o->ptr, (unsigned char*)field,",
          "1640:                     sdslen(field), ZIPLIST_TAIL);",
          "1641:             o->ptr = ziplistPush(o->ptr, (unsigned char*)value,",
          "1642:                     sdslen(value), ZIPLIST_TAIL);",
          "1646:                 sdslen(value) > server.hash_max_ziplist_value)",
          "1648:                 sdsfree(field);",
          "1649:                 sdsfree(value);",
          "",
          "[Added Lines]",
          "1644:                 sdslen(value) > server.hash_max_ziplist_value ||",
          "1645:                 !ziplistSafeToAdd(o->ptr, sdslen(field)+sdslen(value)))",
          "1648:                 ret = dictAdd((dict*)o->ptr, field, value);",
          "1649:                 if (ret == DICT_ERR) {",
          "1650:                     rdbExitReportCorruptRDB(\"Duplicate hash fields detected\");",
          "1651:                 }",
          "1656:             o->ptr = ziplistPush(o->ptr, (unsigned char*)field,",
          "1657:                     sdslen(field), ZIPLIST_TAIL);",
          "1658:             o->ptr = ziplistPush(o->ptr, (unsigned char*)value,",
          "1659:                     sdslen(value), ZIPLIST_TAIL);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1726:                     while ((zi = zipmapNext(zi, &fstr, &flen, &vstr, &vlen)) != NULL) {",
          "1727:                         if (flen > maxlen) maxlen = flen;",
          "1728:                         if (vlen > maxlen) maxlen = vlen;",
          "1729:                         zl = ziplistPush(zl, fstr, flen, ZIPLIST_TAIL);",
          "1730:                         zl = ziplistPush(zl, vstr, vlen, ZIPLIST_TAIL);",
          "1731:                     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1737:                         if (!ziplistSafeToAdd(zl, (size_t)flen + vlen)) {",
          "1738:                             rdbExitReportCorruptRDB(\"Hash zipmap too big (%u)\", flen);",
          "1739:                         }",
          "",
          "---------------"
        ],
        "src/server.h||src/server.h": [
          "File: src/server.h -> src/server.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "1999: unsigned char *zzlLastInRange(unsigned char *zl, zrangespec *range);",
          "2000: unsigned long zsetLength(const robj *zobj);",
          "2001: void zsetConvert(robj *zobj, int encoding);",
          "2003: int zsetScore(robj *zobj, sds member, double *score);",
          "2004: unsigned long zslGetRank(zskiplist *zsl, double score, sds o);",
          "2005: int zsetAdd(robj *zobj, double score, sds ele, int *flags, double *newscore);",
          "",
          "[Removed Lines]",
          "2002: void zsetConvertToZiplistIfNeeded(robj *zobj, size_t maxelelen);",
          "",
          "[Added Lines]",
          "2002: void zsetConvertToZiplistIfNeeded(robj *zobj, size_t maxelelen, size_t totelelen);",
          "",
          "---------------"
        ],
        "src/t_hash.c||src/t_hash.c": [
          "File: src/t_hash.c -> src/t_hash.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "40: void hashTypeTryConversion(robj *o, robj **argv, int start, int end) {",
          "41:     int i;",
          "43:     if (o->encoding != OBJ_ENCODING_ZIPLIST) return;",
          "45:     for (i = start; i <= end; i++) {",
          "49:             hashTypeConvert(o, OBJ_ENCODING_HT);",
          "51:         }",
          "52:     }",
          "53: }",
          "",
          "[Removed Lines]",
          "46:         if (sdsEncodedObject(argv[i]) &&",
          "47:             sdslen(argv[i]->ptr) > server.hash_max_ziplist_value)",
          "48:         {",
          "50:             break;",
          "",
          "[Added Lines]",
          "42:     size_t sum = 0;",
          "47:         if (!sdsEncodedObject(argv[i]))",
          "48:             continue;",
          "49:         size_t len = sdslen(argv[i]->ptr);",
          "50:         if (len > server.hash_max_ziplist_value) {",
          "52:             return;",
          "54:         sum += len;",
          "56:     if (!ziplistSafeToAdd(o->ptr, sum))",
          "57:         hashTypeConvert(o, OBJ_ENCODING_HT);",
          "",
          "---------------"
        ],
        "src/t_list.c||src/t_list.c": [
          "File: src/t_list.c -> src/t_list.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "30: #include \"server.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "32: #define LIST_MAX_ITEM_SIZE ((1ull<<32)-1024)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "197: void pushGenericCommand(client *c, int where) {",
          "198:     int j, pushed = 0;",
          "199:     robj *lobj = lookupKeyWrite(c->db,c->argv[1]);",
          "201:     if (lobj && lobj->type != OBJ_LIST) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "202:     for (j = 2; j < c->argc; j++) {",
          "203:         if (sdslen(c->argv[j]->ptr) > LIST_MAX_ITEM_SIZE) {",
          "204:             addReplyError(c, \"Element too large\");",
          "205:             return;",
          "206:         }",
          "207:     }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "277:         return;",
          "278:     }",
          "280:     if ((subject = lookupKeyWriteOrReply(c,c->argv[1],shared.czero)) == NULL ||",
          "281:         checkType(c,subject,OBJ_LIST)) return;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "290:     if (sdslen(c->argv[4]->ptr) > LIST_MAX_ITEM_SIZE) {",
          "291:         addReplyError(c, \"Element too large\");",
          "292:         return;",
          "293:     }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "344:     long index;",
          "345:     robj *value = c->argv[3];",
          "347:     if ((getLongFromObjectOrReply(c, c->argv[2], &index, NULL) != C_OK))",
          "348:         return;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "362:     if (sdslen(value->ptr) > LIST_MAX_ITEM_SIZE) {",
          "363:         addReplyError(c, \"Element too large\");",
          "364:         return;",
          "365:     }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "510:     int direction = LIST_TAIL;",
          "514:     for (int j = 3; j < c->argc; j++) {",
          "515:         char *opt = c->argv[j]->ptr;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "533:     if (sdslen(ele->ptr) > LIST_MAX_ITEM_SIZE) {",
          "534:         addReplyError(c, \"Element too large\");",
          "535:         return;",
          "536:     }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "610:     long toremove;",
          "611:     long removed = 0;",
          "613:     if ((getLongFromObjectOrReply(c, c->argv[2], &toremove, NULL) != C_OK))",
          "614:         return;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "638:     if (sdslen(obj->ptr) > LIST_MAX_ITEM_SIZE) {",
          "639:         addReplyError(c, \"Element too large\");",
          "640:         return;",
          "641:     }",
          "",
          "---------------"
        ],
        "src/t_stream.c||src/t_stream.c": [
          "File: src/t_stream.c -> src/t_stream.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "43: void streamFreeCG(streamCG *cg);",
          "44: void streamFreeNACK(streamNACK *na);",
          "45: size_t streamReplyWithRangeFromConsumerPEL(client *c, stream *s, streamID *start, streamID *end, size_t count, streamConsumer *consumer);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "47: #define STREAM_LISTPACK_MAX_SIZE (1<<30)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "212:     raxIterator ri;",
          "",
          "[Removed Lines]",
          "209:     if (streamCompareID(&id,&s->last_id) <= 0) return C_ERR;",
          "",
          "[Added Lines]",
          "218:     if (streamCompareID(&id,&s->last_id) <= 0) {",
          "219:         errno = EDOM;",
          "220:         return C_ERR;",
          "221:     }",
          "226:     size_t totelelen = 0;",
          "227:     for (int64_t i = 0; i < numfields*2; i++) {",
          "228:         sds ele = argv[i]->ptr;",
          "229:         totelelen += sdslen(ele);",
          "230:     }",
          "231:     if (totelelen > STREAM_LISTPACK_MAX_SIZE) {",
          "232:         errno = ERANGE;",
          "233:         return C_ERR;",
          "234:     }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "267:     if (lp != NULL) {",
          "271:             lp = NULL;",
          "272:         } else if (server.stream_node_max_entries) {",
          "273:             int64_t count = lpGetInteger(lpFirst(lp));",
          "",
          "[Removed Lines]",
          "268:         if (server.stream_node_max_bytes &&",
          "269:             lp_bytes >= server.stream_node_max_bytes)",
          "270:         {",
          "",
          "[Added Lines]",
          "293:         size_t node_max_bytes = server.stream_node_max_bytes;",
          "294:         if (node_max_bytes == 0 || node_max_bytes > STREAM_LISTPACK_MAX_SIZE)",
          "295:             node_max_bytes = STREAM_LISTPACK_MAX_SIZE;",
          "296:         if (lp_bytes + totelelen >= node_max_bytes) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1269:     if (streamAppendItem(s,c->argv+field_pos,(c->argc-field_pos)/2,",
          "1272:     {",
          "1275:         return;",
          "1276:     }",
          "1277:     addReplyStreamID(c,&id);",
          "",
          "[Removed Lines]",
          "1270:         &id, id_given ? &id : NULL)",
          "1271:         == C_ERR)",
          "1273:         addReplyError(c,\"The ID specified in XADD is equal or smaller than the \"",
          "1274:                         \"target stream top item\");",
          "",
          "[Added Lines]",
          "1296:         &id, id_given ? &id : NULL) == C_ERR)",
          "1298:         if (errno == EDOM)",
          "1299:             addReplyError(c,\"The ID specified in XADD is equal or smaller than \"",
          "1300:                             \"the target stream top item\");",
          "1301:         else",
          "1302:             addReplyError(c,\"Elements are too large to be stored\");",
          "",
          "---------------"
        ],
        "src/t_zset.c||src/t_zset.c": [
          "File: src/t_zset.c -> src/t_zset.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1238: }",
          "1244:     if (zobj->encoding == OBJ_ENCODING_ZIPLIST) return;",
          "1245:     zset *zset = zobj->ptr;",
          "1247:     if (zset->zsl->length <= server.zset_max_ziplist_entries &&",
          "1250: }",
          "",
          "[Removed Lines]",
          "1243: void zsetConvertToZiplistIfNeeded(robj *zobj, size_t maxelelen) {",
          "1248:         maxelelen <= server.zset_max_ziplist_value)",
          "1249:             zsetConvert(zobj,OBJ_ENCODING_ZIPLIST);",
          "",
          "[Added Lines]",
          "1243: void zsetConvertToZiplistIfNeeded(robj *zobj, size_t maxelelen, size_t totelelen) {",
          "1248:         maxelelen <= server.zset_max_ziplist_value &&",
          "1249:         ziplistSafeToAdd(NULL, totelelen))",
          "1250:     {",
          "1251:         zsetConvert(zobj,OBJ_ENCODING_ZIPLIST);",
          "1252:     }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1355:             }",
          "1356:             return 1;",
          "1357:         } else if (!xx) {",
          "1363:                 zsetConvert(zobj,OBJ_ENCODING_SKIPLIST);",
          "1367:         } else {",
          "1369:             return 1;",
          "1370:         }",
          "1372:         zset *zs = zobj->ptr;",
          "1373:         zskiplistNode *znode;",
          "1374:         dictEntry *de;",
          "",
          "[Removed Lines]",
          "1360:             zobj->ptr = zzlInsert(zobj->ptr,ele,score);",
          "1361:             if (zzlLength(zobj->ptr) > server.zset_max_ziplist_entries ||",
          "1362:                 sdslen(ele) > server.zset_max_ziplist_value)",
          "1364:             if (newscore) *newscore = score;",
          "1366:             return 1;",
          "1371:     } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {",
          "",
          "[Added Lines]",
          "1363:             if (zzlLength(zobj->ptr)+1 > server.zset_max_ziplist_entries ||",
          "1364:                 sdslen(ele) > server.zset_max_ziplist_value ||",
          "1365:                 !ziplistSafeToAdd(zobj->ptr, sdslen(ele)))",
          "1366:             {",
          "1368:             } else {",
          "1369:                 zobj->ptr = zzlInsert(zobj->ptr,ele,score);",
          "1370:                 if (newscore) *newscore = score;",
          "1372:                 return 1;",
          "1373:             }",
          "1378:     }",
          "1382:     if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2180:     zsetopsrc *src;",
          "2181:     zsetopval zval;",
          "2182:     sds tmp;",
          "2184:     robj *dstobj;",
          "2185:     zset *dstzset;",
          "2186:     zskiplistNode *znode;",
          "",
          "[Removed Lines]",
          "2183:     size_t maxelelen = 0;",
          "",
          "[Added Lines]",
          "2194:     size_t maxelelen = 0, totelelen = 0;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2304:                     tmp = zuiNewSdsFromValue(&zval);",
          "2305:                     znode = zslInsert(dstzset->zsl,score,tmp);",
          "2306:                     dictAdd(dstzset->dict,tmp,&znode->score);",
          "2307:                     if (sdslen(tmp) > maxelelen) maxelelen = sdslen(tmp);",
          "2308:                 }",
          "2309:             }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2318:                     totelelen += sdslen(tmp);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2343:                      if (sdslen(tmp) > maxelelen) maxelelen = sdslen(tmp);",
          "2345:                     dictSetKey(accumulator, de, tmp);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2355:                      totelelen += sdslen(tmp);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2380:     if (dbDelete(c->db,dstkey))",
          "2381:         touched = 1;",
          "2382:     if (dstzset->zsl->length) {",
          "2384:         dbAdd(c->db,dstkey,dstobj);",
          "2385:         addReplyLongLong(c,zsetLength(dstobj));",
          "2386:         signalModifiedKey(c,c->db,dstkey);",
          "",
          "[Removed Lines]",
          "2383:         zsetConvertToZiplistIfNeeded(dstobj,maxelelen);",
          "",
          "[Added Lines]",
          "2396:         zsetConvertToZiplistIfNeeded(dstobj,maxelelen,totelelen);",
          "",
          "---------------"
        ],
        "src/ziplist.c||src/ziplist.c": [
          "File: src/ziplist.c -> src/ziplist.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "265:         ZIPLIST_LENGTH(zl) = intrev16ifbe(intrev16ifbe(ZIPLIST_LENGTH(zl))+incr); \\",
          "266: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "270: #define ZIPLIST_MAX_SAFETY_SIZE (1<<30)",
          "271: int ziplistSafeToAdd(unsigned char* zl, size_t add) {",
          "272:     size_t len = zl? ziplistBlobLen(zl): 0;",
          "273:     if (len + add > ZIPLIST_MAX_SAFETY_SIZE)",
          "274:         return 0;",
          "275:     return 1;",
          "276: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "586: }",
          "590:     zl = zrealloc(zl,len);",
          "591:     ZIPLIST_BYTES(zl) = intrev32ifbe(len);",
          "592:     zl[len-1] = ZIP_END;",
          "",
          "[Removed Lines]",
          "589: unsigned char *ziplistResize(unsigned char *zl, unsigned int len) {",
          "",
          "[Added Lines]",
          "600: unsigned char *ziplistResize(unsigned char *zl, size_t len) {",
          "601:     assert(len < UINT32_MAX);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "899:     zllength = zllength < UINT16_MAX ? zllength : UINT16_MAX;",
          "902:     size_t first_offset = intrev32ifbe(ZIPLIST_TAIL_OFFSET(*first));",
          "903:     size_t second_offset = intrev32ifbe(ZIPLIST_TAIL_OFFSET(*second));",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "914:     assert(zlbytes < UINT32_MAX);",
          "",
          "---------------"
        ],
        "src/ziplist.h||src/ziplist.h": [
          "File: src/ziplist.h -> src/ziplist.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "49: unsigned int ziplistLen(unsigned char *zl);",
          "50: size_t ziplistBlobLen(unsigned char *zl);",
          "51: void ziplistRepr(unsigned char *zl);",
          "53: #ifdef REDIS_TEST",
          "54: int ziplistTest(int argc, char *argv[]);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "52: int ziplistSafeToAdd(unsigned char* zl, size_t add);",
          "",
          "---------------"
        ],
        "tests/support/util.tcl||tests/support/util.tcl": [
          "File: tests/support/util.tcl -> tests/support/util.tcl",
          "--- Hunk 1 ---",
          "[Context before]",
          "110: # count current log lines in server's stdout",
          "111: proc count_log_lines {srv_idx} {",
          "113: }",
          "115: # verify pattern exists in server's sdtout after a certain line number",
          "",
          "[Removed Lines]",
          "112:     set _ [exec wc -l < [srv $srv_idx stdout]]",
          "",
          "[Added Lines]",
          "112:     set _ [string trim [exec wc -l < [srv $srv_idx stdout]]]",
          "113: }",
          "115: # returns the number of times a line with that pattern appears in a file",
          "116: proc count_message_lines {file pattern} {",
          "117:     set res 0",
          "118:     # exec fails when grep exists with status other than 0 (when the patter wasn't found)",
          "119:     catch {",
          "120:         set res [string trim [exec grep $pattern $file 2> /dev/null | wc -l]]",
          "121:     }",
          "122:     return $res",
          "123: }",
          "125: # returns the number of times a line with that pattern appears in the log",
          "126: proc count_log_message {srv_idx pattern} {",
          "127:     set stdout [srv $srv_idx stdout]",
          "128:     return [count_message_lines $stdout $pattern]",
          "",
          "---------------"
        ],
        "tests/unit/violations.tcl||tests/unit/violations.tcl": [
          "File: tests/unit/violations.tcl -> tests/unit/violations.tcl",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: # These tests consume massive amounts of memory, and are not",
          "2: # suitable to be executed as part of the normal test suite",
          "3: set ::str500 [string repeat x 500000000] ;# 500mb",
          "5: # Utility function to write big argument into redis client connection",
          "6: proc write_big_bulk {size} {",
          "7:     r write \"\\$$size\\r\\n\"",
          "8:     while {$size >= 500000000} {",
          "9:         r write $::str500",
          "10:         incr size -500000000",
          "11:     }",
          "12:     if {$size > 0} {",
          "13:         r write [string repeat x $size]",
          "14:     }",
          "15:     r write \"\\r\\n\"",
          "16: }",
          "18: # One XADD with one huge 5GB field",
          "19: # Expected to fail resulting in an empty stream",
          "20: start_server [list overrides [list save \"\"] ] {",
          "21:     test {XADD one huge field} {",
          "22:         r config set proto-max-bulk-len 10000000000 ;#10gb",
          "23:         r config set client-query-buffer-limit 10000000000 ;#10gb",
          "24:         r write \"*5\\r\\n\\$4\\r\\nXADD\\r\\n\\$2\\r\\nS1\\r\\n\\$1\\r\\n*\\r\\n\"",
          "25:         r write \"\\$1\\r\\nA\\r\\n\"",
          "26:         write_big_bulk 5000000000 ;#5gb",
          "27:         r flush",
          "28:         catch {r read} err",
          "29:         assert_match {*too large*} $err",
          "30:         r xlen S1",
          "31:     } {0}",
          "32: }",
          "34: # One XADD with one huge (exactly nearly) 4GB field",
          "35: # This uncovers the overflow in lpEncodeGetType",
          "36: # Expected to fail resulting in an empty stream",
          "37: start_server [list overrides [list save \"\"] ] {",
          "38:     test {XADD one huge field - 1} {",
          "39:         r config set proto-max-bulk-len 10000000000 ;#10gb",
          "40:         r config set client-query-buffer-limit 10000000000 ;#10gb",
          "41:         r write \"*5\\r\\n\\$4\\r\\nXADD\\r\\n\\$2\\r\\nS1\\r\\n\\$1\\r\\n*\\r\\n\"",
          "42:         r write \"\\$1\\r\\nA\\r\\n\"",
          "43:         write_big_bulk 4294967295 ;#4gb-1",
          "44:         r flush",
          "45:         catch {r read} err",
          "46:         assert_match {*too large*} $err",
          "47:         r xlen S1",
          "48:     } {0}",
          "49: }",
          "51: # Gradually add big stream fields using repeated XADD calls",
          "52: start_server [list overrides [list save \"\"] ] {",
          "53:     test {several XADD big fields} {",
          "54:         r config set stream-node-max-bytes 0",
          "55:         for {set j 0} {$j<10} {incr j} {",
          "56:             r xadd stream * 1 $::str500 2 $::str500",
          "57:         }",
          "58:         r ping",
          "59:         r xlen stream",
          "60:     } {10}",
          "61: }",
          "63: # Add over 4GB to a single stream listpack (one XADD command)",
          "64: # Expected to fail resulting in an empty stream",
          "65: start_server [list overrides [list save \"\"] ] {",
          "66:     test {single XADD big fields} {",
          "67:         r write \"*23\\r\\n\\$4\\r\\nXADD\\r\\n\\$1\\r\\nS\\r\\n\\$1\\r\\n*\\r\\n\"",
          "68:         for {set j 0} {$j<10} {incr j} {",
          "69:             r write \"\\$1\\r\\n$j\\r\\n\"",
          "70:             write_big_bulk 500000000 ;#500mb",
          "71:         }",
          "72:         r flush",
          "73:         catch {r read} err",
          "74:         assert_match {*too large*} $err",
          "75:         r xlen S",
          "76:     } {0}",
          "77: }",
          "79: # Gradually add big hash fields using repeated HSET calls",
          "80: # This reproduces the overflow in the call to ziplistResize",
          "81: # Object will be converted to hashtable encoding",
          "82: start_server [list overrides [list save \"\"] ] {",
          "83:     r config set hash-max-ziplist-value 1000000000 ;#1gb",
          "84:     test {hash with many big fields} {",
          "85:         for {set j 0} {$j<10} {incr j} {",
          "86:             r hset h $j $::str500",
          "87:         }",
          "88:         r object encoding h",
          "89:     } {hashtable}",
          "90: }",
          "92: # Add over 4GB to a single hash field (one HSET command)",
          "93: # Object will be converted to hashtable encoding",
          "94: start_server [list overrides [list save \"\"] ] {",
          "95:     test {hash with one huge field} {",
          "96:         catch {r config set hash-max-ziplist-value 10000000000} ;#10gb",
          "97:         r config set proto-max-bulk-len 10000000000 ;#10gb",
          "98:         r config set client-query-buffer-limit 10000000000 ;#10gb",
          "99:         r write \"*4\\r\\n\\$4\\r\\nHSET\\r\\n\\$2\\r\\nH1\\r\\n\"",
          "100:         r write \"\\$1\\r\\nA\\r\\n\"",
          "101:         write_big_bulk 5000000000 ;#5gb",
          "102:         r flush",
          "103:         r read",
          "104:         r object encoding H1",
          "105:     } {hashtable}",
          "106: }",
          "108: # Add over 4GB to a single list member (one LPUSH command)",
          "109: # Currently unsupported, and expected to fail rather than being truncated",
          "110: # Expected to fail resulting in a non-existing list",
          "111: start_server [list overrides [list save \"\"] ] {",
          "112:     test {list with one huge field} {",
          "113:         r config set proto-max-bulk-len 10000000000 ;#10gb",
          "114:         r config set client-query-buffer-limit 10000000000 ;#10gb",
          "115:         r write \"*3\\r\\n\\$5\\r\\nLPUSH\\r\\n\\$2\\r\\nL1\\r\\n\"",
          "116:         write_big_bulk 5000000000 ;#5gb",
          "117:         r flush",
          "118:         catch {r read} err",
          "119:         assert_match {*too large*} $err",
          "120:         r exists L1",
          "121:     } {0}",
          "122: }",
          "124: # SORT which attempts to store an element larger than 4GB into a list.",
          "125: # Currently unsupported and results in an assertion instead of truncation",
          "126: start_server [list overrides [list save \"\"] ] {",
          "127:     test {SORT adds huge field to list} {",
          "128:         r config set proto-max-bulk-len 10000000000 ;#10gb",
          "129:         r config set client-query-buffer-limit 10000000000 ;#10gb",
          "130:         r write \"*3\\r\\n\\$3\\r\\nSET\\r\\n\\$2\\r\\nS1\\r\\n\"",
          "131:         write_big_bulk 5000000000 ;#5gb",
          "132:         r flush",
          "133:         r read",
          "134:         assert_equal [r strlen S1] 5000000000",
          "135:         r set S2 asdf",
          "136:         r sadd myset 1 2",
          "137:         r mset D1 1 D2 2",
          "138:         catch {r sort myset by D* get S* store mylist}",
          "139:         # assert_equal [count_log_message 0 \"crashed by signal\"] 0   - not suitable for 6.0",
          "140:         assert_equal [count_log_message 0 \"ASSERTION FAILED\"] 1",
          "141:     }",
          "142: }",
          "144: # SORT which stores an integer encoded element into a list.",
          "145: # Just for coverage, no news here.",
          "146: start_server [list overrides [list save \"\"] ] {",
          "147:     test {SORT adds integer field to list} {",
          "148:         r set S1 asdf",
          "149:         r set S2 123 ;# integer encoded",
          "150:         assert_encoding \"int\" S2",
          "151:         r sadd myset 1 2",
          "152:         r mset D1 1 D2 2",
          "153:         r sort myset by D* get S* store mylist",
          "154:         r llen mylist",
          "155:     } {2}",
          "156: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "f621c0a4cbf6b69a674495eb3c0dd16fffeea902",
      "candidate_info": {
        "commit_hash": "f621c0a4cbf6b69a674495eb3c0dd16fffeea902",
        "repo": "redis/redis",
        "commit_url": "https://github.com/redis/redis/commit/f621c0a4cbf6b69a674495eb3c0dd16fffeea902",
        "files": [
          "src/scripting.c",
          "tests/unit/scripting.tcl"
        ],
        "message": "Fix protocol parsing on 'ldbReplParseCommand' (CVE-2021-32672)\n\nThe protocol parsing on 'ldbReplParseCommand' (LUA debugging)\nAssumed protocol correctness. This means that if the following\nis given:\n*1\n$100\ntest\nThe parser will try to read additional 94 unallocated bytes after\nthe client buffer.\nThis commit fixes this issue by validating that there are actually enough\nbytes to read. It also limits the amount of data that can be sent by\nthe debugger client to 1M so the client will not be able to explode\nthe memory.\n\n(cherry picked from commit 4f95e6809902665ced50646107d174dd8137bcaa)",
        "before_after_code_files": [
          "src/scripting.c||src/scripting.c",
          "tests/unit/scripting.tcl||tests/unit/scripting.tcl"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "src/scripting.c||src/scripting.c",
            "tests/unit/scripting.tcl||tests/unit/scripting.tcl"
          ],
          "candidate": [
            "src/scripting.c||src/scripting.c",
            "tests/unit/scripting.tcl||tests/unit/scripting.tcl"
          ]
        }
      },
      "candidate_diff": {
        "src/scripting.c||src/scripting.c": [
          "File: src/scripting.c -> src/scripting.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1833:     sds *argv = NULL;",
          "1834:     int argc = 0;",
          "1835:     if (sdslen(ldb.cbuf) == 0) return NULL;",
          "",
          "[Removed Lines]",
          "1832: sds *ldbReplParseCommand(int *argcp) {",
          "",
          "[Added Lines]",
          "1832: sds *ldbReplParseCommand(int *argcp, char** err) {",
          "1833:     static char* protocol_error = \"protocol error\";",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1847:     p = strchr(p,'*'); if (!p) goto protoerr;",
          "1852:     if (*argcp <= 0 || *argcp > 1024) goto protoerr;",
          "",
          "[Removed Lines]",
          "1849:     p = strstr(p,\"\\r\\n\"); if (!p) goto protoerr;",
          "",
          "[Added Lines]",
          "1850:     p = strstr(p,\"\\r\\n\"); if (!p) goto keep_reading;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1855:     argv = zmalloc(sizeof(sds)*(*argcp));",
          "1856:     argc = 0;",
          "1857:     while(argc < *argcp) {",
          "1858:         if (*p != '$') goto protoerr;",
          "1863:         if (slen <= 0 || slen > 1024) goto protoerr;",
          "1864:         argv[argc++] = sdsnewlen(p,slen);",
          "1866:         if (p[0] != '\\r' || p[1] != '\\n') goto protoerr;",
          "",
          "[Removed Lines]",
          "1860:         p = strstr(p,\"\\r\\n\"); if (!p) goto protoerr;",
          "",
          "[Added Lines]",
          "1860:         if (*p == '\\0') goto keep_reading;",
          "1864:         p = strstr(p,\"\\r\\n\"); if (!p) goto keep_reading;",
          "1868:         if ((size_t)(p + slen + 2 - copy) > sdslen(copy) ) goto keep_reading;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1870:     return argv;",
          "1872: protoerr:",
          "1873:     sdsfreesplitres(argv,argc);",
          "1874:     sdsfree(copy);",
          "1875:     return NULL;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1879: keep_reading:",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2292: int ldbRepl(lua_State *lua) {",
          "2293:     sds *argv;",
          "2294:     int argc;",
          "2298:     while(1) {",
          "2300:             char buf[1024];",
          "2301:             int nread = read(ldb.fd,buf,sizeof(buf));",
          "2302:             if (nread <= 0) {",
          "",
          "[Removed Lines]",
          "2299:         while((argv = ldbReplParseCommand(&argc)) == NULL) {",
          "",
          "[Added Lines]",
          "2302:     char* err = NULL;",
          "2307:         while((argv = ldbReplParseCommand(&argc, &err)) == NULL) {",
          "2309:             if (err) {",
          "2310:                 lua_pushstring(lua, err);",
          "2311:                 lua_error(lua);",
          "2312:             }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2307:                 return C_ERR;",
          "2308:             }",
          "2309:             ldb.cbuf = sdscatlen(ldb.cbuf,buf,nread);",
          "2310:         }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2325:             if (sdslen(ldb.cbuf) > 1<<20) {",
          "2326:                 sdsfree(ldb.cbuf);",
          "2327:                 ldb.cbuf = sdsempty();",
          "2328:                 lua_pushstring(lua, \"max client buffer reached\");",
          "2329:                 lua_error(lua);",
          "2330:             }",
          "",
          "---------------"
        ],
        "tests/unit/scripting.tcl||tests/unit/scripting.tcl": [
          "File: tests/unit/scripting.tcl -> tests/unit/scripting.tcl",
          "--- Hunk 1 ---",
          "[Context before]",
          "741:     }",
          "742: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "744: start_server {tags {\"scripting\"}} {",
          "745:     test {Test scripting debug protocol parsing} {",
          "746:         r script debug sync",
          "747:         r eval {return 'hello'} 0",
          "748:         catch {r 'hello\\0world'} e",
          "749:         assert_match {*Unknown Redis Lua debugger command*} $e",
          "750:         catch {r 'hello\\0'} e",
          "751:         assert_match {*Unknown Redis Lua debugger command*} $e",
          "752:         catch {r '\\0hello'} e",
          "753:         assert_match {*Unknown Redis Lua debugger command*} $e",
          "754:         catch {r '\\0hello\\0'} e",
          "755:         assert_match {*Unknown Redis Lua debugger command*} $e",
          "756:     }",
          "757: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "3e09be56a8a65ad2549452e5bf7a36eb991b8954",
      "candidate_info": {
        "commit_hash": "3e09be56a8a65ad2549452e5bf7a36eb991b8954",
        "repo": "redis/redis",
        "commit_url": "https://github.com/redis/redis/commit/3e09be56a8a65ad2549452e5bf7a36eb991b8954",
        "files": [
          "src/scripting.c",
          "tests/unit/scripting.tcl"
        ],
        "message": "Fix protocol parsing on 'ldbReplParseCommand' (CVE-2021-32672)\n\nThe protocol parsing on 'ldbReplParseCommand' (LUA debugging)\nAssumed protocol correctness. This means that if the following\nis given:\n*1\n$100\ntest\nThe parser will try to read additional 94 unallocated bytes after\nthe client buffer.\nThis commit fixes this issue by validating that there are actually enough\nbytes to read. It also limits the amount of data that can be sent by\nthe debugger client to 1M so the client will not be able to explode\nthe memory.",
        "before_after_code_files": [
          "src/scripting.c||src/scripting.c",
          "tests/unit/scripting.tcl||tests/unit/scripting.tcl"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "src/scripting.c||src/scripting.c",
            "tests/unit/scripting.tcl||tests/unit/scripting.tcl"
          ],
          "candidate": [
            "src/scripting.c||src/scripting.c",
            "tests/unit/scripting.tcl||tests/unit/scripting.tcl"
          ]
        }
      },
      "candidate_diff": {
        "src/scripting.c||src/scripting.c": [
          "File: src/scripting.c -> src/scripting.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2085:     sds *argv = NULL;",
          "2086:     int argc = 0;",
          "2087:     if (sdslen(ldb.cbuf) == 0) return NULL;",
          "",
          "[Removed Lines]",
          "2084: sds *ldbReplParseCommand(int *argcp) {",
          "",
          "[Added Lines]",
          "2084: sds *ldbReplParseCommand(int *argcp, char** err) {",
          "2085:     static char* protocol_error = \"protocol error\";",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2099:     p = strchr(p,'*'); if (!p) goto protoerr;",
          "2104:     if (*argcp <= 0 || *argcp > 1024) goto protoerr;",
          "",
          "[Removed Lines]",
          "2101:     p = strstr(p,\"\\r\\n\"); if (!p) goto protoerr;",
          "",
          "[Added Lines]",
          "2102:     p = strstr(p,\"\\r\\n\"); if (!p) goto keep_reading;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2107:     argv = zmalloc(sizeof(sds)*(*argcp));",
          "2108:     argc = 0;",
          "2109:     while(argc < *argcp) {",
          "2110:         if (*p != '$') goto protoerr;",
          "2115:         if (slen <= 0 || slen > 1024) goto protoerr;",
          "2116:         argv[argc++] = sdsnewlen(p,slen);",
          "2118:         if (p[0] != '\\r' || p[1] != '\\n') goto protoerr;",
          "",
          "[Removed Lines]",
          "2112:         p = strstr(p,\"\\r\\n\"); if (!p) goto protoerr;",
          "",
          "[Added Lines]",
          "2112:         if (*p == '\\0') goto keep_reading;",
          "2116:         p = strstr(p,\"\\r\\n\"); if (!p) goto keep_reading;",
          "2120:         if ((size_t)(p + slen + 2 - copy) > sdslen(copy) ) goto keep_reading;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2122:     return argv;",
          "2124: protoerr:",
          "2125:     sdsfreesplitres(argv,argc);",
          "2126:     sdsfree(copy);",
          "2127:     return NULL;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2131: keep_reading:",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2610: int ldbRepl(lua_State *lua) {",
          "2611:     sds *argv;",
          "2612:     int argc;",
          "2616:     while(1) {",
          "2618:             char buf[1024];",
          "2619:             int nread = connRead(ldb.conn,buf,sizeof(buf));",
          "2620:             if (nread <= 0) {",
          "",
          "[Removed Lines]",
          "2617:         while((argv = ldbReplParseCommand(&argc)) == NULL) {",
          "",
          "[Added Lines]",
          "2620:     char* err = NULL;",
          "2625:         while((argv = ldbReplParseCommand(&argc, &err)) == NULL) {",
          "2627:             if (err) {",
          "2628:                 lua_pushstring(lua, err);",
          "2629:                 lua_error(lua);",
          "2630:             }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2625:                 return C_ERR;",
          "2626:             }",
          "2627:             ldb.cbuf = sdscatlen(ldb.cbuf,buf,nread);",
          "2628:         }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2643:             if (sdslen(ldb.cbuf) > 1<<20) {",
          "2644:                 sdsfree(ldb.cbuf);",
          "2645:                 ldb.cbuf = sdsempty();",
          "2646:                 lua_pushstring(lua, \"max client buffer reached\");",
          "2647:                 lua_error(lua);",
          "2648:             }",
          "",
          "---------------"
        ],
        "tests/unit/scripting.tcl||tests/unit/scripting.tcl": [
          "File: tests/unit/scripting.tcl -> tests/unit/scripting.tcl",
          "--- Hunk 1 ---",
          "[Context before]",
          "923:     r eval {return 'hello'} 0",
          "924:     r eval {return 'hello'} 0",
          "925: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "927: start_server {tags {\"scripting needs:debug external:skip\"}} {",
          "928:     test {Test scripting debug protocol parsing} {",
          "929:         r script debug sync",
          "930:         r eval {return 'hello'} 0",
          "931:         catch {r 'hello\\0world'} e",
          "932:         assert_match {*Unknown Redis Lua debugger command*} $e",
          "933:         catch {r 'hello\\0'} e",
          "934:         assert_match {*Unknown Redis Lua debugger command*} $e",
          "935:         catch {r '\\0hello'} e",
          "936:         assert_match {*Unknown Redis Lua debugger command*} $e",
          "937:         catch {r '\\0hello\\0'} e",
          "938:         assert_match {*Unknown Redis Lua debugger command*} $e",
          "939:     }",
          "940: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b0ca3be2bba3092ec7cc18e1d87380b1af951d48",
      "candidate_info": {
        "commit_hash": "b0ca3be2bba3092ec7cc18e1d87380b1af951d48",
        "repo": "redis/redis",
        "commit_url": "https://github.com/redis/redis/commit/b0ca3be2bba3092ec7cc18e1d87380b1af951d48",
        "files": [
          "src/scripting.c",
          "tests/unit/scripting.tcl"
        ],
        "message": "Fix protocol parsing on 'ldbReplParseCommand' (CVE-2021-32672) (#9590)\n\nThe protocol parsing on 'ldbReplParseCommand' (LUA debugging)\nAssumed protocol correctness. This means that if the following\nis given:\n*1\n$100\ntest\nThe parser will try to read additional 94 unallocated bytes after\nthe client buffer.\nThis commit fixes this issue by validating that there are actually enough\nbytes to read. It also limits the amount of data that can be sent by\nthe debugger client to 1M so the client will not be able to explode\nthe memory.\n\nCo-authored-by: meir@redislabs.com <meir@redislabs.com>",
        "before_after_code_files": [
          "src/scripting.c||src/scripting.c",
          "tests/unit/scripting.tcl||tests/unit/scripting.tcl"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "diff_branch_olp_changes": 1,
        "olp_code_files": {
          "patch": [
            "src/scripting.c||src/scripting.c",
            "tests/unit/scripting.tcl||tests/unit/scripting.tcl"
          ],
          "candidate": [
            "src/scripting.c||src/scripting.c",
            "tests/unit/scripting.tcl||tests/unit/scripting.tcl"
          ]
        }
      },
      "candidate_diff": {
        "src/scripting.c||src/scripting.c": [
          "File: src/scripting.c -> src/scripting.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2247:     sds *argv = NULL;",
          "2248:     int argc = 0;",
          "2249:     if (sdslen(ldb.cbuf) == 0) return NULL;",
          "",
          "[Removed Lines]",
          "2246: sds *ldbReplParseCommand(int *argcp) {",
          "",
          "[Added Lines]",
          "2246: sds *ldbReplParseCommand(int *argcp, char** err) {",
          "2247:     static char* protocol_error = \"protocol error\";",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2261:     p = strchr(p,'*'); if (!p) goto protoerr;",
          "2266:     if (*argcp <= 0 || *argcp > 1024) goto protoerr;",
          "",
          "[Removed Lines]",
          "2263:     p = strstr(p,\"\\r\\n\"); if (!p) goto protoerr;",
          "",
          "[Added Lines]",
          "2264:     p = strstr(p,\"\\r\\n\"); if (!p) goto keep_reading;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2269:     argv = zmalloc(sizeof(sds)*(*argcp));",
          "2270:     argc = 0;",
          "2271:     while(argc < *argcp) {",
          "2272:         if (*p != '$') goto protoerr;",
          "2277:         if (slen <= 0 || slen > 1024) goto protoerr;",
          "2278:         argv[argc++] = sdsnewlen(p,slen);",
          "2280:         if (p[0] != '\\r' || p[1] != '\\n') goto protoerr;",
          "",
          "[Removed Lines]",
          "2274:         p = strstr(p,\"\\r\\n\"); if (!p) goto protoerr;",
          "",
          "[Added Lines]",
          "2274:         if (*p == '\\0') goto keep_reading;",
          "2278:         p = strstr(p,\"\\r\\n\"); if (!p) goto keep_reading;",
          "2282:         if ((size_t)(p + slen + 2 - copy) > sdslen(copy) ) goto keep_reading;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2284:     return argv;",
          "2286: protoerr:",
          "2287:     sdsfreesplitres(argv,argc);",
          "2288:     sdsfree(copy);",
          "2289:     return NULL;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2293: keep_reading:",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2772: int ldbRepl(lua_State *lua) {",
          "2773:     sds *argv;",
          "2774:     int argc;",
          "2778:     while(1) {",
          "2780:             char buf[1024];",
          "2781:             int nread = connRead(ldb.conn,buf,sizeof(buf));",
          "2782:             if (nread <= 0) {",
          "",
          "[Removed Lines]",
          "2779:         while((argv = ldbReplParseCommand(&argc)) == NULL) {",
          "",
          "[Added Lines]",
          "2782:     char* err = NULL;",
          "2787:         while((argv = ldbReplParseCommand(&argc, &err)) == NULL) {",
          "2789:             if (err) {",
          "2790:                 lua_pushstring(lua, err);",
          "2791:                 lua_error(lua);",
          "2792:             }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2787:                 return C_ERR;",
          "2788:             }",
          "2789:             ldb.cbuf = sdscatlen(ldb.cbuf,buf,nread);",
          "2790:         }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2805:             if (sdslen(ldb.cbuf) > 1<<20) {",
          "2806:                 sdsfree(ldb.cbuf);",
          "2807:                 ldb.cbuf = sdsempty();",
          "2808:                 lua_pushstring(lua, \"max client buffer reached\");",
          "2809:                 lua_error(lua);",
          "2810:             }",
          "",
          "---------------"
        ],
        "tests/unit/scripting.tcl||tests/unit/scripting.tcl": [
          "File: tests/unit/scripting.tcl -> tests/unit/scripting.tcl",
          "--- Hunk 1 ---",
          "[Context before]",
          "935:     r eval {return 'hello'} 0",
          "936: }",
          "938: start_server {tags {\"scripting resp3 needs:debug\"}} {",
          "939:     r debug set-disable-deny-scripts 1",
          "940:     for {set i 2} {$i <= 3} {incr i} {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "938: start_server {tags {\"scripting needs:debug external:skip\"}} {",
          "939:     test {Test scripting debug protocol parsing} {",
          "940:         r script debug sync",
          "941:         r eval {return 'hello'} 0",
          "942:         catch {r 'hello\\0world'} e",
          "943:         assert_match {*Unknown Redis Lua debugger command*} $e",
          "944:         catch {r 'hello\\0'} e",
          "945:         assert_match {*Unknown Redis Lua debugger command*} $e",
          "946:         catch {r '\\0hello'} e",
          "947:         assert_match {*Unknown Redis Lua debugger command*} $e",
          "948:         catch {r '\\0hello\\0'} e",
          "949:         assert_match {*Unknown Redis Lua debugger command*} $e",
          "950:     }",
          "951: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1046:     } {Some real reply following the attribute}",
          "1048:     r debug set-disable-deny-scripts 0",
          "",
          "[Removed Lines]",
          "1049: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2022-1205",
  "cve_desc": "A NULL pointer dereference flaw was found in the Linux kernel\u2019s Amateur Radio AX.25 protocol functionality in the way a user connects with the protocol. This flaw allows a local user to crash the system.",
  "repo": "torvalds/linux",
  "patch_hash": "fc6d01ff9ef03b66d4a3a23b46fc3c3d8cf92009",
  "patch_info": {
    "commit_hash": "fc6d01ff9ef03b66d4a3a23b46fc3c3d8cf92009",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/fc6d01ff9ef03b66d4a3a23b46fc3c3d8cf92009",
    "files": [
      "net/ax25/af_ax25.c",
      "net/ax25/ax25_subr.c"
    ],
    "message": "ax25: Fix NULL pointer dereferences in ax25 timers\n\nThe previous commit 7ec02f5ac8a5 (\"ax25: fix NPD bug in ax25_disconnect\")\nmove ax25_disconnect into lock_sock() in order to prevent NPD bugs. But\nthere are race conditions that may lead to null pointer dereferences in\nax25_heartbeat_expiry(), ax25_t1timer_expiry(), ax25_t2timer_expiry(),\nax25_t3timer_expiry() and ax25_idletimer_expiry(), when we use\nax25_kill_by_device() to detach the ax25 device.\n\nOne of the race conditions that cause null pointer dereferences can be\nshown as below:\n\n      (Thread 1)                    |      (Thread 2)\nax25_connect()                      |\n ax25_std_establish_data_link()     |\n  ax25_start_t1timer()              |\n   mod_timer(&ax25->t1timer,..)     |\n                                    | ax25_kill_by_device()\n   (wait a time)                    |  ...\n                                    |  s->ax25_dev = NULL; //(1)\n   ax25_t1timer_expiry()            |\n    ax25->ax25_dev->values[..] //(2)|  ...\n     ...                            |\n\nWe set null to ax25_cb->ax25_dev in position (1) and dereference\nthe null pointer in position (2).\n\nThe corresponding fail log is shown below:\n===============================================================\nBUG: kernel NULL pointer dereference, address: 0000000000000050\nCPU: 1 PID: 0 Comm: swapper/1 Not tainted 5.17.0-rc6-00794-g45690b7d0\nRIP: 0010:ax25_t1timer_expiry+0x12/0x40\n...\nCall Trace:\n call_timer_fn+0x21/0x120\n __run_timers.part.0+0x1ca/0x250\n run_timer_softirq+0x2c/0x60\n __do_softirq+0xef/0x2f3\n irq_exit_rcu+0xb6/0x100\n sysvec_apic_timer_interrupt+0xa2/0xd0\n...\n\nThis patch moves ax25_disconnect() before s->ax25_dev = NULL\nand uses del_timer_sync() to delete timers in ax25_disconnect().\nIf ax25_disconnect() is called by ax25_kill_by_device() or\nax25->ax25_dev is NULL, the reason in ax25_disconnect() will be\nequal to ENETUNREACH, it will wait all timers to stop before we\nset null to s->ax25_dev in ax25_kill_by_device().\n\nFixes: 7ec02f5ac8a5 (\"ax25: fix NPD bug in ax25_disconnect\")\nSigned-off-by: Duoming Zhou <duoming@zju.edu.cn>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
    "before_after_code_files": [
      "net/ax25/af_ax25.c||net/ax25/af_ax25.c",
      "net/ax25/ax25_subr.c||net/ax25/ax25_subr.c"
    ]
  },
  "patch_diff": {
    "net/ax25/af_ax25.c||net/ax25/af_ax25.c": [
      "File: net/ax25/af_ax25.c -> net/ax25/af_ax25.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "89:    sk = s->sk;",
      "90:    if (!sk) {",
      "91:     spin_unlock_bh(&ax25_list_lock);",
      "93:     ax25_disconnect(s, ENETUNREACH);",
      "94:     spin_lock_bh(&ax25_list_lock);",
      "95:     goto again;",
      "96:    }",
      "97:    sock_hold(sk);",
      "98:    spin_unlock_bh(&ax25_list_lock);",
      "99:    lock_sock(sk);",
      "100:    s->ax25_dev = NULL;",
      "101:    if (sk->sk_socket) {",
      "102:     dev_put_track(ax25_dev->dev, &ax25_dev->dev_tracker);",
      "103:     ax25_dev_put(ax25_dev);",
      "104:    }",
      "106:    release_sock(sk);",
      "107:    spin_lock_bh(&ax25_list_lock);",
      "108:    sock_put(sk);",
      "",
      "[Removed Lines]",
      "92:     s->ax25_dev = NULL;",
      "105:    ax25_disconnect(s, ENETUNREACH);",
      "",
      "[Added Lines]",
      "93:     s->ax25_dev = NULL;",
      "100:    ax25_disconnect(s, ENETUNREACH);",
      "",
      "---------------"
    ],
    "net/ax25/ax25_subr.c||net/ax25/ax25_subr.c": [
      "File: net/ax25/ax25_subr.c -> net/ax25/ax25_subr.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "261: {",
      "262:  ax25_clear_queues(ax25);",
      "271:  ax25->state = AX25_STATE_0;",
      "",
      "[Removed Lines]",
      "264:  if (!ax25->sk || !sock_flag(ax25->sk, SOCK_DESTROY))",
      "265:   ax25_stop_heartbeat(ax25);",
      "266:  ax25_stop_t1timer(ax25);",
      "267:  ax25_stop_t2timer(ax25);",
      "268:  ax25_stop_t3timer(ax25);",
      "269:  ax25_stop_idletimer(ax25);",
      "",
      "[Added Lines]",
      "264:  if (reason == ENETUNREACH) {",
      "265:   del_timer_sync(&ax25->timer);",
      "266:   del_timer_sync(&ax25->t1timer);",
      "267:   del_timer_sync(&ax25->t2timer);",
      "268:   del_timer_sync(&ax25->t3timer);",
      "269:   del_timer_sync(&ax25->idletimer);",
      "270:  } else {",
      "271:   if (!ax25->sk || !sock_flag(ax25->sk, SOCK_DESTROY))",
      "272:    ax25_stop_heartbeat(ax25);",
      "273:   ax25_stop_t1timer(ax25);",
      "274:   ax25_stop_t2timer(ax25);",
      "275:   ax25_stop_t3timer(ax25);",
      "276:   ax25_stop_idletimer(ax25);",
      "277:  }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "feef318c855a361a1eccd880f33e88c460eb63b4",
      "candidate_info": {
        "commit_hash": "feef318c855a361a1eccd880f33e88c460eb63b4",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/feef318c855a361a1eccd880f33e88c460eb63b4",
        "files": [
          "net/ax25/af_ax25.c"
        ],
        "message": "ax25: fix UAF bugs of net_device caused by rebinding operation\n\nThe ax25_kill_by_device() will set s->ax25_dev = NULL and\ncall ax25_disconnect() to change states of ax25_cb and\nsock, if we call ax25_bind() before ax25_kill_by_device().\n\nHowever, if we call ax25_bind() again between the window of\nax25_kill_by_device() and ax25_dev_device_down(), the values\nand states changed by ax25_kill_by_device() will be reassigned.\n\nFinally, ax25_dev_device_down() will deallocate net_device.\nIf we dereference net_device in syscall functions such as\nax25_release(), ax25_sendmsg(), ax25_getsockopt(), ax25_getname()\nand ax25_info_show(), a UAF bug will occur.\n\nOne of the possible race conditions is shown below:\n\n      (USE)                   |      (FREE)\nax25_bind()                   |\n                              |  ax25_kill_by_device()\nax25_bind()                   |\nax25_connect()                |    ...\n                              |  ax25_dev_device_down()\n                              |    ...\n                              |    dev_put_track(dev, ...) //FREE\nax25_release()                |    ...\n  ax25_send_control()         |\n    alloc_skb()      //USE    |\n\nthe corresponding fail log is shown below:\n===============================================================\nBUG: KASAN: use-after-free in ax25_send_control+0x43/0x210\n...\nCall Trace:\n  ...\n  ax25_send_control+0x43/0x210\n  ax25_release+0x2db/0x3b0\n  __sock_release+0x6d/0x120\n  sock_close+0xf/0x20\n  __fput+0x11f/0x420\n  ...\nAllocated by task 1283:\n  ...\n  __kasan_kmalloc+0x81/0xa0\n  alloc_netdev_mqs+0x5a/0x680\n  mkiss_open+0x6c/0x380\n  tty_ldisc_open+0x55/0x90\n  ...\nFreed by task 1969:\n  ...\n  kfree+0xa3/0x2c0\n  device_release+0x54/0xe0\n  kobject_put+0xa5/0x120\n  tty_ldisc_kill+0x3e/0x80\n  ...\n\nIn order to fix these UAF bugs caused by rebinding operation,\nthis patch adds dev_hold_track() into ax25_bind() and\ncorresponding dev_put_track() into ax25_kill_by_device().\n\nSigned-off-by: Duoming Zhou <duoming@zju.edu.cn>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "net/ax25/af_ax25.c||net/ax25/af_ax25.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "net/ax25/af_ax25.c||net/ax25/af_ax25.c"
          ],
          "candidate": [
            "net/ax25/af_ax25.c||net/ax25/af_ax25.c"
          ]
        }
      },
      "candidate_diff": {
        "net/ax25/af_ax25.c||net/ax25/af_ax25.c": [
          "File: net/ax25/af_ax25.c -> net/ax25/af_ax25.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "91:    spin_unlock_bh(&ax25_list_lock);",
          "92:    lock_sock(sk);",
          "93:    s->ax25_dev = NULL;",
          "94:    ax25_dev_put(ax25_dev);",
          "95:    ax25_disconnect(s, ENETUNREACH);",
          "96:    release_sock(sk);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "94:    dev_put_track(ax25_dev->dev, &ax25_dev->dev_tracker);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1116:   }",
          "1117:  }",
          "1120:   ax25_fillin_cb(ax25, ax25_dev);",
          "1122: done:",
          "1123:  ax25_cb_add(ax25);",
          "",
          "[Removed Lines]",
          "1119:  if (ax25_dev != NULL)",
          "",
          "[Added Lines]",
          "1120:  if (ax25_dev) {",
          "1122:   dev_hold_track(ax25_dev->dev, &ax25_dev->dev_tracker, GFP_ATOMIC);",
          "1123:  }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "71171ac8eb34ce7fe6b3267dce27c313ab3cb3ac",
      "candidate_info": {
        "commit_hash": "71171ac8eb34ce7fe6b3267dce27c313ab3cb3ac",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/71171ac8eb34ce7fe6b3267dce27c313ab3cb3ac",
        "files": [
          "net/ax25/af_ax25.c"
        ],
        "message": "ax25: Fix NULL pointer dereference in ax25_kill_by_device\n\nWhen two ax25 devices attempted to establish connection, the requester use ax25_create(),\nax25_bind() and ax25_connect() to initiate connection. The receiver use ax25_rcv() to\naccept connection and use ax25_create_cb() in ax25_rcv() to create ax25_cb, but the\nax25_cb->sk is NULL. When the receiver is detaching, a NULL pointer dereference bug\ncaused by sock_hold(sk) in ax25_kill_by_device() will happen. The corresponding\nfail log is shown below:\n\n===============================================================\nBUG: KASAN: null-ptr-deref in ax25_device_event+0xfd/0x290\nCall Trace:\n...\nax25_device_event+0xfd/0x290\nraw_notifier_call_chain+0x5e/0x70\ndev_close_many+0x174/0x220\nunregister_netdevice_many+0x1f7/0xa60\nunregister_netdevice_queue+0x12f/0x170\nunregister_netdev+0x13/0x20\nmkiss_close+0xcd/0x140\ntty_ldisc_release+0xc0/0x220\ntty_release_struct+0x17/0xa0\ntty_release+0x62d/0x670\n...\n\nThis patch add condition check in ax25_kill_by_device(). If s->sk is\nNULL, it will goto if branch to kill device.\n\nFixes: 4e0f718daf97 (\"ax25: improve the incomplete fix to avoid UAF and NPD bugs\")\nReported-by: Thomas Osterried <thomas@osterried.de>\nSigned-off-by: Duoming Zhou <duoming@zju.edu.cn>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "net/ax25/af_ax25.c||net/ax25/af_ax25.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "net/ax25/af_ax25.c||net/ax25/af_ax25.c"
          ],
          "candidate": [
            "net/ax25/af_ax25.c||net/ax25/af_ax25.c"
          ]
        }
      },
      "candidate_diff": {
        "net/ax25/af_ax25.c||net/ax25/af_ax25.c": [
          "File: net/ax25/af_ax25.c -> net/ax25/af_ax25.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "87:  ax25_for_each(s, &ax25_list) {",
          "88:   if (s->ax25_dev == ax25_dev) {",
          "89:    sk = s->sk;",
          "90:    sock_hold(sk);",
          "91:    spin_unlock_bh(&ax25_list_lock);",
          "92:    lock_sock(sk);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "90:    if (!sk) {",
          "91:     spin_unlock_bh(&ax25_list_lock);",
          "92:     s->ax25_dev = NULL;",
          "93:     ax25_disconnect(s, ENETUNREACH);",
          "94:     spin_lock_bh(&ax25_list_lock);",
          "95:     goto again;",
          "96:    }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "d01ffb9eee4af165d83b08dd73ebdf9fe94a519b",
      "candidate_info": {
        "commit_hash": "d01ffb9eee4af165d83b08dd73ebdf9fe94a519b",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/d01ffb9eee4af165d83b08dd73ebdf9fe94a519b",
        "files": [
          "include/net/ax25.h",
          "net/ax25/af_ax25.c",
          "net/ax25/ax25_dev.c",
          "net/ax25/ax25_route.c"
        ],
        "message": "ax25: add refcount in ax25_dev to avoid UAF bugs\n\nIf we dereference ax25_dev after we call kfree(ax25_dev) in\nax25_dev_device_down(), it will lead to concurrency UAF bugs.\nThere are eight syscall functions suffer from UAF bugs, include\nax25_bind(), ax25_release(), ax25_connect(), ax25_ioctl(),\nax25_getname(), ax25_sendmsg(), ax25_getsockopt() and\nax25_info_show().\n\nOne of the concurrency UAF can be shown as below:\n\n  (USE)                       |    (FREE)\n                              |  ax25_device_event\n                              |    ax25_dev_device_down\nax25_bind                     |    ...\n  ...                         |      kfree(ax25_dev)\n  ax25_fillin_cb()            |    ...\n    ax25_fillin_cb_from_dev() |\n  ...                         |\n\nThe root cause of UAF bugs is that kfree(ax25_dev) in\nax25_dev_device_down() is not protected by any locks.\nWhen ax25_dev, which there are still pointers point to,\nis released, the concurrency UAF bug will happen.\n\nThis patch introduces refcount into ax25_dev in order to\nguarantee that there are no pointers point to it when ax25_dev\nis released.\n\nSigned-off-by: Duoming Zhou <duoming@zju.edu.cn>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "include/net/ax25.h||include/net/ax25.h",
          "net/ax25/af_ax25.c||net/ax25/af_ax25.c",
          "net/ax25/ax25_dev.c||net/ax25/ax25_dev.c",
          "net/ax25/ax25_route.c||net/ax25/ax25_route.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "net/ax25/af_ax25.c||net/ax25/af_ax25.c"
          ],
          "candidate": [
            "net/ax25/af_ax25.c||net/ax25/af_ax25.c"
          ]
        }
      },
      "candidate_diff": {
        "include/net/ax25.h||include/net/ax25.h": [
          "File: include/net/ax25.h -> include/net/ax25.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "239: #if defined(CONFIG_AX25_DAMA_SLAVE) || defined(CONFIG_AX25_DAMA_MASTER)",
          "240:  ax25_dama_info  dama;",
          "241: #endif",
          "242: } ax25_dev;",
          "244: typedef struct ax25_cb {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "242:  refcount_t  refcount;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "293:  }",
          "294: }",
          "296: static inline __be16 ax25_type_trans(struct sk_buff *skb, struct net_device *dev)",
          "297: {",
          "298:  skb->dev      = dev;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "297: #define ax25_dev_hold(__ax25_dev) \\",
          "298:  refcount_inc(&((__ax25_dev)->refcount))",
          "300: static __inline__ void ax25_dev_put(ax25_dev *ax25_dev)",
          "301: {",
          "302:  if (refcount_dec_and_test(&ax25_dev->refcount)) {",
          "303:   kfree(ax25_dev);",
          "304:  }",
          "305: }",
          "",
          "---------------"
        ],
        "net/ax25/af_ax25.c||net/ax25/af_ax25.c": [
          "File: net/ax25/af_ax25.c -> net/ax25/af_ax25.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "91:    spin_unlock_bh(&ax25_list_lock);",
          "92:    lock_sock(sk);",
          "93:    s->ax25_dev = NULL;",
          "94:    release_sock(sk);",
          "95:    ax25_disconnect(s, ENETUNREACH);",
          "96:    spin_lock_bh(&ax25_list_lock);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "94:    ax25_dev_put(ax25_dev);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "439:    }",
          "441: out_put:",
          "442:  ax25_cb_put(ax25);",
          "443:  return ret;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "443:  ax25_dev_put(ax25_dev);",
          "",
          "---------------"
        ],
        "net/ax25/ax25_dev.c||net/ax25/ax25_dev.c": [
          "File: net/ax25/ax25_dev.c -> net/ax25/ax25_dev.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "37:  for (ax25_dev = ax25_dev_list; ax25_dev != NULL; ax25_dev = ax25_dev->next)",
          "38:   if (ax25cmp(addr, (const ax25_address *)ax25_dev->dev->dev_addr) == 0) {",
          "39:    res = ax25_dev;",
          "40:   }",
          "41:  spin_unlock_bh(&ax25_dev_lock);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "40:    ax25_dev_hold(ax25_dev);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "56:   return;",
          "57:  }",
          "59:  dev->ax25_ptr     = ax25_dev;",
          "60:  ax25_dev->dev     = dev;",
          "61:  dev_hold_track(dev, &ax25_dev->dev_tracker, GFP_ATOMIC);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "60:  refcount_set(&ax25_dev->refcount, 1);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "83:  spin_lock_bh(&ax25_dev_lock);",
          "84:  ax25_dev->next = ax25_dev_list;",
          "85:  ax25_dev_list  = ax25_dev;",
          "86:  spin_unlock_bh(&ax25_dev_lock);",
          "88:  ax25_register_dev_sysctl(ax25_dev);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "88:  ax25_dev_hold(ax25_dev);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "113:  if ((s = ax25_dev_list) == ax25_dev) {",
          "114:   ax25_dev_list = s->next;",
          "115:   spin_unlock_bh(&ax25_dev_lock);",
          "116:   dev->ax25_ptr = NULL;",
          "117:   dev_put_track(dev, &ax25_dev->dev_tracker);",
          "119:   return;",
          "120:  }",
          "122:  while (s != NULL && s->next != NULL) {",
          "123:   if (s->next == ax25_dev) {",
          "124:    s->next = ax25_dev->next;",
          "125:    spin_unlock_bh(&ax25_dev_lock);",
          "126:    dev->ax25_ptr = NULL;",
          "127:    dev_put_track(dev, &ax25_dev->dev_tracker);",
          "129:    return;",
          "130:   }",
          "",
          "[Removed Lines]",
          "118:   kfree(ax25_dev);",
          "128:    kfree(ax25_dev);",
          "",
          "[Added Lines]",
          "118:   ax25_dev_put(ax25_dev);",
          "122:   ax25_dev_put(ax25_dev);",
          "129:    ax25_dev_put(ax25_dev);",
          "133:    ax25_dev_put(ax25_dev);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "133:  }",
          "134:  spin_unlock_bh(&ax25_dev_lock);",
          "135:  dev->ax25_ptr = NULL;",
          "136: }",
          "138: int ax25_fwd_ioctl(unsigned int cmd, struct ax25_fwd_struct *fwd)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "141:  ax25_dev_put(ax25_dev);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "149:   if (ax25_dev->forward != NULL)",
          "150:    return -EINVAL;",
          "151:   ax25_dev->forward = fwd_dev->dev;",
          "152:   break;",
          "154:  case SIOCAX25DELFWD:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "158:   ax25_dev_put(fwd_dev);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "161:   return -EINVAL;",
          "162:  }",
          "164:  return 0;",
          "165: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "171:  ax25_dev_put(ax25_dev);",
          "",
          "---------------"
        ],
        "net/ax25/ax25_route.c||net/ax25/ax25_route.c": [
          "File: net/ax25/ax25_route.c -> net/ax25/ax25_route.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "116:  ax25_rt->dev          = ax25_dev->dev;",
          "117:  ax25_rt->digipeat     = NULL;",
          "118:  ax25_rt->ip_mode      = ' ';",
          "119:  if (route->digi_count != 0) {",
          "120:   if ((ax25_rt->digipeat = kmalloc(sizeof(ax25_digi), GFP_ATOMIC)) == NULL) {",
          "121:    write_unlock_bh(&ax25_route_lock);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "119:  ax25_dev_put(ax25_dev);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "172:    }",
          "173:   }",
          "174:  }",
          "175:  write_unlock_bh(&ax25_route_lock);",
          "177:  return 0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "176:  ax25_dev_put(ax25_dev);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "214:  }",
          "216: out:",
          "217:  write_unlock_bh(&ax25_route_lock);",
          "218:  return err;",
          "219: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "219:  ax25_dev_put(ax25_dev);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "9fd75b66b8f68498454d685dc4ba13192ae069b0",
      "candidate_info": {
        "commit_hash": "9fd75b66b8f68498454d685dc4ba13192ae069b0",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/9fd75b66b8f68498454d685dc4ba13192ae069b0",
        "files": [
          "net/ax25/af_ax25.c"
        ],
        "message": "ax25: Fix refcount leaks caused by ax25_cb_del()\n\nThe previous commit d01ffb9eee4a (\"ax25: add refcount in ax25_dev to\navoid UAF bugs\") and commit feef318c855a (\"ax25: fix UAF bugs of\nnet_device caused by rebinding operation\") increase the refcounts of\nax25_dev and net_device in ax25_bind() and decrease the matching refcounts\nin ax25_kill_by_device() in order to prevent UAF bugs, but there are\nreference count leaks.\n\nThe root cause of refcount leaks is shown below:\n\n     (Thread 1)                      |      (Thread 2)\nax25_bind()                          |\n ...                                 |\n ax25_addr_ax25dev()                 |\n  ax25_dev_hold()   //(1)            |\n  ...                                |\n dev_hold_track()   //(2)            |\n ...                                 | ax25_destroy_socket()\n                                     |  ax25_cb_del()\n                                     |   ...\n                                     |   hlist_del_init() //(3)\n                                     |\n                                     |\n     (Thread 3)                      |\nax25_kill_by_device()                |\n ...                                 |\n ax25_for_each(s, &ax25_list) {      |\n  if (s->ax25_dev == ax25_dev) //(4) |\n   ...                               |\n\nFirstly, we use ax25_bind() to increase the refcount of ax25_dev in\nposition (1) and increase the refcount of net_device in position (2).\nThen, we use ax25_cb_del() invoked by ax25_destroy_socket() to delete\nax25_cb in hlist in position (3) before calling ax25_kill_by_device().\nFinally, the decrements of refcounts in ax25_kill_by_device() will not\nbe executed, because no s->ax25_dev equals to ax25_dev in position (4).\n\nThis patch adds decrements of refcounts in ax25_release() and use\nlock_sock() to do synchronization. If refcounts decrease in ax25_release(),\nthe decrements of refcounts in ax25_kill_by_device() will not be\nexecuted and vice versa.\n\nFixes: d01ffb9eee4a (\"ax25: add refcount in ax25_dev to avoid UAF bugs\")\nFixes: 87563a043cef (\"ax25: fix reference count leaks of ax25_dev\")\nFixes: feef318c855a (\"ax25: fix UAF bugs of net_device caused by rebinding operation\")\nReported-by: Thomas Osterried <thomas@osterried.de>\nSigned-off-by: Duoming Zhou <duoming@zju.edu.cn>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "net/ax25/af_ax25.c||net/ax25/af_ax25.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "net/ax25/af_ax25.c||net/ax25/af_ax25.c"
          ],
          "candidate": [
            "net/ax25/af_ax25.c||net/ax25/af_ax25.c"
          ]
        }
      },
      "candidate_diff": {
        "net/ax25/af_ax25.c||net/ax25/af_ax25.c": [
          "File: net/ax25/af_ax25.c -> net/ax25/af_ax25.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "98:    spin_unlock_bh(&ax25_list_lock);",
          "99:    lock_sock(sk);",
          "100:    s->ax25_dev = NULL;",
          "103:    ax25_disconnect(s, ENETUNREACH);",
          "104:    release_sock(sk);",
          "105:    spin_lock_bh(&ax25_list_lock);",
          "",
          "[Removed Lines]",
          "101:    dev_put_track(ax25_dev->dev, &ax25_dev->dev_tracker);",
          "102:    ax25_dev_put(ax25_dev);",
          "",
          "[Added Lines]",
          "101:    if (sk->sk_socket) {",
          "102:     dev_put_track(ax25_dev->dev, &ax25_dev->dev_tracker);",
          "103:     ax25_dev_put(ax25_dev);",
          "104:    }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "979: {",
          "980:  struct sock *sk = sock->sk;",
          "981:  ax25_cb *ax25;",
          "983:  if (sk == NULL)",
          "984:   return 0;",
          "986:  sock_hold(sk);",
          "988:  lock_sock(sk);",
          "989:  ax25 = sk_to_ax25(sk);",
          "991:  if (sk->sk_type == SOCK_SEQPACKET) {",
          "992:   switch (ax25->state) {",
          "",
          "[Removed Lines]",
          "987:  sock_orphan(sk);",
          "",
          "[Added Lines]",
          "984:  ax25_dev *ax25_dev;",
          "991:  sock_orphan(sk);",
          "993:  ax25_dev = ax25->ax25_dev;",
          "994:  if (ax25_dev) {",
          "995:   dev_put_track(ax25_dev->dev, &ax25_dev->dev_tracker);",
          "996:   ax25_dev_put(ax25_dev);",
          "997:  }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "7d8a3a477b3e25ada8dc71d22048c2ea417209a0",
      "candidate_info": {
        "commit_hash": "7d8a3a477b3e25ada8dc71d22048c2ea417209a0",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/7d8a3a477b3e25ada8dc71d22048c2ea417209a0",
        "files": [
          "include/net/ax25.h",
          "net/ax25/af_ax25.c",
          "net/ax25/ax25_dev.c",
          "net/ax25/ax25_subr.c"
        ],
        "message": "ax25: Fix ax25 session cleanup problems\n\nThere are session cleanup problems in ax25_release() and\nax25_disconnect(). If we setup a session and then disconnect,\nthe disconnected session is still in \"LISTENING\" state that\nis shown below.\n\nActive AX.25 sockets\nDest       Source     Device  State        Vr/Vs    Send-Q  Recv-Q\nDL9SAU-4   DL9SAU-3   ???     LISTENING    000/000  0       0\nDL9SAU-3   DL9SAU-4   ???     LISTENING    000/000  0       0\n\nThe first reason is caused by del_timer_sync() in ax25_release().\nThe timers of ax25 are used for correct session cleanup. If we use\nax25_release() to close ax25 sessions and ax25_dev is not null,\nthe del_timer_sync() functions in ax25_release() will execute.\nAs a result, the sessions could not be cleaned up correctly,\nbecause the timers have stopped.\n\nIn order to solve this problem, this patch adds a device_up flag\nin ax25_dev in order to judge whether the device is up. If there\nare sessions to be cleaned up, the del_timer_sync() in\nax25_release() will not execute. What's more, we add ax25_cb_del()\nin ax25_kill_by_device(), because the timers have been stopped\nand there are no functions that could delete ax25_cb if we do not\ncall ax25_release(). Finally, we reorder the position of\nax25_list_lock in ax25_cb_del() in order to synchronize among\ndifferent functions that call ax25_cb_del().\n\nThe second reason is caused by improper check in ax25_disconnect().\nThe incoming ax25 sessions which ax25->sk is null will close\nheartbeat timer, because the check \"if(!ax25->sk || ..)\" is\nsatisfied. As a result, the session could not be cleaned up properly.\n\nIn order to solve this problem, this patch changes the improper\ncheck to \"if(ax25->sk && ..)\" in ax25_disconnect().\n\nWhat`s more, the ax25_disconnect() may be called twice, which is\nnot necessary. For example, ax25_kill_by_device() calls\nax25_disconnect() and sets ax25->state to AX25_STATE_0, but\nax25_release() calls ax25_disconnect() again.\n\nIn order to solve this problem, this patch add a check in\nax25_release(). If the flag of ax25->sk equals to SOCK_DEAD,\nthe ax25_disconnect() in ax25_release() should not be executed.\n\nFixes: 82e31755e55f (\"ax25: Fix UAF bugs in ax25 timers\")\nFixes: 8a367e74c012 (\"ax25: Fix segfault after sock connection timeout\")\nReported-and-tested-by: Thomas Osterried <thomas@osterried.de>\nSigned-off-by: Duoming Zhou <duoming@zju.edu.cn>\nLink: https://lore.kernel.org/r/20220530152158.108619-1-duoming@zju.edu.cn\nSigned-off-by: Paolo Abeni <pabeni@redhat.com>",
        "before_after_code_files": [
          "include/net/ax25.h||include/net/ax25.h",
          "net/ax25/af_ax25.c||net/ax25/af_ax25.c",
          "net/ax25/ax25_dev.c||net/ax25/ax25_dev.c",
          "net/ax25/ax25_subr.c||net/ax25/ax25_subr.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "net/ax25/af_ax25.c||net/ax25/af_ax25.c",
            "net/ax25/ax25_subr.c||net/ax25/ax25_subr.c"
          ],
          "candidate": [
            "net/ax25/af_ax25.c||net/ax25/af_ax25.c",
            "net/ax25/ax25_subr.c||net/ax25/ax25_subr.c"
          ]
        }
      },
      "candidate_diff": {
        "include/net/ax25.h||include/net/ax25.h": [
          "File: include/net/ax25.h -> include/net/ax25.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "228:  ax25_dama_info  dama;",
          "229: #endif",
          "230:  refcount_t  refcount;",
          "231: } ax25_dev;",
          "233: typedef struct ax25_cb {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "231:  bool device_up;",
          "",
          "---------------"
        ],
        "net/ax25/af_ax25.c||net/ax25/af_ax25.c": [
          "File: net/ax25/af_ax25.c -> net/ax25/af_ax25.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "63: static void ax25_cb_del(ax25_cb *ax25)",
          "64: {",
          "65:  if (!hlist_unhashed(&ax25->ax25_node)) {",
          "67:   hlist_del_init(&ax25->ax25_node);",
          "69:   ax25_cb_put(ax25);",
          "70:  }",
          "71: }",
          "",
          "[Removed Lines]",
          "66:   spin_lock_bh(&ax25_list_lock);",
          "68:   spin_unlock_bh(&ax25_list_lock);",
          "",
          "[Added Lines]",
          "65:  spin_lock_bh(&ax25_list_lock);",
          "70:  spin_unlock_bh(&ax25_list_lock);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "82:  if ((ax25_dev = ax25_dev_ax25dev(dev)) == NULL)",
          "83:   return;",
          "85:  spin_lock_bh(&ax25_list_lock);",
          "86: again:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "84:  ax25_dev->device_up = false;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "91:     spin_unlock_bh(&ax25_list_lock);",
          "92:     ax25_disconnect(s, ENETUNREACH);",
          "93:     s->ax25_dev = NULL;",
          "94:     spin_lock_bh(&ax25_list_lock);",
          "95:     goto again;",
          "96:    }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "95:     ax25_cb_del(s);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "103:     dev_put_track(ax25_dev->dev, &ax25_dev->dev_tracker);",
          "104:     ax25_dev_put(ax25_dev);",
          "105:    }",
          "106:    release_sock(sk);",
          "107:    spin_lock_bh(&ax25_list_lock);",
          "108:    sock_put(sk);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "108:    ax25_cb_del(s);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "995:  if (sk->sk_type == SOCK_SEQPACKET) {",
          "996:   switch (ax25->state) {",
          "997:   case AX25_STATE_0:",
          "1001:    ax25_destroy_socket(ax25);",
          "1002:    break;",
          "",
          "[Removed Lines]",
          "998:    release_sock(sk);",
          "999:    ax25_disconnect(ax25, 0);",
          "1000:    lock_sock(sk);",
          "",
          "[Added Lines]",
          "1001:    if (!sock_flag(ax25->sk, SOCK_DEAD)) {",
          "1002:     release_sock(sk);",
          "1003:     ax25_disconnect(ax25, 0);",
          "1004:     lock_sock(sk);",
          "1005:    }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1053:   ax25_destroy_socket(ax25);",
          "1054:  }",
          "1055:  if (ax25_dev) {",
          "1061:   dev_put_track(ax25_dev->dev, &ax25_dev->dev_tracker);",
          "1062:   ax25_dev_put(ax25_dev);",
          "1063:  }",
          "",
          "[Removed Lines]",
          "1056:   del_timer_sync(&ax25->timer);",
          "1057:   del_timer_sync(&ax25->t1timer);",
          "1058:   del_timer_sync(&ax25->t2timer);",
          "1059:   del_timer_sync(&ax25->t3timer);",
          "1060:   del_timer_sync(&ax25->idletimer);",
          "",
          "[Added Lines]",
          "1061:   if (!ax25_dev->device_up) {",
          "1062:    del_timer_sync(&ax25->timer);",
          "1063:    del_timer_sync(&ax25->t1timer);",
          "1064:    del_timer_sync(&ax25->t2timer);",
          "1065:    del_timer_sync(&ax25->t3timer);",
          "1066:    del_timer_sync(&ax25->idletimer);",
          "1067:   }",
          "",
          "---------------"
        ],
        "net/ax25/ax25_dev.c||net/ax25/ax25_dev.c": [
          "File: net/ax25/ax25_dev.c -> net/ax25/ax25_dev.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "62:  ax25_dev->dev     = dev;",
          "63:  dev_hold_track(dev, &ax25_dev->dev_tracker, GFP_ATOMIC);",
          "64:  ax25_dev->forward = NULL;",
          "66:  ax25_dev->values[AX25_VALUES_IPDEFMODE] = AX25_DEF_IPDEFMODE;",
          "67:  ax25_dev->values[AX25_VALUES_AXDEFMODE] = AX25_DEF_AXDEFMODE;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "65:  ax25_dev->device_up = true;",
          "",
          "---------------"
        ],
        "net/ax25/ax25_subr.c||net/ax25/ax25_subr.c": [
          "File: net/ax25/ax25_subr.c -> net/ax25/ax25_subr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "268:   del_timer_sync(&ax25->t3timer);",
          "269:   del_timer_sync(&ax25->idletimer);",
          "270:  } else {",
          "272:    ax25_stop_heartbeat(ax25);",
          "273:   ax25_stop_t1timer(ax25);",
          "274:   ax25_stop_t2timer(ax25);",
          "",
          "[Removed Lines]",
          "271:   if (!ax25->sk || !sock_flag(ax25->sk, SOCK_DESTROY))",
          "",
          "[Added Lines]",
          "271:   if (ax25->sk && !sock_flag(ax25->sk, SOCK_DESTROY))",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2017-5850",
  "cve_desc": "httpd in OpenBSD allows remote attackers to cause a denial of service (memory consumption) via a series of requests for a large file using an HTTP Range header.",
  "repo": "openbsd/src",
  "patch_hash": "142cfc82b932bc211218fbd7bdda8c7ce83f19df",
  "patch_info": {
    "commit_hash": "142cfc82b932bc211218fbd7bdda8c7ce83f19df",
    "repo": "openbsd/src",
    "commit_url": "https://github.com/openbsd/src/commit/142cfc82b932bc211218fbd7bdda8c7ce83f19df",
    "files": [
      "usr.sbin/httpd/httpd.h",
      "usr.sbin/httpd/server_file.c",
      "usr.sbin/httpd/server_http.c"
    ],
    "message": "Reimplement httpd's support for byte ranges.\n\nThe previous implementation loaded all the output into a single output\nbuffer and used its size to determine the Content-Length of the body.\n\nThe new implementation calculates the body length first and writes the\nindividual ranges in an async way using the bufferevent mechanism.\n\nThis prevents httpd from using too much memory and applies the\nwatermark and throttling mechanisms to range requests.\n\nProblem reported by Pierre Kim (pierre.kim.sec at gmail.com)\n\nOK benno@ sunil@",
    "before_after_code_files": [
      "usr.sbin/httpd/httpd.h||usr.sbin/httpd/httpd.h",
      "usr.sbin/httpd/server_file.c||usr.sbin/httpd/server_file.c",
      "usr.sbin/httpd/server_http.c||usr.sbin/httpd/server_http.c"
    ]
  },
  "patch_diff": {
    "usr.sbin/httpd/httpd.h||usr.sbin/httpd/httpd.h": [
      "File: usr.sbin/httpd/httpd.h -> usr.sbin/httpd/httpd.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "73: #define SERVER_MAX_PREFETCH 256",
      "74: #define SERVER_MIN_PREFETCHED 32",
      "75: #define SERVER_HSTS_DEFAULT_AGE 31536000",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "76: #define SERVER_MAX_RANGES 4",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "93:  TOREAD_HTTP_HEADER  = -2,",
      "94:  TOREAD_HTTP_CHUNK_LENGTH = -3,",
      "95:  TOREAD_HTTP_CHUNK_TRAILER = -4,",
      "97: };",
      "99: #if DEBUG",
      "",
      "[Removed Lines]",
      "96:  TOREAD_HTTP_NONE  = -5",
      "",
      "[Added Lines]",
      "97:  TOREAD_HTTP_NONE  = -5,",
      "98:  TOREAD_HTTP_RANGE  = TOREAD_HTTP_CHUNK_LENGTH",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "295:  int    headersdone;",
      "296: };",
      "298: struct client {",
      "299:  uint32_t   clt_id;",
      "300:  pid_t    clt_pid;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "300: struct range {",
      "301:  off_t start;",
      "302:  off_t end;",
      "303: };",
      "305: struct range_data {",
      "306:  struct range   range[SERVER_MAX_RANGES];",
      "307:  int    range_count;",
      "308:  int    range_index;",
      "309:  off_t    range_toread;",
      "312:  struct media_type *range_media;",
      "313:  size_t    range_total;",
      "314: };",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "313:  void   *clt_descreq;",
      "314:  void   *clt_descresp;",
      "315:  int    clt_sndbufsiz;",
      "317:  int    clt_fd;",
      "318:  struct tls  *clt_tls_ctx;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "334:  uint64_t   clt_boundary;",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "327:  int    clt_done;",
      "328:  int    clt_chunk;",
      "329:  int    clt_inflight;",
      "330:  struct fcgi_data  clt_fcgi;",
      "331:  char   *clt_remote_user;",
      "332:  struct evbuffer  *clt_srvevb;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "349:  struct range_data  clt_ranges;",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "602: void  server_read_httpcontent(struct bufferevent *, void *);",
      "603: void  server_read_httpchunks(struct bufferevent *, void *);",
      "604: int  server_writeheader_http(struct client *clt, struct kv *, void *);",
      "605: int  server_headers(struct client *, void *,",
      "606:      int (*)(struct client *, struct kv *, void *), void *);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "624: void  server_read_httprange(struct bufferevent *, void *);",
      "",
      "---------------"
    ],
    "usr.sbin/httpd/server_file.c||usr.sbin/httpd/server_file.c": [
      "File: usr.sbin/httpd/server_file.c -> usr.sbin/httpd/server_file.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "37: #define MINIMUM(a, b) (((a) < (b)) ? (a) : (b))",
      "38: #define MAXIMUM(a, b) (((a) > (b)) ? (a) : (b))",
      "46: int   server_file_access(struct httpd *, struct client *,",
      "47:       char *, size_t);",
      "",
      "[Removed Lines]",
      "39: #define MAX_RANGES 4",
      "41: struct range {",
      "42:  off_t start;",
      "43:  off_t end;",
      "44: };",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "55:       struct stat *);",
      "56: int   server_file_method(struct client *);",
      "57: int   parse_range_spec(char *, size_t, struct range *);",
      "61: int",
      "62: server_file_access(struct httpd *env, struct client *clt,",
      "",
      "[Removed Lines]",
      "58: struct range *parse_range(char *, size_t, int *);",
      "59: int   buffer_add_range(int, struct evbuffer *, struct range *);",
      "",
      "[Added Lines]",
      "52: int   parse_ranges(struct client *, char *, size_t);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "303:  struct http_descriptor *resp = clt->clt_descresp;",
      "304:  struct http_descriptor *desc = clt->clt_descreq;",
      "305:  struct media_type *media, multipart_media;",
      "306:  struct range  *range;",
      "309:  int    code = 500, fd = -1, i, nranges, ret;",
      "311:  char    content_range[64];",
      "312:  const char  *errstr = NULL;",
      "",
      "[Removed Lines]",
      "307:  struct evbuffer  *evb = NULL;",
      "308:  size_t    content_length;",
      "310:  uint32_t   boundary;",
      "",
      "[Added Lines]",
      "299:  struct range_data *r = &clt->clt_ranges;",
      "301:  size_t    content_length = 0;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "315:  if (desc->http_method != HTTP_METHOD_GET)",
      "316:   return server_file_request(env, clt, path, st);",
      "319:   code = 416;",
      "320:   (void)snprintf(content_range, sizeof(content_range),",
      "321:       \"bytes */%lld\", st->st_size);",
      "",
      "[Removed Lines]",
      "318:  if ((range = parse_range(range_str, st->st_size, &nranges)) == NULL) {",
      "",
      "[Added Lines]",
      "310:  if ((nranges = parse_ranges(clt, range_str, st->st_size)) < 1) {",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "328:   goto abort;",
      "330:  media = media_find_config(env, srv_conf, path);",
      "336:  if (nranges == 1) {",
      "337:   (void)snprintf(content_range, sizeof(content_range),",
      "338:       \"bytes %lld-%lld/%lld\", range->start, range->end,",
      "339:       st->st_size);",
      "",
      "[Removed Lines]",
      "331:  if ((evb = evbuffer_new()) == NULL) {",
      "332:   errstr = \"failed to allocate file buffer\";",
      "333:   goto abort;",
      "334:  }",
      "",
      "[Added Lines]",
      "323:  r->range_media = media;",
      "326:   range = &r->range[0];",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "341:       content_range) == NULL)",
      "342:    goto abort;",
      "348:  } else {",
      "365:        \"Content-Range: bytes %lld-%lld/%lld\\r\\n\\r\\n\",",
      "367:     goto abort;",
      "375:   }",
      "379:    goto abort;",
      "384:   (void)strlcpy(multipart_media.media_type, \"multipart\",",
      "385:       sizeof(multipart_media.media_type));",
      "386:   (void)snprintf(multipart_media.media_subtype,",
      "387:       sizeof(multipart_media.media_subtype),",
      "389:   media = &multipart_media;",
      "390:  }",
      "395:  ret = server_response_http(clt, 206, media, content_length,",
      "396:      MINIMUM(time(NULL), st->st_mtim.tv_sec));",
      "",
      "[Removed Lines]",
      "344:   content_length = range->end - range->start + 1;",
      "345:   if (buffer_add_range(fd, evb, range) == 0)",
      "346:    goto abort;",
      "349:   content_length = 0;",
      "350:   boundary = arc4random();",
      "352:   while (nranges--) {",
      "353:    if ((i = evbuffer_add_printf(evb, \"\\r\\n--%ud\\r\\n\",",
      "354:        boundary)) == -1)",
      "355:     goto abort;",
      "357:    content_length += i;",
      "358:    if ((i = evbuffer_add_printf(evb,",
      "359:        \"Content-Type: %s/%s\\r\\n\",",
      "360:        media->media_type, media->media_subtype)) == -1)",
      "361:     goto abort;",
      "363:    content_length += i;",
      "364:    if ((i = evbuffer_add_printf(evb,",
      "366:        range->start, range->end, st->st_size)) == -1)",
      "369:    content_length += i;",
      "370:    if (buffer_add_range(fd, evb, range) == 0)",
      "371:     goto abort;",
      "373:    content_length += range->end - range->start + 1;",
      "374:    range++;",
      "377:   if ((i = evbuffer_add_printf(evb, \"\\r\\n--%ud--\\r\\n\",",
      "378:       boundary)) == -1)",
      "381:   content_length += i;",
      "388:       \"byteranges; boundary=%ud\", boundary);",
      "392:  close(fd);",
      "393:  fd = -1;",
      "",
      "[Added Lines]",
      "334:   range = &r->range[0];",
      "335:   content_length += range->end - range->start + 1;",
      "338:   arc4random_buf(&clt->clt_boundary, sizeof(clt->clt_boundary));",
      "341:   for (i = 0; i < nranges; i++) {",
      "342:    range = &r->range[i];",
      "345:    if ((ret = snprintf(NULL, 0,",
      "346:        \"\\r\\n--%llu\\r\\n\"",
      "347:        \"Content-Type: %s/%s\\r\\n\"",
      "349:        clt->clt_boundary,",
      "350:        media->media_type, media->media_subtype,",
      "351:        range->start, range->end, st->st_size)) < 0)",
      "355:    content_length += ret + range->end - range->start + 1;",
      "358:   if ((ret = snprintf(NULL, 0, \"\\r\\n--%llu--\\r\\n\",",
      "359:       clt->clt_boundary)) < 0)",
      "361:   content_length += ret;",
      "368:       \"byteranges; boundary=%llu\", clt->clt_boundary);",
      "373:  r->range_toread = TOREAD_HTTP_RANGE;",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "399:   goto fail;",
      "400:  case 0:",
      "402:   goto done;",
      "403:  default:",
      "404:   break;",
      "405:  }",
      "408:   goto fail;",
      "417:  done:",
      "419:  server_reset_http(clt);",
      "420:  return (0);",
      "421:  fail:",
      "",
      "[Removed Lines]",
      "407:  if (server_bufferevent_write_buffer(clt, evb) == -1)",
      "410:  bufferevent_enable(clt->clt_bev, EV_READ|EV_WRITE);",
      "411:  if (clt->clt_persist)",
      "412:   clt->clt_toread = TOREAD_HTTP_HEADER;",
      "413:  else",
      "414:   clt->clt_toread = TOREAD_HTTP_NONE;",
      "415:  clt->clt_done = 0;",
      "418:  evbuffer_free(evb);",
      "",
      "[Added Lines]",
      "382:   close(fd);",
      "388:  clt->clt_fd = fd;",
      "389:  if (clt->clt_srvbev != NULL)",
      "390:   bufferevent_free(clt->clt_srvbev);",
      "392:  clt->clt_srvbev_throttled = 0;",
      "393:  clt->clt_srvbev = bufferevent_new(clt->clt_fd, server_read_httprange,",
      "394:      server_write, server_file_error, clt);",
      "395:  if (clt->clt_srvbev == NULL) {",
      "396:   errstr = \"failed to allocate file buffer event\";",
      "398:  }",
      "401:  bufferevent_setwatermark(clt->clt_srvbev, EV_READ, 0,",
      "402:      clt->clt_sndbufsiz);",
      "404:  bufferevent_settimeout(clt->clt_srvbev,",
      "405:      srv_conf->timeout.tv_sec, srv_conf->timeout.tv_sec);",
      "406:  bufferevent_enable(clt->clt_srvbev, EV_READ);",
      "407:  bufferevent_disable(clt->clt_bev, EV_READ);",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "423:  bufferevent_free(clt->clt_bev);",
      "424:  clt->clt_bev = NULL;",
      "425:  abort:",
      "428:  if (fd != -1)",
      "429:   close(fd);",
      "430:  if (errstr == NULL)",
      "",
      "[Removed Lines]",
      "426:  if (evb != NULL)",
      "427:   evbuffer_free(evb);",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "668:  return (-1);",
      "669: }",
      "673: {",
      "675:  int    i = 0;",
      "676:  char   *p, *q;",
      "679:  if ((p = strchr(str, '=')) == NULL)",
      "684:  if (strcmp(str, \"bytes\") != 0)",
      "687:  while ((q = strchr(p, ',')) != NULL) {",
      "692:    continue;",
      "694:   i++;",
      "698:   p = q;",
      "699:  }",
      "702:   i++;",
      "706: }",
      "708: int",
      "",
      "[Removed Lines]",
      "671: struct range *",
      "672: parse_range(char *str, size_t file_sz, int *nranges)",
      "674:  static struct range  ranges[MAX_RANGES];",
      "680:   return (NULL);",
      "685:   return (NULL);",
      "691:   if (parse_range_spec(p, file_sz, &ranges[i]) == 0)",
      "695:   if (i == MAX_RANGES)",
      "696:    return (NULL);",
      "701:  if (parse_range_spec(p, file_sz, &ranges[i]) != 0)",
      "705:  return (i ? ranges : NULL);",
      "",
      "[Added Lines]",
      "660: int",
      "661: parse_ranges(struct client *clt, char *str, size_t file_sz)",
      "665:  struct range_data *r = &clt->clt_ranges;",
      "667:  memset(r, 0, sizeof(*r));",
      "671:   return (-1);",
      "676:   return (-1);",
      "682:   if (parse_range_spec(p, file_sz, &r->range[i]) == 0)",
      "686:   if (i == SERVER_MAX_RANGES)",
      "687:    return (-1);",
      "692:  if (parse_range_spec(p, file_sz, &r->range[i]) != 0)",
      "695:  r->range_total = file_sz;",
      "696:  r->range_count = i;",
      "697:  return (i);",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "753:  return (1);",
      "754: }",
      "",
      "[Removed Lines]",
      "756: int",
      "757: buffer_add_range(int fd, struct evbuffer *evb, struct range *range)",
      "758: {",
      "759:  char buf[BUFSIZ];",
      "760:  size_t n, range_sz;",
      "761:  ssize_t nread;",
      "763:  if (lseek(fd, range->start, SEEK_SET) == -1)",
      "764:   return (0);",
      "766:  range_sz = range->end - range->start + 1;",
      "767:  while (range_sz) {",
      "768:   n = MINIMUM(range_sz, sizeof(buf));",
      "769:   if ((nread = read(fd, buf, n)) == -1)",
      "770:    return (0);",
      "772:   evbuffer_add(evb, buf, nread);",
      "773:   range_sz -= nread;",
      "774:  }",
      "776:  return (1);",
      "777: }",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "usr.sbin/httpd/server_http.c||usr.sbin/httpd/server_http.c": [
      "File: usr.sbin/httpd/server_http.c -> usr.sbin/httpd/server_http.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "609:  server_close(clt, strerror(errno));",
      "610: }",
      "612: void",
      "613: server_reset_http(struct client *clt)",
      "614: {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "612: void",
      "613: server_read_httprange(struct bufferevent *bev, void *arg)",
      "614: {",
      "615:  struct client  *clt = arg;",
      "616:  struct evbuffer  *src = EVBUFFER_INPUT(bev);",
      "617:  size_t    size;",
      "618:  struct media_type *media;",
      "619:  struct range_data *r = &clt->clt_ranges;",
      "620:  struct range  *range;",
      "622:  getmonotime(&clt->clt_tv_last);",
      "624:  if (r->range_toread > 0) {",
      "625:   size = EVBUFFER_LENGTH(src);",
      "626:   if (!size)",
      "627:    return;",
      "630:   if ((off_t)size > r->range_toread) {",
      "631:    size = r->range_toread;",
      "632:    if (server_bufferevent_write_chunk(clt, src, size)",
      "633:        == -1)",
      "634:     goto fail;",
      "635:    r->range_toread = 0;",
      "636:   } else {",
      "637:    if (server_bufferevent_write_buffer(clt, src) == -1)",
      "638:     goto fail;",
      "639:    r->range_toread -= size;",
      "640:   }",
      "641:   if (r->range_toread < 1)",
      "642:    r->range_toread = TOREAD_HTTP_RANGE;",
      "643:   DPRINTF(\"%s: done, size %lu, to read %lld\", __func__,",
      "644:       size, r->range_toread);",
      "645:  }",
      "647:  switch (r->range_toread) {",
      "648:  case TOREAD_HTTP_RANGE:",
      "649:   if (r->range_index >= r->range_count) {",
      "650:    if (r->range_count > 1) {",
      "652:     if (server_bufferevent_printf(clt,",
      "653:         \"\\r\\n--%llu--\\r\\n\",",
      "654:         clt->clt_boundary) == -1)",
      "655:      goto fail;",
      "656:    }",
      "657:    r->range_toread = TOREAD_HTTP_NONE;",
      "658:    break;",
      "659:   }",
      "661:   range = &r->range[r->range_index];",
      "663:   if (r->range_count > 1) {",
      "664:    media = r->range_media;",
      "665:    if (server_bufferevent_printf(clt,",
      "666:        \"\\r\\n--%llu\\r\\n\"",
      "667:        \"Content-Type: %s/%s\\r\\n\"",
      "668:        \"Content-Range: bytes %lld-%lld/%zu\\r\\n\\r\\n\",",
      "669:        clt->clt_boundary,",
      "670:        media->media_type, media->media_subtype,",
      "671:        range->start, range->end, r->range_total) == -1)",
      "672:     goto fail;",
      "673:   }",
      "674:   r->range_toread = range->end - range->start + 1;",
      "676:   if (lseek(clt->clt_fd, range->start, SEEK_SET) == -1)",
      "677:    goto fail;",
      "680:   evbuffer_drain(src, EVBUFFER_LENGTH(src));",
      "683:   r->range_index++;",
      "684:   break;",
      "685:  case TOREAD_HTTP_NONE:",
      "686:  case 0:",
      "687:   break;",
      "688:  }",
      "690:  if (clt->clt_done)",
      "691:   goto done;",
      "693:  if (EVBUFFER_LENGTH(EVBUFFER_OUTPUT(clt->clt_bev)) > (size_t)",
      "694:      SERVER_MAX_PREFETCH * clt->clt_sndbufsiz) {",
      "695:   bufferevent_disable(clt->clt_srvbev, EV_READ);",
      "696:   clt->clt_srvbev_throttled = 1;",
      "697:  }",
      "699:  return;",
      "700:  done:",
      "701:  (*bev->errorcb)(bev, EVBUFFER_READ, bev->cbarg);",
      "702:  return;",
      "703:  fail:",
      "704:  server_close(clt, strerror(errno));",
      "705: }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "f035d8b176d3bf6583027e90387021d1815ed61a",
      "candidate_info": {
        "commit_hash": "f035d8b176d3bf6583027e90387021d1815ed61a",
        "repo": "openbsd/src",
        "commit_url": "https://github.com/openbsd/src/commit/f035d8b176d3bf6583027e90387021d1815ed61a",
        "files": [
          "usr.sbin/httpd/server_file.c"
        ],
        "message": "Repair some file descriptor leaks. ok beck krw millert",
        "before_after_code_files": [
          "usr.sbin/httpd/server_file.c||usr.sbin/httpd/server_file.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "usr.sbin/httpd/server_file.c||usr.sbin/httpd/server_file.c"
          ],
          "candidate": [
            "usr.sbin/httpd/server_file.c||usr.sbin/httpd/server_file.c"
          ]
        }
      },
      "candidate_diff": {
        "usr.sbin/httpd/server_file.c||usr.sbin/httpd/server_file.c": [
          "File: usr.sbin/httpd/server_file.c -> usr.sbin/httpd/server_file.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "287:  bufferevent_free(clt->clt_bev);",
          "288:  clt->clt_bev = NULL;",
          "289:  abort:",
          "290:  if (errstr == NULL)",
          "291:   errstr = strerror(errno);",
          "292:  server_abort_http(clt, code, errstr);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "290:  if (fd != -1)",
          "291:   close(fd);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "387:   media = &multipart_media;",
          "388:  }",
          "390:  ret = server_response_http(clt, 206, media, content_length,",
          "391:      MINIMUM(time(NULL), st->st_mtim.tv_sec));",
          "392:  switch (ret) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "392:  close(fd);",
          "393:  fd = -1;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "394:   goto fail;",
          "395:  case 0:",
          "398:   evbuffer_free(evb);",
          "399:   evb = NULL;",
          "400:   goto done;",
          "",
          "[Removed Lines]",
          "397:   close(fd);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "423:  bufferevent_free(clt->clt_bev);",
          "424:  clt->clt_bev = NULL;",
          "425:  abort:",
          "426:  if (errstr == NULL)",
          "427:   errstr = strerror(errno);",
          "428:  server_abort_http(clt, code, errstr);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "430:  if (fd != -1)",
          "431:   close(fd);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
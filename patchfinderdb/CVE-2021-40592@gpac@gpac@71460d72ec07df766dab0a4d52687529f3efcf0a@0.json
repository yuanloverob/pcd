{
  "cve_id": "CVE-2021-40592",
  "cve_desc": "GPAC version before commit 71460d72ec07df766dab0a4d52687529f3efcf0a (version v1.0.1 onwards) contains loop with unreachable exit condition ('infinite loop') vulnerability in ISOBMFF reader filter, isoffin_read.c. Function isoffin_process() can result in DoS by infinite loop. To exploit, the victim must open a specially crafted mp4 file.",
  "repo": "gpac/gpac",
  "patch_hash": "71460d72ec07df766dab0a4d52687529f3efcf0a",
  "patch_info": {
    "commit_hash": "71460d72ec07df766dab0a4d52687529f3efcf0a",
    "repo": "gpac/gpac",
    "commit_url": "https://github.com/gpac/gpac/commit/71460d72ec07df766dab0a4d52687529f3efcf0a",
    "files": [
      "src/filters/isoffin_read.c",
      "src/filters/isoffin_read_ch.c"
    ],
    "message": "fixed #1876",
    "before_after_code_files": [
      "src/filters/isoffin_read.c||src/filters/isoffin_read.c",
      "src/filters/isoffin_read_ch.c||src/filters/isoffin_read_ch.c"
    ]
  },
  "patch_diff": {
    "src/filters/isoffin_read.c||src/filters/isoffin_read.c": [
      "File: src/filters/isoffin_read.c -> src/filters/isoffin_read.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1453:      gf_filter_pid_set_eos(ch->pid);",
      "1454:     }",
      "1455:     break;",
      "1456:    } else {",
      "1457:     read->force_fetch = GF_TRUE;",
      "1458:     break;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1456:    } else if (ch->last_state==GF_ISOM_INVALID_FILE) {",
      "1457:     if (!ch->eos_sent) {",
      "1458:      ch->eos_sent = GF_TRUE;",
      "1459:      read->eos_signaled = GF_TRUE;",
      "1460:      gf_filter_pid_set_eos(ch->pid);",
      "1461:     }",
      "1462:     return ch->last_state;",
      "",
      "---------------"
    ],
    "src/filters/isoffin_read_ch.c||src/filters/isoffin_read_ch.c": [
      "File: src/filters/isoffin_read_ch.c -> src/filters/isoffin_read_ch.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "479:     if (!ch->has_edit_list && ch->sample_num)",
      "480:      ch->sample_num--;",
      "481:    } else {",
      "482:     if (ch->sample_num >= gf_isom_get_sample_count(ch->owner->mov, ch->track)) {",
      "483:      ch->last_state = GF_EOS;",
      "484:     }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "482:     if (ch->to_init && ch->sample_num) {",
      "483:      GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[IsoMedia] Failed to fetch initial sample %d for track %d\\n\"));",
      "484:      ch->last_state = GF_ISOM_INVALID_FILE;",
      "485:     }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "9f8510835b97a729baf3646a3171bf51b4a8592e",
      "candidate_info": {
        "commit_hash": "9f8510835b97a729baf3646a3171bf51b4a8592e",
        "repo": "gpac/gpac",
        "commit_url": "https://github.com/gpac/gpac/commit/9f8510835b97a729baf3646a3171bf51b4a8592e",
        "files": [
          "src/filters/isoffin_read_ch.c",
          "src/media_tools/media_export.c",
          "src/scene_manager/scene_dump.c",
          "testsuite"
        ],
        "message": "fixed #2055",
        "before_after_code_files": [
          "src/filters/isoffin_read_ch.c||src/filters/isoffin_read_ch.c",
          "src/media_tools/media_export.c||src/media_tools/media_export.c",
          "src/scene_manager/scene_dump.c||src/scene_manager/scene_dump.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/filters/isoffin_read_ch.c||src/filters/isoffin_read_ch.c"
          ],
          "candidate": [
            "src/filters/isoffin_read_ch.c||src/filters/isoffin_read_ch.c"
          ]
        }
      },
      "candidate_diff": {
        "src/filters/isoffin_read_ch.c||src/filters/isoffin_read_ch.c": [
          "File: src/filters/isoffin_read_ch.c -> src/filters/isoffin_read_ch.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "480:      ch->sample_num--;",
          "481:    } else {",
          "482:     if (ch->to_init && ch->sample_num) {",
          "484:      ch->last_state = GF_ISOM_INVALID_FILE;",
          "487:      ch->last_state = GF_EOS;",
          "488:     }",
          "489:    }",
          "",
          "[Removed Lines]",
          "483:      GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[IsoMedia] Failed to fetch initial sample %d for track %d\\n\"));",
          "485:     }",
          "486:     if (ch->sample_num >= gf_isom_get_sample_count(ch->owner->mov, ch->track)) {",
          "",
          "[Added Lines]",
          "483:      GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[IsoMedia] Failed to fetch initial sample %d for track %d\\n\", ch->sample_num, ch->track));",
          "485:     } else {",
          "486:      GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[IsoMedia] File truncated, aborting read for track %d\\n\", ch->track));",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "507:   } else {",
          "508:    e = gf_isom_last_error(ch->owner->mov);",
          "509:    GF_LOG((e==GF_ISOM_INCOMPLETE_FILE) ? GF_LOG_DEBUG : GF_LOG_WARNING, GF_LOG_DASH, (\"[IsoMedia] Track #%d fail to fetch sample %d / %d: %s\\n\", ch->track, ch->sample_num, gf_isom_get_sample_count(ch->owner->mov, ch->track), gf_error_to_string(e) ));",
          "510:   }",
          "511:   return;",
          "512:  }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "511:    if ((e<GF_OK) && (e!=GF_ISOM_INCOMPLETE_FILE)) {",
          "512:     ch->last_state = GF_EOS;",
          "513:    }",
          "",
          "---------------"
        ],
        "src/media_tools/media_export.c||src/media_tools/media_export.c": [
          "File: src/media_tools/media_export.c -> src/media_tools/media_export.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1075:    GF_ISOSample *samp;",
          "1076:    if (safs[i].last_sample==safs[i].nb_samp) continue;",
          "1077:    samp = gf_isom_get_sample(dumper->file, safs[i].track_num, safs[i].last_sample + 1, &di);",
          "1078:    gf_saf_mux_add_au(mux, safs[i].stream_id, (u32) (samp->DTS+samp->CTS_Offset), samp->data, samp->dataLength, (samp->IsRAP==RAP) ? 1 : 0);",
          "1080:    gf_free(samp);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1078:    if (!samp) {",
          "1079:     gf_saf_mux_del(mux);",
          "1080:     return gf_isom_last_error(dumper->file);",
          "1081:    }",
          "",
          "---------------"
        ],
        "src/scene_manager/scene_dump.c||src/scene_manager/scene_dump.c": [
          "File: src/scene_manager/scene_dump.c -> src/scene_manager/scene_dump.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "939:   }",
          "941:   if (!sdump->XMLDump) gf_fprintf(sdump->trace, \"[\");",
          "946:   }",
          "947:   if (!sdump->XMLDump) gf_fprintf(sdump->trace, \"]\");",
          "",
          "[Removed Lines]",
          "942:   for (i=0; i<mffield->count; i++) {",
          "943:    if (i) gf_fprintf(sdump->trace, \" \");",
          "944:    gf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);",
          "945:    gf_dump_vrml_sffield(sdump, sf_type, slot_ptr, 1, node);",
          "",
          "[Added Lines]",
          "942:   if (mffield) {",
          "943:    for (i=0; i<mffield->count; i++) {",
          "944:     if (i) gf_fprintf(sdump->trace, \" \");",
          "945:     gf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);",
          "946:     gf_dump_vrml_sffield(sdump, sf_type, slot_ptr, 1, node);",
          "947:    }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1261:     } else {",
          "1262:      gf_fprintf(sdump->trace, \" %s=\\\"\", GetXMTFieldTypeValueName(field.fieldType));",
          "1263:     }",
          "1269:      }",
          "1270:     }",
          "1271:     gf_fprintf(sdump->trace, \"\\\"/>\\n\");",
          "",
          "[Removed Lines]",
          "1264:     for (i=0; i<mffield->count; i++) {",
          "1265:      if (i) gf_fprintf(sdump->trace, \" \");",
          "1266:      if (field.fieldType != GF_SG_VRML_MFNODE) {",
          "1267:       gf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);",
          "1268:       gf_dump_vrml_sffield(sdump, sf_type, slot_ptr, (mffield->count>1) ? 1 : 0, node);",
          "",
          "[Added Lines]",
          "1266:     if (mffield) {",
          "1267:      for (i=0; i<mffield->count; i++) {",
          "1268:       if (i) gf_fprintf(sdump->trace, \" \");",
          "1269:       if (field.fieldType != GF_SG_VRML_MFNODE) {",
          "1270:        gf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);",
          "1271:        gf_dump_vrml_sffield(sdump, sf_type, slot_ptr, (mffield->count>1) ? 1 : 0, node);",
          "1272:       }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2021-20298",
  "cve_desc": "A flaw was found in OpenEXR's B44Compressor. This flaw allows an attacker who can submit a crafted file to be processed by OpenEXR, to exhaust all memory accessible to the application. The highest threat from this vulnerability is to system availability.",
  "repo": "AcademySoftwareFoundation/openexr",
  "patch_hash": "85fd638ae0d5fa132434f4cbf32590261c1dba97",
  "patch_info": {
    "commit_hash": "85fd638ae0d5fa132434f4cbf32590261c1dba97",
    "repo": "AcademySoftwareFoundation/openexr",
    "commit_url": "https://github.com/AcademySoftwareFoundation/openexr/commit/85fd638ae0d5fa132434f4cbf32590261c1dba97",
    "files": [
      "OpenEXR/IlmImf/ImfB44Compressor.cpp"
    ],
    "message": "reduce B44 _tmpBufferSize (was allocating two bytes per byte) (#843)\n\nSigned-off-by: Peter Hillman <peterh@wetafx.co.nz>",
    "before_after_code_files": [
      "OpenEXR/IlmImf/ImfB44Compressor.cpp||OpenEXR/IlmImf/ImfB44Compressor.cpp"
    ]
  },
  "patch_diff": {
    "OpenEXR/IlmImf/ImfB44Compressor.cpp||OpenEXR/IlmImf/ImfB44Compressor.cpp": [
      "File: OpenEXR/IlmImf/ImfB44Compressor.cpp -> OpenEXR/IlmImf/ImfB44Compressor.cpp",
      "--- Hunk 1 ---",
      "[Context before]",
      "496:     _tmpBuffer = new unsigned short",
      "498:                          sizeof (unsigned short))];",
      "500:     const ChannelList &channels = header().channels();",
      "",
      "[Removed Lines]",
      "497:         [checkArraySize (uiMult (maxScanLineSize, numScanLines),",
      "",
      "[Added Lines]",
      "497:         [checkArraySize (uiMult (maxScanLineSize / sizeof(unsigned short), numScanLines),",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "0c2b46f630a3b5f2f561c2849d047ee39f899179",
      "candidate_info": {
        "commit_hash": "0c2b46f630a3b5f2f561c2849d047ee39f899179",
        "repo": "AcademySoftwareFoundation/openexr",
        "commit_url": "https://github.com/AcademySoftwareFoundation/openexr/commit/0c2b46f630a3b5f2f561c2849d047ee39f899179",
        "files": [
          "OpenEXR/IlmImf/ImfB44Compressor.cpp",
          "OpenEXR/IlmImf/ImfDeepImageStateAttribute.cpp",
          "OpenEXR/IlmImf/ImfDeepScanLineInputFile.cpp",
          "OpenEXR/IlmImf/ImfDeepTiledInputFile.cpp",
          "OpenEXR/IlmImf/ImfDwaCompressor.cpp",
          "OpenEXR/IlmImf/ImfEnvmapAttribute.cpp",
          "OpenEXR/IlmImf/ImfFastHuf.cpp",
          "OpenEXR/IlmImf/ImfHuf.cpp",
          "OpenEXR/IlmImf/ImfInputFile.cpp",
          "OpenEXR/IlmImf/ImfMultiPartInputFile.cpp",
          "OpenEXR/IlmImf/ImfPizCompressor.cpp",
          "OpenEXR/IlmImf/ImfRgbaFile.cpp",
          "OpenEXR/IlmImf/ImfScanLineInputFile.cpp",
          "OpenEXR/IlmImf/ImfTiledInputFile.cpp",
          "OpenEXR/IlmImf/ImfTiledMisc.cpp",
          "OpenEXR/IlmImf/ImfTiledOutputFile.cpp",
          "OpenEXR/IlmImfTest/testHuf.cpp",
          "OpenEXR/IlmImfTest/testScanLineApi.cpp",
          "OpenEXR/IlmImfTest/testYca.cpp",
          "OpenEXR/exrmaketiled/main.cpp"
        ],
        "message": "Cherry-pick PRs from master branch which fix issues reported by fuzz tests (#875)\n\n* ignore unused bits in B44 mode detection\n\nSigned-off-by: Peter Hillman <peterh@wetafx.co.nz>\n\n* apply #832: use unsigned values in shift to prevent undefined behavior\n\nSigned-off-by: Peter Hillman <peterh@wetafx.co.nz>\n\n* apply #818: compute Huf codelengths using 64 bit to prevent shift overflow\n\nSigned-off-by: Peter Hillman <peterh@wetafx.co.nz>\n\n* apply #817: double-check unpackedBuffer created in DWA uncompress\n\nSigned-off-by: Peter Hillman <peterh@wetafx.co.nz>\n\n* apply #820: suppress sanitizer warnings when writing invalid enums\n\nSigned-off-by: Peter Hillman <peterh@wetafx.co.nz>\n\n* apply #825: Avoid overflow in calculateNumTiles when size=MAX_INT\n\nSigned-off-by: Peter Hillman <peterh@wetafx.co.nz>\n\n* apply #826: restrict maximum tile size to INT_MAX byte limit\n\nSigned-off-by: Peter Hillman <peterh@wetafx.co.nz>\n\n* apply #827: lighter weight reading of Luma-only images via RgbaInputFile\n\nSigned-off-by: Peter Hillman <peterh@wetafx.co.nz>\n\n* refactor channel filling in InputFile API with tiled source\n\nSigned-off-by: Peter Hillman <peterh@wetafx.co.nz>\n\n* handle edge-case of empty framebuffer\n\nSigned-off-by: Peter Hillman <peterh@wetafx.co.nz>\n\n* apply #829: fix buffer overflow check in PIZ decompression\n\nSigned-off-by: Peter Hillman <peterh@wetafx.co.nz>\n\n* Use Int64 in dataWindowForTile to prevent integer overflow (#831)\n\n* Use Int64 in dataWindowForTile to prevent integer overflow\n\nSigned-off-by: Peter Hillman <peterh@wetafx.co.nz>\n\n* use signed 64 bit instead for dataWindow calculation\n\nSigned-off-by: Peter Hillman <peterh@wetafx.co.nz>\n\nCo-authored-by: Cary Phillips <cary@ilm.com>\nSigned-off-by: Peter Hillman <peterh@wetafx.co.nz>\n\n* prevent overflow in hufUncompress if nBits is large (#836)\n\nSigned-off-by: Peter Hillman <peterh@wetafx.co.nz>\n\n* add sanity check for reading multipart files with no parts (#840)\n\nSigned-off-by: Peter Hillman <peterh@wetafx.co.nz>\n\n* reduce B44 _tmpBufferSize (was allocating two bytes per byte) (#843)\n\nSigned-off-by: Peter Hillman <peterh@wetafx.co.nz>\n\n* check for valid Huf code lengths (#849)\n\n* check for valid Huf code lengths\n* test non-fast huf decoder in testHuf\n\nSigned-off-by: Peter Hillman <peterh@wetafx.co.nz>\n\n* check 1 part files with 'nonimage' bit have type attribute (#860)\n\nSigned-off-by: Peter Hillman <peterh@wetafx.co.nz>\n\nCo-authored-by: Cary Phillips <cary@ilm.com>\nSigned-off-by: Peter Hillman <peterh@wetafx.co.nz>\n\n* Fix overflow computing deeptile sample table size (#861)\n\n\nSigned-off-by: Peter Hillman <peterh@wetafx.co.nz>\n\n* re-order shift/compare in FastHuf to prevent undefined shift overflow warning (#819)\n\nSigned-off-by: Peter Hillman <peterh@wetafx.co.nz>\n\nCo-authored-by: Cary Phillips <cary@ilm.com>\nSigned-off-by: Peter Hillman <peterh@wetafx.co.nz>\n\n* more elegant exception handling in exrmaketiled (#841)\n\nSigned-off-by: Peter Hillman <peterh@wetafx.co.nz>\n\n* check EXRAllocAligned succeeded to allocate ScanlineInputFile lineBuffers (#844)\n\nSigned-off-by: Peter Hillman <peterh@wetafx.co.nz>\n\n* test channels are DCT compressed before DWA decompression (#845)\n\nSigned-off-by: Peter Hillman <peterh@wetafx.co.nz>\n\n* Merge ABI-compatible changes from #842\n\nSigned-off-by: Peter Hillman <peterh@wetafx.co.nz>\n\nCo-authored-by: Cary Phillips <cary@ilm.com>",
        "before_after_code_files": [
          "OpenEXR/IlmImf/ImfB44Compressor.cpp||OpenEXR/IlmImf/ImfB44Compressor.cpp",
          "OpenEXR/IlmImf/ImfDeepImageStateAttribute.cpp||OpenEXR/IlmImf/ImfDeepImageStateAttribute.cpp",
          "OpenEXR/IlmImf/ImfDeepScanLineInputFile.cpp||OpenEXR/IlmImf/ImfDeepScanLineInputFile.cpp",
          "OpenEXR/IlmImf/ImfDeepTiledInputFile.cpp||OpenEXR/IlmImf/ImfDeepTiledInputFile.cpp",
          "OpenEXR/IlmImf/ImfDwaCompressor.cpp||OpenEXR/IlmImf/ImfDwaCompressor.cpp",
          "OpenEXR/IlmImf/ImfEnvmapAttribute.cpp||OpenEXR/IlmImf/ImfEnvmapAttribute.cpp",
          "OpenEXR/IlmImf/ImfFastHuf.cpp||OpenEXR/IlmImf/ImfFastHuf.cpp",
          "OpenEXR/IlmImf/ImfHuf.cpp||OpenEXR/IlmImf/ImfHuf.cpp",
          "OpenEXR/IlmImf/ImfInputFile.cpp||OpenEXR/IlmImf/ImfInputFile.cpp",
          "OpenEXR/IlmImf/ImfMultiPartInputFile.cpp||OpenEXR/IlmImf/ImfMultiPartInputFile.cpp",
          "OpenEXR/IlmImf/ImfPizCompressor.cpp||OpenEXR/IlmImf/ImfPizCompressor.cpp",
          "OpenEXR/IlmImf/ImfRgbaFile.cpp||OpenEXR/IlmImf/ImfRgbaFile.cpp",
          "OpenEXR/IlmImf/ImfScanLineInputFile.cpp||OpenEXR/IlmImf/ImfScanLineInputFile.cpp",
          "OpenEXR/IlmImf/ImfTiledInputFile.cpp||OpenEXR/IlmImf/ImfTiledInputFile.cpp",
          "OpenEXR/IlmImf/ImfTiledMisc.cpp||OpenEXR/IlmImf/ImfTiledMisc.cpp",
          "OpenEXR/IlmImf/ImfTiledOutputFile.cpp||OpenEXR/IlmImf/ImfTiledOutputFile.cpp",
          "OpenEXR/IlmImfTest/testHuf.cpp||OpenEXR/IlmImfTest/testHuf.cpp",
          "OpenEXR/IlmImfTest/testScanLineApi.cpp||OpenEXR/IlmImfTest/testScanLineApi.cpp",
          "OpenEXR/IlmImfTest/testYca.cpp||OpenEXR/IlmImfTest/testYca.cpp",
          "OpenEXR/exrmaketiled/main.cpp||OpenEXR/exrmaketiled/main.cpp"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_olp_changes": 1,
        "olp_code_files": {
          "patch": [
            "OpenEXR/IlmImf/ImfB44Compressor.cpp||OpenEXR/IlmImf/ImfB44Compressor.cpp"
          ],
          "candidate": [
            "OpenEXR/IlmImf/ImfB44Compressor.cpp||OpenEXR/IlmImf/ImfB44Compressor.cpp"
          ]
        }
      },
      "candidate_diff": {
        "OpenEXR/IlmImf/ImfB44Compressor.cpp||OpenEXR/IlmImf/ImfB44Compressor.cpp": [
          "File: OpenEXR/IlmImf/ImfB44Compressor.cpp -> OpenEXR/IlmImf/ImfB44Compressor.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "381:     s[ 0] = (b[0] << 8) | b[1];",
          "383:     unsigned short shift = (b[ 2] >> 2);",
          "405:     for (int i = 0; i < 16; ++i)",
          "406:     {",
          "",
          "[Removed Lines]",
          "384:     unsigned short bias = (0x20 << shift);",
          "386:     s[ 4] = s[ 0] + ((((b[ 2] << 4) | (b[ 3] >> 4)) & 0x3f) << shift) - bias;",
          "387:     s[ 8] = s[ 4] + ((((b[ 3] << 2) | (b[ 4] >> 6)) & 0x3f) << shift) - bias;",
          "388:     s[12] = s[ 8] +   ((b[ 4]                       & 0x3f) << shift) - bias;",
          "390:     s[ 1] = s[ 0] +   ((b[ 5] >> 2)                         << shift) - bias;",
          "391:     s[ 5] = s[ 4] + ((((b[ 5] << 4) | (b[ 6] >> 4)) & 0x3f) << shift) - bias;",
          "392:     s[ 9] = s[ 8] + ((((b[ 6] << 2) | (b[ 7] >> 6)) & 0x3f) << shift) - bias;",
          "393:     s[13] = s[12] +   ((b[ 7]                       & 0x3f) << shift) - bias;",
          "395:     s[ 2] = s[ 1] +   ((b[ 8] >> 2)                         << shift) - bias;",
          "396:     s[ 6] = s[ 5] + ((((b[ 8] << 4) | (b[ 9] >> 4)) & 0x3f) << shift) - bias;",
          "397:     s[10] = s[ 9] + ((((b[ 9] << 2) | (b[10] >> 6)) & 0x3f) << shift) - bias;",
          "398:     s[14] = s[13] +   ((b[10]                       & 0x3f) << shift) - bias;",
          "400:     s[ 3] = s[ 2] +   ((b[11] >> 2)                         << shift) - bias;",
          "401:     s[ 7] = s[ 6] + ((((b[11] << 4) | (b[12] >> 4)) & 0x3f) << shift) - bias;",
          "402:     s[11] = s[10] + ((((b[12] << 2) | (b[13] >> 6)) & 0x3f) << shift) - bias;",
          "403:     s[15] = s[14] +   ((b[13]                       & 0x3f) << shift) - bias;",
          "",
          "[Added Lines]",
          "384:     unsigned short bias = (0x20u << shift);",
          "386:     s[ 4] = s[ 0] + ((((b[ 2] << 4) | (b[ 3] >> 4)) & 0x3fu) << shift) - bias;",
          "387:     s[ 8] = s[ 4] + ((((b[ 3] << 2) | (b[ 4] >> 6)) & 0x3fu) << shift) - bias;",
          "388:     s[12] = s[ 8] +   ((b[ 4]                       & 0x3fu) << shift) - bias;",
          "390:     s[ 1] = s[ 0] +   ((unsigned int) (b[ 5] >> 2)           << shift) - bias;",
          "391:     s[ 5] = s[ 4] + ((((b[ 5] << 4) | (b[ 6] >> 4)) & 0x3fu) << shift) - bias;",
          "392:     s[ 9] = s[ 8] + ((((b[ 6] << 2) | (b[ 7] >> 6)) & 0x3fu) << shift) - bias;",
          "393:     s[13] = s[12] +   ((b[ 7]                       & 0x3fu) << shift) - bias;",
          "395:     s[ 2] = s[ 1] +   ((unsigned int)(b[ 8] >> 2)            << shift) - bias;",
          "396:     s[ 6] = s[ 5] + ((((b[ 8] << 4) | (b[ 9] >> 4)) & 0x3fu) << shift) - bias;",
          "397:     s[10] = s[ 9] + ((((b[ 9] << 2) | (b[10] >> 6)) & 0x3fu) << shift) - bias;",
          "398:     s[14] = s[13] +   ((b[10]                       & 0x3fu) << shift) - bias;",
          "400:     s[ 3] = s[ 2] +   ((unsigned int)(b[11] >> 2)            << shift) - bias;",
          "401:     s[ 7] = s[ 6] + ((((b[11] << 4) | (b[12] >> 4)) & 0x3fu) << shift) - bias;",
          "402:     s[11] = s[10] + ((((b[12] << 2) | (b[13] >> 6)) & 0x3fu) << shift) - bias;",
          "403:     s[15] = s[14] +   ((b[13]                       & 0x3fu) << shift) - bias;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "496:     _tmpBuffer = new unsigned short",
          "498:                          sizeof (unsigned short))];",
          "500:     const ChannelList &channels = header().channels();",
          "",
          "[Removed Lines]",
          "497:         [checkArraySize (uiMult (maxScanLineSize, numScanLines),",
          "",
          "[Added Lines]",
          "497:         [checkArraySize (uiMult (maxScanLineSize / sizeof(unsigned short), numScanLines),",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "951:   if (inSize < 3)",
          "952:       notEnoughData();",
          "955:   {",
          "956:       unpack3 ((const unsigned char *)inPtr, s);",
          "957:       inPtr += 3;",
          "",
          "[Removed Lines]",
          "954:   if (((const unsigned char *)inPtr)[2] == 0xfc)",
          "",
          "[Added Lines]",
          "957:   if (((const unsigned char *)inPtr)[2] >= (13<<2) )",
          "",
          "---------------"
        ],
        "OpenEXR/IlmImf/ImfDeepImageStateAttribute.cpp||OpenEXR/IlmImf/ImfDeepImageStateAttribute.cpp": [
          "File: OpenEXR/IlmImf/ImfDeepImageStateAttribute.cpp -> OpenEXR/IlmImf/ImfDeepImageStateAttribute.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "58: void",
          "59: DeepImageStateAttribute::writeValueTo",
          "60:     (OPENEXR_IMF_INTERNAL_NAMESPACE::OStream &os, int version) const",
          "61: {",
          "62:     unsigned char tmp = _value;",
          "63:     Xdr::write <StreamIO> (os, tmp);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "61: #if defined (__clang__)",
          "65:     __attribute__((no_sanitize (\"undefined\")))",
          "66: #endif",
          "",
          "---------------"
        ],
        "OpenEXR/IlmImf/ImfDeepScanLineInputFile.cpp||OpenEXR/IlmImf/ImfDeepScanLineInputFile.cpp": [
          "File: OpenEXR/IlmImf/ImfDeepScanLineInputFile.cpp -> OpenEXR/IlmImf/ImfDeepScanLineInputFile.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "722:                     int width = (_ifd->maxX - _ifd->minX + 1);",
          "724:                     copyIntoDeepFrameBuffer (readPtr, slice.base,",
          "728:                                              sizeof(unsigned int) * 1,",
          "729:                                              sizeof(unsigned int) * width,",
          "730:                                              y, _ifd->minX, _ifd->maxX,",
          "",
          "[Removed Lines]",
          "725:                                              (char*) (&_ifd->sampleCount[0][0]",
          "726:                                                       - _ifd->minX",
          "727:                                                       - _ifd->minY * width),",
          "",
          "[Added Lines]",
          "724:                     ptrdiff_t base = reinterpret_cast<ptrdiff_t>(&_ifd->sampleCount[0][0]);",
          "725:                     base -= sizeof(unsigned int)*_ifd->minX;",
          "726:                     base -= sizeof(unsigned int)*static_cast<ptrdiff_t>(_ifd->minY) * static_cast<ptrdiff_t>(width);",
          "729:                                              reinterpret_cast<char*>(base),",
          "",
          "---------------"
        ],
        "OpenEXR/IlmImf/ImfDeepTiledInputFile.cpp||OpenEXR/IlmImf/ImfDeepTiledInputFile.cpp": [
          "File: OpenEXR/IlmImf/ImfDeepTiledInputFile.cpp -> OpenEXR/IlmImf/ImfDeepTiledInputFile.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "990:     for (size_t i = 0; i < _data->tileBuffers.size(); i++)",
          "991:         _data->tileBuffers[i] = new TileBuffer ();",
          "995:                                      sizeof(int);",
          "997:     _data->sampleCountTableBuffer.resizeErase(_data->maxSampleCountTableSize);",
          "",
          "[Removed Lines]",
          "993:     _data->maxSampleCountTableSize = _data->tileDesc.ySize *",
          "994:                                      _data->tileDesc.xSize *",
          "",
          "[Added Lines]",
          "993:     _data->maxSampleCountTableSize = static_cast<size_t>(_data->tileDesc.ySize) *",
          "994:                                      static_cast<size_t>(_data->tileDesc.xSize) *",
          "",
          "---------------"
        ],
        "OpenEXR/IlmImf/ImfDwaCompressor.cpp||OpenEXR/IlmImf/ImfDwaCompressor.cpp": [
          "File: OpenEXR/IlmImf/ImfDwaCompressor.cpp -> OpenEXR/IlmImf/ImfDwaCompressor.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "2536:     if (acCompressedSize > 0)",
          "2537:     {",
          "2539:         {",
          "2540:             throw IEX_NAMESPACE::InputExc(\"Error uncompressing DWA data\"",
          "2541:                                 \"(corrupt header).\");",
          "",
          "[Removed Lines]",
          "2538:         if (totalAcUncompressedCount*sizeof(unsigned short) > _packedAcBufferSize)",
          "",
          "[Added Lines]",
          "2538:         if ( !_packedAcBuffer || totalAcUncompressedCount*sizeof(unsigned short) > _packedAcBufferSize)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2681:         int gChan = _cscSets[csc].idx[1];",
          "2682:         int bChan = _cscSets[csc].idx[2];",
          "2685:         LossyDctDecoderCsc decoder",
          "2686:             (rowPtrs[rChan],",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2684:         if (_channelData[rChan].compression != LOSSY_DCT || _channelData[gChan].compression != LOSSY_DCT || _channelData[bChan].compression != LOSSY_DCT)",
          "2685:         {",
          "2686:             throw IEX_NAMESPACE::BaseExc(\"Bad DWA compression type detected\");",
          "2687:         }",
          "",
          "---------------"
        ],
        "OpenEXR/IlmImf/ImfEnvmapAttribute.cpp||OpenEXR/IlmImf/ImfEnvmapAttribute.cpp": [
          "File: OpenEXR/IlmImf/ImfEnvmapAttribute.cpp -> OpenEXR/IlmImf/ImfEnvmapAttribute.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "57: template <>",
          "58: void",
          "59: EnvmapAttribute::writeValueTo (OPENEXR_IMF_INTERNAL_NAMESPACE::OStream &os, int version) const",
          "60: {",
          "61:     unsigned char tmp = _value;",
          "62:     Xdr::write <StreamIO> (os, tmp);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "60: #if defined (__clang__)",
          "64:     __attribute__((no_sanitize (\"undefined\")))",
          "65: #endif",
          "",
          "---------------"
        ],
        "OpenEXR/IlmImf/ImfFastHuf.cpp||OpenEXR/IlmImf/ImfFastHuf.cpp": [
          "File: OpenEXR/IlmImf/ImfFastHuf.cpp -> OpenEXR/IlmImf/ImfFastHuf.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "128:     for (Int64 symbol = static_cast<Int64>(minSymbol); symbol <= static_cast<Int64>(maxSymbol); symbol++)",
          "129:     {",
          "131:         {",
          "132:             throw IEX_NAMESPACE::InputExc (\"Error decoding Huffman table \"",
          "133:                                            \"(Truncated table data).\");",
          "",
          "[Removed Lines]",
          "130:         if (currByte - table > numBytes)",
          "",
          "[Added Lines]",
          "130:         if (currByte - table >= numBytes)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "145:         if (codeLen == (Int64) LONG_ZEROCODE_RUN)",
          "146:         {",
          "148:             {",
          "149:                 throw IEX_NAMESPACE::InputExc (\"Error decoding Huffman table \"",
          "150:                                                \"(Truncated table data).\");",
          "",
          "[Removed Lines]",
          "147:             if (currByte - table > numBytes)",
          "",
          "[Added Lines]",
          "147:             if (currByte - table >= numBytes)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "205:         for (int l = _minCodeLength; l <= _maxCodeLength; ++l)",
          "206:         {",
          "207:             countTmp[l] = (double)codeCount[l] *",
          "209:         }",
          "211:         for (int l = _minCodeLength; l <= _maxCodeLength; ++l)",
          "",
          "[Removed Lines]",
          "208:                           (double)(2 << (_maxCodeLength-l));",
          "",
          "[Added Lines]",
          "208:                           (double)(2ll << (_maxCodeLength-l));",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "215:             for (int k =l + 1; k <= _maxCodeLength; ++k)",
          "216:                 tmp += countTmp[k];",
          "220:             base[l] = (Int64)ceil (tmp);",
          "221:         }",
          "",
          "[Removed Lines]",
          "218:             tmp /= (double)(2 << (_maxCodeLength - l));",
          "",
          "[Added Lines]",
          "218:             tmp /= (double)(2ll << (_maxCodeLength - l));",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "539:         buffer |= bufferBack >> (64 - numBits);",
          "540:     }",
          "552:         bufferBack = 0;",
          "553: }",
          "",
          "[Removed Lines]",
          "542:     bufferBack         = bufferBack << numBits;",
          "543:     bufferBackNumBits -= numBits;",
          "551:     if (bufferBackNumBits == 0)",
          "",
          "[Added Lines]",
          "549:     if (bufferBackNumBits <= numBits)",
          "550:     {",
          "552:     }else",
          "553:     {",
          "554:         bufferBack = bufferBack << numBits;",
          "555:     }",
          "556:     bufferBackNumBits -= numBits;",
          "",
          "---------------"
        ],
        "OpenEXR/IlmImf/ImfHuf.cpp||OpenEXR/IlmImf/ImfHuf.cpp": [
          "File: OpenEXR/IlmImf/ImfHuf.cpp -> OpenEXR/IlmImf/ImfHuf.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "912:   lc -= pl.len;",
          "913:   getCode (pl.lit, rlc, c, lc, in, out, outb, oe);",
          "914:      }",
          "915:      else",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "914:   if ( lc < 0 )",
          "915:   {",
          "916:    invalidCode(); // code length too long",
          "917:   }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "967:  if (pl.len)",
          "968:  {",
          "969:      lc -= pl.len;",
          "970:      getCode (pl.lit, rlc, c, lc, in, out, outb, oe);",
          "971:  }",
          "972:  else",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "975:             if ( lc < 0 )",
          "976:             {",
          "977:             invalidCode(); // code length too long",
          "978:             }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1094:     const char *ptr = compressed + 20;",
          "1097:     {",
          "1098:         notEnoughData();",
          "1099:         return;",
          "",
          "[Removed Lines]",
          "1096:     if ( ptr + (nBits+7 )/8 > compressed+nCompressed)",
          "",
          "[Added Lines]",
          "1105:     uint64_t nBytes = (static_cast<uint64_t>(nBits)+7) / 8 ;",
          "1107:     if ( ptr + nBytes > compressed+nCompressed)",
          "",
          "---------------"
        ],
        "OpenEXR/IlmImf/ImfInputFile.cpp||OpenEXR/IlmImf/ImfInputFile.cpp": [
          "File: OpenEXR/IlmImf/ImfInputFile.cpp -> OpenEXR/IlmImf/ImfInputFile.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "284:             ifd->cachedTileY = j;",
          "285:         }",
          "",
          "[Removed Lines]",
          "283:             ifd->tFile->readTiles (0, ifd->tFile->numXTiles (0) - 1, j, j);",
          "",
          "[Added Lines]",
          "284:             if (ifd->cachedBuffer && ifd->cachedBuffer->begin() != ifd->cachedBuffer->end())",
          "285:             {",
          "286:                 ifd->tFile->readTiles (0, ifd->tFile->numXTiles (0) - 1, j, j);",
          "287:             }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "294:              ++k)",
          "295:         {",
          "314:             {",
          "335:                 {",
          "341:                 }",
          "342:             }",
          "343:         }",
          "",
          "[Removed Lines]",
          "292:         for (FrameBuffer::ConstIterator k = ifd->cachedBuffer->begin();",
          "293:              k != ifd->cachedBuffer->end();",
          "296:             Slice fromSlice = k.slice();  // slice to write from",
          "297:             Slice toSlice = ifd->tFileBuffer[k.name()]; // slice to write to",
          "299:             char *fromPtr, *toPtr;",
          "300:             int size = pixelTypeSize (toSlice.type);",
          "302:      int xStart = levelRange.min.x;",
          "303:      int yStart = minYThisRow;",
          "305:      while (modp (xStart, toSlice.xSampling) != 0)",
          "306:   ++xStart;",
          "308:      while (modp (yStart, toSlice.ySampling) != 0)",
          "309:   ++yStart;",
          "311:             for (int y = yStart;",
          "312:    y <= maxYThisRow;",
          "313:    y += toSlice.ySampling)",
          "320:                 fromPtr = fromSlice.base +",
          "321:                           (y - tileRange.min.y) * fromSlice.yStride +",
          "322:                           xStart * fromSlice.xStride;",
          "324:                 toPtr = toSlice.base +",
          "325:                         divp (y, toSlice.ySampling) * toSlice.yStride +",
          "326:                         divp (xStart, toSlice.xSampling) * toSlice.xStride;",
          "332:                 for (int x = xStart;",
          "333:        x <= levelRange.max.x;",
          "334:        x += toSlice.xSampling)",
          "336:       for (int i = 0; i < size; ++i)",
          "337:    toPtr[i] = fromPtr[i];",
          "339:       fromPtr += fromSlice.xStride * toSlice.xSampling;",
          "340:       toPtr += toSlice.xStride;",
          "",
          "[Added Lines]",
          "297:         for (FrameBuffer::ConstIterator k = ifd->tFileBuffer.begin();",
          "298:              k != ifd->tFileBuffer.end();",
          "303:             Slice toSlice = k.slice();  // slice to read from",
          "304:             char* toPtr;",
          "306:             int xStart = levelRange.min.x;",
          "307:             int yStart = minYThisRow;",
          "309:             while (modp (xStart, toSlice.xSampling) != 0)",
          "310:                 ++xStart;",
          "312:             while (modp (yStart, toSlice.ySampling) != 0)",
          "313:                 ++yStart;",
          "315:             FrameBuffer::ConstIterator c = ifd->cachedBuffer->find(k.name());",
          "318:             if( c!=ifd->cachedBuffer->end())",
          "323:                 Slice fromSlice = c.slice(); // slice to write to",
          "325:                 int size = pixelTypeSize (toSlice.type);",
          "326:                 char* fromPtr;",
          "328:                 for (int y = yStart;",
          "329:                     y <= maxYThisRow;",
          "330:                     y += toSlice.ySampling)",
          "331:                 {",
          "337:                     fromPtr = fromSlice.base +",
          "338:                             (y - tileRange.min.y) * fromSlice.yStride +",
          "339:                             xStart * fromSlice.xStride;",
          "341:                     toPtr = toSlice.base +",
          "342:                             divp (y, toSlice.ySampling) * toSlice.yStride +",
          "343:                             divp (xStart, toSlice.xSampling) * toSlice.xStride;",
          "349:                     for (int x = xStart;",
          "350:                         x <= levelRange.max.x;",
          "351:                         x += toSlice.xSampling)",
          "352:                     {",
          "353:                         for (int i = 0; i < size; ++i)",
          "354:                             toPtr[i] = fromPtr[i];",
          "356:                         fromPtr += fromSlice.xStride * toSlice.xSampling;",
          "357:                         toPtr += toSlice.xStride;",
          "358:                     }",
          "359:                 }",
          "360:             }",
          "361:             else",
          "362:             {",
          "367:                 for (int y = yStart;",
          "368:                     y <= maxYThisRow;",
          "369:                     y += toSlice.ySampling)",
          "372:                     toPtr = toSlice.base +",
          "373:                             divp (y, toSlice.ySampling) * toSlice.yStride +",
          "374:                             divp (xStart, toSlice.xSampling) * toSlice.xStride;",
          "380:                     switch ( toSlice.type)",
          "381:                     {",
          "382:                         case UINT:",
          "383:                         {",
          "384:                             unsigned int fill = toSlice.fillValue;",
          "385:                             for (int x = xStart;",
          "386:                                 x <= levelRange.max.x;",
          "387:                                 x += toSlice.xSampling)",
          "388:                             {",
          "390:                                 toPtr += toSlice.xStride;",
          "391:                             }",
          "392:                             break;",
          "393:                         }",
          "394:                         case HALF :",
          "395:                         {",
          "396:                             half fill = toSlice.fillValue;",
          "397:                             for (int x = xStart;",
          "398:                                 x <= levelRange.max.x;",
          "399:                                 x += toSlice.xSampling)",
          "400:                             {",
          "402:                                 toPtr += toSlice.xStride;",
          "403:                             }",
          "404:                             break;",
          "405:                         }",
          "406:                         case FLOAT :",
          "407:                         {",
          "408:                             float fill = toSlice.fillValue;",
          "409:                             for (int x = xStart;",
          "410:                                 x <= levelRange.max.x;",
          "411:                                 x += toSlice.xSampling)",
          "412:                             {",
          "414:                                 toPtr += toSlice.xStride;",
          "415:                             }",
          "416:                             break;",
          "417:                         }",
          "418:                         case NUM_PIXELTYPES :",
          "419:                         {",
          "420:                             break;",
          "421:                         }",
          "423:                     }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "373:             _data->_streamData->is = is;",
          "374:             _data->header.readFrom (*_data->_streamData->is, _data->version);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "459:             if(isNonImage(_data->version))",
          "460:             {",
          "461:                 if(!_data->header.hasType())",
          "462:                 {",
          "463:                       throw(IEX_NAMESPACE::InputExc(\"Non-image files must have a 'type' attribute\"));",
          "464:                 }",
          "465:             }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "441:             _data->_streamData->is = &is;",
          "442:             _data->header.readFrom (*_data->_streamData->is, _data->version);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "535:             if(isNonImage(_data->version))",
          "536:             {",
          "537:                 if(!_data->header.hasType())",
          "538:                 {",
          "539:                       throw(IEX_NAMESPACE::InputExc(\"Non-image files must have a 'type' attribute\"));",
          "540:                 }",
          "541:             }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "703:      {",
          "704:   Slice s = k.slice();",
          "757:      }",
          "759:      _data->tFile->setFrameBuffer (*_data->cachedBuffer);",
          "760:         }",
          "762:  _data->tFileBuffer = frameBuffer;",
          "",
          "[Removed Lines]",
          "706:   switch (s.type)",
          "707:   {",
          "708:     case OPENEXR_IMF_INTERNAL_NAMESPACE::UINT:",
          "710:       _data->cachedBuffer->insert",
          "711:    (k.name(),",
          "712:     Slice (UINT,",
          "713:     (char *)(new unsigned int[tileRowSize] -",
          "714:      _data->offset),",
          "715:     sizeof (unsigned int),",
          "716:     sizeof (unsigned int) *",
          "717:         _data->tFile->levelWidth(0),",
          "718:     1, 1,",
          "719:     s.fillValue,",
          "720:     false, true));",
          "721:       break;",
          "723:     case OPENEXR_IMF_INTERNAL_NAMESPACE::HALF:",
          "725:       _data->cachedBuffer->insert",
          "726:    (k.name(),",
          "727:     Slice (HALF,",
          "728:     (char *)(new half[tileRowSize] -",
          "729:      _data->offset),",
          "730:     sizeof (half),",
          "731:     sizeof (half) *",
          "732:         _data->tFile->levelWidth(0),",
          "733:     1, 1,",
          "734:     s.fillValue,",
          "735:     false, true));",
          "736:       break;",
          "738:     case OPENEXR_IMF_INTERNAL_NAMESPACE::FLOAT:",
          "740:       _data->cachedBuffer->insert",
          "741:    (k.name(),",
          "742:     Slice (OPENEXR_IMF_INTERNAL_NAMESPACE::FLOAT,",
          "743:     (char *)(new float[tileRowSize] -",
          "744:      _data->offset),",
          "745:     sizeof(float),",
          "746:     sizeof(float) *",
          "747:         _data->tFile->levelWidth(0),",
          "748:     1, 1,",
          "749:     s.fillValue,",
          "750:     false, true));",
          "751:       break;",
          "753:     default:",
          "755:       throw IEX_NAMESPACE::ArgExc (\"Unknown pixel data type.\");",
          "756:   }",
          "",
          "[Added Lines]",
          "808:                 if ( _data->header.channels().find(k.name()) != _data->header.channels().end() )",
          "809:                 {",
          "810:                     switch (s.type)",
          "811:                     {",
          "812:                     case OPENEXR_IMF_INTERNAL_NAMESPACE::UINT:",
          "814:                         _data->cachedBuffer->insert",
          "815:                             (k.name(),",
          "816:                             Slice (UINT,",
          "817:                                     (char *)(new unsigned int[tileRowSize] -",
          "818:                                             _data->offset),",
          "819:                                     sizeof (unsigned int),",
          "820:                                     sizeof (unsigned int) *",
          "821:                                         _data->tFile->levelWidth(0),",
          "822:                                     1, 1,",
          "823:                                     s.fillValue,",
          "824:                                     false, true));",
          "825:                         break;",
          "827:                     case OPENEXR_IMF_INTERNAL_NAMESPACE::HALF:",
          "829:                         _data->cachedBuffer->insert",
          "830:                             (k.name(),",
          "831:                             Slice (HALF,",
          "832:                                     (char *)(new half[tileRowSize] -",
          "833:                                             _data->offset),",
          "834:                                     sizeof (half),",
          "835:                                     sizeof (half) *",
          "836:                                         _data->tFile->levelWidth(0),",
          "837:                                     1, 1,",
          "838:                                     s.fillValue,",
          "839:                                     false, true));",
          "840:                         break;",
          "842:                     case OPENEXR_IMF_INTERNAL_NAMESPACE::FLOAT:",
          "844:                         _data->cachedBuffer->insert",
          "845:                             (k.name(),",
          "846:                             Slice (OPENEXR_IMF_INTERNAL_NAMESPACE::FLOAT,",
          "847:                                     (char *)(new float[tileRowSize] -",
          "848:                                             _data->offset),",
          "849:                                     sizeof(float),",
          "850:                                     sizeof(float) *",
          "851:                                         _data->tFile->levelWidth(0),",
          "852:                                     1, 1,",
          "853:                                     s.fillValue,",
          "854:                                     false, true));",
          "855:                         break;",
          "857:                     default:",
          "859:                         throw IEX_NAMESPACE::ArgExc (\"Unknown pixel data type.\");",
          "860:                     }",
          "861:                 }",
          "",
          "---------------"
        ],
        "OpenEXR/IlmImf/ImfMultiPartInputFile.cpp||OpenEXR/IlmImf/ImfMultiPartInputFile.cpp": [
          "File: OpenEXR/IlmImf/ImfMultiPartInputFile.cpp -> OpenEXR/IlmImf/ImfMultiPartInputFile.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "343:     for (size_t i = 0; i < _data->_headers.size(); i++)",
          "344:     {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "343:     if ( _data->_headers.size() == 0)",
          "344:     {",
          "345:         throw IEX_NAMESPACE::ArgExc (\"Files must contain at least one header\");",
          "346:     }",
          "",
          "---------------"
        ],
        "OpenEXR/IlmImf/ImfPizCompressor.cpp||OpenEXR/IlmImf/ImfPizCompressor.cpp": [
          "File: OpenEXR/IlmImf/ImfPizCompressor.cpp -> OpenEXR/IlmImf/ImfPizCompressor.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "594:     int length;",
          "595:     Xdr::read <CharPtrIO> (inPtr, length);",
          "598:     {",
          "599:  throw InputExc (\"Error in header for PIZ-compressed data \"",
          "600:    \"(invalid array length).\");",
          "",
          "[Removed Lines]",
          "597:     if (length > inSize)",
          "",
          "[Added Lines]",
          "597:     if (inPtr + length > inputEnd || length<0 )",
          "",
          "---------------"
        ],
        "OpenEXR/IlmImf/ImfRgbaFile.cpp||OpenEXR/IlmImf/ImfRgbaFile.cpp": [
          "File: OpenEXR/IlmImf/ImfRgbaFile.cpp -> OpenEXR/IlmImf/ImfRgbaFile.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "1180: {",
          "1181:     RgbaChannels rgbaChannels = channels();",
          "1184:  _fromYca = new FromYca (*_inputFile, rgbaChannels);",
          "1185: }",
          "",
          "[Removed Lines]",
          "1183:     if (rgbaChannels & (WRITE_Y | WRITE_C))",
          "",
          "[Added Lines]",
          "1183:     if (rgbaChannels & WRITE_C)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1192: {",
          "1193:     RgbaChannels rgbaChannels = channels();",
          "1196:  _fromYca = new FromYca (*_inputFile, rgbaChannels);",
          "1197: }",
          "",
          "[Removed Lines]",
          "1195:     if (rgbaChannels & (WRITE_Y | WRITE_C))",
          "",
          "[Added Lines]",
          "1195:     if (rgbaChannels & WRITE_C)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1207: {",
          "1208:     RgbaChannels rgbaChannels = channels();",
          "1211:  _fromYca = new FromYca (*_inputFile, rgbaChannels);",
          "1212: }",
          "",
          "[Removed Lines]",
          "1210:     if (rgbaChannels & (WRITE_Y | WRITE_C))",
          "",
          "[Added Lines]",
          "1210:     if (rgbaChannels & WRITE_C)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1222: {",
          "1223:     RgbaChannels rgbaChannels = channels();",
          "1226:  _fromYca = new FromYca (*_inputFile, rgbaChannels);",
          "1227: }",
          "",
          "[Removed Lines]",
          "1225:     if (rgbaChannels & (WRITE_Y | WRITE_C))",
          "",
          "[Added Lines]",
          "1225:     if (rgbaChannels & WRITE_C)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1250:  FrameBuffer fb;",
          "1273:  fb.insert (_channelNamePrefix + \"A\",",
          "1274:      Slice (HALF,",
          "1275:      (char *) &base[0].a,",
          "",
          "[Removed Lines]",
          "1252:  fb.insert (_channelNamePrefix + \"R\",",
          "1253:      Slice (HALF,",
          "1254:      (char *) &base[0].r,",
          "1255:      xs, ys,",
          "1256:      1, 1,  // xSampling, ySampling",
          "1257:      0.0)); // fillValue",
          "1259:  fb.insert (_channelNamePrefix + \"G\",",
          "1260:      Slice (HALF,",
          "1261:      (char *) &base[0].g,",
          "1262:      xs, ys,",
          "1263:      1, 1,  // xSampling, ySampling",
          "1264:      0.0)); // fillValue",
          "1266:  fb.insert (_channelNamePrefix + \"B\",",
          "1267:      Slice (HALF,",
          "1268:      (char *) &base[0].b,",
          "1269:      xs, ys,",
          "1270:      1, 1,  // xSampling, ySampling",
          "1271:      0.0)); // fillValue",
          "",
          "[Added Lines]",
          "1252:         if( channels() & WRITE_Y )",
          "1253:         {",
          "1254:             fb.insert (_channelNamePrefix + \"Y\",",
          "1255:                     Slice (HALF,",
          "1256:                             (char *) &base[0].r,",
          "1257:                             xs, ys,",
          "1258:                             1, 1,  // xSampling, ySampling",
          "1259:                             0.0)); // fillValue",
          "1260:         }",
          "1261:         else",
          "1262:         {",
          "1265:             fb.insert (_channelNamePrefix + \"R\",",
          "1266:                     Slice (HALF,",
          "1267:                             (char *) &base[0].r,",
          "1268:                             xs, ys,",
          "1269:                             1, 1,  // xSampling, ySampling",
          "1270:                             0.0)); // fillValue",
          "1274:             fb.insert (_channelNamePrefix + \"G\",",
          "1275:                     Slice (HALF,",
          "1276:                             (char *) &base[0].g,",
          "1277:                             xs, ys,",
          "1278:                             1, 1,  // xSampling, ySampling",
          "1279:                             0.0)); // fillValue",
          "1281:             fb.insert (_channelNamePrefix + \"B\",",
          "1282:                     Slice (HALF,",
          "1283:                             (char *) &base[0].b,",
          "1284:                             xs, ys,",
          "1285:                             1, 1,  // xSampling, ySampling",
          "1286:                             0.0)); // fillValue",
          "1287:         }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1293:     RgbaChannels rgbaChannels = channels();",
          "1296:  _fromYca = new FromYca (*_inputFile, rgbaChannels);",
          "1298:     FrameBuffer fb;",
          "",
          "[Removed Lines]",
          "1295:     if (rgbaChannels & (WRITE_Y | WRITE_C))",
          "",
          "[Added Lines]",
          "1310:     if (rgbaChannels & WRITE_C)",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1311:     else",
          "1312:     {",
          "1313:  _inputFile->readPixels (scanLine1, scanLine2);",
          "1314:     }",
          "1315: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1330:         if (channels() & WRITE_Y)",
          "1331:         {",
          "1336:             const Slice* s = _inputFile->frameBuffer().findSlice(_channelNamePrefix + \"Y\");",
          "1337:             Box2i dataWindow = _inputFile->header().dataWindow();",
          "1339:             for( int scanLine = scanLine1  ; scanLine <= scanLine2 ; scanLine++ )",
          "1340:             {",
          "1341:                 char* rowBase = s->base + scanLine*s->yStride;",
          "1342:                 for(int x = dataWindow.min.x ; x <= dataWindow.max.x ; ++x )",
          "1343:                 {",
          "1344:                     Rgba* pixel = reinterpret_cast<Rgba*>(rowBase+x*s->xStride);",
          "1345:                     pixel->g = pixel->r;",
          "1346:                     pixel->b = pixel->r;",
          "1347:                 }",
          "1349:             }",
          "1350:         }",
          "",
          "---------------"
        ],
        "OpenEXR/IlmImf/ImfScanLineInputFile.cpp||OpenEXR/IlmImf/ImfScanLineInputFile.cpp": [
          "File: OpenEXR/IlmImf/ImfScanLineInputFile.cpp -> OpenEXR/IlmImf/ImfScanLineInputFile.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "1145:             for (size_t i = 0; i < _data->lineBuffers.size(); i++)",
          "1146:             {",
          "1147:                 _data->lineBuffers[i]->buffer = (char *) EXRAllocAligned(_data->lineBufferSize*sizeof(char),16);",
          "1148:             }",
          "1149:         }",
          "1150:         _data->nextLineBufferMinY = _data->minY - 1;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1148:                 if (!_data->lineBuffers[i]->buffer)",
          "1149:                 {",
          "1150:                     throw IEX_NAMESPACE::LogicExc(\"Failed to allocate memory for scanline buffers\");",
          "1151:                 }",
          "",
          "---------------"
        ],
        "OpenEXR/IlmImf/ImfTiledInputFile.cpp||OpenEXR/IlmImf/ImfTiledInputFile.cpp": [
          "File: OpenEXR/IlmImf/ImfTiledInputFile.cpp -> OpenEXR/IlmImf/ImfTiledInputFile.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "958:     {",
          "959:         if (!isTiled (_data->version))",
          "960:             throw IEX_NAMESPACE::ArgExc (\"Expected a tiled file but the file is not tiled.\");",
          "962:     }",
          "963:     else",
          "964:     {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "962:         if (isNonImage (_data->version))",
          "963:             throw IEX_NAMESPACE::ArgExc (\"File is not a regular tiled image.\");",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1000:     _data->tileBufferSize = _data->maxBytesPerTileLine * _data->tileDesc.ySize;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1009:     if( _data->tileBufferSize > INT_MAX )",
          "1010:     {",
          "1011:         throw IEX_NAMESPACE::ArgExc (\"Tile size too large for OpenEXR format\");",
          "1012:     }",
          "",
          "---------------"
        ],
        "OpenEXR/IlmImf/ImfTiledMisc.cpp||OpenEXR/IlmImf/ImfTiledMisc.cpp": [
          "File: OpenEXR/IlmImf/ImfTiledMisc.cpp -> OpenEXR/IlmImf/ImfTiledMisc.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "97:     V2i tileMin = V2i (minX + dx * tileDesc.xSize,",
          "98:          minY + dy * tileDesc.ySize);",
          "102:     V2i levelMax = dataWindowForLevel",
          "103:          (tileDesc, minX, maxX, minY, maxY, lx, ly).max;",
          "108:     return Box2i (tileMin, tileMax);",
          "109: }",
          "",
          "[Removed Lines]",
          "100:     V2i tileMax = tileMin + V2i (tileDesc.xSize - 1, tileDesc.ySize - 1);",
          "105:     tileMax = V2i (std::min (tileMax[0], levelMax[0]),",
          "106:      std::min (tileMax[1], levelMax[1]));",
          "",
          "[Added Lines]",
          "100:     int64_t tileMaxX = int64_t(tileMin[0]) + tileDesc.xSize - 1;",
          "101:     int64_t tileMaxY = int64_t(tileMin[1]) + tileDesc.ySize - 1;",
          "106:     V2i tileMax = V2i (std::min (tileMaxX, int64_t(levelMax[0])),",
          "107:      std::min (tileMaxY, int64_t(levelMax[1])));",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "301: {",
          "302:     for (int i = 0; i < numLevels; i++)",
          "303:     {",
          "308:         numTiles[i] = (l + size - 1) / size;",
          "309:     }",
          "310: }",
          "",
          "[Removed Lines]",
          "304:         int l = levelSize (min, max, i, rmode);",
          "305:         if (l > std::numeric_limits<int>::max() - size + 1)",
          "306:             throw IEX_NAMESPACE::ArgExc (\"Invalid size.\");",
          "",
          "[Added Lines]",
          "306:         Int64 l = levelSize (min, max, i, rmode);",
          "",
          "---------------"
        ],
        "OpenEXR/IlmImf/ImfTiledOutputFile.cpp||OpenEXR/IlmImf/ImfTiledOutputFile.cpp": [
          "File: OpenEXR/IlmImf/ImfTiledOutputFile.cpp -> OpenEXR/IlmImf/ImfTiledOutputFile.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "1036:     _data->tileBufferSize = _data->maxBytesPerTileLine * _data->tileDesc.ySize;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1042:     if( _data->tileBufferSize > INT_MAX )",
          "1043:     {",
          "1044:         throw IEX_NAMESPACE::ArgExc (\"Tile size too large for OpenEXR format\");",
          "1045:     }",
          "",
          "---------------"
        ],
        "OpenEXR/IlmImfTest/testHuf.cpp||OpenEXR/IlmImfTest/testHuf.cpp": [
          "File: OpenEXR/IlmImfTest/testHuf.cpp -> OpenEXR/IlmImfTest/testHuf.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "246:  IMATH_NAMESPACE::Rand48 rand48 (0);",
          "313:  cout << \"ok\\n\" << endl;",
          "314:     }",
          "",
          "[Removed Lines]",
          "248:  const int N = 1000000;",
          "249:  Array <unsigned short> raw (N);",
          "251:  fill1 (raw, N, 1, rand48);   // test various symbol distributions",
          "252:  compressUncompress (raw, N);",
          "253:  compressUncompressSubset (raw, N);",
          "254:  fill1 (raw, N, 10, rand48);",
          "255:  compressUncompress (raw, N);",
          "256:  compressUncompressSubset (raw, N);",
          "257:  fill1 (raw, N, 100, rand48);",
          "258:  compressUncompress (raw, N);",
          "259:  compressUncompressSubset (raw, N);",
          "260:  fill1 (raw, N, 1000, rand48);",
          "261:  compressUncompress (raw, N);",
          "262:  compressUncompressSubset (raw, N);",
          "264:  fill2 (raw, N, 1, rand48);",
          "265:  compressUncompress (raw, N);",
          "266:  compressUncompressSubset (raw, N);",
          "267:  fill2 (raw, N, 10, rand48);",
          "268:  compressUncompress (raw, N);",
          "269:  compressUncompressSubset (raw, N);",
          "270:  fill2 (raw, N, 100, rand48);",
          "271:  compressUncompress (raw, N);",
          "272:  compressUncompressSubset (raw, N);",
          "273:  fill2 (raw, N, 1000, rand48);",
          "274:  compressUncompress (raw, N);",
          "275:  compressUncompressSubset (raw, N);",
          "277:  fill3 (raw, N, 0);",
          "278:  compressUncompress (raw, N);",
          "279:  compressUncompressSubset (raw, N);",
          "280:  fill3 (raw, N, 1);",
          "281:  compressUncompress (raw, N);",
          "282:  compressUncompressSubset (raw, N);",
          "283:  fill3 (raw, N, USHRT_MAX - 1);",
          "284:  compressUncompress (raw, N);",
          "285:  compressUncompressSubset (raw, N);",
          "286:  fill3 (raw, N, USHRT_MAX);",
          "287:  compressUncompress (raw, N);",
          "288:  compressUncompressSubset (raw, N);",
          "290:  fill4 (raw, USHRT_MAX + 1);",
          "291:         compressVerify(raw, USHRT_MAX + 1, HUF_COMPRESS_DEK_HASH_FOR_FILL4_USHRT_MAX_PLUS_ONE);",
          "292:  compressUncompress (raw, USHRT_MAX + 1);",
          "293:  compressUncompressSubset (raw, USHRT_MAX + 1);",
          "294:  fill4 (raw, N);",
          "295:         compressVerify(raw, N, HUF_COMPRESS_DEK_HASH_FOR_FILL4_N);",
          "296:  compressUncompress (raw, N);",
          "297:  compressUncompressSubset (raw, N);",
          "299:  fill4 (raw, 0);",
          "300:  compressUncompress (raw, 0); // test small input data sets",
          "301:  fill4 (raw, 1);",
          "302:  compressUncompress (raw, 1);",
          "303:  fill4 (raw, 2);",
          "304:  compressUncompress (raw, 2);",
          "305:  fill4 (raw, 3);",
          "306:  compressUncompress (raw, 3);",
          "308:  fill5 (raw, N);   // test run-length coding of code table",
          "309:         compressVerify(raw, N, HUF_COMPRESS_DEK_HASH_FOR_FILL5_N);",
          "310:  compressUncompress (raw, N);",
          "311:  compressUncompressSubset (raw, N);",
          "",
          "[Added Lines]",
          "252:         for (int pass = 0 ; pass < 2 ; ++pass)",
          "253:         {",
          "255:             int N = pass==0 ? 12 : 1000000;",
          "256:             Array <unsigned short> raw (N);",
          "258:             fill1 (raw, N, 1, rand48);   // test various symbol distributions",
          "259:             compressUncompress (raw, N);",
          "260:             compressUncompressSubset (raw, N);",
          "261:             fill1 (raw, N, 10, rand48);",
          "262:             compressUncompress (raw, N);",
          "263:             compressUncompressSubset (raw, N);",
          "264:             fill1 (raw, N, 100, rand48);",
          "265:             compressUncompress (raw, N);",
          "266:             compressUncompressSubset (raw, N);",
          "267:             fill1 (raw, N, 1000, rand48);",
          "268:             compressUncompress (raw, N);",
          "269:             compressUncompressSubset (raw, N);",
          "271:             fill2 (raw, N, 1, rand48);",
          "272:             compressUncompress (raw, N);",
          "273:             compressUncompressSubset (raw, N);",
          "274:             fill2 (raw, N, 10, rand48);",
          "275:             compressUncompress (raw, N);",
          "276:             compressUncompressSubset (raw, N);",
          "277:             fill2 (raw, N, 100, rand48);",
          "278:             compressUncompress (raw, N);",
          "279:             compressUncompressSubset (raw, N);",
          "280:             fill2 (raw, N, 1000, rand48);",
          "281:             compressUncompress (raw, N);",
          "282:             compressUncompressSubset (raw, N);",
          "284:             fill3 (raw, N, 0);",
          "285:             compressUncompress (raw, N);",
          "286:             compressUncompressSubset (raw, N);",
          "287:             fill3 (raw, N, 1);",
          "288:             compressUncompress (raw, N);",
          "289:             compressUncompressSubset (raw, N);",
          "290:             fill3 (raw, N, USHRT_MAX - 1);",
          "291:             compressUncompress (raw, N);",
          "292:             compressUncompressSubset (raw, N);",
          "293:             fill3 (raw, N, USHRT_MAX);",
          "294:             compressUncompress (raw, N);",
          "295:             compressUncompressSubset (raw, N);",
          "297:             if (pass==1)",
          "298:             {",
          "299:                 fill4 (raw, USHRT_MAX + 1);",
          "300:                 compressVerify(raw, USHRT_MAX + 1, HUF_COMPRESS_DEK_HASH_FOR_FILL4_USHRT_MAX_PLUS_ONE);",
          "302:                 compressUncompress (raw, USHRT_MAX + 1);",
          "303:                 compressUncompressSubset (raw, USHRT_MAX + 1);",
          "304:                 fill4 (raw, N);",
          "305:                 compressVerify(raw, N, HUF_COMPRESS_DEK_HASH_FOR_FILL4_N);",
          "306:             }",
          "307:             compressUncompress (raw, N);",
          "308:             compressUncompressSubset (raw, N);",
          "310:             fill4 (raw, 0);",
          "311:             compressUncompress (raw, 0); // test small input data sets",
          "312:             fill4 (raw, 1);",
          "313:             compressUncompress (raw, 1);",
          "314:             fill4 (raw, 2);",
          "315:             compressUncompress (raw, 2);",
          "316:             fill4 (raw, 3);",
          "317:             compressUncompress (raw, 3);",
          "319:             fill5 (raw, N);   // test run-length coding of code table",
          "320:             if (pass==1)",
          "321:             {",
          "322:                 compressVerify(raw, N, HUF_COMPRESS_DEK_HASH_FOR_FILL5_N);",
          "323:             }",
          "324:             compressUncompress (raw, N);",
          "325:             compressUncompressSubset (raw, N);",
          "327:         }",
          "",
          "---------------"
        ],
        "OpenEXR/IlmImfTest/testScanLineApi.cpp||OpenEXR/IlmImfTest/testScanLineApi.cpp": [
          "File: OpenEXR/IlmImfTest/testScanLineApi.cpp -> OpenEXR/IlmImfTest/testScanLineApi.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "93:            int yOffset,",
          "94:            Compression comp,",
          "95:            LevelMode mode,",
          "97: {",
          "",
          "[Removed Lines]",
          "96:     LevelRoundingMode rmode)",
          "",
          "[Added Lines]",
          "96:     LevelRoundingMode rmode,",
          "97:            bool fillChannel",
          "98:           )",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "263:         Array2D<half>         ph2 (h, w);",
          "264:         Array2D<float>        pf2 (h, w);",
          "266:         FrameBuffer fb;",
          "268:         fb.insert (\"I\",                             // name",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "268:         Array2D<unsigned int> fi2 (fillChannel ? h : 1 , fillChannel ? w : 1);",
          "269:         Array2D<half>         fh2 (fillChannel ? h : 1 , fillChannel ? w : 1);",
          "270:         Array2D<float>        ff2 (fillChannel ? h : 1 , fillChannel ? w : 1);",
          "273:         const unsigned int fillInt = 12;",
          "274:         const half fillHalf = 4.5;",
          "275:         const float fillFloat = M_PI;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "286:                           sizeof (pf2[0][0]) * w)   // yStride",
          "287:                   );",
          "289:         in.setFrameBuffer (fb);",
          "290:         for (int y = dw.min.y; y <= dw.max.y; ++y)",
          "291:             in.readPixels (y);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "301:         if(fillChannel)",
          "302:         {",
          "303:             fb.insert (\"FI\",                             // name",
          "304:                    Slice (IMF::UINT,                // type",
          "305:                           (char *) &fi2[-dwy][-dwx],// base",
          "306:                           sizeof (fi2[0][0]),       // xStride",
          "307:                           sizeof (fi2[0][0]) * w,1,1,fillInt)  // yStride",
          "308:                   );",
          "310:             fb.insert (\"FH\",                             // name",
          "311:                     Slice (IMF::HALF,                // type",
          "312:                             (char *) &fh2[-dwy][-dwx],// base",
          "313:                             sizeof (fh2[0][0]),       // xStride",
          "314:                             sizeof (fh2[0][0]) * w,1,1,fillHalf)   // yStride",
          "315:                     );",
          "317:             fb.insert (\"FF\",                             // name",
          "318:                     Slice (IMF::FLOAT,               // type",
          "319:                             (char *) &ff2[-dwy][-dwx],// base",
          "320:                             sizeof (ff2[0][0]),       // xStride",
          "321:                             sizeof (ff2[0][0]) * w,1,1,fillFloat)   // yStride",
          "322:                     );",
          "323:         }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "323:                 assert (pi1[y][x] == pi2[y][x]);",
          "324:                 assert (ph1[y][x] == ph2[y][x]);",
          "325:                 assert (pf1[y][x] == pf2[y][x]);",
          "326:             }",
          "327:         }",
          "328:     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "363:                 if (fillChannel)",
          "364:                 {",
          "365:                     assert(fi2[y][x] == fillInt);",
          "366:                     assert(fh2[y][x] == fillHalf);",
          "367:                     assert(ff2[y][x] == fillFloat);",
          "368:                 }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "342:         Array2D<half>         ph2 (h, w);",
          "343:         Array2D<float>        pf2 (h, w);",
          "345:         FrameBuffer fb;",
          "347:         fb.insert (\"I\",                             // name",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "388:         Array2D<unsigned int> fi2 (fillChannel ? h : 1 , fillChannel ? w : 1);",
          "389:         Array2D<half>         fh2 (fillChannel ? h : 1 , fillChannel ? w : 1);",
          "390:         Array2D<float>        ff2 (fillChannel ? h : 1 , fillChannel ? w : 1);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "364:                           sizeof (pf2[0][0]),       // xStride",
          "365:                           sizeof (pf2[0][0]) * w)   // yStride",
          "366:                   );",
          "368:         in.setFrameBuffer (fb);",
          "369:         for (int y = dw.max.y; y >= dw.min.y; --y)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "414:         const unsigned int fillInt = 21;",
          "415:         const half fillHalf = 42;",
          "416:         const float fillFloat = 2.8;",
          "418:         if (fillChannel)",
          "419:         {",
          "420:             fb.insert (\"FI\",                             // name",
          "421:                    Slice (IMF::UINT,                // type",
          "422:                           (char *) &fi2[-dwy][-dwx],// base",
          "423:                           sizeof (fi2[0][0]),       // xStride",
          "424:                           sizeof (fi2[0][0]) * w,1,1,fillInt)   // yStride",
          "425:                   );",
          "427:             fb.insert (\"FH\",                             // name",
          "428:                     Slice (IMF::HALF,                // type",
          "429:                             (char *) &fh2[-dwy][-dwx],// base",
          "430:                             sizeof (fh2[0][0]),       // xStride",
          "431:                             sizeof (fh2[0][0]) * w,1,1,fillHalf)   // yStride",
          "432:                     );",
          "434:             fb.insert (\"FF\",                             // name",
          "435:                     Slice (IMF::FLOAT,               // type",
          "436:                             (char *) &ff2[-dwy][-dwx],// base",
          "437:                             sizeof (ff2[0][0]),       // xStride",
          "438:                             sizeof (ff2[0][0]) * w,1,1,fillFloat)   // yStride",
          "439:                     );",
          "441:         }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "402:                 assert (pi1[y][x] == pi2[y][x]);",
          "403:                 assert (ph1[y][x] == ph2[y][x]);",
          "404:                 assert (pf1[y][x] == pf2[y][x]);",
          "405:             }",
          "406:         }",
          "407:     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "480:                 if (fillChannel)",
          "481:                 {",
          "482:                     assert(fi2[y][x] == fillInt);",
          "483:                     assert(fh2[y][x] == fillHalf);",
          "484:                     assert(ff2[y][x] == fillFloat);",
          "485:                 }",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "422:         Array2D<half>         ph2 (h, w);",
          "423:         Array2D<float>        pf2 (h, w);",
          "425:         for (int y = dw.min.y; y <= dw.max.y; ++y)",
          "426:  {",
          "427:      FrameBuffer fb;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "507:         Array2D<unsigned int> fi2 (fillChannel ? h : 1 , fillChannel ? w : 1);",
          "508:         Array2D<half>         fh2 (fillChannel ? h : 1 , fillChannel ? w : 1);",
          "509:         Array2D<float>        ff2 (fillChannel ? h : 1 , fillChannel ? w : 1);",
          "512:         const unsigned int fillInt = 81;",
          "513:         const half fillHalf = 0.5;",
          "514:         const float fillFloat = 7.8;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "447:          0)    // yStride",
          "448:         );",
          "450:      in.setFrameBuffer (fb);",
          "451:             in.readPixels (y);",
          "452:  }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "542:             if (fillChannel)",
          "543:             {",
          "544:                 fb.insert (\"FI\",     // name",
          "545:                         Slice (IMF::UINT,   // type",
          "546:                                 (char *) &fi2[y - dwy][-dwx], // base",
          "547:                                 sizeof (fi2[0][0]),  // xStride",
          "548:                                 0,1,1,fillInt)    // yStride",
          "549:                         );",
          "551:                 fb.insert (\"FH\",     // name",
          "552:                         Slice (IMF::HALF,   // type",
          "553:                                 (char *) &fh2[y - dwy][-dwx], // base",
          "554:                                 sizeof (fh2[0][0]),  // xStride",
          "555:                                 0,1,1,fillHalf)    // yStride",
          "556:                         );",
          "558:                 fb.insert (\"FF\",                              // name",
          "559:                         Slice (IMF::FLOAT,   // type",
          "560:                                 (char *) &ff2[y - dwy][-dwx], // base",
          "561:                                 sizeof (ff2[0][0]),  // xStride",
          "562:                                 0,1,1,fillFloat)    // yStride",
          "563:                         );",
          "565:             }",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "484:                 assert (pi1[y][x] == pi2[y][x]);",
          "485:                 assert (ph1[y][x] == ph2[y][x]);",
          "486:                 assert (pf1[y][x] == pf2[y][x]);",
          "487:             }",
          "488:         }",
          "489:     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "604:                 if (fillChannel)",
          "605:                 {",
          "606:                     assert (fi2[y][x] == fillInt);",
          "607:                     assert (fh2[y][x] == fillHalf);",
          "608:                     assert (ff2[y][x] == fillFloat);",
          "609:                 }",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "509:     std::string filename = tempDir + \"imf_test_scanline_api.exr\";",
          "511:     writeRead (pi, ph, pf, filename.c_str(), lorder, W, H,",
          "513:     writeRead (pi, ph, pf, filename.c_str(), lorder, W, H,",
          "515:     writeRead (pi, ph, pf, filename.c_str(), lorder, W, H,",
          "517: }",
          "519: } // namespace",
          "",
          "[Removed Lines]",
          "512:                xSize, ySize, dx, dy, comp, ONE_LEVEL, rmode);",
          "514:                xSize, ySize, dx, dy, comp, MIPMAP_LEVELS, rmode);",
          "516:                xSize, ySize, dx, dy, comp, RIPMAP_LEVELS, rmode);",
          "",
          "[Added Lines]",
          "636:                xSize, ySize, dx, dy, comp, ONE_LEVEL, rmode , false);",
          "637:     writeRead (pi, ph, pf, filename.c_str(), lorder, W, H,",
          "638:                xSize, ySize, dx, dy, comp, MIPMAP_LEVELS, rmode , false );",
          "640:                xSize, ySize, dx, dy, comp, RIPMAP_LEVELS, rmode , false);",
          "642:                xSize, ySize, dx, dy, comp, ONE_LEVEL, rmode , true);",
          "",
          "---------------"
        ],
        "OpenEXR/IlmImfTest/testYca.cpp||OpenEXR/IlmImfTest/testYca.cpp": [
          "File: OpenEXR/IlmImfTest/testYca.cpp -> OpenEXR/IlmImfTest/testYca.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "195:      else",
          "196:      {",
          "197:   assert (p1.g == p2.g);",
          "198:      }",
          "200:      if (channels & WRITE_A)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "198:   assert (p1.b == p2.b);",
          "",
          "---------------"
        ],
        "OpenEXR/exrmaketiled/main.cpp||OpenEXR/exrmaketiled/main.cpp": [
          "File: OpenEXR/exrmaketiled/main.cpp -> OpenEXR/exrmaketiled/main.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "394:     int exitStatus = 0;",
          "399:     {",
          "414:         }",
          "421:         makeTiled (inFile, outFile, partnum,",
          "422:                    mode, roundingMode, compression,",
          "423:                    tileSizeX, tileSizeY,",
          "",
          "[Removed Lines]",
          "400:         MultiPartInputFile input (inFile);",
          "401:         int parts = input.parts();",
          "403:         if (partnum < 0 || partnum >= parts){",
          "404:             cerr << \"ERROR: you asked for part \" << partnum << \" in \" << inFile;",
          "405:             cerr << \", which only has \" << parts << \" parts\\n\";",
          "406:             exit(1);",
          "407:         }",
          "409:         Header h = input.header (partnum);",
          "410:         if (h.type() == DEEPTILE || h.type() == DEEPSCANLINE)",
          "411:         {",
          "412:             cerr << \"Cannot make tile for deep data\" << endl;",
          "413:             exit(1);",
          "416:     }",
          "419:     try",
          "420:     {",
          "",
          "[Added Lines]",
          "396:     try",
          "401:         {",
          "402:             MultiPartInputFile input (inFile);",
          "403:             int parts = input.parts();",
          "405:             if (partnum < 0 || partnum >= parts){",
          "406:                 cerr << \"ERROR: you asked for part \" << partnum << \" in \" << inFile;",
          "407:                 cerr << \", which only has \" << parts << \" parts\\n\";",
          "408:                 exit(1);",
          "409:             }",
          "411:             Header h = input.header (partnum);",
          "412:             if (h.type() == DEEPTILE || h.type() == DEEPSCANLINE)",
          "413:             {",
          "414:                 cerr << \"Cannot make tile for deep data\" << endl;",
          "415:                 exit(1);",
          "416:             }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
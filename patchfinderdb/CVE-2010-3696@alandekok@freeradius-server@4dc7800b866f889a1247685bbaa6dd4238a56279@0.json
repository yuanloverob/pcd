{
  "cve_id": "CVE-2010-3696",
  "cve_desc": "The fr_dhcp_decode function in lib/dhcp.c in FreeRADIUS 2.1.9, in certain non-default builds, does not properly handle the DHCP Relay Agent Information option, which allows remote attackers to cause a denial of service (infinite loop and daemon outage) via a packet that has more than one sub-option.  NOTE: some of these details are obtained from third party information.",
  "repo": "alandekok/freeradius-server",
  "patch_hash": "4dc7800b866f889a1247685bbaa6dd4238a56279",
  "patch_info": {
    "commit_hash": "4dc7800b866f889a1247685bbaa6dd4238a56279",
    "repo": "alandekok/freeradius-server",
    "commit_url": "https://github.com/alandekok/freeradius-server/commit/4dc7800b866f889a1247685bbaa6dd4238a56279",
    "files": [
      "src/lib/dhcp.c"
    ],
    "message": "Fix endless loop when there are multiple DHCP options",
    "before_after_code_files": [
      "src/lib/dhcp.c||src/lib/dhcp.c"
    ]
  },
  "patch_diff": {
    "src/lib/dhcp.c||src/lib/dhcp.c": [
      "File: src/lib/dhcp.c -> src/lib/dhcp.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "714:    }",
      "718:    p += alen;",
      "",
      "[Removed Lines]",
      "717:    while (*tail) tail = &vp->next;",
      "",
      "[Added Lines]",
      "717:    while (*tail) tail = &(*tail)->next;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "1f13fe573056232b30b22baac1fd484d0bac2d27",
      "candidate_info": {
        "commit_hash": "1f13fe573056232b30b22baac1fd484d0bac2d27",
        "repo": "alandekok/freeradius-server",
        "commit_url": "https://github.com/alandekok/freeradius-server/commit/1f13fe573056232b30b22baac1fd484d0bac2d27",
        "files": [
          "src/lib/dhcp.c"
        ],
        "message": "Large code cleanups.\n\nFix error messages (no fprintf)\nEnable option 82 sub-options\nAllow it to originate DHCP packets, too",
        "before_after_code_files": [
          "src/lib/dhcp.c||src/lib/dhcp.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/lib/dhcp.c||src/lib/dhcp.c"
          ],
          "candidate": [
            "src/lib/dhcp.c||src/lib/dhcp.c"
          ]
        }
      },
      "candidate_diff": {
        "src/lib/dhcp.c||src/lib/dhcp.c": [
          "File: src/lib/dhcp.c -> src/lib/dhcp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "168:   if ((where + 2) > size) {",
          "169:    fr_strerror_printf(\"Options overflow field at %u\",",
          "171:    return NULL;",
          "172:   }",
          "174:   if ((where + 2 + data[1]) > size) {",
          "175:    fr_strerror_printf(\"Option length overflows field at %u\",",
          "177:    return NULL;",
          "178:   }",
          "",
          "[Removed Lines]",
          "170:         data - (uint8_t *) packet);",
          "176:         data - (uint8_t *) packet);",
          "",
          "[Added Lines]",
          "170:         (unsigned int) (data - (uint8_t *) packet));",
          "176:         (unsigned int) (data - (uint8_t *) packet));",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "206:  uint8_t   *code;",
          "208:  packet = rad_alloc(0);",
          "210:  memset(packet, 0, sizeof(packet));",
          "212:  packet->data = malloc(MAX_PACKET_SIZE);",
          "213:  if (!packet->data) {",
          "214:   rad_free(&packet);",
          "215:   return NULL;",
          "216:  }",
          "",
          "[Removed Lines]",
          "209:  if (!packet) return NULL;",
          "",
          "[Added Lines]",
          "209:  if (!packet) {",
          "210:   fr_strerror_printf(\"Failed allocating packet\");",
          "211:   return NULL;",
          "212:  }",
          "217:   fr_strerror_printf(\"Failed in malloc\");",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "228: #endif",
          "230:  if (packet->data_len <= 0) {",
          "232:   rad_free(&packet);",
          "233:   return NULL;",
          "234:  }",
          "236:  if (packet->data_len < MIN_PACKET_SIZE) {",
          "238:         packet->data_len, MIN_PACKET_SIZE);",
          "239:   rad_free(&packet);",
          "240:   return NULL;",
          "241:  }",
          "249:  if (packet->data[1] != 1) {",
          "251:         packet->data[1]);",
          "252:   rad_free(&packet);",
          "253:   return NULL;",
          "254:  }",
          "256:  if (packet->data[2] != 6) {",
          "258:    packet->data[2]);",
          "259:   rad_free(&packet);",
          "260:   return NULL;",
          "",
          "[Removed Lines]",
          "231:   fprintf(stderr, \"Failed reading DHCP socket: %s\", strerror(errno));",
          "237:   fprintf(stderr, \"DHCP packet is too small (%d < %d)\",",
          "243:  if (packet->data[0] != 1) {",
          "244:   fprintf(stderr, \"Cannot receive DHCP server messages\");",
          "245:   rad_free(&packet);",
          "246:   return NULL;",
          "247:  }",
          "250:   fprintf(stderr, \"DHCP can only receive ethernet requests, not type %02x\",",
          "257:   fprintf(stderr, \"Ethernet HW length is wrong length %d\\n\",",
          "",
          "[Added Lines]",
          "235:   fr_strerror_printf(\"Failed reading DHCP socket: %s\", strerror(errno));",
          "241:   fr_strerror_printf(\"DHCP packet is too small (%d < %d)\",",
          "248:   fr_strerror_printf(\"DHCP can only receive ethernet requests, not type %02x\",",
          "255:   fr_strerror_printf(\"Ethernet HW length is wrong length %d\",",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "263:  memcpy(&magic, packet->data + 236, 4);",
          "264:  magic = ntohl(magic);",
          "265:  if (magic != DHCP_OPTION_MAGIC_NUMBER) {",
          "267:   rad_free(&packet);",
          "268:   return NULL;",
          "269:  }",
          "",
          "[Removed Lines]",
          "266:   fprintf(stderr, \"Cannot do BOOTP\\n\");",
          "",
          "[Added Lines]",
          "264:   fr_strerror_printf(\"Cannot do BOOTP\");",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "346:      packet->code - PW_DHCP_OFFSET);",
          "347:   }",
          "350:          name, (unsigned int) packet->id,",
          "351:          inet_ntop(packet->src_ipaddr.af,",
          "352:      &packet->src_ipaddr.ipaddr,",
          "",
          "[Removed Lines]",
          "349:   printf(\"Received %s of id %08x from %s:%d to %s:%d\\n\",",
          "",
          "[Added Lines]",
          "347:   DEBUG(\"Received %s of id %08x from %s:%d to %s:%d\",",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "356:      &packet->dst_ipaddr.ipaddr,",
          "357:      dst_ip_buf, sizeof(dst_ip_buf)),",
          "358:          packet->dst_port);",
          "360:  }",
          "362:  return packet;",
          "",
          "[Removed Lines]",
          "359:   fflush(stdout);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "395: #endif",
          "396: }",
          "399: int fr_dhcp_decode(RADIUS_PACKET *packet)",
          "400: {",
          "401:  int i;",
          "404:  uint32_t giaddr;",
          "405:  VALUE_PAIR *head, *vp, **tail;",
          "406:  VALUE_PAIR *maxms, *mtu;",
          "",
          "[Removed Lines]",
          "402:  ssize_t total;",
          "403:  uint8_t *p;",
          "",
          "[Added Lines]",
          "395: static int fr_dhcp_attr2vp(VALUE_PAIR *vp, const uint8_t *p, size_t alen);",
          "397: static int decode_tlv(VALUE_PAIR *tlv, const uint8_t *data, size_t data_len)",
          "398: {",
          "399:  const uint8_t *p;",
          "400:  VALUE_PAIR *head, **tail, *vp;",
          "405:  p = data;",
          "406:  while (p < (data + data_len)) {",
          "407:   if ((p + 2) > (data + data_len)) goto make_tlv;",
          "409:   if ((p + p[1] + 2) > (data + data_len)) goto make_tlv;",
          "410:   p += 2 + p[1];",
          "411:  }",
          "416:  head = NULL;",
          "417:  tail = &head;",
          "419:  p = data;",
          "420:  while (p < (data + data_len)) {",
          "421:   vp = paircreate(tlv->attribute | (p[0] << 8), PW_TYPE_OCTETS);",
          "422:   if (!vp) {",
          "423:    pairfree(&head);",
          "424:    goto make_tlv;",
          "425:   }",
          "427:   if (fr_dhcp_attr2vp(vp, p + 2, p[1]) < 0) {",
          "428:    pairfree(&head);",
          "429:    goto make_tlv;",
          "430:   }",
          "433:   tail = &(vp->next);",
          "434:   p += 2 + p[1];",
          "435:  }",
          "441:  memcpy(tlv, head, sizeof(*tlv));",
          "442:  head->next = NULL;",
          "443:  pairfree(&head);",
          "444:  return 0;",
          "446: make_tlv:",
          "447:  tlv->vp_tlv = malloc(data_len);",
          "448:  if (!tlv->vp_tlv) {",
          "449:   fr_strerror_printf(\"No memory\");",
          "450:   return -1;",
          "451:  }",
          "452:  memcpy(tlv->vp_tlv, data, data_len);",
          "453:  tlv->length = data_len;",
          "455:  return 0;",
          "456: }",
          "462: static int fr_dhcp_attr2vp(VALUE_PAIR *vp, const uint8_t *p, size_t alen)",
          "463: {",
          "464:  switch (vp->type) {",
          "465:  case PW_TYPE_BYTE:",
          "466:   if (alen != 1) goto raw;",
          "467:   vp->vp_integer = p[0];",
          "468:   break;",
          "470:  case PW_TYPE_SHORT:",
          "471:   if (alen != 2) goto raw;",
          "472:   vp->vp_integer = (p[0] << 8) | p[1];",
          "473:   break;",
          "475:  case PW_TYPE_INTEGER:",
          "476:   if (alen != 4) goto raw;",
          "477:   memcpy(&vp->vp_integer, p, 4);",
          "478:   vp->vp_integer = ntohl(vp->vp_integer);",
          "479:   break;",
          "481:  case PW_TYPE_IPADDR:",
          "482:   if (alen != 4) goto raw;",
          "483:   memcpy(&vp->vp_ipaddr, p , 4);",
          "484:   vp->length = 4;",
          "485:   break;",
          "487:  case PW_TYPE_STRING:",
          "488:   if (alen > 253) return -1;",
          "489:   memcpy(vp->vp_strvalue, p , alen);",
          "490:   vp->vp_strvalue[alen] = '\\0';",
          "491:   break;",
          "493:  raw:",
          "494:   vp->type = PW_TYPE_OCTETS;",
          "496:  case PW_TYPE_OCTETS:",
          "497:   if (alen > 253) return -1;",
          "498:   memcpy(vp->vp_octets, p, alen);",
          "499:   break;",
          "501:  case PW_TYPE_TLV:",
          "502:   return decode_tlv(vp, p, alen);",
          "504:  default:",
          "505:   fr_strerror_printf(\"Internal sanity check %d %d\", vp->type, __LINE__);",
          "506:   break;",
          "509:  vp->length = alen;",
          "510:  return 0;",
          "511: }",
          "516:  uint8_t *p, *next;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "413:  if ((fr_debug_flag > 2) && fr_log_fp) {",
          "414:   for (i = 0; i < packet->data_len; i++) {",
          "416:    fprintf(fr_log_fp, \"%02x \", packet->data[i]);",
          "417:    if ((i & 0x0f) == 0x0f) fprintf(fr_log_fp, \"\\n\");",
          "418:   }",
          "",
          "[Removed Lines]",
          "415:    if ((i & 0x0f) == 0x00) fprintf(stderr, \"%d: \", i);",
          "",
          "[Added Lines]",
          "528:    if ((i & 0x0f) == 0x00) fr_strerror_printf(\"%d: \", i);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "420:  }",
          "422:  if (packet->data[1] != 1) {",
          "424:         packet->data[1]);",
          "425:   return -1;",
          "426:  }",
          "",
          "[Removed Lines]",
          "423:   fprintf(stderr, \"Packet is not Ethernet: %u\\n\",",
          "",
          "[Added Lines]",
          "536:   fr_strerror_printf(\"Packet is not Ethernet: %u\",",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "431:  for (i = 0; i < 14; i++) {",
          "432:   vp = pairmake(dhcp_header_names[i], NULL, T_OP_EQ);",
          "433:   if (!vp) {",
          "435:    pairfree(&head);",
          "436:    return -1;",
          "437:   }",
          "440:   if ((i == 11) &&",
          "441:       (packet->data[1] == 1) &&",
          "442:       (packet->data[2] == 6)) {",
          "",
          "[Removed Lines]",
          "434:    fprintf(stderr, \"Parse error %s\\n\", fr_strerror());",
          "",
          "[Added Lines]",
          "547:    fr_strerror_printf(\"Parse error %s\", fr_strerror());",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "485:    break;",
          "487:   default:",
          "489:    pairfree(&vp);",
          "490:    break;",
          "491:   }",
          "",
          "[Removed Lines]",
          "488:    fprintf(stderr, \"BAD TYPE %d\\n\", vp->type);",
          "",
          "[Added Lines]",
          "600:    fr_strerror_printf(\"BAD TYPE %d\", vp->type);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "496:   if (fr_debug_flag > 1) {",
          "497:    vp_prints(buffer, sizeof(buffer), vp);",
          "499:   }",
          "501:   tail = &vp->next;",
          "",
          "[Removed Lines]",
          "498:    fprintf(stderr, \"\\t%s\\n\", buffer);",
          "",
          "[Added Lines]",
          "610:    fr_strerror_printf(\"\\t%s\", buffer);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "515:   int num_entries, alen;",
          "516:   DICT_ATTR *da;",
          "518:   if (*p == 0) break;",
          "521:   if (p[1] >= 253) {",
          "523:          p[0], p[1]);",
          "525:   }",
          "527:   da = dict_attrbyvalue(DHCP2ATTR(p[0]));",
          "528:   if (!da) {",
          "530:          p[0]);",
          "536:    continue;",
          "537:   }",
          "",
          "[Removed Lines]",
          "507:  p = packet->data + 240;",
          "508:  total = packet->data_len - 240;",
          "514:  while (total > 0) {",
          "522:    fprintf(stderr, \"Attribute too long %u %u\\n\",",
          "524:    goto do_next;",
          "529:    fprintf(stderr, \"Attribute not in our dictionary: %u\\n\",",
          "531:   do_next:",
          "532:    total -= 2;",
          "533:    total -= p[1];",
          "534:    p += p[1];",
          "535:    p += 2;",
          "",
          "[Added Lines]",
          "619:  next = packet->data + 240;",
          "625:  while (next < (packet->data + packet->data_len)) {",
          "629:   p = next;",
          "633:   if ((p + 2) > (packet->data + packet->data_len)) break;",
          "635:   next = p + 2 + p[1];",
          "638:    fr_strerror_printf(\"Attribute too long %u %u\",",
          "640:    continue;",
          "645:    fr_strerror_printf(\"Attribute not in our dictionary: %u\",",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "548:     alen = 1;",
          "549:     break;",
          "554:     alen = 2;",
          "555:     break;",
          "557:    case PW_TYPE_IPADDR:",
          "558:    case PW_TYPE_INTEGER:",
          "562:     alen = 4;",
          "563:     break;",
          "565:    default:",
          "588:    }",
          "589:   }",
          "591:   for (i = 0; i < num_entries; i++) {",
          "592:    vp = pairmake(da->name, NULL, T_OP_EQ);",
          "593:    if (!vp) {",
          "595:      fr_strerror());",
          "596:     pairfree(&head);",
          "597:     return -1;",
          "598:    }",
          "603:    if ((da->attr == DHCP2ATTR(0x3d)) &&",
          "604:        !da->flags.array &&",
          "605:        (alen == 7) && (*p == 1) && (num_entries == 1)) {",
          "606:     vp->type = PW_TYPE_ETHERNET;",
          "607:     memcpy(vp->vp_octets, p + 1, 6);",
          "650:      pairfree(&vp);",
          "656:    if (fr_debug_flag > 1) {",
          "657:     vp_prints(buffer, sizeof(buffer), vp);",
          "659:    }",
          "663:    p += alen;",
          "",
          "[Removed Lines]",
          "551:    case PW_TYPE_SHORT:",
          "552:     if ((alen & 0x01) != 0) goto raw;",
          "553:     num_entries = alen / 2;",
          "559:    case PW_TYPE_DATE:",
          "560:     if ((alen & 0x03) != 0) goto raw;",
          "561:     num_entries = alen / 4;",
          "567:    }",
          "568:   } else {",
          "569:    num_entries = 1;",
          "571:    switch (da->type) {",
          "572:    case PW_TYPE_BYTE:",
          "573:     if (alen != 1) goto raw;",
          "574:     break;",
          "576:    case PW_TYPE_SHORT:",
          "577:     if (alen != 2) goto raw;",
          "578:     break;",
          "580:    case PW_TYPE_IPADDR:",
          "581:    case PW_TYPE_INTEGER:",
          "582:    case PW_TYPE_DATE:",
          "583:     if (alen != 4) goto raw;",
          "584:     break;",
          "586:    default:",
          "587:     break;",
          "594:     fprintf(stderr, \"Cannot build attribute %s\\n\",",
          "608:    } else",
          "610:     switch (vp->type) {",
          "611:     case PW_TYPE_BYTE:",
          "612:      vp->vp_integer = p[0];",
          "613:      break;",
          "615:     case PW_TYPE_SHORT:",
          "616:      vp->vp_integer = (p[0] << 8) | p[1];",
          "617:      break;",
          "619:     case PW_TYPE_INTEGER:",
          "620:      memcpy(&vp->vp_integer, p, 4);",
          "621:      vp->vp_integer = ntohl(vp->vp_integer);",
          "622:      break;",
          "624:     case PW_TYPE_IPADDR:",
          "625:      memcpy(&vp->vp_ipaddr, p , 4);",
          "626:      vp->length = 4;",
          "627:      break;",
          "629:     case PW_TYPE_STRING:",
          "630:      memcpy(vp->vp_strvalue, p , alen);",
          "631:      vp->vp_strvalue[alen] = '\\0';",
          "632:      break;",
          "634:     raw:",
          "635:      vp = pairmake(da->name, NULL, T_OP_EQ);",
          "636:      if (!vp) {",
          "637:       fprintf(stderr, \"Cannot build attribute %s\\n\", fr_strerror());",
          "638:       pairfree(&head);",
          "639:       return -1;",
          "640:      }",
          "642:      vp->type = PW_TYPE_OCTETS;",
          "644:     case PW_TYPE_OCTETS:",
          "645:      memcpy(vp->vp_octets, p, alen);",
          "646:      break;",
          "648:     default:",
          "649:      fprintf(stderr, \"Internal sanity check %d %d\\n\", vp->type, __LINE__);",
          "651:      break;",
          "654:    vp->length = alen;",
          "658:     fprintf(stderr, \"\\t%s\\n\", buffer);",
          "662:    tail = &vp->next;",
          "666:   total -= 2;",
          "667:   total -= (alen * num_entries);",
          "668:  }",
          "",
          "[Added Lines]",
          "666:     num_entries = alen >> 1;",
          "673:     num_entries = alen >> 2;",
          "689:     fr_strerror_printf(\"Cannot build attribute %s\",",
          "703:     vp->length = alen;",
          "705:    } else if (fr_dhcp_attr2vp(vp, p, alen) < 0) {",
          "707:      pairfree(&head);",
          "708:      return -1;",
          "709:    }",
          "713:     fr_strerror_printf(\"\\t%s\", buffer);",
          "717:    while (*tail) tail = &vp->next;",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "712:  mtu = pairfind(packet->vps, DHCP2ATTR(26));",
          "714:  if (mtu && (mtu->vp_integer < DEFAULT_PACKET_SIZE)) {",
          "716:   return -1;",
          "717:  }",
          "719:  if (maxms && (maxms->vp_integer < DEFAULT_PACKET_SIZE)) {",
          "721:   maxms->vp_integer = DEFAULT_PACKET_SIZE;",
          "722:  }",
          "724:  if (maxms && mtu && (maxms->vp_integer > mtu->vp_integer)) {",
          "726:   maxms->vp_integer = mtu->vp_integer;",
          "727:  }",
          "",
          "[Removed Lines]",
          "715:   fprintf(stderr, \"DHCP Fatal: Client says MTU is smaller than minimum permitted by the specification.\");",
          "720:   fprintf(stderr, \"DHCP WARNING: Client says maximum message size is smaller than minimum permitted by the specification: fixing it\");",
          "725:   fprintf(stderr, \"DHCP WARNING: Client says MTU is smaller than maximum message size: fixing it\");",
          "",
          "[Added Lines]",
          "767:   fr_strerror_printf(\"DHCP Fatal: Client says MTU is smaller than minimum permitted by the specification.\");",
          "772:   fr_strerror_printf(\"DHCP WARNING: Client says maximum message size is smaller than minimum permitted by the specification: fixing it\");",
          "777:   fr_strerror_printf(\"DHCP WARNING: Client says MTU is smaller than maximum message size: fixing it\");",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "801:   length = vp->length;",
          "802:   break;",
          "804:  case PW_TYPE_OCTETS:",
          "805:   memcpy(p, vp->vp_octets, vp->length);",
          "806:   length = vp->length;",
          "807:   break;",
          "809:  default:",
          "811:   length = 0;",
          "812:   break;",
          "813:  }",
          "",
          "[Removed Lines]",
          "810:   fprintf(stderr, \"BAD TYPE2 %d\\n\", vp->type);",
          "",
          "[Added Lines]",
          "857:   memcpy(p, vp->vp_tlv, vp->length);",
          "858:   length = vp->length;",
          "859:   break;",
          "867:   fr_strerror_printf(\"BAD TYPE2 %d\", vp->type);",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "815:  return length;",
          "816: }",
          "818: int fr_dhcp_encode(RADIUS_PACKET *packet, RADIUS_PACKET *original)",
          "819: {",
          "820:  int i, num_vps;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "875: static VALUE_PAIR *fr_dhcp_vp2suboption(VALUE_PAIR *vps)",
          "876: {",
          "877:  int length;",
          "878:  unsigned int attribute;",
          "879:  uint8_t *ptr;",
          "880:  VALUE_PAIR *vp, *tlv;",
          "882:  attribute = vps->attribute & 0xffff00ff;",
          "884:  tlv = paircreate(attribute, PW_TYPE_TLV);",
          "885:  if (!tlv) return NULL;",
          "887:  tlv->length = 0;",
          "888:  for (vp = vps; vp != NULL; vp = vp->next) {",
          "893:   if (!vp->flags.is_tlv ||",
          "894:       vp->flags.encoded ||",
          "895:       ((vp->attribute & 0xffff00ff) != attribute)) {",
          "896:    break;",
          "897:   }",
          "899:   tlv->length += vp->length + 2;",
          "900:  }",
          "902:  if (!tlv->length) {",
          "903:   pairfree(&tlv);",
          "904:   return NULL;",
          "905:  }",
          "907:  tlv->vp_tlv = malloc(tlv->length);",
          "908:  if (!tlv->vp_tlv) {",
          "909:   pairfree(&tlv);",
          "910:   return NULL;",
          "911:  }",
          "913:  ptr = tlv->vp_tlv;",
          "914:  for (vp = vps; vp != NULL; vp = vp->next) {",
          "915:   if (!vp->flags.is_tlv ||",
          "916:       vp->flags.encoded ||",
          "917:       ((vp->attribute & 0xffff00ff) != attribute)) {",
          "918:    break;",
          "919:   }",
          "921:   length = fr_dhcp_vp2attr(vp, ptr + 2,",
          "922:       tlv->vp_tlv + tlv->length - ptr);",
          "923:   if (length > 255) return NULL;",
          "928:   ptr[0] = (vp->attribute & 0xff00) >> 8;",
          "929:   ptr[1] = length;",
          "931:   ptr += length + 2;",
          "932:   vp->flags.encoded = 1;",
          "933:  }",
          "935:  return tlv;",
          "936: }",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "835:  if (packet->code == 0) packet->code = PW_DHCP_NAK;",
          "876:   } else {",
          "878:   }",
          "895:  } else {",
          "904:  }",
          "906:  if (fr_debug_flag > 1) {",
          "",
          "[Removed Lines]",
          "840:  if (!original) {",
          "841:   fr_strerror_printf(\"Need original to send response!\");",
          "842:   return -1;",
          "843:  }",
          "845:  packet->dst_ipaddr.af = AF_INET;",
          "846:  packet->src_ipaddr.af = AF_INET;",
          "848:  packet->dst_port = original->src_port;",
          "849:  packet->src_port = original->dst_port;",
          "869:  dhcp = (dhcp_packet_t *) original->data;",
          "871:  if (dhcp->giaddr != htonl(INADDR_ANY)) {",
          "872:   packet->dst_ipaddr.ipaddr.ip4addr.s_addr = dhcp->giaddr;",
          "874:   if (dhcp->giaddr != htonl(INADDR_LOOPBACK)) {",
          "875:    packet->dst_port = original->dst_port;",
          "880:  } else if (packet->code == PW_DHCP_NAK) {",
          "881:   packet->dst_ipaddr.ipaddr.ip4addr.s_addr = htonl(INADDR_BROADCAST);",
          "883:  } else if (dhcp->ciaddr != htonl(INADDR_ANY)) {",
          "884:   packet->dst_ipaddr.ipaddr.ip4addr.s_addr = dhcp->ciaddr;",
          "886:  } else if ((dhcp->flags & 0x8000) != 0) {",
          "887:   packet->dst_ipaddr.ipaddr.ip4addr.s_addr = htonl(INADDR_BROADCAST);",
          "889:  } else if (packet->dst_ipaddr.ipaddr.ip4addr.s_addr == htonl(INADDR_ANY)) {",
          "890:   packet->dst_ipaddr.ipaddr.ip4addr.s_addr = htonl(INADDR_BROADCAST);",
          "892:  } else if (dhcp->yiaddr != htonl(INADDR_ANY)) {",
          "893:   packet->dst_ipaddr.ipaddr.ip4addr.s_addr = dhcp->yiaddr;",
          "897:  }",
          "902:  if (packet->src_ipaddr.ipaddr.ip4addr.s_addr == htonl(INADDR_BROADCAST)) {",
          "903:   packet->src_ipaddr.ipaddr.ip4addr.s_addr = htonl(INADDR_ANY);",
          "",
          "[Added Lines]",
          "963:  if (original) {",
          "964:   packet->dst_ipaddr.af = AF_INET;",
          "965:   packet->src_ipaddr.af = AF_INET;",
          "967:   packet->dst_port = original->src_port;",
          "968:   packet->src_port = original->dst_port;",
          "989:   dhcp = (dhcp_packet_t *) original->data;",
          "991:   if (dhcp->giaddr != htonl(INADDR_ANY)) {",
          "992:    packet->dst_ipaddr.ipaddr.ip4addr.s_addr = dhcp->giaddr;",
          "994:    if (dhcp->giaddr != htonl(INADDR_LOOPBACK)) {",
          "995:     packet->dst_port = original->dst_port;",
          "996:    } else {",
          "998:    }",
          "1000:   } else if (packet->code == PW_DHCP_NAK) {",
          "1001:    packet->dst_ipaddr.ipaddr.ip4addr.s_addr = htonl(INADDR_BROADCAST);",
          "1003:   } else if (dhcp->ciaddr != htonl(INADDR_ANY)) {",
          "1004:    packet->dst_ipaddr.ipaddr.ip4addr.s_addr = dhcp->ciaddr;",
          "1006:   } else if ((dhcp->flags & 0x8000) != 0) {",
          "1007:    packet->dst_ipaddr.ipaddr.ip4addr.s_addr = htonl(INADDR_BROADCAST);",
          "1009:   } else if (packet->dst_ipaddr.ipaddr.ip4addr.s_addr == htonl(INADDR_ANY)) {",
          "1010:    packet->dst_ipaddr.ipaddr.ip4addr.s_addr = htonl(INADDR_BROADCAST);",
          "1012:   } else if (dhcp->yiaddr != htonl(INADDR_ANY)) {",
          "1013:    packet->dst_ipaddr.ipaddr.ip4addr.s_addr = dhcp->yiaddr;",
          "1022:   if (packet->src_ipaddr.ipaddr.ip4addr.s_addr == htonl(INADDR_BROADCAST)) {",
          "1023:    packet->src_ipaddr.ipaddr.ip4addr.s_addr = htonl(INADDR_ANY);",
          "1024:   }",
          "1026:   memset(packet->data, 0, packet->data_len);",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "916:      packet->code - PW_DHCP_OFFSET);",
          "917:   }",
          "920:          name, (unsigned int) packet->id,",
          "921:          inet_ntop(packet->src_ipaddr.af,",
          "922:      &packet->src_ipaddr.ipaddr,",
          "",
          "[Removed Lines]",
          "919:   printf(\"Sending %s of id %08x from %s:%d to %s:%d\\n\",",
          "",
          "[Added Lines]",
          "1042:   DEBUG(\"Sending %s of id %08x from %s:%d to %s:%d\",",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "945:  }",
          "",
          "[Removed Lines]",
          "940:  vp = pairfind(original->vps, DHCP2ATTR(57));",
          "941:  if (vp && (vp->vp_integer > mms)) {",
          "942:   mms = vp->vp_integer;",
          "944:   if (mms > MAX_PACKET_SIZE) mms = MAX_PACKET_SIZE;",
          "",
          "[Added Lines]",
          "1059:  if (original) {",
          "1065:   vp = pairfind(original->vps, DHCP2ATTR(57));",
          "1066:   if (vp && (vp->vp_integer > mms)) {",
          "1067:    mms = vp->vp_integer;",
          "1069:    if (mms > MAX_PACKET_SIZE) mms = MAX_PACKET_SIZE;",
          "1070:   }",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "986:     vp->length = 11 + 8;",
          "987:    }",
          "990:     vp->vp_octets[0]);",
          "991:   }",
          "992:  }",
          "",
          "[Removed Lines]",
          "989:    fprintf(stderr, \"DHCP-Authentication %d unsupported\\n\",",
          "",
          "[Added Lines]",
          "1115:    fr_strerror_printf(\"DHCP-Authentication %d unsupported\",",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "998:  }",
          "1004:   lvalue = fr_rand();",
          "1005:   memcpy(p, &lvalue, 4);",
          "1008:  }",
          "1009:  p += 4;",
          "1012:  p += 2;",
          "",
          "[Removed Lines]",
          "1006:  } else {",
          "1007:   memcpy(p, original->data + 4, 4);",
          "",
          "[Added Lines]",
          "1130:   memcpy(p, original->data + 4, 4);",
          "1131:  } else {",
          "1140:  if (original) {",
          "1142:  }",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "1047:  p += 4;",
          "1050:  p += 4;",
          "1053:  p += DHCP_CHADDR_LEN;",
          "",
          "[Removed Lines]",
          "1052:  memcpy(p, original->data + 28, DHCP_CHADDR_LEN);",
          "",
          "[Added Lines]",
          "1177:  if (original) {",
          "1179:  } else {",
          "1180:   vp = pairfind(packet->vps, DHCP2ATTR(266));",
          "1181:   if (vp) {",
          "1182:    lvalue = vp->vp_ipaddr;",
          "1183:   } else {",
          "1184:    lvalue = htonl(INADDR_NONE);",
          "1185:   }",
          "1186:   memcpy(p, &lvalue, 4);",
          "1187:  }",
          "1190:  if (original) {",
          "1191:   memcpy(p, original->data + 28, DHCP_CHADDR_LEN);",
          "1192:  } else {",
          "1193:   vp = pairfind(packet->vps, DHCP2ATTR(267));",
          "1194:   if (vp) {",
          "1195:    if (vp->length > DHCP_CHADDR_LEN) {",
          "1196:     memcpy(p, vp->vp_octets, DHCP_CHADDR_LEN);",
          "1197:    } else {",
          "1198:     memcpy(p, vp->vp_octets, vp->length);",
          "1199:    }",
          "1200:   }",
          "1201:  }",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "1070:   for (i = 0; i < 14; i++) {",
          "1071:    vp = pairmake(dhcp_header_names[i], NULL, T_OP_EQ);",
          "1072:    if (!vp) {",
          "1074:     return -1;",
          "1075:    }",
          "",
          "[Removed Lines]",
          "1073:     fprintf(stderr, \"Parse error %s\\n\", fr_strerror());",
          "",
          "[Added Lines]",
          "1222:     fr_strerror_printf(\"Parse error %s\", fr_strerror());",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "1113:     break;",
          "1115:    default:",
          "1117:     pairfree(&vp);",
          "1118:     break;",
          "1119:    }",
          "",
          "[Removed Lines]",
          "1116:     fprintf(stderr, \"Internal sanity check failed %d %d\\n\", vp->type, __LINE__);",
          "",
          "[Added Lines]",
          "1265:     fr_strerror_printf(\"Internal sanity check failed %d %d\", vp->type, __LINE__);",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "1121:    p += dhcp_header_sizes[i];",
          "1123:    vp_prints(buffer, sizeof(buffer), vp);",
          "1125:    pairfree(&vp);",
          "1126:   }",
          "",
          "[Removed Lines]",
          "1124:    fprintf(stderr, \"\\t%s\\n\", buffer);",
          "",
          "[Added Lines]",
          "1273:    fr_strerror_printf(\"\\t%s\", buffer);",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "1211:   for (i = 0; i < num_entries; i++) {",
          "1212:    if (fr_debug_flag > 1) {",
          "1213:     vp_prints(buffer, sizeof(buffer), vp);",
          "1215:    }",
          "1217:    length = fr_dhcp_vp2attr(vp, p, 0);",
          "",
          "[Removed Lines]",
          "1214:     fprintf(stderr, \"\\t%s\\n\", buffer);",
          "",
          "[Added Lines]",
          "1363:     fr_strerror_printf(\"\\t%s\", buffer);",
          "1364:    }",
          "1366:    if (vp->flags.is_tlv) {",
          "1367:     VALUE_PAIR *tlv = fr_dhcp_vp2suboption(vp);",
          "1368:     if (vp) {",
          "1369:      tlv->next = vp->next;",
          "1370:      vp->next = tlv;",
          "1371:     }",
          "1376:     vp = vp->next;",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "1223:    if (length > 255) {",
          "1225:     break;",
          "1226:    }",
          "",
          "[Removed Lines]",
          "1224:     fprintf(stderr, \"WARNING Ignoring too long attribute %s!\\n\", vp->name);",
          "",
          "[Added Lines]",
          "1386:     fr_strerror_printf(\"WARNING Ignoring too long attribute %s!\", vp->name);",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "1234:    if ((*plength + length) > 255) {",
          "1236:     break;",
          "1237:    }",
          "",
          "[Removed Lines]",
          "1235:     fprintf(stderr, \"WARNING Ignoring too long attribute %s!\\n\", vp->name);",
          "",
          "[Added Lines]",
          "1397:     fr_strerror_printf(\"WARNING Ignoring too long attribute %s!\", vp->name);",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "1244:     vp = vp->next;",
          "1251:  next:",
          "1252:   vp = vp->next;",
          "1253:  }",
          "",
          "[Removed Lines]",
          "1247:   if (DHCP_BASE_ATTR(vp->attribute) == PW_DHCP_OPTION_82) {",
          "1248:    plength[2] = plength[0] - 2;",
          "1249:   }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "1273:  packet->data_len = dhcp_size;",
          "1284:  if (packet->data_len < DEFAULT_PACKET_SIZE) {",
          "1285:   memset(packet->data + packet->data_len, 0,",
          "",
          "[Removed Lines]",
          "1280:  packet->src_ipaddr = original->dst_ipaddr;",
          "1282:  packet->sockfd = original->sockfd;",
          "",
          "[Added Lines]",
          "1433:  if (original) {",
          "1439:   packet->src_ipaddr = original->dst_ipaddr;",
          "1441:   packet->sockfd = original->sockfd;",
          "1442:  }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "222e4c1d35e0a3969806b84b96734cb17205f0a6",
      "candidate_info": {
        "commit_hash": "222e4c1d35e0a3969806b84b96734cb17205f0a6",
        "repo": "alandekok/freeradius-server",
        "commit_url": "https://github.com/alandekok/freeradius-server/commit/222e4c1d35e0a3969806b84b96734cb17205f0a6",
        "files": [
          "src/lib/dhcp.c"
        ],
        "message": "Print all decoded TLVs, not just the first one.",
        "before_after_code_files": [
          "src/lib/dhcp.c||src/lib/dhcp.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/lib/dhcp.c||src/lib/dhcp.c"
          ],
          "candidate": [
            "src/lib/dhcp.c||src/lib/dhcp.c"
          ]
        }
      },
      "candidate_diff": {
        "src/lib/dhcp.c||src/lib/dhcp.c": [
          "File: src/lib/dhcp.c -> src/lib/dhcp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "707:      return -1;",
          "708:    }",
          "713:    p += alen;",
          "",
          "[Removed Lines]",
          "710:    debug_pair(vp);",
          "712:    while (*tail) tail = &(*tail)->next;",
          "",
          "[Added Lines]",
          "711:    while (*tail) {",
          "712:     debug_pair(*tail);",
          "713:     tail = &(*tail)->next;",
          "714:    }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "a81cd3910b220aeae6cc0611082261d06fe95b80",
      "candidate_info": {
        "commit_hash": "a81cd3910b220aeae6cc0611082261d06fe95b80",
        "repo": "alandekok/freeradius-server",
        "commit_url": "https://github.com/alandekok/freeradius-server/commit/a81cd3910b220aeae6cc0611082261d06fe95b80",
        "files": [
          "src/lib/dhcp.c"
        ],
        "message": "Fix endless loop when there are multiple DHCP options",
        "before_after_code_files": [
          "src/lib/dhcp.c||src/lib/dhcp.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "diff_branch_message": 1,
        "olp_code_files": {
          "patch": [
            "src/lib/dhcp.c||src/lib/dhcp.c"
          ],
          "candidate": [
            "src/lib/dhcp.c||src/lib/dhcp.c"
          ]
        }
      },
      "candidate_diff": {
        "src/lib/dhcp.c||src/lib/dhcp.c": [
          "File: src/lib/dhcp.c -> src/lib/dhcp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "714:    }",
          "718:    p += alen;",
          "",
          "[Removed Lines]",
          "717:    while (*tail) tail = &vp->next;",
          "",
          "[Added Lines]",
          "717:    while (*tail) tail = &(*tail)->next;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
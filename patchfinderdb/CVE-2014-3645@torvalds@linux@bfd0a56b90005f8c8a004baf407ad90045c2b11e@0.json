{
  "cve_id": "CVE-2014-3645",
  "cve_desc": "arch/x86/kvm/vmx.c in the KVM subsystem in the Linux kernel before 3.12 does not have an exit handler for the INVEPT instruction, which allows guest OS users to cause a denial of service (guest OS crash) via a crafted application.",
  "repo": "torvalds/linux",
  "patch_hash": "bfd0a56b90005f8c8a004baf407ad90045c2b11e",
  "patch_info": {
    "commit_hash": "bfd0a56b90005f8c8a004baf407ad90045c2b11e",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/bfd0a56b90005f8c8a004baf407ad90045c2b11e",
    "files": [
      "arch/x86/include/asm/vmx.h",
      "arch/x86/include/uapi/asm/vmx.h",
      "arch/x86/kvm/mmu.c",
      "arch/x86/kvm/vmx.c"
    ],
    "message": "nEPT: Nested INVEPT\n\nIf we let L1 use EPT, we should probably also support the INVEPT instruction.\n\nIn our current nested EPT implementation, when L1 changes its EPT table\nfor L2 (i.e., EPT12), L0 modifies the shadow EPT table (EPT02), and in\nthe course of this modification already calls INVEPT. But if last level\nof shadow page is unsync not all L1's changes to EPT12 are intercepted,\nwhich means roots need to be synced when L1 calls INVEPT. Global INVEPT\nshould not be different since roots are synced by kvm_mmu_load() each\ntime EPTP02 changes.\n\nReviewed-by: Xiao Guangrong <xiaoguangrong@linux.vnet.ibm.com>\nSigned-off-by: Nadav Har'El <nyh@il.ibm.com>\nSigned-off-by: Jun Nakajima <jun.nakajima@intel.com>\nSigned-off-by: Xinhao Xu <xinhao.xu@intel.com>\nSigned-off-by: Yang Zhang <yang.z.zhang@Intel.com>\nSigned-off-by: Gleb Natapov <gleb@redhat.com>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>",
    "before_after_code_files": [
      "arch/x86/include/asm/vmx.h||arch/x86/include/asm/vmx.h",
      "arch/x86/include/uapi/asm/vmx.h||arch/x86/include/uapi/asm/vmx.h",
      "arch/x86/kvm/mmu.c||arch/x86/kvm/mmu.c",
      "arch/x86/kvm/vmx.c||arch/x86/kvm/vmx.c"
    ]
  },
  "patch_diff": {
    "arch/x86/include/asm/vmx.h||arch/x86/include/asm/vmx.h": [
      "File: arch/x86/include/asm/vmx.h -> arch/x86/include/asm/vmx.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "387: #define VMX_EPT_EXTENT_INDIVIDUAL_ADDR  0",
      "388: #define VMX_EPT_EXTENT_CONTEXT   1",
      "389: #define VMX_EPT_EXTENT_GLOBAL   2",
      "391: #define VMX_EPT_EXECUTE_ONLY_BIT  (1ull)",
      "392: #define VMX_EPT_PAGE_WALK_4_BIT   (1ull << 6)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "390: #define VMX_EPT_EXTENT_SHIFT   24",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "394: #define VMX_EPTP_WB_BIT    (1ull << 14)",
      "395: #define VMX_EPT_2MB_PAGE_BIT   (1ull << 16)",
      "396: #define VMX_EPT_1GB_PAGE_BIT   (1ull << 17)",
      "397: #define VMX_EPT_AD_BIT        (1ull << 21)",
      "398: #define VMX_EPT_EXTENT_CONTEXT_BIT  (1ull << 25)",
      "399: #define VMX_EPT_EXTENT_GLOBAL_BIT  (1ull << 26)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "398: #define VMX_EPT_INVEPT_BIT   (1ull << 20)",
      "",
      "---------------"
    ],
    "arch/x86/include/uapi/asm/vmx.h||arch/x86/include/uapi/asm/vmx.h": [
      "File: arch/x86/include/uapi/asm/vmx.h -> arch/x86/include/uapi/asm/vmx.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "65: #define EXIT_REASON_EOI_INDUCED         45",
      "66: #define EXIT_REASON_EPT_VIOLATION       48",
      "67: #define EXIT_REASON_EPT_MISCONFIG       49",
      "68: #define EXIT_REASON_PREEMPTION_TIMER    52",
      "69: #define EXIT_REASON_WBINVD              54",
      "70: #define EXIT_REASON_XSETBV              55",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "68: #define EXIT_REASON_INVEPT              50",
      "",
      "---------------"
    ],
    "arch/x86/kvm/mmu.c||arch/x86/kvm/mmu.c": [
      "File: arch/x86/kvm/mmu.c -> arch/x86/kvm/mmu.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "3182:  mmu_sync_roots(vcpu);",
      "3183:  spin_unlock(&vcpu->kvm->mmu_lock);",
      "3184: }",
      "3186: static gpa_t nonpaging_gva_to_gpa(struct kvm_vcpu *vcpu, gva_t vaddr,",
      "3187:       u32 access, struct x86_exception *exception)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "3185: EXPORT_SYMBOL_GPL(kvm_mmu_sync_roots);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "3451:  ++vcpu->stat.tlb_flush;",
      "3452:  kvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);",
      "3453: }",
      "3455: static void paging_new_cr3(struct kvm_vcpu *vcpu)",
      "3456: {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "3455: EXPORT_SYMBOL_GPL(kvm_mmu_flush_tlb);",
      "",
      "---------------"
    ],
    "arch/x86/kvm/vmx.c||arch/x86/kvm/vmx.c": [
      "File: arch/x86/kvm/vmx.c -> arch/x86/kvm/vmx.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "712:  kvm_release_page_clean(page);",
      "713: }",
      "715: static u64 construct_eptp(unsigned long root_hpa);",
      "716: static void kvm_cpu_vmxon(u64 addr);",
      "717: static void kvm_cpu_vmxoff(void);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "715: static unsigned long nested_ept_get_cr3(struct kvm_vcpu *vcpu);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "2161: static u32 nested_vmx_exit_ctls_low, nested_vmx_exit_ctls_high;",
      "2162: static u32 nested_vmx_entry_ctls_low, nested_vmx_entry_ctls_high;",
      "2163: static u32 nested_vmx_misc_low, nested_vmx_misc_high;",
      "2164: static __init void nested_vmx_setup_ctls_msrs(void)",
      "2165: {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2165: static u32 nested_vmx_ept_caps;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "6279:  return 1;",
      "6280: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "6285: static int handle_invept(struct kvm_vcpu *vcpu)",
      "6286: {",
      "6287:  u32 vmx_instruction_info, types;",
      "6288:  unsigned long type;",
      "6289:  gva_t gva;",
      "6290:  struct x86_exception e;",
      "6291:  struct {",
      "6292:   u64 eptp, gpa;",
      "6293:  } operand;",
      "6294:  u64 eptp_mask = ((1ull << 51) - 1) & PAGE_MASK;",
      "6296:  if (!(nested_vmx_secondary_ctls_high & SECONDARY_EXEC_ENABLE_EPT) ||",
      "6297:      !(nested_vmx_ept_caps & VMX_EPT_INVEPT_BIT)) {",
      "6298:   kvm_queue_exception(vcpu, UD_VECTOR);",
      "6299:   return 1;",
      "6300:  }",
      "6302:  if (!nested_vmx_check_permission(vcpu))",
      "6303:   return 1;",
      "6305:  if (!kvm_read_cr0_bits(vcpu, X86_CR0_PE)) {",
      "6306:   kvm_queue_exception(vcpu, UD_VECTOR);",
      "6307:   return 1;",
      "6308:  }",
      "6310:  vmx_instruction_info = vmcs_read32(VMX_INSTRUCTION_INFO);",
      "6311:  type = kvm_register_read(vcpu, (vmx_instruction_info >> 28) & 0xf);",
      "6313:  types = (nested_vmx_ept_caps >> VMX_EPT_EXTENT_SHIFT) & 6;",
      "6315:  if (!(types & (1UL << type))) {",
      "6316:   nested_vmx_failValid(vcpu,",
      "6317:     VMXERR_INVALID_OPERAND_TO_INVEPT_INVVPID);",
      "6318:   return 1;",
      "6319:  }",
      "6324:  if (get_vmx_mem_address(vcpu, vmcs_readl(EXIT_QUALIFICATION),",
      "6325:    vmx_instruction_info, &gva))",
      "6326:   return 1;",
      "6327:  if (kvm_read_guest_virt(&vcpu->arch.emulate_ctxt, gva, &operand,",
      "6328:     sizeof(operand), &e)) {",
      "6329:   kvm_inject_page_fault(vcpu, &e);",
      "6330:   return 1;",
      "6331:  }",
      "6333:  switch (type) {",
      "6334:  case VMX_EPT_EXTENT_CONTEXT:",
      "6335:   if ((operand.eptp & eptp_mask) !=",
      "6336:     (nested_ept_get_cr3(vcpu) & eptp_mask))",
      "6337:    break;",
      "6338:  case VMX_EPT_EXTENT_GLOBAL:",
      "6339:   kvm_mmu_sync_roots(vcpu);",
      "6340:   kvm_mmu_flush_tlb(vcpu);",
      "6341:   nested_vmx_succeed(vcpu);",
      "6342:   break;",
      "6343:  default:",
      "6344:   BUG_ON(1);",
      "6345:   break;",
      "6346:  }",
      "6348:  skip_emulated_instruction(vcpu);",
      "6349:  return 1;",
      "6350: }",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "6323:  [EXIT_REASON_PAUSE_INSTRUCTION]       = handle_pause,",
      "6324:  [EXIT_REASON_MWAIT_INSTRUCTION]       = handle_invalid_op,",
      "6325:  [EXIT_REASON_MONITOR_INSTRUCTION]     = handle_invalid_op,",
      "6326: };",
      "6328: static const int kvm_vmx_max_exit_handlers =",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "6396:  [EXIT_REASON_INVEPT]                  = handle_invept,",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "6549:  case EXIT_REASON_VMPTRST: case EXIT_REASON_VMREAD:",
      "6550:  case EXIT_REASON_VMRESUME: case EXIT_REASON_VMWRITE:",
      "6551:  case EXIT_REASON_VMOFF: case EXIT_REASON_VMON:",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "6623:  case EXIT_REASON_INVEPT:",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "27e6fb5dae2819d17f38dc9224692b771e989981",
      "candidate_info": {
        "commit_hash": "27e6fb5dae2819d17f38dc9224692b771e989981",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/27e6fb5dae2819d17f38dc9224692b771e989981",
        "files": [
          "arch/x86/kvm/vmx.c",
          "arch/x86/kvm/x86.h"
        ],
        "message": "KVM: vmx: vmx instructions handling does not consider cs.l\n\nVMX instructions use 32-bit operands in 32-bit mode, and 64-bit operands in\n64-bit mode.  The current implementation is broken since it does not use the\nregister operands correctly, and always uses 64-bit for reads and writes.\nMoreover, write to memory in vmwrite only considers long-mode, so it ignores\ncs.l. This patch fixes this behavior.\n\nSigned-off-by: Nadav Amit <namit@cs.technion.ac.il>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>",
        "before_after_code_files": [
          "arch/x86/kvm/vmx.c||arch/x86/kvm/vmx.c",
          "arch/x86/kvm/x86.h||arch/x86/kvm/x86.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "arch/x86/kvm/vmx.c||arch/x86/kvm/vmx.c"
          ],
          "candidate": [
            "arch/x86/kvm/vmx.c||arch/x86/kvm/vmx.c"
          ]
        }
      },
      "candidate_diff": {
        "arch/x86/kvm/vmx.c||arch/x86/kvm/vmx.c": [
          "File: arch/x86/kvm/vmx.c -> arch/x86/kvm/vmx.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "6403:   return 1;",
          "6408:  if (!vmcs12_read_any(vcpu, field, &field_value)) {",
          "6409:   nested_vmx_failValid(vcpu, VMXERR_UNSUPPORTED_VMCS_COMPONENT);",
          "",
          "[Removed Lines]",
          "6406:  field = kvm_register_read(vcpu, (((vmx_instruction_info) >> 28) & 0xf));",
          "",
          "[Added Lines]",
          "6406:  field = kvm_register_readl(vcpu, (((vmx_instruction_info) >> 28) & 0xf));",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "6418:  if (vmx_instruction_info & (1u << 10)) {",
          "6420:    field_value);",
          "6421:  } else {",
          "6422:   if (get_vmx_mem_address(vcpu, exit_qualification,",
          "",
          "[Removed Lines]",
          "6419:   kvm_register_write(vcpu, (((vmx_instruction_info) >> 3) & 0xf),",
          "",
          "[Added Lines]",
          "6419:   kvm_register_writel(vcpu, (((vmx_instruction_info) >> 3) & 0xf),",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "6453:   return 1;",
          "6455:  if (vmx_instruction_info & (1u << 10))",
          "6457:    (((vmx_instruction_info) >> 3) & 0xf));",
          "6458:  else {",
          "6459:   if (get_vmx_mem_address(vcpu, exit_qualification,",
          "6460:     vmx_instruction_info, &gva))",
          "6461:    return 1;",
          "6462:   if (kvm_read_guest_virt(&vcpu->arch.emulate_ctxt, gva,",
          "6464:    kvm_inject_page_fault(vcpu, &e);",
          "6465:    return 1;",
          "6466:   }",
          "6467:  }",
          "6471:  if (vmcs_field_readonly(field)) {",
          "6472:   nested_vmx_failValid(vcpu,",
          "6473:    VMXERR_VMWRITE_READ_ONLY_VMCS_COMPONENT);",
          "",
          "[Removed Lines]",
          "6456:   field_value = kvm_register_read(vcpu,",
          "6463:       &field_value, (is_long_mode(vcpu) ? 8 : 4), &e)) {",
          "6470:  field = kvm_register_read(vcpu, (((vmx_instruction_info) >> 28) & 0xf));",
          "",
          "[Added Lines]",
          "6456:   field_value = kvm_register_readl(vcpu,",
          "6463:       &field_value, (is_64_bit_mode(vcpu) ? 8 : 4), &e)) {",
          "6470:  field = kvm_register_readl(vcpu, (((vmx_instruction_info) >> 28) & 0xf));",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "6590:  }",
          "6592:  vmx_instruction_info = vmcs_read32(VMX_INSTRUCTION_INFO);",
          "6595:  types = (nested_vmx_ept_caps >> VMX_EPT_EXTENT_SHIFT) & 6;",
          "",
          "[Removed Lines]",
          "6593:  type = kvm_register_read(vcpu, (vmx_instruction_info >> 28) & 0xf);",
          "",
          "[Added Lines]",
          "6593:  type = kvm_register_readl(vcpu, (vmx_instruction_info >> 28) & 0xf);",
          "",
          "---------------"
        ],
        "arch/x86/kvm/x86.h||arch/x86/kvm/x86.h": [
          "File: arch/x86/kvm/x86.h -> arch/x86/kvm/x86.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "126:  return is_64_bit_mode(vcpu) ? val : (u32)val;",
          "127: }",
          "129: void kvm_before_handle_nmi(struct kvm_vcpu *vcpu);",
          "130: void kvm_after_handle_nmi(struct kvm_vcpu *vcpu);",
          "131: int kvm_inject_realmode_interrupt(struct kvm_vcpu *vcpu, int irq, int inc_eip);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "129: static inline void kvm_register_writel(struct kvm_vcpu *vcpu,",
          "130:            enum kvm_reg reg,",
          "131:            unsigned long val)",
          "132: {",
          "133:  if (!is_64_bit_mode(vcpu))",
          "134:   val = (u32)val;",
          "135:  return kvm_register_write(vcpu, reg, val);",
          "136: }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
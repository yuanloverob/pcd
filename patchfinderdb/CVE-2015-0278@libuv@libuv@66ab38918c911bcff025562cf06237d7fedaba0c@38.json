{
  "cve_id": "CVE-2015-0278",
  "cve_desc": "libuv before 0.10.34 does not properly drop group privileges, which allows context-dependent attackers to gain privileges via unspecified vectors.",
  "repo": "libuv/libuv",
  "patch_hash": "66ab38918c911bcff025562cf06237d7fedaba0c",
  "patch_info": {
    "commit_hash": "66ab38918c911bcff025562cf06237d7fedaba0c",
    "repo": "libuv/libuv",
    "commit_url": "https://github.com/libuv/libuv/commit/66ab38918c911bcff025562cf06237d7fedaba0c",
    "files": [
      "src/unix/process.c"
    ],
    "message": "unix: call setgoups before calling setuid/setgid\n\nPartial fix for #1093",
    "before_after_code_files": [
      "src/unix/process.c||src/unix/process.c"
    ]
  },
  "patch_diff": {
    "src/unix/process.c||src/unix/process.c": [
      "File: src/unix/process.c -> src/unix/process.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "330:     _exit(127);",
      "331:   }",
      "333:   if ((options->flags & UV_PROCESS_SETGID) && setgid(options->gid)) {",
      "334:     uv__write_int(error_fd, -errno);",
      "335:     perror(\"setgid()\");",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "333:   if (options->flags & (UV_PROCESS_SETUID | UV_PROCESS_SETGID)) {",
      "341:     SAVE_ERRNO(setgroups(0, NULL));",
      "342:   }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "4a023fc0786780d254e1e4a34a983c36f59d99bf",
      "candidate_info": {
        "commit_hash": "4a023fc0786780d254e1e4a34a983c36f59d99bf",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/4a023fc0786780d254e1e4a34a983c36f59d99bf",
        "files": [
          "include/uv-errno.h",
          "include/uv.h"
        ],
        "message": "unix, windows: map ENOPROTOOPT errno\n\nFixes #1143",
        "before_after_code_files": [
          "include/uv-errno.h||include/uv-errno.h",
          "include/uv.h||include/uv.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "include/uv-errno.h||include/uv-errno.h": [
          "File: include/uv-errno.h -> include/uv-errno.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "376: # define UV__EFBIG (-4036)",
          "377: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "379: #if defined(ENOPROTOOPT) && !defined(_WIN32)",
          "380: # define UV__ENOPROTOOPT (-ENOPROTOOPT)",
          "381: #else",
          "382: # define UV__ENOPROTOOPT (-4035)",
          "383: #endif",
          "",
          "---------------"
        ],
        "include/uv.h||include/uv.h": [
          "File: include/uv.h -> include/uv.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "114:   XX(ENOENT, \"no such file or directory\")                                     \\",
          "115:   XX(ENOMEM, \"not enough memory\")                                             \\",
          "116:   XX(ENONET, \"machine is not on the network\")                                 \\",
          "117:   XX(ENOSPC, \"no space left on device\")                                       \\",
          "118:   XX(ENOSYS, \"function not implemented\")                                      \\",
          "119:   XX(ENOTCONN, \"socket is not connected\")                                     \\",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "117:   XX(ENOPROTOOPT, \"protocol not available\")                                   \\",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "17d60e3f94f4b122f6412e78b10e40573637dfa1",
      "candidate_info": {
        "commit_hash": "17d60e3f94f4b122f6412e78b10e40573637dfa1",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/17d60e3f94f4b122f6412e78b10e40573637dfa1",
        "files": [
          "include/uv.h",
          "src/unix/stream.c",
          "src/win/stream.c",
          "test/test-tcp-try-write.c"
        ],
        "message": "stream: allow multiple buffers for uv_try_write",
        "before_after_code_files": [
          "include/uv.h||include/uv.h",
          "src/unix/stream.c||src/unix/stream.c",
          "src/win/stream.c||src/win/stream.c",
          "test/test-tcp-try-write.c||test/test-tcp-try-write.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "include/uv.h||include/uv.h": [
          "File: include/uv.h -> include/uv.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "687: struct uv_write_s {",
          "",
          "[Removed Lines]",
          "684: UV_EXTERN int uv_try_write(uv_stream_t* handle, const char* buf, size_t length);",
          "",
          "[Added Lines]",
          "684: UV_EXTERN int uv_try_write(uv_stream_t* handle,",
          "685:                            const uv_buf_t bufs[],",
          "686:                            unsigned int nbufs);",
          "",
          "---------------"
        ],
        "src/unix/stream.c||src/unix/stream.c": [
          "File: src/unix/stream.c -> src/unix/stream.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1305: }",
          "1309:   int r;",
          "1310:   int has_pollout;",
          "1311:   size_t written;",
          "1312:   size_t req_size;",
          "1313:   uv_write_t req;",
          "1317:   if (stream->connect_req != NULL || stream->write_queue_size != 0)",
          "",
          "[Removed Lines]",
          "1308: int uv_try_write(uv_stream_t* stream, const char* buf, size_t size) {",
          "1314:   uv_buf_t bufstruct;",
          "",
          "[Added Lines]",
          "1308: int uv_try_write(uv_stream_t* stream,",
          "1309:                  const uv_buf_t bufs[],",
          "1310:                  unsigned int nbufs) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1320:   has_pollout = uv__io_active(&stream->io_watcher, UV__POLLOUT);",
          "1324:   if (r != 0)",
          "1325:     return r;",
          "1329:   if (req.bufs != NULL)",
          "1330:     req_size = uv__write_req_size(&req);",
          "1331:   else",
          "",
          "[Removed Lines]",
          "1322:   bufstruct = uv_buf_init((char*) buf, size);",
          "1323:   r = uv_write(&req, stream, &bufstruct, 1, uv_try_write_cb);",
          "1328:   written = size;",
          "",
          "[Added Lines]",
          "1323:   r = uv_write(&req, stream, bufs, nbufs, uv_try_write_cb);",
          "1328:   written = uv_count_bufs(bufs, nbufs);",
          "",
          "---------------"
        ],
        "src/win/stream.c||src/win/stream.c": [
          "File: src/win/stream.c -> src/win/stream.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "202: }",
          "207:   return UV_ENOSYS;",
          "208: }",
          "",
          "[Removed Lines]",
          "205: int uv_try_write(uv_stream_t* handle, const char* buf, size_t length) {",
          "",
          "[Added Lines]",
          "205: int uv_try_write(uv_stream_t* stream,",
          "206:                  const uv_buf_t bufs[],",
          "207:                  unsigned int nbufs) {",
          "",
          "---------------"
        ],
        "test/test-tcp-try-write.c||test/test-tcp-try-write.c": [
          "File: test/test-tcp-try-write.c -> test/test-tcp-try-write.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "61:   connect_cb_called++;",
          "63:   do {",
          "65:     ASSERT(r >= 0);",
          "66:     bytes_written += r;",
          "",
          "[Removed Lines]",
          "64:     r = uv_try_write((uv_stream_t*) &client, zeroes, sizeof(zeroes));",
          "",
          "[Added Lines]",
          "64:     buf = uv_buf_init(zeroes, sizeof(zeroes));",
          "65:     r = uv_try_write((uv_stream_t*) &client, &buf, 1);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "24bfef2ef4b5ac3e47f037f0f6759ad63b5d1e96",
      "candidate_info": {
        "commit_hash": "24bfef2ef4b5ac3e47f037f0f6759ad63b5d1e96",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/24bfef2ef4b5ac3e47f037f0f6759ad63b5d1e96",
        "files": [
          "Makefile.am",
          "src/unix/linux-core.c",
          "test/test-close-fd.c",
          "test/test-list.h",
          "uv.gyp"
        ],
        "message": "linux: handle EPOLLHUP without EPOLLIN/EPOLLOUT\n\nWork around an epoll quirk where it sometimes reports just the EPOLLERR\nor EPOLLHUP event.  In order to force the event loop to move forward,\nwe merge in the read/write events that the watcher is interested in;\nuv__read() and uv__write() will then deal with the error or hangup in\nthe usual fashion.\n\nFixes #982.",
        "before_after_code_files": [
          "Makefile.am||Makefile.am",
          "src/unix/linux-core.c||src/unix/linux-core.c",
          "test/test-close-fd.c||test/test-close-fd.c",
          "test/test-list.h||test/test-list.h",
          "uv.gyp||uv.gyp"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Makefile.am||Makefile.am": [
          "File: Makefile.am -> Makefile.am",
          "--- Hunk 1 ---",
          "[Context before]",
          "118:                          test/test-barrier.c \\",
          "119:                          test/test-callback-order.c \\",
          "120:                          test/test-callback-stack.c \\",
          "121:                          test/test-close-order.c \\",
          "122:                          test/test-condvar.c \\",
          "123:                          test/test-connection-fail.c \\",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "121:                          test/test-close-fd.c \\",
          "",
          "---------------"
        ],
        "src/unix/linux-core.c||src/unix/linux-core.c": [
          "File: src/unix/linux-core.c -> src/unix/linux-core.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "113:   uv__io_t* w;",
          "114:   uint64_t base;",
          "115:   uint64_t diff;",
          "117:   int nevents;",
          "118:   int count;",
          "119:   int nfds;",
          "",
          "[Removed Lines]",
          "116:   unsigned int masked_events;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "217:         continue;",
          "218:       }",
          "230:     }",
          "232:     if (nevents != 0) {",
          "",
          "[Removed Lines]",
          "226:       masked_events = pe->events & w->pevents;",
          "227:       if (masked_events != 0)",
          "228:         w->cb(loop, w, masked_events);",
          "229:       nevents++;",
          "",
          "[Added Lines]",
          "224:       pe->events &= w->pevents | UV__POLLERR | UV__POLLHUP;",
          "241:       if (pe->events == UV__EPOLLERR || pe->events == UV__EPOLLHUP)",
          "242:         pe->events |= w->pevents & (UV__EPOLLIN | UV__EPOLLOUT);",
          "244:       if (pe->events != 0) {",
          "245:         w->cb(loop, w, pe->events);",
          "246:         nevents++;",
          "247:       }",
          "",
          "---------------"
        ],
        "test/test-close-fd.c||test/test-close-fd.c": [
          "File: test/test-close-fd.c -> test/test-close-fd.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "22: #if !defined(_WIN32)",
          "24: #include \"uv.h\"",
          "25: #include \"task.h\"",
          "26: #include <fcntl.h>",
          "27: #include <unistd.h>",
          "29: static unsigned int read_cb_called;",
          "31: static void alloc_cb(uv_handle_t *handle, size_t size, uv_buf_t *buf) {",
          "32:   static char slab[1];",
          "33:   buf->base = slab;",
          "34:   buf->len = sizeof(slab);",
          "35: }",
          "37: static void read_cb(uv_stream_t *handle, ssize_t nread, const uv_buf_t *buf) {",
          "38:   switch (++read_cb_called) {",
          "39:   case 1:",
          "40:     ASSERT(nread == 1);",
          "41:     uv_read_stop(handle);",
          "42:     break;",
          "43:   case 2:",
          "44:     ASSERT(nread == UV_EOF);",
          "45:     uv_close((uv_handle_t *) handle, NULL);",
          "46:     break;",
          "47:   default:",
          "48:     ASSERT(!\"read_cb_called > 2\");",
          "49:   }",
          "50: }",
          "52: TEST_IMPL(close_fd) {",
          "53:   uv_pipe_t pipe_handle;",
          "54:   int fd[2];",
          "56:   ASSERT(0 == pipe(fd));",
          "57:   ASSERT(0 == fcntl(fd[0], F_SETFL, O_NONBLOCK));",
          "58:   ASSERT(0 == uv_pipe_init(uv_default_loop(), &pipe_handle, 0));",
          "59:   ASSERT(0 == uv_pipe_open(&pipe_handle, fd[0]));",
          "61:   ASSERT(1 == write(fd[1], \"\", 1));",
          "62:   ASSERT(0 == close(fd[1]));",
          "63:   fd[1] = -1;",
          "64:   ASSERT(0 == uv_read_start((uv_stream_t *) &pipe_handle, alloc_cb, read_cb));",
          "65:   ASSERT(0 == uv_run(uv_default_loop(), UV_RUN_DEFAULT));",
          "66:   ASSERT(1 == read_cb_called);",
          "67:   ASSERT(0 == uv_is_active((const uv_handle_t *) &pipe_handle));",
          "68:   ASSERT(0 == uv_read_start((uv_stream_t *) &pipe_handle, alloc_cb, read_cb));",
          "69:   ASSERT(0 == uv_run(uv_default_loop(), UV_RUN_DEFAULT));",
          "70:   ASSERT(2 == read_cb_called);",
          "71:   ASSERT(0 != uv_is_closing((const uv_handle_t *) &pipe_handle));",
          "73:   MAKE_VALGRIND_HAPPY();",
          "74:   return 0;",
          "75: }",
          "",
          "---------------"
        ],
        "test/test-list.h||test/test-list.h": [
          "File: test/test-list.h -> test/test-list.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "223: TEST_DECLARE   (listen_no_simultaneous_accepts)",
          "224: TEST_DECLARE   (fs_stat_root)",
          "225: #else",
          "226: TEST_DECLARE   (spawn_setuid_setgid)",
          "227: TEST_DECLARE   (we_get_signal)",
          "228: TEST_DECLARE   (we_get_signals)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "226: TEST_DECLARE   (close_fd)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "453:   TEST_ENTRY  (listen_no_simultaneous_accepts)",
          "454:   TEST_ENTRY  (fs_stat_root)",
          "455: #else",
          "456:   TEST_ENTRY  (spawn_setuid_setgid)",
          "457:   TEST_ENTRY  (we_get_signal)",
          "458:   TEST_ENTRY  (we_get_signals)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "457:   TEST_ENTRY  (close_fd)",
          "",
          "---------------"
        ],
        "uv.gyp||uv.gyp": [
          "File: uv.gyp -> uv.gyp",
          "--- Hunk 1 ---",
          "[Context before]",
          "302:         'test/test-async-null-cb.c',",
          "303:         'test/test-callback-stack.c',",
          "304:         'test/test-callback-order.c',",
          "305:         'test/test-close-order.c',",
          "306:         'test/test-connection-fail.c',",
          "307:         'test/test-cwd-and-chdir.c',",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "305:         'test/test-close-fd.c',",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "0943d3cb33e2c28afb8252759e7a2313c9ec8ce4",
      "candidate_info": {
        "commit_hash": "0943d3cb33e2c28afb8252759e7a2313c9ec8ce4",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/0943d3cb33e2c28afb8252759e7a2313c9ec8ce4",
        "files": [
          "src/win/pipe.c"
        ],
        "message": "win: minor error handle fix to uv_pipe_write_impl\n\nThis commit ensures a proper win32 error code is returned\nfrom uv_pipe_write_impl in case of failure.",
        "before_after_code_files": [
          "src/win/pipe.c||src/win/pipe.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/win/pipe.c||src/win/pipe.c": [
          "File: src/win/pipe.c -> src/win/pipe.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1174:                        NULL);",
          "1176:     if (!result) {",
          "1177:       return err;",
          "1178:     } else {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1177:       err = GetLastError();",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "0d435a56622c02e6164ce34cd820b2add44fadd8",
      "candidate_info": {
        "commit_hash": "0d435a56622c02e6164ce34cd820b2add44fadd8",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/0d435a56622c02e6164ce34cd820b2add44fadd8",
        "files": [
          "src/unix/pipe.c"
        ],
        "message": "unix: remove uv__pipe_accept()\n\nIt's basically a less advanced version of uv__server_io().  Drop the\nformer in favor of the latter.",
        "before_after_code_files": [
          "src/unix/pipe.c||src/unix/pipe.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/unix/pipe.c||src/unix/pipe.c": [
          "File: src/unix/pipe.c -> src/unix/pipe.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "29: #include <unistd.h>",
          "30: #include <stdlib.h>",
          "35: int uv_pipe_init(uv_loop_t* loop, uv_pipe_t* handle, int ipc) {",
          "36:   uv__stream_init(loop, (uv_stream_t*)handle, UV_NAMED_PIPE);",
          "",
          "[Removed Lines]",
          "32: static void uv__pipe_accept(uv_loop_t* loop, uv__io_t* w, unsigned int events);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "111:     return -errno;",
          "113:   handle->connection_cb = cb;",
          "115:   uv__io_start(handle->loop, &handle->io_watcher, UV__POLLIN);",
          "116:   return 0;",
          "117: }",
          "",
          "[Removed Lines]",
          "114:   handle->io_watcher.cb = uv__pipe_accept;",
          "",
          "[Added Lines]",
          "112:   handle->io_watcher.cb = uv__server_io;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "212: }",
          "239: void uv_pipe_pending_instances(uv_pipe_t* handle, int count) {",
          "240: }",
          "",
          "[Removed Lines]",
          "216: static void uv__pipe_accept(uv_loop_t* loop, uv__io_t* w, unsigned int events) {",
          "217:   uv_pipe_t* pipe;",
          "218:   int sockfd;",
          "220:   pipe = container_of(w, uv_pipe_t, io_watcher);",
          "221:   assert(pipe->type == UV_NAMED_PIPE);",
          "223:   sockfd = uv__accept(uv__stream_fd(pipe));",
          "224:   if (sockfd == -1) {",
          "225:     if (errno != EAGAIN && errno != EWOULDBLOCK)",
          "226:       pipe->connection_cb((uv_stream_t*)pipe, -errno);",
          "227:     return;",
          "228:   }",
          "230:   pipe->accepted_fd = sockfd;",
          "231:   pipe->connection_cb((uv_stream_t*)pipe, 0);",
          "232:   if (pipe->accepted_fd == sockfd) {",
          "234:     uv__io_stop(pipe->loop, &pipe->io_watcher, UV__POLLIN);",
          "235:   }",
          "236: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    }
  ]
}
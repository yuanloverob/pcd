{
  "cve_id": "CVE-2015-8324",
  "cve_desc": "The ext4 implementation in the Linux kernel before 2.6.34 does not properly track the initialization of certain data structures, which allows physically proximate attackers to cause a denial of service (NULL pointer dereference and panic) via a crafted USB device, related to the ext4_fill_super function.",
  "repo": "torvalds/linux",
  "patch_hash": "744692dc059845b2a3022119871846e74d4f6e11",
  "patch_info": {
    "commit_hash": "744692dc059845b2a3022119871846e74d4f6e11",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/744692dc059845b2a3022119871846e74d4f6e11",
    "files": [
      "fs/ext4/ext4.h",
      "fs/ext4/ext4_jbd2.h",
      "fs/ext4/extents.c",
      "fs/ext4/inode.c",
      "fs/ext4/super.c"
    ],
    "message": "ext4: use ext4_get_block_write in buffer write\n\nAllocate uninitialized extent before ext4 buffer write and\nconvert the extent to initialized after io completes.\nThe purpose is to make sure an extent can only be marked\ninitialized after it has been written with new data so\nwe can safely drop the i_mutex lock in ext4 DIO read without\nexposing stale data. This helps to improve multi-thread DIO\nread performance on high-speed disks.\n\nSkip the nobh and data=journal mount cases to make things simple for now.\n\nSigned-off-by: Jiaying Zhang <jiayingz@google.com>\nSigned-off-by: \"Theodore Ts'o\" <tytso@mit.edu>",
    "before_after_code_files": [
      "fs/ext4/ext4.h||fs/ext4/ext4.h",
      "fs/ext4/ext4_jbd2.h||fs/ext4/ext4_jbd2.h",
      "fs/ext4/extents.c||fs/ext4/extents.c",
      "fs/ext4/inode.c||fs/ext4/inode.c",
      "fs/ext4/super.c||fs/ext4/super.c"
    ]
  },
  "patch_diff": {
    "fs/ext4/ext4.h||fs/ext4/ext4.h": [
      "File: fs/ext4/ext4.h -> fs/ext4/ext4.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "361:       EXT4_GET_BLOCKS_CREATE_UNINIT_EXT)",
      "363: #define EXT4_GET_BLOCKS_IO_CONVERT_EXT  (EXT4_GET_BLOCKS_CONVERT|\\",
      "",
      "[Removed Lines]",
      "364:       EXT4_GET_BLOCKS_IO_CREATE_EXT)",
      "",
      "[Added Lines]",
      "364:       EXT4_GET_BLOCKS_CREATE_UNINIT_EXT)",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "704:  struct list_head i_completed_io_list;",
      "706:  ext4_io_end_t *cur_aio_dio;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "705:  spinlock_t i_completed_io_lock;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1781:         __u64 len, __u64 *moved_len);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1787: enum ext4_state_bits {",
      "1789:    = BH_JBDPrivateStart,",
      "1790: };",
      "1792: BUFFER_FNS(Uninit, uninit)",
      "1793: TAS_BUFFER_FNS(Uninit, uninit)",
      "",
      "---------------"
    ],
    "fs/ext4/ext4_jbd2.h||fs/ext4/ext4_jbd2.h": [
      "File: fs/ext4/ext4_jbd2.h -> fs/ext4/ext4_jbd2.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "304:  return 0;",
      "305: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "316: static inline int ext4_should_dioread_nolock(struct inode *inode)",
      "317: {",
      "318:  if (!test_opt(inode->i_sb, DIOREAD_NOLOCK))",
      "319:   return 0;",
      "320:  if (test_opt(inode->i_sb, NOBH))",
      "321:   return 0;",
      "322:  if (!S_ISREG(inode->i_mode))",
      "323:   return 0;",
      "324:  if (!(EXT4_I(inode)->i_flags & EXT4_EXTENTS_FL))",
      "325:   return 0;",
      "326:  if (ext4_should_journal_data(inode))",
      "327:   return 0;",
      "328:  return 1;",
      "329: }",
      "",
      "---------------"
    ],
    "fs/ext4/extents.c||fs/ext4/extents.c": [
      "File: fs/ext4/extents.c -> fs/ext4/extents.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1619:  BUG_ON(path[depth].p_hdr == NULL);",
      "1623:   && ext4_can_extents_be_merged(inode, ex, newext)) {",
      "1624:   ext_debug(\"append [%d]%d block to %d:[%d]%d (from %llu)\\n\",",
      "1625:     ext4_ext_is_uninitialized(newext),",
      "",
      "[Removed Lines]",
      "1622:  if (ex && (flag != EXT4_GET_BLOCKS_PRE_IO)",
      "",
      "[Added Lines]",
      "1622:  if (ex && !(flag & EXT4_GET_BLOCKS_PRE_IO)",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1741: merge:",
      "1744:   ext4_ext_try_to_merge(inode, path, nearex);",
      "",
      "[Removed Lines]",
      "1743:  if (flag != EXT4_GET_BLOCKS_PRE_IO)",
      "",
      "[Added Lines]",
      "1743:  if (!(flag & EXT4_GET_BLOCKS_PRE_IO))",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "3065:  ext4_ext_show_leaf(inode, path);",
      "3069:   ret = ext4_split_unwritten_extents(handle,",
      "3070:       inode, path, iblock,",
      "3071:       max_blocks, flags);",
      "",
      "[Removed Lines]",
      "3068:  if (flags == EXT4_GET_BLOCKS_PRE_IO) {",
      "",
      "[Added Lines]",
      "3068:  if ((flags & EXT4_GET_BLOCKS_PRE_IO)) {",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "3078:    io->flag = EXT4_IO_UNWRITTEN;",
      "3079:   else",
      "3080:    ext4_set_inode_state(inode, EXT4_STATE_DIO_UNWRITTEN);",
      "3081:   goto out;",
      "3082:  }",
      "3085:   ret = ext4_convert_unwritten_extents_endio(handle, inode,",
      "3086:        path);",
      "3087:   if (ret >= 0)",
      "",
      "[Removed Lines]",
      "3084:  if (flags == EXT4_GET_BLOCKS_CONVERT) {",
      "",
      "[Added Lines]",
      "3081:   if (ext4_should_dioread_nolock(inode))",
      "3082:    set_buffer_uninit(bh_result);",
      "3086:  if ((flags & EXT4_GET_BLOCKS_CONVERT)) {",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "3351:  if (flags & EXT4_GET_BLOCKS_UNINIT_EXT){",
      "3352:   ext4_ext_mark_uninitialized(&newex);",
      "3363:    if (io)",
      "3364:     io->flag = EXT4_IO_UNWRITTEN;",
      "3365:    else",
      "3366:     ext4_set_inode_state(inode,",
      "3367:            EXT4_STATE_DIO_UNWRITTEN);",
      "3368:   }",
      "3369:  }",
      "3371:  if (unlikely(EXT4_I(inode)->i_flags & EXT4_EOFBLOCKS_FL)) {",
      "",
      "[Removed Lines]",
      "3362:   if (flags == EXT4_GET_BLOCKS_PRE_IO) {",
      "",
      "[Added Lines]",
      "3362:   if ((flags & EXT4_GET_BLOCKS_PRE_IO)) {",
      "3369:   if (ext4_should_dioread_nolock(inode))",
      "3370:    set_buffer_uninit(bh_result);",
      "",
      "---------------"
    ],
    "fs/ext4/inode.c||fs/ext4/inode.c": [
      "File: fs/ext4/inode.c -> fs/ext4/inode.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "38: #include <linux/uio.h>",
      "39: #include <linux/bio.h>",
      "40: #include <linux/workqueue.h>",
      "42: #include \"ext4_jbd2.h\"",
      "43: #include \"xattr.h\"",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "41: #include <linux/kernel.h>",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1534:  ext4_truncate(inode);",
      "1535: }",
      "1537: static int ext4_write_begin(struct file *file, struct address_space *mapping,",
      "1538:        loff_t pos, unsigned len, unsigned flags,",
      "1539:        struct page **pagep, void **fsdata)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1538: static int ext4_get_block_write(struct inode *inode, sector_t iblock,",
      "1539:      struct buffer_head *bh_result, int create);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1575:  }",
      "1581:  if (!ret && ext4_should_journal_data(inode)) {",
      "1582:   ret = walk_page_buffers(handle, page_buffers(page),",
      "",
      "[Removed Lines]",
      "1578:  ret = block_write_begin(file, mapping, pos, len, flags, pagep, fsdata,",
      "1579:     ext4_get_block);",
      "",
      "[Added Lines]",
      "1581:  if (ext4_should_dioread_nolock(inode))",
      "1582:   ret = block_write_begin(file, mapping, pos, len, flags, pagep,",
      "1583:     fsdata, ext4_get_block_write);",
      "1584:  else",
      "1585:   ret = block_write_begin(file, mapping, pos, len, flags, pagep,",
      "1586:     fsdata, ext4_get_block);",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "2092:     } else if (buffer_mapped(bh))",
      "2093:      BUG_ON(bh->b_blocknr != pblock);",
      "2095:     cur_logical++;",
      "2096:     pblock++;",
      "2097:    } while ((bh = bh->b_this_page) != head);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2102:     if (buffer_uninit(exbh))",
      "2103:      set_buffer_uninit(bh);",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "2222:  new.b_state = 0;",
      "2223:  get_blocks_flags = EXT4_GET_BLOCKS_CREATE;",
      "2224:  if (mpd->b_state & (1 << BH_Delay))",
      "2225:   get_blocks_flags |= EXT4_GET_BLOCKS_DELALLOC_RESERVE;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2233:  if (ext4_should_dioread_nolock(mpd->inode))",
      "2234:   get_blocks_flags |= EXT4_GET_BLOCKS_IO_CREATE_EXT;",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "2636:  return ret;",
      "2637: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2650: static int ext4_set_bh_endio(struct buffer_head *bh, struct inode *inode);",
      "2651: static void ext4_end_io_buffer_write(struct buffer_head *bh, int uptodate);",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "2683:  int ret = 0;",
      "2684:  loff_t size;",
      "2685:  unsigned int len;",
      "2687:  struct inode *inode = page->mapping->host;",
      "2689:  trace_ext4_writepage(inode, page);",
      "",
      "[Removed Lines]",
      "2686:  struct buffer_head *page_bufs;",
      "",
      "[Added Lines]",
      "2700:  struct buffer_head *page_bufs = NULL;",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "2760:  if (test_opt(inode->i_sb, NOBH) && ext4_should_writeback_data(inode))",
      "2761:   ret = nobh_writepage(page, noalloc_get_block_write, wbc);",
      "2763:   ret = block_write_full_page(page, noalloc_get_block_write,",
      "2764:          wbc);",
      "",
      "[Removed Lines]",
      "2762:  else",
      "",
      "[Added Lines]",
      "2776:  else if (page_bufs && buffer_uninit(page_bufs)) {",
      "2777:   ext4_set_bh_endio(page_bufs, inode);",
      "2778:   ret = block_write_full_page_endio(page, noalloc_get_block_write,",
      "2779:          wbc, ext4_end_io_buffer_write);",
      "2780:  } else",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "3347:  return mpage_readpages(mapping, pages, nr_pages, ext4_get_block);",
      "3348: }",
      "3350: static void ext4_invalidatepage(struct page *page, unsigned long offset)",
      "3351: {",
      "3352:  journal_t *journal = EXT4_JOURNAL(page->mapping->host);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "3368: static void ext4_free_io_end(ext4_io_end_t *io)",
      "3369: {",
      "3370:  BUG_ON(!io);",
      "3371:  if (io->page)",
      "3372:   put_page(io->page);",
      "3373:  iput(io->inode);",
      "3374:  kfree(io);",
      "3375: }",
      "3377: static void ext4_invalidatepage_free_endio(struct page *page, unsigned long offset)",
      "3378: {",
      "3379:  struct buffer_head *head, *bh;",
      "3380:  unsigned int curr_off = 0;",
      "3382:  if (!page_has_buffers(page))",
      "3383:   return;",
      "3384:  head = bh = page_buffers(page);",
      "3385:  do {",
      "3386:   if (offset <= curr_off && test_clear_buffer_uninit(bh)",
      "3387:      && bh->b_private) {",
      "3388:    ext4_free_io_end(bh->b_private);",
      "3389:    bh->b_private = NULL;",
      "3390:    bh->b_end_io = NULL;",
      "3391:   }",
      "3392:   curr_off = curr_off + bh->b_size;",
      "3393:   bh = bh->b_this_page;",
      "3394:  } while (bh != head);",
      "3395: }",
      "3404:  if (ext4_should_dioread_nolock(page->mapping->host))",
      "3405:   ext4_invalidatepage_free_endio(page, offset);",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "3471: static int ext4_get_block_write(struct inode *inode, sector_t iblock,",
      "3472:      struct buffer_head *bh_result, int create)",
      "3473: {",
      "3475:  int ret = 0;",
      "3476:  unsigned max_blocks = bh_result->b_size >> inode->i_blkbits;",
      "3477:  int dio_credits;",
      "3479:  ext4_debug(\"ext4_get_block_write: inode %lu, create flag %d\\n\",",
      "3480:      inode->i_ino, create);",
      "",
      "[Removed Lines]",
      "3474:  handle_t *handle = NULL;",
      "",
      "[Added Lines]",
      "3526:  handle_t *handle = ext4_journal_current_handle();",
      "3530:  int started = 0;",
      "",
      "---------------",
      "--- Hunk 11 ---",
      "[Context before]",
      "3486:  create = EXT4_GET_BLOCKS_IO_CREATE_EXT;",
      "3495:  }",
      "3496:  ret = ext4_get_blocks(handle, inode, iblock, max_blocks, bh_result,",
      "3497:          create);",
      "3498:  if (ret > 0) {",
      "3499:   bh_result->b_size = (ret << inode->i_blkbits);",
      "3500:   ret = 0;",
      "3501:  }",
      "3503: out:",
      "3504:  return ret;",
      "3505: }",
      "3514: static void dump_completed_IO(struct inode * inode)",
      "3515: {",
      "3516: #ifdef EXT4_DEBUG",
      "3517:  struct list_head *cur, *before, *after;",
      "3518:  ext4_io_end_t *io, *io0, *io1;",
      "3520:  if (list_empty(&EXT4_I(inode)->i_completed_io_list)){",
      "3521:   ext4_debug(\"inode %lu completed_io list is empty\\n\", inode->i_ino);",
      "",
      "[Removed Lines]",
      "3488:  if (max_blocks > DIO_MAX_BLOCKS)",
      "3489:   max_blocks = DIO_MAX_BLOCKS;",
      "3490:  dio_credits = ext4_chunk_trans_blocks(inode, max_blocks);",
      "3491:  handle = ext4_journal_start(inode, dio_credits);",
      "3492:  if (IS_ERR(handle)) {",
      "3493:   ret = PTR_ERR(handle);",
      "3494:   goto out;",
      "3502:  ext4_journal_stop(handle);",
      "3507: static void ext4_free_io_end(ext4_io_end_t *io)",
      "3508: {",
      "3509:  BUG_ON(!io);",
      "3510:  iput(io->inode);",
      "3511:  kfree(io);",
      "3512: }",
      "",
      "[Added Lines]",
      "3541:  if (!handle) {",
      "3542:   if (max_blocks > DIO_MAX_BLOCKS)",
      "3543:    max_blocks = DIO_MAX_BLOCKS;",
      "3544:   dio_credits = ext4_chunk_trans_blocks(inode, max_blocks);",
      "3545:   handle = ext4_journal_start(inode, dio_credits);",
      "3546:   if (IS_ERR(handle)) {",
      "3547:    ret = PTR_ERR(handle);",
      "3548:    goto out;",
      "3549:   }",
      "3550:   started = 1;",
      "3559:  if (started)",
      "3560:   ext4_journal_stop(handle);",
      "3570:  unsigned long flags;",
      "",
      "---------------",
      "--- Hunk 12 ---",
      "[Context before]",
      "3523:  }",
      "3525:  ext4_debug(\"Dump inode %lu completed_io list \\n\", inode->i_ino);",
      "3526:  list_for_each_entry(io, &EXT4_I(inode)->i_completed_io_list, list){",
      "3527:   cur = &io->list;",
      "3528:   before = cur->prev;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "3578:  spin_lock_irqsave(&EXT4_I(inode)->i_completed_io_lock, flags);",
      "",
      "---------------",
      "--- Hunk 13 ---",
      "[Context before]",
      "3533:   ext4_debug(\"io 0x%p from inode %lu,prev 0x%p,next 0x%p\\n\",",
      "3534:        io, inode->i_ino, io0, io1);",
      "3535:  }",
      "3536: #endif",
      "3537: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "3589:  spin_unlock_irqrestore(&EXT4_I(inode)->i_completed_io_lock, flags);",
      "",
      "---------------",
      "--- Hunk 14 ---",
      "[Context before]",
      "3556:  if (io->flag != EXT4_IO_UNWRITTEN)",
      "3557:   return ret;",
      "3562:  if (ret < 0) {",
      "3563:   printk(KERN_EMERG \"%s: failed to convert unwritten\"",
      "3564:    \"extents to written extents, error is %d\"",
      "",
      "[Removed Lines]",
      "3559:  if (offset + size <= i_size_read(inode))",
      "3560:   ret = ext4_convert_unwritten_extents(inode, offset, size);",
      "",
      "[Added Lines]",
      "3613:  ret = ext4_convert_unwritten_extents(inode, offset, size);",
      "",
      "---------------",
      "--- Hunk 15 ---",
      "[Context before]",
      "3578: static void ext4_end_io_work(struct work_struct *work)",
      "3579: {",
      "3584:  mutex_lock(&inode->i_mutex);",
      "3585:  ret = ext4_end_io_nolock(io);",
      "3590:  }",
      "3591:  mutex_unlock(&inode->i_mutex);",
      "3592: }",
      "",
      "[Removed Lines]",
      "3580:  ext4_io_end_t *io  = container_of(work, ext4_io_end_t, work);",
      "3581:  struct inode *inode = io->inode;",
      "3582:  int ret = 0;",
      "3586:  if (ret >= 0) {",
      "3587:   if (!list_empty(&io->list))",
      "3588:    list_del_init(&io->list);",
      "3589:   ext4_free_io_end(io);",
      "",
      "[Added Lines]",
      "3632:  ext4_io_end_t  *io = container_of(work, ext4_io_end_t, work);",
      "3633:  struct inode  *inode = io->inode;",
      "3634:  struct ext4_inode_info *ei = EXT4_I(inode);",
      "3635:  unsigned long  flags;",
      "3636:  int   ret;",
      "3640:  if (ret < 0) {",
      "3641:   mutex_unlock(&inode->i_mutex);",
      "3642:   return;",
      "3645:  spin_lock_irqsave(&ei->i_completed_io_lock, flags);",
      "3646:  if (!list_empty(&io->list))",
      "3647:   list_del_init(&io->list);",
      "3648:  spin_unlock_irqrestore(&ei->i_completed_io_lock, flags);",
      "3650:  ext4_free_io_end(io);",
      "",
      "---------------",
      "--- Hunk 16 ---",
      "[Context before]",
      "3607: int flush_completed_IO(struct inode *inode)",
      "3608: {",
      "3609:  ext4_io_end_t *io;",
      "3610:  int ret = 0;",
      "3611:  int ret2 = 0;",
      "3614:   return ret;",
      "3616:  dump_completed_IO(inode);",
      "3619:     ext4_io_end_t, list);",
      "",
      "[Removed Lines]",
      "3613:  if (list_empty(&EXT4_I(inode)->i_completed_io_list))",
      "3617:  while (!list_empty(&EXT4_I(inode)->i_completed_io_list)){",
      "3618:   io = list_entry(EXT4_I(inode)->i_completed_io_list.next,",
      "",
      "[Added Lines]",
      "3669:  struct ext4_inode_info *ei = EXT4_I(inode);",
      "3670:  unsigned long flags;",
      "3674:  if (list_empty(&ei->i_completed_io_list))",
      "3678:  spin_lock_irqsave(&ei->i_completed_io_lock, flags);",
      "3679:  while (!list_empty(&ei->i_completed_io_list)){",
      "3680:   io = list_entry(ei->i_completed_io_list.next,",
      "",
      "---------------",
      "--- Hunk 17 ---",
      "[Context before]",
      "3634:   ret = ext4_end_io_nolock(io);",
      "3635:   if (ret < 0)",
      "3636:    ret2 = ret;",
      "3637:   else",
      "3638:    list_del_init(&io->list);",
      "3639:  }",
      "3640:  return (ret2 < 0) ? ret2 : 0;",
      "3641: }",
      "3644: {",
      "3645:  ext4_io_end_t *io = NULL;",
      "3649:  if (io) {",
      "3650:   igrab(inode);",
      "",
      "[Removed Lines]",
      "3643: static ext4_io_end_t *ext4_init_io_end (struct inode *inode)",
      "3647:  io = kmalloc(sizeof(*io), GFP_NOFS);",
      "",
      "[Added Lines]",
      "3696:   spin_unlock_irqrestore(&ei->i_completed_io_lock, flags);",
      "3698:   spin_lock_irqsave(&ei->i_completed_io_lock, flags);",
      "3704:  spin_unlock_irqrestore(&ei->i_completed_io_lock, flags);",
      "3708: static ext4_io_end_t *ext4_init_io_end (struct inode *inode, gfp_t flags)",
      "3712:  io = kmalloc(sizeof(*io), flags);",
      "",
      "---------------",
      "--- Hunk 18 ---",
      "[Context before]",
      "3652:   io->flag = 0;",
      "3653:   io->offset = 0;",
      "3654:   io->size = 0;",
      "3656:   INIT_WORK(&io->work, ext4_end_io_work);",
      "3657:   INIT_LIST_HEAD(&io->list);",
      "3658:  }",
      "",
      "[Removed Lines]",
      "3655:   io->error = 0;",
      "",
      "[Added Lines]",
      "3720:   io->page = NULL;",
      "",
      "---------------",
      "--- Hunk 19 ---",
      "[Context before]",
      "3665: {",
      "3666:         ext4_io_end_t *io_end = iocb->private;",
      "3667:  struct workqueue_struct *wq;",
      "3670:  if (!io_end || !size)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "3733:  unsigned long flags;",
      "3734:  struct ext4_inode_info *ei;",
      "",
      "---------------",
      "--- Hunk 20 ---",
      "[Context before]",
      "3685:  io_end->offset = offset;",
      "3686:  io_end->size = size;",
      "3687:  wq = EXT4_SB(io_end->inode->i_sb)->dio_unwritten_wq;",
      "3690:  queue_work(wq, &io_end->work);",
      "3695:  iocb->private = NULL;",
      "3696: }",
      "",
      "[Removed Lines]",
      "3693:  list_add_tail(&io_end->list,",
      "3694:    &EXT4_I(io_end->inode)->i_completed_io_list);",
      "",
      "[Added Lines]",
      "3754:  io_end->flag = EXT4_IO_UNWRITTEN;",
      "3761:  ei = EXT4_I(io_end->inode);",
      "3762:  spin_lock_irqsave(&ei->i_completed_io_lock, flags);",
      "3763:  list_add_tail(&io_end->list, &ei->i_completed_io_list);",
      "3764:  spin_unlock_irqrestore(&ei->i_completed_io_lock, flags);",
      "3768: static void ext4_end_io_buffer_write(struct buffer_head *bh, int uptodate)",
      "3769: {",
      "3770:  ext4_io_end_t *io_end = bh->b_private;",
      "3771:  struct workqueue_struct *wq;",
      "3772:  struct inode *inode;",
      "3773:  unsigned long flags;",
      "3775:  if (!test_clear_buffer_uninit(bh) || !io_end)",
      "3776:   goto out;",
      "3778:  if (!(io_end->inode->i_sb->s_flags & MS_ACTIVE)) {",
      "3779:   printk(\"sb umounted, discard end_io request for inode %lu\\n\",",
      "3780:    io_end->inode->i_ino);",
      "3781:   ext4_free_io_end(io_end);",
      "3782:   goto out;",
      "3783:  }",
      "3785:  io_end->flag = EXT4_IO_UNWRITTEN;",
      "3786:  inode = io_end->inode;",
      "3789:  spin_lock_irqsave(&EXT4_I(inode)->i_completed_io_lock, flags);",
      "3790:  list_add_tail(&io_end->list, &EXT4_I(inode)->i_completed_io_list);",
      "3791:  spin_unlock_irqrestore(&EXT4_I(inode)->i_completed_io_lock, flags);",
      "3793:  wq = EXT4_SB(inode->i_sb)->dio_unwritten_wq;",
      "3795:  queue_work(wq, &io_end->work);",
      "3796: out:",
      "3797:  bh->b_private = NULL;",
      "3798:  bh->b_end_io = NULL;",
      "3799:  clear_buffer_uninit(bh);",
      "3800:  end_buffer_async_write(bh, uptodate);",
      "3801: }",
      "3803: static int ext4_set_bh_endio(struct buffer_head *bh, struct inode *inode)",
      "3804: {",
      "3805:  ext4_io_end_t *io_end;",
      "3806:  struct page *page = bh->b_page;",
      "3807:  loff_t offset = (sector_t)page->index << PAGE_CACHE_SHIFT;",
      "3808:  size_t size = bh->b_size;",
      "3810: retry:",
      "3811:  io_end = ext4_init_io_end(inode, GFP_ATOMIC);",
      "3812:  if (!io_end) {",
      "3813:   if (printk_ratelimit())",
      "3814:    printk(KERN_WARNING \"%s: allocation fail\\n\", __func__);",
      "3815:   schedule();",
      "3816:   goto retry;",
      "3817:  }",
      "3818:  io_end->offset = offset;",
      "3819:  io_end->size = size;",
      "3825:  io_end->page = page;",
      "3826:  get_page(io_end->page);",
      "3828:  bh->b_private = io_end;",
      "3829:  bh->b_end_io = ext4_end_io_buffer_write;",
      "3830:  return 0;",
      "3831: }",
      "",
      "---------------",
      "--- Hunk 21 ---",
      "[Context before]",
      "3748:   iocb->private = NULL;",
      "3749:   EXT4_I(inode)->cur_aio_dio = NULL;",
      "3750:   if (!is_sync_kiocb(iocb)) {",
      "3752:    if (!iocb->private)",
      "3753:     return -ENOMEM;",
      "",
      "[Removed Lines]",
      "3751:    iocb->private = ext4_init_io_end(inode);",
      "",
      "[Added Lines]",
      "3886:    iocb->private = ext4_init_io_end(inode, GFP_NOFS);",
      "",
      "---------------"
    ],
    "fs/ext4/super.c||fs/ext4/super.c": [
      "File: fs/ext4/super.c -> fs/ext4/super.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "709:  ei->i_reserved_quota = 0;",
      "710: #endif",
      "711:  INIT_LIST_HEAD(&ei->i_completed_io_list);",
      "712:  ei->cur_aio_dio = NULL;",
      "713:  ei->i_sync_tid = 0;",
      "714:  ei->i_datasync_tid = 0;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "712:  spin_lock_init(&ei->i_completed_io_lock);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "926:  if (test_opt(sb, NOLOAD))",
      "927:   seq_puts(seq, \",norecovery\");",
      "929:  ext4_show_quota_options(seq, sb);",
      "931:  return 0;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "930:  if (test_opt(sb, DIOREAD_NOLOCK))",
      "931:   seq_puts(seq, \",dioread_nolock\");",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1109:  Opt_stripe, Opt_delalloc, Opt_nodelalloc,",
      "1110:  Opt_block_validity, Opt_noblock_validity,",
      "1111:  Opt_inode_readahead_blks, Opt_journal_ioprio,",
      "1112:  Opt_discard, Opt_nodiscard,",
      "1113: };",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1116:  Opt_dioread_nolock, Opt_dioread_lock,",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "1176:  {Opt_auto_da_alloc, \"auto_da_alloc=%u\"},",
      "1177:  {Opt_auto_da_alloc, \"auto_da_alloc\"},",
      "1178:  {Opt_noauto_da_alloc, \"noauto_da_alloc\"},",
      "1179:  {Opt_discard, \"discard\"},",
      "1180:  {Opt_nodiscard, \"nodiscard\"},",
      "1181:  {Opt_err, NULL},",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1184:  {Opt_dioread_nolock, \"dioread_nolock\"},",
      "1185:  {Opt_dioread_lock, \"dioread_lock\"},",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "1640:   case Opt_nodiscard:",
      "1641:    clear_opt(sbi->s_mount_opt, DISCARD);",
      "1642:    break;",
      "1643:   default:",
      "1644:    ext4_msg(sb, KERN_ERR,",
      "1645:           \"Unrecognized mount option \\\"%s\\\" \"",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1650:   case Opt_dioread_nolock:",
      "1651:    set_opt(sbi->s_mount_opt, DIOREAD_NOLOCK);",
      "1652:    break;",
      "1653:   case Opt_dioread_lock:",
      "1654:    clear_opt(sbi->s_mount_opt, DIOREAD_NOLOCK);",
      "1655:    break;",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "2795:        EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_RECOVER)) {",
      "2796:   ext4_msg(sb, KERN_ERR, \"required journal recovery \"",
      "2797:          \"suppressed and not mounted read-only\");",
      "2799:  } else {",
      "2800:   clear_opt(sbi->s_mount_opt, DATA_FLAGS);",
      "2801:   set_opt(sbi->s_mount_opt, WRITEBACK_DATA);",
      "",
      "[Removed Lines]",
      "2798:   goto failed_mount4;",
      "",
      "[Added Lines]",
      "2811:   goto failed_mount_wq;",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "2808:      !jbd2_journal_set_features(EXT4_SB(sb)->s_journal, 0, 0,",
      "2809:            JBD2_FEATURE_INCOMPAT_64BIT)) {",
      "2810:   ext4_msg(sb, KERN_ERR, \"Failed to set 64-bit journal feature\");",
      "2812:  }",
      "2814:  if (test_opt(sb, JOURNAL_ASYNC_COMMIT)) {",
      "",
      "[Removed Lines]",
      "2811:   goto failed_mount4;",
      "",
      "[Added Lines]",
      "2824:   goto failed_mount_wq;",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "2847:       (sbi->s_journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE)) {",
      "2848:    ext4_msg(sb, KERN_ERR, \"Journal does not support \"",
      "2849:           \"requested data journaling mode\");",
      "2851:   }",
      "2852:  default:",
      "2853:   break;",
      "",
      "[Removed Lines]",
      "2850:    goto failed_mount4;",
      "",
      "[Added Lines]",
      "2863:    goto failed_mount_wq;",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "2855:  set_task_ioprio(sbi->s_journal->j_task, journal_ioprio);",
      "2857: no_journal:",
      "2859:  if (test_opt(sb, NOBH)) {",
      "2860:   if (!(test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_WRITEBACK_DATA)) {",
      "2861:    ext4_msg(sb, KERN_WARNING, \"Ignoring nobh option - \"",
      "2862:     \"its supported only with writeback mode\");",
      "2863:    clear_opt(sbi->s_mount_opt, NOBH);",
      "2864:   }",
      "2865:  }",
      "2866:  EXT4_SB(sb)->dio_unwritten_wq = create_workqueue(\"ext4-dio-unwritten\");",
      "2867:  if (!EXT4_SB(sb)->dio_unwritten_wq) {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2877:   if (test_opt(sb, DIOREAD_NOLOCK)) {",
      "2878:    ext4_msg(sb, KERN_WARNING, \"dioread_nolock option is \"",
      "2879:     \"not supported with nobh mode\");",
      "2880:    goto failed_mount_wq;",
      "2881:   }",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "2926:     \"requested data journaling mode\");",
      "2927:   clear_opt(sbi->s_mount_opt, DELALLOC);",
      "2928:  }",
      "2930:  err = ext4_setup_system_zone(sb);",
      "2931:  if (err) {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2946:  if (test_opt(sb, DIOREAD_NOLOCK)) {",
      "2947:   if (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA) {",
      "2948:    ext4_msg(sb, KERN_WARNING, \"Ignoring dioread_nolock \"",
      "2949:     \"option - requested data journaling mode\");",
      "2950:    clear_opt(sbi->s_mount_opt, DIOREAD_NOLOCK);",
      "2951:   }",
      "2952:   if (sb->s_blocksize < PAGE_SIZE) {",
      "2953:    ext4_msg(sb, KERN_WARNING, \"Ignoring dioread_nolock \"",
      "2954:     \"option - block size is too small\");",
      "2955:    clear_opt(sbi->s_mount_opt, DIOREAD_NOLOCK);",
      "2956:   }",
      "2957:  }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "2ed886852adfcb070bf350e66a0da0d98b2f3ab5",
      "candidate_info": {
        "commit_hash": "2ed886852adfcb070bf350e66a0da0d98b2f3ab5",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/2ed886852adfcb070bf350e66a0da0d98b2f3ab5",
        "files": [
          "fs/ext4/dir.c",
          "fs/ext4/extents.c",
          "fs/ext4/inode.c"
        ],
        "message": "ext4: Convert callers of ext4_get_blocks() to use ext4_map_blocks()\n\nThis saves a huge amount of stack space by avoiding unnecesary struct\nbuffer_head's from being allocated on the stack.\n\nIn addition, to make the code easier to understand, collapse and\nrefactor ext4_get_block(), ext4_get_block_write(),\nnoalloc_get_block_write(), into a single function.\n\nSigned-off-by: \"Theodore Ts'o\" <tytso@mit.edu>",
        "before_after_code_files": [
          "fs/ext4/dir.c||fs/ext4/dir.c",
          "fs/ext4/extents.c||fs/ext4/extents.c",
          "fs/ext4/inode.c||fs/ext4/inode.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/ext4/extents.c||fs/ext4/extents.c",
            "fs/ext4/inode.c||fs/ext4/inode.c"
          ],
          "candidate": [
            "fs/ext4/extents.c||fs/ext4/extents.c",
            "fs/ext4/inode.c||fs/ext4/inode.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/ext4/dir.c||fs/ext4/dir.c": [
          "File: fs/ext4/dir.c -> fs/ext4/dir.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "128:  offset = filp->f_pos & (sb->s_blocksize - 1);",
          "130:  while (!error && !stored && filp->f_pos < inode->i_size) {",
          "133:   struct buffer_head *bh = NULL;",
          "137:   if (err > 0) {",
          "139:      (PAGE_CACHE_SHIFT - inode->i_blkbits);",
          "140:    if (!ra_has_index(&filp->f_ra, index))",
          "141:     page_cache_sync_readahead(",
          "",
          "[Removed Lines]",
          "131:   ext4_lblk_t blk = filp->f_pos >> EXT4_BLOCK_SIZE_BITS(sb);",
          "132:   struct buffer_head map_bh;",
          "135:   map_bh.b_state = 0;",
          "136:   err = ext4_get_blocks(NULL, inode, blk, 1, &map_bh, 0);",
          "138:    pgoff_t index = map_bh.b_blocknr >>",
          "",
          "[Added Lines]",
          "131:   struct ext4_map_blocks map;",
          "134:   map.m_lblk = filp->f_pos >> EXT4_BLOCK_SIZE_BITS(sb);",
          "135:   map.m_len = 1;",
          "136:   err = ext4_map_blocks(NULL, inode, &map, 0);",
          "138:    pgoff_t index = map.m_pblk >>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "143:      &filp->f_ra, filp,",
          "144:      index, 1);",
          "145:    filp->f_ra.prev_pos = (loff_t)index << PAGE_CACHE_SHIFT;",
          "147:   }",
          "",
          "[Removed Lines]",
          "146:    bh = ext4_bread(NULL, inode, blk, 0, &err);",
          "",
          "[Added Lines]",
          "146:    bh = ext4_bread(NULL, inode, map.m_lblk, 0, &err);",
          "",
          "---------------"
        ],
        "fs/ext4/extents.c||fs/ext4/extents.c": [
          "File: fs/ext4/extents.c -> fs/ext4/extents.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3667: long ext4_fallocate(struct inode *inode, int mode, loff_t offset, loff_t len)",
          "3668: {",
          "3669:  handle_t *handle;",
          "3671:  loff_t new_size;",
          "3672:  unsigned int max_blocks;",
          "3673:  int ret = 0;",
          "3674:  int ret2 = 0;",
          "3675:  int retries = 0;",
          "3677:  unsigned int credits, blkbits = inode->i_blkbits;",
          "",
          "[Removed Lines]",
          "3670:  ext4_lblk_t block;",
          "3676:  struct buffer_head map_bh;",
          "",
          "[Added Lines]",
          "3675:  struct ext4_map_blocks map;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3687:  if (S_ISDIR(inode->i_mode))",
          "3688:   return -ENODEV;",
          "3695:  max_blocks = (EXT4_BLOCK_ALIGN(len + offset, blkbits) >> blkbits)",
          "",
          "[Removed Lines]",
          "3690:  block = offset >> blkbits;",
          "3696:        - block;",
          "",
          "[Added Lines]",
          "3689:  map.m_lblk = offset >> blkbits;",
          "3695:   - map.m_lblk;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3706:  }",
          "3707: retry:",
          "3708:  while (ret >= 0 && ret < max_blocks) {",
          "3711:   handle = ext4_journal_start(inode, credits);",
          "3712:   if (IS_ERR(handle)) {",
          "3713:    ret = PTR_ERR(handle);",
          "3714:    break;",
          "3715:   }",
          "3719:           EXT4_GET_BLOCKS_CREATE_UNINIT_EXT);",
          "3720:   if (ret <= 0) {",
          "3721: #ifdef EXT4FS_DEBUG",
          "",
          "[Removed Lines]",
          "3709:   block = block + ret;",
          "3710:   max_blocks = max_blocks - ret;",
          "3716:   map_bh.b_state = 0;",
          "3717:   ret = ext4_get_blocks(handle, inode, block,",
          "3718:           max_blocks, &map_bh,",
          "",
          "[Added Lines]",
          "3708:   map.m_lblk = map.m_lblk + ret;",
          "3709:   map.m_len = max_blocks = max_blocks - ret;",
          "3715:   ret = ext4_map_blocks(handle, inode, &map,",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "3729:    ret2 = ext4_journal_stop(handle);",
          "3730:    break;",
          "3731:   }",
          "3733:       blkbits) >> blkbits))",
          "3734:    new_size = offset + len;",
          "3735:   else",
          "3738:   ext4_falloc_update_inode(inode, mode, new_size,",
          "3740:   ext4_mark_inode_dirty(handle, inode);",
          "3741:   ret2 = ext4_journal_stop(handle);",
          "3742:   if (ret2)",
          "",
          "[Removed Lines]",
          "3732:   if ((block + ret) >= (EXT4_BLOCK_ALIGN(offset + len,",
          "3736:    new_size = (block + ret) << blkbits;",
          "3739:       buffer_new(&map_bh));",
          "",
          "[Added Lines]",
          "3729:   if ((map.m_lblk + ret) >= (EXT4_BLOCK_ALIGN(offset + len,",
          "3733:    new_size = (map.m_lblk + ret) << blkbits;",
          "3736:       (map.m_flags & EXT4_MAP_NEW));",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "3765:         ssize_t len)",
          "3766: {",
          "3767:  handle_t *handle;",
          "3769:  unsigned int max_blocks;",
          "3770:  int ret = 0;",
          "3771:  int ret2 = 0;",
          "3773:  unsigned int credits, blkbits = inode->i_blkbits;",
          "3785:  credits = ext4_chunk_trans_blocks(inode, max_blocks);",
          "3786:  while (ret >= 0 && ret < max_blocks) {",
          "3789:   handle = ext4_journal_start(inode, credits);",
          "3790:   if (IS_ERR(handle)) {",
          "3791:    ret = PTR_ERR(handle);",
          "3792:    break;",
          "3793:   }",
          "3797:           EXT4_GET_BLOCKS_IO_CONVERT_EXT);",
          "3798:   if (ret <= 0) {",
          "3799:    WARN_ON(ret <= 0);",
          "3800:    printk(KERN_ERR \"%s: ext4_ext_map_blocks \"",
          "3801:         \"returned error inode#%lu, block=%u, \"",
          "3802:         \"max_blocks=%u\", __func__,",
          "3804:   }",
          "3805:   ext4_mark_inode_dirty(handle, inode);",
          "3806:   ret2 = ext4_journal_stop(handle);",
          "",
          "[Removed Lines]",
          "3768:  ext4_lblk_t block;",
          "3772:  struct buffer_head map_bh;",
          "3775:  block = offset >> blkbits;",
          "3780:  max_blocks = (EXT4_BLOCK_ALIGN(len + offset, blkbits) >> blkbits)",
          "3781:        - block;",
          "3787:   block = block + ret;",
          "3788:   max_blocks = max_blocks - ret;",
          "3794:   map_bh.b_state = 0;",
          "3795:   ret = ext4_get_blocks(handle, inode, block,",
          "3796:           max_blocks, &map_bh,",
          "3803:         inode->i_ino, block, max_blocks);",
          "",
          "[Added Lines]",
          "3768:  struct ext4_map_blocks map;",
          "3771:  map.m_lblk = offset >> blkbits;",
          "3776:  max_blocks = ((EXT4_BLOCK_ALIGN(len + offset, blkbits) >> blkbits) -",
          "3777:         map.m_lblk);",
          "3783:   map.m_lblk += ret;",
          "3784:   map.m_len = (max_blocks -= ret);",
          "3790:   ret = ext4_map_blocks(handle, inode, &map,",
          "3797:         inode->i_ino, map.m_lblk, map.m_len);",
          "",
          "---------------"
        ],
        "fs/ext4/inode.c||fs/ext4/inode.c": [
          "File: fs/ext4/inode.c -> fs/ext4/inode.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1336:  return retval;",
          "1337: }",
          "1361: #define DIO_MAX_BLOCKS 4096",
          "1365: {",
          "1366:  handle_t *handle = ext4_journal_current_handle();",
          "1367:  int ret = 0, started = 0;",
          "1369:  int dio_credits;",
          "1376:   handle = ext4_journal_start(inode, dio_credits);",
          "1377:   if (IS_ERR(handle)) {",
          "1378:    ret = PTR_ERR(handle);",
          "1380:   }",
          "1381:   started = 1;",
          "1382:  }",
          "1386:  if (ret > 0) {",
          "1388:   ret = 0;",
          "1389:  }",
          "1390:  if (started)",
          "1391:   ext4_journal_stop(handle);",
          "1393:  return ret;",
          "1394: }",
          "1399: struct buffer_head *ext4_getblk(handle_t *handle, struct inode *inode,",
          "1400:     ext4_lblk_t block, int create, int *errp)",
          "1401: {",
          "1403:  int fatal = 0, err;",
          "1406:  J_ASSERT(handle != NULL || create == 0);",
          "1461:   }",
          "1463:  }",
          "1466: }",
          "1468: struct buffer_head *ext4_bread(handle_t *handle, struct inode *inode,",
          "",
          "[Removed Lines]",
          "1339: int ext4_get_blocks(handle_t *handle, struct inode *inode, sector_t block,",
          "1340:       unsigned int max_blocks, struct buffer_head *bh,",
          "1341:       int flags)",
          "1342: {",
          "1343:  struct ext4_map_blocks map;",
          "1344:  int ret;",
          "1346:  map.m_lblk = block;",
          "1347:  map.m_len = max_blocks;",
          "1349:  ret = ext4_map_blocks(handle, inode, &map, flags);",
          "1350:  if (ret < 0)",
          "1351:   return ret;",
          "1353:  bh->b_blocknr = map.m_pblk;",
          "1354:  bh->b_size = inode->i_sb->s_blocksize * map.m_len;",
          "1355:  bh->b_bdev = inode->i_sb->s_bdev;",
          "1356:  bh->b_state = (bh->b_state & ~EXT4_MAP_FLAGS) | map.m_flags;",
          "1357:  return ret;",
          "1358: }",
          "1363: int ext4_get_block(struct inode *inode, sector_t iblock,",
          "1364:      struct buffer_head *bh_result, int create)",
          "1368:  unsigned max_blocks = bh_result->b_size >> inode->i_blkbits;",
          "1371:  if (create && !handle) {",
          "1373:   if (max_blocks > DIO_MAX_BLOCKS)",
          "1374:    max_blocks = DIO_MAX_BLOCKS;",
          "1375:   dio_credits = ext4_chunk_trans_blocks(inode, max_blocks);",
          "1379:    goto out;",
          "1384:  ret = ext4_get_blocks(handle, inode, iblock, max_blocks, bh_result,",
          "1385:          create ? EXT4_GET_BLOCKS_CREATE : 0);",
          "1387:   bh_result->b_size = (ret << inode->i_blkbits);",
          "1392: out:",
          "1402:  struct buffer_head dummy;",
          "1404:  int flags = 0;",
          "1408:  dummy.b_state = 0;",
          "1409:  dummy.b_blocknr = -1000;",
          "1410:  buffer_trace_init(&dummy.b_history);",
          "1411:  if (create)",
          "1412:   flags |= EXT4_GET_BLOCKS_CREATE;",
          "1413:  err = ext4_get_blocks(handle, inode, block, 1, &dummy, flags);",
          "1418:  if (err > 0) {",
          "1419:   if (err > 1)",
          "1420:    WARN_ON(1);",
          "1421:   err = 0;",
          "1422:  }",
          "1424:  if (!err && buffer_mapped(&dummy)) {",
          "1425:   struct buffer_head *bh;",
          "1426:   bh = sb_getblk(inode->i_sb, dummy.b_blocknr);",
          "1427:   if (!bh) {",
          "1429:    goto err;",
          "1430:   }",
          "1431:   if (buffer_new(&dummy)) {",
          "1432:    J_ASSERT(create != 0);",
          "1433:    J_ASSERT(handle != NULL);",
          "1442:    lock_buffer(bh);",
          "1443:    BUFFER_TRACE(bh, \"call get_create_access\");",
          "1444:    fatal = ext4_journal_get_create_access(handle, bh);",
          "1445:    if (!fatal && !buffer_uptodate(bh)) {",
          "1446:     memset(bh->b_data, 0, inode->i_sb->s_blocksize);",
          "1447:     set_buffer_uptodate(bh);",
          "1448:    }",
          "1449:    unlock_buffer(bh);",
          "1450:    BUFFER_TRACE(bh, \"call ext4_handle_dirty_metadata\");",
          "1451:    err = ext4_handle_dirty_metadata(handle, inode, bh);",
          "1452:    if (!fatal)",
          "1453:     fatal = err;",
          "1454:   } else {",
          "1455:    BUFFER_TRACE(bh, \"not a new buffer\");",
          "1456:   }",
          "1457:   if (fatal) {",
          "1459:    brelse(bh);",
          "1460:    bh = NULL;",
          "1462:   return bh;",
          "1464: err:",
          "1465:  return NULL;",
          "",
          "[Added Lines]",
          "1342: static int _ext4_get_block(struct inode *inode, sector_t iblock,",
          "1343:       struct buffer_head *bh, int flags)",
          "1346:  struct ext4_map_blocks map;",
          "1350:  map.m_lblk = iblock;",
          "1351:  map.m_len = bh->b_size >> inode->i_blkbits;",
          "1353:  if (flags && !handle) {",
          "1355:   if (map.m_len > DIO_MAX_BLOCKS)",
          "1356:    map.m_len = DIO_MAX_BLOCKS;",
          "1357:   dio_credits = ext4_chunk_trans_blocks(inode, map.m_len);",
          "1361:    return ret;",
          "1366:  ret = ext4_map_blocks(handle, inode, &map, flags);",
          "1368:   map_bh(bh, inode->i_sb, map.m_pblk);",
          "1369:   bh->b_state = (bh->b_state & ~EXT4_MAP_FLAGS) | map.m_flags;",
          "1370:   bh->b_size = inode->i_sb->s_blocksize * map.m_len;",
          "1378: int ext4_get_block(struct inode *inode, sector_t iblock,",
          "1379:      struct buffer_head *bh, int create)",
          "1380: {",
          "1381:  return _ext4_get_block(inode, iblock, bh,",
          "1382:           create ? EXT4_GET_BLOCKS_CREATE : 0);",
          "1383: }",
          "1391:  struct ext4_map_blocks map;",
          "1392:  struct buffer_head *bh;",
          "1397:  map.m_lblk = block;",
          "1398:  map.m_len = 1;",
          "1399:  err = ext4_map_blocks(handle, inode, &map,",
          "1400:          create ? EXT4_GET_BLOCKS_CREATE : 0);",
          "1402:  if (err < 0)",
          "1404:  if (err <= 0)",
          "1405:   return NULL;",
          "1408:  bh = sb_getblk(inode->i_sb, map.m_pblk);",
          "1409:  if (!bh) {",
          "1411:   return NULL;",
          "1412:  }",
          "1413:  if (map.m_flags & EXT4_MAP_NEW) {",
          "1414:   J_ASSERT(create != 0);",
          "1415:   J_ASSERT(handle != NULL);",
          "1424:   lock_buffer(bh);",
          "1425:   BUFFER_TRACE(bh, \"call get_create_access\");",
          "1426:   fatal = ext4_journal_get_create_access(handle, bh);",
          "1427:   if (!fatal && !buffer_uptodate(bh)) {",
          "1428:    memset(bh->b_data, 0, inode->i_sb->s_blocksize);",
          "1429:    set_buffer_uptodate(bh);",
          "1431:   unlock_buffer(bh);",
          "1432:   BUFFER_TRACE(bh, \"call ext4_handle_dirty_metadata\");",
          "1433:   err = ext4_handle_dirty_metadata(handle, inode, bh);",
          "1434:   if (!fatal)",
          "1435:    fatal = err;",
          "1436:  } else {",
          "1437:   BUFFER_TRACE(bh, \"not a new buffer\");",
          "1439:  if (fatal) {",
          "1441:   brelse(bh);",
          "1442:   bh = NULL;",
          "1443:  }",
          "1444:  return bh;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2063: {",
          "2064:  struct inode *inode = mpd->inode;",
          "2065:  struct address_space *mapping = inode->i_mapping;",
          "2068:  struct buffer_head *head, *bh;",
          "2069:  pgoff_t index, end;",
          "2070:  struct pagevec pvec;",
          "2071:  int nr_pages, i;",
          "2075:  cur_logical = index << (PAGE_CACHE_SHIFT - inode->i_blkbits);",
          "2077:  pagevec_init(&pvec, 0);",
          "",
          "[Removed Lines]",
          "2061: static void mpage_put_bnr_to_bhs(struct mpage_da_data *mpd, sector_t logical,",
          "2062:      struct buffer_head *exbh)",
          "2066:  int blocks = exbh->b_size >> inode->i_blkbits;",
          "2067:  sector_t pblock = exbh->b_blocknr, cur_logical;",
          "2073:  index = logical >> (PAGE_CACHE_SHIFT - inode->i_blkbits);",
          "2074:  end = (logical + blocks - 1) >> (PAGE_CACHE_SHIFT - inode->i_blkbits);",
          "",
          "[Added Lines]",
          "2035: static void mpage_put_bnr_to_bhs(struct mpage_da_data *mpd,",
          "2036:      struct ext4_map_blocks *map)",
          "2040:  int blocks = map->m_len;",
          "2041:  sector_t pblock = map->m_pblk, cur_logical;",
          "2047:  index = map->m_lblk >> (PAGE_CACHE_SHIFT - inode->i_blkbits);",
          "2048:  end = (map->m_lblk + blocks - 1) >> (PAGE_CACHE_SHIFT - inode->i_blkbits);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2100:    do {",
          "2102:      break;",
          "2103:     cur_logical++;",
          "2104:    } while ((bh = bh->b_this_page) != head);",
          "2106:    do {",
          "2108:      break;",
          "2113:      BUG_ON(bh->b_bdev != inode->i_sb->s_bdev);",
          "",
          "[Removed Lines]",
          "2101:     if (cur_logical >= logical)",
          "2107:     if (cur_logical >= logical + blocks)",
          "2110:     if (buffer_delay(bh) ||",
          "2111:       buffer_unwritten(bh)) {",
          "",
          "[Added Lines]",
          "2075:     if (cur_logical >= map->m_lblk)",
          "2081:     if (cur_logical >= map->m_lblk + blocks)",
          "2084:     if (buffer_delay(bh) || buffer_unwritten(bh)) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2127:     } else if (buffer_mapped(bh))",
          "2128:      BUG_ON(bh->b_blocknr != pblock);",
          "2131:      set_buffer_uninit(bh);",
          "2132:     cur_logical++;",
          "2133:     pblock++;",
          "",
          "[Removed Lines]",
          "2130:     if (buffer_uninit(exbh))",
          "",
          "[Added Lines]",
          "2103:     if (map->m_flags & EXT4_MAP_UNINIT)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2138: }",
          "2156: static void ext4_da_block_invalidatepages(struct mpage_da_data *mpd,",
          "2157:      sector_t logical, long blk_cnt)",
          "2158: {",
          "",
          "[Removed Lines]",
          "2145: static inline void __unmap_underlying_blocks(struct inode *inode,",
          "2146:           struct buffer_head *bh)",
          "2147: {",
          "2148:  struct block_device *bdev = inode->i_sb->s_bdev;",
          "2149:  int blocks, i;",
          "2151:  blocks = bh->b_size >> inode->i_blkbits;",
          "2152:  for (i = 0; i < blocks; i++)",
          "2153:   unmap_underlying_metadata(bdev, bh->b_blocknr + i);",
          "2154: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2214: static int mpage_da_map_blocks(struct mpage_da_data *mpd)",
          "2215: {",
          "2216:  int err, blks, get_blocks_flags;",
          "2218:  sector_t next = mpd->b_blocknr;",
          "2219:  unsigned max_blocks = mpd->b_size >> mpd->inode->i_blkbits;",
          "2220:  loff_t disksize = EXT4_I(mpd->inode)->i_disksize;",
          "",
          "[Removed Lines]",
          "2217:  struct buffer_head new;",
          "",
          "[Added Lines]",
          "2175:  struct ext4_map_blocks map;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "2259:  get_blocks_flags = EXT4_GET_BLOCKS_CREATE;",
          "2260:  if (ext4_should_dioread_nolock(mpd->inode))",
          "2261:   get_blocks_flags |= EXT4_GET_BLOCKS_IO_CREATE_EXT;",
          "2262:  if (mpd->b_state & (1 << BH_Delay))",
          "2263:   get_blocks_flags |= EXT4_GET_BLOCKS_DELALLOC_RESERVE;",
          "2267:  if (blks < 0) {",
          "2268:   err = blks;",
          "",
          "[Removed Lines]",
          "2258:  new.b_state = 0;",
          "2265:  blks = ext4_get_blocks(handle, mpd->inode, next, max_blocks,",
          "2266:           &new, get_blocks_flags);",
          "",
          "[Added Lines]",
          "2216:  map.m_lblk = next;",
          "2217:  map.m_len = max_blocks;",
          "2224:  blks = ext4_map_blocks(handle, mpd->inode, &map, get_blocks_flags);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "2305:  }",
          "2306:  BUG_ON(blks == 0);",
          "",
          "[Removed Lines]",
          "2308:  new.b_size = (blks << mpd->inode->i_blkbits);",
          "2310:  if (buffer_new(&new))",
          "2311:   __unmap_underlying_blocks(mpd->inode, &new);",
          "",
          "[Added Lines]",
          "2266:  if (map.m_flags & EXT4_MAP_NEW) {",
          "2267:   struct block_device *bdev = mpd->inode->i_sb->s_bdev;",
          "2268:   int i;",
          "2270:   for (i = 0; i < map.m_len; i++)",
          "2271:    unmap_underlying_metadata(bdev, map.m_pblk + i);",
          "2272:  }",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "2317:  if ((mpd->b_state & (1 << BH_Delay)) ||",
          "2318:      (mpd->b_state & (1 << BH_Unwritten)))",
          "2321:  if (ext4_should_order_data(mpd->inode)) {",
          "2322:   err = ext4_jbd2_file_inode(handle, mpd->inode);",
          "",
          "[Removed Lines]",
          "2319:   mpage_put_bnr_to_bhs(mpd, next, &new);",
          "",
          "[Added Lines]",
          "2280:   mpage_put_bnr_to_bhs(mpd, &map);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "2536: static int ext4_da_get_block_prep(struct inode *inode, sector_t iblock,",
          "2538: {",
          "2539:  int ret = 0;",
          "2540:  sector_t invalid_block = ~((sector_t) 0xffff);",
          "",
          "[Removed Lines]",
          "2537:       struct buffer_head *bh_result, int create)",
          "",
          "[Added Lines]",
          "2498:       struct buffer_head *bh, int create)",
          "2500:  struct ext4_map_blocks map;",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "2543:   invalid_block = ~0;",
          "2545:  BUG_ON(create == 0);",
          "",
          "[Removed Lines]",
          "2546:  BUG_ON(bh_result->b_size != inode->i_sb->s_blocksize);",
          "2553:  ret = ext4_get_blocks(NULL, inode, iblock, 1,  bh_result, 0);",
          "2554:  if ((ret == 0) && !buffer_delay(bh_result)) {",
          "",
          "[Added Lines]",
          "2508:  BUG_ON(bh->b_size != inode->i_sb->s_blocksize);",
          "2510:  map.m_lblk = iblock;",
          "2511:  map.m_len = 1;",
          "2518:  ret = ext4_map_blocks(NULL, inode, &map, 0);",
          "2519:  if (ret < 0)",
          "2520:   return ret;",
          "2521:  if (ret == 0) {",
          "2522:   if (buffer_delay(bh))",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "2563:    return ret;",
          "2582:  }",
          "2585: }",
          "",
          "[Removed Lines]",
          "2565:   map_bh(bh_result, inode->i_sb, invalid_block);",
          "2566:   set_buffer_new(bh_result);",
          "2567:   set_buffer_delay(bh_result);",
          "2568:  } else if (ret > 0) {",
          "2569:   bh_result->b_size = (ret << inode->i_blkbits);",
          "2570:   if (buffer_unwritten(bh_result)) {",
          "2578:    set_buffer_new(bh_result);",
          "2579:    set_buffer_mapped(bh_result);",
          "2580:   }",
          "2581:   ret = 0;",
          "2584:  return ret;",
          "",
          "[Added Lines]",
          "2533:   map_bh(bh, inode->i_sb, invalid_block);",
          "2534:   set_buffer_new(bh);",
          "2535:   set_buffer_delay(bh);",
          "2536:   return 0;",
          "2539:  map_bh(bh, inode->i_sb, map.m_pblk);",
          "2540:  bh->b_state = (bh->b_state & ~EXT4_MAP_FLAGS) | map.m_flags;",
          "2542:  if (buffer_unwritten(bh)) {",
          "2549:   set_buffer_new(bh);",
          "2550:   set_buffer_mapped(bh);",
          "2551:  }",
          "2552:  return 0;",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "2603: static int noalloc_get_block_write(struct inode *inode, sector_t iblock,",
          "2604:        struct buffer_head *bh_result, int create)",
          "2605: {",
          "2609:  BUG_ON(bh_result->b_size != inode->i_sb->s_blocksize);",
          "2621: }",
          "2623: static int bget_one(handle_t *handle, struct buffer_head *bh)",
          "",
          "[Removed Lines]",
          "2606:  int ret = 0;",
          "2607:  unsigned max_blocks = bh_result->b_size >> inode->i_blkbits;",
          "2615:  ret = ext4_get_blocks(NULL, inode, iblock, max_blocks, bh_result, 0);",
          "2616:  if (ret > 0) {",
          "2617:   bh_result->b_size = (ret << inode->i_blkbits);",
          "2618:   ret = 0;",
          "2619:  }",
          "2620:  return ret;",
          "",
          "[Added Lines]",
          "2575:  return _ext4_get_block(inode, iblock, bh_result, 0);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "3644:  return ret;",
          "3645: }",
          "3647: static int ext4_get_block_write(struct inode *inode, sector_t iblock,",
          "3648:      struct buffer_head *bh_result, int create)",
          "3649: {",
          "3656:  ext4_debug(\"ext4_get_block_write: inode %lu, create flag %d\\n\",",
          "3657:      inode->i_ino, create);",
          "3687: }",
          "3689: static void dump_completed_IO(struct inode * inode)",
          "",
          "[Removed Lines]",
          "3650:  handle_t *handle = ext4_journal_current_handle();",
          "3651:  int ret = 0;",
          "3652:  unsigned max_blocks = bh_result->b_size >> inode->i_blkbits;",
          "3653:  int dio_credits;",
          "3654:  int started = 0;",
          "3663:  create = EXT4_GET_BLOCKS_IO_CREATE_EXT;",
          "3665:  if (!handle) {",
          "3666:   if (max_blocks > DIO_MAX_BLOCKS)",
          "3667:    max_blocks = DIO_MAX_BLOCKS;",
          "3668:   dio_credits = ext4_chunk_trans_blocks(inode, max_blocks);",
          "3669:   handle = ext4_journal_start(inode, dio_credits);",
          "3670:   if (IS_ERR(handle)) {",
          "3671:    ret = PTR_ERR(handle);",
          "3672:    goto out;",
          "3673:   }",
          "3674:   started = 1;",
          "3675:  }",
          "3677:  ret = ext4_get_blocks(handle, inode, iblock, max_blocks, bh_result,",
          "3678:          create);",
          "3679:  if (ret > 0) {",
          "3680:   bh_result->b_size = (ret << inode->i_blkbits);",
          "3681:   ret = 0;",
          "3682:  }",
          "3683:  if (started)",
          "3684:   ext4_journal_stop(handle);",
          "3685: out:",
          "3686:  return ret;",
          "",
          "[Added Lines]",
          "3612:  return _ext4_get_block(inode, iblock, bh_result,",
          "3613:           EXT4_GET_BLOCKS_IO_CREATE_EXT);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
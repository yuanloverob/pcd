{
  "cve_id": "CVE-2014-5077",
  "cve_desc": "The sctp_assoc_update function in net/sctp/associola.c in the Linux kernel through 3.15.8, when SCTP authentication is enabled, allows remote attackers to cause a denial of service (NULL pointer dereference and OOPS) by starting to establish an association between two endpoints immediately after an exchange of INIT and INIT ACK chunks to establish an earlier association between these endpoints in the opposite direction.",
  "repo": "torvalds/linux",
  "patch_hash": "1be9a950c646c9092fb3618197f7b6bfb50e82aa",
  "patch_info": {
    "commit_hash": "1be9a950c646c9092fb3618197f7b6bfb50e82aa",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/1be9a950c646c9092fb3618197f7b6bfb50e82aa",
    "files": [
      "net/sctp/associola.c"
    ],
    "message": "net: sctp: inherit auth_capable on INIT collisions\n\nJason reported an oops caused by SCTP on his ARM machine with\nSCTP authentication enabled:\n\nInternal error: Oops: 17 [#1] ARM\nCPU: 0 PID: 104 Comm: sctp-test Not tainted 3.13.0-68744-g3632f30c9b20-dirty #1\ntask: c6eefa40 ti: c6f52000 task.ti: c6f52000\nPC is at sctp_auth_calculate_hmac+0xc4/0x10c\nLR is at sg_init_table+0x20/0x38\npc : [<c024bb80>]    lr : [<c00f32dc>]    psr: 40000013\nsp : c6f538e8  ip : 00000000  fp : c6f53924\nr10: c6f50d80  r9 : 00000000  r8 : 00010000\nr7 : 00000000  r6 : c7be4000  r5 : 00000000  r4 : c6f56254\nr3 : c00c8170  r2 : 00000001  r1 : 00000008  r0 : c6f1e660\nFlags: nZcv  IRQs on  FIQs on  Mode SVC_32  ISA ARM  Segment user\nControl: 0005397f  Table: 06f28000  DAC: 00000015\nProcess sctp-test (pid: 104, stack limit = 0xc6f521c0)\nStack: (0xc6f538e8 to 0xc6f54000)\n[...]\nBacktrace:\n[<c024babc>] (sctp_auth_calculate_hmac+0x0/0x10c) from [<c0249af8>] (sctp_packet_transmit+0x33c/0x5c8)\n[<c02497bc>] (sctp_packet_transmit+0x0/0x5c8) from [<c023e96c>] (sctp_outq_flush+0x7fc/0x844)\n[<c023e170>] (sctp_outq_flush+0x0/0x844) from [<c023ef78>] (sctp_outq_uncork+0x24/0x28)\n[<c023ef54>] (sctp_outq_uncork+0x0/0x28) from [<c0234364>] (sctp_side_effects+0x1134/0x1220)\n[<c0233230>] (sctp_side_effects+0x0/0x1220) from [<c02330b0>] (sctp_do_sm+0xac/0xd4)\n[<c0233004>] (sctp_do_sm+0x0/0xd4) from [<c023675c>] (sctp_assoc_bh_rcv+0x118/0x160)\n[<c0236644>] (sctp_assoc_bh_rcv+0x0/0x160) from [<c023d5bc>] (sctp_inq_push+0x6c/0x74)\n[<c023d550>] (sctp_inq_push+0x0/0x74) from [<c024a6b0>] (sctp_rcv+0x7d8/0x888)\n\nWhile we already had various kind of bugs in that area\nec0223ec48a9 (\"net: sctp: fix sctp_sf_do_5_1D_ce to verify if\nwe/peer is AUTH capable\") and b14878ccb7fa (\"net: sctp: cache\nauth_enable per endpoint\"), this one is a bit of a different\nkind.\n\nGiving a bit more background on why SCTP authentication is\nneeded can be found in RFC4895:\n\n  SCTP uses 32-bit verification tags to protect itself against\n  blind attackers. These values are not changed during the\n  lifetime of an SCTP association.\n\n  Looking at new SCTP extensions, there is the need to have a\n  method of proving that an SCTP chunk(s) was really sent by\n  the original peer that started the association and not by a\n  malicious attacker.\n\nTo cause this bug, we're triggering an INIT collision between\npeers; normal SCTP handshake where both sides intent to\nauthenticate packets contains RANDOM; CHUNKS; HMAC-ALGO\nparameters that are being negotiated among peers:\n\n  ---------- INIT[RANDOM; CHUNKS; HMAC-ALGO] ---------->\n  <------- INIT-ACK[RANDOM; CHUNKS; HMAC-ALGO] ---------\n  -------------------- COOKIE-ECHO -------------------->\n  <-------------------- COOKIE-ACK ---------------------\n\nRFC4895 says that each endpoint therefore knows its own random\nnumber and the peer's random number *after* the association\nhas been established. The local and peer's random number along\nwith the shared key are then part of the secret used for\ncalculating the HMAC in the AUTH chunk.\n\nNow, in our scenario, we have 2 threads with 1 non-blocking\nSEQ_PACKET socket each, setting up common shared SCTP_AUTH_KEY\nand SCTP_AUTH_ACTIVE_KEY properly, and each of them calling\nsctp_bindx(3), listen(2) and connect(2) against each other,\nthus the handshake looks similar to this, e.g.:\n\n  ---------- INIT[RANDOM; CHUNKS; HMAC-ALGO] ---------->\n  <------- INIT-ACK[RANDOM; CHUNKS; HMAC-ALGO] ---------\n  <--------- INIT[RANDOM; CHUNKS; HMAC-ALGO] -----------\n  -------- INIT-ACK[RANDOM; CHUNKS; HMAC-ALGO] -------->\n  ...\n\nSince such collisions can also happen with verification tags,\nthe RFC4895 for AUTH rather vaguely says under section 6.1:\n\n  In case of INIT collision, the rules governing the handling\n  of this Random Number follow the same pattern as those for\n  the Verification Tag, as explained in Section 5.2.4 of\n  RFC 2960 [5]. Therefore, each endpoint knows its own Random\n  Number and the peer's Random Number after the association\n  has been established.\n\nIn RFC2960, section 5.2.4, we're eventually hitting Action B:\n\n  B) In this case, both sides may be attempting to start an\n     association at about the same time but the peer endpoint\n     started its INIT after responding to the local endpoint's\n     INIT. Thus it may have picked a new Verification Tag not\n     being aware of the previous Tag it had sent this endpoint.\n     The endpoint should stay in or enter the ESTABLISHED\n     state but it MUST update its peer's Verification Tag from\n     the State Cookie, stop any init or cookie timers that may\n     running and send a COOKIE ACK.\n\nIn other words, the handling of the Random parameter is the\nsame as behavior for the Verification Tag as described in\nAction B of section 5.2.4.\n\nLooking at the code, we exactly hit the sctp_sf_do_dupcook_b()\ncase which triggers an SCTP_CMD_UPDATE_ASSOC command to the\nside effect interpreter, and in fact it properly copies over\npeer_{random, hmacs, chunks} parameters from the newly created\nassociation to update the existing one.\n\nAlso, the old asoc_shared_key is being released and based on\nthe new params, sctp_auth_asoc_init_active_key() updated.\nHowever, the issue observed in this case is that the previous\nasoc->peer.auth_capable was 0, and has *not* been updated, so\nthat instead of creating a new secret, we're doing an early\nreturn from the function sctp_auth_asoc_init_active_key()\nleaving asoc->asoc_shared_key as NULL. However, we now have to\nauthenticate chunks from the updated chunk list (e.g. COOKIE-ACK).\n\nThat in fact causes the server side when responding with ...\n\n  <------------------ AUTH; COOKIE-ACK -----------------\n\n... to trigger a NULL pointer dereference, since in\nsctp_packet_transmit(), it discovers that an AUTH chunk is\nbeing queued for xmit, and thus it calls sctp_auth_calculate_hmac().\n\nSince the asoc->active_key_id is still inherited from the\nendpoint, and the same as encoded into the chunk, it uses\nasoc->asoc_shared_key, which is still NULL, as an asoc_key\nand dereferences it in ...\n\n  crypto_hash_setkey(desc.tfm, &asoc_key->data[0], asoc_key->len)\n\n... causing an oops. All this happens because sctp_make_cookie_ack()\ncalled with the *new* association has the peer.auth_capable=1\nand therefore marks the chunk with auth=1 after checking\nsctp_auth_send_cid(), but it is *actually* sent later on over\nthe then *updated* association's transport that didn't initialize\nits shared key due to peer.auth_capable=0. Since control chunks\nin that case are not sent by the temporary association which\nare scheduled for deletion, they are issued for xmit via\nSCTP_CMD_REPLY in the interpreter with the context of the\n*updated* association. peer.auth_capable was 0 in the updated\nassociation (which went from COOKIE_WAIT into ESTABLISHED state),\nsince all previous processing that performed sctp_process_init()\nwas being done on temporary associations, that we eventually\nthrow away each time.\n\nThe correct fix is to update to the new peer.auth_capable\nvalue as well in the collision case via sctp_assoc_update(),\nso that in case the collision migrated from 0 -> 1,\nsctp_auth_asoc_init_active_key() can properly recalculate\nthe secret. This therefore fixes the observed server panic.\n\nFixes: 730fc3d05cd4 (\"[SCTP]: Implete SCTP-AUTH parameter processing\")\nReported-by: Jason Gunthorpe <jgunthorpe@obsidianresearch.com>\nSigned-off-by: Daniel Borkmann <dborkman@redhat.com>\nTested-by: Jason Gunthorpe <jgunthorpe@obsidianresearch.com>\nCc: Vlad Yasevich <vyasevich@gmail.com>\nAcked-by: Vlad Yasevich <vyasevich@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
    "before_after_code_files": [
      "net/sctp/associola.c||net/sctp/associola.c"
    ]
  },
  "patch_diff": {
    "net/sctp/associola.c||net/sctp/associola.c": [
      "File: net/sctp/associola.c -> net/sctp/associola.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1097:  asoc->c = new->c;",
      "1098:  asoc->peer.rwnd = new->peer.rwnd;",
      "1099:  asoc->peer.sack_needed = new->peer.sack_needed;",
      "1100:  asoc->peer.i = new->peer.i;",
      "1101:  sctp_tsnmap_init(&asoc->peer.tsn_map, SCTP_TSN_MAP_INITIAL,",
      "1102:     asoc->peer.i.initial_tsn, GFP_ATOMIC);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1100:  asoc->peer.auth_capable = new->peer.auth_capable;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "1a112d10f03e83fb3a2fdc4c9165865dec8a3ca6",
      "candidate_info": {
        "commit_hash": "1a112d10f03e83fb3a2fdc4c9165865dec8a3ca6",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/1a112d10f03e83fb3a2fdc4c9165865dec8a3ca6",
        "files": [
          "drivers/ata/libata-core.c",
          "include/linux/libata.h"
        ],
        "message": "libata: introduce ata_host->n_tags to avoid oops on SAS controllers\n\n1871ee134b73 (\"libata: support the ata host which implements a queue\ndepth less than 32\") directly used ata_port->scsi_host->can_queue from\nata_qc_new() to determine the number of tags supported by the host;\nunfortunately, SAS controllers doing SATA don't initialize ->scsi_host\nleading to the following oops.\n\n BUG: unable to handle kernel NULL pointer dereference at 0000000000000058\n IP: [<ffffffff814e0618>] ata_qc_new_init+0x188/0x1b0\n PGD 0\n Oops: 0002 [#1] SMP\n Modules linked in: isci libsas scsi_transport_sas mgag200 drm_kms_helper ttm\n CPU: 1 PID: 518 Comm: udevd Not tainted 3.16.0-rc6+ #62\n Hardware name: Intel Corporation S2600CO/S2600CO, BIOS SE5C600.86B.02.02.0002.122320131210 12/23/2013\n task: ffff880c1a00b280 ti: ffff88061a000000 task.ti: ffff88061a000000\n RIP: 0010:[<ffffffff814e0618>]  [<ffffffff814e0618>] ata_qc_new_init+0x188/0x1b0\n RSP: 0018:ffff88061a003ae8  EFLAGS: 00010012\n RAX: 0000000000000001 RBX: ffff88000241ca80 RCX: 00000000000000fa\n RDX: 0000000000000020 RSI: 0000000000000020 RDI: ffff8806194aa298\n RBP: ffff88061a003ae8 R08: ffff8806194a8000 R09: 0000000000000000\n R10: 0000000000000000 R11: ffff88000241ca80 R12: ffff88061ad58200\n R13: ffff8806194aa298 R14: ffffffff814e67a0 R15: ffff8806194a8000\n FS:  00007f3ad7fe3840(0000) GS:ffff880627620000(0000) knlGS:0000000000000000\n CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n CR2: 0000000000000058 CR3: 000000061a118000 CR4: 00000000001407e0\n Stack:\n  ffff88061a003b20 ffffffff814e96e1 ffff88000241ca80 ffff88061ad58200\n  ffff8800b6bf6000 ffff880c1c988000 ffff880619903850 ffff88061a003b68\n  ffffffffa0056ce1 ffff88061a003b48 0000000013d6e6f8 ffff88000241ca80\n Call Trace:\n  [<ffffffff814e96e1>] ata_sas_queuecmd+0xa1/0x430\n  [<ffffffffa0056ce1>] sas_queuecommand+0x191/0x220 [libsas]\n  [<ffffffff8149afee>] scsi_dispatch_cmd+0x10e/0x300\n  [<ffffffff814a3bc5>] scsi_request_fn+0x2f5/0x550\n  [<ffffffff81317613>] __blk_run_queue+0x33/0x40\n  [<ffffffff8131781a>] queue_unplugged+0x2a/0x90\n  [<ffffffff8131ceb4>] blk_flush_plug_list+0x1b4/0x210\n  [<ffffffff8131d274>] blk_finish_plug+0x14/0x50\n  [<ffffffff8117eaa8>] __do_page_cache_readahead+0x198/0x1f0\n  [<ffffffff8117ee21>] force_page_cache_readahead+0x31/0x50\n  [<ffffffff8117ee7e>] page_cache_sync_readahead+0x3e/0x50\n  [<ffffffff81172ac6>] generic_file_read_iter+0x496/0x5a0\n  [<ffffffff81219897>] blkdev_read_iter+0x37/0x40\n  [<ffffffff811e307e>] new_sync_read+0x7e/0xb0\n  [<ffffffff811e3734>] vfs_read+0x94/0x170\n  [<ffffffff811e43c6>] SyS_read+0x46/0xb0\n  [<ffffffff811e33d1>] ? SyS_lseek+0x91/0xb0\n  [<ffffffff8171ee29>] system_call_fastpath+0x16/0x1b\n Code: 00 00 00 88 50 29 83 7f 08 01 19 d2 83 e2 f0 83 ea 50 88 50 34 c6 81 1d 02 00 00 40 c6 81 17 02 00 00 00 5d c3 66 0f 1f 44 00 00 <89> 14 25 58 00 00 00\n\nFix it by introducing ata_host->n_tags which is initialized to\nATA_MAX_QUEUE - 1 in ata_host_init() for SAS controllers and set to\nscsi_host_template->can_queue in ata_host_register() for !SAS ones.\nAs SAS hosts are never registered, this will give them the same\nATA_MAX_QUEUE - 1 as before.  Note that we can't use\nscsi_host->can_queue directly for SAS hosts anyway as they can go\nhigher than the libata maximum.\n\nSigned-off-by: Tejun Heo <tj@kernel.org>\nReported-by: Mike Qiu <qiudayu@linux.vnet.ibm.com>\nReported-by: Jesse Brandeburg <jesse.brandeburg@gmail.com>\nReported-by: Peter Hurley <peter@hurleysoftware.com>\nReported-by: Peter Zijlstra <peterz@infradead.org>\nTested-by: Alexey Kardashevskiy <aik@ozlabs.ru>\nFixes: 1871ee134b73 (\"libata: support the ata host which implements a queue depth less than 32\")\nCc: Kevin Hao <haokexin@gmail.com>\nCc: Dan Williams <dan.j.williams@intel.com>\nCc: stable@vger.kernel.org",
        "before_after_code_files": [
          "drivers/ata/libata-core.c||drivers/ata/libata-core.c",
          "include/linux/libata.h||include/linux/libata.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/ata/libata-core.c||drivers/ata/libata-core.c": [
          "File: drivers/ata/libata-core.c -> drivers/ata/libata-core.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4798: static struct ata_queued_cmd *ata_qc_new(struct ata_port *ap)",
          "4799: {",
          "4800:  struct ata_queued_cmd *qc = NULL;",
          "4806:  if (unlikely(ap->pflags & ATA_PFLAG_FROZEN))",
          "",
          "[Removed Lines]",
          "4801:  unsigned int i, tag, max_queue;",
          "4803:  max_queue = ap->scsi_host->can_queue;",
          "",
          "[Added Lines]",
          "4801:  unsigned int max_queue = ap->host->n_tags;",
          "4802:  unsigned int i, tag;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "6094: {",
          "6095:  spin_lock_init(&host->lock);",
          "6096:  mutex_init(&host->eh_mutex);",
          "6097:  host->dev = dev;",
          "6098:  host->ops = ops;",
          "6099: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6096:  host->n_tags = ATA_MAX_QUEUE - 1;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "6175: {",
          "6176:  int i, rc;",
          "6189:  if (!(host->flags & ATA_HOST_STARTED)) {",
          "",
          "[Removed Lines]",
          "6182:  if (sht->can_queue > ATA_MAX_QUEUE) {",
          "6183:   dev_err(host->dev, \"BUG: the hardware max queue is too large\\n\");",
          "6184:   WARN_ON(1);",
          "6185:   return -EINVAL;",
          "6186:  }",
          "",
          "[Added Lines]",
          "6178:  host->n_tags = clamp(sht->can_queue, 1, ATA_MAX_QUEUE - 1);",
          "",
          "---------------"
        ],
        "include/linux/libata.h||include/linux/libata.h": [
          "File: include/linux/libata.h -> include/linux/libata.h"
        ]
      }
    },
    {
      "candidate_hash": "05ac65305437e8ef63d2d19cac704138a2a05aa5",
      "candidate_info": {
        "commit_hash": "05ac65305437e8ef63d2d19cac704138a2a05aa5",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/05ac65305437e8ef63d2d19cac704138a2a05aa5",
        "files": [
          "arch/arm64/include/asm/tlbflush.h"
        ],
        "message": "arm64: fix soft lockup due to large tlb flush range\n\nUnder certain loads, this soft lockup has been observed:\n\n   BUG: soft lockup - CPU#2 stuck for 22s! [ip6tables:1016]\n   Modules linked in: ip6t_rpfilter ip6t_REJECT cfg80211 rfkill xt_conntrack ebtable_nat ebtable_broute bridge stp llc ebtable_filter ebtables ip6table_nat nf_conntrack_ipv6 nf_defrag_ipv6 nf_nat_ipv6 ip6table_mangle ip6table_security ip6table_raw ip6table_filter ip6_tables iptable_nat nf_conntrack_ipv4 nf_defrag_ipv4 nf_nat_ipv4 nf_nat nf_conntrack iptable_mangle iptable_security iptable_raw vfat fat efivarfs xfs libcrc32c\n\n   CPU: 2 PID: 1016 Comm: ip6tables Not tainted 3.13.0-0.rc7.30.sa2.aarch64 #1\n   task: fffffe03e81d1400 ti: fffffe03f01f8000 task.ti: fffffe03f01f8000\n   PC is at __cpu_flush_kern_tlb_range+0xc/0x40\n   LR is at __purge_vmap_area_lazy+0x28c/0x3ac\n   pc : [<fffffe000009c5cc>] lr : [<fffffe0000182710>] pstate: 80000145\n   sp : fffffe03f01fbb70\n   x29: fffffe03f01fbb70 x28: fffffe03f01f8000\n   x27: fffffe0000b19000 x26: 00000000000000d0\n   x25: 000000000000001c x24: fffffe03f01fbc50\n   x23: fffffe03f01fbc58 x22: fffffe03f01fbc10\n   x21: fffffe0000b2a3f8 x20: 0000000000000802\n   x19: fffffe0000b2a3c8 x18: 000003fffdf52710\n   x17: 000003ff9d8bb910 x16: fffffe000050fbfc\n   x15: 0000000000005735 x14: 000003ff9d7e1a5c\n   x13: 0000000000000000 x12: 000003ff9d7e1a5c\n   x11: 0000000000000007 x10: fffffe0000c09af0\n   x9 : fffffe0000ad1000 x8 : 000000000000005c\n   x7 : fffffe03e8624000 x6 : 0000000000000000\n   x5 : 0000000000000000 x4 : 0000000000000000\n   x3 : fffffe0000c09cc8 x2 : 0000000000000000\n   x1 : 000fffffdfffca80 x0 : 000fffffcd742150\n\nThe __cpu_flush_kern_tlb_range() function looks like:\n\n  ENTRY(__cpu_flush_kern_tlb_range)\n\tdsb\tsy\n\tlsr\tx0, x0, #12\n\tlsr\tx1, x1, #12\n  1:\ttlbi\tvaae1is, x0\n\tadd\tx0, x0, #1\n\tcmp\tx0, x1\n\tb.lo\t1b\n\tdsb\tsy\n\tisb\n\tret\n  ENDPROC(__cpu_flush_kern_tlb_range)\n\nThe above soft lockup shows the PC at tlbi insn with:\n\n  x0 = 0x000fffffcd742150\n  x1 = 0x000fffffdfffca80\n\nSo __cpu_flush_kern_tlb_range has 0x128ba930 tlbi flushes left\nafter it has already been looping for 23 seconds!.\n\nLooking up one frame at __purge_vmap_area_lazy(), there is:\n\n\t...\n\tlist_for_each_entry_rcu(va, &vmap_area_list, list) {\n\t\tif (va->flags & VM_LAZY_FREE) {\n\t\t\tif (va->va_start < *start)\n\t\t\t\t*start = va->va_start;\n\t\t\tif (va->va_end > *end)\n\t\t\t\t*end = va->va_end;\n\t\t\tnr += (va->va_end - va->va_start) >> PAGE_SHIFT;\n\t\t\tlist_add_tail(&va->purge_list, &valist);\n\t\t\tva->flags |= VM_LAZY_FREEING;\n\t\t\tva->flags &= ~VM_LAZY_FREE;\n\t\t}\n\t}\n\t...\n\tif (nr || force_flush)\n\t\tflush_tlb_kernel_range(*start, *end);\n\nSo if two areas are being freed, the range passed to\nflush_tlb_kernel_range() may be as large as the vmalloc\nspace. For arm64, this is ~240GB for 4k pagesize and ~2TB\nfor 64kpage size.\n\nThis patch works around this problem by adding a loop limit.\nIf the range is larger than the limit, use flush_tlb_all()\nrather than flushing based on individual pages. The limit\nchosen is arbitrary as the TLB size is implementation\nspecific and not accessible in an architected way. The aim\nof the arbitrary limit is to avoid soft lockup.\n\nSigned-off-by: Mark Salter <msalter@redhat.com>\n[catalin.marinas@arm.com: commit log update]\n[catalin.marinas@arm.com: marginal optimisation]\n[catalin.marinas@arm.com: changed to MAX_TLB_RANGE and added comment]\nSigned-off-by: Catalin Marinas <catalin.marinas@arm.com>",
        "before_after_code_files": [
          "arch/arm64/include/asm/tlbflush.h||arch/arm64/include/asm/tlbflush.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "arch/arm64/include/asm/tlbflush.h||arch/arm64/include/asm/tlbflush.h": [
          "File: arch/arm64/include/asm/tlbflush.h -> arch/arm64/include/asm/tlbflush.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "98:  dsb(ish);",
          "99: }",
          "103: {",
          "104:  unsigned long asid = (unsigned long)ASID(vma->vm_mm) << 48;",
          "105:  unsigned long addr;",
          "",
          "[Removed Lines]",
          "101: static inline void flush_tlb_range(struct vm_area_struct *vma,",
          "102:      unsigned long start, unsigned long end)",
          "",
          "[Added Lines]",
          "101: static inline void __flush_tlb_range(struct vm_area_struct *vma,",
          "102:          unsigned long start, unsigned long end)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "112:  dsb(ish);",
          "113: }",
          "116: {",
          "117:  unsigned long addr;",
          "118:  start >>= 12;",
          "",
          "[Removed Lines]",
          "115: static inline void flush_tlb_kernel_range(unsigned long start, unsigned long end)",
          "",
          "[Added Lines]",
          "115: static inline void __flush_tlb_kernel_range(unsigned long start, unsigned long end)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "125:  isb();",
          "126: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "132: #define MAX_TLB_RANGE (1024UL << PAGE_SHIFT)",
          "134: static inline void flush_tlb_range(struct vm_area_struct *vma,",
          "135:        unsigned long start, unsigned long end)",
          "136: {",
          "137:  if ((end - start) <= MAX_TLB_RANGE)",
          "138:   __flush_tlb_range(vma, start, end);",
          "139:  else",
          "140:   flush_tlb_mm(vma->vm_mm);",
          "141: }",
          "143: static inline void flush_tlb_kernel_range(unsigned long start, unsigned long end)",
          "144: {",
          "145:  if ((end - start) <= MAX_TLB_RANGE)",
          "146:   __flush_tlb_kernel_range(start, end);",
          "147:  else",
          "148:   flush_tlb_all();",
          "149: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "c5946f9d286ad368329c79107fdf4d825d2091bd",
      "candidate_info": {
        "commit_hash": "c5946f9d286ad368329c79107fdf4d825d2091bd",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/c5946f9d286ad368329c79107fdf4d825d2091bd",
        "files": [
          "drivers/usb/core/hcd-pci.c"
        ],
        "message": "USB: core: hcd-pci: free IRQ before disabling PCI device when shutting down\n\nThe assigned IRQ should be freed before calling pci_disable_device()\nwhen shutting down system, otherwise it will cause following warning.\n[  568.879482] ------------[ cut here ]------------\n[  568.884236] WARNING: CPU: 1 PID: 3300 at /home/konrad/ssd/konrad/xtt-i386/bootstrap/linux-usb/fs/proc/generic.c:521 remove_proc_entry+0x165/0x170()\n[  568.897846] remove_proc_entry: removing non-empty directory 'irq/16', leaking at least 'ohci_hcd:usb4'\n[  568.907430] Modules linked in: dm_multipath dm_mod iscsi_boot_sysfs iscsi_tcp libiscsi_tcp libiscsi scsi_transport_iscsi libcrc32c crc32c_generic sg sd_mod crct10dif_generic crc_t10dif crct10dif_common radeon fbcon tileblit ttm font bitblit softcursor ata_generic ahci libahci drm_kms_helper skge r8169 libata mii scsi_mod wmi acpi_cpufreq\n[  568.938539] CPU: 1 PID: 3300 Comm: init Tainted: G        W     3.16.0-rc5upstream-01651-g03b9189 #1\n[  568.947946] Hardware name: ECS A780GM-A Ultra/A780GM-A Ultra, BIOS 080015  04/01/2010\n[  568.956008]  00000209 ed0f1cd0 c1617946 c175403c ed0f1d00 c1090c3f c1754084 ed0f1d2c\n[  568.964068]  00000ce4 c175403c 00000209 c11f22a5 c11f22a5 f755e8c0 ed0f1d78 f755e90d\n[  568.972128]  ed0f1d18 c1090cde 00000009 ed0f1d10 c1754084 ed0f1d2c ed0f1d60 c11f22a5\n[  568.980194] Call Trace:\n[  568.982715]  [<c1617946>] dump_stack+0x48/0x60\n[  568.987294]  [<c1090c3f>] warn_slowpath_common+0x7f/0xa0\n[  569.003887]  [<c1090cde>] warn_slowpath_fmt+0x2e/0x30\n[  569.009092]  [<c11f22a5>] remove_proc_entry+0x165/0x170\n[  569.014476]  [<c10da6ca>] unregister_irq_proc+0xaa/0xc0\n[  569.019858]  [<c10d582f>] free_desc+0x1f/0x60\n[  569.024346]  [<c10d58aa>] irq_free_descs+0x3a/0x80\n[  569.029283]  [<c10d9e9d>] irq_dispose_mapping+0x2d/0x50\n[  569.034666]  [<c1078fd3>] mp_unmap_irq+0x73/0xa0\n[  569.039423]  [<c107196b>] acpi_unregister_gsi_ioapic+0x2b/0x40\n[  569.045431]  [<c107180f>] acpi_unregister_gsi+0xf/0x20\n[  569.050725]  [<c1339cad>] acpi_pci_irq_disable+0x4b/0x50\n[  569.056196]  [<c14daa38>] pcibios_disable_device+0x18/0x20\n[  569.061848]  [<c130123d>] do_pci_disable_device+0x4d/0x60\n[  569.067410]  [<c13012b7>] pci_disable_device+0x47/0xb0\n[  569.077814]  [<c14800b1>] usb_hcd_pci_shutdown+0x31/0x40\n[  569.083285]  [<c1304b19>] pci_device_shutdown+0x19/0x50\n[  569.088667]  [<c13fda64>] device_shutdown+0x14/0x120\n[  569.093777]  [<c10ac29d>] kernel_restart_prepare+0x2d/0x30\n[  569.099429]  [<c10ac41e>] kernel_restart+0xe/0x60\n[  569.109028]  [<c10ac611>] SYSC_reboot+0x191/0x220\n[  569.159269]  [<c10ac6ba>] SyS_reboot+0x1a/0x20\n[  569.163843]  [<c161c718>] sysenter_do_call+0x12/0x16\n[  569.168951] ---[ end trace ccc1ec4471c289c9 ]---\n\nTested-by: Aaron Lu <aaron.lu@intel.com>\nSigned-off-by: Jiang Liu <jiang.liu@linux.intel.com>\nReviewed-by: Huang Rui <ray.huang@amd.com>\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>",
        "before_after_code_files": [
          "drivers/usb/core/hcd-pci.c||drivers/usb/core/hcd-pci.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/usb/core/hcd-pci.c||drivers/usb/core/hcd-pci.c": [
          "File: drivers/usb/core/hcd-pci.c -> drivers/usb/core/hcd-pci.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "380:  if (test_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags) &&",
          "381:    hcd->driver->shutdown) {",
          "382:   hcd->driver->shutdown(hcd);",
          "383:   pci_disable_device(dev);",
          "384:  }",
          "385: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "383:   if (usb_hcd_is_primary_hcd(hcd) && hcd->irq > 0)",
          "384:    free_irq(hcd->irq, hcd);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b19729617929fff8217708f6e960cd85e6f53da2",
      "candidate_info": {
        "commit_hash": "b19729617929fff8217708f6e960cd85e6f53da2",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/b19729617929fff8217708f6e960cd85e6f53da2",
        "files": [
          "drivers/gpu/drm/i915/intel_dp.c"
        ],
        "message": "drm/i915: fix psr match conditions screw ups.\n\nNot enough brown paper bags, you'll have to share one.\n(oops below).\n\nThe initial match condition code was racy (locking is coming I hear).\n\nthen along came:\ncd234b0bfd5ab012e42274b24aae420fa1823d58\ndrm/i915: Do not dereference NULL crtc or fb until after checking\n\nChris made an attempt to fix it, Ben \"reviewed\" it.\nDaniel merged it.\n\nThen\ndrm/i915: Make use of intel_fb_obj() (v2)\n2ff8fde1ea0992dfd735dce94f8cae2aacff8e5c\n\nmade it worse by removing the obj check later.\n\nAll in all, my laptop can't barely turn off the display\nwithout hitting this.\n\nPosted to #intel-gfx out of niceness, but I've merged\nthis already into drm-next.\n\nHere's an oops.\n[   11.528185] BUG: unable to handle kernel NULL pointer dereference at 00000000000000d0\n[   11.528233] IP: [<ffffffffa0161fde>] intel_edp_psr_match_conditions+0x1e/0x2e0 [i915]\n[   11.528294] PGD 35bc0067 PUD c997c067 PMD 0\n[   11.528321] Oops: 0000 [#1] SMP\n[   11.528916] CPU: 3 PID: 244 Comm: kworker/3:2 Not tainted 3.16.0-rc4+ #17\n[   11.528949] Hardware name: LENOVO 20ARS25701/20ARS25701, BIOS GJET72WW (2.22 ) 02/21/2014\n[   11.529004] Workqueue: events intel_edp_psr_work [i915]\n[   11.529031] task: ffff8803079fdaa0 ti: ffff8803079c4000 task.ti: ffff8803079c4000\n[   11.529067] RIP: 0010:[<ffffffffa0161fde>]  [<ffffffffa0161fde>] intel_edp_psr_match_conditions+0x1e/0x2e0 [i915]\n[   11.529129] RSP: 0018:ffff8803079c7d40  EFLAGS: 00010246\n[   11.529155] RAX: 0000000000000000 RBX: ffff88030c11c000 RCX: c000000000000000\n[   11.529189] RDX: 0000000000000001 RSI: 1df0000000000000 RDI: ffff88030c1190d8\n[   11.529222] RBP: ffff8803079c7d60 R08: ffffffff82691140 R09: 0000000000000000\n[   11.529256] R10: ffff8803079fdaa0 R11: 3e00000000000000 R12: ffff88030c11c728\n[   11.529290] R13: ffff88030c1190d8 R14: ffff88031e2d8e00 R15: 00000000000000c0\n[   11.529324] FS:  0000000000000000(0000) GS:ffff88031e2c0000(0000) knlGS:0000000000000000\n[   11.529361] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[   11.529389] CR2: 00000000000000d0 CR3: 00000000c8d9d000 CR4: 00000000001407e0\n[   11.529423] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n[   11.529457] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n[   11.529489] Stack:\n[   11.529500]  ffff88030c119000 ffff88030c11c728 ffff88030c1190d8 ffff88031e2d8e00\n[   11.529541]  ffff8803079c7d88 ffffffffa01679b2 ffff880035b29a80 ffff880307909f00\n[   11.529583]  ffff88031e2d4740 ffff8803079c7df8 ffffffff810a78ab ffffffff810a7849\n[   11.529624] Call Trace:\n[   11.529654]  [<ffffffffa01679b2>] intel_edp_psr_work+0x52/0x90 [i915]\n[   11.529689]  [<ffffffff810a78ab>] process_one_work+0x1db/0x540\n[   11.529719]  [<ffffffff810a7849>] ? process_one_work+0x179/0x540\n[   11.529750]  [<ffffffff810a81ed>] worker_thread+0x11d/0x520\n[   11.529779]  [<ffffffff810a80d0>] ? create_and_start_worker+0x60/0x60\n[   11.529810]  [<ffffffff810aeb04>] kthread+0xe4/0x100\n[   11.529836]  [<ffffffff810aea20>] ? kthread_create_on_node+0x200/0x200\n[   11.529870]  [<ffffffff81705ebc>] ret_from_fork+0x7c/0xb0\n[   11.529896]  [<ffffffff810aea20>] ? kthread_create_on_node+0x200/0x200\n[   11.529926] Code: ba 31 13 f0 c9 85 f6 75 84 eb d0 66 90 0f 1f 44 00 00 55 48 89 e5 41 56 41 55 41 54 53 48 8b 87 68 ff ff ff 48 8b 9f 28 ff ff ff <48> 8b 80 d0 00 00 00 4c 8b 63 28 48 8b 40 48 48 85 c0 0f 84 1a\n[   11.530110] RIP  [<ffffffffa0161fde>] intel_edp_psr_match_conditions+0x1e/0x2e0 [i915]\n[   11.530163]  RSP <ffff8803079c7d40>\n[   11.530180] CR2: 00000000000000d0\n\nSigned-off-by: Dave Airlie <airlied@redhat.com>",
        "before_after_code_files": [
          "drivers/gpu/drm/i915/intel_dp.c||drivers/gpu/drm/i915/intel_dp.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/gpu/drm/i915/intel_dp.c||drivers/gpu/drm/i915/intel_dp.c": [
          "File: drivers/gpu/drm/i915/intel_dp.c -> drivers/gpu/drm/i915/intel_dp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1767:  struct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);",
          "1768:  struct drm_device *dev = dig_port->base.base.dev;",
          "1769:  struct drm_i915_private *dev_priv = dev->dev_private;",
          "1773:  struct intel_encoder *intel_encoder = &dp_to_dig_port(intel_dp)->base;",
          "1775:  dev_priv->psr.source_ok = false;",
          "",
          "[Removed Lines]",
          "1770:  struct drm_crtc *crtc = dig_port->base.base.crtc;",
          "1771:  struct intel_crtc *intel_crtc = to_intel_crtc(crtc);",
          "1772:  struct drm_i915_gem_object *obj = intel_fb_obj(crtc->primary->fb);",
          "",
          "[Added Lines]",
          "1770:  struct drm_crtc *crtc;",
          "1771:  struct intel_crtc *intel_crtc;",
          "1772:  struct drm_i915_gem_object *obj;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1802:   return false;",
          "1803:  }",
          "1805:  if (obj->tiling_mode != I915_TILING_X ||",
          "1806:      obj->fence_reg == I915_FENCE_REG_NONE) {",
          "1807:   DRM_DEBUG_KMS(\"PSR condition failed: fb not tiled or fenced\\n\");",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1805:  obj = intel_fb_obj(crtc->primary->fb);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
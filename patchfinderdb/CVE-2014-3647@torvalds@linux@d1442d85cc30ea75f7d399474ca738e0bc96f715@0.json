{
  "cve_id": "CVE-2014-3647",
  "cve_desc": "arch/x86/kvm/emulate.c in the KVM subsystem in the Linux kernel through 3.17.2 does not properly perform RIP changes, which allows guest OS users to cause a denial of service (guest OS crash) via a crafted application.",
  "repo": "torvalds/linux",
  "patch_hash": "d1442d85cc30ea75f7d399474ca738e0bc96f715",
  "patch_info": {
    "commit_hash": "d1442d85cc30ea75f7d399474ca738e0bc96f715",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/d1442d85cc30ea75f7d399474ca738e0bc96f715",
    "files": [
      "arch/x86/kvm/emulate.c"
    ],
    "message": "KVM: x86: Handle errors when RIP is set during far jumps\n\nFar jmp/call/ret may fault while loading a new RIP.  Currently KVM does not\nhandle this case, and may result in failed vm-entry once the assignment is\ndone.  The tricky part of doing so is that loading the new CS affects the\nVMCS/VMCB state, so if we fail during loading the new RIP, we are left in\nunconsistent state.  Therefore, this patch saves on 64-bit the old CS\ndescriptor and restores it if loading RIP failed.\n\nThis fixes CVE-2014-3647.\n\nCc: stable@vger.kernel.org\nSigned-off-by: Nadav Amit <namit@cs.technion.ac.il>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>",
    "before_after_code_files": [
      "arch/x86/kvm/emulate.c||arch/x86/kvm/emulate.c"
    ]
  },
  "patch_diff": {
    "arch/x86/kvm/emulate.c||arch/x86/kvm/emulate.c": [
      "File: arch/x86/kvm/emulate.c -> arch/x86/kvm/emulate.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1445: static int __load_segment_descriptor(struct x86_emulate_ctxt *ctxt,",
      "1447: {",
      "1448:  struct desc_struct seg_desc, old_desc;",
      "1449:  u8 dpl, rpl;",
      "",
      "[Removed Lines]",
      "1446:          u16 selector, int seg, u8 cpl, bool in_task_switch)",
      "",
      "[Added Lines]",
      "1446:          u16 selector, int seg, u8 cpl,",
      "1447:          bool in_task_switch,",
      "1448:          struct desc_struct *desc)",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1584:  }",
      "1585: load:",
      "1586:  ctxt->ops->set_segment(ctxt, selector, &seg_desc, base3, seg);",
      "1587:  return X86EMUL_CONTINUE;",
      "1588: exception:",
      "1589:  return emulate_exception(ctxt, err_vec, err_code, true);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1589:  if (desc)",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1593:        u16 selector, int seg)",
      "1594: {",
      "1595:  u8 cpl = ctxt->ops->cpl(ctxt);",
      "1597: }",
      "1599: static void write_register_operand(struct operand *op)",
      "",
      "[Removed Lines]",
      "1596:  return __load_segment_descriptor(ctxt, selector, seg, cpl, false);",
      "",
      "[Added Lines]",
      "1600:  return __load_segment_descriptor(ctxt, selector, seg, cpl, false, NULL);",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "1987: static int em_jmp_far(struct x86_emulate_ctxt *ctxt)",
      "1988: {",
      "1989:  int rc;",
      "1992:  memcpy(&sel, ctxt->src.valptr + ctxt->op_bytes, 2);",
      "1995:  if (rc != X86EMUL_CONTINUE)",
      "1996:   return rc;",
      "2001: }",
      "2003: static int em_grp45(struct x86_emulate_ctxt *ctxt)",
      "",
      "[Removed Lines]",
      "1990:  unsigned short sel;",
      "1994:  rc = load_segment_descriptor(ctxt, sel, VCPU_SREG_CS);",
      "1998:  ctxt->_eip = 0;",
      "1999:  memcpy(&ctxt->_eip, ctxt->src.valptr, ctxt->op_bytes);",
      "2000:  return X86EMUL_CONTINUE;",
      "",
      "[Added Lines]",
      "1994:  unsigned short sel, old_sel;",
      "1995:  struct desc_struct old_desc, new_desc;",
      "1996:  const struct x86_emulate_ops *ops = ctxt->ops;",
      "1997:  u8 cpl = ctxt->ops->cpl(ctxt);",
      "2000:  if (ctxt->mode == X86EMUL_MODE_PROT64)",
      "2001:   ops->get_segment(ctxt, &old_sel, &old_desc, NULL,",
      "2002:      VCPU_SREG_CS);",
      "2006:  rc = __load_segment_descriptor(ctxt, sel, VCPU_SREG_CS, cpl, false,",
      "2007:            &new_desc);",
      "2011:  rc = assign_eip_far(ctxt, ctxt->src.val, new_desc.l);",
      "2012:  if (rc != X86EMUL_CONTINUE) {",
      "2013:   WARN_ON(!ctxt->mode != X86EMUL_MODE_PROT64);",
      "2015:   ops->set_segment(ctxt, old_sel, &old_desc, 0, VCPU_SREG_CS);",
      "2016:   return rc;",
      "2017:  }",
      "2018:  return rc;",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "2064: static int em_ret_far(struct x86_emulate_ctxt *ctxt)",
      "2065: {",
      "2066:  int rc;",
      "2068:  int cpl = ctxt->ops->cpl(ctxt);",
      "2071:  if (rc != X86EMUL_CONTINUE)",
      "2072:   return rc;",
      "2075:  rc = emulate_pop(ctxt, &cs, ctxt->op_bytes);",
      "2076:  if (rc != X86EMUL_CONTINUE)",
      "2077:   return rc;",
      "2079:  if (ctxt->mode >= X86EMUL_MODE_PROT16 && (cs & 3) > cpl)",
      "2080:   return X86EMUL_UNHANDLEABLE;",
      "2082:  return rc;",
      "2083: }",
      "",
      "[Removed Lines]",
      "2067:  unsigned long cs;",
      "2070:  rc = emulate_pop(ctxt, &ctxt->_eip, ctxt->op_bytes);",
      "2073:  if (ctxt->op_bytes == 4)",
      "2074:   ctxt->_eip = (u32)ctxt->_eip;",
      "2081:  rc = load_segment_descriptor(ctxt, (u16)cs, VCPU_SREG_CS);",
      "",
      "[Added Lines]",
      "2085:  unsigned long eip, cs;",
      "2086:  u16 old_cs;",
      "2088:  struct desc_struct old_desc, new_desc;",
      "2089:  const struct x86_emulate_ops *ops = ctxt->ops;",
      "2091:  if (ctxt->mode == X86EMUL_MODE_PROT64)",
      "2092:   ops->get_segment(ctxt, &old_cs, &old_desc, NULL,",
      "2093:      VCPU_SREG_CS);",
      "2095:  rc = emulate_pop(ctxt, &eip, ctxt->op_bytes);",
      "2104:  rc = __load_segment_descriptor(ctxt, (u16)cs, VCPU_SREG_CS, 0, false,",
      "2105:            &new_desc);",
      "2106:  if (rc != X86EMUL_CONTINUE)",
      "2107:   return rc;",
      "2108:  rc = assign_eip_far(ctxt, eip, new_desc.l);",
      "2109:  if (rc != X86EMUL_CONTINUE) {",
      "2110:   WARN_ON(!ctxt->mode != X86EMUL_MODE_PROT64);",
      "2111:   ops->set_segment(ctxt, old_cs, &old_desc, 0, VCPU_SREG_CS);",
      "2112:  }",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "2509:  if (ret != X86EMUL_CONTINUE)",
      "2510:   return ret;",
      "2512:  if (ret != X86EMUL_CONTINUE)",
      "2513:   return ret;",
      "2515:  if (ret != X86EMUL_CONTINUE)",
      "2516:   return ret;",
      "2518:  if (ret != X86EMUL_CONTINUE)",
      "2519:   return ret;",
      "2521:  if (ret != X86EMUL_CONTINUE)",
      "2522:   return ret;",
      "",
      "[Removed Lines]",
      "2508:  ret = __load_segment_descriptor(ctxt, tss->ldt, VCPU_SREG_LDTR, cpl, true);",
      "2511:  ret = __load_segment_descriptor(ctxt, tss->es, VCPU_SREG_ES, cpl, true);",
      "2514:  ret = __load_segment_descriptor(ctxt, tss->cs, VCPU_SREG_CS, cpl, true);",
      "2517:  ret = __load_segment_descriptor(ctxt, tss->ss, VCPU_SREG_SS, cpl, true);",
      "2520:  ret = __load_segment_descriptor(ctxt, tss->ds, VCPU_SREG_DS, cpl, true);",
      "",
      "[Added Lines]",
      "2539:  ret = __load_segment_descriptor(ctxt, tss->ldt, VCPU_SREG_LDTR, cpl,",
      "2540:      true, NULL);",
      "2543:  ret = __load_segment_descriptor(ctxt, tss->es, VCPU_SREG_ES, cpl,",
      "2544:      true, NULL);",
      "2547:  ret = __load_segment_descriptor(ctxt, tss->cs, VCPU_SREG_CS, cpl,",
      "2548:      true, NULL);",
      "2551:  ret = __load_segment_descriptor(ctxt, tss->ss, VCPU_SREG_SS, cpl,",
      "2552:      true, NULL);",
      "2555:  ret = __load_segment_descriptor(ctxt, tss->ds, VCPU_SREG_DS, cpl,",
      "2556:      true, NULL);",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "2646:  if (ret != X86EMUL_CONTINUE)",
      "2647:   return ret;",
      "2649:  if (ret != X86EMUL_CONTINUE)",
      "2650:   return ret;",
      "2652:  if (ret != X86EMUL_CONTINUE)",
      "2653:   return ret;",
      "2655:  if (ret != X86EMUL_CONTINUE)",
      "2656:   return ret;",
      "2658:  if (ret != X86EMUL_CONTINUE)",
      "2659:   return ret;",
      "2661:  if (ret != X86EMUL_CONTINUE)",
      "2662:   return ret;",
      "2664:  if (ret != X86EMUL_CONTINUE)",
      "2665:   return ret;",
      "",
      "[Removed Lines]",
      "2645:  ret = __load_segment_descriptor(ctxt, tss->ldt_selector, VCPU_SREG_LDTR, cpl, true);",
      "2648:  ret = __load_segment_descriptor(ctxt, tss->es, VCPU_SREG_ES, cpl, true);",
      "2651:  ret = __load_segment_descriptor(ctxt, tss->cs, VCPU_SREG_CS, cpl, true);",
      "2654:  ret = __load_segment_descriptor(ctxt, tss->ss, VCPU_SREG_SS, cpl, true);",
      "2657:  ret = __load_segment_descriptor(ctxt, tss->ds, VCPU_SREG_DS, cpl, true);",
      "2660:  ret = __load_segment_descriptor(ctxt, tss->fs, VCPU_SREG_FS, cpl, true);",
      "2663:  ret = __load_segment_descriptor(ctxt, tss->gs, VCPU_SREG_GS, cpl, true);",
      "",
      "[Added Lines]",
      "2681:  ret = __load_segment_descriptor(ctxt, tss->ldt_selector, VCPU_SREG_LDTR,",
      "2682:      cpl, true, NULL);",
      "2685:  ret = __load_segment_descriptor(ctxt, tss->es, VCPU_SREG_ES, cpl,",
      "2686:      true, NULL);",
      "2689:  ret = __load_segment_descriptor(ctxt, tss->cs, VCPU_SREG_CS, cpl,",
      "2690:      true, NULL);",
      "2693:  ret = __load_segment_descriptor(ctxt, tss->ss, VCPU_SREG_SS, cpl,",
      "2694:      true, NULL);",
      "2697:  ret = __load_segment_descriptor(ctxt, tss->ds, VCPU_SREG_DS, cpl,",
      "2698:      true, NULL);",
      "2701:  ret = __load_segment_descriptor(ctxt, tss->fs, VCPU_SREG_FS, cpl,",
      "2702:      true, NULL);",
      "2705:  ret = __load_segment_descriptor(ctxt, tss->gs, VCPU_SREG_GS, cpl,",
      "2706:      true, NULL);",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "2942:  u16 sel, old_cs;",
      "2943:  ulong old_eip;",
      "2944:  int rc;",
      "2947:  old_eip = ctxt->_eip;",
      "2949:  memcpy(&sel, ctxt->src.valptr + ctxt->op_bytes, 2);",
      "2951:   return X86EMUL_CONTINUE;",
      "2956:  ctxt->src.val = old_cs;",
      "2957:  rc = em_push(ctxt);",
      "2958:  if (rc != X86EMUL_CONTINUE)",
      "2961:  ctxt->src.val = old_eip;",
      "2963: }",
      "2965: static int em_ret_near_imm(struct x86_emulate_ctxt *ctxt)",
      "",
      "[Removed Lines]",
      "2946:  old_cs = get_segment_selector(ctxt, VCPU_SREG_CS);",
      "2950:  if (load_segment_descriptor(ctxt, sel, VCPU_SREG_CS))",
      "2953:  ctxt->_eip = 0;",
      "2954:  memcpy(&ctxt->_eip, ctxt->src.valptr, ctxt->op_bytes);",
      "2959:   return rc;",
      "2962:  return em_push(ctxt);",
      "",
      "[Added Lines]",
      "2988:  struct desc_struct old_desc, new_desc;",
      "2989:  const struct x86_emulate_ops *ops = ctxt->ops;",
      "2990:  int cpl = ctxt->ops->cpl(ctxt);",
      "2993:  ops->get_segment(ctxt, &old_cs, &old_desc, NULL, VCPU_SREG_CS);",
      "2996:  rc = __load_segment_descriptor(ctxt, sel, VCPU_SREG_CS, cpl, false,",
      "2997:            &new_desc);",
      "2998:  if (rc != X86EMUL_CONTINUE)",
      "3001:  rc = assign_eip_far(ctxt, ctxt->src.val, new_desc.l);",
      "3002:  if (rc != X86EMUL_CONTINUE)",
      "3003:   goto fail;",
      "3008:   goto fail;",
      "3011:  rc = em_push(ctxt);",
      "3014:  if (rc != X86EMUL_CONTINUE)",
      "3015:   goto fail;",
      "3016:  return rc;",
      "3017: fail:",
      "3018:  ops->set_segment(ctxt, old_cs, &old_desc, 0, VCPU_SREG_CS);",
      "3019:  return rc;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "234f3ce485d54017f15cf5e0699cff4100121601",
      "candidate_info": {
        "commit_hash": "234f3ce485d54017f15cf5e0699cff4100121601",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/234f3ce485d54017f15cf5e0699cff4100121601",
        "files": [
          "arch/x86/kvm/emulate.c"
        ],
        "message": "KVM: x86: Emulator fixes for eip canonical checks on near branches\n\nBefore changing rip (during jmp, call, ret, etc.) the target should be asserted\nto be canonical one, as real CPUs do.  During sysret, both target rsp and rip\nshould be canonical. If any of these values is noncanonical, a #GP exception\nshould occur.  The exception to this rule are syscall and sysenter instructions\nin which the assigned rip is checked during the assignment to the relevant\nMSRs.\n\nThis patch fixes the emulator to behave as real CPUs do for near branches.\nFar branches are handled by the next patch.\n\nThis fixes CVE-2014-3647.\n\nCc: stable@vger.kernel.org\nSigned-off-by: Nadav Amit <namit@cs.technion.ac.il>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>",
        "before_after_code_files": [
          "arch/x86/kvm/emulate.c||arch/x86/kvm/emulate.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "arch/x86/kvm/emulate.c||arch/x86/kvm/emulate.c"
          ],
          "candidate": [
            "arch/x86/kvm/emulate.c||arch/x86/kvm/emulate.c"
          ]
        }
      },
      "candidate_diff": {
        "arch/x86/kvm/emulate.c||arch/x86/kvm/emulate.c": [
          "File: arch/x86/kvm/emulate.c -> arch/x86/kvm/emulate.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "564:  return emulate_exception(ctxt, NM_VECTOR, 0, false);",
          "565: }",
          "568: {",
          "569:  switch (ctxt->op_bytes) {",
          "570:  case 2:",
          "",
          "[Removed Lines]",
          "567: static inline void assign_eip_near(struct x86_emulate_ctxt *ctxt, ulong dst)",
          "",
          "[Added Lines]",
          "567: static inline int assign_eip_far(struct x86_emulate_ctxt *ctxt, ulong dst,",
          "568:           int cs_l)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "574:   ctxt->_eip = (u32)dst;",
          "575:   break;",
          "576:  case 8:",
          "577:   ctxt->_eip = dst;",
          "578:   break;",
          "579:  default:",
          "580:   WARN(1, \"unsupported eip assignment size\\n\");",
          "581:  }",
          "582: }",
          "585: {",
          "587: }",
          "589: static u16 get_segment_selector(struct x86_emulate_ctxt *ctxt, unsigned seg)",
          "",
          "[Removed Lines]",
          "584: static inline void jmp_rel(struct x86_emulate_ctxt *ctxt, int rel)",
          "586:  assign_eip_near(ctxt, ctxt->_eip + rel);",
          "",
          "[Added Lines]",
          "578:   if ((cs_l && is_noncanonical_address(dst)) ||",
          "579:       (!cs_l && (dst & ~(u32)-1)))",
          "580:    return emulate_gp(ctxt, 0);",
          "586:  return X86EMUL_CONTINUE;",
          "587: }",
          "589: static inline int assign_eip_near(struct x86_emulate_ctxt *ctxt, ulong dst)",
          "590: {",
          "591:  return assign_eip_far(ctxt, dst, ctxt->mode == X86EMUL_MODE_PROT64);",
          "594: static inline int jmp_rel(struct x86_emulate_ctxt *ctxt, int rel)",
          "596:  return assign_eip_near(ctxt, ctxt->_eip + rel);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1998:  case 2: /* call near abs */ {",
          "1999:   long int old_eip;",
          "2000:   old_eip = ctxt->_eip;",
          "2002:   ctxt->src.val = old_eip;",
          "2003:   rc = em_push(ctxt);",
          "2004:   break;",
          "2005:  }",
          "2008:   break;",
          "2010:   rc = em_jmp_far(ctxt);",
          "",
          "[Removed Lines]",
          "2001:   ctxt->_eip = ctxt->src.val;",
          "2007:   ctxt->_eip = ctxt->src.val;",
          "",
          "[Added Lines]",
          "2011:   rc = assign_eip_near(ctxt, ctxt->src.val);",
          "2012:   if (rc != X86EMUL_CONTINUE)",
          "2013:    break;",
          "2019:   rc = assign_eip_near(ctxt, ctxt->src.val);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2040: static int em_ret(struct x86_emulate_ctxt *ctxt)",
          "2041: {",
          "2046: }",
          "2048: static int em_ret_far(struct x86_emulate_ctxt *ctxt)",
          "",
          "[Removed Lines]",
          "2042:  ctxt->dst.type = OP_REG;",
          "2043:  ctxt->dst.addr.reg = &ctxt->_eip;",
          "2044:  ctxt->dst.bytes = ctxt->op_bytes;",
          "2045:  return em_pop(ctxt);",
          "",
          "[Added Lines]",
          "2054:  int rc;",
          "2055:  unsigned long eip;",
          "2057:  rc = emulate_pop(ctxt, &eip, ctxt->op_bytes);",
          "2058:  if (rc != X86EMUL_CONTINUE)",
          "2059:   return rc;",
          "2061:  return assign_eip_near(ctxt, eip);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2323: {",
          "2324:  const struct x86_emulate_ops *ops = ctxt->ops;",
          "2325:  struct desc_struct cs, ss;",
          "2327:  int usermode;",
          "2328:  u16 cs_sel = 0, ss_sel = 0;",
          "",
          "[Removed Lines]",
          "2326:  u64 msr_data;",
          "",
          "[Added Lines]",
          "2342:  u64 msr_data, rcx, rdx;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2339:  else",
          "2340:   usermode = X86EMUL_MODE_PROT32;",
          "2342:  cs.dpl = 3;",
          "2343:  ss.dpl = 3;",
          "2344:  ops->get_msr(ctxt, MSR_IA32_SYSENTER_CS, &msr_data);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2358:  rcx = reg_read(ctxt, VCPU_REGS_RCX);",
          "2359:  rdx = reg_read(ctxt, VCPU_REGS_RDX);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "2356:   ss_sel = cs_sel + 8;",
          "2357:   cs.d = 0;",
          "2358:   cs.l = 1;",
          "2359:   break;",
          "2360:  }",
          "2361:  cs_sel |= SELECTOR_RPL_MASK;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2378:   if (is_noncanonical_address(rcx) ||",
          "2379:       is_noncanonical_address(rdx))",
          "2380:    return emulate_gp(ctxt, 0);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "2364:  ops->set_segment(ctxt, cs_sel, &cs, 0, VCPU_SREG_CS);",
          "2365:  ops->set_segment(ctxt, ss_sel, &ss, 0, VCPU_SREG_SS);",
          "2370:  return X86EMUL_CONTINUE;",
          "2371: }",
          "",
          "[Removed Lines]",
          "2367:  ctxt->_eip = reg_read(ctxt, VCPU_REGS_RDX);",
          "",
          "[Added Lines]",
          "2389:  ctxt->_eip = rdx;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "2906: static int em_call(struct x86_emulate_ctxt *ctxt)",
          "2907: {",
          "2908:  long rel = ctxt->src.val;",
          "2910:  ctxt->src.val = (unsigned long)ctxt->_eip;",
          "2912:  return em_push(ctxt);",
          "2913: }",
          "",
          "[Removed Lines]",
          "2911:  jmp_rel(ctxt, rel);",
          "",
          "[Added Lines]",
          "2930:  int rc;",
          "2934:  rc = jmp_rel(ctxt, rel);",
          "2935:  if (rc != X86EMUL_CONTINUE)",
          "2936:   return rc;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "2940: static int em_ret_near_imm(struct x86_emulate_ctxt *ctxt)",
          "2941: {",
          "2942:  int rc;",
          "2948:  if (rc != X86EMUL_CONTINUE)",
          "2949:   return rc;",
          "2950:  rsp_increment(ctxt, ctxt->src.val);",
          "",
          "[Removed Lines]",
          "2944:  ctxt->dst.type = OP_REG;",
          "2945:  ctxt->dst.addr.reg = &ctxt->_eip;",
          "2946:  ctxt->dst.bytes = ctxt->op_bytes;",
          "2947:  rc = emulate_pop(ctxt, &ctxt->dst.val, ctxt->op_bytes);",
          "",
          "[Added Lines]",
          "2968:  unsigned long eip;",
          "2970:  rc = emulate_pop(ctxt, &eip, ctxt->op_bytes);",
          "2971:  if (rc != X86EMUL_CONTINUE)",
          "2972:   return rc;",
          "2973:  rc = assign_eip_near(ctxt, eip);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "3272: static int em_loop(struct x86_emulate_ctxt *ctxt)",
          "3273: {",
          "3274:  register_address_increment(ctxt, reg_rmw(ctxt, VCPU_REGS_RCX), -1);",
          "3275:  if ((address_mask(ctxt, reg_read(ctxt, VCPU_REGS_RCX)) != 0) &&",
          "3276:      (ctxt->b == 0xe2 || test_cc(ctxt->b ^ 0x5, ctxt->eflags)))",
          "3280: }",
          "3282: static int em_jcxz(struct x86_emulate_ctxt *ctxt)",
          "3283: {",
          "3284:  if (address_mask(ctxt, reg_read(ctxt, VCPU_REGS_RCX)) == 0)",
          "3288: }",
          "3290: static int em_in(struct x86_emulate_ctxt *ctxt)",
          "",
          "[Removed Lines]",
          "3277:   jmp_rel(ctxt, ctxt->src.val);",
          "3279:  return X86EMUL_CONTINUE;",
          "3285:   jmp_rel(ctxt, ctxt->src.val);",
          "3287:  return X86EMUL_CONTINUE;",
          "",
          "[Added Lines]",
          "3300:  int rc = X86EMUL_CONTINUE;",
          "3305:   rc = jmp_rel(ctxt, ctxt->src.val);",
          "3307:  return rc;",
          "3312:  int rc = X86EMUL_CONTINUE;",
          "3315:   rc = jmp_rel(ctxt, ctxt->src.val);",
          "3317:  return rc;",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "4743:   break;",
          "4745:   if (test_cc(ctxt->b, ctxt->eflags))",
          "4747:   break;",
          "4749:   ctxt->dst.val = ctxt->src.addr.mem.ea;",
          "",
          "[Removed Lines]",
          "4746:    jmp_rel(ctxt, ctxt->src.val);",
          "",
          "[Added Lines]",
          "4776:    rc = jmp_rel(ctxt, ctxt->src.val);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "4773:   break;",
          "4778:   break;",
          "",
          "[Removed Lines]",
          "4776:   jmp_rel(ctxt, ctxt->src.val);",
          "",
          "[Added Lines]",
          "4806:   rc = jmp_rel(ctxt, ctxt->src.val);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "4898:   break;",
          "4900:   if (test_cc(ctxt->b, ctxt->eflags))",
          "4902:   break;",
          "4904:   ctxt->dst.val = test_cc(ctxt->b, ctxt->eflags);",
          "",
          "[Removed Lines]",
          "4901:    jmp_rel(ctxt, ctxt->src.val);",
          "",
          "[Added Lines]",
          "4931:    rc = jmp_rel(ctxt, ctxt->src.val);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "3dc4bc4f6b9265bd05dda007b07eac5a17da0562",
      "candidate_info": {
        "commit_hash": "3dc4bc4f6b9265bd05dda007b07eac5a17da0562",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/3dc4bc4f6b9265bd05dda007b07eac5a17da0562",
        "files": [
          "arch/x86/kvm/emulate.c"
        ],
        "message": "KVM: x86: JMP/CALL using call- or task-gate causes exception\n\nThe KVM emulator does not emulate JMP and CALL that target a call gate or a\ntask gate.  This patch does not try to implement these scenario as they are\npresumably rare; yet it returns X86EMUL_UNHANDLEABLE error in such cases\ninstead of generating an exception.\n\nSigned-off-by: Nadav Amit <namit@cs.technion.ac.il>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>",
        "before_after_code_files": [
          "arch/x86/kvm/emulate.c||arch/x86/kvm/emulate.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "arch/x86/kvm/emulate.c||arch/x86/kvm/emulate.c"
          ],
          "candidate": [
            "arch/x86/kvm/emulate.c||arch/x86/kvm/emulate.c"
          ]
        }
      },
      "candidate_diff": {
        "arch/x86/kvm/emulate.c||arch/x86/kvm/emulate.c": [
          "File: arch/x86/kvm/emulate.c -> arch/x86/kvm/emulate.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "263: #define EFLG_RESERVED_ZEROS_MASK 0xffc0802a",
          "264: #define EFLG_RESERVED_ONE_MASK 2",
          "266: static ulong reg_read(struct x86_emulate_ctxt *ctxt, unsigned nr)",
          "267: {",
          "268:  if (!(ctxt->regs_valid & (1 << nr))) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "266: enum x86_transfer_type {",
          "267:  X86_TRANSFER_NONE,",
          "268:  X86_TRANSFER_CALL_JMP,",
          "269:  X86_TRANSFER_RET,",
          "270:  X86_TRANSFER_TASK_SWITCH,",
          "271: };",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1473: static int __load_segment_descriptor(struct x86_emulate_ctxt *ctxt,",
          "1474:          u16 selector, int seg, u8 cpl,",
          "1476:          struct desc_struct *desc)",
          "1477: {",
          "1478:  struct desc_struct seg_desc, old_desc;",
          "",
          "[Removed Lines]",
          "1475:          bool in_task_switch,",
          "",
          "[Added Lines]",
          "1482:          enum x86_transfer_type transfer,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1526:   return ret;",
          "1528:  err_code = selector & 0xfffc;",
          "1533:   goto exception;",
          "1535:  if (!seg_desc.p) {",
          "1536:   err_vec = (seg == VCPU_SREG_SS) ? SS_VECTOR : NP_VECTOR;",
          "",
          "[Removed Lines]",
          "1529:  err_vec = in_task_switch ? TS_VECTOR : GP_VECTOR;",
          "1532:  if (seg <= VCPU_SREG_GS && !seg_desc.s)",
          "",
          "[Added Lines]",
          "1536:  err_vec = (transfer == X86_TRANSFER_TASK_SWITCH) ? TS_VECTOR :",
          "1537:           GP_VECTOR;",
          "1540:  if (seg <= VCPU_SREG_GS && !seg_desc.s) {",
          "1541:   if (transfer == X86_TRANSFER_CALL_JMP)",
          "1542:    return X86EMUL_UNHANDLEABLE;",
          "1544:  }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1628:        u16 selector, int seg)",
          "1629: {",
          "1630:  u8 cpl = ctxt->ops->cpl(ctxt);",
          "1632: }",
          "1634: static void write_register_operand(struct operand *op)",
          "",
          "[Removed Lines]",
          "1631:  return __load_segment_descriptor(ctxt, selector, seg, cpl, false, NULL);",
          "",
          "[Added Lines]",
          "1642:  return __load_segment_descriptor(ctxt, selector, seg, cpl,",
          "1643:       X86_TRANSFER_NONE, NULL);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2041:  memcpy(&sel, ctxt->src.valptr + ctxt->op_bytes, 2);",
          "2044:            &new_desc);",
          "2045:  if (rc != X86EMUL_CONTINUE)",
          "2046:   return rc;",
          "",
          "[Removed Lines]",
          "2043:  rc = __load_segment_descriptor(ctxt, sel, VCPU_SREG_CS, cpl, false,",
          "",
          "[Added Lines]",
          "2055:  rc = __load_segment_descriptor(ctxt, sel, VCPU_SREG_CS, cpl,",
          "2056:            X86_TRANSFER_CALL_JMP,",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2130:  if (ctxt->mode >= X86EMUL_MODE_PROT16 && (cs & 3) > cpl)",
          "2131:   return X86EMUL_UNHANDLEABLE;",
          "2133:            &new_desc);",
          "2134:  if (rc != X86EMUL_CONTINUE)",
          "2135:   return rc;",
          "",
          "[Removed Lines]",
          "2132:  rc = __load_segment_descriptor(ctxt, (u16)cs, VCPU_SREG_CS, cpl, false,",
          "",
          "[Added Lines]",
          "2145:  rc = __load_segment_descriptor(ctxt, (u16)cs, VCPU_SREG_CS, cpl,",
          "2146:            X86_TRANSFER_RET,",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "2568:  ret = __load_segment_descriptor(ctxt, tss->ldt, VCPU_SREG_LDTR, cpl,",
          "2570:  if (ret != X86EMUL_CONTINUE)",
          "2571:   return ret;",
          "2572:  ret = __load_segment_descriptor(ctxt, tss->es, VCPU_SREG_ES, cpl,",
          "2574:  if (ret != X86EMUL_CONTINUE)",
          "2575:   return ret;",
          "2576:  ret = __load_segment_descriptor(ctxt, tss->cs, VCPU_SREG_CS, cpl,",
          "2578:  if (ret != X86EMUL_CONTINUE)",
          "2579:   return ret;",
          "2580:  ret = __load_segment_descriptor(ctxt, tss->ss, VCPU_SREG_SS, cpl,",
          "2582:  if (ret != X86EMUL_CONTINUE)",
          "2583:   return ret;",
          "2584:  ret = __load_segment_descriptor(ctxt, tss->ds, VCPU_SREG_DS, cpl,",
          "2586:  if (ret != X86EMUL_CONTINUE)",
          "2587:   return ret;",
          "",
          "[Removed Lines]",
          "2569:      true, NULL);",
          "2573:      true, NULL);",
          "2577:      true, NULL);",
          "2581:      true, NULL);",
          "2585:      true, NULL);",
          "",
          "[Added Lines]",
          "2583:      X86_TRANSFER_TASK_SWITCH, NULL);",
          "2587:      X86_TRANSFER_TASK_SWITCH, NULL);",
          "2591:      X86_TRANSFER_TASK_SWITCH, NULL);",
          "2595:      X86_TRANSFER_TASK_SWITCH, NULL);",
          "2599:      X86_TRANSFER_TASK_SWITCH, NULL);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "2706:  ret = __load_segment_descriptor(ctxt, tss->ldt_selector, VCPU_SREG_LDTR,",
          "2708:  if (ret != X86EMUL_CONTINUE)",
          "2709:   return ret;",
          "2710:  ret = __load_segment_descriptor(ctxt, tss->es, VCPU_SREG_ES, cpl,",
          "2712:  if (ret != X86EMUL_CONTINUE)",
          "2713:   return ret;",
          "2714:  ret = __load_segment_descriptor(ctxt, tss->cs, VCPU_SREG_CS, cpl,",
          "2716:  if (ret != X86EMUL_CONTINUE)",
          "2717:   return ret;",
          "2718:  ret = __load_segment_descriptor(ctxt, tss->ss, VCPU_SREG_SS, cpl,",
          "2720:  if (ret != X86EMUL_CONTINUE)",
          "2721:   return ret;",
          "2722:  ret = __load_segment_descriptor(ctxt, tss->ds, VCPU_SREG_DS, cpl,",
          "2724:  if (ret != X86EMUL_CONTINUE)",
          "2725:   return ret;",
          "2726:  ret = __load_segment_descriptor(ctxt, tss->fs, VCPU_SREG_FS, cpl,",
          "2728:  if (ret != X86EMUL_CONTINUE)",
          "2729:   return ret;",
          "2730:  ret = __load_segment_descriptor(ctxt, tss->gs, VCPU_SREG_GS, cpl,",
          "2732:  if (ret != X86EMUL_CONTINUE)",
          "2733:   return ret;",
          "",
          "[Removed Lines]",
          "2707:      cpl, true, NULL);",
          "2711:      true, NULL);",
          "2715:      true, NULL);",
          "2719:      true, NULL);",
          "2723:      true, NULL);",
          "2727:      true, NULL);",
          "2731:      true, NULL);",
          "",
          "[Added Lines]",
          "2721:      cpl, X86_TRANSFER_TASK_SWITCH, NULL);",
          "2725:      X86_TRANSFER_TASK_SWITCH, NULL);",
          "2729:      X86_TRANSFER_TASK_SWITCH, NULL);",
          "2733:      X86_TRANSFER_TASK_SWITCH, NULL);",
          "2737:      X86_TRANSFER_TASK_SWITCH, NULL);",
          "2741:      X86_TRANSFER_TASK_SWITCH, NULL);",
          "2745:      X86_TRANSFER_TASK_SWITCH, NULL);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "3010:  ops->get_segment(ctxt, &old_cs, &old_desc, NULL, VCPU_SREG_CS);",
          "3012:  memcpy(&sel, ctxt->src.valptr + ctxt->op_bytes, 2);",
          "3015:  if (rc != X86EMUL_CONTINUE)",
          "3016:   return X86EMUL_CONTINUE;",
          "",
          "[Removed Lines]",
          "3013:  rc = __load_segment_descriptor(ctxt, sel, VCPU_SREG_CS, cpl, false,",
          "3014:            &new_desc);",
          "",
          "[Added Lines]",
          "3027:  rc = __load_segment_descriptor(ctxt, sel, VCPU_SREG_CS, cpl,",
          "3028:            X86_TRANSFER_CALL_JMP, &new_desc);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "82268083fa78452c1c8be30a82984e470d9678c7",
      "candidate_info": {
        "commit_hash": "82268083fa78452c1c8be30a82984e470d9678c7",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/82268083fa78452c1c8be30a82984e470d9678c7",
        "files": [
          "arch/x86/kvm/emulate.c"
        ],
        "message": "KVM: x86: Emulation of call may use incorrect stack size\n\nOn long-mode, when far call that changes cs.l takes place, the stack size is\ndetermined by the new mode.  For instance, if we go from 32-bit mode to 64-bit\nmode, the stack-size if 64.  KVM uses the old stack size.\n\nFix it.\n\nSigned-off-by: Nadav Amit <namit@cs.technion.ac.il>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>",
        "before_after_code_files": [
          "arch/x86/kvm/emulate.c||arch/x86/kvm/emulate.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "arch/x86/kvm/emulate.c||arch/x86/kvm/emulate.c"
          ],
          "candidate": [
            "arch/x86/kvm/emulate.c||arch/x86/kvm/emulate.c"
          ]
        }
      },
      "candidate_diff": {
        "arch/x86/kvm/emulate.c||arch/x86/kvm/emulate.c": [
          "File: arch/x86/kvm/emulate.c -> arch/x86/kvm/emulate.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "741:      const struct desc_struct *cs_desc)",
          "742: {",
          "743:  enum x86emul_mode mode = ctxt->mode;",
          "745: #ifdef CONFIG_X86_64",
          "752:  }",
          "753: #endif",
          "754:  if (mode == X86EMUL_MODE_PROT16 || mode == X86EMUL_MODE_PROT32)",
          "755:   mode = cs_desc->d ? X86EMUL_MODE_PROT32 : X86EMUL_MODE_PROT16;",
          "757: }",
          "759: static inline int jmp_rel(struct x86_emulate_ctxt *ctxt, int rel)",
          "",
          "[Removed Lines]",
          "746:  if (ctxt->mode >= X86EMUL_MODE_PROT32 && cs_desc->l) {",
          "747:   u64 efer = 0;",
          "749:   ctxt->ops->get_msr(ctxt, MSR_EFER, &efer);",
          "750:   if (efer & EFER_LMA)",
          "751:    mode = X86EMUL_MODE_PROT64;",
          "756:  return assign_eip(ctxt, dst, mode);",
          "",
          "[Added Lines]",
          "744:  int rc;",
          "747:  if (ctxt->mode >= X86EMUL_MODE_PROT16) {",
          "748:   if (cs_desc->l) {",
          "749:    u64 efer = 0;",
          "751:    ctxt->ops->get_msr(ctxt, MSR_EFER, &efer);",
          "752:    if (efer & EFER_LMA)",
          "753:     mode = X86EMUL_MODE_PROT64;",
          "754:   } else",
          "760:  rc = assign_eip(ctxt, dst, mode);",
          "761:  if (rc == X86EMUL_CONTINUE)",
          "762:   ctxt->mode = mode;",
          "763:  return rc;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3062:  struct desc_struct old_desc, new_desc;",
          "3063:  const struct x86_emulate_ops *ops = ctxt->ops;",
          "3064:  int cpl = ctxt->ops->cpl(ctxt);",
          "3066:  old_eip = ctxt->_eip;",
          "3067:  ops->get_segment(ctxt, &old_cs, &old_desc, NULL, VCPU_SREG_CS);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3072:  enum x86emul_mode prev_mode = ctxt->mode;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3085:  rc = em_push(ctxt);",
          "3089:   goto fail;",
          "3090:  return rc;",
          "3091: fail:",
          "3092:  ops->set_segment(ctxt, old_cs, &old_desc, 0, VCPU_SREG_CS);",
          "3093:  return rc;",
          "3095: }",
          "",
          "[Removed Lines]",
          "3088:  if (rc != X86EMUL_CONTINUE)",
          "",
          "[Added Lines]",
          "3096:  if (rc != X86EMUL_CONTINUE) {",
          "3097:   pr_warn_once(\"faulting far call emulation tainted memory\\n\");",
          "3099:  }",
          "3103:  ctxt->mode = prev_mode;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "7e46dddd6f6cd5dbf3c7bd04a7e75d19475ac9f2",
      "candidate_info": {
        "commit_hash": "7e46dddd6f6cd5dbf3c7bd04a7e75d19475ac9f2",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/7e46dddd6f6cd5dbf3c7bd04a7e75d19475ac9f2",
        "files": [
          "arch/x86/kvm/emulate.c"
        ],
        "message": "KVM: x86: Fix far-jump to non-canonical check\n\nCommit d1442d85cc30 (\"KVM: x86: Handle errors when RIP is set during far\njumps\") introduced a bug that caused the fix to be incomplete.  Due to\nincorrect evaluation, far jump to segment with L bit cleared (i.e., 32-bit\nsegment) and RIP with any of the high bits set (i.e, RIP[63:32] != 0) set may\nnot trigger #GP.  As we know, this imposes a security problem.\n\nIn addition, the condition for two warnings was incorrect.\n\nFixes: d1442d85cc30ea75f7d399474ca738e0bc96f715\nReported-by: Dan Carpenter <dan.carpenter@oracle.com>\nSigned-off-by: Nadav Amit <namit@cs.technion.ac.il>\n[Add #ifdef CONFIG_X86_64 to avoid complaints of undefined behavior. - Paolo]\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>",
        "before_after_code_files": [
          "arch/x86/kvm/emulate.c||arch/x86/kvm/emulate.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "arch/x86/kvm/emulate.c||arch/x86/kvm/emulate.c"
          ],
          "candidate": [
            "arch/x86/kvm/emulate.c||arch/x86/kvm/emulate.c"
          ]
        }
      },
      "candidate_diff": {
        "arch/x86/kvm/emulate.c||arch/x86/kvm/emulate.c": [
          "File: arch/x86/kvm/emulate.c -> arch/x86/kvm/emulate.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "574:  case 4:",
          "575:   ctxt->_eip = (u32)dst;",
          "576:   break;",
          "577:  case 8:",
          "578:   if ((cs_l && is_noncanonical_address(dst)) ||",
          "580:    return emulate_gp(ctxt, 0);",
          "581:   ctxt->_eip = dst;",
          "582:   break;",
          "583:  default:",
          "584:   WARN(1, \"unsupported eip assignment size\\n\");",
          "585:  }",
          "",
          "[Removed Lines]",
          "579:       (!cs_l && (dst & ~(u32)-1)))",
          "",
          "[Added Lines]",
          "577: #ifdef CONFIG_X86_64",
          "580:       (!cs_l && (dst >> 32) != 0))",
          "584: #endif",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2036:  rc = assign_eip_far(ctxt, ctxt->src.val, new_desc.l);",
          "2037:  if (rc != X86EMUL_CONTINUE) {",
          "2040:   ops->set_segment(ctxt, old_sel, &old_desc, 0, VCPU_SREG_CS);",
          "2041:   return rc;",
          "",
          "[Removed Lines]",
          "2038:   WARN_ON(!ctxt->mode != X86EMUL_MODE_PROT64);",
          "",
          "[Added Lines]",
          "2040:   WARN_ON(ctxt->mode != X86EMUL_MODE_PROT64);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2132:   return rc;",
          "2133:  rc = assign_eip_far(ctxt, eip, new_desc.l);",
          "2134:  if (rc != X86EMUL_CONTINUE) {",
          "2136:   ops->set_segment(ctxt, old_cs, &old_desc, 0, VCPU_SREG_CS);",
          "2137:  }",
          "2138:  return rc;",
          "",
          "[Removed Lines]",
          "2135:   WARN_ON(!ctxt->mode != X86EMUL_MODE_PROT64);",
          "",
          "[Added Lines]",
          "2137:   WARN_ON(ctxt->mode != X86EMUL_MODE_PROT64);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "d50eaa18039b8b848c2285478d0775335ad5e930",
      "candidate_info": {
        "commit_hash": "d50eaa18039b8b848c2285478d0775335ad5e930",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/d50eaa18039b8b848c2285478d0775335ad5e930",
        "files": [
          "arch/x86/kvm/emulate.c"
        ],
        "message": "KVM: x86: Perform limit checks when assigning EIP\n\nIf branch (e.g., jmp, ret) causes limit violations, since the target IP >\nlimit, the #GP exception occurs before the branch.  In other words, the RIP\npushed on the stack should be that of the branch and not that of the target.\n\nTo do so, we can call __linearize, with new EIP, which also saves us the code\nwhich performs the canonical address checks. On the case of assigning an EIP >=\n2^32 (when switching cs.l), we also safe, as __linearize will check the new EIP\ndoes not exceed the limit and would trigger #GP(0) otherwise.\n\nSigned-off-by: Nadav Amit <namit@cs.technion.ac.il>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>",
        "before_after_code_files": [
          "arch/x86/kvm/emulate.c||arch/x86/kvm/emulate.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "arch/x86/kvm/emulate.c||arch/x86/kvm/emulate.c"
          ],
          "candidate": [
            "arch/x86/kvm/emulate.c||arch/x86/kvm/emulate.c"
          ]
        }
      },
      "candidate_diff": {
        "arch/x86/kvm/emulate.c||arch/x86/kvm/emulate.c": [
          "File: arch/x86/kvm/emulate.c -> arch/x86/kvm/emulate.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "575:  return emulate_exception(ctxt, NM_VECTOR, 0, false);",
          "576: }",
          "612: static u16 get_segment_selector(struct x86_emulate_ctxt *ctxt, unsigned seg)",
          "613: {",
          "614:  u16 selector;",
          "",
          "[Removed Lines]",
          "578: static inline int assign_eip_far(struct x86_emulate_ctxt *ctxt, ulong dst,",
          "579:           int cs_l)",
          "580: {",
          "581:  switch (ctxt->op_bytes) {",
          "582:  case 2:",
          "583:   ctxt->_eip = (u16)dst;",
          "584:   break;",
          "585:  case 4:",
          "586:   ctxt->_eip = (u32)dst;",
          "587:   break;",
          "588: #ifdef CONFIG_X86_64",
          "589:  case 8:",
          "590:   if ((cs_l && is_noncanonical_address(dst)) ||",
          "591:       (!cs_l && (dst >> 32) != 0))",
          "592:    return emulate_gp(ctxt, 0);",
          "593:   ctxt->_eip = dst;",
          "594:   break;",
          "595: #endif",
          "596:  default:",
          "597:   WARN(1, \"unsupported eip assignment size\\n\");",
          "598:  }",
          "599:  return X86EMUL_CONTINUE;",
          "600: }",
          "602: static inline int assign_eip_near(struct x86_emulate_ctxt *ctxt, ulong dst)",
          "603: {",
          "604:  return assign_eip_far(ctxt, dst, ctxt->mode == X86EMUL_MODE_PROT64);",
          "605: }",
          "607: static inline int jmp_rel(struct x86_emulate_ctxt *ctxt, int rel)",
          "608: {",
          "609:  return assign_eip_near(ctxt, ctxt->_eip + rel);",
          "610: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "656:            struct segmented_address addr,",
          "657:            unsigned *max_size, unsigned size,",
          "658:            bool write, bool fetch,",
          "660: {",
          "661:  struct desc_struct desc;",
          "662:  bool usable;",
          "",
          "[Removed Lines]",
          "659:            ulong *linear)",
          "",
          "[Added Lines]",
          "625:            enum x86emul_mode mode, ulong *linear)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "667:  la = seg_base(ctxt, addr.seg) + addr.ea;",
          "670:  case X86EMUL_MODE_PROT64:",
          "671:   if (is_noncanonical_address(la))",
          "672:    return emulate_gp(ctxt, 0);",
          "",
          "[Removed Lines]",
          "669:  switch (ctxt->mode) {",
          "",
          "[Added Lines]",
          "635:  switch (mode) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "725:        ulong *linear)",
          "726: {",
          "727:  unsigned max_size;",
          "729: }",
          "732: static int segmented_read_std(struct x86_emulate_ctxt *ctxt,",
          "733:          struct segmented_address addr,",
          "",
          "[Removed Lines]",
          "728:  return __linearize(ctxt, addr, &max_size, size, write, false, linear);",
          "",
          "[Added Lines]",
          "694:  return __linearize(ctxt, addr, &max_size, size, write, false,",
          "695:       ctxt->mode, linear);",
          "698: static inline int assign_eip(struct x86_emulate_ctxt *ctxt, ulong dst,",
          "699:         enum x86emul_mode mode)",
          "700: {",
          "701:  ulong linear;",
          "702:  int rc;",
          "703:  unsigned max_size;",
          "704:  struct segmented_address addr = { .seg = VCPU_SREG_CS,",
          "705:         .ea = dst };",
          "707:  if (ctxt->op_bytes != sizeof(unsigned long))",
          "708:   addr.ea = dst & ((1UL << (ctxt->op_bytes << 3)) - 1);",
          "709:  rc = __linearize(ctxt, addr, &max_size, 1, false, true, mode, &linear);",
          "710:  if (rc == X86EMUL_CONTINUE)",
          "711:   ctxt->_eip = addr.ea;",
          "712:  return rc;",
          "713: }",
          "715: static inline int assign_eip_near(struct x86_emulate_ctxt *ctxt, ulong dst)",
          "716: {",
          "717:  return assign_eip(ctxt, dst, ctxt->mode);",
          "718: }",
          "720: static int assign_eip_far(struct x86_emulate_ctxt *ctxt, ulong dst,",
          "721:      const struct desc_struct *cs_desc)",
          "722: {",
          "723:  enum x86emul_mode mode = ctxt->mode;",
          "725: #ifdef CONFIG_X86_64",
          "726:  if (ctxt->mode >= X86EMUL_MODE_PROT32 && cs_desc->l) {",
          "727:   u64 efer = 0;",
          "729:   ctxt->ops->get_msr(ctxt, MSR_EFER, &efer);",
          "730:   if (efer & EFER_LMA)",
          "731:    mode = X86EMUL_MODE_PROT64;",
          "732:  }",
          "733: #endif",
          "734:  if (mode == X86EMUL_MODE_PROT16 || mode == X86EMUL_MODE_PROT32)",
          "735:   mode = cs_desc->d ? X86EMUL_MODE_PROT32 : X86EMUL_MODE_PROT16;",
          "736:  return assign_eip(ctxt, dst, mode);",
          "737: }",
          "739: static inline int jmp_rel(struct x86_emulate_ctxt *ctxt, int rel)",
          "740: {",
          "741:  return assign_eip_near(ctxt, ctxt->_eip + rel);",
          "742: }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "770:  if (unlikely(rc != X86EMUL_CONTINUE))",
          "771:   return rc;",
          "",
          "[Removed Lines]",
          "769:  rc = __linearize(ctxt, addr, &max_size, 0, false, true, &linear);",
          "",
          "[Added Lines]",
          "781:  rc = __linearize(ctxt, addr, &max_size, 0, false, true, ctxt->mode,",
          "782:     &linear);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2032:  if (rc != X86EMUL_CONTINUE)",
          "2033:   return rc;",
          "2036:  if (rc != X86EMUL_CONTINUE) {",
          "2037:   WARN_ON(ctxt->mode != X86EMUL_MODE_PROT64);",
          "",
          "[Removed Lines]",
          "2035:  rc = assign_eip_far(ctxt, ctxt->src.val, new_desc.l);",
          "",
          "[Added Lines]",
          "2048:  rc = assign_eip_far(ctxt, ctxt->src.val, &new_desc);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "2120:            &new_desc);",
          "2121:  if (rc != X86EMUL_CONTINUE)",
          "2122:   return rc;",
          "2124:  if (rc != X86EMUL_CONTINUE) {",
          "2125:   WARN_ON(ctxt->mode != X86EMUL_MODE_PROT64);",
          "2126:   ops->set_segment(ctxt, old_cs, &old_desc, 0, VCPU_SREG_CS);",
          "",
          "[Removed Lines]",
          "2123:  rc = assign_eip_far(ctxt, eip, new_desc.l);",
          "",
          "[Added Lines]",
          "2136:  rc = assign_eip_far(ctxt, eip, &new_desc);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "3010:  if (rc != X86EMUL_CONTINUE)",
          "3011:   return X86EMUL_CONTINUE;",
          "3014:  if (rc != X86EMUL_CONTINUE)",
          "3015:   goto fail;",
          "",
          "[Removed Lines]",
          "3013:  rc = assign_eip_far(ctxt, ctxt->src.val, new_desc.l);",
          "",
          "[Added Lines]",
          "3026:  rc = assign_eip_far(ctxt, ctxt->src.val, &new_desc);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
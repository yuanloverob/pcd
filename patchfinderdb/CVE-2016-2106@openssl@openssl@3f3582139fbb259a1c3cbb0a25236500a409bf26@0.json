{
  "cve_id": "CVE-2016-2106",
  "cve_desc": "Integer overflow in the EVP_EncryptUpdate function in crypto/evp/evp_enc.c in OpenSSL before 1.0.1t and 1.0.2 before 1.0.2h allows remote attackers to cause a denial of service (heap memory corruption) via a large amount of data.",
  "repo": "openssl/openssl",
  "patch_hash": "3f3582139fbb259a1c3cbb0a25236500a409bf26",
  "patch_info": {
    "commit_hash": "3f3582139fbb259a1c3cbb0a25236500a409bf26",
    "repo": "openssl/openssl",
    "commit_url": "https://github.com/openssl/openssl/commit/3f3582139fbb259a1c3cbb0a25236500a409bf26",
    "files": [
      "crypto/evp/evp_enc.c"
    ],
    "message": "Fix encrypt overflow\n\nAn overflow can occur in the EVP_EncryptUpdate function. If an attacker is\nable to supply very large amounts of input data after a previous call to\nEVP_EncryptUpdate with a partial block then a length check can overflow\nresulting in a heap corruption.\n\nFollowing an analysis of all OpenSSL internal usage of the\nEVP_EncryptUpdate function all usage is one of two forms.\n\nThe first form is like this:\nEVP_EncryptInit()\nEVP_EncryptUpdate()\n\ni.e. where the EVP_EncryptUpdate() call is known to be the first called\nfunction after an EVP_EncryptInit(), and therefore that specific call\nmust be safe.\n\nThe second form is where the length passed to EVP_EncryptUpdate() can be\nseen from the code to be some small value and therefore there is no\npossibility of an overflow.\n\nSince all instances are one of these two forms, I believe that there can\nbe no overflows in internal code due to this problem.\n\nIt should be noted that EVP_DecryptUpdate() can call EVP_EncryptUpdate()\nin certain code paths. Also EVP_CipherUpdate() is a synonym for\nEVP_EncryptUpdate(). Therefore I have checked all instances of these\ncalls too, and came to the same conclusion, i.e. there are no instances\nin internal usage where an overflow could occur.\n\nThis could still represent a security issue for end user code that calls\nthis function directly.\n\nCVE-2016-2106\n\nIssue reported by Guido Vranken.\n\nReviewed-by: Tim Hudson <tjh@openssl.org>",
    "before_after_code_files": [
      "crypto/evp/evp_enc.c||crypto/evp/evp_enc.c"
    ]
  },
  "patch_diff": {
    "crypto/evp/evp_enc.c||crypto/evp/evp_enc.c": [
      "File: crypto/evp/evp_enc.c -> crypto/evp/evp_enc.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "332:     bl = ctx->cipher->block_size;",
      "333:     OPENSSL_assert(bl <= (int)sizeof(ctx->buf));",
      "334:     if (i != 0) {",
      "336:             memcpy(&(ctx->buf[i]), in, inl);",
      "337:             ctx->buf_len += inl;",
      "",
      "[Removed Lines]",
      "335:         if (i + inl < bl) {",
      "",
      "[Added Lines]",
      "335:         if (bl - i > inl) {",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "3ab937bc440371fbbe74318ce494ba95021f850a",
      "candidate_info": {
        "commit_hash": "3ab937bc440371fbbe74318ce494ba95021f850a",
        "repo": "openssl/openssl",
        "commit_url": "https://github.com/openssl/openssl/commit/3ab937bc440371fbbe74318ce494ba95021f850a",
        "files": [
          "crypto/evp/evp_enc.c"
        ],
        "message": "Fix encrypt overflow\n\nAn overflow can occur in the EVP_EncryptUpdate function. If an attacker is\nable to supply very large amounts of input data after a previous call to\nEVP_EncryptUpdate with a partial block then a length check can overflow\nresulting in a heap corruption.\n\nFollowing an analysis of all OpenSSL internal usage of the\nEVP_EncryptUpdate function all usage is one of two forms.\n\nThe first form is like this:\nEVP_EncryptInit()\nEVP_EncryptUpdate()\n\ni.e. where the EVP_EncryptUpdate() call is known to be the first called\nfunction after an EVP_EncryptInit(), and therefore that specific call\nmust be safe.\n\nThe second form is where the length passed to EVP_EncryptUpdate() can be\nseen from the code to be some small value and therefore there is no\npossibility of an overflow.\n\nSince all instances are one of these two forms, I believe that there can\nbe no overflows in internal code due to this problem.\n\nIt should be noted that EVP_DecryptUpdate() can call EVP_EncryptUpdate()\nin certain code paths. Also EVP_CipherUpdate() is a synonym for\nEVP_EncryptUpdate(). Therefore I have checked all instances of these\ncalls too, and came to the same conclusion, i.e. there are no instances\nin internal usage where an overflow could occur.\n\nThis could still represent a security issue for end user code that calls\nthis function directly.\n\nCVE-2016-2106\n\nIssue reported by Guido Vranken.\n\nReviewed-by: Tim Hudson <tjh@openssl.org>\n(cherry picked from commit 3f3582139fbb259a1c3cbb0a25236500a409bf26)",
        "before_after_code_files": [
          "crypto/evp/evp_enc.c||crypto/evp/evp_enc.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "crypto/evp/evp_enc.c||crypto/evp/evp_enc.c"
          ],
          "candidate": [
            "crypto/evp/evp_enc.c||crypto/evp/evp_enc.c"
          ]
        }
      },
      "candidate_diff": {
        "crypto/evp/evp_enc.c||crypto/evp/evp_enc.c": [
          "File: crypto/evp/evp_enc.c -> crypto/evp/evp_enc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "347:     bl = ctx->cipher->block_size;",
          "348:     OPENSSL_assert(bl <= (int)sizeof(ctx->buf));",
          "349:     if (i != 0) {",
          "351:             memcpy(&(ctx->buf[i]), in, inl);",
          "352:             ctx->buf_len += inl;",
          "",
          "[Removed Lines]",
          "350:         if (i + inl < bl) {",
          "",
          "[Added Lines]",
          "350:         if (bl - i > inl) {",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "56ea22458f3f5f1d0148b0a97957de4d56f3d328",
      "candidate_info": {
        "commit_hash": "56ea22458f3f5f1d0148b0a97957de4d56f3d328",
        "repo": "openssl/openssl",
        "commit_url": "https://github.com/openssl/openssl/commit/56ea22458f3f5f1d0148b0a97957de4d56f3d328",
        "files": [
          "crypto/evp/evp_enc.c"
        ],
        "message": "Fix encrypt overflow\n\nAn overflow can occur in the EVP_EncryptUpdate function. If an attacker is\nable to supply very large amounts of input data after a previous call to\nEVP_EncryptUpdate with a partial block then a length check can overflow\nresulting in a heap corruption.\n\nFollowing an analysis of all OpenSSL internal usage of the\nEVP_EncryptUpdate function all usage is one of two forms.\n\nThe first form is like this:\nEVP_EncryptInit()\nEVP_EncryptUpdate()\n\ni.e. where the EVP_EncryptUpdate() call is known to be the first called\nfunction after an EVP_EncryptInit(), and therefore that specific call\nmust be safe.\n\nThe second form is where the length passed to EVP_EncryptUpdate() can be\nseen from the code to be some small value and therefore there is no\npossibility of an overflow.\n\nSince all instances are one of these two forms, I believe that there can\nbe no overflows in internal code due to this problem.\n\nIt should be noted that EVP_DecryptUpdate() can call EVP_EncryptUpdate()\nin certain code paths. Also EVP_CipherUpdate() is a synonym for\nEVP_EncryptUpdate(). Therefore I have checked all instances of these\ncalls too, and came to the same conclusion, i.e. there are no instances\nin internal usage where an overflow could occur.\n\nThis could still represent a security issue for end user code that calls\nthis function directly.\n\nCVE-2016-2106\n\nIssue reported by Guido Vranken.\n\nReviewed-by: Tim Hudson <tjh@openssl.org>\n(cherry picked from commit 3f3582139fbb259a1c3cbb0a25236500a409bf26)",
        "before_after_code_files": [
          "crypto/evp/evp_enc.c||crypto/evp/evp_enc.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "crypto/evp/evp_enc.c||crypto/evp/evp_enc.c"
          ],
          "candidate": [
            "crypto/evp/evp_enc.c||crypto/evp/evp_enc.c"
          ]
        }
      },
      "candidate_diff": {
        "crypto/evp/evp_enc.c||crypto/evp/evp_enc.c": [
          "File: crypto/evp/evp_enc.c -> crypto/evp/evp_enc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "334:     bl = ctx->cipher->block_size;",
          "335:     OPENSSL_assert(bl <= (int)sizeof(ctx->buf));",
          "336:     if (i != 0) {",
          "338:             memcpy(&(ctx->buf[i]), in, inl);",
          "339:             ctx->buf_len += inl;",
          "",
          "[Removed Lines]",
          "337:         if (i + inl < bl) {",
          "",
          "[Added Lines]",
          "337:         if (bl - i > inl) {",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2021-38201",
  "cve_desc": "net/sunrpc/xdr.c in the Linux kernel before 5.13.4 allows remote attackers to cause a denial of service (xdr_set_page_base slab-out-of-bounds access) by performing many NFS 4.2 READ_PLUS operations.",
  "repo": "torvalds/linux",
  "patch_hash": "6d1c0f3d28f98ea2736128ed3e46821496dc3a8c",
  "patch_info": {
    "commit_hash": "6d1c0f3d28f98ea2736128ed3e46821496dc3a8c",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/6d1c0f3d28f98ea2736128ed3e46821496dc3a8c",
    "files": [
      "net/sunrpc/xdr.c"
    ],
    "message": "sunrpc: Avoid a KASAN slab-out-of-bounds bug in xdr_set_page_base()\n\nThis seems to happen fairly easily during READ_PLUS testing on NFS v4.2.\nI found that we could end up accessing xdr->buf->pages[pgnr] with a pgnr\ngreater than the number of pages in the array. So let's just return\nearly if we're setting base to a point at the end of the page data and\nlet xdr_set_tail_base() handle setting up the buffer pointers instead.\n\nSigned-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>\nFixes: 8d86e373b0ef (\"SUNRPC: Clean up helpers xdr_set_iov() and xdr_set_page_base()\")\nSigned-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>",
    "before_after_code_files": [
      "net/sunrpc/xdr.c||net/sunrpc/xdr.c"
    ]
  },
  "patch_diff": {
    "net/sunrpc/xdr.c||net/sunrpc/xdr.c": [
      "File: net/sunrpc/xdr.c -> net/sunrpc/xdr.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1230:  void *kaddr;",
      "1232:  maxlen = xdr->buf->page_len;",
      "1237:   maxlen -= base;",
      "1238:  if (len > maxlen)",
      "1239:   len = maxlen;",
      "",
      "[Removed Lines]",
      "1233:  if (base >= maxlen) {",
      "1234:   base = maxlen;",
      "1235:   maxlen = 0;",
      "1236:  } else",
      "",
      "[Added Lines]",
      "1233:  if (base >= maxlen)",
      "1234:   return 0;",
      "1235:  else",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "8d86e373b0ef52d091ced9583ffbb33ad2771576",
      "candidate_info": {
        "commit_hash": "8d86e373b0ef52d091ced9583ffbb33ad2771576",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/8d86e373b0ef52d091ced9583ffbb33ad2771576",
        "files": [
          "net/sunrpc/xdr.c"
        ],
        "message": "SUNRPC: Clean up helpers xdr_set_iov() and xdr_set_page_base()\n\nAllow xdr_set_iov() to set a base so that we can use it to set the\ncursor to a specific position in the kvec buffer.\n\nIf the new base overflows the kvec/pages buffer in either xdr_set_iov()\nor xdr_set_page_base(), then truncate it so that we point to the end of\nthe buffer.\n\nFinally, change both function to return the number of bytes remaining to\nread in their buffers.\n\nSigned-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>",
        "before_after_code_files": [
          "net/sunrpc/xdr.c||net/sunrpc/xdr.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "net/sunrpc/xdr.c||net/sunrpc/xdr.c"
          ],
          "candidate": [
            "net/sunrpc/xdr.c||net/sunrpc/xdr.c"
          ]
        }
      },
      "candidate_diff": {
        "net/sunrpc/xdr.c||net/sunrpc/xdr.c": [
          "File: net/sunrpc/xdr.c -> net/sunrpc/xdr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "970: }",
          "971: EXPORT_SYMBOL_GPL(xdr_write_pages);",
          "975: {",
          "976:  if (len > iov->iov_len)",
          "977:   len = iov->iov_len;",
          "979:  xdr->end = (__be32*)(iov->iov_base + len);",
          "980:  xdr->iov = iov;",
          "981:  xdr->page_ptr = NULL;",
          "982: }",
          "986: {",
          "987:  unsigned int pgnr;",
          "988:  unsigned int maxlen;",
          "",
          "[Removed Lines]",
          "973: static void xdr_set_iov(struct xdr_stream *xdr, struct kvec *iov,",
          "974:   unsigned int len)",
          "978:  xdr->p = (__be32*)iov->iov_base;",
          "984: static int xdr_set_page_base(struct xdr_stream *xdr,",
          "985:   unsigned int base, unsigned int len)",
          "",
          "[Added Lines]",
          "973: static unsigned int xdr_set_iov(struct xdr_stream *xdr, struct kvec *iov,",
          "974:     unsigned int base, unsigned int len)",
          "978:  if (unlikely(base > len))",
          "979:   base = len;",
          "980:  xdr->p = (__be32*)(iov->iov_base + base);",
          "984:  return len - base;",
          "987: static unsigned int xdr_set_page_base(struct xdr_stream *xdr,",
          "988:           unsigned int base, unsigned int len)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "991:  void *kaddr;",
          "993:  maxlen = xdr->buf->page_len;",
          "997:  if (len > maxlen)",
          "998:   len = maxlen;",
          "",
          "[Removed Lines]",
          "994:  if (base >= maxlen)",
          "995:   return -EINVAL;",
          "996:  maxlen -= base;",
          "",
          "[Added Lines]",
          "997:  if (base >= maxlen) {",
          "998:   base = maxlen;",
          "999:   maxlen = 0;",
          "1000:  } else",
          "1001:   maxlen -= base;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1011:   pgend = PAGE_SIZE;",
          "1012:  xdr->end = (__be32*)(kaddr + pgend);",
          "1013:  xdr->iov = NULL;",
          "1015: }",
          "1017: static void xdr_set_page(struct xdr_stream *xdr, unsigned int base,",
          "1018:     unsigned int len)",
          "1019: {",
          "1022: }",
          "1024: static void xdr_set_next_page(struct xdr_stream *xdr)",
          "",
          "[Removed Lines]",
          "1014:  return 0;",
          "1020:  if (xdr_set_page_base(xdr, base, len) < 0)",
          "1021:   xdr_set_iov(xdr, xdr->buf->tail, xdr->nwords << 2);",
          "",
          "[Added Lines]",
          "1019:  return len;",
          "1025:  if (xdr_set_page_base(xdr, base, len) == 0)",
          "1026:   xdr_set_iov(xdr, xdr->buf->tail, 0, xdr_stream_remaining(xdr));",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1055:  xdr->scratch.iov_base = NULL;",
          "1056:  xdr->scratch.iov_len = 0;",
          "1057:  xdr->nwords = XDR_QUADLEN(buf->len);",
          "1064:  if (p != NULL && p > xdr->p && xdr->end >= p) {",
          "1065:   xdr->nwords -= p - xdr->p;",
          "1066:   xdr->p = p;",
          "",
          "[Removed Lines]",
          "1058:  if (buf->head[0].iov_len != 0)",
          "1059:   xdr_set_iov(xdr, buf->head, buf->len);",
          "1060:  else if (buf->page_len != 0)",
          "1061:   xdr_set_page_base(xdr, 0, buf->len);",
          "1062:  else",
          "1063:   xdr_set_iov(xdr, buf->tail, buf->len);",
          "",
          "[Added Lines]",
          "1063:  if (xdr_set_iov(xdr, buf->head, 0, buf->len) == 0 &&",
          "1064:      xdr_set_page_base(xdr, 0, buf->len) == 0)",
          "1065:   xdr_set_iov(xdr, buf->tail, 0, buf->len);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
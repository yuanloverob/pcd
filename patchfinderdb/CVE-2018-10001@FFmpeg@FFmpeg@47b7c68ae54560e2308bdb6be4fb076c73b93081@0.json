{
  "cve_id": "CVE-2018-10001",
  "cve_desc": "The decode_init function in libavcodec/utvideodec.c in FFmpeg through 3.4.2 allows remote attackers to cause a denial of service (out of array read) via an AVI file.",
  "repo": "FFmpeg/FFmpeg",
  "patch_hash": "47b7c68ae54560e2308bdb6be4fb076c73b93081",
  "patch_info": {
    "commit_hash": "47b7c68ae54560e2308bdb6be4fb076c73b93081",
    "repo": "FFmpeg/FFmpeg",
    "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/47b7c68ae54560e2308bdb6be4fb076c73b93081",
    "files": [
      "libavcodec/utvideodec.c"
    ],
    "message": "avcodec/utvideodec: Set pro flag based on fourcc\n\nThis avoids mixing 8bit variants with pro and 10bit with non pro mode.\nFixes: out of array read\nFixes: poc_03_30.avi\n\nFound-by: GwanYeong Kim <gy741.kim@gmail.com>\nReviewed-by: Paul B Mahol <onemda@gmail.com>\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>",
    "before_after_code_files": [
      "libavcodec/utvideodec.c||libavcodec/utvideodec.c"
    ]
  },
  "patch_diff": {
    "libavcodec/utvideodec.c||libavcodec/utvideodec.c": [
      "File: libavcodec/utvideodec.c -> libavcodec/utvideodec.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "949:         break;",
      "950:     case MKTAG('U', 'Q', 'Y', '2'):",
      "951:         c->planes      = 3;",
      "952:         avctx->pix_fmt = AV_PIX_FMT_YUV422P10;",
      "953:         break;",
      "954:     case MKTAG('U', 'Q', 'R', 'G'):",
      "955:         c->planes      = 3;",
      "956:         avctx->pix_fmt = AV_PIX_FMT_GBRP10;",
      "957:         break;",
      "958:     case MKTAG('U', 'Q', 'R', 'A'):",
      "959:         c->planes      = 4;",
      "960:         avctx->pix_fmt = AV_PIX_FMT_GBRAP10;",
      "961:         break;",
      "962:     case MKTAG('U', 'L', 'H', '0'):",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "952:         c->pro         = 1;",
      "957:         c->pro         = 1;",
      "962:         c->pro         = 1;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1031:         if (c->compression != 2)",
      "1032:             avpriv_request_sample(avctx, \"Unknown compression type\");",
      "1033:         c->slices      = avctx->extradata[9] + 1;",
      "1035:         av_log(avctx, AV_LOG_DEBUG, \"Encoder version %d.%d.%d.%d\\n\",",
      "1036:                avctx->extradata[3], avctx->extradata[2],",
      "1037:                avctx->extradata[1], avctx->extradata[0]);",
      "",
      "[Removed Lines]",
      "1034:     } else if (avctx->extradata_size >= 16) {",
      "",
      "[Added Lines]",
      "1037:     } else if (!c->pro && avctx->extradata_size >= 16) {",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1046:         c->slices      = (c->flags >> 24) + 1;",
      "1047:         c->compression = c->flags & 1;",
      "1048:         c->interlaced  = c->flags & 0x800;",
      "1050:         av_log(avctx, AV_LOG_DEBUG, \"Encoder version %d.%d.%d.%d\\n\",",
      "1051:                avctx->extradata[3], avctx->extradata[2],",
      "1052:                avctx->extradata[1], avctx->extradata[0]);",
      "1053:         av_log(avctx, AV_LOG_DEBUG, \"Original format %\"PRIX32\"\\n\",",
      "1054:                AV_RB32(avctx->extradata + 4));",
      "1055:         c->interlaced  = 0;",
      "1057:         c->frame_info_size = 4;",
      "1058:     } else {",
      "1059:         av_log(avctx, AV_LOG_ERROR,",
      "",
      "[Removed Lines]",
      "1049:     } else if (avctx->extradata_size == 8) {",
      "1056:         c->pro         = 1;",
      "",
      "[Added Lines]",
      "1052:     } else if (c->pro && avctx->extradata_size == 8) {",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "15d4dc0da1e9f2450b5f9e748e1704fc0e6ef3a4",
      "candidate_info": {
        "commit_hash": "15d4dc0da1e9f2450b5f9e748e1704fc0e6ef3a4",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/15d4dc0da1e9f2450b5f9e748e1704fc0e6ef3a4",
        "files": [
          "libavcodec/utvideodec.c"
        ],
        "message": "avcodec/utvideodec: Set pro flag based on fourcc\n\nThis avoids mixing 8bit variants with pro and 10bit with non pro mode.\nFixes: out of array read\nFixes: poc_03_30.avi\n\nFound-by: GwanYeong Kim <gy741.kim@gmail.com>\nReviewed-by: Paul B Mahol <onemda@gmail.com>\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>\n(cherry picked from commit 47b7c68ae54560e2308bdb6be4fb076c73b93081)\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>",
        "before_after_code_files": [
          "libavcodec/utvideodec.c||libavcodec/utvideodec.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "libavcodec/utvideodec.c||libavcodec/utvideodec.c"
          ],
          "candidate": [
            "libavcodec/utvideodec.c||libavcodec/utvideodec.c"
          ]
        }
      },
      "candidate_diff": {
        "libavcodec/utvideodec.c||libavcodec/utvideodec.c": [
          "File: libavcodec/utvideodec.c -> libavcodec/utvideodec.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "832:     ff_bswapdsp_init(&c->bdsp);",
          "833:     ff_llviddsp_init(&c->llviddsp);",
          "866:     c->slice_bits_size = 0;",
          "868:     switch (avctx->codec_tag) {",
          "",
          "[Removed Lines]",
          "835:     if (avctx->extradata_size >= 16) {",
          "836:         av_log(avctx, AV_LOG_DEBUG, \"Encoder version %d.%d.%d.%d\\n\",",
          "837:                avctx->extradata[3], avctx->extradata[2],",
          "838:                avctx->extradata[1], avctx->extradata[0]);",
          "839:         av_log(avctx, AV_LOG_DEBUG, \"Original format %\"PRIX32\"\\n\",",
          "840:                AV_RB32(avctx->extradata + 4));",
          "841:         c->frame_info_size = AV_RL32(avctx->extradata + 8);",
          "842:         c->flags           = AV_RL32(avctx->extradata + 12);",
          "844:         if (c->frame_info_size != 4)",
          "845:             avpriv_request_sample(avctx, \"Frame info not 4 bytes\");",
          "846:         av_log(avctx, AV_LOG_DEBUG, \"Encoding parameters %08\"PRIX32\"\\n\", c->flags);",
          "847:         c->slices      = (c->flags >> 24) + 1;",
          "848:         c->compression = c->flags & 1;",
          "849:         c->interlaced  = c->flags & 0x800;",
          "850:     } else if (avctx->extradata_size == 8) {",
          "851:         av_log(avctx, AV_LOG_DEBUG, \"Encoder version %d.%d.%d.%d\\n\",",
          "852:                avctx->extradata[3], avctx->extradata[2],",
          "853:                avctx->extradata[1], avctx->extradata[0]);",
          "854:         av_log(avctx, AV_LOG_DEBUG, \"Original format %\"PRIX32\"\\n\",",
          "855:                AV_RB32(avctx->extradata + 4));",
          "856:         c->interlaced  = 0;",
          "857:         c->pro         = 1;",
          "858:         c->frame_info_size = 4;",
          "859:     } else {",
          "860:         av_log(avctx, AV_LOG_ERROR,",
          "861:                \"Insufficient extradata size %d, should be at least 16\\n\",",
          "862:                avctx->extradata_size);",
          "863:         return AVERROR_INVALIDDATA;",
          "864:     }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "891:         break;",
          "892:     case MKTAG('U', 'Q', 'Y', '2'):",
          "893:         c->planes      = 3;",
          "894:         avctx->pix_fmt = AV_PIX_FMT_YUV422P10;",
          "895:         break;",
          "896:     case MKTAG('U', 'Q', 'R', 'G'):",
          "897:         c->planes      = 3;",
          "898:         avctx->pix_fmt = AV_PIX_FMT_GBRP10;",
          "899:         break;",
          "900:     case MKTAG('U', 'Q', 'R', 'A'):",
          "901:         c->planes      = 4;",
          "902:         avctx->pix_fmt = AV_PIX_FMT_GBRAP10;",
          "903:         break;",
          "904:     case MKTAG('U', 'L', 'H', '0'):",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "863:         c->pro         = 1;",
          "868:         c->pro         = 1;",
          "873:         c->pro         = 1;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "929:         return AVERROR_PATCHWELCOME;",
          "930:     }",
          "932:     return 0;",
          "933: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "904:     if (!c->pro && avctx->extradata_size >= 16) {",
          "905:         av_log(avctx, AV_LOG_DEBUG, \"Encoder version %d.%d.%d.%d\\n\",",
          "906:                avctx->extradata[3], avctx->extradata[2],",
          "907:                avctx->extradata[1], avctx->extradata[0]);",
          "908:         av_log(avctx, AV_LOG_DEBUG, \"Original format %\"PRIX32\"\\n\",",
          "909:                AV_RB32(avctx->extradata + 4));",
          "910:         c->frame_info_size = AV_RL32(avctx->extradata + 8);",
          "911:         c->flags           = AV_RL32(avctx->extradata + 12);",
          "913:         if (c->frame_info_size != 4)",
          "914:             avpriv_request_sample(avctx, \"Frame info not 4 bytes\");",
          "915:         av_log(avctx, AV_LOG_DEBUG, \"Encoding parameters %08\"PRIX32\"\\n\", c->flags);",
          "916:         c->slices      = (c->flags >> 24) + 1;",
          "917:         c->compression = c->flags & 1;",
          "918:         c->interlaced  = c->flags & 0x800;",
          "919:     } else if (c->pro && avctx->extradata_size == 8) {",
          "920:         av_log(avctx, AV_LOG_DEBUG, \"Encoder version %d.%d.%d.%d\\n\",",
          "921:                avctx->extradata[3], avctx->extradata[2],",
          "922:                avctx->extradata[1], avctx->extradata[0]);",
          "923:         av_log(avctx, AV_LOG_DEBUG, \"Original format %\"PRIX32\"\\n\",",
          "924:                AV_RB32(avctx->extradata + 4));",
          "925:         c->interlaced  = 0;",
          "926:         c->frame_info_size = 4;",
          "927:     } else {",
          "928:         av_log(avctx, AV_LOG_ERROR,",
          "929:                \"Insufficient extradata size %d, should be at least 16\\n\",",
          "930:                avctx->extradata_size);",
          "931:         return AVERROR_INVALIDDATA;",
          "932:     }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "7050970d066b853f82b0891fd7b57c19b4fd9095",
      "candidate_info": {
        "commit_hash": "7050970d066b853f82b0891fd7b57c19b4fd9095",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/7050970d066b853f82b0891fd7b57c19b4fd9095",
        "files": [
          "libavcodec/utvideodec.c"
        ],
        "message": "avcodec/utvideodec: Set pro flag based on fourcc\n\nThis avoids mixing 8bit variants with pro and 10bit with non pro mode.\nFixes: out of array read\nFixes: poc_03_30.avi\n\nFound-by: GwanYeong Kim <gy741.kim@gmail.com>\nReviewed-by: Paul B Mahol <onemda@gmail.com>\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>\n(cherry picked from commit 47b7c68ae54560e2308bdb6be4fb076c73b93081)\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>",
        "before_after_code_files": [
          "libavcodec/utvideodec.c||libavcodec/utvideodec.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "libavcodec/utvideodec.c||libavcodec/utvideodec.c"
          ],
          "candidate": [
            "libavcodec/utvideodec.c||libavcodec/utvideodec.c"
          ]
        }
      },
      "candidate_diff": {
        "libavcodec/utvideodec.c||libavcodec/utvideodec.c": [
          "File: libavcodec/utvideodec.c -> libavcodec/utvideodec.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "728:     ff_bswapdsp_init(&c->bdsp);",
          "761:     c->slice_bits_size = 0;",
          "763:     switch (avctx->codec_tag) {",
          "",
          "[Removed Lines]",
          "730:     if (avctx->extradata_size >= 16) {",
          "731:         av_log(avctx, AV_LOG_DEBUG, \"Encoder version %d.%d.%d.%d\\n\",",
          "732:                avctx->extradata[3], avctx->extradata[2],",
          "733:                avctx->extradata[1], avctx->extradata[0]);",
          "734:         av_log(avctx, AV_LOG_DEBUG, \"Original format %\"PRIX32\"\\n\",",
          "735:                AV_RB32(avctx->extradata + 4));",
          "736:         c->frame_info_size = AV_RL32(avctx->extradata + 8);",
          "737:         c->flags           = AV_RL32(avctx->extradata + 12);",
          "739:         if (c->frame_info_size != 4)",
          "740:             avpriv_request_sample(avctx, \"Frame info not 4 bytes\");",
          "741:         av_log(avctx, AV_LOG_DEBUG, \"Encoding parameters %08\"PRIX32\"\\n\", c->flags);",
          "742:         c->slices      = (c->flags >> 24) + 1;",
          "743:         c->compression = c->flags & 1;",
          "744:         c->interlaced  = c->flags & 0x800;",
          "745:     } else if (avctx->extradata_size == 8) {",
          "746:         av_log(avctx, AV_LOG_DEBUG, \"Encoder version %d.%d.%d.%d\\n\",",
          "747:                avctx->extradata[3], avctx->extradata[2],",
          "748:                avctx->extradata[1], avctx->extradata[0]);",
          "749:         av_log(avctx, AV_LOG_DEBUG, \"Original format %\"PRIX32\"\\n\",",
          "750:                AV_RB32(avctx->extradata + 4));",
          "751:         c->interlaced  = 0;",
          "752:         c->pro         = 1;",
          "753:         c->frame_info_size = 4;",
          "754:     } else {",
          "755:         av_log(avctx, AV_LOG_ERROR,",
          "756:                \"Insufficient extradata size %d, should be at least 16\\n\",",
          "757:                avctx->extradata_size);",
          "758:         return AVERROR_INVALIDDATA;",
          "759:     }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "786:         break;",
          "787:     case MKTAG('U', 'Q', 'Y', '2'):",
          "788:         c->planes      = 3;",
          "789:         avctx->pix_fmt = AV_PIX_FMT_YUV422P10;",
          "790:         break;",
          "791:     case MKTAG('U', 'Q', 'R', 'G'):",
          "792:         c->planes      = 3;",
          "793:         avctx->pix_fmt = AV_PIX_FMT_GBRP10;",
          "794:         break;",
          "795:     case MKTAG('U', 'Q', 'R', 'A'):",
          "796:         c->planes      = 4;",
          "797:         avctx->pix_fmt = AV_PIX_FMT_GBRAP10;",
          "798:         break;",
          "799:     case MKTAG('U', 'L', 'H', '0'):",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "758:         c->pro         = 1;",
          "763:         c->pro         = 1;",
          "768:         c->pro         = 1;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "824:         return AVERROR_PATCHWELCOME;",
          "825:     }",
          "827:     return 0;",
          "828: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "799:     if (!c->pro && avctx->extradata_size >= 16) {",
          "800:         av_log(avctx, AV_LOG_DEBUG, \"Encoder version %d.%d.%d.%d\\n\",",
          "801:                avctx->extradata[3], avctx->extradata[2],",
          "802:                avctx->extradata[1], avctx->extradata[0]);",
          "803:         av_log(avctx, AV_LOG_DEBUG, \"Original format %\"PRIX32\"\\n\",",
          "804:                AV_RB32(avctx->extradata + 4));",
          "805:         c->frame_info_size = AV_RL32(avctx->extradata + 8);",
          "806:         c->flags           = AV_RL32(avctx->extradata + 12);",
          "808:         if (c->frame_info_size != 4)",
          "809:             avpriv_request_sample(avctx, \"Frame info not 4 bytes\");",
          "810:         av_log(avctx, AV_LOG_DEBUG, \"Encoding parameters %08\"PRIX32\"\\n\", c->flags);",
          "811:         c->slices      = (c->flags >> 24) + 1;",
          "812:         c->compression = c->flags & 1;",
          "813:         c->interlaced  = c->flags & 0x800;",
          "814:     } else if (c->pro && avctx->extradata_size == 8) {",
          "815:         av_log(avctx, AV_LOG_DEBUG, \"Encoder version %d.%d.%d.%d\\n\",",
          "816:                avctx->extradata[3], avctx->extradata[2],",
          "817:                avctx->extradata[1], avctx->extradata[0]);",
          "818:         av_log(avctx, AV_LOG_DEBUG, \"Original format %\"PRIX32\"\\n\",",
          "819:                AV_RB32(avctx->extradata + 4));",
          "820:         c->interlaced  = 0;",
          "821:         c->frame_info_size = 4;",
          "822:     } else {",
          "823:         av_log(avctx, AV_LOG_ERROR,",
          "824:                \"Insufficient extradata size %d, should be at least 16\\n\",",
          "825:                avctx->extradata_size);",
          "826:         return AVERROR_INVALIDDATA;",
          "827:     }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "51035698bde9c13da7eedc1f6eb47d190bbc949d",
      "candidate_info": {
        "commit_hash": "51035698bde9c13da7eedc1f6eb47d190bbc949d",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/51035698bde9c13da7eedc1f6eb47d190bbc949d",
        "files": [
          "libavcodec/utvideodec.c"
        ],
        "message": "avcodec/utvideodec: Set pro flag based on fourcc\n\nThis avoids mixing 8bit variants with pro and 10bit with non pro mode.\nFixes: out of array read\nFixes: poc_03_30.avi\n\nFound-by: GwanYeong Kim <gy741.kim@gmail.com>\nReviewed-by: Paul B Mahol <onemda@gmail.com>\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>\n(cherry picked from commit 47b7c68ae54560e2308bdb6be4fb076c73b93081)\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>",
        "before_after_code_files": [
          "libavcodec/utvideodec.c||libavcodec/utvideodec.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "libavcodec/utvideodec.c||libavcodec/utvideodec.c"
          ],
          "candidate": [
            "libavcodec/utvideodec.c||libavcodec/utvideodec.c"
          ]
        }
      },
      "candidate_diff": {
        "libavcodec/utvideodec.c||libavcodec/utvideodec.c": [
          "File: libavcodec/utvideodec.c -> libavcodec/utvideodec.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "798:     ff_bswapdsp_init(&c->bdsp);",
          "799:     ff_llviddsp_init(&c->llviddsp);",
          "832:     c->slice_bits_size = 0;",
          "834:     switch (avctx->codec_tag) {",
          "",
          "[Removed Lines]",
          "801:     if (avctx->extradata_size >= 16) {",
          "802:         av_log(avctx, AV_LOG_DEBUG, \"Encoder version %d.%d.%d.%d\\n\",",
          "803:                avctx->extradata[3], avctx->extradata[2],",
          "804:                avctx->extradata[1], avctx->extradata[0]);",
          "805:         av_log(avctx, AV_LOG_DEBUG, \"Original format %\"PRIX32\"\\n\",",
          "806:                AV_RB32(avctx->extradata + 4));",
          "807:         c->frame_info_size = AV_RL32(avctx->extradata + 8);",
          "808:         c->flags           = AV_RL32(avctx->extradata + 12);",
          "810:         if (c->frame_info_size != 4)",
          "811:             avpriv_request_sample(avctx, \"Frame info not 4 bytes\");",
          "812:         av_log(avctx, AV_LOG_DEBUG, \"Encoding parameters %08\"PRIX32\"\\n\", c->flags);",
          "813:         c->slices      = (c->flags >> 24) + 1;",
          "814:         c->compression = c->flags & 1;",
          "815:         c->interlaced  = c->flags & 0x800;",
          "816:     } else if (avctx->extradata_size == 8) {",
          "817:         av_log(avctx, AV_LOG_DEBUG, \"Encoder version %d.%d.%d.%d\\n\",",
          "818:                avctx->extradata[3], avctx->extradata[2],",
          "819:                avctx->extradata[1], avctx->extradata[0]);",
          "820:         av_log(avctx, AV_LOG_DEBUG, \"Original format %\"PRIX32\"\\n\",",
          "821:                AV_RB32(avctx->extradata + 4));",
          "822:         c->interlaced  = 0;",
          "823:         c->pro         = 1;",
          "824:         c->frame_info_size = 4;",
          "825:     } else {",
          "826:         av_log(avctx, AV_LOG_ERROR,",
          "827:                \"Insufficient extradata size %d, should be at least 16\\n\",",
          "828:                avctx->extradata_size);",
          "829:         return AVERROR_INVALIDDATA;",
          "830:     }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "857:         break;",
          "858:     case MKTAG('U', 'Q', 'Y', '2'):",
          "859:         c->planes      = 3;",
          "860:         avctx->pix_fmt = AV_PIX_FMT_YUV422P10;",
          "861:         break;",
          "862:     case MKTAG('U', 'Q', 'R', 'G'):",
          "863:         c->planes      = 3;",
          "864:         avctx->pix_fmt = AV_PIX_FMT_GBRP10;",
          "865:         break;",
          "866:     case MKTAG('U', 'Q', 'R', 'A'):",
          "867:         c->planes      = 4;",
          "868:         avctx->pix_fmt = AV_PIX_FMT_GBRAP10;",
          "869:         break;",
          "870:     case MKTAG('U', 'L', 'H', '0'):",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "829:         c->pro         = 1;",
          "834:         c->pro         = 1;",
          "839:         c->pro         = 1;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "895:         return AVERROR_PATCHWELCOME;",
          "896:     }",
          "898:     return 0;",
          "899: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "870:     if (!c->pro && avctx->extradata_size >= 16) {",
          "871:         av_log(avctx, AV_LOG_DEBUG, \"Encoder version %d.%d.%d.%d\\n\",",
          "872:                avctx->extradata[3], avctx->extradata[2],",
          "873:                avctx->extradata[1], avctx->extradata[0]);",
          "874:         av_log(avctx, AV_LOG_DEBUG, \"Original format %\"PRIX32\"\\n\",",
          "875:                AV_RB32(avctx->extradata + 4));",
          "876:         c->frame_info_size = AV_RL32(avctx->extradata + 8);",
          "877:         c->flags           = AV_RL32(avctx->extradata + 12);",
          "879:         if (c->frame_info_size != 4)",
          "880:             avpriv_request_sample(avctx, \"Frame info not 4 bytes\");",
          "881:         av_log(avctx, AV_LOG_DEBUG, \"Encoding parameters %08\"PRIX32\"\\n\", c->flags);",
          "882:         c->slices      = (c->flags >> 24) + 1;",
          "883:         c->compression = c->flags & 1;",
          "884:         c->interlaced  = c->flags & 0x800;",
          "885:     } else if (c->pro && avctx->extradata_size == 8) {",
          "886:         av_log(avctx, AV_LOG_DEBUG, \"Encoder version %d.%d.%d.%d\\n\",",
          "887:                avctx->extradata[3], avctx->extradata[2],",
          "888:                avctx->extradata[1], avctx->extradata[0]);",
          "889:         av_log(avctx, AV_LOG_DEBUG, \"Original format %\"PRIX32\"\\n\",",
          "890:                AV_RB32(avctx->extradata + 4));",
          "891:         c->interlaced  = 0;",
          "892:         c->frame_info_size = 4;",
          "893:     } else {",
          "894:         av_log(avctx, AV_LOG_ERROR,",
          "895:                \"Insufficient extradata size %d, should be at least 16\\n\",",
          "896:                avctx->extradata_size);",
          "897:         return AVERROR_INVALIDDATA;",
          "898:     }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "92b32664cdc064523c60ddba5ed139855e08470c",
      "candidate_info": {
        "commit_hash": "92b32664cdc064523c60ddba5ed139855e08470c",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/92b32664cdc064523c60ddba5ed139855e08470c",
        "files": [
          "libavcodec/utvideo.h",
          "libavcodec/utvideodec.c",
          "libavformat/riff.c"
        ],
        "message": "avcodec/utvideodec: add support for UMH2, UMY2, UMH4, UMY4, UMRA, UMRG\n\nThese are new modes which are supposed to be more SIMD friendly.\n\nSigned-off-by: Paul B Mahol <onemda@gmail.com>",
        "before_after_code_files": [
          "libavcodec/utvideo.h||libavcodec/utvideo.h",
          "libavcodec/utvideodec.c||libavcodec/utvideodec.c",
          "libavformat/riff.c||libavformat/riff.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libavcodec/utvideodec.c||libavcodec/utvideodec.c"
          ],
          "candidate": [
            "libavcodec/utvideodec.c||libavcodec/utvideodec.c"
          ]
        }
      },
      "candidate_diff": {
        "libavcodec/utvideo.h||libavcodec/utvideo.h": [
          "File: libavcodec/utvideo.h -> libavcodec/utvideo.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "72:     LLVidDSPContext llviddsp;",
          "73:     LLVidEncDSPContext llvidencdsp;",
          "76:     int      planes;",
          "77:     int      slices;",
          "78:     int      compression;",
          "79:     int      interlaced;",
          "80:     int      frame_pred;",
          "81:     int      pro;",
          "83:     ptrdiff_t slice_stride;",
          "84:     uint8_t *slice_bits, *slice_buffer[4];",
          "85:     int      slice_bits_size;",
          "86: } UtvideoContext;",
          "88: typedef struct HuffEntry {",
          "",
          "[Removed Lines]",
          "75:     uint32_t frame_info_size, flags, frame_info;",
          "",
          "[Added Lines]",
          "75:     uint32_t frame_info_size, flags, frame_info, offset;",
          "82:     int      pack;",
          "88:     const uint8_t *packed_stream[4][256];",
          "89:     size_t packed_stream_size[4][256];",
          "90:     const uint8_t *control_stream[4][256];",
          "91:     size_t control_stream_size[4][256];",
          "",
          "---------------"
        ],
        "libavcodec/utvideodec.c||libavcodec/utvideodec.c": [
          "File: libavcodec/utvideodec.c -> libavcodec/utvideodec.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "247:     int sstart, send;",
          "248:     VLC vlc;",
          "249:     GetBitContext gb;",
          "251:     const int cmask = compute_cmask(plane_no, c->interlaced, c->avctx->pix_fmt);",
          "253:     if (build_huff(src, &vlc, &fsym)) {",
          "254:         av_log(c->avctx, AV_LOG_ERROR, \"Cannot build Huffman codes\\n\");",
          "255:         return AVERROR_INVALIDDATA;",
          "",
          "[Removed Lines]",
          "250:     int prev, fsym;",
          "",
          "[Added Lines]",
          "250:     int ret, prev, fsym;",
          "253:     if (c->pack) {",
          "254:         send = 0;",
          "255:         for (slice = 0; slice < c->slices; slice++) {",
          "256:             GetBitContext cbit, pbit;",
          "257:             uint8_t *dest, *p;",
          "259:             ret = init_get_bits8(&cbit, c->control_stream[plane_no][slice], c->control_stream_size[plane_no][slice]);",
          "260:             if (ret < 0)",
          "261:                 return ret;",
          "263:             ret = init_get_bits8(&pbit, c->packed_stream[plane_no][slice], c->packed_stream_size[plane_no][slice]);",
          "264:             if (ret < 0)",
          "265:                 return ret;",
          "267:             sstart = send;",
          "268:             send   = (height * (slice + 1) / c->slices) & cmask;",
          "269:             dest   = dst + sstart * stride;",
          "271:             for (p = dest; p < dst + send * stride; p += 8) {",
          "272:                 int bits = get_bits_le(&cbit, 3);",
          "274:                 if (bits == 0) {",
          "276:                 } else {",
          "277:                     uint32_t sub = 0x80 >> (8 - (bits + 1)), add;",
          "278:                     int k;",
          "280:                     for (k = 0; k < 8; k++) {",
          "282:                         p[k] = get_bits_le(&pbit, bits + 1);",
          "283:                         add = (~p[k] & sub) << (8 - bits);",
          "284:                         p[k] -= sub;",
          "285:                         p[k] += add;",
          "286:                     }",
          "287:                 }",
          "288:             }",
          "289:         }",
          "291:         return 0;",
          "292:     }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "568:     bytestream2_init(&gb, buf, buf_size);",
          "570:         if (bytestream2_get_bytes_left(&gb) < c->frame_info_size) {",
          "571:             av_log(avctx, AV_LOG_ERROR, \"Not enough data for frame information\\n\");",
          "572:             return AVERROR_INVALIDDATA;",
          "",
          "[Removed Lines]",
          "569:     if (c->pro) {",
          "",
          "[Added Lines]",
          "611:     if (c->pack) {",
          "612:         const uint8_t *packed_stream;",
          "613:         const uint8_t *control_stream;",
          "614:         GetByteContext pb;",
          "615:         uint32_t nb_cbs;",
          "616:         int left;",
          "618:         c->frame_info = PRED_GRADIENT << 8;",
          "620:         if (bytestream2_get_byte(&gb) != 1)",
          "621:             return AVERROR_INVALIDDATA;",
          "622:         bytestream2_skip(&gb, 3);",
          "623:         c->offset = bytestream2_get_le32(&gb);",
          "625:         if (buf_size <= c->offset + 8LL)",
          "626:             return AVERROR_INVALIDDATA;",
          "628:         bytestream2_init(&pb, buf + 8 + c->offset, buf_size - 8 - c->offset);",
          "630:         nb_cbs = bytestream2_get_le32(&pb);",
          "631:         if (nb_cbs > c->offset)",
          "632:             return AVERROR_INVALIDDATA;",
          "634:         packed_stream = buf + 8;",
          "635:         control_stream = packed_stream + (c->offset - nb_cbs);",
          "636:         left = control_stream - packed_stream;",
          "638:         for (i = 0; i < c->planes; i++) {",
          "639:             for (j = 0; j < c->slices; j++) {",
          "640:                 c->packed_stream[i][j] = packed_stream;",
          "641:                 c->packed_stream_size[i][j] = bytestream2_get_le32(&pb);",
          "642:                 left -= c->packed_stream_size[i][j];",
          "643:                 if (left < 0)",
          "644:                     return AVERROR_INVALIDDATA;",
          "645:                 packed_stream += c->packed_stream_size[i][j];",
          "646:             }",
          "647:         }",
          "649:         left = buf + buf_size - control_stream;",
          "651:         for (i = 0; i < c->planes; i++) {",
          "652:             for (j = 0; j < c->slices; j++) {",
          "653:                 c->control_stream[i][j] = control_stream;",
          "654:                 c->control_stream_size[i][j] = bytestream2_get_le32(&pb);",
          "655:                 left -= c->control_stream_size[i][j];",
          "656:                 if (left < 0)",
          "657:                     return AVERROR_INVALIDDATA;",
          "658:                 control_stream += c->control_stream_size[i][j];",
          "659:             }",
          "660:         }",
          "661:     } else if (c->pro) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "636:     max_slice_size += 4*avctx->width;",
          "644:     }",
          "646:     switch (c->avctx->pix_fmt) {",
          "",
          "[Removed Lines]",
          "638:     av_fast_malloc(&c->slice_bits, &c->slice_bits_size,",
          "639:                    max_slice_size + AV_INPUT_BUFFER_PADDING_SIZE);",
          "641:     if (!c->slice_bits) {",
          "642:         av_log(avctx, AV_LOG_ERROR, \"Cannot allocate temporary buffer\\n\");",
          "643:         return AVERROR(ENOMEM);",
          "",
          "[Added Lines]",
          "730:     if (!c->pack) {",
          "731:         av_fast_malloc(&c->slice_bits, &c->slice_bits_size,",
          "732:                        max_slice_size + AV_INPUT_BUFFER_PADDING_SIZE);",
          "734:         if (!c->slice_bits) {",
          "735:             av_log(avctx, AV_LOG_ERROR, \"Cannot allocate temporary buffer\\n\");",
          "736:             return AVERROR(ENOMEM);",
          "737:         }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "819:     ff_bswapdsp_init(&c->bdsp);",
          "820:     ff_llviddsp_init(&c->llviddsp);",
          "853:     c->slice_bits_size = 0;",
          "855:     switch (avctx->codec_tag) {",
          "",
          "[Removed Lines]",
          "822:     if (avctx->extradata_size >= 16) {",
          "823:         av_log(avctx, AV_LOG_DEBUG, \"Encoder version %d.%d.%d.%d\\n\",",
          "824:                avctx->extradata[3], avctx->extradata[2],",
          "825:                avctx->extradata[1], avctx->extradata[0]);",
          "826:         av_log(avctx, AV_LOG_DEBUG, \"Original format %\"PRIX32\"\\n\",",
          "827:                AV_RB32(avctx->extradata + 4));",
          "828:         c->frame_info_size = AV_RL32(avctx->extradata + 8);",
          "829:         c->flags           = AV_RL32(avctx->extradata + 12);",
          "831:         if (c->frame_info_size != 4)",
          "832:             avpriv_request_sample(avctx, \"Frame info not 4 bytes\");",
          "833:         av_log(avctx, AV_LOG_DEBUG, \"Encoding parameters %08\"PRIX32\"\\n\", c->flags);",
          "834:         c->slices      = (c->flags >> 24) + 1;",
          "835:         c->compression = c->flags & 1;",
          "836:         c->interlaced  = c->flags & 0x800;",
          "837:     } else if (avctx->extradata_size == 8) {",
          "838:         av_log(avctx, AV_LOG_DEBUG, \"Encoder version %d.%d.%d.%d\\n\",",
          "839:                avctx->extradata[3], avctx->extradata[2],",
          "840:                avctx->extradata[1], avctx->extradata[0]);",
          "841:         av_log(avctx, AV_LOG_DEBUG, \"Original format %\"PRIX32\"\\n\",",
          "842:                AV_RB32(avctx->extradata + 4));",
          "843:         c->interlaced  = 0;",
          "844:         c->pro         = 1;",
          "845:         c->frame_info_size = 4;",
          "846:     } else {",
          "847:         av_log(avctx, AV_LOG_ERROR,",
          "848:                \"Insufficient extradata size %d, should be at least 16\\n\",",
          "849:                avctx->extradata_size);",
          "850:         return AVERROR_INVALIDDATA;",
          "851:     }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "903:         avctx->pix_fmt = AV_PIX_FMT_YUV444P;",
          "904:         avctx->colorspace = AVCOL_SPC_BT709;",
          "905:         break;",
          "906:     default:",
          "907:         av_log(avctx, AV_LOG_ERROR, \"Unknown Ut Video FOURCC provided (%08X)\\n\",",
          "908:                avctx->codec_tag);",
          "909:         return AVERROR_INVALIDDATA;",
          "910:     }",
          "912:     return 0;",
          "913: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "969:     case MKTAG('U', 'M', 'Y', '2'):",
          "970:         c->planes      = 3;",
          "971:         c->pack        = 1;",
          "972:         avctx->pix_fmt = AV_PIX_FMT_YUV422P;",
          "973:         avctx->colorspace = AVCOL_SPC_BT470BG;",
          "974:         break;",
          "975:     case MKTAG('U', 'M', 'H', '2'):",
          "976:         c->planes      = 3;",
          "977:         c->pack        = 1;",
          "978:         avctx->pix_fmt = AV_PIX_FMT_YUV422P;",
          "979:         avctx->colorspace = AVCOL_SPC_BT709;",
          "980:         break;",
          "981:     case MKTAG('U', 'M', 'Y', '4'):",
          "982:         c->planes      = 3;",
          "983:         c->pack        = 1;",
          "984:         avctx->pix_fmt = AV_PIX_FMT_YUV444P;",
          "985:         avctx->colorspace = AVCOL_SPC_BT470BG;",
          "986:         break;",
          "987:     case MKTAG('U', 'M', 'H', '4'):",
          "988:         c->planes      = 3;",
          "989:         c->pack        = 1;",
          "990:         avctx->pix_fmt = AV_PIX_FMT_YUV444P;",
          "991:         avctx->colorspace = AVCOL_SPC_BT709;",
          "992:         break;",
          "993:     case MKTAG('U', 'M', 'R', 'G'):",
          "994:         c->planes      = 3;",
          "995:         c->pack        = 1;",
          "996:         avctx->pix_fmt = AV_PIX_FMT_GBRP;",
          "997:         break;",
          "998:     case MKTAG('U', 'M', 'R', 'A'):",
          "999:         c->planes      = 4;",
          "1000:         c->pack        = 1;",
          "1001:         avctx->pix_fmt = AV_PIX_FMT_GBRAP;",
          "1002:         break;",
          "1009:     if (c->pack && avctx->extradata_size >= 16) {",
          "1010:         av_log(avctx, AV_LOG_DEBUG, \"Encoder version %d.%d.%d.%d\\n\",",
          "1011:                avctx->extradata[3], avctx->extradata[2],",
          "1012:                avctx->extradata[1], avctx->extradata[0]);",
          "1013:         av_log(avctx, AV_LOG_DEBUG, \"Original format %\"PRIX32\"\\n\",",
          "1014:                AV_RB32(avctx->extradata + 4));",
          "1015:         c->compression = avctx->extradata[8];",
          "1016:         if (c->compression != 2)",
          "1017:             avpriv_request_sample(avctx, \"Unknown compression type\");",
          "1018:         c->slices      = avctx->extradata[9] + 1;",
          "1019:     } else if (avctx->extradata_size >= 16) {",
          "1020:         av_log(avctx, AV_LOG_DEBUG, \"Encoder version %d.%d.%d.%d\\n\",",
          "1021:                avctx->extradata[3], avctx->extradata[2],",
          "1022:                avctx->extradata[1], avctx->extradata[0]);",
          "1023:         av_log(avctx, AV_LOG_DEBUG, \"Original format %\"PRIX32\"\\n\",",
          "1024:                AV_RB32(avctx->extradata + 4));",
          "1025:         c->frame_info_size = AV_RL32(avctx->extradata + 8);",
          "1026:         c->flags           = AV_RL32(avctx->extradata + 12);",
          "1028:         if (c->frame_info_size != 4)",
          "1029:             avpriv_request_sample(avctx, \"Frame info not 4 bytes\");",
          "1030:         av_log(avctx, AV_LOG_DEBUG, \"Encoding parameters %08\"PRIX32\"\\n\", c->flags);",
          "1031:         c->slices      = (c->flags >> 24) + 1;",
          "1032:         c->compression = c->flags & 1;",
          "1033:         c->interlaced  = c->flags & 0x800;",
          "1034:     } else if (avctx->extradata_size == 8) {",
          "1035:         av_log(avctx, AV_LOG_DEBUG, \"Encoder version %d.%d.%d.%d\\n\",",
          "1036:                avctx->extradata[3], avctx->extradata[2],",
          "1037:                avctx->extradata[1], avctx->extradata[0]);",
          "1038:         av_log(avctx, AV_LOG_DEBUG, \"Original format %\"PRIX32\"\\n\",",
          "1039:                AV_RB32(avctx->extradata + 4));",
          "1040:         c->interlaced  = 0;",
          "1041:         c->pro         = 1;",
          "1042:         c->frame_info_size = 4;",
          "1043:     } else {",
          "1044:         av_log(avctx, AV_LOG_ERROR,",
          "1045:                \"Insufficient extradata size %d, should be at least 16\\n\",",
          "1046:                avctx->extradata_size);",
          "1047:         return AVERROR_INVALIDDATA;",
          "1048:     }",
          "",
          "---------------"
        ],
        "libavformat/riff.c||libavformat/riff.c": [
          "File: libavformat/riff.c -> libavformat/riff.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "404:     { AV_CODEC_ID_UTVIDEO,      MKTAG('U', 'Q', 'Y', '2') },",
          "405:     { AV_CODEC_ID_UTVIDEO,      MKTAG('U', 'Q', 'R', 'A') },",
          "406:     { AV_CODEC_ID_UTVIDEO,      MKTAG('U', 'Q', 'R', 'G') },",
          "407:     { AV_CODEC_ID_VBLE,         MKTAG('V', 'B', 'L', 'E') },",
          "408:     { AV_CODEC_ID_ESCAPE130,    MKTAG('E', '1', '3', '0') },",
          "409:     { AV_CODEC_ID_DXTORY,       MKTAG('x', 't', 'o', 'r') },",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "407:     { AV_CODEC_ID_UTVIDEO,      MKTAG('U', 'M', 'Y', '2') },",
          "408:     { AV_CODEC_ID_UTVIDEO,      MKTAG('U', 'M', 'H', '2') },",
          "409:     { AV_CODEC_ID_UTVIDEO,      MKTAG('U', 'M', 'Y', '4') },",
          "410:     { AV_CODEC_ID_UTVIDEO,      MKTAG('U', 'M', 'H', '4') },",
          "411:     { AV_CODEC_ID_UTVIDEO,      MKTAG('U', 'M', 'R', 'A') },",
          "412:     { AV_CODEC_ID_UTVIDEO,      MKTAG('U', 'M', 'R', 'G') },",
          "",
          "---------------"
        ]
      }
    }
  ]
}
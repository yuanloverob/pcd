{
  "cve_id": "CVE-2016-7097",
  "cve_desc": "The filesystem implementation in the Linux kernel through 4.8.2 preserves the setgid bit during a setxattr call, which allows local users to gain group privileges by leveraging the existence of a setgid program with restrictions on execute permissions.",
  "repo": "torvalds/linux",
  "patch_hash": "073931017b49d9458aa351605b43a7e34598caef",
  "patch_info": {
    "commit_hash": "073931017b49d9458aa351605b43a7e34598caef",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/073931017b49d9458aa351605b43a7e34598caef",
    "files": [
      "fs/9p/acl.c",
      "fs/btrfs/acl.c",
      "fs/ceph/acl.c",
      "fs/ext2/acl.c",
      "fs/ext4/acl.c",
      "fs/f2fs/acl.c",
      "fs/gfs2/acl.c",
      "fs/hfsplus/posix_acl.c",
      "fs/jffs2/acl.c",
      "fs/jfs/acl.c",
      "fs/ocfs2/acl.c",
      "fs/orangefs/acl.c",
      "fs/posix_acl.c",
      "fs/reiserfs/xattr_acl.c",
      "fs/xfs/xfs_acl.c",
      "include/linux/posix_acl.h"
    ],
    "message": "posix_acl: Clear SGID bit when setting file permissions\n\nWhen file permissions are modified via chmod(2) and the user is not in\nthe owning group or capable of CAP_FSETID, the setgid bit is cleared in\ninode_change_ok().  Setting a POSIX ACL via setxattr(2) sets the file\npermissions as well as the new ACL, but doesn't clear the setgid bit in\na similar way; this allows to bypass the check in chmod(2).  Fix that.\n\nReferences: CVE-2016-7097\nReviewed-by: Christoph Hellwig <hch@lst.de>\nReviewed-by: Jeff Layton <jlayton@redhat.com>\nSigned-off-by: Jan Kara <jack@suse.cz>\nSigned-off-by: Andreas Gruenbacher <agruenba@redhat.com>",
    "before_after_code_files": [
      "fs/9p/acl.c||fs/9p/acl.c",
      "fs/btrfs/acl.c||fs/btrfs/acl.c",
      "fs/ceph/acl.c||fs/ceph/acl.c",
      "fs/ext2/acl.c||fs/ext2/acl.c",
      "fs/ext4/acl.c||fs/ext4/acl.c",
      "fs/f2fs/acl.c||fs/f2fs/acl.c",
      "fs/gfs2/acl.c||fs/gfs2/acl.c",
      "fs/hfsplus/posix_acl.c||fs/hfsplus/posix_acl.c",
      "fs/jffs2/acl.c||fs/jffs2/acl.c",
      "fs/jfs/acl.c||fs/jfs/acl.c",
      "fs/ocfs2/acl.c||fs/ocfs2/acl.c",
      "fs/orangefs/acl.c||fs/orangefs/acl.c",
      "fs/posix_acl.c||fs/posix_acl.c",
      "fs/reiserfs/xattr_acl.c||fs/reiserfs/xattr_acl.c",
      "fs/xfs/xfs_acl.c||fs/xfs/xfs_acl.c",
      "include/linux/posix_acl.h||include/linux/posix_acl.h"
    ]
  },
  "patch_diff": {
    "fs/9p/acl.c||fs/9p/acl.c": [
      "File: fs/9p/acl.c -> fs/9p/acl.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "276:  switch (handler->flags) {",
      "277:  case ACL_TYPE_ACCESS:",
      "278:   if (acl) {",
      "282:     goto err_out;",
      "304:    }",
      "305:   }",
      "306:   break;",
      "307:  case ACL_TYPE_DEFAULT:",
      "",
      "[Removed Lines]",
      "279:    umode_t mode = inode->i_mode;",
      "280:    retval = posix_acl_equiv_mode(acl, &mode);",
      "281:    if (retval < 0)",
      "283:    else {",
      "284:     struct iattr iattr;",
      "285:     if (retval == 0) {",
      "291:      acl = NULL;",
      "292:      value = NULL;",
      "293:      size = 0;",
      "294:     }",
      "296:     iattr.ia_mode = ((mode & S_IALLUGO) |",
      "297:        (inode->i_mode & ~S_IALLUGO));",
      "298:     iattr.ia_valid = ATTR_MODE;",
      "303:     v9fs_vfs_setattr_dotl(dentry, &iattr);",
      "",
      "[Added Lines]",
      "279:    struct iattr iattr;",
      "281:    retval = posix_acl_update_mode(inode, &iattr.ia_mode, &acl);",
      "282:    if (retval)",
      "284:    if (!acl) {",
      "290:     value = NULL;",
      "291:     size = 0;",
      "293:    iattr.ia_valid = ATTR_MODE;",
      "298:    v9fs_vfs_setattr_dotl(dentry, &iattr);",
      "",
      "---------------"
    ],
    "fs/btrfs/acl.c||fs/btrfs/acl.c": [
      "File: fs/btrfs/acl.c -> fs/btrfs/acl.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "79:  case ACL_TYPE_ACCESS:",
      "80:   name = XATTR_NAME_POSIX_ACL_ACCESS;",
      "81:   if (acl) {",
      "84:     return ret;",
      "87:   }",
      "88:   ret = 0;",
      "89:   break;",
      "",
      "[Removed Lines]",
      "82:    ret = posix_acl_equiv_mode(acl, &inode->i_mode);",
      "83:    if (ret < 0)",
      "85:    if (ret == 0)",
      "86:     acl = NULL;",
      "",
      "[Added Lines]",
      "82:    ret = posix_acl_update_mode(inode, &inode->i_mode, &acl);",
      "83:    if (ret)",
      "",
      "---------------"
    ],
    "fs/ceph/acl.c||fs/ceph/acl.c": [
      "File: fs/ceph/acl.c -> fs/ceph/acl.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "95:  case ACL_TYPE_ACCESS:",
      "96:   name = XATTR_NAME_POSIX_ACL_ACCESS;",
      "97:   if (acl) {",
      "100:     goto out;",
      "103:   }",
      "104:   break;",
      "105:  case ACL_TYPE_DEFAULT:",
      "",
      "[Removed Lines]",
      "98:    ret = posix_acl_equiv_mode(acl, &new_mode);",
      "99:    if (ret < 0)",
      "101:    if (ret == 0)",
      "102:     acl = NULL;",
      "",
      "[Added Lines]",
      "98:    ret = posix_acl_update_mode(inode, &new_mode, &acl);",
      "99:    if (ret)",
      "",
      "---------------"
    ],
    "fs/ext2/acl.c||fs/ext2/acl.c": [
      "File: fs/ext2/acl.c -> fs/ext2/acl.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "190:   case ACL_TYPE_ACCESS:",
      "191:    name_index = EXT2_XATTR_INDEX_POSIX_ACL_ACCESS;",
      "192:    if (acl) {",
      "195:      return error;",
      "202:    }",
      "203:    break;",
      "",
      "[Removed Lines]",
      "193:     error = posix_acl_equiv_mode(acl, &inode->i_mode);",
      "194:     if (error < 0)",
      "196:     else {",
      "197:      inode->i_ctime = CURRENT_TIME_SEC;",
      "198:      mark_inode_dirty(inode);",
      "199:      if (error == 0)",
      "200:       acl = NULL;",
      "201:     }",
      "",
      "[Added Lines]",
      "193:     error = posix_acl_update_mode(inode, &inode->i_mode, &acl);",
      "194:     if (error)",
      "196:     inode->i_ctime = CURRENT_TIME_SEC;",
      "197:     mark_inode_dirty(inode);",
      "",
      "---------------"
    ],
    "fs/ext4/acl.c||fs/ext4/acl.c": [
      "File: fs/ext4/acl.c -> fs/ext4/acl.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "193:  case ACL_TYPE_ACCESS:",
      "194:   name_index = EXT4_XATTR_INDEX_POSIX_ACL_ACCESS;",
      "195:   if (acl) {",
      "198:     return error;",
      "205:   }",
      "206:   break;",
      "",
      "[Removed Lines]",
      "196:    error = posix_acl_equiv_mode(acl, &inode->i_mode);",
      "197:    if (error < 0)",
      "199:    else {",
      "200:     inode->i_ctime = ext4_current_time(inode);",
      "201:     ext4_mark_inode_dirty(handle, inode);",
      "202:     if (error == 0)",
      "203:      acl = NULL;",
      "204:    }",
      "",
      "[Added Lines]",
      "196:    error = posix_acl_update_mode(inode, &inode->i_mode, &acl);",
      "197:    if (error)",
      "199:    inode->i_ctime = ext4_current_time(inode);",
      "200:    ext4_mark_inode_dirty(handle, inode);",
      "",
      "---------------"
    ],
    "fs/f2fs/acl.c||fs/f2fs/acl.c": [
      "File: fs/f2fs/acl.c -> fs/f2fs/acl.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "210:  case ACL_TYPE_ACCESS:",
      "211:   name_index = F2FS_XATTR_INDEX_POSIX_ACL_ACCESS;",
      "212:   if (acl) {",
      "215:     return error;",
      "216:    set_acl_inode(inode, inode->i_mode);",
      "219:   }",
      "220:   break;",
      "",
      "[Removed Lines]",
      "213:    error = posix_acl_equiv_mode(acl, &inode->i_mode);",
      "214:    if (error < 0)",
      "217:    if (error == 0)",
      "218:     acl = NULL;",
      "",
      "[Added Lines]",
      "213:    error = posix_acl_update_mode(inode, &inode->i_mode, &acl);",
      "214:    if (error)",
      "",
      "---------------"
    ],
    "fs/gfs2/acl.c||fs/gfs2/acl.c": [
      "File: fs/gfs2/acl.c -> fs/gfs2/acl.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "92:  if (type == ACL_TYPE_ACCESS) {",
      "93:   umode_t mode = inode->i_mode;",
      "97:    return error;",
      "104:    mark_inode_dirty(inode);",
      "106:  }",
      "108:  if (acl) {",
      "",
      "[Removed Lines]",
      "95:   error = posix_acl_equiv_mode(acl, &mode);",
      "96:   if (error < 0)",
      "99:   if (error == 0)",
      "100:    acl = NULL;",
      "102:   if (mode != inode->i_mode) {",
      "103:    inode->i_mode = mode;",
      "105:   }",
      "",
      "[Added Lines]",
      "95:   error = posix_acl_update_mode(inode, &inode->i_mode, &acl);",
      "96:   if (error)",
      "98:   if (mode != inode->i_mode)",
      "",
      "---------------"
    ],
    "fs/hfsplus/posix_acl.c||fs/hfsplus/posix_acl.c": [
      "File: fs/hfsplus/posix_acl.c -> fs/hfsplus/posix_acl.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "65:  case ACL_TYPE_ACCESS:",
      "66:   xattr_name = XATTR_NAME_POSIX_ACL_ACCESS;",
      "67:   if (acl) {",
      "70:     return err;",
      "71:   }",
      "72:   err = 0;",
      "",
      "[Removed Lines]",
      "68:    err = posix_acl_equiv_mode(acl, &inode->i_mode);",
      "69:    if (err < 0)",
      "",
      "[Added Lines]",
      "68:    err = posix_acl_update_mode(inode, &inode->i_mode, &acl);",
      "69:    if (err)",
      "",
      "---------------"
    ],
    "fs/jffs2/acl.c||fs/jffs2/acl.c": [
      "File: fs/jffs2/acl.c -> fs/jffs2/acl.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "233:  case ACL_TYPE_ACCESS:",
      "234:   xprefix = JFFS2_XPREFIX_ACL_ACCESS;",
      "235:   if (acl) {",
      "239:     return rc;",
      "240:    if (inode->i_mode != mode) {",
      "241:     struct iattr attr;",
      "",
      "[Removed Lines]",
      "236:    umode_t mode = inode->i_mode;",
      "237:    rc = posix_acl_equiv_mode(acl, &mode);",
      "238:    if (rc < 0)",
      "",
      "[Added Lines]",
      "236:    umode_t mode;",
      "238:    rc = posix_acl_update_mode(inode, &mode, &acl);",
      "239:    if (rc)",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "247:     if (rc < 0)",
      "248:      return rc;",
      "249:    }",
      "252:   }",
      "253:   break;",
      "254:  case ACL_TYPE_DEFAULT:",
      "",
      "[Removed Lines]",
      "250:    if (rc == 0)",
      "251:     acl = NULL;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "fs/jfs/acl.c||fs/jfs/acl.c": [
      "File: fs/jfs/acl.c -> fs/jfs/acl.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "78:  case ACL_TYPE_ACCESS:",
      "79:   ea_name = XATTR_NAME_POSIX_ACL_ACCESS;",
      "80:   if (acl) {",
      "83:     return rc;",
      "84:    inode->i_ctime = CURRENT_TIME;",
      "85:    mark_inode_dirty(inode);",
      "88:   }",
      "89:   break;",
      "90:  case ACL_TYPE_DEFAULT:",
      "",
      "[Removed Lines]",
      "81:    rc = posix_acl_equiv_mode(acl, &inode->i_mode);",
      "82:    if (rc < 0)",
      "86:    if (rc == 0)",
      "87:     acl = NULL;",
      "",
      "[Added Lines]",
      "81:    rc = posix_acl_update_mode(inode, &inode->i_mode, &acl);",
      "82:    if (rc)",
      "",
      "---------------"
    ],
    "fs/ocfs2/acl.c||fs/ocfs2/acl.c": [
      "File: fs/ocfs2/acl.c -> fs/ocfs2/acl.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "241:  case ACL_TYPE_ACCESS:",
      "242:   name_index = OCFS2_XATTR_INDEX_POSIX_ACL_ACCESS;",
      "243:   if (acl) {",
      "252:    ret = ocfs2_acl_set_mode(inode, di_bh,",
      "253:        handle, mode);",
      "",
      "[Removed Lines]",
      "244:    umode_t mode = inode->i_mode;",
      "245:    ret = posix_acl_equiv_mode(acl, &mode);",
      "246:    if (ret < 0)",
      "247:     return ret;",
      "249:    if (ret == 0)",
      "250:     acl = NULL;",
      "",
      "[Added Lines]",
      "244:    umode_t mode;",
      "246:    ret = posix_acl_update_mode(inode, &mode, &acl);",
      "247:    if (ret)",
      "248:     return ret;",
      "",
      "---------------"
    ],
    "fs/orangefs/acl.c||fs/orangefs/acl.c": [
      "File: fs/orangefs/acl.c -> fs/orangefs/acl.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "73:  case ACL_TYPE_ACCESS:",
      "74:   name = XATTR_NAME_POSIX_ACL_ACCESS;",
      "75:   if (acl) {",
      "84:         __func__,",
      "85:         error);",
      "86:     return error;",
      "",
      "[Removed Lines]",
      "76:    umode_t mode = inode->i_mode;",
      "81:    error = posix_acl_equiv_mode(acl, &mode);",
      "82:    if (error < 0) {",
      "83:     gossip_err(\"%s: posix_acl_equiv_mode err: %d\\n\",",
      "",
      "[Added Lines]",
      "76:    umode_t mode;",
      "78:    error = posix_acl_update_mode(inode, &mode, &acl);",
      "79:    if (error) {",
      "80:     gossip_err(\"%s: posix_acl_update_mode err: %d\\n\",",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "90:     SetModeFlag(orangefs_inode);",
      "91:    inode->i_mode = mode;",
      "92:    mark_inode_dirty_sync(inode);",
      "95:   }",
      "96:   break;",
      "97:  case ACL_TYPE_DEFAULT:",
      "",
      "[Removed Lines]",
      "93:    if (error == 0)",
      "94:     acl = NULL;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "fs/posix_acl.c||fs/posix_acl.c": [
      "File: fs/posix_acl.c -> fs/posix_acl.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "626: }",
      "627: EXPORT_SYMBOL_GPL(posix_acl_create);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "641: int posix_acl_update_mode(struct inode *inode, umode_t *mode_p,",
      "642:      struct posix_acl **acl)",
      "643: {",
      "644:  umode_t mode = inode->i_mode;",
      "645:  int error;",
      "647:  error = posix_acl_equiv_mode(*acl, &mode);",
      "648:  if (error < 0)",
      "649:   return error;",
      "650:  if (error == 0)",
      "652:  if (!in_group_p(inode->i_gid) &&",
      "653:      !capable_wrt_inode_uidgid(inode, CAP_FSETID))",
      "654:   mode &= ~S_ISGID;",
      "656:  return 0;",
      "657: }",
      "658: EXPORT_SYMBOL(posix_acl_update_mode);",
      "",
      "---------------"
    ],
    "fs/reiserfs/xattr_acl.c||fs/reiserfs/xattr_acl.c": [
      "File: fs/reiserfs/xattr_acl.c -> fs/reiserfs/xattr_acl.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "242:  case ACL_TYPE_ACCESS:",
      "243:   name = XATTR_NAME_POSIX_ACL_ACCESS;",
      "244:   if (acl) {",
      "247:     return error;",
      "252:   }",
      "253:   break;",
      "254:  case ACL_TYPE_DEFAULT:",
      "",
      "[Removed Lines]",
      "245:    error = posix_acl_equiv_mode(acl, &inode->i_mode);",
      "246:    if (error < 0)",
      "248:    else {",
      "249:     if (error == 0)",
      "250:      acl = NULL;",
      "251:    }",
      "",
      "[Added Lines]",
      "245:    error = posix_acl_update_mode(inode, &inode->i_mode, &acl);",
      "246:    if (error)",
      "",
      "---------------"
    ],
    "fs/xfs/xfs_acl.c||fs/xfs/xfs_acl.c": [
      "File: fs/xfs/xfs_acl.c -> fs/xfs/xfs_acl.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "257:   return error;",
      "259:  if (type == ACL_TYPE_ACCESS) {",
      "270:   error = xfs_set_mode(inode, mode);",
      "271:   if (error)",
      "272:    return error;",
      "",
      "[Removed Lines]",
      "260:   umode_t mode = inode->i_mode;",
      "261:   error = posix_acl_equiv_mode(acl, &mode);",
      "263:   if (error <= 0) {",
      "264:    acl = NULL;",
      "266:    if (error < 0)",
      "267:     return error;",
      "268:   }",
      "",
      "[Added Lines]",
      "260:   umode_t mode;",
      "262:   error = posix_acl_update_mode(inode, &mode, &acl);",
      "263:   if (error)",
      "264:    return error;",
      "",
      "---------------"
    ],
    "include/linux/posix_acl.h||include/linux/posix_acl.h": [
      "File: include/linux/posix_acl.h -> include/linux/posix_acl.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "93: extern int posix_acl_chmod(struct inode *, umode_t);",
      "94: extern int posix_acl_create(struct inode *, umode_t *, struct posix_acl **,",
      "95:   struct posix_acl **);",
      "97: extern int simple_set_acl(struct inode *, struct posix_acl *, int);",
      "98: extern int simple_acl_create(struct inode *, struct inode *);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "96: extern int posix_acl_update_mode(struct inode *, umode_t *, struct posix_acl **);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "eeca7ea1baa939c97d58ba821f8c6e683e4388f2",
      "candidate_info": {
        "commit_hash": "eeca7ea1baa939c97d58ba821f8c6e683e4388f2",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/eeca7ea1baa939c97d58ba821f8c6e683e4388f2",
        "files": [
          "fs/ext4/acl.c",
          "fs/ext4/ext4.h",
          "fs/ext4/extents.c",
          "fs/ext4/ialloc.c",
          "fs/ext4/inline.c",
          "fs/ext4/inode.c",
          "fs/ext4/ioctl.c",
          "fs/ext4/namei.c",
          "fs/ext4/super.c",
          "fs/ext4/xattr.c"
        ],
        "message": "ext4: use current_time() for inode timestamps\n\nCURRENT_TIME_SEC and CURRENT_TIME are not y2038 safe.\ncurrent_time() will be transitioned to be y2038 safe\nalong with vfs.\n\ncurrent_time() returns timestamps according to the\ngranularities set in the super_block.\nThe granularity check in ext4_current_time() to call\ncurrent_time() or CURRENT_TIME_SEC is not required.\nUse current_time() directly to obtain timestamps\nunconditionally, and remove ext4_current_time().\n\nQuota files are assumed to be on the same filesystem.\nHence, use current_time() for these files as well.\n\nSigned-off-by: Deepa Dinamani <deepa.kernel@gmail.com>\nSigned-off-by: Theodore Ts'o <tytso@mit.edu>\nReviewed-by: Arnd Bergmann <arnd@arndb.de>",
        "before_after_code_files": [
          "fs/ext4/acl.c||fs/ext4/acl.c",
          "fs/ext4/ext4.h||fs/ext4/ext4.h",
          "fs/ext4/extents.c||fs/ext4/extents.c",
          "fs/ext4/ialloc.c||fs/ext4/ialloc.c",
          "fs/ext4/inline.c||fs/ext4/inline.c",
          "fs/ext4/inode.c||fs/ext4/inode.c",
          "fs/ext4/ioctl.c||fs/ext4/ioctl.c",
          "fs/ext4/namei.c||fs/ext4/namei.c",
          "fs/ext4/super.c||fs/ext4/super.c",
          "fs/ext4/xattr.c||fs/ext4/xattr.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/ext4/acl.c||fs/ext4/acl.c"
          ],
          "candidate": [
            "fs/ext4/acl.c||fs/ext4/acl.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/ext4/acl.c||fs/ext4/acl.c": [
          "File: fs/ext4/acl.c -> fs/ext4/acl.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "196:    error = posix_acl_update_mode(inode, &inode->i_mode, &acl);",
          "197:    if (error)",
          "198:     return error;",
          "200:    ext4_mark_inode_dirty(handle, inode);",
          "201:   }",
          "202:   break;",
          "",
          "[Removed Lines]",
          "199:    inode->i_ctime = ext4_current_time(inode);",
          "",
          "[Added Lines]",
          "199:    inode->i_ctime = current_time(inode);",
          "",
          "---------------"
        ],
        "fs/ext4/ext4.h||fs/ext4/ext4.h": [
          "File: fs/ext4/ext4.h -> fs/ext4/ext4.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "1532:  return container_of(inode, struct ext4_inode_info, vfs_inode);",
          "1533: }",
          "1541: static inline int ext4_valid_inum(struct super_block *sb, unsigned long ino)",
          "1542: {",
          "1543:  return ino == EXT4_ROOT_INO ||",
          "",
          "[Removed Lines]",
          "1535: static inline struct timespec ext4_current_time(struct inode *inode)",
          "1536: {",
          "1537:  return (inode->i_sb->s_time_gran < NSEC_PER_SEC) ?",
          "1538:   current_fs_time(inode->i_sb) : CURRENT_TIME_SEC;",
          "1539: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "fs/ext4/extents.c||fs/ext4/extents.c": [
          "File: fs/ext4/extents.c -> fs/ext4/extents.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4724:   map.m_lblk += ret;",
          "4725:   map.m_len = len = len - ret;",
          "4726:   epos = (loff_t)map.m_lblk << inode->i_blkbits;",
          "4728:   if (new_size) {",
          "4729:    if (epos > new_size)",
          "4730:     epos = new_size;",
          "",
          "[Removed Lines]",
          "4727:   inode->i_ctime = ext4_current_time(inode);",
          "",
          "[Added Lines]",
          "4727:   inode->i_ctime = current_time(inode);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "4852:   }",
          "4854:   truncate_pagecache_range(inode, start, end - 1);",
          "4857:   ret = ext4_alloc_file_blocks(file, lblk, max_blocks, new_size,",
          "4858:           flags, mode);",
          "",
          "[Removed Lines]",
          "4855:   inode->i_mtime = inode->i_ctime = ext4_current_time(inode);",
          "",
          "[Added Lines]",
          "4855:   inode->i_mtime = inode->i_ctime = current_time(inode);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "4877:   goto out_dio;",
          "4878:  }",
          "4881:  if (new_size) {",
          "4882:   ext4_update_inode_size(inode, new_size);",
          "4883:  } else {",
          "",
          "[Removed Lines]",
          "4880:  inode->i_mtime = inode->i_ctime = ext4_current_time(inode);",
          "",
          "[Added Lines]",
          "4880:  inode->i_mtime = inode->i_ctime = current_time(inode);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "5567:  up_write(&EXT4_I(inode)->i_data_sem);",
          "5568:  if (IS_SYNC(inode))",
          "5569:   ext4_handle_sync(handle);",
          "5571:  ext4_mark_inode_dirty(handle, inode);",
          "5573: out_stop:",
          "",
          "[Removed Lines]",
          "5570:  inode->i_mtime = inode->i_ctime = ext4_current_time(inode);",
          "",
          "[Added Lines]",
          "5570:  inode->i_mtime = inode->i_ctime = current_time(inode);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "5678:  inode->i_size += len;",
          "5679:  EXT4_I(inode)->i_disksize += len;",
          "5681:  ret = ext4_mark_inode_dirty(handle, inode);",
          "5682:  if (ret)",
          "5683:   goto out_stop;",
          "",
          "[Removed Lines]",
          "5680:  inode->i_mtime = inode->i_ctime = ext4_current_time(inode);",
          "",
          "[Added Lines]",
          "5680:  inode->i_mtime = inode->i_ctime = current_time(inode);",
          "",
          "---------------"
        ],
        "fs/ext4/ialloc.c||fs/ext4/ialloc.c": [
          "File: fs/ext4/ialloc.c -> fs/ext4/ialloc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1040:  inode->i_blocks = 0;",
          "1041:  inode->i_mtime = inode->i_atime = inode->i_ctime = ei->i_crtime =",
          "1044:  memset(ei->i_data, 0, sizeof(ei->i_data));",
          "1045:  ei->i_dir_start_lookup = 0;",
          "",
          "[Removed Lines]",
          "1042:              ext4_current_time(inode);",
          "",
          "[Added Lines]",
          "1042:              current_time(inode);",
          "",
          "---------------"
        ],
        "fs/ext4/inline.c||fs/ext4/inline.c": [
          "File: fs/ext4/inline.c -> fs/ext4/inline.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1032:  ext4_update_dx_flag(dir);",
          "1033:  dir->i_version++;",
          "1034:  ext4_mark_inode_dirty(handle, dir);",
          "",
          "[Removed Lines]",
          "1031:  dir->i_mtime = dir->i_ctime = ext4_current_time(dir);",
          "",
          "[Added Lines]",
          "1031:  dir->i_mtime = dir->i_ctime = current_time(dir);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1971:  if (inode->i_nlink)",
          "1972:   ext4_orphan_del(handle, inode);",
          "1975:  ext4_mark_inode_dirty(handle, inode);",
          "1976:  if (IS_SYNC(inode))",
          "1977:   ext4_handle_sync(handle);",
          "",
          "[Removed Lines]",
          "1974:  inode->i_mtime = inode->i_ctime = ext4_current_time(inode);",
          "",
          "[Added Lines]",
          "1974:  inode->i_mtime = inode->i_ctime = current_time(inode);",
          "",
          "---------------"
        ],
        "fs/ext4/inode.c||fs/ext4/inode.c": [
          "File: fs/ext4/inode.c -> fs/ext4/inode.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4039:  if (IS_SYNC(inode))",
          "4040:   ext4_handle_sync(handle);",
          "4043:  ext4_mark_inode_dirty(handle, inode);",
          "4044: out_stop:",
          "4045:  ext4_journal_stop(handle);",
          "",
          "[Removed Lines]",
          "4042:  inode->i_mtime = inode->i_ctime = ext4_current_time(inode);",
          "",
          "[Added Lines]",
          "4042:  inode->i_mtime = inode->i_ctime = current_time(inode);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "4195:  if (inode->i_nlink)",
          "4196:   ext4_orphan_del(handle, inode);",
          "4199:  ext4_mark_inode_dirty(handle, inode);",
          "4200:  ext4_journal_stop(handle);",
          "",
          "[Removed Lines]",
          "4198:  inode->i_mtime = inode->i_ctime = ext4_current_time(inode);",
          "",
          "[Added Lines]",
          "4198:  inode->i_mtime = inode->i_ctime = current_time(inode);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "5172:    if (!shrink) {",
          "5174:     inode->i_ctime = inode->i_mtime;",
          "5175:    }",
          "5176:    down_write(&EXT4_I(inode)->i_data_sem);",
          "",
          "[Removed Lines]",
          "5173:     inode->i_mtime = ext4_current_time(inode);",
          "",
          "[Added Lines]",
          "5173:     inode->i_mtime = current_time(inode);",
          "",
          "---------------"
        ],
        "fs/ext4/ioctl.c||fs/ext4/ioctl.c": [
          "File: fs/ext4/ioctl.c -> fs/ext4/ioctl.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "154:  swap_inode_data(inode, inode_bl);",
          "158:  spin_lock(&sbi->s_next_gen_lock);",
          "159:  inode->i_generation = sbi->s_next_generation++;",
          "",
          "[Removed Lines]",
          "156:  inode->i_ctime = inode_bl->i_ctime = ext4_current_time(inode);",
          "",
          "[Added Lines]",
          "156:  inode->i_ctime = inode_bl->i_ctime = current_time(inode);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "275:  }",
          "277:  ext4_set_inode_flags(inode);",
          "280:  err = ext4_mark_iloc_dirty(handle, inode, &iloc);",
          "281: flags_err:",
          "",
          "[Removed Lines]",
          "278:  inode->i_ctime = ext4_current_time(inode);",
          "",
          "[Added Lines]",
          "278:  inode->i_ctime = current_time(inode);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "371:  }",
          "373:  EXT4_I(inode)->i_projid = kprojid;",
          "375: out_dirty:",
          "376:  rc = ext4_mark_iloc_dirty(handle, inode, &iloc);",
          "377:  if (!err)",
          "",
          "[Removed Lines]",
          "374:  inode->i_ctime = ext4_current_time(inode);",
          "",
          "[Added Lines]",
          "374:  inode->i_ctime = current_time(inode);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "503:   }",
          "504:   err = ext4_reserve_inode_write(handle, inode, &iloc);",
          "505:   if (err == 0) {",
          "507:    inode->i_generation = generation;",
          "508:    err = ext4_mark_iloc_dirty(handle, inode, &iloc);",
          "509:   }",
          "",
          "[Removed Lines]",
          "506:    inode->i_ctime = ext4_current_time(inode);",
          "",
          "[Added Lines]",
          "506:    inode->i_ctime = current_time(inode);",
          "",
          "---------------"
        ],
        "fs/ext4/namei.c||fs/ext4/namei.c": [
          "File: fs/ext4/namei.c -> fs/ext4/namei.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1945:  ext4_update_dx_flag(dir);",
          "1946:  dir->i_version++;",
          "1947:  ext4_mark_inode_dirty(handle, dir);",
          "",
          "[Removed Lines]",
          "1944:  dir->i_mtime = dir->i_ctime = ext4_current_time(dir);",
          "",
          "[Added Lines]",
          "1944:  dir->i_mtime = dir->i_ctime = current_time(dir);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2988:  inode->i_size = 0;",
          "2989:  ext4_orphan_add(handle, inode);",
          "2991:  ext4_mark_inode_dirty(handle, inode);",
          "2992:  ext4_dec_count(handle, dir);",
          "2993:  ext4_update_dx_flag(dir);",
          "",
          "[Removed Lines]",
          "2990:  inode->i_ctime = dir->i_ctime = dir->i_mtime = ext4_current_time(inode);",
          "",
          "[Added Lines]",
          "2990:  inode->i_ctime = dir->i_ctime = dir->i_mtime = current_time(inode);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3050:  retval = ext4_delete_entry(handle, dir, de, bh);",
          "3051:  if (retval)",
          "3052:   goto end_unlink;",
          "3054:  ext4_update_dx_flag(dir);",
          "3055:  ext4_mark_inode_dirty(handle, dir);",
          "3056:  drop_nlink(inode);",
          "3057:  if (!inode->i_nlink)",
          "3058:   ext4_orphan_add(handle, inode);",
          "3060:  ext4_mark_inode_dirty(handle, inode);",
          "3062: end_unlink:",
          "",
          "[Removed Lines]",
          "3053:  dir->i_ctime = dir->i_mtime = ext4_current_time(dir);",
          "3059:  inode->i_ctime = ext4_current_time(inode);",
          "",
          "[Added Lines]",
          "3053:  dir->i_ctime = dir->i_mtime = current_time(dir);",
          "3059:  inode->i_ctime = current_time(inode);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "3254:  if (IS_DIRSYNC(dir))",
          "3255:   ext4_handle_sync(handle);",
          "3258:  ext4_inc_count(handle, inode);",
          "3259:  ihold(inode);",
          "",
          "[Removed Lines]",
          "3257:  inode->i_ctime = ext4_current_time(inode);",
          "",
          "[Added Lines]",
          "3257:  inode->i_ctime = current_time(inode);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "3381:   ent->de->file_type = file_type;",
          "3382:  ent->dir->i_version++;",
          "3383:  ent->dir->i_ctime = ent->dir->i_mtime =",
          "3385:  ext4_mark_inode_dirty(handle, ent->dir);",
          "3386:  BUFFER_TRACE(ent->bh, \"call ext4_handle_dirty_metadata\");",
          "3387:  if (!ent->inlined) {",
          "",
          "[Removed Lines]",
          "3384:   ext4_current_time(ent->dir);",
          "",
          "[Added Lines]",
          "3384:   current_time(ent->dir);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "3655:  ext4_mark_inode_dirty(handle, old.inode);",
          "3657:  if (!whiteout) {",
          "",
          "[Removed Lines]",
          "3654:  old.inode->i_ctime = ext4_current_time(old.inode);",
          "",
          "[Added Lines]",
          "3654:  old.inode->i_ctime = current_time(old.inode);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "3664:  if (new.inode) {",
          "3665:   ext4_dec_count(handle, new.inode);",
          "3667:  }",
          "3669:  ext4_update_dx_flag(old.dir);",
          "3670:  if (old.dir_bh) {",
          "3671:   retval = ext4_rename_dir_finish(handle, &old, new.dir->i_ino);",
          "",
          "[Removed Lines]",
          "3666:   new.inode->i_ctime = ext4_current_time(new.inode);",
          "3668:  old.dir->i_ctime = old.dir->i_mtime = ext4_current_time(old.dir);",
          "",
          "[Added Lines]",
          "3666:   new.inode->i_ctime = current_time(new.inode);",
          "3668:  old.dir->i_ctime = old.dir->i_mtime = current_time(old.dir);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "3723:  };",
          "3724:  u8 new_file_type;",
          "3725:  int retval;",
          "3727:  if ((ext4_encrypted_inode(old_dir) ||",
          "3728:       ext4_encrypted_inode(new_dir)) &&",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3726:  struct timespec ctime;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "3828:  ext4_mark_inode_dirty(handle, old.inode);",
          "3829:  ext4_mark_inode_dirty(handle, new.inode);",
          "",
          "[Removed Lines]",
          "3826:  old.inode->i_ctime = ext4_current_time(old.inode);",
          "3827:  new.inode->i_ctime = ext4_current_time(new.inode);",
          "",
          "[Added Lines]",
          "3827:  ctime = current_time(old.inode);",
          "3828:  old.inode->i_ctime = ctime;",
          "3829:  new.inode->i_ctime = ctime;",
          "",
          "---------------"
        ],
        "fs/ext4/super.c||fs/ext4/super.c": [
          "File: fs/ext4/super.c -> fs/ext4/super.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "5354:  handle = ext4_journal_start(inode, EXT4_HT_QUOTA, 1);",
          "5355:  if (IS_ERR(handle))",
          "5356:   goto out;",
          "5358:  ext4_mark_inode_dirty(handle, inode);",
          "5359:  ext4_journal_stop(handle);",
          "",
          "[Removed Lines]",
          "5357:  inode->i_mtime = inode->i_ctime = CURRENT_TIME;",
          "",
          "[Added Lines]",
          "5357:  inode->i_mtime = inode->i_ctime = current_time(inode);",
          "",
          "---------------"
        ],
        "fs/ext4/xattr.c||fs/ext4/xattr.c": [
          "File: fs/ext4/xattr.c -> fs/ext4/xattr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1249:  }",
          "1250:  if (!error) {",
          "1251:   ext4_xattr_update_super_block(handle, inode->i_sb);",
          "1253:   if (!value)",
          "1254:    ext4_clear_inode_state(inode, EXT4_STATE_NO_EXPAND);",
          "1255:   error = ext4_mark_iloc_dirty(handle, inode, &is.iloc);",
          "",
          "[Removed Lines]",
          "1252:   inode->i_ctime = ext4_current_time(inode);",
          "",
          "[Added Lines]",
          "1252:   inode->i_ctime = current_time(inode);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "8bb8aefd5afb54a25a002feb4ec70011812d06a0",
      "candidate_info": {
        "commit_hash": "8bb8aefd5afb54a25a002feb4ec70011812d06a0",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/8bb8aefd5afb54a25a002feb4ec70011812d06a0",
        "files": [
          "fs/orangefs/acl.c",
          "fs/orangefs/dcache.c",
          "fs/orangefs/devpvfs2-req.c",
          "fs/orangefs/dir.c",
          "fs/orangefs/downcall.h",
          "fs/orangefs/file.c",
          "fs/orangefs/inode.c",
          "fs/orangefs/namei.c",
          "fs/orangefs/protocol.h",
          "fs/orangefs/pvfs2-bufmap.c",
          "fs/orangefs/pvfs2-bufmap.h",
          "fs/orangefs/pvfs2-cache.c",
          "fs/orangefs/pvfs2-debug.h",
          "fs/orangefs/pvfs2-debugfs.c",
          "fs/orangefs/pvfs2-debugfs.h",
          "fs/orangefs/pvfs2-dev-proto.h",
          "fs/orangefs/pvfs2-kernel.h",
          "fs/orangefs/pvfs2-mod.c",
          "fs/orangefs/pvfs2-sysfs.c",
          "fs/orangefs/pvfs2-utils.c",
          "fs/orangefs/super.c",
          "fs/orangefs/symlink.c",
          "fs/orangefs/upcall.h",
          "fs/orangefs/waitqueue.c",
          "fs/orangefs/xattr.c"
        ],
        "message": "OrangeFS: Change almost all instances of the string PVFS2 to OrangeFS.\n\nOrangeFS was formerly known as PVFS2 and retains the name in many places.\n\nI leave the device /dev/pvfs2-req since this affects userspace.\n\nI leave the filesystem type pvfs2 since this affects userspace. Further\nthe OrangeFS sysint library reads fstab for an entry of type pvfs2\nindependently of kernel mounts.\n\nI leave extended attribute keys user.pvfs2 and system.pvfs2 as the\nsysint library understands these.\n\nI leave references to userspace binaries still named pvfs2.\n\nI leave the filenames.\n\nSigned-off-by: Yi Liu <yi9@clemson.edu>\n[martin@omnibond.com: clairify above constraints and merge]\nSigned-off-by: Martin Brandenburg <martin@omnibond.com>\nSigned-off-by: Mike Marshall <hubcap@omnibond.com>",
        "before_after_code_files": [
          "fs/orangefs/acl.c||fs/orangefs/acl.c",
          "fs/orangefs/dcache.c||fs/orangefs/dcache.c",
          "fs/orangefs/devpvfs2-req.c||fs/orangefs/devpvfs2-req.c",
          "fs/orangefs/dir.c||fs/orangefs/dir.c",
          "fs/orangefs/downcall.h||fs/orangefs/downcall.h",
          "fs/orangefs/file.c||fs/orangefs/file.c",
          "fs/orangefs/inode.c||fs/orangefs/inode.c",
          "fs/orangefs/namei.c||fs/orangefs/namei.c",
          "fs/orangefs/protocol.h||fs/orangefs/protocol.h",
          "fs/orangefs/pvfs2-bufmap.c||fs/orangefs/pvfs2-bufmap.c",
          "fs/orangefs/pvfs2-bufmap.h||fs/orangefs/pvfs2-bufmap.h",
          "fs/orangefs/pvfs2-cache.c||fs/orangefs/pvfs2-cache.c",
          "fs/orangefs/pvfs2-debug.h||fs/orangefs/pvfs2-debug.h",
          "fs/orangefs/pvfs2-debugfs.c||fs/orangefs/pvfs2-debugfs.c",
          "fs/orangefs/pvfs2-debugfs.h||fs/orangefs/pvfs2-debugfs.h",
          "fs/orangefs/pvfs2-dev-proto.h||fs/orangefs/pvfs2-dev-proto.h",
          "fs/orangefs/pvfs2-kernel.h||fs/orangefs/pvfs2-kernel.h",
          "fs/orangefs/pvfs2-mod.c||fs/orangefs/pvfs2-mod.c",
          "fs/orangefs/pvfs2-sysfs.c||fs/orangefs/pvfs2-sysfs.c",
          "fs/orangefs/pvfs2-utils.c||fs/orangefs/pvfs2-utils.c",
          "fs/orangefs/super.c||fs/orangefs/super.c",
          "fs/orangefs/symlink.c||fs/orangefs/symlink.c",
          "fs/orangefs/upcall.h||fs/orangefs/upcall.h",
          "fs/orangefs/waitqueue.c||fs/orangefs/waitqueue.c",
          "fs/orangefs/xattr.c||fs/orangefs/xattr.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/orangefs/acl.c||fs/orangefs/acl.c"
          ],
          "candidate": [
            "fs/orangefs/acl.c||fs/orangefs/acl.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/orangefs/acl.c||fs/orangefs/acl.c": [
          "File: fs/orangefs/acl.c -> fs/orangefs/acl.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "10: #include <linux/posix_acl_xattr.h>",
          "11: #include <linux/fs_struct.h>",
          "14: {",
          "15:  struct posix_acl *acl;",
          "16:  int ret;",
          "",
          "[Removed Lines]",
          "13: struct posix_acl *pvfs2_get_acl(struct inode *inode, int type)",
          "",
          "[Added Lines]",
          "13: struct posix_acl *orangefs_get_acl(struct inode *inode, int type)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "19:  switch (type) {",
          "20:  case ACL_TYPE_ACCESS:",
          "22:   break;",
          "23:  case ACL_TYPE_DEFAULT:",
          "25:   break;",
          "26:  default:",
          "28:   return ERR_PTR(-EINVAL);",
          "29:  }",
          "38:  if (value == NULL)",
          "39:   return ERR_PTR(-ENOMEM);",
          "",
          "[Removed Lines]",
          "21:   key = PVFS2_XATTR_NAME_ACL_ACCESS;",
          "24:   key = PVFS2_XATTR_NAME_ACL_DEFAULT;",
          "27:   gossip_err(\"pvfs2_get_acl: bogus value of type %d\\n\", type);",
          "37:  value = kmalloc(PVFS_MAX_XATTR_VALUELEN, GFP_KERNEL);",
          "",
          "[Added Lines]",
          "21:   key = ORANGEFS_XATTR_NAME_ACL_ACCESS;",
          "24:   key = ORANGEFS_XATTR_NAME_ACL_DEFAULT;",
          "27:   gossip_err(\"orangefs_get_acl: bogus value of type %d\\n\", type);",
          "37:  value = kmalloc(ORANGEFS_MAX_XATTR_VALUELEN, GFP_KERNEL);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "43:        get_khandle_from_ino(inode),",
          "44:        key,",
          "45:        type);",
          "47:        \"\",",
          "48:        key,",
          "49:        value,",
          "52:  if (ret > 0) {",
          "53:   acl = posix_acl_from_xattr(&init_user_ns, value, ret);",
          "",
          "[Removed Lines]",
          "46:  ret = pvfs2_inode_getxattr(inode,",
          "50:        PVFS_MAX_XATTR_VALUELEN);",
          "",
          "[Added Lines]",
          "46:  ret = orangefs_inode_getxattr(inode,",
          "50:        ORANGEFS_MAX_XATTR_VALUELEN);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "64:  return acl;",
          "65: }",
          "68: {",
          "70:  int error = 0;",
          "71:  void *value = NULL;",
          "72:  size_t size = 0;",
          "",
          "[Removed Lines]",
          "67: int pvfs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)",
          "69:  struct pvfs2_inode_s *pvfs2_inode = PVFS2_I(inode);",
          "",
          "[Added Lines]",
          "67: int orangefs_set_acl(struct inode *inode, struct posix_acl *acl, int type)",
          "69:  struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "75:  switch (type) {",
          "76:  case ACL_TYPE_ACCESS:",
          "78:   if (acl) {",
          "79:    umode_t mode = inode->i_mode;",
          "",
          "[Removed Lines]",
          "77:   name = PVFS2_XATTR_NAME_ACL_ACCESS;",
          "",
          "[Added Lines]",
          "77:   name = ORANGEFS_XATTR_NAME_ACL_ACCESS;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "90:    }",
          "92:    if (inode->i_mode != mode)",
          "94:    inode->i_mode = mode;",
          "95:    mark_inode_dirty_sync(inode);",
          "96:    if (error == 0)",
          "",
          "[Removed Lines]",
          "93:     SetModeFlag(pvfs2_inode);",
          "",
          "[Added Lines]",
          "93:     SetModeFlag(orangefs_inode);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "98:   }",
          "99:   break;",
          "100:  case ACL_TYPE_DEFAULT:",
          "102:   break;",
          "103:  default:",
          "104:   gossip_err(\"%s: invalid type %d!\\n\", __func__, type);",
          "",
          "[Removed Lines]",
          "101:   name = PVFS2_XATTR_NAME_ACL_DEFAULT;",
          "",
          "[Added Lines]",
          "101:   name = ORANGEFS_XATTR_NAME_ACL_DEFAULT;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "136: out:",
          "137:  kfree(value);",
          "",
          "[Removed Lines]",
          "134:  error = pvfs2_inode_setxattr(inode, \"\", name, value, size, 0);",
          "",
          "[Added Lines]",
          "134:  error = orangefs_inode_setxattr(inode, \"\", name, value, size, 0);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "140:  return error;",
          "141: }",
          "144: {",
          "146:  struct posix_acl *default_acl, *acl;",
          "147:  umode_t mode = inode->i_mode;",
          "148:  int error = 0;",
          "152:  error = posix_acl_create(dir, &mode, &default_acl, &acl);",
          "153:  if (error)",
          "154:   return error;",
          "156:  if (default_acl) {",
          "158:   posix_acl_release(default_acl);",
          "159:  }",
          "161:  if (acl) {",
          "162:   if (!error)",
          "164:   posix_acl_release(acl);",
          "165:  }",
          "168:  if (mode != inode->i_mode) {",
          "170:   inode->i_mode = mode;",
          "172:  }",
          "174:  return error;",
          "",
          "[Removed Lines]",
          "143: int pvfs2_init_acl(struct inode *inode, struct inode *dir)",
          "145:  struct pvfs2_inode_s *pvfs2_inode = PVFS2_I(inode);",
          "150:  ClearModeFlag(pvfs2_inode);",
          "157:   error = pvfs2_set_acl(inode, default_acl, ACL_TYPE_DEFAULT);",
          "163:    error = pvfs2_set_acl(inode, acl, ACL_TYPE_ACCESS);",
          "169:   SetModeFlag(pvfs2_inode);",
          "171:   pvfs2_flush_inode(inode);",
          "",
          "[Added Lines]",
          "143: int orangefs_init_acl(struct inode *inode, struct inode *dir)",
          "145:  struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);",
          "150:  ClearModeFlag(orangefs_inode);",
          "157:   error = orangefs_set_acl(inode, default_acl, ACL_TYPE_DEFAULT);",
          "163:    error = orangefs_set_acl(inode, acl, ACL_TYPE_ACCESS);",
          "169:   SetModeFlag(orangefs_inode);",
          "171:   orangefs_flush_inode(inode);",
          "",
          "---------------"
        ],
        "fs/orangefs/dcache.c||fs/orangefs/dcache.c": [
          "File: fs/orangefs/dcache.c -> fs/orangefs/dcache.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "12: #include \"pvfs2-kernel.h\"",
          "16: {",
          "17:  struct dentry *parent_dentry = dget_parent(dentry);",
          "18:  struct inode *parent_inode = parent_dentry->d_inode;",
          "20:  struct inode *inode = dentry->d_inode;",
          "22:  int ret = 0;",
          "23:  int err = 0;",
          "25:  gossip_debug(GOSSIP_DCACHE_DEBUG, \"%s: attempting lookup.\\n\", __func__);",
          "28:  if (!new_op)",
          "29:   goto out_put_parent;",
          "32:  new_op->upcall.req.lookup.parent_refn = parent->refn;",
          "33:  strncpy(new_op->upcall.req.lookup.d_name,",
          "34:   dentry->d_name.name,",
          "37:  gossip_debug(GOSSIP_DCACHE_DEBUG,",
          "38:        \"%s:%s:%d interrupt flag [%d]\\n\",",
          "",
          "[Removed Lines]",
          "15: static int pvfs2_revalidate_lookup(struct dentry *dentry)",
          "19:  struct pvfs2_inode_s *parent = PVFS2_I(parent_inode);",
          "21:  struct pvfs2_kernel_op_s *new_op;",
          "27:  new_op = op_alloc(PVFS2_VFS_OP_LOOKUP);",
          "31:  new_op->upcall.req.lookup.sym_follow = PVFS2_LOOKUP_LINK_NO_FOLLOW;",
          "35:   PVFS2_NAME_LEN);",
          "",
          "[Added Lines]",
          "15: static int orangefs_revalidate_lookup(struct dentry *dentry)",
          "19:  struct orangefs_inode_s *parent = ORANGEFS_I(parent_inode);",
          "21:  struct orangefs_kernel_op_s *new_op;",
          "27:  new_op = op_alloc(ORANGEFS_VFS_OP_LOOKUP);",
          "31:  new_op->upcall.req.lookup.sym_follow = ORANGEFS_LOOKUP_LINK_NO_FOLLOW;",
          "35:   ORANGEFS_NAME_LEN);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "41:        __LINE__,",
          "42:        get_interruptible_flag(parent_inode));",
          "45:    get_interruptible_flag(parent_inode));",
          "46:  if (err)",
          "47:   goto out_drop;",
          "",
          "[Removed Lines]",
          "44:  err = service_operation(new_op, \"pvfs2_lookup\",",
          "",
          "[Added Lines]",
          "44:  err = service_operation(new_op, \"orangefs_lookup\",",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "83: {",
          "84:  struct inode *inode;",
          "85:  int ret = 0;",
          "",
          "[Removed Lines]",
          "82: static int pvfs2_d_revalidate(struct dentry *dentry, unsigned int flags)",
          "",
          "[Added Lines]",
          "82: static int orangefs_d_revalidate(struct dentry *dentry, unsigned int flags)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "107:  if (!is_root_handle(inode)) {",
          "109:    goto invalid_exit;",
          "110:  } else {",
          "111:   gossip_debug(GOSSIP_DCACHE_DEBUG,",
          "",
          "[Removed Lines]",
          "108:   if (!pvfs2_revalidate_lookup(dentry))",
          "",
          "[Added Lines]",
          "108:   if (!orangefs_revalidate_lookup(dentry))",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "119:        __func__,",
          "120:        inode,",
          "121:        get_khandle_from_ino(inode));",
          "123:  gossip_debug(GOSSIP_DCACHE_DEBUG,",
          "124:        \"%s: getattr %s (ret = %d), returning %s for dentry i_count=%d\\n\",",
          "125:        __func__,",
          "",
          "[Removed Lines]",
          "122:  ret = pvfs2_inode_getattr(inode, PVFS_ATTR_SYS_ALL_NOHINT);",
          "",
          "[Added Lines]",
          "122:  ret = orangefs_inode_getattr(inode, ORANGEFS_ATTR_SYS_ALL_NOHINT);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "137:  return 0;",
          "138: }",
          "142: };",
          "",
          "[Removed Lines]",
          "140: const struct dentry_operations pvfs2_dentry_operations = {",
          "141:  .d_revalidate = pvfs2_d_revalidate,",
          "",
          "[Added Lines]",
          "140: const struct dentry_operations orangefs_dentry_operations = {",
          "141:  .d_revalidate = orangefs_d_revalidate,",
          "",
          "---------------"
        ],
        "fs/orangefs/devpvfs2-req.c||fs/orangefs/devpvfs2-req.c": [
          "File: fs/orangefs/devpvfs2-req.c -> fs/orangefs/devpvfs2-req.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "22: #define DUMP_DEVICE_ERROR()                                                   \\",
          "23: do {                                                                          \\",
          "24:  gossip_err(\"*****************************************************\\n\");\\",
          "26:  gossip_err(\"\\n/dev/%s more than once.  Please make sure that\\nthere \" \\",
          "28:  gossip_err(\"instances of a program using this device\\ncurrently \"     \\",
          "29:      \"running. (You must verify this!)\\n\");                     \\",
          "30:  gossip_err(\"For example, you can use the lsof program as follows:\\n\");\\",
          "31:  gossip_err(\"'lsof | grep %s' (run this as root)\\n\",                   \\",
          "33:  gossip_err(\"  open_access_count = %d\\n\", open_access_count);          \\",
          "34:  gossip_err(\"*****************************************************\\n\");\\",
          "35: } while (0)",
          "",
          "[Removed Lines]",
          "25:  gossip_err(\"PVFS2 Device Error:  You cannot open the device file \");  \\",
          "27:      \"are no \", PVFS2_REQDEVICE_NAME);                          \\",
          "32:      PVFS2_REQDEVICE_NAME);                                     \\",
          "",
          "[Added Lines]",
          "25:  gossip_err(\"ORANGEFS Device Error:  You cannot open the device file \");  \\",
          "27:      \"are no \", ORANGEFS_REQDEVICE_NAME);                          \\",
          "32:      ORANGEFS_REQDEVICE_NAME);                                     \\",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "39:  return do_div(tag, (unsigned int)table_size);",
          "40: }",
          "43: {",
          "44:  int index = hash_func(op->tag, hash_table_size);",
          "",
          "[Removed Lines]",
          "42: static void pvfs2_devreq_add_op(struct pvfs2_kernel_op_s *op)",
          "",
          "[Added Lines]",
          "42: static void orangefs_devreq_add_op(struct orangefs_kernel_op_s *op)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "48:  spin_unlock(&htable_ops_in_progress_lock);",
          "49: }",
          "52: {",
          "54:  int index;",
          "56:  index = hash_func(tag, hash_table_size);",
          "",
          "[Removed Lines]",
          "51: static struct pvfs2_kernel_op_s *pvfs2_devreq_remove_op(__u64 tag)",
          "53:  struct pvfs2_kernel_op_s *op, *next;",
          "",
          "[Added Lines]",
          "51: static struct orangefs_kernel_op_s *orangefs_devreq_remove_op(__u64 tag)",
          "53:  struct orangefs_kernel_op_s *op, *next;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "71:  return NULL;",
          "72: }",
          "75: {",
          "76:  int ret = -EINVAL;",
          "78:  if (!(file->f_flags & O_NONBLOCK)) {",
          "80:   goto out;",
          "81:  }",
          "82:  ret = -EACCES;",
          "",
          "[Removed Lines]",
          "74: static int pvfs2_devreq_open(struct inode *inode, struct file *file)",
          "79:   gossip_err(\"pvfs2: device cannot be opened in blocking mode\\n\");",
          "",
          "[Added Lines]",
          "74: static int orangefs_devreq_open(struct inode *inode, struct file *file)",
          "79:   gossip_err(\"orangefs: device cannot be opened in blocking mode\\n\");",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "100:  return ret;",
          "101: }",
          "104:      char __user *buf,",
          "105:      size_t count, loff_t *offset)",
          "106: {",
          "111:  unsigned long ret;",
          "",
          "[Removed Lines]",
          "103: static ssize_t pvfs2_devreq_read(struct file *file,",
          "107:  struct pvfs2_kernel_op_s *op, *temp;",
          "108:  __s32 proto_ver = PVFS_KERNEL_PROTO_VERSION;",
          "109:  static __s32 magic = PVFS2_DEVREQ_MAGIC;",
          "110:  struct pvfs2_kernel_op_s *cur_op = NULL;",
          "",
          "[Added Lines]",
          "103: static ssize_t orangefs_devreq_read(struct file *file,",
          "107:  struct orangefs_kernel_op_s *op, *temp;",
          "108:  __s32 proto_ver = ORANGEFS_KERNEL_PROTO_VERSION;",
          "109:  static __s32 magic = ORANGEFS_DEVREQ_MAGIC;",
          "110:  struct orangefs_kernel_op_s *cur_op = NULL;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "126:  }",
          "131:   __s32 fsid;",
          "133:   spin_lock(&op->lock);",
          "135:   fsid = fsid_of_op(op);",
          "137:    int ret;",
          "139:    ret = fs_mount_pending(fsid);",
          "",
          "[Removed Lines]",
          "129:  spin_lock(&pvfs2_request_list_lock);",
          "130:  list_for_each_entry_safe(op, temp, &pvfs2_request_list, list) {",
          "136:   if (fsid != PVFS_FS_ID_NULL) {",
          "",
          "[Added Lines]",
          "129:  spin_lock(&orangefs_request_list_lock);",
          "130:  list_for_each_entry_safe(op, temp, &orangefs_request_list, list) {",
          "136:   if (fsid != ORANGEFS_FS_ID_NULL) {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "149:    } else if (ret == -1 &&",
          "152:     gossip_debug(GOSSIP_DEV_DEBUG,",
          "153:         \"orangefs: skipping op tag %llu %s\\n\",",
          "154:         llu(op->tag), get_opname_string(op));",
          "",
          "[Removed Lines]",
          "150:        !(op->upcall.type == PVFS2_VFS_OP_FS_MOUNT ||",
          "151:          op->upcall.type == PVFS2_VFS_OP_GETATTR)) {",
          "",
          "[Added Lines]",
          "150:        !(op->upcall.type == ORANGEFS_VFS_OP_FS_MOUNT ||",
          "151:          op->upcall.type == ORANGEFS_VFS_OP_GETATTR)) {",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "175:  if (!cur_op) {",
          "177:   return -EAGAIN;",
          "178:  }",
          "",
          "[Removed Lines]",
          "176:   spin_unlock(&pvfs2_request_list_lock);",
          "",
          "[Added Lines]",
          "176:   spin_unlock(&orangefs_request_list_lock);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "188:   gossip_err(\"orangefs: ERROR: Current op already queued.\\n\");",
          "189:   list_del(&cur_op->list);",
          "190:   spin_unlock(&cur_op->lock);",
          "192:   return -EAGAIN;",
          "193:  }",
          "",
          "[Removed Lines]",
          "191:   spin_unlock(&pvfs2_request_list_lock);",
          "",
          "[Added Lines]",
          "191:   spin_unlock(&orangefs_request_list_lock);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "199:  set_op_state_inprogress(cur_op);",
          "201:  list_del(&cur_op->list);",
          "204:  spin_unlock(&cur_op->lock);",
          "",
          "[Removed Lines]",
          "202:  spin_unlock(&pvfs2_request_list_lock);",
          "203:  pvfs2_devreq_add_op(cur_op);",
          "",
          "[Added Lines]",
          "202:  spin_unlock(&orangefs_request_list_lock);",
          "203:  orangefs_devreq_add_op(cur_op);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "214:  if (ret != 0)",
          "215:   goto error;",
          "216:  ret = copy_to_user(buf+2*sizeof(__s32)+sizeof(__u64), &cur_op->upcall,",
          "218:  if (ret != 0)",
          "219:   goto error;",
          "",
          "[Removed Lines]",
          "217:       sizeof(struct pvfs2_upcall_s));",
          "",
          "[Added Lines]",
          "217:       sizeof(struct orangefs_upcall_s));",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "229:  gossip_err(\"orangefs: Failed to copy data to user space\\n\");",
          "231:  spin_lock(&cur_op->lock);",
          "232:  set_op_state_waiting(cur_op);",
          "235:  spin_unlock(&cur_op->lock);",
          "237:  return -EFAULT;",
          "238: }",
          "242:        const struct iovec *iov,",
          "243:        size_t count,",
          "244:        loff_t *offset)",
          "245: {",
          "247:  void *buffer = NULL;",
          "248:  void *ptr = NULL;",
          "249:  unsigned long i = 0;",
          "",
          "[Removed Lines]",
          "230:  spin_lock(&pvfs2_request_list_lock);",
          "233:  pvfs2_devreq_remove_op(cur_op->tag);",
          "234:  list_add(&cur_op->list, &pvfs2_request_list);",
          "236:  spin_unlock(&pvfs2_request_list_lock);",
          "241: static ssize_t pvfs2_devreq_writev(struct file *file,",
          "246:  struct pvfs2_kernel_op_s *op = NULL;",
          "",
          "[Added Lines]",
          "230:  spin_lock(&orangefs_request_list_lock);",
          "233:  orangefs_devreq_remove_op(cur_op->tag);",
          "234:  list_add(&cur_op->list, &orangefs_request_list);",
          "236:  spin_unlock(&orangefs_request_list_lock);",
          "241: static ssize_t orangefs_devreq_writev(struct file *file,",
          "246:  struct orangefs_kernel_op_s *op = NULL;",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "301:  tag = *((__u64 *) ptr);",
          "302:  ptr += sizeof(__u64);",
          "305:   gossip_err(\"Error: Device magic number does not match.\\n\");",
          "306:   dev_req_release(buffer);",
          "307:   return -EPROTO;",
          "",
          "[Removed Lines]",
          "304:  if (magic != PVFS2_DEVREQ_MAGIC) {",
          "",
          "[Added Lines]",
          "304:  if (magic != ORANGEFS_DEVREQ_MAGIC) {",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "315:  if (op) {",
          "317:   get_op(op);",
          "319:   payload_size -= (2 * sizeof(__s32) + sizeof(__u64));",
          "322:    memcpy(&op->downcall,",
          "323:           ptr,",
          "325:   else",
          "326:    gossip_debug(GOSSIP_DEV_DEBUG,",
          "327:          \"writev: Ignoring %d bytes\\n\",",
          "",
          "[Removed Lines]",
          "314:  op = pvfs2_devreq_remove_op(tag);",
          "320:   if (payload_size <= sizeof(struct pvfs2_downcall_s))",
          "324:           sizeof(struct pvfs2_downcall_s));",
          "",
          "[Added Lines]",
          "314:  op = orangefs_devreq_remove_op(tag);",
          "320:   if (payload_size <= sizeof(struct orangefs_downcall_s))",
          "324:           sizeof(struct orangefs_downcall_s));",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "397:    int timed_out = 0;",
          "398:    DECLARE_WAITQUEUE(wait_entry, current);",
          "",
          "[Removed Lines]",
          "395:   if (op->upcall.type == PVFS2_VFS_OP_FILE_IO &&",
          "396:       op->upcall.req.io.async_vfs_io == PVFS_VFS_SYNC_IO) {",
          "",
          "[Added Lines]",
          "395:   if (op->upcall.type == ORANGEFS_VFS_OP_FILE_IO &&",
          "396:       op->upcall.req.io.async_vfs_io == ORANGEFS_VFS_SYNC_IO) {",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "473:  return total_returned_size;",
          "474: }",
          "477:           struct iov_iter *iter)",
          "478: {",
          "480:        iter->iov,",
          "481:        iter->nr_segs,",
          "482:        &iocb->ki_pos);",
          "",
          "[Removed Lines]",
          "476: static ssize_t pvfs2_devreq_write_iter(struct kiocb *iocb,",
          "479:  return pvfs2_devreq_writev(iocb->ki_filp,",
          "",
          "[Added Lines]",
          "476: static ssize_t orangefs_devreq_write_iter(struct kiocb *iocb,",
          "479:  return orangefs_devreq_writev(iocb->ki_filp,",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "486: static int mark_all_pending_mounts(void)",
          "487: {",
          "488:  int unmounted = 1;",
          "495:   unmounted = 0;",
          "496:  }",
          "498:  return unmounted;",
          "499: }",
          "",
          "[Removed Lines]",
          "489:  struct pvfs2_sb_info_s *pvfs2_sb = NULL;",
          "491:  spin_lock(&pvfs2_superblocks_lock);",
          "492:  list_for_each_entry(pvfs2_sb, &pvfs2_superblocks, list) {",
          "494:   pvfs2_sb->mount_pending = 1;",
          "497:  spin_unlock(&pvfs2_superblocks_lock);",
          "",
          "[Added Lines]",
          "489:  struct orangefs_sb_info_s *orangefs_sb = NULL;",
          "491:  spin_lock(&orangefs_superblocks_lock);",
          "492:  list_for_each_entry(orangefs_sb, &orangefs_superblocks, list) {",
          "494:   orangefs_sb->mount_pending = 1;",
          "497:  spin_unlock(&orangefs_superblocks_lock);",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "507: int fs_mount_pending(__s32 fsid)",
          "508: {",
          "509:  int mount_pending = -1;",
          "516:    break;",
          "517:   }",
          "518:  }",
          "520:  return mount_pending;",
          "521: }",
          "",
          "[Removed Lines]",
          "510:  struct pvfs2_sb_info_s *pvfs2_sb = NULL;",
          "512:  spin_lock(&pvfs2_superblocks_lock);",
          "513:  list_for_each_entry(pvfs2_sb, &pvfs2_superblocks, list) {",
          "514:   if (pvfs2_sb->fs_id == fsid) {",
          "515:    mount_pending = pvfs2_sb->mount_pending;",
          "519:  spin_unlock(&pvfs2_superblocks_lock);",
          "",
          "[Added Lines]",
          "510:  struct orangefs_sb_info_s *orangefs_sb = NULL;",
          "512:  spin_lock(&orangefs_superblocks_lock);",
          "513:  list_for_each_entry(orangefs_sb, &orangefs_superblocks, list) {",
          "514:   if (orangefs_sb->fs_id == fsid) {",
          "515:    mount_pending = orangefs_sb->mount_pending;",
          "519:  spin_unlock(&orangefs_superblocks_lock);",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "532: {",
          "533:  int unmounted = 0;",
          "",
          "[Removed Lines]",
          "531: static int pvfs2_devreq_release(struct inode *inode, struct file *file)",
          "",
          "[Added Lines]",
          "531: static int orangefs_devreq_release(struct inode *inode, struct file *file)",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "537:        __func__);",
          "539:  mutex_lock(&devreq_mutex);",
          "542:  open_access_count--;",
          "544:  unmounted = mark_all_pending_mounts();",
          "546:        (unmounted ? \"UNMOUNTED\" : \"MOUNTED\"));",
          "547:  mutex_unlock(&devreq_mutex);",
          "",
          "[Removed Lines]",
          "540:  pvfs_bufmap_finalize();",
          "545:  gossip_debug(GOSSIP_DEV_DEBUG, \"PVFS2 Device Close: Filesystem(s) %s\\n\",",
          "",
          "[Added Lines]",
          "540:  orangefs_bufmap_finalize();",
          "545:  gossip_debug(GOSSIP_DEV_DEBUG, \"ORANGEFS Device Close: Filesystem(s) %s\\n\",",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "578: static inline long check_ioctl_command(unsigned int command)",
          "579: {",
          "582:   gossip_err(\"device ioctl magic numbers don't match! Did you rebuild pvfs2-client-core/libpvfs2? [cmd %x, magic %x != %x]\\n\",",
          "583:    command,",
          "584:    _IOC_TYPE(command),",
          "586:   return -EINVAL;",
          "587:  }",
          "590:   gossip_err(\"Invalid ioctl command number [%d >= %d]\\n\",",
          "592:   return -ENOIOCTLCMD;",
          "593:  }",
          "594:  return 0;",
          "",
          "[Removed Lines]",
          "581:  if (_IOC_TYPE(command) != PVFS_DEV_MAGIC) {",
          "585:    PVFS_DEV_MAGIC);",
          "589:  if (_IOC_NR(command) >= PVFS_DEV_MAXNR || _IOC_NR(command) <= 0) {",
          "591:       _IOC_NR(command), PVFS_DEV_MAXNR);",
          "",
          "[Added Lines]",
          "581:  if (_IOC_TYPE(command) != ORANGEFS_DEV_MAGIC) {",
          "585:    ORANGEFS_DEV_MAGIC);",
          "589:  if (_IOC_NR(command) >= ORANGEFS_DEV_MAXNR || _IOC_NR(command) <= 0) {",
          "591:       _IOC_NR(command), ORANGEFS_DEV_MAXNR);",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "597: static long dispatch_ioctl_command(unsigned int command, unsigned long arg)",
          "598: {",
          "600:  static __s32 max_up_size = MAX_ALIGNED_DEV_REQ_UPSIZE;",
          "601:  static __s32 max_down_size = MAX_ALIGNED_DEV_REQ_DOWNSIZE;",
          "603:  int ret = 0;",
          "604:  struct dev_mask_info_s mask_info = { 0 };",
          "605:  struct dev_mask2_info_s mask2_info = { 0, 0 };",
          "606:  int upstream_kmod = 1;",
          "607:  struct list_head *tmp = NULL;",
          "612:  switch (command) {",
          "614:   return ((put_user(magic, (__s32 __user *) arg) == -EFAULT) ?",
          "615:    -EIO :",
          "616:    0);",
          "618:   return ((put_user(max_up_size,",
          "619:       (__s32 __user *) arg) == -EFAULT) ?",
          "620:      -EIO :",
          "621:      0);",
          "623:   return ((put_user(max_down_size,",
          "624:       (__s32 __user *) arg) == -EFAULT) ?",
          "625:      -EIO :",
          "626:      0);",
          "628:   ret = copy_from_user(&user_desc,",
          "630:          arg,",
          "634:   gossip_debug(GOSSIP_DEV_DEBUG,",
          "",
          "[Removed Lines]",
          "599:  static __s32 magic = PVFS2_DEVREQ_MAGIC;",
          "602:  struct PVFS_dev_map_desc user_desc;",
          "608:  struct pvfs2_sb_info_s *pvfs2_sb = NULL;",
          "613:  case PVFS_DEV_GET_MAGIC:",
          "617:  case PVFS_DEV_GET_MAX_UPSIZE:",
          "622:  case PVFS_DEV_GET_MAX_DOWNSIZE:",
          "627:  case PVFS_DEV_MAP:",
          "629:          (struct PVFS_dev_map_desc __user *)",
          "631:          sizeof(struct PVFS_dev_map_desc));",
          "632:   return ret ? -EIO : pvfs_bufmap_initialize(&user_desc);",
          "633:  case PVFS_DEV_REMOUNT_ALL:",
          "635:         \"pvfs2_devreq_ioctl: got PVFS_DEV_REMOUNT_ALL\\n\");",
          "",
          "[Added Lines]",
          "599:  static __s32 magic = ORANGEFS_DEVREQ_MAGIC;",
          "602:  struct ORANGEFS_dev_map_desc user_desc;",
          "608:  struct orangefs_sb_info_s *orangefs_sb = NULL;",
          "613:  case ORANGEFS_DEV_GET_MAGIC:",
          "617:  case ORANGEFS_DEV_GET_MAX_UPSIZE:",
          "622:  case ORANGEFS_DEV_GET_MAX_DOWNSIZE:",
          "627:  case ORANGEFS_DEV_MAP:",
          "629:          (struct ORANGEFS_dev_map_desc __user *)",
          "631:          sizeof(struct ORANGEFS_dev_map_desc));",
          "632:   return ret ? -EIO : orangefs_bufmap_initialize(&user_desc);",
          "633:  case ORANGEFS_DEV_REMOUNT_ALL:",
          "635:         \"orangefs_devreq_ioctl: got ORANGEFS_DEV_REMOUNT_ALL\\n\");",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "647:   if (ret < 0)",
          "648:    return ret;",
          "649:   gossip_debug(GOSSIP_DEV_DEBUG,",
          "655:     gossip_debug(GOSSIP_DEV_DEBUG,",
          "656:           \"Remounting SB %p\\n\",",
          "660:     if (ret) {",
          "661:      gossip_debug(GOSSIP_DEV_DEBUG,",
          "662:            \"SB %p remount failed\\n\",",
          "664:       break;",
          "665:     }",
          "666:    }",
          "667:   }",
          "668:   gossip_debug(GOSSIP_DEV_DEBUG,",
          "670:   mutex_unlock(&request_mutex);",
          "671:   return ret;",
          "674:   ret = copy_to_user((void __user *)arg,",
          "675:         &upstream_kmod,",
          "676:         sizeof(upstream_kmod));",
          "",
          "[Removed Lines]",
          "650:         \"pvfs2_devreq_ioctl: priority remount in progress\\n\");",
          "651:   list_for_each(tmp, &pvfs2_superblocks) {",
          "652:    pvfs2_sb =",
          "653:     list_entry(tmp, struct pvfs2_sb_info_s, list);",
          "654:    if (pvfs2_sb && (pvfs2_sb->sb)) {",
          "657:           pvfs2_sb);",
          "659:     ret = pvfs2_remount(pvfs2_sb->sb);",
          "663:            pvfs2_sb);",
          "669:         \"pvfs2_devreq_ioctl: priority remount complete\\n\");",
          "673:  case PVFS_DEV_UPSTREAM:",
          "",
          "[Added Lines]",
          "650:         \"orangefs_devreq_ioctl: priority remount in progress\\n\");",
          "651:   list_for_each(tmp, &orangefs_superblocks) {",
          "652:    orangefs_sb =",
          "653:     list_entry(tmp, struct orangefs_sb_info_s, list);",
          "654:    if (orangefs_sb && (orangefs_sb->sb)) {",
          "657:           orangefs_sb);",
          "659:     ret = orangefs_remount(orangefs_sb->sb);",
          "663:            orangefs_sb);",
          "669:         \"orangefs_devreq_ioctl: priority remount complete\\n\");",
          "673:  case ORANGEFS_DEV_UPSTREAM:",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "680:   else",
          "681:    return ret;",
          "684:   ret = copy_from_user(&mask2_info,",
          "685:          (void __user *)arg,",
          "686:          sizeof(struct dev_mask2_info_s));",
          "",
          "[Removed Lines]",
          "683:  case PVFS_DEV_CLIENT_MASK:",
          "",
          "[Added Lines]",
          "683:  case ORANGEFS_DEV_CLIENT_MASK:",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "700:   return ret;",
          "703:   ret = copy_from_user(&client_debug_array_string,",
          "704:          (void __user *)arg,",
          "706:   if (ret != 0) {",
          "707:    pr_info(\"%s: \"",
          "709:     \"\\n\",",
          "710:     __func__);",
          "711:    return -EIO;",
          "",
          "[Removed Lines]",
          "702:  case PVFS_DEV_CLIENT_STRING:",
          "705:          PVFS2_MAX_DEBUG_STRING_LEN);",
          "708:     \"PVFS_DEV_CLIENT_STRING: copy_from_user failed\"",
          "",
          "[Added Lines]",
          "702:  case ORANGEFS_DEV_CLIENT_STRING:",
          "705:          ORANGEFS_MAX_DEBUG_STRING_LEN);",
          "708:     \"ORANGEFS_DEV_CLIENT_STRING: copy_from_user failed\"",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "754:   debugfs_remove(client_debug_dentry);",
          "758:   help_string_initialized++;",
          "760:   return ret;",
          "763:   ret = copy_from_user(&mask_info,",
          "764:          (void __user *)arg,",
          "765:          sizeof(mask_info));",
          "",
          "[Removed Lines]",
          "756:   pvfs2_client_debug_init();",
          "762:  case PVFS_DEV_DEBUG:",
          "",
          "[Added Lines]",
          "756:   orangefs_client_debug_init();",
          "762:  case ORANGEFS_DEV_DEBUG:",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "779:     return 0;",
          "780:    }",
          "781:    debug_mask_to_string(&mask_info.mask_value,",
          "782:           mask_info.mask_type);",
          "783:    gossip_debug_mask = mask_info.mask_value;",
          "785:     \":%s: :%llx:\\n\",",
          "786:     kernel_debug_string,",
          "787:     (unsigned long long)gossip_debug_mask);",
          "788:   } else if (mask_info.mask_type == CLIENT_MASK) {",
          "789:    debug_mask_to_string(&mask_info.mask_value,",
          "790:           mask_info.mask_type);",
          "792:     \":%s: :%llx:\\n\",",
          "793:     client_debug_string,",
          "794:     llu(mask_info.mask_value));",
          "",
          "[Removed Lines]",
          "784:    pr_info(\"PVFS: kernel debug mask has been modified to \"",
          "791:    pr_info(\"PVFS: client debug mask has been modified to\"",
          "",
          "[Added Lines]",
          "784:    pr_info(\"ORANGEFS: kernel debug mask has been modified to \"",
          "791:    pr_info(\"ORANGEFS: client debug mask has been modified to\"",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "805:  return -ENOIOCTLCMD;",
          "806: }",
          "809:           unsigned int command, unsigned long arg)",
          "810: {",
          "811:  long ret;",
          "",
          "[Removed Lines]",
          "808: static long pvfs2_devreq_ioctl(struct file *file,",
          "",
          "[Added Lines]",
          "808: static long orangefs_devreq_ioctl(struct file *file,",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "825:  compat_uptr_t ptr;",
          "826:  __s32 total_size;",
          "827:  __s32 size;",
          "",
          "[Removed Lines]",
          "824: struct PVFS_dev_map_desc32 {",
          "",
          "[Added Lines]",
          "824: struct ORANGEFS_dev_map_desc32 {",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "831: static unsigned long translate_dev_map26(unsigned long args, long *error)",
          "832: {",
          "839:      compat_alloc_user_space(sizeof(*p));",
          "840:  compat_uptr_t addr;",
          "",
          "[Removed Lines]",
          "833:  struct PVFS_dev_map_desc32 __user *p32 = (void __user *)args;",
          "838:  struct PVFS_dev_map_desc __user *p =",
          "",
          "[Added Lines]",
          "833:  struct ORANGEFS_dev_map_desc32 __user *p32 = (void __user *)args;",
          "838:  struct ORANGEFS_dev_map_desc __user *p =",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "867:           unsigned long args)",
          "868: {",
          "869:  long ret;",
          "",
          "[Removed Lines]",
          "866: static long pvfs2_devreq_compat_ioctl(struct file *filp, unsigned int cmd,",
          "",
          "[Added Lines]",
          "866: static long orangefs_devreq_compat_ioctl(struct file *filp, unsigned int cmd,",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "873:  ret = check_ioctl_command(cmd);",
          "874:  if (ret < 0)",
          "875:   return ret;",
          "",
          "[Removed Lines]",
          "876:  if (cmd == PVFS_DEV_MAP) {",
          "",
          "[Added Lines]",
          "876:  if (cmd == ORANGEFS_DEV_MAP) {",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "898: #if (defined(CONFIG_COMPAT) && !defined(HAVE_REGISTER_IOCTL32_CONVERSION)) || !defined(CONFIG_COMPAT)",
          "900: {",
          "901:  return 0;",
          "902: }",
          "905: {",
          "906:  return;",
          "907: }",
          "908: #endif",
          "918: {",
          "919:  int ret;",
          "923:  if (ret < 0)",
          "924:   return ret;",
          "931:   gossip_debug(GOSSIP_DEV_DEBUG,",
          "932:         \"Failed to register /dev/%s (error %d)\\n\",",
          "936:  }",
          "938:  gossip_debug(GOSSIP_DEV_DEBUG,",
          "939:        \"*** /dev/%s character device registered ***\\n\",",
          "941:  gossip_debug(GOSSIP_DEV_DEBUG, \"'mknod /dev/%s c %d 0'.\\n\",",
          "943:  return 0;",
          "944: }",
          "947: {",
          "949:  gossip_debug(GOSSIP_DEV_DEBUG,",
          "950:        \"*** /dev/%s character device unregistered ***\\n\",",
          "954: }",
          "957:           struct poll_table_struct *poll_table)",
          "958: {",
          "959:  int poll_revent_mask = 0;",
          "961:  if (open_access_count == 1) {",
          "966:    poll_revent_mask |= POLL_IN;",
          "968:  }",
          "969:  return poll_revent_mask;",
          "970: }",
          "973:  .owner = THIS_MODULE,",
          "982: #endif",
          "984: };",
          "",
          "[Removed Lines]",
          "899: static int pvfs2_ioctl32_init(void)",
          "904: static void pvfs2_ioctl32_cleanup(void)",
          "911: static int pvfs2_dev_major;",
          "917: int pvfs2_dev_init(void)",
          "922:  ret = pvfs2_ioctl32_init();",
          "927:  pvfs2_dev_major = register_chrdev(0,",
          "928:        PVFS2_REQDEVICE_NAME,",
          "929:        &pvfs2_devreq_file_operations);",
          "930:  if (pvfs2_dev_major < 0) {",
          "933:         PVFS2_REQDEVICE_NAME, pvfs2_dev_major);",
          "934:   pvfs2_ioctl32_cleanup();",
          "935:   return pvfs2_dev_major;",
          "940:        PVFS2_REQDEVICE_NAME);",
          "942:        PVFS2_REQDEVICE_NAME, pvfs2_dev_major);",
          "946: void pvfs2_dev_cleanup(void)",
          "948:  unregister_chrdev(pvfs2_dev_major, PVFS2_REQDEVICE_NAME);",
          "951:        PVFS2_REQDEVICE_NAME);",
          "953:  pvfs2_ioctl32_cleanup();",
          "956: static unsigned int pvfs2_devreq_poll(struct file *file,",
          "962:   poll_wait(file, &pvfs2_request_list_waitq, poll_table);",
          "964:   spin_lock(&pvfs2_request_list_lock);",
          "965:   if (!list_empty(&pvfs2_request_list))",
          "967:   spin_unlock(&pvfs2_request_list_lock);",
          "972: const struct file_operations pvfs2_devreq_file_operations = {",
          "974:  .read = pvfs2_devreq_read,",
          "975:  .write_iter = pvfs2_devreq_write_iter,",
          "976:  .open = pvfs2_devreq_open,",
          "977:  .release = pvfs2_devreq_release,",
          "978:  .unlocked_ioctl = pvfs2_devreq_ioctl,",
          "981:  .compat_ioctl = pvfs2_devreq_compat_ioctl,",
          "983:  .poll = pvfs2_devreq_poll",
          "",
          "[Added Lines]",
          "899: static int orangefs_ioctl32_init(void)",
          "904: static void orangefs_ioctl32_cleanup(void)",
          "911: static int orangefs_dev_major;",
          "917: int orangefs_dev_init(void)",
          "922:  ret = orangefs_ioctl32_init();",
          "927:  orangefs_dev_major = register_chrdev(0,",
          "928:        ORANGEFS_REQDEVICE_NAME,",
          "929:        &orangefs_devreq_file_operations);",
          "930:  if (orangefs_dev_major < 0) {",
          "933:         ORANGEFS_REQDEVICE_NAME, orangefs_dev_major);",
          "934:   orangefs_ioctl32_cleanup();",
          "935:   return orangefs_dev_major;",
          "940:        ORANGEFS_REQDEVICE_NAME);",
          "942:        ORANGEFS_REQDEVICE_NAME, orangefs_dev_major);",
          "946: void orangefs_dev_cleanup(void)",
          "948:  unregister_chrdev(orangefs_dev_major, ORANGEFS_REQDEVICE_NAME);",
          "951:        ORANGEFS_REQDEVICE_NAME);",
          "953:  orangefs_ioctl32_cleanup();",
          "956: static unsigned int orangefs_devreq_poll(struct file *file,",
          "962:   poll_wait(file, &orangefs_request_list_waitq, poll_table);",
          "964:   spin_lock(&orangefs_request_list_lock);",
          "965:   if (!list_empty(&orangefs_request_list))",
          "967:   spin_unlock(&orangefs_request_list_lock);",
          "972: const struct file_operations orangefs_devreq_file_operations = {",
          "974:  .read = orangefs_devreq_read,",
          "975:  .write_iter = orangefs_devreq_write_iter,",
          "976:  .open = orangefs_devreq_open,",
          "977:  .release = orangefs_devreq_release,",
          "978:  .unlocked_ioctl = orangefs_devreq_ioctl,",
          "981:  .compat_ioctl = orangefs_devreq_compat_ioctl,",
          "983:  .poll = orangefs_devreq_poll",
          "",
          "---------------"
        ],
        "fs/orangefs/dir.c||fs/orangefs/dir.c": [
          "File: fs/orangefs/dir.c -> fs/orangefs/dir.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "11: struct readdir_handle_s {",
          "12:  int buffer_index;",
          "14:  void *dents_buf;",
          "15: };",
          "",
          "[Removed Lines]",
          "13:  struct pvfs2_readdir_response_s readdir_response;",
          "",
          "[Added Lines]",
          "13:  struct orangefs_readdir_response_s readdir_response;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "20: static long decode_dirents(char *ptr, size_t size,",
          "22: {",
          "23:  int i;",
          "26:  char *buf = ptr;",
          "29:   return -EINVAL;",
          "31:  readdir->token = rd->token;",
          "34:      sizeof(*readdir->dirent_array),",
          "35:      GFP_KERNEL);",
          "36:  if (readdir->dirent_array == NULL)",
          "37:   return -ENOMEM;",
          "43:   __u32 len;",
          "45:   if (size < 4)",
          "",
          "[Removed Lines]",
          "21:       struct pvfs2_readdir_response_s *readdir)",
          "24:  struct pvfs2_readdir_response_s *rd =",
          "25:   (struct pvfs2_readdir_response_s *) ptr;",
          "28:  if (size < offsetof(struct pvfs2_readdir_response_s, dirent_array))",
          "32:  readdir->pvfs_dirent_outcount = rd->pvfs_dirent_outcount;",
          "33:  readdir->dirent_array = kcalloc(readdir->pvfs_dirent_outcount,",
          "39:  buf += offsetof(struct pvfs2_readdir_response_s, dirent_array);",
          "40:  size -= offsetof(struct pvfs2_readdir_response_s, dirent_array);",
          "42:  for (i = 0; i < readdir->pvfs_dirent_outcount; i++) {",
          "",
          "[Added Lines]",
          "21:                            struct orangefs_readdir_response_s *readdir)",
          "24:  struct orangefs_readdir_response_s *rd =",
          "25:   (struct orangefs_readdir_response_s *) ptr;",
          "28:  if (size < offsetof(struct orangefs_readdir_response_s, dirent_array))",
          "32:  readdir->orangefs_dirent_outcount = rd->orangefs_dirent_outcount;",
          "33:  readdir->dirent_array = kcalloc(readdir->orangefs_dirent_outcount,",
          "39:  buf += offsetof(struct orangefs_readdir_response_s, dirent_array);",
          "40:  size -= offsetof(struct orangefs_readdir_response_s, dirent_array);",
          "42:  for (i = 0; i < readdir->orangefs_dirent_outcount; i++) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "98:  return ret;",
          "99: }",
          "102:   struct readdir_handle_s *rhandle)",
          "103: {",
          "104:  if (rhandle == NULL)",
          "",
          "[Removed Lines]",
          "101: static void readdir_handle_dtor(struct pvfs2_bufmap *bufmap,",
          "",
          "[Added Lines]",
          "101: static void readdir_handle_dtor(struct orangefs_bufmap *bufmap,",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "127: {",
          "129:  int ret = 0;",
          "130:  int buffer_index;",
          "",
          "[Removed Lines]",
          "126: static int pvfs2_readdir(struct file *file, struct dir_context *ctx)",
          "128:  struct pvfs2_bufmap *bufmap = NULL;",
          "",
          "[Added Lines]",
          "126: static int orangefs_readdir(struct file *file, struct dir_context *ctx)",
          "128:  struct orangefs_bufmap *bufmap = NULL;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "136:  __u64 pos = 0;",
          "137:  ino_t ino = 0;",
          "138:  struct dentry *dentry = file->f_path.dentry;",
          "141:  int buffer_full = 0;",
          "142:  struct readdir_handle_s rhandle;",
          "143:  int i = 0;",
          "",
          "[Removed Lines]",
          "139:  struct pvfs2_kernel_op_s *new_op = NULL;",
          "140:  struct pvfs2_inode_s *pvfs2_inode = PVFS2_I(dentry->d_inode);",
          "",
          "[Added Lines]",
          "139:  struct orangefs_kernel_op_s *new_op = NULL;",
          "140:  struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(dentry->d_inode);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "155:  pos = (__u64) ctx->pos;",
          "159:   gossip_debug(GOSSIP_DIR_DEBUG,",
          "160:         \"Skipping to termination path\\n\");",
          "161:   return 0;",
          "162:  }",
          "164:  gossip_debug(GOSSIP_DIR_DEBUG,",
          "166:        dentry->d_name.name, llu(pos));",
          "168:  rhandle.buffer_index = -1;",
          "169:  rhandle.dents_buf = NULL;",
          "170:  memset(&rhandle.readdir_response, 0, sizeof(rhandle.readdir_response));",
          "173:  if (!new_op)",
          "174:   return -ENOMEM;",
          "176:  new_op->uses_shared_memory = 1;",
          "178:  new_op->upcall.req.readdir.max_dirent_count = MAX_DIRENT_COUNT_READDIR;",
          "180:  gossip_debug(GOSSIP_DIR_DEBUG,",
          "",
          "[Removed Lines]",
          "158:  if (pos == PVFS_READDIR_END) {",
          "165:        \"pvfs2_readdir called on %s (pos=%llu)\\n\",",
          "172:  new_op = op_alloc(PVFS2_VFS_OP_READDIR);",
          "177:  new_op->upcall.req.readdir.refn = pvfs2_inode->refn;",
          "",
          "[Added Lines]",
          "158:  if (pos == ORANGEFS_READDIR_END) {",
          "165:        \"orangefs_readdir called on %s (pos=%llu)\\n\",",
          "172:  new_op = op_alloc(ORANGEFS_VFS_OP_READDIR);",
          "177:  new_op->upcall.req.readdir.refn = orangefs_inode->refn;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "187: get_new_buffer_index:",
          "188:  ret = readdir_index_get(&bufmap, &buffer_index);",
          "189:  if (ret < 0) {",
          "191:        ret);",
          "192:   goto out_free_op;",
          "193:  }",
          "194:  new_op->upcall.req.readdir.buf_index = buffer_index;",
          "196:  ret = service_operation(new_op,",
          "198:     get_interruptible_flag(dentry->d_inode));",
          "200:  gossip_debug(GOSSIP_DIR_DEBUG,",
          "",
          "[Removed Lines]",
          "190:   gossip_lerr(\"pvfs2_readdir: readdir_index_get() failure (%d)\\n\",",
          "197:     \"pvfs2_readdir\",",
          "",
          "[Added Lines]",
          "190:   gossip_lerr(\"orangefs_readdir: readdir_index_get() failure (%d)\\n\",",
          "197:     \"orangefs_readdir\",",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "238:         new_op->downcall.trailer_size,",
          "239:         buffer_index);",
          "240:  if (bytes_decoded < 0) {",
          "242:    ret);",
          "243:   ret = bytes_decoded;",
          "244:   readdir_index_put(bufmap, buffer_index);",
          "",
          "[Removed Lines]",
          "241:   gossip_err(\"pvfs2_readdir: Could not decode trailer buffer into a readdir response %d\\n\",",
          "",
          "[Added Lines]",
          "241:   gossip_err(\"orangefs_readdir: Could not decode trailer buffer into a readdir response %d\\n\",",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "246:  }",
          "248:  if (bytes_decoded != new_op->downcall.trailer_size) {",
          "250:       \"!= trailer size (%ld)\\n\",",
          "251:       bytes_decoded,",
          "252:       (long)new_op->downcall.trailer_size);",
          "",
          "[Removed Lines]",
          "249:   gossip_err(\"pvfs2_readdir: # bytes decoded (%ld) \"",
          "",
          "[Added Lines]",
          "249:   gossip_err(\"orangefs_readdir: # bytes decoded (%ld) \"",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "279:  }",
          "287:   ctx->pos = 0;",
          "289:  for (i = ctx->pos;",
          "291:       i++) {",
          "292:   len = rhandle.readdir_response.dirent_array[i].d_length;",
          "293:   current_entry = rhandle.readdir_response.dirent_array[i].d_name;",
          "295:    &(rhandle.readdir_response.dirent_array[i].khandle));",
          "297:   gossip_debug(GOSSIP_DIR_DEBUG,",
          "",
          "[Removed Lines]",
          "286:  if (ctx->pos == PVFS_ITERATE_NEXT)",
          "290:       i < rhandle.readdir_response.pvfs_dirent_outcount;",
          "294:   current_ino = pvfs2_khandle_to_ino(",
          "",
          "[Added Lines]",
          "286:  if (ctx->pos == ORANGEFS_ITERATE_NEXT)",
          "290:       i < rhandle.readdir_response.orangefs_dirent_outcount;",
          "294:   current_ino = orangefs_khandle_to_ino(",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "324:  if (ret) {",
          "327:  }",
          "333:      !buffer_full) {",
          "334:   gossip_debug(GOSSIP_DIR_DEBUG,",
          "337:  }",
          "339: out_destroy_handle:",
          "340:  readdir_handle_dtor(bufmap, &rhandle);",
          "341: out_free_op:",
          "342:  op_release(new_op);",
          "344:  return ret;",
          "345: }",
          "348: {",
          "349:  __u64 *ptoken;",
          "",
          "[Removed Lines]",
          "326:   ctx->pos = PVFS_ITERATE_NEXT;",
          "332:  if (rhandle.readdir_response.token == PVFS_READDIR_END &&",
          "335:   \"End of dir detected; setting ctx->pos to PVFS_READDIR_END.\\n\");",
          "336:   ctx->pos = PVFS_READDIR_END;",
          "343:  gossip_debug(GOSSIP_DIR_DEBUG, \"pvfs2_readdir returning %d\\n\", ret);",
          "347: static int pvfs2_dir_open(struct inode *inode, struct file *file)",
          "",
          "[Added Lines]",
          "326:   ctx->pos = ORANGEFS_ITERATE_NEXT;",
          "332:  if (rhandle.readdir_response.token == ORANGEFS_READDIR_END &&",
          "335:   \"End of dir detected; setting ctx->pos to ORANGEFS_READDIR_END.\\n\");",
          "336:   ctx->pos = ORANGEFS_READDIR_END;",
          "343:  gossip_debug(GOSSIP_DIR_DEBUG, \"orangefs_readdir returning %d\\n\", ret);",
          "347: static int orangefs_dir_open(struct inode *inode, struct file *file)",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "353:   return -ENOMEM;",
          "355:  ptoken = file->private_data;",
          "357:  return 0;",
          "358: }",
          "361: {",
          "363:  kfree(file->private_data);",
          "364:  return 0;",
          "365: }",
          "369:  .read = generic_read_dir,",
          "373: };",
          "",
          "[Removed Lines]",
          "360: static int pvfs2_dir_release(struct inode *inode, struct file *file)",
          "362:  pvfs2_flush_inode(inode);",
          "368: const struct file_operations pvfs2_dir_operations = {",
          "370:  .iterate = pvfs2_readdir,",
          "371:  .open = pvfs2_dir_open,",
          "372:  .release = pvfs2_dir_release,",
          "",
          "[Added Lines]",
          "360: static int orangefs_dir_release(struct inode *inode, struct file *file)",
          "362:  orangefs_flush_inode(inode);",
          "368: const struct file_operations orangefs_dir_operations = {",
          "370:  .iterate = orangefs_readdir,",
          "371:  .open = orangefs_dir_open,",
          "372:  .release = orangefs_dir_release,",
          "",
          "---------------"
        ],
        "fs/orangefs/downcall.h||fs/orangefs/downcall.h": [
          "File: fs/orangefs/downcall.h -> fs/orangefs/downcall.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "19:  __s64 amt_complete;",
          "20: };",
          "24: };",
          "28: };",
          "32: };",
          "37: };",
          "41: };",
          "48:  char *d_name;",
          "49:  int d_length;",
          "51: };",
          "54:  __s64 block_size;",
          "55:  __s64 blocks_total;",
          "56:  __s64 blocks_avail;",
          "",
          "[Removed Lines]",
          "18: struct pvfs2_io_response {",
          "22: struct pvfs2_lookup_response {",
          "23:  struct pvfs2_object_kref refn;",
          "26: struct pvfs2_create_response {",
          "27:  struct pvfs2_object_kref refn;",
          "30: struct pvfs2_symlink_response {",
          "31:  struct pvfs2_object_kref refn;",
          "34: struct pvfs2_getattr_response {",
          "35:  struct PVFS_sys_attr_s attributes;",
          "36:  char link_target[PVFS2_NAME_LEN];",
          "39: struct pvfs2_mkdir_response {",
          "40:  struct pvfs2_object_kref refn;",
          "47: struct pvfs2_dirent {",
          "50:  struct pvfs2_khandle khandle;",
          "53: struct pvfs2_statfs_response {",
          "",
          "[Added Lines]",
          "18: struct orangefs_io_response {",
          "22: struct orangefs_lookup_response {",
          "23:  struct orangefs_object_kref refn;",
          "26: struct orangefs_create_response {",
          "27:  struct orangefs_object_kref refn;",
          "30: struct orangefs_symlink_response {",
          "31:  struct orangefs_object_kref refn;",
          "34: struct orangefs_getattr_response {",
          "35:  struct ORANGEFS_sys_attr_s attributes;",
          "36:  char link_target[ORANGEFS_NAME_LEN];",
          "39: struct orangefs_mkdir_response {",
          "40:  struct orangefs_object_kref refn;",
          "47: struct orangefs_dirent {",
          "50:  struct orangefs_khandle khandle;",
          "53: struct orangefs_statfs_response {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "58:  __s64 files_avail;",
          "59: };",
          "62:  __s32 fs_id;",
          "63:  __s32 id;",
          "65: };",
          "69:  __s32 val_sz;",
          "70:  __s32 __pad1;",
          "72: };",
          "76:  __s32 returned_count;",
          "77:  __s32 __pad1;",
          "78:  __u64 token;",
          "80:  __s32 keylen;",
          "81:  __s32 __pad2;",
          "83: };",
          "86:  __s64 value;",
          "87: };",
          "89: #define PERF_COUNT_BUF_SIZE 4096",
          "91:  char buffer[PERF_COUNT_BUF_SIZE];",
          "92: };",
          "94: #define FS_KEY_BUF_SIZE 4096",
          "96:  __s32 fs_keylen;",
          "97:  __s32 __pad1;",
          "98:  char fs_key[FS_KEY_BUF_SIZE];",
          "99: };",
          "102:  __s32 type;",
          "103:  __s32 status;",
          "",
          "[Removed Lines]",
          "61: struct pvfs2_fs_mount_response {",
          "64:  struct pvfs2_khandle root_khandle;",
          "68: struct pvfs2_getxattr_response {",
          "71:  char val[PVFS_MAX_XATTR_VALUELEN];",
          "75: struct pvfs2_listxattr_response {",
          "79:  char key[PVFS_MAX_XATTR_LISTLEN * PVFS_MAX_XATTR_NAMELEN];",
          "82:  __s32 lengths[PVFS_MAX_XATTR_LISTLEN];",
          "85: struct pvfs2_param_response {",
          "90: struct pvfs2_perf_count_response {",
          "95: struct pvfs2_fs_key_response {",
          "101: struct pvfs2_downcall_s {",
          "",
          "[Added Lines]",
          "61: struct orangefs_fs_mount_response {",
          "64:  struct orangefs_khandle root_khandle;",
          "68: struct orangefs_getxattr_response {",
          "71:  char val[ORANGEFS_MAX_XATTR_VALUELEN];",
          "75: struct orangefs_listxattr_response {",
          "79:  char key[ORANGEFS_MAX_XATTR_LISTLEN * ORANGEFS_MAX_XATTR_NAMELEN];",
          "82:  __s32 lengths[ORANGEFS_MAX_XATTR_LISTLEN];",
          "85: struct orangefs_param_response {",
          "90: struct orangefs_perf_count_response {",
          "95: struct orangefs_fs_key_response {",
          "101: struct orangefs_downcall_s {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "106:  char *trailer_buf;",
          "108:  union {",
          "122:  } resp;",
          "123: };",
          "126:  __u64 token;",
          "127:  __u64 directory_version;",
          "128:  __u32 __pad2;",
          "131: };",
          "",
          "[Removed Lines]",
          "109:   struct pvfs2_io_response io;",
          "110:   struct pvfs2_lookup_response lookup;",
          "111:   struct pvfs2_create_response create;",
          "112:   struct pvfs2_symlink_response sym;",
          "113:   struct pvfs2_getattr_response getattr;",
          "114:   struct pvfs2_mkdir_response mkdir;",
          "115:   struct pvfs2_statfs_response statfs;",
          "116:   struct pvfs2_fs_mount_response fs_mount;",
          "117:   struct pvfs2_getxattr_response getxattr;",
          "118:   struct pvfs2_listxattr_response listxattr;",
          "119:   struct pvfs2_param_response param;",
          "120:   struct pvfs2_perf_count_response perf_count;",
          "121:   struct pvfs2_fs_key_response fs_key;",
          "125: struct pvfs2_readdir_response_s {",
          "129:  __u32 pvfs_dirent_outcount;",
          "130:  struct pvfs2_dirent *dirent_array;",
          "",
          "[Added Lines]",
          "109:   struct orangefs_io_response io;",
          "110:   struct orangefs_lookup_response lookup;",
          "111:   struct orangefs_create_response create;",
          "112:   struct orangefs_symlink_response sym;",
          "113:   struct orangefs_getattr_response getattr;",
          "114:   struct orangefs_mkdir_response mkdir;",
          "115:   struct orangefs_statfs_response statfs;",
          "116:   struct orangefs_fs_mount_response fs_mount;",
          "117:   struct orangefs_getxattr_response getxattr;",
          "118:   struct orangefs_listxattr_response listxattr;",
          "119:   struct orangefs_param_response param;",
          "120:   struct orangefs_perf_count_response perf_count;",
          "121:   struct orangefs_fs_key_response fs_key;",
          "125: struct orangefs_readdir_response_s {",
          "129:  __u32 orangefs_dirent_outcount;",
          "130:  struct orangefs_dirent *dirent_array;",
          "",
          "---------------"
        ],
        "fs/orangefs/file.c||fs/orangefs/file.c": [
          "File: fs/orangefs/file.c -> fs/orangefs/file.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "33:       int buffer_index,",
          "34:       struct iov_iter *iter,",
          "35:       size_t total_size)",
          "",
          "[Removed Lines]",
          "32: static int precopy_buffers(struct pvfs2_bufmap *bufmap,",
          "",
          "[Added Lines]",
          "32: static int precopy_buffers(struct orangefs_bufmap *bufmap,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "44:  if (total_size) {",
          "49:   if (ret < 0)",
          "50:   gossip_err(\"%s: Failed to copy-in buffers. Please make sure that the pvfs2-client is running. %ld\\n\",",
          "51:       __func__,",
          "",
          "[Removed Lines]",
          "45:   ret = pvfs_bufmap_copy_from_iovec(bufmap,",
          "46:       iter,",
          "47:       buffer_index,",
          "48:       total_size);",
          "",
          "[Added Lines]",
          "45:   ret = orangefs_bufmap_copy_from_iovec(bufmap,",
          "46:             iter,",
          "47:             buffer_index,",
          "48:             total_size);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "70:        int buffer_index,",
          "71:        struct iov_iter *iter,",
          "72:        size_t total_size)",
          "",
          "[Removed Lines]",
          "69: static int postcopy_buffers(struct pvfs2_bufmap *bufmap,",
          "",
          "[Added Lines]",
          "69: static int postcopy_buffers(struct orangefs_bufmap *bufmap,",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "80:  if (total_size) {",
          "85:   if (ret < 0)",
          "86:    gossip_err(\"%s: Failed to copy-out buffers. Please make sure that the pvfs2-client is running (%ld)\\n\",",
          "87:     __func__,",
          "",
          "[Removed Lines]",
          "81:   ret = pvfs_bufmap_copy_to_iovec(bufmap,",
          "82:       iter,",
          "83:       buffer_index,",
          "84:       total_size);",
          "",
          "[Added Lines]",
          "81:   ret = orangefs_bufmap_copy_to_iovec(bufmap,",
          "82:           iter,",
          "83:           buffer_index,",
          "84:           total_size);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "97:   loff_t *offset, struct iov_iter *iter,",
          "98:   size_t total_size, loff_t readahead_size)",
          "99: {",
          "104:  int buffer_index = -1;",
          "105:  ssize_t ret;",
          "108:  if (!new_op) {",
          "109:   ret = -ENOMEM;",
          "110:   goto out;",
          "111:  }",
          "114:  new_op->upcall.req.io.readahead_size = readahead_size;",
          "115:  new_op->upcall.req.io.io_type = type;",
          "118: populate_shared_memory:",
          "121:  if (ret < 0) {",
          "122:   gossip_debug(GOSSIP_FILE_DEBUG,",
          "124:         __func__, (long)ret);",
          "125:   goto out;",
          "126:  }",
          "",
          "[Removed Lines]",
          "96: static ssize_t wait_for_direct_io(enum PVFS_io_type type, struct inode *inode,",
          "100:  struct pvfs2_inode_s *pvfs2_inode = PVFS2_I(inode);",
          "101:  struct pvfs2_khandle *handle = &pvfs2_inode->refn.khandle;",
          "102:  struct pvfs2_bufmap *bufmap = NULL;",
          "103:  struct pvfs2_kernel_op_s *new_op = NULL;",
          "107:  new_op = op_alloc(PVFS2_VFS_OP_FILE_IO);",
          "113:  new_op->upcall.req.io.async_vfs_io = PVFS_VFS_SYNC_IO;",
          "116:  new_op->upcall.req.io.refn = pvfs2_inode->refn;",
          "120:  ret = pvfs_bufmap_get(&bufmap, &buffer_index);",
          "123:         \"%s: pvfs_bufmap_get failure (%ld)\\n\",",
          "",
          "[Added Lines]",
          "96: static ssize_t wait_for_direct_io(enum ORANGEFS_io_type type, struct inode *inode,",
          "100:  struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);",
          "101:  struct orangefs_khandle *handle = &orangefs_inode->refn.khandle;",
          "102:  struct orangefs_bufmap *bufmap = NULL;",
          "103:  struct orangefs_kernel_op_s *new_op = NULL;",
          "107:  new_op = op_alloc(ORANGEFS_VFS_OP_FILE_IO);",
          "113:  new_op->upcall.req.io.async_vfs_io = ORANGEFS_VFS_SYNC_IO;",
          "116:  new_op->upcall.req.io.refn = orangefs_inode->refn;",
          "120:  ret = orangefs_bufmap_get(&bufmap, &buffer_index);",
          "123:         \"%s: orangefs_bufmap_get failure (%ld)\\n\",",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "150:   ret = precopy_buffers(bufmap,",
          "151:           buffer_index,",
          "152:           iter,",
          "",
          "[Removed Lines]",
          "149:  if (type == PVFS_IO_WRITE) {",
          "",
          "[Added Lines]",
          "149:  if (type == ORANGEFS_IO_WRITE) {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "165:  ret = service_operation(new_op,",
          "167:      \"file_write\" :",
          "168:      \"file_read\",",
          "169:     get_interruptible_flag(inode));",
          "",
          "[Removed Lines]",
          "166:     type == PVFS_IO_WRITE ?",
          "",
          "[Added Lines]",
          "166:     type == ORANGEFS_IO_WRITE ?",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "180:  if (ret == -EAGAIN && op_state_purged(new_op)) {",
          "182:   gossip_debug(GOSSIP_FILE_DEBUG,",
          "183:         \"%s:going to repopulate_shared_memory.\\n\",",
          "184:         __func__);",
          "",
          "[Removed Lines]",
          "181:   pvfs_bufmap_put(bufmap, buffer_index);",
          "",
          "[Added Lines]",
          "181:   orangefs_bufmap_put(bufmap, buffer_index);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "199:   else",
          "200:    gossip_err(\"%s: error in %s handle %pU, returning %zd\\n\",",
          "201:     __func__,",
          "203:      \"read from\" : \"write to\",",
          "204:     handle, ret);",
          "205:   goto out;",
          "",
          "[Removed Lines]",
          "202:     type == PVFS_IO_READ ?",
          "",
          "[Added Lines]",
          "202:     type == ORANGEFS_IO_READ ?",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "213:   ret = postcopy_buffers(bufmap,",
          "214:            buffer_index,",
          "215:            iter,",
          "",
          "[Removed Lines]",
          "212:  if (type == PVFS_IO_READ) {",
          "",
          "[Added Lines]",
          "212:  if (type == ORANGEFS_IO_READ) {",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "244: out:",
          "245:  if (buffer_index >= 0) {",
          "247:   gossip_debug(GOSSIP_FILE_DEBUG,",
          "248:         \"%s(%pU): PUT buffer_index %d\\n\",",
          "249:         __func__, handle, buffer_index);",
          "",
          "[Removed Lines]",
          "246:   pvfs_bufmap_put(bufmap, buffer_index);",
          "",
          "[Added Lines]",
          "246:   orangefs_bufmap_put(bufmap, buffer_index);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "267:   loff_t *offset, struct iov_iter *iter)",
          "268: {",
          "269:  struct inode *inode = file->f_mapping->host;",
          "272:  size_t count = iov_iter_count(iter);",
          "273:  ssize_t total_count = 0;",
          "274:  ssize_t ret = -EINVAL;",
          "",
          "[Removed Lines]",
          "266: static ssize_t do_readv_writev(enum PVFS_io_type type, struct file *file,",
          "270:  struct pvfs2_inode_s *pvfs2_inode = PVFS2_I(inode);",
          "271:  struct pvfs2_khandle *handle = &pvfs2_inode->refn.khandle;",
          "",
          "[Added Lines]",
          "266: static ssize_t do_readv_writev(enum ORANGEFS_io_type type, struct file *file,",
          "270:  struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);",
          "271:  struct orangefs_khandle *handle = &orangefs_inode->refn.khandle;",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "279:   handle,",
          "280:   (int)count);",
          "283:   gossip_debug(GOSSIP_FILE_DEBUG,",
          "284:         \"%s(%pU): proceeding with offset : %llu, \"",
          "285:         \"size %d\\n\",",
          "",
          "[Removed Lines]",
          "282:  if (type == PVFS_IO_WRITE) {",
          "",
          "[Added Lines]",
          "282:  if (type == ORANGEFS_IO_WRITE) {",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "299:   size_t amt_complete;",
          "305:   gossip_debug(GOSSIP_FILE_DEBUG,",
          "306:         \"%s(%pU): size of each_count(%d)\\n\",",
          "",
          "[Removed Lines]",
          "302:   if (each_count > pvfs_bufmap_size_query())",
          "303:    each_count = pvfs_bufmap_size_query();",
          "",
          "[Added Lines]",
          "302:   if (each_count > orangefs_bufmap_size_query())",
          "303:    each_count = orangefs_bufmap_size_query();",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "346:   ret = total_count;",
          "347: out:",
          "348:  if (ret > 0) {",
          "350:    file_accessed(file);",
          "351:   } else {",
          "353:    inode->i_mtime = CURRENT_TIME;",
          "354:    mark_inode_dirty_sync(inode);",
          "355:   }",
          "",
          "[Removed Lines]",
          "349:   if (type == PVFS_IO_READ) {",
          "352:    SetMtimeFlag(pvfs2_inode);",
          "",
          "[Added Lines]",
          "349:   if (type == ORANGEFS_IO_READ) {",
          "352:    SetMtimeFlag(orangefs_inode);",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "375: {",
          "377:  size_t count = iov_iter_count(iter);",
          "378:  size_t bufmap_size;",
          "379:  ssize_t ret = -EINVAL;",
          "384:  if (count > bufmap_size) {",
          "385:   gossip_debug(GOSSIP_FILE_DEBUG,",
          "386:         \"%s: count is too large (%zd/%zd)!\\n\",",
          "",
          "[Removed Lines]",
          "371: ssize_t pvfs2_inode_read(struct inode *inode,",
          "372:     struct iov_iter *iter,",
          "373:     loff_t *offset,",
          "374:     loff_t readahead_size)",
          "376:  struct pvfs2_inode_s *pvfs2_inode = PVFS2_I(inode);",
          "381:  g_pvfs2_stats.reads++;",
          "383:  bufmap_size = pvfs_bufmap_size_query();",
          "",
          "[Added Lines]",
          "371: ssize_t orangefs_inode_read(struct inode *inode,",
          "372:        struct iov_iter *iter,",
          "373:        loff_t *offset,",
          "374:        loff_t readahead_size)",
          "376:  struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);",
          "381:  g_orangefs_stats.reads++;",
          "383:  bufmap_size = orangefs_bufmap_size_query();",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "391:  gossip_debug(GOSSIP_FILE_DEBUG,",
          "392:        \"%s(%pU) %zd@%llu\\n\",",
          "393:        __func__,",
          "395:        count,",
          "396:        llu(*offset));",
          "399:    count, readahead_size);",
          "400:  if (ret > 0)",
          "",
          "[Removed Lines]",
          "394:        &pvfs2_inode->refn.khandle,",
          "398:  ret = wait_for_direct_io(PVFS_IO_READ, inode, offset, iter,",
          "",
          "[Added Lines]",
          "394:        &orangefs_inode->refn.khandle,",
          "398:  ret = wait_for_direct_io(ORANGEFS_IO_READ, inode, offset, iter,",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "403:  gossip_debug(GOSSIP_FILE_DEBUG,",
          "404:        \"%s(%pU): Value(%zd) returned.\\n\",",
          "405:        __func__,",
          "407:        ret);",
          "409:  return ret;",
          "410: }",
          "413: {",
          "414:  struct file *file = iocb->ki_filp;",
          "415:  loff_t pos = *(&iocb->ki_pos);",
          "",
          "[Removed Lines]",
          "406:        &pvfs2_inode->refn.khandle,",
          "412: static ssize_t pvfs2_file_read_iter(struct kiocb *iocb, struct iov_iter *iter)",
          "",
          "[Added Lines]",
          "406:        &orangefs_inode->refn.khandle,",
          "412: static ssize_t orangefs_file_read_iter(struct kiocb *iocb, struct iov_iter *iter)",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "418:  BUG_ON(iocb->private);",
          "425:  iocb->ki_pos = pos;",
          "427:  return rc;",
          "428: }",
          "431: {",
          "432:  struct file *file = iocb->ki_filp;",
          "433:  loff_t pos;",
          "",
          "[Removed Lines]",
          "420:  gossip_debug(GOSSIP_FILE_DEBUG, \"pvfs2_file_read_iter\\n\");",
          "422:  g_pvfs2_stats.reads++;",
          "424:  rc = do_readv_writev(PVFS_IO_READ, file, &pos, iter);",
          "430: static ssize_t pvfs2_file_write_iter(struct kiocb *iocb, struct iov_iter *iter)",
          "",
          "[Added Lines]",
          "420:  gossip_debug(GOSSIP_FILE_DEBUG, \"orangefs_file_read_iter\\n\");",
          "422:  g_orangefs_stats.reads++;",
          "424:  rc = do_readv_writev(ORANGEFS_IO_READ, file, &pos, iter);",
          "430: static ssize_t orangefs_file_write_iter(struct kiocb *iocb, struct iov_iter *iter)",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "436:  BUG_ON(iocb->private);",
          "440:  mutex_lock(&file->f_mapping->host->i_mutex);",
          "443:  if (file->f_flags & O_APPEND) {",
          "446:   if (rc) {",
          "448:        __func__, rc);",
          "449:    goto out;",
          "450:   }",
          "451:  }",
          "453:  if (file->f_pos > i_size_read(file->f_mapping->host))",
          "456:  rc = generic_write_checks(iocb, iter);",
          "",
          "[Removed Lines]",
          "438:  gossip_debug(GOSSIP_FILE_DEBUG, \"pvfs2_file_write_iter\\n\");",
          "444:   rc = pvfs2_inode_getattr(file->f_mapping->host,",
          "445:       PVFS_ATTR_SYS_SIZE);",
          "447:    gossip_err(\"%s: pvfs2_inode_getattr failed, rc:%zd:.\\n\",",
          "454:   pvfs2_i_size_write(file->f_mapping->host, file->f_pos);",
          "",
          "[Added Lines]",
          "438:  gossip_debug(GOSSIP_FILE_DEBUG, \"orangefs_file_write_iter\\n\");",
          "444:   rc = orangefs_inode_getattr(file->f_mapping->host,",
          "445:       ORANGEFS_ATTR_SYS_SIZE);",
          "447:    gossip_err(\"%s: orangefs_inode_getattr failed, rc:%zd:.\\n\",",
          "454:   orangefs_i_size_write(file->f_mapping->host, file->f_pos);",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "469:  pos = *(&iocb->ki_pos);",
          "472:         file,",
          "473:         &pos,",
          "474:         iter);",
          "",
          "[Removed Lines]",
          "471:  rc = do_readv_writev(PVFS_IO_WRITE,",
          "",
          "[Added Lines]",
          "471:  rc = do_readv_writev(ORANGEFS_IO_WRITE,",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "479:  }",
          "481:  iocb->ki_pos = pos;",
          "484: out:",
          "",
          "[Removed Lines]",
          "482:  g_pvfs2_stats.writes++;",
          "",
          "[Added Lines]",
          "482:  g_orangefs_stats.writes++;",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "494: {",
          "495:  int ret = -ENOTTY;",
          "496:  __u64 val = 0;",
          "497:  unsigned long uval;",
          "499:  gossip_debug(GOSSIP_FILE_DEBUG,",
          "501:        cmd);",
          "",
          "[Removed Lines]",
          "493: static long pvfs2_ioctl(struct file *file, unsigned int cmd, unsigned long arg)",
          "500:        \"pvfs2_ioctl: called with cmd %d\\n\",",
          "",
          "[Added Lines]",
          "493: static long orangefs_ioctl(struct file *file, unsigned int cmd, unsigned long arg)",
          "500:        \"orangefs_ioctl: called with cmd %d\\n\",",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "507:  if (cmd == FS_IOC_GETFLAGS) {",
          "508:   val = 0;",
          "513:   if (ret < 0 && ret != -ENODATA)",
          "514:    return ret;",
          "515:   else if (ret == -ENODATA)",
          "516:    val = 0;",
          "517:   uval = val;",
          "518:   gossip_debug(GOSSIP_FILE_DEBUG,",
          "520:         (unsigned long long)uval);",
          "521:   return put_user(uval, (int __user *)arg);",
          "522:  } else if (cmd == FS_IOC_SETFLAGS) {",
          "",
          "[Removed Lines]",
          "509:   ret = pvfs2_inode_getxattr(file_inode(file),",
          "510:         PVFS2_XATTR_NAME_DEFAULT_PREFIX,",
          "511:         \"user.pvfs2.meta_hint\",",
          "512:         &val, sizeof(val));",
          "519:         \"pvfs2_ioctl: FS_IOC_GETFLAGS: %llu\\n\",",
          "",
          "[Added Lines]",
          "509:   ret = orangefs_inode_getxattr(file_inode(file),",
          "510:            ORANGEFS_XATTR_NAME_DEFAULT_PREFIX,",
          "511:            \"user.pvfs2.meta_hint\",",
          "512:            &val, sizeof(val));",
          "519:         \"orangefs_ioctl: FS_IOC_GETFLAGS: %llu\\n\",",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "524:   if (get_user(uval, (int __user *)arg))",
          "525:    return -EFAULT;",
          "534:       (~(FS_IMMUTABLE_FL | FS_APPEND_FL | FS_NOATIME_FL))) {",
          "536:    return -EINVAL;",
          "537:   }",
          "538:   val = uval;",
          "539:   gossip_debug(GOSSIP_FILE_DEBUG,",
          "541:         (unsigned long long)val);",
          "546:  }",
          "548:  return ret;",
          "",
          "[Removed Lines]",
          "533:   if ((uval & ~PVFS_MIRROR_FL) &",
          "535:    gossip_err(\"pvfs2_ioctl: the FS_IOC_SETFLAGS only supports setting one of FS_IMMUTABLE_FL|FS_APPEND_FL|FS_NOATIME_FL\\n\");",
          "540:         \"pvfs2_ioctl: FS_IOC_SETFLAGS: %llu\\n\",",
          "542:   ret = pvfs2_inode_setxattr(file_inode(file),",
          "543:         PVFS2_XATTR_NAME_DEFAULT_PREFIX,",
          "544:         \"user.pvfs2.meta_hint\",",
          "545:         &val, sizeof(val), 0);",
          "",
          "[Added Lines]",
          "533:   if ((uval & ~ORANGEFS_MIRROR_FL) &",
          "535:    gossip_err(\"orangefs_ioctl: the FS_IOC_SETFLAGS only supports setting one of FS_IMMUTABLE_FL|FS_APPEND_FL|FS_NOATIME_FL\\n\");",
          "540:         \"orangefs_ioctl: FS_IOC_SETFLAGS: %llu\\n\",",
          "542:   ret = orangefs_inode_setxattr(file_inode(file),",
          "543:            ORANGEFS_XATTR_NAME_DEFAULT_PREFIX,",
          "544:            \"user.pvfs2.meta_hint\",",
          "545:            &val, sizeof(val), 0);",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "555: {",
          "556:  gossip_debug(GOSSIP_FILE_DEBUG,",
          "558:        (file ?",
          "559:    (char *)file->f_path.dentry->d_name.name :",
          "560:    (char *)\"Unknown\"));",
          "",
          "[Removed Lines]",
          "554: static int pvfs2_file_mmap(struct file *file, struct vm_area_struct *vma)",
          "557:        \"pvfs2_file_mmap: called on %s\\n\",",
          "",
          "[Added Lines]",
          "554: static int orangefs_file_mmap(struct file *file, struct vm_area_struct *vma)",
          "557:        \"orangefs_file_mmap: called on %s\\n\",",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "579: {",
          "580:  gossip_debug(GOSSIP_FILE_DEBUG,",
          "582:        file->f_path.dentry->d_name.name);",
          "",
          "[Removed Lines]",
          "578: static int pvfs2_file_release(struct inode *inode, struct file *file)",
          "581:        \"pvfs2_file_release: called on %s\\n\",",
          "584:  pvfs2_flush_inode(inode);",
          "",
          "[Added Lines]",
          "578: static int orangefs_file_release(struct inode *inode, struct file *file)",
          "581:        \"orangefs_file_release: called on %s\\n\",",
          "584:  orangefs_flush_inode(inode);",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "603:          loff_t start,",
          "604:          loff_t end,",
          "605:          int datasync)",
          "606: {",
          "607:  int ret = -EINVAL;",
          "613:  filemap_write_and_wait_range(file->f_mapping, start, end);",
          "616:  if (!new_op)",
          "617:   return -ENOMEM;",
          "620:  ret = service_operation(new_op,",
          "622:    get_interruptible_flag(file->f_path.dentry->d_inode));",
          "624:  gossip_debug(GOSSIP_FILE_DEBUG,",
          "626:        ret);",
          "628:  op_release(new_op);",
          "631:  return ret;",
          "632: }",
          "",
          "[Removed Lines]",
          "602: static int pvfs2_fsync(struct file *file,",
          "608:  struct pvfs2_inode_s *pvfs2_inode =",
          "609:   PVFS2_I(file->f_path.dentry->d_inode);",
          "610:  struct pvfs2_kernel_op_s *new_op = NULL;",
          "615:  new_op = op_alloc(PVFS2_VFS_OP_FSYNC);",
          "618:  new_op->upcall.req.fsync.refn = pvfs2_inode->refn;",
          "621:    \"pvfs2_fsync\",",
          "625:        \"pvfs2_fsync got return value of %d\\n\",",
          "630:  pvfs2_flush_inode(file->f_path.dentry->d_inode);",
          "",
          "[Added Lines]",
          "602: static int orangefs_fsync(struct file *file,",
          "608:  struct orangefs_inode_s *orangefs_inode =",
          "609:   ORANGEFS_I(file->f_path.dentry->d_inode);",
          "610:  struct orangefs_kernel_op_s *new_op = NULL;",
          "615:  new_op = op_alloc(ORANGEFS_VFS_OP_FSYNC);",
          "618:  new_op->upcall.req.fsync.refn = orangefs_inode->refn;",
          "621:    \"orangefs_fsync\",",
          "625:        \"orangefs_fsync got return value of %d\\n\",",
          "630:  orangefs_flush_inode(file->f_path.dentry->d_inode);",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "644: {",
          "645:  int ret = -EINVAL;",
          "646:  struct inode *inode = file->f_path.dentry->d_inode;",
          "648:  if (!inode) {",
          "650:   return ret;",
          "651:  }",
          "660:   if (ret) {",
          "661:    gossip_debug(GOSSIP_FILE_DEBUG,",
          "662:          \"%s:%s:%d calling make bad inode\\n\",",
          "663:          __FILE__,",
          "664:          __func__,",
          "665:          __LINE__);",
          "667:    return ret;",
          "668:   }",
          "669:  }",
          "671:  gossip_debug(GOSSIP_FILE_DEBUG,",
          "673:        \" | inode size is %lu\\n\",",
          "674:        (long)offset,",
          "675:        origin,",
          "",
          "[Removed Lines]",
          "643: static loff_t pvfs2_file_llseek(struct file *file, loff_t offset, int origin)",
          "649:   gossip_err(\"pvfs2_file_llseek: invalid inode (NULL)\\n\");",
          "653:  if (origin == PVFS2_SEEK_END) {",
          "659:   ret = pvfs2_inode_getattr(inode, PVFS_ATTR_SYS_SIZE);",
          "666:    pvfs2_make_bad_inode(inode);",
          "672:        \"pvfs2_file_llseek: offset is %ld | origin is %d\"",
          "",
          "[Added Lines]",
          "643: static loff_t orangefs_file_llseek(struct file *file, loff_t offset, int origin)",
          "649:   gossip_err(\"orangefs_file_llseek: invalid inode (NULL)\\n\");",
          "653:  if (origin == ORANGEFS_SEEK_END) {",
          "659:   ret = orangefs_inode_getattr(inode, ORANGEFS_ATTR_SYS_SIZE);",
          "666:    orangefs_make_bad_inode(inode);",
          "672:        \"orangefs_file_llseek: offset is %ld | origin is %d\"",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "686: {",
          "687:  int rc = -EINVAL;",
          "690:   if (cmd == F_GETLK) {",
          "691:    rc = 0;",
          "692:    posix_test_lock(filp, fl);",
          "",
          "[Removed Lines]",
          "685: static int pvfs2_lock(struct file *filp, int cmd, struct file_lock *fl)",
          "689:  if (PVFS2_SB(filp->f_inode->i_sb)->flags & PVFS2_OPT_LOCAL_LOCK) {",
          "",
          "[Added Lines]",
          "685: static int orangefs_lock(struct file *filp, int cmd, struct file_lock *fl)",
          "689:  if (ORANGEFS_SB(filp->f_inode->i_sb)->flags & ORANGEFS_OPT_LOCAL_LOCK) {",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "698:  return rc;",
          "699: }",
          "709:  .open  = generic_file_open,",
          "712: };",
          "",
          "[Removed Lines]",
          "702: const struct file_operations pvfs2_file_operations = {",
          "703:  .llseek  = pvfs2_file_llseek,",
          "704:  .read_iter = pvfs2_file_read_iter,",
          "705:  .write_iter = pvfs2_file_write_iter,",
          "706:  .lock  = pvfs2_lock,",
          "707:  .unlocked_ioctl = pvfs2_ioctl,",
          "708:  .mmap  = pvfs2_file_mmap,",
          "710:  .release = pvfs2_file_release,",
          "711:  .fsync  = pvfs2_fsync,",
          "",
          "[Added Lines]",
          "702: const struct file_operations orangefs_file_operations = {",
          "703:  .llseek  = orangefs_file_llseek,",
          "704:  .read_iter = orangefs_file_read_iter,",
          "705:  .write_iter = orangefs_file_write_iter,",
          "706:  .lock  = orangefs_lock,",
          "707:  .unlocked_ioctl = orangefs_ioctl,",
          "708:  .mmap  = orangefs_file_mmap,",
          "710:  .release = orangefs_file_release,",
          "711:  .fsync  = orangefs_fsync,",
          "",
          "---------------"
        ],
        "fs/orangefs/inode.c||fs/orangefs/inode.c": [
          "File: fs/orangefs/inode.c -> fs/orangefs/inode.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "26:  iov_iter_bvec(&to, ITER_BVEC | READ, &bv, 1, PAGE_SIZE);",
          "28:  gossip_debug(GOSSIP_INODE_DEBUG,",
          "30:        page);",
          "32:  max_block = ((inode->i_size / blocksize) + 1);",
          "",
          "[Removed Lines]",
          "29:       \"pvfs2_readpage called with page %p\\n\",",
          "",
          "[Added Lines]",
          "29:       \"orangefs_readpage called with page %p\\n\",",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "34:  if (page->index < max_block) {",
          "35:   loff_t blockptr_offset = (((loff_t) page->index) << blockbits);",
          "41:  }",
          "43:  iov_iter_zero(~0U, &to);",
          "",
          "[Removed Lines]",
          "37:   bytes_read = pvfs2_inode_read(inode,",
          "38:            &to,",
          "39:            &blockptr_offset,",
          "40:            inode->i_size);",
          "",
          "[Added Lines]",
          "37:   bytes_read = orangefs_inode_read(inode,",
          "38:        &to,",
          "39:        &blockptr_offset,",
          "40:        inode->i_size);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "57:  return ret;",
          "58: }",
          "61: {",
          "62:  return read_one_page(page);",
          "63: }",
          "66:       struct address_space *mapping,",
          "67:       struct list_head *pages,",
          "68:       unsigned nr_pages)",
          "",
          "[Removed Lines]",
          "60: static int pvfs2_readpage(struct file *file, struct page *page)",
          "65: static int pvfs2_readpages(struct file *file,",
          "",
          "[Added Lines]",
          "60: static int orangefs_readpage(struct file *file, struct page *page)",
          "65: static int orangefs_readpages(struct file *file,",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "70:  int page_idx;",
          "71:  int ret;",
          "75:  for (page_idx = 0; page_idx < nr_pages; page_idx++) {",
          "76:   struct page *page;",
          "",
          "[Removed Lines]",
          "73:  gossip_debug(GOSSIP_INODE_DEBUG, \"pvfs2_readpages called\\n\");",
          "",
          "[Added Lines]",
          "73:  gossip_debug(GOSSIP_INODE_DEBUG, \"orangefs_readpages called\\n\");",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "93:  return 0;",
          "94: }",
          "97:      unsigned int offset,",
          "98:      unsigned int length)",
          "99: {",
          "100:  gossip_debug(GOSSIP_INODE_DEBUG,",
          "102:        \"(offset is %u)\\n\",",
          "103:        page,",
          "104:        offset);",
          "",
          "[Removed Lines]",
          "96: static void pvfs2_invalidatepage(struct page *page,",
          "101:        \"pvfs2_invalidatepage called on page %p \"",
          "",
          "[Added Lines]",
          "96: static void orangefs_invalidatepage(struct page *page,",
          "101:        \"orangefs_invalidatepage called on page %p \"",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "110: }",
          "113: {",
          "114:  gossip_debug(GOSSIP_INODE_DEBUG,",
          "116:        page);",
          "117:  return 0;",
          "118: }",
          "",
          "[Removed Lines]",
          "112: static int pvfs2_releasepage(struct page *page, gfp_t foo)",
          "115:        \"pvfs2_releasepage called on page %p\\n\",",
          "",
          "[Added Lines]",
          "112: static int orangefs_releasepage(struct page *page, gfp_t foo)",
          "115:        \"orangefs_releasepage called on page %p\\n\",",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "143:  .ra_pages = 0,",
          "144:  .capabilities = BDI_CAP_NO_ACCT_DIRTY | BDI_CAP_NO_WRITEBACK,",
          "145: };",
          "154: };",
          "157: {",
          "160:  loff_t orig_size = i_size_read(inode);",
          "161:  int ret = -EINVAL;",
          "",
          "[Removed Lines]",
          "141: struct backing_dev_info pvfs2_backing_dev_info = {",
          "142:  .name = \"pvfs2\",",
          "148: const struct address_space_operations pvfs2_address_operations = {",
          "149:  .readpage = pvfs2_readpage,",
          "150:  .readpages = pvfs2_readpages,",
          "151:  .invalidatepage = pvfs2_invalidatepage,",
          "152:  .releasepage = pvfs2_releasepage,",
          "156: static int pvfs2_setattr_size(struct inode *inode, struct iattr *iattr)",
          "158:  struct pvfs2_inode_s *pvfs2_inode = PVFS2_I(inode);",
          "159:  struct pvfs2_kernel_op_s *new_op;",
          "",
          "[Added Lines]",
          "141: struct backing_dev_info orangefs_backing_dev_info = {",
          "142:  .name = \"orangefs\",",
          "148: const struct address_space_operations orangefs_address_operations = {",
          "149:  .readpage = orangefs_readpage,",
          "150:  .readpages = orangefs_readpages,",
          "151:  .invalidatepage = orangefs_invalidatepage,",
          "152:  .releasepage = orangefs_releasepage,",
          "156: static int orangefs_setattr_size(struct inode *inode, struct iattr *iattr)",
          "158:  struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);",
          "159:  struct orangefs_kernel_op_s *new_op;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "164:        \"%s: %pU: Handle is %pU | fs_id %d | size is %llu\\n\",",
          "165:        __func__,",
          "166:        get_khandle_from_ino(inode),",
          "169:        iattr->ia_size);",
          "171:  truncate_setsize(inode, iattr->ia_size);",
          "174:  if (!new_op)",
          "175:   return -ENOMEM;",
          "178:  new_op->upcall.req.truncate.size = (__s64) iattr->ia_size;",
          "180:  ret = service_operation(new_op, __func__,",
          "",
          "[Removed Lines]",
          "167:        &pvfs2_inode->refn.khandle,",
          "168:        pvfs2_inode->refn.fs_id,",
          "173:  new_op = op_alloc(PVFS2_VFS_OP_TRUNCATE);",
          "177:  new_op->upcall.req.truncate.refn = pvfs2_inode->refn;",
          "",
          "[Added Lines]",
          "167:        &orangefs_inode->refn.khandle,",
          "168:        orangefs_inode->refn.fs_id,",
          "173:  new_op = op_alloc(ORANGEFS_VFS_OP_TRUNCATE);",
          "177:  new_op->upcall.req.truncate.refn = orangefs_inode->refn;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "187:  gossip_debug(GOSSIP_INODE_DEBUG,",
          "189:        ret);",
          "191:  op_release(new_op);",
          "",
          "[Removed Lines]",
          "188:        \"pvfs2: pvfs2_truncate got return value of %d\\n\",",
          "",
          "[Added Lines]",
          "188:        \"orangefs: orangefs_truncate got return value of %d\\n\",",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "220: {",
          "221:  int ret = -EINVAL;",
          "222:  struct inode *inode = dentry->d_inode;",
          "224:  gossip_debug(GOSSIP_INODE_DEBUG,",
          "226:        dentry->d_name.name);",
          "228:  ret = inode_change_ok(inode, iattr);",
          "",
          "[Removed Lines]",
          "219: int pvfs2_setattr(struct dentry *dentry, struct iattr *iattr)",
          "225:        \"pvfs2_setattr: called on %s\\n\",",
          "",
          "[Added Lines]",
          "219: int orangefs_setattr(struct dentry *dentry, struct iattr *iattr)",
          "225:        \"orangefs_setattr: called on %s\\n\",",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "232:  if ((iattr->ia_valid & ATTR_SIZE) &&",
          "233:      iattr->ia_size != i_size_read(inode)) {",
          "235:   if (ret)",
          "236:    goto out;",
          "237:  }",
          "",
          "[Removed Lines]",
          "234:   ret = pvfs2_setattr_size(inode, iattr);",
          "",
          "[Added Lines]",
          "234:   ret = orangefs_setattr_size(inode, iattr);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "239:  setattr_copy(inode, iattr);",
          "240:  mark_inode_dirty(inode);",
          "243:  gossip_debug(GOSSIP_INODE_DEBUG,",
          "245:        ret);",
          "247:  if (!ret && (iattr->ia_valid & ATTR_MODE))",
          "",
          "[Removed Lines]",
          "242:  ret = pvfs2_inode_setattr(inode, iattr);",
          "244:        \"pvfs2_setattr: inode_setattr returned %d\\n\",",
          "",
          "[Added Lines]",
          "242:  ret = orangefs_inode_setattr(inode, iattr);",
          "244:        \"orangefs_setattr: inode_setattr returned %d\\n\",",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "249:   ret = posix_acl_chmod(inode, inode->i_mode);",
          "251: out:",
          "253:  return ret;",
          "254: }",
          "260:     struct dentry *dentry,",
          "261:     struct kstat *kstat)",
          "262: {",
          "263:  int ret = -ENOENT;",
          "264:  struct inode *inode = dentry->d_inode;",
          "267:  gossip_debug(GOSSIP_INODE_DEBUG,",
          "269:        dentry->d_name.name);",
          "",
          "[Removed Lines]",
          "252:  gossip_debug(GOSSIP_INODE_DEBUG, \"pvfs2_setattr: returning %d\\n\", ret);",
          "259: int pvfs2_getattr(struct vfsmount *mnt,",
          "265:  struct pvfs2_inode_s *pvfs2_inode = NULL;",
          "268:        \"pvfs2_getattr: called on %s\\n\",",
          "",
          "[Added Lines]",
          "252:  gossip_debug(GOSSIP_INODE_DEBUG, \"orangefs_setattr: returning %d\\n\", ret);",
          "259: int orangefs_getattr(struct vfsmount *mnt,",
          "265:  struct orangefs_inode_s *orangefs_inode = NULL;",
          "268:        \"orangefs_getattr: called on %s\\n\",",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "277:  if (ret == 0) {",
          "278:   generic_fillattr(inode, kstat);",
          "282:  } else {",
          "284:   gossip_debug(GOSSIP_INODE_DEBUG,",
          "",
          "[Removed Lines]",
          "276:  ret = pvfs2_inode_getattr(inode, PVFS_ATTR_SYS_ALL_NOHINT);",
          "280:   pvfs2_inode = PVFS2_I(inode);",
          "281:   kstat->blksize = pvfs2_inode->blksize;",
          "",
          "[Added Lines]",
          "276:  ret = orangefs_inode_getattr(inode, ORANGEFS_ATTR_SYS_ALL_NOHINT);",
          "280:   orangefs_inode = ORANGEFS_I(inode);",
          "281:   kstat->blksize = orangefs_inode->blksize;",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "286:         __FILE__,",
          "287:         __func__,",
          "288:         __LINE__);",
          "290:  }",
          "291:  return ret;",
          "292: }",
          "300:  .setxattr = generic_setxattr,",
          "301:  .getxattr = generic_getxattr,",
          "303:  .removexattr = generic_removexattr,",
          "304: };",
          "307: {",
          "310:  switch (inode->i_mode & S_IFMT) {",
          "311:  case S_IFREG:",
          "314:   inode->i_blkbits = PAGE_CACHE_SHIFT;",
          "315:   break;",
          "316:  case S_IFLNK:",
          "318:   break;",
          "319:  case S_IFDIR:",
          "322:   break;",
          "323:  default:",
          "324:   gossip_debug(GOSSIP_INODE_DEBUG,",
          "",
          "[Removed Lines]",
          "289:   pvfs2_make_bad_inode(inode);",
          "295: struct inode_operations pvfs2_file_inode_operations = {",
          "296:  .get_acl = pvfs2_get_acl,",
          "297:  .set_acl = pvfs2_set_acl,",
          "298:  .setattr = pvfs2_setattr,",
          "299:  .getattr = pvfs2_getattr,",
          "302:  .listxattr = pvfs2_listxattr,",
          "306: static int pvfs2_init_iops(struct inode *inode)",
          "308:  inode->i_mapping->a_ops = &pvfs2_address_operations;",
          "312:   inode->i_op = &pvfs2_file_inode_operations;",
          "313:   inode->i_fop = &pvfs2_file_operations;",
          "317:   inode->i_op = &pvfs2_symlink_inode_operations;",
          "320:   inode->i_op = &pvfs2_dir_inode_operations;",
          "321:   inode->i_fop = &pvfs2_dir_operations;",
          "",
          "[Added Lines]",
          "289:   orangefs_make_bad_inode(inode);",
          "295: struct inode_operations orangefs_file_inode_operations = {",
          "296:  .get_acl = orangefs_get_acl,",
          "297:  .set_acl = orangefs_set_acl,",
          "298:  .setattr = orangefs_setattr,",
          "299:  .getattr = orangefs_getattr,",
          "302:  .listxattr = orangefs_listxattr,",
          "306: static int orangefs_init_iops(struct inode *inode)",
          "308:  inode->i_mapping->a_ops = &orangefs_address_operations;",
          "312:   inode->i_op = &orangefs_file_inode_operations;",
          "313:   inode->i_fop = &orangefs_file_operations;",
          "317:   inode->i_op = &orangefs_symlink_inode_operations;",
          "320:   inode->i_op = &orangefs_dir_inode_operations;",
          "321:   inode->i_fop = &orangefs_dir_operations;",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "331: }",
          "339: {",
          "340:  if (!ref)",
          "341:   return 0;",
          "343: }",
          "349: {",
          "354:  if (!data || !inode)",
          "355:   return 0;",
          "358:   return 0;",
          "361:  return 0;",
          "362: }",
          "368: {",
          "375: }",
          "385: {",
          "386:  struct inode *inode = NULL;",
          "387:  unsigned long hash;",
          "388:  int error;",
          "392:  if (!inode || !(inode->i_state & I_NEW))",
          "393:   return inode;",
          "396:  if (error) {",
          "397:   iget_failed(inode);",
          "398:   return ERR_PTR(error);",
          "399:  }",
          "403:  unlock_new_inode(inode);",
          "405:  gossip_debug(GOSSIP_INODE_DEBUG,",
          "",
          "[Removed Lines]",
          "338: static inline ino_t pvfs2_handle_hash(struct pvfs2_object_kref *ref)",
          "342:  return pvfs2_khandle_to_ino(&(ref->khandle));",
          "348: static int pvfs2_set_inode(struct inode *inode, void *data)",
          "350:  struct pvfs2_object_kref *ref = (struct pvfs2_object_kref *) data;",
          "351:  struct pvfs2_inode_s *pvfs2_inode = NULL;",
          "356:  pvfs2_inode = PVFS2_I(inode);",
          "357:  if (!pvfs2_inode)",
          "359:  pvfs2_inode->refn.fs_id = ref->fs_id;",
          "360:  pvfs2_inode->refn.khandle = ref->khandle;",
          "367: static int pvfs2_test_inode(struct inode *inode, void *data)",
          "369:  struct pvfs2_object_kref *ref = (struct pvfs2_object_kref *) data;",
          "370:  struct pvfs2_inode_s *pvfs2_inode = NULL;",
          "372:  pvfs2_inode = PVFS2_I(inode);",
          "373:  return (!PVFS_khandle_cmp(&(pvfs2_inode->refn.khandle), &(ref->khandle))",
          "374:   && pvfs2_inode->refn.fs_id == ref->fs_id);",
          "384: struct inode *pvfs2_iget(struct super_block *sb, struct pvfs2_object_kref *ref)",
          "390:  hash = pvfs2_handle_hash(ref);",
          "391:  inode = iget5_locked(sb, hash, pvfs2_test_inode, pvfs2_set_inode, ref);",
          "395:  error = pvfs2_inode_getattr(inode, PVFS_ATTR_SYS_ALL_NOHINT);",
          "402:  pvfs2_init_iops(inode);",
          "",
          "[Added Lines]",
          "338: static inline ino_t orangefs_handle_hash(struct orangefs_object_kref *ref)",
          "342:  return orangefs_khandle_to_ino(&(ref->khandle));",
          "348: static int orangefs_set_inode(struct inode *inode, void *data)",
          "350:  struct orangefs_object_kref *ref = (struct orangefs_object_kref *) data;",
          "351:  struct orangefs_inode_s *orangefs_inode = NULL;",
          "356:  orangefs_inode = ORANGEFS_I(inode);",
          "357:  if (!orangefs_inode)",
          "359:  orangefs_inode->refn.fs_id = ref->fs_id;",
          "360:  orangefs_inode->refn.khandle = ref->khandle;",
          "367: static int orangefs_test_inode(struct inode *inode, void *data)",
          "369:  struct orangefs_object_kref *ref = (struct orangefs_object_kref *) data;",
          "370:  struct orangefs_inode_s *orangefs_inode = NULL;",
          "372:  orangefs_inode = ORANGEFS_I(inode);",
          "373:  return (!ORANGEFS_khandle_cmp(&(orangefs_inode->refn.khandle), &(ref->khandle))",
          "374:   && orangefs_inode->refn.fs_id == ref->fs_id);",
          "384: struct inode *orangefs_iget(struct super_block *sb, struct orangefs_object_kref *ref)",
          "390:  hash = orangefs_handle_hash(ref);",
          "391:  inode = iget5_locked(sb, hash, orangefs_test_inode, orangefs_set_inode, ref);",
          "395:  error = orangefs_inode_getattr(inode, ORANGEFS_ATTR_SYS_ALL_NOHINT);",
          "402:  orangefs_init_iops(inode);",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "420: {",
          "422:  struct inode *inode;",
          "423:  int error;",
          "425:  gossip_debug(GOSSIP_INODE_DEBUG,",
          "427:        \"(sb is %p | MAJOR(dev)=%u | MINOR(dev)=%u mode=%o)\\n\",",
          "428:        sb,",
          "429:        MAJOR(dev),",
          "",
          "[Removed Lines]",
          "418: struct inode *pvfs2_new_inode(struct super_block *sb, struct inode *dir,",
          "419:   int mode, dev_t dev, struct pvfs2_object_kref *ref)",
          "421:  unsigned long hash = pvfs2_handle_hash(ref);",
          "426:        \"pvfs2_get_custom_inode_common: called\\n\"",
          "",
          "[Added Lines]",
          "418: struct inode *orangefs_new_inode(struct super_block *sb, struct inode *dir,",
          "419:   int mode, dev_t dev, struct orangefs_object_kref *ref)",
          "421:  unsigned long hash = orangefs_handle_hash(ref);",
          "426:        \"orangefs_get_custom_inode_common: called\\n\"",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "434:  if (!inode)",
          "435:   return NULL;",
          "441:  if (error)",
          "442:   goto out_iput;",
          "446:  inode->i_mode = mode;",
          "447:  inode->i_uid = current_fsuid();",
          "",
          "[Removed Lines]",
          "437:  pvfs2_set_inode(inode, ref);",
          "440:  error = pvfs2_inode_getattr(inode, PVFS_ATTR_SYS_ALL_NOHINT);",
          "444:  pvfs2_init_iops(inode);",
          "",
          "[Added Lines]",
          "437:  orangefs_set_inode(inode, ref);",
          "440:  error = orangefs_inode_getattr(inode, ORANGEFS_ATTR_SYS_ALL_NOHINT);",
          "444:  orangefs_init_iops(inode);",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "450:  inode->i_size = PAGE_CACHE_SIZE;",
          "451:  inode->i_rdev = dev;",
          "454:  if (error < 0)",
          "455:   goto out_iput;",
          "457:  gossip_debug(GOSSIP_INODE_DEBUG,",
          "458:        \"Initializing ACL's for inode %pU\\n\",",
          "459:        get_khandle_from_ino(inode));",
          "461:  return inode;",
          "463: out_iput:",
          "",
          "[Removed Lines]",
          "453:  error = insert_inode_locked4(inode, hash, pvfs2_test_inode, ref);",
          "460:  pvfs2_init_acl(inode, dir);",
          "",
          "[Added Lines]",
          "453:  error = insert_inode_locked4(inode, hash, orangefs_test_inode, ref);",
          "460:  orangefs_init_acl(inode, dir);",
          "",
          "---------------"
        ],
        "fs/orangefs/namei.c||fs/orangefs/namei.c": [
          "File: fs/orangefs/namei.c -> fs/orangefs/namei.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "18:    struct dentry *dentry,",
          "19:    umode_t mode,",
          "20:    bool exclusive)",
          "21: {",
          "24:  struct inode *inode;",
          "25:  int ret;",
          "27:  gossip_debug(GOSSIP_NAME_DEBUG, \"%s: called\\n\", __func__);",
          "30:  if (!new_op)",
          "31:   return -ENOMEM;",
          "33:  new_op->upcall.req.create.parent_refn = parent->refn;",
          "35:  fill_default_sys_attrs(new_op->upcall.req.create.attributes,",
          "38:  strncpy(new_op->upcall.req.create.d_name,",
          "41:  ret = service_operation(new_op, __func__, get_interruptible_flag(dir));",
          "43:  gossip_debug(GOSSIP_NAME_DEBUG,",
          "45:        &new_op->downcall.resp.create.refn.khandle,",
          "46:        new_op->downcall.resp.create.refn.fs_id, ret);",
          "",
          "[Removed Lines]",
          "17: static int pvfs2_create(struct inode *dir,",
          "22:  struct pvfs2_inode_s *parent = PVFS2_I(dir);",
          "23:  struct pvfs2_kernel_op_s *new_op;",
          "29:  new_op = op_alloc(PVFS2_VFS_OP_CREATE);",
          "36:           PVFS_TYPE_METAFILE, mode);",
          "39:   dentry->d_name.name, PVFS2_NAME_LEN);",
          "44:        \"Create Got PVFS2 handle %pU on fsid %d (ret=%d)\\n\",",
          "",
          "[Added Lines]",
          "17: static int orangefs_create(struct inode *dir,",
          "22:  struct orangefs_inode_s *parent = ORANGEFS_I(dir);",
          "23:  struct orangefs_kernel_op_s *new_op;",
          "29:  new_op = op_alloc(ORANGEFS_VFS_OP_CREATE);",
          "36:           ORANGEFS_TYPE_METAFILE, mode);",
          "39:   dentry->d_name.name, ORANGEFS_NAME_LEN);",
          "44:        \"Create Got ORANGEFS handle %pU on fsid %d (ret=%d)\\n\",",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "52:   goto out;",
          "53:  }",
          "56:     &new_op->downcall.resp.create.refn);",
          "57:  if (IS_ERR(inode)) {",
          "59:   ret = PTR_ERR(inode);",
          "60:   goto out;",
          "61:  }",
          "",
          "[Removed Lines]",
          "55:  inode = pvfs2_new_inode(dir->i_sb, dir, S_IFREG | mode, 0,",
          "58:   gossip_err(\"*** Failed to allocate pvfs2 file inode\\n\");",
          "",
          "[Added Lines]",
          "55:  inode = orangefs_new_inode(dir->i_sb, dir, S_IFREG | mode, 0,",
          "58:   gossip_err(\"*** Failed to allocate orangefs file inode\\n\");",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "90:        unsigned int flags)",
          "91: {",
          "94:  struct inode *inode;",
          "95:  struct dentry *res;",
          "96:  int ret = -EINVAL;",
          "",
          "[Removed Lines]",
          "89: static struct dentry *pvfs2_lookup(struct inode *dir, struct dentry *dentry,",
          "92:  struct pvfs2_inode_s *parent = PVFS2_I(dir);",
          "93:  struct pvfs2_kernel_op_s *new_op;",
          "",
          "[Added Lines]",
          "89: static struct dentry *orangefs_lookup(struct inode *dir, struct dentry *dentry,",
          "92:  struct orangefs_inode_s *parent = ORANGEFS_I(dir);",
          "93:  struct orangefs_kernel_op_s *new_op;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "106:  gossip_debug(GOSSIP_NAME_DEBUG, \"%s called on %s\\n\",",
          "107:        __func__, dentry->d_name.name);",
          "110:   return ERR_PTR(-ENAMETOOLONG);",
          "113:  if (!new_op)",
          "114:   return ERR_PTR(-ENOMEM);",
          "",
          "[Removed Lines]",
          "109:  if (dentry->d_name.len > (PVFS2_NAME_LEN - 1))",
          "112:  new_op = op_alloc(PVFS2_VFS_OP_LOOKUP);",
          "",
          "[Added Lines]",
          "109:  if (dentry->d_name.len > (ORANGEFS_NAME_LEN - 1))",
          "112:  new_op = op_alloc(ORANGEFS_VFS_OP_LOOKUP);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "123:  new_op->upcall.req.lookup.parent_refn = parent->refn;",
          "125:  strncpy(new_op->upcall.req.lookup.d_name, dentry->d_name.name,",
          "128:  gossip_debug(GOSSIP_NAME_DEBUG,",
          "129:        \"%s: doing lookup on %s under %pU,%d (follow=%s)\\n\",",
          "",
          "[Removed Lines]",
          "126:   PVFS2_NAME_LEN);",
          "",
          "[Added Lines]",
          "126:   ORANGEFS_NAME_LEN);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "132:        &new_op->upcall.req.lookup.parent_refn.khandle,",
          "133:        new_op->upcall.req.lookup.parent_refn.fs_id,",
          "134:        ((new_op->upcall.req.lookup.sym_follow ==",
          "137:  ret = service_operation(new_op, __func__, get_interruptible_flag(dir));",
          "",
          "[Removed Lines]",
          "135:          PVFS2_LOOKUP_LINK_FOLLOW) ? \"yes\" : \"no\"));",
          "",
          "[Added Lines]",
          "135:          ORANGEFS_LOOKUP_LINK_FOLLOW) ? \"yes\" : \"no\"));",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "160:    gossip_debug(GOSSIP_NAME_DEBUG,",
          "162:          \"%p for %s\\n\",",
          "163:          dentry,",
          "164:          dentry->d_name.name);",
          "",
          "[Removed Lines]",
          "161:          \"pvfs2_lookup: Adding *negative* dentry \"",
          "",
          "[Added Lines]",
          "161:          \"orangefs_lookup: Adding *negative* dentry \"",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "173:   goto out;",
          "174:  }",
          "177:  if (IS_ERR(inode)) {",
          "178:   gossip_debug(GOSSIP_NAME_DEBUG,",
          "179:    \"error %ld from iget\\n\", PTR_ERR(inode));",
          "",
          "[Removed Lines]",
          "176:  inode = pvfs2_iget(dir->i_sb, &new_op->downcall.resp.lookup.refn);",
          "",
          "[Added Lines]",
          "176:  inode = orangefs_iget(dir->i_sb, &new_op->downcall.resp.lookup.refn);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "202: }",
          "206: {",
          "207:  struct inode *inode = dentry->d_inode;",
          "210:  int ret;",
          "212:  gossip_debug(GOSSIP_NAME_DEBUG,",
          "",
          "[Removed Lines]",
          "205: static int pvfs2_unlink(struct inode *dir, struct dentry *dentry)",
          "208:  struct pvfs2_inode_s *parent = PVFS2_I(dir);",
          "209:  struct pvfs2_kernel_op_s *new_op;",
          "",
          "[Added Lines]",
          "205: static int orangefs_unlink(struct inode *dir, struct dentry *dentry)",
          "208:  struct orangefs_inode_s *parent = ORANGEFS_I(dir);",
          "209:  struct orangefs_kernel_op_s *new_op;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "218:        &parent->refn.khandle,",
          "219:        parent->refn.fs_id);",
          "222:  if (!new_op)",
          "223:   return -ENOMEM;",
          "225:  new_op->upcall.req.remove.parent_refn = parent->refn;",
          "226:  strncpy(new_op->upcall.req.remove.d_name, dentry->d_name.name,",
          "230:     get_interruptible_flag(inode));",
          "",
          "[Removed Lines]",
          "221:  new_op = op_alloc(PVFS2_VFS_OP_REMOVE);",
          "227:   PVFS2_NAME_LEN);",
          "229:  ret = service_operation(new_op, \"pvfs2_unlink\",",
          "",
          "[Added Lines]",
          "221:  new_op = op_alloc(ORANGEFS_VFS_OP_REMOVE);",
          "227:   ORANGEFS_NAME_LEN);",
          "229:  ret = service_operation(new_op, \"orangefs_unlink\",",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "242:  return ret;",
          "243: }",
          "246:     struct dentry *dentry,",
          "247:     const char *symname)",
          "248: {",
          "251:  struct inode *inode;",
          "252:  int mode = 755;",
          "253:  int ret;",
          "",
          "[Removed Lines]",
          "245: static int pvfs2_symlink(struct inode *dir,",
          "249:  struct pvfs2_inode_s *parent = PVFS2_I(dir);",
          "250:  struct pvfs2_kernel_op_s *new_op;",
          "",
          "[Added Lines]",
          "245: static int orangefs_symlink(struct inode *dir,",
          "249:  struct orangefs_inode_s *parent = ORANGEFS_I(dir);",
          "250:  struct orangefs_kernel_op_s *new_op;",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "257:  if (!symname)",
          "258:   return -EINVAL;",
          "261:  if (!new_op)",
          "262:   return -ENOMEM;",
          "264:  new_op->upcall.req.sym.parent_refn = parent->refn;",
          "266:  fill_default_sys_attrs(new_op->upcall.req.sym.attributes,",
          "268:           mode);",
          "270:  strncpy(new_op->upcall.req.sym.entry_name,",
          "271:   dentry->d_name.name,",
          "275:  ret = service_operation(new_op, __func__, get_interruptible_flag(dir));",
          "277:  gossip_debug(GOSSIP_NAME_DEBUG,",
          "279:        &new_op->downcall.resp.sym.refn.khandle,",
          "280:        new_op->downcall.resp.sym.refn.fs_id, ret);",
          "",
          "[Removed Lines]",
          "260:  new_op = op_alloc(PVFS2_VFS_OP_SYMLINK);",
          "267:           PVFS_TYPE_SYMLINK,",
          "272:   PVFS2_NAME_LEN);",
          "273:  strncpy(new_op->upcall.req.sym.target, symname, PVFS2_NAME_LEN);",
          "278:        \"Symlink Got PVFS2 handle %pU on fsid %d (ret=%d)\\n\",",
          "",
          "[Added Lines]",
          "260:  new_op = op_alloc(ORANGEFS_VFS_OP_SYMLINK);",
          "267:           ORANGEFS_TYPE_SYMLINK,",
          "272:   ORANGEFS_NAME_LEN);",
          "273:  strncpy(new_op->upcall.req.sym.target, symname, ORANGEFS_NAME_LEN);",
          "278:        \"Symlink Got ORANGEFS handle %pU on fsid %d (ret=%d)\\n\",",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "286:   goto out;",
          "287:  }",
          "290:     &new_op->downcall.resp.sym.refn);",
          "291:  if (IS_ERR(inode)) {",
          "292:   gossip_err",
          "294:   ret = PTR_ERR(inode);",
          "295:   goto out;",
          "296:  }",
          "",
          "[Removed Lines]",
          "289:  inode = pvfs2_new_inode(dir->i_sb, dir, S_IFLNK | mode, 0,",
          "293:       (\"*** Failed to allocate pvfs2 symlink inode\\n\");",
          "",
          "[Added Lines]",
          "289:  inode = orangefs_new_inode(dir->i_sb, dir, S_IFLNK | mode, 0,",
          "293:       (\"*** Failed to allocate orangefs symlink inode\\n\");",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "316:  return ret;",
          "317: }",
          "320: {",
          "323:  struct inode *inode;",
          "324:  int ret;",
          "327:  if (!new_op)",
          "328:   return -ENOMEM;",
          "330:  new_op->upcall.req.mkdir.parent_refn = parent->refn;",
          "332:  fill_default_sys_attrs(new_op->upcall.req.mkdir.attributes,",
          "335:  strncpy(new_op->upcall.req.mkdir.d_name,",
          "338:  ret = service_operation(new_op, __func__, get_interruptible_flag(dir));",
          "340:  gossip_debug(GOSSIP_NAME_DEBUG,",
          "342:        &new_op->downcall.resp.mkdir.refn.khandle,",
          "343:        new_op->downcall.resp.mkdir.refn.fs_id);",
          "",
          "[Removed Lines]",
          "319: static int pvfs2_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)",
          "321:  struct pvfs2_inode_s *parent = PVFS2_I(dir);",
          "322:  struct pvfs2_kernel_op_s *new_op;",
          "326:  new_op = op_alloc(PVFS2_VFS_OP_MKDIR);",
          "333:           PVFS_TYPE_DIRECTORY, mode);",
          "336:   dentry->d_name.name, PVFS2_NAME_LEN);",
          "341:        \"Mkdir Got PVFS2 handle %pU on fsid %d\\n\",",
          "",
          "[Added Lines]",
          "319: static int orangefs_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)",
          "321:  struct orangefs_inode_s *parent = ORANGEFS_I(dir);",
          "322:  struct orangefs_kernel_op_s *new_op;",
          "326:  new_op = op_alloc(ORANGEFS_VFS_OP_MKDIR);",
          "333:          ORANGEFS_TYPE_DIRECTORY, mode);",
          "336:   dentry->d_name.name, ORANGEFS_NAME_LEN);",
          "341:        \"Mkdir Got ORANGEFS handle %pU on fsid %d\\n\",",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "349:   goto out;",
          "350:  }",
          "353:     &new_op->downcall.resp.mkdir.refn);",
          "354:  if (IS_ERR(inode)) {",
          "356:   ret = PTR_ERR(inode);",
          "357:   goto out;",
          "358:  }",
          "",
          "[Removed Lines]",
          "352:  inode = pvfs2_new_inode(dir->i_sb, dir, S_IFDIR | mode, 0,",
          "355:   gossip_err(\"*** Failed to allocate pvfs2 dir inode\\n\");",
          "",
          "[Added Lines]",
          "352:  inode = orangefs_new_inode(dir->i_sb, dir, S_IFDIR | mode, 0,",
          "355:   gossip_err(\"*** Failed to allocate orangefs dir inode\\n\");",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "381:  return ret;",
          "382: }",
          "385:    struct dentry *old_dentry,",
          "386:    struct inode *new_dir,",
          "387:    struct dentry *new_dentry)",
          "388: {",
          "390:  int ret;",
          "392:  gossip_debug(GOSSIP_NAME_DEBUG,",
          "394:        old_dentry->d_parent->d_name.name,",
          "395:        old_dentry->d_name.name,",
          "396:        new_dentry->d_parent->d_name.name,",
          "397:        new_dentry->d_name.name,",
          "398:        d_count(new_dentry));",
          "401:  if (!new_op)",
          "402:   return -EINVAL;",
          "407:  strncpy(new_op->upcall.req.rename.d_old_name,",
          "408:   old_dentry->d_name.name,",
          "410:  strncpy(new_op->upcall.req.rename.d_new_name,",
          "411:   new_dentry->d_name.name,",
          "414:  ret = service_operation(new_op,",
          "416:     get_interruptible_flag(old_dentry->d_inode));",
          "418:  gossip_debug(GOSSIP_NAME_DEBUG,",
          "420:        ret);",
          "422:  if (new_dentry->d_inode)",
          "",
          "[Removed Lines]",
          "384: static int pvfs2_rename(struct inode *old_dir,",
          "389:  struct pvfs2_kernel_op_s *new_op;",
          "393:        \"pvfs2_rename: called (%s/%s => %s/%s) ct=%d\\n\",",
          "400:  new_op = op_alloc(PVFS2_VFS_OP_RENAME);",
          "404:  new_op->upcall.req.rename.old_parent_refn = PVFS2_I(old_dir)->refn;",
          "405:  new_op->upcall.req.rename.new_parent_refn = PVFS2_I(new_dir)->refn;",
          "409:   PVFS2_NAME_LEN);",
          "412:   PVFS2_NAME_LEN);",
          "415:     \"pvfs2_rename\",",
          "419:        \"pvfs2_rename: got downcall status %d\\n\",",
          "",
          "[Added Lines]",
          "384: static int orangefs_rename(struct inode *old_dir,",
          "389:  struct orangefs_kernel_op_s *new_op;",
          "393:        \"orangefs_rename: called (%s/%s => %s/%s) ct=%d\\n\",",
          "400:  new_op = op_alloc(ORANGEFS_VFS_OP_RENAME);",
          "404:  new_op->upcall.req.rename.old_parent_refn = ORANGEFS_I(old_dir)->refn;",
          "405:  new_op->upcall.req.rename.new_parent_refn = ORANGEFS_I(new_dir)->refn;",
          "409:   ORANGEFS_NAME_LEN);",
          "412:   ORANGEFS_NAME_LEN);",
          "415:     \"orangefs_rename\",",
          "419:        \"orangefs_rename: got downcall status %d\\n\",",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "426:  return ret;",
          "427: }",
          "442:  .setxattr = generic_setxattr,",
          "443:  .getxattr = generic_getxattr,",
          "444:  .removexattr = generic_removexattr,",
          "446: };",
          "",
          "[Removed Lines]",
          "430: struct inode_operations pvfs2_dir_inode_operations = {",
          "431:  .lookup = pvfs2_lookup,",
          "432:  .get_acl = pvfs2_get_acl,",
          "433:  .set_acl = pvfs2_set_acl,",
          "434:  .create = pvfs2_create,",
          "435:  .unlink = pvfs2_unlink,",
          "436:  .symlink = pvfs2_symlink,",
          "437:  .mkdir = pvfs2_mkdir,",
          "438:  .rmdir = pvfs2_unlink,",
          "439:  .rename = pvfs2_rename,",
          "440:  .setattr = pvfs2_setattr,",
          "441:  .getattr = pvfs2_getattr,",
          "445:  .listxattr = pvfs2_listxattr,",
          "",
          "[Added Lines]",
          "430: struct inode_operations orangefs_dir_inode_operations = {",
          "431:  .lookup = orangefs_lookup,",
          "432:  .get_acl = orangefs_get_acl,",
          "433:  .set_acl = orangefs_set_acl,",
          "434:  .create = orangefs_create,",
          "435:  .unlink = orangefs_unlink,",
          "436:  .symlink = orangefs_symlink,",
          "437:  .mkdir = orangefs_mkdir,",
          "438:  .rmdir = orangefs_unlink,",
          "439:  .rename = orangefs_rename,",
          "440:  .setattr = orangefs_setattr,",
          "441:  .getattr = orangefs_getattr,",
          "445:  .listxattr = orangefs_listxattr,",
          "",
          "---------------"
        ],
        "fs/orangefs/protocol.h||fs/orangefs/protocol.h": [
          "File: fs/orangefs/protocol.h -> fs/orangefs/protocol.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "20: #define ORANGEFS_KMOD_DEBUG_HELP_FILE \"debug-help\"",
          "21: #define ORANGEFS_KMOD_DEBUG_FILE \"kernel-debug\"",
          "22: #define ORANGEFS_CLIENT_DEBUG_FILE \"client-debug\"",
          "",
          "[Removed Lines]",
          "23: #define PVFS2_VERBOSE \"verbose\"",
          "24: #define PVFS2_ALL \"all\"",
          "27: #define PVFS2_VERSION_MAJOR 2",
          "28: #define PVFS2_VERSION_MINOR 9",
          "29: #define PVFS2_VERSION_SUB 0",
          "",
          "[Added Lines]",
          "23: #define ORANGEFS_VERBOSE \"verbose\"",
          "24: #define ORANGEFS_ALL \"all\"",
          "27: #define ORANGEFS_VERSION_MAJOR 2",
          "28: #define ORANGEFS_VERSION_MINOR 9",
          "29: #define ORANGEFS_VERSION_SUB 0",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "42:  unsigned char u[16];",
          "43: }  __aligned(8);",
          "50:  __s32 fs_id;",
          "51:  __s32 __pad1;",
          "52: };",
          "",
          "[Removed Lines]",
          "41: struct pvfs2_khandle {",
          "48: struct pvfs2_object_kref {",
          "49:  struct pvfs2_khandle khandle;",
          "",
          "[Added Lines]",
          "41: struct orangefs_khandle {",
          "48: struct orangefs_object_kref {",
          "49:  struct orangefs_khandle khandle;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "60: {",
          "61:  int i;",
          "",
          "[Removed Lines]",
          "58: static inline int PVFS_khandle_cmp(const struct pvfs2_khandle *kh1,",
          "59:        const struct pvfs2_khandle *kh2)",
          "",
          "[Added Lines]",
          "58: static inline int ORANGEFS_khandle_cmp(const struct orangefs_khandle *kh1,",
          "59:        const struct orangefs_khandle *kh2)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "70:  return 0;",
          "71: }",
          "74:        void *p, int size)",
          "75: {",
          "",
          "[Removed Lines]",
          "73: static inline void PVFS_khandle_to(const struct pvfs2_khandle *kh,",
          "",
          "[Added Lines]",
          "73: static inline void ORANGEFS_khandle_to(const struct orangefs_khandle *kh,",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "80: }",
          "83:          void *p, int size)",
          "84: {",
          "85:  memset(kh, 0, 16);",
          "",
          "[Removed Lines]",
          "82: static inline void PVFS_khandle_from(struct pvfs2_khandle *kh,",
          "",
          "[Added Lines]",
          "82: static inline void ORANGEFS_khandle_from(struct orangefs_khandle *kh,",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "88: }",
          "161: #define INT32_MAX (2147483647)",
          "237: };",
          "",
          "[Removed Lines]",
          "91: typedef __u32 PVFS_uid;",
          "92: typedef __u32 PVFS_gid;",
          "93: typedef __s32 PVFS_fs_id;",
          "94: typedef __u32 PVFS_permissions;",
          "95: typedef __u64 PVFS_time;",
          "96: typedef __s64 PVFS_size;",
          "97: typedef __u64 PVFS_flags;",
          "98: typedef __u64 PVFS_ds_position;",
          "99: typedef __s32 PVFS_error;",
          "100: typedef __s64 PVFS_offset;",
          "102: #define PVFS2_SUPER_MAGIC 0x20030528",
          "115: #define PVFS_ERROR_BIT (1 << 30)",
          "121: #define PVFS_NON_ERRNO_ERROR_BIT (1 << 29)",
          "128: #define PVFS_ERROR_CLASS_BITS 0x380",
          "131: #define PVFS_ERROR_NUMBER_BITS 0x7f",
          "136: #define PVFS_ECANCEL    (1|PVFS_NON_ERRNO_ERROR_BIT|PVFS_ERROR_BIT)",
          "137: #define PVFS_EDEVINIT   (2|PVFS_NON_ERRNO_ERROR_BIT|PVFS_ERROR_BIT)",
          "138: #define PVFS_EDETAIL    (3|PVFS_NON_ERRNO_ERROR_BIT|PVFS_ERROR_BIT)",
          "139: #define PVFS_EHOSTNTFD  (4|PVFS_NON_ERRNO_ERROR_BIT|PVFS_ERROR_BIT)",
          "140: #define PVFS_EADDRNTFD  (5|PVFS_NON_ERRNO_ERROR_BIT|PVFS_ERROR_BIT)",
          "141: #define PVFS_ENORECVR   (6|PVFS_NON_ERRNO_ERROR_BIT|PVFS_ERROR_BIT)",
          "142: #define PVFS_ETRYAGAIN  (7|PVFS_NON_ERRNO_ERROR_BIT|PVFS_ERROR_BIT)",
          "143: #define PVFS_ENOTPVFS   (8|PVFS_NON_ERRNO_ERROR_BIT|PVFS_ERROR_BIT)",
          "144: #define PVFS_ESECURITY  (9|PVFS_NON_ERRNO_ERROR_BIT|PVFS_ERROR_BIT)",
          "147: #define PVFS_O_EXECUTE (1 << 0)",
          "148: #define PVFS_O_WRITE   (1 << 1)",
          "149: #define PVFS_O_READ    (1 << 2)",
          "150: #define PVFS_G_EXECUTE (1 << 3)",
          "151: #define PVFS_G_WRITE   (1 << 4)",
          "152: #define PVFS_G_READ    (1 << 5)",
          "153: #define PVFS_U_EXECUTE (1 << 6)",
          "154: #define PVFS_U_WRITE   (1 << 7)",
          "155: #define PVFS_U_READ    (1 << 8)",
          "157: #define PVFS_G_SGID    (1 << 10)",
          "158: #define PVFS_U_SUID    (1 << 11)",
          "162: #define PVFS_ITERATE_START    (INT32_MAX - 1)",
          "163: #define PVFS_ITERATE_END      (INT32_MAX - 2)",
          "164: #define PVFS_ITERATE_NEXT     (INT32_MAX - 3)",
          "165: #define PVFS_READDIR_START PVFS_ITERATE_START",
          "166: #define PVFS_READDIR_END   PVFS_ITERATE_END",
          "167: #define PVFS_IMMUTABLE_FL FS_IMMUTABLE_FL",
          "168: #define PVFS_APPEND_FL    FS_APPEND_FL",
          "169: #define PVFS_NOATIME_FL   FS_NOATIME_FL",
          "170: #define PVFS_MIRROR_FL    0x01000000ULL",
          "171: #define PVFS_O_EXECUTE (1 << 0)",
          "172: #define PVFS_FS_ID_NULL       ((__s32)0)",
          "173: #define PVFS_ATTR_SYS_UID                   (1 << 0)",
          "174: #define PVFS_ATTR_SYS_GID                   (1 << 1)",
          "175: #define PVFS_ATTR_SYS_PERM                  (1 << 2)",
          "176: #define PVFS_ATTR_SYS_ATIME                 (1 << 3)",
          "177: #define PVFS_ATTR_SYS_CTIME                 (1 << 4)",
          "178: #define PVFS_ATTR_SYS_MTIME                 (1 << 5)",
          "179: #define PVFS_ATTR_SYS_TYPE                  (1 << 6)",
          "180: #define PVFS_ATTR_SYS_ATIME_SET             (1 << 7)",
          "181: #define PVFS_ATTR_SYS_MTIME_SET             (1 << 8)",
          "182: #define PVFS_ATTR_SYS_SIZE                  (1 << 20)",
          "183: #define PVFS_ATTR_SYS_LNK_TARGET            (1 << 24)",
          "184: #define PVFS_ATTR_SYS_DFILE_COUNT           (1 << 25)",
          "185: #define PVFS_ATTR_SYS_DIRENT_COUNT          (1 << 26)",
          "186: #define PVFS_ATTR_SYS_BLKSIZE               (1 << 28)",
          "187: #define PVFS_ATTR_SYS_MIRROR_COPIES_COUNT   (1 << 29)",
          "188: #define PVFS_ATTR_SYS_COMMON_ALL \\",
          "189:  (PVFS_ATTR_SYS_UID | \\",
          "190:   PVFS_ATTR_SYS_GID | \\",
          "191:   PVFS_ATTR_SYS_PERM | \\",
          "192:   PVFS_ATTR_SYS_ATIME | \\",
          "193:   PVFS_ATTR_SYS_CTIME | \\",
          "194:   PVFS_ATTR_SYS_MTIME | \\",
          "195:   PVFS_ATTR_SYS_TYPE)",
          "197: #define PVFS_ATTR_SYS_ALL_SETABLE  \\",
          "198: (PVFS_ATTR_SYS_COMMON_ALL-PVFS_ATTR_SYS_TYPE)",
          "200: #define PVFS_ATTR_SYS_ALL_NOHINT   \\",
          "201:  (PVFS_ATTR_SYS_COMMON_ALL  | \\",
          "202:   PVFS_ATTR_SYS_SIZE   | \\",
          "203:   PVFS_ATTR_SYS_LNK_TARGET  | \\",
          "204:   PVFS_ATTR_SYS_DFILE_COUNT  | \\",
          "205:   PVFS_ATTR_SYS_MIRROR_COPIES_COUNT | \\",
          "206:   PVFS_ATTR_SYS_DIRENT_COUNT  | \\",
          "207:   PVFS_ATTR_SYS_BLKSIZE)",
          "208: #define PVFS_XATTR_REPLACE 0x2",
          "209: #define PVFS_XATTR_CREATE  0x1",
          "210: #define PVFS_MAX_SERVER_ADDR_LEN 256",
          "211: #define PVFS_NAME_MAX            256",
          "221: #define PVFS_MAX_XATTR_NAMELEN   PVFS_NAME_MAX /* Not the same as",
          "225: #define PVFS_MAX_XATTR_VALUELEN  8192 /* Not the same as XATTR_SIZE_MAX",
          "228: #define PVFS_MAX_XATTR_LISTLEN   16 /* Not the same as XATTR_LIST_MAX",
          "234: enum PVFS_io_type {",
          "235:  PVFS_IO_READ = 1,",
          "236:  PVFS_IO_WRITE = 2",
          "",
          "[Added Lines]",
          "91: typedef __u32 ORANGEFS_uid;",
          "92: typedef __u32 ORANGEFS_gid;",
          "93: typedef __s32 ORANGEFS_fs_id;",
          "94: typedef __u32 ORANGEFS_permissions;",
          "95: typedef __u64 ORANGEFS_time;",
          "96: typedef __s64 ORANGEFS_size;",
          "97: typedef __u64 ORANGEFS_flags;",
          "98: typedef __u64 ORANGEFS_ds_position;",
          "99: typedef __s32 ORANGEFS_error;",
          "100: typedef __s64 ORANGEFS_offset;",
          "102: #define ORANGEFS_SUPER_MAGIC 0x20030528",
          "115: #define ORANGEFS_ERROR_BIT (1 << 30)",
          "121: #define ORANGEFS_NON_ERRNO_ERROR_BIT (1 << 29)",
          "128: #define ORANGEFS_ERROR_CLASS_BITS 0x380",
          "131: #define ORANGEFS_ERROR_NUMBER_BITS 0x7f",
          "136: #define ORANGEFS_ECANCEL    (1|ORANGEFS_NON_ERRNO_ERROR_BIT|ORANGEFS_ERROR_BIT)",
          "137: #define ORANGEFS_EDEVINIT   (2|ORANGEFS_NON_ERRNO_ERROR_BIT|ORANGEFS_ERROR_BIT)",
          "138: #define ORANGEFS_EDETAIL    (3|ORANGEFS_NON_ERRNO_ERROR_BIT|ORANGEFS_ERROR_BIT)",
          "139: #define ORANGEFS_EHOSTNTFD  (4|ORANGEFS_NON_ERRNO_ERROR_BIT|ORANGEFS_ERROR_BIT)",
          "140: #define ORANGEFS_EADDRNTFD  (5|ORANGEFS_NON_ERRNO_ERROR_BIT|ORANGEFS_ERROR_BIT)",
          "141: #define ORANGEFS_ENORECVR   (6|ORANGEFS_NON_ERRNO_ERROR_BIT|ORANGEFS_ERROR_BIT)",
          "142: #define ORANGEFS_ETRYAGAIN  (7|ORANGEFS_NON_ERRNO_ERROR_BIT|ORANGEFS_ERROR_BIT)",
          "143: #define ORANGEFS_ENOTPVFS   (8|ORANGEFS_NON_ERRNO_ERROR_BIT|ORANGEFS_ERROR_BIT)",
          "144: #define ORANGEFS_ESECURITY  (9|ORANGEFS_NON_ERRNO_ERROR_BIT|ORANGEFS_ERROR_BIT)",
          "147: #define ORANGEFS_O_EXECUTE (1 << 0)",
          "148: #define ORANGEFS_O_WRITE   (1 << 1)",
          "149: #define ORANGEFS_O_READ    (1 << 2)",
          "150: #define ORANGEFS_G_EXECUTE (1 << 3)",
          "151: #define ORANGEFS_G_WRITE   (1 << 4)",
          "152: #define ORANGEFS_G_READ    (1 << 5)",
          "153: #define ORANGEFS_U_EXECUTE (1 << 6)",
          "154: #define ORANGEFS_U_WRITE   (1 << 7)",
          "155: #define ORANGEFS_U_READ    (1 << 8)",
          "157: #define ORANGEFS_G_SGID    (1 << 10)",
          "158: #define ORANGEFS_U_SUID    (1 << 11)",
          "162: #define ORANGEFS_ITERATE_START    (INT32_MAX - 1)",
          "163: #define ORANGEFS_ITERATE_END      (INT32_MAX - 2)",
          "164: #define ORANGEFS_ITERATE_NEXT     (INT32_MAX - 3)",
          "165: #define ORANGEFS_READDIR_START ORANGEFS_ITERATE_START",
          "166: #define ORANGEFS_READDIR_END   ORANGEFS_ITERATE_END",
          "167: #define ORANGEFS_IMMUTABLE_FL FS_IMMUTABLE_FL",
          "168: #define ORANGEFS_APPEND_FL    FS_APPEND_FL",
          "169: #define ORANGEFS_NOATIME_FL   FS_NOATIME_FL",
          "170: #define ORANGEFS_MIRROR_FL    0x01000000ULL",
          "171: #define ORANGEFS_O_EXECUTE (1 << 0)",
          "172: #define ORANGEFS_FS_ID_NULL       ((__s32)0)",
          "173: #define ORANGEFS_ATTR_SYS_UID                   (1 << 0)",
          "174: #define ORANGEFS_ATTR_SYS_GID                   (1 << 1)",
          "175: #define ORANGEFS_ATTR_SYS_PERM                  (1 << 2)",
          "176: #define ORANGEFS_ATTR_SYS_ATIME                 (1 << 3)",
          "177: #define ORANGEFS_ATTR_SYS_CTIME                 (1 << 4)",
          "178: #define ORANGEFS_ATTR_SYS_MTIME                 (1 << 5)",
          "179: #define ORANGEFS_ATTR_SYS_TYPE                  (1 << 6)",
          "180: #define ORANGEFS_ATTR_SYS_ATIME_SET             (1 << 7)",
          "181: #define ORANGEFS_ATTR_SYS_MTIME_SET             (1 << 8)",
          "182: #define ORANGEFS_ATTR_SYS_SIZE                  (1 << 20)",
          "183: #define ORANGEFS_ATTR_SYS_LNK_TARGET            (1 << 24)",
          "184: #define ORANGEFS_ATTR_SYS_DFILE_COUNT           (1 << 25)",
          "185: #define ORANGEFS_ATTR_SYS_DIRENT_COUNT          (1 << 26)",
          "186: #define ORANGEFS_ATTR_SYS_BLKSIZE               (1 << 28)",
          "187: #define ORANGEFS_ATTR_SYS_MIRROR_COPIES_COUNT   (1 << 29)",
          "188: #define ORANGEFS_ATTR_SYS_COMMON_ALL \\",
          "189:  (ORANGEFS_ATTR_SYS_UID | \\",
          "190:   ORANGEFS_ATTR_SYS_GID | \\",
          "191:   ORANGEFS_ATTR_SYS_PERM | \\",
          "192:   ORANGEFS_ATTR_SYS_ATIME | \\",
          "193:   ORANGEFS_ATTR_SYS_CTIME | \\",
          "194:   ORANGEFS_ATTR_SYS_MTIME | \\",
          "195:   ORANGEFS_ATTR_SYS_TYPE)",
          "197: #define ORANGEFS_ATTR_SYS_ALL_SETABLE  \\",
          "198: (ORANGEFS_ATTR_SYS_COMMON_ALL-ORANGEFS_ATTR_SYS_TYPE)",
          "200: #define ORANGEFS_ATTR_SYS_ALL_NOHINT   \\",
          "201:  (ORANGEFS_ATTR_SYS_COMMON_ALL  | \\",
          "202:   ORANGEFS_ATTR_SYS_SIZE   | \\",
          "203:   ORANGEFS_ATTR_SYS_LNK_TARGET  | \\",
          "204:   ORANGEFS_ATTR_SYS_DFILE_COUNT  | \\",
          "205:   ORANGEFS_ATTR_SYS_MIRROR_COPIES_COUNT | \\",
          "206:   ORANGEFS_ATTR_SYS_DIRENT_COUNT  | \\",
          "207:   ORANGEFS_ATTR_SYS_BLKSIZE)",
          "208: #define ORANGEFS_XATTR_REPLACE 0x2",
          "209: #define ORANGEFS_XATTR_CREATE  0x1",
          "210: #define ORANGEFS_MAX_SERVER_ADDR_LEN 256",
          "211: #define ORANGEFS_NAME_MAX                256",
          "221: #define ORANGEFS_MAX_XATTR_NAMELEN   ORANGEFS_NAME_MAX /* Not the same as",
          "225: #define ORANGEFS_MAX_XATTR_VALUELEN  8192 /* Not the same as XATTR_SIZE_MAX",
          "228: #define ORANGEFS_MAX_XATTR_LISTLEN   16 /* Not the same as XATTR_LIST_MAX",
          "234: enum ORANGEFS_io_type {",
          "235:  ORANGEFS_IO_READ = 1,",
          "236:  ORANGEFS_IO_WRITE = 2",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "252: };",
          "259:  __u32 buf_size;",
          "260:  unsigned char *buf;",
          "261: };",
          "",
          "[Removed Lines]",
          "244: enum pvfs2_ds_type {",
          "245:  PVFS_TYPE_NONE = 0,",
          "246:  PVFS_TYPE_METAFILE = (1 << 0),",
          "247:  PVFS_TYPE_DATAFILE = (1 << 1),",
          "248:  PVFS_TYPE_DIRECTORY = (1 << 2),",
          "249:  PVFS_TYPE_SYMLINK = (1 << 3),",
          "250:  PVFS_TYPE_DIRDATA = (1 << 4),",
          "258: struct PVFS_certificate {",
          "",
          "[Added Lines]",
          "244: enum orangefs_ds_type {",
          "245:  ORANGEFS_TYPE_NONE = 0,",
          "246:  ORANGEFS_TYPE_METAFILE = (1 << 0),",
          "247:  ORANGEFS_TYPE_DATAFILE = (1 << 1),",
          "248:  ORANGEFS_TYPE_DIRECTORY = (1 << 2),",
          "249:  ORANGEFS_TYPE_SYMLINK = (1 << 3),",
          "250:  ORANGEFS_TYPE_DIRDATA = (1 << 4),",
          "258: struct ORANGEFS_certificate {",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "267: struct PVFS_credential {",
          "",
          "[Added Lines]",
          "267: struct ORANGEFS_credential {",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "276: };",
          "278:         sizeof(__u32)  + \\",
          "287:  __s32 val_sz;",
          "289: };",
          "294:  __u32 owner;",
          "295:  __u32 group;",
          "296:  __u32 perms;",
          "",
          "[Removed Lines]",
          "277: #define extra_size_PVFS_credential (PVFS_REQ_LIMIT_GROUPS * \\",
          "279:         PVFS_REQ_LIMIT_ISSUER + \\",
          "280:         PVFS_REQ_LIMIT_SIGNATURE + \\",
          "281:         extra_size_PVFS_certificate)",
          "284: struct PVFS_keyval_pair {",
          "285:  char key[PVFS_MAX_XATTR_NAMELEN];",
          "288:  char val[PVFS_MAX_XATTR_VALUELEN];",
          "293: struct PVFS_sys_attr_s {",
          "",
          "[Added Lines]",
          "277: #define extra_size_ORANGEFS_credential (ORANGEFS_REQ_LIMIT_GROUPS * \\",
          "279:         ORANGEFS_REQ_LIMIT_ISSUER + \\",
          "280:         ORANGEFS_REQ_LIMIT_SIGNATURE + \\",
          "281:         extra_size_ORANGEFS_certificate)",
          "284: struct ORANGEFS_keyval_pair {",
          "285:  char key[ORANGEFS_MAX_XATTR_NAMELEN];",
          "288:  char val[ORANGEFS_MAX_XATTR_VALUELEN];",
          "293: struct ORANGEFS_sys_attr_s {",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "323:  char *dist_params;",
          "325:  __s64 dirent_count;",
          "327:  __u64 flags;",
          "328:  __u32 mask;",
          "329:  __s64 blksize;",
          "330: };",
          "338: struct dev_mask_info_s {",
          "339:  enum {",
          "340:   KERNEL_MASK,",
          "",
          "[Removed Lines]",
          "326:  enum pvfs2_ds_type objtype;",
          "332: #define PVFS2_LOOKUP_LINK_NO_FOLLOW 0",
          "333: #define PVFS2_LOOKUP_LINK_FOLLOW    1",
          "",
          "[Added Lines]",
          "326:  enum orangefs_ds_type objtype;",
          "332: #define ORANGEFS_LOOKUP_LINK_NO_FOLLOW 0",
          "333: #define ORANGEFS_LOOKUP_LINK_FOLLOW    1",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "349: };",
          "355: #include \"pvfs2-debug.h\"",
          "",
          "[Removed Lines]",
          "352: __s32 PVFS_util_translate_mode(int mode);",
          "",
          "[Added Lines]",
          "352: __s32 ORANGEFS_util_translate_mode(int mode);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "359: #define lld(x) (long long)(x)",
          "366: #define DEV_GET_MAGIC           0x1",
          "367: #define DEV_GET_MAX_UPSIZE      0x2",
          "",
          "[Removed Lines]",
          "362: #define PVFS_DEV_MAGIC 'k'",
          "364: #define PVFS2_READDIR_DEFAULT_DESC_COUNT  5",
          "",
          "[Added Lines]",
          "362: #define ORANGEFS_DEV_MAGIC 'k'",
          "364: #define ORANGEFS_READDIR_DEFAULT_DESC_COUNT  5",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "378: enum {",
          "389:         DEV_CLIENT_MASK,",
          "390:         struct dev_mask2_info_s),",
          "392:           DEV_CLIENT_STRING,",
          "393:           char *),",
          "395: };",
          "412:  void *ptr;",
          "413:  __s32 total_size;",
          "414:  __s32 size;",
          "",
          "[Removed Lines]",
          "379:  PVFS_DEV_GET_MAGIC = _IOW(PVFS_DEV_MAGIC, DEV_GET_MAGIC, __s32),",
          "380:  PVFS_DEV_GET_MAX_UPSIZE =",
          "381:      _IOW(PVFS_DEV_MAGIC, DEV_GET_MAX_UPSIZE, __s32),",
          "382:  PVFS_DEV_GET_MAX_DOWNSIZE =",
          "383:      _IOW(PVFS_DEV_MAGIC, DEV_GET_MAX_DOWNSIZE, __s32),",
          "384:  PVFS_DEV_MAP = _IO(PVFS_DEV_MAGIC, DEV_MAP),",
          "385:  PVFS_DEV_REMOUNT_ALL = _IO(PVFS_DEV_MAGIC, DEV_REMOUNT_ALL),",
          "386:  PVFS_DEV_DEBUG = _IOR(PVFS_DEV_MAGIC, DEV_DEBUG, __s32),",
          "387:  PVFS_DEV_UPSTREAM = _IOW(PVFS_DEV_MAGIC, DEV_UPSTREAM, int),",
          "388:  PVFS_DEV_CLIENT_MASK = _IOW(PVFS_DEV_MAGIC,",
          "391:  PVFS_DEV_CLIENT_STRING = _IOW(PVFS_DEV_MAGIC,",
          "394:  PVFS_DEV_MAXNR = DEV_MAX_NR,",
          "401: #define PVFS_KERNEL_PROTO_VERSION 0",
          "411: struct PVFS_dev_map_desc {",
          "",
          "[Added Lines]",
          "379:  ORANGEFS_DEV_GET_MAGIC = _IOW(ORANGEFS_DEV_MAGIC, DEV_GET_MAGIC, __s32),",
          "380:  ORANGEFS_DEV_GET_MAX_UPSIZE =",
          "381:      _IOW(ORANGEFS_DEV_MAGIC, DEV_GET_MAX_UPSIZE, __s32),",
          "382:  ORANGEFS_DEV_GET_MAX_DOWNSIZE =",
          "383:      _IOW(ORANGEFS_DEV_MAGIC, DEV_GET_MAX_DOWNSIZE, __s32),",
          "384:  ORANGEFS_DEV_MAP = _IO(ORANGEFS_DEV_MAGIC, DEV_MAP),",
          "385:  ORANGEFS_DEV_REMOUNT_ALL = _IO(ORANGEFS_DEV_MAGIC, DEV_REMOUNT_ALL),",
          "386:  ORANGEFS_DEV_DEBUG = _IOR(ORANGEFS_DEV_MAGIC, DEV_DEBUG, __s32),",
          "387:  ORANGEFS_DEV_UPSTREAM = _IOW(ORANGEFS_DEV_MAGIC, DEV_UPSTREAM, int),",
          "388:  ORANGEFS_DEV_CLIENT_MASK = _IOW(ORANGEFS_DEV_MAGIC,",
          "391:  ORANGEFS_DEV_CLIENT_STRING = _IOW(ORANGEFS_DEV_MAGIC,",
          "394:  ORANGEFS_DEV_MAXNR = DEV_MAX_NR,",
          "401: #define ORANGEFS_KERNEL_PROTO_VERSION 0",
          "411: struct ORANGEFS_dev_map_desc {",
          "",
          "---------------"
        ],
        "fs/orangefs/pvfs2-bufmap.c||fs/orangefs/pvfs2-bufmap.c": [
          "File: fs/orangefs/pvfs2-bufmap.c -> fs/orangefs/pvfs2-bufmap.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "7: #include \"pvfs2-kernel.h\"",
          "8: #include \"pvfs2-bufmap.h\"",
          "13:  atomic_t refcnt;",
          "15:  int desc_size;",
          "",
          "[Removed Lines]",
          "10: DECLARE_WAIT_QUEUE_HEAD(pvfs2_bufmap_init_waitq);",
          "12: static struct pvfs2_bufmap {",
          "",
          "[Added Lines]",
          "10: DECLARE_WAIT_QUEUE_HEAD(orangefs_bufmap_init_waitq);",
          "12: static struct orangefs_bufmap {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "19:  int page_count;",
          "21:  struct page **page_array;",
          "25:  int *buffer_index_array;",
          "26:  spinlock_t buffer_index_lock;",
          "30:  spinlock_t readdir_index_lock;",
          "35: static void",
          "37: {",
          "38:  int i;",
          "",
          "[Removed Lines]",
          "22:  struct pvfs_bufmap_desc *desc_array;",
          "29:  int readdir_index_array[PVFS2_READDIR_DEFAULT_DESC_COUNT];",
          "31: } *__pvfs2_bufmap;",
          "33: static DEFINE_SPINLOCK(pvfs2_bufmap_lock);",
          "36: pvfs2_bufmap_unmap(struct pvfs2_bufmap *bufmap)",
          "",
          "[Added Lines]",
          "22:  struct orangefs_bufmap_desc *desc_array;",
          "29:  int readdir_index_array[ORANGEFS_READDIR_DEFAULT_DESC_COUNT];",
          "31: } *__orangefs_bufmap;",
          "33: static DEFINE_SPINLOCK(orangefs_bufmap_lock);",
          "36: orangefs_bufmap_unmap(struct orangefs_bufmap *bufmap)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "42: }",
          "44: static void",
          "46: {",
          "47:  kfree(bufmap->page_array);",
          "48:  kfree(bufmap->desc_array);",
          "",
          "[Removed Lines]",
          "45: pvfs2_bufmap_free(struct pvfs2_bufmap *bufmap)",
          "",
          "[Added Lines]",
          "45: orangefs_bufmap_free(struct orangefs_bufmap *bufmap)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "50:  kfree(bufmap);",
          "51: }",
          "54: {",
          "60:   atomic_inc(&bufmap->refcnt);",
          "61:  }",
          "63:  return bufmap;",
          "64: }",
          "67: {",
          "74:  }",
          "75: }",
          "78: {",
          "80:  int size = bufmap ? bufmap->desc_size : 0;",
          "83:  return size;",
          "84: }",
          "87: {",
          "89:  int shift = bufmap ? bufmap->desc_shift : 0;",
          "92:  return shift;",
          "93: }",
          "",
          "[Removed Lines]",
          "53: struct pvfs2_bufmap *pvfs2_bufmap_ref(void)",
          "55:  struct pvfs2_bufmap *bufmap = NULL;",
          "57:  spin_lock(&pvfs2_bufmap_lock);",
          "58:  if (__pvfs2_bufmap) {",
          "59:   bufmap = __pvfs2_bufmap;",
          "62:  spin_unlock(&pvfs2_bufmap_lock);",
          "66: void pvfs2_bufmap_unref(struct pvfs2_bufmap *bufmap)",
          "68:  if (atomic_dec_and_lock(&bufmap->refcnt, &pvfs2_bufmap_lock)) {",
          "69:   __pvfs2_bufmap = NULL;",
          "70:   spin_unlock(&pvfs2_bufmap_lock);",
          "72:   pvfs2_bufmap_unmap(bufmap);",
          "73:   pvfs2_bufmap_free(bufmap);",
          "77: inline int pvfs_bufmap_size_query(void)",
          "79:  struct pvfs2_bufmap *bufmap = pvfs2_bufmap_ref();",
          "82:  pvfs2_bufmap_unref(bufmap);",
          "86: inline int pvfs_bufmap_shift_query(void)",
          "88:  struct pvfs2_bufmap *bufmap = pvfs2_bufmap_ref();",
          "91:  pvfs2_bufmap_unref(bufmap);",
          "",
          "[Added Lines]",
          "53: struct orangefs_bufmap *orangefs_bufmap_ref(void)",
          "55:  struct orangefs_bufmap *bufmap = NULL;",
          "57:  spin_lock(&orangefs_bufmap_lock);",
          "58:  if (__orangefs_bufmap) {",
          "59:   bufmap = __orangefs_bufmap;",
          "62:  spin_unlock(&orangefs_bufmap_lock);",
          "66: void orangefs_bufmap_unref(struct orangefs_bufmap *bufmap)",
          "68:  if (atomic_dec_and_lock(&bufmap->refcnt, &orangefs_bufmap_lock)) {",
          "69:   __orangefs_bufmap = NULL;",
          "70:   spin_unlock(&orangefs_bufmap_lock);",
          "72:   orangefs_bufmap_unmap(bufmap);",
          "73:   orangefs_bufmap_free(bufmap);",
          "77: inline int orangefs_bufmap_size_query(void)",
          "79:  struct orangefs_bufmap *bufmap = orangefs_bufmap_ref();",
          "82:  orangefs_bufmap_unref(bufmap);",
          "86: inline int orangefs_bufmap_shift_query(void)",
          "88:  struct orangefs_bufmap *bufmap = orangefs_bufmap_ref();",
          "91:  orangefs_bufmap_unref(bufmap);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "106: int get_bufmap_init(void)",
          "107: {",
          "109: }",
          "114: {",
          "117:  bufmap = kzalloc(sizeof(*bufmap), GFP_KERNEL);",
          "118:  if (!bufmap)",
          "",
          "[Removed Lines]",
          "108:  return __pvfs2_bufmap ? 1 : 0;",
          "112: static struct pvfs2_bufmap *",
          "113: pvfs2_bufmap_alloc(struct PVFS_dev_map_desc *user_desc)",
          "115:  struct pvfs2_bufmap *bufmap;",
          "",
          "[Added Lines]",
          "108:  return __orangefs_bufmap ? 1 : 0;",
          "112: static struct orangefs_bufmap *",
          "113: orangefs_bufmap_alloc(struct ORANGEFS_dev_map_desc *user_desc)",
          "115:  struct orangefs_bufmap *bufmap;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "128:  bufmap->buffer_index_array =",
          "129:   kcalloc(bufmap->desc_count, sizeof(int), GFP_KERNEL);",
          "130:  if (!bufmap->buffer_index_array) {",
          "132:     bufmap->desc_count);",
          "133:   goto out_free_bufmap;",
          "134:  }",
          "135:  spin_lock_init(&bufmap->readdir_index_lock);",
          "137:  bufmap->desc_array =",
          "139:    GFP_KERNEL);",
          "140:  if (!bufmap->desc_array) {",
          "142:     bufmap->desc_count);",
          "143:   goto out_free_index_array;",
          "144:  }",
          "",
          "[Removed Lines]",
          "131:   gossip_err(\"pvfs2: could not allocate %d buffer indices\\n\",",
          "138:   kcalloc(bufmap->desc_count, sizeof(struct pvfs_bufmap_desc),",
          "141:   gossip_err(\"pvfs2: could not allocate %d descriptors\\n\",",
          "",
          "[Added Lines]",
          "131:   gossip_err(\"orangefs: could not allocate %d buffer indices\\n\",",
          "138:   kcalloc(bufmap->desc_count, sizeof(struct orangefs_bufmap_desc),",
          "141:   gossip_err(\"orangefs: could not allocate %d descriptors\\n\",",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "164: }",
          "166: static int",
          "169: {",
          "170:  int pages_per_desc = bufmap->desc_size / PAGE_SIZE;",
          "171:  int offset = 0, ret, i;",
          "",
          "[Removed Lines]",
          "167: pvfs2_bufmap_map(struct pvfs2_bufmap *bufmap,",
          "168:   struct PVFS_dev_map_desc *user_desc)",
          "",
          "[Added Lines]",
          "167: orangefs_bufmap_map(struct orangefs_bufmap *bufmap,",
          "168:   struct ORANGEFS_dev_map_desc *user_desc)",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "178:   return ret;",
          "180:  if (ret != bufmap->page_count) {",
          "182:     bufmap->page_count, ret);",
          "184:   for (i = 0; i < ret; i++) {",
          "",
          "[Removed Lines]",
          "181:   gossip_err(\"pvfs2 error: asked for %d pages, only got %d.\\n\",",
          "",
          "[Added Lines]",
          "181:   gossip_err(\"orangefs error: asked for %d pages, only got %d.\\n\",",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "210: }",
          "220: {",
          "222:  int ret = -EINVAL;",
          "224:  gossip_debug(GOSSIP_BUFMAP_DEBUG,",
          "226:        \"%p) sz (%d) cnt(%d).\\n\",",
          "227:        user_desc->ptr,",
          "228:        user_desc->size,",
          "",
          "[Removed Lines]",
          "219: int pvfs_bufmap_initialize(struct PVFS_dev_map_desc *user_desc)",
          "221:  struct pvfs2_bufmap *bufmap;",
          "225:        \"pvfs_bufmap_initialize: called (ptr (\"",
          "",
          "[Added Lines]",
          "219: int orangefs_bufmap_initialize(struct ORANGEFS_dev_map_desc *user_desc)",
          "221:  struct orangefs_bufmap *bufmap;",
          "225:        \"orangefs_bufmap_initialize: called (ptr (\"",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "235:  if (PAGE_ALIGN((unsigned long)user_desc->ptr) !=",
          "236:      (unsigned long)user_desc->ptr) {",
          "238:       user_desc->ptr);",
          "239:   goto out;",
          "240:  }",
          "242:  if (PAGE_ALIGN(((unsigned long)user_desc->ptr + user_desc->total_size))",
          "243:      != (unsigned long)(user_desc->ptr + user_desc->total_size)) {",
          "245:       user_desc->ptr,",
          "246:       user_desc->total_size);",
          "247:   goto out;",
          "248:  }",
          "250:  if (user_desc->total_size != (user_desc->size * user_desc->count)) {",
          "252:       user_desc->total_size,",
          "253:       user_desc->size,",
          "254:       user_desc->count);",
          "",
          "[Removed Lines]",
          "237:   gossip_err(\"pvfs2 error: memory alignment (front). %p\\n\",",
          "244:   gossip_err(\"pvfs2 error: memory alignment (back).(%p + %d)\\n\",",
          "251:   gossip_err(\"pvfs2 error: user provided an oddly sized buffer: (%d, %d, %d)\\n\",",
          "",
          "[Added Lines]",
          "237:   gossip_err(\"orangefs error: memory alignment (front). %p\\n\",",
          "244:   gossip_err(\"orangefs error: memory alignment (back).(%p + %d)\\n\",",
          "251:   gossip_err(\"orangefs error: user provided an oddly sized buffer: (%d, %d, %d)\\n\",",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "256:  }",
          "258:  if ((user_desc->size % PAGE_SIZE) != 0) {",
          "260:       user_desc->size);",
          "261:   goto out;",
          "262:  }",
          "264:  ret = -ENOMEM;",
          "266:  if (!bufmap)",
          "267:   goto out;",
          "270:  if (ret)",
          "271:   goto out_free_bufmap;",
          "278:   ret = -EALREADY;",
          "279:   goto out_unmap_bufmap;",
          "280:  }",
          "",
          "[Removed Lines]",
          "259:   gossip_err(\"pvfs2 error: bufmap size not page size divisible (%d).\\n\",",
          "265:  bufmap = pvfs2_bufmap_alloc(user_desc);",
          "269:  ret = pvfs2_bufmap_map(bufmap, user_desc);",
          "274:  spin_lock(&pvfs2_bufmap_lock);",
          "275:  if (__pvfs2_bufmap) {",
          "276:   spin_unlock(&pvfs2_bufmap_lock);",
          "277:   gossip_err(\"pvfs2: error: bufmap already initialized.\\n\");",
          "281:  __pvfs2_bufmap = bufmap;",
          "282:  spin_unlock(&pvfs2_bufmap_lock);",
          "",
          "[Added Lines]",
          "259:   gossip_err(\"orangefs error: bufmap size not page size divisible (%d).\\n\",",
          "265:  bufmap = orangefs_bufmap_alloc(user_desc);",
          "269:  ret = orangefs_bufmap_map(bufmap, user_desc);",
          "274:  spin_lock(&orangefs_bufmap_lock);",
          "275:  if (__orangefs_bufmap) {",
          "276:   spin_unlock(&orangefs_bufmap_lock);",
          "277:   gossip_err(\"orangefs: error: bufmap already initialized.\\n\");",
          "281:  __orangefs_bufmap = bufmap;",
          "282:  spin_unlock(&orangefs_bufmap_lock);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "296:  gossip_debug(GOSSIP_BUFMAP_DEBUG,",
          "298:  return 0;",
          "300: out_unmap_bufmap:",
          "302: out_free_bufmap:",
          "304: out:",
          "305:  return ret;",
          "306: }",
          "317: {",
          "321:  gossip_debug(GOSSIP_BUFMAP_DEBUG,",
          "323: }",
          "325: struct slot_args {",
          "",
          "[Removed Lines]",
          "294:  wake_up_interruptible(&pvfs2_bufmap_init_waitq);",
          "297:        \"pvfs_bufmap_initialize: exiting normally\\n\");",
          "301:  pvfs2_bufmap_unmap(bufmap);",
          "303:  pvfs2_bufmap_free(bufmap);",
          "316: void pvfs_bufmap_finalize(void)",
          "318:  gossip_debug(GOSSIP_BUFMAP_DEBUG, \"pvfs2_bufmap_finalize: called\\n\");",
          "319:  BUG_ON(!__pvfs2_bufmap);",
          "320:  pvfs2_bufmap_unref(__pvfs2_bufmap);",
          "322:        \"pvfs2_bufmap_finalize: exiting normally\\n\");",
          "",
          "[Added Lines]",
          "294:  wake_up_interruptible(&orangefs_bufmap_init_waitq);",
          "297:        \"orangefs_bufmap_initialize: exiting normally\\n\");",
          "301:  orangefs_bufmap_unmap(bufmap);",
          "303:  orangefs_bufmap_free(bufmap);",
          "316: void orangefs_bufmap_finalize(void)",
          "318:  gossip_debug(GOSSIP_BUFMAP_DEBUG, \"orangefs_bufmap_finalize: called\\n\");",
          "319:  BUG_ON(!__orangefs_bufmap);",
          "320:  orangefs_bufmap_unref(__orangefs_bufmap);",
          "322:        \"orangefs_bufmap_finalize: exiting normally\\n\");",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "377:    continue;",
          "378:   }",
          "381:         __func__);",
          "382:   ret = -EINTR;",
          "383:   break;",
          "",
          "[Removed Lines]",
          "380:   gossip_debug(GOSSIP_BUFMAP_DEBUG, \"pvfs2: %s interrupted.\\n\",",
          "",
          "[Added Lines]",
          "380:   gossip_debug(GOSSIP_BUFMAP_DEBUG, \"orangefs: %s interrupted.\\n\",",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "406: }",
          "417: {",
          "419:  struct slot_args slargs;",
          "420:  int ret;",
          "422:  if (!bufmap) {",
          "424:   return -EIO;",
          "425:  }",
          "",
          "[Removed Lines]",
          "416: int pvfs_bufmap_get(struct pvfs2_bufmap **mapp, int *buffer_index)",
          "418:  struct pvfs2_bufmap *bufmap = pvfs2_bufmap_ref();",
          "423:   gossip_err(\"pvfs2: please confirm that pvfs2-client daemon is running.\\n\");",
          "",
          "[Added Lines]",
          "416: int orangefs_bufmap_get(struct orangefs_bufmap **mapp, int *buffer_index)",
          "418:  struct orangefs_bufmap *bufmap = orangefs_bufmap_ref();",
          "423:   gossip_err(\"orangefs: please confirm that pvfs2-client daemon is running.\\n\");",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "430:  slargs.slot_wq = &bufmap_waitq;",
          "431:  ret = wait_for_a_slot(&slargs, buffer_index);",
          "432:  if (ret)",
          "435:  return ret;",
          "436: }",
          "446: {",
          "447:  struct slot_args slargs;",
          "",
          "[Removed Lines]",
          "433:   pvfs2_bufmap_unref(bufmap);",
          "445: void pvfs_bufmap_put(struct pvfs2_bufmap *bufmap, int buffer_index)",
          "",
          "[Added Lines]",
          "433:   orangefs_bufmap_unref(bufmap);",
          "445: void orangefs_bufmap_put(struct orangefs_bufmap *bufmap, int buffer_index)",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "451:  slargs.slot_lock = &bufmap->buffer_index_lock;",
          "452:  slargs.slot_wq = &bufmap_waitq;",
          "453:  put_back_slot(&slargs, buffer_index);",
          "455: }",
          "",
          "[Removed Lines]",
          "454:  pvfs2_bufmap_unref(bufmap);",
          "",
          "[Added Lines]",
          "454:  orangefs_bufmap_unref(bufmap);",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "469: {",
          "471:  struct slot_args slargs;",
          "472:  int ret;",
          "474:  if (!bufmap) {",
          "476:   return -EIO;",
          "477:  }",
          "480:  slargs.slot_array = bufmap->readdir_index_array;",
          "481:  slargs.slot_lock = &bufmap->readdir_index_lock;",
          "482:  slargs.slot_wq = &readdir_waitq;",
          "483:  ret = wait_for_a_slot(&slargs, buffer_index);",
          "484:  if (ret)",
          "487:  return ret;",
          "488: }",
          "491: {",
          "492:  struct slot_args slargs;",
          "495:  slargs.slot_array = bufmap->readdir_index_array;",
          "496:  slargs.slot_lock = &bufmap->readdir_index_lock;",
          "497:  slargs.slot_wq = &readdir_waitq;",
          "498:  put_back_slot(&slargs, buffer_index);",
          "500: }",
          "503:     struct iov_iter *iter,",
          "504:     int buffer_index,",
          "505:     size_t size)",
          "506: {",
          "508:  int i;",
          "510:  gossip_debug(GOSSIP_BUFMAP_DEBUG,",
          "",
          "[Removed Lines]",
          "468: int readdir_index_get(struct pvfs2_bufmap **mapp, int *buffer_index)",
          "470:  struct pvfs2_bufmap *bufmap = pvfs2_bufmap_ref();",
          "475:   gossip_err(\"pvfs2: please confirm that pvfs2-client daemon is running.\\n\");",
          "479:  slargs.slot_count = PVFS2_READDIR_DEFAULT_DESC_COUNT;",
          "485:   pvfs2_bufmap_unref(bufmap);",
          "490: void readdir_index_put(struct pvfs2_bufmap *bufmap, int buffer_index)",
          "494:  slargs.slot_count = PVFS2_READDIR_DEFAULT_DESC_COUNT;",
          "499:  pvfs2_bufmap_unref(bufmap);",
          "502: int pvfs_bufmap_copy_from_iovec(struct pvfs2_bufmap *bufmap,",
          "507:  struct pvfs_bufmap_desc *to = &bufmap->desc_array[buffer_index];",
          "",
          "[Added Lines]",
          "468: int readdir_index_get(struct orangefs_bufmap **mapp, int *buffer_index)",
          "470:  struct orangefs_bufmap *bufmap = orangefs_bufmap_ref();",
          "475:   gossip_err(\"orangefs: please confirm that pvfs2-client daemon is running.\\n\");",
          "479:  slargs.slot_count = ORANGEFS_READDIR_DEFAULT_DESC_COUNT;",
          "485:   orangefs_bufmap_unref(bufmap);",
          "490: void readdir_index_put(struct orangefs_bufmap *bufmap, int buffer_index)",
          "494:  slargs.slot_count = ORANGEFS_READDIR_DEFAULT_DESC_COUNT;",
          "499:  orangefs_bufmap_unref(bufmap);",
          "502: int orangefs_bufmap_copy_from_iovec(struct orangefs_bufmap *bufmap,",
          "507:  struct orangefs_bufmap_desc *to = &bufmap->desc_array[buffer_index];",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "535:         struct iov_iter *iter,",
          "536:         int buffer_index,",
          "537:         size_t size)",
          "538: {",
          "540:  int i;",
          "542:  gossip_debug(GOSSIP_BUFMAP_DEBUG,",
          "",
          "[Removed Lines]",
          "534: int pvfs_bufmap_copy_to_iovec(struct pvfs2_bufmap *bufmap,",
          "539:  struct pvfs_bufmap_desc *from = &bufmap->desc_array[buffer_index];",
          "",
          "[Added Lines]",
          "534: int orangefs_bufmap_copy_to_iovec(struct orangefs_bufmap *bufmap,",
          "539:  struct orangefs_bufmap_desc *from = &bufmap->desc_array[buffer_index];",
          "",
          "---------------"
        ],
        "fs/orangefs/pvfs2-bufmap.h||fs/orangefs/pvfs2-bufmap.h": [
          "File: fs/orangefs/pvfs2-bufmap.h -> fs/orangefs/pvfs2-bufmap.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "15:  struct list_head list_link;",
          "16: };",
          "33: int get_bufmap_init(void);",
          "46:     struct iov_iter *iter,",
          "47:     int buffer_index,",
          "48:     size_t size);",
          "51:          struct iov_iter *iter,",
          "52:          int buffer_index,",
          "53:          size_t size);",
          "56:         struct iovec *iovec,",
          "57:         unsigned long nr_segs,",
          "59:         int buffer_index,",
          "60:         size_t bytes_to_be_copied);",
          "",
          "[Removed Lines]",
          "7: #ifndef __PVFS2_BUFMAP_H",
          "8: #define __PVFS2_BUFMAP_H",
          "11: struct pvfs_bufmap_desc {",
          "18: struct pvfs2_bufmap;",
          "20: struct pvfs2_bufmap *pvfs2_bufmap_ref(void);",
          "21: void pvfs2_bufmap_unref(struct pvfs2_bufmap *bufmap);",
          "27: int pvfs_bufmap_size_query(void);",
          "29: int pvfs_bufmap_shift_query(void);",
          "31: int pvfs_bufmap_initialize(struct PVFS_dev_map_desc *user_desc);",
          "35: void pvfs_bufmap_finalize(void);",
          "37: int pvfs_bufmap_get(struct pvfs2_bufmap **mapp, int *buffer_index);",
          "39: void pvfs_bufmap_put(struct pvfs2_bufmap *bufmap, int buffer_index);",
          "41: int readdir_index_get(struct pvfs2_bufmap **mapp, int *buffer_index);",
          "43: void readdir_index_put(struct pvfs2_bufmap *bufmap, int buffer_index);",
          "45: int pvfs_bufmap_copy_from_iovec(struct pvfs2_bufmap *bufmap,",
          "50: int pvfs_bufmap_copy_to_iovec(struct pvfs2_bufmap *bufmap,",
          "55: size_t pvfs_bufmap_copy_to_user_task_iovec(struct task_struct *tsk,",
          "58:         struct pvfs2_bufmap *bufmap,",
          "",
          "[Added Lines]",
          "7: #ifndef __ORANGEFS_BUFMAP_H",
          "8: #define __ORANGEFS_BUFMAP_H",
          "11: struct orangefs_bufmap_desc {",
          "18: struct orangefs_bufmap;",
          "20: struct orangefs_bufmap *orangefs_bufmap_ref(void);",
          "21: void orangefs_bufmap_unref(struct orangefs_bufmap *bufmap);",
          "27: int orangefs_bufmap_size_query(void);",
          "29: int orangefs_bufmap_shift_query(void);",
          "31: int orangefs_bufmap_initialize(struct ORANGEFS_dev_map_desc *user_desc);",
          "35: void orangefs_bufmap_finalize(void);",
          "37: int orangefs_bufmap_get(struct orangefs_bufmap **mapp, int *buffer_index);",
          "39: void orangefs_bufmap_put(struct orangefs_bufmap *bufmap, int buffer_index);",
          "41: int readdir_index_get(struct orangefs_bufmap **mapp, int *buffer_index);",
          "43: void readdir_index_put(struct orangefs_bufmap *bufmap, int buffer_index);",
          "45: int orangefs_bufmap_copy_from_iovec(struct orangefs_bufmap *bufmap,",
          "50: int orangefs_bufmap_copy_to_iovec(struct orangefs_bufmap *bufmap,",
          "55: size_t orangefs_bufmap_copy_to_user_task_iovec(struct task_struct *tsk,",
          "58:         struct orangefs_bufmap *bufmap,",
          "",
          "---------------"
        ],
        "fs/orangefs/pvfs2-cache.c||fs/orangefs/pvfs2-cache.c": [
          "File: fs/orangefs/pvfs2-cache.c -> fs/orangefs/pvfs2-cache.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "11: static __u64 next_tag_value;",
          "12: static DEFINE_SPINLOCK(next_tag_value_lock);",
          "17: static struct kmem_cache *op_cache;",
          "20: static struct kmem_cache *dev_req_cache;",
          "25: int op_cache_initialize(void)",
          "26: {",
          "29:          0,",
          "31:          NULL);",
          "33:  if (!op_cache) {",
          "35:   return -ENOMEM;",
          "36:  }",
          "",
          "[Removed Lines]",
          "23: static struct kmem_cache *pvfs2_kiocb_cache;",
          "27:  op_cache = kmem_cache_create(\"pvfs2_op_cache\",",
          "28:          sizeof(struct pvfs2_kernel_op_s),",
          "30:          PVFS2_CACHE_CREATE_FLAGS,",
          "34:   gossip_err(\"Cannot create pvfs2_op_cache\\n\");",
          "",
          "[Added Lines]",
          "23: static struct kmem_cache *orangefs_kiocb_cache;",
          "27:  op_cache = kmem_cache_create(\"orangefs_op_cache\",",
          "28:          sizeof(struct orangefs_kernel_op_s),",
          "30:          ORANGEFS_CACHE_CREATE_FLAGS,",
          "34:   gossip_err(\"Cannot create orangefs_op_cache\\n\");",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "48:  return 0;",
          "49: }",
          "52: {",
          "53:  if (new_op) {",
          "54:   __s32 type = new_op->upcall.type;",
          "57:    return \"OP_FILE_IO\";",
          "59:    return \"OP_LOOKUP\";",
          "61:    return \"OP_CREATE\";",
          "63:    return \"OP_GETATTR\";",
          "65:    return \"OP_REMOVE\";",
          "67:    return \"OP_MKDIR\";",
          "69:    return \"OP_READDIR\";",
          "71:    return \"OP_READDIRPLUS\";",
          "73:    return \"OP_SETATTR\";",
          "75:    return \"OP_SYMLINK\";",
          "77:    return \"OP_RENAME\";",
          "79:    return \"OP_STATFS\";",
          "81:    return \"OP_TRUNCATE\";",
          "83:    return \"OP_MMAP_RA_FLUSH\";",
          "85:    return \"OP_FS_MOUNT\";",
          "87:    return \"OP_FS_UMOUNT\";",
          "89:    return \"OP_GETXATTR\";",
          "91:    return \"OP_SETXATTR\";",
          "93:    return \"OP_LISTXATTR\";",
          "95:    return \"OP_REMOVEXATTR\";",
          "97:    return \"OP_PARAM\";",
          "99:    return \"OP_PERF_COUNT\";",
          "101:    return \"OP_CANCEL\";",
          "103:    return \"OP_FSYNC\";",
          "105:    return \"OP_FSKEY\";",
          "106:  }",
          "107:  return \"OP_UNKNOWN?\";",
          "108: }",
          "111: {",
          "115:  if (new_op) {",
          "118:   INIT_LIST_HEAD(&new_op->list);",
          "119:   spin_lock_init(&new_op->lock);",
          "",
          "[Removed Lines]",
          "51: char *get_opname_string(struct pvfs2_kernel_op_s *new_op)",
          "56:   if (type == PVFS2_VFS_OP_FILE_IO)",
          "58:   else if (type == PVFS2_VFS_OP_LOOKUP)",
          "60:   else if (type == PVFS2_VFS_OP_CREATE)",
          "62:   else if (type == PVFS2_VFS_OP_GETATTR)",
          "64:   else if (type == PVFS2_VFS_OP_REMOVE)",
          "66:   else if (type == PVFS2_VFS_OP_MKDIR)",
          "68:   else if (type == PVFS2_VFS_OP_READDIR)",
          "70:   else if (type == PVFS2_VFS_OP_READDIRPLUS)",
          "72:   else if (type == PVFS2_VFS_OP_SETATTR)",
          "74:   else if (type == PVFS2_VFS_OP_SYMLINK)",
          "76:   else if (type == PVFS2_VFS_OP_RENAME)",
          "78:   else if (type == PVFS2_VFS_OP_STATFS)",
          "80:   else if (type == PVFS2_VFS_OP_TRUNCATE)",
          "82:   else if (type == PVFS2_VFS_OP_MMAP_RA_FLUSH)",
          "84:   else if (type == PVFS2_VFS_OP_FS_MOUNT)",
          "86:   else if (type == PVFS2_VFS_OP_FS_UMOUNT)",
          "88:   else if (type == PVFS2_VFS_OP_GETXATTR)",
          "90:   else if (type == PVFS2_VFS_OP_SETXATTR)",
          "92:   else if (type == PVFS2_VFS_OP_LISTXATTR)",
          "94:   else if (type == PVFS2_VFS_OP_REMOVEXATTR)",
          "96:   else if (type == PVFS2_VFS_OP_PARAM)",
          "98:   else if (type == PVFS2_VFS_OP_PERF_COUNT)",
          "100:   else if (type == PVFS2_VFS_OP_CANCEL)",
          "102:   else if (type == PVFS2_VFS_OP_FSYNC)",
          "104:   else if (type == PVFS2_VFS_OP_FSKEY)",
          "110: struct pvfs2_kernel_op_s *op_alloc(__s32 type)",
          "112:  struct pvfs2_kernel_op_s *new_op = NULL;",
          "114:  new_op = kmem_cache_alloc(op_cache, PVFS2_CACHE_ALLOC_FLAGS);",
          "116:   memset(new_op, 0, sizeof(struct pvfs2_kernel_op_s));",
          "",
          "[Added Lines]",
          "51: char *get_opname_string(struct orangefs_kernel_op_s *new_op)",
          "56:   if (type == ORANGEFS_VFS_OP_FILE_IO)",
          "58:   else if (type == ORANGEFS_VFS_OP_LOOKUP)",
          "60:   else if (type == ORANGEFS_VFS_OP_CREATE)",
          "62:   else if (type == ORANGEFS_VFS_OP_GETATTR)",
          "64:   else if (type == ORANGEFS_VFS_OP_REMOVE)",
          "66:   else if (type == ORANGEFS_VFS_OP_MKDIR)",
          "68:   else if (type == ORANGEFS_VFS_OP_READDIR)",
          "70:   else if (type == ORANGEFS_VFS_OP_READDIRPLUS)",
          "72:   else if (type == ORANGEFS_VFS_OP_SETATTR)",
          "74:   else if (type == ORANGEFS_VFS_OP_SYMLINK)",
          "76:   else if (type == ORANGEFS_VFS_OP_RENAME)",
          "78:   else if (type == ORANGEFS_VFS_OP_STATFS)",
          "80:   else if (type == ORANGEFS_VFS_OP_TRUNCATE)",
          "82:   else if (type == ORANGEFS_VFS_OP_MMAP_RA_FLUSH)",
          "84:   else if (type == ORANGEFS_VFS_OP_FS_MOUNT)",
          "86:   else if (type == ORANGEFS_VFS_OP_FS_UMOUNT)",
          "88:   else if (type == ORANGEFS_VFS_OP_GETXATTR)",
          "90:   else if (type == ORANGEFS_VFS_OP_SETXATTR)",
          "92:   else if (type == ORANGEFS_VFS_OP_LISTXATTR)",
          "94:   else if (type == ORANGEFS_VFS_OP_REMOVEXATTR)",
          "96:   else if (type == ORANGEFS_VFS_OP_PARAM)",
          "98:   else if (type == ORANGEFS_VFS_OP_PERF_COUNT)",
          "100:   else if (type == ORANGEFS_VFS_OP_CANCEL)",
          "102:   else if (type == ORANGEFS_VFS_OP_FSYNC)",
          "104:   else if (type == ORANGEFS_VFS_OP_FSKEY)",
          "110: struct orangefs_kernel_op_s *op_alloc(__s32 type)",
          "112:  struct orangefs_kernel_op_s *new_op = NULL;",
          "114:  new_op = kmem_cache_alloc(op_cache, ORANGEFS_CACHE_ALLOC_FLAGS);",
          "116:   memset(new_op, 0, sizeof(struct orangefs_kernel_op_s));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "122:   init_waitqueue_head(&new_op->io_completion_waitq);",
          "123:   atomic_set(&new_op->aio_ref_count, 0);",
          "128:   spin_lock(&next_tag_value_lock);",
          "",
          "[Removed Lines]",
          "125:   pvfs2_op_initialize(new_op);",
          "",
          "[Added Lines]",
          "125:   orangefs_op_initialize(new_op);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "149:  return new_op;",
          "150: }",
          "153: {",
          "155:   gossip_debug(GOSSIP_CACHE_DEBUG,",
          "156:         \"Releasing OP (%p: %llu)\\n\",",
          "161:  } else {",
          "162:   gossip_err(\"NULL pointer in op_release\\n\");",
          "163:  }",
          "",
          "[Removed Lines]",
          "152: void op_release(struct pvfs2_kernel_op_s *pvfs2_op)",
          "154:  if (pvfs2_op) {",
          "157:         pvfs2_op,",
          "158:         llu(pvfs2_op->tag));",
          "159:   pvfs2_op_initialize(pvfs2_op);",
          "160:   kmem_cache_free(op_cache, pvfs2_op);",
          "",
          "[Added Lines]",
          "152: void op_release(struct orangefs_kernel_op_s *orangefs_op)",
          "154:  if (orangefs_op) {",
          "157:         orangefs_op,",
          "158:         llu(orangefs_op->tag));",
          "159:   orangefs_op_initialize(orangefs_op);",
          "160:   kmem_cache_free(op_cache, orangefs_op);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "166: int dev_req_cache_initialize(void)",
          "167: {",
          "169:        MAX_ALIGNED_DEV_REQ_DOWNSIZE,",
          "170:        0,",
          "172:        NULL);",
          "174:  if (!dev_req_cache) {",
          "176:   return -ENOMEM;",
          "177:  }",
          "178:  return 0;",
          "",
          "[Removed Lines]",
          "168:  dev_req_cache = kmem_cache_create(\"pvfs2_devreqcache\",",
          "171:        PVFS2_CACHE_CREATE_FLAGS,",
          "175:   gossip_err(\"Cannot create pvfs2_dev_req_cache\\n\");",
          "",
          "[Added Lines]",
          "168:  dev_req_cache = kmem_cache_create(\"orangefs_devreqcache\",",
          "171:        ORANGEFS_CACHE_CREATE_FLAGS,",
          "175:   gossip_err(\"Cannot create orangefs_dev_req_cache\\n\");",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "188: {",
          "189:  void *buffer;",
          "192:  if (buffer == NULL)",
          "193:   gossip_err(\"Failed to allocate from dev_req_cache\\n\");",
          "194:  else",
          "",
          "[Removed Lines]",
          "191:  buffer = kmem_cache_alloc(dev_req_cache, PVFS2_CACHE_ALLOC_FLAGS);",
          "",
          "[Added Lines]",
          "191:  buffer = kmem_cache_alloc(dev_req_cache, ORANGEFS_CACHE_ALLOC_FLAGS);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "207: int kiocb_cache_initialize(void)",
          "208: {",
          "211:            0,",
          "213:            NULL);",
          "217:   return -ENOMEM;",
          "218:  }",
          "219:  return 0;",
          "",
          "[Removed Lines]",
          "209:  pvfs2_kiocb_cache = kmem_cache_create(\"pvfs2_kiocbcache\",",
          "210:            sizeof(struct pvfs2_kiocb_s),",
          "212:            PVFS2_CACHE_CREATE_FLAGS,",
          "215:  if (!pvfs2_kiocb_cache) {",
          "216:   gossip_err(\"Cannot create pvfs2_kiocb_cache!\\n\");",
          "",
          "[Added Lines]",
          "209:  orangefs_kiocb_cache = kmem_cache_create(\"orangefs_kiocbcache\",",
          "210:            sizeof(struct orangefs_kiocb_s),",
          "212:            ORANGEFS_CACHE_CREATE_FLAGS,",
          "215:  if (!orangefs_kiocb_cache) {",
          "216:   gossip_err(\"Cannot create orangefs_kiocb_cache!\\n\");",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "222: int kiocb_cache_finalize(void)",
          "223: {",
          "225:  return 0;",
          "226: }",
          "229: {",
          "233:  if (x == NULL)",
          "234:   gossip_err(\"kiocb_alloc: kmem_cache_alloc failed!\\n\");",
          "235:  else",
          "237:  return x;",
          "238: }",
          "241: {",
          "242:  if (x)",
          "244:  else",
          "245:   gossip_err(\"kiocb_release: kmem_cache_free NULL pointer!\\n\");",
          "246: }",
          "",
          "[Removed Lines]",
          "224:  kmem_cache_destroy(pvfs2_kiocb_cache);",
          "228: struct pvfs2_kiocb_s *kiocb_alloc(void)",
          "230:  struct pvfs2_kiocb_s *x = NULL;",
          "232:  x = kmem_cache_alloc(pvfs2_kiocb_cache, PVFS2_CACHE_ALLOC_FLAGS);",
          "236:   memset(x, 0, sizeof(struct pvfs2_kiocb_s));",
          "240: void kiocb_release(struct pvfs2_kiocb_s *x)",
          "243:   kmem_cache_free(pvfs2_kiocb_cache, x);",
          "",
          "[Added Lines]",
          "224:  kmem_cache_destroy(orangefs_kiocb_cache);",
          "228: struct orangefs_kiocb_s *kiocb_alloc(void)",
          "230:  struct orangefs_kiocb_s *x = NULL;",
          "232:  x = kmem_cache_alloc(orangefs_kiocb_cache, ORANGEFS_CACHE_ALLOC_FLAGS);",
          "236:   memset(x, 0, sizeof(struct orangefs_kiocb_s));",
          "240: void kiocb_release(struct orangefs_kiocb_s *x)",
          "243:   kmem_cache_free(orangefs_kiocb_cache, x);",
          "",
          "---------------"
        ],
        "fs/orangefs/pvfs2-debug.h||fs/orangefs/pvfs2-debug.h": [
          "File: fs/orangefs/pvfs2-debug.h -> fs/orangefs/pvfs2-debug.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "15: #ifdef __KERNEL__",
          "16: #include <linux/types.h>",
          "",
          "[Removed Lines]",
          "12: #ifndef __PVFS2_DEBUG_H",
          "13: #define __PVFS2_DEBUG_H",
          "",
          "[Added Lines]",
          "12: #ifndef __ORANGEFS_DEBUG_H",
          "13: #define __ORANGEFS_DEBUG_H",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "90:       GOSSIP_BMI_DEBUG_MX +  \\",
          "91:       GOSSIP_BMI_DEBUG_PORTALS))",
          "95: #define GOSSIP_SUPER_DEBUG  ((__u64)1 << 0)",
          "96: #define GOSSIP_INODE_DEBUG  ((__u64)1 << 1)",
          "",
          "[Removed Lines]",
          "93: const char *PVFS_debug_get_next_debug_keyword(int position);",
          "",
          "[Added Lines]",
          "93: const char *ORANGEFS_debug_get_next_debug_keyword(int position);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "113: #define GOSSIP_MAX_DEBUG              (((__u64)1 << GOSSIP_MAX_NR) - 1)",
          "122: struct __keyword_mask_s {",
          "",
          "[Removed Lines]",
          "116: __u64 PVFS_kmod_eventlog_to_mask(const char *event_logging);",
          "117: __u64 PVFS_debug_eventlog_to_mask(const char *event_logging);",
          "118: char *PVFS_debug_mask_to_eventlog(__u64 mask);",
          "119: char *PVFS_kmod_mask_to_eventlog(__u64 mask);",
          "",
          "[Added Lines]",
          "116: __u64 ORANGEFS_kmod_eventlog_to_mask(const char *event_logging);",
          "117: __u64 ORANGEFS_debug_eventlog_to_mask(const char *event_logging);",
          "118: char *ORANGEFS_debug_mask_to_eventlog(__u64 mask);",
          "119: char *ORANGEFS_kmod_mask_to_eventlog(__u64 mask);",
          "",
          "---------------"
        ],
        "fs/orangefs/pvfs2-debugfs.c||fs/orangefs/pvfs2-debugfs.c": [
          "File: fs/orangefs/pvfs2-debugfs.c -> fs/orangefs/pvfs2-debugfs.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "99: {",
          "101:  int rc = -ENOMEM;",
          "",
          "[Removed Lines]",
          "98: int pvfs2_debugfs_init(void)",
          "",
          "[Added Lines]",
          "98: int orangefs_debugfs_init(void)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "118: out:",
          "119:  if (rc)",
          "122:  return rc;",
          "123: }",
          "126: {",
          "127:  debugfs_remove_recursive(debug_dir);",
          "128: }",
          "",
          "[Removed Lines]",
          "120:   pvfs2_debugfs_cleanup();",
          "125: void pvfs2_debugfs_cleanup(void)",
          "",
          "[Added Lines]",
          "120:   orangefs_debugfs_cleanup();",
          "125: void orangefs_debugfs_cleanup(void)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "200: {",
          "202:  int rc = -ENOMEM;",
          "",
          "[Removed Lines]",
          "199: int pvfs2_kernel_debug_init(void)",
          "",
          "[Added Lines]",
          "199: int orangefs_kernel_debug_init(void)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "206:  gossip_debug(GOSSIP_DEBUGFS_DEBUG, \"%s: start\\n\", __func__);",
          "209:  if (!k_buffer)",
          "210:   goto out;",
          "213:   strcpy(k_buffer, kernel_debug_string);",
          "214:   strcat(k_buffer, \"\\n\");",
          "215:  } else {",
          "",
          "[Removed Lines]",
          "208:  k_buffer = kzalloc(PVFS2_MAX_DEBUG_STRING_LEN, GFP_KERNEL);",
          "212:  if (strlen(kernel_debug_string) + 1 < PVFS2_MAX_DEBUG_STRING_LEN) {",
          "",
          "[Added Lines]",
          "208:  k_buffer = kzalloc(ORANGEFS_MAX_DEBUG_STRING_LEN, GFP_KERNEL);",
          "212:  if (strlen(kernel_debug_string) + 1 < ORANGEFS_MAX_DEBUG_STRING_LEN) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "234: out:",
          "235:  if (rc)",
          "238:  gossip_debug(GOSSIP_DEBUGFS_DEBUG, \"%s: rc:%d:\\n\", __func__, rc);",
          "239:  return rc;",
          "",
          "[Removed Lines]",
          "236:   pvfs2_debugfs_cleanup();",
          "",
          "[Added Lines]",
          "236:   orangefs_debugfs_cleanup();",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "246: {",
          "248:  int rc = -ENOMEM;",
          "",
          "[Removed Lines]",
          "245: int pvfs2_client_debug_init(void)",
          "",
          "[Added Lines]",
          "245: int orangefs_client_debug_init(void)",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "251:  gossip_debug(GOSSIP_DEBUGFS_DEBUG, \"%s: start\\n\", __func__);",
          "254:  if (!c_buffer)",
          "255:   goto out;",
          "258:   strcpy(c_buffer, client_debug_string);",
          "259:   strcat(c_buffer, \"\\n\");",
          "260:  } else {",
          "",
          "[Removed Lines]",
          "253:  c_buffer = kzalloc(PVFS2_MAX_DEBUG_STRING_LEN, GFP_KERNEL);",
          "257:  if (strlen(client_debug_string) + 1 < PVFS2_MAX_DEBUG_STRING_LEN) {",
          "",
          "[Added Lines]",
          "253:  c_buffer = kzalloc(ORANGEFS_MAX_DEBUG_STRING_LEN, GFP_KERNEL);",
          "257:  if (strlen(client_debug_string) + 1 < ORANGEFS_MAX_DEBUG_STRING_LEN) {",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "279: out:",
          "280:  if (rc)",
          "283:  gossip_debug(GOSSIP_DEBUGFS_DEBUG, \"%s: rc:%d:\\n\", __func__, rc);",
          "284:  return rc;",
          "",
          "[Removed Lines]",
          "281:   pvfs2_debugfs_cleanup();",
          "",
          "[Added Lines]",
          "281:   orangefs_debugfs_cleanup();",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "321:  gossip_debug(GOSSIP_DEBUGFS_DEBUG, \"orangefs_debug_read: start\\n\");",
          "324:  if (!buf)",
          "325:   goto out;",
          "",
          "[Removed Lines]",
          "323:  buf = kmalloc(PVFS2_MAX_DEBUG_STRING_LEN, GFP_KERNEL);",
          "",
          "[Added Lines]",
          "323:  buf = kmalloc(ORANGEFS_MAX_DEBUG_STRING_LEN, GFP_KERNEL);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "349:  int rc = -EFAULT;",
          "350:  size_t silly = 0;",
          "351:  char *debug_string;",
          "353:  struct client_debug_mask c_mask = { NULL, 0, 0 };",
          "355:  gossip_debug(GOSSIP_DEBUGFS_DEBUG,",
          "",
          "[Removed Lines]",
          "352:  struct pvfs2_kernel_op_s *new_op = NULL;",
          "",
          "[Added Lines]",
          "352:  struct orangefs_kernel_op_s *new_op = NULL;",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "364:   silly = count;",
          "366:  }",
          "369:  if (!buf)",
          "370:   goto out;",
          "373:  if (copy_from_user(buf, ubuf, count - 1)) {",
          "374:   gossip_debug(GOSSIP_DEBUGFS_DEBUG,",
          "",
          "[Removed Lines]",
          "363:  if (count > PVFS2_MAX_DEBUG_STRING_LEN + 1) {",
          "365:   count = PVFS2_MAX_DEBUG_STRING_LEN + 1;",
          "368:  buf = kmalloc(PVFS2_MAX_DEBUG_STRING_LEN, GFP_KERNEL);",
          "371:  memset(buf, 0, PVFS2_MAX_DEBUG_STRING_LEN);",
          "",
          "[Added Lines]",
          "363:  if (count > ORANGEFS_MAX_DEBUG_STRING_LEN + 1) {",
          "365:   count = ORANGEFS_MAX_DEBUG_STRING_LEN + 1;",
          "368:  buf = kmalloc(ORANGEFS_MAX_DEBUG_STRING_LEN, GFP_KERNEL);",
          "371:  memset(buf, 0, ORANGEFS_MAX_DEBUG_STRING_LEN);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "407:   debug_mask_to_string(&c_mask, 1);",
          "408:   debug_string = client_debug_string;",
          "411:   if (!new_op) {",
          "412:    pr_info(\"%s: op_alloc failed!\\n\", __func__);",
          "413:    goto out;",
          "414:   }",
          "416:   new_op->upcall.req.param.op =",
          "419:   memset(new_op->upcall.req.param.s_value,",
          "420:          0,",
          "422:   sprintf(new_op->upcall.req.param.s_value,",
          "423:    \"%llx %llx\\n\",",
          "424:    c_mask.mask1,",
          "",
          "[Removed Lines]",
          "410:   new_op = op_alloc(PVFS2_VFS_OP_PARAM);",
          "417:    PVFS2_PARAM_REQUEST_OP_TWO_MASK_VALUES;",
          "418:   new_op->upcall.req.param.type = PVFS2_PARAM_REQUEST_SET;",
          "421:          PVFS2_MAX_DEBUG_STRING_LEN);",
          "",
          "[Added Lines]",
          "410:   new_op = op_alloc(ORANGEFS_VFS_OP_PARAM);",
          "417:    ORANGEFS_PARAM_REQUEST_OP_TWO_MASK_VALUES;",
          "418:   new_op->upcall.req.param.type = ORANGEFS_PARAM_REQUEST_SET;",
          "421:          ORANGEFS_MAX_DEBUG_STRING_LEN);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "428:   rc = service_operation(new_op,",
          "432:   if (rc)",
          "433:    gossip_debug(GOSSIP_DEBUGFS_DEBUG,",
          "",
          "[Removed Lines]",
          "429:            \"pvfs2_param\",",
          "430:      PVFS2_OP_INTERRUPTIBLE);",
          "",
          "[Added Lines]",
          "429:            \"orangefs_param\",",
          "430:      ORANGEFS_OP_INTERRUPTIBLE);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "439:  }",
          "441:  mutex_lock(&orangefs_debug_lock);",
          "443:  sprintf((char *)file->f_inode->i_private, \"%s\\n\", debug_string);",
          "444:  mutex_unlock(&orangefs_debug_lock);",
          "",
          "[Removed Lines]",
          "442:  memset(file->f_inode->i_private, 0, PVFS2_MAX_DEBUG_STRING_LEN);",
          "",
          "[Added Lines]",
          "442:  memset(file->f_inode->i_private, 0, ORANGEFS_MAX_DEBUG_STRING_LEN);",
          "",
          "---------------"
        ],
        "fs/orangefs/pvfs2-debugfs.h||fs/orangefs/pvfs2-debugfs.h": [
          "File: fs/orangefs/pvfs2-debugfs.h -> fs/orangefs/pvfs2-debugfs.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: int pvfs2_debugfs_init(void);",
          "2: int pvfs2_kernel_debug_init(void);",
          "3: void pvfs2_debugfs_cleanup(void);",
          "",
          "[Added Lines]",
          "1: int orangefs_debugfs_init(void);",
          "2: int orangefs_kernel_debug_init(void);",
          "3: void orangefs_debugfs_cleanup(void);",
          "",
          "---------------"
        ],
        "fs/orangefs/pvfs2-dev-proto.h||fs/orangefs/pvfs2-dev-proto.h": [
          "File: fs/orangefs/pvfs2-dev-proto.h -> fs/orangefs/pvfs2-dev-proto.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "7: #ifndef _PVFS2_DEV_PROTO_H",
          "8: #define _PVFS2_DEV_PROTO_H",
          "",
          "[Added Lines]",
          "7: #ifndef _ORANGEFS_DEV_PROTO_H",
          "8: #define _ORANGEFS_DEV_PROTO_H",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "18: #define PVFS2_VFS_OP_INVALID           0xFF000000",
          "19: #define PVFS2_VFS_OP_FILE_IO           0xFF000001",
          "20: #define PVFS2_VFS_OP_LOOKUP            0xFF000002",
          "21: #define PVFS2_VFS_OP_CREATE            0xFF000003",
          "22: #define PVFS2_VFS_OP_GETATTR           0xFF000004",
          "23: #define PVFS2_VFS_OP_REMOVE            0xFF000005",
          "24: #define PVFS2_VFS_OP_MKDIR             0xFF000006",
          "25: #define PVFS2_VFS_OP_READDIR           0xFF000007",
          "26: #define PVFS2_VFS_OP_SETATTR           0xFF000008",
          "27: #define PVFS2_VFS_OP_SYMLINK           0xFF000009",
          "28: #define PVFS2_VFS_OP_RENAME            0xFF00000A",
          "29: #define PVFS2_VFS_OP_STATFS            0xFF00000B",
          "30: #define PVFS2_VFS_OP_TRUNCATE          0xFF00000C",
          "31: #define PVFS2_VFS_OP_MMAP_RA_FLUSH     0xFF00000D",
          "32: #define PVFS2_VFS_OP_FS_MOUNT          0xFF00000E",
          "33: #define PVFS2_VFS_OP_FS_UMOUNT         0xFF00000F",
          "34: #define PVFS2_VFS_OP_GETXATTR          0xFF000010",
          "35: #define PVFS2_VFS_OP_SETXATTR          0xFF000011",
          "36: #define PVFS2_VFS_OP_LISTXATTR         0xFF000012",
          "37: #define PVFS2_VFS_OP_REMOVEXATTR       0xFF000013",
          "38: #define PVFS2_VFS_OP_PARAM             0xFF000014",
          "39: #define PVFS2_VFS_OP_PERF_COUNT        0xFF000015",
          "40: #define PVFS2_VFS_OP_CANCEL            0xFF00EE00",
          "41: #define PVFS2_VFS_OP_FSYNC             0xFF00EE01",
          "42: #define PVFS2_VFS_OP_FSKEY             0xFF00EE02",
          "43: #define PVFS2_VFS_OP_READDIRPLUS       0xFF00EE03",
          "49: #define PVFS2_NAME_LEN   0x00000100",
          "50: #define PVFS2_MAX_DEBUG_STRING_LEN 0x00000400",
          "51: #define PVFS2_MAX_DEBUG_ARRAY_LEN 0x00000800",
          "",
          "[Added Lines]",
          "18: #define ORANGEFS_VFS_OP_INVALID           0xFF000000",
          "19: #define ORANGEFS_VFS_OP_FILE_IO        0xFF000001",
          "20: #define ORANGEFS_VFS_OP_LOOKUP         0xFF000002",
          "21: #define ORANGEFS_VFS_OP_CREATE         0xFF000003",
          "22: #define ORANGEFS_VFS_OP_GETATTR        0xFF000004",
          "23: #define ORANGEFS_VFS_OP_REMOVE         0xFF000005",
          "24: #define ORANGEFS_VFS_OP_MKDIR          0xFF000006",
          "25: #define ORANGEFS_VFS_OP_READDIR        0xFF000007",
          "26: #define ORANGEFS_VFS_OP_SETATTR        0xFF000008",
          "27: #define ORANGEFS_VFS_OP_SYMLINK        0xFF000009",
          "28: #define ORANGEFS_VFS_OP_RENAME         0xFF00000A",
          "29: #define ORANGEFS_VFS_OP_STATFS         0xFF00000B",
          "30: #define ORANGEFS_VFS_OP_TRUNCATE       0xFF00000C",
          "31: #define ORANGEFS_VFS_OP_MMAP_RA_FLUSH  0xFF00000D",
          "32: #define ORANGEFS_VFS_OP_FS_MOUNT       0xFF00000E",
          "33: #define ORANGEFS_VFS_OP_FS_UMOUNT      0xFF00000F",
          "34: #define ORANGEFS_VFS_OP_GETXATTR       0xFF000010",
          "35: #define ORANGEFS_VFS_OP_SETXATTR          0xFF000011",
          "36: #define ORANGEFS_VFS_OP_LISTXATTR         0xFF000012",
          "37: #define ORANGEFS_VFS_OP_REMOVEXATTR       0xFF000013",
          "38: #define ORANGEFS_VFS_OP_PARAM          0xFF000014",
          "39: #define ORANGEFS_VFS_OP_PERF_COUNT     0xFF000015",
          "40: #define ORANGEFS_VFS_OP_CANCEL            0xFF00EE00",
          "41: #define ORANGEFS_VFS_OP_FSYNC          0xFF00EE01",
          "42: #define ORANGEFS_VFS_OP_FSKEY             0xFF00EE02",
          "43: #define ORANGEFS_VFS_OP_READDIRPLUS       0xFF00EE03",
          "49: #define ORANGEFS_NAME_LEN  0x00000100",
          "50: #define ORANGEFS_MAX_DEBUG_STRING_LEN 0x00000400",
          "51: #define ORANGEFS_MAX_DEBUG_ARRAY_LEN 0x00000800",
          "",
          "---------------"
        ],
        "fs/orangefs/pvfs2-kernel.h||fs/orangefs/pvfs2-kernel.h": [
          "File: fs/orangefs/pvfs2-kernel.h -> fs/orangefs/pvfs2-kernel.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "21: #include <linux/kernel.h>",
          "22: #include <linux/moduleparam.h>",
          "",
          "[Removed Lines]",
          "18: #ifndef __PVFS2KERNEL_H",
          "19: #define __PVFS2KERNEL_H",
          "",
          "[Added Lines]",
          "18: #ifndef __ORANGEFSKERNEL_H",
          "19: #define __ORANGEFSKERNEL_H",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "56: #include \"pvfs2-dev-proto.h\"",
          "60: #else",
          "62: #endif",
          "78: #define MAX_DEV_REQ_UPSIZE (2*sizeof(__s32) +   \\",
          "80: #define MAX_DEV_REQ_DOWNSIZE (2*sizeof(__s32) + \\",
          "83: #define BITS_PER_LONG_DIV_8 (BITS_PER_LONG >> 3)",
          "",
          "[Removed Lines]",
          "58: #ifdef PVFS2_KERNEL_DEBUG",
          "59: #define PVFS2_DEFAULT_OP_TIMEOUT_SECS       10",
          "61: #define PVFS2_DEFAULT_OP_TIMEOUT_SECS       20",
          "64: #define PVFS2_BUFMAP_WAIT_TIMEOUT_SECS      30",
          "68: #define PVFS2_REQDEVICE_NAME          \"pvfs2-req\"",
          "70: #define PVFS2_DEVREQ_MAGIC             0x20030529",
          "71: #define PVFS2_LINK_MAX                 0x000000FF",
          "72: #define PVFS2_PURGE_RETRY_COUNT        0x00000005",
          "73: #define PVFS2_SEEK_END                 0x00000002",
          "74: #define PVFS2_MAX_NUM_OPTIONS          0x00000004",
          "75: #define PVFS2_MAX_MOUNT_OPT_LEN        0x00000080",
          "76: #define PVFS2_MAX_FSKEY_LEN            64",
          "79: sizeof(__u64) + sizeof(struct pvfs2_upcall_s))",
          "81: sizeof(__u64) + sizeof(struct pvfs2_downcall_s))",
          "",
          "[Added Lines]",
          "58: #ifdef ORANGEFS_KERNEL_DEBUG",
          "59: #define ORANGEFS_DEFAULT_OP_TIMEOUT_SECS       10",
          "61: #define ORANGEFS_DEFAULT_OP_TIMEOUT_SECS       20",
          "64: #define ORANGEFS_BUFMAP_WAIT_TIMEOUT_SECS   30",
          "68: #define ORANGEFS_REQDEVICE_NAME          \"pvfs2-req\"",
          "70: #define ORANGEFS_DEVREQ_MAGIC             0x20030529",
          "71: #define ORANGEFS_LINK_MAX                 0x000000FF",
          "72: #define ORANGEFS_PURGE_RETRY_COUNT     0x00000005",
          "73: #define ORANGEFS_SEEK_END              0x00000002",
          "74: #define ORANGEFS_MAX_NUM_OPTIONS          0x00000004",
          "75: #define ORANGEFS_MAX_MOUNT_OPT_LEN        0x00000080",
          "76: #define ORANGEFS_MAX_FSKEY_LEN            64",
          "79: sizeof(__u64) + sizeof(struct orangefs_upcall_s))",
          "81: sizeof(__u64) + sizeof(struct orangefs_downcall_s))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "117:  OP_VFS_STATE_UNKNOWN = 0,",
          "118:  OP_VFS_STATE_WAITING = 1,",
          "119:  OP_VFS_STATE_INPROGR = 2,",
          "",
          "[Removed Lines]",
          "116: enum pvfs2_vfs_op_states {",
          "",
          "[Added Lines]",
          "116: enum orangefs_vfs_op_states {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "162: };",
          "",
          "[Removed Lines]",
          "159: enum PVFS_async_io_type {",
          "160:  PVFS_VFS_SYNC_IO = 0,",
          "161:  PVFS_VFS_ASYNC_IO = 1,",
          "",
          "[Added Lines]",
          "159: enum ORANGEFS_async_io_type {",
          "160:  ORANGEFS_VFS_SYNC_IO = 0,",
          "161:  ORANGEFS_VFS_ASYNC_IO = 1,",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "172: };",
          "180: #else",
          "194: #if 0",
          "195: #ifndef POSIX_ACL_XATTR_ACCESS",
          "",
          "[Removed Lines]",
          "178: #if ((defined PVFS2_KERNEL_DEBUG) && (defined CONFIG_DEBUG_SLAB))",
          "179: #define PVFS2_CACHE_CREATE_FLAGS SLAB_RED_ZONE",
          "181: #define PVFS2_CACHE_CREATE_FLAGS 0",
          "184: #define PVFS2_CACHE_ALLOC_FLAGS (GFP_KERNEL)",
          "185: #define PVFS2_GFP_FLAGS (GFP_KERNEL)",
          "186: #define PVFS2_BUFMAP_GFP_FLAGS (GFP_KERNEL)",
          "189: #define PVFS2_XATTR_INDEX_POSIX_ACL_ACCESS  1",
          "190: #define PVFS2_XATTR_INDEX_POSIX_ACL_DEFAULT 2",
          "191: #define PVFS2_XATTR_INDEX_TRUSTED           3",
          "192: #define PVFS2_XATTR_INDEX_DEFAULT           4",
          "",
          "[Added Lines]",
          "178: #if ((defined ORANGEFS_KERNEL_DEBUG) && (defined CONFIG_DEBUG_SLAB))",
          "179: #define ORANGEFS_CACHE_CREATE_FLAGS SLAB_RED_ZONE",
          "181: #define ORANGEFS_CACHE_CREATE_FLAGS 0",
          "184: #define ORANGEFS_CACHE_ALLOC_FLAGS (GFP_KERNEL)",
          "185: #define ORANGEFS_GFP_FLAGS (GFP_KERNEL)",
          "186: #define ORANGEFS_BUFMAP_GFP_FLAGS (GFP_KERNEL)",
          "189: #define ORANGEFS_XATTR_INDEX_POSIX_ACL_ACCESS  1",
          "190: #define ORANGEFS_XATTR_INDEX_POSIX_ACL_DEFAULT 2",
          "191: #define ORANGEFS_XATTR_INDEX_TRUSTED           3",
          "192: #define ORANGEFS_XATTR_INDEX_DEFAULT           4",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "200: #endif",
          "201: #endif",
          "209: int orangefs_prepare_cdm_array(char *debug_array_string);",
          "210: int orangefs_prepare_debugfs_help_string(int);",
          "215: void debug_string_to_mask(char *, void *, int);",
          "216: void do_c_mask(int, char *, struct client_debug_mask **);",
          "",
          "[Removed Lines]",
          "203: #define PVFS2_XATTR_NAME_ACL_ACCESS  POSIX_ACL_XATTR_ACCESS",
          "204: #define PVFS2_XATTR_NAME_ACL_DEFAULT POSIX_ACL_XATTR_DEFAULT",
          "205: #define PVFS2_XATTR_NAME_TRUSTED_PREFIX \"trusted.\"",
          "206: #define PVFS2_XATTR_NAME_DEFAULT_PREFIX \"\"",
          "213: int pvfs2_client_debug_init(void);",
          "",
          "[Added Lines]",
          "203: #define ORANGEFS_XATTR_NAME_ACL_ACCESS  POSIX_ACL_XATTR_ACCESS",
          "204: #define ORANGEFS_XATTR_NAME_ACL_DEFAULT POSIX_ACL_XATTR_DEFAULT",
          "205: #define ORANGEFS_XATTR_NAME_TRUSTED_PREFIX \"trusted.\"",
          "206: #define ORANGEFS_XATTR_NAME_DEFAULT_PREFIX \"\"",
          "213: int orangefs_client_debug_init(void);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "222: int check_amalgam_keyword(void *, int);",
          "223: int keyword_is_amalgam(char *);",
          "229: extern unsigned int kernel_mask_set_mod_init;",
          "",
          "[Removed Lines]",
          "226: extern char kernel_debug_string[PVFS2_MAX_DEBUG_STRING_LEN];",
          "227: extern char client_debug_string[PVFS2_MAX_DEBUG_STRING_LEN];",
          "228: extern char client_debug_array_string[PVFS2_MAX_DEBUG_STRING_LEN];",
          "231: extern int pvfs2_init_acl(struct inode *inode, struct inode *dir);",
          "232: extern const struct xattr_handler *pvfs2_xattr_handlers[];",
          "234: extern struct posix_acl *pvfs2_get_acl(struct inode *inode, int type);",
          "235: extern int pvfs2_set_acl(struct inode *inode, struct posix_acl *acl, int type);",
          "",
          "[Added Lines]",
          "226: extern char kernel_debug_string[ORANGEFS_MAX_DEBUG_STRING_LEN];",
          "227: extern char client_debug_string[ORANGEFS_MAX_DEBUG_STRING_LEN];",
          "228: extern char client_debug_array_string[ORANGEFS_MAX_DEBUG_STRING_LEN];",
          "231: extern int orangefs_init_acl(struct inode *inode, struct inode *dir);",
          "232: extern const struct xattr_handler *orangefs_xattr_handlers[];",
          "234: extern struct posix_acl *orangefs_get_acl(struct inode *inode, int type);",
          "235: extern int orangefs_set_acl(struct inode *inode, struct posix_acl *acl, int type);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "244: };",
          "251:  __u64 tag;",
          "",
          "[Removed Lines]",
          "249: struct pvfs2_kernel_op_s {",
          "250:  enum pvfs2_vfs_op_states op_state;",
          "",
          "[Added Lines]",
          "249: struct orangefs_kernel_op_s {",
          "250:  enum orangefs_vfs_op_states op_state;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "258:  int uses_shared_memory;",
          "263:  wait_queue_head_t waitq;",
          "264:  spinlock_t lock;",
          "",
          "[Removed Lines]",
          "260:  struct pvfs2_upcall_s upcall;",
          "261:  struct pvfs2_downcall_s downcall;",
          "",
          "[Added Lines]",
          "260:  struct orangefs_upcall_s upcall;",
          "261:  struct orangefs_downcall_s downcall;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "279:  struct list_head list;",
          "280: };",
          "286:  __s64 blksize;",
          "291:  struct rw_semaphore xattr_sem;",
          "",
          "[Removed Lines]",
          "283: struct pvfs2_inode_s {",
          "284:  struct pvfs2_object_kref refn;",
          "285:  char link_target[PVFS_NAME_MAX];",
          "",
          "[Added Lines]",
          "283: struct orangefs_inode_s {",
          "284:  struct orangefs_object_kref refn;",
          "285:  char link_target[ORANGEFS_NAME_MAX];",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "324: #define SetModeFlag(pinode)   set_bit(P_MODE_FLAG, &(pinode)->pinode_flags)",
          "325: #define ModeFlag(pinode)      test_bit(P_MODE_FLAG, &(pinode)->pinode_flags)",
          "330:  __s32 fs_id;",
          "331:  int id;",
          "332:  int flags;",
          "336:  struct super_block *sb;",
          "337:  int mount_pending;",
          "338:  struct list_head list;",
          "",
          "[Removed Lines]",
          "328: struct pvfs2_sb_info_s {",
          "329:  struct pvfs2_khandle root_khandle;",
          "333: #define PVFS2_OPT_INTR  0x01",
          "334: #define PVFS2_OPT_LOCAL_LOCK 0x02",
          "335:  char devname[PVFS_MAX_SERVER_ADDR_LEN];",
          "",
          "[Added Lines]",
          "328: struct orangefs_sb_info_s {",
          "329:  struct orangefs_khandle root_khandle;",
          "333: #define ORANGEFS_OPT_INTR 0x01",
          "334: #define ORANGEFS_OPT_LOCAL_LOCK 0x02",
          "335:  char devname[ORANGEFS_MAX_SERVER_ADDR_LEN];",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "349:  struct task_struct *tsk;",
          "",
          "[Removed Lines]",
          "347: struct pvfs2_kiocb_s {",
          "",
          "[Added Lines]",
          "347: struct orangefs_kiocb_s {",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "352:  struct kiocb *kiocb;",
          "356:  int buffer_index;",
          "362:  struct iovec *iov;",
          "",
          "[Removed Lines]",
          "355:  struct pvfs2_bufmap *bufmap;",
          "359:  struct pvfs2_kernel_op_s *op;",
          "",
          "[Added Lines]",
          "355:  struct orangefs_bufmap *bufmap;",
          "359:  struct orangefs_kernel_op_s *op;",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "377:  int needs_cleanup;",
          "378: };",
          "381:  unsigned long cache_hits;",
          "382:  unsigned long cache_misses;",
          "383:  unsigned long reads;",
          "384:  unsigned long writes;",
          "385: };",
          "394: {",
          "396: }",
          "399: {",
          "401: }",
          "405: {",
          "406:  union {",
          "407:   unsigned char u[8];",
          "",
          "[Removed Lines]",
          "380: struct pvfs2_stats {",
          "387: extern struct pvfs2_stats g_pvfs2_stats;",
          "393: static inline struct pvfs2_inode_s *PVFS2_I(struct inode *inode)",
          "395:  return container_of(inode, struct pvfs2_inode_s, vfs_inode);",
          "398: static inline struct pvfs2_sb_info_s *PVFS2_SB(struct super_block *sb)",
          "400:  return (struct pvfs2_sb_info_s *) sb->s_fs_info;",
          "404: static inline ino_t pvfs2_khandle_to_ino(struct pvfs2_khandle *khandle)",
          "",
          "[Added Lines]",
          "380: struct orangefs_stats {",
          "387: extern struct orangefs_stats g_orangefs_stats;",
          "393: static inline struct orangefs_inode_s *ORANGEFS_I(struct inode *inode)",
          "395:  return container_of(inode, struct orangefs_inode_s, vfs_inode);",
          "398: static inline struct orangefs_sb_info_s *ORANGEFS_SB(struct super_block *sb)",
          "400:  return (struct orangefs_sb_info_s *) sb->s_fs_info;",
          "404: static inline ino_t orangefs_khandle_to_ino(struct orangefs_khandle *khandle)",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "420:  return ihandle.ino;",
          "421: }",
          "424: {",
          "426: }",
          "428: static inline __s32 get_fsid_from_ino(struct inode *inode)",
          "429: {",
          "431: }",
          "433: static inline ino_t get_ino_from_khandle(struct inode *inode)",
          "434: {",
          "436:  ino_t ino;",
          "438:  khandle = get_khandle_from_ino(inode);",
          "440:  return ino;",
          "441: }",
          "",
          "[Removed Lines]",
          "423: static inline struct pvfs2_khandle *get_khandle_from_ino(struct inode *inode)",
          "425:  return &(PVFS2_I(inode)->refn.khandle);",
          "430:  return PVFS2_I(inode)->refn.fs_id;",
          "435:  struct pvfs2_khandle *khandle;",
          "439:  ino = pvfs2_khandle_to_ino(khandle);",
          "",
          "[Added Lines]",
          "423: static inline struct orangefs_khandle *get_khandle_from_ino(struct inode *inode)",
          "425:  return &(ORANGEFS_I(inode)->refn.khandle);",
          "430:  return ORANGEFS_I(inode)->refn.fs_id;",
          "435:  struct orangefs_khandle *khandle;",
          "439:  ino = orangefs_khandle_to_ino(khandle);",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "450:  gossip_debug(GOSSIP_DCACHE_DEBUG,",
          "451:        \"%s: root handle: %pU, this handle: %pU:\\n\",",
          "452:        __func__,",
          "454:        get_khandle_from_ino(inode));",
          "457:         get_khandle_from_ino(inode)))",
          "458:   return 0;",
          "459:  else",
          "460:   return 1;",
          "461: }",
          "464:           struct inode *inode)",
          "465: {",
          "466:  gossip_debug(GOSSIP_DCACHE_DEBUG,",
          "",
          "[Removed Lines]",
          "453:        &PVFS2_SB(inode->i_sb)->root_khandle,",
          "456:  if (PVFS_khandle_cmp(&(PVFS2_SB(inode->i_sb)->root_khandle),",
          "463: static inline int match_handle(struct pvfs2_khandle resp_handle,",
          "",
          "[Added Lines]",
          "453:        &ORANGEFS_SB(inode->i_sb)->root_khandle,",
          "456:  if (ORANGEFS_khandle_cmp(&(ORANGEFS_SB(inode->i_sb)->root_khandle),",
          "463: static inline int match_handle(struct orangefs_khandle resp_handle,",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "469:        &resp_handle,",
          "470:        get_khandle_from_ino(inode));",
          "473:   return 0;",
          "474:  else",
          "475:   return 1;",
          "476: }",
          "481: int op_cache_initialize(void);",
          "482: int op_cache_finalize(void);",
          "487: int dev_req_cache_initialize(void);",
          "488: int dev_req_cache_finalize(void);",
          "489: void *dev_req_alloc(void);",
          "490: void dev_req_release(void *);",
          "495: int kiocb_cache_initialize(void);",
          "496: int kiocb_cache_finalize(void);",
          "503: void purge_inprogress_ops(void);",
          "511: void purge_waiting_ops(void);",
          "517:       int flags,",
          "518:       const char *devname,",
          "519:       void *data);",
          "524: int fsid_key_table_initialize(void);",
          "525: void fsid_key_table_finalize(void);",
          "",
          "[Removed Lines]",
          "472:  if (PVFS_khandle_cmp(&resp_handle, get_khandle_from_ino(inode)))",
          "483: struct pvfs2_kernel_op_s *op_alloc(__s32 type);",
          "484: char *get_opname_string(struct pvfs2_kernel_op_s *new_op);",
          "485: void op_release(struct pvfs2_kernel_op_s *op);",
          "492: int pvfs2_inode_cache_initialize(void);",
          "493: int pvfs2_inode_cache_finalize(void);",
          "497: struct pvfs2_kiocb_s *kiocb_alloc(void);",
          "498: void kiocb_release(struct pvfs2_kiocb_s *ptr);",
          "508: int wait_for_matching_downcall(struct pvfs2_kernel_op_s *op);",
          "509: int wait_for_cancellation_downcall(struct pvfs2_kernel_op_s *op);",
          "510: void pvfs2_clean_up_interrupted_operation(struct pvfs2_kernel_op_s *op);",
          "516: struct dentry *pvfs2_mount(struct file_system_type *fst,",
          "521: void pvfs2_kill_sb(struct super_block *sb);",
          "522: int pvfs2_remount(struct super_block *sb);",
          "",
          "[Added Lines]",
          "472:  if (ORANGEFS_khandle_cmp(&resp_handle, get_khandle_from_ino(inode)))",
          "483: struct orangefs_kernel_op_s *op_alloc(__s32 type);",
          "484: char *get_opname_string(struct orangefs_kernel_op_s *new_op);",
          "485: void op_release(struct orangefs_kernel_op_s *op);",
          "492: int orangefs_inode_cache_initialize(void);",
          "493: int orangefs_inode_cache_finalize(void);",
          "497: struct orangefs_kiocb_s *kiocb_alloc(void);",
          "498: void kiocb_release(struct orangefs_kiocb_s *ptr);",
          "508: int wait_for_matching_downcall(struct orangefs_kernel_op_s *op);",
          "509: int wait_for_cancellation_downcall(struct orangefs_kernel_op_s *op);",
          "510: void orangefs_clean_up_interrupted_operation(struct orangefs_kernel_op_s *op);",
          "516: struct dentry *orangefs_mount(struct file_system_type *fst,",
          "521: void orangefs_kill_sb(struct super_block *sb);",
          "522: int orangefs_remount(struct super_block *sb);",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "532:          struct inode *dir,",
          "533:          int mode,",
          "534:          dev_t dev,",
          "540:     struct dentry *dentry,",
          "541:     struct kstat *kstat);",
          "547:      const char *name,",
          "548:      const void *value,",
          "549:      size_t size,",
          "550:      int flags);",
          "553:          const char *name,",
          "554:          void *buffer,",
          "555:          size_t size);",
          "575: int is_daemon_in_service(void);",
          "576: int fs_mount_pending(__s32 fsid);",
          "586:         const char *prefix,",
          "587:         const char *name,",
          "588:         void *buffer,",
          "589:         size_t size);",
          "592:     const char *prefix,",
          "593:     const char *name,",
          "594:     const void *value,",
          "595:     size_t size,",
          "596:     int flags);",
          "606: void block_signals(sigset_t *);",
          "608: void set_signals(sigset_t *);",
          "615: {",
          "616:  return (__u64)ts->tv_sec;",
          "617: }",
          "621: extern struct mutex devreq_mutex;",
          "622: extern struct mutex request_mutex;",
          "623: extern int debug;",
          "624: extern int op_timeout_secs;",
          "625: extern int slot_timeout_secs;",
          "631: extern struct list_head *htable_ops_in_progress;",
          "632: extern spinlock_t htable_ops_in_progress_lock;",
          "633: extern int hash_table_size;",
          "650: #define add_op_to_request_list(op)    \\",
          "651: do {        \\",
          "653:  spin_lock(&op->lock);     \\",
          "654:  set_op_state_waiting(op);    \\",
          "657:  spin_unlock(&op->lock);     \\",
          "659: } while (0)",
          "661: #define add_priority_op_to_request_list(op)    \\",
          "662:  do {        \\",
          "664:   spin_lock(&op->lock);     \\",
          "665:   set_op_state_waiting(op);    \\",
          "666:          \\",
          "669:   spin_unlock(&op->lock);     \\",
          "671: } while (0)",
          "673: #define remove_op_from_request_list(op)     \\",
          "674:  do {        \\",
          "675:   struct list_head *tmp = NULL;    \\",
          "676:   struct list_head *tmp_safe = NULL;   \\",
          "678:          \\",
          "681:    tmp_op = list_entry(tmp,   \\",
          "683:          list);   \\",
          "684:    if (tmp_op && (tmp_op == op)) {   \\",
          "685:     list_del(&tmp_op->list);  \\",
          "686:     break;     \\",
          "687:    }      \\",
          "688:   }       \\",
          "690:  } while (0)",
          "699:         const char *op_name,",
          "700:         int flags);",
          "",
          "[Removed Lines]",
          "530: __u32 convert_to_pvfs2_mask(unsigned long lite_mask);",
          "531: struct inode *pvfs2_new_inode(struct super_block *sb,",
          "535:          struct pvfs2_object_kref *ref);",
          "537: int pvfs2_setattr(struct dentry *dentry, struct iattr *iattr);",
          "539: int pvfs2_getattr(struct vfsmount *mnt,",
          "546: int pvfs2_setxattr(struct dentry *dentry,",
          "552: ssize_t pvfs2_getxattr(struct dentry *dentry,",
          "557: ssize_t pvfs2_listxattr(struct dentry *dentry, char *buffer, size_t size);",
          "562: struct inode *pvfs2_iget(struct super_block *sb,",
          "563:     struct pvfs2_object_kref *ref);",
          "565: ssize_t pvfs2_inode_read(struct inode *inode,",
          "566:     struct iov_iter *iter,",
          "567:     loff_t *offset,",
          "568:     loff_t readahead_size);",
          "573: int pvfs2_dev_init(void);",
          "574: void pvfs2_dev_cleanup(void);",
          "581: __s32 fsid_of_op(struct pvfs2_kernel_op_s *op);",
          "583: int pvfs2_flush_inode(struct inode *inode);",
          "585: ssize_t pvfs2_inode_getxattr(struct inode *inode,",
          "591: int pvfs2_inode_setxattr(struct inode *inode,",
          "598: int pvfs2_inode_getattr(struct inode *inode, __u32 mask);",
          "600: int pvfs2_inode_setattr(struct inode *inode, struct iattr *iattr);",
          "602: void pvfs2_op_initialize(struct pvfs2_kernel_op_s *op);",
          "604: void pvfs2_make_bad_inode(struct inode *inode);",
          "610: int pvfs2_unmount_sb(struct super_block *sb);",
          "612: int pvfs2_cancel_op_in_progress(__u64 tag);",
          "614: static inline __u64 pvfs2_convert_time_field(const struct timespec *ts)",
          "619: int pvfs2_normalize_to_errno(__s32 error_code);",
          "626: extern struct list_head pvfs2_superblocks;",
          "627: extern spinlock_t pvfs2_superblocks_lock;",
          "628: extern struct list_head pvfs2_request_list;",
          "629: extern spinlock_t pvfs2_request_list_lock;",
          "630: extern wait_queue_head_t pvfs2_request_list_waitq;",
          "635: extern const struct address_space_operations pvfs2_address_operations;",
          "636: extern struct backing_dev_info pvfs2_backing_dev_info;",
          "637: extern struct inode_operations pvfs2_file_inode_operations;",
          "638: extern const struct file_operations pvfs2_file_operations;",
          "639: extern struct inode_operations pvfs2_symlink_inode_operations;",
          "640: extern struct inode_operations pvfs2_dir_inode_operations;",
          "641: extern const struct file_operations pvfs2_dir_operations;",
          "642: extern const struct dentry_operations pvfs2_dentry_operations;",
          "643: extern const struct file_operations pvfs2_devreq_file_operations;",
          "645: extern wait_queue_head_t pvfs2_bufmap_init_waitq;",
          "652:  spin_lock(&pvfs2_request_list_lock);   \\",
          "655:  list_add_tail(&op->list, &pvfs2_request_list);  \\",
          "656:  spin_unlock(&pvfs2_request_list_lock);   \\",
          "658:  wake_up_interruptible(&pvfs2_request_list_waitq); \\",
          "663:   spin_lock(&pvfs2_request_list_lock);   \\",
          "667:   list_add(&op->list, &pvfs2_request_list);  \\",
          "668:   spin_unlock(&pvfs2_request_list_lock);   \\",
          "670:   wake_up_interruptible(&pvfs2_request_list_waitq); \\",
          "677:   struct pvfs2_kernel_op_s *tmp_op = NULL;  \\",
          "679:   spin_lock(&pvfs2_request_list_lock);   \\",
          "680:   list_for_each_safe(tmp, tmp_safe, &pvfs2_request_list) { \\",
          "682:          struct pvfs2_kernel_op_s, \\",
          "689:   spin_unlock(&pvfs2_request_list_lock);   \\",
          "698: int service_operation(struct pvfs2_kernel_op_s *op,",
          "",
          "[Added Lines]",
          "530: __u32 convert_to_orangefs_mask(unsigned long lite_mask);",
          "531: struct inode *orangefs_new_inode(struct super_block *sb,",
          "535:          struct orangefs_object_kref *ref);",
          "537: int orangefs_setattr(struct dentry *dentry, struct iattr *iattr);",
          "539: int orangefs_getattr(struct vfsmount *mnt,",
          "546: int orangefs_setxattr(struct dentry *dentry,",
          "552: ssize_t orangefs_getxattr(struct dentry *dentry,",
          "557: ssize_t orangefs_listxattr(struct dentry *dentry, char *buffer, size_t size);",
          "562: struct inode *orangefs_iget(struct super_block *sb,",
          "563:     struct orangefs_object_kref *ref);",
          "565: ssize_t orangefs_inode_read(struct inode *inode,",
          "566:        struct iov_iter *iter,",
          "567:        loff_t *offset,",
          "568:        loff_t readahead_size);",
          "573: int orangefs_dev_init(void);",
          "574: void orangefs_dev_cleanup(void);",
          "581: __s32 fsid_of_op(struct orangefs_kernel_op_s *op);",
          "583: int orangefs_flush_inode(struct inode *inode);",
          "585: ssize_t orangefs_inode_getxattr(struct inode *inode,",
          "591: int orangefs_inode_setxattr(struct inode *inode,",
          "598: int orangefs_inode_getattr(struct inode *inode, __u32 mask);",
          "600: int orangefs_inode_setattr(struct inode *inode, struct iattr *iattr);",
          "602: void orangefs_op_initialize(struct orangefs_kernel_op_s *op);",
          "604: void orangefs_make_bad_inode(struct inode *inode);",
          "610: int orangefs_unmount_sb(struct super_block *sb);",
          "612: int orangefs_cancel_op_in_progress(__u64 tag);",
          "614: static inline __u64 orangefs_convert_time_field(const struct timespec *ts)",
          "619: int orangefs_normalize_to_errno(__s32 error_code);",
          "626: extern struct list_head orangefs_superblocks;",
          "627: extern spinlock_t orangefs_superblocks_lock;",
          "628: extern struct list_head orangefs_request_list;",
          "629: extern spinlock_t orangefs_request_list_lock;",
          "630: extern wait_queue_head_t orangefs_request_list_waitq;",
          "635: extern const struct address_space_operations orangefs_address_operations;",
          "636: extern struct backing_dev_info orangefs_backing_dev_info;",
          "637: extern struct inode_operations orangefs_file_inode_operations;",
          "638: extern const struct file_operations orangefs_file_operations;",
          "639: extern struct inode_operations orangefs_symlink_inode_operations;",
          "640: extern struct inode_operations orangefs_dir_inode_operations;",
          "641: extern const struct file_operations orangefs_dir_operations;",
          "642: extern const struct dentry_operations orangefs_dentry_operations;",
          "643: extern const struct file_operations orangefs_devreq_file_operations;",
          "645: extern wait_queue_head_t orangefs_bufmap_init_waitq;",
          "652:  spin_lock(&orangefs_request_list_lock);   \\",
          "655:  list_add_tail(&op->list, &orangefs_request_list);  \\",
          "656:  spin_unlock(&orangefs_request_list_lock);   \\",
          "658:  wake_up_interruptible(&orangefs_request_list_waitq); \\",
          "663:   spin_lock(&orangefs_request_list_lock);   \\",
          "667:   list_add(&op->list, &orangefs_request_list);  \\",
          "668:   spin_unlock(&orangefs_request_list_lock);   \\",
          "670:   wake_up_interruptible(&orangefs_request_list_waitq); \\",
          "677:   struct orangefs_kernel_op_s *tmp_op = NULL;  \\",
          "679:   spin_lock(&orangefs_request_list_lock);   \\",
          "680:   list_for_each_safe(tmp, tmp_safe, &orangefs_request_list) { \\",
          "682:          struct orangefs_kernel_op_s, \\",
          "689:   spin_unlock(&orangefs_request_list_lock);   \\",
          "698: int service_operation(struct orangefs_kernel_op_s *op,",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "731: #define handle_io_error()     \\",
          "732: do {        \\",
          "733:  if (!op_state_serviced(new_op)) {   \\",
          "735:   op_release(new_op);    \\",
          "736:  } else {      \\",
          "737:   wake_up_daemon_for_return(new_op);  \\",
          "738:  }       \\",
          "739:  new_op = NULL;      \\",
          "741:  buffer_index = -1;     \\",
          "742: } while (0)",
          "744: #define get_interruptible_flag(inode) \\",
          "749: do {         \\",
          "750:  gossip_debug(GOSSIP_SUPER_DEBUG,    \\",
          "756: } while (0)",
          "759: do {         \\",
          "760:  struct list_head *tmp = NULL;     \\",
          "761:  struct list_head *tmp_safe = NULL;    \\",
          "763:          \\",
          "768:           list);    \\",
          "770:    gossip_debug(GOSSIP_SUPER_DEBUG,  \\",
          "774:    break;      \\",
          "775:   }       \\",
          "776:  }        \\",
          "778: } while (0)",
          "783: #define fill_default_sys_attrs(sys_attr, type, mode)   \\",
          "784: do {         \\",
          "785:  sys_attr.owner = from_kuid(current_user_ns(), current_fsuid()); \\",
          "786:  sys_attr.group = from_kgid(current_user_ns(), current_fsgid()); \\",
          "787:  sys_attr.size = 0;      \\",
          "789:  sys_attr.objtype = type;     \\",
          "791: } while (0)",
          "798: {",
          "799: #if BITS_PER_LONG == 32 && defined(CONFIG_SMP)",
          "801: #endif",
          "802:  i_size_write(inode, i_size);",
          "803: #if BITS_PER_LONG == 32 && defined(CONFIG_SMP)",
          "805: #endif",
          "806: }",
          "",
          "[Removed Lines]",
          "734:   pvfs2_cancel_op_in_progress(new_op->tag); \\",
          "740:  pvfs_bufmap_put(bufmap, buffer_index);    \\",
          "745:  ((PVFS2_SB(inode->i_sb)->flags & PVFS2_OPT_INTR) ? \\",
          "746:   PVFS2_OP_INTERRUPTIBLE : 0)",
          "748: #define add_pvfs2_sb(sb)      \\",
          "751:        \"Adding SB %p to pvfs2 superblocks\\n\",  \\",
          "752:        PVFS2_SB(sb));     \\",
          "753:  spin_lock(&pvfs2_superblocks_lock);    \\",
          "754:  list_add_tail(&PVFS2_SB(sb)->list, &pvfs2_superblocks);  \\",
          "755:  spin_unlock(&pvfs2_superblocks_lock); \\",
          "758: #define remove_pvfs2_sb(sb)      \\",
          "762:  struct pvfs2_sb_info_s *pvfs2_sb = NULL;   \\",
          "764:  spin_lock(&pvfs2_superblocks_lock);    \\",
          "765:  list_for_each_safe(tmp, tmp_safe, &pvfs2_superblocks) {  \\",
          "766:   pvfs2_sb = list_entry(tmp,    \\",
          "767:           struct pvfs2_sb_info_s,  \\",
          "769:   if (pvfs2_sb && (pvfs2_sb->sb == sb)) {   \\",
          "771:        \"Removing SB %p from pvfs2 superblocks\\n\", \\",
          "772:    pvfs2_sb);     \\",
          "773:    list_del(&pvfs2_sb->list);   \\",
          "777:  spin_unlock(&pvfs2_superblocks_lock);    \\",
          "780: #define pvfs2_lock_inode(inode) spin_lock(&inode->i_lock)",
          "781: #define pvfs2_unlock_inode(inode) spin_unlock(&inode->i_lock)",
          "788:  sys_attr.perms = PVFS_util_translate_mode(mode);  \\",
          "790:  sys_attr.mask = PVFS_ATTR_SYS_ALL_SETABLE;   \\",
          "793: #define pvfs2_inode_lock(__i)  mutex_lock(&(__i)->i_mutex)",
          "795: #define pvfs2_inode_unlock(__i) mutex_unlock(&(__i)->i_mutex)",
          "797: static inline void pvfs2_i_size_write(struct inode *inode, loff_t i_size)",
          "800:  pvfs2_inode_lock(inode);",
          "804:  pvfs2_inode_unlock(inode);",
          "",
          "[Added Lines]",
          "734:   orangefs_cancel_op_in_progress(new_op->tag); \\",
          "740:  orangefs_bufmap_put(bufmap, buffer_index);    \\",
          "745:  ((ORANGEFS_SB(inode->i_sb)->flags & ORANGEFS_OPT_INTR) ? \\",
          "746:   ORANGEFS_OP_INTERRUPTIBLE : 0)",
          "748: #define add_orangefs_sb(sb)      \\",
          "751:        \"Adding SB %p to orangefs superblocks\\n\",  \\",
          "752:        ORANGEFS_SB(sb));     \\",
          "753:  spin_lock(&orangefs_superblocks_lock);    \\",
          "754:  list_add_tail(&ORANGEFS_SB(sb)->list, &orangefs_superblocks);  \\",
          "755:  spin_unlock(&orangefs_superblocks_lock); \\",
          "758: #define remove_orangefs_sb(sb)      \\",
          "762:  struct orangefs_sb_info_s *orangefs_sb = NULL;   \\",
          "764:  spin_lock(&orangefs_superblocks_lock);    \\",
          "765:  list_for_each_safe(tmp, tmp_safe, &orangefs_superblocks) {  \\",
          "766:   orangefs_sb = list_entry(tmp,    \\",
          "767:           struct orangefs_sb_info_s,  \\",
          "769:   if (orangefs_sb && (orangefs_sb->sb == sb)) {   \\",
          "771:        \"Removing SB %p from orangefs superblocks\\n\", \\",
          "772:    orangefs_sb);     \\",
          "773:    list_del(&orangefs_sb->list);   \\",
          "777:  spin_unlock(&orangefs_superblocks_lock);    \\",
          "780: #define orangefs_lock_inode(inode) spin_lock(&inode->i_lock)",
          "781: #define orangefs_unlock_inode(inode) spin_unlock(&inode->i_lock)",
          "788:  sys_attr.perms = ORANGEFS_util_translate_mode(mode);  \\",
          "790:  sys_attr.mask = ORANGEFS_ATTR_SYS_ALL_SETABLE;   \\",
          "793: #define orangefs_inode_lock(__i)  mutex_lock(&(__i)->i_mutex)",
          "795: #define orangefs_inode_unlock(__i) mutex_unlock(&(__i)->i_mutex)",
          "797: static inline void orangefs_i_size_write(struct inode *inode, loff_t i_size)",
          "800:  ornagefs_inode_lock(inode);",
          "804:  orangefs_inode_unlock(inode);",
          "",
          "---------------"
        ],
        "fs/orangefs/pvfs2-mod.c||fs/orangefs/pvfs2-mod.c": [
          "File: fs/orangefs/pvfs2-mod.c -> fs/orangefs/pvfs2-mod.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "12: #include \"pvfs2-debugfs.h\"",
          "13: #include \"pvfs2-sysfs.h\"",
          "18: #endif",
          "",
          "[Removed Lines]",
          "16: #ifndef PVFS2_VERSION",
          "17: #define PVFS2_VERSION \"Unknown\"",
          "",
          "[Added Lines]",
          "16: #ifndef ORANGEFS_VERSION",
          "17: #define ORANGEFS_VERSION \"Unknown\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "25: struct client_debug_mask *cdm_array;",
          "26: int cdm_element_count;",
          "32: char *debug_help_string;",
          "33: int help_string_initialized;",
          "",
          "[Removed Lines]",
          "28: char kernel_debug_string[PVFS2_MAX_DEBUG_STRING_LEN] = \"none\";",
          "29: char client_debug_string[PVFS2_MAX_DEBUG_STRING_LEN];",
          "30: char client_debug_array_string[PVFS2_MAX_DEBUG_STRING_LEN];",
          "",
          "[Added Lines]",
          "28: char kernel_debug_string[ORANGEFS_MAX_DEBUG_STRING_LEN] = \"none\";",
          "29: char client_debug_string[ORANGEFS_MAX_DEBUG_STRING_LEN];",
          "30: char client_debug_array_string[ORANGEFS_MAX_DEBUG_STRING_LEN];",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "36: struct dentry *debug_dir;",
          "37: int client_verbose_index;",
          "38: int client_all_index;",
          "42: int hash_table_size = 509;",
          "",
          "[Removed Lines]",
          "39: struct pvfs2_stats g_pvfs2_stats;",
          "",
          "[Added Lines]",
          "39: struct orangefs_stats g_orangefs_stats;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "45: __u64 gossip_debug_mask;",
          "46: struct client_debug_mask client_debug_mask = { NULL, 0, 0 };",
          "51: MODULE_LICENSE(\"GPL\");",
          "55: MODULE_PARM_DESC(op_timeout_secs, \"Operation timeout in seconds\");",
          "56: MODULE_PARM_DESC(slot_timeout_secs, \"Slot timeout in seconds\");",
          "57: MODULE_PARM_DESC(hash_table_size,",
          "58:    \"size of hash table for operations in progress\");",
          "61:  .name = \"pvfs2\",",
          "64:  .owner = THIS_MODULE,",
          "65: };",
          "",
          "[Removed Lines]",
          "48: int op_timeout_secs = PVFS2_DEFAULT_OP_TIMEOUT_SECS;",
          "49: int slot_timeout_secs = PVFS2_DEFAULT_SLOT_TIMEOUT_SECS;",
          "52: MODULE_AUTHOR(\"PVFS2 Development Team\");",
          "53: MODULE_DESCRIPTION(\"The Linux Kernel VFS interface to PVFS2\");",
          "54: MODULE_PARM_DESC(module_parm_debug_mask, \"debugging level (see pvfs2-debug.h for values)\");",
          "60: static struct file_system_type pvfs2_fs_type = {",
          "62:  .mount = pvfs2_mount,",
          "63:  .kill_sb = pvfs2_kill_sb,",
          "",
          "[Added Lines]",
          "48: int op_timeout_secs = ORANGEFS_DEFAULT_OP_TIMEOUT_SECS;",
          "49: int slot_timeout_secs = ORANGEFS_DEFAULT_SLOT_TIMEOUT_SECS;",
          "52: MODULE_AUTHOR(\"ORANGEFS Development Team\");",
          "53: MODULE_DESCRIPTION(\"The Linux Kernel VFS interface to ORANGEFS\");",
          "54: MODULE_PARM_DESC(module_parm_debug_mask, \"debugging level (see orangefs-debug.h for values)\");",
          "60: static struct file_system_type orangefs_fs_type = {",
          "62:  .mount = orangefs_mount,",
          "63:  .kill_sb = orangefs_kill_sb,",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "85: DEFINE_SPINLOCK(htable_ops_in_progress_lock);",
          "97: {",
          "98:  int ret = -1;",
          "99:  __u32 i = 0;",
          "",
          "[Removed Lines]",
          "88: LIST_HEAD(pvfs2_request_list);",
          "91: DEFINE_SPINLOCK(pvfs2_request_list_lock);",
          "94: DECLARE_WAIT_QUEUE_HEAD(pvfs2_request_list_waitq);",
          "96: static int __init pvfs2_init(void)",
          "",
          "[Added Lines]",
          "88: LIST_HEAD(orangefs_request_list);",
          "91: DEFINE_SPINLOCK(orangefs_request_list_lock);",
          "94: DECLARE_WAIT_QUEUE_HEAD(orangefs_request_list_waitq);",
          "96: static int __init orangefs_init(void)",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "120:   kernel_mask_set_mod_init = true;",
          "124:         kernel_debug_string,",
          "125:         (unsigned long long)gossip_debug_mask);",
          "129:  if (ret)",
          "130:   return ret;",
          "",
          "[Removed Lines]",
          "123:  pr_info(\"pvfs2: pvfs2_init called with debug mask: :%s: :%llx:\\n\",",
          "127:  ret = bdi_init(&pvfs2_backing_dev_info);",
          "",
          "[Added Lines]",
          "123:  pr_info(\"orangefs: orangefs_init called with debug mask: :%s: :%llx:\\n\",",
          "127:  ret = bdi_init(&orangefs_backing_dev_info);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "144:  if (ret < 0)",
          "145:   goto cleanup_op;",
          "148:  if (ret < 0)",
          "149:   goto cleanup_req;",
          "",
          "[Removed Lines]",
          "147:  ret = pvfs2_inode_cache_initialize();",
          "",
          "[Added Lines]",
          "147:  ret = orangefs_inode_cache_initialize();",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "153:   goto cleanup_inode;",
          "157:  if (ret < 0) {",
          "159:       ret);",
          "160:   goto cleanup_kiocb;",
          "161:  }",
          "",
          "[Removed Lines]",
          "156:  ret = pvfs2_dev_init();",
          "158:   gossip_err(\"pvfs2: could not initialize device subsystem %d!\\n\",",
          "",
          "[Added Lines]",
          "156:  ret = orangefs_dev_init();",
          "158:   gossip_err(\"orangefs: could not initialize device subsystem %d!\\n\",",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "197:  if (ret)",
          "198:   goto out;",
          "202:  orangefs_sysfs_init();",
          "205:  if (ret == 0) {",
          "207:   return 0;",
          "208:  }",
          "211:  orangefs_sysfs_exit();",
          "212:  fsid_key_table_finalize();",
          "",
          "[Removed Lines]",
          "200:  pvfs2_debugfs_init();",
          "201:  pvfs2_kernel_debug_init();",
          "204:  ret = register_filesystem(&pvfs2_fs_type);",
          "206:   pr_info(\"pvfs2: module version %s loaded\\n\", PVFS2_VERSION);",
          "210:  pvfs2_debugfs_cleanup();",
          "",
          "[Added Lines]",
          "200:  orangefs_debugfs_init();",
          "201:  orangefs_kernel_debug_init();",
          "204:  ret = register_filesystem(&orangefs_fs_type);",
          "206:   pr_info(\"orangefs: module version %s loaded\\n\", ORANGEFS_VERSION);",
          "210:  orangefs_debugfs_cleanup();",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "215:  kfree(htable_ops_in_progress);",
          "217: cleanup_device:",
          "220: cleanup_kiocb:",
          "221:  kiocb_cache_finalize();",
          "223: cleanup_inode:",
          "226: cleanup_req:",
          "227:  dev_req_cache_finalize();",
          "",
          "[Removed Lines]",
          "218:  pvfs2_dev_cleanup();",
          "224:  pvfs2_inode_cache_finalize();",
          "",
          "[Added Lines]",
          "218:  orangefs_dev_cleanup();",
          "224:  orangefs_inode_cache_finalize();",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "230:  op_cache_finalize();",
          "232: err:",
          "235: out:",
          "236:  return ret;",
          "237: }",
          "240: {",
          "241:  int i = 0;",
          "248:  orangefs_sysfs_exit();",
          "249:  fsid_key_table_finalize();",
          "256:         list);",
          "257:   list_del(&cur_op->list);",
          "258:   gossip_debug(GOSSIP_INIT_DEBUG,",
          "",
          "[Removed Lines]",
          "233:  bdi_destroy(&pvfs2_backing_dev_info);",
          "239: static void __exit pvfs2_exit(void)",
          "242:  struct pvfs2_kernel_op_s *cur_op = NULL;",
          "244:  gossip_debug(GOSSIP_INIT_DEBUG, \"pvfs2: pvfs2_exit called\\n\");",
          "246:  unregister_filesystem(&pvfs2_fs_type);",
          "247:  pvfs2_debugfs_cleanup();",
          "250:  pvfs2_dev_cleanup();",
          "252:  spin_lock(&pvfs2_request_list_lock);",
          "253:  while (!list_empty(&pvfs2_request_list)) {",
          "254:   cur_op = list_entry(pvfs2_request_list.next,",
          "255:         struct pvfs2_kernel_op_s,",
          "",
          "[Added Lines]",
          "233:  bdi_destroy(&orangefs_backing_dev_info);",
          "239: static void __exit orangefs_exit(void)",
          "242:  struct orangefs_kernel_op_s *cur_op = NULL;",
          "244:  gossip_debug(GOSSIP_INIT_DEBUG, \"orangefs: orangefs_exit called\\n\");",
          "246:  unregister_filesystem(&orangefs_fs_type);",
          "247:  orangefs_debugfs_cleanup();",
          "250:  orangefs_dev_cleanup();",
          "252:  spin_lock(&orangefs_request_list_lock);",
          "253:  while (!list_empty(&orangefs_request_list)) {",
          "254:   cur_op = list_entry(orangefs_request_list.next,",
          "255:         struct orangefs_kernel_op_s,",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "260:         cur_op->upcall.type);",
          "261:   op_release(cur_op);",
          "262:  }",
          "265:  for (i = 0; i < hash_table_size; i++)",
          "266:   while (!list_empty(&htable_ops_in_progress[i])) {",
          "267:    cur_op = list_entry(htable_ops_in_progress[i].next,",
          "269:          list);",
          "270:    op_release(cur_op);",
          "271:   }",
          "273:  kiocb_cache_finalize();",
          "275:  dev_req_cache_finalize();",
          "276:  op_cache_finalize();",
          "278:  kfree(htable_ops_in_progress);",
          "283: }",
          "",
          "[Removed Lines]",
          "263:  spin_unlock(&pvfs2_request_list_lock);",
          "268:          struct pvfs2_kernel_op_s,",
          "274:  pvfs2_inode_cache_finalize();",
          "280:  bdi_destroy(&pvfs2_backing_dev_info);",
          "282:  pr_info(\"pvfs2: module version %s unloaded\\n\", PVFS2_VERSION);",
          "",
          "[Added Lines]",
          "263:  spin_unlock(&orangefs_request_list_lock);",
          "268:          struct orangefs_kernel_op_s,",
          "274:  orangefs_inode_cache_finalize();",
          "280:  bdi_destroy(&orangefs_backing_dev_info);",
          "282:  pr_info(\"orangefs: module version %s unloaded\\n\", ORANGEFS_VERSION);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "291:  int i;",
          "293:  for (i = 0; i < hash_table_size; i++) {",
          "297:   list_for_each_entry_safe(op,",
          "298:       next,",
          "",
          "[Removed Lines]",
          "294:   struct pvfs2_kernel_op_s *op;",
          "295:   struct pvfs2_kernel_op_s *next;",
          "",
          "[Added Lines]",
          "294:   struct orangefs_kernel_op_s *op;",
          "295:   struct orangefs_kernel_op_s *next;",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "311:  }",
          "312: }",
          "",
          "[Removed Lines]",
          "314: module_init(pvfs2_init);",
          "315: module_exit(pvfs2_exit);",
          "",
          "[Added Lines]",
          "314: module_init(orangefs_init);",
          "315: module_exit(orangefs_exit);",
          "",
          "---------------"
        ],
        "fs/orangefs/pvfs2-sysfs.c||fs/orangefs/pvfs2-sysfs.c": [
          "File: fs/orangefs/pvfs2-sysfs.c -> fs/orangefs/pvfs2-sysfs.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "669:    rc = scnprintf(buf,",
          "670:            PAGE_SIZE,",
          "671:            \"%lu\\n\",",
          "673:    goto out;",
          "674:   } else if (!strcmp(stats_orangefs_attr->attr.name, \"writes\")) {",
          "675:    rc = scnprintf(buf,",
          "676:            PAGE_SIZE,",
          "677:            \"%lu\\n\",",
          "679:    goto out;",
          "680:   } else {",
          "681:    goto out;",
          "",
          "[Removed Lines]",
          "672:            g_pvfs2_stats.reads);",
          "678:            g_pvfs2_stats.writes);",
          "",
          "[Added Lines]",
          "672:            g_orangefs_stats.reads);",
          "678:            g_orangefs_stats.writes);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "753: static int sysfs_service_op_show(char *kobj_id, char *buf, void *attr)",
          "754: {",
          "756:  int rc = 0;",
          "757:  char *ser_op_type = NULL;",
          "758:  struct orangefs_attribute *orangefs_attr;",
          "",
          "[Removed Lines]",
          "755:  struct pvfs2_kernel_op_s *new_op = NULL;",
          "",
          "[Added Lines]",
          "755:  struct orangefs_kernel_op_s *new_op = NULL;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "768:        kobj_id);",
          "770:  if (strcmp(kobj_id, PC_KOBJ_ID))",
          "772:  else",
          "775:  new_op = op_alloc(op_alloc_type);",
          "776:  if (!new_op) {",
          "",
          "[Removed Lines]",
          "771:   op_alloc_type = PVFS2_VFS_OP_PARAM;",
          "773:   op_alloc_type = PVFS2_VFS_OP_PERF_COUNT;",
          "",
          "[Added Lines]",
          "771:   op_alloc_type = ORANGEFS_VFS_OP_PARAM;",
          "773:   op_alloc_type = ORANGEFS_VFS_OP_PERF_COUNT;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "788:  }",
          "790:  if (strcmp(kobj_id, PC_KOBJ_ID))",
          "793:  if (!strcmp(kobj_id, ORANGEFS_KOBJ_ID)) {",
          "794:   orangefs_attr = (struct orangefs_attribute *)attr;",
          "796:   if (!strcmp(orangefs_attr->attr.name, \"perf_history_size\"))",
          "797:    new_op->upcall.req.param.op =",
          "799:   else if (!strcmp(orangefs_attr->attr.name,",
          "800:      \"perf_time_interval_secs\"))",
          "801:    new_op->upcall.req.param.op =",
          "803:   else if (!strcmp(orangefs_attr->attr.name,",
          "804:      \"perf_counter_reset\"))",
          "805:    new_op->upcall.req.param.op =",
          "808:  } else if (!strcmp(kobj_id, ACACHE_KOBJ_ID)) {",
          "809:   acache_attr = (struct acache_orangefs_attribute *)attr;",
          "811:   if (!strcmp(acache_attr->attr.name, \"timeout_msecs\"))",
          "812:    new_op->upcall.req.param.op =",
          "815:   if (!strcmp(acache_attr->attr.name, \"hard_limit\"))",
          "816:    new_op->upcall.req.param.op =",
          "819:   if (!strcmp(acache_attr->attr.name, \"soft_limit\"))",
          "820:    new_op->upcall.req.param.op =",
          "823:   if (!strcmp(acache_attr->attr.name, \"reclaim_percentage\"))",
          "824:    new_op->upcall.req.param.op =",
          "827:  } else if (!strcmp(kobj_id, CAPCACHE_KOBJ_ID)) {",
          "828:   capcache_attr = (struct capcache_orangefs_attribute *)attr;",
          "830:   if (!strcmp(capcache_attr->attr.name, \"timeout_secs\"))",
          "831:    new_op->upcall.req.param.op =",
          "834:   if (!strcmp(capcache_attr->attr.name, \"hard_limit\"))",
          "835:    new_op->upcall.req.param.op =",
          "838:   if (!strcmp(capcache_attr->attr.name, \"soft_limit\"))",
          "839:    new_op->upcall.req.param.op =",
          "842:   if (!strcmp(capcache_attr->attr.name, \"reclaim_percentage\"))",
          "843:    new_op->upcall.req.param.op =",
          "846:  } else if (!strcmp(kobj_id, CCACHE_KOBJ_ID)) {",
          "847:   ccache_attr = (struct ccache_orangefs_attribute *)attr;",
          "849:   if (!strcmp(ccache_attr->attr.name, \"timeout_secs\"))",
          "850:    new_op->upcall.req.param.op =",
          "853:   if (!strcmp(ccache_attr->attr.name, \"hard_limit\"))",
          "854:    new_op->upcall.req.param.op =",
          "857:   if (!strcmp(ccache_attr->attr.name, \"soft_limit\"))",
          "858:    new_op->upcall.req.param.op =",
          "861:   if (!strcmp(ccache_attr->attr.name, \"reclaim_percentage\"))",
          "862:    new_op->upcall.req.param.op =",
          "865:  } else if (!strcmp(kobj_id, NCACHE_KOBJ_ID)) {",
          "866:   ncache_attr = (struct ncache_orangefs_attribute *)attr;",
          "868:   if (!strcmp(ncache_attr->attr.name, \"timeout_msecs\"))",
          "869:    new_op->upcall.req.param.op =",
          "872:   if (!strcmp(ncache_attr->attr.name, \"hard_limit\"))",
          "873:    new_op->upcall.req.param.op =",
          "876:   if (!strcmp(ncache_attr->attr.name, \"soft_limit\"))",
          "877:    new_op->upcall.req.param.op =",
          "880:   if (!strcmp(ncache_attr->attr.name, \"reclaim_percentage\"))",
          "881:    new_op->upcall.req.param.op =",
          "884:  } else if (!strcmp(kobj_id, PC_KOBJ_ID)) {",
          "885:   pc_attr = (struct pc_orangefs_attribute *)attr;",
          "887:   if (!strcmp(pc_attr->attr.name, ACACHE_KOBJ_ID))",
          "888:    new_op->upcall.req.perf_count.type =",
          "891:   if (!strcmp(pc_attr->attr.name, CAPCACHE_KOBJ_ID))",
          "892:    new_op->upcall.req.perf_count.type =",
          "895:   if (!strcmp(pc_attr->attr.name, NCACHE_KOBJ_ID))",
          "896:    new_op->upcall.req.perf_count.type =",
          "899:  } else {",
          "900:   gossip_err(\"sysfs_service_op_show: unknown kobj_id:%s:\\n\",",
          "",
          "[Removed Lines]",
          "791:   new_op->upcall.req.param.type = PVFS2_PARAM_REQUEST_GET;",
          "798:     PVFS2_PARAM_REQUEST_OP_PERF_HISTORY_SIZE;",
          "802:     PVFS2_PARAM_REQUEST_OP_PERF_TIME_INTERVAL_SECS;",
          "806:     PVFS2_PARAM_REQUEST_OP_PERF_RESET;",
          "813:     PVFS2_PARAM_REQUEST_OP_ACACHE_TIMEOUT_MSECS;",
          "817:     PVFS2_PARAM_REQUEST_OP_ACACHE_HARD_LIMIT;",
          "821:     PVFS2_PARAM_REQUEST_OP_ACACHE_SOFT_LIMIT;",
          "825:      PVFS2_PARAM_REQUEST_OP_ACACHE_RECLAIM_PERCENTAGE;",
          "832:     PVFS2_PARAM_REQUEST_OP_CAPCACHE_TIMEOUT_SECS;",
          "836:     PVFS2_PARAM_REQUEST_OP_CAPCACHE_HARD_LIMIT;",
          "840:     PVFS2_PARAM_REQUEST_OP_CAPCACHE_SOFT_LIMIT;",
          "844:      PVFS2_PARAM_REQUEST_OP_CAPCACHE_RECLAIM_PERCENTAGE;",
          "851:     PVFS2_PARAM_REQUEST_OP_CCACHE_TIMEOUT_SECS;",
          "855:     PVFS2_PARAM_REQUEST_OP_CCACHE_HARD_LIMIT;",
          "859:     PVFS2_PARAM_REQUEST_OP_CCACHE_SOFT_LIMIT;",
          "863:      PVFS2_PARAM_REQUEST_OP_CCACHE_RECLAIM_PERCENTAGE;",
          "870:     PVFS2_PARAM_REQUEST_OP_NCACHE_TIMEOUT_MSECS;",
          "874:     PVFS2_PARAM_REQUEST_OP_NCACHE_HARD_LIMIT;",
          "878:     PVFS2_PARAM_REQUEST_OP_NCACHE_SOFT_LIMIT;",
          "882:      PVFS2_PARAM_REQUEST_OP_NCACHE_RECLAIM_PERCENTAGE;",
          "889:     PVFS2_PERF_COUNT_REQUEST_ACACHE;",
          "893:     PVFS2_PERF_COUNT_REQUEST_CAPCACHE;",
          "897:     PVFS2_PERF_COUNT_REQUEST_NCACHE;",
          "",
          "[Added Lines]",
          "791:   new_op->upcall.req.param.type = ORANGEFS_PARAM_REQUEST_GET;",
          "798:     ORANGEFS_PARAM_REQUEST_OP_PERF_HISTORY_SIZE;",
          "802:     ORANGEFS_PARAM_REQUEST_OP_PERF_TIME_INTERVAL_SECS;",
          "806:     ORANGEFS_PARAM_REQUEST_OP_PERF_RESET;",
          "813:     ORANGEFS_PARAM_REQUEST_OP_ACACHE_TIMEOUT_MSECS;",
          "817:     ORANGEFS_PARAM_REQUEST_OP_ACACHE_HARD_LIMIT;",
          "821:     ORANGEFS_PARAM_REQUEST_OP_ACACHE_SOFT_LIMIT;",
          "825:      ORANGEFS_PARAM_REQUEST_OP_ACACHE_RECLAIM_PERCENTAGE;",
          "832:     ORANGEFS_PARAM_REQUEST_OP_CAPCACHE_TIMEOUT_SECS;",
          "836:     ORANGEFS_PARAM_REQUEST_OP_CAPCACHE_HARD_LIMIT;",
          "840:     ORANGEFS_PARAM_REQUEST_OP_CAPCACHE_SOFT_LIMIT;",
          "844:      ORANGEFS_PARAM_REQUEST_OP_CAPCACHE_RECLAIM_PERCENTAGE;",
          "851:     ORANGEFS_PARAM_REQUEST_OP_CCACHE_TIMEOUT_SECS;",
          "855:     ORANGEFS_PARAM_REQUEST_OP_CCACHE_HARD_LIMIT;",
          "859:     ORANGEFS_PARAM_REQUEST_OP_CCACHE_SOFT_LIMIT;",
          "863:      ORANGEFS_PARAM_REQUEST_OP_CCACHE_RECLAIM_PERCENTAGE;",
          "870:     ORANGEFS_PARAM_REQUEST_OP_NCACHE_TIMEOUT_MSECS;",
          "874:     ORANGEFS_PARAM_REQUEST_OP_NCACHE_HARD_LIMIT;",
          "878:     ORANGEFS_PARAM_REQUEST_OP_NCACHE_SOFT_LIMIT;",
          "882:      ORANGEFS_PARAM_REQUEST_OP_NCACHE_RECLAIM_PERCENTAGE;",
          "889:     ORANGEFS_PERF_COUNT_REQUEST_ACACHE;",
          "893:     ORANGEFS_PERF_COUNT_REQUEST_CAPCACHE;",
          "897:     ORANGEFS_PERF_COUNT_REQUEST_NCACHE;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "907:  if (strcmp(kobj_id, PC_KOBJ_ID))",
          "909:  else",
          "918: out:",
          "919:  if (!rc) {",
          "",
          "[Removed Lines]",
          "908:   ser_op_type = \"pvfs2_param\";",
          "910:   ser_op_type = \"pvfs2_perf_count\";",
          "916:  rc = service_operation(new_op, ser_op_type, PVFS2_OP_INTERRUPTIBLE);",
          "",
          "[Added Lines]",
          "908:   ser_op_type = \"orangefs_param\";",
          "910:   ser_op_type = \"orangefs_perf_count\";",
          "916:  rc = service_operation(new_op, ser_op_type, ORANGEFS_OP_INTERRUPTIBLE);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1026: static int sysfs_service_op_store(char *kobj_id, const char *buf, void *attr)",
          "1027: {",
          "1029:  int val = 0;",
          "1030:  int rc = 0;",
          "1031:  struct orangefs_attribute *orangefs_attr;",
          "",
          "[Removed Lines]",
          "1028:  struct pvfs2_kernel_op_s *new_op = NULL;",
          "",
          "[Added Lines]",
          "1028:  struct orangefs_kernel_op_s *new_op = NULL;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1038:        \"sysfs_service_op_store: id:%s:\\n\",",
          "1039:        kobj_id);",
          "1042:  if (!new_op) {",
          "1043:   rc = -ENOMEM;",
          "1044:   goto out;",
          "",
          "[Removed Lines]",
          "1041:  new_op = op_alloc(PVFS2_VFS_OP_PARAM);",
          "",
          "[Added Lines]",
          "1041:  new_op = op_alloc(ORANGEFS_VFS_OP_PARAM);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1066:   if (!strcmp(orangefs_attr->attr.name, \"perf_history_size\")) {",
          "1067:    if (val > 0) {",
          "1068:     new_op->upcall.req.param.op =",
          "1070:    } else {",
          "1071:     rc = 0;",
          "1072:     goto out;",
          "",
          "[Removed Lines]",
          "1069:       PVFS2_PARAM_REQUEST_OP_PERF_HISTORY_SIZE;",
          "",
          "[Added Lines]",
          "1069:       ORANGEFS_PARAM_REQUEST_OP_PERF_HISTORY_SIZE;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1075:        \"perf_time_interval_secs\")) {",
          "1076:    if (val > 0) {",
          "1077:     new_op->upcall.req.param.op =",
          "1079:    } else {",
          "1080:     rc = 0;",
          "1081:     goto out;",
          "",
          "[Removed Lines]",
          "1078:     PVFS2_PARAM_REQUEST_OP_PERF_TIME_INTERVAL_SECS;",
          "",
          "[Added Lines]",
          "1078:     ORANGEFS_PARAM_REQUEST_OP_PERF_TIME_INTERVAL_SECS;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1084:        \"perf_counter_reset\")) {",
          "1085:    if ((val == 0) || (val == 1)) {",
          "1086:     new_op->upcall.req.param.op =",
          "1088:    } else {",
          "1089:     rc = 0;",
          "1090:     goto out;",
          "",
          "[Removed Lines]",
          "1087:      PVFS2_PARAM_REQUEST_OP_PERF_RESET;",
          "",
          "[Added Lines]",
          "1087:      ORANGEFS_PARAM_REQUEST_OP_PERF_RESET;",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1097:   if (!strcmp(acache_attr->attr.name, \"hard_limit\")) {",
          "1098:    if (val > -1) {",
          "1099:     new_op->upcall.req.param.op =",
          "1101:    } else {",
          "1102:     rc = 0;",
          "1103:     goto out;",
          "",
          "[Removed Lines]",
          "1100:       PVFS2_PARAM_REQUEST_OP_ACACHE_HARD_LIMIT;",
          "",
          "[Added Lines]",
          "1100:       ORANGEFS_PARAM_REQUEST_OP_ACACHE_HARD_LIMIT;",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1105:   } else if (!strcmp(acache_attr->attr.name, \"soft_limit\")) {",
          "1106:    if (val > -1) {",
          "1107:     new_op->upcall.req.param.op =",
          "1109:    } else {",
          "1110:     rc = 0;",
          "1111:     goto out;",
          "",
          "[Removed Lines]",
          "1108:       PVFS2_PARAM_REQUEST_OP_ACACHE_SOFT_LIMIT;",
          "",
          "[Added Lines]",
          "1108:       ORANGEFS_PARAM_REQUEST_OP_ACACHE_SOFT_LIMIT;",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1114:        \"reclaim_percentage\")) {",
          "1115:    if ((val > -1) && (val < 101)) {",
          "1116:     new_op->upcall.req.param.op =",
          "1118:    } else {",
          "1119:     rc = 0;",
          "1120:     goto out;",
          "",
          "[Removed Lines]",
          "1117:       PVFS2_PARAM_REQUEST_OP_ACACHE_RECLAIM_PERCENTAGE;",
          "",
          "[Added Lines]",
          "1117:       ORANGEFS_PARAM_REQUEST_OP_ACACHE_RECLAIM_PERCENTAGE;",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "1122:   } else if (!strcmp(acache_attr->attr.name, \"timeout_msecs\")) {",
          "1123:    if (val > -1) {",
          "1124:     new_op->upcall.req.param.op =",
          "1126:    } else {",
          "1127:     rc = 0;",
          "1128:     goto out;",
          "",
          "[Removed Lines]",
          "1125:       PVFS2_PARAM_REQUEST_OP_ACACHE_TIMEOUT_MSECS;",
          "",
          "[Added Lines]",
          "1125:       ORANGEFS_PARAM_REQUEST_OP_ACACHE_TIMEOUT_MSECS;",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "1135:   if (!strcmp(capcache_attr->attr.name, \"hard_limit\")) {",
          "1136:    if (val > -1) {",
          "1137:     new_op->upcall.req.param.op =",
          "1139:    } else {",
          "1140:     rc = 0;",
          "1141:     goto out;",
          "",
          "[Removed Lines]",
          "1138:       PVFS2_PARAM_REQUEST_OP_CAPCACHE_HARD_LIMIT;",
          "",
          "[Added Lines]",
          "1138:       ORANGEFS_PARAM_REQUEST_OP_CAPCACHE_HARD_LIMIT;",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "1143:   } else if (!strcmp(capcache_attr->attr.name, \"soft_limit\")) {",
          "1144:    if (val > -1) {",
          "1145:     new_op->upcall.req.param.op =",
          "1147:    } else {",
          "1148:     rc = 0;",
          "1149:     goto out;",
          "",
          "[Removed Lines]",
          "1146:       PVFS2_PARAM_REQUEST_OP_CAPCACHE_SOFT_LIMIT;",
          "",
          "[Added Lines]",
          "1146:       ORANGEFS_PARAM_REQUEST_OP_CAPCACHE_SOFT_LIMIT;",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "1152:        \"reclaim_percentage\")) {",
          "1153:    if ((val > -1) && (val < 101)) {",
          "1154:     new_op->upcall.req.param.op =",
          "1156:    } else {",
          "1157:     rc = 0;",
          "1158:     goto out;",
          "",
          "[Removed Lines]",
          "1155:       PVFS2_PARAM_REQUEST_OP_CAPCACHE_RECLAIM_PERCENTAGE;",
          "",
          "[Added Lines]",
          "1155:       ORANGEFS_PARAM_REQUEST_OP_CAPCACHE_RECLAIM_PERCENTAGE;",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "1160:   } else if (!strcmp(capcache_attr->attr.name, \"timeout_secs\")) {",
          "1161:    if (val > -1) {",
          "1162:     new_op->upcall.req.param.op =",
          "1164:    } else {",
          "1165:     rc = 0;",
          "1166:     goto out;",
          "",
          "[Removed Lines]",
          "1163:       PVFS2_PARAM_REQUEST_OP_CAPCACHE_TIMEOUT_SECS;",
          "",
          "[Added Lines]",
          "1163:       ORANGEFS_PARAM_REQUEST_OP_CAPCACHE_TIMEOUT_SECS;",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "1173:   if (!strcmp(ccache_attr->attr.name, \"hard_limit\")) {",
          "1174:    if (val > -1) {",
          "1175:     new_op->upcall.req.param.op =",
          "1177:    } else {",
          "1178:     rc = 0;",
          "1179:     goto out;",
          "",
          "[Removed Lines]",
          "1176:       PVFS2_PARAM_REQUEST_OP_CCACHE_HARD_LIMIT;",
          "",
          "[Added Lines]",
          "1176:       ORANGEFS_PARAM_REQUEST_OP_CCACHE_HARD_LIMIT;",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "1181:   } else if (!strcmp(ccache_attr->attr.name, \"soft_limit\")) {",
          "1182:    if (val > -1) {",
          "1183:     new_op->upcall.req.param.op =",
          "1185:    } else {",
          "1186:     rc = 0;",
          "1187:     goto out;",
          "",
          "[Removed Lines]",
          "1184:       PVFS2_PARAM_REQUEST_OP_CCACHE_SOFT_LIMIT;",
          "",
          "[Added Lines]",
          "1184:       ORANGEFS_PARAM_REQUEST_OP_CCACHE_SOFT_LIMIT;",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "1190:        \"reclaim_percentage\")) {",
          "1191:    if ((val > -1) && (val < 101)) {",
          "1192:     new_op->upcall.req.param.op =",
          "1194:    } else {",
          "1195:     rc = 0;",
          "1196:     goto out;",
          "",
          "[Removed Lines]",
          "1193:       PVFS2_PARAM_REQUEST_OP_CCACHE_RECLAIM_PERCENTAGE;",
          "",
          "[Added Lines]",
          "1193:       ORANGEFS_PARAM_REQUEST_OP_CCACHE_RECLAIM_PERCENTAGE;",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "1198:   } else if (!strcmp(ccache_attr->attr.name, \"timeout_secs\")) {",
          "1199:    if (val > -1) {",
          "1200:     new_op->upcall.req.param.op =",
          "1202:    } else {",
          "1203:     rc = 0;",
          "1204:     goto out;",
          "",
          "[Removed Lines]",
          "1201:       PVFS2_PARAM_REQUEST_OP_CCACHE_TIMEOUT_SECS;",
          "",
          "[Added Lines]",
          "1201:       ORANGEFS_PARAM_REQUEST_OP_CCACHE_TIMEOUT_SECS;",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "1211:   if (!strcmp(ncache_attr->attr.name, \"hard_limit\")) {",
          "1212:    if (val > -1) {",
          "1213:     new_op->upcall.req.param.op =",
          "1215:    } else {",
          "1216:     rc = 0;",
          "1217:     goto out;",
          "",
          "[Removed Lines]",
          "1214:       PVFS2_PARAM_REQUEST_OP_NCACHE_HARD_LIMIT;",
          "",
          "[Added Lines]",
          "1214:       ORANGEFS_PARAM_REQUEST_OP_NCACHE_HARD_LIMIT;",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "1219:   } else if (!strcmp(ncache_attr->attr.name, \"soft_limit\")) {",
          "1220:    if (val > -1) {",
          "1221:     new_op->upcall.req.param.op =",
          "1223:    } else {",
          "1224:     rc = 0;",
          "1225:     goto out;",
          "",
          "[Removed Lines]",
          "1222:       PVFS2_PARAM_REQUEST_OP_NCACHE_SOFT_LIMIT;",
          "",
          "[Added Lines]",
          "1222:       ORANGEFS_PARAM_REQUEST_OP_NCACHE_SOFT_LIMIT;",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "1228:        \"reclaim_percentage\")) {",
          "1229:    if ((val > -1) && (val < 101)) {",
          "1230:     new_op->upcall.req.param.op =",
          "1232:    } else {",
          "1233:     rc = 0;",
          "1234:     goto out;",
          "",
          "[Removed Lines]",
          "1231:      PVFS2_PARAM_REQUEST_OP_NCACHE_RECLAIM_PERCENTAGE;",
          "",
          "[Added Lines]",
          "1231:      ORANGEFS_PARAM_REQUEST_OP_NCACHE_RECLAIM_PERCENTAGE;",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "1236:   } else if (!strcmp(ncache_attr->attr.name, \"timeout_msecs\")) {",
          "1237:    if (val > -1) {",
          "1238:     new_op->upcall.req.param.op =",
          "1240:    } else {",
          "1241:     rc = 0;",
          "1242:     goto out;",
          "",
          "[Removed Lines]",
          "1239:       PVFS2_PARAM_REQUEST_OP_NCACHE_TIMEOUT_MSECS;",
          "",
          "[Added Lines]",
          "1239:       ORANGEFS_PARAM_REQUEST_OP_NCACHE_TIMEOUT_MSECS;",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "1250:   goto out;",
          "1251:  }",
          "1255:  new_op->upcall.req.param.value = val;",
          "",
          "[Removed Lines]",
          "1253:  new_op->upcall.req.param.type = PVFS2_PARAM_REQUEST_SET;",
          "",
          "[Added Lines]",
          "1253:  new_op->upcall.req.param.type = ORANGEFS_PARAM_REQUEST_SET;",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "1263:  if (rc < 0) {",
          "1264:   gossip_err(\"sysfs_service_op_store: service op returned:%d:\\n\",",
          "",
          "[Removed Lines]",
          "1261:  rc = service_operation(new_op, \"pvfs2_param\", PVFS2_OP_INTERRUPTIBLE);",
          "",
          "[Added Lines]",
          "1261:  rc = service_operation(new_op, \"orangefs_param\", ORANGEFS_OP_INTERRUPTIBLE);",
          "",
          "---------------"
        ],
        "fs/orangefs/pvfs2-utils.c||fs/orangefs/pvfs2-utils.c": [
          "File: fs/orangefs/pvfs2-utils.c -> fs/orangefs/pvfs2-utils.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "8: #include \"pvfs2-dev-proto.h\"",
          "9: #include \"pvfs2-bufmap.h\"",
          "12: {",
          "15:  if (op) {",
          "16:   switch (op->upcall.type) {",
          "18:    fsid = op->upcall.req.io.refn.fs_id;",
          "19:    break;",
          "21:    fsid = op->upcall.req.lookup.parent_refn.fs_id;",
          "22:    break;",
          "24:    fsid = op->upcall.req.create.parent_refn.fs_id;",
          "25:    break;",
          "27:    fsid = op->upcall.req.getattr.refn.fs_id;",
          "28:    break;",
          "30:    fsid = op->upcall.req.remove.parent_refn.fs_id;",
          "31:    break;",
          "33:    fsid = op->upcall.req.mkdir.parent_refn.fs_id;",
          "34:    break;",
          "36:    fsid = op->upcall.req.readdir.refn.fs_id;",
          "37:    break;",
          "39:    fsid = op->upcall.req.setattr.refn.fs_id;",
          "40:    break;",
          "42:    fsid = op->upcall.req.sym.parent_refn.fs_id;",
          "43:    break;",
          "45:    fsid = op->upcall.req.rename.old_parent_refn.fs_id;",
          "46:    break;",
          "48:    fsid = op->upcall.req.statfs.fs_id;",
          "49:    break;",
          "51:    fsid = op->upcall.req.truncate.refn.fs_id;",
          "52:    break;",
          "54:    fsid = op->upcall.req.ra_cache_flush.refn.fs_id;",
          "55:    break;",
          "57:    fsid = op->upcall.req.fs_umount.fs_id;",
          "58:    break;",
          "60:    fsid = op->upcall.req.getxattr.refn.fs_id;",
          "61:    break;",
          "63:    fsid = op->upcall.req.setxattr.refn.fs_id;",
          "64:    break;",
          "66:    fsid = op->upcall.req.listxattr.refn.fs_id;",
          "67:    break;",
          "69:    fsid = op->upcall.req.removexattr.refn.fs_id;",
          "70:    break;",
          "72:    fsid = op->upcall.req.fsync.refn.fs_id;",
          "73:    break;",
          "74:   default:",
          "",
          "[Removed Lines]",
          "11: __s32 fsid_of_op(struct pvfs2_kernel_op_s *op)",
          "13:  __s32 fsid = PVFS_FS_ID_NULL;",
          "17:   case PVFS2_VFS_OP_FILE_IO:",
          "20:   case PVFS2_VFS_OP_LOOKUP:",
          "23:   case PVFS2_VFS_OP_CREATE:",
          "26:   case PVFS2_VFS_OP_GETATTR:",
          "29:   case PVFS2_VFS_OP_REMOVE:",
          "32:   case PVFS2_VFS_OP_MKDIR:",
          "35:   case PVFS2_VFS_OP_READDIR:",
          "38:   case PVFS2_VFS_OP_SETATTR:",
          "41:   case PVFS2_VFS_OP_SYMLINK:",
          "44:   case PVFS2_VFS_OP_RENAME:",
          "47:   case PVFS2_VFS_OP_STATFS:",
          "50:   case PVFS2_VFS_OP_TRUNCATE:",
          "53:   case PVFS2_VFS_OP_MMAP_RA_FLUSH:",
          "56:   case PVFS2_VFS_OP_FS_UMOUNT:",
          "59:   case PVFS2_VFS_OP_GETXATTR:",
          "62:   case PVFS2_VFS_OP_SETXATTR:",
          "65:   case PVFS2_VFS_OP_LISTXATTR:",
          "68:   case PVFS2_VFS_OP_REMOVEXATTR:",
          "71:   case PVFS2_VFS_OP_FSYNC:",
          "",
          "[Added Lines]",
          "11: __s32 fsid_of_op(struct orangefs_kernel_op_s *op)",
          "13:  __s32 fsid = ORANGEFS_FS_ID_NULL;",
          "17:   case ORANGEFS_VFS_OP_FILE_IO:",
          "20:   case ORANGEFS_VFS_OP_LOOKUP:",
          "23:   case ORANGEFS_VFS_OP_CREATE:",
          "26:   case ORANGEFS_VFS_OP_GETATTR:",
          "29:   case ORANGEFS_VFS_OP_REMOVE:",
          "32:   case ORANGEFS_VFS_OP_MKDIR:",
          "35:   case ORANGEFS_VFS_OP_READDIR:",
          "38:   case ORANGEFS_VFS_OP_SETATTR:",
          "41:   case ORANGEFS_VFS_OP_SYMLINK:",
          "44:   case ORANGEFS_VFS_OP_RENAME:",
          "47:   case ORANGEFS_VFS_OP_STATFS:",
          "50:   case ORANGEFS_VFS_OP_TRUNCATE:",
          "53:   case ORANGEFS_VFS_OP_MMAP_RA_FLUSH:",
          "56:   case ORANGEFS_VFS_OP_FS_UMOUNT:",
          "59:   case ORANGEFS_VFS_OP_GETXATTR:",
          "62:   case ORANGEFS_VFS_OP_SETXATTR:",
          "65:   case ORANGEFS_VFS_OP_LISTXATTR:",
          "68:   case ORANGEFS_VFS_OP_REMOVEXATTR:",
          "71:   case ORANGEFS_VFS_OP_FSYNC:",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "78:  return fsid;",
          "79: }",
          "83: {",
          "85:   inode->i_flags |= S_IMMUTABLE;",
          "86:  else",
          "87:   inode->i_flags &= ~S_IMMUTABLE;",
          "90:   inode->i_flags |= S_APPEND;",
          "91:  else",
          "92:   inode->i_flags &= ~S_APPEND;",
          "95:   inode->i_flags |= S_NOATIME;",
          "96:  else",
          "97:   inode->i_flags &= ~S_NOATIME;",
          "",
          "[Removed Lines]",
          "81: static void pvfs2_set_inode_flags(struct inode *inode,",
          "82:       struct PVFS_sys_attr_s *attrs)",
          "84:  if (attrs->flags & PVFS_IMMUTABLE_FL)",
          "89:  if (attrs->flags & PVFS_APPEND_FL)",
          "94:  if (attrs->flags & PVFS_NOATIME_FL)",
          "",
          "[Added Lines]",
          "81: static void orangefs_set_inode_flags(struct inode *inode,",
          "82:          struct ORANGEFS_sys_attr_s *attrs)",
          "84:  if (attrs->flags & ORANGEFS_IMMUTABLE_FL)",
          "89:  if (attrs->flags & ORANGEFS_APPEND_FL)",
          "94:  if (attrs->flags & ORANGEFS_NOATIME_FL)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "102: static int copy_attributes_to_inode(struct inode *inode,",
          "104:         char *symname)",
          "105: {",
          "106:  int ret = -1;",
          "107:  int perm_mode = 0;",
          "109:  loff_t inode_size = 0;",
          "110:  loff_t rounded_up_size = 0;",
          "",
          "[Removed Lines]",
          "103:         struct PVFS_sys_attr_s *attrs,",
          "108:  struct pvfs2_inode_s *pvfs2_inode = PVFS2_I(inode);",
          "",
          "[Added Lines]",
          "103:         struct ORANGEFS_sys_attr_s *attrs,",
          "108:  struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "127:  gossip_debug(GOSSIP_UTILS_DEBUG,",
          "128:        \"attrs->mask = %x (objtype = %s)\\n\",",
          "129:        attrs->mask,",
          "133:    \"invalid/unknown\");",
          "135:  switch (attrs->objtype) {",
          "139:    inode_size = (loff_t) attrs->size;",
          "140:    rounded_up_size =",
          "141:        (inode_size + (4096 - (inode_size % 4096)));",
          "144:    inode->i_bytes = inode_size;",
          "145:    inode->i_blocks =",
          "146:        (unsigned long)(rounded_up_size / 512);",
          "",
          "[Removed Lines]",
          "130:        attrs->objtype == PVFS_TYPE_METAFILE ? \"file\" :",
          "131:        attrs->objtype == PVFS_TYPE_DIRECTORY ? \"directory\" :",
          "132:        attrs->objtype == PVFS_TYPE_SYMLINK ? \"symlink\" :",
          "136:  case PVFS_TYPE_METAFILE:",
          "137:   pvfs2_set_inode_flags(inode, attrs);",
          "138:   if (attrs->mask & PVFS_ATTR_SYS_SIZE) {",
          "143:    pvfs2_lock_inode(inode);",
          "147:    pvfs2_unlock_inode(inode);",
          "",
          "[Added Lines]",
          "130:        attrs->objtype == ORANGEFS_TYPE_METAFILE ? \"file\" :",
          "131:        attrs->objtype == ORANGEFS_TYPE_DIRECTORY ? \"directory\" :",
          "132:        attrs->objtype == ORANGEFS_TYPE_SYMLINK ? \"symlink\" :",
          "136:  case ORANGEFS_TYPE_METAFILE:",
          "137:   orangefs_set_inode_flags(inode, attrs);",
          "138:   if (attrs->mask & ORANGEFS_ATTR_SYS_SIZE) {",
          "143:    orangefs_lock_inode(inode);",
          "147:    orangefs_unlock_inode(inode);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "155:    inode->i_size = inode_size;",
          "156:   }",
          "157:   break;",
          "159:   if (symname != NULL) {",
          "160:    inode->i_size = (loff_t) strlen(symname);",
          "161:    break;",
          "",
          "[Removed Lines]",
          "158:  case PVFS_TYPE_SYMLINK:",
          "",
          "[Added Lines]",
          "158:  case ORANGEFS_TYPE_SYMLINK:",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "164:  default:",
          "165:   inode->i_size = PAGE_CACHE_SIZE;",
          "168:   inode_set_bytes(inode, inode->i_size);",
          "170:   break;",
          "171:  }",
          "",
          "[Removed Lines]",
          "167:   pvfs2_lock_inode(inode);",
          "169:   pvfs2_unlock_inode(inode);",
          "",
          "[Added Lines]",
          "167:   orangefs_lock_inode(inode);",
          "169:   orangefs_unlock_inode(inode);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "179:  inode->i_mtime.tv_nsec = 0;",
          "180:  inode->i_ctime.tv_nsec = 0;",
          "183:   perm_mode |= S_IXOTH;",
          "185:   perm_mode |= S_IWOTH;",
          "187:   perm_mode |= S_IROTH;",
          "190:   perm_mode |= S_IXGRP;",
          "192:   perm_mode |= S_IWGRP;",
          "194:   perm_mode |= S_IRGRP;",
          "197:   perm_mode |= S_IXUSR;",
          "199:   perm_mode |= S_IWUSR;",
          "201:   perm_mode |= S_IRUSR;",
          "204:   perm_mode |= S_ISGID;",
          "206:   perm_mode |= S_ISUID;",
          "208:  inode->i_mode = perm_mode;",
          "",
          "[Removed Lines]",
          "182:  if (attrs->perms & PVFS_O_EXECUTE)",
          "184:  if (attrs->perms & PVFS_O_WRITE)",
          "186:  if (attrs->perms & PVFS_O_READ)",
          "189:  if (attrs->perms & PVFS_G_EXECUTE)",
          "191:  if (attrs->perms & PVFS_G_WRITE)",
          "193:  if (attrs->perms & PVFS_G_READ)",
          "196:  if (attrs->perms & PVFS_U_EXECUTE)",
          "198:  if (attrs->perms & PVFS_U_WRITE)",
          "200:  if (attrs->perms & PVFS_U_READ)",
          "203:  if (attrs->perms & PVFS_G_SGID)",
          "205:  if (attrs->perms & PVFS_U_SUID)",
          "",
          "[Added Lines]",
          "182:  if (attrs->perms & ORANGEFS_O_EXECUTE)",
          "184:  if (attrs->perms & ORANGEFS_O_WRITE)",
          "186:  if (attrs->perms & ORANGEFS_O_READ)",
          "189:  if (attrs->perms & ORANGEFS_G_EXECUTE)",
          "191:  if (attrs->perms & ORANGEFS_G_WRITE)",
          "193:  if (attrs->perms & ORANGEFS_G_READ)",
          "196:  if (attrs->perms & ORANGEFS_U_EXECUTE)",
          "198:  if (attrs->perms & ORANGEFS_U_WRITE)",
          "200:  if (attrs->perms & ORANGEFS_U_READ)",
          "203:  if (attrs->perms & ORANGEFS_G_SGID)",
          "205:  if (attrs->perms & ORANGEFS_U_SUID)",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "216:  }",
          "218:  switch (attrs->objtype) {",
          "220:   inode->i_mode |= S_IFREG;",
          "221:   ret = 0;",
          "222:   break;",
          "224:   inode->i_mode |= S_IFDIR;",
          "",
          "[Removed Lines]",
          "219:  case PVFS_TYPE_METAFILE:",
          "223:  case PVFS_TYPE_DIRECTORY:",
          "",
          "[Added Lines]",
          "219:  case ORANGEFS_TYPE_METAFILE:",
          "223:  case ORANGEFS_TYPE_DIRECTORY:",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "230:   set_nlink(inode, 1);",
          "231:   ret = 0;",
          "232:   break;",
          "234:   inode->i_mode |= S_IFLNK;",
          "239:     symname,",
          "241:    gossip_debug(GOSSIP_UTILS_DEBUG,",
          "242:          \"Copied attr link target %s\\n\",",
          "244:   }",
          "245:   gossip_debug(GOSSIP_UTILS_DEBUG,",
          "246:         \"symlink mode %o\\n\",",
          "",
          "[Removed Lines]",
          "233:  case PVFS_TYPE_SYMLINK:",
          "237:   if (pvfs2_inode && symname) {",
          "238:    strncpy(pvfs2_inode->link_target,",
          "240:     PVFS_NAME_MAX);",
          "243:          pvfs2_inode->link_target);",
          "",
          "[Added Lines]",
          "233:  case ORANGEFS_TYPE_SYMLINK:",
          "237:   if (orangefs_inode && symname) {",
          "238:    strncpy(orangefs_inode->link_target,",
          "240:     ORANGEFS_NAME_MAX);",
          "243:          orangefs_inode->link_target);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "248:   ret = 0;",
          "249:   break;",
          "250:  default:",
          "252:    attrs->objtype);",
          "253:  }",
          "255:  gossip_debug(GOSSIP_UTILS_DEBUG,",
          "257:        inode->i_mode,",
          "258:        (unsigned long)i_size_read(inode));",
          "",
          "[Removed Lines]",
          "251:   gossip_err(\"pvfs2: copy_attributes_to_inode: got invalid attribute type %x\\n\",",
          "256:        \"pvfs2: copy_attributes_to_inode: setting i_mode to %o, i_size to %lu\\n\",",
          "",
          "[Added Lines]",
          "251:   gossip_err(\"orangefs: copy_attributes_to_inode: got invalid attribute type %x\\n\",",
          "256:        \"orangefs: copy_attributes_to_inode: setting i_mode to %o, i_size to %lu\\n\",",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "267: static inline int copy_attributes_from_inode(struct inode *inode,",
          "269:           struct iattr *iattr)",
          "270: {",
          "271:  umode_t tmp_mode;",
          "",
          "[Removed Lines]",
          "268:           struct PVFS_sys_attr_s *attrs,",
          "",
          "[Added Lines]",
          "268:           struct ORANGEFS_sys_attr_s *attrs,",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "285:  attrs->mask = 0;",
          "286:  if (iattr->ia_valid & ATTR_UID) {",
          "287:   attrs->owner = from_kuid(current_user_ns(), iattr->ia_uid);",
          "289:   gossip_debug(GOSSIP_UTILS_DEBUG, \"(UID) %d\\n\", attrs->owner);",
          "290:  }",
          "291:  if (iattr->ia_valid & ATTR_GID) {",
          "292:   attrs->group = from_kgid(current_user_ns(), iattr->ia_gid);",
          "294:   gossip_debug(GOSSIP_UTILS_DEBUG, \"(GID) %d\\n\", attrs->group);",
          "295:  }",
          "297:  if (iattr->ia_valid & ATTR_ATIME) {",
          "299:   if (iattr->ia_valid & ATTR_ATIME_SET) {",
          "300:    attrs->atime =",
          "303:   }",
          "304:  }",
          "305:  if (iattr->ia_valid & ATTR_MTIME) {",
          "307:   if (iattr->ia_valid & ATTR_MTIME_SET) {",
          "308:    attrs->mtime =",
          "311:   }",
          "312:  }",
          "313:  if (iattr->ia_valid & ATTR_CTIME)",
          "",
          "[Removed Lines]",
          "288:   attrs->mask |= PVFS_ATTR_SYS_UID;",
          "293:   attrs->mask |= PVFS_ATTR_SYS_GID;",
          "298:   attrs->mask |= PVFS_ATTR_SYS_ATIME;",
          "301:        pvfs2_convert_time_field(&iattr->ia_atime);",
          "302:    attrs->mask |= PVFS_ATTR_SYS_ATIME_SET;",
          "306:   attrs->mask |= PVFS_ATTR_SYS_MTIME;",
          "309:        pvfs2_convert_time_field(&iattr->ia_mtime);",
          "310:    attrs->mask |= PVFS_ATTR_SYS_MTIME_SET;",
          "314:   attrs->mask |= PVFS_ATTR_SYS_CTIME;",
          "",
          "[Added Lines]",
          "288:   attrs->mask |= ORANGEFS_ATTR_SYS_UID;",
          "293:   attrs->mask |= ORANGEFS_ATTR_SYS_GID;",
          "298:   attrs->mask |= ORANGEFS_ATTR_SYS_ATIME;",
          "301:        orangefs_convert_time_field(&iattr->ia_atime);",
          "302:    attrs->mask |= ORANGEFS_ATTR_SYS_ATIME_SET;",
          "306:   attrs->mask |= ORANGEFS_ATTR_SYS_MTIME;",
          "309:        orangefs_convert_time_field(&iattr->ia_mtime);",
          "310:    attrs->mask |= ORANGEFS_ATTR_SYS_MTIME_SET;",
          "314:   attrs->mask |= ORANGEFS_ATTR_SYS_CTIME;",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "342:    return -EINVAL;",
          "343:   }",
          "347:  }",
          "349:  return 0;",
          "350: }",
          "357: {",
          "360:  int ret = -EINVAL;",
          "362:  gossip_debug(GOSSIP_UTILS_DEBUG,",
          "",
          "[Removed Lines]",
          "345:   attrs->perms = PVFS_util_translate_mode(tmp_mode);",
          "346:   attrs->mask |= PVFS_ATTR_SYS_PERM;",
          "356: int pvfs2_inode_getattr(struct inode *inode, __u32 getattr_mask)",
          "358:  struct pvfs2_inode_s *pvfs2_inode = PVFS2_I(inode);",
          "359:  struct pvfs2_kernel_op_s *new_op;",
          "",
          "[Added Lines]",
          "345:   attrs->perms = ORANGEFS_util_translate_mode(tmp_mode);",
          "346:   attrs->mask |= ORANGEFS_ATTR_SYS_PERM;",
          "356: int orangefs_inode_getattr(struct inode *inode, __u32 getattr_mask)",
          "358:  struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);",
          "359:  struct orangefs_kernel_op_s *new_op;",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "364:        __func__,",
          "365:        get_khandle_from_ino(inode));",
          "368:  if (!new_op)",
          "369:   return -ENOMEM;",
          "371:  new_op->upcall.req.getattr.mask = getattr_mask;",
          "373:  ret = service_operation(new_op, __func__,",
          "",
          "[Removed Lines]",
          "367:  new_op = op_alloc(PVFS2_VFS_OP_GETATTR);",
          "370:  new_op->upcall.req.getattr.refn = pvfs2_inode->refn;",
          "",
          "[Added Lines]",
          "367:  new_op = op_alloc(ORANGEFS_VFS_OP_GETATTR);",
          "370:  new_op->upcall.req.getattr.refn = orangefs_inode->refn;",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "384:  }",
          "391:  if (new_op->downcall.resp.getattr.attributes.objtype ==",
          "394:    new_op->downcall.resp.getattr.attributes.blksize;",
          "395:  } else {",
          "399:  }",
          "",
          "[Removed Lines]",
          "392:    PVFS_TYPE_METAFILE) {",
          "393:   pvfs2_inode->blksize =",
          "397:   pvfs2_inode->blksize = (1 << inode->i_blkbits);",
          "",
          "[Added Lines]",
          "392:    ORANGEFS_TYPE_METAFILE) {",
          "393:   orangefs_inode->blksize =",
          "397:   orangefs_inode->blksize = (1 << inode->i_blkbits);",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "402:  gossip_debug(GOSSIP_UTILS_DEBUG,",
          "403:        \"Getattr on handle %pU, \"",
          "404:        \"fsid %d\\n  (inode ct = %d) returned %d\\n\",",
          "407:        (int)atomic_read(&inode->i_count),",
          "408:        ret);",
          "",
          "[Removed Lines]",
          "405:        &pvfs2_inode->refn.khandle,",
          "406:        pvfs2_inode->refn.fs_id,",
          "",
          "[Added Lines]",
          "405:        &orangefs_inode->refn.khandle,",
          "406:        orangefs_inode->refn.fs_id,",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "412: }",
          "419: {",
          "422:  int ret;",
          "425:  if (!new_op)",
          "426:   return -ENOMEM;",
          "429:  ret = copy_attributes_from_inode(inode,",
          "430:          &new_op->upcall.req.setattr.attributes,",
          "431:          iattr);",
          "",
          "[Removed Lines]",
          "418: int pvfs2_inode_setattr(struct inode *inode, struct iattr *iattr)",
          "420:  struct pvfs2_inode_s *pvfs2_inode = PVFS2_I(inode);",
          "421:  struct pvfs2_kernel_op_s *new_op;",
          "424:  new_op = op_alloc(PVFS2_VFS_OP_SETATTR);",
          "428:  new_op->upcall.req.setattr.refn = pvfs2_inode->refn;",
          "",
          "[Added Lines]",
          "418: int orangefs_inode_setattr(struct inode *inode, struct iattr *iattr)",
          "420:  struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);",
          "421:  struct orangefs_kernel_op_s *new_op;",
          "424:  new_op = op_alloc(ORANGEFS_VFS_OP_SETATTR);",
          "428:  new_op->upcall.req.setattr.refn = orangefs_inode->refn;",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "438:     get_interruptible_flag(inode));",
          "440:  gossip_debug(GOSSIP_UTILS_DEBUG,",
          "442:        ret);",
          "",
          "[Removed Lines]",
          "441:        \"pvfs2_inode_setattr: returning %d\\n\",",
          "",
          "[Added Lines]",
          "441:        \"orangefs_inode_setattr: returning %d\\n\",",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "451:  if (ret == 0) {",
          "456:  }",
          "458:  return ret;",
          "459: }",
          "462: {",
          "",
          "[Removed Lines]",
          "452:   ClearAtimeFlag(pvfs2_inode);",
          "453:   ClearMtimeFlag(pvfs2_inode);",
          "454:   ClearCtimeFlag(pvfs2_inode);",
          "455:   ClearModeFlag(pvfs2_inode);",
          "461: int pvfs2_flush_inode(struct inode *inode)",
          "",
          "[Added Lines]",
          "452:   ClearAtimeFlag(orangefs_inode);",
          "453:   ClearMtimeFlag(orangefs_inode);",
          "454:   ClearCtimeFlag(orangefs_inode);",
          "455:   ClearModeFlag(orangefs_inode);",
          "461: int orangefs_flush_inode(struct inode *inode)",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "472:  int ctime_flag;",
          "473:  int atime_flag;",
          "474:  int mode_flag;",
          "477:  memset(&wbattr, 0, sizeof(wbattr));",
          "",
          "[Removed Lines]",
          "475:  struct pvfs2_inode_s *pvfs2_inode = PVFS2_I(inode);",
          "",
          "[Added Lines]",
          "475:  struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "484:  mtime_flag = MtimeFlag(pvfs2_inode);",
          "485:  ClearMtimeFlag(pvfs2_inode);",
          "486:  ctime_flag = CtimeFlag(pvfs2_inode);",
          "487:  ClearCtimeFlag(pvfs2_inode);",
          "488:  atime_flag = AtimeFlag(pvfs2_inode);",
          "489:  ClearAtimeFlag(pvfs2_inode);",
          "490:  mode_flag = ModeFlag(pvfs2_inode);",
          "491:  ClearModeFlag(pvfs2_inode);",
          "",
          "[Added Lines]",
          "484:  mtime_flag = MtimeFlag(orangefs_inode);",
          "485:  ClearMtimeFlag(orangefs_inode);",
          "486:  ctime_flag = CtimeFlag(orangefs_inode);",
          "487:  ClearCtimeFlag(orangefs_inode);",
          "488:  atime_flag = AtimeFlag(orangefs_inode);",
          "489:  ClearAtimeFlag(orangefs_inode);",
          "490:  mode_flag = ModeFlag(orangefs_inode);",
          "491:  ClearModeFlag(orangefs_inode);",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "510:  }",
          "512:  gossip_debug(GOSSIP_UTILS_DEBUG,",
          "514:        \"(ia_valid %d)\\n\",",
          "515:        get_khandle_from_ino(inode),",
          "516:        wbattr.ia_valid);",
          "517:  if (wbattr.ia_valid == 0) {",
          "518:   gossip_debug(GOSSIP_UTILS_DEBUG,",
          "520:   return 0;",
          "521:  }",
          "523:  gossip_debug(GOSSIP_UTILS_DEBUG,",
          "525:        get_khandle_from_ino(inode),",
          "526:        inode->i_mode);",
          "530:  return ret;",
          "531: }",
          "534: {",
          "535:  int ret = -EINVAL;",
          "538:  gossip_debug(GOSSIP_UTILS_DEBUG,",
          "540:        sb);",
          "543:  if (!new_op)",
          "544:   return -ENOMEM;",
          "551:  gossip_debug(GOSSIP_UTILS_DEBUG,",
          "557:  gossip_debug(GOSSIP_UTILS_DEBUG,",
          "559:  if (ret)",
          "560:   sb = ERR_PTR(ret);",
          "561:  else",
          "564:  op_release(new_op);",
          "565:  return ret;",
          "",
          "[Removed Lines]",
          "513:        \"*********** pvfs2_flush_inode: %pU \"",
          "519:         \"pvfs2_flush_inode skipping setattr()\\n\");",
          "524:        \"pvfs2_flush_inode (%pU) writing mode %o\\n\",",
          "528:  ret = pvfs2_inode_setattr(inode, &wbattr);",
          "533: int pvfs2_unmount_sb(struct super_block *sb)",
          "536:  struct pvfs2_kernel_op_s *new_op = NULL;",
          "539:        \"pvfs2_unmount_sb called on sb %p\\n\",",
          "542:  new_op = op_alloc(PVFS2_VFS_OP_FS_UMOUNT);",
          "545:  new_op->upcall.req.fs_umount.id = PVFS2_SB(sb)->id;",
          "546:  new_op->upcall.req.fs_umount.fs_id = PVFS2_SB(sb)->fs_id;",
          "547:  strncpy(new_op->upcall.req.fs_umount.pvfs2_config_server,",
          "548:   PVFS2_SB(sb)->devname,",
          "549:   PVFS_MAX_SERVER_ADDR_LEN);",
          "552:        \"Attempting PVFS2 Unmount via host %s\\n\",",
          "553:        new_op->upcall.req.fs_umount.pvfs2_config_server);",
          "555:  ret = service_operation(new_op, \"pvfs2_fs_umount\", 0);",
          "558:        \"pvfs2_unmount: got return value of %d\\n\", ret);",
          "562:   PVFS2_SB(sb)->mount_pending = 1;",
          "",
          "[Added Lines]",
          "513:        \"*********** orangefs_flush_inode: %pU \"",
          "519:         \"orangefs_flush_inode skipping setattr()\\n\");",
          "524:        \"orangefs_flush_inode (%pU) writing mode %o\\n\",",
          "528:  ret = orangefs_inode_setattr(inode, &wbattr);",
          "533: int orangefs_unmount_sb(struct super_block *sb)",
          "536:  struct orangefs_kernel_op_s *new_op = NULL;",
          "539:        \"orangefs_unmount_sb called on sb %p\\n\",",
          "542:  new_op = op_alloc(ORANGEFS_VFS_OP_FS_UMOUNT);",
          "545:  new_op->upcall.req.fs_umount.id = ORANGEFS_SB(sb)->id;",
          "546:  new_op->upcall.req.fs_umount.fs_id = ORANGEFS_SB(sb)->fs_id;",
          "547:  strncpy(new_op->upcall.req.fs_umount.orangefs_config_server,",
          "548:   ORANGEFS_SB(sb)->devname,",
          "549:   ORANGEFS_MAX_SERVER_ADDR_LEN);",
          "552:        \"Attempting ORANGEFS Unmount via host %s\\n\",",
          "553:        new_op->upcall.req.fs_umount.orangefs_config_server);",
          "555:  ret = service_operation(new_op, \"orangefs_fs_umount\", 0);",
          "558:        \"orangefs_unmount: got return value of %d\\n\", ret);",
          "562:   ORANGEFS_SB(sb)->mount_pending = 1;",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "573: {",
          "574:  int ret = -EINVAL;",
          "577:  gossip_debug(GOSSIP_UTILS_DEBUG,",
          "579:        llu(tag));",
          "582:  if (!new_op)",
          "583:   return -ENOMEM;",
          "584:  new_op->upcall.req.cancel.op_tag = tag;",
          "586:  gossip_debug(GOSSIP_UTILS_DEBUG,",
          "588:        llu(new_op->upcall.req.cancel.op_tag));",
          "592:  gossip_debug(GOSSIP_UTILS_DEBUG,",
          "594:        ret);",
          "596:  op_release(new_op);",
          "597:  return ret;",
          "598: }",
          "601: {",
          "602:  if (op) {",
          "603:   spin_lock(&op->lock);",
          "604:   op->io_completed = 0;",
          "608:   op->downcall.status = -1;",
          "610:   op->op_state = OP_VFS_STATE_UNKNOWN;",
          "",
          "[Removed Lines]",
          "572: int pvfs2_cancel_op_in_progress(__u64 tag)",
          "575:  struct pvfs2_kernel_op_s *new_op = NULL;",
          "578:        \"pvfs2_cancel_op_in_progress called on tag %llu\\n\",",
          "581:  new_op = op_alloc(PVFS2_VFS_OP_CANCEL);",
          "587:        \"Attempting PVFS2 operation cancellation of tag %llu\\n\",",
          "590:  ret = service_operation(new_op, \"pvfs2_cancel\", PVFS2_OP_CANCELLATION);",
          "593:        \"pvfs2_cancel_op_in_progress: got return value of %d\\n\",",
          "600: void pvfs2_op_initialize(struct pvfs2_kernel_op_s *op)",
          "606:   op->upcall.type = PVFS2_VFS_OP_INVALID;",
          "607:   op->downcall.type = PVFS2_VFS_OP_INVALID;",
          "",
          "[Added Lines]",
          "572: int orangefs_cancel_op_in_progress(__u64 tag)",
          "575:  struct orangefs_kernel_op_s *new_op = NULL;",
          "578:        \"orangefs_cancel_op_in_progress called on tag %llu\\n\",",
          "581:  new_op = op_alloc(ORANGEFS_VFS_OP_CANCEL);",
          "587:        \"Attempting ORANGEFS operation cancellation of tag %llu\\n\",",
          "590:  ret = service_operation(new_op, \"orangefs_cancel\", ORANGEFS_OP_CANCELLATION);",
          "593:        \"orangefs_cancel_op_in_progress: got return value of %d\\n\",",
          "600: void orangefs_op_initialize(struct orangefs_kernel_op_s *op)",
          "606:   op->upcall.type = ORANGEFS_VFS_OP_INVALID;",
          "607:   op->downcall.type = ORANGEFS_VFS_OP_INVALID;",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "613:  }",
          "614: }",
          "617: {",
          "618:  if (is_root_handle(inode)) {",
          "",
          "[Removed Lines]",
          "616: void pvfs2_make_bad_inode(struct inode *inode)",
          "",
          "[Added Lines]",
          "616: void orangefs_make_bad_inode(struct inode *inode)",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "672:  EACCES, ECONNRESET, ERANGE",
          "673: };",
          "676: {",
          "677:  __u32 i;",
          "",
          "[Removed Lines]",
          "675: int pvfs2_normalize_to_errno(__s32 error_code)",
          "",
          "[Added Lines]",
          "675: int orangefs_normalize_to_errno(__s32 error_code)",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "686:  } else if (error_code > 0) {",
          "689:   error_code = -error_code;",
          "690:  }",
          "702:   if (((-error_code) &",
          "",
          "[Removed Lines]",
          "687:   gossip_err(\"pvfs2: error status receieved.\\n\");",
          "688:   gossip_err(\"pvfs2: assuming error code is inverted.\\n\");",
          "701:  if ((-error_code) & PVFS_NON_ERRNO_ERROR_BIT) {",
          "703:       (PVFS_ERROR_NUMBER_BITS|PVFS_NON_ERRNO_ERROR_BIT|",
          "704:       PVFS_ERROR_BIT)) == PVFS_ECANCEL) {",
          "",
          "[Added Lines]",
          "687:   gossip_err(\"orangefs: error status receieved.\\n\");",
          "688:   gossip_err(\"orangefs: assuming error code is inverted.\\n\");",
          "701:  if ((-error_code) & ORANGEFS_NON_ERRNO_ERROR_BIT) {",
          "703:       (ORANGEFS_ERROR_NUMBER_BITS|ORANGEFS_NON_ERRNO_ERROR_BIT|",
          "704:       ORANGEFS_ERROR_BIT)) == ORANGEFS_ECANCEL) {",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "709:    error_code = -ETIMEDOUT;",
          "710:   } else {",
          "713:    error_code = -EINVAL;",
          "714:   }",
          "719:   if (i < sizeof(PINT_errno_mapping)/sizeof(*PINT_errno_mapping))",
          "720:    error_code = -PINT_errno_mapping[i];",
          "721:   else",
          "722:    error_code = -EINVAL;",
          "728:  } else {",
          "730:  }",
          "731:  return error_code;",
          "732: }",
          "734: #define NUM_MODES 11",
          "736: {",
          "737:  int ret = 0;",
          "738:  int i = 0;",
          "",
          "[Removed Lines]",
          "712:    gossip_err(\"pvfs2: warning: got error code without errno equivalent: %d.\\n\", error_code);",
          "717:  } else if ((-error_code) & PVFS_ERROR_BIT) {",
          "718:   i = (-error_code) & ~(PVFS_ERROR_BIT|PVFS_ERROR_CLASS_BITS);",
          "729:   gossip_err(\"pvfs2: pvfs2_normalize_to_errno: got error code which is not from PVFS2.\\n\");",
          "735: __s32 PVFS_util_translate_mode(int mode)",
          "",
          "[Added Lines]",
          "712:    gossip_err(\"orangefs: warning: got error code without errno equivalent: %d.\\n\", error_code);",
          "717:  } else if ((-error_code) & ORANGEFS_ERROR_BIT) {",
          "718:   i = (-error_code) & ~(ORANGEFS_ERROR_BIT|ORANGEFS_ERROR_CLASS_BITS);",
          "729:   gossip_err(\"orangefs: orangefs_normalize_to_errno: got error code which is not from ORANGEFS.\\n\");",
          "735: __s32 ORANGEFS_util_translate_mode(int mode)",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "742:   S_IXUSR, S_IWUSR, S_IRUSR,",
          "743:   S_ISGID, S_ISUID",
          "744:  };",
          "750:  };",
          "752:  for (i = 0; i < NUM_MODES; i++)",
          "753:   if (mode & modes[i])",
          "756:  return ret;",
          "757: }",
          "",
          "[Removed Lines]",
          "745:  static int pvfs2_modes[NUM_MODES] = {",
          "746:   PVFS_O_EXECUTE, PVFS_O_WRITE, PVFS_O_READ,",
          "747:   PVFS_G_EXECUTE, PVFS_G_WRITE, PVFS_G_READ,",
          "748:   PVFS_U_EXECUTE, PVFS_U_WRITE, PVFS_U_READ,",
          "749:   PVFS_G_SGID, PVFS_U_SUID",
          "754:    ret |= pvfs2_modes[i];",
          "",
          "[Added Lines]",
          "745:  static int orangefs_modes[NUM_MODES] = {",
          "746:   ORANGEFS_O_EXECUTE, ORANGEFS_O_WRITE, ORANGEFS_O_READ,",
          "747:   ORANGEFS_G_EXECUTE, ORANGEFS_G_WRITE, ORANGEFS_G_READ,",
          "748:   ORANGEFS_U_EXECUTE, ORANGEFS_U_WRITE, ORANGEFS_U_READ,",
          "749:   ORANGEFS_G_SGID, ORANGEFS_U_SUID",
          "754:    ret |= orangefs_modes[i];",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "813:          (unsigned long long *)&(cdm_array[i].mask1),",
          "814:          (unsigned long long *)&(cdm_array[i].mask2));",
          "817:    client_verbose_index = i;",
          "820:    client_all_index = i;",
          "822:   cds_head = cds_delimiter + 1;",
          "",
          "[Removed Lines]",
          "816:   if (!strcmp(cdm_array[i].keyword, PVFS2_VERBOSE))",
          "819:   if (!strcmp(cdm_array[i].keyword, PVFS2_ALL))",
          "",
          "[Added Lines]",
          "816:   if (!strcmp(cdm_array[i].keyword, ORANGEFS_VERBOSE))",
          "819:   if (!strcmp(cdm_array[i].keyword, ORANGEFS_ALL))",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "952:   element_count = num_kmod_keyword_mask_map;",
          "953:  }",
          "",
          "[Removed Lines]",
          "955:  memset(debug_string, 0, PVFS2_MAX_DEBUG_STRING_LEN);",
          "",
          "[Added Lines]",
          "955:  memset(debug_string, 0, ORANGEFS_MAX_DEBUG_STRING_LEN);",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "998:  if (*mask & s_kmod_keyword_mask_map[index].mask_val) {",
          "999:   if ((strlen(kernel_debug_string) +",
          "1000:        strlen(s_kmod_keyword_mask_map[index].keyword))",
          "1002:     strcat(kernel_debug_string,",
          "1003:            s_kmod_keyword_mask_map[index].keyword);",
          "1004:     strcat(kernel_debug_string, \",\");",
          "1005:    } else {",
          "1006:     gossip_err(\"%s: overflow!\\n\", __func__);",
          "1008:     goto out;",
          "1009:    }",
          "1010:  }",
          "",
          "[Removed Lines]",
          "1001:    < PVFS2_MAX_DEBUG_STRING_LEN - 1) {",
          "1007:     strcpy(kernel_debug_string, PVFS2_ALL);",
          "",
          "[Added Lines]",
          "1001:    < ORANGEFS_MAX_DEBUG_STRING_LEN - 1) {",
          "1007:     strcpy(kernel_debug_string, ORANGEFS_ALL);",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "1025:      (mask->mask2 & cdm_array[index].mask2)) {",
          "1026:   if ((strlen(client_debug_string) +",
          "1027:        strlen(cdm_array[index].keyword) + 1)",
          "1029:     strcat(client_debug_string,",
          "1030:            cdm_array[index].keyword);",
          "1031:     strcat(client_debug_string, \",\");",
          "1032:    } else {",
          "1033:     gossip_err(\"%s: overflow!\\n\", __func__);",
          "1035:     goto out;",
          "1036:    }",
          "1037:  }",
          "",
          "[Removed Lines]",
          "1028:    < PVFS2_MAX_DEBUG_STRING_LEN - 2) {",
          "1034:     strcpy(client_debug_string, PVFS2_ALL);",
          "",
          "[Added Lines]",
          "1028:    < ORANGEFS_MAX_DEBUG_STRING_LEN - 2) {",
          "1034:     strcpy(client_debug_string, ORANGEFS_ALL);",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "1043: {",
          "1044:  int rc = 0;",
          "1047:   rc = 1;",
          "1049:  return rc;",
          "",
          "[Removed Lines]",
          "1046:  if ((!strcmp(keyword, PVFS2_ALL)) || (!strcmp(keyword, PVFS2_VERBOSE)))",
          "",
          "[Added Lines]",
          "1046:  if ((!strcmp(keyword, ORANGEFS_ALL)) || (!strcmp(keyword, ORANGEFS_VERBOSE)))",
          "",
          "---------------",
          "--- Hunk 34 ---",
          "[Context before]",
          "1068:   if ((c_mask->mask1 == cdm_array[client_all_index].mask1) &&",
          "1069:       (c_mask->mask2 == cdm_array[client_all_index].mask2)) {",
          "1071:    rc = 1;",
          "1072:    goto out;",
          "1073:   }",
          "1075:   if ((c_mask->mask1 == cdm_array[client_verbose_index].mask1) &&",
          "1076:       (c_mask->mask2 == cdm_array[client_verbose_index].mask2)) {",
          "1078:    rc = 1;",
          "1079:    goto out;",
          "1080:   }",
          "",
          "[Removed Lines]",
          "1070:    strcpy(client_debug_string, PVFS2_ALL);",
          "1077:    strcpy(client_debug_string, PVFS2_VERBOSE);",
          "",
          "[Added Lines]",
          "1070:    strcpy(client_debug_string, ORANGEFS_ALL);",
          "1077:    strcpy(client_debug_string, ORANGEFS_VERBOSE);",
          "",
          "---------------",
          "--- Hunk 35 ---",
          "[Context before]",
          "1083:   k_mask = (__u64 *) mask;",
          "1085:   if (*k_mask >= s_kmod_keyword_mask_map[k_all_index].mask_val) {",
          "1087:    rc = 1;",
          "1088:    goto out;",
          "1089:   }",
          "",
          "[Removed Lines]",
          "1086:    strcpy(kernel_debug_string, PVFS2_ALL);",
          "",
          "[Added Lines]",
          "1086:    strcpy(kernel_debug_string, ORANGEFS_ALL);",
          "",
          "---------------"
        ],
        "fs/orangefs/super.c||fs/orangefs/super.c": [
          "File: fs/orangefs/super.c -> fs/orangefs/super.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "11: #include <linux/parser.h>",
          "21: enum {",
          "22:  Opt_intr,",
          "",
          "[Removed Lines]",
          "14: static struct kmem_cache *pvfs2_inode_cache;",
          "17: LIST_HEAD(pvfs2_superblocks);",
          "19: DEFINE_SPINLOCK(pvfs2_superblocks_lock);",
          "",
          "[Added Lines]",
          "14: static struct kmem_cache *orangefs_inode_cache;",
          "17: LIST_HEAD(orangefs_superblocks);",
          "19: DEFINE_SPINLOCK(orangefs_superblocks_lock);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "37: static int parse_mount_options(struct super_block *sb, char *options,",
          "38:   int silent)",
          "39: {",
          "41:  substring_t args[MAX_OPT_ARGS];",
          "42:  char *p;",
          "",
          "[Removed Lines]",
          "40:  struct pvfs2_sb_info_s *pvfs2_sb = PVFS2_SB(sb);",
          "",
          "[Added Lines]",
          "40:  struct orangefs_sb_info_s *orangefs_sb = ORANGEFS_SB(sb);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "48:  sb->s_flags &= ~MS_POSIXACL;",
          "52:  while ((p = strsep(&options, \",\")) != NULL) {",
          "53:   int token;",
          "",
          "[Removed Lines]",
          "49:  pvfs2_sb->flags &= ~PVFS2_OPT_INTR;",
          "50:  pvfs2_sb->flags &= ~PVFS2_OPT_LOCAL_LOCK;",
          "",
          "[Added Lines]",
          "49:  orangefs_sb->flags &= ~ORANGEFS_OPT_INTR;",
          "50:  orangefs_sb->flags &= ~ORANGEFS_OPT_LOCAL_LOCK;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "61:    sb->s_flags |= MS_POSIXACL;",
          "62:    break;",
          "63:   case Opt_intr:",
          "65:    break;",
          "66:   case Opt_local_lock:",
          "68:    break;",
          "69:   default:",
          "70:    goto fail;",
          "",
          "[Removed Lines]",
          "64:    pvfs2_sb->flags |= PVFS2_OPT_INTR;",
          "67:    pvfs2_sb->flags |= PVFS2_OPT_LOCAL_LOCK;",
          "",
          "[Added Lines]",
          "64:    orangefs_sb->flags |= ORANGEFS_OPT_INTR;",
          "67:    orangefs_sb->flags |= ORANGEFS_OPT_LOCAL_LOCK;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "78:  return -EINVAL;",
          "79: }",
          "82: {",
          "89: }",
          "92: {",
          "99:   return NULL;",
          "100:  }",
          "",
          "[Removed Lines]",
          "81: static void pvfs2_inode_cache_ctor(void *req)",
          "83:  struct pvfs2_inode_s *pvfs2_inode = req;",
          "85:  inode_init_once(&pvfs2_inode->vfs_inode);",
          "86:  init_rwsem(&pvfs2_inode->xattr_sem);",
          "88:  pvfs2_inode->vfs_inode.i_version = 1;",
          "91: static struct inode *pvfs2_alloc_inode(struct super_block *sb)",
          "93:  struct pvfs2_inode_s *pvfs2_inode;",
          "95:  pvfs2_inode = kmem_cache_alloc(pvfs2_inode_cache,",
          "96:            PVFS2_CACHE_ALLOC_FLAGS);",
          "97:  if (pvfs2_inode == NULL) {",
          "98:   gossip_err(\"Failed to allocate pvfs2_inode\\n\");",
          "",
          "[Added Lines]",
          "81: static void orangefs_inode_cache_ctor(void *req)",
          "83:  struct orangefs_inode_s *orangefs_inode = req;",
          "85:  inode_init_once(&orangefs_inode->vfs_inode);",
          "86:  init_rwsem(&orangefs_inode->xattr_sem);",
          "88:  orangefs_inode->vfs_inode.i_version = 1;",
          "91: static struct inode *orangefs_alloc_inode(struct super_block *sb)",
          "93:  struct orangefs_inode_s *orangefs_inode;",
          "95:  orangefs_inode = kmem_cache_alloc(orangefs_inode_cache,",
          "96:            ORANGEFS_CACHE_ALLOC_FLAGS);",
          "97:  if (orangefs_inode == NULL) {",
          "98:   gossip_err(\"Failed to allocate orangefs_inode\\n\");",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "112:  gossip_debug(GOSSIP_SUPER_DEBUG,",
          "116: }",
          "119: {",
          "122:  gossip_debug(GOSSIP_SUPER_DEBUG,",
          "123:    \"%s: deallocated %p destroying inode %pU\\n\",",
          "127: }",
          "134: {",
          "135:  int ret = -ENOMEM;",
          "137:  int flags = 0;",
          "138:  struct super_block *sb = NULL;",
          "140:  sb = dentry->d_sb;",
          "142:  gossip_debug(GOSSIP_SUPER_DEBUG,",
          "144:        sb,",
          "148:  if (!new_op)",
          "149:   return ret;",
          "157:  if (new_op->downcall.status < 0)",
          "158:   goto out_op_release;",
          "160:  gossip_debug(GOSSIP_SUPER_DEBUG,",
          "162:        \"%ld blocks total | %ld block size\\n\",",
          "163:        (long)new_op->downcall.resp.statfs.blocks_avail,",
          "164:        (long)new_op->downcall.resp.statfs.blocks_total,",
          "165:        (long)new_op->downcall.resp.statfs.block_size);",
          "167:  buf->f_type = sb->s_magic;",
          "169:  buf->f_bsize = new_op->downcall.resp.statfs.block_size;",
          "172:  buf->f_blocks = (sector_t) new_op->downcall.resp.statfs.blocks_total;",
          "173:  buf->f_bfree = (sector_t) new_op->downcall.resp.statfs.blocks_avail;",
          "",
          "[Removed Lines]",
          "106:  memset(&pvfs2_inode->refn.khandle, 0, 16);",
          "107:  pvfs2_inode->refn.fs_id = PVFS_FS_ID_NULL;",
          "108:  pvfs2_inode->last_failed_block_index_read = 0;",
          "109:  memset(pvfs2_inode->link_target, 0, sizeof(pvfs2_inode->link_target));",
          "110:  pvfs2_inode->pinode_flags = 0;",
          "113:        \"pvfs2_alloc_inode: allocated %p\\n\",",
          "114:        &pvfs2_inode->vfs_inode);",
          "115:  return &pvfs2_inode->vfs_inode;",
          "118: static void pvfs2_destroy_inode(struct inode *inode)",
          "120:  struct pvfs2_inode_s *pvfs2_inode = PVFS2_I(inode);",
          "124:    __func__, pvfs2_inode, get_khandle_from_ino(inode));",
          "126:  kmem_cache_free(pvfs2_inode_cache, pvfs2_inode);",
          "133: static int pvfs2_statfs(struct dentry *dentry, struct kstatfs *buf)",
          "136:  struct pvfs2_kernel_op_s *new_op = NULL;",
          "143:        \"pvfs2_statfs: called on sb %p (fs_id is %d)\\n\",",
          "145:        (int)(PVFS2_SB(sb)->fs_id));",
          "147:  new_op = op_alloc(PVFS2_VFS_OP_STATFS);",
          "150:  new_op->upcall.req.statfs.fs_id = PVFS2_SB(sb)->fs_id;",
          "152:  if (PVFS2_SB(sb)->flags & PVFS2_OPT_INTR)",
          "153:   flags = PVFS2_OP_INTERRUPTIBLE;",
          "155:  ret = service_operation(new_op, \"pvfs2_statfs\", flags);",
          "161:        \"pvfs2_statfs: got %ld blocks available | \"",
          "168:  memcpy(&buf->f_fsid, &PVFS2_SB(sb)->fs_id, sizeof(buf->f_fsid));",
          "170:  buf->f_namelen = PVFS2_NAME_LEN;",
          "",
          "[Added Lines]",
          "106:  memset(&orangefs_inode->refn.khandle, 0, 16);",
          "107:  orangefs_inode->refn.fs_id = ORANGEFS_FS_ID_NULL;",
          "108:  orangefs_inode->last_failed_block_index_read = 0;",
          "109:  memset(orangefs_inode->link_target, 0, sizeof(orangefs_inode->link_target));",
          "110:  orangefs_inode->pinode_flags = 0;",
          "113:        \"orangefs_alloc_inode: allocated %p\\n\",",
          "114:        &orangefs_inode->vfs_inode);",
          "115:  return &orangefs_inode->vfs_inode;",
          "118: static void orangefs_destroy_inode(struct inode *inode)",
          "120:  struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);",
          "124:    __func__, orangefs_inode, get_khandle_from_ino(inode));",
          "126:  kmem_cache_free(orangefs_inode_cache, orangefs_inode);",
          "133: static int orangefs_statfs(struct dentry *dentry, struct kstatfs *buf)",
          "136:  struct orangefs_kernel_op_s *new_op = NULL;",
          "143:        \"orangefs_statfs: called on sb %p (fs_id is %d)\\n\",",
          "145:        (int)(ORANGEFS_SB(sb)->fs_id));",
          "147:  new_op = op_alloc(ORANGEFS_VFS_OP_STATFS);",
          "150:  new_op->upcall.req.statfs.fs_id = ORANGEFS_SB(sb)->fs_id;",
          "152:  if (ORANGEFS_SB(sb)->flags & ORANGEFS_OPT_INTR)",
          "153:   flags = ORANGEFS_OP_INTERRUPTIBLE;",
          "155:  ret = service_operation(new_op, \"orangefs_statfs\", flags);",
          "161:        \"orangefs_statfs: got %ld blocks available | \"",
          "168:  memcpy(&buf->f_fsid, &ORANGEFS_SB(sb)->fs_id, sizeof(buf->f_fsid));",
          "170:  buf->f_namelen = ORANGEFS_NAME_LEN;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "179: out_op_release:",
          "180:  op_release(new_op);",
          "182:  return ret;",
          "183: }",
          "",
          "[Removed Lines]",
          "181:  gossip_debug(GOSSIP_SUPER_DEBUG, \"pvfs2_statfs: returning %d\\n\", ret);",
          "",
          "[Added Lines]",
          "181:  gossip_debug(GOSSIP_SUPER_DEBUG, \"orangefs_statfs: returning %d\\n\", ret);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "190: {",
          "192:  return parse_mount_options(sb, data, 1);",
          "193: }",
          "",
          "[Removed Lines]",
          "189: static int pvfs2_remount_fs(struct super_block *sb, int *flags, char *data)",
          "191:  gossip_debug(GOSSIP_SUPER_DEBUG, \"pvfs2_remount_fs: called\\n\");",
          "",
          "[Added Lines]",
          "189: static int orangefs_remount_fs(struct super_block *sb, int *flags, char *data)",
          "191:  gossip_debug(GOSSIP_SUPER_DEBUG, \"orangefs_remount_fs: called\\n\");",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "211: {",
          "213:  int ret = -EINVAL;",
          "218:  if (!new_op)",
          "219:   return -ENOMEM;",
          "224:  gossip_debug(GOSSIP_SUPER_DEBUG,",
          "235:  gossip_debug(GOSSIP_SUPER_DEBUG,",
          "237:        ret);",
          "238:  if (ret == 0) {",
          "",
          "[Removed Lines]",
          "210: int pvfs2_remount(struct super_block *sb)",
          "212:  struct pvfs2_kernel_op_s *new_op;",
          "215:  gossip_debug(GOSSIP_SUPER_DEBUG, \"pvfs2_remount: called\\n\");",
          "217:  new_op = op_alloc(PVFS2_VFS_OP_FS_MOUNT);",
          "220:  strncpy(new_op->upcall.req.fs_mount.pvfs2_config_server,",
          "221:   PVFS2_SB(sb)->devname,",
          "222:   PVFS_MAX_SERVER_ADDR_LEN);",
          "225:        \"Attempting PVFS2 Remount via host %s\\n\",",
          "226:        new_op->upcall.req.fs_mount.pvfs2_config_server);",
          "233:  ret = service_operation(new_op, \"pvfs2_remount\",",
          "234:   PVFS2_OP_PRIORITY | PVFS2_OP_NO_SEMAPHORE);",
          "236:        \"pvfs2_remount: mount got return value of %d\\n\",",
          "",
          "[Added Lines]",
          "210: int orangefs_remount(struct super_block *sb)",
          "212:  struct orangefs_kernel_op_s *new_op;",
          "215:  gossip_debug(GOSSIP_SUPER_DEBUG, \"orangefs_remount: called\\n\");",
          "217:  new_op = op_alloc(ORANGEFS_VFS_OP_FS_MOUNT);",
          "220:  strncpy(new_op->upcall.req.fs_mount.orangefs_config_server,",
          "221:   ORANGEFS_SB(sb)->devname,",
          "222:   ORANGEFS_MAX_SERVER_ADDR_LEN);",
          "225:        \"Attempting ORANGEFS Remount via host %s\\n\",",
          "226:        new_op->upcall.req.fs_mount.orangefs_config_server);",
          "233:  ret = service_operation(new_op, \"orangefs_remount\",",
          "234:   ORANGEFS_OP_PRIORITY | ORANGEFS_OP_NO_SEMAPHORE);",
          "236:        \"orangefs_remount: mount got return value of %d\\n\",",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "246:  }",
          "248:  op_release(new_op);",
          "",
          "[Removed Lines]",
          "244:   PVFS2_SB(sb)->id = new_op->downcall.resp.fs_mount.id;",
          "245:   PVFS2_SB(sb)->mount_pending = 0;",
          "",
          "[Added Lines]",
          "244:   ORANGEFS_SB(sb)->id = new_op->downcall.resp.fs_mount.id;",
          "245:   ORANGEFS_SB(sb)->mount_pending = 0;",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "259: }",
          "263: {",
          "266:  gossip_debug(GOSSIP_SUPER_DEBUG,",
          "268:        get_khandle_from_ino(inode));",
          "270: }",
          "276:  .drop_inode = generic_delete_inode,",
          "279:  .show_options = generic_show_options,",
          "280: };",
          "283:       struct fid *fid,",
          "284:       int fh_len,",
          "285:       int fh_type)",
          "286: {",
          "289:  if (fh_len < 5 || fh_type > 2)",
          "290:   return NULL;",
          "293:  refn.fs_id = (u32) fid->raw[4];",
          "294:  gossip_debug(GOSSIP_SUPER_DEBUG,",
          "295:        \"fh_to_dentry: handle %pU, fs_id %d\\n\",",
          "296:        &refn.khandle,",
          "297:        refn.fs_id);",
          "300: }",
          "303:       __u32 *fh,",
          "304:       int *max_len,",
          "305:       struct inode *parent)",
          "306: {",
          "307:  int len = parent ? 10 : 5;",
          "308:  int type = 1;",
          "311:  if (*max_len < len) {",
          "312:   gossip_lerr(\"fh buffer is too small for encoding\\n\");",
          "",
          "[Removed Lines]",
          "262: static void pvfs2_dirty_inode(struct inode *inode, int flags)",
          "264:  struct pvfs2_inode_s *pvfs2_inode = PVFS2_I(inode);",
          "267:        \"pvfs2_dirty_inode: %pU\\n\",",
          "269:  SetAtimeFlag(pvfs2_inode);",
          "272: static const struct super_operations pvfs2_s_ops = {",
          "273:  .alloc_inode = pvfs2_alloc_inode,",
          "274:  .destroy_inode = pvfs2_destroy_inode,",
          "275:  .dirty_inode = pvfs2_dirty_inode,",
          "277:  .statfs = pvfs2_statfs,",
          "278:  .remount_fs = pvfs2_remount_fs,",
          "282: static struct dentry *pvfs2_fh_to_dentry(struct super_block *sb,",
          "287:  struct pvfs2_object_kref refn;",
          "292:  PVFS_khandle_from(&(refn.khandle), fid->raw, 16);",
          "299:  return d_obtain_alias(pvfs2_iget(sb, &refn));",
          "302: static int pvfs2_encode_fh(struct inode *inode,",
          "309:  struct pvfs2_object_kref refn;",
          "",
          "[Added Lines]",
          "262: static void orangefs_dirty_inode(struct inode *inode, int flags)",
          "264:  struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);",
          "267:        \"orangefs_dirty_inode: %pU\\n\",",
          "269:  SetAtimeFlag(orangefs_inode);",
          "272: static const struct super_operations orangefs_s_ops = {",
          "273:  .alloc_inode = orangefs_alloc_inode,",
          "274:  .destroy_inode = orangefs_destroy_inode,",
          "275:  .dirty_inode = orangefs_dirty_inode,",
          "277:  .statfs = orangefs_statfs,",
          "278:  .remount_fs = orangefs_remount_fs,",
          "282: static struct dentry *orangefs_fh_to_dentry(struct super_block *sb,",
          "287:  struct orangefs_object_kref refn;",
          "292:  ORANGEFS_khandle_from(&(refn.khandle), fid->raw, 16);",
          "299:  return d_obtain_alias(orangefs_iget(sb, &refn));",
          "302: static int orangefs_encode_fh(struct inode *inode,",
          "309:  struct orangefs_object_kref refn;",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "315:   goto out;",
          "316:  }",
          "320:  fh[4] = refn.fs_id;",
          "322:  gossip_debug(GOSSIP_SUPER_DEBUG,",
          "",
          "[Removed Lines]",
          "318:  refn = PVFS2_I(inode)->refn;",
          "319:  PVFS_khandle_to(&refn.khandle, fh, 16);",
          "",
          "[Added Lines]",
          "318:  refn = ORANGEFS_I(inode)->refn;",
          "319:  ORANGEFS_khandle_to(&refn.khandle, fh, 16);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "328:  if (parent) {",
          "331:   fh[9] = refn.fs_id;",
          "333:   type = 2;",
          "",
          "[Removed Lines]",
          "329:   refn = PVFS2_I(parent)->refn;",
          "330:   PVFS_khandle_to(&refn.khandle, (char *) fh + 20, 16);",
          "",
          "[Added Lines]",
          "329:   refn = ORANGEFS_I(parent)->refn;",
          "330:   ORANGEFS_khandle_to(&refn.khandle, (char *) fh + 20, 16);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "342:  return type;",
          "343: }",
          "348: };",
          "352:   void *data, int silent)",
          "353: {",
          "354:  int ret = -EINVAL;",
          "355:  struct inode *root = NULL;",
          "356:  struct dentry *root_dentry = NULL;",
          "360:  sb->s_fs_info =",
          "363:   return -ENOMEM;",
          "370:  if (data) {",
          "371:   ret = parse_mount_options(sb, data, silent);",
          "",
          "[Removed Lines]",
          "345: static struct export_operations pvfs2_export_ops = {",
          "346:  .encode_fh = pvfs2_encode_fh,",
          "347:  .fh_to_dentry = pvfs2_fh_to_dentry,",
          "350: static int pvfs2_fill_sb(struct super_block *sb,",
          "351:   struct pvfs2_fs_mount_response *fs_mount,",
          "357:  struct pvfs2_object_kref root_object;",
          "361:   kzalloc(sizeof(struct pvfs2_sb_info_s), PVFS2_GFP_FLAGS);",
          "362:  if (!PVFS2_SB(sb))",
          "364:  PVFS2_SB(sb)->sb = sb;",
          "366:  PVFS2_SB(sb)->root_khandle = fs_mount->root_khandle;",
          "367:  PVFS2_SB(sb)->fs_id = fs_mount->fs_id;",
          "368:  PVFS2_SB(sb)->id = fs_mount->id;",
          "",
          "[Added Lines]",
          "345: static struct export_operations orangefs_export_ops = {",
          "346:  .encode_fh = orangefs_encode_fh,",
          "347:  .fh_to_dentry = orangefs_fh_to_dentry,",
          "350: static int orangefs_fill_sb(struct super_block *sb,",
          "351:   struct orangefs_fs_mount_response *fs_mount,",
          "357:  struct orangefs_object_kref root_object;",
          "361:   kzalloc(sizeof(struct orangefs_sb_info_s), ORANGEFS_GFP_FLAGS);",
          "362:  if (!ORANGEFS_SB(sb))",
          "364:  ORANGEFS_SB(sb)->sb = sb;",
          "366:  ORANGEFS_SB(sb)->root_khandle = fs_mount->root_khandle;",
          "367:  ORANGEFS_SB(sb)->fs_id = fs_mount->fs_id;",
          "368:  ORANGEFS_SB(sb)->id = fs_mount->id;",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "374:  }",
          "384:  sb->s_maxbytes = MAX_LFS_FILESIZE;",
          "388:  gossip_debug(GOSSIP_SUPER_DEBUG,",
          "389:        \"get inode %pU, fsid %d\\n\",",
          "390:        &root_object.khandle,",
          "391:        root_object.fs_id);",
          "394:  if (IS_ERR(root))",
          "395:   return PTR_ERR(root);",
          "",
          "[Removed Lines]",
          "377:  sb->s_xattr = pvfs2_xattr_handlers;",
          "378:  sb->s_magic = PVFS2_SUPER_MAGIC;",
          "379:  sb->s_op = &pvfs2_s_ops;",
          "380:  sb->s_d_op = &pvfs2_dentry_operations;",
          "382:  sb->s_blocksize = pvfs_bufmap_size_query();",
          "383:  sb->s_blocksize_bits = pvfs_bufmap_shift_query();",
          "386:  root_object.khandle = PVFS2_SB(sb)->root_khandle;",
          "387:  root_object.fs_id = PVFS2_SB(sb)->fs_id;",
          "393:  root = pvfs2_iget(sb, &root_object);",
          "",
          "[Added Lines]",
          "377:  sb->s_xattr = orangefs_xattr_handlers;",
          "378:  sb->s_magic = ORANGEFS_SUPER_MAGIC;",
          "379:  sb->s_op = &orangefs_s_ops;",
          "380:  sb->s_d_op = &orangefs_dentry_operations;",
          "382:  sb->s_blocksize = orangefs_bufmap_size_query();",
          "383:  sb->s_blocksize_bits = orangefs_bufmap_shift_query();",
          "386:  root_object.khandle = ORANGEFS_SB(sb)->root_khandle;",
          "387:  root_object.fs_id = ORANGEFS_SB(sb)->fs_id;",
          "393:  root = orangefs_iget(sb, &root_object);",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "404:  if (!root_dentry)",
          "405:   return -ENOMEM;",
          "408:  sb->s_root = root_dentry;",
          "409:  return 0;",
          "410: }",
          "413:       int flags,",
          "414:       const char *devname,",
          "415:       void *data)",
          "416: {",
          "417:  int ret = -EINVAL;",
          "418:  struct super_block *sb = ERR_PTR(-EINVAL);",
          "420:  struct dentry *d = ERR_PTR(-EINVAL);",
          "422:  gossip_debug(GOSSIP_SUPER_DEBUG,",
          "424:        devname);",
          "426:  if (!devname) {",
          "",
          "[Removed Lines]",
          "407:  sb->s_export_op = &pvfs2_export_ops;",
          "412: struct dentry *pvfs2_mount(struct file_system_type *fst,",
          "419:  struct pvfs2_kernel_op_s *new_op;",
          "423:        \"pvfs2_mount: called with devname %s\\n\",",
          "",
          "[Added Lines]",
          "407:  sb->s_export_op = &orangefs_export_ops;",
          "412: struct dentry *orangefs_mount(struct file_system_type *fst,",
          "419:  struct orangefs_kernel_op_s *new_op;",
          "423:        \"orangefs_mount: called with devname %s\\n\",",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "428:   return ERR_PTR(-EINVAL);",
          "429:  }",
          "432:  if (!new_op)",
          "433:   return ERR_PTR(-ENOMEM);",
          "436:   devname,",
          "439:  gossip_debug(GOSSIP_SUPER_DEBUG,",
          "444:  gossip_debug(GOSSIP_SUPER_DEBUG,",
          "446:  if (ret)",
          "447:   goto free_op;",
          "450:   gossip_err(\"ERROR: Retrieved null fs_id\\n\");",
          "451:   ret = -EINVAL;",
          "452:   goto free_op;",
          "",
          "[Removed Lines]",
          "431:  new_op = op_alloc(PVFS2_VFS_OP_FS_MOUNT);",
          "435:  strncpy(new_op->upcall.req.fs_mount.pvfs2_config_server,",
          "437:   PVFS_MAX_SERVER_ADDR_LEN);",
          "440:        \"Attempting PVFS2 Mount via host %s\\n\",",
          "441:        new_op->upcall.req.fs_mount.pvfs2_config_server);",
          "443:  ret = service_operation(new_op, \"pvfs2_mount\", 0);",
          "445:        \"pvfs2_mount: mount got return value of %d\\n\", ret);",
          "449:  if (new_op->downcall.resp.fs_mount.fs_id == PVFS_FS_ID_NULL) {",
          "",
          "[Added Lines]",
          "431:  new_op = op_alloc(ORANGEFS_VFS_OP_FS_MOUNT);",
          "435:  strncpy(new_op->upcall.req.fs_mount.orangefs_config_server,",
          "437:   ORANGEFS_MAX_SERVER_ADDR_LEN);",
          "440:        \"Attempting ORANGEFS Mount via host %s\\n\",",
          "441:        new_op->upcall.req.fs_mount.orangefs_config_server);",
          "443:  ret = service_operation(new_op, \"orangefs_mount\", 0);",
          "445:        \"orangefs_mount: mount got return value of %d\\n\", ret);",
          "449:  if (new_op->downcall.resp.fs_mount.fs_id == ORANGEFS_FS_ID_NULL) {",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "459:   goto free_op;",
          "460:  }",
          "463:        &new_op->downcall.resp.fs_mount, data,",
          "464:        flags & MS_SILENT ? 1 : 0);",
          "",
          "[Removed Lines]",
          "462:  ret = pvfs2_fill_sb(sb,",
          "",
          "[Added Lines]",
          "462:  ret = orangefs_fill_sb(sb,",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "476:   devname,",
          "487:  op_release(new_op);",
          "488:  return dget(sb->s_root);",
          "490: free_op:",
          "492:  if (ret == -EINVAL) {",
          "494:   gossip_err(\"Look at pvfs2-client-core log file (typically /tmp/pvfs2-client.log) for more details\\n\");",
          "495:  }",
          "",
          "[Removed Lines]",
          "475:  strncpy(PVFS2_SB(sb)->devname,",
          "477:   PVFS_MAX_SERVER_ADDR_LEN);",
          "480:  PVFS2_SB(sb)->mount_pending = 0;",
          "486:  add_pvfs2_sb(sb);",
          "491:  gossip_err(\"pvfs2_mount: mount request failed with %d\\n\", ret);",
          "493:   gossip_err(\"Ensure that all pvfs2-servers have the same FS configuration files\\n\");",
          "",
          "[Added Lines]",
          "475:  strncpy(ORANGEFS_SB(sb)->devname,",
          "477:   ORANGEFS_MAX_SERVER_ADDR_LEN);",
          "480:  ORANGEFS_SB(sb)->mount_pending = 0;",
          "486:  add_orangefs_sb(sb);",
          "491:  gossip_err(\"orangefs_mount: mount request failed with %d\\n\", ret);",
          "493:   gossip_err(\"Ensure that all orangefs-servers have the same FS configuration files\\n\");",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "499:  return d;",
          "500: }",
          "503: {",
          "516:  kill_anon_super(sb);",
          "520: }",
          "523: {",
          "526:            0,",
          "532:   return -ENOMEM;",
          "533:  }",
          "534:  return 0;",
          "535: }",
          "538: {",
          "540:  return 0;",
          "541: }",
          "",
          "[Removed Lines]",
          "502: void pvfs2_kill_sb(struct super_block *sb)",
          "504:  gossip_debug(GOSSIP_SUPER_DEBUG, \"pvfs2_kill_sb: called\\n\");",
          "510:  pvfs2_unmount_sb(sb);",
          "513:  remove_pvfs2_sb(sb);",
          "519:  kfree(PVFS2_SB(sb));",
          "522: int pvfs2_inode_cache_initialize(void)",
          "524:  pvfs2_inode_cache = kmem_cache_create(\"pvfs2_inode_cache\",",
          "525:            sizeof(struct pvfs2_inode_s),",
          "527:            PVFS2_CACHE_CREATE_FLAGS,",
          "528:            pvfs2_inode_cache_ctor);",
          "530:  if (!pvfs2_inode_cache) {",
          "531:   gossip_err(\"Cannot create pvfs2_inode_cache\\n\");",
          "537: int pvfs2_inode_cache_finalize(void)",
          "539:  kmem_cache_destroy(pvfs2_inode_cache);",
          "",
          "[Added Lines]",
          "502: void orangefs_kill_sb(struct super_block *sb)",
          "504:  gossip_debug(GOSSIP_SUPER_DEBUG, \"orangefs_kill_sb: called\\n\");",
          "510:  orangefs_unmount_sb(sb);",
          "513:  remove_orangefs_sb(sb);",
          "519:  kfree(ORANGEFS_SB(sb));",
          "522: int orangefs_inode_cache_initialize(void)",
          "524:  orangefs_inode_cache = kmem_cache_create(\"orangefs_inode_cache\",",
          "525:            sizeof(struct orangefs_inode_s),",
          "527:            ORANGEFS_CACHE_CREATE_FLAGS,",
          "528:            orangefs_inode_cache_ctor);",
          "530:  if (!orangefs_inode_cache) {",
          "531:   gossip_err(\"Cannot create orangefs_inode_cache\\n\");",
          "537: int orangefs_inode_cache_finalize(void)",
          "539:  kmem_cache_destroy(orangefs_inode_cache);",
          "",
          "---------------"
        ],
        "fs/orangefs/symlink.c||fs/orangefs/symlink.c": [
          "File: fs/orangefs/symlink.c -> fs/orangefs/symlink.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "8: #include \"pvfs2-kernel.h\"",
          "9: #include \"pvfs2-bufmap.h\"",
          "12: {",
          "15:  gossip_debug(GOSSIP_INODE_DEBUG,",
          "16:        \"%s: called on %s (target is %p)\\n\",",
          "",
          "[Removed Lines]",
          "11: static const char *pvfs2_follow_link(struct dentry *dentry, void **cookie)",
          "13:  char *target =  PVFS2_I(dentry->d_inode)->link_target;",
          "",
          "[Added Lines]",
          "11: static const char *orangefs_follow_link(struct dentry *dentry, void **cookie)",
          "13:  char *target =  ORANGEFS_I(dentry->d_inode)->link_target;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "21:  return target;",
          "22: }",
          "25:  .readlink = generic_readlink,",
          "30:  .setxattr = generic_setxattr,",
          "31: };",
          "",
          "[Removed Lines]",
          "24: struct inode_operations pvfs2_symlink_inode_operations = {",
          "26:  .follow_link = pvfs2_follow_link,",
          "27:  .setattr = pvfs2_setattr,",
          "28:  .getattr = pvfs2_getattr,",
          "29:  .listxattr = pvfs2_listxattr,",
          "",
          "[Added Lines]",
          "24: struct inode_operations orangefs_symlink_inode_operations = {",
          "26:  .follow_link = orangefs_follow_link,",
          "27:  .setattr = orangefs_setattr,",
          "28:  .getattr = orangefs_getattr,",
          "29:  .listxattr = orangefs_listxattr,",
          "",
          "---------------"
        ],
        "fs/orangefs/upcall.h||fs/orangefs/upcall.h": [
          "File: fs/orangefs/upcall.h -> fs/orangefs/upcall.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "16:  __s32 async_vfs_io;",
          "17:  __s32 buf_index;",
          "18:  __s32 count;",
          "19:  __s32 __pad1;",
          "20:  __s64 offset;",
          "23:  __s32 readahead_size;",
          "24: };",
          "27:  __s32 sym_follow;",
          "28:  __s32 __pad1;",
          "31: };",
          "37: };",
          "44: };",
          "48:  __u32 mask;",
          "49:  __u32 __pad1;",
          "50: };",
          "55: };",
          "60: };",
          "66: };",
          "70:  __u64 token;",
          "71:  __s32 max_dirent_count;",
          "72:  __s32 buf_index;",
          "73: };",
          "77:  __u64 token;",
          "78:  __s32 max_dirent_count;",
          "79:  __u32 mask;",
          "",
          "[Removed Lines]",
          "15: struct pvfs2_io_request_s {",
          "21:  struct pvfs2_object_kref refn;",
          "22:  enum PVFS_io_type io_type;",
          "26: struct pvfs2_lookup_request_s {",
          "29:  struct pvfs2_object_kref parent_refn;",
          "30:  char d_name[PVFS2_NAME_LEN];",
          "33: struct pvfs2_create_request_s {",
          "34:  struct pvfs2_object_kref parent_refn;",
          "35:  struct PVFS_sys_attr_s attributes;",
          "36:  char d_name[PVFS2_NAME_LEN];",
          "39: struct pvfs2_symlink_request_s {",
          "40:  struct pvfs2_object_kref parent_refn;",
          "41:  struct PVFS_sys_attr_s attributes;",
          "42:  char entry_name[PVFS2_NAME_LEN];",
          "43:  char target[PVFS2_NAME_LEN];",
          "46: struct pvfs2_getattr_request_s {",
          "47:  struct pvfs2_object_kref refn;",
          "52: struct pvfs2_setattr_request_s {",
          "53:  struct pvfs2_object_kref refn;",
          "54:  struct PVFS_sys_attr_s attributes;",
          "57: struct pvfs2_remove_request_s {",
          "58:  struct pvfs2_object_kref parent_refn;",
          "59:  char d_name[PVFS2_NAME_LEN];",
          "62: struct pvfs2_mkdir_request_s {",
          "63:  struct pvfs2_object_kref parent_refn;",
          "64:  struct PVFS_sys_attr_s attributes;",
          "65:  char d_name[PVFS2_NAME_LEN];",
          "68: struct pvfs2_readdir_request_s {",
          "69:  struct pvfs2_object_kref refn;",
          "75: struct pvfs2_readdirplus_request_s {",
          "76:  struct pvfs2_object_kref refn;",
          "",
          "[Added Lines]",
          "15: struct orangefs_io_request_s {",
          "21:  struct orangefs_object_kref refn;",
          "22:  enum ORANGEFS_io_type io_type;",
          "26: struct orangefs_lookup_request_s {",
          "29:  struct orangefs_object_kref parent_refn;",
          "30:  char d_name[ORANGEFS_NAME_LEN];",
          "33: struct orangefs_create_request_s {",
          "34:  struct orangefs_object_kref parent_refn;",
          "35:  struct ORANGEFS_sys_attr_s attributes;",
          "36:  char d_name[ORANGEFS_NAME_LEN];",
          "39: struct orangefs_symlink_request_s {",
          "40:  struct orangefs_object_kref parent_refn;",
          "41:  struct ORANGEFS_sys_attr_s attributes;",
          "42:  char entry_name[ORANGEFS_NAME_LEN];",
          "43:  char target[ORANGEFS_NAME_LEN];",
          "46: struct orangefs_getattr_request_s {",
          "47:  struct orangefs_object_kref refn;",
          "52: struct orangefs_setattr_request_s {",
          "53:  struct orangefs_object_kref refn;",
          "54:  struct ORANGEFS_sys_attr_s attributes;",
          "57: struct orangefs_remove_request_s {",
          "58:  struct orangefs_object_kref parent_refn;",
          "59:  char d_name[ORANGEFS_NAME_LEN];",
          "62: struct orangefs_mkdir_request_s {",
          "63:  struct orangefs_object_kref parent_refn;",
          "64:  struct ORANGEFS_sys_attr_s attributes;",
          "65:  char d_name[ORANGEFS_NAME_LEN];",
          "68: struct orangefs_readdir_request_s {",
          "69:  struct orangefs_object_kref refn;",
          "75: struct orangefs_readdirplus_request_s {",
          "76:  struct orangefs_object_kref refn;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "81:  __s32 __pad1;",
          "82: };",
          "89: };",
          "92:  __s32 fs_id;",
          "93:  __s32 __pad1;",
          "94: };",
          "98:  __s64 size;",
          "99: };",
          "103: };",
          "107: };",
          "110:  __s32 id;",
          "111:  __s32 fs_id;",
          "113: };",
          "117:  __s32 key_sz;",
          "118:  __s32 __pad1;",
          "120: };",
          "125:  __s32 flags;",
          "126:  __s32 __pad1;",
          "127: };",
          "131:  __s32 requested_count;",
          "132:  __s32 __pad1;",
          "133:  __u64 token;",
          "134: };",
          "138:  __s32 key_sz;",
          "139:  __s32 __pad1;",
          "141: };",
          "144:  __u64 op_tag;",
          "145: };",
          "187:  __s64 value;",
          "189: };",
          "195: };",
          "199:  __s32 __pad1;",
          "200: };",
          "203:  __s32 fsid;",
          "204:  __s32 __pad1;",
          "205: };",
          "208:  __s32 type;",
          "209:  __u32 uid;",
          "210:  __u32 gid;",
          "",
          "[Removed Lines]",
          "84: struct pvfs2_rename_request_s {",
          "85:  struct pvfs2_object_kref old_parent_refn;",
          "86:  struct pvfs2_object_kref new_parent_refn;",
          "87:  char d_old_name[PVFS2_NAME_LEN];",
          "88:  char d_new_name[PVFS2_NAME_LEN];",
          "91: struct pvfs2_statfs_request_s {",
          "96: struct pvfs2_truncate_request_s {",
          "97:  struct pvfs2_object_kref refn;",
          "101: struct pvfs2_mmap_ra_cache_flush_request_s {",
          "102:  struct pvfs2_object_kref refn;",
          "105: struct pvfs2_fs_mount_request_s {",
          "106:  char pvfs2_config_server[PVFS_MAX_SERVER_ADDR_LEN];",
          "109: struct pvfs2_fs_umount_request_s {",
          "112:  char pvfs2_config_server[PVFS_MAX_SERVER_ADDR_LEN];",
          "115: struct pvfs2_getxattr_request_s {",
          "116:  struct pvfs2_object_kref refn;",
          "119:  char key[PVFS_MAX_XATTR_NAMELEN];",
          "122: struct pvfs2_setxattr_request_s {",
          "123:  struct pvfs2_object_kref refn;",
          "124:  struct PVFS_keyval_pair keyval;",
          "129: struct pvfs2_listxattr_request_s {",
          "130:  struct pvfs2_object_kref refn;",
          "136: struct pvfs2_removexattr_request_s {",
          "137:  struct pvfs2_object_kref refn;",
          "140:  char key[PVFS_MAX_XATTR_NAMELEN];",
          "143: struct pvfs2_op_cancel_s {",
          "147: struct pvfs2_fsync_request_s {",
          "148:  struct pvfs2_object_kref refn;",
          "149: };",
          "151: enum pvfs2_param_request_type {",
          "152:  PVFS2_PARAM_REQUEST_SET = 1,",
          "153:  PVFS2_PARAM_REQUEST_GET = 2",
          "154: };",
          "156: enum pvfs2_param_request_op {",
          "157:  PVFS2_PARAM_REQUEST_OP_ACACHE_TIMEOUT_MSECS = 1,",
          "158:  PVFS2_PARAM_REQUEST_OP_ACACHE_HARD_LIMIT = 2,",
          "159:  PVFS2_PARAM_REQUEST_OP_ACACHE_SOFT_LIMIT = 3,",
          "160:  PVFS2_PARAM_REQUEST_OP_ACACHE_RECLAIM_PERCENTAGE = 4,",
          "161:  PVFS2_PARAM_REQUEST_OP_PERF_TIME_INTERVAL_SECS = 5,",
          "162:  PVFS2_PARAM_REQUEST_OP_PERF_HISTORY_SIZE = 6,",
          "163:  PVFS2_PARAM_REQUEST_OP_PERF_RESET = 7,",
          "164:  PVFS2_PARAM_REQUEST_OP_NCACHE_TIMEOUT_MSECS = 8,",
          "165:  PVFS2_PARAM_REQUEST_OP_NCACHE_HARD_LIMIT = 9,",
          "166:  PVFS2_PARAM_REQUEST_OP_NCACHE_SOFT_LIMIT = 10,",
          "167:  PVFS2_PARAM_REQUEST_OP_NCACHE_RECLAIM_PERCENTAGE = 11,",
          "168:  PVFS2_PARAM_REQUEST_OP_STATIC_ACACHE_TIMEOUT_MSECS = 12,",
          "169:  PVFS2_PARAM_REQUEST_OP_STATIC_ACACHE_HARD_LIMIT = 13,",
          "170:  PVFS2_PARAM_REQUEST_OP_STATIC_ACACHE_SOFT_LIMIT = 14,",
          "171:  PVFS2_PARAM_REQUEST_OP_STATIC_ACACHE_RECLAIM_PERCENTAGE = 15,",
          "172:  PVFS2_PARAM_REQUEST_OP_CLIENT_DEBUG = 16,",
          "173:  PVFS2_PARAM_REQUEST_OP_CCACHE_TIMEOUT_SECS = 17,",
          "174:  PVFS2_PARAM_REQUEST_OP_CCACHE_HARD_LIMIT = 18,",
          "175:  PVFS2_PARAM_REQUEST_OP_CCACHE_SOFT_LIMIT = 19,",
          "176:  PVFS2_PARAM_REQUEST_OP_CCACHE_RECLAIM_PERCENTAGE = 20,",
          "177:  PVFS2_PARAM_REQUEST_OP_CAPCACHE_TIMEOUT_SECS = 21,",
          "178:  PVFS2_PARAM_REQUEST_OP_CAPCACHE_HARD_LIMIT = 22,",
          "179:  PVFS2_PARAM_REQUEST_OP_CAPCACHE_SOFT_LIMIT = 23,",
          "180:  PVFS2_PARAM_REQUEST_OP_CAPCACHE_RECLAIM_PERCENTAGE = 24,",
          "181:  PVFS2_PARAM_REQUEST_OP_TWO_MASK_VALUES = 25,",
          "182: };",
          "184: struct pvfs2_param_request_s {",
          "185:  enum pvfs2_param_request_type type;",
          "186:  enum pvfs2_param_request_op op;",
          "188:  char s_value[PVFS2_MAX_DEBUG_STRING_LEN];",
          "191: enum pvfs2_perf_count_request_type {",
          "192:  PVFS2_PERF_COUNT_REQUEST_ACACHE = 1,",
          "193:  PVFS2_PERF_COUNT_REQUEST_NCACHE = 2,",
          "194:  PVFS2_PERF_COUNT_REQUEST_CAPCACHE = 3,",
          "197: struct pvfs2_perf_count_request_s {",
          "198:  enum pvfs2_perf_count_request_type type;",
          "202: struct pvfs2_fs_key_request_s {",
          "207: struct pvfs2_upcall_s {",
          "",
          "[Added Lines]",
          "84: struct orangefs_rename_request_s {",
          "85:  struct orangefs_object_kref old_parent_refn;",
          "86:  struct orangefs_object_kref new_parent_refn;",
          "87:  char d_old_name[ORANGEFS_NAME_LEN];",
          "88:  char d_new_name[ORANGEFS_NAME_LEN];",
          "91: struct orangefs_statfs_request_s {",
          "96: struct orangefs_truncate_request_s {",
          "97:  struct orangefs_object_kref refn;",
          "101: struct orangefs_mmap_ra_cache_flush_request_s {",
          "102:  struct orangefs_object_kref refn;",
          "105: struct orangefs_fs_mount_request_s {",
          "106:  char orangefs_config_server[ORANGEFS_MAX_SERVER_ADDR_LEN];",
          "109: struct orangefs_fs_umount_request_s {",
          "112:  char orangefs_config_server[ORANGEFS_MAX_SERVER_ADDR_LEN];",
          "115: struct orangefs_getxattr_request_s {",
          "116:  struct orangefs_object_kref refn;",
          "119:  char key[ORANGEFS_MAX_XATTR_NAMELEN];",
          "122: struct orangefs_setxattr_request_s {",
          "123:  struct orangefs_object_kref refn;",
          "124:  struct ORANGEFS_keyval_pair keyval;",
          "129: struct orangefs_listxattr_request_s {",
          "130:  struct orangefs_object_kref refn;",
          "136: struct orangefs_removexattr_request_s {",
          "137:  struct orangefs_object_kref refn;",
          "140:  char key[ORANGEFS_MAX_XATTR_NAMELEN];",
          "143: struct orangefs_op_cancel_s {",
          "147: struct orangefs_fsync_request_s {",
          "148:  struct orangefs_object_kref refn;",
          "149: };",
          "151: enum orangefs_param_request_type {",
          "152:  ORANGEFS_PARAM_REQUEST_SET = 1,",
          "153:  ORANGEFS_PARAM_REQUEST_GET = 2",
          "154: };",
          "156: enum orangefs_param_request_op {",
          "157:  ORANGEFS_PARAM_REQUEST_OP_ACACHE_TIMEOUT_MSECS = 1,",
          "158:  ORANGEFS_PARAM_REQUEST_OP_ACACHE_HARD_LIMIT = 2,",
          "159:  ORANGEFS_PARAM_REQUEST_OP_ACACHE_SOFT_LIMIT = 3,",
          "160:  ORANGEFS_PARAM_REQUEST_OP_ACACHE_RECLAIM_PERCENTAGE = 4,",
          "161:  ORANGEFS_PARAM_REQUEST_OP_PERF_TIME_INTERVAL_SECS = 5,",
          "162:  ORANGEFS_PARAM_REQUEST_OP_PERF_HISTORY_SIZE = 6,",
          "163:  ORANGEFS_PARAM_REQUEST_OP_PERF_RESET = 7,",
          "164:  ORANGEFS_PARAM_REQUEST_OP_NCACHE_TIMEOUT_MSECS = 8,",
          "165:  ORANGEFS_PARAM_REQUEST_OP_NCACHE_HARD_LIMIT = 9,",
          "166:  ORANGEFS_PARAM_REQUEST_OP_NCACHE_SOFT_LIMIT = 10,",
          "167:  ORANGEFS_PARAM_REQUEST_OP_NCACHE_RECLAIM_PERCENTAGE = 11,",
          "168:  ORANGEFS_PARAM_REQUEST_OP_STATIC_ACACHE_TIMEOUT_MSECS = 12,",
          "169:  ORANGEFS_PARAM_REQUEST_OP_STATIC_ACACHE_HARD_LIMIT = 13,",
          "170:  ORANGEFS_PARAM_REQUEST_OP_STATIC_ACACHE_SOFT_LIMIT = 14,",
          "171:  ORANGEFS_PARAM_REQUEST_OP_STATIC_ACACHE_RECLAIM_PERCENTAGE = 15,",
          "172:  ORANGEFS_PARAM_REQUEST_OP_CLIENT_DEBUG = 16,",
          "173:  ORANGEFS_PARAM_REQUEST_OP_CCACHE_TIMEOUT_SECS = 17,",
          "174:  ORANGEFS_PARAM_REQUEST_OP_CCACHE_HARD_LIMIT = 18,",
          "175:  ORANGEFS_PARAM_REQUEST_OP_CCACHE_SOFT_LIMIT = 19,",
          "176:  ORANGEFS_PARAM_REQUEST_OP_CCACHE_RECLAIM_PERCENTAGE = 20,",
          "177:  ORANGEFS_PARAM_REQUEST_OP_CAPCACHE_TIMEOUT_SECS = 21,",
          "178:  ORANGEFS_PARAM_REQUEST_OP_CAPCACHE_HARD_LIMIT = 22,",
          "179:  ORANGEFS_PARAM_REQUEST_OP_CAPCACHE_SOFT_LIMIT = 23,",
          "180:  ORANGEFS_PARAM_REQUEST_OP_CAPCACHE_RECLAIM_PERCENTAGE = 24,",
          "181:  ORANGEFS_PARAM_REQUEST_OP_TWO_MASK_VALUES = 25,",
          "182: };",
          "184: struct orangefs_param_request_s {",
          "185:  enum orangefs_param_request_type type;",
          "186:  enum orangefs_param_request_op op;",
          "188:  char s_value[ORANGEFS_MAX_DEBUG_STRING_LEN];",
          "191: enum orangefs_perf_count_request_type {",
          "192:  ORANGEFS_PERF_COUNT_REQUEST_ACACHE = 1,",
          "193:  ORANGEFS_PERF_COUNT_REQUEST_NCACHE = 2,",
          "194:  ORANGEFS_PERF_COUNT_REQUEST_CAPCACHE = 3,",
          "197: struct orangefs_perf_count_request_s {",
          "198:  enum orangefs_perf_count_request_type type;",
          "202: struct orangefs_fs_key_request_s {",
          "207: struct orangefs_upcall_s {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "215:  char *trailer_buf;",
          "217:  union {",
          "243:  } req;",
          "244: };",
          "",
          "[Removed Lines]",
          "218:   struct pvfs2_io_request_s io;",
          "219:   struct pvfs2_lookup_request_s lookup;",
          "220:   struct pvfs2_create_request_s create;",
          "221:   struct pvfs2_symlink_request_s sym;",
          "222:   struct pvfs2_getattr_request_s getattr;",
          "223:   struct pvfs2_setattr_request_s setattr;",
          "224:   struct pvfs2_remove_request_s remove;",
          "225:   struct pvfs2_mkdir_request_s mkdir;",
          "226:   struct pvfs2_readdir_request_s readdir;",
          "227:   struct pvfs2_readdirplus_request_s readdirplus;",
          "228:   struct pvfs2_rename_request_s rename;",
          "229:   struct pvfs2_statfs_request_s statfs;",
          "230:   struct pvfs2_truncate_request_s truncate;",
          "231:   struct pvfs2_mmap_ra_cache_flush_request_s ra_cache_flush;",
          "232:   struct pvfs2_fs_mount_request_s fs_mount;",
          "233:   struct pvfs2_fs_umount_request_s fs_umount;",
          "234:   struct pvfs2_getxattr_request_s getxattr;",
          "235:   struct pvfs2_setxattr_request_s setxattr;",
          "236:   struct pvfs2_listxattr_request_s listxattr;",
          "237:   struct pvfs2_removexattr_request_s removexattr;",
          "238:   struct pvfs2_op_cancel_s cancel;",
          "239:   struct pvfs2_fsync_request_s fsync;",
          "240:   struct pvfs2_param_request_s param;",
          "241:   struct pvfs2_perf_count_request_s perf_count;",
          "242:   struct pvfs2_fs_key_request_s fs_key;",
          "",
          "[Added Lines]",
          "218:   struct orangefs_io_request_s io;",
          "219:   struct orangefs_lookup_request_s lookup;",
          "220:   struct orangefs_create_request_s create;",
          "221:   struct orangefs_symlink_request_s sym;",
          "222:   struct orangefs_getattr_request_s getattr;",
          "223:   struct orangefs_setattr_request_s setattr;",
          "224:   struct orangefs_remove_request_s remove;",
          "225:   struct orangefs_mkdir_request_s mkdir;",
          "226:   struct orangefs_readdir_request_s readdir;",
          "227:   struct orangefs_readdirplus_request_s readdirplus;",
          "228:   struct orangefs_rename_request_s rename;",
          "229:   struct orangefs_statfs_request_s statfs;",
          "230:   struct orangefs_truncate_request_s truncate;",
          "231:   struct orangefs_mmap_ra_cache_flush_request_s ra_cache_flush;",
          "232:   struct orangefs_fs_mount_request_s fs_mount;",
          "233:   struct orangefs_fs_umount_request_s fs_umount;",
          "234:   struct orangefs_getxattr_request_s getxattr;",
          "235:   struct orangefs_setxattr_request_s setxattr;",
          "236:   struct orangefs_listxattr_request_s listxattr;",
          "237:   struct orangefs_removexattr_request_s removexattr;",
          "238:   struct orangefs_op_cancel_s cancel;",
          "239:   struct orangefs_fsync_request_s fsync;",
          "240:   struct orangefs_param_request_s param;",
          "241:   struct orangefs_perf_count_request_s perf_count;",
          "242:   struct orangefs_fs_key_request_s fs_key;",
          "",
          "---------------"
        ],
        "fs/orangefs/waitqueue.c||fs/orangefs/waitqueue.c": [
          "File: fs/orangefs/waitqueue.c -> fs/orangefs/waitqueue.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "26: void purge_waiting_ops(void)",
          "27: {",
          "32:   gossip_debug(GOSSIP_WAIT_DEBUG,",
          "33:         \"pvfs2-client-core: purging op tag %llu %s\\n\",",
          "34:         llu(op->tag),",
          "",
          "[Removed Lines]",
          "28:  struct pvfs2_kernel_op_s *op;",
          "30:  spin_lock(&pvfs2_request_list_lock);",
          "31:  list_for_each_entry(op, &pvfs2_request_list, list) {",
          "",
          "[Added Lines]",
          "28:  struct orangefs_kernel_op_s *op;",
          "30:  spin_lock(&orangefs_request_list_lock);",
          "31:  list_for_each_entry(op, &orangefs_request_list, list) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "38:   spin_unlock(&op->lock);",
          "39:   wake_up_interruptible(&op->waitq);",
          "40:  }",
          "42: }",
          "",
          "[Removed Lines]",
          "41:  spin_unlock(&pvfs2_request_list_lock);",
          "",
          "[Added Lines]",
          "41:  spin_unlock(&orangefs_request_list_lock);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "55:         const char *op_name,",
          "56:         int flags)",
          "57: {",
          "",
          "[Removed Lines]",
          "54: int service_operation(struct pvfs2_kernel_op_s *op,",
          "",
          "[Added Lines]",
          "54: int service_operation(struct orangefs_kernel_op_s *op,",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "70: retry_servicing:",
          "71:  op->downcall.status = 0;",
          "72:  gossip_debug(GOSSIP_WAIT_DEBUG,",
          "74:        op_name,",
          "75:        op);",
          "76:  gossip_debug(GOSSIP_WAIT_DEBUG,",
          "78:        current->comm,",
          "79:        current->pid);",
          "83:   block_signals(&orig_sigset);",
          "86:   ret = mutex_lock_interruptible(&request_mutex);",
          "91:   if (ret < 0) {",
          "93:     set_signals(&orig_sigset);",
          "94:    op->downcall.status = ret;",
          "95:    gossip_debug(GOSSIP_WAIT_DEBUG,",
          "97:    return ret;",
          "98:   }",
          "99:  }",
          "",
          "[Removed Lines]",
          "73:        \"pvfs2: service_operation: %s %p\\n\",",
          "77:        \"pvfs2: operation posted by process: %s, pid: %i\\n\",",
          "82:  if (!(flags & PVFS2_OP_INTERRUPTIBLE))",
          "85:  if (!(flags & PVFS2_OP_NO_SEMAPHORE)) {",
          "92:    if (!(flags & PVFS2_OP_INTERRUPTIBLE))",
          "96:          \"pvfs2: service_operation interrupted.\\n\");",
          "",
          "[Added Lines]",
          "73:        \"orangefs: service_operation: %s %p\\n\",",
          "77:        \"orangefs: operation posted by process: %s, pid: %i\\n\",",
          "82:  if (!(flags & ORANGEFS_OP_INTERRUPTIBLE))",
          "85:  if (!(flags & ORANGEFS_OP_NO_SEMAPHORE)) {",
          "92:    if (!(flags & ORANGEFS_OP_INTERRUPTIBLE))",
          "96:          \"orangefs: service_operation interrupted.\\n\");",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "116:  }",
          "120:   add_priority_op_to_request_list(op);",
          "121:  } else {",
          "122:   gossip_debug(GOSSIP_WAIT_DEBUG,",
          "",
          "[Removed Lines]",
          "119:  if (flags & PVFS2_OP_PRIORITY) {",
          "",
          "[Added Lines]",
          "119:  if (flags & ORANGEFS_OP_PRIORITY) {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "125:   add_op_to_request_list(op);",
          "126:  }",
          "129:   mutex_unlock(&request_mutex);",
          "136:   return 0;",
          "139:   gossip_debug(GOSSIP_WAIT_DEBUG,",
          "140:         \"%s:\"",
          "141:         \"About to call wait_for_cancellation_downcall.\\n\",",
          "",
          "[Removed Lines]",
          "128:  if (!(flags & PVFS2_OP_NO_SEMAPHORE))",
          "135:  if (flags & PVFS2_OP_ASYNC)",
          "138:  if (flags & PVFS2_OP_CANCELLATION) {",
          "",
          "[Added Lines]",
          "128:  if (!(flags & ORANGEFS_OP_NO_SEMAPHORE))",
          "135:  if (flags & ORANGEFS_OP_ASYNC)",
          "138:  if (flags & ORANGEFS_OP_CANCELLATION) {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "148:  if (ret < 0) {",
          "150:   if (ret == -ETIMEDOUT) {",
          "152:        op_name);",
          "153:   }",
          "154:   op->downcall.status = ret;",
          "155:  } else {",
          "157:   op->downcall.status =",
          "159:   ret = op->downcall.status;",
          "160:  }",
          "163:   set_signals(&orig_sigset);",
          "165:  BUG_ON(ret != op->downcall.status);",
          "167:  if (!op_state_serviced(op) && op->downcall.status == -EAGAIN) {",
          "168:   gossip_debug(GOSSIP_WAIT_DEBUG,",
          "170:         \" -- operation to be retried (%d attempt)\\n\",",
          "171:         llu(op->tag),",
          "172:         op_name,",
          "",
          "[Removed Lines]",
          "151:    gossip_err(\"pvfs2: %s -- wait timed out; aborting attempt.\\n\",",
          "158:       pvfs2_normalize_to_errno(op->downcall.status);",
          "162:  if (!(flags & PVFS2_OP_INTERRUPTIBLE))",
          "169:         \"pvfs2: tag %llu (%s)\"",
          "",
          "[Added Lines]",
          "151:    gossip_err(\"orangefs: %s -- wait timed out; aborting attempt.\\n\",",
          "158:       orangefs_normalize_to_errno(op->downcall.status);",
          "162:  if (!(flags & ORANGEFS_OP_INTERRUPTIBLE))",
          "169:         \"orangefs: tag %llu (%s)\"",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "206:    spin_lock_irqsave(&op->lock, irqflags);",
          "208:    spin_unlock_irqrestore(&op->lock, irqflags);",
          "210:    set_current_state(TASK_INTERRUPTIBLE);",
          "216:    ret = schedule_timeout(MSECS_TO_JIFFIES",
          "219:    gossip_debug(GOSSIP_WAIT_DEBUG,",
          "220:          \"Value returned from schedule_timeout:\"",
          "",
          "[Removed Lines]",
          "207:    add_wait_queue(&pvfs2_bufmap_init_waitq, &wait_entry);",
          "217:     (1000 * PVFS2_BUFMAP_WAIT_TIMEOUT_SECS));",
          "",
          "[Added Lines]",
          "207:    add_wait_queue(&orangefs_bufmap_init_waitq, &wait_entry);",
          "217:     (1000 * ORANGEFS_BUFMAP_WAIT_TIMEOUT_SECS));",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "225:          get_bufmap_init());",
          "227:    spin_lock_irqsave(&op->lock, irqflags);",
          "229:        &wait_entry);",
          "230:    spin_unlock_irqrestore(&op->lock, irqflags);",
          "232:    if (get_bufmap_init() == 0) {",
          "233:     gossip_err(\"%s:The shared memory system has not started in %d seconds after the client core restarted.  Aborting user's request(%s).\\n\",",
          "234:         __func__,",
          "236:         get_opname_string(op));",
          "237:     return -EIO;",
          "238:    }",
          "",
          "[Removed Lines]",
          "228:    remove_wait_queue(&pvfs2_bufmap_init_waitq,",
          "235:         PVFS2_BUFMAP_WAIT_TIMEOUT_SECS,",
          "",
          "[Added Lines]",
          "228:    remove_wait_queue(&orangefs_bufmap_init_waitq,",
          "235:         ORANGEFS_BUFMAP_WAIT_TIMEOUT_SECS,",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "246:  }",
          "248:  gossip_debug(GOSSIP_WAIT_DEBUG,",
          "250:        op_name,",
          "251:        ret,",
          "252:        op);",
          "253:  return ret;",
          "254: }",
          "257: {",
          "",
          "[Removed Lines]",
          "249:        \"pvfs2: service_operation %s returning: %d for %p.\\n\",",
          "256: void pvfs2_clean_up_interrupted_operation(struct pvfs2_kernel_op_s *op)",
          "",
          "[Added Lines]",
          "249:        \"orangefs: service_operation %s returning: %d for %p.\\n\",",
          "256: void orangefs_clean_up_interrupted_operation(struct orangefs_kernel_op_s *op)",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "343: {",
          "344:  int ret = -EINVAL;",
          "345:  DECLARE_WAITQUEUE(wait_entry, current);",
          "",
          "[Removed Lines]",
          "342: int wait_for_matching_downcall(struct pvfs2_kernel_op_s *op)",
          "",
          "[Added Lines]",
          "342: int wait_for_matching_downcall(struct orangefs_kernel_op_s *op)",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "386:            op,",
          "387:            op->attempts);",
          "388:      ret = -ETIMEDOUT;",
          "390:          (op);",
          "391:      break;",
          "392:     }",
          "",
          "[Removed Lines]",
          "389:      pvfs2_clean_up_interrupted_operation",
          "",
          "[Added Lines]",
          "389:      orangefs_clean_up_interrupted_operation",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "405:    if (op_state_purged(op)) {",
          "407:       -EAGAIN :",
          "408:       -EIO;",
          "409:     spin_unlock(&op->lock);",
          "",
          "[Removed Lines]",
          "406:     ret = (op->attempts < PVFS2_PURGE_RETRY_COUNT) ?",
          "",
          "[Added Lines]",
          "406:     ret = (op->attempts < ORANGEFS_PURGE_RETRY_COUNT) ?",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "415:           llu(op->tag),",
          "416:           op,",
          "417:           op->attempts);",
          "419:     break;",
          "420:    }",
          "421:    spin_unlock(&op->lock);",
          "",
          "[Removed Lines]",
          "418:     pvfs2_clean_up_interrupted_operation(op);",
          "",
          "[Added Lines]",
          "418:     orangefs_clean_up_interrupted_operation(op);",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "429:         __func__,",
          "430:         llu(op->tag),",
          "431:         op);",
          "433:   ret = -EINTR;",
          "434:   break;",
          "435:  }",
          "",
          "[Removed Lines]",
          "432:   pvfs2_clean_up_interrupted_operation(op);",
          "",
          "[Added Lines]",
          "432:   orangefs_clean_up_interrupted_operation(op);",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "456: {",
          "457:  int ret = -EINVAL;",
          "458:  DECLARE_WAITQUEUE(wait_entry, current);",
          "",
          "[Removed Lines]",
          "455: int wait_for_cancellation_downcall(struct pvfs2_kernel_op_s *op)",
          "",
          "[Added Lines]",
          "455: int wait_for_cancellation_downcall(struct orangefs_kernel_op_s *op)",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "482:          __func__,",
          "483:          llu(op->tag),",
          "484:          op);",
          "486:    ret = -EINTR;",
          "487:    break;",
          "488:   }",
          "",
          "[Removed Lines]",
          "485:    pvfs2_clean_up_interrupted_operation(op);",
          "",
          "[Added Lines]",
          "485:    orangefs_clean_up_interrupted_operation(op);",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "502:          \"%s:*** operation timed out: %p\\n\",",
          "503:          __func__,",
          "504:          op);",
          "506:    ret = -ETIMEDOUT;",
          "507:    break;",
          "508:   }",
          "",
          "[Removed Lines]",
          "505:    pvfs2_clean_up_interrupted_operation(op);",
          "",
          "[Added Lines]",
          "505:    orangefs_clean_up_interrupted_operation(op);",
          "",
          "---------------"
        ],
        "fs/orangefs/xattr.c||fs/orangefs/xattr.c": [
          "File: fs/orangefs/xattr.c -> fs/orangefs/xattr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "15: #include <linux/xattr.h>",
          "",
          "[Removed Lines]",
          "18: #define SYSTEM_PVFS2_KEY \"system.pvfs2.\"",
          "19: #define SYSTEM_PVFS2_KEY_LEN 13",
          "",
          "[Added Lines]",
          "18: #define SYSTEM_ORANGEFS_KEY \"system.pvfs2.\"",
          "19: #define SYSTEM_ORANGEFS_KEY_LEN 13",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "29: static int is_reserved_key(const char *key, size_t size)",
          "30: {",
          "33:   return 1;",
          "36: }",
          "38: static inline int convert_to_internal_xattr_flags(int setxattr_flags)",
          "",
          "[Removed Lines]",
          "32:  if (size < SYSTEM_PVFS2_KEY_LEN)",
          "35:  return strncmp(key, SYSTEM_PVFS2_KEY, SYSTEM_PVFS2_KEY_LEN) ?  1 : 0;",
          "",
          "[Added Lines]",
          "32:  if (size < SYSTEM_ORANGEFS_KEY_LEN)",
          "35:  return strncmp(key, SYSTEM_ORANGEFS_KEY, SYSTEM_ORANGEFS_KEY_LEN) ?  1 : 0;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "42:  if (setxattr_flags & XATTR_REPLACE) {",
          "45:  } else if (setxattr_flags & XATTR_CREATE) {",
          "48:  }",
          "49:  return internal_flag;",
          "50: }",
          "",
          "[Removed Lines]",
          "44:   internal_flag = PVFS_XATTR_REPLACE;",
          "47:   internal_flag = PVFS_XATTR_CREATE;",
          "",
          "[Added Lines]",
          "44:   internal_flag = ORANGEFS_XATTR_REPLACE;",
          "47:   internal_flag = ORANGEFS_XATTR_CREATE;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "63:   const char *name, void *buffer, size_t size)",
          "64: {",
          "67:  ssize_t ret = -ENOMEM;",
          "68:  ssize_t length = 0;",
          "69:  int fsuid;",
          "",
          "[Removed Lines]",
          "62: ssize_t pvfs2_inode_getxattr(struct inode *inode, const char *prefix,",
          "65:  struct pvfs2_inode_s *pvfs2_inode = PVFS2_I(inode);",
          "66:  struct pvfs2_kernel_op_s *new_op = NULL;",
          "",
          "[Added Lines]",
          "62: ssize_t orangefs_inode_getxattr(struct inode *inode, const char *prefix,",
          "65:  struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);",
          "66:  struct orangefs_kernel_op_s *new_op = NULL;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "74:        __func__, prefix, name, size);",
          "76:  if (name == NULL || (size > 0 && buffer == NULL)) {",
          "78:   return -EINVAL;",
          "79:  }",
          "81:   gossip_err(\"Invalid key length (%d)\\n\",",
          "82:       (int)(strlen(name) + strlen(prefix)));",
          "83:   return -EINVAL;",
          "",
          "[Removed Lines]",
          "77:   gossip_err(\"pvfs2_inode_getxattr: bogus NULL pointers\\n\");",
          "80:  if ((strlen(name) + strlen(prefix)) >= PVFS_MAX_XATTR_NAMELEN) {",
          "",
          "[Added Lines]",
          "77:   gossip_err(\"orangefs_inode_getxattr: bogus NULL pointers\\n\");",
          "80:  if ((strlen(name) + strlen(prefix)) >= ORANGEFS_MAX_XATTR_NAMELEN) {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "94:        fsuid,",
          "95:        fsgid);",
          "100:  if (!new_op)",
          "101:   goto out_unlock;",
          "104:  ret = snprintf((char *)new_op->upcall.req.getxattr.key,",
          "",
          "[Removed Lines]",
          "97:  down_read(&pvfs2_inode->xattr_sem);",
          "99:  new_op = op_alloc(PVFS2_VFS_OP_GETXATTR);",
          "103:  new_op->upcall.req.getxattr.refn = pvfs2_inode->refn;",
          "105:          PVFS_MAX_XATTR_NAMELEN, \"%s%s\", prefix, name);",
          "",
          "[Added Lines]",
          "97:  down_read(&orangefs_inode->xattr_sem);",
          "99:  new_op = op_alloc(ORANGEFS_VFS_OP_GETXATTR);",
          "103:  new_op->upcall.req.getxattr.refn = orangefs_inode->refn;",
          "105:          ORANGEFS_MAX_XATTR_NAMELEN, \"%s%s\", prefix, name);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "112:  new_op->upcall.req.getxattr.key_sz = ret + 1;",
          "115:     get_interruptible_flag(inode));",
          "116:  if (ret != 0) {",
          "117:   if (ret == -ENOENT) {",
          "118:    ret = -ENODATA;",
          "119:    gossip_debug(GOSSIP_XATTR_DEBUG,",
          "121:          \" does not exist!\\n\",",
          "122:          get_khandle_from_ino(inode),",
          "123:          (char *)new_op->upcall.req.getxattr.key);",
          "",
          "[Removed Lines]",
          "114:  ret = service_operation(new_op, \"pvfs2_inode_getxattr\",",
          "120:          \"pvfs2_inode_getxattr: inode %pU key %s\"",
          "",
          "[Added Lines]",
          "114:  ret = service_operation(new_op, \"orangefs_inode_getxattr\",",
          "120:          \"orangefs_inode_getxattr: inode %pU key %s\"",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "149:  memset(buffer, 0, size);",
          "150:  memcpy(buffer, new_op->downcall.resp.getxattr.val, length);",
          "151:  gossip_debug(GOSSIP_XATTR_DEBUG,",
          "153:       \"key %s key_sz %d, val_len %d\\n\",",
          "154:       get_khandle_from_ino(inode),",
          "155:       (char *)new_op->",
          "",
          "[Removed Lines]",
          "152:       \"pvfs2_inode_getxattr: inode %pU \"",
          "",
          "[Added Lines]",
          "152:       \"orangefs_inode_getxattr: inode %pU \"",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "163: out_release_op:",
          "164:  op_release(new_op);",
          "165: out_unlock:",
          "167:  return ret;",
          "168: }",
          "171:        const char *prefix,",
          "172:        const char *name,",
          "173:        int flags)",
          "174: {",
          "177:  int ret = -ENOMEM;",
          "181:  if (!new_op)",
          "182:   goto out_unlock;",
          "190:  ret = snprintf((char *)new_op->upcall.req.removexattr.key,",
          "192:          \"%s%s\",",
          "193:          (prefix ? prefix : \"\"),",
          "194:          name);",
          "195:  new_op->upcall.req.removexattr.key_sz = ret + 1;",
          "197:  gossip_debug(GOSSIP_XATTR_DEBUG,",
          "199:        (char *)new_op->upcall.req.removexattr.key,",
          "200:        (int)new_op->upcall.req.removexattr.key_sz);",
          "202:  ret = service_operation(new_op,",
          "204:     get_interruptible_flag(inode));",
          "205:  if (ret == -ENOENT) {",
          "",
          "[Removed Lines]",
          "166:  up_read(&pvfs2_inode->xattr_sem);",
          "170: static int pvfs2_inode_removexattr(struct inode *inode,",
          "175:  struct pvfs2_inode_s *pvfs2_inode = PVFS2_I(inode);",
          "176:  struct pvfs2_kernel_op_s *new_op = NULL;",
          "179:  down_write(&pvfs2_inode->xattr_sem);",
          "180:  new_op = op_alloc(PVFS2_VFS_OP_REMOVEXATTR);",
          "184:  new_op->upcall.req.removexattr.refn = pvfs2_inode->refn;",
          "191:          PVFS_MAX_XATTR_NAMELEN,",
          "198:        \"pvfs2_inode_removexattr: key %s, key_sz %d\\n\",",
          "203:     \"pvfs2_inode_removexattr\",",
          "",
          "[Added Lines]",
          "166:  up_read(&orangefs_inode->xattr_sem);",
          "170: static int orangefs_inode_removexattr(struct inode *inode,",
          "175:  struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);",
          "176:  struct orangefs_kernel_op_s *new_op = NULL;",
          "179:  down_write(&orangefs_inode->xattr_sem);",
          "180:  new_op = op_alloc(ORANGEFS_VFS_OP_REMOVEXATTR);",
          "184:  new_op->upcall.req.removexattr.refn = orangefs_inode->refn;",
          "191:          ORANGEFS_MAX_XATTR_NAMELEN,",
          "198:        \"orangefs_inode_removexattr: key %s, key_sz %d\\n\",",
          "203:     \"orangefs_inode_removexattr\",",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "213:  }",
          "215:  gossip_debug(GOSSIP_XATTR_DEBUG,",
          "218:  op_release(new_op);",
          "219: out_unlock:",
          "221:  return ret;",
          "222: }",
          "",
          "[Removed Lines]",
          "216:        \"pvfs2_inode_removexattr: returning %d\\n\", ret);",
          "220:  up_write(&pvfs2_inode->xattr_sem);",
          "",
          "[Added Lines]",
          "216:        \"orangefs_inode_removexattr: returning %d\\n\", ret);",
          "220:  up_write(&orangefs_inode->xattr_sem);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "231:   const char *name, const void *value, size_t size, int flags)",
          "232: {",
          "235:  int internal_flag = 0;",
          "236:  int ret = -ENOMEM;",
          "",
          "[Removed Lines]",
          "230: int pvfs2_inode_setxattr(struct inode *inode, const char *prefix,",
          "233:  struct pvfs2_inode_s *pvfs2_inode = PVFS2_I(inode);",
          "234:  struct pvfs2_kernel_op_s *new_op;",
          "",
          "[Added Lines]",
          "230: int orangefs_inode_setxattr(struct inode *inode, const char *prefix,",
          "233:  struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);",
          "234:  struct orangefs_kernel_op_s *new_op;",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "240:        __func__, prefix, name, size);",
          "242:  if (size < 0 ||",
          "244:      flags < 0) {",
          "246:       (int)size,",
          "247:       flags);",
          "248:   return -EINVAL;",
          "",
          "[Removed Lines]",
          "243:      size >= PVFS_MAX_XATTR_VALUELEN ||",
          "245:   gossip_err(\"pvfs2_inode_setxattr: bogus values of size(%d), flags(%d)\\n\",",
          "",
          "[Added Lines]",
          "243:      size >= ORANGEFS_MAX_XATTR_VALUELEN ||",
          "245:   gossip_err(\"orangefs_inode_setxattr: bogus values of size(%d), flags(%d)\\n\",",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "251:  if (name == NULL ||",
          "252:      (size > 0 && value == NULL)) {",
          "254:   return -EINVAL;",
          "255:  }",
          "257:  internal_flag = convert_to_internal_xattr_flags(flags);",
          "259:  if (prefix) {",
          "261:    gossip_err",
          "263:         (int)(strlen(name) + strlen(prefix)));",
          "264:    return -EINVAL;",
          "265:   }",
          "266:  } else {",
          "268:    gossip_err",
          "270:         (int)(strlen(name)));",
          "271:    return -EINVAL;",
          "272:   }",
          "",
          "[Removed Lines]",
          "253:   gossip_err(\"pvfs2_inode_setxattr: bogus NULL pointers!\\n\");",
          "260:   if (strlen(name) + strlen(prefix) >= PVFS_MAX_XATTR_NAMELEN) {",
          "262:        (\"pvfs2_inode_setxattr: bogus key size (%d)\\n\",",
          "267:   if (strlen(name) >= PVFS_MAX_XATTR_NAMELEN) {",
          "269:        (\"pvfs2_inode_setxattr: bogus key size (%d)\\n\",",
          "",
          "[Added Lines]",
          "253:   gossip_err(\"orangefs_inode_setxattr: bogus NULL pointers!\\n\");",
          "260:   if (strlen(name) + strlen(prefix) >= ORANGEFS_MAX_XATTR_NAMELEN) {",
          "262:        (\"orangefs_inode_setxattr: bogus key size (%d)\\n\",",
          "267:   if (strlen(name) >= ORANGEFS_MAX_XATTR_NAMELEN) {",
          "269:        (\"orangefs_inode_setxattr: bogus key size (%d)\\n\",",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "278:         \"removing xattr (%s%s)\\n\",",
          "279:         prefix,",
          "280:         name);",
          "282:  }",
          "284:  gossip_debug(GOSSIP_XATTR_DEBUG,",
          "",
          "[Removed Lines]",
          "281:   return pvfs2_inode_removexattr(inode, prefix, name, flags);",
          "",
          "[Added Lines]",
          "281:   return orangefs_inode_removexattr(inode, prefix, name, flags);",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "286:        get_khandle_from_ino(inode),",
          "287:        name);",
          "291:  if (!new_op)",
          "292:   goto out_unlock;",
          "296:  new_op->upcall.req.setxattr.flags = internal_flag;",
          "",
          "[Removed Lines]",
          "289:  down_write(&pvfs2_inode->xattr_sem);",
          "290:  new_op = op_alloc(PVFS2_VFS_OP_SETXATTR);",
          "295:  new_op->upcall.req.setxattr.refn = pvfs2_inode->refn;",
          "",
          "[Added Lines]",
          "289:  down_write(&orangefs_inode->xattr_sem);",
          "290:  new_op = op_alloc(ORANGEFS_VFS_OP_SETXATTR);",
          "295:  new_op->upcall.req.setxattr.refn = orangefs_inode->refn;",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "302:  ret = snprintf((char *)new_op->upcall.req.setxattr.keyval.key,",
          "304:          \"%s%s\",",
          "305:          prefix, name);",
          "306:  new_op->upcall.req.setxattr.keyval.key_sz = ret + 1;",
          "",
          "[Removed Lines]",
          "303:          PVFS_MAX_XATTR_NAMELEN,",
          "",
          "[Added Lines]",
          "303:          ORANGEFS_MAX_XATTR_NAMELEN,",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "308:  new_op->upcall.req.setxattr.keyval.val_sz = size;",
          "310:  gossip_debug(GOSSIP_XATTR_DEBUG,",
          "312:        \" value size %zd\\n\",",
          "313:        (char *)new_op->upcall.req.setxattr.keyval.key,",
          "314:        (int)new_op->upcall.req.setxattr.keyval.key_sz,",
          "315:        size);",
          "317:  ret = service_operation(new_op,",
          "319:     get_interruptible_flag(inode));",
          "321:  gossip_debug(GOSSIP_XATTR_DEBUG,",
          "323:        ret);",
          "326:  op_release(new_op);",
          "327: out_unlock:",
          "329:  return ret;",
          "330: }",
          "",
          "[Removed Lines]",
          "311:        \"pvfs2_inode_setxattr: key %s, key_sz %d \"",
          "318:     \"pvfs2_inode_setxattr\",",
          "322:        \"pvfs2_inode_setxattr: returning %d\\n\",",
          "328:  up_write(&pvfs2_inode->xattr_sem);",
          "",
          "[Added Lines]",
          "311:        \"orangefs_inode_setxattr: key %s, key_sz %d \"",
          "318:     \"orangefs_inode_setxattr\",",
          "322:        \"orangefs_inode_setxattr: returning %d\\n\",",
          "328:  up_write(&orangefs_inode->xattr_sem);",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "340: {",
          "341:  struct inode *inode = dentry->d_inode;",
          "345:  ssize_t ret = -ENOMEM;",
          "346:  ssize_t total = 0;",
          "347:  ssize_t length = 0;",
          "",
          "[Removed Lines]",
          "339: ssize_t pvfs2_listxattr(struct dentry *dentry, char *buffer, size_t size)",
          "342:  struct pvfs2_inode_s *pvfs2_inode = PVFS2_I(inode);",
          "343:  struct pvfs2_kernel_op_s *new_op;",
          "344:  __u64 token = PVFS_ITERATE_START;",
          "",
          "[Added Lines]",
          "339: ssize_t orangefs_listxattr(struct dentry *dentry, char *buffer, size_t size)",
          "342:  struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);",
          "343:  struct orangefs_kernel_op_s *new_op;",
          "344:  __u64 token = ORANGEFS_ITERATE_START;",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "358:   return -EINVAL;",
          "359:  }",
          "363:  if (!new_op)",
          "364:   goto out_unlock;",
          "",
          "[Removed Lines]",
          "361:  down_read(&pvfs2_inode->xattr_sem);",
          "362:  new_op = op_alloc(PVFS2_VFS_OP_LISTXATTR);",
          "",
          "[Added Lines]",
          "361:  down_read(&orangefs_inode->xattr_sem);",
          "362:  new_op = op_alloc(ORANGEFS_VFS_OP_LISTXATTR);",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "369: try_again:",
          "370:  key_size = 0;",
          "372:  new_op->upcall.req.listxattr.token = token;",
          "373:  new_op->upcall.req.listxattr.requested_count =",
          "375:  ret = service_operation(new_op, __func__,",
          "376:     get_interruptible_flag(inode));",
          "377:  if (ret != 0)",
          "",
          "[Removed Lines]",
          "371:  new_op->upcall.req.listxattr.refn = pvfs2_inode->refn;",
          "374:      (size == 0) ? 0 : PVFS_MAX_XATTR_LISTLEN;",
          "",
          "[Added Lines]",
          "371:  new_op->upcall.req.listxattr.refn = orangefs_inode->refn;",
          "374:      (size == 0) ? 0 : ORANGEFS_MAX_XATTR_LISTLEN;",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "386:   total = new_op->downcall.resp.listxattr.returned_count *",
          "388:   goto done;",
          "389:  }",
          "",
          "[Removed Lines]",
          "387:    PVFS_MAX_XATTR_NAMELEN;",
          "",
          "[Added Lines]",
          "387:    ORANGEFS_MAX_XATTR_NAMELEN;",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "431:  token = new_op->downcall.resp.listxattr.token;",
          "433:   goto try_again;",
          "435: done:",
          "",
          "[Removed Lines]",
          "432:  if (token != PVFS_ITERATE_END)",
          "",
          "[Added Lines]",
          "432:  if (token != ORANGEFS_ITERATE_END)",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "443:  if (ret == 0)",
          "444:   ret = total;",
          "445: out_unlock:",
          "447:  return ret;",
          "448: }",
          "456: {",
          "459:         name,",
          "460:         buffer,",
          "461:         size,",
          "462:         flags);",
          "463: }",
          "470: {",
          "473:         name,",
          "474:         buffer,",
          "475:         size);",
          "477: }",
          "485: {",
          "488:         name,",
          "489:         buffer,",
          "490:         size,",
          "491:         flags);",
          "492: }",
          "499: {",
          "502:         name,",
          "503:         buffer,",
          "504:         size);",
          "505: }",
          "511: };",
          "522: };",
          "525:  &posix_acl_access_xattr_handler,",
          "526:  &posix_acl_default_xattr_handler,",
          "529:  NULL",
          "530: };",
          "",
          "[Removed Lines]",
          "446:  up_read(&pvfs2_inode->xattr_sem);",
          "450: static int pvfs2_xattr_set_default(const struct xattr_handler *handler,",
          "451:        struct dentry *dentry,",
          "452:        const char *name,",
          "453:        const void *buffer,",
          "454:        size_t size,",
          "455:        int flags)",
          "457:  return pvfs2_inode_setxattr(dentry->d_inode,",
          "458:         PVFS2_XATTR_NAME_DEFAULT_PREFIX,",
          "465: static int pvfs2_xattr_get_default(const struct xattr_handler *handler,",
          "466:        struct dentry *dentry,",
          "467:        const char *name,",
          "468:        void *buffer,",
          "469:        size_t size)",
          "471:  return pvfs2_inode_getxattr(dentry->d_inode,",
          "472:         PVFS2_XATTR_NAME_DEFAULT_PREFIX,",
          "479: static int pvfs2_xattr_set_trusted(const struct xattr_handler *handler,",
          "480:        struct dentry *dentry,",
          "481:        const char *name,",
          "482:        const void *buffer,",
          "483:        size_t size,",
          "484:        int flags)",
          "486:  return pvfs2_inode_setxattr(dentry->d_inode,",
          "487:         PVFS2_XATTR_NAME_TRUSTED_PREFIX,",
          "494: static int pvfs2_xattr_get_trusted(const struct xattr_handler *handler,",
          "495:        struct dentry *dentry,",
          "496:        const char *name,",
          "497:        void *buffer,",
          "498:        size_t size)",
          "500:  return pvfs2_inode_getxattr(dentry->d_inode,",
          "501:         PVFS2_XATTR_NAME_TRUSTED_PREFIX,",
          "507: static struct xattr_handler pvfs2_xattr_trusted_handler = {",
          "508:  .prefix = PVFS2_XATTR_NAME_TRUSTED_PREFIX,",
          "509:  .get = pvfs2_xattr_get_trusted,",
          "510:  .set = pvfs2_xattr_set_trusted,",
          "513: static struct xattr_handler pvfs2_xattr_default_handler = {",
          "519:  .prefix = PVFS2_XATTR_NAME_DEFAULT_PREFIX,",
          "520:  .get = pvfs2_xattr_get_default,",
          "521:  .set = pvfs2_xattr_set_default,",
          "524: const struct xattr_handler *pvfs2_xattr_handlers[] = {",
          "527:  &pvfs2_xattr_trusted_handler,",
          "528:  &pvfs2_xattr_default_handler,",
          "",
          "[Added Lines]",
          "446:  up_read(&orangefs_inode->xattr_sem);",
          "450: static int orangefs_xattr_set_default(const struct xattr_handler *handler,",
          "451:           struct dentry *dentry,",
          "452:           const char *name,",
          "453:           const void *buffer,",
          "454:           size_t size,",
          "455:           int flags)",
          "457:  return orangefs_inode_setxattr(dentry->d_inode,",
          "458:         ORANGEFS_XATTR_NAME_DEFAULT_PREFIX,",
          "465: static int orangefs_xattr_get_default(const struct xattr_handler *handler,",
          "466:           struct dentry *dentry,",
          "467:           const char *name,",
          "468:           void *buffer,",
          "469:           size_t size)",
          "471:  return orangefs_inode_getxattr(dentry->d_inode,",
          "472:         ORANGEFS_XATTR_NAME_DEFAULT_PREFIX,",
          "479: static int orangefs_xattr_set_trusted(const struct xattr_handler *handler,",
          "480:          struct dentry *dentry,",
          "481:          const char *name,",
          "482:          const void *buffer,",
          "483:          size_t size,",
          "484:          int flags)",
          "486:  return orangefs_inode_setxattr(dentry->d_inode,",
          "487:         ORANGEFS_XATTR_NAME_TRUSTED_PREFIX,",
          "494: static int orangefs_xattr_get_trusted(const struct xattr_handler *handler,",
          "495:           struct dentry *dentry,",
          "496:           const char *name,",
          "497:           void *buffer,",
          "498:           size_t size)",
          "500:  return orangefs_inode_getxattr(dentry->d_inode,",
          "501:         ORANGEFS_XATTR_NAME_TRUSTED_PREFIX,",
          "507: static struct xattr_handler orangefs_xattr_trusted_handler = {",
          "508:  .prefix = ORANGEFS_XATTR_NAME_TRUSTED_PREFIX,",
          "509:  .get = orangefs_xattr_get_trusted,",
          "510:  .set = orangefs_xattr_set_trusted,",
          "513: static struct xattr_handler orangefs_xattr_default_handler = {",
          "519:  .prefix = ORANGEFS_XATTR_NAME_DEFAULT_PREFIX,",
          "520:  .get = orangefs_xattr_get_default,",
          "521:  .set = orangefs_xattr_set_default,",
          "524: const struct xattr_handler *orangefs_xattr_handlers[] = {",
          "527:  &orangefs_xattr_trusted_handler,",
          "528:  &orangefs_xattr_default_handler,",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "14af20fcb1833dd776822361891963c90f7b0262",
      "candidate_info": {
        "commit_hash": "14af20fcb1833dd776822361891963c90f7b0262",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/14af20fcb1833dd776822361891963c90f7b0262",
        "files": [
          "fs/f2fs/acl.c"
        ],
        "message": "f2fs: preserve i_mode if __f2fs_set_acl() fails\n\nWhen changing a file's acl mask, __f2fs_set_acl() will first set the\ngroup bits of i_mode to the value of the mask, and only then set the\nactual extended attribute representing the new acl.\n\nIf the second part fails (due to lack of space, for example) and the\nfile had no acl attribute to begin with, the system will from now on\nassume that the mask permission bits are actual group permission bits,\npotentially granting access to the wrong users.\n\nPrevent this by only changing the inode mode after the acl has been set.\n\nSigned-off-by: Ernesto A. Fern\u00e1ndez <ernesto.mnd.fernandez@gmail.com>\nReviewed-by: Chao Yu <yuchao0@huawei.com>\nSigned-off-by: Jaegeuk Kim <jaegeuk@kernel.org>",
        "before_after_code_files": [
          "fs/f2fs/acl.c||fs/f2fs/acl.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/f2fs/acl.c||fs/f2fs/acl.c"
          ],
          "candidate": [
            "fs/f2fs/acl.c||fs/f2fs/acl.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/f2fs/acl.c||fs/f2fs/acl.c": [
          "File: fs/f2fs/acl.c -> fs/f2fs/acl.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "207:  void *value = NULL;",
          "208:  size_t size = 0;",
          "209:  int error;",
          "211:  switch (type) {",
          "212:  case ACL_TYPE_ACCESS:",
          "213:   name_index = F2FS_XATTR_INDEX_POSIX_ACL_ACCESS;",
          "214:   if (acl && !ipage) {",
          "216:    if (error)",
          "217:     return error;",
          "219:   }",
          "220:   break;",
          "",
          "[Removed Lines]",
          "215:    error = posix_acl_update_mode(inode, &inode->i_mode, &acl);",
          "218:    set_acl_inode(inode, inode->i_mode);",
          "",
          "[Added Lines]",
          "210:  umode_t mode = inode->i_mode;",
          "216:    error = posix_acl_update_mode(inode, &mode, &acl);",
          "219:    set_acl_inode(inode, mode);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "397e434176bb62bc6068d2210af1d876c6212a7e",
      "candidate_info": {
        "commit_hash": "397e434176bb62bc6068d2210af1d876c6212a7e",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/397e434176bb62bc6068d2210af1d876c6212a7e",
        "files": [
          "fs/ext4/acl.c"
        ],
        "message": "ext4: preserve i_mode if __ext4_set_acl() fails\n\nWhen changing a file's acl mask, __ext4_set_acl() will first set the group\nbits of i_mode to the value of the mask, and only then set the actual\nextended attribute representing the new acl.\n\nIf the second part fails (due to lack of space, for example) and the file\nhad no acl attribute to begin with, the system will from now on assume\nthat the mask permission bits are actual group permission bits, potentially\ngranting access to the wrong users.\n\nPrevent this by only changing the inode mode after the acl has been set.\n\nSigned-off-by: Ernesto A. Fern\u00e1ndez <ernesto.mnd.fernandez@gmail.com>\nSigned-off-by: Theodore Ts'o <tytso@mit.edu>\nReviewed-by: Jan Kara <jack@suse.cz>",
        "before_after_code_files": [
          "fs/ext4/acl.c||fs/ext4/acl.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/ext4/acl.c||fs/ext4/acl.c"
          ],
          "candidate": [
            "fs/ext4/acl.c||fs/ext4/acl.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/ext4/acl.c||fs/ext4/acl.c": [
          "File: fs/ext4/acl.c -> fs/ext4/acl.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "189:  void *value = NULL;",
          "190:  size_t size = 0;",
          "191:  int error;",
          "193:  switch (type) {",
          "194:  case ACL_TYPE_ACCESS:",
          "195:   name_index = EXT4_XATTR_INDEX_POSIX_ACL_ACCESS;",
          "196:   if (acl) {",
          "198:    if (error)",
          "199:     return error;",
          "202:   }",
          "203:   break;",
          "",
          "[Removed Lines]",
          "197:    error = posix_acl_update_mode(inode, &inode->i_mode, &acl);",
          "200:    inode->i_ctime = current_time(inode);",
          "201:    ext4_mark_inode_dirty(handle, inode);",
          "",
          "[Added Lines]",
          "192:  int update_mode = 0;",
          "193:  umode_t mode = inode->i_mode;",
          "199:    error = posix_acl_update_mode(inode, &mode, &acl);",
          "202:    update_mode = 1;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "221:           value, size, xattr_flags);",
          "223:  kfree(value);",
          "225:   set_cached_acl(inode, type, acl);",
          "227:  return error;",
          "228: }",
          "",
          "[Removed Lines]",
          "224:  if (!error)",
          "",
          "[Added Lines]",
          "225:  if (!error) {",
          "227:   if (update_mode) {",
          "228:    inode->i_mode = mode;",
          "229:    inode->i_ctime = current_time(inode);",
          "230:    ext4_mark_inode_dirty(handle, inode);",
          "231:   }",
          "232:  }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "972a7344fcb54e0aabe78cfac5abb531fc6299ab",
      "candidate_info": {
        "commit_hash": "972a7344fcb54e0aabe78cfac5abb531fc6299ab",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/972a7344fcb54e0aabe78cfac5abb531fc6299ab",
        "files": [
          "fs/orangefs/acl.c",
          "fs/orangefs/file.c",
          "fs/orangefs/orangefs-kernel.h",
          "fs/orangefs/xattr.c"
        ],
        "message": "orangefs: Remove useless defines\n\nThe ORANGEFS_XATTR_INDEX_ defines are unused; the ORANGEFS_XATTR_NAME_\ndefines only obfuscate the code.\n\nSigned-off-by: Andreas Gruenbacher <agruenba@redhat.com>\nSigned-off-by: Mike Marshall <hubcap@omnibond.com>",
        "before_after_code_files": [
          "fs/orangefs/acl.c||fs/orangefs/acl.c",
          "fs/orangefs/file.c||fs/orangefs/file.c",
          "fs/orangefs/orangefs-kernel.h||fs/orangefs/orangefs-kernel.h",
          "fs/orangefs/xattr.c||fs/orangefs/xattr.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/orangefs/acl.c||fs/orangefs/acl.c"
          ],
          "candidate": [
            "fs/orangefs/acl.c||fs/orangefs/acl.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/orangefs/acl.c||fs/orangefs/acl.c": [
          "File: fs/orangefs/acl.c -> fs/orangefs/acl.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "19:  switch (type) {",
          "20:  case ACL_TYPE_ACCESS:",
          "22:   break;",
          "23:  case ACL_TYPE_DEFAULT:",
          "25:   break;",
          "26:  default:",
          "27:   gossip_err(\"orangefs_get_acl: bogus value of type %d\\n\", type);",
          "",
          "[Removed Lines]",
          "21:   key = ORANGEFS_XATTR_NAME_ACL_ACCESS;",
          "24:   key = ORANGEFS_XATTR_NAME_ACL_DEFAULT;",
          "",
          "[Added Lines]",
          "21:   key = XATTR_NAME_POSIX_ACL_ACCESS;",
          "24:   key = XATTR_NAME_POSIX_ACL_DEFAULT;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "75:  switch (type) {",
          "76:  case ACL_TYPE_ACCESS:",
          "78:   if (acl) {",
          "79:    umode_t mode = inode->i_mode;",
          "",
          "[Removed Lines]",
          "77:   name = ORANGEFS_XATTR_NAME_ACL_ACCESS;",
          "",
          "[Added Lines]",
          "77:   name = XATTR_NAME_POSIX_ACL_ACCESS;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "98:   }",
          "99:   break;",
          "100:  case ACL_TYPE_DEFAULT:",
          "102:   break;",
          "103:  default:",
          "104:   gossip_err(\"%s: invalid type %d!\\n\", __func__, type);",
          "",
          "[Removed Lines]",
          "101:   name = ORANGEFS_XATTR_NAME_ACL_DEFAULT;",
          "",
          "[Added Lines]",
          "101:   name = XATTR_NAME_POSIX_ACL_DEFAULT;",
          "",
          "---------------"
        ],
        "fs/orangefs/file.c||fs/orangefs/file.c": [
          "File: fs/orangefs/file.c -> fs/orangefs/file.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "516:  if (cmd == FS_IOC_GETFLAGS) {",
          "517:   val = 0;",
          "518:   ret = orangefs_inode_getxattr(file_inode(file),",
          "520:            \"user.pvfs2.meta_hint\",",
          "521:            &val, sizeof(val));",
          "522:   if (ret < 0 && ret != -ENODATA)",
          "",
          "[Removed Lines]",
          "519:            ORANGEFS_XATTR_NAME_DEFAULT_PREFIX,",
          "",
          "[Added Lines]",
          "519:            \"\",",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "549:         \"orangefs_ioctl: FS_IOC_SETFLAGS: %llu\\n\",",
          "550:         (unsigned long long)val);",
          "551:   ret = orangefs_inode_setxattr(file_inode(file),",
          "553:            \"user.pvfs2.meta_hint\",",
          "554:            &val, sizeof(val), 0);",
          "555:  }",
          "",
          "[Removed Lines]",
          "552:            ORANGEFS_XATTR_NAME_DEFAULT_PREFIX,",
          "",
          "[Added Lines]",
          "552:            \"\",",
          "",
          "---------------"
        ],
        "fs/orangefs/orangefs-kernel.h||fs/orangefs/orangefs-kernel.h": [
          "File: fs/orangefs/orangefs-kernel.h -> fs/orangefs/orangefs-kernel.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "119: #define ORANGEFS_CACHE_CREATE_FLAGS 0",
          "134: int orangefs_prepare_cdm_array(char *debug_array_string);",
          "135: int orangefs_prepare_debugfs_help_string(int);",
          "",
          "[Removed Lines]",
          "123: #define ORANGEFS_XATTR_INDEX_POSIX_ACL_ACCESS  1",
          "124: #define ORANGEFS_XATTR_INDEX_POSIX_ACL_DEFAULT 2",
          "125: #define ORANGEFS_XATTR_INDEX_TRUSTED           3",
          "126: #define ORANGEFS_XATTR_INDEX_DEFAULT           4",
          "128: #define ORANGEFS_XATTR_NAME_ACL_ACCESS XATTR_NAME_POSIX_ACL_ACCESS",
          "129: #define ORANGEFS_XATTR_NAME_ACL_DEFAULT XATTR_NAME_POSIX_ACL_DEFAULT",
          "130: #define ORANGEFS_XATTR_NAME_TRUSTED_PREFIX \"trusted.\"",
          "131: #define ORANGEFS_XATTR_NAME_DEFAULT_PREFIX \"\"",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "fs/orangefs/xattr.c||fs/orangefs/xattr.c": [
          "File: fs/orangefs/xattr.c -> fs/orangefs/xattr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "456:           int flags)",
          "457: {",
          "458:  return orangefs_inode_setxattr(inode,",
          "460:         name,",
          "461:         buffer,",
          "462:         size,",
          "",
          "[Removed Lines]",
          "459:         ORANGEFS_XATTR_NAME_DEFAULT_PREFIX,",
          "",
          "[Added Lines]",
          "459:         \"\",",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "471:           size_t size)",
          "472: {",
          "473:  return orangefs_inode_getxattr(inode,",
          "475:         name,",
          "476:         buffer,",
          "477:         size);",
          "",
          "[Removed Lines]",
          "474:         ORANGEFS_XATTR_NAME_DEFAULT_PREFIX,",
          "",
          "[Added Lines]",
          "474:         \"\",",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "487:          int flags)",
          "488: {",
          "489:  return orangefs_inode_setxattr(inode,",
          "491:         name,",
          "492:         buffer,",
          "493:         size,",
          "",
          "[Removed Lines]",
          "490:         ORANGEFS_XATTR_NAME_TRUSTED_PREFIX,",
          "",
          "[Added Lines]",
          "490:         XATTR_TRUSTED_PREFIX,",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "502:           size_t size)",
          "503: {",
          "504:  return orangefs_inode_getxattr(inode,",
          "506:         name,",
          "507:         buffer,",
          "508:         size);",
          "509: }",
          "511: static struct xattr_handler orangefs_xattr_trusted_handler = {",
          "513:  .get = orangefs_xattr_get_trusted,",
          "514:  .set = orangefs_xattr_set_trusted,",
          "515: };",
          "517: static struct xattr_handler orangefs_xattr_default_handler = {",
          "524:  .get = orangefs_xattr_get_default,",
          "525:  .set = orangefs_xattr_set_default,",
          "526: };",
          "",
          "[Removed Lines]",
          "505:         ORANGEFS_XATTR_NAME_TRUSTED_PREFIX,",
          "512:  .prefix = ORANGEFS_XATTR_NAME_TRUSTED_PREFIX,",
          "523:  .prefix = ORANGEFS_XATTR_NAME_DEFAULT_PREFIX,",
          "",
          "[Added Lines]",
          "505:         XATTR_TRUSTED_PREFIX,",
          "512:  .prefix = XATTR_TRUSTED_PREFIX,",
          "",
          "---------------"
        ]
      }
    }
  ]
}
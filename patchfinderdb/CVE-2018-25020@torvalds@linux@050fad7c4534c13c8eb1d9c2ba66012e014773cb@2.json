{
  "cve_id": "CVE-2018-25020",
  "cve_desc": "The BPF subsystem in the Linux kernel before 4.17 mishandles situations with a long jump over an instruction sequence where inner instructions require substantial expansions into multiple BPF instructions, leading to an overflow. This affects kernel/bpf/core.c and net/core/filter.c.",
  "repo": "torvalds/linux",
  "patch_hash": "050fad7c4534c13c8eb1d9c2ba66012e014773cb",
  "patch_info": {
    "commit_hash": "050fad7c4534c13c8eb1d9c2ba66012e014773cb",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/050fad7c4534c13c8eb1d9c2ba66012e014773cb",
    "files": [
      "kernel/bpf/core.c",
      "net/core/filter.c"
    ],
    "message": "bpf: fix truncated jump targets on heavy expansions\n\nRecently during testing, I ran into the following panic:\n\n  [  207.892422] Internal error: Accessing user space memory outside uaccess.h routines: 96000004 [#1] SMP\n  [  207.901637] Modules linked in: binfmt_misc [...]\n  [  207.966530] CPU: 45 PID: 2256 Comm: test_verifier Tainted: G        W         4.17.0-rc3+ #7\n  [  207.974956] Hardware name: FOXCONN R2-1221R-A4/C2U4N_MB, BIOS G31FB18A 03/31/2017\n  [  207.982428] pstate: 60400005 (nZCv daif +PAN -UAO)\n  [  207.987214] pc : bpf_skb_load_helper_8_no_cache+0x34/0xc0\n  [  207.992603] lr : 0xffff000000bdb754\n  [  207.996080] sp : ffff000013703ca0\n  [  207.999384] x29: ffff000013703ca0 x28: 0000000000000001\n  [  208.004688] x27: 0000000000000001 x26: 0000000000000000\n  [  208.009992] x25: ffff000013703ce0 x24: ffff800fb4afcb00\n  [  208.015295] x23: ffff00007d2f5038 x22: ffff00007d2f5000\n  [  208.020599] x21: fffffffffeff2a6f x20: 000000000000000a\n  [  208.025903] x19: ffff000009578000 x18: 0000000000000a03\n  [  208.031206] x17: 0000000000000000 x16: 0000000000000000\n  [  208.036510] x15: 0000ffff9de83000 x14: 0000000000000000\n  [  208.041813] x13: 0000000000000000 x12: 0000000000000000\n  [  208.047116] x11: 0000000000000001 x10: ffff0000089e7f18\n  [  208.052419] x9 : fffffffffeff2a6f x8 : 0000000000000000\n  [  208.057723] x7 : 000000000000000a x6 : 00280c6160000000\n  [  208.063026] x5 : 0000000000000018 x4 : 0000000000007db6\n  [  208.068329] x3 : 000000000008647a x2 : 19868179b1484500\n  [  208.073632] x1 : 0000000000000000 x0 : ffff000009578c08\n  [  208.078938] Process test_verifier (pid: 2256, stack limit = 0x0000000049ca7974)\n  [  208.086235] Call trace:\n  [  208.088672]  bpf_skb_load_helper_8_no_cache+0x34/0xc0\n  [  208.093713]  0xffff000000bdb754\n  [  208.096845]  bpf_test_run+0x78/0xf8\n  [  208.100324]  bpf_prog_test_run_skb+0x148/0x230\n  [  208.104758]  sys_bpf+0x314/0x1198\n  [  208.108064]  el0_svc_naked+0x30/0x34\n  [  208.111632] Code: 91302260 f9400001 f9001fa1 d2800001 (29500680)\n  [  208.117717] ---[ end trace 263cb8a59b5bf29f ]---\n\nThe program itself which caused this had a long jump over the whole\ninstruction sequence where all of the inner instructions required\nheavy expansions into multiple BPF instructions. Additionally, I also\nhad BPF hardening enabled which requires once more rewrites of all\nconstant values in order to blind them. Each time we rewrite insns,\nbpf_adj_branches() would need to potentially adjust branch targets\nwhich cross the patchlet boundary to accommodate for the additional\ndelta. Eventually that lead to the case where the target offset could\nnot fit into insn->off's upper 0x7fff limit anymore where then offset\nwraps around becoming negative (in s16 universe), or vice versa\ndepending on the jump direction.\n\nTherefore it becomes necessary to detect and reject any such occasions\nin a generic way for native eBPF and cBPF to eBPF migrations. For\nthe latter we can simply check bounds in the bpf_convert_filter()'s\nBPF_EMIT_JMP helper macro and bail out once we surpass limits. The\nbpf_patch_insn_single() for native eBPF (and cBPF to eBPF in case\nof subsequent hardening) is a bit more complex in that we need to\ndetect such truncations before hitting the bpf_prog_realloc(). Thus\nthe latter is split into an extra pass to probe problematic offsets\non the original program in order to fail early. With that in place\nand carefully tested I no longer hit the panic and the rewrites are\nrejected properly. The above example panic I've seen on bpf-next,\nthough the issue itself is generic in that a guard against this issue\nin bpf seems more appropriate in this case.\n\nSigned-off-by: Daniel Borkmann <daniel@iogearbox.net>\nAcked-by: Martin KaFai Lau <kafai@fb.com>\nSigned-off-by: Alexei Starovoitov <ast@kernel.org>",
    "before_after_code_files": [
      "kernel/bpf/core.c||kernel/bpf/core.c",
      "net/core/filter.c||net/core/filter.c"
    ]
  },
  "patch_diff": {
    "kernel/bpf/core.c||kernel/bpf/core.c": [
      "File: kernel/bpf/core.c -> kernel/bpf/core.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "218:  return 0;",
      "219: }",
      "222: {",
      "223:  struct bpf_insn *insn = prog->insnsi;",
      "229:  for (i = 0; i < insn_cnt; i++, insn++) {",
      "230:   code = insn->code;",
      "234:    continue;",
      "235:   if (BPF_OP(code) == BPF_CALL) {",
      "239:     continue;",
      "240:   } else {",
      "242:   }",
      "255:  }",
      "256: }",
      "258: struct bpf_prog *bpf_patch_insn_single(struct bpf_prog *prog, u32 off,",
      "259:            const struct bpf_insn *patch, u32 len)",
      "260: {",
      "261:  u32 insn_adj_cnt, insn_rest, insn_delta = len - 1;",
      "262:  struct bpf_prog *prog_adj;",
      "",
      "[Removed Lines]",
      "221: static void bpf_adj_branches(struct bpf_prog *prog, u32 pos, u32 delta)",
      "224:  u32 i, insn_cnt = prog->len;",
      "225:  bool pseudo_call;",
      "226:  u8 code;",
      "227:  int off;",
      "231:   if (BPF_CLASS(code) != BPF_JMP)",
      "232:    continue;",
      "233:   if (BPF_OP(code) == BPF_EXIT)",
      "236:    if (insn->src_reg == BPF_PSEUDO_CALL)",
      "237:     pseudo_call = true;",
      "238:    else",
      "241:    pseudo_call = false;",
      "243:   off = pseudo_call ? insn->imm : insn->off;",
      "246:   if (i < pos && i + off + 1 > pos)",
      "247:    off += delta;",
      "248:   else if (i > pos + delta && i + off + 1 <= pos + delta)",
      "249:    off -= delta;",
      "251:   if (pseudo_call)",
      "252:    insn->imm = off;",
      "253:   else",
      "254:    insn->off = off;",
      "",
      "[Added Lines]",
      "221: static int bpf_adj_delta_to_imm(struct bpf_insn *insn, u32 pos, u32 delta,",
      "222:     u32 curr, const bool probe_pass)",
      "224:  const s64 imm_min = S32_MIN, imm_max = S32_MAX;",
      "225:  s64 imm = insn->imm;",
      "227:  if (curr < pos && curr + imm + 1 > pos)",
      "228:   imm += delta;",
      "229:  else if (curr > pos + delta && curr + imm + 1 <= pos + delta)",
      "230:   imm -= delta;",
      "231:  if (imm < imm_min || imm > imm_max)",
      "232:   return -ERANGE;",
      "233:  if (!probe_pass)",
      "234:   insn->imm = imm;",
      "235:  return 0;",
      "236: }",
      "238: static int bpf_adj_delta_to_off(struct bpf_insn *insn, u32 pos, u32 delta,",
      "239:     u32 curr, const bool probe_pass)",
      "240: {",
      "241:  const s32 off_min = S16_MIN, off_max = S16_MAX;",
      "242:  s32 off = insn->off;",
      "244:  if (curr < pos && curr + off + 1 > pos)",
      "245:   off += delta;",
      "246:  else if (curr > pos + delta && curr + off + 1 <= pos + delta)",
      "247:   off -= delta;",
      "248:  if (off < off_min || off > off_max)",
      "249:   return -ERANGE;",
      "250:  if (!probe_pass)",
      "251:   insn->off = off;",
      "252:  return 0;",
      "253: }",
      "255: static int bpf_adj_branches(struct bpf_prog *prog, u32 pos, u32 delta,",
      "256:        const bool probe_pass)",
      "257: {",
      "258:  u32 i, insn_cnt = prog->len + (probe_pass ? delta : 0);",
      "260:  int ret = 0;",
      "263:   u8 code;",
      "269:   if (probe_pass && i == pos) {",
      "270:    i += delta + 1;",
      "271:    insn++;",
      "272:   }",
      "274:   if (BPF_CLASS(code) != BPF_JMP ||",
      "275:       BPF_OP(code) == BPF_EXIT)",
      "279:    if (insn->src_reg != BPF_PSEUDO_CALL)",
      "281:    ret = bpf_adj_delta_to_imm(insn, pos, delta, i,",
      "282:          probe_pass);",
      "284:    ret = bpf_adj_delta_to_off(insn, pos, delta, i,",
      "285:          probe_pass);",
      "287:   if (ret)",
      "288:    break;",
      "291:  return ret;",
      "298:  const u32 cnt_max = S16_MAX;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "270:  insn_adj_cnt = prog->len + insn_delta;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "314:  if (insn_adj_cnt > cnt_max &&",
      "315:      bpf_adj_branches(prog, off, insn_delta, true))",
      "316:   return NULL;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "294:   sizeof(*patch) * insn_rest);",
      "295:  memcpy(prog_adj->insnsi + off, patch, sizeof(*patch) * len);",
      "299:  return prog_adj;",
      "300: }",
      "",
      "[Removed Lines]",
      "297:  bpf_adj_branches(prog_adj, off, insn_delta);",
      "",
      "[Added Lines]",
      "347:  BUG_ON(bpf_adj_branches(prog_adj, off, insn_delta, false));",
      "",
      "---------------"
    ],
    "net/core/filter.c||net/core/filter.c": [
      "File: net/core/filter.c -> net/core/filter.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "482: #define BPF_EMIT_JMP       \\",
      "483:  do {        \\",
      "484:   if (target >= len || target < 0)   \\",
      "485:    goto err;     \\",
      "489:  } while (0)",
      "491:   case BPF_JMP | BPF_JA:",
      "",
      "[Removed Lines]",
      "486:   insn->off = addrs ? addrs[target] - addrs[i] - 1 : 0; \\",
      "488:   insn->off -= insn - tmp_insns;    \\",
      "",
      "[Added Lines]",
      "484:   const s32 off_min = S16_MIN, off_max = S16_MAX;  \\",
      "485:   s32 off;      \\",
      "486:          \\",
      "489:   off = addrs ? addrs[target] - addrs[i] - 1 : 0;  \\",
      "491:   off -= insn - tmp_insns;    \\",
      "493:   if (off < off_min || off > off_max)   \\",
      "494:    goto err;     \\",
      "495:   insn->off = off;     \\",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "5c750d58e9d78987e2bda6b65441e6f6b961a01e",
      "candidate_info": {
        "commit_hash": "5c750d58e9d78987e2bda6b65441e6f6b961a01e",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/5c750d58e9d78987e2bda6b65441e6f6b961a01e",
        "files": [
          "drivers/s390/scsi/zfcp_fc.c",
          "drivers/s390/scsi/zfcp_scsi.c",
          "kernel/workqueue.c"
        ],
        "message": "scsi: zfcp: workqueue: set description for port work items with their WWPN as context\n\nAs a prerequisite, complement commit 3d1cb2059d93 (\"workqueue: include\nworkqueue info when printing debug dump of a worker task\") to be usable with\nkernel modules by exporting the symbol set_worker_desc().  Current built-in\nuser was introduced with commit ef3b101925f2 (\"writeback: set worker desc to\nidentify writeback workers in task dumps\").\n\nCan help distinguishing work items which do not have adapter scope.\nDescription is printed out with task dump for debugging on WARN, BUG, panic,\nor magic-sysrq [show-task-states(t)].\n\nExample:\n$ echo 0 >| /sys/bus/ccw/drivers/zfcp/0.0.1880/0x50050763031bd327/failed &\n$ echo 't' >| /proc/sysrq-trigger\n$ dmesg\nsysrq: SysRq : Show State\n  task                        PC stack   pid father\n...\nzfcp_q_0.0.1880 S14640  2165      2 0x02000000\nCall Trace:\n([<00000000009df464>] __schedule+0xbf4/0xc78)\n [<00000000009df57c>] schedule+0x94/0xc0\n [<0000000000168654>] rescuer_thread+0x33c/0x3a0\n [<000000000016f8be>] kthread+0x166/0x178\n [<00000000009e71f2>] kernel_thread_starter+0x6/0xc\n [<00000000009e71ec>] kernel_thread_starter+0x0/0xc\nno locks held by zfcp_q_0.0.1880/2165.\n...\nkworker/u512:2  D11280  2193      2 0x02000000\nWorkqueue: zfcp_q_0.0.1880 zfcp_scsi_rport_work [zfcp] (zrpd-50050763031bd327)\n                                                        ^^^^^^^^^^^^^^^^^^^^^\nCall Trace:\n([<00000000009df464>] __schedule+0xbf4/0xc78)\n [<00000000009df57c>] schedule+0x94/0xc0\n [<00000000009e50c0>] schedule_timeout+0x488/0x4d0\n [<00000000001e425c>] msleep+0x5c/0x78                  >>test code only<<\n [<000003ff8008a21e>] zfcp_scsi_rport_work+0xbe/0x100 [zfcp]\n [<0000000000167154>] process_one_work+0x3b4/0x718\n [<000000000016771c>] worker_thread+0x264/0x408\n [<000000000016f8be>] kthread+0x166/0x178\n [<00000000009e71f2>] kernel_thread_starter+0x6/0xc\n [<00000000009e71ec>] kernel_thread_starter+0x0/0xc\n2 locks held by kworker/u512:2/2193:\n #0:  (name){++++.+}, at: [<0000000000166f4e>] process_one_work+0x1ae/0x718\n #1:  ((&(&port->rport_work)->work)){+.+.+.}, at: [<0000000000166f4e>] process_one_work+0x1ae/0x718\n...\n\n=============================================\nShowing busy workqueues and worker pools:\nworkqueue zfcp_q_0.0.1880: flags=0x2000a\n  pwq 512: cpus=0-255 flags=0x4 nice=0 active=1/1\n    in-flight: 2193:zfcp_scsi_rport_work [zfcp]\npool 512: cpus=0-255 flags=0x4 nice=0 hung=0s workers=4 idle: 5 2354 2311\n\nWork items with adapter scope are already identified by the workqueue name\n\"zfcp_q_<devbusid>\" and the work item function name.\n\nSigned-off-by: Steffen Maier <maier@linux.ibm.com>\nCc: Tejun Heo <tj@kernel.org>\nCc: Lai Jiangshan <jiangshanlai@gmail.com>\nReviewed-by: Benjamin Block <bblock@linux.ibm.com>\nAcked-by: Tejun Heo <tj@kernel.org>\nSigned-off-by: Martin K. Petersen <martin.petersen@oracle.com>",
        "before_after_code_files": [
          "drivers/s390/scsi/zfcp_fc.c||drivers/s390/scsi/zfcp_fc.c",
          "drivers/s390/scsi/zfcp_scsi.c||drivers/s390/scsi/zfcp_scsi.c",
          "kernel/workqueue.c||kernel/workqueue.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/s390/scsi/zfcp_fc.c||drivers/s390/scsi/zfcp_fc.c": [
          "File: drivers/s390/scsi/zfcp_fc.c -> drivers/s390/scsi/zfcp_fc.c"
        ],
        "drivers/s390/scsi/zfcp_scsi.c||drivers/s390/scsi/zfcp_scsi.c": [
          "File: drivers/s390/scsi/zfcp_scsi.c -> drivers/s390/scsi/zfcp_scsi.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "730:  struct zfcp_port *port = container_of(work, struct zfcp_port,",
          "731:            rport_work);",
          "733:  while (port->rport_task) {",
          "734:   if (port->rport_task == RPORT_ADD) {",
          "735:    port->rport_task = RPORT_NONE;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "733:  set_worker_desc(\"zrp%c-%16llx\",",
          "734:    (port->rport_task == RPORT_ADD) ? 'a' : 'd',",
          "",
          "---------------"
        ],
        "kernel/workqueue.c||kernel/workqueue.c": [
          "File: kernel/workqueue.c -> kernel/workqueue.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4350:   worker->desc_valid = true;",
          "4351:  }",
          "4352: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4353: EXPORT_SYMBOL_GPL(set_worker_desc);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "c42a0e2675721e1444f56e6132a07b7b1ec169ac",
      "candidate_info": {
        "commit_hash": "c42a0e2675721e1444f56e6132a07b7b1ec169ac",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/c42a0e2675721e1444f56e6132a07b7b1ec169ac",
        "files": [
          "drivers/md/md.c"
        ],
        "message": "md: fix NULL dereference of mddev->pers in remove_and_add_spares()\n\nWe met NULL pointer BUG as follow:\n\n[  151.760358] BUG: unable to handle kernel NULL pointer dereference at 0000000000000060\n[  151.761340] PGD 80000001011eb067 P4D 80000001011eb067 PUD 1011ea067 PMD 0\n[  151.762039] Oops: 0000 [#1] SMP PTI\n[  151.762406] Modules linked in:\n[  151.762723] CPU: 2 PID: 3561 Comm: mdadm-test Kdump: loaded Not tainted 4.17.0-rc1+ #238\n[  151.763542] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1.fc26 04/01/2014\n[  151.764432] RIP: 0010:remove_and_add_spares.part.56+0x13c/0x3a0\n[  151.765061] RSP: 0018:ffffc90001d7fcd8 EFLAGS: 00010246\n[  151.765590] RAX: 0000000000000000 RBX: ffff88013601d600 RCX: 0000000000000000\n[  151.766306] RDX: 0000000000000000 RSI: ffff88013601d600 RDI: ffff880136187000\n[  151.767014] RBP: ffff880136187018 R08: 0000000000000003 R09: 0000000000000051\n[  151.767728] R10: ffffc90001d7fed8 R11: 0000000000000000 R12: ffff88013601d600\n[  151.768447] R13: ffff8801298b1300 R14: ffff880136187000 R15: 0000000000000000\n[  151.769160] FS:  00007f2624276700(0000) GS:ffff88013ae80000(0000) knlGS:0000000000000000\n[  151.769971] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  151.770554] CR2: 0000000000000060 CR3: 0000000111aac000 CR4: 00000000000006e0\n[  151.771272] Call Trace:\n[  151.771542]  md_ioctl+0x1df2/0x1e10\n[  151.771906]  ? __switch_to+0x129/0x440\n[  151.772295]  ? __schedule+0x244/0x850\n[  151.772672]  blkdev_ioctl+0x4bd/0x970\n[  151.773048]  block_ioctl+0x39/0x40\n[  151.773402]  do_vfs_ioctl+0xa4/0x610\n[  151.773770]  ? dput.part.23+0x87/0x100\n[  151.774151]  ksys_ioctl+0x70/0x80\n[  151.774493]  __x64_sys_ioctl+0x16/0x20\n[  151.774877]  do_syscall_64+0x5b/0x180\n[  151.775258]  entry_SYSCALL_64_after_hwframe+0x44/0xa9\n\nFor raid6, when two disk of the array are offline, two spare disks can\nbe added into the array. Before spare disks recovery completing,\nsystem reboot and mdadm thinks it is ok to restart the degraded\narray by md_ioctl(). Since disks in raid6 is not only_parity(),\nraid5_run() will abort, when there is no PPL feature or not setting\n'start_dirty_degraded' parameter. Therefore, mddev->pers is NULL.\n\nBut, mddev->raid_disks has been set and it will not be cleared when\nraid5_run abort. md_ioctl() can execute cmd 'HOT_REMOVE_DISK' to\nremove a disk by mdadm, which will cause NULL pointer dereference\nin remove_and_add_spares() finally.\n\nSigned-off-by: Yufen Yu <yuyufen@huawei.com>\nSigned-off-by: Shaohua Li <shli@fb.com>",
        "before_after_code_files": [
          "drivers/md/md.c||drivers/md/md.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/md/md.c||drivers/md/md.c": [
          "File: drivers/md/md.c -> drivers/md/md.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "6525:  char b[BDEVNAME_SIZE];",
          "6526:  struct md_rdev *rdev;",
          "6528:  rdev = find_rdev(mddev, dev);",
          "6529:  if (!rdev)",
          "6530:   return -ENXIO;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6528:  if (!mddev->pers)",
          "6529:   return -ENODEV;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "01b8d064d58b4c1f0eff47f8fe8a8508cb3b3840",
      "candidate_info": {
        "commit_hash": "01b8d064d58b4c1f0eff47f8fe8a8508cb3b3840",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/01b8d064d58b4c1f0eff47f8fe8a8508cb3b3840",
        "files": [
          "net/ipv6/ip6_gre.c"
        ],
        "message": "net: ip6_gre: Request headroom in __gre6_xmit()\n\n__gre6_xmit() pushes GRE headers before handing over to ip6_tnl_xmit()\nfor generic IP-in-IP processing. However it doesn't make sure that there\nis enough headroom to push the header to. That can lead to the panic\ncited below. (Reproducer below that).\n\nFix by requesting either needed_headroom if already primed, or just the\nbare minimum needed for the header otherwise.\n\n[  158.576725] kernel BUG at net/core/skbuff.c:104!\n[  158.581510] invalid opcode: 0000 [#1] PREEMPT SMP KASAN PTI\n[  158.587174] Modules linked in: act_mirred cls_matchall ip6_gre ip6_tunnel tunnel6 gre sch_ingress vrf veth x86_pkg_temp_thermal mlx_platform nfsd e1000e leds_mlxcpld\n[  158.602268] CPU: 1 PID: 16 Comm: ksoftirqd/1 Not tainted 4.17.0-rc4-net_master-custom-139 #10\n[  158.610938] Hardware name: Mellanox Technologies Ltd. \"MSN2410-CB2F\"/\"SA000874\", BIOS 4.6.5 03/08/2016\n[  158.620426] RIP: 0010:skb_panic+0xc3/0x100\n[  158.624586] RSP: 0018:ffff8801d3f27110 EFLAGS: 00010286\n[  158.629882] RAX: 0000000000000082 RBX: ffff8801c02cc040 RCX: 0000000000000000\n[  158.637127] RDX: 0000000000000082 RSI: dffffc0000000000 RDI: ffffed003a7e4e18\n[  158.644366] RBP: ffff8801bfec8020 R08: ffffed003aabce19 R09: ffffed003aabce19\n[  158.651574] R10: 000000000000000b R11: ffffed003aabce18 R12: ffff8801c364de66\n[  158.658786] R13: 000000000000002c R14: 00000000000000c0 R15: ffff8801c364de68\n[  158.666007] FS:  0000000000000000(0000) GS:ffff8801d5400000(0000) knlGS:0000000000000000\n[  158.674212] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  158.680036] CR2: 00007f4b3702dcd0 CR3: 0000000003228002 CR4: 00000000001606e0\n[  158.687228] Call Trace:\n[  158.689752]  ? __gre6_xmit+0x246/0xd80 [ip6_gre]\n[  158.694475]  ? __gre6_xmit+0x246/0xd80 [ip6_gre]\n[  158.699141]  skb_push+0x78/0x90\n[  158.702344]  __gre6_xmit+0x246/0xd80 [ip6_gre]\n[  158.706872]  ip6gre_tunnel_xmit+0x3bc/0x610 [ip6_gre]\n[  158.711992]  ? __gre6_xmit+0xd80/0xd80 [ip6_gre]\n[  158.716668]  ? debug_check_no_locks_freed+0x210/0x210\n[  158.721761]  ? print_irqtrace_events+0x120/0x120\n[  158.726461]  ? sched_clock_cpu+0x18/0x210\n[  158.730572]  ? sched_clock_cpu+0x18/0x210\n[  158.734692]  ? cyc2ns_read_end+0x10/0x10\n[  158.738705]  ? skb_network_protocol+0x76/0x200\n[  158.743216]  ? netif_skb_features+0x1b2/0x550\n[  158.747648]  dev_hard_start_xmit+0x137/0x770\n[  158.752010]  sch_direct_xmit+0x2ef/0x5d0\n[  158.755992]  ? pfifo_fast_dequeue+0x3fa/0x670\n[  158.760460]  ? pfifo_fast_change_tx_queue_len+0x810/0x810\n[  158.765975]  ? __lock_is_held+0xa0/0x160\n[  158.770002]  __qdisc_run+0x39e/0xfc0\n[  158.773673]  ? _raw_spin_unlock+0x29/0x40\n[  158.777781]  ? pfifo_fast_enqueue+0x24b/0x3e0\n[  158.782191]  ? sch_direct_xmit+0x5d0/0x5d0\n[  158.786372]  ? pfifo_fast_dequeue+0x670/0x670\n[  158.790818]  ? __dev_queue_xmit+0x172/0x1770\n[  158.795195]  ? preempt_count_sub+0xf/0xd0\n[  158.799313]  __dev_queue_xmit+0x410/0x1770\n[  158.803512]  ? ___slab_alloc+0x605/0x930\n[  158.807525]  ? ___slab_alloc+0x605/0x930\n[  158.811540]  ? memcpy+0x34/0x50\n[  158.814768]  ? netdev_pick_tx+0x1c0/0x1c0\n[  158.818895]  ? __skb_clone+0x2fd/0x3d0\n[  158.822712]  ? __copy_skb_header+0x270/0x270\n[  158.827079]  ? rcu_read_lock_sched_held+0x93/0xa0\n[  158.831903]  ? kmem_cache_alloc+0x344/0x4d0\n[  158.836199]  ? skb_clone+0x123/0x230\n[  158.839869]  ? skb_split+0x820/0x820\n[  158.843521]  ? tcf_mirred+0x554/0x930 [act_mirred]\n[  158.848407]  tcf_mirred+0x554/0x930 [act_mirred]\n[  158.853104]  ? tcf_mirred_act_wants_ingress.part.2+0x10/0x10 [act_mirred]\n[  158.860005]  ? __lock_acquire+0x706/0x26e0\n[  158.864162]  ? mark_lock+0x13d/0xb40\n[  158.867832]  tcf_action_exec+0xcf/0x2a0\n[  158.871736]  tcf_classify+0xfa/0x340\n[  158.875402]  __netif_receive_skb_core+0x8e1/0x1c60\n[  158.880334]  ? nf_ingress+0x500/0x500\n[  158.884059]  ? process_backlog+0x347/0x4b0\n[  158.888241]  ? lock_acquire+0xd8/0x320\n[  158.892050]  ? process_backlog+0x1b6/0x4b0\n[  158.896228]  ? process_backlog+0xc2/0x4b0\n[  158.900291]  process_backlog+0xc2/0x4b0\n[  158.904210]  net_rx_action+0x5cc/0x980\n[  158.908047]  ? napi_complete_done+0x2c0/0x2c0\n[  158.912525]  ? rcu_read_unlock+0x80/0x80\n[  158.916534]  ? __lock_is_held+0x34/0x160\n[  158.920541]  __do_softirq+0x1d4/0x9d2\n[  158.924308]  ? trace_event_raw_event_irq_handler_exit+0x140/0x140\n[  158.930515]  run_ksoftirqd+0x1d/0x40\n[  158.934152]  smpboot_thread_fn+0x32b/0x690\n[  158.938299]  ? sort_range+0x20/0x20\n[  158.941842]  ? preempt_count_sub+0xf/0xd0\n[  158.945940]  ? schedule+0x5b/0x140\n[  158.949412]  kthread+0x206/0x300\n[  158.952689]  ? sort_range+0x20/0x20\n[  158.956249]  ? kthread_stop+0x570/0x570\n[  158.960164]  ret_from_fork+0x3a/0x50\n[  158.963823] Code: 14 3e ff 8b 4b 78 55 4d 89 f9 41 56 41 55 48 c7 c7 a0 cf db 82 41 54 44 8b 44 24 2c 48 8b 54 24 30 48 8b 74 24 20 e8 16 94 13 ff <0f> 0b 48 c7 c7 60 8e 1f 85 48 83 c4 20 e8 55 ef a6 ff 89 74 24\n[  158.983235] RIP: skb_panic+0xc3/0x100 RSP: ffff8801d3f27110\n[  158.988935] ---[ end trace 5af56ee845aa6cc8 ]---\n[  158.993641] Kernel panic - not syncing: Fatal exception in interrupt\n[  159.000176] Kernel Offset: disabled\n[  159.003767] ---[ end Kernel panic - not syncing: Fatal exception in interrupt ]---\n\nReproducer:\n\n\tip link add h1 type veth peer name swp1\n\tip link add h3 type veth peer name swp3\n\n\tip link set dev h1 up\n\tip address add 192.0.2.1/28 dev h1\n\n\tip link add dev vh3 type vrf table 20\n\tip link set dev h3 master vh3\n\tip link set dev vh3 up\n\tip link set dev h3 up\n\n\tip link set dev swp3 up\n\tip address add dev swp3 2001:db8:2::1/64\n\n\tip link set dev swp1 up\n\ttc qdisc add dev swp1 clsact\n\n\tip link add name gt6 type ip6gretap \\\n\t\tlocal 2001:db8:2::1 remote 2001:db8:2::2\n\tip link set dev gt6 up\n\n\tsleep 1\n\n\ttc filter add dev swp1 ingress pref 1000 matchall skip_hw \\\n\t\taction mirred egress mirror dev gt6\n\tping -I h1 192.0.2.2\n\nFixes: c12b395a4664 (\"gre: Support GRE over IPv6\")\nSigned-off-by: Petr Machata <petrm@mellanox.com>\nAcked-by: William Tu <u9012063@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "net/ipv6/ip6_gre.c||net/ipv6/ip6_gre.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "net/ipv6/ip6_gre.c||net/ipv6/ip6_gre.c": [
          "File: net/ipv6/ip6_gre.c -> net/ipv6/ip6_gre.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "698:  else",
          "699:   fl6->daddr = tunnel->parms.raddr;",
          "702:  protocol = (dev->type == ARPHRD_ETHER) ? htons(ETH_P_TEB) : proto;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "701:  if (skb_cow_head(skb, dev->needed_headroom ?: tunnel->hlen))",
          "702:   return -ENOMEM;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "9e156c54ace310ce7fb1cd960e62416947f3d47c",
      "candidate_info": {
        "commit_hash": "9e156c54ace310ce7fb1cd960e62416947f3d47c",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/9e156c54ace310ce7fb1cd960e62416947f3d47c",
        "files": [
          "drivers/s390/scsi/zfcp_dbf.c"
        ],
        "message": "scsi: zfcp: assert that the ERP lock is held when tracing a recovery trigger\n\nOtherwise iterating with list_for_each() over the adapter->erp_ready_head\nand adapter->erp_running_head lists can lead to an infinite loop. See commit\n\"zfcp: fix infinite iteration on erp_ready_head list\".\n\nThe run-time check is only performed for debug kernels which have the kernel\nlock validator enabled. Following is an example of the warning that is\nreported, if the ERP lock is not held when calling zfcp_dbf_rec_trig():\n\nWARNING: CPU: 0 PID: 604 at drivers/s390/scsi/zfcp_dbf.c:288 zfcp_dbf_rec_trig+0x172/0x188\nModules linked in: ...\nCPU: 0 PID: 604 Comm: kworker/u128:3 Not tainted 4.16.0-... #1\nHardware name: IBM 2964 N96 702 (z/VM 6.4.0)\nWorkqueue: zfcp_q_0.0.1906 zfcp_scsi_rport_work\nKrnl PSW : 00000000330fdbf9 00000000367e9728 (zfcp_dbf_rec_trig+0x172/0x188)\n           R:0 T:1 IO:1 EX:1 Key:0 M:1 W:0 P:0 AS:3 CC:3 PM:0 RI:0 EA:3\nKrnl GPRS: 00000000c57a5d99 3288200000000000 0000000000000000 000000006cc82740\n           00000000009d09d6 0000000000000000 00000000000000ff 0000000000000000\n           0000000000000000 0000000000e1b5fe 000000006de01d38 0000000076130958\n           000000006cc82548 000000006de01a98 00000000009d09d6 000000006a6d3c80\nKrnl Code: 00000000009d0ad2: eb7ff0b80004        lmg        %r7,%r15,184(%r15)\n           00000000009d0ad8: c0f4000d7dd0        brcl       15,b80678\n          #00000000009d0ade: a7f40001            brc        15,9d0ae0\n          >00000000009d0ae2: a7f4ff7d            brc        15,9d09dc\n           00000000009d0ae6: e340f0f00004        lg         %r4,240(%r15)\n           00000000009d0aec: eb7ff0b80004        lmg        %r7,%r15,184(%r15)\n           00000000009d0af2: 07f4                bcr        15,%r4\n           00000000009d0af4: 0707                bcr        0,%r7\nCall Trace:\n([<00000000009d09d6>] zfcp_dbf_rec_trig+0x66/0x188)\n [<00000000009dd740>] zfcp_scsi_rport_work+0x98/0x190\n [<0000000000169b34>] process_one_work+0x3d4/0x6f8\n [<000000000016a08a>] worker_thread+0x232/0x418\n [<000000000017219e>] kthread+0x166/0x178\n [<0000000000b815ea>] kernel_thread_starter+0x6/0xc\n [<0000000000b815e4>] kernel_thread_starter+0x0/0xc\n2 locks held by kworker/u128:3/604:\n #0:  ((wq_completion)name){+.+.}, at: [<0000000082af1024>] process_one_work+0x1dc/0x6f8\n #1:  ((work_completion)(&port->rport_work)){+.+.}, at: [<0000000082af1024>] process_one_work+0x1dc/0x6f8\nLast Breaking-Event-Address:\n [<00000000009d0ade>] zfcp_dbf_rec_trig+0x16e/0x188\n---[ end trace b2f4020572e2c124 ]---\n\nSuggested-by: Steffen Maier <maier@linux.ibm.com>\nSigned-off-by: Jens Remus <jremus@linux.ibm.com>\nReviewed-by: Benjamin Block <bblock@linux.ibm.com>\nReviewed-by: Steffen Maier <maier@linux.ibm.com>\nSigned-off-by: Steffen Maier <maier@linux.ibm.com>\nSigned-off-by: Martin K. Petersen <martin.petersen@oracle.com>",
        "before_after_code_files": [
          "drivers/s390/scsi/zfcp_dbf.c||drivers/s390/scsi/zfcp_dbf.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/s390/scsi/zfcp_dbf.c||drivers/s390/scsi/zfcp_dbf.c": [
          "File: drivers/s390/scsi/zfcp_dbf.c -> drivers/s390/scsi/zfcp_dbf.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "285:  struct list_head *entry;",
          "286:  unsigned long flags;",
          "288:  if (unlikely(!debug_level_enabled(dbf->rec, level)))",
          "289:   return;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "288:  lockdep_assert_held(&adapter->erp_lock);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "7f582b248d0a86bae5788c548d7bb5bca6f7691a",
      "candidate_info": {
        "commit_hash": "7f582b248d0a86bae5788c548d7bb5bca6f7691a",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/7f582b248d0a86bae5788c548d7bb5bca6f7691a",
        "files": [
          "net/ipv4/tcp_output.c"
        ],
        "message": "tcp: purge write queue in tcp_connect_init()\n\nsyzkaller found a reliable way to crash the host, hitting a BUG()\nin __tcp_retransmit_skb()\n\nMalicous MSG_FASTOPEN is the root cause. We need to purge write queue\nin tcp_connect_init() at the point we init snd_una/write_seq.\n\nThis patch also replaces the BUG() by a less intrusive WARN_ON_ONCE()\n\nkernel BUG at net/ipv4/tcp_output.c:2837!\ninvalid opcode: 0000 [#1] SMP KASAN\nDumping ftrace buffer:\n   (ftrace buffer empty)\nModules linked in:\nCPU: 0 PID: 5276 Comm: syz-executor0 Not tainted 4.17.0-rc3+ #51\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011\nRIP: 0010:__tcp_retransmit_skb+0x2992/0x2eb0 net/ipv4/tcp_output.c:2837\nRSP: 0000:ffff8801dae06ff8 EFLAGS: 00010206\nRAX: ffff8801b9fe61c0 RBX: 00000000ffc18a16 RCX: ffffffff864e1a49\nRDX: 0000000000000100 RSI: ffffffff864e2e12 RDI: 0000000000000005\nRBP: ffff8801dae073a0 R08: ffff8801b9fe61c0 R09: ffffed0039c40dd2\nR10: ffffed0039c40dd2 R11: ffff8801ce206e93 R12: 00000000421eeaad\nR13: ffff8801ce206d4e R14: ffff8801ce206cc0 R15: ffff8801cd4f4a80\nFS:  0000000000000000(0000) GS:ffff8801dae00000(0063) knlGS:00000000096bc900\nCS:  0010 DS: 002b ES: 002b CR0: 0000000080050033\nCR2: 0000000020000000 CR3: 00000001c47b6000 CR4: 00000000001406f0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nCall Trace:\n <IRQ>\n tcp_retransmit_skb+0x2e/0x250 net/ipv4/tcp_output.c:2923\n tcp_retransmit_timer+0xc50/0x3060 net/ipv4/tcp_timer.c:488\n tcp_write_timer_handler+0x339/0x960 net/ipv4/tcp_timer.c:573\n tcp_write_timer+0x111/0x1d0 net/ipv4/tcp_timer.c:593\n call_timer_fn+0x230/0x940 kernel/time/timer.c:1326\n expire_timers kernel/time/timer.c:1363 [inline]\n __run_timers+0x79e/0xc50 kernel/time/timer.c:1666\n run_timer_softirq+0x4c/0x70 kernel/time/timer.c:1692\n __do_softirq+0x2e0/0xaf5 kernel/softirq.c:285\n invoke_softirq kernel/softirq.c:365 [inline]\n irq_exit+0x1d1/0x200 kernel/softirq.c:405\n exiting_irq arch/x86/include/asm/apic.h:525 [inline]\n smp_apic_timer_interrupt+0x17e/0x710 arch/x86/kernel/apic/apic.c:1052\n apic_timer_interrupt+0xf/0x20 arch/x86/entry/entry_64.S:863\n\nFixes: cf60af03ca4e (\"net-tcp: Fast Open client - sendmsg(MSG_FASTOPEN)\")\nSigned-off-by: Eric Dumazet <edumazet@google.com>\nCc: Yuchung Cheng <ycheng@google.com>\nCc: Neal Cardwell <ncardwell@google.com>\nReported-by: syzbot <syzkaller@googlegroups.com>\nAcked-by: Neal Cardwell <ncardwell@google.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "net/ipv4/tcp_output.c||net/ipv4/tcp_output.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "net/ipv4/tcp_output.c||net/ipv4/tcp_output.c": [
          "File: net/ipv4/tcp_output.c -> net/ipv4/tcp_output.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2833:   return -EBUSY;",
          "2835:  if (before(TCP_SKB_CB(skb)->seq, tp->snd_una)) {",
          "2838:   if (tcp_trim_head(sk, skb, tp->snd_una - TCP_SKB_CB(skb)->seq))",
          "2839:    return -ENOMEM;",
          "2840:  }",
          "",
          "[Removed Lines]",
          "2836:   if (before(TCP_SKB_CB(skb)->end_seq, tp->snd_una))",
          "2837:    BUG();",
          "",
          "[Added Lines]",
          "2836:   if (unlikely(before(TCP_SKB_CB(skb)->end_seq, tp->snd_una))) {",
          "2837:    WARN_ON_ONCE(1);",
          "2838:    return -EINVAL;",
          "2839:   }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3342:  sock_reset_flag(sk, SOCK_DONE);",
          "3343:  tp->snd_wnd = 0;",
          "3344:  tcp_init_wl(tp, 0);",
          "3345:  tp->snd_una = tp->write_seq;",
          "3346:  tp->snd_sml = tp->write_seq;",
          "3347:  tp->snd_up = tp->write_seq;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3347:  tcp_write_queue_purge(sk);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2021-31616",
  "cve_desc": "Insufficient length checks in the ShapeShift KeepKey hardware wallet firmware before 7.1.0 allow a stack buffer overflow via crafted messages. The overflow in ethereum_extractThorchainSwapData() in ethereum.c can circumvent stack protections and lead to code execution. The vulnerable interface is reachable remotely over WebUSB.",
  "repo": "keepkey/keepkey-firmware",
  "patch_hash": "e49d45594002d4d3fbc1f03488e6dfc0a0a65836",
  "patch_info": {
    "commit_hash": "e49d45594002d4d3fbc1f03488e6dfc0a0a65836",
    "repo": "keepkey/keepkey-firmware",
    "commit_url": "https://github.com/keepkey/keepkey-firmware/commit/e49d45594002d4d3fbc1f03488e6dfc0a0a65836",
    "files": [
      "deps/python-keepkey",
      "lib/firmware/ethereum.c",
      "lib/firmware/ethereum_contracts/zxliquidtx.c"
    ],
    "message": "710 merge",
    "before_after_code_files": [
      "lib/firmware/ethereum.c||lib/firmware/ethereum.c",
      "lib/firmware/ethereum_contracts/zxliquidtx.c||lib/firmware/ethereum_contracts/zxliquidtx.c"
    ]
  },
  "patch_diff": {
    "lib/firmware/ethereum.c||lib/firmware/ethereum.c": [
      "File: lib/firmware/ethereum.c -> lib/firmware/ethereum.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "94:   uint16_t offset = 4 + (5 * 32);",
      "95:   int16_t len = msg->data_length - offset;",
      "97:     memcpy(buffer, msg->data_initial_chunk.bytes + offset, len);",
      "100:   }",
      "101:   return 0;",
      "102: }",
      "",
      "[Removed Lines]",
      "96:   if (msg->has_data_length && len > 0) {",
      "99:     return len < 256 ? (uint8_t)len : 0;",
      "",
      "[Added Lines]",
      "96:   if (msg->has_data_length && len > 0 && len < 256) {",
      "99:     return (uint8_t)len;",
      "",
      "---------------"
    ],
    "lib/firmware/ethereum_contracts/zxliquidtx.c||lib/firmware/ethereum_contracts/zxliquidtx.c": [
      "File: lib/firmware/ethereum_contracts/zxliquidtx.c -> lib/firmware/ethereum_contracts/zxliquidtx.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "168:     confirm(ButtonRequestType_ButtonRequest_ConfirmOutput, arStr,",
      "169:                  \"Minimum %s\", constr1);",
      "172:     confirm(ButtonRequestType_ButtonRequest_ConfirmOutput, arStr,",
      "173:                  \"Deadline %s\", ctime((const time_t *)&deadline));",
      "",
      "[Removed Lines]",
      "171:     snprintf(constr1, 32, \"%lld\", deadline);",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "3022c5c9a10bc40d74b9a1fcc812f081029b980a",
      "candidate_info": {
        "commit_hash": "3022c5c9a10bc40d74b9a1fcc812f081029b980a",
        "repo": "keepkey/keepkey-firmware",
        "commit_url": "https://github.com/keepkey/keepkey-firmware/commit/3022c5c9a10bc40d74b9a1fcc812f081029b980a",
        "files": [
          "CMakeLists.txt",
          "include/keepkey/firmware/ethereum_contracts/zxappliquid.h",
          "lib/firmware/ethereum_contracts/zxappliquid.c",
          "lib/firmware/ethereum_contracts/zxliquidtx.c"
        ],
        "message": "bump version",
        "before_after_code_files": [
          "include/keepkey/firmware/ethereum_contracts/zxappliquid.h||include/keepkey/firmware/ethereum_contracts/zxappliquid.h",
          "lib/firmware/ethereum_contracts/zxappliquid.c||lifirmware/ethereum_contracts/zxappliquid.c",
          "lib/firmware/ethereum_contracts/zxliquidtx.c||lifirmware/ethereum_contracts/zxliquidtx.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "lib/firmware/ethereum_contracts/zxliquidtx.c||lib/firmware/ethereum_contracts/zxliquidtx.c"
          ],
          "candidate": [
            "lib/firmware/ethereum_contracts/zxliquidtx.c||lifirmware/ethereum_contracts/zxliquidtx.c"
          ]
        }
      },
      "candidate_diff": {
        "include/keepkey/firmware/ethereum_contracts/zxappliquid.h||include/keepkey/firmware/ethereum_contracts/zxappliquid.h": [
          "File: include/keepkey/firmware/ethereum_contracts/zxappliquid.h -> include/keepkey/firmware/ethereum_contracts/zxappliquid.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "23: #include <inttypes.h>",
          "24: #include <stdbool.h>",
          "28: typedef struct _EthereumSignTx EthereumSignTx;",
          "",
          "[Removed Lines]",
          "26: #define MAX_ALLOWANCE \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x52\\xb7\\xd2\\xdc\\xc8\\x0c\\xd2\\xe4\\x00\\x00\\x00\"",
          "",
          "[Added Lines]",
          "26: #define MAX_ALLOWANCE \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\"",
          "",
          "---------------"
        ],
        "lib/firmware/ethereum_contracts/zxappliquid.c||lifirmware/ethereum_contracts/zxappliquid.c": [
          "File: lib/firmware/ethereum_contracts/zxappliquid.c -> lifirmware/ethereum_contracts/zxappliquid.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "96:         amt = amtStr;",
          "97:     }",
          "100:                  \"Amount: %s\", amt);",
          "102:                  \"approve for pool %s %s\", tikstr, poolstr);",
          "103:     return true;",
          "104: }",
          "",
          "[Removed Lines]",
          "99:     confirm(ButtonRequestType_ButtonRequest_ConfirmOutput, \"uniswap approve liquidity\",",
          "101:     confirm(ButtonRequestType_ButtonRequest_ConfirmOutput, \"uniswap approve liquidity\",",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "lib/firmware/ethereum_contracts/zxliquidtx.c||lifirmware/ethereum_contracts/zxliquidtx.c": [
          "File: lib/firmware/ethereum_contracts/zxliquidtx.c -> lifirmware/ethereum_contracts/zxliquidtx.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "76:     return false;",
          "77: }",
          "82:     char *fromSrc;",
          "83:     uint8_t *fromAddress;",
          "84:     uint8_t addressBytes[20];",
          "",
          "[Removed Lines]",
          "79: static bool confirmFromAccountMatch(const EthereumSignTx *msg) {",
          "81:     char addressStr[43] = {'0', 'x'};",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "91:         memzero(node, sizeof(*node));",
          "92:     }",
          "115:     fromAddress = (uint8_t *)(msg->data_initial_chunk.bytes + 4 + 5*32 - 20);",
          "117:     if (memcmp(fromAddress, addressBytes, 20) == 0) {",
          "",
          "[Removed Lines]",
          "94:     bool rskip60 = false;",
          "95:     uint32_t chain_id = 0;",
          "97:     if (msg->address_n_count == 5) {",
          "98:         uint32_t slip44 = msg->address_n[1] & 0x7fffffff;",
          "100:         switch (slip44) {",
          "101:             case 137:",
          "102:                 rskip60 = true;",
          "103:                 chain_id = 30;",
          "104:                 break;",
          "105:             case 37310:",
          "106:                 rskip60 = true;",
          "107:                 chain_id = 31;",
          "108:             break;",
          "109:         }",
          "110:     }",
          "112:     ethereum_address_checksum(addressBytes, addressStr + 2, rskip60,",
          "113:                             chain_id);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "120:         fromSrc = \"NOT this wallet\";",
          "121:     }",
          "125:        return false;",
          "126:     }",
          "127:     return true;",
          "",
          "[Removed Lines]",
          "123:     if (!confirm(ButtonRequestType_ButtonRequest_ConfirmOutput, \"Uniswap Add Liquidity\",",
          "124:                   \"Confirming ETH sending from %s: %s\", fromSrc, addressStr)) {",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "140: bool zx_confirmZxLiquidTx(uint32_t data_total, const EthereumSignTx *msg) {",
          "141:     (void)data_total;",
          "142:     const TokenType *token;",
          "144:     uint8_t *tokenAddress, *deadlineBytes;",
          "145:     bignum256 tokenAmount, tokenMinAmount, ethMinAmount;",
          "146:     uint64_t deadline;",
          "189:     }",
          "192: }",
          "",
          "[Removed Lines]",
          "143:     char constr1[40], constr2[40];",
          "148:     if (isAddLiquidityEthCall(msg)) {                     // add liquidity confirm",
          "149:         tokenAddress = (uint8_t *)(msg->data_initial_chunk.bytes + 4 + 32 - 20);",
          "150:         token = tokenByChainAddress(msg->chain_id, tokenAddress);",
          "151:         bn_from_bytes(msg->data_initial_chunk.bytes + 4 + 32, 32, &tokenAmount);",
          "152:         bn_from_bytes(msg->data_initial_chunk.bytes + 4 + 2*32, 32, &tokenMinAmount);",
          "153:         bn_from_bytes(msg->data_initial_chunk.bytes + 4 + 3*32, 32, &ethMinAmount);",
          "156:         deadlineBytes = (uint8_t *)(msg->data_initial_chunk.bytes + 4 + 6*32 - 8);",
          "157:         deadline = ((uint64_t)deadlineBytes[0] << 8*7) |",
          "158:                    ((uint64_t)deadlineBytes[1] << 8*6) |",
          "159:                    ((uint64_t)deadlineBytes[2] << 8*5) |",
          "160:                    ((uint64_t)deadlineBytes[3] << 8*4) |",
          "161:                    ((uint64_t)deadlineBytes[4] << 8*3) |",
          "162:                    ((uint64_t)deadlineBytes[5] << 8*2) |",
          "163:                    ((uint64_t)deadlineBytes[6] << 8*1) |",
          "164:                    ((uint64_t)deadlineBytes[7]);",
          "166:         char tokbuf[32];",
          "167:         ethereumFormatAmount(&tokenAmount, token, msg->chain_id, tokbuf, sizeof(tokbuf));",
          "168:         snprintf(constr1, 32, \"%s\", tokbuf);",
          "169:         ethereumFormatAmount(&tokenMinAmount, token, msg->chain_id, tokbuf, sizeof(tokbuf));",
          "170:         snprintf(constr2, 32, \"%s\", tokbuf);",
          "172:         confirm(ButtonRequestType_ButtonRequest_ConfirmOutput, \"uniswap add liquidity\",",
          "173:                      \"Add %s\\nMinimum %s\", constr1, constr2);",
          "175:         if (!confirmFromAccountMatch(msg)) {",
          "176:             return false;",
          "177:         }",
          "179:         ethereumFormatAmount(&ethMinAmount, NULL, msg->chain_id, tokbuf, sizeof(tokbuf));",
          "180:         snprintf(constr1, 32, \"%s\", tokbuf);",
          "181:         confirm(ButtonRequestType_ButtonRequest_ConfirmOutput, \"uniswap add liquidity\",",
          "182:                      \"Add Minimum %s\", constr1);",
          "184:         snprintf(constr1, 32, \"%lld\", deadline);",
          "185:         confirm(ButtonRequestType_ButtonRequest_ConfirmOutput, \"uniswap add liquidity\",",
          "186:                      \"Deadline (unix ref) %s\", constr1);",
          "188:         return true;",
          "191:    return true;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "970e4bd46bb1275954a67a727905d4d9ec01cf02",
      "candidate_info": {
        "commit_hash": "970e4bd46bb1275954a67a727905d4d9ec01cf02",
        "repo": "keepkey/keepkey-firmware",
        "commit_url": "https://github.com/keepkey/keepkey-firmware/commit/970e4bd46bb1275954a67a727905d4d9ec01cf02",
        "files": [
          "lib/firmware/ethereum.c"
        ],
        "message": "Parse THORChain swap data from ETH transactions",
        "before_after_code_files": [
          "lib/firmware/ethereum.c||lifirmware/ethereum.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "lib/firmware/ethereum.c||lib/firmware/ethereum.c"
          ],
          "candidate": [
            "lib/firmware/ethereum.c||lifirmware/ethereum.c"
          ]
        }
      },
      "candidate_diff": {
        "lib/firmware/ethereum.c||lifirmware/ethereum.c": [
          "File: lib/firmware/ethereum.c -> lifirmware/ethereum.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "33: #include \"keepkey/firmware/ethereum_contracts/makerdao.h\"",
          "34: #include \"keepkey/firmware/ethereum_tokens.h\"",
          "35: #include \"keepkey/firmware/storage.h\"",
          "36: #include \"keepkey/firmware/transaction.h\"",
          "37: #include \"trezor/crypto/address.h\"",
          "38: #include \"trezor/crypto/ecdsa.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "76:   return false;",
          "77: }",
          "79: bool ethereum_getStandardERC20Recipient(const EthereumSignTx *msg,",
          "80:                                         char *address, size_t len) {",
          "81:   if (len < 2 * 20 + 1) return false;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "649:     data_needs_confirm = false;",
          "650:   }",
          "653:   if (data_total == 68 && ethereum_isStandardERC20Transfer(msg)) {",
          "654:     token = tokenByChainAddress(chain_id, msg->to.bytes);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "926:     return 2;",
          "927:   }",
          "928:   return 0;",
          "",
          "[Removed Lines]",
          "929: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "15c27a4bf523b2883b61c8e90b77b91d5faec0e4",
      "candidate_info": {
        "commit_hash": "15c27a4bf523b2883b61c8e90b77b91d5faec0e4",
        "repo": "keepkey/keepkey-firmware",
        "commit_url": "https://github.com/keepkey/keepkey-firmware/commit/15c27a4bf523b2883b61c8e90b77b91d5faec0e4",
        "files": [
          "include/keepkey/firmware/ethereum_contracts/zxappliquid.h",
          "include/keepkey/firmware/ethereum_contracts/zxliquidtx.h",
          "include/keepkey/firmware/ethereum_tokens.h",
          "lib/firmware/CMakeLists.txt",
          "lib/firmware/ethereum_contracts.c",
          "lib/firmware/ethereum_contracts/zxappliquid.c",
          "lib/firmware/ethereum_contracts/zxliquidtx.c",
          "lib/firmware/ethereum_contracts/zxswap.c",
          "lib/firmware/ethereum_tokens.c"
        ],
        "message": "uniswap add liquidity and approve liquid txs work",
        "before_after_code_files": [
          "include/keepkey/firmware/ethereum_contracts/zxappliquid.h||include/keepkey/firmware/ethereum_contracts/zxappliquid.h",
          "include/keepkey/firmware/ethereum_contracts/zxliquidtx.h||include/keepkey/firmware/ethereum_contracts/zxliquidtx.h",
          "include/keepkey/firmware/ethereum_tokens.h||include/keepkey/firmware/ethereum_tokens.h",
          "lib/firmware/ethereum_contracts.c||lib/firmware/ethereum_contracts.c",
          "lib/firmware/ethereum_contracts/zxappliquid.c||lib/firmware/ethereum_contracts/zxappliquid.c",
          "lib/firmware/ethereum_contracts/zxliquidtx.c||lib/firmware/ethereum_contracts/zxliquidtx.c",
          "lib/firmware/ethereum_contracts/zxswap.c||lib/firmware/ethereum_contracts/zxswap.c",
          "lib/firmware/ethereum_tokens.c||lib/firmware/ethereum_tokens.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "lib/firmware/ethereum_contracts/zxliquidtx.c||lib/firmware/ethereum_contracts/zxliquidtx.c"
          ],
          "candidate": [
            "lib/firmware/ethereum_contracts/zxliquidtx.c||lib/firmware/ethereum_contracts/zxliquidtx.c"
          ]
        }
      },
      "candidate_diff": {
        "include/keepkey/firmware/ethereum_contracts/zxappliquid.h||include/keepkey/firmware/ethereum_contracts/zxappliquid.h": [
          "File: include/keepkey/firmware/ethereum_contracts/zxappliquid.h -> include/keepkey/firmware/ethereum_contracts/zxappliquid.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "20: #ifndef KEEPKEY_FIRMWARE_ETHEREUMCONTRACTS_ZXAPPLIQUIDTX_H",
          "21: #define KEEPKEY_FIRMWARE_ETHEREUMCONTRACTS_ZXAPPLIQUIDTX_H",
          "23: #include <inttypes.h>",
          "24: #include <stdbool.h>",
          "26: #define MAX_ALLOWANCE \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x52\\xb7\\xd2\\xdc\\xc8\\x0c\\xd2\\xe4\\x00\\x00\\x00\"",
          "28: typedef struct _EthereumSignTx EthereumSignTx;",
          "30: bool zx_isZxApproveLiquid(const EthereumSignTx *msg);",
          "31: bool zx_confirmApproveLiquidity(uint32_t data_total, const EthereumSignTx *msg);",
          "33: #endif",
          "",
          "---------------"
        ],
        "include/keepkey/firmware/ethereum_contracts/zxliquidtx.h||include/keepkey/firmware/ethereum_contracts/zxliquidtx.h": [
          "File: include/keepkey/firmware/ethereum_contracts/zxliquidtx.h -> include/keepkey/firmware/ethereum_contracts/zxliquidtx.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "20: #ifndef KEEPKEY_FIRMWARE_ETHEREUMCONTRACTS_ZXLIQUIDTX_H",
          "21: #define KEEPKEY_FIRMWARE_ETHEREUMCONTRACTS_ZXLIQUIDTX_H",
          "23: #include <inttypes.h>",
          "24: #include <stdbool.h>",
          "26: #define UNISWAP_ROUTER_ADDRESS \"\\x7a\\x25\\x0d\\x56\\x30\\xB4\\xcF\\x53\\x97\\x39\\xdF\\x2C\\x5d\\xAc\\xb4\\xc6\\x59\\xF2\\x48\\x8D\"",
          "28: typedef struct _EthereumSignTx EthereumSignTx;",
          "30: bool zx_isZxLiquidTx(const EthereumSignTx *msg);",
          "31: bool zx_confirmZxLiquidTx(uint32_t data_total, const EthereumSignTx *msg);",
          "33: #endif",
          "",
          "---------------"
        ],
        "include/keepkey/firmware/ethereum_tokens.h||include/keepkey/firmware/ethereum_tokens.h": [
          "File: include/keepkey/firmware/ethereum_tokens.h -> include/keepkey/firmware/ethereum_tokens.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "50: extern const TokenType *UnknownToken;",
          "52: const TokenType *tokenByChainAddress(uint8_t chain_id, const uint8_t *address);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "52: const TokenType *tokenIter(int32_t *ctr);",
          "",
          "---------------"
        ],
        "lib/firmware/ethereum_contracts.c||lib/firmware/ethereum_contracts.c": [
          "File: lib/firmware/ethereum_contracts.c -> lib/firmware/ethereum_contracts.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "20: #include \"keepkey/firmware/ethereum_contracts.h\"",
          "22: #include \"keepkey/firmware/ethereum_contracts/zxswap.h\"",
          "23: #include \"keepkey/firmware/ethereum_contracts/makerdao.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "22: #include \"keepkey/firmware/ethereum_contracts/zxappliquid.h\"",
          "23: #include \"keepkey/firmware/ethereum_contracts/zxliquidtx.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "30:   if (zx_isZxSwap(msg)) return true;",
          "32:   if (makerdao_isMakerDAO(data_total, msg)) return true;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "33:   if (zx_isZxLiquidTx(msg)) return true;",
          "34:   if (zx_isZxApproveLiquid(msg)) return true;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "41:   if (zx_isZxSwap(msg))",
          "42:     return zx_confirmZxSwap(data_total, msg);",
          "44:   if (makerdao_isMakerDAO(data_total, msg))",
          "45:     return makerdao_confirmMakerDAO(data_total, msg);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "48:   if (zx_isZxLiquidTx(msg))",
          "49:     return zx_confirmZxLiquidTx(data_total, msg);",
          "51:   if (zx_isZxApproveLiquid(msg))",
          "52:     return zx_confirmApproveLiquidity(data_total, msg);",
          "",
          "---------------"
        ],
        "lib/firmware/ethereum_contracts/zxappliquid.c||lib/firmware/ethereum_contracts/zxappliquid.c": [
          "File: lib/firmware/ethereum_contracts/zxappliquid.c -> lib/firmware/ethereum_contracts/zxappliquid.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "20: #include \"keepkey/firmware/ethereum_contracts/zxappliquid.h\"",
          "21: #include \"keepkey/firmware/ethereum_contracts/zxliquidtx.h\"",
          "23: #include \"keepkey/board/confirm_sm.h\"",
          "24: #include \"keepkey/board/util.h\"",
          "25: #include \"keepkey/firmware/app_confirm.h\"",
          "26: #include \"keepkey/firmware/coins.h\"",
          "27: #include \"keepkey/firmware/ethereum.h\"",
          "28: #include \"keepkey/firmware/ethereum_tokens.h\"",
          "29: #include \"keepkey/firmware/fsm.h\"",
          "30: #include \"keepkey/firmware/storage.h\"",
          "31: #include \"trezor/crypto/address.h\"",
          "32: #include \"trezor/crypto/bip32.h\"",
          "33: #include \"trezor/crypto/curves.h\"",
          "34: #include \"trezor/crypto/memzero.h\"",
          "35: #include \"trezor/crypto/sha3.h\"",
          "37: bool zx_confirmApproveLiquidity(uint32_t data_total, const EthereumSignTx *msg) {",
          "38:     (void)data_total;",
          "39:     const char *to, *tikstr, *poolstr, *allowance, *amt;",
          "40:     unsigned char data[40];",
          "41:     uint8_t digest[SHA3_256_DIGEST_LENGTH] = {0};",
          "42:     uint8_t tokdigest[SHA3_256_DIGEST_LENGTH] = {0};",
          "43:     char digestStr[2*SHA3_256_DIGEST_LENGTH+1], amtStr[2*32+1] = {0};",
          "44:     int32_t ctr, tokctr;",
          "45:     uint32_t wethord, ttokenord;",
          "46:     const TokenType *WETH, *ttoken;",
          "48:     if (!tokenByTicker(msg->chain_id, \"WETH\", &WETH)) return false;",
          "49:     wethord = read_be((const uint8_t *)WETH->address);",
          "50:     to = (const char *)msg->to.bytes;",
          "51:     tokctr = 0;",
          "52:     while (tokctr != -1) {",
          "53:         ttoken = tokenIter(&tokctr);",
          "56:         ttokenord = read_be((const uint8_t *)ttoken->address);",
          "57:         if (ttokenord < wethord) {",
          "58:             memcpy(data, ttoken->address, 20);",
          "59:             memcpy(&data[20], WETH->address, 20);",
          "60:         } else {",
          "61:             memcpy(data, WETH->address, 20);",
          "62:             memcpy(&data[20], ttoken->address, 20);",
          "63:         }",
          "64:         keccak_256(data, sizeof(data), tokdigest);",
          "65:      SHA3_CTX ctx = {0};",
          "66:      keccak_256_Init(&ctx);",
          "67:      keccak_Update(&ctx, (unsigned char *)\"\\xff\", 1);",
          "68:      keccak_Update(&ctx, (unsigned char *)\"\\x5C\\x69\\xbE\\xe7\\x01\\xef\\x81\\x4a\\x2B\\x6a\\x3E\\xDD\\x4B\\x16\\x52\\xCB\\x9c\\xc5\\xaA\\x6f\", 20);",
          "69:      keccak_Update(&ctx, tokdigest, sizeof(tokdigest));",
          "70:      keccak_Update(&ctx, (unsigned char *)\"\\x96\\xe8\\xac\\x42\\x77\\x19\\x8f\\xf8\\xb6\\xf7\\x85\\x47\\x8a\\xa9\\xa3\\x9f\\x40\\x3c\\xb7\\x68\\xdd\\x02\\xcb\\xee\\x32\\x6c\\x3e\\x7d\\xa3\\x48\\x84\\x5f\", 32);",
          "71:      keccak_Final(&ctx, digest);",
          "72:         if (memcmp(to, &digest[12], 20) == 0) break;",
          "73:     }",
          "75:     if (tokctr != -1) {",
          "76:         for (ctr=0; ctr<SHA3_256_DIGEST_LENGTH; ctr++) {",
          "77:             snprintf(&digestStr[ctr*2], 3, \"%02x\", digest[ctr]);",
          "78:         }",
          "79:         tikstr = ttoken->ticker;",
          "80:         poolstr = &digestStr[12*2];",
          "81:     } else {",
          "82:         for (ctr=0; ctr<20; ctr++) {",
          "83:             snprintf(&digestStr[ctr*2], 3, \"%02x\", to[ctr]);",
          "84:         }",
          "85:         tikstr = \"\";",
          "86:         poolstr = digestStr;",
          "87:     }",
          "89:     allowance = (char *)(msg->data_initial_chunk.bytes + 4 +32);",
          "90:     if (memcmp(allowance, (uint8_t *)&MAX_ALLOWANCE, 32) == 0) {",
          "91:         amt = \"full balance\";",
          "92:     } else {",
          "93:         for (ctr=0; ctr<32; ctr++) {",
          "94:             snprintf(&amtStr[ctr*2], 3, \"%02x\", allowance[ctr]);",
          "95:         }",
          "96:         amt = amtStr;",
          "97:     }",
          "99:     confirm(ButtonRequestType_ButtonRequest_ConfirmOutput, \"uniswap approve liquidity\",",
          "100:                  \"Amount: %s\", amt);",
          "101:     confirm(ButtonRequestType_ButtonRequest_ConfirmOutput, \"uniswap approve liquidity\",",
          "102:                  \"approve for pool %s %s\", tikstr, poolstr);",
          "103:     return true;",
          "104: }",
          "106: bool zx_isZxApproveLiquid(const EthereumSignTx *msg) {",
          "107:     if (memcmp(msg->data_initial_chunk.bytes, \"\\x09\\x5e\\xa7\\xb3\", 4) == 0)",
          "108:         if (memcmp((uint8_t *)(msg->data_initial_chunk.bytes + 4 + 32 - 20), UNISWAP_ROUTER_ADDRESS, 20) == 0)",
          "109:             return true;",
          "110:     return false;",
          "111: }",
          "",
          "---------------"
        ],
        "lib/firmware/ethereum_contracts/zxliquidtx.c||lib/firmware/ethereum_contracts/zxliquidtx.c": [
          "File: lib/firmware/ethereum_contracts/zxliquidtx.c -> lib/firmware/ethereum_contracts/zxliquidtx.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "20: #include \"keepkey/firmware/ethereum_contracts/zxliquidtx.h\"",
          "22: #include \"keepkey/board/confirm_sm.h\"",
          "23: #include \"keepkey/board/util.h\"",
          "24: #include \"keepkey/firmware/app_confirm.h\"",
          "25: #include \"keepkey/firmware/coins.h\"",
          "26: #include \"keepkey/firmware/ethereum.h\"",
          "27: #include \"keepkey/firmware/ethereum_tokens.h\"",
          "28: #include \"keepkey/firmware/fsm.h\"",
          "29: #include \"keepkey/firmware/storage.h\"",
          "30: #include \"trezor/crypto/address.h\"",
          "31: #include \"trezor/crypto/bip32.h\"",
          "32: #include \"trezor/crypto/curves.h\"",
          "33: #include \"trezor/crypto/memzero.h\"",
          "34: #include \"trezor/crypto/sha3.h\"",
          "36: static HDNode *zx_getDerivedNode(const char *curve, const uint32_t *address_n,",
          "37:                                   size_t address_n_count,",
          "38:                                   uint32_t *fingerprint) {",
          "39:     static HDNode CONFIDENTIAL node;",
          "40:     if (fingerprint) {",
          "42:     }",
          "44:     if (!get_curve_by_name(curve)) {",
          "45:        return 0;",
          "46:     }",
          "48:     if (!storage_getRootNode(curve, true, &node)) {",
          "49:         return 0;",
          "50:     }",
          "52:     if (!address_n || address_n_count == 0) {",
          "53:         return &node;",
          "54:     }",
          "56:     if (hdnode_private_ckd_cached(&node, address_n, address_n_count,",
          "57:                                 fingerprint) == 0) {",
          "58:         return 0;",
          "59:     }",
          "61:     return &node;",
          "62: }",
          "65: static bool isAddLiquidityEthCall(const EthereumSignTx *msg) {",
          "66:     if (memcmp(msg->data_initial_chunk.bytes, \"\\xf3\\x05\\xd7\\x19\", 4) == 0)",
          "67:         return true;",
          "69:     return false;",
          "70: }",
          "72: static bool isRemoveLiquidityEthCall(const EthereumSignTx *msg) {",
          "73:     if (memcmp(msg->data_initial_chunk.bytes, \"\\x02\\x75\\x1c\\xec\", 4) == 0)",
          "74:         return true;",
          "76:     return false;",
          "77: }",
          "79: static bool confirmFromAccountMatch(const EthereumSignTx *msg) {",
          "81:     char addressStr[43] = {'0', 'x'};",
          "82:     char *fromSrc;",
          "83:     uint8_t *fromAddress;",
          "84:     uint8_t addressBytes[20];",
          "86:     HDNode *node = zx_getDerivedNode(SECP256K1_NAME, msg->address_n,",
          "87:                                     msg->address_n_count, NULL);",
          "88:     if (!node) return false;",
          "90:     if (!hdnode_get_ethereum_pubkeyhash(node, addressBytes)) {",
          "91:         memzero(node, sizeof(*node));",
          "92:     }",
          "94:     bool rskip60 = false;",
          "95:     uint32_t chain_id = 0;",
          "97:     if (msg->address_n_count == 5) {",
          "98:         uint32_t slip44 = msg->address_n[1] & 0x7fffffff;",
          "100:         switch (slip44) {",
          "101:             case 137:",
          "102:                 rskip60 = true;",
          "103:                 chain_id = 30;",
          "104:                 break;",
          "105:             case 37310:",
          "106:                 rskip60 = true;",
          "107:                 chain_id = 31;",
          "108:             break;",
          "109:         }",
          "110:     }",
          "112:     ethereum_address_checksum(addressBytes, addressStr + 2, rskip60,",
          "113:                             chain_id);",
          "115:     fromAddress = (uint8_t *)(msg->data_initial_chunk.bytes + 4 + 5*32 - 20);",
          "117:     if (memcmp(fromAddress, addressBytes, 20) == 0) {",
          "118:         fromSrc = \"self\";",
          "119:     } else {",
          "120:         fromSrc = \"NOT this wallet\";",
          "121:     }",
          "123:     if (!confirm(ButtonRequestType_ButtonRequest_ConfirmOutput, \"Uniswap Add Liquidity\",",
          "124:                   \"Confirming ETH sending from %s: %s\", fromSrc, addressStr)) {",
          "125:        return false;",
          "126:     }",
          "127:     return true;",
          "128: }",
          "130: bool zx_isZxLiquidTx(const EthereumSignTx *msg) {",
          "131:     if (memcmp(msg->to.bytes, UNISWAP_ROUTER_ADDRESS, 20) == 0) {   // correct contract address?",
          "133:         if (isAddLiquidityEthCall(msg)) return true;",
          "135:         if (isRemoveLiquidityEthCall(msg)) return true;",
          "136:     }",
          "137:     return false;",
          "138: }",
          "140: bool zx_confirmZxLiquidTx(uint32_t data_total, const EthereumSignTx *msg) {",
          "141:     (void)data_total;",
          "142:     const TokenType *token;",
          "143:     char constr1[40], constr2[40];",
          "144:     uint8_t *tokenAddress, *deadlineBytes;",
          "145:     bignum256 tokenAmount, tokenMinAmount, ethMinAmount;",
          "146:     uint64_t deadline;",
          "148:     if (isAddLiquidityEthCall(msg)) {                     // add liquidity confirm",
          "149:         tokenAddress = (uint8_t *)(msg->data_initial_chunk.bytes + 4 + 32 - 20);",
          "150:         token = tokenByChainAddress(msg->chain_id, tokenAddress);",
          "151:         bn_from_bytes(msg->data_initial_chunk.bytes + 4 + 32, 32, &tokenAmount);",
          "152:         bn_from_bytes(msg->data_initial_chunk.bytes + 4 + 2*32, 32, &tokenMinAmount);",
          "153:         bn_from_bytes(msg->data_initial_chunk.bytes + 4 + 3*32, 32, &ethMinAmount);",
          "156:         deadlineBytes = (uint8_t *)(msg->data_initial_chunk.bytes + 4 + 6*32 - 8);",
          "157:         deadline = ((uint64_t)deadlineBytes[0] << 8*7) |",
          "158:                    ((uint64_t)deadlineBytes[1] << 8*6) |",
          "159:                    ((uint64_t)deadlineBytes[2] << 8*5) |",
          "160:                    ((uint64_t)deadlineBytes[3] << 8*4) |",
          "161:                    ((uint64_t)deadlineBytes[4] << 8*3) |",
          "162:                    ((uint64_t)deadlineBytes[5] << 8*2) |",
          "163:                    ((uint64_t)deadlineBytes[6] << 8*1) |",
          "164:                    ((uint64_t)deadlineBytes[7]);",
          "166:         char tokbuf[32];",
          "167:         ethereumFormatAmount(&tokenAmount, token, msg->chain_id, tokbuf, sizeof(tokbuf));",
          "168:         snprintf(constr1, 32, \"%s\", tokbuf);",
          "169:         ethereumFormatAmount(&tokenMinAmount, token, msg->chain_id, tokbuf, sizeof(tokbuf));",
          "170:         snprintf(constr2, 32, \"%s\", tokbuf);",
          "172:         confirm(ButtonRequestType_ButtonRequest_ConfirmOutput, \"uniswap add liquidity\",",
          "173:                      \"Add %s\\nMinimum %s\", constr1, constr2);",
          "175:         if (!confirmFromAccountMatch(msg)) {",
          "176:             return false;",
          "177:         }",
          "179:         ethereumFormatAmount(&ethMinAmount, NULL, msg->chain_id, tokbuf, sizeof(tokbuf));",
          "180:         snprintf(constr1, 32, \"%s\", tokbuf);",
          "181:         confirm(ButtonRequestType_ButtonRequest_ConfirmOutput, \"uniswap add liquidity\",",
          "182:                      \"Add Minimum %s\", constr1);",
          "184:         snprintf(constr1, 32, \"%lld\", deadline);",
          "185:         confirm(ButtonRequestType_ButtonRequest_ConfirmOutput, \"uniswap add liquidity\",",
          "186:                      \"Deadline (unix ref) %s\", constr1);",
          "188:         return true;",
          "189:     }",
          "191:    return true;",
          "192: }",
          "",
          "---------------"
        ],
        "lib/firmware/ethereum_contracts/zxswap.c||lib/firmware/ethereum_contracts/zxswap.c": [
          "File: lib/firmware/ethereum_contracts/zxswap.c -> lib/firmware/ethereum_contracts/zxswap.c"
        ],
        "lib/firmware/ethereum_tokens.c||lib/firmware/ethereum_tokens.c": [
          "File: lib/firmware/ethereum_tokens.c -> lib/firmware/ethereum_tokens.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "26:     \"  ETH\", 1, 18};",
          "27: const TokenType *EthTestToken = (const TokenType *)&Ethtest;",
          "29: const TokenType *tokenByChainAddress(uint8_t chain_id, const uint8_t *address) {",
          "30:   if (!address) return 0;",
          "31:   for (int i = 0; i < TOKENS_COUNT; i++) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "29: const TokenType *tokenIter(int32_t *ctr) {",
          "35:   if (*ctr < 0 || *ctr >= TOKENS_COUNT) {",
          "37:     return UnknownToken;",
          "38:   }",
          "41:   return &(tokens[*ctr - 1]);",
          "43: }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
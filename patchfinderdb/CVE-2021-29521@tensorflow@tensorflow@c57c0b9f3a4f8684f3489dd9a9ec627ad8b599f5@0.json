{
  "cve_id": "CVE-2021-29521",
  "cve_desc": "TensorFlow is an end-to-end open source platform for machine learning. Specifying a negative dense shape in `tf.raw_ops.SparseCountSparseOutput` results in a segmentation fault being thrown out from the standard library as `std::vector` invariants are broken. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/8f7b60ee8c0206a2c99802e3a4d1bb55d2bc0624/tensorflow/core/kernels/count_ops.cc#L199-L213) assumes the first element of the dense shape is always positive and uses it to initialize a `BatchedMap<T>` (i.e., `std::vector<absl::flat_hash_map<int64,T>>`(https://github.com/tensorflow/tensorflow/blob/8f7b60ee8c0206a2c99802e3a4d1bb55d2bc0624/tensorflow/core/kernels/count_ops.cc#L27)) data structure. If the `shape` tensor has more than one element, `num_batches` is the first value in `shape`. Ensuring that the `dense_shape` argument is a valid tensor shape (that is, all elements are non-negative) solves this issue. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2 and TensorFlow 2.3.3.",
  "repo": "tensorflow/tensorflow",
  "patch_hash": "c57c0b9f3a4f8684f3489dd9a9ec627ad8b599f5",
  "patch_info": {
    "commit_hash": "c57c0b9f3a4f8684f3489dd9a9ec627ad8b599f5",
    "repo": "tensorflow/tensorflow",
    "commit_url": "https://github.com/tensorflow/tensorflow/commit/c57c0b9f3a4f8684f3489dd9a9ec627ad8b599f5",
    "files": [
      "tensorflow/core/kernels/count_ops.cc"
    ],
    "message": "Fix the segfault in `tf.raw_ops.SparseCountSparseOutput`.\n\nPiperOrigin-RevId: 369264941\nChange-Id: I23a96a15b8370c01ee21ba3841e1c7dcbf55e93d",
    "before_after_code_files": [
      "tensorflow/core/kernels/count_ops.cc||tensorflow/core/kernels/count_ops.cc"
    ]
  },
  "patch_diff": {
    "tensorflow/core/kernels/count_ops.cc||tensorflow/core/kernels/count_ops.cc": [
      "File: tensorflow/core/kernels/count_ops.cc -> tensorflow/core/kernels/count_ops.cc",
      "--- Hunk 1 ---",
      "[Context before]",
      "197:                     \"The shape argument requires at least one element.\"));",
      "199:     bool is_1d = shape.NumElements() == 1;",
      "201:     int num_values = values.NumElements();",
      "203:     OP_REQUIRES(context, num_values == indices.shape().dim_size(0),",
      "204:                 errors::InvalidArgument(",
      "205:                     \"Number of values must match first dimension of indices.\",",
      "",
      "[Removed Lines]",
      "200:     int num_batches = is_1d ? 1 : shape.flat<int64>()(0);",
      "",
      "[Added Lines]",
      "200:     auto shape_vector = shape.flat<int64>();",
      "201:     int num_batches = is_1d ? 1 : shape_vector(0);",
      "204:     for (int b = 0; b < shape_vector.size(); b++) {",
      "205:       OP_REQUIRES(context, shape_vector(b) >= 0,",
      "206:                   errors::InvalidArgument(",
      "207:                       \"Elements in dense_shape must be >= 0. Instead got:\",",
      "208:                       shape.DebugString()));",
      "209:     }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "83b0c2a225869f61cd420abdb044588bcd2f6696",
      "candidate_info": {
        "commit_hash": "83b0c2a225869f61cd420abdb044588bcd2f6696",
        "repo": "tensorflow/tensorflow",
        "commit_url": "https://github.com/tensorflow/tensorflow/commit/83b0c2a225869f61cd420abdb044588bcd2f6696",
        "files": [
          "tensorflow/core/api_def/base_api/api_def_DenseCountSparseOutput.pbtxt",
          "tensorflow/core/api_def/base_api/api_def_RaggedCountSparseOutput.pbtxt",
          "tensorflow/core/api_def/base_api/api_def_SparseCountSparseOutput.pbtxt",
          "tensorflow/core/kernels/count_ops.cc",
          "tensorflow/core/ops/count_ops.cc",
          "tensorflow/python/ops/bincount.py",
          "tensorflow/python/ops/bincount_test.py",
          "tensorflow/tools/api/golden/v1/tensorflow.raw_ops.pbtxt",
          "tensorflow/tools/api/golden/v1/tensorflow.sparse.pbtxt",
          "tensorflow/tools/api/golden/v2/tensorflow.raw_ops.pbtxt",
          "tensorflow/tools/api/golden/v2/tensorflow.sparse.pbtxt"
        ],
        "message": "Automated g4 rollback of changelist 311477582.\n\nPiperOrigin-RevId: 311538137\nChange-Id: Id9c4f986f0c5a6408ea60147917fb72977b83efe",
        "before_after_code_files": [
          "tensorflow/core/api_def/base_api/api_def_DenseCountSparseOutput.pbtxt||tensorflow/core/api_def/base_api/api_def_DenseCountSparseOutput.pbtxt",
          "tensorflow/core/api_def/base_api/api_def_RaggedCountSparseOutput.pbtxt||tensorflow/core/api_def/base_api/api_def_RaggedCountSparseOutput.pbtxt",
          "tensorflow/core/api_def/base_api/api_def_SparseCountSparseOutput.pbtxt||tensorflow/core/api_def/base_api/api_def_SparseCountSparseOutput.pbtxt",
          "tensorflow/core/kernels/count_ops.cc||tensorflow/core/kernels/count_ops.cc",
          "tensorflow/core/ops/count_ops.cc||tensorflow/core/ops/count_ops.cc",
          "tensorflow/python/ops/bincount.py||tensorflow/python/ops/bincount.py",
          "tensorflow/python/ops/bincount_test.py||tensorflow/python/ops/bincount_test.py",
          "tensorflow/tools/api/golden/v1/tensorflow.raw_ops.pbtxt||tensorflow/tools/api/golden/v1/tensorflow.raw_ops.pbtxt",
          "tensorflow/tools/api/golden/v1/tensorflow.sparse.pbtxt||tensorflow/tools/api/golden/v1/tensorflow.sparse.pbtxt",
          "tensorflow/tools/api/golden/v2/tensorflow.raw_ops.pbtxt||tensorflow/tools/api/golden/v2/tensorflow.raw_ops.pbtxt",
          "tensorflow/tools/api/golden/v2/tensorflow.sparse.pbtxt||tensorflow/tools/api/golden/v2/tensorflow.sparse.pbtxt"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "tensorflow/core/kernels/count_ops.cc||tensorflow/core/kernels/count_ops.cc"
          ],
          "candidate": [
            "tensorflow/core/kernels/count_ops.cc||tensorflow/core/kernels/count_ops.cc"
          ]
        }
      },
      "candidate_diff": {
        "tensorflow/core/api_def/base_api/api_def_DenseCountSparseOutput.pbtxt||tensorflow/core/api_def/base_api/api_def_DenseCountSparseOutput.pbtxt": [
          "File: tensorflow/core/api_def/base_api/api_def_DenseCountSparseOutput.pbtxt -> tensorflow/core/api_def/base_api/api_def_DenseCountSparseOutput.pbtxt",
          "--- Hunk 1 ---",
          "[Context before]",
          "4:   in_arg {",
          "5:     name: \"values\"",
          "6:     description: <<END",
          "8: END",
          "9:   }",
          "10:   in_arg {",
          "11:     name: \"weights\"",
          "12:     description: <<END",
          "14: END",
          "15:   }",
          "16:   out_arg {",
          "17:     name: \"output_indices\"",
          "18:     description: <<END",
          "20: END",
          "21:   }",
          "22:   out_arg {",
          "23:     name: \"output_values\"",
          "24:     description: <<END",
          "26: END",
          "27:   }",
          "28:   out_arg {",
          "29:     name: \"output_dense_shape\"",
          "30:     description: <<END",
          "32: END",
          "33:   }",
          "34:   attr {",
          "35:     name: \"T\"",
          "36:     description: <<END",
          "38: END",
          "39:   }",
          "40:   attr {",
          "41:     name: \"minlength\"",
          "42:     description: <<END",
          "44: END",
          "45:   }",
          "46:   attr {",
          "47:     name: \"maxlength\"",
          "48:     description: <<END",
          "50: END",
          "51:   }",
          "52:   attr {",
          "54:     description: <<END",
          "56: END",
          "57:   }",
          "58:   attr {",
          "59:     name: \"output_type\"",
          "60:     description: <<END",
          "62: END",
          "63:   }",
          "64:   summary: \"Performs sparse-output bin counting for a tf.tensor input.\"",
          "",
          "[Removed Lines]",
          "7: int32 or int64; Tensor containing data to count.",
          "13: float32; Optional rank 1 Tensor (shape=[max_values]) with weights for each count value.",
          "19: int64; indices tensor for the resulting sparse tensor object.",
          "25: int64 or float32; values tensor for the resulting sparse tensor object.",
          "31: int64; shape tensor for the resulting sparse tensor object.",
          "37: dtype; dtype of the input values tensor.",
          "43: int32; minimum value to count. Can be set to -1 for no minimum.",
          "49: int32; maximum value to count. Can be set to -1 for no maximum.",
          "53:     name: \"binary_count\"",
          "55: bool; whether to output the number of occurrences of each value or 1.",
          "61: dtype; dtype of the output values tensor.",
          "",
          "[Added Lines]",
          "7: Tensor containing data to count.",
          "13: A Tensor of the same shape as indices containing per-index weight values. May",
          "14: also be the empty tensor if no weights are used.",
          "20: Indices tensor for the resulting sparse tensor object.",
          "26: Values tensor for the resulting sparse tensor object.",
          "32: Shape tensor for the resulting sparse tensor object.",
          "38: Dtype of the input values tensor.",
          "44: Minimum value to count. Can be set to -1 for no minimum.",
          "50: Maximum value to count. Can be set to -1 for no maximum.",
          "54:     name: \"binary_output\"",
          "56: Whether to output the number of occurrences of each value or 1.",
          "62: Dtype of the output values tensor.",
          "",
          "---------------"
        ],
        "tensorflow/core/api_def/base_api/api_def_RaggedCountSparseOutput.pbtxt||tensorflow/core/api_def/base_api/api_def_RaggedCountSparseOutput.pbtxt": [
          "File: tensorflow/core/api_def/base_api/api_def_RaggedCountSparseOutput.pbtxt -> tensorflow/core/api_def/base_api/api_def_RaggedCountSparseOutput.pbtxt",
          "--- Hunk 1 ---",
          "[Context before]",
          "4:   in_arg {",
          "5:     name: \"splits\"",
          "6:     description: <<END",
          "8: END",
          "9:   }",
          "10: in_arg {",
          "11:     name: \"values\"",
          "12:     description: <<END",
          "14: END",
          "15:   }",
          "16:   in_arg {",
          "17:     name: \"weights\"",
          "18:     description: <<END",
          "20: END",
          "21:   }",
          "22:   out_arg {",
          "23:     name: \"output_indices\"",
          "24:     description: <<END",
          "26: END",
          "27:   }",
          "28:   out_arg {",
          "29:     name: \"output_values\"",
          "30:     description: <<END",
          "33:   }",
          "34:   out_arg {",
          "35:     name: \"output_dense_shape\"",
          "36:     description: <<END",
          "38:   END",
          "39:   }",
          "40:   attr {",
          "41:     name: \"T\"",
          "42:     description: <<END",
          "44: END",
          "45:   }",
          "46:   attr {",
          "47:     name: \"minlength\"",
          "48:     description: <<END",
          "50: END",
          "51:   }",
          "52:   attr {",
          "53:     name: \"maxlength\"",
          "54:     description: <<END",
          "56: END",
          "57:   }",
          "58:   attr {",
          "60:     description: <<END",
          "62: END",
          "63:   }",
          "64:   attr {",
          "65:     name: \"output_type\"",
          "66:     description: <<END",
          "68: END",
          "69:   }",
          "70:   summary: \"Performs sparse-output bin counting for a ragged tensor input.\"",
          "",
          "[Removed Lines]",
          "7: int64; Tensor containing the row splits of the ragged tensor to count.",
          "13: int32 or int64; Tensor containing values of the sparse tensor to count.",
          "19: float32; Optional rank 1 Tensor (shape=[max_values]) with weights for each count value.",
          "25: int64; indices tensor for the resulting sparse tensor object.",
          "31: int64 or float32; values tensor for the resulting sparse tensor object.",
          "32:   END",
          "37: int64; shape tensor for the resulting sparse tensor object.",
          "43: dtype; dtype of the input values tensor.",
          "49: int32; minimum value to count. Can be set to -1 for no minimum.",
          "55: int32; maximum value to count. Can be set to -1 for no maximum.",
          "59:     name: \"binary_count\"",
          "61: bool; whether to output the number of occurrences of each value or 1.",
          "67: dtype; dtype of the output values tensor.",
          "",
          "[Added Lines]",
          "7: Tensor containing the row splits of the ragged tensor to count.",
          "13: Tensor containing values of the sparse tensor to count.",
          "19: A Tensor of the same shape as indices containing per-index weight values.",
          "20: May also be the empty tensor if no weights are used.",
          "26: Indices tensor for the resulting sparse tensor object.",
          "32: Values tensor for the resulting sparse tensor object.",
          "33: END",
          "38: Shape tensor for the resulting sparse tensor object.",
          "44: Dtype of the input values tensor.",
          "50: Minimum value to count. Can be set to -1 for no minimum.",
          "56: Maximum value to count. Can be set to -1 for no maximum.",
          "60:     name: \"binary_output\"",
          "62: Whether to output the number of occurrences of each value or 1.",
          "68: Dtype of the output values tensor.",
          "",
          "---------------"
        ],
        "tensorflow/core/api_def/base_api/api_def_SparseCountSparseOutput.pbtxt||tensorflow/core/api_def/base_api/api_def_SparseCountSparseOutput.pbtxt": [
          "File: tensorflow/core/api_def/base_api/api_def_SparseCountSparseOutput.pbtxt -> tensorflow/core/api_def/base_api/api_def_SparseCountSparseOutput.pbtxt",
          "--- Hunk 1 ---",
          "[Context before]",
          "4:   in_arg {",
          "5:     name: \"indices\"",
          "6:     description: <<END",
          "8: END",
          "9:   }",
          "10: in_arg {",
          "11:     name: \"values\"",
          "12:     description: <<END",
          "14: END",
          "15:   }",
          "16: in_arg {",
          "17:     name: \"dense_shape\"",
          "18:     description: <<END",
          "20: END",
          "21:   }",
          "23:     name: \"weights\"",
          "24:     description: <<END",
          "26: END",
          "27:   }",
          "28:   out_arg {",
          "29:     name: \"output_indices\"",
          "30:     description: <<END",
          "32: END",
          "33:   }",
          "34:   out_arg {",
          "35:       name: \"output_values\"",
          "36:       description: <<END",
          "38: END",
          "39:   }",
          "40:   out_arg {",
          "41:       name: \"output_dense_shape\"",
          "42:       description: <<END",
          "44: END",
          "45:   }",
          "46:   attr {",
          "47:     name: \"T\"",
          "48:     description: <<END",
          "50: END",
          "51:   }",
          "52:   attr {",
          "53:     name: \"minlength\"",
          "54:     description: <<END",
          "56: END",
          "57:   }",
          "58:   attr {",
          "59:     name: \"maxlength\"",
          "60:     description: <<END",
          "62: END",
          "63:   }",
          "64:   attr {",
          "66:     description: <<END",
          "68: END",
          "69:   }",
          "70:   attr {",
          "71:     name: \"output_type\"",
          "72:     description: <<END",
          "74: END",
          "75:   }",
          "76:   summary: \"Performs sparse-output bin counting for a sparse tensor input.\"",
          "",
          "[Removed Lines]",
          "7: int64; Tensor containing the indices of the sparse tensor to count.",
          "13: int32 or int64; Tensor containing values of the sparse tensor to count.",
          "19: int64; Tensor containing the dense shape of the sparse tensor to count.",
          "22:   in_arg {",
          "25: float32; Optional rank 1 Tensor (shape=[max_values]) with weights for each count value.",
          "31: int64; indices tensor for the resulting sparse tensor object.",
          "37: int64 or float32; values tensor for the resulting sparse tensor object.",
          "43: int64; shape tensor for the resulting sparse tensor object.",
          "49: dtype; dtype of the input values tensor.",
          "55: int32; minimum value to count. Can be set to -1 for no minimum.",
          "61: int32; maximum value to count. Can be set to -1 for no maximum.",
          "65:     name: \"binary_count\"",
          "67: bool; whether to output the number of occurrences of each value or 1.",
          "73: dtype; dtype of the output values tensor.",
          "",
          "[Added Lines]",
          "7: Tensor containing the indices of the sparse tensor to count.",
          "13: Tensor containing values of the sparse tensor to count.",
          "19: Tensor containing the dense shape of the sparse tensor to count.",
          "22:  in_arg {",
          "25: A Tensor of the same shape as indices containing per-index weight values.",
          "26: May also be the empty tensor if no weights are used.",
          "32: Indices tensor for the resulting sparse tensor object.",
          "38: Values tensor for the resulting sparse tensor object.",
          "44: Shape tensor for the resulting sparse tensor object.",
          "50: Dtype of the input values tensor.",
          "56: Minimum value to count. Can be set to -1 for no minimum.",
          "62: Maximum value to count. Can be set to -1 for no maximum.",
          "66:     name: \"binary_output\"",
          "68: Whether to output the number of occurrences of each value or 1.",
          "74: Dtype of the output values tensor.",
          "",
          "---------------"
        ],
        "tensorflow/core/kernels/count_ops.cc||tensorflow/core/kernels/count_ops.cc": [
          "File: tensorflow/core/kernels/count_ops.cc -> tensorflow/core/kernels/count_ops.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "16: #include \"absl/container/flat_hash_map.h\"",
          "17: #include \"tensorflow/core/framework/op_kernel.h\"",
          "18: #include \"tensorflow/core/framework/op_requires.h\"",
          "19: #include \"tensorflow/core/framework/tensor.h\"",
          "20: #include \"tensorflow/core/platform/errors.h\"",
          "21: #include \"tensorflow/core/platform/types.h\"",
          "23: namespace tensorflow {",
          "27: namespace {",
          "30:                     bool is_1d, OpKernelContext* context) {",
          "31:   int total_values = 0;",
          "32:   int num_batches = per_batch_counts.size();",
          "",
          "[Removed Lines]",
          "25: using BatchedIntMap = std::vector<absl::flat_hash_map<int64, int64>>;",
          "29: Status OutputSparse(const BatchedIntMap& per_batch_counts, int num_values,",
          "",
          "[Added Lines]",
          "19: #include \"tensorflow/core/framework/register_types.h\"",
          "26: template <class T>",
          "27: using BatchedMap = std::vector<absl::flat_hash_map<int64, T>>;",
          "31: template <class T>",
          "32: Status OutputSparse(const BatchedMap<T>& per_batch_counts, int num_values,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "44:       context->allocate_output(1, TensorShape({total_values}), &values));",
          "46:   auto output_indices = indices->matrix<int64>();",
          "48:   int64 value_loc = 0;",
          "49:   for (int b = 0; b < num_batches; ++b) {",
          "50:     const auto& per_batch_count = per_batch_counts[b];",
          "53:     std::sort(pairs.begin(), pairs.end());",
          "54:     for (const auto& x : pairs) {",
          "55:       if (is_1d) {",
          "",
          "[Removed Lines]",
          "47:   auto output_values = values->flat<int64>();",
          "51:     std::vector<std::pair<int, int>> pairs(per_batch_count.begin(),",
          "52:                                            per_batch_count.end());",
          "",
          "[Added Lines]",
          "50:   auto output_values = values->flat<T>();",
          "54:     std::vector<std::pair<int, T>> pairs(per_batch_count.begin(),",
          "55:                                          per_batch_count.end());",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "77:   return Status::OK();",
          "78: }",
          "147:   return max_length > 0 ? max_length : std::max((max_seen + 1), min_length);",
          "148: }",
          "150: }  // namespace",
          "153: class DenseCount : public OpKernel {",
          "154:  public:",
          "155:   explicit DenseCount(OpKernelConstruction* context) : OpKernel(context) {",
          "156:     OP_REQUIRES_OK(context, context->GetAttr(\"minlength\", &minlength_));",
          "157:     OP_REQUIRES_OK(context, context->GetAttr(\"maxlength\", &maxlength_));",
          "159:   }",
          "161:   void Compute(OpKernelContext* context) override {",
          "",
          "[Removed Lines]",
          "80: Status OutputWeightedSparse(const BatchedIntMap& per_batch_counts,",
          "81:                             int num_values, const Tensor& weights, bool is_1d,",
          "82:                             OpKernelContext* context) {",
          "83:   if (!TensorShapeUtils::IsVector(weights.shape())) {",
          "84:     return errors::InvalidArgument(",
          "85:         \"Weights must be a 1-dimensional tensor. Got: \",",
          "86:         weights.shape().DebugString());",
          "87:   }",
          "89:   if (num_values > weights.dim_size(0)) {",
          "90:     return errors::InvalidArgument(\"The maximum array value was \", num_values,",
          "91:                                    \", but the weight array has size \",",
          "92:                                    weights.shape().DebugString());",
          "93:   }",
          "94:   auto weight_values = weights.flat<float>();",
          "96:   int total_values = 0;",
          "97:   int num_batches = per_batch_counts.size();",
          "98:   for (const auto& per_batch_count : per_batch_counts) {",
          "99:     total_values += per_batch_count.size();",
          "100:   }",
          "102:   Tensor* indices;",
          "103:   int inner_dim = is_1d ? 1 : 2;",
          "104:   TF_RETURN_IF_ERROR(context->allocate_output(",
          "105:       0, TensorShape({total_values, inner_dim}), &indices));",
          "107:   Tensor* values;",
          "108:   TF_RETURN_IF_ERROR(",
          "109:       context->allocate_output(1, TensorShape({total_values}), &values));",
          "111:   auto output_indices = indices->matrix<int64>();",
          "112:   auto output_values = values->flat<float>();",
          "113:   int64 value_loc = 0;",
          "114:   for (int b = 0; b < num_batches; ++b) {",
          "115:     const auto& per_batch_count = per_batch_counts[b];",
          "116:     std::vector<std::pair<int, int>> pairs(per_batch_count.begin(),",
          "117:                                            per_batch_count.end());",
          "118:     std::sort(pairs.begin(), pairs.end());",
          "119:     for (const auto& x : pairs) {",
          "120:       if (is_1d) {",
          "121:         output_indices(value_loc, 0) = x.first;",
          "122:       } else {",
          "123:         output_indices(value_loc, 0) = b;",
          "124:         output_indices(value_loc, 1) = x.first;",
          "125:       }",
          "126:       output_values(value_loc) = x.second * weight_values(x.first);",
          "127:       ++value_loc;",
          "128:     }",
          "129:   }",
          "131:   Tensor* dense_shape;",
          "132:   if (is_1d) {",
          "133:     TF_RETURN_IF_ERROR(",
          "134:         context->allocate_output(2, TensorShape({1}), &dense_shape));",
          "135:     dense_shape->flat<int64>().data()[0] = num_values;",
          "136:   } else {",
          "137:     TF_RETURN_IF_ERROR(",
          "138:         context->allocate_output(2, TensorShape({2}), &dense_shape));",
          "139:     dense_shape->flat<int64>().data()[0] = num_batches;",
          "140:     dense_shape->flat<int64>().data()[1] = num_values;",
          "141:   }",
          "142:   return Status::OK();",
          "143: }",
          "145: template <class T>",
          "146: T GetOutputSize(T max_seen, T max_length, T min_length) {",
          "152: template <class T>",
          "158:     OP_REQUIRES_OK(context, context->GetAttr(\"binary_count\", &binary_count_));",
          "",
          "[Added Lines]",
          "83: int GetOutputSize(int max_seen, int max_length, int min_length) {",
          "89: template <class T, class W>",
          "95:     OP_REQUIRES_OK(context, context->GetAttr(\"binary_output\", &binary_output_));",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "170:                     \"Input must be a 1 or 2-dimensional tensor. Got: \",",
          "171:                     data.shape().DebugString()));",
          "173:     bool is_1d = TensorShapeUtils::IsVector(data.shape());",
          "174:     int negative_valued_axis = -1;",
          "175:     int num_batch_dimensions = (data.shape().dims() + negative_valued_axis);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "110:     if (use_weights) {",
          "111:       OP_REQUIRES(",
          "112:           context, weights.shape() == data.shape(),",
          "113:           errors::InvalidArgument(",
          "114:               \"Weights and data must have the same shape. Weight shape: \",",
          "115:               weights.shape().DebugString(),",
          "116:               \"; data shape: \", data.shape().DebugString()));",
          "117:     }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "179:       num_batch_elements *= data.shape().dim_size(i);",
          "180:     }",
          "181:     int num_value_elements = data.shape().num_elements() / num_batch_elements;",
          "183:     T max_value = 0;",
          "185:     const auto data_values = data.flat<T>();",
          "186:     int i = 0;",
          "187:     for (int b = 0; b < num_batch_elements; ++b) {",
          "188:       for (int v = 0; v < num_value_elements; ++v) {",
          "189:         const auto& value = data_values(i);",
          "190:         if (value >= 0 && (maxlength_ <= 0 || value < maxlength_)) {",
          "193:           } else {",
          "195:           }",
          "196:           if (value > max_value) {",
          "197:             max_value = value;",
          "",
          "[Removed Lines]",
          "182:     auto per_batch_counts = BatchedIntMap(num_batch_elements);",
          "191:           if (binary_count_) {",
          "192:             (per_batch_counts[b])[value] = 1;",
          "194:             (per_batch_counts[b])[value]++;",
          "",
          "[Added Lines]",
          "128:     auto per_batch_counts = BatchedMap<W>(num_batch_elements);",
          "133:     const auto weight_values = weights.flat<W>();",
          "139:           if (binary_output_) {",
          "140:             per_batch_counts[b][value] = 1;",
          "141:           } else if (use_weights) {",
          "142:             per_batch_counts[b][value] += weight_values(i);",
          "144:             per_batch_counts[b][value]++;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "201:       }",
          "202:     }",
          "213:   }",
          "215:  private:",
          "219: };",
          "222: class SparseCount : public OpKernel {",
          "223:  public:",
          "224:   explicit SparseCount(OpKernelConstruction* context) : OpKernel(context) {",
          "225:     OP_REQUIRES_OK(context, context->GetAttr(\"minlength\", &minlength_));",
          "226:     OP_REQUIRES_OK(context, context->GetAttr(\"maxlength\", &maxlength_));",
          "228:   }",
          "230:   void Compute(OpKernelContext* context) override {",
          "",
          "[Removed Lines]",
          "204:     T num_output_values = GetOutputSize<T>(max_value, maxlength_, minlength_);",
          "205:     if (use_weights) {",
          "206:       OP_REQUIRES_OK(context,",
          "207:                      OutputWeightedSparse(per_batch_counts, num_output_values,",
          "208:                                           weights, is_1d, context));",
          "209:     } else {",
          "210:       OP_REQUIRES_OK(context, OutputSparse(per_batch_counts, num_output_values,",
          "211:                                            is_1d, context));",
          "212:     }",
          "216:   T minlength_;",
          "217:   T maxlength_;",
          "218:   bool binary_count_;",
          "221: template <class T>",
          "227:     OP_REQUIRES_OK(context, context->GetAttr(\"binary_count\", &binary_count_));",
          "",
          "[Added Lines]",
          "154:     int num_output_values = GetOutputSize(max_value, maxlength_, minlength_);",
          "155:     OP_REQUIRES_OK(context, OutputSparse<W>(per_batch_counts, num_output_values,",
          "156:                                             is_1d, context));",
          "160:   int maxlength_;",
          "161:   int minlength_;",
          "162:   bool binary_output_;",
          "165: template <class T, class W>",
          "171:     OP_REQUIRES_OK(context, context->GetAttr(\"binary_output\", &binary_output_));",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "235:     bool use_weights = weights.NumElements() > 0;",
          "237:     bool is_1d = shape.NumElements() == 1;",
          "238:     const auto indices_values = indices.matrix<int64>();",
          "239:     const auto values_values = values.flat<T>();",
          "245:     T max_value = 0;",
          "247:     for (int idx = 0; idx < num_values; ++idx) {",
          "248:       int batch = is_1d ? 0 : indices_values(idx, 0);",
          "249:       const auto& value = values_values(idx);",
          "250:       if (value >= 0 && (maxlength_ <= 0 || value < maxlength_)) {",
          "253:         } else {",
          "255:         }",
          "256:         if (value > max_value) {",
          "257:           max_value = value;",
          "",
          "[Removed Lines]",
          "241:     int num_batches = is_1d ? 1 : shape.flat<int64>()(0);",
          "242:     int num_values = values.NumElements();",
          "244:     auto per_batch_counts = BatchedIntMap(num_batches);",
          "251:         if (binary_count_) {",
          "252:           (per_batch_counts[batch])[value] = 1;",
          "254:           (per_batch_counts[batch])[value]++;",
          "",
          "[Added Lines]",
          "182:     int num_batches = is_1d ? 1 : shape.flat<int64>()(0);",
          "183:     int num_values = values.NumElements();",
          "187:     const auto weight_values = weights.flat<W>();",
          "189:     auto per_batch_counts = BatchedMap<W>(num_batches);",
          "197:         if (binary_output_) {",
          "198:           per_batch_counts[batch][value] = 1;",
          "199:         } else if (use_weights) {",
          "200:           per_batch_counts[batch][value] += weight_values(idx);",
          "202:           per_batch_counts[batch][value]++;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "259:       }",
          "260:     }",
          "271:   }",
          "273:  private:",
          "277: };",
          "280: class RaggedCount : public OpKernel {",
          "281:  public:",
          "282:   explicit RaggedCount(OpKernelConstruction* context) : OpKernel(context) {",
          "283:     OP_REQUIRES_OK(context, context->GetAttr(\"minlength\", &minlength_));",
          "284:     OP_REQUIRES_OK(context, context->GetAttr(\"maxlength\", &maxlength_));",
          "286:   }",
          "288:   void Compute(OpKernelContext* context) override {",
          "",
          "[Removed Lines]",
          "262:     T num_output_values = GetOutputSize<T>(max_value, maxlength_, minlength_);",
          "263:     if (use_weights) {",
          "264:       OP_REQUIRES_OK(context,",
          "265:                      OutputWeightedSparse(per_batch_counts, num_output_values,",
          "266:                                           weights, is_1d, context));",
          "267:     } else {",
          "268:       OP_REQUIRES_OK(context, OutputSparse(per_batch_counts, num_output_values,",
          "269:                                            is_1d, context));",
          "270:     }",
          "274:   T minlength_;",
          "275:   T maxlength_;",
          "276:   bool binary_count_;",
          "279: template <class T>",
          "285:     OP_REQUIRES_OK(context, context->GetAttr(\"binary_count\", &binary_count_));",
          "",
          "[Added Lines]",
          "210:     int num_output_values = GetOutputSize(max_value, maxlength_, minlength_);",
          "211:     OP_REQUIRES_OK(context, OutputSparse<W>(per_batch_counts, num_output_values,",
          "212:                                             is_1d, context));",
          "216:   int maxlength_;",
          "217:   int minlength_;",
          "218:   bool binary_output_;",
          "219:   bool validate_;",
          "222: template <class T, class W>",
          "228:     OP_REQUIRES_OK(context, context->GetAttr(\"binary_output\", &binary_output_));",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "290:     const Tensor& values = context->input(1);",
          "291:     const Tensor& weights = context->input(2);",
          "292:     bool use_weights = weights.NumElements() > 0;",
          "294:     const auto splits_values = splits.flat<int64>();",
          "295:     const auto values_values = values.flat<T>();",
          "296:     int num_batches = splits.NumElements() - 1;",
          "297:     int num_values = values.NumElements();",
          "300:     T max_value = 0;",
          "301:     int batch_idx = 0;",
          "",
          "[Removed Lines]",
          "299:     auto per_batch_counts = BatchedIntMap(num_batches);",
          "",
          "[Added Lines]",
          "236:     bool is_1d = false;",
          "240:     const auto weight_values = weights.flat<W>();",
          "244:     auto per_batch_counts = BatchedMap<W>(num_batches);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "306:       }",
          "307:       const auto& value = values_values(idx);",
          "308:       if (value >= 0 && (maxlength_ <= 0 || value < maxlength_)) {",
          "311:         } else {",
          "313:         }",
          "314:         if (value > max_value) {",
          "315:           max_value = value;",
          "",
          "[Removed Lines]",
          "309:         if (binary_count_) {",
          "310:           (per_batch_counts[batch_idx - 1])[value] = 1;",
          "312:           (per_batch_counts[batch_idx - 1])[value]++;",
          "",
          "[Added Lines]",
          "254:         if (binary_output_) {",
          "255:           per_batch_counts[batch_idx - 1][value] = 1;",
          "256:         } else if (use_weights) {",
          "257:           per_batch_counts[batch_idx - 1][value] += weight_values(idx);",
          "259:           per_batch_counts[batch_idx - 1][value]++;",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "317:       }",
          "318:     }",
          "329:   }",
          "331:  private:",
          "335: };",
          "356: #undef REGISTER",
          "358: }  // namespace tensorflow",
          "",
          "[Removed Lines]",
          "320:     T num_output_values = GetOutputSize<T>(max_value, maxlength_, minlength_);",
          "321:     if (use_weights) {",
          "322:       OP_REQUIRES_OK(context,",
          "323:                      OutputWeightedSparse(per_batch_counts, num_output_values,",
          "324:                                           weights, false, context));",
          "325:     } else {",
          "326:       OP_REQUIRES_OK(context, OutputSparse(per_batch_counts, num_output_values,",
          "327:                                            false, context));",
          "328:     }",
          "332:   T minlength_;",
          "333:   T maxlength_;",
          "334:   bool binary_count_;",
          "337: #define REGISTER(TYPE)                                    \\",
          "338:                                                           \\",
          "339:   REGISTER_KERNEL_BUILDER(Name(\"DenseCountSparseOutput\")  \\",
          "340:                               .TypeConstraint<TYPE>(\"T\")  \\",
          "341:                               .Device(DEVICE_CPU),        \\",
          "342:                           DenseCount<TYPE>)               \\",
          "343:                                                           \\",
          "344:   REGISTER_KERNEL_BUILDER(Name(\"SparseCountSparseOutput\") \\",
          "345:                               .TypeConstraint<TYPE>(\"T\")  \\",
          "346:                               .Device(DEVICE_CPU),        \\",
          "347:                           SparseCount<TYPE>)              \\",
          "348:                                                           \\",
          "349:   REGISTER_KERNEL_BUILDER(Name(\"RaggedCountSparseOutput\") \\",
          "350:                               .TypeConstraint<TYPE>(\"T\")  \\",
          "351:                               .Device(DEVICE_CPU),        \\",
          "352:                           RaggedCount<TYPE>)",
          "354: REGISTER(int32);",
          "355: REGISTER(int64);",
          "",
          "[Added Lines]",
          "267:     int num_output_values = GetOutputSize(max_value, maxlength_, minlength_);",
          "268:     OP_REQUIRES_OK(context, OutputSparse<W>(per_batch_counts, num_output_values,",
          "269:                                             is_1d, context));",
          "273:   int maxlength_;",
          "274:   int minlength_;",
          "275:   bool binary_output_;",
          "276:   bool validate_;",
          "279: #define REGISTER_W(W_TYPE) \\",
          "280:   REGISTER(int32, W_TYPE)  \\",
          "281:   REGISTER(int64, W_TYPE)",
          "283: #define REGISTER(I_TYPE, W_TYPE)                                     \\",
          "284:                                                                      \\",
          "285:   REGISTER_KERNEL_BUILDER(Name(\"DenseCountSparseOutput\")             \\",
          "286:                               .TypeConstraint<I_TYPE>(\"T\")           \\",
          "287:                               .TypeConstraint<W_TYPE>(\"output_type\") \\",
          "288:                               .Device(DEVICE_CPU),                   \\",
          "289:                           DenseCount<I_TYPE, W_TYPE>)                \\",
          "290:                                                                      \\",
          "291:   REGISTER_KERNEL_BUILDER(Name(\"SparseCountSparseOutput\")            \\",
          "292:                               .TypeConstraint<I_TYPE>(\"T\")           \\",
          "293:                               .TypeConstraint<W_TYPE>(\"output_type\") \\",
          "294:                               .Device(DEVICE_CPU),                   \\",
          "295:                           SparseCount<I_TYPE, W_TYPE>)               \\",
          "296:                                                                      \\",
          "297:   REGISTER_KERNEL_BUILDER(Name(\"RaggedCountSparseOutput\")            \\",
          "298:                               .TypeConstraint<I_TYPE>(\"T\")           \\",
          "299:                               .TypeConstraint<W_TYPE>(\"output_type\") \\",
          "300:                               .Device(DEVICE_CPU),                   \\",
          "301:                           RaggedCount<I_TYPE, W_TYPE>)",
          "303: TF_CALL_INTEGRAL_TYPES(REGISTER_W);",
          "304: TF_CALL_float(REGISTER_W);",
          "305: TF_CALL_double(REGISTER_W);",
          "307: #undef REGISTER_W",
          "",
          "---------------"
        ],
        "tensorflow/core/ops/count_ops.cc||tensorflow/core/ops/count_ops.cc": [
          "File: tensorflow/core/ops/count_ops.cc -> tensorflow/core/ops/count_ops.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "20: namespace tensorflow {",
          "23: using shape_inference::InferenceContext;",
          "25: Status DenseCountSparseOutputShapeFn(InferenceContext *c) {",
          "28:   c->set_output(0, c->Matrix(nvals, rank));  // out.indices",
          "29:   c->set_output(1, c->Vector(nvals));        // out.values",
          "30:   c->set_output(2, c->Vector(rank));         // out.dense_shape",
          "",
          "[Removed Lines]",
          "22: using shape_inference::DimensionHandle;",
          "26:   int32 rank = c->Rank(c->input(0));",
          "27:   DimensionHandle nvals = c->UnknownDim();",
          "",
          "[Added Lines]",
          "23: using shape_inference::ShapeHandle;",
          "26:   auto values = c->input(0);",
          "27:   auto weights = c->input(1);",
          "28:   ShapeHandle output;",
          "29:   auto num_weights = c->NumElements(weights);",
          "30:   if (c->ValueKnown(num_weights) && c->Value(num_weights) == 0) {",
          "31:     output = values;",
          "32:   } else {",
          "33:     TF_RETURN_IF_ERROR(c->Merge(weights, values, &output));",
          "34:   }",
          "35:   auto rank = c->Rank(output);",
          "36:   auto nvals = c->UnknownDim();",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "32: }",
          "34: Status SparseCountSparseOutputShapeFn(InferenceContext *c) {",
          "37:   c->set_output(0, c->Matrix(nvals, rank));  // out.indices",
          "38:   c->set_output(1, c->Vector(nvals));        // out.values",
          "39:   c->set_output(2, c->Vector(rank));         // out.dense_shape",
          "",
          "[Removed Lines]",
          "35:   DimensionHandle rank = c->Dim(c->input(0), 1);",
          "36:   DimensionHandle nvals = c->UnknownDim();",
          "",
          "[Added Lines]",
          "44:   auto rank = c->Dim(c->input(0), 1);",
          "45:   auto nvals = c->UnknownDim();",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "45:   if (rank != c->kUnknownRank) {",
          "46:     ++rank;  // Add the ragged dimension",
          "47:   }",
          "49:   c->set_output(0, c->Matrix(nvals, rank));  // out.indices",
          "50:   c->set_output(1, c->Vector(nvals));        // out.values",
          "51:   c->set_output(2, c->Vector(rank));         // out.dense_shape",
          "",
          "[Removed Lines]",
          "48:   DimensionHandle nvals = c->UnknownDim();",
          "",
          "[Added Lines]",
          "57:   auto nvals = c->UnknownDim();",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "55: REGISTER_OP(\"DenseCountSparseOutput\")",
          "56:     .Input(\"values: T\")",
          "58:     .Attr(\"T: {int32, int64}\")",
          "59:     .Attr(\"minlength: int >= -1 = -1\")",
          "60:     .Attr(\"maxlength: int >= -1 = -1\")",
          "63:     .SetShapeFn(DenseCountSparseOutputShapeFn)",
          "64:     .Output(\"output_indices: int64\")",
          "65:     .Output(\"output_values: output_type\")",
          "",
          "[Removed Lines]",
          "57:     .Input(\"weights: float\")",
          "61:     .Attr(\"binary_count: bool\")",
          "62:     .Attr(\"output_type: {int64, float}\")",
          "",
          "[Added Lines]",
          "66:     .Input(\"weights: output_type\")",
          "70:     .Attr(\"binary_output: bool\")",
          "71:     .Attr(\"output_type: {int32, int64, float, double}\")",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "69:     .Input(\"indices: int64\")",
          "70:     .Input(\"values: T\")",
          "71:     .Input(\"dense_shape: int64\")",
          "73:     .Attr(\"T: {int32, int64}\")",
          "74:     .Attr(\"minlength: int >= -1 = -1\")",
          "75:     .Attr(\"maxlength: int >= -1 = -1\")",
          "78:     .SetShapeFn(SparseCountSparseOutputShapeFn)",
          "79:     .Output(\"output_indices: int64\")",
          "80:     .Output(\"output_values: output_type\")",
          "",
          "[Removed Lines]",
          "72:     .Input(\"weights: float\")",
          "76:     .Attr(\"binary_count: bool\")",
          "77:     .Attr(\"output_type: {int64, float}\")",
          "",
          "[Added Lines]",
          "81:     .Input(\"weights: output_type\")",
          "85:     .Attr(\"binary_output: bool\")",
          "86:     .Attr(\"output_type: {int32, int64, float, double}\")",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "83: REGISTER_OP(\"RaggedCountSparseOutput\")",
          "84:     .Input(\"splits: int64\")",
          "85:     .Input(\"values: T\")",
          "87:     .Attr(\"T: {int32, int64}\")",
          "88:     .Attr(\"minlength: int >= -1 = -1\")",
          "89:     .Attr(\"maxlength: int >= -1 = -1\")",
          "92:     .SetShapeFn(RaggedCountSparseOutputShapeFn)",
          "93:     .Output(\"output_indices: int64\")",
          "94:     .Output(\"output_values: output_type\")",
          "",
          "[Removed Lines]",
          "86:     .Input(\"weights: float\")",
          "90:     .Attr(\"binary_count: bool\")",
          "91:     .Attr(\"output_type: {int64, float}\")",
          "",
          "[Added Lines]",
          "95:     .Input(\"weights: output_type\")",
          "99:     .Attr(\"binary_output: bool\")",
          "100:     .Attr(\"output_type: {int32, int64, float, double}\")",
          "",
          "---------------"
        ],
        "tensorflow/python/ops/bincount.py||tensorflow/python/ops/bincount.py": [
          "File: tensorflow/python/ops/bincount.py -> tensorflow/python/ops/bincount.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "18: from __future__ import division",
          "19: from __future__ import print_function",
          "22: from tensorflow.python.framework import ops",
          "23: from tensorflow.python.framework import sparse_tensor",
          "24: from tensorflow.python.ops import array_ops",
          "25: from tensorflow.python.ops import gen_count_ops",
          "26: from tensorflow.python.ops.ragged import ragged_tensor",
          "27: from tensorflow.python.util.tf_export import tf_export",
          "",
          "[Removed Lines]",
          "21: from tensorflow.python.framework import dtypes",
          "",
          "[Added Lines]",
          "24: from tensorflow.python.ops import check_ops",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "33:                     axis=0,",
          "34:                     minlength=None,",
          "35:                     maxlength=None,",
          "37:                     name=None):",
          "38:   \"\"\"Count the number of times an integer value appears in a tensor.",
          "",
          "[Removed Lines]",
          "36:                     binary_count=False,",
          "",
          "[Added Lines]",
          "36:                     binary_output=False,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "58:     maxlength: If given, skips `values` that are greater than or equal to",
          "59:       `maxlength`, and ensures that the output has a `dense_shape` of at most",
          "60:       `maxlength` in the inner dimension.",
          "63:     name: A name for this op.",
          "65:   Returns:",
          "",
          "[Removed Lines]",
          "61:     binary_count: Whether to do a binary count. When True, this op will return 1",
          "62:       for any value that exists instead of counting the number of occurrences.",
          "",
          "[Added Lines]",
          "61:     binary_output: If True, this op will output 1 instead of the number of times",
          "62:       a token appears (equivalent to one_hot + reduce_any instead of one_hot +",
          "63:       reduce_add). Defaults to False.",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "78:   SparseTensor) and returns a SparseTensor where the value of (i,j) is the",
          "79:   number of times value j appears in batch i.",
          "82:   >>> output = tf.sparse.bincount(data, axis=-1)",
          "83:   >>> print(output)",
          "84:   SparseTensor(indices=tf.Tensor(",
          "",
          "[Removed Lines]",
          "81:   >>> data = [[10, 20, 30, 20], [11, 101, 11, 10001]]",
          "",
          "[Added Lines]",
          "82:   >>> data = np.array([[10, 20, 30, 20], [11, 101, 11, 10001]], dtype=np.int64)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "102:   dense shape is [2, 500] instead of [2,10002] or [2, 102].",
          "104:   >>> minlength = maxlength = 500",
          "106:   >>> output = tf.sparse.bincount(",
          "107:   ...    data, axis=-1, minlength=minlength, maxlength=maxlength)",
          "108:   >>> print(output)",
          "",
          "[Removed Lines]",
          "105:   >>> data = [[10, 20, 30, 20], [11, 101, 11, 10001]]",
          "",
          "[Added Lines]",
          "106:   >>> data = np.array([[10, 20, 30, 20], [11, 101, 11, 10001]], dtype=np.int64)",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "123:   some values (like 20 in batch 1 and 11 in batch 2) appear more than once,",
          "124:   the 'values' tensor is all 1s.",
          "128:   >>> print(output)",
          "129:   SparseTensor(indices=tf.Tensor(",
          "130:   [[    0    10]",
          "",
          "[Removed Lines]",
          "126:   >>> dense = [[10, 20, 30, 20], [11, 101, 11, 10001]]",
          "127:   >>> output = tf.sparse.bincount(dense, binary_count=True, axis=-1)",
          "",
          "[Added Lines]",
          "127:   >>> data = np.array([[10, 20, 30, 20], [11, 101, 11, 10001]], dtype=np.int64)",
          "128:   >>> output = tf.sparse.bincount(data, binary_output=True, axis=-1)",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "136:    values=tf.Tensor([1 1 1 1 1 1], shape=(6,), dtype=int64),",
          "137:    dense_shape=tf.Tensor([    2 10002], shape=(2,), dtype=int64))",
          "139:   \"\"\"",
          "140:   with ops.name_scope(name, \"count\", [values, weights]):",
          "141:     if not isinstance(values, sparse_tensor.SparseTensor):",
          "142:       values = ragged_tensor.convert_to_tensor_or_ragged_tensor(",
          "143:           values, name=\"values\")",
          "154:     if axis is None:",
          "155:       axis = 0",
          "",
          "[Removed Lines]",
          "145:     if weights is not None and binary_count:",
          "146:       raise ValueError(\"binary_count and weights are mutually exclusive.\")",
          "148:     if weights is None:",
          "149:       weights = []",
          "150:       output_type = dtypes.int64",
          "151:     else:",
          "152:       output_type = dtypes.float32",
          "",
          "[Added Lines]",
          "142:   This example takes two inputs - a values tensor and a weights tensor. These",
          "143:   tensors must be identically shaped, and have the same row splits or indices",
          "144:   in the case of RaggedTensors or SparseTensors. When performing a weighted",
          "145:   count, the op will output a SparseTensor where the value of (i, j) is the",
          "146:   sum of the values in the weight tensor's batch i in the locations where",
          "147:   the values tensor has the value j. In this case, the output dtype is the",
          "148:   same as the dtype of the weights tensor.",
          "150:   >>> data = np.array([[10, 20, 30, 20], [11, 101, 11, 10001]], dtype=np.int64)",
          "151:   >>> weights = [[2, 0.25, 15, 0.5], [2, 17, 3, 0.9]]",
          "152:   >>> output = tf.sparse.bincount(data, weights=weights, axis=-1)",
          "153:   >>> print(output)",
          "154:   SparseTensor(indices=tf.Tensor(",
          "155:   [[    0    10]",
          "156:    [    0    20]",
          "157:    [    0    30]",
          "158:    [    1    11]",
          "159:    [    1   101]",
          "160:    [    1 10001]], shape=(6, 2), dtype=int64),",
          "161:    values=tf.Tensor([2. 0.75 15. 5. 17. 0.9], shape=(6,), dtype=float32),",
          "162:    dense_shape=tf.Tensor([    2 10002], shape=(2,), dtype=int64))",
          "169:     if weights is not None:",
          "170:       if not isinstance(weights, sparse_tensor.SparseTensor):",
          "171:         weights = ragged_tensor.convert_to_tensor_or_ragged_tensor(",
          "172:             weights, name=\"weights\")",
          "174:     if weights is not None and binary_output:",
          "175:       raise ValueError(\"binary_output and weights are mutually exclusive.\")",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "162:     maxlength_value = maxlength if maxlength is not None else -1",
          "164:     if axis == 0:",
          "167:         values = values.values",
          "168:       else:",
          "169:         values = array_ops.reshape(values, [-1])",
          "171:     if isinstance(values, sparse_tensor.SparseTensor):",
          "172:       c_ind, c_val, c_shape = gen_count_ops.sparse_count_sparse_output(",
          "173:           values.indices,",
          "174:           values.values,",
          "175:           values.dense_shape,",
          "177:           minlength=minlength_value,",
          "178:           maxlength=maxlength_value,",
          "181:     elif isinstance(values, ragged_tensor.RaggedTensor):",
          "182:       c_ind, c_val, c_shape = gen_count_ops.ragged_count_sparse_output(",
          "183:           values.row_splits,",
          "184:           values.values,",
          "186:           minlength=minlength_value,",
          "187:           maxlength=maxlength_value,",
          "190:     else:",
          "191:       c_ind, c_val, c_shape = gen_count_ops.dense_count_sparse_output(",
          "192:           values,",
          "193:           weights=weights,",
          "194:           minlength=minlength_value,",
          "195:           maxlength=maxlength_value,",
          "199:     return sparse_tensor.SparseTensor(c_ind, c_val, c_shape)",
          "",
          "[Removed Lines]",
          "165:       if isinstance(values,",
          "166:                     (sparse_tensor.SparseTensor, ragged_tensor.RaggedTensor)):",
          "176:           weights=weights,",
          "179:           binary_count=binary_count,",
          "180:           output_type=output_type)",
          "185:           weights=weights,",
          "188:           binary_count=binary_count,",
          "189:           output_type=output_type)",
          "196:           binary_count=binary_count,",
          "197:           output_type=output_type)",
          "",
          "[Added Lines]",
          "188:       if isinstance(values, sparse_tensor.SparseTensor):",
          "189:         if weights is not None:",
          "190:           weights = validate_sparse_weights(values, weights)",
          "191:         values = values.values",
          "192:       elif isinstance(values, ragged_tensor.RaggedTensor):",
          "193:         if weights is not None:",
          "194:           weights = validate_ragged_weights(values, weights)",
          "197:         if weights is not None:",
          "198:           weights = array_ops.reshape(weights, [-1])",
          "202:       weights = validate_sparse_weights(values, weights)",
          "207:           weights,",
          "210:           binary_output=binary_output)",
          "212:       weights = validate_ragged_weights(values, weights)",
          "216:           weights,",
          "219:           binary_output=binary_output)",
          "221:       weights = validate_dense_weights(values, weights)",
          "227:           binary_output=binary_output)",
          "232: def validate_dense_weights(values, weights):",
          "233:   \"\"\"Validates the passed weight tensor or creates an empty one.\"\"\"",
          "234:   if weights is None:",
          "235:     return array_ops.constant([], dtype=values.dtype)",
          "237:   if not isinstance(weights, ops.Tensor):",
          "238:     raise ValueError(",
          "239:         \"`weights` must be a tf.Tensor if `values` is a tf.Tensor.\")",
          "241:   return weights",
          "244: def validate_sparse_weights(values, weights):",
          "245:   \"\"\"Validates the passed weight tensor or creates an empty one.\"\"\"",
          "246:   if weights is None:",
          "247:     return array_ops.constant([], dtype=values.values.dtype)",
          "249:   if not isinstance(weights, sparse_tensor.SparseTensor):",
          "250:     raise ValueError(",
          "251:         \"`weights` must be a SparseTensor if `values` is a SparseTensor.\")",
          "253:   checks = []",
          "254:   if weights.dense_shape is not values.dense_shape:",
          "255:     checks.append(",
          "256:         check_ops.assert_equal(",
          "257:             weights.dense_shape,",
          "258:             values.dense_shape,",
          "259:             message=\"'weights' and 'values' must have the same dense shape.\"))",
          "260:   if weights.indices is not values.indices:",
          "261:     checks.append(",
          "262:         check_ops.assert_equal(",
          "263:             weights.indices,",
          "264:             values.indices,",
          "265:             message=\"'weights' and 'values' must have the same indices.\")",
          "266:     )",
          "267:   if checks:",
          "268:     with ops.control_dependencies(checks):",
          "269:       weights = array_ops.identity(weights.values)",
          "270:   else:",
          "271:     weights = weights.values",
          "273:   return weights",
          "276: def validate_ragged_weights(values, weights):",
          "277:   \"\"\"Validates the passed weight tensor or creates an empty one.\"\"\"",
          "278:   if weights is None:",
          "279:     return array_ops.constant([], dtype=values.values.dtype)",
          "281:   if not isinstance(weights, ragged_tensor.RaggedTensor):",
          "282:     raise ValueError(",
          "283:         \"`weights` must be a RaggedTensor if `values` is a RaggedTensor.\")",
          "285:   checks = []",
          "286:   if weights.row_splits is not values.row_splits:",
          "287:     checks.append(",
          "288:         check_ops.assert_equal(",
          "289:             weights.row_splits,",
          "290:             values.row_splits,",
          "291:             message=\"'weights' and 'values' must have the same row splits.\"))",
          "292:   if checks:",
          "293:     with ops.control_dependencies(checks):",
          "294:       weights = array_ops.identity(weights.values)",
          "295:   else:",
          "296:     weights = weights.values",
          "298:   return weights",
          "",
          "---------------"
        ],
        "tensorflow/python/ops/bincount_test.py||tensorflow/python/ops/bincount_test.py": [
          "File: tensorflow/python/ops/bincount_test.py -> tensorflow/python/ops/bincount_test.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "21: from absl.testing import parameterized",
          "22: import numpy as np",
          "24: from tensorflow.python.ops import bincount",
          "25: from tensorflow.python.ops import sparse_ops",
          "26: from tensorflow.python.ops.ragged import ragged_factory_ops",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "24: from tensorflow.python.eager import context",
          "25: from tensorflow.python.framework import errors",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "65:           \"expected_indices\": [[0, 1], [0, 2], [0, 3], [1, 4], [1, 5]],",
          "66:           \"expected_values\": [1, 1, 1, 1, 1],",
          "67:           \"expected_shape\": [2, 6],",
          "69:       }, {",
          "70:           \"testcase_name\": \"_maxlength_binary\",",
          "71:           \"x\": np.array([[3, 2, 1, 7], [7, 0, 4, 4]], dtype=np.int32),",
          "",
          "[Removed Lines]",
          "68:           \"binary_count\": True,",
          "",
          "[Added Lines]",
          "70:           \"binary_output\": True,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "73:           \"expected_indices\": [[0, 1], [0, 2], [0, 3], [1, 0], [1, 4]],",
          "74:           \"expected_values\": [1, 1, 1, 1, 1],",
          "75:           \"expected_shape\": [2, 7],",
          "77:       }, {",
          "78:           \"testcase_name\": \"_minlength_binary\",",
          "79:           \"x\": np.array([[3, 2, 1, 7], [7, 0, 4, 4]], dtype=np.int32),",
          "",
          "[Removed Lines]",
          "76:           \"binary_count\": True,",
          "",
          "[Added Lines]",
          "78:           \"binary_output\": True,",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "82:                                [1, 7]],",
          "83:           \"expected_values\": [1, 1, 1, 1, 1, 1, 1],",
          "84:           \"expected_shape\": [2, 9],",
          "86:       }, {",
          "87:           \"testcase_name\": \"_minlength_larger_values_binary\",",
          "88:           \"x\": np.array([[3, 2, 1, 7], [7, 0, 4, 4]], dtype=np.int32),",
          "",
          "[Removed Lines]",
          "85:           \"binary_count\": True,",
          "",
          "[Added Lines]",
          "87:           \"binary_output\": True,",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "91:                                [1, 7]],",
          "92:           \"expected_values\": [1, 1, 1, 1, 1, 1, 1],",
          "93:           \"expected_shape\": [2, 8],",
          "95:       }, {",
          "96:           \"testcase_name\": \"_no_maxlength_weights\",",
          "97:           \"x\": np.array([[3, 2, 1], [5, 4, 4]], dtype=np.int32),",
          "98:           \"expected_indices\": [[0, 1], [0, 2], [0, 3], [1, 4], [1, 5]],",
          "100:           \"expected_shape\": [2, 6],",
          "102:       }, {",
          "103:           \"testcase_name\": \"_maxlength_weights\",",
          "104:           \"x\": np.array([[3, 2, 1, 7], [7, 0, 4, 4]], dtype=np.int32),",
          "105:           \"maxlength\": 7,",
          "106:           \"expected_indices\": [[0, 1], [0, 2], [0, 3], [1, 0], [1, 4]],",
          "108:           \"expected_shape\": [2, 7],",
          "110:       }, {",
          "111:           \"testcase_name\": \"_minlength_weights\",",
          "112:           \"x\": np.array([[3, 2, 1, 7], [7, 0, 4, 4]], dtype=np.int32),",
          "113:           \"minlength\": 9,",
          "114:           \"expected_indices\": [[0, 1], [0, 2], [0, 3], [0, 7], [1, 0], [1, 4],",
          "115:                                [1, 7]],",
          "117:           \"expected_shape\": [2, 9],",
          "119:       }, {",
          "120:           \"testcase_name\": \"_minlength_larger_values_weights\",",
          "121:           \"x\": np.array([[3, 2, 1, 7], [7, 0, 4, 4]], dtype=np.int32),",
          "122:           \"minlength\": 3,",
          "123:           \"expected_indices\": [[0, 1], [0, 2], [0, 3], [0, 7], [1, 0], [1, 4],",
          "124:                                [1, 7]],",
          "126:           \"expected_shape\": [2, 8],",
          "128:       }, {",
          "129:           \"testcase_name\": \"_1d\",",
          "130:           \"x\": np.array([3, 2, 1, 1], dtype=np.int32),",
          "",
          "[Removed Lines]",
          "94:           \"binary_count\": True,",
          "99:           \"expected_values\": [1, 2, 3, 8, 5],",
          "101:           \"weights\": [0.5, 1, 2, 3, 4, 5]",
          "107:           \"expected_values\": [1, 2, 3, 0.5, 8],",
          "109:           \"weights\": [0.5, 1, 2, 3, 4, 5, 6]",
          "116:           \"expected_values\": [1, 2, 3, 7, 0.5, 8, 7],",
          "118:           \"weights\": [0.5, 1, 2, 3, 4, 5, 6, 7, 8]",
          "125:           \"expected_values\": [1, 2, 3, 7, 0.5, 8, 7],",
          "127:           \"weights\": [0.5, 1, 2, 3, 4, 5, 6, 7, 8]",
          "",
          "[Added Lines]",
          "96:           \"binary_output\": True,",
          "101:           \"expected_values\": [2, 1, 0.5, 9, 3],",
          "103:           \"weights\": [[0.5, 1, 2], [3, 4, 5]]",
          "109:           \"expected_values\": [2, 1, 0.5, 3, 9],",
          "111:           \"weights\": [[0.5, 1, 2, 11], [7, 3, 4, 5]]",
          "118:           \"expected_values\": [2, 1, 0.5, 3, 5, 13, 4],",
          "120:           \"weights\": [[0.5, 1, 2, 3], [4, 5, 6, 7]]",
          "127:           \"expected_values\": [2, 1, 0.5, 3, 5, 13, 4],",
          "129:           \"weights\": [[0.5, 1, 2, 3], [4, 5, 6, 7]]",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "146:                        expected_shape,",
          "147:                        minlength=None,",
          "148:                        maxlength=None,",
          "150:                        weights=None,",
          "151:                        axis=-1):",
          "152:     y = bincount.sparse_bincount(",
          "",
          "[Removed Lines]",
          "149:                        binary_count=False,",
          "",
          "[Added Lines]",
          "151:                        binary_output=False,",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "154:         weights=weights,",
          "155:         minlength=minlength,",
          "156:         maxlength=maxlength,",
          "158:         axis=axis)",
          "159:     self.assertAllEqual(expected_indices, y.indices)",
          "160:     self.assertAllEqual(expected_values, y.values)",
          "",
          "[Removed Lines]",
          "157:         binary_count=binary_count,",
          "",
          "[Added Lines]",
          "159:         binary_output=binary_output,",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "216:           \"expected_indices\": [[0, 1], [0, 3], [2, 4], [2, 5]],",
          "217:           \"expected_values\": [1, 1, 1, 1],",
          "218:           \"expected_shape\": [3, 6],",
          "220:               True,",
          "221:       },",
          "222:       {",
          "",
          "[Removed Lines]",
          "219:           \"binary_count\":",
          "",
          "[Added Lines]",
          "221:           \"binary_output\":",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "230:           \"expected_shape\": [3, 7],",
          "231:           \"maxlength\":",
          "232:               7,",
          "234:               True,",
          "235:       },",
          "236:       {",
          "",
          "[Removed Lines]",
          "233:           \"binary_count\":",
          "",
          "[Added Lines]",
          "235:           \"binary_output\":",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "244:           \"expected_shape\": [3, 9],",
          "245:           \"minlength\":",
          "246:               9,",
          "248:               True,",
          "249:       },",
          "250:       {",
          "",
          "[Removed Lines]",
          "247:           \"binary_count\":",
          "",
          "[Added Lines]",
          "249:           \"binary_output\":",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "258:           \"expected_shape\": [3, 8],",
          "259:           \"minlength\":",
          "260:               3,",
          "262:               True,",
          "263:       },",
          "264:       {",
          "",
          "[Removed Lines]",
          "261:           \"binary_count\":",
          "",
          "[Added Lines]",
          "263:           \"binary_output\":",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "268:               np.array([[3, 0, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4]],",
          "269:                        dtype=np.int32),",
          "270:           \"expected_indices\": [[0, 1], [0, 3], [2, 4], [2, 5]],",
          "272:           \"expected_shape\": [3, 6],",
          "274:       },",
          "275:       {",
          "276:           \"testcase_name\":",
          "",
          "[Removed Lines]",
          "271:           \"expected_values\": [1, 3, 8, 5],",
          "273:           \"weights\": [0.5, 1, 2, 3, 4, 5]",
          "",
          "[Added Lines]",
          "273:           \"expected_values\": [2, 6, 7, 10],",
          "275:           \"weights\":",
          "276:               np.array([[6, 0, 2, 0], [0, 0, 0, 0], [10, 0, 3.5, 3.5]]),",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "279:               np.array([[3, 0, 1, 0], [0, 0, 7, 0], [5, 0, 4, 4]],",
          "280:                        dtype=np.int32),",
          "281:           \"expected_indices\": [[0, 1], [0, 3], [2, 4], [2, 5]],",
          "283:           \"expected_shape\": [3, 7],",
          "284:           \"maxlength\":",
          "285:               7,",
          "287:       },",
          "288:       {",
          "289:           \"testcase_name\":",
          "",
          "[Removed Lines]",
          "282:           \"expected_values\": [1, 3, 8, 5],",
          "286:           \"weights\": [0.5, 1, 2, 3, 4, 5, 6]",
          "",
          "[Added Lines]",
          "285:           \"expected_values\": [2, 6, 7, 10],",
          "289:           \"weights\":",
          "290:               np.array([[6, 0, 2, 0], [0, 0, 14, 0], [10, 0, 3.5, 3.5]]),",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "292:               np.array([[3, 0, 1, 0], [7, 0, 0, 0], [5, 0, 4, 4]],",
          "293:                        dtype=np.int32),",
          "294:           \"expected_indices\": [[0, 1], [0, 3], [1, 7], [2, 4], [2, 5]],",
          "296:           \"expected_shape\": [3, 9],",
          "297:           \"minlength\":",
          "298:               9,",
          "300:       },",
          "301:       {",
          "302:           \"testcase_name\":",
          "",
          "[Removed Lines]",
          "295:           \"expected_values\": [1, 3, 7, 8, 5],",
          "299:           \"weights\": [0.5, 1, 2, 3, 4, 5, 6, 7, 8]",
          "",
          "[Added Lines]",
          "299:           \"expected_values\": [2, 6, 14, 6.5, 10],",
          "303:           \"weights\":",
          "304:               np.array([[6, 0, 2, 0], [14, 0, 0, 0], [10, 0, 3, 3.5]]),",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "305:               np.array([[3, 0, 1, 0], [7, 0, 0, 0], [5, 0, 4, 4]],",
          "306:                        dtype=np.int32),",
          "307:           \"expected_indices\": [[0, 1], [0, 3], [1, 7], [2, 4], [2, 5]],",
          "309:           \"expected_shape\": [3, 8],",
          "310:           \"minlength\":",
          "311:               3,",
          "313:       },",
          "314:       {",
          "315:           \"testcase_name\": \"_1d\",",
          "",
          "[Removed Lines]",
          "308:           \"expected_values\": [1, 3, 7, 8, 5],",
          "312:           \"weights\": [0.5, 1, 2, 3, 4, 5, 6, 7, 8]",
          "",
          "[Added Lines]",
          "313:           \"expected_values\": [2, 6, 14, 6.5, 10],",
          "317:           \"weights\":",
          "318:               np.array([[6, 0, 2, 0], [14, 0, 0, 0], [10, 0, 3, 3.5]]),",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "338:                         expected_shape,",
          "339:                         maxlength=None,",
          "340:                         minlength=None,",
          "342:                         weights=None,",
          "343:                         axis=-1):",
          "344:     x_sparse = sparse_ops.from_dense(x)",
          "345:     y = bincount.sparse_bincount(",
          "346:         x_sparse,",
          "348:         minlength=minlength,",
          "349:         maxlength=maxlength,",
          "351:         axis=axis)",
          "352:     self.assertAllEqual(expected_indices, y.indices)",
          "353:     self.assertAllEqual(expected_values, y.values)",
          "",
          "[Removed Lines]",
          "341:                         binary_count=False,",
          "347:         weights=weights,",
          "350:         binary_count=binary_count,",
          "",
          "[Added Lines]",
          "347:                         binary_output=False,",
          "351:     w_sparse = sparse_ops.from_dense(weights) if weights is not None else None",
          "354:         weights=w_sparse,",
          "357:         binary_output=binary_output,",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "393:           \"expected_indices\": [[2, 0], [2, 1], [2, 3], [4, 0], [4, 4], [4, 5]],",
          "394:           \"expected_values\": [1, 1, 1, 1, 1, 1],",
          "395:           \"expected_shape\": [5, 6],",
          "397:       },",
          "398:       {",
          "399:           \"testcase_name\": \"_maxlength_binary\",",
          "",
          "[Removed Lines]",
          "396:           \"binary_count\": True,",
          "",
          "[Added Lines]",
          "403:           \"binary_output\": True,",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "402:           \"expected_indices\": [[2, 0], [2, 1], [2, 3], [4, 0], [4, 4], [4, 5]],",
          "403:           \"expected_values\": [1, 1, 1, 1, 1, 1],",
          "404:           \"expected_shape\": [5, 7],",
          "406:       },",
          "407:       {",
          "408:           \"testcase_name\": \"_minlength_binary\",",
          "",
          "[Removed Lines]",
          "405:           \"binary_count\": True,",
          "",
          "[Added Lines]",
          "412:           \"binary_output\": True,",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "412:                                [4, 5]],",
          "413:           \"expected_values\": [1, 1, 1, 1, 1, 1, 1],",
          "414:           \"expected_shape\": [5, 9],",
          "416:       },",
          "417:       {",
          "418:           \"testcase_name\": \"_minlength_larger_values_binary\",",
          "419:           \"x\": [[], [], [3, 0, 1], [7], [5, 0, 4, 4]],",
          "420:           \"minlength\": 3,",
          "422:           \"expected_indices\": [[2, 0], [2, 1], [2, 3], [3, 7], [4, 0], [4, 4],",
          "423:                                [4, 5]],",
          "424:           \"expected_values\": [1, 1, 1, 1, 1, 1, 1],",
          "",
          "[Removed Lines]",
          "415:           \"binary_count\": True,",
          "421:           \"binary_count\": True,",
          "",
          "[Added Lines]",
          "422:           \"binary_output\": True,",
          "428:           \"binary_output\": True,",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "428:           \"testcase_name\": \"_no_maxlength_weights\",",
          "429:           \"x\": [[], [], [3, 0, 1], [], [5, 0, 4, 4]],",
          "430:           \"expected_indices\": [[2, 0], [2, 1], [2, 3], [4, 0], [4, 4], [4, 5]],",
          "432:           \"expected_shape\": [5, 6],",
          "434:       },",
          "435:       {",
          "436:           \"testcase_name\": \"_maxlength_weights\",",
          "437:           \"x\": [[], [], [3, 0, 1], [7], [5, 0, 4, 4]],",
          "438:           \"maxlength\": 7,",
          "439:           \"expected_indices\": [[2, 0], [2, 1], [2, 3], [4, 0], [4, 4], [4, 5]],",
          "441:           \"expected_shape\": [5, 7],",
          "443:       },",
          "444:       {",
          "445:           \"testcase_name\": \"_minlength_weights\",",
          "",
          "[Removed Lines]",
          "431:           \"expected_values\": [0.5, 1, 3, 0.5, 8, 5],",
          "433:           \"weights\": [0.5, 1, 2, 3, 4, 5]",
          "440:           \"expected_values\": [0.5, 1, 3, 0.5, 8, 5],",
          "442:           \"weights\": [0.5, 1, 2, 3, 4, 5, 6]",
          "",
          "[Added Lines]",
          "438:           \"expected_values\": [0.5, 2, 6, 0.25, 8, 10],",
          "440:           \"weights\": [[], [], [6, 0.5, 2], [], [10, 0.25, 5, 3]],",
          "447:           \"expected_values\": [0.5, 2, 6, 0.25, 8, 10],",
          "449:           \"weights\": [[], [], [6, 0.5, 2], [14], [10, 0.25, 5, 3]],",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "447:           \"minlength\": 9,",
          "448:           \"expected_indices\": [[2, 0], [2, 1], [2, 3], [3, 7], [4, 0], [4, 4],",
          "449:                                [4, 5]],",
          "451:           \"expected_shape\": [5, 9],",
          "453:       },",
          "454:       {",
          "455:           \"testcase_name\": \"_minlength_larger_values_weights\",",
          "",
          "[Removed Lines]",
          "450:           \"expected_values\": [0.5, 1, 3, 7, 0.5, 8, 5],",
          "452:           \"weights\": [0.5, 1, 2, 3, 4, 5, 6, 7, 8]",
          "",
          "[Added Lines]",
          "457:           \"expected_values\": [0.5, 2, 6, 14, 0.25, 8, 10],",
          "459:           \"weights\": [[], [], [6, 0.5, 2], [14], [10, 0.25, 5, 3]],",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "457:           \"minlength\": 3,",
          "458:           \"expected_indices\": [[2, 0], [2, 1], [2, 3], [3, 7], [4, 0], [4, 4],",
          "459:                                [4, 5]],",
          "461:           \"expected_shape\": [5, 8],",
          "463:       },",
          "464:       {",
          "465:           \"testcase_name\": \"_1d\",",
          "",
          "[Removed Lines]",
          "460:           \"expected_values\": [0.5, 1, 3, 7, 0.5, 8, 5],",
          "462:           \"weights\": [0.5, 1, 2, 3, 4, 5, 6, 7, 8]",
          "",
          "[Added Lines]",
          "467:           \"expected_values\": [0.5, 2, 6, 14, 0.25, 8, 10],",
          "469:           \"weights\": [[], [], [6, 0.5, 2], [14], [10, 0.25, 5, 3]],",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "484:                         expected_shape,",
          "485:                         maxlength=None,",
          "486:                         minlength=None,",
          "488:                         weights=None,",
          "489:                         axis=-1):",
          "490:     x_ragged = ragged_factory_ops.constant(x)",
          "491:     y = bincount.sparse_bincount(",
          "492:         x_ragged,",
          "494:         minlength=minlength,",
          "495:         maxlength=maxlength,",
          "497:         axis=axis)",
          "498:     self.assertAllEqual(expected_indices, y.indices)",
          "499:     self.assertAllEqual(expected_values, y.values)",
          "500:     self.assertAllEqual(expected_shape, y.dense_shape)",
          "503: if __name__ == \"__main__\":",
          "504:   test.main()",
          "",
          "[Removed Lines]",
          "487:                         binary_count=False,",
          "493:         weights=weights,",
          "496:         binary_count=binary_count,",
          "",
          "[Added Lines]",
          "494:                         binary_output=False,",
          "498:     w = ragged_factory_ops.constant(weights) if weights is not None else None",
          "501:         weights=w,",
          "504:         binary_output=binary_output,",
          "511: class TestSparseCountFailureModes(test.TestCase):",
          "513:   def test_dense_input_sparse_weights_fails(self):",
          "514:     x = np.array([[3, 2, 1], [5, 4, 4]], dtype=np.int32)",
          "515:     weights = sparse_ops.from_dense(",
          "516:         np.array([[3, 0, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4]], dtype=np.int32))",
          "517:     with self.assertRaisesRegexp(ValueError, \"must be a tf.Tensor\"):",
          "518:       self.evaluate(bincount.sparse_bincount(x, weights=weights, axis=-1))",
          "520:   def test_dense_input_ragged_weights_fails(self):",
          "521:     x = np.array([[3, 2, 1], [5, 4, 4]], dtype=np.int32)",
          "522:     weights = ragged_factory_ops.constant([[6, 0.5, 2], [14], [10, 0.25, 5, 3]])",
          "523:     with self.assertRaisesRegexp(ValueError, \"must be a tf.Tensor\"):",
          "524:       self.evaluate(bincount.sparse_bincount(x, weights=weights, axis=-1))",
          "526:   def test_dense_input_wrong_shape_fails(self):",
          "527:     x = np.array([[3, 2, 1], [5, 4, 4]], dtype=np.int32)",
          "528:     weights = np.array([[3, 2], [5, 4], [4, 3]])",
          "529:     # Note: Eager mode and graph mode throw different errors here. Graph mode",
          "530:     # will fail with a ValueError from the shape checking logic, while Eager",
          "531:     # will fail with an InvalidArgumentError from the kernel itself.",
          "532:     if context.executing_eagerly():",
          "533:       with self.assertRaisesRegexp(errors.InvalidArgumentError,",
          "534:                                    \"must have the same shape\"):",
          "535:         self.evaluate(bincount.sparse_bincount(x, weights=weights, axis=-1))",
          "536:     else:",
          "537:       with self.assertRaisesRegexp(ValueError, \"both shapes must be equal\"):",
          "538:         self.evaluate(bincount.sparse_bincount(x, weights=weights, axis=-1))",
          "540:   def test_sparse_input_dense_weights_fails(self):",
          "541:     x = sparse_ops.from_dense(",
          "542:         np.array([[3, 0, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4]], dtype=np.int32))",
          "543:     weights = np.array([[3, 2, 1], [5, 4, 4]], dtype=np.int32)",
          "544:     with self.assertRaisesRegexp(ValueError, \"must be a SparseTensor\"):",
          "545:       self.evaluate(bincount.sparse_bincount(x, weights=weights, axis=-1))",
          "547:   def test_sparse_input_ragged_weights_fails(self):",
          "548:     x = sparse_ops.from_dense(",
          "549:         np.array([[3, 0, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4]], dtype=np.int32))",
          "550:     weights = ragged_factory_ops.constant([[6, 0.5, 2], [14], [10, 0.25, 5, 3]])",
          "551:     with self.assertRaisesRegexp(ValueError, \"must be a SparseTensor\"):",
          "552:       self.evaluate(bincount.sparse_bincount(x, weights=weights, axis=-1))",
          "554:   def test_sparse_input_wrong_indices_fails(self):",
          "555:     x = sparse_ops.from_dense(",
          "556:         np.array([[3, 0, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4]], dtype=np.int32))",
          "557:     weights = sparse_ops.from_dense(",
          "558:         np.array([[3, 1, 0, 0], [0, 0, 0, 0], [5, 0, 4, 4]], dtype=np.int32))",
          "559:     with self.assertRaisesRegexp(errors.InvalidArgumentError,",
          "560:                                  \"must have the same indices\"):",
          "561:       self.evaluate(bincount.sparse_bincount(x, weights=weights, axis=-1))",
          "563:   def test_sparse_input_too_many_indices_fails(self):",
          "564:     x = sparse_ops.from_dense(",
          "565:         np.array([[3, 0, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4]], dtype=np.int32))",
          "566:     weights = sparse_ops.from_dense(",
          "567:         np.array([[3, 1, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4]], dtype=np.int32))",
          "568:     with self.assertRaisesRegexp(errors.InvalidArgumentError,",
          "569:                                  \"Incompatible shapes\"):",
          "570:       self.evaluate(bincount.sparse_bincount(x, weights=weights, axis=-1))",
          "572:   def test_sparse_input_wrong_shape_fails(self):",
          "573:     x = sparse_ops.from_dense(",
          "574:         np.array([[3, 0, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4]], dtype=np.int32))",
          "575:     weights = sparse_ops.from_dense(",
          "576:         np.array([[3, 0, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4], [0, 0, 0, 0]],",
          "577:                  dtype=np.int32))",
          "578:     with self.assertRaisesRegexp(errors.InvalidArgumentError,",
          "579:                                  \"must have the same dense shape\"):",
          "580:       self.evaluate(bincount.sparse_bincount(x, weights=weights, axis=-1))",
          "582:   def test_ragged_input_dense_weights_fails(self):",
          "583:     x = ragged_factory_ops.constant([[6, 1, 2], [14], [10, 1, 5, 3]])",
          "584:     weights = np.array([[3, 2, 1], [5, 4, 4]], dtype=np.int32)",
          "585:     with self.assertRaisesRegexp(ValueError, \"must be a RaggedTensor\"):",
          "586:       self.evaluate(bincount.sparse_bincount(x, weights=weights, axis=-1))",
          "588:   def test_ragged_input_sparse_weights_fails(self):",
          "589:     x = ragged_factory_ops.constant([[6, 1, 2], [14], [10, 1, 5, 3]])",
          "590:     weights = sparse_ops.from_dense(",
          "591:         np.array([[3, 0, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4]], dtype=np.int32))",
          "592:     with self.assertRaisesRegexp(ValueError, \"must be a RaggedTensor\"):",
          "593:       self.evaluate(bincount.sparse_bincount(x, weights=weights, axis=-1))",
          "595:   def test_ragged_input_different_shape_fails(self):",
          "596:     x = ragged_factory_ops.constant([[6, 1, 2], [14], [10, 1, 5, 3]])",
          "597:     weights = ragged_factory_ops.constant([[6, 0.5, 2], [], [10, 0.25, 5, 3]])",
          "598:     with self.assertRaisesRegexp(errors.InvalidArgumentError,",
          "599:                                  \"must have the same row splits\"):",
          "600:       self.evaluate(bincount.sparse_bincount(x, weights=weights, axis=-1))",
          "",
          "---------------"
        ],
        "tensorflow/tools/api/golden/v1/tensorflow.raw_ops.pbtxt||tensorflow/tools/api/golden/v1/tensorflow.raw_ops.pbtxt": [
          "File: tensorflow/tools/api/golden/v1/tensorflow.raw_ops.pbtxt -> tensorflow/tools/api/golden/v1/tensorflow.raw_ops.pbtxt",
          "--- Hunk 1 ---",
          "[Context before]",
          "1078:   }",
          "1079:   member_method {",
          "1080:     name: \"DenseCountSparseOutput\"",
          "1082:   }",
          "1083:   member_method {",
          "1084:     name: \"DenseToCSRSparseMatrix\"",
          "",
          "[Removed Lines]",
          "1081:     argspec: \"args=[\\'values\\', \\'weights\\', \\'binary_count\\', \\'output_type\\', \\'minlength\\', \\'maxlength\\', \\'name\\'], varargs=None, keywords=None, defaults=[\\'-1\\', \\'-1\\', \\'None\\'], \"",
          "",
          "[Added Lines]",
          "1081:     argspec: \"args=[\\'values\\', \\'weights\\', \\'binary_output\\', \\'minlength\\', \\'maxlength\\', \\'name\\'], varargs=None, keywords=None, defaults=[\\'-1\\', \\'-1\\', \\'None\\'], \"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3074:   }",
          "3075:   member_method {",
          "3076:     name: \"RaggedCountSparseOutput\"",
          "3078:   }",
          "3079:   member_method {",
          "3080:     name: \"RaggedCross\"",
          "",
          "[Removed Lines]",
          "3077:     argspec: \"args=[\\'splits\\', \\'values\\', \\'weights\\', \\'binary_count\\', \\'output_type\\', \\'minlength\\', \\'maxlength\\', \\'name\\'], varargs=None, keywords=None, defaults=[\\'-1\\', \\'-1\\', \\'None\\'], \"",
          "",
          "[Added Lines]",
          "3077:     argspec: \"args=[\\'splits\\', \\'values\\', \\'weights\\', \\'binary_output\\', \\'minlength\\', \\'maxlength\\', \\'name\\'], varargs=None, keywords=None, defaults=[\\'-1\\', \\'-1\\', \\'None\\'], \"",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "4094:   }",
          "4095:   member_method {",
          "4096:     name: \"SparseCountSparseOutput\"",
          "4098:   }",
          "4099:   member_method {",
          "4100:     name: \"SparseCross\"",
          "",
          "[Removed Lines]",
          "4097:     argspec: \"args=[\\'indices\\', \\'values\\', \\'dense_shape\\', \\'weights\\', \\'binary_count\\', \\'output_type\\', \\'minlength\\', \\'maxlength\\', \\'name\\'], varargs=None, keywords=None, defaults=[\\'-1\\', \\'-1\\', \\'None\\'], \"",
          "",
          "[Added Lines]",
          "4097:     argspec: \"args=[\\'indices\\', \\'values\\', \\'dense_shape\\', \\'weights\\', \\'binary_output\\', \\'minlength\\', \\'maxlength\\', \\'name\\'], varargs=None, keywords=None, defaults=[\\'-1\\', \\'-1\\', \\'None\\'], \"",
          "",
          "---------------"
        ],
        "tensorflow/tools/api/golden/v1/tensorflow.sparse.pbtxt||tensorflow/tools/api/golden/v1/tensorflow.sparse.pbtxt": [
          "File: tensorflow/tools/api/golden/v1/tensorflow.sparse.pbtxt -> tensorflow/tools/api/golden/v1/tensorflow.sparse.pbtxt",
          "--- Hunk 1 ---",
          "[Context before]",
          "14:   }",
          "15:   member_method {",
          "16:     name: \"bincount\"",
          "18:   }",
          "19:   member_method {",
          "20:     name: \"concat\"",
          "",
          "[Removed Lines]",
          "17:     argspec: \"args=[\\'values\\', \\'weights\\', \\'axis\\', \\'minlength\\', \\'maxlength\\', \\'binary_count\\', \\'name\\'], varargs=None, keywords=None, defaults=[\\'None\\', \\'0\\', \\'None\\', \\'None\\', \\'False\\', \\'None\\'], \"",
          "",
          "[Added Lines]",
          "17:     argspec: \"args=[\\'values\\', \\'weights\\', \\'axis\\', \\'minlength\\', \\'maxlength\\', \\'binary_output\\', \\'name\\'], varargs=None, keywords=None, defaults=[\\'None\\', \\'0\\', \\'None\\', \\'None\\', \\'False\\', \\'None\\'], \"",
          "",
          "---------------"
        ],
        "tensorflow/tools/api/golden/v2/tensorflow.raw_ops.pbtxt||tensorflow/tools/api/golden/v2/tensorflow.raw_ops.pbtxt": [
          "File: tensorflow/tools/api/golden/v2/tensorflow.raw_ops.pbtxt -> tensorflow/tools/api/golden/v2/tensorflow.raw_ops.pbtxt",
          "--- Hunk 1 ---",
          "[Context before]",
          "1078:   }",
          "1079:   member_method {",
          "1080:     name: \"DenseCountSparseOutput\"",
          "1082:   }",
          "1083:   member_method {",
          "1084:     name: \"DenseToCSRSparseMatrix\"",
          "",
          "[Removed Lines]",
          "1081:     argspec: \"args=[\\'values\\', \\'weights\\', \\'binary_count\\', \\'output_type\\', \\'minlength\\', \\'maxlength\\', \\'name\\'], varargs=None, keywords=None, defaults=[\\'-1\\', \\'-1\\', \\'None\\'], \"",
          "",
          "[Added Lines]",
          "1081:     argspec: \"args=[\\'values\\', \\'weights\\', \\'binary_output\\', \\'minlength\\', \\'maxlength\\', \\'name\\'], varargs=None, keywords=None, defaults=[\\'-1\\', \\'-1\\', \\'None\\'], \"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3074:   }",
          "3075:   member_method {",
          "3076:     name: \"RaggedCountSparseOutput\"",
          "3078:   }",
          "3079:   member_method {",
          "3080:     name: \"RaggedCross\"",
          "",
          "[Removed Lines]",
          "3077:     argspec: \"args=[\\'splits\\', \\'values\\', \\'weights\\', \\'binary_count\\', \\'output_type\\', \\'minlength\\', \\'maxlength\\', \\'name\\'], varargs=None, keywords=None, defaults=[\\'-1\\', \\'-1\\', \\'None\\'], \"",
          "",
          "[Added Lines]",
          "3077:     argspec: \"args=[\\'splits\\', \\'values\\', \\'weights\\', \\'binary_output\\', \\'minlength\\', \\'maxlength\\', \\'name\\'], varargs=None, keywords=None, defaults=[\\'-1\\', \\'-1\\', \\'None\\'], \"",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "4094:   }",
          "4095:   member_method {",
          "4096:     name: \"SparseCountSparseOutput\"",
          "4098:   }",
          "4099:   member_method {",
          "4100:     name: \"SparseCross\"",
          "",
          "[Removed Lines]",
          "4097:     argspec: \"args=[\\'indices\\', \\'values\\', \\'dense_shape\\', \\'weights\\', \\'binary_count\\', \\'output_type\\', \\'minlength\\', \\'maxlength\\', \\'name\\'], varargs=None, keywords=None, defaults=[\\'-1\\', \\'-1\\', \\'None\\'], \"",
          "",
          "[Added Lines]",
          "4097:     argspec: \"args=[\\'indices\\', \\'values\\', \\'dense_shape\\', \\'weights\\', \\'binary_output\\', \\'minlength\\', \\'maxlength\\', \\'name\\'], varargs=None, keywords=None, defaults=[\\'-1\\', \\'-1\\', \\'None\\'], \"",
          "",
          "---------------"
        ],
        "tensorflow/tools/api/golden/v2/tensorflow.sparse.pbtxt||tensorflow/tools/api/golden/v2/tensorflow.sparse.pbtxt": [
          "File: tensorflow/tools/api/golden/v2/tensorflow.sparse.pbtxt -> tensorflow/tools/api/golden/v2/tensorflow.sparse.pbtxt",
          "--- Hunk 1 ---",
          "[Context before]",
          "10:   }",
          "11:   member_method {",
          "12:     name: \"bincount\"",
          "14:   }",
          "15:   member_method {",
          "16:     name: \"concat\"",
          "",
          "[Removed Lines]",
          "13:     argspec: \"args=[\\'values\\', \\'weights\\', \\'axis\\', \\'minlength\\', \\'maxlength\\', \\'binary_count\\', \\'name\\'], varargs=None, keywords=None, defaults=[\\'None\\', \\'0\\', \\'None\\', \\'None\\', \\'False\\', \\'None\\'], \"",
          "",
          "[Added Lines]",
          "13:     argspec: \"args=[\\'values\\', \\'weights\\', \\'axis\\', \\'minlength\\', \\'maxlength\\', \\'binary_output\\', \\'name\\'], varargs=None, keywords=None, defaults=[\\'None\\', \\'0\\', \\'None\\', \\'None\\', \\'False\\', \\'None\\'], \"",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "799b5fa38a157e18bdea7c737f46c9e774d9ef90",
      "candidate_info": {
        "commit_hash": "799b5fa38a157e18bdea7c737f46c9e774d9ef90",
        "repo": "tensorflow/tensorflow",
        "commit_url": "https://github.com/tensorflow/tensorflow/commit/799b5fa38a157e18bdea7c737f46c9e774d9ef90",
        "files": [
          "tensorflow/core/kernels/count_ops.cc"
        ],
        "message": "Fix the segfault in `tf.raw_ops.SparseCountSparseOutput`.\n\nPiperOrigin-RevId: 369264941\nChange-Id: I23a96a15b8370c01ee21ba3841e1c7dcbf55e93d",
        "before_after_code_files": [
          "tensorflow/core/kernels/count_ops.cc||tensorflow/core/kernels/count_ops.cc"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "tensorflow/core/kernels/count_ops.cc||tensorflow/core/kernels/count_ops.cc"
          ],
          "candidate": [
            "tensorflow/core/kernels/count_ops.cc||tensorflow/core/kernels/count_ops.cc"
          ]
        }
      },
      "candidate_diff": {
        "tensorflow/core/kernels/count_ops.cc||tensorflow/core/kernels/count_ops.cc": [
          "File: tensorflow/core/kernels/count_ops.cc -> tensorflow/core/kernels/count_ops.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "197:                     \"The shape argument requires at least one element.\"));",
          "199:     bool is_1d = shape.NumElements() == 1;",
          "201:     int num_values = values.NumElements();",
          "203:     OP_REQUIRES(context, num_values == indices.shape().dim_size(0),",
          "204:                 errors::InvalidArgument(",
          "205:                     \"Number of values must match first dimension of indices.\",",
          "",
          "[Removed Lines]",
          "200:     int num_batches = is_1d ? 1 : shape.flat<int64>()(0);",
          "",
          "[Added Lines]",
          "200:     auto shape_vector = shape.flat<int64>();",
          "201:     int num_batches = is_1d ? 1 : shape_vector(0);",
          "204:     for (int b = 0; b < shape_vector.size(); b++) {",
          "205:       OP_REQUIRES(context, shape_vector(b) >= 0,",
          "206:                   errors::InvalidArgument(",
          "207:                       \"Elements in dense_shape must be >= 0. Instead got:\",",
          "208:                       shape.DebugString()));",
          "209:     }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "370e714d7affe3463fba84c0b95d947f43b00380",
      "candidate_info": {
        "commit_hash": "370e714d7affe3463fba84c0b95d947f43b00380",
        "repo": "tensorflow/tensorflow",
        "commit_url": "https://github.com/tensorflow/tensorflow/commit/370e714d7affe3463fba84c0b95d947f43b00380",
        "files": [
          "tensorflow/core/kernels/count_ops.cc"
        ],
        "message": "Fix the segfault in `tf.raw_ops.SparseCountSparseOutput`.\n\nPiperOrigin-RevId: 369264941\nChange-Id: I23a96a15b8370c01ee21ba3841e1c7dcbf55e93d",
        "before_after_code_files": [
          "tensorflow/core/kernels/count_ops.cc||tensorflow/core/kernels/count_ops.cc"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "tensorflow/core/kernels/count_ops.cc||tensorflow/core/kernels/count_ops.cc"
          ],
          "candidate": [
            "tensorflow/core/kernels/count_ops.cc||tensorflow/core/kernels/count_ops.cc"
          ]
        }
      },
      "candidate_diff": {
        "tensorflow/core/kernels/count_ops.cc||tensorflow/core/kernels/count_ops.cc": [
          "File: tensorflow/core/kernels/count_ops.cc -> tensorflow/core/kernels/count_ops.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "193:     }",
          "195:     bool is_1d = shape.NumElements() == 1;",
          "197:     int num_values = values.NumElements();",
          "199:     OP_REQUIRES(context, num_values == indices.shape().dim_size(0),",
          "200:                 errors::InvalidArgument(",
          "201:                     \"Number of values must match first dimension of indices.\",",
          "",
          "[Removed Lines]",
          "196:     int num_batches = is_1d ? 1 : shape.flat<int64>()(0);",
          "",
          "[Added Lines]",
          "196:     auto shape_vector = shape.flat<int64>();",
          "197:     int num_batches = is_1d ? 1 : shape_vector(0);",
          "200:     for (int b = 0; b < shape_vector.size(); b++) {",
          "201:       OP_REQUIRES(context, shape_vector(b) >= 0,",
          "202:                   errors::InvalidArgument(",
          "203:                       \"Elements in dense_shape must be >= 0. Instead got:\",",
          "204:                       shape.DebugString()));",
          "205:     }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "428e5f14d641a7450176f13125438d840bd0f42b",
      "candidate_info": {
        "commit_hash": "428e5f14d641a7450176f13125438d840bd0f42b",
        "repo": "tensorflow/tensorflow",
        "commit_url": "https://github.com/tensorflow/tensorflow/commit/428e5f14d641a7450176f13125438d840bd0f42b",
        "files": [
          "tensorflow/core/kernels/count_ops.cc"
        ],
        "message": "Fix the segfault in `tf.raw_ops.SparseCountSparseOutput`.\n\nPiperOrigin-RevId: 369264941\nChange-Id: I23a96a15b8370c01ee21ba3841e1c7dcbf55e93d",
        "before_after_code_files": [
          "tensorflow/core/kernels/count_ops.cc||tensorflow/core/kernels/count_ops.cc"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "tensorflow/core/kernels/count_ops.cc||tensorflow/core/kernels/count_ops.cc"
          ],
          "candidate": [
            "tensorflow/core/kernels/count_ops.cc||tensorflow/core/kernels/count_ops.cc"
          ]
        }
      },
      "candidate_diff": {
        "tensorflow/core/kernels/count_ops.cc||tensorflow/core/kernels/count_ops.cc": [
          "File: tensorflow/core/kernels/count_ops.cc -> tensorflow/core/kernels/count_ops.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "193:     }",
          "195:     bool is_1d = shape.NumElements() == 1;",
          "197:     int num_values = values.NumElements();",
          "199:     OP_REQUIRES(context, num_values == indices.shape().dim_size(0),",
          "200:                 errors::InvalidArgument(",
          "201:                     \"Number of values must match first dimension of indices.\",",
          "",
          "[Removed Lines]",
          "196:     int num_batches = is_1d ? 1 : shape.flat<int64>()(0);",
          "",
          "[Added Lines]",
          "196:     auto shape_vector = shape.flat<int64>();",
          "197:     int num_batches = is_1d ? 1 : shape_vector(0);",
          "200:     for (int b = 0; b < shape_vector.size(); b++) {",
          "201:       OP_REQUIRES(context, shape_vector(b) >= 0,",
          "202:                   errors::InvalidArgument(",
          "203:                       \"Elements in dense_shape must be >= 0. Instead got:\",",
          "204:                       shape.DebugString()));",
          "205:     }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2019-11811",
  "cve_desc": "An issue was discovered in the Linux kernel before 5.0.4. There is a use-after-free upon attempted read access to /proc/ioports after the ipmi_si module is removed, related to drivers/char/ipmi/ipmi_si_intf.c, drivers/char/ipmi/ipmi_si_mem_io.c, and drivers/char/ipmi/ipmi_si_port_io.c.",
  "repo": "torvalds/linux",
  "patch_hash": "401e7e88d4ef80188ffa07095ac00456f901b8c4",
  "patch_info": {
    "commit_hash": "401e7e88d4ef80188ffa07095ac00456f901b8c4",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/401e7e88d4ef80188ffa07095ac00456f901b8c4",
    "files": [
      "drivers/char/ipmi/ipmi_si_intf.c",
      "drivers/char/ipmi/ipmi_si_mem_io.c",
      "drivers/char/ipmi/ipmi_si_port_io.c"
    ],
    "message": "ipmi_si: fix use-after-free of resource->name\n\nWhen we excute the following commands, we got oops\nrmmod ipmi_si\ncat /proc/ioports\n\n[ 1623.482380] Unable to handle kernel paging request at virtual address ffff00000901d478\n[ 1623.482382] Mem abort info:\n[ 1623.482383]   ESR = 0x96000007\n[ 1623.482385]   Exception class = DABT (current EL), IL = 32 bits\n[ 1623.482386]   SET = 0, FnV = 0\n[ 1623.482387]   EA = 0, S1PTW = 0\n[ 1623.482388] Data abort info:\n[ 1623.482389]   ISV = 0, ISS = 0x00000007\n[ 1623.482390]   CM = 0, WnR = 0\n[ 1623.482393] swapper pgtable: 4k pages, 48-bit VAs, pgdp = 00000000d7d94a66\n[ 1623.482395] [ffff00000901d478] pgd=000000dffbfff003, pud=000000dffbffe003, pmd=0000003f5d06e003, pte=0000000000000000\n[ 1623.482399] Internal error: Oops: 96000007 [#1] SMP\n[ 1623.487407] Modules linked in: ipmi_si(E) nls_utf8 isofs rpcrdma ib_iser ib_srpt target_core_mod ib_srp scsi_transport_srp ib_ipoib rdma_ucm ib_umad rdma_cm ib_cm dm_mirror dm_region_hash dm_log iw_cm dm_mod aes_ce_blk crypto_simd cryptd aes_ce_cipher ses ghash_ce sha2_ce enclosure sha256_arm64 sg sha1_ce hisi_sas_v2_hw hibmc_drm sbsa_gwdt hisi_sas_main ip_tables mlx5_ib ib_uverbs marvell ib_core mlx5_core ixgbe mdio hns_dsaf ipmi_devintf hns_enet_drv ipmi_msghandler hns_mdio [last unloaded: ipmi_si]\n[ 1623.532410] CPU: 30 PID: 11438 Comm: cat Kdump: loaded Tainted: G            E     5.0.0-rc3+ #168\n[ 1623.541498] Hardware name: Huawei TaiShan 2280 /BC11SPCD, BIOS 1.37 11/21/2017\n[ 1623.548822] pstate: a0000005 (NzCv daif -PAN -UAO)\n[ 1623.553684] pc : string+0x28/0x98\n[ 1623.557040] lr : vsnprintf+0x368/0x5e8\n[ 1623.560837] sp : ffff000013213a80\n[ 1623.564191] x29: ffff000013213a80 x28: ffff00001138abb5\n[ 1623.569577] x27: ffff000013213c18 x26: ffff805f67d06049\n[ 1623.574963] x25: 0000000000000000 x24: ffff00001138abb5\n[ 1623.580349] x23: 0000000000000fb7 x22: ffff0000117ed000\n[ 1623.585734] x21: ffff000011188fd8 x20: ffff805f67d07000\n[ 1623.591119] x19: ffff805f67d06061 x18: ffffffffffffffff\n[ 1623.596505] x17: 0000000000000200 x16: 0000000000000000\n[ 1623.601890] x15: ffff0000117ed748 x14: ffff805f67d07000\n[ 1623.607276] x13: ffff805f67d0605e x12: 0000000000000000\n[ 1623.612661] x11: 0000000000000000 x10: 0000000000000000\n[ 1623.618046] x9 : 0000000000000000 x8 : 000000000000000f\n[ 1623.623432] x7 : ffff805f67d06061 x6 : fffffffffffffffe\n[ 1623.628817] x5 : 0000000000000012 x4 : ffff00000901d478\n[ 1623.634203] x3 : ffff0a00ffffff04 x2 : ffff805f67d07000\n[ 1623.639588] x1 : ffff805f67d07000 x0 : ffffffffffffffff\n[ 1623.644974] Process cat (pid: 11438, stack limit = 0x000000008d4cbc10)\n[ 1623.651592] Call trace:\n[ 1623.654068]  string+0x28/0x98\n[ 1623.657071]  vsnprintf+0x368/0x5e8\n[ 1623.660517]  seq_vprintf+0x70/0x98\n[ 1623.668009]  seq_printf+0x7c/0xa0\n[ 1623.675530]  r_show+0xc8/0xf8\n[ 1623.682558]  seq_read+0x330/0x440\n[ 1623.689877]  proc_reg_read+0x78/0xd0\n[ 1623.697346]  __vfs_read+0x60/0x1a0\n[ 1623.704564]  vfs_read+0x94/0x150\n[ 1623.711339]  ksys_read+0x6c/0xd8\n[ 1623.717939]  __arm64_sys_read+0x24/0x30\n[ 1623.725077]  el0_svc_common+0x120/0x148\n[ 1623.732035]  el0_svc_handler+0x30/0x40\n[ 1623.738757]  el0_svc+0x8/0xc\n[ 1623.744520] Code: d1000406 aa0103e2 54000149 b4000080 (39400085)\n[ 1623.753441] ---[ end trace f91b6a4937de9835 ]---\n[ 1623.760871] Kernel panic - not syncing: Fatal exception\n[ 1623.768935] SMP: stopping secondary CPUs\n[ 1623.775718] Kernel Offset: disabled\n[ 1623.781998] CPU features: 0x002,21006008\n[ 1623.788777] Memory Limit: none\n[ 1623.798329] Starting crashdump kernel...\n[ 1623.805202] Bye!\n\nIf io_setup is called successful in try_smi_init() but try_smi_init()\ngoes out_err before calling ipmi_register_smi(), so ipmi_unregister_smi()\nwill not be called while removing module. It leads to the resource that\nallocated in io_setup() can not be freed, but the name(DEVICE_NAME) of\nresource is freed while removing the module. It causes use-after-free\nwhen cat /proc/ioports.\n\nFix this by calling io_cleanup() while try_smi_init() goes to out_err.\nand don't call io_cleanup() until io_setup() returns successful to avoid\nwarning prints.\n\nFixes: 93c303d2045b (\"ipmi_si: Clean up shutdown a bit\")\nCc: stable@vger.kernel.org\nReported-by: NuoHan Qiao <qiaonuohan@huawei.com>\nSuggested-by: Corey Minyard <cminyard@mvista.com>\nSigned-off-by: Yang Yingliang <yangyingliang@huawei.com>\nSigned-off-by: Corey Minyard <cminyard@mvista.com>",
    "before_after_code_files": [
      "drivers/char/ipmi/ipmi_si_intf.c||drivers/char/ipmi/ipmi_si_intf.c",
      "drivers/char/ipmi/ipmi_si_mem_io.c||drivers/char/ipmi/ipmi_si_mem_io.c",
      "drivers/char/ipmi/ipmi_si_port_io.c||drivers/char/ipmi/ipmi_si_port_io.c"
    ]
  },
  "patch_diff": {
    "drivers/char/ipmi/ipmi_si_intf.c||drivers/char/ipmi/ipmi_si_intf.c": [
      "File: drivers/char/ipmi/ipmi_si_intf.c -> drivers/char/ipmi/ipmi_si_intf.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "2085:  WARN_ON(new_smi->io.dev->init_name != NULL);",
      "2087:  out_err:",
      "2088:  kfree(init_name);",
      "2089:  return rv;",
      "2090: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2088:  if (rv && new_smi->io.io_cleanup) {",
      "2089:   new_smi->io.io_cleanup(&new_smi->io);",
      "2090:   new_smi->io.io_cleanup = NULL;",
      "2091:  }",
      "",
      "---------------"
    ],
    "drivers/char/ipmi/ipmi_si_mem_io.c||drivers/char/ipmi/ipmi_si_mem_io.c": [
      "File: drivers/char/ipmi/ipmi_si_mem_io.c -> drivers/char/ipmi/ipmi_si_mem_io.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "81:  if (!addr)",
      "82:   return -ENODEV;",
      "",
      "[Removed Lines]",
      "84:  io->io_cleanup = mem_cleanup;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "141:   mem_region_cleanup(io, io->io_size);",
      "142:   return -EIO;",
      "143:  }",
      "144:  return 0;",
      "145: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "143:  io->io_cleanup = mem_cleanup;",
      "",
      "---------------"
    ],
    "drivers/char/ipmi/ipmi_si_port_io.c||drivers/char/ipmi/ipmi_si_port_io.c": [
      "File: drivers/char/ipmi/ipmi_si_port_io.c -> drivers/char/ipmi/ipmi_si_port_io.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "68:  if (!addr)",
      "69:   return -ENODEV;",
      "",
      "[Removed Lines]",
      "71:  io->io_cleanup = port_cleanup;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "109:    return -EIO;",
      "110:   }",
      "111:  }",
      "112:  return 0;",
      "113: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "111:  io->io_cleanup = port_cleanup;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "8d29d16d21342a0c86405d46de0c4ac5daf1760f",
      "candidate_info": {
        "commit_hash": "8d29d16d21342a0c86405d46de0c4ac5daf1760f",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/8d29d16d21342a0c86405d46de0c4ac5daf1760f",
        "files": [
          "net/netfilter/x_tables.c"
        ],
        "message": "netfilter: compat: initialize all fields in xt_init\n\nIf a non zero value happens to be in xt[NFPROTO_BRIDGE].cur at init\ntime, the following panic can be caused by running\n\n% ebtables -t broute -F BROUTING\n\nfrom a 32-bit user level on a 64-bit kernel. This patch replaces\nkmalloc_array with kcalloc when allocating xt.\n\n[  474.680846] BUG: unable to handle kernel paging request at 0000000009600920\n[  474.687869] PGD 2037006067 P4D 2037006067 PUD 2038938067 PMD 0\n[  474.693838] Oops: 0000 [#1] SMP\n[  474.697055] CPU: 9 PID: 4662 Comm: ebtables Kdump: loaded Not tainted 4.19.17-11302235.AroraKernelnext.fc18.x86_64 #1\n[  474.707721] Hardware name: Supermicro X9DRT/X9DRT, BIOS 3.0 06/28/2013\n[  474.714313] RIP: 0010:xt_compat_calc_jump+0x2f/0x63 [x_tables]\n[  474.720201] Code: 40 0f b6 ff 55 31 c0 48 6b ff 70 48 03 3d dc 45 00 00 48 89 e5 8b 4f 6c 4c 8b 47 60 ff c9 39 c8 7f 2f 8d 14 08 d1 fa 48 63 fa <41> 39 34 f8 4c 8d 0c fd 00 00 00 00 73 05 8d 42 01 eb e1 76 05 8d\n[  474.739023] RSP: 0018:ffffc9000943fc58 EFLAGS: 00010207\n[  474.744296] RAX: 0000000000000000 RBX: ffffc90006465000 RCX: 0000000002580249\n[  474.751485] RDX: 00000000012c0124 RSI: fffffffff7be17e9 RDI: 00000000012c0124\n[  474.758670] RBP: ffffc9000943fc58 R08: 0000000000000000 R09: ffffffff8117cf8f\n[  474.765855] R10: ffffc90006477000 R11: 0000000000000000 R12: 0000000000000001\n[  474.773048] R13: 0000000000000000 R14: ffffc9000943fcb8 R15: ffffc9000943fcb8\n[  474.780234] FS:  0000000000000000(0000) GS:ffff88a03f840000(0063) knlGS:00000000f7ac7700\n[  474.788612] CS:  0010 DS: 002b ES: 002b CR0: 0000000080050033\n[  474.794632] CR2: 0000000009600920 CR3: 0000002037422006 CR4: 00000000000606e0\n[  474.802052] Call Trace:\n[  474.804789]  compat_do_replace+0x1fb/0x2a3 [ebtables]\n[  474.810105]  compat_do_ebt_set_ctl+0x69/0xe6 [ebtables]\n[  474.815605]  ? try_module_get+0x37/0x42\n[  474.819716]  compat_nf_setsockopt+0x4f/0x6d\n[  474.824172]  compat_ip_setsockopt+0x7e/0x8c\n[  474.828641]  compat_raw_setsockopt+0x16/0x3a\n[  474.833220]  compat_sock_common_setsockopt+0x1d/0x24\n[  474.838458]  __compat_sys_setsockopt+0x17e/0x1b1\n[  474.843343]  ? __check_object_size+0x76/0x19a\n[  474.847960]  __ia32_compat_sys_socketcall+0x1cb/0x25b\n[  474.853276]  do_fast_syscall_32+0xaf/0xf6\n[  474.857548]  entry_SYSENTER_compat+0x6b/0x7a\n\nSigned-off-by: Francesco Ruggeri <fruggeri@arista.com>\nAcked-by: Florian Westphal <fw@strlen.de>\nSigned-off-by: Pablo Neira Ayuso <pablo@netfilter.org>",
        "before_after_code_files": [
          "net/netfilter/x_tables.c||net/netfilter/x_tables.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "net/netfilter/x_tables.c||net/netfilter/x_tables.c": [
          "File: net/netfilter/x_tables.c -> net/netfilter/x_tables.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1899:   seqcount_init(&per_cpu(xt_recseq, i));",
          "1900:  }",
          "1903:  if (!xt)",
          "1904:   return -ENOMEM;",
          "",
          "[Removed Lines]",
          "1902:  xt = kmalloc_array(NFPROTO_NUMPROTO, sizeof(struct xt_af), GFP_KERNEL);",
          "",
          "[Added Lines]",
          "1902:  xt = kcalloc(NFPROTO_NUMPROTO, sizeof(struct xt_af), GFP_KERNEL);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "fc2d5cfdcfe2ab76b263d91429caa22451123085",
      "candidate_info": {
        "commit_hash": "fc2d5cfdcfe2ab76b263d91429caa22451123085",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/fc2d5cfdcfe2ab76b263d91429caa22451123085",
        "files": [
          "net/key/af_key.c"
        ],
        "message": "af_key: unconditionally clone on broadcast\n\nAttempting to avoid cloning the skb when broadcasting by inflating\nthe refcount with sock_hold/sock_put while under RCU lock is dangerous\nand violates RCU principles. It leads to subtle race conditions when\nattempting to free the SKB, as we may reference sockets that have\nalready been freed by the stack.\n\nUnable to handle kernel paging request at virtual address 6b6b6b6b6b6c4b\n[006b6b6b6b6b6c4b] address between user and kernel address ranges\nInternal error: Oops: 96000004 [#1] PREEMPT SMP\ntask: fffffff78f65b380 task.stack: ffffff8049a88000\npc : sock_rfree+0x38/0x6c\nlr : skb_release_head_state+0x6c/0xcc\nProcess repro (pid: 7117, stack limit = 0xffffff8049a88000)\nCall trace:\n\tsock_rfree+0x38/0x6c\n\tskb_release_head_state+0x6c/0xcc\n\tskb_release_all+0x1c/0x38\n\t__kfree_skb+0x1c/0x30\n\tkfree_skb+0xd0/0xf4\n\tpfkey_broadcast+0x14c/0x18c\n\tpfkey_sendmsg+0x1d8/0x408\n\tsock_sendmsg+0x44/0x60\n\t___sys_sendmsg+0x1d0/0x2a8\n\t__sys_sendmsg+0x64/0xb4\n\tSyS_sendmsg+0x34/0x4c\n\tel0_svc_naked+0x34/0x38\nKernel panic - not syncing: Fatal exception\n\nSuggested-by: Eric Dumazet <eric.dumazet@gmail.com>\nSigned-off-by: Sean Tranchetti <stranche@codeaurora.org>\nSigned-off-by: Steffen Klassert <steffen.klassert@secunet.com>",
        "before_after_code_files": [
          "net/key/af_key.c||net/key/af_key.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "net/key/af_key.c||net/key/af_key.c": [
          "File: net/key/af_key.c -> net/key/af_key.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "196:  return 0;",
          "197: }",
          "201: {",
          "202:  int err = -ENOBUFS;",
          "221:  }",
          "223:  return err;",
          "224: }",
          "",
          "[Removed Lines]",
          "199: static int pfkey_broadcast_one(struct sk_buff *skb, struct sk_buff **skb2,",
          "200:           gfp_t allocation, struct sock *sk)",
          "204:  sock_hold(sk);",
          "205:  if (*skb2 == NULL) {",
          "206:   if (refcount_read(&skb->users) != 1) {",
          "208:   } else {",
          "210:    refcount_inc(&skb->users);",
          "211:   }",
          "212:  }",
          "213:  if (*skb2 != NULL) {",
          "214:   if (atomic_read(&sk->sk_rmem_alloc) <= sk->sk_rcvbuf) {",
          "215:    skb_set_owner_r(*skb2, sk);",
          "216:    skb_queue_tail(&sk->sk_receive_queue, *skb2);",
          "217:    sk->sk_data_ready(sk);",
          "219:    err = 0;",
          "220:   }",
          "222:  sock_put(sk);",
          "",
          "[Added Lines]",
          "199: static int pfkey_broadcast_one(struct sk_buff *skb, gfp_t allocation,",
          "200:           struct sock *sk)",
          "204:  if (atomic_read(&sk->sk_rmem_alloc) > sk->sk_rcvbuf)",
          "205:   return err;",
          "207:  skb = skb_clone(skb, allocation);",
          "209:  if (skb) {",
          "210:   skb_set_owner_r(skb, sk);",
          "211:   skb_queue_tail(&sk->sk_receive_queue, skb);",
          "212:   sk->sk_data_ready(sk);",
          "213:   err = 0;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "234: {",
          "235:  struct netns_pfkey *net_pfkey = net_generic(net, pfkey_net_id);",
          "236:  struct sock *sk;",
          "238:  int err = -ESRCH;",
          "",
          "[Removed Lines]",
          "237:  struct sk_buff *skb2 = NULL;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "255:   if (pfk->promisc)",
          "259:   if (sk == one_sk)",
          "",
          "[Removed Lines]",
          "256:    pfkey_broadcast_one(skb, &skb2, GFP_ATOMIC, sk);",
          "",
          "[Added Lines]",
          "247:    pfkey_broadcast_one(skb, GFP_ATOMIC, sk);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "268:     continue;",
          "269:   }",
          "",
          "[Removed Lines]",
          "271:   err2 = pfkey_broadcast_one(skb, &skb2, GFP_ATOMIC, sk);",
          "",
          "[Added Lines]",
          "262:   err2 = pfkey_broadcast_one(skb, GFP_ATOMIC, sk);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "278:  rcu_read_unlock();",
          "280:  if (one_sk != NULL)",
          "284:  kfree_skb(skb);",
          "285:  return err;",
          "286: }",
          "",
          "[Removed Lines]",
          "281:   err = pfkey_broadcast_one(skb, &skb2, allocation, one_sk);",
          "283:  kfree_skb(skb2);",
          "",
          "[Added Lines]",
          "272:   err = pfkey_broadcast_one(skb, allocation, one_sk);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "9951379b0ca88c95876ad9778b9099e19a95d566",
      "candidate_info": {
        "commit_hash": "9951379b0ca88c95876ad9778b9099e19a95d566",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/9951379b0ca88c95876ad9778b9099e19a95d566",
        "files": [
          "drivers/md/bcache/writeback.h"
        ],
        "message": "bcache: never writeback a discard operation\n\nSome users see panics like the following when performing fstrim on a\nbcached volume:\n\n[  529.803060] BUG: unable to handle kernel NULL pointer dereference at 0000000000000008\n[  530.183928] #PF error: [normal kernel read fault]\n[  530.412392] PGD 8000001f42163067 P4D 8000001f42163067 PUD 1f42168067 PMD 0\n[  530.750887] Oops: 0000 [#1] SMP PTI\n[  530.920869] CPU: 10 PID: 4167 Comm: fstrim Kdump: loaded Not tainted 5.0.0-rc1+ #3\n[  531.290204] Hardware name: HP ProLiant DL360 Gen9/ProLiant DL360 Gen9, BIOS P89 12/27/2015\n[  531.693137] RIP: 0010:blk_queue_split+0x148/0x620\n[  531.922205] Code: 60 38 89 55 a0 45 31 db 45 31 f6 45 31 c9 31 ff 89 4d 98 85 db 0f 84 7f 04 00 00 44 8b 6d 98 4c 89 ee 48 c1 e6 04 49 03 70 78 <8b> 46 08 44 8b 56 0c 48\n8b 16 44 29 e0 39 d8 48 89 55 a8 0f 47 c3\n[  532.838634] RSP: 0018:ffffb9b708df39b0 EFLAGS: 00010246\n[  533.093571] RAX: 00000000ffffffff RBX: 0000000000046000 RCX: 0000000000000000\n[  533.441865] RDX: 0000000000000200 RSI: 0000000000000000 RDI: 0000000000000000\n[  533.789922] RBP: ffffb9b708df3a48 R08: ffff940d3b3fdd20 R09: 0000000000000000\n[  534.137512] R10: ffffb9b708df3958 R11: 0000000000000000 R12: 0000000000000000\n[  534.485329] R13: 0000000000000000 R14: 0000000000000000 R15: ffff940d39212020\n[  534.833319] FS:  00007efec26e3840(0000) GS:ffff940d1f480000(0000) knlGS:0000000000000000\n[  535.224098] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  535.504318] CR2: 0000000000000008 CR3: 0000001f4e256004 CR4: 00000000001606e0\n[  535.851759] Call Trace:\n[  535.970308]  ? mempool_alloc_slab+0x15/0x20\n[  536.174152]  ? bch_data_insert+0x42/0xd0 [bcache]\n[  536.403399]  blk_mq_make_request+0x97/0x4f0\n[  536.607036]  generic_make_request+0x1e2/0x410\n[  536.819164]  submit_bio+0x73/0x150\n[  536.980168]  ? submit_bio+0x73/0x150\n[  537.149731]  ? bio_associate_blkg_from_css+0x3b/0x60\n[  537.391595]  ? _cond_resched+0x1a/0x50\n[  537.573774]  submit_bio_wait+0x59/0x90\n[  537.756105]  blkdev_issue_discard+0x80/0xd0\n[  537.959590]  ext4_trim_fs+0x4a9/0x9e0\n[  538.137636]  ? ext4_trim_fs+0x4a9/0x9e0\n[  538.324087]  ext4_ioctl+0xea4/0x1530\n[  538.497712]  ? _copy_to_user+0x2a/0x40\n[  538.679632]  do_vfs_ioctl+0xa6/0x600\n[  538.853127]  ? __do_sys_newfstat+0x44/0x70\n[  539.051951]  ksys_ioctl+0x6d/0x80\n[  539.212785]  __x64_sys_ioctl+0x1a/0x20\n[  539.394918]  do_syscall_64+0x5a/0x110\n[  539.568674]  entry_SYSCALL_64_after_hwframe+0x44/0xa9\n\nWe have observed it where both:\n1) LVM/devmapper is involved (bcache backing device is LVM volume) and\n2) writeback cache is involved (bcache cache_mode is writeback)\n\nOn one machine, we can reliably reproduce it with:\n\n # echo writeback > /sys/block/bcache0/bcache/cache_mode\n   (not sure whether above line is required)\n # mount /dev/bcache0 /test\n # for i in {0..10}; do\n\tfile=\"$(mktemp /test/zero.XXX)\"\n\tdd if=/dev/zero of=\"$file\" bs=1M count=256\n\tsync\n\trm $file\n    done\n  # fstrim -v /test\n\nObserving this with tracepoints on, we see the following writes:\n\nfstrim-18019 [022] .... 91107.302026: bcache_write: 73f95583-561c-408f-a93a-4cbd2498f5c8 inode 0  DS 4260112 + 196352 hit 0 bypass 1\nfstrim-18019 [022] .... 91107.302050: bcache_write: 73f95583-561c-408f-a93a-4cbd2498f5c8 inode 0  DS 4456464 + 262144 hit 0 bypass 1\nfstrim-18019 [022] .... 91107.302075: bcache_write: 73f95583-561c-408f-a93a-4cbd2498f5c8 inode 0  DS 4718608 + 81920 hit 0 bypass 1\nfstrim-18019 [022] .... 91107.302094: bcache_write: 73f95583-561c-408f-a93a-4cbd2498f5c8 inode 0  DS 5324816 + 180224 hit 0 bypass 1\nfstrim-18019 [022] .... 91107.302121: bcache_write: 73f95583-561c-408f-a93a-4cbd2498f5c8 inode 0  DS 5505040 + 262144 hit 0 bypass 1\nfstrim-18019 [022] .... 91107.302145: bcache_write: 73f95583-561c-408f-a93a-4cbd2498f5c8 inode 0  DS 5767184 + 81920 hit 0 bypass 1\nfstrim-18019 [022] .... 91107.308777: bcache_write: 73f95583-561c-408f-a93a-4cbd2498f5c8 inode 0  DS 6373392 + 180224 hit 1 bypass 0\n<crash>\n\nNote the final one has different hit/bypass flags.\n\nThis is because in should_writeback(), we were hitting a case where\nthe partial stripe condition was returning true and so\nshould_writeback() was returning true early.\n\nIf that hadn't been the case, it would have hit the would_skip test, and\nas would_skip == s->iop.bypass == true, should_writeback() would have\nreturned false.\n\nLooking at the git history from 'commit 72c270612bd3 (\"bcache: Write out\nfull stripes\")', it looks like the idea was to optimise for raid5/6:\n\n       * If a stripe is already dirty, force writes to that stripe to\n\t writeback mode - to help build up full stripes of dirty data\n\nTo fix this issue, make sure that should_writeback() on a discard op\nnever returns true.\n\nMore details of debugging:\nhttps://www.spinics.net/lists/linux-bcache/msg06996.html\n\nPrevious reports:\n - https://bugzilla.kernel.org/show_bug.cgi?id=201051\n - https://bugzilla.kernel.org/show_bug.cgi?id=196103\n - https://www.spinics.net/lists/linux-bcache/msg06885.html\n\n(Coly Li: minor modification to follow maximum 75 chars per line rule)\n\nCc: Kent Overstreet <koverstreet@google.com>\nCc: stable@vger.kernel.org\nFixes: 72c270612bd3 (\"bcache: Write out full stripes\")\nSigned-off-by: Daniel Axtens <dja@axtens.net>\nSigned-off-by: Coly Li <colyli@suse.de>\nSigned-off-by: Jens Axboe <axboe@kernel.dk>",
        "before_after_code_files": [
          "drivers/md/bcache/writeback.h||drivers/md/bcache/writeback.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/md/bcache/writeback.h||drivers/md/bcache/writeback.h": [
          "File: drivers/md/bcache/writeback.h -> drivers/md/bcache/writeback.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "71:      in_use > bch_cutoff_writeback_sync)",
          "72:   return false;",
          "74:  if (dc->partial_stripes_expensive &&",
          "75:      bcache_dev_stripe_dirty(dc, bio->bi_iter.bi_sector,",
          "76:         bio_sectors(bio)))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "74:  if (bio_op(bio) == REQ_OP_DISCARD)",
          "75:   return false;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "a4cb5bdb754afe21f3e9e7164213e8600cf69427",
      "candidate_info": {
        "commit_hash": "a4cb5bdb754afe21f3e9e7164213e8600cf69427",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/a4cb5bdb754afe21f3e9e7164213e8600cf69427",
        "files": [
          "net/sunrpc/xprtrdma/verbs.c"
        ],
        "message": "xprtrdma: Make sure Send CQ is allocated on an existing compvec\n\nMake sure the device has at least 2 completion vectors\nbefore allocating to compvec#1\n\nFixes: a4699f5647f3 (xprtrdma: Put Send CQ in IB_POLL_WORKQUEUE mode)\nSigned-off-by: Nicolas Morey-Chaisemartin <nmoreychaisemartin@suse.com>\nReviewed-by: Chuck Lever <chuck.lever@oracle.com>\nSigned-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>",
        "before_after_code_files": [
          "net/sunrpc/xprtrdma/verbs.c||net/sunrpc/xprtrdma/verbs.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "net/sunrpc/xprtrdma/verbs.c||net/sunrpc/xprtrdma/verbs.c": [
          "File: net/sunrpc/xprtrdma/verbs.c -> net/sunrpc/xprtrdma/verbs.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "528:  sendcq = ib_alloc_cq(ia->ri_device, NULL,",
          "529:         ep->rep_attr.cap.max_send_wr + 1,",
          "531:  if (IS_ERR(sendcq)) {",
          "532:   rc = PTR_ERR(sendcq);",
          "533:   goto out1;",
          "",
          "[Removed Lines]",
          "530:         1, IB_POLL_WORKQUEUE);",
          "",
          "[Added Lines]",
          "530:         ia->ri_device->num_comp_vectors > 1 ? 1 : 0,",
          "531:         IB_POLL_WORKQUEUE);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "f25191bb322dec8fa2979ecb8235643aa42470e1",
      "candidate_info": {
        "commit_hash": "f25191bb322dec8fa2979ecb8235643aa42470e1",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/f25191bb322dec8fa2979ecb8235643aa42470e1",
        "files": [
          "drivers/cdrom/cdrom.c"
        ],
        "message": "cdrom: Fix race condition in cdrom_sysctl_register\n\nThe following traceback is sometimes seen when booting an image in qemu:\n\n[   54.608293] cdrom: Uniform CD-ROM driver Revision: 3.20\n[   54.611085] Fusion MPT base driver 3.04.20\n[   54.611877] Copyright (c) 1999-2008 LSI Corporation\n[   54.616234] Fusion MPT SAS Host driver 3.04.20\n[   54.635139] sysctl duplicate entry: /dev/cdrom//info\n[   54.639578] CPU: 0 PID: 266 Comm: kworker/u4:5 Not tainted 5.0.0-rc5 #1\n[   54.639578] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 0.0.0 02/06/2015\n[   54.641273] Workqueue: events_unbound async_run_entry_fn\n[   54.641273] Call Trace:\n[   54.641273]  dump_stack+0x67/0x90\n[   54.641273]  __register_sysctl_table+0x50b/0x570\n[   54.641273]  ? rcu_read_lock_sched_held+0x6f/0x80\n[   54.641273]  ? kmem_cache_alloc_trace+0x1c7/0x1f0\n[   54.646814]  __register_sysctl_paths+0x1c8/0x1f0\n[   54.646814]  cdrom_sysctl_register.part.7+0xc/0x5f\n[   54.646814]  register_cdrom.cold.24+0x2a/0x33\n[   54.646814]  sr_probe+0x4bd/0x580\n[   54.646814]  ? __driver_attach+0xd0/0xd0\n[   54.646814]  really_probe+0xd6/0x260\n[   54.646814]  ? __driver_attach+0xd0/0xd0\n[   54.646814]  driver_probe_device+0x4a/0xb0\n[   54.646814]  ? __driver_attach+0xd0/0xd0\n[   54.646814]  bus_for_each_drv+0x73/0xc0\n[   54.646814]  __device_attach+0xd6/0x130\n[   54.646814]  bus_probe_device+0x9a/0xb0\n[   54.646814]  device_add+0x40c/0x670\n[   54.646814]  ? __pm_runtime_resume+0x4f/0x80\n[   54.646814]  scsi_sysfs_add_sdev+0x81/0x290\n[   54.646814]  scsi_probe_and_add_lun+0x888/0xc00\n[   54.646814]  ? scsi_autopm_get_host+0x21/0x40\n[   54.646814]  __scsi_add_device+0x116/0x130\n[   54.646814]  ata_scsi_scan_host+0x93/0x1c0\n[   54.646814]  async_run_entry_fn+0x34/0x100\n[   54.646814]  process_one_work+0x237/0x5e0\n[   54.646814]  worker_thread+0x37/0x380\n[   54.646814]  ? rescuer_thread+0x360/0x360\n[   54.646814]  kthread+0x118/0x130\n[   54.646814]  ? kthread_create_on_node+0x60/0x60\n[   54.646814]  ret_from_fork+0x3a/0x50\n\nThe only sensible explanation is that cdrom_sysctl_register() is called\ntwice, once from the module init function and once from register_cdrom().\ncdrom_sysctl_register() is not mutex protected and may happily execute\ntwice if the second call is made before the first call is complete.\n\nUse a static atomic to ensure that the function is executed exactly once.\n\nSigned-off-by: Guenter Roeck <linux@roeck-us.net>\nSigned-off-by: Jens Axboe <axboe@kernel.dk>",
        "before_after_code_files": [
          "drivers/cdrom/cdrom.c||drivers/cdrom/cdrom.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/cdrom/cdrom.c||drivers/cdrom/cdrom.c": [
          "File: drivers/cdrom/cdrom.c -> drivers/cdrom/cdrom.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "268: #include <linux/module.h>",
          "269: #include <linux/fs.h>",
          "270: #include <linux/major.h>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "268: #include <linux/atomic.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3693: static void cdrom_sysctl_register(void)",
          "3694: {",
          "3698:   return;",
          "3700:  cdrom_sysctl_header = register_sysctl_table(cdrom_root_table);",
          "",
          "[Removed Lines]",
          "3695:  static int initialized;",
          "3697:  if (initialized == 1)",
          "",
          "[Added Lines]",
          "3696:  static atomic_t initialized = ATOMIC_INIT(0);",
          "3698:  if (!atomic_add_unless(&initialized, 1, 1))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3705:  cdrom_sysctl_settings.debug = debug;",
          "3706:  cdrom_sysctl_settings.lock = lockdoor;",
          "3707:  cdrom_sysctl_settings.check = check_media_type;",
          "3710: }",
          "3712: static void cdrom_sysctl_unregister(void)",
          "",
          "[Removed Lines]",
          "3709:  initialized = 1;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    }
  ]
}
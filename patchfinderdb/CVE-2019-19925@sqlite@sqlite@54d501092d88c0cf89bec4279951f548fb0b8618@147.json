{
  "cve_id": "CVE-2019-19925",
  "cve_desc": "zipfileUpdate in ext/misc/zipfile.c in SQLite 3.30.1 mishandles a NULL pathname during an update of a ZIP archive.",
  "repo": "sqlite/sqlite",
  "patch_hash": "54d501092d88c0cf89bec4279951f548fb0b8618",
  "patch_info": {
    "commit_hash": "54d501092d88c0cf89bec4279951f548fb0b8618",
    "repo": "sqlite/sqlite",
    "commit_url": "https://github.com/sqlite/sqlite/commit/54d501092d88c0cf89bec4279951f548fb0b8618",
    "files": [
      "ext/misc/zipfile.c",
      "manifest",
      "manifest.uuid",
      "test/zipfile.test"
    ],
    "message": "Fix the zipfile extension so that INSERT works even if the pathname of the file being inserted is a NULL.  Bug discovered by the Yongheng and Rui fuzzer.\n\nFossilOrigin-Name: a80f84b511231204658304226de3e075a55afc2e3f39ac063716f7a57f585c06",
    "before_after_code_files": [
      "ext/misc/zipfile.c||ext/misc/zipfile.c",
      "manifest.uuid||manifest.uuid",
      "test/zipfile.test||test/zipfile.test"
    ]
  },
  "patch_diff": {
    "ext/misc/zipfile.c||ext/misc/zipfile.c": [
      "File: ext/misc/zipfile.c -> ext/misc/zipfile.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1620:     if( rc==SQLITE_OK ){",
      "1621:       zPath = (const char*)sqlite3_value_text(apVal[2]);",
      "1622:       nPath = (int)strlen(zPath);",
      "1623:       mTime = zipfileGetTime(apVal[4]);",
      "1624:     }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1622:       if( zPath==0 ) zPath = \"\";",
      "",
      "---------------"
    ],
    "manifest.uuid||manifest.uuid": [
      "File: manifest.uuid -> manifest.uuid",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "1: fccfb8a9ed3c1df9f23762bb8df6fdf36a21118899e3fae41f451169a5f2c08e",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "test/zipfile.test||test/zipfile.test": [
      "File: test/zipfile.test -> test/zipfile.test",
      "--- Hunk 1 ---",
      "[Context before]",
      "795:   } {. ./x1.txt ./x2.txt}",
      "796: }",
      "798: finish_test",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "798: # 2019-12-18 Yongheng and Rui fuzzer",
      "799: #",
      "800: do_execsql_test 13.10 {",
      "801:   DROP TABLE IF EXISTS t0;",
      "802:   DROP TABLE IF EXISTS t1;",
      "803:   CREATE TABLE t0(a,b,c,d,e,f,g);",
      "804:   REPLACE INTO t0(c,b,f) VALUES(10,10,10);",
      "805:   CREATE VIRTUAL TABLE t1 USING zipfile('h.zip');",
      "806:   REPLACE INTO t1 SELECT * FROM t0;",
      "807:   SELECT quote(name),quote(mode),quote(mtime),quote(sz),quote(rawdata),",
      "808:          quote(data),quote(method) FROM t1;",
      "809: } {'' 10 10 2 X'3130' X'3130' 0}",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "fd15e18d7fe9bea571c52324a6eae25f3e2b4ebc",
      "candidate_info": {
        "commit_hash": "fd15e18d7fe9bea571c52324a6eae25f3e2b4ebc",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/fd15e18d7fe9bea571c52324a6eae25f3e2b4ebc",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/resolve.c",
          "src/select.c",
          "src/sqliteInt.h"
        ],
        "message": "Make sure any window definitions in an ORDER BY clause are removed from the SELECT statement if the ORDER BY clause gets optimized out.\n\nFossilOrigin-Name: 23b119671f0be3c6b72cf2dc5f7707a0626766db7aa56529ab00d33d1a0a1bee",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/resolve.c||src/resolve.c",
          "src/select.c||src/select.c",
          "src/sqliteInt.h||src/sqliteInt.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 2bf5a4c16457562dc942bcc6ec06d9b4e795ef3ea8e31550e18857bbebd08a76",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/resolve.c||src/resolve.c": [
          "File: src/resolve.c -> src/resolve.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1323: }",
          "",
          "[Removed Lines]",
          "1317: static void resolveRemoveWindows(Select *pSelect, Expr *pExpr){",
          "1318:   Walker sWalker;",
          "1319:   memset(&sWalker, 0, sizeof(Walker));",
          "1320:   sWalker.xExprCallback = resolveRemoveWindowsCb;",
          "1321:   sWalker.u.pSelect = pSelect;",
          "1322:   sqlite3WalkExpr(&sWalker, pExpr);",
          "1324: #else",
          "1325: # define resolveRemoveWindows(x,y)",
          "1326: #endif",
          "",
          "[Added Lines]",
          "1318: void sqlite3WindowRemoveExprFromSelect(Select *pSelect, Expr *pExpr){",
          "1319:   if( pSelect->pWin ){",
          "1320:     Walker sWalker;",
          "1321:     memset(&sWalker, 0, sizeof(Walker));",
          "1322:     sWalker.xExprCallback = resolveRemoveWindowsCb;",
          "1323:     sWalker.u.pSelect = pSelect;",
          "1324:     sqlite3WalkExpr(&sWalker, pExpr);",
          "1325:   }",
          "1332: void sqlite3WindowRemoveExprListFromSelect(Select *pSelect, ExprList *pList){",
          "1333:   if( pList && pSelect->pWin ){",
          "1334:     int i;",
          "1335:     Walker sWalker;",
          "1336:     memset(&sWalker, 0, sizeof(Walker));",
          "1337:     sWalker.xExprCallback = resolveRemoveWindowsCb;",
          "1338:     sWalker.u.pSelect = pSelect;",
          "1339:     for(i=0; i<pList->nExpr; i++){",
          "1340:       sqlite3WalkExpr(&sWalker, pList->a[i].pExpr);",
          "1341:     }",
          "1342:   }",
          "1343: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1398:         pItem->u.x.iOrderByCol = j+1;",
          "1399:       }",
          "1400:     }",
          "",
          "[Removed Lines]",
          "1397:         resolveRemoveWindows(pSelect, pE);",
          "",
          "[Added Lines]",
          "1415:         sqlite3WindowRemoveExprFromSelect(pSelect, pE);",
          "",
          "---------------"
        ],
        "src/select.c||src/select.c": [
          "File: src/select.c -> src/select.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "5661:            pDest->eDest==SRT_DistQueue || pDest->eDest==SRT_Fifo);",
          "5664:     sqlite3ExprListDelete(db, p->pOrderBy);",
          "5665:     p->pOrderBy = 0;",
          "5666:     p->selFlags &= ~SF_Distinct;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5664:     sqlite3WindowRemoveExprListFromSelect(p, p->pOrderBy);",
          "",
          "---------------"
        ],
        "src/sqliteInt.h||src/sqliteInt.h": [
          "File: src/sqliteInt.h -> src/sqliteInt.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "3627: void sqlite3WindowFunctions(void);",
          "3628: void sqlite3WindowChain(Parse*, Window*, Window*);",
          "3629: Window *sqlite3WindowAssemble(Parse*, Window*, ExprList*, ExprList*, Token*);",
          "3630: #else",
          "3631: # define sqlite3WindowDelete(a,b)",
          "3632: # define sqlite3WindowFunctions()",
          "3633: # define sqlite3WindowAttach(a,b,c)",
          "3634: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3630: void sqlite3WindowRemoveExprFromSelect(Select*,Expr*);",
          "3631: void sqlite3WindowRemoveExprListFromSelect(Select*,ExprList*);",
          "3636: # define sqlite3WindowRemoveExprFromSelect(Select*,Expr*);",
          "3637: # define sqlite3WindowRemoveExprListFromSelect(Select*,ExprList*);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "68cb86ef23e3bc9e6362fec4937968a65ec025b5",
      "candidate_info": {
        "commit_hash": "68cb86ef23e3bc9e6362fec4937968a65ec025b5",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/68cb86ef23e3bc9e6362fec4937968a65ec025b5",
        "files": [
          "ext/misc/dbdata.c",
          "main.mk",
          "manifest",
          "manifest.uuid",
          "src/shell.c.in",
          "tool/mkshellc.tcl"
        ],
        "message": "Add the \".recovery\" command to the shell tool. For recovering the maximum amount data from corrupt databases. Still needs work.\n\nFossilOrigin-Name: 7461d2e120f2149315ddac2676d51d7445bcdb8e97543effd9c30603517ef9da",
        "before_after_code_files": [
          "ext/misc/dbdata.c||ext/misc/dbdata.c",
          "main.mk||main.mk",
          "manifest.uuid||manifest.uuid",
          "src/shell.c.in||src/shell.c.in",
          "tool/mkshellc.tcl||tool/mkshellc.tcl"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "ext/misc/dbdata.c||ext/misc/dbdata.c": [
          "File: ext/misc/dbdata.c -> ext/misc/dbdata.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "67: #include \"sqlite3ext.h\"",
          "69: typedef unsigned char u8;",
          "72: #endif",
          "73: SQLITE_EXTENSION_INIT1",
          "",
          "[Removed Lines]",
          "66: #if !defined(SQLITEINT_H)",
          "70: typedef unsigned int u32;",
          "",
          "[Added Lines]",
          "66: #if !defined(SQLITEINT_H)",
          "70: typedef unsigned long u32;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "100: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "99:   u8 *pHdrPtr;",
          "100:   u8 *pPtr;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "306:   return 9;",
          "307: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "312: static int dbdataValueBytes(int eType){",
          "313:   switch( eType ){",
          "314:     case 0: case 8: case 9:",
          "315:     case 10: case 11:",
          "316:       return 0;",
          "317:     case 1:",
          "318:       return 1;",
          "319:     case 2:",
          "320:       return 2;",
          "321:     case 3:",
          "322:       return 3;",
          "323:     case 4:",
          "324:       return 4;",
          "325:     case 5:",
          "326:       return 6;",
          "327:     case 6:",
          "328:     case 7:",
          "329:       return 8;",
          "330:     default:",
          "331:       return ((eType-12) / 2);",
          "332:   }",
          "333: }",
          "335: static void dbdataValue(sqlite3_context *pCtx, int eType, u8 *pData){",
          "336:   switch( eType ){",
          "337:     case 0:",
          "338:     case 10:",
          "339:     case 11:",
          "340:       sqlite3_result_null(pCtx);",
          "341:       break;",
          "343:     case 8:",
          "344:       sqlite3_result_int(pCtx, 0);",
          "345:       break;",
          "346:     case 9:",
          "347:       sqlite3_result_int(pCtx, 1);",
          "348:       break;",
          "350:     case 1: case 2: case 3: case 4: case 5: case 6: case 7: {",
          "351:       sqlite3_uint64 v = (signed char)pData[0];",
          "352:       pData++;",
          "353:       switch( eType ){",
          "354:         case 7:",
          "355:         case 6:  v = (v<<16) + (pData[0]<<8) + pData[1];  pData += 2;",
          "356:         case 5:  v = (v<<16) + (pData[0]<<8) + pData[1];  pData += 2;",
          "357:         case 4:  v = (v<<8) + pData[0];  pData++;",
          "358:         case 3:  v = (v<<8) + pData[0];  pData++;",
          "359:         case 2:  v = (v<<8) + pData[0];  pData++;",
          "360:       }",
          "362:       if( eType==7 ){",
          "363:         double r;",
          "364:         memcpy(&r, &v, sizeof(r));",
          "365:         sqlite3_result_double(pCtx, r);",
          "366:       }else{",
          "367:         sqlite3_result_int64(pCtx, (sqlite3_int64)v);",
          "368:       }",
          "369:       break;",
          "370:     }",
          "372:     default: {",
          "373:       int n = ((eType-12) / 2);",
          "374:       if( eType % 2 ){",
          "375:         sqlite3_result_text(pCtx, (const char*)pData, n, SQLITE_TRANSIENT);",
          "376:       }else{",
          "377:         sqlite3_result_blob(pCtx, pData, n, SQLITE_TRANSIENT);",
          "378:       }",
          "379:     }",
          "380:   }",
          "381: }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "435:           }",
          "436:         }",
          "440:         iHdr = dbdataGetVarint(pCsr->pRec, &nHdr);",
          "445:         }",
          "448:       }",
          "",
          "[Removed Lines]",
          "439:         pCsr->nField = 0;",
          "441:         while( iHdr<nHdr ){",
          "442:           sqlite3_int64 iDummy;",
          "443:           iHdr += dbdataGetVarint(&pCsr->pRec[iHdr], &iDummy);",
          "444:           pCsr->nField++;",
          "447:         pCsr->iField = (bHasRowid ? -2 : -1);",
          "450:       pCsr->iField++;",
          "451:       if( pCsr->iField<pCsr->nField ) return SQLITE_OK;",
          "",
          "[Added Lines]",
          "514:         pCsr->nHdr = nHdr;",
          "515:         pCsr->pHdrPtr = &pCsr->pRec[iHdr];",
          "516:         pCsr->pPtr = &pCsr->pRec[pCsr->nHdr];",
          "517:         pCsr->iField = (bHasRowid ? -1 : 0);",
          "518:       }else{",
          "519:         pCsr->iField++;",
          "520:         if( pCsr->iField>0 ){",
          "521:           sqlite3_int64 iType;",
          "522:           pCsr->pHdrPtr += dbdataGetVarint(pCsr->pHdrPtr, &iType);",
          "523:           pCsr->pPtr += dbdataValueBytes(iType);",
          "527:       if( pCsr->iField<0 || pCsr->pHdrPtr<&pCsr->pRec[pCsr->nHdr] ){",
          "528:         return SQLITE_OK;",
          "529:       }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "485:   dbdataResetCursor(pCsr);",
          "486:   assert( pCsr->iPgno==1 );",
          "487:   if( idxNum & 0x01 ){",
          "489:   }",
          "490:   if( idxNum & 0x02 ){",
          "491:     pCsr->iPgno = sqlite3_value_int(argv[(idxNum & 0x01)]);",
          "",
          "[Removed Lines]",
          "488:     zSchema = sqlite3_value_text(argv[0]);",
          "",
          "[Added Lines]",
          "566:     zSchema = (const char*)sqlite3_value_text(argv[0]);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "498:   );",
          "499:   if( rc==SQLITE_OK ){",
          "500:     rc = sqlite3_bind_text(pCsr->pStmt, 1, zSchema, -1, SQLITE_TRANSIENT);",
          "501:   }",
          "502:   if( rc==SQLITE_OK ){",
          "503:     rc = dbdataNext(pCursor);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "579:   }else{",
          "580:     pTab->base.zErrMsg = sqlite3_mprintf(\"%s\", sqlite3_errmsg(pTab->db));",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "505:   return rc;",
          "506: }",
          "580: static int dbdataColumn(",
          "581:   sqlite3_vtab_cursor *pCursor,",
          "",
          "[Removed Lines]",
          "508: static int dbdataValueBytes(int eType){",
          "509:   switch( eType ){",
          "510:     case 0: case 8: case 9:",
          "511:     case 10: case 11:",
          "512:       return 0;",
          "513:     case 1:",
          "514:       return 1;",
          "515:     case 2:",
          "516:       return 2;",
          "517:     case 3:",
          "518:       return 3;",
          "519:     case 4:",
          "520:       return 4;",
          "521:     case 5:",
          "522:       return 6;",
          "523:     case 6:",
          "524:     case 7:",
          "525:       return 8;",
          "526:     default:",
          "527:       return ((eType-12) / 2);",
          "528:   }",
          "529: }",
          "531: static void dbdataValue(sqlite3_context *pCtx, int eType, u8 *pData){",
          "532:   switch( eType ){",
          "533:     case 0:",
          "534:     case 10:",
          "535:     case 11:",
          "536:       sqlite3_result_null(pCtx);",
          "537:       break;",
          "539:     case 8:",
          "540:       sqlite3_result_int(pCtx, 0);",
          "541:       break;",
          "542:     case 9:",
          "543:       sqlite3_result_int(pCtx, 1);",
          "544:       break;",
          "546:     case 1: case 2: case 3: case 4: case 5: case 6: case 7: {",
          "547:       sqlite3_uint64 v = (signed char)pData[0];",
          "548:       pData++;",
          "549:       switch( eType ){",
          "550:         case 7:",
          "551:         case 6:  v = (v<<16) + (pData[0]<<8) + pData[1];  pData += 2;",
          "552:         case 5:  v = (v<<16) + (pData[0]<<8) + pData[1];  pData += 2;",
          "553:         case 4:  v = (v<<8) + pData[0];  pData++;",
          "554:         case 3:  v = (v<<8) + pData[0];  pData++;",
          "555:         case 2:  v = (v<<8) + pData[0];  pData++;",
          "556:       }",
          "558:       if( eType==7 ){",
          "559:         double r;",
          "560:         memcpy(&r, &v, sizeof(r));",
          "561:         sqlite3_result_double(pCtx, r);",
          "562:       }else{",
          "563:         sqlite3_result_int64(pCtx, (sqlite3_int64)v);",
          "564:       }",
          "565:       break;",
          "566:     }",
          "568:     default: {",
          "569:       int n = ((eType-12) / 2);",
          "570:       if( eType % 2 ){",
          "571:         sqlite3_result_text(pCtx, pData, n, SQLITE_TRANSIENT);",
          "572:       }else{",
          "573:         sqlite3_result_blob(pCtx, pData, n, SQLITE_TRANSIENT);",
          "574:       }",
          "575:     }",
          "576:   }",
          "577: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "616:         if( pCsr->iField<0 ){",
          "617:           sqlite3_result_int64(ctx, pCsr->iIntkey);",
          "618:         }else{",
          "620:           sqlite3_int64 iType;",
          "631:         }",
          "632:         break;",
          "633:       }",
          "",
          "[Removed Lines]",
          "619:           int iHdr;",
          "621:           sqlite3_int64 iOff;",
          "622:           int i;",
          "623:           iHdr = dbdataGetVarint(pCsr->pRec, &iOff);",
          "624:           for(i=0; i<pCsr->iField; i++){",
          "625:             iHdr += dbdataGetVarint(&pCsr->pRec[iHdr], &iType);",
          "626:             iOff += dbdataValueBytes(iType);",
          "627:           }",
          "628:           dbdataGetVarint(&pCsr->pRec[iHdr], &iType);",
          "630:           dbdataValue(ctx, iType, &pCsr->pRec[iOff]);",
          "",
          "[Added Lines]",
          "629:           dbdataGetVarint(pCsr->pHdrPtr, &iType);",
          "630:           dbdataValue(ctx, iType, pCsr->pPtr);",
          "",
          "---------------"
        ],
        "main.mk||main.mk": [
          "File: main.mk -> main.mk",
          "--- Hunk 1 ---",
          "[Context before]",
          "738:  $(TOP)/ext/expert/sqlite3expert.h \\",
          "739:  $(TOP)/ext/misc/zipfile.c \\",
          "740:  $(TOP)/ext/misc/memtrace.c \\",
          "741:         $(TOP)/src/test_windirent.c",
          "743: shell.c: $(SHELL_SRC) $(TOP)/tool/mkshellc.tcl",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "741:  $(TOP)/ext/misc/dbdata.c \\",
          "",
          "---------------"
        ],
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 3213a15f2133afbb0a4fec3b8f6e0eeca8c0befafd6658c41074e84f589d5d32",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/shell.c.in||src/shell.c.in": [
          "File: src/shell.c.in -> src/shell.c.in",
          "--- Hunk 1 ---",
          "[Context before]",
          "948: INCLUDE ../ext/expert/sqlite3expert.h",
          "949: INCLUDE ../ext/expert/sqlite3expert.c",
          "951: #if defined(SQLITE_ENABLE_SESSION)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "951: INCLUDE ../ext/misc/dbdata.c",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3999:     sqlite3_fileio_init(p->db, 0, 0);",
          "4000:     sqlite3_shathree_init(p->db, 0, 0);",
          "4001:     sqlite3_completion_init(p->db, 0, 0);",
          "4002: #ifdef SQLITE_HAVE_ZLIB",
          "4003:     sqlite3_zipfile_init(p->db, 0, 0);",
          "4004:     sqlite3_sqlar_init(p->db, 0, 0);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4005:     sqlite3_dbdata_init(p->db, 0, 0);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6033: static void shellExec(sqlite3 *db, int *pRc, const char *zSql){",
          "6034:   int rc = *pRc;",
          "6035:   if( rc==SQLITE_OK ){",
          "6036:     char *zErr = 0;",
          "6037:     rc = sqlite3_exec(db, zSql, 0, 0, &zErr);",
          "6038:     if( rc!=SQLITE_OK ){",
          "6039:       raw_printf(stderr, \"SQL error: %s\\n\", zErr);",
          "6040:     }",
          "6042:   }",
          "6043: }",
          "6045: static void *shellMalloc(int *pRc, sqlite3_int64 nByte){",
          "6046:   void *pRet = 0;",
          "6047:   if( *pRc==SQLITE_OK ){",
          "6048:     pRet = sqlite3_malloc64(nByte);",
          "6049:     if( pRet==0 ){",
          "6051:     }else{",
          "6052:       memset(pRet, 0, nByte);",
          "6053:     }",
          "6054:   }",
          "6055:   return pRet;",
          "6056: }",
          "6058: static char *shellMPrintf(int *pRc, const char *zFmt, ...){",
          "6059:   char *z = 0;",
          "6060:   if( *pRc==SQLITE_OK ){",
          "6061:     va_list ap;",
          "6062:     va_start(ap, zFmt);",
          "6063:     z = sqlite3_vmprintf(zFmt, ap);",
          "6064:     va_end(ap);",
          "6065:     if( z==0 ){",
          "6067:     }",
          "6068:   }",
          "6069:   return z;",
          "6070: }",
          "6072: typedef struct RecoverTable RecoverTable;",
          "6073: struct RecoverTable {",
          "6079: };",
          "6084: static void recoverFreeTable(RecoverTable *pTab){",
          "6085:   if( pTab ){",
          "6086:     sqlite3_free(pTab->zName);",
          "6087:     sqlite3_free(pTab->zQuoted);",
          "6088:     sqlite3_free(pTab->zCreate);",
          "6089:     if( pTab->azlCol ){",
          "6090:       int i;",
          "6091:       for(i=0; i<pTab->nCol; i++){",
          "6092:         sqlite3_free(pTab->azlCol[i]);",
          "6093:       }",
          "6094:       sqlite3_free(pTab->azlCol);",
          "6095:     }",
          "6096:     sqlite3_free(pTab);",
          "6097:   }",
          "6098: }",
          "6100: static RecoverTable *recoverNewTable(",
          "6101:   ShellState *pState,",
          "6102:   int *pRc,",
          "6103:   int iRoot,",
          "6104:   int nCol",
          "6105: ){",
          "6106:   RecoverTable *pRet = 0;",
          "6108:   pRet = (RecoverTable*)shellMalloc(pRc, sizeof(RecoverTable));",
          "6109:   if( pRet ){",
          "6110:     sqlite3_stmt *pStmt = 0;",
          "6111:     pRet->zName = shellMPrintf(pRc, \"orphan_%d_%d\", nCol, iRoot);",
          "6112:     pRet->zQuoted = shellMPrintf(pRc, \"%Q\", pRet->zName);",
          "6113:     pRet->azlCol = (char**)shellMalloc(pRc, sizeof(char*) * nCol);",
          "6114:     pRet->nCol = nCol;",
          "6116:     shellPreparePrintf(pState->db, pRc, &pStmt,",
          "6117:       \"WITH s(i) AS (\"",
          "6118:       \"  SELECT 1 UNION ALL SELECT i+1 FROM s WHERE i<%d\"",
          "6119:       \")\"",
          "6120:       \"SELECT i-1, group_concat('c' || i, ', ') OVER (ORDER BY i) FROM s\",",
          "6121:       nCol",
          "6122:     );",
          "6123:     while( *pRc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pStmt) ){",
          "6124:       int idx = sqlite3_column_int(pStmt, 0);",
          "6125:       const char *zText = (const char*)sqlite3_column_text(pStmt, 1);",
          "6126:       pRet->azlCol[idx] = shellMPrintf(pRc, \"%s\", zText);",
          "6127:     }",
          "6128:     shellFinalize(pRc, pStmt);",
          "6130:     pRet->zCreate = shellMPrintf(pRc, \"CREATE TABLE %Q (id, %s)\",",
          "6131:         pRet->zName, pRet->azlCol[nCol-1]",
          "6132:     );",
          "6133:   }",
          "6135:   if( *pRc!=SQLITE_OK ){",
          "6136:     recoverFreeTable(pRet);",
          "6137:     pRet = 0;",
          "6138:   }",
          "6140:   return pRet;",
          "6141: }",
          "6148: static int recoverDatabaseCmd(ShellState *pState){",
          "6149:   const char *zSql;",
          "6150:   int rc = SQLITE_OK;",
          "6153:   shellExec(pState->db, &rc,",
          "6156:     \"ATTACH '' AS recovery;\"",
          "6157:     \"CREATE TABLE recovery.dbptr(\"",
          "6158:     \"      pgno, child, PRIMARY KEY(child, pgno)\"",
          "6159:     \") WITHOUT ROWID;\"",
          "6160:     \"INSERT OR IGNORE INTO dbptr(pgno, child) SELECT * FROM sqlite_dbptr;\"",
          "6164:     \"DELETE FROM recovery.dbptr WHERE child = 1;\"",
          "6169:     \"DELETE FROM recovery.dbptr WHERE child IN (\"",
          "6170:     \"  SELECT child FROM recovery.dbptr GROUP BY child HAVING count(*)>1\"",
          "6171:     \");\"",
          "6176:     \"CREATE TABLE recovery.map(pgno INTEGER PRIMARY KEY, maxlen INT, root INT);\"",
          "6181:     \"WITH pages(i, maxlen) AS (\"",
          "6182:     \"  SELECT page_count, max(field+1) \"",
          "6183:     \"      FROM pragma_page_count, sqlite_dbdata WHERE pgno=page_count\"",
          "6184:     \"    UNION ALL\"",
          "6185:     \"  SELECT * FROM (SELECT i-1, max(field+1)\"",
          "6186:     \"      FROM pages, sqlite_dbdata WHERE pgno=i-1 AND i>=2)\"",
          "6187:     \")\"",
          "6188:     \"INSERT INTO recovery.map(pgno, maxlen, root) SELECT i, maxlen, (\"",
          "6189:     \"    WITH p(orig, pgno, parent) AS (\"",
          "6190:     \"      SELECT 0, i, (SELECT pgno FROM recovery.dbptr WHERE child=i)\"",
          "6191:     \"        UNION ALL\"",
          "6192:     \"      SELECT i, p.parent, \"",
          "6193:     \"        (SELECT pgno FROM recovery.dbptr WHERE child=p.parent) FROM p\"",
          "6194:     \"    )\"",
          "6195:     \"    SELECT pgno FROM p WHERE (parent IS NULL OR pgno = orig)\"",
          "6196:     \") \"",
          "6197:     \"FROM pages WHERE maxlen > 0;\"",
          "6201:     \"CREATE TABLE recovery.schema(type, name, tbl_name, rootpage, sql);\"",
          "6202:     \"INSERT INTO recovery.schema SELECT \"",
          "6203:     \"  max(CASE WHEN field=0 THEN value ELSE NULL END),\"",
          "6204:     \"  max(CASE WHEN field=1 THEN value ELSE NULL END),\"",
          "6205:     \"  max(CASE WHEN field=2 THEN value ELSE NULL END),\"",
          "6206:     \"  max(CASE WHEN field=3 THEN value ELSE NULL END),\"",
          "6207:     \"  max(CASE WHEN field=4 THEN value ELSE NULL END)\"",
          "6208:     \"FROM sqlite_dbdata WHERE pgno IN (\"",
          "6209:     \"  SELECT pgno FROM recovery.map WHERE root=1\"",
          "6210:     \")\"",
          "6211:     \"GROUP BY pgno, cell;\"",
          "6212:   );",
          "6214: #if 0",
          "6215:   zSql = \"SELECT type ||','|| name ||','|| tbl_name ||','|| rootpage ||','|| sql FROM recovery.schema;\";",
          "6216:   shellPrepare(pState->db, &rc, zSql, &pLoop);",
          "6217:   while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pLoop) ){",
          "6218:     raw_printf(pState->out, \"%s\\n\", (const char*)sqlite3_column_text(pLoop, 0));",
          "6219:   }",
          "6220:   shellFinalize(&rc, pLoop);",
          "6221:   return rc;",
          "6222: #endif",
          "6225:   zSql = \"SELECT root,max(maxlen) FROM recovery.map WHERE root>1 GROUP BY root\";",
          "6226:   shellPrepare(pState->db, &rc, zSql, &pLoop);",
          "6227:   while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pLoop) ){",
          "6228:     int iRoot = sqlite3_column_int(pLoop, 0);",
          "6229:     int nCol = sqlite3_column_int(pLoop, 1);",
          "6230:     RecoverTable *pTab;",
          "6232:     pTab = recoverNewTable(pState, &rc, iRoot, nCol);",
          "6233:     if( pTab ){",
          "6234:       sqlite3_stmt *pData = 0;",
          "6235:       raw_printf(pState->out, \"%s;\\n\", pTab->zCreate);",
          "6236:       shellPreparePrintf(pState->db, &rc, &pData,",
          "6237:         \"SELECT max(field), group_concat(quote(value), ', ') \"",
          "6238:         \"FROM sqlite_dbdata WHERE pgno IN (\"",
          "6239:         \"  SELECT pgno FROM recovery.map WHERE root=%d\"",
          "6240:         \")\"",
          "6241:         \"GROUP BY pgno, cell;\", iRoot",
          "6242:       );",
          "6243:       while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pData) ){",
          "6244:         int iMax = sqlite3_column_int(pData, 0);",
          "6245:         const char *zVal = (const char*)sqlite3_column_text(pData, 1);",
          "6246:         if( iMax+1==pTab->nCol ){",
          "6247:           raw_printf(pState->out, \"INSERT INTO %s VALUES( %s );\\n\",",
          "6248:               pTab->zQuoted, zVal);",
          "6249:         }else{",
          "6250:           raw_printf(pState->out, \"INSERT INTO %s(%s) VALUES( %s );\\n\",",
          "6251:               pTab->zQuoted, pTab->azlCol[iMax], zVal",
          "6252:           );",
          "6253:         }",
          "6254:       }",
          "6255:       shellFinalize(&rc, pData);",
          "6256:     }",
          "6257:     recoverFreeTable(pTab);",
          "6258:   }",
          "6259:   shellFinalize(&rc, pLoop);",
          "6261:   sqlite3_exec(pState->db, \"DETACH recovery\", 0, 0, 0);",
          "6262:   return rc;",
          "6263: }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "6313:     rc = shell_dbinfo_command(p, nArg, azArg);",
          "6314:   }else",
          "6316:   if( c=='d' && strncmp(azArg[0], \"dump\", n)==0 ){",
          "6317:     const char *zLike = 0;",
          "6318:     int i;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6552:   if( c=='r' && strncmp(azArg[0], \"recover\", n)==0 ){",
          "6553:     open_db(p, 0);",
          "6554:     rc = recoverDatabaseCmd(p);",
          "6555:   }else",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "6365:     p->nErr = 0;",
          "6366:     if( zLike==0 ){",
          "6367:       run_schema_dump_query(p,",
          "6371:       run_schema_dump_query(p,",
          "6375:       run_table_dump_query(p,",
          "6379:     }else{",
          "6380:       char *zSql;",
          "6381:       zSql = sqlite3_mprintf(",
          "6385:       run_schema_dump_query(p,zSql);",
          "6386:       sqlite3_free(zSql);",
          "6387:       zSql = sqlite3_mprintf(",
          "6392:       run_table_dump_query(p, zSql, 0);",
          "6393:       sqlite3_free(zSql);",
          "6394:     }",
          "",
          "[Removed Lines]",
          "6368:         \"SELECT name, type, sql FROM sqlite_master \"",
          "6369:         \"WHERE sql NOT NULL AND type=='table' AND name!='sqlite_sequence'\"",
          "6370:       );",
          "6372:         \"SELECT name, type, sql FROM sqlite_master \"",
          "6373:         \"WHERE name=='sqlite_sequence'\"",
          "6374:       );",
          "6376:         \"SELECT sql FROM sqlite_master \"",
          "6377:         \"WHERE sql NOT NULL AND type IN ('index','trigger','view')\", 0",
          "6378:       );",
          "6382:         \"SELECT name, type, sql FROM sqlite_master \"",
          "6383:         \"WHERE tbl_name LIKE %Q AND type=='table'\"",
          "6384:         \"  AND sql NOT NULL\", zLike);",
          "6388:         \"SELECT sql FROM sqlite_master \"",
          "6389:         \"WHERE sql NOT NULL\"",
          "6390:         \"  AND type IN ('index','trigger','view')\"",
          "6391:         \"  AND tbl_name LIKE %Q\", zLike);",
          "",
          "[Added Lines]",
          "6611:           \"SELECT name, type, sql FROM sqlite_master \"",
          "6612:           \"WHERE sql NOT NULL AND type=='table' AND name!='sqlite_sequence'\"",
          "6613:           );",
          "6615:           \"SELECT name, type, sql FROM sqlite_master \"",
          "6616:           \"WHERE name=='sqlite_sequence'\"",
          "6617:           );",
          "6619:           \"SELECT sql FROM sqlite_master \"",
          "6620:           \"WHERE sql NOT NULL AND type IN ('index','trigger','view')\", 0",
          "6621:           );",
          "6625:           \"SELECT name, type, sql FROM sqlite_master \"",
          "6626:           \"WHERE tbl_name LIKE %Q AND type=='table'\"",
          "6627:           \"  AND sql NOT NULL\", zLike);",
          "6631:           \"SELECT sql FROM sqlite_master \"",
          "6632:           \"WHERE sql NOT NULL\"",
          "6633:           \"  AND type IN ('index','trigger','view')\"",
          "6634:           \"  AND tbl_name LIKE %Q\", zLike);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "6398:     }",
          "6399:     sqlite3_exec(p->db, \"PRAGMA writable_schema=OFF;\", 0, 0, 0);",
          "6400:     sqlite3_exec(p->db, \"RELEASE dump;\", 0, 0, 0);",
          "6402:     p->showHeader = savedShowHeader;",
          "6403:     p->shellFlgs = savedShellFlags;",
          "6404:   }else",
          "",
          "[Removed Lines]",
          "6401:     raw_printf(p->out, p->nErr ? \"ROLLBACK; -- due to errors\\n\" : \"COMMIT;\\n\");",
          "",
          "[Added Lines]",
          "6644:     raw_printf(p->out, p->nErr?\"ROLLBACK; -- due to errors\\n\":\"COMMIT;\\n\");",
          "",
          "---------------"
        ],
        "tool/mkshellc.tcl||tool/mkshellc.tcl": [
          "File: tool/mkshellc.tcl -> tool/mkshellc.tcl",
          "--- Hunk 1 ---",
          "[Context before]",
          "40:   }",
          "41:   return $line",
          "42: }",
          "43: while {1} {",
          "44:   set lx [omit_redundant_typedefs [gets $in]]",
          "45:   if {[eof $in]} break;",
          "46:   if {[regexp {^INCLUDE } $lx]} {",
          "47:     set cfile [lindex $lx 1]",
          "48:     puts $out \"/************************* Begin $cfile ******************/\"",
          "49:     set in2 [open $topdir/src/$cfile rb]",
          "50:     while {![eof $in2]} {",
          "51:       set lx [omit_redundant_typedefs [gets $in2]]",
          "53:       if {[regexp {^# *include \"test_windirent.h\"} $lx]} {",
          "54:         set lx \"/* $lx */\"",
          "55:       }",
          "",
          "[Removed Lines]",
          "52:       if {[regexp {^#include \"sqlite} $lx]} continue",
          "",
          "[Added Lines]",
          "43: set iLine 0",
          "47:   incr iLine",
          "51:     puts $out \"#line 1 \\\"$cfile\\\"\"",
          "55:       if {[regexp {^#include \"sqlite} $lx]} {",
          "56:         set lx \"/* $lx */\"",
          "57:       }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "58:     }",
          "59:     close $in2",
          "60:     puts $out \"/************************* End $cfile ********************/\"",
          "61:     continue",
          "62:   }",
          "63:   puts $out $lx",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "66:     puts $out \"#line [expr $iLine+1] \\\"shell.c.in\\\"\"",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "ad84bd849e00917b9007edea4521da48a6a00ed1",
      "candidate_info": {
        "commit_hash": "ad84bd849e00917b9007edea4521da48a6a00ed1",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/ad84bd849e00917b9007edea4521da48a6a00ed1",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/dbstat.c",
          "test/stat.test"
        ],
        "message": "Begin an enhancement effort for the built-in DBSTAT virtual table.\n\nFossilOrigin-Name: 9b5722f0fe666b99677e5f333dd8413aefb9ace7a461d74f6558f0ac53768719",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/dbstat.c||src/dbstat.c",
          "test/stat.test||test/stat.test"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 4330f0795dbc2ab41dddd41d5979331fb9b78c477c66367c4be52f929531a45f",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/dbstat.c||src/dbstat.c": [
          "File: src/dbstat.c -> src/dbstat.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "72:   \");\"",
          "75: typedef struct StatTable StatTable;",
          "76: typedef struct StatCursor StatCursor;",
          "77: typedef struct StatPage StatPage;",
          "78: typedef struct StatCell StatCell;",
          "80: struct StatCell {",
          "",
          "[Removed Lines]",
          "59: #define VTAB_SCHEMA                                                         \\",
          "60:   \"CREATE TABLE xx( \"                                                       \\",
          "61:   \"  name       TEXT,             /* Name of table or index */\"             \\",
          "62:   \"  path       TEXT,             /* Path to page from root */\"             \\",
          "63:   \"  pageno     INTEGER,          /* Page number */\"                        \\",
          "64:   \"  pagetype   TEXT,             /* 'internal', 'leaf' or 'overflow' */\"   \\",
          "65:   \"  ncell      INTEGER,          /* Cells on page (0 for overflow) */\"     \\",
          "66:   \"  payload    INTEGER,          /* Bytes of payload on this page */\"      \\",
          "67:   \"  unused     INTEGER,          /* Bytes of unused space on this page */\" \\",
          "68:   \"  mx_payload INTEGER,          /* Largest payload size of all cells */\"  \\",
          "69:   \"  pgoffset   INTEGER,          /* Offset of page in file */\"             \\",
          "70:   \"  pgsize     INTEGER,          /* Size of the page */\"                   \\",
          "71:   \"  schema     TEXT HIDDEN       /* Database schema being analyzed */\"     \\",
          "",
          "[Added Lines]",
          "59: #define VTAB_SCHEMA                                                          \\",
          "60:   \"CREATE TABLE xx( \"                                                        \\",
          "61:   \"  name       TEXT,\"          /*  0 Name of table or index */              \\",
          "62:   \"  path       TEXT,\"          /*  1 Path to page from root */              \\",
          "63:   \"  pageno     INTEGER,\"       /*  2 Page number */                         \\",
          "64:   \"  pagetype   TEXT,\"          /*  3 'internal', 'leaf' or 'overflow' */    \\",
          "65:   \"  ncell      INTEGER,\"       /*  4 Cells on page (0 for overflow) */      \\",
          "66:   \"  payload    INTEGER,\"       /*  5 Bytes of payload on this page */       \\",
          "67:   \"  unused     INTEGER,\"       /*  6 Bytes of unused space on this page */  \\",
          "68:   \"  mx_payload INTEGER,\"       /*  7 Largest payload size of all cells */   \\",
          "69:   \"  pgoffset   INTEGER,\"       /*  8 Offset of page in file */              \\",
          "70:   \"  pgsize     INTEGER,\"       /*  9 Size of the page */                    \\",
          "71:   \"  schema     TEXT HIDDEN,\"   /* 10 Database schema being analyzed */      \\",
          "72:   \"  aggregate  BOOLEAN HIDDEN\" /* 11 aggregate info for each table */       \\",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "87: };",
          "89: struct StatPage {",
          "",
          "[Removed Lines]",
          "90:   u32 iPgno;",
          "91:   DbPage *pPg;",
          "92:   int iCell;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "103: };",
          "105: struct StatCursor {",
          "",
          "[Removed Lines]",
          "106:   sqlite3_vtab_cursor base;",
          "111:   StatPage aPage[32];",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "125: };",
          "127: struct StatTable {",
          "131: };",
          "",
          "[Removed Lines]",
          "128:   sqlite3_vtab base;",
          "129:   sqlite3 *db;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "185: }",
          "194: static int statBestIndex(sqlite3_vtab *tab, sqlite3_index_info *pIdxInfo){",
          "195:   int i;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "205:   int iSchema = -1;",
          "206:   int iName = -1;",
          "207:   int iAgg = -1;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "202:   for(i=0; i<pIdxInfo->nConstraint; i++){",
          "205:     if( pIdxInfo->aConstraint[i].op!=SQLITE_INDEX_CONSTRAINT_EQ ) continue;",
          "211:   }",
          "",
          "[Removed Lines]",
          "203:     if( pIdxInfo->aConstraint[i].iColumn!=10 ) continue;",
          "204:     if( pIdxInfo->aConstraint[i].usable==0 ) return SQLITE_CONSTRAINT;",
          "206:     pIdxInfo->idxNum = 1;",
          "207:     pIdxInfo->estimatedCost = 1.0;",
          "208:     pIdxInfo->aConstraintUsage[i].argvIndex = 1;",
          "209:     pIdxInfo->aConstraintUsage[i].omit = 1;",
          "210:     break;",
          "",
          "[Added Lines]",
          "216:     if( pIdxInfo->aConstraint[i].usable==0 ){",
          "218:       return SQLITE_CONSTRAINT;",
          "219:     }",
          "220:     switch( pIdxInfo->aConstraint[i].iColumn ){",
          "222:         iName = i;",
          "223:         break;",
          "224:       }",
          "226:         iSchema = i;",
          "227:         break;",
          "228:       }",
          "230:         iAgg = i;",
          "231:         break;",
          "232:       }",
          "233:     }",
          "235:   i = 0;",
          "236:   if( iSchema>=0 ){",
          "237:     pIdxInfo->aConstraintUsage[iSchema].argvIndex = ++i;",
          "238:     pIdxInfo->aConstraintUsage[iSchema].omit = 1;",
          "239:     pIdxInfo->idxNum |= 0x01;",
          "240:   }",
          "241:   if( iName>=0 ){",
          "242:     pIdxInfo->aConstraintUsage[iName].argvIndex = ++i;",
          "243:     pIdxInfo->aConstraintUsage[iName].omit = 1;",
          "244:     pIdxInfo->idxNum |= 0x02;",
          "245:   }",
          "246:   if( iAgg>=0 ){",
          "247:     pIdxInfo->aConstraintUsage[iAgg].argvIndex = ++i;",
          "248:     pIdxInfo->aConstraintUsage[iAgg].omit = 1;",
          "249:     pIdxInfo->idxNum |= 0x04;",
          "250:   }",
          "251:   pIdxInfo->estimatedCost = 1.0;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "227:      )",
          "228:   ){",
          "229:     pIdxInfo->orderByConsumed = 1;",
          "230:   }",
          "232:   return SQLITE_OK;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "269:     pIdxInfo->idxNum |= 0x08;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "294:   return SQLITE_OK;",
          "295: }",
          "302: ){",
          "303:   int nLocal;",
          "304:   int nMinLocal;",
          "",
          "[Removed Lines]",
          "297: static void getLocalPayload(",
          "",
          "[Added Lines]",
          "342: static int getLocalPayload(",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "315:   nLocal = nMinLocal + (nTotal - nMinLocal) % (nUsable - 4);",
          "316:   if( nLocal>nMaxLocal ) nLocal = nMinLocal;",
          "318: }",
          "320: static int statDecodePage(Btree *pBt, StatPage *p){",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "361:   return nLocal;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "387:           iOff += sqlite3GetVarint(&aData[iOff], &dummy);",
          "388:         }",
          "389:         if( nPayload>(u32)p->nMxPayload ) p->nMxPayload = nPayload;",
          "391:         if( nLocal<0 ) goto statPageIsCorrupt;",
          "392:         pCell->nLocal = nLocal;",
          "393:         assert( nPayload>=(u32)nLocal );",
          "",
          "[Removed Lines]",
          "390:         getLocalPayload(nUsable, p->flags, nPayload, &nLocal);",
          "",
          "[Added Lines]",
          "434:         nLocal = getLocalPayload(nUsable, p->flags, nPayload);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "604: ){",
          "605:   StatCursor *pCsr = (StatCursor *)pCursor;",
          "606:   StatTable *pTab = (StatTable*)(pCursor->pVtab);",
          "612:     pCsr->iDb = sqlite3FindDbName(pTab->db, zDbase);",
          "613:     if( pCsr->iDb<0 ){",
          "614:       sqlite3_free(pCursor->pVtab->zErrMsg);",
          "",
          "[Removed Lines]",
          "607:   char *zSql;",
          "608:   int rc = SQLITE_OK;",
          "610:   if( idxNum==1 ){",
          "611:     const char *zDbase = (const char*)sqlite3_value_text(argv[0]);",
          "",
          "[Added Lines]",
          "661:   statResetCsr(pCsr);",
          "662:   sqlite3_finalize(pCsr->pStmt);",
          "663:   pCsr->pStmt = 0;",
          "664:   if( idxNum & 0x01 ){",
          "666:     const char *zDbase = (const char*)sqlite3_value_text(argv[iArg++]);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "618:   }else{",
          "619:     pCsr->iDb = pTab->iDb;",
          "620:   }",
          "630:   if( zSql==0 ){",
          "631:     return SQLITE_NOMEM_BKPT;",
          "632:   }else{",
          "",
          "[Removed Lines]",
          "621:   statResetCsr(pCsr);",
          "622:   sqlite3_finalize(pCsr->pStmt);",
          "623:   pCsr->pStmt = 0;",
          "624:   zSql = sqlite3_mprintf(",
          "625:       \"SELECT 'sqlite_master' AS name, 1 AS rootpage, 'table' AS type\"",
          "626:       \"  UNION ALL  \"",
          "627:       \"SELECT name, rootpage, type\"",
          "628:       \"  FROM \\\"%w\\\".sqlite_master WHERE rootpage!=0\"",
          "629:       \"  ORDER BY name\", pTab->db->aDb[pCsr->iDb].zDbSName);",
          "",
          "[Added Lines]",
          "676:   if( idxNum & 0x02 ){",
          "678:     zName = (const char*)sqlite3_value_text(argv[iArg++]);",
          "679:   }",
          "680:   if( idxNum & 0x04 ){",
          "682:     pCsr->isAgg = sqlite3_value_double(argv[iArg++])!=0.0;",
          "683:   }else{",
          "684:     pCsr->isAgg = 0;",
          "685:   }",
          "686:   pSql = sqlite3_str_new(pTab->db);",
          "687:   sqlite3_str_appendf(pSql,",
          "688:       \"SELECT * FROM (\"",
          "689:         \"SELECT 'sqlite_master' AS name,1 AS rootpage,'table' AS type\"",
          "690:         \" UNION ALL \"",
          "691:         \"SELECT name,rootpage,type\"",
          "692:         \" FROM \\\"%w\\\".sqlite_master WHERE rootpage!=0)\",",
          "693:       pTab->db->aDb[pCsr->iDb].zDbSName);",
          "694:   if( zName ){",
          "695:     sqlite3_str_appendf(pSql, \"WHERE name=%Q\", zName);",
          "696:   }",
          "697:   if( idxNum & 0x08 ){",
          "698:     sqlite3_str_appendf(pSql, \" ORDER BY name\");",
          "699:   }",
          "700:   zSql = sqlite3_str_finish(pSql);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "678:       sqlite3_result_int(ctx, pCsr->szPage);",
          "679:       break;",
          "681:       sqlite3 *db = sqlite3_context_db_handle(ctx);",
          "682:       int iDb = pCsr->iDb;",
          "683:       sqlite3_result_text(ctx, db->aDb[iDb].zDbSName, -1, SQLITE_STATIC);",
          "684:       break;",
          "685:     }",
          "686:   }",
          "687:   return SQLITE_OK;",
          "688: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "758:       sqlite3_result_int(ctx, pCsr->isAgg);",
          "759:       break;",
          "760:     }",
          "",
          "---------------"
        ],
        "test/stat.test||test/stat.test": [
          "File: test/stat.test -> test/stat.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "108:   INSERT INTO t3 SELECT a_string(110+rowid), a_string(221+rowid) FROM t3",
          "109:    ORDER BY rowid;",
          "110:   SELECT name, path, pageno, pagetype, ncell, payload, unused, mx_payload",
          "112: } [list \\",
          "113:   sqlite_autoindex_t3_1 / 3 internal 3 368 623 125       \\",
          "114:   sqlite_autoindex_t3_1 /000/ 8 leaf 8 946 46 123        \\",
          "",
          "[Removed Lines]",
          "111:     FROM stat WHERE name != 'sqlite_master';",
          "",
          "[Added Lines]",
          "111:     FROM stat WHERE name != 'sqlite_master' ORDER BY name;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "150:   CREATE INDEX i4 ON t4(x);",
          "151:   INSERT INTO t4(rowid, x) VALUES(2, a_string(7777));",
          "152:   SELECT name, path, pageno, pagetype, ncell, payload, unused, mx_payload",
          "154: } [list \\",
          "155:   i4 / 3 leaf 1 103 905 7782                 \\",
          "156:   i4 /000+000000 4 overflow 0 1020 0 0       \\",
          "",
          "[Removed Lines]",
          "153:     FROM stat WHERE name != 'sqlite_master';",
          "",
          "[Added Lines]",
          "153:     FROM stat WHERE name != 'sqlite_master' ORDER BY name;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "c075c505f30b91e3de18fb2a058e2e6d6fd7aead",
      "candidate_info": {
        "commit_hash": "c075c505f30b91e3de18fb2a058e2e6d6fd7aead",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/c075c505f30b91e3de18fb2a058e2e6d6fd7aead",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/parse.y"
        ],
        "message": "Fix parser bugs: require a semicolon after an EXPLAIN command.\n\nFossilOrigin-Name: 707a058a22bd00ef14431cee0d02048cf1be745c0ef5254eda76c325435738ff",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/parse.y||src/parse.y"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 355afd77df21a2265871ca6d075f26b1fa121c7c2682cf512281944ff0c2186d",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/parse.y||src/parse.y": [
          "File: src/parse.y -> src/parse.y",
          "--- Hunk 1 ---",
          "[Context before]",
          "120: ecmd ::= SEMI.",
          "121: ecmd ::= cmdx SEMI.",
          "122: %ifndef SQLITE_OMIT_EXPLAIN",
          "124: explain ::= EXPLAIN.              { pParse->explain = 1; }",
          "125: explain ::= EXPLAIN QUERY PLAN.   { pParse->explain = 2; }",
          "126: %endif  SQLITE_OMIT_EXPLAIN",
          "",
          "[Removed Lines]",
          "123: ecmd ::= explain cmdx.",
          "",
          "[Added Lines]",
          "123: ecmd ::= explain cmdx SEMI.",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "1c269a9ff844bb85943d59eb8cf6c6b10e51e305",
      "candidate_info": {
        "commit_hash": "1c269a9ff844bb85943d59eb8cf6c6b10e51e305",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/1c269a9ff844bb85943d59eb8cf6c6b10e51e305",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/btree.c"
        ],
        "message": "Remove a NEVER() that is reachable from a corrupt database.\n\nFossilOrigin-Name: 30e6ee27a9fb78291c324ac9b80db4579280140430804ecd4692e312f9938525",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/btree.c||src/btree.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 7f2246a17be9915b3492624a3d8deff56694bdc372f7627e3f16c1869415b1a3",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/btree.c||src/btree.c": [
          "File: src/btree.c -> src/btree.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "6900:   assert( i<iEnd );",
          "6901:   j = get2byte(&aData[hdr+5]);",
          "6903:   memcpy(&pTmp[j], &aData[j], usableSize - j);",
          "6905:   for(k=0; pCArray->ixNx[k]<=i && ALWAYS(k<NB*2); k++){}",
          "",
          "[Removed Lines]",
          "6902:   if( NEVER(j>(u32)usableSize) ){ j = 0; }",
          "",
          "[Added Lines]",
          "6902:   if( j>(u32)usableSize ){ j = 0; }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
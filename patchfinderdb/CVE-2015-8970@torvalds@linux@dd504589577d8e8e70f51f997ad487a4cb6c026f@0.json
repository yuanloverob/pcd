{
  "cve_id": "CVE-2015-8970",
  "cve_desc": "crypto/algif_skcipher.c in the Linux kernel before 4.4.2 does not verify that a setkey operation has been performed on an AF_ALG socket before an accept system call is processed, which allows local users to cause a denial of service (NULL pointer dereference and system crash) via a crafted application that does not supply a key, related to the lrw_crypt function in crypto/lrw.c.",
  "repo": "torvalds/linux",
  "patch_hash": "dd504589577d8e8e70f51f997ad487a4cb6c026f",
  "patch_info": {
    "commit_hash": "dd504589577d8e8e70f51f997ad487a4cb6c026f",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/dd504589577d8e8e70f51f997ad487a4cb6c026f",
    "files": [
      "crypto/algif_skcipher.c"
    ],
    "message": "crypto: algif_skcipher - Require setkey before accept(2)\n\nSome cipher implementations will crash if you try to use them\nwithout calling setkey first.  This patch adds a check so that\nthe accept(2) call will fail with -ENOKEY if setkey hasn't been\ndone on the socket yet.\n\nCc: stable@vger.kernel.org\nReported-by: Dmitry Vyukov <dvyukov@google.com>\nSigned-off-by: Herbert Xu <herbert@gondor.apana.org.au>\nTested-by: Dmitry Vyukov <dvyukov@google.com>",
    "before_after_code_files": [
      "crypto/algif_skcipher.c||crypto/algif_skcipher.c"
    ]
  },
  "patch_diff": {
    "crypto/algif_skcipher.c||crypto/algif_skcipher.c": [
      "File: crypto/algif_skcipher.c -> crypto/algif_skcipher.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "31:  struct scatterlist sg[0];",
      "32: };",
      "34: struct skcipher_ctx {",
      "35:  struct list_head tsgl;",
      "36:  struct af_alg_sgl rsgl;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "34: struct skcipher_tfm {",
      "35:  struct crypto_skcipher *skcipher;",
      "36:  bool has_key;",
      "37: };",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "751: static void *skcipher_bind(const char *name, u32 type, u32 mask)",
      "752: {",
      "754: }",
      "756: static void skcipher_release(void *private)",
      "757: {",
      "759: }",
      "761: static int skcipher_setkey(void *private, const u8 *key, unsigned int keylen)",
      "762: {",
      "764: }",
      "766: static void skcipher_wait(struct sock *sk)",
      "",
      "[Removed Lines]",
      "753:  return crypto_alloc_skcipher(name, type, mask);",
      "758:  crypto_free_skcipher(private);",
      "763:  return crypto_skcipher_setkey(private, key, keylen);",
      "",
      "[Added Lines]",
      "758:  struct skcipher_tfm *tfm;",
      "759:  struct crypto_skcipher *skcipher;",
      "761:  tfm = kzalloc(sizeof(*tfm), GFP_KERNEL);",
      "762:  if (!tfm)",
      "763:   return ERR_PTR(-ENOMEM);",
      "765:  skcipher = crypto_alloc_skcipher(name, type, mask);",
      "766:  if (IS_ERR(skcipher)) {",
      "767:   kfree(tfm);",
      "768:   return ERR_CAST(skcipher);",
      "769:  }",
      "771:  tfm->skcipher = skcipher;",
      "773:  return tfm;",
      "778:  struct skcipher_tfm *tfm = private;",
      "780:  crypto_free_skcipher(tfm->skcipher);",
      "781:  kfree(tfm);",
      "786:  struct skcipher_tfm *tfm = private;",
      "787:  int err;",
      "789:  err = crypto_skcipher_setkey(tfm->skcipher, key, keylen);",
      "790:  tfm->has_key = !err;",
      "792:  return err;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "792: {",
      "793:  struct skcipher_ctx *ctx;",
      "794:  struct alg_sock *ask = alg_sk(sk);",
      "797:  ctx = sock_kmalloc(sk, len, GFP_KERNEL);",
      "798:  if (!ctx)",
      "799:   return -ENOMEM;",
      "802:           GFP_KERNEL);",
      "803:  if (!ctx->iv) {",
      "804:   sock_kfree_s(sk, ctx, len);",
      "805:   return -ENOMEM;",
      "806:  }",
      "810:  INIT_LIST_HEAD(&ctx->tsgl);",
      "811:  ctx->len = len;",
      "",
      "[Removed Lines]",
      "795:  unsigned int len = sizeof(*ctx) + crypto_skcipher_reqsize(private);",
      "801:  ctx->iv = sock_kmalloc(sk, crypto_skcipher_ivsize(private),",
      "808:  memset(ctx->iv, 0, crypto_skcipher_ivsize(private));",
      "",
      "[Added Lines]",
      "824:  struct skcipher_tfm *tfm = private;",
      "825:  struct crypto_skcipher *skcipher = tfm->skcipher;",
      "826:  unsigned int len = sizeof(*ctx) + crypto_skcipher_reqsize(skcipher);",
      "828:  if (!tfm->has_key)",
      "829:   return -ENOKEY;",
      "835:  ctx->iv = sock_kmalloc(sk, crypto_skcipher_ivsize(skcipher),",
      "842:  memset(ctx->iv, 0, crypto_skcipher_ivsize(skcipher));",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "819:  ask->private = ctx;",
      "822:  skcipher_request_set_callback(&ctx->req, CRYPTO_TFM_REQ_MAY_BACKLOG,",
      "823:           af_alg_complete, &ctx->completion);",
      "",
      "[Removed Lines]",
      "821:  skcipher_request_set_tfm(&ctx->req, private);",
      "",
      "[Added Lines]",
      "855:  skcipher_request_set_tfm(&ctx->req, skcipher);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "a596999b7ddfe7fc5b7b8adf9536ab1c39cb12d2",
      "candidate_info": {
        "commit_hash": "a596999b7ddfe7fc5b7b8adf9536ab1c39cb12d2",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/a596999b7ddfe7fc5b7b8adf9536ab1c39cb12d2",
        "files": [
          "crypto/algif_skcipher.c"
        ],
        "message": "crypto: algif - change algif_skcipher to be asynchronous\n\nThe way the algif_skcipher works currently is that on sendmsg/sendpage it\nbuilds an sgl for the input data and then on read/recvmsg it sends the job\nfor encryption putting the user to sleep till the data is processed.\nThis way it can only handle one job at a given time.\nThis patch changes it to be asynchronous by adding AIO support.\n\nSigned-off-by: Tadeusz Struk <tadeusz.struk@intel.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "crypto/algif_skcipher.c||crypto/algif_skcipher.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "crypto/algif_skcipher.c||crypto/algif_skcipher.c"
          ],
          "candidate": [
            "crypto/algif_skcipher.c||crypto/algif_skcipher.c"
          ]
        }
      },
      "candidate_diff": {
        "crypto/algif_skcipher.c||crypto/algif_skcipher.c": [
          "File: crypto/algif_skcipher.c -> crypto/algif_skcipher.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "40:  struct af_alg_completion completion;",
          "42:  unsigned used;",
          "44:  unsigned int len;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "42:  atomic_t inflight;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "49:  struct ablkcipher_request req;",
          "50: };",
          "52: #define MAX_SGL_ENTS ((4096 - sizeof(struct skcipher_sg_list)) / \\",
          "53:         sizeof(struct scatterlist) - 1)",
          "55: static inline int skcipher_sndbuf(struct sock *sk)",
          "56: {",
          "57:  struct alg_sock *ask = alg_sk(sk);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "53: struct skcipher_async_rsgl {",
          "54:  struct af_alg_sgl sgl;",
          "55:  struct list_head list;",
          "56: };",
          "58: struct skcipher_async_req {",
          "59:  struct kiocb *iocb;",
          "60:  struct skcipher_async_rsgl first_sgl;",
          "61:  struct list_head list;",
          "62:  struct scatterlist *tsg;",
          "63:  char iv[];",
          "64: };",
          "66: #define GET_SREQ(areq, ctx) (struct skcipher_async_req *)((char *)areq + \\",
          "67:  crypto_ablkcipher_reqsize(crypto_ablkcipher_reqtfm(&ctx->req)))",
          "69: #define GET_REQ_SIZE(ctx) \\",
          "70:  crypto_ablkcipher_reqsize(crypto_ablkcipher_reqtfm(&ctx->req))",
          "72: #define GET_IV_SIZE(ctx) \\",
          "73:  crypto_ablkcipher_ivsize(crypto_ablkcipher_reqtfm(&ctx->req))",
          "78: static void skcipher_free_async_sgls(struct skcipher_async_req *sreq)",
          "79: {",
          "80:  struct skcipher_async_rsgl *rsgl, *tmp;",
          "81:  struct scatterlist *sgl;",
          "82:  struct scatterlist *sg;",
          "83:  int i, n;",
          "85:  list_for_each_entry_safe(rsgl, tmp, &sreq->list, list) {",
          "86:   af_alg_free_sg(&rsgl->sgl);",
          "87:   if (rsgl != &sreq->first_sgl)",
          "88:    kfree(rsgl);",
          "89:  }",
          "90:  sgl = sreq->tsg;",
          "91:  n = sg_nents(sgl);",
          "92:  for_each_sg(sgl, sg, n, i)",
          "93:   put_page(sg_page(sg));",
          "95:  kfree(sreq->tsg);",
          "96: }",
          "98: static void skcipher_async_cb(struct crypto_async_request *req, int err)",
          "99: {",
          "100:  struct sock *sk = req->data;",
          "101:  struct alg_sock *ask = alg_sk(sk);",
          "102:  struct skcipher_ctx *ctx = ask->private;",
          "103:  struct skcipher_async_req *sreq = GET_SREQ(req, ctx);",
          "104:  struct kiocb *iocb = sreq->iocb;",
          "106:  atomic_dec(&ctx->inflight);",
          "107:  skcipher_free_async_sgls(sreq);",
          "108:  kfree(req);",
          "109:  aio_complete(iocb, err, err);",
          "110: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "96:  return 0;",
          "97: }",
          "100: {",
          "101:  struct alg_sock *ask = alg_sk(sk);",
          "102:  struct skcipher_ctx *ctx = ask->private;",
          "",
          "[Removed Lines]",
          "99: static void skcipher_pull_sgl(struct sock *sk, int used)",
          "",
          "[Added Lines]",
          "156: static void skcipher_pull_sgl(struct sock *sk, int used, int put)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "124:    if (sg[i].length)",
          "125:     return;",
          "128:    sg_assign_page(sg + i, NULL);",
          "129:   }",
          "",
          "[Removed Lines]",
          "127:    put_page(sg_page(sg + i));",
          "",
          "[Added Lines]",
          "183:    if (put)",
          "184:     put_page(sg_page(sg + i));",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "143:  struct alg_sock *ask = alg_sk(sk);",
          "144:  struct skcipher_ctx *ctx = ask->private;",
          "147: }",
          "149: static int skcipher_wait_for_wmem(struct sock *sk, unsigned flags)",
          "",
          "[Removed Lines]",
          "146:  skcipher_pull_sgl(sk, ctx->used);",
          "",
          "[Added Lines]",
          "203:  skcipher_pull_sgl(sk, ctx->used, 1);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "424:  return err ?: size;",
          "425: }",
          "429: {",
          "430:  struct sock *sk = sock->sk;",
          "431:  struct alg_sock *ask = alg_sk(sk);",
          "",
          "[Removed Lines]",
          "427: static int skcipher_recvmsg(struct socket *sock, struct msghdr *msg,",
          "428:        size_t ignored, int flags)",
          "",
          "[Added Lines]",
          "484: static int skcipher_all_sg_nents(struct skcipher_ctx *ctx)",
          "485: {",
          "486:  struct skcipher_sg_list *sgl;",
          "487:  struct scatterlist *sg;",
          "488:  int nents = 0;",
          "490:  list_for_each_entry(sgl, &ctx->tsgl, list) {",
          "491:   sg = sgl->sg;",
          "493:   while (!sg->length)",
          "494:    sg++;",
          "496:   nents += sg_nents(sg);",
          "497:  }",
          "498:  return nents;",
          "499: }",
          "501: static int skcipher_recvmsg_async(struct socket *sock, struct msghdr *msg,",
          "502:       int flags)",
          "503: {",
          "504:  struct sock *sk = sock->sk;",
          "505:  struct alg_sock *ask = alg_sk(sk);",
          "506:  struct skcipher_ctx *ctx = ask->private;",
          "507:  struct skcipher_sg_list *sgl;",
          "508:  struct scatterlist *sg;",
          "509:  struct skcipher_async_req *sreq;",
          "510:  struct ablkcipher_request *req;",
          "511:  struct skcipher_async_rsgl *last_rsgl = NULL;",
          "512:  unsigned int len = 0, tx_nents = skcipher_all_sg_nents(ctx);",
          "513:  unsigned int reqlen = sizeof(struct skcipher_async_req) +",
          "514:     GET_REQ_SIZE(ctx) + GET_IV_SIZE(ctx);",
          "515:  int i = 0;",
          "516:  int err = -ENOMEM;",
          "518:  lock_sock(sk);",
          "519:  req = kmalloc(reqlen, GFP_KERNEL);",
          "520:  if (unlikely(!req))",
          "521:   goto unlock;",
          "523:  sreq = GET_SREQ(req, ctx);",
          "524:  sreq->iocb = msg->msg_iocb;",
          "525:  memset(&sreq->first_sgl, '\\0', sizeof(struct skcipher_async_rsgl));",
          "526:  INIT_LIST_HEAD(&sreq->list);",
          "527:  sreq->tsg = kcalloc(tx_nents, sizeof(*sg), GFP_KERNEL);",
          "528:  if (unlikely(!sreq->tsg)) {",
          "529:   kfree(req);",
          "530:   goto unlock;",
          "531:  }",
          "532:  sg_init_table(sreq->tsg, tx_nents);",
          "533:  memcpy(sreq->iv, ctx->iv, GET_IV_SIZE(ctx));",
          "534:  ablkcipher_request_set_tfm(req, crypto_ablkcipher_reqtfm(&ctx->req));",
          "535:  ablkcipher_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG,",
          "536:      skcipher_async_cb, sk);",
          "538:  while (iov_iter_count(&msg->msg_iter)) {",
          "539:   struct skcipher_async_rsgl *rsgl;",
          "540:   unsigned long used;",
          "542:   if (!ctx->used) {",
          "543:    err = skcipher_wait_for_data(sk, flags);",
          "544:    if (err)",
          "545:     goto free;",
          "546:   }",
          "547:   sgl = list_first_entry(&ctx->tsgl,",
          "548:            struct skcipher_sg_list, list);",
          "549:   sg = sgl->sg;",
          "551:   while (!sg->length)",
          "552:    sg++;",
          "554:   used = min_t(unsigned long, ctx->used,",
          "555:         iov_iter_count(&msg->msg_iter));",
          "556:   used = min_t(unsigned long, used, sg->length);",
          "558:   if (i == tx_nents) {",
          "559:    struct scatterlist *tmp;",
          "560:    int x;",
          "563:    tmp = kcalloc(tx_nents * 2, sizeof(*tmp),",
          "564:           GFP_KERNEL);",
          "565:    if (!tmp)",
          "566:     goto free;",
          "568:    sg_init_table(tmp, tx_nents * 2);",
          "569:    for (x = 0; x < tx_nents; x++)",
          "570:     sg_set_page(&tmp[x], sg_page(&sreq->tsg[x]),",
          "571:          sreq->tsg[x].length,",
          "572:          sreq->tsg[x].offset);",
          "573:    kfree(sreq->tsg);",
          "574:    sreq->tsg = tmp;",
          "575:    tx_nents *= 2;",
          "576:   }",
          "579:   sg_set_page(sreq->tsg + i++, sg_page(sg), sg->length,",
          "580:        sg->offset);",
          "582:   if (list_empty(&sreq->list)) {",
          "583:    rsgl = &sreq->first_sgl;",
          "584:    list_add_tail(&rsgl->list, &sreq->list);",
          "585:   } else {",
          "586:    rsgl = kzalloc(sizeof(*rsgl), GFP_KERNEL);",
          "587:    if (!rsgl) {",
          "588:     err = -ENOMEM;",
          "589:     goto free;",
          "590:    }",
          "591:    list_add_tail(&rsgl->list, &sreq->list);",
          "592:   }",
          "594:   used = af_alg_make_sg(&rsgl->sgl, &msg->msg_iter, used);",
          "595:   err = used;",
          "596:   if (used < 0)",
          "597:    goto free;",
          "598:   if (last_rsgl)",
          "599:    af_alg_link_sg(&last_rsgl->sgl, &rsgl->sgl);",
          "601:   last_rsgl = rsgl;",
          "602:   len += used;",
          "603:   skcipher_pull_sgl(sk, used, 0);",
          "604:   iov_iter_advance(&msg->msg_iter, used);",
          "605:  }",
          "607:  ablkcipher_request_set_crypt(req, sreq->tsg, sreq->first_sgl.sgl.sg,",
          "608:          len, sreq->iv);",
          "609:  err = ctx->enc ? crypto_ablkcipher_encrypt(req) :",
          "610:     crypto_ablkcipher_decrypt(req);",
          "611:  if (err == -EINPROGRESS) {",
          "612:   atomic_inc(&ctx->inflight);",
          "613:   err = -EIOCBQUEUED;",
          "614:   goto unlock;",
          "615:  }",
          "616: free:",
          "617:  skcipher_free_async_sgls(sreq);",
          "618:  kfree(req);",
          "619: unlock:",
          "620:  skcipher_wmem_wakeup(sk);",
          "621:  release_sock(sk);",
          "622:  return err;",
          "623: }",
          "625: static int skcipher_recvmsg_sync(struct socket *sock, struct msghdr *msg,",
          "626:      int flags)",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "484:    goto unlock;",
          "486:   copied += used;",
          "488:   iov_iter_advance(&msg->msg_iter, used);",
          "489:  }",
          "",
          "[Removed Lines]",
          "487:   skcipher_pull_sgl(sk, used);",
          "",
          "[Added Lines]",
          "685:   skcipher_pull_sgl(sk, used, 1);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "497:  return copied ?: err;",
          "498: }",
          "501: static unsigned int skcipher_poll(struct file *file, struct socket *sock,",
          "502:       poll_table *wait)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "698: static int skcipher_recvmsg(struct socket *sock, struct msghdr *msg,",
          "699:        size_t ignored, int flags)",
          "700: {",
          "701:  return (msg->msg_iocb && !is_sync_kiocb(msg->msg_iocb)) ?",
          "702:   skcipher_recvmsg_async(sock, msg, flags) :",
          "703:   skcipher_recvmsg_sync(sock, msg, flags);",
          "704: }",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "555:  return crypto_ablkcipher_setkey(private, key, keylen);",
          "556: }",
          "558: static void skcipher_sock_destruct(struct sock *sk)",
          "559: {",
          "560:  struct alg_sock *ask = alg_sk(sk);",
          "561:  struct skcipher_ctx *ctx = ask->private;",
          "562:  struct crypto_ablkcipher *tfm = crypto_ablkcipher_reqtfm(&ctx->req);",
          "564:  skcipher_free_sgl(sk);",
          "565:  sock_kzfree_s(sk, ctx->iv, crypto_ablkcipher_ivsize(tfm));",
          "566:  sock_kfree_s(sk, ctx, ctx->len);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "763: static void skcipher_wait(struct sock *sk)",
          "764: {",
          "765:  struct alg_sock *ask = alg_sk(sk);",
          "766:  struct skcipher_ctx *ctx = ask->private;",
          "767:  int ctr = 0;",
          "769:  while (atomic_read(&ctx->inflight) && ctr++ < 100)",
          "770:   msleep(100);",
          "771: }",
          "779:  if (atomic_read(&ctx->inflight))",
          "780:   skcipher_wait(sk);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "592:  ctx->more = 0;",
          "593:  ctx->merge = 0;",
          "594:  ctx->enc = 0;",
          "595:  af_alg_init_completion(&ctx->completion);",
          "597:  ask->private = ctx;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "813:  atomic_set(&ctx->inflight, 0);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "0d96e4bab2855a030077cc695a3563fd7cb0e7d8",
      "candidate_info": {
        "commit_hash": "0d96e4bab2855a030077cc695a3563fd7cb0e7d8",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/0d96e4bab2855a030077cc695a3563fd7cb0e7d8",
        "files": [
          "crypto/algif_skcipher.c"
        ],
        "message": "crypto: algif_skcipher - Use new skcipher interface\n\nThis patch replaces uses of ablkcipher with the new skcipher\ninterface.\n\nCc: stable@vger.kernel.org\nSigned-off-by: Herbert Xu <herbert@gondor.apana.org.au>\nTested-by: <smueller@chronox.de>",
        "before_after_code_files": [
          "crypto/algif_skcipher.c||crypto/algif_skcipher.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "crypto/algif_skcipher.c||crypto/algif_skcipher.c"
          ],
          "candidate": [
            "crypto/algif_skcipher.c||crypto/algif_skcipher.c"
          ]
        }
      },
      "candidate_diff": {
        "crypto/algif_skcipher.c||crypto/algif_skcipher.c": [
          "File: crypto/algif_skcipher.c -> crypto/algif_skcipher.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "47:  bool merge;",
          "48:  bool enc;",
          "51: };",
          "53: struct skcipher_async_rsgl {",
          "",
          "[Removed Lines]",
          "50:  struct ablkcipher_request req;",
          "",
          "[Added Lines]",
          "50:  struct skcipher_request req;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "64: };",
          "66: #define GET_SREQ(areq, ctx) (struct skcipher_async_req *)((char *)areq + \\",
          "69: #define GET_REQ_SIZE(ctx) \\",
          "72: #define GET_IV_SIZE(ctx) \\",
          "75: #define MAX_SGL_ENTS ((4096 - sizeof(struct skcipher_sg_list)) / \\",
          "76:         sizeof(struct scatterlist) - 1)",
          "",
          "[Removed Lines]",
          "67:  crypto_ablkcipher_reqsize(crypto_ablkcipher_reqtfm(&ctx->req)))",
          "70:  crypto_ablkcipher_reqsize(crypto_ablkcipher_reqtfm(&ctx->req))",
          "73:  crypto_ablkcipher_ivsize(crypto_ablkcipher_reqtfm(&ctx->req))",
          "",
          "[Added Lines]",
          "67:  crypto_skcipher_reqsize(crypto_skcipher_reqtfm(&ctx->req)))",
          "70:  crypto_skcipher_reqsize(crypto_skcipher_reqtfm(&ctx->req))",
          "73:  crypto_skcipher_ivsize(crypto_skcipher_reqtfm(&ctx->req))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "302:  struct sock *sk = sock->sk;",
          "303:  struct alg_sock *ask = alg_sk(sk);",
          "304:  struct skcipher_ctx *ctx = ask->private;",
          "307:  struct skcipher_sg_list *sgl;",
          "308:  struct af_alg_control con = {};",
          "309:  long copied = 0;",
          "",
          "[Removed Lines]",
          "305:  struct crypto_ablkcipher *tfm = crypto_ablkcipher_reqtfm(&ctx->req);",
          "306:  unsigned ivsize = crypto_ablkcipher_ivsize(tfm);",
          "",
          "[Added Lines]",
          "305:  struct crypto_skcipher *tfm = crypto_skcipher_reqtfm(&ctx->req);",
          "306:  unsigned ivsize = crypto_skcipher_ivsize(tfm);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "507:  struct skcipher_sg_list *sgl;",
          "508:  struct scatterlist *sg;",
          "509:  struct skcipher_async_req *sreq;",
          "511:  struct skcipher_async_rsgl *last_rsgl = NULL;",
          "512:  unsigned int txbufs = 0, len = 0, tx_nents = skcipher_all_sg_nents(ctx);",
          "513:  unsigned int reqlen = sizeof(struct skcipher_async_req) +",
          "",
          "[Removed Lines]",
          "510:  struct ablkcipher_request *req;",
          "",
          "[Added Lines]",
          "510:  struct skcipher_request *req;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "531:  }",
          "532:  sg_init_table(sreq->tsg, tx_nents);",
          "533:  memcpy(sreq->iv, ctx->iv, GET_IV_SIZE(ctx));",
          "538:  while (iov_iter_count(&msg->msg_iter)) {",
          "539:   struct skcipher_async_rsgl *rsgl;",
          "",
          "[Removed Lines]",
          "534:  ablkcipher_request_set_tfm(req, crypto_ablkcipher_reqtfm(&ctx->req));",
          "535:  ablkcipher_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG,",
          "536:      skcipher_async_cb, sk);",
          "",
          "[Added Lines]",
          "534:  skcipher_request_set_tfm(req, crypto_skcipher_reqtfm(&ctx->req));",
          "535:  skcipher_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG,",
          "536:           skcipher_async_cb, sk);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "608:  if (mark)",
          "609:   sg_mark_end(sreq->tsg + txbufs - 1);",
          "615:  if (err == -EINPROGRESS) {",
          "616:   atomic_inc(&ctx->inflight);",
          "617:   err = -EIOCBQUEUED;",
          "",
          "[Removed Lines]",
          "611:  ablkcipher_request_set_crypt(req, sreq->tsg, sreq->first_sgl.sgl.sg,",
          "612:          len, sreq->iv);",
          "613:  err = ctx->enc ? crypto_ablkcipher_encrypt(req) :",
          "614:     crypto_ablkcipher_decrypt(req);",
          "",
          "[Added Lines]",
          "611:  skcipher_request_set_crypt(req, sreq->tsg, sreq->first_sgl.sgl.sg,",
          "612:        len, sreq->iv);",
          "613:  err = ctx->enc ? crypto_skcipher_encrypt(req) :",
          "614:     crypto_skcipher_decrypt(req);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "632:  struct sock *sk = sock->sk;",
          "633:  struct alg_sock *ask = alg_sk(sk);",
          "634:  struct skcipher_ctx *ctx = ask->private;",
          "636:   &ctx->req));",
          "637:  struct skcipher_sg_list *sgl;",
          "638:  struct scatterlist *sg;",
          "",
          "[Removed Lines]",
          "635:  unsigned bs = crypto_ablkcipher_blocksize(crypto_ablkcipher_reqtfm(",
          "",
          "[Added Lines]",
          "635:  unsigned bs = crypto_skcipher_blocksize(crypto_skcipher_reqtfm(",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "669:   if (!used)",
          "670:    goto free;",
          "676:   err = af_alg_wait_for_completion(",
          "677:     ctx->enc ?",
          "680:     &ctx->completion);",
          "682: free:",
          "",
          "[Removed Lines]",
          "672:   ablkcipher_request_set_crypt(&ctx->req, sg,",
          "673:           ctx->rsgl.sg, used,",
          "674:           ctx->iv);",
          "678:      crypto_ablkcipher_encrypt(&ctx->req) :",
          "679:      crypto_ablkcipher_decrypt(&ctx->req),",
          "",
          "[Added Lines]",
          "672:   skcipher_request_set_crypt(&ctx->req, sg, ctx->rsgl.sg, used,",
          "673:         ctx->iv);",
          "677:      crypto_skcipher_encrypt(&ctx->req) :",
          "678:      crypto_skcipher_decrypt(&ctx->req),",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "752: static void *skcipher_bind(const char *name, u32 type, u32 mask)",
          "753: {",
          "755: }",
          "757: static void skcipher_release(void *private)",
          "758: {",
          "760: }",
          "762: static int skcipher_setkey(void *private, const u8 *key, unsigned int keylen)",
          "763: {",
          "765: }",
          "767: static void skcipher_wait(struct sock *sk)",
          "",
          "[Removed Lines]",
          "754:  return crypto_alloc_ablkcipher(name, type, mask);",
          "759:  crypto_free_ablkcipher(private);",
          "764:  return crypto_ablkcipher_setkey(private, key, keylen);",
          "",
          "[Added Lines]",
          "753:  return crypto_alloc_skcipher(name, type, mask);",
          "758:  crypto_free_skcipher(private);",
          "763:  return crypto_skcipher_setkey(private, key, keylen);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "778: {",
          "779:  struct alg_sock *ask = alg_sk(sk);",
          "780:  struct skcipher_ctx *ctx = ask->private;",
          "783:  if (atomic_read(&ctx->inflight))",
          "784:   skcipher_wait(sk);",
          "786:  skcipher_free_sgl(sk);",
          "788:  sock_kfree_s(sk, ctx, ctx->len);",
          "789:  af_alg_release_parent(sk);",
          "790: }",
          "",
          "[Removed Lines]",
          "781:  struct crypto_ablkcipher *tfm = crypto_ablkcipher_reqtfm(&ctx->req);",
          "787:  sock_kzfree_s(sk, ctx->iv, crypto_ablkcipher_ivsize(tfm));",
          "",
          "[Added Lines]",
          "780:  struct crypto_skcipher *tfm = crypto_skcipher_reqtfm(&ctx->req);",
          "786:  sock_kzfree_s(sk, ctx->iv, crypto_skcipher_ivsize(tfm));",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "793: {",
          "794:  struct skcipher_ctx *ctx;",
          "795:  struct alg_sock *ask = alg_sk(sk);",
          "798:  ctx = sock_kmalloc(sk, len, GFP_KERNEL);",
          "799:  if (!ctx)",
          "800:   return -ENOMEM;",
          "803:           GFP_KERNEL);",
          "804:  if (!ctx->iv) {",
          "805:   sock_kfree_s(sk, ctx, len);",
          "806:   return -ENOMEM;",
          "807:  }",
          "811:  INIT_LIST_HEAD(&ctx->tsgl);",
          "812:  ctx->len = len;",
          "",
          "[Removed Lines]",
          "796:  unsigned int len = sizeof(*ctx) + crypto_ablkcipher_reqsize(private);",
          "802:  ctx->iv = sock_kmalloc(sk, crypto_ablkcipher_ivsize(private),",
          "809:  memset(ctx->iv, 0, crypto_ablkcipher_ivsize(private));",
          "",
          "[Added Lines]",
          "795:  unsigned int len = sizeof(*ctx) + crypto_skcipher_reqsize(private);",
          "801:  ctx->iv = sock_kmalloc(sk, crypto_skcipher_ivsize(private),",
          "808:  memset(ctx->iv, 0, crypto_skcipher_ivsize(private));",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "820:  ask->private = ctx;",
          "826:  sk->sk_destruct = skcipher_sock_destruct;",
          "",
          "[Removed Lines]",
          "822:  ablkcipher_request_set_tfm(&ctx->req, private);",
          "823:  ablkcipher_request_set_callback(&ctx->req, CRYPTO_TFM_REQ_MAY_BACKLOG,",
          "824:      af_alg_complete, &ctx->completion);",
          "",
          "[Added Lines]",
          "821:  skcipher_request_set_tfm(&ctx->req, private);",
          "822:  skcipher_request_set_callback(&ctx->req, CRYPTO_TFM_REQ_MAY_BACKLOG,",
          "823:           af_alg_complete, &ctx->completion);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
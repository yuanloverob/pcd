{
  "cve_id": "CVE-2015-0278",
  "cve_desc": "libuv before 0.10.34 does not properly drop group privileges, which allows context-dependent attackers to gain privileges via unspecified vectors.",
  "repo": "libuv/libuv",
  "patch_hash": "66ab38918c911bcff025562cf06237d7fedaba0c",
  "patch_info": {
    "commit_hash": "66ab38918c911bcff025562cf06237d7fedaba0c",
    "repo": "libuv/libuv",
    "commit_url": "https://github.com/libuv/libuv/commit/66ab38918c911bcff025562cf06237d7fedaba0c",
    "files": [
      "src/unix/process.c"
    ],
    "message": "unix: call setgoups before calling setuid/setgid\n\nPartial fix for #1093",
    "before_after_code_files": [
      "src/unix/process.c||src/unix/process.c"
    ]
  },
  "patch_diff": {
    "src/unix/process.c||src/unix/process.c": [
      "File: src/unix/process.c -> src/unix/process.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "330:     _exit(127);",
      "331:   }",
      "333:   if ((options->flags & UV_PROCESS_SETGID) && setgid(options->gid)) {",
      "334:     uv__write_int(error_fd, -errno);",
      "335:     perror(\"setgid()\");",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "333:   if (options->flags & (UV_PROCESS_SETUID | UV_PROCESS_SETGID)) {",
      "341:     SAVE_ERRNO(setgroups(0, NULL));",
      "342:   }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "646de34f5e83994f121892394776c60cb01a2706",
      "candidate_info": {
        "commit_hash": "646de34f5e83994f121892394776c60cb01a2706",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/646de34f5e83994f121892394776c60cb01a2706",
        "files": [
          "src/unix/darwin.c",
          "src/unix/fsevents.c",
          "src/unix/signal.c"
        ],
        "message": "unix: fix various memory leaks and undef behavior\n\nKindly suggested by `cppcheck`.",
        "before_after_code_files": [
          "src/unix/darwin.c||src/unix/darwin.c",
          "src/unix/fsevents.c||src/unix/fsevents.c",
          "src/unix/signal.c||src/unix/signal.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/unix/darwin.c||src/unix/darwin.c": [
          "File: src/unix/darwin.c -> src/unix/darwin.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "75:   result = _NSGetExecutablePath(buffer, &usize);",
          "76:   if (result) return result;",
          "79:   fullpath = realpath(buffer, path);",
          "80:   if (fullpath == NULL) {",
          "81:     SAVE_ERRNO(free(path));",
          "",
          "[Removed Lines]",
          "78:   path = (char*)malloc(2 * PATH_MAX);",
          "",
          "[Added Lines]",
          "78:   path = malloc(2 * PATH_MAX);",
          "",
          "---------------"
        ],
        "src/unix/fsevents.c||src/unix/fsevents.c": [
          "File: src/unix/fsevents.c -> src/unix/fsevents.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "591:   err = uv_mutex_init(&loop->cf_mutex);",
          "592:   if (err)",
          "595:   err = uv_sem_init(&loop->cf_sem, 0);",
          "596:   if (err)",
          "",
          "[Removed Lines]",
          "593:     return err;",
          "",
          "[Added Lines]",
          "593:     goto fail_mutex_init;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "661: fail_sem_init:",
          "662:   uv_mutex_destroy(&loop->cf_mutex);",
          "663:   free(state);",
          "664:   return err;",
          "665: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "664: fail_mutex_init:",
          "",
          "---------------"
        ],
        "src/unix/signal.c||src/unix/signal.c": [
          "File: src/unix/signal.c -> src/unix/signal.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "348:   int r;",
          "350:   bytes = 0;",
          "352:   do {",
          "353:     r = read(loop->signal_pipefd[0], buf + bytes, sizeof(buf) - bytes);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "351:   end = 0;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "76d831e4c828b5fbf0d561c29ad9d1e876082577",
      "candidate_info": {
        "commit_hash": "76d831e4c828b5fbf0d561c29ad9d1e876082577",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/76d831e4c828b5fbf0d561c29ad9d1e876082577",
        "files": [
          "src/unix/getaddrinfo.c",
          "test/test-getaddrinfo.c",
          "test/test-list.h",
          "test/test-threadpool-cancel.c"
        ],
        "message": "unix: getaddrinfo_cb status arg should be 0 or -1\n\nThe documentation in uv.h states that the status argument to the\nuv_getaddrinfo() callback is either 0 or -1 but uv-unix actually\npassed it the addrinfo error code. Rectify that and add a regression\ntest.\n\nFixes #754.",
        "before_after_code_files": [
          "src/unix/getaddrinfo.c||src/unix/getaddrinfo.c",
          "test/test-getaddrinfo.c||test/test-getaddrinfo.c",
          "test/test-list.h||test/test-list.h",
          "test/test-threadpool-cancel.c||test/test-threadpool-cancel.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/unix/getaddrinfo.c||src/unix/getaddrinfo.c": [
          "File: src/unix/getaddrinfo.c -> src/unix/getaddrinfo.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "40: static void uv__getaddrinfo_done(struct uv__work* w, int status) {",
          "44:   size_t hostlen;",
          "52:   req->res = NULL;",
          "57:   if (req->hints)",
          "58:     free(req->hints);",
          "59:   else if (req->service)",
          "",
          "[Removed Lines]",
          "41:   uv_getaddrinfo_t* req = container_of(w, uv_getaddrinfo_t, work_req);",
          "42:   struct addrinfo *res = req->res;",
          "43: #if defined(__sun)",
          "46:   if (req->hostname)",
          "47:     hostlen = strlen(req->hostname);",
          "48:   else",
          "49:     hostlen = 0;",
          "50: #endif",
          "54:   uv__req_unregister(req->loop, req);",
          "",
          "[Added Lines]",
          "41:   uv_getaddrinfo_t* req;",
          "42:   struct addrinfo *res;",
          "45:   req = container_of(w, uv_getaddrinfo_t, work_req);",
          "46:   uv__req_unregister(req->loop, req);",
          "48:   res = req->res;",
          "52:   hostlen = 0;",
          "53: #if defined(__sun)",
          "54:   if (req->hostname != NULL)",
          "55:     hostlen = strlen(req->hostname);",
          "56: #endif",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "67:   req->service = NULL;",
          "68:   req->hostname = NULL;",
          "70:   if (req->retcode == 0) {",
          "80:     uv__set_sys_error(req->loop, ENOENT);",
          "81: #endif",
          "83:     req->loop->last_err.code = UV_EADDRINFO;",
          "84:     req->loop->last_err.sys_errno_ = req->retcode;",
          "85:   }",
          "94: }",
          "",
          "[Removed Lines]",
          "73:   } else if (req->retcode == EAI_NONAME || req->retcode == EAI_NODATA) {",
          "74: #else",
          "75:   } else if (req->retcode == EAI_NONAME) {",
          "76: #endif",
          "78: #if defined(__sun)",
          "79:   } else if (req->retcode == EAI_MEMORY && hostlen >= MAXHOSTNAMELEN) {",
          "82:   } else {",
          "87:   if (status == -UV_ECANCELED) {",
          "88:     assert(req->retcode == 0);",
          "89:     req->retcode = UV_ECANCELED;",
          "90:     uv__set_artificial_error(req->loop, UV_ECANCELED);",
          "91:   }",
          "93:   req->cb(req, req->retcode, res);",
          "",
          "[Added Lines]",
          "72:   if (status == -UV_ECANCELED) {",
          "73:     assert(req->retcode == 0);",
          "74:     req->retcode = UV_ECANCELED;",
          "75:     uv__set_artificial_error(req->loop, UV_ECANCELED);",
          "76:     req->cb(req, -1, NULL);",
          "77:     return;",
          "78:   }",
          "81:     req->cb(req, 0, res);",
          "82:     return;",
          "83:   }",
          "85:   if (req->retcode == EAI_NONAME)",
          "86:     uv__set_sys_error(req->loop, ENOENT);",
          "88:   else if (req->retcode == EAI_NODATA)",
          "89:     uv__set_sys_error(req->loop, ENOENT);",
          "90: #elif defined(__sun)",
          "91:   if (req->retcode == EAI_MEMORY && hostlen >= MAXHOSTNAMELEN) {",
          "94:   else {",
          "99:   req->cb(req, -1, res);",
          "",
          "---------------"
        ],
        "test/test-getaddrinfo.c||test/test-getaddrinfo.c": [
          "File: test/test-getaddrinfo.c -> test/test-getaddrinfo.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "33: static uv_getaddrinfo_t* getaddrinfo_handle;",
          "34: static uv_getaddrinfo_t getaddrinfo_handles[CONCURRENT_COUNT];",
          "35: static int callback_counts[CONCURRENT_COUNT];",
          "38: static void getaddrinfo_basic_cb(uv_getaddrinfo_t* handle,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "36: static int fail_cb_called;",
          "39: static void getaddrinfo_fail_cb(uv_getaddrinfo_t* req,",
          "40:                                 int status,",
          "41:                                 struct addrinfo* res) {",
          "42:   ASSERT(fail_cb_called == 0);",
          "43:   ASSERT(status == -1);",
          "44:   ASSERT(res == NULL);",
          "46:   fail_cb_called++;",
          "47: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "68: }",
          "71: TEST_IMPL(getaddrinfo_basic) {",
          "72:   int r;",
          "73:   getaddrinfo_handle = (uv_getaddrinfo_t*)malloc(sizeof(uv_getaddrinfo_t));",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "83: TEST_IMPL(getaddrinfo_fail) {",
          "84:   uv_getaddrinfo_t req;",
          "86:   ASSERT(0 == uv_getaddrinfo(uv_default_loop(),",
          "87:                              &req,",
          "88:                              getaddrinfo_fail_cb,",
          "89:                              \"xyzzy.xyzzy.xyzzy\",",
          "90:                              NULL,",
          "91:                              NULL));",
          "92:   ASSERT(0 == uv_run(uv_default_loop(), UV_RUN_DEFAULT));",
          "93:   ASSERT(fail_cb_called == 1);",
          "95:   MAKE_VALGRIND_HAPPY();",
          "96:   return 0;",
          "97: }",
          "",
          "---------------"
        ],
        "test/test-list.h||test/test-list.h": [
          "File: test/test-list.h -> test/test-list.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "136: TEST_DECLARE   (cwd_and_chdir)",
          "137: TEST_DECLARE   (get_memory)",
          "138: TEST_DECLARE   (hrtime)",
          "139: TEST_DECLARE   (getaddrinfo_basic)",
          "140: TEST_DECLARE   (getaddrinfo_concurrent)",
          "141: TEST_DECLARE   (getsockname_tcp)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "139: TEST_DECLARE   (getaddrinfo_fail)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "399:   TEST_ENTRY  (hrtime)",
          "401:   TEST_ENTRY  (getaddrinfo_basic)",
          "402:   TEST_ENTRY  (getaddrinfo_concurrent)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "402:   TEST_ENTRY  (getaddrinfo_fail)",
          "",
          "---------------"
        ],
        "test/test-threadpool-cancel.c||test/test-threadpool-cancel.c": [
          "File: test/test-threadpool-cancel.c -> test/test-threadpool-cancel.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "121:                            int status,",
          "122:                            struct addrinfo* res) {",
          "123:   ASSERT(UV_ECANCELED == uv_last_error(req->loop).code);",
          "125:   getaddrinfo_cb_called++;",
          "126: }",
          "",
          "[Removed Lines]",
          "124:   ASSERT(UV_ECANCELED == status);",
          "",
          "[Added Lines]",
          "124:   ASSERT(status == -1);",
          "125:   ASSERT(res == NULL);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "68ac0a68e7269ddcea86ca90b4a4ae10bb43e784",
      "candidate_info": {
        "commit_hash": "68ac0a68e7269ddcea86ca90b4a4ae10bb43e784",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/68ac0a68e7269ddcea86ca90b4a4ae10bb43e784",
        "files": [
          "src/win/util.c"
        ],
        "message": "windows: fix netmask detection\n\nuv_interface_addresses was using the linked list pointed to by\nthe FirstPrefix member of IP_ADAPTER_ADDRESSES in order to compute the\nnetwork prefix / network mask.\n\nThis was flawed in several ways:\n- FirstPrefix can be NULL, and we would crash.\n- On Windows Vista and later, the prefix list includes three IP adapter prefixes\n  for each IP address assigned to the adapter. We were assuming a 1:1 mapping\n  with the unicast address list.\n- Even on Windows versions (i.e. XP) where the prefix list is supposed to have\n  one and only one element for each unicast address, the order of the two lists\n  is not guaranteed to be the same.\n\nThis fix was inspired and adapted from a commit in the Chromium project:\nhttps://codereview.chromium.org/25167002/diff/6001/net/base/net_util_win.cc\n\nSee MSDN article for reference:\nhttp://msdn.microsoft.com/en-us/library/windows/desktop/aa366058(v=vs.85).aspx\n\nExcerpt from MSDN below:\n\nIn addition, the linked IP_ADAPTER_UNICAST_ADDRESS structures pointed to\nby the FirstUnicastAddress member and the linked IP_ADAPTER_PREFIX\nstructures pointed to by the FirstPrefix member are maintained as separate\ninternal linked lists by the operating system. As a result, the order of\nlinked IP_ADAPTER_UNICAST_ADDRESS structures pointed to by the\nFirstUnicastAddress member does not have any relationship with the order\nof linked IP_ADAPTER_PREFIX structures pointed to by the FirstPrefix member.\n\nOn Windows Vista and later, the linked IP_ADAPTER_PREFIX structures pointed to\nby the FirstPrefix member include three IP adapter prefixes for each IP address\nassigned to the adapter. These include the host IP address prefix, the subnet\nIP address prefix, and the subnet broadcast IP address prefix. In addition, for\neach adapter there is a multicast address prefix and a broadcast address prefix.",
        "before_after_code_files": [
          "src/win/util.c||src/win/util.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/win/util.c||src/win/util.c": [
          "File: src/win/util.c -> src/win/util.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "778: }",
          "781: int uv_interface_addresses(uv_interface_address_t** addresses_ptr,",
          "782:     int* count_ptr) {",
          "783:   IP_ADAPTER_ADDRESSES* win_address_buf;",
          "784:   ULONG win_address_buf_size;",
          "787:   uv_interface_address_t* uv_address_buf;",
          "788:   char* name_buf;",
          "",
          "[Removed Lines]",
          "785:   IP_ADAPTER_ADDRESSES* win_address;",
          "",
          "[Added Lines]",
          "781: static int is_windows_version_or_greater(DWORD os_major,",
          "782:                                          DWORD os_minor,",
          "783:                                          WORD service_pack_major,",
          "784:                                          WORD service_pack_minor) {",
          "785:   OSVERSIONINFOEX osvi;",
          "786:   DWORDLONG condition_mask = 0;",
          "787:   int op = VER_GREATER_EQUAL;",
          "790:   ZeroMemory(&osvi, sizeof(OSVERSIONINFOEX));",
          "791:   osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);",
          "792:   osvi.dwMajorVersion = os_major;",
          "793:   osvi.dwMinorVersion = os_minor;",
          "794:   osvi.wServicePackMajor = service_pack_major;",
          "795:   osvi.wServicePackMinor = service_pack_minor;",
          "798:   VER_SET_CONDITION(condition_mask, VER_MAJORVERSION, op);",
          "799:   VER_SET_CONDITION(condition_mask, VER_MINORVERSION, op);",
          "800:   VER_SET_CONDITION(condition_mask, VER_SERVICEPACKMAJOR, op);",
          "801:   VER_SET_CONDITION(condition_mask, VER_SERVICEPACKMINOR, op);",
          "804:   return (int) VerifyVersionInfo(",
          "805:     &osvi,",
          "806:     VER_MAJORVERSION | VER_MINORVERSION |",
          "807:     VER_SERVICEPACKMAJOR | VER_SERVICEPACKMINOR,",
          "808:     condition_mask);",
          "809: }",
          "812: static int address_prefix_match(int family,",
          "813:                                 struct sockaddr* address,",
          "814:                                 struct sockaddr* prefix_address,",
          "815:                                 int prefix_len) {",
          "816:   uint8_t* address_data;",
          "817:   uint8_t* prefix_address_data;",
          "818:   int i;",
          "820:   assert(address->sa_family == family);",
          "821:   assert(prefix_address->sa_family == family);",
          "823:   if (family == AF_INET6) {",
          "824:     address_data = (uint8_t*) &(((struct sockaddr_in6 *) address)->sin6_addr);",
          "825:     prefix_address_data =",
          "826:       (uint8_t*) &(((struct sockaddr_in6 *) prefix_address)->sin6_addr);",
          "827:   } else {",
          "828:     address_data = (uint8_t*) &(((struct sockaddr_in *) address)->sin_addr);",
          "829:     prefix_address_data =",
          "830:       (uint8_t*) &(((struct sockaddr_in *) prefix_address)->sin_addr);",
          "831:   }",
          "833:   for (i = 0; i < prefix_len >> 3; i++) {",
          "834:     if (address_data[i] != prefix_address_data[i])",
          "835:       return 0;",
          "836:   }",
          "838:   if (prefix_len % 8)",
          "839:     return prefix_address_data[i] ==",
          "840:       (address_data[i] & (0xff << (8 - prefix_len % 8)));",
          "842:   return 1;",
          "843: }",
          "850:   IP_ADAPTER_ADDRESSES* adapter;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "792:   int count;",
          "796:   win_address_buf_size = 0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "859:   int is_vista_or_greater;",
          "860:   ULONG flags;",
          "862:   is_vista_or_greater = is_windows_version_or_greater(6, 0, 0, 0);",
          "863:   if (is_vista_or_greater) {",
          "864:     flags = GAA_FLAG_SKIP_ANYCAST | GAA_FLAG_SKIP_MULTICAST |",
          "865:       GAA_FLAG_SKIP_DNS_SERVER;",
          "866:   } else {",
          "868:     if (!is_windows_version_or_greater(5, 1, 1, 0))",
          "869:       return UV_ENOTSUP;",
          "871:     flags = GAA_FLAG_SKIP_ANYCAST | GAA_FLAG_SKIP_MULTICAST |",
          "872:       GAA_FLAG_SKIP_DNS_SERVER | GAA_FLAG_INCLUDE_PREFIX;",
          "873:   }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "805:     r = GetAdaptersAddresses(AF_UNSPEC,",
          "807:                              NULL,",
          "808:                              win_address_buf,",
          "809:                              &win_address_buf_size);",
          "",
          "[Removed Lines]",
          "806:                              GAA_FLAG_INCLUDE_PREFIX,",
          "",
          "[Added Lines]",
          "888:                              flags,",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "862:   count = 0;",
          "863:   uv_address_buf_size = 0;",
          "871:     int name_size;",
          "878:       continue;",
          "881:     name_size = WideCharToMultiByte(CP_UTF8,",
          "882:                                     0,",
          "884:                                     -1,",
          "885:                                     NULL,",
          "886:                                     0,",
          "",
          "[Removed Lines]",
          "865:   for (win_address = win_address_buf;",
          "866:        win_address != NULL;",
          "867:        win_address = win_address->Next) {",
          "870:     IP_ADAPTER_UNICAST_ADDRESS_XP* unicast_address;",
          "876:     if (win_address->OperStatus != IfOperStatusUp ||",
          "877:         win_address->FirstUnicastAddress == NULL)",
          "883:                                     win_address->FriendlyName,",
          "",
          "[Added Lines]",
          "947:   for (adapter = win_address_buf;",
          "948:        adapter != NULL;",
          "949:        adapter = adapter->Next) {",
          "950:     IP_ADAPTER_UNICAST_ADDRESS* unicast_address;",
          "956:     if (adapter->OperStatus != IfOperStatusUp ||",
          "957:         adapter->FirstUnicastAddress == NULL)",
          "963:                                     adapter->FriendlyName,",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "899:          unicast_address != NULL;",
          "900:          unicast_address = unicast_address->Next) {",
          "901:       count++;",
          "",
          "[Removed Lines]",
          "897:     for (unicast_address = (IP_ADAPTER_UNICAST_ADDRESS_XP*)",
          "898:                            win_address->FirstUnicastAddress;",
          "",
          "[Added Lines]",
          "977:     for (unicast_address = (IP_ADAPTER_UNICAST_ADDRESS*)",
          "978:                            adapter->FirstUnicastAddress;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "916:   name_buf = (char*) (uv_address_buf + count);",
          "924:     int name_size;",
          "925:     size_t max_name_size;",
          "929:       continue;",
          "",
          "[Removed Lines]",
          "919:   for (win_address = win_address_buf;",
          "920:        win_address != NULL;",
          "921:        win_address = win_address->Next) {",
          "922:     IP_ADAPTER_UNICAST_ADDRESS_XP* unicast_address;",
          "923:     IP_ADAPTER_PREFIX* prefix;",
          "927:     if (win_address->OperStatus != IfOperStatusUp ||",
          "928:         win_address->FirstUnicastAddress == NULL)",
          "",
          "[Added Lines]",
          "999:   for (adapter = win_address_buf;",
          "1000:        adapter != NULL;",
          "1001:        adapter = adapter->Next) {",
          "1002:     IP_ADAPTER_UNICAST_ADDRESS* unicast_address;",
          "1006:     if (adapter->OperStatus != IfOperStatusUp ||",
          "1007:         adapter->FirstUnicastAddress == NULL)",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "934:       max_name_size = INT_MAX;",
          "935:     name_size = WideCharToMultiByte(CP_UTF8,",
          "936:                                     0,",
          "938:                                     -1,",
          "939:                                     name_buf,",
          "940:                                     (int) max_name_size,",
          "",
          "[Removed Lines]",
          "937:                                     win_address->FriendlyName,",
          "",
          "[Added Lines]",
          "1016:                                     adapter->FriendlyName,",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "946:       return uv_translate_sys_error(GetLastError());",
          "947:     }",
          "957:       struct sockaddr* sa;",
          "958:       ULONG prefix_len;",
          "960:       sa = unicast_address->Address.lpSockaddr;",
          "963:       memset(uv_address, 0, sizeof *uv_address);",
          "965:       uv_address->name = name_buf;",
          "968:         memcpy(uv_address->phys_addr,",
          "970:                sizeof(uv_address->phys_addr));",
          "971:       }",
          "973:       uv_address->is_internal =",
          "976:       if (sa->sa_family == AF_INET6) {",
          "977:         uv_address->address.address6 = *((struct sockaddr_in6 *) sa);",
          "979:         uv_address->netmask.netmask6.sin6_family = AF_INET6;",
          "980:         memset(uv_address->netmask.netmask6.sin6_addr.s6_addr, 0xff, prefix_len >> 3);",
          "984:       } else {",
          "985:         uv_address->address.address4 = *((struct sockaddr_in *) sa);",
          "987:         uv_address->netmask.netmask4.sin_family = AF_INET;",
          "990:       }",
          "992:       uv_address++;",
          "",
          "[Removed Lines]",
          "949:     prefix = win_address->FirstPrefix;",
          "953:     for (unicast_address = (IP_ADAPTER_UNICAST_ADDRESS_XP*)",
          "954:                            win_address->FirstUnicastAddress;",
          "955:          unicast_address != NULL && prefix != NULL;",
          "956:          unicast_address = unicast_address->Next, prefix = prefix->Next) {",
          "961:       prefix_len = prefix->PrefixLength;",
          "967:       if (win_address->PhysicalAddressLength == sizeof(uv_address->phys_addr)) {",
          "969:                win_address->PhysicalAddress,",
          "974:           (win_address->IfType == IF_TYPE_SOFTWARE_LOOPBACK);",
          "981:         uv_address->netmask.netmask6.sin6_addr.s6_addr[prefix_len >> 3] =",
          "982:             0xff << (8 - prefix_len % 8);",
          "988:         uv_address->netmask.netmask4.sin_addr.s_addr =",
          "989:             htonl(0xffffffff << (32 - prefix_len));",
          "",
          "[Added Lines]",
          "1029:     for (unicast_address = (IP_ADAPTER_UNICAST_ADDRESS*)",
          "1030:                            adapter->FirstUnicastAddress;",
          "1031:          unicast_address != NULL;",
          "1032:          unicast_address = unicast_address->Next) {",
          "1039:       if (is_vista_or_greater) {",
          "1040:         prefix_len = unicast_address->OnLinkPrefixLength;",
          "1041:       } else {",
          "1047:         IP_ADAPTER_PREFIX* prefix;",
          "1048:         prefix_len = 0;",
          "1050:         for (prefix = adapter->FirstPrefix; prefix; prefix = prefix->Next) {",
          "1052:           if (prefix->Address.lpSockaddr->sa_family != sa->sa_family ||",
          "1053:               prefix->PrefixLength <= prefix_len)",
          "1054:             continue;",
          "1056:           if (address_prefix_match(sa->sa_family, sa,",
          "1057:               prefix->Address.lpSockaddr, prefix->PrefixLength)) {",
          "1058:             prefix_len = prefix->PrefixLength;",
          "1059:           }",
          "1060:         }",
          "1065:         if (!prefix_len)",
          "1066:           prefix_len = (sa->sa_family == AF_INET6) ? 128 : 32;",
          "1067:       }",
          "1073:       if (adapter->PhysicalAddressLength == sizeof(uv_address->phys_addr)) {",
          "1075:                adapter->PhysicalAddress,",
          "1080:           (adapter->IfType == IF_TYPE_SOFTWARE_LOOPBACK);",
          "1088:         if (prefix_len % 8) {",
          "1089:           uv_address->netmask.netmask6.sin6_addr.s6_addr[prefix_len >> 3] =",
          "1090:               0xff << (8 - prefix_len % 8);",
          "1091:         }",
          "1097:         uv_address->netmask.netmask4.sin_addr.s_addr = (prefix_len > 0) ?",
          "1098:             htonl(0xffffffff << (32 - prefix_len)) : 0;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "377bf68a2a0d14c43fb9f33aab70541364e13b6a",
      "candidate_info": {
        "commit_hash": "377bf68a2a0d14c43fb9f33aab70541364e13b6a",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/377bf68a2a0d14c43fb9f33aab70541364e13b6a",
        "files": [
          "src/win/udp.c"
        ],
        "message": "windows: count queued bytes even if request completed immediately\n\nThe send_queue_size/count needs to maintain its value until right before\nthe callback is called.",
        "before_after_code_files": [
          "src/win/udp.c||src/win/udp.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/win/udp.c||src/win/udp.c": [
          "File: src/win/udp.c -> src/win/udp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "399:     req->queued_bytes = 0;",
          "400:     handle->reqs_pending++;",
          "401:     REGISTER_HANDLE_REQ(loop, handle, req);",
          "402:     uv_insert_pending_req(loop, (uv_req_t*)req);",
          "403:   } else if (UV_SUCCEEDED_WITH_IOCP(result == 0)) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "401:     handle->send_queue_size += req->queued_bytes;",
          "402:     handle->send_queue_count++;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "03e53f1cf76e9388e46fd66406b91ef598876986",
      "candidate_info": {
        "commit_hash": "03e53f1cf76e9388e46fd66406b91ef598876986",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/03e53f1cf76e9388e46fd66406b91ef598876986",
        "files": [
          "docs/src/fs.rst",
          "include/uv.h",
          "src/unix/fs.c",
          "src/uv-common.c",
          "src/uv-common.h",
          "src/win/fs.c",
          "test/test-fs.c",
          "test/test-list.h",
          "test/test-threadpool-cancel.c"
        ],
        "message": "fs: rename uv_fs_readdir to uv_fs_scandir\n\nCloses #1431",
        "before_after_code_files": [
          "include/uv.h||include/uv.h",
          "src/unix/fs.c||src/unix/fs.c",
          "src/uv-common.c||src/uv-common.c",
          "src/uv-common.h||src/uv-common.h",
          "src/win/fs.c||src/win/fs.c",
          "test/test-fs.c||test/test-fs.c",
          "test/test-list.h||test/test-list.h",
          "test/test-threadpool-cancel.c||test/test-threadpool-cancel.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "include/uv.h||include/uv.h": [
          "File: include/uv.h -> include/uv.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "1031:   UV_FS_MKDIR,",
          "1032:   UV_FS_MKDTEMP,",
          "1033:   UV_FS_RENAME,",
          "1035:   UV_FS_LINK,",
          "1036:   UV_FS_SYMLINK,",
          "1037:   UV_FS_READLINK,",
          "",
          "[Removed Lines]",
          "1034:   UV_FS_READDIR,",
          "",
          "[Added Lines]",
          "1034:   UV_FS_SCANDIR,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1094:                           uv_fs_t* req,",
          "1095:                           const char* path,",
          "1096:                           uv_fs_cb cb);",
          "1098:                             uv_fs_t* req,",
          "1099:                             const char* path,",
          "1100:                             int flags,",
          "1101:                             uv_fs_cb cb);",
          "1103:                                  uv_dirent_t* ent);",
          "1104: UV_EXTERN int uv_fs_stat(uv_loop_t* loop,",
          "1105:                          uv_fs_t* req,",
          "",
          "[Removed Lines]",
          "1097: UV_EXTERN int uv_fs_readdir(uv_loop_t* loop,",
          "1102: UV_EXTERN int uv_fs_readdir_next(uv_fs_t* req,",
          "",
          "[Added Lines]",
          "1097: UV_EXTERN int uv_fs_scandir(uv_loop_t* loop,",
          "1102: UV_EXTERN int uv_fs_scandir_next(uv_fs_t* req,",
          "",
          "---------------"
        ],
        "src/unix/fs.c||src/unix/fs.c": [
          "File: src/unix/fs.c -> src/unix/fs.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "297: #if defined(__OpenBSD__) || (defined(__APPLE__) && !defined(MAC_OS_X_VERSION_10_8))",
          "299: #else",
          "301: #endif",
          "302:   return strcmp(dent->d_name, \".\") != 0 && strcmp(dent->d_name, \"..\") != 0;",
          "303: }",
          "308:   uv__dirent_t **dents;",
          "309:   int saved_errno;",
          "310:   int n;",
          "312:   dents = NULL;",
          "316:   req->nbufs = 0;",
          "",
          "[Removed Lines]",
          "298: static int uv__fs_readdir_filter(uv__dirent_t* dent) {",
          "300: static int uv__fs_readdir_filter(const uv__dirent_t* dent) {",
          "307: static ssize_t uv__fs_readdir(uv_fs_t* req) {",
          "313:   n = scandir(req->path, &dents, uv__fs_readdir_filter, alphasort);",
          "",
          "[Added Lines]",
          "298: static int uv__fs_scandir_filter(uv__dirent_t* dent) {",
          "300: static int uv__fs_scandir_filter(const uv__dirent_t* dent) {",
          "306: static ssize_t uv__fs_scandir(uv_fs_t* req) {",
          "312:   n = scandir(req->path, &dents, uv__fs_scandir_filter, alphasort);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "779:     X(MKDIR, mkdir(req->path, req->mode));",
          "780:     X(MKDTEMP, uv__fs_mkdtemp(req));",
          "781:     X(READ, uv__fs_read(req));",
          "783:     X(READLINK, uv__fs_readlink(req));",
          "784:     X(RENAME, rename(req->path, req->new_path));",
          "785:     X(RMDIR, rmdir(req->path));",
          "",
          "[Removed Lines]",
          "782:     X(READDIR, uv__fs_readdir(req));",
          "",
          "[Added Lines]",
          "781:     X(SCANDIR, uv__fs_scandir(req));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1040: }",
          "1044:                   uv_fs_t* req,",
          "1045:                   const char* path,",
          "1046:                   int flags,",
          "1047:                   uv_fs_cb cb) {",
          "1049:   PATH;",
          "1050:   req->flags = flags;",
          "1051:   POST;",
          "",
          "[Removed Lines]",
          "1043: int uv_fs_readdir(uv_loop_t* loop,",
          "1048:   INIT(READDIR);",
          "",
          "[Added Lines]",
          "1042: int uv_fs_scandir(uv_loop_t* loop,",
          "1047:   INIT(SCANDIR);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1167:   req->path = NULL;",
          "1168:   req->new_path = NULL;",
          "1173:   if (req->ptr != &req->statbuf)",
          "1174:     free(req->ptr);",
          "",
          "[Removed Lines]",
          "1170:   if (req->fs_type == UV_FS_READDIR && req->ptr != NULL)",
          "1171:     uv__fs_readdir_cleanup(req);",
          "",
          "[Added Lines]",
          "1169:   if (req->fs_type == UV_FS_SCANDIR && req->ptr != NULL)",
          "1170:     uv__fs_scandir_cleanup(req);",
          "",
          "---------------"
        ],
        "src/uv-common.c||src/uv-common.c": [
          "File: src/uv-common.c -> src/uv-common.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "437: }",
          "441:   uv__dirent_t** dents;",
          "443:   dents = req->ptr;",
          "",
          "[Removed Lines]",
          "440: void uv__fs_readdir_cleanup(uv_fs_t* req) {",
          "",
          "[Added Lines]",
          "440: void uv__fs_scandir_cleanup(uv_fs_t* req) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "448: }",
          "452:   uv__dirent_t** dents;",
          "453:   uv__dirent_t* dent;",
          "",
          "[Removed Lines]",
          "451: int uv_fs_readdir_next(uv_fs_t* req, uv_dirent_t* ent) {",
          "",
          "[Added Lines]",
          "451: int uv_fs_scandir_next(uv_fs_t* req, uv_dirent_t* ent) {",
          "",
          "---------------"
        ],
        "src/uv-common.h||src/uv-common.h": [
          "File: src/uv-common.h -> src/uv-common.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "110: int uv__socket_sockopt(uv_handle_t* handle, int optname, int* value);",
          "114: #define uv__has_active_reqs(loop)                                             \\",
          "115:   (QUEUE_EMPTY(&(loop)->active_reqs) == 0)",
          "",
          "[Removed Lines]",
          "112: void uv__fs_readdir_cleanup(uv_fs_t* req);",
          "",
          "[Added Lines]",
          "112: void uv__fs_scandir_cleanup(uv_fs_t* req);",
          "",
          "---------------"
        ],
        "src/win/fs.c||src/win/fs.c": [
          "File: src/win/fs.c -> src/win/fs.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "783: }",
          "787:   WCHAR* pathw = req->pathw;",
          "788:   size_t len = wcslen(pathw);",
          "789:   int result;",
          "",
          "[Removed Lines]",
          "786: void fs__readdir(uv_fs_t* req) {",
          "",
          "[Added Lines]",
          "786: void fs__scandir(uv_fs_t* req) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1604:     XX(MKDIR, mkdir)",
          "1605:     XX(MKDTEMP, mkdtemp)",
          "1606:     XX(RENAME, rename)",
          "1608:     XX(LINK, link)",
          "1609:     XX(SYMLINK, symlink)",
          "1610:     XX(READLINK, readlink)",
          "",
          "[Removed Lines]",
          "1607:     XX(READDIR, readdir)",
          "",
          "[Added Lines]",
          "1607:     XX(SCANDIR, scandir)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1839: }",
          "1843:     uv_fs_cb cb) {",
          "1844:   int err;",
          "1848:   err = fs__capture_path(loop, req, path, NULL, cb != NULL);",
          "1849:   if (err) {",
          "",
          "[Removed Lines]",
          "1842: int uv_fs_readdir(uv_loop_t* loop, uv_fs_t* req, const char* path, int flags,",
          "1846:   uv_fs_req_init(loop, req, UV_FS_READDIR, cb);",
          "",
          "[Added Lines]",
          "1842: int uv_fs_scandir(uv_loop_t* loop, uv_fs_t* req, const char* path, int flags,",
          "1846:   uv_fs_req_init(loop, req, UV_FS_SCANDIR, cb);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1856:     QUEUE_FS_TP_JOB(loop, req);",
          "1857:     return 0;",
          "1858:   } else {",
          "1860:     return req->result;",
          "1861:   }",
          "1862: }",
          "",
          "[Removed Lines]",
          "1859:     fs__readdir(req);",
          "",
          "[Added Lines]",
          "1859:     fs__scandir(req);",
          "",
          "---------------"
        ],
        "test/test-fs.c||test/test-fs.c": [
          "File: test/test-fs.c -> test/test-fs.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "67: static int mkdir_cb_count;",
          "68: static int mkdtemp_cb_count;",
          "69: static int rmdir_cb_count;",
          "71: static int stat_cb_count;",
          "72: static int rename_cb_count;",
          "73: static int fsync_cb_count;",
          "",
          "[Removed Lines]",
          "70: static int readdir_cb_count;",
          "",
          "[Added Lines]",
          "70: static int scandir_cb_count;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "97: static uv_fs_t mkdtemp_req1;",
          "98: static uv_fs_t mkdtemp_req2;",
          "99: static uv_fs_t rmdir_req;",
          "101: static uv_fs_t stat_req;",
          "102: static uv_fs_t rename_req;",
          "103: static uv_fs_t fsync_req;",
          "",
          "[Removed Lines]",
          "100: static uv_fs_t readdir_req;",
          "",
          "[Added Lines]",
          "100: static uv_fs_t scandir_req;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "416: }",
          "420:   uv_dirent_t dent;",
          "423:   ASSERT(req->result == 2);",
          "424:   ASSERT(req->ptr);",
          "427:     ASSERT(strcmp(dent.name, \"file1\") == 0 || strcmp(dent.name, \"file2\") == 0);",
          "428:     ASSERT(dent.type == UV_DIRENT_FILE || dent.type == UV_DIRENT_UNKNOWN);",
          "429:   }",
          "431:   ASSERT(req->path);",
          "432:   ASSERT(memcmp(req->path, \"test_dir\\0\", 9) == 0);",
          "433:   uv_fs_req_cleanup(req);",
          "",
          "[Removed Lines]",
          "419: static void readdir_cb(uv_fs_t* req) {",
          "421:   ASSERT(req == &readdir_req);",
          "422:   ASSERT(req->fs_type == UV_FS_READDIR);",
          "426:   while (UV_EOF != uv_fs_readdir_next(req, &dent)) {",
          "430:   readdir_cb_count++;",
          "",
          "[Added Lines]",
          "419: static void scandir_cb(uv_fs_t* req) {",
          "421:   ASSERT(req == &scandir_req);",
          "422:   ASSERT(req->fs_type == UV_FS_SCANDIR);",
          "426:   while (UV_EOF != uv_fs_scandir_next(req, &dent)) {",
          "430:   scandir_cb_count++;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "435: }",
          "439:   uv_dirent_t dent;",
          "443:   ASSERT(req->result == 0);",
          "444:   ASSERT(req->ptr == NULL);",
          "446:   uv_fs_req_cleanup(req);",
          "448: }",
          "454:   ASSERT(req->result == UV_ENOTDIR);",
          "455:   ASSERT(req->ptr == NULL);",
          "456:   uv_fs_req_cleanup(req);",
          "458: }",
          "",
          "[Removed Lines]",
          "438: static void empty_readdir_cb(uv_fs_t* req) {",
          "441:   ASSERT(req == &readdir_req);",
          "442:   ASSERT(req->fs_type == UV_FS_READDIR);",
          "445:   ASSERT(UV_EOF == uv_fs_readdir_next(req, &dent));",
          "447:   readdir_cb_count++;",
          "451: static void file_readdir_cb(uv_fs_t* req) {",
          "452:   ASSERT(req == &readdir_req);",
          "453:   ASSERT(req->fs_type == UV_FS_READDIR);",
          "457:   readdir_cb_count++;",
          "",
          "[Added Lines]",
          "438: static void empty_scandir_cb(uv_fs_t* req) {",
          "441:   ASSERT(req == &scandir_req);",
          "442:   ASSERT(req->fs_type == UV_FS_SCANDIR);",
          "445:   ASSERT(UV_EOF == uv_fs_scandir_next(req, &dent));",
          "447:   scandir_cb_count++;",
          "451: static void file_scandir_cb(uv_fs_t* req) {",
          "452:   ASSERT(req == &scandir_req);",
          "453:   ASSERT(req->fs_type == UV_FS_SCANDIR);",
          "457:   scandir_cb_count++;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "841:   ASSERT(r == 0);",
          "842:   uv_fs_req_cleanup(&close_req);",
          "845:   ASSERT(r == 0);",
          "847:   uv_run(loop, UV_RUN_DEFAULT);",
          "852:   ASSERT(r == 2);",
          "856:     ASSERT(strcmp(dent.name, \"file1\") == 0 || strcmp(dent.name, \"file2\") == 0);",
          "857:     ASSERT(dent.type == UV_DIRENT_FILE || dent.type == UV_DIRENT_UNKNOWN);",
          "858:   }",
          "862:   r = uv_fs_stat(loop, &stat_req, \"test_dir\", stat_cb);",
          "863:   ASSERT(r == 0);",
          "",
          "[Removed Lines]",
          "844:   r = uv_fs_readdir(loop, &readdir_req, \"test_dir\", 0, readdir_cb);",
          "848:   ASSERT(readdir_cb_count == 1);",
          "851:   r = uv_fs_readdir(loop, &readdir_req, \"test_dir\", 0, NULL);",
          "853:   ASSERT(readdir_req.result == 2);",
          "854:   ASSERT(readdir_req.ptr);",
          "855:   while (UV_EOF != uv_fs_readdir_next(&readdir_req, &dent)) {",
          "859:   uv_fs_req_cleanup(&readdir_req);",
          "860:   ASSERT(!readdir_req.ptr);",
          "",
          "[Added Lines]",
          "844:   r = uv_fs_scandir(loop, &scandir_req, \"test_dir\", 0, scandir_cb);",
          "848:   ASSERT(scandir_cb_count == 1);",
          "851:   r = uv_fs_scandir(loop, &scandir_req, \"test_dir\", 0, NULL);",
          "853:   ASSERT(scandir_req.result == 2);",
          "854:   ASSERT(scandir_req.ptr);",
          "855:   while (UV_EOF != uv_fs_scandir_next(&scandir_req, &dent)) {",
          "859:   uv_fs_req_cleanup(&scandir_req);",
          "860:   ASSERT(!scandir_req.ptr);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1604:   ASSERT(r == 0);",
          "1605:   uv_fs_req_cleanup(&close_req);",
          "1608:   ASSERT(r == 2);",
          "1612:     ASSERT(strcmp(dent.name, \"file1\") == 0 || strcmp(dent.name, \"file2\") == 0);",
          "1613:     ASSERT(dent.type == UV_DIRENT_FILE || dent.type == UV_DIRENT_UNKNOWN);",
          "1614:   }",
          "1619:   r = uv_fs_unlink(loop, &req, \"test_dir_symlink\", NULL);",
          "1620:   ASSERT(r == 0);",
          "1621:   uv_fs_req_cleanup(&req);",
          "1624:   ASSERT(r == UV_ENOENT);",
          "1628:   ASSERT(r == 2);",
          "1632:     ASSERT(strcmp(dent.name, \"file1\") == 0 || strcmp(dent.name, \"file2\") == 0);",
          "1633:     ASSERT(dent.type == UV_DIRENT_FILE || dent.type == UV_DIRENT_UNKNOWN);",
          "1634:   }",
          "1639:   unlink(\"test_dir/file1\");",
          "",
          "[Removed Lines]",
          "1607:   r = uv_fs_readdir(loop, &readdir_req, \"test_dir_symlink\", 0, NULL);",
          "1609:   ASSERT(readdir_req.result == 2);",
          "1610:   ASSERT(readdir_req.ptr);",
          "1611:   while (UV_EOF != uv_fs_readdir_next(&readdir_req, &dent)) {",
          "1615:   uv_fs_req_cleanup(&readdir_req);",
          "1616:   ASSERT(!readdir_req.ptr);",
          "1623:   r = uv_fs_readdir(loop, &readdir_req, \"test_dir_symlink\", 0, NULL);",
          "1625:   uv_fs_req_cleanup(&readdir_req);",
          "1627:   r = uv_fs_readdir(loop, &readdir_req, \"test_dir\", 0, NULL);",
          "1629:   ASSERT(readdir_req.result == 2);",
          "1630:   ASSERT(readdir_req.ptr);",
          "1631:   while (UV_EOF != uv_fs_readdir_next(&readdir_req, &dent)) {",
          "1635:   uv_fs_req_cleanup(&readdir_req);",
          "1636:   ASSERT(!readdir_req.ptr);",
          "",
          "[Added Lines]",
          "1607:   r = uv_fs_scandir(loop, &scandir_req, \"test_dir_symlink\", 0, NULL);",
          "1609:   ASSERT(scandir_req.result == 2);",
          "1610:   ASSERT(scandir_req.ptr);",
          "1611:   while (UV_EOF != uv_fs_scandir_next(&scandir_req, &dent)) {",
          "1615:   uv_fs_req_cleanup(&scandir_req);",
          "1616:   ASSERT(!scandir_req.ptr);",
          "1623:   r = uv_fs_scandir(loop, &scandir_req, \"test_dir_symlink\", 0, NULL);",
          "1625:   uv_fs_req_cleanup(&scandir_req);",
          "1627:   r = uv_fs_scandir(loop, &scandir_req, \"test_dir\", 0, NULL);",
          "1629:   ASSERT(scandir_req.result == 2);",
          "1630:   ASSERT(scandir_req.ptr);",
          "1631:   while (UV_EOF != uv_fs_scandir_next(&scandir_req, &dent)) {",
          "1635:   uv_fs_req_cleanup(&scandir_req);",
          "1636:   ASSERT(!scandir_req.ptr);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1805: }",
          "1809:   const char* path;",
          "1810:   uv_fs_t req;",
          "1811:   uv_dirent_t dent;",
          "",
          "[Removed Lines]",
          "1808: TEST_IMPL(fs_readdir_empty_dir) {",
          "",
          "[Added Lines]",
          "1808: TEST_IMPL(fs_scandir_empty_dir) {",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1821:   memset(&req, 0xdb, sizeof(req));",
          "1824:   ASSERT(r == 0);",
          "1825:   ASSERT(req.result == 0);",
          "1826:   ASSERT(req.ptr == NULL);",
          "1828:   uv_fs_req_cleanup(&req);",
          "1831:   ASSERT(r == 0);",
          "1834:   uv_run(loop, UV_RUN_DEFAULT);",
          "1837:   uv_fs_rmdir(loop, &req, path, NULL);",
          "1838:   uv_fs_req_cleanup(&req);",
          "",
          "[Removed Lines]",
          "1823:   r = uv_fs_readdir(loop, &req, path, 0, NULL);",
          "1827:   ASSERT(UV_EOF == uv_fs_readdir_next(&req, &dent));",
          "1830:   r = uv_fs_readdir(loop, &readdir_req, path, 0, empty_readdir_cb);",
          "1833:   ASSERT(readdir_cb_count == 0);",
          "1835:   ASSERT(readdir_cb_count == 1);",
          "",
          "[Added Lines]",
          "1823:   r = uv_fs_scandir(loop, &req, path, 0, NULL);",
          "1827:   ASSERT(UV_EOF == uv_fs_scandir_next(&req, &dent));",
          "1830:   r = uv_fs_scandir(loop, &scandir_req, path, 0, empty_scandir_cb);",
          "1833:   ASSERT(scandir_cb_count == 0);",
          "1835:   ASSERT(scandir_cb_count == 1);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1842: }",
          "1846:   const char* path;",
          "1847:   int r;",
          "1849:   path = \"test/fixtures/empty_file\";",
          "1850:   loop = uv_default_loop();",
          "1853:   ASSERT(r == UV_ENOTDIR);",
          "1857:   ASSERT(r == 0);",
          "1860:   uv_run(loop, UV_RUN_DEFAULT);",
          "1863:   MAKE_VALGRIND_HAPPY();",
          "1864:   return 0;",
          "",
          "[Removed Lines]",
          "1845: TEST_IMPL(fs_readdir_file) {",
          "1852:   r = uv_fs_readdir(loop, &readdir_req, path, 0, NULL);",
          "1854:   uv_fs_req_cleanup(&readdir_req);",
          "1856:   r = uv_fs_readdir(loop, &readdir_req, path, 0, file_readdir_cb);",
          "1859:   ASSERT(readdir_cb_count == 0);",
          "1861:   ASSERT(readdir_cb_count == 1);",
          "",
          "[Added Lines]",
          "1845: TEST_IMPL(fs_scandir_file) {",
          "1852:   r = uv_fs_scandir(loop, &scandir_req, path, 0, NULL);",
          "1854:   uv_fs_req_cleanup(&scandir_req);",
          "1856:   r = uv_fs_scandir(loop, &scandir_req, path, 0, file_scandir_cb);",
          "1859:   ASSERT(scandir_cb_count == 0);",
          "1861:   ASSERT(scandir_cb_count == 1);",
          "",
          "---------------"
        ],
        "test/test-list.h||test/test-list.h": [
          "File: test/test-list.h -> test/test-list.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "241: TEST_DECLARE   (fs_event_start_and_close)",
          "242: TEST_DECLARE   (fs_event_error_reporting)",
          "243: TEST_DECLARE   (fs_event_getpath)",
          "246: TEST_DECLARE   (fs_open_dir)",
          "247: TEST_DECLARE   (fs_rename_to_existing_file)",
          "248: TEST_DECLARE   (threadpool_queue_work_simple)",
          "",
          "[Removed Lines]",
          "244: TEST_DECLARE   (fs_readdir_empty_dir)",
          "245: TEST_DECLARE   (fs_readdir_file)",
          "",
          "[Added Lines]",
          "244: TEST_DECLARE   (fs_scandir_empty_dir)",
          "245: TEST_DECLARE   (fs_scandir_file)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "612:   TEST_ENTRY  (fs_event_start_and_close)",
          "613:   TEST_ENTRY  (fs_event_error_reporting)",
          "614:   TEST_ENTRY  (fs_event_getpath)",
          "617:   TEST_ENTRY  (fs_open_dir)",
          "618:   TEST_ENTRY  (fs_rename_to_existing_file)",
          "619:   TEST_ENTRY  (threadpool_queue_work_simple)",
          "",
          "[Removed Lines]",
          "615:   TEST_ENTRY  (fs_readdir_empty_dir)",
          "616:   TEST_ENTRY  (fs_readdir_file)",
          "",
          "[Added Lines]",
          "615:   TEST_ENTRY  (fs_scandir_empty_dir)",
          "616:   TEST_ENTRY  (fs_scandir_file)",
          "",
          "---------------"
        ],
        "test/test-threadpool-cancel.c||test/test-threadpool-cancel.c": [
          "File: test/test-threadpool-cancel.c -> test/test-threadpool-cancel.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "301:   ASSERT(0 == uv_fs_mkdir(loop, reqs + n++, \"/\", 0, fs_cb));",
          "302:   ASSERT(0 == uv_fs_open(loop, reqs + n++, \"/\", 0, 0, fs_cb));",
          "303:   ASSERT(0 == uv_fs_read(loop, reqs + n++, 0, NULL, 0, 0, fs_cb));",
          "305:   ASSERT(0 == uv_fs_readlink(loop, reqs + n++, \"/\", fs_cb));",
          "306:   ASSERT(0 == uv_fs_rename(loop, reqs + n++, \"/\", \"/\", fs_cb));",
          "307:   ASSERT(0 == uv_fs_mkdir(loop, reqs + n++, \"/\", 0, fs_cb));",
          "",
          "[Removed Lines]",
          "304:   ASSERT(0 == uv_fs_readdir(loop, reqs + n++, \"/\", 0, fs_cb));",
          "",
          "[Added Lines]",
          "304:   ASSERT(0 == uv_fs_scandir(loop, reqs + n++, \"/\", 0, fs_cb));",
          "",
          "---------------"
        ]
      }
    }
  ]
}
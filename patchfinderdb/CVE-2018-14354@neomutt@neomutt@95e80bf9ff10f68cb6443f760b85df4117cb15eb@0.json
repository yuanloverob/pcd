{
  "cve_id": "CVE-2018-14354",
  "cve_desc": "An issue was discovered in Mutt before 1.10.1 and NeoMutt before 2018-07-16. They allow remote IMAP servers to execute arbitrary commands via backquote characters, related to the mailboxes command associated with a manual subscription or unsubscription.",
  "repo": "neomutt/neomutt",
  "patch_hash": "95e80bf9ff10f68cb6443f760b85df4117cb15eb",
  "patch_info": {
    "commit_hash": "95e80bf9ff10f68cb6443f760b85df4117cb15eb",
    "repo": "neomutt/neomutt",
    "commit_url": "https://github.com/neomutt/neomutt/commit/95e80bf9ff10f68cb6443f760b85df4117cb15eb",
    "files": [
      "imap/imap.c"
    ],
    "message": "Quote path in imap_subscribe",
    "before_after_code_files": [
      "imap/imap.c||imap/imap.c"
    ]
  },
  "patch_diff": {
    "imap/imap.c||imap/imap.c": [
      "File: imap/imap.c -> imap/imap.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1709:   char errstr[STRING];",
      "1710:   struct Buffer err, token;",
      "1711:   struct ImapMbox mx;",
      "1713:   if (!mx_is_imap(path) || imap_parse_path(path, &mx) || !mx.mbox)",
      "1714:   {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1712:   size_t len = 0;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1729:     mutt_buffer_init(&err);",
      "1730:     err.data = errstr;",
      "1731:     err.dsize = sizeof(errstr);",
      "1733:     if (mutt_parse_rc_line(mbox, &token, &err))",
      "1734:       mutt_debug(1, \"Error adding subscribed mailbox: %s\\n\", errstr);",
      "1735:     FREE(&token.data);",
      "",
      "[Removed Lines]",
      "1732:     snprintf(mbox, sizeof(mbox), \"%smailboxes \\\"%s\\\"\", subscribe ? \"\" : \"un\", path);",
      "",
      "[Added Lines]",
      "1733:  len = snprintf(mbox, sizeof(mbox), \"%smailboxes \", subscribe ? \"\" : \"un\");",
      "1734:  imap_quote_string(mbox + len, sizeof(mbox) - len, path, true);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "00dc67c7de86d196f0e412165dff7aeadec34ea3",
      "candidate_info": {
        "commit_hash": "00dc67c7de86d196f0e412165dff7aeadec34ea3",
        "repo": "neomutt/neomutt",
        "commit_url": "https://github.com/neomutt/neomutt/commit/00dc67c7de86d196f0e412165dff7aeadec34ea3",
        "files": [
          "address/group.c",
          "address/group.h",
          "browser.c",
          "complete.c",
          "compress.c",
          "conn/ssl.c",
          "copy.c",
          "doc/makedoc.c",
          "icommands.c",
          "imap/imap.c",
          "maildir/shared.c",
          "mutt/envlist.c",
          "ncrypt/crypt_gpgme.c",
          "ncrypt/pgp.c",
          "nntp/complete.c",
          "nntp/nntp.c",
          "notmuch/mutt_notmuch.c",
          "pop/pop.c"
        ],
        "message": "light tidying\n\nLots of minor fixes, many inspired by cppcheck.\n\n- reduce scope of variables\n- return early\n- NULL pointers after free\n- fix typos\n- correct retval type",
        "before_after_code_files": [
          "address/group.c||address/group.c",
          "address/group.h||address/group.h",
          "browser.c||browser.c",
          "complete.c||complete.c",
          "compress.c||compress.c",
          "conn/ssl.c||conn/ssl.c",
          "copy.c||copy.c",
          "icommands.c||icommands.c",
          "imap/imap.c||imap/imap.c",
          "maildir/shared.c||maildir/shared.c",
          "mutt/envlist.c||mutt/envlist.c",
          "ncrypt/crypt_gpgme.c||ncrypt/crypt_gpgme.c",
          "ncrypt/pgp.c||ncrypt/pgp.c",
          "nntp/complete.c||nntp/complete.c",
          "nntp/nntp.c||nntp/nntp.c",
          "notmuch/mutt_notmuch.c||notmuch/mutt_notmuch.c",
          "pop/pop.c||pop/pop.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "imap/imap.c||imap/imap.c"
          ],
          "candidate": [
            "imap/imap.c||imap/imap.c"
          ]
        }
      },
      "candidate_diff": {
        "address/group.c||address/group.c": [
          "File: address/group.c -> address/group.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "64: struct Group *mutt_pattern_group(const char *pat)",
          "65: {",
          "66:   if (!pat)",
          "69:   struct Group *g = mutt_hash_find(Groups, pat);",
          "70:   if (!g)",
          "",
          "[Removed Lines]",
          "67:     return 0;",
          "",
          "[Added Lines]",
          "67:     return NULL;",
          "",
          "---------------"
        ],
        "address/group.h||address/group.h": [
          "File: address/group.h -> address/group.h"
        ],
        "browser.c||browser.c": [
          "File: browser.c -> browser.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "372:                                      const char *if_str, const char *else_str,",
          "373:                                      unsigned long data, MuttFormatFlags flags)",
          "374: {",
          "376:   struct Folder *folder = (struct Folder *) data;",
          "377:   int optional = (flags & MUTT_FORMAT_OPTIONAL);",
          "",
          "[Removed Lines]",
          "375:   char fn[128], fmt[128], permission[11];",
          "",
          "[Added Lines]",
          "375:   char fn[128], fmt[128];",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "437:       break;",
          "438:     }",
          "439:     case 'F':",
          "440:       if (folder->ff->local)",
          "441:       {",
          "442:         snprintf(permission, sizeof(permission), \"%c%c%c%c%c%c%c%c%c%c\",",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "440:     {",
          "441:       char permission[11];",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "470:       else",
          "471:         mutt_format_s(buf, buflen, prec, \"\");",
          "472:       break;",
          "474:     case 'g':",
          "475:       if (folder->ff->local)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "475:     }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1336:   if (multiple)",
          "1337:     menu->menu_tag = file_tag;",
          "1340:   menu->help = mutt_compile_help(helpstr, sizeof(helpstr), MENU_FOLDER,",
          "1341: #ifdef USE_NNTP",
          "1342:                                  OptNews ? FolderNewsHelp :",
          "",
          "[Removed Lines]",
          "1339:   menu->menu_make_entry = folder_make_entry;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "complete.c||complete.c": [
          "File: complete.c -> complete.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "180:         for (i = 0; filepart[i] && de->d_name[i]; i++)",
          "181:         {",
          "182:           if (filepart[i] != de->d_name[i])",
          "185:             break;",
          "187:         }",
          "188:         filepart[i] = '\\0';",
          "189:       }",
          "",
          "[Removed Lines]",
          "183:           {",
          "184:             filepart[i] = '\\0';",
          "186:           }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "compress.c||compress.c": [
          "File: compress.c -> compress.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "441: int comp_ac_add(struct Account *a, struct Mailbox *m)",
          "442: {",
          "447:     return -1;",
          "449:   m->account = a;",
          "",
          "[Removed Lines]",
          "443:   if (!a || !m)",
          "444:     return -1;",
          "446:   if (m->magic != MUTT_COMPRESSED)",
          "",
          "[Added Lines]",
          "443:   if (!a || !m || (m->magic != MUTT_COMPRESSED))",
          "",
          "---------------"
        ],
        "conn/ssl.c||conn/ssl.c": [
          "File: conn/ssl.c -> conn/ssl.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1310: free_ssl:",
          "1311:   SSL_free(ssldata->ssl);",
          "1312:   ssldata->ssl = 0;",
          "1313: free_ctx:",
          "1314:   SSL_CTX_free(ssldata->sctx);",
          "1315:   ssldata->sctx = 0;",
          "1316: free_sasldata:",
          "1317:   FREE(&ssldata);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1312:   ssldata->ssl = NULL;",
          "1316:   ssldata->sctx = NULL;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1394:     SSL_free(data->ssl);",
          "1395:     SSL_CTX_free(data->sctx);",
          "1396:     FREE(&conn->sockdata);",
          "1397:   }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1397:     data->ssl = NULL;",
          "1399:     data->sctx = NULL;",
          "",
          "---------------"
        ],
        "copy.c||copy.c": [
          "File: copy.c -> copy.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "500:       rfc2047_encode(&temp_hdr, NULL, sizeof(\"X-Label:\"), C_SendCharset);",
          "501:     }",
          "502:     if (mutt_write_one_header(",
          "504:             mutt_window_wrap_cols(MuttIndexWindow, C_Wrap), chflags) == -1)",
          "505:     {",
          "506:       return -1;",
          "",
          "[Removed Lines]",
          "503:             fp_out, \"X-Label\", temp_hdr, chflags & CH_PREFIX ? prefix : 0,",
          "",
          "[Added Lines]",
          "503:             fp_out, \"X-Label\", temp_hdr, (chflags & CH_PREFIX) ? prefix : 0,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "520:       rfc2047_encode(&temp_hdr, NULL, sizeof(\"Subject:\"), C_SendCharset);",
          "521:     }",
          "522:     if (mutt_write_one_header(",
          "524:             mutt_window_wrap_cols(MuttIndexWindow, C_Wrap), chflags) == -1)",
          "525:       return -1;",
          "526:     if (!(chflags & CH_DECODE))",
          "",
          "[Removed Lines]",
          "523:             fp_out, \"Subject\", temp_hdr, chflags & CH_PREFIX ? prefix : 0,",
          "",
          "[Added Lines]",
          "523:             fp_out, \"Subject\", temp_hdr, (chflags & CH_PREFIX) ? prefix : 0,",
          "",
          "---------------"
        ],
        "icommands.c||icommands.c": [
          "File: icommands.c -> icommands.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "215: static void dump_all_menus(struct Buffer *buf, bool bind)",
          "216: {",
          "218:   for (int i = 0; i < MENU_MAX; i++)",
          "219:   {",
          "220:     const char *menu_name = mutt_map_get_name(i, Menus);",
          "221:     struct Mapping menu = { menu_name, i };",
          "226:     if (!empty && (i < (MENU_MAX - 1)))",
          "",
          "[Removed Lines]",
          "217:   bool empty;",
          "223:     empty = dump_menu(buf, &menu, bind);",
          "",
          "[Added Lines]",
          "222:     const bool empty = dump_menu(buf, &menu, bind);",
          "",
          "---------------"
        ],
        "imap/imap.c||imap/imap.c": [
          "File: imap/imap.c -> imap/imap.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1391:   struct ImapAccountData *adata = NULL;",
          "1392:   struct ImapMboxData *mdata = NULL;",
          "1393:   char buf[2048];",
          "1395:   char errstr[256];",
          "1396:   struct Buffer err, token;",
          "1399:   if (imap_adata_find(path, &adata, &mdata) < 0)",
          "1400:     return -1;",
          "1402:   if (C_ImapCheckSubscribed)",
          "1403:   {",
          "1404:     mutt_buffer_init(&token);",
          "1405:     mutt_buffer_init(&err);",
          "1406:     err.data = errstr;",
          "1407:     err.dsize = sizeof(errstr);",
          "1409:     imap_quote_string(mbox + len, sizeof(mbox) - len, path, true);",
          "1410:     if (mutt_parse_rc_line(mbox, &token, &err))",
          "1411:       mutt_debug(LL_DEBUG1, \"Error adding subscribed mailbox: %s\\n\", errstr);",
          "",
          "[Removed Lines]",
          "1394:   char mbox[1024];",
          "1397:   size_t len = 0;",
          "1408:     len = snprintf(mbox, sizeof(mbox), \"%smailboxes \", subscribe ? \"\" : \"un\");",
          "",
          "[Added Lines]",
          "1402:     char mbox[1024];",
          "1407:     size_t len = snprintf(mbox, sizeof(mbox), \"%smailboxes \", subscribe ? \"\" : \"un\");",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1845: int imap_ac_add(struct Account *a, struct Mailbox *m)",
          "1846: {",
          "1851:     return -1;",
          "1853:   struct ImapAccountData *adata = a->adata;",
          "",
          "[Removed Lines]",
          "1847:   if (!a || !m)",
          "1848:     return -1;",
          "1850:   if (m->magic != MUTT_IMAP)",
          "",
          "[Added Lines]",
          "1846:   if (!a || !m || (m->magic != MUTT_IMAP))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2459:   if (!buf)",
          "2460:     return -1;",
          "2462:   char tmp[PATH_MAX];",
          "2463:   char tmp2[PATH_MAX];",
          "2474:   return 0;",
          "2475: }",
          "",
          "[Removed Lines]",
          "2464:   struct Url *url = url_parse(buf);",
          "2465:   if (url)",
          "2466:   {",
          "2467:     imap_fix_path('\\0', url->path, tmp, sizeof(tmp));",
          "2468:     url->path = tmp;",
          "2469:     url_tostring(url, tmp2, sizeof(tmp2), 0);",
          "2470:     mutt_str_strfcpy(buf, tmp2, buflen);",
          "2471:     url_free(&url);",
          "2472:   }",
          "",
          "[Added Lines]",
          "2458:   struct Url *url = url_parse(buf);",
          "2459:   if (!url)",
          "2460:     return 0;",
          "2465:   imap_fix_path('\\0', url->path, tmp, sizeof(tmp));",
          "2466:   url->path = tmp;",
          "2467:   url_tostring(url, tmp2, sizeof(tmp2), 0);",
          "2468:   mutt_str_strfcpy(buf, tmp2, buflen);",
          "2469:   url_free(&url);",
          "",
          "---------------"
        ],
        "maildir/shared.c||maildir/shared.c": [
          "File: maildir/shared.c -> maildir/shared.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1497: bool maildir_update_flags(struct Mailbox *m, struct Email *o, struct Email *n)",
          "1498: {",
          "1499:   if (!m)",
          "",
          "[Removed Lines]",
          "1500:     return -1;",
          "",
          "[Added Lines]",
          "1500:     return false;",
          "",
          "---------------"
        ],
        "mutt/envlist.c||mutt/envlist.c": [
          "File: mutt/envlist.c -> mutt/envlist.c"
        ],
        "ncrypt/crypt_gpgme.c||ncrypt/crypt_gpgme.c": [
          "File: ncrypt/crypt_gpgme.c -> ncrypt/crypt_gpgme.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3474:       char buf2[128];",
          "3475:       bool do_locales = true;",
          "3476:       struct tm tm = { 0 };",
          "3479:       char *p = buf;",
          "",
          "[Removed Lines]",
          "3477:       size_t len;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3485:         cp++;",
          "3486:       }",
          "3489:       while ((len > 0) && (*cp != ']'))",
          "3490:       {",
          "3491:         if (*cp == '%')",
          "",
          "[Removed Lines]",
          "3488:       len = buflen - 1;",
          "",
          "[Added Lines]",
          "3487:       size_t len = buflen - 1;",
          "",
          "---------------"
        ],
        "ncrypt/pgp.c||ncrypt/pgp.c": [
          "File: ncrypt/pgp.c -> ncrypt/pgp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "689:       if (clearsign)",
          "690:       {",
          "691:         rewind(fp_tmp);",
          "694:       }",
          "695:       else if (fp_pgp_out)",
          "696:       {",
          "",
          "[Removed Lines]",
          "692:         if (fp_tmp)",
          "693:           pgp_copy_clearsigned(fp_tmp, s, body_charset);",
          "",
          "[Added Lines]",
          "692:         pgp_copy_clearsigned(fp_tmp, s, body_charset);",
          "",
          "---------------"
        ],
        "nntp/complete.c||nntp/complete.c": [
          "File: nntp/complete.c -> nntp/complete.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "82:         for (i = 0; filepart[i] && mdata->group[i]; i++)",
          "83:         {",
          "84:           if (filepart[i] != mdata->group[i])",
          "87:             break;",
          "89:         }",
          "90:         filepart[i] = '\\0';",
          "91:       }",
          "",
          "[Removed Lines]",
          "85:           {",
          "86:             filepart[i] = '\\0';",
          "88:           }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "nntp/nntp.c||nntp/nntp.c": [
          "File: nntp/nntp.c -> nntp/nntp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2626:     struct Email *e = m->emails[i];",
          "2627:     char buf[16];",
          "2630:     if (mdata->bcache && e->deleted)",
          "2631:     {",
          "2632:       mutt_debug(LL_DEBUG2, \"mutt_bcache_del %s\\n\", buf);",
          "",
          "[Removed Lines]",
          "2629:     snprintf(buf, sizeof(buf), \"%d\", nntp_edata_get(e)->article_num);",
          "",
          "[Added Lines]",
          "2629:     snprintf(buf, sizeof(buf), ANUM, nntp_edata_get(e)->article_num);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2713:       FREE(&acache->path);",
          "2714:     }",
          "2715:   }",
          "2717:   msg->fp = mutt_bcache_get(mdata->bcache, article);",
          "2718:   if (msg->fp)",
          "2719:   {",
          "",
          "[Removed Lines]",
          "2716:   snprintf(article, sizeof(article), \"%d\", nntp_edata_get(e)->article_num);",
          "",
          "[Added Lines]",
          "2716:   snprintf(article, sizeof(article), ANUM, nntp_edata_get(e)->article_num);",
          "",
          "---------------"
        ],
        "notmuch/mutt_notmuch.c||notmuch/mutt_notmuch.c": [
          "File: notmuch/mutt_notmuch.c -> notmuch/mutt_notmuch.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "559: static void apply_exclude_tags(notmuch_query_t *query)",
          "560: {",
          "562:     return;",
          "564:   char *end = NULL, *tag = NULL;",
          "",
          "[Removed Lines]",
          "561:   if (!C_NmExcludeTags || !*C_NmExcludeTags)",
          "",
          "[Added Lines]",
          "561:   if (!C_NmExcludeTags || !query || !*C_NmExcludeTags)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2161:   if (!a || !m || (m->magic != MUTT_NOTMUCH))",
          "2162:     return -1;",
          "2171:   return 0;",
          "2172: }",
          "",
          "[Removed Lines]",
          "2164:   if (!a->adata)",
          "2165:   {",
          "2166:     struct NmAccountData *adata = nm_adata_new();",
          "2167:     a->adata = adata;",
          "2168:     a->free_adata = nm_adata_free;",
          "2169:   }",
          "",
          "[Added Lines]",
          "2164:   if (a->adata)",
          "2165:     return 0;",
          "2167:   struct NmAccountData *adata = nm_adata_new();",
          "2168:   a->adata = adata;",
          "2169:   a->free_adata = nm_adata_free;",
          "",
          "---------------"
        ],
        "pop/pop.c||pop/pop.c": [
          "File: pop/pop.c -> pop/pop.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "779:   if (!a || !m || (m->magic != MUTT_POP))",
          "780:     return -1;",
          "808:   return 0;",
          "809: }",
          "",
          "[Removed Lines]",
          "782:   if (!a->adata)",
          "783:   {",
          "784:     struct PopAccountData *adata = pop_adata_new();",
          "785:     a->adata = adata;",
          "786:     a->free_adata = pop_adata_free;",
          "788:     struct Url *url = url_parse(mutt_b2s(m->pathbuf));",
          "789:     if (url)",
          "790:     {",
          "791:       mutt_str_strfcpy(adata->conn_account.user, url->user,",
          "792:                        sizeof(adata->conn_account.user));",
          "793:       mutt_str_strfcpy(adata->conn_account.pass, url->pass,",
          "794:                        sizeof(adata->conn_account.pass));",
          "795:       mutt_str_strfcpy(adata->conn_account.host, url->host,",
          "796:                        sizeof(adata->conn_account.host));",
          "797:       adata->conn_account.port = url->port;",
          "798:       adata->conn_account.type = MUTT_ACCT_TYPE_POP;",
          "800:       if (adata->conn_account.user[0] != '\\0')",
          "801:         adata->conn_account.flags |= MUTT_ACCT_USER;",
          "802:       if (adata->conn_account.pass[0] != '\\0')",
          "803:         adata->conn_account.flags |= MUTT_ACCT_PASS;",
          "804:       url_free(&url);",
          "805:     }",
          "806:   }",
          "",
          "[Added Lines]",
          "782:   if (a->adata)",
          "783:     return 0;",
          "785:   struct PopAccountData *adata = pop_adata_new();",
          "786:   a->adata = adata;",
          "787:   a->free_adata = pop_adata_free;",
          "789:   struct Url *url = url_parse(mutt_b2s(m->pathbuf));",
          "790:   if (!url)",
          "791:     return 0;",
          "793:   mutt_str_strfcpy(adata->conn_account.user, url->user,",
          "794:                    sizeof(adata->conn_account.user));",
          "795:   mutt_str_strfcpy(adata->conn_account.pass, url->pass,",
          "796:                    sizeof(adata->conn_account.pass));",
          "797:   mutt_str_strfcpy(adata->conn_account.host, url->host,",
          "798:                    sizeof(adata->conn_account.host));",
          "799:   adata->conn_account.port = url->port;",
          "800:   adata->conn_account.type = MUTT_ACCT_TYPE_POP;",
          "802:   if (adata->conn_account.user[0] != '\\0')",
          "803:     adata->conn_account.flags |= MUTT_ACCT_USER;",
          "804:   if (adata->conn_account.pass[0] != '\\0')",
          "805:     adata->conn_account.flags |= MUTT_ACCT_PASS;",
          "806:   url_free(&url);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "d58a649a71e922009c670afc7ed563bd71f87479",
      "candidate_info": {
        "commit_hash": "d58a649a71e922009c670afc7ed563bd71f87479",
        "repo": "neomutt/neomutt",
        "commit_url": "https://github.com/neomutt/neomutt/commit/d58a649a71e922009c670afc7ed563bd71f87479",
        "files": [
          "imap/auth_cram.c",
          "imap/imap.c",
          "imap/imap.h",
          "imap/imap_private.h",
          "imap/message.c"
        ],
        "message": "rearrange functions\n\nNo code changes\n\nStatic functions first\nGeneral public functions\nMailbox functions",
        "before_after_code_files": [
          "imap/auth_cram.c||imap/auth_cram.c",
          "imap/imap.c||imap/imap.c",
          "imap/imap.h||imap/imap.h",
          "imap/imap_private.h||imap/imap_private.h",
          "imap/message.c||imap/message.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "imap/imap.c||imap/imap.c"
          ],
          "candidate": [
            "imap/imap.c||imap/imap.c"
          ]
        }
      },
      "candidate_diff": {
        "imap/auth_cram.c||imap/auth_cram.c": [
          "File: imap/auth_cram.c -> imap/auth_cram.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "37: #define MD5_BLOCK_LEN 64",
          "38: #define MD5_DIGEST_LEN 16",
          "",
          "[Removed Lines]",
          "41: static void hmac_md5(const char *password, char *challenge, unsigned char *response);",
          "",
          "[Added Lines]",
          "43: static void hmac_md5(const char *password, char *challenge, unsigned char *response)",
          "44: {",
          "45:   struct Md5Ctx ctx;",
          "46:   unsigned char ipad[MD5_BLOCK_LEN], opad[MD5_BLOCK_LEN];",
          "47:   unsigned char secret[MD5_BLOCK_LEN + 1];",
          "48:   unsigned char hash_passwd[MD5_DIGEST_LEN];",
          "49:   unsigned int secret_len, chal_len;",
          "51:   secret_len = strlen(password);",
          "52:   chal_len = strlen(challenge);",
          "56:   if (secret_len > MD5_BLOCK_LEN)",
          "57:   {",
          "58:     md5_buffer(password, secret_len, hash_passwd);",
          "59:     strfcpy((char *) secret, (char *) hash_passwd, MD5_DIGEST_LEN);",
          "60:     secret_len = MD5_DIGEST_LEN;",
          "61:   }",
          "62:   else",
          "63:     strfcpy((char *) secret, password, sizeof(secret));",
          "65:   memset(ipad, 0, sizeof(ipad));",
          "66:   memset(opad, 0, sizeof(opad));",
          "67:   memcpy(ipad, secret, secret_len);",
          "68:   memcpy(opad, secret, secret_len);",
          "70:   for (int i = 0; i < MD5_BLOCK_LEN; i++)",
          "71:   {",
          "72:     ipad[i] ^= 0x36;",
          "73:     opad[i] ^= 0x5c;",
          "74:   }",
          "77:   md5_init_ctx(&ctx);",
          "78:   md5_process_bytes(ipad, MD5_BLOCK_LEN, &ctx);",
          "79:   md5_process_bytes(challenge, chal_len, &ctx);",
          "80:   md5_finish_ctx(&ctx, response);",
          "83:   md5_init_ctx(&ctx);",
          "84:   md5_process_bytes(opad, MD5_BLOCK_LEN, &ctx);",
          "85:   md5_process_bytes(response, MD5_DIGEST_LEN, &ctx);",
          "86:   md5_finish_ctx(&ctx, response);",
          "87: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "138:   mutt_sleep(2);",
          "139:   return IMAP_AUTH_FAILURE;",
          "140: }",
          "",
          "[Removed Lines]",
          "145: static void hmac_md5(const char *password, char *challenge, unsigned char *response)",
          "146: {",
          "147:   struct Md5Ctx ctx;",
          "148:   unsigned char ipad[MD5_BLOCK_LEN], opad[MD5_BLOCK_LEN];",
          "149:   unsigned char secret[MD5_BLOCK_LEN + 1];",
          "150:   unsigned char hash_passwd[MD5_DIGEST_LEN];",
          "151:   unsigned int secret_len, chal_len;",
          "153:   secret_len = strlen(password);",
          "154:   chal_len = strlen(challenge);",
          "158:   if (secret_len > MD5_BLOCK_LEN)",
          "159:   {",
          "160:     md5_buffer(password, secret_len, hash_passwd);",
          "161:     strfcpy((char *) secret, (char *) hash_passwd, MD5_DIGEST_LEN);",
          "162:     secret_len = MD5_DIGEST_LEN;",
          "163:   }",
          "164:   else",
          "165:     strfcpy((char *) secret, password, sizeof(secret));",
          "167:   memset(ipad, 0, sizeof(ipad));",
          "168:   memset(opad, 0, sizeof(opad));",
          "169:   memcpy(ipad, secret, secret_len);",
          "170:   memcpy(opad, secret, secret_len);",
          "172:   for (int i = 0; i < MD5_BLOCK_LEN; i++)",
          "173:   {",
          "174:     ipad[i] ^= 0x36;",
          "175:     opad[i] ^= 0x5c;",
          "176:   }",
          "179:   md5_init_ctx(&ctx);",
          "180:   md5_process_bytes(ipad, MD5_BLOCK_LEN, &ctx);",
          "181:   md5_process_bytes(challenge, chal_len, &ctx);",
          "182:   md5_finish_ctx(&ctx, response);",
          "185:   md5_init_ctx(&ctx);",
          "186:   md5_process_bytes(opad, MD5_BLOCK_LEN, &ctx);",
          "187:   md5_process_bytes(response, MD5_DIGEST_LEN, &ctx);",
          "188:   md5_finish_ctx(&ctx, response);",
          "189: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "imap/imap.c||imap/imap.c": [
          "File: imap/imap.c -> imap/imap.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "64: #include \"mutt_ssl.h\"",
          "65: #endif",
          "79: {",
          "92:   {",
          "94:     return -1;",
          "95:   }",
          "110:   {",
          "124:     return -1;",
          "125:   }",
          "134:   return 0;",
          "135: }",
          "138: {",
          "145:   {",
          "148:   }",
          "176:   {",
          "184:   }",
          "186:   {",
          "188:   }",
          "197: }",
          "205: {",
          "219: }",
          "228: {",
          "235:   {",
          "248:     {",
          "251:     }",
          "263:   }",
          "266: }",
          "276: {",
          "350: }",
          "356: {",
          "358:   {",
          "360:     return -1;",
          "361:   }",
          "365:   {",
          "370:     return -1;",
          "371:   }",
          "373:   return 0;",
          "374: }",
          "383: {",
          "390:   {",
          "398:     {",
          "407:     }",
          "413:   }",
          "435:   {",
          "437:     {",
          "479:   }",
          "482:   {",
          "490:     {",
          "499:       {",
          "504:         {",
          "517:         }",
          "518:       }",
          "519:     }",
          "540:   }",
          "542:   return 0;",
          "551: }",
          "554: {",
          "562: }",
          "570: {",
          "583:   {",
          "586:   }",
          "590:   {",
          "610:   }",
          "615: }",
          "618: {",
          "619:   struct ImapData *idata = NULL;",
          "621:   char buf[LONG_STRING];",
          "625:   int rc;",
          "630:     return -1;",
          "635:   if (!idata)",
          "675:   {",
          "684:   }",
          "702:   {",
          "765:   {",
          "772:   }",
          "780:   {",
          "783:   }",
          "788:   {",
          "804:   }",
          "819:   {",
          "823:   }",
          "827:   return 0;",
          "835: }",
          "838: {",
          "840:   char buf[LONG_STRING];",
          "877:     return -1;",
          "879:   return 0;",
          "880: }",
          "886: {",
          "892:   {",
          "895:   }",
          "910:     return -1;",
          "913:   return 0;",
          "914: }",
          "923: {",
          "927: }",
          "937: {",
          "943:   {",
          "949:   }",
          "952: }",
          "962: {",
          "1011:     {",
          "1014:       {",
          "1023:       }",
          "",
          "[Removed Lines]",
          "68: static char *imap_get_flags(struct ListHead *hflags, char *s);",
          "69: static int imap_check_capabilities(struct ImapData *idata);",
          "70: static void imap_set_flag(struct ImapData *idata, int aclbit, int flag,",
          "71:                           const char *str, char *flags, size_t flsize);",
          "78: int imap_access(const char *path)",
          "80:   struct ImapData *idata = NULL;",
          "81:   struct ImapMbox mx;",
          "82:   char buf[LONG_STRING];",
          "83:   char mailbox[LONG_STRING];",
          "84:   char mbox[LONG_STRING];",
          "85:   int rc;",
          "87:   if (imap_parse_path(path, &mx))",
          "88:     return -1;",
          "90:   idata = imap_conn_find(&mx.account, option(OPT_IMAP_PASSIVE) ? MUTT_IMAP_CONN_NONEW : 0);",
          "91:   if (!idata)",
          "93:     FREE(&mx.mbox);",
          "97:   imap_fix_path(idata, mx.mbox, mailbox, sizeof(mailbox));",
          "98:   if (!*mailbox)",
          "99:     strfcpy(mailbox, \"INBOX\", sizeof(mailbox));",
          "102:   if (mutt_strcmp(idata->mailbox, mx.mbox) == 0)",
          "103:   {",
          "104:     FREE(&mx.mbox);",
          "105:     return 0;",
          "106:   }",
          "107:   FREE(&mx.mbox);",
          "109:   if (imap_mboxcache_get(idata, mailbox, 0))",
          "111:     mutt_debug(3, \"imap_access: found %s in cache\\n\", mailbox);",
          "112:     return 0;",
          "113:   }",
          "115:   imap_munge_mbox_name(idata, mbox, sizeof(mbox), mailbox);",
          "117:   if (mutt_bit_isset(idata->capabilities, IMAP4REV1))",
          "118:     snprintf(buf, sizeof(buf), \"STATUS %s (UIDVALIDITY)\", mbox);",
          "119:   else if (mutt_bit_isset(idata->capabilities, STATUS))",
          "120:     snprintf(buf, sizeof(buf), \"STATUS %s (UID-VALIDITY)\", mbox);",
          "121:   else",
          "122:   {",
          "123:     mutt_debug(2, \"imap_access: STATUS not supported?\\n\");",
          "127:   rc = imap_exec(idata, buf, IMAP_CMD_FAIL_OK);",
          "128:   if (rc < 0)",
          "129:   {",
          "130:     mutt_debug(1, \"imap_access: Can't check STATUS of %s\\n\", mbox);",
          "131:     return rc;",
          "132:   }",
          "137: int imap_create_mailbox(struct ImapData *idata, char *mailbox)",
          "139:   char buf[LONG_STRING], mbox[LONG_STRING];",
          "141:   imap_munge_mbox_name(idata, mbox, sizeof(mbox), mailbox);",
          "142:   snprintf(buf, sizeof(buf), \"CREATE %s\", mbox);",
          "144:   if (imap_exec(idata, buf, 0) != 0)",
          "146:     mutt_error(_(\"CREATE failed: %s\"), imap_cmd_trailer(idata));",
          "147:     return -1;",
          "150:   return 0;",
          "151: }",
          "153: int imap_rename_mailbox(struct ImapData *idata, struct ImapMbox *mx, const char *newname)",
          "154: {",
          "155:   char oldmbox[LONG_STRING];",
          "156:   char newmbox[LONG_STRING];",
          "157:   char buf[LONG_STRING];",
          "159:   imap_munge_mbox_name(idata, oldmbox, sizeof(oldmbox), mx->mbox);",
          "160:   imap_munge_mbox_name(idata, newmbox, sizeof(newmbox), newname);",
          "162:   snprintf(buf, sizeof(buf), \"RENAME %s %s\", oldmbox, newmbox);",
          "164:   if (imap_exec(idata, buf, 0) != 0)",
          "165:     return -1;",
          "167:   return 0;",
          "168: }",
          "170: int imap_delete_mailbox(struct Context *ctx, struct ImapMbox *mx)",
          "171: {",
          "172:   char buf[LONG_STRING], mbox[LONG_STRING];",
          "173:   struct ImapData *idata = NULL;",
          "175:   if (!ctx || !ctx->data)",
          "177:     idata = imap_conn_find(&mx->account,",
          "178:                            option(OPT_IMAP_PASSIVE) ? MUTT_IMAP_CONN_NONEW : 0);",
          "179:     if (!idata)",
          "180:     {",
          "181:       FREE(&mx->mbox);",
          "182:       return -1;",
          "183:     }",
          "185:   else",
          "187:     idata = ctx->data;",
          "190:   imap_munge_mbox_name(idata, mbox, sizeof(mbox), mx->mbox);",
          "191:   snprintf(buf, sizeof(buf), \"DELETE %s\", mbox);",
          "193:   if (imap_exec(idata, buf, 0) != 0)",
          "194:     return -1;",
          "196:   return 0;",
          "204: void imap_logout_all(void)",
          "206:   struct ConnectionList *head = mutt_socket_head();",
          "207:   struct Connection *np, *tmp;",
          "208:   TAILQ_FOREACH_SAFE(np, head, entries, tmp)",
          "209:   {",
          "210:     if (np->account.type == MUTT_ACCT_TYPE_IMAP && np->fd >= 0)",
          "211:     {",
          "212:       TAILQ_REMOVE(head, np, entries);",
          "213:       mutt_message(_(\"Closing connection to %s...\"), np->account.host);",
          "214:       imap_logout((struct ImapData **) (void *) &np->data);",
          "215:       mutt_clear_error();",
          "216:       mutt_socket_free(np);",
          "217:     }",
          "218:   }",
          "227: int imap_read_literal(FILE *fp, struct ImapData *idata, long bytes, struct Progress *pbar)",
          "229:   char c;",
          "230:   bool r = false;",
          "232:   mutt_debug(2, \"imap_read_literal: reading %ld bytes\\n\", bytes);",
          "234:   for (long pos = 0; pos < bytes; pos++)",
          "236:     if (mutt_socket_readchar(idata->conn, &c) != 1)",
          "237:     {",
          "238:       mutt_debug(1, \"imap_read_literal: error during read, %ld bytes read\\n\", pos);",
          "239:       idata->status = IMAP_FATAL;",
          "241:       return -1;",
          "242:     }",
          "244:     if (r && c != '\\n')",
          "245:       fputc('\\r', fp);",
          "247:     if (c == '\\r')",
          "249:       r = true;",
          "250:       continue;",
          "252:     else",
          "253:       r = false;",
          "255:     fputc(c, fp);",
          "257:     if (pbar && !(pos % 1024))",
          "258:       mutt_progress_update(pbar, pos, -1);",
          "259: #ifdef DEBUG",
          "260:     if (debuglevel >= IMAP_LOG_LTRL)",
          "261:       fputc(c, debugfile);",
          "262: #endif",
          "265:   return 0;",
          "275: void imap_expunge_mailbox(struct ImapData *idata)",
          "277:   struct Header *h = NULL;",
          "278:   int cacheno;",
          "279:   short old_sort;",
          "281: #ifdef USE_HCACHE",
          "282:   idata->hcache = imap_hcache_open(idata, NULL);",
          "283: #endif",
          "285:   old_sort = Sort;",
          "286:   Sort = SORT_ORDER;",
          "287:   mutt_sort_headers(idata->ctx, 0);",
          "289:   for (int i = 0; i < idata->ctx->msgcount; i++)",
          "290:   {",
          "291:     h = idata->ctx->hdrs[i];",
          "293:     if (h->index == INT_MAX)",
          "294:     {",
          "295:       mutt_debug(2, \"Expunging message UID %d.\\n\", HEADER_DATA(h)->uid);",
          "297:       h->active = false;",
          "298:       idata->ctx->size -= h->content->length;",
          "300:       imap_cache_del(idata, h);",
          "301: #ifdef USE_HCACHE",
          "302:       imap_hcache_del(idata, HEADER_DATA(h)->uid);",
          "303: #endif",
          "306:       cacheno = HEADER_DATA(h)->uid % IMAP_CACHE_LEN;",
          "307:       if (idata->cache[cacheno].uid == HEADER_DATA(h)->uid &&",
          "308:           idata->cache[cacheno].path)",
          "309:       {",
          "310:         unlink(idata->cache[cacheno].path);",
          "311:         FREE(&idata->cache[cacheno].path);",
          "312:       }",
          "314:       int_hash_delete(idata->uid_hash, HEADER_DATA(h)->uid, h, NULL);",
          "316:       imap_free_header_data((struct ImapHeaderData **) &h->data);",
          "317:     }",
          "318:     else",
          "319:     {",
          "320:       h->index = i;",
          "337:       h->active = true;",
          "338:     }",
          "339:   }",
          "341: #ifdef USE_HCACHE",
          "342:   imap_hcache_close(idata);",
          "343: #endif",
          "347:   mx_update_tables(idata->ctx, false);",
          "348:   Sort = old_sort;",
          "349:   mutt_sort_headers(idata->ctx, 1);",
          "355: static int imap_check_capabilities(struct ImapData *idata)",
          "357:   if (imap_exec(idata, \"CAPABILITY\", 0) != 0)",
          "359:     imap_error(\"imap_check_capabilities\", idata->buf);",
          "363:   if (!(mutt_bit_isset(idata->capabilities, IMAP4) ||",
          "364:         mutt_bit_isset(idata->capabilities, IMAP4REV1)))",
          "366:     mutt_error(",
          "367:         _(\"This IMAP server is ancient. NeoMutt does not work with it.\"));",
          "382: struct ImapData *imap_conn_find(const struct Account *account, int flags)",
          "384:   struct Connection *conn = NULL;",
          "385:   struct Account *creds = NULL;",
          "386:   struct ImapData *idata = NULL;",
          "387:   bool new = false;",
          "389:   while ((conn = mutt_conn_find(conn, account)))",
          "391:     if (!creds)",
          "392:       creds = &conn->account;",
          "393:     else",
          "394:       memcpy(&conn->account, creds, sizeof(struct Account));",
          "396:     idata = conn->data;",
          "397:     if (flags & MUTT_IMAP_CONN_NONEW)",
          "399:       if (!idata)",
          "400:       {",
          "402:         mutt_socket_free(conn);",
          "403:         return NULL;",
          "404:       }",
          "405:       else if (idata->state < IMAP_AUTHENTICATED)",
          "406:         continue;",
          "408:     if (flags & MUTT_IMAP_CONN_NOSELECT && idata && idata->state >= IMAP_SELECTED)",
          "409:       continue;",
          "410:     if (idata && idata->status == IMAP_FATAL)",
          "411:       continue;",
          "412:     break;",
          "414:   if (!conn)",
          "417:   if (!idata)",
          "418:   {",
          "420:     idata = imap_new_idata();",
          "421:     if (!idata)",
          "422:     {",
          "423:       mutt_socket_free(conn);",
          "424:       return NULL;",
          "425:     }",
          "427:     conn->data = idata;",
          "428:     idata->conn = conn;",
          "429:     new = true;",
          "430:   }",
          "432:   if (idata->state == IMAP_DISCONNECTED)",
          "433:     imap_open_connection(idata);",
          "434:   if (idata->state == IMAP_CONNECTED)",
          "436:     if (!imap_authenticate(idata))",
          "438:       idata->state = IMAP_AUTHENTICATED;",
          "439:       FREE(&idata->capstr);",
          "440:       new = true;",
          "441:       if (idata->conn->ssf)",
          "442:         mutt_debug(2, \"Communication encrypted at %d bits\\n\", idata->conn->ssf);",
          "443:     }",
          "444:     else",
          "445:       mutt_account_unsetpass(&idata->conn->account);",
          "446:   }",
          "447:   if (new && idata->state == IMAP_AUTHENTICATED)",
          "448:   {",
          "450:     imap_exec(idata, \"CAPABILITY\", IMAP_CMD_QUEUE);",
          "452:     if (mutt_bit_isset(idata->capabilities, ENABLE))",
          "453:       imap_exec(idata, \"ENABLE UTF8=ACCEPT\", IMAP_CMD_QUEUE);",
          "455:     idata->delim = '/';",
          "456:     imap_exec(idata, \"LIST \\\"\\\" \\\"\\\"\", IMAP_CMD_QUEUE);",
          "457:     if (option(OPT_IMAP_CHECK_SUBSCRIBED))",
          "458:       imap_exec(idata, \"LSUB \\\"\\\" \\\"*\\\"\", IMAP_CMD_QUEUE);",
          "460:     imap_exec(idata, NULL, IMAP_CMD_FAIL_OK);",
          "461:   }",
          "463:   return idata;",
          "464: }",
          "466: int imap_open_connection(struct ImapData *idata)",
          "467: {",
          "468:   char buf[LONG_STRING];",
          "470:   if (mutt_socket_open(idata->conn) < 0)",
          "471:     return -1;",
          "473:   idata->state = IMAP_CONNECTED;",
          "475:   if (imap_cmd_step(idata) != IMAP_CMD_OK)",
          "476:   {",
          "477:     imap_close_connection(idata);",
          "478:     return -1;",
          "481:   if (mutt_strncasecmp(\"* OK\", idata->buf, 4) == 0)",
          "483:     if ((mutt_strncasecmp(\"* OK [CAPABILITY\", idata->buf, 16) != 0) &&",
          "484:         imap_check_capabilities(idata))",
          "485:       goto bail;",
          "486: #ifdef USE_SSL",
          "488:     if (!idata->conn->ssf &&",
          "489:         (option(OPT_SSL_FORCE_TLS) || mutt_bit_isset(idata->capabilities, STARTTLS)))",
          "491:       int rc;",
          "493:       if (option(OPT_SSL_FORCE_TLS))",
          "494:         rc = MUTT_YES;",
          "495:       else if ((rc = query_quadoption(OPT_SSL_STARTTLS,",
          "496:                                       _(\"Secure connection with TLS?\"))) == MUTT_ABORT)",
          "497:         goto err_close_conn;",
          "498:       if (rc == MUTT_YES)",
          "500:         rc = imap_exec(idata, \"STARTTLS\", IMAP_CMD_FAIL_OK);",
          "501:         if (rc == -1)",
          "502:           goto bail;",
          "503:         if (rc != -2)",
          "505:           if (mutt_ssl_starttls(idata->conn))",
          "506:           {",
          "507:             mutt_error(_(\"Could not negotiate TLS connection\"));",
          "508:             mutt_sleep(1);",
          "509:             goto err_close_conn;",
          "510:           }",
          "511:           else",
          "512:           {",
          "514:             if (imap_exec(idata, \"CAPABILITY\", 0))",
          "515:               goto bail;",
          "516:           }",
          "521:     if (option(OPT_SSL_FORCE_TLS) && !idata->conn->ssf)",
          "522:     {",
          "523:       mutt_error(_(\"Encrypted connection unavailable\"));",
          "524:       mutt_sleep(1);",
          "525:       goto err_close_conn;",
          "526:     }",
          "527: #endif",
          "528:   }",
          "529:   else if (mutt_strncasecmp(\"* PREAUTH\", idata->buf, 9) == 0)",
          "530:   {",
          "531:     idata->state = IMAP_AUTHENTICATED;",
          "532:     if (imap_check_capabilities(idata) != 0)",
          "533:       goto bail;",
          "534:     FREE(&idata->capstr);",
          "535:   }",
          "536:   else",
          "537:   {",
          "538:     imap_error(\"imap_open_connection()\", buf);",
          "539:     goto bail;",
          "544: #ifdef USE_SSL",
          "545: err_close_conn:",
          "546:   imap_close_connection(idata);",
          "547: #endif",
          "548: bail:",
          "549:   FREE(&idata->capstr);",
          "550:   return -1;",
          "553: void imap_close_connection(struct ImapData *idata)",
          "555:   if (idata->state != IMAP_DISCONNECTED)",
          "556:   {",
          "557:     mutt_socket_close(idata->conn);",
          "558:     idata->state = IMAP_DISCONNECTED;",
          "559:   }",
          "560:   idata->seqno = idata->nextcmd = idata->lastcmd = idata->status = false;",
          "561:   memset(idata->cmds, 0, sizeof(struct ImapCommand) * idata->cmdslots);",
          "569: static char *imap_get_flags(struct ListHead *hflags, char *s)",
          "571:   char *flag_word = NULL;",
          "572:   char ctmp;",
          "575:   if (mutt_strncasecmp(\"FLAGS\", s, 5) != 0)",
          "576:   {",
          "577:     mutt_debug(1, \"imap_get_flags: not a FLAGS response: %s\\n\", s);",
          "578:     return NULL;",
          "579:   }",
          "580:   s += 5;",
          "581:   SKIPWS(s);",
          "582:   if (*s != '(')",
          "584:     mutt_debug(1, \"imap_get_flags: bogus FLAGS response: %s\\n\", s);",
          "585:     return NULL;",
          "589:   while (*s && *s != ')')",
          "591:     s++;",
          "592:     SKIPWS(s);",
          "593:     flag_word = s;",
          "594:     while (*s && (*s != ')') && !ISSPACE(*s))",
          "595:       s++;",
          "596:     ctmp = *s;",
          "598:     if (*flag_word)",
          "599:       mutt_list_insert_tail(hflags, safe_strdup(flag_word));",
          "601:   }",
          "604:   if (*s != ')')",
          "605:   {",
          "606:     mutt_debug(1, \"imap_get_flags: Unterminated FLAGS response: %s\\n\", s);",
          "607:     mutt_list_free(hflags);",
          "609:     return NULL;",
          "612:   s++;",
          "614:   return s;",
          "617: static int imap_open_mailbox(struct Context *ctx)",
          "620:   struct ImapStatus *status = NULL;",
          "622:   char bufout[LONG_STRING];",
          "623:   int count = 0;",
          "624:   struct ImapMbox mx, pmx;",
          "627:   if (imap_parse_path(ctx->path, &mx))",
          "628:   {",
          "629:     mutt_error(_(\"%s is an invalid IMAP path\"), ctx->path);",
          "631:   }",
          "634:   idata = imap_conn_find(&(mx.account), MUTT_IMAP_CONN_NOSELECT);",
          "636:     goto fail_noidata;",
          "637:   if (idata->state < IMAP_AUTHENTICATED)",
          "638:     goto fail;",
          "641:   ctx->data = idata;",
          "644:   imap_fix_path(idata, mx.mbox, buf, sizeof(buf));",
          "645:   if (!*buf)",
          "646:     strfcpy(buf, \"INBOX\", sizeof(buf));",
          "647:   FREE(&(idata->mailbox));",
          "648:   idata->mailbox = safe_strdup(buf);",
          "649:   imap_qualify_path(buf, sizeof(buf), &mx, idata->mailbox);",
          "651:   FREE(&(ctx->path));",
          "652:   FREE(&(ctx->realpath));",
          "653:   ctx->path = safe_strdup(buf);",
          "654:   ctx->realpath = safe_strdup(ctx->path);",
          "656:   idata->ctx = ctx;",
          "659:   idata->status = false;",
          "660:   memset(idata->ctx->rights, 0, sizeof(idata->ctx->rights));",
          "661:   idata->new_mail_count = 0;",
          "662:   idata->max_msn = 0;",
          "664:   mutt_message(_(\"Selecting %s...\"), idata->mailbox);",
          "665:   imap_munge_mbox_name(idata, buf, sizeof(buf), idata->mailbox);",
          "668:   if (mutt_bit_isset(idata->capabilities, ACL))",
          "669:   {",
          "670:     snprintf(bufout, sizeof(bufout), \"MYRIGHTS %s\", buf);",
          "671:     imap_exec(idata, bufout, IMAP_CMD_QUEUE);",
          "672:   }",
          "674:   else",
          "676:     mutt_bit_set(idata->ctx->rights, MUTT_ACL_LOOKUP);",
          "677:     mutt_bit_set(idata->ctx->rights, MUTT_ACL_READ);",
          "678:     mutt_bit_set(idata->ctx->rights, MUTT_ACL_SEEN);",
          "679:     mutt_bit_set(idata->ctx->rights, MUTT_ACL_WRITE);",
          "680:     mutt_bit_set(idata->ctx->rights, MUTT_ACL_INSERT);",
          "681:     mutt_bit_set(idata->ctx->rights, MUTT_ACL_POST);",
          "682:     mutt_bit_set(idata->ctx->rights, MUTT_ACL_CREATE);",
          "683:     mutt_bit_set(idata->ctx->rights, MUTT_ACL_DELETE);",
          "686:   pmx.mbox = NULL;",
          "687:   if (mx_is_imap(Postponed) && !imap_parse_path(Postponed, &pmx) &&",
          "688:       mutt_account_match(&pmx.account, &mx.account))",
          "689:     imap_status(Postponed, 1);",
          "690:   FREE(&pmx.mbox);",
          "692:   snprintf(bufout, sizeof(bufout), \"%s %s\",",
          "693:            ctx->readonly ? \"EXAMINE\" : \"SELECT\", buf);",
          "695:   idata->state = IMAP_SELECTED;",
          "697:   imap_cmd_start(idata, bufout);",
          "699:   status = imap_mboxcache_get(idata, idata->mailbox, 1);",
          "701:   do",
          "703:     char *pc = NULL;",
          "705:     rc = imap_cmd_step(idata);",
          "706:     if (rc != IMAP_CMD_CONTINUE)",
          "707:       break;",
          "709:     pc = idata->buf + 2;",
          "713:     if (mutt_strncasecmp(\"FLAGS\", pc, 5) == 0)",
          "714:     {",
          "716:       if (STAILQ_EMPTY(&idata->flags))",
          "717:       {",
          "718:         mutt_debug(3, \"Getting mailbox FLAGS\\n\");",
          "719:         pc = imap_get_flags(&idata->flags, pc);",
          "720:         if (!pc)",
          "721:           goto fail;",
          "722:       }",
          "723:     }",
          "725:     else if (mutt_strncasecmp(\"OK [PERMANENTFLAGS\", pc, 18) == 0)",
          "726:     {",
          "727:       mutt_debug(3, \"Getting mailbox PERMANENTFLAGS\\n\");",
          "729:       mutt_list_free(&idata->flags);",
          "731:       pc += 13;",
          "732:       pc = imap_get_flags(&(idata->flags), pc);",
          "733:       if (!pc)",
          "734:         goto fail;",
          "735:     }",
          "737:     else if (mutt_strncasecmp(\"OK [UIDVALIDITY\", pc, 14) == 0)",
          "738:     {",
          "739:       mutt_debug(3, \"Getting mailbox UIDVALIDITY\\n\");",
          "740:       pc += 3;",
          "741:       pc = imap_next_word(pc);",
          "742:       idata->uid_validity = strtol(pc, NULL, 10);",
          "743:       status->uidvalidity = idata->uid_validity;",
          "744:     }",
          "745:     else if (mutt_strncasecmp(\"OK [UIDNEXT\", pc, 11) == 0)",
          "746:     {",
          "747:       mutt_debug(3, \"Getting mailbox UIDNEXT\\n\");",
          "748:       pc += 3;",
          "749:       pc = imap_next_word(pc);",
          "750:       idata->uidnext = strtol(pc, NULL, 10);",
          "751:       status->uidnext = idata->uidnext;",
          "752:     }",
          "753:     else",
          "754:     {",
          "755:       pc = imap_next_word(pc);",
          "756:       if (mutt_strncasecmp(\"EXISTS\", pc, 6) == 0)",
          "757:       {",
          "758:         count = idata->new_mail_count;",
          "759:         idata->new_mail_count = 0;",
          "760:       }",
          "761:     }",
          "762:   } while (rc == IMAP_CMD_CONTINUE);",
          "764:   if (rc == IMAP_CMD_NO)",
          "766:     char *s = NULL;",
          "769:     mutt_error(\"%s\", s);",
          "770:     mutt_sleep(2);",
          "771:     goto fail;",
          "774:   if (rc != IMAP_CMD_OK)",
          "775:     goto fail;",
          "778:   if ((mutt_strncasecmp(imap_get_qualifier(idata->buf), \"[READ-ONLY]\", 11) == 0) &&",
          "779:       !mutt_bit_isset(idata->capabilities, ACL))",
          "781:     mutt_debug(2, \"Mailbox is read-only.\\n\");",
          "782:     ctx->readonly = true;",
          "785: #ifdef DEBUG",
          "787:   if (debuglevel > 2)",
          "789:     if (STAILQ_EMPTY(&idata->flags))",
          "790:       mutt_debug(3, \"No folder flags found\\n\");",
          "791:     else",
          "792:     {",
          "793:       struct ListNode *np;",
          "794:       struct Buffer flag_buffer;",
          "795:       mutt_buffer_init(&flag_buffer);",
          "796:       mutt_buffer_printf(&flag_buffer, \"Mailbox flags: \");",
          "797:       STAILQ_FOREACH(np, &idata->flags, entries)",
          "798:       {",
          "799:         mutt_buffer_printf(&flag_buffer, \"[%s] \", np->data);",
          "800:       }",
          "801:       mutt_debug(3, \"%s\\n\", flag_buffer.data);",
          "802:       FREE(&flag_buffer.data);",
          "803:     }",
          "805: #endif",
          "807:   if (!(mutt_bit_isset(idata->ctx->rights, MUTT_ACL_DELETE) ||",
          "808:         mutt_bit_isset(idata->ctx->rights, MUTT_ACL_SEEN) ||",
          "809:         mutt_bit_isset(idata->ctx->rights, MUTT_ACL_WRITE) ||",
          "810:         mutt_bit_isset(idata->ctx->rights, MUTT_ACL_INSERT)))",
          "811:     ctx->readonly = true;",
          "813:   ctx->hdrmax = count;",
          "814:   ctx->hdrs = safe_calloc(count, sizeof(struct Header *));",
          "815:   ctx->v2r = safe_calloc(count, sizeof(int));",
          "816:   ctx->msgcount = 0;",
          "818:   if (count && (imap_read_headers(idata, 1, count) < 0))",
          "820:     mutt_error(_(\"Error opening mailbox\"));",
          "821:     mutt_sleep(1);",
          "822:     goto fail;",
          "825:   mutt_debug(2, \"imap_open_mailbox: msgcount is %d\\n\", ctx->msgcount);",
          "826:   FREE(&mx.mbox);",
          "829: fail:",
          "830:   if (idata->state == IMAP_SELECTED)",
          "831:     idata->state = IMAP_AUTHENTICATED;",
          "832: fail_noidata:",
          "833:   FREE(&mx.mbox);",
          "834:   return -1;",
          "837: static int imap_open_mailbox_append(struct Context *ctx, int flags)",
          "839:   struct ImapData *idata = NULL;",
          "841:   char mailbox[LONG_STRING];",
          "842:   struct ImapMbox mx;",
          "843:   int rc;",
          "845:   if (imap_parse_path(ctx->path, &mx))",
          "846:     return -1;",
          "851:   idata = imap_conn_find(&(mx.account), 0);",
          "852:   if (!idata)",
          "853:   {",
          "854:     FREE(&mx.mbox);",
          "855:     return -1;",
          "856:   }",
          "858:   ctx->data = idata;",
          "860:   imap_fix_path(idata, mx.mbox, mailbox, sizeof(mailbox));",
          "861:   if (!*mailbox)",
          "862:     strfcpy(mailbox, \"INBOX\", sizeof(mailbox));",
          "863:   FREE(&mx.mbox);",
          "865:   rc = imap_access(ctx->path);",
          "866:   if (rc == 0)",
          "867:     return 0;",
          "869:   if (rc == -1)",
          "870:     return -1;",
          "872:   snprintf(buf, sizeof(buf), _(\"Create %s?\"), mailbox);",
          "873:   if (option(OPT_CONFIRMCREATE) && mutt_yesorno(buf, 1) != MUTT_YES)",
          "874:     return -1;",
          "876:   if (imap_create_mailbox(idata, mailbox) < 0)",
          "885: void imap_logout(struct ImapData **idata)",
          "889:   (*idata)->status = IMAP_BYE;",
          "890:   imap_cmd_start(*idata, \"LOGOUT\");",
          "891:   if (ImapPollTimeout <= 0 || mutt_socket_poll((*idata)->conn, ImapPollTimeout) != 0)",
          "893:     while (imap_cmd_step(*idata) == IMAP_CMD_CONTINUE)",
          "894:       ;",
          "897:   mutt_socket_close((*idata)->conn);",
          "898:   imap_free_idata(idata);",
          "899: }",
          "901: static int imap_open_new_message(struct Message *msg, struct Context *dest, struct Header *hdr)",
          "902: {",
          "903:   char tmp[_POSIX_PATH_MAX];",
          "905:   mutt_mktemp(tmp, sizeof(tmp));",
          "906:   msg->fp = safe_fopen(tmp, \"w\");",
          "907:   if (!msg->fp)",
          "908:   {",
          "909:     mutt_perror(tmp);",
          "911:   }",
          "912:   msg->path = safe_strdup(tmp);",
          "921: static void imap_set_flag(struct ImapData *idata, int aclbit, int flag,",
          "922:                           const char *str, char *flags, size_t flsize)",
          "924:   if (mutt_bit_isset(idata->ctx->rights, aclbit))",
          "925:     if (flag && imap_has_flag(&idata->flags, str))",
          "926:       safe_strcat(flags, flsize, str);",
          "936: bool imap_has_flag(struct ListHead *flag_list, const char *flag)",
          "938:   if (STAILQ_EMPTY(flag_list))",
          "939:     return false;",
          "941:   struct ListNode *np;",
          "942:   STAILQ_FOREACH(np, flag_list, entries)",
          "944:     if (mutt_strncasecmp(np->data, flag, strlen(np->data)) == 0)",
          "945:       return true;",
          "947:     if (mutt_strncmp(np->data, \"\\\\*\", strlen(np->data)) == 0)",
          "948:       return true;",
          "951:   return false;",
          "960: static int imap_make_msg_set(struct ImapData *idata, struct Buffer *buf,",
          "961:                              int flag, bool changed, bool invert, int *pos)",
          "963:   struct Header **hdrs = idata->ctx->hdrs;",
          "967:   int n;",
          "968:   bool started = false;",
          "970:   hdrs = idata->ctx->hdrs;",
          "972:   for (n = *pos; n < idata->ctx->msgcount && buf->dptr - buf->data < IMAP_MAX_CMDLEN; n++)",
          "973:   {",
          "974:     match = false;",
          "976:     if (hdrs[n]->active)",
          "977:       switch (flag)",
          "978:       {",
          "979:         case MUTT_DELETED:",
          "980:           if (hdrs[n]->deleted != HEADER_DATA(hdrs[n])->deleted)",
          "981:             match = invert ^ hdrs[n]->deleted;",
          "982:           break;",
          "983:         case MUTT_FLAG:",
          "984:           if (hdrs[n]->flagged != HEADER_DATA(hdrs[n])->flagged)",
          "985:             match = invert ^ hdrs[n]->flagged;",
          "986:           break;",
          "987:         case MUTT_OLD:",
          "988:           if (hdrs[n]->old != HEADER_DATA(hdrs[n])->old)",
          "989:             match = invert ^ hdrs[n]->old;",
          "990:           break;",
          "991:         case MUTT_READ:",
          "992:           if (hdrs[n]->read != HEADER_DATA(hdrs[n])->read)",
          "993:             match = invert ^ hdrs[n]->read;",
          "994:           break;",
          "995:         case MUTT_REPLIED:",
          "996:           if (hdrs[n]->replied != HEADER_DATA(hdrs[n])->replied)",
          "997:             match = invert ^ hdrs[n]->replied;",
          "998:           break;",
          "1000:         case MUTT_TAG:",
          "1001:           if (hdrs[n]->tagged)",
          "1002:             match = true;",
          "1003:           break;",
          "1004:         case MUTT_TRASH:",
          "1005:           if (hdrs[n]->deleted && !hdrs[n]->purge)",
          "1006:             match = true;",
          "1007:           break;",
          "1008:       }",
          "1010:     if (match && (!changed || hdrs[n]->changed))",
          "1012:       count++;",
          "1013:       if (setstart == 0)",
          "1015:         setstart = HEADER_DATA(hdrs[n])->uid;",
          "1016:         if (!started)",
          "1017:         {",
          "1018:           mutt_buffer_printf(buf, \"%u\", HEADER_DATA(hdrs[n])->uid);",
          "1019:           started = true;",
          "1020:         }",
          "1021:         else",
          "1022:           mutt_buffer_printf(buf, \",%u\", HEADER_DATA(hdrs[n])->uid);",
          "1025:       else if (n == idata->ctx->msgcount - 1)",
          "1026:         mutt_buffer_printf(buf, \":%u\", HEADER_DATA(hdrs[n])->uid);",
          "1027:     }",
          "1030:     else if (setstart && (hdrs[n]->active || n == idata->ctx->msgcount - 1))",
          "1031:     {",
          "1032:       if (HEADER_DATA(hdrs[n - 1])->uid > setstart)",
          "1033:         mutt_buffer_printf(buf, \":%u\", HEADER_DATA(hdrs[n - 1])->uid);",
          "1034:       setstart = 0;",
          "1035:     }",
          "1036:   }",
          "1040:   return count;",
          "1041: }",
          "",
          "[Added Lines]",
          "70: static int imap_check_capabilities(struct ImapData *idata)",
          "72:   if (imap_exec(idata, \"CAPABILITY\", 0) != 0)",
          "74:     imap_error(\"imap_check_capabilities\", idata->buf);",
          "78:   if (!(mutt_bit_isset(idata->capabilities, IMAP4) ||",
          "79:         mutt_bit_isset(idata->capabilities, IMAP4REV1)))",
          "81:     mutt_error(",
          "82:         _(\"This IMAP server is ancient. NeoMutt does not work with it.\"));",
          "96: static char *imap_get_flags(struct ListHead *hflags, char *s)",
          "98:   char *flag_word = NULL;",
          "99:   char ctmp;",
          "102:   if (mutt_strncasecmp(\"FLAGS\", s, 5) != 0)",
          "104:     mutt_debug(1, \"imap_get_flags: not a FLAGS response: %s\\n\", s);",
          "105:     return NULL;",
          "107:   s += 5;",
          "108:   SKIPWS(s);",
          "109:   if (*s != '(')",
          "111:     mutt_debug(1, \"imap_get_flags: bogus FLAGS response: %s\\n\", s);",
          "112:     return NULL;",
          "116:   while (*s && *s != ')')",
          "118:     s++;",
          "119:     SKIPWS(s);",
          "120:     flag_word = s;",
          "121:     while (*s && (*s != ')') && !ISSPACE(*s))",
          "122:       s++;",
          "123:     ctmp = *s;",
          "125:     if (*flag_word)",
          "126:       mutt_list_insert_tail(hflags, safe_strdup(flag_word));",
          "131:   if (*s != ')')",
          "132:   {",
          "133:     mutt_debug(1, \"imap_get_flags: Unterminated FLAGS response: %s\\n\", s);",
          "134:     mutt_list_free(hflags);",
          "136:     return NULL;",
          "137:   }",
          "139:   s++;",
          "141:   return s;",
          "149: static void imap_set_flag(struct ImapData *idata, int aclbit, int flag,",
          "150:                           const char *str, char *flags, size_t flsize)",
          "152:   if (mutt_bit_isset(idata->ctx->rights, aclbit))",
          "153:     if (flag && imap_has_flag(&idata->flags, str))",
          "154:       safe_strcat(flags, flsize, str);",
          "163: static int imap_make_msg_set(struct ImapData *idata, struct Buffer *buf,",
          "164:                              int flag, bool changed, bool invert, int *pos)",
          "166:   struct Header **hdrs = idata->ctx->hdrs;",
          "170:   int n;",
          "171:   bool started = false;",
          "173:   hdrs = idata->ctx->hdrs;",
          "175:   for (n = *pos; n < idata->ctx->msgcount && buf->dptr - buf->data < IMAP_MAX_CMDLEN; n++)",
          "177:     match = false;",
          "179:     if (hdrs[n]->active)",
          "180:       switch (flag)",
          "181:       {",
          "182:         case MUTT_DELETED:",
          "183:           if (hdrs[n]->deleted != HEADER_DATA(hdrs[n])->deleted)",
          "184:             match = invert ^ hdrs[n]->deleted;",
          "185:           break;",
          "186:         case MUTT_FLAG:",
          "187:           if (hdrs[n]->flagged != HEADER_DATA(hdrs[n])->flagged)",
          "188:             match = invert ^ hdrs[n]->flagged;",
          "189:           break;",
          "190:         case MUTT_OLD:",
          "191:           if (hdrs[n]->old != HEADER_DATA(hdrs[n])->old)",
          "192:             match = invert ^ hdrs[n]->old;",
          "193:           break;",
          "194:         case MUTT_READ:",
          "195:           if (hdrs[n]->read != HEADER_DATA(hdrs[n])->read)",
          "196:             match = invert ^ hdrs[n]->read;",
          "197:           break;",
          "198:         case MUTT_REPLIED:",
          "199:           if (hdrs[n]->replied != HEADER_DATA(hdrs[n])->replied)",
          "200:             match = invert ^ hdrs[n]->replied;",
          "201:           break;",
          "203:         case MUTT_TAG:",
          "204:           if (hdrs[n]->tagged)",
          "205:             match = true;",
          "206:           break;",
          "207:         case MUTT_TRASH:",
          "208:           if (hdrs[n]->deleted && !hdrs[n]->purge)",
          "209:             match = true;",
          "210:           break;",
          "211:       }",
          "213:     if (match && (!changed || hdrs[n]->changed))",
          "215:       count++;",
          "216:       if (setstart == 0)",
          "217:       {",
          "218:         setstart = HEADER_DATA(hdrs[n])->uid;",
          "219:         if (!started)",
          "220:         {",
          "221:           mutt_buffer_printf(buf, \"%u\", HEADER_DATA(hdrs[n])->uid);",
          "222:           started = true;",
          "223:         }",
          "224:         else",
          "225:           mutt_buffer_printf(buf, \",%u\", HEADER_DATA(hdrs[n])->uid);",
          "226:       }",
          "228:       else if (n == idata->ctx->msgcount - 1)",
          "229:         mutt_buffer_printf(buf, \":%u\", HEADER_DATA(hdrs[n])->uid);",
          "230:     }",
          "233:     else if (setstart && (hdrs[n]->active || n == idata->ctx->msgcount - 1))",
          "234:     {",
          "235:       if (HEADER_DATA(hdrs[n - 1])->uid > setstart)",
          "236:         mutt_buffer_printf(buf, \":%u\", HEADER_DATA(hdrs[n - 1])->uid);",
          "237:       setstart = 0;",
          "243:   return count;",
          "251: static bool compare_flags_for_copy(struct Header *h)",
          "253:   struct ImapHeaderData *hd = (struct ImapHeaderData *) h->data;",
          "255:   if (h->read != hd->read)",
          "256:     return true;",
          "257:   if (h->old != hd->old)",
          "258:     return true;",
          "259:   if (h->flagged != hd->flagged)",
          "260:     return true;",
          "261:   if (h->replied != hd->replied)",
          "262:     return true;",
          "264:   return false;",
          "265: }",
          "267: static int sync_helper(struct ImapData *idata, int right, int flag, const char *name)",
          "268: {",
          "269:   int count = 0;",
          "270:   int rc;",
          "271:   char buf[LONG_STRING];",
          "273:   if (!idata->ctx)",
          "274:     return -1;",
          "276:   if (!mutt_bit_isset(idata->ctx->rights, right))",
          "277:     return 0;",
          "279:   if (right == MUTT_ACL_WRITE && !imap_has_flag(&idata->flags, name))",
          "280:     return 0;",
          "282:   snprintf(buf, sizeof(buf), \"+FLAGS.SILENT (%s)\", name);",
          "283:   rc = imap_exec_msgset(idata, \"UID STORE\", buf, flag, 1, 0);",
          "284:   if (rc < 0)",
          "285:     return rc;",
          "286:   count += rc;",
          "288:   buf[0] = '-';",
          "289:   rc = imap_exec_msgset(idata, \"UID STORE\", buf, flag, 1, 1);",
          "290:   if (rc < 0)",
          "291:     return rc;",
          "292:   count += rc;",
          "294:   return count;",
          "300: static int imap_get_mailbox(const char *path, struct ImapData **hidata, char *buf, size_t blen)",
          "302:   struct ImapMbox mx;",
          "304:   if (imap_parse_path(path, &mx))",
          "306:     mutt_debug(1, \"imap_get_mailbox: Error parsing %s\\n\", path);",
          "309:   if (!(*hidata = imap_conn_find(&(mx.account), option(OPT_IMAP_PASSIVE) ? MUTT_IMAP_CONN_NONEW : 0)) ||",
          "310:       (*hidata)->state < IMAP_AUTHENTICATED)",
          "312:     FREE(&mx.mbox);",
          "316:   imap_fix_path(*hidata, mx.mbox, buf, blen);",
          "317:   if (!*buf)",
          "318:     strfcpy(buf, \"INBOX\", blen);",
          "319:   FREE(&mx.mbox);",
          "330: static int do_search(const struct Pattern *search, int allpats)",
          "332:   int rc = 0;",
          "333:   const struct Pattern *pat = NULL;",
          "335:   for (pat = search; pat; pat = pat->next)",
          "337:     switch (pat->op)",
          "339:       case MUTT_BODY:",
          "340:       case MUTT_HEADER:",
          "341:       case MUTT_WHOLE_MSG:",
          "342:         if (pat->stringmatch)",
          "343:           rc++;",
          "344:         break;",
          "345:       case MUTT_SERVERSEARCH:",
          "346:         rc++;",
          "347:         break;",
          "348:       default:",
          "349:         if (pat->child && do_search(pat->child, 1))",
          "350:           rc++;",
          "353:     if (!allpats)",
          "354:       break;",
          "357:   return rc;",
          "358: }",
          "367: static int imap_compile_search(struct Context *ctx, const struct Pattern *pat,",
          "368:                                struct Buffer *buf)",
          "369: {",
          "370:   if (!do_search(pat, 0))",
          "371:     return 0;",
          "373:   if (pat->not)",
          "374:     mutt_buffer_addstr(buf, \"NOT \");",
          "376:   if (pat->child)",
          "378:     int clauses;",
          "380:     clauses = do_search(pat->child, 1);",
          "381:     if (clauses > 0)",
          "383:       const struct Pattern *clause = pat->child;",
          "385:       mutt_buffer_addch(buf, '(');",
          "387:       while (clauses)",
          "388:       {",
          "389:         if (do_search(clause, 0))",
          "390:         {",
          "391:           if (pat->op == MUTT_OR && clauses > 1)",
          "392:             mutt_buffer_addstr(buf, \"OR \");",
          "393:           clauses--;",
          "395:           if (imap_compile_search(ctx, clause, buf) < 0)",
          "396:             return -1;",
          "398:           if (clauses)",
          "399:             mutt_buffer_addch(buf, ' ');",
          "400:         }",
          "401:         clause = clause->next;",
          "402:       }",
          "404:       mutt_buffer_addch(buf, ')');",
          "405:     }",
          "407:   else",
          "409:     char term[STRING];",
          "410:     char *delim = NULL;",
          "412:     switch (pat->op)",
          "414:       case MUTT_HEADER:",
          "415:         mutt_buffer_addstr(buf, \"HEADER \");",
          "418:         delim = strchr(pat->p.str, ':');",
          "419:         if (!delim)",
          "420:         {",
          "421:           mutt_error(_(\"Header search without header name: %s\"), pat->p.str);",
          "422:           return -1;",
          "423:         }",
          "425:         imap_quote_string(term, sizeof(term), pat->p.str);",
          "426:         mutt_buffer_addstr(buf, term);",
          "427:         mutt_buffer_addch(buf, ' ');",
          "431:         delim++;",
          "432:         SKIPWS(delim);",
          "433:         imap_quote_string(term, sizeof(term), delim);",
          "434:         mutt_buffer_addstr(buf, term);",
          "435:         break;",
          "436:       case MUTT_BODY:",
          "437:         mutt_buffer_addstr(buf, \"BODY \");",
          "438:         imap_quote_string(term, sizeof(term), pat->p.str);",
          "439:         mutt_buffer_addstr(buf, term);",
          "440:         break;",
          "441:       case MUTT_WHOLE_MSG:",
          "442:         mutt_buffer_addstr(buf, \"TEXT \");",
          "443:         imap_quote_string(term, sizeof(term), pat->p.str);",
          "444:         mutt_buffer_addstr(buf, term);",
          "445:         break;",
          "446:       case MUTT_SERVERSEARCH:",
          "448:         struct ImapData *idata = ctx->data;",
          "449:         if (!mutt_bit_isset(idata->capabilities, X_GM_EXT1))",
          "451:           mutt_error(_(\"Server-side custom search not supported: %s\"), pat->p.str);",
          "452:           return -1;",
          "455:         mutt_buffer_addstr(buf, \"X-GM-RAW \");",
          "456:         imap_quote_string(term, sizeof(term), pat->p.str);",
          "457:         mutt_buffer_addstr(buf, term);",
          "458:         break;",
          "475: static size_t longest_common_prefix(char *dest, const char *src, size_t start, size_t dlen)",
          "477:   size_t pos = start;",
          "479:   while (pos < dlen && dest[pos] && dest[pos] == src[pos])",
          "480:     pos++;",
          "481:   dest[pos] = '\\0';",
          "483:   return pos;",
          "492: static int imap_complete_hosts(char *dest, size_t len)",
          "494:   struct Buffy *mailbox = NULL;",
          "495:   struct Connection *conn = NULL;",
          "496:   int rc = -1;",
          "497:   size_t matchlen;",
          "499:   matchlen = mutt_strlen(dest);",
          "500:   for (mailbox = Incoming; mailbox; mailbox = mailbox->next)",
          "502:     if (mutt_strncmp(dest, mailbox->path, matchlen) == 0)",
          "503:     {",
          "504:       if (rc)",
          "505:       {",
          "506:         strfcpy(dest, mailbox->path, len);",
          "507:         rc = 0;",
          "508:       }",
          "509:       else",
          "510:         longest_common_prefix(dest, mailbox->path, matchlen, len);",
          "511:     }",
          "514:   TAILQ_FOREACH(conn, mutt_socket_head(), entries)",
          "516:     struct Url url;",
          "517:     char urlstr[LONG_STRING];",
          "519:     if (conn->account.type != MUTT_ACCT_TYPE_IMAP)",
          "520:       continue;",
          "522:     mutt_account_tourl(&conn->account, &url);",
          "524:     url.user = NULL;",
          "525:     url.path = NULL;",
          "526:     url_tostring(&url, urlstr, sizeof(urlstr), 0);",
          "527:     if (mutt_strncmp(dest, urlstr, matchlen) == 0)",
          "528:     {",
          "529:       if (rc)",
          "530:       {",
          "531:         strfcpy(dest, urlstr, len);",
          "532:         rc = 0;",
          "533:       }",
          "534:       else",
          "535:         longest_common_prefix(dest, urlstr, matchlen, len);",
          "536:     }",
          "539:   return rc;",
          "547: int imap_access(const char *path)",
          "550:   struct ImapMbox mx;",
          "552:   char mailbox[LONG_STRING];",
          "553:   char mbox[LONG_STRING];",
          "556:   if (imap_parse_path(path, &mx))",
          "559:   idata = imap_conn_find(&mx.account, option(OPT_IMAP_PASSIVE) ? MUTT_IMAP_CONN_NONEW : 0);",
          "562:     FREE(&mx.mbox);",
          "563:     return -1;",
          "566:   imap_fix_path(idata, mx.mbox, mailbox, sizeof(mailbox));",
          "567:   if (!*mailbox)",
          "568:     strfcpy(mailbox, \"INBOX\", sizeof(mailbox));",
          "571:   if (mutt_strcmp(idata->mailbox, mx.mbox) == 0)",
          "573:     FREE(&mx.mbox);",
          "574:     return 0;",
          "575:   }",
          "576:   FREE(&mx.mbox);",
          "578:   if (imap_mboxcache_get(idata, mailbox, 0))",
          "580:     mutt_debug(3, \"imap_access: found %s in cache\\n\", mailbox);",
          "581:     return 0;",
          "584:   imap_munge_mbox_name(idata, mbox, sizeof(mbox), mailbox);",
          "586:   if (mutt_bit_isset(idata->capabilities, IMAP4REV1))",
          "587:     snprintf(buf, sizeof(buf), \"STATUS %s (UIDVALIDITY)\", mbox);",
          "588:   else if (mutt_bit_isset(idata->capabilities, STATUS))",
          "589:     snprintf(buf, sizeof(buf), \"STATUS %s (UID-VALIDITY)\", mbox);",
          "590:   else",
          "592:     mutt_debug(2, \"imap_access: STATUS not supported?\\n\");",
          "593:     return -1;",
          "596:   rc = imap_exec(idata, buf, IMAP_CMD_FAIL_OK);",
          "597:   if (rc < 0)",
          "599:     mutt_debug(1, \"imap_access: Can't check STATUS of %s\\n\", mbox);",
          "600:     return rc;",
          "603:   return 0;",
          "604: }",
          "606: int imap_create_mailbox(struct ImapData *idata, char *mailbox)",
          "607: {",
          "608:   char buf[LONG_STRING], mbox[LONG_STRING];",
          "610:   imap_munge_mbox_name(idata, mbox, sizeof(mbox), mailbox);",
          "611:   snprintf(buf, sizeof(buf), \"CREATE %s\", mbox);",
          "613:   if (imap_exec(idata, buf, 0) != 0)",
          "615:     mutt_error(_(\"CREATE failed: %s\"), imap_cmd_trailer(idata));",
          "616:     return -1;",
          "622: int imap_rename_mailbox(struct ImapData *idata, struct ImapMbox *mx, const char *newname)",
          "624:   char oldmbox[LONG_STRING];",
          "625:   char newmbox[LONG_STRING];",
          "628:   imap_munge_mbox_name(idata, oldmbox, sizeof(oldmbox), mx->mbox);",
          "629:   imap_munge_mbox_name(idata, newmbox, sizeof(newmbox), newname);",
          "631:   snprintf(buf, sizeof(buf), \"RENAME %s %s\", oldmbox, newmbox);",
          "633:   if (imap_exec(idata, buf, 0) != 0)",
          "639: int imap_delete_mailbox(struct Context *ctx, struct ImapMbox *mx)",
          "641:   char buf[LONG_STRING], mbox[LONG_STRING];",
          "642:   struct ImapData *idata = NULL;",
          "644:   if (!ctx || !ctx->data)",
          "646:     idata = imap_conn_find(&mx->account,",
          "647:                            option(OPT_IMAP_PASSIVE) ? MUTT_IMAP_CONN_NONEW : 0);",
          "648:     if (!idata)",
          "649:     {",
          "650:       FREE(&mx->mbox);",
          "651:       return -1;",
          "652:     }",
          "653:   }",
          "654:   else",
          "655:   {",
          "656:     idata = ctx->data;",
          "659:   imap_munge_mbox_name(idata, mbox, sizeof(mbox), mx->mbox);",
          "660:   snprintf(buf, sizeof(buf), \"DELETE %s\", mbox);",
          "662:   if (imap_exec(idata, buf, 0) != 0)",
          "673: void imap_logout_all(void)",
          "675:   struct ConnectionList *head = mutt_socket_head();",
          "676:   struct Connection *np, *tmp;",
          "677:   TAILQ_FOREACH_SAFE(np, head, entries, tmp)",
          "678:   {",
          "679:     if (np->account.type == MUTT_ACCT_TYPE_IMAP && np->fd >= 0)",
          "680:     {",
          "681:       TAILQ_REMOVE(head, np, entries);",
          "682:       mutt_message(_(\"Closing connection to %s...\"), np->account.host);",
          "683:       imap_logout((struct ImapData **) (void *) &np->data);",
          "684:       mutt_clear_error();",
          "685:       mutt_socket_free(np);",
          "686:     }",
          "687:   }",
          "696: int imap_read_literal(FILE *fp, struct ImapData *idata, long bytes, struct Progress *pbar)",
          "698:   char c;",
          "699:   bool r = false;",
          "701:   mutt_debug(2, \"imap_read_literal: reading %ld bytes\\n\", bytes);",
          "703:   for (long pos = 0; pos < bytes; pos++)",
          "705:     if (mutt_socket_readchar(idata->conn, &c) != 1)",
          "706:     {",
          "707:       mutt_debug(1, \"imap_read_literal: error during read, %ld bytes read\\n\", pos);",
          "708:       idata->status = IMAP_FATAL;",
          "710:       return -1;",
          "711:     }",
          "713:     if (r && c != '\\n')",
          "714:       fputc('\\r', fp);",
          "716:     if (c == '\\r')",
          "717:     {",
          "718:       r = true;",
          "719:       continue;",
          "720:     }",
          "721:     else",
          "722:       r = false;",
          "724:     fputc(c, fp);",
          "726:     if (pbar && !(pos % 1024))",
          "727:       mutt_progress_update(pbar, pos, -1);",
          "728: #ifdef DEBUG",
          "729:     if (debuglevel >= IMAP_LOG_LTRL)",
          "730:       fputc(c, debugfile);",
          "731: #endif",
          "734:   return 0;",
          "744: void imap_expunge_mailbox(struct ImapData *idata)",
          "746:   struct Header *h = NULL;",
          "747:   int cacheno;",
          "748:   short old_sort;",
          "750: #ifdef USE_HCACHE",
          "751:   idata->hcache = imap_hcache_open(idata, NULL);",
          "752: #endif",
          "754:   old_sort = Sort;",
          "755:   Sort = SORT_ORDER;",
          "756:   mutt_sort_headers(idata->ctx, 0);",
          "758:   for (int i = 0; i < idata->ctx->msgcount; i++)",
          "759:   {",
          "760:     h = idata->ctx->hdrs[i];",
          "762:     if (h->index == INT_MAX)",
          "764:       mutt_debug(2, \"Expunging message UID %d.\\n\", HEADER_DATA(h)->uid);",
          "766:       h->active = false;",
          "767:       idata->ctx->size -= h->content->length;",
          "769:       imap_cache_del(idata, h);",
          "770: #ifdef USE_HCACHE",
          "771:       imap_hcache_del(idata, HEADER_DATA(h)->uid);",
          "772: #endif",
          "775:       cacheno = HEADER_DATA(h)->uid % IMAP_CACHE_LEN;",
          "776:       if (idata->cache[cacheno].uid == HEADER_DATA(h)->uid &&",
          "777:           idata->cache[cacheno].path)",
          "779:         unlink(idata->cache[cacheno].path);",
          "780:         FREE(&idata->cache[cacheno].path);",
          "783:       int_hash_delete(idata->uid_hash, HEADER_DATA(h)->uid, h, NULL);",
          "785:       imap_free_header_data((struct ImapHeaderData **) &h->data);",
          "786:     }",
          "787:     else",
          "788:     {",
          "789:       h->index = i;",
          "806:       h->active = true;",
          "807:     }",
          "808:   }",
          "810: #ifdef USE_HCACHE",
          "811:   imap_hcache_close(idata);",
          "812: #endif",
          "816:   mx_update_tables(idata->ctx, false);",
          "817:   Sort = old_sort;",
          "818:   mutt_sort_headers(idata->ctx, 1);",
          "819: }",
          "827: struct ImapData *imap_conn_find(const struct Account *account, int flags)",
          "828: {",
          "829:   struct Connection *conn = NULL;",
          "830:   struct Account *creds = NULL;",
          "831:   struct ImapData *idata = NULL;",
          "832:   bool new = false;",
          "834:   while ((conn = mutt_conn_find(conn, account)))",
          "835:   {",
          "836:     if (!creds)",
          "837:       creds = &conn->account;",
          "838:     else",
          "839:       memcpy(&conn->account, creds, sizeof(struct Account));",
          "841:     idata = conn->data;",
          "842:     if (flags & MUTT_IMAP_CONN_NONEW)",
          "843:     {",
          "844:       if (!idata)",
          "845:       {",
          "847:         mutt_socket_free(conn);",
          "848:         return NULL;",
          "849:       }",
          "850:       else if (idata->state < IMAP_AUTHENTICATED)",
          "851:         continue;",
          "852:     }",
          "853:     if (flags & MUTT_IMAP_CONN_NOSELECT && idata && idata->state >= IMAP_SELECTED)",
          "854:       continue;",
          "855:     if (idata && idata->status == IMAP_FATAL)",
          "856:       continue;",
          "857:     break;",
          "858:   }",
          "859:   if (!conn)",
          "862:   if (!idata)",
          "863:   {",
          "865:     idata = imap_new_idata();",
          "866:     if (!idata)",
          "867:     {",
          "868:       mutt_socket_free(conn);",
          "869:       return NULL;",
          "870:     }",
          "872:     conn->data = idata;",
          "873:     idata->conn = conn;",
          "874:     new = true;",
          "875:   }",
          "877:   if (idata->state == IMAP_DISCONNECTED)",
          "878:     imap_open_connection(idata);",
          "879:   if (idata->state == IMAP_CONNECTED)",
          "880:   {",
          "881:     if (!imap_authenticate(idata))",
          "882:     {",
          "883:       idata->state = IMAP_AUTHENTICATED;",
          "884:       FREE(&idata->capstr);",
          "885:       new = true;",
          "886:       if (idata->conn->ssf)",
          "887:         mutt_debug(2, \"Communication encrypted at %d bits\\n\", idata->conn->ssf);",
          "888:     }",
          "889:     else",
          "890:       mutt_account_unsetpass(&idata->conn->account);",
          "891:   }",
          "892:   if (new && idata->state == IMAP_AUTHENTICATED)",
          "893:   {",
          "895:     imap_exec(idata, \"CAPABILITY\", IMAP_CMD_QUEUE);",
          "897:     if (mutt_bit_isset(idata->capabilities, ENABLE))",
          "898:       imap_exec(idata, \"ENABLE UTF8=ACCEPT\", IMAP_CMD_QUEUE);",
          "900:     idata->delim = '/';",
          "901:     imap_exec(idata, \"LIST \\\"\\\" \\\"\\\"\", IMAP_CMD_QUEUE);",
          "902:     if (option(OPT_IMAP_CHECK_SUBSCRIBED))",
          "903:       imap_exec(idata, \"LSUB \\\"\\\" \\\"*\\\"\", IMAP_CMD_QUEUE);",
          "905:     imap_exec(idata, NULL, IMAP_CMD_FAIL_OK);",
          "906:   }",
          "908:   return idata;",
          "909: }",
          "911: int imap_open_connection(struct ImapData *idata)",
          "912: {",
          "913:   char buf[LONG_STRING];",
          "915:   if (mutt_socket_open(idata->conn) < 0)",
          "916:     return -1;",
          "918:   idata->state = IMAP_CONNECTED;",
          "920:   if (imap_cmd_step(idata) != IMAP_CMD_OK)",
          "921:   {",
          "922:     imap_close_connection(idata);",
          "923:     return -1;",
          "924:   }",
          "926:   if (mutt_strncasecmp(\"* OK\", idata->buf, 4) == 0)",
          "927:   {",
          "928:     if ((mutt_strncasecmp(\"* OK [CAPABILITY\", idata->buf, 16) != 0) &&",
          "929:         imap_check_capabilities(idata))",
          "930:       goto bail;",
          "931: #ifdef USE_SSL",
          "933:     if (!idata->conn->ssf &&",
          "934:         (option(OPT_SSL_FORCE_TLS) || mutt_bit_isset(idata->capabilities, STARTTLS)))",
          "935:     {",
          "936:       int rc;",
          "938:       if (option(OPT_SSL_FORCE_TLS))",
          "939:         rc = MUTT_YES;",
          "940:       else if ((rc = query_quadoption(OPT_SSL_STARTTLS,",
          "941:                                       _(\"Secure connection with TLS?\"))) == MUTT_ABORT)",
          "942:         goto err_close_conn;",
          "943:       if (rc == MUTT_YES)",
          "944:       {",
          "945:         rc = imap_exec(idata, \"STARTTLS\", IMAP_CMD_FAIL_OK);",
          "946:         if (rc == -1)",
          "947:           goto bail;",
          "948:         if (rc != -2)",
          "949:         {",
          "950:           if (mutt_ssl_starttls(idata->conn))",
          "951:           {",
          "952:             mutt_error(_(\"Could not negotiate TLS connection\"));",
          "953:             mutt_sleep(1);",
          "954:             goto err_close_conn;",
          "955:           }",
          "956:           else",
          "957:           {",
          "959:             if (imap_exec(idata, \"CAPABILITY\", 0))",
          "960:               goto bail;",
          "961:           }",
          "962:         }",
          "963:       }",
          "964:     }",
          "966:     if (option(OPT_SSL_FORCE_TLS) && !idata->conn->ssf)",
          "967:     {",
          "968:       mutt_error(_(\"Encrypted connection unavailable\"));",
          "969:       mutt_sleep(1);",
          "970:       goto err_close_conn;",
          "971:     }",
          "972: #endif",
          "973:   }",
          "974:   else if (mutt_strncasecmp(\"* PREAUTH\", idata->buf, 9) == 0)",
          "975:   {",
          "976:     idata->state = IMAP_AUTHENTICATED;",
          "977:     if (imap_check_capabilities(idata) != 0)",
          "978:       goto bail;",
          "979:     FREE(&idata->capstr);",
          "980:   }",
          "981:   else",
          "982:   {",
          "983:     imap_error(\"imap_open_connection()\", buf);",
          "984:     goto bail;",
          "985:   }",
          "987:   return 0;",
          "989: #ifdef USE_SSL",
          "990: err_close_conn:",
          "991:   imap_close_connection(idata);",
          "992: #endif",
          "993: bail:",
          "994:   FREE(&idata->capstr);",
          "995:   return -1;",
          "996: }",
          "998: void imap_close_connection(struct ImapData *idata)",
          "999: {",
          "1000:   if (idata->state != IMAP_DISCONNECTED)",
          "1001:   {",
          "1002:     mutt_socket_close(idata->conn);",
          "1003:     idata->state = IMAP_DISCONNECTED;",
          "1004:   }",
          "1005:   idata->seqno = idata->nextcmd = idata->lastcmd = idata->status = false;",
          "1006:   memset(idata->cmds, 0, sizeof(struct ImapCommand) * idata->cmdslots);",
          "1007: }",
          "1012: void imap_logout(struct ImapData **idata)",
          "1013: {",
          "1016:   (*idata)->status = IMAP_BYE;",
          "1017:   imap_cmd_start(*idata, \"LOGOUT\");",
          "1018:   if (ImapPollTimeout <= 0 || mutt_socket_poll((*idata)->conn, ImapPollTimeout) != 0)",
          "1019:   {",
          "1020:     while (imap_cmd_step(*idata) == IMAP_CMD_CONTINUE)",
          "1021:       ;",
          "1022:   }",
          "1024:   mutt_socket_close((*idata)->conn);",
          "1025:   imap_free_idata(idata);",
          "1026: }",
          "1035: bool imap_has_flag(struct ListHead *flag_list, const char *flag)",
          "1036: {",
          "1037:   if (STAILQ_EMPTY(flag_list))",
          "1038:     return false;",
          "1040:   struct ListNode *np;",
          "1041:   STAILQ_FOREACH(np, flag_list, entries)",
          "1042:   {",
          "1043:     if (mutt_strncasecmp(np->data, flag, strlen(np->data)) == 0)",
          "1044:       return true;",
          "1046:     if (mutt_strncmp(np->data, \"\\\\*\", strlen(np->data)) == 0)",
          "1047:       return true;",
          "1048:   }",
          "1050:   return false;",
          "1051: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1113:   if (oldsort != Sort)",
          "1114:   {",
          "1115:     Sort = oldsort;",
          "1142: }",
          "",
          "[Removed Lines]",
          "1116:     FREE(&idata->ctx->hdrs);",
          "1117:     idata->ctx->hdrs = hdrs;",
          "1118:   }",
          "1120:   return rc;",
          "1121: }",
          "1128: static bool compare_flags_for_copy(struct Header *h)",
          "1129: {",
          "1130:   struct ImapHeaderData *hd = (struct ImapHeaderData *) h->data;",
          "1132:   if (h->read != hd->read)",
          "1133:     return true;",
          "1134:   if (h->old != hd->old)",
          "1135:     return true;",
          "1136:   if (h->flagged != hd->flagged)",
          "1137:     return true;",
          "1138:   if (h->replied != hd->replied)",
          "1139:     return true;",
          "1141:   return false;",
          "",
          "[Added Lines]",
          "1126:     FREE(&idata->ctx->hdrs);",
          "1127:     idata->ctx->hdrs = hdrs;",
          "1128:   }",
          "1130:   return rc;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1245:   return 0;",
          "1246: }",
          "1249: {",
          "1276: }",
          "1286: {",
          "1293:   {",
          "1296:   }",
          "1322:   {",
          "1337:     {",
          "1341:     }",
          "1357: }",
          "1378: {",
          "1379:   struct ImapData *idata = NULL;",
          "1398:     {",
          "1401:     }",
          "1413:     {",
          "1416:     }",
          "1426:     {",
          "1429:     }",
          "1438:     {",
          "1442:     }",
          "1445:   }",
          "1453: }",
          "1463: {",
          "1476:     return -1;",
          "1489:   {",
          "1507:   }",
          "1515:   {",
          "1550: #ifdef USE_HCACHE",
          "1552: #endif",
          "1557:   {",
          "1564:   }",
          "1577:   {",
          "1581:   }",
          "1589:   {",
          "1591:     {",
          "1593:       {",
          "1631:     }",
          "1639:   }",
          "1648:   {",
          "1651:   }",
          "1653: }",
          "1659: {",
          "1665:     return 0;",
          "1676:   {",
          "1706:   }",
          "1710:   {",
          "1714:   }",
          "1716:   return 0;",
          "1717: }",
          "1734: {",
          "1742:   {",
          "1745:   }",
          "1747:   {",
          "1761:   }",
          "1793: }",
          "1799: {",
          "1800:   struct ImapMbox mx;",
          "1803:   {",
          "1805:     return -1;",
          "1806:   }",
          "1809:   {",
          "1812:   }",
          "1840:   {",
          "1843:     {",
          "1846:     }",
          "1852:     {",
          "1855:     }",
          "1862:     {",
          "1865:     }",
          "1869:     {",
          "1872:     }",
          "1903:   {",
          "1906:   }",
          "1946:   {",
          "1950:   }",
          "1951:   else",
          "1957:   {",
          "1961:   }",
          "1988:   {",
          "1993:   }",
          "1998:   {",
          "2004:   }",
          "2009:   {",
          "2013:     {",
          "2015:       {",
          "2020:       }",
          "2025:     }",
          "2029:   }",
          "2030: #endif",
          "2033: }",
          "2036: {",
          "2041:   {",
          "2044:   }",
          "2083: }",
          "2094: {",
          "2102:   {",
          "2107:     {",
          "2130:     }",
          "2172:       {",
          "2179:       }",
          "2184:     }",
          "2185:   }",
          "2187:   return 0;",
          "2188: }",
          "2191: {",
          "2208:   {",
          "2210:     return -1;",
          "2211:   }",
          "2214:   return 0;",
          "2215: }",
          "2218: {",
          "2219:   struct ImapData *idata = NULL;",
          "2227:   {",
          "2229:     return -1;",
          "2230:   }",
          "2240:   {",
          "2311:   {",
          "2313:     {",
          "2315:       {",
          "2317:         rc = 0;",
          "2318:       }",
          "2321:     }",
          "2322:   }",
          "2325:   {",
          "2338:     {",
          "2346:     }",
          "2347:   }",
          "2349:   return rc;",
          "2350: }",
          "2359: {",
          "2385:   }",
          "2405:   {",
          "2410:     {",
          "2430:     }",
          "2442:   }",
          "2445: }",
          "2454: {",
          "2455:   struct ImapData *idata = NULL;",
          "2465:   idata = ctx->data;",
          "2487:   {",
          "2490:     {",
          "2497:     }",
          "2505:     {",
          "2509:     }",
          "2511:     {",
          "2514:     }",
          "2521:     {",
          "2540:     }",
          "2547:   }",
          "2556: }",
          "2558: struct MxOps mx_imap_ops = {",
          "",
          "[Removed Lines]",
          "1248: static int sync_helper(struct ImapData *idata, int right, int flag, const char *name)",
          "1250:   int count = 0;",
          "1251:   int rc;",
          "1252:   char buf[LONG_STRING];",
          "1254:   if (!idata->ctx)",
          "1255:     return -1;",
          "1257:   if (!mutt_bit_isset(idata->ctx->rights, right))",
          "1258:     return 0;",
          "1260:   if (right == MUTT_ACL_WRITE && !imap_has_flag(&idata->flags, name))",
          "1261:     return 0;",
          "1263:   snprintf(buf, sizeof(buf), \"+FLAGS.SILENT (%s)\", name);",
          "1264:   rc = imap_exec_msgset(idata, \"UID STORE\", buf, flag, 1, 0);",
          "1265:   if (rc < 0)",
          "1266:     return rc;",
          "1267:   count += rc;",
          "1269:   buf[0] = '-';",
          "1270:   rc = imap_exec_msgset(idata, \"UID STORE\", buf, flag, 1, 1);",
          "1271:   if (rc < 0)",
          "1272:     return rc;",
          "1273:   count += rc;",
          "1275:   return count;",
          "1285: static int imap_edit_message_tags(struct Context *ctx, const char *tags, char *buf, size_t buflen)",
          "1287:   char *new = NULL;",
          "1288:   char *checker = NULL;",
          "1289:   struct ImapData *idata = (struct ImapData *) ctx->data;",
          "1292:   if (!imap_has_flag(&idata->flags, NULL))",
          "1294:     mutt_error(_(\"IMAP server doesn't support custom flags\"));",
          "1295:     return -1;",
          "1299:   if (tags)",
          "1300:     strncpy(buf, tags, buflen);",
          "1302:   if (mutt_get_field(\"Tags: \", buf, buflen, 0) != 0)",
          "1303:     return -1;",
          "1318:   new = buf;",
          "1319:   checker = buf;",
          "1320:   SKIPWS(checker);",
          "1321:   while (*checker != '\\0')",
          "1323:     if (*checker < 32 || *checker >= 127 || // We allow space because it's the separator",
          "1338:       mutt_error(_(\"Invalid IMAP flags\"));",
          "1339:       mutt_sleep(2);",
          "1340:       return 0;",
          "1344:     while (*checker == ' ' && *(checker + 1) == ' ')",
          "1345:       checker++;",
          "1349:   }",
          "1352:   mutt_remove_trailing_ws(new);",
          "1354:   if (mutt_strcmp(tags, buf) == 0)",
          "1355:     return 0;",
          "1356:   return 1;",
          "1377: static int imap_commit_message_tags(struct Context *ctx, struct Header *h, char *tags)",
          "1380:   struct Buffer *cmd = NULL;",
          "1381:   char uid[11];",
          "1383:   idata = ctx->data;",
          "1385:   if (*tags == '\\0')",
          "1386:     tags = NULL;",
          "1388:   if (!mutt_bit_isset(idata->ctx->rights, MUTT_ACL_WRITE))",
          "1389:     return 0;",
          "1391:   snprintf(uid, sizeof(uid), \"%u\", HEADER_DATA(h)->uid);",
          "1394:   if (HEADER_DATA(h)->flags_remote)",
          "1395:   {",
          "1396:     cmd = mutt_buffer_new();",
          "1397:     if (!cmd)",
          "1399:       mutt_debug(1, \"imap_commit_message_tags: unable to allocate buffer\\n\");",
          "1400:       return -1;",
          "1402:     cmd->dptr = cmd->data;",
          "1403:     mutt_buffer_addstr(cmd, \"UID STORE \");",
          "1404:     mutt_buffer_addstr(cmd, uid);",
          "1405:     mutt_buffer_addstr(cmd, \" -FLAGS.SILENT (\");",
          "1406:     mutt_buffer_addstr(cmd, HEADER_DATA(h)->flags_remote);",
          "1407:     mutt_buffer_addstr(cmd, \")\");",
          "1412:     if (imap_exec(idata, cmd->data, 0) != 0)",
          "1414:       mutt_buffer_free(&cmd);",
          "1415:       return -1;",
          "1418:     mutt_buffer_free(&cmd);",
          "1419:   }",
          "1422:   if (tags)",
          "1423:   {",
          "1424:     cmd = mutt_buffer_new();",
          "1425:     if (!cmd)",
          "1427:       mutt_debug(1, \"imap_commit_message_tags: fail to remove old flags\\n\");",
          "1428:       return -1;",
          "1430:     cmd->dptr = cmd->data;",
          "1431:     mutt_buffer_addstr(cmd, \"UID STORE \");",
          "1432:     mutt_buffer_addstr(cmd, uid);",
          "1433:     mutt_buffer_addstr(cmd, \" +FLAGS.SILENT (\");",
          "1434:     mutt_buffer_addstr(cmd, tags);",
          "1435:     mutt_buffer_addstr(cmd, \")\");",
          "1437:     if (imap_exec(idata, cmd->data, 0) != 0)",
          "1439:       mutt_debug(1, \"imap_commit_message_tags: fail to add new flags\\n\");",
          "1440:       mutt_buffer_free(&cmd);",
          "1441:       return -1;",
          "1444:     mutt_buffer_free(&cmd);",
          "1448:   mutt_debug(1, \"NEW TAGS: %d\\n\", tags);",
          "1449:   driver_tags_replace(&h->tags, tags);",
          "1450:   FREE(&HEADER_DATA(h)->flags_remote);",
          "1451:   HEADER_DATA(h)->flags_remote = driver_tags_get_with_hidden(&h->tags);",
          "1452:   return 0;",
          "1462: int imap_sync_mailbox(struct Context *ctx, int expunge)",
          "1464:   struct ImapData *idata = NULL;",
          "1465:   struct Context *appendctx = NULL;",
          "1466:   struct Header *h = NULL;",
          "1467:   struct Header **hdrs = NULL;",
          "1468:   int oldsort;",
          "1469:   int rc;",
          "1471:   idata = ctx->data;",
          "1473:   if (idata->state < IMAP_SELECTED)",
          "1474:   {",
          "1475:     mutt_debug(2, \"imap_sync_mailbox: no mailbox selected\\n\");",
          "1477:   }",
          "1481:   imap_allow_reopen(ctx);",
          "1483:   rc = imap_check(idata, 0);",
          "1484:   if (rc != 0)",
          "1485:     return rc;",
          "1488:   if (expunge && mutt_bit_isset(ctx->rights, MUTT_ACL_DELETE))",
          "1490:     if ((rc = imap_exec_msgset(idata, \"UID STORE\", \"+FLAGS.SILENT (\\\\Deleted)\",",
          "1491:                                MUTT_DELETED, 1, 0)) < 0)",
          "1492:     {",
          "1493:       mutt_error(_(\"Expunge failed\"));",
          "1494:       mutt_sleep(1);",
          "1495:       goto out;",
          "1496:     }",
          "1498:     if (rc > 0)",
          "1499:     {",
          "1502:       for (int i = 0; i < ctx->msgcount; i++)",
          "1503:         if (ctx->hdrs[i]->deleted && ctx->hdrs[i]->changed)",
          "1504:           ctx->hdrs[i]->active = false;",
          "1505:       mutt_message(_(\"Marking %d messages deleted...\"), rc);",
          "1506:     }",
          "1509: #ifdef USE_HCACHE",
          "1510:   idata->hcache = imap_hcache_open(idata, NULL);",
          "1511: #endif",
          "1514:   for (int i = 0; i < ctx->msgcount; i++)",
          "1516:     h = ctx->hdrs[i];",
          "1518:     if (h->deleted)",
          "1519:     {",
          "1520:       imap_cache_del(idata, h);",
          "1521: #ifdef USE_HCACHE",
          "1522:       imap_hcache_del(idata, HEADER_DATA(h)->uid);",
          "1523: #endif",
          "1524:     }",
          "1526:     if (h->active && h->changed)",
          "1527:     {",
          "1528: #ifdef USE_HCACHE",
          "1529:       imap_hcache_put(idata, h);",
          "1530: #endif",
          "1534:       if ((h->env && (h->env->refs_changed || h->env->irt_changed)) ||",
          "1535:           h->attach_del || h->xlabel_changed)",
          "1536:       {",
          "1537:         mutt_message(_(\"Saving changed messages... [%d/%d]\"), i + 1, ctx->msgcount);",
          "1538:         if (!appendctx)",
          "1539:           appendctx = mx_open_mailbox(ctx->path, MUTT_APPEND | MUTT_QUIET, NULL);",
          "1540:         if (!appendctx)",
          "1541:           mutt_debug(",
          "1542:               1, \"imap_sync_mailbox: Error opening mailbox in append mode\\n\");",
          "1543:         else",
          "1544:           _mutt_save_message(h, appendctx, 1, 0, 0);",
          "1545:         h->xlabel_changed = false;",
          "1546:       }",
          "1547:     }",
          "1548:   }",
          "1551:   imap_hcache_close(idata);",
          "1555:   oldsort = Sort;",
          "1556:   if (Sort != SORT_ORDER)",
          "1558:     hdrs = ctx->hdrs;",
          "1559:     ctx->hdrs = safe_malloc(ctx->msgcount * sizeof(struct Header *));",
          "1560:     memcpy(ctx->hdrs, hdrs, ctx->msgcount * sizeof(struct Header *));",
          "1562:     Sort = SORT_ORDER;",
          "1563:     qsort(ctx->hdrs, ctx->msgcount, sizeof(struct Header *), mutt_get_sort_func(SORT_ORDER));",
          "1566:   rc = sync_helper(idata, MUTT_ACL_DELETE, MUTT_DELETED, \"\\\\Deleted\");",
          "1567:   if (rc >= 0)",
          "1568:     rc |= sync_helper(idata, MUTT_ACL_WRITE, MUTT_FLAG, \"\\\\Flagged\");",
          "1569:   if (rc >= 0)",
          "1570:     rc |= sync_helper(idata, MUTT_ACL_WRITE, MUTT_OLD, \"Old\");",
          "1571:   if (rc >= 0)",
          "1572:     rc |= sync_helper(idata, MUTT_ACL_SEEN, MUTT_READ, \"\\\\Seen\");",
          "1573:   if (rc >= 0)",
          "1574:     rc |= sync_helper(idata, MUTT_ACL_WRITE, MUTT_REPLIED, \"\\\\Answered\");",
          "1576:   if (oldsort != Sort)",
          "1578:     Sort = oldsort;",
          "1579:     FREE(&ctx->hdrs);",
          "1580:     ctx->hdrs = hdrs;",
          "1584:   if (rc > 0)",
          "1585:     if (imap_exec(idata, NULL, 0) != IMAP_CMD_OK)",
          "1586:       rc = -1;",
          "1588:   if (rc < 0)",
          "1590:     if (ctx->closing)",
          "1592:       if (mutt_yesorno(_(\"Error saving flags. Close anyway?\"), 0) == MUTT_YES)",
          "1594:         rc = 0;",
          "1595:         idata->state = IMAP_AUTHENTICATED;",
          "1596:         goto out;",
          "1597:       }",
          "1598:     }",
          "1599:     else",
          "1600:       mutt_error(_(\"Error saving flags\"));",
          "1601:     rc = -1;",
          "1602:     goto out;",
          "1603:   }",
          "1608:   for (int i = 0; i < ctx->msgcount; i++)",
          "1609:   {",
          "1610:     HEADER_DATA(ctx->hdrs[i])->deleted = ctx->hdrs[i]->deleted;",
          "1611:     HEADER_DATA(ctx->hdrs[i])->flagged = ctx->hdrs[i]->flagged;",
          "1612:     HEADER_DATA(ctx->hdrs[i])->old = ctx->hdrs[i]->old;",
          "1613:     HEADER_DATA(ctx->hdrs[i])->read = ctx->hdrs[i]->read;",
          "1614:     HEADER_DATA(ctx->hdrs[i])->replied = ctx->hdrs[i]->replied;",
          "1615:     ctx->hdrs[i]->changed = false;",
          "1616:   }",
          "1617:   ctx->changed = false;",
          "1620:   if (expunge && !(ctx->closing) && mutt_bit_isset(ctx->rights, MUTT_ACL_DELETE))",
          "1621:   {",
          "1622:     mutt_message(_(\"Expunging messages from server...\"));",
          "1624:     idata->reopen |= IMAP_EXPUNGE_EXPECTED;",
          "1625:     if (imap_exec(idata, \"EXPUNGE\", 0) != 0)",
          "1626:     {",
          "1627:       idata->reopen &= ~IMAP_EXPUNGE_EXPECTED;",
          "1628:       imap_error(_(\"imap_sync_mailbox: EXPUNGE failed\"), idata->buf);",
          "1629:       rc = -1;",
          "1630:       goto out;",
          "1632:     idata->reopen &= ~IMAP_EXPUNGE_EXPECTED;",
          "1633:   }",
          "1635:   if (expunge && ctx->closing)",
          "1636:   {",
          "1637:     imap_exec(idata, \"CLOSE\", IMAP_CMD_QUEUE);",
          "1638:     idata->state = IMAP_AUTHENTICATED;",
          "1641:   if (option(OPT_MESSAGE_CACHE_CLEAN))",
          "1642:     imap_cache_clean(idata);",
          "1644:   rc = 0;",
          "1646: out:",
          "1647:   if (appendctx)",
          "1649:     mx_fastclose_mailbox(appendctx);",
          "1650:     FREE(&appendctx);",
          "1652:   return rc;",
          "1658: int imap_close_mailbox(struct Context *ctx)",
          "1660:   struct ImapData *idata = NULL;",
          "1662:   idata = ctx->data;",
          "1664:   if (!idata)",
          "1675:   if (ctx == idata->ctx)",
          "1677:     if (idata->status != IMAP_FATAL && idata->state >= IMAP_SELECTED)",
          "1678:     {",
          "1681:       if (!ctx->deleted)",
          "1682:         imap_exec(idata, \"CLOSE\", IMAP_CMD_QUEUE);",
          "1683:       idata->state = IMAP_AUTHENTICATED;",
          "1684:     }",
          "1686:     idata->reopen &= IMAP_REOPEN_ALLOW;",
          "1687:     FREE(&(idata->mailbox));",
          "1688:     mutt_list_free(&idata->flags);",
          "1689:     idata->ctx = NULL;",
          "1691:     hash_destroy(&idata->uid_hash, NULL);",
          "1692:     FREE(&idata->msn_index);",
          "1693:     idata->msn_index_size = 0;",
          "1694:     idata->max_msn = 0;",
          "1696:     for (int i = 0; i < IMAP_CACHE_LEN; i++)",
          "1697:     {",
          "1698:       if (idata->cache[i].path)",
          "1699:       {",
          "1700:         unlink(idata->cache[i].path);",
          "1701:         FREE(&idata->cache[i].path);",
          "1702:       }",
          "1703:     }",
          "1705:     mutt_bcache_close(&idata->bcache);",
          "1709:   for (int i = 0; i < ctx->msgcount; i++)",
          "1712:     if (ctx->hdrs[i] && ctx->hdrs[i]->data)",
          "1713:       imap_free_header_data((struct ImapHeaderData **) &(ctx->hdrs[i]->data));",
          "1728: int imap_check_mailbox(struct Context *ctx, int force)",
          "1729: {",
          "1730:   return imap_check(ctx->data, force);",
          "1731: }",
          "1733: int imap_check(struct ImapData *idata, int force)",
          "1737:   int result = 0;",
          "1740:   if (!force && option(OPT_IMAP_IDLE) && mutt_bit_isset(idata->capabilities, IDLE) &&",
          "1741:       (idata->state != IMAP_IDLE || time(NULL) >= idata->lastread + ImapKeepalive))",
          "1743:     if (imap_cmd_idle(idata) < 0)",
          "1744:       return -1;",
          "1746:   if (idata->state == IMAP_IDLE)",
          "1748:     while ((result = mutt_socket_poll(idata->conn, 0)) > 0)",
          "1749:     {",
          "1750:       if (imap_cmd_step(idata) != IMAP_CMD_CONTINUE)",
          "1751:       {",
          "1752:         mutt_debug(1, \"Error reading IDLE response\\n\");",
          "1753:         return -1;",
          "1754:       }",
          "1755:     }",
          "1756:     if (result < 0)",
          "1757:     {",
          "1758:       mutt_debug(1, \"Poll failed, disabling IDLE\\n\");",
          "1759:       mutt_bit_unset(idata->capabilities, IDLE);",
          "1760:     }",
          "1763:   if ((force || (idata->state != IMAP_IDLE && time(NULL) >= idata->lastread + Timeout)) &&",
          "1764:       imap_exec(idata, \"NOOP\", IMAP_CMD_POLL) != 0)",
          "1765:     return -1;",
          "1769:   imap_cmd_finish(idata);",
          "1771:   if (idata->check_status & IMAP_EXPUNGE_PENDING)",
          "1772:     result = MUTT_REOPENED;",
          "1773:   else if (idata->check_status & IMAP_NEWMAIL_PENDING)",
          "1774:     result = MUTT_NEW_MAIL;",
          "1775:   else if (idata->check_status & IMAP_FLAGS_PENDING)",
          "1776:     result = MUTT_FLAGS;",
          "1778:   idata->check_status = 0;",
          "1780:   return result;",
          "1781: }",
          "1783: static int imap_check_mailbox_reopen(struct Context *ctx, int *index_hint)",
          "1784: {",
          "1785:   int rc;",
          "1786:   (void) index_hint;",
          "1788:   imap_allow_reopen(ctx);",
          "1789:   rc = imap_check(ctx->data, 0);",
          "1790:   imap_disallow_reopen(ctx);",
          "1792:   return rc;",
          "1798: static int imap_get_mailbox(const char *path, struct ImapData **hidata, char *buf, size_t blen)",
          "1802:   if (imap_parse_path(path, &mx))",
          "1804:     mutt_debug(1, \"imap_get_mailbox: Error parsing %s\\n\", path);",
          "1807:   if (!(*hidata = imap_conn_find(&(mx.account), option(OPT_IMAP_PASSIVE) ? MUTT_IMAP_CONN_NONEW : 0)) ||",
          "1808:       (*hidata)->state < IMAP_AUTHENTICATED)",
          "1810:     FREE(&mx.mbox);",
          "1811:     return -1;",
          "1814:   imap_fix_path(*hidata, mx.mbox, buf, blen);",
          "1815:   if (!*buf)",
          "1816:     strfcpy(buf, \"INBOX\", blen);",
          "1817:   FREE(&mx.mbox);",
          "1819:   return 0;",
          "1820: }",
          "1829: int imap_buffy_check(int force, int check_stats)",
          "1830: {",
          "1831:   struct ImapData *idata = NULL;",
          "1832:   struct ImapData *lastdata = NULL;",
          "1833:   struct Buffy *mailbox = NULL;",
          "1834:   char name[LONG_STRING];",
          "1835:   char command[LONG_STRING];",
          "1836:   char munged[LONG_STRING];",
          "1837:   int buffies = 0;",
          "1839:   for (mailbox = Incoming; mailbox; mailbox = mailbox->next)",
          "1842:     if (!mailbox->magic)",
          "1844:       if (mx_is_imap(mailbox->path))",
          "1845:         mailbox->magic = MUTT_IMAP;",
          "1848:     if (mailbox->magic != MUTT_IMAP)",
          "1849:       continue;",
          "1851:     if (imap_get_mailbox(mailbox->path, &idata, name, sizeof(name)) < 0)",
          "1853:       mailbox->new = false;",
          "1854:       continue;",
          "1861:     if (idata->mailbox && (imap_mxcmp(name, idata->mailbox) == 0))",
          "1863:       mailbox->new = false;",
          "1864:       continue;",
          "1867:     if (!mutt_bit_isset(idata->capabilities, IMAP4REV1) &&",
          "1868:         !mutt_bit_isset(idata->capabilities, STATUS))",
          "1870:       mutt_debug(2, \"Server doesn't support STATUS\\n\");",
          "1871:       continue;",
          "1874:     if (lastdata && idata != lastdata)",
          "1875:     {",
          "1878:       if (imap_exec(lastdata, NULL, IMAP_CMD_FAIL_OK | IMAP_CMD_POLL) == -1)",
          "1879:         mutt_debug(1, \"Error polling mailboxes\\n\");",
          "1881:       lastdata = NULL;",
          "1882:     }",
          "1884:     if (!lastdata)",
          "1885:       lastdata = idata;",
          "1887:     imap_munge_mbox_name(idata, munged, sizeof(munged), name);",
          "1888:     if (check_stats)",
          "1889:       snprintf(command, sizeof(command),",
          "1890:                \"STATUS %s (UIDNEXT UIDVALIDITY UNSEEN RECENT MESSAGES)\", munged);",
          "1891:     else",
          "1892:       snprintf(command, sizeof(command),",
          "1893:                \"STATUS %s (UIDNEXT UIDVALIDITY UNSEEN RECENT)\", munged);",
          "1895:     if (imap_exec(idata, command, IMAP_CMD_QUEUE | IMAP_CMD_POLL) < 0)",
          "1896:     {",
          "1897:       mutt_debug(1, \"Error queueing command\\n\");",
          "1898:       return 0;",
          "1899:     }",
          "1900:   }",
          "1902:   if (lastdata && (imap_exec(lastdata, NULL, IMAP_CMD_FAIL_OK | IMAP_CMD_POLL) == -1))",
          "1904:     mutt_debug(1, \"Error polling mailboxes\\n\");",
          "1905:     return 0;",
          "1909:   for (mailbox = Incoming; mailbox; mailbox = mailbox->next)",
          "1910:   {",
          "1911:     if (mailbox->magic == MUTT_IMAP && mailbox->new)",
          "1912:       buffies++;",
          "1913:   }",
          "1915:   return buffies;",
          "1916: }",
          "1926: int imap_status(char *path, int queue)",
          "1927: {",
          "1928:   static int queued = 0;",
          "1930:   struct ImapData *idata = NULL;",
          "1931:   char buf[LONG_STRING];",
          "1932:   char mbox[LONG_STRING];",
          "1933:   struct ImapStatus *status = NULL;",
          "1935:   if (imap_get_mailbox(path, &idata, buf, sizeof(buf)) < 0)",
          "1936:     return -1;",
          "1942:   if (idata->ctx && !imap_mxcmp(buf, idata->mailbox))",
          "1943:     return idata->ctx->msgcount;",
          "1944:   else if (mutt_bit_isset(idata->capabilities, IMAP4REV1) ||",
          "1945:            mutt_bit_isset(idata->capabilities, STATUS))",
          "1947:     imap_munge_mbox_name(idata, mbox, sizeof(mbox), buf);",
          "1948:     snprintf(buf, sizeof(buf), \"STATUS %s (%s)\", mbox, \"MESSAGES\");",
          "1949:     imap_unmunge_mbox_name(idata, mbox);",
          "1954:     return -1;",
          "1956:   if (queue)",
          "1958:     imap_exec(idata, buf, IMAP_CMD_QUEUE);",
          "1959:     queued = 1;",
          "1960:     return 0;",
          "1962:   else if (!queued)",
          "1963:     imap_exec(idata, buf, 0);",
          "1965:   queued = 0;",
          "1966:   if ((status = imap_mboxcache_get(idata, mbox, 0)))",
          "1967:     return status->messages;",
          "1969:   return 0;",
          "1970: }",
          "1977: struct ImapStatus *imap_mboxcache_get(struct ImapData *idata, const char *mbox, int create)",
          "1978: {",
          "1979:   struct ImapStatus *status = NULL;",
          "1980: #ifdef USE_HCACHE",
          "1981:   header_cache_t *hc = NULL;",
          "1982:   void *uidvalidity = NULL;",
          "1983:   void *uidnext = NULL;",
          "1984: #endif",
          "1986:   struct ListNode *np;",
          "1987:   STAILQ_FOREACH(np, &idata->mboxcache, entries)",
          "1989:     status = (struct ImapStatus *) np->data;",
          "1991:     if (imap_mxcmp(mbox, status->name) == 0)",
          "1992:       return status;",
          "1994:   status = NULL;",
          "1997:   if (create)",
          "1999:     struct ImapStatus *scache = safe_calloc(1, sizeof(struct ImapStatus));",
          "2000:     scache->name = (char *) mbox;",
          "2001:     mutt_list_insert_tail(&idata->mboxcache, (char *) scache);",
          "2002:     status = imap_mboxcache_get(idata, mbox, 0);",
          "2003:     status->name = safe_strdup(mbox);",
          "2006: #ifdef USE_HCACHE",
          "2007:   hc = imap_hcache_open(idata, mbox);",
          "2008:   if (hc)",
          "2010:     uidvalidity = mutt_hcache_fetch_raw(hc, \"/UIDVALIDITY\", 12);",
          "2011:     uidnext = mutt_hcache_fetch_raw(hc, \"/UIDNEXT\", 8);",
          "2012:     if (uidvalidity)",
          "2014:       if (!status)",
          "2016:         mutt_hcache_free(hc, &uidvalidity);",
          "2017:         mutt_hcache_free(hc, &uidnext);",
          "2018:         mutt_hcache_close(hc);",
          "2019:         return imap_mboxcache_get(idata, mbox, 1);",
          "2021:       status->uidvalidity = *(unsigned int *) uidvalidity;",
          "2022:       status->uidnext = uidnext ? *(unsigned int *) uidnext : 0;",
          "2023:       mutt_debug(3, \"mboxcache: hcache uidvalidity %d, uidnext %d\\n\",",
          "2024:                  status->uidvalidity, status->uidnext);",
          "2026:     mutt_hcache_free(hc, &uidvalidity);",
          "2027:     mutt_hcache_free(hc, &uidnext);",
          "2028:     mutt_hcache_close(hc);",
          "2032:   return status;",
          "2035: void imap_mboxcache_free(struct ImapData *idata)",
          "2037:   struct ImapStatus *status = NULL;",
          "2039:   struct ListNode *np;",
          "2040:   STAILQ_FOREACH(np, &idata->mboxcache, entries)",
          "2042:     status = (struct ImapStatus *) np->data;",
          "2043:     FREE(&status->name);",
          "2046:   mutt_list_free(&idata->mboxcache);",
          "2047: }",
          "2055: static int do_search(const struct Pattern *search, int allpats)",
          "2056: {",
          "2057:   int rc = 0;",
          "2058:   const struct Pattern *pat = NULL;",
          "2060:   for (pat = search; pat; pat = pat->next)",
          "2061:   {",
          "2062:     switch (pat->op)",
          "2063:     {",
          "2064:       case MUTT_BODY:",
          "2065:       case MUTT_HEADER:",
          "2066:       case MUTT_WHOLE_MSG:",
          "2067:         if (pat->stringmatch)",
          "2068:           rc++;",
          "2069:         break;",
          "2070:       case MUTT_SERVERSEARCH:",
          "2071:         rc++;",
          "2072:         break;",
          "2073:       default:",
          "2074:         if (pat->child && do_search(pat->child, 1))",
          "2075:           rc++;",
          "2076:     }",
          "2078:     if (!allpats)",
          "2079:       break;",
          "2080:   }",
          "2082:   return rc;",
          "2092: static int imap_compile_search(struct Context *ctx, const struct Pattern *pat,",
          "2093:                                struct Buffer *buf)",
          "2095:   if (!do_search(pat, 0))",
          "2096:     return 0;",
          "2098:   if (pat->not)",
          "2099:     mutt_buffer_addstr(buf, \"NOT \");",
          "2101:   if (pat->child)",
          "2103:     int clauses;",
          "2105:     clauses = do_search(pat->child, 1);",
          "2106:     if (clauses > 0)",
          "2108:       const struct Pattern *clause = pat->child;",
          "2110:       mutt_buffer_addch(buf, '(');",
          "2112:       while (clauses)",
          "2113:       {",
          "2114:         if (do_search(clause, 0))",
          "2115:         {",
          "2116:           if (pat->op == MUTT_OR && clauses > 1)",
          "2117:             mutt_buffer_addstr(buf, \"OR \");",
          "2118:           clauses--;",
          "2120:           if (imap_compile_search(ctx, clause, buf) < 0)",
          "2121:             return -1;",
          "2123:           if (clauses)",
          "2124:             mutt_buffer_addch(buf, ' ');",
          "2125:         }",
          "2126:         clause = clause->next;",
          "2127:       }",
          "2129:       mutt_buffer_addch(buf, ')');",
          "2131:   }",
          "2132:   else",
          "2133:   {",
          "2134:     char term[STRING];",
          "2135:     char *delim = NULL;",
          "2137:     switch (pat->op)",
          "2138:     {",
          "2139:       case MUTT_HEADER:",
          "2140:         mutt_buffer_addstr(buf, \"HEADER \");",
          "2143:         delim = strchr(pat->p.str, ':');",
          "2144:         if (!delim)",
          "2145:         {",
          "2146:           mutt_error(_(\"Header search without header name: %s\"), pat->p.str);",
          "2147:           return -1;",
          "2148:         }",
          "2150:         imap_quote_string(term, sizeof(term), pat->p.str);",
          "2151:         mutt_buffer_addstr(buf, term);",
          "2152:         mutt_buffer_addch(buf, ' ');",
          "2156:         delim++;",
          "2157:         SKIPWS(delim);",
          "2158:         imap_quote_string(term, sizeof(term), delim);",
          "2159:         mutt_buffer_addstr(buf, term);",
          "2160:         break;",
          "2161:       case MUTT_BODY:",
          "2162:         mutt_buffer_addstr(buf, \"BODY \");",
          "2163:         imap_quote_string(term, sizeof(term), pat->p.str);",
          "2164:         mutt_buffer_addstr(buf, term);",
          "2165:         break;",
          "2166:       case MUTT_WHOLE_MSG:",
          "2167:         mutt_buffer_addstr(buf, \"TEXT \");",
          "2168:         imap_quote_string(term, sizeof(term), pat->p.str);",
          "2169:         mutt_buffer_addstr(buf, term);",
          "2170:         break;",
          "2171:       case MUTT_SERVERSEARCH:",
          "2173:         struct ImapData *idata = ctx->data;",
          "2174:         if (!mutt_bit_isset(idata->capabilities, X_GM_EXT1))",
          "2175:         {",
          "2176:           mutt_error(_(\"Server-side custom search not supported: %s\"), pat->p.str);",
          "2177:           return -1;",
          "2178:         }",
          "2180:         mutt_buffer_addstr(buf, \"X-GM-RAW \");",
          "2181:         imap_quote_string(term, sizeof(term), pat->p.str);",
          "2182:         mutt_buffer_addstr(buf, term);",
          "2183:         break;",
          "2190: int imap_search(struct Context *ctx, const struct Pattern *pat)",
          "2192:   struct Buffer buf;",
          "2193:   struct ImapData *idata = ctx->data;",
          "2194:   for (int i = 0; i < ctx->msgcount; i++)",
          "2195:     ctx->hdrs[i]->matched = false;",
          "2197:   if (!do_search(pat, 1))",
          "2198:     return 0;",
          "2200:   mutt_buffer_init(&buf);",
          "2201:   mutt_buffer_addstr(&buf, \"UID SEARCH \");",
          "2202:   if (imap_compile_search(ctx, pat, &buf) < 0)",
          "2203:   {",
          "2204:     FREE(&buf.data);",
          "2205:     return -1;",
          "2206:   }",
          "2207:   if (imap_exec(idata, buf.data, 0) < 0)",
          "2209:     FREE(&buf.data);",
          "2213:   FREE(&buf.data);",
          "2217: int imap_subscribe(char *path, int subscribe)",
          "2220:   char buf[LONG_STRING];",
          "2221:   char mbox[LONG_STRING];",
          "2222:   char errstr[STRING];",
          "2223:   struct Buffer err, token;",
          "2224:   struct ImapMbox mx;",
          "2226:   if (!mx_is_imap(path) || imap_parse_path(path, &mx) || !mx.mbox)",
          "2228:     mutt_error(_(\"Bad mailbox name\"));",
          "2231:   idata = imap_conn_find(&(mx.account), 0);",
          "2232:   if (!idata)",
          "2233:     goto fail;",
          "2235:   imap_fix_path(idata, mx.mbox, buf, sizeof(buf));",
          "2236:   if (!*buf)",
          "2237:     strfcpy(buf, \"INBOX\", sizeof(buf));",
          "2239:   if (option(OPT_IMAP_CHECK_SUBSCRIBED))",
          "2241:     mutt_buffer_init(&token);",
          "2242:     mutt_buffer_init(&err);",
          "2243:     err.data = errstr;",
          "2244:     err.dsize = sizeof(errstr);",
          "2245:     snprintf(mbox, sizeof(mbox), \"%smailboxes \\\"%s\\\"\", subscribe ? \"\" : \"un\", path);",
          "2246:     if (mutt_parse_rc_line(mbox, &token, &err))",
          "2247:       mutt_debug(1, \"Error adding subscribed mailbox: %s\\n\", errstr);",
          "2248:     FREE(&token.data);",
          "2249:   }",
          "2251:   if (subscribe)",
          "2252:     mutt_message(_(\"Subscribing to %s...\"), buf);",
          "2253:   else",
          "2254:     mutt_message(_(\"Unsubscribing from %s...\"), buf);",
          "2255:   imap_munge_mbox_name(idata, mbox, sizeof(mbox), buf);",
          "2257:   snprintf(buf, sizeof(buf), \"%sSUBSCRIBE %s\", subscribe ? \"\" : \"UN\", mbox);",
          "2259:   if (imap_exec(idata, buf, 0) < 0)",
          "2260:     goto fail;",
          "2262:   imap_unmunge_mbox_name(idata, mx.mbox);",
          "2263:   if (subscribe)",
          "2264:     mutt_message(_(\"Subscribed to %s\"), mx.mbox);",
          "2265:   else",
          "2266:     mutt_message(_(\"Unsubscribed from %s\"), mx.mbox);",
          "2267:   FREE(&mx.mbox);",
          "2268:   return 0;",
          "2270: fail:",
          "2271:   FREE(&mx.mbox);",
          "2272:   return -1;",
          "2273: }",
          "2285: static size_t longest_common_prefix(char *dest, const char *src, size_t start, size_t dlen)",
          "2286: {",
          "2287:   size_t pos = start;",
          "2289:   while (pos < dlen && dest[pos] && dest[pos] == src[pos])",
          "2290:     pos++;",
          "2291:   dest[pos] = '\\0';",
          "2293:   return pos;",
          "2294: }",
          "2302: static int imap_complete_hosts(char *dest, size_t len)",
          "2303: {",
          "2304:   struct Buffy *mailbox = NULL;",
          "2305:   struct Connection *conn = NULL;",
          "2306:   int rc = -1;",
          "2307:   size_t matchlen;",
          "2309:   matchlen = mutt_strlen(dest);",
          "2310:   for (mailbox = Incoming; mailbox; mailbox = mailbox->next)",
          "2312:     if (mutt_strncmp(dest, mailbox->path, matchlen) == 0)",
          "2314:       if (rc)",
          "2316:         strfcpy(dest, mailbox->path, len);",
          "2319:       else",
          "2320:         longest_common_prefix(dest, mailbox->path, matchlen, len);",
          "2324:   TAILQ_FOREACH(conn, mutt_socket_head(), entries)",
          "2326:     struct Url url;",
          "2327:     char urlstr[LONG_STRING];",
          "2329:     if (conn->account.type != MUTT_ACCT_TYPE_IMAP)",
          "2330:       continue;",
          "2332:     mutt_account_tourl(&conn->account, &url);",
          "2334:     url.user = NULL;",
          "2335:     url.path = NULL;",
          "2336:     url_tostring(&url, urlstr, sizeof(urlstr), 0);",
          "2337:     if (mutt_strncmp(dest, urlstr, matchlen) == 0)",
          "2339:       if (rc)",
          "2340:       {",
          "2341:         strfcpy(dest, urlstr, len);",
          "2342:         rc = 0;",
          "2343:       }",
          "2344:       else",
          "2345:         longest_common_prefix(dest, urlstr, matchlen, len);",
          "2358: int imap_complete(char *dest, size_t dlen, char *path)",
          "2360:   struct ImapData *idata = NULL;",
          "2361:   char list[LONG_STRING];",
          "2362:   char buf[LONG_STRING];",
          "2363:   struct ImapList listresp;",
          "2364:   char completion[LONG_STRING];",
          "2365:   int clen;",
          "2366:   size_t matchlen = 0;",
          "2367:   int completions = 0;",
          "2368:   struct ImapMbox mx;",
          "2369:   int rc;",
          "2371:   if (imap_parse_path(path, &mx))",
          "2372:   {",
          "2373:     strfcpy(dest, path, dlen);",
          "2374:     return imap_complete_hosts(dest, dlen);",
          "2375:   }",
          "2379:   idata = imap_conn_find(&(mx.account), MUTT_IMAP_CONN_NONEW);",
          "2380:   if (!idata)",
          "2381:   {",
          "2382:     FREE(&mx.mbox);",
          "2383:     strfcpy(dest, path, dlen);",
          "2384:     return imap_complete_hosts(dest, dlen);",
          "2389:   if (mx.mbox && mx.mbox[0])",
          "2390:     imap_fix_path(idata, mx.mbox, list, sizeof(list));",
          "2391:   else",
          "2392:     list[0] = '\\0';",
          "2395:   snprintf(buf, sizeof(buf), \"%s \\\"\\\" \\\"%s%%\\\"\",",
          "2396:            option(OPT_IMAP_LIST_SUBSCRIBED) ? \"LSUB\" : \"LIST\", list);",
          "2398:   imap_cmd_start(idata, buf);",
          "2401:   strfcpy(completion, NONULL(mx.mbox), sizeof(completion));",
          "2402:   idata->cmdtype = IMAP_CT_LIST;",
          "2403:   idata->cmddata = &listresp;",
          "2404:   do",
          "2406:     listresp.name = NULL;",
          "2407:     rc = imap_cmd_step(idata);",
          "2409:     if (rc == IMAP_CMD_CONTINUE && listresp.name)",
          "2413:       if (listresp.noselect)",
          "2414:       {",
          "2415:         clen = strlen(listresp.name);",
          "2416:         listresp.name[clen++] = listresp.delim;",
          "2417:         listresp.name[clen] = '\\0';",
          "2418:       }",
          "2420:       if (!completions)",
          "2421:       {",
          "2422:         strfcpy(completion, listresp.name, sizeof(completion));",
          "2423:         matchlen = strlen(completion);",
          "2424:         completions++;",
          "2425:         continue;",
          "2426:       }",
          "2428:       matchlen = longest_common_prefix(completion, listresp.name, 0, matchlen);",
          "2429:       completions++;",
          "2431:   } while (rc == IMAP_CMD_CONTINUE);",
          "2432:   idata->cmddata = NULL;",
          "2434:   if (completions)",
          "2435:   {",
          "2437:     imap_qualify_path(dest, dlen, &mx, completion);",
          "2438:     mutt_pretty_mailbox(dest, dlen);",
          "2440:     FREE(&mx.mbox);",
          "2441:     return 0;",
          "2444:   return -1;",
          "2453: int imap_fast_trash(struct Context *ctx, char *dest)",
          "2456:   char mbox[LONG_STRING];",
          "2457:   char mmbox[LONG_STRING];",
          "2458:   char prompt[LONG_STRING];",
          "2459:   int rc;",
          "2460:   struct ImapMbox mx;",
          "2461:   bool triedcreate = false;",
          "2462:   struct Buffer *sync_cmd = NULL;",
          "2463:   int err_continue = MUTT_NO;",
          "2467:   if (imap_parse_path(dest, &mx))",
          "2468:   {",
          "2469:     mutt_debug(1, \"imap_fast_trash: bad destination %s\\n\", dest);",
          "2470:     return -1;",
          "2471:   }",
          "2474:   if (!mutt_account_match(&(idata->conn->account), &(mx.account)))",
          "2475:   {",
          "2476:     mutt_debug(3, \"imap_fast_trash: %s not same server as %s\\n\", dest, ctx->path);",
          "2477:     return 1;",
          "2478:   }",
          "2480:   imap_fix_path(idata, mx.mbox, mbox, sizeof(mbox));",
          "2481:   if (!*mbox)",
          "2482:     strfcpy(mbox, \"INBOX\", sizeof(mbox));",
          "2483:   imap_munge_mbox_name(idata, mmbox, sizeof(mmbox), mbox);",
          "2485:   sync_cmd = mutt_buffer_new();",
          "2486:   for (int i = 0; i < ctx->msgcount; i++)",
          "2488:     if (ctx->hdrs[i]->active && ctx->hdrs[i]->changed &&",
          "2489:         ctx->hdrs[i]->deleted && !ctx->hdrs[i]->purge)",
          "2491:       rc = imap_sync_message_for_copy(idata, ctx->hdrs[i], sync_cmd, &err_continue);",
          "2492:       if (rc < 0)",
          "2493:       {",
          "2494:         mutt_debug(1, \"imap_fast_trash: could not sync\\n\");",
          "2495:         goto out;",
          "2496:       }",
          "2498:   }",
          "2501:   do",
          "2502:   {",
          "2503:     rc = imap_exec_msgset(idata, \"UID COPY\", mmbox, MUTT_TRASH, 0, 0);",
          "2504:     if (!rc)",
          "2506:       mutt_debug(1, \"imap_fast_trash: No messages to trash\\n\");",
          "2507:       rc = -1;",
          "2508:       goto out;",
          "2510:     else if (rc < 0)",
          "2512:       mutt_debug(1, \"could not queue copy\\n\");",
          "2513:       goto out;",
          "2515:     else",
          "2516:       mutt_message(_(\"Copying %d messages to %s...\"), rc, mbox);",
          "2519:     rc = imap_exec(idata, NULL, IMAP_CMD_FAIL_OK);",
          "2520:     if (rc == -2)",
          "2522:       if (triedcreate)",
          "2523:       {",
          "2524:         mutt_debug(1, \"Already tried to create mailbox %s\\n\", mbox);",
          "2525:         break;",
          "2526:       }",
          "2528:       if (mutt_strncasecmp(imap_get_qualifier(idata->buf), \"[TRYCREATE]\", 11) != 0)",
          "2529:         break;",
          "2530:       mutt_debug(3, \"imap_fast_trash: server suggests TRYCREATE\\n\");",
          "2531:       snprintf(prompt, sizeof(prompt), _(\"Create %s?\"), mbox);",
          "2532:       if (option(OPT_CONFIRMCREATE) && mutt_yesorno(prompt, 1) != MUTT_YES)",
          "2533:       {",
          "2534:         mutt_clear_error();",
          "2535:         goto out;",
          "2536:       }",
          "2537:       if (imap_create_mailbox(idata, mbox) < 0)",
          "2538:         break;",
          "2539:       triedcreate = true;",
          "2541:   } while (rc == -2);",
          "2543:   if (rc != 0)",
          "2544:   {",
          "2545:     imap_error(\"imap_fast_trash\", idata->buf);",
          "2546:     goto out;",
          "2549:   rc = 0;",
          "2551: out:",
          "2552:   mutt_buffer_free(&sync_cmd);",
          "2553:   FREE(&mx.mbox);",
          "2555:   return rc < 0 ? -1 : rc;",
          "",
          "[Added Lines]",
          "1246: int imap_check_mailbox(struct Context *ctx, int force)",
          "1248:   return imap_check(ctx->data, force);",
          "1251: int imap_check(struct ImapData *idata, int force)",
          "1255:   int result = 0;",
          "1258:   if (!force && option(OPT_IMAP_IDLE) && mutt_bit_isset(idata->capabilities, IDLE) &&",
          "1259:       (idata->state != IMAP_IDLE || time(NULL) >= idata->lastread + ImapKeepalive))",
          "1261:     if (imap_cmd_idle(idata) < 0)",
          "1262:       return -1;",
          "1264:   if (idata->state == IMAP_IDLE)",
          "1266:     while ((result = mutt_socket_poll(idata->conn, 0)) > 0)",
          "1268:       if (imap_cmd_step(idata) != IMAP_CMD_CONTINUE)",
          "1269:       {",
          "1270:         mutt_debug(1, \"Error reading IDLE response\\n\");",
          "1271:         return -1;",
          "1272:       }",
          "1273:     }",
          "1274:     if (result < 0)",
          "1275:     {",
          "1276:       mutt_debug(1, \"Poll failed, disabling IDLE\\n\");",
          "1277:       mutt_bit_unset(idata->capabilities, IDLE);",
          "1279:   }",
          "1281:   if ((force || (idata->state != IMAP_IDLE && time(NULL) >= idata->lastread + Timeout)) &&",
          "1282:       imap_exec(idata, \"NOOP\", IMAP_CMD_POLL) != 0)",
          "1283:     return -1;",
          "1287:   imap_cmd_finish(idata);",
          "1289:   if (idata->check_status & IMAP_EXPUNGE_PENDING)",
          "1290:     result = MUTT_REOPENED;",
          "1291:   else if (idata->check_status & IMAP_NEWMAIL_PENDING)",
          "1292:     result = MUTT_NEW_MAIL;",
          "1293:   else if (idata->check_status & IMAP_FLAGS_PENDING)",
          "1294:     result = MUTT_FLAGS;",
          "1296:   idata->check_status = 0;",
          "1298:   return result;",
          "1308: int imap_buffy_check(int force, int check_stats)",
          "1311:   struct ImapData *lastdata = NULL;",
          "1312:   struct Buffy *mailbox = NULL;",
          "1313:   char name[LONG_STRING];",
          "1314:   char command[LONG_STRING];",
          "1315:   char munged[LONG_STRING];",
          "1316:   int buffies = 0;",
          "1318:   for (mailbox = Incoming; mailbox; mailbox = mailbox->next)",
          "1319:   {",
          "1321:     if (!mailbox->magic)",
          "1322:     {",
          "1323:       if (mx_is_imap(mailbox->path))",
          "1324:         mailbox->magic = MUTT_IMAP;",
          "1325:     }",
          "1327:     if (mailbox->magic != MUTT_IMAP)",
          "1328:       continue;",
          "1330:     if (imap_get_mailbox(mailbox->path, &idata, name, sizeof(name)) < 0)",
          "1332:       mailbox->new = false;",
          "1333:       continue;",
          "1340:     if (idata->mailbox && (imap_mxcmp(name, idata->mailbox) == 0))",
          "1342:       mailbox->new = false;",
          "1343:       continue;",
          "1346:     if (!mutt_bit_isset(idata->capabilities, IMAP4REV1) &&",
          "1347:         !mutt_bit_isset(idata->capabilities, STATUS))",
          "1348:     {",
          "1349:       mutt_debug(2, \"Server doesn't support STATUS\\n\");",
          "1350:       continue;",
          "1351:     }",
          "1353:     if (lastdata && idata != lastdata)",
          "1357:       if (imap_exec(lastdata, NULL, IMAP_CMD_FAIL_OK | IMAP_CMD_POLL) == -1)",
          "1358:         mutt_debug(1, \"Error polling mailboxes\\n\");",
          "1360:       lastdata = NULL;",
          "1363:     if (!lastdata)",
          "1364:       lastdata = idata;",
          "1366:     imap_munge_mbox_name(idata, munged, sizeof(munged), name);",
          "1367:     if (check_stats)",
          "1368:       snprintf(command, sizeof(command),",
          "1369:                \"STATUS %s (UIDNEXT UIDVALIDITY UNSEEN RECENT MESSAGES)\", munged);",
          "1370:     else",
          "1371:       snprintf(command, sizeof(command),",
          "1372:                \"STATUS %s (UIDNEXT UIDVALIDITY UNSEEN RECENT)\", munged);",
          "1374:     if (imap_exec(idata, command, IMAP_CMD_QUEUE | IMAP_CMD_POLL) < 0)",
          "1376:       mutt_debug(1, \"Error queueing command\\n\");",
          "1377:       return 0;",
          "1379:   }",
          "1381:   if (lastdata && (imap_exec(lastdata, NULL, IMAP_CMD_FAIL_OK | IMAP_CMD_POLL) == -1))",
          "1382:   {",
          "1383:     mutt_debug(1, \"Error polling mailboxes\\n\");",
          "1384:     return 0;",
          "1388:   for (mailbox = Incoming; mailbox; mailbox = mailbox->next)",
          "1389:   {",
          "1390:     if (mailbox->magic == MUTT_IMAP && mailbox->new)",
          "1391:       buffies++;",
          "1392:   }",
          "1394:   return buffies;",
          "1405: int imap_status(char *path, int queue)",
          "1407:   static int queued = 0;",
          "1409:   struct ImapData *idata = NULL;",
          "1410:   char buf[LONG_STRING];",
          "1411:   char mbox[LONG_STRING];",
          "1412:   struct ImapStatus *status = NULL;",
          "1414:   if (imap_get_mailbox(path, &idata, buf, sizeof(buf)) < 0)",
          "1421:   if (idata->ctx && !imap_mxcmp(buf, idata->mailbox))",
          "1422:     return idata->ctx->msgcount;",
          "1423:   else if (mutt_bit_isset(idata->capabilities, IMAP4REV1) ||",
          "1424:            mutt_bit_isset(idata->capabilities, STATUS))",
          "1426:     imap_munge_mbox_name(idata, mbox, sizeof(mbox), buf);",
          "1427:     snprintf(buf, sizeof(buf), \"STATUS %s (%s)\", mbox, \"MESSAGES\");",
          "1428:     imap_unmunge_mbox_name(idata, mbox);",
          "1430:   else",
          "1433:     return -1;",
          "1435:   if (queue)",
          "1437:     imap_exec(idata, buf, IMAP_CMD_QUEUE);",
          "1438:     queued = 1;",
          "1439:     return 0;",
          "1440:   }",
          "1441:   else if (!queued)",
          "1442:     imap_exec(idata, buf, 0);",
          "1444:   queued = 0;",
          "1445:   if ((status = imap_mboxcache_get(idata, mbox, 0)))",
          "1446:     return status->messages;",
          "1448:   return 0;",
          "1449: }",
          "1456: struct ImapStatus *imap_mboxcache_get(struct ImapData *idata, const char *mbox, int create)",
          "1457: {",
          "1458:   struct ImapStatus *status = NULL;",
          "1460:   header_cache_t *hc = NULL;",
          "1461:   void *uidvalidity = NULL;",
          "1462:   void *uidnext = NULL;",
          "1465:   struct ListNode *np;",
          "1466:   STAILQ_FOREACH(np, &idata->mboxcache, entries)",
          "1468:     status = (struct ImapStatus *) np->data;",
          "1470:     if (imap_mxcmp(mbox, status->name) == 0)",
          "1471:       return status;",
          "1473:   status = NULL;",
          "1476:   if (create)",
          "1478:     struct ImapStatus *scache = safe_calloc(1, sizeof(struct ImapStatus));",
          "1479:     scache->name = (char *) mbox;",
          "1480:     mutt_list_insert_tail(&idata->mboxcache, (char *) scache);",
          "1481:     status = imap_mboxcache_get(idata, mbox, 0);",
          "1482:     status->name = safe_strdup(mbox);",
          "1485: #ifdef USE_HCACHE",
          "1486:   hc = imap_hcache_open(idata, mbox);",
          "1487:   if (hc)",
          "1489:     uidvalidity = mutt_hcache_fetch_raw(hc, \"/UIDVALIDITY\", 12);",
          "1490:     uidnext = mutt_hcache_fetch_raw(hc, \"/UIDNEXT\", 8);",
          "1491:     if (uidvalidity)",
          "1493:       if (!status)",
          "1495:         mutt_hcache_free(hc, &uidvalidity);",
          "1496:         mutt_hcache_free(hc, &uidnext);",
          "1497:         mutt_hcache_close(hc);",
          "1498:         return imap_mboxcache_get(idata, mbox, 1);",
          "1499:       }",
          "1500:       status->uidvalidity = *(unsigned int *) uidvalidity;",
          "1501:       status->uidnext = uidnext ? *(unsigned int *) uidnext : 0;",
          "1502:       mutt_debug(3, \"mboxcache: hcache uidvalidity %d, uidnext %d\\n\",",
          "1503:                  status->uidvalidity, status->uidnext);",
          "1505:     mutt_hcache_free(hc, &uidvalidity);",
          "1506:     mutt_hcache_free(hc, &uidnext);",
          "1507:     mutt_hcache_close(hc);",
          "1509: #endif",
          "1511:   return status;",
          "1512: }",
          "1514: void imap_mboxcache_free(struct ImapData *idata)",
          "1515: {",
          "1516:   struct ImapStatus *status = NULL;",
          "1518:   struct ListNode *np;",
          "1519:   STAILQ_FOREACH(np, &idata->mboxcache, entries)",
          "1521:     status = (struct ImapStatus *) np->data;",
          "1522:     FREE(&status->name);",
          "1525:   mutt_list_free(&idata->mboxcache);",
          "1528: int imap_search(struct Context *ctx, const struct Pattern *pat)",
          "1530:   struct Buffer buf;",
          "1531:   struct ImapData *idata = ctx->data;",
          "1532:   for (int i = 0; i < ctx->msgcount; i++)",
          "1533:     ctx->hdrs[i]->matched = false;",
          "1535:   if (!do_search(pat, 1))",
          "1538:   mutt_buffer_init(&buf);",
          "1539:   mutt_buffer_addstr(&buf, \"UID SEARCH \");",
          "1540:   if (imap_compile_search(ctx, pat, &buf) < 0)",
          "1542:     FREE(&buf.data);",
          "1543:     return -1;",
          "1544:   }",
          "1545:   if (imap_exec(idata, buf.data, 0) < 0)",
          "1546:   {",
          "1547:     FREE(&buf.data);",
          "1548:     return -1;",
          "1549:   }",
          "1551:   FREE(&buf.data);",
          "1552:   return 0;",
          "1553: }",
          "1555: int imap_subscribe(char *path, int subscribe)",
          "1556: {",
          "1557:   struct ImapData *idata = NULL;",
          "1558:   char buf[LONG_STRING];",
          "1559:   char mbox[LONG_STRING];",
          "1560:   char errstr[STRING];",
          "1561:   struct Buffer err, token;",
          "1562:   struct ImapMbox mx;",
          "1564:   if (!mx_is_imap(path) || imap_parse_path(path, &mx) || !mx.mbox)",
          "1565:   {",
          "1566:     mutt_error(_(\"Bad mailbox name\"));",
          "1567:     return -1;",
          "1569:   idata = imap_conn_find(&(mx.account), 0);",
          "1570:   if (!idata)",
          "1571:     goto fail;",
          "1573:   imap_fix_path(idata, mx.mbox, buf, sizeof(buf));",
          "1574:   if (!*buf)",
          "1575:     strfcpy(buf, \"INBOX\", sizeof(buf));",
          "1577:   if (option(OPT_IMAP_CHECK_SUBSCRIBED))",
          "1579:     mutt_buffer_init(&token);",
          "1580:     mutt_buffer_init(&err);",
          "1581:     err.data = errstr;",
          "1582:     err.dsize = sizeof(errstr);",
          "1583:     snprintf(mbox, sizeof(mbox), \"%smailboxes \\\"%s\\\"\", subscribe ? \"\" : \"un\", path);",
          "1584:     if (mutt_parse_rc_line(mbox, &token, &err))",
          "1585:       mutt_debug(1, \"Error adding subscribed mailbox: %s\\n\", errstr);",
          "1586:     FREE(&token.data);",
          "1589:   if (subscribe)",
          "1590:     mutt_message(_(\"Subscribing to %s...\"), buf);",
          "1591:   else",
          "1592:     mutt_message(_(\"Unsubscribing from %s...\"), buf);",
          "1593:   imap_munge_mbox_name(idata, mbox, sizeof(mbox), buf);",
          "1595:   snprintf(buf, sizeof(buf), \"%sSUBSCRIBE %s\", subscribe ? \"\" : \"UN\", mbox);",
          "1597:   if (imap_exec(idata, buf, 0) < 0)",
          "1598:     goto fail;",
          "1600:   imap_unmunge_mbox_name(idata, mx.mbox);",
          "1601:   if (subscribe)",
          "1602:     mutt_message(_(\"Subscribed to %s\"), mx.mbox);",
          "1603:   else",
          "1604:     mutt_message(_(\"Unsubscribed from %s\"), mx.mbox);",
          "1605:   FREE(&mx.mbox);",
          "1608: fail:",
          "1609:   FREE(&mx.mbox);",
          "1610:   return -1;",
          "1619: int imap_complete(char *dest, size_t dlen, char *path)",
          "1621:   struct ImapData *idata = NULL;",
          "1622:   char list[LONG_STRING];",
          "1623:   char buf[LONG_STRING];",
          "1624:   struct ImapList listresp;",
          "1625:   char completion[LONG_STRING];",
          "1626:   int clen;",
          "1627:   size_t matchlen = 0;",
          "1628:   int completions = 0;",
          "1629:   struct ImapMbox mx;",
          "1630:   int rc;",
          "1632:   if (imap_parse_path(path, &mx))",
          "1634:     strfcpy(dest, path, dlen);",
          "1635:     return imap_complete_hosts(dest, dlen);",
          "1640:   idata = imap_conn_find(&(mx.account), MUTT_IMAP_CONN_NONEW);",
          "1641:   if (!idata)",
          "1643:     FREE(&mx.mbox);",
          "1644:     strfcpy(dest, path, dlen);",
          "1645:     return imap_complete_hosts(dest, dlen);",
          "1650:   if (mx.mbox && mx.mbox[0])",
          "1651:     imap_fix_path(idata, mx.mbox, list, sizeof(list));",
          "1652:   else",
          "1653:     list[0] = '\\0';",
          "1656:   snprintf(buf, sizeof(buf), \"%s \\\"\\\" \\\"%s%%\\\"\",",
          "1657:            option(OPT_IMAP_LIST_SUBSCRIBED) ? \"LSUB\" : \"LIST\", list);",
          "1659:   imap_cmd_start(idata, buf);",
          "1662:   strfcpy(completion, NONULL(mx.mbox), sizeof(completion));",
          "1663:   idata->cmdtype = IMAP_CT_LIST;",
          "1664:   idata->cmddata = &listresp;",
          "1665:   do",
          "1666:   {",
          "1667:     listresp.name = NULL;",
          "1668:     rc = imap_cmd_step(idata);",
          "1670:     if (rc == IMAP_CMD_CONTINUE && listresp.name)",
          "1671:     {",
          "1674:       if (listresp.noselect)",
          "1675:       {",
          "1676:         clen = strlen(listresp.name);",
          "1677:         listresp.name[clen++] = listresp.delim;",
          "1678:         listresp.name[clen] = '\\0';",
          "1679:       }",
          "1681:       if (!completions)",
          "1682:       {",
          "1683:         strfcpy(completion, listresp.name, sizeof(completion));",
          "1684:         matchlen = strlen(completion);",
          "1685:         completions++;",
          "1686:         continue;",
          "1687:       }",
          "1689:       matchlen = longest_common_prefix(completion, listresp.name, 0, matchlen);",
          "1690:       completions++;",
          "1691:     }",
          "1692:   } while (rc == IMAP_CMD_CONTINUE);",
          "1693:   idata->cmddata = NULL;",
          "1695:   if (completions)",
          "1696:   {",
          "1698:     imap_qualify_path(dest, dlen, &mx, completion);",
          "1699:     mutt_pretty_mailbox(dest, dlen);",
          "1701:     FREE(&mx.mbox);",
          "1702:     return 0;",
          "1703:   }",
          "1705:   return -1;",
          "1714: int imap_fast_trash(struct Context *ctx, char *dest)",
          "1716:   struct ImapData *idata = NULL;",
          "1717:   char mbox[LONG_STRING];",
          "1718:   char mmbox[LONG_STRING];",
          "1719:   char prompt[LONG_STRING];",
          "1720:   int rc;",
          "1722:   bool triedcreate = false;",
          "1723:   struct Buffer *sync_cmd = NULL;",
          "1724:   int err_continue = MUTT_NO;",
          "1726:   idata = ctx->data;",
          "1728:   if (imap_parse_path(dest, &mx))",
          "1730:     mutt_debug(1, \"imap_fast_trash: bad destination %s\\n\", dest);",
          "1735:   if (!mutt_account_match(&(idata->conn->account), &(mx.account)))",
          "1737:     mutt_debug(3, \"imap_fast_trash: %s not same server as %s\\n\", dest, ctx->path);",
          "1738:     return 1;",
          "1741:   imap_fix_path(idata, mx.mbox, mbox, sizeof(mbox));",
          "1742:   if (!*mbox)",
          "1743:     strfcpy(mbox, \"INBOX\", sizeof(mbox));",
          "1744:   imap_munge_mbox_name(idata, mmbox, sizeof(mmbox), mbox);",
          "1746:   sync_cmd = mutt_buffer_new();",
          "1747:   for (int i = 0; i < ctx->msgcount; i++)",
          "1749:     if (ctx->hdrs[i]->active && ctx->hdrs[i]->changed &&",
          "1750:         ctx->hdrs[i]->deleted && !ctx->hdrs[i]->purge)",
          "1752:       rc = imap_sync_message_for_copy(idata, ctx->hdrs[i], sync_cmd, &err_continue);",
          "1753:       if (rc < 0)",
          "1754:       {",
          "1755:         mutt_debug(1, \"imap_fast_trash: could not sync\\n\");",
          "1756:         goto out;",
          "1757:       }",
          "1759:   }",
          "1762:   do",
          "1763:   {",
          "1764:     rc = imap_exec_msgset(idata, \"UID COPY\", mmbox, MUTT_TRASH, 0, 0);",
          "1765:     if (!rc)",
          "1767:       mutt_debug(1, \"imap_fast_trash: No messages to trash\\n\");",
          "1768:       rc = -1;",
          "1769:       goto out;",
          "1771:     else if (rc < 0)",
          "1773:       mutt_debug(1, \"could not queue copy\\n\");",
          "1774:       goto out;",
          "1776:     else",
          "1777:       mutt_message(_(\"Copying %d messages to %s...\"), rc, mbox);",
          "1780:     rc = imap_exec(idata, NULL, IMAP_CMD_FAIL_OK);",
          "1781:     if (rc == -2)",
          "1783:       if (triedcreate)",
          "1784:       {",
          "1785:         mutt_debug(1, \"Already tried to create mailbox %s\\n\", mbox);",
          "1786:         break;",
          "1787:       }",
          "1789:       if (mutt_strncasecmp(imap_get_qualifier(idata->buf), \"[TRYCREATE]\", 11) != 0)",
          "1790:         break;",
          "1791:       mutt_debug(3, \"imap_fast_trash: server suggests TRYCREATE\\n\");",
          "1792:       snprintf(prompt, sizeof(prompt), _(\"Create %s?\"), mbox);",
          "1793:       if (option(OPT_CONFIRMCREATE) && mutt_yesorno(prompt, 1) != MUTT_YES)",
          "1794:       {",
          "1795:         mutt_clear_error();",
          "1796:         goto out;",
          "1797:       }",
          "1798:       if (imap_create_mailbox(idata, mbox) < 0)",
          "1799:         break;",
          "1800:       triedcreate = true;",
          "1802:   } while (rc == -2);",
          "1804:   if (rc != 0)",
          "1805:   {",
          "1806:     imap_error(\"imap_fast_trash\", idata->buf);",
          "1807:     goto out;",
          "1808:   }",
          "1810:   rc = 0;",
          "1812: out:",
          "1813:   mutt_buffer_free(&sync_cmd);",
          "1814:   FREE(&mx.mbox);",
          "1816:   return rc < 0 ? -1 : rc;",
          "1817: }",
          "1819: static int imap_open_mailbox(struct Context *ctx)",
          "1820: {",
          "1821:   struct ImapData *idata = NULL;",
          "1822:   struct ImapStatus *status = NULL;",
          "1823:   char buf[LONG_STRING];",
          "1824:   char bufout[LONG_STRING];",
          "1825:   int count = 0;",
          "1826:   struct ImapMbox mx, pmx;",
          "1827:   int rc;",
          "1829:   if (imap_parse_path(ctx->path, &mx))",
          "1831:     mutt_error(_(\"%s is an invalid IMAP path\"), ctx->path);",
          "1832:     return -1;",
          "1836:   idata = imap_conn_find(&(mx.account), MUTT_IMAP_CONN_NOSELECT);",
          "1837:   if (!idata)",
          "1838:     goto fail_noidata;",
          "1839:   if (idata->state < IMAP_AUTHENTICATED)",
          "1840:     goto fail;",
          "1843:   ctx->data = idata;",
          "1846:   imap_fix_path(idata, mx.mbox, buf, sizeof(buf));",
          "1847:   if (!*buf)",
          "1848:     strfcpy(buf, \"INBOX\", sizeof(buf));",
          "1849:   FREE(&(idata->mailbox));",
          "1850:   idata->mailbox = safe_strdup(buf);",
          "1851:   imap_qualify_path(buf, sizeof(buf), &mx, idata->mailbox);",
          "1853:   FREE(&(ctx->path));",
          "1854:   FREE(&(ctx->realpath));",
          "1855:   ctx->path = safe_strdup(buf);",
          "1856:   ctx->realpath = safe_strdup(ctx->path);",
          "1858:   idata->ctx = ctx;",
          "1861:   idata->status = false;",
          "1862:   memset(idata->ctx->rights, 0, sizeof(idata->ctx->rights));",
          "1863:   idata->new_mail_count = 0;",
          "1864:   idata->max_msn = 0;",
          "1866:   mutt_message(_(\"Selecting %s...\"), idata->mailbox);",
          "1867:   imap_munge_mbox_name(idata, buf, sizeof(buf), idata->mailbox);",
          "1870:   if (mutt_bit_isset(idata->capabilities, ACL))",
          "1872:     snprintf(bufout, sizeof(bufout), \"MYRIGHTS %s\", buf);",
          "1873:     imap_exec(idata, bufout, IMAP_CMD_QUEUE);",
          "1878:     mutt_bit_set(idata->ctx->rights, MUTT_ACL_LOOKUP);",
          "1879:     mutt_bit_set(idata->ctx->rights, MUTT_ACL_READ);",
          "1880:     mutt_bit_set(idata->ctx->rights, MUTT_ACL_SEEN);",
          "1881:     mutt_bit_set(idata->ctx->rights, MUTT_ACL_WRITE);",
          "1882:     mutt_bit_set(idata->ctx->rights, MUTT_ACL_INSERT);",
          "1883:     mutt_bit_set(idata->ctx->rights, MUTT_ACL_POST);",
          "1884:     mutt_bit_set(idata->ctx->rights, MUTT_ACL_CREATE);",
          "1885:     mutt_bit_set(idata->ctx->rights, MUTT_ACL_DELETE);",
          "1888:   pmx.mbox = NULL;",
          "1889:   if (mx_is_imap(Postponed) && !imap_parse_path(Postponed, &pmx) &&",
          "1890:       mutt_account_match(&pmx.account, &mx.account))",
          "1891:     imap_status(Postponed, 1);",
          "1892:   FREE(&pmx.mbox);",
          "1894:   snprintf(bufout, sizeof(bufout), \"%s %s\",",
          "1895:            ctx->readonly ? \"EXAMINE\" : \"SELECT\", buf);",
          "1897:   idata->state = IMAP_SELECTED;",
          "1899:   imap_cmd_start(idata, bufout);",
          "1901:   status = imap_mboxcache_get(idata, idata->mailbox, 1);",
          "1903:   do",
          "1905:     char *pc = NULL;",
          "1907:     rc = imap_cmd_step(idata);",
          "1908:     if (rc != IMAP_CMD_CONTINUE)",
          "1909:       break;",
          "1911:     pc = idata->buf + 2;",
          "1915:     if (mutt_strncasecmp(\"FLAGS\", pc, 5) == 0)",
          "1916:     {",
          "1918:       if (STAILQ_EMPTY(&idata->flags))",
          "1919:       {",
          "1920:         mutt_debug(3, \"Getting mailbox FLAGS\\n\");",
          "1921:         pc = imap_get_flags(&idata->flags, pc);",
          "1922:         if (!pc)",
          "1923:           goto fail;",
          "1924:       }",
          "1925:     }",
          "1927:     else if (mutt_strncasecmp(\"OK [PERMANENTFLAGS\", pc, 18) == 0)",
          "1928:     {",
          "1929:       mutt_debug(3, \"Getting mailbox PERMANENTFLAGS\\n\");",
          "1931:       mutt_list_free(&idata->flags);",
          "1933:       pc += 13;",
          "1934:       pc = imap_get_flags(&(idata->flags), pc);",
          "1935:       if (!pc)",
          "1936:         goto fail;",
          "1937:     }",
          "1939:     else if (mutt_strncasecmp(\"OK [UIDVALIDITY\", pc, 14) == 0)",
          "1940:     {",
          "1941:       mutt_debug(3, \"Getting mailbox UIDVALIDITY\\n\");",
          "1942:       pc += 3;",
          "1943:       pc = imap_next_word(pc);",
          "1944:       idata->uid_validity = strtol(pc, NULL, 10);",
          "1945:       status->uidvalidity = idata->uid_validity;",
          "1946:     }",
          "1947:     else if (mutt_strncasecmp(\"OK [UIDNEXT\", pc, 11) == 0)",
          "1948:     {",
          "1949:       mutt_debug(3, \"Getting mailbox UIDNEXT\\n\");",
          "1950:       pc += 3;",
          "1951:       pc = imap_next_word(pc);",
          "1952:       idata->uidnext = strtol(pc, NULL, 10);",
          "1953:       status->uidnext = idata->uidnext;",
          "1954:     }",
          "1955:     else",
          "1956:     {",
          "1957:       pc = imap_next_word(pc);",
          "1958:       if (mutt_strncasecmp(\"EXISTS\", pc, 6) == 0)",
          "1959:       {",
          "1960:         count = idata->new_mail_count;",
          "1961:         idata->new_mail_count = 0;",
          "1962:       }",
          "1963:     }",
          "1964:   } while (rc == IMAP_CMD_CONTINUE);",
          "1966:   if (rc == IMAP_CMD_NO)",
          "1967:   {",
          "1968:     char *s = NULL;",
          "1971:     mutt_error(\"%s\", s);",
          "1972:     mutt_sleep(2);",
          "1973:     goto fail;",
          "1976:   if (rc != IMAP_CMD_OK)",
          "1977:     goto fail;",
          "1980:   if ((mutt_strncasecmp(imap_get_qualifier(idata->buf), \"[READ-ONLY]\", 11) == 0) &&",
          "1981:       !mutt_bit_isset(idata->capabilities, ACL))",
          "1983:     mutt_debug(2, \"Mailbox is read-only.\\n\");",
          "1984:     ctx->readonly = true;",
          "1987: #ifdef DEBUG",
          "1989:   if (debuglevel > 2)",
          "1991:     if (STAILQ_EMPTY(&idata->flags))",
          "1992:       mutt_debug(3, \"No folder flags found\\n\");",
          "1993:     else",
          "1995:       struct ListNode *np;",
          "1996:       struct Buffer flag_buffer;",
          "1997:       mutt_buffer_init(&flag_buffer);",
          "1998:       mutt_buffer_printf(&flag_buffer, \"Mailbox flags: \");",
          "1999:       STAILQ_FOREACH(np, &idata->flags, entries)",
          "2001:         mutt_buffer_printf(&flag_buffer, \"[%s] \", np->data);",
          "2003:       mutt_debug(3, \"%s\\n\", flag_buffer.data);",
          "2004:       FREE(&flag_buffer.data);",
          "2009:   if (!(mutt_bit_isset(idata->ctx->rights, MUTT_ACL_DELETE) ||",
          "2010:         mutt_bit_isset(idata->ctx->rights, MUTT_ACL_SEEN) ||",
          "2011:         mutt_bit_isset(idata->ctx->rights, MUTT_ACL_WRITE) ||",
          "2012:         mutt_bit_isset(idata->ctx->rights, MUTT_ACL_INSERT)))",
          "2013:     ctx->readonly = true;",
          "2015:   ctx->hdrmax = count;",
          "2016:   ctx->hdrs = safe_calloc(count, sizeof(struct Header *));",
          "2017:   ctx->v2r = safe_calloc(count, sizeof(int));",
          "2018:   ctx->msgcount = 0;",
          "2020:   if (count && (imap_read_headers(idata, 1, count) < 0))",
          "2021:   {",
          "2022:     mutt_error(_(\"Error opening mailbox\"));",
          "2023:     mutt_sleep(1);",
          "2024:     goto fail;",
          "2025:   }",
          "2027:   mutt_debug(2, \"imap_open_mailbox: msgcount is %d\\n\", ctx->msgcount);",
          "2028:   FREE(&mx.mbox);",
          "2029:   return 0;",
          "2031: fail:",
          "2032:   if (idata->state == IMAP_SELECTED)",
          "2033:     idata->state = IMAP_AUTHENTICATED;",
          "2034: fail_noidata:",
          "2035:   FREE(&mx.mbox);",
          "2036:   return -1;",
          "2039: static int imap_open_mailbox_append(struct Context *ctx, int flags)",
          "2041:   struct ImapData *idata = NULL;",
          "2042:   char buf[LONG_STRING];",
          "2043:   char mailbox[LONG_STRING];",
          "2044:   struct ImapMbox mx;",
          "2045:   int rc;",
          "2047:   if (imap_parse_path(ctx->path, &mx))",
          "2048:     return -1;",
          "2053:   idata = imap_conn_find(&(mx.account), 0);",
          "2054:   if (!idata)",
          "2056:     FREE(&mx.mbox);",
          "2057:     return -1;",
          "2060:   ctx->data = idata;",
          "2062:   imap_fix_path(idata, mx.mbox, mailbox, sizeof(mailbox));",
          "2063:   if (!*mailbox)",
          "2064:     strfcpy(mailbox, \"INBOX\", sizeof(mailbox));",
          "2065:   FREE(&mx.mbox);",
          "2067:   rc = imap_access(ctx->path);",
          "2068:   if (rc == 0)",
          "2069:     return 0;",
          "2071:   if (rc == -1)",
          "2072:     return -1;",
          "2074:   snprintf(buf, sizeof(buf), _(\"Create %s?\"), mailbox);",
          "2075:   if (option(OPT_CONFIRMCREATE) && mutt_yesorno(buf, 1) != MUTT_YES)",
          "2076:     return -1;",
          "2078:   if (imap_create_mailbox(idata, mailbox) < 0)",
          "2079:     return -1;",
          "2081:   return 0;",
          "2087: int imap_close_mailbox(struct Context *ctx)",
          "2089:   struct ImapData *idata = NULL;",
          "2091:   idata = ctx->data;",
          "2093:   if (!idata)",
          "2094:     return 0;",
          "2104:   if (ctx == idata->ctx)",
          "2106:     if (idata->status != IMAP_FATAL && idata->state >= IMAP_SELECTED)",
          "2110:       if (!ctx->deleted)",
          "2111:         imap_exec(idata, \"CLOSE\", IMAP_CMD_QUEUE);",
          "2112:       idata->state = IMAP_AUTHENTICATED;",
          "2115:     idata->reopen &= IMAP_REOPEN_ALLOW;",
          "2116:     FREE(&(idata->mailbox));",
          "2117:     mutt_list_free(&idata->flags);",
          "2118:     idata->ctx = NULL;",
          "2120:     hash_destroy(&idata->uid_hash, NULL);",
          "2121:     FREE(&idata->msn_index);",
          "2122:     idata->msn_index_size = 0;",
          "2123:     idata->max_msn = 0;",
          "2125:     for (int i = 0; i < IMAP_CACHE_LEN; i++)",
          "2126:     {",
          "2127:       if (idata->cache[i].path)",
          "2129:         unlink(idata->cache[i].path);",
          "2130:         FREE(&idata->cache[i].path);",
          "2134:     mutt_bcache_close(&idata->bcache);",
          "2135:   }",
          "2138:   for (int i = 0; i < ctx->msgcount; i++)",
          "2139:   {",
          "2141:     if (ctx->hdrs[i] && ctx->hdrs[i]->data)",
          "2142:       imap_free_header_data((struct ImapHeaderData **) &(ctx->hdrs[i]->data));",
          "2148: static int imap_open_new_message(struct Message *msg, struct Context *dest, struct Header *hdr)",
          "2150:   char tmp[_POSIX_PATH_MAX];",
          "2152:   mutt_mktemp(tmp, sizeof(tmp));",
          "2153:   msg->fp = safe_fopen(tmp, \"w\");",
          "2154:   if (!msg->fp)",
          "2156:     mutt_perror(tmp);",
          "2159:   msg->path = safe_strdup(tmp);",
          "2163: static int imap_check_mailbox_reopen(struct Context *ctx, int *index_hint)",
          "2164: {",
          "2165:   int rc;",
          "2166:   (void) index_hint;",
          "2168:   imap_allow_reopen(ctx);",
          "2169:   rc = imap_check(ctx->data, 0);",
          "2170:   imap_disallow_reopen(ctx);",
          "2172:   return rc;",
          "2173: }",
          "2182: int imap_sync_mailbox(struct Context *ctx, int expunge)",
          "2185:   struct Context *appendctx = NULL;",
          "2186:   struct Header *h = NULL;",
          "2187:   struct Header **hdrs = NULL;",
          "2188:   int oldsort;",
          "2189:   int rc;",
          "2191:   idata = ctx->data;",
          "2193:   if (idata->state < IMAP_SELECTED)",
          "2195:     mutt_debug(2, \"imap_sync_mailbox: no mailbox selected\\n\");",
          "2201:   imap_allow_reopen(ctx);",
          "2203:   rc = imap_check(idata, 0);",
          "2204:   if (rc != 0)",
          "2205:     return rc;",
          "2208:   if (expunge && mutt_bit_isset(ctx->rights, MUTT_ACL_DELETE))",
          "2209:   {",
          "2210:     if ((rc = imap_exec_msgset(idata, \"UID STORE\", \"+FLAGS.SILENT (\\\\Deleted)\",",
          "2211:                                MUTT_DELETED, 1, 0)) < 0)",
          "2212:     {",
          "2213:       mutt_error(_(\"Expunge failed\"));",
          "2214:       mutt_sleep(1);",
          "2215:       goto out;",
          "2216:     }",
          "2218:     if (rc > 0)",
          "2219:     {",
          "2222:       for (int i = 0; i < ctx->msgcount; i++)",
          "2223:         if (ctx->hdrs[i]->deleted && ctx->hdrs[i]->changed)",
          "2224:           ctx->hdrs[i]->active = false;",
          "2225:       mutt_message(_(\"Marking %d messages deleted...\"), rc);",
          "2226:     }",
          "2227:   }",
          "2229: #ifdef USE_HCACHE",
          "2230:   idata->hcache = imap_hcache_open(idata, NULL);",
          "2231: #endif",
          "2234:   for (int i = 0; i < ctx->msgcount; i++)",
          "2236:     h = ctx->hdrs[i];",
          "2238:     if (h->deleted)",
          "2239:     {",
          "2240:       imap_cache_del(idata, h);",
          "2241: #ifdef USE_HCACHE",
          "2242:       imap_hcache_del(idata, HEADER_DATA(h)->uid);",
          "2243: #endif",
          "2244:     }",
          "2246:     if (h->active && h->changed)",
          "2247:     {",
          "2248: #ifdef USE_HCACHE",
          "2249:       imap_hcache_put(idata, h);",
          "2250: #endif",
          "2254:       if ((h->env && (h->env->refs_changed || h->env->irt_changed)) ||",
          "2255:           h->attach_del || h->xlabel_changed)",
          "2256:       {",
          "2257:         mutt_message(_(\"Saving changed messages... [%d/%d]\"), i + 1, ctx->msgcount);",
          "2258:         if (!appendctx)",
          "2259:           appendctx = mx_open_mailbox(ctx->path, MUTT_APPEND | MUTT_QUIET, NULL);",
          "2260:         if (!appendctx)",
          "2261:           mutt_debug(",
          "2262:               1, \"imap_sync_mailbox: Error opening mailbox in append mode\\n\");",
          "2263:         else",
          "2264:           _mutt_save_message(h, appendctx, 1, 0, 0);",
          "2265:         h->xlabel_changed = false;",
          "2266:       }",
          "2267:     }",
          "2268:   }",
          "2270: #ifdef USE_HCACHE",
          "2271:   imap_hcache_close(idata);",
          "2272: #endif",
          "2275:   oldsort = Sort;",
          "2276:   if (Sort != SORT_ORDER)",
          "2277:   {",
          "2278:     hdrs = ctx->hdrs;",
          "2279:     ctx->hdrs = safe_malloc(ctx->msgcount * sizeof(struct Header *));",
          "2280:     memcpy(ctx->hdrs, hdrs, ctx->msgcount * sizeof(struct Header *));",
          "2282:     Sort = SORT_ORDER;",
          "2283:     qsort(ctx->hdrs, ctx->msgcount, sizeof(struct Header *), mutt_get_sort_func(SORT_ORDER));",
          "2284:   }",
          "2286:   rc = sync_helper(idata, MUTT_ACL_DELETE, MUTT_DELETED, \"\\\\Deleted\");",
          "2287:   if (rc >= 0)",
          "2288:     rc |= sync_helper(idata, MUTT_ACL_WRITE, MUTT_FLAG, \"\\\\Flagged\");",
          "2289:   if (rc >= 0)",
          "2290:     rc |= sync_helper(idata, MUTT_ACL_WRITE, MUTT_OLD, \"Old\");",
          "2291:   if (rc >= 0)",
          "2292:     rc |= sync_helper(idata, MUTT_ACL_SEEN, MUTT_READ, \"\\\\Seen\");",
          "2293:   if (rc >= 0)",
          "2294:     rc |= sync_helper(idata, MUTT_ACL_WRITE, MUTT_REPLIED, \"\\\\Answered\");",
          "2296:   if (oldsort != Sort)",
          "2297:   {",
          "2298:     Sort = oldsort;",
          "2299:     FREE(&ctx->hdrs);",
          "2300:     ctx->hdrs = hdrs;",
          "2301:   }",
          "2304:   if (rc > 0)",
          "2305:     if (imap_exec(idata, NULL, 0) != IMAP_CMD_OK)",
          "2306:       rc = -1;",
          "2308:   if (rc < 0)",
          "2310:     if (ctx->closing)",
          "2312:       if (mutt_yesorno(_(\"Error saving flags. Close anyway?\"), 0) == MUTT_YES)",
          "2315:         idata->state = IMAP_AUTHENTICATED;",
          "2316:         goto out;",
          "2319:     else",
          "2320:       mutt_error(_(\"Error saving flags\"));",
          "2321:     rc = -1;",
          "2322:     goto out;",
          "2328:   for (int i = 0; i < ctx->msgcount; i++)",
          "2330:     HEADER_DATA(ctx->hdrs[i])->deleted = ctx->hdrs[i]->deleted;",
          "2331:     HEADER_DATA(ctx->hdrs[i])->flagged = ctx->hdrs[i]->flagged;",
          "2332:     HEADER_DATA(ctx->hdrs[i])->old = ctx->hdrs[i]->old;",
          "2333:     HEADER_DATA(ctx->hdrs[i])->read = ctx->hdrs[i]->read;",
          "2334:     HEADER_DATA(ctx->hdrs[i])->replied = ctx->hdrs[i]->replied;",
          "2335:     ctx->hdrs[i]->changed = false;",
          "2336:   }",
          "2337:   ctx->changed = false;",
          "2340:   if (expunge && !(ctx->closing) && mutt_bit_isset(ctx->rights, MUTT_ACL_DELETE))",
          "2341:   {",
          "2342:     mutt_message(_(\"Expunging messages from server...\"));",
          "2344:     idata->reopen |= IMAP_EXPUNGE_EXPECTED;",
          "2345:     if (imap_exec(idata, \"EXPUNGE\", 0) != 0)",
          "2347:       idata->reopen &= ~IMAP_EXPUNGE_EXPECTED;",
          "2348:       imap_error(_(\"imap_sync_mailbox: EXPUNGE failed\"), idata->buf);",
          "2349:       rc = -1;",
          "2350:       goto out;",
          "2352:     idata->reopen &= ~IMAP_EXPUNGE_EXPECTED;",
          "2353:   }",
          "2355:   if (expunge && ctx->closing)",
          "2356:   {",
          "2357:     imap_exec(idata, \"CLOSE\", IMAP_CMD_QUEUE);",
          "2358:     idata->state = IMAP_AUTHENTICATED;",
          "2361:   if (option(OPT_MESSAGE_CACHE_CLEAN))",
          "2362:     imap_cache_clean(idata);",
          "2364:   rc = 0;",
          "2366: out:",
          "2367:   if (appendctx)",
          "2368:   {",
          "2369:     mx_fastclose_mailbox(appendctx);",
          "2370:     FREE(&appendctx);",
          "2371:   }",
          "2382: static int imap_edit_message_tags(struct Context *ctx, const char *tags, char *buf, size_t buflen)",
          "2384:   char *new = NULL;",
          "2385:   char *checker = NULL;",
          "2386:   struct ImapData *idata = (struct ImapData *) ctx->data;",
          "2389:   if (!imap_has_flag(&idata->flags, NULL))",
          "2390:   {",
          "2391:     mutt_error(_(\"IMAP server doesn't support custom flags\"));",
          "2392:     return -1;",
          "2396:   if (tags)",
          "2397:     strncpy(buf, tags, buflen);",
          "2399:   if (mutt_get_field(\"Tags: \", buf, buflen, 0) != 0)",
          "2400:     return -1;",
          "2415:   new = buf;",
          "2416:   checker = buf;",
          "2417:   SKIPWS(checker);",
          "2418:   while (*checker != '\\0')",
          "2420:     if (*checker < 32 || *checker >= 127 || // We allow space because it's the separator",
          "2435:       mutt_error(_(\"Invalid IMAP flags\"));",
          "2436:       mutt_sleep(2);",
          "2437:       return 0;",
          "2441:     while (*checker == ' ' && *(checker + 1) == ' ')",
          "2442:       checker++;",
          "2449:   mutt_remove_trailing_ws(new);",
          "2451:   if (mutt_strcmp(tags, buf) == 0)",
          "2452:     return 0;",
          "2453:   return 1;",
          "2474: static int imap_commit_message_tags(struct Context *ctx, struct Header *h, char *tags)",
          "2477:   struct Buffer *cmd = NULL;",
          "2478:   char uid[11];",
          "2482:   if (*tags == '\\0')",
          "2483:     tags = NULL;",
          "2485:   if (!mutt_bit_isset(idata->ctx->rights, MUTT_ACL_WRITE))",
          "2486:     return 0;",
          "2488:   snprintf(uid, sizeof(uid), \"%u\", HEADER_DATA(h)->uid);",
          "2491:   if (HEADER_DATA(h)->flags_remote)",
          "2493:     cmd = mutt_buffer_new();",
          "2494:     if (!cmd)",
          "2496:       mutt_debug(1, \"imap_commit_message_tags: unable to allocate buffer\\n\");",
          "2497:       return -1;",
          "2499:     cmd->dptr = cmd->data;",
          "2500:     mutt_buffer_addstr(cmd, \"UID STORE \");",
          "2501:     mutt_buffer_addstr(cmd, uid);",
          "2502:     mutt_buffer_addstr(cmd, \" -FLAGS.SILENT (\");",
          "2503:     mutt_buffer_addstr(cmd, HEADER_DATA(h)->flags_remote);",
          "2504:     mutt_buffer_addstr(cmd, \")\");",
          "2509:     if (imap_exec(idata, cmd->data, 0) != 0)",
          "2511:       mutt_buffer_free(&cmd);",
          "2512:       return -1;",
          "2515:     mutt_buffer_free(&cmd);",
          "2516:   }",
          "2519:   if (tags)",
          "2520:   {",
          "2521:     cmd = mutt_buffer_new();",
          "2522:     if (!cmd)",
          "2524:       mutt_debug(1, \"imap_commit_message_tags: fail to remove old flags\\n\");",
          "2525:       return -1;",
          "2527:     cmd->dptr = cmd->data;",
          "2528:     mutt_buffer_addstr(cmd, \"UID STORE \");",
          "2529:     mutt_buffer_addstr(cmd, uid);",
          "2530:     mutt_buffer_addstr(cmd, \" +FLAGS.SILENT (\");",
          "2531:     mutt_buffer_addstr(cmd, tags);",
          "2532:     mutt_buffer_addstr(cmd, \")\");",
          "2534:     if (imap_exec(idata, cmd->data, 0) != 0)",
          "2536:       mutt_debug(1, \"imap_commit_message_tags: fail to add new flags\\n\");",
          "2537:       mutt_buffer_free(&cmd);",
          "2538:       return -1;",
          "2541:     mutt_buffer_free(&cmd);",
          "2545:   mutt_debug(1, \"NEW TAGS: %d\\n\", tags);",
          "2546:   driver_tags_replace(&h->tags, tags);",
          "2547:   FREE(&HEADER_DATA(h)->flags_remote);",
          "2548:   HEADER_DATA(h)->flags_remote = driver_tags_get_with_hidden(&h->tags);",
          "2549:   return 0;",
          "",
          "---------------"
        ],
        "imap/imap.h||imap/imap.h": [
          "File: imap/imap.h -> imap/imap.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "56: int imap_complete(char *dest, size_t dlen, char *path);",
          "57: int imap_fast_trash(struct Context *ctx, char *dest);",
          "62: extern struct MxOps mx_imap_ops;",
          "",
          "[Removed Lines]",
          "59: void imap_allow_reopen(struct Context *ctx);",
          "60: void imap_disallow_reopen(struct Context *ctx);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "67: int imap_mailbox_rename(const char *mailbox);",
          "71: int imap_copy_messages(struct Context *ctx, struct Header *h, char *dest, int delete);",
          "",
          "[Removed Lines]",
          "70: int imap_append_message(struct Context *ctx, struct Message *msg);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "81: int imap_wait_keepalive(pid_t pid);",
          "82: void imap_keepalive(void);",
          "86: void imap_get_parent_path(char *output, const char *path, size_t olen);",
          "87: void imap_clean_path(char *path, size_t plen);",
          "",
          "[Removed Lines]",
          "84: int imap_account_match(const struct Account *a1, const struct Account *a2);",
          "85: void imap_get_parent(char *output, const char *mbox, size_t olen, char delim);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "imap/imap_private.h||imap/imap_private.h": [
          "File: imap/imap_private.h -> imap/imap_private.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "300: char *imap_set_flags(struct ImapData *idata, struct Header *h, char *s, int *server_changes);",
          "301: int imap_cache_del(struct ImapData *idata, struct Header *h);",
          "302: int imap_cache_clean(struct ImapData *idata);",
          "304: int imap_fetch_message(struct Context *ctx, struct Message *msg, int msgno);",
          "305: int imap_close_message(struct Context *ctx, struct Message *msg);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "303: int imap_append_message(struct Context *ctx, struct Message *msg);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "329: void imap_unquote_string(char *s);",
          "330: void imap_munge_mbox_name(struct ImapData *idata, char *dest, size_t dlen, const char *src);",
          "331: void imap_unmunge_mbox_name(struct ImapData *idata, char *s);",
          "334: void imap_utf_encode(struct ImapData *idata, char **s);",
          "335: void imap_utf_decode(struct ImapData *idata, char **s);",
          "337: #ifdef USE_HCACHE",
          "338: #define imap_hcache_keylen mutt_strlen",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "333: int imap_account_match(const struct Account *a1, const struct Account *a2);",
          "334: void imap_get_parent(char *output, const char *mbox, size_t olen, char delim);",
          "339: void imap_allow_reopen(struct Context *ctx);",
          "340: void imap_disallow_reopen(struct Context *ctx);",
          "",
          "---------------"
        ],
        "imap/message.c||imap/message.c": [
          "File: imap/message.c -> imap/message.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "478:   }",
          "479: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "484: static void imap_set_changed_flag(struct Context *ctx, struct Header *h,",
          "485:                                   int local_changes, int *server_changes, int flag_name,",
          "486:                                   int old_hd_flag, int new_hd_flag, int h_flag)",
          "487: {",
          "493:   if ((old_hd_flag != new_hd_flag) || (!local_changes))",
          "494:   {",
          "495:     if (new_hd_flag != h_flag)",
          "496:     {",
          "497:       if (server_changes)",
          "501:       if (!local_changes)",
          "502:         mutt_set_flag(ctx, h, flag_name, new_hd_flag);",
          "503:     }",
          "504:   }",
          "505: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1435:   }",
          "1436: }",
          "",
          "[Removed Lines]",
          "1441: static void imap_set_changed_flag(struct Context *ctx, struct Header *h,",
          "1442:                                   int local_changes, int *server_changes, int flag_name,",
          "1443:                                   int old_hd_flag, int new_hd_flag, int h_flag)",
          "1444: {",
          "1450:   if ((old_hd_flag != new_hd_flag) || (!local_changes))",
          "1451:   {",
          "1452:     if (new_hd_flag != h_flag)",
          "1453:     {",
          "1454:       if (server_changes)",
          "1458:       if (!local_changes)",
          "1459:         mutt_set_flag(ctx, h, flag_name, new_hd_flag);",
          "1460:     }",
          "1461:   }",
          "1462: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "8fe673fc8bf0f5fbf4ac3149ee46461641cb5d4b",
      "candidate_info": {
        "commit_hash": "8fe673fc8bf0f5fbf4ac3149ee46461641cb5d4b",
        "repo": "neomutt/neomutt",
        "commit_url": "https://github.com/neomutt/neomutt/commit/8fe673fc8bf0f5fbf4ac3149ee46461641cb5d4b",
        "files": [
          "imap/imap.c",
          "imap/imap_private.h",
          "imap/message.c"
        ],
        "message": "Create a uid hash for imap. (see #3905)\n\nThis hash will allow for more efficient UID SEARCH processing,\nreplacing a linear scan with a hash lookup.",
        "before_after_code_files": [
          "imap/imap.c||imap/imap.c",
          "imap/imap_private.h||imap/imap_private.h",
          "imap/message.c||imap/message.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "imap/imap.c||imap/imap.c"
          ],
          "candidate": [
            "imap/imap.c||imap/imap.c"
          ]
        }
      },
      "candidate_diff": {
        "imap/imap.c||imap/imap.c": [
          "File: imap/imap.c -> imap/imap.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "281:  FREE (&idata->cache[cacheno].path);",
          "282:       }",
          "284:       imap_free_header_data ((IMAP_HEADER_DATA**)&h->data);",
          "285:     }",
          "286:   }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "284:       int_hash_delete (idata->uid_hash, HEADER_DATA(h)->uid, h, NULL);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1392:     if (ctx->hdrs[i] && ctx->hdrs[i]->data)",
          "1393:       imap_free_header_data ((IMAP_HEADER_DATA**)&(ctx->hdrs[i]->data));",
          "1395:   for (i = 0; i < IMAP_CACHE_LEN; i++)",
          "1396:   {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1396:   hash_destroy (&idata->uid_hash, NULL);",
          "",
          "---------------"
        ],
        "imap/imap_private.h||imap/imap_private.h": [
          "File: imap/imap_private.h -> imap/imap_private.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "215:   unsigned char reopen;",
          "216:   unsigned int newMailCount;",
          "217:   IMAP_CACHE cache[IMAP_CACHE_LEN];",
          "218:   unsigned int uid_validity;",
          "219:   unsigned int uidnext;",
          "220:   body_cache_t *bcache;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "218:   HASH *uid_hash;",
          "",
          "---------------"
        ],
        "imap/message.c||imap/message.c": [
          "File: imap/message.c -> imap/message.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "52: static int msg_parse_fetch (IMAP_HEADER* h, char* s);",
          "53: static char* msg_parse_flags (IMAP_HEADER* h, char* s);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "55: static void imap_update_context (IMAP_DATA *idata, int oldmsgcount)",
          "56: {",
          "57:   CONTEXT *ctx;",
          "58:   HEADER *h;",
          "59:   int msgno;",
          "61:   ctx = idata->ctx;",
          "62:   if (!idata->uid_hash)",
          "63:     idata->uid_hash = int_hash_create (MAX (6 * ctx->msgcount / 5, 30));",
          "65:   for (msgno = oldmsgcount; msgno < ctx->msgcount; msgno++)",
          "66:   {",
          "67:     h = ctx->hdrs[msgno];",
          "68:     int_hash_insert (idata->uid_hash, HEADER_DATA(h)->uid, h, 0);",
          "69:   }",
          "70: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "377:   {",
          "378:     mx_alloc_memory(ctx);",
          "379:     mx_update_context (ctx, ctx->msgcount - oldmsgcount);",
          "380:   }",
          "382:   idata->reopen |= IMAP_REOPEN_ALLOW;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "397:     imap_update_context (idata, oldmsgcount);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "81d9f878efd40d91a683402973dfd1dbd9be30a6",
      "candidate_info": {
        "commit_hash": "81d9f878efd40d91a683402973dfd1dbd9be30a6",
        "repo": "neomutt/neomutt",
        "commit_url": "https://github.com/neomutt/neomutt/commit/81d9f878efd40d91a683402973dfd1dbd9be30a6",
        "files": [
          "imap/imap.c",
          "imap/imap_private.h",
          "imap/message.c",
          "imap/message.h"
        ],
        "message": "replace 'IMAP_HEADER_DATA' with 'struct ImapHeaderData'",
        "before_after_code_files": [
          "imap/imap.c||imap/imap.c",
          "imap/imap_private.h||imap/imap_private.h",
          "imap/message.c||imap/message.c",
          "imap/message.h||imap/message.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "imap/imap.c||imap/imap.c"
          ],
          "candidate": [
            "imap/imap.c||imap/imap.c"
          ]
        }
      },
      "candidate_diff": {
        "imap/imap.c||imap/imap.c": [
          "File: imap/imap.c -> imap/imap.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "278:       int_hash_delete(idata->uid_hash, HEADER_DATA(h)->uid, h, NULL);",
          "281:     }",
          "282:   }",
          "",
          "[Removed Lines]",
          "280:       imap_free_header_data((IMAP_HEADER_DATA **) &h->data);",
          "",
          "[Added Lines]",
          "280:       imap_free_header_data((struct ImapHeaderData **) &h->data);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1032: static bool compare_flags(struct Header *h)",
          "1033: {",
          "1036:   if (h->read != hd->read)",
          "1037:     return true;",
          "",
          "[Removed Lines]",
          "1034:   IMAP_HEADER_DATA *hd = (IMAP_HEADER_DATA *) h->data;",
          "",
          "[Added Lines]",
          "1034:   struct ImapHeaderData *hd = (struct ImapHeaderData *) h->data;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1375:   for (i = 0; i < ctx->msgcount; i++)",
          "1377:     if (ctx->hdrs[i] && ctx->hdrs[i]->data)",
          "1379:   hash_destroy(&idata->uid_hash, NULL);",
          "1381:   for (i = 0; i < IMAP_CACHE_LEN; i++)",
          "",
          "[Removed Lines]",
          "1378:       imap_free_header_data((IMAP_HEADER_DATA **) &(ctx->hdrs[i]->data));",
          "",
          "[Added Lines]",
          "1378:       imap_free_header_data((struct ImapHeaderData **) &(ctx->hdrs[i]->data));",
          "",
          "---------------"
        ],
        "imap/imap_private.h||imap/imap_private.h": [
          "File: imap/imap_private.h -> imap/imap_private.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "261: void imap_add_keywords(char *s, struct Header *keywords, struct List *mailbox_flags, size_t slen);",
          "263: int imap_read_headers(IMAP_DATA *idata, int msgbegin, int msgend);",
          "264: char *imap_set_flags(IMAP_DATA *idata, struct Header *h, char *s);",
          "265: int imap_cache_del(IMAP_DATA *idata, struct Header *h);",
          "",
          "[Removed Lines]",
          "262: void imap_free_header_data(IMAP_HEADER_DATA **data);",
          "",
          "[Added Lines]",
          "262: void imap_free_header_data(struct ImapHeaderData **data);",
          "",
          "---------------"
        ],
        "imap/message.c||imap/message.c": [
          "File: imap/message.c -> imap/message.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "123: static char *msg_parse_flags(IMAP_HEADER *h, char *s)",
          "124: {",
          "128:   if (ascii_strncasecmp(\"FLAGS\", s, 5) != 0)",
          "",
          "[Removed Lines]",
          "125:   IMAP_HEADER_DATA *hd = h->data;",
          "",
          "[Added Lines]",
          "125:   struct ImapHeaderData *hd = h->data;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "447:       mutt_progress_update(&progress, msgno + 1, -1);",
          "449:       memset(&h, 0, sizeof(h));",
          "451:       do",
          "452:       {",
          "453:         mfhrc = 0;",
          "",
          "[Removed Lines]",
          "450:       h.data = safe_calloc(1, sizeof(IMAP_HEADER_DATA));",
          "",
          "[Added Lines]",
          "450:       h.data = safe_calloc(1, sizeof(struct ImapHeaderData));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "545:     rewind(fp);",
          "546:     memset(&h, 0, sizeof(h));",
          "",
          "[Removed Lines]",
          "547:     h.data = safe_calloc(1, sizeof(IMAP_HEADER_DATA));",
          "",
          "[Added Lines]",
          "547:     h.data = safe_calloc(1, sizeof(struct ImapHeaderData));",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1262: }",
          "1266: {",
          "1267:   if (*data)",
          "1268:   {",
          "",
          "[Removed Lines]",
          "1265: void imap_free_header_data(IMAP_HEADER_DATA **data)",
          "",
          "[Added Lines]",
          "1265: void imap_free_header_data(struct ImapHeaderData **data)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1278: {",
          "1279:   struct Context *ctx = idata->ctx;",
          "1280:   IMAP_HEADER newh;",
          "1282:   bool readonly;",
          "1284:   memset(&newh, 0, sizeof(newh));",
          "",
          "[Removed Lines]",
          "1281:   IMAP_HEADER_DATA *hd = NULL;",
          "",
          "[Added Lines]",
          "1281:   struct ImapHeaderData *hd = NULL;",
          "",
          "---------------"
        ],
        "imap/message.h||imap/message.h": [
          "File: imap/message.h -> imap/message.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "27: {",
          "29:   bool read : 1;",
          "",
          "[Removed Lines]",
          "26: typedef struct imap_header_data",
          "",
          "[Added Lines]",
          "26: struct ImapHeaderData",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "39:   struct List *keywords;",
          "42: typedef struct",
          "43: {",
          "44:   unsigned int sid;",
          "48:   time_t received;",
          "49:   long content_length;",
          "50: } IMAP_HEADER;",
          "",
          "[Removed Lines]",
          "40: } IMAP_HEADER_DATA;",
          "46:   IMAP_HEADER_DATA *data;",
          "53: #define HEADER_DATA(ph) ((IMAP_HEADER_DATA *) ((ph)->data))",
          "",
          "[Added Lines]",
          "40: };",
          "46:   struct ImapHeaderData *data;",
          "53: #define HEADER_DATA(ph) ((struct ImapHeaderData *) ((ph)->data))",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "9b004d941caef32b770b09394bd4860b97e6c25d",
      "candidate_info": {
        "commit_hash": "9b004d941caef32b770b09394bd4860b97e6c25d",
        "repo": "neomutt/neomutt",
        "commit_url": "https://github.com/neomutt/neomutt/commit/9b004d941caef32b770b09394bd4860b97e6c25d",
        "files": [
          "imap/auth_plain.c",
          "imap/imap.c",
          "newsrc.c",
          "nntp.c",
          "pattern.c",
          "send.c"
        ],
        "message": "clang-format",
        "before_after_code_files": [
          "imap/auth_plain.c||imap/auth_plain.c",
          "imap/imap.c||imap/imap.c",
          "newsrc.c||newsrc.c",
          "nntp.c||nntp.c",
          "pattern.c||pattern.c",
          "send.c||send.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "imap/imap.c||imap/imap.c"
          ],
          "candidate": [
            "imap/imap.c||imap/imap.c"
          ]
        }
      },
      "candidate_diff": {
        "imap/auth_plain.c||imap/auth_plain.c": [
          "File: imap/auth_plain.c -> imap/auth_plain.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "77:     }",
          "78:     if (rc == IMAP_CMD_RESPOND)",
          "79:     {",
          "81:       mutt_socket_send(idata->conn, buf + sizeof(auth_plain_cmd));",
          "82:     }",
          "83:   }",
          "",
          "[Removed Lines]",
          "80:       mutt_str_strcat(buf + sizeof(auth_plain_cmd), sizeof(buf) - sizeof(auth_plain_cmd), \"\\r\\n\");",
          "",
          "[Added Lines]",
          "80:       mutt_str_strcat(buf + sizeof(auth_plain_cmd),",
          "81:                       sizeof(buf) - sizeof(auth_plain_cmd), \"\\r\\n\");",
          "",
          "---------------"
        ],
        "imap/imap.c||imap/imap.c": [
          "File: imap/imap.c -> imap/imap.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1730:     mutt_buffer_init(&err);",
          "1731:     err.data = errstr;",
          "1732:     err.dsize = sizeof(errstr);",
          "1735:     if (mutt_parse_rc_line(mbox, &token, &err))",
          "1736:       mutt_debug(1, \"Error adding subscribed mailbox: %s\\n\", errstr);",
          "1737:     FREE(&token.data);",
          "",
          "[Removed Lines]",
          "1733:  len = snprintf(mbox, sizeof(mbox), \"%smailboxes \", subscribe ? \"\" : \"un\");",
          "1734:  imap_quote_string(mbox + len, sizeof(mbox) - len, path, true);",
          "",
          "[Added Lines]",
          "1733:     len = snprintf(mbox, sizeof(mbox), \"%smailboxes \", subscribe ? \"\" : \"un\");",
          "1734:     imap_quote_string(mbox + len, sizeof(mbox) - len, path, true);",
          "",
          "---------------"
        ],
        "newsrc.c||newsrc.c": [
          "File: newsrc.c -> newsrc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "601:     return 0;",
          "605:   {",
          "606:     mutt_debug(4, \"Cannot parse server line: %s\\n\", line);",
          "607:     return 0;",
          "",
          "[Removed Lines]",
          "604:   if (sscanf(line, \"%1023s \" ANUM \" \" ANUM \" %c %8191[^\\n]\", group, &last, &first, &mod, desc) < 4)",
          "",
          "[Added Lines]",
          "604:   if (sscanf(line, \"%1023s \" ANUM \" \" ANUM \" %c %8191[^\\n]\", group, &last,",
          "605:              &first, &mod, desc) < 4)",
          "",
          "---------------"
        ],
        "nntp.c||nntp.c": [
          "File: nntp.c -> nntp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1289:   fc.restore = restore;",
          "1290:   fc.messages = mutt_mem_calloc(last - first + 1, sizeof(unsigned char));",
          "1291:   if (fc.messages == NULL)",
          "1293: #ifdef USE_HCACHE",
          "1294:   fc.hc = hc;",
          "1295: #endif",
          "",
          "[Removed Lines]",
          "1292:    return -1;",
          "",
          "[Added Lines]",
          "1292:     return -1;",
          "",
          "---------------"
        ],
        "pattern.c||pattern.c": [
          "File: pattern.c -> pattern.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1885:     case MUTT_SENDER:",
          "1886:       if (!h->env)",
          "1887:         return 0;",
          "1890:     case MUTT_FROM:",
          "1891:       if (!h->env)",
          "1892:         return 0;",
          "1895:     case MUTT_TO:",
          "1896:       if (!h->env)",
          "1897:         return 0;",
          "",
          "[Removed Lines]",
          "1888:       return (pat->not ^ match_addrlist(pat, (flags & MUTT_MATCH_FULL_ADDRESS), 1,",
          "1889:                                         h->env->sender));",
          "1893:       return (pat->not ^",
          "1894:               match_addrlist(pat, (flags & MUTT_MATCH_FULL_ADDRESS), 1, h->env->from));",
          "",
          "[Added Lines]",
          "1888:       return (pat->not ^ match_addrlist(pat, (flags & MUTT_MATCH_FULL_ADDRESS),",
          "1889:                                         1, h->env->sender));",
          "1893:       return (pat->not ^ match_addrlist(pat, (flags & MUTT_MATCH_FULL_ADDRESS),",
          "1894:                                         1, h->env->from));",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1924:     case MUTT_ADDRESS:",
          "1925:       if (!h->env)",
          "1926:         return 0;",
          "1929:                                         h->env->to, h->env->cc));",
          "1930:     case MUTT_RECIPIENT:",
          "1931:       if (!h->env)",
          "1932:         return 0;",
          "1936:       if (!h->env)",
          "1937:         return 0;",
          "",
          "[Removed Lines]",
          "1927:       return (pat->not ^ match_addrlist(pat, (flags & MUTT_MATCH_FULL_ADDRESS), 4,",
          "1928:                                         h->env->from, h->env->sender,",
          "1933:       return (pat->not ^ match_addrlist(pat, (flags & MUTT_MATCH_FULL_ADDRESS), 2,",
          "1934:                                         h->env->to, h->env->cc));",
          "",
          "[Added Lines]",
          "1927:       return (pat->not ^ match_addrlist(pat, (flags & MUTT_MATCH_FULL_ADDRESS),",
          "1928:                                         4, h->env->from, h->env->sender,",
          "1933:       return (pat->not ^ match_addrlist(pat, (flags & MUTT_MATCH_FULL_ADDRESS),",
          "1934:                                         2, h->env->to, h->env->cc));",
          "",
          "---------------"
        ],
        "send.c||send.c": [
          "File: send.c -> send.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1077:   if (From)",
          "1078:     addr = mutt_addr_copy(From);",
          "1080:     addr = mutt_addr_new();",
          "1081:     if (UseDomain)",
          "1082:     {",
          "",
          "[Removed Lines]",
          "1079:   else {",
          "",
          "[Added Lines]",
          "1079:   else",
          "1080:   {",
          "",
          "---------------"
        ]
      }
    }
  ]
}
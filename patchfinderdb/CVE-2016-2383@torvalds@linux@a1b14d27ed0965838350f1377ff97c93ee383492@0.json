{
  "cve_id": "CVE-2016-2383",
  "cve_desc": "The adjust_branches function in kernel/bpf/verifier.c in the Linux kernel before 4.5 does not consider the delta in the backward-jump case, which allows local users to obtain sensitive information from kernel memory by creating a packet filter and then loading crafted BPF instructions.",
  "repo": "torvalds/linux",
  "patch_hash": "a1b14d27ed0965838350f1377ff97c93ee383492",
  "patch_info": {
    "commit_hash": "a1b14d27ed0965838350f1377ff97c93ee383492",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/a1b14d27ed0965838350f1377ff97c93ee383492",
    "files": [
      "kernel/bpf/verifier.c"
    ],
    "message": "bpf: fix branch offset adjustment on backjumps after patching ctx expansion\n\nWhen ctx access is used, the kernel often needs to expand/rewrite\ninstructions, so after that patching, branch offsets have to be\nadjusted for both forward and backward jumps in the new eBPF program,\nbut for backward jumps it fails to account the delta. Meaning, for\nexample, if the expansion happens exactly on the insn that sits at\nthe jump target, it doesn't fix up the back jump offset.\n\nAnalysis on what the check in adjust_branches() is currently doing:\n\n  /* adjust offset of jmps if necessary */\n  if (i < pos && i + insn->off + 1 > pos)\n    insn->off += delta;\n  else if (i > pos && i + insn->off + 1 < pos)\n    insn->off -= delta;\n\nFirst condition (forward jumps):\n\n  Before:                         After:\n\n  insns[0]                        insns[0]\n  insns[1] <--- i/insn            insns[1] <--- i/insn\n  insns[2] <--- pos               insns[P] <--- pos\n  insns[3]                        insns[P]  `------| delta\n  insns[4] <--- target_X          insns[P]   `-----|\n  insns[5]                        insns[3]\n                                  insns[4] <--- target_X\n                                  insns[5]\n\nFirst case is if we cross pos-boundary and the jump instruction was\nbefore pos. This is handeled correctly. I.e. if i == pos, then this\nwould mean our jump that we currently check was the patchlet itself\nthat we just injected. Since such patchlets are self-contained and\nhave no awareness of any insns before or after the patched one, the\ndelta is correctly not adjusted. Also, for the second condition in\ncase of i + insn->off + 1 == pos, means we jump to that newly patched\ninstruction, so no offset adjustment are needed. That part is correct.\n\nSecond condition (backward jumps):\n\n  Before:                         After:\n\n  insns[0]                        insns[0]\n  insns[1] <--- target_X          insns[1] <--- target_X\n  insns[2] <--- pos <-- target_Y  insns[P] <--- pos <-- target_Y\n  insns[3]                        insns[P]  `------| delta\n  insns[4] <--- i/insn            insns[P]   `-----|\n  insns[5]                        insns[3]\n                                  insns[4] <--- i/insn\n                                  insns[5]\n\nSecond interesting case is where we cross pos-boundary and the jump\ninstruction was after pos. Backward jump with i == pos would be\nimpossible and pose a bug somewhere in the patchlet, so the first\ncondition checking i > pos is okay only by itself. However, i +\ninsn->off + 1 < pos does not always work as intended to trigger the\nadjustment. It works when jump targets would be far off where the\ndelta wouldn't matter. But, for example, where the fixed insn->off\nbefore pointed to pos (target_Y), it now points to pos + delta, so\nthat additional room needs to be taken into account for the check.\nThis means that i) both tests here need to be adjusted into pos + delta,\nand ii) for the second condition, the test needs to be <= as pos\nitself can be a target in the backjump, too.\n\nFixes: 9bac3d6d548e (\"bpf: allow extended BPF programs access skb fields\")\nSigned-off-by: Daniel Borkmann <daniel@iogearbox.net>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
    "before_after_code_files": [
      "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
    ]
  },
  "patch_diff": {
    "kernel/bpf/verifier.c||kernel/bpf/verifier.c": [
      "File: kernel/bpf/verifier.c -> kernel/bpf/verifier.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "2083:   if (i < pos && i + insn->off + 1 > pos)",
      "2084:    insn->off += delta;",
      "2086:    insn->off -= delta;",
      "2087:  }",
      "2088: }",
      "",
      "[Removed Lines]",
      "2085:   else if (i > pos && i + insn->off + 1 < pos)",
      "",
      "[Added Lines]",
      "2085:   else if (i > pos + delta && i + insn->off + 1 <= pos + delta)",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "9bac3d6d548e5cc925570b263f35b70a00a00ffd",
      "candidate_info": {
        "commit_hash": "9bac3d6d548e5cc925570b263f35b70a00a00ffd",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/9bac3d6d548e5cc925570b263f35b70a00a00ffd",
        "files": [
          "include/linux/bpf.h",
          "include/uapi/linux/bpf.h",
          "kernel/bpf/syscall.c",
          "kernel/bpf/verifier.c",
          "net/core/filter.c"
        ],
        "message": "bpf: allow extended BPF programs access skb fields\n\nintroduce user accessible mirror of in-kernel 'struct sk_buff':\nstruct __sk_buff {\n    __u32 len;\n    __u32 pkt_type;\n    __u32 mark;\n    __u32 queue_mapping;\n};\n\nbpf programs can do:\n\nint bpf_prog(struct __sk_buff *skb)\n{\n    __u32 var = skb->pkt_type;\n\nwhich will be compiled to bpf assembler as:\n\ndst_reg = *(u32 *)(src_reg + 4) // 4 == offsetof(struct __sk_buff, pkt_type)\n\nbpf verifier will check validity of access and will convert it to:\n\ndst_reg = *(u8 *)(src_reg + offsetof(struct sk_buff, __pkt_type_offset))\ndst_reg &= 7\n\nsince skb->pkt_type is a bitfield.\n\nSigned-off-by: Alexei Starovoitov <ast@plumgrid.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "include/linux/bpf.h||include/linux/bpf.h",
          "include/uapi/linux/bpf.h||include/uapi/linux/bpf.h",
          "kernel/bpf/syscall.c||kernel/bpf/syscall.c",
          "kernel/bpf/verifier.c||kernel/bpf/verifier.c",
          "net/core/filter.c||net/core/filter.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
          ],
          "candidate": [
            "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
          ]
        }
      },
      "candidate_diff": {
        "include/linux/bpf.h||include/linux/bpf.h": [
          "File: include/linux/bpf.h -> include/linux/bpf.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "105:  bool (*is_valid_access)(int off, int size, enum bpf_access_type type);",
          "106: };",
          "108: struct bpf_prog_type_list {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "107:  u32 (*convert_ctx_access)(int dst_reg, int src_reg, int ctx_off,",
          "108:       struct bpf_insn *insn);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "133: void bpf_map_put(struct bpf_map *map);",
          "137: #else",
          "138: static inline void bpf_register_prog_type(struct bpf_prog_type_list *tl)",
          "139: {",
          "",
          "[Removed Lines]",
          "136: int bpf_check(struct bpf_prog *fp, union bpf_attr *attr);",
          "",
          "[Added Lines]",
          "139: int bpf_check(struct bpf_prog **fp, union bpf_attr *attr);",
          "",
          "---------------"
        ],
        "include/uapi/linux/bpf.h||include/uapi/linux/bpf.h": [
          "File: include/uapi/linux/bpf.h -> include/uapi/linux/bpf.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "170:  __BPF_FUNC_MAX_ID,",
          "171: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "176: struct __sk_buff {",
          "177:  __u32 len;",
          "178:  __u32 pkt_type;",
          "179:  __u32 mark;",
          "180:  __u32 queue_mapping;",
          "181: };",
          "",
          "---------------"
        ],
        "kernel/bpf/syscall.c||kernel/bpf/syscall.c": [
          "File: kernel/bpf/syscall.c -> kernel/bpf/syscall.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "519:   goto free_prog;",
          "523:  if (err < 0)",
          "524:   goto free_used_maps;",
          "",
          "[Removed Lines]",
          "522:  err = bpf_check(prog, attr);",
          "",
          "[Added Lines]",
          "522:  err = bpf_check(&prog, attr);",
          "",
          "---------------"
        ],
        "kernel/bpf/verifier.c||kernel/bpf/verifier.c": [
          "File: kernel/bpf/verifier.c -> kernel/bpf/verifier.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1620:     return err;",
          "1622:   } else if (class == BPF_LDX) {",
          "1629:    err = check_reg_arg(regs, insn->src_reg, SRC_OP);",
          "1630:    if (err)",
          "",
          "[Removed Lines]",
          "1623:    if (BPF_MODE(insn->code) != BPF_MEM ||",
          "1624:        insn->imm != 0) {",
          "1625:     verbose(\"BPF_LDX uses reserved fields\\n\");",
          "1626:     return -EINVAL;",
          "1627:    }",
          "",
          "[Added Lines]",
          "1623:    enum bpf_reg_type src_reg_type;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1643:    if (err)",
          "1644:     return err;",
          "1646:   } else if (class == BPF_STX) {",
          "1647:    if (BPF_MODE(insn->code) == BPF_XADD) {",
          "1648:     err = check_xadd(env, insn);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1645:    src_reg_type = regs[insn->src_reg].type;",
          "1647:    if (insn->imm == 0 && BPF_SIZE(insn->code) == BPF_W) {",
          "1652:     insn->imm = src_reg_type;",
          "1654:    } else if (src_reg_type != insn->imm &&",
          "1655:        (src_reg_type == PTR_TO_CTX ||",
          "1656:         insn->imm == PTR_TO_CTX)) {",
          "1664:     verbose(\"same insn cannot be used with different pointers\\n\");",
          "1665:     return -EINVAL;",
          "1666:    }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1790:  int i, j;",
          "1792:  for (i = 0; i < insn_cnt; i++, insn++) {",
          "1793:   if (insn[0].code == (BPF_LD | BPF_IMM | BPF_DW)) {",
          "1794:    struct bpf_map *map;",
          "1795:    struct fd f;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1815:   if (BPF_CLASS(insn->code) == BPF_LDX &&",
          "1816:       (BPF_MODE(insn->code) != BPF_MEM ||",
          "1817:        insn->imm != 0)) {",
          "1818:    verbose(\"BPF_LDX uses reserved fields\\n\");",
          "1819:    return -EINVAL;",
          "1820:   }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1881:    insn->src_reg = 0;",
          "1882: }",
          "1884: static void free_states(struct verifier_env *env)",
          "1885: {",
          "1886:  struct verifier_state_list *sl, *sln;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1913: static void adjust_branches(struct bpf_prog *prog, int pos, int delta)",
          "1914: {",
          "1915:  struct bpf_insn *insn = prog->insnsi;",
          "1916:  int insn_cnt = prog->len;",
          "1917:  int i;",
          "1919:  for (i = 0; i < insn_cnt; i++, insn++) {",
          "1920:   if (BPF_CLASS(insn->code) != BPF_JMP ||",
          "1921:       BPF_OP(insn->code) == BPF_CALL ||",
          "1922:       BPF_OP(insn->code) == BPF_EXIT)",
          "1923:    continue;",
          "1926:   if (i < pos && i + insn->off + 1 > pos)",
          "1927:    insn->off += delta;",
          "1928:   else if (i > pos && i + insn->off + 1 < pos)",
          "1929:    insn->off -= delta;",
          "1930:  }",
          "1931: }",
          "1936: static int convert_ctx_accesses(struct verifier_env *env)",
          "1937: {",
          "1938:  struct bpf_insn *insn = env->prog->insnsi;",
          "1939:  int insn_cnt = env->prog->len;",
          "1940:  struct bpf_insn insn_buf[16];",
          "1941:  struct bpf_prog *new_prog;",
          "1942:  u32 cnt;",
          "1943:  int i;",
          "1945:  if (!env->prog->aux->ops->convert_ctx_access)",
          "1946:   return 0;",
          "1948:  for (i = 0; i < insn_cnt; i++, insn++) {",
          "1949:   if (insn->code != (BPF_LDX | BPF_MEM | BPF_W))",
          "1950:    continue;",
          "1952:   if (insn->imm != PTR_TO_CTX) {",
          "1954:    insn->imm = 0;",
          "1955:    continue;",
          "1956:   }",
          "1958:   cnt = env->prog->aux->ops->",
          "1959:    convert_ctx_access(insn->dst_reg, insn->src_reg,",
          "1960:         insn->off, insn_buf);",
          "1961:   if (cnt == 0 || cnt >= ARRAY_SIZE(insn_buf)) {",
          "1962:    verbose(\"bpf verifier is misconfigured\\n\");",
          "1963:    return -EINVAL;",
          "1964:   }",
          "1966:   if (cnt == 1) {",
          "1967:    memcpy(insn, insn_buf, sizeof(*insn));",
          "1968:    continue;",
          "1969:   }",
          "1972:   insn_cnt += cnt - 1;",
          "1973:   new_prog = bpf_prog_realloc(env->prog,",
          "1974:          bpf_prog_size(insn_cnt),",
          "1975:          GFP_USER);",
          "1976:   if (!new_prog)",
          "1977:    return -ENOMEM;",
          "1979:   new_prog->len = insn_cnt;",
          "1981:   memmove(new_prog->insnsi + i + cnt, new_prog->insns + i + 1,",
          "1982:    sizeof(*insn) * (insn_cnt - i - cnt));",
          "1985:   memcpy(new_prog->insnsi + i, insn_buf, sizeof(*insn) * cnt);",
          "1988:   adjust_branches(new_prog, i, cnt - 1);",
          "1991:   env->prog = new_prog;",
          "1992:   insn = new_prog->insnsi + i + cnt - 1;",
          "1993:   i += cnt - 1;",
          "1994:  }",
          "1996:  return 0;",
          "1997: }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1903:  kfree(env->explored_states);",
          "1904: }",
          "1907: {",
          "1908:  char __user *log_ubuf = NULL;",
          "1909:  struct verifier_env *env;",
          "1910:  int ret = -EINVAL;",
          "1913:   return -E2BIG;",
          "",
          "[Removed Lines]",
          "1906: int bpf_check(struct bpf_prog *prog, union bpf_attr *attr)",
          "1912:  if (prog->len <= 0 || prog->len > BPF_MAXINSNS)",
          "",
          "[Added Lines]",
          "2021: int bpf_check(struct bpf_prog **prog, union bpf_attr *attr)",
          "2027:  if ((*prog)->len <= 0 || (*prog)->len > BPF_MAXINSNS)",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1919:  if (!env)",
          "1920:   return -ENOMEM;",
          "1925:  mutex_lock(&bpf_verifier_lock);",
          "",
          "[Removed Lines]",
          "1922:  env->prog = prog;",
          "",
          "[Added Lines]",
          "2037:  env->prog = *prog;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1951:  if (ret < 0)",
          "1952:   goto skip_full_check;",
          "1955:            sizeof(struct verifier_state_list *),",
          "1956:            GFP_USER);",
          "1957:  ret = -ENOMEM;",
          "",
          "[Removed Lines]",
          "1954:  env->explored_states = kcalloc(prog->len,",
          "",
          "[Added Lines]",
          "2069:  env->explored_states = kcalloc(env->prog->len,",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1968:  while (pop_stack(env, NULL) >= 0);",
          "1969:  free_states(env);",
          "1971:  if (log_level && log_len >= log_size - 1) {",
          "1972:   BUG_ON(log_len >= log_size);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2086:  if (ret == 0)",
          "2088:   ret = convert_ctx_accesses(env);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1984:  if (ret == 0 && env->used_map_cnt) {",
          "1991:    ret = -ENOMEM;",
          "1992:    goto free_log_buf;",
          "1993:   }",
          "1996:          sizeof(env->used_maps[0]) * env->used_map_cnt);",
          "",
          "[Removed Lines]",
          "1986:   prog->aux->used_maps = kmalloc_array(env->used_map_cnt,",
          "1987:            sizeof(env->used_maps[0]),",
          "1988:            GFP_KERNEL);",
          "1990:   if (!prog->aux->used_maps) {",
          "1995:   memcpy(prog->aux->used_maps, env->used_maps,",
          "1997:   prog->aux->used_map_cnt = env->used_map_cnt;",
          "",
          "[Added Lines]",
          "2105:   env->prog->aux->used_maps = kmalloc_array(env->used_map_cnt,",
          "2106:          sizeof(env->used_maps[0]),",
          "2107:          GFP_KERNEL);",
          "2109:   if (!env->prog->aux->used_maps) {",
          "2114:   memcpy(env->prog->aux->used_maps, env->used_maps,",
          "2116:   env->prog->aux->used_map_cnt = env->used_map_cnt;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "2006:  if (log_level)",
          "2007:   vfree(log_buf);",
          "2008: free_env:",
          "2013:   release_maps(env);",
          "2014:  kfree(env);",
          "2015:  mutex_unlock(&bpf_verifier_lock);",
          "2016:  return ret;",
          "",
          "[Removed Lines]",
          "2009:  if (!prog->aux->used_maps)",
          "",
          "[Added Lines]",
          "2128:  if (!env->prog->aux->used_maps)",
          "",
          "---------------"
        ],
        "net/core/filter.c||net/core/filter.c": [
          "File: net/core/filter.c -> net/core/filter.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "150:  return prandom_u32();",
          "151: }",
          "153: static bool convert_bpf_extensions(struct sock_filter *fp,",
          "154:        struct bpf_insn **insnp)",
          "155: {",
          "156:  struct bpf_insn *insn = *insnp;",
          "158:  switch (fp->k) {",
          "159:  case SKF_AD_OFF + SKF_AD_PROTOCOL:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "153: static u32 convert_skb_access(int skb_field, int dst_reg, int src_reg,",
          "154:          struct bpf_insn *insn_buf)",
          "155: {",
          "156:  struct bpf_insn *insn = insn_buf;",
          "158:  switch (skb_field) {",
          "159:  case SKF_AD_MARK:",
          "160:   BUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, mark) != 4);",
          "163:           offsetof(struct sk_buff, mark));",
          "164:   break;",
          "166:  case SKF_AD_PKTTYPE:",
          "169: #ifdef __BIG_ENDIAN_BITFIELD",
          "171: #endif",
          "172:   break;",
          "174:  case SKF_AD_QUEUE:",
          "175:   BUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, queue_mapping) != 2);",
          "178:           offsetof(struct sk_buff, queue_mapping));",
          "179:   break;",
          "180:  }",
          "182:  return insn - insn_buf;",
          "183: }",
          "189:  u32 cnt;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "167:   break;",
          "169:  case SKF_AD_OFF + SKF_AD_PKTTYPE:",
          "177:   break;",
          "179:  case SKF_AD_OFF + SKF_AD_IFINDEX:",
          "",
          "[Removed Lines]",
          "171:           PKT_TYPE_OFFSET());",
          "173: #ifdef __BIG_ENDIAN_BITFIELD",
          "174:   insn++;",
          "176: #endif",
          "",
          "[Added Lines]",
          "203:   cnt = convert_skb_access(SKF_AD_PKTTYPE, BPF_REG_A, BPF_REG_CTX, insn);",
          "204:   insn += cnt - 1;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "197:   break;",
          "199:  case SKF_AD_OFF + SKF_AD_MARK:",
          "204:   break;",
          "206:  case SKF_AD_OFF + SKF_AD_RXHASH:",
          "",
          "[Removed Lines]",
          "200:   BUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, mark) != 4);",
          "203:         offsetof(struct sk_buff, mark));",
          "",
          "[Added Lines]",
          "228:   cnt = convert_skb_access(SKF_AD_MARK, BPF_REG_A, BPF_REG_CTX, insn);",
          "229:   insn += cnt - 1;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "211:   break;",
          "213:  case SKF_AD_OFF + SKF_AD_QUEUE:",
          "218:   break;",
          "220:  case SKF_AD_OFF + SKF_AD_VLAN_TAG:",
          "",
          "[Removed Lines]",
          "214:   BUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, queue_mapping) != 2);",
          "217:         offsetof(struct sk_buff, queue_mapping));",
          "",
          "[Added Lines]",
          "240:   cnt = convert_skb_access(SKF_AD_QUEUE, BPF_REG_A, BPF_REG_CTX, insn);",
          "241:   insn += cnt - 1;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1151: static bool sk_filter_is_valid_access(int off, int size,",
          "1152:           enum bpf_access_type type)",
          "1153: {",
          "1156: }",
          "1158: static const struct bpf_verifier_ops sk_filter_ops = {",
          "1159:  .get_func_proto = sk_filter_func_proto,",
          "1160:  .is_valid_access = sk_filter_is_valid_access,",
          "1161: };",
          "1163: static struct bpf_prog_type_list sk_filter_type __read_mostly = {",
          "",
          "[Removed Lines]",
          "1155:  return false;",
          "",
          "[Added Lines]",
          "1179:  if (type != BPF_READ)",
          "1180:   return false;",
          "1183:  if (off < 0 || off >= sizeof(struct __sk_buff))",
          "1184:   return false;",
          "1187:  if (off % size != 0)",
          "1188:   return false;",
          "1191:  if (size != 4)",
          "1192:   return false;",
          "1194:  return true;",
          "1195: }",
          "1197: static u32 sk_filter_convert_ctx_access(int dst_reg, int src_reg, int ctx_off,",
          "1198:      struct bpf_insn *insn_buf)",
          "1199: {",
          "1200:  struct bpf_insn *insn = insn_buf;",
          "1202:  switch (ctx_off) {",
          "1203:  case offsetof(struct __sk_buff, len):",
          "1204:   BUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, len) != 4);",
          "1207:           offsetof(struct sk_buff, len));",
          "1208:   break;",
          "1210:  case offsetof(struct __sk_buff, mark):",
          "1211:   return convert_skb_access(SKF_AD_MARK, dst_reg, src_reg, insn);",
          "1213:  case offsetof(struct __sk_buff, pkt_type):",
          "1214:   return convert_skb_access(SKF_AD_PKTTYPE, dst_reg, src_reg, insn);",
          "1216:  case offsetof(struct __sk_buff, queue_mapping):",
          "1217:   return convert_skb_access(SKF_AD_QUEUE, dst_reg, src_reg, insn);",
          "1218:  }",
          "1220:  return insn - insn_buf;",
          "1226:  .convert_ctx_access = sk_filter_convert_ctx_access,",
          "",
          "---------------"
        ]
      }
    }
  ]
}
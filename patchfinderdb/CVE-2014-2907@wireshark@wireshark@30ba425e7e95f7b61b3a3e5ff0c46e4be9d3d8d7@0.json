{
  "cve_id": "CVE-2014-2907",
  "cve_desc": "The srtp_add_address function in epan/dissectors/packet-rtp.c in the RTP dissector in Wireshark 1.10.x before 1.10.7 does not properly update SRTP conversation data, which allows remote attackers to cause a denial of service (application crash) via a crafted packet.",
  "repo": "wireshark/wireshark",
  "patch_hash": "30ba425e7e95f7b61b3a3e5ff0c46e4be9d3d8d7",
  "patch_info": {
    "commit_hash": "30ba425e7e95f7b61b3a3e5ff0c46e4be9d3d8d7",
    "repo": "wireshark/wireshark",
    "commit_url": "https://github.com/wireshark/wireshark/commit/30ba425e7e95f7b61b3a3e5ff0c46e4be9d3d8d7",
    "files": [
      "epan/dissectors/packet-rtp.c",
      "epan/dissectors/packet-sdp.c"
    ],
    "message": "Fix Bug 9885: 'Buildbot crash output: fuzz-2014-03-14-15333.pcap'\n\nThe Buildbot found a crash which is cause by a bug that has\nbeen there all along, but a recent change exposed. This bug is\nlikely in 1.10.6 as well, so I'll backport this if I can\nreproduce it in 1.10.6.\n\nChange-Id: I505bc73cbe6281e6d64f00de441c8e6231b55000\nReviewed-on: https://code.wireshark.org/review/702\nReviewed-by: Hadriel Kaplan <hadrielk@yahoo.com>\nReviewed-by: Evan Huus <eapache@gmail.com>\nReviewed-by: Martin Kaiser <wireshark@kaiser.cx>\nReviewed-by: Michael Mann <mmann78@netscape.net>",
    "before_after_code_files": [
      "epan/dissectors/packet-rtp.c||epan/dissectors/packet-rtp.c",
      "epan/dissectors/packet-sdp.c||epan/dissectors/packet-sdp.c"
    ]
  },
  "patch_diff": {
    "epan/dissectors/packet-rtp.c||epan/dissectors/packet-rtp.c": [
      "File: epan/dissectors/packet-rtp.c -> epan/dissectors/packet-rtp.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "978:     g_strlcpy(p_conv_data->method, setup_method, MAX_RTP_SETUP_METHOD_SIZE+1);",
      "979:     p_conv_data->frame_number = setup_frame_number;",
      "",
      "[Removed Lines]",
      "976:     rtp_free_hash_dyn_payload(p_conv_data->rtp_dyn_payload);",
      "",
      "[Added Lines]",
      "976:     if (p_conv_data->rtp_dyn_payload != rtp_dyn_payload)",
      "977:         rtp_free_hash_dyn_payload(p_conv_data->rtp_dyn_payload);",
      "",
      "---------------"
    ],
    "epan/dissectors/packet-sdp.c||epan/dissectors/packet-sdp.c": [
      "File: epan/dissectors/packet-sdp.c -> epan/dissectors/packet-sdp.c"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "69cc9e10452eb2725ab9a6bb35b717081c50e01d",
      "candidate_info": {
        "commit_hash": "69cc9e10452eb2725ab9a6bb35b717081c50e01d",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/69cc9e10452eb2725ab9a6bb35b717081c50e01d",
        "files": [
          "epan/dissectors/packet-rtp.c",
          "epan/dissectors/packet-sdp.c",
          "epan/dissectors/packet-sip.c"
        ],
        "message": "Fix whitespace tabs to spaces, indent by 4, modelines\n\nChange-Id: I8bb64a879d1aa779c9ac85db306cbd34d1188243\nReviewed-on: https://code.wireshark.org/review/617\nReviewed-by: Evan Huus <eapache@gmail.com>",
        "before_after_code_files": [
          "epan/dissectors/packet-rtp.c||epan/dissectors/packet-rtp.c",
          "epan/dissectors/packet-sdp.c||epan/dissectors/packet-sdp.c",
          "epan/dissectors/packet-sip.c||epan/dissectors/packet-sip.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "epan/dissectors/packet-rtp.c||epan/dissectors/packet-rtp.c",
            "epan/dissectors/packet-sdp.c||epan/dissectors/packet-sdp.c"
          ],
          "candidate": [
            "epan/dissectors/packet-rtp.c||epan/dissectors/packet-rtp.c",
            "epan/dissectors/packet-sdp.c||epan/dissectors/packet-sdp.c"
          ]
        }
      },
      "candidate_diff": {
        "epan/dissectors/packet-rtp.c||epan/dissectors/packet-rtp.c": [
          "File: epan/dissectors/packet-rtp.c -> epan/dissectors/packet-rtp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "76: typedef struct _rfc2198_hdr {",
          "81: } rfc2198_hdr;",
          "85: typedef struct _rtp_multisegment_pdu {",
          "91: } rtp_multisegment_pdu;",
          "93: typedef struct  _rtp_private_conv_info {",
          "98: } rtp_private_conv_info;",
          "100: static reassembly_table rtp_reassembly_table;",
          "",
          "[Removed Lines]",
          "77:  unsigned int pt;",
          "78:  int offset;",
          "79:  int len;",
          "80:  struct _rfc2198_hdr *next;",
          "87:  guint32 startseq;",
          "90:  guint32 endseq;",
          "97:  wmem_tree_t *multisegment_pdus;",
          "",
          "[Added Lines]",
          "77:     unsigned int pt;",
          "78:     int offset;",
          "79:     int len;",
          "80:     struct _rfc2198_hdr *next;",
          "87:     guint32 startseq;",
          "90:     guint32 endseq;",
          "97:     wmem_tree_t *multisegment_pdus;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "114: static gint ett_rtp_fragments = -1;",
          "116: static const fragment_items rtp_fragment_items = {",
          "132: };",
          "134: static dissector_handle_t rtp_handle;",
          "",
          "[Removed Lines]",
          "117:  &ett_rtp_fragment,",
          "118:  &ett_rtp_fragments,",
          "119:  &hf_rtp_fragments,",
          "120:  &hf_rtp_fragment,",
          "121:  &hf_rtp_fragment_overlap,",
          "122:  &hf_rtp_fragment_overlap_conflict,",
          "123:  &hf_rtp_fragment_multiple_tails,",
          "124:  &hf_rtp_fragment_too_long_fragment,",
          "125:  &hf_rtp_fragment_error,",
          "126:  &hf_rtp_fragment_count,",
          "127:  &hf_rtp_reassembled_in,",
          "128:  &hf_rtp_reassembled_length,",
          "130:  NULL,",
          "131:  \"RTP fragments\"",
          "",
          "[Added Lines]",
          "117:     &ett_rtp_fragment,",
          "118:     &ett_rtp_fragments,",
          "119:     &hf_rtp_fragments,",
          "120:     &hf_rtp_fragment,",
          "121:     &hf_rtp_fragment_overlap,",
          "122:     &hf_rtp_fragment_overlap_conflict,",
          "123:     &hf_rtp_fragment_multiple_tails,",
          "124:     &hf_rtp_fragment_too_long_fragment,",
          "125:     &hf_rtp_fragment_error,",
          "126:     &hf_rtp_fragment_count,",
          "127:     &hf_rtp_reassembled_in,",
          "128:     &hf_rtp_reassembled_length,",
          "130:     NULL,",
          "131:     \"RTP fragments\"",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "261: #define RTP0_SPRT    4",
          "263: static const enum_val_t rtp_version0_types[] = {",
          "270: };",
          "271: static gint global_rtp_version0_type = 0;",
          "",
          "[Removed Lines]",
          "264:  { \"invalid\", \"Invalid or ZRTP packets\", RTP0_INVALID },",
          "265:  { \"stun\", \"STUN packets\", RTP0_STUN },",
          "266:  { \"classicstun\", \"CLASSIC-STUN packets\", RTP0_CLASSICSTUN },",
          "267:  { \"t38\", \"T.38 packets\", RTP0_T38 },",
          "268:  { \"sprt\", \"SPRT packets\", RTP0_SPRT },",
          "269:  { NULL, NULL, 0 }",
          "",
          "[Added Lines]",
          "264:     { \"invalid\", \"Invalid or ZRTP packets\", RTP0_INVALID },",
          "265:     { \"stun\", \"STUN packets\", RTP0_STUN },",
          "266:     { \"classicstun\", \"CLASSIC-STUN packets\", RTP0_CLASSICSTUN },",
          "267:     { \"t38\", \"T.38 packets\", RTP0_T38 },",
          "268:     { \"sprt\", \"SPRT packets\", RTP0_SPRT },",
          "269:     { NULL, NULL, 0 }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "312: #define RTP_ED137_SIG    0x0067",
          "",
          "[Removed Lines]",
          "302: #define RTP_VERSION(octet) ((octet) >> 6)",
          "306: #define RTP_PADDING(octet) ((octet) & 0x20)",
          "309: #define RTP_EXTENSION(octet) ((octet) & 0x10)",
          "",
          "[Added Lines]",
          "302: #define RTP_VERSION(octet)  ((octet) >> 6)",
          "306: #define RTP_PADDING(octet)  ((octet) & 0x20)",
          "309: #define RTP_EXTENSION(octet)    ((octet) & 0x10)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "324: #define RTP_ED137_extended_information(octet)   ((octet) & 0x00400000)",
          "328: #define RTP_ED137_feature_type(octet)  (((octet) & 0x003C0000) >> 18)",
          "",
          "[Removed Lines]",
          "325: #define RTP_ED137A_extended_information(octet) ((octet) & 0x00010000)",
          "",
          "[Added Lines]",
          "325: #define RTP_ED137A_extended_information(octet)  ((octet) & 0x00010000)",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "350: #define RTP_RFC5215_TWO_BYTE_SIG        0x1000",
          "355: static const value_string rtp_version_vals[] =",
          "356: {",
          "361: };",
          "363: static const value_string rtp_ext_profile_vals[] =",
          "364: {",
          "368: };",
          "370: static const value_string rtp_ext_ed137_ptt_type[] =",
          "371: {",
          "381: };",
          "383: static const value_string rtp_ext_ed137_squ[] =",
          "384: {",
          "388: };",
          "390: static const value_string rtp_ext_ed137_ft_type[] =",
          "391: {",
          "409: };",
          "411: static const value_string rtp_ext_ed137_vf[] =",
          "412: {",
          "416: };",
          "418: static const value_string rtp_ext_ed137_ft_bss_rssi_qidx[] =",
          "419: {",
          "437: };",
          "439: static const value_string rtp_ext_ed137_ft_bss_qidx_ml[] =",
          "440: {",
          "450: };",
          "452: static const value_string rtp_ext_ed137a_ptt_type[] =",
          "453: {",
          "463: };",
          "465: static const value_string rtp_ext_ed137a_squ[] =",
          "466: {",
          "470: };",
          "472: static const value_string rtp_ext_ed137a_ft_type[] =",
          "473: {",
          "491: };",
          "",
          "[Removed Lines]",
          "353: #define RTP_CSRC_COUNT(octet) ((octet) & 0xF)",
          "358:  { 0, \"Old VAT Version\" },",
          "359:  { 1, \"First Draft Version\" },",
          "360:  { 0, NULL },",
          "365:  { RTP_ED137_SIG, \"ED137\" },",
          "366:  { RTP_ED137A_SIG, \"ED137A\" },",
          "367:  { 0, NULL },",
          "372:  { 0x00, \"PTT OFF\" },",
          "373:  { 0x01, \"Normal PTT ON\" },",
          "374:  { 0x02, \"Coupling PTT ON\" },",
          "375:  { 0x03, \"Priority PTT ON\" },",
          "376:  { 0x04, \"Emergency PTT ON\" },",
          "377:  { 0x05, \"Reserved\" },",
          "378:  { 0x06, \"Reserved\" },",
          "379:  { 0x07, \"Reserved\" },",
          "380:  { 0, NULL },",
          "385:  { 0x00, \"SQ OFF\" },",
          "386:  { 0x01, \"SQ ON\" },",
          "387:  { 0, NULL },",
          "392:  { 0x0, \"No features\" },",
          "393:  { 0x1, \"Best signal selection\" },",
          "394:  { 0x2, \"CLIMAX time delay\" },",
          "395:  { 0x3, \"Reserved\" },",
          "396:  { 0x4, \"Reserved\" },",
          "397:  { 0x5, \"Reserved\" },",
          "398:  { 0x6, \"Reserved\" },",
          "399:  { 0x7, \"Reserved\" },",
          "400:  { 0x8, \"Reserved\" },",
          "401:  { 0x9, \"Reserved\" },",
          "402:  { 0xA, \"Reserved\" },",
          "403:  { 0xB, \"Vendor reserved\" },",
          "404:  { 0xC, \"Vendor reserved\" },",
          "405:  { 0xD, \"Vendor reserved\" },",
          "406:  { 0xE, \"Vendor reserved\" },",
          "407:  { 0xF, \"Vendor reserved\" },",
          "408:  { 0, NULL },",
          "413:  { 0x00, \"VF OFF\" },",
          "414:  { 0x01, \"VF ON\" },",
          "415:  { 0, NULL },",
          "420:  { 0x00, \"lower than -100.00 dBm\" },",
          "421:  { 0x01, \"lower than or equal to -97.86 dBm\" },",
          "422:  { 0x02, \"lower than or equal to -95.71 dBm\" },",
          "423:  { 0x03, \"lower than or equal to -93.57 dBm\" },",
          "424:  { 0x04, \"lower than or equal to -91.43 dBm\" },",
          "425:  { 0x05, \"lower than or equal to -89.29 dBm\" },",
          "426:  { 0x06, \"lower than or equal to -87.14 dBm\" },",
          "427:  { 0x07, \"lower than or equal to -85.00 dBm\" },",
          "428:  { 0x08, \"lower than or equal to -82.86 dBm\" },",
          "429:  { 0x09, \"lower than or equal to -80.71 dBm\" },",
          "430:  { 0x0a, \"lower than or equal to -78.57 dBm\" },",
          "431:  { 0x0b, \"lower than or equal to -76.43 dBm\" },",
          "432:  { 0x0c, \"lower than or equal to -74.29 dBm\" },",
          "433:  { 0x0d, \"lower than or equal to -72.14 dBm\" },",
          "434:  { 0x0e, \"lower than or equal to -70.00 dBm\" },",
          "435:  { 0x0f, \"higher than -70.00 dBm\" },",
          "436:  { 0, NULL },",
          "441:  { 0x00, \"RSSI\" },",
          "442:  { 0x01, \"AGC Level\" },",
          "443:  { 0x02, \"C/N\" },",
          "444:  { 0x03, \"Standardized PSD\" },",
          "445:  { 0x04, \"Vendor specific method\" },",
          "446:  { 0x05, \"Vendor specific method\" },",
          "447:  { 0x06, \"Vendor specific method\" },",
          "448:  { 0x07, \"Vendor specific method\" },",
          "449:  { 0, NULL },",
          "454:  { 0x00, \"PTT OFF\" },",
          "455:  { 0x01, \"Normal PTT ON\" },",
          "456:  { 0x02, \"Coupling PTT ON\" },",
          "457:  { 0x03, \"Priority PTT ON\" },",
          "458:  { 0x04, \"Emergency PTT ON\" },",
          "459:  { 0x05, \"Reserved\" },",
          "460:  { 0x06, \"Reserved\" },",
          "461:  { 0x07, \"Reserved\" },",
          "462:  { 0, NULL },",
          "467:  { 0x00, \"SQ OFF\" },",
          "468:  { 0x01, \"SQ ON\" },",
          "469:  { 0, NULL },",
          "474:  { 0x0, \"No features\" },",
          "475:  { 0x1, \"Signal Quality Information\" },",
          "476:  { 0x2, \"CLIMAX time delay\" },",
          "477:  { 0x3, \"Radio remote control\" },",
          "478:  { 0x4, \"CLIMAX dynamic delay compensation\" },",
          "479:  { 0x5, \"Reserved\" },",
          "480:  { 0x6, \"Reserved\" },",
          "481:  { 0x7, \"Reserved\" },",
          "482:  { 0x8, \"Reserved\" },",
          "483:  { 0x9, \"Reserved\" },",
          "484:  { 0xA, \"Reserved\" },",
          "485:  { 0xB, \"Vendor reserved\" },",
          "486:  { 0xC, \"Vendor reserved\" },",
          "487:  { 0xD, \"Vendor reserved\" },",
          "488:  { 0xE, \"Vendor reserved\" },",
          "489:  { 0xF, \"Vendor reserved\" },",
          "490:  { 0, NULL },",
          "",
          "[Added Lines]",
          "353: #define RTP_CSRC_COUNT(octet)   ((octet) & 0xF)",
          "358:     { 0, \"Old VAT Version\" },",
          "359:     { 1, \"First Draft Version\" },",
          "360:     { 0, NULL },",
          "365:     { RTP_ED137_SIG, \"ED137\" },",
          "366:     { RTP_ED137A_SIG, \"ED137A\" },",
          "367:     { 0, NULL },",
          "372:     { 0x00, \"PTT OFF\" },",
          "373:     { 0x01, \"Normal PTT ON\" },",
          "374:     { 0x02, \"Coupling PTT ON\" },",
          "375:     { 0x03, \"Priority PTT ON\" },",
          "376:     { 0x04, \"Emergency PTT ON\" },",
          "377:     { 0x05, \"Reserved\" },",
          "378:     { 0x06, \"Reserved\" },",
          "379:     { 0x07, \"Reserved\" },",
          "380:     { 0, NULL },",
          "385:     { 0x00, \"SQ OFF\" },",
          "386:     { 0x01, \"SQ ON\" },",
          "387:     { 0, NULL },",
          "392:     { 0x0, \"No features\" },",
          "393:     { 0x1, \"Best signal selection\" },",
          "394:     { 0x2, \"CLIMAX time delay\" },",
          "395:     { 0x3, \"Reserved\" },",
          "396:     { 0x4, \"Reserved\" },",
          "397:     { 0x5, \"Reserved\" },",
          "398:     { 0x6, \"Reserved\" },",
          "399:     { 0x7, \"Reserved\" },",
          "400:     { 0x8, \"Reserved\" },",
          "401:     { 0x9, \"Reserved\" },",
          "402:     { 0xA, \"Reserved\" },",
          "403:     { 0xB, \"Vendor reserved\" },",
          "404:     { 0xC, \"Vendor reserved\" },",
          "405:     { 0xD, \"Vendor reserved\" },",
          "406:     { 0xE, \"Vendor reserved\" },",
          "407:     { 0xF, \"Vendor reserved\" },",
          "408:     { 0, NULL },",
          "413:     { 0x00, \"VF OFF\" },",
          "414:     { 0x01, \"VF ON\" },",
          "415:     { 0, NULL },",
          "420:     { 0x00, \"lower than -100.00 dBm\" },",
          "421:     { 0x01, \"lower than or equal to -97.86 dBm\" },",
          "422:     { 0x02, \"lower than or equal to -95.71 dBm\" },",
          "423:     { 0x03, \"lower than or equal to -93.57 dBm\" },",
          "424:     { 0x04, \"lower than or equal to -91.43 dBm\" },",
          "425:     { 0x05, \"lower than or equal to -89.29 dBm\" },",
          "426:     { 0x06, \"lower than or equal to -87.14 dBm\" },",
          "427:     { 0x07, \"lower than or equal to -85.00 dBm\" },",
          "428:     { 0x08, \"lower than or equal to -82.86 dBm\" },",
          "429:     { 0x09, \"lower than or equal to -80.71 dBm\" },",
          "430:     { 0x0a, \"lower than or equal to -78.57 dBm\" },",
          "431:     { 0x0b, \"lower than or equal to -76.43 dBm\" },",
          "432:     { 0x0c, \"lower than or equal to -74.29 dBm\" },",
          "433:     { 0x0d, \"lower than or equal to -72.14 dBm\" },",
          "434:     { 0x0e, \"lower than or equal to -70.00 dBm\" },",
          "435:     { 0x0f, \"higher than -70.00 dBm\" },",
          "436:     { 0, NULL },",
          "441:     { 0x00, \"RSSI\" },",
          "442:     { 0x01, \"AGC Level\" },",
          "443:     { 0x02, \"C/N\" },",
          "444:     { 0x03, \"Standardized PSD\" },",
          "445:     { 0x04, \"Vendor specific method\" },",
          "446:     { 0x05, \"Vendor specific method\" },",
          "447:     { 0x06, \"Vendor specific method\" },",
          "448:     { 0x07, \"Vendor specific method\" },",
          "449:     { 0, NULL },",
          "454:     { 0x00, \"PTT OFF\" },",
          "455:     { 0x01, \"Normal PTT ON\" },",
          "456:     { 0x02, \"Coupling PTT ON\" },",
          "457:     { 0x03, \"Priority PTT ON\" },",
          "458:     { 0x04, \"Emergency PTT ON\" },",
          "459:     { 0x05, \"Reserved\" },",
          "460:     { 0x06, \"Reserved\" },",
          "461:     { 0x07, \"Reserved\" },",
          "462:     { 0, NULL },",
          "467:     { 0x00, \"SQ OFF\" },",
          "468:     { 0x01, \"SQ ON\" },",
          "469:     { 0, NULL },",
          "474:     { 0x0, \"No features\" },",
          "475:     { 0x1, \"Signal Quality Information\" },",
          "476:     { 0x2, \"CLIMAX time delay\" },",
          "477:     { 0x3, \"Radio remote control\" },",
          "478:     { 0x4, \"CLIMAX dynamic delay compensation\" },",
          "479:     { 0x5, \"Reserved\" },",
          "480:     { 0x6, \"Reserved\" },",
          "481:     { 0x7, \"Reserved\" },",
          "482:     { 0x8, \"Reserved\" },",
          "483:     { 0x9, \"Reserved\" },",
          "484:     { 0xA, \"Reserved\" },",
          "485:     { 0xB, \"Vendor reserved\" },",
          "486:     { 0xC, \"Vendor reserved\" },",
          "487:     { 0xD, \"Vendor reserved\" },",
          "488:     { 0xE, \"Vendor reserved\" },",
          "489:     { 0xF, \"Vendor reserved\" },",
          "490:     { 0, NULL },",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "504: #define FIRST_RTCP_CONFLICT_PAYLOAD_TYPE 64",
          "",
          "[Removed Lines]",
          "498: #define RTP_MARKER(octet) ((octet) & 0x80)",
          "501: #define RTP_PAYLOAD_TYPE(octet) ((octet) & 0x7F)",
          "",
          "[Added Lines]",
          "498: #define RTP_MARKER(octet)   ((octet) & 0x80)",
          "501: #define RTP_PAYLOAD_TYPE(octet) ((octet) & 0x7F)",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "507: static const value_string rtp_payload_type_vals[] =",
          "508: {",
          "644: };",
          "646: value_string_ext rtp_payload_type_vals_ext = VALUE_STRING_EXT_INIT(rtp_payload_type_vals);",
          "648: static const value_string rtp_payload_type_short_vals[] =",
          "649: {",
          "784: };",
          "785: value_string_ext rtp_payload_type_short_vals_ext = VALUE_STRING_EXT_INIT(rtp_payload_type_short_vals);",
          "787: #if 0",
          "788: static const value_string srtp_encryption_alg_vals[] =",
          "789: {",
          "794: };",
          "796: static const value_string srtp_auth_alg_vals[] =",
          "797: {",
          "801: };",
          "802: #endif",
          "",
          "[Removed Lines]",
          "610:   { PT_UNDF_96, \"DynamicRTP-Type-96\" },",
          "611:   { PT_UNDF_97, \"DynamicRTP-Type-97\" },",
          "612:   { PT_UNDF_98, \"DynamicRTP-Type-98\" },",
          "613:   { PT_UNDF_99, \"DynamicRTP-Type-99\" },",
          "614:   { PT_UNDF_100, \"DynamicRTP-Type-100\" },",
          "615:   { PT_UNDF_101, \"DynamicRTP-Type-101\" },",
          "616:   { PT_UNDF_102, \"DynamicRTP-Type-102\" },",
          "617:   { PT_UNDF_103, \"DynamicRTP-Type-103\" },",
          "618:   { PT_UNDF_104, \"DynamicRTP-Type-104\" },",
          "619:   { PT_UNDF_105, \"DynamicRTP-Type-105\" },",
          "620:   { PT_UNDF_106, \"DynamicRTP-Type-106\" },",
          "621:   { PT_UNDF_107, \"DynamicRTP-Type-107\" },",
          "622:   { PT_UNDF_108, \"DynamicRTP-Type-108\" },",
          "623:   { PT_UNDF_109, \"DynamicRTP-Type-109\" },",
          "624:   { PT_UNDF_110, \"DynamicRTP-Type-110\" },",
          "625:   { PT_UNDF_111, \"DynamicRTP-Type-111\" },",
          "626:   { PT_UNDF_112, \"DynamicRTP-Type-112\" },",
          "627:   { PT_UNDF_113, \"DynamicRTP-Type-113\" },",
          "628:   { PT_UNDF_114, \"DynamicRTP-Type-114\" },",
          "629:   { PT_UNDF_115, \"DynamicRTP-Type-115\" },",
          "630:   { PT_UNDF_116, \"DynamicRTP-Type-116\" },",
          "631:   { PT_UNDF_117, \"DynamicRTP-Type-117\" },",
          "632:   { PT_UNDF_118, \"DynamicRTP-Type-118\" },",
          "633:   { PT_UNDF_119, \"DynamicRTP-Type-119\" },",
          "634:   { PT_UNDF_120, \"DynamicRTP-Type-120\" },",
          "635:   { PT_UNDF_121, \"DynamicRTP-Type-121\" },",
          "636:   { PT_UNDF_122, \"DynamicRTP-Type-122\" },",
          "637:   { PT_UNDF_123, \"DynamicRTP-Type-123\" },",
          "638:   { PT_UNDF_124, \"DynamicRTP-Type-124\" },",
          "639:   { PT_UNDF_125, \"DynamicRTP-Type-125\" },",
          "640:   { PT_UNDF_126, \"DynamicRTP-Type-126\" },",
          "641:   { PT_UNDF_127, \"DynamicRTP-Type-127\" },",
          "643:   { 0,  NULL },",
          "650:  { PT_PCMU,      \"g711U\" },",
          "651:  { PT_1016,      \"fs-1016\" },",
          "652:  { PT_G721,      \"g721\" },",
          "653:  { PT_GSM,       \"GSM\" },",
          "654:  { PT_G723,      \"g723\" },",
          "655:  { PT_DVI4_8000, \"DVI4 8k\" },",
          "656:  { PT_DVI4_16000, \"DVI4 16k\" },",
          "657:  { PT_LPC,       \"Exp. from Xerox PARC\" },",
          "658:  { PT_PCMA,      \"g711A\" },",
          "659:  { PT_G722,      \"g722\" },",
          "660:  { PT_L16_STEREO, \"16-bit audio, stereo\" },",
          "661:  { PT_L16_MONO,  \"16-bit audio, monaural\" },",
          "662:  { PT_QCELP,     \"Qualcomm\" },",
          "663:  { PT_CN,        \"CN\" },",
          "664:  { PT_MPA,       \"MPEG-I/II Audio\"},",
          "665:  { PT_G728,      \"g728\" },",
          "666:  { PT_DVI4_11025, \"DVI4 11k\" },",
          "667:  { PT_DVI4_22050, \"DVI4 22k\" },",
          "668:  { PT_G729,      \"g729\" },",
          "669:  { PT_CN_OLD,    \"CN(old)\" },",
          "670:  { 20,    \"Unassigned\" },",
          "671:  { 21,    \"Unassigned\" },",
          "672:  { 22,    \"Unassigned\" },",
          "673:  { 23,    \"Unassigned\" },",
          "674:  { 24,    \"Unassigned\" },",
          "675:  { PT_CELB,      \"CellB\" },",
          "676:  { PT_JPEG,      \"JPEG\" },",
          "677:  { 27,    \"Unassigned\" },",
          "678:  { PT_NV,        \"NV\" },",
          "679:  { 29,    \"Unassigned\" },",
          "680:  { 30,    \"Unassigned\" },",
          "681:  { PT_H261,      \"h261\" },",
          "682:  { PT_MPV,       \"MPEG-I/II Video\"},",
          "683:  { PT_MP2T,      \"MPEG-II streams\"},",
          "684:  { PT_H263,      \"h263\" },",
          "686:  { 35,    \"Unassigned\" },",
          "687:  { 36,    \"Unassigned\" },",
          "688:  { 37,    \"Unassigned\" },",
          "689:  { 38,    \"Unassigned\" },",
          "690:  { 39,    \"Unassigned\" },",
          "691:  { 40,    \"Unassigned\" },",
          "692:  { 41,    \"Unassigned\" },",
          "693:  { 42,    \"Unassigned\" },",
          "694:  { 43,    \"Unassigned\" },",
          "695:  { 44,    \"Unassigned\" },",
          "696:  { 45,    \"Unassigned\" },",
          "697:  { 46,    \"Unassigned\" },",
          "698:  { 47,    \"Unassigned\" },",
          "699:  { 48,    \"Unassigned\" },",
          "700:  { 49,    \"Unassigned\" },",
          "701:  { 50,    \"Unassigned\" },",
          "702:  { 51,    \"Unassigned\" },",
          "703:  { 52,    \"Unassigned\" },",
          "704:  { 53,    \"Unassigned\" },",
          "705:  { 54,    \"Unassigned\" },",
          "706:  { 55,    \"Unassigned\" },",
          "707:  { 56,    \"Unassigned\" },",
          "708:  { 57,    \"Unassigned\" },",
          "709:  { 58,    \"Unassigned\" },",
          "710:  { 59,    \"Unassigned\" },",
          "711:  { 60,    \"Unassigned\" },",
          "712:  { 61,    \"Unassigned\" },",
          "713:  { 62,    \"Unassigned\" },",
          "714:  { 63,    \"Unassigned\" },",
          "715:  { 64,    \"Unassigned\" },",
          "716:  { 65,    \"Unassigned\" },",
          "717:  { 66,    \"Unassigned\" },",
          "718:  { 67,    \"Unassigned\" },",
          "719:  { 68,    \"Unassigned\" },",
          "720:  { 69,    \"Unassigned\" },",
          "721:  { 70,    \"Unassigned\" },",
          "722:  { 71,    \"Unassigned\" },",
          "724:  { 72,    \"Reserved for RTCP conflict avoidance\" },",
          "725:  { 73,    \"Reserved for RTCP conflict avoidance\" },",
          "726:  { 74,    \"Reserved for RTCP conflict avoidance\" },",
          "727:  { 75,    \"Reserved for RTCP conflict avoidance\" },",
          "728:  { 76,    \"Reserved for RTCP conflict avoidance\" },",
          "730:  { 77,    \"Unassigned\" },",
          "731:  { 78,    \"Unassigned\" },",
          "732:  { 79,    \"Unassigned\" },",
          "733:  { 80,    \"Unassigned\" },",
          "734:  { 81,    \"Unassigned\" },",
          "735:  { 82,    \"Unassigned\" },",
          "736:  { 83,    \"Unassigned\" },",
          "737:  { 84,    \"Unassigned\" },",
          "738:  { 85,    \"Unassigned\" },",
          "739:  { 86,    \"Unassigned\" },",
          "740:  { 87,    \"Unassigned\" },",
          "741:  { 88,    \"Unassigned\" },",
          "742:  { 89,    \"Unassigned\" },",
          "743:  { 90,    \"Unassigned\" },",
          "744:  { 91,    \"Unassigned\" },",
          "745:  { 92,    \"Unassigned\" },",
          "746:  { 93,    \"Unassigned\" },",
          "747:  { 94,    \"Unassigned\" },",
          "748:  { 95,    \"Unassigned\" },",
          "750:  { PT_UNDF_96, \"RTPType-96\" },",
          "751:  { PT_UNDF_97, \"RTPType-97\" },",
          "752:  { PT_UNDF_98, \"RTPType-98\" },",
          "753:  { PT_UNDF_99, \"RTPType-99\" },",
          "754:  { PT_UNDF_100, \"RTPType-100\" },",
          "755:  { PT_UNDF_101, \"RTPType-101\" },",
          "756:  { PT_UNDF_102, \"RTPType-102\" },",
          "757:  { PT_UNDF_103, \"RTPType-103\" },",
          "758:  { PT_UNDF_104, \"RTPType-104\" },",
          "759:  { PT_UNDF_105, \"RTPType-105\" },",
          "760:  { PT_UNDF_106, \"RTPType-106\" },",
          "761:  { PT_UNDF_107, \"RTPType-107\" },",
          "762:  { PT_UNDF_108, \"RTPType-108\" },",
          "763:  { PT_UNDF_109, \"RTPType-109\" },",
          "764:  { PT_UNDF_110, \"RTPType-110\" },",
          "765:  { PT_UNDF_111, \"RTPType-111\" },",
          "766:  { PT_UNDF_112, \"RTPType-112\" },",
          "767:  { PT_UNDF_113, \"RTPType-113\" },",
          "768:  { PT_UNDF_114, \"RTPType-114\" },",
          "769:  { PT_UNDF_115, \"RTPType-115\" },",
          "770:  { PT_UNDF_116, \"RTPType-116\" },",
          "771:  { PT_UNDF_117, \"RTPType-117\" },",
          "772:  { PT_UNDF_118, \"RTPType-118\" },",
          "773:  { PT_UNDF_119, \"RTPType-119\" },",
          "774:  { PT_UNDF_120, \"RTPType-120\" },",
          "775:  { PT_UNDF_121, \"RTPType-121\" },",
          "776:  { PT_UNDF_122, \"RTPType-122\" },",
          "777:  { PT_UNDF_123, \"RTPType-123\" },",
          "778:  { PT_UNDF_124, \"RTPType-124\" },",
          "779:  { PT_UNDF_125, \"RTPType-125\" },",
          "780:  { PT_UNDF_126, \"RTPType-126\" },",
          "781:  { PT_UNDF_127, \"RTPType-127\" },",
          "783:  { 0,            NULL },",
          "790:  { SRTP_ENC_ALG_NULL, \"Null Encryption\" },",
          "791:  { SRTP_ENC_ALG_AES_CM, \"AES-128 Counter Mode\" },",
          "792:  { SRTP_ENC_ALG_AES_F8, \"AES-128 F8 Mode\" },",
          "793:  { 0, NULL },",
          "798:  { SRTP_AUTH_ALG_NONE,  \"No Authentication\" },",
          "799:  { SRTP_AUTH_ALG_HMAC_SHA1, \"HMAC-SHA1\" },",
          "800:  { 0, NULL },",
          "",
          "[Added Lines]",
          "610:         { PT_UNDF_96,   \"DynamicRTP-Type-96\" },",
          "611:         { PT_UNDF_97,   \"DynamicRTP-Type-97\" },",
          "612:         { PT_UNDF_98,   \"DynamicRTP-Type-98\" },",
          "613:         { PT_UNDF_99,   \"DynamicRTP-Type-99\" },",
          "614:         { PT_UNDF_100,  \"DynamicRTP-Type-100\" },",
          "615:         { PT_UNDF_101,  \"DynamicRTP-Type-101\" },",
          "616:         { PT_UNDF_102,  \"DynamicRTP-Type-102\" },",
          "617:         { PT_UNDF_103,  \"DynamicRTP-Type-103\" },",
          "618:         { PT_UNDF_104,  \"DynamicRTP-Type-104\" },",
          "619:         { PT_UNDF_105,  \"DynamicRTP-Type-105\" },",
          "620:         { PT_UNDF_106,  \"DynamicRTP-Type-106\" },",
          "621:         { PT_UNDF_107,  \"DynamicRTP-Type-107\" },",
          "622:         { PT_UNDF_108,  \"DynamicRTP-Type-108\" },",
          "623:         { PT_UNDF_109,  \"DynamicRTP-Type-109\" },",
          "624:         { PT_UNDF_110,  \"DynamicRTP-Type-110\" },",
          "625:         { PT_UNDF_111,  \"DynamicRTP-Type-111\" },",
          "626:         { PT_UNDF_112,  \"DynamicRTP-Type-112\" },",
          "627:         { PT_UNDF_113,  \"DynamicRTP-Type-113\" },",
          "628:         { PT_UNDF_114,  \"DynamicRTP-Type-114\" },",
          "629:         { PT_UNDF_115,  \"DynamicRTP-Type-115\" },",
          "630:         { PT_UNDF_116,  \"DynamicRTP-Type-116\" },",
          "631:         { PT_UNDF_117,  \"DynamicRTP-Type-117\" },",
          "632:         { PT_UNDF_118,  \"DynamicRTP-Type-118\" },",
          "633:         { PT_UNDF_119,  \"DynamicRTP-Type-119\" },",
          "634:         { PT_UNDF_120,  \"DynamicRTP-Type-120\" },",
          "635:         { PT_UNDF_121,  \"DynamicRTP-Type-121\" },",
          "636:         { PT_UNDF_122,  \"DynamicRTP-Type-122\" },",
          "637:         { PT_UNDF_123,  \"DynamicRTP-Type-123\" },",
          "638:         { PT_UNDF_124,  \"DynamicRTP-Type-124\" },",
          "639:         { PT_UNDF_125,  \"DynamicRTP-Type-125\" },",
          "640:         { PT_UNDF_126,  \"DynamicRTP-Type-126\" },",
          "641:         { PT_UNDF_127,  \"DynamicRTP-Type-127\" },",
          "643:         { 0,        NULL },",
          "650:     { PT_PCMU,      \"g711U\" },",
          "651:     { PT_1016,      \"fs-1016\" },",
          "652:     { PT_G721,      \"g721\" },",
          "653:     { PT_GSM,       \"GSM\" },",
          "654:     { PT_G723,      \"g723\" },",
          "655:     { PT_DVI4_8000, \"DVI4 8k\" },",
          "656:     { PT_DVI4_16000, \"DVI4 16k\" },",
          "657:     { PT_LPC,       \"Exp. from Xerox PARC\" },",
          "658:     { PT_PCMA,      \"g711A\" },",
          "659:     { PT_G722,      \"g722\" },",
          "660:     { PT_L16_STEREO, \"16-bit audio, stereo\" },",
          "661:     { PT_L16_MONO,  \"16-bit audio, monaural\" },",
          "662:     { PT_QCELP,     \"Qualcomm\" },",
          "663:     { PT_CN,        \"CN\" },",
          "664:     { PT_MPA,       \"MPEG-I/II Audio\"},",
          "665:     { PT_G728,      \"g728\" },",
          "666:     { PT_DVI4_11025, \"DVI4 11k\" },",
          "667:     { PT_DVI4_22050, \"DVI4 22k\" },",
          "668:     { PT_G729,      \"g729\" },",
          "669:     { PT_CN_OLD,    \"CN(old)\" },",
          "670:     { 20,               \"Unassigned\" },",
          "671:     { 21,               \"Unassigned\" },",
          "672:     { 22,               \"Unassigned\" },",
          "673:     { 23,               \"Unassigned\" },",
          "674:     { 24,               \"Unassigned\" },",
          "675:     { PT_CELB,      \"CellB\" },",
          "676:     { PT_JPEG,      \"JPEG\" },",
          "677:     { 27,               \"Unassigned\" },",
          "678:     { PT_NV,        \"NV\" },",
          "679:     { 29,               \"Unassigned\" },",
          "680:     { 30,               \"Unassigned\" },",
          "681:     { PT_H261,      \"h261\" },",
          "682:     { PT_MPV,       \"MPEG-I/II Video\"},",
          "683:     { PT_MP2T,      \"MPEG-II streams\"},",
          "684:     { PT_H263,      \"h263\" },",
          "686:     { 35,               \"Unassigned\" },",
          "687:     { 36,               \"Unassigned\" },",
          "688:     { 37,               \"Unassigned\" },",
          "689:     { 38,               \"Unassigned\" },",
          "690:     { 39,               \"Unassigned\" },",
          "691:     { 40,               \"Unassigned\" },",
          "692:     { 41,               \"Unassigned\" },",
          "693:     { 42,               \"Unassigned\" },",
          "694:     { 43,               \"Unassigned\" },",
          "695:     { 44,               \"Unassigned\" },",
          "696:     { 45,               \"Unassigned\" },",
          "697:     { 46,               \"Unassigned\" },",
          "698:     { 47,               \"Unassigned\" },",
          "699:     { 48,               \"Unassigned\" },",
          "700:     { 49,               \"Unassigned\" },",
          "701:     { 50,               \"Unassigned\" },",
          "702:     { 51,               \"Unassigned\" },",
          "703:     { 52,               \"Unassigned\" },",
          "704:     { 53,               \"Unassigned\" },",
          "705:     { 54,               \"Unassigned\" },",
          "706:     { 55,               \"Unassigned\" },",
          "707:     { 56,               \"Unassigned\" },",
          "708:     { 57,               \"Unassigned\" },",
          "709:     { 58,               \"Unassigned\" },",
          "710:     { 59,               \"Unassigned\" },",
          "711:     { 60,               \"Unassigned\" },",
          "712:     { 61,               \"Unassigned\" },",
          "713:     { 62,               \"Unassigned\" },",
          "714:     { 63,               \"Unassigned\" },",
          "715:     { 64,               \"Unassigned\" },",
          "716:     { 65,               \"Unassigned\" },",
          "717:     { 66,               \"Unassigned\" },",
          "718:     { 67,               \"Unassigned\" },",
          "719:     { 68,               \"Unassigned\" },",
          "720:     { 69,               \"Unassigned\" },",
          "721:     { 70,               \"Unassigned\" },",
          "722:     { 71,               \"Unassigned\" },",
          "724:     { 72,               \"Reserved for RTCP conflict avoidance\" },",
          "725:     { 73,               \"Reserved for RTCP conflict avoidance\" },",
          "726:     { 74,               \"Reserved for RTCP conflict avoidance\" },",
          "727:     { 75,               \"Reserved for RTCP conflict avoidance\" },",
          "728:     { 76,               \"Reserved for RTCP conflict avoidance\" },",
          "730:     { 77,               \"Unassigned\" },",
          "731:     { 78,               \"Unassigned\" },",
          "732:     { 79,               \"Unassigned\" },",
          "733:     { 80,               \"Unassigned\" },",
          "734:     { 81,               \"Unassigned\" },",
          "735:     { 82,               \"Unassigned\" },",
          "736:     { 83,               \"Unassigned\" },",
          "737:     { 84,               \"Unassigned\" },",
          "738:     { 85,               \"Unassigned\" },",
          "739:     { 86,               \"Unassigned\" },",
          "740:     { 87,               \"Unassigned\" },",
          "741:     { 88,               \"Unassigned\" },",
          "742:     { 89,               \"Unassigned\" },",
          "743:     { 90,               \"Unassigned\" },",
          "744:     { 91,               \"Unassigned\" },",
          "745:     { 92,               \"Unassigned\" },",
          "746:     { 93,               \"Unassigned\" },",
          "747:     { 94,               \"Unassigned\" },",
          "748:     { 95,               \"Unassigned\" },",
          "750:     { PT_UNDF_96,   \"RTPType-96\" },",
          "751:     { PT_UNDF_97,   \"RTPType-97\" },",
          "752:     { PT_UNDF_98,   \"RTPType-98\" },",
          "753:     { PT_UNDF_99,   \"RTPType-99\" },",
          "754:     { PT_UNDF_100,  \"RTPType-100\" },",
          "755:     { PT_UNDF_101,  \"RTPType-101\" },",
          "756:     { PT_UNDF_102,  \"RTPType-102\" },",
          "757:     { PT_UNDF_103,  \"RTPType-103\" },",
          "758:     { PT_UNDF_104,  \"RTPType-104\" },",
          "759:     { PT_UNDF_105,  \"RTPType-105\" },",
          "760:     { PT_UNDF_106,  \"RTPType-106\" },",
          "761:     { PT_UNDF_107,  \"RTPType-107\" },",
          "762:     { PT_UNDF_108,  \"RTPType-108\" },",
          "763:     { PT_UNDF_109,  \"RTPType-109\" },",
          "764:     { PT_UNDF_110,  \"RTPType-110\" },",
          "765:     { PT_UNDF_111,  \"RTPType-111\" },",
          "766:     { PT_UNDF_112,  \"RTPType-112\" },",
          "767:     { PT_UNDF_113,  \"RTPType-113\" },",
          "768:     { PT_UNDF_114,  \"RTPType-114\" },",
          "769:     { PT_UNDF_115,  \"RTPType-115\" },",
          "770:     { PT_UNDF_116,  \"RTPType-116\" },",
          "771:     { PT_UNDF_117,  \"RTPType-117\" },",
          "772:     { PT_UNDF_118,  \"RTPType-118\" },",
          "773:     { PT_UNDF_119,  \"RTPType-119\" },",
          "774:     { PT_UNDF_120,  \"RTPType-120\" },",
          "775:     { PT_UNDF_121,  \"RTPType-121\" },",
          "776:     { PT_UNDF_122,  \"RTPType-122\" },",
          "777:     { PT_UNDF_123,  \"RTPType-123\" },",
          "778:     { PT_UNDF_124,  \"RTPType-124\" },",
          "779:     { PT_UNDF_125,  \"RTPType-125\" },",
          "780:     { PT_UNDF_126,  \"RTPType-126\" },",
          "781:     { PT_UNDF_127,  \"RTPType-127\" },",
          "783:     { 0,            NULL },",
          "790:     { SRTP_ENC_ALG_NULL,    \"Null Encryption\" },",
          "791:     { SRTP_ENC_ALG_AES_CM,  \"AES-128 Counter Mode\" },",
          "792:     { SRTP_ENC_ALG_AES_F8,  \"AES-128 F8 Mode\" },",
          "793:     { 0, NULL },",
          "798:     { SRTP_AUTH_ALG_NONE,       \"No Authentication\" },",
          "799:     { SRTP_AUTH_ALG_HMAC_SHA1,  \"HMAC-SHA1\" },",
          "800:     { 0, NULL },",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "805: static void",
          "806: rtp_fragment_init(void)",
          "807: {",
          "810: }",
          "812: void",
          "813: rtp_free_hash_dyn_payload(GHashTable *rtp_dyn_payload)",
          "814: {",
          "818: }",
          "821: void",
          "822: bluetooth_add_address(packet_info *pinfo, address *addr,",
          "825: {",
          "900: }",
          "903: void",
          "904: srtp_add_address(packet_info *pinfo, address *addr, int port, int other_port,",
          "908: {",
          "923: #ifdef DEBUG",
          "927: #endif",
          "985: }",
          "988: void",
          "989: rtp_add_address(packet_info *pinfo, address *addr, int port, int other_port,",
          "992: {",
          "994: }",
          "996: static gboolean",
          "997: dissect_rtp_heur_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data, gboolean check_destport)",
          "998: {",
          "1054: }",
          "1056: static gboolean",
          "1057: dissect_rtp_heur_udp( tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data )",
          "1058: {",
          "1060: }",
          "1062: static gboolean",
          "1063: dissect_rtp_heur_stun( tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data )",
          "1064: {",
          "1066: }",
          "",
          "[Removed Lines]",
          "808:  reassembly_table_init(&rtp_reassembly_table,",
          "809:          &addresses_reassembly_table_functions);",
          "815:  if (rtp_dyn_payload == NULL) return;",
          "816:  g_hash_table_destroy(rtp_dyn_payload);",
          "817:  rtp_dyn_payload = NULL;",
          "823:    const gchar *setup_method, guint32 setup_frame_number,",
          "824:    gboolean is_video, void *data)",
          "826:  address null_addr;",
          "827:  conversation_t* p_conv;",
          "828:  struct _rtp_conversation_info *p_conv_data = NULL;",
          "834:  if ((pinfo->fd->flags.visited) || (rtp_handle == NULL))",
          "835:  {",
          "836:   return;",
          "837:  }",
          "839:  SET_ADDRESS(&null_addr, AT_NONE, 0, NULL);",
          "845:  p_conv = find_conversation(setup_frame_number, addr, &null_addr, PT_BLUETOOTH, 0, 0,",
          "846:        NO_ADDR_B | NO_PORT_B);",
          "851:  if (!p_conv || p_conv->setup_frame != setup_frame_number) {",
          "852:   p_conv = conversation_new(setup_frame_number, addr, &null_addr, PT_BLUETOOTH, 0, 0,",
          "853:        NO_ADDR2 | NO_PORT2);",
          "854:  }",
          "857:  conversation_set_dissector(p_conv, rtp_handle);",
          "862:  p_conv_data = (struct _rtp_conversation_info *)conversation_get_proto_data(p_conv, proto_rtp);",
          "867:  if (! p_conv_data) {",
          "869:   p_conv_data = wmem_new(wmem_file_scope(), struct _rtp_conversation_info);",
          "870:   p_conv_data->rtp_dyn_payload = NULL;",
          "875:   p_conv_data->extended_seqno = 0x10000;",
          "876:   p_conv_data->rtp_conv_info = wmem_new(wmem_file_scope(), rtp_private_conv_info);",
          "877:   p_conv_data->rtp_conv_info->multisegment_pdus = wmem_tree_new(wmem_file_scope());",
          "878:   conversation_add_proto_data(p_conv, proto_rtp, p_conv_data);",
          "880:   if (is_video) {",
          "881:    p_conv_data->bta2dp_info = NULL;",
          "882:    p_conv_data->btvdp_info = (btvdp_codec_info_t *) wmem_memdup(wmem_file_scope(), data, sizeof(btvdp_codec_info_t));",
          "883:   } else {",
          "884:    p_conv_data->bta2dp_info = (bta2dp_codec_info_t *) wmem_memdup(wmem_file_scope(), data, sizeof(bta2dp_codec_info_t));",
          "885:    p_conv_data->btvdp_info = NULL;",
          "886:   }",
          "887:  }",
          "893:  rtp_free_hash_dyn_payload(p_conv_data->rtp_dyn_payload);",
          "895:  g_strlcpy(p_conv_data->method, setup_method, MAX_RTP_SETUP_METHOD_SIZE+1);",
          "896:  p_conv_data->frame_number = setup_frame_number;",
          "897:  p_conv_data->is_video = is_video;",
          "898:  p_conv_data->rtp_dyn_payload = NULL;",
          "899:  p_conv_data->srtp_info = NULL;",
          "905:    const gchar *setup_method, guint32 setup_frame_number,",
          "906:    gboolean is_video _U_, GHashTable *rtp_dyn_payload,",
          "907:    struct srtp_info *srtp_info)",
          "909:  address null_addr;",
          "910:  conversation_t* p_conv;",
          "911:  struct _rtp_conversation_info *p_conv_data = NULL;",
          "918:  if ((pinfo->fd->flags.visited) || (rtp_handle == NULL))",
          "919:  {",
          "920:   return;",
          "921:  }",
          "924:  printf(\"#%u: %srtp_add_address(%s, %u, %u, %s, %u\\n\",",
          "925:   pinfo->fd->num, (srtp_info)?\"s\":\"\", ep_address_to_str(addr), port,",
          "926:   other_port, setup_method, setup_frame_number);",
          "929:  SET_ADDRESS(&null_addr, AT_NONE, 0, NULL);",
          "935:  p_conv = find_conversation(setup_frame_number, addr, &null_addr, PT_UDP, port, other_port,",
          "936:        NO_ADDR_B | (!other_port ? NO_PORT_B : 0));",
          "941:  if (!p_conv || p_conv->setup_frame != setup_frame_number) {",
          "942:   p_conv = conversation_new(setup_frame_number, addr, &null_addr, PT_UDP,",
          "943:                             (guint32)port, (guint32)other_port,",
          "944:        NO_ADDR2 | (!other_port ? NO_PORT2 : 0));",
          "945:  }",
          "948:  conversation_set_dissector(p_conv, rtp_handle);",
          "953:  p_conv_data = (struct _rtp_conversation_info *)conversation_get_proto_data(p_conv, proto_rtp);",
          "958:  if (! p_conv_data) {",
          "960:   p_conv_data = wmem_new(wmem_file_scope(), struct _rtp_conversation_info);",
          "961:   p_conv_data->rtp_dyn_payload = NULL;",
          "966:   p_conv_data->extended_seqno = 0x10000;",
          "967:   p_conv_data->rtp_conv_info = wmem_new(wmem_file_scope(), rtp_private_conv_info);",
          "968:   p_conv_data->rtp_conv_info->multisegment_pdus = wmem_tree_new(wmem_file_scope());",
          "969:   conversation_add_proto_data(p_conv, proto_rtp, p_conv_data);",
          "970:  }",
          "976:  rtp_free_hash_dyn_payload(p_conv_data->rtp_dyn_payload);",
          "978:  g_strlcpy(p_conv_data->method, setup_method, MAX_RTP_SETUP_METHOD_SIZE+1);",
          "979:  p_conv_data->frame_number = setup_frame_number;",
          "980:  p_conv_data->is_video = is_video;",
          "981:  p_conv_data->rtp_dyn_payload = rtp_dyn_payload;",
          "982:  p_conv_data->srtp_info = srtp_info;",
          "983:  p_conv_data->bta2dp_info = NULL;",
          "984:  p_conv_data->btvdp_info = NULL;",
          "990:   const gchar *setup_method, guint32 setup_frame_number,",
          "991:   gboolean is_video , GHashTable *rtp_dyn_payload)",
          "993:  srtp_add_address(pinfo, addr, port, other_port, setup_method, setup_frame_number, is_video, rtp_dyn_payload, NULL);",
          "999:  guint8       octet1;",
          "1000:  unsigned int version;",
          "1001:  unsigned int offset = 0;",
          "1008:  if (! global_rtp_heur)",
          "1009:   return FALSE;",
          "1012:  octet1 = tvb_get_guint8( tvb, offset );",
          "1013:  version = RTP_VERSION( octet1 );",
          "1015:  if (version == 0) {",
          "1016:   if (!(tvb_memeql(tvb, 4, \"ZRTP\", 4)))",
          "1017:   {",
          "1018:    call_dissector_only(zrtp_handle, tvb, pinfo, tree, NULL);",
          "1019:    return TRUE;",
          "1020:   } else {",
          "1021:    switch (global_rtp_version0_type) {",
          "1022:    case RTP0_STUN:",
          "1023:     return call_dissector_only(stun_heur_handle, tvb, pinfo, tree, NULL);",
          "1024:    case RTP0_CLASSICSTUN:",
          "1025:     return call_dissector_only(classicstun_heur_handle, tvb, pinfo, tree, NULL);",
          "1027:    case RTP0_T38:",
          "1029:     call_dissector_only(t38_handle, tvb, pinfo, tree, NULL);",
          "1030:     return TRUE;",
          "1032:    case RTP0_SPRT:",
          "1033:     call_dissector_only(sprt_handle, tvb, pinfo, tree, NULL);",
          "1034:     return TRUE;",
          "1036:    case RTP0_INVALID:",
          "1038:    default:",
          "1040:    }",
          "1041:   }",
          "1042:  } else if (version != 2) {",
          "1044:   return FALSE;",
          "1045:  }",
          "1048:  if (check_destport && ((pinfo->destport % 2) != 0)) {",
          "1049:   return FALSE;",
          "1050:  }",
          "1052:  dissect_rtp( tvb, pinfo, tree, data );",
          "1053:  return TRUE;",
          "1059:  return dissect_rtp_heur_common(tvb, pinfo, tree, data, TRUE);",
          "1065:  return dissect_rtp_heur_common(tvb, pinfo, tree, data, FALSE);",
          "",
          "[Added Lines]",
          "808:     reassembly_table_init(&rtp_reassembly_table,",
          "809:                   &addresses_reassembly_table_functions);",
          "815:     if (rtp_dyn_payload == NULL) return;",
          "816:     g_hash_table_destroy(rtp_dyn_payload);",
          "817:     rtp_dyn_payload = NULL;",
          "823:          const gchar *setup_method, guint32 setup_frame_number,",
          "824:          gboolean is_video, void *data)",
          "826:     address null_addr;",
          "827:     conversation_t* p_conv;",
          "828:     struct _rtp_conversation_info *p_conv_data = NULL;",
          "834:     if ((pinfo->fd->flags.visited) || (rtp_handle == NULL))",
          "835:     {",
          "836:         return;",
          "837:     }",
          "839:     SET_ADDRESS(&null_addr, AT_NONE, 0, NULL);",
          "845:     p_conv = find_conversation(setup_frame_number, addr, &null_addr, PT_BLUETOOTH, 0, 0,",
          "846:                    NO_ADDR_B | NO_PORT_B);",
          "851:     if (!p_conv || p_conv->setup_frame != setup_frame_number) {",
          "852:         p_conv = conversation_new(setup_frame_number, addr, &null_addr, PT_BLUETOOTH, 0, 0,",
          "853:                    NO_ADDR2 | NO_PORT2);",
          "854:     }",
          "857:     conversation_set_dissector(p_conv, rtp_handle);",
          "862:     p_conv_data = (struct _rtp_conversation_info *)conversation_get_proto_data(p_conv, proto_rtp);",
          "867:     if (! p_conv_data) {",
          "869:         p_conv_data = wmem_new(wmem_file_scope(), struct _rtp_conversation_info);",
          "870:         p_conv_data->rtp_dyn_payload = NULL;",
          "875:         p_conv_data->extended_seqno = 0x10000;",
          "876:         p_conv_data->rtp_conv_info = wmem_new(wmem_file_scope(), rtp_private_conv_info);",
          "877:         p_conv_data->rtp_conv_info->multisegment_pdus = wmem_tree_new(wmem_file_scope());",
          "878:         conversation_add_proto_data(p_conv, proto_rtp, p_conv_data);",
          "880:         if (is_video) {",
          "881:             p_conv_data->bta2dp_info = NULL;",
          "882:             p_conv_data->btvdp_info = (btvdp_codec_info_t *) wmem_memdup(wmem_file_scope(), data, sizeof(btvdp_codec_info_t));",
          "883:         } else {",
          "884:             p_conv_data->bta2dp_info = (bta2dp_codec_info_t *) wmem_memdup(wmem_file_scope(), data, sizeof(bta2dp_codec_info_t));",
          "885:             p_conv_data->btvdp_info = NULL;",
          "886:         }",
          "887:     }",
          "893:     rtp_free_hash_dyn_payload(p_conv_data->rtp_dyn_payload);",
          "895:     g_strlcpy(p_conv_data->method, setup_method, MAX_RTP_SETUP_METHOD_SIZE+1);",
          "896:     p_conv_data->frame_number = setup_frame_number;",
          "897:     p_conv_data->is_video = is_video;",
          "898:     p_conv_data->rtp_dyn_payload = NULL;",
          "899:     p_conv_data->srtp_info = NULL;",
          "905:          const gchar *setup_method, guint32 setup_frame_number,",
          "906:          gboolean is_video _U_, GHashTable *rtp_dyn_payload,",
          "907:          struct srtp_info *srtp_info)",
          "909:     address null_addr;",
          "910:     conversation_t* p_conv;",
          "911:     struct _rtp_conversation_info *p_conv_data = NULL;",
          "918:     if ((pinfo->fd->flags.visited) || (rtp_handle == NULL))",
          "919:     {",
          "920:         return;",
          "921:     }",
          "924:     printf(\"#%u: %srtp_add_address(%s, %u, %u, %s, %u\\n\",",
          "925:         pinfo->fd->num, (srtp_info)?\"s\":\"\", ep_address_to_str(addr), port,",
          "926:         other_port, setup_method, setup_frame_number);",
          "929:     SET_ADDRESS(&null_addr, AT_NONE, 0, NULL);",
          "935:     p_conv = find_conversation(setup_frame_number, addr, &null_addr, PT_UDP, port, other_port,",
          "936:                    NO_ADDR_B | (!other_port ? NO_PORT_B : 0));",
          "941:     if (!p_conv || p_conv->setup_frame != setup_frame_number) {",
          "942:         p_conv = conversation_new(setup_frame_number, addr, &null_addr, PT_UDP,",
          "943:                                   (guint32)port, (guint32)other_port,",
          "944:                       NO_ADDR2 | (!other_port ? NO_PORT2 : 0));",
          "945:     }",
          "948:     conversation_set_dissector(p_conv, rtp_handle);",
          "953:     p_conv_data = (struct _rtp_conversation_info *)conversation_get_proto_data(p_conv, proto_rtp);",
          "958:     if (! p_conv_data) {",
          "960:         p_conv_data = wmem_new(wmem_file_scope(), struct _rtp_conversation_info);",
          "961:         p_conv_data->rtp_dyn_payload = NULL;",
          "966:         p_conv_data->extended_seqno = 0x10000;",
          "967:         p_conv_data->rtp_conv_info = wmem_new(wmem_file_scope(), rtp_private_conv_info);",
          "968:         p_conv_data->rtp_conv_info->multisegment_pdus = wmem_tree_new(wmem_file_scope());",
          "969:         conversation_add_proto_data(p_conv, proto_rtp, p_conv_data);",
          "970:     }",
          "976:     rtp_free_hash_dyn_payload(p_conv_data->rtp_dyn_payload);",
          "978:     g_strlcpy(p_conv_data->method, setup_method, MAX_RTP_SETUP_METHOD_SIZE+1);",
          "979:     p_conv_data->frame_number = setup_frame_number;",
          "980:     p_conv_data->is_video = is_video;",
          "981:     p_conv_data->rtp_dyn_payload = rtp_dyn_payload;",
          "982:     p_conv_data->srtp_info = srtp_info;",
          "983:     p_conv_data->bta2dp_info = NULL;",
          "984:     p_conv_data->btvdp_info = NULL;",
          "990:         const gchar *setup_method, guint32 setup_frame_number,",
          "991:         gboolean is_video , GHashTable *rtp_dyn_payload)",
          "993:     srtp_add_address(pinfo, addr, port, other_port, setup_method, setup_frame_number, is_video, rtp_dyn_payload, NULL);",
          "999:     guint8       octet1;",
          "1000:     unsigned int version;",
          "1001:     unsigned int offset = 0;",
          "1008:     if (! global_rtp_heur)",
          "1009:         return FALSE;",
          "1012:     octet1 = tvb_get_guint8( tvb, offset );",
          "1013:     version = RTP_VERSION( octet1 );",
          "1015:     if (version == 0) {",
          "1016:         if (!(tvb_memeql(tvb, 4, \"ZRTP\", 4)))",
          "1017:         {",
          "1018:             call_dissector_only(zrtp_handle, tvb, pinfo, tree, NULL);",
          "1019:             return TRUE;",
          "1020:         } else {",
          "1021:             switch (global_rtp_version0_type) {",
          "1022:             case RTP0_STUN:",
          "1023:                 return call_dissector_only(stun_heur_handle, tvb, pinfo, tree, NULL);",
          "1024:             case RTP0_CLASSICSTUN:",
          "1025:                 return call_dissector_only(classicstun_heur_handle, tvb, pinfo, tree, NULL);",
          "1027:             case RTP0_T38:",
          "1029:                 call_dissector_only(t38_handle, tvb, pinfo, tree, NULL);",
          "1030:                 return TRUE;",
          "1032:             case RTP0_SPRT:",
          "1033:                 call_dissector_only(sprt_handle, tvb, pinfo, tree, NULL);",
          "1034:                 return TRUE;",
          "1036:             case RTP0_INVALID:",
          "1038:             default:",
          "1040:             }",
          "1041:         }",
          "1042:     } else if (version != 2) {",
          "1044:         return FALSE;",
          "1045:     }",
          "1048:     if (check_destport && ((pinfo->destport % 2) != 0)) {",
          "1049:         return FALSE;",
          "1050:     }",
          "1052:     dissect_rtp( tvb, pinfo, tree, data );",
          "1053:     return TRUE;",
          "1059:     return dissect_rtp_heur_common(tvb, pinfo, tree, data, TRUE);",
          "1065:     return dissect_rtp_heur_common(tvb, pinfo, tree, data, FALSE);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1071: static void",
          "1072: process_rtp_payload(tvbuff_t *newtvb, packet_info *pinfo, proto_tree *tree,",
          "1074: {",
          "1088: #if 0",
          "1089: #error Currently the srtp_info structure contains no cipher data, see packet-sdp.c adding dummy_srtp_info structure",
          "1095: #endif",
          "1177: }",
          "",
          "[Removed Lines]",
          "1073:       proto_tree *rtp_tree, unsigned int payload_type)",
          "1075:  struct _rtp_conversation_info *p_conv_data = NULL;",
          "1076:  gboolean found_match = FALSE;",
          "1077:  int payload_len;",
          "1078:  struct srtp_info *srtp_info;",
          "1079:  int offset = 0;",
          "1081:  payload_len = tvb_length_remaining(newtvb, offset);",
          "1084:  p_conv_data = (struct _rtp_conversation_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_rtp, 0);",
          "1085:  if (p_conv_data && p_conv_data->srtp_info) {",
          "1086:   srtp_info = p_conv_data->srtp_info;",
          "1087:   payload_len -= srtp_info->mki_len + srtp_info->auth_tag_len;",
          "1090:   if (p_conv_data->srtp_info->encryption_algorithm==SRTP_ENC_ALG_NULL) {",
          "1091:    if (rtp_tree)",
          "1092:     proto_tree_add_text(rtp_tree, newtvb, offset, payload_len, \"SRTP Payload with NULL encryption\");",
          "1093:   }",
          "1094:   else",
          "1096:   {",
          "1097:    if (rtp_tree)",
          "1098:     proto_tree_add_item(rtp_tree, hf_srtp_encrypted_payload, newtvb, offset, payload_len, ENC_NA);",
          "1100:   }",
          "1101:   offset += payload_len;",
          "1103:   if (srtp_info->mki_len) {",
          "1104:    proto_tree_add_item(rtp_tree, hf_srtp_mki, newtvb, offset, srtp_info->mki_len, ENC_NA);",
          "1105:    offset += srtp_info->mki_len;",
          "1106:   }",
          "1108:   if (srtp_info->auth_tag_len) {",
          "1109:    proto_tree_add_item(rtp_tree, hf_srtp_auth_tag, newtvb, offset, srtp_info->auth_tag_len, ENC_NA);",
          "1111:   }",
          "1112:  } else if (p_conv_data && !p_conv_data->bta2dp_info && !p_conv_data->btvdp_info &&",
          "1113:    payload_type >= PT_UNDF_96 && payload_type <= PT_UNDF_127) {",
          "1115:   if (p_conv_data && p_conv_data->rtp_dyn_payload) {",
          "1116:    gchar *payload_type_str = NULL;",
          "1117:    encoding_name_and_rate_t *encoding_name_and_rate_pt = NULL;",
          "1118:    encoding_name_and_rate_pt = (encoding_name_and_rate_t *)g_hash_table_lookup(p_conv_data->rtp_dyn_payload, &payload_type);",
          "1119:    if (encoding_name_and_rate_pt) {",
          "1120:     payload_type_str = encoding_name_and_rate_pt->encoding_name;",
          "1121:    }",
          "1122:    if (payload_type_str){",
          "1123:     found_match = dissector_try_string(rtp_dyn_pt_dissector_table,",
          "1124:            payload_type_str, newtvb, pinfo, tree, NULL);",
          "1131:     if(found_match==FALSE)",
          "1132:      proto_tree_add_item( rtp_tree, hf_rtp_data, newtvb, 0, -1, ENC_NA );",
          "1133:     return;",
          "1134:    }",
          "1136:   }",
          "1137:  } else if (p_conv_data && p_conv_data->bta2dp_info) {",
          "1138:   tvbuff_t  *nexttvb;",
          "1139:   gint       suboffset = 0;",
          "1141:   found_match = TRUE;",
          "1143:   if (p_conv_data->bta2dp_info->content_protection_type == BTAVDTP_CONTENT_PROTECTION_TYPE_SCMS_T) {",
          "1144:    nexttvb = tvb_new_subset(newtvb, 0, 1, 1);",
          "1145:     call_dissector(bta2dp_content_protection_header_scms_t, nexttvb, pinfo, tree);",
          "1146:    suboffset = 1;",
          "1147:   }",
          "1149:   nexttvb = tvb_new_subset_remaining(newtvb, suboffset);",
          "1150:   if (p_conv_data->bta2dp_info->codec_dissector)",
          "1151:    call_dissector(p_conv_data->bta2dp_info->codec_dissector, nexttvb, pinfo, tree);",
          "1152:   else",
          "1153:    call_dissector(data_handle, nexttvb, pinfo, tree);",
          "1154:  } else if (p_conv_data && p_conv_data->btvdp_info) {",
          "1155:   tvbuff_t  *nexttvb;",
          "1156:   gint       suboffset = 0;",
          "1158:   found_match = TRUE;",
          "1160:   if (p_conv_data->btvdp_info->content_protection_type == BTAVDTP_CONTENT_PROTECTION_TYPE_SCMS_T) {",
          "1161:    nexttvb = tvb_new_subset(newtvb, 0, 1, 1);",
          "1162:    call_dissector(bta2dp_content_protection_header_scms_t, nexttvb, pinfo, tree);",
          "1163:    suboffset = 1;",
          "1164:   }",
          "1166:   nexttvb = tvb_new_subset_remaining(newtvb, suboffset);",
          "1167:   if (p_conv_data->btvdp_info->codec_dissector)",
          "1168:    call_dissector(p_conv_data->btvdp_info->codec_dissector, nexttvb, pinfo, tree);",
          "1169:   else",
          "1170:    call_dissector(data_handle, nexttvb, pinfo, tree);",
          "1171:  }",
          "1174:  if (!found_match && !dissector_try_uint(rtp_pt_dissector_table, payload_type, newtvb, pinfo, tree))",
          "1175:   proto_tree_add_item( rtp_tree, hf_rtp_data, newtvb, 0, -1, ENC_NA );",
          "",
          "[Added Lines]",
          "1073:             proto_tree *rtp_tree, unsigned int payload_type)",
          "1075:     struct _rtp_conversation_info *p_conv_data = NULL;",
          "1076:     gboolean found_match = FALSE;",
          "1077:     int payload_len;",
          "1078:     struct srtp_info *srtp_info;",
          "1079:     int offset = 0;",
          "1081:     payload_len = tvb_length_remaining(newtvb, offset);",
          "1084:     p_conv_data = (struct _rtp_conversation_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_rtp, 0);",
          "1085:     if (p_conv_data && p_conv_data->srtp_info) {",
          "1086:         srtp_info = p_conv_data->srtp_info;",
          "1087:         payload_len -= srtp_info->mki_len + srtp_info->auth_tag_len;",
          "1090:         if (p_conv_data->srtp_info->encryption_algorithm==SRTP_ENC_ALG_NULL) {",
          "1091:             if (rtp_tree)",
          "1092:                 proto_tree_add_text(rtp_tree, newtvb, offset, payload_len, \"SRTP Payload with NULL encryption\");",
          "1093:         }",
          "1094:         else",
          "1096:         {",
          "1097:             if (rtp_tree)",
          "1098:                 proto_tree_add_item(rtp_tree, hf_srtp_encrypted_payload, newtvb, offset, payload_len, ENC_NA);",
          "1100:         }",
          "1101:         offset += payload_len;",
          "1103:         if (srtp_info->mki_len) {",
          "1104:             proto_tree_add_item(rtp_tree, hf_srtp_mki, newtvb, offset, srtp_info->mki_len, ENC_NA);",
          "1105:             offset += srtp_info->mki_len;",
          "1106:         }",
          "1108:         if (srtp_info->auth_tag_len) {",
          "1109:             proto_tree_add_item(rtp_tree, hf_srtp_auth_tag, newtvb, offset, srtp_info->auth_tag_len, ENC_NA);",
          "1111:         }",
          "1112:     } else if (p_conv_data && !p_conv_data->bta2dp_info && !p_conv_data->btvdp_info &&",
          "1113:             payload_type >= PT_UNDF_96 && payload_type <= PT_UNDF_127) {",
          "1115:         if (p_conv_data && p_conv_data->rtp_dyn_payload) {",
          "1116:             gchar *payload_type_str = NULL;",
          "1117:             encoding_name_and_rate_t *encoding_name_and_rate_pt = NULL;",
          "1118:             encoding_name_and_rate_pt = (encoding_name_and_rate_t *)g_hash_table_lookup(p_conv_data->rtp_dyn_payload, &payload_type);",
          "1119:             if (encoding_name_and_rate_pt) {",
          "1120:                 payload_type_str = encoding_name_and_rate_pt->encoding_name;",
          "1121:             }",
          "1122:             if (payload_type_str){",
          "1123:                 found_match = dissector_try_string(rtp_dyn_pt_dissector_table,",
          "1124:                                    payload_type_str, newtvb, pinfo, tree, NULL);",
          "1131:                 if(found_match==FALSE)",
          "1132:                     proto_tree_add_item( rtp_tree, hf_rtp_data, newtvb, 0, -1, ENC_NA );",
          "1133:                 return;",
          "1134:             }",
          "1136:         }",
          "1137:     } else if (p_conv_data && p_conv_data->bta2dp_info) {",
          "1138:         tvbuff_t  *nexttvb;",
          "1139:         gint       suboffset = 0;",
          "1141:         found_match = TRUE;",
          "1143:         if (p_conv_data->bta2dp_info->content_protection_type == BTAVDTP_CONTENT_PROTECTION_TYPE_SCMS_T) {",
          "1144:             nexttvb = tvb_new_subset(newtvb, 0, 1, 1);",
          "1145:              call_dissector(bta2dp_content_protection_header_scms_t, nexttvb, pinfo, tree);",
          "1146:             suboffset = 1;",
          "1147:         }",
          "1149:         nexttvb = tvb_new_subset_remaining(newtvb, suboffset);",
          "1150:         if (p_conv_data->bta2dp_info->codec_dissector)",
          "1151:             call_dissector(p_conv_data->bta2dp_info->codec_dissector, nexttvb, pinfo, tree);",
          "1152:         else",
          "1153:             call_dissector(data_handle, nexttvb, pinfo, tree);",
          "1154:     } else if (p_conv_data && p_conv_data->btvdp_info) {",
          "1155:         tvbuff_t  *nexttvb;",
          "1156:         gint       suboffset = 0;",
          "1158:         found_match = TRUE;",
          "1160:         if (p_conv_data->btvdp_info->content_protection_type == BTAVDTP_CONTENT_PROTECTION_TYPE_SCMS_T) {",
          "1161:             nexttvb = tvb_new_subset(newtvb, 0, 1, 1);",
          "1162:             call_dissector(bta2dp_content_protection_header_scms_t, nexttvb, pinfo, tree);",
          "1163:             suboffset = 1;",
          "1164:         }",
          "1166:         nexttvb = tvb_new_subset_remaining(newtvb, suboffset);",
          "1167:         if (p_conv_data->btvdp_info->codec_dissector)",
          "1168:             call_dissector(p_conv_data->btvdp_info->codec_dissector, nexttvb, pinfo, tree);",
          "1169:         else",
          "1170:             call_dissector(data_handle, nexttvb, pinfo, tree);",
          "1171:     }",
          "1174:     if (!found_match && !dissector_try_uint(rtp_pt_dissector_table, payload_type, newtvb, pinfo, tree))",
          "1175:         proto_tree_add_item( rtp_tree, hf_rtp_data, newtvb, 0, -1, ENC_NA );",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1192: static void",
          "1193: dissect_rtp_data(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,",
          "1197: {",
          "1224: #ifdef DEBUG_FRAGMENTS",
          "1230: #endif",
          "1239: #ifdef DEBUG_FRAGMENTS",
          "1241: #endif",
          "1255: #ifdef DEBUG_FRAGMENTS",
          "1258: #endif",
          "1269: #ifdef DEBUG_FRAGMENTS",
          "1271: #endif",
          "1299: #ifdef DEBUG_FRAGMENTS",
          "1301: #endif",
          "1324: #ifdef DEBUG_FRAGMENTS",
          "1331: #endif",
          "1354: #ifdef DEBUG_FRAGMENTS",
          "1356: #endif",
          "1360: #ifdef DEBUG_FRAGMENTS",
          "1362: #endif",
          "1373: #ifdef DEBUG_FRAGMENTS",
          "1375: #endif",
          "1388: }",
          "",
          "[Removed Lines]",
          "1194:    proto_tree *rtp_tree, int offset, unsigned int data_len,",
          "1195:    unsigned int data_reported_len,",
          "1196:    unsigned int payload_type)",
          "1198:  tvbuff_t *newtvb;",
          "1199:  struct _rtp_conversation_info *p_conv_data= NULL;",
          "1200:  gboolean must_desegment = FALSE;",
          "1201:  rtp_private_conv_info *finfo = NULL;",
          "1202:  rtp_multisegment_pdu *msp = NULL;",
          "1203:  guint32 seqno;",
          "1206:  p_conv_data = (struct _rtp_conversation_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_rtp, 0);",
          "1208:  if(p_conv_data != NULL)",
          "1209:   finfo = p_conv_data->rtp_conv_info;",
          "1211:  if(finfo == NULL || !desegment_rtp) {",
          "1213:   newtvb=tvb_new_subset(tvb,offset,data_len,data_reported_len);",
          "1214:   process_rtp_payload(newtvb, pinfo, tree, rtp_tree, payload_type);",
          "1215:   return;",
          "1216:  }",
          "1218:  seqno = p_conv_data->extended_seqno;",
          "1220:  pinfo->can_desegment = 2;",
          "1221:  pinfo->desegment_offset = 0;",
          "1222:  pinfo->desegment_len = 0;",
          "1225:  g_debug(\"%d: RTP Part of convo %d(%p); seqno %d\",",
          "1226:   pinfo->fd->num,",
          "1227:   p_conv_data->frame_number, p_conv_data,",
          "1228:   seqno",
          "1229:   );",
          "1233:  msp = (rtp_multisegment_pdu *)wmem_tree_lookup32_le(finfo->multisegment_pdus,seqno-1);",
          "1235:  if(msp && msp->startseq < seqno && msp->endseq >= seqno) {",
          "1236:   guint32 fid = msp->startseq;",
          "1237:   fragment_head *fd_head;",
          "1240:   g_debug(\"\\tContinues fragment %d\", fid);",
          "1247:   fd_head = fragment_add_seq(&rtp_reassembly_table,",
          "1248:         tvb, offset, pinfo, fid, NULL,",
          "1249:         seqno-msp->startseq, data_len,",
          "1250:         FALSE, 0);",
          "1252:   newtvb = process_reassembled_data(tvb,offset, pinfo, \"Reassembled RTP\", fd_head,",
          "1253:         &rtp_fragment_items, NULL, tree);",
          "1256:   g_debug(\"\\tFragment Coalesced; fd_head=%p, newtvb=%p (len %d)\",fd_head, newtvb,",
          "1257:    newtvb?tvb_reported_length(newtvb):0);",
          "1260:   if(newtvb != NULL) {",
          "1262:    process_rtp_payload(newtvb, pinfo, tree, rtp_tree, payload_type);",
          "1267:    if( pinfo->desegment_len && pinfo->desegment_offset == 0 )",
          "1268:    {",
          "1270:     g_debug(\"\\tNo complete pdus in payload\" );",
          "1273:     fragment_set_partial_reassembly(&rtp_reassembly_table,",
          "1274:         pinfo, fid, NULL);",
          "1277:     msp->endseq = MIN(msp->endseq,seqno) + 1;",
          "1278:    }",
          "1279:    else",
          "1280:    {",
          "1281:     if(pinfo->desegment_len)",
          "1282:     {",
          "1284:         the end of this segment does not coincide with the end of a",
          "1286:      must_desegment = TRUE;",
          "1287:     }",
          "1288:    }",
          "1290:   }",
          "1292:  }",
          "1293:  else",
          "1294:  {",
          "1300:   g_debug(\"\\tRTP non-fragment payload\");",
          "1302:   newtvb = tvb_new_subset( tvb, offset, data_len, data_reported_len );",
          "1305:   process_rtp_payload(newtvb, pinfo, tree, rtp_tree, payload_type);",
          "1307:   if(pinfo->desegment_len) {",
          "1309:       the end of this segment does not coincide with the end of a",
          "1311:    must_desegment = TRUE;",
          "1312:   }",
          "1313:  }",
          "1318:  if(must_desegment)",
          "1319:  {",
          "1320:   guint32 deseg_offset = pinfo->desegment_offset;",
          "1321:   guint32 frag_len = tvb_reported_length_remaining(newtvb, deseg_offset);",
          "1322:   fragment_head *fd_head = NULL;",
          "1325:   g_debug(\"\\tRTP Must Desegment: tvb_len=%d ds_len=%d %d frag_len=%d ds_off=%d\",",
          "1326:    tvb_reported_length(newtvb),",
          "1327:    pinfo->desegment_len,",
          "1328:    pinfo->fd->flags.visited,",
          "1329:    frag_len,",
          "1330:    deseg_offset);",
          "1333:   msp = wmem_new(wmem_file_scope(), rtp_multisegment_pdu);",
          "1334:   msp->startseq = seqno;",
          "1335:   msp->endseq = seqno+1;",
          "1336:   wmem_tree_insert32(finfo->multisegment_pdus,seqno,msp);",
          "1341:   fd_head = fragment_add_seq(&rtp_reassembly_table,",
          "1342:         newtvb, deseg_offset, pinfo, seqno, NULL, 0, frag_len,",
          "1343:         TRUE, 0);",
          "1345:   if(fd_head != NULL)",
          "1346:   {",
          "1347:    if( fd_head->reassembled_in != 0 && !(fd_head->flags & FD_PARTIAL_REASSEMBLY) )",
          "1348:    {",
          "1349:     proto_item *rtp_tree_item;",
          "1350:     rtp_tree_item = proto_tree_add_uint( tree, hf_rtp_reassembled_in,",
          "1351:              newtvb, deseg_offset, tvb_reported_length_remaining(newtvb,deseg_offset),",
          "1352:              fd_head->reassembled_in);",
          "1353:     PROTO_ITEM_SET_GENERATED(rtp_tree_item);",
          "1355:     g_debug(\"\\tReassembled in %d\", fd_head->reassembled_in);",
          "1357:    }",
          "1358:    else",
          "1359:    {",
          "1361:     g_debug(\"\\tUnfinished fragment\");",
          "1364:     proto_tree_add_text( tree, tvb, deseg_offset, -1,\"RTP fragment, unfinished\");",
          "1365:    }",
          "1366:   }",
          "1367:   else",
          "1368:   {",
          "1374:    g_debug(\"\\tnew pdu\");",
          "1376:   }",
          "1378:   if( pinfo->desegment_offset == 0 )",
          "1379:   {",
          "1380:    col_set_str(pinfo->cinfo, COL_PROTOCOL, \"RTP\");",
          "1381:    col_set_str(pinfo->cinfo, COL_INFO, \"[RTP segment of a reassembled PDU]\");",
          "1382:   }",
          "1383:  }",
          "1385:  pinfo->can_desegment = 0;",
          "1386:  pinfo->desegment_offset = 0;",
          "1387:  pinfo->desegment_len = 0;",
          "",
          "[Added Lines]",
          "1194:          proto_tree *rtp_tree, int offset, unsigned int data_len,",
          "1195:          unsigned int data_reported_len,",
          "1196:          unsigned int payload_type)",
          "1198:     tvbuff_t *newtvb;",
          "1199:     struct _rtp_conversation_info *p_conv_data= NULL;",
          "1200:     gboolean must_desegment = FALSE;",
          "1201:     rtp_private_conv_info *finfo = NULL;",
          "1202:     rtp_multisegment_pdu *msp = NULL;",
          "1203:     guint32 seqno;",
          "1206:     p_conv_data = (struct _rtp_conversation_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_rtp, 0);",
          "1208:     if(p_conv_data != NULL)",
          "1209:         finfo = p_conv_data->rtp_conv_info;",
          "1211:     if(finfo == NULL || !desegment_rtp) {",
          "1213:         newtvb=tvb_new_subset(tvb,offset,data_len,data_reported_len);",
          "1214:         process_rtp_payload(newtvb, pinfo, tree, rtp_tree, payload_type);",
          "1215:         return;",
          "1216:     }",
          "1218:     seqno = p_conv_data->extended_seqno;",
          "1220:     pinfo->can_desegment = 2;",
          "1221:     pinfo->desegment_offset = 0;",
          "1222:     pinfo->desegment_len = 0;",
          "1225:     g_debug(\"%d: RTP Part of convo %d(%p); seqno %d\",",
          "1226:         pinfo->fd->num,",
          "1227:         p_conv_data->frame_number, p_conv_data,",
          "1228:         seqno",
          "1229:         );",
          "1233:     msp = (rtp_multisegment_pdu *)wmem_tree_lookup32_le(finfo->multisegment_pdus,seqno-1);",
          "1235:     if(msp && msp->startseq < seqno && msp->endseq >= seqno) {",
          "1236:         guint32 fid = msp->startseq;",
          "1237:         fragment_head *fd_head;",
          "1240:         g_debug(\"\\tContinues fragment %d\", fid);",
          "1247:         fd_head = fragment_add_seq(&rtp_reassembly_table,",
          "1248:                        tvb, offset, pinfo, fid, NULL,",
          "1249:                        seqno-msp->startseq, data_len,",
          "1250:                        FALSE, 0);",
          "1252:         newtvb = process_reassembled_data(tvb,offset, pinfo, \"Reassembled RTP\", fd_head,",
          "1253:                           &rtp_fragment_items, NULL, tree);",
          "1256:         g_debug(\"\\tFragment Coalesced; fd_head=%p, newtvb=%p (len %d)\",fd_head, newtvb,",
          "1257:             newtvb?tvb_reported_length(newtvb):0);",
          "1260:         if(newtvb != NULL) {",
          "1262:             process_rtp_payload(newtvb, pinfo, tree, rtp_tree, payload_type);",
          "1267:             if( pinfo->desegment_len && pinfo->desegment_offset == 0 )",
          "1268:             {",
          "1270:                 g_debug(\"\\tNo complete pdus in payload\" );",
          "1273:                 fragment_set_partial_reassembly(&rtp_reassembly_table,",
          "1274:                                 pinfo, fid, NULL);",
          "1277:                 msp->endseq = MIN(msp->endseq,seqno) + 1;",
          "1278:             }",
          "1279:             else",
          "1280:             {",
          "1281:                 if(pinfo->desegment_len)",
          "1282:                 {",
          "1284:                        the end of this segment does not coincide with the end of a",
          "1286:                     must_desegment = TRUE;",
          "1287:                 }",
          "1288:             }",
          "1290:         }",
          "1292:     }",
          "1293:     else",
          "1294:     {",
          "1300:         g_debug(\"\\tRTP non-fragment payload\");",
          "1302:         newtvb = tvb_new_subset( tvb, offset, data_len, data_reported_len );",
          "1305:         process_rtp_payload(newtvb, pinfo, tree, rtp_tree, payload_type);",
          "1307:         if(pinfo->desegment_len) {",
          "1309:                the end of this segment does not coincide with the end of a",
          "1311:             must_desegment = TRUE;",
          "1312:         }",
          "1313:     }",
          "1318:     if(must_desegment)",
          "1319:     {",
          "1320:         guint32 deseg_offset = pinfo->desegment_offset;",
          "1321:         guint32 frag_len = tvb_reported_length_remaining(newtvb, deseg_offset);",
          "1322:         fragment_head *fd_head = NULL;",
          "1325:         g_debug(\"\\tRTP Must Desegment: tvb_len=%d ds_len=%d %d frag_len=%d ds_off=%d\",",
          "1326:             tvb_reported_length(newtvb),",
          "1327:             pinfo->desegment_len,",
          "1328:             pinfo->fd->flags.visited,",
          "1329:             frag_len,",
          "1330:             deseg_offset);",
          "1333:         msp = wmem_new(wmem_file_scope(), rtp_multisegment_pdu);",
          "1334:         msp->startseq = seqno;",
          "1335:         msp->endseq = seqno+1;",
          "1336:         wmem_tree_insert32(finfo->multisegment_pdus,seqno,msp);",
          "1341:         fd_head = fragment_add_seq(&rtp_reassembly_table,",
          "1342:                        newtvb, deseg_offset, pinfo, seqno, NULL, 0, frag_len,",
          "1343:                        TRUE, 0);",
          "1345:         if(fd_head != NULL)",
          "1346:         {",
          "1347:             if( fd_head->reassembled_in != 0 && !(fd_head->flags & FD_PARTIAL_REASSEMBLY) )",
          "1348:             {",
          "1349:                 proto_item *rtp_tree_item;",
          "1350:                 rtp_tree_item = proto_tree_add_uint( tree, hf_rtp_reassembled_in,",
          "1351:                                      newtvb, deseg_offset, tvb_reported_length_remaining(newtvb,deseg_offset),",
          "1352:                                      fd_head->reassembled_in);",
          "1353:                 PROTO_ITEM_SET_GENERATED(rtp_tree_item);",
          "1355:                 g_debug(\"\\tReassembled in %d\", fd_head->reassembled_in);",
          "1357:             }",
          "1358:             else",
          "1359:             {",
          "1361:                 g_debug(\"\\tUnfinished fragment\");",
          "1364:                 proto_tree_add_text( tree, tvb, deseg_offset, -1,\"RTP fragment, unfinished\");",
          "1365:             }",
          "1366:         }",
          "1367:         else",
          "1368:         {",
          "1374:             g_debug(\"\\tnew pdu\");",
          "1376:         }",
          "1378:         if( pinfo->desegment_offset == 0 )",
          "1379:         {",
          "1380:             col_set_str(pinfo->cinfo, COL_PROTOCOL, \"RTP\");",
          "1381:             col_set_str(pinfo->cinfo, COL_INFO, \"[RTP segment of a reassembled PDU]\");",
          "1382:         }",
          "1383:     }",
          "1385:     pinfo->can_desegment = 0;",
          "1386:     pinfo->desegment_offset = 0;",
          "1387:     pinfo->desegment_len = 0;",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1392: static void",
          "1393: dissect_rtp_rfc2198(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)",
          "1394: {",
          "1481: }",
          "1483: static void",
          "1484: dissect_rtp_hext_rfc5215_onebyte( tvbuff_t *tvb, packet_info *pinfo,",
          "1486: {",
          "1534: }",
          "1537: static void",
          "1538: dissect_rtp_hext_rfc5215_twobytes(tvbuff_t *parent_tvb, guint id_offset,",
          "1540: {",
          "1582: }",
          "1584: static gint",
          "1585: dissect_rtp( tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)",
          "1586: {",
          "1769: #endif",
          "2056: }",
          "2058: static void",
          "2059: dissect_rtp_hdr_ext_ed137(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree )",
          "2060: {",
          "2145: }",
          "2147: static void",
          "2148: dissect_rtp_hdr_ext_ed137a(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree )",
          "2149: {",
          "2212: }",
          "",
          "[Removed Lines]",
          "1395:  gint offset = 0;",
          "1396:  guint8 octet1;",
          "1397:  int cnt;",
          "1398:  gboolean hdr_follow = TRUE;",
          "1399:  proto_item *ti = NULL;",
          "1400:  proto_tree *rfc2198_tree = NULL;",
          "1401:  proto_tree *rfc2198_hdr_tree = NULL;",
          "1402:  rfc2198_hdr *hdr_last, *hdr_new;",
          "1403:  rfc2198_hdr *hdr_chain = NULL;",
          "1404:  struct _rtp_conversation_info *p_conv_data= NULL;",
          "1405:  gchar *payload_type_str;",
          "1408:  p_conv_data = (struct _rtp_conversation_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_rtp, 0);",
          "1411:  ti = proto_tree_add_text(tree, tvb, offset, -1, \"RFC 2198: Redundant Audio Data\");",
          "1412:  rfc2198_tree = proto_item_add_subtree(ti, ett_rtp_rfc2198);",
          "1414:  hdr_last = NULL;",
          "1415:  cnt = 0;",
          "1416:  while (hdr_follow) {",
          "1417:   cnt++;",
          "1418:   payload_type_str = NULL;",
          "1421:   hdr_new = wmem_new(wmem_packet_scope(), rfc2198_hdr);",
          "1422:   hdr_new->next = NULL;",
          "1423:   octet1 = tvb_get_guint8(tvb, offset);",
          "1424:   hdr_new->pt = RTP_PAYLOAD_TYPE(octet1);",
          "1425:   hdr_follow = (octet1 & 0x80);",
          "1428:   if ((hdr_new->pt > 95) && (hdr_new->pt < 128)) {",
          "1429:    if (p_conv_data && p_conv_data->rtp_dyn_payload){",
          "1430:     encoding_name_and_rate_t *encoding_name_and_rate_pt = NULL;",
          "1431:     encoding_name_and_rate_pt = (encoding_name_and_rate_t *)g_hash_table_lookup(p_conv_data->rtp_dyn_payload, &hdr_new->pt);",
          "1432:     if (encoding_name_and_rate_pt) {",
          "1433:      payload_type_str = encoding_name_and_rate_pt->encoding_name;",
          "1434:     }",
          "1435:    }",
          "1436:   }",
          "1438:   ti = proto_tree_add_text(rfc2198_tree, tvb, offset, (hdr_follow)?4:1, \"Header %u\", cnt);",
          "1439:   rfc2198_hdr_tree = proto_item_add_subtree(ti, ett_rtp_rfc2198_hdr);",
          "1440:   proto_tree_add_item(rfc2198_hdr_tree, hf_rtp_rfc2198_follow, tvb, offset, 1, ENC_BIG_ENDIAN );",
          "1441:   proto_tree_add_uint_format_value(rfc2198_hdr_tree, hf_rtp_payload_type, tvb,",
          "1442:       offset, 1, octet1, \"%s (%u)\",",
          "1443:    payload_type_str ? payload_type_str : val_to_str_ext_const(hdr_new->pt, &rtp_payload_type_vals_ext, \"Unknown\"),",
          "1444:    hdr_new->pt);",
          "1445:   proto_item_append_text(ti, \": PT=%s\",",
          "1446:            payload_type_str ? payload_type_str :",
          "1447:                               val_to_str_ext(hdr_new->pt, &rtp_payload_type_vals_ext, \"Unknown (%u)\"));",
          "1448:   offset += 1;",
          "1451:   if (hdr_follow) {",
          "1452:    proto_tree_add_item(rfc2198_hdr_tree, hf_rtp_rfc2198_tm_off, tvb, offset, 2, ENC_BIG_ENDIAN );",
          "1453:    proto_tree_add_item(rfc2198_hdr_tree, hf_rtp_rfc2198_bl_len, tvb, offset + 1, 2, ENC_BIG_ENDIAN );",
          "1454:    hdr_new->len = tvb_get_ntohs(tvb, offset + 1) & 0x03FF;",
          "1455:    proto_item_append_text(ti, \", len=%u\", hdr_new->len);",
          "1456:    offset += 3;",
          "1457:   } else {",
          "1458:    hdr_new->len = -1;",
          "1459:    hdr_follow = FALSE;",
          "1460:   }",
          "1462:   if (hdr_last) {",
          "1463:    hdr_last->next = hdr_new;",
          "1464:   } else {",
          "1465:    hdr_chain = hdr_new;",
          "1466:   }",
          "1467:   hdr_last = hdr_new;",
          "1468:  }",
          "1471:  hdr_last = hdr_chain;",
          "1472:  while (hdr_last) {",
          "1473:   hdr_last->offset = offset;",
          "1474:   if (!hdr_last->next) {",
          "1475:    hdr_last->len = tvb_reported_length_remaining(tvb, offset);",
          "1476:   }",
          "1477:   dissect_rtp_data(tvb, pinfo, tree, rfc2198_tree, hdr_last->offset, hdr_last->len, hdr_last->len, hdr_last->pt);",
          "1478:   offset += hdr_last->len;",
          "1479:   hdr_last = hdr_last->next;",
          "1480:  }",
          "1485:   proto_tree *rtp_hext_tree )",
          "1487:  proto_item *ti = NULL;",
          "1488:  proto_tree *rtp_hext_rfc5285_tree = NULL;",
          "1489:  guint ext_offset = 0, start_ext_offset;",
          "1491:  while (ext_offset < tvb_length (tvb)) {",
          "1492:   guint8 ext_hdr_hdr;",
          "1493:   guint8 ext_id;",
          "1494:   guint8 ext_length;",
          "1495:   tvbuff_t *subtvb = NULL;",
          "1498:   start_ext_offset = ext_offset;",
          "1499:   while (tvb_get_guint8 (tvb, ext_offset) == 0) {",
          "1500:    ext_offset ++;",
          "1501:    if (ext_offset >= tvb_length (tvb))",
          "1502:     return;",
          "1503:   }",
          "1506:   if (ext_offset > start_ext_offset)",
          "1507:    proto_tree_add_item(rtp_hext_tree, hf_rtp_padding_data, tvb, ext_offset, ext_offset-start_ext_offset, ENC_NA );",
          "1509:   ext_hdr_hdr = tvb_get_guint8 (tvb, ext_offset);",
          "1510:   ext_id = ext_hdr_hdr >> 4;",
          "1513:   if (ext_id == 15)",
          "1514:    return;",
          "1516:   ext_length = (ext_hdr_hdr & 0x0F) + 1;",
          "1517:   if (rtp_hext_tree) {",
          "1518:    ti = proto_tree_add_text(rtp_hext_tree, tvb, ext_offset, ext_length + 1, \"RFC 5285 Header Extension (One-Byte Header)\");",
          "1519:    rtp_hext_rfc5285_tree = proto_item_add_subtree( ti, ett_hdr_ext_rfc5285);",
          "1521:    proto_tree_add_uint( rtp_hext_rfc5285_tree, hf_rtp_ext_rfc5285_id, tvb, ext_offset, 1, ext_id);",
          "1522:    proto_tree_add_uint( rtp_hext_rfc5285_tree, hf_rtp_ext_rfc5285_length, tvb, ext_offset, 1, ext_length);",
          "1523:   }",
          "1524:   ext_offset ++;",
          "1526:   subtvb = tvb_new_subset(tvb, ext_offset, ext_length, ext_length);",
          "1527:   if (!dissector_try_uint (rtp_hdr_ext_rfc5285_dissector_table, ext_id, subtvb, pinfo, rtp_hext_rfc5285_tree)) {",
          "1528:    if (rtp_hext_tree)",
          "1529:     proto_tree_add_item(rtp_hext_rfc5285_tree, hf_rtp_ext_rfc5285_data, subtvb, 0, ext_length, ENC_NA );",
          "1530:   }",
          "1532:   ext_offset += ext_length;",
          "1533:  }",
          "1539:   guint8 id, tvbuff_t *tvb, packet_info *pinfo, proto_tree *rtp_hext_tree)",
          "1541:  proto_item *ti = NULL;",
          "1542:  proto_tree *rtp_hext_rfc5285_tree = NULL;",
          "1543:  guint ext_offset = 0, start_ext_offset;",
          "1545:  while (ext_offset + 2 < tvb_length (tvb)) {",
          "1546:   guint8 ext_id;",
          "1547:   guint8 ext_length;",
          "1548:   tvbuff_t *subtvb = NULL;",
          "1551:   start_ext_offset = ext_offset;",
          "1552:   while (tvb_get_guint8 (tvb, ext_offset) == 0) {",
          "1553:    if (ext_offset + 2 >= tvb_length (tvb))",
          "1554:     return;",
          "1555:    ext_offset ++;",
          "1556:   }",
          "1558:   if (ext_offset > start_ext_offset)",
          "1559:    proto_tree_add_item(rtp_hext_tree, hf_rtp_padding_data, tvb, ext_offset, ext_offset-start_ext_offset, ENC_NA );",
          "1561:   ext_id = tvb_get_guint8 (tvb, ext_offset);",
          "1562:   ext_length = tvb_get_guint8 (tvb, ext_offset + 1);",
          "1564:   if (rtp_hext_tree) {",
          "1565:    ti = proto_tree_add_text(rtp_hext_tree, tvb, ext_offset, ext_length + 2, \"RFC 5285 Header Extension (Two-Byte Header)\");",
          "1566:    rtp_hext_rfc5285_tree = proto_item_add_subtree( ti, ett_hdr_ext_rfc5285);",
          "1568:    proto_tree_add_uint( rtp_hext_rfc5285_tree, hf_rtp_ext_rfc5285_appbits, parent_tvb, id_offset + 1, 1, id & 0x000F);",
          "1569:    proto_tree_add_uint( rtp_hext_rfc5285_tree, hf_rtp_ext_rfc5285_id, tvb, ext_offset, 1, ext_id);",
          "1570:    proto_tree_add_uint( rtp_hext_rfc5285_tree, hf_rtp_ext_rfc5285_length, tvb, ext_offset + 1, 1, ext_length);",
          "1571:   }",
          "1573:   ext_offset += 2;",
          "1575:   subtvb = tvb_new_subset(tvb, ext_offset, ext_length, ext_length);",
          "1576:   if (ext_length && !dissector_try_uint (rtp_hdr_ext_rfc5285_dissector_table, ext_id, subtvb, pinfo, rtp_hext_rfc5285_tree)) {",
          "1577:    proto_tree_add_item(rtp_hext_rfc5285_tree, hf_rtp_ext_rfc5285_data, subtvb, 0, ext_length, ENC_NA );",
          "1578:   }",
          "1580:   ext_offset += ext_length;",
          "1581:  }",
          "1587:  proto_item *ti            = NULL;",
          "1588:  proto_tree *volatile rtp_tree = NULL;",
          "1589:  proto_tree *rtp_csrc_tree = NULL;",
          "1590:  proto_tree *rtp_hext_tree = NULL;",
          "1591:  guint8      octet1, octet2;",
          "1592:  unsigned int version;",
          "1593:  gboolean    padding_set;",
          "1594:  gboolean    extension_set;",
          "1595:  unsigned int csrc_count;",
          "1596:  gboolean    marker_set;",
          "1597:  unsigned int payload_type;",
          "1598:  gchar *payload_type_str = NULL;",
          "1599:  gboolean    is_srtp = FALSE;",
          "1600:  unsigned int i            = 0;",
          "1601:  unsigned int hdr_extension_len= 0;",
          "1602:  unsigned int hdr_extension_id = 0;",
          "1603:  volatile unsigned int padding_count;",
          "1604:  gint        length, reported_length;",
          "1605:  int         data_len;",
          "1606:  volatile unsigned int offset = 0;",
          "1607:  guint16     seq_num;",
          "1608:  guint32     timestamp;",
          "1609:  guint32     sync_src;",
          "1610:  guint32     csrc_item;",
          "1611:  struct _rtp_conversation_info *p_conv_data = NULL;",
          "1614:  unsigned int hdrext_offset = 0;",
          "1615:  tvbuff_t     *newtvb = NULL;",
          "1616:  const char   *pt = NULL;",
          "1618:  static struct _rtp_info rtp_info_arr[4];",
          "1619:  static int rtp_info_current=0;",
          "1620:  struct _rtp_info *rtp_info;",
          "1622:  rtp_info_current++;",
          "1623:  if (rtp_info_current==4) {",
          "1624:   rtp_info_current=0;",
          "1625:  }",
          "1626:  rtp_info = &rtp_info_arr[rtp_info_current];",
          "1629:  octet1 = tvb_get_guint8( tvb, offset );",
          "1630:  version = RTP_VERSION( octet1 );",
          "1632:  if (version == 0) {",
          "1633:   switch (global_rtp_version0_type) {",
          "1634:   case RTP0_STUN:",
          "1635:    call_dissector(stun_handle, tvb, pinfo, tree);",
          "1636:    return tvb_length(tvb);",
          "1637:   case RTP0_CLASSICSTUN:",
          "1638:    call_dissector(classicstun_handle, tvb, pinfo, tree);",
          "1639:    return tvb_length(tvb);",
          "1641:   case RTP0_T38:",
          "1642:    call_dissector(t38_handle, tvb, pinfo, tree);",
          "1643:    return tvb_length(tvb);",
          "1645:   case RTP0_SPRT:",
          "1646:    call_dissector(sprt_handle, tvb, pinfo, tree);",
          "1647:    return tvb_length(tvb);",
          "1649:   case RTP0_INVALID:",
          "1650:    if (!(tvb_memeql(tvb, 4, \"ZRTP\", 4)))",
          "1651:    {",
          "1652:     call_dissector(zrtp_handle,tvb,pinfo,tree);",
          "1653:     return tvb_length(tvb);",
          "1654:    }",
          "1655:   default:",
          "1657:   }",
          "1658:  }",
          "1661:  rtp_info->info_version = version;",
          "1662:  if (version != 2) {",
          "1666:   col_set_str(pinfo->cinfo, COL_PROTOCOL, \"RTP\");",
          "1668:   col_add_fstr( pinfo->cinfo, COL_INFO,",
          "1669:       \"Unknown RTP version %u\", version);",
          "1671:   if ( tree ) {",
          "1672:    ti = proto_tree_add_item( tree, proto_rtp, tvb, offset, -1, ENC_NA );",
          "1673:    rtp_tree = proto_item_add_subtree( ti, ett_rtp );",
          "1675:    proto_tree_add_uint( rtp_tree, hf_rtp_version, tvb,",
          "1676:        offset, 1, octet1);",
          "1677:   }",
          "1678:   return offset;",
          "1679:  }",
          "1681:  padding_set = RTP_PADDING( octet1 );",
          "1682:  extension_set = RTP_EXTENSION( octet1 );",
          "1683:  csrc_count = RTP_CSRC_COUNT( octet1 );",
          "1686:  octet2 = tvb_get_guint8( tvb, offset + 1 );",
          "1687:  marker_set = RTP_MARKER( octet2 );",
          "1688:  payload_type = RTP_PAYLOAD_TYPE( octet2 );",
          "1690:  if (marker_set && payload_type >= FIRST_RTCP_CONFLICT_PAYLOAD_TYPE && payload_type <=  LAST_RTCP_CONFLICT_PAYLOAD_TYPE) {",
          "1691:   call_dissector(rtcp_handle, tvb, pinfo, tree);",
          "1692:   return tvb_length(tvb);",
          "1693:  }",
          "1696:  seq_num = tvb_get_ntohs( tvb, offset + 2 );",
          "1697:  timestamp = tvb_get_ntohl( tvb, offset + 4 );",
          "1698:  sync_src = tvb_get_ntohl( tvb, offset + 8 );",
          "1701:  rtp_info->info_padding_set = padding_set;",
          "1702:  rtp_info->info_padding_count = 0;",
          "1703:  rtp_info->info_marker_set = marker_set;",
          "1704:  rtp_info->info_is_video = FALSE;",
          "1705:  rtp_info->info_payload_type = payload_type;",
          "1706:  rtp_info->info_seq_num = seq_num;",
          "1707:  rtp_info->info_timestamp = timestamp;",
          "1708:  rtp_info->info_sync_src = sync_src;",
          "1709:  rtp_info->info_is_srtp = FALSE;",
          "1710:  rtp_info->info_setup_frame_num = 0;",
          "1711:  rtp_info->info_payload_type_str = NULL;",
          "1712:  rtp_info->info_payload_rate = 0;",
          "1717:  length = tvb_length_remaining(tvb, offset);",
          "1718:  reported_length = tvb_reported_length_remaining(tvb, offset);",
          "1719:  if (reported_length >= 0 && length >= reported_length) {",
          "1723:   rtp_info->info_all_data_present = TRUE;",
          "1724:   rtp_info->info_data_len = reported_length;",
          "1737:   rtp_info->info_data = tvb_get_ptr(tvb, 0, -1);",
          "1738:  } else {",
          "1742:   rtp_info->info_all_data_present = FALSE;",
          "1743:   rtp_info->info_data_len = 0;",
          "1744:   rtp_info->info_data = NULL;",
          "1745:  }",
          "1748:  get_conv_info(pinfo, rtp_info);",
          "1749:  p_conv_data = (struct _rtp_conversation_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_rtp, 0);",
          "1751:  if (p_conv_data)",
          "1752:   rtp_info->info_is_video = p_conv_data->is_video;",
          "1754:  if (p_conv_data && p_conv_data->srtp_info) is_srtp = TRUE;",
          "1755:  rtp_info->info_is_srtp = is_srtp;",
          "1757:  col_set_str( pinfo->cinfo, COL_PROTOCOL, (is_srtp) ? \"SRTP\" : \"RTP\" );",
          "1760:  p_conv_data = (struct _rtp_conversation_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_rtp, 0);",
          "1763:  if (p_conv_data && p_conv_data->srtp_info) {",
          "1764:   srtp_info = p_conv_data->srtp_info;",
          "1765:   if (rtp_info->info_all_data_present) {",
          "1766:    srtp_offset = rtp_info->info_data_len - srtp_info->mki_len - srtp_info->auth_tag_len;",
          "1767:   }",
          "1768:  }",
          "1771:  if (p_conv_data && p_conv_data->bta2dp_info && p_conv_data->bta2dp_info->codec_dissector) {",
          "1772:   rtp_info->info_payload_type_str = (const char *) dissector_handle_get_short_name(p_conv_data->bta2dp_info->codec_dissector);",
          "1773:  } else if (p_conv_data && p_conv_data->btvdp_info && p_conv_data->btvdp_info->codec_dissector) {",
          "1774:   rtp_info->info_payload_type_str = (const char *) dissector_handle_get_short_name(p_conv_data->btvdp_info->codec_dissector);",
          "1775:  }",
          "1778:  if ( (payload_type>95) && (payload_type<128) ) {",
          "1779:   if (p_conv_data && p_conv_data->rtp_dyn_payload){",
          "1780:    encoding_name_and_rate_t *encoding_name_and_rate_pt = NULL;",
          "1781:    encoding_name_and_rate_pt = (encoding_name_and_rate_t *)g_hash_table_lookup(p_conv_data->rtp_dyn_payload, &payload_type);",
          "1782:    if (encoding_name_and_rate_pt) {",
          "1783:     rtp_info->info_payload_type_str = payload_type_str = encoding_name_and_rate_pt->encoding_name;",
          "1784:     rtp_info->info_payload_rate = encoding_name_and_rate_pt->sample_rate;",
          "1785:    }",
          "1786:   }",
          "1787:  }",
          "1789:  if (p_conv_data && p_conv_data->bta2dp_info) {",
          "1790:   pt = (p_conv_data->bta2dp_info->codec_dissector) ? dissector_handle_get_short_name(p_conv_data->bta2dp_info->codec_dissector) : \"Unknown\";",
          "1791:  } else if (p_conv_data && p_conv_data->btvdp_info) {",
          "1792:   pt = (p_conv_data->btvdp_info->codec_dissector) ? dissector_handle_get_short_name(p_conv_data->btvdp_info->codec_dissector) : \"Unknown\";",
          "1793:  } else {",
          "1794:   pt = (payload_type_str ? payload_type_str : val_to_str_ext(payload_type, &rtp_payload_type_vals_ext,\"Unknown (%u)\"));",
          "1795:  }",
          "1797:  col_add_fstr( pinfo->cinfo, COL_INFO,",
          "1798:      \"PT=%s, SSRC=0x%X, Seq=%u, Time=%u%s\",",
          "1799:   pt,",
          "1800:      sync_src,",
          "1801:      seq_num,",
          "1802:      timestamp,",
          "1803:      marker_set ? \", Mark\" : \"\");",
          "1805:  if ( tree ) {",
          "1806:   proto_tree *item;",
          "1808:   ti = proto_tree_add_item(tree, proto_rtp, tvb, offset, -1, ENC_NA );",
          "1809:   rtp_tree = proto_item_add_subtree(ti, ett_rtp );",
          "1812:   if (global_rtp_show_setup_info)",
          "1813:   {",
          "1814:    show_setup_info(tvb, pinfo, rtp_tree);",
          "1815:   }",
          "1817:   proto_tree_add_uint( rtp_tree, hf_rtp_version, tvb,",
          "1818:       offset, 1, octet1 );",
          "1819:   proto_tree_add_boolean( rtp_tree, hf_rtp_padding, tvb,",
          "1820:       offset, 1, octet1 );",
          "1821:   proto_tree_add_boolean( rtp_tree, hf_rtp_extension, tvb,",
          "1822:       offset, 1, octet1 );",
          "1823:   proto_tree_add_uint( rtp_tree, hf_rtp_csrc_count, tvb,",
          "1824:       offset, 1, octet1 );",
          "1825:   offset++;",
          "1827:   proto_tree_add_boolean( rtp_tree, hf_rtp_marker, tvb, offset,",
          "1828:       1, octet2 );",
          "1830:   proto_tree_add_uint_format( rtp_tree, hf_rtp_payload_type, tvb,",
          "1831:       offset, 1, octet2, \"Payload type: %s (%u)\", pt, payload_type);",
          "1833:   offset++;",
          "1836:   proto_tree_add_uint( rtp_tree, hf_rtp_seq_nr, tvb, offset, 2, seq_num );",
          "1837:   if(p_conv_data != NULL) {",
          "1838:    item = proto_tree_add_uint( rtp_tree, hf_rtp_ext_seq_nr, tvb, offset, 2, p_conv_data->extended_seqno );",
          "1839:    PROTO_ITEM_SET_GENERATED(item);",
          "1840:   }",
          "1841:   offset += 2;",
          "1844:   proto_tree_add_uint( rtp_tree, hf_rtp_timestamp, tvb, offset, 4, timestamp );",
          "1845:   offset += 4;",
          "1848:   proto_tree_add_uint( rtp_tree, hf_rtp_ssrc, tvb, offset, 4, sync_src );",
          "1849:   offset += 4;",
          "1850:  } else {",
          "1851:   offset += 12;",
          "1852:  }",
          "1854:  if ( csrc_count > 0 ) {",
          "1855:   ti = proto_tree_add_item(rtp_tree, hf_rtp_csrc_items, tvb, offset,",
          "1856:                             csrc_count * 4, ENC_NA);",
          "1857:   proto_item_append_text(ti, \" (%u items)\", csrc_count);",
          "1858:   rtp_csrc_tree = proto_item_add_subtree( ti, ett_csrc_list );",
          "1860:   for (i = 0; i < csrc_count; i++ ) {",
          "1861:    csrc_item = tvb_get_ntohl( tvb, offset );",
          "1862:    proto_tree_add_uint_format( rtp_csrc_tree,",
          "1863:        hf_rtp_csrc_item, tvb, offset, 4,",
          "1864:        csrc_item,",
          "1865:        \"CSRC item %d: 0x%X\",",
          "1866:        i, csrc_item );",
          "1867:    offset += 4;",
          "1868:   }",
          "1869:  }",
          "1872:  if ( extension_set ) {",
          "1874:   hdr_extension_id = tvb_get_ntohs( tvb, offset );",
          "1875:   if ( tree ) proto_tree_add_uint( rtp_tree, hf_rtp_prof_define, tvb, offset, 2, hdr_extension_id );",
          "1876:   offset += 2;",
          "1878:   hdr_extension_len = tvb_get_ntohs( tvb, offset );",
          "1879:   if ( tree ) proto_tree_add_uint( rtp_tree, hf_rtp_length, tvb, offset, 2, hdr_extension_len);",
          "1880:   offset += 2;",
          "1881:   if ( hdr_extension_len > 0 ) {",
          "1882:    if ( tree ) {",
          "1883:     ti = proto_tree_add_item(rtp_tree, hf_rtp_hdr_exts, tvb, offset, hdr_extension_len * 4, ENC_NA);",
          "1884:     rtp_hext_tree = proto_item_add_subtree( ti, ett_hdr_ext );",
          "1885:    }",
          "1888:    newtvb = tvb_new_subset(tvb, offset, hdr_extension_len * 4, hdr_extension_len * 4);",
          "1890:    if (hdr_extension_id == RTP_RFC5215_ONE_BYTE_SIG) {",
          "1891:     dissect_rtp_hext_rfc5215_onebyte (newtvb, pinfo, rtp_hext_tree);",
          "1892:     }",
          "1893:    else if ((hdr_extension_id & RTP_RFC5215_TWO_BYTE_MASK) == RTP_RFC5215_TWO_BYTE_SIG) {",
          "1894:     dissect_rtp_hext_rfc5215_twobytes(tvb,",
          "1895:      offset - 4, hdr_extension_id, newtvb,",
          "1896:      pinfo, rtp_hext_tree);",
          "1897:    }",
          "1898:     else {",
          "1899:     if ( !(dissector_try_uint(rtp_hdr_ext_dissector_table, hdr_extension_id, newtvb, pinfo, rtp_hext_tree)) ) {",
          "1900:      hdrext_offset = offset;",
          "1901:      for ( i = 0; i < hdr_extension_len; i++ ) {",
          "1902:       if ( tree ) proto_tree_add_uint( rtp_hext_tree, hf_rtp_hdr_ext, tvb, hdrext_offset, 4, tvb_get_ntohl( tvb, hdrext_offset ) );",
          "1903:       hdrext_offset += 4;",
          "1904:      }",
          "1905:     }",
          "1906:    }",
          "1907:   }",
          "1908:   offset += hdr_extension_len * 4;",
          "1909:  }",
          "1911:  if ( padding_set ) {",
          "1919:   if (tvb_length(tvb) < tvb_reported_length(tvb)) {",
          "1929:    if ( tree ) proto_tree_add_text(rtp_tree, tvb, 0, 0,",
          "1930:        \"Frame has padding, but not all the frame data was captured\");",
          "1931:    call_dissector(data_handle,",
          "1932:        tvb_new_subset_remaining(tvb, offset),",
          "1933:        pinfo, rtp_tree);",
          "1934:    return tvb_length(tvb);",
          "1935:   }",
          "1937:   padding_count = tvb_get_guint8( tvb,",
          "1938:       tvb_reported_length( tvb ) - 1 );",
          "1939:   data_len =",
          "1940:       tvb_reported_length_remaining( tvb, offset ) - padding_count;",
          "1942:   rtp_info->info_payload_offset = offset;",
          "1943:   rtp_info->info_payload_len = tvb_length_remaining(tvb, offset);",
          "1944:   rtp_info->info_padding_count = padding_count;",
          "1946:   if (p_conv_data && p_conv_data->bta2dp_info) {",
          "1947:    if (p_conv_data->bta2dp_info->codec_dissector == sbc_handle) {",
          "1948:     rtp_info->info_payload_offset += 1;",
          "1949:     rtp_info->info_payload_len -= 1;",
          "1950:    }",
          "1952:    if (p_conv_data->bta2dp_info->content_protection_type == BTAVDTP_CONTENT_PROTECTION_TYPE_SCMS_T) {",
          "1953:     rtp_info->info_payload_offset += 1;",
          "1954:     rtp_info->info_payload_len -= 1;",
          "1955:    }",
          "1956:   }",
          "1958:   if (p_conv_data && p_conv_data->btvdp_info &&",
          "1959:     p_conv_data->bta2dp_info->content_protection_type == BTAVDTP_CONTENT_PROTECTION_TYPE_SCMS_T) {",
          "1960:    rtp_info->info_payload_offset += 1;",
          "1961:    rtp_info->info_payload_len -= 1;",
          "1962:   }",
          "1964:   if (data_len > 0) {",
          "1970:    TRY {",
          "1971:     dissect_rtp_data( tvb, pinfo, tree, rtp_tree,",
          "1972:         offset,",
          "1973:         data_len,",
          "1974:         data_len,",
          "1975:         payload_type);",
          "1976:    } CATCH_ALL {",
          "1977:     if (!pinfo->flags.in_error_pkt)",
          "1978:      tap_queue_packet(rtp_tap, pinfo, rtp_info);",
          "1979:     RETHROW;",
          "1980:    }",
          "1981:    ENDTRY;",
          "1982:    offset += data_len;",
          "1983:   } else if (data_len < 0) {",
          "1992:    padding_count =",
          "1993:        tvb_reported_length_remaining(tvb, offset);",
          "1994:   }",
          "1995:   if (padding_count > 1) {",
          "2001:    if ( tree ) proto_tree_add_item( rtp_tree, hf_rtp_padding_data,",
          "2002:        tvb, offset, padding_count - 1, ENC_NA );",
          "2003:    offset += padding_count - 1;",
          "2004:   }",
          "2009:   if ( tree ) proto_tree_add_item( rtp_tree, hf_rtp_padding_count,",
          "2010:       tvb, offset, 1, ENC_BIG_ENDIAN );",
          "2011:  }",
          "2012:  else {",
          "2016:   rtp_info->info_payload_offset = offset;",
          "2017:   rtp_info->info_payload_len = tvb_length_remaining(tvb, offset);",
          "2019:   if (p_conv_data && p_conv_data->bta2dp_info) {",
          "2020:    if (p_conv_data->bta2dp_info->codec_dissector == sbc_handle) {",
          "2021:     rtp_info->info_payload_offset += 1;",
          "2022:     rtp_info->info_payload_len -= 1;",
          "2023:    }",
          "2025:    if (p_conv_data->bta2dp_info->content_protection_type == BTAVDTP_CONTENT_PROTECTION_TYPE_SCMS_T) {",
          "2026:     rtp_info->info_payload_offset += 1;",
          "2027:     rtp_info->info_payload_len -= 1;",
          "2028:    }",
          "2029:   }",
          "2031:   if (p_conv_data && p_conv_data->btvdp_info &&",
          "2032:     p_conv_data->bta2dp_info->content_protection_type == BTAVDTP_CONTENT_PROTECTION_TYPE_SCMS_T) {",
          "2033:    rtp_info->info_payload_offset += 1;",
          "2034:    rtp_info->info_payload_len -= 1;",
          "2035:   }",
          "2037:   if (tvb_reported_length_remaining(tvb, offset) > 0) {",
          "2039:    TRY {",
          "2040:     dissect_rtp_data( tvb, pinfo, tree, rtp_tree, offset,",
          "2041:         tvb_length_remaining( tvb, offset ),",
          "2042:         tvb_reported_length_remaining( tvb, offset ),",
          "2043:         payload_type);",
          "2044:    } CATCH_ALL {",
          "2045:     if (!pinfo->flags.in_error_pkt)",
          "2046:      tap_queue_packet(rtp_tap, pinfo, rtp_info);",
          "2047:     RETHROW;",
          "2048:    }",
          "2049:    ENDTRY;",
          "2050:   }",
          "2051:  }",
          "2052:  if (!pinfo->flags.in_error_pkt)",
          "2053:   tap_queue_packet(rtp_tap, pinfo, rtp_info);",
          "2055:  return offset;",
          "2061:  unsigned int offset = 0;",
          "2062:  unsigned int hdr_extension_len = 0;",
          "2063:  proto_item *ti            = NULL;",
          "2064:  proto_item *ti2           = NULL;",
          "2065:  proto_tree *rtp_hext_tree = NULL;",
          "2066:  proto_tree *rtp_hext_tree2 = NULL;",
          "2067:  unsigned int i;",
          "2068:  guint32 ext_value;",
          "2069:  unsigned int ft_type = 0;",
          "2070:  unsigned int bss_qidx = 0;",
          "2071:  unsigned int bss_qidx_ml = 0;",
          "2073:  hdr_extension_len = tvb_reported_length(tvb)/4;",
          "2075:  if ( hdr_extension_len > 0 ) {",
          "2076:   unsigned int hdrext_offset = 0;",
          "2078:   if ( tree ) {",
          "2079:     ti = proto_tree_add_item(tree, hf_rtp_hdr_ed137s, tvb, offset, hdr_extension_len * 4, ENC_NA);",
          "2080:     rtp_hext_tree = proto_item_add_subtree( ti, ett_hdr_ext_ed137s );",
          "2081:   }",
          "2082:   for(i=0; i<hdr_extension_len; i++) {",
          "2083:    if ( tree ) {",
          "2084:     ti2 = proto_tree_add_item(rtp_hext_tree, hf_rtp_hdr_ed137, tvb, hdrext_offset, 4, ENC_NA);",
          "2085:     rtp_hext_tree2 = proto_item_add_subtree( ti2, ett_hdr_ext_ed137 );",
          "2086:     ext_value=tvb_get_ntohl( tvb, hdrext_offset );",
          "2088:     if (RTP_ED137_ptt_mask(ext_value)) {",
          "2089:      col_append_str(pinfo->cinfo, COL_INFO, \", PTT\");",
          "2090:     }",
          "2091:     if (RTP_ED137_squ_mask(ext_value)) {",
          "2092:      col_append_str(pinfo->cinfo, COL_INFO, \", SQU\");",
          "2093:     }",
          "2096:     proto_tree_add_item( rtp_hext_tree2, hf_rtp_hdr_ed137_ptt_type, tvb, hdrext_offset, 4, ENC_BIG_ENDIAN);",
          "2097:     proto_tree_add_item( rtp_hext_tree2, hf_rtp_hdr_ed137_squ, tvb, hdrext_offset, 4, ENC_BIG_ENDIAN);",
          "2098:     proto_tree_add_item( rtp_hext_tree2, hf_rtp_hdr_ed137_ptt_id, tvb, hdrext_offset, 4, ENC_BIG_ENDIAN);",
          "2099:     proto_tree_add_item( rtp_hext_tree2, hf_rtp_hdr_ed137_sct, tvb, hdrext_offset, 4, ENC_BIG_ENDIAN);",
          "2100:     proto_tree_add_item( rtp_hext_tree2, hf_rtp_hdr_ed137_x, tvb, hdrext_offset, 4, ENC_BIG_ENDIAN);",
          "2102:     if (RTP_ED137_extended_information(ext_value)) {",
          "2104:      proto_tree_add_item( rtp_hext_tree2, hf_rtp_hdr_ed137_ft_type, tvb, hdrext_offset, 4, ENC_BIG_ENDIAN);",
          "2105:      proto_tree_add_item( rtp_hext_tree2, hf_rtp_hdr_ed137_ft_len, tvb, hdrext_offset, 4, ENC_BIG_ENDIAN);",
          "2107:      ft_type=RTP_ED137_feature_type(ext_value);",
          "2108:      switch (ft_type) {",
          "2109:       case RTP_ED137_feature_bss_type:",
          "2110:        bss_qidx=RTP_ED137_feature_bss_qidx(ext_value);",
          "2111:        bss_qidx_ml=RTP_ED137_feature_bss_qidx_ml(ext_value);",
          "2112:        if (0==bss_qidx_ml) {",
          "2114:         if (bss_qidx<=15) {",
          "2116:          proto_tree_add_item( rtp_hext_tree2, hf_rtp_hdr_ed137_ft_bss_rssi_qidx, tvb, hdrext_offset, 4, ENC_BIG_ENDIAN);",
          "2117:         }",
          "2118:         else {",
          "2120:          proto_tree_add_item( rtp_hext_tree2, hf_rtp_hdr_ed137_ft_bss_qidx, tvb, hdrext_offset, 4, ENC_BIG_ENDIAN);",
          "2121:         }",
          "2122:        }",
          "2123:        else {",
          "2125:         proto_tree_add_item( rtp_hext_tree2, hf_rtp_hdr_ed137_ft_bss_qidx, tvb, hdrext_offset, 4, ENC_BIG_ENDIAN);",
          "2126:        }",
          "2127:        proto_tree_add_item( rtp_hext_tree2, hf_rtp_hdr_ed137_ft_bss_qidx_ml, tvb, hdrext_offset, 4, ENC_BIG_ENDIAN);",
          "2128:        proto_tree_add_item( rtp_hext_tree2, hf_rtp_hdr_ed137_ft_bss_nu, tvb, hdrext_offset, 4, ENC_BIG_ENDIAN);",
          "2129:        break;",
          "2130:       default:",
          "2131:        proto_tree_add_item( rtp_hext_tree2, hf_rtp_hdr_ed137_ft_value, tvb, hdrext_offset, 4, ENC_BIG_ENDIAN);",
          "2132:        break;",
          "2133:      }",
          "2134:     }",
          "2135:     else {",
          "2137:      proto_tree_add_item( rtp_hext_tree2, hf_rtp_hdr_ed137_x_nu, tvb, hdrext_offset, 4, ENC_BIG_ENDIAN);",
          "2138:     }",
          "2140:     proto_tree_add_item( rtp_hext_tree2, hf_rtp_hdr_ed137_vf, tvb, hdrext_offset, 4, ENC_BIG_ENDIAN);",
          "2141:    }",
          "2142:    hdrext_offset += 4;",
          "2143:   }",
          "2144:  }",
          "2150:  unsigned int offset = 0;",
          "2151:  unsigned int hdr_extension_len = 0;",
          "2152:  proto_item *ti            = NULL;",
          "2153:  proto_item *ti2           = NULL;",
          "2154:  proto_tree *rtp_hext_tree = NULL;",
          "2155:  proto_tree *rtp_hext_tree2 = NULL;",
          "2156:  unsigned int i;",
          "2157:  guint32 ext_value;",
          "2158:  unsigned int ft_type = 0;",
          "2160:  hdr_extension_len = tvb_reported_length(tvb)/4;",
          "2162:  if ( hdr_extension_len > 0 ) {",
          "2163:   unsigned int hdrext_offset = 0;",
          "2165:   if ( tree ) {",
          "2166:    ti = proto_tree_add_item(tree, hf_rtp_hdr_ed137s, tvb, offset, hdr_extension_len * 4, ENC_NA);",
          "2167:    rtp_hext_tree = proto_item_add_subtree( ti, ett_hdr_ext_ed137s );",
          "2168:   }",
          "2169:   for(i=0; i<hdr_extension_len; i++) {",
          "2170:    if ( tree ) {",
          "2171:     ti2 = proto_tree_add_item(rtp_hext_tree, hf_rtp_hdr_ed137a, tvb, hdrext_offset, 4, ENC_NA);",
          "2172:     rtp_hext_tree2 = proto_item_add_subtree( ti2, ett_hdr_ext_ed137a );",
          "2173:     ext_value=tvb_get_ntohl( tvb, hdrext_offset );",
          "2175:     if (RTP_ED137A_ptt_mask(ext_value)) {",
          "2176:      col_append_str(pinfo->cinfo, COL_INFO, \", PTT\");",
          "2177:     }",
          "2178:     if (RTP_ED137A_squ_mask(ext_value)) {",
          "2179:      col_append_str(pinfo->cinfo, COL_INFO, \", SQU\");",
          "2180:     }",
          "2183:     proto_tree_add_item( rtp_hext_tree2, hf_rtp_hdr_ed137a_ptt_type, tvb, hdrext_offset, 4, ENC_BIG_ENDIAN);",
          "2184:     proto_tree_add_item( rtp_hext_tree2, hf_rtp_hdr_ed137a_squ, tvb, hdrext_offset, 4, ENC_BIG_ENDIAN);",
          "2185:     proto_tree_add_item( rtp_hext_tree2, hf_rtp_hdr_ed137a_ptt_id, tvb, hdrext_offset, 4, ENC_BIG_ENDIAN);",
          "2186:     proto_tree_add_item( rtp_hext_tree2, hf_rtp_hdr_ed137a_pm, tvb, hdrext_offset, 4, ENC_BIG_ENDIAN);",
          "2187:     proto_tree_add_item( rtp_hext_tree2, hf_rtp_hdr_ed137a_ptts, tvb, hdrext_offset, 4, ENC_BIG_ENDIAN);",
          "2188:     proto_tree_add_item( rtp_hext_tree2, hf_rtp_hdr_ed137a_sct, tvb, hdrext_offset, 4, ENC_BIG_ENDIAN);",
          "2189:     proto_tree_add_item( rtp_hext_tree2, hf_rtp_hdr_ed137a_reserved, tvb, hdrext_offset, 4, ENC_BIG_ENDIAN);",
          "2190:     proto_tree_add_item( rtp_hext_tree2, hf_rtp_hdr_ed137a_x, tvb, hdrext_offset, 4, ENC_BIG_ENDIAN);",
          "2192:     if (RTP_ED137A_extended_information(ext_value)) {",
          "2194:      proto_tree_add_item( rtp_hext_tree2, hf_rtp_hdr_ed137a_ft_type, tvb, hdrext_offset, 4, ENC_BIG_ENDIAN);",
          "2195:      proto_tree_add_item( rtp_hext_tree2, hf_rtp_hdr_ed137a_ft_len, tvb, hdrext_offset, 4, ENC_BIG_ENDIAN);",
          "2197:      ft_type=RTP_ED137A_feature_type(ext_value);",
          "2198:      switch (ft_type) {",
          "2199:       default:",
          "2200:        proto_tree_add_item( rtp_hext_tree2, hf_rtp_hdr_ed137a_ft_value, tvb, hdrext_offset, 4, ENC_BIG_ENDIAN);",
          "2201:        break;",
          "2202:      }",
          "2203:     }",
          "2204:     else {",
          "2206:      proto_tree_add_item( rtp_hext_tree2, hf_rtp_hdr_ed137a_x_nu, tvb, hdrext_offset, 4, ENC_BIG_ENDIAN);",
          "2207:     }",
          "2208:    }",
          "2209:    hdrext_offset += 4;",
          "2210:   }",
          "2211:  }",
          "",
          "[Added Lines]",
          "1395:     gint offset = 0;",
          "1396:     guint8 octet1;",
          "1397:     int cnt;",
          "1398:     gboolean hdr_follow = TRUE;",
          "1399:     proto_item *ti = NULL;",
          "1400:     proto_tree *rfc2198_tree = NULL;",
          "1401:     proto_tree *rfc2198_hdr_tree = NULL;",
          "1402:     rfc2198_hdr *hdr_last, *hdr_new;",
          "1403:     rfc2198_hdr *hdr_chain = NULL;",
          "1404:     struct _rtp_conversation_info *p_conv_data= NULL;",
          "1405:     gchar *payload_type_str;",
          "1408:     p_conv_data = (struct _rtp_conversation_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_rtp, 0);",
          "1411:     ti = proto_tree_add_text(tree, tvb, offset, -1, \"RFC 2198: Redundant Audio Data\");",
          "1412:     rfc2198_tree = proto_item_add_subtree(ti, ett_rtp_rfc2198);",
          "1414:     hdr_last = NULL;",
          "1415:     cnt = 0;",
          "1416:     while (hdr_follow) {",
          "1417:         cnt++;",
          "1418:         payload_type_str = NULL;",
          "1421:         hdr_new = wmem_new(wmem_packet_scope(), rfc2198_hdr);",
          "1422:         hdr_new->next = NULL;",
          "1423:         octet1 = tvb_get_guint8(tvb, offset);",
          "1424:         hdr_new->pt = RTP_PAYLOAD_TYPE(octet1);",
          "1425:         hdr_follow = (octet1 & 0x80);",
          "1428:         if ((hdr_new->pt > 95) && (hdr_new->pt < 128)) {",
          "1429:             if (p_conv_data && p_conv_data->rtp_dyn_payload){",
          "1430:                 encoding_name_and_rate_t *encoding_name_and_rate_pt = NULL;",
          "1431:                 encoding_name_and_rate_pt = (encoding_name_and_rate_t *)g_hash_table_lookup(p_conv_data->rtp_dyn_payload, &hdr_new->pt);",
          "1432:                 if (encoding_name_and_rate_pt) {",
          "1433:                     payload_type_str = encoding_name_and_rate_pt->encoding_name;",
          "1434:                 }",
          "1435:             }",
          "1436:         }",
          "1438:         ti = proto_tree_add_text(rfc2198_tree, tvb, offset, (hdr_follow)?4:1, \"Header %u\", cnt);",
          "1439:         rfc2198_hdr_tree = proto_item_add_subtree(ti, ett_rtp_rfc2198_hdr);",
          "1440:         proto_tree_add_item(rfc2198_hdr_tree, hf_rtp_rfc2198_follow, tvb, offset, 1, ENC_BIG_ENDIAN );",
          "1441:         proto_tree_add_uint_format_value(rfc2198_hdr_tree, hf_rtp_payload_type, tvb,",
          "1442:             offset, 1, octet1, \"%s (%u)\",",
          "1443:             payload_type_str ? payload_type_str : val_to_str_ext_const(hdr_new->pt, &rtp_payload_type_vals_ext, \"Unknown\"),",
          "1444:             hdr_new->pt);",
          "1445:         proto_item_append_text(ti, \": PT=%s\",",
          "1446:                        payload_type_str ? payload_type_str :",
          "1447:                                           val_to_str_ext(hdr_new->pt, &rtp_payload_type_vals_ext, \"Unknown (%u)\"));",
          "1448:         offset += 1;",
          "1451:         if (hdr_follow) {",
          "1452:             proto_tree_add_item(rfc2198_hdr_tree, hf_rtp_rfc2198_tm_off, tvb, offset, 2, ENC_BIG_ENDIAN );",
          "1453:             proto_tree_add_item(rfc2198_hdr_tree, hf_rtp_rfc2198_bl_len, tvb, offset + 1, 2, ENC_BIG_ENDIAN );",
          "1454:             hdr_new->len = tvb_get_ntohs(tvb, offset + 1) & 0x03FF;",
          "1455:             proto_item_append_text(ti, \", len=%u\", hdr_new->len);",
          "1456:             offset += 3;",
          "1457:         } else {",
          "1458:             hdr_new->len = -1;",
          "1459:             hdr_follow = FALSE;",
          "1460:         }",
          "1462:         if (hdr_last) {",
          "1463:             hdr_last->next = hdr_new;",
          "1464:         } else {",
          "1465:             hdr_chain = hdr_new;",
          "1466:         }",
          "1467:         hdr_last = hdr_new;",
          "1468:     }",
          "1471:     hdr_last = hdr_chain;",
          "1472:     while (hdr_last) {",
          "1473:         hdr_last->offset = offset;",
          "1474:         if (!hdr_last->next) {",
          "1475:             hdr_last->len = tvb_reported_length_remaining(tvb, offset);",
          "1476:         }",
          "1477:         dissect_rtp_data(tvb, pinfo, tree, rfc2198_tree, hdr_last->offset, hdr_last->len, hdr_last->len, hdr_last->pt);",
          "1478:         offset += hdr_last->len;",
          "1479:         hdr_last = hdr_last->next;",
          "1480:     }",
          "1485:         proto_tree *rtp_hext_tree )",
          "1487:     proto_item *ti = NULL;",
          "1488:     proto_tree *rtp_hext_rfc5285_tree = NULL;",
          "1489:     guint ext_offset = 0, start_ext_offset;",
          "1491:     while (ext_offset < tvb_length (tvb)) {",
          "1492:         guint8 ext_hdr_hdr;",
          "1493:         guint8 ext_id;",
          "1494:         guint8 ext_length;",
          "1495:         tvbuff_t *subtvb = NULL;",
          "1498:         start_ext_offset = ext_offset;",
          "1499:         while (tvb_get_guint8 (tvb, ext_offset) == 0) {",
          "1500:             ext_offset ++;",
          "1501:             if (ext_offset >= tvb_length (tvb))",
          "1502:                 return;",
          "1503:         }",
          "1506:         if (ext_offset > start_ext_offset)",
          "1507:             proto_tree_add_item(rtp_hext_tree, hf_rtp_padding_data, tvb, ext_offset, ext_offset-start_ext_offset, ENC_NA );",
          "1509:         ext_hdr_hdr = tvb_get_guint8 (tvb, ext_offset);",
          "1510:         ext_id = ext_hdr_hdr >> 4;",
          "1513:         if (ext_id == 15)",
          "1514:             return;",
          "1516:         ext_length = (ext_hdr_hdr & 0x0F) + 1;",
          "1517:         if (rtp_hext_tree) {",
          "1518:             ti = proto_tree_add_text(rtp_hext_tree, tvb, ext_offset, ext_length + 1, \"RFC 5285 Header Extension (One-Byte Header)\");",
          "1519:             rtp_hext_rfc5285_tree = proto_item_add_subtree( ti, ett_hdr_ext_rfc5285);",
          "1521:             proto_tree_add_uint( rtp_hext_rfc5285_tree, hf_rtp_ext_rfc5285_id, tvb, ext_offset, 1, ext_id);",
          "1522:             proto_tree_add_uint( rtp_hext_rfc5285_tree, hf_rtp_ext_rfc5285_length, tvb, ext_offset, 1, ext_length);",
          "1523:         }",
          "1524:         ext_offset ++;",
          "1526:         subtvb = tvb_new_subset(tvb, ext_offset, ext_length, ext_length);",
          "1527:         if (!dissector_try_uint (rtp_hdr_ext_rfc5285_dissector_table, ext_id, subtvb, pinfo, rtp_hext_rfc5285_tree)) {",
          "1528:             if (rtp_hext_tree)",
          "1529:                 proto_tree_add_item(rtp_hext_rfc5285_tree, hf_rtp_ext_rfc5285_data, subtvb, 0, ext_length, ENC_NA );",
          "1530:         }",
          "1532:         ext_offset += ext_length;",
          "1533:     }",
          "1539:         guint8 id, tvbuff_t *tvb, packet_info *pinfo, proto_tree *rtp_hext_tree)",
          "1541:     proto_item *ti = NULL;",
          "1542:     proto_tree *rtp_hext_rfc5285_tree = NULL;",
          "1543:     guint ext_offset = 0, start_ext_offset;",
          "1545:     while (ext_offset + 2 < tvb_length (tvb)) {",
          "1546:         guint8 ext_id;",
          "1547:         guint8 ext_length;",
          "1548:         tvbuff_t *subtvb = NULL;",
          "1551:         start_ext_offset = ext_offset;",
          "1552:         while (tvb_get_guint8 (tvb, ext_offset) == 0) {",
          "1553:             if (ext_offset + 2 >= tvb_length (tvb))",
          "1554:                 return;",
          "1555:             ext_offset ++;",
          "1556:         }",
          "1558:         if (ext_offset > start_ext_offset)",
          "1559:             proto_tree_add_item(rtp_hext_tree, hf_rtp_padding_data, tvb, ext_offset, ext_offset-start_ext_offset, ENC_NA );",
          "1561:         ext_id = tvb_get_guint8 (tvb, ext_offset);",
          "1562:         ext_length = tvb_get_guint8 (tvb, ext_offset + 1);",
          "1564:         if (rtp_hext_tree) {",
          "1565:             ti = proto_tree_add_text(rtp_hext_tree, tvb, ext_offset, ext_length + 2, \"RFC 5285 Header Extension (Two-Byte Header)\");",
          "1566:             rtp_hext_rfc5285_tree = proto_item_add_subtree( ti, ett_hdr_ext_rfc5285);",
          "1568:             proto_tree_add_uint( rtp_hext_rfc5285_tree, hf_rtp_ext_rfc5285_appbits, parent_tvb, id_offset + 1, 1, id & 0x000F);",
          "1569:             proto_tree_add_uint( rtp_hext_rfc5285_tree, hf_rtp_ext_rfc5285_id, tvb, ext_offset, 1, ext_id);",
          "1570:             proto_tree_add_uint( rtp_hext_rfc5285_tree, hf_rtp_ext_rfc5285_length, tvb, ext_offset + 1, 1, ext_length);",
          "1571:         }",
          "1573:         ext_offset += 2;",
          "1575:         subtvb = tvb_new_subset(tvb, ext_offset, ext_length, ext_length);",
          "1576:         if (ext_length && !dissector_try_uint (rtp_hdr_ext_rfc5285_dissector_table, ext_id, subtvb, pinfo, rtp_hext_rfc5285_tree)) {",
          "1577:             proto_tree_add_item(rtp_hext_rfc5285_tree, hf_rtp_ext_rfc5285_data, subtvb, 0, ext_length, ENC_NA );",
          "1578:         }",
          "1580:         ext_offset += ext_length;",
          "1581:     }",
          "1587:     proto_item *ti            = NULL;",
          "1588:     proto_tree *volatile rtp_tree = NULL;",
          "1589:     proto_tree *rtp_csrc_tree = NULL;",
          "1590:     proto_tree *rtp_hext_tree = NULL;",
          "1591:     guint8      octet1, octet2;",
          "1592:     unsigned int version;",
          "1593:     gboolean    padding_set;",
          "1594:     gboolean    extension_set;",
          "1595:     unsigned int csrc_count;",
          "1596:     gboolean    marker_set;",
          "1597:     unsigned int payload_type;",
          "1598:     gchar *payload_type_str = NULL;",
          "1599:     gboolean    is_srtp = FALSE;",
          "1600:     unsigned int i            = 0;",
          "1601:     unsigned int hdr_extension_len= 0;",
          "1602:     unsigned int hdr_extension_id = 0;",
          "1603:     volatile unsigned int padding_count;",
          "1604:     gint        length, reported_length;",
          "1605:     int         data_len;",
          "1606:     volatile unsigned int offset = 0;",
          "1607:     guint16     seq_num;",
          "1608:     guint32     timestamp;",
          "1609:     guint32     sync_src;",
          "1610:     guint32     csrc_item;",
          "1611:     struct _rtp_conversation_info *p_conv_data = NULL;",
          "1614:     unsigned int hdrext_offset = 0;",
          "1615:     tvbuff_t     *newtvb = NULL;",
          "1616:     const char   *pt = NULL;",
          "1618:     static struct _rtp_info rtp_info_arr[4];",
          "1619:     static int rtp_info_current=0;",
          "1620:     struct _rtp_info *rtp_info;",
          "1622:     rtp_info_current++;",
          "1623:     if (rtp_info_current==4) {",
          "1624:         rtp_info_current=0;",
          "1625:     }",
          "1626:     rtp_info = &rtp_info_arr[rtp_info_current];",
          "1629:     octet1 = tvb_get_guint8( tvb, offset );",
          "1630:     version = RTP_VERSION( octet1 );",
          "1632:     if (version == 0) {",
          "1633:         switch (global_rtp_version0_type) {",
          "1634:         case RTP0_STUN:",
          "1635:             call_dissector(stun_handle, tvb, pinfo, tree);",
          "1636:             return tvb_length(tvb);",
          "1637:         case RTP0_CLASSICSTUN:",
          "1638:             call_dissector(classicstun_handle, tvb, pinfo, tree);",
          "1639:             return tvb_length(tvb);",
          "1641:         case RTP0_T38:",
          "1642:             call_dissector(t38_handle, tvb, pinfo, tree);",
          "1643:             return tvb_length(tvb);",
          "1645:         case RTP0_SPRT:",
          "1646:             call_dissector(sprt_handle, tvb, pinfo, tree);",
          "1647:             return tvb_length(tvb);",
          "1649:         case RTP0_INVALID:",
          "1650:             if (!(tvb_memeql(tvb, 4, \"ZRTP\", 4)))",
          "1651:             {",
          "1652:                 call_dissector(zrtp_handle,tvb,pinfo,tree);",
          "1653:                 return tvb_length(tvb);",
          "1654:             }",
          "1655:         default:",
          "1657:         }",
          "1658:     }",
          "1661:     rtp_info->info_version = version;",
          "1662:     if (version != 2) {",
          "1666:         col_set_str(pinfo->cinfo, COL_PROTOCOL, \"RTP\");",
          "1668:         col_add_fstr( pinfo->cinfo, COL_INFO,",
          "1669:             \"Unknown RTP version %u\", version);",
          "1671:         if ( tree ) {",
          "1672:             ti = proto_tree_add_item( tree, proto_rtp, tvb, offset, -1, ENC_NA );",
          "1673:             rtp_tree = proto_item_add_subtree( ti, ett_rtp );",
          "1675:             proto_tree_add_uint( rtp_tree, hf_rtp_version, tvb,",
          "1676:                 offset, 1, octet1);",
          "1677:         }",
          "1678:         return offset;",
          "1679:     }",
          "1681:     padding_set = RTP_PADDING( octet1 );",
          "1682:     extension_set = RTP_EXTENSION( octet1 );",
          "1683:     csrc_count = RTP_CSRC_COUNT( octet1 );",
          "1686:     octet2 = tvb_get_guint8( tvb, offset + 1 );",
          "1687:     marker_set = RTP_MARKER( octet2 );",
          "1688:     payload_type = RTP_PAYLOAD_TYPE( octet2 );",
          "1690:     if (marker_set && payload_type >= FIRST_RTCP_CONFLICT_PAYLOAD_TYPE && payload_type <=  LAST_RTCP_CONFLICT_PAYLOAD_TYPE) {",
          "1691:         call_dissector(rtcp_handle, tvb, pinfo, tree);",
          "1692:         return tvb_length(tvb);",
          "1693:     }",
          "1696:     seq_num = tvb_get_ntohs( tvb, offset + 2 );",
          "1697:     timestamp = tvb_get_ntohl( tvb, offset + 4 );",
          "1698:     sync_src = tvb_get_ntohl( tvb, offset + 8 );",
          "1701:     rtp_info->info_padding_set = padding_set;",
          "1702:     rtp_info->info_padding_count = 0;",
          "1703:     rtp_info->info_marker_set = marker_set;",
          "1704:     rtp_info->info_is_video = FALSE;",
          "1705:     rtp_info->info_payload_type = payload_type;",
          "1706:     rtp_info->info_seq_num = seq_num;",
          "1707:     rtp_info->info_timestamp = timestamp;",
          "1708:     rtp_info->info_sync_src = sync_src;",
          "1709:     rtp_info->info_is_srtp = FALSE;",
          "1710:     rtp_info->info_setup_frame_num = 0;",
          "1711:     rtp_info->info_payload_type_str = NULL;",
          "1712:     rtp_info->info_payload_rate = 0;",
          "1717:     length = tvb_length_remaining(tvb, offset);",
          "1718:     reported_length = tvb_reported_length_remaining(tvb, offset);",
          "1719:     if (reported_length >= 0 && length >= reported_length) {",
          "1723:         rtp_info->info_all_data_present = TRUE;",
          "1724:         rtp_info->info_data_len = reported_length;",
          "1737:         rtp_info->info_data = tvb_get_ptr(tvb, 0, -1);",
          "1738:     } else {",
          "1742:         rtp_info->info_all_data_present = FALSE;",
          "1743:         rtp_info->info_data_len = 0;",
          "1744:         rtp_info->info_data = NULL;",
          "1745:     }",
          "1748:     get_conv_info(pinfo, rtp_info);",
          "1749:     p_conv_data = (struct _rtp_conversation_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_rtp, 0);",
          "1751:     if (p_conv_data)",
          "1752:         rtp_info->info_is_video = p_conv_data->is_video;",
          "1754:     if (p_conv_data && p_conv_data->srtp_info) is_srtp = TRUE;",
          "1755:     rtp_info->info_is_srtp = is_srtp;",
          "1757:     col_set_str( pinfo->cinfo, COL_PROTOCOL, (is_srtp) ? \"SRTP\" : \"RTP\" );",
          "1760:     p_conv_data = (struct _rtp_conversation_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_rtp, 0);",
          "1763:     if (p_conv_data && p_conv_data->srtp_info) {",
          "1764:         srtp_info = p_conv_data->srtp_info;",
          "1765:         if (rtp_info->info_all_data_present) {",
          "1766:             srtp_offset = rtp_info->info_data_len - srtp_info->mki_len - srtp_info->auth_tag_len;",
          "1767:         }",
          "1768:     }",
          "1771:     if (p_conv_data && p_conv_data->bta2dp_info && p_conv_data->bta2dp_info->codec_dissector) {",
          "1772:         rtp_info->info_payload_type_str = (const char *) dissector_handle_get_short_name(p_conv_data->bta2dp_info->codec_dissector);",
          "1773:     } else if (p_conv_data && p_conv_data->btvdp_info && p_conv_data->btvdp_info->codec_dissector) {",
          "1774:         rtp_info->info_payload_type_str = (const char *) dissector_handle_get_short_name(p_conv_data->btvdp_info->codec_dissector);",
          "1775:     }",
          "1778:     if ( (payload_type>95) && (payload_type<128) ) {",
          "1779:         if (p_conv_data && p_conv_data->rtp_dyn_payload){",
          "1780:             encoding_name_and_rate_t *encoding_name_and_rate_pt = NULL;",
          "1781:             encoding_name_and_rate_pt = (encoding_name_and_rate_t *)g_hash_table_lookup(p_conv_data->rtp_dyn_payload, &payload_type);",
          "1782:             if (encoding_name_and_rate_pt) {",
          "1783:                 rtp_info->info_payload_type_str = payload_type_str = encoding_name_and_rate_pt->encoding_name;",
          "1784:                 rtp_info->info_payload_rate = encoding_name_and_rate_pt->sample_rate;",
          "1785:             }",
          "1786:         }",
          "1787:     }",
          "1789:     if (p_conv_data && p_conv_data->bta2dp_info) {",
          "1790:         pt = (p_conv_data->bta2dp_info->codec_dissector) ? dissector_handle_get_short_name(p_conv_data->bta2dp_info->codec_dissector) : \"Unknown\";",
          "1791:     } else if (p_conv_data && p_conv_data->btvdp_info) {",
          "1792:         pt = (p_conv_data->btvdp_info->codec_dissector) ? dissector_handle_get_short_name(p_conv_data->btvdp_info->codec_dissector) : \"Unknown\";",
          "1793:     } else {",
          "1794:         pt = (payload_type_str ? payload_type_str : val_to_str_ext(payload_type, &rtp_payload_type_vals_ext,\"Unknown (%u)\"));",
          "1795:     }",
          "1797:     col_add_fstr( pinfo->cinfo, COL_INFO,",
          "1798:         \"PT=%s, SSRC=0x%X, Seq=%u, Time=%u%s\",",
          "1799:         pt,",
          "1800:         sync_src,",
          "1801:         seq_num,",
          "1802:         timestamp,",
          "1803:         marker_set ? \", Mark\" : \"\");",
          "1805:     if ( tree ) {",
          "1806:         proto_tree *item;",
          "1808:         ti = proto_tree_add_item(tree, proto_rtp, tvb, offset, -1, ENC_NA );",
          "1809:         rtp_tree = proto_item_add_subtree(ti, ett_rtp );",
          "1812:         if (global_rtp_show_setup_info)",
          "1813:         {",
          "1814:             show_setup_info(tvb, pinfo, rtp_tree);",
          "1815:         }",
          "1817:         proto_tree_add_uint( rtp_tree, hf_rtp_version, tvb,",
          "1818:             offset, 1, octet1 );",
          "1819:         proto_tree_add_boolean( rtp_tree, hf_rtp_padding, tvb,",
          "1820:             offset, 1, octet1 );",
          "1821:         proto_tree_add_boolean( rtp_tree, hf_rtp_extension, tvb,",
          "1822:             offset, 1, octet1 );",
          "1823:         proto_tree_add_uint( rtp_tree, hf_rtp_csrc_count, tvb,",
          "1824:             offset, 1, octet1 );",
          "1825:         offset++;",
          "1827:         proto_tree_add_boolean( rtp_tree, hf_rtp_marker, tvb, offset,",
          "1828:             1, octet2 );",
          "1830:         proto_tree_add_uint_format( rtp_tree, hf_rtp_payload_type, tvb,",
          "1831:             offset, 1, octet2, \"Payload type: %s (%u)\", pt, payload_type);",
          "1833:         offset++;",
          "1836:         proto_tree_add_uint( rtp_tree, hf_rtp_seq_nr, tvb, offset, 2, seq_num );",
          "1837:         if(p_conv_data != NULL) {",
          "1838:             item = proto_tree_add_uint( rtp_tree, hf_rtp_ext_seq_nr, tvb, offset, 2, p_conv_data->extended_seqno );",
          "1839:             PROTO_ITEM_SET_GENERATED(item);",
          "1840:         }",
          "1841:         offset += 2;",
          "1844:         proto_tree_add_uint( rtp_tree, hf_rtp_timestamp, tvb, offset, 4, timestamp );",
          "1845:         offset += 4;",
          "1848:         proto_tree_add_uint( rtp_tree, hf_rtp_ssrc, tvb, offset, 4, sync_src );",
          "1849:         offset += 4;",
          "1850:     } else {",
          "1851:         offset += 12;",
          "1852:     }",
          "1854:     if ( csrc_count > 0 ) {",
          "1855:         ti = proto_tree_add_item(rtp_tree, hf_rtp_csrc_items, tvb, offset,",
          "1856:                                      csrc_count * 4, ENC_NA);",
          "1857:         proto_item_append_text(ti, \" (%u items)\", csrc_count);",
          "1858:         rtp_csrc_tree = proto_item_add_subtree( ti, ett_csrc_list );",
          "1860:         for (i = 0; i < csrc_count; i++ ) {",
          "1861:             csrc_item = tvb_get_ntohl( tvb, offset );",
          "1862:             proto_tree_add_uint_format( rtp_csrc_tree,",
          "1863:                 hf_rtp_csrc_item, tvb, offset, 4,",
          "1864:                 csrc_item,",
          "1865:                 \"CSRC item %d: 0x%X\",",
          "1866:                 i, csrc_item );",
          "1867:             offset += 4;",
          "1868:         }",
          "1869:     }",
          "1872:     if ( extension_set ) {",
          "1874:         hdr_extension_id = tvb_get_ntohs( tvb, offset );",
          "1875:         if ( tree ) proto_tree_add_uint( rtp_tree, hf_rtp_prof_define, tvb, offset, 2, hdr_extension_id );",
          "1876:         offset += 2;",
          "1878:         hdr_extension_len = tvb_get_ntohs( tvb, offset );",
          "1879:         if ( tree ) proto_tree_add_uint( rtp_tree, hf_rtp_length, tvb, offset, 2, hdr_extension_len);",
          "1880:         offset += 2;",
          "1881:         if ( hdr_extension_len > 0 ) {",
          "1882:             if ( tree ) {",
          "1883:                 ti = proto_tree_add_item(rtp_tree, hf_rtp_hdr_exts, tvb, offset, hdr_extension_len * 4, ENC_NA);",
          "1884:                 rtp_hext_tree = proto_item_add_subtree( ti, ett_hdr_ext );",
          "1885:             }",
          "1888:             newtvb = tvb_new_subset(tvb, offset, hdr_extension_len * 4, hdr_extension_len * 4);",
          "1890:             if (hdr_extension_id == RTP_RFC5215_ONE_BYTE_SIG) {",
          "1891:                 dissect_rtp_hext_rfc5215_onebyte (newtvb, pinfo, rtp_hext_tree);",
          "1892:             }",
          "1893:             else if ((hdr_extension_id & RTP_RFC5215_TWO_BYTE_MASK) == RTP_RFC5215_TWO_BYTE_SIG) {",
          "1894:                 dissect_rtp_hext_rfc5215_twobytes(tvb,",
          "1895:                     offset - 4, hdr_extension_id, newtvb,",
          "1896:                     pinfo, rtp_hext_tree);",
          "1897:             }",
          "1898:             else {",
          "1899:                 if ( !(dissector_try_uint(rtp_hdr_ext_dissector_table, hdr_extension_id, newtvb, pinfo, rtp_hext_tree)) ) {",
          "1900:                     hdrext_offset = offset;",
          "1901:                     for ( i = 0; i < hdr_extension_len; i++ ) {",
          "1902:                         if ( tree ) proto_tree_add_uint( rtp_hext_tree, hf_rtp_hdr_ext, tvb, hdrext_offset, 4, tvb_get_ntohl( tvb, hdrext_offset ) );",
          "1903:                         hdrext_offset += 4;",
          "1904:                     }",
          "1905:                 }",
          "1906:             }",
          "1907:         }",
          "1908:         offset += hdr_extension_len * 4;",
          "1909:     }",
          "1911:     if ( padding_set ) {",
          "1919:         if (tvb_length(tvb) < tvb_reported_length(tvb)) {",
          "1929:             if ( tree ) proto_tree_add_text(rtp_tree, tvb, 0, 0,",
          "1930:                 \"Frame has padding, but not all the frame data was captured\");",
          "1931:             call_dissector(data_handle,",
          "1932:                 tvb_new_subset_remaining(tvb, offset),",
          "1933:                 pinfo, rtp_tree);",
          "1934:             return tvb_length(tvb);",
          "1935:         }",
          "1937:         padding_count = tvb_get_guint8( tvb,",
          "1938:             tvb_reported_length( tvb ) - 1 );",
          "1939:         data_len =",
          "1940:             tvb_reported_length_remaining( tvb, offset ) - padding_count;",
          "1942:         rtp_info->info_payload_offset = offset;",
          "1943:         rtp_info->info_payload_len = tvb_length_remaining(tvb, offset);",
          "1944:         rtp_info->info_padding_count = padding_count;",
          "1946:         if (p_conv_data && p_conv_data->bta2dp_info) {",
          "1947:             if (p_conv_data->bta2dp_info->codec_dissector == sbc_handle) {",
          "1948:                 rtp_info->info_payload_offset += 1;",
          "1949:                 rtp_info->info_payload_len -= 1;",
          "1950:             }",
          "1952:             if (p_conv_data->bta2dp_info->content_protection_type == BTAVDTP_CONTENT_PROTECTION_TYPE_SCMS_T) {",
          "1953:                 rtp_info->info_payload_offset += 1;",
          "1954:                 rtp_info->info_payload_len -= 1;",
          "1955:             }",
          "1956:         }",
          "1958:         if (p_conv_data && p_conv_data->btvdp_info &&",
          "1959:                 p_conv_data->bta2dp_info->content_protection_type == BTAVDTP_CONTENT_PROTECTION_TYPE_SCMS_T) {",
          "1960:             rtp_info->info_payload_offset += 1;",
          "1961:             rtp_info->info_payload_len -= 1;",
          "1962:         }",
          "1964:         if (data_len > 0) {",
          "1970:             TRY {",
          "1971:                 dissect_rtp_data( tvb, pinfo, tree, rtp_tree,",
          "1972:                     offset,",
          "1973:                     data_len,",
          "1974:                     data_len,",
          "1975:                     payload_type);",
          "1976:             } CATCH_ALL {",
          "1977:                 if (!pinfo->flags.in_error_pkt)",
          "1978:                     tap_queue_packet(rtp_tap, pinfo, rtp_info);",
          "1979:                 RETHROW;",
          "1980:             }",
          "1981:             ENDTRY;",
          "1982:             offset += data_len;",
          "1983:         } else if (data_len < 0) {",
          "1992:             padding_count =",
          "1993:                 tvb_reported_length_remaining(tvb, offset);",
          "1994:         }",
          "1995:         if (padding_count > 1) {",
          "2001:             if ( tree ) proto_tree_add_item( rtp_tree, hf_rtp_padding_data,",
          "2002:                 tvb, offset, padding_count - 1, ENC_NA );",
          "2003:             offset += padding_count - 1;",
          "2004:         }",
          "2009:         if ( tree ) proto_tree_add_item( rtp_tree, hf_rtp_padding_count,",
          "2010:             tvb, offset, 1, ENC_BIG_ENDIAN );",
          "2011:     }",
          "2012:     else {",
          "2016:         rtp_info->info_payload_offset = offset;",
          "2017:         rtp_info->info_payload_len = tvb_length_remaining(tvb, offset);",
          "2019:         if (p_conv_data && p_conv_data->bta2dp_info) {",
          "2020:             if (p_conv_data->bta2dp_info->codec_dissector == sbc_handle) {",
          "2021:                 rtp_info->info_payload_offset += 1;",
          "2022:                 rtp_info->info_payload_len -= 1;",
          "2023:             }",
          "2025:             if (p_conv_data->bta2dp_info->content_protection_type == BTAVDTP_CONTENT_PROTECTION_TYPE_SCMS_T) {",
          "2026:                 rtp_info->info_payload_offset += 1;",
          "2027:                 rtp_info->info_payload_len -= 1;",
          "2028:             }",
          "2029:         }",
          "2031:         if (p_conv_data && p_conv_data->btvdp_info &&",
          "2032:                 p_conv_data->bta2dp_info->content_protection_type == BTAVDTP_CONTENT_PROTECTION_TYPE_SCMS_T) {",
          "2033:             rtp_info->info_payload_offset += 1;",
          "2034:             rtp_info->info_payload_len -= 1;",
          "2035:         }",
          "2037:         if (tvb_reported_length_remaining(tvb, offset) > 0) {",
          "2039:             TRY {",
          "2040:                 dissect_rtp_data( tvb, pinfo, tree, rtp_tree, offset,",
          "2041:                           tvb_length_remaining( tvb, offset ),",
          "2042:                           tvb_reported_length_remaining( tvb, offset ),",
          "2043:                           payload_type);",
          "2044:             } CATCH_ALL {",
          "2045:                 if (!pinfo->flags.in_error_pkt)",
          "2046:                     tap_queue_packet(rtp_tap, pinfo, rtp_info);",
          "2047:                 RETHROW;",
          "2048:             }",
          "2049:             ENDTRY;",
          "2050:         }",
          "2051:     }",
          "2052:     if (!pinfo->flags.in_error_pkt)",
          "2053:         tap_queue_packet(rtp_tap, pinfo, rtp_info);",
          "2055:     return offset;",
          "2061:     unsigned int offset = 0;",
          "2062:     unsigned int hdr_extension_len = 0;",
          "2063:     proto_item *ti            = NULL;",
          "2064:     proto_item *ti2           = NULL;",
          "2065:     proto_tree *rtp_hext_tree = NULL;",
          "2066:     proto_tree *rtp_hext_tree2 = NULL;",
          "2067:     unsigned int i;",
          "2068:     guint32 ext_value;",
          "2069:     unsigned int ft_type = 0;",
          "2070:     unsigned int bss_qidx = 0;",
          "2071:     unsigned int bss_qidx_ml = 0;",
          "2073:     hdr_extension_len = tvb_reported_length(tvb)/4;",
          "2075:     if ( hdr_extension_len > 0 ) {",
          "2076:         unsigned int hdrext_offset = 0;",
          "2078:         if ( tree ) {",
          "2079:           ti = proto_tree_add_item(tree, hf_rtp_hdr_ed137s, tvb, offset, hdr_extension_len * 4, ENC_NA);",
          "2080:           rtp_hext_tree = proto_item_add_subtree( ti, ett_hdr_ext_ed137s );",
          "2081:         }",
          "2082:         for(i=0; i<hdr_extension_len; i++) {",
          "2083:             if ( tree ) {",
          "2084:                 ti2 = proto_tree_add_item(rtp_hext_tree, hf_rtp_hdr_ed137, tvb, hdrext_offset, 4, ENC_NA);",
          "2085:                 rtp_hext_tree2 = proto_item_add_subtree( ti2, ett_hdr_ext_ed137 );",
          "2086:                 ext_value=tvb_get_ntohl( tvb, hdrext_offset );",
          "2088:                 if (RTP_ED137_ptt_mask(ext_value)) {",
          "2089:                     col_append_str(pinfo->cinfo, COL_INFO, \", PTT\");",
          "2090:                 }",
          "2091:                 if (RTP_ED137_squ_mask(ext_value)) {",
          "2092:                     col_append_str(pinfo->cinfo, COL_INFO, \", SQU\");",
          "2093:                 }",
          "2096:                 proto_tree_add_item( rtp_hext_tree2, hf_rtp_hdr_ed137_ptt_type, tvb, hdrext_offset, 4, ENC_BIG_ENDIAN);",
          "2097:                 proto_tree_add_item( rtp_hext_tree2, hf_rtp_hdr_ed137_squ, tvb, hdrext_offset, 4, ENC_BIG_ENDIAN);",
          "2098:                 proto_tree_add_item( rtp_hext_tree2, hf_rtp_hdr_ed137_ptt_id, tvb, hdrext_offset, 4, ENC_BIG_ENDIAN);",
          "2099:                 proto_tree_add_item( rtp_hext_tree2, hf_rtp_hdr_ed137_sct, tvb, hdrext_offset, 4, ENC_BIG_ENDIAN);",
          "2100:                 proto_tree_add_item( rtp_hext_tree2, hf_rtp_hdr_ed137_x, tvb, hdrext_offset, 4, ENC_BIG_ENDIAN);",
          "2102:                 if (RTP_ED137_extended_information(ext_value)) {",
          "2104:                     proto_tree_add_item( rtp_hext_tree2, hf_rtp_hdr_ed137_ft_type, tvb, hdrext_offset, 4, ENC_BIG_ENDIAN);",
          "2105:                     proto_tree_add_item( rtp_hext_tree2, hf_rtp_hdr_ed137_ft_len, tvb, hdrext_offset, 4, ENC_BIG_ENDIAN);",
          "2107:                     ft_type=RTP_ED137_feature_type(ext_value);",
          "2108:                     switch (ft_type) {",
          "2109:                         case RTP_ED137_feature_bss_type:",
          "2110:                             bss_qidx=RTP_ED137_feature_bss_qidx(ext_value);",
          "2111:                             bss_qidx_ml=RTP_ED137_feature_bss_qidx_ml(ext_value);",
          "2112:                             if (0==bss_qidx_ml) {",
          "2114:                                 if (bss_qidx<=15) {",
          "2116:                                     proto_tree_add_item( rtp_hext_tree2, hf_rtp_hdr_ed137_ft_bss_rssi_qidx, tvb, hdrext_offset, 4, ENC_BIG_ENDIAN);",
          "2117:                                 }",
          "2118:                                 else {",
          "2120:                                     proto_tree_add_item( rtp_hext_tree2, hf_rtp_hdr_ed137_ft_bss_qidx, tvb, hdrext_offset, 4, ENC_BIG_ENDIAN);",
          "2121:                                 }",
          "2122:                             }",
          "2123:                             else {",
          "2125:                                 proto_tree_add_item( rtp_hext_tree2, hf_rtp_hdr_ed137_ft_bss_qidx, tvb, hdrext_offset, 4, ENC_BIG_ENDIAN);",
          "2126:                             }",
          "2127:                             proto_tree_add_item( rtp_hext_tree2, hf_rtp_hdr_ed137_ft_bss_qidx_ml, tvb, hdrext_offset, 4, ENC_BIG_ENDIAN);",
          "2128:                             proto_tree_add_item( rtp_hext_tree2, hf_rtp_hdr_ed137_ft_bss_nu, tvb, hdrext_offset, 4, ENC_BIG_ENDIAN);",
          "2129:                             break;",
          "2130:                         default:",
          "2131:                             proto_tree_add_item( rtp_hext_tree2, hf_rtp_hdr_ed137_ft_value, tvb, hdrext_offset, 4, ENC_BIG_ENDIAN);",
          "2132:                             break;",
          "2133:                     }",
          "2134:                 }",
          "2135:                 else {",
          "2137:                     proto_tree_add_item( rtp_hext_tree2, hf_rtp_hdr_ed137_x_nu, tvb, hdrext_offset, 4, ENC_BIG_ENDIAN);",
          "2138:                 }",
          "2140:                 proto_tree_add_item( rtp_hext_tree2, hf_rtp_hdr_ed137_vf, tvb, hdrext_offset, 4, ENC_BIG_ENDIAN);",
          "2141:             }",
          "2142:             hdrext_offset += 4;",
          "2143:         }",
          "2144:     }",
          "2150:     unsigned int offset = 0;",
          "2151:     unsigned int hdr_extension_len = 0;",
          "2152:     proto_item *ti            = NULL;",
          "2153:     proto_item *ti2           = NULL;",
          "2154:     proto_tree *rtp_hext_tree = NULL;",
          "2155:     proto_tree *rtp_hext_tree2 = NULL;",
          "2156:     unsigned int i;",
          "2157:     guint32 ext_value;",
          "2158:     unsigned int ft_type = 0;",
          "2160:     hdr_extension_len = tvb_reported_length(tvb)/4;",
          "2162:     if ( hdr_extension_len > 0 ) {",
          "2163:         unsigned int hdrext_offset = 0;",
          "2165:         if ( tree ) {",
          "2166:             ti = proto_tree_add_item(tree, hf_rtp_hdr_ed137s, tvb, offset, hdr_extension_len * 4, ENC_NA);",
          "2167:             rtp_hext_tree = proto_item_add_subtree( ti, ett_hdr_ext_ed137s );",
          "2168:         }",
          "2169:         for(i=0; i<hdr_extension_len; i++) {",
          "2170:             if ( tree ) {",
          "2171:                 ti2 = proto_tree_add_item(rtp_hext_tree, hf_rtp_hdr_ed137a, tvb, hdrext_offset, 4, ENC_NA);",
          "2172:                 rtp_hext_tree2 = proto_item_add_subtree( ti2, ett_hdr_ext_ed137a );",
          "2173:                 ext_value=tvb_get_ntohl( tvb, hdrext_offset );",
          "2175:                 if (RTP_ED137A_ptt_mask(ext_value)) {",
          "2176:                     col_append_str(pinfo->cinfo, COL_INFO, \", PTT\");",
          "2177:                 }",
          "2178:                 if (RTP_ED137A_squ_mask(ext_value)) {",
          "2179:                     col_append_str(pinfo->cinfo, COL_INFO, \", SQU\");",
          "2180:                 }",
          "2183:                 proto_tree_add_item( rtp_hext_tree2, hf_rtp_hdr_ed137a_ptt_type, tvb, hdrext_offset, 4, ENC_BIG_ENDIAN);",
          "2184:                 proto_tree_add_item( rtp_hext_tree2, hf_rtp_hdr_ed137a_squ, tvb, hdrext_offset, 4, ENC_BIG_ENDIAN);",
          "2185:                 proto_tree_add_item( rtp_hext_tree2, hf_rtp_hdr_ed137a_ptt_id, tvb, hdrext_offset, 4, ENC_BIG_ENDIAN);",
          "2186:                 proto_tree_add_item( rtp_hext_tree2, hf_rtp_hdr_ed137a_pm, tvb, hdrext_offset, 4, ENC_BIG_ENDIAN);",
          "2187:                 proto_tree_add_item( rtp_hext_tree2, hf_rtp_hdr_ed137a_ptts, tvb, hdrext_offset, 4, ENC_BIG_ENDIAN);",
          "2188:                 proto_tree_add_item( rtp_hext_tree2, hf_rtp_hdr_ed137a_sct, tvb, hdrext_offset, 4, ENC_BIG_ENDIAN);",
          "2189:                 proto_tree_add_item( rtp_hext_tree2, hf_rtp_hdr_ed137a_reserved, tvb, hdrext_offset, 4, ENC_BIG_ENDIAN);",
          "2190:                 proto_tree_add_item( rtp_hext_tree2, hf_rtp_hdr_ed137a_x, tvb, hdrext_offset, 4, ENC_BIG_ENDIAN);",
          "2192:                 if (RTP_ED137A_extended_information(ext_value)) {",
          "2194:                     proto_tree_add_item( rtp_hext_tree2, hf_rtp_hdr_ed137a_ft_type, tvb, hdrext_offset, 4, ENC_BIG_ENDIAN);",
          "2195:                     proto_tree_add_item( rtp_hext_tree2, hf_rtp_hdr_ed137a_ft_len, tvb, hdrext_offset, 4, ENC_BIG_ENDIAN);",
          "2197:                     ft_type=RTP_ED137A_feature_type(ext_value);",
          "2198:                     switch (ft_type) {",
          "2199:                         default:",
          "2200:                             proto_tree_add_item( rtp_hext_tree2, hf_rtp_hdr_ed137a_ft_value, tvb, hdrext_offset, 4, ENC_BIG_ENDIAN);",
          "2201:                             break;",
          "2202:                     }",
          "2203:                 }",
          "2204:                 else {",
          "2206:                     proto_tree_add_item( rtp_hext_tree2, hf_rtp_hdr_ed137a_x_nu, tvb, hdrext_offset, 4, ENC_BIG_ENDIAN);",
          "2207:                 }",
          "2208:             }",
          "2209:             hdrext_offset += 4;",
          "2210:         }",
          "2211:     }",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "2216: static guint32",
          "2217: calculate_extended_seqno(guint32 previous_seqno, guint16 raw_seqno)",
          "2218: {",
          "2228: }",
          "2231: static void",
          "2232: get_conv_info(packet_info *pinfo, struct _rtp_info *rtp_info)",
          "2233: {",
          "2278: }",
          "",
          "[Removed Lines]",
          "2219:  guint32 seqno = (previous_seqno & 0xffff0000) | raw_seqno;",
          "2220:  if(seqno + 0x8000 < previous_seqno) {",
          "2221:   seqno += 0x10000;",
          "2222:  } else if(previous_seqno + 0x8000 < seqno) {",
          "2225:   seqno -= 0x10000;",
          "2226:  }",
          "2227:  return seqno;",
          "2235:  conversation_t *p_conv = NULL;",
          "2236:  struct _rtp_conversation_info *p_conv_data = NULL;",
          "2239:  p_conv_data = (struct _rtp_conversation_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_rtp, 0);",
          "2241:  if (!p_conv_data)",
          "2242:  {",
          "2244:   p_conv = find_conversation(pinfo->fd->num, &pinfo->net_dst, &pinfo->net_src,",
          "2245:                              pinfo->ptype,",
          "2246:                              pinfo->destport, pinfo->srcport, NO_ADDR_B);",
          "2247:   if (p_conv)",
          "2248:   {",
          "2250:    struct _rtp_conversation_info *p_conv_packet_data;",
          "2251:    p_conv_data = (struct _rtp_conversation_info *)conversation_get_proto_data(p_conv, proto_rtp);",
          "2253:    if (p_conv_data) {",
          "2254:     guint32 seqno;",
          "2257:     p_conv_packet_data = wmem_new(wmem_file_scope(), struct _rtp_conversation_info);",
          "2258:     g_strlcpy(p_conv_packet_data->method, p_conv_data->method, MAX_RTP_SETUP_METHOD_SIZE+1);",
          "2259:     p_conv_packet_data->frame_number = p_conv_data->frame_number;",
          "2260:     p_conv_packet_data->is_video = p_conv_data->is_video;",
          "2261:     p_conv_packet_data->rtp_dyn_payload = p_conv_data->rtp_dyn_payload;",
          "2262:     p_conv_packet_data->rtp_conv_info = p_conv_data->rtp_conv_info;",
          "2263:     p_conv_packet_data->srtp_info = p_conv_data->srtp_info;",
          "2264:     p_conv_packet_data->bta2dp_info = p_conv_data->bta2dp_info;",
          "2265:     p_conv_packet_data->btvdp_info = p_conv_data->btvdp_info;",
          "2266:     p_add_proto_data(wmem_file_scope(), pinfo, proto_rtp, 0, p_conv_packet_data);",
          "2269:     seqno = calculate_extended_seqno(p_conv_data->extended_seqno,",
          "2270:          rtp_info->info_seq_num);",
          "2272:     p_conv_packet_data->extended_seqno = seqno;",
          "2273:     p_conv_data->extended_seqno = seqno;",
          "2274:    }",
          "2275:   }",
          "2276:  }",
          "2277:  if (p_conv_data) rtp_info->info_setup_frame_num = p_conv_data->frame_number;",
          "",
          "[Added Lines]",
          "2219:     guint32 seqno = (previous_seqno & 0xffff0000) | raw_seqno;",
          "2220:     if(seqno + 0x8000 < previous_seqno) {",
          "2221:         seqno += 0x10000;",
          "2222:     } else if(previous_seqno + 0x8000 < seqno) {",
          "2225:         seqno -= 0x10000;",
          "2226:     }",
          "2227:     return seqno;",
          "2235:     conversation_t *p_conv = NULL;",
          "2236:     struct _rtp_conversation_info *p_conv_data = NULL;",
          "2239:     p_conv_data = (struct _rtp_conversation_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_rtp, 0);",
          "2241:     if (!p_conv_data)",
          "2242:     {",
          "2244:         p_conv = find_conversation(pinfo->fd->num, &pinfo->net_dst, &pinfo->net_src,",
          "2245:                                    pinfo->ptype,",
          "2246:                                    pinfo->destport, pinfo->srcport, NO_ADDR_B);",
          "2247:         if (p_conv)",
          "2248:         {",
          "2250:             struct _rtp_conversation_info *p_conv_packet_data;",
          "2251:             p_conv_data = (struct _rtp_conversation_info *)conversation_get_proto_data(p_conv, proto_rtp);",
          "2253:             if (p_conv_data) {",
          "2254:                 guint32 seqno;",
          "2257:                 p_conv_packet_data = wmem_new(wmem_file_scope(), struct _rtp_conversation_info);",
          "2258:                 g_strlcpy(p_conv_packet_data->method, p_conv_data->method, MAX_RTP_SETUP_METHOD_SIZE+1);",
          "2259:                 p_conv_packet_data->frame_number = p_conv_data->frame_number;",
          "2260:                 p_conv_packet_data->is_video = p_conv_data->is_video;",
          "2261:                 p_conv_packet_data->rtp_dyn_payload = p_conv_data->rtp_dyn_payload;",
          "2262:                 p_conv_packet_data->rtp_conv_info = p_conv_data->rtp_conv_info;",
          "2263:                 p_conv_packet_data->srtp_info = p_conv_data->srtp_info;",
          "2264:                 p_conv_packet_data->bta2dp_info = p_conv_data->bta2dp_info;",
          "2265:                 p_conv_packet_data->btvdp_info = p_conv_data->btvdp_info;",
          "2266:                 p_add_proto_data(wmem_file_scope(), pinfo, proto_rtp, 0, p_conv_packet_data);",
          "2269:                 seqno = calculate_extended_seqno(p_conv_data->extended_seqno,",
          "2270:                                  rtp_info->info_seq_num);",
          "2272:                 p_conv_packet_data->extended_seqno = seqno;",
          "2273:                 p_conv_data->extended_seqno = seqno;",
          "2274:             }",
          "2275:         }",
          "2276:     }",
          "2277:     if (p_conv_data) rtp_info->info_setup_frame_num = p_conv_data->frame_number;",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "2282: static void",
          "2283: show_setup_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)",
          "2284: {",
          "2312: }",
          "",
          "[Removed Lines]",
          "2286:  struct _rtp_conversation_info *p_conv_data = NULL;",
          "2287:  proto_tree *rtp_setup_tree;",
          "2288:  proto_item *ti;",
          "2291:  p_conv_data = (struct _rtp_conversation_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_rtp, 0);",
          "2293:  if (!p_conv_data) return;",
          "2296:  ti =  proto_tree_add_string_format(tree, hf_rtp_setup, tvb, 0, 0,",
          "2297:         \"\", \"Stream setup by %s (frame %u)\",",
          "2298:         p_conv_data->method,",
          "2299:         p_conv_data->frame_number);",
          "2300:   PROTO_ITEM_SET_GENERATED(ti);",
          "2301:   rtp_setup_tree = proto_item_add_subtree(ti, ett_rtp_setup);",
          "2302:   if (rtp_setup_tree)",
          "2303:   {",
          "2305:    proto_item* item = proto_tree_add_uint(rtp_setup_tree, hf_rtp_setup_frame,",
          "2306:                                           tvb, 0, 0, p_conv_data->frame_number);",
          "2307:    PROTO_ITEM_SET_GENERATED(item);",
          "2308:    item = proto_tree_add_string(rtp_setup_tree, hf_rtp_setup_method,",
          "2309:                                 tvb, 0, 0, p_conv_data->method);",
          "2310:    PROTO_ITEM_SET_GENERATED(item);",
          "2311:   }",
          "",
          "[Added Lines]",
          "2286:     struct _rtp_conversation_info *p_conv_data = NULL;",
          "2287:     proto_tree *rtp_setup_tree;",
          "2288:     proto_item *ti;",
          "2291:     p_conv_data = (struct _rtp_conversation_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_rtp, 0);",
          "2293:     if (!p_conv_data) return;",
          "2296:     ti =  proto_tree_add_string_format(tree, hf_rtp_setup, tvb, 0, 0,",
          "2297:                        \"\", \"Stream setup by %s (frame %u)\",",
          "2298:                        p_conv_data->method,",
          "2299:                        p_conv_data->frame_number);",
          "2300:         PROTO_ITEM_SET_GENERATED(ti);",
          "2301:         rtp_setup_tree = proto_item_add_subtree(ti, ett_rtp_setup);",
          "2302:         if (rtp_setup_tree)",
          "2303:         {",
          "2305:             proto_item* item = proto_tree_add_uint(rtp_setup_tree, hf_rtp_setup_frame,",
          "2306:                                                    tvb, 0, 0, p_conv_data->frame_number);",
          "2307:             PROTO_ITEM_SET_GENERATED(item);",
          "2308:             item = proto_tree_add_string(rtp_setup_tree, hf_rtp_setup_method,",
          "2309:                                          tvb, 0, 0, p_conv_data->method);",
          "2310:             PROTO_ITEM_SET_GENERATED(item);",
          "2311:         }",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "2316: static int",
          "2317: dissect_pkt_ccc(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)",
          "2318: {",
          "2332: }",
          "",
          "[Removed Lines]",
          "2319:  proto_item *ti            = NULL;",
          "2320:  proto_tree *pkt_ccc_tree      = NULL;",
          "2322:  if ( tree ) {",
          "2323:   ti = proto_tree_add_item(tree, proto_pkt_ccc, tvb, 0, 12, ENC_NA);",
          "2324:   pkt_ccc_tree = proto_item_add_subtree(ti, ett_pkt_ccc);",
          "2326:   proto_tree_add_item(pkt_ccc_tree, hf_pkt_ccc_id, tvb, 0, 4, ENC_BIG_ENDIAN);",
          "2327:   proto_tree_add_item(pkt_ccc_tree, hf_pkt_ccc_ts, tvb, 4, 8,",
          "2328:         ENC_TIME_NTP|ENC_BIG_ENDIAN);",
          "2329:  }",
          "2331:  return dissect_rtp(tvb, pinfo, tree, data);",
          "",
          "[Added Lines]",
          "2319:     proto_item *ti            = NULL;",
          "2320:     proto_tree *pkt_ccc_tree      = NULL;",
          "2322:     if ( tree ) {",
          "2323:         ti = proto_tree_add_item(tree, proto_pkt_ccc, tvb, 0, 12, ENC_NA);",
          "2324:         pkt_ccc_tree = proto_item_add_subtree(ti, ett_pkt_ccc);",
          "2326:         proto_tree_add_item(pkt_ccc_tree, hf_pkt_ccc_id, tvb, 0, 4, ENC_BIG_ENDIAN);",
          "2327:         proto_tree_add_item(pkt_ccc_tree, hf_pkt_ccc_ts, tvb, 4, 8,",
          "2328:                     ENC_TIME_NTP|ENC_BIG_ENDIAN);",
          "2329:     }",
          "2331:     return dissect_rtp(tvb, pinfo, tree, data);",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "2337: void",
          "2338: proto_register_pkt_ccc(void)",
          "2339: {",
          "2389: }",
          "2391: void",
          "2392: proto_reg_handoff_pkt_ccc(void)",
          "2393: {",
          "2416: }",
          "",
          "[Removed Lines]",
          "2340:  static hf_register_info hf[] =",
          "2341:  {",
          "2342:   {",
          "2343:    &hf_pkt_ccc_id,",
          "2344:    {",
          "2345:     \"PacketCable CCC Identifier\",",
          "2346:     \"pkt_ccc.ccc_id\",",
          "2347:     FT_UINT32,",
          "2348:     BASE_DEC,",
          "2349:     NULL,",
          "2350:     0x0,",
          "2351:     NULL, HFILL",
          "2352:    }",
          "2353:   },",
          "2354:   {",
          "2355:    &hf_pkt_ccc_ts,",
          "2356:    {",
          "2357:     \"PacketCable CCC Timestamp\",",
          "2358:     \"pkt_ccc.ts\",",
          "2359:     FT_ABSOLUTE_TIME,",
          "2360:     ABSOLUTE_TIME_UTC,",
          "2361:     NULL,",
          "2362:     0x0,",
          "2363:     NULL, HFILL",
          "2364:    }",
          "2365:   },",
          "2367:  };",
          "2369:  static gint *ett[] =",
          "2370:  {",
          "2371:   &ett_pkt_ccc,",
          "2372:  };",
          "2374:  module_t *pkt_ccc_module;",
          "2376:  proto_pkt_ccc = proto_register_protocol(\"PacketCable Call Content Connection\",",
          "2377:      \"PKT CCC\", \"pkt_ccc\");",
          "2378:  proto_register_field_array(proto_pkt_ccc, hf, array_length(hf));",
          "2379:  proto_register_subtree_array(ett, array_length(ett));",
          "2381:  new_register_dissector(\"pkt_ccc\", dissect_pkt_ccc, proto_pkt_ccc);",
          "2383:  pkt_ccc_module = prefs_register_protocol(proto_pkt_ccc, proto_reg_handoff_pkt_ccc);",
          "2385:  prefs_register_uint_preference(pkt_ccc_module, \"udp_port\",",
          "2386:                                 \"UDP port\",",
          "2387:                                 \"Decode packets on this UDP port as PacketCable CCC\",",
          "2388:                                 10, &global_pkt_ccc_udp_port);",
          "2398:  static gboolean initialized = FALSE;",
          "2399:  static dissector_handle_t pkt_ccc_handle;",
          "2400:  static guint saved_pkt_ccc_udp_port;",
          "2402:  if (!initialized) {",
          "2403:   pkt_ccc_handle = find_dissector(\"pkt_ccc\");",
          "2405:   initialized = TRUE;",
          "2406:  } else {",
          "2407:   if (saved_pkt_ccc_udp_port != 0) {",
          "2408:    dissector_delete_uint(\"udp.port\", saved_pkt_ccc_udp_port, pkt_ccc_handle);",
          "2409:   }",
          "2410:  }",
          "2412:  if (global_pkt_ccc_udp_port != 0) {",
          "2413:   dissector_add_uint(\"udp.port\", global_pkt_ccc_udp_port, pkt_ccc_handle);",
          "2414:  }",
          "2415:  saved_pkt_ccc_udp_port = global_pkt_ccc_udp_port;",
          "",
          "[Added Lines]",
          "2340:     static hf_register_info hf[] =",
          "2341:     {",
          "2342:         {",
          "2343:             &hf_pkt_ccc_id,",
          "2344:             {",
          "2345:                 \"PacketCable CCC Identifier\",",
          "2346:                 \"pkt_ccc.ccc_id\",",
          "2347:                 FT_UINT32,",
          "2348:                 BASE_DEC,",
          "2349:                 NULL,",
          "2350:                 0x0,",
          "2351:                 NULL, HFILL",
          "2352:             }",
          "2353:         },",
          "2354:         {",
          "2355:             &hf_pkt_ccc_ts,",
          "2356:             {",
          "2357:                 \"PacketCable CCC Timestamp\",",
          "2358:                 \"pkt_ccc.ts\",",
          "2359:                 FT_ABSOLUTE_TIME,",
          "2360:                 ABSOLUTE_TIME_UTC,",
          "2361:                 NULL,",
          "2362:                 0x0,",
          "2363:                 NULL, HFILL",
          "2364:             }",
          "2365:         },",
          "2367:     };",
          "2369:     static gint *ett[] =",
          "2370:     {",
          "2371:         &ett_pkt_ccc,",
          "2372:     };",
          "2374:     module_t *pkt_ccc_module;",
          "2376:     proto_pkt_ccc = proto_register_protocol(\"PacketCable Call Content Connection\",",
          "2377:         \"PKT CCC\", \"pkt_ccc\");",
          "2378:     proto_register_field_array(proto_pkt_ccc, hf, array_length(hf));",
          "2379:     proto_register_subtree_array(ett, array_length(ett));",
          "2381:     new_register_dissector(\"pkt_ccc\", dissect_pkt_ccc, proto_pkt_ccc);",
          "2383:     pkt_ccc_module = prefs_register_protocol(proto_pkt_ccc, proto_reg_handoff_pkt_ccc);",
          "2385:     prefs_register_uint_preference(pkt_ccc_module, \"udp_port\",",
          "2386:                                    \"UDP port\",",
          "2387:                                    \"Decode packets on this UDP port as PacketCable CCC\",",
          "2388:                                    10, &global_pkt_ccc_udp_port);",
          "2398:     static gboolean initialized = FALSE;",
          "2399:     static dissector_handle_t pkt_ccc_handle;",
          "2400:     static guint saved_pkt_ccc_udp_port;",
          "2402:     if (!initialized) {",
          "2403:         pkt_ccc_handle = find_dissector(\"pkt_ccc\");",
          "2405:         initialized = TRUE;",
          "2406:     } else {",
          "2407:         if (saved_pkt_ccc_udp_port != 0) {",
          "2408:             dissector_delete_uint(\"udp.port\", saved_pkt_ccc_udp_port, pkt_ccc_handle);",
          "2409:         }",
          "2410:     }",
          "2412:     if (global_pkt_ccc_udp_port != 0) {",
          "2413:         dissector_add_uint(\"udp.port\", global_pkt_ccc_udp_port, pkt_ccc_handle);",
          "2414:     }",
          "2415:     saved_pkt_ccc_udp_port = global_pkt_ccc_udp_port;",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "2420: void",
          "2421: proto_register_rtp(void)",
          "2422: {",
          "3279: }",
          "3281: void",
          "3282: proto_reg_handoff_rtp(void)",
          "3283: {",
          "3332: }",
          "",
          "[Removed Lines]",
          "2423:  static hf_register_info hf[] =",
          "2424:  {",
          "2425:   {",
          "2426:    &hf_rtp_version,",
          "2427:    {",
          "2428:     \"Version\",",
          "2429:     \"rtp.version\",",
          "2430:     FT_UINT8,",
          "2431:     BASE_DEC,",
          "2432:     VALS(rtp_version_vals),",
          "2433:     0xC0,",
          "2434:     NULL, HFILL",
          "2435:    }",
          "2436:   },",
          "2437:   {",
          "2438:    &hf_rtp_padding,",
          "2439:    {",
          "2440:     \"Padding\",",
          "2441:     \"rtp.padding\",",
          "2442:     FT_BOOLEAN,",
          "2443:     8,",
          "2444:     NULL,",
          "2445:     0x20,",
          "2446:     NULL, HFILL",
          "2447:    }",
          "2448:   },",
          "2449:   {",
          "2450:    &hf_rtp_extension,",
          "2451:    {",
          "2452:     \"Extension\",",
          "2453:     \"rtp.ext\",",
          "2454:     FT_BOOLEAN,",
          "2455:     8,",
          "2456:     NULL,",
          "2457:     0x10,",
          "2458:     NULL, HFILL",
          "2459:    }",
          "2460:   },",
          "2461:   {",
          "2462:    &hf_rtp_csrc_count,",
          "2463:    {",
          "2464:     \"Contributing source identifiers count\",",
          "2465:     \"rtp.cc\",",
          "2466:     FT_UINT8,",
          "2467:     BASE_DEC,",
          "2468:     NULL,",
          "2469:     0x0F,",
          "2470:     NULL, HFILL",
          "2471:    }",
          "2472:   },",
          "2473:   {",
          "2474:    &hf_rtp_marker,",
          "2475:    {",
          "2476:     \"Marker\",",
          "2477:     \"rtp.marker\",",
          "2478:     FT_BOOLEAN,",
          "2479:     8,",
          "2480:     NULL,",
          "2481:     0x80,",
          "2482:     NULL, HFILL",
          "2483:    }",
          "2484:   },",
          "2485:   {",
          "2486:    &hf_rtp_payload_type,",
          "2487:    {",
          "2488:     \"Payload type\",",
          "2489:     \"rtp.p_type\",",
          "2490:     FT_UINT8,",
          "2491:     BASE_DEC,",
          "2492:     NULL,",
          "2493:     0x7F,",
          "2494:     NULL, HFILL",
          "2495:    }",
          "2496:   },",
          "2497:   {",
          "2498:    &hf_rtp_seq_nr,",
          "2499:    {",
          "2500:     \"Sequence number\",",
          "2501:     \"rtp.seq\",",
          "2502:     FT_UINT16,",
          "2503:     BASE_DEC,",
          "2504:     NULL,",
          "2505:     0x0,",
          "2506:     NULL, HFILL",
          "2507:    }",
          "2508:   },",
          "2509:   {",
          "2510:    &hf_rtp_ext_seq_nr,",
          "2511:    {",
          "2512:     \"Extended sequence number\",",
          "2513:     \"rtp.extseq\",",
          "2514:     FT_UINT32,",
          "2515:     BASE_DEC,",
          "2516:     NULL,",
          "2517:     0x0,",
          "2518:     NULL, HFILL",
          "2519:    }",
          "2520:   },",
          "2521:   {",
          "2522:    &hf_rtp_timestamp,",
          "2523:    {",
          "2524:     \"Timestamp\",",
          "2525:     \"rtp.timestamp\",",
          "2526:     FT_UINT32,",
          "2527:     BASE_DEC,",
          "2528:     NULL,",
          "2529:     0x0,",
          "2530:     NULL, HFILL",
          "2531:    }",
          "2532:   },",
          "2533:   {",
          "2534:    &hf_rtp_ssrc,",
          "2535:    {",
          "2536:     \"Synchronization Source identifier\",",
          "2537:     \"rtp.ssrc\",",
          "2538:     FT_UINT32,",
          "2539:     BASE_HEX_DEC,",
          "2540:     NULL,",
          "2541:     0x0,",
          "2542:     NULL, HFILL",
          "2543:    }",
          "2544:   },",
          "2545:   {",
          "2546:    &hf_rtp_prof_define,",
          "2547:    {",
          "2548:     \"Defined by profile\",",
          "2549:     \"rtp.ext.profile\",",
          "2550:     FT_UINT16,",
          "2551:     BASE_HEX_DEC,",
          "2552:     VALS(rtp_ext_profile_vals),",
          "2553:     0x0,",
          "2554:     NULL, HFILL",
          "2555:    }",
          "2556:   },",
          "2557:   {",
          "2558:    &hf_rtp_length,",
          "2559:    {",
          "2560:     \"Extension length\",",
          "2561:     \"rtp.ext.len\",",
          "2562:     FT_UINT16,",
          "2563:     BASE_DEC,",
          "2564:     NULL,",
          "2565:     0x0,",
          "2566:     NULL, HFILL",
          "2567:    }",
          "2568:   },",
          "2569:   {",
          "2570:    &hf_rtp_csrc_items,",
          "2571:    {",
          "2572:     \"Contributing Source identifiers\",",
          "2573:     \"rtp.csrc.items\",",
          "2574:     FT_NONE,",
          "2575:     BASE_NONE,",
          "2576:     NULL,",
          "2577:     0x0,",
          "2578:     NULL, HFILL",
          "2579:    }",
          "2580:   },",
          "2581:   {",
          "2582:    &hf_rtp_csrc_item,",
          "2583:    {",
          "2584:     \"CSRC item\",",
          "2585:     \"rtp.csrc.item\",",
          "2586:     FT_UINT32,",
          "2587:     BASE_HEX_DEC,",
          "2588:     NULL,",
          "2589:     0x0,",
          "2590:     NULL, HFILL",
          "2591:    }",
          "2592:   },",
          "2593:   {",
          "2594:    &hf_rtp_hdr_exts,",
          "2595:    {",
          "2596:     \"Header extensions\",",
          "2597:     \"rtp.hdr_exts\",",
          "2598:     FT_NONE,",
          "2599:     BASE_NONE,",
          "2600:     NULL,",
          "2601:     0x0,",
          "2602:     NULL, HFILL",
          "2603:    }",
          "2604:   },",
          "2606:   {",
          "2607:    &hf_rtp_hdr_ed137s,",
          "2608:    {",
          "2609:     \"ED137 extensions\",",
          "2610:     \"rtp.ext.ed137s\",",
          "2611:     FT_NONE,",
          "2612:     BASE_NONE,",
          "2613:     NULL,",
          "2614:     0x0,",
          "2615:     NULL, HFILL",
          "2616:    }",
          "2617:   },",
          "2619:   {",
          "2620:    &hf_rtp_hdr_ed137,",
          "2621:    {",
          "2622:     \"ED137 extension\",",
          "2623:     \"rtp.ext.ed137\",",
          "2624:     FT_NONE,",
          "2625:     BASE_NONE,",
          "2626:     NULL,",
          "2627:     0x0,",
          "2628:     NULL, HFILL",
          "2629:    }",
          "2630:   },",
          "2631:   {",
          "2632:    &hf_rtp_hdr_ed137_ptt_type,",
          "2633:    {",
          "2634:     \"PTT Type\",",
          "2635:     \"rtp.ext.ed137.ptt_type\",",
          "2636:     FT_UINT32,",
          "2637:     BASE_DEC,",
          "2638:     VALS(rtp_ext_ed137_ptt_type),",
          "2639:     0xE0000000,",
          "2640:     NULL, HFILL",
          "2641:    }",
          "2642:   },",
          "2643:   {",
          "2644:    &hf_rtp_hdr_ed137_squ,",
          "2645:    {",
          "2646:     \"SQU\",",
          "2647:     \"rtp.ext.ed137.squ\",",
          "2648:     FT_UINT32,",
          "2649:     BASE_DEC,",
          "2650:     VALS(rtp_ext_ed137_squ),",
          "2651:     0x10000000,",
          "2652:     NULL, HFILL",
          "2653:    }",
          "2654:   },",
          "2655:   {",
          "2656:    &hf_rtp_hdr_ed137_ptt_id,",
          "2657:    {",
          "2658:     \"PTT-id\",",
          "2659:     \"rtp.ext.ed137.ptt_id\",",
          "2660:     FT_UINT32,",
          "2661:     BASE_DEC,",
          "2662:     NULL,",
          "2663:     0x0F000000,",
          "2664:     NULL, HFILL",
          "2665:    }",
          "2666:   },",
          "2667:   {",
          "2668:    &hf_rtp_hdr_ed137_sct,",
          "2669:    {",
          "2670:     \"Simultaneous Call Transmissions\",",
          "2671:     \"rtp.ext.ed137.sct\",",
          "2672:     FT_UINT32,",
          "2673:     BASE_DEC,",
          "2674:     NULL,",
          "2675:     0x00800000,",
          "2676:     NULL, HFILL",
          "2677:    }",
          "2678:   },",
          "2679:   {",
          "2680:    &hf_rtp_hdr_ed137_x,",
          "2681:    {",
          "2682:     \"X\",",
          "2683:     \"rtp.ext.ed137.x\",",
          "2684:     FT_UINT32,",
          "2685:     BASE_DEC,",
          "2686:     NULL,",
          "2687:     0x00400000,",
          "2688:     NULL, HFILL",
          "2689:    }",
          "2690:   },",
          "2691:   {",
          "2692:    &hf_rtp_hdr_ed137_x_nu,",
          "2693:    {",
          "2694:     \"Not used\",",
          "2695:     \"rtp.ext.ed137.x-nu\",",
          "2696:     FT_UINT32,",
          "2697:     BASE_DEC,",
          "2698:     NULL,",
          "2699:     0x003FFFFE,",
          "2700:     NULL, HFILL",
          "2701:    }",
          "2702:   },",
          "2703:   {",
          "2704:    &hf_rtp_hdr_ed137_ft_type,",
          "2705:    {",
          "2706:     \"Feature type\",",
          "2707:     \"rtp.ext.ed137.ft.type\",",
          "2708:     FT_UINT32,",
          "2709:     BASE_HEX_DEC,",
          "2710:     VALS(rtp_ext_ed137_ft_type),",
          "2711:     0x003C0000,",
          "2712:     NULL, HFILL",
          "2713:    }",
          "2714:   },",
          "2715:   {",
          "2716:    &hf_rtp_hdr_ed137_ft_len,",
          "2717:    {",
          "2718:     \"Feature length\",",
          "2719:     \"rtp.ext.ed137.ft.len\",",
          "2720:     FT_UINT32,",
          "2721:     BASE_DEC,",
          "2722:     NULL,",
          "2723:     0x0003C000,",
          "2724:     NULL, HFILL",
          "2725:    }",
          "2726:   },",
          "2727:   {",
          "2728:    &hf_rtp_hdr_ed137_ft_value,",
          "2729:    {",
          "2730:     \"Feature value\",",
          "2731:     \"rtp.ext.ed137.ft.value\",",
          "2732:     FT_UINT32,",
          "2733:     BASE_HEX_DEC,",
          "2734:     NULL,",
          "2735:     0x00003FFE,",
          "2736:     NULL, HFILL",
          "2737:    }",
          "2738:   },",
          "2739:   {",
          "2740:    &hf_rtp_hdr_ed137_vf,",
          "2741:    {",
          "2742:     \"VF\",",
          "2743:     \"rtp.ext.ed137.vf\",",
          "2744:     FT_UINT32,",
          "2745:     BASE_DEC,",
          "2746:     VALS(rtp_ext_ed137_vf),",
          "2747:     0x00000001,",
          "2748:     NULL, HFILL",
          "2749:    }",
          "2750:   },",
          "2751:   {",
          "2752:    &hf_rtp_hdr_ed137_ft_bss_qidx,",
          "2753:    {",
          "2754:     \"BSS Quality Index\",",
          "2755:     \"rtp.ext.ed137.ft.bss.qidx\",",
          "2756:     FT_UINT32,",
          "2757:     BASE_DEC,",
          "2758:     NULL,",
          "2759:     0x00003FC0,",
          "2760:     NULL, HFILL",
          "2761:    }",
          "2762:   },",
          "2763:   {",
          "2764:    &hf_rtp_hdr_ed137_ft_bss_rssi_qidx,",
          "2765:    {",
          "2766:     \"BSS Quality Index\",",
          "2767:     \"rtp.ext.ed137.ft.bss.qidx\",",
          "2768:     FT_UINT32,",
          "2769:     BASE_DEC,",
          "2770:     VALS(rtp_ext_ed137_ft_bss_rssi_qidx),",
          "2771:     0x00003FC0,",
          "2772:     NULL, HFILL",
          "2773:    }",
          "2774:   },",
          "2775:   {",
          "2776:    &hf_rtp_hdr_ed137_ft_bss_qidx_ml,",
          "2777:    {",
          "2778:     \"BSS Quality Index Method\",",
          "2779:     \"rtp.ext.ed137.ft.bss.qidx-ml\",",
          "2780:     FT_UINT32,",
          "2781:     BASE_DEC,",
          "2782:     VALS(rtp_ext_ed137_ft_bss_qidx_ml),",
          "2783:     0x00000038,",
          "2784:     NULL, HFILL",
          "2785:    }",
          "2786:   },",
          "2787:   {",
          "2788:    &hf_rtp_hdr_ed137_ft_bss_nu,",
          "2789:    {",
          "2790:     \"Not used\",",
          "2791:     \"rtp.ext.ed137.ft.bss-nu\",",
          "2792:     FT_UINT32,",
          "2793:     BASE_DEC,",
          "2794:     NULL,",
          "2795:     0x00000006,",
          "2796:     NULL, HFILL",
          "2797:    }",
          "2798:   },",
          "2800:   {",
          "2801:    &hf_rtp_hdr_ed137a,",
          "2802:    {",
          "2803:     \"ED137A extension\",",
          "2804:     \"rtp.ext.ed137A\",",
          "2805:     FT_NONE,",
          "2806:     BASE_NONE,",
          "2807:     NULL,",
          "2808:     0x0,",
          "2809:     NULL, HFILL",
          "2810:    }",
          "2811:   },",
          "2812:   {",
          "2813:    &hf_rtp_hdr_ed137a_ptt_type,",
          "2814:    {",
          "2815:     \"PTT Type\",",
          "2816:     \"rtp.ext.ed137A.ptt_type\",",
          "2817:     FT_UINT32,",
          "2818:     BASE_DEC,",
          "2819:     VALS(rtp_ext_ed137a_ptt_type),",
          "2820:     0xE0000000,",
          "2821:     NULL, HFILL",
          "2822:    }",
          "2823:   },",
          "2824:   {",
          "2825:    &hf_rtp_hdr_ed137a_squ,",
          "2826:    {",
          "2827:     \"SQU\",",
          "2828:     \"rtp.ext.ed137A.squ\",",
          "2829:     FT_UINT32,",
          "2830:     BASE_DEC,",
          "2831:     VALS(rtp_ext_ed137a_squ),",
          "2832:     0x10000000,",
          "2833:     NULL, HFILL",
          "2834:    }",
          "2835:   },",
          "2836:   {",
          "2837:    &hf_rtp_hdr_ed137a_ptt_id,",
          "2838:    {",
          "2839:     \"PTT-id\",",
          "2840:     \"rtp.ext.ed137A.ptt_id\",",
          "2841:     FT_UINT32,",
          "2842:     BASE_DEC,",
          "2843:     NULL,",
          "2844:     0x0FC00000,",
          "2845:     NULL, HFILL",
          "2846:    }",
          "2847:   },",
          "2848:   {",
          "2849:    &hf_rtp_hdr_ed137a_pm,",
          "2850:    {",
          "2851:     \"PTT Mute\",",
          "2852:     \"rtp.ext.ed137A.pm\",",
          "2853:     FT_UINT32,",
          "2854:     BASE_DEC,",
          "2855:     NULL,",
          "2856:     0x00200000,",
          "2857:     NULL, HFILL",
          "2858:    }",
          "2859:   },",
          "2860:   {",
          "2861:    &hf_rtp_hdr_ed137a_ptts,",
          "2862:    {",
          "2863:     \"PTT Summation\",",
          "2864:     \"rtp.ext.ed137A.ptts\",",
          "2865:     FT_UINT32,",
          "2866:     BASE_DEC,",
          "2867:     NULL,",
          "2868:     0x00100000,",
          "2869:     NULL, HFILL",
          "2870:    }",
          "2871:   },",
          "2872:   {",
          "2873:    &hf_rtp_hdr_ed137a_sct,",
          "2874:    {",
          "2875:     \"Simultaneous Call Transmissions\",",
          "2876:     \"rtp.ext.ed137a.sct\",",
          "2877:     FT_UINT32,",
          "2878:     BASE_DEC,",
          "2879:     NULL,",
          "2880:     0x00080000,",
          "2881:     NULL, HFILL",
          "2882:    }",
          "2883:   },",
          "2884:   {",
          "2885:    &hf_rtp_hdr_ed137a_reserved,",
          "2886:    {",
          "2887:     \"Reserved\",",
          "2888:     \"rtp.ext.ed137A.reserved\",",
          "2889:     FT_UINT32,",
          "2890:     BASE_HEX_DEC,",
          "2891:     NULL,",
          "2892:     0x00060000,",
          "2893:     NULL, HFILL",
          "2894:    }",
          "2895:   },",
          "2896:   {",
          "2897:    &hf_rtp_hdr_ed137a_x,",
          "2898:    {",
          "2899:     \"X\",",
          "2900:     \"rtp.ext.ed137A.x\",",
          "2901:     FT_UINT32,",
          "2902:     BASE_DEC,",
          "2903:     NULL,",
          "2904:     0x00010000,",
          "2905:     NULL, HFILL",
          "2906:    }",
          "2907:   },",
          "2908:   {",
          "2909:    &hf_rtp_hdr_ed137a_x_nu,",
          "2910:    {",
          "2911:     \"Not used\",",
          "2912:     \"rtp.ext.ed137A.x-nu\",",
          "2913:     FT_UINT32,",
          "2914:     BASE_DEC,",
          "2915:     NULL,",
          "2916:     0x0000FFFF,",
          "2917:     NULL, HFILL",
          "2918:    }",
          "2919:   },",
          "2920:   {",
          "2921:    &hf_rtp_hdr_ed137a_ft_type,",
          "2922:    {",
          "2923:     \"Feature type\",",
          "2924:     \"rtp.ext.ed137A.ft.type\",",
          "2925:     FT_UINT32,",
          "2926:     BASE_HEX_DEC,",
          "2927:     VALS(rtp_ext_ed137a_ft_type),",
          "2928:     0x0000F000,",
          "2929:     NULL, HFILL",
          "2930:    }",
          "2931:   },",
          "2932:   {",
          "2933:    &hf_rtp_hdr_ed137a_ft_len,",
          "2934:    {",
          "2935:     \"Feature length\",",
          "2936:     \"rtp.ext.ed137A.ft.len\",",
          "2937:     FT_UINT32,",
          "2938:     BASE_DEC,",
          "2939:     NULL,",
          "2940:     0x00000F00,",
          "2941:     NULL, HFILL",
          "2942:    }",
          "2943:   },",
          "2944:   {",
          "2945:    &hf_rtp_hdr_ed137a_ft_value,",
          "2946:    {",
          "2947:     \"Feature value\",",
          "2948:     \"rtp.ext.ed137A.ft.value\",",
          "2949:     FT_UINT32,",
          "2950:     BASE_HEX_DEC,",
          "2951:     NULL,",
          "2952:     0x000000FF,",
          "2953:     NULL, HFILL",
          "2954:    }",
          "2955:   },",
          "2957:   {",
          "2958:    &hf_rtp_hdr_ext,",
          "2959:    {",
          "2960:     \"Header extension\",",
          "2961:     \"rtp.hdr_ext\",",
          "2962:     FT_UINT32,",
          "2963:     BASE_HEX_DEC,",
          "2964:     NULL,",
          "2965:     0x0,",
          "2966:     NULL, HFILL",
          "2967:    }",
          "2968:   },",
          "2969:   {",
          "2970:    &hf_rtp_data,",
          "2971:    {",
          "2972:     \"Payload\",",
          "2973:     \"rtp.payload\",",
          "2974:     FT_BYTES,",
          "2975:     BASE_NONE,",
          "2976:     NULL,",
          "2977:     0x0,",
          "2978:     NULL, HFILL",
          "2979:    }",
          "2980:   },",
          "2981:   {",
          "2982:    &hf_rtp_padding_data,",
          "2983:    {",
          "2984:     \"Padding data\",",
          "2985:     \"rtp.padding.data\",",
          "2986:     FT_BYTES,",
          "2987:     BASE_NONE,",
          "2988:     NULL,",
          "2989:     0x0,",
          "2990:     NULL, HFILL",
          "2991:    }",
          "2992:   },",
          "2993:   {",
          "2994:    &hf_rtp_padding_count,",
          "2995:    {",
          "2996:     \"Padding count\",",
          "2997:     \"rtp.padding.count\",",
          "2998:     FT_UINT8,",
          "2999:     BASE_DEC,",
          "3000:     NULL,",
          "3001:     0x0,",
          "3002:     NULL, HFILL",
          "3003:    }",
          "3004:   },",
          "3005:   {",
          "3006:    &hf_rtp_setup,",
          "3007:    {",
          "3008:     \"Stream setup\",",
          "3009:     \"rtp.setup\",",
          "3010:     FT_STRING,",
          "3011:     BASE_NONE,",
          "3012:     NULL,",
          "3013:     0x0,",
          "3014:     \"Stream setup, method and frame number\", HFILL",
          "3015:    }",
          "3016:   },",
          "3017:   {",
          "3018:    &hf_rtp_setup_frame,",
          "3019:    {",
          "3020:     \"Setup frame\",",
          "3021:     \"rtp.setup-frame\",",
          "3022:     FT_FRAMENUM,",
          "3023:     BASE_NONE,",
          "3024:     NULL,",
          "3025:     0x0,",
          "3026:     \"Frame that set up this stream\", HFILL",
          "3027:    }",
          "3028:   },",
          "3029:   {",
          "3030:    &hf_rtp_setup_method,",
          "3031:    {",
          "3032:     \"Setup Method\",",
          "3033:     \"rtp.setup-method\",",
          "3034:     FT_STRING,",
          "3035:     BASE_NONE,",
          "3036:     NULL,",
          "3037:     0x0,",
          "3038:     \"Method used to set up this stream\", HFILL",
          "3039:    }",
          "3040:   },",
          "3041:   {",
          "3042:    &hf_rtp_rfc2198_follow,",
          "3043:    {",
          "3044:     \"Follow\",",
          "3045:     \"rtp.follow\",",
          "3046:     FT_BOOLEAN,",
          "3047:     8,",
          "3048:     TFS(&tfs_set_notset),",
          "3049:     0x80,",
          "3050:     \"Next header follows\", HFILL",
          "3051:    }",
          "3052:   },",
          "3053:   {",
          "3054:    &hf_rtp_rfc2198_tm_off,",
          "3055:    {",
          "3056:     \"Timestamp offset\",",
          "3057:     \"rtp.timestamp-offset\",",
          "3058:     FT_UINT16,",
          "3059:     BASE_DEC,",
          "3060:     NULL,",
          "3061:     0xFFFC,",
          "3062:     NULL, HFILL",
          "3063:    }",
          "3064:   },",
          "3065:   {",
          "3066:    &hf_rtp_rfc2198_bl_len,",
          "3067:    {",
          "3068:     \"Block length\",",
          "3069:     \"rtp.block-length\",",
          "3070:     FT_UINT16,",
          "3071:     BASE_DEC,",
          "3072:     NULL,",
          "3073:     0x03FF,",
          "3074:     NULL, HFILL",
          "3075:    }",
          "3076:   },",
          "3077:   {",
          "3078:    &hf_rtp_ext_rfc5285_id,",
          "3079:    {",
          "3080:     \"Identifier\",",
          "3081:     \"rtp.ext.rfc5285.id\",",
          "3082:     FT_UINT8,",
          "3083:     BASE_DEC,",
          "3084:     NULL,",
          "3085:     0x0,",
          "3086:     \"RFC 5285 Header Extension Identifier\",",
          "3087:     HFILL",
          "3088:    }",
          "3089:   },",
          "3090:   {",
          "3091:    &hf_rtp_ext_rfc5285_length,",
          "3092:    {",
          "3093:     \"Length\",",
          "3094:     \"rtp.ext.rfc5285.len\",",
          "3095:     FT_UINT8,",
          "3096:     BASE_DEC,",
          "3097:     NULL,",
          "3098:     0x0,",
          "3099:     \"RFC 5285 Header Extension length\",",
          "3100:     HFILL",
          "3101:    }",
          "3102:   },",
          "3103:   {",
          "3104:    &hf_rtp_ext_rfc5285_appbits,",
          "3105:    {",
          "3106:     \"Application Bits\",",
          "3107:     \"rtp.ext.rfc5285.appbits\",",
          "3108:     FT_UINT8,",
          "3109:     BASE_DEC,",
          "3110:     NULL,",
          "3111:     0x0,",
          "3112:     \"RFC 5285 2-bytes header application bits\",",
          "3113:     HFILL",
          "3114:    }",
          "3115:   },",
          "3116:   {",
          "3117:    &hf_rtp_ext_rfc5285_data,",
          "3118:    {",
          "3119:     \"Extension Data\",",
          "3120:     \"rtp.ext.rfc5285.data\",",
          "3121:     FT_BYTES,",
          "3122:     BASE_NONE,",
          "3123:     NULL,",
          "3124:     0x0,",
          "3125:     \"RFC 5285 Extension Data\",",
          "3126:     HFILL",
          "3127:    }",
          "3128:   },",
          "3131:   {&hf_rtp_fragments,",
          "3132:    {\"RTP Fragments\", \"rtp.fragments\", FT_NONE, BASE_NONE, NULL, 0x0,",
          "3133:     NULL, HFILL }",
          "3134:   },",
          "3136:   {&hf_rtp_fragment,",
          "3137:    {\"RTP Fragment data\", \"rtp.fragment\", FT_FRAMENUM, BASE_NONE, NULL, 0x0,",
          "3138:     NULL, HFILL }",
          "3139:   },",
          "3141:   {&hf_rtp_fragment_overlap,",
          "3142:    {\"Fragment overlap\", \"rtp.fragment.overlap\", FT_BOOLEAN, BASE_NONE,",
          "3143:     NULL, 0x0, \"Fragment overlaps with other fragments\", HFILL }",
          "3144:   },",
          "3146:   {&hf_rtp_fragment_overlap_conflict,",
          "3147:    {\"Conflicting data in fragment overlap\", \"rtp.fragment.overlap.conflict\",",
          "3148:     FT_BOOLEAN, BASE_NONE, NULL, 0x0,",
          "3149:     \"Overlapping fragments contained conflicting data\", HFILL }",
          "3150:   },",
          "3152:   {&hf_rtp_fragment_multiple_tails,",
          "3153:    {\"Multiple tail fragments found\", \"rtp.fragment.multipletails\",",
          "3154:     FT_BOOLEAN, BASE_NONE, NULL, 0x0,",
          "3155:     \"Several tails were found when defragmenting the packet\", HFILL }",
          "3156:   },",
          "3158:   {&hf_rtp_fragment_too_long_fragment,",
          "3159:    {\"Fragment too long\", \"rtp.fragment.toolongfragment\",",
          "3160:     FT_BOOLEAN, BASE_NONE, NULL, 0x0,",
          "3161:     \"Fragment contained data past end of packet\", HFILL }",
          "3162:   },",
          "3164:   {&hf_rtp_fragment_error,",
          "3165:    {\"Defragmentation error\", \"rtp.fragment.error\",",
          "3166:     FT_FRAMENUM, BASE_NONE, NULL, 0x0,",
          "3167:     \"Defragmentation error due to illegal fragments\", HFILL }",
          "3168:   },",
          "3170:   {&hf_rtp_fragment_count,",
          "3171:    {\"Fragment count\", \"rtp.fragment.count\",",
          "3172:     FT_UINT32, BASE_DEC, NULL, 0x0,",
          "3173:     NULL, HFILL }",
          "3174:   },",
          "3176:   {&hf_rtp_reassembled_in,",
          "3177:    {\"RTP fragment, reassembled in frame\", \"rtp.reassembled_in\",",
          "3178:     FT_FRAMENUM, BASE_NONE, NULL, 0x0,",
          "3179:     \"This RTP packet is reassembled in this frame\", HFILL }",
          "3180:   },",
          "3181:   {&hf_rtp_reassembled_length,",
          "3182:    {\"Reassembled RTP length\", \"rtp.reassembled.length\",",
          "3183:     FT_UINT32, BASE_DEC, NULL, 0x0,",
          "3184:     \"The total length of the reassembled payload\", HFILL }",
          "3185:   },",
          "3186:   {&hf_srtp_encrypted_payload,",
          "3187:    {\"SRTP Encrypted Payload\", \"srtp.enc_payload\",",
          "3188:     FT_BYTES, BASE_NONE, NULL, 0x0,",
          "3189:     NULL, HFILL }",
          "3190:   },",
          "3191:   {&hf_srtp_mki,",
          "3192:    {\"SRTP MKI\", \"srtp.mki\",",
          "3193:     FT_BYTES, BASE_NONE, NULL, 0x0,",
          "3194:     \"SRTP Master Key Index\", HFILL }",
          "3195:   },",
          "3196:   {&hf_srtp_auth_tag,",
          "3197:    {\"SRTP Auth Tag\", \"srtp.auth_tag\",",
          "3198:     FT_BYTES, BASE_NONE, NULL, 0x0,",
          "3199:     \"SRTP Authentication Tag\", HFILL }",
          "3200:   }",
          "3202:  };",
          "3204:  static gint *ett[] =",
          "3205:  {",
          "3206:   &ett_rtp,",
          "3207:   &ett_csrc_list,",
          "3208:   &ett_hdr_ext,",
          "3209:   &ett_hdr_ext_rfc5285,",
          "3210:   &ett_hdr_ext_ed137s,",
          "3211:   &ett_hdr_ext_ed137,",
          "3212:   &ett_hdr_ext_ed137a,",
          "3213:   &ett_rtp_setup,",
          "3214:   &ett_rtp_rfc2198,",
          "3215:   &ett_rtp_rfc2198_hdr,",
          "3216:   &ett_rtp_fragment,",
          "3217:   &ett_rtp_fragments",
          "3218:  };",
          "3220:  module_t *rtp_module;",
          "3223:  proto_rtp = proto_register_protocol(\"Real-Time Transport Protocol\",",
          "3224:          \"RTP\", \"rtp\");",
          "3225:  proto_register_field_array(proto_rtp, hf, array_length(hf));",
          "3226:  proto_register_subtree_array(ett, array_length(ett));",
          "3228:  new_register_dissector(\"rtp\", dissect_rtp, proto_rtp);",
          "3229:  register_dissector(\"rtp.rfc2198\", dissect_rtp_rfc2198, proto_rtp);",
          "3231:  rtp_tap = register_tap(\"rtp\");",
          "3233:  rtp_pt_dissector_table = register_dissector_table(\"rtp.pt\",",
          "3234:          \"RTP payload type\", FT_UINT8, BASE_DEC);",
          "3235:  rtp_dyn_pt_dissector_table = register_dissector_table(\"rtp_dyn_payload_type\",",
          "3236:          \"Dynamic RTP payload type\", FT_STRING, BASE_NONE);",
          "3239:  rtp_hdr_ext_dissector_table = register_dissector_table(\"rtp.hdr_ext\",",
          "3240:          \"RTP header extension\", FT_UINT32, BASE_HEX);",
          "3241:  rtp_hdr_ext_rfc5285_dissector_table = register_dissector_table(\"rtp.ext.rfc5285.id\",",
          "3242:          \"RTP Generic header extension (RFC 5285)\", FT_UINT8, BASE_DEC);",
          "3244:  register_dissector(\"rtp.ext.ed137\", dissect_rtp_hdr_ext_ed137, proto_rtp);",
          "3245:  register_dissector(\"rtp.ext.ed137a\", dissect_rtp_hdr_ext_ed137a, proto_rtp);",
          "3247:  rtp_module = prefs_register_protocol(proto_rtp, proto_reg_handoff_rtp);",
          "3249:  prefs_register_bool_preference(rtp_module, \"show_setup_info\",",
          "3250:          \"Show stream setup information\",",
          "3251:          \"Where available, show which protocol and frame caused \"",
          "3252:          \"this RTP stream to be created\",",
          "3253:          &global_rtp_show_setup_info);",
          "3255:  prefs_register_bool_preference(rtp_module, \"heuristic_rtp\",",
          "3256:          \"Try to decode RTP outside of conversations\",",
          "3257:          \"If call control SIP/H323/RTSP/.. messages are missing in the trace, \"",
          "3258:          \"RTP isn't decoded without this\",",
          "3259:          &global_rtp_heur);",
          "3261:  prefs_register_bool_preference(rtp_module, \"desegment_rtp_streams\",",
          "3262:          \"Allow subdissector to reassemble RTP streams\",",
          "3263:          \"Whether subdissector can request RTP streams to be reassembled\",",
          "3264:          &desegment_rtp);",
          "3266:  prefs_register_enum_preference(rtp_module, \"version0_type\",",
          "3267:          \"Treat RTP version 0 packets as\",",
          "3268:          \"If an RTP version 0 packet is encountered, it can be treated as \"",
          "3269:          \"an invalid or ZRTP packet, a CLASSIC-STUN packet, or a T.38 packet\",",
          "3270:          &global_rtp_version0_type,",
          "3271:          rtp_version0_types, FALSE);",
          "3272:  prefs_register_uint_preference(rtp_module,",
          "3273:          \"rfc2198_payload_type\", \"Payload Type for RFC2198\",",
          "3274:          \"Payload Type for RFC2198 Redundant Audio Data\",",
          "3275:          10,",
          "3276:          &rtp_rfc2198_pt);",
          "3278:  register_init_routine(rtp_fragment_init);",
          "3284:  static gboolean rtp_prefs_initialized = FALSE;",
          "3285:  static dissector_handle_t rtp_rfc2198_handle;",
          "3286:  static dissector_handle_t rtp_hdr_ext_ed137_handle;",
          "3287:  static dissector_handle_t rtp_hdr_ext_ed137a_handle;",
          "3288:  static guint rtp_saved_rfc2198_pt;",
          "3290:  if (!rtp_prefs_initialized) {",
          "3291:   rtp_handle = find_dissector(\"rtp\");",
          "3292:   rtp_rfc2198_handle = find_dissector(\"rtp.rfc2198\");",
          "3295:   dissector_add_string(\"rtp_dyn_payload_type\", \"red\", rtp_rfc2198_handle);",
          "3296:   heur_dissector_add( \"udp\", dissect_rtp_heur_udp,  proto_rtp);",
          "3297:   heur_dissector_add(\"stun\", dissect_rtp_heur_stun, proto_rtp);",
          "3299:   rtp_hdr_ext_ed137_handle = find_dissector(\"rtp.ext.ed137\");",
          "3300:   rtp_hdr_ext_ed137a_handle = find_dissector(\"rtp.ext.ed137a\");",
          "3301:   dissector_add_uint(\"rtp.hdr_ext\", RTP_ED137_SIG, rtp_hdr_ext_ed137_handle);",
          "3302:   dissector_add_uint(\"rtp.hdr_ext\", RTP_ED137A_SIG, rtp_hdr_ext_ed137a_handle);",
          "3304:   rtcp_handle = find_dissector(\"rtcp\");",
          "3305:   data_handle = find_dissector(\"data\");",
          "3306:   stun_handle = find_dissector(\"stun-udp\");",
          "3307:   classicstun_handle = find_dissector(\"classicstun\");",
          "3308:   classicstun_heur_handle = find_dissector(\"classicstun-heur\");",
          "3309:   stun_heur_handle = find_dissector(\"stun-heur\");",
          "3310:   t38_handle = find_dissector(\"t38\");",
          "3311:   zrtp_handle = find_dissector(\"zrtp\");",
          "3313:   sprt_handle = find_dissector(\"sprt\");",
          "3314:   v150fw_handle = find_dissector(\"v150fw\");",
          "3316:   bta2dp_content_protection_header_scms_t = find_dissector(\"bta2dp_content_protection_header_scms_t\");",
          "3317:   btvdp_content_protection_header_scms_t = find_dissector(\"btvdp_content_protection_header_scms_t\");",
          "3318:   bta2dp_handle = find_dissector(\"bta2dp\");",
          "3319:   btvdp_handle = find_dissector(\"btvdp\");",
          "3320:   sbc_handle = find_dissector(\"sbc\");",
          "3322:   dissector_add_string(\"rtp_dyn_payload_type\", \"v150fw\", v150fw_handle);",
          "3324:   dissector_add_handle(\"btl2cap.cid\", rtp_handle);",
          "3326:   rtp_prefs_initialized = TRUE;",
          "3327:  } else {",
          "3328:   dissector_delete_uint(\"rtp.pt\", rtp_saved_rfc2198_pt, rtp_rfc2198_handle);",
          "3329:  }",
          "3330:  dissector_add_uint(\"rtp.pt\", rtp_rfc2198_pt, rtp_rfc2198_handle);",
          "3331:  rtp_saved_rfc2198_pt = rtp_rfc2198_pt;",
          "",
          "[Added Lines]",
          "2423:     static hf_register_info hf[] =",
          "2424:     {",
          "2425:         {",
          "2426:             &hf_rtp_version,",
          "2427:             {",
          "2428:                 \"Version\",",
          "2429:                 \"rtp.version\",",
          "2430:                 FT_UINT8,",
          "2431:                 BASE_DEC,",
          "2432:                 VALS(rtp_version_vals),",
          "2433:                 0xC0,",
          "2434:                 NULL, HFILL",
          "2435:             }",
          "2436:         },",
          "2437:         {",
          "2438:             &hf_rtp_padding,",
          "2439:             {",
          "2440:                 \"Padding\",",
          "2441:                 \"rtp.padding\",",
          "2442:                 FT_BOOLEAN,",
          "2443:                 8,",
          "2444:                 NULL,",
          "2445:                 0x20,",
          "2446:                 NULL, HFILL",
          "2447:             }",
          "2448:         },",
          "2449:         {",
          "2450:             &hf_rtp_extension,",
          "2451:             {",
          "2452:                 \"Extension\",",
          "2453:                 \"rtp.ext\",",
          "2454:                 FT_BOOLEAN,",
          "2455:                 8,",
          "2456:                 NULL,",
          "2457:                 0x10,",
          "2458:                 NULL, HFILL",
          "2459:             }",
          "2460:         },",
          "2461:         {",
          "2462:             &hf_rtp_csrc_count,",
          "2463:             {",
          "2464:                 \"Contributing source identifiers count\",",
          "2465:                 \"rtp.cc\",",
          "2466:                 FT_UINT8,",
          "2467:                 BASE_DEC,",
          "2468:                 NULL,",
          "2469:                 0x0F,",
          "2470:                 NULL, HFILL",
          "2471:             }",
          "2472:         },",
          "2473:         {",
          "2474:             &hf_rtp_marker,",
          "2475:             {",
          "2476:                 \"Marker\",",
          "2477:                 \"rtp.marker\",",
          "2478:                 FT_BOOLEAN,",
          "2479:                 8,",
          "2480:                 NULL,",
          "2481:                 0x80,",
          "2482:                 NULL, HFILL",
          "2483:             }",
          "2484:         },",
          "2485:         {",
          "2486:             &hf_rtp_payload_type,",
          "2487:             {",
          "2488:                 \"Payload type\",",
          "2489:                 \"rtp.p_type\",",
          "2490:                 FT_UINT8,",
          "2491:                 BASE_DEC,",
          "2492:                 NULL,",
          "2493:                 0x7F,",
          "2494:                 NULL, HFILL",
          "2495:             }",
          "2496:         },",
          "2497:         {",
          "2498:             &hf_rtp_seq_nr,",
          "2499:             {",
          "2500:                 \"Sequence number\",",
          "2501:                 \"rtp.seq\",",
          "2502:                 FT_UINT16,",
          "2503:                 BASE_DEC,",
          "2504:                 NULL,",
          "2505:                 0x0,",
          "2506:                 NULL, HFILL",
          "2507:             }",
          "2508:         },",
          "2509:         {",
          "2510:             &hf_rtp_ext_seq_nr,",
          "2511:             {",
          "2512:                 \"Extended sequence number\",",
          "2513:                 \"rtp.extseq\",",
          "2514:                 FT_UINT32,",
          "2515:                 BASE_DEC,",
          "2516:                 NULL,",
          "2517:                 0x0,",
          "2518:                 NULL, HFILL",
          "2519:             }",
          "2520:         },",
          "2521:         {",
          "2522:             &hf_rtp_timestamp,",
          "2523:             {",
          "2524:                 \"Timestamp\",",
          "2525:                 \"rtp.timestamp\",",
          "2526:                 FT_UINT32,",
          "2527:                 BASE_DEC,",
          "2528:                 NULL,",
          "2529:                 0x0,",
          "2530:                 NULL, HFILL",
          "2531:             }",
          "2532:         },",
          "2533:         {",
          "2534:             &hf_rtp_ssrc,",
          "2535:             {",
          "2536:                 \"Synchronization Source identifier\",",
          "2537:                 \"rtp.ssrc\",",
          "2538:                 FT_UINT32,",
          "2539:                 BASE_HEX_DEC,",
          "2540:                 NULL,",
          "2541:                 0x0,",
          "2542:                 NULL, HFILL",
          "2543:             }",
          "2544:         },",
          "2545:         {",
          "2546:             &hf_rtp_prof_define,",
          "2547:             {",
          "2548:                 \"Defined by profile\",",
          "2549:                 \"rtp.ext.profile\",",
          "2550:                 FT_UINT16,",
          "2551:                 BASE_HEX_DEC,",
          "2552:                 VALS(rtp_ext_profile_vals),",
          "2553:                 0x0,",
          "2554:                 NULL, HFILL",
          "2555:             }",
          "2556:         },",
          "2557:         {",
          "2558:             &hf_rtp_length,",
          "2559:             {",
          "2560:                 \"Extension length\",",
          "2561:                 \"rtp.ext.len\",",
          "2562:                 FT_UINT16,",
          "2563:                 BASE_DEC,",
          "2564:                 NULL,",
          "2565:                 0x0,",
          "2566:                 NULL, HFILL",
          "2567:             }",
          "2568:         },",
          "2569:         {",
          "2570:             &hf_rtp_csrc_items,",
          "2571:             {",
          "2572:                 \"Contributing Source identifiers\",",
          "2573:                 \"rtp.csrc.items\",",
          "2574:                 FT_NONE,",
          "2575:                 BASE_NONE,",
          "2576:                 NULL,",
          "2577:                 0x0,",
          "2578:                 NULL, HFILL",
          "2579:             }",
          "2580:         },",
          "2581:         {",
          "2582:             &hf_rtp_csrc_item,",
          "2583:             {",
          "2584:                 \"CSRC item\",",
          "2585:                 \"rtp.csrc.item\",",
          "2586:                 FT_UINT32,",
          "2587:                 BASE_HEX_DEC,",
          "2588:                 NULL,",
          "2589:                 0x0,",
          "2590:                 NULL, HFILL",
          "2591:             }",
          "2592:         },",
          "2593:         {",
          "2594:             &hf_rtp_hdr_exts,",
          "2595:             {",
          "2596:                 \"Header extensions\",",
          "2597:                 \"rtp.hdr_exts\",",
          "2598:                 FT_NONE,",
          "2599:                 BASE_NONE,",
          "2600:                 NULL,",
          "2601:                 0x0,",
          "2602:                 NULL, HFILL",
          "2603:             }",
          "2604:         },",
          "2606:         {",
          "2607:             &hf_rtp_hdr_ed137s,",
          "2608:             {",
          "2609:                 \"ED137 extensions\",",
          "2610:                 \"rtp.ext.ed137s\",",
          "2611:                 FT_NONE,",
          "2612:                 BASE_NONE,",
          "2613:                 NULL,",
          "2614:                 0x0,",
          "2615:                 NULL, HFILL",
          "2616:             }",
          "2617:         },",
          "2619:         {",
          "2620:             &hf_rtp_hdr_ed137,",
          "2621:             {",
          "2622:                 \"ED137 extension\",",
          "2623:                 \"rtp.ext.ed137\",",
          "2624:                 FT_NONE,",
          "2625:                 BASE_NONE,",
          "2626:                 NULL,",
          "2627:                 0x0,",
          "2628:                 NULL, HFILL",
          "2629:             }",
          "2630:         },",
          "2631:         {",
          "2632:             &hf_rtp_hdr_ed137_ptt_type,",
          "2633:             {",
          "2634:                 \"PTT Type\",",
          "2635:                 \"rtp.ext.ed137.ptt_type\",",
          "2636:                 FT_UINT32,",
          "2637:                 BASE_DEC,",
          "2638:                 VALS(rtp_ext_ed137_ptt_type),",
          "2639:                 0xE0000000,",
          "2640:                 NULL, HFILL",
          "2641:             }",
          "2642:         },",
          "2643:         {",
          "2644:             &hf_rtp_hdr_ed137_squ,",
          "2645:             {",
          "2646:                 \"SQU\",",
          "2647:                 \"rtp.ext.ed137.squ\",",
          "2648:                 FT_UINT32,",
          "2649:                 BASE_DEC,",
          "2650:                 VALS(rtp_ext_ed137_squ),",
          "2651:                 0x10000000,",
          "2652:                 NULL, HFILL",
          "2653:             }",
          "2654:         },",
          "2655:         {",
          "2656:             &hf_rtp_hdr_ed137_ptt_id,",
          "2657:             {",
          "2658:                 \"PTT-id\",",
          "2659:                 \"rtp.ext.ed137.ptt_id\",",
          "2660:                 FT_UINT32,",
          "2661:                 BASE_DEC,",
          "2662:                 NULL,",
          "2663:                 0x0F000000,",
          "2664:                 NULL, HFILL",
          "2665:             }",
          "2666:         },",
          "2667:         {",
          "2668:             &hf_rtp_hdr_ed137_sct,",
          "2669:             {",
          "2670:                 \"Simultaneous Call Transmissions\",",
          "2671:                 \"rtp.ext.ed137.sct\",",
          "2672:                 FT_UINT32,",
          "2673:                 BASE_DEC,",
          "2674:                 NULL,",
          "2675:                 0x00800000,",
          "2676:                 NULL, HFILL",
          "2677:             }",
          "2678:         },",
          "2679:         {",
          "2680:             &hf_rtp_hdr_ed137_x,",
          "2681:             {",
          "2682:                 \"X\",",
          "2683:                 \"rtp.ext.ed137.x\",",
          "2684:                 FT_UINT32,",
          "2685:                 BASE_DEC,",
          "2686:                 NULL,",
          "2687:                 0x00400000,",
          "2688:                 NULL, HFILL",
          "2689:             }",
          "2690:         },",
          "2691:         {",
          "2692:             &hf_rtp_hdr_ed137_x_nu,",
          "2693:             {",
          "2694:                 \"Not used\",",
          "2695:                 \"rtp.ext.ed137.x-nu\",",
          "2696:                 FT_UINT32,",
          "2697:                 BASE_DEC,",
          "2698:                 NULL,",
          "2699:                 0x003FFFFE,",
          "2700:                 NULL, HFILL",
          "2701:             }",
          "2702:         },",
          "2703:         {",
          "2704:             &hf_rtp_hdr_ed137_ft_type,",
          "2705:             {",
          "2706:                 \"Feature type\",",
          "2707:                 \"rtp.ext.ed137.ft.type\",",
          "2708:                 FT_UINT32,",
          "2709:                 BASE_HEX_DEC,",
          "2710:                 VALS(rtp_ext_ed137_ft_type),",
          "2711:                 0x003C0000,",
          "2712:                 NULL, HFILL",
          "2713:             }",
          "2714:         },",
          "2715:         {",
          "2716:             &hf_rtp_hdr_ed137_ft_len,",
          "2717:             {",
          "2718:                 \"Feature length\",",
          "2719:                 \"rtp.ext.ed137.ft.len\",",
          "2720:                 FT_UINT32,",
          "2721:                 BASE_DEC,",
          "2722:                 NULL,",
          "2723:                 0x0003C000,",
          "2724:                 NULL, HFILL",
          "2725:             }",
          "2726:         },",
          "2727:         {",
          "2728:             &hf_rtp_hdr_ed137_ft_value,",
          "2729:             {",
          "2730:                 \"Feature value\",",
          "2731:                 \"rtp.ext.ed137.ft.value\",",
          "2732:                 FT_UINT32,",
          "2733:                 BASE_HEX_DEC,",
          "2734:                 NULL,",
          "2735:                 0x00003FFE,",
          "2736:                 NULL, HFILL",
          "2737:             }",
          "2738:         },",
          "2739:         {",
          "2740:             &hf_rtp_hdr_ed137_vf,",
          "2741:             {",
          "2742:                 \"VF\",",
          "2743:                 \"rtp.ext.ed137.vf\",",
          "2744:                 FT_UINT32,",
          "2745:                 BASE_DEC,",
          "2746:                 VALS(rtp_ext_ed137_vf),",
          "2747:                 0x00000001,",
          "2748:                 NULL, HFILL",
          "2749:             }",
          "2750:         },",
          "2751:         {",
          "2752:             &hf_rtp_hdr_ed137_ft_bss_qidx,",
          "2753:             {",
          "2754:                 \"BSS Quality Index\",",
          "2755:                 \"rtp.ext.ed137.ft.bss.qidx\",",
          "2756:                 FT_UINT32,",
          "2757:                 BASE_DEC,",
          "2758:                 NULL,",
          "2759:                 0x00003FC0,",
          "2760:                 NULL, HFILL",
          "2761:             }",
          "2762:         },",
          "2763:         {",
          "2764:             &hf_rtp_hdr_ed137_ft_bss_rssi_qidx,",
          "2765:             {",
          "2766:                 \"BSS Quality Index\",",
          "2767:                 \"rtp.ext.ed137.ft.bss.qidx\",",
          "2768:                 FT_UINT32,",
          "2769:                 BASE_DEC,",
          "2770:                 VALS(rtp_ext_ed137_ft_bss_rssi_qidx),",
          "2771:                 0x00003FC0,",
          "2772:                 NULL, HFILL",
          "2773:             }",
          "2774:         },",
          "2775:         {",
          "2776:             &hf_rtp_hdr_ed137_ft_bss_qidx_ml,",
          "2777:             {",
          "2778:                 \"BSS Quality Index Method\",",
          "2779:                 \"rtp.ext.ed137.ft.bss.qidx-ml\",",
          "2780:                 FT_UINT32,",
          "2781:                 BASE_DEC,",
          "2782:                 VALS(rtp_ext_ed137_ft_bss_qidx_ml),",
          "2783:                 0x00000038,",
          "2784:                 NULL, HFILL",
          "2785:             }",
          "2786:         },",
          "2787:         {",
          "2788:             &hf_rtp_hdr_ed137_ft_bss_nu,",
          "2789:             {",
          "2790:                 \"Not used\",",
          "2791:                 \"rtp.ext.ed137.ft.bss-nu\",",
          "2792:                 FT_UINT32,",
          "2793:                 BASE_DEC,",
          "2794:                 NULL,",
          "2795:                 0x00000006,",
          "2796:                 NULL, HFILL",
          "2797:             }",
          "2798:         },",
          "2800:         {",
          "2801:             &hf_rtp_hdr_ed137a,",
          "2802:             {",
          "2803:                 \"ED137A extension\",",
          "2804:                 \"rtp.ext.ed137A\",",
          "2805:                 FT_NONE,",
          "2806:                 BASE_NONE,",
          "2807:                 NULL,",
          "2808:                 0x0,",
          "2809:                 NULL, HFILL",
          "2810:             }",
          "2811:         },",
          "2812:         {",
          "2813:             &hf_rtp_hdr_ed137a_ptt_type,",
          "2814:             {",
          "2815:                 \"PTT Type\",",
          "2816:                 \"rtp.ext.ed137A.ptt_type\",",
          "2817:                 FT_UINT32,",
          "2818:                 BASE_DEC,",
          "2819:                 VALS(rtp_ext_ed137a_ptt_type),",
          "2820:                 0xE0000000,",
          "2821:                 NULL, HFILL",
          "2822:             }",
          "2823:         },",
          "2824:         {",
          "2825:             &hf_rtp_hdr_ed137a_squ,",
          "2826:             {",
          "2827:                 \"SQU\",",
          "2828:                 \"rtp.ext.ed137A.squ\",",
          "2829:                 FT_UINT32,",
          "2830:                 BASE_DEC,",
          "2831:                 VALS(rtp_ext_ed137a_squ),",
          "2832:                 0x10000000,",
          "2833:                 NULL, HFILL",
          "2834:             }",
          "2835:         },",
          "2836:         {",
          "2837:             &hf_rtp_hdr_ed137a_ptt_id,",
          "2838:             {",
          "2839:                 \"PTT-id\",",
          "2840:                 \"rtp.ext.ed137A.ptt_id\",",
          "2841:                 FT_UINT32,",
          "2842:                 BASE_DEC,",
          "2843:                 NULL,",
          "2844:                 0x0FC00000,",
          "2845:                 NULL, HFILL",
          "2846:             }",
          "2847:         },",
          "2848:         {",
          "2849:             &hf_rtp_hdr_ed137a_pm,",
          "2850:             {",
          "2851:                 \"PTT Mute\",",
          "2852:                 \"rtp.ext.ed137A.pm\",",
          "2853:                 FT_UINT32,",
          "2854:                 BASE_DEC,",
          "2855:                 NULL,",
          "2856:                 0x00200000,",
          "2857:                 NULL, HFILL",
          "2858:             }",
          "2859:         },",
          "2860:         {",
          "2861:             &hf_rtp_hdr_ed137a_ptts,",
          "2862:             {",
          "2863:                 \"PTT Summation\",",
          "2864:                 \"rtp.ext.ed137A.ptts\",",
          "2865:                 FT_UINT32,",
          "2866:                 BASE_DEC,",
          "2867:                 NULL,",
          "2868:                 0x00100000,",
          "2869:                 NULL, HFILL",
          "2870:             }",
          "2871:         },",
          "2872:         {",
          "2873:             &hf_rtp_hdr_ed137a_sct,",
          "2874:             {",
          "2875:                 \"Simultaneous Call Transmissions\",",
          "2876:                 \"rtp.ext.ed137a.sct\",",
          "2877:                 FT_UINT32,",
          "2878:                 BASE_DEC,",
          "2879:                 NULL,",
          "2880:                 0x00080000,",
          "2881:                 NULL, HFILL",
          "2882:             }",
          "2883:         },",
          "2884:         {",
          "2885:             &hf_rtp_hdr_ed137a_reserved,",
          "2886:             {",
          "2887:                 \"Reserved\",",
          "2888:                 \"rtp.ext.ed137A.reserved\",",
          "2889:                 FT_UINT32,",
          "2890:                 BASE_HEX_DEC,",
          "2891:                 NULL,",
          "2892:                 0x00060000,",
          "2893:                 NULL, HFILL",
          "2894:             }",
          "2895:         },",
          "2896:         {",
          "2897:             &hf_rtp_hdr_ed137a_x,",
          "2898:             {",
          "2899:                 \"X\",",
          "2900:                 \"rtp.ext.ed137A.x\",",
          "2901:                 FT_UINT32,",
          "2902:                 BASE_DEC,",
          "2903:                 NULL,",
          "2904:                 0x00010000,",
          "2905:                 NULL, HFILL",
          "2906:             }",
          "2907:         },",
          "2908:         {",
          "2909:             &hf_rtp_hdr_ed137a_x_nu,",
          "2910:             {",
          "2911:                 \"Not used\",",
          "2912:                 \"rtp.ext.ed137A.x-nu\",",
          "2913:                 FT_UINT32,",
          "2914:                 BASE_DEC,",
          "2915:                 NULL,",
          "2916:                 0x0000FFFF,",
          "2917:                 NULL, HFILL",
          "2918:             }",
          "2919:         },",
          "2920:         {",
          "2921:             &hf_rtp_hdr_ed137a_ft_type,",
          "2922:             {",
          "2923:                 \"Feature type\",",
          "2924:                 \"rtp.ext.ed137A.ft.type\",",
          "2925:                 FT_UINT32,",
          "2926:                 BASE_HEX_DEC,",
          "2927:                 VALS(rtp_ext_ed137a_ft_type),",
          "2928:                 0x0000F000,",
          "2929:                 NULL, HFILL",
          "2930:             }",
          "2931:         },",
          "2932:         {",
          "2933:             &hf_rtp_hdr_ed137a_ft_len,",
          "2934:             {",
          "2935:                 \"Feature length\",",
          "2936:                 \"rtp.ext.ed137A.ft.len\",",
          "2937:                 FT_UINT32,",
          "2938:                 BASE_DEC,",
          "2939:                 NULL,",
          "2940:                 0x00000F00,",
          "2941:                 NULL, HFILL",
          "2942:             }",
          "2943:         },",
          "2944:         {",
          "2945:             &hf_rtp_hdr_ed137a_ft_value,",
          "2946:             {",
          "2947:                 \"Feature value\",",
          "2948:                 \"rtp.ext.ed137A.ft.value\",",
          "2949:                 FT_UINT32,",
          "2950:                 BASE_HEX_DEC,",
          "2951:                 NULL,",
          "2952:                 0x000000FF,",
          "2953:                 NULL, HFILL",
          "2954:             }",
          "2955:         },",
          "2957:         {",
          "2958:             &hf_rtp_hdr_ext,",
          "2959:             {",
          "2960:                 \"Header extension\",",
          "2961:                 \"rtp.hdr_ext\",",
          "2962:                 FT_UINT32,",
          "2963:                 BASE_HEX_DEC,",
          "2964:                 NULL,",
          "2965:                 0x0,",
          "2966:                 NULL, HFILL",
          "2967:             }",
          "2968:         },",
          "2969:         {",
          "2970:             &hf_rtp_data,",
          "2971:             {",
          "2972:                 \"Payload\",",
          "2973:                 \"rtp.payload\",",
          "2974:                 FT_BYTES,",
          "2975:                 BASE_NONE,",
          "2976:                 NULL,",
          "2977:                 0x0,",
          "2978:                 NULL, HFILL",
          "2979:             }",
          "2980:         },",
          "2981:         {",
          "2982:             &hf_rtp_padding_data,",
          "2983:             {",
          "2984:                 \"Padding data\",",
          "2985:                 \"rtp.padding.data\",",
          "2986:                 FT_BYTES,",
          "2987:                 BASE_NONE,",
          "2988:                 NULL,",
          "2989:                 0x0,",
          "2990:                 NULL, HFILL",
          "2991:             }",
          "2992:         },",
          "2993:         {",
          "2994:             &hf_rtp_padding_count,",
          "2995:             {",
          "2996:                 \"Padding count\",",
          "2997:                 \"rtp.padding.count\",",
          "2998:                 FT_UINT8,",
          "2999:                 BASE_DEC,",
          "3000:                 NULL,",
          "3001:                 0x0,",
          "3002:                 NULL, HFILL",
          "3003:             }",
          "3004:         },",
          "3005:         {",
          "3006:             &hf_rtp_setup,",
          "3007:             {",
          "3008:                 \"Stream setup\",",
          "3009:                 \"rtp.setup\",",
          "3010:                 FT_STRING,",
          "3011:                 BASE_NONE,",
          "3012:                 NULL,",
          "3013:                 0x0,",
          "3014:                 \"Stream setup, method and frame number\", HFILL",
          "3015:             }",
          "3016:         },",
          "3017:         {",
          "3018:             &hf_rtp_setup_frame,",
          "3019:             {",
          "3020:                 \"Setup frame\",",
          "3021:                 \"rtp.setup-frame\",",
          "3022:                 FT_FRAMENUM,",
          "3023:                 BASE_NONE,",
          "3024:                 NULL,",
          "3025:                 0x0,",
          "3026:                 \"Frame that set up this stream\", HFILL",
          "3027:             }",
          "3028:         },",
          "3029:         {",
          "3030:             &hf_rtp_setup_method,",
          "3031:             {",
          "3032:                 \"Setup Method\",",
          "3033:                 \"rtp.setup-method\",",
          "3034:                 FT_STRING,",
          "3035:                 BASE_NONE,",
          "3036:                 NULL,",
          "3037:                 0x0,",
          "3038:                 \"Method used to set up this stream\", HFILL",
          "3039:             }",
          "3040:         },",
          "3041:         {",
          "3042:             &hf_rtp_rfc2198_follow,",
          "3043:             {",
          "3044:                 \"Follow\",",
          "3045:                 \"rtp.follow\",",
          "3046:                 FT_BOOLEAN,",
          "3047:                 8,",
          "3048:                 TFS(&tfs_set_notset),",
          "3049:                 0x80,",
          "3050:                 \"Next header follows\", HFILL",
          "3051:             }",
          "3052:         },",
          "3053:         {",
          "3054:             &hf_rtp_rfc2198_tm_off,",
          "3055:             {",
          "3056:                 \"Timestamp offset\",",
          "3057:                 \"rtp.timestamp-offset\",",
          "3058:                 FT_UINT16,",
          "3059:                 BASE_DEC,",
          "3060:                 NULL,",
          "3061:                 0xFFFC,",
          "3062:                 NULL, HFILL",
          "3063:             }",
          "3064:         },",
          "3065:         {",
          "3066:             &hf_rtp_rfc2198_bl_len,",
          "3067:             {",
          "3068:                 \"Block length\",",
          "3069:                 \"rtp.block-length\",",
          "3070:                 FT_UINT16,",
          "3071:                 BASE_DEC,",
          "3072:                 NULL,",
          "3073:                 0x03FF,",
          "3074:                 NULL, HFILL",
          "3075:             }",
          "3076:         },",
          "3077:         {",
          "3078:             &hf_rtp_ext_rfc5285_id,",
          "3079:             {",
          "3080:                 \"Identifier\",",
          "3081:                 \"rtp.ext.rfc5285.id\",",
          "3082:                 FT_UINT8,",
          "3083:                 BASE_DEC,",
          "3084:                 NULL,",
          "3085:                 0x0,",
          "3086:                 \"RFC 5285 Header Extension Identifier\",",
          "3087:                 HFILL",
          "3088:             }",
          "3089:         },",
          "3090:         {",
          "3091:             &hf_rtp_ext_rfc5285_length,",
          "3092:             {",
          "3093:                 \"Length\",",
          "3094:                 \"rtp.ext.rfc5285.len\",",
          "3095:                 FT_UINT8,",
          "3096:                 BASE_DEC,",
          "3097:                 NULL,",
          "3098:                 0x0,",
          "3099:                 \"RFC 5285 Header Extension length\",",
          "3100:                 HFILL",
          "3101:             }",
          "3102:         },",
          "3103:         {",
          "3104:             &hf_rtp_ext_rfc5285_appbits,",
          "3105:             {",
          "3106:                 \"Application Bits\",",
          "3107:                 \"rtp.ext.rfc5285.appbits\",",
          "3108:                 FT_UINT8,",
          "3109:                 BASE_DEC,",
          "3110:                 NULL,",
          "3111:                 0x0,",
          "3112:                 \"RFC 5285 2-bytes header application bits\",",
          "3113:                 HFILL",
          "3114:             }",
          "3115:         },",
          "3116:         {",
          "3117:             &hf_rtp_ext_rfc5285_data,",
          "3118:             {",
          "3119:                 \"Extension Data\",",
          "3120:                 \"rtp.ext.rfc5285.data\",",
          "3121:                 FT_BYTES,",
          "3122:                 BASE_NONE,",
          "3123:                 NULL,",
          "3124:                 0x0,",
          "3125:                 \"RFC 5285 Extension Data\",",
          "3126:                 HFILL",
          "3127:             }",
          "3128:         },",
          "3131:         {&hf_rtp_fragments,",
          "3132:          {\"RTP Fragments\", \"rtp.fragments\", FT_NONE, BASE_NONE, NULL, 0x0,",
          "3133:           NULL, HFILL }",
          "3134:         },",
          "3136:         {&hf_rtp_fragment,",
          "3137:          {\"RTP Fragment data\", \"rtp.fragment\", FT_FRAMENUM, BASE_NONE, NULL, 0x0,",
          "3138:           NULL, HFILL }",
          "3139:         },",
          "3141:         {&hf_rtp_fragment_overlap,",
          "3142:          {\"Fragment overlap\", \"rtp.fragment.overlap\", FT_BOOLEAN, BASE_NONE,",
          "3143:           NULL, 0x0, \"Fragment overlaps with other fragments\", HFILL }",
          "3144:         },",
          "3146:         {&hf_rtp_fragment_overlap_conflict,",
          "3147:          {\"Conflicting data in fragment overlap\", \"rtp.fragment.overlap.conflict\",",
          "3148:           FT_BOOLEAN, BASE_NONE, NULL, 0x0,",
          "3149:           \"Overlapping fragments contained conflicting data\", HFILL }",
          "3150:         },",
          "3152:         {&hf_rtp_fragment_multiple_tails,",
          "3153:          {\"Multiple tail fragments found\", \"rtp.fragment.multipletails\",",
          "3154:           FT_BOOLEAN, BASE_NONE, NULL, 0x0,",
          "3155:           \"Several tails were found when defragmenting the packet\", HFILL }",
          "3156:         },",
          "3158:         {&hf_rtp_fragment_too_long_fragment,",
          "3159:          {\"Fragment too long\", \"rtp.fragment.toolongfragment\",",
          "3160:           FT_BOOLEAN, BASE_NONE, NULL, 0x0,",
          "3161:           \"Fragment contained data past end of packet\", HFILL }",
          "3162:         },",
          "3164:         {&hf_rtp_fragment_error,",
          "3165:          {\"Defragmentation error\", \"rtp.fragment.error\",",
          "3166:           FT_FRAMENUM, BASE_NONE, NULL, 0x0,",
          "3167:           \"Defragmentation error due to illegal fragments\", HFILL }",
          "3168:         },",
          "3170:         {&hf_rtp_fragment_count,",
          "3171:          {\"Fragment count\", \"rtp.fragment.count\",",
          "3172:           FT_UINT32, BASE_DEC, NULL, 0x0,",
          "3173:           NULL, HFILL }",
          "3174:         },",
          "3176:         {&hf_rtp_reassembled_in,",
          "3177:          {\"RTP fragment, reassembled in frame\", \"rtp.reassembled_in\",",
          "3178:           FT_FRAMENUM, BASE_NONE, NULL, 0x0,",
          "3179:           \"This RTP packet is reassembled in this frame\", HFILL }",
          "3180:         },",
          "3181:         {&hf_rtp_reassembled_length,",
          "3182:          {\"Reassembled RTP length\", \"rtp.reassembled.length\",",
          "3183:           FT_UINT32, BASE_DEC, NULL, 0x0,",
          "3184:           \"The total length of the reassembled payload\", HFILL }",
          "3185:         },",
          "3186:         {&hf_srtp_encrypted_payload,",
          "3187:          {\"SRTP Encrypted Payload\", \"srtp.enc_payload\",",
          "3188:           FT_BYTES, BASE_NONE, NULL, 0x0,",
          "3189:           NULL, HFILL }",
          "3190:         },",
          "3191:         {&hf_srtp_mki,",
          "3192:          {\"SRTP MKI\", \"srtp.mki\",",
          "3193:           FT_BYTES, BASE_NONE, NULL, 0x0,",
          "3194:           \"SRTP Master Key Index\", HFILL }",
          "3195:         },",
          "3196:         {&hf_srtp_auth_tag,",
          "3197:          {\"SRTP Auth Tag\", \"srtp.auth_tag\",",
          "3198:           FT_BYTES, BASE_NONE, NULL, 0x0,",
          "3199:           \"SRTP Authentication Tag\", HFILL }",
          "3200:         }",
          "3202:     };",
          "3204:     static gint *ett[] =",
          "3205:     {",
          "3206:         &ett_rtp,",
          "3207:         &ett_csrc_list,",
          "3208:         &ett_hdr_ext,",
          "3209:         &ett_hdr_ext_rfc5285,",
          "3210:         &ett_hdr_ext_ed137s,",
          "3211:         &ett_hdr_ext_ed137,",
          "3212:         &ett_hdr_ext_ed137a,",
          "3213:         &ett_rtp_setup,",
          "3214:         &ett_rtp_rfc2198,",
          "3215:         &ett_rtp_rfc2198_hdr,",
          "3216:         &ett_rtp_fragment,",
          "3217:         &ett_rtp_fragments",
          "3218:     };",
          "3220:     module_t *rtp_module;",
          "3223:     proto_rtp = proto_register_protocol(\"Real-Time Transport Protocol\",",
          "3224:                         \"RTP\", \"rtp\");",
          "3225:     proto_register_field_array(proto_rtp, hf, array_length(hf));",
          "3226:     proto_register_subtree_array(ett, array_length(ett));",
          "3228:     new_register_dissector(\"rtp\", dissect_rtp, proto_rtp);",
          "3229:     register_dissector(\"rtp.rfc2198\", dissect_rtp_rfc2198, proto_rtp);",
          "3231:     rtp_tap = register_tap(\"rtp\");",
          "3233:     rtp_pt_dissector_table = register_dissector_table(\"rtp.pt\",",
          "3234:                                     \"RTP payload type\", FT_UINT8, BASE_DEC);",
          "3235:     rtp_dyn_pt_dissector_table = register_dissector_table(\"rtp_dyn_payload_type\",",
          "3236:                                     \"Dynamic RTP payload type\", FT_STRING, BASE_NONE);",
          "3239:     rtp_hdr_ext_dissector_table = register_dissector_table(\"rtp.hdr_ext\",",
          "3240:                                     \"RTP header extension\", FT_UINT32, BASE_HEX);",
          "3241:     rtp_hdr_ext_rfc5285_dissector_table = register_dissector_table(\"rtp.ext.rfc5285.id\",",
          "3242:                                     \"RTP Generic header extension (RFC 5285)\", FT_UINT8, BASE_DEC);",
          "3244:     register_dissector(\"rtp.ext.ed137\", dissect_rtp_hdr_ext_ed137, proto_rtp);",
          "3245:     register_dissector(\"rtp.ext.ed137a\", dissect_rtp_hdr_ext_ed137a, proto_rtp);",
          "3247:     rtp_module = prefs_register_protocol(proto_rtp, proto_reg_handoff_rtp);",
          "3249:     prefs_register_bool_preference(rtp_module, \"show_setup_info\",",
          "3250:                                     \"Show stream setup information\",",
          "3251:                                     \"Where available, show which protocol and frame caused \"",
          "3252:                                     \"this RTP stream to be created\",",
          "3253:                                     &global_rtp_show_setup_info);",
          "3255:     prefs_register_bool_preference(rtp_module, \"heuristic_rtp\",",
          "3256:                                     \"Try to decode RTP outside of conversations\",",
          "3257:                                     \"If call control SIP/H323/RTSP/.. messages are missing in the trace, \"",
          "3258:                                     \"RTP isn't decoded without this\",",
          "3259:                                     &global_rtp_heur);",
          "3261:     prefs_register_bool_preference(rtp_module, \"desegment_rtp_streams\",",
          "3262:                                     \"Allow subdissector to reassemble RTP streams\",",
          "3263:                                     \"Whether subdissector can request RTP streams to be reassembled\",",
          "3264:                                     &desegment_rtp);",
          "3266:     prefs_register_enum_preference(rtp_module, \"version0_type\",",
          "3267:                                     \"Treat RTP version 0 packets as\",",
          "3268:                                     \"If an RTP version 0 packet is encountered, it can be treated as \"",
          "3269:                                     \"an invalid or ZRTP packet, a CLASSIC-STUN packet, or a T.38 packet\",",
          "3270:                                     &global_rtp_version0_type,",
          "3271:                                     rtp_version0_types, FALSE);",
          "3272:     prefs_register_uint_preference(rtp_module,",
          "3273:                                     \"rfc2198_payload_type\", \"Payload Type for RFC2198\",",
          "3274:                                     \"Payload Type for RFC2198 Redundant Audio Data\",",
          "3275:                                     10,",
          "3276:                                     &rtp_rfc2198_pt);",
          "3278:     register_init_routine(rtp_fragment_init);",
          "3284:     static gboolean rtp_prefs_initialized = FALSE;",
          "3285:     static dissector_handle_t rtp_rfc2198_handle;",
          "3286:     static dissector_handle_t rtp_hdr_ext_ed137_handle;",
          "3287:     static dissector_handle_t rtp_hdr_ext_ed137a_handle;",
          "3288:     static guint rtp_saved_rfc2198_pt;",
          "3290:     if (!rtp_prefs_initialized) {",
          "3291:         rtp_handle = find_dissector(\"rtp\");",
          "3292:         rtp_rfc2198_handle = find_dissector(\"rtp.rfc2198\");",
          "3295:         dissector_add_string(\"rtp_dyn_payload_type\", \"red\", rtp_rfc2198_handle);",
          "3296:         heur_dissector_add( \"udp\", dissect_rtp_heur_udp,  proto_rtp);",
          "3297:         heur_dissector_add(\"stun\", dissect_rtp_heur_stun, proto_rtp);",
          "3299:         rtp_hdr_ext_ed137_handle = find_dissector(\"rtp.ext.ed137\");",
          "3300:         rtp_hdr_ext_ed137a_handle = find_dissector(\"rtp.ext.ed137a\");",
          "3301:         dissector_add_uint(\"rtp.hdr_ext\", RTP_ED137_SIG, rtp_hdr_ext_ed137_handle);",
          "3302:         dissector_add_uint(\"rtp.hdr_ext\", RTP_ED137A_SIG, rtp_hdr_ext_ed137a_handle);",
          "3304:         rtcp_handle = find_dissector(\"rtcp\");",
          "3305:         data_handle = find_dissector(\"data\");",
          "3306:         stun_handle = find_dissector(\"stun-udp\");",
          "3307:         classicstun_handle = find_dissector(\"classicstun\");",
          "3308:         classicstun_heur_handle = find_dissector(\"classicstun-heur\");",
          "3309:         stun_heur_handle = find_dissector(\"stun-heur\");",
          "3310:         t38_handle = find_dissector(\"t38\");",
          "3311:         zrtp_handle = find_dissector(\"zrtp\");",
          "3313:         sprt_handle = find_dissector(\"sprt\");",
          "3314:         v150fw_handle = find_dissector(\"v150fw\");",
          "3316:         bta2dp_content_protection_header_scms_t = find_dissector(\"bta2dp_content_protection_header_scms_t\");",
          "3317:         btvdp_content_protection_header_scms_t = find_dissector(\"btvdp_content_protection_header_scms_t\");",
          "3318:         bta2dp_handle = find_dissector(\"bta2dp\");",
          "3319:         btvdp_handle = find_dissector(\"btvdp\");",
          "3320:         sbc_handle = find_dissector(\"sbc\");",
          "3322:         dissector_add_string(\"rtp_dyn_payload_type\", \"v150fw\", v150fw_handle);",
          "3324:         dissector_add_handle(\"btl2cap.cid\", rtp_handle);",
          "3326:         rtp_prefs_initialized = TRUE;",
          "3327:     } else {",
          "3328:         dissector_delete_uint(\"rtp.pt\", rtp_saved_rfc2198_pt, rtp_rfc2198_handle);",
          "3329:     }",
          "3330:     dissector_add_uint(\"rtp.pt\", rtp_rfc2198_pt, rtp_rfc2198_handle);",
          "3331:     rtp_saved_rfc2198_pt = rtp_rfc2198_pt;",
          "",
          "---------------"
        ],
        "epan/dissectors/packet-sdp.c||epan/dissectors/packet-sdp.c": [
          "File: epan/dissectors/packet-sdp.c -> epan/dissectors/packet-sdp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "202: #define SDP_MAX_RTP_PAYLOAD_TYPES 20",
          "203: #define SDP_NO_OF_PT 128",
          "204: typedef struct {",
          "209: } transport_media_pt_t;",
          "211: typedef struct {",
          "231: } transport_info_t;",
          "234: typedef struct {",
          "248: } disposable_media_info_t;",
          "",
          "[Removed Lines]",
          "205:   gint32 pt[SDP_MAX_RTP_PAYLOAD_TYPES];",
          "206:   gint8 pt_count;",
          "207:   GHashTable *rtp_dyn_payload;",
          "208:   gboolean set_rtp;",
          "212:   enum sdp_exchange_type sdp_status;",
          "213:   char  *encoding_name[SDP_NO_OF_PT];",
          "214:   int    sample_rate[SDP_NO_OF_PT];",
          "215:   int    media_port[SDP_MAX_RTP_CHANNELS];",
          "216:   address  src_addr[SDP_MAX_RTP_CHANNELS];",
          "217:   guint  proto_bitmask[SDP_MAX_RTP_CHANNELS];",
          "218:   transport_media_pt_t media[SDP_MAX_RTP_CHANNELS];",
          "219:   gint8  media_count;",
          "227:   guint  encryption_algorithm;",
          "228:   guint  auth_algorithm;",
          "236:   char  *connection_type;",
          "238:   char  *media_type[SDP_MAX_RTP_CHANNELS];",
          "239:   char  *media_port[SDP_MAX_RTP_CHANNELS];",
          "240:   char  *media_proto[SDP_MAX_RTP_CHANNELS];",
          "241:   guint8 media_count;",
          "244:   gboolean msrp_transport_address_set;",
          "245:   guint32  msrp_ipaddr[4];",
          "246:   guint16  msrp_port_number;",
          "",
          "[Added Lines]",
          "205:     gint32 pt[SDP_MAX_RTP_PAYLOAD_TYPES];",
          "206:     gint8 pt_count;",
          "207:     GHashTable *rtp_dyn_payload;",
          "208:     gboolean set_rtp;",
          "212:     enum sdp_exchange_type sdp_status;",
          "213:     char  *encoding_name[SDP_NO_OF_PT];",
          "214:     int    sample_rate[SDP_NO_OF_PT];",
          "215:     int    media_port[SDP_MAX_RTP_CHANNELS];",
          "216:     address  src_addr[SDP_MAX_RTP_CHANNELS];",
          "217:     guint  proto_bitmask[SDP_MAX_RTP_CHANNELS];",
          "218:     transport_media_pt_t media[SDP_MAX_RTP_CHANNELS];",
          "219:     gint8  media_count;",
          "227:     guint  encryption_algorithm;",
          "228:     guint  auth_algorithm;",
          "236:     char  *connection_type;",
          "238:     char  *media_type[SDP_MAX_RTP_CHANNELS];",
          "239:     char  *media_port[SDP_MAX_RTP_CHANNELS];",
          "240:     char  *media_proto[SDP_MAX_RTP_CHANNELS];",
          "241:     guint8 media_count;",
          "244:     gboolean msrp_transport_address_set;",
          "245:     guint32  msrp_ipaddr[4];",
          "246:     guint16  msrp_port_number;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "257: static void",
          "258: dissect_sdp_owner(tvbuff_t *tvb, proto_item *ti) {",
          "318: }",
          "",
          "[Removed Lines]",
          "259:   proto_tree *sdp_owner_tree;",
          "260:   gint        offset, next_offset, tokenlen;",
          "262:   offset = 0;",
          "264:   sdp_owner_tree = proto_item_add_subtree(ti, ett_sdp_owner);",
          "267:   next_offset = tvb_find_guint8(tvb, offset, -1, ' ');",
          "268:   if (next_offset == -1)",
          "269:     return;",
          "270:   tokenlen = next_offset - offset;",
          "272:   proto_tree_add_item(sdp_owner_tree, hf_owner_username, tvb, offset, tokenlen,",
          "273:                       ENC_ASCII|ENC_NA);",
          "274:   offset = next_offset  + 1;",
          "277:   next_offset = tvb_find_guint8(tvb, offset, -1, ' ');",
          "278:   if (next_offset == -1)",
          "279:     return;",
          "280:   tokenlen = next_offset - offset;",
          "282:   proto_tree_add_item(sdp_owner_tree, hf_owner_sessionid, tvb, offset,",
          "283:                       tokenlen, ENC_ASCII|ENC_NA);",
          "284:   offset = next_offset + 1;",
          "287:   next_offset = tvb_find_guint8(tvb, offset, -1, ' ');",
          "288:   if (next_offset == -1)",
          "289:     return;",
          "290:   tokenlen = next_offset - offset;",
          "292:   proto_tree_add_item(sdp_owner_tree, hf_owner_version, tvb, offset, tokenlen,",
          "293:                       ENC_ASCII|ENC_NA);",
          "294:   offset = next_offset + 1;",
          "297:   next_offset = tvb_find_guint8(tvb, offset, -1, ' ');",
          "298:   if (next_offset == -1)",
          "299:     return;",
          "300:   tokenlen = next_offset - offset;",
          "302:   proto_tree_add_item(sdp_owner_tree, hf_owner_network_type, tvb, offset,",
          "303:                       tokenlen, ENC_ASCII|ENC_NA);",
          "304:   offset = next_offset + 1;",
          "307:   next_offset = tvb_find_guint8(tvb, offset, -1, ' ');",
          "308:   if (next_offset == -1)",
          "309:     return;",
          "310:   tokenlen = next_offset - offset;",
          "312:   proto_tree_add_item(sdp_owner_tree, hf_owner_address_type, tvb, offset,",
          "313:                       tokenlen, ENC_ASCII|ENC_NA);",
          "314:   offset = next_offset + 1;",
          "317:   proto_tree_add_item(sdp_owner_tree, hf_owner_address, tvb, offset, -1, ENC_ASCII|ENC_NA);",
          "",
          "[Added Lines]",
          "259:     proto_tree *sdp_owner_tree;",
          "260:     gint        offset, next_offset, tokenlen;",
          "262:     offset = 0;",
          "264:     sdp_owner_tree = proto_item_add_subtree(ti, ett_sdp_owner);",
          "267:     next_offset = tvb_find_guint8(tvb, offset, -1, ' ');",
          "268:     if (next_offset == -1)",
          "269:         return;",
          "270:     tokenlen = next_offset - offset;",
          "272:     proto_tree_add_item(sdp_owner_tree, hf_owner_username, tvb, offset, tokenlen,",
          "273:                         ENC_ASCII|ENC_NA);",
          "274:     offset = next_offset  + 1;",
          "277:     next_offset = tvb_find_guint8(tvb, offset, -1, ' ');",
          "278:     if (next_offset == -1)",
          "279:         return;",
          "280:     tokenlen = next_offset - offset;",
          "282:     proto_tree_add_item(sdp_owner_tree, hf_owner_sessionid, tvb, offset,",
          "283:                         tokenlen, ENC_ASCII|ENC_NA);",
          "284:     offset = next_offset + 1;",
          "287:     next_offset = tvb_find_guint8(tvb, offset, -1, ' ');",
          "288:     if (next_offset == -1)",
          "289:         return;",
          "290:     tokenlen = next_offset - offset;",
          "292:     proto_tree_add_item(sdp_owner_tree, hf_owner_version, tvb, offset, tokenlen,",
          "293:                         ENC_ASCII|ENC_NA);",
          "294:     offset = next_offset + 1;",
          "297:     next_offset = tvb_find_guint8(tvb, offset, -1, ' ');",
          "298:     if (next_offset == -1)",
          "299:         return;",
          "300:     tokenlen = next_offset - offset;",
          "302:     proto_tree_add_item(sdp_owner_tree, hf_owner_network_type, tvb, offset,",
          "303:                         tokenlen, ENC_ASCII|ENC_NA);",
          "304:     offset = next_offset + 1;",
          "307:     next_offset = tvb_find_guint8(tvb, offset, -1, ' ');",
          "308:     if (next_offset == -1)",
          "309:         return;",
          "310:     tokenlen = next_offset - offset;",
          "312:     proto_tree_add_item(sdp_owner_tree, hf_owner_address_type, tvb, offset,",
          "313:                         tokenlen, ENC_ASCII|ENC_NA);",
          "314:     offset = next_offset + 1;",
          "317:     proto_tree_add_item(sdp_owner_tree, hf_owner_address, tvb, offset, -1, ENC_ASCII|ENC_NA);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "324: static void",
          "325: dissect_sdp_connection_info(tvbuff_t *tvb, proto_item* ti,",
          "326:                             disposable_media_info_t *media_info) {",
          "369:     tokenlen = next_offset - offset;",
          "378:     offset = next_offset + 1;",
          "379:     next_offset = tvb_find_guint8(tvb, offset, -1, '/');",
          "380:     if (next_offset == -1) {",
          "382:     } else {",
          "384:     }",
          "385:     proto_tree_add_item(sdp_connection_info_tree,",
          "387:     if (next_offset != -1) {",
          "391:     }",
          "393: }",
          "395: static void",
          "396: dissect_sdp_bandwidth(tvbuff_t *tvb, proto_item *ti) {",
          "437: }",
          "439: static void dissect_sdp_time(tvbuff_t *tvb, proto_item* ti) {",
          "459: }",
          "461: static void dissect_sdp_repeat_time(tvbuff_t *tvb, proto_item* ti) {",
          "501: }",
          "502: static void",
          "503: dissect_sdp_timezone(tvbuff_t *tvb, proto_item* ti) {",
          "531: }",
          "534: static void dissect_sdp_encryption_key(tvbuff_t *tvb, proto_item * ti) {",
          "555: }",
          "557: static void dissect_key_mgmt(tvbuff_t *tvb, packet_info * pinfo, proto_item * ti) {",
          "641:     if (next_offset == -1)",
          "644:     tokenlen = next_offset - offset;",
          "716:     next_offset = tvb_find_guint8(tvb, offset, -1, ' ');",
          "717:     if (next_offset == -1)",
          "719:     tokenlen = next_offset - offset;",
          "722:     offset = next_offset + 1;",
          "726:     if (next_offset == -1)",
          "728:     tokenlen = next_offset - offset;",
          "752:     next_offset = tvb_find_guint8(tvb, offset, -1, ' ');",
          "783: }",
          "785: static tvbuff_t *",
          "786: ascii_bytes_to_tvb(tvbuff_t *tvb, packet_info *pinfo, gint len, gchar *msg)",
          "787: {",
          "851:     }",
          "857: }",
          "860: static const value_string h263_profile_vals[] =",
          "861: {",
          "872: };",
          "876: static const value_string h263_level_vals[] =",
          "877: {",
          "887: };",
          "890: static const value_string h264_packetization_mode_vals[] =",
          "891: {",
          "896: };",
          "",
          "[Removed Lines]",
          "327:   proto_tree *sdp_connection_info_tree;",
          "328:   gint        offset, next_offset, tokenlen;",
          "330:   offset = 0;",
          "332:   sdp_connection_info_tree = proto_item_add_subtree(ti,",
          "333:                                                     ett_sdp_connection_info);",
          "336:   next_offset = tvb_find_guint8(tvb, offset, -1, ' ');",
          "337:   if (next_offset == -1)",
          "338:     return;",
          "339:   tokenlen = next_offset - offset;",
          "341:   proto_tree_add_item(sdp_connection_info_tree,",
          "342:                       hf_connection_info_network_type, tvb, offset, tokenlen,",
          "343:                       ENC_ASCII|ENC_NA);",
          "344:   offset = next_offset + 1;",
          "347:   next_offset = tvb_find_guint8(tvb, offset, -1, ' ');",
          "348:   if (next_offset == -1)",
          "349:     return;",
          "350:   tokenlen = next_offset - offset;",
          "352:   media_info->connection_type = (char*)tvb_get_string(wmem_packet_scope(), tvb, offset, tokenlen);",
          "355:   proto_tree_add_item(sdp_connection_info_tree,",
          "356:                       hf_connection_info_address_type, tvb, offset, tokenlen,",
          "357:                       ENC_ASCII|ENC_NA);",
          "358:   offset = next_offset + 1;",
          "362:   next_offset = tvb_find_guint8(tvb, offset, -1, '/');",
          "363:   if (next_offset == -1) {",
          "366:     media_info->connection_address =",
          "367:       (char*)tvb_get_string(wmem_packet_scope(), tvb, offset, tvb_length_remaining(tvb, offset));",
          "368:   } else {",
          "371:     media_info->connection_address = (char*)tvb_get_string(wmem_packet_scope(), tvb, offset, tokenlen);",
          "372:   }",
          "374:   proto_tree_add_item(sdp_connection_info_tree,",
          "375:                       hf_connection_info_connection_address, tvb, offset,",
          "376:                       tokenlen, ENC_ASCII|ENC_NA);",
          "377:   if (next_offset != -1) {",
          "383:       tokenlen = next_offset - offset;",
          "386:                         hf_connection_info_ttl, tvb, offset, tokenlen, ENC_ASCII|ENC_NA);",
          "388:       offset = next_offset + 1;",
          "389:       proto_tree_add_item(sdp_connection_info_tree,",
          "390:                           hf_connection_info_num_addr, tvb, offset, -1, ENC_ASCII|ENC_NA);",
          "392:   }",
          "397:   proto_tree *sdp_bandwidth_tree;",
          "398:   gint        offset, next_offset, tokenlen;",
          "399:   proto_item *item;",
          "400:   gboolean    unit_is_kbs = FALSE;",
          "401:   gboolean    unit_is_bps = FALSE;",
          "403:   offset = 0;",
          "405:   sdp_bandwidth_tree = proto_item_add_subtree(ti, ett_sdp_bandwidth);",
          "408:   next_offset = tvb_find_guint8(tvb, offset, -1, ':');",
          "410:   if (next_offset == -1)",
          "411:     return;",
          "413:   tokenlen = next_offset - offset;",
          "415:   item = proto_tree_add_item(sdp_bandwidth_tree, hf_bandwidth_modifier, tvb, offset,",
          "416:                              tokenlen, ENC_ASCII|ENC_NA);",
          "417:   if (tvb_strneql(tvb, offset, \"CT\", 2) == 0) {",
          "418:     proto_item_append_text(item, \" [Conference Total(total bandwidth of all RTP sessions)]\");",
          "419:     unit_is_kbs = TRUE;",
          "420:   } else if (tvb_strneql(tvb, offset, \"AS\", 2) == 0) {",
          "421:     proto_item_append_text(item, \" [Application Specific (RTP session bandwidth)]\");",
          "422:     unit_is_kbs = TRUE;",
          "423:   } else if (tvb_strneql(tvb, offset, \"TIAS\", 4) == 0) {",
          "424:     proto_item_append_text(item, \" [Transport Independent Application Specific maximum]\");",
          "425:     unit_is_bps = TRUE;",
          "426:   }",
          "429:   offset = next_offset + 1;",
          "431:   item = proto_tree_add_item(sdp_bandwidth_tree, hf_bandwidth_value, tvb, offset, -1,",
          "432:                              ENC_ASCII|ENC_NA);",
          "433:   if (unit_is_kbs == TRUE)",
          "434:     proto_item_append_text(item, \" kb/s\");",
          "435:   if (unit_is_bps == TRUE)",
          "436:     proto_item_append_text(item, \" b/s\");",
          "440:   proto_tree *sdp_time_tree;",
          "441:   gint        offset, next_offset, tokenlen;",
          "443:   offset = 0;",
          "445:   sdp_time_tree = proto_item_add_subtree(ti, ett_sdp_time);",
          "448:   next_offset = tvb_find_guint8(tvb, offset, -1, ' ');",
          "449:   if (next_offset == -1)",
          "450:     return;",
          "452:   tokenlen = next_offset - offset;",
          "453:   proto_tree_add_item(sdp_time_tree, hf_time_start, tvb, offset, tokenlen,",
          "454:                       ENC_ASCII|ENC_NA);",
          "457:   offset = next_offset + 1;",
          "458:   proto_tree_add_item(sdp_time_tree, hf_time_stop, tvb, offset, -1, ENC_ASCII|ENC_NA);",
          "462:   proto_tree *sdp_repeat_time_tree;",
          "463:   gint        offset, next_offset, tokenlen;",
          "465:   offset = 0;",
          "467:   sdp_repeat_time_tree = proto_item_add_subtree(ti, ett_sdp_time);",
          "470:   next_offset = tvb_find_guint8(tvb, offset, -1, ' ');",
          "471:   if (next_offset == -1)",
          "472:     return;",
          "474:   tokenlen = next_offset - offset;",
          "475:   proto_tree_add_item(sdp_repeat_time_tree, hf_repeat_time_interval, tvb,",
          "476:                       offset, tokenlen, ENC_ASCII|ENC_NA);",
          "479:   offset = next_offset + 1;",
          "480:   next_offset = tvb_find_guint8(tvb, offset, -1, ' ');",
          "481:   if (next_offset == -1)",
          "482:     return;",
          "484:   tokenlen = next_offset - offset;",
          "485:   proto_tree_add_item(sdp_repeat_time_tree, hf_repeat_time_duration, tvb,",
          "486:                       offset, tokenlen, ENC_ASCII|ENC_NA);",
          "489:   do{",
          "490:     offset = next_offset +1;",
          "491:     next_offset = tvb_find_guint8(tvb, offset, -1, ' ');",
          "492:     if (next_offset != -1) {",
          "493:       tokenlen = next_offset - offset;",
          "494:     } else {",
          "496:     }",
          "497:     proto_tree_add_item(sdp_repeat_time_tree, hf_repeat_time_offset,",
          "498:                         tvb, offset, tokenlen, ENC_ASCII|ENC_NA);",
          "499:   } while (next_offset != -1);",
          "504:   proto_tree* sdp_timezone_tree;",
          "505:   gint        offset, next_offset, tokenlen;",
          "507:   offset = 0;",
          "509:   sdp_timezone_tree = proto_item_add_subtree(ti, ett_sdp_timezone);",
          "511:   do{",
          "512:     next_offset = tvb_find_guint8(tvb, offset, -1, ' ');",
          "513:     if (next_offset == -1)",
          "514:       break;",
          "515:     tokenlen = next_offset - offset;",
          "517:     proto_tree_add_item(sdp_timezone_tree, hf_timezone_time, tvb, offset,",
          "518:                         tokenlen, ENC_ASCII|ENC_NA);",
          "519:     offset = next_offset + 1;",
          "520:     next_offset = tvb_find_guint8(tvb, offset, -1, ' ');",
          "521:     if (next_offset != -1) {",
          "522:       tokenlen = next_offset - offset;",
          "523:     } else {",
          "525:     }",
          "526:     proto_tree_add_item(sdp_timezone_tree, hf_timezone_offset, tvb, offset,",
          "527:                         tokenlen, ENC_ASCII|ENC_NA);",
          "528:     offset = next_offset + 1;",
          "529:   } while (next_offset != -1);",
          "535:   proto_tree *sdp_encryption_key_tree;",
          "536:   gint        offset, next_offset, tokenlen;",
          "538:   offset = 0;",
          "540:   sdp_encryption_key_tree = proto_item_add_subtree(ti, ett_sdp_encryption_key);",
          "542:   next_offset = tvb_find_guint8(tvb, offset, -1, ':');",
          "544:   if (next_offset == -1)",
          "545:     return;",
          "547:   tokenlen = next_offset - offset;",
          "549:   proto_tree_add_item(sdp_encryption_key_tree, hf_encryption_key_type,",
          "550:                       tvb, offset, tokenlen, ENC_ASCII|ENC_NA);",
          "552:   offset = next_offset + 1;",
          "553:   proto_tree_add_item(sdp_encryption_key_tree, hf_encryption_key_data,",
          "554:                       tvb, offset, -1, ENC_ASCII|ENC_NA);",
          "558:   gchar      *data_p      = NULL;",
          "559:   gchar      *prtcl_id    = NULL;",
          "560:   gint        len;",
          "561:   tvbuff_t   *keymgmt_tvb;",
          "562:   gboolean    found_match = FALSE;",
          "563:   proto_tree *key_tree;",
          "564:   gint        next_offset;",
          "565:   gint        offset      = 0;",
          "566:   gint        tokenlen;",
          "568:   key_tree = proto_item_add_subtree(ti, ett_sdp_key_mgmt);",
          "570:   next_offset = tvb_find_guint8(tvb, offset, -1, ' ');",
          "572:   if (next_offset == -1)",
          "573:     return;",
          "575:   tokenlen = next_offset - offset;",
          "576:   prtcl_id = tvb_get_string(wmem_packet_scope(), tvb, offset, tokenlen);",
          "578:   proto_tree_add_item(key_tree, hf_key_mgmt_prtcl_id, tvb, offset, tokenlen, ENC_ASCII|ENC_NA);",
          "580:   offset = next_offset + 1;",
          "582:   len = tvb_length_remaining(tvb, offset);",
          "583:   if (len < 0)",
          "584:     return;",
          "586:   data_p = tvb_get_string(wmem_packet_scope(), tvb, offset, len);",
          "587:   keymgmt_tvb = base64_to_tvb(tvb, data_p);",
          "588:   add_new_data_source(pinfo, keymgmt_tvb, \"Key Management Data\");",
          "590:   if ((prtcl_id != NULL) && (key_mgmt_dissector_table != NULL)) {",
          "591:     found_match = dissector_try_string(key_mgmt_dissector_table,",
          "592:                                        prtcl_id,",
          "593:                                        keymgmt_tvb, pinfo,",
          "594:                                        key_tree, NULL);",
          "595:   }",
          "597:   if (found_match) {",
          "598:     proto_item *ti2 = proto_tree_add_item(key_tree, hf_key_mgmt_data,",
          "599:                                           keymgmt_tvb, 0, -1, ENC_NA);",
          "600:     PROTO_ITEM_SET_HIDDEN(ti2);",
          "601:   } else {",
          "602:     proto_tree_add_item(key_tree, hf_key_mgmt_data,",
          "603:                         keymgmt_tvb, 0, -1, ENC_NA);",
          "604:   }",
          "606: }",
          "609: static void dissect_sdp_session_attribute(tvbuff_t *tvb, packet_info * pinfo, proto_item * ti) {",
          "610:   proto_tree *sdp_session_attribute_tree;",
          "611:   gint        offset, next_offset, tokenlen;",
          "612:   guint8     *field_name;",
          "614:   offset = 0;",
          "616:   sdp_session_attribute_tree = proto_item_add_subtree(ti,",
          "617:                                                       ett_sdp_session_attribute);",
          "619:   next_offset = tvb_find_guint8(tvb, offset, -1, ':');",
          "621:   if (next_offset == -1)",
          "622:     return;",
          "624:   tokenlen = next_offset - offset;",
          "626:   proto_tree_add_item(sdp_session_attribute_tree, hf_session_attribute_field,",
          "627:                       tvb, offset, tokenlen, ENC_ASCII|ENC_NA);",
          "629:   field_name = tvb_get_string(wmem_packet_scope(), tvb, offset, tokenlen);",
          "631:   offset = next_offset + 1;",
          "633:   if (strcmp((char*)field_name, \"ipbcp\") == 0) {",
          "634:     offset = tvb_pbrk_guint8(tvb, offset, -1,\"0123456789\", NULL);",
          "636:     if (offset == -1)",
          "637:       return;",
          "639:     next_offset = tvb_find_guint8(tvb, offset, -1, ' ');",
          "642:       return;",
          "646:     proto_tree_add_item(sdp_session_attribute_tree, hf_ipbcp_version, tvb, offset, tokenlen, ENC_ASCII|ENC_NA);",
          "648:     offset = tvb_pbrk_guint8(tvb, offset, -1,\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\", NULL);",
          "650:     if (offset == -1)",
          "651:       return;",
          "653:     tokenlen = tvb_find_line_end(tvb, offset, -1, &next_offset, FALSE);",
          "655:     if (tokenlen == -1)",
          "656:       return;",
          "658:     proto_tree_add_item(sdp_session_attribute_tree, hf_ipbcp_type, tvb, offset, tokenlen, ENC_ASCII|ENC_NA);",
          "659:   } else if (strcmp((char*)field_name, \"key-mgmt\") == 0) {",
          "660:     tvbuff_t   *key_tvb;",
          "661:     proto_item *key_ti;",
          "663:     key_tvb = tvb_new_subset_remaining(tvb, offset);",
          "664:     key_ti = proto_tree_add_item(sdp_session_attribute_tree, hf_key_mgmt_att_value, key_tvb, 0, -1, ENC_ASCII|ENC_NA);",
          "666:     dissect_key_mgmt(key_tvb, pinfo, key_ti);",
          "667:   } else {",
          "668:     proto_tree_add_item(sdp_session_attribute_tree, hf_session_attribute_value,",
          "669:                         tvb, offset, -1, ENC_ASCII|ENC_NA);",
          "670:   }",
          "671: }",
          "675: static void",
          "676: dissect_sdp_media(tvbuff_t *tvb, proto_item *ti,",
          "677:                   transport_info_t *transport_info, disposable_media_info_t *media_info) {",
          "678:   proto_tree *sdp_media_tree;",
          "679:   gint        offset, next_offset, tokenlen, idx;",
          "680:   guint8     *media_format;",
          "682:   offset = 0;",
          "685:   sdp_media_tree = proto_item_add_subtree(ti, ett_sdp_media);",
          "687:   next_offset = tvb_find_guint8(tvb, offset, -1, ' ');",
          "689:   if (next_offset == -1)",
          "690:     return;",
          "692:   tokenlen = next_offset - offset;",
          "695:   proto_tree_add_item(sdp_media_tree, hf_media_media, tvb, offset, tokenlen,",
          "696:                       ENC_ASCII|ENC_NA);",
          "698:   media_info->media_type[media_info->media_count] = (char*)tvb_get_string(wmem_packet_scope(), tvb, offset, tokenlen);",
          "700:   offset = next_offset + 1;",
          "702:   next_offset = tvb_find_guint8(tvb, offset, -1, ' ');",
          "703:   if (next_offset == -1)",
          "704:     return;",
          "705:   tokenlen = next_offset - offset;",
          "706:   next_offset = tvb_find_guint8(tvb, offset, tokenlen, '/');",
          "708:   if (next_offset != -1) {",
          "709:     tokenlen = next_offset - offset;",
          "711:     media_info->media_port[media_info->media_count] = (char*)tvb_get_string(wmem_packet_scope(), tvb, offset, tokenlen);",
          "713:     proto_tree_add_uint(sdp_media_tree, hf_media_port, tvb, offset, tokenlen,",
          "714:                         atoi((char*)tvb_get_string(wmem_packet_scope(), tvb, offset, tokenlen)));",
          "715:     offset = next_offset + 1;",
          "718:       return;",
          "720:     proto_tree_add_item(sdp_media_tree, hf_media_portcount, tvb, offset,",
          "721:                         tokenlen, ENC_ASCII|ENC_NA);",
          "723:   } else {",
          "724:     next_offset = tvb_find_guint8(tvb, offset, -1, ' ');",
          "727:       return;",
          "730:     media_info->media_port[media_info->media_count] = (char*)tvb_get_string(wmem_packet_scope(), tvb, offset, tokenlen);",
          "732:     proto_tree_add_uint(sdp_media_tree, hf_media_port, tvb, offset, tokenlen,",
          "733:                         atoi((char*)tvb_get_string(wmem_packet_scope(), tvb, offset, tokenlen)));",
          "734:     offset = next_offset + 1;",
          "735:   }",
          "737:   next_offset = tvb_find_guint8(tvb, offset, -1, ' ');",
          "739:   if ( next_offset == -1)",
          "740:     return;",
          "742:   tokenlen = next_offset - offset;",
          "744:   media_info->media_proto[media_info->media_count] = (char*)tvb_get_string(wmem_packet_scope(), tvb, offset, tokenlen);",
          "747:   proto_tree_add_item(sdp_media_tree, hf_media_proto, tvb, offset, tokenlen,",
          "748:                       ENC_ASCII|ENC_NA);",
          "750:   do {",
          "751:     offset = next_offset + 1;",
          "754:     if (next_offset == -1) {",
          "756:       if (tokenlen == 0)",
          "758:     } else {",
          "759:       tokenlen = next_offset - offset;",
          "760:     }",
          "762:     if (!strcmp(media_info->media_proto[media_info->media_count], \"RTP/AVP\")) {",
          "763:       media_format = tvb_get_string(wmem_packet_scope(), tvb, offset, tokenlen);",
          "764:       proto_tree_add_string(sdp_media_tree, hf_media_format, tvb, offset,",
          "765:                             tokenlen, val_to_str_ext((guint32)strtoul((char*)media_format, NULL, 10), &rtp_payload_type_vals_ext, \"%u\"));",
          "766:       idx = transport_info->media[transport_info->media_count].pt_count;",
          "767:       transport_info->media[transport_info->media_count].pt[idx] = (gint32)strtol((char*)media_format, NULL, 10);",
          "768:       if (idx < (SDP_MAX_RTP_PAYLOAD_TYPES-1))",
          "769:         transport_info->media[transport_info->media_count].pt_count++;",
          "770:     } else {",
          "771:       proto_tree_add_item(sdp_media_tree, hf_media_format, tvb, offset,",
          "772:                           tokenlen, ENC_ASCII|ENC_NA);",
          "773:     }",
          "774:   } while (next_offset != -1);",
          "788:   guint8 *buf = (guint8 *)wmem_alloc(pinfo->pool, 10240);",
          "791:   if (len < 20480) {",
          "792:     int i;",
          "793:     tvbuff_t *bytes_tvb;",
          "796:        the first hex digit after the '=' char.",
          "798:     while (1) {",
          "799:       if ((*msg == 0) || (*msg == '\\n')) {",
          "800:         return NULL;",
          "801:       }",
          "802:       if (*msg == '=') {",
          "803:         msg++;",
          "804:         break;",
          "805:       }",
          "806:       msg++;",
          "807:     }",
          "808:     while (1) {",
          "809:       if ((*msg == 0) || (*msg == '\\n')) {",
          "810:         return NULL;",
          "811:       }",
          "812:       if ( ((*msg >= '0') && (*msg <= '9'))",
          "813:            || ((*msg >= 'a') && (*msg <= 'f'))",
          "814:            || ((*msg >= 'A') && (*msg <= 'F'))) {",
          "815:         break;",
          "816:       }",
          "817:       msg++;",
          "818:     }",
          "819:     i = 0;",
          "820:     while (((*msg >= '0') && (*msg <= '9'))",
          "821:            || ((*msg >= 'a') && (*msg <= 'f'))",
          "822:            || ((*msg >= 'A') && (*msg <= 'F'))) {",
          "823:       int val;",
          "824:       if ((*msg >= '0') && (*msg <= '9')) {",
          "825:         val = (*msg)-'0';",
          "826:       } else if ((*msg >= 'a') && (*msg <= 'f')) {",
          "827:         val = (*msg)-'a'+10;",
          "828:       } else if ((*msg >= 'A') && (*msg <= 'F')) {",
          "829:         val = (*msg)-'A'+10;",
          "830:       } else {",
          "831:         return NULL;",
          "832:       }",
          "833:       val <<= 4;",
          "834:       msg++;",
          "835:       if ((*msg >= '0') && (*msg <= '9')) {",
          "836:         val |= (*msg)-'0';",
          "837:       } else if ((*msg >= 'a') && (*msg <= 'f')) {",
          "838:         val |= (*msg)-'a'+10;",
          "839:       } else if ((*msg >= 'A') && (*msg <= 'F')) {",
          "840:         val |= (*msg)-'A'+10;",
          "841:       } else {",
          "842:         return NULL;",
          "843:       }",
          "844:       msg++;",
          "846:       buf[i] = (guint8)val;",
          "847:       i++;",
          "848:     }",
          "849:     if (i == 0) {",
          "850:       return NULL;",
          "852:     bytes_tvb = tvb_new_child_real_data(tvb, buf, i, i);",
          "853:     add_new_data_source(pinfo, bytes_tvb, \"ASCII bytes to tvb\");",
          "854:     return bytes_tvb;",
          "855:   }",
          "856:   return NULL;",
          "862:   { 0,    \"Baseline Profile\" },",
          "863:   { 1,    \"H.320 Coding Efficiency Version 2 Backward-Compatibility Profile\" },",
          "864:   { 2,    \"Version 1 Backward-Compatibility Profile\" },",
          "865:   { 3,    \"Version 2 Interactive and Streaming Wireless Profile\" },",
          "866:   { 4,    \"Version 3 Interactive and Streaming Wireless Profile\" },",
          "867:   { 5,    \"Conversational High Compression Profile\" },",
          "868:   { 6,    \"Conversational Internet Profile\" },",
          "869:   { 7,    \"Conversational Interlace Profile\" },",
          "870:   { 8,    \"High Latency Profile\" },",
          "871:   { 0, NULL },",
          "878:   { 10,    \"QCIF (176 x 144), 1 x 64Kb/s\" },",
          "879:   { 20,    \"CIF (352 x 288), 2 x 64Kb/s\" },",
          "880:   { 30,    \"CIF (352 x 288), 6 x 64Kb/s\" },",
          "881:   { 40,    \"CIF (352 x 288), 32 x 64Kb/s\" },",
          "882:   { 45,    \"QCIF (176 x144) support of CPFMT, 2 x 64Kb/s\" },",
          "883:   { 50,    \"CIF (352 x 288) support of CPFMT, 64 x 64Kb/s\" },",
          "884:   { 60,    \"CPFMT: 720 x 288 support of CPFMT, 128 x 64Kb/s\" },",
          "885:   { 70,    \"CPFMT: 720 x 576 support of CPFMT, 256 x 64Kb/s\" },",
          "886:   { 0, NULL },",
          "892:   { 0,    \"Single NAL mode\" },",
          "893:   { 1,    \"Non-interleaved mode\" },",
          "894:   { 2,    \"Interleaved mode\" },",
          "895:   { 0, NULL },",
          "",
          "[Added Lines]",
          "327:     proto_tree *sdp_connection_info_tree;",
          "328:     gint        offset, next_offset, tokenlen;",
          "330:     offset = 0;",
          "332:     sdp_connection_info_tree = proto_item_add_subtree(ti,",
          "333:                                                       ett_sdp_connection_info);",
          "336:     next_offset = tvb_find_guint8(tvb, offset, -1, ' ');",
          "337:     if (next_offset == -1)",
          "338:         return;",
          "341:     proto_tree_add_item(sdp_connection_info_tree,",
          "342:                         hf_connection_info_network_type, tvb, offset, tokenlen,",
          "343:                         ENC_ASCII|ENC_NA);",
          "347:     next_offset = tvb_find_guint8(tvb, offset, -1, ' ');",
          "348:     if (next_offset == -1)",
          "349:         return;",
          "350:     tokenlen = next_offset - offset;",
          "352:     media_info->connection_type = (char*)tvb_get_string(wmem_packet_scope(), tvb, offset, tokenlen);",
          "355:     proto_tree_add_item(sdp_connection_info_tree,",
          "356:                         hf_connection_info_address_type, tvb, offset, tokenlen,",
          "357:                         ENC_ASCII|ENC_NA);",
          "358:     offset = next_offset + 1;",
          "366:         media_info->connection_address =",
          "367:             (char*)tvb_get_string(wmem_packet_scope(), tvb, offset, tvb_length_remaining(tvb, offset));",
          "369:         tokenlen = next_offset - offset;",
          "371:         media_info->connection_address = (char*)tvb_get_string(wmem_packet_scope(), tvb, offset, tokenlen);",
          "375:                         hf_connection_info_connection_address, tvb, offset,",
          "376:                         tokenlen, ENC_ASCII|ENC_NA);",
          "378:         offset = next_offset + 1;",
          "379:         next_offset = tvb_find_guint8(tvb, offset, -1, '/');",
          "380:         if (next_offset == -1) {",
          "382:         } else {",
          "383:             tokenlen = next_offset - offset;",
          "384:         }",
          "385:         proto_tree_add_item(sdp_connection_info_tree,",
          "386:                             hf_connection_info_ttl, tvb, offset, tokenlen, ENC_ASCII|ENC_NA);",
          "387:         if (next_offset != -1) {",
          "388:             offset = next_offset + 1;",
          "389:             proto_tree_add_item(sdp_connection_info_tree,",
          "390:                                 hf_connection_info_num_addr, tvb, offset, -1, ENC_ASCII|ENC_NA);",
          "391:         }",
          "397:     proto_tree *sdp_bandwidth_tree;",
          "398:     gint        offset, next_offset, tokenlen;",
          "399:     proto_item *item;",
          "400:     gboolean    unit_is_kbs = FALSE;",
          "401:     gboolean    unit_is_bps = FALSE;",
          "403:     offset = 0;",
          "405:     sdp_bandwidth_tree = proto_item_add_subtree(ti, ett_sdp_bandwidth);",
          "408:     next_offset = tvb_find_guint8(tvb, offset, -1, ':');",
          "410:     if (next_offset == -1)",
          "411:         return;",
          "413:     tokenlen = next_offset - offset;",
          "415:     item = proto_tree_add_item(sdp_bandwidth_tree, hf_bandwidth_modifier, tvb, offset,",
          "416:                                tokenlen, ENC_ASCII|ENC_NA);",
          "417:     if (tvb_strneql(tvb, offset, \"CT\", 2) == 0) {",
          "418:         proto_item_append_text(item, \" [Conference Total(total bandwidth of all RTP sessions)]\");",
          "419:         unit_is_kbs = TRUE;",
          "420:     } else if (tvb_strneql(tvb, offset, \"AS\", 2) == 0) {",
          "421:         proto_item_append_text(item, \" [Application Specific (RTP session bandwidth)]\");",
          "422:         unit_is_kbs = TRUE;",
          "423:     } else if (tvb_strneql(tvb, offset, \"TIAS\", 4) == 0) {",
          "424:         proto_item_append_text(item, \" [Transport Independent Application Specific maximum]\");",
          "425:         unit_is_bps = TRUE;",
          "426:     }",
          "429:     offset = next_offset + 1;",
          "431:     item = proto_tree_add_item(sdp_bandwidth_tree, hf_bandwidth_value, tvb, offset, -1,",
          "432:                                ENC_ASCII|ENC_NA);",
          "433:     if (unit_is_kbs == TRUE)",
          "434:         proto_item_append_text(item, \" kb/s\");",
          "435:     if (unit_is_bps == TRUE)",
          "436:         proto_item_append_text(item, \" b/s\");",
          "440:     proto_tree *sdp_time_tree;",
          "441:     gint        offset, next_offset, tokenlen;",
          "443:     offset = 0;",
          "445:     sdp_time_tree = proto_item_add_subtree(ti, ett_sdp_time);",
          "448:     next_offset = tvb_find_guint8(tvb, offset, -1, ' ');",
          "449:     if (next_offset == -1)",
          "450:         return;",
          "452:     tokenlen = next_offset - offset;",
          "453:     proto_tree_add_item(sdp_time_tree, hf_time_start, tvb, offset, tokenlen,",
          "454:                         ENC_ASCII|ENC_NA);",
          "457:     offset = next_offset + 1;",
          "458:     proto_tree_add_item(sdp_time_tree, hf_time_stop, tvb, offset, -1, ENC_ASCII|ENC_NA);",
          "462:     proto_tree *sdp_repeat_time_tree;",
          "463:     gint        offset, next_offset, tokenlen;",
          "465:     offset = 0;",
          "467:     sdp_repeat_time_tree = proto_item_add_subtree(ti, ett_sdp_time);",
          "470:     next_offset = tvb_find_guint8(tvb, offset, -1, ' ');",
          "471:     if (next_offset == -1)",
          "472:         return;",
          "474:     tokenlen = next_offset - offset;",
          "475:     proto_tree_add_item(sdp_repeat_time_tree, hf_repeat_time_interval, tvb,",
          "476:                         offset, tokenlen, ENC_ASCII|ENC_NA);",
          "479:     offset = next_offset + 1;",
          "480:     next_offset = tvb_find_guint8(tvb, offset, -1, ' ');",
          "481:     if (next_offset == -1)",
          "482:         return;",
          "484:     tokenlen = next_offset - offset;",
          "485:     proto_tree_add_item(sdp_repeat_time_tree, hf_repeat_time_duration, tvb,",
          "486:                         offset, tokenlen, ENC_ASCII|ENC_NA);",
          "489:     do {",
          "490:         offset = next_offset +1;",
          "491:         next_offset = tvb_find_guint8(tvb, offset, -1, ' ');",
          "492:         if (next_offset != -1) {",
          "493:             tokenlen = next_offset - offset;",
          "494:         } else {",
          "496:         }",
          "497:         proto_tree_add_item(sdp_repeat_time_tree, hf_repeat_time_offset,",
          "498:                             tvb, offset, tokenlen, ENC_ASCII|ENC_NA);",
          "499:     } while (next_offset != -1);",
          "505:     proto_tree* sdp_timezone_tree;",
          "506:     gint        offset, next_offset, tokenlen;",
          "508:     offset = 0;",
          "510:     sdp_timezone_tree = proto_item_add_subtree(ti, ett_sdp_timezone);",
          "512:     do {",
          "513:         next_offset = tvb_find_guint8(tvb, offset, -1, ' ');",
          "514:         if (next_offset == -1)",
          "515:             break;",
          "516:         tokenlen = next_offset - offset;",
          "518:         proto_tree_add_item(sdp_timezone_tree, hf_timezone_time, tvb, offset,",
          "519:                             tokenlen, ENC_ASCII|ENC_NA);",
          "520:         offset = next_offset + 1;",
          "521:         next_offset = tvb_find_guint8(tvb, offset, -1, ' ');",
          "522:         if (next_offset != -1) {",
          "523:             tokenlen = next_offset - offset;",
          "524:         } else {",
          "526:         }",
          "527:         proto_tree_add_item(sdp_timezone_tree, hf_timezone_offset, tvb, offset,",
          "528:                             tokenlen, ENC_ASCII|ENC_NA);",
          "529:         offset = next_offset + 1;",
          "530:     } while (next_offset != -1);",
          "536:     proto_tree *sdp_encryption_key_tree;",
          "537:     gint        offset, next_offset, tokenlen;",
          "539:     offset = 0;",
          "541:     sdp_encryption_key_tree = proto_item_add_subtree(ti, ett_sdp_encryption_key);",
          "543:     next_offset = tvb_find_guint8(tvb, offset, -1, ':');",
          "545:     if (next_offset == -1)",
          "546:         return;",
          "548:     tokenlen = next_offset - offset;",
          "550:     proto_tree_add_item(sdp_encryption_key_tree, hf_encryption_key_type,",
          "551:                         tvb, offset, tokenlen, ENC_ASCII|ENC_NA);",
          "553:     offset = next_offset + 1;",
          "554:     proto_tree_add_item(sdp_encryption_key_tree, hf_encryption_key_data,",
          "555:                         tvb, offset, -1, ENC_ASCII|ENC_NA);",
          "559:     gchar      *data_p      = NULL;",
          "560:     gchar      *prtcl_id    = NULL;",
          "561:     gint        len;",
          "562:     tvbuff_t   *keymgmt_tvb;",
          "563:     gboolean    found_match = FALSE;",
          "564:     proto_tree *key_tree;",
          "565:     gint        next_offset;",
          "566:     gint        offset      = 0;",
          "567:     gint        tokenlen;",
          "569:     key_tree = proto_item_add_subtree(ti, ett_sdp_key_mgmt);",
          "571:     next_offset = tvb_find_guint8(tvb, offset, -1, ' ');",
          "573:     if (next_offset == -1)",
          "574:         return;",
          "576:     tokenlen = next_offset - offset;",
          "577:     prtcl_id = tvb_get_string(wmem_packet_scope(), tvb, offset, tokenlen);",
          "579:     proto_tree_add_item(key_tree, hf_key_mgmt_prtcl_id, tvb, offset, tokenlen, ENC_ASCII|ENC_NA);",
          "581:     offset = next_offset + 1;",
          "583:     len = tvb_length_remaining(tvb, offset);",
          "584:     if (len < 0)",
          "585:         return;",
          "587:     data_p = tvb_get_string(wmem_packet_scope(), tvb, offset, len);",
          "588:     keymgmt_tvb = base64_to_tvb(tvb, data_p);",
          "589:     add_new_data_source(pinfo, keymgmt_tvb, \"Key Management Data\");",
          "591:     if ((prtcl_id != NULL) && (key_mgmt_dissector_table != NULL)) {",
          "592:         found_match = dissector_try_string(key_mgmt_dissector_table,",
          "593:                                            prtcl_id,",
          "594:                                            keymgmt_tvb, pinfo,",
          "595:                                            key_tree, NULL);",
          "596:     }",
          "598:     if (found_match) {",
          "599:         proto_item *ti2 = proto_tree_add_item(key_tree, hf_key_mgmt_data,",
          "600:                                               keymgmt_tvb, 0, -1, ENC_NA);",
          "601:         PROTO_ITEM_SET_HIDDEN(ti2);",
          "602:     } else {",
          "603:         proto_tree_add_item(key_tree, hf_key_mgmt_data,",
          "604:                             keymgmt_tvb, 0, -1, ENC_NA);",
          "605:     }",
          "607: }",
          "610: static void dissect_sdp_session_attribute(tvbuff_t *tvb, packet_info * pinfo, proto_item * ti) {",
          "611:     proto_tree *sdp_session_attribute_tree;",
          "612:     gint        offset, next_offset, tokenlen;",
          "613:     guint8     *field_name;",
          "615:     offset = 0;",
          "617:     sdp_session_attribute_tree = proto_item_add_subtree(ti,",
          "618:                                                         ett_sdp_session_attribute);",
          "620:     next_offset = tvb_find_guint8(tvb, offset, -1, ':');",
          "623:         return;",
          "627:     proto_tree_add_item(sdp_session_attribute_tree, hf_session_attribute_field,",
          "628:                         tvb, offset, tokenlen, ENC_ASCII|ENC_NA);",
          "630:     field_name = tvb_get_string(wmem_packet_scope(), tvb, offset, tokenlen);",
          "632:     offset = next_offset + 1;",
          "634:     if (strcmp((char*)field_name, \"ipbcp\") == 0) {",
          "635:         offset = tvb_pbrk_guint8(tvb, offset, -1,\"0123456789\", NULL);",
          "637:         if (offset == -1)",
          "638:             return;",
          "640:         next_offset = tvb_find_guint8(tvb, offset, -1, ' ');",
          "642:         if (next_offset == -1)",
          "643:             return;",
          "645:         tokenlen = next_offset - offset;",
          "647:         proto_tree_add_item(sdp_session_attribute_tree, hf_ipbcp_version, tvb, offset, tokenlen, ENC_ASCII|ENC_NA);",
          "649:         offset = tvb_pbrk_guint8(tvb, offset, -1,\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\", NULL);",
          "651:         if (offset == -1)",
          "652:             return;",
          "654:         tokenlen = tvb_find_line_end(tvb, offset, -1, &next_offset, FALSE);",
          "656:         if (tokenlen == -1)",
          "657:             return;",
          "659:         proto_tree_add_item(sdp_session_attribute_tree, hf_ipbcp_type, tvb, offset, tokenlen, ENC_ASCII|ENC_NA);",
          "660:     } else if (strcmp((char*)field_name, \"key-mgmt\") == 0) {",
          "661:         tvbuff_t   *key_tvb;",
          "662:         proto_item *key_ti;",
          "664:         key_tvb = tvb_new_subset_remaining(tvb, offset);",
          "665:         key_ti = proto_tree_add_item(sdp_session_attribute_tree, hf_key_mgmt_att_value, key_tvb, 0, -1, ENC_ASCII|ENC_NA);",
          "667:         dissect_key_mgmt(key_tvb, pinfo, key_ti);",
          "668:     } else {",
          "669:         proto_tree_add_item(sdp_session_attribute_tree, hf_session_attribute_value,",
          "670:                             tvb, offset, -1, ENC_ASCII|ENC_NA);",
          "671:     }",
          "672: }",
          "676: static void",
          "677: dissect_sdp_media(tvbuff_t *tvb, proto_item *ti,",
          "678:                   transport_info_t *transport_info, disposable_media_info_t *media_info) {",
          "679:     proto_tree *sdp_media_tree;",
          "680:     gint        offset, next_offset, tokenlen, idx;",
          "681:     guint8     *media_format;",
          "683:     offset = 0;",
          "686:     sdp_media_tree = proto_item_add_subtree(ti, ett_sdp_media);",
          "691:         return;",
          "696:     proto_tree_add_item(sdp_media_tree, hf_media_media, tvb, offset, tokenlen,",
          "697:                         ENC_ASCII|ENC_NA);",
          "699:     media_info->media_type[media_info->media_count] = (char*)tvb_get_string(wmem_packet_scope(), tvb, offset, tokenlen);",
          "703:     next_offset = tvb_find_guint8(tvb, offset, -1, ' ');",
          "705:         return;",
          "707:     next_offset = tvb_find_guint8(tvb, offset, tokenlen, '/');",
          "709:     if (next_offset != -1) {",
          "710:         tokenlen = next_offset - offset;",
          "712:         media_info->media_port[media_info->media_count] = (char*)tvb_get_string(wmem_packet_scope(), tvb, offset, tokenlen);",
          "714:         proto_tree_add_uint(sdp_media_tree, hf_media_port, tvb, offset, tokenlen,",
          "715:                             atoi((char*)tvb_get_string(wmem_packet_scope(), tvb, offset, tokenlen)));",
          "716:         offset = next_offset + 1;",
          "717:         next_offset = tvb_find_guint8(tvb, offset, -1, ' ');",
          "718:         if (next_offset == -1)",
          "719:             return;",
          "720:         tokenlen = next_offset - offset;",
          "721:         proto_tree_add_item(sdp_media_tree, hf_media_portcount, tvb, offset,",
          "722:                             tokenlen, ENC_ASCII|ENC_NA);",
          "723:         offset = next_offset + 1;",
          "724:     } else {",
          "725:         next_offset = tvb_find_guint8(tvb, offset, -1, ' ');",
          "727:         if (next_offset == -1)",
          "728:             return;",
          "729:         tokenlen = next_offset - offset;",
          "731:         media_info->media_port[media_info->media_count] = (char*)tvb_get_string(wmem_packet_scope(), tvb, offset, tokenlen);",
          "733:         proto_tree_add_uint(sdp_media_tree, hf_media_port, tvb, offset, tokenlen,",
          "734:                             atoi((char*)tvb_get_string(wmem_packet_scope(), tvb, offset, tokenlen)));",
          "735:         offset = next_offset + 1;",
          "736:     }",
          "740:     if ( next_offset == -1)",
          "741:         return;",
          "743:     tokenlen = next_offset - offset;",
          "745:     media_info->media_proto[media_info->media_count] = (char*)tvb_get_string(wmem_packet_scope(), tvb, offset, tokenlen);",
          "748:     proto_tree_add_item(sdp_media_tree, hf_media_proto, tvb, offset, tokenlen,",
          "749:                         ENC_ASCII|ENC_NA);",
          "751:     do {",
          "752:         offset = next_offset + 1;",
          "753:         next_offset = tvb_find_guint8(tvb, offset, -1, ' ');",
          "755:         if (next_offset == -1) {",
          "757:             if (tokenlen == 0)",
          "759:         } else {",
          "760:             tokenlen = next_offset - offset;",
          "761:         }",
          "763:         if (!strcmp(media_info->media_proto[media_info->media_count], \"RTP/AVP\")) {",
          "764:             media_format = tvb_get_string(wmem_packet_scope(), tvb, offset, tokenlen);",
          "765:             proto_tree_add_string(sdp_media_tree, hf_media_format, tvb, offset,",
          "766:                                   tokenlen, val_to_str_ext((guint32)strtoul((char*)media_format, NULL, 10), &rtp_payload_type_vals_ext, \"%u\"));",
          "767:             idx = transport_info->media[transport_info->media_count].pt_count;",
          "768:             transport_info->media[transport_info->media_count].pt[idx] = (gint32)strtol((char*)media_format, NULL, 10);",
          "769:             if (idx < (SDP_MAX_RTP_PAYLOAD_TYPES-1))",
          "770:                 transport_info->media[transport_info->media_count].pt_count++;",
          "771:         } else {",
          "772:             proto_tree_add_item(sdp_media_tree, hf_media_format, tvb, offset,",
          "773:                                 tokenlen, ENC_ASCII|ENC_NA);",
          "774:         }",
          "775:     } while (next_offset != -1);",
          "789:     guint8 *buf = (guint8 *)wmem_alloc(pinfo->pool, 10240);",
          "792:     if (len < 20480) {",
          "793:         int i;",
          "794:         tvbuff_t *bytes_tvb;",
          "797:            the first hex digit after the '=' char.",
          "799:         while (1) {",
          "800:             if ((*msg == 0) || (*msg == '\\n')) {",
          "801:                 return NULL;",
          "802:             }",
          "803:             if (*msg == '=') {",
          "804:                 msg++;",
          "805:                 break;",
          "806:             }",
          "807:             msg++;",
          "808:         }",
          "809:         while (1) {",
          "810:             if ((*msg == 0) || (*msg == '\\n')) {",
          "811:                 return NULL;",
          "812:             }",
          "813:             if ( ((*msg >= '0') && (*msg <= '9'))",
          "814:                  || ((*msg >= 'a') && (*msg <= 'f'))",
          "815:                  || ((*msg >= 'A') && (*msg <= 'F'))) {",
          "816:                 break;",
          "817:             }",
          "818:             msg++;",
          "819:         }",
          "820:         i = 0;",
          "821:         while (((*msg >= '0') && (*msg <= '9'))",
          "822:                || ((*msg >= 'a') && (*msg <= 'f'))",
          "823:                || ((*msg >= 'A') && (*msg <= 'F'))) {",
          "824:             int val;",
          "825:             if ((*msg >= '0') && (*msg <= '9')) {",
          "826:                 val = (*msg)-'0';",
          "827:             } else if ((*msg >= 'a') && (*msg <= 'f')) {",
          "828:                 val = (*msg)-'a'+10;",
          "829:             } else if ((*msg >= 'A') && (*msg <= 'F')) {",
          "830:                 val = (*msg)-'A'+10;",
          "831:             } else {",
          "832:                 return NULL;",
          "833:             }",
          "834:             val <<= 4;",
          "835:             msg++;",
          "836:             if ((*msg >= '0') && (*msg <= '9')) {",
          "837:                 val |= (*msg)-'0';",
          "838:             } else if ((*msg >= 'a') && (*msg <= 'f')) {",
          "839:                 val |= (*msg)-'a'+10;",
          "840:             } else if ((*msg >= 'A') && (*msg <= 'F')) {",
          "841:                 val |= (*msg)-'A'+10;",
          "842:             } else {",
          "843:                 return NULL;",
          "844:             }",
          "845:             msg++;",
          "847:             buf[i] = (guint8)val;",
          "848:             i++;",
          "849:         }",
          "850:         if (i == 0) {",
          "851:             return NULL;",
          "852:         }",
          "853:         bytes_tvb = tvb_new_child_real_data(tvb, buf, i, i);",
          "854:         add_new_data_source(pinfo, bytes_tvb, \"ASCII bytes to tvb\");",
          "855:         return bytes_tvb;",
          "857:     return NULL;",
          "863:     { 0,    \"Baseline Profile\" },",
          "864:     { 1,    \"H.320 Coding Efficiency Version 2 Backward-Compatibility Profile\" },",
          "865:     { 2,    \"Version 1 Backward-Compatibility Profile\" },",
          "866:     { 3,    \"Version 2 Interactive and Streaming Wireless Profile\" },",
          "867:     { 4,    \"Version 3 Interactive and Streaming Wireless Profile\" },",
          "868:     { 5,    \"Conversational High Compression Profile\" },",
          "869:     { 6,    \"Conversational Internet Profile\" },",
          "870:     { 7,    \"Conversational Interlace Profile\" },",
          "871:     { 8,    \"High Latency Profile\" },",
          "872:     { 0, NULL },",
          "879:     { 10,    \"QCIF (176 x 144), 1 x 64Kb/s\" },",
          "880:     { 20,    \"CIF (352 x 288), 2 x 64Kb/s\" },",
          "881:     { 30,    \"CIF (352 x 288), 6 x 64Kb/s\" },",
          "882:     { 40,    \"CIF (352 x 288), 32 x 64Kb/s\" },",
          "883:     { 45,    \"QCIF (176 x144) support of CPFMT, 2 x 64Kb/s\" },",
          "884:     { 50,    \"CIF (352 x 288) support of CPFMT, 64 x 64Kb/s\" },",
          "885:     { 60,    \"CPFMT: 720 x 288 support of CPFMT, 128 x 64Kb/s\" },",
          "886:     { 70,    \"CPFMT: 720 x 576 support of CPFMT, 256 x 64Kb/s\" },",
          "887:     { 0, NULL },",
          "893:     { 0,    \"Single NAL mode\" },",
          "894:     { 1,    \"Non-interleaved mode\" },",
          "895:     { 2,    \"Interleaved mode\" },",
          "896:     { 0, NULL },",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "914:     tvb_get_string(wmem_packet_scope(), tvb, offset, tokenlen));",
          "915: #endif",
          "929: #if 0",
          "931: #endif",
          "1049:         }",
          "1052:         }",
          "1063:         }",
          "1065:     }",
          "1068: }",
          "",
          "[Removed Lines]",
          "919:   next_offset = tvb_find_guint8(tvb, offset, -1, '=');",
          "920:   if (next_offset == -1)",
          "921:   {",
          "923:     return;",
          "924:   }",
          "927:   tokenlen = next_offset - offset;",
          "928:   field_name = tvb_get_string(wmem_packet_scope(), tvb, offset, tokenlen);",
          "932:   offset = next_offset;",
          "935:   if ((mime_type != NULL) && (g_ascii_strcasecmp(mime_type, \"MP4V-ES\") == 0)) {",
          "936:     if (strcmp((char*)field_name, \"profile-level-id\") == 0) {",
          "937:       offset++;",
          "938:       tokenlen = end_offset - offset;",
          "939:       format_specific_parameter = tvb_get_string(wmem_packet_scope(), tvb, offset, tokenlen);",
          "940:       item = proto_tree_add_uint(tree, hf_sdp_fmtp_mpeg4_profile_level_id, tvb, offset, tokenlen,",
          "941:                                  (guint32)strtol((char*)format_specific_parameter, NULL, 10));",
          "942:       PROTO_ITEM_SET_GENERATED(item);",
          "943:     } else if (strcmp((char*)field_name, \"config\") == 0) {",
          "945:       tokenlen = end_offset - offset;",
          "946:       format_specific_parameter = tvb_get_string(wmem_packet_scope(), tvb, offset, tokenlen);",
          "948:       data_tvb = ascii_bytes_to_tvb(tvb, pinfo, tokenlen, format_specific_parameter);",
          "949:       if (mp4ves_handle && data_tvb) {",
          "950:         dissect_mp4ves_config(data_tvb, pinfo, tree);",
          "951:       }",
          "952:     }",
          "953:   }",
          "956:   if (((mime_type != NULL) && (g_ascii_strcasecmp(mime_type, \"H263-2000\") == 0)) ||",
          "957:       ((mime_type != NULL) && (g_ascii_strcasecmp(mime_type, \"H263-1998\") == 0))) {",
          "958:     if (strcmp((char*)field_name, \"profile\") == 0) {",
          "959:       offset++;",
          "960:       tokenlen = end_offset - offset;",
          "961:       format_specific_parameter = tvb_get_string(wmem_packet_scope(), tvb, offset, tokenlen);",
          "962:       item = proto_tree_add_uint(tree, hf_sdp_fmtp_h263_profile, tvb, offset, tokenlen,",
          "963:                                  (guint32)strtol((char*)format_specific_parameter, NULL, 10));",
          "964:       PROTO_ITEM_SET_GENERATED(item);",
          "965:     } else if (strcmp((char*)field_name, \"level\") == 0) {",
          "966:       offset++;",
          "967:       tokenlen = end_offset - offset;",
          "968:       format_specific_parameter = tvb_get_string(wmem_packet_scope(), tvb, offset, tokenlen);",
          "969:       item = proto_tree_add_uint(tree, hf_sdp_fmtp_h263_level, tvb, offset, tokenlen,",
          "970:                                  (guint32)strtol((char*)format_specific_parameter, NULL, 10));",
          "971:       PROTO_ITEM_SET_GENERATED(item);",
          "972:     }",
          "973:   }",
          "988:   if ((mime_type != NULL) && (g_ascii_strcasecmp(mime_type, \"H264\") == 0)) {",
          "989:     if (strcmp(field_name, \"profile-level-id\") == 0) {",
          "990:       int length = 0;",
          "993:       tokenlen = end_offset - offset;",
          "994:       format_specific_parameter = tvb_get_string(wmem_packet_scope(), tvb, offset, tokenlen);",
          "995:       data_tvb = ascii_bytes_to_tvb(tvb, pinfo, tokenlen, format_specific_parameter);",
          "996:       if (!data_tvb) {",
          "997:         proto_tree_add_text(tree, tvb, offset, tokenlen, \"Could not convert '%s' to 3 bytes\", format_specific_parameter);",
          "998:         return;",
          "999:       }",
          "1000:       length = tvb_length(data_tvb);",
          "1001:       if (length == 3) {",
          "1002:         if (h264_handle && data_tvb) {",
          "1003:           dissect_h264_profile(data_tvb, pinfo, tree);",
          "1004:         }",
          "1005:       } else {",
          "1006:         item = proto_tree_add_text(tree, tvb, offset, tokenlen, \"Incorrectly coded, must be three bytes\");",
          "1007:         PROTO_ITEM_SET_GENERATED(item);",
          "1008:       }",
          "1009:     } else if (strcmp(field_name, \"packetization-mode\") == 0) {",
          "1010:       offset++;",
          "1011:       tokenlen = end_offset - offset;",
          "1012:       format_specific_parameter = tvb_get_string(wmem_packet_scope(), tvb, offset, tokenlen);",
          "1013:       item = proto_tree_add_uint(tree, hf_sdp_h264_packetization_mode, tvb, offset, tokenlen,",
          "1014:                                  (guint32)strtol((char*)format_specific_parameter, NULL, 10));",
          "1015:       PROTO_ITEM_SET_GENERATED(item);",
          "1016:     } else if (strcmp(field_name, \"sprop-parameter-sets\") == 0) {",
          "1018:          base64 [6] representation of the initial",
          "1019:          parameter set NAL units as specified in",
          "1020:          sections 7.3.2.1 and 7.3.2.2 of [1].  The",
          "1021:          parameter sets are conveyed in decoding order,",
          "1022:          and no framing of the parameter set NAL units",
          "1023:          takes place.  A comma is used to separate any",
          "1024:          pair of parameter sets in the list.",
          "1026:       gchar *data_p = NULL;",
          "1027:       gint   comma_offset;",
          "1031:       offset++;",
          "1032:       comma_offset = tvb_find_guint8(tvb, offset, -1, ',');",
          "1033:       if (comma_offset != -1) {",
          "1034:         tokenlen = comma_offset - offset;",
          "1035:       } else {",
          "1036:         tokenlen = end_offset - offset;",
          "1037:       }",
          "1039:       data_p = tvb_get_string(wmem_packet_scope(), tvb, offset, tokenlen);",
          "1040:       proto_tree_add_text(tree, tvb, offset, tokenlen, \"NAL unit 1 string: %s\", data_p);",
          "1043:       data_tvb = base64_to_tvb(tvb, data_p);",
          "1044:       add_new_data_source(pinfo, data_tvb, \"h264 prop-parameter-sets\");",
          "1046:       if (h264_handle && data_tvb) {",
          "1047:         TRY {",
          "1048:           dissect_h264_nal_unit(data_tvb, pinfo, tree);",
          "1050:         CATCH_NONFATAL_ERRORS {",
          "1051:           show_exception(tvb, pinfo, tree, EXCEPT_CODE, GET_MESSAGE);",
          "1053:         ENDTRY;",
          "1054:         if (comma_offset != -1) {",
          "1056:           offset   = comma_offset +1;",
          "1057:           tokenlen = end_offset - offset;",
          "1058:           data_p   = tvb_get_string(wmem_packet_scope(), tvb, offset, tokenlen);",
          "1059:           proto_tree_add_text(tree, tvb, offset, tokenlen, \"NAL unit 2 string: %s\", data_p);",
          "1060:           data_tvb = base64_to_tvb(tvb, data_p);",
          "1061:           add_new_data_source(pinfo, data_tvb, \"h264 prop-parameter-sets 2\");",
          "1062:           dissect_h264_nal_unit(data_tvb, pinfo, tree);",
          "1064:       }",
          "1066:   }",
          "",
          "[Added Lines]",
          "920:     next_offset = tvb_find_guint8(tvb, offset, -1, '=');",
          "921:     if (next_offset == -1)",
          "922:     {",
          "924:         return;",
          "925:     }",
          "928:     tokenlen = next_offset - offset;",
          "929:     field_name = tvb_get_string(wmem_packet_scope(), tvb, offset, tokenlen);",
          "933:     offset = next_offset;",
          "936:     if ((mime_type != NULL) && (g_ascii_strcasecmp(mime_type, \"MP4V-ES\") == 0)) {",
          "937:         if (strcmp((char*)field_name, \"profile-level-id\") == 0) {",
          "938:             offset++;",
          "939:             tokenlen = end_offset - offset;",
          "940:             format_specific_parameter = tvb_get_string(wmem_packet_scope(), tvb, offset, tokenlen);",
          "941:             item = proto_tree_add_uint(tree, hf_sdp_fmtp_mpeg4_profile_level_id, tvb, offset, tokenlen,",
          "942:                                        (guint32)strtol((char*)format_specific_parameter, NULL, 10));",
          "943:             PROTO_ITEM_SET_GENERATED(item);",
          "944:         } else if (strcmp((char*)field_name, \"config\") == 0) {",
          "946:             tokenlen = end_offset - offset;",
          "947:             format_specific_parameter = tvb_get_string(wmem_packet_scope(), tvb, offset, tokenlen);",
          "949:             data_tvb = ascii_bytes_to_tvb(tvb, pinfo, tokenlen, format_specific_parameter);",
          "950:             if (mp4ves_handle && data_tvb) {",
          "951:                 dissect_mp4ves_config(data_tvb, pinfo, tree);",
          "952:             }",
          "954:     }",
          "957:     if (((mime_type != NULL) && (g_ascii_strcasecmp(mime_type, \"H263-2000\") == 0)) ||",
          "958:         ((mime_type != NULL) && (g_ascii_strcasecmp(mime_type, \"H263-1998\") == 0))) {",
          "959:         if (strcmp((char*)field_name, \"profile\") == 0) {",
          "960:             offset++;",
          "961:             tokenlen = end_offset - offset;",
          "962:             format_specific_parameter = tvb_get_string(wmem_packet_scope(), tvb, offset, tokenlen);",
          "963:             item = proto_tree_add_uint(tree, hf_sdp_fmtp_h263_profile, tvb, offset, tokenlen,",
          "964:                                        (guint32)strtol((char*)format_specific_parameter, NULL, 10));",
          "965:             PROTO_ITEM_SET_GENERATED(item);",
          "966:         } else if (strcmp((char*)field_name, \"level\") == 0) {",
          "967:             offset++;",
          "968:             tokenlen = end_offset - offset;",
          "969:             format_specific_parameter = tvb_get_string(wmem_packet_scope(), tvb, offset, tokenlen);",
          "970:             item = proto_tree_add_uint(tree, hf_sdp_fmtp_h263_level, tvb, offset, tokenlen,",
          "971:                                        (guint32)strtol((char*)format_specific_parameter, NULL, 10));",
          "972:             PROTO_ITEM_SET_GENERATED(item);",
          "974:     }",
          "989:     if ((mime_type != NULL) && (g_ascii_strcasecmp(mime_type, \"H264\") == 0)) {",
          "990:         if (strcmp(field_name, \"profile-level-id\") == 0) {",
          "991:             int length = 0;",
          "994:             tokenlen = end_offset - offset;",
          "995:             format_specific_parameter = tvb_get_string(wmem_packet_scope(), tvb, offset, tokenlen);",
          "996:             data_tvb = ascii_bytes_to_tvb(tvb, pinfo, tokenlen, format_specific_parameter);",
          "997:             if (!data_tvb) {",
          "998:                 proto_tree_add_text(tree, tvb, offset, tokenlen, \"Could not convert '%s' to 3 bytes\", format_specific_parameter);",
          "999:                 return;",
          "1000:             }",
          "1001:             length = tvb_length(data_tvb);",
          "1002:             if (length == 3) {",
          "1003:                 if (h264_handle && data_tvb) {",
          "1004:                     dissect_h264_profile(data_tvb, pinfo, tree);",
          "1005:                 }",
          "1006:             } else {",
          "1007:                 item = proto_tree_add_text(tree, tvb, offset, tokenlen, \"Incorrectly coded, must be three bytes\");",
          "1008:                 PROTO_ITEM_SET_GENERATED(item);",
          "1009:             }",
          "1010:         } else if (strcmp(field_name, \"packetization-mode\") == 0) {",
          "1011:             offset++;",
          "1012:             tokenlen = end_offset - offset;",
          "1013:             format_specific_parameter = tvb_get_string(wmem_packet_scope(), tvb, offset, tokenlen);",
          "1014:             item = proto_tree_add_uint(tree, hf_sdp_h264_packetization_mode, tvb, offset, tokenlen,",
          "1015:                                        (guint32)strtol((char*)format_specific_parameter, NULL, 10));",
          "1016:             PROTO_ITEM_SET_GENERATED(item);",
          "1017:         } else if (strcmp(field_name, \"sprop-parameter-sets\") == 0) {",
          "1019:                base64 [6] representation of the initial",
          "1020:                parameter set NAL units as specified in",
          "1021:                sections 7.3.2.1 and 7.3.2.2 of [1].  The",
          "1022:                parameter sets are conveyed in decoding order,",
          "1023:                and no framing of the parameter set NAL units",
          "1024:                takes place.  A comma is used to separate any",
          "1025:                pair of parameter sets in the list.",
          "1027:             gchar *data_p = NULL;",
          "1028:             gint   comma_offset;",
          "1032:             offset++;",
          "1033:             comma_offset = tvb_find_guint8(tvb, offset, -1, ',');",
          "1034:             if (comma_offset != -1) {",
          "1035:                 tokenlen = comma_offset - offset;",
          "1036:             } else {",
          "1037:                 tokenlen = end_offset - offset;",
          "1038:             }",
          "1040:             data_p = tvb_get_string(wmem_packet_scope(), tvb, offset, tokenlen);",
          "1041:             proto_tree_add_text(tree, tvb, offset, tokenlen, \"NAL unit 1 string: %s\", data_p);",
          "1044:             data_tvb = base64_to_tvb(tvb, data_p);",
          "1045:             add_new_data_source(pinfo, data_tvb, \"h264 prop-parameter-sets\");",
          "1047:             if (h264_handle && data_tvb) {",
          "1048:                 TRY {",
          "1049:                     dissect_h264_nal_unit(data_tvb, pinfo, tree);",
          "1050:                 }",
          "1051:                 CATCH_NONFATAL_ERRORS {",
          "1052:                     show_exception(tvb, pinfo, tree, EXCEPT_CODE, GET_MESSAGE);",
          "1053:                 }",
          "1054:                 ENDTRY;",
          "1055:                 if (comma_offset != -1) {",
          "1057:                     offset   = comma_offset +1;",
          "1058:                     tokenlen = end_offset - offset;",
          "1059:                     data_p   = tvb_get_string(wmem_packet_scope(), tvb, offset, tokenlen);",
          "1060:                     proto_tree_add_text(tree, tvb, offset, tokenlen, \"NAL unit 2 string: %s\", data_p);",
          "1061:                     data_tvb = base64_to_tvb(tvb, data_p);",
          "1062:                     add_new_data_source(pinfo, data_tvb, \"h264 prop-parameter-sets 2\");",
          "1063:                     dissect_h264_nal_unit(data_tvb, pinfo, tree);",
          "1064:                 }",
          "1065:             }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1079: #define SDP_SPRTMAP             6",
          "1081: static const sdp_names_t sdp_media_attribute_names[] = {",
          "1089: };",
          "1091: static gint find_sdp_media_attribute_names(tvbuff_t *tvb, int offset, guint len)",
          "1092: {",
          "1102: }",
          "1104: static void dissect_sdp_media_attribute(tvbuff_t *tvb, packet_info *pinfo, proto_item * ti, int length,",
          "1105:                                         transport_info_t *transport_info, disposable_media_info_t *media_info) {",
          "1161:       return;",
          "1554: }",
          "1556: static void",
          "1557: call_sdp_subdissector(tvbuff_t *tvb, packet_info *pinfo, int hf, proto_tree* ti, int length,",
          "1558:                       transport_info_t *transport_info, disposable_media_info_t *media_info) {",
          "1580: }",
          "1582: static void",
          "1583: convert_disposable_media(transport_info_t* transport_info, disposable_media_info_t* media_info,",
          "1584:                          gint start_transport_info_count)",
          "1585: {",
          "1624:         }",
          "1630:         }",
          "1641:           }",
          "1642:         }",
          "1655:         }",
          "1681:     }",
          "1683: }",
          "1685: void",
          "1686: setup_sdp_transport(tvbuff_t *tvb, packet_info *pinfo, enum sdp_exchange_type exchange_type, int request_frame)",
          "1687: {",
          "1721:     if (request_frame != 0)",
          "1789:     }",
          "1798:     }",
          "1834:             }",
          "1902:         {",
          "1905:         }",
          "1913:         {",
          "1916:         }",
          "1936: }",
          "1938: void setup_sdp_transport_resend(int current_frame, int request_frame)",
          "1939: {",
          "1946:     }",
          "1948: }",
          "1950: static void",
          "1951: dissect_sdp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)",
          "1952: {",
          "2193:         }",
          "2210:     }",
          "2220:     }",
          "2251:             if (strlen(sdp_pi->summary_str))",
          "2261:         }",
          "2263:     }",
          "2282:     }",
          "2295:     }",
          "2304: }",
          "2306: void",
          "2307: proto_register_sdp(void)",
          "2308: {",
          "2716: }",
          "2718: void",
          "2719: proto_reg_handoff_sdp(void)",
          "2720: {",
          "2734: }",
          "",
          "[Removed Lines]",
          "1093:   guint i;",
          "1095:   for (i = 1; i < array_length(sdp_media_attribute_names); i++) {",
          "1096:     if ((len == strlen(sdp_media_attribute_names[i].name)) &&",
          "1097:         (tvb_strncaseeql(tvb, offset, sdp_media_attribute_names[i].name, len) == 0))",
          "1098:       return i;",
          "1099:   }",
          "1101:   return -1;",
          "1106:   proto_tree *sdp_media_attribute_tree, *parameter_item;",
          "1107:   proto_item *fmtp_item, *media_format_item, *parameter_tree;",
          "1108:   proto_tree *fmtp_tree;",
          "1109:   gint        offset, next_offset, tokenlen, n, colon_offset;",
          "1111:   guint8     *payload_type;",
          "1112:   guint8     *attribute_value;",
          "1113:   gint       *key;",
          "1114:   guint8      pt;",
          "1115:   gint        sdp_media_attrbute_code;",
          "1116:   const char *msrp_res           = \"msrp://\";",
          "1117:   const char *h324ext_h223lcparm = \"h324ext/h223lcparm\";",
          "1118:   gboolean    has_more_pars      = TRUE;",
          "1119:   tvbuff_t   *h245_tvb;",
          "1120:   guint8      master_key_length  = 0, master_salt_length = 0;",
          "1121:   encoding_name_and_rate_t *encoding_name_and_rate;",
          "1123:   offset = 0;",
          "1126:   sdp_media_attribute_tree = proto_item_add_subtree(ti,",
          "1127:                                                     ett_sdp_media_attribute);",
          "1129:   colon_offset = tvb_find_guint8(tvb, offset, -1, ':');",
          "1131:   if (colon_offset == -1)",
          "1132:     return;",
          "1135:   tokenlen = colon_offset - offset;",
          "1136:   proto_tree_add_item(sdp_media_attribute_tree,",
          "1137:                       hf_media_attribute_field,",
          "1138:                       tvb, offset, tokenlen, ENC_ASCII|ENC_NA);",
          "1140:   sdp_media_attrbute_code = find_sdp_media_attribute_names(tvb, offset, tokenlen);",
          "1143:   offset = colon_offset + 1;",
          "1145:   offset = tvb_skip_wsp(tvb, offset, tvb_length_remaining(tvb, offset));",
          "1148:   attribute_value = tvb_get_string(wmem_packet_scope(), tvb, offset, tvb_length_remaining(tvb, offset));",
          "1155:   switch (sdp_media_attrbute_code) {",
          "1156:   case SDP_RTPMAP:",
          "1158:     next_offset = tvb_find_guint8(tvb, offset, -1, ' ');",
          "1160:     if (next_offset == -1)",
          "1163:     tokenlen = next_offset - offset;",
          "1165:     proto_tree_add_item(sdp_media_attribute_tree, hf_media_format, tvb,",
          "1166:                         offset, tokenlen, ENC_ASCII|ENC_NA);",
          "1168:     payload_type = tvb_get_string(wmem_packet_scope(), tvb, offset, tokenlen);",
          "1170:     offset = next_offset + 1;",
          "1172:     next_offset = tvb_find_guint8(tvb, offset, -1, '/');",
          "1174:     if (next_offset == -1) {",
          "1175:       return;",
          "1176:     }",
          "1178:     tokenlen = next_offset - offset;",
          "1180:     proto_tree_add_item(sdp_media_attribute_tree, hf_media_encoding_name, tvb,",
          "1181:                         offset, tokenlen, ENC_ASCII|ENC_NA);",
          "1183:     pt = atoi((char*)payload_type);",
          "1184:     if (pt >= SDP_NO_OF_PT) {",
          "1186:     }",
          "1188:     key  = wmem_new(wmem_file_scope(), gint);",
          "1191:     transport_info->encoding_name[pt] = (char*)tvb_get_string(wmem_packet_scope(), tvb, offset, tokenlen);",
          "1193:     next_offset =  next_offset + 1;",
          "1194:     offset = next_offset;",
          "1195:     while (length-1 >= next_offset) {",
          "1196:       if (!g_ascii_isdigit(tvb_get_guint8(tvb, next_offset)))",
          "1197:         break;",
          "1198:       next_offset++;",
          "1199:     }",
          "1200:     tokenlen = next_offset - offset;",
          "1201:     proto_tree_add_item(sdp_media_attribute_tree, hf_media_sample_rate, tvb,",
          "1202:                         offset, tokenlen, ENC_ASCII|ENC_NA);",
          "1203:     transport_info->sample_rate[pt] = atoi(tvb_get_string(wmem_packet_scope(), tvb, offset, tokenlen));",
          "1205:        For example:",
          "1207:        a=rtpmap:101 G726-32/8000",
          "1208:        m=audio 49170 RTP/AVP 0 97",
          "1209:        a=rtpmap:97 telephone-event/8000",
          "1210:        m=audio 49172 RTP/AVP 97 101",
          "1211:        a=rtpmap:97 G726-24/8000",
          "1213:        The Media attributes (\"a=\"s) after the \"m=\" only apply for that \"m=\".",
          "1214:        If there is an \"a=\" before the first \"m=\", that attribute applies for",
          "1215:        all the session (all the \"m=\"s).",
          "1221:     if (transport_info->media_count < 0) {",
          "1222:       for (n = 0; n < SDP_MAX_RTP_CHANNELS; n++) {",
          "1223:         encoding_name_and_rate = wmem_new(wmem_file_scope(), encoding_name_and_rate_t);",
          "1224:         encoding_name_and_rate->encoding_name = wmem_strdup(wmem_file_scope(), transport_info->encoding_name[pt]);",
          "1225:         encoding_name_and_rate->sample_rate = transport_info->sample_rate[pt];",
          "1226:         if (n == 0) {",
          "1227:           g_hash_table_insert(transport_info->media[n].rtp_dyn_payload,",
          "1228:                               key, encoding_name_and_rate);",
          "1230:           gint *key2;",
          "1231:           key2  = wmem_new(wmem_file_scope(), gint);",
          "1233:           g_hash_table_insert(transport_info->media[n].rtp_dyn_payload,",
          "1234:                               key2, encoding_name_and_rate);",
          "1235:         }",
          "1236:       }",
          "1237:       return;",
          "1239:     } else",
          "1241:       encoding_name_and_rate = wmem_new(wmem_file_scope(), encoding_name_and_rate_t);",
          "1243:     encoding_name_and_rate->encoding_name = wmem_strdup(wmem_file_scope(), transport_info->encoding_name[pt]);",
          "1244:     encoding_name_and_rate->sample_rate   = transport_info->sample_rate[pt];",
          "1245:     g_hash_table_insert(transport_info->media[ transport_info->media_count ].rtp_dyn_payload,",
          "1246:                           key, encoding_name_and_rate);",
          "1247:     break;",
          "1248:   case SDP_FMTP:",
          "1249:     if (sdp_media_attribute_tree) {",
          "1250:       guint8 media_format;",
          "1253:       offset = tvb_skip_wsp(tvb, offset, tvb_length_remaining(tvb, offset));",
          "1255:       next_offset = tvb_find_guint8(tvb, offset, -1, ' ');",
          "1257:       if (next_offset == -1)",
          "1258:         return;",
          "1260:       tokenlen = next_offset - offset;",
          "1263:       media_format_item = proto_tree_add_item(sdp_media_attribute_tree,",
          "1264:                                               hf_media_format, tvb, offset,",
          "1265:                                               tokenlen, ENC_ASCII|ENC_NA);",
          "1266:       media_format = atoi((char*)tvb_get_string(wmem_packet_scope(), tvb, offset, tokenlen));",
          "1267:       if (media_format >= SDP_NO_OF_PT) {",
          "1269:       }",
          "1272:       proto_item_append_text(media_format_item, \" [%s]\",",
          "1273:                              transport_info->encoding_name[media_format]);",
          "1276:       payload_type = tvb_get_string(wmem_packet_scope(), tvb, offset, tokenlen);",
          "1277: #endif",
          "1279:       offset = next_offset + 1;",
          "1281:       while (has_more_pars == TRUE) {",
          "1282:         next_offset = tvb_find_guint8(tvb, offset, -1, ';');",
          "1283:         offset = tvb_skip_wsp(tvb, offset, tvb_length_remaining(tvb, offset));",
          "1285:         if (next_offset == -1) {",
          "1286:           has_more_pars = FALSE;",
          "1287:           next_offset= tvb_length(tvb);",
          "1288:         }",
          "1291:         tokenlen = next_offset - offset;",
          "1292:         fmtp_item = proto_tree_add_item(sdp_media_attribute_tree,",
          "1293:                                         hf_media_format_specific_parameter, tvb,",
          "1294:                                         offset, tokenlen, ENC_ASCII|ENC_NA);",
          "1296:         fmtp_tree = proto_item_add_subtree(fmtp_item, ett_sdp_fmtp);",
          "1298:         decode_sdp_fmtp(fmtp_tree, tvb, pinfo, offset, tokenlen,",
          "1299:                         transport_info->encoding_name[media_format]);",
          "1302:         offset = next_offset + 1;",
          "1303:       }",
          "1304:     }",
          "1305:     break;",
          "1306:   case SDP_PATH:",
          "1324:     if (strncmp((char*)attribute_value, msrp_res, strlen(msrp_res)) == 0) {",
          "1325:       int address_offset, port_offset, port_end_offset;",
          "1328:       address_offset = offset + (int)strlen(msrp_res);",
          "1331:       port_offset = tvb_find_guint8(tvb, address_offset, -1, ':');",
          "1333:       if (port_offset!= -1) {",
          "1335:         port_end_offset = tvb_find_guint8(tvb, port_offset, -1, '/');",
          "1336:         if (port_end_offset == -1) {",
          "1338:             port_end_offset = tvb_find_guint8(tvb, port_offset, -1, ';');",
          "1339:         }",
          "1341:         if (str_to_ip((char*)tvb_get_string(wmem_packet_scope(), tvb, address_offset, port_offset-address_offset),",
          "1342:                        &media_info->msrp_ipaddr)) {",
          "1344:           media_info->msrp_port_number = atoi((char*)tvb_get_string(wmem_packet_scope(), tvb, port_offset + 1, port_end_offset - port_offset - 1));",
          "1346:           media_info->msrp_transport_address_set = TRUE;",
          "1347:         }",
          "1348:       }",
          "1349:     }",
          "1350:     break;",
          "1351:   case SDP_H248_ITEM:",
          "1353:     if (strncmp((char*)attribute_value, h324ext_h223lcparm, strlen(msrp_res)) == 0) {",
          "1360:       gint len;",
          "1361:       asn1_ctx_t actx;",
          "1363:       len = (gint)strlen(attribute_value);",
          "1364:       h245_tvb = ascii_bytes_to_tvb(tvb, pinfo, len, attribute_value);",
          "1367:          points are different, one is over tpkt and the other is raw",
          "1369:       if (h245_tvb) {",
          "1370:         asn1_ctx_init(&actx, ASN1_ENC_PER, TRUE, pinfo);",
          "1371:         dissect_h245_H223LogicalChannelParameters(h245_tvb, 0, &actx,",
          "1372:                                                   sdp_media_attribute_tree,",
          "1373:                                                   hf_SDPh223LogicalChannelParameters);",
          "1374:       }",
          "1375:     }",
          "1376:     break;",
          "1377:   case SDP_CRYPTO:",
          "1403:       next_offset = tvb_find_guint8(tvb, offset, -1, ' ');",
          "1404:       if(next_offset==-1){",
          "1406:           return;",
          "1407:       }",
          "1408:       tokenlen    = next_offset - offset;",
          "1409:       proto_tree_add_uint(sdp_media_attribute_tree, hf_sdp_crypto_tag, tvb, offset, tokenlen,",
          "1410:           atoi((char*)tvb_get_string(wmem_packet_scope(), tvb, offset, tokenlen)));",
          "1411:       offset = next_offset + 1;",
          "1414:       next_offset = tvb_find_guint8(tvb, offset, -1, ' ');",
          "1415:       if(next_offset==-1){",
          "1417:           return;",
          "1418:       }",
          "1419:       tokenlen    = next_offset - offset;",
          "1420:       parameter_item = proto_tree_add_item(sdp_media_attribute_tree, hf_sdp_crypto_crypto_suite,",
          "1421:           tvb, offset, tokenlen, ENC_ASCII|ENC_NA);",
          "1422:       if (tvb_strncaseeql(tvb, offset, \"AES_CM_128_HMAC_SHA1_80\", tokenlen) == 0) {",
          "1425:           if (transport_info->encryption_algorithm == SRTP_ENC_ALG_NOT_SET) {",
          "1426:               transport_info->encryption_algorithm = SRTP_ENC_ALG_AES_CM;",
          "1427:               transport_info->auth_algorithm       = SRTP_AUTH_ALG_HMAC_SHA1;",
          "1429:               transport_info->auth_tag_len         = 10;",
          "1430:           }",
          "1433:       } else if (tvb_strncaseeql(tvb, offset, \"AES_CM_128_HMAC_SHA1_32\", tokenlen) == 0) {",
          "1435:           if (transport_info->encryption_algorithm == SRTP_ENC_ALG_NOT_SET) {",
          "1436:               transport_info->encryption_algorithm = SRTP_ENC_ALG_AES_CM;",
          "1437:               transport_info->auth_algorithm       = SRTP_AUTH_ALG_HMAC_SHA1;",
          "1439:               transport_info->auth_tag_len         = 4;",
          "1440:           }",
          "1443:       } else if (tvb_strncaseeql(tvb, offset, \"F8_128_HMAC_SHA1_80\", tokenlen) == 0) {",
          "1444:           if (transport_info->encryption_algorithm == SRTP_ENC_ALG_NOT_SET) {",
          "1446:               transport_info->encryption_algorithm = SRTP_ENC_ALG_AES_F8;",
          "1447:               transport_info->auth_algorithm       = SRTP_AUTH_ALG_HMAC_SHA1;",
          "1449:               transport_info->auth_tag_len         = 10;",
          "1450:           }",
          "1453:       }",
          "1454:       offset = next_offset + 1;",
          "1457:       while (has_more_pars == TRUE) {",
          "1458:           int       param_end_offset;",
          "1459:           tvbuff_t *key_salt_tvb;",
          "1460:           gchar    *data_p = NULL;",
          "1462:           param_end_offset = tvb_find_guint8(tvb, offset, -1, ';');",
          "1463:           if (param_end_offset == -1) {",
          "1464:               has_more_pars = FALSE;",
          "1465:               param_end_offset = tvb_length(tvb);",
          "1466:           }",
          "1468:           next_offset = tvb_find_guint8(tvb, offset, -1, ':');",
          "1469:           if (next_offset == -1) {",
          "1470:               expert_add_info(pinfo, parameter_item, &ei_sdp_invalid_key_param);",
          "1471:               break;",
          "1472:           }",
          "1474:           if (tvb_strncaseeql(tvb, offset, \"inline\", next_offset-offset) == 0) {",
          "1475:               parameter_item = proto_tree_add_text(sdp_media_attribute_tree,",
          "1476:                   tvb, offset, param_end_offset-offset, \"Key parameters\");",
          "1477:               parameter_tree = proto_item_add_subtree(parameter_item, ett_sdp_crypto_key_parameters);",
          "1480:               offset      = next_offset +1;",
          "1481:               next_offset = tvb_find_guint8(tvb, offset, -1, '|');",
          "1482:               if (next_offset == -1) {",
          "1483:                   tokenlen = param_end_offset - offset;",
          "1484:               } else {",
          "1485:                   tokenlen = next_offset - offset;",
          "1486:               }",
          "1487:               data_p = tvb_get_string(wmem_packet_scope(), tvb, offset, tokenlen);",
          "1488:               key_salt_tvb = base64_to_tvb(tvb, data_p);",
          "1489:               add_new_data_source(pinfo, key_salt_tvb, \"Key_Salt_tvb\");",
          "1490:               if (master_key_length != 0) {",
          "1491:                   proto_tree_add_text(parameter_tree, tvb, offset, tokenlen, \"Key and Salt\");",
          "1492:                   proto_tree_add_item(parameter_tree, hf_sdp_crypto_master_key,",
          "1493:                       key_salt_tvb, 0, master_key_length, ENC_ASCII|ENC_NA);",
          "1494:                   proto_tree_add_item(parameter_tree, hf_sdp_crypto_master_salt,",
          "1495:                       key_salt_tvb, master_key_length, master_salt_length, ENC_ASCII|ENC_NA);",
          "1496:               } else {",
          "1497:                   proto_tree_add_text(parameter_tree, key_salt_tvb, 0, -1, \"Key and Salt\");",
          "1498:               }",
          "1501:               if (next_offset != -1) {",
          "1502:                   offset = next_offset + 1;",
          "1503:                   next_offset = tvb_find_guint8(tvb, offset, -1, '|');",
          "1504:                   if(next_offset == -1){",
          "1505:                       if(next_offset < param_end_offset){",
          "1506:                           next_offset = param_end_offset;",
          "1507:                       }",
          "1508:                   }",
          "1509:                   if (next_offset != -1) {",
          "1511:                       tokenlen = next_offset - offset;",
          "1512:                       proto_tree_add_item(parameter_tree, hf_sdp_crypto_lifetime,",
          "1513:                           tvb, offset, tokenlen, ENC_ASCII|ENC_NA);",
          "1514:                       offset   = next_offset + 1;",
          "1515:                   }",
          "1520:                   if(offset>param_end_offset){",
          "1521:                       next_offset = -1;",
          "1522:                   }else{",
          "1523:                       next_offset = tvb_find_guint8(tvb, offset, -1, ':');",
          "1524:                   }",
          "1525:                   if (next_offset != -1) {",
          "1526:                       tokenlen    = next_offset - offset;",
          "1527:                       proto_tree_add_item(parameter_tree, hf_sdp_crypto_mki, tvb, offset, tokenlen, ENC_ASCII|ENC_NA);",
          "1528:                       offset      = next_offset + 1;",
          "1531:                       next_offset = param_end_offset;",
          "1532:                       tokenlen    = next_offset - offset;",
          "1536:                       transport_info->mki_len = atoi((char*)tvb_get_string(wmem_packet_scope(), tvb, offset, tokenlen));",
          "1537:                       proto_tree_add_item(parameter_tree, hf_sdp_crypto_mki_length,",
          "1538:                           tvb, offset, tokenlen, ENC_ASCII|ENC_NA);",
          "1539:                   }",
          "1540:               }",
          "1541:               offset = param_end_offset;",
          "1542:           } else {",
          "1543:               break;",
          "1544:           }",
          "1545:       }",
          "1547:     break;",
          "1548:   default:",
          "1550:     proto_tree_add_item(sdp_media_attribute_tree, hf_media_attribute_value,",
          "1551:                         tvb, offset, -1, ENC_ASCII|ENC_NA);",
          "1552:     break;",
          "1553:   }",
          "1559:   if (hf == hf_owner) {",
          "1560:     dissect_sdp_owner(tvb, ti);",
          "1561:   } else if (hf == hf_connection_info) {",
          "1562:     dissect_sdp_connection_info(tvb, ti, media_info);",
          "1563:   } else if (hf == hf_bandwidth) {",
          "1564:     dissect_sdp_bandwidth(tvb, ti);",
          "1565:   } else if (hf == hf_time) {",
          "1566:     dissect_sdp_time(tvb, ti);",
          "1567:   } else if (hf == hf_repeat_time) {",
          "1568:     dissect_sdp_repeat_time(tvb, ti);",
          "1569:   } else if (hf == hf_timezone) {",
          "1570:     dissect_sdp_timezone(tvb, ti);",
          "1571:   } else if (hf == hf_encryption_key) {",
          "1572:     dissect_sdp_encryption_key(tvb, ti);",
          "1573:   } else if (hf == hf_session_attribute) {",
          "1574:     dissect_sdp_session_attribute(tvb, pinfo, ti);",
          "1575:   } else if (hf == hf_media) {",
          "1576:     dissect_sdp_media(tvb, ti, transport_info, media_info);",
          "1577:   } else if (hf == hf_media_attribute) {",
          "1578:     dissect_sdp_media_attribute(tvb, pinfo, ti, length, transport_info, media_info);",
          "1579:   }",
          "1586:   gint8 n, transport_index;",
          "1587:   guint proto_bitmask;",
          "1589:   for (n = 0; (n < media_info->media_count) && (n+start_transport_info_count < SDP_MAX_RTP_CHANNELS); n++)",
          "1590:   {",
          "1591:     transport_index = n+start_transport_info_count;",
          "1592:     if (media_info->media_port[n] != NULL) {",
          "1593:       transport_info->media_port[transport_index] = (int)strtol(media_info->media_port[n], NULL, 10);",
          "1594:     }",
          "1596:     if (media_info->media_proto[n] != NULL) {",
          "1600:       if (global_sdp_establish_conversation) {",
          "1601:         proto_bitmask = 0;",
          "1605:         if (!strcmp(media_info->media_proto[n],\"RTP/AVP\")) {",
          "1606:           transport_info->proto_bitmask[transport_index] |= SDP_RTP_PROTO;",
          "1607:           proto_bitmask |= SDP_RTP_PROTO;",
          "1608:         }",
          "1610:         else if (!strcmp(media_info->media_proto[n],\"RTP/SAVP\")) {",
          "1611:           transport_info->proto_bitmask[transport_index] |= SDP_SRTP_PROTO;",
          "1612:           proto_bitmask |= SDP_SRTP_PROTO;",
          "1613:         }",
          "1615:         else if ((!strcmp(media_info->media_proto[n],\"UDPTL\")) ||",
          "1616:             (!strcmp(media_info->media_proto[n],\"udptl\"))) {",
          "1617:           transport_info->proto_bitmask[transport_index] |= SDP_T38_PROTO;",
          "1618:           proto_bitmask |= SDP_T38_PROTO;",
          "1619:         }",
          "1621:         else if (!strcmp(media_info->media_proto[n],\"msrp/tcp\")) {",
          "1622:           transport_info->proto_bitmask[transport_index] |= SDP_MSRP_PROTO;",
          "1623:           proto_bitmask |= SDP_MSRP_PROTO;",
          "1626:         else if ((!strcmp(media_info->media_proto[n],\"UDPSPRT\")) ||",
          "1627:             (!strcmp(media_info->media_proto[n],\"udpsprt\"))) {",
          "1628:           transport_info->proto_bitmask[transport_index] |= SDP_SPRT_PROTO;",
          "1629:           proto_bitmask |= SDP_SPRT_PROTO;",
          "1633:         if (transport_info->media_port[transport_index] == 0) {",
          "1635:              basically start_transport_info_count is 0 for the offer, and >0 for the answer, so we",
          "1636:              check that and if this is the answer, then we go set the offer's paired stream to 0.",
          "1637:              If it turns out we got a port=0 in the offer, we don't care and it's ok to let the",
          "1639:           if (start_transport_info_count > 0 && (proto_bitmask & transport_info->proto_bitmask[n])) {",
          "1640:             transport_info->media_port[n] = 0;",
          "1643:       }",
          "1644:     }",
          "1646:     if ((media_info->connection_address != NULL) &&",
          "1647:         (media_info->connection_type != NULL)) {",
          "1648:       if (strcmp(media_info->connection_type, \"IP4\") == 0) {",
          "1649:         transport_info->src_addr[transport_index].data = wmem_alloc(wmem_file_scope(), 4);",
          "1650:         if (str_to_ip(media_info->connection_address, (void*)transport_info->src_addr[transport_index].data)) {",
          "1652:           transport_info->proto_bitmask[transport_index] |= SDP_IPv4;",
          "1653:           transport_info->src_addr[transport_index].type = AT_IPv4;",
          "1654:           transport_info->src_addr[transport_index].len  = 4;",
          "1656:       } else if (strcmp(media_info->connection_type, \"IP6\") == 0) {",
          "1657:           transport_info->src_addr[transport_index].data = wmem_alloc(wmem_file_scope(), 16);",
          "1658:           if (str_to_ip6(media_info->connection_address, (void*)transport_info->src_addr[transport_index].data)) {",
          "1660:             transport_info->proto_bitmask[transport_index] |= SDP_IPv6;",
          "1661:             transport_info->src_addr[transport_index].type = AT_IPv6;",
          "1662:             transport_info->src_addr[transport_index].len  = 16;",
          "1663:           }",
          "1664:       }",
          "1665:     }",
          "1669:     if ((transport_info->proto_bitmask[transport_index] & SDP_MSRP_PROTO) &&",
          "1670:         (transport_info->proto_bitmask[transport_index] & SDP_MSRP_IPv4) &&",
          "1671:         msrp_handle) {",
          "1672:        transport_info->src_addr[transport_index].type = AT_IPv4;",
          "1673:        transport_info->src_addr[transport_index].len  = 4;",
          "1674:        transport_info->src_addr[transport_index].data = wmem_memdup(wmem_file_scope(), media_info->msrp_ipaddr, 4);",
          "1675:        transport_info->media_port[transport_index] = media_info->msrp_port_number;",
          "1676:     }",
          "1678:     if ((media_info->media_type[transport_index] != NULL) &&",
          "1679:         (strcmp(media_info->media_type[transport_index], \"video\") == 0)) {",
          "1680:       transport_info->proto_bitmask[transport_index] |= SDP_VIDEO;",
          "1682:   }",
          "1688:   gint        offset = 0, next_offset, n;",
          "1689:   int         linelen;",
          "1690:   gboolean    in_media_description = FALSE;",
          "1691:   guchar      type, delim;",
          "1692:   const int   tokenoffset = 2;",
          "1693:   int         hf     = -1;",
          "1694:   gint        start_transport_info_count = 0;",
          "1695:   transport_info_t* transport_info = NULL;",
          "1696:   disposable_media_info_t media_info;",
          "1698:   struct srtp_info *srtp_info = NULL;",
          "1701:   if (pinfo->fd->flags.visited)",
          "1702:      return;",
          "1704:   memset(&media_info, 0, sizeof(media_info));",
          "1706:   if (request_frame != 0)",
          "1707:     transport_info = (transport_info_t*)wmem_tree_lookup32( sdp_transport_reqs, request_frame );",
          "1708:   if (transport_info == NULL) {",
          "1709:     transport_info = wmem_new0(wmem_file_scope(), transport_info_t);",
          "1710:     transport_info->media_count = -1;",
          "1712:     for (n = 0; n < SDP_NO_OF_PT; n++) {",
          "1713:       transport_info->encoding_name[n] = (char*)UNKNOWN_ENCODING;",
          "1714:     }",
          "1715:     for (n = 0; n < SDP_MAX_RTP_CHANNELS; n++) {",
          "1716:       transport_info->media[n].rtp_dyn_payload =",
          "1717:           g_hash_table_new(g_int_hash, g_int_equal);",
          "1718:       transport_info->media[n].set_rtp = FALSE;",
          "1719:     }",
          "1722:       wmem_tree_insert32(sdp_transport_reqs, request_frame, (void *)transport_info);",
          "1723:   }",
          "1725:   if (exchange_type != SDP_EXCHANGE_OFFER)",
          "1726:     wmem_tree_insert32(sdp_transport_rsps, pinfo->fd->num, (void *)transport_info);",
          "1731:   if ((transport_info->sdp_status == SDP_EXCHANGE_ANSWER_REJECT) ||",
          "1732:       (transport_info->sdp_status == SDP_EXCHANGE_ANSWER_ACCEPT))",
          "1733:       return;",
          "1735:   if (transport_info->media_count > 0)",
          "1736:     start_transport_info_count = transport_info->media_count;",
          "1741:   while (tvb_reported_length_remaining(tvb, offset) > 0) {",
          "1745:     linelen = tvb_find_line_end_unquoted(tvb, offset, -1, &next_offset);",
          "1750:     if (linelen < 2)",
          "1751:       break;",
          "1753:     type  = tvb_get_guint8(tvb, offset);",
          "1754:     delim = tvb_get_guint8(tvb, offset + 1);",
          "1755:     if (delim != '=') {",
          "1756:       offset = next_offset;",
          "1757:       continue;",
          "1758:     }",
          "1763:     switch (type) {",
          "1764:     case 'c':",
          "1765:       hf = hf_connection_info;",
          "1766:       break;",
          "1767:     case 'm':",
          "1768:       hf = hf_media;",
          "1771:       if (((transport_info->media_count < 0) && (in_media_description == FALSE)) || (transport_info->media_count < (SDP_MAX_RTP_CHANNELS-1)))",
          "1772:         transport_info->media_count++;",
          "1774:       if (in_media_description && (media_info.media_count < (SDP_MAX_RTP_CHANNELS-1)))",
          "1775:         media_info.media_count++;",
          "1777:       in_media_description = TRUE;",
          "1778:       break;",
          "1779:     case 'a':",
          "1780:       if (in_media_description) {",
          "1781:         hf = hf_media_attribute;",
          "1782:       } else {",
          "1783:         hf = hf_session_attribute;",
          "1784:       }",
          "1785:       break;",
          "1786:     default:",
          "1787:       hf = hf_unknown;",
          "1788:       break;",
          "1791:     if (hf != hf_unknown)",
          "1792:     {",
          "1793:       call_sdp_subdissector(tvb_new_subset(tvb, offset + tokenoffset,",
          "1794:                                              linelen - tokenoffset,",
          "1795:                                              linelen - tokenoffset),",
          "1796:                               pinfo,",
          "1797:                               hf, NULL, linelen-tokenoffset, transport_info, &media_info);",
          "1800:     offset = next_offset;",
          "1801:   }",
          "1803:   if (in_media_description) {",
          "1805:     if (transport_info->media_count < (SDP_MAX_RTP_CHANNELS-1))",
          "1806:       transport_info->media_count++;",
          "1807:     if (media_info.media_count < (SDP_MAX_RTP_CHANNELS-1))",
          "1808:       media_info.media_count++;",
          "1809:   }",
          "1814:   convert_disposable_media(transport_info, &media_info, start_transport_info_count);",
          "1817:   if ((exchange_type == SDP_EXCHANGE_ANSWER_ACCEPT) &&",
          "1818:       (transport_info->sdp_status == SDP_EXCHANGE_OFFER)) {",
          "1819:     for (n = 0; n <= transport_info->media_count; n++) {",
          "1820:       guint32 current_rtp_port = 0;",
          "1823:       if ((transport_info->media_port[n] != 0) &&",
          "1824:           (transport_info->proto_bitmask[n] & (SDP_RTP_PROTO|SDP_SRTP_PROTO)) &&",
          "1825:           (transport_info->proto_bitmask[n] & (SDP_IPv4|SDP_IPv6))) {",
          "1826:         if (transport_info->proto_bitmask[n] & SDP_SRTP_PROTO) {",
          "1827:             srtp_info = wmem_new0(wmem_file_scope(), struct srtp_info);",
          "1828:             if (transport_info->encryption_algorithm != SRTP_ENC_ALG_NOT_SET) {",
          "1829:               srtp_info->encryption_algorithm = transport_info->encryption_algorithm;",
          "1830:               srtp_info->auth_algorithm       = transport_info->auth_algorithm;",
          "1831:               srtp_info->mki_len              = transport_info->mki_len;",
          "1832:               srtp_info->auth_tag_len         = transport_info->auth_tag_len;",
          "1837:             srtp_add_address(pinfo, &transport_info->src_addr[n], transport_info->media_port[n], 0, \"SDP\", request_frame,",
          "1838:                             (transport_info->proto_bitmask[n] & SDP_VIDEO) ? TRUE : FALSE,",
          "1839:                              transport_info->media[n].rtp_dyn_payload, srtp_info);",
          "1840:         } else {",
          "1841:             rtp_add_address(pinfo, &transport_info->src_addr[n], transport_info->media_port[n], 0, \"SDP\", request_frame,",
          "1842:                             (transport_info->proto_bitmask[n] & SDP_VIDEO) ? TRUE : FALSE,",
          "1843:                             transport_info->media[n].rtp_dyn_payload);",
          "1844:         }",
          "1845:         transport_info->media[n].set_rtp = TRUE;",
          "1847:         current_rtp_port = transport_info->media_port[n];",
          "1849:         if (rtcp_handle) {",
          "1850:           if (transport_info->proto_bitmask[n] & SDP_SRTP_PROTO) {",
          "1851:             srtcp_add_address(pinfo, &transport_info->src_addr[n], transport_info->media_port[n]+1, 0, \"SDP\", request_frame, srtp_info);",
          "1852:           } else {",
          "1853:             rtcp_add_address(pinfo, &transport_info->src_addr[n], transport_info->media_port[n]+1, 0, \"SDP\", request_frame);",
          "1854:           }",
          "1855:         }",
          "1856:       }",
          "1859:       if ((transport_info->proto_bitmask[n] & SDP_SPRT_PROTO) &&",
          "1860:           (transport_info->proto_bitmask[n] & (SDP_IPv4|SDP_IPv6)) &&",
          "1861:           (sprt_handle)) {",
          "1863:         if (transport_info->media_port[n] == 0 && current_rtp_port) {",
          "1864:           sprt_add_address(pinfo, &transport_info->src_addr[n], current_rtp_port,",
          "1866:         } else {",
          "1867:           sprt_add_address(pinfo, &transport_info->src_addr[n], transport_info->media_port[n], 0, \"SDP\", pinfo->fd->num);",
          "1868:         }",
          "1869:       }",
          "1872:       if ((transport_info->media_port[n] != 0) &&",
          "1873:           !transport_info->media[n].set_rtp &&",
          "1874:           (transport_info->proto_bitmask[n] & SDP_T38_PROTO) &&",
          "1875:           (transport_info->proto_bitmask[n] & SDP_IPv4)) {",
          "1876:         t38_add_address(pinfo, &transport_info->src_addr[n], transport_info->media_port[n], 0, \"SDP\", pinfo->fd->num);",
          "1877:       }",
          "1880:          rather than connection information of media session line",
          "1882:       if ((transport_info->proto_bitmask[n] & SDP_MSRP_PROTO) &&",
          "1883:           (transport_info->proto_bitmask[n] & SDP_MSRP_IPv4) &&",
          "1884:           msrp_handle) {",
          "1885:           msrp_add_address(pinfo, &transport_info->src_addr[n], transport_info->media_port[n], \"SDP\", pinfo->fd->num);",
          "1886:       }",
          "1889:       if (!transport_info->media[n].set_rtp)",
          "1890:       {",
          "1891:           rtp_free_hash_dyn_payload(transport_info->media[n].rtp_dyn_payload);",
          "1892:           transport_info->media[n].rtp_dyn_payload = NULL;",
          "1893:       }",
          "1894:     }",
          "1897:     if (transport_info->media_count == -1)",
          "1898:     {",
          "1899:       for (n = 0; n < SDP_MAX_RTP_CHANNELS; n++)",
          "1900:       {",
          "1901:         if (!transport_info->media[n].set_rtp)",
          "1903:           rtp_free_hash_dyn_payload(transport_info->media[n].rtp_dyn_payload);",
          "1904:           transport_info->media[n].rtp_dyn_payload = NULL;",
          "1906:       }",
          "1907:     }",
          "1908:     else",
          "1909:     {",
          "1910:       for (n = transport_info->media_count; n < SDP_MAX_RTP_CHANNELS; n++)",
          "1911:       {",
          "1912:         if (!transport_info->media[n].set_rtp)",
          "1914:           rtp_free_hash_dyn_payload(transport_info->media[n].rtp_dyn_payload);",
          "1915:           transport_info->media[n].rtp_dyn_payload = NULL;",
          "1917:       }",
          "1918:     }",
          "1919:     transport_info->sdp_status = SDP_EXCHANGE_ANSWER_ACCEPT;",
          "1921:   } else if ((exchange_type == SDP_EXCHANGE_ANSWER_REJECT) &&",
          "1922:              (transport_info->sdp_status != SDP_EXCHANGE_ANSWER_REJECT)){",
          "1925:     for (n = 0; n < SDP_MAX_RTP_CHANNELS; n++)",
          "1926:     {",
          "1927:       if (!transport_info->media[n].set_rtp)",
          "1928:       {",
          "1929:         rtp_free_hash_dyn_payload(transport_info->media[n].rtp_dyn_payload);",
          "1930:         transport_info->media[n].rtp_dyn_payload = NULL;",
          "1931:       }",
          "1932:     }",
          "1934:     transport_info->sdp_status = SDP_EXCHANGE_ANSWER_REJECT;",
          "1935:   }",
          "1940:   transport_info_t* transport_info = NULL;",
          "1942:   if (request_frame != 0) {",
          "1943:     transport_info = (transport_info_t*)wmem_tree_lookup32( sdp_transport_reqs, request_frame );",
          "1944:     if (transport_info != NULL) {",
          "1945:         wmem_tree_insert32(sdp_transport_reqs, current_frame, (void *)transport_info);",
          "1947:   }",
          "1953:   proto_tree *sdp_tree;",
          "1954:   proto_item *ti, *sub_ti;",
          "1955:   gint        offset = 0, next_offset, n, i;",
          "1956:   int         linelen;",
          "1957:   gboolean    in_media_description;",
          "1958:   guchar      type, delim;",
          "1959:   int         datalen, tokenoffset, hf = -1;",
          "1960:   char       *string;",
          "1962:   transport_info_t  local_transport_info;",
          "1963:   transport_info_t* transport_info = NULL;",
          "1964:   disposable_media_info_t media_info;",
          "1966:   sdp_packet_info  *sdp_pi;",
          "1967:   struct srtp_info *srtp_info = NULL;",
          "1970:   sdp_pi = wmem_new(wmem_packet_scope(), sdp_packet_info);",
          "1971:   sdp_pi->summary_str[0] = '\\0';",
          "1973:   if (!pinfo->fd->flags.visited) {",
          "1974:     transport_info = (transport_info_t*)wmem_tree_lookup32( sdp_transport_reqs, pinfo->fd->num );",
          "1976:     if (transport_info == NULL) {",
          "1978:        transport_info = (transport_info_t*)wmem_tree_lookup32( sdp_transport_rsps, pinfo->fd->num );",
          "1979:     }",
          "1980:   }",
          "1982:   if (transport_info == NULL) {",
          "1983:     transport_info = &local_transport_info;",
          "1984:   }",
          "1987:   memset(&local_transport_info, 0, sizeof(local_transport_info));",
          "1988:   local_transport_info.media_count = -1;",
          "1990:   for (n = 0; n < SDP_NO_OF_PT; n++) {",
          "1991:     local_transport_info.encoding_name[n] = (char*)UNKNOWN_ENCODING;",
          "1992:   }",
          "1993:   for (n = 0; n < SDP_MAX_RTP_CHANNELS; n++) {",
          "1994:     local_transport_info.media[n].rtp_dyn_payload =",
          "1995:         g_hash_table_new(g_int_hash, g_int_equal);",
          "1996:     local_transport_info.media[n].set_rtp = FALSE;",
          "1997:   }",
          "1999:   memset(&media_info, 0, sizeof(media_info));",
          "2015:   col_append_str(pinfo->cinfo, COL_PROTOCOL, \"/SDP\");",
          "2024:   ti = proto_tree_add_item(tree, proto_sdp, tvb, offset, -1, ENC_NA);",
          "2025:   sdp_tree = proto_item_add_subtree(ti, ett_sdp);",
          "2030:   in_media_description = FALSE;",
          "2032:   while (tvb_reported_length_remaining(tvb, offset) > 0) {",
          "2036:     linelen = tvb_find_line_end_unquoted(tvb, offset, -1, &next_offset);",
          "2041:     if (linelen < 2)",
          "2042:       break;",
          "2044:     type  = tvb_get_guint8(tvb, offset);",
          "2045:     delim = tvb_get_guint8(tvb, offset + 1);",
          "2046:     if (delim != '=') {",
          "2047:       proto_item *ti2 = proto_tree_add_item(sdp_tree, hf_invalid, tvb, offset, linelen, ENC_ASCII|ENC_NA);",
          "2048:       expert_add_info(pinfo, ti2, &ei_sdp_invalid_line);",
          "2049:       offset = next_offset;",
          "2050:       continue;",
          "2051:     }",
          "2056:     switch (type) {",
          "2057:     case 'v':",
          "2058:       hf = hf_protocol_version;",
          "2059:       break;",
          "2060:     case 'o':",
          "2061:       hf = hf_owner;",
          "2062:       break;",
          "2063:     case 's':",
          "2064:       hf = hf_session_name;",
          "2065:       break;",
          "2066:     case 'i':",
          "2067:       if (in_media_description) {",
          "2068:         hf = hf_media_title;",
          "2069:       } else {",
          "2070:         hf = hf_session_info;",
          "2071:       }",
          "2072:       break;",
          "2073:     case 'u':",
          "2074:       hf = hf_uri;",
          "2075:       break;",
          "2076:     case 'e':",
          "2077:       hf = hf_email;",
          "2078:       break;",
          "2079:     case 'p':",
          "2080:       hf = hf_phone;",
          "2081:       break;",
          "2082:     case 'c':",
          "2083:       hf = hf_connection_info;",
          "2084:       break;",
          "2085:     case 'b':",
          "2086:       hf = hf_bandwidth;",
          "2087:       break;",
          "2088:     case 't':",
          "2089:       hf = hf_time;",
          "2090:       break;",
          "2091:     case 'r':",
          "2092:       hf = hf_repeat_time;",
          "2093:       break;",
          "2094:     case 'm':",
          "2095:       hf = hf_media;",
          "2098:       if (local_transport_info.media_count < (SDP_MAX_RTP_CHANNELS-1))",
          "2099:         local_transport_info.media_count++;",
          "2101:       if (in_media_description && (media_info.media_count < (SDP_MAX_RTP_CHANNELS-1)))",
          "2102:         media_info.media_count++;",
          "2104:       in_media_description = TRUE;",
          "2105:       break;",
          "2106:     case 'k':",
          "2107:       hf = hf_encryption_key;",
          "2108:       break;",
          "2109:     case 'a':",
          "2110:       if (in_media_description) {",
          "2111:         hf = hf_media_attribute;",
          "2112:       } else {",
          "2113:         hf = hf_session_attribute;",
          "2114:       }",
          "2115:       break;",
          "2116:     case 'z':",
          "2117:       hf = hf_timezone;",
          "2118:       break;",
          "2119:     default:",
          "2120:       hf = hf_unknown;",
          "2121:       break;",
          "2122:     }",
          "2123:     tokenoffset = 2;",
          "2124:     if (hf == hf_unknown)",
          "2125:       tokenoffset = 0;",
          "2126:     string = (char*)tvb_get_string(wmem_packet_scope(), tvb, offset + tokenoffset,",
          "2127:                                              linelen - tokenoffset);",
          "2128:     sub_ti = proto_tree_add_string(sdp_tree, hf, tvb, offset, linelen,",
          "2129:                                    string);",
          "2131:     call_sdp_subdissector(tvb_new_subset(tvb, offset + tokenoffset,",
          "2132:                                          linelen - tokenoffset,",
          "2133:                                          linelen - tokenoffset),",
          "2134:                           pinfo,",
          "2135:                           hf, sub_ti, linelen-tokenoffset,",
          "2136:                           &local_transport_info, &media_info);",
          "2138:     offset = next_offset;",
          "2139:   }",
          "2141:   if (in_media_description) {",
          "2143:     if (local_transport_info.media_count < (SDP_MAX_RTP_CHANNELS-1))",
          "2144:       local_transport_info.media_count++;",
          "2145:     if (media_info.media_count < (SDP_MAX_RTP_CHANNELS-1))",
          "2146:       media_info.media_count++;",
          "2147:   }",
          "2152:   if (transport_info == &local_transport_info)",
          "2153:     convert_disposable_media(transport_info, &media_info, 0);",
          "2155:   for (n = 0; n < local_transport_info.media_count; n++)",
          "2156:   {",
          "2162:     guint32 current_rtp_port = 0;",
          "2164:     if ((!pinfo->fd->flags.visited) && (transport_info == &local_transport_info) &&",
          "2165:         (transport_info->media_port[n] != 0) &&",
          "2166:         (transport_info->proto_bitmask[n] & (SDP_RTP_PROTO|SDP_SRTP_PROTO)) &&",
          "2167:         (transport_info->proto_bitmask[n] & (SDP_IPv4|SDP_IPv6))) {",
          "2168:       if (transport_info->proto_bitmask[n] & SDP_SRTP_PROTO) {",
          "2169:           srtp_info = wmem_new0(wmem_file_scope(), struct srtp_info);",
          "2170:           if (transport_info->encryption_algorithm != SRTP_ENC_ALG_NOT_SET) {",
          "2171:             srtp_info->encryption_algorithm = transport_info->encryption_algorithm;",
          "2172:             srtp_info->auth_algorithm       = transport_info->auth_algorithm;",
          "2173:             srtp_info->mki_len              = transport_info->mki_len;",
          "2174:             srtp_info->auth_tag_len         = transport_info->auth_tag_len;",
          "2175:           }",
          "2176:           srtp_add_address(pinfo, &transport_info->src_addr[n], transport_info->media_port[n], 0, \"SDP\", pinfo->fd->num,",
          "2177:                           (transport_info->proto_bitmask[n] & SDP_VIDEO) ? TRUE : FALSE,",
          "2178:                            transport_info->media[n].rtp_dyn_payload, srtp_info);",
          "2179:       } else {",
          "2180:           rtp_add_address(pinfo, &transport_info->src_addr[n], transport_info->media_port[n], 0, \"SDP\", pinfo->fd->num,",
          "2181:                           (transport_info->proto_bitmask[n] & SDP_VIDEO) ? TRUE : FALSE,",
          "2182:                           transport_info->media[n].rtp_dyn_payload);",
          "2183:       }",
          "2184:       transport_info->media[n].set_rtp = TRUE;",
          "2186:       current_rtp_port = transport_info->media_port[n];",
          "2188:       if (rtcp_handle) {",
          "2189:         if (transport_info->proto_bitmask[n] & SDP_SRTP_PROTO) {",
          "2190:           srtcp_add_address(pinfo, &transport_info->src_addr[n], transport_info->media_port[n]+1, 0, \"SDP\", pinfo->fd->num, srtp_info);",
          "2191:         } else {",
          "2192:           rtcp_add_address(pinfo, &transport_info->src_addr[n], transport_info->media_port[n]+1, 0, \"SDP\", pinfo->fd->num);",
          "2194:       }",
          "2195:     }",
          "2199:     if ((!pinfo->fd->flags.visited) && (transport_info == &local_transport_info) &&",
          "2200:         (transport_info->proto_bitmask[n] & SDP_SPRT_PROTO) &&",
          "2201:         (transport_info->proto_bitmask[n] & (SDP_IPv4|SDP_IPv6)) &&",
          "2202:         (sprt_handle)) {",
          "2204:       if (transport_info->media_port[n] == 0 && current_rtp_port) {",
          "2205:         sprt_add_address(pinfo, &transport_info->src_addr[n], current_rtp_port,",
          "2207:       } else {",
          "2208:         sprt_add_address(pinfo, &transport_info->src_addr[n], transport_info->media_port[n], 0, \"SDP\", pinfo->fd->num);",
          "2209:       }",
          "2214:     if ((!pinfo->fd->flags.visited) && (transport_info == &local_transport_info) &&",
          "2215:         (transport_info->media_port[n] != 0) &&",
          "2216:         !transport_info->media[n].set_rtp &&",
          "2217:         (transport_info->proto_bitmask[n] & SDP_T38_PROTO) &&",
          "2218:         (transport_info->proto_bitmask[n] & SDP_IPv4)) {",
          "2219:       t38_add_address(pinfo, &transport_info->src_addr[n], transport_info->media_port[n], 0, \"SDP\", pinfo->fd->num);",
          "2225:     if ((!pinfo->fd->flags.visited) && (transport_info == &local_transport_info) &&",
          "2226:         (transport_info->proto_bitmask[n] & SDP_MSRP_PROTO) &&",
          "2227:         (transport_info->proto_bitmask[n] & SDP_MSRP_IPv4) &&",
          "2228:         msrp_handle) {",
          "2229:         msrp_add_address(pinfo, &transport_info->src_addr[n], transport_info->media_port[n], \"SDP\", pinfo->fd->num);",
          "2230:     }",
          "2232:     if (local_transport_info.media_port[n] != 0) {",
          "2236:       for (i = 0; i < local_transport_info.media[n].pt_count; i++)",
          "2237:       {",
          "2239:         if ((local_transport_info.media[n].pt[i] >= 96) && (local_transport_info.media[n].pt[i] <= 127)) {",
          "2240:           encoding_name_and_rate_t *encoding_name_and_rate_pt =",
          "2241:             (encoding_name_and_rate_t *)g_hash_table_lookup(",
          "2242:             local_transport_info.media[n].rtp_dyn_payload,",
          "2243:             &local_transport_info.media[n].pt[i]);",
          "2244:           if (encoding_name_and_rate_pt) {",
          "2245:             if (strlen(sdp_pi->summary_str))",
          "2246:               g_strlcat(sdp_pi->summary_str, \" \", 50);",
          "2247:             g_strlcat(sdp_pi->summary_str, encoding_name_and_rate_pt->encoding_name, 50);",
          "2248:           } else {",
          "2249:             char num_pt[10];",
          "2250:             g_snprintf(num_pt, 10, \"%u\", local_transport_info.media[n].pt[i]);",
          "2252:               g_strlcat(sdp_pi->summary_str, \" \", 50);",
          "2253:             g_strlcat(sdp_pi->summary_str, num_pt, 50);",
          "2254:           }",
          "2255:         } else {",
          "2256:           if (strlen(sdp_pi->summary_str))",
          "2257:             g_strlcat(sdp_pi->summary_str, \" \", 50);",
          "2258:           g_strlcat(sdp_pi->summary_str,",
          "2259:                     val_to_str_ext(local_transport_info.media[n].pt[i], &rtp_payload_type_short_vals_ext, \"%u\"),",
          "2260:                     50);",
          "2262:       }",
          "2267:     if ((transport_info == &local_transport_info) &&",
          "2268:         !transport_info->media[n].set_rtp)",
          "2269:     {",
          "2270:       rtp_free_hash_dyn_payload(transport_info->media[n].rtp_dyn_payload);",
          "2271:       transport_info->media[n].rtp_dyn_payload = NULL;",
          "2272:     }",
          "2277:     if ((local_transport_info.media_port[n] != 0) &&",
          "2278:         (local_transport_info.proto_bitmask[n] & SDP_T38_PROTO)) {",
          "2279:       if (strlen(sdp_pi->summary_str))",
          "2280:         g_strlcat(sdp_pi->summary_str, \" \", 50);",
          "2281:       g_strlcat(sdp_pi->summary_str, \"t38\", 50);",
          "2283:   }",
          "2287:   if (transport_info == &local_transport_info) {",
          "2288:     for (n = transport_info->media_count; n < SDP_MAX_RTP_CHANNELS; n++)",
          "2289:     {",
          "2290:       if (!transport_info->media[n].set_rtp)",
          "2291:       {",
          "2292:         rtp_free_hash_dyn_payload(transport_info->media[n].rtp_dyn_payload);",
          "2293:         transport_info->media[n].rtp_dyn_payload = NULL;",
          "2294:       }",
          "2296:   }",
          "2298:   datalen = tvb_length_remaining(tvb, offset);",
          "2299:   if (datalen > 0) {",
          "2300:     proto_tree_add_text(sdp_tree, tvb, offset, datalen, \"Data (%d bytes)\",  datalen);",
          "2301:   }",
          "2303:   tap_queue_packet(sdp_tap, pinfo, sdp_pi);",
          "2309:   static hf_register_info hf[] = {",
          "2310:     { &hf_protocol_version,",
          "2311:       { \"Session Description Protocol Version (v)\", \"sdp.version\",",
          "2312:         FT_STRING, BASE_NONE, NULL, 0x0,",
          "2313:         NULL, HFILL }",
          "2314:     },",
          "2315:     { &hf_owner,",
          "2316:       { \"Owner/Creator, Session Id (o)\",",
          "2317:         \"sdp.owner\", FT_STRING, BASE_NONE, NULL,",
          "2318:         0x0, NULL, HFILL}",
          "2319:     },",
          "2320:     { &hf_session_name,",
          "2321:       { \"Session Name (s)\", \"sdp.session_name\",",
          "2322:         FT_STRING, BASE_NONE, NULL, 0x0,",
          "2323:         NULL, HFILL }",
          "2324:     },",
          "2325:     { &hf_session_info,",
          "2326:       { \"Session Information (i)\", \"sdp.session_info\",",
          "2327:         FT_STRING, BASE_NONE, NULL, 0x0,",
          "2328:         NULL, HFILL }",
          "2329:     },",
          "2330:     { &hf_uri,",
          "2331:       { \"URI of Description (u)\", \"sdp.uri\",",
          "2332:         FT_STRING, BASE_NONE, NULL, 0x0,",
          "2333:         NULL, HFILL }",
          "2334:     },",
          "2335:     { &hf_email,",
          "2336:       { \"E-mail Address (e)\", \"sdp.email\",",
          "2337:         FT_STRING, BASE_NONE, NULL, 0x0,",
          "2338:         \"E-mail Address\", HFILL }",
          "2339:     },",
          "2340:     { &hf_phone,",
          "2341:       { \"Phone Number (p)\", \"sdp.phone\",",
          "2342:         FT_STRING, BASE_NONE, NULL, 0x0,",
          "2343:         NULL, HFILL }",
          "2344:     },",
          "2345:     { &hf_connection_info,",
          "2346:       { \"Connection Information (c)\", \"sdp.connection_info\",",
          "2347:         FT_STRING, BASE_NONE, NULL, 0x0,",
          "2348:         NULL, HFILL }",
          "2349:     },",
          "2350:     { &hf_bandwidth,",
          "2351:       { \"Bandwidth Information (b)\", \"sdp.bandwidth\",",
          "2352:         FT_STRING, BASE_NONE, NULL, 0x0,",
          "2353:         NULL, HFILL }",
          "2354:     },",
          "2355:     { &hf_timezone,",
          "2356:       { \"Time Zone Adjustments (z)\", \"sdp.timezone\",",
          "2357:         FT_STRING, BASE_NONE, NULL, 0x0,",
          "2358:         NULL, HFILL }",
          "2359:     },",
          "2360:     { &hf_encryption_key,",
          "2361:       { \"Encryption Key (k)\", \"sdp.encryption_key\",",
          "2362:         FT_STRING, BASE_NONE, NULL, 0x0,",
          "2363:         NULL, HFILL }",
          "2364:     },",
          "2365:     { &hf_session_attribute,",
          "2366:       { \"Session Attribute (a)\", \"sdp.session_attr\",",
          "2367:         FT_STRING, BASE_NONE, NULL, 0x0,",
          "2368:         NULL, HFILL }",
          "2369:     },",
          "2370:     { &hf_media_attribute,",
          "2371:       { \"Media Attribute (a)\", \"sdp.media_attr\",",
          "2372:         FT_STRING, BASE_NONE, NULL, 0x0,",
          "2373:         NULL, HFILL }",
          "2374:     },",
          "2375:     { &hf_time,",
          "2376:       { \"Time Description, active time (t)\",",
          "2377:         \"sdp.time\", FT_STRING, BASE_NONE, NULL,",
          "2378:         0x0, NULL, HFILL }",
          "2379:     },",
          "2380:     { &hf_repeat_time,",
          "2381:       { \"Repeat Time (r)\", \"sdp.repeat_time\",",
          "2382:         FT_STRING, BASE_NONE, NULL, 0x0,",
          "2383:         NULL, HFILL }",
          "2384:     },",
          "2385:     { &hf_media,",
          "2386:       { \"Media Description, name and address (m)\",",
          "2387:         \"sdp.media\", FT_STRING, BASE_NONE, NULL,",
          "2388:         0x0, NULL, HFILL }",
          "2389:     },",
          "2390:     { &hf_media_title,",
          "2391:       { \"Media Title (i)\", \"sdp.media_title\",",
          "2392:         FT_STRING, BASE_NONE, NULL, 0x0,",
          "2393:         \"Media Title\", HFILL }",
          "2394:     },",
          "2395:     { &hf_unknown,",
          "2396:       { \"Unknown\", \"sdp.unknown\",",
          "2397:         FT_STRING, BASE_NONE, NULL, 0x0,",
          "2398:         NULL, HFILL }",
          "2399:     },",
          "2400:     { &hf_invalid,",
          "2401:       { \"Invalid line\", \"sdp.invalid\",",
          "2402:         FT_STRING, BASE_NONE, NULL, 0x0,",
          "2403:         NULL, HFILL }",
          "2404:     },",
          "2405:     { &hf_owner_username,",
          "2406:       { \"Owner Username\", \"sdp.owner.username\",",
          "2407:         FT_STRING, BASE_NONE, NULL, 0x0,",
          "2408:         NULL, HFILL }",
          "2409:     },",
          "2410:     { &hf_owner_sessionid,",
          "2411:       { \"Session ID\", \"sdp.owner.sessionid\",",
          "2412:         FT_STRING, BASE_NONE, NULL, 0x0,",
          "2413:         NULL, HFILL }",
          "2414:     },",
          "2415:     { &hf_owner_version,",
          "2416:       { \"Session Version\", \"sdp.owner.version\",",
          "2417:         FT_STRING, BASE_NONE, NULL, 0x0,",
          "2418:         NULL, HFILL }",
          "2419:     },",
          "2420:     { &hf_owner_network_type,",
          "2421:       { \"Owner Network Type\", \"sdp.owner.network_type\",",
          "2422:         FT_STRING, BASE_NONE, NULL, 0x0,",
          "2423:         NULL, HFILL }",
          "2424:     },",
          "2425:     { &hf_owner_address_type,",
          "2426:       { \"Owner Address Type\", \"sdp.owner.address_type\",",
          "2427:         FT_STRING, BASE_NONE, NULL, 0x0,",
          "2428:         NULL, HFILL }",
          "2429:     },",
          "2430:     { &hf_owner_address,",
          "2431:       { \"Owner Address\", \"sdp.owner.address\",",
          "2432:         FT_STRING, BASE_NONE, NULL, 0x0,",
          "2433:         NULL, HFILL }",
          "2434:     },",
          "2435:     { &hf_connection_info_network_type,",
          "2436:       { \"Connection Network Type\", \"sdp.connection_info.network_type\",",
          "2437:         FT_STRING, BASE_NONE, NULL, 0x0,",
          "2438:         NULL, HFILL }",
          "2439:     },",
          "2440:     { &hf_connection_info_address_type,",
          "2441:       { \"Connection Address Type\", \"sdp.connection_info.address_type\",",
          "2442:         FT_STRING, BASE_NONE, NULL, 0x0,",
          "2443:         NULL, HFILL }",
          "2444:     },",
          "2445:     { &hf_connection_info_connection_address,",
          "2446:       { \"Connection Address\", \"sdp.connection_info.address\",",
          "2447:         FT_STRING, BASE_NONE, NULL, 0x0,",
          "2448:         NULL, HFILL }",
          "2449:     },",
          "2450:     { &hf_connection_info_ttl,",
          "2451:       { \"Connection TTL\", \"sdp.connection_info.ttl\",",
          "2452:         FT_STRING, BASE_NONE, NULL, 0x0,",
          "2453:         NULL, HFILL }",
          "2454:     },",
          "2455:     { &hf_connection_info_num_addr,",
          "2456:       { \"Connection Number of Addresses\", \"sdp.connection_info.num_addr\",",
          "2457:         FT_STRING, BASE_NONE, NULL, 0x0,",
          "2458:         NULL, HFILL }",
          "2459:     },",
          "2460:     { &hf_bandwidth_modifier,",
          "2461:       { \"Bandwidth Modifier\", \"sdp.bandwidth.modifier\",",
          "2462:         FT_STRING, BASE_NONE, NULL, 0x0,",
          "2463:         NULL, HFILL }",
          "2464:     },",
          "2465:     { &hf_bandwidth_value,",
          "2466:       { \"Bandwidth Value\", \"sdp.bandwidth.value\",",
          "2467:         FT_STRING, BASE_NONE, NULL, 0x0,",
          "2468:         \"Bandwidth Value (in kbits/s)\", HFILL }",
          "2469:     },",
          "2470:     { &hf_time_start,",
          "2471:       { \"Session Start Time\", \"sdp.time.start\",",
          "2472:         FT_STRING, BASE_NONE, NULL, 0x0,",
          "2473:         NULL, HFILL }",
          "2474:     },",
          "2475:     { &hf_time_stop,",
          "2476:       { \"Session Stop Time\", \"sdp.time.stop\",",
          "2477:         FT_STRING, BASE_NONE, NULL, 0x0,",
          "2478:         NULL, HFILL }",
          "2479:     },",
          "2480:     { &hf_repeat_time_interval,",
          "2481:       { \"Repeat Interval\", \"sdp.repeat_time.interval\",",
          "2482:         FT_STRING, BASE_NONE, NULL, 0x0,",
          "2483:         NULL, HFILL }",
          "2484:     },",
          "2485:     { &hf_repeat_time_duration,",
          "2486:       { \"Repeat Duration\", \"sdp.repeat_time.duration\",",
          "2487:         FT_STRING, BASE_NONE, NULL, 0x0,",
          "2488:         NULL, HFILL }",
          "2489:     },",
          "2490:     { &hf_repeat_time_offset,",
          "2491:       { \"Repeat Offset\", \"sdp.repeat_time.offset\",",
          "2492:         FT_STRING, BASE_NONE, NULL, 0x0,",
          "2493:         NULL, HFILL }",
          "2494:     },",
          "2495:     { &hf_timezone_time,",
          "2496:       { \"Timezone Time\", \"sdp.timezone.time\",",
          "2497:         FT_STRING, BASE_NONE, NULL, 0x0,",
          "2498:         NULL, HFILL }",
          "2499:     },",
          "2500:     { &hf_timezone_offset,",
          "2501:       { \"Timezone Offset\", \"sdp.timezone.offset\",",
          "2502:         FT_STRING, BASE_NONE, NULL, 0x0,",
          "2503:         NULL, HFILL }",
          "2504:     },",
          "2505:     { &hf_encryption_key_type,",
          "2506:       { \"Key Type\", \"sdp.encryption_key.type\",",
          "2507:         FT_STRING, BASE_NONE, NULL, 0x0,",
          "2508:         NULL, HFILL }",
          "2509:     },",
          "2510:     { &hf_encryption_key_data,",
          "2511:       { \"Key Data\", \"sdp.encryption_key.data\",",
          "2512:         FT_STRING, BASE_NONE, NULL, 0x0,",
          "2513:         NULL, HFILL }",
          "2514:     },",
          "2515:     { &hf_session_attribute_field,",
          "2516:       { \"Session Attribute Fieldname\", \"sdp.session_attr.field\",",
          "2517:         FT_STRING, BASE_NONE, NULL, 0x0,",
          "2518:         NULL, HFILL }",
          "2519:     },",
          "2520:     { &hf_session_attribute_value,",
          "2521:       { \"Session Attribute Value\", \"sdp.session_attr.value\",",
          "2522:         FT_STRING, BASE_NONE, NULL, 0x0,",
          "2523:         NULL, HFILL }",
          "2524:     },",
          "2525:     { &hf_media_media,",
          "2526:       { \"Media Type\", \"sdp.media.media\",",
          "2527:         FT_STRING, BASE_NONE, NULL, 0x0,",
          "2528:         NULL, HFILL }",
          "2529:     },",
          "2530:     { &hf_media_port,",
          "2531:       { \"Media Port\", \"sdp.media.port\",",
          "2532:         FT_UINT16, BASE_DEC, NULL, 0x0,",
          "2533:         NULL, HFILL }",
          "2534:     },",
          "2535:     { &hf_media_portcount,",
          "2536:       { \"Media Port Count\", \"sdp.media.portcount\",",
          "2537:         FT_STRING, BASE_NONE, NULL, 0x0,",
          "2538:         NULL, HFILL }",
          "2539:     },",
          "2540:     { &hf_media_proto,",
          "2541:       { \"Media Protocol\", \"sdp.media.proto\",",
          "2542:         FT_STRING, BASE_NONE, NULL, 0x0,",
          "2543:         NULL, HFILL }",
          "2544:     },",
          "2545:     { &hf_media_format,",
          "2546:       { \"Media Format\", \"sdp.media.format\",",
          "2547:         FT_STRING, BASE_NONE, NULL, 0x0,",
          "2548:         NULL, HFILL }",
          "2549:     },",
          "2550:     { &hf_media_attribute_field,",
          "2551:       { \"Media Attribute Fieldname\", \"sdp.media_attribute.field\",",
          "2552:         FT_STRING, BASE_NONE, NULL, 0x0,",
          "2553:         NULL, HFILL }",
          "2554:     },",
          "2555:     { &hf_media_attribute_value,",
          "2556:       { \"Media Attribute Value\", \"sdp.media_attribute.value\",",
          "2557:         FT_STRING, BASE_NONE, NULL, 0x0,",
          "2558:         NULL, HFILL }",
          "2559:     },",
          "2560:     { &hf_media_encoding_name,",
          "2561:       { \"MIME Type\", \"sdp.mime.type\",",
          "2562:         FT_STRING, BASE_NONE, NULL, 0x0,",
          "2563:         \"SDP MIME Type\", HFILL }",
          "2564:     },",
          "2565:     { &hf_media_sample_rate,",
          "2566:       { \"Sample Rate\", \"sdp.sample_rate\",",
          "2567:         FT_STRING, BASE_NONE, NULL, 0x0,",
          "2568:         NULL, HFILL }",
          "2569:     },",
          "2570:     { &hf_media_format_specific_parameter,",
          "2571:       { \"Media format specific parameters\", \"sdp.fmtp.parameter\",",
          "2572:         FT_STRING, BASE_NONE, NULL, 0x0,",
          "2573:         \"Format specific parameter(fmtp)\", HFILL }",
          "2574:     },",
          "2575:     { &hf_ipbcp_version,",
          "2576:       { \"IPBCP Protocol Version\", \"sdp.ipbcp.version\",",
          "2577:         FT_STRING, BASE_NONE, NULL, 0x0,",
          "2578:         NULL, HFILL }",
          "2579:     },",
          "2580:     { &hf_ipbcp_type,",
          "2581:       { \"IPBCP Command Type\", \"sdp.ipbcp.command\",",
          "2582:         FT_STRING, BASE_NONE, NULL, 0x0,",
          "2583:         NULL, HFILL }",
          "2584:     },",
          "2585:     {&hf_sdp_fmtp_mpeg4_profile_level_id,",
          "2586:      { \"Level Code\", \"sdp.fmtp.profile_level_id\",",
          "2587:        FT_UINT32, BASE_DEC, VALS(mp4ves_level_indication_vals), 0x0,",
          "2588:        NULL, HFILL }",
          "2589:     },",
          "2590:     { &hf_sdp_fmtp_h263_profile,",
          "2591:       { \"Profile\", \"sdp.fmtp.h263profile\",",
          "2592:         FT_UINT32, BASE_DEC, VALS(h263_profile_vals), 0x0,",
          "2593:         NULL, HFILL }",
          "2594:     },",
          "2595:     { &hf_sdp_fmtp_h263_level,",
          "2596:       { \"Level\", \"sdp.fmtp.h263level\",",
          "2597:         FT_UINT32, BASE_DEC, VALS(h263_level_vals), 0x0,",
          "2598:         NULL, HFILL }",
          "2599:     },",
          "2600:     { &hf_sdp_h264_packetization_mode,",
          "2601:       { \"Packetization mode\", \"sdp.fmtp.h264_packetization_mode\",",
          "2602:         FT_UINT32, BASE_DEC, VALS(h264_packetization_mode_vals), 0x0,",
          "2603:         NULL, HFILL }",
          "2604:     },",
          "2605:     { &hf_SDPh223LogicalChannelParameters,",
          "2606:       { \"h223LogicalChannelParameters\", \"sdp.h223LogicalChannelParameters\",",
          "2607:         FT_NONE, BASE_NONE, NULL, 0,",
          "2608:         NULL, HFILL }",
          "2609:     },",
          "2610:     { &hf_key_mgmt_att_value,",
          "2611:       { \"Key Management\", \"sdp.key_mgmt\",",
          "2612:         FT_STRING, BASE_NONE, NULL, 0x0,",
          "2613:         NULL, HFILL }",
          "2614:     },",
          "2615:     { &hf_key_mgmt_prtcl_id,",
          "2616:       { \"Key Management Protocol (kmpid)\", \"sdp.key_mgmt.kmpid\",",
          "2617:         FT_STRING, BASE_NONE, NULL, 0x0,",
          "2618:         NULL, HFILL }",
          "2619:     },",
          "2620:     { &hf_key_mgmt_data,",
          "2621:       { \"Key Management Data\", \"sdp.key_mgmt.data\",",
          "2622:         FT_BYTES, BASE_NONE, NULL, 0x0,",
          "2623:         NULL, HFILL }",
          "2624:     },",
          "2625:     { &hf_sdp_crypto_tag,",
          "2626:       { \"tag\", \"sdp.crypto.tag\",",
          "2627:         FT_UINT32, BASE_DEC, NULL, 0x0,",
          "2628:         NULL, HFILL }",
          "2629:     },",
          "2630:     { &hf_sdp_crypto_crypto_suite,",
          "2631:       { \"Crypto suite\", \"sdp.crypto.crypto_suite\",",
          "2632:         FT_STRING, BASE_NONE, NULL, 0x0,",
          "2633:         NULL, HFILL }",
          "2634:     },",
          "2635:     { &hf_sdp_crypto_master_key,",
          "2636:       { \"Master Key\", \"sdp.crypto.master_key\",",
          "2637:         FT_BYTES, BASE_NONE, NULL, 0x0,",
          "2638:         NULL, HFILL }",
          "2639:     },",
          "2640:     { &hf_sdp_crypto_master_salt,",
          "2641:       { \"Master salt\", \"sdp.crypto.master_salt\",",
          "2642:         FT_BYTES, BASE_NONE, NULL, 0x0,",
          "2643:         NULL, HFILL }",
          "2644:     },",
          "2645:     { &hf_sdp_crypto_lifetime,",
          "2646:       { \"Lifetime\", \"sdp.crypto.lifetime\",",
          "2647:         FT_STRING, BASE_NONE, NULL, 0x0,",
          "2648:         NULL, HFILL }",
          "2649:     },",
          "2650:     { &hf_sdp_crypto_mki,",
          "2651:       { \"mki-value\", \"sdp.crypto.mki-valu\",",
          "2652:         FT_STRING, BASE_NONE, NULL, 0x0,",
          "2653:         NULL, HFILL }",
          "2654:     },",
          "2655:     { &hf_sdp_crypto_mki_length,",
          "2656:       { \"mki_length\", \"sdp.crypto.mki_length\",",
          "2657:         FT_STRING, BASE_NONE, NULL, 0x0,",
          "2658:         NULL, HFILL }",
          "2659:     },",
          "2660:   };",
          "2661:   static gint *ett[] = {",
          "2662:     &ett_sdp,",
          "2663:     &ett_sdp_owner,",
          "2664:     &ett_sdp_connection_info,",
          "2665:     &ett_sdp_bandwidth,",
          "2666:     &ett_sdp_time,",
          "2667:     &ett_sdp_repeat_time,",
          "2668:     &ett_sdp_timezone,",
          "2669:     &ett_sdp_encryption_key,",
          "2670:     &ett_sdp_session_attribute,",
          "2671:     &ett_sdp_media,",
          "2672:     &ett_sdp_media_attribute,",
          "2673:     &ett_sdp_fmtp,",
          "2674:     &ett_sdp_key_mgmt,",
          "2675:     &ett_sdp_crypto_key_parameters,",
          "2676:   };",
          "2678:   static ei_register_info ei[] = {",
          "2679:      { &ei_sdp_invalid_key_param, { \"sdp.invalid_key_param\", PI_MALFORMED, PI_NOTE, \"Invalid key-param (no ':' delimiter)\", EXPFILL }},",
          "2680:      { &ei_sdp_invalid_line, { \"sdp.invalid_line\", PI_MALFORMED, PI_NOTE, \"Invalid SDP line (no '=' delimiter)\", EXPFILL }},",
          "2681:   };",
          "2683:   module_t *sdp_module;",
          "2684:   expert_module_t* expert_sdp;",
          "2686:   proto_sdp = proto_register_protocol(\"Session Description Protocol\",",
          "2687:                                       \"SDP\", \"sdp\");",
          "2688:   proto_register_field_array(proto_sdp, hf, array_length(hf));",
          "2689:   proto_register_subtree_array(ett, array_length(ett));",
          "2690:   expert_sdp = expert_register_protocol(proto_sdp);",
          "2691:   expert_register_field_array(expert_sdp, ei, array_length(ei));",
          "2693:   key_mgmt_dissector_table = register_dissector_table(\"key_mgmt\",",
          "2694:                                                       \"Key Management\", FT_STRING, BASE_NONE);",
          "2698:   sdp_module = prefs_register_protocol(proto_sdp, NULL);",
          "2699:   prefs_register_bool_preference(sdp_module, \"establish_conversation\",",
          "2700:                                  \"Establish Media Conversation\",",
          "2701:                                  \"Specifies that RTP/RTCP/T.38/MSRP/etc streams are decoded based \"",
          "2702:                                  \"upon port numbers found in SDP payload\",",
          "2703:                                  &global_sdp_establish_conversation);",
          "2705:   sdp_transport_reqs = wmem_tree_new_autoreset(wmem_epan_scope(), wmem_file_scope());",
          "2706:   sdp_transport_rsps = wmem_tree_new_autoreset(wmem_epan_scope(), wmem_file_scope());",
          "2712:   register_dissector(\"sdp\", dissect_sdp, proto_sdp);",
          "2715:   sdp_tap = register_tap(\"sdp\");",
          "2721:   dissector_handle_t sdp_handle;",
          "2723:   rtcp_handle   = find_dissector(\"rtcp\");",
          "2724:   msrp_handle   = find_dissector(\"msrp\");",
          "2725:   sprt_handle   = find_dissector(\"sprt\");",
          "2726:   h264_handle   = find_dissector(\"h264\");",
          "2727:   mp4ves_handle = find_dissector(\"mp4ves\");",
          "2729:   proto_sprt    = dissector_handle_get_protocol_index(find_dissector(\"sprt\"));",
          "2731:   sdp_handle = find_dissector(\"sdp\");",
          "2732:   dissector_add_string(\"media_type\", \"application/sdp\", sdp_handle);",
          "2733:   dissector_add_uint(\"bctp.tpi\", 0x20, sdp_handle);",
          "",
          "[Added Lines]",
          "1094:     guint i;",
          "1096:     for (i = 1; i < array_length(sdp_media_attribute_names); i++) {",
          "1097:         if ((len == strlen(sdp_media_attribute_names[i].name)) &&",
          "1098:             (tvb_strncaseeql(tvb, offset, sdp_media_attribute_names[i].name, len) == 0))",
          "1099:             return i;",
          "1100:     }",
          "1102:     return -1;",
          "1107:     proto_tree *sdp_media_attribute_tree, *parameter_item;",
          "1108:     proto_item *fmtp_item, *media_format_item, *parameter_tree;",
          "1109:     proto_tree *fmtp_tree;",
          "1110:     gint        offset, next_offset, tokenlen, n, colon_offset;",
          "1112:     guint8     *payload_type;",
          "1113:     guint8     *attribute_value;",
          "1114:     gint       *key;",
          "1115:     guint8      pt;",
          "1116:     gint        sdp_media_attrbute_code;",
          "1117:     const char *msrp_res           = \"msrp://\";",
          "1118:     const char *h324ext_h223lcparm = \"h324ext/h223lcparm\";",
          "1119:     gboolean    has_more_pars      = TRUE;",
          "1120:     tvbuff_t   *h245_tvb;",
          "1121:     guint8      master_key_length  = 0, master_salt_length = 0;",
          "1122:     encoding_name_and_rate_t *encoding_name_and_rate;",
          "1124:     offset = 0;",
          "1127:     sdp_media_attribute_tree = proto_item_add_subtree(ti,",
          "1128:                                                       ett_sdp_media_attribute);",
          "1130:     colon_offset = tvb_find_guint8(tvb, offset, -1, ':');",
          "1132:     if (colon_offset == -1)",
          "1136:     tokenlen = colon_offset - offset;",
          "1137:     proto_tree_add_item(sdp_media_attribute_tree,",
          "1138:                         hf_media_attribute_field,",
          "1139:                         tvb, offset, tokenlen, ENC_ASCII|ENC_NA);",
          "1141:     sdp_media_attrbute_code = find_sdp_media_attribute_names(tvb, offset, tokenlen);",
          "1144:     offset = colon_offset + 1;",
          "1146:     offset = tvb_skip_wsp(tvb, offset, tvb_length_remaining(tvb, offset));",
          "1149:     attribute_value = tvb_get_string(wmem_packet_scope(), tvb, offset, tvb_length_remaining(tvb, offset));",
          "1156:     switch (sdp_media_attrbute_code) {",
          "1157:         case SDP_RTPMAP:",
          "1159:             next_offset = tvb_find_guint8(tvb, offset, -1, ' ');",
          "1161:             if (next_offset == -1)",
          "1162:                 return;",
          "1164:             tokenlen = next_offset - offset;",
          "1166:             proto_tree_add_item(sdp_media_attribute_tree, hf_media_format, tvb,",
          "1167:                                 offset, tokenlen, ENC_ASCII|ENC_NA);",
          "1169:             payload_type = tvb_get_string(wmem_packet_scope(), tvb, offset, tokenlen);",
          "1171:             offset = next_offset + 1;",
          "1173:             next_offset = tvb_find_guint8(tvb, offset, -1, '/');",
          "1175:             if (next_offset == -1) {",
          "1176:                 return;",
          "1177:             }",
          "1179:             tokenlen = next_offset - offset;",
          "1181:             proto_tree_add_item(sdp_media_attribute_tree, hf_media_encoding_name, tvb,",
          "1182:                                 offset, tokenlen, ENC_ASCII|ENC_NA);",
          "1184:             pt = atoi((char*)payload_type);",
          "1185:             if (pt >= SDP_NO_OF_PT) {",
          "1187:             }",
          "1189:             key  = wmem_new(wmem_file_scope(), gint);",
          "1192:             transport_info->encoding_name[pt] = (char*)tvb_get_string(wmem_packet_scope(), tvb, offset, tokenlen);",
          "1194:             next_offset =  next_offset + 1;",
          "1195:             offset = next_offset;",
          "1196:             while (length-1 >= next_offset) {",
          "1197:                 if (!g_ascii_isdigit(tvb_get_guint8(tvb, next_offset)))",
          "1198:                     break;",
          "1199:                 next_offset++;",
          "1200:             }",
          "1201:             tokenlen = next_offset - offset;",
          "1202:             proto_tree_add_item(sdp_media_attribute_tree, hf_media_sample_rate, tvb,",
          "1203:                                 offset, tokenlen, ENC_ASCII|ENC_NA);",
          "1204:             transport_info->sample_rate[pt] = atoi(tvb_get_string(wmem_packet_scope(), tvb, offset, tokenlen));",
          "1206:                For example:",
          "1208:                a=rtpmap:101 G726-32/8000",
          "1209:                m=audio 49170 RTP/AVP 0 97",
          "1210:                a=rtpmap:97 telephone-event/8000",
          "1211:                m=audio 49172 RTP/AVP 97 101",
          "1212:                a=rtpmap:97 G726-24/8000",
          "1214:                The Media attributes (\"a=\"s) after the \"m=\" only apply for that \"m=\".",
          "1215:                If there is an \"a=\" before the first \"m=\", that attribute applies for",
          "1216:                all the session (all the \"m=\"s).",
          "1222:             if (transport_info->media_count < 0) {",
          "1223:                 for (n = 0; n < SDP_MAX_RTP_CHANNELS; n++) {",
          "1224:                     encoding_name_and_rate = wmem_new(wmem_file_scope(), encoding_name_and_rate_t);",
          "1225:                     encoding_name_and_rate->encoding_name = wmem_strdup(wmem_file_scope(), transport_info->encoding_name[pt]);",
          "1226:                     encoding_name_and_rate->sample_rate = transport_info->sample_rate[pt];",
          "1227:                     if (n == 0) {",
          "1228:                         g_hash_table_insert(transport_info->media[n].rtp_dyn_payload,",
          "1229:                                             key, encoding_name_and_rate);",
          "1231:                         gint *key2;",
          "1232:                         key2  = wmem_new(wmem_file_scope(), gint);",
          "1234:                         g_hash_table_insert(transport_info->media[n].rtp_dyn_payload,",
          "1235:                                             key2, encoding_name_and_rate);",
          "1236:                     }",
          "1237:                 }",
          "1238:                 return;",
          "1240:             } else",
          "1242:                 encoding_name_and_rate = wmem_new(wmem_file_scope(), encoding_name_and_rate_t);",
          "1244:             encoding_name_and_rate->encoding_name = wmem_strdup(wmem_file_scope(), transport_info->encoding_name[pt]);",
          "1245:             encoding_name_and_rate->sample_rate   = transport_info->sample_rate[pt];",
          "1246:             g_hash_table_insert(transport_info->media[ transport_info->media_count ].rtp_dyn_payload,",
          "1247:                                   key, encoding_name_and_rate);",
          "1248:             break;",
          "1249:         case SDP_FMTP:",
          "1250:             if (sdp_media_attribute_tree) {",
          "1251:                 guint8 media_format;",
          "1254:                 offset = tvb_skip_wsp(tvb, offset, tvb_length_remaining(tvb, offset));",
          "1256:                 next_offset = tvb_find_guint8(tvb, offset, -1, ' ');",
          "1258:                 if (next_offset == -1)",
          "1259:                     return;",
          "1261:                 tokenlen = next_offset - offset;",
          "1264:                 media_format_item = proto_tree_add_item(sdp_media_attribute_tree,",
          "1265:                                                         hf_media_format, tvb, offset,",
          "1266:                                                         tokenlen, ENC_ASCII|ENC_NA);",
          "1267:                 media_format = atoi((char*)tvb_get_string(wmem_packet_scope(), tvb, offset, tokenlen));",
          "1268:                 if (media_format >= SDP_NO_OF_PT) {",
          "1270:                 }",
          "1273:                 proto_item_append_text(media_format_item, \" [%s]\",",
          "1274:                                        transport_info->encoding_name[media_format]);",
          "1277:                 payload_type = tvb_get_string(wmem_packet_scope(), tvb, offset, tokenlen);",
          "1278: #endif",
          "1280:                 offset = next_offset + 1;",
          "1282:                 while (has_more_pars == TRUE) {",
          "1283:                     next_offset = tvb_find_guint8(tvb, offset, -1, ';');",
          "1284:                     offset = tvb_skip_wsp(tvb, offset, tvb_length_remaining(tvb, offset));",
          "1286:                     if (next_offset == -1) {",
          "1287:                         has_more_pars = FALSE;",
          "1288:                         next_offset= tvb_length(tvb);",
          "1289:                     }",
          "1292:                     tokenlen = next_offset - offset;",
          "1293:                     fmtp_item = proto_tree_add_item(sdp_media_attribute_tree,",
          "1294:                                                     hf_media_format_specific_parameter, tvb,",
          "1295:                                                     offset, tokenlen, ENC_ASCII|ENC_NA);",
          "1297:                     fmtp_tree = proto_item_add_subtree(fmtp_item, ett_sdp_fmtp);",
          "1299:                     decode_sdp_fmtp(fmtp_tree, tvb, pinfo, offset, tokenlen,",
          "1300:                                     transport_info->encoding_name[media_format]);",
          "1303:                     offset = next_offset + 1;",
          "1304:                 }",
          "1305:             }",
          "1306:             break;",
          "1307:         case SDP_PATH:",
          "1325:             if (strncmp((char*)attribute_value, msrp_res, strlen(msrp_res)) == 0) {",
          "1326:                 int address_offset, port_offset, port_end_offset;",
          "1329:                 address_offset = offset + (int)strlen(msrp_res);",
          "1332:                 port_offset = tvb_find_guint8(tvb, address_offset, -1, ':');",
          "1334:                 if (port_offset!= -1) {",
          "1336:                     port_end_offset = tvb_find_guint8(tvb, port_offset, -1, '/');",
          "1337:                     if (port_end_offset == -1) {",
          "1339:                         port_end_offset = tvb_find_guint8(tvb, port_offset, -1, ';');",
          "1340:                     }",
          "1342:                     if (str_to_ip((char*)tvb_get_string(wmem_packet_scope(), tvb, address_offset, port_offset-address_offset),",
          "1343:                                    &media_info->msrp_ipaddr)) {",
          "1345:                         media_info->msrp_port_number = atoi((char*)tvb_get_string(wmem_packet_scope(), tvb, port_offset + 1, port_end_offset - port_offset - 1));",
          "1347:                         media_info->msrp_transport_address_set = TRUE;",
          "1348:                     }",
          "1349:                 }",
          "1350:             }",
          "1351:             break;",
          "1352:         case SDP_H248_ITEM:",
          "1354:             if (strncmp((char*)attribute_value, h324ext_h223lcparm, strlen(msrp_res)) == 0) {",
          "1361:                 gint len;",
          "1362:                 asn1_ctx_t actx;",
          "1364:                 len = (gint)strlen(attribute_value);",
          "1365:                 h245_tvb = ascii_bytes_to_tvb(tvb, pinfo, len, attribute_value);",
          "1368:                    points are different, one is over tpkt and the other is raw",
          "1370:                 if (h245_tvb) {",
          "1371:                     asn1_ctx_init(&actx, ASN1_ENC_PER, TRUE, pinfo);",
          "1372:                     dissect_h245_H223LogicalChannelParameters(h245_tvb, 0, &actx,",
          "1373:                                                               sdp_media_attribute_tree,",
          "1374:                                                               hf_SDPh223LogicalChannelParameters);",
          "1375:                 }",
          "1376:             }",
          "1377:             break;",
          "1378:         case SDP_CRYPTO:",
          "1404:             next_offset = tvb_find_guint8(tvb, offset, -1, ' ');",
          "1405:             if (next_offset==-1) {",
          "1407:                 return;",
          "1408:             }",
          "1409:             tokenlen    = next_offset - offset;",
          "1410:             proto_tree_add_uint(sdp_media_attribute_tree, hf_sdp_crypto_tag, tvb, offset, tokenlen,",
          "1411:                 atoi((char*)tvb_get_string(wmem_packet_scope(), tvb, offset, tokenlen)));",
          "1412:             offset = next_offset + 1;",
          "1415:             next_offset = tvb_find_guint8(tvb, offset, -1, ' ');",
          "1416:             if (next_offset==-1) {",
          "1418:                 return;",
          "1419:             }",
          "1420:             tokenlen    = next_offset - offset;",
          "1421:             parameter_item = proto_tree_add_item(sdp_media_attribute_tree, hf_sdp_crypto_crypto_suite,",
          "1422:                 tvb, offset, tokenlen, ENC_ASCII|ENC_NA);",
          "1423:             if (tvb_strncaseeql(tvb, offset, \"AES_CM_128_HMAC_SHA1_80\", tokenlen) == 0) {",
          "1426:                 if (transport_info->encryption_algorithm == SRTP_ENC_ALG_NOT_SET) {",
          "1427:                     transport_info->encryption_algorithm = SRTP_ENC_ALG_AES_CM;",
          "1428:                     transport_info->auth_algorithm       = SRTP_AUTH_ALG_HMAC_SHA1;",
          "1430:                     transport_info->auth_tag_len         = 10;",
          "1431:                 }",
          "1434:             } else if (tvb_strncaseeql(tvb, offset, \"AES_CM_128_HMAC_SHA1_32\", tokenlen) == 0) {",
          "1436:                 if (transport_info->encryption_algorithm == SRTP_ENC_ALG_NOT_SET) {",
          "1437:                     transport_info->encryption_algorithm = SRTP_ENC_ALG_AES_CM;",
          "1438:                     transport_info->auth_algorithm       = SRTP_AUTH_ALG_HMAC_SHA1;",
          "1440:                     transport_info->auth_tag_len         = 4;",
          "1441:                 }",
          "1444:             } else if (tvb_strncaseeql(tvb, offset, \"F8_128_HMAC_SHA1_80\", tokenlen) == 0) {",
          "1445:                 if (transport_info->encryption_algorithm == SRTP_ENC_ALG_NOT_SET) {",
          "1447:                     transport_info->encryption_algorithm = SRTP_ENC_ALG_AES_F8;",
          "1448:                     transport_info->auth_algorithm       = SRTP_AUTH_ALG_HMAC_SHA1;",
          "1450:                     transport_info->auth_tag_len         = 10;",
          "1451:                 }",
          "1454:             }",
          "1455:             offset = next_offset + 1;",
          "1458:             while (has_more_pars == TRUE) {",
          "1459:                 int       param_end_offset;",
          "1460:                 tvbuff_t *key_salt_tvb;",
          "1461:                 gchar    *data_p = NULL;",
          "1463:                 param_end_offset = tvb_find_guint8(tvb, offset, -1, ';');",
          "1464:                 if (param_end_offset == -1) {",
          "1465:                     has_more_pars = FALSE;",
          "1466:                     param_end_offset = tvb_length(tvb);",
          "1467:                 }",
          "1469:                 next_offset = tvb_find_guint8(tvb, offset, -1, ':');",
          "1470:                 if (next_offset == -1) {",
          "1471:                     expert_add_info(pinfo, parameter_item, &ei_sdp_invalid_key_param);",
          "1472:                     break;",
          "1473:                 }",
          "1475:                 if (tvb_strncaseeql(tvb, offset, \"inline\", next_offset-offset) == 0) {",
          "1476:                     parameter_item = proto_tree_add_text(sdp_media_attribute_tree,",
          "1477:                         tvb, offset, param_end_offset-offset, \"Key parameters\");",
          "1478:                     parameter_tree = proto_item_add_subtree(parameter_item, ett_sdp_crypto_key_parameters);",
          "1481:                     offset      = next_offset +1;",
          "1482:                     next_offset = tvb_find_guint8(tvb, offset, -1, '|');",
          "1483:                     if (next_offset == -1) {",
          "1484:                         tokenlen = param_end_offset - offset;",
          "1485:                     } else {",
          "1486:                         tokenlen = next_offset - offset;",
          "1487:                     }",
          "1488:                     data_p = tvb_get_string(wmem_packet_scope(), tvb, offset, tokenlen);",
          "1489:                     key_salt_tvb = base64_to_tvb(tvb, data_p);",
          "1490:                     add_new_data_source(pinfo, key_salt_tvb, \"Key_Salt_tvb\");",
          "1491:                     if (master_key_length != 0) {",
          "1492:                         proto_tree_add_text(parameter_tree, tvb, offset, tokenlen, \"Key and Salt\");",
          "1493:                         proto_tree_add_item(parameter_tree, hf_sdp_crypto_master_key,",
          "1494:                             key_salt_tvb, 0, master_key_length, ENC_ASCII|ENC_NA);",
          "1495:                         proto_tree_add_item(parameter_tree, hf_sdp_crypto_master_salt,",
          "1496:                             key_salt_tvb, master_key_length, master_salt_length, ENC_ASCII|ENC_NA);",
          "1497:                     } else {",
          "1498:                         proto_tree_add_text(parameter_tree, key_salt_tvb, 0, -1, \"Key and Salt\");",
          "1499:                     }",
          "1502:                     if (next_offset != -1) {",
          "1503:                         offset = next_offset + 1;",
          "1504:                         next_offset = tvb_find_guint8(tvb, offset, -1, '|');",
          "1505:                         if (next_offset == -1) {",
          "1506:                             if (next_offset < param_end_offset){",
          "1507:                                 next_offset = param_end_offset;",
          "1508:                             }",
          "1509:                         }",
          "1510:                         if (next_offset != -1) {",
          "1512:                             tokenlen = next_offset - offset;",
          "1513:                             proto_tree_add_item(parameter_tree, hf_sdp_crypto_lifetime,",
          "1514:                                 tvb, offset, tokenlen, ENC_ASCII|ENC_NA);",
          "1515:                             offset   = next_offset + 1;",
          "1516:                         }",
          "1521:                         if (offset>param_end_offset) {",
          "1522:                             next_offset = -1;",
          "1523:                         } else {",
          "1524:                             next_offset = tvb_find_guint8(tvb, offset, -1, ':');",
          "1525:                         }",
          "1526:                         if (next_offset != -1) {",
          "1527:                             tokenlen    = next_offset - offset;",
          "1528:                             proto_tree_add_item(parameter_tree, hf_sdp_crypto_mki, tvb, offset, tokenlen, ENC_ASCII|ENC_NA);",
          "1529:                             offset      = next_offset + 1;",
          "1532:                             next_offset = param_end_offset;",
          "1533:                             tokenlen    = next_offset - offset;",
          "1537:                             transport_info->mki_len = atoi((char*)tvb_get_string(wmem_packet_scope(), tvb, offset, tokenlen));",
          "1538:                             proto_tree_add_item(parameter_tree, hf_sdp_crypto_mki_length,",
          "1539:                                 tvb, offset, tokenlen, ENC_ASCII|ENC_NA);",
          "1540:                         }",
          "1541:                     }",
          "1542:                     offset = param_end_offset;",
          "1543:                 } else {",
          "1544:                     break;",
          "1545:                 }",
          "1546:             }",
          "1548:           break;",
          "1549:         default:",
          "1551:             proto_tree_add_item(sdp_media_attribute_tree, hf_media_attribute_value,",
          "1552:                                 tvb, offset, -1, ENC_ASCII|ENC_NA);",
          "1553:             break;",
          "1554:     }",
          "1560:     if (hf == hf_owner) {",
          "1561:         dissect_sdp_owner(tvb, ti);",
          "1562:     } else if (hf == hf_connection_info) {",
          "1563:         dissect_sdp_connection_info(tvb, ti, media_info);",
          "1564:     } else if (hf == hf_bandwidth) {",
          "1565:         dissect_sdp_bandwidth(tvb, ti);",
          "1566:     } else if (hf == hf_time) {",
          "1567:         dissect_sdp_time(tvb, ti);",
          "1568:     } else if (hf == hf_repeat_time) {",
          "1569:         dissect_sdp_repeat_time(tvb, ti);",
          "1570:     } else if (hf == hf_timezone) {",
          "1571:         dissect_sdp_timezone(tvb, ti);",
          "1572:     } else if (hf == hf_encryption_key) {",
          "1573:         dissect_sdp_encryption_key(tvb, ti);",
          "1574:     } else if (hf == hf_session_attribute) {",
          "1575:         dissect_sdp_session_attribute(tvb, pinfo, ti);",
          "1576:     } else if (hf == hf_media) {",
          "1577:         dissect_sdp_media(tvb, ti, transport_info, media_info);",
          "1578:     } else if (hf == hf_media_attribute) {",
          "1579:         dissect_sdp_media_attribute(tvb, pinfo, ti, length, transport_info, media_info);",
          "1580:     }",
          "1587:     gint8 n, transport_index;",
          "1588:     guint proto_bitmask;",
          "1590:     for (n = 0; (n < media_info->media_count) && (n+start_transport_info_count < SDP_MAX_RTP_CHANNELS); n++)",
          "1591:     {",
          "1592:         transport_index = n+start_transport_info_count;",
          "1593:         if (media_info->media_port[n] != NULL) {",
          "1594:             transport_info->media_port[transport_index] = (int)strtol(media_info->media_port[n], NULL, 10);",
          "1597:         if (media_info->media_proto[n] != NULL) {",
          "1601:             if (global_sdp_establish_conversation) {",
          "1602:                 proto_bitmask = 0;",
          "1606:                 if (!strcmp(media_info->media_proto[n],\"RTP/AVP\")) {",
          "1607:                     transport_info->proto_bitmask[transport_index] |= SDP_RTP_PROTO;",
          "1608:                     proto_bitmask |= SDP_RTP_PROTO;",
          "1609:                 }",
          "1611:                 else if (!strcmp(media_info->media_proto[n],\"RTP/SAVP\")) {",
          "1612:                     transport_info->proto_bitmask[transport_index] |= SDP_SRTP_PROTO;",
          "1613:                     proto_bitmask |= SDP_SRTP_PROTO;",
          "1614:                 }",
          "1616:                 else if ((!strcmp(media_info->media_proto[n],\"UDPTL\")) ||",
          "1617:                     (!strcmp(media_info->media_proto[n],\"udptl\"))) {",
          "1618:                     transport_info->proto_bitmask[transport_index] |= SDP_T38_PROTO;",
          "1619:                     proto_bitmask |= SDP_T38_PROTO;",
          "1620:                 }",
          "1622:                 else if (!strcmp(media_info->media_proto[n],\"msrp/tcp\")) {",
          "1623:                     transport_info->proto_bitmask[transport_index] |= SDP_MSRP_PROTO;",
          "1624:                     proto_bitmask |= SDP_MSRP_PROTO;",
          "1625:                 }",
          "1627:                 else if ((!strcmp(media_info->media_proto[n],\"UDPSPRT\")) ||",
          "1628:                     (!strcmp(media_info->media_proto[n],\"udpsprt\"))) {",
          "1629:                     transport_info->proto_bitmask[transport_index] |= SDP_SPRT_PROTO;",
          "1630:                     proto_bitmask |= SDP_SPRT_PROTO;",
          "1631:                 }",
          "1634:                 if (transport_info->media_port[transport_index] == 0) {",
          "1636:                        basically start_transport_info_count is 0 for the offer, and >0 for the answer, so we",
          "1637:                        check that and if this is the answer, then we go set the offer's paired stream to 0.",
          "1638:                        If it turns out we got a port=0 in the offer, we don't care and it's ok to let the",
          "1640:                     if (start_transport_info_count > 0 && (proto_bitmask & transport_info->proto_bitmask[n])) {",
          "1641:                         transport_info->media_port[n] = 0;",
          "1642:                     }",
          "1643:                 }",
          "1644:             }",
          "1647:         if ((media_info->connection_address != NULL) &&",
          "1648:             (media_info->connection_type != NULL)) {",
          "1649:           if (strcmp(media_info->connection_type, \"IP4\") == 0) {",
          "1650:             transport_info->src_addr[transport_index].data = wmem_alloc(wmem_file_scope(), 4);",
          "1651:             if (str_to_ip(media_info->connection_address, (void*)transport_info->src_addr[transport_index].data)) {",
          "1653:               transport_info->proto_bitmask[transport_index] |= SDP_IPv4;",
          "1654:               transport_info->src_addr[transport_index].type = AT_IPv4;",
          "1655:               transport_info->src_addr[transport_index].len  = 4;",
          "1656:             }",
          "1657:           } else if (strcmp(media_info->connection_type, \"IP6\") == 0) {",
          "1658:               transport_info->src_addr[transport_index].data = wmem_alloc(wmem_file_scope(), 16);",
          "1659:               if (str_to_ip6(media_info->connection_address, (void*)transport_info->src_addr[transport_index].data)) {",
          "1661:                 transport_info->proto_bitmask[transport_index] |= SDP_IPv6;",
          "1662:                 transport_info->src_addr[transport_index].type = AT_IPv6;",
          "1663:                 transport_info->src_addr[transport_index].len  = 16;",
          "1664:               }",
          "1670:         if ((transport_info->proto_bitmask[transport_index] & SDP_MSRP_PROTO) &&",
          "1671:             (transport_info->proto_bitmask[transport_index] & SDP_MSRP_IPv4) &&",
          "1672:               msrp_handle) {",
          "1673:             transport_info->src_addr[transport_index].type = AT_IPv4;",
          "1674:             transport_info->src_addr[transport_index].len  = 4;",
          "1675:             transport_info->src_addr[transport_index].data = wmem_memdup(wmem_file_scope(), media_info->msrp_ipaddr, 4);",
          "1676:             transport_info->media_port[transport_index] = media_info->msrp_port_number;",
          "1679:         if ((media_info->media_type[transport_index] != NULL) &&",
          "1680:             (strcmp(media_info->media_type[transport_index], \"video\") == 0)) {",
          "1681:             transport_info->proto_bitmask[transport_index] |= SDP_VIDEO;",
          "1682:         }",
          "1689:     gint        offset = 0, next_offset, n;",
          "1690:     int         linelen;",
          "1691:     gboolean    in_media_description = FALSE;",
          "1692:     guchar      type, delim;",
          "1693:     const int   tokenoffset = 2;",
          "1694:     int         hf     = -1;",
          "1695:     gint        start_transport_info_count = 0;",
          "1696:     transport_info_t* transport_info = NULL;",
          "1697:     disposable_media_info_t media_info;",
          "1699:     struct srtp_info *srtp_info = NULL;",
          "1702:     if (pinfo->fd->flags.visited)",
          "1703:       return;",
          "1705:     memset(&media_info, 0, sizeof(media_info));",
          "1708:         transport_info = (transport_info_t*)wmem_tree_lookup32( sdp_transport_reqs, request_frame );",
          "1709:     if (transport_info == NULL) {",
          "1710:         transport_info = wmem_new0(wmem_file_scope(), transport_info_t);",
          "1711:         transport_info->media_count = -1;",
          "1713:         for (n = 0; n < SDP_NO_OF_PT; n++) {",
          "1714:             transport_info->encoding_name[n] = (char*)UNKNOWN_ENCODING;",
          "1715:         }",
          "1716:         for (n = 0; n < SDP_MAX_RTP_CHANNELS; n++) {",
          "1717:             transport_info->media[n].rtp_dyn_payload =",
          "1718:                 g_hash_table_new(g_int_hash, g_int_equal);",
          "1719:             transport_info->media[n].set_rtp = FALSE;",
          "1720:         }",
          "1722:         if (request_frame != 0)",
          "1723:             wmem_tree_insert32(sdp_transport_reqs, request_frame, (void *)transport_info);",
          "1724:     }",
          "1726:     if (exchange_type != SDP_EXCHANGE_OFFER)",
          "1727:         wmem_tree_insert32(sdp_transport_rsps, pinfo->fd->num, (void *)transport_info);",
          "1732:     if ((transport_info->sdp_status == SDP_EXCHANGE_ANSWER_REJECT) ||",
          "1733:         (transport_info->sdp_status == SDP_EXCHANGE_ANSWER_ACCEPT))",
          "1734:         return;",
          "1736:     if (transport_info->media_count > 0)",
          "1737:         start_transport_info_count = transport_info->media_count;",
          "1742:     while (tvb_reported_length_remaining(tvb, offset) > 0) {",
          "1746:         linelen = tvb_find_line_end_unquoted(tvb, offset, -1, &next_offset);",
          "1751:         if (linelen < 2)",
          "1752:             break;",
          "1754:         type  = tvb_get_guint8(tvb, offset);",
          "1755:         delim = tvb_get_guint8(tvb, offset + 1);",
          "1756:         if (delim != '=') {",
          "1757:             offset = next_offset;",
          "1758:             continue;",
          "1759:         }",
          "1764:         switch (type) {",
          "1765:             case 'c':",
          "1766:                 hf = hf_connection_info;",
          "1767:                 break;",
          "1768:             case 'm':",
          "1769:                 hf = hf_media;",
          "1772:                 if (((transport_info->media_count < 0) && (in_media_description == FALSE)) || (transport_info->media_count < (SDP_MAX_RTP_CHANNELS-1)))",
          "1773:                     transport_info->media_count++;",
          "1775:                 if (in_media_description && (media_info.media_count < (SDP_MAX_RTP_CHANNELS-1)))",
          "1776:                     media_info.media_count++;",
          "1778:                 in_media_description = TRUE;",
          "1779:                 break;",
          "1780:             case 'a':",
          "1781:                 if (in_media_description) {",
          "1782:                     hf = hf_media_attribute;",
          "1783:                 } else {",
          "1784:                     hf = hf_session_attribute;",
          "1785:                 }",
          "1786:                 break;",
          "1787:             default:",
          "1788:                 hf = hf_unknown;",
          "1789:                 break;",
          "1790:         }",
          "1792:         if (hf != hf_unknown)",
          "1793:         {",
          "1794:             call_sdp_subdissector(tvb_new_subset(tvb, offset + tokenoffset,",
          "1795:                                                    linelen - tokenoffset,",
          "1796:                                                    linelen - tokenoffset),",
          "1797:                                     pinfo,",
          "1798:                                     hf, NULL, linelen-tokenoffset, transport_info, &media_info);",
          "1799:         }",
          "1801:         offset = next_offset;",
          "1804:     if (in_media_description) {",
          "1806:         if (transport_info->media_count < (SDP_MAX_RTP_CHANNELS-1))",
          "1807:             transport_info->media_count++;",
          "1808:         if (media_info.media_count < (SDP_MAX_RTP_CHANNELS-1))",
          "1809:             media_info.media_count++;",
          "1815:     convert_disposable_media(transport_info, &media_info, start_transport_info_count);",
          "1818:     if ((exchange_type == SDP_EXCHANGE_ANSWER_ACCEPT) &&",
          "1819:         (transport_info->sdp_status == SDP_EXCHANGE_OFFER)) {",
          "1821:         for (n = 0; n <= transport_info->media_count; n++) {",
          "1822:           guint32 current_rtp_port = 0;",
          "1825:             if ((transport_info->media_port[n] != 0) &&",
          "1826:                 (transport_info->proto_bitmask[n] & (SDP_RTP_PROTO|SDP_SRTP_PROTO)) &&",
          "1827:                 (transport_info->proto_bitmask[n] & (SDP_IPv4|SDP_IPv6))) {",
          "1829:                 if (transport_info->proto_bitmask[n] & SDP_SRTP_PROTO) {",
          "1830:                     srtp_info = wmem_new0(wmem_file_scope(), struct srtp_info);",
          "1831:                     if (transport_info->encryption_algorithm != SRTP_ENC_ALG_NOT_SET) {",
          "1832:                         srtp_info->encryption_algorithm = transport_info->encryption_algorithm;",
          "1833:                         srtp_info->auth_algorithm       = transport_info->auth_algorithm;",
          "1834:                         srtp_info->mki_len              = transport_info->mki_len;",
          "1835:                         srtp_info->auth_tag_len         = transport_info->auth_tag_len;",
          "1837:                     }",
          "1840:                     srtp_add_address(pinfo, &transport_info->src_addr[n], transport_info->media_port[n], 0, \"SDP\", request_frame,",
          "1841:                                     (transport_info->proto_bitmask[n] & SDP_VIDEO) ? TRUE : FALSE,",
          "1842:                                      transport_info->media[n].rtp_dyn_payload, srtp_info);",
          "1843:                 } else {",
          "1844:                     rtp_add_address(pinfo, &transport_info->src_addr[n], transport_info->media_port[n], 0, \"SDP\", request_frame,",
          "1845:                                     (transport_info->proto_bitmask[n] & SDP_VIDEO) ? TRUE : FALSE,",
          "1846:                                     transport_info->media[n].rtp_dyn_payload);",
          "1847:                 }",
          "1848:                 transport_info->media[n].set_rtp = TRUE;",
          "1850:                 current_rtp_port = transport_info->media_port[n];",
          "1852:                 if (rtcp_handle) {",
          "1853:                     if (transport_info->proto_bitmask[n] & SDP_SRTP_PROTO) {",
          "1854:                         srtcp_add_address(pinfo, &transport_info->src_addr[n], transport_info->media_port[n]+1, 0, \"SDP\", request_frame, srtp_info);",
          "1855:                     } else {",
          "1856:                         rtcp_add_address(pinfo, &transport_info->src_addr[n], transport_info->media_port[n]+1, 0, \"SDP\", request_frame);",
          "1857:                     }",
          "1858:                 }",
          "1859:             }",
          "1862:             if ((transport_info->proto_bitmask[n] & SDP_SPRT_PROTO) &&",
          "1863:                 (transport_info->proto_bitmask[n] & (SDP_IPv4|SDP_IPv6)) &&",
          "1864:                 (sprt_handle)) {",
          "1866:                 if (transport_info->media_port[n] == 0 && current_rtp_port) {",
          "1867:                     sprt_add_address(pinfo, &transport_info->src_addr[n], current_rtp_port,",
          "1869:                 } else {",
          "1870:                     sprt_add_address(pinfo, &transport_info->src_addr[n], transport_info->media_port[n], 0, \"SDP\", pinfo->fd->num);",
          "1871:                 }",
          "1872:             }",
          "1875:             if ((transport_info->media_port[n] != 0) &&",
          "1876:                 !transport_info->media[n].set_rtp &&",
          "1877:                 (transport_info->proto_bitmask[n] & SDP_T38_PROTO) &&",
          "1878:                 (transport_info->proto_bitmask[n] & SDP_IPv4)) {",
          "1879:                 t38_add_address(pinfo, &transport_info->src_addr[n], transport_info->media_port[n], 0, \"SDP\", pinfo->fd->num);",
          "1883:                rather than connection information of media session line",
          "1885:             if ((transport_info->proto_bitmask[n] & SDP_MSRP_PROTO) &&",
          "1886:                 (transport_info->proto_bitmask[n] & SDP_MSRP_IPv4) &&",
          "1887:                 msrp_handle) {",
          "1888:                 msrp_add_address(pinfo, &transport_info->src_addr[n], transport_info->media_port[n], \"SDP\", pinfo->fd->num);",
          "1889:             }",
          "1892:             if (!transport_info->media[n].set_rtp)",
          "1893:             {",
          "1894:                 rtp_free_hash_dyn_payload(transport_info->media[n].rtp_dyn_payload);",
          "1895:                 transport_info->media[n].rtp_dyn_payload = NULL;",
          "1896:             }",
          "1901:         if (transport_info->media_count == -1)",
          "1903:             for (n = 0; n < SDP_MAX_RTP_CHANNELS; n++)",
          "1904:             {",
          "1905:                 if (!transport_info->media[n].set_rtp)",
          "1906:                 {",
          "1907:                     rtp_free_hash_dyn_payload(transport_info->media[n].rtp_dyn_payload);",
          "1908:                     transport_info->media[n].rtp_dyn_payload = NULL;",
          "1909:                 }",
          "1910:             }",
          "1912:         else",
          "1914:             for (n = transport_info->media_count; n < SDP_MAX_RTP_CHANNELS; n++)",
          "1915:             {",
          "1916:                 if (!transport_info->media[n].set_rtp)",
          "1917:                 {",
          "1918:                     rtp_free_hash_dyn_payload(transport_info->media[n].rtp_dyn_payload);",
          "1919:                     transport_info->media[n].rtp_dyn_payload = NULL;",
          "1920:                 }",
          "1921:             }",
          "1923:         transport_info->sdp_status = SDP_EXCHANGE_ANSWER_ACCEPT;",
          "1925:     } else if ((exchange_type == SDP_EXCHANGE_ANSWER_REJECT) &&",
          "1926:                (transport_info->sdp_status != SDP_EXCHANGE_ANSWER_REJECT)) {",
          "1929:         for (n = 0; n < SDP_MAX_RTP_CHANNELS; n++)",
          "1930:         {",
          "1931:             if (!transport_info->media[n].set_rtp)",
          "1932:             {",
          "1933:                 rtp_free_hash_dyn_payload(transport_info->media[n].rtp_dyn_payload);",
          "1934:                 transport_info->media[n].rtp_dyn_payload = NULL;",
          "1935:             }",
          "1936:         }",
          "1938:         transport_info->sdp_status = SDP_EXCHANGE_ANSWER_REJECT;",
          "1939:     }",
          "1944:     transport_info_t* transport_info = NULL;",
          "1946:     if (request_frame != 0) {",
          "1947:         transport_info = (transport_info_t*)wmem_tree_lookup32( sdp_transport_reqs, request_frame );",
          "1948:         if (transport_info != NULL) {",
          "1949:             wmem_tree_insert32(sdp_transport_reqs, current_frame, (void *)transport_info);",
          "1950:         }",
          "1957:     proto_tree *sdp_tree;",
          "1958:     proto_item *ti, *sub_ti;",
          "1959:     gint        offset = 0, next_offset, n, i;",
          "1960:     int         linelen;",
          "1961:     gboolean    in_media_description;",
          "1962:     guchar      type, delim;",
          "1963:     int         datalen, tokenoffset, hf = -1;",
          "1964:     char       *string;",
          "1966:     transport_info_t  local_transport_info;",
          "1967:     transport_info_t* transport_info = NULL;",
          "1968:     disposable_media_info_t media_info;",
          "1970:     sdp_packet_info  *sdp_pi;",
          "1971:     struct srtp_info *srtp_info = NULL;",
          "1974:     sdp_pi = wmem_new(wmem_packet_scope(), sdp_packet_info);",
          "1975:     sdp_pi->summary_str[0] = '\\0';",
          "1977:     if (!pinfo->fd->flags.visited) {",
          "1978:         transport_info = (transport_info_t*)wmem_tree_lookup32( sdp_transport_reqs, pinfo->fd->num );",
          "1980:         if (transport_info == NULL) {",
          "1982:           transport_info = (transport_info_t*)wmem_tree_lookup32( sdp_transport_rsps, pinfo->fd->num );",
          "1983:         }",
          "1984:     }",
          "1986:     if (transport_info == NULL) {",
          "1987:       transport_info = &local_transport_info;",
          "1988:     }",
          "1991:     memset(&local_transport_info, 0, sizeof(local_transport_info));",
          "1992:     local_transport_info.media_count = -1;",
          "1994:     for (n = 0; n < SDP_NO_OF_PT; n++) {",
          "1995:         local_transport_info.encoding_name[n] = (char*)UNKNOWN_ENCODING;",
          "1996:     }",
          "1997:     for (n = 0; n < SDP_MAX_RTP_CHANNELS; n++) {",
          "1998:         local_transport_info.media[n].rtp_dyn_payload =",
          "1999:             g_hash_table_new(g_int_hash, g_int_equal);",
          "2000:         local_transport_info.media[n].set_rtp = FALSE;",
          "2001:     }",
          "2003:     memset(&media_info, 0, sizeof(media_info));",
          "2019:     col_append_str(pinfo->cinfo, COL_PROTOCOL, \"/SDP\");",
          "2028:     ti = proto_tree_add_item(tree, proto_sdp, tvb, offset, -1, ENC_NA);",
          "2029:     sdp_tree = proto_item_add_subtree(ti, ett_sdp);",
          "2034:     in_media_description = FALSE;",
          "2036:     while (tvb_reported_length_remaining(tvb, offset) > 0) {",
          "2040:         linelen = tvb_find_line_end_unquoted(tvb, offset, -1, &next_offset);",
          "2045:         if (linelen < 2)",
          "2046:             break;",
          "2048:         type  = tvb_get_guint8(tvb, offset);",
          "2049:         delim = tvb_get_guint8(tvb, offset + 1);",
          "2050:         if (delim != '=') {",
          "2051:             proto_item *ti2 = proto_tree_add_item(sdp_tree, hf_invalid, tvb, offset, linelen, ENC_ASCII|ENC_NA);",
          "2052:             expert_add_info(pinfo, ti2, &ei_sdp_invalid_line);",
          "2053:             offset = next_offset;",
          "2054:             continue;",
          "2055:         }",
          "2060:         switch (type) {",
          "2061:             case 'v':",
          "2062:                 hf = hf_protocol_version;",
          "2063:                 break;",
          "2064:             case 'o':",
          "2065:                 hf = hf_owner;",
          "2066:                 break;",
          "2067:             case 's':",
          "2068:                 hf = hf_session_name;",
          "2069:                 break;",
          "2070:             case 'i':",
          "2071:                 if (in_media_description) {",
          "2072:                   hf = hf_media_title;",
          "2073:                 } else {",
          "2074:                   hf = hf_session_info;",
          "2075:                 }",
          "2076:                 break;",
          "2077:             case 'u':",
          "2078:                 hf = hf_uri;",
          "2079:                 break;",
          "2080:             case 'e':",
          "2081:                 hf = hf_email;",
          "2082:                 break;",
          "2083:             case 'p':",
          "2084:                 hf = hf_phone;",
          "2085:                 break;",
          "2086:             case 'c':",
          "2087:                 hf = hf_connection_info;",
          "2088:                 break;",
          "2089:             case 'b':",
          "2090:                 hf = hf_bandwidth;",
          "2091:                 break;",
          "2092:             case 't':",
          "2093:                 hf = hf_time;",
          "2094:                 break;",
          "2095:             case 'r':",
          "2096:                 hf = hf_repeat_time;",
          "2097:                 break;",
          "2098:             case 'm':",
          "2099:                 hf = hf_media;",
          "2102:                 if (local_transport_info.media_count < (SDP_MAX_RTP_CHANNELS-1))",
          "2103:                     local_transport_info.media_count++;",
          "2105:                 if (in_media_description && (media_info.media_count < (SDP_MAX_RTP_CHANNELS-1)))",
          "2106:                     media_info.media_count++;",
          "2108:                 in_media_description = TRUE;",
          "2109:                 break;",
          "2110:             case 'k':",
          "2111:                 hf = hf_encryption_key;",
          "2112:                 break;",
          "2113:             case 'a':",
          "2114:                 if (in_media_description) {",
          "2115:                     hf = hf_media_attribute;",
          "2116:                 } else {",
          "2117:                     hf = hf_session_attribute;",
          "2118:                 }",
          "2119:                 break;",
          "2120:             case 'z':",
          "2121:                 hf = hf_timezone;",
          "2122:                 break;",
          "2123:             default:",
          "2124:                 hf = hf_unknown;",
          "2125:                 break;",
          "2127:         tokenoffset = 2;",
          "2128:         if (hf == hf_unknown)",
          "2129:             tokenoffset = 0;",
          "2130:         string = (char*)tvb_get_string(wmem_packet_scope(), tvb, offset + tokenoffset,",
          "2131:                                                  linelen - tokenoffset);",
          "2132:         sub_ti = proto_tree_add_string(sdp_tree, hf, tvb, offset, linelen,",
          "2133:                                        string);",
          "2135:         call_sdp_subdissector(tvb_new_subset(tvb, offset + tokenoffset,",
          "2136:                                              linelen - tokenoffset,",
          "2137:                                              linelen - tokenoffset),",
          "2138:                               pinfo,",
          "2139:                               hf, sub_ti, linelen-tokenoffset,",
          "2140:                               &local_transport_info, &media_info);",
          "2142:         offset = next_offset;",
          "2145:     if (in_media_description) {",
          "2147:         if (local_transport_info.media_count < (SDP_MAX_RTP_CHANNELS-1))",
          "2148:             local_transport_info.media_count++;",
          "2149:         if (media_info.media_count < (SDP_MAX_RTP_CHANNELS-1))",
          "2150:             media_info.media_count++;",
          "2156:     if (transport_info == &local_transport_info)",
          "2157:         convert_disposable_media(transport_info, &media_info, 0);",
          "2159:     for (n = 0; n < local_transport_info.media_count; n++)",
          "2160:     {",
          "2166:         guint32 current_rtp_port = 0;",
          "2168:         if ((!pinfo->fd->flags.visited) && (transport_info == &local_transport_info) &&",
          "2169:             (transport_info->media_port[n] != 0) &&",
          "2170:             (transport_info->proto_bitmask[n] & (SDP_RTP_PROTO|SDP_SRTP_PROTO)) &&",
          "2171:             (transport_info->proto_bitmask[n] & (SDP_IPv4|SDP_IPv6))) {",
          "2173:             if (transport_info->proto_bitmask[n] & SDP_SRTP_PROTO) {",
          "2174:                 srtp_info = wmem_new0(wmem_file_scope(), struct srtp_info);",
          "2175:                 if (transport_info->encryption_algorithm != SRTP_ENC_ALG_NOT_SET) {",
          "2176:                     srtp_info->encryption_algorithm = transport_info->encryption_algorithm;",
          "2177:                     srtp_info->auth_algorithm       = transport_info->auth_algorithm;",
          "2178:                     srtp_info->mki_len              = transport_info->mki_len;",
          "2179:                     srtp_info->auth_tag_len         = transport_info->auth_tag_len;",
          "2180:                 }",
          "2181:                 srtp_add_address(pinfo, &transport_info->src_addr[n], transport_info->media_port[n], 0, \"SDP\", pinfo->fd->num,",
          "2182:                                 (transport_info->proto_bitmask[n] & SDP_VIDEO) ? TRUE : FALSE,",
          "2183:                                  transport_info->media[n].rtp_dyn_payload, srtp_info);",
          "2184:             } else {",
          "2185:                 rtp_add_address(pinfo, &transport_info->src_addr[n], transport_info->media_port[n], 0, \"SDP\", pinfo->fd->num,",
          "2186:                                 (transport_info->proto_bitmask[n] & SDP_VIDEO) ? TRUE : FALSE,",
          "2187:                                 transport_info->media[n].rtp_dyn_payload);",
          "2188:             }",
          "2189:             transport_info->media[n].set_rtp = TRUE;",
          "2191:             current_rtp_port = transport_info->media_port[n];",
          "2193:             if (rtcp_handle) {",
          "2194:                 if (transport_info->proto_bitmask[n] & SDP_SRTP_PROTO) {",
          "2195:                     srtcp_add_address(pinfo, &transport_info->src_addr[n], transport_info->media_port[n]+1, 0, \"SDP\", pinfo->fd->num, srtp_info);",
          "2196:                 } else {",
          "2197:                     rtcp_add_address(pinfo, &transport_info->src_addr[n], transport_info->media_port[n]+1, 0, \"SDP\", pinfo->fd->num);",
          "2198:                 }",
          "2199:             }",
          "2200:         }",
          "2204:         if ((!pinfo->fd->flags.visited) && (transport_info == &local_transport_info) &&",
          "2205:             (transport_info->proto_bitmask[n] & SDP_SPRT_PROTO) &&",
          "2206:             (transport_info->proto_bitmask[n] & (SDP_IPv4|SDP_IPv6)) &&",
          "2207:             (sprt_handle)) {",
          "2209:             if (transport_info->media_port[n] == 0 && current_rtp_port) {",
          "2210:                 sprt_add_address(pinfo, &transport_info->src_addr[n], current_rtp_port,",
          "2212:             } else {",
          "2213:                 sprt_add_address(pinfo, &transport_info->src_addr[n], transport_info->media_port[n], 0, \"SDP\", pinfo->fd->num);",
          "2214:             }",
          "2215:         }",
          "2219:         if ((!pinfo->fd->flags.visited) && (transport_info == &local_transport_info) &&",
          "2220:             (transport_info->media_port[n] != 0) &&",
          "2221:             !transport_info->media[n].set_rtp &&",
          "2222:             (transport_info->proto_bitmask[n] & SDP_T38_PROTO) &&",
          "2223:             (transport_info->proto_bitmask[n] & SDP_IPv4)) {",
          "2224:             t38_add_address(pinfo, &transport_info->src_addr[n], transport_info->media_port[n], 0, \"SDP\", pinfo->fd->num);",
          "2225:         }",
          "2230:         if ((!pinfo->fd->flags.visited) && (transport_info == &local_transport_info) &&",
          "2231:             (transport_info->proto_bitmask[n] & SDP_MSRP_PROTO) &&",
          "2232:             (transport_info->proto_bitmask[n] & SDP_MSRP_IPv4) &&",
          "2233:             msrp_handle) {",
          "2234:             msrp_add_address(pinfo, &transport_info->src_addr[n], transport_info->media_port[n], \"SDP\", pinfo->fd->num);",
          "2235:         }",
          "2237:         if (local_transport_info.media_port[n] != 0) {",
          "2241:             for (i = 0; i < local_transport_info.media[n].pt_count; i++)",
          "2242:             {",
          "2244:                 if ((local_transport_info.media[n].pt[i] >= 96) && (local_transport_info.media[n].pt[i] <= 127)) {",
          "2245:                     encoding_name_and_rate_t *encoding_name_and_rate_pt =",
          "2246:                         (encoding_name_and_rate_t *)g_hash_table_lookup(",
          "2247:                         local_transport_info.media[n].rtp_dyn_payload,",
          "2248:                         &local_transport_info.media[n].pt[i]);",
          "2249:                     if (encoding_name_and_rate_pt) {",
          "2250:                         if (strlen(sdp_pi->summary_str))",
          "2251:                             g_strlcat(sdp_pi->summary_str, \" \", 50);",
          "2252:                         g_strlcat(sdp_pi->summary_str, encoding_name_and_rate_pt->encoding_name, 50);",
          "2253:                     } else {",
          "2254:                         char num_pt[10];",
          "2255:                         g_snprintf(num_pt, 10, \"%u\", local_transport_info.media[n].pt[i]);",
          "2256:                         if (strlen(sdp_pi->summary_str))",
          "2257:                             g_strlcat(sdp_pi->summary_str, \" \", 50);",
          "2258:                         g_strlcat(sdp_pi->summary_str, num_pt, 50);",
          "2259:                       }",
          "2260:                 } else {",
          "2261:                     if (strlen(sdp_pi->summary_str))",
          "2262:                         g_strlcat(sdp_pi->summary_str, \" \", 50);",
          "2263:                     g_strlcat(sdp_pi->summary_str,",
          "2264:                               val_to_str_ext(local_transport_info.media[n].pt[i], &rtp_payload_type_short_vals_ext, \"%u\"),",
          "2265:                               50);",
          "2266:                 }",
          "2267:             }",
          "2268:         }",
          "2272:         if ((transport_info == &local_transport_info) &&",
          "2273:             !transport_info->media[n].set_rtp)",
          "2274:         {",
          "2275:             rtp_free_hash_dyn_payload(transport_info->media[n].rtp_dyn_payload);",
          "2276:             transport_info->media[n].rtp_dyn_payload = NULL;",
          "2277:         }",
          "2282:         if ((local_transport_info.media_port[n] != 0) &&",
          "2283:             (local_transport_info.proto_bitmask[n] & SDP_T38_PROTO)) {",
          "2285:                 g_strlcat(sdp_pi->summary_str, \" \", 50);",
          "2286:             g_strlcat(sdp_pi->summary_str, \"t38\", 50);",
          "2292:     if (transport_info == &local_transport_info) {",
          "2293:         for (n = transport_info->media_count; n < SDP_MAX_RTP_CHANNELS; n++)",
          "2294:         {",
          "2295:             if (!transport_info->media[n].set_rtp)",
          "2296:             {",
          "2297:                 rtp_free_hash_dyn_payload(transport_info->media[n].rtp_dyn_payload);",
          "2298:                 transport_info->media[n].rtp_dyn_payload = NULL;",
          "2299:             }",
          "2300:         }",
          "2303:     datalen = tvb_length_remaining(tvb, offset);",
          "2304:     if (datalen > 0) {",
          "2305:         proto_tree_add_text(sdp_tree, tvb, offset, datalen, \"Data (%d bytes)\",  datalen);",
          "2308:     tap_queue_packet(sdp_tap, pinfo, sdp_pi);",
          "2314:     static hf_register_info hf[] = {",
          "2315:         { &hf_protocol_version,",
          "2316:             { \"Session Description Protocol Version (v)\", \"sdp.version\",",
          "2317:               FT_STRING, BASE_NONE, NULL, 0x0,",
          "2318:               NULL, HFILL }",
          "2319:         },",
          "2320:         { &hf_owner,",
          "2321:             { \"Owner/Creator, Session Id (o)\",",
          "2322:               \"sdp.owner\", FT_STRING, BASE_NONE, NULL,",
          "2323:               0x0, NULL, HFILL}",
          "2324:         },",
          "2325:         { &hf_session_name,",
          "2326:             { \"Session Name (s)\", \"sdp.session_name\",",
          "2327:               FT_STRING, BASE_NONE, NULL, 0x0,",
          "2328:               NULL, HFILL }",
          "2329:         },",
          "2330:         { &hf_session_info,",
          "2331:             { \"Session Information (i)\", \"sdp.session_info\",",
          "2332:               FT_STRING, BASE_NONE, NULL, 0x0,",
          "2333:               NULL, HFILL }",
          "2334:         },",
          "2335:         { &hf_uri,",
          "2336:             { \"URI of Description (u)\", \"sdp.uri\",",
          "2337:               FT_STRING, BASE_NONE, NULL, 0x0,",
          "2338:               NULL, HFILL }",
          "2339:         },",
          "2340:         { &hf_email,",
          "2341:             { \"E-mail Address (e)\", \"sdp.email\",",
          "2342:               FT_STRING, BASE_NONE, NULL, 0x0,",
          "2343:               \"E-mail Address\", HFILL }",
          "2344:         },",
          "2345:         { &hf_phone,",
          "2346:             { \"Phone Number (p)\", \"sdp.phone\",",
          "2347:               FT_STRING, BASE_NONE, NULL, 0x0,",
          "2348:               NULL, HFILL }",
          "2349:         },",
          "2350:         { &hf_connection_info,",
          "2351:             { \"Connection Information (c)\", \"sdp.connection_info\",",
          "2352:               FT_STRING, BASE_NONE, NULL, 0x0,",
          "2353:               NULL, HFILL }",
          "2354:         },",
          "2355:         { &hf_bandwidth,",
          "2356:             { \"Bandwidth Information (b)\", \"sdp.bandwidth\",",
          "2357:               FT_STRING, BASE_NONE, NULL, 0x0,",
          "2358:               NULL, HFILL }",
          "2359:         },",
          "2360:         { &hf_timezone,",
          "2361:             { \"Time Zone Adjustments (z)\", \"sdp.timezone\",",
          "2362:               FT_STRING, BASE_NONE, NULL, 0x0,",
          "2363:               NULL, HFILL }",
          "2364:         },",
          "2365:         { &hf_encryption_key,",
          "2366:             { \"Encryption Key (k)\", \"sdp.encryption_key\",",
          "2367:               FT_STRING, BASE_NONE, NULL, 0x0,",
          "2368:               NULL, HFILL }",
          "2369:         },",
          "2370:         { &hf_session_attribute,",
          "2371:             { \"Session Attribute (a)\", \"sdp.session_attr\",",
          "2372:               FT_STRING, BASE_NONE, NULL, 0x0,",
          "2373:               NULL, HFILL }",
          "2374:         },",
          "2375:         { &hf_media_attribute,",
          "2376:             { \"Media Attribute (a)\", \"sdp.media_attr\",",
          "2377:               FT_STRING, BASE_NONE, NULL, 0x0,",
          "2378:               NULL, HFILL }",
          "2379:         },",
          "2380:         { &hf_time,",
          "2381:             { \"Time Description, active time (t)\",",
          "2382:               \"sdp.time\", FT_STRING, BASE_NONE, NULL,",
          "2383:               0x0, NULL, HFILL }",
          "2384:         },",
          "2385:         { &hf_repeat_time,",
          "2386:             { \"Repeat Time (r)\", \"sdp.repeat_time\",",
          "2387:               FT_STRING, BASE_NONE, NULL, 0x0,",
          "2388:               NULL, HFILL }",
          "2389:         },",
          "2390:         { &hf_media,",
          "2391:             { \"Media Description, name and address (m)\",",
          "2392:               \"sdp.media\", FT_STRING, BASE_NONE, NULL,",
          "2393:               0x0, NULL, HFILL }",
          "2394:         },",
          "2395:         { &hf_media_title,",
          "2396:             { \"Media Title (i)\", \"sdp.media_title\",",
          "2397:               FT_STRING, BASE_NONE, NULL, 0x0,",
          "2398:               \"Media Title\", HFILL }",
          "2399:         },",
          "2400:         { &hf_unknown,",
          "2401:             { \"Unknown\", \"sdp.unknown\",",
          "2402:               FT_STRING, BASE_NONE, NULL, 0x0,",
          "2403:               NULL, HFILL }",
          "2404:         },",
          "2405:         { &hf_invalid,",
          "2406:             { \"Invalid line\", \"sdp.invalid\",",
          "2407:               FT_STRING, BASE_NONE, NULL, 0x0,",
          "2408:               NULL, HFILL }",
          "2409:         },",
          "2410:         { &hf_owner_username,",
          "2411:             { \"Owner Username\", \"sdp.owner.username\",",
          "2412:               FT_STRING, BASE_NONE, NULL, 0x0,",
          "2413:               NULL, HFILL }",
          "2414:         },",
          "2415:         { &hf_owner_sessionid,",
          "2416:             { \"Session ID\", \"sdp.owner.sessionid\",",
          "2417:               FT_STRING, BASE_NONE, NULL, 0x0,",
          "2418:               NULL, HFILL }",
          "2419:         },",
          "2420:         { &hf_owner_version,",
          "2421:             { \"Session Version\", \"sdp.owner.version\",",
          "2422:               FT_STRING, BASE_NONE, NULL, 0x0,",
          "2423:               NULL, HFILL }",
          "2424:         },",
          "2425:         { &hf_owner_network_type,",
          "2426:             { \"Owner Network Type\", \"sdp.owner.network_type\",",
          "2427:               FT_STRING, BASE_NONE, NULL, 0x0,",
          "2428:               NULL, HFILL }",
          "2429:         },",
          "2430:         { &hf_owner_address_type,",
          "2431:             { \"Owner Address Type\", \"sdp.owner.address_type\",",
          "2432:               FT_STRING, BASE_NONE, NULL, 0x0,",
          "2433:               NULL, HFILL }",
          "2434:         },",
          "2435:         { &hf_owner_address,",
          "2436:             { \"Owner Address\", \"sdp.owner.address\",",
          "2437:               FT_STRING, BASE_NONE, NULL, 0x0,",
          "2438:               NULL, HFILL }",
          "2439:         },",
          "2440:         { &hf_connection_info_network_type,",
          "2441:             { \"Connection Network Type\", \"sdp.connection_info.network_type\",",
          "2442:               FT_STRING, BASE_NONE, NULL, 0x0,",
          "2443:               NULL, HFILL }",
          "2444:         },",
          "2445:         { &hf_connection_info_address_type,",
          "2446:             { \"Connection Address Type\", \"sdp.connection_info.address_type\",",
          "2447:               FT_STRING, BASE_NONE, NULL, 0x0,",
          "2448:               NULL, HFILL }",
          "2449:         },",
          "2450:         { &hf_connection_info_connection_address,",
          "2451:             { \"Connection Address\", \"sdp.connection_info.address\",",
          "2452:               FT_STRING, BASE_NONE, NULL, 0x0,",
          "2453:               NULL, HFILL }",
          "2454:         },",
          "2455:         { &hf_connection_info_ttl,",
          "2456:             { \"Connection TTL\", \"sdp.connection_info.ttl\",",
          "2457:               FT_STRING, BASE_NONE, NULL, 0x0,",
          "2458:               NULL, HFILL }",
          "2459:         },",
          "2460:         { &hf_connection_info_num_addr,",
          "2461:             { \"Connection Number of Addresses\", \"sdp.connection_info.num_addr\",",
          "2462:               FT_STRING, BASE_NONE, NULL, 0x0,",
          "2463:               NULL, HFILL }",
          "2464:         },",
          "2465:         { &hf_bandwidth_modifier,",
          "2466:             { \"Bandwidth Modifier\", \"sdp.bandwidth.modifier\",",
          "2467:               FT_STRING, BASE_NONE, NULL, 0x0,",
          "2468:               NULL, HFILL }",
          "2469:         },",
          "2470:         { &hf_bandwidth_value,",
          "2471:             { \"Bandwidth Value\", \"sdp.bandwidth.value\",",
          "2472:               FT_STRING, BASE_NONE, NULL, 0x0,",
          "2473:               \"Bandwidth Value (in kbits/s)\", HFILL }",
          "2474:         },",
          "2475:         { &hf_time_start,",
          "2476:             { \"Session Start Time\", \"sdp.time.start\",",
          "2477:               FT_STRING, BASE_NONE, NULL, 0x0,",
          "2478:               NULL, HFILL }",
          "2479:         },",
          "2480:         { &hf_time_stop,",
          "2481:             { \"Session Stop Time\", \"sdp.time.stop\",",
          "2482:               FT_STRING, BASE_NONE, NULL, 0x0,",
          "2483:               NULL, HFILL }",
          "2484:         },",
          "2485:         { &hf_repeat_time_interval,",
          "2486:             { \"Repeat Interval\", \"sdp.repeat_time.interval\",",
          "2487:               FT_STRING, BASE_NONE, NULL, 0x0,",
          "2488:               NULL, HFILL }",
          "2489:         },",
          "2490:         { &hf_repeat_time_duration,",
          "2491:             { \"Repeat Duration\", \"sdp.repeat_time.duration\",",
          "2492:               FT_STRING, BASE_NONE, NULL, 0x0,",
          "2493:               NULL, HFILL }",
          "2494:         },",
          "2495:         { &hf_repeat_time_offset,",
          "2496:             { \"Repeat Offset\", \"sdp.repeat_time.offset\",",
          "2497:               FT_STRING, BASE_NONE, NULL, 0x0,",
          "2498:               NULL, HFILL }",
          "2499:         },",
          "2500:         { &hf_timezone_time,",
          "2501:             { \"Timezone Time\", \"sdp.timezone.time\",",
          "2502:               FT_STRING, BASE_NONE, NULL, 0x0,",
          "2503:               NULL, HFILL }",
          "2504:         },",
          "2505:         { &hf_timezone_offset,",
          "2506:             { \"Timezone Offset\", \"sdp.timezone.offset\",",
          "2507:               FT_STRING, BASE_NONE, NULL, 0x0,",
          "2508:               NULL, HFILL }",
          "2509:         },",
          "2510:         { &hf_encryption_key_type,",
          "2511:             { \"Key Type\", \"sdp.encryption_key.type\",",
          "2512:               FT_STRING, BASE_NONE, NULL, 0x0,",
          "2513:               NULL, HFILL }",
          "2514:         },",
          "2515:         { &hf_encryption_key_data,",
          "2516:             { \"Key Data\", \"sdp.encryption_key.data\",",
          "2517:               FT_STRING, BASE_NONE, NULL, 0x0,",
          "2518:               NULL, HFILL }",
          "2519:         },",
          "2520:         { &hf_session_attribute_field,",
          "2521:             { \"Session Attribute Fieldname\", \"sdp.session_attr.field\",",
          "2522:               FT_STRING, BASE_NONE, NULL, 0x0,",
          "2523:               NULL, HFILL }",
          "2524:         },",
          "2525:         { &hf_session_attribute_value,",
          "2526:             { \"Session Attribute Value\", \"sdp.session_attr.value\",",
          "2527:               FT_STRING, BASE_NONE, NULL, 0x0,",
          "2528:               NULL, HFILL }",
          "2529:         },",
          "2530:         { &hf_media_media,",
          "2531:             { \"Media Type\", \"sdp.media.media\",",
          "2532:               FT_STRING, BASE_NONE, NULL, 0x0,",
          "2533:               NULL, HFILL }",
          "2534:         },",
          "2535:         { &hf_media_port,",
          "2536:             { \"Media Port\", \"sdp.media.port\",",
          "2537:               FT_UINT16, BASE_DEC, NULL, 0x0,",
          "2538:               NULL, HFILL }",
          "2539:         },",
          "2540:         { &hf_media_portcount,",
          "2541:             { \"Media Port Count\", \"sdp.media.portcount\",",
          "2542:               FT_STRING, BASE_NONE, NULL, 0x0,",
          "2543:               NULL, HFILL }",
          "2544:         },",
          "2545:         { &hf_media_proto,",
          "2546:             { \"Media Protocol\", \"sdp.media.proto\",",
          "2547:               FT_STRING, BASE_NONE, NULL, 0x0,",
          "2548:               NULL, HFILL }",
          "2549:         },",
          "2550:         { &hf_media_format,",
          "2551:             { \"Media Format\", \"sdp.media.format\",",
          "2552:               FT_STRING, BASE_NONE, NULL, 0x0,",
          "2553:               NULL, HFILL }",
          "2554:         },",
          "2555:         { &hf_media_attribute_field,",
          "2556:             { \"Media Attribute Fieldname\", \"sdp.media_attribute.field\",",
          "2557:               FT_STRING, BASE_NONE, NULL, 0x0,",
          "2558:               NULL, HFILL }",
          "2559:         },",
          "2560:         { &hf_media_attribute_value,",
          "2561:             { \"Media Attribute Value\", \"sdp.media_attribute.value\",",
          "2562:               FT_STRING, BASE_NONE, NULL, 0x0,",
          "2563:               NULL, HFILL }",
          "2564:         },",
          "2565:         { &hf_media_encoding_name,",
          "2566:             { \"MIME Type\", \"sdp.mime.type\",",
          "2567:               FT_STRING, BASE_NONE, NULL, 0x0,",
          "2568:               \"SDP MIME Type\", HFILL }",
          "2569:         },",
          "2570:         { &hf_media_sample_rate,",
          "2571:             { \"Sample Rate\", \"sdp.sample_rate\",",
          "2572:               FT_STRING, BASE_NONE, NULL, 0x0,",
          "2573:               NULL, HFILL }",
          "2574:         },",
          "2575:         { &hf_media_format_specific_parameter,",
          "2576:             { \"Media format specific parameters\", \"sdp.fmtp.parameter\",",
          "2577:               FT_STRING, BASE_NONE, NULL, 0x0,",
          "2578:               \"Format specific parameter(fmtp)\", HFILL }",
          "2579:         },",
          "2580:         { &hf_ipbcp_version,",
          "2581:             { \"IPBCP Protocol Version\", \"sdp.ipbcp.version\",",
          "2582:               FT_STRING, BASE_NONE, NULL, 0x0,",
          "2583:               NULL, HFILL }",
          "2584:         },",
          "2585:         { &hf_ipbcp_type,",
          "2586:             { \"IPBCP Command Type\", \"sdp.ipbcp.command\",",
          "2587:               FT_STRING, BASE_NONE, NULL, 0x0,",
          "2588:               NULL, HFILL }",
          "2589:         },",
          "2590:         {&hf_sdp_fmtp_mpeg4_profile_level_id,",
          "2591:            { \"Level Code\", \"sdp.fmtp.profile_level_id\",",
          "2592:              FT_UINT32, BASE_DEC, VALS(mp4ves_level_indication_vals), 0x0,",
          "2593:              NULL, HFILL }",
          "2594:         },",
          "2595:         { &hf_sdp_fmtp_h263_profile,",
          "2596:             { \"Profile\", \"sdp.fmtp.h263profile\",",
          "2597:               FT_UINT32, BASE_DEC, VALS(h263_profile_vals), 0x0,",
          "2598:               NULL, HFILL }",
          "2599:         },",
          "2600:         { &hf_sdp_fmtp_h263_level,",
          "2601:             { \"Level\", \"sdp.fmtp.h263level\",",
          "2602:               FT_UINT32, BASE_DEC, VALS(h263_level_vals), 0x0,",
          "2603:               NULL, HFILL }",
          "2604:         },",
          "2605:         { &hf_sdp_h264_packetization_mode,",
          "2606:             { \"Packetization mode\", \"sdp.fmtp.h264_packetization_mode\",",
          "2607:               FT_UINT32, BASE_DEC, VALS(h264_packetization_mode_vals), 0x0,",
          "2608:               NULL, HFILL }",
          "2609:         },",
          "2610:         { &hf_SDPh223LogicalChannelParameters,",
          "2611:             { \"h223LogicalChannelParameters\", \"sdp.h223LogicalChannelParameters\",",
          "2612:               FT_NONE, BASE_NONE, NULL, 0,",
          "2613:               NULL, HFILL }",
          "2614:         },",
          "2615:         { &hf_key_mgmt_att_value,",
          "2616:             { \"Key Management\", \"sdp.key_mgmt\",",
          "2617:               FT_STRING, BASE_NONE, NULL, 0x0,",
          "2618:               NULL, HFILL }",
          "2619:         },",
          "2620:         { &hf_key_mgmt_prtcl_id,",
          "2621:             { \"Key Management Protocol (kmpid)\", \"sdp.key_mgmt.kmpid\",",
          "2622:               FT_STRING, BASE_NONE, NULL, 0x0,",
          "2623:               NULL, HFILL }",
          "2624:         },",
          "2625:         { &hf_key_mgmt_data,",
          "2626:             { \"Key Management Data\", \"sdp.key_mgmt.data\",",
          "2627:               FT_BYTES, BASE_NONE, NULL, 0x0,",
          "2628:               NULL, HFILL }",
          "2629:         },",
          "2630:         { &hf_sdp_crypto_tag,",
          "2631:             { \"tag\", \"sdp.crypto.tag\",",
          "2632:               FT_UINT32, BASE_DEC, NULL, 0x0,",
          "2633:               NULL, HFILL }",
          "2634:         },",
          "2635:         { &hf_sdp_crypto_crypto_suite,",
          "2636:             { \"Crypto suite\", \"sdp.crypto.crypto_suite\",",
          "2637:               FT_STRING, BASE_NONE, NULL, 0x0,",
          "2638:               NULL, HFILL }",
          "2639:         },",
          "2640:         { &hf_sdp_crypto_master_key,",
          "2641:             { \"Master Key\", \"sdp.crypto.master_key\",",
          "2642:               FT_BYTES, BASE_NONE, NULL, 0x0,",
          "2643:               NULL, HFILL }",
          "2644:         },",
          "2645:         { &hf_sdp_crypto_master_salt,",
          "2646:             { \"Master salt\", \"sdp.crypto.master_salt\",",
          "2647:               FT_BYTES, BASE_NONE, NULL, 0x0,",
          "2648:               NULL, HFILL }",
          "2649:         },",
          "2650:         { &hf_sdp_crypto_lifetime,",
          "2651:             { \"Lifetime\", \"sdp.crypto.lifetime\",",
          "2652:               FT_STRING, BASE_NONE, NULL, 0x0,",
          "2653:               NULL, HFILL }",
          "2654:         },",
          "2655:         { &hf_sdp_crypto_mki,",
          "2656:             { \"mki-value\", \"sdp.crypto.mki-valu\",",
          "2657:               FT_STRING, BASE_NONE, NULL, 0x0,",
          "2658:               NULL, HFILL }",
          "2659:         },",
          "2660:         { &hf_sdp_crypto_mki_length,",
          "2661:             { \"mki_length\", \"sdp.crypto.mki_length\",",
          "2662:               FT_STRING, BASE_NONE, NULL, 0x0,",
          "2663:               NULL, HFILL }",
          "2664:         },",
          "2665:     };",
          "2666:     static gint *ett[] = {",
          "2667:         &ett_sdp,",
          "2668:         &ett_sdp_owner,",
          "2669:         &ett_sdp_connection_info,",
          "2670:         &ett_sdp_bandwidth,",
          "2671:         &ett_sdp_time,",
          "2672:         &ett_sdp_repeat_time,",
          "2673:         &ett_sdp_timezone,",
          "2674:         &ett_sdp_encryption_key,",
          "2675:         &ett_sdp_session_attribute,",
          "2676:         &ett_sdp_media,",
          "2677:         &ett_sdp_media_attribute,",
          "2678:         &ett_sdp_fmtp,",
          "2679:         &ett_sdp_key_mgmt,",
          "2680:         &ett_sdp_crypto_key_parameters,",
          "2681:     };",
          "2683:     static ei_register_info ei[] = {",
          "2684:         { &ei_sdp_invalid_key_param, { \"sdp.invalid_key_param\", PI_MALFORMED, PI_NOTE, \"Invalid key-param (no ':' delimiter)\", EXPFILL }},",
          "2685:         { &ei_sdp_invalid_line, { \"sdp.invalid_line\", PI_MALFORMED, PI_NOTE, \"Invalid SDP line (no '=' delimiter)\", EXPFILL }},",
          "2686:     };",
          "2688:     module_t *sdp_module;",
          "2689:     expert_module_t* expert_sdp;",
          "2691:     proto_sdp = proto_register_protocol(\"Session Description Protocol\",",
          "2692:                                         \"SDP\", \"sdp\");",
          "2693:     proto_register_field_array(proto_sdp, hf, array_length(hf));",
          "2694:     proto_register_subtree_array(ett, array_length(ett));",
          "2695:     expert_sdp = expert_register_protocol(proto_sdp);",
          "2696:     expert_register_field_array(expert_sdp, ei, array_length(ei));",
          "2698:     key_mgmt_dissector_table = register_dissector_table(\"key_mgmt\",",
          "2699:                                                         \"Key Management\", FT_STRING, BASE_NONE);",
          "2703:     sdp_module = prefs_register_protocol(proto_sdp, NULL);",
          "2704:     prefs_register_bool_preference(sdp_module, \"establish_conversation\",",
          "2705:                                    \"Establish Media Conversation\",",
          "2706:                                    \"Specifies that RTP/RTCP/T.38/MSRP/etc streams are decoded based \"",
          "2707:                                    \"upon port numbers found in SDP payload\",",
          "2708:                                    &global_sdp_establish_conversation);",
          "2710:     sdp_transport_reqs = wmem_tree_new_autoreset(wmem_epan_scope(), wmem_file_scope());",
          "2711:     sdp_transport_rsps = wmem_tree_new_autoreset(wmem_epan_scope(), wmem_file_scope());",
          "2717:     register_dissector(\"sdp\", dissect_sdp, proto_sdp);",
          "2720:     sdp_tap = register_tap(\"sdp\");",
          "2726:     dissector_handle_t sdp_handle;",
          "2728:     rtcp_handle   = find_dissector(\"rtcp\");",
          "2729:     msrp_handle   = find_dissector(\"msrp\");",
          "2730:     sprt_handle   = find_dissector(\"sprt\");",
          "2731:     h264_handle   = find_dissector(\"h264\");",
          "2732:     mp4ves_handle = find_dissector(\"mp4ves\");",
          "2734:     proto_sprt    = dissector_handle_get_protocol_index(find_dissector(\"sprt\"));",
          "2736:     sdp_handle = find_dissector(\"sdp\");",
          "2737:     dissector_add_string(\"media_type\", \"application/sdp\", sdp_handle);",
          "2738:     dissector_add_uint(\"bctp.tpi\", 0x20, sdp_handle);",
          "",
          "---------------"
        ],
        "epan/dissectors/packet-sip.c||epan/dissectors/packet-sip.c": [
          "File: epan/dissectors/packet-sip.c -> epan/dissectors/packet-sip.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "227: static const char *sip_methods[] = {",
          "231:         \"ACK\",",
          "233:         \"BYE\",",
          "235:         \"CANCEL\",",
          "237:         \"DO\",",
          "239:         \"INFO\",",
          "241:         \"INVITE\",",
          "243:         \"MESSAGE\",",
          "245:         \"NOTIFY\",",
          "247:         \"OPTIONS\",",
          "249:         \"PRACK\",",
          "251:         \"QAUTH\",",
          "253:         \"REFER\",",
          "255:         \"REGISTER\",",
          "257:         \"SPRACK\",",
          "259:         \"SUBSCRIBE\",",
          "261:         \"UPDATE\",",
          "263:         \"PUBLISH\"",
          "264: };",
          "",
          "[Removed Lines]",
          "228: #define SIP_METHOD_INVALID 0",
          "230: #define SIP_METHOD_ACK  1",
          "232: #define SIP_METHOD_BYE  2",
          "234: #define SIP_METHOD_CANCEL 3",
          "236: #define SIP_METHOD_DO  4",
          "238: #define SIP_METHOD_INFO  5",
          "240: #define SIP_METHOD_INVITE 6",
          "242: #define SIP_METHOD_MESSAGE 7",
          "244: #define SIP_METHOD_NOTIFY 8",
          "246: #define SIP_METHOD_OPTIONS 9",
          "248: #define SIP_METHOD_PRACK 10",
          "250: #define SIP_METHOD_QAUTH 11",
          "252: #define SIP_METHOD_REFER 12",
          "254: #define SIP_METHOD_REGISTER 13",
          "256: #define SIP_METHOD_SPRACK 14",
          "258: #define SIP_METHOD_SUBSCRIBE 15",
          "260: #define SIP_METHOD_UPDATE 16",
          "262: #define SIP_METHOD_PUBLISH 17",
          "",
          "[Added Lines]",
          "228: #define SIP_METHOD_INVALID  0",
          "230: #define SIP_METHOD_ACK      1",
          "232: #define SIP_METHOD_BYE      2",
          "234: #define SIP_METHOD_CANCEL   3",
          "236: #define SIP_METHOD_DO       4",
          "238: #define SIP_METHOD_INFO     5",
          "240: #define SIP_METHOD_INVITE   6",
          "242: #define SIP_METHOD_MESSAGE  7",
          "244: #define SIP_METHOD_NOTIFY   8",
          "246: #define SIP_METHOD_OPTIONS  9",
          "248: #define SIP_METHOD_PRACK    10",
          "250: #define SIP_METHOD_QAUTH    11",
          "252: #define SIP_METHOD_REFER    12",
          "254: #define SIP_METHOD_REGISTER 13",
          "256: #define SIP_METHOD_SPRACK   14",
          "258: #define SIP_METHOD_SUBSCRIBE    15",
          "260: #define SIP_METHOD_UPDATE   16",
          "262: #define SIP_METHOD_PUBLISH  17",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "273:         const char *compact_name;",
          "274: } sip_header_t;",
          "275: static const sip_header_t sip_headers[] = {",
          "278: #define POS_ACCEPT                       1",
          "280: #define POS_ACCEPT_CONTACT               2",
          "282: #define POS_ACCEPT_ENCODING              3",
          "284: #define POS_ACCEPT_LANGUAGE              4",
          "286: #define POS_ACCEPT_RESOURCE_PRIORITY     5",
          "288: #define POS_ALERT_INFO                   6",
          "290: #define POS_ALLOW                        7",
          "292: #define POS_ALLOW_EVENTS                 8",
          "294: #define POS_ANSWER_MODE                  9",
          "296: #define POS_AUTHENTICATION_INFO         10",
          "298: #define POS_AUTHORIZATION               11",
          "300: #define POS_CALL_ID                     12",
          "302: #define POS_CALL_INFO                   13",
          "304: #define POS_CONTACT                     14",
          "306: #define POS_CONTENT_DISPOSITION         15",
          "308: #define POS_CONTENT_ENCODING            16",
          "310: #define POS_CONTENT_LANGUAGE            17",
          "312: #define POS_CONTENT_LENGTH              18",
          "314: #define POS_CONTENT_TYPE                19",
          "316: #define POS_CSEQ                        20",
          "318: #define POS_DATE                        21",
          "321: #define POS_ERROR_INFO                  22",
          "323: #define POS_EVENT                       23",
          "325: #define POS_EXPIRES                     24",
          "327: #define POS_FEATURE_CAPS                25",
          "329: #define POS_FLOW_TIMER                  26",
          "331: #define POS_FROM                        27",
          "334: #define POS_GEOLOCATION                 28",
          "336: #define POS_GEOLOCATION_ERROR           29",
          "338: #define POS_GEOLOCATION_ROUTING         30",
          "342: #define POS_HISTORY_INFO                31",
          "344: #define POS_IDENTITY                    32",
          "346: #define POS_IDENTITY_INFO               33",
          "348: #define POS_INFO_PKG                    34",
          "350: #define POS_IN_REPLY_TO                 35",
          "352: #define POS_JOIN                        36",
          "354: #define POS_MAX_BREADTH                 37",
          "356: #define POS_MAX_FORWARDS                38",
          "358: #define POS_MIME_VERSION                39",
          "360: #define POS_MIN_EXPIRES                 40",
          "362: #define POS_MIN_SE                      41",
          "364: #define POS_ORGANIZATION                42",
          "366: #define POS_P_ACCESS_NETWORK_INFO       43",
          "368: #define POS_P_ANSWER_STATE              44",
          "370: #define POS_P_ASSERTED_IDENTITY         45",
          "372: #define POS_P_ASSERTED_SERV             46",
          "374: #define POS_P_ASSOCIATED_URI            47",
          "376: #define POS_P_CALLED_PARTY_ID           48",
          "378: #define POS_P_CHARGING_FUNC_ADDRESSES   49",
          "380: #define POS_P_CHARGING_VECTOR           50",
          "382: #define POS_P_DCS_TRACE_PARTY_ID        51",
          "384: #define POS_P_DCS_OSPS                  52",
          "386: #define POS_P_DCS_BILLING_INFO          53",
          "388: #define POS_P_DCS_LAES                  54",
          "390: #define POS_P_DCS_REDIRECT              55",
          "392: #define POS_P_EARLY_MEDIA               56",
          "394: #define POS_P_MEDIA_AUTHORIZATION       57",
          "396: #define POS_P_PREFERRED_IDENTITY        58",
          "398: #define POS_P_PREFERRED_SERV            59",
          "400: #define POS_P_PROFILE_KEY               60",
          "402: #define POS_P_REFUSED_URI_LST           61",
          "404: #define POS_P_SERVED_USER               62",
          "406: #define POS_P_USER_DATABASE             63",
          "408: #define POS_P_VISITED_NETWORK_ID        64",
          "410: #define POS_PATH                        65",
          "412: #define POS_PERMISSION_MISSING          66",
          "414: #define POS_POLICY_CONTACT              67",
          "416: #define POS_POLICY_ID                   68",
          "418: #define POS_PRIORITY                    69",
          "420: #define POS_PRIV_ANSWER_MODE            70",
          "422: #define POS_PRIVACY                     71",
          "424: #define POS_PROXY_AUTHENTICATE          72",
          "426: #define POS_PROXY_AUTHORIZATION         73",
          "428: #define POS_PROXY_REQUIRE               74",
          "430: #define POS_RACK                        75",
          "432: #define POS_REASON                      76",
          "434: #define POS_REASON_PHRASE               77",
          "436: #define POS_RECORD_ROUTE                78",
          "438: #define POS_RECV_INFO                   79",
          "440: #define POS_REFER_SUB                   80",
          "442: #define POS_REFER_TO                    81",
          "444: #define POS_REFERED_BY                  82",
          "446: #define POS_REJECT_CONTACT              83",
          "448: #define POS_REPLACES                    84",
          "450: #define POS_REPLY_TO                    85",
          "452: #define POS_REQUEST_DISPOSITION         86",
          "454: #define POS_REQUIRE                     87",
          "456: #define POS_RESOURCE_PRIORITY           88",
          "459: #define POS_RETRY_AFTER                 89",
          "461: #define POS_ROUTE                       90",
          "463: #define POS_RSEQ                        91",
          "465: #define POS_SECURITY_CLIENT             92",
          "467: #define POS_SECURITY_SERVER             93",
          "469: #define POS_SECURITY_VERIFY             94",
          "471: #define POS_SERVER                      95",
          "473: #define POS_SERVICE_ROUTE               96",
          "475: #define POS_SESSION_EXPIRES             97",
          "477: #define POS_SIP_ETAG                    98",
          "479: #define POS_SIP_IF_MATCH                99",
          "481: #define POS_SUBJECT                     100",
          "483: #define POS_SUBSCRIPTION_STATE          101",
          "485: #define POS_SUPPORTED                   102",
          "487: #define POS_SUPPRESS_IF_MATCH           103",
          "489: #define POS_TARGET_DIALOG               104",
          "491: #define POS_TIMESTAMP                   105",
          "493: #define POS_TO                          106",
          "495: #define POS_TRIGGER_CONSENT             107",
          "497: #define POS_UNSUPPORTED                 108",
          "499: #define POS_USER_AGENT                  109",
          "501: #define POS_VIA                         110",
          "503: #define POS_WARNING                     111",
          "505: #define POS_WWW_AUTHENTICATE            112",
          "507: #define POS_DIVERSION                   113",
          "509: #define POS_USER_TO_USER                114",
          "510: };",
          "",
          "[Removed Lines]",
          "287:  { \"Alert-Info\",                     NULL },",
          "289:  { \"Allow\",                          NULL },",
          "295:  { \"Authentication-Info\",            NULL },",
          "299:  { \"Call-ID\",                        \"i\"  },",
          "301:  { \"Call-Info\",                      NULL },",
          "303:  { \"Contact\",                        \"m\"  },",
          "305:  { \"Content-Disposition\",            NULL },",
          "309:  { \"Content-Language\",               NULL },",
          "311:  { \"Content-Length\",                 \"l\"  },",
          "313:  { \"Content-Type\",                   \"c\"  },",
          "315:  { \"CSeq\",                           NULL },",
          "",
          "[Added Lines]",
          "287:     { \"Alert-Info\",                     NULL },",
          "289:     { \"Allow\",                          NULL },",
          "295:     { \"Authentication-Info\",            NULL },",
          "299:     { \"Call-ID\",                        \"i\"  },",
          "301:     { \"Call-Info\",                      NULL },",
          "303:     { \"Contact\",                        \"m\"  },",
          "305:     { \"Content-Disposition\",            NULL },",
          "309:     { \"Content-Language\",               NULL },",
          "311:     { \"Content-Length\",                 \"l\"  },",
          "313:     { \"Content-Type\",                   \"c\"  },",
          "315:     { \"CSeq\",                           NULL },",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "515: static gint hf_header_array[] = {",
          "632: };",
          "635: typedef struct {",
          "638: } header_parameter_t;",
          "640: static header_parameter_t auth_parameters_hf_array[] =",
          "641: {",
          "659: };",
          "661: static header_parameter_t via_parameters_hf_array[] =",
          "662: {",
          "670: };",
          "673: typedef struct {",
          "680: } hf_sip_uri_t;",
          "682: static hf_sip_uri_t sip_pai_uri = {",
          "689: };",
          "691: static hf_sip_uri_t sip_ppi_uri = {",
          "698: };",
          "700: static hf_sip_uri_t sip_pmiss_uri = {",
          "707: };",
          "710: static hf_sip_uri_t sip_tc_uri = {",
          "717: };",
          "719: static hf_sip_uri_t sip_to_uri = {",
          "726: };",
          "728: static hf_sip_uri_t sip_from_uri = {",
          "735: };",
          "737: static hf_sip_uri_t sip_req_uri = {",
          "744: };",
          "746: static hf_sip_uri_t sip_contact_uri = {",
          "753: };",
          "755: static hf_sip_uri_t sip_route_uri = {",
          "762: };",
          "764: static hf_sip_uri_t sip_record_route_uri = {",
          "771: };",
          "",
          "[Removed Lines]",
          "636:  const char  *param_name;",
          "637:  const gint  *hf_item;",
          "642:  {\"response\",        &hf_sip_auth_digest_response},",
          "643:  {\"nc\",              &hf_sip_auth_nc},",
          "644:  {\"username\",        &hf_sip_auth_username},",
          "645:  {\"realm\",           &hf_sip_auth_realm},",
          "646:  {\"nonce\",           &hf_sip_auth_nonce},",
          "647:  {\"algorithm\",       &hf_sip_auth_algorithm},",
          "648:  {\"opaque\",          &hf_sip_auth_opaque},",
          "649:  {\"qop\",             &hf_sip_auth_qop},",
          "650:  {\"cnonce\",          &hf_sip_auth_cnonce},",
          "651:  {\"uri\",             &hf_sip_auth_uri},",
          "652:  {\"domain\",          &hf_sip_auth_domain},",
          "653:  {\"stale\",           &hf_sip_auth_stale},",
          "654:  {\"auts\",            &hf_sip_auth_auts},",
          "655:  {\"rspauth\",         &hf_sip_auth_rspauth},",
          "656:  {\"nextnonce\",       &hf_sip_auth_nextnonce},",
          "657:  {\"ik\",              &hf_sip_auth_ik},",
          "658:  {\"ck\",              &hf_sip_auth_ck}",
          "663:  {\"branch\",        &hf_sip_via_branch},",
          "664:  {\"maddr\",         &hf_sip_via_maddr},",
          "665:  {\"rport\",         &hf_sip_via_rport},",
          "666:  {\"received\",      &hf_sip_via_received},",
          "667:  {\"ttl\",           &hf_sip_via_ttl},",
          "668:  {\"comp\",          &hf_sip_via_comp},",
          "669:  {\"sigcomp-id\",    &hf_sip_via_sigcomp_id}",
          "674:  gint *hf_sip_addr;",
          "675:  gint *hf_sip_user;",
          "676:  gint *hf_sip_host;",
          "677:  gint *hf_sip_port;",
          "678:  gint *hf_sip_param;",
          "679:  gint *ett_uri;",
          "683:  &hf_sip_pai_addr,",
          "684:  &hf_sip_pai_user,",
          "685:  &hf_sip_pai_host,",
          "686:  &hf_sip_pai_port,",
          "687:  &hf_sip_pai_param,",
          "688:  &ett_sip_pai_uri",
          "692:  &hf_sip_ppi_addr,",
          "693:  &hf_sip_ppi_user,",
          "694:  &hf_sip_ppi_host,",
          "695:  &hf_sip_ppi_port,",
          "696:  &hf_sip_ppi_param,",
          "697:  &ett_sip_ppi_uri",
          "701:  &hf_sip_pmiss_addr,",
          "702:  &hf_sip_pmiss_user,",
          "703:  &hf_sip_pmiss_host,",
          "704:  &hf_sip_pmiss_port,",
          "705:  &hf_sip_pmiss_param,",
          "706:  &ett_sip_pmiss_uri",
          "711:  &hf_sip_tc_addr,",
          "712:  &hf_sip_tc_user,",
          "713:  &hf_sip_tc_host,",
          "714:  &hf_sip_tc_port,",
          "715:  &hf_sip_tc_param,",
          "716:  &ett_sip_tc_uri",
          "720:  &hf_sip_to_addr,",
          "721:  &hf_sip_to_user,",
          "722:  &hf_sip_to_host,",
          "723:  &hf_sip_to_port,",
          "724:  &hf_sip_to_param,",
          "725:  &ett_sip_to_uri",
          "729:  &hf_sip_from_addr,",
          "730:  &hf_sip_from_user,",
          "731:  &hf_sip_from_host,",
          "732:  &hf_sip_from_port,",
          "733:  &hf_sip_from_param,",
          "734:  &ett_sip_from_uri",
          "738:  &hf_sip_ruri,",
          "739:  &hf_sip_ruri_user,",
          "740:  &hf_sip_ruri_host,",
          "741:  &hf_sip_ruri_port,",
          "742:  &hf_sip_ruri_param,",
          "743:  &ett_sip_ruri",
          "747:  &hf_sip_curi,",
          "748:  &hf_sip_curi_user,",
          "749:  &hf_sip_curi_host,",
          "750:  &hf_sip_curi_port,",
          "751:  &hf_sip_curi_param,",
          "752:  &ett_sip_curi",
          "756:  &hf_sip_route,",
          "757:  &hf_sip_route_user,",
          "758:  &hf_sip_route_host,",
          "759:  &hf_sip_route_port,",
          "760:  &hf_sip_route_param,",
          "761:  &ett_sip_route",
          "765:  &hf_sip_record_route,",
          "766:  &hf_sip_record_route_user,",
          "767:  &hf_sip_record_route_host,",
          "768:  &hf_sip_record_route_port,",
          "769:  &hf_sip_record_route_param,",
          "770:  &ett_sip_record_route",
          "",
          "[Added Lines]",
          "636:     const char  *param_name;",
          "637:     const gint  *hf_item;",
          "642:     {\"response\",        &hf_sip_auth_digest_response},",
          "643:     {\"nc\",              &hf_sip_auth_nc},",
          "644:     {\"username\",        &hf_sip_auth_username},",
          "645:     {\"realm\",           &hf_sip_auth_realm},",
          "646:     {\"nonce\",           &hf_sip_auth_nonce},",
          "647:     {\"algorithm\",       &hf_sip_auth_algorithm},",
          "648:     {\"opaque\",          &hf_sip_auth_opaque},",
          "649:     {\"qop\",             &hf_sip_auth_qop},",
          "650:     {\"cnonce\",          &hf_sip_auth_cnonce},",
          "651:     {\"uri\",             &hf_sip_auth_uri},",
          "652:     {\"domain\",          &hf_sip_auth_domain},",
          "653:     {\"stale\",           &hf_sip_auth_stale},",
          "654:     {\"auts\",            &hf_sip_auth_auts},",
          "655:     {\"rspauth\",         &hf_sip_auth_rspauth},",
          "656:     {\"nextnonce\",       &hf_sip_auth_nextnonce},",
          "657:     {\"ik\",              &hf_sip_auth_ik},",
          "658:     {\"ck\",              &hf_sip_auth_ck}",
          "663:     {\"branch\",        &hf_sip_via_branch},",
          "664:     {\"maddr\",         &hf_sip_via_maddr},",
          "665:     {\"rport\",         &hf_sip_via_rport},",
          "666:     {\"received\",      &hf_sip_via_received},",
          "667:     {\"ttl\",           &hf_sip_via_ttl},",
          "668:     {\"comp\",          &hf_sip_via_comp},",
          "669:     {\"sigcomp-id\",    &hf_sip_via_sigcomp_id}",
          "674:     gint *hf_sip_addr;",
          "675:     gint *hf_sip_user;",
          "676:     gint *hf_sip_host;",
          "677:     gint *hf_sip_port;",
          "678:     gint *hf_sip_param;",
          "679:     gint *ett_uri;",
          "683:     &hf_sip_pai_addr,",
          "684:     &hf_sip_pai_user,",
          "685:     &hf_sip_pai_host,",
          "686:     &hf_sip_pai_port,",
          "687:     &hf_sip_pai_param,",
          "688:     &ett_sip_pai_uri",
          "692:     &hf_sip_ppi_addr,",
          "693:     &hf_sip_ppi_user,",
          "694:     &hf_sip_ppi_host,",
          "695:     &hf_sip_ppi_port,",
          "696:     &hf_sip_ppi_param,",
          "697:     &ett_sip_ppi_uri",
          "701:     &hf_sip_pmiss_addr,",
          "702:     &hf_sip_pmiss_user,",
          "703:     &hf_sip_pmiss_host,",
          "704:     &hf_sip_pmiss_port,",
          "705:     &hf_sip_pmiss_param,",
          "706:     &ett_sip_pmiss_uri",
          "711:     &hf_sip_tc_addr,",
          "712:     &hf_sip_tc_user,",
          "713:     &hf_sip_tc_host,",
          "714:     &hf_sip_tc_port,",
          "715:     &hf_sip_tc_param,",
          "716:     &ett_sip_tc_uri",
          "720:     &hf_sip_to_addr,",
          "721:     &hf_sip_to_user,",
          "722:     &hf_sip_to_host,",
          "723:     &hf_sip_to_port,",
          "724:     &hf_sip_to_param,",
          "725:     &ett_sip_to_uri",
          "729:     &hf_sip_from_addr,",
          "730:     &hf_sip_from_user,",
          "731:     &hf_sip_from_host,",
          "732:     &hf_sip_from_port,",
          "733:     &hf_sip_from_param,",
          "734:     &ett_sip_from_uri",
          "738:     &hf_sip_ruri,",
          "739:     &hf_sip_ruri_user,",
          "740:     &hf_sip_ruri_host,",
          "741:     &hf_sip_ruri_port,",
          "742:     &hf_sip_ruri_param,",
          "743:     &ett_sip_ruri",
          "747:     &hf_sip_curi,",
          "748:     &hf_sip_curi_user,",
          "749:     &hf_sip_curi_host,",
          "750:     &hf_sip_curi_port,",
          "751:     &hf_sip_curi_param,",
          "752:     &ett_sip_curi",
          "756:     &hf_sip_route,",
          "757:     &hf_sip_route_user,",
          "758:     &hf_sip_route_host,",
          "759:     &hf_sip_route_port,",
          "760:     &hf_sip_route_param,",
          "761:     &ett_sip_route",
          "765:     &hf_sip_record_route,",
          "766:     &hf_sip_record_route_user,",
          "767:     &hf_sip_record_route_host,",
          "768:     &hf_sip_record_route_port,",
          "769:     &hf_sip_record_route_param,",
          "770:     &ett_sip_record_route",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "777: typedef enum {",
          "781: } line_type_t;",
          "784: static guint sip_tls_port = TLS_PORT_SIP;",
          "785: static range_t *global_sip_tcp_port_range;",
          "789: static gboolean global_sip_raw_text = FALSE;",
          "792: static gboolean global_sip_raw_text_without_crlf = FALSE;",
          "",
          "[Removed Lines]",
          "778:  REQUEST_LINE,",
          "779:  STATUS_LINE,",
          "780:  OTHER_LINE",
          "",
          "[Added Lines]",
          "778:     REQUEST_LINE,",
          "779:     STATUS_LINE,",
          "780:     OTHER_LINE",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "828: static void dfilter_sip_status_line(tvbuff_t *tvb, proto_tree *tree, packet_info *pinfo, gint line_end, gint offset);",
          "829: static void tvb_raw_text_add(tvbuff_t *tvb, int offset, int length, proto_tree *tree);",
          "830: static guint sip_is_packet_resend(packet_info *pinfo,",
          "836: static guint sip_find_request(packet_info *pinfo,",
          "842: static guint sip_find_invite(packet_info *pinfo,",
          "",
          "[Removed Lines]",
          "831:     gchar* cseq_method,",
          "832:     gchar* call_id,",
          "833:     guchar cseq_number_set, guint32 cseq_number,",
          "834:     line_type_t line_type);",
          "837:     gchar* cseq_method,",
          "838:     gchar* call_id,",
          "839:     guchar cseq_number_set, guint32 cseq_number,",
          "840:     guint32 *response_time);",
          "843:     gchar* cseq_method,",
          "844:     gchar* call_id,",
          "845:     guchar cseq_number_set, guint32 cseq_number,",
          "846:     guint32 *response_time);",
          "",
          "[Added Lines]",
          "831:                 gchar* cseq_method,",
          "832:                 gchar* call_id,",
          "833:                 guchar cseq_number_set, guint32 cseq_number,",
          "834:                 line_type_t line_type);",
          "837:                 gchar* cseq_method,",
          "838:                 gchar* call_id,",
          "839:                 guchar cseq_number_set, guint32 cseq_number,",
          "840:                 guint32 *response_time);",
          "843:                 gchar* cseq_method,",
          "844:                 gchar* call_id,",
          "845:                 guchar cseq_number_set, guint32 cseq_number,",
          "846:                 guint32 *response_time);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "893: typedef struct",
          "894: {",
          "900: } sip_hash_key;",
          "903: typedef enum",
          "904: {",
          "909: } transaction_state_t;",
          "912: typedef struct",
          "913: {",
          "920: } sip_hash_value;",
          "923: typedef struct",
          "924: {",
          "928: } sip_frame_result_value;",
          "",
          "[Removed Lines]",
          "895:  char call_id[MAX_CALL_ID_SIZE];",
          "896:  address source_address;",
          "897:  guint32 source_port;",
          "898:  address dest_address;",
          "899:  guint32 dest_port;",
          "905:  nothing_seen,",
          "906:  request_seen,",
          "907:  provisional_response_seen,",
          "908:  final_response_seen",
          "914:  guint32             cseq;",
          "915:  transaction_state_t transaction_state;",
          "916:  gchar               method[MAX_CSEQ_METHOD_SIZE];",
          "917:  nstime_t            request_time;",
          "918:  guint32             response_code;",
          "919:  gint                frame_number;",
          "925:  gint       original_frame_num;",
          "926:  gint       response_request_frame_num;",
          "927:  gint       response_time;",
          "",
          "[Added Lines]",
          "895:     char call_id[MAX_CALL_ID_SIZE];",
          "896:     address source_address;",
          "897:     guint32 source_port;",
          "898:     address dest_address;",
          "899:     guint32 dest_port;",
          "905:     nothing_seen,",
          "906:     request_seen,",
          "907:     provisional_response_seen,",
          "908:     final_response_seen",
          "914:     guint32             cseq;",
          "915:     transaction_state_t transaction_state;",
          "916:     gchar               method[MAX_CSEQ_METHOD_SIZE];",
          "917:     nstime_t            request_time;",
          "918:     guint32             response_code;",
          "919:     gint                frame_number;",
          "925:     gint       original_frame_num;",
          "926:     gint       response_request_frame_num;",
          "927:     gint       response_time;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "935: static gint sip_equal(gconstpointer v, gconstpointer v2)",
          "936: {",
          "951: }",
          "",
          "[Removed Lines]",
          "937:  const sip_hash_key* val1 = (const sip_hash_key*)v;",
          "938:  const sip_hash_key* val2 = (const sip_hash_key*)v2;",
          "941:  if (strcmp(val1->call_id, val2->call_id) != 0)",
          "942:  {",
          "943:   return 0;",
          "944:  }",
          "947:  return  (ADDRESSES_EQUAL(&(val1->source_address), &(val2->source_address))) &&",
          "948:   (val1->source_port == val2->source_port) &&",
          "949:   (ADDRESSES_EQUAL(&(val1->dest_address), &(val2->dest_address))) &&",
          "950:   (val1->dest_port == val2->dest_port);",
          "",
          "[Added Lines]",
          "937:     const sip_hash_key* val1 = (const sip_hash_key*)v;",
          "938:     const sip_hash_key* val2 = (const sip_hash_key*)v2;",
          "941:     if (strcmp(val1->call_id, val2->call_id) != 0)",
          "942:     {",
          "943:         return 0;",
          "944:     }",
          "947:     return  (ADDRESSES_EQUAL(&(val1->source_address), &(val2->source_address))) &&",
          "948:         (val1->source_port == val2->source_port) &&",
          "949:         (ADDRESSES_EQUAL(&(val1->dest_address), &(val2->dest_address))) &&",
          "950:         (val1->dest_port == val2->dest_port);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "956: static void",
          "957: sip_init_protocol(void)",
          "958: {",
          "981: }",
          "983: static void",
          "",
          "[Removed Lines]",
          "959:   guint i;",
          "960:   gchar *value_copy;",
          "963:  if (sip_hash)",
          "964:   g_hash_table_destroy(sip_hash);",
          "967:  sip_hash = g_hash_table_new(g_str_hash , sip_equal);",
          "972:  if(!sip_headers_hash){",
          "973:   sip_headers_hash = g_hash_table_new(g_str_hash , g_str_equal);",
          "974:   for (i = 1; i < array_length(sip_headers); i++){",
          "975:    value_copy = g_strdup (sip_headers[i].name);",
          "977:    ascii_strdown_inplace(value_copy);",
          "978:    g_hash_table_insert(sip_headers_hash, (gpointer)value_copy, GINT_TO_POINTER(i));",
          "979:   }",
          "980:  }",
          "",
          "[Added Lines]",
          "959:      guint i;",
          "960:      gchar *value_copy;",
          "963:     if (sip_hash)",
          "964:         g_hash_table_destroy(sip_hash);",
          "967:     sip_hash = g_hash_table_new(g_str_hash , sip_equal);",
          "972:     if(!sip_headers_hash){",
          "973:         sip_headers_hash = g_hash_table_new(g_str_hash , g_str_equal);",
          "974:         for (i = 1; i < array_length(sip_headers); i++){",
          "975:             value_copy = g_strdup (sip_headers[i].name);",
          "977:             ascii_strdown_inplace(value_copy);",
          "978:             g_hash_table_insert(sip_headers_hash, (gpointer)value_copy, GINT_TO_POINTER(i));",
          "979:         }",
          "980:     }",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "988:   guint32 tags_bit_field;",
          "990:   tags_bit_field = EXP_PDU_TAG_IP_SRC_BIT + EXP_PDU_TAG_IP_DST_BIT + EXP_PDU_TAG_SRC_PORT_BIT+",
          "993:   exp_pdu_data = load_export_pdu_tags(pinfo, \"sip\", -1, tags_bit_field);",
          "",
          "[Removed Lines]",
          "991:    EXP_PDU_TAG_DST_PORT_BIT + EXP_PDU_TAG_ORIG_FNO_BIT;",
          "",
          "[Added Lines]",
          "991:       EXP_PDU_TAG_DST_PORT_BIT + EXP_PDU_TAG_ORIG_FNO_BIT;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1003: typedef struct _uri_offset_info",
          "1004: {",
          "1019: } uri_offset_info;",
          "1021: static void",
          "1022: sip_uri_offset_init(uri_offset_info *uri_offsets){",
          "1040: }",
          "",
          "[Removed Lines]",
          "1005:  gint display_name_start;",
          "1006:  gint display_name_end;",
          "1007:  gint uri_start;",
          "1008:  gint uri_end;",
          "1009:  gint uri_parameters_start;",
          "1010:  gint uri_parameters_end;",
          "1011:  gint name_addr_start;",
          "1012:  gint name_addr_end;",
          "1013:  gint uri_user_start;",
          "1014:  gint uri_user_end;",
          "1015:  gint uri_host_start;",
          "1016:  gint uri_host_end;",
          "1017:  gint uri_host_port_start;",
          "1018:  gint uri_host_port_end;",
          "1025:  uri_offsets->display_name_start = -1;",
          "1026:  uri_offsets->display_name_end = -1;",
          "1027:  uri_offsets->uri_start = -1;",
          "1028:  uri_offsets->uri_end = -1;",
          "1029:  uri_offsets->uri_parameters_start = -1;",
          "1030:  uri_offsets->uri_parameters_end = -1;",
          "1031:  uri_offsets->name_addr_start = -1;",
          "1032:  uri_offsets->name_addr_end = -1;",
          "1033:  uri_offsets->uri_user_start = -1;",
          "1034:  uri_offsets->uri_user_end = -1;",
          "1035:  uri_offsets->uri_host_start = -1;",
          "1036:  uri_offsets->uri_host_end = -1;",
          "1037:  uri_offsets->uri_host_port_start = -1;",
          "1038:  uri_offsets->uri_host_port_end = -1;",
          "",
          "[Added Lines]",
          "1005:     gint display_name_start;",
          "1006:     gint display_name_end;",
          "1007:     gint uri_start;",
          "1008:     gint uri_end;",
          "1009:     gint uri_parameters_start;",
          "1010:     gint uri_parameters_end;",
          "1011:     gint name_addr_start;",
          "1012:     gint name_addr_end;",
          "1013:     gint uri_user_start;",
          "1014:     gint uri_user_end;",
          "1015:     gint uri_host_start;",
          "1016:     gint uri_host_end;",
          "1017:     gint uri_host_port_start;",
          "1018:     gint uri_host_port_end;",
          "1025:     uri_offsets->display_name_start = -1;",
          "1026:     uri_offsets->display_name_end = -1;",
          "1027:     uri_offsets->uri_start = -1;",
          "1028:     uri_offsets->uri_end = -1;",
          "1029:     uri_offsets->uri_parameters_start = -1;",
          "1030:     uri_offsets->uri_parameters_end = -1;",
          "1031:     uri_offsets->name_addr_start = -1;",
          "1032:     uri_offsets->name_addr_end = -1;",
          "1033:     uri_offsets->uri_user_start = -1;",
          "1034:     uri_offsets->uri_user_end = -1;",
          "1035:     uri_offsets->uri_host_start = -1;",
          "1036:     uri_offsets->uri_host_end = -1;",
          "1037:     uri_offsets->uri_host_port_start = -1;",
          "1038:     uri_offsets->uri_host_port_end = -1;",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1046: dissect_sip_uri(tvbuff_t *tvb, packet_info *pinfo _U_, gint start_offset,",
          "1047:                 gint line_end_offset, uri_offset_info *uri_offsets)",
          "1048: {",
          "1163: uri_host_end_found:",
          "1197: }",
          "",
          "[Removed Lines]",
          "1049:  gchar c = '\\0';",
          "1050:  gint current_offset;",
          "1051:  gint queried_offset;",
          "1052:  gint comma_offset;",
          "1053:  gint semicolon_offset;",
          "1054:  gint parameter_end_offset;",
          "1055:  gboolean in_ipv6 = FALSE;",
          "1058:  current_offset = tvb_skip_wsp(tvb, start_offset, line_end_offset - start_offset);",
          "1060:  if(current_offset >= line_end_offset) {",
          "1062:   return -1;",
          "1063:  }",
          "1065:  uri_offsets->uri_start = current_offset;",
          "1068:  tvb_find_guint8(tvb, current_offset, line_end_offset - current_offset, ':');",
          "1069:  if (tvb_strneql(tvb, current_offset, \"sip\", 3) != 0)",
          "1070:   return -1;",
          "1072:  if(uri_offsets->uri_end == -1)",
          "1073:  {",
          "1078:   comma_offset = tvb_find_guint8(tvb, current_offset, line_end_offset - current_offset, ',');",
          "1079:   semicolon_offset = tvb_find_guint8(tvb, current_offset, line_end_offset - current_offset, ';');",
          "1081:   if (semicolon_offset != -1 && comma_offset != -1)",
          "1082:   {",
          "1083:    if(semicolon_offset < comma_offset)",
          "1084:    {",
          "1085:     uri_offsets->uri_end = semicolon_offset - 1;",
          "1086:    }",
          "1087:    else",
          "1088:    {",
          "1089:     uri_offsets->uri_end = comma_offset - 1;",
          "1090:    }",
          "1091:   }",
          "1092:   else",
          "1093:   {",
          "1094:    if (semicolon_offset != -1)",
          "1095:    {",
          "1096:     uri_offsets->uri_end = semicolon_offset - 1;",
          "1097:    }",
          "1098:    else if (comma_offset != -1)",
          "1099:    {",
          "1100:     uri_offsets->uri_end = comma_offset - 1;",
          "1101:    } else {",
          "1107:    }",
          "1108:   }",
          "1109:   uri_offsets->name_addr_end = uri_offsets->uri_end;",
          "1110:  }",
          "1115:  queried_offset = tvb_find_guint8(tvb, uri_offsets->uri_start, uri_offsets->uri_end - uri_offsets->uri_start, '@');",
          "1116:  if(queried_offset == -1)",
          "1117:  {",
          "1119:   uri_offsets->uri_host_start = tvb_find_guint8(tvb, uri_offsets->uri_start, uri_offsets->uri_end - uri_offsets->uri_start, ':')+1;",
          "1120:  }",
          "1121:  else",
          "1122:  {",
          "1124:   uri_offsets->uri_user_start = tvb_find_guint8(tvb, uri_offsets->uri_start, uri_offsets->uri_end - uri_offsets->uri_start, ':')+1;",
          "1125:   uri_offsets->uri_user_end = tvb_find_guint8(tvb, uri_offsets->uri_user_start, uri_offsets->uri_end - uri_offsets->uri_start, '@')-1;",
          "1126:   uri_offsets->uri_host_start = uri_offsets->uri_user_end + 2;",
          "1127:  }",
          "1130:  parameter_end_offset = uri_offsets->uri_host_start;",
          "1132:  in_ipv6 = (tvb_get_guint8(tvb, parameter_end_offset) == '[');",
          "1133:  while (parameter_end_offset < line_end_offset)",
          "1134:  {",
          "1135:   parameter_end_offset++;",
          "1136:   c = tvb_get_guint8(tvb, parameter_end_offset);",
          "1137:   switch (c) {",
          "1138:    case '>':",
          "1139:    case ',':",
          "1140:     goto uri_host_end_found;",
          "1141:    case ';':",
          "1142:     uri_offsets->uri_parameters_start = parameter_end_offset + 1;",
          "1143:     goto uri_host_end_found;",
          "1144:    case '?':",
          "1145:    case ' ':",
          "1146:    case '\\r':",
          "1147:     goto uri_host_end_found;",
          "1148:    case ':':",
          "1149:     if (!in_ipv6)",
          "1150:      goto uri_host_end_found;",
          "1151:     break;",
          "1152:    case '[':",
          "1153:     in_ipv6 = TRUE;",
          "1154:     break;",
          "1155:    case ']':",
          "1156:     in_ipv6 = FALSE;",
          "1157:     break;",
          "1158:    default :",
          "1159:    break;",
          "1160:   }",
          "1161:  }",
          "1165:  uri_offsets->uri_host_end = parameter_end_offset - 1;",
          "1167:  if (c == ':')",
          "1168:  {",
          "1169:   uri_offsets->uri_host_port_start = parameter_end_offset + 1;",
          "1170:   parameter_end_offset = uri_offsets->uri_host_port_start;",
          "1171:   while (parameter_end_offset < line_end_offset)",
          "1172:   {",
          "1173:    parameter_end_offset++;",
          "1174:    c = tvb_get_guint8(tvb, parameter_end_offset);",
          "1175:    switch (c) {",
          "1176:     case '>':",
          "1177:     case ',':",
          "1178:      goto uri_host_port_end_found;",
          "1179:     case ';':",
          "1180:      uri_offsets->uri_parameters_start = parameter_end_offset + 1;",
          "1181:      goto uri_host_port_end_found;",
          "1182:     case '?':",
          "1183:     case ' ':",
          "1184:     case '\\r':",
          "1185:      goto uri_host_port_end_found;",
          "1186:     default :",
          "1187:     break;",
          "1188:    }",
          "1189:   }",
          "1191:  uri_host_port_end_found:",
          "1193:   uri_offsets->uri_host_port_end = parameter_end_offset -1;",
          "1194:  }",
          "1196:  return uri_offsets->name_addr_end;",
          "",
          "[Added Lines]",
          "1049:     gchar c = '\\0';",
          "1050:     gint current_offset;",
          "1051:     gint queried_offset;",
          "1052:     gint comma_offset;",
          "1053:     gint semicolon_offset;",
          "1054:     gint parameter_end_offset;",
          "1055:     gboolean in_ipv6 = FALSE;",
          "1058:     current_offset = tvb_skip_wsp(tvb, start_offset, line_end_offset - start_offset);",
          "1060:     if(current_offset >= line_end_offset) {",
          "1062:         return -1;",
          "1063:     }",
          "1065:     uri_offsets->uri_start = current_offset;",
          "1068:     tvb_find_guint8(tvb, current_offset, line_end_offset - current_offset, ':');",
          "1069:     if (tvb_strneql(tvb, current_offset, \"sip\", 3) != 0)",
          "1070:         return -1;",
          "1072:     if(uri_offsets->uri_end == -1)",
          "1073:     {",
          "1078:         comma_offset = tvb_find_guint8(tvb, current_offset, line_end_offset - current_offset, ',');",
          "1079:         semicolon_offset = tvb_find_guint8(tvb, current_offset, line_end_offset - current_offset, ';');",
          "1081:         if (semicolon_offset != -1 && comma_offset != -1)",
          "1082:         {",
          "1083:             if(semicolon_offset < comma_offset)",
          "1084:             {",
          "1085:                 uri_offsets->uri_end = semicolon_offset - 1;",
          "1086:             }",
          "1087:             else",
          "1088:             {",
          "1089:                 uri_offsets->uri_end = comma_offset - 1;",
          "1090:             }",
          "1091:         }",
          "1092:         else",
          "1093:         {",
          "1094:             if (semicolon_offset != -1)",
          "1095:             {",
          "1096:                 uri_offsets->uri_end = semicolon_offset - 1;",
          "1097:             }",
          "1098:             else if (comma_offset != -1)",
          "1099:             {",
          "1100:                 uri_offsets->uri_end = comma_offset - 1;",
          "1101:             } else {",
          "1107:             }",
          "1108:         }",
          "1109:         uri_offsets->name_addr_end = uri_offsets->uri_end;",
          "1110:     }",
          "1115:     queried_offset = tvb_find_guint8(tvb, uri_offsets->uri_start, uri_offsets->uri_end - uri_offsets->uri_start, '@');",
          "1116:     if(queried_offset == -1)",
          "1117:     {",
          "1119:         uri_offsets->uri_host_start = tvb_find_guint8(tvb, uri_offsets->uri_start, uri_offsets->uri_end - uri_offsets->uri_start, ':')+1;",
          "1120:     }",
          "1121:     else",
          "1122:     {",
          "1124:         uri_offsets->uri_user_start = tvb_find_guint8(tvb, uri_offsets->uri_start, uri_offsets->uri_end - uri_offsets->uri_start, ':')+1;",
          "1125:         uri_offsets->uri_user_end = tvb_find_guint8(tvb, uri_offsets->uri_user_start, uri_offsets->uri_end - uri_offsets->uri_start, '@')-1;",
          "1126:         uri_offsets->uri_host_start = uri_offsets->uri_user_end + 2;",
          "1127:     }",
          "1130:     parameter_end_offset = uri_offsets->uri_host_start;",
          "1132:     in_ipv6 = (tvb_get_guint8(tvb, parameter_end_offset) == '[');",
          "1133:     while (parameter_end_offset < line_end_offset)",
          "1134:     {",
          "1135:         parameter_end_offset++;",
          "1136:         c = tvb_get_guint8(tvb, parameter_end_offset);",
          "1137:         switch (c) {",
          "1138:             case '>':",
          "1139:             case ',':",
          "1140:                 goto uri_host_end_found;",
          "1141:             case ';':",
          "1142:                 uri_offsets->uri_parameters_start = parameter_end_offset + 1;",
          "1143:                 goto uri_host_end_found;",
          "1144:             case '?':",
          "1145:             case ' ':",
          "1146:             case '\\r':",
          "1147:                 goto uri_host_end_found;",
          "1148:             case ':':",
          "1149:                 if (!in_ipv6)",
          "1150:                     goto uri_host_end_found;",
          "1151:                 break;",
          "1152:             case '[':",
          "1153:                 in_ipv6 = TRUE;",
          "1154:                 break;",
          "1155:             case ']':",
          "1156:                 in_ipv6 = FALSE;",
          "1157:                 break;",
          "1158:             default :",
          "1159:             break;",
          "1160:         }",
          "1161:     }",
          "1165:     uri_offsets->uri_host_end = parameter_end_offset - 1;",
          "1167:     if (c == ':')",
          "1168:     {",
          "1169:         uri_offsets->uri_host_port_start = parameter_end_offset + 1;",
          "1170:         parameter_end_offset = uri_offsets->uri_host_port_start;",
          "1171:         while (parameter_end_offset < line_end_offset)",
          "1172:         {",
          "1173:             parameter_end_offset++;",
          "1174:             c = tvb_get_guint8(tvb, parameter_end_offset);",
          "1175:             switch (c) {",
          "1176:                 case '>':",
          "1177:                 case ',':",
          "1178:                     goto uri_host_port_end_found;",
          "1179:                 case ';':",
          "1180:                     uri_offsets->uri_parameters_start = parameter_end_offset + 1;",
          "1181:                     goto uri_host_port_end_found;",
          "1182:                 case '?':",
          "1183:                 case ' ':",
          "1184:                 case '\\r':",
          "1185:                     goto uri_host_port_end_found;",
          "1186:                 default :",
          "1187:                 break;",
          "1188:             }",
          "1189:         }",
          "1191:     uri_host_port_end_found:",
          "1193:         uri_offsets->uri_host_port_end = parameter_end_offset -1;",
          "1194:     }",
          "1196:     return uri_offsets->name_addr_end;",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1215: dissect_sip_history_info(tvbuff_t *tvb, proto_tree* tree, packet_info *pinfo _U_, gint current_offset,",
          "1216:                 gint line_end_offset)",
          "1217: {",
          "1242: }",
          "",
          "[Removed Lines]",
          "1218:  int comma_offset;",
          "1219:  gboolean first_time = TRUE;",
          "1222:  while (line_end_offset > current_offset){",
          "1223:   comma_offset = tvb_find_guint8(tvb, current_offset, line_end_offset - current_offset, ',');",
          "1224:   if(comma_offset == -1){",
          "1225:    if(first_time == TRUE){",
          "1227:     return line_end_offset;",
          "1228:    }",
          "1230:    comma_offset = line_end_offset;",
          "1231:   }",
          "1232:   first_time = FALSE;",
          "1233:   proto_tree_add_text(tree, tvb, current_offset, comma_offset-current_offset,",
          "1234:                       \"%s\", tvb_format_text(tvb, current_offset,",
          "1235:                                       comma_offset-current_offset));",
          "1237:   current_offset = comma_offset+1;",
          "1238:  }",
          "1240:  return line_end_offset;",
          "",
          "[Added Lines]",
          "1218:     int comma_offset;",
          "1219:     gboolean first_time = TRUE;",
          "1222:     while (line_end_offset > current_offset){",
          "1223:         comma_offset = tvb_find_guint8(tvb, current_offset, line_end_offset - current_offset, ',');",
          "1224:         if(comma_offset == -1){",
          "1225:             if(first_time == TRUE){",
          "1227:                 return line_end_offset;",
          "1228:             }",
          "1230:             comma_offset = line_end_offset;",
          "1231:         }",
          "1232:         first_time = FALSE;",
          "1233:         proto_tree_add_text(tree, tvb, current_offset, comma_offset-current_offset,",
          "1234:                             \"%s\", tvb_format_text(tvb, current_offset,",
          "1235:                                             comma_offset-current_offset));",
          "1237:         current_offset = comma_offset+1;",
          "1238:     }",
          "1240:     return line_end_offset;",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1261: dissect_sip_p_charging_func_addresses(tvbuff_t *tvb, proto_tree* tree, packet_info *pinfo _U_, gint current_offset,",
          "1262:                 gint line_end_offset)",
          "1263: {",
          "1297: }",
          "",
          "[Removed Lines]",
          "1264:  int semi_offset, quote_offset;",
          "1265:  gboolean first_time = TRUE;",
          "1267:  while (line_end_offset > current_offset){",
          "1269:   quote_offset = tvb_find_guint8(tvb, current_offset, line_end_offset - current_offset, '\"');",
          "1270:   if(quote_offset>0){",
          "1272:    quote_offset = tvb_find_guint8(tvb, quote_offset+1, line_end_offset - current_offset, '\"');",
          "1274:    semi_offset = tvb_find_guint8(tvb, quote_offset+1, line_end_offset - quote_offset, ';');",
          "1275:   }else{",
          "1277:    semi_offset = tvb_find_guint8(tvb, current_offset, line_end_offset - current_offset, ';');",
          "1278:   }",
          "1279:   if(semi_offset == -1){",
          "1280:    if(first_time == TRUE){",
          "1282:    return line_end_offset;",
          "1283:    }",
          "1285:    semi_offset = line_end_offset;",
          "1286:   }",
          "1287:   first_time = FALSE;",
          "1288:   proto_tree_add_text(tree, tvb, current_offset, semi_offset-current_offset,",
          "1289:                       \"%s\", tvb_format_text(tvb, current_offset,",
          "1290:                                       semi_offset-current_offset));",
          "1292:   current_offset = semi_offset+1;",
          "1294:  }",
          "1296:  return current_offset;",
          "",
          "[Added Lines]",
          "1264:     int semi_offset, quote_offset;",
          "1265:     gboolean first_time = TRUE;",
          "1267:     while (line_end_offset > current_offset){",
          "1269:         quote_offset = tvb_find_guint8(tvb, current_offset, line_end_offset - current_offset, '\"');",
          "1270:         if(quote_offset>0){",
          "1272:             quote_offset = tvb_find_guint8(tvb, quote_offset+1, line_end_offset - current_offset, '\"');",
          "1274:             semi_offset = tvb_find_guint8(tvb, quote_offset+1, line_end_offset - quote_offset, ';');",
          "1275:         }else{",
          "1277:             semi_offset = tvb_find_guint8(tvb, current_offset, line_end_offset - current_offset, ';');",
          "1278:         }",
          "1279:         if(semi_offset == -1){",
          "1280:             if(first_time == TRUE){",
          "1282:             return line_end_offset;",
          "1283:             }",
          "1285:             semi_offset = line_end_offset;",
          "1286:         }",
          "1287:         first_time = FALSE;",
          "1288:         proto_tree_add_text(tree, tvb, current_offset, semi_offset-current_offset,",
          "1289:                             \"%s\", tvb_format_text(tvb, current_offset,",
          "1290:                                             semi_offset-current_offset));",
          "1292:         current_offset = semi_offset+1;",
          "1294:     }",
          "1296:     return current_offset;",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "1309: dissect_sip_name_addr_or_addr_spec(tvbuff_t *tvb, packet_info *pinfo _U_, gint start_offset,",
          "1310:                 gint line_end_offset, uri_offset_info *uri_offsets)",
          "1311: {",
          "1436: }",
          "",
          "[Removed Lines]",
          "1312:  gchar c;",
          "1313:  gint i;",
          "1314:  gint current_offset;",
          "1315:  gint queried_offset;",
          "1316:  gint colon_offset;",
          "1317:  gboolean uri_without_angle_quotes = FALSE;",
          "1320:  current_offset = tvb_skip_wsp(tvb, start_offset, line_end_offset - start_offset);",
          "1322:  if(current_offset >= line_end_offset) {",
          "1324:   return -1;",
          "1325:  }",
          "1327:  uri_offsets->name_addr_start = current_offset;",
          "1330:  c=tvb_get_guint8(tvb, current_offset);",
          "1331:  switch(c)",
          "1332:  {",
          "1333:   case '\"':",
          "1335:    uri_offsets->display_name_start = current_offset;",
          "1336:    do",
          "1337:    {",
          "1338:     queried_offset = tvb_find_guint8(tvb, current_offset + 1, line_end_offset - (current_offset + 1), '\"');",
          "1339:     if(queried_offset == -1)",
          "1340:     {",
          "1342:      return -1;",
          "1343:     }",
          "1344:     current_offset = queried_offset;",
          "1348:     for(i=1;tvb_get_guint8(tvb, queried_offset - i) == '\\\\';i++);",
          "1349:     i--;",
          "1351:     if(i % 2 == 0)",
          "1352:     {",
          "1354:      break;",
          "1355:     }",
          "1356:    } while (current_offset < line_end_offset);",
          "1357:    if(current_offset >= line_end_offset)",
          "1358:    {",
          "1360:     return -1;",
          "1361:    }",
          "1363:    uri_offsets->display_name_end = current_offset;",
          "1366:    queried_offset = tvb_find_guint8(tvb, current_offset, line_end_offset - current_offset, '<');",
          "1367:    if(queried_offset == -1)",
          "1368:    {",
          "1370:     return -1;",
          "1371:    }",
          "1372:    current_offset = queried_offset + 1;",
          "1373:    break;",
          "1375:   case '<':",
          "1377:    current_offset++;",
          "1378:    break;",
          "1380:   default:",
          "1383:    queried_offset = tvb_find_guint8(tvb, current_offset, line_end_offset - current_offset, '<');",
          "1384:    colon_offset = tvb_find_guint8(tvb, current_offset, line_end_offset - current_offset, ':');",
          "1385:    if(queried_offset != -1 && colon_offset != -1)",
          "1386:    {",
          "1387:     if(queried_offset < colon_offset)",
          "1388:     {",
          "1390:      uri_offsets->display_name_start = current_offset;",
          "1391:      uri_offsets->display_name_end = queried_offset - 1;",
          "1392:      current_offset = queried_offset + 1;",
          "1393:     }",
          "1394:     else",
          "1395:     {",
          "1397:      uri_without_angle_quotes = TRUE;",
          "1398:     }",
          "1399:    }",
          "1400:    else",
          "1401:    {",
          "1402:     if(queried_offset != -1)",
          "1403:     {",
          "1405:      uri_offsets->display_name_start = current_offset;",
          "1406:      uri_offsets->display_name_end = queried_offset - 1;",
          "1407:      current_offset = queried_offset + 1;",
          "1408:      break;",
          "1409:     }",
          "1410:     if(colon_offset != -1)",
          "1411:     {",
          "1413:      uri_without_angle_quotes = TRUE;",
          "1414:      break;",
          "1415:     }",
          "1417:     return -1;",
          "1418:    }",
          "1419:    break;",
          "1420:  }",
          "1422:  uri_offsets->uri_start = current_offset;",
          "1423:  if(uri_without_angle_quotes==FALSE){",
          "1426:   queried_offset = tvb_find_guint8(tvb, current_offset, line_end_offset - current_offset, '>');",
          "1427:   if(queried_offset == -1)",
          "1428:   {",
          "1430:    return -1;",
          "1431:   }",
          "1432:   uri_offsets->name_addr_end = queried_offset;",
          "1433:   uri_offsets->uri_end = queried_offset - 1;",
          "1434:  }",
          "1435:  return dissect_sip_uri(tvb, pinfo, current_offset, line_end_offset, uri_offsets);",
          "",
          "[Added Lines]",
          "1312:     gchar c;",
          "1313:     gint i;",
          "1314:     gint current_offset;",
          "1315:     gint queried_offset;",
          "1316:     gint colon_offset;",
          "1317:     gboolean uri_without_angle_quotes = FALSE;",
          "1320:     current_offset = tvb_skip_wsp(tvb, start_offset, line_end_offset - start_offset);",
          "1322:     if(current_offset >= line_end_offset) {",
          "1324:         return -1;",
          "1325:     }",
          "1327:     uri_offsets->name_addr_start = current_offset;",
          "1330:     c=tvb_get_guint8(tvb, current_offset);",
          "1331:     switch(c)",
          "1332:     {",
          "1333:         case '\"':",
          "1335:             uri_offsets->display_name_start = current_offset;",
          "1336:             do",
          "1337:             {",
          "1338:                 queried_offset = tvb_find_guint8(tvb, current_offset + 1, line_end_offset - (current_offset + 1), '\"');",
          "1339:                 if(queried_offset == -1)",
          "1340:                 {",
          "1342:                     return -1;",
          "1343:                 }",
          "1344:                 current_offset = queried_offset;",
          "1348:                 for(i=1;tvb_get_guint8(tvb, queried_offset - i) == '\\\\';i++);",
          "1349:                 i--;",
          "1351:                 if(i % 2 == 0)",
          "1352:                 {",
          "1354:                     break;",
          "1355:                 }",
          "1356:             } while (current_offset < line_end_offset);",
          "1357:             if(current_offset >= line_end_offset)",
          "1358:             {",
          "1360:                 return -1;",
          "1361:             }",
          "1363:             uri_offsets->display_name_end = current_offset;",
          "1366:             queried_offset = tvb_find_guint8(tvb, current_offset, line_end_offset - current_offset, '<');",
          "1367:             if(queried_offset == -1)",
          "1368:             {",
          "1370:                 return -1;",
          "1371:             }",
          "1372:             current_offset = queried_offset + 1;",
          "1373:             break;",
          "1375:         case '<':",
          "1377:             current_offset++;",
          "1378:             break;",
          "1380:         default:",
          "1383:             queried_offset = tvb_find_guint8(tvb, current_offset, line_end_offset - current_offset, '<');",
          "1384:             colon_offset = tvb_find_guint8(tvb, current_offset, line_end_offset - current_offset, ':');",
          "1385:             if(queried_offset != -1 && colon_offset != -1)",
          "1386:             {",
          "1387:                 if(queried_offset < colon_offset)",
          "1388:                 {",
          "1390:                     uri_offsets->display_name_start = current_offset;",
          "1391:                     uri_offsets->display_name_end = queried_offset - 1;",
          "1392:                     current_offset = queried_offset + 1;",
          "1393:                 }",
          "1394:                 else",
          "1395:                 {",
          "1397:                     uri_without_angle_quotes = TRUE;",
          "1398:                 }",
          "1399:             }",
          "1400:             else",
          "1401:             {",
          "1402:                 if(queried_offset != -1)",
          "1403:                 {",
          "1405:                     uri_offsets->display_name_start = current_offset;",
          "1406:                     uri_offsets->display_name_end = queried_offset - 1;",
          "1407:                     current_offset = queried_offset + 1;",
          "1408:                     break;",
          "1409:                 }",
          "1410:                 if(colon_offset != -1)",
          "1411:                 {",
          "1413:                     uri_without_angle_quotes = TRUE;",
          "1414:                     break;",
          "1415:                 }",
          "1417:                 return -1;",
          "1418:             }",
          "1419:             break;",
          "1420:     }",
          "1422:     uri_offsets->uri_start = current_offset;",
          "1423:     if(uri_without_angle_quotes==FALSE){",
          "1426:         queried_offset = tvb_find_guint8(tvb, current_offset, line_end_offset - current_offset, '>');",
          "1427:         if(queried_offset == -1)",
          "1428:         {",
          "1430:             return -1;",
          "1431:         }",
          "1432:         uri_offsets->name_addr_end = queried_offset;",
          "1433:         uri_offsets->uri_end = queried_offset - 1;",
          "1434:     }",
          "1435:     return dissect_sip_uri(tvb, pinfo, current_offset, line_end_offset, uri_offsets);",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "1522: static gint",
          "1523: dissect_sip_contact_item(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, gint start_offset, gint line_end_offset,",
          "1525: {",
          "1674: }",
          "",
          "[Removed Lines]",
          "1524:    guchar* contacts_expires_0, guchar* contacts_expires_unknown)",
          "1526:  gchar c;",
          "1527:  gint current_offset;",
          "1528:  gint queried_offset;",
          "1529:  gint contact_params_start_offset = -1;",
          "1531:  uri_offset_info uri_offsets;",
          "1532:  gboolean end_of_hdr = FALSE;",
          "1533:  gboolean has_expires_param = FALSE;",
          "1536:  start_offset = tvb_skip_wsp(tvb, start_offset, line_end_offset - start_offset);",
          "1538:  if(start_offset >= line_end_offset) {",
          "1540:   return -1;",
          "1541:  }",
          "1544:  sip_uri_offset_init(&uri_offsets);",
          "1546:  current_offset = dissect_sip_name_addr_or_addr_spec(tvb, pinfo, start_offset, line_end_offset, &uri_offsets);",
          "1547:  if(current_offset == -1)",
          "1548:  {",
          "1550:   return -1;",
          "1551:  }",
          "1552:  display_sip_uri(tvb, tree, &uri_offsets, &sip_contact_uri);",
          "1555:  queried_offset = tvb_find_guint8(tvb, uri_offsets.uri_end, line_end_offset - uri_offsets.uri_end, ',');",
          "1558:  contact_params_start_offset = tvb_find_guint8(tvb, uri_offsets.uri_end, line_end_offset - uri_offsets.uri_end, ';');",
          "1560:  if(contact_params_start_offset == -1) {",
          "1562:   (*contacts_expires_unknown)++;",
          "1563:   return line_end_offset;",
          "1564:  }",
          "1566:  if (queried_offset != -1 && queried_offset < contact_params_start_offset) {",
          "1568:   (*contacts_expires_unknown)++;",
          "1569:   return queried_offset;",
          "1570:  }",
          "1573:  contact_params_start_offset++;",
          "1574:  current_offset = contact_params_start_offset;",
          "1578:  queried_offset = current_offset;",
          "1580:  while(current_offset< line_end_offset){",
          "1581:   c = '\\0';",
          "1582:   while (queried_offset < line_end_offset)",
          "1583:   {",
          "1584:    queried_offset++;",
          "1585:    c = tvb_get_guint8(tvb, queried_offset);",
          "1586:    switch (c) {",
          "1588:     case '\\r':",
          "1589:     case '\\n':",
          "1590:      end_of_hdr = TRUE;",
          "1592:     case ',':",
          "1593:     case ';':",
          "1594:     case '\"':",
          "1595:      goto found;",
          "1596:      break;",
          "1597:     default :",
          "1598:      break;",
          "1599:    }",
          "1600:   }",
          "1601:  found:",
          "1602:   if(queried_offset==line_end_offset){",
          "1604:    current_offset = line_end_offset;",
          "1605:   }else if(c=='\"'){",
          "1607:    queried_offset = tvb_find_guint8(tvb, queried_offset+1, line_end_offset - queried_offset, '\"');",
          "1608:    if(queried_offset==-1){",
          "1610:     current_offset = line_end_offset;",
          "1611:    } else {",
          "1612:     current_offset = tvb_pbrk_guint8(tvb, queried_offset+1, line_end_offset - queried_offset, \",;\", &c);",
          "1613:     if(current_offset==-1){",
          "1615:      current_offset = line_end_offset;",
          "1616:     }",
          "1617:    }",
          "1618:   }else{",
          "1619:    current_offset = queried_offset;",
          "1620:   }",
          "1621:   proto_tree_add_item(tree, hf_sip_contact_param, tvb, contact_params_start_offset ,",
          "1622:    current_offset - contact_params_start_offset, ENC_ASCII|ENC_NA);",
          "1631:   if (tvb_strncaseeql(tvb, contact_params_start_offset, \"expires=\", 8) == 0) {",
          "1637:    if (atoi(tvb_get_string_enc(wmem_packet_scope(), tvb, contact_params_start_offset+8,",
          "1638:       current_offset - (contact_params_start_offset+8), ENC_UTF_8)) == 0) {",
          "1639:     (*contacts_expires_0)++;",
          "1643:     if (stat_info && stat_info->response_code > 199 && stat_info->response_code < 300) {",
          "1644:      proto_tree_add_expert_format(tree, pinfo, &ei_sip_odd_register_response,",
          "1645:       tvb, contact_params_start_offset, current_offset - contact_params_start_offset,",
          "1646:       \"SIP REGISTER %d response contains Contact with expires=0\",",
          "1647:       stat_info->response_code);",
          "1648:     }",
          "1649:    } else {",
          "1650:     has_expires_param = TRUE;",
          "1651:    }",
          "1652:   }",
          "1655:   contact_params_start_offset = current_offset+1;",
          "1656:   queried_offset = contact_params_start_offset;",
          "1657:   if (end_of_hdr) {",
          "1661:    current_offset = line_end_offset;",
          "1662:   }",
          "1663:   if (c == ',') {",
          "1665:    break;",
          "1666:   }",
          "1667:  }",
          "1669:  if (!has_expires_param) {",
          "1670:   (*contacts_expires_unknown)++;",
          "1671:  }",
          "1673:  return current_offset;",
          "",
          "[Added Lines]",
          "1524:             guchar* contacts_expires_0, guchar* contacts_expires_unknown)",
          "1526:     gchar c;",
          "1527:     gint current_offset;",
          "1528:     gint queried_offset;",
          "1529:     gint contact_params_start_offset = -1;",
          "1531:     uri_offset_info uri_offsets;",
          "1532:     gboolean end_of_hdr = FALSE;",
          "1533:     gboolean has_expires_param = FALSE;",
          "1536:     start_offset = tvb_skip_wsp(tvb, start_offset, line_end_offset - start_offset);",
          "1538:     if(start_offset >= line_end_offset) {",
          "1540:         return -1;",
          "1541:     }",
          "1544:     sip_uri_offset_init(&uri_offsets);",
          "1546:     current_offset = dissect_sip_name_addr_or_addr_spec(tvb, pinfo, start_offset, line_end_offset, &uri_offsets);",
          "1547:     if(current_offset == -1)",
          "1548:     {",
          "1550:         return -1;",
          "1551:     }",
          "1552:     display_sip_uri(tvb, tree, &uri_offsets, &sip_contact_uri);",
          "1555:     queried_offset = tvb_find_guint8(tvb, uri_offsets.uri_end, line_end_offset - uri_offsets.uri_end, ',');",
          "1558:     contact_params_start_offset = tvb_find_guint8(tvb, uri_offsets.uri_end, line_end_offset - uri_offsets.uri_end, ';');",
          "1560:     if(contact_params_start_offset == -1) {",
          "1562:         (*contacts_expires_unknown)++;",
          "1563:         return line_end_offset;",
          "1564:     }",
          "1566:     if (queried_offset != -1 && queried_offset < contact_params_start_offset) {",
          "1568:         (*contacts_expires_unknown)++;",
          "1569:         return queried_offset;",
          "1570:     }",
          "1573:     contact_params_start_offset++;",
          "1574:     current_offset = contact_params_start_offset;",
          "1578:     queried_offset = current_offset;",
          "1580:     while(current_offset< line_end_offset){",
          "1581:         c = '\\0';",
          "1582:         while (queried_offset < line_end_offset)",
          "1583:         {",
          "1584:             queried_offset++;",
          "1585:             c = tvb_get_guint8(tvb, queried_offset);",
          "1586:             switch (c) {",
          "1588:                 case '\\r':",
          "1589:                 case '\\n':",
          "1590:                     end_of_hdr = TRUE;",
          "1592:                 case ',':",
          "1593:                 case ';':",
          "1594:                 case '\"':",
          "1595:                     goto found;",
          "1596:                     break;",
          "1597:                 default :",
          "1598:                     break;",
          "1599:             }",
          "1600:         }",
          "1601:     found:",
          "1602:         if(queried_offset==line_end_offset){",
          "1604:             current_offset = line_end_offset;",
          "1605:         }else if(c=='\"'){",
          "1607:             queried_offset = tvb_find_guint8(tvb, queried_offset+1, line_end_offset - queried_offset, '\"');",
          "1608:             if(queried_offset==-1){",
          "1610:                 current_offset = line_end_offset;",
          "1611:             } else {",
          "1612:                 current_offset = tvb_pbrk_guint8(tvb, queried_offset+1, line_end_offset - queried_offset, \",;\", &c);",
          "1613:                 if(current_offset==-1){",
          "1615:                     current_offset = line_end_offset;",
          "1616:                 }",
          "1617:             }",
          "1618:         }else{",
          "1619:             current_offset = queried_offset;",
          "1620:         }",
          "1621:         proto_tree_add_item(tree, hf_sip_contact_param, tvb, contact_params_start_offset ,",
          "1622:             current_offset - contact_params_start_offset, ENC_ASCII|ENC_NA);",
          "1631:         if (tvb_strncaseeql(tvb, contact_params_start_offset, \"expires=\", 8) == 0) {",
          "1637:             if (atoi(tvb_get_string_enc(wmem_packet_scope(), tvb, contact_params_start_offset+8,",
          "1638:                         current_offset - (contact_params_start_offset+8), ENC_UTF_8)) == 0) {",
          "1639:                 (*contacts_expires_0)++;",
          "1643:                 if (stat_info && stat_info->response_code > 199 && stat_info->response_code < 300) {",
          "1644:                     proto_tree_add_expert_format(tree, pinfo, &ei_sip_odd_register_response,",
          "1645:                         tvb, contact_params_start_offset, current_offset - contact_params_start_offset,",
          "1646:                         \"SIP REGISTER %d response contains Contact with expires=0\",",
          "1647:                         stat_info->response_code);",
          "1648:                 }",
          "1649:             } else {",
          "1650:                 has_expires_param = TRUE;",
          "1651:             }",
          "1652:         }",
          "1655:         contact_params_start_offset = current_offset+1;",
          "1656:         queried_offset = contact_params_start_offset;",
          "1657:         if (end_of_hdr) {",
          "1661:             current_offset = line_end_offset;",
          "1662:         }",
          "1663:         if (c == ',') {",
          "1665:             break;",
          "1666:         }",
          "1667:     }",
          "1669:     if (!has_expires_param) {",
          "1670:         (*contacts_expires_unknown)++;",
          "1671:     }",
          "1673:     return current_offset;",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "1679: static gint",
          "1680: dissect_sip_authorization_item(tvbuff_t *tvb, proto_tree *tree, gint start_offset, gint line_end_offset)",
          "1681: {",
          "1725: found:",
          "1768: }",
          "1771: static void",
          "1772: dissect_sip_reason_header(tvbuff_t *tvb, proto_tree *tree, gint start_offset, gint line_end_offset){",
          "1810: }",
          "",
          "[Removed Lines]",
          "1682:  gint current_offset, par_name_end_offset, queried_offset;",
          "1683:  gint equals_offset = 0;",
          "1684:  gchar *name;",
          "1685:  header_parameter_t *auth_parameter;",
          "1686:  guint i = 0;",
          "1687:  gchar c = '\\0';",
          "1690:  start_offset = tvb_skip_wsp(tvb, start_offset, line_end_offset - start_offset);",
          "1692:  if (start_offset >= line_end_offset)",
          "1693:  {",
          "1695:   return -1;",
          "1696:  }",
          "1698:  current_offset = start_offset;",
          "1699:  equals_offset = tvb_find_guint8(tvb, current_offset + 1, line_end_offset - (current_offset + 1), '=');",
          "1700:  if(equals_offset == -1){",
          "1702:   return -1;",
          "1703:  }",
          "1704:  par_name_end_offset = equals_offset - 1;",
          "1705:  par_name_end_offset = tvb_skip_wsp_return(tvb,par_name_end_offset);",
          "1708:  name = tvb_get_string(wmem_packet_scope(), tvb, start_offset, par_name_end_offset-start_offset);",
          "1711:  queried_offset = par_name_end_offset;",
          "1712:  while (queried_offset < line_end_offset)",
          "1713:  {",
          "1714:    queried_offset++;",
          "1715:    c = tvb_get_guint8(tvb, queried_offset);",
          "1716:    switch (c) {",
          "1717:     case ',':",
          "1718:     case '\"':",
          "1719:      goto found;",
          "1720:      break;",
          "1721:     default :",
          "1722:      break;",
          "1723:    }",
          "1724:  }",
          "1726:  if(queried_offset==line_end_offset){",
          "1728:   current_offset = line_end_offset;",
          "1729:  }else if(c=='\"'){",
          "1731:   queried_offset = tvb_find_guint8(tvb, queried_offset+1, line_end_offset - queried_offset, '\"');",
          "1732:   if(queried_offset==-1){",
          "1734:    queried_offset = line_end_offset;",
          "1735:   }",
          "1736:   current_offset =  tvb_find_guint8(tvb, queried_offset+1, line_end_offset - queried_offset, ',');",
          "1737:   if(current_offset==-1){",
          "1739:    current_offset = line_end_offset;",
          "1740:   }",
          "1741:  }else{",
          "1742:   current_offset = queried_offset;",
          "1743:  }",
          "1746:  for (auth_parameter = &auth_parameters_hf_array[i];",
          "1747:       i < array_length(auth_parameters_hf_array);",
          "1748:       i++, auth_parameter++)",
          "1749:  {",
          "1750:   if (g_ascii_strcasecmp(name, auth_parameter->param_name) == 0)",
          "1751:   {",
          "1752:    proto_tree_add_item(tree, *(auth_parameter->hf_item), tvb,",
          "1753:                        equals_offset+1, current_offset-equals_offset-1,",
          "1754:                        ENC_ASCII|ENC_NA);",
          "1755:    break;",
          "1756:   }",
          "1757:  }",
          "1760:  if (i == array_length(auth_parameters_hf_array))",
          "1761:  {",
          "1762:   proto_tree_add_text(tree, tvb, start_offset, current_offset-start_offset,",
          "1763:                       \"%s\", tvb_format_text(tvb, start_offset,",
          "1764:                                       current_offset-start_offset));",
          "1765:  }",
          "1767:  return current_offset;",
          "1774:  gint  current_offset, semi_colon_offset, length;",
          "1775:  gchar *param_name = NULL;",
          "1776:  guint cause_value;",
          "1779:  start_offset = tvb_skip_wsp(tvb, start_offset, line_end_offset - start_offset);",
          "1781:  if (start_offset >= line_end_offset)",
          "1782:  {",
          "1784:   return;",
          "1785:  }",
          "1787:  current_offset = start_offset;",
          "1788:  semi_colon_offset = tvb_find_guint8(tvb, current_offset, line_end_offset-current_offset, ';');",
          "1790:  if(semi_colon_offset == -1)",
          "1791:   return;",
          "1793:  length = semi_colon_offset - current_offset;",
          "1794:  proto_tree_add_text(tree, tvb, start_offset, length,",
          "1795:   \"Reason Protocols: %s\", tvb_format_text(tvb, start_offset, length));",
          "1797:  param_name = tvb_get_string(wmem_packet_scope(), tvb, start_offset, length);",
          "1798:  if (g_ascii_strcasecmp(param_name, \"Q.850\") == 0){",
          "1799:   current_offset = tvb_find_guint8(tvb, semi_colon_offset, line_end_offset-semi_colon_offset, '=')+1;",
          "1800:   length = line_end_offset - current_offset;",
          "1803:   cause_value = (guint)strtoul(tvb_get_string(wmem_packet_scope(), tvb, current_offset, length), NULL, 10);",
          "1804:   proto_tree_add_text(tree, tvb, current_offset, length,",
          "1805:    \"Cause: %u(0x%x)[%s]\", cause_value,cause_value,",
          "1806:    val_to_str_ext(cause_value, &q850_cause_code_vals_ext, \"Unknown (%d)\" ));",
          "1808:  }",
          "",
          "[Added Lines]",
          "1682:     gint current_offset, par_name_end_offset, queried_offset;",
          "1683:     gint equals_offset = 0;",
          "1684:     gchar *name;",
          "1685:     header_parameter_t *auth_parameter;",
          "1686:     guint i = 0;",
          "1687:     gchar c = '\\0';",
          "1690:     start_offset = tvb_skip_wsp(tvb, start_offset, line_end_offset - start_offset);",
          "1692:     if (start_offset >= line_end_offset)",
          "1693:     {",
          "1695:         return -1;",
          "1696:     }",
          "1698:     current_offset = start_offset;",
          "1699:     equals_offset = tvb_find_guint8(tvb, current_offset + 1, line_end_offset - (current_offset + 1), '=');",
          "1700:     if(equals_offset == -1){",
          "1702:         return -1;",
          "1703:     }",
          "1704:     par_name_end_offset = equals_offset - 1;",
          "1705:     par_name_end_offset = tvb_skip_wsp_return(tvb,par_name_end_offset);",
          "1708:     name = tvb_get_string(wmem_packet_scope(), tvb, start_offset, par_name_end_offset-start_offset);",
          "1711:     queried_offset = par_name_end_offset;",
          "1712:     while (queried_offset < line_end_offset)",
          "1713:     {",
          "1714:             queried_offset++;",
          "1715:             c = tvb_get_guint8(tvb, queried_offset);",
          "1716:             switch (c) {",
          "1717:                 case ',':",
          "1718:                 case '\"':",
          "1719:                     goto found;",
          "1720:                     break;",
          "1721:                 default :",
          "1722:                     break;",
          "1723:             }",
          "1724:     }",
          "1726:     if(queried_offset==line_end_offset){",
          "1728:         current_offset = line_end_offset;",
          "1729:     }else if(c=='\"'){",
          "1731:         queried_offset = tvb_find_guint8(tvb, queried_offset+1, line_end_offset - queried_offset, '\"');",
          "1732:         if(queried_offset==-1){",
          "1734:             queried_offset = line_end_offset;",
          "1735:         }",
          "1736:         current_offset =  tvb_find_guint8(tvb, queried_offset+1, line_end_offset - queried_offset, ',');",
          "1737:         if(current_offset==-1){",
          "1739:             current_offset = line_end_offset;",
          "1740:         }",
          "1741:     }else{",
          "1742:         current_offset = queried_offset;",
          "1743:     }",
          "1746:     for (auth_parameter = &auth_parameters_hf_array[i];",
          "1747:          i < array_length(auth_parameters_hf_array);",
          "1748:          i++, auth_parameter++)",
          "1749:     {",
          "1750:         if (g_ascii_strcasecmp(name, auth_parameter->param_name) == 0)",
          "1751:         {",
          "1752:             proto_tree_add_item(tree, *(auth_parameter->hf_item), tvb,",
          "1753:                                 equals_offset+1, current_offset-equals_offset-1,",
          "1754:                                 ENC_ASCII|ENC_NA);",
          "1755:             break;",
          "1756:         }",
          "1757:     }",
          "1760:     if (i == array_length(auth_parameters_hf_array))",
          "1761:     {",
          "1762:         proto_tree_add_text(tree, tvb, start_offset, current_offset-start_offset,",
          "1763:                             \"%s\", tvb_format_text(tvb, start_offset,",
          "1764:                                             current_offset-start_offset));",
          "1765:     }",
          "1767:     return current_offset;",
          "1774:     gint  current_offset, semi_colon_offset, length;",
          "1775:     gchar *param_name = NULL;",
          "1776:     guint cause_value;",
          "1779:     start_offset = tvb_skip_wsp(tvb, start_offset, line_end_offset - start_offset);",
          "1781:     if (start_offset >= line_end_offset)",
          "1782:     {",
          "1784:         return;",
          "1785:     }",
          "1787:     current_offset = start_offset;",
          "1788:     semi_colon_offset = tvb_find_guint8(tvb, current_offset, line_end_offset-current_offset, ';');",
          "1790:     if(semi_colon_offset == -1)",
          "1791:         return;",
          "1793:     length = semi_colon_offset - current_offset;",
          "1794:     proto_tree_add_text(tree, tvb, start_offset, length,",
          "1795:         \"Reason Protocols: %s\", tvb_format_text(tvb, start_offset, length));",
          "1797:     param_name = tvb_get_string(wmem_packet_scope(), tvb, start_offset, length);",
          "1798:     if (g_ascii_strcasecmp(param_name, \"Q.850\") == 0){",
          "1799:         current_offset = tvb_find_guint8(tvb, semi_colon_offset, line_end_offset-semi_colon_offset, '=')+1;",
          "1800:         length = line_end_offset - current_offset;",
          "1803:         cause_value = (guint)strtoul(tvb_get_string(wmem_packet_scope(), tvb, current_offset, length), NULL, 10);",
          "1804:         proto_tree_add_text(tree, tvb, current_offset, length,",
          "1805:             \"Cause: %u(0x%x)[%s]\", cause_value,cause_value,",
          "1806:             val_to_str_ext(cause_value, &q850_cause_code_vals_ext, \"Unknown (%d)\" ));",
          "1808:     }",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "1827: dissect_sip_sec_mechanism(tvbuff_t *tvb, packet_info* pinfo, proto_tree *tree, gint start_offset, gint line_end_offset){",
          "1829:     gint  current_offset, semi_colon_offset, length, par_name_end_offset, equals_offset;",
          "1834:     start_offset = tvb_skip_wsp(tvb, start_offset, line_end_offset - start_offset);",
          "",
          "[Removed Lines]",
          "1830:  guint32 spi_c = 0;",
          "1831:  guint32 spi_s = 0;",
          "",
          "[Added Lines]",
          "1830:     guint32 spi_c = 0;",
          "1831:     guint32 spi_s = 0;",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "1840:     }",
          "1842:     current_offset = start_offset;",
          "1922: }",
          "",
          "[Removed Lines]",
          "1843:  semi_colon_offset = tvb_find_guint8(tvb, current_offset, line_end_offset-current_offset, ';');",
          "1844:  if(semi_colon_offset == -1){",
          "1845:   semi_colon_offset = line_end_offset;",
          "1846:  }",
          "1848:  length = semi_colon_offset-current_offset;",
          "1849:  proto_tree_add_item(tree, hf_sip_sec_mechanism, tvb,",
          "1850:                        start_offset, length,",
          "1851:                        ENC_ASCII|ENC_NA);",
          "1853:  current_offset = current_offset + length + 1;",
          "1856:  while(current_offset < line_end_offset){",
          "1857:   gchar *param_name = NULL, *value = NULL;",
          "1859:      semi_colon_offset = tvb_find_guint8(tvb, current_offset, line_end_offset-current_offset, ';');",
          "1861:      if(semi_colon_offset == -1){",
          "1862:    semi_colon_offset = line_end_offset;",
          "1863:   }",
          "1865:      length = semi_colon_offset - current_offset;",
          "1868:   equals_offset = tvb_find_guint8(tvb, current_offset + 1, length, '=');",
          "1869:   if(equals_offset != -1){",
          "1871:    par_name_end_offset = equals_offset;",
          "1873:    param_name = tvb_get_string(wmem_packet_scope(), tvb, current_offset, par_name_end_offset-current_offset);",
          "1875:    value = tvb_get_string(wmem_packet_scope(), tvb, equals_offset+1, semi_colon_offset-equals_offset+1);",
          "1876:   }",
          "1881:   if (g_ascii_strcasecmp(param_name, \"alg\") == 0){",
          "1882:    proto_tree_add_item(tree, hf_sip_sec_mechanism_alg, tvb,",
          "1883:                        equals_offset+1, semi_colon_offset-equals_offset-1,",
          "1884:                        ENC_ASCII|ENC_NA);",
          "1886:   }else if (g_ascii_strcasecmp(param_name, \"ealg\") == 0){",
          "1887:    proto_tree_add_item(tree, hf_sip_sec_mechanism_ealg, tvb,",
          "1888:                        equals_offset+1, semi_colon_offset-equals_offset-1,",
          "1889:                        ENC_ASCII|ENC_NA);",
          "1891:   }else if (g_ascii_strcasecmp(param_name, \"prot\") == 0){",
          "1892:    proto_tree_add_item(tree, hf_sip_sec_mechanism_prot, tvb,",
          "1893:                        equals_offset+1, semi_colon_offset-equals_offset-1,",
          "1894:                        ENC_ASCII|ENC_NA);",
          "1896:   }else if (g_ascii_strcasecmp(param_name, \"spi-c\") == 0){",
          "1897:    if (!value) {",
          "1898:     proto_tree_add_expert(tree, pinfo, &ei_sip_sipsec_malformed,",
          "1899:           tvb, current_offset, -1);",
          "1900:    } else {",
          "1901:     spi_c = (guint32)strtoul(value, NULL, 10);",
          "1902:     proto_tree_add_uint(tree, hf_sip_sec_mechanism_spi_c, tvb,",
          "1903:          equals_offset+1, semi_colon_offset-equals_offset-1, spi_c);",
          "1904:    }",
          "1905:   }else if (g_ascii_strcasecmp(param_name, \"spi-s\") == 0){",
          "1906:    if (!value) {",
          "1907:     proto_tree_add_expert(tree, pinfo, &ei_sip_sipsec_malformed,",
          "1908:           tvb, current_offset, -1);",
          "1909:    } else {",
          "1910:     spi_s = (guint32)strtoul(value, NULL, 10);",
          "1911:     proto_tree_add_uint(tree, hf_sip_sec_mechanism_spi_s, tvb,",
          "1912:          equals_offset+1, semi_colon_offset-equals_offset-1, spi_s);",
          "1913:    }",
          "1914:   }",
          "1916:   else{",
          "1917:    proto_tree_add_text(tree, tvb, current_offset, length,\"%s\",tvb_format_text(tvb, current_offset, length));",
          "1918:   }",
          "1919:   current_offset = semi_colon_offset+1;",
          "1920:  }",
          "",
          "[Added Lines]",
          "1843:     semi_colon_offset = tvb_find_guint8(tvb, current_offset, line_end_offset-current_offset, ';');",
          "1844:     if(semi_colon_offset == -1){",
          "1845:         semi_colon_offset = line_end_offset;",
          "1846:     }",
          "1848:     length = semi_colon_offset-current_offset;",
          "1849:     proto_tree_add_item(tree, hf_sip_sec_mechanism, tvb,",
          "1850:                                 start_offset, length,",
          "1851:                                 ENC_ASCII|ENC_NA);",
          "1853:     current_offset = current_offset + length + 1;",
          "1856:     while(current_offset < line_end_offset){",
          "1857:         gchar *param_name = NULL, *value = NULL;",
          "1859:         semi_colon_offset = tvb_find_guint8(tvb, current_offset, line_end_offset-current_offset, ';');",
          "1861:         if(semi_colon_offset == -1){",
          "1862:             semi_colon_offset = line_end_offset;",
          "1863:         }",
          "1865:         length = semi_colon_offset - current_offset;",
          "1868:         equals_offset = tvb_find_guint8(tvb, current_offset + 1, length, '=');",
          "1869:         if(equals_offset != -1){",
          "1871:             par_name_end_offset = equals_offset;",
          "1873:             param_name = tvb_get_string(wmem_packet_scope(), tvb, current_offset, par_name_end_offset-current_offset);",
          "1875:             value = tvb_get_string(wmem_packet_scope(), tvb, equals_offset+1, semi_colon_offset-equals_offset+1);",
          "1876:         }",
          "1881:         if (g_ascii_strcasecmp(param_name, \"alg\") == 0){",
          "1882:             proto_tree_add_item(tree, hf_sip_sec_mechanism_alg, tvb,",
          "1883:                                 equals_offset+1, semi_colon_offset-equals_offset-1,",
          "1884:                                 ENC_ASCII|ENC_NA);",
          "1886:         }else if (g_ascii_strcasecmp(param_name, \"ealg\") == 0){",
          "1887:             proto_tree_add_item(tree, hf_sip_sec_mechanism_ealg, tvb,",
          "1888:                                 equals_offset+1, semi_colon_offset-equals_offset-1,",
          "1889:                                 ENC_ASCII|ENC_NA);",
          "1891:         }else if (g_ascii_strcasecmp(param_name, \"prot\") == 0){",
          "1892:             proto_tree_add_item(tree, hf_sip_sec_mechanism_prot, tvb,",
          "1893:                                 equals_offset+1, semi_colon_offset-equals_offset-1,",
          "1894:                                 ENC_ASCII|ENC_NA);",
          "1896:         }else if (g_ascii_strcasecmp(param_name, \"spi-c\") == 0){",
          "1897:             if (!value) {",
          "1898:                 proto_tree_add_expert(tree, pinfo, &ei_sip_sipsec_malformed,",
          "1899:                                         tvb, current_offset, -1);",
          "1900:             } else {",
          "1901:                 spi_c = (guint32)strtoul(value, NULL, 10);",
          "1902:                 proto_tree_add_uint(tree, hf_sip_sec_mechanism_spi_c, tvb,",
          "1903:                                     equals_offset+1, semi_colon_offset-equals_offset-1, spi_c);",
          "1904:             }",
          "1905:         }else if (g_ascii_strcasecmp(param_name, \"spi-s\") == 0){",
          "1906:             if (!value) {",
          "1907:                 proto_tree_add_expert(tree, pinfo, &ei_sip_sipsec_malformed,",
          "1908:                                         tvb, current_offset, -1);",
          "1909:             } else {",
          "1910:                 spi_s = (guint32)strtoul(value, NULL, 10);",
          "1911:                 proto_tree_add_uint(tree, hf_sip_sec_mechanism_spi_s, tvb,",
          "1912:                                     equals_offset+1, semi_colon_offset-equals_offset-1, spi_s);",
          "1913:             }",
          "1914:         }",
          "1916:         else{",
          "1917:             proto_tree_add_text(tree, tvb, current_offset, length,\"%s\",tvb_format_text(tvb, current_offset, length));",
          "1918:         }",
          "1919:         current_offset = semi_colon_offset+1;",
          "1920:     }",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "1943:         if (c == ',') {",
          "1944:             sip_uri_offset_init(&uri_offsets);",
          "1945:             current_offset = dissect_sip_name_addr_or_addr_spec(tvb, pinfo, start_offset, current_offset, &uri_offsets);",
          "1948:             display_sip_uri(tvb, tree, &uri_offsets, sip_route_uri_p);",
          "1950:             current_offset++;",
          "",
          "[Removed Lines]",
          "1946:    if(current_offset == -1)",
          "1947:     return;",
          "",
          "[Added Lines]",
          "1946:             if(current_offset == -1)",
          "1947:                 return;",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "1953:         } else if (current_offset == line_end_offset - 1) {",
          "1954:             sip_uri_offset_init(&uri_offsets);",
          "1955:             current_offset = dissect_sip_name_addr_or_addr_spec(tvb, pinfo, start_offset, line_end_offset, &uri_offsets);",
          "1958:             display_sip_uri(tvb, tree, &uri_offsets, sip_route_uri_p);",
          "1960:             return;",
          "",
          "[Removed Lines]",
          "1956:    if(current_offset == -1)",
          "1957:     return;",
          "",
          "[Added Lines]",
          "1956:             if(current_offset == -1)",
          "1957:                 return;",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "1970: static void dissect_sip_via_header(tvbuff_t *tvb, proto_tree *tree, gint start_offset, gint line_end_offset)",
          "1971: {",
          "2231: }",
          "2234: static int",
          "2235: dissect_sip(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)",
          "2236: {",
          "2251: }",
          "2253: static void",
          "2254: dissect_sip_tcp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)",
          "2255: {",
          "2272: }",
          "2274: static gboolean",
          "2275: dissect_sip_tcp_heur(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)",
          "2276: {",
          "2300: }",
          "2302: static gboolean",
          "2303: dissect_sip_heur(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)",
          "2304: {",
          "2306: }",
          "2308: static int",
          "2309: dissect_sip_common(tvbuff_t *tvb, int offset, packet_info *pinfo, proto_tree *tree,",
          "2310:     gboolean dissect_other_as_continuation, gboolean use_reassembly)",
          "2311: {",
          "3317:                         break;",
          "3318:                     case POS_SECURITY_VERIFY:",
          "3322:                         sip_element_item = proto_tree_add_string_format(hdr_tree,",
          "3323:                                                          hf_header_array[hf_index], tvb,",
          "3324:                                                          offset, next_offset - offset,",
          "3325:                                                          value, \"%s\",",
          "3326:                                                          tvb_format_text(tvb, offset, linelen));",
          "3338:                         break;",
          "3339:                     default :",
          "3615: }",
          "3618: static void",
          "3619: dfilter_sip_request_line(tvbuff_t *tvb, proto_tree *tree, packet_info *pinfo, gint offset, guint meth_len, gint linelen)",
          "3620: {",
          "3650: }",
          "3653: static void",
          "3654: dfilter_sip_status_line(tvbuff_t *tvb, proto_tree *tree, packet_info *pinfo, gint line_end, gint offset)",
          "3655: {",
          "3690: }",
          "",
          "[Removed Lines]",
          "1972:  gint  current_offset;",
          "1973:  gint  transport_start_offset;",
          "1974:  gint  address_start_offset;",
          "1975:  gint  semicolon_offset;",
          "1976:  guint transport_slash_count;",
          "1977:  gboolean transport_name_started;",
          "1978:  gboolean colon_seen;",
          "1979:  gboolean ipv6_reference;",
          "1980:  gboolean ipv6_address;",
          "1981:  guchar c;",
          "1982:  gchar *param_name = NULL;",
          "1984:  current_offset = start_offset;",
          "1986:  while (1)",
          "1987:  {",
          "1989:   transport_start_offset = 0;",
          "1990:   semicolon_offset = 0;",
          "1991:   transport_name_started = FALSE;",
          "1992:   transport_slash_count = 0;",
          "1993:   ipv6_reference = FALSE;",
          "1994:   ipv6_address = FALSE;",
          "1995:   colon_seen = FALSE;",
          "1998:   current_offset = tvb_skip_wsp(tvb, current_offset, line_end_offset - current_offset);",
          "2000:   if (current_offset >= line_end_offset)",
          "2001:   {",
          "2003:    return;",
          "2004:   }",
          "2008:   while (current_offset < line_end_offset)",
          "2009:   {",
          "2010:    c = tvb_get_guint8(tvb, current_offset);",
          "2011:    if (c == '/')",
          "2012:    {",
          "2013:     transport_slash_count++;",
          "2014:    }",
          "2015:    else",
          "2016:    if (!transport_name_started && (transport_slash_count == 2) && isalpha(c))",
          "2017:    {",
          "2018:     transport_name_started = TRUE;",
          "2019:     transport_start_offset = current_offset;",
          "2020:    }",
          "2021:    else",
          "2022:    if (transport_name_started && ((c == ' ') || (c == '\\t')))",
          "2023:    {",
          "2024:     proto_tree_add_item(tree, hf_sip_via_transport, tvb, transport_start_offset,",
          "2025:          current_offset - transport_start_offset, ENC_ASCII|ENC_NA);",
          "2027:     break;",
          "2028:    }",
          "2030:    current_offset++;",
          "2031:   }",
          "2034:   current_offset = tvb_skip_wsp(tvb, current_offset, line_end_offset - current_offset);",
          "2037:   address_start_offset = current_offset;",
          "2038:   while (current_offset < line_end_offset)",
          "2039:   {",
          "2040:    c = tvb_get_guint8(tvb, current_offset);",
          "2042:    if (c == '[') {",
          "2043:     ipv6_reference = TRUE;",
          "2044:     ipv6_address = TRUE;",
          "2045:    }",
          "2046:    else if (c == ']')",
          "2047:    {",
          "2048:     ipv6_reference = FALSE;",
          "2049:    }",
          "2051:    if (colon_seen || (c == ' ') || (c == '\\t') || ((c == ':') && (ipv6_reference == FALSE)) || (c == ';'))",
          "2052:    {",
          "2053:     break;",
          "2054:    }",
          "2056:    current_offset++;",
          "2057:   }",
          "2059:   if (ipv6_address == TRUE) {",
          "2060:    proto_tree_add_item(tree, hf_sip_via_sent_by_address, tvb, address_start_offset + 1,",
          "2061:         current_offset - address_start_offset - 2, ENC_ASCII|ENC_NA);",
          "2062:   } else {",
          "2063:    proto_tree_add_item(tree, hf_sip_via_sent_by_address, tvb, address_start_offset,",
          "2064:         current_offset - address_start_offset, ENC_ASCII|ENC_NA);",
          "2065:   }",
          "2068:   current_offset = tvb_skip_wsp(tvb, current_offset, line_end_offset - current_offset);",
          "2069:   c = tvb_get_guint8(tvb, current_offset);",
          "2071:   if (c == ':')",
          "2072:   {",
          "2074:    gint port_offset;",
          "2075:    current_offset++;",
          "2078:    current_offset = tvb_skip_wsp(tvb, current_offset, line_end_offset - current_offset);",
          "2080:    port_offset = current_offset;",
          "2083:    while (current_offset < line_end_offset)",
          "2084:    {",
          "2085:     c = tvb_get_guint8(tvb, current_offset);",
          "2087:     if (!isdigit(c))",
          "2088:     {",
          "2089:      if (current_offset > port_offset)",
          "2090:      {",
          "2092:       proto_tree_add_uint(tree, hf_sip_via_sent_by_port, tvb, port_offset,",
          "2093:            current_offset - port_offset,",
          "2094:            atoi(tvb_get_string(wmem_packet_scope(), tvb, port_offset,",
          "2095:                     current_offset - port_offset)));",
          "2096:      }",
          "2097:      else",
          "2098:      {",
          "2100:       return;",
          "2101:      }",
          "2102:      break;",
          "2103:     }",
          "2105:     current_offset++;",
          "2106:    }",
          "2107:   }",
          "2110:   current_offset = tvb_skip_wsp(tvb, current_offset, line_end_offset - current_offset);",
          "2114:   while (current_offset < line_end_offset)",
          "2115:   {",
          "2116:    gboolean equals_found = FALSE;",
          "2117:    gboolean found_end_of_parameters = FALSE;",
          "2118:    gint parameter_name_end = 0;",
          "2119:    header_parameter_t *via_parameter;",
          "2120:    guint i = 0;",
          "2123:    while (current_offset < line_end_offset)",
          "2124:    {",
          "2125:     c = tvb_get_guint8(tvb, current_offset);",
          "2126:     if (c == ';')",
          "2127:     {",
          "2128:      semicolon_offset = current_offset;",
          "2129:      current_offset++;",
          "2130:      break;",
          "2131:     }",
          "2132:     else",
          "2133:     if ((c != ' ') && (c != '\\t'))",
          "2134:     {",
          "2135:      found_end_of_parameters = TRUE;",
          "2136:      break;",
          "2137:     }",
          "2138:     current_offset++;",
          "2139:    }",
          "2141:    if (found_end_of_parameters)",
          "2142:    {",
          "2143:     break;",
          "2144:    }",
          "2146:    if (current_offset == line_end_offset)",
          "2147:    {",
          "2148:     return;",
          "2149:    }",
          "2152:    while (current_offset < line_end_offset)",
          "2153:    {",
          "2154:     c = tvb_get_guint8(tvb, current_offset);",
          "2155:     if (!isalpha(c) && (c != '-'))",
          "2156:     {",
          "2157:      break;",
          "2158:     }",
          "2159:     current_offset++;",
          "2160:    }",
          "2163:    if (c == '=')",
          "2164:    {",
          "2165:     equals_found = TRUE;",
          "2166:    }",
          "2167:    parameter_name_end = current_offset;",
          "2170:    while (current_offset < line_end_offset)",
          "2171:    {",
          "2172:     c = tvb_get_guint8(tvb, current_offset);",
          "2173:     if ((c == ' ') || (c == '\\t') || (c == ';') || (c == ','))",
          "2174:     {",
          "2175:      break;",
          "2176:     }",
          "2177:     current_offset++;",
          "2178:    }",
          "2181:    param_name = tvb_get_string(wmem_packet_scope(), tvb, semicolon_offset+1,",
          "2182:               parameter_name_end - semicolon_offset - 1);",
          "2185:    for (via_parameter = &via_parameters_hf_array[i];",
          "2186:      i < array_length(via_parameters_hf_array);",
          "2187:      i++, via_parameter++)",
          "2188:    {",
          "2189:     if (g_ascii_strcasecmp(param_name, via_parameter->param_name) == 0)",
          "2190:     {",
          "2191:      if (equals_found)",
          "2192:      {",
          "2193:       proto_tree_add_item(tree, *(via_parameter->hf_item), tvb,",
          "2194:            parameter_name_end+1, current_offset-parameter_name_end-1,",
          "2195:            ENC_ASCII|ENC_NA);",
          "2196:      }",
          "2197:      else",
          "2198:      {",
          "2199:       proto_tree_add_item(tree, *(via_parameter->hf_item), tvb,",
          "2200:            semicolon_offset+1, current_offset-semicolon_offset-1,",
          "2201:            ENC_ASCII|ENC_NA);",
          "2202:      }",
          "2203:      break;",
          "2204:     }",
          "2205:    }",
          "2208:    if (i == array_length(via_parameters_hf_array))",
          "2209:    {",
          "2210:     proto_tree_add_text(tree, tvb, semicolon_offset+1, current_offset-semicolon_offset-1,",
          "2211:          \"%s\", tvb_format_text(tvb, semicolon_offset+1,",
          "2212:          current_offset-semicolon_offset-1));",
          "2213:    }",
          "2216:    current_offset = tvb_skip_wsp(tvb, current_offset, line_end_offset - current_offset);",
          "2219:    if (current_offset < line_end_offset)",
          "2220:    {",
          "2221:     c = tvb_get_guint8(tvb, current_offset);",
          "2222:     if (c == ',')",
          "2223:     {",
          "2225:      current_offset++;",
          "2226:      break;",
          "2227:     }",
          "2228:    }",
          "2229:   }",
          "2230:  }",
          "2237:  guint8 octet;",
          "2238:  int len;",
          "2240:  octet = tvb_get_guint8(tvb,0);",
          "2241:  if ((octet  & 0xf8) == 0xf8){",
          "2242:   call_dissector(sigcomp_handle, tvb, pinfo, tree);",
          "2243:   return tvb_length(tvb);",
          "2244:  }",
          "2246:  len = dissect_sip_common(tvb, 0, pinfo, tree, FALSE, FALSE);",
          "2247:  if (len < 0)",
          "2249:  else",
          "2250:   return len;",
          "2256:  guint8 octet;",
          "2257:  int offset = 0;",
          "2258:  int len;",
          "2260:  octet = tvb_get_guint8(tvb,0);",
          "2261:  if ((octet  & 0xf8) == 0xf8){",
          "2262:   call_dissector(sigcomp_handle, tvb, pinfo, tree);",
          "2263:   return;",
          "2264:  }",
          "2266:  while (tvb_reported_length_remaining(tvb, offset) > 0) {",
          "2267:   len = dissect_sip_common(tvb, offset, pinfo, tree, TRUE, TRUE);",
          "2268:   if (len <= 0)",
          "2269:    break;",
          "2270:   offset += len;",
          "2271:  }",
          "2277:  int offset = 0;",
          "2278:  int len;",
          "2279:  gboolean first = TRUE;",
          "2281:  while (tvb_reported_length_remaining(tvb, offset) > 0) {",
          "2282:   len = dissect_sip_common(tvb, offset, pinfo, tree, !first, TRUE);",
          "2283:   if (len == -2) {",
          "2284:    if (first) {",
          "2290:     return FALSE;",
          "2291:    }",
          "2292:    break;",
          "2293:   }",
          "2294:   if (len == -1)",
          "2296:   offset += len;",
          "2297:   first = FALSE;",
          "2298:  }",
          "2299:  return TRUE;",
          "2305:  return dissect_sip_common(tvb, 0, pinfo, tree, FALSE, FALSE) > 0;",
          "2312:  int orig_offset;",
          "2313:  gint next_offset, linelen;",
          "2314:  int content_length, datalen, reported_datalen;",
          "2315:  line_type_t line_type;",
          "2316:  tvbuff_t *next_tvb;",
          "2317:  gboolean is_known_request;",
          "2318:  gboolean found_match = FALSE;",
          "2319:  const char *descr;",
          "2320:  guint token_1_len = 0;",
          "2321:  guint current_method_idx = SIP_METHOD_INVALID;",
          "2322:  proto_item *ts = NULL, *ti_a = NULL, *th = NULL, *sip_element_item = NULL;",
          "2323:  proto_tree *sip_tree  = NULL, *reqresp_tree      = NULL, *hdr_tree  = NULL,",
          "2327:  guchar contacts = 0, contact_is_star = 0, expires_is_0 = 0, contacts_expires_0 = 0, contacts_expires_unknown = 0;",
          "2328:  guint32 cseq_number = 0;",
          "2329:  guchar  cseq_number_set = 0;",
          "2330:  char    cseq_method[MAX_CSEQ_METHOD_SIZE] = \"\";",
          "2331:  char call_id[MAX_CALL_ID_SIZE] = \"\";",
          "2332:  gchar  *media_type_str_lower_case = NULL;",
          "2333:  char   *content_type_parameter_str = NULL;",
          "2334:  char   *content_encoding_parameter_str = NULL;",
          "2335:  guint   resend_for_packet = 0;",
          "2336:  guint   request_for_response = 0;",
          "2337:  guint32 response_time = 0;",
          "2338:  int     strlen_to_copy;",
          "2346:  if (!dissect_other_as_continuation &&",
          "2347:      ((tvb_reported_length_remaining(tvb, offset) < 1) || !isprint(tvb_get_guint8(tvb, offset))))",
          "2348:  {",
          "2349:   return -2;",
          "2350:  }",
          "2360:  orig_offset = offset;",
          "2361:  linelen = tvb_find_line_end(tvb, offset, -1, &next_offset, FALSE);",
          "2362:  if(linelen==0){",
          "2363:   return -2;",
          "2364:  }",
          "2366:  if (tvb_strnlen(tvb, offset, linelen) > -1)",
          "2367:  {",
          "2373:   return -2;",
          "2374:  }",
          "2375:  line_type = sip_parse_line(tvb, offset, linelen, &token_1_len);",
          "2377:  if (line_type == OTHER_LINE) {",
          "2381:   if (!dissect_other_as_continuation) {",
          "2385:    return -2;",
          "2386:   }",
          "2391:  } else if ((use_reassembly)&&( pinfo->ptype == PT_TCP)) {",
          "2398:   if (!req_resp_hdrs_do_reassembly(tvb, offset, pinfo,",
          "2399:       sip_desegment_headers, sip_desegment_body)) {",
          "2403:    return -1;",
          "2404:   }",
          "2405:  }",
          "2410:  stat_info = wmem_new0(wmem_packet_scope(), sip_info_value_t);",
          "2412:  col_set_str(pinfo->cinfo, COL_PROTOCOL, \"SIP\");",
          "2414:  switch (line_type) {",
          "2416:  case REQUEST_LINE:",
          "2417:   is_known_request = sip_is_known_request(tvb, offset, token_1_len, &current_method_idx);",
          "2418:   descr = is_known_request ? \"Request\" : \"Unknown request\";",
          "2419:   col_add_fstr(pinfo->cinfo, COL_INFO, \"%s: %s\",",
          "2420:                descr,",
          "2421:                tvb_format_text(tvb, offset, linelen - SIP2_HDR_LEN - 1));",
          "2422:   break;",
          "2424:  case STATUS_LINE:",
          "2425:   descr = \"Status\";",
          "2426:   col_add_fstr(pinfo->cinfo, COL_INFO, \"Status: %s\",",
          "2427:                tvb_format_text(tvb, offset + SIP2_HDR_LEN + 1, linelen - SIP2_HDR_LEN - 1));",
          "2428:   stat_info->reason_phrase = tvb_get_string(wmem_packet_scope(), tvb, offset + SIP2_HDR_LEN + 5, linelen - (SIP2_HDR_LEN + 5));",
          "2429:   break;",
          "2431:  case OTHER_LINE:",
          "2433:   descr = \"Continuation\";",
          "2434:   col_set_str(pinfo->cinfo, COL_INFO, \"Continuation\");",
          "2435:   break;",
          "2436:  }",
          "2438:  if (tree) {",
          "2439:   ts = proto_tree_add_item(tree, proto_sip, tvb, offset, -1, ENC_NA);",
          "2440:   sip_tree = proto_item_add_subtree(ts, ett_sip);",
          "2441:  }",
          "2443:  switch (line_type) {",
          "2445:  case REQUEST_LINE:",
          "2446:   if (sip_tree) {",
          "2447:    ti_a = proto_tree_add_item(sip_tree, hf_Request_Line, tvb,",
          "2448:       offset, linelen, ENC_ASCII|ENC_NA);",
          "2450:    reqresp_tree = proto_item_add_subtree(ti_a, ett_sip_reqresp);",
          "2451:   }",
          "2452:   dfilter_sip_request_line(tvb, reqresp_tree, pinfo, offset, token_1_len, linelen);",
          "2453:   break;",
          "2455:  case STATUS_LINE:",
          "2456:   if (sip_tree) {",
          "2457:    ti_a = proto_tree_add_item(sip_tree, hf_sip_Status_Line, tvb,",
          "2458:       offset, linelen, ENC_ASCII|ENC_NA);",
          "2459:    reqresp_tree = proto_item_add_subtree(ti_a, ett_sip_reqresp);",
          "2460:   }",
          "2461:   dfilter_sip_status_line(tvb, reqresp_tree, pinfo, linelen, offset);",
          "2462:   break;",
          "2464:  case OTHER_LINE:",
          "2465:   if (sip_tree) {",
          "2466:    ti_a = proto_tree_add_text(sip_tree, tvb, offset, next_offset,",
          "2467:                             \"%s line: %s\", descr,",
          "2468:                             tvb_format_text(tvb, offset, linelen));",
          "2469:    reqresp_tree = proto_item_add_subtree(ti_a, ett_sip_reqresp);",
          "2471:    proto_tree_add_text(reqresp_tree, tvb, offset, -1, \"Continuation data\");",
          "2472:   }",
          "2473:   return tvb_length_remaining(tvb, offset);",
          "2474:  }",
          "2476:  offset = next_offset;",
          "2477:  if (sip_tree) {",
          "2478:   th = proto_tree_add_item(sip_tree, hf_sip_msg_hdr, tvb, offset,",
          "2479:                            tvb_length_remaining(tvb, offset), ENC_ASCII|ENC_NA);",
          "2480:   proto_item_set_text(th, \"Message Header\");",
          "2481:   hdr_tree = proto_item_add_subtree(th, ett_sip_hdr);",
          "2482:  }",
          "2489:  next_offset = offset;",
          "2490:  content_length = -1;",
          "2491:  while (tvb_reported_length_remaining(tvb, offset) > 0) {",
          "2492:   gint line_end_offset;",
          "2493:   gint colon_offset;",
          "2494:   gint semi_colon_offset;",
          "2495:   gint parameter_offset;",
          "2496:   gint parameter_end_offset;",
          "2497:   gint parameter_len;",
          "2498:   gint content_type_len, content_type_parameter_str_len;",
          "2499:   gint header_len;",
          "2500:   gchar *header_name;",
          "2501:   dissector_handle_t ext_hdr_handle;",
          "2502:   gint hf_index;",
          "2503:   gint value_offset;",
          "2504:   gint sub_value_offset;",
          "2505:   gint comma_offset;",
          "2506:   guchar c;",
          "2507:   gint value_len;",
          "2508:   char *value;",
          "2509:   gboolean is_no_header_termination = FALSE;",
          "2510:   proto_tree *tc_uri_item_tree = NULL;",
          "2511:   uri_offset_info uri_offsets;",
          "2517:   linelen = tvb_find_line_end(tvb, offset, -1, &next_offset, FALSE);",
          "2518:   if (linelen == 0) {",
          "2523:    offset = next_offset;",
          "2524:    break;",
          "2525:   }",
          "2527:   line_end_offset = offset + linelen;",
          "2528:   if(tvb_reported_length_remaining(tvb, next_offset) <= 0){",
          "2529:    is_no_header_termination = TRUE;",
          "2530:   }else{",
          "2531:    while ((c = tvb_get_guint8(tvb, next_offset)) == ' ' || c == '\\t')",
          "2532:    {",
          "2538:     linelen += (next_offset - line_end_offset);",
          "2539:     linelen += tvb_find_line_end(tvb, next_offset, -1, &next_offset, FALSE);",
          "2540:     line_end_offset = offset + linelen;",
          "2541:    }",
          "2542:   }",
          "2543:   colon_offset = tvb_find_guint8(tvb, offset, linelen, ':');",
          "2544:   if (colon_offset == -1) {",
          "2548:    if(hdr_tree) {",
          "2549:     proto_tree_add_text(hdr_tree, tvb, offset,",
          "2550:                         next_offset - offset, \"%s\",",
          "2551:                         tvb_format_text(tvb, offset, linelen));",
          "2552:    }",
          "2553:   } else {",
          "2554:    header_len = colon_offset - offset;",
          "2555:    header_name = (gchar*)tvb_get_string(wmem_packet_scope(), tvb, offset, header_len);",
          "2556:    ascii_strdown_inplace(header_name);",
          "2557:    hf_index = sip_is_known_sip_header(header_name, header_len);",
          "2562:    value_offset = tvb_skip_wsp(tvb, colon_offset + 1, line_end_offset - (colon_offset + 1));",
          "2567:    value_len = (gint) (line_end_offset - value_offset);",
          "2568:    value = tvb_get_string(wmem_packet_scope(), tvb, value_offset, value_len);",
          "2570:    if (hf_index == -1) {",
          "2571:     proto_item *ti_c = proto_tree_add_text(hdr_tree, tvb,",
          "2572:                                          offset, next_offset - offset, \"%s\",",
          "2573:                                          tvb_format_text(tvb, offset, linelen));",
          "2574:     ext_hdr_handle = dissector_get_string_handle(ext_hdr_subdissector_table, header_name);",
          "2575:     if (ext_hdr_handle != NULL) {",
          "2576:      tvbuff_t *next_tvb2;",
          "2577:      next_tvb2 = tvb_new_subset(tvb, value_offset, value_len, value_len);",
          "2578:      dissector_try_string(ext_hdr_subdissector_table, header_name, next_tvb2, pinfo, proto_item_add_subtree(ti_c, ett_sip_ext_hdr), NULL);",
          "2579:      } else {",
          "2580:      expert_add_info_format(pinfo, ti_c, &ei_sip_unrecognized_header,",
          "2581:                             \"Unrecognised SIP header (%s)\",",
          "2582:                             tvb_format_text(tvb, offset, header_len));",
          "2583:     }",
          "2584:    } else {",
          "2589:     switch ( hf_index ) {",
          "2591:      case POS_TO :",
          "2593:       if(hdr_tree) {",
          "2594:        proto_item *item;",
          "2596:        sip_element_item = proto_tree_add_string_format(hdr_tree,",
          "2597:                           hf_header_array[hf_index], tvb,",
          "2598:                           offset, next_offset - offset,",
          "2599:                           value, \"%s\",",
          "2600:                           tvb_format_text(tvb, offset, linelen));",
          "2601:        sip_element_tree = proto_item_add_subtree( sip_element_item,",
          "2602:                           ett_sip_element);",
          "2606:        sip_uri_offset_init(&uri_offsets);",
          "2607:        if((dissect_sip_name_addr_or_addr_spec(tvb, pinfo, value_offset, line_end_offset+2, &uri_offsets)) != -1){",
          "2608:         display_sip_uri(tvb, sip_element_tree, &uri_offsets, &sip_to_uri);",
          "2609:         if((uri_offsets.name_addr_start != -1) && (uri_offsets.name_addr_end != -1)){",
          "2610:          stat_info->tap_to_addr=tvb_get_string(wmem_packet_scope(), tvb, uri_offsets.name_addr_start,",
          "2611:           uri_offsets.name_addr_end - uri_offsets.name_addr_start);",
          "2612:         }",
          "2613:         offset = uri_offsets.name_addr_end +1;",
          "2614:        }",
          "2621:        parameter_offset = offset;",
          "2622:        while (parameter_offset < line_end_offset",
          "2623:            && (tvb_strneql(tvb, parameter_offset, \"tag=\", 4) != 0))",
          "2624:         parameter_offset++;",
          "2627:         parameter_offset = parameter_offset + 4;",
          "2628:         parameter_end_offset = tvb_find_guint8(tvb, parameter_offset,",
          "2629:                     (line_end_offset - parameter_offset), ';');",
          "2630:         if ( parameter_end_offset == -1)",
          "2631:          parameter_end_offset = line_end_offset;",
          "2632:         parameter_len = parameter_end_offset - parameter_offset;",
          "2633:         proto_tree_add_item(sip_element_tree, hf_sip_to_tag, tvb, parameter_offset,",
          "2634:              parameter_len, ENC_ASCII|ENC_NA);",
          "2635:         item = proto_tree_add_item(sip_element_tree, hf_sip_tag, tvb, parameter_offset,",
          "2636:                  parameter_len, ENC_ASCII|ENC_NA);",
          "2637:         PROTO_ITEM_SET_HIDDEN(item);",
          "2640:         switch (current_method_idx) {",
          "2642:         case SIP_METHOD_INVITE:",
          "2643:         case SIP_METHOD_SUBSCRIBE:",
          "2644:         case SIP_METHOD_REFER:",
          "2645:          col_append_str(pinfo->cinfo, COL_INFO, \", in-dialog\");",
          "2646:          break;",
          "2647:         }",
          "2648:        }",
          "2650:      break;",
          "2652:      case POS_FROM :",
          "2653:       if(hdr_tree) {",
          "2654:        proto_item *item;",
          "2656:        sip_element_item = proto_tree_add_string_format(hdr_tree,",
          "2657:                           hf_header_array[hf_index], tvb,",
          "2658:                           offset, next_offset - offset,",
          "2659:                           value, \"%s\",",
          "2660:                           tvb_format_text(tvb, offset, linelen));",
          "2661:        sip_element_tree = proto_item_add_subtree( sip_element_item, ett_sip_element);",
          "2668:        sip_uri_offset_init(&uri_offsets);",
          "2669:        if((dissect_sip_name_addr_or_addr_spec(tvb, pinfo, value_offset, line_end_offset+2, &uri_offsets)) != -1){",
          "2670:         display_sip_uri(tvb, sip_element_tree, &uri_offsets, &sip_from_uri);",
          "2671:         if((uri_offsets.name_addr_start != -1) && (uri_offsets.name_addr_end != -1)){",
          "2672:          stat_info->tap_from_addr=tvb_get_string(wmem_packet_scope(), tvb, uri_offsets.name_addr_start,",
          "2673:           uri_offsets.name_addr_end - uri_offsets.name_addr_start);",
          "2674:         }",
          "2675:         offset = uri_offsets.name_addr_end +1;",
          "2676:        }",
          "2683:        parameter_offset = offset;",
          "2684:        while (parameter_offset < line_end_offset",
          "2685:            && (tvb_strneql(tvb, parameter_offset, \"tag=\", 4) != 0))",
          "2686:         parameter_offset++;",
          "2688:         parameter_offset = parameter_offset + 4;",
          "2689:         parameter_end_offset = tvb_find_guint8(tvb, parameter_offset,",
          "2690:                     (line_end_offset - parameter_offset), ';');",
          "2691:         if ( parameter_end_offset == -1)",
          "2692:          parameter_end_offset = line_end_offset;",
          "2693:         parameter_len = parameter_end_offset - parameter_offset;",
          "2694:         proto_tree_add_item(sip_element_tree, hf_sip_from_tag, tvb, parameter_offset,",
          "2695:              parameter_len, ENC_ASCII|ENC_NA);",
          "2696:         item = proto_tree_add_item(sip_element_tree, hf_sip_tag, tvb, parameter_offset,",
          "2697:                  parameter_len, ENC_ASCII|ENC_NA);",
          "2698:         PROTO_ITEM_SET_HIDDEN(item);",
          "2699:        }",
          "2701:      break;",
          "2703:      case POS_P_ASSERTED_IDENTITY :",
          "2704:       if(hdr_tree)",
          "2705:       {",
          "2706:        sip_element_item = proto_tree_add_string_format(hdr_tree,",
          "2707:                           hf_header_array[hf_index], tvb,",
          "2708:                           offset, next_offset - offset,",
          "2709:                           value, \"%s\",",
          "2710:                           tvb_format_text(tvb, offset, linelen));",
          "2711:        sip_element_tree = proto_item_add_subtree( sip_element_item,",
          "2712:                           ett_sip_element);",
          "2721:        sip_uri_offset_init(&uri_offsets);",
          "2722:        if((dissect_sip_name_addr_or_addr_spec(tvb, pinfo, value_offset, line_end_offset+2, &uri_offsets)) != -1)",
          "2723:          display_sip_uri(tvb, sip_element_tree, &uri_offsets, &sip_pai_uri);",
          "2724:       }",
          "2725:       break;",
          "2726:      case POS_HISTORY_INFO:",
          "2727:       if(hdr_tree)",
          "2728:       {",
          "2729:        sip_element_item = proto_tree_add_string_format(hdr_tree,",
          "2730:                           hf_header_array[hf_index], tvb,",
          "2731:                           offset, next_offset - offset,",
          "2732:                           value, \"%s\",",
          "2733:                           tvb_format_text(tvb, offset, linelen));",
          "2734:        sip_element_tree = proto_item_add_subtree( sip_element_item,",
          "2735:                           ett_sip_hist);",
          "2736:        dissect_sip_history_info(tvb, sip_element_tree, pinfo, value_offset, line_end_offset);",
          "2737:       }",
          "2738:       break;",
          "2740:      case POS_P_CHARGING_FUNC_ADDRESSES:",
          "2741:       if(hdr_tree)",
          "2742:       {",
          "2743:        sip_element_item = proto_tree_add_string_format(hdr_tree,",
          "2744:                           hf_header_array[hf_index], tvb,",
          "2745:                           offset, next_offset - offset,",
          "2746:                           value, \"%s\",",
          "2747:                           tvb_format_text(tvb, offset, linelen));",
          "2748:        sip_element_tree = proto_item_add_subtree( sip_element_item,",
          "2749:                           ett_sip_element);",
          "2750:        dissect_sip_p_charging_func_addresses(tvb, sip_element_tree, pinfo, value_offset, line_end_offset);",
          "2751:       }",
          "2752:       break;",
          "2754:      case POS_P_PREFERRED_IDENTITY :",
          "2755:       if(hdr_tree)",
          "2756:       {",
          "2757:        sip_element_item = proto_tree_add_string_format(hdr_tree,",
          "2758:                           hf_header_array[hf_index], tvb,",
          "2759:                           offset, next_offset - offset,",
          "2760:                           value, \"%s\",",
          "2761:                           tvb_format_text(tvb, offset, linelen));",
          "2762:        sip_element_tree = proto_item_add_subtree( sip_element_item,",
          "2763:                           ett_sip_element);",
          "2771:        sip_uri_offset_init(&uri_offsets);",
          "2772:        if((dissect_sip_name_addr_or_addr_spec(tvb, pinfo, value_offset, line_end_offset+2, &uri_offsets)) != -1)",
          "2773:          display_sip_uri(tvb, sip_element_tree, &uri_offsets, &sip_ppi_uri);",
          "2774:       }",
          "2775:       break;",
          "2777:      case POS_PERMISSION_MISSING :",
          "2778:       if(hdr_tree)",
          "2779:       {",
          "2780:        sip_element_item = proto_tree_add_string_format(hdr_tree,",
          "2781:                        hf_header_array[hf_index], tvb,",
          "2782:                        offset, next_offset - offset,",
          "2783:                        value, \"%s\",",
          "2784:                        tvb_format_text(tvb, offset, linelen));",
          "2786:        sip_element_tree = proto_item_add_subtree( sip_element_item,",
          "2787:                          ett_sip_element);",
          "2795:        sip_uri_offset_init(&uri_offsets);",
          "2796:        if((dissect_sip_name_addr_or_addr_spec(tvb, pinfo, value_offset, line_end_offset+2, &uri_offsets)) != -1)",
          "2797:          display_sip_uri(tvb, sip_element_tree, &uri_offsets, &sip_pmiss_uri);",
          "2798:       }",
          "2799:       break;",
          "2802:      case POS_TRIGGER_CONSENT :",
          "2803:       if(hdr_tree)",
          "2804:       {",
          "2805:        sip_element_item = proto_tree_add_string_format(hdr_tree,",
          "2806:                  hf_header_array[hf_index], tvb,",
          "2807:                  offset, next_offset - offset,",
          "2808:                  value, \"%s\",",
          "2809:                  tvb_format_text(tvb, offset, linelen));",
          "2811:        sip_element_tree = proto_item_add_subtree( sip_element_item,",
          "2812:                   ett_sip_element);",
          "2823:        sip_uri_offset_init(&uri_offsets);",
          "2824:        if((dissect_sip_uri(tvb, pinfo, value_offset, line_end_offset+2, &uri_offsets)) != -1) {",
          "2826:         tc_uri_item_tree = display_sip_uri(tvb, sip_element_tree, &uri_offsets, &sip_tc_uri);",
          "2827:         if (line_end_offset > uri_offsets.uri_end) {",
          "2828:          gint hparam_offset = uri_offsets.uri_end + 1;",
          "2830:          if (tvb_find_guint8(tvb, hparam_offset, 1,';')) {",
          "2831:           while ((hparam_offset != -1 && hparam_offset < line_end_offset) )  {",
          "2833:            hparam_offset = hparam_offset + 1;",
          "2834:            if (tvb_strncaseeql(tvb, hparam_offset, \"target-uri=\\\"\", 12) == 0) {",
          "2835:             gint turi_start_offset = hparam_offset + 12;",
          "2836:             gint turi_end_offset   = tvb_find_guint8(tvb, turi_start_offset, -1,'\\\"');",
          "2837:             if (turi_end_offset != -1)",
          "2838:              proto_tree_add_item(tc_uri_item_tree, hf_sip_tc_turi, tvb, turi_start_offset,(turi_end_offset - turi_start_offset),ENC_ASCII|ENC_NA);",
          "2839:             else",
          "2841:            }",
          "2842:            hparam_offset = tvb_find_guint8(tvb, hparam_offset, -1,';');",
          "2843:           }",
          "2844:          }",
          "2845:         }",
          "2846:        }",
          "2848:       break;",
          "2850:      case POS_CSEQ :",
          "2852:       cseq_number = (guint32)strtoul(value, NULL, 10);",
          "2853:       cseq_number_set = 1;",
          "2854:       stat_info->tap_cseq_number=cseq_number;",
          "2857:       if (hdr_tree) {",
          "2858:        sip_element_item = proto_tree_add_string_format(hdr_tree,",
          "2859:                                     hf_header_array[hf_index], tvb,",
          "2860:                                     offset, next_offset - offset,",
          "2861:                                     value, \"%s\",",
          "2862:                                     tvb_format_text(tvb, offset, linelen));",
          "2863:        cseq_tree = proto_item_add_subtree(sip_element_item, ett_sip_cseq);",
          "2864:       }",
          "2868:       for (sub_value_offset=0; sub_value_offset < value_len; sub_value_offset++)",
          "2869:       {",
          "2870:        if (!isdigit((guchar)value[sub_value_offset]))",
          "2871:        {",
          "2872:         proto_tree_add_uint(cseq_tree, hf_sip_cseq_seq_no,",
          "2873:                             tvb, value_offset, sub_value_offset,",
          "2874:                             cseq_number);",
          "2875:         break;",
          "2876:        }",
          "2877:       }",
          "2879:       for (; sub_value_offset < value_len; sub_value_offset++)",
          "2880:       {",
          "2881:        if (isalpha((guchar)value[sub_value_offset]))",
          "2882:        {",
          "2884:         break;",
          "2885:        }",
          "2886:       }",
          "2888:       if (sub_value_offset == value_len)",
          "2889:       {",
          "2891:        THROW(ReportedBoundsError);",
          "2892:        return offset - orig_offset;",
          "2893:       }",
          "2896:       strlen_to_copy = (int)value_len-sub_value_offset;",
          "2897:       if (strlen_to_copy > MAX_CSEQ_METHOD_SIZE) {",
          "2899:        if (hdr_tree) {",
          "2900:         proto_tree_add_string_format(hdr_tree,",
          "2901:                                      hf_header_array[hf_index], tvb,",
          "2902:                                      offset, next_offset - offset,",
          "2903:                                      value+sub_value_offset, \"%s String too big: %d bytes\",",
          "2904:                                      sip_headers[POS_CSEQ].name,",
          "2905:                                      strlen_to_copy);",
          "2906:        }",
          "2907:        THROW(ReportedBoundsError);",
          "2908:        return offset - orig_offset;",
          "2909:       }",
          "2910:       else {",
          "2911:        g_strlcpy(cseq_method, value+sub_value_offset, MAX_CSEQ_METHOD_SIZE);",
          "2914:        if (cseq_tree)",
          "2915:        {",
          "2916:         proto_tree_add_item(cseq_tree, hf_sip_cseq_method, tvb,",
          "2917:                             value_offset + sub_value_offset, strlen_to_copy, ENC_ASCII|ENC_NA);",
          "2918:        }",
          "2919:       }",
          "2920:      break;",
          "2922:      case POS_RACK :",
          "2923:      {",
          "2924:       int cseq_no_offset;",
          "2928:       if (hdr_tree) {",
          "2929:        sip_element_item = proto_tree_add_string_format(hdr_tree,",
          "2930:                                     hf_header_array[hf_index], tvb,",
          "2931:                                     offset, next_offset - offset,",
          "2932:                                     value, \"%s\",",
          "2933:                                     tvb_format_text(tvb, offset, linelen));",
          "2934:        rack_tree = proto_item_add_subtree(sip_element_item, ett_sip_rack);",
          "2935:       }",
          "2938:       for (sub_value_offset=0; sub_value_offset < value_len; sub_value_offset++)",
          "2939:       {",
          "2940:        if (!isdigit((guchar)value[sub_value_offset]))",
          "2941:        {",
          "2942:         proto_tree_add_uint(rack_tree, hf_sip_rack_rseq_no,",
          "2943:                             tvb, value_offset, sub_value_offset,",
          "2944:                             (guint32)strtoul(value, NULL, 10));",
          "2945:         break;",
          "2946:        }",
          "2947:       }",
          "2950:       for ( ; sub_value_offset < value_len; sub_value_offset++)",
          "2951:       {",
          "2952:        if (value[sub_value_offset] != ' ' &&",
          "2953:               value[sub_value_offset] != '\\t')",
          "2954:        {",
          "2955:         break;",
          "2956:        }",
          "2957:       }",
          "2958:       cseq_no_offset = sub_value_offset;",
          "2961:       for ( ; sub_value_offset < value_len; sub_value_offset++)",
          "2962:       {",
          "2963:        if (!isdigit((guchar)value[sub_value_offset]))",
          "2964:        {",
          "2965:         proto_tree_add_uint(rack_tree, hf_sip_rack_cseq_no,",
          "2966:                             tvb, value_offset+cseq_no_offset,",
          "2967:                             sub_value_offset-cseq_no_offset,",
          "2968:                             (guint32)strtoul(value+cseq_no_offset, NULL, 10));",
          "2969:         break;",
          "2970:        }",
          "2971:       }",
          "2974:       for ( ; sub_value_offset < value_len; sub_value_offset++)",
          "2975:       {",
          "2976:        if (isalpha((guchar)value[sub_value_offset]))",
          "2977:        {",
          "2979:         break;",
          "2980:        }",
          "2981:       }",
          "2984:       if (sub_value_offset == linelen)",
          "2985:       {",
          "2987:        THROW(ReportedBoundsError);",
          "2988:        return offset - orig_offset;",
          "2989:       }",
          "2992:       if (cseq_tree)",
          "2993:       {",
          "2994:        proto_tree_add_item(rack_tree, hf_sip_rack_cseq_method, tvb,",
          "2995:                            value_offset + sub_value_offset,",
          "2996:                            (int)value_len-sub_value_offset, ENC_ASCII|ENC_NA);",
          "2997:       }",
          "2999:       break;",
          "3000:      }",
          "3002:      case POS_CALL_ID :",
          "3004:       g_strlcpy(call_id, value, MAX_CALL_ID_SIZE);",
          "3005:       stat_info->tap_call_id = wmem_strdup(wmem_packet_scope(), call_id);",
          "3008:       if(hdr_tree) {",
          "3009:        proto_tree_add_string_format(hdr_tree,",
          "3010:                                     hf_header_array[hf_index], tvb,",
          "3011:                                     offset, next_offset - offset,",
          "3012:                                     value, \"%s\",",
          "3013:                                     tvb_format_text(tvb, offset, linelen));",
          "3014:       }",
          "3015:      break;",
          "3017:      case POS_EXPIRES :",
          "3018:       if (strcmp(value, \"0\") == 0)",
          "3019:       {",
          "3020:        expires_is_0 = 1;",
          "3021:       }",
          "3023:       if(hdr_tree) {",
          "3024:        proto_tree_add_uint(hdr_tree,",
          "3025:                            hf_header_array[hf_index], tvb,",
          "3026:                            offset, next_offset - offset,",
          "3027:                            atoi(value));",
          "3028:       }",
          "3029:      break;",
          "3037:      case POS_CONTENT_TYPE :",
          "3038:       proto_tree_add_string_format(hdr_tree,",
          "3039:                                     hf_header_array[hf_index], tvb,",
          "3040:                                     offset, next_offset - offset,",
          "3041:                                     value, \"%s\",",
          "3042:                                     tvb_format_text(tvb, offset, linelen));",
          "3043:       content_type_len = value_len;",
          "3044:       semi_colon_offset = tvb_find_guint8(tvb, value_offset, value_len, ';');",
          "3051:       if ( semi_colon_offset != -1) {",
          "3052:        gint content_type_end;",
          "3056:        parameter_offset = tvb_skip_wsp(tvb, semi_colon_offset +1, value_offset + value_len - (semi_colon_offset +1));",
          "3057:        content_type_end = tvb_skip_wsp_return(tvb, semi_colon_offset-1);",
          "3058:        content_type_len = content_type_end - value_offset;",
          "3059:        content_type_parameter_str_len = value_offset + value_len - parameter_offset;",
          "3060:        content_type_parameter_str = tvb_get_string(wmem_packet_scope(), tvb, parameter_offset,",
          "3061:                                     content_type_parameter_str_len);",
          "3062:       }",
          "3063:       media_type_str_lower_case = ascii_strdown_inplace(",
          "3064:        (gchar *)tvb_get_string(wmem_packet_scope(), tvb, value_offset, content_type_len));",
          "3067:       proto_tree_add_text(hdr_tree, tvb, value_offset,content_type_len,",
          "3068:                           \"media_type_str(lower cased)=%s\",media_type_str_lower_case);",
          "3070:      break;",
          "3072:      case POS_CONTENT_LENGTH :",
          "3073:       content_length = atoi(value);",
          "3074:       if(hdr_tree) {",
          "3075:        proto_tree_add_uint_format(hdr_tree,",
          "3076:                           hf_header_array[hf_index], tvb,",
          "3077:                           offset, next_offset - offset,",
          "3078:                           content_length, \"%s\",",
          "3079:                           tvb_format_text(tvb, offset, linelen));",
          "3080:       }",
          "3081:       break;",
          "3083:      case POS_MAX_BREADTH :",
          "3084:      case POS_MAX_FORWARDS :",
          "3085:      case POS_RSEQ :",
          "3086:       if(hdr_tree) {",
          "3087:        proto_tree_add_uint(hdr_tree,",
          "3088:                            hf_header_array[hf_index], tvb,",
          "3089:                            offset, next_offset - offset,",
          "3090:                            (guint32)strtoul(value, NULL, 10));",
          "3091:       }",
          "3092:       break;",
          "3094:      case POS_CONTACT :",
          "3100:       sip_element_item = proto_tree_add_string_format(hdr_tree,",
          "3101:                           hf_header_array[hf_index], tvb,",
          "3102:                           offset, next_offset - offset,",
          "3103:                           value, \"%s\",",
          "3104:                           tvb_format_text(tvb, offset, linelen));",
          "3105:       sip_element_tree = proto_item_add_subtree( sip_element_item,",
          "3106:                           ett_sip_element);",
          "3109:       c = tvb_get_guint8(tvb, value_offset);",
          "3110:       if (c =='*'){",
          "3111:        contact_is_star = 1;",
          "3112:        break;",
          "3113:       }",
          "3115:       if(hdr_tree) {",
          "3116:        comma_offset = value_offset;",
          "3117:        while((comma_offset = dissect_sip_contact_item(tvb, pinfo, sip_element_tree, comma_offset,",
          "3118:          next_offset, &contacts_expires_0, &contacts_expires_unknown)) != -1)",
          "3119:        {",
          "3120:         contacts++;",
          "3121:         if(comma_offset == next_offset)",
          "3122:         {",
          "3124:          break;",
          "3125:         }",
          "3127:         if(tvb_get_guint8(tvb, comma_offset) != ',')",
          "3128:         {",
          "3130:          break;",
          "3131:         }",
          "3133:        }",
          "3134:       }",
          "3135:      break;",
          "3137:      case POS_AUTHORIZATION:",
          "3145:      case POS_WWW_AUTHENTICATE:",
          "3153:      case POS_PROXY_AUTHENTICATE:",
          "3156:      case POS_PROXY_AUTHORIZATION:",
          "3159:      case POS_AUTHENTICATION_INFO:",
          "3167:       if (hdr_tree) {",
          "3168:        proto_item *ti_c;",
          "3170:        sip_element_item = proto_tree_add_string_format(hdr_tree,",
          "3171:                           hf_header_array[hf_index], tvb,",
          "3172:                           offset, next_offset - offset,",
          "3173:                           value, \"%s\",",
          "3174:                           tvb_format_text(tvb, offset, linelen));",
          "3175:        sip_element_tree = proto_item_add_subtree( sip_element_item,",
          "3176:                           ett_sip_element);",
          "3179:        ti_c = proto_tree_add_item(hdr_tree, hf_sip_auth, tvb,",
          "3180:                                 offset, next_offset-offset,",
          "3181:                                 ENC_ASCII|ENC_NA);",
          "3182:        PROTO_ITEM_SET_HIDDEN(ti_c);",
          "3185:        if (hf_index != POS_AUTHENTICATION_INFO)",
          "3186:        {",
          "3188:         comma_offset = tvb_pbrk_guint8(tvb, value_offset, line_end_offset - value_offset, \" \\t\\r\\n\", NULL);",
          "3189:         proto_tree_add_item(sip_element_tree, hf_sip_auth_scheme,",
          "3190:              tvb, value_offset, comma_offset - value_offset,",
          "3191:              ENC_ASCII|ENC_NA);",
          "3192:        }else{",
          "3194:         comma_offset = value_offset;",
          "3195:        }",
          "3198:        while ((comma_offset = dissect_sip_authorization_item(tvb, sip_element_tree, comma_offset, line_end_offset)) != -1)",
          "3199:        {",
          "3200:         if(comma_offset == line_end_offset)",
          "3201:         {",
          "3203:          break;",
          "3204:         }",
          "3206:         if(tvb_get_guint8(tvb, comma_offset) != ',')",
          "3207:         {",
          "3209:          break;",
          "3210:         }",
          "3212:        }",
          "3214:      break;",
          "3216:      case POS_ROUTE:",
          "3218:       if (hdr_tree) {",
          "3219:        sip_element_item = proto_tree_add_string_format(hdr_tree,",
          "3220:                                     hf_header_array[hf_index], tvb,",
          "3221:                                     offset, next_offset - offset,",
          "3222:                                     value, \"%s\",",
          "3223:                                     tvb_format_text(tvb, offset, linelen));",
          "3224:        route_tree = proto_item_add_subtree(sip_element_item, ett_sip_route);",
          "3225:        dissect_sip_route_header(tvb, route_tree, pinfo, &sip_route_uri, value_offset, line_end_offset);",
          "3226:       }",
          "3227:       break;",
          "3228:      case POS_RECORD_ROUTE:",
          "3230:       if (hdr_tree) {",
          "3231:        sip_element_item = proto_tree_add_string_format(hdr_tree,",
          "3232:                                     hf_header_array[hf_index], tvb,",
          "3233:                                     offset, next_offset - offset,",
          "3234:                                     value, \"%s\",",
          "3235:                                     tvb_format_text(tvb, offset, linelen));",
          "3236:        route_tree = proto_item_add_subtree(sip_element_item, ett_sip_route);",
          "3237:        dissect_sip_route_header(tvb, route_tree, pinfo, &sip_record_route_uri, value_offset, line_end_offset);",
          "3238:       }",
          "3239:       break;",
          "3240:      case POS_VIA:",
          "3242:       if (hdr_tree) {",
          "3243:        sip_element_item = proto_tree_add_string_format(hdr_tree,",
          "3244:                                     hf_header_array[hf_index], tvb,",
          "3245:                                     offset, next_offset - offset,",
          "3246:                                     value, \"%s\",",
          "3247:                                     tvb_format_text(tvb, offset, linelen));",
          "3248:        via_tree = proto_item_add_subtree(sip_element_item, ett_sip_via);",
          "3249:        dissect_sip_via_header(tvb, via_tree, value_offset, line_end_offset);",
          "3250:       }",
          "3251:       break;",
          "3252:      case POS_REASON:",
          "3253:       if(hdr_tree) {",
          "3254:        sip_element_item = proto_tree_add_string_format(hdr_tree,",
          "3255:                                     hf_header_array[hf_index], tvb,",
          "3256:                                     offset, next_offset - offset,",
          "3257:                                     value, \"%s\",",
          "3258:                                     tvb_format_text(tvb, offset, linelen));",
          "3259:        reason_tree = proto_item_add_subtree(sip_element_item, ett_sip_reason);",
          "3260:        dissect_sip_reason_header(tvb, reason_tree, value_offset, line_end_offset);",
          "3261:       }",
          "3262:       break;",
          "3263:      case POS_CONTENT_ENCODING:",
          "3267:       proto_tree_add_string_format(hdr_tree,",
          "3268:                                     hf_header_array[hf_index], tvb,",
          "3269:                                     offset, next_offset - offset,",
          "3270:                                     value, \"%s\",",
          "3271:                                     tvb_format_text(tvb, offset, linelen));",
          "3273:       content_encoding_parameter_str = ascii_strdown_inplace(tvb_get_string(wmem_packet_scope(), tvb, value_offset,",
          "3274:                                     (line_end_offset-value_offset)));",
          "3275:       break;",
          "3276:                     case POS_SECURITY_CLIENT:",
          "3280:                         sip_element_item = proto_tree_add_string_format(hdr_tree,",
          "3281:                                                          hf_header_array[hf_index], tvb,",
          "3282:                                                          offset, next_offset - offset,",
          "3283:                                                          value, \"%s\",",
          "3284:                                                          tvb_format_text(tvb, offset, linelen));",
          "3285:       comma_offset = tvb_find_guint8(tvb, value_offset, line_end_offset - value_offset, ',');",
          "3286:       while(comma_offset<line_end_offset){",
          "3287:        comma_offset = tvb_find_guint8(tvb, value_offset, line_end_offset - value_offset, ',');",
          "3288:        if(comma_offset == -1){",
          "3289:         comma_offset = line_end_offset;",
          "3290:        }",
          "3291:        security_client_tree = proto_item_add_subtree(sip_element_item, ett_sip_security_client);",
          "3292:        dissect_sip_sec_mechanism(tvb, pinfo, security_client_tree, value_offset, comma_offset);",
          "3293:        comma_offset = value_offset = comma_offset+1;",
          "3294:       }",
          "3296:                         break;",
          "3297:                     case POS_SECURITY_SERVER:",
          "3301:                         sip_element_item = proto_tree_add_string_format(hdr_tree,",
          "3302:                                                          hf_header_array[hf_index], tvb,",
          "3303:                                                          offset, next_offset - offset,",
          "3304:                                                          value, \"%s\",",
          "3305:                                                          tvb_format_text(tvb, offset, linelen));",
          "3306:       comma_offset = tvb_find_guint8(tvb, value_offset, line_end_offset - value_offset, ',');",
          "3307:       while(comma_offset<line_end_offset){",
          "3308:        comma_offset = tvb_find_guint8(tvb, value_offset, line_end_offset - value_offset, ',');",
          "3309:        if(comma_offset == -1){",
          "3310:         comma_offset = line_end_offset;",
          "3311:        }",
          "3312:        security_client_tree = proto_item_add_subtree(sip_element_item, ett_sip_security_server);",
          "3313:        dissect_sip_sec_mechanism(tvb, pinfo, security_client_tree, value_offset, comma_offset);",
          "3314:        comma_offset = value_offset = comma_offset+1;",
          "3315:       }",
          "3327:       comma_offset = tvb_find_guint8(tvb, value_offset, line_end_offset - value_offset, ',');",
          "3328:       while(comma_offset<line_end_offset){",
          "3329:        comma_offset = tvb_find_guint8(tvb, value_offset, line_end_offset - value_offset, ',');",
          "3330:        if(comma_offset == -1){",
          "3331:         comma_offset = line_end_offset;",
          "3332:        }",
          "3333:        security_client_tree = proto_item_add_subtree(sip_element_item, ett_sip_security_verify);",
          "3334:        dissect_sip_sec_mechanism(tvb, pinfo, security_client_tree, value_offset, comma_offset);",
          "3335:        comma_offset = value_offset = comma_offset+1;",
          "3336:       }",
          "3341:       proto_tree_add_string_format(hdr_tree,",
          "3342:                                     hf_header_array[hf_index], tvb,",
          "3343:                                     offset, next_offset - offset,",
          "3344:                                     value, \"%s\",",
          "3345:                                     tvb_format_text(tvb, offset, linelen));",
          "3346:       break;",
          "3350:   if (is_no_header_termination == TRUE){",
          "3352:    proto_tree_add_expert(hdr_tree, pinfo, &ei_sip_header_not_terminated,",
          "3353:          tvb, line_end_offset, -1);",
          "3354:   }",
          "3355:   offset = next_offset;",
          "3358:  datalen = tvb_length_remaining(tvb, offset);",
          "3359:  reported_datalen = tvb_reported_length_remaining(tvb, offset);",
          "3360:  if (content_length != -1) {",
          "3361:   if (datalen > content_length)",
          "3362:    datalen = content_length;",
          "3363:   if (reported_datalen > content_length)",
          "3364:    reported_datalen = content_length;",
          "3365:  }",
          "3372:  if (expires_is_0) {",
          "3374:   contacts_expires_0 += contacts_expires_unknown;",
          "3375:  }",
          "3378:  if (current_method_idx == SIP_METHOD_REGISTER)",
          "3379:  {",
          "3383:   if (contact_is_star && expires_is_0)",
          "3384:   {",
          "3385:    col_append_str(pinfo->cinfo, COL_INFO, \"  (remove all bindings)\");",
          "3386:   }",
          "3387:   else",
          "3388:   if (contacts_expires_0 > 0)",
          "3389:   {",
          "3390:    col_append_fstr(pinfo->cinfo, COL_INFO, \"  (remove %d binding%s)\",",
          "3391:     contacts_expires_0, contacts_expires_0 == 1 ? \"\":\"s\");",
          "3392:    if (contacts > contacts_expires_0) {",
          "3393:     col_append_fstr(pinfo->cinfo, COL_INFO, \" (add %d binding%s)\",",
          "3394:      contacts - contacts_expires_0,",
          "3395:      (contacts - contacts_expires_0 == 1) ? \"\":\"s\");",
          "3396:    }",
          "3397:   }",
          "3398:   else",
          "3399:   if (!contacts)",
          "3400:   {",
          "3401:    col_append_str(pinfo->cinfo, COL_INFO, \"  (fetch bindings)\");",
          "3402:   }",
          "3403:   else",
          "3404:   {",
          "3405:    col_append_fstr(pinfo->cinfo, COL_INFO, \"  (%d binding%s)\",",
          "3406:     contacts, contacts == 1 ? \"\":\"s\");",
          "3407:   }",
          "3408:  }",
          "3411:  if (line_type == STATUS_LINE && (strcmp(cseq_method, \"REGISTER\") == 0) &&",
          "3412:   stat_info && stat_info->response_code > 199 && stat_info->response_code < 300)",
          "3413:  {",
          "3414:   if (contacts_expires_0 > 0) {",
          "3415:    col_append_fstr(pinfo->cinfo, COL_INFO, \"  (removed %d binding%s)\",",
          "3416:     contacts_expires_0, contacts_expires_0 == 1 ? \"\":\"s\");",
          "3417:    if (contacts > contacts_expires_0) {",
          "3418:     col_append_fstr(pinfo->cinfo, COL_INFO, \" (%d binding%s kept)\",",
          "3419:      contacts - contacts_expires_0,",
          "3420:      (contacts - contacts_expires_0 == 1) ? \"\":\"s\");",
          "3421:    }",
          "3422:   } else {",
          "3423:    col_append_fstr(pinfo->cinfo, COL_INFO, \"  (%d binding%s)\",",
          "3424:     contacts, contacts == 1 ? \"\":\"s\");",
          "3425:   }",
          "3426:  }",
          "3435:  col_append_str(pinfo->cinfo, COL_INFO, \" | \");",
          "3436:  col_set_fence(pinfo->cinfo, COL_INFO);",
          "3441:  if ((line_type == REQUEST_LINE)&&(strcmp(cseq_method, \"ACK\") == 0))",
          "3442:  {",
          "3443:   request_for_response = sip_find_invite(pinfo, cseq_method, call_id,",
          "3444:                                           cseq_number_set, cseq_number,",
          "3445:                                           &response_time);",
          "3446:   stat_info->setup_time = response_time;",
          "3447:  }",
          "3450:  resend_for_packet = sip_is_packet_resend(pinfo, cseq_method, call_id,",
          "3451:                                           cseq_number_set, cseq_number,",
          "3452:                                           line_type);",
          "3454:  stat_info->resend = (resend_for_packet > 0);",
          "3457:  if (line_type == STATUS_LINE)",
          "3458:  {",
          "3459:   request_for_response = sip_find_request(pinfo, cseq_method, call_id,",
          "3460:                                           cseq_number_set, cseq_number,",
          "3461:                                           &response_time);",
          "3462:  }",
          "3464:  if (datalen > 0) {",
          "3469:   proto_item_set_end(th, tvb, offset);",
          "3470:   if(content_encoding_parameter_str != NULL &&",
          "3471:    (!strncmp(content_encoding_parameter_str, \"gzip\", 4) ||",
          "3472:     !strncmp(content_encoding_parameter_str,\"deflate\",7))){",
          "3474:    next_tvb = tvb_uncompress(tvb, offset,  datalen);",
          "3475:    if (next_tvb) {",
          "3476:     add_new_data_source(pinfo, next_tvb, \"gunziped data\");",
          "3477:     if(sip_tree) {",
          "3478:      ti_a = proto_tree_add_item(sip_tree, hf_sip_msg_body, next_tvb, 0, -1,",
          "3479:                              ENC_NA);",
          "3480:      message_body_tree = proto_item_add_subtree(ti_a, ett_sip_message_body);",
          "3481:     }",
          "3482:    } else {",
          "3483:     next_tvb = tvb_new_subset(tvb, offset, datalen, reported_datalen);",
          "3484:     if(sip_tree) {",
          "3485:      ti_a = proto_tree_add_item(sip_tree, hf_sip_msg_body, next_tvb, 0, -1,",
          "3486:                              ENC_NA);",
          "3487:      message_body_tree = proto_item_add_subtree(ti_a, ett_sip_message_body);",
          "3488:     }",
          "3489:    }",
          "3490:   }else{",
          "3491:    next_tvb = tvb_new_subset(tvb, offset, datalen, reported_datalen);",
          "3492:    if(sip_tree) {",
          "3493:     ti_a = proto_tree_add_item(sip_tree, hf_sip_msg_body, next_tvb, 0, -1,",
          "3494:                             ENC_NA);",
          "3495:     message_body_tree = proto_item_add_subtree(ti_a, ett_sip_message_body);",
          "3496:    }",
          "3497:   }",
          "3500:   if ( media_type_str_lower_case != NULL ) {",
          "3501:    void *save_private_data = pinfo->private_data;",
          "3502:    pinfo->private_data = content_type_parameter_str;",
          "3505:    if (!strcmp(media_type_str_lower_case, \"application/sdp\")) {",
          "3507:     if (resend_for_packet == 0) {",
          "3508:      if (line_type == REQUEST_LINE) {",
          "3509:       setup_sdp_transport(next_tvb, pinfo, SDP_EXCHANGE_OFFER, pinfo->fd->num);",
          "3510:      } else if (line_type == STATUS_LINE) {",
          "3511:       if (stat_info->response_code >= 400) {",
          "3513:        setup_sdp_transport(next_tvb, pinfo, SDP_EXCHANGE_ANSWER_REJECT, request_for_response);",
          "3514:       }",
          "3515:       else if ((stat_info->response_code >= 200) && (stat_info->response_code <= 299)) {",
          "3517:        setup_sdp_transport(next_tvb, pinfo, SDP_EXCHANGE_ANSWER_ACCEPT, request_for_response);",
          "3518:       }",
          "3519:      }",
          "3520:     } else {",
          "3521:      setup_sdp_transport_resend(pinfo->fd->num, resend_for_packet);",
          "3522:     }",
          "3523:    }",
          "3527:    found_match = dissector_try_string(media_type_dissector_table,",
          "3528:                                       media_type_str_lower_case,",
          "3529:                                       next_tvb, pinfo,",
          "3530:                                       message_body_tree, NULL);",
          "3531:    if (!found_match &&",
          "3532:        !strncmp(media_type_str_lower_case, \"multipart/\", sizeof(\"multipart/\")-1)) {",
          "3534:     found_match = dissector_try_string(media_type_dissector_table,",
          "3535:                                        \"multipart/\",",
          "3536:                                        next_tvb, pinfo,",
          "3537:                                        message_body_tree, NULL);",
          "3538:    }",
          "3539:    pinfo->private_data = save_private_data;",
          "3541:   }",
          "3542:   if ( found_match != TRUE )",
          "3543:   {",
          "3544:    if (!(dissector_try_heuristic(heur_subdissector_list,",
          "3545:             next_tvb, pinfo, message_body_tree, NULL))) {",
          "3546:     int tmp_offset = 0;",
          "3547:     while (tvb_offset_exists(next_tvb, tmp_offset)) {",
          "3548:      tvb_find_line_end(next_tvb, tmp_offset, -1, &next_offset, FALSE);",
          "3549:      linelen = next_offset - tmp_offset;",
          "3550:      if(message_body_tree) {",
          "3551:       proto_tree_add_text(message_body_tree, next_tvb,",
          "3552:             tmp_offset, linelen, \"%s\",",
          "3553:             tvb_format_text(next_tvb, tmp_offset, linelen));",
          "3554:      }",
          "3555:      tmp_offset = next_offset;",
          "3557:    }",
          "3558:   }",
          "3559:   offset += datalen;",
          "3560:  }",
          "3563:  if (reqresp_tree)",
          "3564:  {",
          "3565:   proto_item *item;",
          "3566:   item = proto_tree_add_boolean(reqresp_tree, hf_sip_resend, tvb, orig_offset, 0,",
          "3567:                                 resend_for_packet > 0);",
          "3568:   PROTO_ITEM_SET_GENERATED(item);",
          "3569:   if (resend_for_packet > 0)",
          "3570:   {",
          "3571:    item = proto_tree_add_uint(reqresp_tree, hf_sip_original_frame,",
          "3572:                               tvb, orig_offset, 0, resend_for_packet);",
          "3573:    PROTO_ITEM_SET_GENERATED(item);",
          "3574:   }",
          "3576:   if (request_for_response > 0)",
          "3577:   {",
          "3578:    item = proto_tree_add_uint(reqresp_tree, hf_sip_matching_request_frame,",
          "3579:                               tvb, orig_offset, 0, request_for_response);",
          "3580:    PROTO_ITEM_SET_GENERATED(item);",
          "3581:    item = proto_tree_add_uint(reqresp_tree, hf_sip_response_time,",
          "3582:                               tvb, orig_offset, 0, response_time);",
          "3583:    PROTO_ITEM_SET_GENERATED(item);",
          "3584:    if ((line_type == STATUS_LINE)&&(strcmp(cseq_method, \"BYE\") == 0)){",
          "3585:     item = proto_tree_add_uint(reqresp_tree, hf_sip_release_time,",
          "3586:                               tvb, orig_offset, 0, response_time);",
          "3587:     PROTO_ITEM_SET_GENERATED(item);",
          "3588:    }",
          "3589:   }",
          "3590:  }",
          "3592:  if (ts != NULL)",
          "3593:   proto_item_set_len(ts, offset - orig_offset);",
          "3595:  if (global_sip_raw_text)",
          "3596:   tvb_raw_text_add(tvb, orig_offset, offset - orig_offset, tree);",
          "3599:  if (!pinfo->flags.in_error_pkt)",
          "3600:  {",
          "3601:   tap_queue_packet(sip_tap, pinfo, stat_info);",
          "3602:   if(have_tap_listener(exported_pdu_tap)){",
          "3603:    export_sip_pdu(pinfo,tvb);",
          "3604:   }",
          "3605:  }",
          "3608:  if (stat_info->request_method) {",
          "3609:   proto_item_append_text(ts, \" (%s)\", stat_info->request_method);",
          "3610:  }",
          "3611:  else {",
          "3612:   proto_item_append_text(ts, \" (%u)\", stat_info->response_code);",
          "3613:  }",
          "3614:  return offset - orig_offset;",
          "3621:  char *value;",
          "3622:  guint parameter_len = meth_len;",
          "3623:  uri_offset_info uri_offsets;",
          "3634:  value = tvb_get_string(wmem_packet_scope(), tvb, offset, parameter_len);",
          "3637:  stat_info->request_method = value;",
          "3639:  if (tree) {",
          "3640:   proto_tree_add_string(tree, hf_sip_Method, tvb, offset, parameter_len, value);",
          "3643:   offset=offset + parameter_len+1;",
          "3644:   sip_uri_offset_init(&uri_offsets);",
          "3646:   uri_offsets.uri_end = tvb_find_guint8(tvb, offset, linelen, ' ')-1;",
          "3647:   dissect_sip_uri(tvb, pinfo, offset, offset + linelen, &uri_offsets);",
          "3648:   display_sip_uri(tvb, tree, &uri_offsets, &sip_req_uri);",
          "3649:  }",
          "3656:  gint response_code = 0;",
          "3657:  int diag_len;",
          "3658:  tvbuff_t *next_tvb;",
          "3666:  response_code = atoi((char*)tvb_get_string(wmem_packet_scope(), tvb, offset + SIP2_HDR_LEN + 1, 3));",
          "3669:  if (tree) {",
          "3670:   proto_tree_add_uint(tree, hf_sip_Status_Code, tvb, offset + SIP2_HDR_LEN + 1,",
          "3671:                       3, response_code);",
          "3672:  }",
          "3675:  stat_info->response_code = response_code;",
          "3678:  offset =  SIP2_HDR_LEN + 1 + 3 + 1;",
          "3681:  diag_len = line_end - offset;",
          "3682:  if((diag_len) <= 0)",
          "3683:   return;",
          "3686:  if(sip_diag_handle){",
          "3687:   next_tvb = tvb_new_subset(tvb, offset, diag_len, diag_len);",
          "3688:   call_dissector(sip_diag_handle, next_tvb, pinfo, tree);",
          "3689:  }",
          "",
          "[Added Lines]",
          "1972:     gint  current_offset;",
          "1973:     gint  transport_start_offset;",
          "1974:     gint  address_start_offset;",
          "1975:     gint  semicolon_offset;",
          "1976:     guint transport_slash_count;",
          "1977:     gboolean transport_name_started;",
          "1978:     gboolean colon_seen;",
          "1979:     gboolean ipv6_reference;",
          "1980:     gboolean ipv6_address;",
          "1981:     guchar c;",
          "1982:     gchar *param_name = NULL;",
          "1984:     current_offset = start_offset;",
          "1986:     while (1)",
          "1987:     {",
          "1989:         transport_start_offset = 0;",
          "1990:         semicolon_offset = 0;",
          "1991:         transport_name_started = FALSE;",
          "1992:         transport_slash_count = 0;",
          "1993:         ipv6_reference = FALSE;",
          "1994:         ipv6_address = FALSE;",
          "1995:         colon_seen = FALSE;",
          "1998:         current_offset = tvb_skip_wsp(tvb, current_offset, line_end_offset - current_offset);",
          "2000:         if (current_offset >= line_end_offset)",
          "2001:         {",
          "2003:             return;",
          "2004:         }",
          "2008:         while (current_offset < line_end_offset)",
          "2009:         {",
          "2010:             c = tvb_get_guint8(tvb, current_offset);",
          "2011:             if (c == '/')",
          "2012:             {",
          "2013:                 transport_slash_count++;",
          "2014:             }",
          "2015:             else",
          "2016:             if (!transport_name_started && (transport_slash_count == 2) && isalpha(c))",
          "2017:             {",
          "2018:                 transport_name_started = TRUE;",
          "2019:                 transport_start_offset = current_offset;",
          "2020:             }",
          "2021:             else",
          "2022:             if (transport_name_started && ((c == ' ') || (c == '\\t')))",
          "2023:             {",
          "2024:                 proto_tree_add_item(tree, hf_sip_via_transport, tvb, transport_start_offset,",
          "2025:                                     current_offset - transport_start_offset, ENC_ASCII|ENC_NA);",
          "2027:                 break;",
          "2028:             }",
          "2030:             current_offset++;",
          "2031:         }",
          "2034:         current_offset = tvb_skip_wsp(tvb, current_offset, line_end_offset - current_offset);",
          "2037:         address_start_offset = current_offset;",
          "2038:         while (current_offset < line_end_offset)",
          "2039:         {",
          "2040:             c = tvb_get_guint8(tvb, current_offset);",
          "2042:             if (c == '[') {",
          "2043:                 ipv6_reference = TRUE;",
          "2044:                 ipv6_address = TRUE;",
          "2045:             }",
          "2046:             else if (c == ']')",
          "2047:             {",
          "2048:                 ipv6_reference = FALSE;",
          "2049:             }",
          "2051:             if (colon_seen || (c == ' ') || (c == '\\t') || ((c == ':') && (ipv6_reference == FALSE)) || (c == ';'))",
          "2052:             {",
          "2053:                 break;",
          "2054:             }",
          "2056:             current_offset++;",
          "2057:         }",
          "2059:         if (ipv6_address == TRUE) {",
          "2060:             proto_tree_add_item(tree, hf_sip_via_sent_by_address, tvb, address_start_offset + 1,",
          "2061:                                 current_offset - address_start_offset - 2, ENC_ASCII|ENC_NA);",
          "2062:         } else {",
          "2063:             proto_tree_add_item(tree, hf_sip_via_sent_by_address, tvb, address_start_offset,",
          "2064:                                 current_offset - address_start_offset, ENC_ASCII|ENC_NA);",
          "2065:         }",
          "2068:         current_offset = tvb_skip_wsp(tvb, current_offset, line_end_offset - current_offset);",
          "2069:         c = tvb_get_guint8(tvb, current_offset);",
          "2071:         if (c == ':')",
          "2072:         {",
          "2074:             gint port_offset;",
          "2075:             current_offset++;",
          "2078:             current_offset = tvb_skip_wsp(tvb, current_offset, line_end_offset - current_offset);",
          "2080:             port_offset = current_offset;",
          "2083:             while (current_offset < line_end_offset)",
          "2084:             {",
          "2085:                 c = tvb_get_guint8(tvb, current_offset);",
          "2087:                 if (!isdigit(c))",
          "2088:                 {",
          "2089:                     if (current_offset > port_offset)",
          "2090:                     {",
          "2092:                         proto_tree_add_uint(tree, hf_sip_via_sent_by_port, tvb, port_offset,",
          "2093:                                             current_offset - port_offset,",
          "2094:                                             atoi(tvb_get_string(wmem_packet_scope(), tvb, port_offset,",
          "2095:                                                                           current_offset - port_offset)));",
          "2096:                     }",
          "2097:                     else",
          "2098:                     {",
          "2100:                         return;",
          "2101:                     }",
          "2102:                     break;",
          "2103:                 }",
          "2105:                 current_offset++;",
          "2106:             }",
          "2107:         }",
          "2110:         current_offset = tvb_skip_wsp(tvb, current_offset, line_end_offset - current_offset);",
          "2114:         while (current_offset < line_end_offset)",
          "2115:         {",
          "2116:             gboolean equals_found = FALSE;",
          "2117:             gboolean found_end_of_parameters = FALSE;",
          "2118:             gint parameter_name_end = 0;",
          "2119:             header_parameter_t *via_parameter;",
          "2120:             guint i = 0;",
          "2123:             while (current_offset < line_end_offset)",
          "2124:             {",
          "2125:                 c = tvb_get_guint8(tvb, current_offset);",
          "2126:                 if (c == ';')",
          "2127:                 {",
          "2128:                     semicolon_offset = current_offset;",
          "2129:                     current_offset++;",
          "2130:                     break;",
          "2131:                 }",
          "2132:                 else",
          "2133:                 if ((c != ' ') && (c != '\\t'))",
          "2134:                 {",
          "2135:                     found_end_of_parameters = TRUE;",
          "2136:                     break;",
          "2137:                 }",
          "2138:                 current_offset++;",
          "2139:             }",
          "2141:             if (found_end_of_parameters)",
          "2142:             {",
          "2143:                 break;",
          "2144:             }",
          "2146:             if (current_offset == line_end_offset)",
          "2147:             {",
          "2148:                 return;",
          "2149:             }",
          "2152:             while (current_offset < line_end_offset)",
          "2153:             {",
          "2154:                 c = tvb_get_guint8(tvb, current_offset);",
          "2155:                 if (!isalpha(c) && (c != '-'))",
          "2156:                 {",
          "2157:                     break;",
          "2158:                 }",
          "2159:                 current_offset++;",
          "2160:             }",
          "2163:             if (c == '=')",
          "2164:             {",
          "2165:                 equals_found = TRUE;",
          "2166:             }",
          "2167:             parameter_name_end = current_offset;",
          "2170:             while (current_offset < line_end_offset)",
          "2171:             {",
          "2172:                 c = tvb_get_guint8(tvb, current_offset);",
          "2173:                 if ((c == ' ') || (c == '\\t') || (c == ';') || (c == ','))",
          "2174:                 {",
          "2175:                     break;",
          "2176:                 }",
          "2177:                 current_offset++;",
          "2178:             }",
          "2181:             param_name = tvb_get_string(wmem_packet_scope(), tvb, semicolon_offset+1,",
          "2182:                                                   parameter_name_end - semicolon_offset - 1);",
          "2185:             for (via_parameter = &via_parameters_hf_array[i];",
          "2186:                  i < array_length(via_parameters_hf_array);",
          "2187:                  i++, via_parameter++)",
          "2188:             {",
          "2189:                 if (g_ascii_strcasecmp(param_name, via_parameter->param_name) == 0)",
          "2190:                 {",
          "2191:                     if (equals_found)",
          "2192:                     {",
          "2193:                         proto_tree_add_item(tree, *(via_parameter->hf_item), tvb,",
          "2194:                                             parameter_name_end+1, current_offset-parameter_name_end-1,",
          "2195:                                             ENC_ASCII|ENC_NA);",
          "2196:                     }",
          "2197:                     else",
          "2198:                     {",
          "2199:                         proto_tree_add_item(tree, *(via_parameter->hf_item), tvb,",
          "2200:                                             semicolon_offset+1, current_offset-semicolon_offset-1,",
          "2201:                                             ENC_ASCII|ENC_NA);",
          "2202:                     }",
          "2203:                     break;",
          "2204:                 }",
          "2205:             }",
          "2208:             if (i == array_length(via_parameters_hf_array))",
          "2209:             {",
          "2210:                 proto_tree_add_text(tree, tvb, semicolon_offset+1, current_offset-semicolon_offset-1,",
          "2211:                                     \"%s\", tvb_format_text(tvb, semicolon_offset+1,",
          "2212:                                     current_offset-semicolon_offset-1));",
          "2213:             }",
          "2216:             current_offset = tvb_skip_wsp(tvb, current_offset, line_end_offset - current_offset);",
          "2219:             if (current_offset < line_end_offset)",
          "2220:             {",
          "2221:                 c = tvb_get_guint8(tvb, current_offset);",
          "2222:                 if (c == ',')",
          "2223:                 {",
          "2225:                     current_offset++;",
          "2226:                     break;",
          "2227:                 }",
          "2228:             }",
          "2229:         }",
          "2230:     }",
          "2237:     guint8 octet;",
          "2238:     int len;",
          "2240:     octet = tvb_get_guint8(tvb,0);",
          "2241:     if ((octet  & 0xf8) == 0xf8){",
          "2242:         call_dissector(sigcomp_handle, tvb, pinfo, tree);",
          "2243:         return tvb_length(tvb);",
          "2244:     }",
          "2246:     len = dissect_sip_common(tvb, 0, pinfo, tree, FALSE, FALSE);",
          "2247:     if (len < 0)",
          "2249:     else",
          "2250:         return len;",
          "2256:     guint8 octet;",
          "2257:     int offset = 0;",
          "2258:     int len;",
          "2260:     octet = tvb_get_guint8(tvb,0);",
          "2261:     if ((octet  & 0xf8) == 0xf8){",
          "2262:         call_dissector(sigcomp_handle, tvb, pinfo, tree);",
          "2263:         return;",
          "2264:     }",
          "2266:     while (tvb_reported_length_remaining(tvb, offset) > 0) {",
          "2267:         len = dissect_sip_common(tvb, offset, pinfo, tree, TRUE, TRUE);",
          "2268:         if (len <= 0)",
          "2269:             break;",
          "2270:         offset += len;",
          "2271:     }",
          "2277:     int offset = 0;",
          "2278:     int len;",
          "2279:     gboolean first = TRUE;",
          "2281:     while (tvb_reported_length_remaining(tvb, offset) > 0) {",
          "2282:         len = dissect_sip_common(tvb, offset, pinfo, tree, !first, TRUE);",
          "2283:         if (len == -2) {",
          "2284:             if (first) {",
          "2290:                 return FALSE;",
          "2291:             }",
          "2292:             break;",
          "2293:         }",
          "2294:         if (len == -1)",
          "2296:         offset += len;",
          "2297:         first = FALSE;",
          "2298:     }",
          "2299:     return TRUE;",
          "2305:     return dissect_sip_common(tvb, 0, pinfo, tree, FALSE, FALSE) > 0;",
          "2312:     int orig_offset;",
          "2313:     gint next_offset, linelen;",
          "2314:     int content_length, datalen, reported_datalen;",
          "2315:     line_type_t line_type;",
          "2316:     tvbuff_t *next_tvb;",
          "2317:     gboolean is_known_request;",
          "2318:     gboolean found_match = FALSE;",
          "2319:     const char *descr;",
          "2320:     guint token_1_len = 0;",
          "2321:     guint current_method_idx = SIP_METHOD_INVALID;",
          "2322:     proto_item *ts = NULL, *ti_a = NULL, *th = NULL, *sip_element_item = NULL;",
          "2323:     proto_tree *sip_tree  = NULL, *reqresp_tree      = NULL, *hdr_tree  = NULL,",
          "2327:     guchar contacts = 0, contact_is_star = 0, expires_is_0 = 0, contacts_expires_0 = 0, contacts_expires_unknown = 0;",
          "2328:     guint32 cseq_number = 0;",
          "2329:     guchar  cseq_number_set = 0;",
          "2330:     char    cseq_method[MAX_CSEQ_METHOD_SIZE] = \"\";",
          "2331:     char    call_id[MAX_CALL_ID_SIZE] = \"\";",
          "2332:     gchar  *media_type_str_lower_case = NULL;",
          "2333:     char   *content_type_parameter_str = NULL;",
          "2334:     char   *content_encoding_parameter_str = NULL;",
          "2335:     guint   resend_for_packet = 0;",
          "2336:     guint   request_for_response = 0;",
          "2337:     guint32 response_time = 0;",
          "2338:     int     strlen_to_copy;",
          "2346:     if (!dissect_other_as_continuation &&",
          "2347:         ((tvb_reported_length_remaining(tvb, offset) < 1) || !isprint(tvb_get_guint8(tvb, offset))))",
          "2348:     {",
          "2349:         return -2;",
          "2350:     }",
          "2360:     orig_offset = offset;",
          "2361:     linelen = tvb_find_line_end(tvb, offset, -1, &next_offset, FALSE);",
          "2362:     if(linelen==0){",
          "2363:         return -2;",
          "2364:     }",
          "2366:     if (tvb_strnlen(tvb, offset, linelen) > -1)",
          "2367:     {",
          "2373:         return -2;",
          "2374:     }",
          "2375:     line_type = sip_parse_line(tvb, offset, linelen, &token_1_len);",
          "2377:     if (line_type == OTHER_LINE) {",
          "2381:         if (!dissect_other_as_continuation) {",
          "2385:             return -2;",
          "2386:         }",
          "2391:     } else if ((use_reassembly)&&( pinfo->ptype == PT_TCP)) {",
          "2398:         if (!req_resp_hdrs_do_reassembly(tvb, offset, pinfo,",
          "2399:             sip_desegment_headers, sip_desegment_body)) {",
          "2403:             return -1;",
          "2404:         }",
          "2405:     }",
          "2410:     stat_info = wmem_new0(wmem_packet_scope(), sip_info_value_t);",
          "2412:     col_set_str(pinfo->cinfo, COL_PROTOCOL, \"SIP\");",
          "2414:     switch (line_type) {",
          "2416:     case REQUEST_LINE:",
          "2417:         is_known_request = sip_is_known_request(tvb, offset, token_1_len, &current_method_idx);",
          "2418:         descr = is_known_request ? \"Request\" : \"Unknown request\";",
          "2419:         col_add_fstr(pinfo->cinfo, COL_INFO, \"%s: %s\",",
          "2420:                      descr,",
          "2421:                      tvb_format_text(tvb, offset, linelen - SIP2_HDR_LEN - 1));",
          "2422:         break;",
          "2424:     case STATUS_LINE:",
          "2425:         descr = \"Status\";",
          "2426:         col_add_fstr(pinfo->cinfo, COL_INFO, \"Status: %s\",",
          "2427:                      tvb_format_text(tvb, offset + SIP2_HDR_LEN + 1, linelen - SIP2_HDR_LEN - 1));",
          "2428:         stat_info->reason_phrase = tvb_get_string(wmem_packet_scope(), tvb, offset + SIP2_HDR_LEN + 5, linelen - (SIP2_HDR_LEN + 5));",
          "2429:         break;",
          "2431:     case OTHER_LINE:",
          "2433:         descr = \"Continuation\";",
          "2434:         col_set_str(pinfo->cinfo, COL_INFO, \"Continuation\");",
          "2435:         break;",
          "2436:     }",
          "2438:     if (tree) {",
          "2439:         ts = proto_tree_add_item(tree, proto_sip, tvb, offset, -1, ENC_NA);",
          "2440:         sip_tree = proto_item_add_subtree(ts, ett_sip);",
          "2441:     }",
          "2443:     switch (line_type) {",
          "2445:     case REQUEST_LINE:",
          "2446:         if (sip_tree) {",
          "2447:             ti_a = proto_tree_add_item(sip_tree, hf_Request_Line, tvb,",
          "2448:                         offset, linelen, ENC_ASCII|ENC_NA);",
          "2450:             reqresp_tree = proto_item_add_subtree(ti_a, ett_sip_reqresp);",
          "2451:         }",
          "2452:         dfilter_sip_request_line(tvb, reqresp_tree, pinfo, offset, token_1_len, linelen);",
          "2453:         break;",
          "2455:     case STATUS_LINE:",
          "2456:         if (sip_tree) {",
          "2457:             ti_a = proto_tree_add_item(sip_tree, hf_sip_Status_Line, tvb,",
          "2458:                         offset, linelen, ENC_ASCII|ENC_NA);",
          "2459:             reqresp_tree = proto_item_add_subtree(ti_a, ett_sip_reqresp);",
          "2460:         }",
          "2461:         dfilter_sip_status_line(tvb, reqresp_tree, pinfo, linelen, offset);",
          "2462:         break;",
          "2464:     case OTHER_LINE:",
          "2465:         if (sip_tree) {",
          "2466:             ti_a = proto_tree_add_text(sip_tree, tvb, offset, next_offset,",
          "2467:                                      \"%s line: %s\", descr,",
          "2468:                                      tvb_format_text(tvb, offset, linelen));",
          "2469:             reqresp_tree = proto_item_add_subtree(ti_a, ett_sip_reqresp);",
          "2471:             proto_tree_add_text(reqresp_tree, tvb, offset, -1, \"Continuation data\");",
          "2472:         }",
          "2473:         return tvb_length_remaining(tvb, offset);",
          "2474:     }",
          "2476:     offset = next_offset;",
          "2477:     if (sip_tree) {",
          "2478:         th = proto_tree_add_item(sip_tree, hf_sip_msg_hdr, tvb, offset,",
          "2479:                                  tvb_length_remaining(tvb, offset), ENC_ASCII|ENC_NA);",
          "2480:         proto_item_set_text(th, \"Message Header\");",
          "2481:         hdr_tree = proto_item_add_subtree(th, ett_sip_hdr);",
          "2482:     }",
          "2489:     next_offset = offset;",
          "2490:     content_length = -1;",
          "2491:     while (tvb_reported_length_remaining(tvb, offset) > 0) {",
          "2492:         gint line_end_offset;",
          "2493:         gint colon_offset;",
          "2494:         gint semi_colon_offset;",
          "2495:         gint parameter_offset;",
          "2496:         gint parameter_end_offset;",
          "2497:         gint parameter_len;",
          "2498:         gint content_type_len, content_type_parameter_str_len;",
          "2499:         gint header_len;",
          "2500:         gchar *header_name;",
          "2501:         dissector_handle_t ext_hdr_handle;",
          "2502:         gint hf_index;",
          "2503:         gint value_offset;",
          "2504:         gint sub_value_offset;",
          "2505:         gint comma_offset;",
          "2506:         guchar c;",
          "2507:         gint value_len;",
          "2508:         char *value;",
          "2509:         gboolean is_no_header_termination = FALSE;",
          "2510:         proto_tree *tc_uri_item_tree = NULL;",
          "2511:         uri_offset_info uri_offsets;",
          "2517:         linelen = tvb_find_line_end(tvb, offset, -1, &next_offset, FALSE);",
          "2518:         if (linelen == 0) {",
          "2523:             offset = next_offset;",
          "2524:             break;",
          "2525:         }",
          "2527:         line_end_offset = offset + linelen;",
          "2528:         if(tvb_reported_length_remaining(tvb, next_offset) <= 0){",
          "2529:             is_no_header_termination = TRUE;",
          "2530:         }else{",
          "2531:             while ((c = tvb_get_guint8(tvb, next_offset)) == ' ' || c == '\\t')",
          "2532:             {",
          "2538:                 linelen += (next_offset - line_end_offset);",
          "2539:                 linelen += tvb_find_line_end(tvb, next_offset, -1, &next_offset, FALSE);",
          "2540:                 line_end_offset = offset + linelen;",
          "2541:             }",
          "2542:         }",
          "2543:         colon_offset = tvb_find_guint8(tvb, offset, linelen, ':');",
          "2544:         if (colon_offset == -1) {",
          "2548:             if(hdr_tree) {",
          "2549:                 proto_tree_add_text(hdr_tree, tvb, offset,",
          "2550:                                     next_offset - offset, \"%s\",",
          "2551:                                     tvb_format_text(tvb, offset, linelen));",
          "2552:             }",
          "2553:         } else {",
          "2554:             header_len = colon_offset - offset;",
          "2555:             header_name = (gchar*)tvb_get_string(wmem_packet_scope(), tvb, offset, header_len);",
          "2556:             ascii_strdown_inplace(header_name);",
          "2557:             hf_index = sip_is_known_sip_header(header_name, header_len);",
          "2562:             value_offset = tvb_skip_wsp(tvb, colon_offset + 1, line_end_offset - (colon_offset + 1));",
          "2567:             value_len = (gint) (line_end_offset - value_offset);",
          "2568:             value = tvb_get_string(wmem_packet_scope(), tvb, value_offset, value_len);",
          "2570:             if (hf_index == -1) {",
          "2571:                 proto_item *ti_c = proto_tree_add_text(hdr_tree, tvb,",
          "2572:                                                      offset, next_offset - offset, \"%s\",",
          "2573:                                                      tvb_format_text(tvb, offset, linelen));",
          "2574:                 ext_hdr_handle = dissector_get_string_handle(ext_hdr_subdissector_table, header_name);",
          "2575:                 if (ext_hdr_handle != NULL) {",
          "2576:                     tvbuff_t *next_tvb2;",
          "2577:                     next_tvb2 = tvb_new_subset(tvb, value_offset, value_len, value_len);",
          "2578:                     dissector_try_string(ext_hdr_subdissector_table, header_name, next_tvb2, pinfo, proto_item_add_subtree(ti_c, ett_sip_ext_hdr), NULL);",
          "2579:                 } else {",
          "2580:                     expert_add_info_format(pinfo, ti_c, &ei_sip_unrecognized_header,",
          "2581:                                            \"Unrecognised SIP header (%s)\",",
          "2582:                                            tvb_format_text(tvb, offset, header_len));",
          "2583:                 }",
          "2584:             } else {",
          "2589:                 switch ( hf_index ) {",
          "2591:                     case POS_TO :",
          "2593:                         if(hdr_tree) {",
          "2594:                             proto_item *item;",
          "2596:                             sip_element_item = proto_tree_add_string_format(hdr_tree,",
          "2597:                                                hf_header_array[hf_index], tvb,",
          "2598:                                                offset, next_offset - offset,",
          "2599:                                                value, \"%s\",",
          "2600:                                                tvb_format_text(tvb, offset, linelen));",
          "2601:                             sip_element_tree = proto_item_add_subtree( sip_element_item,",
          "2602:                                                ett_sip_element);",
          "2606:                             sip_uri_offset_init(&uri_offsets);",
          "2607:                             if((dissect_sip_name_addr_or_addr_spec(tvb, pinfo, value_offset, line_end_offset+2, &uri_offsets)) != -1){",
          "2608:                                 display_sip_uri(tvb, sip_element_tree, &uri_offsets, &sip_to_uri);",
          "2609:                                 if((uri_offsets.name_addr_start != -1) && (uri_offsets.name_addr_end != -1)){",
          "2610:                                     stat_info->tap_to_addr=tvb_get_string(wmem_packet_scope(), tvb, uri_offsets.name_addr_start,",
          "2611:                                         uri_offsets.name_addr_end - uri_offsets.name_addr_start);",
          "2612:                                 }",
          "2613:                                 offset = uri_offsets.name_addr_end +1;",
          "2614:                             }",
          "2621:                             parameter_offset = offset;",
          "2622:                             while (parameter_offset < line_end_offset",
          "2623:                                    && (tvb_strneql(tvb, parameter_offset, \"tag=\", 4) != 0))",
          "2624:                                 parameter_offset++;",
          "2627:                                 parameter_offset = parameter_offset + 4;",
          "2628:                                 parameter_end_offset = tvb_find_guint8(tvb, parameter_offset,",
          "2629:                                                                        (line_end_offset - parameter_offset), ';');",
          "2630:                                 if ( parameter_end_offset == -1)",
          "2631:                                     parameter_end_offset = line_end_offset;",
          "2632:                                 parameter_len = parameter_end_offset - parameter_offset;",
          "2633:                                 proto_tree_add_item(sip_element_tree, hf_sip_to_tag, tvb, parameter_offset,",
          "2634:                                                     parameter_len, ENC_ASCII|ENC_NA);",
          "2635:                                 item = proto_tree_add_item(sip_element_tree, hf_sip_tag, tvb, parameter_offset,",
          "2636:                                                            parameter_len, ENC_ASCII|ENC_NA);",
          "2637:                                 PROTO_ITEM_SET_HIDDEN(item);",
          "2640:                                 switch (current_method_idx) {",
          "2642:                                 case SIP_METHOD_INVITE:",
          "2643:                                 case SIP_METHOD_SUBSCRIBE:",
          "2644:                                 case SIP_METHOD_REFER:",
          "2645:                                     col_append_str(pinfo->cinfo, COL_INFO, \", in-dialog\");",
          "2646:                                     break;",
          "2647:                                 }",
          "2648:                             }",
          "2650:                     break;",
          "2652:                     case POS_FROM :",
          "2653:                         if(hdr_tree) {",
          "2654:                             proto_item *item;",
          "2656:                             sip_element_item = proto_tree_add_string_format(hdr_tree,",
          "2657:                                                hf_header_array[hf_index], tvb,",
          "2658:                                                offset, next_offset - offset,",
          "2659:                                                value, \"%s\",",
          "2660:                                                tvb_format_text(tvb, offset, linelen));",
          "2661:                             sip_element_tree = proto_item_add_subtree( sip_element_item, ett_sip_element);",
          "2668:                             sip_uri_offset_init(&uri_offsets);",
          "2669:                             if((dissect_sip_name_addr_or_addr_spec(tvb, pinfo, value_offset, line_end_offset+2, &uri_offsets)) != -1){",
          "2670:                                 display_sip_uri(tvb, sip_element_tree, &uri_offsets, &sip_from_uri);",
          "2671:                                 if((uri_offsets.name_addr_start != -1) && (uri_offsets.name_addr_end != -1)){",
          "2672:                                     stat_info->tap_from_addr=tvb_get_string(wmem_packet_scope(), tvb, uri_offsets.name_addr_start,",
          "2673:                                         uri_offsets.name_addr_end - uri_offsets.name_addr_start);",
          "2674:                                 }",
          "2675:                                 offset = uri_offsets.name_addr_end +1;",
          "2676:                             }",
          "2683:                             parameter_offset = offset;",
          "2684:                             while (parameter_offset < line_end_offset",
          "2685:                                    && (tvb_strneql(tvb, parameter_offset, \"tag=\", 4) != 0))",
          "2686:                                 parameter_offset++;",
          "2688:                                 parameter_offset = parameter_offset + 4;",
          "2689:                                 parameter_end_offset = tvb_find_guint8(tvb, parameter_offset,",
          "2690:                                                                        (line_end_offset - parameter_offset), ';');",
          "2691:                                 if ( parameter_end_offset == -1)",
          "2692:                                     parameter_end_offset = line_end_offset;",
          "2693:                                 parameter_len = parameter_end_offset - parameter_offset;",
          "2694:                                 proto_tree_add_item(sip_element_tree, hf_sip_from_tag, tvb, parameter_offset,",
          "2695:                                                     parameter_len, ENC_ASCII|ENC_NA);",
          "2696:                                 item = proto_tree_add_item(sip_element_tree, hf_sip_tag, tvb, parameter_offset,",
          "2697:                                                            parameter_len, ENC_ASCII|ENC_NA);",
          "2698:                                 PROTO_ITEM_SET_HIDDEN(item);",
          "2699:                             }",
          "2701:                     break;",
          "2703:                     case POS_P_ASSERTED_IDENTITY :",
          "2704:                         if(hdr_tree)",
          "2705:                         {",
          "2706:                             sip_element_item = proto_tree_add_string_format(hdr_tree,",
          "2707:                                                hf_header_array[hf_index], tvb,",
          "2708:                                                offset, next_offset - offset,",
          "2709:                                                value, \"%s\",",
          "2710:                                                tvb_format_text(tvb, offset, linelen));",
          "2711:                             sip_element_tree = proto_item_add_subtree( sip_element_item,",
          "2712:                                                ett_sip_element);",
          "2721:                             sip_uri_offset_init(&uri_offsets);",
          "2722:                             if((dissect_sip_name_addr_or_addr_spec(tvb, pinfo, value_offset, line_end_offset+2, &uri_offsets)) != -1)",
          "2723:                                  display_sip_uri(tvb, sip_element_tree, &uri_offsets, &sip_pai_uri);",
          "2724:                         }",
          "2725:                         break;",
          "2726:                     case POS_HISTORY_INFO:",
          "2727:                         if(hdr_tree)",
          "2728:                         {",
          "2729:                             sip_element_item = proto_tree_add_string_format(hdr_tree,",
          "2730:                                                hf_header_array[hf_index], tvb,",
          "2731:                                                offset, next_offset - offset,",
          "2732:                                                value, \"%s\",",
          "2733:                                                tvb_format_text(tvb, offset, linelen));",
          "2734:                             sip_element_tree = proto_item_add_subtree( sip_element_item,",
          "2735:                                                ett_sip_hist);",
          "2736:                             dissect_sip_history_info(tvb, sip_element_tree, pinfo, value_offset, line_end_offset);",
          "2737:                         }",
          "2738:                         break;",
          "2740:                     case POS_P_CHARGING_FUNC_ADDRESSES:",
          "2741:                         if(hdr_tree)",
          "2742:                         {",
          "2743:                             sip_element_item = proto_tree_add_string_format(hdr_tree,",
          "2744:                                                hf_header_array[hf_index], tvb,",
          "2745:                                                offset, next_offset - offset,",
          "2746:                                                value, \"%s\",",
          "2747:                                                tvb_format_text(tvb, offset, linelen));",
          "2748:                             sip_element_tree = proto_item_add_subtree( sip_element_item,",
          "2749:                                                ett_sip_element);",
          "2750:                             dissect_sip_p_charging_func_addresses(tvb, sip_element_tree, pinfo, value_offset, line_end_offset);",
          "2751:                         }",
          "2752:                         break;",
          "2754:                     case POS_P_PREFERRED_IDENTITY :",
          "2755:                         if(hdr_tree)",
          "2756:                         {",
          "2757:                             sip_element_item = proto_tree_add_string_format(hdr_tree,",
          "2758:                                                hf_header_array[hf_index], tvb,",
          "2759:                                                offset, next_offset - offset,",
          "2760:                                                value, \"%s\",",
          "2761:                                                tvb_format_text(tvb, offset, linelen));",
          "2762:                             sip_element_tree = proto_item_add_subtree( sip_element_item,",
          "2763:                                                ett_sip_element);",
          "2771:                             sip_uri_offset_init(&uri_offsets);",
          "2772:                             if((dissect_sip_name_addr_or_addr_spec(tvb, pinfo, value_offset, line_end_offset+2, &uri_offsets)) != -1)",
          "2773:                                  display_sip_uri(tvb, sip_element_tree, &uri_offsets, &sip_ppi_uri);",
          "2774:                         }",
          "2775:                         break;",
          "2777:                     case POS_PERMISSION_MISSING :",
          "2778:                         if(hdr_tree)",
          "2779:                         {",
          "2780:                             sip_element_item = proto_tree_add_string_format(hdr_tree,",
          "2781:                                                hf_header_array[hf_index], tvb,",
          "2782:                                                offset, next_offset - offset,",
          "2783:                                                value, \"%s\",",
          "2784:                                                tvb_format_text(tvb, offset, linelen));",
          "2786:                             sip_element_tree = proto_item_add_subtree( sip_element_item,",
          "2787:                                                                    ett_sip_element);",
          "2795:                             sip_uri_offset_init(&uri_offsets);",
          "2796:                             if((dissect_sip_name_addr_or_addr_spec(tvb, pinfo, value_offset, line_end_offset+2, &uri_offsets)) != -1)",
          "2797:                                  display_sip_uri(tvb, sip_element_tree, &uri_offsets, &sip_pmiss_uri);",
          "2798:                         }",
          "2799:                         break;",
          "2802:                     case POS_TRIGGER_CONSENT :",
          "2803:                         if(hdr_tree)",
          "2804:                         {",
          "2805:                             sip_element_item = proto_tree_add_string_format(hdr_tree,",
          "2806:                                                hf_header_array[hf_index], tvb,",
          "2807:                                                offset, next_offset - offset,",
          "2808:                                                value, \"%s\",",
          "2809:                                                tvb_format_text(tvb, offset, linelen));",
          "2811:                             sip_element_tree = proto_item_add_subtree( sip_element_item,",
          "2812:                                                                         ett_sip_element);",
          "2823:                             sip_uri_offset_init(&uri_offsets);",
          "2824:                             if((dissect_sip_uri(tvb, pinfo, value_offset, line_end_offset+2, &uri_offsets)) != -1) {",
          "2826:                                 tc_uri_item_tree = display_sip_uri(tvb, sip_element_tree, &uri_offsets, &sip_tc_uri);",
          "2827:                                 if (line_end_offset > uri_offsets.uri_end) {",
          "2828:                                     gint hparam_offset = uri_offsets.uri_end + 1;",
          "2830:                                     if (tvb_find_guint8(tvb, hparam_offset, 1,';')) {",
          "2831:                                         while ((hparam_offset != -1 && hparam_offset < line_end_offset) )  {",
          "2833:                                             hparam_offset = hparam_offset + 1;",
          "2834:                                             if (tvb_strncaseeql(tvb, hparam_offset, \"target-uri=\\\"\", 12) == 0) {",
          "2835:                                                 gint turi_start_offset = hparam_offset + 12;",
          "2836:                                                 gint turi_end_offset   = tvb_find_guint8(tvb, turi_start_offset, -1,'\\\"');",
          "2837:                                                 if (turi_end_offset != -1)",
          "2838:                                                     proto_tree_add_item(tc_uri_item_tree, hf_sip_tc_turi, tvb, turi_start_offset,(turi_end_offset - turi_start_offset),ENC_ASCII|ENC_NA);",
          "2839:                                                 else",
          "2841:                                             }",
          "2842:                                             hparam_offset = tvb_find_guint8(tvb, hparam_offset, -1,';');",
          "2843:                                         }",
          "2844:                                     }",
          "2845:                                 }",
          "2846:                             }",
          "2848:                         break;",
          "2850:                     case POS_CSEQ :",
          "2852:                         cseq_number = (guint32)strtoul(value, NULL, 10);",
          "2853:                         cseq_number_set = 1;",
          "2854:                         stat_info->tap_cseq_number=cseq_number;",
          "2857:                         if (hdr_tree) {",
          "2858:                             sip_element_item = proto_tree_add_string_format(hdr_tree,",
          "2859:                                                          hf_header_array[hf_index], tvb,",
          "2860:                                                          offset, next_offset - offset,",
          "2861:                                                          value, \"%s\",",
          "2862:                                                          tvb_format_text(tvb, offset, linelen));",
          "2863:                             cseq_tree = proto_item_add_subtree(sip_element_item, ett_sip_cseq);",
          "2864:                         }",
          "2868:                         for (sub_value_offset=0; sub_value_offset < value_len; sub_value_offset++)",
          "2869:                         {",
          "2870:                             if (!isdigit((guchar)value[sub_value_offset]))",
          "2871:                             {",
          "2872:                                 proto_tree_add_uint(cseq_tree, hf_sip_cseq_seq_no,",
          "2873:                                                     tvb, value_offset, sub_value_offset,",
          "2874:                                                     cseq_number);",
          "2875:                                 break;",
          "2876:                             }",
          "2877:                         }",
          "2879:                         for (; sub_value_offset < value_len; sub_value_offset++)",
          "2880:                         {",
          "2881:                             if (isalpha((guchar)value[sub_value_offset]))",
          "2882:                             {",
          "2884:                                 break;",
          "2885:                             }",
          "2886:                         }",
          "2888:                         if (sub_value_offset == value_len)",
          "2889:                         {",
          "2891:                             THROW(ReportedBoundsError);",
          "2892:                             return offset - orig_offset;",
          "2893:                         }",
          "2896:                         strlen_to_copy = (int)value_len-sub_value_offset;",
          "2897:                         if (strlen_to_copy > MAX_CSEQ_METHOD_SIZE) {",
          "2899:                             if (hdr_tree) {",
          "2900:                                 proto_tree_add_string_format(hdr_tree,",
          "2901:                                                              hf_header_array[hf_index], tvb,",
          "2902:                                                              offset, next_offset - offset,",
          "2903:                                                              value+sub_value_offset, \"%s String too big: %d bytes\",",
          "2904:                                                              sip_headers[POS_CSEQ].name,",
          "2905:                                                              strlen_to_copy);",
          "2906:                             }",
          "2907:                             THROW(ReportedBoundsError);",
          "2908:                             return offset - orig_offset;",
          "2909:                         }",
          "2910:                         else {",
          "2911:                             g_strlcpy(cseq_method, value+sub_value_offset, MAX_CSEQ_METHOD_SIZE);",
          "2914:                             if (cseq_tree)",
          "2915:                             {",
          "2916:                                 proto_tree_add_item(cseq_tree, hf_sip_cseq_method, tvb,",
          "2917:                                                     value_offset + sub_value_offset, strlen_to_copy, ENC_ASCII|ENC_NA);",
          "2918:                             }",
          "2919:                         }",
          "2920:                     break;",
          "2922:                     case POS_RACK :",
          "2923:                     {",
          "2924:                         int cseq_no_offset;",
          "2928:                         if (hdr_tree) {",
          "2929:                             sip_element_item = proto_tree_add_string_format(hdr_tree,",
          "2930:                                                          hf_header_array[hf_index], tvb,",
          "2931:                                                          offset, next_offset - offset,",
          "2932:                                                          value, \"%s\",",
          "2933:                                                          tvb_format_text(tvb, offset, linelen));",
          "2934:                             rack_tree = proto_item_add_subtree(sip_element_item, ett_sip_rack);",
          "2935:                         }",
          "2938:                         for (sub_value_offset=0; sub_value_offset < value_len; sub_value_offset++)",
          "2939:                         {",
          "2940:                             if (!isdigit((guchar)value[sub_value_offset]))",
          "2941:                             {",
          "2942:                                 proto_tree_add_uint(rack_tree, hf_sip_rack_rseq_no,",
          "2943:                                                     tvb, value_offset, sub_value_offset,",
          "2944:                                                     (guint32)strtoul(value, NULL, 10));",
          "2945:                                 break;",
          "2946:                             }",
          "2947:                         }",
          "2950:                         for ( ; sub_value_offset < value_len; sub_value_offset++)",
          "2951:                         {",
          "2952:                             if (value[sub_value_offset] != ' ' &&",
          "2953:                                 value[sub_value_offset] != '\\t')",
          "2954:                             {",
          "2955:                                 break;",
          "2956:                             }",
          "2957:                         }",
          "2958:                         cseq_no_offset = sub_value_offset;",
          "2961:                         for ( ; sub_value_offset < value_len; sub_value_offset++)",
          "2962:                         {",
          "2963:                             if (!isdigit((guchar)value[sub_value_offset]))",
          "2964:                             {",
          "2965:                                 proto_tree_add_uint(rack_tree, hf_sip_rack_cseq_no,",
          "2966:                                                     tvb, value_offset+cseq_no_offset,",
          "2967:                                                     sub_value_offset-cseq_no_offset,",
          "2968:                                                     (guint32)strtoul(value+cseq_no_offset, NULL, 10));",
          "2969:                                 break;",
          "2970:                             }",
          "2971:                         }",
          "2974:                         for ( ; sub_value_offset < value_len; sub_value_offset++)",
          "2975:                         {",
          "2976:                             if (isalpha((guchar)value[sub_value_offset]))",
          "2977:                             {",
          "2979:                                 break;",
          "2980:                             }",
          "2981:                         }",
          "2984:                         if (sub_value_offset == linelen)",
          "2985:                         {",
          "2987:                             THROW(ReportedBoundsError);",
          "2988:                             return offset - orig_offset;",
          "2989:                         }",
          "2992:                         if (cseq_tree)",
          "2993:                         {",
          "2994:                             proto_tree_add_item(rack_tree, hf_sip_rack_cseq_method, tvb,",
          "2995:                                                 value_offset + sub_value_offset,",
          "2996:                                                 (int)value_len-sub_value_offset, ENC_ASCII|ENC_NA);",
          "2997:                         }",
          "2999:                         break;",
          "3000:                     }",
          "3002:                     case POS_CALL_ID :",
          "3004:                         g_strlcpy(call_id, value, MAX_CALL_ID_SIZE);",
          "3005:                         stat_info->tap_call_id = wmem_strdup(wmem_packet_scope(), call_id);",
          "3008:                         if(hdr_tree) {",
          "3009:                             proto_tree_add_string_format(hdr_tree,",
          "3010:                                                          hf_header_array[hf_index], tvb,",
          "3011:                                                          offset, next_offset - offset,",
          "3012:                                                          value, \"%s\",",
          "3013:                                                          tvb_format_text(tvb, offset, linelen));",
          "3014:                         }",
          "3015:                     break;",
          "3017:                     case POS_EXPIRES :",
          "3018:                         if (strcmp(value, \"0\") == 0)",
          "3019:                         {",
          "3020:                             expires_is_0 = 1;",
          "3021:                         }",
          "3023:                         if(hdr_tree) {",
          "3024:                             proto_tree_add_uint(hdr_tree,",
          "3025:                                                 hf_header_array[hf_index], tvb,",
          "3026:                                                 offset, next_offset - offset,",
          "3027:                                                 atoi(value));",
          "3028:                         }",
          "3029:                     break;",
          "3037:                     case POS_CONTENT_TYPE :",
          "3038:                         proto_tree_add_string_format(hdr_tree,",
          "3039:                                                          hf_header_array[hf_index], tvb,",
          "3040:                                                          offset, next_offset - offset,",
          "3041:                                                          value, \"%s\",",
          "3042:                                                          tvb_format_text(tvb, offset, linelen));",
          "3043:                         content_type_len = value_len;",
          "3044:                         semi_colon_offset = tvb_find_guint8(tvb, value_offset, value_len, ';');",
          "3051:                         if ( semi_colon_offset != -1) {",
          "3052:                             gint content_type_end;",
          "3056:                             parameter_offset = tvb_skip_wsp(tvb, semi_colon_offset +1, value_offset + value_len - (semi_colon_offset +1));",
          "3057:                             content_type_end = tvb_skip_wsp_return(tvb, semi_colon_offset-1);",
          "3058:                             content_type_len = content_type_end - value_offset;",
          "3059:                             content_type_parameter_str_len = value_offset + value_len - parameter_offset;",
          "3060:                             content_type_parameter_str = tvb_get_string(wmem_packet_scope(), tvb, parameter_offset,",
          "3061:                                                          content_type_parameter_str_len);",
          "3062:                         }",
          "3063:                         media_type_str_lower_case = ascii_strdown_inplace(",
          "3064:                             (gchar *)tvb_get_string(wmem_packet_scope(), tvb, value_offset, content_type_len));",
          "3067:                         proto_tree_add_text(hdr_tree, tvb, value_offset,content_type_len,",
          "3068:                                             \"media_type_str(lower cased)=%s\",media_type_str_lower_case);",
          "3070:                     break;",
          "3072:                     case POS_CONTENT_LENGTH :",
          "3073:                         content_length = atoi(value);",
          "3074:                         if(hdr_tree) {",
          "3075:                             proto_tree_add_uint_format(hdr_tree,",
          "3076:                                                hf_header_array[hf_index], tvb,",
          "3077:                                                offset, next_offset - offset,",
          "3078:                                                content_length, \"%s\",",
          "3079:                                                tvb_format_text(tvb, offset, linelen));",
          "3080:                         }",
          "3081:                         break;",
          "3083:                     case POS_MAX_BREADTH :",
          "3084:                     case POS_MAX_FORWARDS :",
          "3085:                     case POS_RSEQ :",
          "3086:                         if(hdr_tree) {",
          "3087:                             proto_tree_add_uint(hdr_tree,",
          "3088:                                                 hf_header_array[hf_index], tvb,",
          "3089:                                                 offset, next_offset - offset,",
          "3090:                                                 (guint32)strtoul(value, NULL, 10));",
          "3091:                         }",
          "3092:                         break;",
          "3094:                     case POS_CONTACT :",
          "3100:                         sip_element_item = proto_tree_add_string_format(hdr_tree,",
          "3101:                                                hf_header_array[hf_index], tvb,",
          "3102:                                                offset, next_offset - offset,",
          "3103:                                                value, \"%s\",",
          "3104:                                                tvb_format_text(tvb, offset, linelen));",
          "3105:                         sip_element_tree = proto_item_add_subtree( sip_element_item,",
          "3106:                                                ett_sip_element);",
          "3109:                         c = tvb_get_guint8(tvb, value_offset);",
          "3110:                         if (c =='*'){",
          "3111:                             contact_is_star = 1;",
          "3112:                             break;",
          "3113:                         }",
          "3115:                         if(hdr_tree) {",
          "3116:                             comma_offset = value_offset;",
          "3117:                             while((comma_offset = dissect_sip_contact_item(tvb, pinfo, sip_element_tree, comma_offset,",
          "3118:                                     next_offset, &contacts_expires_0, &contacts_expires_unknown)) != -1)",
          "3119:                             {",
          "3120:                                 contacts++;",
          "3121:                                 if(comma_offset == next_offset)",
          "3122:                                 {",
          "3124:                                     break;",
          "3125:                                 }",
          "3127:                                 if(tvb_get_guint8(tvb, comma_offset) != ',')",
          "3128:                                 {",
          "3130:                                     break;",
          "3131:                                 }",
          "3133:                             }",
          "3134:                         }",
          "3135:                     break;",
          "3137:                     case POS_AUTHORIZATION:",
          "3145:                     case POS_WWW_AUTHENTICATE:",
          "3153:                     case POS_PROXY_AUTHENTICATE:",
          "3156:                     case POS_PROXY_AUTHORIZATION:",
          "3159:                     case POS_AUTHENTICATION_INFO:",
          "3167:                         if (hdr_tree) {",
          "3168:                             proto_item *ti_c;",
          "3170:                             sip_element_item = proto_tree_add_string_format(hdr_tree,",
          "3171:                                                hf_header_array[hf_index], tvb,",
          "3172:                                                offset, next_offset - offset,",
          "3173:                                                value, \"%s\",",
          "3174:                                                tvb_format_text(tvb, offset, linelen));",
          "3175:                             sip_element_tree = proto_item_add_subtree( sip_element_item,",
          "3176:                                                ett_sip_element);",
          "3179:                             ti_c = proto_tree_add_item(hdr_tree, hf_sip_auth, tvb,",
          "3180:                                                      offset, next_offset-offset,",
          "3181:                                                      ENC_ASCII|ENC_NA);",
          "3182:                             PROTO_ITEM_SET_HIDDEN(ti_c);",
          "3185:                             if (hf_index != POS_AUTHENTICATION_INFO)",
          "3186:                             {",
          "3188:                                 comma_offset = tvb_pbrk_guint8(tvb, value_offset, line_end_offset - value_offset, \" \\t\\r\\n\", NULL);",
          "3189:                                 proto_tree_add_item(sip_element_tree, hf_sip_auth_scheme,",
          "3190:                                                     tvb, value_offset, comma_offset - value_offset,",
          "3191:                                                     ENC_ASCII|ENC_NA);",
          "3192:                             }else{",
          "3194:                                 comma_offset = value_offset;",
          "3195:                             }",
          "3198:                             while ((comma_offset = dissect_sip_authorization_item(tvb, sip_element_tree, comma_offset, line_end_offset)) != -1)",
          "3199:                             {",
          "3200:                                 if(comma_offset == line_end_offset)",
          "3201:                                 {",
          "3203:                                     break;",
          "3204:                                 }",
          "3206:                                 if(tvb_get_guint8(tvb, comma_offset) != ',')",
          "3207:                                 {",
          "3209:                                     break;",
          "3210:                                 }",
          "3212:                             }",
          "3214:                     break;",
          "3216:                     case POS_ROUTE:",
          "3218:                         if (hdr_tree) {",
          "3219:                             sip_element_item = proto_tree_add_string_format(hdr_tree,",
          "3220:                                                          hf_header_array[hf_index], tvb,",
          "3221:                                                          offset, next_offset - offset,",
          "3222:                                                          value, \"%s\",",
          "3223:                                                          tvb_format_text(tvb, offset, linelen));",
          "3224:                             route_tree = proto_item_add_subtree(sip_element_item, ett_sip_route);",
          "3225:                             dissect_sip_route_header(tvb, route_tree, pinfo, &sip_route_uri, value_offset, line_end_offset);",
          "3226:                         }",
          "3227:                         break;",
          "3228:                     case POS_RECORD_ROUTE:",
          "3230:                         if (hdr_tree) {",
          "3231:                             sip_element_item = proto_tree_add_string_format(hdr_tree,",
          "3232:                                                          hf_header_array[hf_index], tvb,",
          "3233:                                                          offset, next_offset - offset,",
          "3234:                                                          value, \"%s\",",
          "3235:                                                          tvb_format_text(tvb, offset, linelen));",
          "3236:                             route_tree = proto_item_add_subtree(sip_element_item, ett_sip_route);",
          "3237:                             dissect_sip_route_header(tvb, route_tree, pinfo, &sip_record_route_uri, value_offset, line_end_offset);",
          "3238:                         }",
          "3239:                         break;",
          "3240:                     case POS_VIA:",
          "3242:                         if (hdr_tree) {",
          "3243:                             sip_element_item = proto_tree_add_string_format(hdr_tree,",
          "3244:                                                          hf_header_array[hf_index], tvb,",
          "3245:                                                          offset, next_offset - offset,",
          "3246:                                                          value, \"%s\",",
          "3247:                                                          tvb_format_text(tvb, offset, linelen));",
          "3248:                             via_tree = proto_item_add_subtree(sip_element_item, ett_sip_via);",
          "3249:                             dissect_sip_via_header(tvb, via_tree, value_offset, line_end_offset);",
          "3250:                         }",
          "3251:                         break;",
          "3252:                     case POS_REASON:",
          "3253:                         if(hdr_tree) {",
          "3254:                             sip_element_item = proto_tree_add_string_format(hdr_tree,",
          "3255:                                                          hf_header_array[hf_index], tvb,",
          "3256:                                                          offset, next_offset - offset,",
          "3257:                                                          value, \"%s\",",
          "3258:                                                          tvb_format_text(tvb, offset, linelen));",
          "3259:                             reason_tree = proto_item_add_subtree(sip_element_item, ett_sip_reason);",
          "3260:                             dissect_sip_reason_header(tvb, reason_tree, value_offset, line_end_offset);",
          "3261:                         }",
          "3262:                         break;",
          "3263:                     case POS_CONTENT_ENCODING:",
          "3267:                         proto_tree_add_string_format(hdr_tree,",
          "3268:                                                          hf_header_array[hf_index], tvb,",
          "3269:                                                          offset, next_offset - offset,",
          "3270:                                                          value, \"%s\",",
          "3271:                                                          tvb_format_text(tvb, offset, linelen));",
          "3273:                         content_encoding_parameter_str = ascii_strdown_inplace(tvb_get_string(wmem_packet_scope(), tvb, value_offset,",
          "3274:                                                          (line_end_offset-value_offset)));",
          "3275:                         break;",
          "3276:                     case POS_SECURITY_CLIENT:",
          "3280:                         sip_element_item = proto_tree_add_string_format(hdr_tree,",
          "3281:                                                          hf_header_array[hf_index], tvb,",
          "3282:                                                          offset, next_offset - offset,",
          "3283:                                                          value, \"%s\",",
          "3284:                                                          tvb_format_text(tvb, offset, linelen));",
          "3285:                         comma_offset = tvb_find_guint8(tvb, value_offset, line_end_offset - value_offset, ',');",
          "3286:                         while(comma_offset<line_end_offset){",
          "3287:                             comma_offset = tvb_find_guint8(tvb, value_offset, line_end_offset - value_offset, ',');",
          "3288:                             if(comma_offset == -1){",
          "3289:                                 comma_offset = line_end_offset;",
          "3290:                             }",
          "3291:                             security_client_tree = proto_item_add_subtree(sip_element_item, ett_sip_security_client);",
          "3292:                             dissect_sip_sec_mechanism(tvb, pinfo, security_client_tree, value_offset, comma_offset);",
          "3293:                             comma_offset = value_offset = comma_offset+1;",
          "3294:                         }",
          "3296:                         break;",
          "3297:                     case POS_SECURITY_SERVER:",
          "3301:                         sip_element_item = proto_tree_add_string_format(hdr_tree,",
          "3302:                                                          hf_header_array[hf_index], tvb,",
          "3303:                                                          offset, next_offset - offset,",
          "3304:                                                          value, \"%s\",",
          "3305:                                                          tvb_format_text(tvb, offset, linelen));",
          "3306:                         comma_offset = tvb_find_guint8(tvb, value_offset, line_end_offset - value_offset, ',');",
          "3307:                         while(comma_offset<line_end_offset){",
          "3308:                             comma_offset = tvb_find_guint8(tvb, value_offset, line_end_offset - value_offset, ',');",
          "3309:                             if(comma_offset == -1){",
          "3310:                                 comma_offset = line_end_offset;",
          "3311:                             }",
          "3312:                             security_client_tree = proto_item_add_subtree(sip_element_item, ett_sip_security_server);",
          "3313:                             dissect_sip_sec_mechanism(tvb, pinfo, security_client_tree, value_offset, comma_offset);",
          "3314:                             comma_offset = value_offset = comma_offset+1;",
          "3315:                         }",
          "3327:                         comma_offset = tvb_find_guint8(tvb, value_offset, line_end_offset - value_offset, ',');",
          "3328:                         while(comma_offset<line_end_offset){",
          "3329:                             comma_offset = tvb_find_guint8(tvb, value_offset, line_end_offset - value_offset, ',');",
          "3330:                             if(comma_offset == -1){",
          "3331:                                 comma_offset = line_end_offset;",
          "3332:                             }",
          "3333:                             security_client_tree = proto_item_add_subtree(sip_element_item, ett_sip_security_verify);",
          "3334:                             dissect_sip_sec_mechanism(tvb, pinfo, security_client_tree, value_offset, comma_offset);",
          "3335:                             comma_offset = value_offset = comma_offset+1;",
          "3336:                         }",
          "3341:                         proto_tree_add_string_format(hdr_tree,",
          "3342:                                                          hf_header_array[hf_index], tvb,",
          "3343:                                                          offset, next_offset - offset,",
          "3344:                                                          value, \"%s\",",
          "3345:                                                          tvb_format_text(tvb, offset, linelen));",
          "3346:                         break;",
          "3350:         if (is_no_header_termination == TRUE){",
          "3352:             proto_tree_add_expert(hdr_tree, pinfo, &ei_sip_header_not_terminated,",
          "3353:                                     tvb, line_end_offset, -1);",
          "3354:         }",
          "3355:         offset = next_offset;",
          "3358:     datalen = tvb_length_remaining(tvb, offset);",
          "3359:     reported_datalen = tvb_reported_length_remaining(tvb, offset);",
          "3360:     if (content_length != -1) {",
          "3361:         if (datalen > content_length)",
          "3362:             datalen = content_length;",
          "3363:         if (reported_datalen > content_length)",
          "3364:             reported_datalen = content_length;",
          "3365:     }",
          "3372:     if (expires_is_0) {",
          "3374:         contacts_expires_0 += contacts_expires_unknown;",
          "3375:     }",
          "3378:     if (current_method_idx == SIP_METHOD_REGISTER)",
          "3379:     {",
          "3383:         if (contact_is_star && expires_is_0)",
          "3384:         {",
          "3385:             col_append_str(pinfo->cinfo, COL_INFO, \"  (remove all bindings)\");",
          "3386:         }",
          "3387:         else",
          "3388:         if (contacts_expires_0 > 0)",
          "3389:         {",
          "3390:             col_append_fstr(pinfo->cinfo, COL_INFO, \"  (remove %d binding%s)\",",
          "3391:                 contacts_expires_0, contacts_expires_0 == 1 ? \"\":\"s\");",
          "3392:             if (contacts > contacts_expires_0) {",
          "3393:                 col_append_fstr(pinfo->cinfo, COL_INFO, \" (add %d binding%s)\",",
          "3394:                     contacts - contacts_expires_0,",
          "3395:                     (contacts - contacts_expires_0 == 1) ? \"\":\"s\");",
          "3396:             }",
          "3397:         }",
          "3398:         else",
          "3399:         if (!contacts)",
          "3400:         {",
          "3401:             col_append_str(pinfo->cinfo, COL_INFO, \"  (fetch bindings)\");",
          "3402:         }",
          "3403:         else",
          "3404:         {",
          "3405:             col_append_fstr(pinfo->cinfo, COL_INFO, \"  (%d binding%s)\",",
          "3406:                 contacts, contacts == 1 ? \"\":\"s\");",
          "3407:         }",
          "3408:     }",
          "3411:     if (line_type == STATUS_LINE && (strcmp(cseq_method, \"REGISTER\") == 0) &&",
          "3412:         stat_info && stat_info->response_code > 199 && stat_info->response_code < 300)",
          "3413:     {",
          "3414:         if (contacts_expires_0 > 0) {",
          "3415:             col_append_fstr(pinfo->cinfo, COL_INFO, \"  (removed %d binding%s)\",",
          "3416:                 contacts_expires_0, contacts_expires_0 == 1 ? \"\":\"s\");",
          "3417:             if (contacts > contacts_expires_0) {",
          "3418:                 col_append_fstr(pinfo->cinfo, COL_INFO, \" (%d binding%s kept)\",",
          "3419:                     contacts - contacts_expires_0,",
          "3420:                     (contacts - contacts_expires_0 == 1) ? \"\":\"s\");",
          "3421:             }",
          "3422:         } else {",
          "3423:             col_append_fstr(pinfo->cinfo, COL_INFO, \"  (%d binding%s)\",",
          "3424:                 contacts, contacts == 1 ? \"\":\"s\");",
          "3425:         }",
          "3426:     }",
          "3435:     col_append_str(pinfo->cinfo, COL_INFO, \" | \");",
          "3436:     col_set_fence(pinfo->cinfo, COL_INFO);",
          "3441:     if ((line_type == REQUEST_LINE)&&(strcmp(cseq_method, \"ACK\") == 0))",
          "3442:     {",
          "3443:         request_for_response = sip_find_invite(pinfo, cseq_method, call_id,",
          "3444:                                                 cseq_number_set, cseq_number,",
          "3445:                                                 &response_time);",
          "3446:         stat_info->setup_time = response_time;",
          "3447:     }",
          "3450:     resend_for_packet = sip_is_packet_resend(pinfo, cseq_method, call_id,",
          "3451:                                              cseq_number_set, cseq_number,",
          "3452:                                              line_type);",
          "3454:     stat_info->resend = (resend_for_packet > 0);",
          "3457:     if (line_type == STATUS_LINE)",
          "3458:     {",
          "3459:         request_for_response = sip_find_request(pinfo, cseq_method, call_id,",
          "3460:                                                 cseq_number_set, cseq_number,",
          "3461:                                                 &response_time);",
          "3462:     }",
          "3464:     if (datalen > 0) {",
          "3469:         proto_item_set_end(th, tvb, offset);",
          "3470:         if(content_encoding_parameter_str != NULL &&",
          "3471:             (!strncmp(content_encoding_parameter_str, \"gzip\", 4) ||",
          "3472:              !strncmp(content_encoding_parameter_str,\"deflate\",7))){",
          "3474:             next_tvb = tvb_uncompress(tvb, offset,  datalen);",
          "3475:             if (next_tvb) {",
          "3476:                 add_new_data_source(pinfo, next_tvb, \"gunziped data\");",
          "3477:                 if(sip_tree) {",
          "3478:                     ti_a = proto_tree_add_item(sip_tree, hf_sip_msg_body, next_tvb, 0, -1,",
          "3479:                                          ENC_NA);",
          "3480:                     message_body_tree = proto_item_add_subtree(ti_a, ett_sip_message_body);",
          "3481:                 }",
          "3482:             } else {",
          "3483:                 next_tvb = tvb_new_subset(tvb, offset, datalen, reported_datalen);",
          "3484:                 if(sip_tree) {",
          "3485:                     ti_a = proto_tree_add_item(sip_tree, hf_sip_msg_body, next_tvb, 0, -1,",
          "3486:                                          ENC_NA);",
          "3487:                     message_body_tree = proto_item_add_subtree(ti_a, ett_sip_message_body);",
          "3488:                 }",
          "3489:             }",
          "3490:         }else{",
          "3491:             next_tvb = tvb_new_subset(tvb, offset, datalen, reported_datalen);",
          "3492:             if(sip_tree) {",
          "3493:                 ti_a = proto_tree_add_item(sip_tree, hf_sip_msg_body, next_tvb, 0, -1,",
          "3494:                                      ENC_NA);",
          "3495:                 message_body_tree = proto_item_add_subtree(ti_a, ett_sip_message_body);",
          "3496:             }",
          "3497:         }",
          "3500:         if ( media_type_str_lower_case != NULL ) {",
          "3501:             void *save_private_data = pinfo->private_data;",
          "3502:             pinfo->private_data = content_type_parameter_str;",
          "3505:             if (!strcmp(media_type_str_lower_case, \"application/sdp\")) {",
          "3507:                 if (resend_for_packet == 0) {",
          "3508:                     if (line_type == REQUEST_LINE) {",
          "3509:                         setup_sdp_transport(next_tvb, pinfo, SDP_EXCHANGE_OFFER, pinfo->fd->num);",
          "3510:                     } else if (line_type == STATUS_LINE) {",
          "3511:                         if (stat_info->response_code >= 400) {",
          "3513:                             setup_sdp_transport(next_tvb, pinfo, SDP_EXCHANGE_ANSWER_REJECT, request_for_response);",
          "3514:                         }",
          "3515:                         else if ((stat_info->response_code >= 200) && (stat_info->response_code <= 299)) {",
          "3517:                             setup_sdp_transport(next_tvb, pinfo, SDP_EXCHANGE_ANSWER_ACCEPT, request_for_response);",
          "3518:                         }",
          "3519:                     }",
          "3520:                 } else {",
          "3521:                     setup_sdp_transport_resend(pinfo->fd->num, resend_for_packet);",
          "3522:                 }",
          "3523:             }",
          "3527:             found_match = dissector_try_string(media_type_dissector_table,",
          "3528:                                                media_type_str_lower_case,",
          "3529:                                                next_tvb, pinfo,",
          "3530:                                                message_body_tree, NULL);",
          "3531:             if (!found_match &&",
          "3532:                 !strncmp(media_type_str_lower_case, \"multipart/\", sizeof(\"multipart/\")-1)) {",
          "3534:                 found_match = dissector_try_string(media_type_dissector_table,",
          "3535:                                                    \"multipart/\",",
          "3536:                                                    next_tvb, pinfo,",
          "3537:                                                    message_body_tree, NULL);",
          "3538:             }",
          "3539:             pinfo->private_data = save_private_data;",
          "3541:         }",
          "3542:         if ( found_match != TRUE )",
          "3543:         {",
          "3544:             if (!(dissector_try_heuristic(heur_subdissector_list,",
          "3545:                               next_tvb, pinfo, message_body_tree, NULL))) {",
          "3546:                 int tmp_offset = 0;",
          "3547:                 while (tvb_offset_exists(next_tvb, tmp_offset)) {",
          "3548:                     tvb_find_line_end(next_tvb, tmp_offset, -1, &next_offset, FALSE);",
          "3549:                     linelen = next_offset - tmp_offset;",
          "3550:                     if(message_body_tree) {",
          "3551:                         proto_tree_add_text(message_body_tree, next_tvb,",
          "3552:                                     tmp_offset, linelen, \"%s\",",
          "3553:                                     tvb_format_text(next_tvb, tmp_offset, linelen));",
          "3554:                     }",
          "3555:                     tmp_offset = next_offset;",
          "3557:             }",
          "3558:         }",
          "3559:         offset += datalen;",
          "3560:     }",
          "3563:     if (reqresp_tree)",
          "3564:     {",
          "3565:         proto_item *item;",
          "3566:         item = proto_tree_add_boolean(reqresp_tree, hf_sip_resend, tvb, orig_offset, 0,",
          "3567:                                       resend_for_packet > 0);",
          "3568:         PROTO_ITEM_SET_GENERATED(item);",
          "3569:         if (resend_for_packet > 0)",
          "3570:         {",
          "3571:             item = proto_tree_add_uint(reqresp_tree, hf_sip_original_frame,",
          "3572:                                        tvb, orig_offset, 0, resend_for_packet);",
          "3573:             PROTO_ITEM_SET_GENERATED(item);",
          "3574:         }",
          "3576:         if (request_for_response > 0)",
          "3577:         {",
          "3578:             item = proto_tree_add_uint(reqresp_tree, hf_sip_matching_request_frame,",
          "3579:                                        tvb, orig_offset, 0, request_for_response);",
          "3580:             PROTO_ITEM_SET_GENERATED(item);",
          "3581:             item = proto_tree_add_uint(reqresp_tree, hf_sip_response_time,",
          "3582:                                        tvb, orig_offset, 0, response_time);",
          "3583:             PROTO_ITEM_SET_GENERATED(item);",
          "3584:             if ((line_type == STATUS_LINE)&&(strcmp(cseq_method, \"BYE\") == 0)){",
          "3585:                 item = proto_tree_add_uint(reqresp_tree, hf_sip_release_time,",
          "3586:                                           tvb, orig_offset, 0, response_time);",
          "3587:                 PROTO_ITEM_SET_GENERATED(item);",
          "3588:             }",
          "3589:         }",
          "3590:     }",
          "3592:     if (ts != NULL)",
          "3593:         proto_item_set_len(ts, offset - orig_offset);",
          "3595:     if (global_sip_raw_text)",
          "3596:         tvb_raw_text_add(tvb, orig_offset, offset - orig_offset, tree);",
          "3599:     if (!pinfo->flags.in_error_pkt)",
          "3600:     {",
          "3601:         tap_queue_packet(sip_tap, pinfo, stat_info);",
          "3602:         if(have_tap_listener(exported_pdu_tap)){",
          "3603:             export_sip_pdu(pinfo,tvb);",
          "3604:         }",
          "3605:     }",
          "3608:     if (stat_info->request_method) {",
          "3609:         proto_item_append_text(ts, \" (%s)\", stat_info->request_method);",
          "3610:     }",
          "3611:     else {",
          "3612:         proto_item_append_text(ts, \" (%u)\", stat_info->response_code);",
          "3613:     }",
          "3614:     return offset - orig_offset;",
          "3621:     char    *value;",
          "3622:     guint   parameter_len = meth_len;",
          "3623:     uri_offset_info uri_offsets;",
          "3634:     value = tvb_get_string(wmem_packet_scope(), tvb, offset, parameter_len);",
          "3637:     stat_info->request_method = value;",
          "3639:     if (tree) {",
          "3640:         proto_tree_add_string(tree, hf_sip_Method, tvb, offset, parameter_len, value);",
          "3643:         offset=offset + parameter_len+1;",
          "3644:         sip_uri_offset_init(&uri_offsets);",
          "3646:         uri_offsets.uri_end = tvb_find_guint8(tvb, offset, linelen, ' ')-1;",
          "3647:         dissect_sip_uri(tvb, pinfo, offset, offset + linelen, &uri_offsets);",
          "3648:         display_sip_uri(tvb, tree, &uri_offsets, &sip_req_uri);",
          "3649:     }",
          "3656:     gint response_code = 0;",
          "3657:     int diag_len;",
          "3658:     tvbuff_t *next_tvb;",
          "3666:     response_code = atoi((char*)tvb_get_string(wmem_packet_scope(), tvb, offset + SIP2_HDR_LEN + 1, 3));",
          "3669:     if (tree) {",
          "3670:         proto_tree_add_uint(tree, hf_sip_Status_Code, tvb, offset + SIP2_HDR_LEN + 1,",
          "3671:                             3, response_code);",
          "3672:     }",
          "3675:     stat_info->response_code = response_code;",
          "3678:     offset =  SIP2_HDR_LEN + 1 + 3 + 1;",
          "3681:     diag_len = line_end - offset;",
          "3682:     if((diag_len) <= 0)",
          "3683:         return;",
          "3686:     if(sip_diag_handle){",
          "3687:         next_tvb = tvb_new_subset(tvb, offset, diag_len, diag_len);",
          "3688:         call_dissector(sip_diag_handle, next_tvb, pinfo, tree);",
          "3689:     }",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "3705: static line_type_t",
          "3706: sip_parse_line(tvbuff_t *tvb, int offset, gint linelen, guint *token_1_lenp)",
          "3707: {",
          "3819: }",
          "3821: static gboolean sip_is_known_request(tvbuff_t *tvb, int meth_offset,",
          "3823: {",
          "3839: }",
          "",
          "[Removed Lines]",
          "3708:  gint space_offset;",
          "3709:  gint token_1_start;",
          "3710:  guint token_1_len;",
          "3711:  gint token_2_start;",
          "3712:  guint token_2_len;",
          "3713:  gint token_3_start;",
          "3714:  guint token_3_len;",
          "3715:  gint colon_pos;",
          "3717:  token_1_start = offset;",
          "3718:  space_offset = tvb_find_guint8(tvb, token_1_start, -1, ' ');",
          "3719:  if ((space_offset == -1) || (space_offset == token_1_start)) {",
          "3729:   return OTHER_LINE;",
          "3730:  }",
          "3731:  token_1_len = space_offset - token_1_start;",
          "3732:  token_2_start = space_offset + 1;",
          "3733:  space_offset = tvb_find_guint8(tvb, token_2_start, -1, ' ');",
          "3734:  if (space_offset == -1) {",
          "3739:   return OTHER_LINE;",
          "3740:  }",
          "3741:  token_2_len = space_offset - token_2_start;",
          "3742:  token_3_start = space_offset + 1;",
          "3743:  token_3_len = token_1_start + linelen - token_3_start;",
          "3750:  if ( (strict_sip_version && (",
          "3751:   token_1_len == SIP2_HDR_LEN",
          "3752:   && tvb_strneql(tvb, token_1_start, SIP2_HDR, SIP2_HDR_LEN) == 0)",
          "3753:  ) || (! strict_sip_version && (",
          "3754:   tvb_strncaseeql(tvb, token_1_start, \"SIP/\", 4) == 0)",
          "3755:  )) {",
          "3761:   if (token_2_len != 3) {",
          "3765:    return OTHER_LINE;",
          "3766:   }",
          "3767:   if (!isdigit(tvb_get_guint8(tvb, token_2_start)) ||",
          "3768:       !isdigit(tvb_get_guint8(tvb, token_2_start + 1)) ||",
          "3769:       !isdigit(tvb_get_guint8(tvb, token_2_start + 2))) {",
          "3773:    return OTHER_LINE;",
          "3774:   }",
          "3775:   return STATUS_LINE;",
          "3776:  } else {",
          "3783:   if (token_2_len < 3) {",
          "3788:    return OTHER_LINE;",
          "3789:   }",
          "3790:   colon_pos = tvb_find_guint8(tvb, token_2_start + 1, -1, ':');",
          "3791:   if (colon_pos == -1) {",
          "3796:    return OTHER_LINE;",
          "3797:   }",
          "3798:   if (colon_pos >= token_3_start) {",
          "3802:    return OTHER_LINE;",
          "3803:   }",
          "3805:   if ( (strict_sip_version && (",
          "3806:    token_3_len != SIP2_HDR_LEN",
          "3807:    || tvb_strneql(tvb, token_3_start, SIP2_HDR, SIP2_HDR_LEN) == -1)",
          "3808:   ) || (! strict_sip_version && (",
          "3809:    tvb_strncaseeql(tvb, token_3_start, \"SIP/\", 4) == -1)",
          "3810:   )) {",
          "3815:    return OTHER_LINE;",
          "3816:   }",
          "3817:   return REQUEST_LINE;",
          "3818:  }",
          "3822:          guint meth_len, guint *meth_idx)",
          "3824:  guint i;",
          "3825:  gchar *meth_name;",
          "3827:  meth_name = tvb_get_string(wmem_packet_scope(), tvb, meth_offset, meth_len);",
          "3829:  for (i = 1; i < array_length(sip_methods); i++) {",
          "3830:   if (meth_len == strlen(sip_methods[i]) &&",
          "3831:       strncmp(meth_name, sip_methods[i], meth_len) == 0)",
          "3832:   {",
          "3834:    return TRUE;",
          "3835:   }",
          "3836:  }",
          "3838:  return FALSE;",
          "",
          "[Added Lines]",
          "3708:     gint space_offset;",
          "3709:     gint token_1_start;",
          "3710:     guint token_1_len;",
          "3711:     gint token_2_start;",
          "3712:     guint token_2_len;",
          "3713:     gint token_3_start;",
          "3714:     guint token_3_len;",
          "3715:     gint colon_pos;",
          "3717:     token_1_start = offset;",
          "3718:     space_offset = tvb_find_guint8(tvb, token_1_start, -1, ' ');",
          "3719:     if ((space_offset == -1) || (space_offset == token_1_start)) {",
          "3729:         return OTHER_LINE;",
          "3730:     }",
          "3731:     token_1_len = space_offset - token_1_start;",
          "3732:     token_2_start = space_offset + 1;",
          "3733:     space_offset = tvb_find_guint8(tvb, token_2_start, -1, ' ');",
          "3734:     if (space_offset == -1) {",
          "3739:         return OTHER_LINE;",
          "3740:     }",
          "3741:     token_2_len = space_offset - token_2_start;",
          "3742:     token_3_start = space_offset + 1;",
          "3743:     token_3_len = token_1_start + linelen - token_3_start;",
          "3750:     if ( (strict_sip_version && (",
          "3751:         token_1_len == SIP2_HDR_LEN",
          "3752:         && tvb_strneql(tvb, token_1_start, SIP2_HDR, SIP2_HDR_LEN) == 0)",
          "3753:     ) || (! strict_sip_version && (",
          "3754:         tvb_strncaseeql(tvb, token_1_start, \"SIP/\", 4) == 0)",
          "3755:     )) {",
          "3761:         if (token_2_len != 3) {",
          "3765:             return OTHER_LINE;",
          "3766:         }",
          "3767:         if (!isdigit(tvb_get_guint8(tvb, token_2_start)) ||",
          "3768:             !isdigit(tvb_get_guint8(tvb, token_2_start + 1)) ||",
          "3769:             !isdigit(tvb_get_guint8(tvb, token_2_start + 2))) {",
          "3773:             return OTHER_LINE;",
          "3774:         }",
          "3775:         return STATUS_LINE;",
          "3776:     } else {",
          "3783:         if (token_2_len < 3) {",
          "3788:             return OTHER_LINE;",
          "3789:         }",
          "3790:         colon_pos = tvb_find_guint8(tvb, token_2_start + 1, -1, ':');",
          "3791:         if (colon_pos == -1) {",
          "3796:             return OTHER_LINE;",
          "3797:         }",
          "3798:         if (colon_pos >= token_3_start) {",
          "3802:             return OTHER_LINE;",
          "3803:         }",
          "3805:         if ( (strict_sip_version && (",
          "3806:             token_3_len != SIP2_HDR_LEN",
          "3807:             || tvb_strneql(tvb, token_3_start, SIP2_HDR, SIP2_HDR_LEN) == -1)",
          "3808:         ) || (! strict_sip_version && (",
          "3809:             tvb_strncaseeql(tvb, token_3_start, \"SIP/\", 4) == -1)",
          "3810:         )) {",
          "3815:             return OTHER_LINE;",
          "3816:         }",
          "3817:         return REQUEST_LINE;",
          "3818:     }",
          "3822:                      guint meth_len, guint *meth_idx)",
          "3824:     guint i;",
          "3825:     gchar *meth_name;",
          "3827:     meth_name = tvb_get_string(wmem_packet_scope(), tvb, meth_offset, meth_len);",
          "3829:     for (i = 1; i < array_length(sip_methods); i++) {",
          "3830:         if (meth_len == strlen(sip_methods[i]) &&",
          "3831:             strncmp(meth_name, sip_methods[i], meth_len) == 0)",
          "3832:         {",
          "3834:             return TRUE;",
          "3835:         }",
          "3836:     }",
          "3838:     return FALSE;",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "3845: static gint sip_is_known_sip_header(gchar *header_name, guint header_len)",
          "3846: {",
          "3865: }",
          "",
          "[Removed Lines]",
          "3847:  guint pos;",
          "3850:  if(header_len>1){",
          "3851:   pos = GPOINTER_TO_UINT(g_hash_table_lookup(sip_headers_hash, header_name));",
          "3852:   if (pos!=0)",
          "3853:    return pos;",
          "3854:  }",
          "3857:  for (pos = 1; pos < array_length(sip_headers); pos++) {",
          "3858:   if (sip_headers[pos].compact_name != NULL &&",
          "3859:     header_len == strlen(sip_headers[pos].compact_name) &&",
          "3860:     g_ascii_strncasecmp(header_name, sip_headers[pos].compact_name, header_len) == 0)",
          "3861:    return pos;",
          "3862:  }",
          "3864:  return -1;",
          "",
          "[Added Lines]",
          "3847:     guint pos;",
          "3850:     if(header_len>1){",
          "3851:         pos = GPOINTER_TO_UINT(g_hash_table_lookup(sip_headers_hash, header_name));",
          "3852:         if (pos!=0)",
          "3853:             return pos;",
          "3854:     }",
          "3857:     for (pos = 1; pos < array_length(sip_headers); pos++) {",
          "3858:         if (sip_headers[pos].compact_name != NULL &&",
          "3859:                 header_len == strlen(sip_headers[pos].compact_name) &&",
          "3860:                 g_ascii_strncasecmp(header_name, sip_headers[pos].compact_name, header_len) == 0)",
          "3861:             return pos;",
          "3862:     }",
          "3864:     return -1;",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "3870: static void",
          "3871: tvb_raw_text_add(tvbuff_t *tvb, int offset, int length, proto_tree *tree)",
          "3872: {",
          "3900: }",
          "3904: guint sip_is_packet_resend(packet_info *pinfo,",
          "3909: {",
          "4096: }",
          "4101: guint sip_find_request(packet_info *pinfo,",
          "4107: {",
          "4208: }",
          "4213: guint sip_find_invite(packet_info *pinfo,",
          "4219: {",
          "4220: #if 0",
          "4222: #endif",
          "4281: #if 0",
          "4284: #endif",
          "4295: #if 0",
          "4302: #endif",
          "4328: }",
          "",
          "[Removed Lines]",
          "3873:  proto_tree *raw_tree = NULL;",
          "3874:  proto_item *ti = NULL;",
          "3875:  int next_offset, linelen, end_offset;",
          "3876:  char *str;",
          "3878:  if (tree) {",
          "3879:   ti = proto_tree_add_item(tree, proto_raw_sip, tvb, offset, length, ENC_NA);",
          "3880:   raw_tree = proto_item_add_subtree(ti, ett_raw_text);",
          "3881:  }",
          "3883:  end_offset = offset + length;",
          "3885:  while (offset < end_offset) {",
          "3886:   tvb_find_line_end(tvb, offset, -1, &next_offset, FALSE);",
          "3887:   linelen = next_offset - offset;",
          "3888:   if (raw_tree) {",
          "3889:    if (global_sip_raw_text_without_crlf)",
          "3890:     str = tvb_format_text_wsp(tvb, offset, linelen);",
          "3891:    else",
          "3892:     str = tvb_format_text(tvb, offset, linelen);",
          "3893:    proto_tree_add_string_format(raw_tree, hf_sip_raw_line, tvb, offset, linelen,",
          "3894:            str,",
          "3895:            \"%s\",",
          "3896:            str);",
          "3897:   }",
          "3898:   offset = next_offset;",
          "3899:  }",
          "3905:    gchar *cseq_method,",
          "3906:    gchar *call_id,",
          "3907:    guchar cseq_number_set,",
          "3908:    guint32 cseq_number, line_type_t line_type)",
          "3910:  guint32 cseq_to_compare = 0;",
          "3911:  sip_hash_key   key;",
          "3912:  sip_hash_key   *p_key = 0;",
          "3913:  sip_hash_value *p_val = 0;",
          "3914:  sip_frame_result_value *sip_frame_result = NULL;",
          "3915:  guint result = 0;",
          "3918:  if (pinfo->ptype != PT_UDP)",
          "3919:  {",
          "3920:   return 0;",
          "3921:  }",
          "3925:  if (pinfo->flags.in_error_pkt)",
          "3926:  {",
          "3927:   return 0;",
          "3928:  }",
          "3932:  if (!cseq_number_set)",
          "3933:  {",
          "3934:   return 0;",
          "3935:  }",
          "3938:  if (pinfo->fd->flags.visited)",
          "3939:  {",
          "3940:   sip_frame_result = (sip_frame_result_value*)p_get_proto_data(wmem_file_scope(), pinfo, proto_sip, pinfo->curr_layer_num);",
          "3941:   if (sip_frame_result != NULL)",
          "3942:   {",
          "3943:    return sip_frame_result->original_frame_num;",
          "3944:   }",
          "3945:   else",
          "3946:   {",
          "3947:    return 0;",
          "3948:   }",
          "3949:  }",
          "3954:  g_strlcpy(key.call_id, call_id, MAX_CALL_ID_SIZE);",
          "3959:  SET_ADDRESS(&key.dest_address, pinfo->net_dst.type, pinfo->net_dst.len,",
          "3960:       pinfo->net_dst.data);",
          "3961:  SET_ADDRESS(&key.source_address, pinfo->net_src.type,",
          "3962:       pinfo->net_src.len, pinfo->net_src.data);",
          "3963:  key.dest_port = pinfo->destport;",
          "3964:  if (sip_retrans_the_same_sport) {",
          "3965:   key.source_port = pinfo->srcport;",
          "3966:  } else {",
          "3967:   key.source_port = MAGIC_SOURCE_PORT;",
          "3968:  }",
          "3971:  p_val = (sip_hash_value*)g_hash_table_lookup(sip_hash, &key);",
          "3973:  if (p_val)",
          "3974:  {",
          "3976:   cseq_to_compare = p_val->cseq;",
          "3980:   if (cseq_number != p_val->cseq)",
          "3981:   {",
          "3982:    p_val->cseq = cseq_number;",
          "3983:    g_strlcpy(p_val->method, cseq_method, MAX_CSEQ_METHOD_SIZE);",
          "3984:    p_val->transaction_state = nothing_seen;",
          "3985:    p_val->frame_number = 0;",
          "3986:    if (line_type == REQUEST_LINE)",
          "3987:    {",
          "3988:     p_val->request_time = pinfo->fd->abs_ts;",
          "3989:    }",
          "3990:   }",
          "3991:  }",
          "3992:  else",
          "3993:  {",
          "3997:   p_key = wmem_new(wmem_file_scope(), sip_hash_key);",
          "3998:   p_val = wmem_new0(wmem_file_scope(), sip_hash_value);",
          "4001:   g_snprintf(p_key->call_id, MAX_CALL_ID_SIZE, \"%s\", call_id);",
          "4002:   SE_COPY_ADDRESS(&(p_key->dest_address), &pinfo->net_dst);",
          "4003:   SE_COPY_ADDRESS(&(p_key->source_address), &pinfo->net_src);",
          "4004:   p_key->dest_port = pinfo->destport;",
          "4005:   if (sip_retrans_the_same_sport) {",
          "4006:    p_key->source_port = pinfo->srcport;",
          "4007:   } else {",
          "4008:    p_key->source_port = MAGIC_SOURCE_PORT;",
          "4009:   }",
          "4011:   p_val->cseq = cseq_number;",
          "4012:   g_strlcpy(p_val->method, cseq_method, MAX_CSEQ_METHOD_SIZE);",
          "4013:   p_val->transaction_state = nothing_seen;",
          "4014:   if (line_type == REQUEST_LINE)",
          "4015:   {",
          "4016:    p_val->request_time = pinfo->fd->abs_ts;",
          "4017:   }",
          "4020:   g_hash_table_insert(sip_hash, p_key, p_val);",
          "4023:   cseq_to_compare = 0;",
          "4024:  }",
          "4033:  if ((line_type == REQUEST_LINE) && (cseq_number == cseq_to_compare) &&",
          "4034:      (p_val->transaction_state == request_seen) &&",
          "4035:      (strcmp(cseq_method, p_val->method) == 0) &&",
          "4036:      (strcmp(cseq_method, \"ACK\") != 0) &&",
          "4037:      (strcmp(cseq_method, \"CANCEL\") != 0))",
          "4038:  {",
          "4039:   result = p_val->frame_number;",
          "4040:  }",
          "4043:  if ((line_type == STATUS_LINE) && (cseq_number == cseq_to_compare) &&",
          "4044:      (p_val->transaction_state == final_response_seen) &&",
          "4045:      (strcmp(cseq_method, p_val->method) == 0) &&",
          "4046:      (stat_info->response_code >= 200) &&",
          "4047:      (stat_info->response_code == p_val->response_code))",
          "4048:  {",
          "4049:   result = p_val->frame_number;",
          "4050:  }",
          "4053:  p_val->cseq = cseq_number;",
          "4055:  switch (line_type)",
          "4056:  {",
          "4057:   case REQUEST_LINE:",
          "4058:    p_val->transaction_state = request_seen;",
          "4059:    if (!result)",
          "4060:    {",
          "4062:     p_val->frame_number = pinfo->fd->num;",
          "4063:    }",
          "4064:    break;",
          "4065:   case STATUS_LINE:",
          "4066:    if (stat_info->response_code >= 200)",
          "4067:    {",
          "4068:     p_val->response_code = stat_info->response_code;",
          "4069:     p_val->transaction_state = final_response_seen;",
          "4070:     if (!result)",
          "4071:     {",
          "4073:      p_val->frame_number = pinfo->fd->num;",
          "4074:     }",
          "4075:    }",
          "4076:    else",
          "4077:    {",
          "4078:     p_val->transaction_state = provisional_response_seen;",
          "4079:    }",
          "4080:    break;",
          "4081:   default:",
          "4082:    break;",
          "4083:  }",
          "4085:  sip_frame_result = (sip_frame_result_value *)p_get_proto_data(wmem_file_scope(), pinfo, proto_sip, pinfo->curr_layer_num);",
          "4086:  if (sip_frame_result == NULL)",
          "4087:  {",
          "4088:   sip_frame_result = wmem_new0(wmem_file_scope(), sip_frame_result_value);",
          "4089:   p_add_proto_data(wmem_file_scope(), pinfo, proto_sip, pinfo->curr_layer_num, sip_frame_result);",
          "4090:  }",
          "4093:  sip_frame_result->original_frame_num = result;",
          "4095:  return result;",
          "4102:    gchar *cseq_method,",
          "4103:    gchar *call_id,",
          "4104:    guchar cseq_number_set,",
          "4105:    guint32 cseq_number,",
          "4106:    guint32 *response_time)",
          "4108:  guint32 cseq_to_compare = 0;",
          "4109:  sip_hash_key   key;",
          "4110:  sip_hash_value *p_val = 0;",
          "4111:  sip_frame_result_value *sip_frame_result = NULL;",
          "4112:  guint result = 0;",
          "4113:  gint seconds_between_packets;",
          "4114:  gint nseconds_between_packets;",
          "4117:  if (pinfo->ptype != PT_UDP)",
          "4118:  {",
          "4119:   return 0;",
          "4120:  }",
          "4123:  if (pinfo->flags.in_error_pkt)",
          "4124:  {",
          "4125:   return 0;",
          "4126:  }",
          "4129:  if (!cseq_number_set)",
          "4130:  {",
          "4131:   return 0;",
          "4132:  }",
          "4135:  if (pinfo->fd->flags.visited)",
          "4136:  {",
          "4137:   sip_frame_result = (sip_frame_result_value*)p_get_proto_data(wmem_file_scope(), pinfo, proto_sip, pinfo->curr_layer_num);",
          "4138:   if (sip_frame_result != NULL)",
          "4139:   {",
          "4141:    return sip_frame_result->response_request_frame_num;",
          "4142:   }",
          "4143:   else",
          "4144:   {",
          "4145:    return 0;",
          "4146:   }",
          "4147:  }",
          "4152:  g_strlcpy(key.call_id, call_id, MAX_CALL_ID_SIZE);",
          "4155:  SET_ADDRESS(&key.dest_address, pinfo->net_src.type, pinfo->net_src.len,",
          "4156:       pinfo->net_src.data);",
          "4157:  SET_ADDRESS(&key.source_address, pinfo->net_dst.type, pinfo->net_dst.len,",
          "4158:    pinfo->net_dst.data);",
          "4159:  key.dest_port = pinfo->srcport;",
          "4160:  key.source_port = pinfo->destport;",
          "4163:  p_val = (sip_hash_value*)g_hash_table_lookup(sip_hash, &key);",
          "4165:  if (p_val)",
          "4166:  {",
          "4168:   cseq_to_compare = p_val->cseq;",
          "4169:  }",
          "4170:  else",
          "4171:  {",
          "4173:   return 0;",
          "4174:  }",
          "4179:  if ((cseq_number == cseq_to_compare) &&",
          "4180:      (p_val->transaction_state == request_seen) &&",
          "4181:      (strcmp(cseq_method, p_val->method) == 0))",
          "4182:  {",
          "4183:   result = p_val->frame_number;",
          "4184:  }",
          "4188:  sip_frame_result = (sip_frame_result_value *)p_get_proto_data(wmem_file_scope(), pinfo, proto_sip, pinfo->curr_layer_num);",
          "4189:  if (sip_frame_result == NULL)",
          "4190:  {",
          "4192:   sip_frame_result = wmem_new0(wmem_file_scope(), sip_frame_result_value);",
          "4193:   p_add_proto_data(wmem_file_scope(), pinfo, proto_sip, pinfo->curr_layer_num, sip_frame_result);",
          "4194:  }",
          "4196:  sip_frame_result->response_request_frame_num = result;",
          "4199:  seconds_between_packets = (gint)",
          "4200:      (pinfo->fd->abs_ts.secs - p_val->request_time.secs);",
          "4201:  nseconds_between_packets =",
          "4202:       pinfo->fd->abs_ts.nsecs - p_val->request_time.nsecs;",
          "4203:  sip_frame_result->response_time = (seconds_between_packets*1000) +",
          "4204:                                    (nseconds_between_packets / 1000000);",
          "4207:  return result;",
          "4214:    gchar *cseq_method _U_,",
          "4215:    gchar *call_id,",
          "4216:    guchar cseq_number_set,",
          "4217:    guint32 cseq_number _U_,",
          "4218:    guint32 *response_time)",
          "4221:  guint32 cseq_to_compare = 0;",
          "4223:  sip_hash_key   key;",
          "4224:  sip_hash_value *p_val = 0;",
          "4225:  sip_frame_result_value *sip_frame_result = NULL;",
          "4226:  guint result = 0;",
          "4227:  gint seconds_between_packets;",
          "4228:  gint nseconds_between_packets;",
          "4231:  if (pinfo->ptype != PT_UDP)",
          "4232:  {",
          "4233:   return 0;",
          "4234:  }",
          "4237:  if (pinfo->flags.in_error_pkt)",
          "4238:  {",
          "4239:   return 0;",
          "4240:  }",
          "4243:  if (!cseq_number_set)",
          "4244:  {",
          "4245:   return 0;",
          "4246:  }",
          "4249:  if (pinfo->fd->flags.visited)",
          "4250:  {",
          "4251:   sip_frame_result = (sip_frame_result_value*)p_get_proto_data(wmem_file_scope(), pinfo, proto_sip, pinfo->curr_layer_num);",
          "4252:   if (sip_frame_result != NULL)",
          "4253:   {",
          "4255:    return sip_frame_result->response_request_frame_num;",
          "4256:   }",
          "4257:   else",
          "4258:   {",
          "4259:    return 0;",
          "4260:   }",
          "4261:  }",
          "4266:  g_strlcpy(key.call_id, call_id, MAX_CALL_ID_SIZE);",
          "4269:  SET_ADDRESS(&key.dest_address, pinfo->net_dst.type, pinfo->net_dst.len,",
          "4270:    pinfo->net_dst.data);",
          "4271:  SET_ADDRESS(&key.source_address, pinfo->net_src.type, pinfo->net_src.len,",
          "4272:       pinfo->net_src.data);",
          "4273:  key.dest_port = pinfo->destport;",
          "4274:  key.source_port = pinfo->srcport;",
          "4277:  p_val = (sip_hash_value*)g_hash_table_lookup(sip_hash, &key);",
          "4279:  if (p_val)",
          "4280:  {",
          "4283:   cseq_to_compare = p_val->cseq;",
          "4285:  }",
          "4286:  else",
          "4287:  {",
          "4289:   return 0;",
          "4290:  }",
          "4296:  if ((cseq_number == cseq_to_compare) &&",
          "4297:      (p_val->transaction_state == request_seen) &&",
          "4298:      (strcmp(cseq_method, p_val->method) == 0))",
          "4299:  {",
          "4300:   result = p_val->frame_number;",
          "4301:  }",
          "4304:  result = p_val->frame_number;",
          "4307:  sip_frame_result = (sip_frame_result_value *)p_get_proto_data(wmem_file_scope(), pinfo, proto_sip, pinfo->curr_layer_num);",
          "4308:  if (sip_frame_result == NULL)",
          "4309:  {",
          "4311:   sip_frame_result = wmem_new0(wmem_file_scope(), sip_frame_result_value);",
          "4312:   p_add_proto_data(wmem_file_scope(), pinfo, proto_sip,  pinfo->curr_layer_num, sip_frame_result);",
          "4313:  }",
          "4315:  sip_frame_result->response_request_frame_num = result;",
          "4318:  seconds_between_packets = (gint)",
          "4319:      (pinfo->fd->abs_ts.secs - p_val->request_time.secs);",
          "4320:  nseconds_between_packets =",
          "4321:       pinfo->fd->abs_ts.nsecs - p_val->request_time.nsecs;",
          "4322:  sip_frame_result->response_time = (seconds_between_packets*1000) +",
          "4323:                                    (nseconds_between_packets / 1000000);",
          "4327:  return result;",
          "",
          "[Added Lines]",
          "3873:     proto_tree *raw_tree = NULL;",
          "3874:     proto_item *ti = NULL;",
          "3875:     int next_offset, linelen, end_offset;",
          "3876:     char *str;",
          "3878:     if (tree) {",
          "3879:         ti = proto_tree_add_item(tree, proto_raw_sip, tvb, offset, length, ENC_NA);",
          "3880:         raw_tree = proto_item_add_subtree(ti, ett_raw_text);",
          "3881:     }",
          "3883:     end_offset = offset + length;",
          "3885:     while (offset < end_offset) {",
          "3886:         tvb_find_line_end(tvb, offset, -1, &next_offset, FALSE);",
          "3887:         linelen = next_offset - offset;",
          "3888:         if (raw_tree) {",
          "3889:             if (global_sip_raw_text_without_crlf)",
          "3890:                 str = tvb_format_text_wsp(tvb, offset, linelen);",
          "3891:             else",
          "3892:                 str = tvb_format_text(tvb, offset, linelen);",
          "3893:             proto_tree_add_string_format(raw_tree, hf_sip_raw_line, tvb, offset, linelen,",
          "3894:                              str,",
          "3895:                              \"%s\",",
          "3896:                              str);",
          "3897:         }",
          "3898:         offset = next_offset;",
          "3899:     }",
          "3905:             gchar *cseq_method,",
          "3906:             gchar *call_id,",
          "3907:             guchar cseq_number_set,",
          "3908:             guint32 cseq_number, line_type_t line_type)",
          "3910:     guint32 cseq_to_compare = 0;",
          "3911:     sip_hash_key   key;",
          "3912:     sip_hash_key   *p_key = 0;",
          "3913:     sip_hash_value *p_val = 0;",
          "3914:     sip_frame_result_value *sip_frame_result = NULL;",
          "3915:     guint result = 0;",
          "3918:     if (pinfo->ptype != PT_UDP)",
          "3919:     {",
          "3920:         return 0;",
          "3921:     }",
          "3925:     if (pinfo->flags.in_error_pkt)",
          "3926:     {",
          "3927:         return 0;",
          "3928:     }",
          "3932:     if (!cseq_number_set)",
          "3933:     {",
          "3934:         return 0;",
          "3935:     }",
          "3938:     if (pinfo->fd->flags.visited)",
          "3939:     {",
          "3940:         sip_frame_result = (sip_frame_result_value*)p_get_proto_data(wmem_file_scope(), pinfo, proto_sip, pinfo->curr_layer_num);",
          "3941:         if (sip_frame_result != NULL)",
          "3942:         {",
          "3943:             return sip_frame_result->original_frame_num;",
          "3944:         }",
          "3945:         else",
          "3946:         {",
          "3947:             return 0;",
          "3948:         }",
          "3949:     }",
          "3954:     g_strlcpy(key.call_id, call_id, MAX_CALL_ID_SIZE);",
          "3959:     SET_ADDRESS(&key.dest_address, pinfo->net_dst.type, pinfo->net_dst.len,",
          "3960:             pinfo->net_dst.data);",
          "3961:     SET_ADDRESS(&key.source_address, pinfo->net_src.type,",
          "3962:             pinfo->net_src.len, pinfo->net_src.data);",
          "3963:     key.dest_port = pinfo->destport;",
          "3964:     if (sip_retrans_the_same_sport) {",
          "3965:         key.source_port = pinfo->srcport;",
          "3966:     } else {",
          "3967:         key.source_port = MAGIC_SOURCE_PORT;",
          "3968:     }",
          "3971:     p_val = (sip_hash_value*)g_hash_table_lookup(sip_hash, &key);",
          "3973:     if (p_val)",
          "3974:     {",
          "3976:         cseq_to_compare = p_val->cseq;",
          "3980:         if (cseq_number != p_val->cseq)",
          "3981:         {",
          "3982:             p_val->cseq = cseq_number;",
          "3983:             g_strlcpy(p_val->method, cseq_method, MAX_CSEQ_METHOD_SIZE);",
          "3984:             p_val->transaction_state = nothing_seen;",
          "3985:             p_val->frame_number = 0;",
          "3986:             if (line_type == REQUEST_LINE)",
          "3987:             {",
          "3988:                 p_val->request_time = pinfo->fd->abs_ts;",
          "3989:             }",
          "3990:         }",
          "3991:     }",
          "3992:     else",
          "3993:     {",
          "3997:         p_key = wmem_new(wmem_file_scope(), sip_hash_key);",
          "3998:         p_val = wmem_new0(wmem_file_scope(), sip_hash_value);",
          "4001:         g_snprintf(p_key->call_id, MAX_CALL_ID_SIZE, \"%s\", call_id);",
          "4002:         SE_COPY_ADDRESS(&(p_key->dest_address), &pinfo->net_dst);",
          "4003:         SE_COPY_ADDRESS(&(p_key->source_address), &pinfo->net_src);",
          "4004:         p_key->dest_port = pinfo->destport;",
          "4005:         if (sip_retrans_the_same_sport) {",
          "4006:             p_key->source_port = pinfo->srcport;",
          "4007:         } else {",
          "4008:             p_key->source_port = MAGIC_SOURCE_PORT;",
          "4009:         }",
          "4011:         p_val->cseq = cseq_number;",
          "4012:         g_strlcpy(p_val->method, cseq_method, MAX_CSEQ_METHOD_SIZE);",
          "4013:         p_val->transaction_state = nothing_seen;",
          "4014:         if (line_type == REQUEST_LINE)",
          "4015:         {",
          "4016:             p_val->request_time = pinfo->fd->abs_ts;",
          "4017:         }",
          "4020:         g_hash_table_insert(sip_hash, p_key, p_val);",
          "4023:         cseq_to_compare = 0;",
          "4024:     }",
          "4033:     if ((line_type == REQUEST_LINE) && (cseq_number == cseq_to_compare) &&",
          "4034:         (p_val->transaction_state == request_seen) &&",
          "4035:         (strcmp(cseq_method, p_val->method) == 0) &&",
          "4036:         (strcmp(cseq_method, \"ACK\") != 0) &&",
          "4037:         (strcmp(cseq_method, \"CANCEL\") != 0))",
          "4038:     {",
          "4039:         result = p_val->frame_number;",
          "4040:     }",
          "4043:     if ((line_type == STATUS_LINE) && (cseq_number == cseq_to_compare) &&",
          "4044:         (p_val->transaction_state == final_response_seen) &&",
          "4045:         (strcmp(cseq_method, p_val->method) == 0) &&",
          "4046:         (stat_info->response_code >= 200) &&",
          "4047:         (stat_info->response_code == p_val->response_code))",
          "4048:     {",
          "4049:         result = p_val->frame_number;",
          "4050:     }",
          "4053:     p_val->cseq = cseq_number;",
          "4055:     switch (line_type)",
          "4056:     {",
          "4057:         case REQUEST_LINE:",
          "4058:             p_val->transaction_state = request_seen;",
          "4059:             if (!result)",
          "4060:             {",
          "4062:                 p_val->frame_number = pinfo->fd->num;",
          "4063:             }",
          "4064:             break;",
          "4065:         case STATUS_LINE:",
          "4066:             if (stat_info->response_code >= 200)",
          "4067:             {",
          "4068:                 p_val->response_code = stat_info->response_code;",
          "4069:                 p_val->transaction_state = final_response_seen;",
          "4070:                 if (!result)",
          "4071:                 {",
          "4073:                     p_val->frame_number = pinfo->fd->num;",
          "4074:                 }",
          "4075:             }",
          "4076:             else",
          "4077:             {",
          "4078:                 p_val->transaction_state = provisional_response_seen;",
          "4079:             }",
          "4080:             break;",
          "4081:         default:",
          "4082:             break;",
          "4083:     }",
          "4085:     sip_frame_result = (sip_frame_result_value *)p_get_proto_data(wmem_file_scope(), pinfo, proto_sip, pinfo->curr_layer_num);",
          "4086:     if (sip_frame_result == NULL)",
          "4087:     {",
          "4088:         sip_frame_result = wmem_new0(wmem_file_scope(), sip_frame_result_value);",
          "4089:         p_add_proto_data(wmem_file_scope(), pinfo, proto_sip, pinfo->curr_layer_num, sip_frame_result);",
          "4090:     }",
          "4093:     sip_frame_result->original_frame_num = result;",
          "4095:     return result;",
          "4102:             gchar *cseq_method,",
          "4103:             gchar *call_id,",
          "4104:             guchar cseq_number_set,",
          "4105:             guint32 cseq_number,",
          "4106:             guint32 *response_time)",
          "4108:     guint32 cseq_to_compare = 0;",
          "4109:     sip_hash_key   key;",
          "4110:     sip_hash_value *p_val = 0;",
          "4111:     sip_frame_result_value *sip_frame_result = NULL;",
          "4112:     guint result = 0;",
          "4113:     gint seconds_between_packets;",
          "4114:     gint nseconds_between_packets;",
          "4117:     if (pinfo->ptype != PT_UDP)",
          "4118:     {",
          "4119:         return 0;",
          "4120:     }",
          "4123:     if (pinfo->flags.in_error_pkt)",
          "4124:     {",
          "4125:         return 0;",
          "4126:     }",
          "4129:     if (!cseq_number_set)",
          "4130:     {",
          "4131:         return 0;",
          "4132:     }",
          "4135:     if (pinfo->fd->flags.visited)",
          "4136:     {",
          "4137:         sip_frame_result = (sip_frame_result_value*)p_get_proto_data(wmem_file_scope(), pinfo, proto_sip, pinfo->curr_layer_num);",
          "4138:         if (sip_frame_result != NULL)",
          "4139:         {",
          "4141:             return sip_frame_result->response_request_frame_num;",
          "4142:         }",
          "4143:         else",
          "4144:         {",
          "4145:             return 0;",
          "4146:         }",
          "4147:     }",
          "4152:     g_strlcpy(key.call_id, call_id, MAX_CALL_ID_SIZE);",
          "4155:     SET_ADDRESS(&key.dest_address, pinfo->net_src.type, pinfo->net_src.len,",
          "4156:             pinfo->net_src.data);",
          "4157:     SET_ADDRESS(&key.source_address, pinfo->net_dst.type, pinfo->net_dst.len,",
          "4158:             pinfo->net_dst.data);",
          "4159:     key.dest_port = pinfo->srcport;",
          "4160:     key.source_port = pinfo->destport;",
          "4163:     p_val = (sip_hash_value*)g_hash_table_lookup(sip_hash, &key);",
          "4165:     if (p_val)",
          "4166:     {",
          "4168:         cseq_to_compare = p_val->cseq;",
          "4169:     }",
          "4170:     else",
          "4171:     {",
          "4173:         return 0;",
          "4174:     }",
          "4179:     if ((cseq_number == cseq_to_compare) &&",
          "4180:         (p_val->transaction_state == request_seen) &&",
          "4181:         (strcmp(cseq_method, p_val->method) == 0))",
          "4182:     {",
          "4183:         result = p_val->frame_number;",
          "4184:     }",
          "4188:     sip_frame_result = (sip_frame_result_value *)p_get_proto_data(wmem_file_scope(), pinfo, proto_sip, pinfo->curr_layer_num);",
          "4189:     if (sip_frame_result == NULL)",
          "4190:     {",
          "4192:         sip_frame_result = wmem_new0(wmem_file_scope(), sip_frame_result_value);",
          "4193:         p_add_proto_data(wmem_file_scope(), pinfo, proto_sip, pinfo->curr_layer_num, sip_frame_result);",
          "4194:     }",
          "4196:     sip_frame_result->response_request_frame_num = result;",
          "4199:     seconds_between_packets = (gint)",
          "4200:         (pinfo->fd->abs_ts.secs - p_val->request_time.secs);",
          "4201:     nseconds_between_packets =",
          "4202:          pinfo->fd->abs_ts.nsecs - p_val->request_time.nsecs;",
          "4203:     sip_frame_result->response_time = (seconds_between_packets*1000) +",
          "4204:                                       (nseconds_between_packets / 1000000);",
          "4207:     return result;",
          "4214:             gchar *cseq_method _U_,",
          "4215:             gchar *call_id,",
          "4216:             guchar cseq_number_set,",
          "4217:             guint32 cseq_number _U_,",
          "4218:             guint32 *response_time)",
          "4221:     guint32 cseq_to_compare = 0;",
          "4223:     sip_hash_key   key;",
          "4224:     sip_hash_value *p_val = 0;",
          "4225:     sip_frame_result_value *sip_frame_result = NULL;",
          "4226:     guint result = 0;",
          "4227:     gint seconds_between_packets;",
          "4228:     gint nseconds_between_packets;",
          "4231:     if (pinfo->ptype != PT_UDP)",
          "4232:     {",
          "4233:         return 0;",
          "4234:     }",
          "4237:     if (pinfo->flags.in_error_pkt)",
          "4238:     {",
          "4239:         return 0;",
          "4240:     }",
          "4243:     if (!cseq_number_set)",
          "4244:     {",
          "4245:         return 0;",
          "4246:     }",
          "4249:     if (pinfo->fd->flags.visited)",
          "4250:     {",
          "4251:         sip_frame_result = (sip_frame_result_value*)p_get_proto_data(wmem_file_scope(), pinfo, proto_sip, pinfo->curr_layer_num);",
          "4252:         if (sip_frame_result != NULL)",
          "4253:         {",
          "4255:             return sip_frame_result->response_request_frame_num;",
          "4256:         }",
          "4257:         else",
          "4258:         {",
          "4259:             return 0;",
          "4260:         }",
          "4261:     }",
          "4266:     g_strlcpy(key.call_id, call_id, MAX_CALL_ID_SIZE);",
          "4269:     SET_ADDRESS(&key.dest_address, pinfo->net_dst.type, pinfo->net_dst.len,",
          "4270:             pinfo->net_dst.data);",
          "4271:     SET_ADDRESS(&key.source_address, pinfo->net_src.type, pinfo->net_src.len,",
          "4272:             pinfo->net_src.data);",
          "4273:     key.dest_port = pinfo->destport;",
          "4274:     key.source_port = pinfo->srcport;",
          "4277:     p_val = (sip_hash_value*)g_hash_table_lookup(sip_hash, &key);",
          "4279:     if (p_val)",
          "4280:     {",
          "4283:         cseq_to_compare = p_val->cseq;",
          "4285:     }",
          "4286:     else",
          "4287:     {",
          "4289:         return 0;",
          "4290:     }",
          "4296:     if ((cseq_number == cseq_to_compare) &&",
          "4297:         (p_val->transaction_state == request_seen) &&",
          "4298:         (strcmp(cseq_method, p_val->method) == 0))",
          "4299:     {",
          "4300:         result = p_val->frame_number;",
          "4301:     }",
          "4304:     result = p_val->frame_number;",
          "4307:     sip_frame_result = (sip_frame_result_value *)p_get_proto_data(wmem_file_scope(), pinfo, proto_sip, pinfo->curr_layer_num);",
          "4308:     if (sip_frame_result == NULL)",
          "4309:     {",
          "4311:         sip_frame_result = wmem_new0(wmem_file_scope(), sip_frame_result_value);",
          "4312:         p_add_proto_data(wmem_file_scope(), pinfo, proto_sip,  pinfo->curr_layer_num, sip_frame_result);",
          "4313:     }",
          "4315:     sip_frame_result->response_request_frame_num = result;",
          "4318:     seconds_between_packets = (gint)",
          "4319:         (pinfo->fd->abs_ts.secs - p_val->request_time.secs);",
          "4320:     nseconds_between_packets =",
          "4321:          pinfo->fd->abs_ts.nsecs - p_val->request_time.nsecs;",
          "4322:     sip_frame_result->response_time = (seconds_between_packets*1000) +",
          "4323:                                       (nseconds_between_packets / 1000000);",
          "4327:     return result;",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "4335:         static hf_register_info hf[] = {",
          "4339:                         FT_STRING, BASE_NONE, NULL, 0,",
          "4340:                         \"Message Header in SIP message\", HFILL }",
          "4341:                 },",
          "4350:                        \"SIP Request-Line\", HFILL }",
          "4351:                 },",
          "4385:                        \"SIP Status-Line\", HFILL }",
          "4386:                 },",
          "4666:         { &hf_header_array[POS_ALLOW],",
          "4671:                 { &hf_header_array[POS_ALLOW_EVENTS],",
          "4676:                 { &hf_header_array[POS_ANSWER_MODE],",
          "4681:                 { &hf_header_array[POS_AUTHENTICATION_INFO],",
          "4686:                 { &hf_header_array[POS_AUTHORIZATION],",
          "4691:                 { &hf_header_array[POS_CALL_ID],",
          "4696:                 { &hf_header_array[POS_CALL_INFO],",
          "4701:                 { &hf_header_array[POS_CONTACT],",
          "4706:                 { &hf_header_array[POS_CONTENT_DISPOSITION],",
          "4711:                 { &hf_header_array[POS_CONTENT_ENCODING],",
          "4716:                 { &hf_header_array[POS_CONTENT_LANGUAGE],",
          "4721:                 { &hf_header_array[POS_CONTENT_LENGTH],",
          "4726:                 { &hf_header_array[POS_CONTENT_TYPE],",
          "4731:                 { &hf_header_array[POS_CSEQ],",
          "4736:                 { &hf_header_array[POS_DATE],",
          "4741:                 { &hf_header_array[POS_ERROR_INFO],",
          "4746:                 { &hf_header_array[POS_EVENT],",
          "4806:         { &hf_header_array[POS_IN_REPLY_TO],",
          "4811:         { &hf_header_array[POS_JOIN],",
          "4816:                 { &hf_header_array[POS_MAX_BREADTH],",
          "4821:         { &hf_header_array[POS_MAX_FORWARDS],",
          "4826:         { &hf_header_array[POS_MIME_VERSION],",
          "4831:         { &hf_header_array[POS_MIN_EXPIRES],",
          "4836:         { &hf_header_array[POS_MIN_SE],",
          "4841:                 { &hf_header_array[POS_ORGANIZATION],",
          "5011:         { &hf_header_array[POS_PROXY_AUTHORIZATION],",
          "5455: };",
          "5458:         static hf_register_info raw_hf[] = {",
          "5464:         }};",
          "5537:                                  \"SIP TLS Port\",",
          "5538:                                  \"SIP Server TLS Port\",",
          "5539:                                  10, &sip_tls_port);",
          "5564:         \"\\\"Allow subdissectors to reassemble TCP streams\\\" in the TCP protocol settings.\",",
          "5589: }",
          "5591: void",
          "5592: proto_reg_handoff_sip(void)",
          "5593: {",
          "5628: }",
          "",
          "[Removed Lines]",
          "4337:   { &hf_sip_msg_hdr,",
          "4338:     { \"Message Header\",           \"sip.msg_hdr\",",
          "4342:   { &hf_sip_Method,",
          "4343:          { \"Method\",   \"sip.Method\",",
          "4344:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4345:    \"SIP Method\", HFILL }",
          "4346:   },",
          "4347:   { &hf_Request_Line,",
          "4348:     { \"Request-Line\",                \"sip.Request-Line\",",
          "4349:      FT_STRING, BASE_NONE,NULL,0x0,",
          "4352:   { &hf_sip_ruri,",
          "4353:     { \"Request-URI\",   \"sip.r-uri\",",
          "4354:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4355:    \"RFC 3261: SIP R-URI\", HFILL }",
          "4356:   },",
          "4357:   { &hf_sip_ruri_user,",
          "4358:     { \"Request-URI User Part\",   \"sip.r-uri.user\",",
          "4359:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4360:    \"RFC 3261: SIP R-URI User\", HFILL }",
          "4361:   },",
          "4362:   { &hf_sip_ruri_host,",
          "4363:     { \"Request-URI Host Part\",   \"sip.r-uri.host\",",
          "4364:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4365:    \"RFC 3261: SIP R-URI Host\", HFILL }",
          "4366:   },",
          "4367:   { &hf_sip_ruri_port,",
          "4368:     { \"Request-URI Host Port\",   \"sip.r-uri.port\",",
          "4369:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4370:    \"RFC 3261: SIP R-URI Port\", HFILL }",
          "4371:   },",
          "4372:   { &hf_sip_ruri_param,",
          "4373:     { \"Request URI parameter\",   \"sip.r-uri.param\",",
          "4374:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4375:    NULL, HFILL }",
          "4376:   },",
          "4377:   { &hf_sip_Status_Code,",
          "4378:          { \"Status-Code\",   \"sip.Status-Code\",",
          "4379:          FT_UINT32, BASE_DEC,NULL,0x0,",
          "4380:    \"SIP Status Code\", HFILL }",
          "4381:   },",
          "4382:   { &hf_sip_Status_Line,",
          "4383:          { \"Status-Line\",                 \"sip.Status-Line\",",
          "4384:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4387:   { &hf_sip_display,",
          "4388:    { \"SIP Display info\",   \"sip.display.info\",",
          "4389:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4390:    \"RFC 3261: Display info\", HFILL }",
          "4391:   },",
          "4392:   { &hf_sip_to_addr,",
          "4393:     { \"SIP to address\",   \"sip.to.addr\",",
          "4394:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4395:    \"RFC 3261: To Address\", HFILL }",
          "4396:   },",
          "4397:   { &hf_sip_to_user,",
          "4398:          { \"SIP to address User Part\",   \"sip.to.user\",",
          "4399:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4400:    \"RFC 3261: To Address User\", HFILL }",
          "4401:   },",
          "4402:   { &hf_sip_to_host,",
          "4403:          { \"SIP to address Host Part\",   \"sip.to.host\",",
          "4404:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4405:    \"RFC 3261: To Address Host\", HFILL }",
          "4406:   },",
          "4407:   { &hf_sip_to_port,",
          "4408:          { \"SIP to address Host Port\",   \"sip.to.port\",",
          "4409:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4410:    \"RFC 3261: To Address Port\", HFILL }",
          "4411:   },",
          "4412:   { &hf_sip_to_param,",
          "4413:          { \"SIP To URI parameter\",   \"sip.to.param\",",
          "4414:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4415:    NULL, HFILL }",
          "4416:   },",
          "4417:   { &hf_sip_to_tag,",
          "4418:          { \"SIP to tag\",    \"sip.to.tag\",",
          "4419:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4420:    \"RFC 3261: to tag\", HFILL }",
          "4421:   },",
          "4422:   { &hf_sip_from_addr,",
          "4423:          { \"SIP from address\",   \"sip.from.addr\",",
          "4424:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4425:    \"RFC 3261: From Address\", HFILL }",
          "4426:   },",
          "4427:   { &hf_sip_from_user,",
          "4428:          { \"SIP from address User Part\",   \"sip.from.user\",",
          "4429:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4430:    \"RFC 3261: From Address User\", HFILL }",
          "4431:   },",
          "4432:   { &hf_sip_from_host,",
          "4433:          { \"SIP from address Host Part\",   \"sip.from.host\",",
          "4434:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4435:    \"RFC 3261: From Address Host\", HFILL }",
          "4436:   },",
          "4437:   { &hf_sip_from_port,",
          "4438:          { \"SIP from address Host Port\",   \"sip.from.port\",",
          "4439:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4440:    \"RFC 3261: From Address Port\", HFILL }",
          "4441:   },",
          "4442:   { &hf_sip_from_param,",
          "4443:          { \"SIP From URI parameter\",   \"sip.from.param\",",
          "4444:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4445:    NULL, HFILL }",
          "4446:   },",
          "4447:   { &hf_sip_from_tag,",
          "4448:          { \"SIP from tag\",   \"sip.from.tag\",",
          "4449:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4450:    \"RFC 3261: from tag\", HFILL }",
          "4451:   },",
          "4453:   { &hf_sip_curi,",
          "4454:     { \"Contact URI\",   \"sip.contact.uri\",",
          "4455:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4456:    \"RFC 3261: SIP C-URI\", HFILL }",
          "4457:   },",
          "4458:   { &hf_sip_curi_user,",
          "4459:     { \"Contact URI User Part\",   \"sip.contact.user\",",
          "4460:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4461:    \"RFC 3261: SIP C-URI User\", HFILL }",
          "4462:   },",
          "4463:   { &hf_sip_curi_host,",
          "4464:     { \"Contact URI Host Part\",   \"sip.contact.host\",",
          "4465:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4466:    \"RFC 3261: SIP C-URI Host\", HFILL }",
          "4467:   },",
          "4468:   { &hf_sip_curi_port,",
          "4469:     { \"Contact URI Host Port\",   \"sip.contact.port\",",
          "4470:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4471:    \"RFC 3261: SIP C-URI Port\", HFILL }",
          "4472:   },",
          "4473:   { &hf_sip_curi_param,",
          "4474:     { \"Contact URI parameter\",   \"sip.contact.param\",",
          "4475:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4476:    NULL, HFILL }",
          "4477:   },",
          "4479:   { &hf_sip_route,",
          "4480:     { \"Route URI\",         \"sip.Route.uri\",",
          "4481:          FT_STRING, BASE_NONE,NULL,0x0,NULL,HFILL }",
          "4482:   },",
          "4483:   { &hf_sip_route_user,",
          "4484:     { \"Route Userinfo\",    \"sip.Route.user\",",
          "4485:          FT_STRING, BASE_NONE,NULL,0x0,NULL,HFILL }",
          "4486:   },",
          "4487:   { &hf_sip_route_host,",
          "4488:     { \"Route Host Part\",   \"sip.Route.host\",",
          "4489:          FT_STRING, BASE_NONE,NULL,0x0,NULL,HFILL }",
          "4490:   },",
          "4491:   { &hf_sip_route_port,",
          "4492:     { \"Route Host Port\",   \"sip.Route.port\",",
          "4493:          FT_STRING, BASE_NONE,NULL,0x0,NULL,HFILL }",
          "4494:   },",
          "4495:   { &hf_sip_route_param,",
          "4496:     { \"Route URI parameter\",   \"sip.Route.param\",",
          "4497:          FT_STRING, BASE_NONE,NULL,0x0,NULL,HFILL }",
          "4498:   },",
          "4499:   { &hf_sip_record_route,",
          "4500:     { \"Record-Route URI\",         \"sip.Record-Route.uri\",",
          "4501:          FT_STRING, BASE_NONE,NULL,0x0,NULL,HFILL }",
          "4502:   },",
          "4503:   { &hf_sip_record_route_user,",
          "4504:     { \"Record-Route Userinfo\",    \"sip.Record-Route.user\",",
          "4505:          FT_STRING, BASE_NONE,NULL,0x0,NULL,HFILL }",
          "4506:   },",
          "4507:   { &hf_sip_record_route_host,",
          "4508:     { \"Record-Route Host Part\",   \"sip.Record-Route.host\",",
          "4509:          FT_STRING, BASE_NONE,NULL,0x0,NULL,HFILL }",
          "4510:   },",
          "4511:   { &hf_sip_record_route_port,",
          "4512:     { \"Record-Route Host Port\",   \"sip.Record-Route.port\",",
          "4513:          FT_STRING, BASE_NONE,NULL,0x0,NULL,HFILL }",
          "4514:   },",
          "4515:   { &hf_sip_record_route_param,",
          "4516:     { \"Record-Route URI parameter\",   \"sip.Record-Route.param\",",
          "4517:          FT_STRING, BASE_NONE,NULL,0x0,NULL,HFILL }",
          "4518:   },",
          "4520:   { &hf_sip_contact_param,",
          "4521:          { \"Contact parameter\",   \"sip.contact.parameter\",",
          "4522:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4523:    \"RFC 3261: one contact parameter\", HFILL }",
          "4524:   },",
          "4525:   { &hf_sip_tag,",
          "4526:          { \"SIP tag\",   \"sip.tag\",",
          "4527:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4528:    \"RFC 3261: tag\", HFILL }",
          "4529:   },",
          "4530:   { &hf_sip_pai_addr,",
          "4531:          { \"SIP PAI Address\",   \"sip.pai.addr\",",
          "4532:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4533:    \"RFC 3325: P-Asserted-Identity Address\", HFILL }",
          "4534:   },",
          "4535:   { &hf_sip_pai_user,",
          "4536:          { \"SIP PAI User Part\",   \"sip.pai.user\",",
          "4537:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4538:    \"RFC 3325: P-Asserted-Identity User\", HFILL }",
          "4539:   },",
          "4540:   { &hf_sip_pai_host,",
          "4541:          { \"SIP PAI Host Part\",   \"sip.pai.host\",",
          "4542:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4543:    \"RFC 3325: P-Asserted-Identity Host\", HFILL }",
          "4544:   },",
          "4545:   { &hf_sip_pai_port,",
          "4546:          { \"SIP PAI Host Port\",   \"sip.pai.port\",",
          "4547:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4548:    \"RFC 3325: P-Asserted-Identity Port\", HFILL }",
          "4549:   },",
          "4550:   { &hf_sip_pai_param,",
          "4551:          { \"SIP PAI URI parameter\",   \"sip.pai.param\",",
          "4552:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4553:    NULL, HFILL }",
          "4554:   },",
          "4555:   { &hf_sip_pmiss_addr,",
          "4556:          { \"SIP PMISS Address\",   \"sip.pmiss.addr\",",
          "4557:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4558:    \"RFC 3325: Permission Missing Address\", HFILL }",
          "4559:   },",
          "4560:   { &hf_sip_pmiss_user,",
          "4561:          { \"SIP PMISS User Part\",  \"sip.pmiss.user\",",
          "4562:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4563:    \"RFC 3325: Permission Missing User\", HFILL }",
          "4564:   },",
          "4565:   { &hf_sip_pmiss_host,",
          "4566:          { \"SIP PMISS Host Part\",  \"sip.pmiss.host\",",
          "4567:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4568:    \"RFC 3325: Permission Missing Host\", HFILL }",
          "4569:   },",
          "4570:   { &hf_sip_pmiss_port,",
          "4571:          { \"SIP PMISS Host Port\",  \"sip.pmiss.port\",",
          "4572:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4573:    \"RFC 3325: Permission Missing Port\", HFILL }",
          "4574:   },",
          "4575:   { &hf_sip_pmiss_param,",
          "4576:          { \"SIP PMISS URI parameter\",  \"sip.pmiss.param\",",
          "4577:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4578:    NULL, HFILL }",
          "4579:   },",
          "4581:   { &hf_sip_ppi_addr,",
          "4582:          { \"SIP PPI Address\",   \"sip.ppi.addr\",",
          "4583:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4584:    \"RFC 3325: P-Preferred-Identity Address\", HFILL }",
          "4585:   },",
          "4586:   { &hf_sip_ppi_user,",
          "4587:          { \"SIP PPI User Part\",   \"sip.ppi.user\",",
          "4588:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4589:    \"RFC 3325: P-Preferred-Identity User\", HFILL }",
          "4590:   },",
          "4591:   { &hf_sip_ppi_host,",
          "4592:          { \"SIP PPI Host Part\",   \"sip.ppi.host\",",
          "4593:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4594:    \"RFC 3325: P-Preferred-Identity Host\", HFILL }",
          "4595:   },",
          "4596:   { &hf_sip_ppi_port,",
          "4597:          { \"SIP PPI Host Port\",   \"sip.ppi.port\",",
          "4598:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4599:    \"RFC 3325: P-Preferred-Identity Port\", HFILL }",
          "4600:   },",
          "4601:   { &hf_sip_ppi_param,",
          "4602:          { \"SIP PPI URI parameter\",   \"sip.ppi.param\",",
          "4603:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4604:    NULL, HFILL }",
          "4605:   },",
          "4606:   { &hf_sip_tc_addr,",
          "4607:          { \"SIP TC Address\",   \"sip.tc.addr\",",
          "4608:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4609:    \"RFC 3325: Trigger Consent Address\", HFILL }",
          "4610:   },",
          "4611:   { &hf_sip_tc_user,",
          "4612:          { \"SIP TC User Part\",   \"sip.tc.user\",",
          "4613:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4614:    \"RFC 3325: Trigger Consent User\", HFILL }",
          "4615:   },",
          "4616:   { &hf_sip_tc_host,",
          "4617:          { \"SIP TC Host Part\",   \"sip.tc.host\",",
          "4618:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4619:    \"RFC 3325: Trigger Consent Host\", HFILL }",
          "4620:   },",
          "4621:   { &hf_sip_tc_port,",
          "4622:          { \"SIP TC Host Port\",   \"sip.tc.port\",",
          "4623:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4624:    \"RFC 3325: Trigger Consent Port\", HFILL }",
          "4625:   },",
          "4626:   { &hf_sip_tc_param,",
          "4627:          { \"SIP TC URI parameter\",   \"sip.tc.param\",",
          "4628:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4629:    NULL, HFILL }",
          "4630:   },",
          "4631:   { &hf_sip_tc_turi,",
          "4632:          { \"SIP TC Target URI\",   \"sip.tc.target-uri\",",
          "4633:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4634:    \"RFC 3325: Trigger Consent Target URI\", HFILL }",
          "4635:   },",
          "4636:   { &hf_header_array[POS_ACCEPT],",
          "4637:          { \"Accept\",   \"sip.Accept\",",
          "4638:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4639:    \"RFC 3261: Accept Header\", HFILL }",
          "4640:   },",
          "4641:   { &hf_header_array[POS_ACCEPT_CONTACT],",
          "4642:          { \"Accept-Contact\",   \"sip.Accept-Contact\",",
          "4643:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4644:    \"RFC 3841: Accept-Contact Header\", HFILL }",
          "4645:   },",
          "4646:   { &hf_header_array[POS_ACCEPT_ENCODING],",
          "4647:          { \"Accept-Encoding\",   \"sip.Accept-Encoding\",",
          "4648:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4649:    \"RFC 3841: Accept-Encoding Header\", HFILL }",
          "4650:   },",
          "4651:   { &hf_header_array[POS_ACCEPT_LANGUAGE],",
          "4652:          { \"Accept-Language\",   \"sip.Accept-Language\",",
          "4653:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4654:    \"RFC 3261: Accept-Language Header\", HFILL }",
          "4655:   },",
          "4656:   { &hf_header_array[POS_ACCEPT_RESOURCE_PRIORITY],",
          "4657:          { \"Accept-Resource-Priority\",   \"sip.Accept-Resource-Priority\",",
          "4658:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4659:    \"Draft: Accept-Resource-Priority Header\", HFILL }",
          "4660:   },",
          "4661:   { &hf_header_array[POS_ALERT_INFO],",
          "4662:          { \"Alert-Info\",   \"sip.Alert-Info\",",
          "4663:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4664:    \"RFC 3261: Alert-Info Header\", HFILL }",
          "4665:   },",
          "4667:          { \"Allow\",   \"sip.Allow\",",
          "4668:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4669:    \"RFC 3261: Allow Header\", HFILL }",
          "4670:   },",
          "4672:          { \"Allow-Events\",   \"sip.Allow-Events\",",
          "4673:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4674:    \"RFC 3265: Allow-Events Header\", HFILL }",
          "4675:   },",
          "4677:          { \"Answer-Mode\",   \"sip.Answer-Mode\",",
          "4678:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4679:    \"RFC 5373: Answer-Mode Header\", HFILL }",
          "4680:   },",
          "4682:          { \"Authentication-Info\",   \"sip.Authentication-Info\",",
          "4683:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4684:    \"RFC 3261: Authentication-Info Header\", HFILL }",
          "4685:   },",
          "4687:          { \"Authorization\",   \"sip.Authorization\",",
          "4688:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4689:    \"RFC 3261: Authorization Header\", HFILL }",
          "4690:   },",
          "4692:          { \"Call-ID\",   \"sip.Call-ID\",",
          "4693:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4694:    \"RFC 3261: Call-ID Header\", HFILL }",
          "4695:   },",
          "4697:          { \"Call-Info\",   \"sip.Call-Info\",",
          "4698:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4699:    \"RFC 3261: Call-Info Header\", HFILL }",
          "4700:   },",
          "4702:          { \"Contact\",   \"sip.Contact\",",
          "4703:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4704:    \"RFC 3261: Contact Header\", HFILL }",
          "4705:   },",
          "4707:          { \"Content-Disposition\",   \"sip.Content-Disposition\",",
          "4708:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4709:    \"RFC 3261: Content-Disposition Header\", HFILL }",
          "4710:   },",
          "4712:          { \"Content-Encoding\",   \"sip.Content-Encoding\",",
          "4713:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4714:    \"RFC 3261: Content-Encoding Header\", HFILL }",
          "4715:   },",
          "4717:          { \"Content-Language\",   \"sip.Content-Language\",",
          "4718:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4719:    \"RFC 3261: Content-Language Header\", HFILL }",
          "4720:   },",
          "4722:          { \"Content-Length\",   \"sip.Content-Length\",",
          "4723:          FT_UINT32, BASE_DEC,NULL,0x0,",
          "4724:    \"RFC 3261: Content-Length Header\", HFILL }",
          "4725:   },",
          "4727:          { \"Content-Type\",   \"sip.Content-Type\",",
          "4728:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4729:    \"RFC 3261: Content-Type Header\", HFILL }",
          "4730:   },",
          "4732:          { \"CSeq\",   \"sip.CSeq\",",
          "4733:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4734:    \"RFC 3261: CSeq Header\", HFILL }",
          "4735:   },",
          "4737:          { \"Date\",   \"sip.Date\",",
          "4738:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4739:    \"RFC 3261: Date Header\", HFILL }",
          "4740:   },",
          "4742:          { \"Error-Info\",   \"sip.Error-Info\",",
          "4743:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4744:    \"RFC 3261: Error-Info Header\", HFILL }",
          "4745:   },",
          "4747:          { \"Event\",   \"sip.Event\",",
          "4748:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4749:    \"RFC 3265: Event Header\", HFILL }",
          "4750:   },",
          "4751:   { &hf_header_array[POS_EXPIRES],",
          "4752:          { \"Expires\",   \"sip.Expires\",",
          "4753:          FT_UINT32, BASE_DEC,NULL,0x0,",
          "4754:    \"RFC 3261: Expires Header\", HFILL }",
          "4755:   },",
          "4756:   { &hf_header_array[POS_FEATURE_CAPS],",
          "4757:          { \"Feature-Caps\",   \"sip.feature_caps\",",
          "4758:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4759:    \"RFC 6809: Feature-Caps\", HFILL }",
          "4760:   },",
          "4761:   { &hf_header_array[POS_FLOW_TIMER],",
          "4762:          { \"Flow-Timer\",   \"sip.Flow-Timer\",",
          "4763:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4764:    \"RFC 5626: Flow-Timer\", HFILL }",
          "4765:   },",
          "4766:   { &hf_header_array[POS_FROM],",
          "4767:          { \"From\",   \"sip.From\",",
          "4768:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4769:    \"RFC 3261: From Header\", HFILL }",
          "4770:   },",
          "4771:   { &hf_header_array[POS_GEOLOCATION],",
          "4772:          { \"Geolocation\",   \"sip.Geolocation\",",
          "4773:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4774:    NULL, HFILL }",
          "4775:   },",
          "4776:   { &hf_header_array[POS_GEOLOCATION_ERROR],",
          "4777:          { \"Geolocation-Error\",   \"sip.Geolocation\",",
          "4778:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4779:    NULL, HFILL }",
          "4780:   },",
          "4781:   { &hf_header_array[POS_GEOLOCATION_ROUTING],",
          "4782:          { \"Geolocation-Routing\",   \"sip.Geolocation_Routing\",",
          "4783:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4784:    NULL, HFILL }",
          "4785:   },",
          "4786:   { &hf_header_array[POS_HISTORY_INFO],",
          "4787:    { \"History-Info\",    \"sip.History-Info\",",
          "4788:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4789:    \"RFC 4244: Request History Information\", HFILL }",
          "4790:   },",
          "4791:   { &hf_header_array[POS_IDENTITY],",
          "4792:    { \"Identity\",    \"sip.Identity\",",
          "4793:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4794:    \"RFC 4474: Request Identity\", HFILL }",
          "4795:   },",
          "4796:   { &hf_header_array[POS_IDENTITY_INFO],",
          "4797:    { \"Identity-info\",    \"sip.Identity-info\",",
          "4798:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4799:    \"RFC 4474: Request Identity-info\", HFILL }",
          "4800:   },",
          "4801:   { &hf_header_array[POS_INFO_PKG],",
          "4802:    { \"Info-Package\",    \"sip.Info-Package\",",
          "4803:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4804:    NULL, HFILL }",
          "4805:   },",
          "4807:          { \"In-Reply-To\",   \"sip.In-Reply-To\",",
          "4808:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4809:    \"RFC 3261: In-Reply-To Header\", HFILL }",
          "4810:   },",
          "4812:          { \"Join\",   \"sip.Join\",",
          "4813:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4814:    \"Draft: Join Header\", HFILL }",
          "4815:   },",
          "4817:          { \"Max-Breadth\",  \"sip.Max-Breadth\",",
          "4818:          FT_UINT32, BASE_DEC,NULL,0x0,",
          "4819:    \"RFC 5393: Max-Breadth Header\", HFILL }",
          "4820:   },",
          "4822:          { \"Max-Forwards\",   \"sip.Max-Forwards\",",
          "4823:          FT_UINT32, BASE_DEC,NULL,0x0,",
          "4824:    \"RFC 3261: Max-Forwards Header\", HFILL }",
          "4825:   },",
          "4827:          { \"MIME-Version\",   \"sip.MIME-Version\",",
          "4828:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4829:    \"RFC 3261: MIME-Version Header\", HFILL }",
          "4830:   },",
          "4832:          { \"Min-Expires\",   \"sip.Min-Expires\",",
          "4833:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4834:    \"RFC 3261: Min-Expires Header\", HFILL }",
          "4835:   },",
          "4837:          { \"Min-SE\",   \"sip.Min-SE\",",
          "4838:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4839:    \"Draft: Min-SE Header\", HFILL }",
          "4840:   },",
          "4842:          { \"Organization\",   \"sip.Organization\",",
          "4843:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4844:    \"RFC 3261: Organization Header\", HFILL }",
          "4845:   },",
          "4846:   { &hf_header_array[POS_P_ACCESS_NETWORK_INFO],",
          "4847:          { \"P-Access-Network-Info\", \"sip.P-Access-Network-Info\",",
          "4848:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4849:    \"P-Access-Network-Info Header\", HFILL }",
          "4850:   },",
          "4851:   { &hf_header_array[POS_P_ANSWER_STATE],",
          "4852:          { \"P-Answer-State\",  \"sip.P-Answer-State\",",
          "4853:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4854:    \"RFC 4964: P-Answer-State Header\", HFILL }",
          "4855:   },",
          "4856:   { &hf_header_array[POS_P_ASSERTED_IDENTITY],",
          "4857:          { \"P-Asserted-Identity\",  \"sip.P-Asserted-Identity\",",
          "4858:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4859:    \"RFC 3325: P-Asserted-Identity Header\", HFILL }",
          "4860:   },",
          "4861:   { &hf_header_array[POS_P_ASSERTED_SERV],",
          "4862:          { \"P-Asserted-Service\",  \"sip.P-Asserted-Service\",",
          "4863:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4864:    NULL, HFILL }",
          "4865:   },",
          "4866:   { &hf_header_array[POS_P_ASSOCIATED_URI],",
          "4867:          { \"P-Associated-URI\",   \"sip.P-Associated-URI\",",
          "4868:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4869:    \"RFC 3455: P-Associated-URI Header\", HFILL }",
          "4870:   },",
          "4872:   { &hf_header_array[POS_P_CALLED_PARTY_ID],",
          "4873:          { \"P-Called-Party-ID\",   \"sip.P-Called-Party-ID\",",
          "4874:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4875:    \"RFC 3455: P-Called-Party-ID Header\", HFILL }",
          "4876:   },",
          "4878:   { &hf_header_array[POS_P_CHARGING_FUNC_ADDRESSES],",
          "4879:          { \"P-Charging-Function-Addresses\",\"sip.P-Charging-Function-Addresses\",",
          "4880:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4881:    NULL, HFILL }",
          "4882:   },",
          "4884:   { &hf_header_array[POS_P_CHARGING_VECTOR],",
          "4885:          { \"P-Charging-Vector\",   \"sip.P-Charging-Vector\",",
          "4886:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4887:    \"P-Charging-Vector Header\", HFILL }",
          "4888:   },",
          "4890:   { &hf_header_array[POS_P_DCS_TRACE_PARTY_ID],",
          "4891:          { \"P-DCS-Trace-Party-ID\",  \"sip.P-DCS-Trace-Party-ID\",",
          "4892:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4893:    \"P-DCS-Trace-Party-ID Header\", HFILL }",
          "4894:   },",
          "4896:   { &hf_header_array[POS_P_DCS_OSPS],",
          "4897:          { \"P-DCS-OSPS\",    \"sip.P-DCS-OSPS\",",
          "4898:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4899:    \"P-DCS-OSPS Header\", HFILL }",
          "4900:   },",
          "4902:   { &hf_header_array[POS_P_DCS_BILLING_INFO],",
          "4903:          { \"P-DCS-Billing-Info\",   \"sip.P-DCS-Billing-Info\",",
          "4904:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4905:    \"P-DCS-Billing-Info Header\", HFILL }",
          "4906:   },",
          "4908:   { &hf_header_array[POS_P_DCS_LAES],",
          "4909:          { \"P-DCS-LAES\",    \"sip.P-DCS-LAES\",",
          "4910:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4911:    \"P-DCS-LAES Header\", HFILL }",
          "4912:   },",
          "4914:   { &hf_header_array[POS_P_DCS_REDIRECT],",
          "4915:          { \"P-DCS-Redirect\",   \"sip.P-DCS-Redirect\",",
          "4916:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4917:    \"P-DCS-Redirect Header\", HFILL }",
          "4918:   },",
          "4920:   { &hf_header_array[POS_P_EARLY_MEDIA],",
          "4921:          { \"P-Early-Media\",   \"sip.P-Early-Media\",",
          "4922:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4923:    \"P-Early-Media Header\", HFILL }",
          "4924:   },",
          "4926:   { &hf_header_array[POS_P_MEDIA_AUTHORIZATION],",
          "4927:          { \"P-Media-Authorization\",  \"sip.P-Media-Authorization\",",
          "4928:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4929:       \"RFC 3313: P-Media-Authorization Header\", HFILL }",
          "4930:   },",
          "4932:   { &hf_header_array[POS_P_PREFERRED_IDENTITY],",
          "4933:          { \"P-Preferred-Identity\",   \"sip.P-Preferred-Identity\",",
          "4934:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4935:    \"RFC 3325: P-Preferred-Identity Header\", HFILL }",
          "4936:   },",
          "4937:   { &hf_header_array[POS_P_PREFERRED_SERV],",
          "4938:          { \"P-Preferred-Service\",   \"sip.P-Preferred-Service\",",
          "4939:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4940:    NULL, HFILL }",
          "4941:   },",
          "4942:   { &hf_header_array[POS_P_PROFILE_KEY],",
          "4943:          { \"P-Profile-Key\",   \"sip.P-Profile-Key\",",
          "4944:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4945:    \"P-Profile-Key Header\", HFILL }",
          "4946:   },",
          "4947:   { &hf_header_array[POS_P_REFUSED_URI_LST],",
          "4948:          { \"P-Refused-URI-List\",   \"sip.P-Refused-URI-List\",",
          "4949:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4950:    \"P-Refused-URI-List Header\", HFILL }",
          "4951:   },",
          "4952:   { &hf_header_array[POS_P_SERVED_USER],",
          "4953:          { \"P-Served-User\",   \"sip.P-Served-User\",",
          "4954:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4955:    NULL, HFILL }",
          "4956:   },",
          "4957:   { &hf_header_array[POS_P_USER_DATABASE],",
          "4958:          { \"P-User-Database\",   \"sip.P-User-Database\",",
          "4959:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4960:    \"P-User-Database Header\", HFILL }",
          "4961:   },",
          "4963:   { &hf_header_array[POS_P_VISITED_NETWORK_ID],",
          "4964:          { \"P-Visited-Network-ID\",  \"sip.P-Visited-Network-ID\",",
          "4965:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4966:       \"RFC 3455: P-Visited-Network-ID Header\", HFILL }",
          "4967:   },",
          "4969:   { &hf_header_array[POS_PATH],",
          "4970:          { \"Path\",    \"sip.Path\",",
          "4971:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4972:       \"RFC 3327: Path Header\", HFILL }",
          "4973:   },",
          "4975:   { &hf_header_array[POS_PERMISSION_MISSING],",
          "4976:          { \"Permission-Missing\",   \"sip.Permission-Missing\",",
          "4977:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4978:       \"RFC 5360: Permission Missing Header\", HFILL }",
          "4979:   },",
          "4980:   { &hf_header_array[POS_POLICY_CONTACT],",
          "4981:          { \"Policy-Contact\",   \"sip.Policy_Contact\",",
          "4982:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4983:       NULL, HFILL }",
          "4984:   },",
          "4985:   { &hf_header_array[POS_POLICY_ID],",
          "4986:          { \"Policy-ID\",   \"sip.Policy_ID\",",
          "4987:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4988:       NULL, HFILL }",
          "4989:   },",
          "4990:   { &hf_header_array[POS_PRIORITY],",
          "4991:          { \"Priority\",   \"sip.Priority\",",
          "4992:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4993:    \"RFC 3261: Priority Header\", HFILL }",
          "4994:   },",
          "4995:   { &hf_header_array[POS_PRIV_ANSWER_MODE],",
          "4996:          { \"Priv-Answer-mode\",  \"sip.Priv-Answer-mode\",",
          "4997:          FT_STRING, BASE_NONE,NULL,0x0,",
          "4998:    NULL, HFILL }",
          "4999:   },",
          "5000:   { &hf_header_array[POS_PRIVACY],",
          "5001:          { \"Privacy\",    \"sip.Privacy\",",
          "5002:          FT_STRING, BASE_NONE,NULL,0x0,",
          "5003:    \"Privacy Header\", HFILL }",
          "5004:   },",
          "5006:   { &hf_header_array[POS_PROXY_AUTHENTICATE],",
          "5007:          { \"Proxy-Authenticate\",   \"sip.Proxy-Authenticate\",",
          "5008:          FT_STRING, BASE_NONE,NULL,0x0,",
          "5009:    \"RFC 3261: Proxy-Authenticate Header\", HFILL }",
          "5010:   },",
          "5012:          { \"Proxy-Authorization\",   \"sip.Proxy-Authorization\",",
          "5013:          FT_STRING, BASE_NONE,NULL,0x0,",
          "5014:    \"RFC 3261: Proxy-Authorization Header\", HFILL }",
          "5015:   },",
          "5017:   { &hf_header_array[POS_PROXY_REQUIRE],",
          "5018:          { \"Proxy-Require\",   \"sip.Proxy-Require\",",
          "5019:          FT_STRING, BASE_NONE,NULL,0x0,",
          "5020:    \"RFC 3261: Proxy-Require Header\", HFILL }",
          "5021:   },",
          "5022:   { &hf_header_array[POS_RACK],",
          "5023:          { \"RAck\",   \"sip.RAck\",",
          "5024:          FT_STRING, BASE_NONE,NULL,0x0,",
          "5025:    \"RFC 3262: RAck Header\", HFILL }",
          "5026:   },",
          "5027:   { &hf_header_array[POS_REASON],",
          "5028:          { \"Reason\",    \"sip.Reason\",",
          "5029:          FT_STRING, BASE_NONE,NULL,0x0,",
          "5030:    \"RFC 3326 Reason Header\", HFILL }",
          "5031:   },",
          "5032:   { &hf_header_array[POS_REASON_PHRASE],",
          "5033:          { \"Reason-Phrase\",    \"sip.Reason-Phrase\",",
          "5034:          FT_STRING, BASE_NONE,NULL,0x0,",
          "5035:    NULL, HFILL }",
          "5036:   },",
          "5037:   { &hf_header_array[POS_RECORD_ROUTE],",
          "5038:          { \"Record-Route\",   \"sip.Record-Route\",",
          "5039:          FT_STRING, BASE_NONE,NULL,0x0,",
          "5040:    \"RFC 3261: Record-Route Header\", HFILL }",
          "5041:   },",
          "5042:   { &hf_header_array[POS_RECV_INFO],",
          "5043:          { \"Recv-Info\",   \"sip.Recv-Info\",",
          "5044:          FT_STRING, BASE_NONE,NULL,0x0,",
          "5045:    NULL, HFILL }",
          "5046:   },",
          "5047:   { &hf_header_array[POS_REFER_SUB],",
          "5048:          { \"Refer-Sub\",   \"sip.Refer-Sub\",",
          "5049:          FT_STRING, BASE_NONE,NULL,0x0,",
          "5050:    \"RFC 4488: Refer-Sub Header\", HFILL }",
          "5051:   },",
          "5052:   { &hf_header_array[POS_REFER_TO],",
          "5053:    { \"Refer-To\",    \"sip.Refer-To\",",
          "5054:          FT_STRING, BASE_NONE,NULL,0x0,",
          "5055:    \"RFC 3515: Refer-To Header\", HFILL }",
          "5056:   },",
          "5057:   { &hf_header_array[POS_REFERED_BY],",
          "5058:          { \"Refered By\",   \"sip.Refered-by\",",
          "5059:          FT_STRING, BASE_NONE,NULL,0x0,",
          "5060:    \"RFC 3892: Refered-by Header\", HFILL }",
          "5061:   },",
          "5062:   { &hf_header_array[POS_REJECT_CONTACT],",
          "5063:    { \"Reject-Contact\",   \"sip.Reject-Contact\",",
          "5064:    FT_STRING, BASE_NONE,NULL,0x0,",
          "5065:    \"RFC 3841: Reject-Contact Header\", HFILL }",
          "5066:   },",
          "5067:   { &hf_header_array[POS_REPLACES],",
          "5068:    { \"Replaces\",   \"sip.Replaces\",",
          "5069:    FT_STRING, BASE_NONE,NULL,0x0,",
          "5070:    \"RFC 3891: Replaces Header\", HFILL }",
          "5071:   },",
          "5072:   { &hf_header_array[POS_REPLY_TO],",
          "5073:          { \"Reply-To\",   \"sip.Reply-To\",",
          "5074:          FT_STRING, BASE_NONE,NULL,0x0,",
          "5075:    \"RFC 3261: Reply-To Header\", HFILL }",
          "5076:   },",
          "5077:   { &hf_header_array[POS_REQUEST_DISPOSITION],",
          "5078:          { \"Request-Disposition\",  \"sip.Request-Disposition\",",
          "5079:          FT_STRING, BASE_NONE,NULL,0x0,",
          "5080:    \"RFC 3841: Request-Disposition Header\", HFILL }",
          "5081:   },",
          "5082:   { &hf_header_array[POS_REQUIRE],",
          "5083:    { \"Require\",   \"sip.Require\",",
          "5084:          FT_STRING, BASE_NONE,NULL,0x0,",
          "5085:    \"RFC 3261: Require Header\", HFILL }",
          "5086:   },",
          "5087:   { &hf_header_array[POS_RESOURCE_PRIORITY],",
          "5088:    { \"Resource-Priority\",   \"sip.Resource-Priority\",",
          "5089:          FT_STRING, BASE_NONE,NULL,0x0,",
          "5090:    \"Draft: Resource-Priority Header\", HFILL }",
          "5091:   },",
          "5092:   { &hf_header_array[POS_RETRY_AFTER],",
          "5093:    { \"Retry-After\",   \"sip.Retry-After\",",
          "5094:          FT_STRING, BASE_NONE,NULL,0x0,",
          "5095:    \"RFC 3261: Retry-After Header\", HFILL }",
          "5096:   },",
          "5097:   { &hf_header_array[POS_ROUTE],",
          "5098:          { \"Route\",   \"sip.Route\",",
          "5099:          FT_STRING, BASE_NONE,NULL,0x0,",
          "5100:    \"RFC 3261: Route Header\", HFILL }",
          "5101:   },",
          "5102:   { &hf_header_array[POS_RSEQ],",
          "5103:          { \"RSeq\",   \"sip.RSeq\",",
          "5104:          FT_UINT32, BASE_DEC,NULL,0x0,",
          "5105:    \"RFC 3262: RSeq Header\", HFILL }",
          "5106:   },",
          "5107:   { &hf_header_array[ POS_SECURITY_CLIENT],",
          "5108:          { \"Security-Client\",   \"sip.Security-Client\",",
          "5109:          FT_STRING, BASE_NONE,NULL,0x0,",
          "5110:    \"RFC 3329 Security-Client Header\", HFILL }",
          "5111:   },",
          "5112:   { &hf_header_array[ POS_SECURITY_SERVER],",
          "5113:          { \"Security-Server\",   \"sip.Security-Server\",",
          "5114:          FT_STRING, BASE_NONE,NULL,0x0,",
          "5115:    \"RFC 3329 Security-Server Header\", HFILL }",
          "5116:   },",
          "5117:   { &hf_header_array[ POS_SECURITY_VERIFY],",
          "5118:          { \"Security-Verify\",   \"sip.Security-Verify\",",
          "5119:          FT_STRING, BASE_NONE,NULL,0x0,",
          "5120:    \"RFC 3329 Security-Verify Header\", HFILL }",
          "5121:   },",
          "5122:   { &hf_header_array[POS_SERVER],",
          "5123:    { \"Server\",   \"sip.Server\",",
          "5124:          FT_STRING, BASE_NONE,NULL,0x0,",
          "5125:    \"RFC 3261: Server Header\", HFILL }",
          "5126:   },",
          "5127:   { &hf_header_array[POS_SERVICE_ROUTE],",
          "5128:          { \"Service-Route\",   \"sip.Service-Route\",",
          "5129:          FT_STRING, BASE_NONE,NULL,0x0,",
          "5130:    \"RFC 3608: Service-Route Header\", HFILL }",
          "5131:   },",
          "5132:   { &hf_header_array[POS_SESSION_EXPIRES],",
          "5133:          { \"Session-Expires\",   \"sip.Session-Expires\",",
          "5134:          FT_STRING, BASE_NONE,NULL,0x0,",
          "5135:       \"RFC 4028: Session-Expires Header\", HFILL }",
          "5136:   },",
          "5137:   { &hf_header_array[POS_SIP_ETAG],",
          "5138:          { \"ETag\",   \"sip.ETag\",",
          "5139:          FT_STRING, BASE_NONE,NULL,0x0,",
          "5140:       \"RFC 3903: SIP-ETag Header\", HFILL }",
          "5141:   },",
          "5142:   { &hf_header_array[POS_SIP_IF_MATCH],",
          "5143:          { \"If_Match\",   \"sip.If_Match\",",
          "5144:          FT_STRING, BASE_NONE,NULL,0x0,",
          "5145:    \"RFC 3903: SIP-If-Match Header\", HFILL }",
          "5146:   },",
          "5147:   { &hf_header_array[POS_SUBJECT],",
          "5148:          { \"Subject\",   \"sip.Subject\",",
          "5149:          FT_STRING, BASE_NONE,NULL,0x0,",
          "5150:    \"RFC 3261: Subject Header\", HFILL }",
          "5151:   },",
          "5152:   { &hf_header_array[POS_SUBSCRIPTION_STATE],",
          "5153:          { \"Subscription-State\",   \"sip.Subscription-State\",",
          "5154:          FT_STRING, BASE_NONE,NULL,0x0,",
          "5155:    \"RFC 3265: Subscription-State Header\", HFILL }",
          "5156:   },",
          "5157:   { &hf_header_array[POS_SUPPORTED],",
          "5158:    { \"Supported\",   \"sip.Supported\",",
          "5159:          FT_STRING, BASE_NONE,NULL,0x0,",
          "5160:    \"RFC 3261: Supported Header\", HFILL }",
          "5161:   },",
          "5162:   { &hf_header_array[POS_SUPPRESS_IF_MATCH],",
          "5163:    { \"Suppress-If-Match\",   \"sip.Suppress_If_Match\",",
          "5164:          FT_STRING, BASE_NONE,NULL,0x0,",
          "5165:    NULL, HFILL }",
          "5166:   },",
          "5167:   { &hf_header_array[POS_TARGET_DIALOG],",
          "5168:    { \"Target-Dialog\",   \"sip.Target-Dialog\",",
          "5169:          FT_STRING, BASE_NONE,NULL,0x0,",
          "5170:    \"RFC 4538: Target-Dialog Header\", HFILL }",
          "5171:   },",
          "5172:   { &hf_header_array[POS_TIMESTAMP],",
          "5173:    { \"Timestamp\",   \"sip.Timestamp\",",
          "5174:          FT_STRING, BASE_NONE,NULL,0x0,",
          "5175:    \"RFC 3261: Timestamp Header\", HFILL }",
          "5176:   },",
          "5177:   { &hf_header_array[POS_TO],",
          "5178:    { \"To\",   \"sip.To\",",
          "5179:          FT_STRING, BASE_NONE,NULL,0x0,",
          "5180:    \"RFC 3261: To Header\", HFILL }",
          "5181:   },",
          "5183:   { &hf_header_array[POS_TRIGGER_CONSENT],",
          "5184:    { \"Trigger-Consent\",   \"sip.Trigger-Consent\",",
          "5185:          FT_STRING, BASE_NONE,NULL,0x0,",
          "5186:    \"RFC 5380: Trigger Consent\", HFILL }",
          "5187:   },",
          "5189:   { &hf_header_array[POS_UNSUPPORTED],",
          "5190:    { \"Unsupported\",   \"sip.Unsupported\",",
          "5191:          FT_STRING, BASE_NONE,NULL,0x0,",
          "5192:    \"RFC 3261: Unsupported Header\", HFILL }",
          "5193:   },",
          "5194:   { &hf_header_array[POS_USER_AGENT],",
          "5195:    { \"User-Agent\",   \"sip.User-Agent\",",
          "5196:          FT_STRING, BASE_NONE,NULL,0x0,",
          "5197:    \"RFC 3261: User-Agent Header\", HFILL }",
          "5198:   },",
          "5199:   { &hf_header_array[POS_VIA],",
          "5200:    { \"Via\",   \"sip.Via\",",
          "5201:          FT_STRING, BASE_NONE,NULL,0x0,",
          "5202:    \"RFC 3261: Via Header\", HFILL }",
          "5203:   },",
          "5204:   { &hf_header_array[POS_WARNING],",
          "5205:    { \"Warning\",   \"sip.Warning\",",
          "5206:          FT_STRING, BASE_NONE,NULL,0x0,",
          "5207:    \"RFC 3261: Warning Header\", HFILL }",
          "5208:   },",
          "5210:   { &hf_header_array[POS_WWW_AUTHENTICATE],",
          "5211:    { \"WWW-Authenticate\",   \"sip.WWW-Authenticate\",",
          "5212:          FT_STRING, BASE_NONE,NULL,0x0,",
          "5213:    \"RFC 3261: WWW-Authenticate Header\", HFILL }",
          "5214:   },",
          "5215:   { &hf_header_array[POS_DIVERSION],",
          "5216:    { \"Diversion\",   \"sip.Diversion\",",
          "5217:          FT_STRING, BASE_NONE,NULL,0x0,",
          "5218:    \"RFC 5806: Diversion Header\", HFILL }",
          "5219:   },",
          "5220:   { &hf_header_array[POS_USER_TO_USER],",
          "5221:    { \"User-to-User\",  \"sip.uui\",",
          "5222:          FT_STRING, BASE_NONE,NULL,0x0,",
          "5223:    \"draft-johnston-sipping-cc-uui-09: User-to-User header\", HFILL }",
          "5224:   },",
          "5225:   { &hf_sip_resend,",
          "5226:    { \"Resent Packet\", \"sip.resend\",",
          "5227:    FT_BOOLEAN, BASE_NONE, NULL, 0x0,",
          "5228:    NULL, HFILL }",
          "5229:   },",
          "5230:   { &hf_sip_original_frame,",
          "5231:    { \"Suspected resend of frame\",  \"sip.resend-original\",",
          "5232:    FT_FRAMENUM, BASE_NONE, NULL, 0x0,",
          "5233:        \"Original transmission of frame\", HFILL}",
          "5234:   },",
          "5235:   { &hf_sip_matching_request_frame,",
          "5236:    { \"Request Frame\",  \"sip.response-request\",",
          "5237:    FT_FRAMENUM, BASE_NONE, NULL, 0x0,",
          "5238:        NULL, HFILL}",
          "5239:   },",
          "5240:   { &hf_sip_response_time,",
          "5241:    { \"Response Time (ms)\",  \"sip.response-time\",",
          "5242:    FT_UINT32, BASE_DEC, NULL, 0x0,",
          "5243:        \"Response time since original request (in milliseconds)\", HFILL}",
          "5244:   },",
          "5245:   { &hf_sip_release_time,",
          "5246:    { \"Release Time (ms)\",  \"sip.release-time\",",
          "5247:    FT_UINT32, BASE_DEC, NULL, 0x0,",
          "5248:        \"release time since original BYE (in milliseconds)\", HFILL}",
          "5249:   },",
          "5250:   { &hf_sip_auth,",
          "5251:    { \"Authentication\",  \"sip.auth\",",
          "5252:    FT_STRING, BASE_NONE, NULL, 0x0,",
          "5253:        \"SIP Authentication\", HFILL}",
          "5254:   },",
          "5255:   { &hf_sip_auth_scheme,",
          "5256:    { \"Authentication Scheme\",  \"sip.auth.scheme\",",
          "5257:    FT_STRING, BASE_NONE, NULL, 0x0,",
          "5258:        \"SIP Authentication Scheme\", HFILL}",
          "5259:   },",
          "5260:   { &hf_sip_auth_digest_response,",
          "5261:    { \"Digest Authentication Response\",  \"sip.auth.digest.response\",",
          "5262:    FT_STRING, BASE_NONE, NULL, 0x0,",
          "5263:        \"SIP Digest Authentication Response Value\", HFILL}",
          "5264:   },",
          "5265:   { &hf_sip_auth_nc,",
          "5266:    { \"Nonce Count\",  \"sip.auth.nc\",",
          "5267:    FT_STRING, BASE_NONE, NULL, 0x0,",
          "5268:        \"SIP Authentication Nonce count\", HFILL}",
          "5269:   },",
          "5270:   { &hf_sip_auth_username,",
          "5271:    { \"Username\",  \"sip.auth.username\",",
          "5272:    FT_STRING, BASE_NONE, NULL, 0x0,",
          "5273:        \"SIP Authentication Username\", HFILL}",
          "5274:   },",
          "5275:   { &hf_sip_auth_realm,",
          "5276:    { \"Realm\",  \"sip.auth.realm\",",
          "5277:    FT_STRING, BASE_NONE, NULL, 0x0,",
          "5278:        \"SIP Authentication Realm\", HFILL}",
          "5279:   },",
          "5280:   { &hf_sip_auth_nonce,",
          "5281:    { \"Nonce Value\",  \"sip.auth.nonce\",",
          "5282:    FT_STRING, BASE_NONE, NULL, 0x0,",
          "5283:        \"SIP Authentication Nonce\", HFILL}",
          "5284:   },",
          "5285:   { &hf_sip_auth_algorithm,",
          "5286:    { \"Algorithm\",  \"sip.auth.algorithm\",",
          "5287:    FT_STRING, BASE_NONE, NULL, 0x0,",
          "5288:        \"SIP Authentication Algorithm\", HFILL}",
          "5289:   },",
          "5290:   { &hf_sip_auth_opaque,",
          "5291:    { \"Opaque Value\",  \"sip.auth.opaque\",",
          "5292:    FT_STRING, BASE_NONE, NULL, 0x0,",
          "5293:        \"SIP Authentication Opaque value\", HFILL}",
          "5294:   },",
          "5295:   { &hf_sip_auth_qop,",
          "5296:    { \"QOP\",  \"sip.auth.qop\",",
          "5297:    FT_STRING, BASE_NONE, NULL, 0x0,",
          "5298:        \"SIP Authentication QOP\", HFILL}",
          "5299:   },",
          "5300:   { &hf_sip_auth_cnonce,",
          "5301:    { \"CNonce Value\",  \"sip.auth.cnonce\",",
          "5302:    FT_STRING, BASE_NONE, NULL, 0x0,",
          "5303:        \"SIP Authentication Client Nonce\", HFILL}",
          "5304:   },",
          "5305:   { &hf_sip_auth_uri,",
          "5306:    { \"Authentication URI\",  \"sip.auth.uri\",",
          "5307:    FT_STRING, BASE_NONE, NULL, 0x0,",
          "5308:        \"SIP Authentication URI\", HFILL}",
          "5309:   },",
          "5310:   { &hf_sip_auth_domain,",
          "5311:    { \"Authentication Domain\",  \"sip.auth.domain\",",
          "5312:    FT_STRING, BASE_NONE, NULL, 0x0,",
          "5313:        \"SIP Authentication Domain\", HFILL}",
          "5314:   },",
          "5315:   { &hf_sip_auth_stale,",
          "5316:    { \"Stale Flag\",  \"sip.auth.stale\",",
          "5317:    FT_STRING, BASE_NONE, NULL, 0x0,",
          "5318:        \"SIP Authentication Stale Flag\", HFILL}",
          "5319:   },",
          "5320:   { &hf_sip_auth_auts,",
          "5321:    { \"Authentication Token\",  \"sip.auth.auts\",",
          "5322:    FT_STRING, BASE_NONE, NULL, 0x0,",
          "5323:        \"SIP Authentication Token\", HFILL}",
          "5324:   },",
          "5325:   { &hf_sip_auth_rspauth,",
          "5326:    { \"Response auth\",  \"sip.auth.rspauth\",",
          "5327:    FT_STRING, BASE_NONE, NULL, 0x0,",
          "5328:        \"SIP Authentication Response auth\", HFILL}",
          "5329:   },",
          "5330:   { &hf_sip_auth_nextnonce,",
          "5331:    { \"Next Nonce\",  \"sip.auth.nextnonce\",",
          "5332:    FT_STRING, BASE_NONE, NULL, 0x0,",
          "5333:        \"SIP Authentication Next Nonce\", HFILL}",
          "5334:   },",
          "5335:   { &hf_sip_auth_ik,",
          "5336:    { \"Integrity Key\",  \"sip.auth.ik\",",
          "5337:    FT_STRING, BASE_NONE, NULL, 0x0,",
          "5338:        \"SIP Authentication Integrity Key\", HFILL}",
          "5339:   },",
          "5340:   { &hf_sip_auth_ck,",
          "5341:    { \"Cyphering Key\",  \"sip.auth.ck\",",
          "5342:    FT_STRING, BASE_NONE, NULL, 0x0,",
          "5343:        \"SIP Authentication Cyphering Key\", HFILL}",
          "5344:   },",
          "5345:   { &hf_sip_cseq_seq_no,",
          "5346:    { \"Sequence Number\",  \"sip.CSeq.seq\",",
          "5347:    FT_UINT32, BASE_DEC, NULL, 0x0,",
          "5348:        \"CSeq header sequence number\", HFILL}",
          "5349:   },",
          "5350:   { &hf_sip_cseq_method,",
          "5351:    { \"Method\",  \"sip.CSeq.method\",",
          "5352:    FT_STRING, BASE_NONE, NULL, 0x0,",
          "5353:        \"CSeq header method\", HFILL}",
          "5354:   },",
          "5355:   { &hf_sip_via_transport,",
          "5356:    { \"Transport\",  \"sip.Via.transport\",",
          "5357:    FT_STRING, BASE_NONE, NULL, 0x0,",
          "5358:        \"Via header Transport\", HFILL}",
          "5359:   },",
          "5360:   { &hf_sip_via_sent_by_address,",
          "5361:    { \"Sent-by Address\",  \"sip.Via.sent-by.address\",",
          "5362:    FT_STRING, BASE_NONE, NULL, 0x0,",
          "5363:        \"Via header Sent-by Address\", HFILL}",
          "5364:   },",
          "5365:   { &hf_sip_via_sent_by_port,",
          "5366:    { \"Sent-by port\",  \"sip.Via.sent-by.port\",",
          "5367:    FT_UINT16, BASE_DEC, NULL, 0x0,",
          "5368:        \"Via header Sent-by Port\", HFILL}",
          "5369:   },",
          "5370:   { &hf_sip_via_branch,",
          "5371:    { \"Branch\",  \"sip.Via.branch\",",
          "5372:    FT_STRING, BASE_NONE, NULL, 0x0,",
          "5373:        \"SIP Via Branch\", HFILL},",
          "5374:   },",
          "5375:   { &hf_sip_via_maddr,",
          "5376:    { \"Maddr\",  \"sip.Via.maddr\",",
          "5377:    FT_STRING, BASE_NONE, NULL, 0x0,",
          "5378:        \"SIP Via Maddr\", HFILL},",
          "5379:   },",
          "5380:   { &hf_sip_via_rport,",
          "5381:    { \"RPort\",  \"sip.Via.rport\",",
          "5382:    FT_STRING, BASE_NONE, NULL, 0x0,",
          "5383:        \"SIP Via RPort\", HFILL},",
          "5384:   },",
          "5385:   { &hf_sip_via_received,",
          "5386:    { \"Received\",  \"sip.Via.received\",",
          "5387:    FT_STRING, BASE_NONE, NULL, 0x0,",
          "5388:        \"SIP Via Received\", HFILL},",
          "5389:   },",
          "5390:   { &hf_sip_via_ttl,",
          "5391:    { \"TTL\",  \"sip.Via.ttl\",",
          "5392:    FT_STRING, BASE_NONE, NULL, 0x0,",
          "5393:        \"SIP Via TTL\", HFILL}",
          "5394:   },",
          "5395:   { &hf_sip_via_comp,",
          "5396:    { \"Comp\",  \"sip.Via.comp\",",
          "5397:    FT_STRING, BASE_NONE, NULL, 0x0,",
          "5398:        \"SIP Via comp\", HFILL}",
          "5399:   },",
          "5400:   { &hf_sip_via_sigcomp_id,",
          "5401:    { \"Sigcomp identifier\",  \"sip.Via.sigcomp-id\",",
          "5402:    FT_STRING, BASE_NONE, NULL, 0x0,",
          "5403:        \"SIP Via sigcomp identifier\", HFILL}",
          "5404:   },",
          "5405:   { &hf_sip_rack_rseq_no,",
          "5406:    { \"RSeq Sequence Number\",  \"sip.RAck.RSeq.seq\",",
          "5407:    FT_UINT32, BASE_DEC, NULL, 0x0,",
          "5408:        \"RAck RSeq header sequence number (from prov response)\", HFILL}",
          "5409:   },",
          "5410:   { &hf_sip_rack_cseq_no,",
          "5411:    { \"CSeq Sequence Number\",  \"sip.RAck.CSeq.seq\",",
          "5412:    FT_UINT32, BASE_DEC, NULL, 0x0,",
          "5413:        \"RAck CSeq header sequence number (from prov response)\", HFILL}",
          "5414:   },",
          "5415:   { &hf_sip_rack_cseq_method,",
          "5416:    { \"CSeq Method\",  \"sip.RAck.CSeq.method\",",
          "5417:    FT_STRING, BASE_NONE, NULL, 0x0,",
          "5418:        \"RAck CSeq header method (from prov response)\", HFILL}",
          "5419:   },",
          "5420:   { &hf_sip_msg_body,",
          "5421:     { \"Message Body\",           \"sip.msg_body\",",
          "5422:     FT_NONE, BASE_NONE, NULL, 0x0,",
          "5423:     \"Message Body in SIP message\", HFILL }",
          "5424:   },",
          "5425:   { &hf_sip_sec_mechanism,",
          "5426:    { \"[Security-mechanism]\",  \"sip.sec_mechanism\",",
          "5427:    FT_STRING, BASE_NONE, NULL, 0x0,",
          "5428:       NULL, HFILL}",
          "5429:   },",
          "5430:   { &hf_sip_sec_mechanism_alg,",
          "5431:    { \"alg\",  \"sip.sec_mechanism.alg\",",
          "5432:    FT_STRING, BASE_NONE, NULL, 0x0,",
          "5433:       NULL, HFILL}",
          "5434:   },",
          "5435:   { &hf_sip_sec_mechanism_ealg,",
          "5436:    { \"ealg\",  \"sip.sec_mechanism.ealg\",",
          "5437:    FT_STRING, BASE_NONE, NULL, 0x0,",
          "5438:       NULL, HFILL}",
          "5439:   },",
          "5440:   { &hf_sip_sec_mechanism_prot,",
          "5441:    { \"prot\",  \"sip.sec_mechanism.prot\",",
          "5442:    FT_STRING, BASE_NONE, NULL, 0x0,",
          "5443:       NULL, HFILL}",
          "5444:   },",
          "5445:   { &hf_sip_sec_mechanism_spi_c,",
          "5446:    { \"spi-c\",  \"sip.sec_mechanism.spi_c\",",
          "5447:    FT_UINT32, BASE_DEC_HEX, NULL, 0x0,",
          "5448:       NULL, HFILL}",
          "5449:   },",
          "5450:   { &hf_sip_sec_mechanism_spi_s,",
          "5451:    { \"spi-s\",  \"sip.sec_mechanism.spi_s\",",
          "5452:    FT_UINT32, BASE_DEC_HEX, NULL, 0x0,",
          "5453:       NULL, HFILL}",
          "5454:   },",
          "5460:   { &hf_sip_raw_line,",
          "5461:     { \"Raw SIP Line\",                \"raw_sip.line\",",
          "5462:      FT_STRING, BASE_NONE,NULL,0x0,",
          "5463:     NULL, HFILL }",
          "5467:  static gint *ett[] = {",
          "5468:   &ett_sip,",
          "5469:   &ett_sip_reqresp,",
          "5470:   &ett_sip_hdr,",
          "5471:   &ett_sip_ext_hdr,",
          "5472:   &ett_sip_element,",
          "5473:   &ett_sip_hist,",
          "5474:   &ett_sip_uri,",
          "5475:   &ett_sip_contact_item,",
          "5476:   &ett_sip_message_body,",
          "5477:   &ett_sip_cseq,",
          "5478:   &ett_sip_via,",
          "5479:   &ett_sip_reason,",
          "5480:   &ett_sip_security_client,",
          "5481:   &ett_sip_security_server,",
          "5482:   &ett_sip_security_verify,",
          "5483:   &ett_sip_rack,",
          "5484:   &ett_sip_record_route,",
          "5485:   &ett_sip_route,",
          "5486:   &ett_sip_ruri,",
          "5487:   &ett_sip_pai_uri,",
          "5488:   &ett_sip_pmiss_uri,",
          "5489:   &ett_sip_ppi_uri,",
          "5490:   &ett_sip_tc_uri,",
          "5491:   &ett_sip_to_uri,",
          "5492:   &ett_sip_from_uri,",
          "5493:   &ett_sip_curi",
          "5494:  };",
          "5495:  static gint *ett_raw[] = {",
          "5496:   &ett_raw_text,",
          "5497:  };",
          "5499:  static ei_register_info ei[] = {",
          "5500:   { &ei_sip_unrecognized_header, { \"sip.unrecognized_header\", PI_UNDECODED, PI_NOTE, \"Unrecognised SIP header\", EXPFILL }},",
          "5501:   { &ei_sip_header_not_terminated, { \"sip.header_not_terminated\", PI_MALFORMED, PI_WARN, \"Header not terminated by empty line (CRLF)\", EXPFILL }},",
          "5502:   { &ei_sip_odd_register_response, { \"sip.response.unusual\", PI_RESPONSE_CODE, PI_WARN, \"SIP Response is unusual\", EXPFILL }},",
          "5503:   { &ei_sip_sipsec_malformed, { \"sip.sec_mechanism.malformed\", PI_MALFORMED, PI_WARN, \"SIP Security-mechanism header malformed\", EXPFILL }},",
          "5504:  };",
          "5506:  module_t *sip_module;",
          "5507:  expert_module_t* expert_sip;",
          "5510:  proto_sip = proto_register_protocol(\"Session Initiation Protocol\",",
          "5511:                                      \"SIP\", \"sip\");",
          "5512:  proto_raw_sip = proto_register_protocol(\"Session Initiation Protocol (SIP as raw text)\",",
          "5513:                                          \"Raw_SIP\", \"raw_sip\");",
          "5514:  new_register_dissector(\"sip\", dissect_sip, proto_sip);",
          "5515:  register_dissector(\"sip.tcp\", dissect_sip_tcp, proto_sip);",
          "5518:  proto_register_field_array(proto_sip, hf, array_length(hf));",
          "5519:  proto_register_subtree_array(ett, array_length(ett));",
          "5520:  expert_sip = expert_register_protocol(proto_sip);",
          "5521:  expert_register_field_array(expert_sip, ei, array_length(ei));",
          "5522:  proto_register_subtree_array(ett_raw, array_length(ett_raw));",
          "5525:  proto_register_field_array(proto_raw_sip, raw_hf, array_length(raw_hf));",
          "5527:  sip_module = prefs_register_protocol(proto_sip, proto_reg_handoff_sip);",
          "5528:  range_convert_str(&global_sip_tcp_port_range, DEFAULT_SIP_PORT_RANGE, MAX_UDP_PORT);",
          "5531:  prefs_register_range_preference(sip_module, \"tcp.ports\", \"SIP TCP ports\",",
          "5532:      \"TCP ports to be decoded as SIP (default: \"",
          "5533:      DEFAULT_SIP_PORT_RANGE \")\",",
          "5534:      &global_sip_tcp_port_range, MAX_UDP_PORT);",
          "5536:  prefs_register_uint_preference(sip_module, \"tls.port\",",
          "5541:  prefs_register_bool_preference(sip_module, \"display_raw_text\",",
          "5542:   \"Display raw text for SIP message\",",
          "5543:   \"Specifies that the raw text of the \"",
          "5544:   \"SIP message should be displayed \"",
          "5545:   \"in addition to the dissection tree\",",
          "5546:   &global_sip_raw_text);",
          "5547:  prefs_register_bool_preference(sip_module, \"display_raw_text_without_crlf\",",
          "5548:   \"Don't show '\\\\r\\\\n' in raw SIP messages\",",
          "5549:   \"If the raw text of the SIP message \"",
          "5550:   \"is displayed, the trailing carriage \"",
          "5551:   \"return and line feed are not shown\",",
          "5552:   &global_sip_raw_text_without_crlf);",
          "5553:  prefs_register_bool_preference(sip_module, \"strict_sip_version\",",
          "5554:   \"Enforce strict SIP version check (\" SIP2_HDR \")\",",
          "5555:   \"If enabled, only \" SIP2_HDR \" traffic will be dissected as SIP. \"",
          "5556:   \"Disable it to allow SIP traffic with a different version \"",
          "5557:   \"to be dissected as SIP.\",",
          "5558:   &strict_sip_version);",
          "5559:  prefs_register_bool_preference(sip_module, \"desegment_headers\",",
          "5560:      \"Reassemble SIP headers spanning multiple TCP segments\",",
          "5561:      \"Whether the SIP dissector should reassemble headers \"",
          "5562:      \"of a request spanning multiple TCP segments. \"",
          "5563:   \"To use this option, you must also enable \"",
          "5565:      &sip_desegment_headers);",
          "5566:  prefs_register_bool_preference(sip_module, \"desegment_body\",",
          "5567:      \"Reassemble SIP bodies spanning multiple TCP segments\",",
          "5568:      \"Whether the SIP dissector should use the \"",
          "5569:      \"\\\"Content-length:\\\" value, if present, to reassemble \"",
          "5570:      \"the body of a request spanning multiple TCP segments, \"",
          "5571:      \"and reassemble chunked data spanning multiple TCP segments. \"",
          "5572:   \"To use this option, you must also enable \"",
          "5573:          \"\\\"Allow subdissectors to reassemble TCP streams\\\" in the TCP protocol settings.\",",
          "5574:      &sip_desegment_body);",
          "5575:  prefs_register_bool_preference(sip_module, \"retrans_the_same_sport\",",
          "5576:      \"Retransmissions always use the same source port\",",
          "5577:      \"Whether retransmissions are detected coming from the same source port only.\",",
          "5578:      &sip_retrans_the_same_sport);",
          "5580:  prefs_register_obsolete_preference(sip_module, \"tcp.port\");",
          "5582:  register_init_routine(&sip_init_protocol);",
          "5583:  register_heur_dissector_list(\"sip\", &heur_subdissector_list);",
          "5585:  sip_tap = register_tap(\"sip\");",
          "5587:  ext_hdr_subdissector_table = register_dissector_table(\"sip.hdr\", \"SIP Extension header\", FT_STRING, BASE_NONE);",
          "5594:  static range_t *sip_tcp_port_range;",
          "5596:  static guint saved_sip_tls_port;",
          "5597:  static gboolean sip_prefs_initialized = FALSE;",
          "5599:  if (!sip_prefs_initialized) {",
          "5600:   dissector_handle_t sip_handle;",
          "5601:   sip_handle = find_dissector(\"sip\");",
          "5602:   sip_tcp_handle = find_dissector(\"sip.tcp\");",
          "5603:   sigcomp_handle = find_dissector(\"sigcomp\");",
          "5604:   sip_diag_handle = find_dissector(\"sip.diagnostic\");",
          "5606:   media_type_dissector_table = find_dissector_table(\"media_type\");",
          "5608:   dissector_add_uint(\"udp.port\", UDP_PORT_SIP, sip_handle);",
          "5609:   dissector_add_string(\"media_type\", \"message/sip\", sip_handle);",
          "5611:   heur_dissector_add(\"udp\", dissect_sip_heur, proto_sip);",
          "5612:   heur_dissector_add(\"tcp\", dissect_sip_tcp_heur, proto_sip);",
          "5613:   heur_dissector_add(\"sctp\", dissect_sip_heur, proto_sip);",
          "5614:   heur_dissector_add(\"stun\", dissect_sip_heur, proto_sip);",
          "5615:   sip_prefs_initialized = TRUE;",
          "5616:  } else {",
          "5617:   dissector_delete_uint_range(\"tcp.port\", sip_tcp_port_range, sip_tcp_handle);",
          "5618:   g_free(sip_tcp_port_range);",
          "5619:   ssl_dissector_delete(saved_sip_tls_port, \"sip.tcp\", TRUE);",
          "5620:  }",
          "5622:  sip_tcp_port_range = range_copy(global_sip_tcp_port_range);",
          "5623:  dissector_add_uint_range(\"tcp.port\", sip_tcp_port_range, sip_tcp_handle);",
          "5624:  saved_sip_tls_port = sip_tls_port;",
          "5625:  ssl_dissector_add(saved_sip_tls_port, \"sip.tcp\", TRUE);",
          "5627:  exported_pdu_tap = find_tap_id(EXPORT_PDU_TAP_NAME_LAYER_7);",
          "",
          "[Added Lines]",
          "4337:         { &hf_sip_msg_hdr,",
          "4338:                 { \"Message Header\",           \"sip.msg_hdr\",",
          "4342:         { &hf_sip_Method,",
          "4343:                { \"Method\",      \"sip.Method\",",
          "4344:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4345:             \"SIP Method\", HFILL }",
          "4346:         },",
          "4347:         { &hf_Request_Line,",
          "4348:                 { \"Request-Line\",                \"sip.Request-Line\",",
          "4349:                     FT_STRING, BASE_NONE,NULL,0x0,",
          "4352:         { &hf_sip_ruri,",
          "4353:                 { \"Request-URI\",        \"sip.r-uri\",",
          "4354:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4355:             \"RFC 3261: SIP R-URI\", HFILL }",
          "4356:         },",
          "4357:         { &hf_sip_ruri_user,",
          "4358:                 { \"Request-URI User Part\",      \"sip.r-uri.user\",",
          "4359:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4360:             \"RFC 3261: SIP R-URI User\", HFILL }",
          "4361:         },",
          "4362:         { &hf_sip_ruri_host,",
          "4363:                 { \"Request-URI Host Part\",      \"sip.r-uri.host\",",
          "4364:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4365:             \"RFC 3261: SIP R-URI Host\", HFILL }",
          "4366:         },",
          "4367:         { &hf_sip_ruri_port,",
          "4368:                 { \"Request-URI Host Port\",      \"sip.r-uri.port\",",
          "4369:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4370:             \"RFC 3261: SIP R-URI Port\", HFILL }",
          "4371:         },",
          "4372:         { &hf_sip_ruri_param,",
          "4373:                 { \"Request URI parameter\",      \"sip.r-uri.param\",",
          "4374:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4375:             NULL, HFILL }",
          "4376:         },",
          "4377:         { &hf_sip_Status_Code,",
          "4378:                { \"Status-Code\",         \"sip.Status-Code\",",
          "4379:                FT_UINT32, BASE_DEC,NULL,0x0,",
          "4380:             \"SIP Status Code\", HFILL }",
          "4381:         },",
          "4382:         { &hf_sip_Status_Line,",
          "4383:                { \"Status-Line\",                 \"sip.Status-Line\",",
          "4384:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4387:         { &hf_sip_display,",
          "4388:             { \"SIP Display info\",       \"sip.display.info\",",
          "4389:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4390:             \"RFC 3261: Display info\", HFILL }",
          "4391:         },",
          "4392:         { &hf_sip_to_addr,",
          "4393:                 { \"SIP to address\",         \"sip.to.addr\",",
          "4394:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4395:             \"RFC 3261: To Address\", HFILL }",
          "4396:         },",
          "4397:         { &hf_sip_to_user,",
          "4398:                { \"SIP to address User Part\",        \"sip.to.user\",",
          "4399:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4400:             \"RFC 3261: To Address User\", HFILL }",
          "4401:         },",
          "4402:         { &hf_sip_to_host,",
          "4403:                { \"SIP to address Host Part\",        \"sip.to.host\",",
          "4404:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4405:             \"RFC 3261: To Address Host\", HFILL }",
          "4406:         },",
          "4407:         { &hf_sip_to_port,",
          "4408:                { \"SIP to address Host Port\",        \"sip.to.port\",",
          "4409:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4410:             \"RFC 3261: To Address Port\", HFILL }",
          "4411:         },",
          "4412:         { &hf_sip_to_param,",
          "4413:                { \"SIP To URI parameter\",        \"sip.to.param\",",
          "4414:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4415:             NULL, HFILL }",
          "4416:         },",
          "4417:         { &hf_sip_to_tag,",
          "4418:                { \"SIP to tag\",          \"sip.to.tag\",",
          "4419:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4420:             \"RFC 3261: to tag\", HFILL }",
          "4421:         },",
          "4422:         { &hf_sip_from_addr,",
          "4423:                { \"SIP from address\",        \"sip.from.addr\",",
          "4424:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4425:             \"RFC 3261: From Address\", HFILL }",
          "4426:         },",
          "4427:         { &hf_sip_from_user,",
          "4428:                { \"SIP from address User Part\",      \"sip.from.user\",",
          "4429:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4430:             \"RFC 3261: From Address User\", HFILL }",
          "4431:         },",
          "4432:         { &hf_sip_from_host,",
          "4433:                { \"SIP from address Host Part\",      \"sip.from.host\",",
          "4434:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4435:             \"RFC 3261: From Address Host\", HFILL }",
          "4436:         },",
          "4437:         { &hf_sip_from_port,",
          "4438:                { \"SIP from address Host Port\",      \"sip.from.port\",",
          "4439:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4440:             \"RFC 3261: From Address Port\", HFILL }",
          "4441:         },",
          "4442:         { &hf_sip_from_param,",
          "4443:                { \"SIP From URI parameter\",      \"sip.from.param\",",
          "4444:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4445:             NULL, HFILL }",
          "4446:         },",
          "4447:         { &hf_sip_from_tag,",
          "4448:                { \"SIP from tag\",        \"sip.from.tag\",",
          "4449:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4450:             \"RFC 3261: from tag\", HFILL }",
          "4451:         },",
          "4453:         { &hf_sip_curi,",
          "4454:                 { \"Contact URI\",        \"sip.contact.uri\",",
          "4455:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4456:             \"RFC 3261: SIP C-URI\", HFILL }",
          "4457:         },",
          "4458:         { &hf_sip_curi_user,",
          "4459:                 { \"Contact URI User Part\",      \"sip.contact.user\",",
          "4460:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4461:             \"RFC 3261: SIP C-URI User\", HFILL }",
          "4462:         },",
          "4463:         { &hf_sip_curi_host,",
          "4464:                 { \"Contact URI Host Part\",      \"sip.contact.host\",",
          "4465:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4466:             \"RFC 3261: SIP C-URI Host\", HFILL }",
          "4467:         },",
          "4468:         { &hf_sip_curi_port,",
          "4469:                 { \"Contact URI Host Port\",      \"sip.contact.port\",",
          "4470:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4471:             \"RFC 3261: SIP C-URI Port\", HFILL }",
          "4472:         },",
          "4473:         { &hf_sip_curi_param,",
          "4474:                 { \"Contact URI parameter\",      \"sip.contact.param\",",
          "4475:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4476:             NULL, HFILL }",
          "4477:         },",
          "4479:         { &hf_sip_route,",
          "4480:                 { \"Route URI\",         \"sip.Route.uri\",",
          "4481:                FT_STRING, BASE_NONE,NULL,0x0,NULL,HFILL }",
          "4482:         },",
          "4483:         { &hf_sip_route_user,",
          "4484:                 { \"Route Userinfo\",    \"sip.Route.user\",",
          "4485:                FT_STRING, BASE_NONE,NULL,0x0,NULL,HFILL }",
          "4486:         },",
          "4487:         { &hf_sip_route_host,",
          "4488:                 { \"Route Host Part\",   \"sip.Route.host\",",
          "4489:                FT_STRING, BASE_NONE,NULL,0x0,NULL,HFILL }",
          "4490:         },",
          "4491:         { &hf_sip_route_port,",
          "4492:                 { \"Route Host Port\",   \"sip.Route.port\",",
          "4493:                FT_STRING, BASE_NONE,NULL,0x0,NULL,HFILL }",
          "4494:         },",
          "4495:         { &hf_sip_route_param,",
          "4496:                 { \"Route URI parameter\",   \"sip.Route.param\",",
          "4497:                FT_STRING, BASE_NONE,NULL,0x0,NULL,HFILL }",
          "4498:         },",
          "4499:         { &hf_sip_record_route,",
          "4500:                 { \"Record-Route URI\",         \"sip.Record-Route.uri\",",
          "4501:                FT_STRING, BASE_NONE,NULL,0x0,NULL,HFILL }",
          "4502:         },",
          "4503:         { &hf_sip_record_route_user,",
          "4504:                 { \"Record-Route Userinfo\",    \"sip.Record-Route.user\",",
          "4505:                FT_STRING, BASE_NONE,NULL,0x0,NULL,HFILL }",
          "4506:         },",
          "4507:         { &hf_sip_record_route_host,",
          "4508:                 { \"Record-Route Host Part\",   \"sip.Record-Route.host\",",
          "4509:                FT_STRING, BASE_NONE,NULL,0x0,NULL,HFILL }",
          "4510:         },",
          "4511:         { &hf_sip_record_route_port,",
          "4512:                 { \"Record-Route Host Port\",   \"sip.Record-Route.port\",",
          "4513:                FT_STRING, BASE_NONE,NULL,0x0,NULL,HFILL }",
          "4514:         },",
          "4515:         { &hf_sip_record_route_param,",
          "4516:                 { \"Record-Route URI parameter\",   \"sip.Record-Route.param\",",
          "4517:                FT_STRING, BASE_NONE,NULL,0x0,NULL,HFILL }",
          "4518:         },",
          "4520:         { &hf_sip_contact_param,",
          "4521:                { \"Contact parameter\",       \"sip.contact.parameter\",",
          "4522:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4523:             \"RFC 3261: one contact parameter\", HFILL }",
          "4524:         },",
          "4525:         { &hf_sip_tag,",
          "4526:                { \"SIP tag\",         \"sip.tag\",",
          "4527:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4528:             \"RFC 3261: tag\", HFILL }",
          "4529:         },",
          "4530:         { &hf_sip_pai_addr,",
          "4531:                { \"SIP PAI Address\",         \"sip.pai.addr\",",
          "4532:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4533:             \"RFC 3325: P-Asserted-Identity Address\", HFILL }",
          "4534:         },",
          "4535:         { &hf_sip_pai_user,",
          "4536:                { \"SIP PAI User Part\",       \"sip.pai.user\",",
          "4537:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4538:             \"RFC 3325: P-Asserted-Identity User\", HFILL }",
          "4539:         },",
          "4540:         { &hf_sip_pai_host,",
          "4541:                { \"SIP PAI Host Part\",       \"sip.pai.host\",",
          "4542:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4543:             \"RFC 3325: P-Asserted-Identity Host\", HFILL }",
          "4544:         },",
          "4545:         { &hf_sip_pai_port,",
          "4546:                { \"SIP PAI Host Port\",       \"sip.pai.port\",",
          "4547:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4548:             \"RFC 3325: P-Asserted-Identity Port\", HFILL }",
          "4549:         },",
          "4550:         { &hf_sip_pai_param,",
          "4551:                { \"SIP PAI URI parameter\",       \"sip.pai.param\",",
          "4552:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4553:             NULL, HFILL }",
          "4554:         },",
          "4555:         { &hf_sip_pmiss_addr,",
          "4556:                { \"SIP PMISS Address\",       \"sip.pmiss.addr\",",
          "4557:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4558:             \"RFC 3325: Permission Missing Address\", HFILL }",
          "4559:         },",
          "4560:         { &hf_sip_pmiss_user,",
          "4561:                { \"SIP PMISS User Part\",     \"sip.pmiss.user\",",
          "4562:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4563:             \"RFC 3325: Permission Missing User\", HFILL }",
          "4564:         },",
          "4565:         { &hf_sip_pmiss_host,",
          "4566:                { \"SIP PMISS Host Part\",     \"sip.pmiss.host\",",
          "4567:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4568:             \"RFC 3325: Permission Missing Host\", HFILL }",
          "4569:         },",
          "4570:         { &hf_sip_pmiss_port,",
          "4571:                { \"SIP PMISS Host Port\",     \"sip.pmiss.port\",",
          "4572:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4573:             \"RFC 3325: Permission Missing Port\", HFILL }",
          "4574:         },",
          "4575:         { &hf_sip_pmiss_param,",
          "4576:                { \"SIP PMISS URI parameter\",     \"sip.pmiss.param\",",
          "4577:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4578:             NULL, HFILL }",
          "4579:         },",
          "4581:         { &hf_sip_ppi_addr,",
          "4582:                { \"SIP PPI Address\",         \"sip.ppi.addr\",",
          "4583:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4584:             \"RFC 3325: P-Preferred-Identity Address\", HFILL }",
          "4585:         },",
          "4586:         { &hf_sip_ppi_user,",
          "4587:                { \"SIP PPI User Part\",       \"sip.ppi.user\",",
          "4588:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4589:             \"RFC 3325: P-Preferred-Identity User\", HFILL }",
          "4590:         },",
          "4591:         { &hf_sip_ppi_host,",
          "4592:                { \"SIP PPI Host Part\",       \"sip.ppi.host\",",
          "4593:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4594:             \"RFC 3325: P-Preferred-Identity Host\", HFILL }",
          "4595:         },",
          "4596:         { &hf_sip_ppi_port,",
          "4597:                { \"SIP PPI Host Port\",       \"sip.ppi.port\",",
          "4598:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4599:             \"RFC 3325: P-Preferred-Identity Port\", HFILL }",
          "4600:         },",
          "4601:         { &hf_sip_ppi_param,",
          "4602:                { \"SIP PPI URI parameter\",       \"sip.ppi.param\",",
          "4603:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4604:             NULL, HFILL }",
          "4605:         },",
          "4606:         { &hf_sip_tc_addr,",
          "4607:                { \"SIP TC Address\",      \"sip.tc.addr\",",
          "4608:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4609:             \"RFC 3325: Trigger Consent Address\", HFILL }",
          "4610:         },",
          "4611:         { &hf_sip_tc_user,",
          "4612:                { \"SIP TC User Part\",        \"sip.tc.user\",",
          "4613:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4614:             \"RFC 3325: Trigger Consent User\", HFILL }",
          "4615:         },",
          "4616:         { &hf_sip_tc_host,",
          "4617:                { \"SIP TC Host Part\",        \"sip.tc.host\",",
          "4618:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4619:             \"RFC 3325: Trigger Consent Host\", HFILL }",
          "4620:         },",
          "4621:         { &hf_sip_tc_port,",
          "4622:                { \"SIP TC Host Port\",        \"sip.tc.port\",",
          "4623:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4624:             \"RFC 3325: Trigger Consent Port\", HFILL }",
          "4625:         },",
          "4626:         { &hf_sip_tc_param,",
          "4627:                { \"SIP TC URI parameter\",        \"sip.tc.param\",",
          "4628:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4629:             NULL, HFILL }",
          "4630:         },",
          "4631:         { &hf_sip_tc_turi,",
          "4632:                { \"SIP TC Target URI\",       \"sip.tc.target-uri\",",
          "4633:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4634:             \"RFC 3325: Trigger Consent Target URI\", HFILL }",
          "4635:         },",
          "4636:         { &hf_header_array[POS_ACCEPT],",
          "4637:                { \"Accept\",      \"sip.Accept\",",
          "4638:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4639:             \"RFC 3261: Accept Header\", HFILL }",
          "4640:         },",
          "4641:         { &hf_header_array[POS_ACCEPT_CONTACT],",
          "4642:                { \"Accept-Contact\",      \"sip.Accept-Contact\",",
          "4643:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4644:             \"RFC 3841: Accept-Contact Header\", HFILL }",
          "4645:         },",
          "4646:         { &hf_header_array[POS_ACCEPT_ENCODING],",
          "4647:                { \"Accept-Encoding\",         \"sip.Accept-Encoding\",",
          "4648:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4649:             \"RFC 3841: Accept-Encoding Header\", HFILL }",
          "4650:         },",
          "4651:         { &hf_header_array[POS_ACCEPT_LANGUAGE],",
          "4652:                { \"Accept-Language\",         \"sip.Accept-Language\",",
          "4653:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4654:             \"RFC 3261: Accept-Language Header\", HFILL }",
          "4655:         },",
          "4656:         { &hf_header_array[POS_ACCEPT_RESOURCE_PRIORITY],",
          "4657:                { \"Accept-Resource-Priority\",        \"sip.Accept-Resource-Priority\",",
          "4658:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4659:             \"Draft: Accept-Resource-Priority Header\", HFILL }",
          "4660:         },",
          "4661:         { &hf_header_array[POS_ALERT_INFO],",
          "4662:                { \"Alert-Info\",      \"sip.Alert-Info\",",
          "4663:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4664:             \"RFC 3261: Alert-Info Header\", HFILL }",
          "4665:         },",
          "4667:                { \"Allow\",       \"sip.Allow\",",
          "4668:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4669:             \"RFC 3261: Allow Header\", HFILL }",
          "4670:         },",
          "4672:                { \"Allow-Events\",        \"sip.Allow-Events\",",
          "4673:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4674:             \"RFC 3265: Allow-Events Header\", HFILL }",
          "4675:         },",
          "4677:                { \"Answer-Mode\",         \"sip.Answer-Mode\",",
          "4678:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4679:             \"RFC 5373: Answer-Mode Header\", HFILL }",
          "4680:         },",
          "4682:                { \"Authentication-Info\",         \"sip.Authentication-Info\",",
          "4683:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4684:             \"RFC 3261: Authentication-Info Header\", HFILL }",
          "4685:         },",
          "4687:                { \"Authorization\",       \"sip.Authorization\",",
          "4688:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4689:             \"RFC 3261: Authorization Header\", HFILL }",
          "4690:         },",
          "4692:                { \"Call-ID\",         \"sip.Call-ID\",",
          "4693:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4694:             \"RFC 3261: Call-ID Header\", HFILL }",
          "4695:         },",
          "4697:                { \"Call-Info\",       \"sip.Call-Info\",",
          "4698:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4699:             \"RFC 3261: Call-Info Header\", HFILL }",
          "4700:         },",
          "4702:                { \"Contact\",         \"sip.Contact\",",
          "4703:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4704:             \"RFC 3261: Contact Header\", HFILL }",
          "4705:         },",
          "4707:                { \"Content-Disposition\",         \"sip.Content-Disposition\",",
          "4708:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4709:             \"RFC 3261: Content-Disposition Header\", HFILL }",
          "4710:         },",
          "4712:                { \"Content-Encoding\",        \"sip.Content-Encoding\",",
          "4713:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4714:             \"RFC 3261: Content-Encoding Header\", HFILL }",
          "4715:         },",
          "4717:                { \"Content-Language\",        \"sip.Content-Language\",",
          "4718:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4719:             \"RFC 3261: Content-Language Header\", HFILL }",
          "4720:         },",
          "4722:                { \"Content-Length\",      \"sip.Content-Length\",",
          "4723:                FT_UINT32, BASE_DEC,NULL,0x0,",
          "4724:             \"RFC 3261: Content-Length Header\", HFILL }",
          "4725:         },",
          "4727:                { \"Content-Type\",        \"sip.Content-Type\",",
          "4728:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4729:             \"RFC 3261: Content-Type Header\", HFILL }",
          "4730:         },",
          "4732:                { \"CSeq\",        \"sip.CSeq\",",
          "4733:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4734:             \"RFC 3261: CSeq Header\", HFILL }",
          "4735:         },",
          "4737:                { \"Date\",        \"sip.Date\",",
          "4738:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4739:             \"RFC 3261: Date Header\", HFILL }",
          "4740:         },",
          "4742:                { \"Error-Info\",      \"sip.Error-Info\",",
          "4743:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4744:             \"RFC 3261: Error-Info Header\", HFILL }",
          "4745:         },",
          "4747:                { \"Event\",       \"sip.Event\",",
          "4748:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4749:             \"RFC 3265: Event Header\", HFILL }",
          "4750:         },",
          "4751:         { &hf_header_array[POS_EXPIRES],",
          "4752:                { \"Expires\",         \"sip.Expires\",",
          "4753:                FT_UINT32, BASE_DEC,NULL,0x0,",
          "4754:             \"RFC 3261: Expires Header\", HFILL }",
          "4755:         },",
          "4756:         { &hf_header_array[POS_FEATURE_CAPS],",
          "4757:                { \"Feature-Caps\",        \"sip.feature_caps\",",
          "4758:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4759:             \"RFC 6809: Feature-Caps\", HFILL }",
          "4760:         },",
          "4761:         { &hf_header_array[POS_FLOW_TIMER],",
          "4762:                { \"Flow-Timer\",      \"sip.Flow-Timer\",",
          "4763:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4764:             \"RFC 5626: Flow-Timer\", HFILL }",
          "4765:         },",
          "4766:         { &hf_header_array[POS_FROM],",
          "4767:                { \"From\",        \"sip.From\",",
          "4768:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4769:             \"RFC 3261: From Header\", HFILL }",
          "4770:         },",
          "4771:         { &hf_header_array[POS_GEOLOCATION],",
          "4772:                { \"Geolocation\",         \"sip.Geolocation\",",
          "4773:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4774:             NULL, HFILL }",
          "4775:         },",
          "4776:         { &hf_header_array[POS_GEOLOCATION_ERROR],",
          "4777:                { \"Geolocation-Error\",       \"sip.Geolocation\",",
          "4778:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4779:             NULL, HFILL }",
          "4780:         },",
          "4781:         { &hf_header_array[POS_GEOLOCATION_ROUTING],",
          "4782:                { \"Geolocation-Routing\",         \"sip.Geolocation_Routing\",",
          "4783:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4784:             NULL, HFILL }",
          "4785:         },",
          "4786:         { &hf_header_array[POS_HISTORY_INFO],",
          "4787:             { \"History-Info\",           \"sip.History-Info\",",
          "4788:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4789:             \"RFC 4244: Request History Information\", HFILL }",
          "4790:         },",
          "4791:         { &hf_header_array[POS_IDENTITY],",
          "4792:             { \"Identity\",           \"sip.Identity\",",
          "4793:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4794:             \"RFC 4474: Request Identity\", HFILL }",
          "4795:         },",
          "4796:         { &hf_header_array[POS_IDENTITY_INFO],",
          "4797:             { \"Identity-info\",          \"sip.Identity-info\",",
          "4798:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4799:             \"RFC 4474: Request Identity-info\", HFILL }",
          "4800:         },",
          "4801:         { &hf_header_array[POS_INFO_PKG],",
          "4802:             { \"Info-Package\",           \"sip.Info-Package\",",
          "4803:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4804:             NULL, HFILL }",
          "4805:         },",
          "4807:                { \"In-Reply-To\",         \"sip.In-Reply-To\",",
          "4808:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4809:             \"RFC 3261: In-Reply-To Header\", HFILL }",
          "4810:         },",
          "4812:                { \"Join\",        \"sip.Join\",",
          "4813:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4814:             \"Draft: Join Header\", HFILL }",
          "4815:         },",
          "4817:                { \"Max-Breadth\",     \"sip.Max-Breadth\",",
          "4818:                FT_UINT32, BASE_DEC,NULL,0x0,",
          "4819:             \"RFC 5393: Max-Breadth Header\", HFILL }",
          "4820:         },",
          "4822:                { \"Max-Forwards\",        \"sip.Max-Forwards\",",
          "4823:                FT_UINT32, BASE_DEC,NULL,0x0,",
          "4824:             \"RFC 3261: Max-Forwards Header\", HFILL }",
          "4825:         },",
          "4827:                { \"MIME-Version\",        \"sip.MIME-Version\",",
          "4828:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4829:             \"RFC 3261: MIME-Version Header\", HFILL }",
          "4830:         },",
          "4832:                { \"Min-Expires\",         \"sip.Min-Expires\",",
          "4833:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4834:             \"RFC 3261: Min-Expires Header\", HFILL }",
          "4835:         },",
          "4837:                { \"Min-SE\",      \"sip.Min-SE\",",
          "4838:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4839:             \"Draft: Min-SE Header\", HFILL }",
          "4840:         },",
          "4842:                { \"Organization\",        \"sip.Organization\",",
          "4843:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4844:             \"RFC 3261: Organization Header\", HFILL }",
          "4845:         },",
          "4846:         { &hf_header_array[POS_P_ACCESS_NETWORK_INFO],",
          "4847:                { \"P-Access-Network-Info\",   \"sip.P-Access-Network-Info\",",
          "4848:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4849:             \"P-Access-Network-Info Header\", HFILL }",
          "4850:         },",
          "4851:         { &hf_header_array[POS_P_ANSWER_STATE],",
          "4852:                { \"P-Answer-State\",      \"sip.P-Answer-State\",",
          "4853:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4854:             \"RFC 4964: P-Answer-State Header\", HFILL }",
          "4855:         },",
          "4856:         { &hf_header_array[POS_P_ASSERTED_IDENTITY],",
          "4857:                { \"P-Asserted-Identity\",     \"sip.P-Asserted-Identity\",",
          "4858:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4859:             \"RFC 3325: P-Asserted-Identity Header\", HFILL }",
          "4860:         },",
          "4861:         { &hf_header_array[POS_P_ASSERTED_SERV],",
          "4862:                { \"P-Asserted-Service\",      \"sip.P-Asserted-Service\",",
          "4863:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4864:             NULL, HFILL }",
          "4865:         },",
          "4866:         { &hf_header_array[POS_P_ASSOCIATED_URI],",
          "4867:                { \"P-Associated-URI\",        \"sip.P-Associated-URI\",",
          "4868:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4869:             \"RFC 3455: P-Associated-URI Header\", HFILL }",
          "4870:         },",
          "4872:         { &hf_header_array[POS_P_CALLED_PARTY_ID],",
          "4873:                { \"P-Called-Party-ID\",       \"sip.P-Called-Party-ID\",",
          "4874:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4875:             \"RFC 3455: P-Called-Party-ID Header\", HFILL }",
          "4876:         },",
          "4878:         { &hf_header_array[POS_P_CHARGING_FUNC_ADDRESSES],",
          "4879:                { \"P-Charging-Function-Addresses\",\"sip.P-Charging-Function-Addresses\",",
          "4880:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4881:             NULL, HFILL }",
          "4882:         },",
          "4884:         { &hf_header_array[POS_P_CHARGING_VECTOR],",
          "4885:                { \"P-Charging-Vector\",       \"sip.P-Charging-Vector\",",
          "4886:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4887:             \"P-Charging-Vector Header\", HFILL }",
          "4888:         },",
          "4890:         { &hf_header_array[POS_P_DCS_TRACE_PARTY_ID],",
          "4891:                { \"P-DCS-Trace-Party-ID\",    \"sip.P-DCS-Trace-Party-ID\",",
          "4892:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4893:             \"P-DCS-Trace-Party-ID Header\", HFILL }",
          "4894:         },",
          "4896:         { &hf_header_array[POS_P_DCS_OSPS],",
          "4897:                { \"P-DCS-OSPS\",          \"sip.P-DCS-OSPS\",",
          "4898:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4899:             \"P-DCS-OSPS Header\", HFILL }",
          "4900:         },",
          "4902:         { &hf_header_array[POS_P_DCS_BILLING_INFO],",
          "4903:                { \"P-DCS-Billing-Info\",      \"sip.P-DCS-Billing-Info\",",
          "4904:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4905:             \"P-DCS-Billing-Info Header\", HFILL }",
          "4906:         },",
          "4908:         { &hf_header_array[POS_P_DCS_LAES],",
          "4909:                { \"P-DCS-LAES\",          \"sip.P-DCS-LAES\",",
          "4910:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4911:             \"P-DCS-LAES Header\", HFILL }",
          "4912:         },",
          "4914:         { &hf_header_array[POS_P_DCS_REDIRECT],",
          "4915:                { \"P-DCS-Redirect\",      \"sip.P-DCS-Redirect\",",
          "4916:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4917:             \"P-DCS-Redirect Header\", HFILL }",
          "4918:         },",
          "4920:         { &hf_header_array[POS_P_EARLY_MEDIA],",
          "4921:                { \"P-Early-Media\",       \"sip.P-Early-Media\",",
          "4922:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4923:             \"P-Early-Media Header\", HFILL }",
          "4924:         },",
          "4926:         { &hf_header_array[POS_P_MEDIA_AUTHORIZATION],",
          "4927:                { \"P-Media-Authorization\",   \"sip.P-Media-Authorization\",",
          "4928:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4929:                \"RFC 3313: P-Media-Authorization Header\", HFILL }",
          "4930:         },",
          "4932:         { &hf_header_array[POS_P_PREFERRED_IDENTITY],",
          "4933:                { \"P-Preferred-Identity\",    \"sip.P-Preferred-Identity\",",
          "4934:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4935:             \"RFC 3325: P-Preferred-Identity Header\", HFILL }",
          "4936:         },",
          "4937:         { &hf_header_array[POS_P_PREFERRED_SERV],",
          "4938:                { \"P-Preferred-Service\",     \"sip.P-Preferred-Service\",",
          "4939:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4940:             NULL, HFILL }",
          "4941:         },",
          "4942:         { &hf_header_array[POS_P_PROFILE_KEY],",
          "4943:                { \"P-Profile-Key\",   \"sip.P-Profile-Key\",",
          "4944:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4945:             \"P-Profile-Key Header\", HFILL }",
          "4946:         },",
          "4947:         { &hf_header_array[POS_P_REFUSED_URI_LST],",
          "4948:                { \"P-Refused-URI-List\",      \"sip.P-Refused-URI-List\",",
          "4949:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4950:             \"P-Refused-URI-List Header\", HFILL }",
          "4951:         },",
          "4952:         { &hf_header_array[POS_P_SERVED_USER],",
          "4953:                { \"P-Served-User\",   \"sip.P-Served-User\",",
          "4954:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4955:             NULL, HFILL }",
          "4956:         },",
          "4957:         { &hf_header_array[POS_P_USER_DATABASE],",
          "4958:                { \"P-User-Database\",     \"sip.P-User-Database\",",
          "4959:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4960:             \"P-User-Database Header\", HFILL }",
          "4961:         },",
          "4963:         { &hf_header_array[POS_P_VISITED_NETWORK_ID],",
          "4964:                { \"P-Visited-Network-ID\",    \"sip.P-Visited-Network-ID\",",
          "4965:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4966:                \"RFC 3455: P-Visited-Network-ID Header\", HFILL }",
          "4967:         },",
          "4969:         { &hf_header_array[POS_PATH],",
          "4970:                { \"Path\",            \"sip.Path\",",
          "4971:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4972:                \"RFC 3327: Path Header\", HFILL }",
          "4973:         },",
          "4975:         { &hf_header_array[POS_PERMISSION_MISSING],",
          "4976:                { \"Permission-Missing\",      \"sip.Permission-Missing\",",
          "4977:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4978:                \"RFC 5360: Permission Missing Header\", HFILL }",
          "4979:         },",
          "4980:         { &hf_header_array[POS_POLICY_CONTACT],",
          "4981:                { \"Policy-Contact\",      \"sip.Policy_Contact\",",
          "4982:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4983:                NULL, HFILL }",
          "4984:         },",
          "4985:         { &hf_header_array[POS_POLICY_ID],",
          "4986:                { \"Policy-ID\",       \"sip.Policy_ID\",",
          "4987:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4988:                NULL, HFILL }",
          "4989:         },",
          "4990:         { &hf_header_array[POS_PRIORITY],",
          "4991:                { \"Priority\",        \"sip.Priority\",",
          "4992:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4993:             \"RFC 3261: Priority Header\", HFILL }",
          "4994:         },",
          "4995:         { &hf_header_array[POS_PRIV_ANSWER_MODE],",
          "4996:                { \"Priv-Answer-mode\",    \"sip.Priv-Answer-mode\",",
          "4997:                FT_STRING, BASE_NONE,NULL,0x0,",
          "4998:             NULL, HFILL }",
          "4999:         },",
          "5000:         { &hf_header_array[POS_PRIVACY],",
          "5001:                { \"Privacy\",             \"sip.Privacy\",",
          "5002:                FT_STRING, BASE_NONE,NULL,0x0,",
          "5003:             \"Privacy Header\", HFILL }",
          "5004:         },",
          "5006:         { &hf_header_array[POS_PROXY_AUTHENTICATE],",
          "5007:                { \"Proxy-Authenticate\",      \"sip.Proxy-Authenticate\",",
          "5008:                FT_STRING, BASE_NONE,NULL,0x0,",
          "5009:             \"RFC 3261: Proxy-Authenticate Header\", HFILL }",
          "5010:         },",
          "5012:                { \"Proxy-Authorization\",         \"sip.Proxy-Authorization\",",
          "5013:                FT_STRING, BASE_NONE,NULL,0x0,",
          "5014:             \"RFC 3261: Proxy-Authorization Header\", HFILL }",
          "5015:         },",
          "5017:         { &hf_header_array[POS_PROXY_REQUIRE],",
          "5018:                { \"Proxy-Require\",       \"sip.Proxy-Require\",",
          "5019:                FT_STRING, BASE_NONE,NULL,0x0,",
          "5020:             \"RFC 3261: Proxy-Require Header\", HFILL }",
          "5021:         },",
          "5022:         { &hf_header_array[POS_RACK],",
          "5023:                { \"RAck\",        \"sip.RAck\",",
          "5024:                FT_STRING, BASE_NONE,NULL,0x0,",
          "5025:             \"RFC 3262: RAck Header\", HFILL }",
          "5026:         },",
          "5027:         { &hf_header_array[POS_REASON],",
          "5028:                { \"Reason\",          \"sip.Reason\",",
          "5029:                FT_STRING, BASE_NONE,NULL,0x0,",
          "5030:             \"RFC 3326 Reason Header\", HFILL }",
          "5031:         },",
          "5032:         { &hf_header_array[POS_REASON_PHRASE],",
          "5033:                { \"Reason-Phrase\",           \"sip.Reason-Phrase\",",
          "5034:                FT_STRING, BASE_NONE,NULL,0x0,",
          "5035:             NULL, HFILL }",
          "5036:         },",
          "5037:         { &hf_header_array[POS_RECORD_ROUTE],",
          "5038:                { \"Record-Route\",        \"sip.Record-Route\",",
          "5039:                FT_STRING, BASE_NONE,NULL,0x0,",
          "5040:             \"RFC 3261: Record-Route Header\", HFILL }",
          "5041:         },",
          "5042:         { &hf_header_array[POS_RECV_INFO],",
          "5043:                { \"Recv-Info\",       \"sip.Recv-Info\",",
          "5044:                FT_STRING, BASE_NONE,NULL,0x0,",
          "5045:             NULL, HFILL }",
          "5046:         },",
          "5047:         { &hf_header_array[POS_REFER_SUB],",
          "5048:                { \"Refer-Sub\",       \"sip.Refer-Sub\",",
          "5049:                FT_STRING, BASE_NONE,NULL,0x0,",
          "5050:             \"RFC 4488: Refer-Sub Header\", HFILL }",
          "5051:         },",
          "5052:         { &hf_header_array[POS_REFER_TO],",
          "5053:             { \"Refer-To\",           \"sip.Refer-To\",",
          "5054:                FT_STRING, BASE_NONE,NULL,0x0,",
          "5055:             \"RFC 3515: Refer-To Header\", HFILL }",
          "5056:         },",
          "5057:         { &hf_header_array[POS_REFERED_BY],",
          "5058:                { \"Refered By\",      \"sip.Refered-by\",",
          "5059:                FT_STRING, BASE_NONE,NULL,0x0,",
          "5060:             \"RFC 3892: Refered-by Header\", HFILL }",
          "5061:         },",
          "5062:         { &hf_header_array[POS_REJECT_CONTACT],",
          "5063:             { \"Reject-Contact\",         \"sip.Reject-Contact\",",
          "5064:             FT_STRING, BASE_NONE,NULL,0x0,",
          "5065:             \"RFC 3841: Reject-Contact Header\", HFILL }",
          "5066:         },",
          "5067:         { &hf_header_array[POS_REPLACES],",
          "5068:             { \"Replaces\",       \"sip.Replaces\",",
          "5069:             FT_STRING, BASE_NONE,NULL,0x0,",
          "5070:             \"RFC 3891: Replaces Header\", HFILL }",
          "5071:         },",
          "5072:         { &hf_header_array[POS_REPLY_TO],",
          "5073:                { \"Reply-To\",        \"sip.Reply-To\",",
          "5074:                FT_STRING, BASE_NONE,NULL,0x0,",
          "5075:             \"RFC 3261: Reply-To Header\", HFILL }",
          "5076:         },",
          "5077:         { &hf_header_array[POS_REQUEST_DISPOSITION],",
          "5078:                { \"Request-Disposition\",     \"sip.Request-Disposition\",",
          "5079:                FT_STRING, BASE_NONE,NULL,0x0,",
          "5080:             \"RFC 3841: Request-Disposition Header\", HFILL }",
          "5081:         },",
          "5082:         { &hf_header_array[POS_REQUIRE],",
          "5083:             { \"Require\",        \"sip.Require\",",
          "5084:                FT_STRING, BASE_NONE,NULL,0x0,",
          "5085:             \"RFC 3261: Require Header\", HFILL }",
          "5086:         },",
          "5087:         { &hf_header_array[POS_RESOURCE_PRIORITY],",
          "5088:             { \"Resource-Priority\",      \"sip.Resource-Priority\",",
          "5089:                FT_STRING, BASE_NONE,NULL,0x0,",
          "5090:             \"Draft: Resource-Priority Header\", HFILL }",
          "5091:         },",
          "5092:         { &hf_header_array[POS_RETRY_AFTER],",
          "5093:             { \"Retry-After\",        \"sip.Retry-After\",",
          "5094:                FT_STRING, BASE_NONE,NULL,0x0,",
          "5095:             \"RFC 3261: Retry-After Header\", HFILL }",
          "5096:         },",
          "5097:         { &hf_header_array[POS_ROUTE],",
          "5098:                { \"Route\",       \"sip.Route\",",
          "5099:                FT_STRING, BASE_NONE,NULL,0x0,",
          "5100:             \"RFC 3261: Route Header\", HFILL }",
          "5101:         },",
          "5102:         { &hf_header_array[POS_RSEQ],",
          "5103:                { \"RSeq\",        \"sip.RSeq\",",
          "5104:                FT_UINT32, BASE_DEC,NULL,0x0,",
          "5105:             \"RFC 3262: RSeq Header\", HFILL }",
          "5106:         },",
          "5107:         { &hf_header_array[ POS_SECURITY_CLIENT],",
          "5108:                { \"Security-Client\",         \"sip.Security-Client\",",
          "5109:                FT_STRING, BASE_NONE,NULL,0x0,",
          "5110:             \"RFC 3329 Security-Client Header\", HFILL }",
          "5111:         },",
          "5112:         { &hf_header_array[ POS_SECURITY_SERVER],",
          "5113:                { \"Security-Server\",         \"sip.Security-Server\",",
          "5114:                FT_STRING, BASE_NONE,NULL,0x0,",
          "5115:             \"RFC 3329 Security-Server Header\", HFILL }",
          "5116:         },",
          "5117:         { &hf_header_array[ POS_SECURITY_VERIFY],",
          "5118:                { \"Security-Verify\",         \"sip.Security-Verify\",",
          "5119:                FT_STRING, BASE_NONE,NULL,0x0,",
          "5120:             \"RFC 3329 Security-Verify Header\", HFILL }",
          "5121:         },",
          "5122:         { &hf_header_array[POS_SERVER],",
          "5123:             { \"Server\",         \"sip.Server\",",
          "5124:                FT_STRING, BASE_NONE,NULL,0x0,",
          "5125:             \"RFC 3261: Server Header\", HFILL }",
          "5126:         },",
          "5127:         { &hf_header_array[POS_SERVICE_ROUTE],",
          "5128:                { \"Service-Route\",       \"sip.Service-Route\",",
          "5129:                FT_STRING, BASE_NONE,NULL,0x0,",
          "5130:             \"RFC 3608: Service-Route Header\", HFILL }",
          "5131:         },",
          "5132:         { &hf_header_array[POS_SESSION_EXPIRES],",
          "5133:                { \"Session-Expires\",         \"sip.Session-Expires\",",
          "5134:                FT_STRING, BASE_NONE,NULL,0x0,",
          "5135:                \"RFC 4028: Session-Expires Header\", HFILL }",
          "5136:         },",
          "5137:         { &hf_header_array[POS_SIP_ETAG],",
          "5138:                { \"ETag\",        \"sip.ETag\",",
          "5139:                FT_STRING, BASE_NONE,NULL,0x0,",
          "5140:                \"RFC 3903: SIP-ETag Header\", HFILL }",
          "5141:         },",
          "5142:         { &hf_header_array[POS_SIP_IF_MATCH],",
          "5143:                { \"If_Match\",        \"sip.If_Match\",",
          "5144:                FT_STRING, BASE_NONE,NULL,0x0,",
          "5145:             \"RFC 3903: SIP-If-Match Header\", HFILL }",
          "5146:         },",
          "5147:         { &hf_header_array[POS_SUBJECT],",
          "5148:                { \"Subject\",         \"sip.Subject\",",
          "5149:                FT_STRING, BASE_NONE,NULL,0x0,",
          "5150:             \"RFC 3261: Subject Header\", HFILL }",
          "5151:         },",
          "5152:         { &hf_header_array[POS_SUBSCRIPTION_STATE],",
          "5153:                { \"Subscription-State\",      \"sip.Subscription-State\",",
          "5154:                FT_STRING, BASE_NONE,NULL,0x0,",
          "5155:             \"RFC 3265: Subscription-State Header\", HFILL }",
          "5156:         },",
          "5157:         { &hf_header_array[POS_SUPPORTED],",
          "5158:             { \"Supported\",      \"sip.Supported\",",
          "5159:                FT_STRING, BASE_NONE,NULL,0x0,",
          "5160:             \"RFC 3261: Supported Header\", HFILL }",
          "5161:         },",
          "5162:         { &hf_header_array[POS_SUPPRESS_IF_MATCH],",
          "5163:             { \"Suppress-If-Match\",      \"sip.Suppress_If_Match\",",
          "5164:                FT_STRING, BASE_NONE,NULL,0x0,",
          "5165:             NULL, HFILL }",
          "5166:         },",
          "5167:         { &hf_header_array[POS_TARGET_DIALOG],",
          "5168:             { \"Target-Dialog\",      \"sip.Target-Dialog\",",
          "5169:                FT_STRING, BASE_NONE,NULL,0x0,",
          "5170:             \"RFC 4538: Target-Dialog Header\", HFILL }",
          "5171:         },",
          "5172:         { &hf_header_array[POS_TIMESTAMP],",
          "5173:             { \"Timestamp\",      \"sip.Timestamp\",",
          "5174:                FT_STRING, BASE_NONE,NULL,0x0,",
          "5175:             \"RFC 3261: Timestamp Header\", HFILL }",
          "5176:         },",
          "5177:         { &hf_header_array[POS_TO],",
          "5178:             { \"To\",         \"sip.To\",",
          "5179:                FT_STRING, BASE_NONE,NULL,0x0,",
          "5180:             \"RFC 3261: To Header\", HFILL }",
          "5181:         },",
          "5183:         { &hf_header_array[POS_TRIGGER_CONSENT],",
          "5184:             { \"Trigger-Consent\",        \"sip.Trigger-Consent\",",
          "5185:                FT_STRING, BASE_NONE,NULL,0x0,",
          "5186:             \"RFC 5380: Trigger Consent\", HFILL }",
          "5187:         },",
          "5189:         { &hf_header_array[POS_UNSUPPORTED],",
          "5190:             { \"Unsupported\",        \"sip.Unsupported\",",
          "5191:                FT_STRING, BASE_NONE,NULL,0x0,",
          "5192:             \"RFC 3261: Unsupported Header\", HFILL }",
          "5193:         },",
          "5194:         { &hf_header_array[POS_USER_AGENT],",
          "5195:             { \"User-Agent\",         \"sip.User-Agent\",",
          "5196:                FT_STRING, BASE_NONE,NULL,0x0,",
          "5197:             \"RFC 3261: User-Agent Header\", HFILL }",
          "5198:         },",
          "5199:         { &hf_header_array[POS_VIA],",
          "5200:             { \"Via\",        \"sip.Via\",",
          "5201:                FT_STRING, BASE_NONE,NULL,0x0,",
          "5202:             \"RFC 3261: Via Header\", HFILL }",
          "5203:         },",
          "5204:         { &hf_header_array[POS_WARNING],",
          "5205:             { \"Warning\",        \"sip.Warning\",",
          "5206:                FT_STRING, BASE_NONE,NULL,0x0,",
          "5207:             \"RFC 3261: Warning Header\", HFILL }",
          "5208:         },",
          "5210:         { &hf_header_array[POS_WWW_AUTHENTICATE],",
          "5211:             { \"WWW-Authenticate\",       \"sip.WWW-Authenticate\",",
          "5212:                FT_STRING, BASE_NONE,NULL,0x0,",
          "5213:             \"RFC 3261: WWW-Authenticate Header\", HFILL }",
          "5214:         },",
          "5215:         { &hf_header_array[POS_DIVERSION],",
          "5216:             { \"Diversion\",      \"sip.Diversion\",",
          "5217:                FT_STRING, BASE_NONE,NULL,0x0,",
          "5218:             \"RFC 5806: Diversion Header\", HFILL }",
          "5219:         },",
          "5220:         { &hf_header_array[POS_USER_TO_USER],",
          "5221:             { \"User-to-User\",   \"sip.uui\",",
          "5222:                FT_STRING, BASE_NONE,NULL,0x0,",
          "5223:             \"draft-johnston-sipping-cc-uui-09: User-to-User header\", HFILL }",
          "5224:         },",
          "5225:         { &hf_sip_resend,",
          "5226:             { \"Resent Packet\", \"sip.resend\",",
          "5227:             FT_BOOLEAN, BASE_NONE, NULL, 0x0,",
          "5228:             NULL, HFILL }",
          "5229:         },",
          "5230:         { &hf_sip_original_frame,",
          "5231:             { \"Suspected resend of frame\",  \"sip.resend-original\",",
          "5232:             FT_FRAMENUM, BASE_NONE, NULL, 0x0,",
          "5233:                 \"Original transmission of frame\", HFILL}",
          "5234:         },",
          "5235:         { &hf_sip_matching_request_frame,",
          "5236:             { \"Request Frame\",  \"sip.response-request\",",
          "5237:             FT_FRAMENUM, BASE_NONE, NULL, 0x0,",
          "5238:                 NULL, HFILL}",
          "5239:         },",
          "5240:         { &hf_sip_response_time,",
          "5241:             { \"Response Time (ms)\",  \"sip.response-time\",",
          "5242:             FT_UINT32, BASE_DEC, NULL, 0x0,",
          "5243:                 \"Response time since original request (in milliseconds)\", HFILL}",
          "5244:         },",
          "5245:         { &hf_sip_release_time,",
          "5246:             { \"Release Time (ms)\",  \"sip.release-time\",",
          "5247:             FT_UINT32, BASE_DEC, NULL, 0x0,",
          "5248:                 \"release time since original BYE (in milliseconds)\", HFILL}",
          "5249:         },",
          "5250:         { &hf_sip_auth,",
          "5251:             { \"Authentication\",  \"sip.auth\",",
          "5252:             FT_STRING, BASE_NONE, NULL, 0x0,",
          "5253:                 \"SIP Authentication\", HFILL}",
          "5254:         },",
          "5255:         { &hf_sip_auth_scheme,",
          "5256:             { \"Authentication Scheme\",  \"sip.auth.scheme\",",
          "5257:             FT_STRING, BASE_NONE, NULL, 0x0,",
          "5258:                 \"SIP Authentication Scheme\", HFILL}",
          "5259:         },",
          "5260:         { &hf_sip_auth_digest_response,",
          "5261:             { \"Digest Authentication Response\",  \"sip.auth.digest.response\",",
          "5262:             FT_STRING, BASE_NONE, NULL, 0x0,",
          "5263:                 \"SIP Digest Authentication Response Value\", HFILL}",
          "5264:         },",
          "5265:         { &hf_sip_auth_nc,",
          "5266:             { \"Nonce Count\",  \"sip.auth.nc\",",
          "5267:             FT_STRING, BASE_NONE, NULL, 0x0,",
          "5268:                 \"SIP Authentication Nonce count\", HFILL}",
          "5269:         },",
          "5270:         { &hf_sip_auth_username,",
          "5271:             { \"Username\",  \"sip.auth.username\",",
          "5272:             FT_STRING, BASE_NONE, NULL, 0x0,",
          "5273:                 \"SIP Authentication Username\", HFILL}",
          "5274:         },",
          "5275:         { &hf_sip_auth_realm,",
          "5276:             { \"Realm\",  \"sip.auth.realm\",",
          "5277:             FT_STRING, BASE_NONE, NULL, 0x0,",
          "5278:                 \"SIP Authentication Realm\", HFILL}",
          "5279:         },",
          "5280:         { &hf_sip_auth_nonce,",
          "5281:             { \"Nonce Value\",  \"sip.auth.nonce\",",
          "5282:             FT_STRING, BASE_NONE, NULL, 0x0,",
          "5283:                 \"SIP Authentication Nonce\", HFILL}",
          "5284:         },",
          "5285:         { &hf_sip_auth_algorithm,",
          "5286:             { \"Algorithm\",  \"sip.auth.algorithm\",",
          "5287:             FT_STRING, BASE_NONE, NULL, 0x0,",
          "5288:                 \"SIP Authentication Algorithm\", HFILL}",
          "5289:         },",
          "5290:         { &hf_sip_auth_opaque,",
          "5291:             { \"Opaque Value\",  \"sip.auth.opaque\",",
          "5292:             FT_STRING, BASE_NONE, NULL, 0x0,",
          "5293:                 \"SIP Authentication Opaque value\", HFILL}",
          "5294:         },",
          "5295:         { &hf_sip_auth_qop,",
          "5296:             { \"QOP\",  \"sip.auth.qop\",",
          "5297:             FT_STRING, BASE_NONE, NULL, 0x0,",
          "5298:                 \"SIP Authentication QOP\", HFILL}",
          "5299:         },",
          "5300:         { &hf_sip_auth_cnonce,",
          "5301:             { \"CNonce Value\",  \"sip.auth.cnonce\",",
          "5302:             FT_STRING, BASE_NONE, NULL, 0x0,",
          "5303:                 \"SIP Authentication Client Nonce\", HFILL}",
          "5304:         },",
          "5305:         { &hf_sip_auth_uri,",
          "5306:             { \"Authentication URI\",  \"sip.auth.uri\",",
          "5307:             FT_STRING, BASE_NONE, NULL, 0x0,",
          "5308:                 \"SIP Authentication URI\", HFILL}",
          "5309:         },",
          "5310:         { &hf_sip_auth_domain,",
          "5311:             { \"Authentication Domain\",  \"sip.auth.domain\",",
          "5312:             FT_STRING, BASE_NONE, NULL, 0x0,",
          "5313:                 \"SIP Authentication Domain\", HFILL}",
          "5314:         },",
          "5315:         { &hf_sip_auth_stale,",
          "5316:             { \"Stale Flag\",  \"sip.auth.stale\",",
          "5317:             FT_STRING, BASE_NONE, NULL, 0x0,",
          "5318:                 \"SIP Authentication Stale Flag\", HFILL}",
          "5319:         },",
          "5320:         { &hf_sip_auth_auts,",
          "5321:             { \"Authentication Token\",  \"sip.auth.auts\",",
          "5322:             FT_STRING, BASE_NONE, NULL, 0x0,",
          "5323:                 \"SIP Authentication Token\", HFILL}",
          "5324:         },",
          "5325:         { &hf_sip_auth_rspauth,",
          "5326:             { \"Response auth\",  \"sip.auth.rspauth\",",
          "5327:             FT_STRING, BASE_NONE, NULL, 0x0,",
          "5328:                 \"SIP Authentication Response auth\", HFILL}",
          "5329:         },",
          "5330:         { &hf_sip_auth_nextnonce,",
          "5331:             { \"Next Nonce\",  \"sip.auth.nextnonce\",",
          "5332:             FT_STRING, BASE_NONE, NULL, 0x0,",
          "5333:                 \"SIP Authentication Next Nonce\", HFILL}",
          "5334:         },",
          "5335:         { &hf_sip_auth_ik,",
          "5336:             { \"Integrity Key\",  \"sip.auth.ik\",",
          "5337:             FT_STRING, BASE_NONE, NULL, 0x0,",
          "5338:                 \"SIP Authentication Integrity Key\", HFILL}",
          "5339:         },",
          "5340:         { &hf_sip_auth_ck,",
          "5341:             { \"Cyphering Key\",  \"sip.auth.ck\",",
          "5342:             FT_STRING, BASE_NONE, NULL, 0x0,",
          "5343:                 \"SIP Authentication Cyphering Key\", HFILL}",
          "5344:         },",
          "5345:         { &hf_sip_cseq_seq_no,",
          "5346:             { \"Sequence Number\",  \"sip.CSeq.seq\",",
          "5347:             FT_UINT32, BASE_DEC, NULL, 0x0,",
          "5348:                 \"CSeq header sequence number\", HFILL}",
          "5349:         },",
          "5350:         { &hf_sip_cseq_method,",
          "5351:             { \"Method\",  \"sip.CSeq.method\",",
          "5352:             FT_STRING, BASE_NONE, NULL, 0x0,",
          "5353:                 \"CSeq header method\", HFILL}",
          "5354:         },",
          "5355:         { &hf_sip_via_transport,",
          "5356:             { \"Transport\",  \"sip.Via.transport\",",
          "5357:             FT_STRING, BASE_NONE, NULL, 0x0,",
          "5358:                 \"Via header Transport\", HFILL}",
          "5359:         },",
          "5360:         { &hf_sip_via_sent_by_address,",
          "5361:             { \"Sent-by Address\",  \"sip.Via.sent-by.address\",",
          "5362:             FT_STRING, BASE_NONE, NULL, 0x0,",
          "5363:                 \"Via header Sent-by Address\", HFILL}",
          "5364:         },",
          "5365:         { &hf_sip_via_sent_by_port,",
          "5366:             { \"Sent-by port\",  \"sip.Via.sent-by.port\",",
          "5367:             FT_UINT16, BASE_DEC, NULL, 0x0,",
          "5368:                 \"Via header Sent-by Port\", HFILL}",
          "5369:         },",
          "5370:         { &hf_sip_via_branch,",
          "5371:             { \"Branch\",  \"sip.Via.branch\",",
          "5372:             FT_STRING, BASE_NONE, NULL, 0x0,",
          "5373:                 \"SIP Via Branch\", HFILL},",
          "5374:         },",
          "5375:         { &hf_sip_via_maddr,",
          "5376:             { \"Maddr\",  \"sip.Via.maddr\",",
          "5377:             FT_STRING, BASE_NONE, NULL, 0x0,",
          "5378:                 \"SIP Via Maddr\", HFILL},",
          "5379:         },",
          "5380:         { &hf_sip_via_rport,",
          "5381:             { \"RPort\",  \"sip.Via.rport\",",
          "5382:             FT_STRING, BASE_NONE, NULL, 0x0,",
          "5383:                 \"SIP Via RPort\", HFILL},",
          "5384:         },",
          "5385:         { &hf_sip_via_received,",
          "5386:             { \"Received\",  \"sip.Via.received\",",
          "5387:             FT_STRING, BASE_NONE, NULL, 0x0,",
          "5388:                 \"SIP Via Received\", HFILL},",
          "5389:         },",
          "5390:         { &hf_sip_via_ttl,",
          "5391:             { \"TTL\",  \"sip.Via.ttl\",",
          "5392:             FT_STRING, BASE_NONE, NULL, 0x0,",
          "5393:                 \"SIP Via TTL\", HFILL}",
          "5394:         },",
          "5395:         { &hf_sip_via_comp,",
          "5396:             { \"Comp\",  \"sip.Via.comp\",",
          "5397:             FT_STRING, BASE_NONE, NULL, 0x0,",
          "5398:                 \"SIP Via comp\", HFILL}",
          "5399:         },",
          "5400:         { &hf_sip_via_sigcomp_id,",
          "5401:             { \"Sigcomp identifier\",  \"sip.Via.sigcomp-id\",",
          "5402:             FT_STRING, BASE_NONE, NULL, 0x0,",
          "5403:                 \"SIP Via sigcomp identifier\", HFILL}",
          "5404:         },",
          "5405:         { &hf_sip_rack_rseq_no,",
          "5406:             { \"RSeq Sequence Number\",  \"sip.RAck.RSeq.seq\",",
          "5407:             FT_UINT32, BASE_DEC, NULL, 0x0,",
          "5408:                 \"RAck RSeq header sequence number (from prov response)\", HFILL}",
          "5409:         },",
          "5410:         { &hf_sip_rack_cseq_no,",
          "5411:             { \"CSeq Sequence Number\",  \"sip.RAck.CSeq.seq\",",
          "5412:             FT_UINT32, BASE_DEC, NULL, 0x0,",
          "5413:                 \"RAck CSeq header sequence number (from prov response)\", HFILL}",
          "5414:         },",
          "5415:         { &hf_sip_rack_cseq_method,",
          "5416:             { \"CSeq Method\",  \"sip.RAck.CSeq.method\",",
          "5417:             FT_STRING, BASE_NONE, NULL, 0x0,",
          "5418:                 \"RAck CSeq header method (from prov response)\", HFILL}",
          "5419:         },",
          "5420:         { &hf_sip_msg_body,",
          "5421:                 { \"Message Body\",           \"sip.msg_body\",",
          "5422:                 FT_NONE, BASE_NONE, NULL, 0x0,",
          "5423:                 \"Message Body in SIP message\", HFILL }",
          "5424:         },",
          "5425:         { &hf_sip_sec_mechanism,",
          "5426:             { \"[Security-mechanism]\",  \"sip.sec_mechanism\",",
          "5427:             FT_STRING, BASE_NONE, NULL, 0x0,",
          "5428:             NULL, HFILL}",
          "5429:         },",
          "5430:         { &hf_sip_sec_mechanism_alg,",
          "5431:             { \"alg\",  \"sip.sec_mechanism.alg\",",
          "5432:             FT_STRING, BASE_NONE, NULL, 0x0,",
          "5433:             NULL, HFILL}",
          "5434:         },",
          "5435:         { &hf_sip_sec_mechanism_ealg,",
          "5436:             { \"ealg\",  \"sip.sec_mechanism.ealg\",",
          "5437:             FT_STRING, BASE_NONE, NULL, 0x0,",
          "5438:             NULL, HFILL}",
          "5439:         },",
          "5440:         { &hf_sip_sec_mechanism_prot,",
          "5441:             { \"prot\",  \"sip.sec_mechanism.prot\",",
          "5442:             FT_STRING, BASE_NONE, NULL, 0x0,",
          "5443:             NULL, HFILL}",
          "5444:         },",
          "5445:         { &hf_sip_sec_mechanism_spi_c,",
          "5446:             { \"spi-c\",  \"sip.sec_mechanism.spi_c\",",
          "5447:             FT_UINT32, BASE_DEC_HEX, NULL, 0x0,",
          "5448:             NULL, HFILL}",
          "5449:         },",
          "5450:         { &hf_sip_sec_mechanism_spi_s,",
          "5451:             { \"spi-s\",  \"sip.sec_mechanism.spi_s\",",
          "5452:             FT_UINT32, BASE_DEC_HEX, NULL, 0x0,",
          "5453:             NULL, HFILL}",
          "5454:         },",
          "5460:         { &hf_sip_raw_line,",
          "5461:                 { \"Raw SIP Line\",                \"raw_sip.line\",",
          "5462:                     FT_STRING, BASE_NONE,NULL,0x0,",
          "5463:                 NULL, HFILL }",
          "5467:     static gint *ett[] = {",
          "5468:         &ett_sip,",
          "5469:         &ett_sip_reqresp,",
          "5470:         &ett_sip_hdr,",
          "5471:         &ett_sip_ext_hdr,",
          "5472:         &ett_sip_element,",
          "5473:         &ett_sip_hist,",
          "5474:         &ett_sip_uri,",
          "5475:         &ett_sip_contact_item,",
          "5476:         &ett_sip_message_body,",
          "5477:         &ett_sip_cseq,",
          "5478:         &ett_sip_via,",
          "5479:         &ett_sip_reason,",
          "5480:         &ett_sip_security_client,",
          "5481:         &ett_sip_security_server,",
          "5482:         &ett_sip_security_verify,",
          "5483:         &ett_sip_rack,",
          "5484:         &ett_sip_record_route,",
          "5485:         &ett_sip_route,",
          "5486:         &ett_sip_ruri,",
          "5487:         &ett_sip_pai_uri,",
          "5488:         &ett_sip_pmiss_uri,",
          "5489:         &ett_sip_ppi_uri,",
          "5490:         &ett_sip_tc_uri,",
          "5491:         &ett_sip_to_uri,",
          "5492:         &ett_sip_from_uri,",
          "5493:         &ett_sip_curi",
          "5494:     };",
          "5495:     static gint *ett_raw[] = {",
          "5496:         &ett_raw_text,",
          "5497:     };",
          "5499:     static ei_register_info ei[] = {",
          "5500:         { &ei_sip_unrecognized_header, { \"sip.unrecognized_header\", PI_UNDECODED, PI_NOTE, \"Unrecognised SIP header\", EXPFILL }},",
          "5501:         { &ei_sip_header_not_terminated, { \"sip.header_not_terminated\", PI_MALFORMED, PI_WARN, \"Header not terminated by empty line (CRLF)\", EXPFILL }},",
          "5502:         { &ei_sip_odd_register_response, { \"sip.response.unusual\", PI_RESPONSE_CODE, PI_WARN, \"SIP Response is unusual\", EXPFILL }},",
          "5503:         { &ei_sip_sipsec_malformed, { \"sip.sec_mechanism.malformed\", PI_MALFORMED, PI_WARN, \"SIP Security-mechanism header malformed\", EXPFILL }},",
          "5504:     };",
          "5506:     module_t *sip_module;",
          "5507:     expert_module_t* expert_sip;",
          "5510:     proto_sip = proto_register_protocol(\"Session Initiation Protocol\",",
          "5511:                                         \"SIP\", \"sip\");",
          "5512:     proto_raw_sip = proto_register_protocol(\"Session Initiation Protocol (SIP as raw text)\",",
          "5513:                                             \"Raw_SIP\", \"raw_sip\");",
          "5514:     new_register_dissector(\"sip\", dissect_sip, proto_sip);",
          "5515:     register_dissector(\"sip.tcp\", dissect_sip_tcp, proto_sip);",
          "5518:     proto_register_field_array(proto_sip, hf, array_length(hf));",
          "5519:     proto_register_subtree_array(ett, array_length(ett));",
          "5520:     expert_sip = expert_register_protocol(proto_sip);",
          "5521:     expert_register_field_array(expert_sip, ei, array_length(ei));",
          "5522:     proto_register_subtree_array(ett_raw, array_length(ett_raw));",
          "5525:     proto_register_field_array(proto_raw_sip, raw_hf, array_length(raw_hf));",
          "5527:     sip_module = prefs_register_protocol(proto_sip, proto_reg_handoff_sip);",
          "5528:     range_convert_str(&global_sip_tcp_port_range, DEFAULT_SIP_PORT_RANGE, MAX_UDP_PORT);",
          "5531:     prefs_register_range_preference(sip_module, \"tcp.ports\", \"SIP TCP ports\",",
          "5532:                     \"TCP ports to be decoded as SIP (default: \"",
          "5533:                     DEFAULT_SIP_PORT_RANGE \")\",",
          "5534:                     &global_sip_tcp_port_range, MAX_UDP_PORT);",
          "5536:     prefs_register_uint_preference(sip_module, \"tls.port\",",
          "5541:     prefs_register_bool_preference(sip_module, \"display_raw_text\",",
          "5542:         \"Display raw text for SIP message\",",
          "5543:         \"Specifies that the raw text of the \"",
          "5544:         \"SIP message should be displayed \"",
          "5545:         \"in addition to the dissection tree\",",
          "5546:         &global_sip_raw_text);",
          "5547:     prefs_register_bool_preference(sip_module, \"display_raw_text_without_crlf\",",
          "5548:         \"Don't show '\\\\r\\\\n' in raw SIP messages\",",
          "5549:         \"If the raw text of the SIP message \"",
          "5550:         \"is displayed, the trailing carriage \"",
          "5551:         \"return and line feed are not shown\",",
          "5552:         &global_sip_raw_text_without_crlf);",
          "5553:     prefs_register_bool_preference(sip_module, \"strict_sip_version\",",
          "5554:         \"Enforce strict SIP version check (\" SIP2_HDR \")\",",
          "5555:         \"If enabled, only \" SIP2_HDR \" traffic will be dissected as SIP. \"",
          "5556:         \"Disable it to allow SIP traffic with a different version \"",
          "5557:         \"to be dissected as SIP.\",",
          "5558:         &strict_sip_version);",
          "5559:     prefs_register_bool_preference(sip_module, \"desegment_headers\",",
          "5560:         \"Reassemble SIP headers spanning multiple TCP segments\",",
          "5561:         \"Whether the SIP dissector should reassemble headers \"",
          "5562:         \"of a request spanning multiple TCP segments. \"",
          "5563:         \"To use this option, you must also enable \"",
          "5565:         &sip_desegment_headers);",
          "5566:     prefs_register_bool_preference(sip_module, \"desegment_body\",",
          "5567:         \"Reassemble SIP bodies spanning multiple TCP segments\",",
          "5568:         \"Whether the SIP dissector should use the \"",
          "5569:         \"\\\"Content-length:\\\" value, if present, to reassemble \"",
          "5570:         \"the body of a request spanning multiple TCP segments, \"",
          "5571:         \"and reassemble chunked data spanning multiple TCP segments. \"",
          "5572:         \"To use this option, you must also enable \"",
          "5573:             \"\\\"Allow subdissectors to reassemble TCP streams\\\" in the TCP protocol settings.\",",
          "5574:         &sip_desegment_body);",
          "5575:     prefs_register_bool_preference(sip_module, \"retrans_the_same_sport\",",
          "5576:         \"Retransmissions always use the same source port\",",
          "5577:         \"Whether retransmissions are detected coming from the same source port only.\",",
          "5578:         &sip_retrans_the_same_sport);",
          "5580:     prefs_register_obsolete_preference(sip_module, \"tcp.port\");",
          "5582:     register_init_routine(&sip_init_protocol);",
          "5583:     register_heur_dissector_list(\"sip\", &heur_subdissector_list);",
          "5585:     sip_tap = register_tap(\"sip\");",
          "5587:     ext_hdr_subdissector_table = register_dissector_table(\"sip.hdr\", \"SIP Extension header\", FT_STRING, BASE_NONE);",
          "5594:     static range_t *sip_tcp_port_range;",
          "5596:     static guint saved_sip_tls_port;",
          "5597:     static gboolean sip_prefs_initialized = FALSE;",
          "5599:     if (!sip_prefs_initialized) {",
          "5600:         dissector_handle_t sip_handle;",
          "5601:         sip_handle = find_dissector(\"sip\");",
          "5602:         sip_tcp_handle = find_dissector(\"sip.tcp\");",
          "5603:         sigcomp_handle = find_dissector(\"sigcomp\");",
          "5604:         sip_diag_handle = find_dissector(\"sip.diagnostic\");",
          "5606:         media_type_dissector_table = find_dissector_table(\"media_type\");",
          "5608:         dissector_add_uint(\"udp.port\", UDP_PORT_SIP, sip_handle);",
          "5609:         dissector_add_string(\"media_type\", \"message/sip\", sip_handle);",
          "5611:         heur_dissector_add(\"udp\", dissect_sip_heur, proto_sip);",
          "5612:         heur_dissector_add(\"tcp\", dissect_sip_tcp_heur, proto_sip);",
          "5613:         heur_dissector_add(\"sctp\", dissect_sip_heur, proto_sip);",
          "5614:         heur_dissector_add(\"stun\", dissect_sip_heur, proto_sip);",
          "5615:         sip_prefs_initialized = TRUE;",
          "5616:     } else {",
          "5617:         dissector_delete_uint_range(\"tcp.port\", sip_tcp_port_range, sip_tcp_handle);",
          "5618:         g_free(sip_tcp_port_range);",
          "5619:         ssl_dissector_delete(saved_sip_tls_port, \"sip.tcp\", TRUE);",
          "5620:     }",
          "5622:     sip_tcp_port_range = range_copy(global_sip_tcp_port_range);",
          "5623:     dissector_add_uint_range(\"tcp.port\", sip_tcp_port_range, sip_tcp_handle);",
          "5624:     saved_sip_tls_port = sip_tls_port;",
          "5625:     ssl_dissector_add(saved_sip_tls_port, \"sip.tcp\", TRUE);",
          "5627:     exported_pdu_tap = find_tap_id(EXPORT_PDU_TAP_NAME_LAYER_7);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "04c05a21e34cec326f1aff2f5f8a6e74e1ced984",
      "candidate_info": {
        "commit_hash": "04c05a21e34cec326f1aff2f5f8a6e74e1ced984",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/04c05a21e34cec326f1aff2f5f8a6e74e1ced984",
        "files": [
          "asn1/h245/packet-h245-template.c",
          "epan/dissectors/packet-ansi_a.c",
          "epan/dissectors/packet-applemidi.c",
          "epan/dissectors/packet-h245.c",
          "epan/dissectors/packet-rtp.c",
          "epan/dissectors/packet-rtp.h",
          "epan/dissectors/packet-sdp.c",
          "ui/gtk/voip_calls.c"
        ],
        "message": "Fix Bug 9920 Buildbot crash due to SDP/RTP mismatch\n\nFor details see comments in Bug 9920.\n\nThe executive summary:\nBug 9920 is a crash caused by a couple of issues:\n\n1) The memory ownership model for the rtp_dyn_payload hashtable is split: SDP\ncreates the rtp_dyn_payload hashtable, but RTP can free it. Since there isn't\n*one* pointer to the hashtable, RTP freeing it means SDP has a dangling\npointer.\n\n2) Either the SDP dissector shouldn't be creating two separate, unique\nhashtables for multiple media channels of the same addr:port, or RTP shouldn't\nbe free'ing the previous one.\n\nChange-Id: I436e67de6882f84aa82dcbdfe60bf313fe4fd99c\nReviewed-on: https://code.wireshark.org/review/918\nReviewed-by: Hadriel Kaplan <hadrielk@yahoo.com>\nReviewed-by: Anders Broman <a.broman58@gmail.com>",
        "before_after_code_files": [
          "asn1/h245/packet-h245-template.c||asn1/h245/packet-h245-template.c",
          "epan/dissectors/packet-ansi_a.c||epan/dissectors/packet-ansi_a.c",
          "epan/dissectors/packet-applemidi.c||epan/dissectors/packet-applemidi.c",
          "epan/dissectors/packet-h245.c||epan/dissectors/packet-h245.c",
          "epan/dissectors/packet-rtp.c||epan/dissectors/packet-rtp.c",
          "epan/dissectors/packet-rtp.h||epan/dissectors/packet-rtp.h",
          "epan/dissectors/packet-sdp.c||epan/dissectors/packet-sdp.c",
          "ui/gtk/voip_calls.c||ui/gtk/voip_calls.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "epan/dissectors/packet-rtp.c||epan/dissectors/packet-rtp.c",
            "epan/dissectors/packet-sdp.c||epan/dissectors/packet-sdp.c"
          ],
          "candidate": [
            "epan/dissectors/packet-rtp.c||epan/dissectors/packet-rtp.c",
            "epan/dissectors/packet-sdp.c||epan/dissectors/packet-sdp.c"
          ]
        }
      },
      "candidate_diff": {
        "asn1/h245/packet-h245-template.c||asn1/h245/packet-h245-template.c": [
          "File: asn1/h245/packet-h245-template.c -> asn1/h245/packet-h245-template.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "342: static void h245_setup_channels(packet_info *pinfo, channel_info_t *upcoming_channel_lcl)",
          "343: {",
          "346:  struct srtp_info *dummy_srtp_info = NULL;",
          "348:  if (!upcoming_channel_lcl) return;",
          "",
          "[Removed Lines]",
          "344:  gint *key;",
          "345:  GHashTable *rtp_dyn_payload = NULL;",
          "",
          "[Added Lines]",
          "344:  rtp_dyn_payload_t *rtp_dyn_payload = NULL;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "361:  if (upcoming_channel_lcl->rfc2198 > 0) {",
          "369:  }",
          "371:  if (upcoming_channel_lcl->srtp_flag) {",
          "",
          "[Removed Lines]",
          "362:   encoding_name_and_rate_t *encoding_name_and_rate = wmem_new(wmem_file_scope(), encoding_name_and_rate_t);",
          "363:   rtp_dyn_payload = g_hash_table_new(g_int_hash, g_int_equal);",
          "364:   encoding_name_and_rate->encoding_name = wmem_strdup(wmem_file_scope(), \"red\");",
          "365:   encoding_name_and_rate->sample_rate = 8000;",
          "366:   key = wmem_new(wmem_file_scope(), gint);",
          "368:   g_hash_table_insert(rtp_dyn_payload, key, encoding_name_and_rate);",
          "",
          "[Added Lines]",
          "361:   rtp_dyn_payload = rtp_dyn_payload_new();",
          "362:   rtp_dyn_payload_insert(rtp_dyn_payload, upcoming_channel_lcl->rfc2198, \"red\", 8000);",
          "",
          "---------------"
        ],
        "epan/dissectors/packet-ansi_a.c||epan/dissectors/packet-ansi_a.c": [
          "File: epan/dissectors/packet-ansi_a.c -> epan/dissectors/packet-ansi_a.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "6905:     gboolean                            first_assigned_found;",
          "6906:     gboolean                            rtp_dyn_payload_used;",
          "6907:     guint8                              rtp_payload_type;",
          "6913:     rtp_dyn_payload_used = FALSE;",
          "6915:     first_assigned_found = FALSE;",
          "",
          "[Removed Lines]",
          "6908:     GHashTable                          *rtp_dyn_payload;",
          "6909:     gint                                *key;",
          "6910:     encoding_name_and_rate_t            *encoding_name_and_rate;",
          "6912:     rtp_dyn_payload = g_hash_table_new(g_int_hash, g_int_equal);",
          "",
          "[Added Lines]",
          "6908:     rtp_dyn_payload_t                  *rtp_dyn_payload;",
          "6910:     rtp_dyn_payload = rtp_dyn_payload_new();",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "7066:         if (format_assigned &&",
          "7067:             (first_assigned_found == FALSE))",
          "7068:         {",
          "7077:             rtp_dyn_payload_used = TRUE;",
          "7079:             first_assigned_found = TRUE;",
          "",
          "[Removed Lines]",
          "7069:             key  = wmem_new(wmem_file_scope(), gint);",
          "7072:             encoding_name_and_rate = wmem_new(wmem_file_scope(), encoding_name_and_rate_t);",
          "7073:             encoding_name_and_rate->encoding_name = wmem_strdup(wmem_file_scope(), mime_type);",
          "7074:             encoding_name_and_rate->sample_rate = sample_rate;",
          "7076:             g_hash_table_insert(rtp_dyn_payload, key, encoding_name_and_rate);",
          "",
          "[Added Lines]",
          "7067:             rtp_dyn_payload_insert(rtp_dyn_payload, rtp_payload_type, mime_type, sample_rate);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "7084:         if (in_band_format_assigned)",
          "7085:         {",
          "7094:             rtp_dyn_payload_used = TRUE;",
          "7095:         }",
          "",
          "[Removed Lines]",
          "7086:             key  = (gint *) wmem_alloc(wmem_file_scope(), sizeof(gint));",
          "7089:             encoding_name_and_rate = wmem_new(wmem_file_scope(), encoding_name_and_rate_t);",
          "7090:             encoding_name_and_rate->encoding_name = wmem_strdup(wmem_file_scope(), \"telephone-event\");",
          "7091:             encoding_name_and_rate->sample_rate = sample_rate;",
          "7093:             g_hash_table_insert(rtp_dyn_payload, key, encoding_name_and_rate);",
          "",
          "[Added Lines]",
          "7077:             rtp_dyn_payload_insert(rtp_dyn_payload, rtp_payload_type, \"telephone-event\", sample_rate);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "7100:     if (rtp_dyn_payload_used == FALSE)",
          "7101:     {",
          "7103:     }",
          "7105:     EXTRANEOUS_DATA_CHECK(len, curr_offset - offset);",
          "",
          "[Removed Lines]",
          "7102:         rtp_free_hash_dyn_payload(rtp_dyn_payload);",
          "",
          "[Added Lines]",
          "7086:         rtp_dyn_payload_free(rtp_dyn_payload);",
          "",
          "---------------"
        ],
        "epan/dissectors/packet-applemidi.c||epan/dissectors/packet-applemidi.c": [
          "File: epan/dissectors/packet-applemidi.c -> epan/dissectors/packet-applemidi.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "285:  guint16   command;",
          "286:  conversation_t *p_conv;",
          "292:  if ( tvb_length( tvb ) < 4)",
          "",
          "[Removed Lines]",
          "288:  encoding_name_and_rate_t *encoding_name_and_rate = NULL;",
          "289:  GHashTable *rtp_dyn_payload = NULL;",
          "290:  gint *key;",
          "",
          "[Added Lines]",
          "288:  rtp_dyn_payload_t *rtp_dyn_payload = NULL;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "309:         rtp_add_address( pinfo, &pinfo->src, pinfo->srcport, 0, APPLEMIDI_DISSECTOR_SHORTNAME,",
          "310:     pinfo->fd->num, FALSE, rtp_dyn_payload);",
          "",
          "[Removed Lines]",
          "302:  encoding_name_and_rate = wmem_new(wmem_file_scope(), encoding_name_and_rate_t);",
          "303:  rtp_dyn_payload = g_hash_table_new( g_int_hash, g_int_equal );",
          "304:  encoding_name_and_rate->encoding_name = wmem_strdup( wmem_file_scope(), \"rtp-midi\" );",
          "305:  encoding_name_and_rate->sample_rate = 10000;",
          "306:  key = wmem_new(wmem_file_scope(), gint);",
          "308:  g_hash_table_insert( rtp_dyn_payload, key, encoding_name_and_rate );",
          "",
          "[Added Lines]",
          "300:  rtp_dyn_payload = rtp_dyn_payload_new();",
          "301:  rtp_dyn_payload_insert(rtp_dyn_payload, 97, \"rtp-midi\", 10000);",
          "",
          "---------------"
        ],
        "epan/dissectors/packet-h245.c||epan/dissectors/packet-h245.c": [
          "File: epan/dissectors/packet-h245.c -> epan/dissectors/packet-h245.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "473: static void h245_setup_channels(packet_info *pinfo, channel_info_t *upcoming_channel_lcl)",
          "474: {",
          "477:  struct srtp_info *dummy_srtp_info = NULL;",
          "479:  if (!upcoming_channel_lcl) return;",
          "",
          "[Removed Lines]",
          "475:  gint *key;",
          "476:  GHashTable *rtp_dyn_payload = NULL;",
          "",
          "[Added Lines]",
          "475:  rtp_dyn_payload_t *rtp_dyn_payload = NULL;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "492:  if (upcoming_channel_lcl->rfc2198 > 0) {",
          "500:  }",
          "502:  if (upcoming_channel_lcl->srtp_flag) {",
          "",
          "[Removed Lines]",
          "493:   encoding_name_and_rate_t *encoding_name_and_rate = wmem_new(wmem_file_scope(), encoding_name_and_rate_t);",
          "494:   rtp_dyn_payload = g_hash_table_new(g_int_hash, g_int_equal);",
          "495:   encoding_name_and_rate->encoding_name = wmem_strdup(wmem_file_scope(), \"red\");",
          "496:   encoding_name_and_rate->sample_rate = 8000;",
          "497:   key = wmem_new(wmem_file_scope(), gint);",
          "499:   g_hash_table_insert(rtp_dyn_payload, key, encoding_name_and_rate);",
          "",
          "[Added Lines]",
          "492:   rtp_dyn_payload = rtp_dyn_payload_new();",
          "493:   rtp_dyn_payload_insert(rtp_dyn_payload, upcoming_channel_lcl->rfc2198, \"red\", 8000);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1932: static int ett_h245 = -1;",
          "",
          "[Removed Lines]",
          "1929: #line 392 \"../../asn1/h245/packet-h245-template.c\"",
          "",
          "[Added Lines]",
          "1923: #line 386 \"../../asn1/h245/packet-h245-template.c\"",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2427: static gint ett_h245_MobileMultilinkReconfigurationIndication = -1;",
          "2433: static int dissect_h245_MultimediaSystemControlMessage(tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_);",
          "",
          "[Removed Lines]",
          "2430: #line 397 \"../../asn1/h245/packet-h245-template.c\"",
          "",
          "[Added Lines]",
          "2424: #line 391 \"../../asn1/h245/packet-h245-template.c\"",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "14499: static void",
          "14500: dissect_h245(tvbuff_t *tvb, packet_info *pinfo, proto_tree *parent_tree)",
          "",
          "[Removed Lines]",
          "14497: #line 406 \"../../asn1/h245/packet-h245-template.c\"",
          "",
          "[Added Lines]",
          "14491: #line 400 \"../../asn1/h245/packet-h245-template.c\"",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "20188:         NULL, HFILL }},",
          "20192:   };",
          "",
          "[Removed Lines]",
          "20191: #line 487 \"../../asn1/h245/packet-h245-template.c\"",
          "",
          "[Added Lines]",
          "20185: #line 481 \"../../asn1/h245/packet-h245-template.c\"",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "20691:     &ett_h245_MobileMultilinkReconfigurationIndication,",
          "20695:   };",
          "20696:   module_t *h245_module;",
          "",
          "[Removed Lines]",
          "20694: #line 494 \"../../asn1/h245/packet-h245-template.c\"",
          "",
          "[Added Lines]",
          "20688: #line 488 \"../../asn1/h245/packet-h245-template.c\"",
          "",
          "---------------"
        ],
        "epan/dissectors/packet-rtp.c||epan/dissectors/packet-rtp.c": [
          "File: epan/dissectors/packet-rtp.c -> epan/dissectors/packet-rtp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "102:     wmem_tree_t *multisegment_pdus;",
          "103: } rtp_private_conv_info;",
          "105: static reassembly_table rtp_reassembly_table;",
          "107: static int hf_rtp_fragments = -1;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "105: typedef struct {",
          "106:     char *encoding_name;",
          "107:     int   sample_rate;",
          "108: } encoding_name_and_rate_t;",
          "110: struct _rtp_dyn_payload_t",
          "111: {",
          "112:     GHashTable *table;",
          "113:     size_t ref_count;",
          "114: };",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "809: #ifdef DEBUG_CONVERSATION",
          "811: static void",
          "814:     encoding_name_and_rate_t *encoding = (encoding_name_and_rate_t*) value;",
          "817:     if (encoding) {",
          "818:         DPRINT2((\"encoding_name=%s\",",
          "819:                 encoding->encoding_name ? encoding->encoding_name : \"NULL\"));",
          "",
          "[Removed Lines]",
          "812: rtp_dyn_payload_table_foreach_func (gpointer key, gpointer value, gpointer user_data _U_) {",
          "813:     gint* pt = (gint*) key;",
          "816:     DPRINT2((\"pt=%d\",*pt));",
          "",
          "[Added Lines]",
          "823: rtp_dyn_payload_table_foreach_func(gpointer key, gpointer value, gpointer user_data _U_) {",
          "824:     guint pt = GPOINTER_TO_UINT(key);",
          "827:     DPRINT2((\"pt=%d\",pt));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "822:         DPRINT2((\"encoding=NULL\"));",
          "823:     }",
          "824: }",
          "826:     DPRINT2((\"rtp_dyn_payload hash table contents:\"));",
          "827:     DINDENT();",
          "838:     DENDENT();",
          "839: }",
          "",
          "[Removed Lines]",
          "825: static void rtp_dump_dyn_payload(GHashTable *rtp_dyn_payload) {",
          "828:     if (!rtp_dyn_payload) {",
          "829:         DPRINT2((\"null rtp_dyn_payload\"));",
          "830:         DENDENT();",
          "831:         return;",
          "832:     }",
          "833:     if (g_hash_table_size(rtp_dyn_payload) == 0) {",
          "834:         DPRINT2((\"rtp_dyn_payload is empty\"));",
          "835:     } else {",
          "836:         g_hash_table_foreach(rtp_dyn_payload, rtp_dyn_payload_table_foreach_func, NULL);",
          "837:     }",
          "",
          "[Added Lines]",
          "837: void",
          "838: rtp_dump_dyn_payload(rtp_dyn_payload_t *rtp_dyn_payload) {",
          "841:         if (!rtp_dyn_payload) {",
          "842:             DPRINT2((\"null pointer to rtp_dyn_payload\"));",
          "843:             DENDENT();",
          "844:             return;",
          "845:         }",
          "846:         DPRINT2((\"ref_count=%\" G_GSIZE_FORMAT, rtp_dyn_payload->ref_count));",
          "847:         if (!rtp_dyn_payload->table) {",
          "848:             DPRINT2((\"null rtp_dyn_payload table\"));",
          "849:             DENDENT();",
          "850:             return;",
          "851:         }",
          "852:         if (g_hash_table_size(rtp_dyn_payload->table) == 0) {",
          "853:             DPRINT2((\"rtp_dyn_payload has no entries\"));",
          "854:         } else {",
          "855:             g_hash_table_foreach(rtp_dyn_payload->table, rtp_dyn_payload_table_foreach_func, NULL);",
          "856:         }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "847:                   &addresses_reassembly_table_functions);",
          "848: }",
          "850: void",
          "852: {",
          "856: }",
          "859: void",
          "860: bluetooth_add_address(packet_info *pinfo, address *addr,",
          "",
          "[Removed Lines]",
          "851: rtp_free_hash_dyn_payload(GHashTable *rtp_dyn_payload)",
          "853:     if (rtp_dyn_payload == NULL) return;",
          "854:     g_hash_table_destroy(rtp_dyn_payload);",
          "855:     rtp_dyn_payload = NULL;",
          "",
          "[Added Lines]",
          "870:    This is necessary because we need to g_hash_table_destroy() them, either individually or",
          "871:    all at once at the end of the wmem file scope. Since rtp_dyn_payload_free() removes them",
          "872:    individually, we need to remove those then; and when the file scope is over, we have a",
          "873:    single registered callback walk this GHashTable and destroy each member as well as this",
          "874:    GHashTable.",
          "876: static GHashTable *rtp_dyn_payloads = NULL;",
          "880: static void",
          "881: rtp_dyn_payload_value_destroy(gpointer data)",
          "882: {",
          "883:     encoding_name_and_rate_t *encoding_name_and_rate_pt = (encoding_name_and_rate_t*) data;",
          "884:     wmem_free(wmem_file_scope(), encoding_name_and_rate_pt->encoding_name);",
          "885:     wmem_free(wmem_file_scope(), encoding_name_and_rate_pt);",
          "886: }",
          "889: static gboolean",
          "890: rtp_dyn_payloads_table_steal_func(gpointer key _U_, gpointer value, gpointer user_data _U_)",
          "891: {",
          "892:     rtp_dyn_payload_t *rtp_dyn_payload = (rtp_dyn_payload_t *)value;",
          "894: #ifdef DEBUG_CONVERSATION",
          "895:     DPRINT((\"about to steal_all and destroy the following:\"));",
          "896:     DINDENT();",
          "897:     rtp_dump_dyn_payload(rtp_dyn_payload);",
          "898:     DENDENT();",
          "899: #endif",
          "901:     if (rtp_dyn_payload->ref_count == 0) {",
          "903:         g_error(\"rtp_dyn_payload cannot be free'd because it should already have been!\\n\");",
          "904:     }",
          "905:     else if (rtp_dyn_payload->table) {",
          "908:         g_hash_table_steal_all(rtp_dyn_payload->table);",
          "909:         g_hash_table_destroy(rtp_dyn_payload->table);",
          "910:     }",
          "912:     return TRUE;",
          "913: }",
          "916:    which are pointed to by the single rtp_dyn_payloads GHashTable above.",
          "918: static gboolean",
          "919: wmem_rtp_dyn_payload_destroy_cb(wmem_allocator_t *allocator _U_, wmem_cb_event_t event _U_,",
          "920:         void *user_data _U_)",
          "921: {",
          "922:     g_assert(rtp_dyn_payloads);",
          "924:     DPRINT((\"destroying %u remaining rtp_dyn_payload_t's\", g_hash_table_size(rtp_dyn_payloads)));",
          "928:     g_hash_table_foreach_steal(rtp_dyn_payloads, rtp_dyn_payloads_table_steal_func, NULL);",
          "929:     g_hash_table_destroy(rtp_dyn_payloads);",
          "930:     rtp_dyn_payloads = NULL;",
          "933:     return FALSE;",
          "934: }",
          "937:    but those are called both at init and cleanup times, and the cleanup time is before",
          "938:    wmem scope is exited, so we ignore this if rtp_dyn_payloads is not NULL.",
          "940: static void",
          "941: rtp_dyn_payloads_init(void)",
          "942: {",
          "943:     if (rtp_dyn_payloads == NULL) {",
          "944:         rtp_dyn_payloads = g_hash_table_new(NULL, NULL);",
          "945:         wmem_register_callback(wmem_file_scope(), wmem_rtp_dyn_payload_destroy_cb, NULL);",
          "946:     }",
          "947: }",
          "950: rtp_dyn_payload_t* rtp_dyn_payload_new(void)",
          "951: {",
          "953:     rtp_dyn_payload_t * rtp_dyn_payload = wmem_new(wmem_file_scope(), rtp_dyn_payload_t);",
          "954:     rtp_dyn_payload->table = g_hash_table_new_full(NULL, NULL, NULL, rtp_dyn_payload_value_destroy);",
          "955:     rtp_dyn_payload->ref_count = 1;",
          "958:     g_hash_table_insert(rtp_dyn_payloads, rtp_dyn_payload, rtp_dyn_payload);",
          "960:     return rtp_dyn_payload;",
          "961: }",
          "963: static rtp_dyn_payload_t*",
          "964: rtp_dyn_payload_ref(rtp_dyn_payload_t *rtp_dyn_payload)",
          "965: {",
          "966:     if (rtp_dyn_payload) {",
          "967:         rtp_dyn_payload->ref_count++;",
          "968:     }",
          "969:     return rtp_dyn_payload;",
          "970: }",
          "973:    This makes copies of the encoding name, scoped to the life of the capture file or sooner if",
          "976: rtp_dyn_payload_insert(rtp_dyn_payload_t *rtp_dyn_payload,",
          "977:                        const guint8 pt,",
          "978:                        const gchar* encoding_name,",
          "979:                        const int sample_rate)",
          "980: {",
          "981:     if (rtp_dyn_payload && rtp_dyn_payload->table) {",
          "982:         encoding_name_and_rate_t *encoding_name_and_rate_pt =",
          "983:                     wmem_new(wmem_file_scope(), encoding_name_and_rate_t);",
          "984:         encoding_name_and_rate_pt->encoding_name = wmem_strdup(wmem_file_scope(), encoding_name);",
          "985:         encoding_name_and_rate_pt->sample_rate = sample_rate;",
          "986:         g_hash_table_insert(rtp_dyn_payload->table, GUINT_TO_POINTER(pt), encoding_name_and_rate_pt);",
          "987:     }",
          "988: }",
          "991:    This makes copies of the encoding name, scoped to the life of the capture file or sooner if",
          "993: void",
          "994: rtp_dyn_payload_replace(rtp_dyn_payload_t *rtp_dyn_payload,",
          "995:                         const guint8 pt,",
          "996:                         const gchar* encoding_name,",
          "997:                         const int sample_rate)",
          "998: {",
          "999:     if (rtp_dyn_payload && rtp_dyn_payload->table) {",
          "1000:         encoding_name_and_rate_t *encoding_name_and_rate_pt =",
          "1001:                     wmem_new(wmem_file_scope(), encoding_name_and_rate_t);",
          "1002:         encoding_name_and_rate_pt->encoding_name = wmem_strdup(wmem_file_scope(), encoding_name);",
          "1003:         encoding_name_and_rate_pt->sample_rate = sample_rate;",
          "1004:         g_hash_table_replace(rtp_dyn_payload->table, GUINT_TO_POINTER(pt), encoding_name_and_rate_pt);",
          "1005:     }",
          "1006: }",
          "1009: gboolean",
          "1010: rtp_dyn_payload_remove(rtp_dyn_payload_t *rtp_dyn_payload, const guint8 pt)",
          "1012:     return (rtp_dyn_payload && rtp_dyn_payload->table &&",
          "1013:             g_hash_table_remove(rtp_dyn_payload->table, GUINT_TO_POINTER(pt)));",
          "1014: }",
          "1017: const gchar*",
          "1018: rtp_dyn_payload_get_name(rtp_dyn_payload_t *rtp_dyn_payload, const guint8 pt)",
          "1019: {",
          "1020:     encoding_name_and_rate_t *encoding_name_and_rate_pt;",
          "1022:     if (!rtp_dyn_payload || !rtp_dyn_payload->table) return NULL;",
          "1024:     encoding_name_and_rate_pt = (encoding_name_and_rate_t*)g_hash_table_lookup(rtp_dyn_payload->table,",
          "1025:                                                                                GUINT_TO_POINTER(pt));",
          "1027:     return (encoding_name_and_rate_pt ? encoding_name_and_rate_pt->encoding_name : NULL);",
          "1028: }",
          "1031:    successful, else FALSE. The encoding string pointed to is only valid until the entry is",
          "1033: gboolean",
          "1034: rtp_dyn_payload_get_full(rtp_dyn_payload_t *rtp_dyn_payload, const guint8 pt,",
          "1035:                          const gchar **encoding_name, int *sample_rate)",
          "1036: {",
          "1037:     encoding_name_and_rate_t *encoding_name_and_rate_pt;",
          "1041:     if (!rtp_dyn_payload || !rtp_dyn_payload->table) return FALSE;",
          "1043:     encoding_name_and_rate_pt = (encoding_name_and_rate_t*)g_hash_table_lookup(rtp_dyn_payload->table,",
          "1044:                                                                                GUINT_TO_POINTER(pt));",
          "1046:     if (encoding_name_and_rate_pt) {",
          "1049:     }",
          "1051:     return (encoding_name_and_rate_pt != NULL);",
          "1056: void",
          "1057: rtp_dyn_payload_free(rtp_dyn_payload_t *rtp_dyn_payload)",
          "1058: {",
          "1059:     if (!rtp_dyn_payload) return;",
          "1061:     if (rtp_dyn_payload->ref_count > 0)",
          "1062:         --(rtp_dyn_payload->ref_count);",
          "1064:     if (rtp_dyn_payload->ref_count == 0) {",
          "1066: #ifdef DEBUG_CONVERSATION",
          "1067:         DPRINT((\"free'ing the following rtp_dyn_payload:\"));",
          "1068:         DINDENT();",
          "1069:         rtp_dump_dyn_payload(rtp_dyn_payload);",
          "1070:         DENDENT();",
          "1071: #endif",
          "1074:         g_assert(rtp_dyn_payloads);",
          "1075:         if (!g_hash_table_remove(rtp_dyn_payloads, rtp_dyn_payload)) {",
          "1076:             g_error(\"rtp_dyn_payload not found in rtp_dyn_payloads table to remove!\");",
          "1077:         }",
          "1081:         if (rtp_dyn_payload->table)",
          "1082:             g_hash_table_destroy(rtp_dyn_payload->table);",
          "1085:         wmem_free(wmem_file_scope(), rtp_dyn_payload);",
          "1086:     }",
          "1087: }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "933:     g_strlcpy(p_conv_data->method, setup_method, MAX_RTP_SETUP_METHOD_SIZE+1);",
          "934:     p_conv_data->frame_number = setup_frame_number;",
          "",
          "[Removed Lines]",
          "931:     rtp_free_hash_dyn_payload(p_conv_data->rtp_dyn_payload);",
          "",
          "[Added Lines]",
          "1161:     rtp_dyn_payload_free(p_conv_data->rtp_dyn_payload);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "941: void",
          "942: srtp_add_address(packet_info *pinfo, address *addr, int port, int other_port,",
          "943:          const gchar *setup_method, guint32 setup_frame_number,",
          "945:          struct srtp_info *srtp_info)",
          "946: {",
          "947:     address null_addr;",
          "",
          "[Removed Lines]",
          "944:          gboolean is_video _U_, GHashTable *rtp_dyn_payload,",
          "",
          "[Added Lines]",
          "1174:          gboolean is_video _U_, rtp_dyn_payload_t *rtp_dyn_payload,",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1028:     g_strlcpy(p_conv_data->method, setup_method, MAX_RTP_SETUP_METHOD_SIZE+1);",
          "1029:     p_conv_data->frame_number = setup_frame_number;",
          "1030:     p_conv_data->is_video = is_video;",
          "1032:     p_conv_data->srtp_info = srtp_info;",
          "1033:     p_conv_data->bta2dp_info = NULL;",
          "1034:     p_conv_data->btvdp_info = NULL;",
          "",
          "[Removed Lines]",
          "1025:     if (p_conv_data->rtp_dyn_payload != rtp_dyn_payload)",
          "1026:         rtp_free_hash_dyn_payload(p_conv_data->rtp_dyn_payload);",
          "1031:     p_conv_data->rtp_dyn_payload = rtp_dyn_payload;",
          "",
          "[Added Lines]",
          "1255:     if (p_conv_data->rtp_dyn_payload != rtp_dyn_payload) {",
          "1256:         rtp_dyn_payload_free(p_conv_data->rtp_dyn_payload);",
          "1257:         p_conv_data->rtp_dyn_payload = rtp_dyn_payload_ref(rtp_dyn_payload);",
          "1258:     } else {",
          "1259:         DPRINT((\"passed-in rtp_dyn_payload is the same as in the conversation\"));",
          "1260:     }",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1038: void",
          "1039: rtp_add_address(packet_info *pinfo, address *addr, int port, int other_port,",
          "1040:         const gchar *setup_method, guint32 setup_frame_number,",
          "1042: {",
          "1043:     srtp_add_address(pinfo, addr, port, other_port, setup_method, setup_frame_number, is_video, rtp_dyn_payload, NULL);",
          "1044: }",
          "",
          "[Removed Lines]",
          "1041:         gboolean is_video , GHashTable *rtp_dyn_payload)",
          "",
          "[Added Lines]",
          "1274:         gboolean is_video , rtp_dyn_payload_t *rtp_dyn_payload)",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1163:             payload_type >= PT_UNDF_96 && payload_type <= PT_UNDF_127) {",
          "1165:         if (p_conv_data && p_conv_data->rtp_dyn_payload) {",
          "1173:                 found_match = dissector_try_string(rtp_dyn_pt_dissector_table,",
          "1174:                                    payload_type_str, newtvb, pinfo, tree, NULL);",
          "",
          "[Removed Lines]",
          "1166:             gchar *payload_type_str = NULL;",
          "1167:             encoding_name_and_rate_t *encoding_name_and_rate_pt = NULL;",
          "1168:             encoding_name_and_rate_pt = (encoding_name_and_rate_t *)g_hash_table_lookup(p_conv_data->rtp_dyn_payload, &payload_type);",
          "1169:             if (encoding_name_and_rate_pt) {",
          "1170:                 payload_type_str = encoding_name_and_rate_pt->encoding_name;",
          "1171:             }",
          "1172:             if (payload_type_str){",
          "",
          "[Added Lines]",
          "1399:             const gchar *payload_type_str = rtp_dyn_payload_get_name(p_conv_data->rtp_dyn_payload, payload_type);",
          "1400:             if (payload_type_str) {",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1452:     rfc2198_hdr *hdr_last, *hdr_new;",
          "1453:     rfc2198_hdr *hdr_chain = NULL;",
          "1454:     struct _rtp_conversation_info *p_conv_data= NULL;",
          "1458:     p_conv_data = (struct _rtp_conversation_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_rtp, 0);",
          "",
          "[Removed Lines]",
          "1455:     gchar *payload_type_str;",
          "",
          "[Added Lines]",
          "1683:     const gchar *payload_type_str;",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1478:         if ((hdr_new->pt > 95) && (hdr_new->pt < 128)) {",
          "1479:             if (p_conv_data && p_conv_data->rtp_dyn_payload){",
          "1485:             }",
          "1486:         }",
          "",
          "[Removed Lines]",
          "1480:                 encoding_name_and_rate_t *encoding_name_and_rate_pt = NULL;",
          "1481:                 encoding_name_and_rate_pt = (encoding_name_and_rate_t *)g_hash_table_lookup(p_conv_data->rtp_dyn_payload, &hdr_new->pt);",
          "1482:                 if (encoding_name_and_rate_pt) {",
          "1483:                     payload_type_str = encoding_name_and_rate_pt->encoding_name;",
          "1484:                 }",
          "",
          "[Added Lines]",
          "1708:                 payload_type_str = rtp_dyn_payload_get_name(p_conv_data->rtp_dyn_payload, hdr_new->pt);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1645:     unsigned int csrc_count;",
          "1646:     gboolean    marker_set;",
          "1647:     unsigned int payload_type;",
          "1649:     gboolean    is_srtp = FALSE;",
          "1650:     unsigned int i            = 0;",
          "1651:     unsigned int hdr_extension_len= 0;",
          "",
          "[Removed Lines]",
          "1648:     gchar *payload_type_str = NULL;",
          "",
          "[Added Lines]",
          "1872:     const gchar *payload_type_str = NULL;",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1828:     if ( (payload_type>95) && (payload_type<128) ) {",
          "1832: #ifdef DEBUG_CONVERSATION",
          "1833:             rtp_dump_dyn_payload(p_conv_data->rtp_dyn_payload);",
          "1834: #endif",
          "1835:             DPRINT((\"looking up conversation data for dyn_pt=%d\", payload_type));",
          "1843:                 DPRINT((\"found conversation data for dyn_pt=%d, enc_name=%s\",",
          "1847:             }",
          "1848:         }",
          "1849:     }",
          "",
          "[Removed Lines]",
          "1829:         if (p_conv_data && p_conv_data->rtp_dyn_payload){",
          "1830:             encoding_name_and_rate_t *encoding_name_and_rate_pt = NULL;",
          "1837:             encoding_name_and_rate_pt = (encoding_name_and_rate_t *)g_hash_table_lookup(p_conv_data->rtp_dyn_payload, &payload_type);",
          "1839:             DPRINT((\"did %sfind conversation data for dyn_pt=%d\",",
          "1840:                     encoding_name_and_rate_pt?\"\":\"not \", payload_type));",
          "1842:             if (encoding_name_and_rate_pt) {",
          "1844:                         payload_type,encoding_name_and_rate_pt->encoding_name));",
          "1845:                 rtp_info->info_payload_type_str = payload_type_str = encoding_name_and_rate_pt->encoding_name;",
          "1846:                 rtp_info->info_payload_rate = encoding_name_and_rate_pt->sample_rate;",
          "",
          "[Added Lines]",
          "2053:         if (p_conv_data && p_conv_data->rtp_dyn_payload) {",
          "2054:             int sample_rate = 0;",
          "2061:             if (rtp_dyn_payload_get_full(p_conv_data->rtp_dyn_payload, payload_type,",
          "2062:                                         &payload_type_str, &sample_rate)) {",
          "2064:                         payload_type, payload_type_str));",
          "2065:                 rtp_info->info_payload_type_str = payload_type_str;",
          "2066:                 rtp_info->info_payload_rate     = sample_rate;",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "3338:                                     &rtp_rfc2198_pt);",
          "3340:     register_init_routine(rtp_fragment_init);",
          "3341: }",
          "3343: void",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3564:     register_init_routine(rtp_dyn_payloads_init);",
          "",
          "---------------"
        ],
        "epan/dissectors/packet-rtp.h||epan/dissectors/packet-rtp.h": [
          "File: epan/dissectors/packet-rtp.h -> epan/dissectors/packet-rtp.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "100: #endif",
          "101: };",
          "104: #define MAX_RTP_SETUP_METHOD_SIZE 7",
          "105: struct _rtp_conversation_info",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "104: typedef struct _rtp_dyn_payload_t rtp_dyn_payload_t;",
          "107:    dynamic payload information. Internally, RTP creates the GHashTable with a wmem file scope",
          "108:    and increments the ref_count when it saves the info to conversations later. The calling",
          "109:    dissector (SDP, H.245, etc.) uses these functions as an interface. If the calling dissector",
          "110:    is done with the rtp_dyn_payload_t* for good, it should call rtp_dyn_payload_free() which",
          "111:    will decrement the ref_count and free's it if the ref_count is 0. In the worst case, it",
          "112:    will get free'd when the wmem file scope is over.",
          "114:    This was changed because there were too many bugs with SDP's handling of memory ownership",
          "115:    of the GHashTable, with RTP freeing things SDP didn't think were free'ed. And also because",
          "116:    the GHashTables never got free'd in many cases by several dissectors.",
          "120: WS_DLL_PUBLIC",
          "121: rtp_dyn_payload_t* rtp_dyn_payload_new(void);",
          "124:    This makes copies of the encoding name, scoped to the life of the capture file or sooner if",
          "126: WS_DLL_PUBLIC",
          "127: void rtp_dyn_payload_insert(rtp_dyn_payload_t *rtp_dyn_payload,",
          "128:        const guint8 pt,",
          "129:        const gchar* encoding_name,",
          "130:        const int sample_rate);",
          "133:    This makes copies of the encoding name, scoped to the life of the capture file or sooner if",
          "135: WS_DLL_PUBLIC",
          "136: void rtp_dyn_payload_replace(rtp_dyn_payload_t *rtp_dyn_payload,",
          "137:        const guint8 pt,",
          "138:        const gchar* encoding_name,",
          "139:        const int sample_rate);",
          "142: WS_DLL_PUBLIC",
          "143: gboolean rtp_dyn_payload_remove(rtp_dyn_payload_t *rtp_dyn_payload, const guint8 pt);",
          "146:    until the entry is replaced, removed, or the hash table is destroyed, so duplicate it if",
          "148: WS_DLL_PUBLIC",
          "149: const gchar* rtp_dyn_payload_get_name(rtp_dyn_payload_t *rtp_dyn_payload, const guint8 pt);",
          "152:    successful, else FALSE. The encoding string pointed to is only valid until the entry is",
          "154: WS_DLL_PUBLIC",
          "155: gboolean rtp_dyn_payload_get_full(rtp_dyn_payload_t *rtp_dyn_payload, const guint8 pt,",
          "156:           const gchar **encoding_name, int *sample_rate);",
          "160: WS_DLL_PUBLIC",
          "161: void rtp_dyn_payload_free(rtp_dyn_payload_t *rtp_dyn_payload);",
          "164: #ifdef DEBUG_CONVERSATION",
          "166: void rtp_dump_dyn_payload(rtp_dyn_payload_t *rtp_dyn_payload);",
          "167: #endif",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "121:  btvdp_codec_info_t *btvdp_info;",
          "122: };",
          "130: WS_DLL_PUBLIC",
          "131: void rtp_add_address(packet_info *pinfo,",
          "",
          "[Removed Lines]",
          "124: typedef struct {",
          "125:  char *encoding_name;",
          "126:  int   sample_rate;",
          "127: } encoding_name_and_rate_t;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "134:                      const gchar *setup_method,",
          "135:                      guint32 setup_frame_number,",
          "136:       gboolean is_video,",
          "140: WS_DLL_PUBLIC",
          "",
          "[Removed Lines]",
          "137:                      GHashTable *rtp_dyn_payload);",
          "",
          "[Added Lines]",
          "198:                      rtp_dyn_payload_t *rtp_dyn_payload);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "144:                      const gchar *setup_method,",
          "145:                      guint32 setup_frame_number,",
          "146:       gboolean is_video,",
          "148:                      struct srtp_info *srtp_info);",
          "",
          "[Removed Lines]",
          "147:                      GHashTable *rtp_dyn_payload,",
          "",
          "[Added Lines]",
          "208:                      rtp_dyn_payload_t *rtp_dyn_payload,",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "152: bluetooth_add_address(packet_info *pinfo, address *addr,",
          "153:          const gchar *setup_method, guint32 setup_frame_number,",
          "154:          gboolean is_video, void *data);",
          "",
          "[Removed Lines]",
          "157: WS_DLL_PUBLIC",
          "158: void rtp_free_hash_dyn_payload(GHashTable *rtp_dyn_payload);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "epan/dissectors/packet-sdp.c||epan/dissectors/packet-sdp.c": [
          "File: epan/dissectors/packet-sdp.c -> epan/dissectors/packet-sdp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "41: #include <epan/addr_resolv.h>",
          "43: #include \"packet-sdp.h\"",
          "44: #include \"packet-rtp.h\"",
          "46: #include \"packet-rtcp.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "47: #include \"conversation_debug.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "52: #include \"packet-h264.h\"",
          "53: #include \"packet-mp4ves.h\"",
          "59: void proto_register_sdp(void);",
          "60: void proto_reg_handoff_sdp(void);",
          "",
          "[Removed Lines]",
          "57: #include \"conversation_debug.h\"",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "208: typedef struct {",
          "209:     gint32 pt[SDP_MAX_RTP_PAYLOAD_TYPES];",
          "210:     gint8 pt_count;",
          "212:     gboolean set_rtp;",
          "213: } transport_media_pt_t;",
          "",
          "[Removed Lines]",
          "211:     GHashTable *rtp_dyn_payload;",
          "",
          "[Added Lines]",
          "212:     rtp_dyn_payload_t *rtp_dyn_payload;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "256: #ifdef DEBUG_CONVERSATION",
          "275: static void sdp_dump_transport_media(const transport_media_pt_t* media) {",
          "276:     int i;",
          "277:     int count;",
          "",
          "[Removed Lines]",
          "258: static void",
          "259: rtp_dyn_payload_table_foreach_func (gpointer key, gpointer value, gpointer user_data _U_) {",
          "260:     gint* pt = (gint*) key;",
          "261:     encoding_name_and_rate_t *encoding = (encoding_name_and_rate_t*) value;",
          "263:     DPRINT2((\"pt=%d\",*pt));",
          "264:     DINDENT();",
          "265:         if (encoding) {",
          "266:             DPRINT2((\"encoding_name=%s\",",
          "267:                     encoding->encoding_name ? encoding->encoding_name : \"NULL\"));",
          "268:             DPRINT2((\"sample_rate=%d\", encoding->sample_rate));",
          "269:         } else {",
          "270:             DPRINT2((\"encoding=NULL\"));",
          "271:         }",
          "272:     DENDENT();",
          "273: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "291:         DENDENT();",
          "292:         DPRINT2((\"rtp_dyn_payload hashtable=%s\", media->rtp_dyn_payload ? \"YES\" : \"NO\"));",
          "293:         if (media->rtp_dyn_payload) {",
          "302:         }",
          "303:         DPRINT2((\"set_rtp=%s\", media->set_rtp ? \"TRUE\" : \"FALSE\"));",
          "304:     DENDENT();",
          "",
          "[Removed Lines]",
          "294:             DPRINT2((\"rtp_dyn_payload hash table contents:\"));",
          "295:             DINDENT();",
          "296:                 if (g_hash_table_size(media->rtp_dyn_payload) == 0) {",
          "297:                     DPRINT2((\"rtp_dyn_payload is empty\"));",
          "298:                 } else {",
          "299:                     g_hash_table_foreach(media->rtp_dyn_payload, rtp_dyn_payload_table_foreach_func, NULL);",
          "300:                 }",
          "301:             DENDENT();",
          "",
          "[Added Lines]",
          "277:             rtp_dump_dyn_payload(media->rtp_dyn_payload);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1290:     guint8     *payload_type;",
          "1291:     guint8     *attribute_value;",
          "1293:     guint8      pt;",
          "1294:     gint        sdp_media_attrbute_code;",
          "1295:     const char *msrp_res           = \"msrp://\";",
          "",
          "[Removed Lines]",
          "1292:     gint       *key;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1297:     gboolean    has_more_pars      = TRUE;",
          "1298:     tvbuff_t   *h245_tvb;",
          "1299:     guint8      master_key_length  = 0, master_salt_length = 0;",
          "1302:     offset = 0;",
          "",
          "[Removed Lines]",
          "1300:     encoding_name_and_rate_t *encoding_name_and_rate;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1365:             }",
          "1370:             transport_info->encoding_name[pt] = (char*)tvb_get_string_enc(wmem_packet_scope(), tvb, offset, tokenlen, ENC_UTF_8|ENC_NA);",
          "1372:             next_offset =  next_offset + 1;",
          "",
          "[Removed Lines]",
          "1367:             key  = wmem_new(wmem_file_scope(), gint);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1400:             if (transport_info->media_count < 0) {",
          "1401:                 for (n = 0; n < SDP_MAX_RTP_CHANNELS; n++) {",
          "1415:                 }",
          "1416:                 return;",
          "1426:             break;",
          "1427:         case SDP_FMTP:",
          "1428:             if (sdp_media_attribute_tree) {",
          "",
          "[Removed Lines]",
          "1402:                     encoding_name_and_rate = wmem_new(wmem_file_scope(), encoding_name_and_rate_t);",
          "1403:                     encoding_name_and_rate->encoding_name = wmem_strdup(wmem_file_scope(), transport_info->encoding_name[pt]);",
          "1404:                     encoding_name_and_rate->sample_rate = transport_info->sample_rate[pt];",
          "1405:                     if (n == 0) {",
          "1406:                         g_hash_table_insert(transport_info->media[n].rtp_dyn_payload,",
          "1407:                                             key, encoding_name_and_rate);",
          "1409:                         gint *key2;",
          "1410:                         key2  = wmem_new(wmem_file_scope(), gint);",
          "1412:                         g_hash_table_insert(transport_info->media[n].rtp_dyn_payload,",
          "1413:                                             key2, encoding_name_and_rate);",
          "1414:                     }",
          "1418:             } else",
          "1420:                 encoding_name_and_rate = wmem_new(wmem_file_scope(), encoding_name_and_rate_t);",
          "1422:             encoding_name_and_rate->encoding_name = wmem_strdup(wmem_file_scope(), transport_info->encoding_name[pt]);",
          "1423:             encoding_name_and_rate->sample_rate   = transport_info->sample_rate[pt];",
          "1424:             g_hash_table_insert(transport_info->media[ transport_info->media_count ].rtp_dyn_payload,",
          "1425:                                   key, encoding_name_and_rate);",
          "",
          "[Added Lines]",
          "1373:                     rtp_dyn_payload_insert(transport_info->media[n].rtp_dyn_payload,",
          "1374:                                            pt,",
          "1375:                                            transport_info->encoding_name[pt],",
          "1376:                                            transport_info->sample_rate[pt]);",
          "1380:             }",
          "1382:             rtp_dyn_payload_insert(transport_info->media[ transport_info->media_count ].rtp_dyn_payload,",
          "1383:                                   pt, transport_info->encoding_name[pt], transport_info->sample_rate[pt]);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1917:             transport_info->encoding_name[n] = (char*)UNKNOWN_ENCODING;",
          "1918:         }",
          "1919:         for (n = 0; n < SDP_MAX_RTP_CHANNELS; n++) {",
          "1922:             transport_info->media[n].set_rtp = FALSE;",
          "1923:         }",
          "",
          "[Removed Lines]",
          "1920:             transport_info->media[n].rtp_dyn_payload =",
          "1921:                 g_hash_table_new(g_int_hash, g_int_equal);",
          "",
          "[Added Lines]",
          "1878:             transport_info->media[n].rtp_dyn_payload = rtp_dyn_payload_new();",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1955:         (transport_info->sdp_status == SDP_EXCHANGE_OFFER)) {",
          "1956:         for (n = start_transport_info_count; n < SDP_MAX_RTP_CHANNELS; n++) {",
          "1957:             if (!transport_info->media[n].rtp_dyn_payload)",
          "1959:         }",
          "1960:     }",
          "",
          "[Removed Lines]",
          "1958:                 transport_info->media[n].rtp_dyn_payload = g_hash_table_new(g_int_hash, g_int_equal);",
          "",
          "[Added Lines]",
          "1915:                 transport_info->media[n].rtp_dyn_payload = rtp_dyn_payload_new();",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "2161:             if (!transport_info->media[n].set_rtp)",
          "2162:             {",
          "2164:                         \"channel=%d, media_port=%d\",",
          "2165:                         n, transport_info->media_port[n]));",
          "2167:                 transport_info->media[n].rtp_dyn_payload = NULL;",
          "2168:             }",
          "",
          "[Removed Lines]",
          "2163:                 DPRINT((\"set_rtp is not set, calling rtp_free_hash_dyn_payload, \"",
          "2166:                 rtp_free_hash_dyn_payload(transport_info->media[n].rtp_dyn_payload);",
          "",
          "[Added Lines]",
          "2120:                 DPRINT((\"set_rtp is not set, calling rtp_dyn_payload_free, \"",
          "2123:                 rtp_dyn_payload_free(transport_info->media[n].rtp_dyn_payload);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "2176:             {",
          "2177:                 if (!transport_info->media[n].set_rtp)",
          "2178:                 {",
          "2180:                             \"channel=%d, media_port=%d\",",
          "2181:                             n, transport_info->media_port[n]));",
          "2183:                     transport_info->media[n].rtp_dyn_payload = NULL;",
          "2184:                 }",
          "2185:             }",
          "",
          "[Removed Lines]",
          "2179:                     DPRINT((\"media_count == -1, calling rtp_free_hash_dyn_payload, \"",
          "2182:                     rtp_free_hash_dyn_payload(transport_info->media[n].rtp_dyn_payload);",
          "",
          "[Added Lines]",
          "2136:                     DPRINT((\"media_count == -1, calling rtp_dyn_payload_free, \"",
          "2139:                     rtp_dyn_payload_free(transport_info->media[n].rtp_dyn_payload);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "2190:             {",
          "2191:                 if (!transport_info->media[n].set_rtp)",
          "2192:                 {",
          "2194:                             \"channel=%d, media_port=%d\",",
          "2195:                             n, transport_info->media_port[n]));",
          "2197:                     transport_info->media[n].rtp_dyn_payload = NULL;",
          "2198:                 }",
          "2199:             }",
          "",
          "[Removed Lines]",
          "2193:                     DPRINT((\"media_count != -1, calling rtp_free_hash_dyn_payload, \"",
          "2196:                     rtp_free_hash_dyn_payload(transport_info->media[n].rtp_dyn_payload);",
          "",
          "[Added Lines]",
          "2150:                     DPRINT((\"media_count != -1, calling rtp_dyn_payload_free, \"",
          "2153:                     rtp_dyn_payload_free(transport_info->media[n].rtp_dyn_payload);",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "2208:         {",
          "2209:             if (!transport_info->media[n].set_rtp)",
          "2210:             {",
          "2212:                 transport_info->media[n].rtp_dyn_payload = NULL;",
          "2213:             }",
          "2214:         }",
          "",
          "[Removed Lines]",
          "2211:                 rtp_free_hash_dyn_payload(transport_info->media[n].rtp_dyn_payload);",
          "",
          "[Added Lines]",
          "2168:                 rtp_dyn_payload_free(transport_info->media[n].rtp_dyn_payload);",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "2281:         local_transport_info.encoding_name[n] = (char*)UNKNOWN_ENCODING;",
          "2282:     }",
          "2283:     for (n = 0; n < SDP_MAX_RTP_CHANNELS; n++) {",
          "2286:         local_transport_info.media[n].set_rtp = FALSE;",
          "2287:     }",
          "",
          "[Removed Lines]",
          "2284:         local_transport_info.media[n].rtp_dyn_payload =",
          "2285:             g_hash_table_new(g_int_hash, g_int_equal);",
          "",
          "[Added Lines]",
          "2241:         local_transport_info.media[n].rtp_dyn_payload = rtp_dyn_payload_new();",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "2559:                         i, local_transport_info.media[n].pt[i]));",
          "2561:                 if ((local_transport_info.media[n].pt[i] >= 96) && (local_transport_info.media[n].pt[i] <= 127)) {",
          "2564:                         local_transport_info.media[n].rtp_dyn_payload,",
          "2567:                         if (strlen(sdp_pi->summary_str))",
          "2568:                             g_strlcat(sdp_pi->summary_str, \" \", 50);",
          "2570:                     } else {",
          "2571:                         char num_pt[10];",
          "2572:                         g_snprintf(num_pt, 10, \"%u\", local_transport_info.media[n].pt[i]);",
          "",
          "[Removed Lines]",
          "2562:                     encoding_name_and_rate_t *encoding_name_and_rate_pt =",
          "2563:                         (encoding_name_and_rate_t *)g_hash_table_lookup(",
          "2565:                         &local_transport_info.media[n].pt[i]);",
          "2566:                     if (encoding_name_and_rate_pt) {",
          "2569:                         g_strlcat(sdp_pi->summary_str, encoding_name_and_rate_pt->encoding_name, 50);",
          "",
          "[Added Lines]",
          "2518:                     const gchar *payload_type_str = rtp_dyn_payload_get_name(",
          "2520:                         local_transport_info.media[n].pt[i]);",
          "2521:                     if (payload_type_str) {",
          "2524:                         g_strlcat(sdp_pi->summary_str, payload_type_str, 50);",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "2589:         if ((transport_info == &local_transport_info) &&",
          "2590:             !transport_info->media[n].set_rtp)",
          "2591:         {",
          "2593:             transport_info->media[n].rtp_dyn_payload = NULL;",
          "2594:         }",
          "",
          "[Removed Lines]",
          "2592:             rtp_free_hash_dyn_payload(transport_info->media[n].rtp_dyn_payload);",
          "",
          "[Added Lines]",
          "2547:             rtp_dyn_payload_free(transport_info->media[n].rtp_dyn_payload);",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "2611:         {",
          "2612:             if (!transport_info->media[n].set_rtp)",
          "2613:             {",
          "2615:                 transport_info->media[n].rtp_dyn_payload = NULL;",
          "2616:             }",
          "2617:         }",
          "",
          "[Removed Lines]",
          "2614:                 rtp_free_hash_dyn_payload(transport_info->media[n].rtp_dyn_payload);",
          "",
          "[Added Lines]",
          "2569:                 rtp_dyn_payload_free(transport_info->media[n].rtp_dyn_payload);",
          "",
          "---------------"
        ],
        "ui/gtk/voip_calls.c||ui/gtk/voip_calls.c": [
          "File: ui/gtk/voip_calls.c -> ui/gtk/voip_calls.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "564:    p_conv_data = (struct _rtp_conversation_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_get_id_by_filter_name(\"rtp\"), 0);",
          "565:    if (p_conv_data && p_conv_data->rtp_dyn_payload) {",
          "570:     }",
          "571:    }",
          "572:   }",
          "",
          "[Removed Lines]",
          "566:     encoding_name_and_rate_t *encoding_name_and_rate_pt = NULL;",
          "567:     encoding_name_and_rate_pt = (encoding_name_and_rate_t *)g_hash_table_lookup(p_conv_data->rtp_dyn_payload, &strinfo->pt);",
          "568:     if (encoding_name_and_rate_pt) {",
          "569:      strinfo->pt_str = g_strdup(encoding_name_and_rate_pt->encoding_name);",
          "",
          "[Added Lines]",
          "566:     const gchar *encoding_name = rtp_dyn_payload_get_name(p_conv_data->rtp_dyn_payload, strinfo->pt);",
          "567:     if (encoding_name) {",
          "568:      strinfo->pt_str = g_strdup(encoding_name);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "65b6a98b4a18a941a3c56ef3e961cc77fc33b575",
      "candidate_info": {
        "commit_hash": "65b6a98b4a18a941a3c56ef3e961cc77fc33b575",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/65b6a98b4a18a941a3c56ef3e961cc77fc33b575",
        "files": [
          "epan/dissectors/packet-btavdtp.c",
          "epan/dissectors/packet-btavdtp.h",
          "epan/dissectors/packet-hci_h1.c",
          "epan/dissectors/packet-hci_h4.c",
          "epan/dissectors/packet-rtp.c",
          "epan/dissectors/packet-rtp.h",
          "ui/rtp_stream.h",
          "ui/tap-rtp-common.c"
        ],
        "message": "Bluetooth: AVDTP: Add support for Content Protection type SCMS-T (and some minor cleanup).  Bug 7893 (https://bugs.wireshark.org/bugzilla/show_bug.cgi?id=7893)\n\nFrom Michal Labedzki\n\nsvn path=/trunk/; revision=53065",
        "before_after_code_files": [
          "epan/dissectors/packet-btavdtp.c||epan/dissectors/packet-btavdtp.c",
          "epan/dissectors/packet-btavdtp.h||epan/dissectors/packet-btavdtp.h",
          "epan/dissectors/packet-hci_h1.c||epan/dissectors/packet-hci_h1.c",
          "epan/dissectors/packet-hci_h4.c||epan/dissectors/packet-hci_h4.c",
          "epan/dissectors/packet-rtp.c||epan/dissectors/packet-rtp.c",
          "epan/dissectors/packet-rtp.h||epan/dissectors/packet-rtp.h",
          "ui/rtp_stream.h||ui/rtp_stream.h",
          "ui/tap-rtp-common.c||ui/tap-rtp-common.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "epan/dissectors/packet-rtp.c||epan/dissectors/packet-rtp.c"
          ],
          "candidate": [
            "epan/dissectors/packet-rtp.c||epan/dissectors/packet-rtp.c"
          ]
        }
      },
      "candidate_diff": {
        "epan/dissectors/packet-btavdtp.c||epan/dissectors/packet-btavdtp.c": [
          "File: epan/dissectors/packet-btavdtp.c -> epan/dissectors/packet-btavdtp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "34: #include \"packet-btl2cap.h\"",
          "35: #include \"packet-btsdp.h\"",
          "36: #include \"packet-btavdtp.h\"",
          "38: #define AVDTP_MESSAGE_TYPE_MASK  0x03",
          "39: #define AVDTP_PACKET_TYPE_MASK   0x0C",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "37: #include \"packet-rtp.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "250: static wmem_tree_t *cid_to_type_table = NULL;",
          "256: static dissector_handle_t sbc_handle;",
          "257: static dissector_handle_t mp2t_handle;",
          "258: static dissector_handle_t mpeg_audio_handle;",
          "259: static dissector_handle_t atrac_handle;",
          "265: static dissector_handle_t h263_handle;",
          "266: static dissector_handle_t mp4v_es_handle;",
          "269: static const value_string message_type_vals[] = {",
          "270:     { 0x00,  \"Command\" },",
          "",
          "[Removed Lines]",
          "253: static int proto_bta2dp                        = -1;",
          "254: static gint ett_bta2dp                         = -1;",
          "262: static int proto_btvdp                         = -1;",
          "263: static gint ett_btvdp                          = -1;",
          "",
          "[Added Lines]",
          "254: static gint proto_bta2dp                        = -1;",
          "255: static gint ett_bta2dp                          = -1;",
          "256: static gint proto_bta2dp_cph_scms_t             = -1;",
          "257: static gint ett_bta2dp_cph_scms_t               = -1;",
          "259: static int hf_bta2dp_codec                              = -1;",
          "260: static int hf_bta2dp_content_protection                 = -1;",
          "261: static int hf_bta2dp_l_bit                              = -1;",
          "262: static int hf_bta2dp_cp_bit                             = -1;",
          "263: static int hf_bta2dp_reserved                           = -1;",
          "270: static gboolean  force_a2dp_scms_t = FALSE;",
          "271: static gint      force_a2dp_codec = CODEC_SBC;",
          "273: static const enum_val_t pref_a2dp_codec[] = {",
          "274:     { \"sbc\",         \"SBC\",          CODEC_SBC },",
          "275:     { \"mp2t\",        \"MPEG12 AUDIO\", CODEC_MPEG12_AUDIO },",
          "276:     { \"mpeg-audio\",  \"MPEG24 AAC\",   CODEC_MPEG24_AAC },",
          "278:     { NULL, NULL, 0 }",
          "279: };",
          "283: static gint proto_btvdp                         = -1;",
          "284: static gint ett_btvdp                           = -1;",
          "285: static gint proto_btvdp_cph_scms_t              = -1;",
          "286: static gint ett_btvdp_cph_scms_t                = -1;",
          "288: static int hf_btvdp_codec                              = -1;",
          "289: static int hf_btvdp_content_protection                 = -1;",
          "290: static int hf_btvdp_l_bit                              = -1;",
          "291: static int hf_btvdp_cp_bit                             = -1;",
          "292: static int hf_btvdp_reserved                           = -1;",
          "297: static gboolean  force_vdp_scms_t = FALSE;",
          "298: static gint      force_vdp_codec = CODEC_H263_BASELINE;",
          "300: static const enum_val_t pref_vdp_codec[] = {",
          "301:     { \"h263\",    \"H263\",      CODEC_H263_BASELINE },",
          "302:     { \"mp4v-es\", \"MPEG4 VSP\", CODEC_MPEG4_VSP },",
          "303:     { NULL, NULL, 0 }",
          "304: };",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "392:     { 0, NULL }",
          "393: };",
          "395: extern value_string_ext bthci_evt_comp_id_ext;",
          "397: enum sep_state {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "433: static const value_string content_protection_type_vals[] = {",
          "434:     { 0x01,  \"DTCP\" },",
          "435:     { 0x02,  \"SCMS-T\" },",
          "436:     { 0, NULL }",
          "437: };",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "405:     guint8 type;",
          "406:     guint8 media_type;",
          "407:     gint   codec;",
          "408:     enum sep_state state;",
          "409: } sep_entry_t;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "452:     gint   content_protection_type;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "414:     sep_entry_t  *sep;",
          "415: } cid_type_data_t;",
          "417: void proto_register_btavdtp(void);",
          "418: void proto_reg_handoff_btavdtp(void);",
          "419: void proto_register_bta2dp(void);",
          "420: void proto_reg_handoff_bta2dp(void);",
          "421: void proto_register_btvdp(void);",
          "422: void proto_reg_handoff_btvdp(void);",
          "424: static const char *",
          "425: get_sep_type(guint32 frame_number, guint seid)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "463: typedef struct _sep_data_t {",
          "464:     gint   codec;",
          "465:     gint   content_protection_type;",
          "466: } sep_data_t;",
          "472: void proto_register_bta2dp_content_protection_header_scms_t(void);",
          "475: void proto_register_btvdp_content_protection_header_scms_t(void);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "527:             sep_data->seid = seid;",
          "528:             sep_data->type = type;",
          "529:             sep_data->codec = -1;",
          "530:             sep_data->media_type = media_type;",
          "531:             if (in_use) {",
          "532:                 sep_data->state = SEP_STATE_IN_USE;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "583:             sep_data->content_protection_type = 0;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "701: static gint",
          "702: dissect_capabilities(tvbuff_t *tvb, packet_info *pinfo,",
          "704: {",
          "705:     proto_item  *pitem                                        = NULL;",
          "706:     proto_item  *ptree                                        = NULL;",
          "",
          "[Removed Lines]",
          "703:                                          proto_tree *tree, gint offset, gint *codec)",
          "",
          "[Added Lines]",
          "757:         proto_tree *tree, gint offset, gint *codec,",
          "758:         gint *content_protection_type)",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "805:                 losc = 0;",
          "806:                 break;",
          "807:             case SERVICE_CATEGORY_CONTENT_PROTECTION:",
          "808:                 proto_tree_add_item(service_tree, hf_btavdtp_content_protection_type, tvb, offset, 2, ENC_LITTLE_ENDIAN);",
          "809:                 offset += 2;",
          "810:                 losc -= 2;",
          "815:                 break;",
          "816:             case SERVICE_CATEGORY_HEADER_COMPRESSION:",
          "817:                 proto_tree_add_item(service_tree, hf_btavdtp_header_compression_backch,   tvb, offset, 1, ENC_BIG_ENDIAN);",
          "",
          "[Removed Lines]",
          "812:                 proto_tree_add_item(service_tree, hf_btavdtp_data, tvb, offset, losc, ENC_NA);",
          "813:                 offset += losc;",
          "814:                 losc = 0;",
          "",
          "[Added Lines]",
          "865:                 if (content_protection_type) {",
          "867:                 }",
          "871:                 if (losc > 0) {",
          "872:                     proto_tree_add_item(service_tree, hf_btavdtp_data, tvb, offset, losc, ENC_NA);",
          "873:                     offset += losc;",
          "874:                     losc = 0;",
          "875:                 }",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "950:     tvbuff_t         *next_tvb;",
          "951:     guint32          seid;",
          "952:     guint32          t_seid;",
          "955:     col_set_str(pinfo->cinfo, COL_PROTOCOL, \"AVDTP\");",
          "",
          "[Removed Lines]",
          "953:     gint             codec;",
          "",
          "[Added Lines]",
          "1014:     gint             codec = -1;",
          "1015:     gint             content_protection_type = 0;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1047:                         get_sep_type(pinfo->fd->num, cid_type_data->sep->seid));",
          "1049:                 if (cid_type_data->sep->media_type == MEDIA_TYPE_AUDIO) {",
          "1050:                     next_tvb = tvb_new_subset_remaining(tvb, offset);",
          "1052:                 } else if (cid_type_data->sep->media_type == MEDIA_TYPE_VIDEO) {",
          "1053:                     next_tvb = tvb_new_subset_remaining(tvb, offset);",
          "1055:                 } else {",
          "1056:                     ti = proto_tree_add_item(tree, proto_btavdtp, tvb, offset, -1, ENC_NA);",
          "1057:                     btavdtp_tree = proto_item_add_subtree(ti, ett_btavdtp);",
          "",
          "[Removed Lines]",
          "1051:                     call_dissector_with_data(bta2dp_handle, next_tvb, pinfo, tree, &cid_type_data->sep->codec);",
          "1054:                     call_dissector_with_data(btvdp_handle, next_tvb, pinfo, tree, &cid_type_data->sep->codec);",
          "",
          "[Added Lines]",
          "1112:                     sep_data_t  sep_data;",
          "1114:                     sep_data.codec = cid_type_data->sep->codec;",
          "1115:                     sep_data.content_protection_type = cid_type_data->sep->content_protection_type;",
          "1118:                     call_dissector_with_data(bta2dp_handle, next_tvb, pinfo, tree, &sep_data);",
          "1120:                     sep_data_t  sep_data;",
          "1122:                     sep_data.codec = cid_type_data->sep->codec;",
          "1123:                     sep_data.content_protection_type = cid_type_data->sep->content_protection_type;",
          "1126:                     call_dissector_with_data(btvdp_handle, next_tvb, pinfo, tree, &sep_data);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1129:                 proto_tree_add_item(btavdtp_tree, hf_btavdtp_error_code, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "1130:                 break;",
          "1131:             }",
          "1133:             break;",
          "1134:         case SIGNAL_ID_SET_CONFIGURATION:",
          "1135:             if (message_type == MESSAGE_TYPE_COMMAND) {",
          "1136:                 offset = dissect_seid(tvb, pinfo, btavdtp_tree, offset, SEID_ACP, 0, &seid);",
          "1137:                 offset = dissect_seid(tvb, pinfo, btavdtp_tree, offset, SEID_INT, 0, NULL);",
          "1140:                 t_frame_number = pinfo->fd->num;",
          "1141:                 t_seid = seid;",
          "",
          "[Removed Lines]",
          "1132:             offset = dissect_capabilities(tvb, pinfo, btavdtp_tree, offset, NULL);",
          "1138:                 offset = dissect_capabilities(tvb, pinfo, btavdtp_tree, offset, &codec);",
          "",
          "[Added Lines]",
          "1204:             offset = dissect_capabilities(tvb, pinfo, btavdtp_tree, offset, NULL, NULL);",
          "1210:                 offset = dissect_capabilities(tvb, pinfo, btavdtp_tree, offset, &codec, &content_protection_type);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1150:                 sep = (sep_entry_t *)wmem_tree_lookup32_array_le(sep_list, key);",
          "1151:                 if (sep && sep->seid == seid) {",
          "1152:                     sep->codec = codec;",
          "1153:                 }",
          "1155:                 break;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1225:                     sep->content_protection_type = content_protection_type;",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1170:                 proto_tree_add_item(btavdtp_tree, hf_btavdtp_error_code, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "1171:                 break;",
          "1172:             }",
          "1174:             break;",
          "1175:         case SIGNAL_ID_RECONFIGURE:",
          "1176:             if (message_type == MESSAGE_TYPE_COMMAND) {",
          "1177:                 offset = dissect_seid(tvb, pinfo, btavdtp_tree, offset, SEID_ACP, 0, &seid);",
          "1180:                 t_frame_number = pinfo->fd->num;",
          "1181:                 t_seid = seid;",
          "",
          "[Removed Lines]",
          "1173:             offset = dissect_capabilities(tvb, pinfo, btavdtp_tree, offset, NULL);",
          "1178:                 offset = dissect_capabilities(tvb, pinfo, btavdtp_tree, offset, &codec);",
          "",
          "[Added Lines]",
          "1246:             offset = dissect_capabilities(tvb, pinfo, btavdtp_tree, offset, NULL, NULL);",
          "1251:                 offset = dissect_capabilities(tvb, pinfo, btavdtp_tree, offset, &codec, &content_protection_type);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "1190:                 sep = (sep_entry_t *)wmem_tree_lookup32_array_le(sep_list, key);",
          "1191:                 if (sep && sep->seid == seid) {",
          "1192:                     sep->codec = codec;",
          "1193:                 }",
          "1195:                 break;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1266:                     sep->content_protection_type = content_protection_type;",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "1504:         },",
          "1505:         { &hf_btavdtp_content_protection_type,",
          "1506:             { \"Type\",                           \"btavdtp.content_protection_type\",",
          "1508:             NULL, HFILL }",
          "1509:         },",
          "1510:         { &hf_btavdtp_media_codec_media_type,",
          "",
          "[Removed Lines]",
          "1507:             FT_UINT16, BASE_HEX, NULL, 0x0000,",
          "",
          "[Added Lines]",
          "1581:             FT_UINT16, BASE_HEX, VALS(content_protection_type_vals), 0x0000,",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "2013:     proto_item          *ti;",
          "2014:     proto_tree          *bta2dp_tree;",
          "2015:     proto_item          *pitem;",
          "2025:     col_set_str(pinfo->cinfo, COL_PROTOCOL, \"A2DP\");",
          "",
          "[Removed Lines]",
          "2016:     gint                offset = 0;",
          "2017:     gint                codec = -1;",
          "2018:     void                *save_private_data;",
          "2019:     dissector_handle_t  codec_dissector = NULL;",
          "2020:     btavdtp_data_t      *btavdtp_data;",
          "2022:     if (data)",
          "2023:         codec = *((gint *) data);",
          "",
          "[Added Lines]",
          "2090:     gint                 offset = 0;",
          "2091:     dissector_handle_t   codec_dissector = NULL;",
          "2092:     bta2dp_codec_info_t  bta2dp_codec_info;",
          "2093:     sep_data_t           sep_data;",
          "2095:     sep_data.codec = CODEC_SBC;",
          "2096:     sep_data.content_protection_type = 0;",
          "2098:     if (force_a2dp_scms_t || force_a2dp_codec) {",
          "2099:         if (force_a2dp_scms_t)",
          "2100:             sep_data.content_protection_type = 2;",
          "2101:         else if (data)",
          "2102:             sep_data.content_protection_type = ((sep_data_t *) data)->content_protection_type;",
          "2104:         if (force_a2dp_codec)",
          "2105:             sep_data.codec = force_a2dp_codec;",
          "2106:         else if (data)",
          "2107:             sep_data.codec = ((sep_data_t *) data)->codec;",
          "2108:     } else {",
          "2109:         if (data)",
          "2110:             sep_data = *((sep_data_t *) data);",
          "2111:     }",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "2047:     ti = proto_tree_add_item(tree, proto_bta2dp, tvb, offset, -1, ENC_NA);",
          "2048:     col_append_fstr(pinfo->cinfo, COL_INFO, \"Audio stream - %s\",",
          "2051:     bta2dp_tree = proto_item_add_subtree(ti, ett_bta2dp);",
          "2055:     PROTO_ITEM_SET_GENERATED(pitem);",
          "2058:         case CODEC_SBC:",
          "2059:             codec_dissector = sbc_handle;",
          "2060:             break;",
          "",
          "[Removed Lines]",
          "2049:             val_to_str_const(codec, media_codec_audio_type_vals, \"unknown codec\"));",
          "2053:     pitem = proto_tree_add_text(bta2dp_tree, tvb, offset, tvb_length_remaining(tvb, offset), \"Codec: %s\",",
          "2054:             val_to_str_const(codec, media_codec_audio_type_vals, \"unknown codec\"));",
          "2057:     switch (codec) {",
          "",
          "[Added Lines]",
          "2137:             val_to_str_const(sep_data.codec, media_codec_audio_type_vals, \"unknown codec\"));",
          "2141:     pitem = proto_tree_add_uint(bta2dp_tree, hf_bta2dp_codec, tvb, offset, 0, sep_data.codec);",
          "2144:     if (sep_data.content_protection_type > 0) {",
          "2145:         pitem = proto_tree_add_uint(bta2dp_tree, hf_bta2dp_content_protection, tvb, offset, 0, sep_data.content_protection_type);",
          "2146:         PROTO_ITEM_SET_GENERATED(pitem);",
          "2147:     }",
          "2149:     switch (sep_data.codec) {",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "2069:             break;",
          "2070:     }",
          "2079:     call_dissector(rtp_handle, tvb, pinfo, tree);",
          "2080:     offset += tvb_length_remaining(tvb, offset);",
          "2084:     return offset;",
          "2085: }",
          "",
          "[Removed Lines]",
          "2072:     save_private_data = pinfo->private_data;",
          "2074:     btavdtp_data = wmem_new(wmem_packet_scope(), btavdtp_data_t);",
          "2075:     btavdtp_data->codec_dissector = codec_dissector;",
          "2077:     pinfo->private_data = btavdtp_data;",
          "2082:     pinfo->private_data = save_private_data;",
          "",
          "[Added Lines]",
          "2164:     bta2dp_codec_info.codec_dissector = codec_dissector;",
          "2165:     bta2dp_codec_info.content_protection_type = sep_data.content_protection_type;",
          "2167:     bluetooth_add_address(pinfo, &pinfo->net_dst, \"BT A2DP\", pinfo->fd->num, FALSE, &bta2dp_codec_info);",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "2088: proto_register_bta2dp(void)",
          "2089: {",
          "2090:     module_t *module;",
          "2092:     static hf_register_info hf[] = {",
          "2093:         { &hf_bta2dp_codec,",
          "2094:             { \"Codec\",                           \"bta2dp.codec\",",
          "",
          "[Removed Lines]",
          "2091: #if 0",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "2101:             NULL, HFILL }",
          "2102:         }",
          "2103:     };",
          "2106:     static gint *ett[] = {",
          "2107:         &ett_bta2dp",
          "2108:     };",
          "2110:     proto_bta2dp = proto_register_protocol(\"Bluetooth A2DP Profile\", \"BT A2DP\", \"bta2dp\");",
          "2112:     proto_register_field_array(proto_bta2dp, hf, array_length(hf));",
          "2114:     proto_register_subtree_array(ett, array_length(ett));",
          "2116:     new_register_dissector(\"bta2dp\", dissect_bta2dp, proto_bta2dp);",
          "",
          "[Removed Lines]",
          "2104: #endif",
          "2111: #if 0",
          "2113: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "2119:     prefs_register_static_text_preference(module, \"a2dp.version\",",
          "2120:             \"Bluetooth Profile A2DP version: 1.3\",",
          "2121:             \"Version of profile supported by this dissector.\");",
          "2122: }",
          "2124: void",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2207:     prefs_register_bool_preference(module, \"a2dp.content_protection.scms_t\",",
          "2208:             \"Force SCMS-T decoding\",",
          "2209:             \"Force decoding stream as A2DP with Content Protection SCMS-T \",",
          "2210:             &force_a2dp_scms_t);",
          "2212:     prefs_register_enum_preference(module, \"a2dp.codec\",",
          "2213:             \"Force codec\",",
          "2214:             \"Force decoding stream as A2DP with specified codec\",",
          "2215:             &force_a2dp_codec, pref_a2dp_codec, FALSE);",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "2139:     dissector_add_handle(\"btl2cap.cid\", bta2dp_handle);",
          "2140: }",
          "2143: static gint",
          "2144: dissect_btvdp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)",
          "2145: {",
          "2146:     proto_item          *ti;",
          "2147:     proto_tree          *btvdp_tree;",
          "2148:     proto_item          *pitem;",
          "2158:     col_set_str(pinfo->cinfo, COL_PROTOCOL, \"VDP\");",
          "",
          "[Removed Lines]",
          "2149:     gint                offset = 0;",
          "2150:     gint                codec = -1;",
          "2151:     void                *save_private_data;",
          "2152:     dissector_handle_t  codec_dissector = NULL;",
          "2153:     btavdtp_data_t      *btavdtp_data;",
          "2155:     if (data)",
          "2156:         codec = *((gint *) data);",
          "",
          "[Added Lines]",
          "2242:     gint                 offset = 0;",
          "2243:     dissector_handle_t   codec_dissector = NULL;",
          "2244:     btvdp_codec_info_t   btvdp_codec_info;",
          "2245:     sep_data_t           sep_data;",
          "2247:     sep_data.codec = CODEC_H263_BASELINE;",
          "2248:     sep_data.content_protection_type = 0;",
          "2250:     if (force_vdp_scms_t || force_vdp_codec) {",
          "2251:         if (force_vdp_scms_t)",
          "2252:             sep_data.content_protection_type = 2;",
          "2253:         else if (data)",
          "2254:             sep_data.content_protection_type = ((sep_data_t *) data)->content_protection_type;",
          "2256:         if (force_vdp_codec)",
          "2257:             sep_data.codec = force_vdp_codec;",
          "2258:         else if (data)",
          "2259:             sep_data.codec = ((sep_data_t *) data)->codec;",
          "2260:     } else {",
          "2261:         if (data)",
          "2262:             sep_data = *((sep_data_t *) data);",
          "2263:     }",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "2180:     ti = proto_tree_add_item(tree, proto_btvdp, tvb, offset, -1, ENC_NA);",
          "2181:     col_append_fstr(pinfo->cinfo, COL_INFO, \"Video stream - %s\",",
          "2184:     btvdp_tree = proto_item_add_subtree(ti, ett_btvdp);",
          "2188:     PROTO_ITEM_SET_GENERATED(pitem);",
          "2191:         case CODEC_H263_BASELINE:",
          "2192:         case CODEC_H263_PROFILE_3:",
          "2193:         case CODEC_H263_PROFILE_8:",
          "",
          "[Removed Lines]",
          "2182:             val_to_str_const(codec, media_codec_video_type_vals, \"unknown codec\"));",
          "2186:     pitem = proto_tree_add_text(btvdp_tree, tvb, offset, tvb_length_remaining(tvb, offset), \"Codec: %s\",",
          "2187:             val_to_str_const(codec, media_codec_video_type_vals, \"unknown codec\"));",
          "2190:     switch (codec) {",
          "",
          "[Added Lines]",
          "2289:             val_to_str_const(sep_data.codec, media_codec_video_type_vals, \"unknown codec\"));",
          "2293:     pitem = proto_tree_add_uint(btvdp_tree, hf_btvdp_codec, tvb, offset, 0, sep_data.codec);",
          "2296:     if (sep_data.content_protection_type > 0) {",
          "2297:         pitem = proto_tree_add_uint(btvdp_tree, hf_btvdp_content_protection, tvb, offset, 0, sep_data.content_protection_type);",
          "2298:         PROTO_ITEM_SET_GENERATED(pitem);",
          "2299:     }",
          "2301:     switch (sep_data.codec) {",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "2198:             break;",
          "2199:     }",
          "2208:     call_dissector(rtp_handle, tvb, pinfo, tree);",
          "2209:     offset += tvb_length_remaining(tvb, offset);",
          "2213:     return offset;",
          "2214: }",
          "",
          "[Removed Lines]",
          "2201:     save_private_data = pinfo->private_data;",
          "2203:     btavdtp_data = wmem_new(wmem_packet_scope(), btavdtp_data_t);",
          "2204:     btavdtp_data->codec_dissector = codec_dissector;",
          "2206:     pinfo->private_data = btavdtp_data;",
          "2211:     pinfo->private_data = save_private_data;",
          "",
          "[Added Lines]",
          "2312:     btvdp_codec_info.codec_dissector = codec_dissector;",
          "2313:     btvdp_codec_info.content_protection_type = sep_data.content_protection_type;",
          "2315:     bluetooth_add_address(pinfo, &pinfo->net_dst, \"BT VDP\", pinfo->fd->num, TRUE, &btvdp_codec_info);",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "2219:     module_t *module;",
          "2220:     expert_module_t* expert_btavdtp;",
          "2223:     static hf_register_info hf[] = {",
          "2224:         { &hf_btvdp_codec,",
          "2225:             { \"Codec\",                           \"btvdp.codec\",",
          "",
          "[Removed Lines]",
          "2222: #if 0",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "2232:             NULL, HFILL }",
          "2233:         }",
          "2234:     };",
          "2237:     static gint *ett[] = {",
          "2238:         &ett_btvdp",
          "",
          "[Removed Lines]",
          "2235: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "2247:     proto_btvdp = proto_register_protocol(\"Bluetooth VDP Profile\", \"BT VDP\", \"btvdp\");",
          "2248:     new_register_dissector(\"btvdp\", dissect_btvdp, proto_btvdp);",
          "2250:     proto_register_field_array(proto_bta2dp, hf, array_length(hf));",
          "2252:     proto_register_subtree_array(ett, array_length(ett));",
          "2253:     expert_btavdtp = expert_register_protocol(proto_btvdp);",
          "2254:     expert_register_field_array(expert_btavdtp, ei, array_length(ei));",
          "",
          "[Removed Lines]",
          "2249: #if 0",
          "2251: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "2257:     prefs_register_static_text_preference(module, \"vdp.version\",",
          "2258:             \"Bluetooth Profile VDP version: 1.1\",",
          "2259:             \"Version of profile supported by this dissector.\");",
          "2260: }",
          "2262: void",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2363:     prefs_register_bool_preference(module, \"vdp.content_protection.scms_t\",",
          "2364:             \"Force SCMS-T decoding\",",
          "2365:             \"Force decoding stream as VDP with Content Protection SCMS-T \",",
          "2366:             &force_vdp_scms_t);",
          "2368:     prefs_register_enum_preference(module, \"vdp.codec\",",
          "2369:             \"Force codec\",",
          "2370:             \"Force decoding stream as VDP with specified codec\",",
          "2371:             &force_vdp_codec, pref_vdp_codec, FALSE);",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "2275: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2391: static gint",
          "2392: dissect_a2dp_cp_scms_t(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void *data _U_)",
          "2393: {",
          "2394:     proto_item  *main_item;",
          "2395:     proto_tree  *main_tree;",
          "2396:     gint         offset = 0;",
          "2398:     main_item = proto_tree_add_item(tree, proto_bta2dp_cph_scms_t, tvb, offset, 1, ENC_NA);",
          "2399:     main_tree = proto_item_add_subtree(main_item, ett_bta2dp_cph_scms_t);",
          "2401:     proto_tree_add_item(main_tree, hf_bta2dp_reserved , tvb, offset, 1, ENC_BIG_ENDIAN);",
          "2402:     proto_tree_add_item(main_tree, hf_bta2dp_cp_bit, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "2403:     proto_tree_add_item(main_tree, hf_bta2dp_l_bit , tvb, offset, 1, ENC_BIG_ENDIAN);",
          "2404:     offset += 1;",
          "2406:     return offset;",
          "2407: }",
          "2409: void",
          "2410: proto_register_bta2dp_content_protection_header_scms_t(void)",
          "2411: {",
          "2412:     static hf_register_info hf[] = {",
          "2413:         { &hf_bta2dp_l_bit,",
          "2414:             { \"L-bit\",                           \"bta2dp.content_protection_header.scms_t.l_bit\",",
          "2415:             FT_BOOLEAN, 8, NULL, 0x01,",
          "2416:             NULL, HFILL }",
          "2417:         },",
          "2418:         { &hf_bta2dp_cp_bit,",
          "2419:             { \"Cp-bit\",                          \"bta2dp.content_protection_header.scms_t.cp_bit\",",
          "2420:             FT_BOOLEAN, 8, NULL, 0x02,",
          "2421:             NULL, HFILL }",
          "2422:         },",
          "2423:         { &hf_bta2dp_reserved,",
          "2424:             { \"Reserved\",                        \"bta2dp.content_protection_header.scms_t.reserved\",",
          "2425:             FT_BOOLEAN, 8, NULL, 0xFC,",
          "2426:             NULL, HFILL }",
          "2427:         }",
          "2428:     };",
          "2430:     static gint *ett[] = {",
          "2431:         &ett_bta2dp_cph_scms_t",
          "2432:     };",
          "2434:     proto_bta2dp_cph_scms_t = proto_register_protocol(\"Bluetooth A2DP Content Protection Header SCMS-T\", \"BT A2DP Content Protection Header SCMS-T\", \"bta2dp_content_protection_header_scms_t\");",
          "2435:     proto_register_field_array(proto_bta2dp_cph_scms_t, hf, array_length(hf));",
          "2436:     proto_register_subtree_array(ett, array_length(ett));",
          "2438:     new_register_dissector(\"bta2dp_content_protection_header_scms_t\", dissect_a2dp_cp_scms_t, proto_bta2dp_cph_scms_t);",
          "2439: }",
          "2441: static gint",
          "2442: dissect_vdp_cp_scms_t(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void *data _U_)",
          "2443: {",
          "2444:     proto_item  *main_item;",
          "2445:     proto_tree  *main_tree;",
          "2446:     gint         offset = 0;",
          "2448:     main_item = proto_tree_add_item(tree, proto_btvdp_cph_scms_t, tvb, offset, 1, ENC_NA);",
          "2449:     main_tree = proto_item_add_subtree(main_item, ett_btvdp_cph_scms_t);",
          "2451:     proto_tree_add_item(main_tree, hf_btvdp_reserved , tvb, offset, 1, ENC_BIG_ENDIAN);",
          "2452:     proto_tree_add_item(main_tree, hf_btvdp_cp_bit, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "2453:     proto_tree_add_item(main_tree, hf_btvdp_l_bit , tvb, offset, 1, ENC_BIG_ENDIAN);",
          "2454:     offset += 1;",
          "2456:     return offset;",
          "2457: }",
          "2459: void",
          "2460: proto_register_btvdp_content_protection_header_scms_t(void)",
          "2461: {",
          "2462:     static hf_register_info hf[] = {",
          "2463:         { &hf_btvdp_l_bit,",
          "2464:             { \"L-bit\",                           \"btvdp.content_protection_header.scms_t.l_bit\",",
          "2465:             FT_BOOLEAN, 8, NULL, 0x01,",
          "2466:             NULL, HFILL }",
          "2467:         },",
          "2468:         { &hf_btvdp_cp_bit,",
          "2469:             { \"Cp-bit\",                          \"btvdp.content_protection_header.scms_t.cp_bit\",",
          "2470:             FT_BOOLEAN, 8, NULL, 0x02,",
          "2471:             NULL, HFILL }",
          "2472:         },",
          "2473:         { &hf_btvdp_reserved,",
          "2474:             { \"Reserved\",                        \"btvdp.content_protection_header.scms_t.reserved\",",
          "2475:             FT_BOOLEAN, 8, NULL, 0xFC,",
          "2476:             NULL, HFILL }",
          "2477:         }",
          "2478:     };",
          "2480:     static gint *ett[] = {",
          "2481:         &ett_btvdp_cph_scms_t",
          "2482:     };",
          "2484:     proto_btvdp_cph_scms_t = proto_register_protocol(\"Bluetooth VDP Content Protection Header SCMS-T\", \"BT VDP Content Protection Header SCMS-T\", \"btvdp_content_protection_header_scms_t\");",
          "2485:     proto_register_field_array(proto_btvdp_cph_scms_t, hf, array_length(hf));",
          "2486:     proto_register_subtree_array(ett, array_length(ett));",
          "2488:     new_register_dissector(\"btvdp_content_protection_header_scms_t\", dissect_vdp_cp_scms_t, proto_btvdp_cph_scms_t);",
          "2489: }",
          "",
          "---------------"
        ],
        "epan/dissectors/packet-btavdtp.h||epan/dissectors/packet-btavdtp.h": [
          "File: epan/dissectors/packet-btavdtp.h -> epan/dissectors/packet-btavdtp.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "27: #ifndef __PACKET_BTAVDTP_H__",
          "28: #define __PACKET_BTAVDTP_H__",
          "31:     dissector_handle_t  codec_dissector;",
          "34: #endif",
          "",
          "[Removed Lines]",
          "30: typedef struct _btavdtp_data_t {",
          "32: } btavdtp_data_t;",
          "",
          "[Added Lines]",
          "30: #define BTAVDTP_CONTENT_PROTECTION_TYPE_SCMS_T  0x02",
          "32: typedef struct _bta2dp_codec_info_t {",
          "33:     dissector_handle_t  codec_dissector;",
          "34:     gint                content_protection_type;",
          "35: } bta2dp_codec_info_t;",
          "37: typedef struct _btvdp_codec_info_t {",
          "39:     gint                content_protection_type;",
          "40: } btvdp_codec_info_t;",
          "",
          "---------------"
        ],
        "epan/dissectors/packet-hci_h1.c||epan/dissectors/packet-hci_h1.c": [
          "File: epan/dissectors/packet-hci_h1.c -> epan/dissectors/packet-hci_h1.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "114:     hci_data->localhost_bdaddr = localhost_bdaddr;",
          "115:     hci_data->localhost_name = localhost_name;",
          "117:     ti = proto_tree_add_int(hci_h1_tree, hf_hci_h1_direction, tvb, 0, 0, pinfo->p2p_dir);",
          "118:     PROTO_ITEM_SET_GENERATED(ti);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "117:     pinfo->ptype = PT_BLUETOOTH;",
          "",
          "---------------"
        ],
        "epan/dissectors/packet-hci_h4.c||epan/dissectors/packet-hci_h4.c": [
          "File: epan/dissectors/packet-hci_h4.c -> epan/dissectors/packet-hci_h4.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "110:     hci_data->localhost_bdaddr = localhost_bdaddr;",
          "111:     hci_data->localhost_name = localhost_name;",
          "113:     ti = proto_tree_add_uint(hci_h4_tree, hf_hci_h4_direction, tvb, 0, 0, pinfo->p2p_dir);",
          "114:     PROTO_ITEM_SET_GENERATED(ti);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "113:     pinfo->ptype = PT_BLUETOOTH;",
          "",
          "---------------"
        ],
        "epan/dissectors/packet-rtp.c||epan/dissectors/packet-rtp.c": [
          "File: epan/dissectors/packet-rtp.c -> epan/dissectors/packet-rtp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "61: #include <epan/packet.h>",
          "63: #include \"packet-rtp.h\"",
          "64: #include <epan/rtp_pt.h>",
          "65: #include <epan/conversation.h>",
          "66: #include <epan/reassemble.h>",
          "67: #include <epan/tap.h>",
          "69: #include <epan/prefs.h>",
          "70: #include <epan/wmem/wmem.h>",
          "71: #include <epan/strutil.h>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "69: #include <epan/epan_dissect.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "142: static dissector_handle_t sprt_handle;",
          "143: static dissector_handle_t v150fw_handle;",
          "145: static int rtp_tap = -1;",
          "147: static dissector_table_t rtp_pt_dissector_table;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "146: static dissector_handle_t bta2dp_content_protection_header_scms_t;",
          "147: static dissector_handle_t btvdp_content_protection_header_scms_t;",
          "148: static dissector_handle_t bta2dp_handle;",
          "149: static dissector_handle_t btvdp_handle;",
          "150: static dissector_handle_t sbc_handle;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "266: static dissector_handle_t data_handle;",
          "269: void proto_reg_handoff_rtp(void);",
          "270: void proto_reg_handoff_pkt_ccc(void);",
          "274: static void show_setup_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree);",
          "275: static void get_conv_info(packet_info *pinfo, struct _rtp_info *rtp_info);",
          "",
          "[Removed Lines]",
          "272: static void dissect_rtp( tvbuff_t *tvb, packet_info *pinfo,",
          "273:     proto_tree *tree );",
          "",
          "[Added Lines]",
          "276: void proto_register_rtp(void);",
          "278: void proto_register_pkt_ccc(void);",
          "281: static gint dissect_rtp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "806:  rtp_dyn_payload = NULL;",
          "807: }",
          "810: void",
          "811: srtp_add_address(packet_info *pinfo, address *addr, int port, int other_port,",
          "812:    const gchar *setup_method, guint32 setup_frame_number,",
          "813:    gboolean is_video _U_, GHashTable *rtp_dyn_payload,",
          "815: {",
          "816:  address null_addr;",
          "817:  conversation_t* p_conv;",
          "",
          "[Removed Lines]",
          "814:                  struct srtp_info *srtp_info)",
          "",
          "[Added Lines]",
          "818: void",
          "819: bluetooth_add_address(packet_info *pinfo, address *addr,",
          "820:    const gchar *setup_method, guint32 setup_frame_number,",
          "821:    gboolean is_video, void *data)",
          "822: {",
          "823:  address null_addr;",
          "824:  conversation_t* p_conv;",
          "825:  struct _rtp_conversation_info *p_conv_data = NULL;",
          "831:  if (pinfo->fd->flags.visited)",
          "832:  {",
          "833:   return;",
          "834:  }",
          "836:  SET_ADDRESS(&null_addr, AT_NONE, 0, NULL);",
          "842:  p_conv = find_conversation(setup_frame_number, addr, &null_addr, PT_BLUETOOTH, 0, 0,",
          "843:        NO_ADDR_B | NO_PORT_B);",
          "848:  if (!p_conv || p_conv->setup_frame != setup_frame_number) {",
          "849:   p_conv = conversation_new(setup_frame_number, addr, &null_addr, PT_BLUETOOTH, 0, 0,",
          "850:        NO_ADDR2 | NO_PORT2);",
          "851:  }",
          "854:  conversation_set_dissector(p_conv, rtp_handle);",
          "859:  p_conv_data = (struct _rtp_conversation_info *)conversation_get_proto_data(p_conv, proto_rtp);",
          "864:  if (! p_conv_data) {",
          "866:   p_conv_data = wmem_new(wmem_file_scope(), struct _rtp_conversation_info);",
          "867:   p_conv_data->rtp_dyn_payload = NULL;",
          "872:   p_conv_data->extended_seqno = 0x10000;",
          "873:   p_conv_data->rtp_conv_info = wmem_new(wmem_file_scope(), rtp_private_conv_info);",
          "874:   p_conv_data->rtp_conv_info->multisegment_pdus = wmem_tree_new(wmem_file_scope());",
          "875:   conversation_add_proto_data(p_conv, proto_rtp, p_conv_data);",
          "877:   if (is_video) {",
          "878:    p_conv_data->bta2dp_info = NULL;",
          "879:    p_conv_data->btvdp_info = (btvdp_codec_info_t *) wmem_memdup(wmem_file_scope(), data, sizeof(btvdp_codec_info_t));",
          "880:   } else {",
          "881:    p_conv_data->bta2dp_info = (bta2dp_codec_info_t *) wmem_memdup(wmem_file_scope(), data, sizeof(bta2dp_codec_info_t));",
          "882:    p_conv_data->btvdp_info = NULL;",
          "883:   }",
          "884:  }",
          "890:  rtp_free_hash_dyn_payload(p_conv_data->rtp_dyn_payload);",
          "892:  g_strlcpy(p_conv_data->method, setup_method, MAX_RTP_SETUP_METHOD_SIZE+1);",
          "893:  p_conv_data->frame_number = setup_frame_number;",
          "894:  p_conv_data->is_video = is_video;",
          "895:  p_conv_data->rtp_dyn_payload = NULL;",
          "896:  p_conv_data->srtp_info = NULL;",
          "897: }",
          "904:    struct srtp_info *srtp_info)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "887:  p_conv_data->is_video = is_video;",
          "888:  p_conv_data->rtp_dyn_payload = rtp_dyn_payload;",
          "889:  p_conv_data->srtp_info = srtp_info;",
          "890: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "980:  p_conv_data->bta2dp_info = NULL;",
          "981:  p_conv_data->btvdp_info = NULL;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "899: }",
          "901: static gboolean",
          "903: {",
          "904:  guint8       octet1;",
          "905:  unsigned int version;",
          "",
          "[Removed Lines]",
          "902: dissect_rtp_heur_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, gboolean check_destport)",
          "",
          "[Added Lines]",
          "994: dissect_rtp_heur_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data, gboolean check_destport)",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "954:   return FALSE;",
          "955:  }",
          "958:  return TRUE;",
          "959: }",
          "961: static gboolean",
          "963: {",
          "965: }",
          "967: static gboolean",
          "969: {",
          "971: }",
          "",
          "[Removed Lines]",
          "957:  dissect_rtp( tvb, pinfo, tree );",
          "962: dissect_rtp_heur_udp( tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_ )",
          "964:  return dissect_rtp_heur_common(tvb, pinfo, tree, TRUE);",
          "968: dissect_rtp_heur_stun( tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_ )",
          "970:  return dissect_rtp_heur_common(tvb, pinfo, tree, FALSE);",
          "",
          "[Added Lines]",
          "1049:  dissect_rtp( tvb, pinfo, tree, data );",
          "1054: dissect_rtp_heur_udp( tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data )",
          "1056:  return dissect_rtp_heur_common(tvb, pinfo, tree, data, TRUE);",
          "1060: dissect_rtp_heur_stun( tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data )",
          "1062:  return dissect_rtp_heur_common(tvb, pinfo, tree, data, FALSE);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "976: static void",
          "977: process_rtp_payload(tvbuff_t *newtvb, packet_info *pinfo, proto_tree *tree,",
          "980: {",
          "981:  struct _rtp_conversation_info *p_conv_data = NULL;",
          "982:  gboolean found_match = FALSE;",
          "983:  int payload_len;",
          "984:  struct srtp_info *srtp_info;",
          "987:  payload_len = tvb_length_remaining(newtvb, offset);",
          "",
          "[Removed Lines]",
          "978:       proto_tree *rtp_tree,",
          "979:       unsigned int payload_type)",
          "985:  int offset=0;",
          "",
          "[Added Lines]",
          "1070:       proto_tree *rtp_tree, unsigned int payload_type)",
          "1076:  int offset = 0;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1015:    proto_tree_add_item(rtp_tree, hf_srtp_auth_tag, newtvb, offset, srtp_info->auth_tag_len, ENC_NA);",
          "1017:   }",
          "1022:   if (p_conv_data && p_conv_data->rtp_dyn_payload) {",
          "1023:    gchar *payload_type_str = NULL;",
          "1024:    encoding_name_and_rate_t *encoding_name_and_rate_pt = NULL;",
          "",
          "[Removed Lines]",
          "1018:  }",
          "1021:  else if ( (payload_type >= PT_UNDF_96 && payload_type <= PT_UNDF_127) ) {",
          "",
          "[Added Lines]",
          "1109:  } else if (p_conv_data && !p_conv_data->bta2dp_info && !p_conv_data->btvdp_info &&",
          "1110:    payload_type >= PT_UNDF_96 && payload_type <= PT_UNDF_127) {",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1041:    }",
          "1043:   }",
          "1044:  }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1134:  } else if (p_conv_data && p_conv_data->bta2dp_info) {",
          "1135:   tvbuff_t  *nexttvb;",
          "1136:   gint       suboffset = 0;",
          "1138:   found_match = TRUE;",
          "1140:   if (p_conv_data->bta2dp_info->content_protection_type == BTAVDTP_CONTENT_PROTECTION_TYPE_SCMS_T) {",
          "1141:    nexttvb = tvb_new_subset(newtvb, 0, 1, 1);",
          "1142:     call_dissector(bta2dp_content_protection_header_scms_t, nexttvb, pinfo, tree);",
          "1143:    suboffset = 1;",
          "1144:   }",
          "1146:   nexttvb = tvb_new_subset_remaining(newtvb, suboffset);",
          "1147:   call_dissector(p_conv_data->bta2dp_info->codec_dissector, nexttvb, pinfo, tree);",
          "1148:  } else if (p_conv_data && p_conv_data->btvdp_info) {",
          "1149:   tvbuff_t  *nexttvb;",
          "1150:   gint       suboffset = 0;",
          "1152:   found_match = TRUE;",
          "1154:   if (p_conv_data->btvdp_info->content_protection_type == BTAVDTP_CONTENT_PROTECTION_TYPE_SCMS_T) {",
          "1155:    nexttvb = tvb_new_subset(newtvb, 0, 1, 1);",
          "1156:    call_dissector(bta2dp_content_protection_header_scms_t, nexttvb, pinfo, tree);",
          "1157:    suboffset = 1;",
          "1158:   }",
          "1160:   nexttvb = tvb_new_subset_remaining(newtvb, suboffset);",
          "1161:   call_dissector(p_conv_data->btvdp_info->codec_dissector, nexttvb, pinfo, tree);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1265: static void",
          "1266: dissect_rtp_rfc2198(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)",
          "1267: {",
          "1269:  guint8 octet1;",
          "1270:  int cnt;",
          "1271:  gboolean hdr_follow = TRUE;",
          "",
          "[Removed Lines]",
          "1268:  int offset = 0;",
          "",
          "[Added Lines]",
          "1386:  gint offset = 0;",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1356: static void",
          "1357: dissect_rtp_hext_rfc5215_onebyte( tvbuff_t *tvb, packet_info *pinfo,",
          "1359: {",
          "1360:  proto_item *ti = NULL;",
          "1361:  proto_tree *rtp_hext_rfc5285_tree = NULL;",
          "",
          "[Removed Lines]",
          "1358:     proto_tree *rtp_hext_tree )",
          "",
          "[Added Lines]",
          "1476:   proto_tree *rtp_hext_tree )",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1410: static void",
          "1411: dissect_rtp_hext_rfc5215_twobytes(tvbuff_t *parent_tvb, guint id_offset,",
          "1413: {",
          "1414:  proto_item *ti = NULL;",
          "1415:  proto_tree *rtp_hext_rfc5285_tree = NULL;",
          "",
          "[Removed Lines]",
          "1412:     guint8 id, tvbuff_t *tvb, packet_info *pinfo, proto_tree *rtp_hext_tree)",
          "",
          "[Added Lines]",
          "1530:   guint8 id, tvbuff_t *tvb, packet_info *pinfo, proto_tree *rtp_hext_tree)",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "1454:  }",
          "1455: }",
          "1459: {",
          "1460:  proto_item *ti            = NULL;",
          "1461:  proto_tree *volatile rtp_tree = NULL;",
          "",
          "[Removed Lines]",
          "1457: static void",
          "1458: dissect_rtp( tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree )",
          "",
          "[Added Lines]",
          "1575: static gint",
          "1576: dissect_rtp( tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "1487:  unsigned int hdrext_offset = 0;",
          "1491:  static struct _rtp_info rtp_info_arr[4];",
          "1492:  static int rtp_info_current=0;",
          "",
          "[Removed Lines]",
          "1488:  tvbuff_t *newtvb = NULL;",
          "",
          "[Added Lines]",
          "1606:  tvbuff_t     *newtvb = NULL;",
          "1607:  const char   *pt = NULL;",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "1506:   switch (global_rtp_version0_type) {",
          "1507:   case RTP0_STUN:",
          "1508:    call_dissector(stun_handle, tvb, pinfo, tree);",
          "1510:   case RTP0_CLASSICSTUN:",
          "1511:    call_dissector(classicstun_handle, tvb, pinfo, tree);",
          "1514:   case RTP0_T38:",
          "1515:    call_dissector(t38_handle, tvb, pinfo, tree);",
          "1518:   case RTP0_SPRT:",
          "1519:    call_dissector(sprt_handle, tvb, pinfo, tree);",
          "1522:   case RTP0_INVALID:",
          "1523:    if (!(tvb_memeql(tvb, 4, \"ZRTP\", 4)))",
          "1524:    {",
          "1525:     call_dissector(zrtp_handle,tvb,pinfo,tree);",
          "1527:    }",
          "1528:   default:",
          "",
          "[Removed Lines]",
          "1509:    return;",
          "1512:    return;",
          "1516:    return;",
          "1520:    return;",
          "1526:     return;",
          "",
          "[Added Lines]",
          "1627:    return tvb_length(tvb);",
          "1630:    return tvb_length(tvb);",
          "1634:    return tvb_length(tvb);",
          "1638:    return tvb_length(tvb);",
          "1644:     return tvb_length(tvb);",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "1548:    proto_tree_add_uint( rtp_tree, hf_rtp_version, tvb,",
          "1549:        offset, 1, octet1);",
          "1550:   }",
          "1552:  }",
          "1554:  padding_set = RTP_PADDING( octet1 );",
          "",
          "[Removed Lines]",
          "1551:   return;",
          "",
          "[Added Lines]",
          "1669:   return offset;",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "1636:  }",
          "1637: #endif",
          "1640:  if ( (payload_type>95) && (payload_type<128) ) {",
          "1641:   if (p_conv_data && p_conv_data->rtp_dyn_payload){",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1757:  if (p_conv_data && p_conv_data->bta2dp_info && p_conv_data->bta2dp_info->codec_dissector) {",
          "1758:   rtp_info->info_payload_type_str = (const char *) dissector_handle_get_short_name(p_conv_data->bta2dp_info->codec_dissector);",
          "1759:  } else if (p_conv_data && p_conv_data->btvdp_info && p_conv_data->btvdp_info->codec_dissector) {",
          "1760:   rtp_info->info_payload_type_str = (const char *) dissector_handle_get_short_name(p_conv_data->btvdp_info->codec_dissector);",
          "1761:  }",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "1648:   }",
          "1649:  }",
          "1651:  col_add_fstr( pinfo->cinfo, COL_INFO,",
          "1652:      \"PT=%s, SSRC=0x%X, Seq=%u, Time=%u%s\",",
          "1654:      sync_src,",
          "1655:      seq_num,",
          "1656:      timestamp,",
          "1657:      marker_set ? \", Mark\" : \"\");",
          "1660:  if ( tree ) {",
          "1661:   proto_tree *item;",
          "",
          "[Removed Lines]",
          "1653:   payload_type_str ? payload_type_str : val_to_str_ext( payload_type, &rtp_payload_type_vals_ext,\"Unknown (%u)\" ),",
          "",
          "[Added Lines]",
          "1775:  if (p_conv_data && p_conv_data->bta2dp_info) {",
          "1776:   pt = (p_conv_data->bta2dp_info->codec_dissector) ? dissector_handle_get_short_name(p_conv_data->bta2dp_info->codec_dissector) : \"Unknown\";",
          "1777:  } else if (p_conv_data && p_conv_data->btvdp_info) {",
          "1778:   pt = (p_conv_data->btvdp_info->codec_dissector) ? dissector_handle_get_short_name(p_conv_data->btvdp_info->codec_dissector) : \"Unknown\";",
          "1779:  } else {",
          "1780:   pt = (payload_type_str ? payload_type_str : val_to_str_ext(payload_type, &rtp_payload_type_vals_ext,\"Unknown (%u)\"));",
          "1781:  }",
          "1785:   pt,",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "1682:   proto_tree_add_boolean( rtp_tree, hf_rtp_marker, tvb, offset,",
          "1683:       1, octet2 );",
          "1690:   offset++;",
          "",
          "[Removed Lines]",
          "1685:   proto_tree_add_uint_format_value( rtp_tree, hf_rtp_payload_type, tvb,",
          "1686:       offset, 1, octet2, \"%s (%u)\",",
          "1687:    payload_type_str ? payload_type_str : val_to_str_ext_const( payload_type, &rtp_payload_type_vals_ext,\"Unknown\"),",
          "1688:    payload_type);",
          "",
          "[Added Lines]",
          "1816:   proto_tree_add_uint_format( rtp_tree, hf_rtp_payload_type, tvb,",
          "1817:       offset, 1, octet2, \"Payload type: %s (%u)\", pt, payload_type);",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "1714:   proto_item_append_text(ti, \" (%u items)\", csrc_count);",
          "1715:   rtp_csrc_tree = proto_item_add_subtree( ti, ett_csrc_list );",
          "1718:    csrc_item = tvb_get_ntohl( tvb, offset );",
          "1719:    proto_tree_add_uint_format( rtp_csrc_tree,",
          "1720:        hf_rtp_csrc_item, tvb, offset, 4,",
          "",
          "[Removed Lines]",
          "1717:         for (i = 0; i < csrc_count; i++ ) {",
          "",
          "[Added Lines]",
          "1846:   for (i = 0; i < csrc_count; i++ ) {",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "1788:    call_dissector(data_handle,",
          "1789:        tvb_new_subset_remaining(tvb, offset),",
          "1790:        pinfo, rtp_tree);",
          "1792:   }",
          "1794:   padding_count = tvb_get_guint8( tvb,",
          "",
          "[Removed Lines]",
          "1791:    return;",
          "",
          "[Added Lines]",
          "1920:    return tvb_length(tvb);;",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "1800:   rtp_info->info_payload_len = tvb_length_remaining(tvb, offset);",
          "1801:   rtp_info->info_padding_count = padding_count;",
          "1803:   if (data_len > 0) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1932:   if (p_conv_data && p_conv_data->bta2dp_info) {",
          "1933:    if (p_conv_data->bta2dp_info->codec_dissector == sbc_handle) {",
          "1934:     rtp_info->info_payload_offset += 1;",
          "1935:     rtp_info->info_payload_len -= 1;",
          "1936:    }",
          "1938:    if (p_conv_data->bta2dp_info->content_protection_type == BTAVDTP_CONTENT_PROTECTION_TYPE_SCMS_T) {",
          "1939:     rtp_info->info_payload_offset += 1;",
          "1940:     rtp_info->info_payload_len -= 1;",
          "1941:    }",
          "1942:   }",
          "1944:   if (p_conv_data && p_conv_data->btvdp_info &&",
          "1945:     p_conv_data->bta2dp_info->content_protection_type == BTAVDTP_CONTENT_PROTECTION_TYPE_SCMS_T) {",
          "1946:    rtp_info->info_payload_offset += 1;",
          "1947:    rtp_info->info_payload_len -= 1;",
          "1948:   }",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "1811:         offset,",
          "1812:         data_len,",
          "1813:         data_len,",
          "1815:    } CATCH_ALL {",
          "1816:     if (!pinfo->flags.in_error_pkt)",
          "1817:      tap_queue_packet(rtp_tap, pinfo, rtp_info);",
          "",
          "[Removed Lines]",
          "1814:         payload_type );",
          "",
          "[Added Lines]",
          "1961:         payload_type);",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "1855:   if (tvb_reported_length_remaining(tvb, offset) > 0) {",
          "1857:    TRY {",
          "1858:     dissect_rtp_data( tvb, pinfo, tree, rtp_tree, offset,",
          "1859:         tvb_length_remaining( tvb, offset ),",
          "1860:         tvb_reported_length_remaining( tvb, offset ),",
          "1862:    } CATCH_ALL {",
          "1863:     if (!pinfo->flags.in_error_pkt)",
          "1864:      tap_queue_packet(rtp_tap, pinfo, rtp_info);",
          "",
          "[Removed Lines]",
          "1861:         payload_type );",
          "",
          "[Added Lines]",
          "2002:   rtp_info->info_payload_offset = offset;",
          "2003:   rtp_info->info_payload_len = tvb_length_remaining(tvb, offset);",
          "2005:   if (p_conv_data && p_conv_data->bta2dp_info) {",
          "2006:    if (p_conv_data->bta2dp_info->codec_dissector == sbc_handle) {",
          "2007:     rtp_info->info_payload_offset += 1;",
          "2008:     rtp_info->info_payload_len -= 1;",
          "2009:    }",
          "2011:    if (p_conv_data->bta2dp_info->content_protection_type == BTAVDTP_CONTENT_PROTECTION_TYPE_SCMS_T) {",
          "2012:     rtp_info->info_payload_offset += 1;",
          "2013:     rtp_info->info_payload_len -= 1;",
          "2014:    }",
          "2015:   }",
          "2017:   if (p_conv_data && p_conv_data->btvdp_info &&",
          "2018:     p_conv_data->bta2dp_info->content_protection_type == BTAVDTP_CONTENT_PROTECTION_TYPE_SCMS_T) {",
          "2019:    rtp_info->info_payload_offset += 1;",
          "2020:    rtp_info->info_payload_len -= 1;",
          "2021:   }",
          "2029:         payload_type);",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "1866:    }",
          "1867:    ENDTRY;",
          "1868:   }",
          "1871:  }",
          "1872:  if (!pinfo->flags.in_error_pkt)",
          "1873:   tap_queue_packet(rtp_tap, pinfo, rtp_info);",
          "1874: }",
          "1876: static void",
          "",
          "[Removed Lines]",
          "1869:   rtp_info->info_payload_offset = offset;",
          "1870:   rtp_info->info_payload_len = tvb_length_remaining(tvb, offset);",
          "",
          "[Added Lines]",
          "2041:  return offset;",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "2079:     p_conv_packet_data->rtp_dyn_payload = p_conv_data->rtp_dyn_payload;",
          "2080:     p_conv_packet_data->rtp_conv_info = p_conv_data->rtp_conv_info;",
          "2081:     p_conv_packet_data->srtp_info = p_conv_data->srtp_info;",
          "2082:     p_add_proto_data(pinfo->fd, proto_rtp, 0, p_conv_packet_data);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2250:     p_conv_packet_data->bta2dp_info = p_conv_data->bta2dp_info;",
          "2251:     p_conv_packet_data->btvdp_info = p_conv_data->btvdp_info;",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "2134: {",
          "2135:  proto_item *ti            = NULL;",
          "2136:  proto_tree *pkt_ccc_tree      = NULL;",
          "",
          "[Removed Lines]",
          "2132: static void",
          "2133: dissect_pkt_ccc(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)",
          "",
          "[Added Lines]",
          "2302: static int",
          "2303: dissect_pkt_ccc(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "2144:         ENC_TIME_NTP|ENC_BIG_ENDIAN);",
          "2145:  }",
          "2148: }",
          "",
          "[Removed Lines]",
          "2147:  dissect_rtp(tvb, pinfo, tree);",
          "",
          "[Added Lines]",
          "2317:  return dissect_rtp(tvb, pinfo, tree, data);",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "2194:  proto_register_field_array(proto_pkt_ccc, hf, array_length(hf));",
          "2195:  proto_register_subtree_array(ett, array_length(ett));",
          "2199:  pkt_ccc_module = prefs_register_protocol(proto_pkt_ccc, proto_reg_handoff_pkt_ccc);",
          "",
          "[Removed Lines]",
          "2197:  register_dissector(\"pkt_ccc\", dissect_pkt_ccc, proto_pkt_ccc);",
          "",
          "[Added Lines]",
          "2367:  new_register_dissector(\"pkt_ccc\", dissect_pkt_ccc, proto_pkt_ccc);",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "3041:  proto_register_field_array(proto_rtp, hf, array_length(hf));",
          "3042:  proto_register_subtree_array(ett, array_length(ett));",
          "3045:  register_dissector(\"rtp.rfc2198\", dissect_rtp_rfc2198, proto_rtp);",
          "3047:  rtp_tap = register_tap(\"rtp\");",
          "",
          "[Removed Lines]",
          "3044:  register_dissector(\"rtp\", dissect_rtp, proto_rtp);",
          "",
          "[Added Lines]",
          "3214:  new_register_dissector(\"rtp\", dissect_rtp, proto_rtp);",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "3128:   sprt_handle = find_dissector(\"sprt\");",
          "3129:   v150fw_handle = find_dissector(\"v150fw\");",
          "3131:   dissector_add_string(\"rtp_dyn_payload_type\", \"v150fw\", v150fw_handle);",
          "3133:   rtp_prefs_initialized = TRUE;",
          "3134:  } else {",
          "3135:   dissector_delete_uint(\"rtp.pt\", rtp_saved_rfc2198_pt, rtp_rfc2198_handle);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3301:   bta2dp_content_protection_header_scms_t = find_dissector(\"bta2dp_content_protection_header_scms_t\");",
          "3302:   btvdp_content_protection_header_scms_t = find_dissector(\"btvdp_content_protection_header_scms_t\");",
          "3303:   bta2dp_handle = find_dissector(\"bta2dp\");",
          "3304:   btvdp_handle = find_dissector(\"btvdp\");",
          "3305:   sbc_handle = find_dissector(\"sbc\");",
          "3309:   dissector_add_handle(\"btl2cap.cid\", rtp_handle);",
          "",
          "---------------"
        ],
        "epan/dissectors/packet-rtp.h||epan/dissectors/packet-rtp.h": [
          "File: epan/dissectors/packet-rtp.h -> epan/dissectors/packet-rtp.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "30: #include \"ws_symbol_export.h\"",
          "32: struct _rtp_info {",
          "33:  unsigned int  info_version;",
          "34:  gboolean      info_padding_set;",
          "35:  gboolean      info_marker_set;",
          "37:  unsigned int  info_payload_type;",
          "38:  unsigned int  info_padding_count;",
          "39:  guint16       info_seq_num;",
          "",
          "[Removed Lines]",
          "36:  gboolean   info_is_video;",
          "",
          "[Added Lines]",
          "30: #include \"epan/packet.h\"",
          "33: #include \"packet-btavdtp.h\"",
          "39:  gboolean      info_is_video;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "46:  gboolean      info_is_srtp;",
          "",
          "[Removed Lines]",
          "49:  gchar    *info_payload_type_str;",
          "50:  gint    info_payload_rate;",
          "",
          "[Added Lines]",
          "52:  const gchar   *info_payload_type_str;",
          "53:  gint          info_payload_rate;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "119: };",
          "121: typedef struct {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "122:  bta2dp_codec_info_t *bta2dp_info;",
          "123:  btvdp_codec_info_t *btvdp_info;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "144:                      GHashTable *rtp_dyn_payload,",
          "145:                      struct srtp_info *srtp_info);",
          "148: WS_DLL_PUBLIC",
          "149: void rtp_free_hash_dyn_payload(GHashTable *rtp_dyn_payload);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "153: void",
          "154: bluetooth_add_address(packet_info *pinfo, address *addr,",
          "155:          const gchar *setup_method, guint32 setup_frame_number,",
          "156:          gboolean is_video, void *data);",
          "",
          "---------------"
        ],
        "ui/rtp_stream.h||ui/rtp_stream.h": [
          "File: ui/rtp_stream.h -> ui/rtp_stream.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "58:     guint32 dest_port;",
          "59:     guint32 ssrc;",
          "60:     guint8  pt;",
          "62:     guint32 npackets;",
          "",
          "[Removed Lines]",
          "61:     gchar *info_payload_type_str;",
          "",
          "[Added Lines]",
          "61:     const gchar *info_payload_type_str;",
          "",
          "---------------"
        ],
        "ui/tap-rtp-common.c||ui/tap-rtp-common.c": [
          "File: ui/tap-rtp-common.c -> ui/tap-rtp-common.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "417: #define NUM_DYN_CLOCK_VALUES (sizeof mimetype_and_clock_map / sizeof mimetype_and_clock_map[0])",
          "419: static guint32",
          "421: {",
          "422:  int i;",
          "",
          "[Removed Lines]",
          "420: get_dyn_pt_clock_rate(gchar *payload_type_str)",
          "",
          "[Added Lines]",
          "420: get_dyn_pt_clock_rate(const gchar *payload_type_str)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "58804a6f158ce39f1944b172486d6e8316ea0953",
      "candidate_info": {
        "commit_hash": "58804a6f158ce39f1944b172486d6e8316ea0953",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/58804a6f158ce39f1944b172486d6e8316ea0953",
        "files": [
          "epan/dissectors/packet-adwin.c",
          "epan/dissectors/packet-ctdb.c",
          "epan/dissectors/packet-fcp.c",
          "epan/dissectors/packet-ipmi.c",
          "epan/dissectors/packet-mysql.c",
          "epan/dissectors/packet-pana.c",
          "epan/dissectors/packet-reload-framing.c",
          "epan/dissectors/packet-rtp.c",
          "epan/dissectors/packet-scsi-osd.c",
          "epan/dissectors/packet-xmcp.c"
        ],
        "message": "Convert another 10 dissectors to wmem.\n\nsvn path=/trunk/; revision=51612",
        "before_after_code_files": [
          "epan/dissectors/packet-adwin.c||epan/dissectors/packet-adwin.c",
          "epan/dissectors/packet-ctdb.c||epan/dissectors/packet-ctdb.c",
          "epan/dissectors/packet-fcp.c||epan/dissectors/packet-fcp.c",
          "epan/dissectors/packet-ipmi.c||epan/dissectors/packet-ipmi.c",
          "epan/dissectors/packet-mysql.c||epan/dissectors/packet-mysql.c",
          "epan/dissectors/packet-pana.c||epan/dissectors/packet-pana.c",
          "epan/dissectors/packet-reload-framing.c||epan/dissectors/packet-reload-framing.c",
          "epan/dissectors/packet-rtp.c||epan/dissectors/packet-rtp.c",
          "epan/dissectors/packet-scsi-osd.c||epan/dissectors/packet-scsi-osd.c",
          "epan/dissectors/packet-xmcp.c||epan/dissectors/packet-xmcp.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "epan/dissectors/packet-rtp.c||epan/dissectors/packet-rtp.c"
          ],
          "candidate": [
            "epan/dissectors/packet-rtp.c||epan/dissectors/packet-rtp.c"
          ]
        }
      },
      "candidate_diff": {
        "epan/dissectors/packet-adwin.c||epan/dissectors/packet-adwin.c": [
          "File: epan/dissectors/packet-adwin.c -> epan/dissectors/packet-adwin.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "509: typedef struct _adwin_conv_info_t {",
          "511: } adwin_conv_info_t;",
          "513: typedef enum { ADWIN_REQUEST,",
          "",
          "[Removed Lines]",
          "510:  emem_tree_t *pdus;",
          "",
          "[Added Lines]",
          "510:  wmem_tree_t *pdus;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "543:   conversation_add_proto_data(conversation, proto_adwin, adwin_info);",
          "544:  }",
          "545:  if (!pinfo->fd->flags.visited) {",
          "546:   if (direction == ADWIN_REQUEST) {",
          "549:    adwin_trans->req_frame = pinfo->fd->num;",
          "550:    adwin_trans->rep_frame = 0;",
          "551:    adwin_trans->req_time = pinfo->fd->abs_ts;",
          "553:   } else {",
          "555:    if (adwin_trans) {",
          "556:     adwin_trans->rep_frame = pinfo->fd->num;",
          "557:    }",
          "558:   }",
          "559:  } else {",
          "561:  }",
          "562:  if (!adwin_trans) {",
          "",
          "[Removed Lines]",
          "539:   adwin_info = se_new(adwin_conv_info_t);",
          "540:   adwin_info->pdus = se_tree_create_non_persistent(",
          "541:      EMEM_TREE_TYPE_RED_BLACK, \"adwin_pdus\");",
          "548:    adwin_trans = se_new(adwin_transaction_t);",
          "552:    se_tree_insert32(adwin_info->pdus, seq_num, (void *)adwin_trans);",
          "554:    adwin_trans = (adwin_transaction_t *)se_tree_lookup32(adwin_info->pdus, seq_num);",
          "560:   adwin_trans = (adwin_transaction_t *)se_tree_lookup32(adwin_info->pdus, seq_num);",
          "",
          "[Added Lines]",
          "539:   adwin_info = wmem_new(wmem_file_scope(), adwin_conv_info_t);",
          "540:   adwin_info->pdus = wmem_tree_new(wmem_file_scope());",
          "547:    adwin_trans = wmem_new(wmem_file_scope(), adwin_transaction_t);",
          "551:    wmem_tree_insert32(adwin_info->pdus, seq_num, (void *)adwin_trans);",
          "553:    adwin_trans = (adwin_transaction_t *)wmem_tree_lookup32(adwin_info->pdus, seq_num);",
          "559:   adwin_trans = (adwin_transaction_t *)wmem_tree_lookup32(adwin_info->pdus, seq_num);",
          "",
          "---------------"
        ],
        "epan/dissectors/packet-ctdb.c||epan/dissectors/packet-ctdb.c": [
          "File: epan/dissectors/packet-ctdb.c -> epan/dissectors/packet-ctdb.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "30: #include <epan/packet.h>",
          "31: #include <epan/expert.h>",
          "34: void proto_register_ctdb(void);",
          "35: void proto_reg_handoff_ctdb(void);",
          "",
          "[Removed Lines]",
          "32: #include <epan/emem.h>",
          "",
          "[Added Lines]",
          "32: #include <epan/wmem/wmem.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "81: static expert_field ei_ctdb_too_many_nodes = EI_INIT;",
          "85: typedef struct _ctdb_trans_t {",
          "86:  guint32 key_hash;",
          "87:  guint32 request_in;",
          "",
          "[Removed Lines]",
          "84: static emem_tree_t *ctdb_transactions=NULL;",
          "",
          "[Added Lines]",
          "84: static wmem_tree_t *ctdb_transactions=NULL;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "90: } ctdb_trans_t;",
          "94: typedef struct _ctdb_control_t {",
          "95:  guint32 opcode;",
          "96:  guint32 request_in;",
          "",
          "[Removed Lines]",
          "93: static emem_tree_t *ctdb_controls=NULL;",
          "",
          "[Added Lines]",
          "93: static wmem_tree_t *ctdb_controls=NULL;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "578: dissect_ctdb_reply_dmaster(tvbuff_t *tvb, int offset, packet_info *pinfo _U_, proto_tree *tree, guint32 reqid, guint32 dst, int endianess)",
          "579: {",
          "580:  guint32 datalen, keylen;",
          "582:  ctdb_trans_t *ctdb_trans;",
          "",
          "[Removed Lines]",
          "581:  emem_tree_key_t tkey[3];",
          "",
          "[Added Lines]",
          "581:  wmem_tree_key_t tkey[3];",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "621:  tkey[1].length=1;",
          "622:  tkey[1].key=&dst;",
          "623:  tkey[2].length=0;",
          "626:  if(ctdb_trans){",
          "627:   ctdb_trans->response_in=pinfo->fd->num;",
          "",
          "[Removed Lines]",
          "624:  ctdb_trans=(ctdb_trans_t *)se_tree_lookup32_array(ctdb_transactions, &tkey[0]);",
          "",
          "[Added Lines]",
          "624:  ctdb_trans=(ctdb_trans_t *)wmem_tree_lookup32_array(ctdb_transactions, &tkey[0]);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "635: dissect_ctdb_req_dmaster(tvbuff_t *tvb, int offset, packet_info *pinfo _U_, proto_tree *tree, guint32 reqid, int endianess)",
          "636: {",
          "637:  guint32 keylen, datalen, dmaster;",
          "639:  ctdb_trans_t *ctdb_trans;",
          "",
          "[Removed Lines]",
          "638:  emem_tree_key_t tkey[3];",
          "",
          "[Added Lines]",
          "638:  wmem_tree_key_t tkey[3];",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "687:  tkey[1].length=1;",
          "688:  tkey[1].key=&dmaster;",
          "689:  tkey[2].length=0;",
          "692:  if(ctdb_trans){",
          "693:   ctdb_display_trans(pinfo, tree, tvb, ctdb_trans);",
          "",
          "[Removed Lines]",
          "690:  ctdb_trans=(ctdb_trans_t *)se_tree_lookup32_array(ctdb_transactions, &tkey[0]);",
          "",
          "[Added Lines]",
          "690:  ctdb_trans=(ctdb_trans_t *)wmem_tree_lookup32_array(ctdb_transactions, &tkey[0]);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "753:  if(!pinfo->fd->flags.visited){",
          "757:   ctdb_control->opcode=opcode;",
          "758:   ctdb_control->request_in=pinfo->fd->num;",
          "759:   ctdb_control->response_in=0;",
          "",
          "[Removed Lines]",
          "754:   emem_tree_key_t tkey[4];",
          "756:   ctdb_control=se_new(ctdb_control_t);",
          "",
          "[Added Lines]",
          "754:   wmem_tree_key_t tkey[4];",
          "756:   ctdb_control=wmem_new(wmem_file_scope(), ctdb_control_t);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "766:   tkey[2].key=&dst;",
          "767:   tkey[3].length=0;",
          "770:  } else {",
          "773:   tkey[0].length=1;",
          "774:   tkey[0].key=&reqid;",
          "",
          "[Removed Lines]",
          "769:   se_tree_insert32_array(ctdb_controls, &tkey[0], ctdb_control);",
          "771:   emem_tree_key_t tkey[4];",
          "",
          "[Added Lines]",
          "769:   wmem_tree_insert32_array(ctdb_controls, &tkey[0], ctdb_control);",
          "771:   wmem_tree_key_t tkey[4];",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "777:   tkey[2].length=1;",
          "778:   tkey[2].key=&dst;",
          "779:   tkey[3].length=0;",
          "781:  }",
          "",
          "[Removed Lines]",
          "780:   ctdb_control=(ctdb_control_t *)se_tree_lookup32_array(ctdb_controls, &tkey[0]);",
          "",
          "[Added Lines]",
          "780:   ctdb_control=(ctdb_control_t *)wmem_tree_lookup32_array(ctdb_controls, &tkey[0]);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "795: dissect_ctdb_reply_control(tvbuff_t *tvb, int offset, packet_info *pinfo _U_, proto_tree *tree, guint32 reqid, guint32 src, guint32 dst, int endianess)",
          "796: {",
          "797:  ctdb_control_t *ctdb_control;",
          "799:  proto_item *item;",
          "800:  guint32 datalen, errorlen, status;",
          "801:  int data_offset;",
          "",
          "[Removed Lines]",
          "798:  emem_tree_key_t tkey[4];",
          "",
          "[Added Lines]",
          "798:  wmem_tree_key_t tkey[4];",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "808:  tkey[2].length=1;",
          "809:  tkey[2].key=&src;",
          "810:  tkey[3].length=0;",
          "813:  if(!ctdb_control){",
          "814:   return offset;",
          "",
          "[Removed Lines]",
          "811:  ctdb_control=(ctdb_control_t *)se_tree_lookup32_array(ctdb_controls, &tkey[0]);",
          "",
          "[Added Lines]",
          "811:  ctdb_control=(ctdb_control_t *)wmem_tree_lookup32_array(ctdb_controls, &tkey[0]);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "943:  if(!pinfo->fd->flags.visited){",
          "947:   ctdb_trans->key_hash=keyhash;",
          "948:   ctdb_trans->request_in=pinfo->fd->num;",
          "949:   ctdb_trans->response_in=0;",
          "",
          "[Removed Lines]",
          "944:   emem_tree_key_t tkey[3];",
          "946:   ctdb_trans=se_new(ctdb_trans_t);",
          "",
          "[Added Lines]",
          "944:   wmem_tree_key_t tkey[3];",
          "946:   ctdb_trans=wmem_new(wmem_file_scope(), ctdb_trans_t);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "954:   tkey[1].key=&caller;",
          "955:   tkey[2].length=0;",
          "958:  } else {",
          "961:   tkey[0].length=1;",
          "962:   tkey[0].key=&reqid;",
          "963:   tkey[1].length=1;",
          "964:   tkey[1].key=&caller;",
          "965:   tkey[2].length=0;",
          "967:  }",
          "969:  if(ctdb_trans){",
          "",
          "[Removed Lines]",
          "957:   se_tree_insert32_array(ctdb_transactions, &tkey[0], ctdb_trans);",
          "959:   emem_tree_key_t tkey[3];",
          "966:   ctdb_trans=(ctdb_trans_t *)se_tree_lookup32_array(ctdb_transactions, &tkey[0]);",
          "",
          "[Added Lines]",
          "957:   wmem_tree_insert32_array(ctdb_transactions, &tkey[0], ctdb_trans);",
          "959:   wmem_tree_key_t tkey[3];",
          "966:   ctdb_trans=(ctdb_trans_t *)wmem_tree_lookup32_array(ctdb_transactions, &tkey[0]);",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "1234:  proto_register_subtree_array(ett, array_length(ett));",
          "1235:  expert_ctdb = expert_register_protocol(proto_ctdb);",
          "1236:  expert_register_field_array(expert_ctdb, ei, array_length(ei));",
          "1237: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1238:  ctdb_transactions = wmem_tree_new_autoreset(wmem_epan_scope(), wmem_file_scope());",
          "1239:  ctdb_controls     = wmem_tree_new_autoreset(wmem_epan_scope(), wmem_file_scope());",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "1246:  dissector_add_handle(\"tcp.port\", ctdb_handle);",
          "1248:  heur_dissector_add(\"tcp\", dissect_ctdb, proto_ctdb);",
          "1252: }",
          "",
          "[Removed Lines]",
          "1250:  ctdb_transactions=se_tree_create(EMEM_TREE_TYPE_RED_BLACK, \"CTDB transactions tree\");",
          "1251:  ctdb_controls=se_tree_create(EMEM_TREE_TYPE_RED_BLACK, \"CTDB controls tree\");",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "epan/dissectors/packet-fcp.c||epan/dissectors/packet-fcp.c": [
          "File: epan/dissectors/packet-fcp.c -> epan/dissectors/packet-fcp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "28: #include <glib.h>",
          "31: #include <epan/packet.h>",
          "32: #include <epan/conversation.h>",
          "33: #include <epan/etypes.h>",
          "",
          "[Removed Lines]",
          "30: #include <epan/emem.h>",
          "",
          "[Added Lines]",
          "30: #include <epan/wmem/wmem.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "92: static gint ett_fcp_rsp_flags = -1;",
          "94: typedef struct _fcp_conv_data_t {",
          "96: } fcp_conv_data_t;",
          "98: typedef struct fcp_request_data {",
          "",
          "[Removed Lines]",
          "95:     emem_tree_t *luns;",
          "",
          "[Added Lines]",
          "95:     wmem_tree_t *luns;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "429:         fchdr->itlq->lun = lun;",
          "431:     if (!pinfo->fd->flags.visited) {",
          "433:         proto_data->lun = lun;",
          "434:         p_add_proto_data(pinfo->fd, proto_fcp, 0, proto_data);",
          "435:     }",
          "438:     if (!request_data) {",
          "440:         request_data->request_frame = pinfo->fd->num;",
          "441:         request_data->response_frame = 0;",
          "442:         request_data->request_time = pinfo->fd->abs_ts;",
          "444:         request_data->itl->cmdset = 0xff;",
          "445:         request_data->itl->conversation = conversation;",
          "447:     }",
          "449:     proto_tree_add_item(tree, hf_fcp_crn, tvb, offset+8, 1, ENC_BIG_ENDIAN);",
          "",
          "[Removed Lines]",
          "432:         proto_data = se_new(fcp_proto_data_t);",
          "437:     request_data = (fcp_request_data_t*)se_tree_lookup32(fcp_conv_data->luns, lun);",
          "439:         request_data = se_new(fcp_request_data_t);",
          "443:         request_data->itl = se_new(itl_nexus_t);",
          "446:         se_tree_insert32(fcp_conv_data->luns, lun, request_data);",
          "",
          "[Added Lines]",
          "432:         proto_data = wmem_new(wmem_file_scope(), fcp_proto_data_t);",
          "437:     request_data = (fcp_request_data_t*)wmem_tree_lookup32(fcp_conv_data->luns, lun);",
          "439:         request_data = wmem_new(wmem_file_scope(), fcp_request_data_t);",
          "443:         request_data->itl = wmem_new(wmem_file_scope(), itl_nexus_t);",
          "446:         wmem_tree_insert32(fcp_conv_data->luns, lun, request_data);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "703:         fcp_conv_data = (fcp_conv_data_t *)conversation_get_proto_data(fc_conv, proto_fcp);",
          "704:     }",
          "705:     if (!fcp_conv_data) {",
          "708:         conversation_add_proto_data(fc_conv, proto_fcp, fcp_conv_data);",
          "709:     }",
          "",
          "[Removed Lines]",
          "706:         fcp_conv_data = se_new(fcp_conv_data_t);",
          "707:         fcp_conv_data->luns = se_tree_create_non_persistent(EMEM_TREE_TYPE_RED_BLACK, \"FCP Luns\");",
          "",
          "[Added Lines]",
          "706:         fcp_conv_data = wmem_new(wmem_file_scope(), fcp_conv_data_t);",
          "707:         fcp_conv_data->luns = wmem_tree_new(wmem_file_scope());",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "712:        The only way that consistently works is to save the lun on the first pass when packets",
          "714:     if (!pinfo->fd->flags.visited) {",
          "716:         proto_data->lun = fchdr->itlq->lun;",
          "717:         p_add_proto_data(pinfo->fd, proto_fcp, 0, proto_data);",
          "718:     } else {",
          "",
          "[Removed Lines]",
          "715:         proto_data = se_new(fcp_proto_data_t);",
          "",
          "[Added Lines]",
          "715:         proto_data = wmem_new(wmem_file_scope(), fcp_proto_data_t);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "721:     }",
          "723:     if ((r_ctl != FCP_IU_CMD) && (r_ctl != FCP_IU_UNSOL_CTL)) {",
          "725:     }",
          "",
          "[Removed Lines]",
          "724:         request_data = (fcp_request_data_t *)se_tree_lookup32(fcp_conv_data->luns, fchdr->itlq->lun);",
          "",
          "[Added Lines]",
          "724:         request_data = (fcp_request_data_t *)wmem_tree_lookup32(fcp_conv_data->luns, fchdr->itlq->lun);",
          "",
          "---------------"
        ],
        "epan/dissectors/packet-ipmi.c||epan/dissectors/packet-ipmi.c": [
          "File: epan/dissectors/packet-ipmi.c -> epan/dissectors/packet-ipmi.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "32: #include <epan/packet.h>",
          "33: #include <epan/conversation.h>",
          "35: #include <epan/to_str.h>",
          "36: #include <epan/prefs.h>",
          "37: #include <epan/addr_resolv.h>",
          "",
          "[Removed Lines]",
          "34: #include <epan/emem.h>",
          "",
          "[Added Lines]",
          "34: #include <epan/wmem/wmem.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "96: };",
          "98: struct ipmi_keytree {",
          "100: };",
          "102: struct ipmi_parse_typelen {",
          "",
          "[Removed Lines]",
          "99:  emem_tree_t *heads;",
          "",
          "[Added Lines]",
          "99:  wmem_tree_t *heads;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "350:  kt = (struct ipmi_keytree *)conversation_get_proto_data(cnv, proto_ipmi);",
          "351:  if (!kt) {",
          "355:   conversation_add_proto_data(cnv, proto_ipmi, kt);",
          "356:  }",
          "",
          "[Removed Lines]",
          "352:   kt = se_new(struct ipmi_keytree);",
          "353:   kt->heads = se_tree_create_non_persistent(EMEM_TREE_TYPE_RED_BLACK,",
          "354:     \"ipmi_key_heads\");",
          "",
          "[Added Lines]",
          "352:   kt = wmem_new(wmem_file_scope(), struct ipmi_keytree);",
          "353:   kt->heads = wmem_tree_new(wmem_file_scope());",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "362:     hdr->trg_sa, hdr->trg_lun, hdr->src_sa, hdr->src_lun, hdr->seq,",
          "363:     hdr->netfn, hdr->cmd);",
          "364:   key = makekey(hdr);",
          "366:   if (!kh) {",
          "369:   }",
          "370:   if ((rr = key_lookup_reqresp(kh, hdr, pinfo->fd)) != NULL) {",
          "",
          "[Removed Lines]",
          "365:   kh = (struct ipmi_keyhead *)se_tree_lookup32(kt->heads, key);",
          "367:    kh = se_new0(struct ipmi_keyhead);",
          "368:    se_tree_insert32(kt->heads, key, kh);",
          "",
          "[Added Lines]",
          "364:   kh = (struct ipmi_keyhead *)wmem_tree_lookup32(kt->heads, key);",
          "366:    kh = wmem_new0(wmem_file_scope(), struct ipmi_keyhead);",
          "367:    wmem_tree_insert32(kt->heads, key, kh);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "394:   if (!current_saved_data) {",
          "397:   }",
          "399:   rr->whichresponse = dfmt->whichresponse;",
          "400:   rr->netfn = hdr->netfn & 0x3e;",
          "401:   rr->cmd = hdr->cmd;",
          "",
          "[Removed Lines]",
          "396:    current_saved_data = se_new0(struct ipmi_saved_data);",
          "398:   rr = se_new0(struct ipmi_reqresp);",
          "",
          "[Added Lines]",
          "395:    current_saved_data = wmem_new0(wmem_file_scope(), struct ipmi_saved_data);",
          "397:   rr = wmem_new0(wmem_file_scope(), struct ipmi_reqresp);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "452:     hdr->trg_sa, hdr->trg_lun, hdr->src_sa, hdr->src_lun, hdr->seq,",
          "453:     hdr->netfn, hdr->cmd);",
          "454:   key = makekey(hdr);",
          "456:     (rr = key_lookup_reqresp(kh, hdr, pinfo->fd)) != NULL) {",
          "457:    debug_printf(\"Found [ <%d,%d,%d> (%02x,%1x <-> %02x,%1x : %02x) %02x %02x ]\\n\",",
          "458:      rr->frames[0].num, rr->frames[1].num, rr->frames[2].num,",
          "",
          "[Removed Lines]",
          "455:   if ((kh = (struct ipmi_keyhead *)se_tree_lookup32(kt->heads, key)) != NULL &&",
          "",
          "[Added Lines]",
          "454:   if ((kh = (struct ipmi_keyhead *)wmem_tree_lookup32(kt->heads, key)) != NULL &&",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "735:  len = typelen & msk;",
          "736:  ptr->get_len(&clen, &blen, tvb, offs + 1, len, is_fru);",
          "739:  ptr->parse(str, tvb, offs + 1, clen);",
          "740:  str[clen] = '\\0';",
          "",
          "[Removed Lines]",
          "738:  str = (char *)ep_alloc(clen + 1);",
          "",
          "[Added Lines]",
          "737:  str = (char *)wmem_alloc(wmem_packet_scope(), clen + 1);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "853:   ipmi_cmd_tab[netfn >> 1].desc : \"Reserved\";",
          "854:  db = nf ? nf->desc : NULL;",
          "855:  if (db) {",
          "857:  } else {",
          "858:   return dn;",
          "859:  }",
          "",
          "[Removed Lines]",
          "856:   return ep_strdup_printf(\"%s (%s)\", db, dn);",
          "",
          "[Added Lines]",
          "855:   return wmem_strdup_printf(wmem_packet_scope(), \"%s (%s)\", db, dn);",
          "",
          "---------------"
        ],
        "epan/dissectors/packet-mysql.c||epan/dissectors/packet-mysql.c": [
          "File: epan/dissectors/packet-mysql.c -> epan/dissectors/packet-mysql.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "42: #include <epan/packet.h>",
          "43: #include <epan/conversation.h>",
          "46: #include <epan/dissectors/packet-tcp.h>",
          "47: #include <epan/prefs.h>",
          "",
          "[Removed Lines]",
          "44: #include <epan/emem.h>",
          "",
          "[Added Lines]",
          "44: #include <epan/wmem/wmem.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "588:  mysql_state_t state;",
          "589:  guint16 stmt_num_params;",
          "590:  guint16 stmt_num_fields;",
          "592: #ifdef CTDEBUG",
          "593:  guint32 generation;",
          "594: #endif",
          "",
          "[Removed Lines]",
          "591:  emem_tree_t* stmts;",
          "",
          "[Added Lines]",
          "591:  wmem_tree_t* stmts;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "706:  conn_data= (mysql_conn_data_t *)conversation_get_proto_data(conversation, proto_mysql);",
          "707:  if (!conn_data) {",
          "709:   conn_data->srv_caps= 0;",
          "710:   conn_data->clnt_caps= 0;",
          "711:   conn_data->clnt_caps_ext= 0;",
          "712:   conn_data->state= UNDEFINED;",
          "714: #ifdef CTDEBUG",
          "715:   conn_data->generation= 0;",
          "716: #endif",
          "",
          "[Removed Lines]",
          "708:   conn_data= se_new(mysql_conn_data_t);",
          "713:   conn_data->stmts= se_tree_create_non_persistent(EMEM_TREE_TYPE_RED_BLACK, \"PROTO_mysql_stmts\");",
          "",
          "[Added Lines]",
          "708:   conn_data= wmem_new(wmem_file_scope(), mysql_conn_data_t);",
          "713:   conn_data->stmts= wmem_tree_new(wmem_file_scope());",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "728:   mysql_frame_data_p->state = conn_data->state;",
          "729:   p_add_proto_data(pinfo->fd, proto_mysql, 0, mysql_frame_data_p);",
          "",
          "[Removed Lines]",
          "727:   mysql_frame_data_p = se_new(struct mysql_frame_data);",
          "",
          "[Added Lines]",
          "727:   mysql_frame_data_p = wmem_new(wmem_file_scope(), struct mysql_frame_data);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1314:   stmt_id = tvb_get_letohl(tvb, offset);",
          "1315:   offset += 4;",
          "1318:   if (stmt_data != NULL) {",
          "1319:    guint16 data_param = tvb_get_letohs(tvb, offset);",
          "1320:    if (stmt_data->nparam > data_param) {",
          "",
          "[Removed Lines]",
          "1317:   stmt_data = (my_stmt_data_t *)se_tree_lookup32(conn_data->stmts, stmt_id);",
          "",
          "[Added Lines]",
          "1317:   stmt_data = (my_stmt_data_t *)wmem_tree_lookup32(conn_data->stmts, stmt_id);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1349:   proto_tree_add_item(req_tree, hf_mysql_exec_iter, tvb, offset, 4, ENC_LITTLE_ENDIAN);",
          "1350:   offset += 4;",
          "1353:   if (stmt_data != NULL) {",
          "1354:    if (stmt_data->nparam != 0) {",
          "1355:     guint8 stmt_bound;",
          "",
          "[Removed Lines]",
          "1352:   stmt_data = (my_stmt_data_t *)se_tree_lookup32(conn_data->stmts, stmt_id);",
          "",
          "[Added Lines]",
          "1352:   stmt_data = (my_stmt_data_t *)wmem_tree_lookup32(conn_data->stmts, stmt_id);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1844:  offset += 2;",
          "1845:  proto_tree_add_item(tree, hf_mysql_num_params, tvb, offset, 2, ENC_LITTLE_ENDIAN);",
          "1846:  conn_data->stmt_num_params = tvb_get_letohs(tvb, offset);",
          "1848:  stmt_data->nparam = conn_data->stmt_num_params;",
          "1849:  flagsize = (int)(sizeof(guint8) * stmt_data->nparam);",
          "1851:  memset(stmt_data->param_flags, 0, flagsize);",
          "1853:  offset += 2;",
          "1855:  offset += 1;",
          "",
          "[Removed Lines]",
          "1847:  stmt_data = se_new(struct my_stmt_data);",
          "1850:  stmt_data->param_flags = (guint8 *)se_alloc(flagsize);",
          "1852:  se_tree_insert32(conn_data->stmts, stmt_id, stmt_data);",
          "",
          "[Added Lines]",
          "1847:  stmt_data = wmem_new(wmem_file_scope(), struct my_stmt_data);",
          "1850:  stmt_data->param_flags = (guint8 *)wmem_alloc(wmem_file_scope(), flagsize);",
          "1852:  wmem_tree_insert32(conn_data->stmts, stmt_id, stmt_data);",
          "",
          "---------------"
        ],
        "epan/dissectors/packet-pana.c||epan/dissectors/packet-pana.c": [
          "File: epan/dissectors/packet-pana.c -> epan/dissectors/packet-pana.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "35: #include <epan/packet.h>",
          "36: #include <epan/conversation.h>",
          "39: #if 0",
          "40: #define PANA_UDP_PORT 3001",
          "",
          "[Removed Lines]",
          "37: #include <epan/emem.h>",
          "",
          "[Added Lines]",
          "37: #include <epan/wmem/wmem.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "207: } pana_transaction_t;",
          "209: typedef struct _pana_conv_info_t {",
          "211: } pana_conv_info_t;",
          "213: static void",
          "",
          "[Removed Lines]",
          "210:         emem_tree_t *pdus;",
          "",
          "[Added Lines]",
          "210:         wmem_tree_t *pdus;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "550:                conversation_add_proto_data(conversation, proto_pana, pana_info);",
          "551:        }",
          "",
          "[Removed Lines]",
          "547:                pana_info = se_new(pana_conv_info_t);",
          "548:                pana_info->pdus=se_tree_create_non_persistent(EMEM_TREE_TYPE_RED_BLACK, \"pana_pdus\");",
          "",
          "[Added Lines]",
          "547:                pana_info = wmem_new(wmem_file_scope(), pana_conv_info_t);",
          "548:                pana_info->pdus=wmem_tree_new(wmem_file_scope());",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "553:        if(!pinfo->fd->flags.visited){",
          "554:                if(flags&PANA_FLAG_R){",
          "557:                       pana_trans->req_frame=pinfo->fd->num;",
          "558:                       pana_trans->rep_frame=0;",
          "559:                       pana_trans->req_time=pinfo->fd->abs_ts;",
          "561:                } else {",
          "563:                       if(pana_trans){",
          "564:                               pana_trans->rep_frame=pinfo->fd->num;",
          "565:                       }",
          "566:                }",
          "567:        } else {",
          "569:        }",
          "571:        if(!pana_trans){",
          "574:                pana_trans->req_frame=0;",
          "575:                pana_trans->rep_frame=0;",
          "576:                pana_trans->req_time=pinfo->fd->abs_ts;",
          "",
          "[Removed Lines]",
          "556:                       pana_trans=se_new(pana_transaction_t);",
          "560:                       se_tree_insert32(pana_info->pdus, seq_num, (void *)pana_trans);",
          "562:                       pana_trans=(pana_transaction_t *)se_tree_lookup32(pana_info->pdus, seq_num);",
          "568:                pana_trans=(pana_transaction_t *)se_tree_lookup32(pana_info->pdus, seq_num);",
          "573:                pana_trans=ep_new(pana_transaction_t);",
          "",
          "[Added Lines]",
          "556:                       pana_trans=wmem_new(wmem_file_scope(), pana_transaction_t);",
          "560:                       wmem_tree_insert32(pana_info->pdus, seq_num, (void *)pana_trans);",
          "562:                       pana_trans=(pana_transaction_t *)wmem_tree_lookup32(pana_info->pdus, seq_num);",
          "568:                pana_trans=(pana_transaction_t *)wmem_tree_lookup32(pana_info->pdus, seq_num);",
          "573:                pana_trans=wmem_new(wmem_packet_scope(), pana_transaction_t);",
          "",
          "---------------"
        ],
        "epan/dissectors/packet-reload-framing.c||epan/dissectors/packet-reload-framing.c": [
          "File: epan/dissectors/packet-reload-framing.c -> epan/dissectors/packet-reload-framing.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "33: #include <epan/expert.h>",
          "34: #include <epan/tap.h>",
          "35: #include <epan/exported_pdu.h>",
          "36: #include <packet-tcp.h>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "36: #include <epan/wmem/wmem.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "66: typedef struct _reload_frame_conv_info_t {",
          "68: } reload_conv_info_t;",
          "",
          "[Removed Lines]",
          "67:   emem_tree_t *transaction_pdus;",
          "",
          "[Added Lines]",
          "68:   wmem_tree_t *transaction_pdus;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "116:   proto_tree         *reload_framing_tree;",
          "117:   guint32             relo_token;",
          "118:   guint32             message_length = 0;",
          "120:   guint32            *key_save, len_save;",
          "121:   guint32             sequence;",
          "122:   guint               effective_length;",
          "",
          "[Removed Lines]",
          "119:   emem_tree_key_t     transaction_id_key[4];",
          "",
          "[Added Lines]",
          "120:   wmem_tree_key_t     transaction_id_key[4];",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "239:     conversation_add_proto_data(conversation, proto_reload_framing, reload_framing_info);",
          "240:   }",
          "242:   if (!pinfo->fd->flags.visited) {",
          "243:     if ((reload_frame = (reload_frame_t *)",
          "245:       transaction_id_key[2].key    = key_save;",
          "246:       transaction_id_key[2].length = len_save;",
          "248:       reload_frame->data_frame = 0;",
          "249:       reload_frame->ack_frame  = 0;",
          "250:       reload_frame->req_time   = pinfo->fd->abs_ts;",
          "252:     }",
          "253:     transaction_id_key[2].key    = key_save;",
          "254:     transaction_id_key[2].length = len_save;",
          "",
          "[Removed Lines]",
          "236:     reload_framing_info = se_new(reload_conv_info_t);",
          "237:     reload_framing_info->transaction_pdus = se_tree_create_non_persistent(EMEM_TREE_TYPE_RED_BLACK,",
          "238:                                                                           \"reload_framing_transaction_pdus\");",
          "244:            se_tree_lookup32_array(reload_framing_info->transaction_pdus, transaction_id_key)) == NULL) {",
          "247:       reload_frame = se_new(reload_frame_t);",
          "251:       se_tree_insert32_array(reload_framing_info->transaction_pdus, transaction_id_key, (void *)reload_frame);",
          "",
          "[Added Lines]",
          "237:     reload_framing_info = wmem_new(wmem_file_scope(), reload_conv_info_t);",
          "238:     reload_framing_info->transaction_pdus = wmem_tree_new(wmem_file_scope());",
          "244:            wmem_tree_lookup32_array(reload_framing_info->transaction_pdus, transaction_id_key)) == NULL) {",
          "247:       reload_frame = wmem_new(wmem_file_scope(), reload_frame_t);",
          "251:       wmem_tree_insert32_array(reload_framing_info->transaction_pdus, transaction_id_key, (void *)reload_frame);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "269:     }",
          "270:   }",
          "271:   else {",
          "273:     transaction_id_key[2].key    = key_save;",
          "274:     transaction_id_key[2].length = len_save;",
          "275:   }",
          "",
          "[Removed Lines]",
          "272:     reload_frame=(reload_frame_t *)se_tree_lookup32_array(reload_framing_info->transaction_pdus, transaction_id_key);",
          "",
          "[Added Lines]",
          "272:     reload_frame=(reload_frame_t *)wmem_tree_lookup32_array(reload_framing_info->transaction_pdus, transaction_id_key);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "278:   if (!reload_frame) {",
          "281:     reload_frame->data_frame = (type==DATA) ? pinfo->fd->num : 0;",
          "282:     reload_frame->ack_frame  = (type!=DATA) ? pinfo->fd->num : 0;",
          "283:     reload_frame->req_time   = pinfo->fd->abs_ts;",
          "",
          "[Removed Lines]",
          "280:     reload_frame = ep_new(reload_frame_t);",
          "",
          "[Added Lines]",
          "280:     reload_frame = wmem_new(wmem_packet_scope(), reload_frame_t);",
          "",
          "---------------"
        ],
        "epan/dissectors/packet-rtp.c||epan/dissectors/packet-rtp.c": [
          "File: epan/dissectors/packet-rtp.c -> epan/dissectors/packet-rtp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "67: #include <epan/tap.h>",
          "69: #include <epan/prefs.h>",
          "71: #include <epan/strutil.h>",
          "",
          "[Removed Lines]",
          "70: #include <epan/emem.h>",
          "",
          "[Added Lines]",
          "70: #include <epan/wmem/wmem.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "98: } rtp_private_conv_info;",
          "100: static reassembly_table rtp_reassembly_table;",
          "",
          "[Removed Lines]",
          "97:  emem_tree_t *multisegment_pdus;",
          "",
          "[Added Lines]",
          "97:  wmem_tree_t *multisegment_pdus;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "865:  if (! p_conv_data) {",
          "868:   p_conv_data->rtp_dyn_payload = NULL;",
          "873:   p_conv_data->extended_seqno = 0x10000;",
          "876:   conversation_add_proto_data(p_conv, proto_rtp, p_conv_data);",
          "877:  }",
          "",
          "[Removed Lines]",
          "867:   p_conv_data = se_new(struct _rtp_conversation_info);",
          "874:   p_conv_data->rtp_conv_info = se_new(rtp_private_conv_info);",
          "875:   p_conv_data->rtp_conv_info->multisegment_pdus = se_tree_create(EMEM_TREE_TYPE_RED_BLACK,\"rtp_ms_pdus\");",
          "",
          "[Added Lines]",
          "867:   p_conv_data = wmem_new(wmem_file_scope(), struct _rtp_conversation_info);",
          "874:   p_conv_data->rtp_conv_info = wmem_new(wmem_file_scope(), rtp_private_conv_info);",
          "875:   p_conv_data->rtp_conv_info->multisegment_pdus = wmem_tree_new(wmem_file_scope());",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1103: #endif",
          "1108:  if(msp && msp->startseq < seqno && msp->endseq >= seqno) {",
          "1109:   guint32 fid = msp->startseq;",
          "",
          "[Removed Lines]",
          "1106:  msp = (rtp_multisegment_pdu *)se_tree_lookup32_le(finfo->multisegment_pdus,seqno-1);",
          "",
          "[Added Lines]",
          "1106:  msp = (rtp_multisegment_pdu *)wmem_tree_lookup32_le(finfo->multisegment_pdus,seqno-1);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1203:    deseg_offset);",
          "1204: #endif",
          "1207:   msp->startseq = seqno;",
          "1208:   msp->endseq = seqno+1;",
          "",
          "[Removed Lines]",
          "1206:   msp = se_new(rtp_multisegment_pdu);",
          "1209:   se_tree_insert32(finfo->multisegment_pdus,seqno,msp);",
          "",
          "[Added Lines]",
          "1206:   msp = wmem_new(wmem_file_scope(), rtp_multisegment_pdu);",
          "1209:   wmem_tree_insert32(finfo->multisegment_pdus,seqno,msp);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1291:   payload_type_str = NULL;",
          "1295:   hdr_new->next = NULL;",
          "1296:   octet1 = tvb_get_guint8(tvb, offset);",
          "1297:   hdr_new->pt = RTP_PAYLOAD_TYPE(octet1);",
          "",
          "[Removed Lines]",
          "1294:   hdr_new = ep_new(rfc2198_hdr);",
          "",
          "[Added Lines]",
          "1294:   hdr_new = wmem_new(wmem_packet_scope(), rfc2198_hdr);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "2073:     guint32 seqno;",
          "2077:     g_strlcpy(p_conv_packet_data->method, p_conv_data->method, MAX_RTP_SETUP_METHOD_SIZE+1);",
          "2078:     p_conv_packet_data->frame_number = p_conv_data->frame_number;",
          "2079:     p_conv_packet_data->is_video = p_conv_data->is_video;",
          "",
          "[Removed Lines]",
          "2076:     p_conv_packet_data = se_new(struct _rtp_conversation_info);",
          "",
          "[Added Lines]",
          "2076:     p_conv_packet_data = wmem_new(wmem_file_scope(), struct _rtp_conversation_info);",
          "",
          "---------------"
        ],
        "epan/dissectors/packet-scsi-osd.c||epan/dissectors/packet-scsi-osd.c": [
          "File: epan/dissectors/packet-scsi-osd.c -> epan/dissectors/packet-scsi-osd.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "31: #include <glib.h>",
          "32: #include <epan/strutil.h>",
          "33: #include <epan/packet.h>",
          "35: #include <epan/conversation.h>",
          "36: #include <epan/tap.h>",
          "37: #include <epan/expert.h>",
          "",
          "[Removed Lines]",
          "34: #include <epan/emem.h>",
          "",
          "[Added Lines]",
          "34: #include <epan/wmem/wmem.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "186: typedef struct _scsi_osd_conv_info_t {",
          "188: } scsi_osd_conv_info_t;",
          "193: struct _scsi_osd_lun_info_t {",
          "195: };",
          "197: typedef void (*scsi_osd_dissector_t)(tvbuff_t *tvb, packet_info *pinfo,",
          "",
          "[Removed Lines]",
          "187:     emem_tree_t *luns;",
          "194:     emem_tree_t *partitions;",
          "",
          "[Added Lines]",
          "187:     wmem_tree_t *luns;",
          "194:     wmem_tree_t *partitions;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1295:         proto_item_append_text(item, \" (ROOT partition)\");",
          "1296:     } else {",
          "1297:         partition_info_t *part_info;",
          "1299:         proto_tree *partition_tree=NULL;",
          "1301:         pikey[0].length=2;",
          "1302:         pikey[0].key=partition_id;",
          "1303:         pikey[1].length=0;",
          "1305:         if(!part_info){",
          "1307:             part_info->created_in=0;",
          "1308:             part_info->removed_in=0;",
          "1310:             pikey[0].length=2;",
          "1311:             pikey[0].key=partition_id;",
          "1312:             pikey[1].length=0;",
          "1314:         }",
          "1315:         if(is_created){",
          "1316:             part_info->created_in=pinfo->fd->num;",
          "",
          "[Removed Lines]",
          "1298:         emem_tree_key_t pikey[2];",
          "1304:         part_info=(partition_info_t *)se_tree_lookup32_array(lun_info->partitions, &pikey[0]);",
          "1306:             part_info=se_new(partition_info_t);",
          "1313:             se_tree_insert32_array(lun_info->partitions, &pikey[0], part_info);",
          "",
          "[Added Lines]",
          "1298:         wmem_tree_key_t pikey[2];",
          "1304:         part_info=(partition_info_t *)wmem_tree_lookup32_array(lun_info->partitions, &pikey[0]);",
          "1306:             part_info=wmem_new(wmem_file_scope(), partition_info_t);",
          "1313:             wmem_tree_insert32_array(lun_info->partitions, &pikey[0], part_info);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "3357:     conv_info=(scsi_osd_conv_info_t *)conversation_get_proto_data(cdata->itl->conversation, proto_scsi_osd);",
          "3358:     if(!conv_info){",
          "3361:         conversation_add_proto_data(cdata->itl->conversation, proto_scsi_osd, conv_info);",
          "3362:     }",
          "3365:     if(!lun_info){",
          "3369:     }",
          "",
          "[Removed Lines]",
          "3359:         conv_info=se_new(scsi_osd_conv_info_t);",
          "3360:         conv_info->luns=se_tree_create_non_persistent(EMEM_TREE_TYPE_RED_BLACK, \"SCSI OSD luns tree\");",
          "3364:     lun_info=(scsi_osd_lun_info_t *)se_tree_lookup32(conv_info->luns, cdata->itlq->lun);",
          "3366:         lun_info=se_new(scsi_osd_lun_info_t);",
          "3367:         lun_info->partitions=se_tree_create_non_persistent(EMEM_TREE_TYPE_RED_BLACK, \"SCSI OSD partitions tree\");",
          "3368:         se_tree_insert32(conv_info->luns, cdata->itlq->lun, (void *)lun_info);",
          "",
          "[Added Lines]",
          "3359:         conv_info=wmem_new(wmem_file_scope(), scsi_osd_conv_info_t);",
          "3360:         conv_info->luns=wmem_tree_new(wmem_file_scope());",
          "3364:     lun_info=(scsi_osd_lun_info_t *)wmem_tree_lookup32(conv_info->luns, cdata->itlq->lun);",
          "3366:         lun_info=wmem_new(wmem_file_scope(), scsi_osd_lun_info_t);",
          "3367:         lun_info->partitions=wmem_tree_new(wmem_file_scope());",
          "3368:         wmem_tree_insert32(conv_info->luns, cdata->itlq->lun, (void *)lun_info);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "3387:             if((!pinfo->fd->flags.visited) || (!cdata->itlq->extra_data)){",
          "3388:                 scsi_osd_extra_data_t *extra_data;",
          "3391:                 extra_data->svcaction=svcaction;",
          "3392:                 extra_data->gsatype=0;",
          "3393:                 extra_data->osd2=0;",
          "",
          "[Removed Lines]",
          "3390:                 extra_data=se_new(scsi_osd_extra_data_t);",
          "",
          "[Added Lines]",
          "3390:                 extra_data=wmem_new(wmem_file_scope(), scsi_osd_extra_data_t);",
          "",
          "---------------"
        ],
        "epan/dissectors/packet-xmcp.c||epan/dissectors/packet-xmcp.c": [
          "File: epan/dissectors/packet-xmcp.c -> epan/dissectors/packet-xmcp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "40: #include <packet-tcp.h>",
          "41: #include <epan/prefs.h>",
          "42: #include <epan/conversation.h>",
          "44: #include <epan/expert.h>",
          "46: static dissector_table_t media_type_dissector_table;",
          "",
          "[Removed Lines]",
          "43: #include <epan/emem.h>",
          "",
          "[Added Lines]",
          "43: #include <epan/wmem/wmem.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "60: } xmcp_transaction_t;",
          "62: typedef struct _xmcp_conv_info_t {",
          "64: } xmcp_conv_info_t;",
          "66: static int hf_xmcp_type = -1;",
          "",
          "[Removed Lines]",
          "63:   emem_tree_t *transaction_pdus;",
          "",
          "[Added Lines]",
          "63:   wmem_tree_t *transaction_pdus;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "841:   guint32 transaction_id[3];",
          "843:   conversation_t *conversation;",
          "844:   xmcp_conv_info_t *xmcp_conv_info;",
          "845:   xmcp_transaction_t *xmcp_trans;",
          "",
          "[Removed Lines]",
          "842:   emem_tree_key_t transaction_id_key[2];",
          "",
          "[Added Lines]",
          "842:   wmem_tree_key_t transaction_id_key[2];",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "884:   xmcp_conv_info = (xmcp_conv_info_t *)conversation_get_proto_data(conversation, proto_xmcp);",
          "885:   if (!xmcp_conv_info) {",
          "890:     conversation_add_proto_data(conversation, proto_xmcp, xmcp_conv_info);",
          "891:   }",
          "895:                                       transaction_id_key);",
          "896:   if (!xmcp_trans) {",
          "898:       xmcp_trans->request_frame = 0;",
          "899:       xmcp_trans->response_frame = 0;",
          "900:       xmcp_trans->request_time = pinfo->fd->abs_ts;",
          "901:       xmcp_trans->request_is_keepalive = FALSE;",
          "903:                              transaction_id_key, (void *)xmcp_trans);",
          "904:   }",
          "",
          "[Removed Lines]",
          "886:     xmcp_conv_info = se_new(xmcp_conv_info_t);",
          "887:     xmcp_conv_info->transaction_pdus =",
          "888:       se_tree_create_non_persistent(EMEM_TREE_TYPE_RED_BLACK,",
          "889:                                     \"xmcp_pdus\");",
          "894:   xmcp_trans = (xmcp_transaction_t *)se_tree_lookup32_array(xmcp_conv_info->transaction_pdus,",
          "897:       xmcp_trans = se_new(xmcp_transaction_t);",
          "902:       se_tree_insert32_array(xmcp_conv_info->transaction_pdus,",
          "",
          "[Added Lines]",
          "886:     xmcp_conv_info = wmem_new(wmem_file_scope(), xmcp_conv_info_t);",
          "887:     xmcp_conv_info->transaction_pdus = wmem_tree_new(wmem_file_scope());",
          "892:   xmcp_trans = (xmcp_transaction_t *)wmem_tree_lookup32_array(xmcp_conv_info->transaction_pdus,",
          "895:       xmcp_trans = wmem_new(wmem_file_scope(), xmcp_transaction_t);",
          "900:       wmem_tree_insert32_array(xmcp_conv_info->transaction_pdus,",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "1559f77ff147b21260cf9411d5e22f7faa345d30",
      "candidate_info": {
        "commit_hash": "1559f77ff147b21260cf9411d5e22f7faa345d30",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/1559f77ff147b21260cf9411d5e22f7faa345d30",
        "files": [
          "epan/dissectors/packet-rtp.c",
          "epan/dissectors/packet-sdp.c"
        ],
        "message": "Fix Bug 9885: 'Buildbot crash output: fuzz-2014-03-14-15333.pcap'\n\nThe Buildbot found a crash which is cause by a bug that has\nbeen there all along, but a recent change exposed. This bug is\nlikely in 1.10.6 as well, so I'll backport this if I can\nreproduce it in 1.10.6.\n\nChange-Id: I505bc73cbe6281e6d64f00de441c8e6231b55000\nReviewed-on: https://code.wireshark.org/review/702\nReviewed-by: Hadriel Kaplan <hadrielk@yahoo.com>\nReviewed-by: Evan Huus <eapache@gmail.com>\nReviewed-by: Martin Kaiser <wireshark@kaiser.cx>\nReviewed-by: Michael Mann <mmann78@netscape.net>\nReviewed-on: https://code.wireshark.org/review/781\nReviewed-by: Anders Broman <a.broman58@gmail.com>",
        "before_after_code_files": [
          "epan/dissectors/packet-rtp.c||epan/dissectors/packet-rtp.c",
          "epan/dissectors/packet-sdp.c||epan/dissectors/packet-sdp.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "epan/dissectors/packet-rtp.c||epan/dissectors/packet-rtp.c",
            "epan/dissectors/packet-sdp.c||epan/dissectors/packet-sdp.c"
          ],
          "candidate": [
            "epan/dissectors/packet-rtp.c||epan/dissectors/packet-rtp.c",
            "epan/dissectors/packet-sdp.c||epan/dissectors/packet-sdp.c"
          ]
        }
      },
      "candidate_diff": {
        "epan/dissectors/packet-rtp.c||epan/dissectors/packet-rtp.c": [
          "File: epan/dissectors/packet-rtp.c -> epan/dissectors/packet-rtp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "885:  g_strlcpy(p_conv_data->method, setup_method, MAX_RTP_SETUP_METHOD_SIZE+1);",
          "886:  p_conv_data->frame_number = setup_frame_number;",
          "",
          "[Removed Lines]",
          "883:  rtp_free_hash_dyn_payload(p_conv_data->rtp_dyn_payload);",
          "",
          "[Added Lines]",
          "883:  if (p_conv_data->rtp_dyn_payload != rtp_dyn_payload)",
          "884:   rtp_free_hash_dyn_payload(p_conv_data->rtp_dyn_payload);",
          "",
          "---------------"
        ],
        "epan/dissectors/packet-sdp.c||epan/dissectors/packet-sdp.c": [
          "File: epan/dissectors/packet-sdp.c -> epan/dissectors/packet-sdp.c"
        ]
      }
    }
  ]
}
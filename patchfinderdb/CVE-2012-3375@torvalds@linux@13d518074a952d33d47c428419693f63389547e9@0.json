{
  "cve_id": "CVE-2012-3375",
  "cve_desc": "The epoll_ctl system call in fs/eventpoll.c in the Linux kernel before 3.2.24 does not properly handle ELOOP errors in EPOLL_CTL_ADD operations, which allows local users to cause a denial of service (file-descriptor consumption and system crash) via a crafted application that attempts to create a circular epoll dependency.  NOTE: this vulnerability exists because of an incorrect fix for CVE-2011-1083.",
  "repo": "torvalds/linux",
  "patch_hash": "13d518074a952d33d47c428419693f63389547e9",
  "patch_info": {
    "commit_hash": "13d518074a952d33d47c428419693f63389547e9",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/13d518074a952d33d47c428419693f63389547e9",
    "files": [
      "fs/eventpoll.c"
    ],
    "message": "epoll: clear the tfile_check_list on -ELOOP\n\nAn epoll_ctl(,EPOLL_CTL_ADD,,) operation can return '-ELOOP' to prevent\ncircular epoll dependencies from being created.  However, in that case we\ndo not properly clear the 'tfile_check_list'.  Thus, add a call to\nclear_tfile_check_list() for the -ELOOP case.\n\nSigned-off-by: Jason Baron <jbaron@redhat.com>\nReported-by: Yurij M. Plotnikov <Yurij.Plotnikov@oktetlabs.ru>\nCc: Nelson Elhage <nelhage@nelhage.com>\nCc: Davide Libenzi <davidel@xmailserver.org>\nTested-by: Alexandra N. Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
    "before_after_code_files": [
      "fs/eventpoll.c||fs/eventpoll.c"
    ]
  },
  "patch_diff": {
    "fs/eventpoll.c||fs/eventpoll.c": [
      "File: fs/eventpoll.c -> fs/eventpoll.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1663:  if (op == EPOLL_CTL_ADD) {",
      "1664:   if (is_file_epoll(tfile)) {",
      "1665:    error = -ELOOP;",
      "1667:     goto error_tgt_fput;",
      "1668:   } else",
      "1669:    list_add(&tfile->f_tfile_llink, &tfile_check_list);",
      "1670:  }",
      "",
      "[Removed Lines]",
      "1666:    if (ep_loop_check(ep, tfile) != 0)",
      "",
      "[Added Lines]",
      "1666:    if (ep_loop_check(ep, tfile) != 0) {",
      "1667:     clear_tfile_check_list();",
      "1669:    }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "28d82dc1c4edbc352129f97f4ca22624d1fe61de",
      "candidate_info": {
        "commit_hash": "28d82dc1c4edbc352129f97f4ca22624d1fe61de",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/28d82dc1c4edbc352129f97f4ca22624d1fe61de",
        "files": [
          "fs/eventpoll.c",
          "include/linux/eventpoll.h",
          "include/linux/fs.h"
        ],
        "message": "epoll: limit paths\n\nThe current epoll code can be tickled to run basically indefinitely in\nboth loop detection path check (on ep_insert()), and in the wakeup paths.\nThe programs that tickle this behavior set up deeply linked networks of\nepoll file descriptors that cause the epoll algorithms to traverse them\nindefinitely.  A couple of these sample programs have been previously\nposted in this thread: https://lkml.org/lkml/2011/2/25/297.\n\nTo fix the loop detection path check algorithms, I simply keep track of\nthe epoll nodes that have been already visited.  Thus, the loop detection\nbecomes proportional to the number of epoll file descriptor and links.\nThis dramatically decreases the run-time of the loop check algorithm.  In\none diabolical case I tried it reduced the run-time from 15 mintues (all\nin kernel time) to .3 seconds.\n\nFixing the wakeup paths could be done at wakeup time in a similar manner\nby keeping track of nodes that have already been visited, but the\ncomplexity is harder, since there can be multiple wakeups on different\ncpus...Thus, I've opted to limit the number of possible wakeup paths when\nthe paths are created.\n\nThis is accomplished, by noting that the end file descriptor points that\nare found during the loop detection pass (from the newly added link), are\nactually the sources for wakeup events.  I keep a list of these file\ndescriptors and limit the number and length of these paths that emanate\nfrom these 'source file descriptors'.  In the current implemetation I\nallow 1000 paths of length 1, 500 of length 2, 100 of length 3, 50 of\nlength 4 and 10 of length 5.  Note that it is sufficient to check the\n'source file descriptors' reachable from the newly added link, since no\nother 'source file descriptors' will have newly added links.  This allows\nus to check only the wakeup paths that may have gotten too long, and not\nre-check all possible wakeup paths on the system.\n\nIn terms of the path limit selection, I think its first worth noting that\nthe most common case for epoll, is probably the model where you have 1\nepoll file descriptor that is monitoring n number of 'source file\ndescriptors'.  In this case, each 'source file descriptor' has a 1 path of\nlength 1.  Thus, I believe that the limits I'm proposing are quite\nreasonable and in fact may be too generous.  Thus, I'm hoping that the\nproposed limits will not prevent any workloads that currently work to\nfail.\n\nIn terms of locking, I have extended the use of the 'epmutex' to all\nepoll_ctl add and remove operations.  Currently its only used in a subset\nof the add paths.  I need to hold the epmutex, so that we can correctly\ntraverse a coherent graph, to check the number of paths.  I believe that\nthis additional locking is probably ok, since its in the setup/teardown\npaths, and doesn't affect the running paths, but it certainly is going to\nadd some extra overhead.  Also, worth noting is that the epmuex was\nrecently added to the ep_ctl add operations in the initial path loop\ndetection code using the argument that it was not on a critical path.\n\nAnother thing to note here, is the length of epoll chains that is allowed.\nCurrently, eventpoll.c defines:\n\n/* Maximum number of nesting allowed inside epoll sets */\n#define EP_MAX_NESTS 4\n\nThis basically means that I am limited to a graph depth of 5 (EP_MAX_NESTS\n+ 1).  However, this limit is currently only enforced during the loop\ncheck detection code, and only when the epoll file descriptors are added\nin a certain order.  Thus, this limit is currently easily bypassed.  The\nnewly added check for wakeup paths, stricly limits the wakeup paths to a\nlength of 5, regardless of the order in which ep's are linked together.\nThus, a side-effect of the new code is a more consistent enforcement of\nthe graph depth.\n\nThus far, I've tested this, using the sample programs previously\nmentioned, which now either return quickly or return -EINVAL.  I've also\ntesting using the piptest.c epoll tester, which showed no difference in\nperformance.  I've also created a number of different epoll networks and\ntested that they behave as expectded.\n\nI believe this solves the original diabolical test cases, while still\npreserving the sane epoll nesting.\n\nSigned-off-by: Jason Baron <jbaron@redhat.com>\nCc: Nelson Elhage <nelhage@ksplice.com>\nCc: Davide Libenzi <davidel@xmailserver.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "fs/eventpoll.c||fs/eventpoll.c",
          "include/linux/eventpoll.h||include/linux/eventpoll.h",
          "include/linux/fs.h||include/linux/fs.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/eventpoll.c||fs/eventpoll.c"
          ],
          "candidate": [
            "fs/eventpoll.c||fs/eventpoll.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/eventpoll.c||fs/eventpoll.c": [
          "File: fs/eventpoll.c -> fs/eventpoll.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "199:  struct user_struct *user;",
          "200: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "201:  struct file *file;",
          "204:  int visited;",
          "205:  struct list_head visited_list_link;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "256: static struct kmem_cache *pwq_cache __read_mostly;",
          "258: #ifdef CONFIG_SYSCTL",
          "260: #include <linux/sysctl.h>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "265: static LIST_HEAD(visited_list);",
          "271: static LIST_HEAD(tfile_check_list);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "276: };",
          "281: static inline void ep_set_ffd(struct epoll_filefd *ffd,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "294: static const struct file_operations eventpoll_fops;",
          "296: static inline int is_file_epoll(struct file *f)",
          "297: {",
          "298:  return f->f_op == &eventpoll_fops;",
          "299: }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "711:  .llseek  = noop_llseek,",
          "712: };",
          "",
          "[Removed Lines]",
          "715: static inline int is_file_epoll(struct file *f)",
          "716: {",
          "717:  return f->f_op == &eventpoll_fops;",
          "718: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "926:  rb_insert_color(&epi->rbn, &ep->rbr);",
          "927: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "946: #define PATH_ARR_SIZE 5",
          "958: static const int path_limits[PATH_ARR_SIZE] = { 1000, 500, 100, 50, 10 };",
          "959: static int path_count[PATH_ARR_SIZE];",
          "961: static int path_count_inc(int nests)",
          "962: {",
          "963:  if (++path_count[nests] > path_limits[nests])",
          "964:   return -1;",
          "965:  return 0;",
          "966: }",
          "968: static void path_count_init(void)",
          "969: {",
          "970:  int i;",
          "972:  for (i = 0; i < PATH_ARR_SIZE; i++)",
          "973:   path_count[i] = 0;",
          "974: }",
          "976: static int reverse_path_check_proc(void *priv, void *cookie, int call_nests)",
          "977: {",
          "978:  int error = 0;",
          "979:  struct file *file = priv;",
          "980:  struct file *child_file;",
          "981:  struct epitem *epi;",
          "983:  list_for_each_entry(epi, &file->f_ep_links, fllink) {",
          "984:   child_file = epi->ep->file;",
          "985:   if (is_file_epoll(child_file)) {",
          "986:    if (list_empty(&child_file->f_ep_links)) {",
          "987:     if (path_count_inc(call_nests)) {",
          "988:      error = -1;",
          "989:      break;",
          "990:     }",
          "991:    } else {",
          "992:     error = ep_call_nested(&poll_loop_ncalls,",
          "993:        EP_MAX_NESTS,",
          "994:        reverse_path_check_proc,",
          "995:        child_file, child_file,",
          "996:        current);",
          "997:    }",
          "998:    if (error != 0)",
          "999:     break;",
          "1000:   } else {",
          "1001:    printk(KERN_ERR \"reverse_path_check_proc: \"",
          "1002:     \"file is not an ep!\\n\");",
          "1003:   }",
          "1004:  }",
          "1005:  return error;",
          "1006: }",
          "1018: static int reverse_path_check(void)",
          "1019: {",
          "1020:  int length = 0;",
          "1021:  int error = 0;",
          "1022:  struct file *current_file;",
          "1025:  list_for_each_entry(current_file, &tfile_check_list, f_tfile_llink) {",
          "1026:   length++;",
          "1027:   path_count_init();",
          "1028:   error = ep_call_nested(&poll_loop_ncalls, EP_MAX_NESTS,",
          "1029:      reverse_path_check_proc, current_file,",
          "1030:      current_file, current);",
          "1031:   if (error)",
          "1032:    break;",
          "1033:  }",
          "1034:  return error;",
          "1035: }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "988:  ep_rbtree_insert(ep, epi);",
          "991:  spin_lock_irqsave(&ep->lock, flags);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1099:  error = -EINVAL;",
          "1100:  if (reverse_path_check())",
          "1101:   goto error_remove_epi;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1012:  return 0;",
          "1014: error_unregister:",
          "1015:  ep_unregister_pollwait(ep, epi);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1127: error_remove_epi:",
          "1128:  spin_lock(&tfile->f_lock);",
          "1129:  if (ep_is_linked(&epi->fllink))",
          "1130:   list_del_init(&epi->fllink);",
          "1131:  spin_unlock(&tfile->f_lock);",
          "1133:  rb_erase(&epi->rbn, &ep->rbr);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1275:  int error = 0;",
          "1276:  struct file *file = priv;",
          "1277:  struct eventpoll *ep = file->private_data;",
          "1278:  struct rb_node *rbp;",
          "1279:  struct epitem *epi;",
          "1281:  mutex_lock_nested(&ep->mtx, call_nests + 1);",
          "1282:  for (rbp = rb_first(&ep->rbr); rbp; rbp = rb_next(rbp)) {",
          "1283:   epi = rb_entry(rbp, struct epitem, rbn);",
          "1284:   if (unlikely(is_file_epoll(epi->ffd.file))) {",
          "1285:    error = ep_call_nested(&poll_loop_ncalls, EP_MAX_NESTS,",
          "1288:    if (error != 0)",
          "1289:     break;",
          "1290:   }",
          "1291:  }",
          "1292:  mutex_unlock(&ep->mtx);",
          "",
          "[Removed Lines]",
          "1286:             ep_loop_check_proc, epi->ffd.file,",
          "1287:             epi->ffd.file->private_data, current);",
          "",
          "[Added Lines]",
          "1399:  struct eventpoll *ep_tovisit;",
          "1404:  ep->visited = 1;",
          "1405:  list_add(&ep->visited_list_link, &visited_list);",
          "1409:    ep_tovisit = epi->ffd.file->private_data;",
          "1410:    if (ep_tovisit->visited)",
          "1411:     continue;",
          "1413:      ep_loop_check_proc, epi->ffd.file,",
          "1414:      ep_tovisit, current);",
          "1417:   } else {",
          "1426:    if (list_empty(&epi->ffd.file->f_tfile_llink))",
          "1427:     list_add(&epi->ffd.file->f_tfile_llink,",
          "1428:       &tfile_check_list);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1308: static int ep_loop_check(struct eventpoll *ep, struct file *file)",
          "1309: {",
          "1311:          ep_loop_check_proc, file, ep, current);",
          "1312: }",
          "",
          "[Removed Lines]",
          "1310:  return ep_call_nested(&poll_loop_ncalls, EP_MAX_NESTS,",
          "",
          "[Added Lines]",
          "1449:  int ret;",
          "1450:  struct eventpoll *ep_cur, *ep_next;",
          "1452:  ret = ep_call_nested(&poll_loop_ncalls, EP_MAX_NESTS,",
          "1455:  list_for_each_entry_safe(ep_cur, ep_next, &visited_list,",
          "1456:        visited_list_link) {",
          "1457:   ep_cur->visited = 0;",
          "1458:   list_del(&ep_cur->visited_list_link);",
          "1459:  }",
          "1460:  return ret;",
          "1461: }",
          "1463: static void clear_tfile_check_list(void)",
          "1464: {",
          "1465:  struct file *file;",
          "1468:  while (!list_empty(&tfile_check_list)) {",
          "1469:   file = list_first_entry(&tfile_check_list, struct file,",
          "1470:      f_tfile_llink);",
          "1471:   list_del_init(&file->f_tfile_llink);",
          "1472:  }",
          "1473:  INIT_LIST_HEAD(&tfile_check_list);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1317: SYSCALL_DEFINE1(epoll_create1, int, flags)",
          "1318: {",
          "1320:  struct eventpoll *ep = NULL;",
          "1323:  BUILD_BUG_ON(EPOLL_CLOEXEC != O_CLOEXEC);",
          "",
          "[Removed Lines]",
          "1319:  int error;",
          "",
          "[Added Lines]",
          "1481:  int error, fd;",
          "1483:  struct file *file;",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1338:      O_RDWR | (flags & O_CLOEXEC));",
          "1342:  return error;",
          "1343: }",
          "",
          "[Removed Lines]",
          "1337:  error = anon_inode_getfd(\"[eventpoll]\", &eventpoll_fops, ep,",
          "1339:  if (error < 0)",
          "1340:   ep_free(ep);",
          "",
          "[Added Lines]",
          "1500:  fd = get_unused_fd_flags(O_RDWR | (flags & O_CLOEXEC));",
          "1501:  if (fd < 0) {",
          "1502:   error = fd;",
          "1503:   goto out_free_ep;",
          "1504:  }",
          "1505:  file = anon_inode_getfile(\"[eventpoll]\", &eventpoll_fops, ep,",
          "1507:  if (IS_ERR(file)) {",
          "1508:   error = PTR_ERR(file);",
          "1509:   goto out_free_fd;",
          "1510:  }",
          "1511:  fd_install(fd, file);",
          "1512:  ep->file = file;",
          "1513:  return fd;",
          "1515: out_free_fd:",
          "1516:  put_unused_fd(fd);",
          "1517: out_free_ep:",
          "1518:  ep_free(ep);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1415:   mutex_lock(&epmutex);",
          "1416:   did_lock_epmutex = 1;",
          "1420:  }",
          "1423:  mutex_lock_nested(&ep->mtx, 0);",
          "",
          "[Removed Lines]",
          "1414:  if (unlikely(is_file_epoll(tfile) && op == EPOLL_CTL_ADD)) {",
          "1417:   error = -ELOOP;",
          "1418:   if (ep_loop_check(ep, tfile) != 0)",
          "1419:    goto error_tgt_fput;",
          "",
          "[Added Lines]",
          "1593:  if (op == EPOLL_CTL_ADD || op == EPOLL_CTL_DEL) {",
          "1597:  if (op == EPOLL_CTL_ADD) {",
          "1598:   if (is_file_epoll(tfile)) {",
          "1599:    error = -ELOOP;",
          "1600:    if (ep_loop_check(ep, tfile) != 0)",
          "1601:     goto error_tgt_fput;",
          "1602:   } else",
          "1603:    list_add(&tfile->f_tfile_llink, &tfile_check_list);",
          "1604:  }",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1437:    error = ep_insert(ep, &epds, tfile, fd);",
          "1438:   } else",
          "1439:    error = -EEXIST;",
          "1440:   break;",
          "1441:  case EPOLL_CTL_DEL:",
          "1442:   if (epi)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1623:   clear_tfile_check_list();",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "1455:  mutex_unlock(&ep->mtx);",
          "1457: error_tgt_fput:",
          "1459:   mutex_unlock(&epmutex);",
          "1461:  fput(tfile);",
          "",
          "[Removed Lines]",
          "1458:  if (unlikely(did_lock_epmutex))",
          "",
          "[Added Lines]",
          "1642:  if (did_lock_epmutex)",
          "",
          "---------------"
        ],
        "include/linux/eventpoll.h||include/linux/eventpoll.h": [
          "File: include/linux/eventpoll.h -> include/linux/eventpoll.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "61: static inline void eventpoll_init_file(struct file *file)",
          "62: {",
          "63:  INIT_LIST_HEAD(&file->f_ep_links);",
          "64: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "64:  INIT_LIST_HEAD(&file->f_tfile_llink);",
          "",
          "---------------"
        ],
        "include/linux/fs.h||include/linux/fs.h": [
          "File: include/linux/fs.h -> include/linux/fs.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "1001: #ifdef CONFIG_EPOLL",
          "1003:  struct list_head f_ep_links;",
          "1005:  struct address_space *f_mapping;",
          "1006: #ifdef CONFIG_DEBUG_WRITECOUNT",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1004:  struct list_head f_tfile_llink;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
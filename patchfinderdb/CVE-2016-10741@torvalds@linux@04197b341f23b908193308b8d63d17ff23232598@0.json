{
  "cve_id": "CVE-2016-10741",
  "cve_desc": "In the Linux kernel before 4.9.3, fs/xfs/xfs_aops.c allows local users to cause a denial of service (system crash) because there is a race condition between direct and memory-mapped I/O (associated with a hole) that is handled with BUG_ON instead of an I/O failure.",
  "repo": "torvalds/linux",
  "patch_hash": "04197b341f23b908193308b8d63d17ff23232598",
  "patch_info": {
    "commit_hash": "04197b341f23b908193308b8d63d17ff23232598",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/04197b341f23b908193308b8d63d17ff23232598",
    "files": [
      "fs/xfs/xfs_aops.c"
    ],
    "message": "xfs: don't BUG() on mixed direct and mapped I/O\n\nWe've had reports of generic/095 causing XFS to BUG() in\n__xfs_get_blocks() due to the existence of delalloc blocks on a\ndirect I/O read. generic/095 issues a mix of various types of I/O,\nincluding direct and memory mapped I/O to a single file. This is\nclearly not supported behavior and is known to lead to such\nproblems. E.g., the lack of exclusion between the direct I/O and\nwrite fault paths means that a write fault can allocate delalloc\nblocks in a region of a file that was previously a hole after the\ndirect read has attempted to flush/inval the file range, but before\nit actually reads the block mapping. In turn, the direct read\ndiscovers a delalloc extent and cannot proceed.\n\nWhile the appropriate solution here is to not mix direct and memory\nmapped I/O to the same regions of the same file, the current\nBUG_ON() behavior is probably overkill as it can crash the entire\nsystem.  Instead, localize the failure to the I/O in question by\nreturning an error for a direct I/O that cannot be handled safely\ndue to delalloc blocks. Be careful to allow the case of a direct\nwrite to post-eof delalloc blocks. This can occur due to speculative\npreallocation and is safe as post-eof blocks are not accompanied by\ndirty pages in pagecache (conversely, preallocation within eof must\nhave been zeroed, and thus dirtied, before the inode size could have\nbeen increased beyond said blocks).\n\nFinally, provide an additional warning if a direct I/O write occurs\nwhile the file is memory mapped. This may not catch all problematic\nscenarios, but provides a hint that some known-to-be-problematic I/O\nmethods are in use.\n\nSigned-off-by: Brian Foster <bfoster@redhat.com>\nReviewed-by: Dave Chinner <dchinner@redhat.com>\nSigned-off-by: Dave Chinner <david@fromorbit.com>",
    "before_after_code_files": [
      "fs/xfs/xfs_aops.c||fs/xfs/xfs_aops.c"
    ]
  },
  "patch_diff": {
    "fs/xfs/xfs_aops.c||fs/xfs/xfs_aops.c": [
      "File: fs/xfs/xfs_aops.c -> fs/xfs/xfs_aops.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1361:  if (error)",
      "1362:   goto out_unlock;",
      "1365:  if (create &&",
      "1366:      (!nimaps ||",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1375:  if (direct && imap.br_startblock == DELAYSTARTBLOCK) {",
      "1376:   if (!create || offset < i_size_read(VFS_I(ip))) {",
      "1377:    WARN_ON_ONCE(1);",
      "1378:    error = -EIO;",
      "1379:    goto out_unlock;",
      "1380:   }",
      "1381:   WARN_ON_ONCE(mapping_mapped(VFS_I(ip)->i_mapping));",
      "1382:  }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1450:       (new || ISUNWRITTEN(&imap))))",
      "1451:   set_buffer_new(bh_result);",
      "1455:  return 0;",
      "1457: out_unlock:",
      "",
      "[Removed Lines]",
      "1453:  BUG_ON(direct && imap.br_startblock == DELAYSTARTBLOCK);",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "acdda3aae146d9b69d30e9d8a32a8d8937055523",
      "candidate_info": {
        "commit_hash": "acdda3aae146d9b69d30e9d8a32a8d8937055523",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/acdda3aae146d9b69d30e9d8a32a8d8937055523",
        "files": [
          "fs/xfs/xfs_aops.c",
          "fs/xfs/xfs_aops.h",
          "fs/xfs/xfs_file.c",
          "fs/xfs/xfs_iomap.c"
        ],
        "message": "xfs: use iomap_dio_rw\n\nStraight switch over to using iomap for direct I/O - we already have the\nnon-COW dio path in write_begin for DAX and files with extent size hints,\nso nothing to add there.  The COW path is ported over from the old\nget_blocks version and a bit of a mess, but I have some work in progress\nto make it look more like the buffered I/O COW path.\n\nThis gets rid of xfs_get_blocks_direct and the last caller of\nxfs_get_blocks with the create flag set, so all that code can be removed.\n\nLast but not least I've removed a comment in xfs_filemap_fault that\nrefers to xfs_get_blocks entirely instead of updating it - while the\nreference is correct, the whole DAX fault path looks different than\nthe non-DAX one, so it seems rather pointless.\n\nSigned-off-by: Christoph Hellwig <hch@lst.de>\nTested-by: Jens Axboe <axboe@fb.com>\nReviewed-by: Darrick J. Wong <darrick.wong@oracle.com>\nSigned-off-by: Dave Chinner <david@fromorbit.com>",
        "before_after_code_files": [
          "fs/xfs/xfs_aops.c||fs/xfs/xfs_aops.c",
          "fs/xfs/xfs_aops.h||fs/xfs/xfs_aops.h",
          "fs/xfs/xfs_file.c||fs/xfs/xfs_file.c",
          "fs/xfs/xfs_iomap.c||fs/xfs/xfs_iomap.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/xfs/xfs_aops.c||fs/xfs/xfs_aops.c"
          ],
          "candidate": [
            "fs/xfs/xfs_aops.c||fs/xfs/xfs_aops.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/xfs/xfs_aops.c||fs/xfs/xfs_aops.c": [
          "File: fs/xfs/xfs_aops.c -> fs/xfs/xfs_aops.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "37: #include <linux/pagevec.h>",
          "38: #include <linux/writeback.h>",
          "",
          "[Removed Lines]",
          "41: #define XFS_DIO_FLAG_UNWRITTEN (1 << 0)",
          "42: #define XFS_DIO_FLAG_APPEND (1 << 1)",
          "43: #define XFS_DIO_FLAG_COW (1 << 2)",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1175:  return try_to_free_buffers(page);",
          "1176: }",
          "",
          "[Removed Lines]",
          "1189: static void",
          "1190: xfs_map_direct(",
          "1191:  struct inode  *inode,",
          "1192:  struct buffer_head *bh_result,",
          "1193:  struct xfs_bmbt_irec *imap,",
          "1194:  xfs_off_t  offset,",
          "1195:  bool   is_cow)",
          "1196: {",
          "1197:  uintptr_t  *flags = (uintptr_t *)&bh_result->b_private;",
          "1198:  xfs_off_t  size = bh_result->b_size;",
          "1200:  trace_xfs_get_blocks_map_direct(XFS_I(inode), offset, size,",
          "1201:   ISUNWRITTEN(imap) ? XFS_IO_UNWRITTEN : is_cow ? XFS_IO_COW :",
          "1202:   XFS_IO_OVERWRITE, imap);",
          "1204:  if (ISUNWRITTEN(imap)) {",
          "1206:   set_buffer_defer_completion(bh_result);",
          "1207:  } else if (is_cow) {",
          "1209:   set_buffer_defer_completion(bh_result);",
          "1210:  }",
          "1211:  if (offset + size > i_size_read(inode) || offset + size < 0) {",
          "1213:   set_buffer_defer_completion(bh_result);",
          "1214:  }",
          "1215: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1254:  bh_result->b_size = mapping_size;",
          "1255: }",
          "1258: static int",
          "1297:  struct inode  *inode,",
          "1298:  sector_t  iblock,",
          "1299:  struct buffer_head *bh_result,",
          "1302: {",
          "1303:  struct xfs_inode *ip = XFS_I(inode);",
          "1304:  struct xfs_mount *mp = ip->i_mount;",
          "",
          "[Removed Lines]",
          "1259: xfs_bounce_unaligned_dio_write(",
          "1260:  struct xfs_inode *ip,",
          "1261:  xfs_fileoff_t  offset_fsb,",
          "1262:  struct xfs_bmbt_irec *imap)",
          "1263: {",
          "1264:  struct xfs_bmbt_irec irec;",
          "1265:  xfs_fileoff_t  delta;",
          "1266:  bool   shared;",
          "1267:  bool   x;",
          "1268:  int   error;",
          "1270:  irec = *imap;",
          "1271:  if (offset_fsb > irec.br_startoff) {",
          "1272:   delta = offset_fsb - irec.br_startoff;",
          "1273:   irec.br_blockcount -= delta;",
          "1274:   irec.br_startblock += delta;",
          "1275:   irec.br_startoff = offset_fsb;",
          "1276:  }",
          "1277:  error = xfs_reflink_trim_around_shared(ip, &irec, &shared, &x);",
          "1278:  if (error)",
          "1279:   return error;",
          "1288:  if (shared) {",
          "1289:   trace_xfs_reflink_bounce_dio_write(ip, imap);",
          "1290:   return -EREMCHG;",
          "1291:  }",
          "1292:  return 0;",
          "1293: }",
          "1295: STATIC int",
          "1296: __xfs_get_blocks(",
          "1300:  int   create,",
          "1301:  bool   direct)",
          "",
          "[Added Lines]",
          "1214: xfs_get_blocks(",
          "1218:  int   create)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1309:  int   nimaps = 1;",
          "1310:  xfs_off_t  offset;",
          "1311:  ssize_t   size;",
          "1317:  if (XFS_FORCED_SHUTDOWN(mp))",
          "1318:   return -EIO;",
          "",
          "[Removed Lines]",
          "1312:  int   new = 0;",
          "1313:  bool   is_cow = false;",
          "1315:  BUG_ON(create && !direct);",
          "",
          "[Added Lines]",
          "1230:  BUG_ON(create);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1321:  ASSERT(bh_result->b_size >= (1 << inode->i_blkbits));",
          "1322:  size = bh_result->b_size;",
          "1325:   return 0;",
          "",
          "[Removed Lines]",
          "1324:  if (!create && offset >= i_size_read(inode))",
          "",
          "[Added Lines]",
          "1239:  if (offset >= i_size_read(inode))",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1336:  end_fsb = XFS_B_TO_FSB(mp, (xfs_ufsize_t)offset + size);",
          "1337:  offset_fsb = XFS_B_TO_FSBT(mp, offset);",
          "1360:  if (error)",
          "1361:   goto out_unlock;",
          "1406:   trace_xfs_get_blocks_found(ip, offset, size,",
          "1407:     ISUNWRITTEN(&imap) ? XFS_IO_UNWRITTEN",
          "1408:          : XFS_IO_OVERWRITE, &imap);",
          "",
          "[Removed Lines]",
          "1339:  if (create && direct && xfs_is_reflink_inode(ip)) {",
          "1340:   is_cow = xfs_reflink_find_cow_mapping(ip, offset, &imap);",
          "1341:   ASSERT(!is_cow || !isnullstartblock(imap.br_startblock));",
          "1342:  }",
          "1344:  if (!is_cow) {",
          "1345:   error = xfs_bmapi_read(ip, offset_fsb, end_fsb - offset_fsb,",
          "1346:      &imap, &nimaps, XFS_BMAPI_ENTIRE);",
          "1353:   if (create && direct && nimaps &&",
          "1354:       imap.br_startblock != HOLESTARTBLOCK &&",
          "1355:       imap.br_startblock != DELAYSTARTBLOCK &&",
          "1356:       !ISUNWRITTEN(&imap))",
          "1357:    xfs_reflink_trim_irec_to_next_cow(ip, offset_fsb,",
          "1358:      &imap);",
          "1359:  }",
          "1374:  if (direct && imap.br_startblock == DELAYSTARTBLOCK) {",
          "1375:   if (!create || offset < i_size_read(VFS_I(ip))) {",
          "1376:    WARN_ON_ONCE(1);",
          "1377:    error = -EIO;",
          "1378:    goto out_unlock;",
          "1379:   }",
          "1380:   WARN_ON_ONCE(mapping_mapped(VFS_I(ip)->i_mapping));",
          "1381:  }",
          "1384:  if (create &&",
          "1385:      (!nimaps ||",
          "1386:       (imap.br_startblock == HOLESTARTBLOCK ||",
          "1387:        imap.br_startblock == DELAYSTARTBLOCK) ||",
          "1388:       (IS_DAX(inode) && ISUNWRITTEN(&imap)))) {",
          "1393:   if (lockmode == XFS_ILOCK_EXCL)",
          "1394:    xfs_ilock_demote(ip, lockmode);",
          "1396:   error = xfs_iomap_write_direct(ip, offset, size,",
          "1397:             &imap, nimaps);",
          "1398:   if (error)",
          "1399:    return error;",
          "1400:   new = 1;",
          "1402:   trace_xfs_get_blocks_alloc(ip, offset, size,",
          "1403:     ISUNWRITTEN(&imap) ? XFS_IO_UNWRITTEN",
          "1404:          : XFS_IO_DELALLOC, &imap);",
          "1405:  } else if (nimaps) {",
          "",
          "[Added Lines]",
          "1254:  error = xfs_bmapi_read(ip, offset_fsb, end_fsb - offset_fsb,",
          "1255:     &imap, &nimaps, XFS_BMAPI_ENTIRE);",
          "1259:  if (nimaps) {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1412:   goto out_unlock;",
          "1413:  }",
          "1422:  xfs_map_trim_size(inode, iblock, bh_result, &imap, offset, size);",
          "",
          "[Removed Lines]",
          "1415:  if (IS_DAX(inode) && create) {",
          "1416:   ASSERT(!ISUNWRITTEN(&imap));",
          "1418:   new = 0;",
          "1419:  }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1428:  if (imap.br_startblock != HOLESTARTBLOCK &&",
          "1429:      imap.br_startblock != DELAYSTARTBLOCK &&",
          "1438:   xfs_map_buffer(inode, bh_result, &imap, offset);",
          "1450:  bh_result->b_bdev = xfs_find_bdev_for_inode(inode);",
          "1467:  return 0;",
          "1469: out_unlock:",
          "",
          "[Removed Lines]",
          "1430:      (create || !ISUNWRITTEN(&imap))) {",
          "1431:   if (create && direct && !is_cow) {",
          "1432:    error = xfs_bounce_unaligned_dio_write(ip, offset_fsb,",
          "1433:      &imap);",
          "1434:    if (error)",
          "1435:     return error;",
          "1436:   }",
          "1439:   if (ISUNWRITTEN(&imap))",
          "1440:    set_buffer_unwritten(bh_result);",
          "1442:   if (create)",
          "1443:    xfs_map_direct(inode, bh_result, &imap, offset, is_cow);",
          "1444:  }",
          "1461:  if (create &&",
          "1462:      ((!buffer_mapped(bh_result) && !buffer_uptodate(bh_result)) ||",
          "1463:       (offset >= i_size_read(inode)) ||",
          "1464:       (new || ISUNWRITTEN(&imap))))",
          "1465:   set_buffer_new(bh_result);",
          "",
          "[Added Lines]",
          "1278:      !ISUNWRITTEN(&imap))",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1471:  return error;",
          "1472: }",
          "1568: STATIC ssize_t",
          "1569: xfs_vm_direct_IO(",
          "1570:  struct kiocb  *iocb,",
          "",
          "[Removed Lines]",
          "1474: int",
          "1475: xfs_get_blocks(",
          "1476:  struct inode  *inode,",
          "1477:  sector_t  iblock,",
          "1478:  struct buffer_head *bh_result,",
          "1479:  int   create)",
          "1480: {",
          "1481:  return __xfs_get_blocks(inode, iblock, bh_result, create, false);",
          "1482: }",
          "1484: int",
          "1485: xfs_get_blocks_direct(",
          "1486:  struct inode  *inode,",
          "1487:  sector_t  iblock,",
          "1488:  struct buffer_head *bh_result,",
          "1489:  int   create)",
          "1490: {",
          "1491:  return __xfs_get_blocks(inode, iblock, bh_result, create, true);",
          "1492: }",
          "1505: int",
          "1506: xfs_end_io_direct_write(",
          "1507:  struct kiocb  *iocb,",
          "1508:  loff_t   offset,",
          "1509:  ssize_t   size,",
          "1510:  void   *private)",
          "1511: {",
          "1512:  struct inode  *inode = file_inode(iocb->ki_filp);",
          "1513:  struct xfs_inode *ip = XFS_I(inode);",
          "1514:  uintptr_t  flags = (uintptr_t)private;",
          "1515:  int   error = 0;",
          "1517:  trace_xfs_end_io_direct_write(ip, offset, size);",
          "1519:  if (XFS_FORCED_SHUTDOWN(ip->i_mount))",
          "1520:   return -EIO;",
          "1522:  if (size <= 0)",
          "1523:   return size;",
          "1531:  if (flags == 0) {",
          "1532:   ASSERT(offset + size <= i_size_read(inode));",
          "1533:   return 0;",
          "1534:  }",
          "1547:  spin_lock(&ip->i_flags_lock);",
          "1548:  if (offset + size > i_size_read(inode))",
          "1549:   i_size_write(inode, offset + size);",
          "1550:  spin_unlock(&ip->i_flags_lock);",
          "1552:  if (flags & XFS_DIO_FLAG_COW)",
          "1553:   error = xfs_reflink_end_cow(ip, offset, size);",
          "1554:  if (flags & XFS_DIO_FLAG_UNWRITTEN) {",
          "1555:   trace_xfs_end_io_direct_write_unwritten(ip, offset, size);",
          "1557:   error = xfs_iomap_write_unwritten(ip, offset, size);",
          "1558:  }",
          "1559:  if (flags & XFS_DIO_FLAG_APPEND) {",
          "1560:   trace_xfs_end_io_direct_write_append(ip, offset, size);",
          "1562:   error = xfs_setfilesize(ip, offset, size);",
          "1563:  }",
          "1565:  return error;",
          "1566: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "fs/xfs/xfs_aops.h||fs/xfs/xfs_aops.h": [
          "File: fs/xfs/xfs_aops.h -> fs/xfs/xfs_aops.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "56: extern const struct address_space_operations xfs_address_space_operations;",
          "64: int xfs_setfilesize(struct xfs_inode *ip, xfs_off_t offset, size_t size);",
          "66: extern void xfs_count_page_state(struct page *, int *, int *);",
          "",
          "[Removed Lines]",
          "58: int xfs_get_blocks(struct inode *inode, sector_t offset,",
          "59:          struct buffer_head *map_bh, int create);",
          "60: int xfs_get_blocks_direct(struct inode *inode, sector_t offset,",
          "61:          struct buffer_head *map_bh, int create);",
          "62: int xfs_end_io_direct_write(struct kiocb *iocb, loff_t offset,",
          "63:   ssize_t size, void *private);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "fs/xfs/xfs_file.c||fs/xfs/xfs_file.c": [
          "File: fs/xfs/xfs_file.c -> fs/xfs/xfs_file.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "210:  struct kiocb  *iocb,",
          "211:  struct iov_iter  *to)",
          "212: {",
          "217:  size_t   count = iov_iter_count(to);",
          "223:  trace_xfs_file_direct_read(ip, count, iocb->ki_pos);",
          "225:  if (!count)",
          "240:  file_accessed(iocb->ki_filp);",
          "242:  xfs_ilock(ip, XFS_IOLOCK_SHARED);",
          "268:  xfs_iunlock(ip, XFS_IOLOCK_SHARED);",
          "269:  return ret;",
          "270: }",
          "",
          "[Removed Lines]",
          "213:  struct address_space *mapping = iocb->ki_filp->f_mapping;",
          "214:  struct inode  *inode = mapping->host;",
          "215:  struct xfs_inode *ip = XFS_I(inode);",
          "216:  loff_t   isize = i_size_read(inode);",
          "218:  loff_t   end = iocb->ki_pos + count - 1;",
          "219:  struct iov_iter  data;",
          "220:  struct xfs_buftarg *target;",
          "221:  ssize_t   ret = 0;",
          "228:  if (XFS_IS_REALTIME_INODE(ip))",
          "229:   target = ip->i_mount->m_rtdev_targp;",
          "230:  else",
          "231:   target = ip->i_mount->m_ddev_targp;",
          "234:  if ((iocb->ki_pos | count) & target->bt_logical_sectormask) {",
          "235:   if (iocb->ki_pos == isize)",
          "236:    return 0;",
          "237:   return -EINVAL;",
          "238:  }",
          "243:  if (mapping->nrpages) {",
          "244:   ret = filemap_write_and_wait_range(mapping, iocb->ki_pos, end);",
          "245:   if (ret)",
          "246:    goto out_unlock;",
          "253:   ret = invalidate_inode_pages2_range(mapping,",
          "254:     iocb->ki_pos >> PAGE_SHIFT, end >> PAGE_SHIFT);",
          "255:   WARN_ON_ONCE(ret);",
          "256:   ret = 0;",
          "257:  }",
          "259:  data = *to;",
          "260:  ret = __blockdev_direct_IO(iocb, inode, target->bt_bdev, &data,",
          "261:    xfs_get_blocks_direct, NULL, NULL, 0);",
          "262:  if (ret >= 0) {",
          "263:   iocb->ki_pos += ret;",
          "264:   iov_iter_advance(to, ret);",
          "265:  }",
          "267: out_unlock:",
          "",
          "[Added Lines]",
          "213:  struct xfs_inode *ip = XFS_I(file_inode(iocb->ki_filp));",
          "215:  ssize_t   ret;",
          "225:  ret = iomap_dio_rw(iocb, to, &xfs_iomap_ops, NULL);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "465:  return 0;",
          "466: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "427: static int",
          "428: xfs_dio_write_end_io(",
          "429:  struct kiocb  *iocb,",
          "430:  ssize_t   size,",
          "431:  unsigned  flags)",
          "432: {",
          "433:  struct inode  *inode = file_inode(iocb->ki_filp);",
          "434:  struct xfs_inode *ip = XFS_I(inode);",
          "435:  loff_t   offset = iocb->ki_pos;",
          "436:  bool   update_size = false;",
          "437:  int   error = 0;",
          "439:  trace_xfs_end_io_direct_write(ip, offset, size);",
          "441:  if (XFS_FORCED_SHUTDOWN(ip->i_mount))",
          "442:   return -EIO;",
          "444:  if (size <= 0)",
          "445:   return size;",
          "458:  spin_lock(&ip->i_flags_lock);",
          "459:  if (offset + size > i_size_read(inode)) {",
          "460:   i_size_write(inode, offset + size);",
          "461:   update_size = true;",
          "462:  }",
          "463:  spin_unlock(&ip->i_flags_lock);",
          "465:  if (flags & IOMAP_DIO_COW) {",
          "466:   error = xfs_reflink_end_cow(ip, offset, size);",
          "467:   if (error)",
          "468:    return error;",
          "469:  }",
          "471:  if (flags & IOMAP_DIO_UNWRITTEN)",
          "472:   error = xfs_iomap_write_unwritten(ip, offset, size);",
          "473:  else if (update_size)",
          "474:   error = xfs_setfilesize(ip, offset, size);",
          "476:  return error;",
          "477: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "504:  int   unaligned_io = 0;",
          "505:  int   iolock;",
          "506:  size_t   count = iov_iter_count(from);",
          "510:      mp->m_rtdev_targp : mp->m_ddev_targp;",
          "",
          "[Removed Lines]",
          "507:  loff_t   end;",
          "508:  struct iov_iter  data;",
          "509:  struct xfs_buftarg *target = XFS_IS_REALTIME_INODE(ip) ?",
          "",
          "[Added Lines]",
          "518:  struct xfs_buftarg      *target = XFS_IS_REALTIME_INODE(ip) ?",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "534:  if (ret)",
          "535:   goto out;",
          "536:  count = iov_iter_count(from);",
          "",
          "[Removed Lines]",
          "537:  end = iocb->ki_pos + count - 1;",
          "539:  if (mapping->nrpages) {",
          "540:   ret = filemap_write_and_wait_range(mapping, iocb->ki_pos, end);",
          "541:   if (ret)",
          "542:    goto out;",
          "549:   ret = invalidate_inode_pages2_range(mapping,",
          "550:     iocb->ki_pos >> PAGE_SHIFT, end >> PAGE_SHIFT);",
          "551:   WARN_ON_ONCE(ret);",
          "552:   ret = 0;",
          "553:  }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "573:    goto out;",
          "574:  }",
          "592: out:",
          "593:  xfs_iunlock(ip, iolock);",
          "",
          "[Removed Lines]",
          "576:  data = *from;",
          "577:  ret = __blockdev_direct_IO(iocb, inode, target->bt_bdev, &data,",
          "578:    xfs_get_blocks_direct, xfs_end_io_direct_write,",
          "579:    NULL, DIO_ASYNC_EXTEND);",
          "582:  if (mapping->nrpages) {",
          "583:   invalidate_inode_pages2_range(mapping,",
          "584:            iocb->ki_pos >> PAGE_SHIFT,",
          "585:            end >> PAGE_SHIFT);",
          "586:  }",
          "588:  if (ret > 0) {",
          "589:   iocb->ki_pos += ret;",
          "590:   iov_iter_advance(from, ret);",
          "591:  }",
          "",
          "[Added Lines]",
          "568:  ret = iomap_dio_rw(iocb, from, &xfs_iomap_ops, xfs_dio_write_end_io);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1468:   return xfs_filemap_page_mkwrite(vma, vmf);",
          "1470:  xfs_ilock(XFS_I(inode), XFS_MMAPLOCK_SHARED);",
          "1478:   ret = dax_iomap_fault(vma, vmf, &xfs_iomap_ops);",
          "1480:   ret = filemap_fault(vma, vmf);",
          "1481:  xfs_iunlock(XFS_I(inode), XFS_MMAPLOCK_SHARED);",
          "",
          "[Removed Lines]",
          "1471:  if (IS_DAX(inode)) {",
          "1479:  } else",
          "",
          "[Added Lines]",
          "1448:  if (IS_DAX(inode))",
          "1450:  else",
          "",
          "---------------"
        ],
        "fs/xfs/xfs_iomap.c||fs/xfs/xfs_iomap.c": [
          "File: fs/xfs/xfs_iomap.c -> fs/xfs/xfs_iomap.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "950:   (IS_DAX(inode) && ISUNWRITTEN(imap));",
          "951: }",
          "953: static int",
          "954: xfs_file_iomap_begin(",
          "955:  struct inode  *inode,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "953: static inline bool need_excl_ilock(struct xfs_inode *ip, unsigned flags)",
          "954: {",
          "959:  if (xfs_is_reflink_inode(ip) && (flags & (IOMAP_WRITE | IOMAP_ZERO)))",
          "960:   return true;",
          "961:  if ((flags & IOMAP_DIRECT) && (flags & IOMAP_WRITE))",
          "962:   return true;",
          "963:  return false;",
          "964: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "969:  if (XFS_FORCED_SHUTDOWN(mp))",
          "970:   return -EIO;",
          "975:   return xfs_file_iomap_begin_delay(inode, offset, length, flags,",
          "976:     iomap);",
          "977:  }",
          "984:   lockmode = XFS_ILOCK_EXCL;",
          "985:   xfs_ilock(ip, XFS_ILOCK_EXCL);",
          "986:  } else {",
          "",
          "[Removed Lines]",
          "972:  if ((flags & IOMAP_WRITE) && !IS_DAX(inode) &&",
          "973:      !xfs_get_extsz_hint(ip)) {",
          "983:  if ((flags & (IOMAP_WRITE | IOMAP_ZERO)) && xfs_is_reflink_inode(ip)) {",
          "",
          "[Added Lines]",
          "985:  if (((flags & (IOMAP_WRITE | IOMAP_DIRECT)) == IOMAP_WRITE) &&",
          "986:    !IS_DAX(inode) && !xfs_get_extsz_hint(ip)) {",
          "992:  if (need_excl_ilock(ip, flags)) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "993:  offset_fsb = XFS_B_TO_FSBT(mp, offset);",
          "994:  end_fsb = XFS_B_TO_FSB(mp, offset + length);",
          "996:  error = xfs_bmapi_read(ip, offset_fsb, end_fsb - offset_fsb, &imap,",
          "997:           &nimaps, 0);",
          "998:  if (error)",
          "999:   goto out_unlock;",
          "1003:   error = xfs_reflink_trim_around_shared(ip, &imap, &shared,",
          "1004:     &trimmed);",
          "1005:   if (error)",
          "1006:    goto out_unlock;",
          "1007:  }",
          "1009:  if ((flags & (IOMAP_WRITE | IOMAP_ZERO)) && xfs_is_reflink_inode(ip)) {",
          "",
          "[Removed Lines]",
          "1001:  if (flags & IOMAP_REPORT) {",
          "",
          "[Added Lines]",
          "1005:  if (xfs_is_reflink_inode(ip) &&",
          "1006:      (flags & IOMAP_WRITE) && (flags & IOMAP_DIRECT)) {",
          "1007:   shared = xfs_reflink_find_cow_mapping(ip, offset, &imap);",
          "1008:   if (shared) {",
          "1009:    xfs_iunlock(ip, lockmode);",
          "1010:    goto alloc_done;",
          "1011:   }",
          "1012:   ASSERT(!isnullstartblock(imap.br_startblock));",
          "1013:  }",
          "1020:  if ((flags & IOMAP_REPORT) ||",
          "1021:      (xfs_is_reflink_inode(ip) &&",
          "1022:       (flags & IOMAP_WRITE) && (flags & IOMAP_DIRECT))) {",
          "1035:   if (!(flags & IOMAP_REPORT) && shared) {",
          "1036:    trace_xfs_reflink_bounce_dio_write(ip, &imap);",
          "1037:    error = -EREMCHG;",
          "1038:    goto out_unlock;",
          "1039:   }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1038:   if (error)",
          "1039:    return error;",
          "1041:   iomap->flags = IOMAP_F_NEW;",
          "1042:   trace_xfs_iomap_alloc(ip, offset, length, 0, &imap);",
          "1043:  } else {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1074: alloc_done:",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2022-29264",
  "cve_desc": "An issue was discovered in coreboot 4.13 through 4.16. On APs, arbitrary code execution in SMM may occur.",
  "repo": "coreboot/coreboot",
  "patch_hash": "afb7a814783cda12f5b72167163b9109ee1d15a7",
  "patch_info": {
    "commit_hash": "afb7a814783cda12f5b72167163b9109ee1d15a7",
    "repo": "coreboot/coreboot",
    "commit_url": "https://github.com/coreboot/coreboot/commit/afb7a814783cda12f5b72167163b9109ee1d15a7",
    "files": [
      "Documentation/releases/coreboot-4.13-relnotes.md",
      "src/cpu/x86/Kconfig",
      "src/cpu/x86/mp_init.c",
      "src/cpu/x86/smm/Makefile.inc",
      "src/cpu/x86/smm/smm_module_loaderv2.c",
      "src/include/cpu/x86/smm.h"
    ],
    "message": "cpu/x86/smm: Introduce SMM module loader version 2\n\nXeon-SP Skylake Scalable Processor can have 36 CPU threads (18 cores).\nCurrent coreboot SMM is unable to handle more than ~32 CPU threads.\nThis patch introduces a version 2 of the SMM module loader which\naddresses this problem. Having two versions of the SMM module loader\nprevents any issues to current projects. Future Xeon-SP products will\nbe using this version of the SMM loader.  Subsequent patches will\nenable board specific functionality for Xeon-SP.\n\nThe reason for moving to version 2 is the state save area begins to\nencroach upon the SMI handling code when more than 32 CPU threads are\nin the system. This can cause system hangs, reboots, etc. The second\nchange is related to staggered entry points with simple near jumps. In\nthe current loader, near jumps will not work because the CPU is jumping\nwithin the same code segment. In version 2, \"far\" address jumps are\nnecessary therefore protected mode must be enabled first. The SMM\nlayout and how the CPUs are staggered are documented in the code.\n\nBy making the modifications above, this allows the smm module loader to\nexpand easily as more CPU threads are added.\n\nTEST=build for Tiogapass platform under OCP mainboard. Enable the\nfollowing in Kconfig.\n        select CPU_INTEL_COMMON_SMM\n        select SOC_INTEL_COMMON_BLOCK_SMM\n        select SMM_TSEG\n        select HAVE_SMI_HANDLER\n        select ACPI_INTEL_HARDWARE_SLEEP_VALUES\n\nDebug console will show all 36 cores relocated. Further tested by\ngenerating SMI's to port 0xb2 using XDP/ITP HW debugger and ensured all\ncores entering and exiting SMM properly. In addition, booted to Linux\n5.4 kernel and observed no issues during mp init.\n\nChange-Id: I00a23a5f2a46110536c344254868390dbb71854c\nSigned-off-by: Rocky Phagura <rphagura@fb.com>\nReviewed-on: https://review.coreboot.org/c/coreboot/+/43684\nTested-by: build bot (Jenkins) <no-reply@coreboot.org>\nReviewed-by: Angel Pons <th3fanbus@gmail.com>",
    "before_after_code_files": [
      "src/cpu/x86/mp_init.c||src/cpu/x86/mp_init.c",
      "src/cpu/x86/smm/Makefile.inc||src/cpu/x86/smm/Makefile.inc",
      "src/cpu/x86/smm/smm_module_loaderv2.c||src/cpu/x86/smm/smm_module_loaderv2.c",
      "src/include/cpu/x86/smm.h||src/include/cpu/x86/smm.h"
    ]
  },
  "patch_diff": {
    "src/cpu/x86/mp_init.c||src/cpu/x86/mp_init.c": [
      "File: src/cpu/x86/mp_init.c -> src/cpu/x86/mp_init.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "729:  perm_smbase = mp_state.perm_smbase;",
      "730:  perm_smbase -= cpu * runtime->save_state_size;",
      "735:  mp_state.ops.relocation_handler(cpu, curr_smbase, perm_smbase);",
      "737:  if (CONFIG(STM)) {",
      "",
      "[Removed Lines]",
      "732:  printk(BIOS_DEBUG, \"New SMBASE 0x%08lx\\n\", perm_smbase);",
      "",
      "[Added Lines]",
      "729: #if CONFIG(X86_SMM_LOADER_VERSION2)",
      "730:  perm_smbase = smm_get_cpu_smbase(cpu);",
      "731:  mp_state.perm_smbase = perm_smbase;",
      "732:  if (!perm_smbase) {",
      "733:   printk(BIOS_ERR, \"%s: bad SMBASE for CPU %d\\n\", __func__, cpu);",
      "734:   return;",
      "735:  }",
      "736: #else",
      "739: #endif",
      "742:  printk(BIOS_INFO, \"%s : curr_smbase 0x%x perm_smbase 0x%x, cpu = %d\\n\",",
      "743:   __func__, (int)curr_smbase, (int)perm_smbase, cpu);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "759: static int install_relocation_handler(int num_cpus, size_t save_state_size)",
      "760: {",
      "761:  struct smm_loader_params smm_params = {",
      "762:   .per_cpu_stack_size = CONFIG_SMM_STUB_STACK_SIZE,",
      "764:   .per_cpu_save_state_size = save_state_size,",
      "765:   .num_concurrent_save_states = 1,",
      "766:   .handler = smm_do_relocation,",
      "",
      "[Removed Lines]",
      "763:   .num_concurrent_stacks = num_cpus,",
      "",
      "[Added Lines]",
      "770:  int cpus = num_cpus;",
      "771: #if CONFIG(X86_SMM_LOADER_VERSION2)",
      "775:  cpus = 1;",
      "776: #endif",
      "780:   .num_concurrent_stacks = cpus,",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "770:  if (mp_state.ops.adjust_smm_params != NULL)",
      "771:   mp_state.ops.adjust_smm_params(&smm_params, 0);",
      "774:   return -1;",
      "776:  adjust_smm_apic_id_map(&smm_params);",
      "778:  return 0;",
      "",
      "[Removed Lines]",
      "773:  if (smm_setup_relocation_handler(&smm_params))",
      "",
      "[Added Lines]",
      "790:  if (smm_setup_relocation_handler(&smm_params)) {",
      "791:   printk(BIOS_ERR, \"%s: smm setup failed\\n\", __func__);",
      "793:  }",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "794:  if (mp_state.ops.adjust_smm_params != NULL)",
      "795:   mp_state.ops.adjust_smm_params(&smm_params, 1);",
      "799:  if (smm_load_module((void *)smbase, smsize, &smm_params))",
      "800:   return -1;",
      "",
      "[Removed Lines]",
      "797:  printk(BIOS_DEBUG, \"Installing SMM handler to 0x%08lx\\n\", smbase);",
      "",
      "[Added Lines]",
      "820:  printk(BIOS_DEBUG, \"Installing permanent SMM handler to 0x%08lx\\n\", smbase);",
      "",
      "---------------"
    ],
    "src/cpu/x86/smm/Makefile.inc||src/cpu/x86/smm/Makefile.inc": [
      "File: src/cpu/x86/smm/Makefile.inc -> src/cpu/x86/smm/Makefile.inc",
      "--- Hunk 1 ---",
      "[Context before]",
      "1: ## SPDX-License-Identifier: GPL-2.0-only",
      "3: ramstage-y += smm_module_loader.c",
      "4: ramstage-y += smi_trigger.c",
      "6: ifeq ($(CONFIG_ARCH_RAMSTAGE_X86_32),y)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "3: ifeq ($(CONFIG_X86_SMM_LOADER_VERSION2),y)",
      "4: ramstage-y += smm_module_loaderv2.c",
      "5: else",
      "7: endif",
      "",
      "---------------"
    ],
    "src/cpu/x86/smm/smm_module_loaderv2.c||src/cpu/x86/smm/smm_module_loaderv2.c": [
      "File: src/cpu/x86/smm/smm_module_loaderv2.c -> src/cpu/x86/smm/smm_module_loaderv2.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "3: #include <stdint.h>",
      "4: #include <string.h>",
      "5: #include <rmodule.h>",
      "6: #include <cpu/x86/smm.h>",
      "7: #include <commonlib/helpers.h>",
      "8: #include <console/console.h>",
      "9: #include <security/intel/stm/SmmStm.h>",
      "11: #define FXSAVE_SIZE 512",
      "12: #define SMM_CODE_SEGMENT_SIZE 0x10000",
      "14:    SMM stub code relies on the FXSAVE area being non-zero to enable SSE",
      "16: static uint8_t fxsave_area_relocation[CONFIG_MAX_CPUS][FXSAVE_SIZE]",
      "17: __attribute__((aligned(16)));",
      "31: struct smm_stub_params {",
      "32:  u32 stack_size;",
      "33:  u32 stack_top;",
      "34:  u32 c_handler;",
      "35:  u32 c_handler_arg;",
      "36:  u32 fxsave_area;",
      "37:  u32 fxsave_area_size;",
      "38:  struct smm_runtime runtime;",
      "39: } __packed;",
      "45: extern unsigned char _binary_smmstub_start[];",
      "48: #define SMM_MINIMUM_STACK_SIZE 32",
      "50: struct cpu_smm_info {",
      "51:  uint8_t active;",
      "52:  uintptr_t smbase;",
      "53:  uintptr_t entry;",
      "54:  uintptr_t ss_start;",
      "55:  uintptr_t code_start;",
      "56:  uintptr_t code_end;",
      "57: };",
      "58: struct cpu_smm_info cpus[CONFIG_MAX_CPUS] = { 0 };",
      "97: static int smm_create_map(uintptr_t smbase, unsigned int num_cpus,",
      "98:    const struct smm_loader_params *params)",
      "99: {",
      "100:  unsigned int i;",
      "101:  struct rmodule smm_stub;",
      "102:  unsigned int ss_size = params->per_cpu_save_state_size, stub_size;",
      "103:  unsigned int smm_entry_offset = params->smm_main_entry_offset;",
      "104:  unsigned int seg_count = 0, segments = 0, available;",
      "105:  unsigned int cpus_in_segment = 0;",
      "106:  unsigned int base = smbase;",
      "108:  if (rmodule_parse(&_binary_smmstub_start, &smm_stub)) {",
      "109:   printk(BIOS_ERR, \"%s: unable to get SMM module size\\n\", __func__);",
      "110:   return 0;",
      "111:  }",
      "113:  stub_size = rmodule_memory_size(&smm_stub);",
      "115:  available = 0xFFFF - smm_entry_offset - ss_size - stub_size;",
      "116:  if (available > 0) {",
      "117:   cpus_in_segment = available / ss_size;",
      "119:   segments = num_cpus / cpus_in_segment + 1;",
      "120:   printk(BIOS_DEBUG,",
      "121:    \"%s: cpus allowed in one segment %d\\n\", __func__, cpus_in_segment);",
      "122:   printk(BIOS_DEBUG,",
      "123:    \"%s: min # of segments needed %d\\n\", __func__, segments);",
      "124:  } else {",
      "125:   printk(BIOS_ERR, \"%s: not enough space in SMM to setup all CPUs\\n\", __func__);",
      "126:   printk(BIOS_ERR, \"    save state & stub size need to be reduced\\n\");",
      "127:   printk(BIOS_ERR, \"    or increase SMRAM size\\n\");",
      "128:   return 0;",
      "129:  }",
      "131:  if (sizeof(cpus) / sizeof(struct cpu_smm_info) < num_cpus) {",
      "132:   printk(BIOS_ERR,",
      "133:    \"%s: increase MAX_CPUS in Kconfig\\n\", __func__);",
      "134:   return 0;",
      "135:  }",
      "137:  for (i = 0; i < num_cpus; i++) {",
      "138:   cpus[i].smbase = base;",
      "139:   cpus[i].entry = base + smm_entry_offset;",
      "140:   cpus[i].ss_start = cpus[i].entry + (smm_entry_offset - ss_size);",
      "141:   cpus[i].code_start = cpus[i].entry;",
      "142:   cpus[i].code_end = cpus[i].entry + stub_size;",
      "143:   cpus[i].active = 1;",
      "144:   base -= ss_size;",
      "145:   seg_count++;",
      "146:   if (seg_count >= cpus_in_segment) {",
      "147:    base -= smm_entry_offset;",
      "148:    seg_count = 0;",
      "149:   }",
      "150:  }",
      "152:  if (CONFIG_DEFAULT_CONSOLE_LOGLEVEL >= BIOS_DEBUG) {",
      "153:   seg_count = 0;",
      "154:   for (i = 0; i < num_cpus; i++) {",
      "155:    printk(BIOS_DEBUG, \"CPU 0x%x\\n\", i);",
      "156:    printk(BIOS_DEBUG,",
      "157:     \"    smbase %zx  entry %zx\\n\",",
      "158:     cpus[i].smbase, cpus[i].entry);",
      "159:    printk(BIOS_DEBUG,",
      "160:     \"           ss_start %zx  code_end %zx\\n\",",
      "161:     cpus[i].ss_start, cpus[i].code_end);",
      "162:    seg_count++;",
      "163:    if (seg_count >= cpus_in_segment) {",
      "164:     printk(BIOS_DEBUG,",
      "165:      \"-------------NEW CODE SEGMENT --------------\\n\");",
      "166:     seg_count = 0;",
      "167:    }",
      "168:   }",
      "169:  }",
      "170:  return 1;",
      "171: }",
      "180: u32 smm_get_cpu_smbase(unsigned int cpu_num)",
      "181: {",
      "182:  if (cpu_num < CONFIG_MAX_CPUS) {",
      "183:   if (cpus[cpu_num].active)",
      "184:    return cpus[cpu_num].smbase;",
      "185:  }",
      "186:  return 0;",
      "187: }",
      "217: static int smm_place_entry_code(uintptr_t smbase, unsigned int num_cpus,",
      "218:     unsigned int stack_top, const struct smm_loader_params *params)",
      "219: {",
      "220:  unsigned int i;",
      "221:  unsigned int size;",
      "222:  if (smm_create_map(smbase, num_cpus, params)) {",
      "228:   if (cpus[num_cpus].active) {",
      "229:    if (cpus[num_cpus - 1].smbase +",
      "230:     params->smm_main_entry_offset < stack_top) {",
      "231:     printk(BIOS_ERR, \"%s: stack encroachment\\n\", __func__);",
      "232:     printk(BIOS_ERR, \"%s: smbase %zx, stack_top %x\\n\",",
      "233:      __func__, cpus[num_cpus].smbase, stack_top);",
      "234:     return 0;",
      "235:    }",
      "236:   }",
      "237:  } else {",
      "238:   printk(BIOS_ERR, \"%s: unable to place smm entry code\\n\", __func__);",
      "239:   return 0;",
      "240:  }",
      "242:  printk(BIOS_INFO, \"%s: smbase %zx, stack_top %x\\n\",",
      "243:   __func__, cpus[num_cpus-1].smbase, stack_top);",
      "246:  size = cpus[0].code_end - cpus[0].code_start;",
      "247:  for (i = 1; i < num_cpus; i++) {",
      "248:   memcpy((int *)cpus[i].code_start, (int *)cpus[0].code_start, size);",
      "249:   printk(BIOS_DEBUG,",
      "250:    \"SMM Module: placing smm entry code at %zx,  cpu # 0x%x\\n\",",
      "251:    cpus[i].code_start, i);",
      "252:   printk(BIOS_DEBUG, \"%s: copying from %zx to %zx 0x%x bytes\\n\",",
      "253:    __func__, cpus[0].code_start, cpus[i].code_start, size);",
      "254:  }",
      "255:  return 1;",
      "256: }",
      "262: static void *smm_stub_place_stacks(char *base, size_t size,",
      "263:        struct smm_loader_params *params)",
      "264: {",
      "265:  size_t total_stack_size;",
      "266:  char *stacks_top;",
      "270:  total_stack_size = params->per_cpu_stack_size *",
      "271:       params->num_concurrent_stacks;",
      "272:  printk(BIOS_DEBUG, \"%s: cpus: %zx : stack space: needed -> %zx\\n\",",
      "273:   __func__, params->num_concurrent_stacks,",
      "274:   total_stack_size);",
      "275:  printk(BIOS_DEBUG, \"  available -> %zx : per_cpu_stack_size : %zx\\n\",",
      "276:   size, params->per_cpu_stack_size);",
      "279:  if (params->num_concurrent_stacks < 1)",
      "280:   return NULL;",
      "283:  if (total_stack_size > size)",
      "284:   return NULL;",
      "287:  stacks_top = &base[total_stack_size];",
      "288:  printk(BIOS_DEBUG, \"%s: exit, stack_top %p\\n\", __func__, stacks_top);",
      "290:  return stacks_top;",
      "291: }",
      "298: static int smm_stub_place_staggered_entry_points(char *base,",
      "299:  const struct smm_loader_params *params, const struct rmodule *smm_stub)",
      "300: {",
      "301:  size_t stub_entry_offset;",
      "302:  int rc = 1;",
      "303:  stub_entry_offset = rmodule_entry_offset(smm_stub);",
      "307:  if (params->num_concurrent_save_states > 1 || stub_entry_offset != 0) {",
      "308:   rc = smm_place_entry_code((unsigned int)base,",
      "309:    params->num_concurrent_save_states,",
      "310:    (unsigned int)params->stack_top, params);",
      "311:  }",
      "312:  return rc;",
      "313: }",
      "336: static int smm_module_setup_stub(void *smbase, size_t smm_size,",
      "337:      struct smm_loader_params *params,",
      "338:      void *fxsave_area)",
      "339: {",
      "340:  size_t total_save_state_size;",
      "341:  size_t smm_stub_size;",
      "342:  size_t stub_entry_offset;",
      "343:  char *smm_stub_loc;",
      "344:  void *stacks_top;",
      "345:  size_t size;",
      "346:  char *base;",
      "347:  size_t i;",
      "348:  struct smm_stub_params *stub_params;",
      "349:  struct rmodule smm_stub;",
      "350:  unsigned int total_size_all;",
      "351:  base = smbase;",
      "352:  size = smm_size;",
      "355:  if (params->num_concurrent_stacks > CONFIG_MAX_CPUS) {",
      "356:   printk(BIOS_ERR, \"%s: not enough stacks\\n\", __func__);",
      "357:   return -1;",
      "358:  }",
      "361:  if (rmodule_parse(&_binary_smmstub_start, &smm_stub)) {",
      "362:   printk(BIOS_ERR, \"%s: unable to parse smm stub\\n\", __func__);",
      "363:   return -1;",
      "364:  }",
      "367:  total_save_state_size = params->per_cpu_save_state_size *",
      "368:     params->num_concurrent_save_states;",
      "369:  if (total_save_state_size > size) {",
      "370:   printk(BIOS_ERR,",
      "371:    \"%s: more state save space needed:need -> %zx:available->%zx\\n\",",
      "372:    __func__, total_save_state_size, size);",
      "373:   return -1;",
      "374:  }",
      "376:  size -= total_save_state_size;",
      "379:  if (size <= params->smm_main_entry_offset) {",
      "380:   printk(BIOS_ERR, \"%s: encroachment over SMM entry point\\n\", __func__);",
      "381:   printk(BIOS_ERR, \"%s: state save size: %zx : smm_entry_offset -> %x\\n\",",
      "382:    __func__, size, params->smm_main_entry_offset);",
      "383:   return -1;",
      "384:  }",
      "387:  if (params->per_cpu_stack_size <= SMM_MINIMUM_STACK_SIZE ||",
      "388:      (params->per_cpu_stack_size & 3) != 0) {",
      "389:   printk(BIOS_ERR, \"%s: need minimum stack size\\n\", __func__);",
      "390:   return -1;",
      "391:  }",
      "393:  smm_stub_loc = NULL;",
      "394:  smm_stub_size = rmodule_memory_size(&smm_stub);",
      "395:  stub_entry_offset = rmodule_entry_offset(&smm_stub);",
      "398:  smm_stub_loc = &base[params->smm_main_entry_offset];",
      "401:  if (smm_stub_size > (size - params->smm_main_entry_offset)) {",
      "402:   printk(BIOS_ERR, \"%s: stub is too big to fit\\n\", __func__);",
      "403:   return -1;",
      "404:  }",
      "410:  size = params->num_concurrent_stacks * params->per_cpu_stack_size;",
      "411:  stacks_top = smm_stub_place_stacks((char *)params->smram_start, size, params);",
      "412:  if (stacks_top == NULL) {",
      "413:   printk(BIOS_ERR, \"%s: not enough space for stacks\\n\", __func__);",
      "414:   printk(BIOS_ERR, \"%s: ....need -> %p : available -> %zx\\n\", __func__,",
      "415:    base, size);",
      "416:   return -1;",
      "417:  }",
      "418:  params->stack_top = stacks_top;",
      "420:  if (rmodule_load(smm_stub_loc, &smm_stub)) {",
      "421:   printk(BIOS_ERR, \"%s: load module failed\\n\", __func__);",
      "422:   return -1;",
      "423:  }",
      "425:  if (!smm_stub_place_staggered_entry_points(base, params, &smm_stub)) {",
      "426:   printk(BIOS_ERR, \"%s: staggered entry points failed\\n\", __func__);",
      "427:   return -1;",
      "428:  }",
      "431:  stub_params = rmodule_parameters(&smm_stub);",
      "432:  stub_params->stack_top = (uintptr_t)stacks_top;",
      "433:  stub_params->stack_size = params->per_cpu_stack_size;",
      "434:  stub_params->c_handler = (uintptr_t)params->handler;",
      "435:  stub_params->c_handler_arg = (uintptr_t)params->handler_arg;",
      "436:  stub_params->fxsave_area = (uintptr_t)fxsave_area;",
      "437:  stub_params->fxsave_area_size = FXSAVE_SIZE;",
      "438:  stub_params->runtime.smbase = (uintptr_t)smbase;",
      "439:  stub_params->runtime.smm_size = smm_size;",
      "440:  stub_params->runtime.save_state_size = params->per_cpu_save_state_size;",
      "441:  stub_params->runtime.num_cpus = params->num_concurrent_stacks;",
      "443:  printk(BIOS_DEBUG, \"%s: stack_end = 0x%x\\n\",",
      "444:   __func__, stub_params->runtime.smbase);",
      "445:  printk(BIOS_DEBUG,",
      "446:   \"%s: stack_top = 0x%x\\n\", __func__, stub_params->stack_top);",
      "447:  printk(BIOS_DEBUG, \"%s: stack_size = 0x%x\\n\",",
      "448:   __func__, stub_params->stack_size);",
      "449:  printk(BIOS_DEBUG, \"%s: runtime.smbase = 0x%x\\n\",",
      "450:   __func__, stub_params->runtime.smbase);",
      "451:  printk(BIOS_DEBUG, \"%s: runtime.start32_offset = 0x%x\\n\", __func__,",
      "452:   stub_params->runtime.start32_offset);",
      "453:  printk(BIOS_DEBUG, \"%s: runtime.smm_size = 0x%zx\\n\",",
      "454:   __func__, smm_size);",
      "455:  printk(BIOS_DEBUG, \"%s: per_cpu_save_state_size = 0x%x\\n\",",
      "456:   __func__, stub_params->runtime.save_state_size);",
      "457:  printk(BIOS_DEBUG, \"%s: num_cpus = 0x%x\\n\", __func__,",
      "458:   stub_params->runtime.num_cpus);",
      "459:  printk(BIOS_DEBUG, \"%s: total_save_state_size = 0x%x\\n\",",
      "460:   __func__, (stub_params->runtime.save_state_size *",
      "461:   stub_params->runtime.num_cpus));",
      "462:  total_size_all = stub_params->stack_size +",
      "463:   (stub_params->runtime.save_state_size *",
      "464:   stub_params->runtime.num_cpus);",
      "465:  printk(BIOS_DEBUG, \"%s: total_size_all = 0x%x\\n\", __func__,",
      "466:   total_size_all);",
      "469:  for (i = 0; i < params->num_concurrent_stacks; i++)",
      "470:   stub_params->runtime.apic_id_to_cpu[i] = i;",
      "473:  params->runtime = &stub_params->runtime;",
      "475:  printk(BIOS_DEBUG, \"SMM Module: stub loaded at %p. Will call %p(%p)\\n\",",
      "476:         smm_stub_loc, params->handler, params->handler_arg);",
      "477:  return 0;",
      "478: }",
      "486: int smm_setup_relocation_handler(struct smm_loader_params *params)",
      "487: {",
      "488:  void *smram = (void *)(SMM_DEFAULT_BASE);",
      "489:  printk(BIOS_SPEW, \"%s: enter\\n\", __func__);",
      "492:  if (params->num_concurrent_save_states > 1)",
      "493:   return -1;",
      "496:  if (params->handler == NULL)",
      "497:   return -1;",
      "501:  if (params->num_concurrent_stacks == 0)",
      "502:   params->num_concurrent_stacks = CONFIG_MAX_CPUS;",
      "504:  params->smm_main_entry_offset = SMM_ENTRY_OFFSET;",
      "505:  params->smram_start = SMM_DEFAULT_BASE;",
      "506:  params->smram_end = SMM_DEFAULT_BASE + SMM_DEFAULT_SIZE;",
      "507:  return smm_module_setup_stub(smram, SMM_DEFAULT_SIZE,",
      "508:     params, fxsave_area_relocation);",
      "509:  printk(BIOS_SPEW, \"%s: exit\\n\", __func__);",
      "510: }",
      "538: int smm_load_module(void *smram, size_t size, struct smm_loader_params *params)",
      "539: {",
      "540:  struct rmodule smm_mod;",
      "541:  size_t total_stack_size;",
      "542:  size_t handler_size;",
      "543:  size_t module_alignment;",
      "544:  size_t alignment_size;",
      "545:  size_t fxsave_size;",
      "546:  void *fxsave_area;",
      "547:  size_t total_size = 0;",
      "548:  char *base;",
      "550:  if (size <= SMM_DEFAULT_SIZE)",
      "551:   return -1;",
      "556:  base = smram;",
      "557:  base += size;",
      "558:  params->smram_start = (uintptr_t)smram;",
      "559:  params->smram_end = params->smram_start + size;",
      "560:  params->smm_main_entry_offset = SMM_ENTRY_OFFSET;",
      "563:  if (rmodule_parse(&_binary_smm_start, &smm_mod))",
      "564:   return -1;",
      "567:  if (CONFIG(DEBUG_SMI))",
      "568:   memset(smram, 0xcd, size);",
      "570:  total_stack_size = params->per_cpu_stack_size *",
      "571:       params->num_concurrent_stacks;",
      "572:  total_size += total_stack_size;",
      "574:  params->stack_top = smram + total_stack_size;",
      "577:  if (CONFIG(STM)) {",
      "578:   base -= CONFIG_MSEG_SIZE + CONFIG_BIOS_RESOURCE_LIST_SIZE;",
      "579:   total_size += CONFIG_MSEG_SIZE + CONFIG_BIOS_RESOURCE_LIST_SIZE;",
      "580:  }",
      "583:  if (CONFIG(SSE)) {",
      "584:   fxsave_size = FXSAVE_SIZE * params->num_concurrent_stacks;",
      "585:   fxsave_area = base - fxsave_size;",
      "586:   base -= fxsave_size;",
      "587:   total_size += fxsave_size;",
      "588:  } else {",
      "589:   fxsave_size = 0;",
      "590:   fxsave_area = NULL;",
      "591:  }",
      "594:  handler_size = rmodule_memory_size(&smm_mod);",
      "595:  base -= handler_size;",
      "596:  total_size += handler_size;",
      "597:  module_alignment = rmodule_load_alignment(&smm_mod);",
      "598:  alignment_size = module_alignment -",
      "599:     ((uintptr_t)base % module_alignment);",
      "600:  if (alignment_size != module_alignment) {",
      "601:   handler_size += alignment_size;",
      "602:   base += alignment_size;",
      "603:  }",
      "605:  printk(BIOS_DEBUG,",
      "606:   \"%s: total_smm_space_needed %zx, available -> %zx\\n\",",
      "607:    __func__, total_size, size);",
      "610:  if (total_size > size) {",
      "611:   printk(BIOS_ERR, \"%s: need more SMRAM\\n\", __func__);",
      "612:   return -1;",
      "613:  }",
      "614:  if (handler_size > SMM_CODE_SEGMENT_SIZE) {",
      "615:   printk(BIOS_ERR, \"%s: increase SMM_CODE_SEGMENT_SIZE: handler_size = %zx\\n\",",
      "616:    __func__, handler_size);",
      "617:   return -1;",
      "618:  }",
      "620:  if (rmodule_load(base, &smm_mod))",
      "621:   return -1;",
      "623:  params->handler = rmodule_entry(&smm_mod);",
      "624:  params->handler_arg = rmodule_parameters(&smm_mod);",
      "626:  printk(BIOS_DEBUG, \"%s: smram_start: 0x%p\\n\",",
      "627:    __func__, smram);",
      "628:  printk(BIOS_DEBUG, \"%s: smram_end: %p\\n\",",
      "629:    __func__, smram + size);",
      "630:  printk(BIOS_DEBUG, \"%s: stack_top: %p\\n\",",
      "631:    __func__, params->stack_top);",
      "632:  printk(BIOS_DEBUG, \"%s: handler start %p\\n\",",
      "633:    __func__, params->handler);",
      "634:  printk(BIOS_DEBUG, \"%s: handler_size %zx\\n\",",
      "635:    __func__, handler_size);",
      "636:  printk(BIOS_DEBUG, \"%s: handler_arg %p\\n\",",
      "637:    __func__, params->handler_arg);",
      "638:  printk(BIOS_DEBUG, \"%s: fxsave_area %p\\n\",",
      "639:    __func__, fxsave_area);",
      "640:  printk(BIOS_DEBUG, \"%s: fxsave_size %zx\\n\",",
      "641:    __func__, fxsave_size);",
      "642:  printk(BIOS_DEBUG, \"%s: CONFIG_MSEG_SIZE 0x%x\\n\",",
      "643:    __func__, CONFIG_MSEG_SIZE);",
      "644:  printk(BIOS_DEBUG, \"%s: CONFIG_BIOS_RESOURCE_LIST_SIZE 0x%x\\n\",",
      "645:    __func__, CONFIG_BIOS_RESOURCE_LIST_SIZE);",
      "650:  base -= SMM_CODE_SEGMENT_SIZE;",
      "651:  printk(BIOS_DEBUG, \"%s: cpu0 entry: %p\\n\",",
      "652:    __func__, base);",
      "653:  params->smm_entry = (uintptr_t)base + params->smm_main_entry_offset;",
      "654:  return smm_module_setup_stub(base, size, params, fxsave_area);",
      "655: }",
      "",
      "---------------"
    ],
    "src/include/cpu/x86/smm.h||src/include/cpu/x86/smm.h": [
      "File: src/include/cpu/x86/smm.h -> src/include/cpu/x86/smm.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "141:  void *handler_arg;",
      "143:  struct smm_runtime *runtime;",
      "144: };",
      "147: int smm_setup_relocation_handler(struct smm_loader_params *params);",
      "148: int smm_load_module(void *smram, size_t size, struct smm_loader_params *params);",
      "151: void *backup_default_smm_area(void);",
      "152: void restore_default_smm_area(void *smm_save_area);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "152: #if CONFIG(X86_SMM_LOADER_VERSION2)",
      "153:  unsigned int smm_entry;",
      "154:  unsigned int smm_main_entry_offset;",
      "155:  unsigned int smram_start;",
      "156:  unsigned int smram_end;",
      "157: #endif",
      "164: #if CONFIG(X86_SMM_LOADER_VERSION2)",
      "165: u32 smm_get_cpu_smbase(unsigned int cpu_num);",
      "166: #endif",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "5434988bac2175c66fbe29b76d277abf2c0e1819",
      "candidate_info": {
        "commit_hash": "5434988bac2175c66fbe29b76d277abf2c0e1819",
        "repo": "coreboot/coreboot",
        "commit_url": "https://github.com/coreboot/coreboot/commit/5434988bac2175c66fbe29b76d277abf2c0e1819",
        "files": [
          "src/cpu/x86/Kconfig",
          "src/cpu/x86/mp_init.c",
          "src/cpu/x86/smm/Makefile.inc",
          "src/cpu/x86/smm/smm_module_loaderv2.c",
          "src/include/cpu/x86/smm.h"
        ],
        "message": "cpu/x86/smm: Introduce SMM module loader version 2\n\nXeon-SP Skylake Scalable Processor can have 36 CPU threads (18 cores).\nCurrent coreboot SMM is unable to handle more than ~32 CPU threads.\nThis patch introduces a version 2 of the SMM module loader which\naddresses this problem. Having two versions of the SMM module loader\nprevents any issues to current projects. Future Xeon-SP products will\nbe using this version of the SMM loader.  Subsequent patches will\nenable board specific functionality for Xeon-SP.\n\nThe reason for moving to version 2 is the state save area begins to\nencroach upon the SMI handling code when more than 32 CPU threads are\nin the system. This can cause system hangs, reboots, etc. The second\nchange is related to staggered entry points with simple near jumps. In\nthe current loader, near jumps will not work because the CPU is jumping\nwithin the same code segment. In version 2, \"far\" address jumps are\nnecessary therefore protected mode must be enabled first. The SMM\nlayout and how the CPUs are staggered are documented in the code.\n\nBy making the modifications above, this allows the smm module loader to\nexpand easily as more CPU threads are added.\n\nTEST=build for Tiogapass platform under OCP mainboard. Enable the\nfollowing in Kconfig.\n        select CPU_INTEL_COMMON_SMM\n        select SOC_INTEL_COMMON_BLOCK_SMM\n        select SMM_TSEG\n        select HAVE_SMI_HANDLER\n        select ACPI_INTEL_HARDWARE_SLEEP_VALUES\n\nDebug console will show all 36 cores relocated. Further tested by\ngenerating SMI's to port 0xb2 using XDP/ITP HW debugger and ensured all\ncores entering and exiting SMM properly. In addition, booted to Linux\n5.4 kernel and observed no issues during mp init.\nOriginal-Change-Id: I00a23a5f2a46110536c344254868390dbb71854c\nOriginal-Signed-off-by: Rocky Phagura <rphagura@fb.com>\nOriginal-Reviewed-on: https://review.coreboot.org/c/coreboot/+/43684\nOriginal-Tested-by: build bot (Jenkins) <no-reply@coreboot.org>\nOriginal-Reviewed-by: Angel Pons <th3fanbus@gmail.com>\n\n(cherry picked from commit afb7a814783cda12f5b72167163b9109ee1d15a7)\nSigned-off-by: Marc Jones <marcjones@sysproconsulting.com>\n\nChange-Id: I76bb506de56c816f6c0635bfd990125b789c5877\nReviewed-on: https://review.coreboot.org/c/coreboot/+/50313\nTested-by: build bot (Jenkins) <no-reply@coreboot.org>\nReviewed-by: Stefan Reinauer <stefan.reinauer@coreboot.org>\nReviewed-by: Jay Talbott <JayTalbott@sysproconsulting.com>\nReviewed-by: Rocky Phagura",
        "before_after_code_files": [
          "src/cpu/x86/mp_init.c||src/cpu/x86/mp_init.c",
          "src/cpu/x86/smm/Makefile.inc||src/cpu/x86/smm/Makefile.inc",
          "src/cpu/x86/smm/smm_module_loaderv2.c||src/cpu/x86/smm/smm_module_loaderv2.c",
          "src/include/cpu/x86/smm.h||src/include/cpu/x86/smm.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "src/cpu/x86/mp_init.c||src/cpu/x86/mp_init.c",
            "src/cpu/x86/smm/Makefile.inc||src/cpu/x86/smm/Makefile.inc",
            "src/cpu/x86/smm/smm_module_loaderv2.c||src/cpu/x86/smm/smm_module_loaderv2.c",
            "src/include/cpu/x86/smm.h||src/include/cpu/x86/smm.h"
          ],
          "candidate": [
            "src/cpu/x86/mp_init.c||src/cpu/x86/mp_init.c",
            "src/cpu/x86/smm/Makefile.inc||src/cpu/x86/smm/Makefile.inc",
            "src/cpu/x86/smm/smm_module_loaderv2.c||src/cpu/x86/smm/smm_module_loaderv2.c",
            "src/include/cpu/x86/smm.h||src/include/cpu/x86/smm.h"
          ]
        }
      },
      "candidate_diff": {
        "src/cpu/x86/mp_init.c||src/cpu/x86/mp_init.c": [
          "File: src/cpu/x86/mp_init.c -> src/cpu/x86/mp_init.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "739:  perm_smbase = mp_state.perm_smbase;",
          "740:  perm_smbase -= cpu * runtime->save_state_size;",
          "745:  mp_state.ops.relocation_handler(cpu, curr_smbase, perm_smbase);",
          "747:  if (CONFIG(STM)) {",
          "",
          "[Removed Lines]",
          "742:  printk(BIOS_DEBUG, \"New SMBASE 0x%08lx\\n\", perm_smbase);",
          "",
          "[Added Lines]",
          "739: #if CONFIG(X86_SMM_LOADER_VERSION2)",
          "740:  perm_smbase = smm_get_cpu_smbase(cpu);",
          "741:  mp_state.perm_smbase = perm_smbase;",
          "742:  if (!perm_smbase) {",
          "743:   printk(BIOS_ERR, \"%s: bad SMBASE for CPU %d\\n\", __func__, cpu);",
          "744:   return;",
          "745:  }",
          "746: #else",
          "749: #endif",
          "752:  printk(BIOS_INFO, \"%s : curr_smbase 0x%x perm_smbase 0x%x, cpu = %d\\n\",",
          "753:   __func__, (int)curr_smbase, (int)perm_smbase, cpu);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "774: static int install_relocation_handler(int num_cpus, size_t save_state_size)",
          "775: {",
          "776:  struct smm_loader_params smm_params = {",
          "777:   .per_cpu_stack_size = CONFIG_SMM_STUB_STACK_SIZE,",
          "779:   .per_cpu_save_state_size = save_state_size,",
          "780:   .num_concurrent_save_states = 1,",
          "781:   .handler = smm_do_relocation,",
          "",
          "[Removed Lines]",
          "778:   .num_concurrent_stacks = num_cpus,",
          "",
          "[Added Lines]",
          "785:  int cpus = num_cpus;",
          "786: #if CONFIG(X86_SMM_LOADER_VERSION2)",
          "790:  cpus = 1;",
          "791: #endif",
          "795:   .num_concurrent_stacks = cpus,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "785:  if (mp_state.ops.adjust_smm_params != NULL)",
          "786:   mp_state.ops.adjust_smm_params(&smm_params, 0);",
          "789:   return -1;",
          "791:  adjust_smm_apic_id_map(&smm_params);",
          "793:  return 0;",
          "",
          "[Removed Lines]",
          "788:  if (smm_setup_relocation_handler(&smm_params))",
          "",
          "[Added Lines]",
          "805:  if (smm_setup_relocation_handler(&smm_params)) {",
          "806:   printk(BIOS_ERR, \"%s: smm setup failed\\n\", __func__);",
          "808:  }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "809:  if (mp_state.ops.adjust_smm_params != NULL)",
          "810:   mp_state.ops.adjust_smm_params(&smm_params, 1);",
          "814:  if (smm_load_module((void *)smbase, smsize, &smm_params))",
          "815:   return -1;",
          "",
          "[Removed Lines]",
          "812:  printk(BIOS_DEBUG, \"Installing SMM handler to 0x%08lx\\n\", smbase);",
          "",
          "[Added Lines]",
          "835:  printk(BIOS_DEBUG, \"Installing permanent SMM handler to 0x%08lx\\n\", smbase);",
          "",
          "---------------"
        ],
        "src/cpu/x86/smm/Makefile.inc||src/cpu/x86/smm/Makefile.inc": [
          "File: src/cpu/x86/smm/Makefile.inc -> src/cpu/x86/smm/Makefile.inc",
          "--- Hunk 1 ---",
          "[Context before]",
          "11: ## GNU General Public License for more details.",
          "12: ##",
          "14: ramstage-y += smm_module_loader.c",
          "16: ifeq ($(CONFIG_ARCH_RAMSTAGE_X86_32),y)",
          "17: $(eval $(call create_class_compiler,smm,x86_32))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "14: ifeq ($(CONFIG_X86_SMM_LOADER_VERSION2),y)",
          "15: ramstage-y += smm_module_loaderv2.c",
          "16: else",
          "18: endif",
          "",
          "---------------"
        ],
        "src/cpu/x86/smm/smm_module_loaderv2.c||src/cpu/x86/smm/smm_module_loaderv2.c": [
          "File: src/cpu/x86/smm/smm_module_loaderv2.c -> src/cpu/x86/smm/smm_module_loaderv2.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "14: #include <stdint.h>",
          "15: #include <string.h>",
          "16: #include <rmodule.h>",
          "17: #include <cpu/x86/smm.h>",
          "18: #include <commonlib/helpers.h>",
          "19: #include <console/console.h>",
          "20: #include <security/intel/stm/SmmStm.h>",
          "22: #define FXSAVE_SIZE 512",
          "23: #define SMM_CODE_SEGMENT_SIZE 0x10000",
          "25:    SMM stub code relies on the FXSAVE area being non-zero to enable SSE",
          "27: static uint8_t fxsave_area_relocation[CONFIG_MAX_CPUS][FXSAVE_SIZE]",
          "28: __attribute__((aligned(16)));",
          "42: struct smm_stub_params {",
          "43:  u32 stack_size;",
          "44:  u32 stack_top;",
          "45:  u32 c_handler;",
          "46:  u32 c_handler_arg;",
          "47:  u32 fxsave_area;",
          "48:  u32 fxsave_area_size;",
          "49:  struct smm_runtime runtime;",
          "50: } __packed;",
          "56: extern unsigned char _binary_smmstub_start[];",
          "59: #define SMM_MINIMUM_STACK_SIZE 32",
          "61: struct cpu_smm_info {",
          "62:  uint8_t active;",
          "63:  uintptr_t smbase;",
          "64:  uintptr_t entry;",
          "65:  uintptr_t ss_start;",
          "66:  uintptr_t code_start;",
          "67:  uintptr_t code_end;",
          "68: };",
          "69: struct cpu_smm_info cpus[CONFIG_MAX_CPUS] = { 0 };",
          "108: static int smm_create_map(uintptr_t smbase, unsigned int num_cpus,",
          "109:    const struct smm_loader_params *params)",
          "110: {",
          "111:  unsigned int i;",
          "112:  struct rmodule smm_stub;",
          "113:  unsigned int ss_size = params->per_cpu_save_state_size, stub_size;",
          "114:  unsigned int smm_entry_offset = params->smm_main_entry_offset;",
          "115:  unsigned int seg_count = 0, segments = 0, available;",
          "116:  unsigned int cpus_in_segment = 0;",
          "117:  unsigned int base = smbase;",
          "119:  if (rmodule_parse(&_binary_smmstub_start, &smm_stub)) {",
          "120:   printk(BIOS_ERR, \"%s: unable to get SMM module size\\n\", __func__);",
          "121:   return 0;",
          "122:  }",
          "124:  stub_size = rmodule_memory_size(&smm_stub);",
          "126:  available = 0xFFFF - smm_entry_offset - ss_size - stub_size;",
          "127:  if (available > 0) {",
          "128:   cpus_in_segment = available / ss_size;",
          "130:   segments = num_cpus / cpus_in_segment + 1;",
          "131:   printk(BIOS_DEBUG,",
          "132:    \"%s: cpus allowed in one segment %d\\n\", __func__, cpus_in_segment);",
          "133:   printk(BIOS_DEBUG,",
          "134:    \"%s: min # of segments needed %d\\n\", __func__, segments);",
          "135:  } else {",
          "136:   printk(BIOS_ERR, \"%s: not enough space in SMM to setup all CPUs\\n\", __func__);",
          "137:   printk(BIOS_ERR, \"    save state & stub size need to be reduced\\n\");",
          "138:   printk(BIOS_ERR, \"    or increase SMRAM size\\n\");",
          "139:   return 0;",
          "140:  }",
          "142:  if (sizeof(cpus) / sizeof(struct cpu_smm_info) < num_cpus) {",
          "143:   printk(BIOS_ERR,",
          "144:    \"%s: increase MAX_CPUS in Kconfig\\n\", __func__);",
          "145:   return 0;",
          "146:  }",
          "148:  for (i = 0; i < num_cpus; i++) {",
          "149:   cpus[i].smbase = base;",
          "150:   cpus[i].entry = base + smm_entry_offset;",
          "151:   cpus[i].ss_start = cpus[i].entry + (smm_entry_offset - ss_size);",
          "152:   cpus[i].code_start = cpus[i].entry;",
          "153:   cpus[i].code_end = cpus[i].entry + stub_size;",
          "154:   cpus[i].active = 1;",
          "155:   base -= ss_size;",
          "156:   seg_count++;",
          "157:   if (seg_count >= cpus_in_segment) {",
          "158:    base -= smm_entry_offset;",
          "159:    seg_count = 0;",
          "160:   }",
          "161:  }",
          "163:  if (CONFIG_DEFAULT_CONSOLE_LOGLEVEL >= BIOS_DEBUG) {",
          "164:   seg_count = 0;",
          "165:   for (i = 0; i < num_cpus; i++) {",
          "166:    printk(BIOS_DEBUG, \"CPU 0x%x\\n\", i);",
          "167:    printk(BIOS_DEBUG,",
          "168:     \"    smbase %zx  entry %zx\\n\",",
          "169:     cpus[i].smbase, cpus[i].entry);",
          "170:    printk(BIOS_DEBUG,",
          "171:     \"           ss_start %zx  code_end %zx\\n\",",
          "172:     cpus[i].ss_start, cpus[i].code_end);",
          "173:    seg_count++;",
          "174:    if (seg_count >= cpus_in_segment) {",
          "175:     printk(BIOS_DEBUG,",
          "176:      \"-------------NEW CODE SEGMENT --------------\\n\");",
          "177:     seg_count = 0;",
          "178:    }",
          "179:   }",
          "180:  }",
          "181:  return 1;",
          "182: }",
          "191: u32 smm_get_cpu_smbase(unsigned int cpu_num)",
          "192: {",
          "193:  if (cpu_num < CONFIG_MAX_CPUS) {",
          "194:   if (cpus[cpu_num].active)",
          "195:    return cpus[cpu_num].smbase;",
          "196:  }",
          "197:  return 0;",
          "198: }",
          "228: static int smm_place_entry_code(uintptr_t smbase, unsigned int num_cpus,",
          "229:     unsigned int stack_top, const struct smm_loader_params *params)",
          "230: {",
          "231:  unsigned int i;",
          "232:  unsigned int size;",
          "233:  if (smm_create_map(smbase, num_cpus, params)) {",
          "239:   if (cpus[num_cpus].active) {",
          "240:    if (cpus[num_cpus - 1].smbase +",
          "241:     params->smm_main_entry_offset < stack_top) {",
          "242:     printk(BIOS_ERR, \"%s: stack encroachment\\n\", __func__);",
          "243:     printk(BIOS_ERR, \"%s: smbase %zx, stack_top %x\\n\",",
          "244:      __func__, cpus[num_cpus].smbase, stack_top);",
          "245:     return 0;",
          "246:    }",
          "247:   }",
          "248:  } else {",
          "249:   printk(BIOS_ERR, \"%s: unable to place smm entry code\\n\", __func__);",
          "250:   return 0;",
          "251:  }",
          "253:  printk(BIOS_INFO, \"%s: smbase %zx, stack_top %x\\n\",",
          "254:   __func__, cpus[num_cpus-1].smbase, stack_top);",
          "257:  size = cpus[0].code_end - cpus[0].code_start;",
          "258:  for (i = 1; i < num_cpus; i++) {",
          "259:   memcpy((int *)cpus[i].code_start, (int *)cpus[0].code_start, size);",
          "260:   printk(BIOS_DEBUG,",
          "261:    \"SMM Module: placing smm entry code at %zx,  cpu # 0x%x\\n\",",
          "262:    cpus[i].code_start, i);",
          "263:   printk(BIOS_DEBUG, \"%s: copying from %zx to %zx 0x%x bytes\\n\",",
          "264:    __func__, cpus[0].code_start, cpus[i].code_start, size);",
          "265:  }",
          "266:  return 1;",
          "267: }",
          "273: static void *smm_stub_place_stacks(char *base, size_t size,",
          "274:        struct smm_loader_params *params)",
          "275: {",
          "276:  size_t total_stack_size;",
          "277:  char *stacks_top;",
          "281:  total_stack_size = params->per_cpu_stack_size *",
          "282:       params->num_concurrent_stacks;",
          "283:  printk(BIOS_DEBUG, \"%s: cpus: %zx : stack space: needed -> %zx\\n\",",
          "284:   __func__, params->num_concurrent_stacks,",
          "285:   total_stack_size);",
          "286:  printk(BIOS_DEBUG, \"  available -> %zx : per_cpu_stack_size : %zx\\n\",",
          "287:   size, params->per_cpu_stack_size);",
          "290:  if (params->num_concurrent_stacks < 1)",
          "291:   return NULL;",
          "294:  if (total_stack_size > size)",
          "295:   return NULL;",
          "298:  stacks_top = &base[total_stack_size];",
          "299:  printk(BIOS_DEBUG, \"%s: exit, stack_top %p\\n\", __func__, stacks_top);",
          "301:  return stacks_top;",
          "302: }",
          "309: static int smm_stub_place_staggered_entry_points(char *base,",
          "310:  const struct smm_loader_params *params, const struct rmodule *smm_stub)",
          "311: {",
          "312:  size_t stub_entry_offset;",
          "313:  int rc = 1;",
          "314:  stub_entry_offset = rmodule_entry_offset(smm_stub);",
          "318:  if (params->num_concurrent_save_states > 1 || stub_entry_offset != 0) {",
          "319:   rc = smm_place_entry_code((unsigned int)base,",
          "320:    params->num_concurrent_save_states,",
          "321:    (unsigned int)params->stack_top, params);",
          "322:  }",
          "323:  return rc;",
          "324: }",
          "347: static int smm_module_setup_stub(void *smbase, size_t smm_size,",
          "348:      struct smm_loader_params *params,",
          "349:      void *fxsave_area)",
          "350: {",
          "351:  size_t total_save_state_size;",
          "352:  size_t smm_stub_size;",
          "353:  size_t stub_entry_offset;",
          "354:  char *smm_stub_loc;",
          "355:  void *stacks_top;",
          "356:  size_t size;",
          "357:  char *base;",
          "358:  size_t i;",
          "359:  struct smm_stub_params *stub_params;",
          "360:  struct rmodule smm_stub;",
          "361:  unsigned int total_size_all;",
          "362:  base = smbase;",
          "363:  size = smm_size;",
          "366:  if (params->num_concurrent_stacks > CONFIG_MAX_CPUS) {",
          "367:   printk(BIOS_ERR, \"%s: not enough stacks\\n\", __func__);",
          "368:   return -1;",
          "369:  }",
          "372:  if (rmodule_parse(&_binary_smmstub_start, &smm_stub)) {",
          "373:   printk(BIOS_ERR, \"%s: unable to parse smm stub\\n\", __func__);",
          "374:   return -1;",
          "375:  }",
          "378:  total_save_state_size = params->per_cpu_save_state_size *",
          "379:     params->num_concurrent_save_states;",
          "380:  if (total_save_state_size > size) {",
          "381:   printk(BIOS_ERR,",
          "382:    \"%s: more state save space needed:need -> %zx:available->%zx\\n\",",
          "383:    __func__, total_save_state_size, size);",
          "384:   return -1;",
          "385:  }",
          "387:  size -= total_save_state_size;",
          "390:  if (size <= params->smm_main_entry_offset) {",
          "391:   printk(BIOS_ERR, \"%s: encroachment over SMM entry point\\n\", __func__);",
          "392:   printk(BIOS_ERR, \"%s: state save size: %zx : smm_entry_offset -> %x\\n\",",
          "393:    __func__, size, params->smm_main_entry_offset);",
          "394:   return -1;",
          "395:  }",
          "398:  if (params->per_cpu_stack_size <= SMM_MINIMUM_STACK_SIZE ||",
          "399:      (params->per_cpu_stack_size & 3) != 0) {",
          "400:   printk(BIOS_ERR, \"%s: need minimum stack size\\n\", __func__);",
          "401:   return -1;",
          "402:  }",
          "404:  smm_stub_loc = NULL;",
          "405:  smm_stub_size = rmodule_memory_size(&smm_stub);",
          "406:  stub_entry_offset = rmodule_entry_offset(&smm_stub);",
          "409:  smm_stub_loc = &base[params->smm_main_entry_offset];",
          "412:  if (smm_stub_size > (size - params->smm_main_entry_offset)) {",
          "413:   printk(BIOS_ERR, \"%s: stub is too big to fit\\n\", __func__);",
          "414:   return -1;",
          "415:  }",
          "421:  size = params->num_concurrent_stacks * params->per_cpu_stack_size;",
          "422:  stacks_top = smm_stub_place_stacks((char *)params->smram_start, size, params);",
          "423:  if (stacks_top == NULL) {",
          "424:   printk(BIOS_ERR, \"%s: not enough space for stacks\\n\", __func__);",
          "425:   printk(BIOS_ERR, \"%s: ....need -> %p : available -> %zx\\n\", __func__,",
          "426:    base, size);",
          "427:   return -1;",
          "428:  }",
          "429:  params->stack_top = stacks_top;",
          "431:  if (rmodule_load(smm_stub_loc, &smm_stub)) {",
          "432:   printk(BIOS_ERR, \"%s: load module failed\\n\", __func__);",
          "433:   return -1;",
          "434:  }",
          "436:  if (!smm_stub_place_staggered_entry_points(base, params, &smm_stub)) {",
          "437:   printk(BIOS_ERR, \"%s: staggered entry points failed\\n\", __func__);",
          "438:   return -1;",
          "439:  }",
          "442:  stub_params = rmodule_parameters(&smm_stub);",
          "443:  stub_params->stack_top = (uintptr_t)stacks_top;",
          "444:  stub_params->stack_size = params->per_cpu_stack_size;",
          "445:  stub_params->c_handler = (uintptr_t)params->handler;",
          "446:  stub_params->c_handler_arg = (uintptr_t)params->handler_arg;",
          "447:  stub_params->fxsave_area = (uintptr_t)fxsave_area;",
          "448:  stub_params->fxsave_area_size = FXSAVE_SIZE;",
          "449:  stub_params->runtime.smbase = (uintptr_t)smbase;",
          "450:  stub_params->runtime.smm_size = smm_size;",
          "451:  stub_params->runtime.save_state_size = params->per_cpu_save_state_size;",
          "452:  stub_params->runtime.num_cpus = params->num_concurrent_stacks;",
          "454:  printk(BIOS_DEBUG, \"%s: stack_end = 0x%x\\n\",",
          "455:   __func__, stub_params->runtime.smbase);",
          "456:  printk(BIOS_DEBUG,",
          "457:   \"%s: stack_top = 0x%x\\n\", __func__, stub_params->stack_top);",
          "458:  printk(BIOS_DEBUG, \"%s: stack_size = 0x%x\\n\",",
          "459:   __func__, stub_params->stack_size);",
          "460:  printk(BIOS_DEBUG, \"%s: runtime.smbase = 0x%x\\n\",",
          "461:   __func__, stub_params->runtime.smbase);",
          "462:  printk(BIOS_DEBUG, \"%s: runtime.start32_offset = 0x%x\\n\", __func__,",
          "463:   stub_params->runtime.start32_offset);",
          "464:  printk(BIOS_DEBUG, \"%s: runtime.smm_size = 0x%zx\\n\",",
          "465:   __func__, smm_size);",
          "466:  printk(BIOS_DEBUG, \"%s: per_cpu_save_state_size = 0x%x\\n\",",
          "467:   __func__, stub_params->runtime.save_state_size);",
          "468:  printk(BIOS_DEBUG, \"%s: num_cpus = 0x%x\\n\", __func__,",
          "469:   stub_params->runtime.num_cpus);",
          "470:  printk(BIOS_DEBUG, \"%s: total_save_state_size = 0x%x\\n\",",
          "471:   __func__, (stub_params->runtime.save_state_size *",
          "472:   stub_params->runtime.num_cpus));",
          "473:  total_size_all = stub_params->stack_size +",
          "474:   (stub_params->runtime.save_state_size *",
          "475:   stub_params->runtime.num_cpus);",
          "476:  printk(BIOS_DEBUG, \"%s: total_size_all = 0x%x\\n\", __func__,",
          "477:   total_size_all);",
          "480:  for (i = 0; i < params->num_concurrent_stacks; i++)",
          "481:   stub_params->runtime.apic_id_to_cpu[i] = i;",
          "484:  params->runtime = &stub_params->runtime;",
          "486:  printk(BIOS_DEBUG, \"SMM Module: stub loaded at %p. Will call %p(%p)\\n\",",
          "487:         smm_stub_loc, params->handler, params->handler_arg);",
          "488:  return 0;",
          "489: }",
          "497: int smm_setup_relocation_handler(struct smm_loader_params *params)",
          "498: {",
          "499:  void *smram = (void *)(SMM_DEFAULT_BASE);",
          "500:  printk(BIOS_SPEW, \"%s: enter\\n\", __func__);",
          "503:  if (params->num_concurrent_save_states > 1)",
          "504:   return -1;",
          "507:  if (params->handler == NULL)",
          "508:   return -1;",
          "512:  if (params->num_concurrent_stacks == 0)",
          "513:   params->num_concurrent_stacks = CONFIG_MAX_CPUS;",
          "515:  params->smm_main_entry_offset = SMM_ENTRY_OFFSET;",
          "516:  params->smram_start = SMM_DEFAULT_BASE;",
          "517:  params->smram_end = SMM_DEFAULT_BASE + SMM_DEFAULT_SIZE;",
          "518:  return smm_module_setup_stub(smram, SMM_DEFAULT_SIZE,",
          "519:     params, fxsave_area_relocation);",
          "520:  printk(BIOS_SPEW, \"%s: exit\\n\", __func__);",
          "521: }",
          "549: int smm_load_module(void *smram, size_t size, struct smm_loader_params *params)",
          "550: {",
          "551:  struct rmodule smm_mod;",
          "552:  size_t total_stack_size;",
          "553:  size_t handler_size;",
          "554:  size_t module_alignment;",
          "555:  size_t alignment_size;",
          "556:  size_t fxsave_size;",
          "557:  void *fxsave_area;",
          "558:  size_t total_size = 0;",
          "559:  char *base;",
          "561:  if (size <= SMM_DEFAULT_SIZE)",
          "562:   return -1;",
          "567:  base = smram;",
          "568:  base += size;",
          "569:  params->smram_start = (uintptr_t)smram;",
          "570:  params->smram_end = params->smram_start + size;",
          "571:  params->smm_main_entry_offset = SMM_ENTRY_OFFSET;",
          "574:  if (rmodule_parse(&_binary_smm_start, &smm_mod))",
          "575:   return -1;",
          "578:  if (CONFIG(DEBUG_SMI))",
          "579:   memset(smram, 0xcd, size);",
          "581:  total_stack_size = params->per_cpu_stack_size *",
          "582:       params->num_concurrent_stacks;",
          "583:  total_size += total_stack_size;",
          "585:  params->stack_top = smram + total_stack_size;",
          "588:  if (CONFIG(STM)) {",
          "589:   base -= CONFIG_MSEG_SIZE + CONFIG_BIOS_RESOURCE_LIST_SIZE;",
          "590:   total_size += CONFIG_MSEG_SIZE + CONFIG_BIOS_RESOURCE_LIST_SIZE;",
          "591:  }",
          "594:  if (CONFIG(SSE)) {",
          "595:   fxsave_size = FXSAVE_SIZE * params->num_concurrent_stacks;",
          "596:   fxsave_area = base - fxsave_size;",
          "597:   base -= fxsave_size;",
          "598:   total_size += fxsave_size;",
          "599:  } else {",
          "600:   fxsave_size = 0;",
          "601:   fxsave_area = NULL;",
          "602:  }",
          "605:  handler_size = rmodule_memory_size(&smm_mod);",
          "606:  base -= handler_size;",
          "607:  total_size += handler_size;",
          "608:  module_alignment = rmodule_load_alignment(&smm_mod);",
          "609:  alignment_size = module_alignment -",
          "610:     ((uintptr_t)base % module_alignment);",
          "611:  if (alignment_size != module_alignment) {",
          "612:   handler_size += alignment_size;",
          "613:   base += alignment_size;",
          "614:  }",
          "616:  printk(BIOS_DEBUG,",
          "617:   \"%s: total_smm_space_needed %zx, available -> %zx\\n\",",
          "618:    __func__, total_size, size);",
          "621:  if (total_size > size) {",
          "622:   printk(BIOS_ERR, \"%s: need more SMRAM\\n\", __func__);",
          "623:   return -1;",
          "624:  }",
          "625:  if (handler_size > SMM_CODE_SEGMENT_SIZE) {",
          "626:   printk(BIOS_ERR, \"%s: increase SMM_CODE_SEGMENT_SIZE: handler_size = %zx\\n\",",
          "627:    __func__, handler_size);",
          "628:   return -1;",
          "629:  }",
          "631:  if (rmodule_load(base, &smm_mod))",
          "632:   return -1;",
          "634:  params->handler = rmodule_entry(&smm_mod);",
          "635:  params->handler_arg = rmodule_parameters(&smm_mod);",
          "637:  printk(BIOS_DEBUG, \"%s: smram_start: 0x%p\\n\",",
          "638:    __func__, smram);",
          "639:  printk(BIOS_DEBUG, \"%s: smram_end: %p\\n\",",
          "640:    __func__, smram + size);",
          "641:  printk(BIOS_DEBUG, \"%s: stack_top: %p\\n\",",
          "642:    __func__, params->stack_top);",
          "643:  printk(BIOS_DEBUG, \"%s: handler start %p\\n\",",
          "644:    __func__, params->handler);",
          "645:  printk(BIOS_DEBUG, \"%s: handler_size %zx\\n\",",
          "646:    __func__, handler_size);",
          "647:  printk(BIOS_DEBUG, \"%s: handler_arg %p\\n\",",
          "648:    __func__, params->handler_arg);",
          "649:  printk(BIOS_DEBUG, \"%s: fxsave_area %p\\n\",",
          "650:    __func__, fxsave_area);",
          "651:  printk(BIOS_DEBUG, \"%s: fxsave_size %zx\\n\",",
          "652:    __func__, fxsave_size);",
          "653:  printk(BIOS_DEBUG, \"%s: CONFIG_MSEG_SIZE 0x%x\\n\",",
          "654:    __func__, CONFIG_MSEG_SIZE);",
          "655:  printk(BIOS_DEBUG, \"%s: CONFIG_BIOS_RESOURCE_LIST_SIZE 0x%x\\n\",",
          "656:    __func__, CONFIG_BIOS_RESOURCE_LIST_SIZE);",
          "661:  base -= SMM_CODE_SEGMENT_SIZE;",
          "662:  printk(BIOS_DEBUG, \"%s: cpu0 entry: %p\\n\",",
          "663:    __func__, base);",
          "664:  params->smm_entry = (uintptr_t)base + params->smm_main_entry_offset;",
          "665:  return smm_module_setup_stub(base, size, params, fxsave_area);",
          "666: }",
          "",
          "---------------"
        ],
        "src/include/cpu/x86/smm.h||src/include/cpu/x86/smm.h": [
          "File: src/include/cpu/x86/smm.h -> src/include/cpu/x86/smm.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "131:  void *handler_arg;",
          "133:  struct smm_runtime *runtime;",
          "134: };",
          "137: int smm_setup_relocation_handler(struct smm_loader_params *params);",
          "138: int smm_load_module(void *smram, size_t size, struct smm_loader_params *params);",
          "141: void *backup_default_smm_area(void);",
          "142: void restore_default_smm_area(void *smm_save_area);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "142: #if CONFIG(X86_SMM_LOADER_VERSION2)",
          "143:  unsigned int smm_entry;",
          "144:  unsigned int smm_main_entry_offset;",
          "145:  unsigned int smram_start;",
          "146:  unsigned int smram_end;",
          "147: #endif",
          "154: #if CONFIG(X86_SMM_LOADER_VERSION2)",
          "155: u32 smm_get_cpu_smbase(unsigned int cpu_num);",
          "156: #endif",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "ed4be45d58ea482c1c8172bc4b2fa1c6af75c75f",
      "candidate_info": {
        "commit_hash": "ed4be45d58ea482c1c8172bc4b2fa1c6af75c75f",
        "repo": "coreboot/coreboot",
        "commit_url": "https://github.com/coreboot/coreboot/commit/ed4be45d58ea482c1c8172bc4b2fa1c6af75c75f",
        "files": [
          "src/cpu/x86/mp_init.c",
          "src/cpu/x86/smm/smm_module_loader.c",
          "src/cpu/x86/smm/smm_module_loaderv2.c",
          "src/cpu/x86/smm/smm_stub.S",
          "src/include/cpu/x86/smm.h"
        ],
        "message": "cpu/x86/smm: Move apic_id_to_cpu map to smm_stub params\n\nThis is only consumed by the stub and not by the relocation handler or\nthe permanent handler, so move it out of the runtime struct.\n\nChange-Id: I01ed0a412c23c8a82d88408be058a27e55d0dc4d\nSigned-off-by: Arthur Heymans <arthur@aheymans.xyz>\nReviewed-on: https://review.coreboot.org/c/coreboot/+/50762\nTested-by: build bot (Jenkins) <no-reply@coreboot.org>\nReviewed-by: Angel Pons <th3fanbus@gmail.com>",
        "before_after_code_files": [
          "src/cpu/x86/mp_init.c||src/cpu/x86/mp_init.c",
          "src/cpu/x86/smm/smm_module_loader.c||src/cpu/x86/smm/smm_module_loader.c",
          "src/cpu/x86/smm/smm_module_loaderv2.c||src/cpu/x86/smm/smm_module_loaderv2.c",
          "src/cpu/x86/smm/smm_stub.S||src/cpu/x86/smm/smm_stub.S",
          "src/include/cpu/x86/smm.h||src/include/cpu/x86/smm.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/cpu/x86/mp_init.c||src/cpu/x86/mp_init.c",
            "src/cpu/x86/smm/smm_module_loaderv2.c||src/cpu/x86/smm/smm_module_loaderv2.c",
            "src/include/cpu/x86/smm.h||src/include/cpu/x86/smm.h"
          ],
          "candidate": [
            "src/cpu/x86/mp_init.c||src/cpu/x86/mp_init.c",
            "src/cpu/x86/smm/smm_module_loaderv2.c||src/cpu/x86/smm/smm_module_loaderv2.c",
            "src/include/cpu/x86/smm.h||src/include/cpu/x86/smm.h"
          ]
        }
      },
      "candidate_diff": {
        "src/cpu/x86/mp_init.c||src/cpu/x86/mp_init.c": [
          "File: src/cpu/x86/mp_init.c -> src/cpu/x86/mp_init.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "762: static void adjust_smm_apic_id_map(struct smm_loader_params *smm_params)",
          "763: {",
          "764:  int i;",
          "767:  for (i = 0; i < CONFIG_MAX_CPUS; i++)",
          "769: }",
          "771: static int install_relocation_handler(int num_cpus, size_t save_state_size)",
          "",
          "[Removed Lines]",
          "765:  struct smm_runtime *runtime = smm_params->runtime;",
          "768:   runtime->apic_id_to_cpu[i] = cpu_get_apic_id(i);",
          "",
          "[Added Lines]",
          "765:  struct smm_stub_params *stub_params = smm_params->stub_params;",
          "768:   stub_params->apic_id_to_cpu[i] = cpu_get_apic_id(i);",
          "",
          "---------------"
        ],
        "src/cpu/x86/smm/smm_module_loader.c||src/cpu/x86/smm/smm_module_loader.c": [
          "File: src/cpu/x86/smm/smm_module_loader.c -> src/cpu/x86/smm/smm_module_loader.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "261:  for (i = 0; i < params->num_concurrent_stacks; i++)",
          "265:  params->runtime = &stub_params->runtime;",
          "267:  printk(BIOS_DEBUG, \"SMM Module: stub loaded at %p. Will call %p\\n\",",
          "",
          "[Removed Lines]",
          "262:   stub_params->runtime.apic_id_to_cpu[i] = i;",
          "",
          "[Added Lines]",
          "262:   stub_params->apic_id_to_cpu[i] = i;",
          "265:  params->stub_params = stub_params;",
          "",
          "---------------"
        ],
        "src/cpu/x86/smm/smm_module_loaderv2.c||src/cpu/x86/smm/smm_module_loaderv2.c": [
          "File: src/cpu/x86/smm/smm_module_loaderv2.c -> src/cpu/x86/smm/smm_module_loaderv2.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "466:  for (i = 0; i < params->num_concurrent_stacks; i++)",
          "470:  params->runtime = &stub_params->runtime;",
          "472:  printk(BIOS_DEBUG, \"SMM Module: stub loaded at %p. Will call %p\\n\",",
          "",
          "[Removed Lines]",
          "467:   stub_params->runtime.apic_id_to_cpu[i] = i;",
          "",
          "[Added Lines]",
          "467:   stub_params->apic_id_to_cpu[i] = i;",
          "470:  params->stub_params = stub_params;",
          "",
          "---------------"
        ],
        "src/cpu/x86/smm/smm_stub.S||src/cpu/x86/smm/smm_stub.S": [
          "File: src/cpu/x86/smm/smm_stub.S -> src/cpu/x86/smm/smm_stub.S",
          "--- Hunk 1 ---",
          "[Context before]",
          "25: .long 0",
          "26: fxsave_area_size:",
          "27: .long 0",
          "29: smm_runtime:",
          "30: smbase:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "31: apic_to_cpu_num:",
          "32: .fill CONFIG_MAX_CPUS,1,0xff",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "41: start32_offset:",
          "42: .long smm_trampoline32 - _start",
          "50: .data",
          "",
          "[Removed Lines]",
          "46: apic_to_cpu_num:",
          "47: .fill CONFIG_MAX_CPUS,1,0xff",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/include/cpu/x86/smm.h||src/include/cpu/x86/smm.h": [
          "File: src/include/cpu/x86/smm.h -> src/include/cpu/x86/smm.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "62:  u32 gnvs_ptr;",
          "64:  u32 start32_offset;",
          "72: } __packed;",
          "74: struct smm_module_params {",
          "",
          "[Removed Lines]",
          "71:  u8 apic_id_to_cpu[CONFIG_MAX_CPUS];",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "88:  u32 c_handler;",
          "89:  u32 fxsave_area;",
          "90:  u32 fxsave_area_size;",
          "91:  struct smm_runtime runtime;",
          "92: } __packed;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "90:  u8 apic_id_to_cpu[CONFIG_MAX_CPUS];",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "151:  smm_handler_t handler;",
          "153:  struct smm_runtime *runtime;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "153:  struct smm_stub_params *stub_params;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "ad0116c0327f575f0af184a2f4861848a49a0e2a",
      "candidate_info": {
        "commit_hash": "ad0116c0327f575f0af184a2f4861848a49a0e2a",
        "repo": "coreboot/coreboot",
        "commit_url": "https://github.com/coreboot/coreboot/commit/ad0116c0327f575f0af184a2f4861848a49a0e2a",
        "files": [
          "src/cpu/x86/smm/smm_module_loaderv2.c",
          "src/include/cpu/x86/smm.h"
        ],
        "message": "cpu/x86/smm_loaderv2: Remove unused variables\n\nRemove variables that are either constants or are just assigned but\nnot used.\n\nChange-Id: I5d291a3464f30fc5d9f4b7233bde575010275973\nSigned-off-by: Arthur Heymans <arthur@aheymans.xyz>\nReviewed-on: https://review.coreboot.org/c/coreboot/+/50784\nTested-by: build bot (Jenkins) <no-reply@coreboot.org>\nReviewed-by: Angel Pons <th3fanbus@gmail.com>",
        "before_after_code_files": [
          "src/cpu/x86/smm/smm_module_loaderv2.c||src/cpu/x86/smm/smm_module_loaderv2.c",
          "src/include/cpu/x86/smm.h||src/include/cpu/x86/smm.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/cpu/x86/smm/smm_module_loaderv2.c||src/cpu/x86/smm/smm_module_loaderv2.c",
            "src/include/cpu/x86/smm.h||src/include/cpu/x86/smm.h"
          ],
          "candidate": [
            "src/cpu/x86/smm/smm_module_loaderv2.c||src/cpu/x86/smm/smm_module_loaderv2.c",
            "src/include/cpu/x86/smm.h||src/include/cpu/x86/smm.h"
          ]
        }
      },
      "candidate_diff": {
        "src/cpu/x86/smm/smm_module_loaderv2.c||src/cpu/x86/smm/smm_module_loaderv2.c": [
          "File: src/cpu/x86/smm/smm_module_loaderv2.c -> src/cpu/x86/smm/smm_module_loaderv2.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "89:  unsigned int i;",
          "90:  struct rmodule smm_stub;",
          "91:  unsigned int ss_size = params->per_cpu_save_state_size, stub_size;",
          "93:  unsigned int seg_count = 0, segments = 0, available;",
          "94:  unsigned int cpus_in_segment = 0;",
          "95:  unsigned int base = smbase;",
          "",
          "[Removed Lines]",
          "92:  unsigned int smm_entry_offset = params->smm_main_entry_offset;",
          "",
          "[Added Lines]",
          "92:  unsigned int smm_entry_offset = SMM_ENTRY_OFFSET;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "223:  if (cpus[num_cpus].active) {",
          "226:    printk(BIOS_ERR, \"%s: stack encroachment\\n\", __func__);",
          "227:     printk(BIOS_ERR, \"%s: smbase %zx, stack_top %lx\\n\",",
          "228:            __func__, cpus[num_cpus].smbase, stack_top);",
          "",
          "[Removed Lines]",
          "224:   if (cpus[num_cpus - 1].smbase +",
          "225:       params->smm_main_entry_offset < stack_top) {",
          "",
          "[Added Lines]",
          "224:   if (cpus[num_cpus - 1].smbase + SMM_ENTRY_OFFSET < stack_top) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "330: {",
          "331:  size_t total_save_state_size;",
          "332:  size_t smm_stub_size;",
          "334:  char *smm_stub_loc;",
          "335:  void *stacks_top;",
          "336:  size_t size;",
          "",
          "[Removed Lines]",
          "333:  size_t stub_entry_offset;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "366:  size -= total_save_state_size;",
          "370:   printk(BIOS_ERR, \"%s: encroachment over SMM entry point\\n\", __func__);",
          "371:   printk(BIOS_ERR, \"%s: state save size: %zx : smm_entry_offset -> %lx\\n\",",
          "373:   return -1;",
          "374:  }",
          "",
          "[Removed Lines]",
          "369:  if (size <= params->smm_main_entry_offset) {",
          "372:    __func__, size, params->smm_main_entry_offset);",
          "",
          "[Added Lines]",
          "367:  if (size <= SMM_ENTRY_OFFSET) {",
          "370:          __func__, size, (size_t)SMM_ENTRY_OFFSET);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "383:  smm_stub_loc = NULL;",
          "384:  smm_stub_size = rmodule_memory_size(&smm_stub);",
          "392:   printk(BIOS_ERR, \"%s: stub is too big to fit\\n\", __func__);",
          "393:   return -1;",
          "394:  }",
          "",
          "[Removed Lines]",
          "385:  stub_entry_offset = rmodule_entry_offset(&smm_stub);",
          "388:  smm_stub_loc = &base[params->smm_main_entry_offset];",
          "391:  if (smm_stub_size > (size - params->smm_main_entry_offset)) {",
          "",
          "[Added Lines]",
          "385:  smm_stub_loc = &base[SMM_ENTRY_OFFSET];",
          "388:  if (smm_stub_size > (size - SMM_ENTRY_OFFSET)) {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "400:  const size_t total_stack_size = params->num_concurrent_stacks *",
          "401:   params->per_cpu_stack_size;",
          "403:         params);",
          "404:  if (stacks_top == NULL) {",
          "405:   printk(BIOS_ERR, \"%s: not enough space for stacks\\n\", __func__);",
          "",
          "[Removed Lines]",
          "402:  stacks_top = smm_stub_place_stacks((char *)params->smram_start, total_stack_size,",
          "",
          "[Added Lines]",
          "399:  stacks_top = smm_stub_place_stacks(smbase, total_stack_size,",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "474:  if (params->num_concurrent_stacks == 0)",
          "475:   params->num_concurrent_stacks = CONFIG_MAX_CPUS;",
          "480:  return smm_module_setup_stub(smram, SMM_DEFAULT_SIZE,",
          "481:     params, fxsave_area_relocation);",
          "482:  printk(BIOS_SPEW, \"%s: exit\\n\", __func__);",
          "",
          "[Removed Lines]",
          "477:  params->smm_main_entry_offset = SMM_ENTRY_OFFSET;",
          "478:  params->smram_start = SMM_DEFAULT_BASE;",
          "479:  params->smram_end = SMM_DEFAULT_BASE + SMM_DEFAULT_SIZE;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "530:  base = smram;",
          "531:  base += size;",
          "537:  if (rmodule_parse(&_binary_smm_start, &smm_mod))",
          "",
          "[Removed Lines]",
          "532:  params->smram_start = (uintptr_t)smram;",
          "533:  params->smram_end = params->smram_start + size;",
          "534:  params->smm_main_entry_offset = SMM_ENTRY_OFFSET;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "634:  base -= SMM_CODE_SEGMENT_SIZE;",
          "635:  printk(BIOS_DEBUG, \"%s: cpu0 entry: %p\\n\",",
          "636:    __func__, base);",
          "639:  if (!smm_create_map((uintptr_t)base, params->num_concurrent_save_states, params)) {",
          "640:   printk(BIOS_ERR, \"%s: Error creating CPU map\\n\", __func__);",
          "",
          "[Removed Lines]",
          "637:  params->smm_entry = (uintptr_t)base + params->smm_main_entry_offset;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/include/cpu/x86/smm.h||src/include/cpu/x86/smm.h": [
          "File: src/include/cpu/x86/smm.h -> src/include/cpu/x86/smm.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "150:  smm_handler_t handler;",
          "152:  struct smm_stub_params *stub_params;",
          "161: };",
          "",
          "[Removed Lines]",
          "155: #if CONFIG(X86_SMM_LOADER_VERSION2)",
          "156:  uintptr_t smm_entry;",
          "157:  uintptr_t smm_main_entry_offset;",
          "158:  uintptr_t smram_start;",
          "159:  uintptr_t smram_end;",
          "160: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "41b078f8aecd9d01b83ac8ceb646645b8d1c4722",
      "candidate_info": {
        "commit_hash": "41b078f8aecd9d01b83ac8ceb646645b8d1c4722",
        "repo": "coreboot/coreboot",
        "commit_url": "https://github.com/coreboot/coreboot/commit/41b078f8aecd9d01b83ac8ceb646645b8d1c4722",
        "files": [
          "src/cpu/x86/mp_init.c"
        ],
        "message": "cpu/x86/mp_init.c: Don't overwrite the global variable per CPU\n\nGlobal variables are located in .bss and not on the CPU stack.\nOverwriting them a per CPU case is bound to cause race conditions. In\nthis case it is even just plainly wrong.\n\nNote: This variable is set up in the get_smm_info() function.\n\nChange-Id: Iaef26fa996f7e30b6e4c4941683026b8a29a5fd1\nSigned-off-by: Arthur Heymans <arthur@aheymans.xyz>\nReviewed-on: https://review.coreboot.org/c/coreboot/+/51184\nTested-by: build bot (Jenkins) <no-reply@coreboot.org>\nReviewed-by: Angel Pons <th3fanbus@gmail.com>",
        "before_after_code_files": [
          "src/cpu/x86/mp_init.c||src/cpu/x86/mp_init.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/cpu/x86/mp_init.c||src/cpu/x86/mp_init.c"
          ],
          "candidate": [
            "src/cpu/x86/mp_init.c||src/cpu/x86/mp_init.c"
          ]
        }
      },
      "candidate_diff": {
        "src/cpu/x86/mp_init.c||src/cpu/x86/mp_init.c": [
          "File: src/cpu/x86/mp_init.c -> src/cpu/x86/mp_init.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "733: #if CONFIG(X86_SMM_LOADER_VERSION2)",
          "734:  perm_smbase = smm_get_cpu_smbase(cpu);",
          "736:  if (!perm_smbase) {",
          "737:   printk(BIOS_ERR, \"%s: bad SMBASE for CPU %d\\n\", __func__, cpu);",
          "738:   return;",
          "",
          "[Removed Lines]",
          "735:  mp_state.perm_smbase = perm_smbase;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "dfff5c2d193066adff8e0bee9ed4525b622eb7c8",
      "candidate_info": {
        "commit_hash": "dfff5c2d193066adff8e0bee9ed4525b622eb7c8",
        "repo": "coreboot/coreboot",
        "commit_url": "https://github.com/coreboot/coreboot/commit/dfff5c2d193066adff8e0bee9ed4525b622eb7c8",
        "files": [
          "src/cpu/x86/smm/smm_module_loaderv2.c"
        ],
        "message": "cpu/x86/smm_loaderv2: Fix when only 1 CPU is present\n\nMove out smm_create_map as this was not run if concurrent_save_states\nis 1. The cpus struct array is used in the smm_get_cpu_smbase()\ncallback so it is necessary to create this.\n\nTEST: run qemu/q35 with -smp 1 (or no -smp argument)\n\nChange-Id: I07a98bbc9ff6dce548171ee6cd0c303db94087aa\nSigned-off-by: Arthur Heymans <arthur@aheymans.xyz>\nReviewed-on: https://review.coreboot.org/c/coreboot/+/50783\nReviewed-by: Angel Pons <th3fanbus@gmail.com>\nTested-by: build bot (Jenkins) <no-reply@coreboot.org>",
        "before_after_code_files": [
          "src/cpu/x86/smm/smm_module_loaderv2.c||src/cpu/x86/smm/smm_module_loaderv2.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/cpu/x86/smm/smm_module_loaderv2.c||src/cpu/x86/smm/smm_module_loaderv2.c"
          ],
          "candidate": [
            "src/cpu/x86/smm/smm_module_loaderv2.c||src/cpu/x86/smm/smm_module_loaderv2.c"
          ]
        }
      },
      "candidate_diff": {
        "src/cpu/x86/smm/smm_module_loaderv2.c||src/cpu/x86/smm/smm_module_loaderv2.c": [
          "File: src/cpu/x86/smm/smm_module_loaderv2.c -> src/cpu/x86/smm/smm_module_loaderv2.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "214: {",
          "215:  unsigned int i;",
          "216:  unsigned int size;",
          "227:     printk(BIOS_ERR, \"%s: smbase %zx, stack_top %lx\\n\",",
          "229:     return 0;",
          "231:   }",
          "235:  }",
          "237:  printk(BIOS_INFO, \"%s: smbase %zx, stack_top %lx\\n\",",
          "",
          "[Removed Lines]",
          "217:  if (smm_create_map(smbase, num_cpus, params)) {",
          "223:   if (cpus[num_cpus].active) {",
          "224:    if (cpus[num_cpus - 1].smbase +",
          "225:     params->smm_main_entry_offset < stack_top) {",
          "226:     printk(BIOS_ERR, \"%s: stack encroachment\\n\", __func__);",
          "228:      __func__, cpus[num_cpus].smbase, stack_top);",
          "230:    }",
          "232:  } else {",
          "233:   printk(BIOS_ERR, \"%s: unable to place smm entry code\\n\", __func__);",
          "234:   return 0;",
          "",
          "[Added Lines]",
          "223:  if (cpus[num_cpus].active) {",
          "224:   if (cpus[num_cpus - 1].smbase +",
          "225:       params->smm_main_entry_offset < stack_top) {",
          "226:    printk(BIOS_ERR, \"%s: stack encroachment\\n\", __func__);",
          "228:            __func__, cpus[num_cpus].smbase, stack_top);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "639:  printk(BIOS_DEBUG, \"%s: cpu0 entry: %p\\n\",",
          "640:    __func__, base);",
          "641:  params->smm_entry = (uintptr_t)base + params->smm_main_entry_offset;",
          "642:  return smm_module_setup_stub(base, size, params, fxsave_area);",
          "643: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "639:  if (!smm_create_map((uintptr_t)base, params->num_concurrent_save_states, params)) {",
          "640:   printk(BIOS_ERR, \"%s: Error creating CPU map\\n\", __func__);",
          "641:   return -1;",
          "642:  }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
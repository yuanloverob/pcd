{
  "cve_id": "CVE-2020-36177",
  "cve_desc": "RsaPad_PSS in wolfcrypt/src/rsa.c in wolfSSL before 4.6.0 has an out-of-bounds write for certain relationships between key size and digest size.",
  "repo": "wolfSSL/wolfssl",
  "patch_hash": "fb2288c46dd4c864b78f00a47a364b96a09a5c0f",
  "patch_info": {
    "commit_hash": "fb2288c46dd4c864b78f00a47a364b96a09a5c0f",
    "repo": "wolfSSL/wolfssl",
    "commit_url": "https://github.com/wolfSSL/wolfssl/commit/fb2288c46dd4c864b78f00a47a364b96a09a5c0f",
    "files": [
      "wolfcrypt/src/rsa.c"
    ],
    "message": "RSA-PSS: Handle edge case with encoding message to hash\n\nWhen the key is small relative to the digest (1024-bit key, 64-byte\nhash, 61-byte salt length), the internal message to hash is larger than\nthe output size.\nAllocate a buffer for the message when this happens.",
    "before_after_code_files": [
      "wolfcrypt/src/rsa.c||wolfcrypt/src/rsa.c"
    ]
  },
  "patch_diff": {
    "wolfcrypt/src/rsa.c||wolfcrypt/src/rsa.c": [
      "File: wolfcrypt/src/rsa.c -> wolfcrypt/src/rsa.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1116:     int   hLen, i, o, maskLen, hiBits;",
      "1117:     byte* m;",
      "1118:     byte* s;",
      "1119: #if defined(WOLFSSL_PSS_LONG_SALT) || defined(WOLFSSL_PSS_SALT_LEN_DISCOVER)",
      "1125: #else",
      "1126:     byte salt[WC_MAX_DIGEST_SIZE];",
      "1127: #endif",
      "",
      "[Removed Lines]",
      "1120:     #if defined(WOLFSSL_NO_MALLOC) && !defined(WOLFSSL_STATIC_MEMORY)",
      "1121:         byte salt[RSA_MAX_SIZE/8 + RSA_PSS_PAD_SZ];",
      "1122:     #else",
      "1123:         byte* salt = NULL;",
      "1124:     #endif",
      "",
      "[Added Lines]",
      "1119: #if defined(WOLFSSL_NO_MALLOC) && !defined(WOLFSSL_STATIC_MEMORY)",
      "1120:     byte msg[RSA_MAX_SIZE/8 + RSA_PSS_PAD_SZ];",
      "1121: #else",
      "1122:     byte* msg = NULL;",
      "1123: #endif",
      "1125:     byte* salt;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1185: #if defined(WOLFSSL_PSS_LONG_SALT) || defined(WOLFSSL_PSS_SALT_LEN_DISCOVER)",
      "1186:     #if !defined(WOLFSSL_NO_MALLOC) || defined(WOLFSSL_STATIC_MEMORY)",
      "1188:                                                        DYNAMIC_TYPE_RSA_BUFFER);",
      "1190:             return MEMORY_E;",
      "1191:         }",
      "1192:     #endif",
      "1194:     XMEMSET(m, 0, RSA_PSS_PAD_SZ);",
      "1195:     m += RSA_PSS_PAD_SZ;",
      "1196:     XMEMCPY(m, input, inputLen);",
      "",
      "[Removed Lines]",
      "1187:         salt = (byte*)XMALLOC(RSA_PSS_PAD_SZ + inputLen + saltLen, heap,",
      "1189:         if (salt == NULL) {",
      "1193:     s = m = salt;",
      "",
      "[Added Lines]",
      "1188:         msg = (byte*)XMALLOC(RSA_PSS_PAD_SZ + inputLen + saltLen, heap,",
      "1190:         if (msg == NULL) {",
      "1194:     salt = s = m = msg;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1203:         }",
      "1204:     }",
      "1205: #else",
      "1207:     XMEMSET(m, 0, RSA_PSS_PAD_SZ);",
      "1208:     m += RSA_PSS_PAD_SZ;",
      "1209:     XMEMCPY(m, input, inputLen);",
      "",
      "[Removed Lines]",
      "1206:     s = m = pkcsBlock;",
      "",
      "[Added Lines]",
      "1207:     if (pkcsBlockLen < RSA_PSS_PAD_SZ + inputLen + saltLen) {",
      "1208:     #if !defined(WOLFSSL_NO_MALLOC) || defined(WOLFSSL_STATIC_MEMORY)",
      "1209:         msg = (byte*)XMALLOC(RSA_PSS_PAD_SZ + inputLen + saltLen, heap,",
      "1210:                                                        DYNAMIC_TYPE_RSA_BUFFER);",
      "1211:         if (msg == NULL) {",
      "1212:             return MEMORY_E;",
      "1213:         }",
      "1214:     #endif",
      "1215:         m = msg;",
      "1216:     }",
      "1217:     else {",
      "1218:         m = pkcsBlock;",
      "1219:     }",
      "1220:     s = m;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "1240:         }",
      "1241:     }",
      "1244:     #if !defined(WOLFSSL_NO_MALLOC) || defined(WOLFSSL_STATIC_MEMORY)",
      "1247:         }",
      "1248:     #endif",
      "1250:     return ret;",
      "1251: }",
      "",
      "[Removed Lines]",
      "1243: #if defined(WOLFSSL_PSS_LONG_SALT) || defined(WOLFSSL_PSS_SALT_LEN_DISCOVER)",
      "1245:         if (salt != NULL) {",
      "1246:             XFREE(salt, heap, DYNAMIC_TYPE_RSA_BUFFER);",
      "1249: #endif",
      "",
      "[Added Lines]",
      "1258:         if (msg != NULL) {",
      "1259:             XFREE(msg, heap, DYNAMIC_TYPE_RSA_BUFFER);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "2c6285ccbadbccf4c7e486be4b933fc394c46f59",
      "candidate_info": {
        "commit_hash": "2c6285ccbadbccf4c7e486be4b933fc394c46f59",
        "repo": "wolfSSL/wolfssl",
        "commit_url": "https://github.com/wolfSSL/wolfssl/commit/2c6285ccbadbccf4c7e486be4b933fc394c46f59",
        "files": [
          "IDE/Espressif/ESP-IDF/examples/wolfssl_benchmark/main/helper.c",
          "IDE/MDK-ARM/MDK-ARM/wolfSSL/wolfssl_MDK_ARM.c",
          "IDE/zephyr/wolfssl_tls_sock/src/tls_sock.c",
          "examples/echoclient/echoclient.c",
          "mcapi/mcapi_test.c",
          "src/bio.c",
          "src/internal.c",
          "src/ssl.c",
          "src/tls.c",
          "src/tls13.c",
          "tests/api.c",
          "wolfcrypt/src/asn.c",
          "wolfcrypt/src/curve25519.c",
          "wolfcrypt/src/des3.c",
          "wolfcrypt/src/ecc.c",
          "wolfcrypt/src/eccsi.c",
          "wolfcrypt/src/evp.c",
          "wolfcrypt/src/integer.c",
          "wolfcrypt/src/pkcs12.c",
          "wolfcrypt/src/port/ti/ti-hash.c",
          "wolfcrypt/src/random.c",
          "wolfcrypt/src/rsa.c",
          "wolfcrypt/src/sakke.c",
          "wolfcrypt/src/srp.c",
          "wolfcrypt/src/wc_port.c",
          "wolfcrypt/test/test.c",
          "wolfcrypt/user-crypto/src/rsa.c"
        ],
        "message": "cppcheck: fixes from reviewing report",
        "before_after_code_files": [
          "IDE/Espressif/ESP-IDF/examples/wolfssl_benchmark/main/helper.c||IDE/Espressif/ESP-IDF/examples/wolfssl_benchmark/main/helper.c",
          "IDE/MDK-ARM/MDK-ARM/wolfSSL/wolfssl_MDK_ARM.c||IDE/MDK-ARM/MDK-ARM/wolfSSL/wolfssl_MDK_ARM.c",
          "IDE/zephyr/wolfssl_tls_sock/src/tls_sock.c||IDE/zephyr/wolfssl_tls_sock/src/tls_sock.c",
          "examples/echoclient/echoclient.c||examples/echoclient/echoclient.c",
          "mcapi/mcapi_test.c||mcapi/mcapi_test.c",
          "src/bio.c||src/bio.c",
          "src/internal.c||src/internal.c",
          "src/ssl.c||src/ssl.c",
          "src/tls.c||src/tls.c",
          "src/tls13.c||src/tls13.c",
          "tests/api.c||tests/api.c",
          "wolfcrypt/src/asn.c||wolfcrypt/src/asn.c",
          "wolfcrypt/src/curve25519.c||wolfcrypt/src/curve25519.c",
          "wolfcrypt/src/des3.c||wolfcrypt/src/des3.c",
          "wolfcrypt/src/ecc.c||wolfcrypt/src/ecc.c",
          "wolfcrypt/src/eccsi.c||wolfcrypt/src/eccsi.c",
          "wolfcrypt/src/evp.c||wolfcrypt/src/evp.c",
          "wolfcrypt/src/integer.c||wolfcrypt/src/integer.c",
          "wolfcrypt/src/pkcs12.c||wolfcrypt/src/pkcs12.c",
          "wolfcrypt/src/port/ti/ti-hash.c||wolfcrypt/src/port/ti/ti-hash.c",
          "wolfcrypt/src/random.c||wolfcrypt/src/random.c",
          "wolfcrypt/src/rsa.c||wolfcrypt/src/rsa.c",
          "wolfcrypt/src/sakke.c||wolfcrypt/src/sakke.c",
          "wolfcrypt/src/srp.c||wolfcrypt/src/srp.c",
          "wolfcrypt/src/wc_port.c||wolfcrypt/src/wc_port.c",
          "wolfcrypt/test/test.c||wolfcrypt/test/test.c",
          "wolfcrypt/user-crypto/src/rsa.c||wolfcrypt/user-crypto/src/rsa.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "wolfcrypt/src/rsa.c||wolfcrypt/src/rsa.c"
          ],
          "candidate": [
            "wolfcrypt/src/rsa.c||wolfcrypt/src/rsa.c"
          ]
        }
      },
      "candidate_diff": {
        "IDE/Espressif/ESP-IDF/examples/wolfssl_benchmark/main/helper.c||IDE/Espressif/ESP-IDF/examples/wolfssl_benchmark/main/helper.c": [
          "File: IDE/Espressif/ESP-IDF/examples/wolfssl_benchmark/main/helper.c -> IDE/Espressif/ESP-IDF/examples/wolfssl_benchmark/main/helper.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "119:     __argv[cnt] = malloc(10);",
          "120:     sprintf(__argv[cnt], \"benchmark\");",
          "122:     cnt = 1;",
          "124:     while (*ch != '\\0')",
          "",
          "[Removed Lines]",
          "121:     __argv[9] = '\\0';",
          "",
          "[Added Lines]",
          "121:     __argv[cnt][9] = '\\0';",
          "",
          "---------------"
        ],
        "IDE/MDK-ARM/MDK-ARM/wolfSSL/wolfssl_MDK_ARM.c||IDE/MDK-ARM/MDK-ARM/wolfSSL/wolfssl_MDK_ARM.c": [
          "File: IDE/MDK-ARM/MDK-ARM/wolfSSL/wolfssl_MDK_ARM.c -> IDE/MDK-ARM/MDK-ARM/wolfSSL/wolfssl_MDK_ARM.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "197:     #define PATHSIZE 100",
          "198:     char path[PATHSIZE] ; char *p ;",
          "200:     if(strlen(name) > PATHSIZE)return(NULL) ;",
          "202:     for(i = 0; i<= strlen(name); i++) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "200:     if (name == NULL) return NULL;",
          "",
          "---------------"
        ],
        "IDE/zephyr/wolfssl_tls_sock/src/tls_sock.c||IDE/zephyr/wolfssl_tls_sock/src/tls_sock.c": [
          "File: IDE/zephyr/wolfssl_tls_sock/src/tls_sock.c -> IDE/zephyr/wolfssl_tls_sock/src/tls_sock.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "323:     if (ret == 0) {",
          "325:         tcp_set_nonblocking(&clientfd);",
          "329:         printf(\"Server has client\\n\");",
          "330:         if (wolfSSL_set_fd(ssl, clientfd) != WOLFSSL_SUCCESS)",
          "331:             ret = -1;",
          "",
          "[Removed Lines]",
          "326:     }",
          "328:     if (ret == 0) {",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "examples/echoclient/echoclient.c||examples/echoclient/echoclient.c": [
          "File: examples/echoclient/echoclient.c -> examples/echoclient/echoclient.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "89:     int argc    = 0;",
          "90:     char** argv = 0;",
          "91: #endif",
          "93:     char buffer[CYASSL_MAX_ERROR_SZ];",
          "",
          "[Removed Lines]",
          "92:     word16 port = yasslPort;",
          "",
          "[Added Lines]",
          "92:     word16 port;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "127: #if defined(NO_MAIN_DRIVER) && !defined(USE_WINDOWS_API) && !defined(WOLFSSL_MDK_SHELL)",
          "128:     port = ((func_args*)args)->signal->port;",
          "129: #endif",
          "131: #if defined(CYASSL_DTLS)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "129: #else",
          "130:     port = yasslPort;",
          "",
          "---------------"
        ],
        "mcapi/mcapi_test.c||mcapi/mcapi_test.c": [
          "File: mcapi/mcapi_test.c -> mcapi/mcapi_test.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "238:         return -1;",
          "239:     }",
          "242:         printf(\"md5 final memcmp failed\\n\");",
          "243:         return -1;",
          "244:     }",
          "",
          "[Removed Lines]",
          "241:     if (ret == 0 && memcmp(mcDigest, defDigest, CRYPT_MD5_DIGEST_SIZE) != 0) {",
          "",
          "[Added Lines]",
          "241:     if (memcmp(mcDigest, defDigest, CRYPT_MD5_DIGEST_SIZE) != 0) {",
          "",
          "---------------"
        ],
        "src/bio.c||src/bio.c": [
          "File: src/bio.c -> src/bio.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "230:                 if (bio->ptr) {",
          "231:                     ret = (int)XFREAD(buf, 1, len, (XFILE)bio->ptr);",
          "232:                 }",
          "233:                 #if !defined(USE_WINDOWS_API) && !defined(NO_WOLFSSL_DIR) && \\",
          "234:                     !defined(WOLFSSL_NUCLEUS) && !defined(WOLFSSL_NUCLEUS_1_2)",
          "236:                     ret = (int)XREAD(bio->num, buf, len);",
          "238:                 #else",
          "241:                 #endif",
          "242:             #else",
          "243:                 WOLFSSL_MSG(\"WOLFSSL_BIO_FILE used with NO_FILESYSTEM\");",
          "244:                 ret = NOT_COMPILED_IN;",
          "",
          "[Removed Lines]",
          "235:                 else {",
          "237:                 }",
          "239:                 WOLFSSL_MSG(\"No file pointer and XREAD not enabled\");",
          "240:                 ret = NOT_COMPILED_IN;",
          "",
          "[Added Lines]",
          "233:                 else {",
          "238:                     WOLFSSL_MSG(\"No file pointer and XREAD not enabled\");",
          "239:                     ret = NOT_COMPILED_IN;",
          "241:                 }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "541: int wolfSSL_BIO_write(WOLFSSL_BIO* bio, const void* data, int len)",
          "542: {",
          "543:     int ret = 0;",
          "546:     int retB64 = 0;",
          "547:     WOLFSSL_BIO* front = bio;",
          "548:     void* frmt = NULL;",
          "549:     word32 frmtSz = 0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "544: #ifdef WOLFSSL_BASE64_ENCODE",
          "548: #endif",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "594:                 if (bio->ptr) {",
          "595:                     ret = (int)XFWRITE(data, 1, len, (XFILE)bio->ptr);",
          "596:                 }",
          "597:                 #if !defined(USE_WINDOWS_API) && !defined(NO_WOLFSSL_DIR) && \\",
          "598:                     !defined(WOLFSSL_NUCLEUS) && !defined(WOLFSSL_NUCLEUS_1_2)",
          "600:                     ret = (int)XWRITE(bio->num, data, len);",
          "602:                 #else",
          "605:                 #endif",
          "606:             #else",
          "607:                 WOLFSSL_MSG(\"WOLFSSL_BIO_FILE used with NO_FILESYSTEM\");",
          "608:                 ret = NOT_COMPILED_IN;",
          "",
          "[Removed Lines]",
          "599:                 else {",
          "601:                 }",
          "603:                 WOLFSSL_MSG(\"No file pointer and XWRITE not enabled\");",
          "604:                 ret = NOT_COMPILED_IN;",
          "",
          "[Added Lines]",
          "599:                 else {",
          "604:                     WOLFSSL_MSG(\"No file pointer and XWRITE not enabled\");",
          "605:                     ret = NOT_COMPILED_IN;",
          "607:                 }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "659:         XFREE(frmt, front->heap, DYNAMIC_TYPE_TMP_BUFFER);",
          "660:     }",
          "662:     if (retB64 > 0 && ret > 0)",
          "663:         return retB64;",
          "664:     else",
          "665:         return ret;",
          "666: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "664: #ifdef WOLFSSL_BASE64_ENCODE",
          "668: #endif",
          "",
          "---------------"
        ],
        "src/internal.c||src/internal.c": [
          "File: src/internal.c -> src/internal.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1715:     ctx->minEccKeySz  = MIN_ECCKEY_SZ;",
          "1716:     ctx->eccTempKeySz = ECDHE_SIZE;",
          "1717: #endif",
          "1719:     ctx->verifyDepth = MAX_CHAIN_DEPTH;",
          "1721: #ifdef OPENSSL_EXTRA",
          "1722:     ctx->cbioFlag = WOLFSSL_CBIO_NONE;",
          "1723: #endif",
          "",
          "[Removed Lines]",
          "1718: #if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)",
          "1720: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1866:     ctx->ticketHint = SESSION_TICKET_HINT_DEFAULT;",
          "1867: #endif",
          "1874: #ifdef WOLFSSL_EARLY_DATA",
          "1875:     ctx->maxEarlyDataSz = MAX_EARLY_DATA_SZ;",
          "1876: #endif",
          "",
          "[Removed Lines]",
          "1869: #ifdef HAVE_WOLF_EVENT",
          "1870:     if (ret == 0)",
          "1871:         ret = wolfEventQueue_Init(&ctx->event_queue);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1880: #endif",
          "1885:     return ret;",
          "1886: }",
          "",
          "[Removed Lines]",
          "1883:     ctx->verifyDepth = MAX_CHAIN_DEPTH;",
          "",
          "[Added Lines]",
          "1877: #ifdef HAVE_WOLF_EVENT",
          "1878:     ret = wolfEventQueue_Init(&ctx->event_queue);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "5848: #elif defined (WOLFSSL_GNRC)",
          "5849:     ssl->IOCB_ReadCtx = ssl->gnrcCtx;",
          "5850:     ssl->IOCB_WriteCtx = ssl->gnrcCtx;",
          "5851: #endif",
          "5853:     ssl->options.serverState = NULL_STATE;",
          "5854:     ssl->options.clientState = NULL_STATE;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5844: #else",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "6256:             return BAD_FUNC_ARG;",
          "6257:     }",
          "6265:     if (*pKey == NULL) {",
          "",
          "[Removed Lines]",
          "6259:     if (sz == 0) {",
          "6260:         return NOT_COMPILED_IN;",
          "6261:     }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "8557:        the header, if the user wants encrypted alignment they need",
          "8564: #endif",
          "8566:     tmp = (byte*)XMALLOC(size + ssl->buffers.outputBuffer.length + align,",
          "",
          "[Removed Lines]",
          "8560:     if (align) {",
          "8561:        while (align < hdrSz)",
          "8562:            align *= 2;",
          "8563:     }",
          "",
          "[Added Lines]",
          "8553:     while (align < hdrSz)",
          "8554:         align *= 2;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "11776:                         if (args->dCert->version != WOLFSSL_X509_V3) {",
          "11777:                             WOLFSSL_MSG(\"Peers certificate was not version 3!\");",
          "11778:                             args->lastErr = ASN_VERSION_E;",
          "",
          "[Removed Lines]",
          "11774:                     if ((ret == 0) &&",
          "11775:                             (ssl->options.side == WOLFSSL_SERVER_END)) {",
          "",
          "[Added Lines]",
          "11765:                     if (ssl->options.side == WOLFSSL_SERVER_END) {",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "17048:              int epochOrder)",
          "17049: {",
          "17050: #ifndef WOLFSSL_NO_TLS12",
          "17052:     BuildMsgArgs* args;",
          "17053:     BuildMsgArgs  lcl_args;",
          "17054: #ifdef WOLFSSL_ASYNC_CRYPT",
          "",
          "[Removed Lines]",
          "17051:     int ret = 0;",
          "",
          "[Added Lines]",
          "17041:     int ret;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "17075:     }",
          "17076: #endif",
          "17079: #ifdef WOLFSSL_ASYNC_CRYPT",
          "17080:     if (asyncOkay) {",
          "17081:         ret = wolfSSL_AsyncPop(ssl, &ssl->options.buildMsgState);",
          "17082:         if (ret != WC_NOT_PENDING_E) {",
          "",
          "[Removed Lines]",
          "17078:     ret = WC_NOT_PENDING_E;",
          "",
          "[Added Lines]",
          "17069:     ret = WC_NOT_PENDING_E;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "17092:     }",
          "17096:         ret = 0;",
          "17097:         ssl->options.buildMsgState = BUILD_MSG_BEGIN;",
          "17098:         XMEMSET(args, 0, sizeof(BuildMsgArgs));",
          "",
          "[Removed Lines]",
          "17095:     if (ret == WC_NOT_PENDING_E) {",
          "",
          "[Added Lines]",
          "17085: #ifdef WOLFSSL_ASYNC_CRYPT",
          "17086:     if (ret == WC_NOT_PENDING_E)",
          "17087: #endif",
          "17088:     {",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "18585:         sendSz,",
          "18586:         ret;",
          "18587:     int groupMsgs = 0;",
          "18589:     if (ssl->error == WANT_WRITE",
          "18590:     #ifdef WOLFSSL_ASYNC_CRYPT",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "18580: #if defined(WOLFSSL_EARLY_DATA) && defined(WOLFSSL_EARLY_DATA_GROUP)",
          "18582: #endif",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "18635:     }",
          "18639:         WOLFSSL_MSG(\"output buffer was full, trying to send again\");",
          "18640:         if ( (ssl->error = SendBuffered(ssl)) < 0) {",
          "18641:             WOLFSSL_ERROR(ssl->error);",
          "",
          "[Removed Lines]",
          "18638:     if (!groupMsgs && ssl->buffers.outputBuffer.length > 0) {",
          "",
          "[Added Lines]",
          "18633:     if (ssl->buffers.outputBuffer.length > 0",
          "18634:     #if defined(WOLFSSL_EARLY_DATA) && defined(WOLFSSL_EARLY_DATA_GROUP)",
          "18635:         && !groupMsgs",
          "18636:     #endif",
          "18637:         ) {",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "21973:     int VerifyClientSuite(WOLFSSL* ssl)",
          "21974:     {",
          "21976:         byte first   = ssl->options.cipherSuite0;",
          "21977:         byte second  = ssl->options.cipherSuite;",
          "21979:         WOLFSSL_ENTER(\"VerifyClientSuite\");",
          "21985:         if (CipherRequires(first, second, REQUIRES_PSK)) {",
          "21986:             WOLFSSL_MSG(\"Requires PSK\");",
          "21988:                 WOLFSSL_MSG(\"Don't have PSK\");",
          "21989:                 return 0;",
          "21990:             }",
          "",
          "[Removed Lines]",
          "21975:         int  havePSK = 0;",
          "21981:         #ifndef NO_PSK",
          "21982:             havePSK = ssl->options.havePSK;",
          "21983:         #endif",
          "21987:             if (havePSK == 0) {",
          "",
          "[Added Lines]",
          "21974:     #ifndef NO_PSK",
          "21975:         int  havePSK = ssl->options.havePSK;",
          "21976:     #endif",
          "21984:         #ifndef NO_PSK",
          "21985:             if (havePSK == 0)",
          "21986:         #endif",
          "21987:             {",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "24191:         case TLS_ASYNC_BUILD:",
          "24192:         {",
          "24193:             args->encSz = MAX_ENCRYPT_SZ;",
          "24195:                                                     DYNAMIC_TYPE_SECRET);",
          "24196:             if (args->encSecret == NULL) {",
          "24197:                 ERROR_OUT(MEMORY_E, exit_scke);",
          "",
          "[Removed Lines]",
          "24194:             args->encSecret = (byte*)XMALLOC(args->encSz, ssl->heap,",
          "",
          "[Added Lines]",
          "24194:             args->encSecret = (byte*)XMALLOC(MAX_ENCRYPT_SZ, ssl->heap,",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "25277:             ssl->buffers.sig.length = MAX_ENCODED_SIG_SZ;",
          "25279:                                         ssl->heap, DYNAMIC_TYPE_SIGNATURE);",
          "25280:             if (ssl->buffers.sig.buffer == NULL) {",
          "25281:                 ERROR_OUT(MEMORY_E, exit_scv);",
          "",
          "[Removed Lines]",
          "25278:             ssl->buffers.sig.buffer = (byte*)XMALLOC(ssl->buffers.sig.length,",
          "",
          "[Added Lines]",
          "25278:             ssl->buffers.sig.buffer = (byte*)XMALLOC(MAX_ENCODED_SIG_SZ,",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "25325:             }",
          "25326:         #ifndef NO_OLD_TLS",
          "25327:             else {",
          "25329:                 XMEMCPY(ssl->buffers.sig.buffer,",
          "25331:             }",
          "25332:         #endif",
          "",
          "[Removed Lines]",
          "25330:                     (byte*)ssl->hsHashes->certHashes.md5, FINISHED_SZ);",
          "",
          "[Added Lines]",
          "25331:                                 (byte*)&ssl->hsHashes->certHashes, FINISHED_SZ);",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "25817:         word32 idx = RECORD_HEADER_SZ + HANDSHAKE_HEADER_SZ;",
          "25818:         int    sendSz;",
          "25819:         byte   sessIdSz = ID_LEN;",
          "25823:         WOLFSSL_START(WC_FUNC_SERVER_HELLO_SEND);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "25821:     #if defined(HAVE_TLS_EXTENSIONS) && defined(HAVE_SESSION_TICKET)",
          "25823:     #endif",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "25867:             sessIdSz = 0;",
          "25868:         }",
          "",
          "[Removed Lines]",
          "25865:         if (echoId == 0 && cacheOff == 1) {",
          "",
          "[Added Lines]",
          "25868:         if (cacheOff == 1",
          "25869:         #if defined(HAVE_TLS_EXTENSIONS) && defined(HAVE_SESSION_TICKET)",
          "25870:             && echoId == 0",
          "25871:         #endif",
          "25872:             ) {",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "26547:                         args->length = ENUM_LEN + CURVE_LEN + ENUM_LEN;",
          "26549:                         args->exportSz = MAX_EXPORT_ECC_SZ;",
          "26551:                                             ssl->heap, DYNAMIC_TYPE_DER);",
          "26552:                         if (args->exportBuf == NULL) {",
          "26553:                             ERROR_OUT(MEMORY_E, exit_sske);",
          "",
          "[Removed Lines]",
          "26550:                         args->exportBuf = (byte*)XMALLOC(args->exportSz,",
          "",
          "[Added Lines]",
          "26557:                         args->exportBuf = (byte*)XMALLOC(MAX_EXPORT_ECC_SZ,",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "26658:                         args->exportSz = MAX_EXPORT_ECC_SZ;",
          "26660:                                             ssl->heap, DYNAMIC_TYPE_DER);",
          "26661:                         if (args->exportBuf == NULL) {",
          "26662:                             ERROR_OUT(MEMORY_E, exit_sske);",
          "",
          "[Removed Lines]",
          "26659:                         args->exportBuf = (byte*)XMALLOC(args->exportSz,",
          "",
          "[Added Lines]",
          "26666:                         args->exportBuf = (byte*)XMALLOC(MAX_EXPORT_ECC_SZ,",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "27635:     static int VerifyServerSuite(WOLFSSL* ssl, word16 idx)",
          "27636:     {",
          "27637:         int  haveRSA = !ssl->options.haveStaticECC;",
          "27639:         byte first;",
          "27640:         byte second;",
          "",
          "[Removed Lines]",
          "27638:         int  havePSK = 0;",
          "",
          "[Added Lines]",
          "27645:     #ifndef NO_PSK",
          "27646:         int  havePSK = ssl->options.havePSK;",
          "27647:     #endif",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "27649:         first   = ssl->suites->suites[idx];",
          "27650:         second  = ssl->suites->suites[idx+1];",
          "27656:         if (ssl->options.haveNTRU)",
          "27657:             haveRSA = 0;",
          "",
          "[Removed Lines]",
          "27652:         #ifndef NO_PSK",
          "27653:             havePSK = ssl->options.havePSK;",
          "27654:         #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "27691:         if (CipherRequires(first, second, REQUIRES_PSK)) {",
          "27692:             WOLFSSL_MSG(\"Requires PSK\");",
          "27694:                 WOLFSSL_MSG(\"Don't have PSK\");",
          "27695:                 return 0;",
          "27696:             }",
          "",
          "[Removed Lines]",
          "27693:             if (havePSK == 0) {",
          "",
          "[Added Lines]",
          "27698:         #ifndef NO_PSK",
          "27699:             if (havePSK == 0)",
          "27700:         #endif",
          "27701:             {",
          "",
          "---------------"
        ],
        "src/ssl.c||src/ssl.c": [
          "File: src/ssl.c -> src/ssl.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2123:     WOLFSSL_ENTER(\"wolfSSL_read()\");",
          "2125:     #ifdef OPENSSL_EXTRA",
          "2126:     if (ssl->CBIS != NULL) {",
          "2127:         ssl->CBIS(ssl, SSL_CB_READ, WOLFSSL_SUCCESS);",
          "2128:         ssl->cbmode = SSL_CB_READ;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2126:     if (ssl == NULL) {",
          "2127:         return BAD_FUNC_ARG;",
          "2128:     }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2837:         #endif",
          "2838:     }",
          "2840:     if (ret == WOLFSSL_SUCCESS)",
          "2841:         ret = _Rehandshake(ssl);",
          "2843:     return ret;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2843: #ifdef HAVE_SESSION_TICKET",
          "2845: #endif",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "8287:         if (ret == 0 && der.keyOID == RSAk) {",
          "8288:             ret = wc_CryptoCb_RsaCheckPrivKey((RsaKey*)pkey, der.publicKey,",
          "8289:                                               der.pubKeySize);",
          "8291:                 ret = WOLFSSL_SUCCESS;",
          "8292:             wc_FreeRsaKey((RsaKey*)pkey);",
          "8293:         }",
          "",
          "[Removed Lines]",
          "8290:             if (ret == 0 && ret != CRYPTOCB_UNAVAILABLE)",
          "",
          "[Added Lines]",
          "8295:             if (ret == 0)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "8296:         if (ret == 0 && der.keyOID == ECDSAk) {",
          "8297:             ret = wc_CryptoCb_EccCheckPrivKey((ecc_key*)pkey, der.publicKey,",
          "8298:                                               der.pubKeySize);",
          "8300:                 ret = WOLFSSL_SUCCESS;",
          "8301:             wc_ecc_free((ecc_key*)pkey);",
          "8302:         }",
          "",
          "[Removed Lines]",
          "8299:             if (ret == 0 && ret != CRYPTOCB_UNAVAILABLE)",
          "",
          "[Added Lines]",
          "8304:             if (ret == 0)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "13793: int SetSession(WOLFSSL* ssl, WOLFSSL_SESSION* session)",
          "13794: {",
          "13796:         return WOLFSSL_FAILURE;",
          "13798: #ifdef OPENSSL_EXTRA",
          "",
          "[Removed Lines]",
          "13795:     if (ssl->options.sessionCacheOff)",
          "",
          "[Added Lines]",
          "13800:     if (ssl == NULL || ssl->options.sessionCacheOff)",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "16746: #endif",
          "16752:         return WOLFSSL_SUCCESS;",
          "16753: }",
          "",
          "[Removed Lines]",
          "16749:     if (ret == NULL)",
          "16750:         return WOLFSSL_FAILURE;",
          "16751:     else",
          "",
          "[Added Lines]",
          "16754: #ifdef HAVE_ECC",
          "16755:     if (ret != NULL)",
          "16757:     else",
          "16758: #endif",
          "16759:         return WOLFSSL_FAILURE;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "18855: static void ExternalFreeX509(WOLFSSL_X509* x509)",
          "18856: {",
          "18857:     int doFree = 0;",
          "18859:     WOLFSSL_ENTER(\"ExternalFreeX509\");",
          "18860:     if (x509) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "18864: #if defined(OPENSSL_EXTRA) || defined(OPENSSL_ALL)",
          "18866: #endif",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "18871:             if (x509->refCount == 0)",
          "18872:                 doFree = 1;",
          "18873:             wc_UnLockMutex(&x509->refMutex);",
          "18879:                 FreeX509(x509);",
          "18880:                 XFREE(x509, x509->heap, DYNAMIC_TYPE_X509);",
          "18881:             }",
          "",
          "[Removed Lines]",
          "18874:         #else",
          "18875:             doFree = 1;",
          "18878:             if (doFree) {",
          "",
          "[Added Lines]",
          "18885:         #if defined(OPENSSL_EXTRA) || defined(OPENSSL_ALL)",
          "18886:             if (doFree)",
          "18888:             {",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "22943:         return textSz;",
          "22944:     }",
          "22948:         if (textSz > 0) {",
          "22949:             XMEMCPY(buf, text, textSz - 1);",
          "",
          "[Removed Lines]",
          "22946:     if (buf != NULL && text != NULL) {",
          "",
          "[Added Lines]",
          "22957:     if (text != NULL) {",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "32173:     !defined(HAVE_FAST_RSA) && defined(WC_RSA_BLINDING)",
          "32174:     rng = ((RsaKey*)rsa->internal)->rng;",
          "32175: #endif",
          "32178: #ifdef WOLFSSL_SMALL_STACK",
          "32180:             if (*tmpRNG == NULL)",
          "",
          "[Removed Lines]",
          "32176:     if (rng == NULL && tmpRNG) {",
          "32177:         if (!*tmpRNG) {",
          "",
          "[Added Lines]",
          "32187:     if (tmpRNG != NULL",
          "32188:     #if !defined(HAVE_FIPS) && !defined(HAVE_USER_RSA) && \\",
          "32189:         !defined(HAVE_FAST_RSA) && defined(WC_RSA_BLINDING)",
          "32190:         && rng == NULL",
          "32191:     #endif",
          "32192:         ) {",
          "32193:         if (*tmpRNG == NULL) {",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "32434:     #endif",
          "32435:         return WOLFSSL_FATAL_ERROR;",
          "32436:     }",
          "32450:     }",
          "32452:     while (ret == WOLFSSL_SUCCESS && bytes < 255 && idx + 2 < 256) {",
          "32465:             }",
          "32466:         }",
          "",
          "[Removed Lines]",
          "32437:     if (ret == WOLFSSL_SUCCESS) {",
          "32438:         rem.sun_family = AF_UNIX;",
          "32439:         XSTRNCPY(rem.sun_path, nm, sizeof(rem.sun_path) - 1);",
          "32440:         rem.sun_path[sizeof(rem.sun_path)-1] = '\\0';",
          "32441:     }",
          "32444:     if (ret == WOLFSSL_SUCCESS) {",
          "32445:         if (connect(fd, (struct sockaddr*)&rem, sizeof(struct sockaddr_un))",
          "32446:                 == -1) {",
          "32447:             WOLFSSL_MSG(\"error connecting to egd server\");",
          "32448:             ret = WOLFSSL_FATAL_ERROR;",
          "32449:         }",
          "32453:         if (ret == WOLFSSL_SUCCESS) {",
          "32454:             buf[idx]     = WOLFSSL_EGD_NBLOCK;",
          "32456:             ret = (int)write(fd, buf + idx, 2);",
          "32457:             if (ret <= 0 || ret != 2) {",
          "32458:                 if (errno == EAGAIN) {",
          "32459:                     ret = WOLFSSL_SUCCESS;",
          "32460:                     continue;",
          "32461:                 }",
          "32462:                 WOLFSSL_MSG(\"error requesting entropy from egd server\");",
          "32463:                 ret = WOLFSSL_FATAL_ERROR;",
          "32464:                 break;",
          "",
          "[Added Lines]",
          "32453:     rem.sun_family = AF_UNIX;",
          "32454:     XSTRNCPY(rem.sun_path, nm, sizeof(rem.sun_path) - 1);",
          "32455:     rem.sun_path[sizeof(rem.sun_path)-1] = '\\0';",
          "32458:     if (connect(fd, (struct sockaddr*)&rem, sizeof(struct sockaddr_un)) == -1) {",
          "32459:         WOLFSSL_MSG(\"error connecting to egd server\");",
          "32460:         ret = WOLFSSL_FATAL_ERROR;",
          "32464:         buf[idx]     = WOLFSSL_EGD_NBLOCK;",
          "32466:         ret = (int)write(fd, buf + idx, 2);",
          "32467:         if (ret != 2) {",
          "32468:             if (errno == EAGAIN) {",
          "32469:                 ret = WOLFSSL_SUCCESS;",
          "32470:                 continue;",
          "32472:             WOLFSSL_MSG(\"error requesting entropy from egd server\");",
          "32473:             ret = WOLFSSL_FATAL_ERROR;",
          "32474:             break;",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "43367:         const char* headerEnd = NULL;",
          "43368:         const char* footer = NULL;",
          "43369:         const char* footerEnd = NULL;",
          "43370:         DerBuffer* der = NULL;",
          "43372:         (void)cb;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "43379:     #ifdef HAVE_CRL",
          "43381:     #endif",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "43398:         while (wolfSSL_BIO_read(bio, &pem[i], 1) == 1) {",
          "43399:             i++;",
          "43401:                 header = XSTRNSTR(pem, \"-----BEGIN \", (unsigned int)i);",
          "43403:                 if (!headerEnd) {",
          "43404:                     headerEnd = XSTRNSTR(header + XSTR_SIZEOF(\"-----BEGIN \"),",
          "43405:                             \"-----\",",
          "",
          "[Removed Lines]",
          "43400:             if (!header)",
          "43402:             else if (header) {",
          "",
          "[Added Lines]",
          "43411:             if (!header) {",
          "43413:             }",
          "43414:             else {",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "43463:                     goto err;",
          "43464:                 }",
          "43465:             }",
          "43467:             else if (headerEnd - header ==",
          "43468:                     XSTR_SIZEOF(\"-----BEGIN X509 CRL-----\") &&",
          "43469:                     XMEMCMP(header, \"-----BEGIN X509 CRL-----\",",
          "",
          "[Removed Lines]",
          "43466: #ifdef HAVE_CRL",
          "",
          "[Added Lines]",
          "43478:     #ifdef HAVE_CRL",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "43481:                     goto err;",
          "43482:                 }",
          "43483:             }",
          "43485:             else {",
          "43487:                 WOLFSSL_MSG(\"Unsupported PEM structure\");",
          "",
          "[Removed Lines]",
          "43484: #endif",
          "",
          "[Added Lines]",
          "43496:     #endif",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "43490:         }",
          "43492:         XFREE(pem, 0, DYNAMIC_TYPE_PEM);",
          "43493:         if (der)",
          "43494:             FreeDer(&der);",
          "43495:         return WOLFSSL_SUCCESS;",
          "43496: err:",
          "43497:         if (pem)",
          "43498:             XFREE(pem, 0, DYNAMIC_TYPE_PEM);",
          "43499:         if (der)",
          "43500:             FreeDer(&der);",
          "43501:         return WOLFSSL_FAILURE;",
          "43503:     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "43505:     #ifdef HAVE_CRL",
          "43508:     #endif",
          "43513:     #ifdef HAVE_CRL",
          "43516:     #endif",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "54855:             oidSz = 0;",
          "54856:         }",
          "54859:             ret = wc_CreatePKCS8Key(key, &keySz, (byte*)pkey->pkey.ptr,",
          "54860:                                          pkey->pkey_sz, algId, curveOid, oidSz);",
          "54861:             keySz = ret;",
          "",
          "[Removed Lines]",
          "54858:         if (ret >= 0) {",
          "",
          "[Added Lines]",
          "54874:     #ifdef HAVE_ECC",
          "54875:         if (ret >= 0)",
          "54876:     #endif",
          "54877:         {",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "55233: int wolfSSL_X509_set_pubkey(WOLFSSL_X509 *cert, WOLFSSL_EVP_PKEY *pkey)",
          "55234: {",
          "55235:     byte* p = NULL;",
          "55237:     WOLFSSL_ENTER(\"wolfSSL_X509_set_pubkey\");",
          "55239:     if (cert == NULL || pkey == NULL)",
          "",
          "[Removed Lines]",
          "55236:     int derSz;",
          "",
          "[Added Lines]",
          "55255:     int derSz = 0;",
          "",
          "---------------"
        ],
        "src/tls.c||src/tls.c": [
          "File: src/tls.c -> src/tls.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "5135:                 WOLFSSL_MSG(\"Process client ticket rejected, bad TLS version\");",
          "5136:                 ssl->options.rejectTicket = 1;",
          "5139:                 WOLFSSL_MSG(\"Process client ticket fatal error, not using\");",
          "5140:             }",
          "5141:         }",
          "5142:     }",
          "",
          "[Removed Lines]",
          "5138:             } else if (ret == WOLFSSL_TICKET_RET_FATAL || ret < 0) {",
          "",
          "[Added Lines]",
          "5138:             } else if (ret == WOLFSSL_TICKET_RET_FATAL) {",
          "5140:             } else if (ret < 0) {",
          "5141:                 WOLFSSL_MSG(\"Process client ticket unknown error, not using\");",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "10242:                 }",
          "10243:             }",
          "10244:         }",
          "10245: #endif",
          "10247: #if defined(HAVE_ENCRYPT_THEN_MAC) && !defined(WOLFSSL_AEAD_ONLY)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "10247:         if (ret != 0) {",
          "10248:             return ret;",
          "10249:         }",
          "",
          "---------------"
        ],
        "src/tls13.c||src/tls13.c": [
          "File: src/tls13.c -> src/tls13.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2303: int BuildTls13Message(WOLFSSL* ssl, byte* output, int outSz, const byte* input,",
          "2304:                 int inSz, int type, int hashOutput, int sizeOnly, int asyncOkay)",
          "2305: {",
          "2307:     BuildMsg13Args* args;",
          "2308:     BuildMsg13Args  lcl_args;",
          "2309: #ifdef WOLFSSL_ASYNC_CRYPT",
          "",
          "[Removed Lines]",
          "2306:     int ret = 0;",
          "",
          "[Added Lines]",
          "2306:     int ret;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2315:     WOLFSSL_ENTER(\"BuildTls13Message\");",
          "2318: #ifdef WOLFSSL_ASYNC_CRYPT",
          "2319:     if (asyncOkay) {",
          "2320:         ret = wolfSSL_AsyncPop(ssl, &ssl->options.buildMsgState);",
          "2321:         if (ret != WC_NOT_PENDING_E) {",
          "",
          "[Removed Lines]",
          "2317:     ret = WC_NOT_PENDING_E;",
          "",
          "[Added Lines]",
          "2318:     ret = WC_NOT_PENDING_E;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2331:     }",
          "2335:         ret = 0;",
          "2336:         ssl->options.buildMsgState = BUILD_MSG_BEGIN;",
          "2337:         XMEMSET(args, 0, sizeof(BuildMsg13Args));",
          "",
          "[Removed Lines]",
          "2334:     if (ret == WC_NOT_PENDING_E) {",
          "",
          "[Added Lines]",
          "2334: #ifdef WOLFSSL_ASYNC_CRYPT",
          "2335:     if (ret == WC_NOT_PENDING_E)",
          "2336: #endif",
          "2337:     {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "3292:         return INVALID_PARAMETER;",
          "3293:     }",
          "3296:     if (*extMsgType == server_hello) {",
          "3297:         ext = TLSX_Find(ssl->extensions, TLSX_PRE_SHARED_KEY);",
          "3298:         if (ext != NULL)",
          "3299:             psk = (PreSharedKey*)ext->data;",
          "",
          "[Removed Lines]",
          "3295: #if defined(HAVE_SESSION_TICKET) || !defined(NO_PSK)",
          "",
          "[Added Lines]",
          "3299: #if defined(HAVE_SESSION_TICKET) || !defined(NO_PSK)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "3306:         }",
          "3307:         else if ((ret = SetupPskKey(ssl, psk)) != 0)",
          "3308:             return ret;",
          "3310: #endif",
          "3313:         ssl->keys.encryptionOn = 1;",
          "3314:         ssl->options.serverState = SERVER_HELLO_COMPLETE;",
          "3315:     }",
          "",
          "[Removed Lines]",
          "3309:     }",
          "3312:     if (*extMsgType == server_hello) {",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "3356: #endif",
          "3360:         return BUFFER_ERROR;",
          "3361:     ato16(&input[i], &totalExtSz);",
          "3362:     i += OPAQUE16_LEN;",
          "",
          "[Removed Lines]",
          "3359:     if (totalSz < i - begin + OPAQUE16_LEN)",
          "",
          "[Added Lines]",
          "3360:     if (totalSz < OPAQUE16_LEN)",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "3433:     if (ssl->toInfoOn) AddLateName(\"CertificateRequest\", &ssl->timeoutInfo);",
          "3434: #endif",
          "3437:         return BUFFER_ERROR;",
          "",
          "[Removed Lines]",
          "3436:     if ((*inOutIdx - begin) + OPAQUE8_LEN > size)",
          "",
          "[Added Lines]",
          "3437:     if (OPAQUE8_LEN > size)",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "3733:             continue;",
          "3734:         }",
          "3736:         ssl->options.sendVerify = 0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3737:     #if defined(HAVE_SESSION_TICKET) || !defined(NO_PSK)",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "3755:         current->chosen = 1;",
          "3756:         ext->resp = 1;",
          "3757:         break;",
          "3758:     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3760:     #endif",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "3762:     if (ret != 0)",
          "3763:         return ret;",
          "3766: #ifdef WOLFSSL_PSK_ID_PROTECTION",
          "3767:     #ifndef NO_CERTS",
          "3768:         if (ssl->buffers.certChainCnt != 0)",
          "",
          "[Removed Lines]",
          "3765:     if (current == NULL) {",
          "",
          "[Added Lines]",
          "3768: #if defined(HAVE_SESSION_TICKET) || !defined(NO_PSK)",
          "3769:     if (current == NULL)",
          "3770: #endif",
          "3771:     {",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "4098:     word32          i = *inOutIdx;",
          "4099:     word32          begin = i;",
          "4100:     word16          totalExtSz = 0;",
          "4102:     byte            sessIdSz = 0;",
          "4103:     int             wantDowngrade = 0;",
          "4105:     WOLFSSL_START(WC_FUNC_CLIENT_HELLO_DO);",
          "4106:     WOLFSSL_ENTER(\"DoTls13ClientHello\");",
          "",
          "[Removed Lines]",
          "4101:     int             usingPSK = 0;",
          "",
          "[Added Lines]",
          "4109: #if (defined(HAVE_SESSION_TICKET) || !defined(NO_PSK)) && \\",
          "4110:                                                     defined(HAVE_TLS_EXTENSIONS)",
          "4111:     int             usingPSK = 0;",
          "4112: #endif",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "4114: #endif",
          "4118:         return BUFFER_ERROR;",
          "",
          "[Removed Lines]",
          "4117:     if ((i - begin) + OPAQUE16_LEN + RAN_LEN + OPAQUE8_LEN > helloSz)",
          "",
          "[Added Lines]",
          "4126:     if (OPAQUE16_LEN + RAN_LEN + OPAQUE8_LEN > helloSz)",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "4299:     }",
          "4303:         ssl->options.noPskDheKe = 0;",
          "",
          "[Removed Lines]",
          "4301:     if (!usingPSK) {",
          "",
          "[Added Lines]",
          "4310: #if (defined(HAVE_SESSION_TICKET) || !defined(NO_PSK)) && \\",
          "4311:                                                     defined(HAVE_TLS_EXTENSIONS)",
          "4312:     if (!usingPSK)",
          "4313: #endif",
          "4314:     {",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "5119:     word32 offset = OPAQUE16_LEN;",
          "5120:     byte*  p = NULL;",
          "5121:     byte   certReqCtxLen = 0;",
          "5122:     byte*  certReqCtx = NULL;",
          "5124: #ifdef OPENSSL_EXTRA",
          "5125:     WOLFSSL_X509* x509 = NULL;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5135: #ifdef WOLFSSL_POST_HANDSHAKE_AUTH",
          "5137: #endif",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "5251:             output[i++] = certReqCtxLen;",
          "5252:             if (certReqCtxLen > 0) {",
          "5253:                 XMEMCPY(output + i, certReqCtx, certReqCtxLen);",
          "5254:                 i += certReqCtxLen;",
          "5255:             }",
          "5256:             length -= OPAQUE8_LEN + certReqCtxLen;",
          "5257:             fragSz -= OPAQUE8_LEN + certReqCtxLen;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5267:         #ifdef WOLFSSL_POST_HANDSHAKE_AUTH",
          "5272:         #endif",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "8427: int wolfSSL_accept_TLSv13(WOLFSSL* ssl)",
          "8428: {",
          "8429:     word16 havePSK = 0;",
          "8430:     WOLFSSL_ENTER(\"SSL_accept_TLSv13()\");",
          "8432: #ifdef HAVE_ERRNO_H",
          "8433:     errno = 0;",
          "8434: #endif",
          "8437:     havePSK = ssl->options.havePSK;",
          "8438: #endif",
          "8441:     if (ssl->options.side != WOLFSSL_SERVER_END) {",
          "8442:         WOLFSSL_ERROR(ssl->error = SIDE_ERROR);",
          "",
          "[Removed Lines]",
          "8436: #if defined(HAVE_SESSION_TICKET) || !defined(NO_PSK)",
          "8439:     (void)havePSK;",
          "",
          "[Added Lines]",
          "8446: #if !defined(NO_CERTS) && (defined(HAVE_SESSION_TICKET) || !defined(NO_PSK))",
          "8448: #endif",
          "8455: #if !defined(NO_CERTS) && (defined(HAVE_SESSION_TICKET) || !defined(NO_PSK))",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "8458: #ifndef NO_CERTS",
          "8461:         if (!ssl->buffers.certificate ||",
          "8462:             !ssl->buffers.certificate->buffer) {",
          "",
          "[Removed Lines]",
          "8460:     if (!havePSK) {",
          "",
          "[Added Lines]",
          "8478: #if defined(HAVE_SESSION_TICKET) || !defined(NO_PSK)",
          "8479:     if (!havePSK)",
          "8480: #endif",
          "8481:     {",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "8478:             return WOLFSSL_FATAL_ERROR;",
          "8479:         }",
          "8480:     }",
          "8483:     if (ssl->buffers.outputBuffer.length > 0",
          "8484:     #ifdef WOLFSSL_ASYNC_CRYPT",
          "",
          "[Removed Lines]",
          "8481: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "tests/api.c||tests/api.c": [
          "File: tests/api.c -> tests/api.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "19114: {",
          "19115:     int ret = 0;",
          "19116: #if defined(HAVE_CURVE25519)",
          "",
          "[Removed Lines]",
          "19113: static int test_wc_curve25519_shared_secret_ex (void)",
          "",
          "[Added Lines]",
          "19113: static int test_wc_curve25519_shared_secret_ex(void)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "19126:     ret = wc_curve25519_init(&private_key);",
          "19127:     if (ret == 0) {",
          "19128:         ret = wc_InitRng(&rng);",
          "19132:     }",
          "19133:     if (ret == 0) {",
          "19134:         ret = wc_curve25519_make_key(&rng, CURVE25519_KEYSIZE, &public_key);",
          "",
          "[Removed Lines]",
          "19129:         if (ret == 0) {",
          "19130:             ret = wc_curve25519_make_key(&rng, CURVE25519_KEYSIZE, &private_key);",
          "19131:         }",
          "",
          "[Added Lines]",
          "19129:     }",
          "19130:     if (ret == 0) {",
          "19131:         ret = wc_curve25519_make_key(&rng, CURVE25519_KEYSIZE, &private_key);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "19142:     if (ret == 0) {",
          "19143:         ret = wc_curve25519_shared_secret_ex(NULL, NULL, NULL,",
          "19144:                                               0, endian);",
          "19145:         if (ret == BAD_FUNC_ARG) {",
          "19146:             ret = 0;",
          "19147:         }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "19145:         if (ret == 0) {",
          "19146:             ret = -1;",
          "19147:         }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "19149:     if (ret == 0) {",
          "19150:         ret = wc_curve25519_shared_secret_ex(NULL, &public_key, out,",
          "19151:                                              &outLen, endian);",
          "19153:             ret = 0;",
          "19154:         }",
          "19155:     }",
          "19156:     if (ret == 0) {",
          "19157:         ret = wc_curve25519_shared_secret_ex(&private_key, NULL, out,",
          "19158:                                               &outLen, endian);",
          "19160:             ret = 0;",
          "19161:         }",
          "19162:     }",
          "19163:     if (ret == 0) {",
          "19164:         ret = wc_curve25519_shared_secret_ex(&private_key, &public_key, NULL,",
          "19165:                                               &outLen, endian);",
          "19167:             ret = 0;",
          "19168:         }",
          "19169:     }",
          "19170:     if (ret == 0) {",
          "19171:         ret = wc_curve25519_shared_secret_ex(&private_key, &public_key, out,",
          "19172:                                               NULL, endian);",
          "19174:             ret = 0;",
          "19175:         }",
          "19176:     }",
          "",
          "[Removed Lines]",
          "19152:         if (ret == BAD_FUNC_ARG) {",
          "19159:         if (ret == BAD_FUNC_ARG) {",
          "19166:         if (ret == BAD_FUNC_ARG) {",
          "19173:         if (ret == BAD_FUNC_ARG) {",
          "",
          "[Added Lines]",
          "19155:         if (ret == 0) {",
          "19156:             ret = -1;",
          "19157:         }",
          "19158:         else if (ret == BAD_FUNC_ARG) {",
          "19165:         if (ret == 0) {",
          "19166:             ret = -1;",
          "19167:         }",
          "19168:         else if (ret == BAD_FUNC_ARG) {",
          "19175:         if (ret == 0) {",
          "19176:             ret = -1;",
          "19177:         }",
          "19178:         else if (ret == BAD_FUNC_ARG) {",
          "19185:         if (ret == 0) {",
          "19186:             ret = -1;",
          "19187:         }",
          "19188:         else if (ret == BAD_FUNC_ARG) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "19181:         public_key.p.point[CURVE25519_KEYSIZE-1] = 0x8F;",
          "19182:         ret = wc_curve25519_shared_secret_ex(&private_key, &public_key, out,",
          "19183:                                               &outLen, endian);",
          "19185:            ret = 0;",
          "19186:         }",
          "19187:     }",
          "",
          "[Removed Lines]",
          "19184:         if (ret == ECC_BAD_ARG_E) {",
          "",
          "[Added Lines]",
          "19199:         if (ret == 0) {",
          "19200:             ret = -1;",
          "19201:         }",
          "19202:         else if (ret == ECC_BAD_ARG_E) {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "19190:     if (ret == 0) {",
          "19191:         ret = wc_curve25519_shared_secret_ex(&private_key, &public_key, out,",
          "19192:                                               &outLen, endian);",
          "19194:             ret = 0;",
          "19195:         }",
          "19196:     }",
          "",
          "[Removed Lines]",
          "19193:         if (ret == BAD_FUNC_ARG) {",
          "",
          "[Added Lines]",
          "19211:         if (ret == 0) {",
          "19212:             ret = -1;",
          "19213:         }",
          "19214:         else if (ret == BAD_FUNC_ARG) {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "23293:             derSz = (word32)XFREAD(der, 1, FOURK_BUF, file);",
          "23294:             XFCLOSE(file);",
          "23295:         }",
          "23296:     }",
          "23297:     if (ret == 0) {",
          "23298:         ret = wc_InitCert(&cert);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "23317:         else {",
          "23318:             ret = -1;",
          "23319:         }",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "23351:         ret = wc_ed25519_init(&ed25519Key);",
          "23352:         if (ret == 0) {",
          "23354:         }",
          "23355:         if (ret == 0) {",
          "23356:             ret = wc_SetSubjectKeyIdFromPublicKey_ex(&cert, ED25519_TYPE,",
          "",
          "[Removed Lines]",
          "23353:             wc_ed25519_make_key(&rng, ED25519_KEY_SIZE, &ed25519Key);",
          "",
          "[Added Lines]",
          "23377:             ret = wc_ed25519_make_key(&rng, ED25519_KEY_SIZE, &ed25519Key);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "23376:         ret = wc_ecc_init(&eccKey);",
          "23377:         if (ret == 0) {",
          "23379:         }",
          "23380:         if (ret == 0) {",
          "23381:             ret = wc_SetSubjectKeyIdFromPublicKey_ex(&cert, ECC_TYPE, &eccKey);",
          "",
          "[Removed Lines]",
          "23378:             wc_ecc_make_key(&rng, KEY14, &eccKey);",
          "",
          "[Added Lines]",
          "23402:             ret = wc_ecc_make_key(&rng, KEY14, &eccKey);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "23390:         ret = wc_ed448_init(&ed448Key);",
          "23391:         if (ret == 0) {",
          "23393:         }",
          "23394:         if (ret == 0) {",
          "23395:             ret = wc_SetSubjectKeyIdFromPublicKey_ex(&cert, ED448_TYPE,",
          "",
          "[Removed Lines]",
          "23392:             wc_ed448_make_key(&rng, ED448_KEY_SIZE, &ed448Key);",
          "",
          "[Added Lines]",
          "23416:             ret = wc_ed448_make_key(&rng, ED448_KEY_SIZE, &ed448Key);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "23442:         ret = wc_ed25519_init(&ed25519Key);",
          "23443:         if (ret == 0) {",
          "23445:         }",
          "23446:         if (ret == 0) {",
          "23447:             ret = wc_SetAuthKeyIdFromPublicKey_ex(&cert, ED25519_TYPE,",
          "",
          "[Removed Lines]",
          "23444:             wc_ed25519_make_key(&rng, ED25519_KEY_SIZE, &ed25519Key);",
          "",
          "[Added Lines]",
          "23468:             ret = wc_ed25519_make_key(&rng, ED25519_KEY_SIZE, &ed25519Key);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "23467:         ret = wc_ecc_init(&eccKey);",
          "23468:         if (ret == 0) {",
          "23470:         }",
          "23471:         if (ret == 0) {",
          "23472:             ret = wc_SetAuthKeyIdFromPublicKey_ex(&cert, ECC_TYPE, &eccKey);",
          "",
          "[Removed Lines]",
          "23469:             wc_ecc_make_key(&rng, KEY14, &eccKey);",
          "",
          "[Added Lines]",
          "23493:             ret = wc_ecc_make_key(&rng, KEY14, &eccKey);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "23481:         ret = wc_ed448_init(&ed448Key);",
          "23482:         if (ret == 0) {",
          "23484:         }",
          "23485:         if (ret == 0) {",
          "23486:             ret = wc_SetAuthKeyIdFromPublicKey_ex(&cert, ED448_TYPE,",
          "",
          "[Removed Lines]",
          "23483:             wc_ed448_make_key(&rng, ED448_KEY_SIZE, &ed448Key);",
          "",
          "[Added Lines]",
          "23507:             ret = wc_ed448_make_key(&rng, ED448_KEY_SIZE, &ed448Key);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "25971:     }",
          "25973:     int notSupportedLen = (sizeof(notSupported)/sizeof(enum wc_HashType));",
          "25975:         if (ret == 0) {",
          "25978:                 ret = 0;",
          "25985:             }",
          "25986:         }",
          "25987:         if (ret == 0) {",
          "25988:             ret = wc_HashFree(&hash, notSupported[j]);",
          "25990:                 ret = 0;",
          "25991:             }",
          "25992:         }",
          "",
          "[Removed Lines]",
          "25974:     for (j = 0; j < notSupportedLen; j++){",
          "25976:             ret = wc_HashInit(&hash, notSupported[j]);",
          "25977:             if (ret == BAD_FUNC_ARG){",
          "25979:                 if (ret == 0){",
          "25980:                     ret = wc_HashSetFlags(&hash, notSupported[j], flags);",
          "25981:                     if (ret == BAD_FUNC_ARG) {",
          "25982:                         ret = 0;",
          "25983:                     }",
          "25984:                 }",
          "25989:             if (ret ==  BAD_FUNC_ARG) {",
          "",
          "[Added Lines]",
          "25998:     for (j = 0; ret == 0 && j < notSupportedLen; j++){",
          "25999:         ret = wc_HashInit(&hash, notSupported[j]);",
          "26001:             ret = -1;",
          "26002:         }",
          "26003:         else if (ret == BAD_FUNC_ARG){",
          "26004:             ret = wc_HashSetFlags(&hash, notSupported[j], flags);",
          "26005:             if (ret == 0) {",
          "26006:                 ret = -1;",
          "26007:             }",
          "26008:             else if (ret == BAD_FUNC_ARG) {",
          "26014:             if (ret == 0) {",
          "26015:                 ret = -1;",
          "26016:             }",
          "26017:             else if (ret == BAD_FUNC_ARG) {",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "26068:     }",
          "26070:     int notSupportedLen = (sizeof(notSupported)/sizeof(enum wc_HashType));",
          "26072:         if (ret == 0) {",
          "26075:                 ret = 0;",
          "26082:             }",
          "26083:         }",
          "26084:         if (ret == 0) {",
          "26085:             ret = wc_HashFree(&hash, notSupported[j]);",
          "26087:                 ret = 0;",
          "26088:             }",
          "26089:         }",
          "",
          "[Removed Lines]",
          "26071:     for (j = 0; j < notSupportedLen; j++){",
          "26073:             ret = wc_HashInit(&hash, notSupported[j]);",
          "26074:             if (ret == BAD_FUNC_ARG){",
          "26076:                 if (ret == 0){",
          "26077:                     ret = wc_HashGetFlags(&hash, notSupported[j], &flags);",
          "26078:                     if (ret == BAD_FUNC_ARG) {",
          "26079:                         ret = 0;",
          "26080:                     }",
          "26081:                 }",
          "26086:             if (ret ==  BAD_FUNC_ARG) {",
          "",
          "[Added Lines]",
          "26099:     for (j = 0; ret == 0 && j < notSupportedLen; j++){",
          "26100:         ret = wc_HashInit(&hash, notSupported[j]);",
          "26102:             ret = -1;",
          "26103:         }",
          "26104:         else if (ret == BAD_FUNC_ARG){",
          "26105:             ret = wc_HashGetFlags(&hash, notSupported[j], &flags);",
          "26106:             if (ret == 0) {",
          "26107:                 ret = -1;",
          "26108:             }",
          "26109:             else if (ret == BAD_FUNC_ARG) {",
          "26115:             if (ret == 0) {",
          "26116:                 ret = -1;",
          "26117:             }",
          "26118:             if (ret == BAD_FUNC_ARG) {",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "36550:     AssertIntEQ(wolfSSL_EVP_PKEY_assign(pkey,type,ecKey), WOLFSSL_SUCCESS);",
          "36551:     wolfSSL_EVP_PKEY_free(pkey);",
          "36553:     printf(resultFmt, passed);",
          "36555: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "36586:     (void)type;",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "42890:     AssertTrue(1);",
          "42891:     res = CRYPTO_THREADID_hash(NULL);",
          "42892:     AssertTrue( res == 0UL);",
          "42893:     res = CRYPTO_THREADID_hash(&id);",
          "42894:     AssertTrue( res == 0UL);",
          "42895:     printf(resultFmt, passed);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "42928:     XMEMSET(&id, 0, sizeof(id));",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "42918: #if defined(OPENSSL_EXTRA) || defined(OPENSSL_ALL)",
          "42919:     WOLFSSL_CTX *ctx;",
          "42921:     printf(testingFmt, \"wolfSSL_CTX_get_min_proto_version()\");",
          "42923:     #ifndef NO_OLD_TLS",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "42957:     (void)ctx;",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "43027: #elif defined(HAVE_ECC)",
          "43028:         testCertFile = eccCertFile;",
          "43029:         testKeyFile = eccKeyFile;",
          "43030: #endif",
          "43031:         if  (testCertFile != NULL && testKeyFile != NULL) {",
          "43032:             AssertTrue(SSL_CTX_use_certificate_file(ctx, testCertFile,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "43068: #else",
          "43069:         testCertFile = NULL;",
          "43070:         testKeyFile = NULL;",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "43208: #elif defined(HAVE_ECC)",
          "43209:         testCertFile = eccCertFile;",
          "43210:         testKeyFile = eccKeyFile;",
          "43211: #endif",
          "43212:         if  (testCertFile != NULL && testKeyFile != NULL) {",
          "43213:             AssertTrue(SSL_CTX_use_certificate_file(ctx, testCertFile,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "43252: #else",
          "43253:         testCertFile = NULL;",
          "43254:         testKeyFile = NULL;",
          "",
          "---------------"
        ],
        "wolfcrypt/src/asn.c||wolfcrypt/src/asn.c": [
          "File: wolfcrypt/src/asn.c -> wolfcrypt/src/asn.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "10064:                         cert->ca->keyOID, cert->signature,",
          "10065:                         cert->sigLength, cert->signatureOID,",
          "10066:                         tsip_encRsaKeyIdx)) != 0) {",
          "10068:                         WOLFSSL_MSG(\"Confirm signature failed\");",
          "10069:                     }",
          "10070:                     return ret;",
          "",
          "[Removed Lines]",
          "10067:                     if (ret != 0 && ret != WC_PENDING_E) {",
          "",
          "[Added Lines]",
          "10067:                     if (ret != WC_PENDING_E) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "11181:                             (der->length % DES_BLOCK_SIZE) != 0) {",
          "11182:                             padVal = der->buffer[der->length-1];",
          "11183:                             if (padVal < DES_BLOCK_SIZE) {",
          "",
          "[Removed Lines]",
          "11179:                         if (der->length > 0 &&",
          "11180:                             der->length > DES_BLOCK_SIZE &&",
          "",
          "[Added Lines]",
          "11179:                         if (der->length > DES_BLOCK_SIZE &&",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "16525:     totalSz = prvidx + pubidx + curveidx + verSz + seqSz;",
          "16526:     if (output == NULL) {",
          "16528:         XFREE(prv, key->heap, DYNAMIC_TYPE_TMP_BUFFER);",
          "16530:             XFREE(pub, key->heap, DYNAMIC_TYPE_TMP_BUFFER);",
          "16531:         }",
          "16532:         return LENGTH_ONLY_E;",
          "16533:     }",
          "16534:     if (inLen != NULL && totalSz > (int)*inLen) {",
          "",
          "[Removed Lines]",
          "16529:         if (pubIn) {",
          "",
          "[Added Lines]",
          "16527:     #ifndef WOLFSSL_NO_MALLOC",
          "16529:         if (pub) {",
          "16532:     #endif",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "18126:         word32* inOutIdx, int sz)",
          "18127: {",
          "18128:     word32 oid, dateIdx, idx, checkIdx;",
          "18130:     byte tag;",
          "18132:     if (dcrl == NULL || inOutIdx == NULL || buf == NULL) {",
          "",
          "[Removed Lines]",
          "18129:     int version, doNextDate = 1;",
          "",
          "[Added Lines]",
          "18130:     int version;",
          "18131: #ifdef WOLFSSL_NO_CRL_NEXT_DATE",
          "18132:     int doNextDate = 1;",
          "18133: #endif",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "18165: #endif",
          "18166:     }",
          "18169: #ifndef NO_ASN_TIME",
          "18170:         if (!XVALIDATE_DATE(dcrl->nextDate, dcrl->nextDateFormat, AFTER)) {",
          "18171:             WOLFSSL_MSG(\"CRL after date is no longer valid\");",
          "",
          "[Removed Lines]",
          "18168:     if (doNextDate) {",
          "",
          "[Added Lines]",
          "18172: #ifdef WOLFSSL_NO_CRL_NEXT_DATE",
          "18173:     if (doNextDate)x",
          "18174: #endif",
          "18175:     {",
          "",
          "---------------"
        ],
        "wolfcrypt/src/curve25519.c||wolfcrypt/src/curve25519.c": [
          "File: wolfcrypt/src/curve25519.c -> wolfcrypt/src/curve25519.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "112:                           int private_size, const byte* priv,",
          "113:                           int basepoint_size, const byte* basepoint)",
          "114: {",
          "117: #ifdef FREESCALE_LTC_ECC",
          "120:     return WC_HW_E;",
          "121: #else",
          "123:     if ((public_size != CURVE25519_KEYSIZE) ||",
          "124:         (private_size != CURVE25519_KEYSIZE) ||",
          "",
          "[Removed Lines]",
          "115:     int ret;",
          "",
          "[Added Lines]",
          "120:     int ret;",
          "",
          "---------------"
        ],
        "wolfcrypt/src/des3.c||wolfcrypt/src/des3.c": [
          "File: wolfcrypt/src/des3.c -> wolfcrypt/src/des3.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "719:     int wc_Des3_SetKey(Des3* des, const byte* key, const byte* iv, int dir)",
          "720:     {",
          "721:         int ret = 0;",
          "",
          "[Removed Lines]",
          "722:         byte* dkey1 = (byte*)des->key[0];",
          "723:         byte* dkey2 = (byte*)des->key[1];",
          "724:         byte* dkey3 = (byte*)des->key[2];",
          "",
          "[Added Lines]",
          "722:         byte* dkey1;",
          "723:         byte* dkey2;",
          "724:         byte* dkey3;",
          "726:         if (des == NULL || key == NULL) {",
          "727:             return BAD_FUNC_ARG;",
          "728:         }",
          "730:         dkey1 = (byte*)des->key[0];",
          "731:         dkey2 = (byte*)des->key[1];",
          "732:         dkey3 = (byte*)des->key[2];",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "835:     int wc_Des3_SetKey(Des3* des, const byte* key, const byte* iv, int dir)",
          "836:     {",
          "837:         int i = 0, ret = 0;",
          "",
          "[Removed Lines]",
          "838:         byte* dkey1 = (byte*)des->key[0];",
          "839:         byte* dkey2 = (byte*)des->key[1];",
          "840:         byte* dkey3 = (byte*)des->key[2];",
          "",
          "[Added Lines]",
          "846:         byte* dkey1;",
          "847:         byte* dkey2;",
          "848:         byte* dkey3;",
          "850:         if (des == NULL || key == NULL) {",
          "851:             return BAD_FUNC_ARG;",
          "852:         }",
          "854:         dkey1 = (byte*)des->key[0];",
          "855:         dkey2 = (byte*)des->key[1];",
          "856:         dkey3 = (byte*)des->key[2];",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1771:     if (des == NULL) {",
          "1772:         return BAD_FUNC_ARG;",
          "1773:     }",
          "1775:         XMEMCPY(des->reg, iv, DES_BLOCK_SIZE);",
          "1777:         XMEMSET(des->reg,  0, DES_BLOCK_SIZE);",
          "1779:     return 0;",
          "",
          "[Removed Lines]",
          "1774:     if (des && iv)",
          "1776:     else if (des)",
          "",
          "[Added Lines]",
          "1790:     if (iv)",
          "1792:     else",
          "",
          "---------------"
        ],
        "wolfcrypt/src/ecc.c||wolfcrypt/src/ecc.c": [
          "File: wolfcrypt/src/ecc.c -> wolfcrypt/src/ecc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "5081:         }",
          "5082:         hash_mode = cc310_hashModeECC(msgLenInBytes);",
          "5083:         if (hash_mode == CRYS_ECPKI_HASH_OpModeLast) {",
          "5085:             hash_mode = CRYS_ECPKI_HASH_SHA256_mode;",
          "5087:         }",
          "",
          "[Removed Lines]",
          "5084:             hash_mode = cc310_hashModeECC(keysize);",
          "",
          "[Added Lines]",
          "5084:             (void)cc310_hashModeECC(keysize);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "8139:     if (err == MP_OKAY)",
          "8140:         err = mp_set(key->pubkey.z, 1);",
          "8145: #ifdef WOLFSSL_CRYPTOCELL",
          "8157:     }",
          "8158: #endif",
          "8159: #ifdef WOLFSSL_VALIDATE_ECC_IMPORT",
          "8160:     if (err == MP_OKAY)",
          "",
          "[Removed Lines]",
          "8142: #ifdef WOLFSSL_SILABS_SE_ACCEL",
          "8143:     err = silabs_ecc_import(key, keysize);",
          "8144: #endif",
          "8146:     pDomain = CRYS_ECPKI_GetEcDomain(cc310_mapCurve(key->dp->id));",
          "8149:     err = CRYS_ECPKI_BuildPublKeyFullCheck(pDomain,",
          "8152:                                            &key->ctx.pubKey,",
          "8153:                                            &tempBuff);",
          "8155:     if (err != SA_SILIB_RET_OK){",
          "8156:         WOLFSSL_MSG(\"CRYS_ECPKI_BuildPublKeyFullCheck failed\");",
          "",
          "[Added Lines]",
          "8144:     if (err == MP_OKAY) {",
          "8145:         pDomain = CRYS_ECPKI_GetEcDomain(cc310_mapCurve(key->dp->id));",
          "8148:         err = CRYS_ECPKI_BuildPublKeyFullCheck(pDomain,",
          "8151:                                                &key->ctx.pubKey,",
          "8152:                                                &tempBuff);",
          "8154:         if (err != SA_SILIB_RET_OK){",
          "8155:             WOLFSSL_MSG(\"CRYS_ECPKI_BuildPublKeyFullCheck failed\");",
          "8156:         }",
          "8158: #elif defined(WOLFSSL_SILABS_SE_ACCEL)",
          "8159:     if (err == MP_OKAY)",
          "8160:         err = silabs_ecc_import(key, keysize);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "8346: #ifdef WOLFSSL_CRYPTOCELL",
          "8347:     pDomain = CRYS_ECPKI_GetEcDomain(cc310_mapCurve(key->dp->id));",
          "8352:         ret = CRYS_ECPKI_BuildPrivKey(pDomain,",
          "",
          "[Removed Lines]",
          "8349:     if (priv != NULL && priv[0] != '\\0') {",
          "",
          "[Added Lines]",
          "8352:     if (priv[0] != '\\0') {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "8368:     if (ret == MP_OKAY) {",
          "8369:         if (pub) {",
          "8370:             ret = silabs_ecc_import(key, key->dp->size);",
          "8373:             ret = silabs_ecc_import_private(key, key->dp->size);",
          "8374:         }",
          "8375: #elif defined(WOLFSSL_QNX_CAAM)",
          "8376:     if ((wc_ecc_size(key) + WC_CAAM_MAC_SZ) == (int)privSz) {",
          "8377:         int part = caamFindUnusuedPartition();",
          "",
          "[Removed Lines]",
          "8371:         } else",
          "8372:         {",
          "",
          "[Added Lines]",
          "8374:         }",
          "8375:         else {",
          "8378:     }",
          "",
          "---------------"
        ],
        "wolfcrypt/src/eccsi.c||wolfcrypt/src/eccsi.c": [
          "File: wolfcrypt/src/eccsi.c -> wolfcrypt/src/eccsi.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "543: {",
          "544:     int err = 0;",
          "547:         err = BUFFER_E;",
          "548:     }",
          "",
          "[Removed Lines]",
          "546:     if ((err == 0) && (sz != size * 2) && (sz != size * 2 + 1)) {",
          "",
          "[Added Lines]",
          "546:     if ((sz != size * 2) && (sz != size * 2 + 1)) {",
          "",
          "---------------"
        ],
        "wolfcrypt/src/evp.c||wolfcrypt/src/evp.c": [
          "File: wolfcrypt/src/evp.c -> wolfcrypt/src/evp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4289:                         ret = WOLFSSL_FAILURE;",
          "4290:                         break;",
          "4291:                     }",
          "4292:                     if (wc_InitRng(&rng) != 0) {",
          "4293:                         WOLFSSL_MSG(\"wc_InitRng failed\");",
          "4294:                         ret = WOLFSSL_FAILURE;",
          "4295:                         break;",
          "4296:                     }",
          "4300:                     if (wc_RNG_GenerateBlock(&rng, ctx->iv   + arg,",
          "4301:                                                    ctx->ivSz - arg) != 0) {",
          "",
          "[Removed Lines]",
          "4297:                     if (arg) {",
          "4298:                         XMEMCPY(ctx->iv, ptr, arg);",
          "4299:                     }",
          "",
          "[Added Lines]",
          "4293:                     XMEMCPY(ctx->iv, ptr, arg);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "6373:         ret = wc_DhParamsToDer(dhkey,NULL,&derSz);",
          "6374:     }",
          "6377:        WOLFSSL_MSG(\"Failed to get size of DH Key\");",
          "6378:        return WOLFSSL_FAILURE;",
          "6379:     }",
          "",
          "[Removed Lines]",
          "6376:     if (derSz <= 0 || ret != LENGTH_ONLY_E) {",
          "",
          "[Added Lines]",
          "6375:     if (derSz == 0 || ret != LENGTH_ONLY_E) {",
          "",
          "---------------"
        ],
        "wolfcrypt/src/integer.c||wolfcrypt/src/integer.c": [
          "File: wolfcrypt/src/integer.c -> wolfcrypt/src/integer.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "687:   x = DIGIT_BIT - (b % DIGIT_BIT);",
          "688:   if (x != DIGIT_BIT) {",
          "690:   }",
          "691:   mp_clamp (c);",
          "692:   return MP_OKAY;",
          "",
          "[Removed Lines]",
          "689:     c->dp[b / DIGIT_BIT] &= ~((mp_digit)0) >> (x + ((sizeof(mp_digit)*8) - DIGIT_BIT));",
          "",
          "[Added Lines]",
          "689:     c->dp[b / DIGIT_BIT] &=",
          "690:          ((mp_digit)~((mp_digit)0)) >> (x + ((sizeof(mp_digit)*8) - DIGIT_BIT));",
          "",
          "---------------"
        ],
        "wolfcrypt/src/pkcs12.c||wolfcrypt/src/pkcs12.c": [
          "File: wolfcrypt/src/pkcs12.c -> wolfcrypt/src/pkcs12.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "58:     WC_PKCS12_ENCRYPTED_DATA = 656,",
          "60:     WC_PKCS12_DATA_OBJ_SZ = 11,",
          "61: };",
          "63: static const byte WC_PKCS12_ENCRYPTED_OID[] =",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "61:     WC_PKCS12_MAC_SALT_SZ = 8,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1442:     word32 sz;",
          "1443:     word32 totalSz = 0;",
          "1444:     int ret;",
          "1447:     if (outSz == NULL || pkcs12 == NULL || rng == NULL || key == NULL ||",
          "1448:             pass == NULL) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1446:     byte* pkcs8Key = NULL;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1455:     if (out != NULL) {",
          "1457:         sz = *outSz - tmpIdx;",
          "1458:     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1459:         pkcs8Key = out + tmpIdx;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1472:         }",
          "1477:     }",
          "1478:     else {",
          "1479:         WOLFSSL_MSG(\"creating PKCS12 Shrouded Key Bag\");",
          "",
          "[Removed Lines]",
          "1475:         ret = wc_CreatePKCS8Key(out + tmpIdx, &sz, key, keySz, algoID,",
          "1476:                 curveOID, oidSz);",
          "",
          "[Added Lines]",
          "1477:         ret = wc_CreatePKCS8Key(pkcs8Key, &sz, key, keySz, algoID, curveOID,",
          "1478:                 oidSz);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1483:             vAlgo = 10;",
          "1484:         }",
          "1487:                 vPKCS, vAlgo, NULL, 0, itt, rng, heap);",
          "1488:     }",
          "1489:     if (ret == LENGTH_ONLY_E) {",
          "",
          "[Removed Lines]",
          "1486:         ret = UnTraditionalEnc(key, keySz, out + tmpIdx, &sz, pass, passSz,",
          "",
          "[Added Lines]",
          "1488:         ret = UnTraditionalEnc(key, keySz, pkcs8Key, &sz, pass, passSz,",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2354:         mac->itt = macIter;",
          "2359:         if (mac->salt == NULL) {",
          "2360:             wc_PKCS12_free(pkcs12);",
          "2361:             wc_FreeRng(&rng);",
          "",
          "[Removed Lines]",
          "2357:         mac->saltSz = 8;",
          "2358:         mac->salt = (byte*)XMALLOC(mac->saltSz, heap, DYNAMIC_TYPE_PKCS);",
          "",
          "[Added Lines]",
          "2359:         mac->saltSz = WC_PKCS12_MAC_SALT_SZ;",
          "2360:         mac->salt = (byte*)XMALLOC(WC_PKCS12_MAC_SALT_SZ, heap,",
          "2361:                 DYNAMIC_TYPE_PKCS);",
          "",
          "---------------"
        ],
        "wolfcrypt/src/port/ti/ti-hash.c||wolfcrypt/src/port/ti/ti-hash.c": [
          "File: wolfcrypt/src/port/ti/ti-hash.c -> wolfcrypt/src/port/ti/ti-hash.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "108:     XMEMSET(h, 0, sizeof(h));",
          "109: #endif",
          "110:     XMEMCPY(result, h, hsize);",
          "112:     return 0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "110:     if (result == NULL) {",
          "111:         return BAD_FUNC_ARG;",
          "112:     }",
          "",
          "---------------"
        ],
        "wolfcrypt/src/random.c||wolfcrypt/src/random.c": [
          "File: wolfcrypt/src/random.c -> wolfcrypt/src/random.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "363:     #endif",
          "364:         if (ret != 0)",
          "365:             break;",
          "368: #endif",
          "370:         if (ret == 0) {",
          "371:             ctr++;",
          "372:             ret = wc_Sha256Update(sha, (byte*)&bits, sizeof(bits));",
          "",
          "[Removed Lines]",
          "367:         if (ret == 0)",
          "369:             ret = wc_Sha256Update(sha, &ctr, sizeof(ctr));",
          "",
          "[Added Lines]",
          "367:         ret = wc_Sha256Update(sha, &ctr, sizeof(ctr));",
          "",
          "---------------"
        ],
        "wolfcrypt/src/rsa.c||wolfcrypt/src/rsa.c": [
          "File: wolfcrypt/src/rsa.c -> wolfcrypt/src/rsa.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1282:         }",
          "1283:     }",
          "1290:     return ret;",
          "1291: }",
          "",
          "[Removed Lines]",
          "1285:     #if !defined(WOLFSSL_NO_MALLOC) || defined(WOLFSSL_STATIC_MEMORY)",
          "1286:         if (msg != NULL) {",
          "1287:             XFREE(msg, heap, DYNAMIC_TYPE_RSA_BUFFER);",
          "1288:         }",
          "1289:     #endif",
          "",
          "[Added Lines]",
          "1285: #if !defined(WOLFSSL_NO_MALLOC) || defined(WOLFSSL_STATIC_MEMORY)",
          "1287:     XFREE(msg, heap, DYNAMIC_TYPE_RSA_BUFFER);",
          "1288: #endif",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2284:     tmp = (mp_int*)XMALLOC(sizeof(mp_int), key->heap, DYNAMIC_TYPE_RSA);",
          "2285:     if (tmp == NULL)",
          "2286:         return MEMORY_E;",
          "2288: #ifdef WC_RSA_BLINDING",
          "2289:     rnd = (mp_int*)XMALLOC(sizeof(mp_int) * 2, key->heap, DYNAMIC_TYPE_RSA);",
          "2290:     if (rnd == NULL) {",
          "2291:         XFREE(tmp, key->heap, DYNAMIC_TYPE_RSA);",
          "2292:         return MEMORY_E;",
          "2293:     }",
          "2294:     rndi = rnd + 1;",
          "2296: #endif",
          "2299:     if (mp_init(tmp) != MP_OKAY)",
          "",
          "[Removed Lines]",
          "2287: #if !defined(WOLFSSL_RSA_PUBLIC_ONLY) && !defined(WOLFSSL_RSA_VERIFY_ONLY)",
          "",
          "[Added Lines]",
          "2287: #if !defined(WOLFSSL_RSA_PUBLIC_ONLY) && !defined(WOLFSSL_RSA_VERIFY_ONLY)",
          "2294: #else",
          "2295:     rnd = NULL;",
          "2296:     rndi = NULL;",
          "",
          "---------------"
        ],
        "wolfcrypt/src/sakke.c||wolfcrypt/src/sakke.c": [
          "File: wolfcrypt/src/sakke.c -> wolfcrypt/src/sakke.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "862: {",
          "863:     int err = 0;",
          "866:         err = BUFFER_E;",
          "867:     }",
          "",
          "[Removed Lines]",
          "865:     if ((err == 0) && (sz != size * 2) && (sz != size * 2 + 1)) {",
          "",
          "[Added Lines]",
          "865:     if ((sz != size * 2) && (sz != size * 2 + 1)) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2523:     if (err == 0) {",
          "2524:         mp_zero(c[0]->y);",
          "2528:         err = mp_mulmod(b, c[0]->x, prime, by);",
          "2529:     }",
          "2530:     for (i = mp_count_bits(&key->params.q) - 1; (err == 0) && (i >= 0); i--) {",
          "",
          "[Removed Lines]",
          "2525:     }",
          "2527:     if (err == 0) {",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "6120:     int err = 0;",
          "6121:     byte h[WC_MAX_DIGEST_SIZE];",
          "6122:     byte v[WC_MAX_DIGEST_SIZE];",
          "6124:     word32 i;",
          "",
          "[Removed Lines]",
          "6123:     word32 hashSz = 0;",
          "",
          "[Added Lines]",
          "6122:     word32 hashSz = 1;",
          "",
          "---------------"
        ],
        "wolfcrypt/src/srp.c||wolfcrypt/src/srp.c": [
          "File: wolfcrypt/src/srp.c -> wolfcrypt/src/srp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "479:         return MP_INIT_E;",
          "483:     if (!r) r = *size < (word32)mp_unsigned_bin_size(&v) ? BUFFER_E : MP_OKAY;",
          "484:     if (!r) r = mp_to_unsigned_bin(&v, verifier);",
          "485:     if (!r) *size = mp_unsigned_bin_size(&v);",
          "",
          "[Removed Lines]",
          "482:     if (!r) r = mp_exptmod(&srp->g, &srp->auth, &srp->N, &v);",
          "",
          "[Added Lines]",
          "482:     r = mp_exptmod(&srp->g, &srp->auth, &srp->N, &v);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "511:     r = mp_init(&p);",
          "512:     if (r != MP_OKAY)",
          "513:         return MP_INIT_E;",
          "515:     if (!r) r = mp_mod(&p, &srp->N, &srp->priv);",
          "516:     if (!r) r = mp_iszero(&srp->priv) == MP_YES ? SRP_BAD_KEY_E : 0;",
          "",
          "[Removed Lines]",
          "514:     if (!r) r = mp_read_unsigned_bin(&p, priv, size);",
          "",
          "[Added Lines]",
          "514:     r = mp_read_unsigned_bin(&p, priv, size);",
          "",
          "---------------"
        ],
        "wolfcrypt/src/wc_port.c||wolfcrypt/src/wc_port.c": [
          "File: wolfcrypt/src/wc_port.c -> wolfcrypt/src/wc_port.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1602:     void *uITRON4_realloc(void *p, size_t sz) {",
          "1603:       ER ercd;",
          "1605:       if(p) {",
          "1606:           ercd = get_mpl(ID_wolfssl_MPOOL, sz, (VP)&newp);",
          "1607:           if (ercd == E_OK) {",
          "",
          "[Removed Lines]",
          "1604:       void *newp;",
          "",
          "[Added Lines]",
          "1604:       void *newp = NULL;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1696:     void *uTKernel_realloc(void *p, unsigned int sz) {",
          "1697:       ER ercd;",
          "1699:       if (p) {",
          "1700:           ercd = tk_get_mpl(ID_wolfssl_MPOOL, sz, (VP)&newp, TMO_FEVR);",
          "1701:           if (ercd == E_OK) {",
          "",
          "[Removed Lines]",
          "1698:       void *newp;",
          "",
          "[Added Lines]",
          "1698:       void *newp = NULL;",
          "",
          "---------------"
        ],
        "wolfcrypt/test/test.c||wolfcrypt/test/test.c": [
          "File: wolfcrypt/test/test.c -> wolfcrypt/test/test.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4639:     h.keyLen = 33;",
          "4640:     h.effectiveKeyBits = 129;",
          "4642:     test_rc2[0] = a;",
          "4643:     test_rc2[1] = b;",
          "4644:     test_rc2[2] = c;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4642:     a.iv = b.iv = c.iv = d.iv = e.iv = f.iv = g.iv = h.iv = NULL;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "4724:     c.input  = \"\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x01\"",
          "4725:                \"\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x01\";",
          "4727:     c.output = \"\\xB5\\x70\\x14\\xA2\\x5F\\x40\\xE3\\x6D\"",
          "4728:                \"\\x81\\x99\\x8D\\xE0\\xB5\\xD5\\x3A\\x05\";",
          "4729:     c.key    = \"\\x30\\x00\\x00\\x00\\x00\\x00\\x00\\x00\";",
          "",
          "[Removed Lines]",
          "4726:     c.output = \"\\x30\\x64\\x9e\\xdf\\x9b\\xe7\\xd2\\xc2\";",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "14769:     !defined(USE_CERT_BUFFERS_3072) && !defined(USE_CERT_BUFFERS_4096) && \\",
          "14770:     !defined(NO_FILESYSTEM)",
          "14771:     XFILE   file;",
          "14772:     XFILE   file2;",
          "14773: #endif",
          "14774: #ifdef WOLFSSL_TEST_CERT",
          "14775: #ifdef WOLFSSL_SMALL_STACK",
          "14776:     DecodedCert *cert = (DecodedCert *)XMALLOC(sizeof *cert, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "14773: #ifdef WOLFSSL_TEST_CERT",
          "14776: #endif",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "15410:         return ret;",
          "15411: #endif",
          "15413: #if defined(WOLFSSL_MDK_ARM)",
          "15414:     #define sizeof(s) XSTRLEN((char *)(s))",
          "15415: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "15416: #if !defined(NO_FILESYSTEM) && !defined(NO_RSA) && !defined(NO_ASN) && \\",
          "15417:     !defined(USE_CERT_BUFFERS_1024) && !defined(USE_CERT_BUFFERS_2048) && \\",
          "15418:     !defined(USE_CERT_BUFFERS_3072) && !defined(USE_CERT_BUFFERS_4096)",
          "15419:     (void)clientCert;",
          "15420: #endif",
          "15422: #ifdef WOLFSSL_TEST_CERT",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "15443:     #undef sizeof",
          "15444: #endif",
          "15447:     InitDecodedCert(cert, tmp, (word32)bytes, 0);",
          "15449:     ret = ParseCert(cert, CERT_TYPE, NO_VERIFY, 0);",
          "",
          "[Removed Lines]",
          "15446: #ifdef WOLFSSL_TEST_CERT",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "15453:     }",
          "15455:     FreeDecodedCert(cert);",
          "15458: #ifdef WOLFSSL_CERT_EXT",
          "",
          "[Removed Lines]",
          "15456: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "18044:     ret = EVP_DigestInit(&md_ctx, EVP_md5());",
          "18045:     if (ret == WOLFSSL_SUCCESS) {",
          "18046:         ret = EVP_DigestUpdate(&md_ctx, a.input, (unsigned long)a.inLen);",
          "18049:     }",
          "18050:     EVP_MD_CTX_cleanup(&md_ctx);",
          "18051:     if (ret != WOLFSSL_SUCCESS ||",
          "",
          "[Removed Lines]",
          "18047:         if (ret == WOLFSSL_SUCCESS)",
          "18048:             ret = EVP_DigestFinal(&md_ctx, hash, 0);",
          "",
          "[Added Lines]",
          "18056:     }",
          "18057:     if (ret == WOLFSSL_SUCCESS) {",
          "18058:         ret = EVP_DigestFinal(&md_ctx, hash, 0);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "23470: #ifndef WC_NO_RNG",
          "23471:     if (ret != 0)",
          "23472:         return -10300;",
          "23473: #endif",
          "23475: #if (defined(HAVE_ECC112) || defined(HAVE_ALL_CURVES)) && ECC_MIN_KEY_SZ <= 112",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "23483: #else",
          "23484:     (void)ret;",
          "",
          "---------------"
        ],
        "wolfcrypt/user-crypto/src/rsa.c||wolfcrypt/user-crypto/src/rsa.c": [
          "File: wolfcrypt/user-crypto/src/rsa.c -> wolfcrypt/user-crypto/src/rsa.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1644: {",
          "1645:     int sz, pSz, qSz;",
          "1646:     IppStatus ret;",
          "1649:     IppsMontState* pMont = NULL;",
          "1650:     IppsMontState* qMont = NULL;",
          "",
          "[Removed Lines]",
          "1647:     word32 outSz = outLen;",
          "",
          "[Added Lines]",
          "1647:     word32 outSz;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "35ec2bc6d467c218fb068a9aaf60b4aa2bea7b63",
      "candidate_info": {
        "commit_hash": "35ec2bc6d467c218fb068a9aaf60b4aa2bea7b63",
        "repo": "wolfSSL/wolfssl",
        "commit_url": "https://github.com/wolfSSL/wolfssl/commit/35ec2bc6d467c218fb068a9aaf60b4aa2bea7b63",
        "files": [
          "tests/api.c",
          "wolfcrypt/src/error.c",
          "wolfcrypt/src/rsa.c",
          "wolfcrypt/test/test.c",
          "wolfssl/wolfcrypt/error-crypt.h"
        ],
        "message": "Compile options for larger salt lengths in RSA-PSS\n\nSalt length larger than the hash size allowed in RSA-PSS.\nPassing -2 to PSS pad function uses maximum salt length.\nPassing -2 to PSS un-pad function makes it discover salt length.",
        "before_after_code_files": [
          "tests/api.c||tests/api.c",
          "wolfcrypt/src/error.c||wolfcrypt/src/error.c",
          "wolfcrypt/src/rsa.c||wolfcrypt/src/rsa.c",
          "wolfcrypt/test/test.c||wolfcrypt/test/test.c",
          "wolfssl/wolfcrypt/error-crypt.h||wolfssl/wolfcrypt/error-crypt.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "wolfcrypt/src/rsa.c||wolfcrypt/src/rsa.c"
          ],
          "candidate": [
            "wolfcrypt/src/rsa.c||wolfcrypt/src/rsa.c"
          ]
        }
      },
      "candidate_diff": {
        "tests/api.c||tests/api.c": [
          "File: tests/api.c -> tests/api.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "22310:     AssertNotNull(bio = BIO_new(BIO_s_mem()));",
          "22312:     ERR_put_error(0,SYS_F_ACCEPT, -173, \"ssl.c\", 0);",
          "22315:     ERR_print_errors(bio);",
          "22316:     AssertIntEQ(BIO_gets(bio, buf, sizeof(buf)), 56);",
          "22317:     AssertIntEQ(XSTRNCMP(\"error:173:wolfSSL library:Bad function argument:ssl.c:0\",",
          "22318:                 buf, 55), 0);",
          "22319:     AssertIntEQ(BIO_gets(bio, buf, sizeof(buf)), 57);",
          "22321:                 buf, 56), 0);",
          "22322:     AssertIntEQ(BIO_gets(bio, buf, sizeof(buf)), 0);",
          "22323:     AssertIntEQ(ERR_get_error_line(NULL, NULL), 0);",
          "",
          "[Removed Lines]",
          "22313:     ERR_put_error(0,SYS_F_BIND, -273, \"asn.c\", 100);",
          "22320:     AssertIntEQ(XSTRNCMP(\"error:273:wolfSSL library:unknown error number:asn.c:100\",",
          "",
          "[Added Lines]",
          "22313:     ERR_put_error(0,SYS_F_BIND, -283, \"asn.c\", 100);",
          "22320:     AssertIntEQ(XSTRNCMP(\"error:283:wolfSSL library:unknown error number:asn.c:100\",",
          "",
          "---------------"
        ],
        "wolfcrypt/src/error.c||wolfcrypt/src/error.c": [
          "File: wolfcrypt/src/error.c -> wolfcrypt/src/error.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "509:     case PKCS7_SIGNEEDS_CHECK:",
          "510:         return \"Signature found but no certificate to verify\";",
          "512:     default:",
          "513:         return \"unknown error number\";",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "512:     case PSS_SALTLEN_RECOVER_E:",
          "513:         return \"PSS - Salt length unable to be recovered\";",
          "",
          "---------------"
        ],
        "wolfcrypt/src/rsa.c||wolfcrypt/src/rsa.c": [
          "File: wolfcrypt/src/rsa.c -> wolfcrypt/src/rsa.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1002:         word32 pkcsBlockLen, WC_RNG* rng, enum wc_HashType hType, int mgf,",
          "1003:         int saltLen, int bits, void* heap)",
          "1004: {",
          "1008:     byte* m;",
          "1012:     hLen = wc_HashGetDigestSize(hType);",
          "1013:     if (hLen < 0)",
          "1014:         return hLen;",
          "1016:     if (saltLen == -1) {",
          "1017:         saltLen = hLen;",
          "1018:         #ifdef WOLFSSL_SHA512",
          "1021:                 saltLen = RSA_PSS_SALT_MAX_SZ;",
          "1022:         #endif",
          "1023:     }",
          "1025:         return PSS_SALTLEN_E;",
          "1027:         return PSS_SALTLEN_E;",
          "1029:     s = m = pkcsBlock;",
          "1030:     XMEMSET(m, 0, RSA_PSS_PAD_SZ);",
          "1031:     m += RSA_PSS_PAD_SZ;",
          "1032:     XMEMCPY(m, input, inputLen);",
          "1033:     m += inputLen;",
          "1055: }",
          "",
          "[Removed Lines]",
          "1005:     int   ret;",
          "1006:     int   hLen, i;",
          "1007:     byte* s;",
          "1009:     byte* h;",
          "1010:     byte  salt[WC_MAX_DIGEST_SIZE];",
          "1020:             if (bits == 1024 && hLen == WC_SHA512_DIGEST_SIZE)",
          "1024:     else if (saltLen > hLen || saltLen < -1)",
          "1026:     if ((int)pkcsBlockLen - hLen < saltLen + 2)",
          "1034:     if ((ret = wc_RNG_GenerateBlock(rng, salt, saltLen)) != 0)",
          "1035:         return ret;",
          "1036:     XMEMCPY(m, salt, saltLen);",
          "1037:     m += saltLen;",
          "1039:     h = pkcsBlock + pkcsBlockLen - 1 - hLen;",
          "1040:     if ((ret = wc_Hash(hType, s, (word32)(m - s), h, hLen)) != 0)",
          "1041:         return ret;",
          "1042:     pkcsBlock[pkcsBlockLen - 1] = RSA_PSS_PAD_TERM;",
          "1044:     ret = RsaMGF(mgf, h, hLen, pkcsBlock, pkcsBlockLen - hLen - 1, heap);",
          "1045:     if (ret != 0)",
          "1046:         return ret;",
          "1047:     pkcsBlock[0] &= (1 << ((bits - 1) & 0x7)) - 1;",
          "1049:     m = pkcsBlock + pkcsBlockLen - 1 - saltLen - hLen - 1;",
          "1051:     for (i = 0; i < saltLen; i++)",
          "1052:         m[i] ^= salt[i];",
          "1054:     return 0;",
          "",
          "[Added Lines]",
          "1005:     int   ret = 0;",
          "1006:     int   hLen, i, o, maskLen, hiBits;",
          "1008:     byte* s;",
          "1009: #if defined(WOLFSSL_PSS_LONG_SALT) || defined(WOLFSSL_PSS_SALT_LEN_DISCOVER)",
          "1010:     #if defined(WOLFSSL_NO_MALLOC) && !defined(WOLFSSL_STATIC_MEMORY)",
          "1011:         byte salt[RSA_MAX_SIZE/8 + RSA_PSS_PAD_SZ];",
          "1012:     #else",
          "1013:         byte* salt = NULL;",
          "1014:     #endif",
          "1015: #else",
          "1016:     byte salt[WC_MAX_DIGEST_SIZE];",
          "1017: #endif",
          "1019: #if defined(WOLFSSL_PSS_LONG_SALT) || defined(WOLFSSL_PSS_SALT_LEN_DISCOVER)",
          "1020:     if (pkcsBlockLen > RSA_MAX_SIZE/8) {",
          "1021:         return MEMORY_E;",
          "1022:     }",
          "1023: #endif",
          "1029:     hiBits = (bits - 1) & 0x7;",
          "1030:     if (hiBits == 0) {",
          "1032:         pkcsBlockLen--;",
          "1033:     }",
          "1039:             if (bits == 1024 && hLen == WC_SHA512_DIGEST_SIZE) {",
          "1041:             }",
          "1044: #ifndef WOLFSSL_PSS_LONG_SALT",
          "1045:     else if (saltLen > hLen) {",
          "1046:         return PSS_SALTLEN_E;",
          "1047:     }",
          "1048: #endif",
          "1049: #ifndef WOLFSSL_PSS_SALT_LEN_DISCOVER",
          "1050:     else if (saltLen < -1) {",
          "1052:     }",
          "1053: #else",
          "1054:     else if (saltLen == -2) {",
          "1055:         saltLen = (int)pkcsBlockLen - hLen - 2;",
          "1056:         if (saltLen < 0) {",
          "1057:             return PSS_SALTLEN_E;",
          "1058:         }",
          "1059:     }",
          "1060:     else if (saltLen < -2) {",
          "1062:     }",
          "1063: #endif",
          "1064:     if ((int)pkcsBlockLen - hLen < saltLen + 2) {",
          "1065:         return PSS_SALTLEN_E;",
          "1066:     }",
          "1068:     maskLen = pkcsBlockLen - 1 - hLen;",
          "1070: #if defined(WOLFSSL_PSS_LONG_SALT) || defined(WOLFSSL_PSS_SALT_LEN_DISCOVER)",
          "1071:     #if !defined(WOLFSSL_NO_MALLOC) || defined(WOLFSSL_STATIC_MEMORY)",
          "1072:         salt = (byte*)XMALLOC(RSA_PSS_PAD_SZ + inputLen + saltLen, heap,",
          "1073:                                                        DYNAMIC_TYPE_RSA_BUFFER);",
          "1074:         if (salt == NULL) {",
          "1075:             return MEMORY_E;",
          "1076:         }",
          "1077:     #endif",
          "1078:     s = m = salt;",
          "1079:     XMEMSET(m, 0, RSA_PSS_PAD_SZ);",
          "1080:     m += RSA_PSS_PAD_SZ;",
          "1081:     XMEMCPY(m, input, inputLen);",
          "1082:     m += inputLen;",
          "1083:     o = (int)(m - s);",
          "1084:     if (saltLen > 0) {",
          "1085:         ret = wc_RNG_GenerateBlock(rng, m, saltLen);",
          "1086:         if (ret == 0) {",
          "1087:             m += saltLen;",
          "1088:         }",
          "1089:     }",
          "1090: #else",
          "1096:     o = 0;",
          "1097:     if (saltLen > 0) {",
          "1098:         ret = wc_RNG_GenerateBlock(rng, salt, saltLen);",
          "1099:         if (ret == 0) {",
          "1100:             XMEMCPY(m, salt, saltLen);",
          "1101:             m += saltLen;",
          "1102:         }",
          "1103:     }",
          "1104: #endif",
          "1105:     if (ret == 0) {",
          "1107:         ret = wc_Hash(hType, s, (word32)(m - s), pkcsBlock + maskLen, hLen);",
          "1108:     }",
          "1109:     if (ret == 0) {",
          "1110:         pkcsBlock[pkcsBlockLen - 1] = RSA_PSS_PAD_TERM;",
          "1112:         ret = RsaMGF(mgf, pkcsBlock + maskLen, hLen, pkcsBlock, maskLen, heap);",
          "1113:     }",
          "1114:     if (ret == 0) {",
          "1115:         pkcsBlock[0] &= (1 << hiBits) - 1;",
          "1117:         m = pkcsBlock + maskLen - saltLen - 1;",
          "1119:         for (i = 0; i < saltLen; i++) {",
          "1120:             m[i] ^= salt[o + i];",
          "1121:         }",
          "1122:     }",
          "1124: #if defined(WOLFSSL_PSS_LONG_SALT) || defined(WOLFSSL_PSS_SALT_LEN_DISCOVER)",
          "1125:     #if !defined(WOLFSSL_NO_MALLOC) || defined(WOLFSSL_STATIC_MEMORY)",
          "1126:         if (salt != NULL) {",
          "1127:             XFREE(salt, heap, DYNAMIC_TYPE_RSA_BUFFER);",
          "1128:         }",
          "1129:     #endif",
          "1130: #endif",
          "1131:     return ret;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1294: {",
          "1295:     int   ret;",
          "1296:     byte* tmp;",
          "1298: #if defined(WOLFSSL_NO_MALLOC) && !defined(WOLFSSL_STATIC_MEMORY)",
          "1299:     byte tmp_buf[RSA_MAX_SIZE/8];",
          "1300:     tmp = tmp_buf;",
          "",
          "[Removed Lines]",
          "1297:     int   hLen, i;",
          "",
          "[Added Lines]",
          "1374:     int   hLen, i, maskLen;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1307:     hLen = wc_HashGetDigestSize(hType);",
          "1308:     if (hLen < 0)",
          "1309:         return hLen;",
          "1311:     if (saltLen == -1) {",
          "1312:         saltLen = hLen;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1387:     bits = (bits - 1) & 0x7;",
          "1388:     if ((pkcsBlock[0] & (0xff << bits)) != 0) {",
          "1389:         return BAD_PADDING_E;",
          "1390:     }",
          "1391:     if (bits == 0) {",
          "1392:         pkcsBlock++;",
          "1393:         pkcsBlockLen--;",
          "1394:     }",
          "1395:     maskLen = (int)pkcsBlockLen - 1 - hLen;",
          "1396:     if (maskLen < 0) {",
          "1397:         WOLFSSL_MSG(\"RsaUnPad_PSS: Hash too large\");",
          "1398:         return WC_KEY_SIZE_E;",
          "1399:     }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1316:                 saltLen = RSA_PSS_SALT_MAX_SZ;",
          "1317:         #endif",
          "1318:     }",
          "1320:         return PSS_SALTLEN_E;",
          "1322:         return PSS_SALTLEN_E;",
          "1324:     if (pkcsBlock[pkcsBlockLen - 1] != RSA_PSS_PAD_TERM) {",
          "1325:         WOLFSSL_MSG(\"RsaUnPad_PSS: Padding Term Error\");",
          "",
          "[Removed Lines]",
          "1319:     else if (saltLen > hLen || saltLen < -1)",
          "1321:     if ((int)pkcsBlockLen - hLen < saltLen + 2)",
          "",
          "[Added Lines]",
          "1409: #ifndef WOLFSSL_PSS_LONG_SALT",
          "1410:     else if (saltLen > hLen)",
          "1411:         return PSS_SALTLEN_E;",
          "1412: #endif",
          "1413: #ifndef WOLFSSL_PSS_SALT_LEN_DISCOVER",
          "1414:     else if (saltLen < -1)",
          "1416:     if (maskLen < saltLen + 1) {",
          "1418:     }",
          "1419: #else",
          "1420:     else if (saltLen < -2)",
          "1421:         return PSS_SALTLEN_E;",
          "1422:     if (saltLen != -2 && maskLen < saltLen + 1) {",
          "1423:         return WC_KEY_SIZE_E;",
          "1424:     }",
          "1425: #endif",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1327:     }",
          "1329: #if !defined(WOLFSSL_NO_MALLOC) || defined(WOLFSSL_STATIC_MEMORY)",
          "1332:         return MEMORY_E;",
          "1333: #endif",
          "1337:         XFREE(tmp, heap, DYNAMIC_TYPE_RSA_BUFFER);",
          "1338:         return ret;",
          "1339:     }",
          "1344:             XFREE(tmp, heap, DYNAMIC_TYPE_RSA_BUFFER);",
          "1345:             WOLFSSL_MSG(\"RsaUnPad_PSS: Padding Error Match\");",
          "1347:         }",
          "1348:     }",
          "1353:     }",
          "1355:         pkcsBlock[i] ^= tmp[i];",
          "1357: #if !defined(WOLFSSL_NO_MALLOC) || defined(WOLFSSL_STATIC_MEMORY)",
          "1358:     XFREE(tmp, heap, DYNAMIC_TYPE_RSA_BUFFER);",
          "1359: #endif",
          "1362:     return saltLen + hLen;",
          "1363: }",
          "1364: #endif",
          "",
          "[Removed Lines]",
          "1330:     tmp = (byte*)XMALLOC(pkcsBlockLen, heap, DYNAMIC_TYPE_RSA_BUFFER);",
          "1331:     if (tmp == NULL)",
          "1335:     if ((ret = RsaMGF(mgf, pkcsBlock + pkcsBlockLen - 1 - hLen, hLen,",
          "1336:                                     tmp, pkcsBlockLen - 1 - hLen, heap)) != 0) {",
          "1341:     tmp[0] &= (1 << ((bits - 1) & 0x7)) - 1;",
          "1342:     for (i = 0; i < (int)(pkcsBlockLen - 1 - saltLen - hLen - 1); i++) {",
          "1343:         if (tmp[i] != pkcsBlock[i]) {",
          "1346:             return BAD_PADDING_E;",
          "1349:     if (tmp[i] != (pkcsBlock[i] ^ 0x01)) {",
          "1350:         XFREE(tmp, heap, DYNAMIC_TYPE_RSA_BUFFER);",
          "1351:         WOLFSSL_MSG(\"RsaUnPad_PSS: Padding Error End\");",
          "1352:         return BAD_PADDING_E;",
          "1354:     for (i++; i < (int)(pkcsBlockLen - 1 - hLen); i++)",
          "",
          "[Added Lines]",
          "1433:     tmp = (byte*)XMALLOC(maskLen, heap, DYNAMIC_TYPE_RSA_BUFFER);",
          "1434:     if (tmp == NULL) {",
          "1436:     }",
          "1439:     if ((ret = RsaMGF(mgf, pkcsBlock + maskLen, hLen, tmp, maskLen,",
          "1440:                                                                   heap)) != 0) {",
          "1445:     tmp[0] &= (1 << bits) - 1;",
          "1446:     pkcsBlock[0] &= (1 << bits) - 1;",
          "1447: #ifdef WOLFSSL_PSS_SALT_LEN_DISCOVER",
          "1448:     if (saltLen == -2) {",
          "1449:         for (i = 0; i < maskLen - 1; i++) {",
          "1450:             if (tmp[i] != pkcsBlock[i]) {",
          "1451:                 break;",
          "1452:             }",
          "1453:         }",
          "1454:         if (tmp[i] != (pkcsBlock[i] ^ 0x01)) {",
          "1457:             return PSS_SALTLEN_RECOVER_E;",
          "1459:         saltLen = maskLen - (i + 1);",
          "1461:     else",
          "1462: #endif",
          "1463:     {",
          "1464:         for (i = 0; i < maskLen - 1 - saltLen; i++) {",
          "1465:             if (tmp[i] != pkcsBlock[i]) {",
          "1466:                 XFREE(tmp, heap, DYNAMIC_TYPE_RSA_BUFFER);",
          "1467:                 WOLFSSL_MSG(\"RsaUnPad_PSS: Padding Error Match\");",
          "1468:                 return PSS_SALTLEN_E;",
          "1469:             }",
          "1470:         }",
          "1471:         if (tmp[i] != (pkcsBlock[i] ^ 0x01)) {",
          "1472:             XFREE(tmp, heap, DYNAMIC_TYPE_RSA_BUFFER);",
          "1473:             WOLFSSL_MSG(\"RsaUnPad_PSS: Padding Error End\");",
          "1474:             return PSS_SALTLEN_E;",
          "1475:         }",
          "1477:     for (i++; i < maskLen; i++)",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1469:                 WOLFSSL_MSG(\"Bad input size\");",
          "1470:                 ret = RSA_PAD_E;",
          "1471:             }",
          "",
          "[Removed Lines]",
          "1468:             if (bits <= 0 || pkcsBlockLen != ((word32)bits/WOLFSSL_BIT_SIZE)) {",
          "",
          "[Added Lines]",
          "1591:             if (bits <= 0 || pkcsBlockLen !=",
          "1592:                          ((word32)(bits+WOLFSSL_BIT_SIZE-1)/WOLFSSL_BIT_SIZE)) {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "2910: int wc_RsaPSS_VerifyInline(byte* in, word32 inLen, byte** out,",
          "2911:                            enum wc_HashType hash, int mgf, RsaKey* key)",
          "2912: {",
          "2913:     return wc_RsaPSS_VerifyInline_ex(in, inLen, out, hash, mgf, -1, key);",
          "2914: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3037: #ifndef WOLFSSL_PSS_SALT_LEN_DISCOVER",
          "3039: #else",
          "3040:     return wc_RsaPSS_VerifyInline_ex(in, inLen, out, hash, mgf, -2, key);",
          "3041: #endif",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "2953: int wc_RsaPSS_Verify(byte* in, word32 inLen, byte* out, word32 outLen,",
          "2954:                      enum wc_HashType hash, int mgf, RsaKey* key)",
          "2955: {",
          "2956:     return wc_RsaPSS_Verify_ex(in, inLen, out, outLen, hash, mgf, -1, key);",
          "2957: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3084: #ifndef WOLFSSL_PSS_SALT_LEN_DISCOVER",
          "3086: #else",
          "3087:     return wc_RsaPSS_Verify_ex(in, inLen, out, outLen, hash, mgf, -2, key);",
          "3088: #endif",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "3018:                               int saltLen, int bits)",
          "3019: {",
          "3020:     int ret = 0;",
          "3021:     byte sigCheck[WC_MAX_DIGEST_SIZE*2 + RSA_PSS_PAD_SZ];",
          "3023:     (void)bits;",
          "3025:     if (in == NULL || sig == NULL ||",
          "3027:         ret = BAD_FUNC_ARG;",
          "3029:     if (ret == 0) {",
          "3030:         if (saltLen == -1) {",
          "3031:             saltLen = inSz;",
          "3032:             #ifdef WOLFSSL_SHA512",
          "3035:                     saltLen = RSA_PSS_SALT_MAX_SZ;",
          "3036:             #endif",
          "3037:         }",
          "3039:             ret = PSS_SALTLEN_E;",
          "3040:     }",
          "3043:     if (ret == 0) {",
          "3046:     }",
          "3049:     if (ret == 0) {",
          "",
          "[Removed Lines]",
          "3026:                       inSz != (word32)wc_HashGetDigestSize(hashType))",
          "3034:                 if (bits == 1024 && inSz == WC_SHA512_DIGEST_SIZE)",
          "3038:         else if (saltLen < -1 || (word32)saltLen > inSz)",
          "3044:         if (sigSz != inSz + saltLen)",
          "3045:             ret = BAD_PADDING_E;",
          "",
          "[Added Lines]",
          "3153: #ifndef WOLFSSL_PSS_LONG_SALT",
          "3155: #else",
          "3156:     byte *sigCheck = NULL;",
          "3157: #endif",
          "3162:                                inSz != (word32)wc_HashGetDigestSize(hashType)) {",
          "3164:     }",
          "3171:                 if (bits == 1024 && inSz == WC_SHA512_DIGEST_SIZE) {",
          "3173:                 }",
          "3176: #ifndef WOLFSSL_PSS_LONG_SALT",
          "3177:         else if ((word32)saltLen > inSz) {",
          "3179:         }",
          "3180: #endif",
          "3181: #ifndef WOLFSSL_PSS_SALT_LEN_DISCOVER",
          "3182:         else if (saltLen < -1) {",
          "3183:             ret = PSS_SALTLEN_E;",
          "3184:         }",
          "3185: #else",
          "3186:         else if (saltLen == -2) {",
          "3187:             saltLen = sigSz - inSz;",
          "3188:             if (saltLen < 0) {",
          "3189:                 ret = PSS_SALTLEN_E;",
          "3190:             }",
          "3191:         }",
          "3192:         else if (saltLen < -2) {",
          "3193:             ret = PSS_SALTLEN_E;",
          "3194:         }",
          "3195: #endif",
          "3200:         if (sigSz != inSz + saltLen) {",
          "3201:             ret = PSS_SALTLEN_E;",
          "3202:         }",
          "3203:     }",
          "3205: #ifdef WOLFSSL_PSS_LONG_SALT",
          "3206:     if (ret == 0) {",
          "3207:         sigCheck = (byte*)XMALLOC(RSA_PSS_PAD_SZ + inSz + saltLen, NULL,",
          "3208:                                                        DYNAMIC_TYPE_RSA_BUFFER);",
          "3209:         if (sigCheck == NULL) {",
          "3210:             ret = MEMORY_E;",
          "3211:         }",
          "3213: #endif",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "3060:         }",
          "3061:     }",
          "3063:     return ret;",
          "3064: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3230: #ifdef WOLFSSL_PSS_LONG_SALT",
          "3231:     if (sigCheck != NULL) {",
          "3232:         XFREE(sigCheck, NULL, DYNAMIC_TYPE_RSA_BUFFER);",
          "3233:     }",
          "3234: #endif",
          "",
          "---------------"
        ],
        "wolfcrypt/test/test.c||wolfcrypt/test/test.c": [
          "File: wolfcrypt/test/test.c -> wolfcrypt/test/test.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "10526: #ifdef RSA_PSS_TEST_WRONG_PARAMS",
          "10527:     int              k, l;",
          "10528: #endif",
          "10529:     byte*            plain;",
          "10530:     int              mgf[]   = {",
          "10531: #ifndef NO_SHA",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "10529:     int              len;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "10723:     digestSz = wc_HashGetDigestSize(hash[0]);",
          "10724:     outSz = RSA_TEST_BYTES;",
          "10725:     do {",
          "10726:     #if defined(WOLFSSL_ASYNC_CRYPT)",
          "10727:         ret = wc_AsyncWait(ret, &key->asyncDev,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "10726: #ifndef WOLFSSL_PSS_SALT_LEN_DISCOVER",
          "10727:     len = -2;",
          "10728: #else",
          "10729:     len = -3;",
          "10730: #endif",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "10729:     #endif",
          "10730:         if (ret >= 0) {",
          "10731:             ret = wc_RsaPSS_Sign_ex(digest, digestSz, out, outSz, hash[0],",
          "10733:         }",
          "10734:     } while (ret == WC_PENDING_E);",
          "10735:     if (ret != PSS_SALTLEN_E)",
          "",
          "[Removed Lines]",
          "10732:                 mgf[0], -2, key, rng);",
          "",
          "[Added Lines]",
          "10738:                 mgf[0], len, key, rng);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "10777:         ERROR_OUT(-6830, exit_rsa_pss);",
          "10778:     TEST_SLEEP();",
          "10780: #ifdef HAVE_SELFTEST",
          "10781:     ret = wc_RsaPSS_CheckPadding_ex(digest, digestSz, plain, plainSz, hash[0],",
          "10783: #else",
          "10784:     ret = wc_RsaPSS_CheckPadding_ex(digest, digestSz, plain, plainSz, hash[0],",
          "10786: #endif",
          "10787:     if (ret != PSS_SALTLEN_E)",
          "10788:         ERROR_OUT(-6831, exit_rsa_pss);",
          "10789: #ifdef HAVE_SELFTEST",
          "10790:     ret = wc_RsaPSS_CheckPadding_ex(digest, digestSz, plain, plainSz, hash[0],",
          "10792: #else",
          "10793:     ret = wc_RsaPSS_CheckPadding_ex(digest, digestSz, plain, plainSz, hash[0],",
          "10795: #endif",
          "10796:     if (ret != PSS_SALTLEN_E)",
          "10797:         ERROR_OUT(-6832, exit_rsa_pss);",
          "",
          "[Removed Lines]",
          "10782:                                     -2);",
          "10785:                                     -2, 0);",
          "10791:                                     digestSz + 1);",
          "10794:                                     digestSz + 1, 0);",
          "",
          "[Added Lines]",
          "10786: #ifndef WOLFSSL_PSS_SALT_LEN_DISCOVER",
          "10787:     len = -2;",
          "10788: #else",
          "10789:     len = -3;",
          "10790: #endif",
          "10793:                                     len);",
          "10796:                                     len, 0);",
          "10800: #ifndef WOLFSSL_PSS_LONG_SALT",
          "10801:     len = digestSz + 1;",
          "10802: #else",
          "10803:     len = plainSz - digestSz - 1;",
          "10804: #endif",
          "10807:                                     len);",
          "10810:                                     len, 0);",
          "",
          "---------------"
        ],
        "wolfssl/wolfcrypt/error-crypt.h||wolfssl/wolfcrypt/error-crypt.h": [
          "File: wolfssl/wolfcrypt/error-crypt.h -> wolfssl/wolfcrypt/error-crypt.h"
        ]
      }
    },
    {
      "candidate_hash": "cebb28382243707a435c12db370f1c1a1e4741e3",
      "candidate_info": {
        "commit_hash": "cebb28382243707a435c12db370f1c1a1e4741e3",
        "repo": "wolfSSL/wolfssl",
        "commit_url": "https://github.com/wolfSSL/wolfssl/commit/cebb28382243707a435c12db370f1c1a1e4741e3",
        "files": [
          "tests/api.c",
          "wolfcrypt/src/aes.c",
          "wolfcrypt/src/asn.c",
          "wolfcrypt/src/chacha.c",
          "wolfcrypt/src/chacha20_poly1305.c",
          "wolfcrypt/src/error.c",
          "wolfcrypt/src/misc.c",
          "wolfcrypt/src/poly1305.c",
          "wolfcrypt/src/random.c",
          "wolfcrypt/src/rsa.c",
          "wolfcrypt/src/sha256.c",
          "wolfcrypt/src/sp_int.c",
          "wolfssl/wolfcrypt/aes.h",
          "wolfssl/wolfcrypt/asn.h",
          "wolfssl/wolfcrypt/asn_public.h",
          "wolfssl/wolfcrypt/chacha.h",
          "wolfssl/wolfcrypt/chacha20_poly1305.h",
          "wolfssl/wolfcrypt/error-crypt.h",
          "wolfssl/wolfcrypt/misc.h",
          "wolfssl/wolfcrypt/poly1305.h",
          "wolfssl/wolfcrypt/rsa.h",
          "wolfssl/wolfcrypt/sp_int.h",
          "wolfssl/wolfcrypt/types.h",
          "wolfssl/wolfcrypt/wolfmath.h"
        ],
        "message": "DO-178 changes",
        "before_after_code_files": [
          "tests/api.c||tests/api.c",
          "wolfcrypt/src/aes.c||wolfcrypt/src/aes.c",
          "wolfcrypt/src/asn.c||wolfcrypt/src/asn.c",
          "wolfcrypt/src/chacha.c||wolfcrypt/src/chacha.c",
          "wolfcrypt/src/chacha20_poly1305.c||wolfcrypt/src/chacha20_poly1305.c",
          "wolfcrypt/src/error.c||wolfcrypt/src/error.c",
          "wolfcrypt/src/misc.c||wolfcrypt/src/misc.c",
          "wolfcrypt/src/poly1305.c||wolfcrypt/src/poly1305.c",
          "wolfcrypt/src/random.c||wolfcrypt/src/random.c",
          "wolfcrypt/src/rsa.c||wolfcrypt/src/rsa.c",
          "wolfcrypt/src/sha256.c||wolfcrypt/src/sha256.c",
          "wolfcrypt/src/sp_int.c||wolfcrypt/src/sp_int.c",
          "wolfssl/wolfcrypt/aes.h||wolfssl/wolfcrypt/aes.h",
          "wolfssl/wolfcrypt/asn.h||wolfssl/wolfcrypt/asn.h",
          "wolfssl/wolfcrypt/asn_public.h||wolfssl/wolfcrypt/asn_public.h",
          "wolfssl/wolfcrypt/chacha.h||wolfssl/wolfcrypt/chacha.h",
          "wolfssl/wolfcrypt/chacha20_poly1305.h||wolfssl/wolfcrypt/chacha20_poly1305.h",
          "wolfssl/wolfcrypt/error-crypt.h||wolfssl/wolfcrypt/error-crypt.h",
          "wolfssl/wolfcrypt/misc.h||wolfssl/wolfcrypt/misc.h",
          "wolfssl/wolfcrypt/poly1305.h||wolfssl/wolfcrypt/poly1305.h",
          "wolfssl/wolfcrypt/rsa.h||wolfssl/wolfcrypt/rsa.h",
          "wolfssl/wolfcrypt/sp_int.h||wolfssl/wolfcrypt/sp_int.h",
          "wolfssl/wolfcrypt/types.h||wolfssl/wolfcrypt/types.h",
          "wolfssl/wolfcrypt/wolfmath.h||wolfssl/wolfcrypt/wolfmath.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "wolfcrypt/src/rsa.c||wolfcrypt/src/rsa.c"
          ],
          "candidate": [
            "wolfcrypt/src/rsa.c||wolfcrypt/src/rsa.c"
          ]
        }
      },
      "candidate_diff": {
        "tests/api.c||tests/api.c": [
          "File: tests/api.c -> tests/api.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "13220:         if (ret == 0) {",
          "13221:             ret = wc_RsaPrivateKeyDecode(NULL, &idx, &key, (word32)bytes);",
          "13223:                 ret = wc_RsaPrivateKeyDecode(tmp, NULL, &key, (word32)bytes);",
          "13224:             }",
          "13225:             if (ret == BAD_FUNC_ARG) {",
          "13226:                 ret = wc_RsaPrivateKeyDecode(tmp, &idx, NULL, (word32)bytes);",
          "13227:             }",
          "13229:                 ret = 0;",
          "13230:             } else {",
          "13231:                 ret = WOLFSSL_FATAL_ERROR;",
          "",
          "[Removed Lines]",
          "13222:             if (ret == ASN_PARSE_E) {",
          "13228:             if (ret == ASN_PARSE_E) {",
          "",
          "[Added Lines]",
          "13217:             if (ret == BAD_FUNC_ARG) {",
          "13223:             if (ret == BAD_FUNC_ARG) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "27367:     AssertNotNull(bio = BIO_new(BIO_s_mem()));",
          "27369:     ERR_put_error(0,SYS_F_ACCEPT, -173, \"ssl.c\", 0);",
          "27372:     ERR_print_errors(bio);",
          "27373:     AssertIntEQ(BIO_gets(bio, buf, sizeof(buf)), 56);",
          "27374:     AssertIntEQ(XSTRNCMP(\"error:173:wolfSSL library:Bad function argument:ssl.c:0\",",
          "27375:                 buf, 55), 0);",
          "27376:     AssertIntEQ(BIO_gets(bio, buf, sizeof(buf)), 57);",
          "27378:                 buf, 56), 0);",
          "27379:     AssertIntEQ(BIO_gets(bio, buf, sizeof(buf)), 0);",
          "27380:     AssertIntEQ(ERR_get_error_line(NULL, NULL), 0);",
          "",
          "[Removed Lines]",
          "27370:     ERR_put_error(0,SYS_F_BIND, -275, \"asn.c\", 100);",
          "27377:     AssertIntEQ(XSTRNCMP(\"error:275:wolfSSL library:unknown error number:asn.c:100\",",
          "",
          "[Added Lines]",
          "27365:     ERR_put_error(0,SYS_F_BIND, -295, \"asn.c\", 100);",
          "27372:     AssertIntEQ(XSTRNCMP(\"error:295:wolfSSL library:unknown error number:asn.c:100\",",
          "",
          "---------------"
        ],
        "wolfcrypt/src/aes.c||wolfcrypt/src/aes.c": [
          "File: wolfcrypt/src/aes.c -> wolfcrypt/src/aes.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "23: #ifdef HAVE_CONFIG_H",
          "24:     #include <config.h>",
          "25: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "24: DESCRIPTION",
          "25: This library provides the interfaces to the Advanced Encryption Standard (AES)",
          "26: for encrypting and decrypting data. AES is the standard known for a symmetric",
          "27: block cipher mechanism that uses n-bit binary string parameter key with 128-bits,",
          "28: 192-bits, and 256-bits of key sizes.",
          "",
          "---------------"
        ],
        "wolfcrypt/src/asn.c||wolfcrypt/src/asn.c": [
          "File: wolfcrypt/src/asn.c -> wolfcrypt/src/asn.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "23: #ifdef HAVE_CONFIG_H",
          "24:     #include <config.h>",
          "25: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "24: DESCRIPTION",
          "25: This library provides the interface to Abstract Syntax Notation One (ASN.1) objects.",
          "26: ASN.1 is a standard interface description language for defining data structures",
          "27: that can be serialized and deserialized in a cross-platform way.",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2581: {",
          "2582:     int version, length;",
          "2585:         return BAD_FUNC_ARG;",
          "2586:     }",
          "2587:     if (GetSequence(input, inOutIdx, &length, inSz) < 0)",
          "",
          "[Removed Lines]",
          "2584:     if (inOutIdx == NULL) {",
          "",
          "[Added Lines]",
          "2591:     if (inOutIdx == NULL || input == NULL || key == NULL) {",
          "",
          "---------------"
        ],
        "wolfcrypt/src/chacha.c||wolfcrypt/src/chacha.c": [
          "File: wolfcrypt/src/chacha.c -> wolfcrypt/src/chacha.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "30: #ifdef WOLFSSL_ARMASM",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "23: DESCRIPTION",
          "24: This library contains implementation for the ChaCha20 stream cipher.",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "112: {",
          "125:         return BAD_FUNC_ARG;",
          "127:     XMEMCPY(temp, inIv, CHACHA_IV_BYTES);",
          "135:     return 0;",
          "136: }",
          "",
          "[Removed Lines]",
          "115: #ifdef CHACHA_AEAD_TEST",
          "116:     word32 i;",
          "117:     printf(\"NONCE : \");",
          "118:     for (i = 0; i < CHACHA_IV_BYTES; i++) {",
          "119:         printf(\"%02x\", inIv[i]);",
          "120:     }",
          "121:     printf(\"\\n\\n\");",
          "122: #endif",
          "124:     if (ctx == NULL)",
          "",
          "[Added Lines]",
          "113:     if (ctx == NULL || inIv == NULL)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "152:     word32 alignKey[8];",
          "153: #endif",
          "156:         return BAD_FUNC_ARG;",
          "158:     if (keySz != (CHACHA_MAX_KEY_SZ/2) && keySz != CHACHA_MAX_KEY_SZ)",
          "",
          "[Removed Lines]",
          "155:     if (ctx == NULL)",
          "",
          "[Added Lines]",
          "144:     if (ctx == NULL || key == NULL)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "271:         output = (byte*)temp + CHACHA_CHUNK_BYTES - ctx->left;",
          "272:         for (i = 0; i < bytes && i < ctx->left; i++) {",
          "274:         }",
          "275:         ctx->left = ctx->left - i;",
          "278:         if (ctx->left == 0) {",
          "280:         }",
          "281:         bytes = bytes - i;",
          "282:         c += i;",
          "",
          "[Removed Lines]",
          "273:             c[i] = m[i] ^ output[i];",
          "279:             ctx->X[CHACHA_IV_BYTES] = PLUSONE(ctx->X[CHACHA_IV_BYTES]);",
          "",
          "[Added Lines]",
          "262:             c[i] = (byte)(m[i] ^ output[i]);",
          "268:             ctx->X[CHACHA_MATRIX_CNT_IV] = PLUSONE(ctx->X[CHACHA_MATRIX_CNT_IV]);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "286:     output = (byte*)temp;",
          "287:     while (bytes >= CHACHA_CHUNK_BYTES) {",
          "288:         wc_Chacha_wordtobyte(temp, ctx->X);",
          "290:         for (i = 0; i < CHACHA_CHUNK_BYTES; ++i) {",
          "292:         }",
          "293:         bytes -= CHACHA_CHUNK_BYTES;",
          "294:         c += CHACHA_CHUNK_BYTES;",
          "",
          "[Removed Lines]",
          "289:         ctx->X[CHACHA_IV_BYTES] = PLUSONE(ctx->X[CHACHA_IV_BYTES]);",
          "291:             c[i] = m[i] ^ output[i];",
          "",
          "[Added Lines]",
          "278:         ctx->X[CHACHA_MATRIX_CNT_IV] = PLUSONE(ctx->X[CHACHA_MATRIX_CNT_IV]);",
          "280:             c[i] = (byte)(m[i] ^ output[i]);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "314: int wc_Chacha_Process(ChaCha* ctx, byte* output, const byte* input,",
          "315:                       word32 msglen)",
          "316: {",
          "318:         return BAD_FUNC_ARG;",
          "320: #ifdef USE_INTEL_CHACHA_SPEEDUP",
          "",
          "[Removed Lines]",
          "317:     if (ctx == NULL)",
          "",
          "[Added Lines]",
          "306:     if (ctx == NULL || input == NULL || output == NULL)",
          "",
          "---------------"
        ],
        "wolfcrypt/src/chacha20_poly1305.c||wolfcrypt/src/chacha20_poly1305.c": [
          "File: wolfcrypt/src/chacha20_poly1305.c -> wolfcrypt/src/chacha20_poly1305.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "24: #ifdef HAVE_CONFIG_H",
          "25:     #include <config.h>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "23: DESCRIPTION",
          "24: This library contains implementation for the ChaCha20 stream cipher and",
          "25: the Poly1305 authenticator, both as as combined-mode,",
          "26: or Authenticated Encryption with Additional Data (AEAD) algorithm.",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "142:     XMEMSET(aead, 0, sizeof(ChaChaPoly_Aead));",
          "143:     XMEMSET(authKey, 0, sizeof(authKey));",
          "147:     ret = wc_Chacha_SetKey(&aead->chacha, inKey,",
          "",
          "[Removed Lines]",
          "144:     aead->isEncrypt = isEncrypt;",
          "",
          "[Added Lines]",
          "150:     aead->isEncrypt = (byte)isEncrypt;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "189:         aead->state != CHACHA20_POLY1305_STATE_AAD) {",
          "190:         return BAD_STATE_E;",
          "191:     }",
          "193:     if (inAAD && inAADLen > 0) {",
          "194:         ret = wc_Poly1305Update(&aead->poly, inAAD, inAADLen);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "198:     if (inAADLen > CHACHA20_POLY1305_MAX - aead->aadLen)",
          "199:         return CHACHA_POLY_OVERFLOW;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "215:         aead->state != CHACHA20_POLY1305_STATE_DATA) {",
          "216:         return BAD_STATE_E;",
          "217:     }",
          "220:     if (aead->state == CHACHA20_POLY1305_STATE_AAD) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "226:     if (dataLen > CHACHA20_POLY1305_MAX - aead->dataLen)",
          "227:         return CHACHA_POLY_OVERFLOW;",
          "",
          "---------------"
        ],
        "wolfcrypt/src/error.c||wolfcrypt/src/error.c": [
          "File: wolfcrypt/src/error.c -> wolfcrypt/src/error.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "512:     case PSS_SALTLEN_RECOVER_E:",
          "513:         return \"PSS - Salt length unable to be recovered\";",
          "515:     case ASN_SELF_SIGNED_E:",
          "516:         return \"ASN self-signed certificate error\";",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "515:     case CHACHA_POLY_OVERFLOW:",
          "516:         return \"wolfcrypt - ChaCha20_Poly1305 limit overflow 4GB\";",
          "",
          "---------------"
        ],
        "wolfcrypt/src/misc.c||wolfcrypt/src/misc.c": [
          "File: wolfcrypt/src/misc.c -> wolfcrypt/src/misc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "23: #ifdef HAVE_CONFIG_H",
          "24:     #include <config.h>",
          "25: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "23: DESCRIPTION",
          "24: This module implements the arithmetic-shift right, left, byte swapping, XOR,",
          "25: masking and clearing memory logic.",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "114:     return rotlFixed(value, 16U);",
          "115: #endif",
          "116: }",
          "119: WC_STATIC WC_INLINE void ByteReverseWords(word32* out, const word32* in,",
          "120:                                     word32 byteCount)",
          "121: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "123: #if defined(LITTLE_ENDIAN_ORDER)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "324: WC_STATIC WC_INLINE byte ctMaskGT(int a, int b)",
          "325: {",
          "327: }",
          "",
          "[Removed Lines]",
          "326:     return (((word32)a - b - 1) >> 31) - 1;",
          "",
          "[Added Lines]",
          "338:     return ((byte)(((word32)a - b - 1) >> 31) - 1);",
          "",
          "---------------"
        ],
        "wolfcrypt/src/poly1305.c||wolfcrypt/src/poly1305.c": [
          "File: wolfcrypt/src/poly1305.c -> wolfcrypt/src/poly1305.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "28: #ifdef HAVE_CONFIG_H",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "23: DESCRIPTION",
          "24: This library contains implementation for the Poly1305 authenticator.",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "228:     }",
          "230:     static void U32TO8(byte *p, word32 v) {",
          "236: #endif",
          "",
          "[Removed Lines]",
          "231:         p[0] = (v      ) & 0xff;",
          "232:         p[1] = (v >>  8) & 0xff;",
          "233:         p[2] = (v >> 16) & 0xff;",
          "234:         p[3] = (v >> 24) & 0xff;",
          "235:     }",
          "",
          "[Added Lines]",
          "232:     p[0] = (byte)((v      ) & 0xff);",
          "233:     p[1] = (byte)((v >>  8) & 0xff);",
          "234:     p[2] = (byte)((v >> 16) & 0xff);",
          "235:     p[3] = (byte)((v >> 24) & 0xff);",
          "236: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "256: #if !defined(WOLFSSL_ARMASM) || !defined(__aarch64__)",
          "258:                      size_t bytes)",
          "259: {",
          "260: #ifdef USE_INTEL_SPEEDUP",
          "",
          "[Removed Lines]",
          "257: void poly1305_blocks(Poly1305* ctx, const unsigned char *m,",
          "",
          "[Added Lines]",
          "259: This local function operates on a message with a given number of bytes",
          "260: with a given ctx pointer to a Poly1305 structure.",
          "262: static void poly1305_blocks(Poly1305* ctx, const unsigned char *m,",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "379: }",
          "382: {",
          "383: #ifdef USE_INTEL_SPEEDUP",
          "",
          "[Removed Lines]",
          "381: void poly1305_block(Poly1305* ctx, const unsigned char *m)",
          "",
          "[Added Lines]",
          "387: This local function is used for the last call when a message with a given",
          "388: number of bytes is less than the block size.",
          "390: static void poly1305_block(Poly1305* ctx, const unsigned char *m)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "495: #endif",
          "498:         return BAD_FUNC_ARG;",
          "500: #ifdef USE_INTEL_SPEEDUP",
          "",
          "[Removed Lines]",
          "497:     if (ctx == NULL)",
          "",
          "[Added Lines]",
          "506:     if (ctx == NULL || mac == NULL)",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "663: {",
          "664:     size_t i;",
          "666: #ifdef CHACHA_AEAD_TEST",
          "667:     word32 k;",
          "668:     printf(\"Raw input to poly:\\n\");",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "675:     if (ctx == NULL || (m == NULL && bytes > 0))",
          "676:         return BAD_FUNC_ARG;",
          "678:     if (bytes == 0) {",
          "680:         return 0;",
          "681:     }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "673:     }",
          "674:     printf(\"\\n\");",
          "675: #endif",
          "678:         return BAD_FUNC_ARG;",
          "680: #ifdef USE_INTEL_SPEEDUP",
          "",
          "[Removed Lines]",
          "677:     if (ctx == NULL)",
          "",
          "[Added Lines]",
          "692:     if (ctx == NULL || (m == NULL && bytes > 0))",
          "",
          "---------------"
        ],
        "wolfcrypt/src/random.c||wolfcrypt/src/random.c": [
          "File: wolfcrypt/src/random.c -> wolfcrypt/src/random.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "23: #ifdef HAVE_CONFIG_H",
          "24:     #include <config.h>",
          "25: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "24: DESCRIPTION",
          "25: This library contains implementation for the random number generator.",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "487:                     return DRBG_CONT_FAILURE;",
          "488:                 }",
          "489:                 else {",
          "491:                         len++;",
          "492:                     }",
          "493:                     drbg->matchCount = 1;",
          "",
          "[Removed Lines]",
          "490:                     if (i == len) {",
          "",
          "[Added Lines]",
          "495:                     if (i == (len-1)) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "511:                 }",
          "512:             }",
          "513:         }",
          "514:     }",
          "515:     ForceZero(data, sizeof(data));",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "519:         else {",
          "521:             break;",
          "522:         }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "614:                                              const byte* nonce, word32 nonceSz,",
          "615:                                              void* heap, int devId)",
          "616: {",
          "619:     XMEMSET(drbg, 0, sizeof(DRBG));",
          "620: #if defined(WOLFSSL_ASYNC_CRYPT) || defined(WOLF_CRYPTO_CB)",
          "",
          "[Removed Lines]",
          "617:     int ret;",
          "",
          "[Added Lines]",
          "626:     int ret = DRBG_FAILURE;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "645:         drbg->matchCount = 0;",
          "646:         ret = DRBG_SUCCESS;",
          "647:     }",
          "652:     return ret;",
          "653: }",
          "",
          "[Removed Lines]",
          "648:     else {",
          "649:         ret = DRBG_FAILURE;",
          "650:     }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "675: int wc_RNG_TestSeed(const byte* seed, word32 seedSz)",
          "676: {",
          "680:     word32 seedIdx = 0;",
          "",
          "[Removed Lines]",
          "677:     int ret = DRBG_SUCCESS;",
          "",
          "[Added Lines]",
          "683:     int ret = 0;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "700: static int _InitRng(WC_RNG* rng, byte* nonce, word32 nonceSz,",
          "701:                     void* heap, int devId)",
          "702: {",
          "704: #ifdef HAVE_HASHDRBG",
          "705:     word32 seedSz = SEED_SZ + SEED_BLOCK_SZ;",
          "706: #endif",
          "",
          "[Removed Lines]",
          "703:     int ret = RNG_FAILURE_E;",
          "",
          "[Added Lines]",
          "709:     int ret = 0;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "773:         rng->drbg =",
          "774:                 (struct DRBG*)XMALLOC(sizeof(DRBG), rng->heap,",
          "775:                                                           DYNAMIC_TYPE_RNG);",
          "776: #else",
          "778:         typedef char drbg_data_test[sizeof(rng->drbg_data) >=",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "782:         if (rng->drbg == NULL) {",
          "783:             ret = MEMORY_E;",
          "784:             rng->status = DRBG_FAILED;",
          "785:         }",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "780:         (void)sizeof(drbg_data_test);",
          "781:         rng->drbg = (struct DRBG*)rng->drbg_data;",
          "782: #endif",
          "788:             ret = wc_GenerateSeed(&rng->seed, seed, seedSz);",
          "792:                 ret = wc_RNG_TestSeed(seed, seedSz);",
          "794:             if (ret == DRBG_SUCCESS)",
          "795:                  ret = Hash_DRBG_Instantiate(rng->drbg,",
          "",
          "[Removed Lines]",
          "784:         if (rng->drbg == NULL) {",
          "785:             ret = MEMORY_E;",
          "786:         }",
          "787:         else {",
          "789:             if (ret != 0)",
          "790:                 ret = DRBG_FAILURE;",
          "791:             else",
          "",
          "[Added Lines]",
          "793:         if (ret == 0) {",
          "795:             if (ret == 0)",
          "797:             else {",
          "798:                 ret = DRBG_FAILURE;",
          "799:                 rng->status = DRBG_FAILED;",
          "800:             }",
          "",
          "---------------"
        ],
        "wolfcrypt/src/rsa.c||wolfcrypt/src/rsa.c": [
          "File: wolfcrypt/src/rsa.c -> wolfcrypt/src/rsa.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "23: #ifdef HAVE_CONFIG_H",
          "24:     #include <config.h>",
          "25: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "24: DESCRIPTION",
          "25: This library provides the interface to the RSA.",
          "26: RSA keys can be used to encrypt, decrypt, sign and verify data.",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "605:         if (mp_set_int(k, 0x2342) != MP_OKAY)",
          "606:             ret = MP_READ_E;",
          "607:     }",
          "609: #ifdef WOLFSSL_HAVE_SP_RSA",
          "629:     }",
          "639:             ret = MP_EXPTMOD_E;",
          "640:     }",
          "659:     }",
          "662:     if (ret == 0) {",
          "663:         if (mp_cmp(k, tmp) != MP_EQ)",
          "",
          "[Removed Lines]",
          "610: #ifndef WOLFSSL_SP_NO_2048",
          "611:     if (mp_count_bits(&key->n) == 2048) {",
          "612:         ret = sp_ModExp_2048(k, &key->e, &key->n, tmp);",
          "613:         if (ret != 0)",
          "614:             ret = MP_EXPTMOD_E;",
          "615:         ret = sp_ModExp_2048(tmp, &key->d, &key->n, tmp);",
          "616:         if (ret != 0)",
          "617:             ret = MP_EXPTMOD_E;",
          "618:     }",
          "619:     else",
          "620: #endif",
          "621: #ifndef WOLFSSL_SP_NO_3072",
          "622:     if (mp_count_bits(&key->n) == 3072) {",
          "623:         ret = sp_ModExp_3072(k, &key->e, &key->n, tmp);",
          "624:         if (ret != 0)",
          "625:             ret = MP_EXPTMOD_E;",
          "626:         ret = sp_ModExp_3072(tmp, &key->d, &key->n, tmp);",
          "627:         if (ret != 0)",
          "628:             ret = MP_EXPTMOD_E;",
          "630:     else",
          "631: #endif",
          "632: #ifdef WOLFSSL_SP_4096",
          "633:     if (mp_count_bits(&key->n) == 4096) {",
          "634:         ret = sp_ModExp_4096(k, &key->e, &key->n, tmp);",
          "635:         if (ret != 0)",
          "636:             ret = MP_EXPTMOD_E;",
          "637:         ret = sp_ModExp_4096(tmp, &key->d, &key->n, tmp);",
          "638:         if (ret != 0)",
          "641:     else",
          "642: #endif",
          "643: #endif",
          "644: #ifdef WOLFSSL_SP_MATH",
          "645:     {",
          "646:         ret = WC_KEY_SIZE_E;",
          "647:     }",
          "648: #else",
          "649:     {",
          "650:         if (ret == 0) {",
          "651:             if (mp_exptmod(k, &key->e, &key->n, tmp) != MP_OKAY)",
          "652:                 ret = MP_EXPTMOD_E;",
          "653:         }",
          "655:         if (ret == 0) {",
          "656:             if (mp_exptmod(tmp, &key->d, &key->n, tmp) != MP_OKAY)",
          "657:                 ret = MP_EXPTMOD_E;",
          "658:         }",
          "660: #endif",
          "",
          "[Added Lines]",
          "615:     if (ret == 0) {",
          "616:         switch (mp_count_bits(&key->n)) {",
          "617:     #ifndef WOLFSSL_SP_NO_2048",
          "618:             case 2048:",
          "619:                 ret = sp_ModExp_2048(k, &key->e, &key->n, tmp);",
          "620:                 if (ret != 0)",
          "621:                     ret = MP_EXPTMOD_E;",
          "622:                 if (ret == 0) {",
          "623:                     ret = sp_ModExp_2048(tmp, &key->d, &key->n, tmp);",
          "624:                     if (ret != 0)",
          "625:                         ret = MP_EXPTMOD_E;",
          "626:                 }",
          "627:                 break;",
          "629:     #ifndef WOLFSSL_SP_NO_3072",
          "630:             case 3072:",
          "631:                 ret = sp_ModExp_3072(k, &key->e, &key->n, tmp);",
          "632:                 if (ret != 0)",
          "633:                     ret = MP_EXPTMOD_E;",
          "634:                 if (ret == 0) {",
          "635:                   ret = sp_ModExp_3072(tmp, &key->d, &key->n, tmp);",
          "636:                   if (ret != 0)",
          "637:                       ret = MP_EXPTMOD_E;",
          "638:                 }",
          "639:                 break;",
          "641:     #ifdef WOLFSSL_SP_4096",
          "642:             case 4096:",
          "643:                 ret = sp_ModExp_4096(k, &key->e, &key->n, tmp);",
          "644:                 if (ret != 0)",
          "645:                     ret = MP_EXPTMOD_E;",
          "646:                 if (ret == 0) {",
          "647:                   ret = sp_ModExp_4096(tmp, &key->d, &key->n, tmp);",
          "648:                   if (ret != 0)",
          "649:                       ret = MP_EXPTMOD_E;",
          "650:                 }",
          "651:                 break;",
          "653:                 default:",
          "654:                     ret = WC_KEY_SIZE_E;",
          "655:         }",
          "658: #ifndef WOLFSSL_SP_MATH",
          "659:     if (ret == 0) {",
          "660:         if (mp_exptmod(k, &key->e, &key->n, tmp) != MP_OKAY)",
          "664:     if (ret == 0) {",
          "665:         if (mp_exptmod(tmp, &key->d, &key->n, tmp) != MP_OKAY)",
          "666:             ret = MP_EXPTMOD_E;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "815:         XMEMCPY(tmp, seed, seedSz);",
          "824:         if ((ret = wc_Hash(hType, tmp, (seedSz + 4), tmp, tmpSz)) != 0) {",
          "",
          "[Removed Lines]",
          "818:         tmp[seedSz]     = (counter >> 24) & 0xFF;",
          "819:         tmp[seedSz + 1] = (counter >> 16) & 0xFF;",
          "820:         tmp[seedSz + 2] = (counter >>  8) & 0xFF;",
          "821:         tmp[seedSz + 3] = (counter)       & 0xFF;",
          "",
          "[Added Lines]",
          "826:         tmp[seedSz]     = (byte)((counter >> 24) & 0xFF);",
          "827:         tmp[seedSz + 1] = (byte)((counter >> 16) & 0xFF);",
          "828:         tmp[seedSz + 2] = (byte)((counter >>  8) & 0xFF);",
          "829:         tmp[seedSz + 3] = (byte)((counter)       & 0xFF);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1125:     hiBits = (bits - 1) & 0x7;",
          "1126:     if (hiBits == 0) {",
          "1128:         pkcsBlockLen--;",
          "1129:     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1136:            leftmost octet in DB to zero.",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1203:         ret = wc_Hash(hType, s, (word32)(m - s), pkcsBlock + maskLen, hLen);",
          "1204:     }",
          "1205:     if (ret == 0) {",
          "1206:         pkcsBlock[pkcsBlockLen - 1] = RSA_PSS_PAD_TERM;",
          "1208:         ret = RsaMGF(mgf, pkcsBlock + maskLen, hLen, pkcsBlock, maskLen, heap);",
          "1209:     }",
          "1210:     if (ret == 0) {",
          "1213:         m = pkcsBlock + maskLen - saltLen - 1;",
          "",
          "[Removed Lines]",
          "1211:         pkcsBlock[0] &= (1 << hiBits) - 1;",
          "",
          "[Added Lines]",
          "1224:         if (hiBits)",
          "1225:             pkcsBlock[0] &= (1 << hiBits) - 1;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1237:         return BAD_FUNC_ARG;",
          "1238:     }",
          "1241:     pkcsBlock++; pkcsBlockLen--;",
          "1244:     if (padValue == RSA_BLOCK_TYPE_1) {",
          "1251:         XMEMSET(&pkcsBlock[1], 0xFF, pkcsBlockLen - inputLen - 2);",
          "",
          "[Removed Lines]",
          "1245:         if (pkcsBlockLen < inputLen + 2) {",
          "1246:             WOLFSSL_MSG(\"RsaPad error, invalid length\");",
          "1247:             return RSA_PAD_E;",
          "1248:         }",
          "",
          "[Added Lines]",
          "1254:     if (pkcsBlockLen - RSA_MIN_PAD_SZ < inputLen) {",
          "1255:         WOLFSSL_MSG(\"RsaPad error, invalid length\");",
          "1256:         return RSA_PAD_E;",
          "1257:     }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1256:         word32 padLen, i;",
          "1257:         int    ret;",
          "1264:         padLen = pkcsBlockLen - inputLen - 1;",
          "1265:         ret    = wc_RNG_GenerateBlock(rng, &pkcsBlock[1], padLen);",
          "1266:         if (ret != 0) {",
          "",
          "[Removed Lines]",
          "1259:         if (pkcsBlockLen < inputLen + 1) {",
          "1260:             WOLFSSL_MSG(\"RsaPad error, invalid length\");",
          "1261:             return RSA_PAD_E;",
          "1262:         }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1464: static int RsaUnPad_PSS(byte *pkcsBlock, unsigned int pkcsBlockLen,",
          "1465:                         byte **output, enum wc_HashType hType, int mgf,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1471:                  and other negative values on error.",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "2659: #endif",
          "2661:         if (mp_init(c) != MP_OKAY)",
          "2663:         if (ret == 0) {",
          "2664:             if (mp_read_unsigned_bin(c, in, inLen) != 0)",
          "2665:                 ret = MP_READ_E;",
          "",
          "[Removed Lines]",
          "2662:             ret = MEMORY_E;",
          "",
          "[Added Lines]",
          "2671:             ret = MP_INIT_E;",
          "",
          "---------------"
        ],
        "wolfcrypt/src/sha256.c||wolfcrypt/src/sha256.c": [
          "File: wolfcrypt/src/sha256.c -> wolfcrypt/src/sha256.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "22: #ifdef HAVE_CONFIG_H",
          "23:     #include <config.h>",
          "24: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "25: DESCRIPTION",
          "26: This library provides the interface to SHA-256 secure hash algorithms.",
          "27: SHA-256 performs processing on message blocks to produce a final hash digest",
          "28: output. It can be used to hash a message, M, having a length of L bits,",
          "29: where 0 <= L < 2^64.",
          "",
          "---------------"
        ],
        "wolfcrypt/src/sp_int.c||wolfcrypt/src/sp_int.c": [
          "File: wolfcrypt/src/sp_int.c -> wolfcrypt/src/sp_int.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "24: #ifdef HAVE_CONFIG_H",
          "25:     #include <config.h>",
          "26: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "25: DESCRIPTION",
          "26: This library provides single precision (SP) integer math functions.",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "182:            MP_OKAY otherwise.",
          "185: {",
          "186:     int err = MP_OKAY;",
          "187:     int i, j = 0, k;",
          "191:         err = MP_VAL;",
          "192:     }",
          "195:         for (i = inSz-1; i >= (SP_WORD_SIZE/8); i -= (SP_WORD_SIZE/8), j++) {",
          "196:             a->dp[j]  = (((sp_int_digit)in[i-0]) << (0*8))",
          "197:                      |  (((sp_int_digit)in[i-1]) << (1*8))",
          "",
          "[Removed Lines]",
          "184: int sp_read_unsigned_bin(sp_int* a, const byte* in, int inSz)",
          "190:     if (inSz > (SP_INT_DIGITS - 1) * (int)sizeof(a->dp[0])) {",
          "194:     if (err == MP_OKAY) {",
          "",
          "[Added Lines]",
          "189: int sp_read_unsigned_bin(sp_int* a, const byte* in, word32 inSz)",
          "195:     if (inSz > SP_INT_DIGITS * (int)sizeof(a->dp[0])) {",
          "198:     else if (inSz == 0) {",
          "199:         XMEMSET(a->dp, 0, a->size * sizeof(*a->dp));",
          "200:         a->used = 0;",
          "201:     }",
          "202:     else {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "212:             }",
          "213:         }",
          "214:         a->used = j + 1;",
          "219:     return err;",
          "220: }",
          "",
          "[Removed Lines]",
          "215:     }",
          "217:     sp_clamp(a);",
          "",
          "[Added Lines]",
          "224:         sp_clamp(a);",
          "225:     }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1019:     int i = 0;",
          "1020:     sp_int_digit t;",
          "1022:     r->used = a->used;",
          "1023:     if (a->used == 0) {",
          "1025:     }",
          "1028:         for (++i; i < a->used; i++) {",
          "1029:             r->dp[i] = a->dp[i] + 1;",
          "1030:             if (r->dp[i] != 0) {",
          "",
          "[Removed Lines]",
          "1024:         r->used = d > 0;",
          "1026:     t = a->dp[0] + d;",
          "1027:     if (t < a->dp[0]) {",
          "",
          "[Added Lines]",
          "1030:     if (a == NULL || r == NULL || a->used > SP_INT_DIGITS)",
          "1031:         return BAD_FUNC_ARG;",
          "1035:     if (d == 0) {",
          "1037:         for (; i < a->used; i++)",
          "1038:             r->dp[i] = a->dp[i];",
          "1040:         return MP_OKAY;",
          "1041:     }",
          "1044:         r->used = 1;",
          "1045:         t = d;",
          "1047:     else",
          "1048:         t = a->dp[0] + d;",
          "1050:     if (a->used != 0 && t < a->dp[0]) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1033:         }",
          "1034:         if (i == a->used) {",
          "1035:             r->used++;",
          "1037:         }",
          "1038:     }",
          "1039:     r->dp[0] = t;",
          "1046:     return MP_OKAY;",
          "1047: }",
          "1049: #if !defined(NO_DH) || defined(HAVE_ECC) || defined(WC_RSA_BLINDING) || \\",
          "1050:     !defined(WOLFSSL_RSA_VERIFY_ONLY)",
          "",
          "[Removed Lines]",
          "1036:             r->dp[i] = 1;",
          "1040:     if (r != a) {",
          "1041:         for (++i; i < a->used; i++) {",
          "1042:             r->dp[i] = a->dp[i];",
          "1043:         }",
          "1044:     }",
          "",
          "[Added Lines]",
          "1059:             if (i < SP_INT_DIGITS)",
          "1060:                 r->dp[i] = 1;",
          "1061:             else",
          "1062:                 return MP_VAL;",
          "1066:     for (++i; i < a->used; i++)",
          "1067:         r->dp[i] = a->dp[i];",
          "",
          "---------------"
        ],
        "wolfssl/wolfcrypt/aes.h||wolfssl/wolfcrypt/aes.h": [
          "File: wolfssl/wolfcrypt/aes.h -> wolfssl/wolfcrypt/aes.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "23:     \\file wolfssl/wolfcrypt/aes.h",
          "27: #ifndef WOLF_CRYPT_AES_H",
          "28: #define WOLF_CRYPT_AES_H",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "27: DESCRIPTION",
          "28: This library provides the interfaces to the Advanced Encryption Standard (AES)",
          "29: for encrypting and decrypting data. AES is the standard known for a symmetric",
          "30: block cipher mechanism that uses n-bit binary string parameter key with 128-bits,",
          "31: 192-bits, and 256-bits of key sizes.",
          "",
          "---------------"
        ],
        "wolfssl/wolfcrypt/asn.h||wolfssl/wolfcrypt/asn.h": [
          "File: wolfssl/wolfcrypt/asn.h -> wolfssl/wolfcrypt/asn.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "23:     \\file wolfssl/wolfcrypt/asn.h",
          "26: #ifndef WOLF_CRYPT_ASN_H",
          "27: #define WOLF_CRYPT_ASN_H",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "28: DESCRIPTION",
          "29: This library provides the interface to Abstract Syntax Notation One (ASN.1) objects.",
          "30: ASN.1 is a standard interface description language for defining data structures",
          "31: that can be serialized and deserialized in a cross-platform way.",
          "",
          "---------------"
        ],
        "wolfssl/wolfcrypt/asn_public.h||wolfssl/wolfcrypt/asn_public.h": [
          "File: wolfssl/wolfcrypt/asn_public.h -> wolfssl/wolfcrypt/asn_public.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "23:     \\file wolfssl/wolfcrypt/asn_public.h",
          "26: #ifndef WOLF_CRYPT_ASN_PUBLIC_H",
          "27: #define WOLF_CRYPT_ASN_PUBLIC_H",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "27: DESCRIPTION",
          "28: This library defines the interface APIs for X509 certificates.",
          "",
          "---------------"
        ],
        "wolfssl/wolfcrypt/chacha.h||wolfssl/wolfcrypt/chacha.h": [
          "File: wolfssl/wolfcrypt/chacha.h -> wolfssl/wolfcrypt/chacha.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "23:     \\file wolfssl/wolfcrypt/chacha.h",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "23: DESCRIPTION",
          "24: This library contains implementation for the ChaCha20 stream cipher.",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "35:     extern \"C\" {",
          "36: #endif",
          "39: #define CHACHA_IV_WORDS    3",
          "43: #define CHACHA_CHUNK_WORDS 16",
          "",
          "[Removed Lines]",
          "40: #define CHACHA_IV_BYTES    (CHACHA_IV_WORDS * sizeof(word32))",
          "",
          "[Added Lines]",
          "44: Initialization vector starts at 13 with zero being the index origin of a matrix.",
          "45: Block counter is located at index 12.",
          "46:   0   1   2   3",
          "47:   4   5   6   7",
          "48:   8   9   10  11",
          "49:   12  13  14  15",
          "51: #define CHACHA_MATRIX_CNT_IV 12",
          "57: #define CHACHA_IV_BYTES 12",
          "",
          "---------------"
        ],
        "wolfssl/wolfcrypt/chacha20_poly1305.h||wolfssl/wolfcrypt/chacha20_poly1305.h": [
          "File: wolfssl/wolfcrypt/chacha20_poly1305.h -> wolfssl/wolfcrypt/chacha20_poly1305.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "29:     \\file wolfssl/wolfcrypt/chacha20_poly1305.h",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "23: DESCRIPTION",
          "24: This library contains implementation for the ChaCha20 stream cipher and",
          "25: the Poly1305 authenticator, both as as combined-mode,",
          "26: or Authenticated Encryption with Additional Data (AEAD) algorithm.",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "45: #define CHACHA20_POLY1305_AEAD_KEYSIZE      32",
          "46: #define CHACHA20_POLY1305_AEAD_IV_SIZE      12",
          "47: #define CHACHA20_POLY1305_AEAD_AUTHTAG_SIZE 16",
          "49: enum {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "50: #define CHACHA20_POLY1305_MAX               4294967295U",
          "",
          "---------------"
        ],
        "wolfssl/wolfcrypt/error-crypt.h||wolfssl/wolfcrypt/error-crypt.h": [
          "File: wolfssl/wolfcrypt/error-crypt.h -> wolfssl/wolfcrypt/error-crypt.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "23:     \\file wolfssl/wolfcrypt/error-crypt.h",
          "26: #ifndef WOLF_CRYPT_ERROR_H",
          "27: #define WOLF_CRYPT_ERROR_H",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "26: DESCRIPTION",
          "27: This library defines error codes and contians routines for setting and examining",
          "28: the error status.",
          "",
          "---------------"
        ],
        "wolfssl/wolfcrypt/misc.h||wolfssl/wolfcrypt/misc.h": [
          "File: wolfssl/wolfcrypt/misc.h -> wolfssl/wolfcrypt/misc.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "24: #ifndef WOLF_CRYPT_MISC_H",
          "25: #define WOLF_CRYPT_MISC_H",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "23: DESCRIPTION",
          "24: This module implements the arithmetic-shift right, left, byte swapping, XOR,",
          "25: masking and clearing memory logic.",
          "",
          "---------------"
        ],
        "wolfssl/wolfcrypt/poly1305.h||wolfssl/wolfcrypt/poly1305.h": [
          "File: wolfssl/wolfcrypt/poly1305.h -> wolfssl/wolfcrypt/poly1305.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "119: WOLFSSL_API int wc_Poly1305_MAC(Poly1305* ctx, byte* additional, word32 addSz,",
          "120:                                byte* input, word32 sz, byte* tag, word32 tagSz);",
          "125: #ifdef __cplusplus",
          "127: #endif",
          "",
          "[Removed Lines]",
          "122: void poly1305_block(Poly1305* ctx, const unsigned char *m);",
          "123: void poly1305_blocks(Poly1305* ctx, const unsigned char *m,",
          "124:                             size_t bytes);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "wolfssl/wolfcrypt/rsa.h||wolfssl/wolfcrypt/rsa.h": [
          "File: wolfssl/wolfcrypt/rsa.h -> wolfssl/wolfcrypt/rsa.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "23:     \\file wolfssl/wolfcrypt/rsa.h",
          "27: #ifndef WOLF_CRYPT_RSA_H",
          "28: #define WOLF_CRYPT_RSA_H",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "28: DESCRIPTION",
          "29: This library provides the interface to the RSA.",
          "30: RSA keys can be used to encrypt, decrypt, sign and verify data.",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "280:                                                                RsaKey*, word32);",
          "281: WOLFSSL_API int  wc_RsaPublicKeyDecodeRaw(const byte* n, word32 nSz,",
          "282:                                         const byte* e, word32 eSz, RsaKey* key);",
          "286: #ifdef WC_RSA_BLINDING",
          "287:     WOLFSSL_API int wc_RsaSetRNG(RsaKey* key, WC_RNG* rng);",
          "",
          "[Removed Lines]",
          "283: WOLFSSL_API int wc_RsaKeyToDer(RsaKey*, byte* output, word32 inLen);",
          "",
          "[Added Lines]",
          "289: #ifdef WOLFSSL_KEY_GEN",
          "290:     WOLFSSL_API int wc_RsaKeyToDer(RsaKey*, byte* output, word32 inLen);",
          "291: #endif",
          "",
          "---------------"
        ],
        "wolfssl/wolfcrypt/sp_int.h||wolfssl/wolfcrypt/sp_int.h": [
          "File: wolfssl/wolfcrypt/sp_int.h -> wolfssl/wolfcrypt/sp_int.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "23: #ifndef WOLF_CRYPT_SP_INT_H",
          "24: #define WOLF_CRYPT_SP_INT_H",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "23: DESCRIPTION",
          "24: This library provides single precision (SP) integer math functions.",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "187:                          sp_int* e, sp_int* f);",
          "188: MP_API void sp_clear(sp_int* a);",
          "189: MP_API int sp_unsigned_bin_size(sp_int* a);",
          "191: MP_API int sp_read_radix(sp_int* a, const char* in, int radix);",
          "192: MP_API int sp_cmp(sp_int* a, sp_int* b);",
          "193: MP_API int sp_count_bits(sp_int* a);",
          "",
          "[Removed Lines]",
          "190: MP_API int sp_read_unsigned_bin(sp_int* a, const byte* in, int inSz);",
          "",
          "[Added Lines]",
          "194: MP_API int sp_read_unsigned_bin(sp_int* a, const byte* in, word32 inSz);",
          "",
          "---------------"
        ],
        "wolfssl/wolfcrypt/types.h||wolfssl/wolfcrypt/types.h": [
          "File: wolfssl/wolfcrypt/types.h -> wolfssl/wolfcrypt/types.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "23:     \\file wolfssl/wolfcrypt/types.h",
          "26: #ifndef WOLF_CRYPT_TYPES_H",
          "27: #define WOLF_CRYPT_TYPES_H",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "26: DESCRIPTION",
          "27: This library defines the primitive data types and abstraction macros to",
          "28: decouple library dependencies with standard string, memory and so on.",
          "",
          "---------------"
        ],
        "wolfssl/wolfcrypt/wolfmath.h||wolfssl/wolfcrypt/wolfmath.h": [
          "File: wolfssl/wolfcrypt/wolfmath.h -> wolfssl/wolfcrypt/wolfmath.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "22: #ifndef __WOLFMATH_H__",
          "23: #define __WOLFMATH_H__",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "23: DESCRIPTION",
          "24: This library provides big integer math functions.",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2021-32613",
  "cve_desc": "In radare2 through 5.3.0 there is a double free vulnerability in the pyc parse via a crafted file which can lead to DoS.",
  "repo": "radareorg/radare2",
  "patch_hash": "a07dedb804a82bc01c07072861942dd80c6b6d62",
  "patch_info": {
    "commit_hash": "a07dedb804a82bc01c07072861942dd80c6b6d62",
    "repo": "radareorg/radare2",
    "commit_url": "https://github.com/radareorg/radare2/commit/a07dedb804a82bc01c07072861942dd80c6b6d62",
    "files": [
      "libr/bin/p/bin_mach0.c"
    ],
    "message": "Fix #18667 - division by zero in the macho parser ##bin",
    "before_after_code_files": [
      "libr/bin/p/bin_mach0.c||libr/bin/p/bin_mach0.c"
    ]
  },
  "patch_diff": {
    "libr/bin/p/bin_mach0.c||libr/bin/p/bin_mach0.c": [
      "File: libr/bin/p/bin_mach0.c -> libr/bin/p/bin_mach0.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "771:   if (!obj->chained_starts[i]) {",
      "772:    continue;",
      "773:   }",
      "775:   ut64 start = obj->segs[i].fileoff;",
      "776:   ut64 end = start + obj->segs[i].filesize;",
      "777:   if (end >= off && start <= eob) {",
      "",
      "[Removed Lines]",
      "774:   ut64 page_size = obj->chained_starts[i]->page_size;",
      "",
      "[Added Lines]",
      "774:   int page_size = obj->chained_starts[i]->page_size;",
      "775:   if (page_size < 1) {",
      "776:    page_size = 4096;",
      "777:   }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "ee210ed16a01bf05c0090178582ae5ac327b1efa",
      "candidate_info": {
        "commit_hash": "ee210ed16a01bf05c0090178582ae5ac327b1efa",
        "repo": "radareorg/radare2",
        "commit_url": "https://github.com/radareorg/radare2/commit/ee210ed16a01bf05c0090178582ae5ac327b1efa",
        "files": [
          "libr/bin/bfile.c",
          "libr/bin/bobj.c",
          "libr/bin/p/bin_mach0.c"
        ],
        "message": "Rebase and strip pointers on Mach-O arm64e ##bin\n\nRebasing and stripping happens on-the-fly by swizzling\nthe io read function and leveraging the chain starts\ngenerated by supporting the BIND_OPCODE_THREADED\nmachinery.\n\nFor the swizzling to work, all reads generated\nduring r_bin_object_set_items() must go through the\nswizzled read function.\n\nTo make this possible, these 3 conditions must be true:\n1- r_bin_file_set_obj must be called before the first read\n2- the corresponding bin file must be already in the\nbinfiles list before the first read\n3- the swizzled read function must be able to find the\nright MACH0_(obj_t) among all active bin objects\n\nThis feature is enabled only when opening arm64 binaries.",
        "before_after_code_files": [
          "libr/bin/bfile.c||libr/bin/bfile.c",
          "libr/bin/bobj.c||libr/bin/bobj.c",
          "libr/bin/p/bin_mach0.c||libr/bin/p/bin_mach0.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libr/bin/p/bin_mach0.c||libr/bin/p/bin_mach0.c"
          ],
          "candidate": [
            "libr/bin/p/bin_mach0.c||libr/bin/p/bin_mach0.c"
          ]
        }
      },
      "candidate_diff": {
        "libr/bin/bfile.c||libr/bin/bfile.c": [
          "File: libr/bin/bfile.c -> libr/bin/bfile.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "519:  RBinFile *bf = r_bin_file_new (bin, file, r_buf_size (buf), rawstr, fd, pluginname, NULL, false);",
          "520:  if (bf) {",
          "521:   bf->buf = r_buf_ref (buf);",
          "522:   RBinPlugin *plugin = get_plugin_from_buffer (bin, pluginname, bf->buf);",
          "523:   RBinObject *o = r_bin_object_new (bf, plugin, baseaddr, loadaddr, 0, r_buf_size (bf->buf));",
          "524:   if (!o) {",
          "526:    return NULL;",
          "527:   }",
          "",
          "[Removed Lines]",
          "525:    r_bin_file_free (bf);",
          "",
          "[Added Lines]",
          "521:   RListIter *item = r_list_append (bin->binfiles, bf);",
          "526:    r_list_delete (bin->binfiles, item);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "530:   if (!o->size) {",
          "531:    o->size = r_buf_size (buf);",
          "532:   }",
          "534:  }",
          "535:  return bf;",
          "536: }",
          "",
          "[Removed Lines]",
          "533:   r_list_append (bin->binfiles, bf);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "libr/bin/bobj.c||libr/bin/bobj.c": [
          "File: libr/bin/bobj.c -> libr/bin/bobj.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "173:  r_bin_file_set_obj (bf->rbin, bf, o);",
          "174:  r_bin_set_baddr (bf->rbin, o->baddr);",
          "176:  bf->sdb_info = o->kv;",
          "177:  sdb = bf->rbin->sdb;",
          "",
          "[Removed Lines]",
          "172:  r_bin_object_set_items (bf, o);",
          "",
          "[Added Lines]",
          "174:  r_bin_object_set_items (bf, o);",
          "",
          "---------------"
        ],
        "libr/bin/p/bin_mach0.c||libr/bin/p/bin_mach0.c": [
          "File: libr/bin/p/bin_mach0.c -> libr/bin/p/bin_mach0.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4: #include <r_util.h>",
          "5: #include <r_lib.h>",
          "6: #include <r_bin.h>",
          "7: #include \"../i/private.h\"",
          "8: #include \"mach0/mach0.h\"",
          "9: #include \"objc/mach0_classes.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "7: #include <r_core.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "16: static RBinInfo *info(RBinFile *bf);",
          "18: static Sdb *get_sdb (RBinFile *bf) {",
          "19:  RBinObject *o = bf->o;",
          "20:  if (!o) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "19: static void swizzle_io_read(struct MACH0_(obj_t) *obj, RIO *io);",
          "20: static int rebasing_and_stripping_io_read(RIO *io, RIODesc *fd, ut8 *buf, int count);",
          "21: static void rebase_buffer(struct MACH0_(obj_t) *obj, ut64 off, RIODesc *fd, ut8 *buf, int count);",
          "23: #define IS_PTR_AUTH(x) ((x & (1ULL << 63)) != 0)",
          "24: #define IS_PTR_BIND(x) ((x & (1ULL << 62)) != 0)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "30:  return r_str_dup (NULL, (const char*)bin->signature);",
          "31: }",
          "34: static bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *buf, ut64 loadaddr, Sdb *sdb){",
          "35:  r_return_val_if_fail (bf && bin_obj && buf, false);",
          "36:  struct MACH0_(opts_t) opts;",
          "37:  MACH0_(opts_set_default) (&opts, bf);",
          "38:  struct MACH0_(obj_t) *res = MACH0_(new_buf) (buf, &opts);",
          "39:  if (res) {",
          "40:   sdb_ns_set (sdb, \"info\", res->kv);",
          "42:   return true;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "47:   if (res->chained_starts) {",
          "48:    RIO *io = bf->rbin->iob.io;",
          "49:    swizzle_io_read (res, io);",
          "50:   }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "420:   }",
          "421:   ptr->type = reloc->type;",
          "422:   ptr->additive = 0;",
          "426:    RBinImport *imp;",
          "427:    if (!(imp = import_from_name (bf->rbin, (char*) reloc->name, bin->imports_by_name))) {",
          "428:     break;",
          "429:    }",
          "430:    ptr->import = imp;",
          "431:   } else {",
          "432:    ptr->import = NULL;",
          "433:   }",
          "",
          "[Removed Lines]",
          "423:   if (reloc->ord >= 0 && bin->imports_by_ord && reloc->ord < bin->imports_by_ord_size) {",
          "424:    ptr->import = bin->imports_by_ord[reloc->ord];",
          "425:   } else if (reloc->name[0]) {",
          "",
          "[Added Lines]",
          "434:   if (reloc->name[0]) {",
          "440:   } else if (reloc->ord >= 0 && bin->imports_by_ord && reloc->ord < bin->imports_by_ord_size) {",
          "441:    ptr->import = bin->imports_by_ord[reloc->ord];",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "678:  return NULL;",
          "679: }",
          "681: #if !R_BIN_MACH064",
          "683: static bool check_buffer(RBuffer *b) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "692: static void swizzle_io_read(struct MACH0_(obj_t) *obj, RIO *io) {",
          "693:  r_return_if_fail (io && io->desc && io->desc->plugin);",
          "694:  RIOPlugin *plugin = io->desc->plugin;",
          "695:  obj->original_io_read = plugin->read;",
          "696:  plugin->read = &rebasing_and_stripping_io_read;",
          "697: }",
          "699: static int rebasing_and_stripping_io_read(RIO *io, RIODesc *fd, ut8 *buf, int count) {",
          "700:  r_return_val_if_fail (io, -1);",
          "701:  RCore *core = (RCore*) io->corebind.core;",
          "702:  if (!core || !core->bin || !core->bin->binfiles) {",
          "703:   return -1;",
          "704:  }",
          "705:  struct MACH0_(obj_t) *obj = NULL;",
          "706:  RListIter *iter;",
          "707:  RBinFile *bf;",
          "708:  r_list_foreach (core->bin->binfiles, iter, bf) {",
          "709:   if (bf->fd == fd->fd ) {",
          "716:    ut32 *magic = bf->o->bin_obj;",
          "717:    if (magic && (*magic == MH_MAGIC ||",
          "721:     obj = bf->o->bin_obj;",
          "722:    }",
          "723:    break;",
          "724:   }",
          "725:  }",
          "726:  if (!obj || !obj->original_io_read) {",
          "727:   if (fd->plugin->read == &rebasing_and_stripping_io_read) {",
          "728:    return -1;",
          "729:   }",
          "730:   return fd->plugin->read (io, fd, buf, count);",
          "731:  }",
          "732:  if (obj->rebasing_buffer) {",
          "733:   return obj->original_io_read (io, fd, buf, count);",
          "734:  }",
          "735:  static ut8 *internal_buffer = NULL;",
          "736:  static int internal_buf_size = 0;",
          "737:  if (count > internal_buf_size) {",
          "738:   if (internal_buffer) {",
          "739:    R_FREE (internal_buffer);",
          "740:    internal_buffer = NULL;",
          "741:   }",
          "742:   internal_buf_size = R_MAX (count, 8);",
          "743:   internal_buffer = (ut8 *) malloc (internal_buf_size);",
          "744:  }",
          "745:  ut64 io_off = io->off;",
          "746:  int result = obj->original_io_read (io, fd, internal_buffer, count);",
          "747:  if (result == count) {",
          "748:   rebase_buffer (obj, io_off, fd, internal_buffer, count);",
          "749:   memcpy (buf, internal_buffer, result);",
          "750:  }",
          "751:  return result;",
          "752: }",
          "754: static void rebase_buffer(struct MACH0_(obj_t) *obj, ut64 off, RIODesc *fd, ut8 *buf, int count) {",
          "755:  if (obj->rebasing_buffer) {",
          "756:   return;",
          "757:  }",
          "758:  obj->rebasing_buffer = true;",
          "759:  ut64 eob = off + count;",
          "760:  int i = 0;",
          "761:  for (; i < obj->nsegs; i++) {",
          "762:   if (!obj->chained_starts[i]) {",
          "763:    continue;",
          "764:   }",
          "765:   ut64 page_size = obj->chained_starts[i]->page_size;",
          "766:   ut64 start = obj->segs[i].fileoff;",
          "767:   ut64 end = start + obj->segs[i].filesize;",
          "768:   if (end >= off && start <= eob) {",
          "769:    ut64 page_idx = (R_MAX (start, off) - start) / page_size;",
          "770:    ut64 page_end_idx = (R_MIN (eob, end) - start) / page_size;",
          "771:    for (; page_idx <= page_end_idx; page_idx++) {",
          "772:     if (page_idx >= obj->chained_starts[i]->page_count) {",
          "773:      break;",
          "774:     }",
          "775:     ut16 page_start = obj->chained_starts[i]->page_start[page_idx];",
          "776:     if (page_start == DYLD_CHAINED_PTR_START_NONE) {",
          "777:      continue;",
          "778:     }",
          "779:     ut64 cursor = start + page_idx * page_size + page_start;",
          "780:     while (cursor < eob && cursor < end) {",
          "781:      ut8 tmp[8];",
          "782:      if (r_buf_read_at (obj->b, cursor, tmp, 8) != 8) {",
          "783:       break;",
          "784:      }",
          "785:      ut64 raw_ptr = r_read_le64 (tmp);",
          "786:      bool is_auth = IS_PTR_AUTH (raw_ptr);",
          "787:      bool is_bind = IS_PTR_BIND (raw_ptr);",
          "788:      ut64 ptr_value = raw_ptr;",
          "789:      ut64 delta;",
          "790:      if (is_auth && is_bind) {",
          "791:       struct dyld_chained_ptr_arm64e_auth_bind *p =",
          "792:         (struct dyld_chained_ptr_arm64e_auth_bind *) &raw_ptr;",
          "793:       delta = p->next;",
          "794:      } else if (!is_auth && is_bind) {",
          "795:       struct dyld_chained_ptr_arm64e_bind *p =",
          "796:         (struct dyld_chained_ptr_arm64e_bind *) &raw_ptr;",
          "797:       delta = p->next;",
          "798:      } else if (is_auth && !is_bind) {",
          "799:       struct dyld_chained_ptr_arm64e_auth_rebase *p =",
          "800:         (struct dyld_chained_ptr_arm64e_auth_rebase *) &raw_ptr;",
          "801:       delta = p->next;",
          "802:       ptr_value = p->target + obj->baddr;",
          "803:      } else {",
          "804:       struct dyld_chained_ptr_arm64e_rebase *p =",
          "805:         (struct dyld_chained_ptr_arm64e_rebase *) &raw_ptr;",
          "806:       delta = p->next;",
          "807:       ptr_value = ((ut64)p->high8 << 56) | p->target;",
          "808:      }",
          "809:      ut64 in_buf = cursor - off;",
          "810:      if (cursor >= off && cursor <= eob - 8) {",
          "811:       r_write_le64 (&buf[in_buf], ptr_value);",
          "812:      }",
          "813:      cursor += delta * 8;",
          "814:      if (!delta) {",
          "815:       break;",
          "816:      }",
          "817:     }",
          "818:    }",
          "819:   }",
          "820:  }",
          "821:  obj->rebasing_buffer = false;",
          "822: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "5450345e9bfd4817d24f834a5dca64fb3c5e250d",
      "candidate_info": {
        "commit_hash": "5450345e9bfd4817d24f834a5dca64fb3c5e250d",
        "repo": "radareorg/radare2",
        "commit_url": "https://github.com/radareorg/radare2/commit/5450345e9bfd4817d24f834a5dca64fb3c5e250d",
        "files": [
          "libr/bin/format/mach0/mach0_defines.h",
          "libr/bin/p/bin_mach0.c",
          "test/db/formats/mach0/objc"
        ],
        "message": "Support Mach-O DYLD_CHAINED_PTR_64_OFFSET format ##bin",
        "before_after_code_files": [
          "libr/bin/format/mach0/mach0_defines.h||libr/bin/format/mach0/mach0_defines.h",
          "libr/bin/p/bin_mach0.c||libr/bin/p/bin_mach0.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libr/bin/p/bin_mach0.c||libr/bin/p/bin_mach0.c"
          ],
          "candidate": [
            "libr/bin/p/bin_mach0.c||libr/bin/p/bin_mach0.c"
          ]
        }
      },
      "candidate_diff": {
        "libr/bin/format/mach0/mach0_defines.h||libr/bin/format/mach0/mach0_defines.h": [
          "File: libr/bin/format/mach0/mach0_defines.h -> libr/bin/format/mach0/mach0_defines.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "1485:  DYLD_CHAINED_PTR_32          = 3,",
          "1486:  DYLD_CHAINED_PTR_32_CACHE    = 4,",
          "1487:  DYLD_CHAINED_PTR_32_FIRMWARE = 5,",
          "1488:  DYLD_CHAINED_PTR_ARM64E_KERNEL = 7,",
          "1489:  DYLD_CHAINED_PTR_64_KERNEL_CACHE = 8,",
          "1490: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1488:  DYLD_CHAINED_PTR_64_OFFSET = 6,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1544:   auth : 1; // == 1",
          "1545: };",
          "1547: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1548: struct dyld_chained_ptr_64_rebase {",
          "1549:  uint64_t target : 36,",
          "1550:   high8 : 8,",
          "1551:   reserved : 7,",
          "1552:   next : 12,",
          "1553:   bind : 1; // == 0",
          "1554: };",
          "1556: struct dyld_chained_ptr_64_bind {",
          "1557:  uint64_t ordinal : 24,",
          "1558:   addend : 8,",
          "1559:   reserved : 19,",
          "1560:   next : 12,",
          "1561:   bind : 1; // == 1",
          "1562: };",
          "",
          "---------------"
        ],
        "libr/bin/p/bin_mach0.c||libr/bin/p/bin_mach0.c": [
          "File: libr/bin/p/bin_mach0.c -> libr/bin/p/bin_mach0.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "799:       break;",
          "800:      }",
          "801:      ut64 raw_ptr = r_read_le64 (tmp);",
          "804:      ut64 ptr_value = raw_ptr;",
          "819:      } else {",
          "824:      }",
          "825:      ut64 in_buf = cursor - off;",
          "826:      if (cursor >= off && cursor <= eob - 8) {",
          "827:       r_write_le64 (&buf[in_buf], ptr_value);",
          "828:      }",
          "830:      if (!delta) {",
          "831:       break;",
          "832:      }",
          "",
          "[Removed Lines]",
          "802:      bool is_auth = IS_PTR_AUTH (raw_ptr);",
          "803:      bool is_bind = IS_PTR_BIND (raw_ptr);",
          "805:      ut64 delta;",
          "806:      if (is_auth && is_bind) {",
          "807:       struct dyld_chained_ptr_arm64e_auth_bind *p =",
          "808:         (struct dyld_chained_ptr_arm64e_auth_bind *) &raw_ptr;",
          "809:       delta = p->next;",
          "810:      } else if (!is_auth && is_bind) {",
          "811:       struct dyld_chained_ptr_arm64e_bind *p =",
          "812:         (struct dyld_chained_ptr_arm64e_bind *) &raw_ptr;",
          "813:       delta = p->next;",
          "814:      } else if (is_auth && !is_bind) {",
          "815:       struct dyld_chained_ptr_arm64e_auth_rebase *p =",
          "816:         (struct dyld_chained_ptr_arm64e_auth_rebase *) &raw_ptr;",
          "817:       delta = p->next;",
          "818:       ptr_value = p->target + obj->baddr;",
          "820:       struct dyld_chained_ptr_arm64e_rebase *p =",
          "821:         (struct dyld_chained_ptr_arm64e_rebase *) &raw_ptr;",
          "822:       delta = p->next;",
          "823:       ptr_value = ((ut64)p->high8 << 56) | p->target;",
          "829:      cursor += delta * 8;",
          "",
          "[Added Lines]",
          "803:      ut64 delta, stride;",
          "804:      ut16 pointer_format = obj->chained_starts[i]->pointer_format;",
          "805:      if (pointer_format == DYLD_CHAINED_PTR_ARM64E) {",
          "806:       stride = 8;",
          "807:       bool is_auth = IS_PTR_AUTH (raw_ptr);",
          "808:       bool is_bind = IS_PTR_BIND (raw_ptr);",
          "809:       if (is_auth && is_bind) {",
          "810:        struct dyld_chained_ptr_arm64e_auth_bind *p =",
          "811:          (struct dyld_chained_ptr_arm64e_auth_bind *) &raw_ptr;",
          "812:        delta = p->next;",
          "813:       } else if (!is_auth && is_bind) {",
          "814:        struct dyld_chained_ptr_arm64e_bind *p =",
          "815:          (struct dyld_chained_ptr_arm64e_bind *) &raw_ptr;",
          "816:        delta = p->next;",
          "817:       } else if (is_auth && !is_bind) {",
          "818:        struct dyld_chained_ptr_arm64e_auth_rebase *p =",
          "819:          (struct dyld_chained_ptr_arm64e_auth_rebase *) &raw_ptr;",
          "820:        delta = p->next;",
          "821:        ptr_value = p->target + obj->baddr;",
          "822:       } else {",
          "823:        struct dyld_chained_ptr_arm64e_rebase *p =",
          "824:          (struct dyld_chained_ptr_arm64e_rebase *) &raw_ptr;",
          "825:        delta = p->next;",
          "826:        ptr_value = ((ut64)p->high8 << 56) | p->target;",
          "827:       }",
          "828:      } else if (pointer_format == DYLD_CHAINED_PTR_64_OFFSET) {",
          "829:       stride = 4;",
          "830:       struct dyld_chained_ptr_64_bind *bind =",
          "831:         (struct dyld_chained_ptr_64_bind *) &raw_ptr;",
          "832:       if (bind->bind) {",
          "833:        delta = bind->next;",
          "834:       } else {",
          "835:        struct dyld_chained_ptr_64_rebase *p =",
          "836:         (struct dyld_chained_ptr_64_rebase *)&raw_ptr;",
          "837:        delta = p->next;",
          "838:        ptr_value = obj->baddr + (((ut64)p->high8 << 56) | p->target);",
          "839:       }",
          "841:       eprintf (\"Unsupported chained pointer format\\n\");",
          "842:       goto beach;",
          "848:      cursor += delta * stride;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "834:    }",
          "835:   }",
          "836:  }",
          "837:  obj->rebasing_buffer = false;",
          "838: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "856: beach:",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "169c643a7ad7a1978ff39fba0c326bd26c9f1d4c",
      "candidate_info": {
        "commit_hash": "169c643a7ad7a1978ff39fba0c326bd26c9f1d4c",
        "repo": "radareorg/radare2",
        "commit_url": "https://github.com/radareorg/radare2/commit/169c643a7ad7a1978ff39fba0c326bd26c9f1d4c",
        "files": [
          "libr/bin/format/mach0/mach0_defines.h",
          "libr/bin/p/bin_mach0.c",
          "test/db/formats/mach0/objc"
        ],
        "message": "Add support for rebasing ARM64E_USERLAND24 chained format ##bin",
        "before_after_code_files": [
          "libr/bin/format/mach0/mach0_defines.h||libr/bin/format/mach0/mach0_defines.h",
          "libr/bin/p/bin_mach0.c||libr/bin/p/bin_mach0.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libr/bin/p/bin_mach0.c||libr/bin/p/bin_mach0.c"
          ],
          "candidate": [
            "libr/bin/p/bin_mach0.c||libr/bin/p/bin_mach0.c"
          ]
        }
      },
      "candidate_diff": {
        "libr/bin/format/mach0/mach0_defines.h||libr/bin/format/mach0/mach0_defines.h": [
          "File: libr/bin/format/mach0/mach0_defines.h -> libr/bin/format/mach0/mach0_defines.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "1488:  DYLD_CHAINED_PTR_64_OFFSET = 6,",
          "1489:  DYLD_CHAINED_PTR_ARM64E_KERNEL = 7,",
          "1490:  DYLD_CHAINED_PTR_64_KERNEL_CACHE = 8,",
          "1491: };",
          "1493: struct dyld_chained_ptr_arm64e_rebase {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1491:  DYLD_CHAINED_PTR_ARM64E_USERLAND24 = 12,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1561:   bind : 1; // == 1",
          "1562: };",
          "1564: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1565: struct dyld_chained_ptr_arm64e_bind24 {",
          "1566:  uint64_t ordinal : 24,",
          "1567:   zero : 8,",
          "1568:   addend : 19,",
          "1569:   next : 11,",
          "1570:   bind : 1, // == 1",
          "1571:   auth : 1; // == 0",
          "1572: };",
          "1574: struct dyld_chained_ptr_arm64e_auth_bind24 {",
          "1575:  uint64_t ordinal : 24,",
          "1576:   zero : 8,",
          "1577:   diversity : 16,",
          "1578:   addrDiv : 1,",
          "1579:   key : 2,",
          "1580:   next : 11,",
          "1581:   bind : 1, // == 1",
          "1582:   auth : 1; // == 1",
          "1583: };",
          "",
          "---------------"
        ],
        "libr/bin/p/bin_mach0.c||libr/bin/p/bin_mach0.c": [
          "File: libr/bin/p/bin_mach0.c -> libr/bin/p/bin_mach0.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "825:        delta = p->next;",
          "826:        ptr_value = ((ut64)p->high8 << 56) | p->target;",
          "827:       }",
          "828:      } else if (pointer_format == DYLD_CHAINED_PTR_64_OFFSET) {",
          "829:       stride = 4;",
          "830:       struct dyld_chained_ptr_64_bind *bind =",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "828:      } else if (pointer_format == DYLD_CHAINED_PTR_ARM64E_USERLAND24) {",
          "829:       stride = 8;",
          "830:       struct dyld_chained_ptr_arm64e_bind24 *bind =",
          "831:         (struct dyld_chained_ptr_arm64e_bind24 *) &raw_ptr;",
          "832:       if (bind->bind) {",
          "833:        delta = bind->next;",
          "834:       } else {",
          "835:        if (bind->auth) {",
          "836:         struct dyld_chained_ptr_arm64e_auth_rebase *p =",
          "837:           (struct dyld_chained_ptr_arm64e_auth_rebase *) &raw_ptr;",
          "838:         delta = p->next;",
          "839:         ptr_value = p->target + obj->baddr;",
          "840:        } else {",
          "841:         struct dyld_chained_ptr_arm64e_rebase *p =",
          "842:          (struct dyld_chained_ptr_arm64e_rebase *) &raw_ptr;",
          "843:         delta = p->next;",
          "844:         ptr_value = obj->baddr + (((ut64)p->high8 << 56) | p->target);",
          "845:        }",
          "846:       }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "838:        ptr_value = obj->baddr + (((ut64)p->high8 << 56) | p->target);",
          "839:       }",
          "840:      } else {",
          "842:       goto beach;",
          "843:      }",
          "844:      ut64 in_buf = cursor - off;",
          "",
          "[Removed Lines]",
          "841:       eprintf (\"Unsupported chained pointer format\\n\");",
          "",
          "[Added Lines]",
          "860:       eprintf (\"Unsupported chained pointer format %d\\n\", pointer_format);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "bae21844d0caceb9e9d0187a5b70e63aa6b7c62f",
      "candidate_info": {
        "commit_hash": "bae21844d0caceb9e9d0187a5b70e63aa6b7c62f",
        "repo": "radareorg/radare2",
        "commit_url": "https://github.com/radareorg/radare2/commit/bae21844d0caceb9e9d0187a5b70e63aa6b7c62f",
        "files": [
          "libr/bin/format/mach0/mach0.c",
          "libr/bin/format/mach0/mach0.h",
          "libr/bin/format/mach0/mach0_defines.h",
          "libr/bin/p/bin_mach0.c",
          "test/db/anal/classes",
          "test/db/cmd/cmd_tc",
          "test/db/formats/mach0/fatmach0",
          "test/db/formats/mach0/objc"
        ],
        "message": "Parse relocs from Mach-O chained binds if no opcodes ##bin",
        "before_after_code_files": [
          "libr/bin/format/mach0/mach0.c||libr/bin/format/mach0/mach0.c",
          "libr/bin/format/mach0/mach0.h||libr/bin/format/mach0/mach0.h",
          "libr/bin/format/mach0/mach0_defines.h||libr/bin/format/mach0/mach0_defines.h",
          "libr/bin/p/bin_mach0.c||libr/bin/p/bin_mach0.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libr/bin/p/bin_mach0.c||libr/bin/p/bin_mach0.c"
          ],
          "candidate": [
            "libr/bin/p/bin_mach0.c||libr/bin/p/bin_mach0.c"
          ]
        }
      },
      "candidate_diff": {
        "libr/bin/format/mach0/mach0.c||libr/bin/format/mach0/mach0.c": [
          "File: libr/bin/format/mach0/mach0.c -> libr/bin/format/mach0/mach0.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "10: #define bprintf if (bin->verbose) eprintf",
          "11: #define Eprintf if (mo->verbose) eprintf",
          "13: typedef struct {",
          "14:  struct symbol_t *symbols;",
          "15:  int j;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "13: #define IS_PTR_AUTH(x) ((x & (1ULL << 63)) != 0)",
          "14: #define IS_PTR_BIND(x) ((x & (1ULL << 62)) != 0)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "26:  ut8 *next_child;",
          "27: } RTrieState;",
          "31: #define mach0_endian 1",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "32: typedef struct {",
          "33:  ut8 * imports;",
          "34:  RSkipList *relocs;",
          "35: } RWalkBindChainsContext;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1510:  if (!bin->chained_starts) {",
          "1511:   return false;",
          "1512:  }",
          "1513:  size_t i;",
          "1514:  ut64 cursor = starts_at + sizeof (ut32);",
          "1515:  for (i = 0; i < segs_count; i++) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1521:  bin->fixups_header = header;",
          "1522:  bin->fixups_offset = offset;",
          "1523:  bin->fixups_size = size;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "3187:  free (info);",
          "3188: }",
          "3190: static bool is_valid_ordinal_table_size(ut64 size) {",
          "3191:  return size > 0 && size <= UT16_MAX;",
          "3192: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3201: static bool walk_bind_chains_callback(void * context, RFixupEventDetails * event_details) {",
          "3202:  r_return_val_if_fail (event_details->type == R_FIXUP_EVENT_BIND || event_details->type == R_FIXUP_EVENT_BIND_AUTH, false);",
          "3203:  RWalkBindChainsContext *ctx = context;",
          "3204:  ut8 *imports = ctx->imports;",
          "3205:  struct MACH0_(obj_t) *bin = event_details->bin;",
          "3206:  ut32 imports_count = bin->fixups_header.imports_count;",
          "3207:  ut32 fixups_offset = bin->fixups_offset;",
          "3208:  ut32 fixups_size = bin->fixups_size;",
          "3209:  ut32 imports_format = bin->fixups_header.imports_format;",
          "3210:  ut32 import_index = ((RFixupBindEventDetails *) event_details)->ordinal;",
          "3211:  ut64 addend = 0;",
          "3212:  if (event_details->type != R_FIXUP_EVENT_BIND_AUTH) {",
          "3213:   addend = ((RFixupBindEventDetails *) event_details)->addend;",
          "3214:  }",
          "3216:  if (import_index < imports_count) {",
          "3217:   ut64 name_offset;",
          "3218:   switch (imports_format) {",
          "3219:    case DYLD_CHAINED_IMPORT: {",
          "3220:     struct dyld_chained_import * item = &((struct dyld_chained_import *) imports)[import_index];",
          "3221:     name_offset = item->name_offset;",
          "3222:     break;",
          "3223:    }",
          "3224:    case DYLD_CHAINED_IMPORT_ADDEND: {",
          "3225:     struct dyld_chained_import_addend * item = &((struct dyld_chained_import_addend *) imports)[import_index];",
          "3226:     name_offset = item->name_offset;",
          "3227:     addend += item->addend;",
          "3228:     break;",
          "3229:    }",
          "3230:    case DYLD_CHAINED_IMPORT_ADDEND64: {",
          "3231:     struct dyld_chained_import_addend64 * item = &((struct dyld_chained_import_addend64 *) imports)[import_index];",
          "3232:     name_offset = item->name_offset;",
          "3233:     addend += item->addend;",
          "3234:     break;",
          "3235:    }",
          "3236:    default:",
          "3237:     bprintf (\"Unsupported imports format\\n\");",
          "3238:     return false;",
          "3239:   }",
          "3241:   ut64 symbols_offset = bin->fixups_header.symbols_offset + fixups_offset;",
          "3243:   if (symbols_offset + name_offset + 1 < fixups_offset + fixups_size) {",
          "3244:    char *name = r_buf_get_string (bin->b, symbols_offset + name_offset);",
          "3245:    if (name) {",
          "3246:     struct reloc_t *reloc = R_NEW0 (struct reloc_t);",
          "3247:     if (!reloc) {",
          "3248:      free (name);",
          "3249:      return false;",
          "3250:     }",
          "3251:     reloc->addr = offset_to_vaddr (bin, event_details->offset);",
          "3252:     reloc->offset = event_details->offset;",
          "3253:     reloc->ord = import_index;",
          "3254:     reloc->type = R_BIN_RELOC_64;",
          "3255:     reloc->size = 8;",
          "3256:     reloc->addend = addend;",
          "3257:     r_str_ncpy (reloc->name, name, sizeof (reloc->name) - 1);",
          "3258:     r_skiplist_insert (ctx->relocs, reloc);",
          "3259:     free (name);",
          "3260:    } else if (bin->verbose) {",
          "3261:     eprintf (\"Malformed chained bind: failed to read name\\n\");",
          "3262:    }",
          "3263:   } else if (bin->verbose) {",
          "3264:    eprintf (\"Malformed chained bind: name_offset out of bounds\\n\");",
          "3265:   }",
          "3266:  } else if (bin->verbose) {",
          "3267:   eprintf (\"Malformed chained bind: import out of length\\n\");",
          "3268:  }",
          "3270:  return true;",
          "3271: }",
          "3273: static void walk_bind_chains(struct MACH0_(obj_t) *bin, RSkipList *relocs) {",
          "3274:  r_return_if_fail (bin && bin->fixups_offset);",
          "3276:  ut8 *imports = NULL;",
          "3278:  ut32 imports_count = bin->fixups_header.imports_count;",
          "3279:  ut32 fixups_offset = bin->fixups_offset;",
          "3280:  ut32 imports_offset = bin->fixups_header.imports_offset;",
          "3281:  if (!imports_count || !imports_offset) {",
          "3282:   return;",
          "3283:  }",
          "3284:  if (bin->fixups_header.symbols_format != 0) {",
          "3285:   eprintf (\"Compressed fixups symbols not supported yet, please file a bug with a sample attached.\\n\");",
          "3286:   return;",
          "3287:  }",
          "3289:  ut32 imports_format = bin->fixups_header.imports_format;",
          "3290:  ut64 imports_size;",
          "3291:  switch (imports_format) {",
          "3292:   case DYLD_CHAINED_IMPORT:",
          "3293:    imports_size = sizeof (struct dyld_chained_import) * imports_count;",
          "3294:    break;",
          "3295:   case DYLD_CHAINED_IMPORT_ADDEND:",
          "3296:    imports_size = sizeof (struct dyld_chained_import_addend) * imports_count;",
          "3297:    break;",
          "3298:   case DYLD_CHAINED_IMPORT_ADDEND64:",
          "3299:    imports_size = sizeof (struct dyld_chained_import_addend64) * imports_count;",
          "3300:    break;",
          "3301:   default:",
          "3302:    eprintf (\"Unsupported chained imports format: %d\\n\", imports_format);",
          "3303:    goto beach;",
          "3304:  }",
          "3306:  imports = malloc (imports_size);",
          "3307:  if (!imports) {",
          "3308:   goto beach;",
          "3309:  }",
          "3311:  switch (imports_format) {",
          "3312:   case DYLD_CHAINED_IMPORT:",
          "3313:    if (r_buf_fread_at (bin->b, fixups_offset + imports_offset,",
          "3314:      imports, \"i\", imports_count) != imports_size) {",
          "3315:     goto beach;",
          "3316:    }",
          "3317:    break;",
          "3318:   case DYLD_CHAINED_IMPORT_ADDEND:",
          "3319:    if (r_buf_fread_at (bin->b, fixups_offset + imports_offset,",
          "3320:      imports, \"ii\", imports_count) != imports_size) {",
          "3321:     goto beach;",
          "3322:    }",
          "3323:    break;",
          "3324:   case DYLD_CHAINED_IMPORT_ADDEND64:",
          "3325:    if (r_buf_fread_at (bin->b, fixups_offset + imports_offset,",
          "3326:      imports, \"il\", imports_count) != imports_size) {",
          "3327:     goto beach;",
          "3328:    }",
          "3329:    break;",
          "3330:  }",
          "3332:  RWalkBindChainsContext ctx;",
          "3333:  ctx.imports = imports;",
          "3334:  ctx.relocs = relocs;",
          "3336:  MACH0_(iterate_chained_fixups) (bin, 0, UT64_MAX, R_FIXUP_EVENT_MASK_BIND_ALL, &walk_bind_chains_callback, &ctx);",
          "3338: beach:",
          "3339:  free (imports);",
          "3340: }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "3536:   if (!relocs) {",
          "3537:    relocs = r_skiplist_new ((RListFree) &free, (RListComparator) &reloc_comparator);",
          "3538:    if (!relocs) {",
          "3540:    }",
          "3541:   }",
          "3542:   for (j = 0; j < amount; j++) {",
          "",
          "[Removed Lines]",
          "3539:     return NULL;",
          "",
          "[Added Lines]",
          "3691:     goto beach;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "3557:   if (!relocs) {",
          "3558:    relocs = r_skiplist_new ((RListFree) &free, (RListComparator) &reloc_comparator);",
          "3559:    if (!relocs) {",
          "3561:    }",
          "3562:   }",
          "3563:   parse_relocation_info (bin, relocs, bin->dysymtab.extreloff, bin->dysymtab.nextrel);",
          "3564:  }",
          "3565: beach:",
          "3566:  r_pvector_free (threaded_binds);",
          "3567:  return relocs;",
          "",
          "[Removed Lines]",
          "3560:     return NULL;",
          "",
          "[Added Lines]",
          "3712:     goto beach;",
          "3718:  if (!bin->dyld_info && bin->chained_starts && bin->nsegs && bin->fixups_offset) {",
          "3719:   if (!relocs) {",
          "3720:    relocs = r_skiplist_new ((RListFree) &free, (RListComparator) &reloc_comparator);",
          "3721:    if (!relocs) {",
          "3722:     goto beach;",
          "3723:    }",
          "3724:   }",
          "3725:   walk_bind_chains (bin, relocs);",
          "3726:  }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "4379: #endif",
          "4380:  return macho_hdr;",
          "4381: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4545: void MACH0_(iterate_chained_fixups)(struct MACH0_(obj_t) *bin, ut64 limit_start, ut64 limit_end, ut32 event_mask, RFixupCallback callback, void * context) {",
          "4546:  int i = 0;",
          "4547:  for (; i < bin->nsegs; i++) {",
          "4548:   if (!bin->chained_starts[i]) {",
          "4549:    continue;",
          "4550:   }",
          "4551:   int page_size = bin->chained_starts[i]->page_size;",
          "4552:   if (page_size < 1) {",
          "4553:    page_size = 4096;",
          "4554:   }",
          "4555:   ut64 start = bin->segs[i].fileoff;",
          "4556:   ut64 end = start + bin->segs[i].filesize;",
          "4557:   if (end >= limit_start && start <= limit_end) {",
          "4558:    ut64 page_idx = (R_MAX (start, limit_start) - start) / page_size;",
          "4559:    ut64 page_end_idx = (R_MIN (limit_end, end) - start) / page_size;",
          "4560:    for (; page_idx <= page_end_idx; page_idx++) {",
          "4561:     if (page_idx >= bin->chained_starts[i]->page_count) {",
          "4562:      break;",
          "4563:     }",
          "4564:     ut16 page_start = bin->chained_starts[i]->page_start[page_idx];",
          "4565:     if (page_start == DYLD_CHAINED_PTR_START_NONE) {",
          "4566:      continue;",
          "4567:     }",
          "4568:     ut64 cursor = start + page_idx * page_size + page_start;",
          "4569:     while (cursor < limit_end && cursor < end) {",
          "4570:      ut8 tmp[8];",
          "4571:      bool previous_rebasing = bin->rebasing_buffer;",
          "4572:      bin->rebasing_buffer = true;",
          "4573:      if (r_buf_read_at (bin->b, cursor, tmp, 8) != 8) {",
          "4574:       bin->rebasing_buffer = previous_rebasing;",
          "4575:       break;",
          "4576:      }",
          "4577:      bin->rebasing_buffer = previous_rebasing;",
          "4578:      ut64 raw_ptr = r_read_le64 (tmp);",
          "4579:      ut64 ptr_value = raw_ptr;",
          "4580:      ut64 delta, stride, addend;",
          "4581:      ut16 pointer_format = bin->chained_starts[i]->pointer_format;",
          "4582:      RFixupEvent event = R_FIXUP_EVENT_NONE;",
          "4583:      ut8 key = 0, addr_div = 0;",
          "4584:      ut16 diversity = 0;",
          "4585:      ut32 ordinal = UT32_MAX;",
          "4586:      if (pointer_format == DYLD_CHAINED_PTR_ARM64E) {",
          "4587:       stride = 8;",
          "4588:       bool is_auth = IS_PTR_AUTH (raw_ptr);",
          "4589:       bool is_bind = IS_PTR_BIND (raw_ptr);",
          "4590:       if (is_auth && is_bind) {",
          "4591:        struct dyld_chained_ptr_arm64e_auth_bind *p =",
          "4592:          (struct dyld_chained_ptr_arm64e_auth_bind *) &raw_ptr;",
          "4593:        event = R_FIXUP_EVENT_BIND_AUTH;",
          "4594:        delta = p->next;",
          "4595:        ordinal = p->ordinal;",
          "4596:        key = p->key;",
          "4597:        addr_div = p->addrDiv;",
          "4598:        diversity = p->diversity;",
          "4599:       } else if (!is_auth && is_bind) {",
          "4600:        struct dyld_chained_ptr_arm64e_bind *p =",
          "4601:          (struct dyld_chained_ptr_arm64e_bind *) &raw_ptr;",
          "4602:        event = R_FIXUP_EVENT_BIND;",
          "4603:        delta = p->next;",
          "4604:        ordinal = p->ordinal;",
          "4605:        addend = p->addend;",
          "4606:       } else if (is_auth && !is_bind) {",
          "4607:        struct dyld_chained_ptr_arm64e_auth_rebase *p =",
          "4608:          (struct dyld_chained_ptr_arm64e_auth_rebase *) &raw_ptr;",
          "4609:        event = R_FIXUP_EVENT_REBASE_AUTH;",
          "4610:        delta = p->next;",
          "4611:        ptr_value = p->target + bin->baddr;",
          "4612:        key = p->key;",
          "4613:        addr_div = p->addrDiv;",
          "4614:        diversity = p->diversity;",
          "4615:       } else {",
          "4616:        struct dyld_chained_ptr_arm64e_rebase *p =",
          "4617:          (struct dyld_chained_ptr_arm64e_rebase *) &raw_ptr;",
          "4618:        event = R_FIXUP_EVENT_REBASE;",
          "4619:        delta = p->next;",
          "4620:        ptr_value = ((ut64)p->high8 << 56) | p->target;",
          "4621:       }",
          "4622:      } else if (pointer_format == DYLD_CHAINED_PTR_ARM64E_USERLAND24) {",
          "4623:       stride = 8;",
          "4624:       struct dyld_chained_ptr_arm64e_bind24 *bind =",
          "4625:         (struct dyld_chained_ptr_arm64e_bind24 *) &raw_ptr;",
          "4626:       if (bind->bind) {",
          "4627:        delta = bind->next;",
          "4628:        if (bind->auth) {",
          "4629:         struct dyld_chained_ptr_arm64e_auth_bind24 *p =",
          "4630:           (struct dyld_chained_ptr_arm64e_auth_bind24 *) &raw_ptr;",
          "4631:         event = R_FIXUP_EVENT_BIND_AUTH;",
          "4632:         ordinal = p->ordinal;",
          "4633:         key = p->key;",
          "4634:         addr_div = p->addrDiv;",
          "4635:         diversity = p->diversity;",
          "4636:        } else {",
          "4637:         event = R_FIXUP_EVENT_BIND;",
          "4638:         ordinal = bind->ordinal;",
          "4639:         addend = bind->addend;",
          "4640:        }",
          "4641:       } else {",
          "4642:        if (bind->auth) {",
          "4643:         struct dyld_chained_ptr_arm64e_auth_rebase *p =",
          "4644:           (struct dyld_chained_ptr_arm64e_auth_rebase *) &raw_ptr;",
          "4645:         event = R_FIXUP_EVENT_REBASE_AUTH;",
          "4646:         delta = p->next;",
          "4647:         ptr_value = p->target + bin->baddr;",
          "4648:         key = p->key;",
          "4649:         addr_div = p->addrDiv;",
          "4650:         diversity = p->diversity;",
          "4651:        } else {",
          "4652:         struct dyld_chained_ptr_arm64e_rebase *p =",
          "4653:          (struct dyld_chained_ptr_arm64e_rebase *) &raw_ptr;",
          "4654:         event = R_FIXUP_EVENT_REBASE;",
          "4655:         delta = p->next;",
          "4656:         ptr_value = bin->baddr + (((ut64)p->high8 << 56) | p->target);",
          "4657:        }",
          "4658:       }",
          "4659:      } else if (pointer_format == DYLD_CHAINED_PTR_64_OFFSET) {",
          "4660:       stride = 4;",
          "4661:       struct dyld_chained_ptr_64_bind *bind =",
          "4662:         (struct dyld_chained_ptr_64_bind *) &raw_ptr;",
          "4663:       if (bind->bind) {",
          "4664:        event = R_FIXUP_EVENT_BIND;",
          "4665:        delta = bind->next;",
          "4666:        ordinal = bind->ordinal;",
          "4667:        addend = bind->addend;",
          "4668:       } else {",
          "4669:        struct dyld_chained_ptr_64_rebase *p =",
          "4670:         (struct dyld_chained_ptr_64_rebase *) &raw_ptr;",
          "4671:        event = R_FIXUP_EVENT_REBASE;",
          "4672:        delta = p->next;",
          "4673:        ptr_value = bin->baddr + (((ut64)p->high8 << 56) | p->target);",
          "4674:       }",
          "4675:      } else {",
          "4676:       eprintf (\"Unsupported chained pointer format %d\\n\", pointer_format);",
          "4677:       return;",
          "4678:      }",
          "4679:      if (cursor >= limit_start && cursor <= limit_end - 8 && (event & event_mask) != 0) {",
          "4680:       bool carry_on;",
          "4681:       switch (event) {",
          "4682:        case R_FIXUP_EVENT_BIND: {",
          "4683:         RFixupBindEventDetails event_details;",
          "4685:         event_details.type = event;",
          "4686:         event_details.bin = bin;",
          "4687:         event_details.offset = cursor;",
          "4688:         event_details.raw_ptr = raw_ptr;",
          "4689:         event_details.ordinal = ordinal;",
          "4690:         event_details.addend = addend;",
          "4692:         carry_on = callback (context, (RFixupEventDetails *) &event_details);",
          "4693:         break;",
          "4694:        }",
          "4695:        case R_FIXUP_EVENT_BIND_AUTH: {",
          "4696:         RFixupBindAuthEventDetails event_details;",
          "4698:         event_details.type = event;",
          "4699:         event_details.bin = bin;",
          "4700:         event_details.offset = cursor;",
          "4701:         event_details.raw_ptr = raw_ptr;",
          "4702:         event_details.ordinal = ordinal;",
          "4703:         event_details.key = key;",
          "4704:         event_details.addr_div = addr_div;",
          "4705:         event_details.diversity = diversity;",
          "4707:         carry_on = callback (context, (RFixupEventDetails *) &event_details);",
          "4708:         break;",
          "4709:        }",
          "4710:        case R_FIXUP_EVENT_REBASE: {",
          "4711:         RFixupRebaseEventDetails event_details;",
          "4713:         event_details.type = event;",
          "4714:         event_details.bin = bin;",
          "4715:         event_details.offset = cursor;",
          "4716:         event_details.raw_ptr = raw_ptr;",
          "4717:         event_details.ptr_value = ptr_value;",
          "4719:         carry_on = callback (context, (RFixupEventDetails *) &event_details);",
          "4720:         break;",
          "4721:        }",
          "4722:        case R_FIXUP_EVENT_REBASE_AUTH: {",
          "4723:         RFixupRebaseAuthEventDetails event_details;",
          "4725:         event_details.type = event;",
          "4726:         event_details.bin = bin;",
          "4727:         event_details.offset = cursor;",
          "4728:         event_details.raw_ptr = raw_ptr;",
          "4729:         event_details.ptr_value = ptr_value;",
          "4730:         event_details.key = key;",
          "4731:         event_details.addr_div = addr_div;",
          "4732:         event_details.diversity = diversity;",
          "4734:         carry_on = callback (context, (RFixupEventDetails *) &event_details);",
          "4735:         break;",
          "4736:        }",
          "4737:        default:",
          "4738:         eprintf (\"Unexpected event while iterating chained fixups\\n\");",
          "4739:         carry_on = false;",
          "4740:       }",
          "4741:       if (!carry_on) {",
          "4742:        return;",
          "4743:       }",
          "4744:      }",
          "4745:      cursor += delta * stride;",
          "4746:      if (!delta) {",
          "4747:       break;",
          "4748:      }",
          "4749:     }",
          "4750:    }",
          "4751:   }",
          "4752:  }",
          "4753: }",
          "",
          "---------------"
        ],
        "libr/bin/format/mach0/mach0.h||libr/bin/format/mach0/mach0.h": [
          "File: libr/bin/format/mach0/mach0.h -> libr/bin/format/mach0/mach0.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "36: #define CSSLOT_ENTITLEMENTS  5",
          "37: #define CSSLOT_CMS_SIGNATURE 0x10000",
          "39: struct section_t {",
          "40:  ut64 offset;",
          "41:  ut64 addr;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "39: typedef enum {",
          "40:  R_FIXUP_EVENT_NONE = 0,",
          "41:  R_FIXUP_EVENT_REBASE = 1,",
          "42:  R_FIXUP_EVENT_REBASE_AUTH = 2,",
          "43:  R_FIXUP_EVENT_BIND = 4,",
          "44:  R_FIXUP_EVENT_BIND_AUTH = 8,",
          "45: } RFixupEvent;",
          "47: #define R_FIXUP_EVENT_MASK_BIND_ALL (R_FIXUP_EVENT_BIND | R_FIXUP_EVENT_BIND_AUTH)",
          "48: #define R_FIXUP_EVENT_MASK_REBASE_ALL (R_FIXUP_EVENT_REBASE | R_FIXUP_EVENT_REBASE_AUTH)",
          "49: #define R_FIXUP_EVENT_MASK_ALL (R_FIXUP_EVENT_MASK_BIND_ALL | R_FIXUP_EVENT_MASK_REBASE_ALL)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "119:  char *compiler;",
          "120:  int nsegs;",
          "121:  struct r_dyld_chained_starts_in_segment **chained_starts;",
          "122:  struct MACH0_(section) *sects;",
          "123:  int nsects;",
          "124:  struct MACH0_(nlist) *symtab;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "134:  struct dyld_chained_fixups_header fixups_header;",
          "135:  ut64 fixups_offset;",
          "136:  ut64 fixups_size;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "180:  bool rebasing_buffer;",
          "181: };",
          "183: void MACH0_(opts_set_default)(struct MACH0_(opts_t) *options, RBinFile *bf);",
          "184: struct MACH0_(obj_t) *MACH0_(mach0_new)(const char *file, struct MACH0_(opts_t) *options);",
          "185: struct MACH0_(obj_t) *MACH0_(new_buf)(RBuffer *buf, struct MACH0_(opts_t) *options);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "198: typedef struct {",
          "199:  RFixupEvent type;",
          "200:  struct MACH0_(obj_t) *bin;",
          "201:  ut64 offset;",
          "202:  ut64 raw_ptr;",
          "203: } RFixupEventDetails;",
          "205: typedef struct {",
          "206:  RFixupEvent type;",
          "207:  struct MACH0_(obj_t) *bin;",
          "208:  ut64 offset;",
          "209:  ut64 raw_ptr;",
          "210:  ut64 ordinal;",
          "211:  ut64 addend;",
          "212: } RFixupBindEventDetails;",
          "214: typedef struct {",
          "215:  RFixupEvent type;",
          "216:  struct MACH0_(obj_t) *bin;",
          "217:  ut64 offset;",
          "218:  ut64 raw_ptr;",
          "219:  ut32 ordinal;",
          "220:  ut8 key;",
          "221:  ut8 addr_div;",
          "222:  ut16 diversity;",
          "223: } RFixupBindAuthEventDetails;",
          "225: typedef struct {",
          "226:  RFixupEvent type;",
          "227:  struct MACH0_(obj_t) *bin;",
          "228:  ut64 offset;",
          "229:  ut64 raw_ptr;",
          "230:  ut64 ptr_value;",
          "231: } RFixupRebaseEventDetails;",
          "233: typedef struct {",
          "234:  RFixupEvent type;",
          "235:  struct MACH0_(obj_t) *bin;",
          "236:  ut64 offset;",
          "237:  ut64 raw_ptr;",
          "238:  ut64 ptr_value;",
          "239:  ut8 key;",
          "240:  ut8 addr_div;",
          "241:  ut16 diversity;",
          "242: } RFixupRebaseAuthEventDetails;",
          "244: typedef bool (*RFixupCallback)(void * context, RFixupEventDetails * event_details);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "213: struct MACH0_(mach_header) *MACH0_(get_hdr)(RBuffer *buf);",
          "214: void MACH0_(mach_headerfields)(RBinFile *bf);",
          "215: RList *MACH0_(mach_fields)(RBinFile *bf);",
          "216: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "279: void MACH0_(iterate_chained_fixups)(struct MACH0_(obj_t) *obj, ut64 limit_start, ut64 limit_end, ut32 event_mask, RFixupCallback callback, void *context);",
          "",
          "---------------"
        ],
        "libr/bin/format/mach0/mach0_defines.h||libr/bin/format/mach0/mach0_defines.h": [
          "File: libr/bin/format/mach0/mach0_defines.h -> libr/bin/format/mach0/mach0_defines.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "1582:   auth : 1; // == 1",
          "1583: };",
          "1585: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1585: enum {",
          "1586:  DYLD_CHAINED_IMPORT          = 1,",
          "1587:  DYLD_CHAINED_IMPORT_ADDEND   = 2,",
          "1588:  DYLD_CHAINED_IMPORT_ADDEND64 = 3,",
          "1589: };",
          "1591: struct dyld_chained_import {",
          "1592:  uint32_t lib_ordinal : 8,",
          "1593:   weak_import : 1,",
          "1594:   name_offset : 23;",
          "1595: };",
          "1597: struct dyld_chained_import_addend {",
          "1598:  uint32_t lib_ordinal : 8,",
          "1599:   weak_import : 1,",
          "1600:   name_offset : 23;",
          "1601:  int32_t addend;",
          "1602: };",
          "1604: struct dyld_chained_import_addend64 {",
          "1605:  uint64_t lib_ordinal : 16,",
          "1606:   weak_import : 1,",
          "1607:   reserved : 15,",
          "1608:   name_offset : 32;",
          "1609:  uint64_t addend;",
          "1610: };",
          "",
          "---------------"
        ],
        "libr/bin/p/bin_mach0.c||libr/bin/p/bin_mach0.c": [
          "File: libr/bin/p/bin_mach0.c -> libr/bin/p/bin_mach0.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "10: #include \"objc/mach0_classes.h\"",
          "11: #include <ht_uu.h>",
          "15: extern RBinWrite r_bin_write_mach0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "13: typedef struct {",
          "14:  ut8 *buf;",
          "15:  int count;",
          "16:  ut64 off;",
          "17: } RFixupRebaseContext;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "764:  return result;",
          "765: }",
          "767: static void rebase_buffer(struct MACH0_(obj_t) *obj, ut64 off, RIODesc *fd, ut8 *buf, int count) {",
          "768:  if (obj->rebasing_buffer) {",
          "769:   return;",
          "770:  }",
          "771:  obj->rebasing_buffer = true;",
          "876:  obj->rebasing_buffer = false;",
          "877: }",
          "",
          "[Removed Lines]",
          "772:  ut64 eob = off + count;",
          "773:  int i = 0;",
          "774:  for (; i < obj->nsegs; i++) {",
          "775:   if (!obj->chained_starts[i]) {",
          "776:    continue;",
          "777:   }",
          "778:   int page_size = obj->chained_starts[i]->page_size;",
          "779:   if (page_size < 1) {",
          "780:    page_size = 4096;",
          "781:   }",
          "782:   ut64 start = obj->segs[i].fileoff;",
          "783:   ut64 end = start + obj->segs[i].filesize;",
          "784:   if (end >= off && start <= eob) {",
          "785:    ut64 page_idx = (R_MAX (start, off) - start) / page_size;",
          "786:    ut64 page_end_idx = (R_MIN (eob, end) - start) / page_size;",
          "787:    for (; page_idx <= page_end_idx; page_idx++) {",
          "788:     if (page_idx >= obj->chained_starts[i]->page_count) {",
          "789:      break;",
          "790:     }",
          "791:     ut16 page_start = obj->chained_starts[i]->page_start[page_idx];",
          "792:     if (page_start == DYLD_CHAINED_PTR_START_NONE) {",
          "793:      continue;",
          "794:     }",
          "795:     ut64 cursor = start + page_idx * page_size + page_start;",
          "796:     while (cursor < eob && cursor < end) {",
          "797:      ut8 tmp[8];",
          "798:      if (r_buf_read_at (obj->b, cursor, tmp, 8) != 8) {",
          "799:       break;",
          "800:      }",
          "801:      ut64 raw_ptr = r_read_le64 (tmp);",
          "802:      ut64 ptr_value = raw_ptr;",
          "803:      ut64 delta, stride;",
          "804:      ut16 pointer_format = obj->chained_starts[i]->pointer_format;",
          "805:      if (pointer_format == DYLD_CHAINED_PTR_ARM64E) {",
          "806:       stride = 8;",
          "807:       bool is_auth = IS_PTR_AUTH (raw_ptr);",
          "808:       bool is_bind = IS_PTR_BIND (raw_ptr);",
          "809:       if (is_auth && is_bind) {",
          "810:        struct dyld_chained_ptr_arm64e_auth_bind *p =",
          "811:          (struct dyld_chained_ptr_arm64e_auth_bind *) &raw_ptr;",
          "812:        delta = p->next;",
          "813:       } else if (!is_auth && is_bind) {",
          "814:        struct dyld_chained_ptr_arm64e_bind *p =",
          "815:          (struct dyld_chained_ptr_arm64e_bind *) &raw_ptr;",
          "816:        delta = p->next;",
          "817:       } else if (is_auth && !is_bind) {",
          "818:        struct dyld_chained_ptr_arm64e_auth_rebase *p =",
          "819:          (struct dyld_chained_ptr_arm64e_auth_rebase *) &raw_ptr;",
          "820:        delta = p->next;",
          "821:        ptr_value = p->target + obj->baddr;",
          "822:       } else {",
          "823:        struct dyld_chained_ptr_arm64e_rebase *p =",
          "824:          (struct dyld_chained_ptr_arm64e_rebase *) &raw_ptr;",
          "825:        delta = p->next;",
          "826:        ptr_value = ((ut64)p->high8 << 56) | p->target;",
          "827:       }",
          "828:      } else if (pointer_format == DYLD_CHAINED_PTR_ARM64E_USERLAND24) {",
          "829:       stride = 8;",
          "830:       struct dyld_chained_ptr_arm64e_bind24 *bind =",
          "831:         (struct dyld_chained_ptr_arm64e_bind24 *) &raw_ptr;",
          "832:       if (bind->bind) {",
          "833:        delta = bind->next;",
          "834:       } else {",
          "835:        if (bind->auth) {",
          "836:         struct dyld_chained_ptr_arm64e_auth_rebase *p =",
          "837:           (struct dyld_chained_ptr_arm64e_auth_rebase *) &raw_ptr;",
          "838:         delta = p->next;",
          "839:         ptr_value = p->target + obj->baddr;",
          "840:        } else {",
          "841:         struct dyld_chained_ptr_arm64e_rebase *p =",
          "842:          (struct dyld_chained_ptr_arm64e_rebase *) &raw_ptr;",
          "843:         delta = p->next;",
          "844:         ptr_value = obj->baddr + (((ut64)p->high8 << 56) | p->target);",
          "845:        }",
          "846:       }",
          "847:      } else if (pointer_format == DYLD_CHAINED_PTR_64_OFFSET) {",
          "848:       stride = 4;",
          "849:       struct dyld_chained_ptr_64_bind *bind =",
          "850:         (struct dyld_chained_ptr_64_bind *) &raw_ptr;",
          "851:       if (bind->bind) {",
          "852:        delta = bind->next;",
          "853:       } else {",
          "854:        struct dyld_chained_ptr_64_rebase *p =",
          "855:         (struct dyld_chained_ptr_64_rebase *)&raw_ptr;",
          "856:        delta = p->next;",
          "857:        ptr_value = obj->baddr + (((ut64)p->high8 << 56) | p->target);",
          "858:       }",
          "859:      } else {",
          "860:       eprintf (\"Unsupported chained pointer format %d\\n\", pointer_format);",
          "861:       goto beach;",
          "862:      }",
          "863:      ut64 in_buf = cursor - off;",
          "864:      if (cursor >= off && cursor <= eob - 8) {",
          "865:       r_write_le64 (&buf[in_buf], ptr_value);",
          "866:      }",
          "867:      cursor += delta * stride;",
          "868:      if (!delta) {",
          "869:       break;",
          "870:      }",
          "871:     }",
          "872:    }",
          "873:   }",
          "874:  }",
          "875: beach:",
          "",
          "[Added Lines]",
          "773: static bool rebase_buffer_callback(void * context, RFixupEventDetails * event_details) {",
          "774:  RFixupRebaseContext *ctx = context;",
          "776:  ut64 in_buf = event_details->offset - ctx->off;",
          "777:  switch (event_details->type) {",
          "778:   case R_FIXUP_EVENT_BIND:",
          "779:   case R_FIXUP_EVENT_BIND_AUTH:",
          "780:    r_write_le64 (&ctx->buf[in_buf], 0);",
          "781:    break;",
          "782:   case R_FIXUP_EVENT_REBASE:",
          "783:   case R_FIXUP_EVENT_REBASE_AUTH:",
          "784:    r_write_le64 (&ctx->buf[in_buf], ((RFixupRebaseEventDetails *) event_details)->ptr_value);",
          "785:    break;",
          "786:   default:",
          "787:    eprintf (\"Unexpected event while rebasing buffer\\n\");",
          "788:    return false;",
          "789:  }",
          "791:  return true;",
          "792: }",
          "800:  RFixupRebaseContext ctx;",
          "802:  ctx.buf = buf;",
          "803:  ctx.count = count;",
          "804:  ctx.off = off;",
          "806:  MACH0_(iterate_chained_fixups) (obj, off, off + count, R_FIXUP_EVENT_MASK_ALL, &rebase_buffer_callback, &ctx);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2010-5329",
  "cve_desc": "The video_usercopy function in drivers/media/video/v4l2-ioctl.c in the Linux kernel before 2.6.39 relies on the count value of a v4l2_ext_controls data structure to determine a kmalloc size, which might allow local users to cause a denial of service (memory consumption) via a large value.",
  "repo": "torvalds/linux",
  "patch_hash": "fc0a80798576f80ca10b3f6c9c7097f12fd1d64e",
  "patch_info": {
    "commit_hash": "fc0a80798576f80ca10b3f6c9c7097f12fd1d64e",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/fc0a80798576f80ca10b3f6c9c7097f12fd1d64e",
    "files": [
      "drivers/media/video/v4l2-ioctl.c"
    ],
    "message": "[media] v4l: Share code between video_usercopy and video_ioctl2\n\nThe two functions are mostly identical. They handle the copy_from_user\nand copy_to_user operations related with V4L2 ioctls and call the real\nioctl handler.\n\nCreate a __video_usercopy function that implements the core of\nvideo_usercopy and video_ioctl2, and call that function from both.\n\nSigned-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>\nAcked-by: Hans Verkuil <hverkuil@xs4all.nl>\nSigned-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>",
    "before_after_code_files": [
      "drivers/media/video/v4l2-ioctl.c||drivers/media/video/v4l2-ioctl.c"
    ]
  },
  "patch_diff": {
    "drivers/media/video/v4l2-ioctl.c||drivers/media/video/v4l2-ioctl.c": [
      "File: drivers/media/video/v4l2-ioctl.c -> drivers/media/video/v4l2-ioctl.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "294: }",
      "295: EXPORT_SYMBOL(v4l_printk_ioctl);",
      "392: static void dbgbuf(unsigned int cmd, struct video_device *vfd,",
      "393:      struct v4l2_buffer *p)",
      "394: {",
      "",
      "[Removed Lines]",
      "301: long",
      "302: video_usercopy(struct file *file, unsigned int cmd, unsigned long arg,",
      "303:   v4l2_kioctl func)",
      "304: {",
      "305:  char sbuf[128];",
      "306:  void    *mbuf = NULL;",
      "307:  void *parg = NULL;",
      "308:  long err  = -EINVAL;",
      "309:  int     is_ext_ctrl;",
      "310:  size_t  ctrls_size = 0;",
      "311:  void __user *user_ptr = NULL;",
      "313:  is_ext_ctrl = (cmd == VIDIOC_S_EXT_CTRLS || cmd == VIDIOC_G_EXT_CTRLS ||",
      "314:          cmd == VIDIOC_TRY_EXT_CTRLS);",
      "317:  switch (_IOC_DIR(cmd)) {",
      "318:  case _IOC_NONE:",
      "319:   parg = NULL;",
      "320:   break;",
      "321:  case _IOC_READ:",
      "322:  case _IOC_WRITE:",
      "323:  case (_IOC_WRITE | _IOC_READ):",
      "324:   if (_IOC_SIZE(cmd) <= sizeof(sbuf)) {",
      "325:    parg = sbuf;",
      "326:   } else {",
      "328:    mbuf = kmalloc(_IOC_SIZE(cmd), GFP_KERNEL);",
      "329:    if (NULL == mbuf)",
      "330:     return -ENOMEM;",
      "331:    parg = mbuf;",
      "332:   }",
      "334:   err = -EFAULT;",
      "335:   if (_IOC_DIR(cmd) & _IOC_WRITE)",
      "336:    if (copy_from_user(parg, (void __user *)arg, _IOC_SIZE(cmd)))",
      "337:     goto out;",
      "338:   break;",
      "339:  }",
      "340:  if (is_ext_ctrl) {",
      "341:   struct v4l2_ext_controls *p = parg;",
      "345:   p->error_idx = p->count;",
      "346:   user_ptr = (void __user *)p->controls;",
      "347:   if (p->count) {",
      "348:    ctrls_size = sizeof(struct v4l2_ext_control) * p->count;",
      "350:    mbuf = kmalloc(ctrls_size, GFP_KERNEL);",
      "351:    err = -ENOMEM;",
      "352:    if (NULL == mbuf)",
      "353:     goto out_ext_ctrl;",
      "354:    err = -EFAULT;",
      "355:    if (copy_from_user(mbuf, user_ptr, ctrls_size))",
      "356:     goto out_ext_ctrl;",
      "357:    p->controls = mbuf;",
      "358:   }",
      "359:  }",
      "362:  err = func(file, cmd, parg);",
      "363:  if (err == -ENOIOCTLCMD)",
      "364:   err = -EINVAL;",
      "365:  if (is_ext_ctrl) {",
      "366:   struct v4l2_ext_controls *p = parg;",
      "368:   p->controls = (void *)user_ptr;",
      "369:   if (p->count && err == 0 && copy_to_user(user_ptr, mbuf, ctrls_size))",
      "370:    err = -EFAULT;",
      "371:   goto out_ext_ctrl;",
      "372:  }",
      "373:  if (err < 0)",
      "374:   goto out;",
      "376: out_ext_ctrl:",
      "378:  switch (_IOC_DIR(cmd)) {",
      "379:  case _IOC_READ:",
      "380:  case (_IOC_WRITE | _IOC_READ):",
      "381:   if (copy_to_user((void __user *)arg, parg, _IOC_SIZE(cmd)))",
      "382:    err = -EFAULT;",
      "383:   break;",
      "384:  }",
      "386: out:",
      "387:  kfree(mbuf);",
      "388:  return err;",
      "389: }",
      "390: EXPORT_SYMBOL(video_usercopy);",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "2332:  return ret;",
      "2333: }",
      "2337: {",
      "2338:  char sbuf[128];",
      "2339:  void    *mbuf = NULL;",
      "",
      "[Removed Lines]",
      "2335: long video_ioctl2(struct file *file,",
      "2336:         unsigned int cmd, unsigned long arg)",
      "",
      "[Added Lines]",
      "2240: long",
      "2241: video_usercopy(struct file *file, unsigned int cmd, unsigned long arg,",
      "2242:         v4l2_kioctl func)",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "2395:  }",
      "2399:  if (err == -ENOIOCTLCMD)",
      "2400:   err = -EINVAL;",
      "",
      "[Removed Lines]",
      "2398:  err = __video_do_ioctl(file, cmd, parg);",
      "",
      "[Added Lines]",
      "2304:  err = func(file, cmd, parg);",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "2422:  kfree(mbuf);",
      "2423:  return err;",
      "2424: }",
      "2425: EXPORT_SYMBOL(video_ioctl2);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2331: EXPORT_SYMBOL(video_usercopy);",
      "2333: long video_ioctl2(struct file *file,",
      "2334:         unsigned int cmd, unsigned long arg)",
      "2335: {",
      "2336:  return video_usercopy(file, cmd, arg, __video_do_ioctl);",
      "2337: }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "d14e6d76ebf740fd0d0bd296933993a555938896",
      "candidate_info": {
        "commit_hash": "d14e6d76ebf740fd0d0bd296933993a555938896",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/d14e6d76ebf740fd0d0bd296933993a555938896",
        "files": [
          "drivers/media/video/v4l2-ioctl.c",
          "include/media/v4l2-ioctl.h"
        ],
        "message": "[media] v4l: Add multi-planar ioctl handling code\n\nAdd multi-planar API core ioctl handling and conversion functions.\n\n[mchehab@redhat.com: CondingStyle fixup]\nSigned-off-by: Pawel Osciak <p.osciak@samsung.com>\nSigned-off-by: Kyungmin Park <kyungmin.park@samsung.com>\nReviewed-by: Marek Szyprowski <m.szyprowski@samsung.com>\nSigned-off-by: Marek Szyprowski <m.szyprowski@samsung.com>\nReviewed-by: Hans Verkuil <hverkuil@xs4all.nl>\nSigned-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>",
        "before_after_code_files": [
          "drivers/medivideo/v4l2-ioctl.c||drivers/media/video/v4l2-ioctl.c",
          "include/mediv4l2-ioctl.h||include/media/v4l2-ioctl.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/medivideo/v4l2-ioctl.c||drivers/media/video/v4l2-ioctl.c": [
          "File: drivers/medivideo/v4l2-ioctl.c -> drivers/media/video/v4l2-ioctl.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "431:  struct v4l2_plane *plane;",
          "432:  int i;",
          "435:   \"flags=0x%08d, field=%0d, sequence=%d, memory=%s\\n\",",
          "442:    p->flags, p->field, p->sequence,",
          "443:    prt_names(p->memory, v4l2_memory_names));",
          "445:  if (V4L2_TYPE_IS_MULTIPLANAR(p->type) && p->m.planes) {",
          "446:   for (i = 0; i < p->length; ++i) {",
          "447:    plane = &p->m.planes[i];",
          "448:    dbgarg2(\"plane %d: bytesused=%d, data_offset=0x%08x \"",
          "449:     \"offset/userptr=0x%08lx, length=%d\\n\",",
          "450:     i, plane->bytesused, plane->data_offset,",
          "451:     plane->m.userptr, plane->length);",
          "452:   }",
          "453:  } else {",
          "454:   dbgarg2(\"bytesused=%d, offset/userptr=0x%08lx, length=%d\\n\",",
          "455:    p->bytesused, p->m.userptr, p->length);",
          "456:  }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "485: static inline void v4l_print_pix_fmt_mplane(struct video_device *vfd,",
          "486:          struct v4l2_pix_format_mplane *fmt)",
          "487: {",
          "488:  int i;",
          "490:  dbgarg2(\"width=%d, height=%d, format=%c%c%c%c, field=%s, \"",
          "491:   \"colorspace=%d, num_planes=%d\\n\",",
          "492:   fmt->width, fmt->height,",
          "493:   (fmt->pixelformat & 0xff),",
          "494:   (fmt->pixelformat >>  8) & 0xff,",
          "495:   (fmt->pixelformat >> 16) & 0xff,",
          "496:   (fmt->pixelformat >> 24) & 0xff,",
          "497:   prt_names(fmt->field, v4l2_field_names),",
          "498:   fmt->colorspace, fmt->num_planes);",
          "500:  for (i = 0; i < fmt->num_planes; ++i)",
          "501:   dbgarg2(\"plane %d: bytesperline=%d sizeimage=%d\\n\", i,",
          "502:    fmt->plane_fmt[i].bytesperline,",
          "503:    fmt->plane_fmt[i].sizeimage);",
          "504: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "559:   if (ops->vidioc_g_fmt_vid_cap ||",
          "560:     ops->vidioc_g_fmt_vid_cap_mplane)",
          "561:    return 0;",
          "562:   break;",
          "563:  case V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:",
          "564:   if (ops->vidioc_g_fmt_vid_cap_mplane)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "572:   if (ops->vidioc_g_fmt_vid_out ||",
          "573:     ops->vidioc_g_fmt_vid_out_mplane)",
          "574:    return 0;",
          "575:   break;",
          "576:  case V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE:",
          "577:   if (ops->vidioc_g_fmt_vid_out_mplane)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "612: static int fmt_sp_to_mp(const struct v4l2_format *f_sp,",
          "613:    struct v4l2_format *f_mp)",
          "614: {",
          "615:  struct v4l2_pix_format_mplane *pix_mp = &f_mp->fmt.pix_mp;",
          "616:  const struct v4l2_pix_format *pix = &f_sp->fmt.pix;",
          "618:  if (f_sp->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)",
          "619:   f_mp->type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;",
          "620:  else if (f_sp->type == V4L2_BUF_TYPE_VIDEO_OUTPUT)",
          "621:   f_mp->type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;",
          "622:  else",
          "623:   return -EINVAL;",
          "625:  pix_mp->width = pix->width;",
          "626:  pix_mp->height = pix->height;",
          "627:  pix_mp->pixelformat = pix->pixelformat;",
          "628:  pix_mp->field = pix->field;",
          "629:  pix_mp->colorspace = pix->colorspace;",
          "630:  pix_mp->num_planes = 1;",
          "631:  pix_mp->plane_fmt[0].sizeimage = pix->sizeimage;",
          "632:  pix_mp->plane_fmt[0].bytesperline = pix->bytesperline;",
          "634:  return 0;",
          "635: }",
          "641: static int fmt_mp_to_sp(const struct v4l2_format *f_mp,",
          "642:    struct v4l2_format *f_sp)",
          "643: {",
          "644:  const struct v4l2_pix_format_mplane *pix_mp = &f_mp->fmt.pix_mp;",
          "645:  struct v4l2_pix_format *pix = &f_sp->fmt.pix;",
          "647:  if (f_mp->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)",
          "648:   f_sp->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;",
          "649:  else if (f_mp->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)",
          "650:   f_sp->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;",
          "651:  else",
          "652:   return -EINVAL;",
          "654:  pix->width = pix_mp->width;",
          "655:  pix->height = pix_mp->height;",
          "656:  pix->pixelformat = pix_mp->pixelformat;",
          "657:  pix->field = pix_mp->field;",
          "658:  pix->colorspace = pix_mp->colorspace;",
          "659:  pix->sizeimage = pix_mp->plane_fmt[0].sizeimage;",
          "660:  pix->bytesperline = pix_mp->plane_fmt[0].bytesperline;",
          "662:  return 0;",
          "663: }",
          "671:  struct v4l2_format f_copy;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "740:   case V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:",
          "741:    if (ops->vidioc_enum_fmt_vid_cap_mplane)",
          "742:     ret = ops->vidioc_enum_fmt_vid_cap_mplane(file,",
          "743:          fh, f);",
          "744:    break;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "754:   case V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE:",
          "755:    if (ops->vidioc_enum_fmt_vid_out_mplane)",
          "756:     ret = ops->vidioc_enum_fmt_vid_out_mplane(file,",
          "757:          fh, f);",
          "758:    break;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "787:    if (ops->vidioc_g_fmt_vid_cap) {",
          "789:    } else if (ops->vidioc_g_fmt_vid_cap_mplane) {",
          "790:     if (fmt_sp_to_mp(f, &f_copy))",
          "791:      break;",
          "792:     ret = ops->vidioc_g_fmt_vid_cap_mplane(file, fh,",
          "793:                &f_copy);",
          "794:     if (ret)",
          "795:      break;",
          "799:     if (f_copy.fmt.pix_mp.num_planes > 1) {",
          "800:      ret = -EBUSY;",
          "801:      break;",
          "802:     }",
          "804:     ret = fmt_mp_to_sp(&f_copy, f);",
          "805:    }",
          "809:   case V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:",
          "810:    if (ops->vidioc_g_fmt_vid_cap_mplane) {",
          "811:     ret = ops->vidioc_g_fmt_vid_cap_mplane(file,",
          "812:          fh, f);",
          "813:    } else if (ops->vidioc_g_fmt_vid_cap) {",
          "814:     if (fmt_mp_to_sp(f, &f_copy))",
          "815:      break;",
          "816:     ret = ops->vidioc_g_fmt_vid_cap(file,",
          "817:         fh, &f_copy);",
          "818:     if (ret)",
          "819:      break;",
          "821:     ret = fmt_sp_to_mp(&f_copy, f);",
          "822:    }",
          "823:    if (!ret)",
          "824:     v4l_print_pix_fmt_mplane(vfd, &f->fmt.pix_mp);",
          "825:    break;",
          "832:    if (ops->vidioc_g_fmt_vid_out) {",
          "834:    } else if (ops->vidioc_g_fmt_vid_out_mplane) {",
          "835:     if (fmt_sp_to_mp(f, &f_copy))",
          "836:      break;",
          "837:     ret = ops->vidioc_g_fmt_vid_out_mplane(file, fh,",
          "838:          &f_copy);",
          "839:     if (ret)",
          "840:      break;",
          "844:     if (f_copy.fmt.pix_mp.num_planes > 1) {",
          "845:      ret = -EBUSY;",
          "846:      break;",
          "847:     }",
          "849:     ret = fmt_mp_to_sp(&f_copy, f);",
          "850:    }",
          "854:   case V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE:",
          "855:    if (ops->vidioc_g_fmt_vid_out_mplane) {",
          "856:     ret = ops->vidioc_g_fmt_vid_out_mplane(file,",
          "857:          fh, f);",
          "858:    } else if (ops->vidioc_g_fmt_vid_out) {",
          "859:     if (fmt_mp_to_sp(f, &f_copy))",
          "860:      break;",
          "861:     ret = ops->vidioc_g_fmt_vid_out(file,",
          "862:         fh, &f_copy);",
          "863:     if (ret)",
          "864:      break;",
          "866:     ret = fmt_sp_to_mp(&f_copy, f);",
          "867:    }",
          "868:    if (!ret)",
          "869:     v4l_print_pix_fmt_mplane(vfd, &f->fmt.pix_mp);",
          "870:    break;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "914:    if (ops->vidioc_s_fmt_vid_cap) {",
          "916:    } else if (ops->vidioc_s_fmt_vid_cap_mplane) {",
          "917:     if (fmt_sp_to_mp(f, &f_copy))",
          "918:      break;",
          "919:     ret = ops->vidioc_s_fmt_vid_cap_mplane(file, fh,",
          "920:          &f_copy);",
          "921:     if (ret)",
          "922:      break;",
          "924:     if (f_copy.fmt.pix_mp.num_planes > 1) {",
          "927:      ret = -EBUSY;",
          "928:      WARN_ON(1);",
          "929:      break;",
          "930:     }",
          "932:     ret = fmt_mp_to_sp(&f_copy, f);",
          "933:    }",
          "934:    break;",
          "935:   case V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:",
          "936:    CLEAR_AFTER_FIELD(f, fmt.pix_mp);",
          "937:    v4l_print_pix_fmt_mplane(vfd, &f->fmt.pix_mp);",
          "938:    if (ops->vidioc_s_fmt_vid_cap_mplane) {",
          "939:     ret = ops->vidioc_s_fmt_vid_cap_mplane(file,",
          "940:          fh, f);",
          "941:    } else if (ops->vidioc_s_fmt_vid_cap &&",
          "942:      f->fmt.pix_mp.num_planes == 1) {",
          "943:     if (fmt_mp_to_sp(f, &f_copy))",
          "944:      break;",
          "945:     ret = ops->vidioc_s_fmt_vid_cap(file,",
          "946:         fh, &f_copy);",
          "947:     if (ret)",
          "948:      break;",
          "950:     ret = fmt_sp_to_mp(&f_copy, f);",
          "951:    }",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "962:    if (ops->vidioc_s_fmt_vid_out) {",
          "964:    } else if (ops->vidioc_s_fmt_vid_out_mplane) {",
          "965:     if (fmt_sp_to_mp(f, &f_copy))",
          "966:      break;",
          "967:     ret = ops->vidioc_s_fmt_vid_out_mplane(file, fh,",
          "968:          &f_copy);",
          "969:     if (ret)",
          "970:      break;",
          "972:     if (f_copy.fmt.pix_mp.num_planes > 1) {",
          "975:      ret = -EBUSY;",
          "976:      WARN_ON(1);",
          "977:      break;",
          "978:     }",
          "980:     ret = fmt_mp_to_sp(&f_copy, f);",
          "981:    }",
          "982:    break;",
          "983:   case V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE:",
          "984:    CLEAR_AFTER_FIELD(f, fmt.pix_mp);",
          "985:    v4l_print_pix_fmt_mplane(vfd, &f->fmt.pix_mp);",
          "986:    if (ops->vidioc_s_fmt_vid_out_mplane) {",
          "987:     ret = ops->vidioc_s_fmt_vid_out_mplane(file,",
          "988:          fh, f);",
          "989:    } else if (ops->vidioc_s_fmt_vid_out &&",
          "990:      f->fmt.pix_mp.num_planes == 1) {",
          "991:     if (fmt_mp_to_sp(f, &f_copy))",
          "992:      break;",
          "993:     ret = ops->vidioc_s_fmt_vid_out(file,",
          "994:         fh, &f_copy);",
          "995:     if (ret)",
          "996:      break;",
          "998:     ret = fmt_mp_to_sp(&f_copy, f);",
          "999:    }",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1048:    if (ops->vidioc_try_fmt_vid_cap) {",
          "1050:    } else if (ops->vidioc_try_fmt_vid_cap_mplane) {",
          "1051:     if (fmt_sp_to_mp(f, &f_copy))",
          "1052:      break;",
          "1053:     ret = ops->vidioc_try_fmt_vid_cap_mplane(file,",
          "1054:         fh, &f_copy);",
          "1055:     if (ret)",
          "1056:      break;",
          "1058:     if (f_copy.fmt.pix_mp.num_planes > 1) {",
          "1061:      ret = -EBUSY;",
          "1062:      WARN_ON(1);",
          "1063:      break;",
          "1064:     }",
          "1065:     ret = fmt_mp_to_sp(&f_copy, f);",
          "1066:    }",
          "1070:   case V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:",
          "1071:    CLEAR_AFTER_FIELD(f, fmt.pix_mp);",
          "1072:    if (ops->vidioc_try_fmt_vid_cap_mplane) {",
          "1073:     ret = ops->vidioc_try_fmt_vid_cap_mplane(file,",
          "1074:           fh, f);",
          "1075:    } else if (ops->vidioc_try_fmt_vid_cap &&",
          "1076:      f->fmt.pix_mp.num_planes == 1) {",
          "1077:     if (fmt_mp_to_sp(f, &f_copy))",
          "1078:      break;",
          "1079:     ret = ops->vidioc_try_fmt_vid_cap(file,",
          "1080:           fh, &f_copy);",
          "1081:     if (ret)",
          "1082:      break;",
          "1084:     ret = fmt_sp_to_mp(&f_copy, f);",
          "1085:    }",
          "1086:    if (!ret)",
          "1087:     v4l_print_pix_fmt_mplane(vfd, &f->fmt.pix_mp);",
          "1088:    break;",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1097:    if (ops->vidioc_try_fmt_vid_out) {",
          "1099:    } else if (ops->vidioc_try_fmt_vid_out_mplane) {",
          "1100:     if (fmt_sp_to_mp(f, &f_copy))",
          "1101:      break;",
          "1102:     ret = ops->vidioc_try_fmt_vid_out_mplane(file,",
          "1103:         fh, &f_copy);",
          "1104:     if (ret)",
          "1105:      break;",
          "1107:     if (f_copy.fmt.pix_mp.num_planes > 1) {",
          "1110:      ret = -EBUSY;",
          "1111:      WARN_ON(1);",
          "1112:      break;",
          "1113:     }",
          "1114:     ret = fmt_mp_to_sp(&f_copy, f);",
          "1115:    }",
          "1119:   case V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE:",
          "1120:    CLEAR_AFTER_FIELD(f, fmt.pix_mp);",
          "1121:    if (ops->vidioc_try_fmt_vid_out_mplane) {",
          "1122:     ret = ops->vidioc_try_fmt_vid_out_mplane(file,",
          "1123:           fh, f);",
          "1124:    } else if (ops->vidioc_try_fmt_vid_out &&",
          "1125:      f->fmt.pix_mp.num_planes == 1) {",
          "1126:     if (fmt_mp_to_sp(f, &f_copy))",
          "1127:      break;",
          "1128:     ret = ops->vidioc_try_fmt_vid_out(file,",
          "1129:           fh, &f_copy);",
          "1130:     if (ret)",
          "1131:      break;",
          "1133:     ret = fmt_sp_to_mp(&f_copy, f);",
          "1134:    }",
          "1135:    if (!ret)",
          "1136:     v4l_print_pix_fmt_mplane(vfd, &f->fmt.pix_mp);",
          "1137:    break;",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2302:   CMDINSIZE(QUERYBUF,  buffer,  length);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2327: static int check_array_args(unsigned int cmd, void *parg, size_t *array_size,",
          "2328:        void * __user *user_ptr, void ***kernel_ptr)",
          "2329: {",
          "2330:  int ret = 0;",
          "2332:  switch (cmd) {",
          "2333:  case VIDIOC_QUERYBUF:",
          "2334:  case VIDIOC_QBUF:",
          "2335:  case VIDIOC_DQBUF: {",
          "2336:   struct v4l2_buffer *buf = parg;",
          "2338:   if (V4L2_TYPE_IS_MULTIPLANAR(buf->type) && buf->length > 0) {",
          "2339:    if (buf->length > VIDEO_MAX_PLANES) {",
          "2340:     ret = -EINVAL;",
          "2341:     break;",
          "2342:    }",
          "2346:    ret = 1;",
          "2347:   }",
          "2348:   break;",
          "2349:  }",
          "2351:  case VIDIOC_S_EXT_CTRLS:",
          "2352:  case VIDIOC_G_EXT_CTRLS:",
          "2353:  case VIDIOC_TRY_EXT_CTRLS: {",
          "2354:   struct v4l2_ext_controls *ctrls = parg;",
          "2356:   if (ctrls->count != 0) {",
          "2361:    ret = 1;",
          "2362:   }",
          "2363:   break;",
          "2364:  }",
          "2365:  }",
          "2367:  return ret;",
          "2368: }",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2377:  bool has_array_args;",
          "2378:  size_t  array_size = 0;",
          "2380:  void **kernel_ptr = NULL;",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2413:  err = check_array_args(cmd, parg, &array_size, &user_ptr, &kernel_ptr);",
          "2414:  if (err < 0)",
          "2415:   goto out;",
          "2416:  has_array_args = err;",
          "2418:  if (has_array_args) {",
          "2425:   mbuf = kmalloc(array_size, GFP_KERNEL);",
          "2426:   err = -ENOMEM;",
          "2427:   if (NULL == mbuf)",
          "2428:    goto out_array_args;",
          "2429:   err = -EFAULT;",
          "2430:   if (copy_from_user(mbuf, user_ptr, array_size))",
          "2431:    goto out_array_args;",
          "2440:  if (has_array_args) {",
          "2442:   if (copy_to_user(user_ptr, mbuf, array_size))",
          "2444:   goto out_array_args;",
          "2449: out_array_args:",
          "",
          "---------------"
        ],
        "include/mediv4l2-ioctl.h||include/media/v4l2-ioctl.h": [
          "File: include/mediv4l2-ioctl.h -> include/media/v4l2-ioctl.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "40:  int (*vidioc_enum_fmt_vid_cap_mplane)(struct file *file, void *fh,",
          "41:            struct v4l2_fmtdesc *f);",
          "42:  int (*vidioc_enum_fmt_vid_out_mplane)(struct file *file, void *fh,",
          "43:            struct v4l2_fmtdesc *f);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "64:  int (*vidioc_g_fmt_vid_cap_mplane)(struct file *file, void *fh,",
          "65:         struct v4l2_format *f);",
          "66:  int (*vidioc_g_fmt_vid_out_mplane)(struct file *file, void *fh,",
          "67:         struct v4l2_format *f);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "88:  int (*vidioc_s_fmt_vid_cap_mplane)(struct file *file, void *fh,",
          "89:         struct v4l2_format *f);",
          "90:  int (*vidioc_s_fmt_vid_out_mplane)(struct file *file, void *fh,",
          "91:         struct v4l2_format *f);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "112:  int (*vidioc_try_fmt_vid_cap_mplane)(struct file *file, void *fh,",
          "113:           struct v4l2_format *f);",
          "114:  int (*vidioc_try_fmt_vid_out_mplane)(struct file *file, void *fh,",
          "115:           struct v4l2_format *f);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2022-23590",
  "cve_desc": "Tensorflow is an Open Source Machine Learning Framework. A `GraphDef` from a TensorFlow `SavedModel` can be maliciously altered to cause a TensorFlow process to crash due to encountering a `StatusOr` value that is an error and forcibly extracting the value from it. We have patched the issue in multiple GitHub commits and these will be included in TensorFlow 2.8.0 and TensorFlow 2.7.1, as both are affected.",
  "repo": "tensorflow/tensorflow",
  "patch_hash": "955059813cc325dc1db5e2daa6221271406d4439",
  "patch_info": {
    "commit_hash": "955059813cc325dc1db5e2daa6221271406d4439",
    "repo": "tensorflow/tensorflow",
    "commit_url": "https://github.com/tensorflow/tensorflow/commit/955059813cc325dc1db5e2daa6221271406d4439",
    "files": [
      "tensorflow/core/graph/graph.cc"
    ],
    "message": "Check for type inference error on node construction.\n\nPiperOrigin-RevId: 409415804\nChange-Id: Ieb6e020906b96f522bf8e2fa103715ddbbdc434a",
    "before_after_code_files": [
      "tensorflow/core/graph/graph.cc||tensorflow/core/graph/graph.cc"
    ]
  },
  "patch_diff": {
    "tensorflow/core/graph/graph.cc||tensorflow/core/graph/graph.cc": [
      "File: tensorflow/core/graph/graph.cc -> tensorflow/core/graph/graph.cc",
      "--- Hunk 1 ---",
      "[Context before]",
      "561:     VLOG(3) << \"AddNode: found type constructor for \" << node_def.name();",
      "562:     const auto ctor_type =",
      "563:         full_type::SpecializeType(AttrSlice(node_def), op_reg_data->op_def);",
      "564:     const FullTypeDef ctor_typedef = ctor_type.ValueOrDie();",
      "565:     if (ctor_typedef.type_id() != TFT_UNSET) {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "564:     if (!ctor_type.ok()) {",
      "566:                                         ctor_type.status().ToString());",
      "567:       return nullptr;",
      "568:     }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "bff664b9b2d58e0739f01453f55bb37751792f1e",
      "candidate_info": {
        "commit_hash": "bff664b9b2d58e0739f01453f55bb37751792f1e",
        "repo": "tensorflow/tensorflow",
        "commit_url": "https://github.com/tensorflow/tensorflow/commit/bff664b9b2d58e0739f01453f55bb37751792f1e",
        "files": [
          "tensorflow/core/graph/graph.cc",
          "tensorflow/core/graph/node_builder_test.cc"
        ],
        "message": "Avoid local type inference upon node edits, and avoid running the type constructor if when adding a NodeDef that has type info already set. This increases the chance for stale type info during graph transformations, but avoids surprising behavior when the callers do supply a correct type. It also has better support for incremental or partial type inference. In general, it will be most robust to run the type inference pass before transforms which rely on it.\n\nPiperOrigin-RevId: 431739878",
        "before_after_code_files": [
          "tensorflow/core/graph/graph.cc||tensorflow/core/graph/graph.cc",
          "tensorflow/core/graph/node_builder_test.cc||tensorflow/core/graph/node_builder_test.cc"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "tensorflow/core/graph/graph.cc||tensorflow/core/graph/graph.cc"
          ],
          "candidate": [
            "tensorflow/core/graph/graph.cc||tensorflow/core/graph/graph.cc"
          ]
        }
      },
      "candidate_diff": {
        "tensorflow/core/graph/graph.cc||tensorflow/core/graph/graph.cc": [
          "File: tensorflow/core/graph/graph.cc -> tensorflow/core/graph/graph.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "594:                                    ? Node::NC_FUNCTION_OP",
          "595:                                    : Node::GetNodeClassForOp(node_def.op());",
          "608:   } else {",
          "610:   }",
          "612:   Node* node = AllocateNode(std::make_shared<NodeProperties>(",
          "",
          "[Removed Lines]",
          "597:   if (op_reg_data->type_ctor != nullptr) {",
          "598:     VLOG(3) << \"AddNode: found type constructor for \" << node_def.name();",
          "599:     Status s =",
          "600:         full_type::SpecializeType(AttrSlice(node_def), op_reg_data->op_def,",
          "602:     if (!s.ok()) {",
          "604:       VLOG(3) << \"AddNode: type inference failed for \" << node_def.name()",
          "605:               << \": \" << s;",
          "606:       return nullptr;",
          "607:     }",
          "609:     VLOG(3) << \"AddNode: no type constructor for \" << node_def.name();",
          "",
          "[Added Lines]",
          "597:   if (node_def.has_experimental_type()) {",
          "598:     VLOG(3) << \"AddNode: node has type set, skipping type constructor \"",
          "599:             << node_def.name();",
          "601:     if (op_reg_data->type_ctor != nullptr) {",
          "602:       VLOG(3) << \"AddNode: found type constructor for \" << node_def.name();",
          "603:       Status s =",
          "604:           full_type::SpecializeType(AttrSlice(node_def), op_reg_data->op_def,",
          "606:       if (!s.ok()) {",
          "608:         VLOG(3) << \"AddNode: type inference failed for \" << node_def.name()",
          "609:                 << \": \" << s;",
          "610:         return nullptr;",
          "611:       }",
          "612:     } else {",
          "613:       VLOG(3) << \"AddNode: no type constructor for \" << node_def.name();",
          "614:     }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "688:   edges_.push_back(e);",
          "689:   ++num_edges_;",
          "705:   return e;",
          "706: }",
          "",
          "[Removed Lines]",
          "691:   if (!e->IsControlEdge()) {",
          "692:     if (dest->in_edges_.size() >= dest->props_->input_types.size()) {",
          "701:       dest->RunForwardTypeInference();",
          "702:     }",
          "703:   }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "716:   edges_[e->id_] = nullptr;",
          "717:   RecycleEdge(e);",
          "718:   --num_edges_;",
          "724: }",
          "726: void Graph::RecycleEdge(const Edge* e) {",
          "",
          "[Removed Lines]",
          "720:   if (!e->IsControlEdge()) {",
          "722:     e->dst_->RunForwardTypeInference();",
          "723:   }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "tensorflow/core/graph/node_builder_test.cc||tensorflow/core/graph/node_builder_test.cc": [
          "File: tensorflow/core/graph/node_builder_test.cc -> tensorflow/core/graph/node_builder_test.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "148:                    .Input(input_node)",
          "149:                    .Finalize(&graph, &node));",
          "151:   ASSERT_TRUE(node->def().has_experimental_type());",
          "152:   FullTypeDef ft = node->def().experimental_type();",
          "153:   ASSERT_EQ(input_node->def().experimental_type().type_id(), TFT_PRODUCT);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "151:   node->RunForwardTypeInference();",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "162:                    .Input(input_node)",
          "163:                    .Finalize(&graph, &node));",
          "165:   ASSERT_TRUE(node->def().has_experimental_type());",
          "166:   ft = node->def().experimental_type();",
          "167:   ASSERT_EQ(input_node->def().experimental_type().type_id(), TFT_PRODUCT);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "167:   node->RunForwardTypeInference();",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "9a86e5fa6cbbd8d2bd32b0080c7d0cae1c6225aa",
      "candidate_info": {
        "commit_hash": "9a86e5fa6cbbd8d2bd32b0080c7d0cae1c6225aa",
        "repo": "tensorflow/tensorflow",
        "commit_url": "https://github.com/tensorflow/tensorflow/commit/9a86e5fa6cbbd8d2bd32b0080c7d0cae1c6225aa",
        "files": [
          "tensorflow/core/framework/BUILD",
          "tensorflow/core/framework/full_type_util.cc",
          "tensorflow/core/framework/full_type_util.h",
          "tensorflow/core/framework/full_type_util_test.cc",
          "tensorflow/core/framework/shape_inference.cc",
          "tensorflow/core/framework/types.cc",
          "tensorflow/core/framework/types.h",
          "tensorflow/core/graph/graph.cc",
          "tensorflow/core/graph/node_builder_test.cc"
        ],
        "message": "Refactor SpecializeType to add support for the template expansion in TFT_FOR_EACH and more consistent substitution of variables from node attributes.\n\nPiperOrigin-RevId: 416033602\nChange-Id: Ie7e19fafe5f2fb5f3ba37f6c320e872ad94e3405",
        "before_after_code_files": [
          "tensorflow/core/framework/full_type_util.cc||tensorflow/core/framework/full_type_util.cc",
          "tensorflow/core/framework/full_type_util.h||tensorflow/core/framework/full_type_util.h",
          "tensorflow/core/framework/full_type_util_test.cc||tensorflow/core/framework/full_type_util_test.cc",
          "tensorflow/core/framework/shape_inference.cc||tensorflow/core/framework/shape_inference.cc",
          "tensorflow/core/framework/types.cc||tensorflow/core/framework/types.cc",
          "tensorflow/core/framework/types.h||tensorflow/core/framework/types.h",
          "tensorflow/core/graph/graph.cc||tensorflow/core/graph/graph.cc",
          "tensorflow/core/graph/node_builder_test.cc||tensorflow/core/graph/node_builder_test.cc"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "tensorflow/core/graph/graph.cc||tensorflow/core/graph/graph.cc"
          ],
          "candidate": [
            "tensorflow/core/graph/graph.cc||tensorflow/core/graph/graph.cc"
          ]
        }
      },
      "candidate_diff": {
        "tensorflow/core/framework/full_type_util.cc||tensorflow/core/framework/full_type_util.cc": [
          "File: tensorflow/core/framework/full_type_util.cc -> tensorflow/core/framework/full_type_util.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "18: #include <algorithm>",
          "19: #include <string>",
          "21: #include \"tensorflow/core/framework/attr_value.pb.h\"",
          "22: #include \"tensorflow/core/framework/full_type.pb.h\"",
          "23: #include \"tensorflow/core/framework/node_def.pb.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "21: #include \"absl/container/flat_hash_map.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "124:   };",
          "125: }",
          "174:     }",
          "175:   }",
          "178: }",
          "180: const FullTypeDef& GetArgDefaultUnset(const FullTypeDef& t, int i) {",
          "",
          "[Removed Lines]",
          "127: StatusOr<FullTypeDef> SpecializeType(const AttrSlice& attrs,",
          "128:                                      const OpDef& op_def) {",
          "129:   FullTypeDef ft;",
          "130:   ft.set_type_id(TFT_PRODUCT);",
          "132:   for (int i = 0; i < op_def.output_arg_size(); i++) {",
          "133:     auto* t = ft.add_args();",
          "147:     for (int j = 0; j < t->args_size(); j++) {",
          "148:       auto* arg = t->mutable_args(j);",
          "149:       if (arg->type_id() == TFT_VAR) {",
          "150:         const auto* attr = attrs.Find(arg->s());",
          "151:         if (attr == nullptr) {",
          "152:           return Status(",
          "153:               error::INVALID_ARGUMENT,",
          "154:               absl::StrCat(\"Could not find an attribute for key \", arg->s()));",
          "155:         }",
          "156:         if (attr->value_case() == AttrValue::kList) {",
          "157:           const auto& attr_list = attr->list();",
          "158:           arg->set_type_id(TFT_PRODUCT);",
          "159:           for (int i = 0; i < attr_list.type_size(); i++) {",
          "160:             map_dtype_to_tensor(attr_list.type(i), arg->add_args());",
          "161:           }",
          "163:         } else if (attr->value_case() == AttrValue::kType) {",
          "164:           map_dtype_to_tensor(attr->type(), arg);",
          "166:         } else {",
          "167:           return Status(error::UNIMPLEMENTED,",
          "168:                         absl::StrCat(\"unknown attribute type\",",
          "169:                                      attrs.DebugString(), \" key=\", arg->s()));",
          "170:         }",
          "172:         arg->clear_s();",
          "173:       }",
          "177:   return ft;",
          "",
          "[Added Lines]",
          "128: namespace {",
          "130: inline bool ReduceVariantTensor(FullTypeDef& t) {",
          "133:   if (t.type_id() == TFT_TENSOR && t.args_size() &&",
          "134:       t.args(0).type_id() == TFT_LEGACY_VARIANT) {",
          "135:     t.Clear();",
          "136:     return true;",
          "137:   }",
          "138:   return false;",
          "139: }",
          "141: typedef absl::flat_hash_map<StringPiece, const AttrValue*> AttrMap;",
          "143: inline Status SubstituteFromAttrs(AttrMap& attrs, FullTypeDef& t);",
          "145: Status SubstituteVar(AttrMap& attrs, FullTypeDef& t) {",
          "146:   DCHECK_EQ(t.args_size(), 0);",
          "148:   StringPiece var_name = t.s();",
          "149:   if (!attrs.contains(var_name)) {",
          "150:     return Status(",
          "151:         error::INVALID_ARGUMENT,",
          "152:         absl::StrCat(\"could not find an attribute for key '\", var_name, \"'\"));",
          "153:   }",
          "154:   const AttrValue* attr = attrs.at(var_name);",
          "156:   const auto attr_type = attr->value_case();",
          "157:   if (attr_type == AttrValue::kType) {",
          "158:     map_dtype_to_tensor(attr->type(), t);",
          "159:   } else if (attr_type == AttrValue::kList) {",
          "160:     const auto& attr_list = attr->list();",
          "161:     if (attr_list.type_size() != 1) {",
          "162:       return Status(error::UNIMPLEMENTED,",
          "163:                     absl::StrCat(\"lists or other than one type element\\n\",",
          "164:                                  attr_list.DebugString(), \"\\nkey=\", var_name));",
          "165:     }",
          "166:     map_dtype_to_tensor(attr_list.type(0), t);",
          "167:   } else {",
          "168:     return Status(error::UNIMPLEMENTED,",
          "169:                   absl::StrCat(\"unsupported attribute type \",",
          "170:                                attr->DebugString(), \" for name \", var_name));",
          "171:   }",
          "172:   t.clear_s();",
          "173:   return Status::OK();",
          "174: }",
          "176: Status SubstituteForEach(AttrMap& attrs, FullTypeDef& t) {",
          "177:   DCHECK_EQ(t.args_size(), 3);",
          "179:   const auto& cont = t.args(0);",
          "180:   const auto& tmpl = t.args(1);",
          "181:   const auto& t_var = t.args(2);",
          "183:   StringPiece var_name = t_var.s();",
          "184:   if (!attrs.contains(var_name)) {",
          "185:     return Status(",
          "186:         error::INVALID_ARGUMENT,",
          "187:         absl::StrCat(\"could not find an attribute for key '\", var_name, \"'\"));",
          "188:   }",
          "189:   const AttrValue* attr = attrs.at(var_name);",
          "191:   FullTypeDef result;",
          "192:   result.set_type_id(cont.type_id());",
          "194:   const auto attr_type = attr->value_case();",
          "195:   if (attr_type == AttrValue::kType) {",
          "196:     FullTypeDef* target = result.add_args();",
          "198:     TF_RETURN_WITH_CONTEXT_IF_ERROR(",
          "199:         SubstituteFromAttrs(attrs, *target), \"while substituting '\", var_name,",
          "200:         \"' from\\n\", attr->DebugString(), \"\\ninto \", target->DebugString());",
          "202:   } else if (attr_type == AttrValue::kList) {",
          "203:     const auto& attr_list = attr->list();",
          "204:     int tsize = attr_list.type_size();",
          "205:     if (tsize == 0) {",
          "206:       return Status(error::UNIMPLEMENTED,",
          "207:                     absl::StrCat(\"unsupported list attribute type\\n\",",
          "208:                                  attr_list.DebugString(), \"\\nkey=\", var_name));",
          "210:     AttrValue replacement;",
          "211:     attrs[var_name] = &replacement;",
          "212:     for (int i = 0; i < tsize; i++) {",
          "213:       replacement.set_type(attr_list.type(i));",
          "214:       FullTypeDef* target = result.add_args();",
          "216:       TF_RETURN_WITH_CONTEXT_IF_ERROR(SubstituteFromAttrs(attrs, *target),",
          "217:                                       \"while substituting '\", var_name,",
          "218:                                       \"' from\\n\", attr->DebugString(), \"\\n[\", i,",
          "219:                                       \"] into\\n\", target->DebugString());",
          "220:     }",
          "223:     attrs[var_name] = attr;",
          "225:   } else {",
          "226:     return Status(error::UNIMPLEMENTED,",
          "227:                   absl::StrCat(\"unsupported attribute type\\n\",",
          "228:                                attr->DebugString(), \"\\nfor name \", var_name));",
          "229:   }",
          "230:   t = result;",
          "231:   return Status::OK();",
          "232: }",
          "234: Status SubstituteGeneric(AttrMap& attrs, FullTypeDef& t) {",
          "235:   int nargs = t.args_size();",
          "236:   for (int j = 0; j < nargs; j++) {",
          "237:     TF_RETURN_WITH_CONTEXT_IF_ERROR(",
          "238:         SubstituteFromAttrs(attrs, *(t.mutable_args(j))),",
          "239:         \"while substituting arg \", j, \": \", t.args(j).DebugString());",
          "240:   }",
          "241:   return Status::OK();",
          "242: }",
          "244: inline Status SubstituteFromAttrs(AttrMap& attrs, FullTypeDef& t) {",
          "255:   switch (t.type_id()) {",
          "256:     case TFT_VAR:",
          "257:       return SubstituteVar(attrs, t);",
          "259:     case TFT_FOR_EACH:",
          "260:       return SubstituteForEach(attrs, t);",
          "262:     default:",
          "263:       return SubstituteGeneric(attrs, t);",
          "264:   }",
          "265:   return Status::OK();",
          "266: }",
          "268: }  // namespace",
          "270: Status SpecializeType(const AttrSlice& attrs, const OpDef& op_def,",
          "271:                       FullTypeDef& target) {",
          "272:   target.set_type_id(TFT_PRODUCT);",
          "274:   AttrMap map;",
          "275:   for (const auto& attr : attrs) {",
          "276:     map.emplace(attr.first, &attr.second);",
          "277:   }",
          "279:   int nargs = op_def.output_arg_size();",
          "280:   for (int i = 0; i < nargs; i++) {",
          "281:     auto& t = *(target.add_args());",
          "282:     t = op_def.output_arg(i).experimental_full_type();",
          "283:     TF_RETURN_WITH_CONTEXT_IF_ERROR(",
          "284:         SubstituteFromAttrs(map, t), \"while expanding vars of\\n\",",
          "285:         t.DebugString(), \"\\nfrom\\n\", attrs.SummarizeNode());",
          "286:     ReduceVariantTensor(t);",
          "289:   return Status::OK();",
          "",
          "---------------"
        ],
        "tensorflow/core/framework/full_type_util.h||tensorflow/core/framework/full_type_util.h": [
          "File: tensorflow/core/framework/full_type_util.h -> tensorflow/core/framework/full_type_util.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "73: const FullTypeDef& GetArgDefaultUnset(const FullTypeDef& t, int i);",
          "74: const FullTypeDef& GetArgDefaultAny(const FullTypeDef& t, int i);",
          "",
          "[Removed Lines]",
          "70: StatusOr<FullTypeDef> SpecializeType(const AttrSlice& attrs,",
          "71:                                      const OpDef& op_def);",
          "",
          "[Added Lines]",
          "70: Status SpecializeType(const AttrSlice& attrs, const OpDef& op_def,",
          "71:                       FullTypeDef& target);",
          "",
          "---------------"
        ],
        "tensorflow/core/framework/full_type_util_test.cc||tensorflow/core/framework/full_type_util_test.cc": [
          "File: tensorflow/core/framework/full_type_util_test.cc -> tensorflow/core/framework/full_type_util_test.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "134:   EXPECT_EQ(t.args(0).args(2).s(), \"T\");",
          "135: }",
          "137: TEST(GetArgDefaults, DefaultUnsetFromNoArgs) {",
          "138:   FullTypeDef t;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "137: TEST(SpecializeType, Fixed) {",
          "138:   OpDef op;",
          "139:   FullTypeDef* t = op.add_output_arg()->mutable_experimental_full_type();",
          "140:   t->set_type_id(TFT_ARRAY);",
          "141:   t->add_args()->set_type_id(TFT_TENSOR);",
          "142:   t->mutable_args(0)->add_args()->set_type_id(TFT_INT32);",
          "143:   t->add_args()->set_type_id(TFT_DATASET);",
          "144:   t->mutable_args(1)->add_args()->set_type_id(TFT_FLOAT);",
          "146:   AttrSlice empty;",
          "148:   FullTypeDef ft;",
          "149:   TF_ASSERT_OK(SpecializeType(empty, op, ft));",
          "151:   EXPECT_EQ(ft.type_id(), TFT_PRODUCT);",
          "152:   EXPECT_EQ(ft.args_size(), 1);",
          "154:   const FullTypeDef& t_actual = ft.args(0);",
          "155:   EXPECT_EQ(t_actual.type_id(), TFT_ARRAY);",
          "156:   EXPECT_EQ(t_actual.args_size(), 2);",
          "157:   EXPECT_EQ(t_actual.args(0).type_id(), TFT_TENSOR);",
          "158:   EXPECT_EQ(t_actual.args(0).args_size(), 1);",
          "159:   EXPECT_EQ(t_actual.args(0).args(0).type_id(), TFT_INT32);",
          "160:   EXPECT_EQ(t_actual.args(0).args(0).args_size(), 0);",
          "161:   EXPECT_EQ(t_actual.args(1).type_id(), TFT_DATASET);",
          "162:   EXPECT_EQ(t_actual.args(1).args_size(), 1);",
          "163:   EXPECT_EQ(t_actual.args(1).args(0).type_id(), TFT_FLOAT);",
          "164:   EXPECT_EQ(t_actual.args(1).args(0).args_size(), 0);",
          "165: }",
          "167: TEST(SpecializeType, VarExpandsFromSingleAttribute) {",
          "168:   OpDef op;",
          "169:   FullTypeDef* t = op.add_output_arg()->mutable_experimental_full_type();",
          "170:   t->set_type_id(TFT_ARRAY);",
          "171:   t->add_args()->set_type_id(TFT_TENSOR);",
          "172:   t->mutable_args(0)->add_args()->set_type_id(TFT_VAR);",
          "173:   t->mutable_args(0)->mutable_args(0)->set_s(\"T\");",
          "175:   AttrValue attr;",
          "176:   attr.set_type(DT_INT32);",
          "177:   NodeDef ndef;",
          "178:   (*ndef.mutable_attr())[\"T\"] = attr;",
          "180:   AttrSlice attrs(ndef);",
          "182:   FullTypeDef ft;",
          "183:   TF_ASSERT_OK(SpecializeType(attrs, op, ft));",
          "185:   EXPECT_EQ(ft.type_id(), TFT_PRODUCT);",
          "186:   EXPECT_EQ(ft.args_size(), 1);",
          "188:   const FullTypeDef& t_actual = ft.args(0);",
          "189:   EXPECT_EQ(t_actual.type_id(), TFT_ARRAY);",
          "190:   EXPECT_EQ(t_actual.args_size(), 1);",
          "191:   EXPECT_EQ(t_actual.args(0).type_id(), TFT_TENSOR);",
          "192:   EXPECT_EQ(t_actual.args(0).args_size(), 1);",
          "193:   EXPECT_EQ(t_actual.args(0).args(0).type_id(), TFT_INT32);",
          "194:   EXPECT_EQ(t_actual.args(0).args(0).args_size(), 0);",
          "195: }",
          "197: TEST(SpecializeType, VarExpandsFromSingleElementTypeListAttribute) {",
          "198:   OpDef op;",
          "199:   FullTypeDef* t = op.add_output_arg()->mutable_experimental_full_type();",
          "200:   t->set_type_id(TFT_ARRAY);",
          "201:   t->add_args()->set_type_id(TFT_TENSOR);",
          "202:   t->mutable_args(0)->add_args()->set_type_id(TFT_VAR);",
          "203:   t->mutable_args(0)->mutable_args(0)->set_s(\"T\");",
          "205:   AttrValue attr;",
          "206:   attr.mutable_list()->add_type(DT_INT32);",
          "207:   NodeDef ndef;",
          "208:   (*ndef.mutable_attr())[\"T\"] = attr;",
          "210:   AttrSlice attrs(ndef);",
          "212:   FullTypeDef ft;",
          "213:   TF_ASSERT_OK(SpecializeType(attrs, op, ft));",
          "215:   EXPECT_EQ(ft.type_id(), TFT_PRODUCT);",
          "216:   EXPECT_EQ(ft.args_size(), 1);",
          "218:   const FullTypeDef& t_actual = ft.args(0);",
          "219:   EXPECT_EQ(t_actual.type_id(), TFT_ARRAY);",
          "220:   EXPECT_EQ(t_actual.args_size(), 1);",
          "221:   EXPECT_EQ(t_actual.args(0).type_id(), TFT_TENSOR);",
          "222:   EXPECT_EQ(t_actual.args(0).args_size(), 1);",
          "223:   EXPECT_EQ(t_actual.args(0).args(0).type_id(), TFT_INT32);",
          "224:   EXPECT_EQ(t_actual.args(0).args(0).args_size(), 0);",
          "225: }",
          "227: TEST(SpecializeType, VarRejectsMultipleElementTypeListAttribute) {",
          "228:   OpDef op;",
          "229:   FullTypeDef* t = op.add_output_arg()->mutable_experimental_full_type();",
          "230:   t->set_type_id(TFT_ARRAY);",
          "231:   t->add_args()->set_type_id(TFT_TENSOR);",
          "232:   t->mutable_args(0)->add_args()->set_type_id(TFT_VAR);",
          "233:   t->mutable_args(0)->mutable_args(0)->set_s(\"T\");",
          "235:   AttrValue attr;",
          "236:   attr.mutable_list()->add_type(DT_INT32);",
          "237:   attr.mutable_list()->add_type(DT_FLOAT);",
          "238:   NodeDef ndef;",
          "239:   (*ndef.mutable_attr())[\"T\"] = attr;",
          "241:   AttrSlice attrs(ndef);",
          "243:   FullTypeDef ft;",
          "244:   EXPECT_FALSE(SpecializeType(attrs, op, ft).ok());",
          "245: }",
          "247: TEST(SpecializeType, VarRejectsEmptyTypeListAttribute) {",
          "248:   OpDef op;",
          "249:   FullTypeDef* t = op.add_output_arg()->mutable_experimental_full_type();",
          "250:   t->set_type_id(TFT_ARRAY);",
          "251:   t->add_args()->set_type_id(TFT_TENSOR);",
          "252:   t->mutable_args(0)->add_args()->set_type_id(TFT_VAR);",
          "253:   t->mutable_args(0)->mutable_args(0)->set_s(\"T\");",
          "255:   AttrValue attr;",
          "256:   attr.mutable_list();",
          "257:   NodeDef ndef;",
          "258:   (*ndef.mutable_attr())[\"T\"] = attr;",
          "260:   AttrSlice attrs(ndef);",
          "262:   FullTypeDef ft;",
          "263:   EXPECT_FALSE(SpecializeType(attrs, op, ft).ok());",
          "264: }",
          "266: TEST(SpecializeType, ForEachExpandsFromSingleAttribute) {",
          "267:   OpDef op;",
          "268:   FullTypeDef* t = op.add_output_arg()->mutable_experimental_full_type();",
          "269:   t->set_type_id(TFT_FOR_EACH);",
          "270:   t->add_args()->set_type_id(TFT_PRODUCT);",
          "271:   t->add_args()->set_type_id(TFT_TENSOR);",
          "272:   t->mutable_args(1)->add_args()->set_type_id(TFT_VAR);",
          "273:   t->mutable_args(1)->mutable_args(0)->set_s(\"T\");",
          "274:   t->add_args()->set_type_id(TFT_VAR);",
          "275:   t->mutable_args(2)->set_s(\"T\");",
          "277:   AttrValue attr;",
          "278:   attr.set_type(DT_INT32);",
          "279:   NodeDef ndef;",
          "280:   (*ndef.mutable_attr())[\"T\"] = attr;",
          "282:   AttrSlice attrs(ndef);",
          "284:   FullTypeDef ft;",
          "285:   TF_ASSERT_OK(SpecializeType(attrs, op, ft));",
          "287:   EXPECT_EQ(ft.type_id(), TFT_PRODUCT);",
          "288:   EXPECT_EQ(ft.args_size(), 1);",
          "290:   const FullTypeDef& t_actual = ft.args(0);",
          "291:   EXPECT_EQ(t_actual.type_id(), TFT_PRODUCT);",
          "292:   EXPECT_EQ(t_actual.args_size(), 1);",
          "293:   EXPECT_EQ(t_actual.args(0).type_id(), TFT_TENSOR);",
          "294:   EXPECT_EQ(t_actual.args(0).args_size(), 1);",
          "295:   EXPECT_EQ(t_actual.args(0).args(0).type_id(), TFT_INT32);",
          "296:   EXPECT_EQ(t_actual.args(0).args(0).args_size(), 0);",
          "297: }",
          "299: TEST(SpecializeType, ForEachExpandsFromListAttribute) {",
          "300:   OpDef op;",
          "301:   FullTypeDef* t = op.add_output_arg()->mutable_experimental_full_type();",
          "302:   t->set_type_id(TFT_FOR_EACH);",
          "303:   t->add_args()->set_type_id(TFT_PRODUCT);",
          "304:   t->add_args()->set_type_id(TFT_TENSOR);",
          "305:   t->mutable_args(1)->add_args()->set_type_id(TFT_VAR);",
          "306:   t->mutable_args(1)->mutable_args(0)->set_s(\"T\");",
          "307:   t->add_args()->set_type_id(TFT_VAR);",
          "308:   t->mutable_args(2)->set_s(\"T\");",
          "310:   AttrValue attr;",
          "311:   attr.mutable_list()->add_type(DT_INT32);",
          "312:   attr.mutable_list()->add_type(DT_FLOAT);",
          "313:   NodeDef ndef;",
          "314:   (*ndef.mutable_attr())[\"T\"] = attr;",
          "316:   AttrSlice attrs(ndef);",
          "318:   FullTypeDef ft;",
          "319:   TF_ASSERT_OK(SpecializeType(attrs, op, ft));",
          "321:   EXPECT_EQ(ft.type_id(), TFT_PRODUCT);",
          "322:   EXPECT_EQ(ft.args_size(), 1);",
          "324:   const FullTypeDef& t_actual = ft.args(0);",
          "325:   EXPECT_EQ(t_actual.type_id(), TFT_PRODUCT);",
          "326:   EXPECT_EQ(t_actual.args_size(), 2);",
          "327:   EXPECT_EQ(t_actual.args(0).type_id(), TFT_TENSOR);",
          "328:   EXPECT_EQ(t_actual.args(0).args_size(), 1);",
          "329:   EXPECT_EQ(t_actual.args(0).args(0).type_id(), TFT_INT32);",
          "330:   EXPECT_EQ(t_actual.args(0).args(0).args_size(), 0);",
          "331:   EXPECT_EQ(t_actual.args(1).type_id(), TFT_TENSOR);",
          "332:   EXPECT_EQ(t_actual.args(1).args_size(), 1);",
          "333:   EXPECT_EQ(t_actual.args(1).args(0).type_id(), TFT_FLOAT);",
          "334:   EXPECT_EQ(t_actual.args(1).args(0).args_size(), 0);",
          "335: }",
          "337: TEST(SpecializeType, ForEachDistributesNestedVar) {",
          "338:   OpDef op;",
          "339:   FullTypeDef* t = op.add_output_arg()->mutable_experimental_full_type();",
          "340:   t->set_type_id(TFT_FOR_EACH);",
          "341:   t->add_args()->set_type_id(TFT_PRODUCT);",
          "342:   t->add_args()->set_type_id(TFT_TENSOR);",
          "343:   t->mutable_args(1)->add_args()->set_type_id(TFT_VAR);",
          "344:   t->mutable_args(1)->mutable_args(0)->set_s(\"ForEachTarget\");",
          "345:   t->mutable_args(1)->add_args()->set_type_id(TFT_VAR);",
          "346:   t->mutable_args(1)->mutable_args(1)->set_s(\"GlobalVar\");",
          "347:   t->add_args()->set_type_id(TFT_VAR);",
          "348:   t->mutable_args(2)->set_s(\"ForEachTarget\");",
          "350:   NodeDef ndef;",
          "351:   AttrValue attr;",
          "353:   attr.mutable_list()->add_type(DT_INT32);",
          "354:   attr.mutable_list()->add_type(DT_INT64);",
          "355:   (*ndef.mutable_attr())[\"ForEachTarget\"] = attr;",
          "357:   attr.set_type(DT_FLOAT);",
          "358:   (*ndef.mutable_attr())[\"GlobalVar\"] = attr;",
          "360:   AttrSlice attrs(ndef);",
          "362:   FullTypeDef ft;",
          "363:   TF_ASSERT_OK(SpecializeType(attrs, op, ft));",
          "365:   EXPECT_EQ(ft.type_id(), TFT_PRODUCT);",
          "366:   EXPECT_EQ(ft.args_size(), 1);",
          "368:   const FullTypeDef& t_actual = ft.args(0);",
          "369:   EXPECT_EQ(t_actual.type_id(), TFT_PRODUCT);",
          "370:   EXPECT_EQ(t_actual.args_size(), 2);",
          "371:   EXPECT_EQ(t_actual.args(0).type_id(), TFT_TENSOR);",
          "372:   EXPECT_EQ(t_actual.args(0).args_size(), 2);",
          "373:   EXPECT_EQ(t_actual.args(0).args(0).type_id(), TFT_INT32);",
          "374:   EXPECT_EQ(t_actual.args(0).args(0).args_size(), 0);",
          "375:   EXPECT_EQ(t_actual.args(0).args(1).type_id(), TFT_FLOAT);",
          "376:   EXPECT_EQ(t_actual.args(0).args(1).args_size(), 0);",
          "377:   EXPECT_EQ(t_actual.args(1).type_id(), TFT_TENSOR);",
          "378:   EXPECT_EQ(t_actual.args(1).args_size(), 2);",
          "379:   EXPECT_EQ(t_actual.args(1).args(0).type_id(), TFT_INT64);",
          "380:   EXPECT_EQ(t_actual.args(1).args(0).args_size(), 0);",
          "381:   EXPECT_EQ(t_actual.args(1).args(1).type_id(), TFT_FLOAT);",
          "382:   EXPECT_EQ(t_actual.args(1).args(1).args_size(), 0);",
          "383: }",
          "385: TEST(SpecializeType, ForEachDistributesNestedForEach) {",
          "386:   OpDef op;",
          "387:   FullTypeDef* t = op.add_output_arg()->mutable_experimental_full_type();",
          "388:   t->set_type_id(TFT_FOR_EACH);",
          "389:   t->add_args()->set_type_id(TFT_PRODUCT);",
          "391:   FullTypeDef* inner = t->add_args();",
          "392:   inner->set_type_id(TFT_FOR_EACH);",
          "393:   inner->add_args()->set_type_id(TFT_PRODUCT);",
          "394:   inner->add_args()->set_type_id(TFT_ARRAY);",
          "395:   inner->mutable_args(1)->add_args()->set_type_id(TFT_VAR);",
          "396:   inner->mutable_args(1)->mutable_args(0)->set_s(\"InnerForEach\");",
          "397:   inner->mutable_args(1)->add_args()->set_type_id(TFT_VAR);",
          "398:   inner->mutable_args(1)->mutable_args(1)->set_s(\"OuterForEach\");",
          "399:   inner->add_args()->set_type_id(TFT_VAR);",
          "400:   inner->mutable_args(2)->set_s(\"InnerForEach\");",
          "402:   t->add_args()->set_type_id(TFT_VAR);",
          "403:   t->mutable_args(2)->set_s(\"OuterForEach\");",
          "405:   NodeDef ndef;",
          "406:   AttrValue attr;",
          "408:   attr.mutable_list()->add_type(DT_INT32);",
          "409:   attr.mutable_list()->add_type(DT_INT64);",
          "410:   (*ndef.mutable_attr())[\"OuterForEach\"] = attr;",
          "412:   attr.set_type(DT_FLOAT);",
          "413:   (*ndef.mutable_attr())[\"InnerForEach\"] = attr;",
          "415:   AttrSlice attrs(ndef);",
          "417:   FullTypeDef ft;",
          "418:   TF_ASSERT_OK(SpecializeType(attrs, op, ft));",
          "420:   EXPECT_EQ(ft.type_id(), TFT_PRODUCT);",
          "421:   EXPECT_EQ(ft.args_size(), 1);",
          "423:   const FullTypeDef& t_actual = ft.args(0);",
          "424:   EXPECT_EQ(t_actual.type_id(), TFT_PRODUCT);",
          "425:   EXPECT_EQ(t_actual.args_size(), 2);",
          "426:   EXPECT_EQ(t_actual.args(0).type_id(), TFT_PRODUCT);",
          "427:   EXPECT_EQ(t_actual.args(0).args_size(), 1);",
          "428:   EXPECT_EQ(t_actual.args(0).args(0).type_id(), TFT_ARRAY);",
          "429:   EXPECT_EQ(t_actual.args(0).args(0).args_size(), 2);",
          "430:   EXPECT_EQ(t_actual.args(0).args(0).args(0).type_id(), TFT_FLOAT);",
          "431:   EXPECT_EQ(t_actual.args(0).args(0).args(0).args_size(), 0);",
          "432:   EXPECT_EQ(t_actual.args(0).args(0).args(1).type_id(), TFT_INT32);",
          "433:   EXPECT_EQ(t_actual.args(0).args(0).args(1).args_size(), 0);",
          "434:   EXPECT_EQ(t_actual.args(1).type_id(), TFT_PRODUCT);",
          "435:   EXPECT_EQ(t_actual.args(1).args_size(), 1);",
          "436:   EXPECT_EQ(t_actual.args(1).args(0).type_id(), TFT_ARRAY);",
          "437:   EXPECT_EQ(t_actual.args(1).args(0).args_size(), 2);",
          "438:   EXPECT_EQ(t_actual.args(1).args(0).args(0).type_id(), TFT_FLOAT);",
          "439:   EXPECT_EQ(t_actual.args(1).args(0).args(0).args_size(), 0);",
          "440:   EXPECT_EQ(t_actual.args(1).args(0).args(1).type_id(), TFT_INT64);",
          "441:   EXPECT_EQ(t_actual.args(1).args(0).args(1).args_size(), 0);",
          "442: }",
          "444: TEST(SpecializeType, ForEachOverridesTargetOfNestedForEach) {",
          "445:   OpDef op;",
          "446:   FullTypeDef* t = op.add_output_arg()->mutable_experimental_full_type();",
          "447:   t->set_type_id(TFT_FOR_EACH);",
          "448:   t->add_args()->set_type_id(TFT_PRODUCT);",
          "450:   FullTypeDef* inner = t->add_args();",
          "451:   inner->set_type_id(TFT_FOR_EACH);",
          "452:   inner->add_args()->set_type_id(TFT_PRODUCT);",
          "453:   inner->add_args()->set_type_id(TFT_ARRAY);",
          "454:   inner->mutable_args(1)->add_args()->set_type_id(TFT_VAR);",
          "455:   inner->mutable_args(1)->mutable_args(0)->set_s(\"T\");",
          "456:   inner->add_args()->set_type_id(TFT_VAR);",
          "457:   inner->mutable_args(2)->set_s(\"T\");",
          "459:   t->add_args()->set_type_id(TFT_VAR);",
          "460:   t->mutable_args(2)->set_s(\"T\");",
          "462:   NodeDef ndef;",
          "463:   AttrValue attr;",
          "465:   attr.mutable_list()->add_type(DT_FLOAT);",
          "466:   attr.mutable_list()->add_type(DT_DOUBLE);",
          "467:   (*ndef.mutable_attr())[\"T\"] = attr;",
          "469:   AttrSlice attrs(ndef);",
          "471:   FullTypeDef ft;",
          "472:   TF_ASSERT_OK(SpecializeType(attrs, op, ft));",
          "474:   EXPECT_EQ(ft.type_id(), TFT_PRODUCT);",
          "475:   EXPECT_EQ(ft.args_size(), 1);",
          "477:   const FullTypeDef& t_actual = ft.args(0);",
          "478:   EXPECT_EQ(t_actual.type_id(), TFT_PRODUCT);",
          "479:   EXPECT_EQ(t_actual.args_size(), 2);",
          "480:   EXPECT_EQ(t_actual.args(0).type_id(), TFT_PRODUCT);",
          "481:   EXPECT_EQ(t_actual.args(0).args_size(), 1);",
          "482:   EXPECT_EQ(t_actual.args(0).args(0).type_id(), TFT_ARRAY);",
          "483:   EXPECT_EQ(t_actual.args(0).args(0).args_size(), 1);",
          "484:   EXPECT_EQ(t_actual.args(0).args(0).args(0).type_id(), TFT_FLOAT);",
          "485:   EXPECT_EQ(t_actual.args(0).args(0).args(0).args_size(), 0);",
          "486:   EXPECT_EQ(t_actual.args(1).type_id(), TFT_PRODUCT);",
          "487:   EXPECT_EQ(t_actual.args(1).args_size(), 1);",
          "488:   EXPECT_EQ(t_actual.args(1).args(0).type_id(), TFT_ARRAY);",
          "489:   EXPECT_EQ(t_actual.args(1).args(0).args_size(), 1);",
          "490:   EXPECT_EQ(t_actual.args(1).args(0).args(0).type_id(), TFT_DOUBLE);",
          "491:   EXPECT_EQ(t_actual.args(1).args(0).args(0).args_size(), 0);",
          "492: }",
          "",
          "---------------"
        ],
        "tensorflow/core/framework/shape_inference.cc||tensorflow/core/framework/shape_inference.cc": [
          "File: tensorflow/core/framework/shape_inference.cc -> tensorflow/core/framework/shape_inference.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "171:     const OpDef& op_def, const std::vector<const Tensor*>& input_tensors,",
          "172:     const std::vector<ShapeHandle>& input_tensors_as_shapes) {",
          "177:     return;",
          "178:   }",
          "181:   input_tensors_ = input_tensors;",
          "182:   input_tensors_as_shapes_ = input_tensors_as_shapes;",
          "",
          "[Removed Lines]",
          "174:   const auto ret = full_type::SpecializeType(attrs_, op_def);",
          "175:   if (!ret.status().ok()) {",
          "176:     construction_status_ = ret.status();",
          "179:   ret_types_ = ret.ValueOrDie();",
          "",
          "[Added Lines]",
          "174:   Status s = full_type::SpecializeType(attrs_, op_def, ret_types_);",
          "175:   if (!s.ok()) {",
          "176:     construction_status_ = s;",
          "",
          "---------------"
        ],
        "tensorflow/core/framework/types.cc||tensorflow/core/framework/types.cc": [
          "File: tensorflow/core/framework/types.cc -> tensorflow/core/framework/types.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "46:     {DT_HALF, TFT_HALF},",
          "47:     {DT_UINT32, TFT_UINT32},",
          "48:     {DT_UINT64, TFT_UINT64},",
          "49: });",
          "55:   const auto& mapped = DT_TO_FT->find(dtype);",
          "57:   if (mapped != DT_TO_FT->end()) {",
          "61:   }",
          "62: }",
          "",
          "[Removed Lines]",
          "51: void map_dtype_to_tensor(const DataType& dtype, FullTypeDef* t) {",
          "52:   t->set_type_id(TFT_TENSOR);",
          "56:   auto* arg = t->add_args();",
          "58:     arg->set_type_id(mapped->second);",
          "59:   } else {",
          "60:     arg->set_type_id(TFT_ANY);",
          "",
          "[Added Lines]",
          "49:     {DT_VARIANT, TFT_LEGACY_VARIANT},",
          "52: void map_dtype_to_tensor(const DataType& dtype, FullTypeDef& t) {",
          "53:   t.Clear();",
          "61:     t.set_type_id(mapped->second);",
          "",
          "---------------"
        ],
        "tensorflow/core/framework/types.h||tensorflow/core/framework/types.h": [
          "File: tensorflow/core/framework/types.h -> tensorflow/core/framework/types.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "562:   }",
          "563: };",
          "568: }  // namespace tensorflow",
          "",
          "[Removed Lines]",
          "566: void map_dtype_to_tensor(const DataType& dtype, FullTypeDef* t);",
          "",
          "[Added Lines]",
          "566: void map_dtype_to_tensor(const DataType& dtype, FullTypeDef& t);",
          "",
          "---------------"
        ],
        "tensorflow/core/graph/graph.cc||tensorflow/core/graph/graph.cc": [
          "File: tensorflow/core/graph/graph.cc -> tensorflow/core/graph/graph.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "573:   if (op_reg_data->type_ctor != nullptr) {",
          "574:     VLOG(3) << \"AddNode: found type constructor for \" << node_def.name();",
          "580:       VLOG(3) << \"AddNode: type inference failed for \" << node_def.name()",
          "582:       return nullptr;",
          "583:     }",
          "588:   } else {",
          "589:     VLOG(3) << \"AddNode: no type constructor for \" << node_def.name();",
          "590:   }",
          "",
          "[Removed Lines]",
          "575:     const auto ctor_type =",
          "576:         full_type::SpecializeType(AttrSlice(node_def), op_reg_data->op_def);",
          "577:     if (!ctor_type.ok()) {",
          "579:                                         ctor_type.status().ToString());",
          "581:               << \": \" << status->ToString();",
          "584:     const FullTypeDef ctor_typedef = ctor_type.ValueOrDie();",
          "585:     if (ctor_typedef.type_id() != TFT_UNSET) {",
          "587:     }",
          "",
          "[Added Lines]",
          "575:     Status s =",
          "576:         full_type::SpecializeType(AttrSlice(node_def), op_reg_data->op_def,",
          "578:     if (!s.ok()) {",
          "581:               << \": \" << s;",
          "",
          "---------------"
        ],
        "tensorflow/core/graph/node_builder_test.cc||tensorflow/core/graph/node_builder_test.cc": [
          "File: tensorflow/core/graph/node_builder_test.cc -> tensorflow/core/graph/node_builder_test.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "97:   ASSERT_EQ(ft.args_size(), 1);",
          "98:   auto ot = ft.args(0);",
          "99:   ASSERT_EQ(ot.type_id(), TFT_ARRAY);",
          "103: }",
          "105: REGISTER_OP(\"TypeInferenceOpTensorOutput\")",
          "",
          "[Removed Lines]",
          "100:   ASSERT_EQ(ot.args(0).type_id(), TFT_TENSOR);",
          "101:   ASSERT_EQ(ot.args(0).args(0).type_id(), TFT_FLOAT);",
          "102:   ASSERT_EQ(ot.args(0).args(0).args().size(), 0);",
          "",
          "[Added Lines]",
          "100:   ASSERT_EQ(ot.args(0).type_id(), TFT_FLOAT);",
          "101:   ASSERT_EQ(ot.args(0).args().size(), 0);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "189: TEST(NodeBuilderTest, TypeConstructorListType) {",
          "190:   Graph graph(OpRegistry::Global());",
          "191:   Node* node;",
          "193:                    .Attr(\"out_types\", {DT_FLOAT, DT_INT32})",
          "205: }",
          "207: }  // namespace",
          "",
          "[Removed Lines]",
          "192:   TF_EXPECT_OK(NodeBuilder(\"op\", \"FullTypeOpListType\")",
          "194:                    .Finalize(&graph, &node));",
          "195:   ASSERT_TRUE(node->def().has_experimental_type());",
          "196:   const FullTypeDef& ft = node->def().experimental_type();",
          "197:   ASSERT_EQ(ft.type_id(), TFT_PRODUCT);",
          "198:   ASSERT_EQ(ft.args_size(), 1);",
          "199:   auto ot = ft.args(0);",
          "200:   ASSERT_EQ(ot.type_id(), TFT_ARRAY);",
          "201:   ASSERT_EQ(ot.args(0).type_id(), TFT_PRODUCT);",
          "202:   ASSERT_EQ(ot.args(0).args(0).type_id(), TFT_TENSOR);",
          "203:   ASSERT_EQ(ot.args(0).args(0).args(0).type_id(), TFT_FLOAT);",
          "204:   ASSERT_EQ(ot.args(0).args(0).args(0).args().size(), 0);",
          "",
          "[Added Lines]",
          "191:   ASSERT_FALSE(NodeBuilder(\"op\", \"FullTypeOpListType\")",
          "193:                    .Finalize(&graph, &node)",
          "194:                    .ok());",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "f3a46eab6cdd8a17f2c7e079e5ae4f9debdb2d3a",
      "candidate_info": {
        "commit_hash": "f3a46eab6cdd8a17f2c7e079e5ae4f9debdb2d3a",
        "repo": "tensorflow/tensorflow",
        "commit_url": "https://github.com/tensorflow/tensorflow/commit/f3a46eab6cdd8a17f2c7e079e5ae4f9debdb2d3a",
        "files": [
          "tensorflow/core/graph/graph.cc"
        ],
        "message": "Add logging of type inference errors.\n\nPiperOrigin-RevId: 412121028\nChange-Id: I6c6fc96f87d4a22de173a5537977141ae591c3b5",
        "before_after_code_files": [
          "tensorflow/core/graph/graph.cc||tensorflow/core/graph/graph.cc"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "tensorflow/core/graph/graph.cc||tensorflow/core/graph/graph.cc"
          ],
          "candidate": [
            "tensorflow/core/graph/graph.cc||tensorflow/core/graph/graph.cc"
          ]
        }
      },
      "candidate_diff": {
        "tensorflow/core/graph/graph.cc||tensorflow/core/graph/graph.cc": [
          "File: tensorflow/core/graph/graph.cc -> tensorflow/core/graph/graph.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "577:     if (!ctor_type.ok()) {",
          "579:                                         ctor_type.status().ToString());",
          "580:       return nullptr;",
          "581:     }",
          "582:     const FullTypeDef ctor_typedef = ctor_type.ValueOrDie();",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "580:       VLOG(3) << \"AddNode: type inference failed for \" << node_def.name()",
          "581:               << \": \" << status->ToString();",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "ae7976631d87dfad52f8971369d14067447d1c02",
      "candidate_info": {
        "commit_hash": "ae7976631d87dfad52f8971369d14067447d1c02",
        "repo": "tensorflow/tensorflow",
        "commit_url": "https://github.com/tensorflow/tensorflow/commit/ae7976631d87dfad52f8971369d14067447d1c02",
        "files": [
          "tensorflow/core/graph/graph.cc"
        ],
        "message": "Check for type inference error on node construction.\n\nPiperOrigin-RevId: 409415804\nChange-Id: Ieb6e020906b96f522bf8e2fa103715ddbbdc434a",
        "before_after_code_files": [
          "tensorflow/core/graph/graph.cc||tensorflow/core/graph/graph.cc"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "tensorflow/core/graph/graph.cc||tensorflow/core/graph/graph.cc"
          ],
          "candidate": [
            "tensorflow/core/graph/graph.cc||tensorflow/core/graph/graph.cc"
          ]
        }
      },
      "candidate_diff": {
        "tensorflow/core/graph/graph.cc||tensorflow/core/graph/graph.cc": [
          "File: tensorflow/core/graph/graph.cc -> tensorflow/core/graph/graph.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "485:                                    ? Node::NC_FUNCTION_OP",
          "486:                                    : Node::GetNodeClassForOp(node_def.op());",
          "488:   Node* node = AllocateNode(",
          "489:       std::make_shared<NodeProperties>(&op_reg_data->op_def,",
          "490:                                        std::move(node_def), inputs, outputs),",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "488:   if (op_reg_data->type_ctor != nullptr) {",
          "489:     VLOG(3) << \"AddNode: found type constructor for \" << node_def.name();",
          "490:     const auto ctor_type =",
          "491:         full_type::SpecializeType(AttrSlice(node_def), op_reg_data->op_def);",
          "492:     if (!ctor_type.ok()) {",
          "494:                                         ctor_type.status().ToString());",
          "495:       return nullptr;",
          "496:     }",
          "497:     const FullTypeDef ctor_typedef = ctor_type.ValueOrDie();",
          "498:     if (ctor_typedef.type_id() != TFT_UNSET) {",
          "500:     }",
          "501:   } else {",
          "502:     VLOG(3) << \"AddNode: no type constructor for \" << node_def.name();",
          "503:   }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b49a624c0692a5688c29062abab600bb6e8568e1",
      "candidate_info": {
        "commit_hash": "b49a624c0692a5688c29062abab600bb6e8568e1",
        "repo": "tensorflow/tensorflow",
        "commit_url": "https://github.com/tensorflow/tensorflow/commit/b49a624c0692a5688c29062abab600bb6e8568e1",
        "files": [
          "tensorflow/core/graph/graph.cc"
        ],
        "message": "Check for type inference error on node construction.\n\nPiperOrigin-RevId: 409415804\nChange-Id: Ieb6e020906b96f522bf8e2fa103715ddbbdc434a",
        "before_after_code_files": [
          "tensorflow/core/graph/graph.cc||tensorflow/core/graph/graph.cc"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "tensorflow/core/graph/graph.cc||tensorflow/core/graph/graph.cc"
          ],
          "candidate": [
            "tensorflow/core/graph/graph.cc||tensorflow/core/graph/graph.cc"
          ]
        }
      },
      "candidate_diff": {
        "tensorflow/core/graph/graph.cc||tensorflow/core/graph/graph.cc": [
          "File: tensorflow/core/graph/graph.cc -> tensorflow/core/graph/graph.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "464:                                    ? Node::NC_FUNCTION_OP",
          "465:                                    : Node::GetNodeClassForOp(node_def.op());",
          "467:   Node* node = AllocateNode(",
          "468:       std::make_shared<NodeProperties>(&op_reg_data->op_def,",
          "469:                                        std::move(node_def), inputs, outputs),",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "467:   if (op_reg_data->type_ctor != nullptr) {",
          "468:     VLOG(3) << \"AddNode: found type constructor for \" << node_def.name();",
          "469:     const auto ctor_type =",
          "470:         full_type::SpecializeType(AttrSlice(node_def), op_reg_data->op_def);",
          "471:     if (!ctor_type.ok()) {",
          "473:                                         ctor_type.status().ToString());",
          "474:       return nullptr;",
          "475:     }",
          "476:     const FullTypeDef ctor_typedef = ctor_type.ValueOrDie();",
          "477:     if (ctor_typedef.type_id() != TFT_UNSET) {",
          "479:     }",
          "480:   } else {",
          "481:     VLOG(3) << \"AddNode: no type constructor for \" << node_def.name();",
          "482:   }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
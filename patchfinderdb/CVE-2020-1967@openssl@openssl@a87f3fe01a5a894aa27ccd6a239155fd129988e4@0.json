{
  "cve_id": "CVE-2020-1967",
  "cve_desc": "Server or client applications that call the SSL_check_chain() function during or after a TLS 1.3 handshake may crash due to a NULL pointer dereference as a result of incorrect handling of the \"signature_algorithms_cert\" TLS extension. The crash occurs if an invalid or unrecognised signature algorithm is received from the peer. This could be exploited by a malicious peer in a Denial of Service attack. OpenSSL version 1.1.1d, 1.1.1e, and 1.1.1f are affected by this issue. This issue did not affect OpenSSL versions prior to 1.1.1d. Fixed in OpenSSL 1.1.1g (Affected 1.1.1d-1.1.1f).",
  "repo": "openssl/openssl",
  "patch_hash": "a87f3fe01a5a894aa27ccd6a239155fd129988e4",
  "patch_info": {
    "commit_hash": "a87f3fe01a5a894aa27ccd6a239155fd129988e4",
    "repo": "openssl/openssl",
    "commit_url": "https://github.com/openssl/openssl/commit/a87f3fe01a5a894aa27ccd6a239155fd129988e4",
    "files": [
      "ssl/t1_lib.c"
    ],
    "message": "Fix NULL dereference in SSL_check_chain() for TLS 1.3\n\nIn the tls1_check_sig_alg() helper function, we loop through the list of\n\"signature_algorithms_cert\" values received from the client and attempt\nto look up each one in turn in our internal table that maps wire\ncodepoint to string-form name, digest and/or signature NID, etc., in\norder to compare the signature scheme from the peer's list against what\nis used to sign the certificates in the certificate chain we're\nchecking.  Unfortunately, when the peer sends a value that we don't\nsupport, the lookup returns NULL, but we unconditionally dereference the\nlookup result for the comparison, leading to an application crash\ntriggerable by an unauthenticated client.\n\nSince we will not be able to say anything about algorithms we don't\nrecognize, treat NULL return from lookup as \"does not match\".\n\nWe currently only apply the \"signature_algorithm_cert\" checks on TLS 1.3\nconnections, so previous TLS versions are unaffected.  SSL_check_chain()\nis not called directly from libssl, but may be used by the application\ninside a callback (e.g., client_hello or cert callback) to verify that a\ncandidate certificate chain will be acceptable to the client.\n\nCVE-2020-1967\n\nReviewed-by: Matt Caswell <matt@openssl.org>",
    "before_after_code_files": [
      "ssl/t1_lib.c||ssl/t1_lib.c"
    ]
  },
  "patch_diff": {
    "ssl/t1_lib.c||ssl/t1_lib.c": [
      "File: ssl/t1_lib.c -> ssl/t1_lib.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "2259:         sigalg = use_pc_sigalgs",
      "2260:                  ? tls1_lookup_sigalg(s->s3.tmp.peer_cert_sigalgs[i])",
      "2261:                  : s->shared_sigalgs[i];",
      "2263:             return 1;",
      "2264:     }",
      "2265:     return 0;",
      "",
      "[Removed Lines]",
      "2262:         if (sig_nid == sigalg->sigandhash)",
      "",
      "[Added Lines]",
      "2262:         if (sigalg != NULL && sig_nid == sigalg->sigandhash)",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "5235ef44b93306a14d0b6c695b13c64b16e1fdec",
      "candidate_info": {
        "commit_hash": "5235ef44b93306a14d0b6c695b13c64b16e1fdec",
        "repo": "openssl/openssl",
        "commit_url": "https://github.com/openssl/openssl/commit/5235ef44b93306a14d0b6c695b13c64b16e1fdec",
        "files": [
          "ssl/t1_lib.c"
        ],
        "message": "Fix SSL_check_chain()\n\nThe function SSL_check_chain() can be used by applications to check that\na cert and chain is compatible with the negotiated parameters. This could\nbe useful (for example) from the certificate callback. Unfortunately this\nfunction was applying TLSv1.2 sig algs rules and did not work correctly if\nTLSv1.3 was negotiated.\n\nWe refactor tls_choose_sigalg to split it up and create a new function\nfind_sig_alg which can (optionally) take a certificate and key as\nparameters and find an appropriate sig alg if one exists. If the cert and\nkey are not supplied then we try to find a cert and key from the ones we\nhave available that matches the shared sig algs.\n\nReviewed-by: Tomas Mraz <tmraz@fedoraproject.org>\n(Merged from https://github.com/openssl/openssl/pull/9442)",
        "before_after_code_files": [
          "ssl/t1_lib.c||ssl/t1_lib.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "ssl/t1_lib.c||ssl/t1_lib.c"
          ],
          "candidate": [
            "ssl/t1_lib.c||ssl/t1_lib.c"
          ]
        }
      },
      "candidate_diff": {
        "ssl/t1_lib.c||ssl/t1_lib.c": [
          "File: ssl/t1_lib.c -> ssl/t1_lib.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "21: #include \"ssl_locl.h\"",
          "22: #include <openssl/ct.h>",
          "24: SSL3_ENC_METHOD const TLSv1_enc_data = {",
          "25:     tls1_enc,",
          "26:     tls1_mac,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "24: static const SIGALG_LOOKUP *find_sig_alg(SSL *s, X509 *x, EVP_PKEY *pkey);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2152: static int tls1_check_sig_alg(SSL *s, X509 *x, int default_nid)",
          "2153: {",
          "2155:     size_t i;",
          "2156:     if (default_nid == -1)",
          "2157:         return 1;",
          "2158:     sig_nid = X509_get_signature_nid(x);",
          "2159:     if (default_nid)",
          "2160:         return sig_nid == default_nid ? 1 : 0;",
          "2163:             return 1;",
          "2164:     return 0;",
          "2165: }",
          "",
          "[Removed Lines]",
          "2154:     int sig_nid;",
          "2161:     for (i = 0; i < s->shared_sigalgslen; i++)",
          "2162:         if (sig_nid == s->shared_sigalgs[i]->sigandhash)",
          "",
          "[Added Lines]",
          "2156:     int sig_nid, use_pc_sigalgs = 0;",
          "2158:     const SIGALG_LOOKUP *sigalg;",
          "2159:     size_t sigalgslen;",
          "2166:     if (SSL_IS_TLS13(s) && s->s3.tmp.peer_cert_sigalgs != NULL) {",
          "2172:         sigalgslen = s->s3.tmp.peer_cert_sigalgslen;",
          "2173:         use_pc_sigalgs = 1;",
          "2174:     } else {",
          "2175:         sigalgslen = s->shared_sigalgslen;",
          "2176:     }",
          "2177:     for (i = 0; i < sigalgslen; i++) {",
          "2178:         sigalg = use_pc_sigalgs",
          "2179:                  ? tls1_lookup_sigalg(s->s3.tmp.peer_cert_sigalgs[i])",
          "2180:                  : s->shared_sigalgs[i];",
          "2181:         if (sig_nid == sigalg->sigandhash)",
          "2183:     }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2317:             }",
          "2318:         }",
          "2321:             if (!check_flags)",
          "2322:                 goto end;",
          "2323:         } else",
          "",
          "[Removed Lines]",
          "2320:         if (!tls1_check_sig_alg(s, x, default_nid)) {",
          "",
          "[Added Lines]",
          "2340:         if (SSL_IS_TLS13(s)) {",
          "2345:             if (find_sig_alg(s, x, pk) != NULL)",
          "2346:                 rv |= CERT_PKEY_EE_SIGNATURE;",
          "2347:         } else if (!tls1_check_sig_alg(s, x, default_nid)) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2605: }",
          "2615: {",
          "2616:     const SIGALG_LOOKUP *lu;",
          "2617:     int mdnid, pknid, supported;",
          "2618:     size_t i;",
          "2625:     if (s->s3.tmp.peer_cert_sigalgs != NULL) {",
          "2626:         for (i = 0; i < s->s3.tmp.peer_cert_sigalgslen; i++) {",
          "2627:             lu = tls1_lookup_sigalg(s->s3.tmp.peer_cert_sigalgs[i]);",
          "2628:             if (lu == NULL",
          "",
          "[Removed Lines]",
          "2614: static int has_usable_cert(SSL *s, const SIGALG_LOOKUP *sig, int idx)",
          "2621:     if (idx == -1)",
          "2622:         idx = sig->sig_idx;",
          "2623:     if (!ssl_has_cert(s, idx))",
          "2624:         return 0;",
          "2629:                 || !X509_get_signature_info(s->cert->pkeys[idx].x509, &mdnid,",
          "2630:                                             &pknid, NULL, NULL)",
          "",
          "[Added Lines]",
          "2640: static int check_cert_usable(SSL *s, const SIGALG_LOOKUP *sig, X509 *x,",
          "2641:                              EVP_PKEY *pkey)",
          "2651:                 || !X509_get_signature_info(x, &mdnid, &pknid, NULL, NULL)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2639:                 continue;",
          "2641:             ERR_set_mark();",
          "2644:             if (supported == 0)",
          "2645:                 continue;",
          "2652:             return 1;",
          "2653:         }",
          "2654:         return 0;",
          "2655:     }",
          "2658:     if (supported == 0)",
          "2659:         return 0;",
          "2663:     return 1;",
          "2664: }",
          "",
          "[Removed Lines]",
          "2642:             supported = EVP_PKEY_supports_digest_nid(s->cert->pkeys[idx].privatekey,",
          "2643:                                                      mdnid);",
          "2646:             else if (supported < 0)",
          "2647:             {",
          "2650:                 ERR_pop_to_mark();",
          "2651:             }",
          "2656:     supported = EVP_PKEY_supports_digest_nid(s->cert->pkeys[idx].privatekey,",
          "2657:                                              sig->hash);",
          "2660:     else if (supported < 0)",
          "2661:         ERR_clear_error();",
          "",
          "[Added Lines]",
          "2663:             supported = EVP_PKEY_supports_digest_nid(pkey, mdnid);",
          "2664:             ERR_pop_to_mark();",
          "2676:     ERR_set_mark();",
          "2677:     supported = EVP_PKEY_supports_digest_nid(pkey, sig->hash);",
          "2678:     ERR_pop_to_mark();",
          "2697: static int has_usable_cert(SSL *s, const SIGALG_LOOKUP *sig, int idx)",
          "2698: {",
          "2700:     if (idx == -1)",
          "2701:         idx = sig->sig_idx;",
          "2702:     if (!ssl_has_cert(s, idx))",
          "2703:         return 0;",
          "2705:     return check_cert_usable(s, sig, s->cert->pkeys[idx].x509,",
          "2706:                              s->cert->pkeys[idx].privatekey);",
          "2707: }",
          "2713: static int is_cert_usable(SSL *s, const SIGALG_LOOKUP *sig, X509 *x,",
          "2714:                           EVP_PKEY *pkey)",
          "2715: {",
          "2716:     size_t idx;",
          "2718:     if (ssl_cert_lookup_by_pkey(pkey, &idx) == NULL)",
          "2719:         return 0;",
          "2722:     if ((int)idx != sig->sig_idx)",
          "2723:         return 0;",
          "2725:     return check_cert_usable(s, sig, x, pkey);",
          "2726: }",
          "2733: static const SIGALG_LOOKUP *find_sig_alg(SSL *s, X509 *x, EVP_PKEY *pkey)",
          "2734: {",
          "2735:     const SIGALG_LOOKUP *lu = NULL;",
          "2736:     size_t i;",
          "2737: #ifndef OPENSSL_NO_EC",
          "2738:     int curve = -1;",
          "2739: #endif",
          "2740:     EVP_PKEY *tmppkey;",
          "2743:     for (i = 0; i < s->shared_sigalgslen; i++) {",
          "2744:         lu = s->shared_sigalgs[i];",
          "2747:         if (lu->hash == NID_sha1",
          "2748:             || lu->hash == NID_sha224",
          "2749:             || lu->sig == EVP_PKEY_DSA",
          "2750:             || lu->sig == EVP_PKEY_RSA)",
          "2751:             continue;",
          "2753:         if (!tls1_lookup_md(lu, NULL))",
          "2754:             continue;",
          "2755:         if ((pkey == NULL && !has_usable_cert(s, lu, -1))",
          "2756:                 || (pkey != NULL && !is_cert_usable(s, lu, x, pkey)))",
          "2757:             continue;",
          "2759:         tmppkey = (pkey != NULL) ? pkey",
          "2760:                                  : s->cert->pkeys[lu->sig_idx].privatekey;",
          "2762:         if (lu->sig == EVP_PKEY_EC) {",
          "2763: #ifndef OPENSSL_NO_EC",
          "2764:             if (curve == -1) {",
          "2765:                 EC_KEY *ec = EVP_PKEY_get0_EC_KEY(tmppkey);",
          "2766:                 curve = EC_GROUP_get_curve_name(EC_KEY_get0_group(ec));",
          "2767:             }",
          "2768:             if (lu->curve != NID_undef && curve != lu->curve)",
          "2769:                 continue;",
          "2770: #else",
          "2771:             continue;",
          "2772: #endif",
          "2773:         } else if (lu->sig == EVP_PKEY_RSA_PSS) {",
          "2775:             if (!rsa_pss_check_min_key_size(EVP_PKEY_get0(tmppkey), lu))",
          "2776:                 continue;",
          "2777:         }",
          "2778:         break;",
          "2779:     }",
          "2781:     if (i == s->shared_sigalgslen)",
          "2782:         return NULL;",
          "2784:     return lu;",
          "2785: }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2683:     s->s3.tmp.sigalg = NULL;",
          "2685:     if (SSL_IS_TLS13(s)) {",
          "2728:             if (!fatalerrs)",
          "2729:                 return 1;",
          "2730:             SSLfatal(s, SSL_AD_HANDSHAKE_FAILURE, SSL_F_TLS_CHOOSE_SIGALG,",
          "",
          "[Removed Lines]",
          "2686:         size_t i;",
          "2687: #ifndef OPENSSL_NO_EC",
          "2688:         int curve = -1;",
          "2689: #endif",
          "2692:         for (i = 0; i < s->shared_sigalgslen; i++) {",
          "2693:             lu = s->shared_sigalgs[i];",
          "2694:             sig_idx = -1;",
          "2697:             if (lu->hash == NID_sha1",
          "2698:                 || lu->hash == NID_sha224",
          "2699:                 || lu->sig == EVP_PKEY_DSA",
          "2700:                 || lu->sig == EVP_PKEY_RSA)",
          "2701:                 continue;",
          "2703:             if (!tls1_lookup_md(lu, NULL) || !has_usable_cert(s, lu, -1))",
          "2704:                 continue;",
          "2705:             if (lu->sig == EVP_PKEY_EC) {",
          "2706: #ifndef OPENSSL_NO_EC",
          "2707:                 if (curve == -1) {",
          "2708:                     EC_KEY *ec = EVP_PKEY_get0_EC_KEY(s->cert->pkeys[SSL_PKEY_ECC].privatekey);",
          "2710:                     curve = EC_GROUP_get_curve_name(EC_KEY_get0_group(ec));",
          "2711:                 }",
          "2712:                 if (lu->curve != NID_undef && curve != lu->curve)",
          "2713:                     continue;",
          "2714: #else",
          "2715:                 continue;",
          "2716: #endif",
          "2717:             } else if (lu->sig == EVP_PKEY_RSA_PSS) {",
          "2719:                 EVP_PKEY *pkey;",
          "2721:                 pkey = s->cert->pkeys[lu->sig_idx].privatekey;",
          "2722:                 if (!rsa_pss_check_min_key_size(EVP_PKEY_get0(pkey), lu))",
          "2723:                     continue;",
          "2724:             }",
          "2725:             break;",
          "2726:         }",
          "2727:         if (i == s->shared_sigalgslen) {",
          "",
          "[Added Lines]",
          "2807:         lu = find_sig_alg(s, NULL, NULL);",
          "2808:         if (lu == NULL) {",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "29948ac80c1388cfeb0bd64539ac1fa6e0bb8990",
      "candidate_info": {
        "commit_hash": "29948ac80c1388cfeb0bd64539ac1fa6e0bb8990",
        "repo": "openssl/openssl",
        "commit_url": "https://github.com/openssl/openssl/commit/29948ac80c1388cfeb0bd64539ac1fa6e0bb8990",
        "files": [
          "ssl/ssl_cert.c",
          "ssl/ssl_lib.c",
          "ssl/ssl_locl.h",
          "ssl/t1_lib.c"
        ],
        "message": "Move 'shared_sigalgs' from cert_st to ssl_st\n\nIt was only ever in cert_st because ssl_st was a public structure\nand could not be modified without breaking the API.  However, both\nstructures are now opaque, and thus we can freely change their layout\nwithout breaking applications.  In this case, keeping the shared\nsigalgs in the SSL object prevents complications wherein they would\ninadvertently get cleared during SSL_set_SSL_CTX() (e.g., as run\nduring a cert_cb).\n\nFixes #9099\n\nReviewed-by: Matt Caswell <matt@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/9157)",
        "before_after_code_files": [
          "ssl/ssl_cert.c||ssl/ssl_cert.c",
          "ssl/ssl_lib.c||ssl/ssl_lib.c",
          "ssl/ssl_locl.h||ssl/ssl_locl.h",
          "ssl/t1_lib.c||ssl/t1_lib.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "ssl/t1_lib.c||ssl/t1_lib.c"
          ],
          "candidate": [
            "ssl/t1_lib.c||ssl/t1_lib.c"
          ]
        }
      },
      "candidate_diff": {
        "ssl/ssl_cert.c||ssl/ssl_cert.c": [
          "File: ssl/ssl_cert.c -> ssl/ssl_cert.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "154:         ret->client_sigalgslen = cert->client_sigalgslen;",
          "155:     } else",
          "156:         ret->client_sigalgs = NULL;",
          "160:     if (cert->ctype) {",
          "161:         ret->ctype = OPENSSL_memdup(cert->ctype, cert->ctype_len);",
          "",
          "[Removed Lines]",
          "158:     ret->shared_sigalgs = NULL;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "240:     ssl_cert_clear_certs(c);",
          "241:     OPENSSL_free(c->conf_sigalgs);",
          "242:     OPENSSL_free(c->client_sigalgs);",
          "244:     OPENSSL_free(c->ctype);",
          "245:     X509_STORE_free(c->verify_store);",
          "246:     X509_STORE_free(c->chain_store);",
          "",
          "[Removed Lines]",
          "243:     OPENSSL_free(c->shared_sigalgs);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "ssl/ssl_lib.c||ssl/ssl_lib.c": [
          "File: ssl/ssl_lib.c -> ssl/ssl_lib.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "630:     X509_VERIFY_PARAM_move_peername(s->param, NULL);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "633:     OPENSSL_free(s->shared_sigalgs);",
          "634:     s->shared_sigalgs = NULL;",
          "635:     s->shared_sigalgslen = 0;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1182:     clear_ciphers(s);",
          "1184:     ssl_cert_free(s->cert);",
          "1187:     OPENSSL_free(s->ext.hostname);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1190:     OPENSSL_free(s->shared_sigalgs);",
          "",
          "---------------"
        ],
        "ssl/ssl_locl.h||ssl/ssl_locl.h": [
          "File: ssl/ssl_locl.h -> ssl/ssl_locl.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "1662:     SSL_async_callback_fn async_cb;",
          "1663:     void *async_cb_arg;",
          "1664: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1669:     const struct sigalg_lookup_st **shared_sigalgs;",
          "1670:     size_t shared_sigalgslen;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1925:     uint16_t *client_sigalgs;",
          "1927:     size_t client_sigalgslen;",
          "",
          "[Removed Lines]",
          "1932:     const SIGALG_LOOKUP **shared_sigalgs;",
          "1933:     size_t shared_sigalgslen;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "ssl/t1_lib.c||ssl/t1_lib.c": [
          "File: ssl/t1_lib.c -> ssl/t1_lib.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "650:     if (check_ee_md && tls1_suiteb(s)) {",
          "651:         int check_md;",
          "652:         size_t i;",
          "656:         if (group_id == TLSEXT_curve_P_256)",
          "",
          "[Removed Lines]",
          "653:         CERT *c = s->cert;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "659:             check_md = NID_ecdsa_with_SHA384;",
          "660:         else",
          "664:                 return 1;;",
          "665:         }",
          "666:         return 0;",
          "",
          "[Removed Lines]",
          "662:         for (i = 0; i < c->shared_sigalgslen; i++) {",
          "663:             if (check_md == c->shared_sigalgs[i]->sigandhash)",
          "",
          "[Added Lines]",
          "661:         for (i = 0; i < s->shared_sigalgslen; i++) {",
          "662:             if (check_md == s->shared_sigalgs[i]->sigandhash)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1287:     size_t i;",
          "1294:     for (i = 0; i < SSL_PKEY_NUM; i++)",
          "1295:         s->s3.tmp.valid_flags[i] = 0;",
          "",
          "[Removed Lines]",
          "1290:     OPENSSL_free(s->cert->shared_sigalgs);",
          "1291:     s->cert->shared_sigalgs = NULL;",
          "1292:     s->cert->shared_sigalgslen = 0;",
          "",
          "[Added Lines]",
          "1289:     OPENSSL_free(s->shared_sigalgs);",
          "1290:     s->shared_sigalgs = NULL;",
          "1291:     s->shared_sigalgslen = 0;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1324:                  SSL_F_TLS1_SET_SERVER_SIGALGS, ERR_R_INTERNAL_ERROR);",
          "1325:         return 0;",
          "1326:     }",
          "1328:         return 1;",
          "",
          "[Removed Lines]",
          "1327:     if (s->cert->shared_sigalgs != NULL)",
          "",
          "[Added Lines]",
          "1326:     if (s->shared_sigalgs != NULL)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1796:     CERT *c = s->cert;",
          "1797:     unsigned int is_suiteb = tls1_suiteb(s);",
          "1803:     if (!s->server && c->client_sigalgs && !is_suiteb) {",
          "1804:         conf = c->client_sigalgs;",
          "",
          "[Removed Lines]",
          "1799:     OPENSSL_free(c->shared_sigalgs);",
          "1800:     c->shared_sigalgs = NULL;",
          "1801:     c->shared_sigalgslen = 0;",
          "",
          "[Added Lines]",
          "1798:     OPENSSL_free(s->shared_sigalgs);",
          "1799:     s->shared_sigalgs = NULL;",
          "1800:     s->shared_sigalgslen = 0;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1829:     } else {",
          "1830:         salgs = NULL;",
          "1831:     }",
          "1834:     return 1;",
          "1835: }",
          "",
          "[Removed Lines]",
          "1832:     c->shared_sigalgs = salgs;",
          "1833:     c->shared_sigalgslen = nmatch;",
          "",
          "[Added Lines]",
          "1831:     s->shared_sigalgs = salgs;",
          "1832:     s->shared_sigalgslen = nmatch;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1891: {",
          "1892:     size_t i;",
          "1893:     uint32_t *pvalid = s->s3.tmp.valid_flags;",
          "1896:     if (!tls1_set_shared_sigalgs(s))",
          "1897:         return 0;",
          "",
          "[Removed Lines]",
          "1894:     CERT *c = s->cert;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1899:     for (i = 0; i < SSL_PKEY_NUM; i++)",
          "1900:         pvalid[i] = 0;",
          "1904:         int idx = sigptr->sig_idx;",
          "",
          "[Removed Lines]",
          "1902:     for (i = 0; i < c->shared_sigalgslen; i++) {",
          "1903:         const SIGALG_LOOKUP *sigptr = c->shared_sigalgs[i];",
          "",
          "[Added Lines]",
          "1900:     for (i = 0; i < s->shared_sigalgslen; i++) {",
          "1901:         const SIGALG_LOOKUP *sigptr = s->shared_sigalgs[i];",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1947:                            unsigned char *rsig, unsigned char *rhash)",
          "1948: {",
          "1949:     const SIGALG_LOOKUP *shsigalgs;",
          "1951:         || idx < 0",
          "1954:         return 0;",
          "1956:     if (phash != NULL)",
          "1958:     if (psign != NULL)",
          "",
          "[Removed Lines]",
          "1950:     if (s->cert->shared_sigalgs == NULL",
          "1952:         || idx >= (int)s->cert->shared_sigalgslen",
          "1953:         || s->cert->shared_sigalgslen > INT_MAX)",
          "1955:     shsigalgs = s->cert->shared_sigalgs[idx];",
          "",
          "[Added Lines]",
          "1948:     if (s->shared_sigalgs == NULL",
          "1950:         || idx >= (int)s->shared_sigalgslen",
          "1951:         || s->shared_sigalgslen > INT_MAX)",
          "1953:     shsigalgs = s->shared_sigalgs[idx];",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1964:     if (rhash != NULL)",
          "1967: }",
          "",
          "[Removed Lines]",
          "1966:     return (int)s->cert->shared_sigalgslen;",
          "",
          "[Added Lines]",
          "1964:     return (int)s->shared_sigalgslen;",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "2144:     return 0;",
          "2145: }",
          "2148: {",
          "2149:     int sig_nid;",
          "2150:     size_t i;",
          "",
          "[Removed Lines]",
          "2147: static int tls1_check_sig_alg(CERT *c, X509 *x, int default_nid)",
          "",
          "[Added Lines]",
          "2145: static int tls1_check_sig_alg(SSL *s, X509 *x, int default_nid)",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "2153:     sig_nid = X509_get_signature_nid(x);",
          "2154:     if (default_nid)",
          "2155:         return sig_nid == default_nid ? 1 : 0;",
          "2158:             return 1;",
          "2159:     return 0;",
          "2160: }",
          "",
          "[Removed Lines]",
          "2156:     for (i = 0; i < c->shared_sigalgslen; i++)",
          "2157:         if (sig_nid == c->shared_sigalgs[i]->sigandhash)",
          "",
          "[Added Lines]",
          "2154:     for (i = 0; i < s->shared_sigalgslen; i++)",
          "2155:         if (sig_nid == s->shared_sigalgs[i]->sigandhash)",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "2312:             }",
          "2313:         }",
          "2316:             if (!check_flags)",
          "2317:                 goto end;",
          "2318:         } else",
          "2319:             rv |= CERT_PKEY_EE_SIGNATURE;",
          "2320:         rv |= CERT_PKEY_CA_SIGNATURE;",
          "2321:         for (i = 0; i < sk_X509_num(chain); i++) {",
          "2323:                 if (check_flags) {",
          "2324:                     rv &= ~CERT_PKEY_CA_SIGNATURE;",
          "2325:                     break;",
          "",
          "[Removed Lines]",
          "2315:         if (!tls1_check_sig_alg(c, x, default_nid)) {",
          "2322:             if (!tls1_check_sig_alg(c, sk_X509_value(chain, i), default_nid)) {",
          "",
          "[Added Lines]",
          "2313:         if (!tls1_check_sig_alg(s, x, default_nid)) {",
          "2320:             if (!tls1_check_sig_alg(s, sk_X509_value(chain, i), default_nid)) {",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "2684: #endif",
          "2689:             sig_idx = -1;",
          "",
          "[Removed Lines]",
          "2687:         for (i = 0; i < s->cert->shared_sigalgslen; i++) {",
          "2688:             lu = s->cert->shared_sigalgs[i];",
          "",
          "[Added Lines]",
          "2685:         for (i = 0; i < s->shared_sigalgslen; i++) {",
          "2686:             lu = s->shared_sigalgs[i];",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "2719:             }",
          "2720:             break;",
          "2721:         }",
          "2723:             if (!fatalerrs)",
          "2724:                 return 1;",
          "2725:             SSLfatal(s, SSL_AD_HANDSHAKE_FAILURE, SSL_F_TLS_CHOOSE_SIGALG,",
          "",
          "[Removed Lines]",
          "2722:         if (i == s->cert->shared_sigalgslen) {",
          "",
          "[Added Lines]",
          "2720:         if (i == s->shared_sigalgslen) {",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "2758:                     if (s->server) {",
          "2759:                         if ((sig_idx = tls12_get_cert_sigalg_idx(s, lu)) == -1)",
          "",
          "[Removed Lines]",
          "2755:                 for (i = 0; i < s->cert->shared_sigalgslen; i++) {",
          "2756:                     lu = s->cert->shared_sigalgs[i];",
          "",
          "[Added Lines]",
          "2753:                 for (i = 0; i < s->shared_sigalgslen; i++) {",
          "2754:                     lu = s->shared_sigalgs[i];",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "2780: #endif",
          "2781:                         break;",
          "2782:                 }",
          "2784:                     if (!fatalerrs)",
          "2785:                         return 1;",
          "2786:                     SSLfatal(s, SSL_AD_HANDSHAKE_FAILURE,",
          "",
          "[Removed Lines]",
          "2783:                 if (i == s->cert->shared_sigalgslen) {",
          "",
          "[Added Lines]",
          "2781:                 if (i == s->shared_sigalgslen) {",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "64eef86733fd40a5b7737dc586754c3fa3414b0c",
      "candidate_info": {
        "commit_hash": "64eef86733fd40a5b7737dc586754c3fa3414b0c",
        "repo": "openssl/openssl",
        "commit_url": "https://github.com/openssl/openssl/commit/64eef86733fd40a5b7737dc586754c3fa3414b0c",
        "files": [
          "test/recipes/70-test_sslsigalgs.t"
        ],
        "message": "Add test for CVE-2020-1967\n\nAdd to test_sslsigalgs a TLSProxy test that injects a\n\"signature_algorithms_cert\" extension that contains an unallocated\ncodepoint.\n\nThe test currently fails, since s_server segfaults instead of\nignoring the unrecognized value.\n\nSince \"signature_algorithms\" and \"signature_algorithms_cert\" are very\nsimilar, also add the analogous test for \"signature_algorithms\".\n\nReviewed-by: Matt Caswell <matt@openssl.org>",
        "before_after_code_files": [
          "test/recipes/70-test_sslsigalgs.t||test/recipes/70-test_sslsigalgs.t"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "test/recipes/70-test_sslsigalgs.t||test/recipes/70-test_sslsigalgs.t": [
          "File: test/recipes/70-test_sslsigalgs.t -> test/recipes/70-test_sslsigalgs.t",
          "--- Hunk 1 ---",
          "[Context before]",
          "44:     COMPAT_SIGALGS => 6,",
          "45:     SIGALGS_CERT_ALL => 7,",
          "46:     SIGALGS_CERT_PKCS => 8,",
          "48: };",
          "50: #Note: Throughout this test we override the default ciphersuites where TLSv1.2",
          "",
          "[Removed Lines]",
          "47:     SIGALGS_CERT_INVALID => 9",
          "",
          "[Added Lines]",
          "47:     SIGALGS_CERT_INVALID => 9,",
          "48:     UNRECOGNIZED_SIGALGS_CERT => 10,",
          "49:     UNRECOGNIZED_SIGALG => 11",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "54: #Test 1: Default sig algs should succeed",
          "55: $proxy->start() or plan skip_all => \"Unable to start up Proxy for tests\";",
          "57: ok(TLSProxy::Message->success, \"Default sigalgs\");",
          "58: my $testtype;",
          "",
          "[Removed Lines]",
          "56: plan tests => 24;",
          "",
          "[Added Lines]",
          "58: plan tests => 26;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "282:     ok(TLSProxy::Message->fail, \"No matching certificate for sigalgs_cert\");",
          "283: }",
          "287: sub sigalgs_filter",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "287: SKIP: {",
          "288:     skip \"TLS 1.3 disabled\", 2 if disabled(\"tls1_3\");",
          "289:     #Test 25: Send an unrecognized signature_algorithms_cert",
          "290:     #        We should be able to skip over the unrecognized value and use a",
          "291:     #        valid one that appears later in the list.",
          "292:     $proxy->clear();",
          "293:     $proxy->filter(\\&inject_unrecognized_sigalg);",
          "294:     $proxy->clientflags(\"-tls1_3\");",
          "295:     # Use -xcert to get SSL_check_chain() to run in the cert_cb.  This is",
          "296:     # needed to trigger (e.g.) CVE-2020-1967",
          "297:     $proxy->serverflags(\"\" .",
          "298:             \" -xcert \" . srctop_file(\"test\", \"certs\", \"servercert.pem\") .",
          "299:             \" -xkey \" . srctop_file(\"test\", \"certs\", \"serverkey.pem\") .",
          "300:             \" -xchain \" . srctop_file(\"test\", \"certs\", \"rootcert.pem\"));",
          "301:     $testtype = UNRECOGNIZED_SIGALGS_CERT;",
          "302:     $proxy->start();",
          "303:     ok(TLSProxy::Message->success(), \"Unrecognized sigalg_cert in ClientHello\");",
          "305:     #Test 26: Send an unrecognized signature_algorithms",
          "306:     #        We should be able to skip over the unrecognized value and use a",
          "307:     #        valid one that appears later in the list.",
          "308:     $proxy->clear();",
          "309:     $proxy->filter(\\&inject_unrecognized_sigalg);",
          "310:     $proxy->clientflags(\"-tls1_3\");",
          "311:     $proxy->serverflags(\"\" .",
          "312:             \" -xcert \" . srctop_file(\"test\", \"certs\", \"servercert.pem\") .",
          "313:             \" -xkey \" . srctop_file(\"test\", \"certs\", \"serverkey.pem\") .",
          "314:             \" -xchain \" . srctop_file(\"test\", \"certs\", \"rootcert.pem\"));",
          "315:     $testtype = UNRECOGNIZED_SIGALG;",
          "316:     $proxy->start();",
          "317:     ok(TLSProxy::Message->success(), \"Unrecognized sigalg in ClientHello\");",
          "318: }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "427:         }",
          "428:     }",
          "429: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "466: sub inject_unrecognized_sigalg",
          "467: {",
          "468:     my $proxy = shift;",
          "469:     my $type;",
          "471:     # We're only interested in the initial ClientHello",
          "472:     if ($proxy->flight != 0) {",
          "473:         return;",
          "474:     }",
          "475:     if ($testtype == UNRECOGNIZED_SIGALGS_CERT) {",
          "476:         $type = TLSProxy::Message::EXT_SIG_ALGS_CERT;",
          "477:     } elsif ($testtype == UNRECOGNIZED_SIGALG) {",
          "478:         $type = TLSProxy::Message::EXT_SIG_ALGS;",
          "479:     } else {",
          "480:         return;",
          "481:     }",
          "483:     my $ext = pack \"C8\",",
          "484:         0x00, 0x06, #Extension length",
          "485:         0xfe, 0x18, #private use",
          "486:         0x04, 0x01, #rsa_pkcs1_sha256",
          "487:         0x08, 0x04; #rsa_pss_rsae_sha256;",
          "488:     my $message = ${$proxy->message_list}[0];",
          "489:     $message->set_extension($type, $ext);",
          "490:     $message->repack;",
          "491: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "eb563247aef3e83dda7679c43f9649270462e5b1",
      "candidate_info": {
        "commit_hash": "eb563247aef3e83dda7679c43f9649270462e5b1",
        "repo": "openssl/openssl",
        "commit_url": "https://github.com/openssl/openssl/commit/eb563247aef3e83dda7679c43f9649270462e5b1",
        "files": [
          "ssl/t1_lib.c"
        ],
        "message": "Fix NULL dereference in SSL_check_chain() for TLS 1.3\n\nIn the tls1_check_sig_alg() helper function, we loop through the list of\n\"signature_algorithms_cert\" values received from the client and attempt\nto look up each one in turn in our internal table that maps wire\ncodepoint to string-form name, digest and/or signature NID, etc., in\norder to compare the signature scheme from the peer's list against what\nis used to sign the certificates in the certificate chain we're\nchecking.  Unfortunately, when the peer sends a value that we don't\nsupport, the lookup returns NULL, but we unconditionally dereference the\nlookup result for the comparison, leading to an application crash\ntriggerable by an unauthenticated client.\n\nSince we will not be able to say anything about algorithms we don't\nrecognize, treat NULL return from lookup as \"does not match\".\n\nWe currently only apply the \"signature_algorithm_cert\" checks on TLS 1.3\nconnections, so previous TLS versions are unaffected.  SSL_check_chain()\nis not called directly from libssl, but may be used by the application\ninside a callback (e.g., client_hello or cert callback) to verify that a\ncandidate certificate chain will be acceptable to the client.\n\nCVE-2020-1967\n\nReviewed-by: Matt Caswell <matt@openssl.org>",
        "before_after_code_files": [
          "ssl/t1_lib.c||ssl/t1_lib.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "ssl/t1_lib.c||ssl/t1_lib.c"
          ],
          "candidate": [
            "ssl/t1_lib.c||ssl/t1_lib.c"
          ]
        }
      },
      "candidate_diff": {
        "ssl/t1_lib.c||ssl/t1_lib.c": [
          "File: ssl/t1_lib.c -> ssl/t1_lib.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2130:         sigalg = use_pc_sigalgs",
          "2131:                  ? tls1_lookup_sigalg(s->s3->tmp.peer_cert_sigalgs[i])",
          "2132:                  : s->shared_sigalgs[i];",
          "2134:             return 1;",
          "2135:     }",
          "2136:     return 0;",
          "",
          "[Removed Lines]",
          "2133:         if (sig_nid == sigalg->sigandhash)",
          "",
          "[Added Lines]",
          "2133:         if (sigalg != NULL && sig_nid == sigalg->sigandhash)",
          "",
          "---------------"
        ]
      }
    }
  ]
}
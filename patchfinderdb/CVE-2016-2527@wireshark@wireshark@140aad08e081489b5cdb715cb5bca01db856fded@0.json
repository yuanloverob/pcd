{
  "cve_id": "CVE-2016-2527",
  "cve_desc": "wiretap/nettrace_3gpp_32_423.c in the 3GPP TS 32.423 Trace file parser in Wireshark 2.0.x before 2.0.2 does not ensure that a '\\0' character is present at the end of certain strings, which allows remote attackers to cause a denial of service (stack-based buffer overflow and application crash) via a crafted file.",
  "repo": "wireshark/wireshark",
  "patch_hash": "140aad08e081489b5cdb715cb5bca01db856fded",
  "patch_info": {
    "commit_hash": "140aad08e081489b5cdb715cb5bca01db856fded",
    "repo": "wireshark/wireshark",
    "commit_url": "https://github.com/wireshark/wireshark/commit/140aad08e081489b5cdb715cb5bca01db856fded",
    "files": [
      "wiretap/nettrace_3gpp_32_423.c"
    ],
    "message": "nettrace_3gpp_32_423 Protect from buffer overun.\n\nBug: 11982\nChange-Id: Ib704d9128ab6427751edbf3a33f4b8fd14902562\nReviewed-on: https://code.wireshark.org/review/13233\nReviewed-by: Anders Broman <a.broman58@gmail.com>\nPetri-Dish: Anders Broman <a.broman58@gmail.com>\nTested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>\nReviewed-by: Michael Mann <mmann78@netscape.net>",
    "before_after_code_files": [
      "wiretap/nettrace_3gpp_32_423.c||wiretap/nettrace_3gpp_32_423.c"
    ]
  },
  "patch_diff": {
    "wiretap/nettrace_3gpp_32_423.c||wiretap/nettrace_3gpp_32_423.c": [
      "File: wiretap/nettrace_3gpp_32_423.c -> wiretap/nettrace_3gpp_32_423.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "728:  packet_buf[0] = 0;",
      "",
      "[Removed Lines]",
      "726:  packet_buf = (guint8 *)g_malloc(packet_size + 12);",
      "",
      "[Added Lines]",
      "726:  packet_buf = (guint8 *)g_malloc(packet_size + 12+1);",
      "728:     packet_buf[packet_size + 12] = 0;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "982:  if (memcmp(magic_buf, xml_magic, sizeof(xml_magic)) != 0){",
      "983:   return WTAP_OPEN_NOT_MINE;",
      "984:  }",
      "986:  curr_pos = strstr(magic_buf, \"fileFormatVersion\");",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "988:  magic_buf[512 - 1] = 0;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "10d4c8531623ed5fe3f0ed54e5a9d83872e835dd",
      "candidate_info": {
        "commit_hash": "10d4c8531623ed5fe3f0ed54e5a9d83872e835dd",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/10d4c8531623ed5fe3f0ed54e5a9d83872e835dd",
        "files": [
          "wiretap/nettrace_3gpp_32_423.c"
        ],
        "message": "nettrace_3gpp_32_423 Protect from buffer overun.\n\nBug: 11982\nChange-Id: Ib704d9128ab6427751edbf3a33f4b8fd14902562\nReviewed-on: https://code.wireshark.org/review/13233\nReviewed-by: Anders Broman <a.broman58@gmail.com>\nPetri-Dish: Anders Broman <a.broman58@gmail.com>\nTested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>\nReviewed-by: Michael Mann <mmann78@netscape.net>\n(cherry picked from commit 140aad08e081489b5cdb715cb5bca01db856fded)\nReviewed-on: https://code.wireshark.org/review/13249",
        "before_after_code_files": [
          "wiretap/nettrace_3gpp_32_423.c||wiretap/nettrace_3gpp_32_423.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "olp_code_files": {
          "patch": [
            "wiretap/nettrace_3gpp_32_423.c||wiretap/nettrace_3gpp_32_423.c"
          ],
          "candidate": [
            "wiretap/nettrace_3gpp_32_423.c||wiretap/nettrace_3gpp_32_423.c"
          ]
        }
      },
      "candidate_diff": {
        "wiretap/nettrace_3gpp_32_423.c||wiretap/nettrace_3gpp_32_423.c": [
          "File: wiretap/nettrace_3gpp_32_423.c -> wiretap/nettrace_3gpp_32_423.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "678:  packet_buf[0] = 0;",
          "",
          "[Removed Lines]",
          "676:  packet_buf = (guint8 *)g_malloc(packet_size + 12);",
          "",
          "[Added Lines]",
          "676:  packet_buf = (guint8 *)g_malloc(packet_size + 12+1);",
          "678:     packet_buf[packet_size + 12] = 0;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "932:  if (memcmp(magic_buf, xml_magic, sizeof(xml_magic)) != 0){",
          "933:   return WTAP_OPEN_NOT_MINE;",
          "934:  }",
          "936:  curr_pos = strstr(magic_buf, \"fileFormatVersion\");",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "938:  magic_buf[512 - 1] = 0;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b7dc77312720bb1bfa3698f3b48e21c991c49632",
      "candidate_info": {
        "commit_hash": "b7dc77312720bb1bfa3698f3b48e21c991c49632",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/b7dc77312720bb1bfa3698f3b48e21c991c49632",
        "files": [
          "wiretap/nettrace_3gpp_32_423.c"
        ],
        "message": "Assorted cleanups.\n\nFix indentation.\n\nJust directly assign values to elements in the packet buffer; no need to\nconvert them to numbers and note the value as a comment.\n\nGive more detail in the comment for null-terminating buffers.  Terminate\npacket_buf[] once we're finished reading into it, to make it a bit\nclearer what's being done.\n\nMake the magic number buffer 513 bytes, so we have 512 bytes plus a\nterminating null.\n\nChange-Id: Ie182d93393cc55835b24075e908393c386c85c24\nReviewed-on: https://code.wireshark.org/review/13250\nReviewed-by: Guy Harris <guy@alum.mit.edu>",
        "before_after_code_files": [
          "wiretap/nettrace_3gpp_32_423.c||wiretap/nettrace_3gpp_32_423.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "wiretap/nettrace_3gpp_32_423.c||wiretap/nettrace_3gpp_32_423.c"
          ],
          "candidate": [
            "wiretap/nettrace_3gpp_32_423.c||wiretap/nettrace_3gpp_32_423.c"
          ]
        }
      },
      "candidate_diff": {
        "wiretap/nettrace_3gpp_32_423.c||wiretap/nettrace_3gpp_32_423.c": [
          "File: wiretap/nettrace_3gpp_32_423.c -> wiretap/nettrace_3gpp_32_423.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "730:  packet_buf[0] = 0;",
          "732:  packet_buf[2] = 0;",
          "733:  packet_buf[3] = 4;",
          "737:  packet_buf[7] = 0;",
          "739:  packet_buf[8] = 0;",
          "",
          "[Removed Lines]",
          "726:  packet_buf = (guint8 *)g_malloc(packet_size + 12+1);",
          "728:     packet_buf[packet_size + 12] = 0;",
          "",
          "[Added Lines]",
          "726:  packet_buf = (guint8 *)g_malloc(packet_size + 12 + 1);",
          "729:  packet_buf[1] = EXP_PDU_TAG_PROTO_NAME;",
          "732:  packet_buf[4] = 'x';",
          "733:  packet_buf[5] = 'm';",
          "734:  packet_buf[6] = 'l';",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "741:  packet_buf[10] = 0;",
          "742:  packet_buf[11] = 0;",
          "745:  if (!wtap_read_bytes(wth->fh, packet_buf + 12, packet_size, &wrt_err, &wrt_err_info)){",
          "746:   result = WTAP_OPEN_ERROR;",
          "747:   goto end;",
          "748:  }",
          "751:  memset(&phdr, 0, sizeof(struct wtap_pkthdr));",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "748:  packet_buf[packet_size + 12] = '\\0';",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "984:  if (memcmp(magic_buf, xml_magic, sizeof(xml_magic)) != 0){",
          "985:   return WTAP_OPEN_NOT_MINE;",
          "986:  }",
          "990:  curr_pos = strstr(magic_buf, \"fileFormatVersion\");",
          "",
          "[Removed Lines]",
          "988:  magic_buf[512 - 1] = 0;",
          "",
          "[Added Lines]",
          "987:  magic_buf[512] = '\\0';",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "2d8b4a233e2c089b9736ad7ec2cea90438e6ad0f",
      "candidate_info": {
        "commit_hash": "2d8b4a233e2c089b9736ad7ec2cea90438e6ad0f",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/2d8b4a233e2c089b9736ad7ec2cea90438e6ad0f",
        "files": [
          "wiretap/CMakeLists.txt",
          "wiretap/Makefile.common",
          "wiretap/file_access.c",
          "wiretap/nettrace_3gpp_32_423.c",
          "wiretap/nettrace_3gpp_32_423.h",
          "wiretap/wtap.h"
        ],
        "message": "Add the abillity to read 3GPP trace records with format accoding to TS 32 423(XML)\n\nChange-Id: I37895ec35797089a32c7d1695e735046d6aa979e\nReviewed-on: https://code.wireshark.org/review/8237\nPetri-Dish: Anders Broman <a.broman58@gmail.com>\nTested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>\nReviewed-by: Anders Broman <a.broman58@gmail.com>",
        "before_after_code_files": [
          "wiretap/Makefile.common||wiretap/Makefile.common",
          "wiretap/file_access.c||wiretap/file_access.c",
          "wiretap/nettrace_3gpp_32_423.c||wiretap/nettrace_3gpp_32_423.c",
          "wiretap/nettrace_3gpp_32_423.h||wiretap/nettrace_3gpp_32_423.h",
          "wiretap/wtap.h||wiretap/wtap.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "wiretap/nettrace_3gpp_32_423.c||wiretap/nettrace_3gpp_32_423.c"
          ],
          "candidate": [
            "wiretap/nettrace_3gpp_32_423.c||wiretap/nettrace_3gpp_32_423.c"
          ]
        }
      },
      "candidate_diff": {
        "wiretap/Makefile.common||wiretap/Makefile.common": [
          "File: wiretap/Makefile.common -> wiretap/Makefile.common",
          "--- Hunk 1 ---",
          "[Context before]",
          "65:  netscaler.c  \\",
          "66:  netscreen.c  \\",
          "67:  nettl.c   \\",
          "68:  network_instruments.c \\",
          "69:  netxray.c  \\",
          "70:  ngsniffer.c  \\",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "68:  nettrace_3gpp_32_423.c \\",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "125:  netscreen.h  \\",
          "126:  netscaler.h  \\",
          "127:  nettl.h   \\",
          "128:  network_instruments.h \\",
          "129:  netxray.h  \\",
          "130:  ngsniffer.h  \\",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "129:  nettrace_3gpp_32_423.h \\",
          "",
          "---------------"
        ],
        "wiretap/file_access.c||wiretap/file_access.c": [
          "File: wiretap/file_access.c -> wiretap/file_access.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "89: #include \"stanag4607.h\"",
          "90: #include \"capsa.h\"",
          "91: #include \"pcap-encap.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "92: #include \"nettrace_3gpp_32_423.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "340:  { \"InfoVista 5View capture\",                OPEN_INFO_MAGIC,     _5views_open,             NULL,       NULL, NULL },",
          "341:  { \"Network Instruments Observer\",           OPEN_INFO_MAGIC,     network_instruments_open, NULL,       NULL, NULL },",
          "342:  { \"WildPackets tagged\",                     OPEN_INFO_MAGIC,     peektagged_open,          NULL,       NULL, NULL },",
          "344:  { \"DBS Etherwatch (VMS)\",                   OPEN_INFO_MAGIC,     dbs_etherwatch_open,      NULL,       NULL, NULL },",
          "345:  { \"Tektronix K12xx 32-bit .rf5 format\",     OPEN_INFO_MAGIC,     k12_open,                 NULL,       NULL, NULL },",
          "346:  { \"Catapult DCT2000 trace (.out format)\",   OPEN_INFO_MAGIC,     catapult_dct2000_open,    NULL,       NULL, NULL },",
          "",
          "[Removed Lines]",
          "343:  { \"Colasoft Capsa\",                         OPEN_INFO_MAGIC,     capsa_open,          NULL,       NULL, NULL },",
          "",
          "[Added Lines]",
          "344:  { \"Colasoft Capsa\",                         OPEN_INFO_MAGIC,     capsa_open,               NULL,       NULL, NULL },",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "348:  { \"Symbian OS btsnoop\",                     OPEN_INFO_MAGIC,     btsnoop_open,             \"log\",      NULL, NULL },",
          "349:  { \"EyeSDN USB S0/E1 ISDN trace format\",     OPEN_INFO_MAGIC,     eyesdn_open,              NULL,       NULL, NULL },",
          "350:  { \"Transport-Neutral Encapsulation Format\", OPEN_INFO_MAGIC,     tnef_open,                NULL,       NULL, NULL },",
          "351:  { \"MIME Files Format\",                      OPEN_INFO_MAGIC,     mime_file_open,           NULL,       NULL, NULL },",
          "352:  { \"Novell LANalyzer\",                       OPEN_INFO_HEURISTIC, lanalyzer_open,           \"tr1\",      NULL, NULL },",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "353:  { \"3GPP Nettrace 32 423 Format\",            OPEN_INFO_MAGIC,     nettrace_3gpp_32_423_file_open, NULL, NULL, NULL },",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1598:  { \"NetScaler Trace (Version 3.5)\", \"nstrace35\", \"cap\", NULL,",
          "1599:    TRUE, FALSE, 0,",
          "1600:    nstrace_35_dump_can_write_encap, nstrace_dump_open, NULL },",
          "1601: };",
          "1603: gint wtap_num_file_types_subtypes = sizeof(dump_open_table_base) / sizeof(struct file_type_subtype_info);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1606:  { \"Nettrace 3GPP 32 423\", \"nettrace3gpp324423\", NULL, NULL,",
          "1607:    FALSE, FALSE, 0,",
          "1608:    NULL, NULL, NULL },",
          "",
          "---------------"
        ],
        "wiretap/nettrace_3gpp_32_423.c||wiretap/nettrace_3gpp_32_423.c": [
          "File: wiretap/nettrace_3gpp_32_423.c -> wiretap/nettrace_3gpp_32_423.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "23: #include \"config.h\"",
          "25: #ifdef HAVE_SYS_TYPES_H",
          "26: #include <sys/types.h>",
          "27: #endif",
          "29: #ifdef HAVE_UNISTD_H",
          "30: #include <unistd.h>",
          "31: #endif",
          "33: #include <errno.h>",
          "34: #include <stdlib.h>",
          "35: #include <string.h>",
          "36: #include <time.h>",
          "38: #include \"wtap-int.h\"",
          "39: #include \"file_wrappers.h\"",
          "40: #include \"pcap-encap.h\"",
          "42: #include <wsutil/buffer.h>",
          "43: #include \"wsutil/tempfile.h\"",
          "44: #include \"wsutil/os_version_info.h\"",
          "45: #include \"wsutil/ws_version_info.h\"",
          "46: #include \"wsutil/str_util.h\"",
          "49: #include \"pcapng.h\"",
          "50: #include \"nettrace_3gpp_32_423.h\"",
          "60: #define MAX_FILE_SIZE (G_MAXINT-12)",
          "62: static const guint8 xml_magic[] = { '<', '?', 'x', 'm', 'l' };",
          "63: static const guint8 Threegpp_doc_no[] = { '3', '2', '.', '4', '2', '3' };",
          "65: typedef struct nettrace_3gpp_32_423_file_info {",
          "66:  char *tmpname;",
          "67:  wtap *wth_tmp_file;",
          "68: } nettrace_3gpp_32_423_file_info_t;",
          "71: static gboolean",
          "72: nettrace_read(wtap *wth, int *err, gchar **err_info, gint64 *data_offset)",
          "73: {",
          "74:  struct Buffer               *frame_buffer_saved;",
          "75:  gboolean result;",
          "77:  nettrace_3gpp_32_423_file_info_t *file_info = (nettrace_3gpp_32_423_file_info_t *)wth->priv;",
          "79:  frame_buffer_saved = file_info->wth_tmp_file->frame_buffer;",
          "80:  file_info->wth_tmp_file->frame_buffer = wth->frame_buffer;",
          "82:  result =  wtap_read(file_info->wth_tmp_file, err, err_info, data_offset);",
          "83:  file_info->wth_tmp_file->frame_buffer = frame_buffer_saved;",
          "84:  if (!result)",
          "85:   return result;",
          "86:  wth->phdr.rec_type = file_info->wth_tmp_file->phdr.rec_type;",
          "87:  wth->phdr.presence_flags = file_info->wth_tmp_file->phdr.presence_flags;",
          "88:  wth->phdr.ts = file_info->wth_tmp_file->phdr.ts;",
          "89:  wth->phdr.caplen = file_info->wth_tmp_file->phdr.caplen;",
          "90:  wth->phdr.len = file_info->wth_tmp_file->phdr.len;",
          "91:  wth->phdr.pkt_encap = file_info->wth_tmp_file->phdr.pkt_encap;",
          "92:  wth->phdr.pkt_tsprec = file_info->wth_tmp_file->phdr.pkt_tsprec;",
          "93:  wth->phdr.interface_id = file_info->wth_tmp_file->phdr.interface_id;",
          "94:  wth->phdr.opt_comment = file_info->wth_tmp_file->phdr.opt_comment;",
          "95:  wth->phdr.drop_count = file_info->wth_tmp_file->phdr.drop_count;",
          "96:  wth->phdr.pack_flags = file_info->wth_tmp_file->phdr.pack_flags;",
          "97:  wth->phdr.ft_specific_data = file_info->wth_tmp_file->phdr.ft_specific_data;",
          "99:  return result;",
          "100: }",
          "102: static gboolean",
          "103: nettrace_seek_read(wtap *wth, gint64 seek_off, struct wtap_pkthdr *phdr, Buffer *buf, int *err, gchar **err_info)",
          "104: {",
          "105:  struct Buffer               *frame_buffer_saved;",
          "106:  gboolean result;",
          "107:  nettrace_3gpp_32_423_file_info_t *file_info = (nettrace_3gpp_32_423_file_info_t *)wth->priv;",
          "109:  frame_buffer_saved = file_info->wth_tmp_file->frame_buffer;",
          "110:  file_info->wth_tmp_file->frame_buffer = wth->frame_buffer;",
          "112:  result = wtap_seek_read(file_info->wth_tmp_file, seek_off, phdr, buf, err, err_info);",
          "113:  file_info->wth_tmp_file->frame_buffer = frame_buffer_saved;",
          "115:  return result;",
          "116: }",
          "119: static void",
          "120: nettrace_close(wtap *wth)",
          "121: {",
          "122:  nettrace_3gpp_32_423_file_info_t *file_info = (nettrace_3gpp_32_423_file_info_t *)wth->priv;",
          "124:  wtap_close(file_info->wth_tmp_file);",
          "127:  wth->shb_hdr.opt_comment = NULL;",
          "128:  wth->shb_hdr.shb_hardware = NULL;",
          "129:  wth->shb_hdr.shb_os = NULL;",
          "130:  wth->shb_hdr.shb_user_appl = NULL;",
          "133:  ws_unlink(file_info->tmpname);",
          "135: }",
          "144: static wtap_open_return_val",
          "145: write_packet_data(wtap_dumper *wdh, struct wtap_pkthdr *phdr, int *err, gchar **err_info, guint8 *file_buf)",
          "146: {",
          "147:  char *curr_pos, *next_pos;",
          "148:  char proto_name_str[16];",
          "149:  int tag_str_len = 0;",
          "150:  int proto_str_len, raw_data_len, pkt_data_len,  exp_pdu_tags_len, i, j;",
          "151:  guint8 *packet_buf;",
          "152:  gchar chr;",
          "153:  gint val1, val2;",
          "155:  memset(proto_name_str, 0, sizeof(proto_name_str));",
          "157:  curr_pos = strstr(file_buf, \"protocol=\\\"\");",
          "158:  if (!curr_pos){",
          "159:   return WTAP_OPEN_ERROR;",
          "160:  }",
          "161:  curr_pos = curr_pos + 10;",
          "162:  next_pos = strstr(curr_pos, \"\\\"\");",
          "163:  proto_str_len = (int)(next_pos - curr_pos);",
          "164:  if (proto_str_len > 15){",
          "165:   return WTAP_OPEN_ERROR;",
          "166:  }",
          "168:  g_strlcpy(proto_name_str, curr_pos, proto_str_len+1);",
          "169:  ascii_strdown_inplace(proto_name_str);",
          "172:  if (strcmp(proto_name_str, \"gtpv2-c\") == 0){",
          "174:   proto_name_str[5] = '\\0';",
          "175:   proto_name_str[6] = '\\0';",
          "176:   proto_str_len = 5;",
          "177:  }",
          "179:  if (strcmp(proto_name_str, \"nas\") == 0){",
          "181:   g_strlcpy(proto_name_str, \"nas-eps_plain\", 14);",
          "182:   proto_name_str[13] = '\\0';",
          "183:   proto_str_len = 13;",
          "184:  }",
          "186:  curr_pos = strstr(next_pos, \">\") + 1;",
          "187:  next_pos = strstr(next_pos, \"<\");",
          "189:  raw_data_len = (int)(next_pos - curr_pos);",
          "192:  tag_str_len = (proto_str_len + 3) & 0xfffffffc;",
          "193:  exp_pdu_tags_len = tag_str_len + 4;",
          "197:  pkt_data_len = raw_data_len / 2;",
          "198:  packet_buf = (guint8 *)g_malloc0(pkt_data_len + exp_pdu_tags_len +4);",
          "201:  packet_buf[0] = 0;",
          "203:  packet_buf[2] = 0;",
          "204:  packet_buf[3] = tag_str_len;",
          "205:  i = 4;",
          "206:  for (i = 4, j = 0; j < tag_str_len; i++, j++){",
          "207:   packet_buf[i] = proto_name_str[j];",
          "208:  }",
          "211:  packet_buf[i] = 0;",
          "212:  i++;",
          "213:  packet_buf[i] = 0;",
          "214:  i++;",
          "215:  packet_buf[i] = 0;",
          "216:  i++;",
          "217:  packet_buf[i] = 0;",
          "218:  i++;",
          "219:  exp_pdu_tags_len = exp_pdu_tags_len + 4;",
          "222:  for (; i < (pkt_data_len + exp_pdu_tags_len); i++){",
          "223:   chr = *curr_pos;",
          "224:   val1 = g_ascii_xdigit_value(chr);",
          "225:   curr_pos++;",
          "226:   chr = *curr_pos;",
          "227:   val2 = g_ascii_xdigit_value(chr);",
          "228:   if ((val1 != -1) && (val2 != -1)){",
          "229:    packet_buf[i] = ((guint8)val1 * 16) + val2;",
          "230:   }",
          "231:   else{",
          "233:    g_free(packet_buf);",
          "234:    return WTAP_OPEN_ERROR;",
          "235:   }",
          "236:   curr_pos++;",
          "237:  }",
          "239:  memset(phdr, 0, sizeof(struct wtap_pkthdr));",
          "240:  phdr->rec_type = REC_TYPE_PACKET;",
          "243:  phdr->caplen = pkt_data_len + exp_pdu_tags_len;",
          "244:  phdr->len = pkt_data_len + exp_pdu_tags_len;",
          "246:  phdr->ts.secs = 0;",
          "247:  phdr->ts.nsecs = 0;",
          "249:  if (!wtap_dump(wdh, phdr, packet_buf, err, err_info)) {",
          "250:   switch (*err) {",
          "252:   case WTAP_ERR_UNWRITABLE_REC_DATA:",
          "253:    g_free(err_info);",
          "254:    break;",
          "256:   default:",
          "257:    break;",
          "258:   }",
          "259:   g_free(packet_buf);",
          "260:   return WTAP_OPEN_ERROR;",
          "261:  }",
          "263:  g_free(packet_buf);",
          "264:  return WTAP_OPEN_MINE;",
          "265: }",
          "272: static wtap_open_return_val",
          "273: create_temp_pcapng_file(wtap *wth, int *err, gchar **err_info, nettrace_3gpp_32_423_file_info_t *file_info)",
          "274: {",
          "275:  int import_file_fd;",
          "276:  wtap_dumper* wdh_exp_pdu;",
          "277:  int   exp_pdu_file_err;",
          "280:  wtapng_section_t            *shb_hdr;",
          "281:  wtapng_iface_descriptions_t *idb_inf;",
          "282:  wtapng_if_descr_t            int_data;",
          "283:  GString                     *os_info_str;",
          "284:  char                        *appname;",
          "285:  gint64 file_size;",
          "286:  int packet_size;",
          "287:  guint8 *packet_buf;",
          "288:  int wrt_err;",
          "289:  gchar *wrt_err_info;",
          "290:  struct wtap_pkthdr phdr;",
          "292:  gboolean random = FALSE;",
          "293:  char *curr_pos, *next_pos;",
          "295:  import_file_fd = create_tempfile(&(file_info->tmpname), \"Wireshark_PDU_\");",
          "299:  os_info_str = g_string_new(\"\");",
          "300:  get_os_version_info(os_info_str);",
          "302:  appname = g_strdup_printf(\"Wireshark %s\", get_ws_vcs_version_info());",
          "304:  shb_hdr = g_new(wtapng_section_t, 1);",
          "305:  shb_hdr->section_length = -1;",
          "307:  shb_hdr->opt_comment = g_strdup_printf(\"File converted to Exported PDU format during opening\");",
          "312:  shb_hdr->shb_hardware = NULL;",
          "317:  shb_hdr->shb_os = g_string_free(os_info_str, FALSE);",
          "322:  shb_hdr->shb_user_appl = appname;",
          "325:  idb_inf = g_new(wtapng_iface_descriptions_t, 1);",
          "326:  idb_inf->interface_data = g_array_new(FALSE, FALSE, sizeof(wtapng_if_descr_t));",
          "329:  int_data.wtap_encap = WTAP_ENCAP_WIRESHARK_UPPER_PDU;",
          "331:  int_data.link_type = wtap_wtap_encap_to_pcap_encap(WTAP_ENCAP_WIRESHARK_UPPER_PDU);",
          "332:  int_data.snap_len = WTAP_MAX_PACKET_SIZE;",
          "333:  int_data.if_name = g_strdup(\"Fake IF\");",
          "334:  int_data.opt_comment = NULL;",
          "335:  int_data.if_description = NULL;",
          "336:  int_data.if_speed = 0;",
          "337:  int_data.if_tsresol = 6;",
          "338:  int_data.if_filter_str = NULL;",
          "339:  int_data.bpf_filter_len = 0;",
          "340:  int_data.if_filter_bpf_bytes = NULL;",
          "341:  int_data.if_os = NULL;",
          "342:  int_data.if_fcslen = -1;",
          "344:  int_data.interface_statistics = NULL;",
          "346:  g_array_append_val(idb_inf->interface_data, int_data);",
          "348:  wdh_exp_pdu = wtap_dump_fdopen_ng(import_file_fd, WTAP_FILE_TYPE_SUBTYPE_PCAPNG, WTAP_ENCAP_WIRESHARK_UPPER_PDU, WTAP_MAX_PACKET_SIZE, FALSE, shb_hdr, idb_inf, &exp_pdu_file_err);",
          "349:  if (wdh_exp_pdu == NULL) {",
          "350:   return WTAP_OPEN_ERROR;",
          "351:  }",
          "353:  g_free(shb_hdr);",
          "354:  g_free(appname);",
          "358:  if ((file_size = wtap_file_size(wth, err)) == -1)",
          "359:   return WTAP_OPEN_ERROR;",
          "361:  if (file_size > MAX_FILE_SIZE) {",
          "368:    file_size, MAX_FILE_SIZE);",
          "369:   return WTAP_OPEN_ERROR;",
          "370:  }",
          "371:  packet_size = (int)file_size;",
          "378:  packet_buf = (guint8 *)g_malloc(packet_size + 12);",
          "380:  packet_buf[0] = 0;",
          "382:  packet_buf[2] = 0;",
          "383:  packet_buf[3] = 4;",
          "387:  packet_buf[7] = 0;",
          "389:  packet_buf[8] = 0;",
          "390:  packet_buf[9] = 0;",
          "391:  packet_buf[10] = 0;",
          "392:  packet_buf[11] = 0;",
          "395:  if (!wtap_read_bytes(wth->fh, packet_buf + 12, packet_size, &wrt_err, &wrt_err_info)){",
          "396:   return WTAP_OPEN_ERROR;",
          "397:  }",
          "400:  memset(&phdr, 0, sizeof(struct wtap_pkthdr));",
          "401:  phdr.rec_type = REC_TYPE_PACKET;",
          "404:  phdr.caplen = packet_size + 12;",
          "405:  phdr.len = packet_size + 12;",
          "407:  phdr.ts.secs = 0;",
          "408:  phdr.ts.nsecs = 0;",
          "411:  if (!wtap_dump(wdh_exp_pdu, &phdr, packet_buf, &wrt_err, &wrt_err_info)) {",
          "412:   switch (wrt_err) {",
          "414:   case WTAP_ERR_UNWRITABLE_REC_DATA:",
          "415:    g_free(wrt_err_info);",
          "416:    break;",
          "418:   default:",
          "419:    break;",
          "420:   }",
          "421:   g_free(packet_buf);",
          "422:   return WTAP_OPEN_ERROR;",
          "423:  }",
          "426:  curr_pos = packet_buf + 12;",
          "428:  while ((curr_pos = strstr(curr_pos, \"<msg\")) != NULL){",
          "429:   wtap_open_return_val temp_val;",
          "431:   curr_pos = curr_pos + 4;",
          "432:   next_pos = strstr(curr_pos, \"</msg>\");",
          "433:   if (!next_pos){",
          "435:    break;",
          "436:   }",
          "437:   next_pos = next_pos + 6;",
          "439:   curr_pos = strstr(curr_pos, \"<rawMsg\");",
          "440:   if (!curr_pos){",
          "442:    curr_pos = next_pos;",
          "443:    continue;",
          "444:   }",
          "445:   curr_pos = curr_pos + 7;",
          "447:   temp_val = write_packet_data(wdh_exp_pdu, &phdr, &wrt_err, &wrt_err_info, curr_pos);",
          "448:   if (temp_val != WTAP_OPEN_MINE){",
          "449:    g_free(packet_buf);",
          "450:    return temp_val;",
          "451:   }",
          "452:   curr_pos = next_pos;",
          "453:  }",
          "456:  if (!wtap_dump_close(wdh_exp_pdu, err)){",
          "457:   g_free(packet_buf);",
          "458:   return WTAP_OPEN_ERROR;",
          "459:  }",
          "461:  g_free(packet_buf);",
          "465:  if (wth->random_fh){",
          "466:   random = TRUE;",
          "467:  }",
          "468:  file_info->wth_tmp_file =",
          "469:   wtap_open_offline(file_info->tmpname, WTAP_TYPE_AUTO, err, err_info, random);",
          "471:  if (!file_info->wth_tmp_file){",
          "472:   return WTAP_OPEN_ERROR;",
          "473:  }",
          "475:  return WTAP_OPEN_MINE;",
          "476: }",
          "478: wtap_open_return_val",
          "479: nettrace_3gpp_32_423_file_open(wtap *wth, int *err, gchar **err_info)",
          "480: {",
          "482:  int bytes_read;",
          "483:  char *curr_pos;",
          "484:  nettrace_3gpp_32_423_file_info_t *file_info;",
          "485:  wtap_open_return_val temp_val;",
          "488:  bytes_read = file_read(magic_buf, 512, wth->fh);",
          "490:  if (bytes_read < 0) {",
          "492:   return WTAP_OPEN_ERROR;",
          "493:  }",
          "494:  if (bytes_read == 0){",
          "495:   return WTAP_OPEN_NOT_MINE;",
          "496:  }",
          "498:  if (memcmp(magic_buf, xml_magic, sizeof(xml_magic)) != 0){",
          "499:   return WTAP_OPEN_NOT_MINE;",
          "500:  }",
          "502:  curr_pos = strstr(magic_buf, \"fileFormatVersion\");",
          "504:  if (!curr_pos){",
          "505:   return WTAP_OPEN_NOT_MINE;",
          "506:  }",
          "507:  curr_pos += 19;",
          "508:  if (memcmp(curr_pos, Threegpp_doc_no, sizeof(Threegpp_doc_no)) != 0){",
          "509:   return WTAP_OPEN_NOT_MINE;",
          "510:  }",
          "512:  if (file_seek(wth->fh, 0, SEEK_SET, err) == -1)",
          "513:   return WTAP_OPEN_ERROR;",
          "516:  file_info = g_new0(nettrace_3gpp_32_423_file_info_t, 1);",
          "517:  temp_val = create_temp_pcapng_file(wth, err, err_info, file_info);",
          "519:  if (temp_val != WTAP_OPEN_MINE){",
          "520:   return temp_val;",
          "521:  }",
          "523:  if (file_seek(wth->fh, 0, SEEK_SET, err) == -1)",
          "524:   return WTAP_OPEN_ERROR;",
          "527:  wth->shb_hdr.opt_comment = file_info->wth_tmp_file->shb_hdr.opt_comment;",
          "528:  wth->shb_hdr.shb_hardware = file_info->wth_tmp_file->shb_hdr.shb_hardware;",
          "529:  wth->shb_hdr.shb_os = file_info->wth_tmp_file->shb_hdr.shb_os;",
          "530:  wth->shb_hdr.shb_user_appl = file_info->wth_tmp_file->shb_hdr.shb_user_appl;",
          "532:  wth->file_type_subtype = WTAP_FILE_TYPE_SUBTYPE_NETTRACE_3GPP_32_423;",
          "533:  wth->file_encap = file_info->wth_tmp_file->file_encap;",
          "534:  wth->file_tsprec = file_info->wth_tmp_file->file_tsprec;",
          "535:  wth->subtype_read = nettrace_read;",
          "536:  wth->subtype_seek_read = nettrace_seek_read;",
          "537:  wth->subtype_close = nettrace_close;",
          "538:  wth->snapshot_length = 0;",
          "540:  wth->priv = (void*)file_info;",
          "542:  return WTAP_OPEN_MINE;",
          "544: }",
          "",
          "---------------"
        ],
        "wiretap/nettrace_3gpp_32_423.h||wiretap/nettrace_3gpp_32_423.h": [
          "File: wiretap/nettrace_3gpp_32_423.h -> wiretap/nettrace_3gpp_32_423.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "21: #ifndef __NETTRACE_3GPP_32_423__",
          "22: #define __NETTRACE_3GPP_32_423__",
          "24: #include <glib.h>",
          "25: #include <wtap.h>",
          "27: wtap_open_return_val nettrace_3gpp_32_423_file_open(wtap *wth, int *err, gchar **err_info);",
          "29: #endif",
          "",
          "---------------"
        ],
        "wiretap/wtap.h||wiretap/wtap.h": [
          "File: wiretap/wtap.h -> wiretap/wtap.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "352: #define WTAP_FILE_TYPE_SUBTYPE_COLASOFT_PACKET_BUILDER       76",
          "353: #define WTAP_FILE_TYPE_SUBTYPE_JSON                          77",
          "354: #define WTAP_FILE_TYPE_SUBTYPE_NETSCALER_3_5                 78",
          "356: #define WTAP_NUM_FILE_TYPES_SUBTYPES  wtap_get_num_file_types_subtypes()",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "355: #define WTAP_FILE_TYPE_SUBTYPE_NETTRACE_3GPP_32_423          79",
          "",
          "---------------"
        ]
      }
    }
  ]
}
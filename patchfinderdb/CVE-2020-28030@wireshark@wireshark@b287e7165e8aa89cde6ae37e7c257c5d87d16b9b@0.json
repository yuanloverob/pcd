{
  "cve_id": "CVE-2020-28030",
  "cve_desc": "In Wireshark 3.2.0 to 3.2.7, the GQUIC dissector could crash. This was addressed in epan/dissectors/packet-gquic.c by correcting the implementation of offset advancement.",
  "repo": "wireshark/wireshark",
  "patch_hash": "b287e7165e8aa89cde6ae37e7c257c5d87d16b9b",
  "patch_info": {
    "commit_hash": "b287e7165e8aa89cde6ae37e7c257c5d87d16b9b",
    "repo": "wireshark/wireshark",
    "commit_url": "https://github.com/wireshark/wireshark/commit/b287e7165e8aa89cde6ae37e7c257c5d87d16b9b",
    "files": [
      "epan/dissectors/packet-gquic.c"
    ],
    "message": "GQUIC: make sure our tag offset advances.\n\nMake sure gquic tag offset advances so that we don't infinitely loop.",
    "before_after_code_files": [
      "epan/dissectors/packet-gquic.c||epan/dissectors/packet-gquic.c"
    ]
  },
  "patch_diff": {
    "epan/dissectors/packet-gquic.c||epan/dissectors/packet-gquic.c": [
      "File: epan/dissectors/packet-gquic.c -> epan/dissectors/packet-gquic.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "198: static expert_field ei_gquic_tag_unknown = EI_INIT;",
      "199: static expert_field ei_gquic_version_invalid = EI_INIT;",
      "200: static expert_field ei_gquic_invalid_parameter = EI_INIT;",
      "202: static const value_string gquic_short_long_header_vals[] = {",
      "203:     { 0, \"Short Header\" },",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "201: static expert_field ei_gquic_length_invalid = EI_INIT;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1660:                                  \"Dissector for (Google) QUIC Tag\"",
      "1661:                                  \" %s (%s) code not implemented, Contact\"",
      "1662:                                  \" Wireshark developers if you want this supported\", tvb_get_string_enc(wmem_packet_scope(), tvb, offset-8, 4, ENC_ASCII|ENC_NA), val_to_str(tag, tag_vals, \"Unknown\"));",
      "1664:             break;",
      "1665:         }",
      "1666:         if(tag_offset != offset_end){",
      "",
      "[Removed Lines]",
      "1663:                 tag_offset += tag_len;",
      "",
      "[Added Lines]",
      "1664:                 goto end;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1672:         tag_number--;",
      "1673:     }",
      "1674:     return offset + total_tag_len;",
      "1676: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1676:     end:",
      "1677:     if (offset + total_tag_len <= offset) {",
      "1678:         expert_add_info_format(pinfo, gquic_tree, &ei_gquic_length_invalid,",
      "1679:                                 \"Invalid total tag length: %u\", total_tag_len);",
      "1680:         return offset + tvb_reported_length_remaining(tvb, offset);",
      "1681:     }",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "3173:         { &ei_gquic_tag_length, { \"gquic.tag.length.truncated\", PI_MALFORMED, PI_NOTE, \"Truncated Tag Length...\", EXPFILL }},",
      "3174:         { &ei_gquic_tag_unknown, { \"gquic.tag.unknown.data\", PI_UNDECODED, PI_NOTE, \"Unknown Data\", EXPFILL }},",
      "3175:         { &ei_gquic_version_invalid, { \"gquic.version.invalid\", PI_MALFORMED, PI_ERROR, \"Invalid Version\", EXPFILL }},",
      "3177:     };",
      "3179:     expert_module_t *expert_gquic;",
      "",
      "[Removed Lines]",
      "3176:         { &ei_gquic_invalid_parameter, { \"gquic.invalid.parameter\", PI_MALFORMED, PI_ERROR, \"Invalid Parameter\", EXPFILL }}",
      "",
      "[Added Lines]",
      "3184:         { &ei_gquic_invalid_parameter, { \"gquic.invalid.parameter\", PI_MALFORMED, PI_ERROR, \"Invalid Parameter\", EXPFILL }},",
      "3185:         { &ei_gquic_length_invalid, { \"gquic.length.invalid\", PI_PROTOCOL, PI_WARN, \"Invalid Length\", EXPFILL }}",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "36a0c486b3d8eaeb3dfd377c3a66fa1c39826b54",
      "candidate_info": {
        "commit_hash": "36a0c486b3d8eaeb3dfd377c3a66fa1c39826b54",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/36a0c486b3d8eaeb3dfd377c3a66fa1c39826b54",
        "files": [
          "epan/dissectors/packet-gquic.c"
        ],
        "message": "GQUIC: make sure our tag offset advances.\n\nMake sure gquic tag offset advances so that we don't infinitely loop.\n\n(cherry picked from commit b287e7165e8aa89cde6ae37e7c257c5d87d16b9b)",
        "before_after_code_files": [
          "epan/dissectors/packet-gquic.c||epan/dissectors/packet-gquic.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "epan/dissectors/packet-gquic.c||epan/dissectors/packet-gquic.c"
          ],
          "candidate": [
            "epan/dissectors/packet-gquic.c||epan/dissectors/packet-gquic.c"
          ]
        }
      },
      "candidate_diff": {
        "epan/dissectors/packet-gquic.c||epan/dissectors/packet-gquic.c": [
          "File: epan/dissectors/packet-gquic.c -> epan/dissectors/packet-gquic.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "185: static expert_field ei_gquic_tag_length = EI_INIT;",
          "186: static expert_field ei_gquic_tag_unknown = EI_INIT;",
          "187: static expert_field ei_gquic_version_invalid = EI_INIT;",
          "190: typedef struct gquic_info_data {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "188: static expert_field ei_gquic_length_invalid = EI_INIT;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1619:                                  \"Dissector for (Google) QUIC Tag\"",
          "1620:                                  \" %s (%s) code not implemented, Contact\"",
          "1621:                                  \" Wireshark developers if you want this supported\", tvb_get_string_enc(wmem_packet_scope(), tvb, offset-8, 4, ENC_ASCII|ENC_NA), val_to_str(tag, tag_vals, \"Unknown\"));",
          "1623:             break;",
          "1624:         }",
          "1625:         if(tag_offset != offset_end){",
          "",
          "[Removed Lines]",
          "1622:                 tag_offset += tag_len;",
          "",
          "[Added Lines]",
          "1623:                 goto end;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1631:         tag_number--;",
          "1632:     }",
          "1633:     return offset + total_tag_len;",
          "1635: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1635:     end:",
          "1636:     if (offset + total_tag_len <= offset) {",
          "1637:         expert_add_info_format(pinfo, gquic_tree, &ei_gquic_length_invalid,",
          "1638:                                 \"Invalid total tag length: %u\", total_tag_len);",
          "1639:         return offset + tvb_reported_length_remaining(tvb, offset);",
          "1640:     }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2887:         { &ei_gquic_tag_undecoded, { \"gquic.tag.undecoded\", PI_UNDECODED, PI_NOTE, \"Dissector for (Google)QUIC Tag code not implemented, Contact Wireshark developers if you want this supported\", EXPFILL }},",
          "2888:         { &ei_gquic_tag_length, { \"gquic.tag.length.truncated\", PI_MALFORMED, PI_NOTE, \"Truncated Tag Length...\", EXPFILL }},",
          "2889:         { &ei_gquic_tag_unknown, { \"gquic.tag.unknown.data\", PI_UNDECODED, PI_NOTE, \"Unknown Data\", EXPFILL }},",
          "2891:     };",
          "2893:     expert_module_t *expert_gquic;",
          "",
          "[Removed Lines]",
          "2890:         { &ei_gquic_version_invalid, { \"gquic.version.invalid\", PI_MALFORMED, PI_ERROR, \"Invalid Version\", EXPFILL }}",
          "",
          "[Added Lines]",
          "2898:         { &ei_gquic_version_invalid, { \"gquic.version.invalid\", PI_MALFORMED, PI_ERROR, \"Invalid Version\", EXPFILL }},",
          "2899:         { &ei_gquic_length_invalid, { \"gquic.length.invalid\", PI_PROTOCOL, PI_WARN, \"Invalid Length\", EXPFILL }}",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "0de80702bd3d542c73e311939ac3da9b4dc2069b",
      "candidate_info": {
        "commit_hash": "0de80702bd3d542c73e311939ac3da9b4dc2069b",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/0de80702bd3d542c73e311939ac3da9b4dc2069b",
        "files": [
          "epan/dissectors/packet-gquic.c"
        ],
        "message": "GQUIC: fix parsing of unknown (but valid) tags\n\nThis commit should be a proper fix for the regression reported in #17250\n(7fd71536 is a simple workaround). Such regression has been introduced by\nb287e716 while fixing the infinite loop reported in #16897.\n\nb287e716, while fixing the infinite loop, broke the decoding of perfectly\nvalid tags not yet supported by Wireshark.\n\nAFAIK, the root cause of the infinite loop is the overflow of the `offset`\nvariable. Therefore checking for this overflow should be sufficient to avoid\nthe loop.\nNote that we already check for sensible values for the 'tag_len' variable;\nwe should update `total_tag_len` accordingly.\n\nSome words about testing: other than correctly handling unknown but valid\ntags, it is important that this commit doesn't reintroduce the infinite\nloop bug.\nFortunately #16897 provided a POC trace. Unfortunately, if you revert\nb287e716, this POC doesn't work anymore in master-3.4 and master branches,\nbut it still triggers the infinite loop in master-3.2 branch.\nTherefore I have been able to manually check that this MR + the\noverflow check is enough to avoid the infinite loop bug, at least in master-3.2.\n\nSome traffic with unknown but valid tags is available in e2ee14ae03.\n\n\n(cherry picked from commit 142cfb03ac5d0473d70f3e8adeabdc4f4496e953)",
        "before_after_code_files": [
          "epan/dissectors/packet-gquic.c||epan/dissectors/packet-gquic.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "epan/dissectors/packet-gquic.c||epan/dissectors/packet-gquic.c"
          ],
          "candidate": [
            "epan/dissectors/packet-gquic.c||epan/dissectors/packet-gquic.c"
          ]
        }
      },
      "candidate_diff": {
        "epan/dissectors/packet-gquic.c||epan/dissectors/packet-gquic.c": [
          "File: epan/dissectors/packet-gquic.c -> epan/dissectors/packet-gquic.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1411:         offset_end = tvb_get_guint32(tvb, offset, ENC_LITTLE_ENDIAN);",
          "1413:         tag_len = offset_end - tag_offset;",
          "1415:         ti_len = proto_tree_add_uint(tag_tree, hf_gquic_tag_length, tvb, offset, 4, tag_len);",
          "1416:         proto_item_append_text(ti_tag, \" (l=%u)\", tag_len);",
          "1417:         proto_item_set_generated(ti_len);",
          "",
          "[Removed Lines]",
          "1414:         total_tag_len += tag_len;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1424:             expert_add_info(pinfo, ti_len, &ei_gquic_tag_length);",
          "1425:         }",
          "1427:         proto_tree_add_item(tag_tree, hf_gquic_tag_value, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);",
          "1429:         switch(tag){",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1426:         total_tag_len += tag_len;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1684:                                  \"Dissector for (Google) QUIC Tag\"",
          "1685:                                  \" %s (%s) code not implemented, Contact\"",
          "1686:                                  \" Wireshark developers if you want this supported\", tvb_get_string_enc(wmem_packet_scope(), tvb, offset-8, 4, ENC_ASCII|ENC_NA), val_to_str(tag, tag_vals, \"Unknown\"));",
          "1688:             break;",
          "1689:         }",
          "1690:         if(tag_offset != offset_end){",
          "",
          "[Removed Lines]",
          "1687:                 goto end;",
          "",
          "[Added Lines]",
          "1688:                 tag_offset += tag_len;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1696:         tag_number--;",
          "1697:     }",
          "1700:     if (offset + total_tag_len <= offset) {",
          "1701:         expert_add_info_format(pinfo, gquic_tree, &ei_gquic_length_invalid,",
          "1702:                                 \"Invalid total tag length: %u\", total_tag_len);",
          "",
          "[Removed Lines]",
          "1699:     end:",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "142cfb03ac5d0473d70f3e8adeabdc4f4496e953",
      "candidate_info": {
        "commit_hash": "142cfb03ac5d0473d70f3e8adeabdc4f4496e953",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/142cfb03ac5d0473d70f3e8adeabdc4f4496e953",
        "files": [
          "epan/dissectors/packet-gquic.c"
        ],
        "message": "GQUIC: fix parsing of unknown (but valid) tags\n\nThis commit should be a proper fix for the regression reported in #17250\n(7fd71536 is a simple workaround). Such regression has been introduced by\nb287e716 while fixing the infinite loop reported in #16897.\n\nb287e716, while fixing the infinite loop, broke the decoding of perfectly\nvalid tags not yet supported by Wireshark.\n\nAFAIK, the root cause of the infinite loop is the overflow of the `offset`\nvariable. Therefore checking for this overflow should be sufficient to avoid\nthe loop.\nNote that we already check for sensible values for the 'tag_len' variable;\nwe should update `total_tag_len` accordingly.\n\nSome words about testing: other than correctly handling unknown but valid\ntags, it is important that this commit doesn't reintroduce the infinite\nloop bug.\nFortunately #16897 provided a POC trace. Unfortunately, if you revert\nb287e716, this POC doesn't work anymore in master-3.4 and master branches,\nbut it still triggers the infinite loop in master-3.2 branch.\nTherefore I have been able to manually check that this MR + the\noverflow check is enough to avoid the infinite loop bug, at least in master-3.2.\n\nSome traffic with unknown but valid tags is available in e2ee14ae03.",
        "before_after_code_files": [
          "epan/dissectors/packet-gquic.c||epan/dissectors/packet-gquic.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "epan/dissectors/packet-gquic.c||epan/dissectors/packet-gquic.c"
          ],
          "candidate": [
            "epan/dissectors/packet-gquic.c||epan/dissectors/packet-gquic.c"
          ]
        }
      },
      "candidate_diff": {
        "epan/dissectors/packet-gquic.c||epan/dissectors/packet-gquic.c": [
          "File: epan/dissectors/packet-gquic.c -> epan/dissectors/packet-gquic.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1417:         offset_end = tvb_get_guint32(tvb, offset, ENC_LITTLE_ENDIAN);",
          "1419:         tag_len = offset_end - tag_offset;",
          "1421:         ti_len = proto_tree_add_uint(tag_tree, hf_gquic_tag_length, tvb, offset, 4, tag_len);",
          "1422:         proto_item_append_text(ti_tag, \" (l=%u)\", tag_len);",
          "1423:         proto_item_set_generated(ti_len);",
          "",
          "[Removed Lines]",
          "1420:         total_tag_len += tag_len;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1430:             expert_add_info(pinfo, ti_len, &ei_gquic_tag_length);",
          "1431:         }",
          "1433:         proto_tree_add_item(tag_tree, hf_gquic_tag_value, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);",
          "1435:         switch(tag){",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1432:         total_tag_len += tag_len;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1703:                                  \"Dissector for (Google) QUIC Tag\"",
          "1704:                                  \" %s (%s) code not implemented, Contact\"",
          "1705:                                  \" Wireshark developers if you want this supported\", tvb_get_string_enc(wmem_packet_scope(), tvb, offset-8, 4, ENC_ASCII|ENC_NA), val_to_str(tag, tag_vals, \"Unknown\"));",
          "1707:             break;",
          "1708:         }",
          "1709:         if(tag_offset != offset_end){",
          "",
          "[Removed Lines]",
          "1706:                 goto end;",
          "",
          "[Added Lines]",
          "1707:                 tag_offset += tag_len;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1715:         tag_number--;",
          "1716:     }",
          "1719:     if (offset + total_tag_len <= offset) {",
          "1720:         expert_add_info_format(pinfo, gquic_tree, &ei_gquic_length_invalid,",
          "1721:                                 \"Invalid total tag length: %u\", total_tag_len);",
          "",
          "[Removed Lines]",
          "1718:     end:",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2017-6837",
  "cve_desc": "WAVE.cpp in Audio File Library (aka audiofile) 0.3.6 allows remote attackers to cause a denial of service (crash) via vectors related to a large number of coefficients.",
  "repo": "antlarr/audiofile",
  "patch_hash": "c48e4c6503f7dabd41f11d4c9c7b7f8960e7f2c0",
  "patch_info": {
    "commit_hash": "c48e4c6503f7dabd41f11d4c9c7b7f8960e7f2c0",
    "repo": "antlarr/audiofile",
    "commit_url": "https://github.com/antlarr/audiofile/commit/c48e4c6503f7dabd41f11d4c9c7b7f8960e7f2c0",
    "files": [
      "libaudiofile/WAVE.cpp"
    ],
    "message": "Always check the number of coefficients\n\nWhen building the library with NDEBUG, asserts are eliminated\nso it's better to always check that the number of coefficients\nis inside the array range.\n\nThis fixes the 00191-audiofile-indexoob issue in #41",
    "before_after_code_files": [
      "libaudiofile/WAVE.cpp||libaudiofile/WAVE.cpp"
    ]
  },
  "patch_diff": {
    "libaudiofile/WAVE.cpp||libaudiofile/WAVE.cpp": [
      "File: libaudiofile/WAVE.cpp -> libaudiofile/WAVE.cpp",
      "--- Hunk 1 ---",
      "[Context before]",
      "283:    assert(numCoefficients >= 7 && numCoefficients <= 255);",
      "285:    m_msadpcmNumCoefficients = numCoefficients;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "284:    if (numCoefficients < 7 || numCoefficients > 255)",
      "285:    {",
      "286:     _af_error(AF_BAD_HEADER,",
      "287:       \"Bad number of coefficients\");",
      "288:     return AF_FAIL;",
      "289:    }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "beacc44eb8cdf6d58717ec1a5103c5141f1b37f9",
      "candidate_info": {
        "commit_hash": "beacc44eb8cdf6d58717ec1a5103c5141f1b37f9",
        "repo": "antlarr/audiofile",
        "commit_url": "https://github.com/antlarr/audiofile/commit/beacc44eb8cdf6d58717ec1a5103c5141f1b37f9",
        "files": [
          "libaudiofile/modules/BlockCodec.cpp",
          "libaudiofile/modules/MSADPCM.cpp"
        ],
        "message": "Check for multiplication overflow in MSADPCM decodeSample\n\nCheck for multiplication overflow (using __builtin_mul_overflow\nif available) in MSADPCM.cpp decodeSample and return an empty\ndecoded block if an error occurs.\n\nThis fixes the 00193-audiofile-signintoverflow-MSADPCM case of #41",
        "before_after_code_files": [
          "libaudiofile/modules/BlockCodec.cpp||libaudiofile/modules/BlockCodec.cpp",
          "libaudiofile/modules/MSADPCM.cpp||libaudiofile/modules/MSADPCM.cpp"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "libaudiofile/modules/BlockCodec.cpp||libaudiofile/modules/BlockCodec.cpp": [
          "File: libaudiofile/modules/BlockCodec.cpp -> libaudiofile/modules/BlockCodec.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "53:  for (int i=0; i<blocksRead; i++)",
          "54:  {",
          "58:   framesRead += m_framesPerPacket;",
          "59:  }",
          "",
          "[Removed Lines]",
          "55:   decodeBlock(static_cast<const uint8_t *>(m_inChunk->buffer) + i * m_bytesPerPacket,",
          "56:    static_cast<int16_t *>(m_outChunk->buffer) + i * m_framesPerPacket * m_track->f.channelCount);",
          "",
          "[Added Lines]",
          "55:   if (decodeBlock(static_cast<const uint8_t *>(m_inChunk->buffer) + i * m_bytesPerPacket,",
          "56:    static_cast<int16_t *>(m_outChunk->buffer) + i * m_framesPerPacket * m_track->f.channelCount)==0)",
          "57:    break;",
          "",
          "---------------"
        ],
        "libaudiofile/modules/MSADPCM.cpp||libaudiofile/modules/MSADPCM.cpp": [
          "File: libaudiofile/modules/MSADPCM.cpp -> libaudiofile/modules/MSADPCM.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "101:  768, 614, 512, 409, 307, 230, 230, 230",
          "102: };",
          "105: static int16_t decodeSample(ms_adpcm_state &state,",
          "107: {",
          "108:  int linearSample = (state.sample1 * coefficient[0] +",
          "109:   state.sample2 * coefficient[1]) >> 8;",
          "111:  linearSample += ((code & 0x08) ? (code - 0x10) : code) * state.delta;",
          "113:  linearSample = clamp(linearSample, MIN_INT16, MAX_INT16);",
          "116:  if (delta < 16)",
          "117:   delta = 16;",
          "119:  state.delta = delta;",
          "120:  state.sample2 = state.sample1;",
          "121:  state.sample1 = linearSample;",
          "123:  return static_cast<int16_t>(linearSample);",
          "124: }",
          "",
          "[Removed Lines]",
          "106:  uint8_t code, const int16_t *coefficient)",
          "115:  int delta = (state.delta * adaptationTable[code]) >> 8;",
          "",
          "[Added Lines]",
          "104: int firstBitSet(int x)",
          "105: {",
          "106:         int position=0;",
          "107:         while (x!=0)",
          "108:         {",
          "109:                 x>>=1;",
          "110:                 ++position;",
          "111:         }",
          "112:         return position;",
          "113: }",
          "115: #ifndef __has_builtin",
          "116: #define __has_builtin(x) 0",
          "117: #endif",
          "119: int multiplyCheckOverflow(int a, int b, int *result)",
          "120: {",
          "121: #if (defined __GNUC__ && __GNUC__ >= 5) || ( __clang__ && __has_builtin(__builtin_mul_overflow))",
          "122:  return __builtin_mul_overflow(a, b, result);",
          "123: #else",
          "124:  if (firstBitSet(a)+firstBitSet(b)>31) // int is signed, so we can't use 32 bits",
          "125:   return true;",
          "127:  return false;",
          "128: #endif",
          "129: }",
          "134:  uint8_t code, const int16_t *coefficient, bool *ok=NULL)",
          "138:  int delta;",
          "144:  if (multiplyCheckOverflow(state.delta, adaptationTable[code], &delta))",
          "145:  {",
          "146:                 if (ok) *ok=false;",
          "147:   _af_error(AF_BAD_COMPRESSION, \"Error decoding sample\");",
          "148:   return 0;",
          "149:  }",
          "150:  delta >>= 8;",
          "157:  if (ok) *ok=true;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "212:  {",
          "213:   uint8_t code;",
          "214:   int16_t newSample;",
          "216:   code = *encoded >> 4;",
          "220:   code = *encoded & 0x0f;",
          "224:   encoded++;",
          "",
          "[Removed Lines]",
          "217:   newSample = decodeSample(*state[0], code, coefficient[0]);",
          "221:   newSample = decodeSample(*state[1], code, coefficient[1]);",
          "",
          "[Added Lines]",
          "251:   bool ok;",
          "254:   newSample = decodeSample(*state[0], code, coefficient[0], &ok);",
          "255:   if (!ok) return 0;",
          "259:   newSample = decodeSample(*state[1], code, coefficient[1], &ok);",
          "260:   if (!ok) return 0;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "7d65f89defb092b63bcbc5d98349fb222ca73b3c",
      "candidate_info": {
        "commit_hash": "7d65f89defb092b63bcbc5d98349fb222ca73b3c",
        "repo": "antlarr/audiofile",
        "commit_url": "https://github.com/antlarr/audiofile/commit/7d65f89defb092b63bcbc5d98349fb222ca73b3c",
        "files": [
          "sfcommands/sfconvert.c"
        ],
        "message": "Check for multiplication overflow in sfconvert\n\nChecks that a multiplication doesn't overflow when\ncalculating the buffer size, and if it overflows,\nreduce the buffer size instead of failing.\n\nThis fixes the 00192-audiofile-signintoverflow-sfconvert case\nin #41",
        "before_after_code_files": [
          "sfcommands/sfconvert.c||sfcommands/sfconvert.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "sfcommands/sfconvert.c||sfcommands/sfconvert.c": [
          "File: sfcommands/sfconvert.c -> sfcommands/sfconvert.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "45: void usageerror (void);",
          "46: bool copyaudiodata (AFfilehandle infile, AFfilehandle outfile, int trackid);",
          "48: int main (int argc, char **argv)",
          "49: {",
          "50:  if (argc == 2)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "48: int firstBitSet(int x)",
          "49: {",
          "50:         int position=0;",
          "51:         while (x!=0)",
          "52:         {",
          "53:                 x>>=1;",
          "54:                 ++position;",
          "55:         }",
          "56:         return position;",
          "57: }",
          "59: #ifndef __has_builtin",
          "60: #define __has_builtin(x) 0",
          "61: #endif",
          "63: int multiplyCheckOverflow(int a, int b, int *result)",
          "64: {",
          "65: #if (defined __GNUC__ && __GNUC__ >= 5) || ( __clang__ && __has_builtin(__builtin_mul_overflow))",
          "66:  return __builtin_mul_overflow(a, b, result);",
          "67: #else",
          "68:  if (firstBitSet(a)+firstBitSet(b)>31) // int is signed, so we can't use 32 bits",
          "69:   return true;",
          "71:  return false;",
          "72: #endif",
          "73: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "323: {",
          "324:  int frameSize = afGetVirtualFrameSize(infile, trackid, 1);",
          "329:  AFframecount totalFrames = afGetFrameCount(infile, AF_DEFAULT_TRACK);",
          "330:  AFframecount totalFramesWritten = 0;",
          "",
          "[Removed Lines]",
          "326:  const int kBufferFrameCount = 65536;",
          "327:  void *buffer = malloc(kBufferFrameCount * frameSize);",
          "",
          "[Added Lines]",
          "353:  int kBufferFrameCount = 65536;",
          "354:  int bufferSize;",
          "355:  while (multiplyCheckOverflow(kBufferFrameCount, frameSize, &bufferSize))",
          "356:   kBufferFrameCount /= 2;",
          "357:  void *buffer = malloc(bufferSize);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
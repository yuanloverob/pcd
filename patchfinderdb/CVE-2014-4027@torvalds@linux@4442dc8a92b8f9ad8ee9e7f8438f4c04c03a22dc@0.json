{
  "cve_id": "CVE-2014-4027",
  "cve_desc": "The rd_build_device_space function in drivers/target/target_core_rd.c in the Linux kernel before 3.14 does not properly initialize a certain data structure, which allows local users to obtain sensitive information from ramdisk_mcp memory by leveraging access to a SCSI initiator.",
  "repo": "torvalds/linux",
  "patch_hash": "4442dc8a92b8f9ad8ee9e7f8438f4c04c03a22dc",
  "patch_info": {
    "commit_hash": "4442dc8a92b8f9ad8ee9e7f8438f4c04c03a22dc",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/4442dc8a92b8f9ad8ee9e7f8438f4c04c03a22dc",
    "files": [
      "drivers/target/target_core_rd.c"
    ],
    "message": "target/rd: Refactor rd_build_device_space + rd_release_device_space\n\nThis patch refactors rd_build_device_space() + rd_release_device_space()\ninto rd_allocate_sgl_table() + rd_release_device_space() so that they\nmay be used seperatly for setup + release of protection information\nscatterlists.\n\nAlso add explicit memset of pages within rd_allocate_sgl_table() based\nupon passed 'init_payload' value.\n\nv2 changes:\n  - Drop unused sg_table from rd_release_device_space (Wei)\n\nCc: Martin K. Petersen <martin.petersen@oracle.com>\nCc: Christoph Hellwig <hch@lst.de>\nCc: Hannes Reinecke <hare@suse.de>\nCc: Sagi Grimberg <sagig@mellanox.com>\nCc: Or Gerlitz <ogerlitz@mellanox.com>\nSigned-off-by: Nicholas Bellinger <nab@linux-iscsi.org>",
    "before_after_code_files": [
      "drivers/target/target_core_rd.c||drivers/target/target_core_rd.c"
    ]
  },
  "patch_diff": {
    "drivers/target/target_core_rd.c||drivers/target/target_core_rd.c": [
      "File: drivers/target/target_core_rd.c -> drivers/target/target_core_rd.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "78:  hba->hba_ptr = NULL;",
      "79: }",
      "86: {",
      "89:  struct page *pg;",
      "90:  struct scatterlist *sg;",
      "98:   sg = sg_table[i].sg_table;",
      "99:   sg_per_table = sg_table[i].rd_sg_count;",
      "",
      "[Removed Lines]",
      "85: static void rd_release_device_space(struct rd_dev *rd_dev)",
      "87:  u32 i, j, page_count = 0, sg_per_table;",
      "88:  struct rd_dev_sg_table *sg_table;",
      "92:  if (!rd_dev->sg_table_array || !rd_dev->sg_table_count)",
      "93:   return;",
      "95:  sg_table = rd_dev->sg_table_array;",
      "97:  for (i = 0; i < rd_dev->sg_table_count; i++) {",
      "",
      "[Added Lines]",
      "81: static u32 rd_release_sgl_table(struct rd_dev *rd_dev, struct rd_dev_sg_table *sg_table,",
      "82:      u32 sg_table_count)",
      "86:  u32 i, j, page_count = 0, sg_per_table;",
      "88:  for (i = 0; i < sg_table_count; i++) {",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "105:     page_count++;",
      "106:    }",
      "107:   }",
      "109:   kfree(sg);",
      "110:  }",
      "112:  pr_debug(\"CORE_RD[%u] - Released device space for Ramdisk\"",
      "113:   \" Device ID: %u, pages %u in %u tables total bytes %lu\\n\",",
      "114:   rd_dev->rd_host->rd_host_id, rd_dev->rd_dev_id, page_count,",
      "115:   rd_dev->sg_table_count, (unsigned long)page_count * PAGE_SIZE);",
      "118:  rd_dev->sg_table_array = NULL;",
      "119:  rd_dev->sg_table_count = 0;",
      "120: }",
      "",
      "[Removed Lines]",
      "117:  kfree(sg_table);",
      "",
      "[Added Lines]",
      "102:  kfree(sg_table);",
      "103:  return page_count;",
      "104: }",
      "106: static void rd_release_device_space(struct rd_dev *rd_dev)",
      "107: {",
      "108:  u32 page_count;",
      "110:  if (!rd_dev->sg_table_array || !rd_dev->sg_table_count)",
      "111:   return;",
      "113:  page_count = rd_release_sgl_table(rd_dev, rd_dev->sg_table_array,",
      "114:        rd_dev->sg_table_count);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "128: {",
      "130:  u32 max_sg_per_table = (RD_MAX_ALLOCATION_SIZE /",
      "131:     sizeof(struct scatterlist));",
      "133:  struct page *pg;",
      "134:  struct scatterlist *sg;",
      "160:  while (total_sg_needed) {",
      "161:   sg_per_table = (total_sg_needed > max_sg_per_table) ?",
      "",
      "[Removed Lines]",
      "127: static int rd_build_device_space(struct rd_dev *rd_dev)",
      "129:  u32 i = 0, j, page_offset = 0, sg_per_table, sg_tables, total_sg_needed;",
      "132:  struct rd_dev_sg_table *sg_table;",
      "136:  if (rd_dev->rd_page_count <= 0) {",
      "137:   pr_err(\"Illegal page count: %u for Ramdisk device\\n\",",
      "138:    rd_dev->rd_page_count);",
      "139:   return -EINVAL;",
      "140:  }",
      "143:  if (rd_dev->rd_flags & RDF_NULLIO)",
      "144:   return 0;",
      "146:  total_sg_needed = rd_dev->rd_page_count;",
      "148:  sg_tables = (total_sg_needed / max_sg_per_table) + 1;",
      "150:  sg_table = kzalloc(sg_tables * sizeof(struct rd_dev_sg_table), GFP_KERNEL);",
      "151:  if (!sg_table) {",
      "152:   pr_err(\"Unable to allocate memory for Ramdisk\"",
      "153:    \" scatterlist tables\\n\");",
      "154:   return -ENOMEM;",
      "155:  }",
      "157:  rd_dev->sg_table_array = sg_table;",
      "158:  rd_dev->sg_table_count = sg_tables;",
      "",
      "[Added Lines]",
      "130: static int rd_allocate_sgl_table(struct rd_dev *rd_dev, struct rd_dev_sg_table *sg_table,",
      "131:      u32 total_sg_needed, unsigned char init_payload)",
      "133:  u32 i = 0, j, page_offset = 0, sg_per_table;",
      "138:  unsigned char *p;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "186:    }",
      "187:    sg_assign_page(&sg[j], pg);",
      "188:    sg[j].length = PAGE_SIZE;",
      "189:   }",
      "191:   page_offset += sg_per_table;",
      "192:   total_sg_needed -= sg_per_table;",
      "193:  }",
      "195:  pr_debug(\"CORE_RD[%u] - Built Ramdisk Device ID: %u space of\"",
      "200:  return 0;",
      "201: }",
      "",
      "[Removed Lines]",
      "196:   \" %u pages in %u tables\\n\", rd_dev->rd_host->rd_host_id,",
      "197:   rd_dev->rd_dev_id, rd_dev->rd_page_count,",
      "198:   rd_dev->sg_table_count);",
      "",
      "[Added Lines]",
      "170:    p = kmap(pg);",
      "171:    memset(p, init_payload, PAGE_SIZE);",
      "172:    kunmap(pg);",
      "179:  return 0;",
      "180: }",
      "182: static int rd_build_device_space(struct rd_dev *rd_dev)",
      "183: {",
      "184:  struct rd_dev_sg_table *sg_table;",
      "185:  u32 sg_tables, total_sg_needed;",
      "186:  u32 max_sg_per_table = (RD_MAX_ALLOCATION_SIZE /",
      "187:     sizeof(struct scatterlist));",
      "188:  int rc;",
      "190:  if (rd_dev->rd_page_count <= 0) {",
      "191:   pr_err(\"Illegal page count: %u for Ramdisk device\\n\",",
      "192:          rd_dev->rd_page_count);",
      "193:   return -EINVAL;",
      "194:  }",
      "197:  if (rd_dev->rd_flags & RDF_NULLIO)",
      "198:   return 0;",
      "200:  total_sg_needed = rd_dev->rd_page_count;",
      "202:  sg_tables = (total_sg_needed / max_sg_per_table) + 1;",
      "204:  sg_table = kzalloc(sg_tables * sizeof(struct rd_dev_sg_table), GFP_KERNEL);",
      "205:  if (!sg_table) {",
      "206:   pr_err(\"Unable to allocate memory for Ramdisk\"",
      "207:          \" scatterlist tables\\n\");",
      "208:   return -ENOMEM;",
      "209:  }",
      "211:  rd_dev->sg_table_array = sg_table;",
      "212:  rd_dev->sg_table_count = sg_tables;",
      "214:  rc = rd_allocate_sgl_table(rd_dev, sg_table, total_sg_needed, 0x00);",
      "215:  if (rc)",
      "216:   return rc;",
      "219:    \" %u pages in %u tables\\n\", rd_dev->rd_host->rd_host_id,",
      "220:    rd_dev->rd_dev_id, rd_dev->rd_page_count,",
      "221:    rd_dev->sg_table_count);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "670caa9f762647802a1b19749f127ac28949ca5a",
      "candidate_info": {
        "commit_hash": "670caa9f762647802a1b19749f127ac28949ca5a",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/670caa9f762647802a1b19749f127ac28949ca5a",
        "files": [
          "drivers/target/target_core_rd.c"
        ],
        "message": "target: Don't allocate pages for NULLIO devices\n\nSigned-off-by: Andy Grover <agrover@redhat.com>\nSigned-off-by: Nicholas Bellinger <nab@linux-iscsi.org>",
        "before_after_code_files": [
          "drivers/target/target_core_rd.c||drivers/target/target_core_rd.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "drivers/target/target_core_rd.c||drivers/target/target_core_rd.c"
          ],
          "candidate": [
            "drivers/target/target_core_rd.c||drivers/target/target_core_rd.c"
          ]
        }
      },
      "candidate_diff": {
        "drivers/target/target_core_rd.c||drivers/target/target_core_rd.c": [
          "File: drivers/target/target_core_rd.c -> drivers/target/target_core_rd.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "139:    rd_dev->rd_page_count);",
          "140:   return -EINVAL;",
          "141:  }",
          "142:  total_sg_needed = rd_dev->rd_page_count;",
          "144:  sg_tables = (total_sg_needed / max_sg_per_table) + 1;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "144:  if (rd_dev->rd_flags & RDF_NULLIO)",
          "145:   return 0;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
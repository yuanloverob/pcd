{
  "cve_id": "CVE-2018-19623",
  "cve_desc": "In Wireshark 2.6.0 to 2.6.4 and 2.4.0 to 2.4.10, the LBMPDM dissector could crash. In addition, a remote attacker could write arbitrary data to any memory locations before the packet-scoped memory. This was addressed in epan/dissectors/packet-lbmpdm.c by disallowing certain negative values.",
  "repo": "wireshark/wireshark",
  "patch_hash": "5797f602741a7505c18c2e0c505e963ca3349153",
  "patch_info": {
    "commit_hash": "5797f602741a7505c18c2e0c505e963ca3349153",
    "repo": "wireshark/wireshark",
    "commit_url": "https://github.com/wireshark/wireshark/commit/5797f602741a7505c18c2e0c505e963ca3349153",
    "files": [
      "epan/dissectors/packet-lbmpdm.c"
    ],
    "message": "LBMPDM: fix heap-buffer-overflow (write) in dissect_segment_ofstable\n\nid_list and ofs_list contain offsets read directly from the packet.\nWhile the field type is FT_UINT32, it is somehow interpreted as signed\nnumber. This means that ofs_table->offset_list[id_list[idx]]=... could\nin fact result in an arbitrary write before \"ofs_table->offset_list\" due\nto id_list[idx] being negative.\n\nAnother way for id_list[idx] to remain negative (-1) is for the loop to\nterminate before all \"field_count\" elements are set. Thus, remove the\n\"datalen_remaining >= L_LBMPDM_OFFSET_ENTRY_T\" check, if the offset is\ninvalid the proto_tree_add_item accessors will throw an exception.\n\nFixes the crash in the linked bug. Regression tested against the 8\ncapture files from bug 9718, its dissection results are still the same.\n\nBug: 15132\nChange-Id: If5d2f11ee47578acb80bc43ba7ed16adb27e0c02\nFixes: v1.11.3-rc1-2270-g2f4ca9c8d9 (\"Initial checkin of LBM aka 29West dissectors. See Bug 9718.\")\nReviewed-on: https://code.wireshark.org/review/30300\nPetri-Dish: Peter Wu <peter@lekensteyn.nl>\nTested-by: Petri Dish Buildbot\nReviewed-by: Anders Broman <a.broman58@gmail.com>",
    "before_after_code_files": [
      "epan/dissectors/packet-lbmpdm.c||epan/dissectors/packet-lbmpdm.c"
    ]
  },
  "patch_diff": {
    "epan/dissectors/packet-lbmpdm.c||epan/dissectors/packet-lbmpdm.c": [
      "File: epan/dissectors/packet-lbmpdm.c -> epan/dissectors/packet-lbmpdm.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "13: #include \"config.h\"",
      "14: #include <epan/packet.h>",
      "15: #include \"packet-lbm.h\"",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "15: #include <epan/exceptions.h>",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "792:     proto_tree * subtree = NULL;",
      "793:     int datalen = 0;",
      "794:     int seglen = 0;",
      "796:     int ofs = 0;",
      "797:     int field_count = 0;",
      "798:     int idx;",
      "",
      "[Removed Lines]",
      "795:     int datalen_remaining = 0;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "817:         id_list[idx] = -1;",
      "818:         ofs_list[idx] = -1;",
      "819:     }",
      "821:     ofs = offset + L_LBMPDM_SEG_HDR_T;",
      "823:     {",
      "824:         proto_item * offset_item = NULL;",
      "825:         proto_tree * offset_tree = NULL;",
      "",
      "[Removed Lines]",
      "820:     datalen_remaining = datalen;",
      "822:     for (idx = 0; (idx < field_count) && (datalen_remaining >= L_LBMPDM_OFFSET_ENTRY_T); idx++, ofs += L_LBMPDM_OFFSET_ENTRY_T)",
      "",
      "[Added Lines]",
      "821:     for (idx = 0; idx < field_count; idx++, ofs += L_LBMPDM_OFFSET_ENTRY_T)",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "830:         id_list[idx] = (gint32)tvb_get_guint32(tvb, ofs + O_LBMPDM_OFFSET_ENTRY_T_ID, encoding);",
      "831:         proto_tree_add_item(offset_tree, hf_lbmpdm_offset_entry_offset, tvb, ofs + O_LBMPDM_OFFSET_ENTRY_T_OFFSET, L_LBMPDM_OFFSET_ENTRY_T_OFFSET, encoding);",
      "832:         ofs_list[idx] = (gint32)tvb_get_guint32(tvb, ofs + O_LBMPDM_OFFSET_ENTRY_T_OFFSET, encoding);",
      "833:         if (id_list[idx] > max_index)",
      "834:         {",
      "835:             max_index = id_list[idx];",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "832:         if (id_list[idx] < 0 || ofs_list[idx] < 0) {",
      "833:             THROW(ReportedBoundsError);",
      "834:         }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "9c8645ec7b28e4d7193962ecd2a418613bf6a84f",
      "candidate_info": {
        "commit_hash": "9c8645ec7b28e4d7193962ecd2a418613bf6a84f",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/9c8645ec7b28e4d7193962ecd2a418613bf6a84f",
        "files": [
          "epan/dissectors/packet-lbmpdm.c"
        ],
        "message": "LBMPDM: fix heap-buffer-overflow (write) in dissect_segment_ofstable\n\nid_list and ofs_list contain offsets read directly from the packet.\nWhile the field type is FT_UINT32, it is somehow interpreted as signed\nnumber. This means that ofs_table->offset_list[id_list[idx]]=... could\nin fact result in an arbitrary write before \"ofs_table->offset_list\" due\nto id_list[idx] being negative.\n\nAnother way for id_list[idx] to remain negative (-1) is for the loop to\nterminate before all \"field_count\" elements are set. Thus, remove the\n\"datalen_remaining >= L_LBMPDM_OFFSET_ENTRY_T\" check, if the offset is\ninvalid the proto_tree_add_item accessors will throw an exception.\n\nFixes the crash in the linked bug. Regression tested against the 8\ncapture files from bug 9718, its dissection results are still the same.\n\nBug: 15132\nChange-Id: If5d2f11ee47578acb80bc43ba7ed16adb27e0c02\nFixes: v1.11.3-rc1-2270-g2f4ca9c8d9 (\"Initial checkin of LBM aka 29West dissectors. See Bug 9718.\")\nReviewed-on: https://code.wireshark.org/review/30300\nPetri-Dish: Peter Wu <peter@lekensteyn.nl>\nTested-by: Petri Dish Buildbot\nReviewed-by: Anders Broman <a.broman58@gmail.com>\n(cherry picked from commit 5797f602741a7505c18c2e0c505e963ca3349153)\nReviewed-on: https://code.wireshark.org/review/30347\nReviewed-by: Peter Wu <peter@lekensteyn.nl>",
        "before_after_code_files": [
          "epan/dissectors/packet-lbmpdm.c||epan/dissectors/packet-lbmpdm.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "epan/dissectors/packet-lbmpdm.c||epan/dissectors/packet-lbmpdm.c"
          ],
          "candidate": [
            "epan/dissectors/packet-lbmpdm.c||epan/dissectors/packet-lbmpdm.c"
          ]
        }
      },
      "candidate_diff": {
        "epan/dissectors/packet-lbmpdm.c||epan/dissectors/packet-lbmpdm.c": [
          "File: epan/dissectors/packet-lbmpdm.c -> epan/dissectors/packet-lbmpdm.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "25: #include \"config.h\"",
          "26: #include <epan/packet.h>",
          "27: #include \"packet-lbm.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "27: #include <epan/exceptions.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "849:     proto_tree * subtree = NULL;",
          "850:     int datalen = 0;",
          "851:     int seglen = 0;",
          "853:     int ofs = 0;",
          "854:     int field_count = 0;",
          "855:     int idx;",
          "",
          "[Removed Lines]",
          "852:     int datalen_remaining = 0;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "874:         id_list[idx] = -1;",
          "875:         ofs_list[idx] = -1;",
          "876:     }",
          "878:     ofs = offset + L_LBMPDM_SEG_HDR_T;",
          "880:     {",
          "881:         proto_item * offset_item = NULL;",
          "882:         proto_tree * offset_tree = NULL;",
          "",
          "[Removed Lines]",
          "877:     datalen_remaining = datalen;",
          "879:     for (idx = 0; (idx < field_count) && (datalen_remaining >= L_LBMPDM_OFFSET_ENTRY_T); idx++, ofs += L_LBMPDM_OFFSET_ENTRY_T)",
          "",
          "[Added Lines]",
          "878:     for (idx = 0; idx < field_count; idx++, ofs += L_LBMPDM_OFFSET_ENTRY_T)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "887:         id_list[idx] = (gint32)lbmpdm_fetch_uint32_encoded(tvb, ofs + O_LBMPDM_OFFSET_ENTRY_T_ID, encoding);",
          "888:         proto_tree_add_item(offset_tree, hf_lbmpdm_offset_entry_offset, tvb, ofs + O_LBMPDM_OFFSET_ENTRY_T_OFFSET, L_LBMPDM_OFFSET_ENTRY_T_OFFSET, encoding);",
          "889:         ofs_list[idx] = (gint32)lbmpdm_fetch_uint32_encoded(tvb, ofs + O_LBMPDM_OFFSET_ENTRY_T_OFFSET, encoding);",
          "890:         if (id_list[idx] > max_index)",
          "891:         {",
          "892:             max_index = id_list[idx];",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "889:         if (id_list[idx] < 0 || ofs_list[idx] < 0) {",
          "890:             THROW(ReportedBoundsError);",
          "891:         }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "1ec5a933e1fb331af506a6dddbb6c76017219876",
      "candidate_info": {
        "commit_hash": "1ec5a933e1fb331af506a6dddbb6c76017219876",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/1ec5a933e1fb331af506a6dddbb6c76017219876",
        "files": [
          "epan/dissectors/packet-lbmpdm.c"
        ],
        "message": "LBMPDM: fix heap-buffer-overflow (write) in dissect_segment_ofstable\n\nid_list and ofs_list contain offsets read directly from the packet.\nWhile the field type is FT_UINT32, it is somehow interpreted as signed\nnumber. This means that ofs_table->offset_list[id_list[idx]]=... could\nin fact result in an arbitrary write before \"ofs_table->offset_list\" due\nto id_list[idx] being negative.\n\nAnother way for id_list[idx] to remain negative (-1) is for the loop to\nterminate before all \"field_count\" elements are set. Thus, remove the\n\"datalen_remaining >= L_LBMPDM_OFFSET_ENTRY_T\" check, if the offset is\ninvalid the proto_tree_add_item accessors will throw an exception.\n\nFixes the crash in the linked bug. Regression tested against the 8\ncapture files from bug 9718, its dissection results are still the same.\n\nBug: 15132\nChange-Id: If5d2f11ee47578acb80bc43ba7ed16adb27e0c02\nFixes: v1.11.3-rc1-2270-g2f4ca9c8d9 (\"Initial checkin of LBM aka 29West dissectors. See Bug 9718.\")\nReviewed-on: https://code.wireshark.org/review/30300\nPetri-Dish: Peter Wu <peter@lekensteyn.nl>\nTested-by: Petri Dish Buildbot\nReviewed-by: Anders Broman <a.broman58@gmail.com>\n(cherry picked from commit 5797f602741a7505c18c2e0c505e963ca3349153)\nReviewed-on: https://code.wireshark.org/review/30346\nReviewed-by: Peter Wu <peter@lekensteyn.nl>",
        "before_after_code_files": [
          "epan/dissectors/packet-lbmpdm.c||epan/dissectors/packet-lbmpdm.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "epan/dissectors/packet-lbmpdm.c||epan/dissectors/packet-lbmpdm.c"
          ],
          "candidate": [
            "epan/dissectors/packet-lbmpdm.c||epan/dissectors/packet-lbmpdm.c"
          ]
        }
      },
      "candidate_diff": {
        "epan/dissectors/packet-lbmpdm.c||epan/dissectors/packet-lbmpdm.c": [
          "File: epan/dissectors/packet-lbmpdm.c -> epan/dissectors/packet-lbmpdm.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "13: #include \"config.h\"",
          "14: #include <epan/packet.h>",
          "15: #include \"packet-lbm.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "15: #include <epan/exceptions.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "837:     proto_tree * subtree = NULL;",
          "838:     int datalen = 0;",
          "839:     int seglen = 0;",
          "841:     int ofs = 0;",
          "842:     int field_count = 0;",
          "843:     int idx;",
          "",
          "[Removed Lines]",
          "840:     int datalen_remaining = 0;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "862:         id_list[idx] = -1;",
          "863:         ofs_list[idx] = -1;",
          "864:     }",
          "866:     ofs = offset + L_LBMPDM_SEG_HDR_T;",
          "868:     {",
          "869:         proto_item * offset_item = NULL;",
          "870:         proto_tree * offset_tree = NULL;",
          "",
          "[Removed Lines]",
          "865:     datalen_remaining = datalen;",
          "867:     for (idx = 0; (idx < field_count) && (datalen_remaining >= L_LBMPDM_OFFSET_ENTRY_T); idx++, ofs += L_LBMPDM_OFFSET_ENTRY_T)",
          "",
          "[Added Lines]",
          "866:     for (idx = 0; idx < field_count; idx++, ofs += L_LBMPDM_OFFSET_ENTRY_T)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "875:         id_list[idx] = (gint32)lbmpdm_fetch_uint32_encoded(tvb, ofs + O_LBMPDM_OFFSET_ENTRY_T_ID, encoding);",
          "876:         proto_tree_add_item(offset_tree, hf_lbmpdm_offset_entry_offset, tvb, ofs + O_LBMPDM_OFFSET_ENTRY_T_OFFSET, L_LBMPDM_OFFSET_ENTRY_T_OFFSET, encoding);",
          "877:         ofs_list[idx] = (gint32)lbmpdm_fetch_uint32_encoded(tvb, ofs + O_LBMPDM_OFFSET_ENTRY_T_OFFSET, encoding);",
          "878:         if (id_list[idx] > max_index)",
          "879:         {",
          "880:             max_index = id_list[idx];",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "877:         if (id_list[idx] < 0 || ofs_list[idx] < 0) {",
          "878:             THROW(ReportedBoundsError);",
          "879:         }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
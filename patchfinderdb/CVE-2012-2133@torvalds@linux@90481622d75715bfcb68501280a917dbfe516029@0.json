{
  "cve_id": "CVE-2012-2133",
  "cve_desc": "Use-after-free vulnerability in the Linux kernel before 3.3.6, when huge pages are enabled, allows local users to cause a denial of service (system crash) or possibly gain privileges by interacting with a hugetlbfs filesystem, as demonstrated by a umount operation that triggers improper handling of quota data.",
  "repo": "torvalds/linux",
  "patch_hash": "90481622d75715bfcb68501280a917dbfe516029",
  "patch_info": {
    "commit_hash": "90481622d75715bfcb68501280a917dbfe516029",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/90481622d75715bfcb68501280a917dbfe516029",
    "files": [
      "fs/hugetlbfs/inode.c",
      "include/linux/hugetlb.h",
      "mm/hugetlb.c"
    ],
    "message": "hugepages: fix use after free bug in \"quota\" handling\n\nhugetlbfs_{get,put}_quota() are badly named.  They don't interact with the\ngeneral quota handling code, and they don't much resemble its behaviour.\nRather than being about maintaining limits on on-disk block usage by\nparticular users, they are instead about maintaining limits on in-memory\npage usage (including anonymous MAP_PRIVATE copied-on-write pages)\nassociated with a particular hugetlbfs filesystem instance.\n\nWorse, they work by having callbacks to the hugetlbfs filesystem code from\nthe low-level page handling code, in particular from free_huge_page().\nThis is a layering violation of itself, but more importantly, if the\nkernel does a get_user_pages() on hugepages (which can happen from KVM\namongst others), then the free_huge_page() can be delayed until after the\nassociated inode has already been freed.  If an unmount occurs at the\nwrong time, even the hugetlbfs superblock where the \"quota\" limits are\nstored may have been freed.\n\nAndrew Barry proposed a patch to fix this by having hugepages, instead of\nstoring a pointer to their address_space and reaching the superblock from\nthere, had the hugepages store pointers directly to the superblock,\nbumping the reference count as appropriate to avoid it being freed.\nAndrew Morton rejected that version, however, on the grounds that it made\nthe existing layering violation worse.\n\nThis is a reworked version of Andrew's patch, which removes the extra, and\nsome of the existing, layering violation.  It works by introducing the\nconcept of a hugepage \"subpool\" at the lower hugepage mm layer - that is a\nfinite logical pool of hugepages to allocate from.  hugetlbfs now creates\na subpool for each filesystem instance with a page limit set, and a\npointer to the subpool gets added to each allocated hugepage, instead of\nthe address_space pointer used now.  The subpool has its own lifetime and\nis only freed once all pages in it _and_ all other references to it (i.e.\nsuperblocks) are gone.\n\nsubpools are optional - a NULL subpool pointer is taken by the code to\nmean that no subpool limits are in effect.\n\nPrevious discussion of this bug found in:  \"Fix refcounting in hugetlbfs\nquota handling.\". See:  https://lkml.org/lkml/2011/8/11/28 or\nhttp://marc.info/?l=linux-mm&m=126928970510627&w=1\n\nv2: Fixed a bug spotted by Hillf Danton, and removed the extra parameter to\nalloc_huge_page() - since it already takes the vma, it is not necessary.\n\nSigned-off-by: Andrew Barry <abarry@cray.com>\nSigned-off-by: David Gibson <david@gibson.dropbear.id.au>\nCc: Hugh Dickins <hughd@google.com>\nCc: Mel Gorman <mgorman@suse.de>\nCc: Minchan Kim <minchan.kim@gmail.com>\nCc: Hillf Danton <dhillf@gmail.com>\nCc: Paul Mackerras <paulus@samba.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
    "before_after_code_files": [
      "fs/hugetlbfs/inode.c||fs/hugetlbfs/inode.c",
      "include/linux/hugetlb.h||include/linux/hugetlb.h",
      "mm/hugetlb.c||mm/hugetlb.c"
    ]
  },
  "patch_diff": {
    "fs/hugetlbfs/inode.c||fs/hugetlbfs/inode.c": [
      "File: fs/hugetlbfs/inode.c -> fs/hugetlbfs/inode.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "626:   spin_lock(&sbinfo->stat_lock);",
      "632:    buf->f_files = sbinfo->max_inodes;",
      "633:    buf->f_ffree = sbinfo->free_inodes;",
      "634:   }",
      "",
      "[Removed Lines]",
      "629:   if (sbinfo->max_blocks >= 0) {",
      "630:    buf->f_blocks = sbinfo->max_blocks;",
      "631:    buf->f_bavail = buf->f_bfree = sbinfo->free_blocks;",
      "",
      "[Added Lines]",
      "629:   if (sbinfo->spool) {",
      "630:    long free_pages;",
      "632:    spin_lock(&sbinfo->spool->lock);",
      "633:    buf->f_blocks = sbinfo->spool->max_hpages;",
      "634:    free_pages = sbinfo->spool->max_hpages",
      "635:     - sbinfo->spool->used_hpages;",
      "636:    buf->f_bavail = buf->f_bfree = free_pages;",
      "637:    spin_unlock(&sbinfo->spool->lock);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "645:  if (sbi) {",
      "646:   sb->s_fs_info = NULL;",
      "647:   kfree(sbi);",
      "648:  }",
      "649: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "654:   if (sbi->spool)",
      "655:    hugepage_put_subpool(sbi->spool);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "874:  sb->s_fs_info = sbinfo;",
      "875:  sbinfo->hstate = config.hstate;",
      "876:  spin_lock_init(&sbinfo->stat_lock);",
      "879:  sbinfo->max_inodes = config.nr_inodes;",
      "880:  sbinfo->free_inodes = config.nr_inodes;",
      "881:  sb->s_maxbytes = MAX_LFS_FILESIZE;",
      "882:  sb->s_blocksize = huge_page_size(config.hstate);",
      "883:  sb->s_blocksize_bits = huge_page_shift(config.hstate);",
      "",
      "[Removed Lines]",
      "877:  sbinfo->max_blocks = config.nr_blocks;",
      "878:  sbinfo->free_blocks = config.nr_blocks;",
      "",
      "[Added Lines]",
      "889:  sbinfo->spool = NULL;",
      "890:  if (config.nr_blocks != -1) {",
      "891:   sbinfo->spool = hugepage_new_subpool(config.nr_blocks);",
      "892:   if (!sbinfo->spool)",
      "893:    goto out_free;",
      "894:  }",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "896:  sb->s_root = root;",
      "897:  return 0;",
      "898: out_free:",
      "899:  kfree(sbinfo);",
      "900:  return -ENOMEM;",
      "901: }",
      "931: static struct dentry *hugetlbfs_mount(struct file_system_type *fs_type,",
      "932:  int flags, const char *dev_name, void *data)",
      "933: {",
      "",
      "[Removed Lines]",
      "903: int hugetlb_get_quota(struct address_space *mapping, long delta)",
      "904: {",
      "905:  int ret = 0;",
      "906:  struct hugetlbfs_sb_info *sbinfo = HUGETLBFS_SB(mapping->host->i_sb);",
      "908:  if (sbinfo->free_blocks > -1) {",
      "909:   spin_lock(&sbinfo->stat_lock);",
      "910:   if (sbinfo->free_blocks - delta >= 0)",
      "911:    sbinfo->free_blocks -= delta;",
      "912:   else",
      "913:    ret = -ENOMEM;",
      "914:   spin_unlock(&sbinfo->stat_lock);",
      "915:  }",
      "917:  return ret;",
      "918: }",
      "920: void hugetlb_put_quota(struct address_space *mapping, long delta)",
      "921: {",
      "922:  struct hugetlbfs_sb_info *sbinfo = HUGETLBFS_SB(mapping->host->i_sb);",
      "924:  if (sbinfo->free_blocks > -1) {",
      "925:   spin_lock(&sbinfo->stat_lock);",
      "926:   sbinfo->free_blocks += delta;",
      "927:   spin_unlock(&sbinfo->stat_lock);",
      "928:  }",
      "929: }",
      "",
      "[Added Lines]",
      "913:  if (sbinfo->spool)",
      "914:   kfree(sbinfo->spool);",
      "",
      "---------------"
    ],
    "include/linux/hugetlb.h||include/linux/hugetlb.h": [
      "File: include/linux/hugetlb.h -> include/linux/hugetlb.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "14: #include <linux/shm.h>",
      "15: #include <asm/tlbflush.h>",
      "17: int PageHuge(struct page *page);",
      "19: void reset_vma_resv_huge_pages(struct vm_area_struct *vma);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "17: struct hugepage_subpool {",
      "18:  spinlock_t lock;",
      "19:  long count;",
      "20:  long max_hpages, used_hpages;",
      "21: };",
      "23: struct hugepage_subpool *hugepage_new_subpool(long nr_blocks);",
      "24: void hugepage_put_subpool(struct hugepage_subpool *spool);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "130: #ifdef CONFIG_HUGETLBFS",
      "131: struct hugetlbfs_sb_info {",
      "136:  spinlock_t stat_lock;",
      "137:  struct hstate *hstate;",
      "138: };",
      "140: static inline struct hugetlbfs_sb_info *HUGETLBFS_SB(struct super_block *sb)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "145:  struct hugepage_subpool *spool;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "146: extern const struct vm_operations_struct hugetlb_vm_ops;",
      "147: struct file *hugetlb_file_setup(const char *name, size_t size, vm_flags_t acct,",
      "148:     struct user_struct **user, int creat_flags);",
      "152: static inline int is_file_hugepages(struct file *file)",
      "153: {",
      "",
      "[Removed Lines]",
      "149: int hugetlb_get_quota(struct address_space *mapping, long delta);",
      "150: void hugetlb_put_quota(struct address_space *mapping, long delta);",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "mm/hugetlb.c||mm/hugetlb.c": [
      "File: mm/hugetlb.c -> mm/hugetlb.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "54: static DEFINE_SPINLOCK(hugetlb_lock);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "56: static inline void unlock_or_release_subpool(struct hugepage_subpool *spool)",
      "57: {",
      "58:  bool free = (spool->count == 0) && (spool->used_hpages == 0);",
      "60:  spin_unlock(&spool->lock);",
      "64:  if (free)",
      "65:   kfree(spool);",
      "66: }",
      "68: struct hugepage_subpool *hugepage_new_subpool(long nr_blocks)",
      "69: {",
      "70:  struct hugepage_subpool *spool;",
      "72:  spool = kmalloc(sizeof(*spool), GFP_KERNEL);",
      "73:  if (!spool)",
      "74:   return NULL;",
      "76:  spin_lock_init(&spool->lock);",
      "77:  spool->count = 1;",
      "78:  spool->max_hpages = nr_blocks;",
      "79:  spool->used_hpages = 0;",
      "81:  return spool;",
      "82: }",
      "84: void hugepage_put_subpool(struct hugepage_subpool *spool)",
      "85: {",
      "86:  spin_lock(&spool->lock);",
      "87:  BUG_ON(!spool->count);",
      "88:  spool->count--;",
      "89:  unlock_or_release_subpool(spool);",
      "90: }",
      "92: static int hugepage_subpool_get_pages(struct hugepage_subpool *spool,",
      "93:           long delta)",
      "94: {",
      "95:  int ret = 0;",
      "97:  if (!spool)",
      "98:   return 0;",
      "100:  spin_lock(&spool->lock);",
      "101:  if ((spool->used_hpages + delta) <= spool->max_hpages) {",
      "102:   spool->used_hpages += delta;",
      "103:  } else {",
      "104:   ret = -ENOMEM;",
      "105:  }",
      "106:  spin_unlock(&spool->lock);",
      "108:  return ret;",
      "109: }",
      "111: static void hugepage_subpool_put_pages(struct hugepage_subpool *spool,",
      "112:            long delta)",
      "113: {",
      "114:  if (!spool)",
      "115:   return;",
      "117:  spin_lock(&spool->lock);",
      "118:  spool->used_hpages -= delta;",
      "121:  unlock_or_release_subpool(spool);",
      "122: }",
      "124: static inline struct hugepage_subpool *subpool_inode(struct inode *inode)",
      "125: {",
      "126:  return HUGETLBFS_SB(inode->i_sb)->spool;",
      "127: }",
      "129: static inline struct hugepage_subpool *subpool_vma(struct vm_area_struct *vma)",
      "130: {",
      "131:  return subpool_inode(vma->vm_file->f_dentry->d_inode);",
      "132: }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "541:  struct hstate *h = page_hstate(page);",
      "542:  int nid = page_to_nid(page);",
      "546:  set_page_private(page, 0);",
      "547:  page->mapping = NULL;",
      "548:  BUG_ON(page_count(page));",
      "",
      "[Removed Lines]",
      "543:  struct address_space *mapping;",
      "545:  mapping = (struct address_space *) page_private(page);",
      "",
      "[Added Lines]",
      "621:  struct hugepage_subpool *spool =",
      "622:   (struct hugepage_subpool *)page_private(page);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "558:   enqueue_huge_page(h, page);",
      "559:  }",
      "560:  spin_unlock(&hugetlb_lock);",
      "563: }",
      "565: static void prep_new_huge_page(struct hstate *h, struct page *page, int nid)",
      "",
      "[Removed Lines]",
      "561:  if (mapping)",
      "562:   hugetlb_put_quota(mapping, 1);",
      "",
      "[Added Lines]",
      "639:  hugepage_subpool_put_pages(spool, 1);",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "1030: static struct page *alloc_huge_page(struct vm_area_struct *vma,",
      "1031:         unsigned long addr, int avoid_reserve)",
      "1032: {",
      "1033:  struct hstate *h = hstate_vma(vma);",
      "1034:  struct page *page;",
      "1037:  long chg;",
      "1046:  chg = vma_needs_reservation(h, vma, addr);",
      "1047:  if (chg < 0)",
      "1048:   return ERR_PTR(-VM_FAULT_OOM);",
      "1049:  if (chg)",
      "1051:    return ERR_PTR(-VM_FAULT_SIGBUS);",
      "1053:  spin_lock(&hugetlb_lock);",
      "",
      "[Removed Lines]",
      "1035:  struct address_space *mapping = vma->vm_file->f_mapping;",
      "1036:  struct inode *inode = mapping->host;",
      "1050:   if (hugetlb_get_quota(inode->i_mapping, chg))",
      "",
      "[Added Lines]",
      "1111:  struct hugepage_subpool *spool = subpool_vma(vma);",
      "1128:   if (hugepage_subpool_get_pages(spool, chg))",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "1057:  if (!page) {",
      "1058:   page = alloc_buddy_huge_page(h, NUMA_NO_NODE);",
      "1059:   if (!page) {",
      "1061:    return ERR_PTR(-VM_FAULT_SIGBUS);",
      "1062:   }",
      "1063:  }",
      "1067:  vma_commit_reservation(h, vma, addr);",
      "",
      "[Removed Lines]",
      "1060:    hugetlb_put_quota(inode->i_mapping, chg);",
      "1065:  set_page_private(page, (unsigned long) mapping);",
      "",
      "[Added Lines]",
      "1138:    hugepage_subpool_put_pages(spool, chg);",
      "1143:  set_page_private(page, (unsigned long)spool);",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "2083: {",
      "2084:  struct hstate *h = hstate_vma(vma);",
      "2085:  struct resv_map *reservations = vma_resv_map(vma);",
      "2086:  unsigned long reserve;",
      "2087:  unsigned long start;",
      "2088:  unsigned long end;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2164:  struct hugepage_subpool *spool = subpool_vma(vma);",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "2099:   if (reserve) {",
      "2100:    hugetlb_acct_memory(h, -reserve);",
      "2102:   }",
      "2103:  }",
      "2104: }",
      "",
      "[Removed Lines]",
      "2101:    hugetlb_put_quota(vma->vm_file->f_mapping, reserve);",
      "",
      "[Added Lines]",
      "2180:    hugepage_subpool_put_pages(spool, reserve);",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "2332:  address = address & huge_page_mask(h);",
      "2333:  pgoff = vma_hugecache_offset(h, vma, address);",
      "",
      "[Removed Lines]",
      "2334:  mapping = (struct address_space *)page_private(page);",
      "",
      "[Added Lines]",
      "2413:  mapping = vma->vm_file->f_dentry->d_inode->i_mapping;",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "2884: {",
      "2885:  long ret, chg;",
      "2886:  struct hstate *h = hstate_inode(inode);",
      "2893:  if (vm_flags & VM_NORESERVE)",
      "2894:   return 0;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2966:  struct hugepage_subpool *spool = subpool_inode(inode);",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "2915:  if (chg < 0)",
      "2916:   return chg;",
      "2920:   return -ENOSPC;",
      "2926:  ret = hugetlb_acct_memory(h, chg);",
      "2927:  if (ret < 0) {",
      "2929:   return ret;",
      "2930:  }",
      "",
      "[Removed Lines]",
      "2919:  if (hugetlb_get_quota(inode->i_mapping, chg))",
      "2928:   hugetlb_put_quota(inode->i_mapping, chg);",
      "",
      "[Added Lines]",
      "2999:  if (hugepage_subpool_get_pages(spool, chg))",
      "3008:   hugepage_subpool_put_pages(spool, chg);",
      "",
      "---------------",
      "--- Hunk 11 ---",
      "[Context before]",
      "2949: {",
      "2950:  struct hstate *h = hstate_inode(inode);",
      "2951:  long chg = region_truncate(&inode->i_mapping->private_list, offset);",
      "2953:  spin_lock(&inode->i_lock);",
      "2954:  inode->i_blocks -= (blocks_per_huge_page(h) * freed);",
      "2955:  spin_unlock(&inode->i_lock);",
      "2958:  hugetlb_acct_memory(h, -(chg - freed));",
      "2959: }",
      "",
      "[Removed Lines]",
      "2957:  hugetlb_put_quota(inode->i_mapping, (chg - freed));",
      "",
      "[Added Lines]",
      "3032:  struct hugepage_subpool *spool = subpool_inode(inode);",
      "3038:  hugepage_subpool_put_pages(spool, (chg - freed));",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "c50ac050811d6485616a193eb0f37bfbd191cc89",
      "candidate_info": {
        "commit_hash": "c50ac050811d6485616a193eb0f37bfbd191cc89",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/c50ac050811d6485616a193eb0f37bfbd191cc89",
        "files": [
          "mm/hugetlb.c"
        ],
        "message": "hugetlb: fix resv_map leak in error path\n\nWhen called for anonymous (non-shared) mappings, hugetlb_reserve_pages()\ndoes a resv_map_alloc().  It depends on code in hugetlbfs's\nvm_ops->close() to release that allocation.\n\nHowever, in the mmap() failure path, we do a plain unmap_region() without\nthe remove_vma() which actually calls vm_ops->close().\n\nThis is a decent fix.  This leak could get reintroduced if new code (say,\nafter hugetlb_reserve_pages() in hugetlbfs_file_mmap()) decides to return\nan error.  But, I think it would have to unroll the reservation anyway.\n\nChristoph's test case:\n\n\thttp://marc.info/?l=linux-mm&m=133728900729735\n\nThis patch applies to 3.4 and later.  A version for earlier kernels is at\nhttps://lkml.org/lkml/2012/5/22/418.\n\nSigned-off-by: Dave Hansen <dave@linux.vnet.ibm.com>\nAcked-by: Mel Gorman <mel@csn.ul.ie>\nAcked-by: KOSAKI Motohiro <kosaki.motohiro@jp.fujitsu.com>\nReported-by: Christoph Lameter <cl@linux.com>\nTested-by: Christoph Lameter <cl@linux.com>\nCc: Andrea Arcangeli <aarcange@redhat.com>\nCc: <stable@vger.kernel.org>\t[2.6.32+]\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "mm/hugetlb.c||mm/hugetlb.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "mm/hugetlb.c||mm/hugetlb.c"
          ],
          "candidate": [
            "mm/hugetlb.c||mm/hugetlb.c"
          ]
        }
      },
      "candidate_diff": {
        "mm/hugetlb.c||mm/hugetlb.c": [
          "File: mm/hugetlb.c -> mm/hugetlb.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2157:   kref_get(&reservations->refs);",
          "2158: }",
          "2160: static void hugetlb_vm_op_close(struct vm_area_struct *vma)",
          "2161: {",
          "2162:  struct hstate *h = hstate_vma(vma);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2160: static void resv_map_put(struct vm_area_struct *vma)",
          "2161: {",
          "2162:  struct resv_map *reservations = vma_resv_map(vma);",
          "2164:  if (!reservations)",
          "2165:   return;",
          "2166:  kref_put(&reservations->refs, resv_map_release);",
          "2167: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2173:   reserve = (end - start) -",
          "2174:    region_count(&reservations->regions, start, end);",
          "2178:   if (reserve) {",
          "2179:    hugetlb_acct_memory(h, -reserve);",
          "",
          "[Removed Lines]",
          "2176:   kref_put(&reservations->refs, resv_map_release);",
          "",
          "[Added Lines]",
          "2185:   resv_map_put(vma);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2991:   set_vma_resv_flags(vma, HPAGE_RESV_OWNER);",
          "2992:  }",
          "",
          "[Removed Lines]",
          "2994:  if (chg < 0)",
          "2995:   return chg;",
          "2998:  if (hugepage_subpool_get_pages(spool, chg))",
          "2999:   return -ENOSPC;",
          "",
          "[Added Lines]",
          "3003:  if (chg < 0) {",
          "3004:   ret = chg;",
          "3005:   goto out_err;",
          "3006:  }",
          "3009:  if (hugepage_subpool_get_pages(spool, chg)) {",
          "3010:   ret = -ENOSPC;",
          "3011:   goto out_err;",
          "3012:  }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "3005:  ret = hugetlb_acct_memory(h, chg);",
          "3006:  if (ret < 0) {",
          "3007:   hugepage_subpool_put_pages(spool, chg);",
          "3009:  }",
          "",
          "[Removed Lines]",
          "3008:   return ret;",
          "",
          "[Added Lines]",
          "3021:   goto out_err;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "3022:  if (!vma || vma->vm_flags & VM_MAYSHARE)",
          "3023:   region_add(&inode->i_mapping->private_list, from, to);",
          "3024:  return 0;",
          "3025: }",
          "3027: void hugetlb_unreserve_pages(struct inode *inode, long offset, long freed)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3038: out_err:",
          "3039:  resv_map_put(vma);",
          "3040:  return ret;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "cc9a6c8776615f9c194ccf0b63a0aa5628235545",
      "candidate_info": {
        "commit_hash": "cc9a6c8776615f9c194ccf0b63a0aa5628235545",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/cc9a6c8776615f9c194ccf0b63a0aa5628235545",
        "files": [
          "include/linux/cpuset.h",
          "include/linux/init_task.h",
          "include/linux/sched.h",
          "kernel/cpuset.c",
          "kernel/fork.c",
          "mm/filemap.c",
          "mm/hugetlb.c",
          "mm/mempolicy.c",
          "mm/page_alloc.c",
          "mm/slab.c",
          "mm/slub.c",
          "mm/vmscan.c"
        ],
        "message": "cpuset: mm: reduce large amounts of memory barrier related damage v3\n\nCommit c0ff7453bb5c (\"cpuset,mm: fix no node to alloc memory when\nchanging cpuset's mems\") wins a super prize for the largest number of\nmemory barriers entered into fast paths for one commit.\n\n[get|put]_mems_allowed is incredibly heavy with pairs of full memory\nbarriers inserted into a number of hot paths.  This was detected while\ninvestigating at large page allocator slowdown introduced some time\nafter 2.6.32.  The largest portion of this overhead was shown by\noprofile to be at an mfence introduced by this commit into the page\nallocator hot path.\n\nFor extra style points, the commit introduced the use of yield() in an\nimplementation of what looks like a spinning mutex.\n\nThis patch replaces the full memory barriers on both read and write\nsides with a sequence counter with just read barriers on the fast path\nside.  This is much cheaper on some architectures, including x86.  The\nmain bulk of the patch is the retry logic if the nodemask changes in a\nmanner that can cause a false failure.\n\nWhile updating the nodemask, a check is made to see if a false failure\nis a risk.  If it is, the sequence number gets bumped and parallel\nallocators will briefly stall while the nodemask update takes place.\n\nIn a page fault test microbenchmark, oprofile samples from\n__alloc_pages_nodemask went from 4.53% of all samples to 1.15%.  The\nactual results were\n\n                             3.3.0-rc3          3.3.0-rc3\n                             rc3-vanilla        nobarrier-v2r1\n    Clients   1 UserTime       0.07 (  0.00%)   0.08 (-14.19%)\n    Clients   2 UserTime       0.07 (  0.00%)   0.07 (  2.72%)\n    Clients   4 UserTime       0.08 (  0.00%)   0.07 (  3.29%)\n    Clients   1 SysTime        0.70 (  0.00%)   0.65 (  6.65%)\n    Clients   2 SysTime        0.85 (  0.00%)   0.82 (  3.65%)\n    Clients   4 SysTime        1.41 (  0.00%)   1.41 (  0.32%)\n    Clients   1 WallTime       0.77 (  0.00%)   0.74 (  4.19%)\n    Clients   2 WallTime       0.47 (  0.00%)   0.45 (  3.73%)\n    Clients   4 WallTime       0.38 (  0.00%)   0.37 (  1.58%)\n    Clients   1 Flt/sec/cpu  497620.28 (  0.00%) 520294.53 (  4.56%)\n    Clients   2 Flt/sec/cpu  414639.05 (  0.00%) 429882.01 (  3.68%)\n    Clients   4 Flt/sec/cpu  257959.16 (  0.00%) 258761.48 (  0.31%)\n    Clients   1 Flt/sec      495161.39 (  0.00%) 517292.87 (  4.47%)\n    Clients   2 Flt/sec      820325.95 (  0.00%) 850289.77 (  3.65%)\n    Clients   4 Flt/sec      1020068.93 (  0.00%) 1022674.06 (  0.26%)\n    MMTests Statistics: duration\n    Sys Time Running Test (seconds)             135.68    132.17\n    User+Sys Time Running Test (seconds)         164.2    160.13\n    Total Elapsed Time (seconds)                123.46    120.87\n\nThe overall improvement is small but the System CPU time is much\nimproved and roughly in correlation to what oprofile reported (these\nperformance figures are without profiling so skew is expected).  The\nactual number of page faults is noticeably improved.\n\nFor benchmarks like kernel builds, the overall benefit is marginal but\nthe system CPU time is slightly reduced.\n\nTo test the actual bug the commit fixed I opened two terminals.  The\nfirst ran within a cpuset and continually ran a small program that\nfaulted 100M of anonymous data.  In a second window, the nodemask of the\ncpuset was continually randomised in a loop.\n\nWithout the commit, the program would fail every so often (usually\nwithin 10 seconds) and obviously with the commit everything worked fine.\nWith this patch applied, it also worked fine so the fix should be\nfunctionally equivalent.\n\nSigned-off-by: Mel Gorman <mgorman@suse.de>\nCc: Miao Xie <miaox@cn.fujitsu.com>\nCc: David Rientjes <rientjes@google.com>\nCc: Peter Zijlstra <a.p.zijlstra@chello.nl>\nCc: Christoph Lameter <cl@linux.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "include/linux/cpuset.h||include/linux/cpuset.h",
          "include/linux/init_task.h||include/linux/init_task.h",
          "include/linux/sched.h||include/linux/sched.h",
          "kernel/cpuset.c||kernel/cpuset.c",
          "kernel/fork.c||kernel/fork.c",
          "mm/filemap.c||mm/filemap.c",
          "mm/hugetlb.c||mm/hugetlb.c",
          "mm/mempolicy.c||mm/mempolicy.c",
          "mm/page_alloc.c||mm/page_alloc.c",
          "mm/slab.c||mm/slab.c",
          "mm/slub.c||mm/slub.c",
          "mm/vmscan.c||mm/vmscan.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "mm/hugetlb.c||mm/hugetlb.c"
          ],
          "candidate": [
            "mm/hugetlb.c||mm/hugetlb.c"
          ]
        }
      },
      "candidate_diff": {
        "include/linux/cpuset.h||include/linux/cpuset.h": [
          "File: include/linux/cpuset.h -> include/linux/cpuset.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "89: extern void cpuset_print_task_mems_allowed(struct task_struct *p);",
          "96: {",
          "108: }",
          "111: {",
          "122: }",
          "124: static inline void set_mems_allowed(nodemask_t nodemask)",
          "125: {",
          "126:  task_lock(current);",
          "127:  current->mems_allowed = nodemask;",
          "128:  task_unlock(current);",
          "129: }",
          "",
          "[Removed Lines]",
          "95: static inline void get_mems_allowed(void)",
          "97:  current->mems_allowed_change_disable++;",
          "107:  smp_mb();",
          "110: static inline void put_mems_allowed(void)",
          "120:  smp_mb();",
          "121:  --ACCESS_ONCE(current->mems_allowed_change_disable);",
          "",
          "[Added Lines]",
          "98: static inline unsigned int get_mems_allowed(void)",
          "100:  return read_seqcount_begin(&current->mems_allowed_seq);",
          "108: static inline bool put_mems_allowed(unsigned int seq)",
          "110:  return !read_seqcount_retry(&current->mems_allowed_seq, seq);",
          "116:  write_seqcount_begin(&current->mems_allowed_seq);",
          "118:  write_seqcount_end(&current->mems_allowed_seq);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "234: {",
          "235: }",
          "238: {",
          "239: }",
          "242: {",
          "243: }",
          "",
          "[Removed Lines]",
          "237: static inline void get_mems_allowed(void)",
          "241: static inline void put_mems_allowed(void)",
          "",
          "[Added Lines]",
          "228: static inline unsigned int get_mems_allowed(void)",
          "230:  return 0;",
          "233: static inline bool put_mems_allowed(unsigned int seq)",
          "235:  return true;",
          "",
          "---------------"
        ],
        "include/linux/init_task.h||include/linux/init_task.h": [
          "File: include/linux/init_task.h -> include/linux/init_task.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "29: #define INIT_GROUP_RWSEM(sig)",
          "30: #endif",
          "32: #define INIT_SIGNALS(sig) {      \\",
          "33:  .nr_threads = 1,      \\",
          "34:  .wait_chldexit = __WAIT_QUEUE_HEAD_INITIALIZER(sig.wait_chldexit),\\",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "32: #ifdef CONFIG_CPUSETS",
          "33: #define INIT_CPUSET_SEQ       \\",
          "34:  .mems_allowed_seq = SEQCNT_ZERO,",
          "35: #else",
          "36: #define INIT_CPUSET_SEQ",
          "37: #endif",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "192:  INIT_FTRACE_GRAPH      \\",
          "193:  INIT_TRACE_RECURSION      \\",
          "194:  INIT_TASK_RCU_PREEMPT(tsk)     \\",
          "195: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "202:  INIT_CPUSET_SEQ       \\",
          "",
          "---------------"
        ],
        "include/linux/sched.h||include/linux/sched.h": [
          "File: include/linux/sched.h -> include/linux/sched.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "1514: #endif",
          "1515: #ifdef CONFIG_CPUSETS",
          "1518:  int cpuset_mem_spread_rotor;",
          "1519:  int cpuset_slab_spread_rotor;",
          "1520: #endif",
          "",
          "[Removed Lines]",
          "1517:  int mems_allowed_change_disable;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "kernel/cpuset.c||kernel/cpuset.c": [
          "File: kernel/cpuset.c -> kernel/cpuset.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "964: {",
          "965:  bool need_loop;",
          "",
          "[Removed Lines]",
          "967: repeat:",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "984:  need_loop = task_has_mempolicy(tsk) ||",
          "985:    !nodes_intersects(*newmems, tsk->mems_allowed);",
          "1023:  mpol_rebind_task(tsk, newmems, MPOL_REBIND_STEP2);",
          "1024:  tsk->mems_allowed = *newmems;",
          "1025:  task_unlock(tsk);",
          "1026: }",
          "",
          "[Removed Lines]",
          "986:  nodes_or(tsk->mems_allowed, tsk->mems_allowed, *newmems);",
          "987:  mpol_rebind_task(tsk, newmems, MPOL_REBIND_STEP1);",
          "1001:  smp_mb();",
          "1007:  while (need_loop && ACCESS_ONCE(tsk->mems_allowed_change_disable)) {",
          "1008:   task_unlock(tsk);",
          "1009:   if (!task_curr(tsk))",
          "1010:    yield();",
          "1011:   goto repeat;",
          "1012:  }",
          "1021:  smp_mb();",
          "",
          "[Added Lines]",
          "986:  if (need_loop)",
          "987:   write_seqcount_begin(&tsk->mems_allowed_seq);",
          "989:  nodes_or(tsk->mems_allowed, tsk->mems_allowed, *newmems);",
          "990:  mpol_rebind_task(tsk, newmems, MPOL_REBIND_STEP1);",
          "995:  if (need_loop)",
          "996:   write_seqcount_end(&tsk->mems_allowed_seq);",
          "",
          "---------------"
        ],
        "kernel/fork.c||kernel/fork.c": [
          "File: kernel/fork.c -> kernel/fork.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1237: #ifdef CONFIG_CPUSETS",
          "1238:  p->cpuset_mem_spread_rotor = NUMA_NO_NODE;",
          "1239:  p->cpuset_slab_spread_rotor = NUMA_NO_NODE;",
          "1240: #endif",
          "1241: #ifdef CONFIG_TRACE_IRQFLAGS",
          "1242:  p->irq_events = 0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1240:  seqcount_init(&p->mems_allowed_seq);",
          "",
          "---------------"
        ],
        "mm/filemap.c||mm/filemap.c": [
          "File: mm/filemap.c -> mm/filemap.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "499:  struct page *page;",
          "501:  if (cpuset_do_page_mem_spread()) {",
          "506:   return page;",
          "507:  }",
          "508:  return alloc_pages(gfp, 0);",
          "",
          "[Removed Lines]",
          "502:   get_mems_allowed();",
          "503:   n = cpuset_mem_spread_node();",
          "504:   page = alloc_pages_exact_node(n, gfp, 0);",
          "505:   put_mems_allowed();",
          "",
          "[Added Lines]",
          "502:   unsigned int cpuset_mems_cookie;",
          "503:   do {",
          "504:    cpuset_mems_cookie = get_mems_allowed();",
          "505:    n = cpuset_mem_spread_node();",
          "506:    page = alloc_pages_exact_node(n, gfp, 0);",
          "507:   } while (!put_mems_allowed(cpuset_mems_cookie) && !page);",
          "",
          "---------------"
        ],
        "mm/hugetlb.c||mm/hugetlb.c": [
          "File: mm/hugetlb.c -> mm/hugetlb.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "454:     struct vm_area_struct *vma,",
          "455:     unsigned long address, int avoid_reserve)",
          "456: {",
          "458:  struct mempolicy *mpol;",
          "459:  nodemask_t *nodemask;",
          "460:  struct zonelist *zonelist;",
          "461:  struct zone *zone;",
          "462:  struct zoneref *z;",
          "465:  zonelist = huge_zonelist(vma, address,",
          "466:      htlb_alloc_mask, &mpol, &nodemask);",
          "",
          "[Removed Lines]",
          "457:  struct page *page = NULL;",
          "464:  get_mems_allowed();",
          "",
          "[Added Lines]",
          "457:  struct page *page;",
          "463:  unsigned int cpuset_mems_cookie;",
          "465: retry_cpuset:",
          "466:  cpuset_mems_cookie = get_mems_allowed();",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "488:    }",
          "489:   }",
          "490:  }",
          "492:  mpol_cond_put(mpol);",
          "494:  return page;",
          "495: }",
          "497: static void update_and_free_page(struct hstate *h, struct page *page)",
          "",
          "[Removed Lines]",
          "491: err:",
          "493:  put_mems_allowed();",
          "",
          "[Added Lines]",
          "495:  if (unlikely(!put_mems_allowed(cpuset_mems_cookie) && !page))",
          "496:   goto retry_cpuset;",
          "499: err:",
          "500:  mpol_cond_put(mpol);",
          "501:  return NULL;",
          "",
          "---------------"
        ],
        "mm/mempolicy.c||mm/mempolicy.c": [
          "File: mm/mempolicy.c -> mm/mempolicy.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1850: alloc_pages_vma(gfp_t gfp, int order, struct vm_area_struct *vma,",
          "1851:   unsigned long addr, int node)",
          "1852: {",
          "1854:  struct zonelist *zl;",
          "1855:  struct page *page;",
          "1858:  if (unlikely(pol->mode == MPOL_INTERLEAVE)) {",
          "1859:   unsigned nid;",
          "1861:   nid = interleave_nid(pol, vma, addr, PAGE_SHIFT + order);",
          "1862:   mpol_cond_put(pol);",
          "1863:   page = alloc_page_interleave(gfp, order, nid);",
          "1865:   return page;",
          "1866:  }",
          "1867:  zl = policy_zonelist(gfp, pol, node);",
          "",
          "[Removed Lines]",
          "1853:  struct mempolicy *pol = get_vma_policy(current, vma, addr);",
          "1857:  get_mems_allowed();",
          "1864:   put_mems_allowed();",
          "",
          "[Added Lines]",
          "1853:  struct mempolicy *pol;",
          "1856:  unsigned int cpuset_mems_cookie;",
          "1858: retry_cpuset:",
          "1859:  pol = get_vma_policy(current, vma, addr);",
          "1860:  cpuset_mems_cookie = get_mems_allowed();",
          "1868:   if (unlikely(!put_mems_allowed(cpuset_mems_cookie) && !page))",
          "1869:    goto retry_cpuset;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1872:   struct page *page =  __alloc_pages_nodemask(gfp, order,",
          "1873:       zl, policy_nodemask(gfp, pol));",
          "1874:   __mpol_put(pol);",
          "1876:   return page;",
          "1877:  }",
          "",
          "[Removed Lines]",
          "1875:   put_mems_allowed();",
          "",
          "[Added Lines]",
          "1881:   if (unlikely(!put_mems_allowed(cpuset_mems_cookie) && !page))",
          "1882:    goto retry_cpuset;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1881:  page = __alloc_pages_nodemask(gfp, order, zl,",
          "1882:           policy_nodemask(gfp, pol));",
          "1884:  return page;",
          "1885: }",
          "",
          "[Removed Lines]",
          "1883:  put_mems_allowed();",
          "",
          "[Added Lines]",
          "1890:  if (unlikely(!put_mems_allowed(cpuset_mems_cookie) && !page))",
          "1891:   goto retry_cpuset;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1907: {",
          "1908:  struct mempolicy *pol = current->mempolicy;",
          "1909:  struct page *page;",
          "1911:  if (!pol || in_interrupt() || (gfp & __GFP_THISNODE))",
          "1912:   pol = &default_policy;",
          "",
          "[Removed Lines]",
          "1914:  get_mems_allowed();",
          "",
          "[Added Lines]",
          "1918:  unsigned int cpuset_mems_cookie;",
          "1923: retry_cpuset:",
          "1924:  cpuset_mems_cookie = get_mems_allowed();",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1922:   page = __alloc_pages_nodemask(gfp, order,",
          "1923:     policy_zonelist(gfp, pol, numa_node_id()),",
          "1924:     policy_nodemask(gfp, pol));",
          "1926:  return page;",
          "1927: }",
          "1928: EXPORT_SYMBOL(alloc_pages_current);",
          "",
          "[Removed Lines]",
          "1925:  put_mems_allowed();",
          "",
          "[Added Lines]",
          "1937:  if (unlikely(!put_mems_allowed(cpuset_mems_cookie) && !page))",
          "1938:   goto retry_cpuset;",
          "",
          "---------------"
        ],
        "mm/page_alloc.c||mm/page_alloc.c": [
          "File: mm/page_alloc.c -> mm/page_alloc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2380: {",
          "2381:  enum zone_type high_zoneidx = gfp_zone(gfp_mask);",
          "2382:  struct zone *preferred_zone;",
          "2384:  int migratetype = allocflags_to_migratetype(gfp_mask);",
          "2386:  gfp_mask &= gfp_allowed_mask;",
          "",
          "[Removed Lines]",
          "2383:  struct page *page;",
          "",
          "[Added Lines]",
          "2383:  struct page *page = NULL;",
          "2385:  unsigned int cpuset_mems_cookie;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2400:  if (unlikely(!zonelist->_zonerefs->zone))",
          "2401:   return NULL;",
          "2405:  first_zones_zonelist(zonelist, high_zoneidx,",
          "2406:     nodemask ? : &cpuset_current_mems_allowed,",
          "2407:     &preferred_zone);",
          "2414:  page = get_page_from_freelist(gfp_mask|__GFP_HARDWALL, nodemask, order,",
          "",
          "[Removed Lines]",
          "2403:  get_mems_allowed();",
          "2408:  if (!preferred_zone) {",
          "2409:   put_mems_allowed();",
          "2410:   return NULL;",
          "2411:  }",
          "",
          "[Added Lines]",
          "2404: retry_cpuset:",
          "2405:  cpuset_mems_cookie = get_mems_allowed();",
          "2411:  if (!preferred_zone)",
          "2412:   goto out;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2418:   page = __alloc_pages_slowpath(gfp_mask, order,",
          "2419:     zonelist, high_zoneidx, nodemask,",
          "2420:     preferred_zone, migratetype);",
          "2423:  trace_mm_page_alloc(page, order, gfp_mask, migratetype);",
          "2424:  return page;",
          "2425: }",
          "2426: EXPORT_SYMBOL(__alloc_pages_nodemask);",
          "",
          "[Removed Lines]",
          "2421:  put_mems_allowed();",
          "",
          "[Added Lines]",
          "2425: out:",
          "2432:  if (unlikely(!put_mems_allowed(cpuset_mems_cookie) && !page))",
          "2433:   goto retry_cpuset;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2634: bool skip_free_areas_node(unsigned int flags, int nid)",
          "2635: {",
          "2636:  bool ret = false;",
          "2638:  if (!(flags & SHOW_MEM_FILTER_NODES))",
          "2639:   goto out;",
          "2644: out:",
          "2645:  return ret;",
          "2646: }",
          "",
          "[Removed Lines]",
          "2641:  get_mems_allowed();",
          "2642:  ret = !node_isset(nid, cpuset_current_mems_allowed);",
          "2643:  put_mems_allowed();",
          "",
          "[Added Lines]",
          "2648:  unsigned int cpuset_mems_cookie;",
          "2653:  do {",
          "2654:   cpuset_mems_cookie = get_mems_allowed();",
          "2655:   ret = !node_isset(nid, cpuset_current_mems_allowed);",
          "2656:  } while (!put_mems_allowed(cpuset_mems_cookie));",
          "",
          "---------------"
        ],
        "mm/slab.c||mm/slab.c": [
          "File: mm/slab.c -> mm/slab.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3284:  if (in_interrupt() || (flags & __GFP_THISNODE))",
          "3285:   return NULL;",
          "3286:  nid_alloc = nid_here = numa_mem_id();",
          "3288:  if (cpuset_do_slab_mem_spread() && (cachep->flags & SLAB_MEM_SPREAD))",
          "3289:   nid_alloc = cpuset_slab_spread_node();",
          "3290:  else if (current->mempolicy)",
          "3291:   nid_alloc = slab_node(current->mempolicy);",
          "3293:  if (nid_alloc != nid_here)",
          "3294:   return ____cache_alloc_node(cachep, flags, nid_alloc);",
          "3295:  return NULL;",
          "",
          "[Removed Lines]",
          "3287:  get_mems_allowed();",
          "3292:  put_mems_allowed();",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3312:  enum zone_type high_zoneidx = gfp_zone(flags);",
          "3313:  void *obj = NULL;",
          "3314:  int nid;",
          "3316:  if (flags & __GFP_THISNODE)",
          "3317:   return NULL;",
          "3321:  local_flags = flags & (GFP_CONSTRAINT_MASK|GFP_RECLAIM_MASK);",
          "3323: retry:",
          "",
          "[Removed Lines]",
          "3319:  get_mems_allowed();",
          "3320:  zonelist = node_zonelist(slab_node(current->mempolicy), flags);",
          "",
          "[Added Lines]",
          "3313:  unsigned int cpuset_mems_cookie;",
          "3320: retry_cpuset:",
          "3321:  cpuset_mems_cookie = get_mems_allowed();",
          "3322:  zonelist = node_zonelist(slab_node(current->mempolicy), flags);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3372:    }",
          "3373:   }",
          "3374:  }",
          "3376:  return obj;",
          "3377: }",
          "",
          "[Removed Lines]",
          "3375:  put_mems_allowed();",
          "",
          "[Added Lines]",
          "3377:  if (unlikely(!put_mems_allowed(cpuset_mems_cookie) && !obj))",
          "3378:   goto retry_cpuset;",
          "",
          "---------------"
        ],
        "mm/slub.c||mm/slub.c": [
          "File: mm/slub.c -> mm/slub.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1581:  struct zone *zone;",
          "1582:  enum zone_type high_zoneidx = gfp_zone(flags);",
          "1583:  void *object;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1584:  unsigned int cpuset_mems_cookie;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1604:    get_cycles() % 1024 > s->remote_node_defrag_ratio)",
          "1605:   return NULL;",
          "1620:    }",
          "1621:   }",
          "1624: #endif",
          "1625:  return NULL;",
          "1626: }",
          "",
          "[Removed Lines]",
          "1607:  get_mems_allowed();",
          "1608:  zonelist = node_zonelist(slab_node(current->mempolicy), flags);",
          "1609:  for_each_zone_zonelist(zone, z, zonelist, high_zoneidx) {",
          "1610:   struct kmem_cache_node *n;",
          "1612:   n = get_node(s, zone_to_nid(zone));",
          "1614:   if (n && cpuset_zone_allowed_hardwall(zone, flags) &&",
          "1615:     n->nr_partial > s->min_partial) {",
          "1616:    object = get_partial_node(s, n, c);",
          "1617:    if (object) {",
          "1618:     put_mems_allowed();",
          "1619:     return object;",
          "1622:  }",
          "1623:  put_mems_allowed();",
          "",
          "[Added Lines]",
          "1608:  do {",
          "1609:   cpuset_mems_cookie = get_mems_allowed();",
          "1610:   zonelist = node_zonelist(slab_node(current->mempolicy), flags);",
          "1611:   for_each_zone_zonelist(zone, z, zonelist, high_zoneidx) {",
          "1612:    struct kmem_cache_node *n;",
          "1614:    n = get_node(s, zone_to_nid(zone));",
          "1616:    if (n && cpuset_zone_allowed_hardwall(zone, flags) &&",
          "1617:      n->nr_partial > s->min_partial) {",
          "1618:     object = get_partial_node(s, n, c);",
          "1619:     if (object) {",
          "1628:      put_mems_allowed(cpuset_mems_cookie);",
          "1629:      return object;",
          "1630:     }",
          "1633:  } while (!put_mems_allowed(cpuset_mems_cookie));",
          "",
          "---------------"
        ],
        "mm/vmscan.c||mm/vmscan.c": [
          "File: mm/vmscan.c -> mm/vmscan.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2343:  unsigned long writeback_threshold;",
          "2344:  bool aborted_reclaim;",
          "2347:  delayacct_freepages_start();",
          "2349:  if (global_reclaim(sc))",
          "",
          "[Removed Lines]",
          "2346:  get_mems_allowed();",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2408: out:",
          "2409:  delayacct_freepages_end();",
          "2412:  if (sc->nr_reclaimed)",
          "2413:   return sc->nr_reclaimed;",
          "",
          "[Removed Lines]",
          "2410:  put_mems_allowed();",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    }
  ]
}
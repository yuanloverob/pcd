{
  "cve_id": "CVE-2015-0278",
  "cve_desc": "libuv before 0.10.34 does not properly drop group privileges, which allows context-dependent attackers to gain privileges via unspecified vectors.",
  "repo": "libuv/libuv",
  "patch_hash": "66ab38918c911bcff025562cf06237d7fedaba0c",
  "patch_info": {
    "commit_hash": "66ab38918c911bcff025562cf06237d7fedaba0c",
    "repo": "libuv/libuv",
    "commit_url": "https://github.com/libuv/libuv/commit/66ab38918c911bcff025562cf06237d7fedaba0c",
    "files": [
      "src/unix/process.c"
    ],
    "message": "unix: call setgoups before calling setuid/setgid\n\nPartial fix for #1093",
    "before_after_code_files": [
      "src/unix/process.c||src/unix/process.c"
    ]
  },
  "patch_diff": {
    "src/unix/process.c||src/unix/process.c": [
      "File: src/unix/process.c -> src/unix/process.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "330:     _exit(127);",
      "331:   }",
      "333:   if ((options->flags & UV_PROCESS_SETGID) && setgid(options->gid)) {",
      "334:     uv__write_int(error_fd, -errno);",
      "335:     perror(\"setgid()\");",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "333:   if (options->flags & (UV_PROCESS_SETUID | UV_PROCESS_SETGID)) {",
      "341:     SAVE_ERRNO(setgroups(0, NULL));",
      "342:   }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "303ae3b958eb0fb433589e86370652ec8d99f3c8",
      "candidate_info": {
        "commit_hash": "303ae3b958eb0fb433589e86370652ec8d99f3c8",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/303ae3b958eb0fb433589e86370652ec8d99f3c8",
        "files": [
          "src/unix/fsevents.c",
          "src/unix/kqueue.c"
        ],
        "message": "fsevents: FSEvents is most likely not thread-safe\n\nPerform all operation with FSEventStream in the same thread, where it'll\nbe used.",
        "before_after_code_files": [
          "src/unix/fsevents.c||src/unix/fsevents.c",
          "src/unix/kqueue.c||src/unix/kqueue.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/unix/fsevents.c||src/unix/fsevents.c": [
          "File: src/unix/fsevents.c -> src/unix/fsevents.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "214: static void uv__fsevents_schedule(void* arg) {",
          "215:   uv_fs_event_t* handle;",
          "217:   handle = arg;",
          "218:   FSEventStreamScheduleWithRunLoop(handle->cf_eventstream,",
          "219:                                    handle->loop->cf_loop,",
          "220:                                    kCFRunLoopDefaultMode);",
          "222:   uv_sem_post(&handle->cf_sem);",
          "223: }",
          "",
          "[Removed Lines]",
          "221:   FSEventStreamStart(handle->cf_eventstream);",
          "",
          "[Added Lines]",
          "216:   FSEventStreamContext ctx;",
          "217:   FSEventStreamRef ref;",
          "218:   CFStringRef path;",
          "219:   CFArrayRef paths;",
          "220:   CFAbsoluteTime latency;",
          "221:   FSEventStreamCreateFlags flags;",
          "226:   ctx.version = 0;",
          "227:   ctx.info = handle;",
          "228:   ctx.retain = NULL;",
          "229:   ctx.release = NULL;",
          "230:   ctx.copyDescription = NULL;",
          "233:   path = CFStringCreateWithCString(NULL,",
          "234:                                    handle->filename,",
          "235:                                    CFStringGetSystemEncoding());",
          "236:   assert(path != NULL);",
          "237:   paths = CFArrayCreate(NULL, (const void**)&path, 1, NULL);",
          "238:   assert(paths != NULL);",
          "240:   latency = 0.15;",
          "243:   flags = kFSEventStreamCreateFlagFileEvents;",
          "245:   ref = FSEventStreamCreate(NULL,",
          "246:                             &uv__fsevents_event_cb,",
          "247:                             &ctx,",
          "248:                             paths,",
          "249:                             kFSEventStreamEventIdSinceNow,",
          "250:                             latency,",
          "251:                             flags);",
          "252:   assert(ref != NULL);",
          "253:   handle->cf_eventstream = ref;",
          "258:   if (!FSEventStreamStart(handle->cf_eventstream))",
          "259:     abort();",
          "260: }",
          "263: static void uv__fsevents_unschedule(void* arg) {",
          "264:   uv_fs_event_t* handle;",
          "266:   handle = arg;",
          "269:   FSEventStreamStop(handle->cf_eventstream);",
          "272:   FSEventStreamInvalidate(handle->cf_eventstream);",
          "273:   FSEventStreamRelease(handle->cf_eventstream);",
          "274:   handle->cf_eventstream = NULL;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "381: int uv__fsevents_init(uv_fs_event_t* handle) {",
          "388:   int err;",
          "390:   err = uv__fsevents_loop_init(handle->loop);",
          "391:   if (err)",
          "392:     return err;",
          "402:   handle->realpath = realpath(handle->filename, NULL);",
          "403:   if (handle->realpath != NULL)",
          "404:     handle->realpath_len = strlen(handle->realpath);",
          "",
          "[Removed Lines]",
          "382:   FSEventStreamContext ctx;",
          "383:   FSEventStreamRef ref;",
          "384:   CFStringRef path;",
          "385:   CFArrayRef paths;",
          "386:   CFAbsoluteTime latency;",
          "387:   FSEventStreamCreateFlags flags;",
          "395:   ctx.version = 0;",
          "396:   ctx.info = handle;",
          "397:   ctx.retain = NULL;",
          "398:   ctx.release = NULL;",
          "399:   ctx.copyDescription = NULL;",
          "407:   path = CFStringCreateWithCString(NULL,",
          "408:                                    handle->filename,",
          "409:                                    CFStringGetSystemEncoding());",
          "410:   paths = CFArrayCreate(NULL, (const void**)&path, 1, NULL);",
          "412:   latency = 0.15;",
          "415:   flags = kFSEventStreamCreateFlagFileEvents;",
          "417:   ref = FSEventStreamCreate(NULL,",
          "418:                             &uv__fsevents_event_cb,",
          "419:                             &ctx,",
          "420:                             paths,",
          "421:                             kFSEventStreamEventIdSinceNow,",
          "422:                             latency,",
          "423:                             flags);",
          "424:   handle->cf_eventstream = ref;",
          "",
          "[Added Lines]",
          "448:   handle->cf_eventstream = NULL;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "449: int uv__fsevents_close(uv_fs_event_t* handle) {",
          "451:     return -EINVAL;",
          "464:   uv_close((uv_handle_t*) handle->cf_cb, (uv_close_cb) free);",
          "467:   UV__FSEVENTS_WALK(handle, {",
          "",
          "[Removed Lines]",
          "450:   if (handle->cf_eventstream == NULL)",
          "454:   uv_sem_wait(&handle->cf_sem);",
          "457:   FSEventStreamStop(handle->cf_eventstream);",
          "460:   FSEventStreamInvalidate(handle->cf_eventstream);",
          "461:   FSEventStreamRelease(handle->cf_eventstream);",
          "462:   handle->cf_eventstream = NULL;",
          "",
          "[Added Lines]",
          "473:   if (handle->cf_cb == NULL)",
          "476:   uv__cf_loop_signal(handle->loop, uv__fsevents_unschedule, handle);",
          "479:   uv_sem_wait(&handle->cf_sem);",
          "482:   handle->cf_cb = NULL;",
          "",
          "---------------"
        ],
        "src/unix/kqueue.c||src/unix/kqueue.c": [
          "File: src/unix/kqueue.c -> src/unix/kqueue.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "320: #if defined(__APPLE__)",
          "322:   handle->cf_eventstream = NULL;",
          "323:   handle->realpath = NULL;",
          "324:   handle->realpath_len = 0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "322:   handle->cf_cb = NULL;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "602b1c69e162a99c35bda1fd23daf4f6351e96d2",
      "candidate_info": {
        "commit_hash": "602b1c69e162a99c35bda1fd23daf4f6351e96d2",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/602b1c69e162a99c35bda1fd23daf4f6351e96d2",
        "files": [
          "src/uv-common.c"
        ],
        "message": "unix, windows: fix ipv6 link-local address parsing\n\nuv_ip6_addr() copies the address part to a temporary buffer when it\ncontains a link-local suffix ('<address>%<interface>'). Before this\ncommit, it didn't zero-terminate the address properly: it put the nul\nbyte at the end of the temporary buffer rather than at the end of the\naddress string, meaning the buffer looked like this:\n\n    <address> <garbage> '\\0'\n\nFixes the following valgrind warning:\n\n    ==16170== Conditional jump or move depends on uninitialised value(s)\n    ==16170==    at 0x43602C: inet_pton6 (inet.c:228)\n    ==16170==    by 0x435CE1: uv_inet_pton (inet.c:163)\n    ==16170==    by 0x436FD0: uv_ip6_addr (uv-common.c:175)\n    ==16170==    by 0x434717: test_ip6_addr_scope (test-ip6-addr.c:89)\n    ==16170==    by 0x43455B: call_iface_info_cb (test-ip6-addr.c:45)\n    ==16170==    by 0x43462B: foreach_ip6_interface (test-ip6-addr.c:59)\n    ==16170==    by 0x434791: run_test_ip6_addr_link_local (test-ip6-add\n    ==16170==    by 0x4061E8: run_test_part (runner.c:396)\n    ==16170==    by 0x404F4B: main (run-tests.c:58)\n    ==16170==\n    ==16170== Conditional jump or move depends on uninitialised value(s)\n    ==16170==    at 0x4C2AD8A: __GI_strchr (mc_replace_strmem.c:224)\n    ==16170==    by 0x435ECB: inet_pton6 (inet.c:231)\n    ==16170==    by 0x435CE1: uv_inet_pton (inet.c:163)\n    ==16170==    by 0x436FD0: uv_ip6_addr (uv-common.c:175)\n    ==16170==    by 0x434717: test_ip6_addr_scope (test-ip6-addr.c:89)\n    ==16170==    by 0x43455B: call_iface_info_cb (test-ip6-addr.c:45)\n    ==16170==    by 0x43462B: foreach_ip6_interface (test-ip6-addr.c:59)\n    ==16170==    by 0x434791: run_test_ip6_addr_link_local (test-ip6-add\n    ==16170==    by 0x4061E8: run_test_part (runner.c:396)\n    ==16170==    by 0x404F4B: main (run-tests.c:58)\n\nFixes #890.",
        "before_after_code_files": [
          "src/uv-common.c||src/uv-common.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/uv-common.c||src/uv-common.c": [
          "File: src/uv-common.c -> src/uv-common.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "154: #if defined(UV_PLATFORM_HAS_IP6_LINK_LOCAL_ADDRESS)",
          "155:   zone_index = strchr(ip, '%');",
          "156:   if (zone_index != NULL) {",
          "162:     ip = address_part;",
          "",
          "[Removed Lines]",
          "157:     address_part_size = sizeof(address_part);",
          "158:     assert((unsigned)(zone_index - ip) < address_part_size);",
          "159:     strncpy(address_part, ip, zone_index - ip);",
          "160:     address_part[address_part_size - 1] = '\\0';",
          "",
          "[Added Lines]",
          "157:     address_part_size = zone_index - ip;",
          "158:     if (address_part_size >= sizeof(address_part))",
          "159:       address_part_size = sizeof(address_part) - 1;",
          "161:     memcpy(address_part, ip, address_part_size);",
          "162:     address_part[address_part_size] = '\\0';",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "a1e159f04ec8fd249ec85bb98f6fdf5b97ef6d14",
      "candidate_info": {
        "commit_hash": "a1e159f04ec8fd249ec85bb98f6fdf5b97ef6d14",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/a1e159f04ec8fd249ec85bb98f6fdf5b97ef6d14",
        "files": [
          "test/test-timer-again.c"
        ],
        "message": "test: relax timing assumption of timer_again\n\ntimer_again test makes an implicit assumption on the triggering\ntiming of a repeating timer. However, this assumption may be not\ntrue on slower or virtualized architecture due to delay accumulation,\nwhich may fail the test as show in [0].\nThis commit makes explicit checks conforming to the asserted behavior.\n\n[0] http://ur1.ca/fr5c4\n\nSigned-off-by: Luca Bruno <lucab@debian.org>",
        "before_after_code_files": [
          "test/test-timer-again.c||test/test-timer-again.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "test/test-timer-again.c||test/test-timer-again.c": [
          "File: test/test-timer-again.c -> test/test-timer-again.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "57:   r = uv_timer_again(&repeat_2);",
          "58:   ASSERT(r == 0);",
          "61:     uv_close((uv_handle_t*)handle, close_cb);",
          "",
          "[Removed Lines]",
          "60:   if (uv_now(uv_default_loop()) >= start_time + 500) {",
          "",
          "[Added Lines]",
          "60:   if (repeat_1_cb_called == 10) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "135:   LOGF(\"Test took %ld ms (expected ~700 ms)\\n\",",
          "136:        (long int)(uv_now(uv_default_loop()) - start_time));",
          "139:   MAKE_VALGRIND_HAPPY();",
          "140:   return 0;",
          "",
          "[Removed Lines]",
          "137:   ASSERT(700 <= uv_now(uv_default_loop()) - start_time);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "5008f8de08019af46ee844489ee9eeb18e5c7dd7",
      "candidate_info": {
        "commit_hash": "5008f8de08019af46ee844489ee9eeb18e5c7dd7",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/5008f8de08019af46ee844489ee9eeb18e5c7dd7",
        "files": [
          "src/unix/linux-core.c"
        ],
        "message": "linux: silence uninitialized variable warning\n\nWhen building using gyp and BUILDTYPE=Release using clang 3.4 received\nthis warning:\n\n../src/unix/linux-core.c:640:34: warning: variable 'n' is uninitialized\n      for (len = sizeof(\"cpu0\"); n /= 10; len++);\n                                 ^\n\nInitializing n = 0 silences this build warning.",
        "before_after_code_files": [
          "src/unix/linux-core.c||src/unix/linux-core.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/unix/linux-core.c||src/unix/linux-core.c": [
          "File: src/unix/linux-core.c -> src/unix/linux-core.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "637:     {",
          "639:       assert(sscanf(buf, \"cpu%u \", &n) == 1);",
          "640:       for (len = sizeof(\"cpu0\"); n /= 10; len++);",
          "641:     }",
          "",
          "[Removed Lines]",
          "638:       unsigned int n;",
          "",
          "[Added Lines]",
          "638:       unsigned int n = 0;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "0f5c28b6844dbe8c037aadfa291c9e6277b2d0e9",
      "candidate_info": {
        "commit_hash": "0f5c28b6844dbe8c037aadfa291c9e6277b2d0e9",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/0f5c28b6844dbe8c037aadfa291c9e6277b2d0e9",
        "files": [
          "src/unix/fsevents.c",
          "src/unix/internal.h",
          "test/test-fs-event.c"
        ],
        "message": "fsevents: use FlagNoDefer for FSEventStreamCreate\n\nOtherwise `FSEventStreamCreate()` will coalesce events, even if they're\nhappening in the interval, bigger than supplied `latency`. In other\nwords, if this flag is not set events will happen in separate callback\nonly if there was a delay bigger than `latency` between two consecutive\nevents.",
        "before_after_code_files": [
          "src/unix/fsevents.c||src/unix/fsevents.c",
          "src/unix/internal.h||src/unix/internal.h",
          "test/test-fs-event.c||test/test-fs-event.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/unix/fsevents.c||src/unix/fsevents.c": [
          "File: src/unix/fsevents.c -> src/unix/fsevents.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "316:   ctx.release = NULL;",
          "317:   ctx.copyDescription = NULL;",
          "",
          "[Removed Lines]",
          "319:   latency = 0.15;",
          "322:   flags = kFSEventStreamCreateFlagFileEvents;",
          "",
          "[Added Lines]",
          "319:   latency = 0.05;",
          "333:   flags = kFSEventStreamCreateFlagNoDefer | kFSEventStreamCreateFlagFileEvents;",
          "",
          "---------------"
        ],
        "src/unix/internal.h||src/unix/internal.h": [
          "File: src/unix/internal.h -> src/unix/internal.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "242: #ifndef MAC_OS_X_VERSION_10_7",
          "244: static const int kFSEventStreamCreateFlagFileEvents = 0x00000010;",
          "245: static const int kFSEventStreamEventFlagItemCreated = 0x00000100;",
          "246: static const int kFSEventStreamEventFlagItemRemoved = 0x00000200;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "244: static const int kFSEventStreamCreateFlagNoDefer = 0x00000002;",
          "",
          "---------------"
        ],
        "test/test-fs-event.c||test/test-fs-event.c": [
          "File: test/test-fs-event.c -> test/test-fs-event.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "36: #endif",
          "38: static uv_fs_event_t fs_event;",
          "39: static uv_timer_t timer;",
          "45: static void create_dir(uv_loop_t* loop, const char* name) {",
          "46:   int r;",
          "",
          "[Removed Lines]",
          "40: static int timer_cb_called = 0;",
          "41: static int close_cb_called = 0;",
          "42: static int fs_event_cb_called = 0;",
          "43: static int timer_cb_touch_called = 0;",
          "",
          "[Added Lines]",
          "39: static const char file_prefix[] = \"fsevent-\";",
          "41: static int timer_cb_called;",
          "42: static int close_cb_called;",
          "43: static const int fs_event_file_count = 128;",
          "44: static int fs_event_created;",
          "45: static int fs_event_cb_called;",
          "46: #if defined(PATH_MAX)",
          "47: static char fs_event_filename[PATH_MAX];",
          "48: #else",
          "49: static char fs_event_filename[1024];",
          "51: static int timer_cb_touch_called;",
          "53: static void fs_event_unlink_files(uv_timer_t* handle, int status);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "107:   uv_close((uv_handle_t*)handle, close_cb);",
          "108: }",
          "110: static void fs_event_cb_file(uv_fs_event_t* handle, const char* filename,",
          "111:   int events, int status) {",
          "112:   ++fs_event_cb_called;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "120: static void fs_event_cb_dir_multi_file(uv_fs_event_t* handle,",
          "121:                                        const char* filename,",
          "122:                                        int events,",
          "123:                                        int status) {",
          "124:   fs_event_cb_called++;",
          "125:   ASSERT(handle == &fs_event);",
          "126:   ASSERT(status == 0);",
          "127:   ASSERT(events == UV_RENAME);",
          "128:   ASSERT(filename == NULL ||",
          "129:          strncmp(filename, file_prefix, sizeof(file_prefix) - 1) == 0);",
          "133:   if (fs_event_cb_called == 2 * fs_event_file_count) {",
          "134:     ASSERT(0 == uv_fs_event_stop(handle));",
          "135:     uv_close((uv_handle_t*) handle, close_cb);",
          "136:   }",
          "137: }",
          "139: static const char* fs_event_get_filename(int i) {",
          "140:   snprintf(fs_event_filename,",
          "141:            sizeof(fs_event_filename),",
          "142:            \"watch_dir/%s%d\",",
          "143:            file_prefix,",
          "144:            i);",
          "145:   return fs_event_filename;",
          "146: }",
          "148: static void fs_event_create_files(uv_timer_t* handle, int status) {",
          "149:   int i;",
          "152:   if (fs_event_created == fs_event_file_count) {",
          "153:     uv_close((uv_handle_t*) &timer, close_cb);",
          "154:     return;",
          "155:   }",
          "158:   for (i = 0; i < 16; i++, fs_event_created++)",
          "159:     create_file(handle->loop, fs_event_get_filename(i));",
          "162:   ASSERT(0 == uv_timer_start(&timer, fs_event_unlink_files, 50, 0));",
          "163: }",
          "165: void fs_event_unlink_files(uv_timer_t* handle, int status) {",
          "166:   int r;",
          "167:   int i;",
          "172:   for (i = 0; i < 16; i++) {",
          "173:     r = remove(fs_event_get_filename(i));",
          "174:     if (handle != NULL)",
          "175:       ASSERT(r == 0);",
          "176:   }",
          "179:   if (handle != NULL)",
          "180:     ASSERT(0 == uv_timer_start(&timer, fs_event_create_files, 50, 0));",
          "181: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "148:   }",
          "149: }",
          "157: static void timer_cb_file(uv_timer_t* handle, int status) {",
          "158:   ++timer_cb_called;",
          "",
          "[Removed Lines]",
          "151: static void timer_cb_dir(uv_timer_t* handle, int status) {",
          "152:   ++timer_cb_called;",
          "153:   create_file(handle->loop, \"watch_dir/file1\");",
          "154:   uv_close((uv_handle_t*)handle, close_cb);",
          "155: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "184:   int r;",
          "187:   remove(\"watch_dir/file2\");",
          "188:   remove(\"watch_dir/file1\");",
          "189:   remove(\"watch_dir/\");",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "254:   fs_event_unlink_files(NULL, 0);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "192:   r = uv_fs_event_init(loop, &fs_event);",
          "193:   ASSERT(r == 0);",
          "195:   ASSERT(r == 0);",
          "196:   r = uv_timer_init(loop, &timer);",
          "197:   ASSERT(r == 0);",
          "199:   ASSERT(r == 0);",
          "201:   uv_run(loop, UV_RUN_DEFAULT);",
          "205:   ASSERT(close_cb_called == 2);",
          "208:   remove(\"watch_dir/file2\");",
          "209:   remove(\"watch_dir/file1\");",
          "210:   remove(\"watch_dir/\");",
          "",
          "[Removed Lines]",
          "194:   r = uv_fs_event_start(&fs_event, fs_event_cb_dir, \"watch_dir\", 0);",
          "198:   r = uv_timer_start(&timer, timer_cb_dir, 100, 0);",
          "203:   ASSERT(fs_event_cb_called == 1);",
          "204:   ASSERT(timer_cb_called == 1);",
          "",
          "[Added Lines]",
          "262:   r = uv_fs_event_start(&fs_event, fs_event_cb_dir_multi_file, \"watch_dir\", 0);",
          "266:   r = uv_timer_start(&timer, fs_event_create_files, 100, 0);",
          "271:   ASSERT(fs_event_cb_called == 2 * fs_event_file_count);",
          "272:   ASSERT(fs_event_created == fs_event_file_count);",
          "276:   fs_event_unlink_files(NULL, 0);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
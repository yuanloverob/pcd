{
  "cve_id": "CVE-2018-13100",
  "cve_desc": "An issue was discovered in fs/f2fs/super.c in the Linux kernel through 4.17.3, which does not properly validate secs_per_zone in a corrupted f2fs image, as demonstrated by a divide-by-zero error.",
  "repo": "torvalds/linux",
  "patch_hash": "42bf546c1fe3f3654bdf914e977acbc2b80a5be5",
  "patch_info": {
    "commit_hash": "42bf546c1fe3f3654bdf914e977acbc2b80a5be5",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/42bf546c1fe3f3654bdf914e977acbc2b80a5be5",
    "files": [
      "fs/f2fs/super.c"
    ],
    "message": "f2fs: fix to do sanity check with secs_per_zone\n\nAs Wen Xu reported in below link:\n\nhttps://bugzilla.kernel.org/show_bug.cgi?id=200183\n\n- Overview\nDivide zero in reset_curseg() when mounting a crafted f2fs image\n\n- Reproduce\n\n- Kernel message\n[  588.281510] divide error: 0000 [#1] SMP KASAN PTI\n[  588.282701] CPU: 0 PID: 1293 Comm: mount Not tainted 4.18.0-rc1+ #4\n[  588.284000] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Ubuntu-1.8.2-1ubuntu1 04/01/2014\n[  588.286178] RIP: 0010:reset_curseg+0x94/0x1a0\n[  588.298166] RSP: 0018:ffff8801e88d7940 EFLAGS: 00010246\n[  588.299360] RAX: 0000000000000014 RBX: ffff8801e1d46d00 RCX: ffffffffb88bf60b\n[  588.300809] RDX: 0000000000000000 RSI: dffffc0000000000 RDI: ffff8801e1d46d64\n[  588.305272] R13: 0000000000000000 R14: 0000000000000014 R15: 0000000000000000\n[  588.306822] FS:  00007fad85008840(0000) GS:ffff8801f6e00000(0000) knlGS:0000000000000000\n[  588.308456] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  588.309623] CR2: 0000000001705078 CR3: 00000001f30f8000 CR4: 00000000000006f0\n[  588.311085] Call Trace:\n[  588.311637]  f2fs_build_segment_manager+0x103f/0x3410\n[  588.316136]  ? f2fs_commit_super+0x1b0/0x1b0\n[  588.317031]  ? set_blocksize+0x90/0x140\n[  588.319473]  f2fs_mount+0x15/0x20\n[  588.320166]  mount_fs+0x60/0x1a0\n[  588.320847]  ? alloc_vfsmnt+0x309/0x360\n[  588.321647]  vfs_kern_mount+0x6b/0x1a0\n[  588.322432]  do_mount+0x34a/0x18c0\n[  588.323175]  ? strndup_user+0x46/0x70\n[  588.323937]  ? copy_mount_string+0x20/0x20\n[  588.324793]  ? memcg_kmem_put_cache+0x1b/0xa0\n[  588.325702]  ? kasan_check_write+0x14/0x20\n[  588.326562]  ? _copy_from_user+0x6a/0x90\n[  588.327375]  ? memdup_user+0x42/0x60\n[  588.328118]  ksys_mount+0x83/0xd0\n[  588.328808]  __x64_sys_mount+0x67/0x80\n[  588.329607]  do_syscall_64+0x78/0x170\n[  588.330400]  entry_SYSCALL_64_after_hwframe+0x44/0xa9\n[  588.331461] RIP: 0033:0x7fad848e8b9a\n[  588.336022] RSP: 002b:00007ffd7c5b6be8 EFLAGS: 00000206 ORIG_RAX: 00000000000000a5\n[  588.337547] RAX: ffffffffffffffda RBX: 00000000016f8030 RCX: 00007fad848e8b9a\n[  588.338999] RDX: 00000000016f8210 RSI: 00000000016f9f30 RDI: 0000000001700ec0\n[  588.340442] RBP: 0000000000000000 R08: 0000000000000000 R09: 0000000000000013\n[  588.341887] R10: 00000000c0ed0000 R11: 0000000000000206 R12: 0000000001700ec0\n[  588.343341] R13: 00000000016f8210 R14: 0000000000000000 R15: 0000000000000003\n[  588.354891] ---[ end trace 4ce02f25ff7d3df5 ]---\n[  588.355862] RIP: 0010:reset_curseg+0x94/0x1a0\n[  588.360742] RSP: 0018:ffff8801e88d7940 EFLAGS: 00010246\n[  588.361812] RAX: 0000000000000014 RBX: ffff8801e1d46d00 RCX: ffffffffb88bf60b\n[  588.363485] RDX: 0000000000000000 RSI: dffffc0000000000 RDI: ffff8801e1d46d64\n[  588.365213] RBP: ffff8801e88d7968 R08: ffffed003c32266f R09: ffffed003c32266f\n[  588.366661] R10: 0000000000000001 R11: ffffed003c32266e R12: ffff8801f0337700\n[  588.368110] R13: 0000000000000000 R14: 0000000000000014 R15: 0000000000000000\n[  588.370057] FS:  00007fad85008840(0000) GS:ffff8801f6e00000(0000) knlGS:0000000000000000\n[  588.372099] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  588.373291] CR2: 0000000001705078 CR3: 00000001f30f8000 CR4: 00000000000006f0\n\n- Location\nhttps://elixir.bootlin.com/linux/latest/source/fs/f2fs/segment.c#L2147\n        curseg->zone = GET_ZONE_FROM_SEG(sbi, curseg->segno);\n\nIf secs_per_zone is corrupted due to fuzzing test, it will cause divide\nzero operation when using GET_ZONE_FROM_SEG macro, so we should do more\nsanity check with secs_per_zone during mount to avoid this issue.\n\nSigned-off-by: Chao Yu <yuchao0@huawei.com>\nSigned-off-by: Jaegeuk Kim <jaegeuk@kernel.org>",
    "before_after_code_files": [
      "fs/f2fs/super.c||fs/f2fs/super.c"
    ]
  },
  "patch_diff": {
    "fs/f2fs/super.c||fs/f2fs/super.c": [
      "File: fs/f2fs/super.c -> fs/f2fs/super.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "2227:   return 1;",
      "2228:  }",
      "2231:   f2fs_msg(sb, KERN_INFO,",
      "2233:    secs_per_zone, total_sections);",
      "2234:   return 1;",
      "2235:  }",
      "",
      "[Removed Lines]",
      "2230:  if (secs_per_zone > total_sections) {",
      "2232:    \"Wrong secs_per_zone (%u > %u)\",",
      "",
      "[Added Lines]",
      "2230:  if (secs_per_zone > total_sections || !secs_per_zone) {",
      "2232:    \"Wrong secs_per_zone / total_sections (%u, %u)\",",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "f25e1392fdb556290957142ac2da33a02cbff403",
      "candidate_info": {
        "commit_hash": "f25e1392fdb556290957142ac2da33a02cbff403",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/f25e1392fdb556290957142ac2da33a02cbff403",
        "files": [
          "drivers/net/usb/qmi_wwan.c"
        ],
        "message": "qmi_wwan: fix interface number for DW5821e production firmware\n\nThe original mapping for the DW5821e was done using a development\nversion of the firmware. Confirmed with the vendor that the final\nUSB layout ends up exposing the QMI control/data ports in USB\nconfig #1, interface #0, not in interface #1 (which is now a HID\ninterface).\n\nT:  Bus=01 Lev=03 Prnt=04 Port=00 Cnt=01 Dev#= 16 Spd=480 MxCh= 0\nD:  Ver= 2.10 Cls=ef(misc ) Sub=02 Prot=01 MxPS=64 #Cfgs=  2\nP:  Vendor=413c ProdID=81d7 Rev=03.18\nS:  Manufacturer=DELL\nS:  Product=DW5821e Snapdragon X20 LTE\nS:  SerialNumber=0123456789ABCDEF\nC:  #Ifs= 6 Cfg#= 1 Atr=a0 MxPwr=500mA\nI:  If#= 0 Alt= 0 #EPs= 3 Cls=ff(vend.) Sub=ff Prot=ff Driver=qmi_wwan\nI:  If#= 1 Alt= 0 #EPs= 1 Cls=03(HID  ) Sub=00 Prot=00 Driver=usbhid\nI:  If#= 2 Alt= 0 #EPs= 3 Cls=ff(vend.) Sub=00 Prot=00 Driver=option\nI:  If#= 3 Alt= 0 #EPs= 3 Cls=ff(vend.) Sub=00 Prot=00 Driver=option\nI:  If#= 4 Alt= 0 #EPs= 3 Cls=ff(vend.) Sub=00 Prot=00 Driver=option\nI:  If#= 5 Alt= 0 #EPs= 2 Cls=ff(vend.) Sub=ff Prot=ff Driver=option\n\nFixes: e7e197edd09c25 (\"qmi_wwan: add support for the Dell Wireless 5821e module\")\nSigned-off-by: Aleksander Morgado <aleksander@aleksander.es>\nAcked-by: Bj\u00f8rn Mork <bjorn@mork.no>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "drivers/net/usb/qmi_wwan.c||drivers/net/usb/qmi_wwan.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/net/usb/qmi_wwan.c||drivers/net/usb/qmi_wwan.c": [
          "File: drivers/net/usb/qmi_wwan.c -> drivers/net/usb/qmi_wwan.c"
        ]
      }
    },
    {
      "candidate_hash": "b17b113e0c38e94c2f8c0763926c6a2168293201",
      "candidate_info": {
        "commit_hash": "b17b113e0c38e94c2f8c0763926c6a2168293201",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/b17b113e0c38e94c2f8c0763926c6a2168293201",
        "files": [
          "drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_erp.c",
          "drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_tcam.h"
        ],
        "message": "mlxsw: spectrum_acl: Add support for C-TCAM eRPs\n\nThe number of eRPs that can be used by a single A-TCAM region is limited\nto 16. When more eRPs are needed, an ordinary circuit TCAM (C-TCAM) can\nbe used to hold the extra eRPs.\n\nUnlike the A-TCAM, only a single (last) lookup is performed in the\nC-TCAM and not a lookup per-eRP. However, modeling the C-TCAM as extra\neRPs will allow us to easily introduce support for pruning in a\nfollow-up patch set and is also logically correct.\n\nThe following diagram depicts the relation between both TCAMs:\n                                                                 C-TCAM\n+-------------------+               +--------------------+    +-----------+\n|                   |               |                    |    |           |\n|  eRP #1 (A-TCAM)  +----> ... +----+  eRP #16 (A-TCAM)  +----+  eRP #17  |\n|                   |               |                    |    |    ...    |\n+-------------------+               +--------------------+    |  eRP #N   |\n                                                              |           |\n                                                              +-----------+\nLookup order is from left to right.\n\nExtend the eRP core APIs with a C-TCAM parameter which indicates whether\nthe requested eRP is to be used with the C-TCAM or not.\n\nSince the C-TCAM is only meant to absorb rules that can't fit in the\nA-TCAM due to exceeded number of eRPs or key collision, an error is\nreturned when a C-TCAM eRP needs to be created when the eRP state\nmachine is in its initial state (i.e., 'no masks'). This should only\nhappen in the face of very unlikely errors when trying to push rules\ninto the A-TCAM.\n\nIn order not to perform unnecessary lookups, the eRP core will only\nenable a C-TCAM lookup for a given region if it knows there are C-TCAM\neRPs present.\n\nSigned-off-by: Ido Schimmel <idosch@mellanox.com>\nReviewed-by: Jiri Pirko <jiri@mellanox.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_erp.c||drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_erp.c",
          "drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_tcam.h||drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_tcam.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_erp.c||drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_erp.c": [
          "File: drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_erp.c -> drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_erp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "61: struct mlxsw_sp_acl_erp_key {",
          "62:  char mask[MLXSW_REG_PTCEX_FLEX_KEY_BLOCKS_LEN];",
          "63: };",
          "65: struct mlxsw_sp_acl_erp {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "63:  bool ctcam;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "90:  unsigned long base_index;",
          "91:  unsigned int num_atcam_erps;",
          "92:  unsigned int num_max_atcam_erps;",
          "93: };",
          "95: static const struct rhashtable_params mlxsw_sp_acl_erp_ht_params = {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "94:  unsigned int num_ctcam_erps;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "448: }",
          "450: static int",
          "452: {",
          "453:  struct mlxsw_sp_acl_tcam_region *region = erp_table->aregion->region;",
          "454:  struct mlxsw_sp *mlxsw_sp = erp_table->erp_core->mlxsw_sp;",
          "455:  char pererp_pl[MLXSW_REG_PERERP_LEN];",
          "458:          erp_table->base_index, 0);",
          "459:  mlxsw_reg_pererp_erp_vector_pack(pererp_pl, erp_table->erp_index_bitmap,",
          "460:       MLXSW_SP_ACL_ERP_MAX_PER_REGION);",
          "",
          "[Removed Lines]",
          "451: mlxsw_sp_acl_erp_table_enable(struct mlxsw_sp_acl_erp_table *erp_table)",
          "457:  mlxsw_reg_pererp_pack(pererp_pl, region->id, false, true, 0,",
          "",
          "[Added Lines]",
          "453: mlxsw_sp_acl_erp_table_enable(struct mlxsw_sp_acl_erp_table *erp_table,",
          "454:          bool ctcam_le)",
          "460:  mlxsw_reg_pererp_pack(pererp_pl, region->id, ctcam_le, true, 0,",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "471:  struct mlxsw_sp_acl_erp *master_rp;",
          "473:  master_rp = mlxsw_sp_acl_erp_table_master_rp(erp_table);",
          "477:  mlxsw_reg_pererp_pack(pererp_pl, region->id, false, false, 0, 0,",
          "479:  mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(pererp), pererp_pl);",
          "480: }",
          "",
          "[Removed Lines]",
          "474:  if (!master_rp)",
          "475:   return;",
          "478:          master_rp->id);",
          "",
          "[Added Lines]",
          "482:          master_rp ? master_rp->id : 0);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "506:  unsigned int num_erps, old_num_erps = erp_table->num_max_atcam_erps;",
          "507:  struct mlxsw_sp_acl_erp_core *erp_core = erp_table->erp_core;",
          "508:  unsigned long old_base_index = erp_table->base_index;",
          "509:  int err;",
          "511:  if (erp_table->num_atcam_erps < erp_table->num_max_atcam_erps)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "513:  bool ctcam_le = erp_table->num_ctcam_erps > 0;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "526:  if (err)",
          "527:   goto err_table_relocate;",
          "530:  if (err)",
          "531:   goto err_table_enable;",
          "",
          "[Removed Lines]",
          "529:  err = mlxsw_sp_acl_erp_table_enable(erp_table);",
          "",
          "[Added Lines]",
          "534:  err = mlxsw_sp_acl_erp_table_enable(erp_table, ctcam_le);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "579:  if (err)",
          "580:   goto err_table_master_rp_add;",
          "583:  if (err)",
          "584:   goto err_table_enable;",
          "",
          "[Removed Lines]",
          "582:  err = mlxsw_sp_acl_erp_table_enable(erp_table);",
          "",
          "[Added Lines]",
          "587:  err = mlxsw_sp_acl_erp_table_enable(erp_table, false);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "619: {",
          "620:  struct mlxsw_sp_acl_tcam_region *region = erp_table->aregion->region;",
          "621:  struct mlxsw_sp *mlxsw_sp = erp_table->erp_core->mlxsw_sp;",
          "622:  char pererp_pl[MLXSW_REG_PERERP_LEN];",
          "625:          erp_table->base_index, 0);",
          "626:  mlxsw_reg_pererp_erp_vector_pack(pererp_pl, erp_table->erp_index_bitmap,",
          "627:       MLXSW_SP_ACL_ERP_MAX_PER_REGION);",
          "",
          "[Removed Lines]",
          "624:  mlxsw_reg_pererp_pack(pererp_pl, region->id, false, true, 0,",
          "",
          "[Added Lines]",
          "627:  bool ctcam_le = erp_table->num_ctcam_erps > 0;",
          "630:  mlxsw_reg_pererp_pack(pererp_pl, region->id, ctcam_le, true, 0,",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "635:  struct mlxsw_sp_acl_erp_table *erp_table = erp->erp_table;",
          "636:  struct mlxsw_sp_acl_tcam_region *region = erp_table->aregion->region;",
          "637:  struct mlxsw_sp *mlxsw_sp = erp_table->erp_core->mlxsw_sp;",
          "638:  char pererp_pl[MLXSW_REG_PERERP_LEN];",
          "641:          erp_table->base_index, 0);",
          "642:  mlxsw_reg_pererp_erp_vector_pack(pererp_pl, erp_table->erp_index_bitmap,",
          "643:       MLXSW_SP_ACL_ERP_MAX_PER_REGION);",
          "",
          "[Removed Lines]",
          "640:  mlxsw_reg_pererp_pack(pererp_pl, region->id, false, true, 0,",
          "",
          "[Added Lines]",
          "644:  bool ctcam_le = erp_table->num_ctcam_erps > 0;",
          "647:  mlxsw_reg_pererp_pack(pererp_pl, region->id, ctcam_le, true, 0,",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "646:  mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(pererp), pererp_pl);",
          "647: }",
          "649: static struct mlxsw_sp_acl_erp *",
          "650: mlxsw_sp_acl_erp_mask_create(struct mlxsw_sp_acl_erp_table *erp_table,",
          "651:         struct mlxsw_sp_acl_erp_key *key)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "656: static int",
          "657: mlxsw_sp_acl_erp_region_ctcam_enable(struct mlxsw_sp_acl_erp_table *erp_table)",
          "658: {",
          "660:  if (erp_table->num_ctcam_erps > 1)",
          "661:   return 0;",
          "663:  return mlxsw_sp_acl_erp_table_enable(erp_table, true);",
          "664: }",
          "666: static void",
          "667: mlxsw_sp_acl_erp_region_ctcam_disable(struct mlxsw_sp_acl_erp_table *erp_table)",
          "668: {",
          "670:  if (erp_table->num_ctcam_erps > 1)",
          "671:   return;",
          "673:  mlxsw_sp_acl_erp_table_enable(erp_table, false);",
          "674: }",
          "676: static void",
          "677: mlxsw_sp_acl_erp_ctcam_table_ops_set(struct mlxsw_sp_acl_erp_table *erp_table)",
          "678: {",
          "679:  switch (erp_table->num_atcam_erps) {",
          "680:  case 2:",
          "685:   erp_table->ops = &erp_two_masks_ops;",
          "686:   break;",
          "687:  case 1:",
          "693:   mlxsw_sp_acl_erp_region_master_mask_trans(erp_table);",
          "694:   erp_table->ops = &erp_single_mask_ops;",
          "695:   break;",
          "696:  case 0:",
          "700:   mlxsw_sp_acl_erp_table_disable(erp_table);",
          "701:   mlxsw_sp_acl_erp_table_free(erp_table->erp_core,",
          "702:          erp_table->num_max_atcam_erps,",
          "703:          erp_table->aregion->type,",
          "704:          erp_table->base_index);",
          "705:   erp_table->ops = &erp_no_mask_ops;",
          "706:   break;",
          "707:  default:",
          "708:   break;",
          "709:  }",
          "710: }",
          "712: static struct mlxsw_sp_acl_erp *",
          "713: __mlxsw_sp_acl_erp_ctcam_mask_create(struct mlxsw_sp_acl_erp_table *erp_table,",
          "714:          struct mlxsw_sp_acl_erp_key *key)",
          "715: {",
          "716:  struct mlxsw_sp_acl_erp *erp;",
          "717:  int err;",
          "719:  erp = kzalloc(sizeof(*erp), GFP_KERNEL);",
          "720:  if (!erp)",
          "721:   return ERR_PTR(-ENOMEM);",
          "723:  memcpy(&erp->key, key, sizeof(*key));",
          "724:  bitmap_from_arr32(erp->mask_bitmap, (u32 *) key->mask,",
          "725:      MLXSW_SP_ACL_TCAM_MASK_LEN);",
          "726:  refcount_set(&erp->refcnt, 1);",
          "727:  erp_table->num_ctcam_erps++;",
          "728:  erp->erp_table = erp_table;",
          "730:  err = mlxsw_sp_acl_erp_master_mask_set(erp_table, erp);",
          "731:  if (err)",
          "732:   goto err_master_mask_set;",
          "734:  err = rhashtable_insert_fast(&erp_table->erp_ht, &erp->ht_node,",
          "735:          mlxsw_sp_acl_erp_ht_params);",
          "736:  if (err)",
          "737:   goto err_rhashtable_insert;",
          "739:  err = mlxsw_sp_acl_erp_region_ctcam_enable(erp_table);",
          "740:  if (err)",
          "741:   goto err_erp_region_ctcam_enable;",
          "744:  erp_table->ops = &erp_multiple_masks_ops;",
          "746:  return erp;",
          "748: err_erp_region_ctcam_enable:",
          "749:  rhashtable_remove_fast(&erp_table->erp_ht, &erp->ht_node,",
          "750:           mlxsw_sp_acl_erp_ht_params);",
          "751: err_rhashtable_insert:",
          "752:  mlxsw_sp_acl_erp_master_mask_clear(erp_table, erp);",
          "753: err_master_mask_set:",
          "754:  erp_table->num_ctcam_erps--;",
          "755:  kfree(erp);",
          "756:  return ERR_PTR(err);",
          "757: }",
          "759: static struct mlxsw_sp_acl_erp *",
          "760: mlxsw_sp_acl_erp_ctcam_mask_create(struct mlxsw_sp_acl_erp_table *erp_table,",
          "761:        struct mlxsw_sp_acl_erp_key *key)",
          "762: {",
          "763:  struct mlxsw_sp_acl_erp *erp;",
          "764:  int err;",
          "773:  err = mlxsw_sp_acl_erp_region_table_trans(erp_table);",
          "774:  if (err)",
          "775:   return ERR_PTR(err);",
          "777:  erp = __mlxsw_sp_acl_erp_ctcam_mask_create(erp_table, key);",
          "778:  if (IS_ERR(erp)) {",
          "779:   err = PTR_ERR(erp);",
          "780:   goto err_erp_create;",
          "781:  }",
          "783:  return erp;",
          "785: err_erp_create:",
          "786:  mlxsw_sp_acl_erp_region_master_mask_trans(erp_table);",
          "787:  return ERR_PTR(err);",
          "788: }",
          "790: static void",
          "791: mlxsw_sp_acl_erp_ctcam_mask_destroy(struct mlxsw_sp_acl_erp *erp)",
          "792: {",
          "793:  struct mlxsw_sp_acl_erp_table *erp_table = erp->erp_table;",
          "795:  mlxsw_sp_acl_erp_region_ctcam_disable(erp_table);",
          "796:  rhashtable_remove_fast(&erp_table->erp_ht, &erp->ht_node,",
          "797:           mlxsw_sp_acl_erp_ht_params);",
          "798:  mlxsw_sp_acl_erp_master_mask_clear(erp_table, erp);",
          "799:  erp_table->num_ctcam_erps--;",
          "800:  kfree(erp);",
          "806:  if (erp_table->num_ctcam_erps > 0)",
          "807:   return;",
          "808:  mlxsw_sp_acl_erp_ctcam_table_ops_set(erp_table);",
          "809: }",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "653:  struct mlxsw_sp_acl_erp *erp;",
          "654:  int err;",
          "657:  err = mlxsw_sp_acl_erp_table_expand(erp_table);",
          "658:  if (err)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "818:  if (key->ctcam)",
          "819:   return __mlxsw_sp_acl_erp_ctcam_mask_create(erp_table, key);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "691: mlxsw_sp_acl_erp_mask_destroy(struct mlxsw_sp_acl_erp_table *erp_table,",
          "692:          struct mlxsw_sp_acl_erp *erp)",
          "693: {",
          "694:  mlxsw_sp_acl_erp_region_erp_del(erp);",
          "695:  mlxsw_sp_acl_erp_table_erp_del(erp);",
          "696:  mlxsw_sp_acl_erp_index_put(erp_table, erp->index);",
          "697:  mlxsw_sp_acl_erp_generic_destroy(erp);",
          "700:   erp_table->ops = &erp_two_masks_ops;",
          "701: }",
          "",
          "[Removed Lines]",
          "699:  if (erp_table->num_atcam_erps == 2)",
          "",
          "[Added Lines]",
          "859:  if (erp->key.ctcam)",
          "860:   return mlxsw_sp_acl_erp_ctcam_mask_destroy(erp);",
          "867:  if (erp_table->num_atcam_erps == 2 && erp_table->num_ctcam_erps == 0)",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "707:  struct mlxsw_sp_acl_erp *erp;",
          "708:  int err;",
          "711:  err = mlxsw_sp_acl_erp_region_table_trans(erp_table);",
          "712:  if (err)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "878:  if (key->ctcam)",
          "879:   return mlxsw_sp_acl_erp_ctcam_mask_create(erp_table, key);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "749: mlxsw_sp_acl_erp_second_mask_destroy(struct mlxsw_sp_acl_erp_table *erp_table,",
          "750:          struct mlxsw_sp_acl_erp *erp)",
          "751: {",
          "752:  mlxsw_sp_acl_erp_region_erp_del(erp);",
          "753:  mlxsw_sp_acl_erp_table_erp_del(erp);",
          "754:  mlxsw_sp_acl_erp_index_put(erp_table, erp->index);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "923:  if (erp->key.ctcam)",
          "924:   return mlxsw_sp_acl_erp_ctcam_mask_destroy(erp);",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "765: {",
          "766:  struct mlxsw_sp_acl_erp *erp;",
          "768:  erp = mlxsw_sp_acl_erp_generic_create(erp_table, key);",
          "769:  if (IS_ERR(erp))",
          "770:   return erp;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "942:  if (key->ctcam)",
          "943:   return ERR_PTR(-EINVAL);",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "792: struct mlxsw_sp_acl_erp *",
          "793: mlxsw_sp_acl_erp_get(struct mlxsw_sp_acl_atcam_region *aregion,",
          "795: {",
          "796:  struct mlxsw_sp_acl_erp_table *erp_table = aregion->erp_table;",
          "797:  struct mlxsw_sp_acl_erp_key key;",
          "",
          "[Removed Lines]",
          "794:        const char *mask)",
          "",
          "[Added Lines]",
          "971:        const char *mask, bool ctcam)",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "803:  ASSERT_RTNL();",
          "805:  memcpy(key.mask, mask, MLXSW_REG_PTCEX_FLEX_KEY_BLOCKS_LEN);",
          "806:  erp = rhashtable_lookup_fast(&erp_table->erp_ht, &key,",
          "807:          mlxsw_sp_acl_erp_ht_params);",
          "808:  if (erp) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "983:  key.ctcam = ctcam;",
          "",
          "---------------"
        ],
        "drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_tcam.h||drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_tcam.h": [
          "File: drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_tcam.h -> drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_tcam.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "179: u8 mlxsw_sp_acl_erp_id(const struct mlxsw_sp_acl_erp *erp);",
          "180: struct mlxsw_sp_acl_erp *",
          "181: mlxsw_sp_acl_erp_get(struct mlxsw_sp_acl_atcam_region *aregion,",
          "183: void mlxsw_sp_acl_erp_put(struct mlxsw_sp_acl_atcam_region *aregion,",
          "184:      struct mlxsw_sp_acl_erp *erp);",
          "185: int mlxsw_sp_acl_erp_region_init(struct mlxsw_sp_acl_atcam_region *aregion);",
          "",
          "[Removed Lines]",
          "182:        const char *mask);",
          "",
          "[Added Lines]",
          "182:        const char *mask, bool ctcam);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "10d255c3540239c7920f52d2eb223756e186af56",
      "candidate_info": {
        "commit_hash": "10d255c3540239c7920f52d2eb223756e186af56",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/10d255c3540239c7920f52d2eb223756e186af56",
        "files": [
          "fs/f2fs/gc.c"
        ],
        "message": "f2fs: fix to skip GC if type in SSA and SIT is inconsistent\n\nIf segment type in SSA and SIT is inconsistent, we will encounter below\nBUG_ON during GC, to avoid this panic, let's just skip doing GC on such\nsegment.\n\nThe bug is triggered with image reported in below link:\n\nhttps://bugzilla.kernel.org/show_bug.cgi?id=200223\n\n[  388.060262] ------------[ cut here ]------------\n[  388.060268] kernel BUG at /home/y00370721/git/devf2fs/gc.c:989!\n[  388.061172] invalid opcode: 0000 [#1] SMP\n[  388.061773] Modules linked in: f2fs(O) bluetooth ecdh_generic xt_tcpudp iptable_filter ip_tables x_tables lp ttm drm_kms_helper drm intel_rapl sb_edac crct10dif_pclmul crc32_pclmul ghash_clmulni_intel pcbc aesni_intel fb_sys_fops ppdev aes_x86_64 syscopyarea crypto_simd sysfillrect parport_pc joydev sysimgblt glue_helper parport cryptd i2c_piix4 serio_raw mac_hid btrfs hid_generic usbhid hid raid6_pq psmouse pata_acpi floppy\n[  388.064247] CPU: 7 PID: 4151 Comm: f2fs_gc-7:0 Tainted: G           O    4.13.0-rc1+ #26\n[  388.065306] Hardware name: Xen HVM domU, BIOS 4.1.2_115-900.260_ 11/06/2015\n[  388.066058] task: ffff880201583b80 task.stack: ffffc90004d7c000\n[  388.069948] RIP: 0010:do_garbage_collect+0xcc8/0xcd0 [f2fs]\n[  388.070766] RSP: 0018:ffffc90004d7fc68 EFLAGS: 00010202\n[  388.071783] RAX: ffff8801ed227000 RBX: 0000000000000001 RCX: ffffea0007b489c0\n[  388.072700] RDX: ffff880000000000 RSI: 0000000000000001 RDI: ffffea0007b489c0\n[  388.073607] RBP: ffffc90004d7fd58 R08: 0000000000000003 R09: ffffea0007b489dc\n[  388.074619] R10: 0000000000000000 R11: 0052782ab317138d R12: 0000000000000018\n[  388.075625] R13: 0000000000000018 R14: ffff880211ceb000 R15: ffff880211ceb000\n[  388.076687] FS:  0000000000000000(0000) GS:ffff880214fc0000(0000) knlGS:0000000000000000\n[  388.083277] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  388.084536] CR2: 0000000000e18c60 CR3: 00000001ecf2e000 CR4: 00000000001406e0\n[  388.085748] Call Trace:\n[  388.086690]  ? find_next_bit+0xb/0x10\n[  388.088091]  f2fs_gc+0x1a8/0x9d0 [f2fs]\n[  388.088888]  ? lock_timer_base+0x7d/0xa0\n[  388.090213]  ? try_to_del_timer_sync+0x44/0x60\n[  388.091698]  gc_thread_func+0x342/0x4b0 [f2fs]\n[  388.092892]  ? wait_woken+0x80/0x80\n[  388.094098]  kthread+0x109/0x140\n[  388.095010]  ? f2fs_gc+0x9d0/0x9d0 [f2fs]\n[  388.096043]  ? kthread_park+0x60/0x60\n[  388.097281]  ret_from_fork+0x25/0x30\n[  388.098401] Code: ff ff 48 83 e8 01 48 89 44 24 58 e9 27 f8 ff ff 48 83 e8 01 e9 78 fc ff ff 48 8d 78 ff e9 17 fb ff ff 48 83 ef 01 e9 4d f4 ff ff <0f> 0b 66 0f 1f 44 00 00 0f 1f 44 00 00 55 48 89 e5 41 56 41 55\n[  388.100864] RIP: do_garbage_collect+0xcc8/0xcd0 [f2fs] RSP: ffffc90004d7fc68\n[  388.101810] ---[ end trace 81c73d6e6b7da61d ]---\n\nSigned-off-by: Chao Yu <yuchao0@huawei.com>\nSigned-off-by: Jaegeuk Kim <jaegeuk@kernel.org>",
        "before_after_code_files": [
          "fs/f2fs/gc.c||fs/f2fs/gc.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "fs/f2fs/gc.c||fs/f2fs/gc.c": [
          "File: fs/f2fs/gc.c -> fs/f2fs/gc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "986:    goto next;",
          "988:   sum = page_address(sum_page);",
          "",
          "[Removed Lines]",
          "989:   f2fs_bug_on(sbi, type != GET_SUM_TYPE((&sum->footer)));",
          "",
          "[Added Lines]",
          "989:   if (type != GET_SUM_TYPE((&sum->footer))) {",
          "990:    f2fs_msg(sbi->sb, KERN_ERR, \"Inconsistent segment (%u) \"",
          "991:     \"type [%d, %d] in SSA and SIT\",",
          "992:     segno, type, GET_SUM_TYPE((&sum->footer)));",
          "993:    set_sbi_flag(sbi, SBI_NEED_FSCK);",
          "994:    goto next;",
          "995:   }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b512719f771a82180211c9a315b8a7f628832b3d",
      "candidate_info": {
        "commit_hash": "b512719f771a82180211c9a315b8a7f628832b3d",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/b512719f771a82180211c9a315b8a7f628832b3d",
        "files": [
          "include/linux/delayacct.h"
        ],
        "message": "delayacct: fix crash in delayacct_blkio_end() after delayacct init failure\n\nWhile forking, if delayacct init fails due to memory shortage, it\ncontinues expecting all delayacct users to check task->delays pointer\nagainst NULL before dereferencing it, which all of them used to do.\n\nCommit c96f5471ce7d (\"delayacct: Account blkio completion on the correct\ntask\"), while updating delayacct_blkio_end() to take the target task\ninstead of always using %current, made the function test NULL on\n%current->delays and then continue to operated on @p->delays.  If\n%current succeeded init while @p didn't, it leads to the following\ncrash.\n\n BUG: unable to handle kernel NULL pointer dereference at 0000000000000004\n IP: __delayacct_blkio_end+0xc/0x40\n PGD 8000001fd07e1067 P4D 8000001fd07e1067 PUD 1fcffbb067 PMD 0\n Oops: 0000 [#1] SMP PTI\n CPU: 4 PID: 25774 Comm: QIOThread0 Not tainted 4.16.0-9_fbk1_rc2_1180_g6b593215b4d7 #9\n RIP: 0010:__delayacct_blkio_end+0xc/0x40\n Call Trace:\n  try_to_wake_up+0x2c0/0x600\n  autoremove_wake_function+0xe/0x30\n  __wake_up_common+0x74/0x120\n  wake_up_page_bit+0x9c/0xe0\n  mpage_end_io+0x27/0x70\n  blk_update_request+0x78/0x2c0\n  scsi_end_request+0x2c/0x1e0\n  scsi_io_completion+0x20b/0x5f0\n  blk_mq_complete_request+0xa2/0x100\n  ata_scsi_qc_complete+0x79/0x400\n  ata_qc_complete_multiple+0x86/0xd0\n  ahci_handle_port_interrupt+0xc9/0x5c0\n  ahci_handle_port_intr+0x54/0xb0\n  ahci_single_level_irq_intr+0x3b/0x60\n  __handle_irq_event_percpu+0x43/0x190\n  handle_irq_event_percpu+0x20/0x50\n  handle_irq_event+0x2a/0x50\n  handle_edge_irq+0x80/0x1c0\n  handle_irq+0xaf/0x120\n  do_IRQ+0x41/0xc0\n  common_interrupt+0xf/0xf\n\nFix it by updating delayacct_blkio_end() check @p->delays instead.\n\nLink: http://lkml.kernel.org/r/20180724175542.GP1934745@devbig577.frc2.facebook.com\nFixes: c96f5471ce7d (\"delayacct: Account blkio completion on the correct task\")\nSigned-off-by: Tejun Heo <tj@kernel.org>\nReported-by: Dave Jones <dsj@fb.com>\nDebugged-by: Dave Jones <dsj@fb.com>\nReviewed-by: Andrew Morton <akpm@linux-foundation.org>\nCc: Josh Snyder <joshs@netflix.com>\nCc: <stable@vger.kernel.org>\t[4.15+]\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "include/linux/delayacct.h||include/linux/delayacct.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "include/linux/delayacct.h||include/linux/delayacct.h": [
          "File: include/linux/delayacct.h -> include/linux/delayacct.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "125: static inline void delayacct_blkio_end(struct task_struct *p)",
          "126: {",
          "128:   __delayacct_blkio_end(p);",
          "129:  delayacct_clear_flag(DELAYACCT_PF_BLKIO);",
          "130: }",
          "",
          "[Removed Lines]",
          "127:  if (current->delays)",
          "",
          "[Added Lines]",
          "127:  if (p->delays)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "1863c387259b629e4ebfb255495f67cd06aa229b",
      "candidate_info": {
        "commit_hash": "1863c387259b629e4ebfb255495f67cd06aa229b",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/1863c387259b629e4ebfb255495f67cd06aa229b",
        "files": [
          "kernel/trace/trace_events_trigger.c"
        ],
        "message": "tracing: Fix double free of event_trigger_data\n\nRunning the following:\n\n # cd /sys/kernel/debug/tracing\n # echo 500000 > buffer_size_kb\n[ Or some other number that takes up most of memory ]\n # echo snapshot > events/sched/sched_switch/trigger\n\nTriggers the following bug:\n\n ------------[ cut here ]------------\n kernel BUG at mm/slub.c:296!\n invalid opcode: 0000 [#1] SMP DEBUG_PAGEALLOC PTI\n CPU: 6 PID: 6878 Comm: bash Not tainted 4.18.0-rc6-test+ #1066\n Hardware name: Hewlett-Packard HP Compaq Pro 6300 SFF/339A, BIOS K01 v03.03 07/14/2016\n RIP: 0010:kfree+0x16c/0x180\n Code: 05 41 0f b6 72 51 5b 5d 41 5c 4c 89 d7 e9 ac b3 f8 ff 48 89 d9 48 89 da 41 b8 01 00 00 00 5b 5d 41 5c 4c 89 d6 e9 f4 f3 ff ff <0f> 0b 0f 0b 48 8b 3d d9 d8 f9 00 e9 c1 fe ff ff 0f 1f 40 00 0f 1f\n RSP: 0018:ffffb654436d3d88 EFLAGS: 00010246\n RAX: ffff91a9d50f3d80 RBX: ffff91a9d50f3d80 RCX: ffff91a9d50f3d80\n RDX: 00000000000006a4 RSI: ffff91a9de5a60e0 RDI: ffff91a9d9803500\n RBP: ffffffff8d267c80 R08: 00000000000260e0 R09: ffffffff8c1a56be\n R10: fffff0d404543cc0 R11: 0000000000000389 R12: ffffffff8c1a56be\n R13: ffff91a9d9930e18 R14: ffff91a98c0c2890 R15: ffffffff8d267d00\n FS:  00007f363ea64700(0000) GS:ffff91a9de580000(0000) knlGS:0000000000000000\n CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n CR2: 000055c1cacc8e10 CR3: 00000000d9b46003 CR4: 00000000001606e0\n Call Trace:\n  event_trigger_callback+0xee/0x1d0\n  event_trigger_write+0xfc/0x1a0\n  __vfs_write+0x33/0x190\n  ? handle_mm_fault+0x115/0x230\n  ? _cond_resched+0x16/0x40\n  vfs_write+0xb0/0x190\n  ksys_write+0x52/0xc0\n  do_syscall_64+0x5a/0x160\n  entry_SYSCALL_64_after_hwframe+0x49/0xbe\n RIP: 0033:0x7f363e16ab50\n Code: 73 01 c3 48 8b 0d 38 83 2c 00 f7 d8 64 89 01 48 83 c8 ff c3 66 0f 1f 44 00 00 83 3d 79 db 2c 00 00 75 10 b8 01 00 00 00 0f 05 <48> 3d 01 f0 ff ff 73 31 c3 48 83 ec 08 e8 1e e3 01 00 48 89 04 24\n RSP: 002b:00007fff9a4c6378 EFLAGS: 00000246 ORIG_RAX: 0000000000000001\n RAX: ffffffffffffffda RBX: 0000000000000009 RCX: 00007f363e16ab50\n RDX: 0000000000000009 RSI: 000055c1cacc8e10 RDI: 0000000000000001\n RBP: 000055c1cacc8e10 R08: 00007f363e435740 R09: 00007f363ea64700\n R10: 0000000000000073 R11: 0000000000000246 R12: 0000000000000009\n R13: 0000000000000001 R14: 00007f363e4345e0 R15: 00007f363e4303c0\n Modules linked in: ip6table_filter ip6_tables snd_hda_codec_hdmi snd_hda_codec_realtek snd_hda_codec_generic snd_hda_intel snd_hda_codec snd_hwdep snd_hda_core snd_seq snd_seq_device i915 snd_pcm snd_timer i2c_i801 snd soundcore i2c_algo_bit drm_kms_helper\n86_pkg_temp_thermal video kvm_intel kvm irqbypass wmi e1000e\n ---[ end trace d301afa879ddfa25 ]---\n\nThe cause is because the register_snapshot_trigger() call failed to\nallocate the snapshot buffer, and then called unregister_trigger()\nwhich freed the data that was passed to it. Then on return to the\nfunction that called register_snapshot_trigger(), as it sees it\nfailed to register, it frees the trigger_data again and causes\na double free.\n\nBy calling event_trigger_init() on the trigger_data (which only ups\nthe reference counter for it), and then event_trigger_free() afterward,\nthe trigger_data would not get freed by the registering trigger function\nas it would only up and lower the ref count for it. If the register\ntrigger function fails, then the event_trigger_free() called after it\nwill free the trigger data normally.\n\nLink: http://lkml.kernel.org/r/20180724191331.738eb819@gandalf.local.home\n\nCc: stable@vger.kerne.org\nFixes: 93e31ffbf417 (\"tracing: Add 'snapshot' event trigger command\")\nReported-by: Masami Hiramatsu <mhiramat@kernel.org>\nReviewed-by: Masami Hiramatsu <mhiramat@kernel.org>\nSigned-off-by: Steven Rostedt (VMware) <rostedt@goodmis.org>",
        "before_after_code_files": [
          "kernel/trace/trace_events_trigger.c||kernel/trace/trace_events_trigger.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "kernel/trace/trace_events_trigger.c||kernel/trace/trace_events_trigger.c": [
          "File: kernel/trace/trace_events_trigger.c -> kernel/trace/trace_events_trigger.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "679:   goto out_free;",
          "681:  out_reg:",
          "682:  ret = cmd_ops->reg(glob, trigger_ops, trigger_data, file);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "683:  event_trigger_init(trigger_ops, trigger_data);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "688:  if (!ret) {",
          "689:   ret = -ENOENT;",
          "694:  out:",
          "695:  return ret;",
          "",
          "[Removed Lines]",
          "690:   goto out_free;",
          "691:  } else if (ret < 0)",
          "692:   goto out_free;",
          "693:  ret = 0;",
          "",
          "[Added Lines]",
          "691:   cmd_ops->unreg(glob, trigger_ops, trigger_data, file);",
          "693:  } else if (ret > 0)",
          "694:   ret = 0;",
          "697:  event_trigger_free(trigger_ops, trigger_data);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2019-20218",
  "cve_desc": "selectExpander in select.c in SQLite 3.30.1 proceeds with WITH stack unwinding even after a parsing error.",
  "repo": "sqlite/sqlite",
  "patch_hash": "a6c1a71cde082e09750465d5675699062922e387",
  "patch_info": {
    "commit_hash": "a6c1a71cde082e09750465d5675699062922e387",
    "repo": "sqlite/sqlite",
    "commit_url": "https://github.com/sqlite/sqlite/commit/a6c1a71cde082e09750465d5675699062922e387",
    "files": [
      "manifest",
      "manifest.uuid",
      "src/select.c",
      "test/altertab3.test"
    ],
    "message": "Do not attempt to unwind the WITH stack in the Parse object following an error. This fixes a separate case to [de6e6d68].\n\nFossilOrigin-Name: d29edef93451cc67a5d69c1cce1b1832d9ca8fff1f600afdd51338b74d077b92",
    "before_after_code_files": [
      "manifest.uuid||manifest.uuid",
      "src/select.c||src/select.c",
      "test/altertab3.test||test/altertab3.test"
    ]
  },
  "patch_diff": {
    "manifest.uuid||manifest.uuid": [
      "File: manifest.uuid -> manifest.uuid",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "1: 597896ed0ae9e2960a8f39576bd7f77a11dccc1da84b6a44ebb5c38d90ebc330",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "src/select.c||src/select.c": [
      "File: src/select.c -> src/select.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "4982:     return WRC_Abort;",
      "4983:   }",
      "",
      "[Removed Lines]",
      "4981:   if( db->mallocFailed || sqliteProcessJoin(pParse, p) ){",
      "",
      "[Added Lines]",
      "4981:   if( pParse->nErr || db->mallocFailed || sqliteProcessJoin(pParse, p) ){",
      "",
      "---------------"
    ],
    "test/altertab3.test||test/altertab3.test": [
      "File: test/altertab3.test -> test/altertab3.test",
      "--- Hunk 1 ---",
      "[Context before]",
      "531:   ALTER TABLE t1 RENAME TO t1x;",
      "532: } {1 {error in trigger r1: no such table: main.t2}}",
      "534: finish_test",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "534: #------------------------------------------------------------------------",
      "535: #",
      "536: reset_db",
      "537: do_execsql_test 23.1 {",
      "538:   CREATE TABLE v0 (a);",
      "539:   CREATE VIEW v2 (v3) AS",
      "540:     WITH x1 AS (SELECT * FROM v2)",
      "541:     SELECT v3 AS x, v3 AS y FROM v2;",
      "542: }",
      "544: do_catchsql_test 23.2 {",
      "545:   SELECT * FROM v2",
      "546: } {1 {view v2 is circularly defined}}",
      "548: db close",
      "549: sqlite3 db test.db",
      "551: do_catchsql_test 23.3 {",
      "552:   ALTER TABLE v0 RENAME TO t3 ;",
      "553: } {1 {error in view v2: view v2 is circularly defined}}",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "4ead96348e5aacfcf480aae141d0ab8dccfa4760",
      "candidate_info": {
        "commit_hash": "4ead96348e5aacfcf480aae141d0ab8dccfa4760",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/4ead96348e5aacfcf480aae141d0ab8dccfa4760",
        "files": [
          "ext/misc/prefixes.c",
          "manifest",
          "manifest.uuid"
        ],
        "message": "Add the \"prefixes\" table-valued function in the ext/misc folder.\n\nFossilOrigin-Name: f0fd2163fc23a555ef03af43294a14fcabae6921f52e64c979286c745b4f6218",
        "before_after_code_files": [
          "ext/misc/prefixes.c||ext/misc/prefixes.c",
          "manifest.uuid||manifest.uuid"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "ext/misc/prefixes.c||ext/misc/prefixes.c": [
          "File: ext/misc/prefixes.c -> ext/misc/prefixes.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "22: #if !defined(SQLITEINT_H)",
          "23: #include \"sqlite3ext.h\"",
          "24: #endif",
          "25: SQLITE_EXTENSION_INIT1",
          "26: #include <string.h>",
          "27: #include <assert.h>",
          "32: typedef struct prefixes_vtab prefixes_vtab;",
          "33: struct prefixes_vtab {",
          "36: };",
          "42: typedef struct prefixes_cursor prefixes_cursor;",
          "43: struct prefixes_cursor {",
          "48: };",
          "63: static int prefixesConnect(",
          "64:   sqlite3 *db,",
          "65:   void *pAux,",
          "66:   int argc, const char *const*argv,",
          "67:   sqlite3_vtab **ppVtab,",
          "68:   char **pzErr",
          "69: ){",
          "70:   prefixes_vtab *pNew;",
          "71:   int rc;",
          "73:   rc = sqlite3_declare_vtab(db,",
          "74:            \"CREATE TABLE prefixes(prefix TEXT, original_string TEXT HIDDEN)\"",
          "75:        );",
          "76:   if( rc==SQLITE_OK ){",
          "77:     pNew = sqlite3_malloc( sizeof(*pNew) );",
          "79:     if( pNew==0 ) return SQLITE_NOMEM;",
          "80:     memset(pNew, 0, sizeof(*pNew));",
          "81:   }",
          "82:   return rc;",
          "83: }",
          "88: static int prefixesDisconnect(sqlite3_vtab *pVtab){",
          "89:   prefixes_vtab *p = (prefixes_vtab*)pVtab;",
          "90:   sqlite3_free(p);",
          "91:   return SQLITE_OK;",
          "92: }",
          "97: static int prefixesOpen(sqlite3_vtab *p, sqlite3_vtab_cursor **ppCursor){",
          "98:   prefixes_cursor *pCur;",
          "99:   pCur = sqlite3_malloc( sizeof(*pCur) );",
          "100:   if( pCur==0 ) return SQLITE_NOMEM;",
          "101:   memset(pCur, 0, sizeof(*pCur));",
          "103:   return SQLITE_OK;",
          "104: }",
          "109: static int prefixesClose(sqlite3_vtab_cursor *cur){",
          "110:   prefixes_cursor *pCur = (prefixes_cursor*)cur;",
          "111:   sqlite3_free(pCur->zStr);",
          "112:   sqlite3_free(pCur);",
          "113:   return SQLITE_OK;",
          "114: }",
          "120: static int prefixesNext(sqlite3_vtab_cursor *cur){",
          "121:   prefixes_cursor *pCur = (prefixes_cursor*)cur;",
          "122:   pCur->iRowid++;",
          "123:   return SQLITE_OK;",
          "124: }",
          "130: static int prefixesColumn(",
          "134: ){",
          "135:   prefixes_cursor *pCur = (prefixes_cursor*)cur;",
          "136:   switch( i ){",
          "137:     case 0:",
          "138:       sqlite3_result_text(ctx, pCur->zStr, pCur->nStr - (int)pCur->iRowid,",
          "139:                           0);",
          "140:       break;",
          "141:     default:",
          "142:       sqlite3_result_text(ctx, pCur->zStr, pCur->nStr, 0);",
          "143:       break;",
          "144:   }",
          "145:   return SQLITE_OK;",
          "146: }",
          "152: static int prefixesRowid(sqlite3_vtab_cursor *cur, sqlite_int64 *pRowid){",
          "153:   prefixes_cursor *pCur = (prefixes_cursor*)cur;",
          "155:   return SQLITE_OK;",
          "156: }",
          "162: static int prefixesEof(sqlite3_vtab_cursor *cur){",
          "163:   prefixes_cursor *pCur = (prefixes_cursor*)cur;",
          "164:   return pCur->iRowid>pCur->nStr;",
          "165: }",
          "173: static int prefixesFilter(",
          "174:   sqlite3_vtab_cursor *pVtabCursor,",
          "175:   int idxNum, const char *idxStr,",
          "176:   int argc, sqlite3_value **argv",
          "177: ){",
          "178:   prefixes_cursor *pCur = (prefixes_cursor *)pVtabCursor;",
          "179:   sqlite3_free(pCur->zStr);",
          "180:   if( argc>0 ){",
          "181:     pCur->zStr = sqlite3_mprintf(\"%s\", sqlite3_value_text(argv[0]));",
          "182:     pCur->nStr = pCur->zStr ? (int)strlen(pCur->zStr) : 0;",
          "183:   }else{",
          "184:     pCur->zStr = 0;",
          "185:     pCur->nStr = 0;",
          "186:   }",
          "187:   pCur->iRowid = 0;",
          "188:   return SQLITE_OK;",
          "189: }",
          "197: static int prefixesBestIndex(",
          "198:   sqlite3_vtab *tab,",
          "199:   sqlite3_index_info *pIdxInfo",
          "200: ){",
          "203:   int i;",
          "204:   const struct sqlite3_index_constraint *p;",
          "206:   for(i=0, p=pIdxInfo->aConstraint; i<pIdxInfo->nConstraint; i++, p++){",
          "207:     if( p->iColumn!=1 ) continue;",
          "208:     if( p->op!=SQLITE_INDEX_CONSTRAINT_EQ ) continue;",
          "209:     if( !p->usable ) continue;",
          "210:     pIdxInfo->aConstraintUsage[i].argvIndex = 1;",
          "211:     pIdxInfo->aConstraintUsage[i].omit = 1;",
          "212:     pIdxInfo->estimatedCost = (double)10;",
          "213:     pIdxInfo->estimatedRows = 10;",
          "214:     return SQLITE_OK;",
          "215:   }",
          "216:   pIdxInfo->estimatedCost = (double)1000000000;",
          "217:   pIdxInfo->estimatedRows = 1000000000;",
          "218:   return SQLITE_OK;",
          "219: }",
          "225: static sqlite3_module prefixesModule = {",
          "250: };",
          "253: #ifdef _WIN32",
          "254: __declspec(dllexport)",
          "255: #endif",
          "256: int sqlite3_prefixes_init(",
          "257:   sqlite3 *db,",
          "258:   char **pzErrMsg,",
          "259:   const sqlite3_api_routines *pApi",
          "260: ){",
          "261:   int rc = SQLITE_OK;",
          "262:   SQLITE_EXTENSION_INIT2(pApi);",
          "263:   rc = sqlite3_create_module(db, \"prefixes\", &prefixesModule, 0);",
          "264:   return rc;",
          "265: }",
          "",
          "---------------"
        ],
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 9cd64ce453e4435d80117b8610c22a0a4b53cd6e84b39815e70e684f6b0295c8",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "8654186b0236d556aa85528c2573ee0b6ab71be3",
      "candidate_info": {
        "commit_hash": "8654186b0236d556aa85528c2573ee0b6ab71be3",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/8654186b0236d556aa85528c2573ee0b6ab71be3",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/expr.c",
          "src/vdbeaux.c",
          "src/window.c"
        ],
        "message": "When an error occurs while rewriting the parser tree for window functions in the sqlite3WindowRewrite() routine, make sure that pParse->nErr is set, and make sure that this shuts down any subsequent code generation that might depend on the transformations that were implemented.  This fixes a problem discovered by the Yongheng and Rui fuzzer.\n\nFossilOrigin-Name: e2bddcd4c55ba3cbe0130332679ff4b048630d0ced9a8899982edb5a3569ba7f",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/expr.c||src/expr.c",
          "src/vdbeaux.c||src/vdbeaux.c",
          "src/window.c||src/window.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 4417c5bf0aabb34ed174f01afd981c924ae965a42128719d8d6735536631d12f",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/expr.c||src/expr.c": [
          "File: src/expr.c -> src/expr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "376:   int addr;",
          "377:   CollSeq *p4;",
          "379:   if( isCommuted ){",
          "380:     p4 = sqlite3BinaryCompareCollSeq(pParse, pRight, pLeft);",
          "381:   }else{",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "379:   if( pParse->nErr ) return 0;",
          "",
          "---------------"
        ],
        "src/vdbeaux.c||src/vdbeaux.c": [
          "File: src/vdbeaux.c -> src/vdbeaux.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1304: static void vdbeVComment(Vdbe *p, const char *zFormat, va_list ap){",
          "1305:   assert( p->nOp>0 || p->aOp==0 );",
          "1307:   if( p->nOp ){",
          "1308:     assert( p->aOp );",
          "1309:     sqlite3DbFree(p->db, p->aOp[p->nOp-1].zComment);",
          "",
          "[Removed Lines]",
          "1306:   assert( p->aOp==0 || p->aOp[p->nOp-1].zComment==0 || p->db->mallocFailed );",
          "",
          "[Added Lines]",
          "1306:   assert( p->aOp==0 || p->aOp[p->nOp-1].zComment==0 || p->db->mallocFailed",
          "1307:           || p->pParse->nErr>0 );",
          "",
          "---------------"
        ],
        "src/window.c||src/window.c": [
          "File: src/window.c -> src/window.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "935:     pTab = sqlite3DbMallocZero(db, sizeof(Table));",
          "936:     if( pTab==0 ){",
          "938:     }",
          "940:     p->pSrc = 0;",
          "",
          "[Removed Lines]",
          "937:       return SQLITE_NOMEM;",
          "",
          "[Added Lines]",
          "937:       return sqlite3ErrorToParser(db, SQLITE_NOMEM);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1039:     sqlite3DbFree(db, pTab);",
          "1040:   }",
          "1042:   return rc;",
          "1043: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1042:   if( rc && pParse->nErr==0 ){",
          "1043:     assert( pParse->db->mallocFailed );",
          "1044:     return sqlite3ErrorToParser(pParse->db, SQLITE_NOMEM);",
          "1045:   }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "ad5536fca15959addf7f6a87785140d30cfc8b65",
      "candidate_info": {
        "commit_hash": "ad5536fca15959addf7f6a87785140d30cfc8b65",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/ad5536fca15959addf7f6a87785140d30cfc8b65",
        "files": [
          "ext/rbu/rbumisc.test",
          "ext/rbu/sqlite3rbu.c",
          "manifest",
          "manifest.uuid"
        ],
        "message": "Add another test case to cover a previously uncovered branch in the RBU module.\n\nFossilOrigin-Name: 30392985612c51d4583a905f8fe766f08cd31b86d0e30a977adc6a6705649e00",
        "before_after_code_files": [
          "ext/rbu/rbumisc.test||ext/rbu/rbumisc.test",
          "ext/rbu/sqlite3rbu.c||ext/rbu/sqlite3rbu.c",
          "manifest.uuid||manifest.uuid"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "ext/rbu/rbumisc.test||ext/rbu/rbumisc.test": [
          "File: ext/rbu/rbumisc.test -> ext/rbu/rbumisc.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "43:     INSERT INTO data_ VALUES(3, 3, 3, 0);",
          "44:     INSERT INTO dat VALUES(3, 3, 3, 0);",
          "45:   }",
          "46: } {}",
          "48: do_test 1.2 {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "46:   rbu close",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "50:   db eval { SELECT * FROM x1 }",
          "51: } {1 1 1 2 2 2}",
          "53: finish_test",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "54: do_test 1.3 {",
          "55:   db eval { DELETE FROM x1 }",
          "56:   sqlite3 rbu rbu.db",
          "57:   rbu eval { DELETE FROM rbu_state }",
          "58:   rbu close",
          "59:   step_rbu test.db rbu.db",
          "60:   db eval { SELECT * FROM x1 }",
          "61: } {1 1 1 2 2 2}",
          "63: do_test 1.4 {",
          "64:   db eval { DELETE FROM x1 }",
          "65:   sqlite3 rbu rbu.db",
          "66:   rbu eval { DELETE FROM rbu_state }",
          "67:   rbu close",
          "69:   sqlite3rbu rbu test.db rbu.db",
          "70:   rbu step",
          "71:   rbu step",
          "72:   rbu close",
          "74:   forcecopy test.db-oal test.db-wal",
          "75:   sqlite3rbu rbu test.db rbu.db",
          "76:   rbu step",
          "77:   list [catch { rbu close } msg] $msg",
          "78: } {1 {SQLITE_ERROR - cannot update wal mode database}}",
          "",
          "---------------"
        ],
        "ext/rbu/sqlite3rbu.c||ext/rbu/sqlite3rbu.c": [
          "File: ext/rbu/sqlite3rbu.c -> ext/rbu/sqlite3rbu.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "5051:   if( rc==SQLITE_OK && flags==SQLITE_ACCESS_EXISTS ){",
          "5052:     rbu_file *pDb = rbuFindMaindb(pRbuVfs, zPath, 1);",
          "5054:       if( *pResOut ){",
          "5055:         rc = SQLITE_CANTOPEN;",
          "5056:       }else{",
          "",
          "[Removed Lines]",
          "5053:     if( pDb && pDb->pRbu && pDb->pRbu->eStage==RBU_STAGE_OAL ){",
          "",
          "[Added Lines]",
          "5053:     if( pDb && pDb->pRbu->eStage==RBU_STAGE_OAL ){",
          "5054:       assert( pDb->pRbu );",
          "",
          "---------------"
        ],
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 740201107ae802c12b678e388ea524db01ad0eb70601c78490ad63eae0fe6cf1",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "dfa15270c4108fedd817a99751fc73d43d7fb29d",
      "candidate_info": {
        "commit_hash": "dfa15270c4108fedd817a99751fc73d43d7fb29d",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/dfa15270c4108fedd817a99751fc73d43d7fb29d",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/expr.c",
          "src/insert.c",
          "src/sqliteInt.h",
          "test/gencol1.test"
        ],
        "message": "Change the way generated columns are computed so that no column is computed inside branch code that might not be taken.  Ticket [4fc08501f4e56692]\n\nFossilOrigin-Name: 9e07b48934e9a972dcf62e3538b3b21ffa044c553feba0441675ac0bbe13bcb2",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/expr.c||src/expr.c",
          "src/insert.c||src/insert.c",
          "src/sqliteInt.h||src/sqliteInt.h",
          "test/gencol1.test||test/gencol1.test"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 7bc8205dd9c1657c736a9c6a1a90dd9dad442accfbb77d296eaae2c09ab46bd1",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/expr.c||src/expr.c": [
          "File: src/expr.c -> src/expr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3645:           iSrc = sqlite3TableColumnToStorage(pTab, iCol) - pParse->iSelfTab;",
          "3646: #ifndef SQLITE_OMIT_GENERATED_COLUMNS",
          "3647:           if( pCol->colFlags & COLFLAG_GENERATED ){",
          "3658:             return iSrc;",
          "3659:           }else",
          "",
          "[Removed Lines]",
          "3648:             if( pCol->colFlags & COLFLAG_BUSY ){",
          "3649:               sqlite3ErrorMsg(pParse, \"generated column loop on \\\"%s\\\"\",",
          "3650:                               pCol->zName);",
          "3651:               return 0;",
          "3652:             }",
          "3653:             pCol->colFlags |= COLFLAG_BUSY;",
          "3654:             if( pCol->colFlags & COLFLAG_NOTAVAIL ){",
          "3655:               sqlite3ExprCodeGeneratedColumn(pParse, pCol, iSrc);",
          "3656:             }",
          "3657:             pCol->colFlags &= ~(COLFLAG_BUSY|COLFLAG_NOTAVAIL);",
          "",
          "[Added Lines]",
          "3648:             sqlite3ExprCodeGeneratedColumn(pParse, pCol, iSrc);",
          "",
          "---------------"
        ],
        "src/insert.c||src/insert.c": [
          "File: src/insert.c -> src/insert.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "201:   return 0;",
          "202: }",
          "204: #ifndef SQLITE_OMIT_GENERATED_COLUMNS",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "207: static int exprColumnFlagUnion(Walker *pWalker, Expr *pExpr){",
          "208:   if( pExpr->op==TK_COLUMN ){",
          "209:     pWalker->eCode |= pWalker->u.pTab->aCol[pExpr->iColumn].colFlags;",
          "210:   }",
          "211:   return WRC_Continue;",
          "212: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "216: ){",
          "217:   int i;",
          "",
          "[Removed Lines]",
          "218:   int nv;",
          "",
          "[Added Lines]",
          "228:   Walker w;",
          "229:   Column *pRedo;",
          "230:   int eProgress;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "227:       pTab->aCol[i].colFlags |= COLFLAG_NOTAVAIL;",
          "228:     }",
          "229:   }",
          "235:   pParse->iSelfTab = -iRegStore;",
          "249:       }",
          "251:     }",
          "253:   }",
          "254:   pParse->iSelfTab = 0;",
          "255: }",
          "",
          "[Removed Lines]",
          "236:   for(i=nv=0; i<pTab->nCol; i++){",
          "237:     u32 colFlags = pTab->aCol[i].colFlags;",
          "238:     if( (colFlags & COLFLAG_NOTAVAIL)!=0 ){",
          "239:       assert( colFlags & COLFLAG_GENERATED );",
          "240:       if( colFlags & COLFLAG_VIRTUAL ){",
          "242:         assert( pTab->nNVCol+nv == sqlite3TableColumnToStorage(pTab,i) );",
          "243:         sqlite3ExprCodeGeneratedColumn(pParse, &pTab->aCol[i],",
          "244:                                        iRegStore+pTab->nNVCol+nv);",
          "245:       }else{",
          "247:         assert( i-nv == sqlite3TableColumnToStorage(pTab,i) );",
          "248:         sqlite3ExprCodeGeneratedColumn(pParse, &pTab->aCol[i], iRegStore+i-nv);",
          "250:       pTab->aCol[i].colFlags &= ~COLFLAG_NOTAVAIL;",
          "252:     if( (colFlags & COLFLAG_VIRTUAL)!=0 ) nv++;",
          "",
          "[Added Lines]",
          "244:   w.u.pTab = pTab;",
          "245:   w.xExprCallback = exprColumnFlagUnion;",
          "246:   w.xSelectCallback = 0;",
          "247:   w.xSelectCallback2 = 0;",
          "255:   do{",
          "256:     eProgress = 0;",
          "257:     pRedo = 0;",
          "258:     for(i=0; i<pTab->nCol; i++){",
          "259:       Column *pCol = pTab->aCol + i;",
          "260:       if( (pCol->colFlags & COLFLAG_NOTAVAIL)!=0 ){",
          "261:         int x;",
          "262:         pCol->colFlags |= COLFLAG_BUSY;",
          "263:         w.eCode = 0;",
          "264:         sqlite3WalkExpr(&w, pCol->pDflt);",
          "265:         pCol->colFlags &= ~COLFLAG_BUSY;",
          "266:         if( w.eCode & COLFLAG_NOTAVAIL ){",
          "267:           pRedo = pCol;",
          "268:           continue;",
          "269:         }",
          "270:         eProgress = 1;",
          "271:         assert( pCol->colFlags & COLFLAG_GENERATED );",
          "272:         x = sqlite3TableColumnToStorage(pTab, i) + iRegStore;",
          "273:         sqlite3ExprCodeGeneratedColumn(pParse, pCol, x);",
          "274:         pCol->colFlags &= ~COLFLAG_NOTAVAIL;",
          "277:   }while( pRedo && eProgress );",
          "278:   if( pRedo ){",
          "279:     sqlite3ErrorMsg(pParse, \"generated column loop on \\\"%s\\\"\", pRedo->zName);",
          "",
          "---------------"
        ],
        "src/sqliteInt.h||src/sqliteInt.h": [
          "File: src/sqliteInt.h -> src/sqliteInt.h"
        ],
        "test/gencol1.test||test/gencol1.test": [
          "File: test/gencol1.test -> test/gencol1.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "222:   SELECT 99 FROM t0 WHERE 0 = t0.c2 OR t0.c1 BETWEEN t0.c2 AND 1;",
          "223: } {}",
          "225: finish_test",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "225: # 2019-11-06 ticket 4fc08501f4e56692",
          "226: do_execsql_test gencol1-8.10 {",
          "227:   DROP TABLE IF EXISTS t0;",
          "228:   CREATE TABLE t0(",
          "229:     c0 AS (('a', 9) < ('b', c1)),",
          "230:     c1 AS (1),",
          "231:     c2 CHECK (1 = c1)",
          "232:   );",
          "233:   INSERT INTO t0 VALUES (0),(99);",
          "234:   SELECT * FROM t0;",
          "235: } {1 1 0 1 1 99}",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "94c7ab5038510e3eb84920f5ef2b0ec704d7b470",
      "candidate_info": {
        "commit_hash": "94c7ab5038510e3eb84920f5ef2b0ec704d7b470",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/94c7ab5038510e3eb84920f5ef2b0ec704d7b470",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/test_vfs.c"
        ],
        "message": "In the test_vfs.c VFS, if a Tcl xWrite script returns \"SQLITE_OMIT\", silently omit the write() call.\n\nFossilOrigin-Name: 8b5a621e2ee3bb9d7d4f905217872e7e59153be9477aaa626cea287d56710b5b",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/test_vfs.c||src/test_vfs.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: e859d3184606dd453b9fc4ee388922d7be4b61aad84a66ac82107935ffd56f3a",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/test_vfs.c||src/test_vfs.c": [
          "File: src/test_vfs.c -> src/test_vfs.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "235:     { SQLITE_BUSY,     \"SQLITE_BUSY\"   },",
          "236:     { SQLITE_READONLY, \"SQLITE_READONLY\"   },",
          "237:     { SQLITE_READONLY_CANTINIT, \"SQLITE_READONLY_CANTINIT\"   },",
          "238:   };",
          "240:   const char *z;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "238:     { -1,              \"SQLITE_OMIT\"   },",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "382:         Tcl_NewWideIntObj(iOfst), Tcl_NewIntObj(iAmt)",
          "383:     );",
          "384:     tvfsResultCode(p, &rc);",
          "385:   }",
          "387:   if( rc==SQLITE_OK && tvfsInjectFullerr(p) ){",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "386:     if( rc<0 ) return SQLITE_OK;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2019-19923",
  "cve_desc": "flattenSubquery in select.c in SQLite 3.30.1 mishandles certain uses of SELECT DISTINCT involving a LEFT JOIN in which the right-hand side is a view. This can cause a NULL pointer dereference (or incorrect results).",
  "repo": "sqlite/sqlite",
  "patch_hash": "396afe6f6aa90a31303c183e11b2b2d4b7956b35",
  "patch_info": {
    "commit_hash": "396afe6f6aa90a31303c183e11b2b2d4b7956b35",
    "repo": "sqlite/sqlite",
    "commit_url": "https://github.com/sqlite/sqlite/commit/396afe6f6aa90a31303c183e11b2b2d4b7956b35",
    "files": [
      "manifest",
      "manifest.uuid",
      "src/select.c",
      "test/join.test"
    ],
    "message": "Continue to back away from the LEFT JOIN optimization of check-in [41c27bc0ff1d3135] by disallowing query flattening if the outer query is DISTINCT.  Without this fix, if an index scan is run on the table within the view on the right-hand side of the LEFT JOIN, stale result registers might be accessed yielding incorrect results, and/or an OP_IfNullRow opcode might be invoked on the un-opened table, resulting in a NULL-pointer dereference.  This problem was found by the Yongheng and Rui fuzzer.\n\nFossilOrigin-Name: 862974312edf00e9d1068115d1a39b7235b7db68b6d86b81d38a12f025a4748e",
    "before_after_code_files": [
      "manifest.uuid||manifest.uuid",
      "src/select.c||src/select.c",
      "test/join.test||test/join.test"
    ]
  },
  "patch_diff": {
    "manifest.uuid||manifest.uuid": [
      "File: manifest.uuid -> manifest.uuid",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "1: 289158aa24b066c453d2bce4bc2dead1c56fb0b23c3f7c4810b34b13627cef34",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "src/select.c||src/select.c": [
      "File: src/select.c -> src/select.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "3797:   if( (pSubitem->fg.jointype & JT_OUTER)!=0 ){",
      "3798:     isLeftJoin = 1;",
      "3801:       return 0;",
      "3802:     }",
      "3803:   }",
      "",
      "[Removed Lines]",
      "3799:     if( pSubSrc->nSrc>1 || isAgg || IsVirtual(pSubSrc->a[0].pTab) ){",
      "",
      "[Added Lines]",
      "3804:     ){",
      "",
      "---------------"
    ],
    "test/join.test||test/join.test": [
      "File: test/join.test -> test/join.test",
      "--- Hunk 1 ---",
      "[Context before]",
      "975:   SELECT 24, * FROM t1 LEFT JOIN t0 ON +aa ISNULL;",
      "976: } {13 1 {} 14 1 {} 23 1 {} 24 1 {}}",
      "978: finish_test",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "978: # 2019-12-18 problem with a LEFT JOIN where the RHS is a view.",
      "979: # Detected by Yongheng and Rui.",
      "980: # Follows from the optimization attempt of check-in 41c27bc0ff1d3135",
      "981: # on 2017-04-18",
      "982: #",
      "983: reset_db",
      "984: do_execsql_test join-22.10 {",
      "985:   CREATE TABLE t0(a, b);",
      "986:   CREATE INDEX t0a ON t0(a);",
      "987:   INSERT INTO t0 VALUES(10,10),(10,11),(10,12);",
      "988:   SELECT DISTINCT c FROM t0 LEFT JOIN (SELECT a+1 AS c FROM t0) ORDER BY c ;",
      "989: } {11}",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "38f9c7194df5d9c86cbeaa04c22bdee56c3c5635",
      "candidate_info": {
        "commit_hash": "38f9c7194df5d9c86cbeaa04c22bdee56c3c5635",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/38f9c7194df5d9c86cbeaa04c22bdee56c3c5635",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/shell.c.in",
          "test/recover.test"
        ],
        "message": "Fixes for the \".recover\" shell command.\n\nFossilOrigin-Name: 8dcc1d89d955bf58c80a8c30a37960f0cf95719953951a92626cc332cc75ec60",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/shell.c.in||src/shell.c.in",
          "test/recover.test||test/recover.test"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: f193ca587f9e4f925f4f2343b0b07053bd6f93dd87fc6f8f41cf4479e90cf562",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/shell.c.in||src/shell.c.in": [
          "File: src/shell.c.in -> src/shell.c.in",
          "--- Hunk 1 ---",
          "[Context before]",
          "6113:     sqlite3_stmt *pStmt = 0;",
          "6115:     rc = sqlite3_open(\"\", &dbtmp);",
          "6116:     if( rc==SQLITE_OK ){",
          "6117:       rc = sqlite3_exec(dbtmp, zSql, 0, 0, 0);",
          "6118:       if( rc==SQLITE_ERROR ){",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6116:     if( rc==SQLITE_OK ){",
          "6117:       rc = sqlite3_exec(dbtmp, \"PRAGMA writable_schema = on\", 0, 0, 0);",
          "6118:     }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "6361:   if( rc==SQLITE_OK ){",
          "6362:     sqlite3_stmt *pStmt = 0;",
          "6363:     raw_printf(pState->out, \"BEGIN;\\n\");",
          "6365:         \"SELECT sql FROM recovery.schema \"",
          "6370:     );",
          "6371:     while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pStmt) ){",
          "6372:       const char *zCreateTable = (const char*)sqlite3_column_text(pStmt, 0);",
          "6374:     }",
          "6375:     shellFinalize(&rc, pStmt);",
          "6376:   }",
          "",
          "[Removed Lines]",
          "6364:     shellPrepare(pState->db, &rc,",
          "6366:         \"WHERE type='table' \"",
          "6367:         \"  AND length(sql)>6\"",
          "6368:         \"  AND sql LIKE 'create table%'\"",
          "6369:         \"  AND name NOT LIKE 'sqliteX_%' ESCAPE 'X'\", &pStmt",
          "6373:       raw_printf(pState->out, \"%s;\\n\", zCreateTable);",
          "",
          "[Added Lines]",
          "6367:     raw_printf(pState->out, \"PRAGMA writable_schema = on;\\n\");",
          "6368:     shellPrepare(pState->db, &rc,",
          "6370:         \"WHERE type='table' AND sql LIKE 'create table%'\", &pStmt",
          "6374:       raw_printf(pState->out, \"CREATE TABLE IF NOT EXISTS %s;\\n\",",
          "6375:           &zCreateTable[12]",
          "6376:       );",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "6379:   shellPrepare(pState->db, &rc,",
          "6380:       \"SELECT root, intkey, max(maxlen) FROM recovery.map\"",
          "6382:   );",
          "6383:   while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pLoop) ){",
          "6384:     int iRoot = sqlite3_column_int(pLoop, 0);",
          "",
          "[Removed Lines]",
          "6381:       \" WHERE root>1 GROUP BY root, intkey\", &pLoop",
          "",
          "[Added Lines]",
          "6384:       \" WHERE root>1 GROUP BY root, intkey ORDER BY root=(\"",
          "6385:       \"  SELECT rootpage FROM recovery.schema WHERE name='sqlite_sequence'\"",
          "6386:       \")\", &pLoop",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "6389:     pTab = recoverNewTable(pState, &rc, iRoot, bIntkey, nCol);",
          "6390:     if( pTab ){",
          "6391:       sqlite3_stmt *pData = 0;",
          "6392:       shellPreparePrintf(pState->db, &rc, &pData,",
          "6393:         \"SELECT max(field), group_concat(quote(value), ', ') \"",
          "6394:         \"FROM sqlite_dbdata WHERE pgno IN (\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6397:       if( 0==sqlite3_stricmp(pTab->zName, \"sqlite_sequence\") ){",
          "6398:         raw_printf(pState->out, \"DELETE FROM sqlite_sequence;\\n\");",
          "6399:       }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "6410:   }",
          "6411:   shellFinalize(&rc, pLoop);",
          "6413:   if( rc==SQLITE_OK ){",
          "6414:     raw_printf(pState->out, \"COMMIT;\\n\");",
          "6415:   }",
          "6416:   sqlite3_exec(pState->db, \"DETACH recovery\", 0, 0, 0);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6422:   if( rc==SQLITE_OK ){",
          "6423:     sqlite3_stmt *pStmt = 0;",
          "6424:     shellPrepare(pState->db, &rc,",
          "6425:         \"SELECT sql, name FROM recovery.schema \"",
          "6426:         \"WHERE (type='table' AND sql LIKE 'create table%') IS NOT TRUE\", &pStmt",
          "6427:     );",
          "6428:     while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pStmt) ){",
          "6429:       const char *zSql = (const char*)sqlite3_column_text(pStmt, 0);",
          "6430:       if( sqlite3_strnicmp(zSql, \"create virt\", 11)==0 ){",
          "6431:         const char *zName = (const char*)sqlite3_column_text(pStmt, 1);",
          "6432:         char *zPrint = shellMPrintf(&rc,",
          "6433:           \"INSERT INTO sqlite_master VALUES('table', %Q, %Q, 0, %Q)\",",
          "6434:           zName, zName, zSql",
          "6435:         );",
          "6436:         raw_printf(pState->out, \"%s;\\n\", zPrint);",
          "6437:         sqlite3_free(zPrint);",
          "6438:       }else{",
          "6439:         raw_printf(pState->out, \"%s;\\n\", zSql);",
          "6440:       }",
          "6441:     }",
          "6442:     shellFinalize(&rc, pStmt);",
          "6443:   }",
          "6446:     raw_printf(pState->out, \"PRAGMA writable_schema = off;\\n\");",
          "",
          "---------------"
        ],
        "test/recover.test||test/recover.test": [
          "File: test/recover.test -> test/recover.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: # 2019 April 23",
          "2: #",
          "3: # The author disclaims copyright to this source code.  In place of",
          "4: # a legal notice, here is a blessing:",
          "5: #",
          "6: #    May you do good and not evil.",
          "7: #    May you find forgiveness for yourself and forgive others.",
          "8: #    May you share freely, never taking more than you give.",
          "9: #",
          "10: #***********************************************************************",
          "11: #",
          "12: # Test the shell tool \".ar\" command.",
          "13: #",
          "15: set testdir [file dirname $argv0]",
          "16: source $testdir/tester.tcl",
          "17: set testprefix recover",
          "19: ifcapable !vtab {",
          "20:   finish_test; return",
          "21: }",
          "22: set CLI [test_find_cli]",
          "24: proc compare_result {db1 db2 sql} {",
          "25:   set r1 [$db1 eval $sql]",
          "26:   set r2 [$db2 eval $sql]",
          "27:   if {$r1 != $r2} {",
          "28:   puts \"r1: $r1\"",
          "29:   puts \"r2: $r2\"",
          "30:     error \"mismatch for $sql\"",
          "31:   }",
          "32:   return \"\"",
          "33: }",
          "35: proc compare_dbs {db1 db2} {",
          "36:   compare_result $db1 $db2 \"SELECT sql FROM sqlite_master ORDER BY 1\"",
          "37:   foreach tbl [$db1 eval {SELECT name FROM sqlite_master WHERE type='table'}] {",
          "38:     compare_result $db1 $db2 \"SELECT * FROM $tbl\"",
          "39:   }",
          "40: }",
          "42: proc do_recover_test {tn} {",
          "43:   set fd [open \"|$::CLI test.db .recover\"]",
          "44:   fconfigure $fd -encoding binary",
          "45:   fconfigure $fd -translation binary",
          "46:   set sql [read $fd]",
          "47:   close $fd",
          "49:   forcedelete test.db2",
          "50:   sqlite3 db2 test.db2",
          "51:   breakpoint",
          "52:   execsql $sql db2",
          "53:   uplevel [list do_test $tn [list compare_dbs db db2] {}]",
          "54:   db2 close",
          "55: }",
          "57: set doc {",
          "58:   hello",
          "59:   world",
          "60: }",
          "61: do_execsql_test 1.1.1 {",
          "62:   CREATE TABLE t1(a INTEGER PRIMARY KEY, b, c);",
          "63:   INSERT INTO t1 VALUES(1, 4, X'1234567800');",
          "64:   INSERT INTO t1 VALUES(2, 'test', 8.1);",
          "65:   INSERT INTO t1 VALUES(3, $doc, 8.4);",
          "66: }",
          "67: do_recover_test 1.1.2",
          "69: do_execsql_test 1.2.1 \"",
          "70:   DELETE FROM t1;",
          "71:   INSERT INTO t1 VALUES(13, 'hello\\r\\nworld', 13);",
          "72: \"",
          "73: do_recover_test 1.2.2",
          "75: do_execsql_test 1.3.1 \"",
          "76:   CREATE TABLE t2(i INTEGER PRIMARY KEY AUTOINCREMENT, b, c);",
          "77:   INSERT INTO t2 VALUES(NULL, 1, 2);",
          "78:   INSERT INTO t2 VALUES(NULL, 3, 4);",
          "79:   INSERT INTO t2 VALUES(NULL, 5, 6);",
          "80:   CREATE TABLE t3(i INTEGER PRIMARY KEY AUTOINCREMENT, b, c);",
          "81:   INSERT INTO t3 VALUES(NULL, 1, 2);",
          "82:   INSERT INTO t3 VALUES(NULL, 3, 4);",
          "83:   INSERT INTO t3 VALUES(NULL, 5, 6);",
          "84:   DELETE FROM t2;",
          "85: \"",
          "86: do_recover_test 1.3.2",
          "88: finish_test",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "50efa586006c6ddb7290c37e35b9102747f18d78",
      "candidate_info": {
        "commit_hash": "50efa586006c6ddb7290c37e35b9102747f18d78",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/50efa586006c6ddb7290c37e35b9102747f18d78",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/expr.c",
          "test/select1.test"
        ],
        "message": "Remove an assert() in the code generator that can fail due to an invalid INSERT statement.  The same assert() appears again in the VDBE and will fire there if the problem persists in an SQL statement that does not contain errors.  Gramfuzz find.\n\nFossilOrigin-Name: 9bdd57cb9ad8ac1f4a0f1a3942d94ca5193109eeb1975343c4f0c7abf7135946",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/expr.c||src/expr.c",
          "test/select1.test||test/select1.test"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 1ca0bd982ab1183bbafce0d260e4dceda5eb766ed2e7793374a88d1ae0bdd2ca",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/expr.c||src/expr.c": [
          "File: src/expr.c -> src/expr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3509: void sqlite3ExprCodeMove(Parse *pParse, int iFrom, int iTo, int nReg){",
          "3511:   sqlite3VdbeAddOp3(pParse->pVdbe, OP_Move, iFrom, iTo, nReg);",
          "3512: }",
          "",
          "[Removed Lines]",
          "3510:   assert( iFrom>=iTo+nReg || iFrom+nReg<=iTo );",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "test/select1.test||test/select1.test": [
          "File: test/select1.test -> test/select1.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "1165:   );",
          "1166: } {1}",
          "1168: finish_test",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1168: # 2019-12-17 gramfuzz find",
          "1169: #",
          "1170: do_execsql_test select-19.10 {",
          "1171:   DROP TABLE IF EXISTS t1;",
          "1172:   CREATE TABLE t1(x);",
          "1173: } {}",
          "1174: do_catchsql_test select-19.20 {",
          "1175:   INSERT INTO t1",
          "1176:     SELECT 1,2,3,4,5,6,7",
          "1177:     UNION ALL SELECT 1,2,3,4,5,6,7",
          "1178:     ORDER BY 1;",
          "1179: } {1 {table t1 has 1 columns but 7 values were supplied}}",
          "1180: do_catchsql_test select-19.21 {",
          "1181:   INSERT INTO t1",
          "1182:     SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15",
          "1183:     UNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15",
          "1184:     ORDER BY 1;",
          "1185: } {1 {table t1 has 1 columns but 15 values were supplied}}",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "9877965f56dd0391242dab7617f2d8f06f3b4549",
      "candidate_info": {
        "commit_hash": "9877965f56dd0391242dab7617f2d8f06f3b4549",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/9877965f56dd0391242dab7617f2d8f06f3b4549",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/shell.c.in"
        ],
        "message": "Have \".recover\" handle cases where the sqlite_master table contains malformed SQL statements.\n\nFossilOrigin-Name: e736da9c18fad138c5502d354c3553373cba15358b69e44b257f60def59422e2",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/shell.c.in||src/shell.c.in"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 47fa65343e46c7782a173174952c637c5621e16229ece258dc7e7a556683ca0c",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/shell.c.in||src/shell.c.in": [
          "File: src/shell.c.in -> src/shell.c.in",
          "--- Hunk 1 ---",
          "[Context before]",
          "6388:  finished:",
          "6389:   sqlite3_close(dbtmp);",
          "6392:     recoverFreeTable(pTab);",
          "6393:     pTab = 0;",
          "6394:   }",
          "",
          "[Removed Lines]",
          "6391:   if( rc!=SQLITE_OK ){",
          "",
          "[Added Lines]",
          "6391:   if( rc!=SQLITE_OK || (pTab && pTab->zQuoted==0) ){",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "6682:   shellPrepare(pState->db, &rc,",
          "6685:       , &pLoop",
          "6686:   );",
          "6687:   if( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pLoop) ){",
          "",
          "[Removed Lines]",
          "6683:       \"SELECT coalesce(max(maxlen), -2) FROM recovery.map\"",
          "6684:       \"  WHERE root>1 AND root NOT IN (SELECT rootpage FROM recovery.schema)\"",
          "",
          "[Added Lines]",
          "6683:       \"SELECT coalesce(max(maxlen), -2) FROM recovery.map WHERE root>1\"",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "6689:   }",
          "6690:   shellFinalize(&rc, pLoop);",
          "6691:   pLoop = 0;",
          "6694:   shellPrepare(pState->db, &rc,",
          "6695:       \"SELECT pgno FROM recovery.map WHERE root=?\", &pPages",
          "",
          "[Removed Lines]",
          "6692:   pOrphan = recoverOrphanTable(pState, &rc, zLostAndFound, nOrphan);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "6717:     pTab = recoverFindTable(pState, &rc, iRoot, bIntkey, nCol, &bNoop);",
          "6718:     if( bNoop || rc ) continue;",
          "6721:     if( 0==sqlite3_stricmp(pTab->zQuoted, \"'sqlite_sequence'\") ){",
          "6722:       raw_printf(pState->out, \"DELETE FROM sqlite_sequence;\\n\");",
          "",
          "[Removed Lines]",
          "6719:     if( pTab==0 ) pTab = pOrphan;",
          "",
          "[Added Lines]",
          "6717:     if( pTab==0 ){",
          "6718:       if( pOrphan==0 ){",
          "6719:         pOrphan = recoverOrphanTable(pState, &rc, zLostAndFound, nOrphan);",
          "6720:       }",
          "6721:       pTab = pOrphan;",
          "6722:       if( pTab==0 ) break;",
          "6723:     }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "e5989723ba9b6510728d8a50f35347dc8aa4ee6b",
      "candidate_info": {
        "commit_hash": "e5989723ba9b6510728d8a50f35347dc8aa4ee6b",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/e5989723ba9b6510728d8a50f35347dc8aa4ee6b",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/attach.c",
          "src/main.c",
          "src/sqliteInt.h"
        ],
        "message": "Honor key query parameters for SEE on the URI filename for ATTACH and VACUUM INTO.\n\nFossilOrigin-Name: 2e01096b8933a2315e3dffcd7d0de84c744c1b4be1d909388c61f0fd636ddb99",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/attach.c||src/attach.c",
          "src/main.c||src/main.c",
          "src/sqliteInt.h||src/sqliteInt.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 69b0b2ee536fda8975f60643f7f1891db4649958aca476822ea2a632ce731992",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/attach.c||src/attach.c": [
          "File: src/attach.c -> src/attach.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "155:     assert( pVfs );",
          "156:     flags |= SQLITE_OPEN_MAIN_DB;",
          "157:     rc = sqlite3BtreeOpen(pVfs, zPath, db, &pNew->pBt, 0, flags);",
          "159:     db->nDb++;",
          "160:   }",
          "161:   db->noSharedCache = 0;",
          "162:   if( rc==SQLITE_CONSTRAINT ){",
          "",
          "[Removed Lines]",
          "158:     sqlite3_free( zPath );",
          "",
          "[Added Lines]",
          "159:     pNew->zDbSName = sqlite3DbStrDup(db, zName);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "184:     sqlite3BtreeLeave(pNew->pBt);",
          "185:   }",
          "186:   pNew->safety_level = SQLITE_DEFAULT_SYNCHRONOUS+1;",
          "188:   if( rc==SQLITE_OK && pNew->zDbSName==0 ){",
          "189:     rc = SQLITE_NOMEM_BKPT;",
          "190:   }",
          "",
          "[Removed Lines]",
          "187:   if( !REOPEN_AS_MEMDB(db) ) pNew->zDbSName = sqlite3DbStrDup(db, zName);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "212:         break;",
          "214:       case SQLITE_NULL:",
          "219:         }",
          "220:         break;",
          "221:     }",
          "222:   }",
          "223: #endif",
          "",
          "[Removed Lines]",
          "216:         sqlite3CodecGetKey(db, 0, (void**)&zKey, &nKey);",
          "217:         if( nKey || sqlite3BtreeGetOptimalReserve(db->aDb[0].pBt)>0 ){",
          "218:           rc = sqlite3CodecAttach(db, db->nDb-1, zKey, nKey);",
          "",
          "[Added Lines]",
          "216:         if( sqlite3CodecQueryParameters(db, zName, zPath)==0 ){",
          "217:           sqlite3CodecGetKey(db, 0, (void**)&zKey, &nKey);",
          "218:           if( nKey || sqlite3BtreeGetOptimalReserve(db->aDb[0].pBt)>0 ){",
          "219:             rc = sqlite3CodecAttach(db, db->nDb-1, zKey, nKey);",
          "220:           }",
          "226:   sqlite3_free( zPath );",
          "",
          "---------------"
        ],
        "src/main.c||src/main.c": [
          "File: src/main.c -> src/main.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2942:   return rc;",
          "2943: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2945: #if defined(SQLITE_HAS_CODEC)",
          "2951: int sqlite3CodecQueryParameters(",
          "2955: ){",
          "2956:   const char *zKey;",
          "2957:   if( (zKey = sqlite3_uri_parameter(zUri, \"hexkey\"))!=0 && zKey[0] ){",
          "2958:     u8 iByte;",
          "2959:     int i;",
          "2960:     char zDecoded[40];",
          "2961:     for(i=0, iByte=0; i<sizeof(zDecoded)*2 && sqlite3Isxdigit(zKey[i]); i++){",
          "2962:       iByte = (iByte<<4) + sqlite3HexToInt(zKey[i]);",
          "2963:       if( (i&1)!=0 ) zDecoded[i/2] = iByte;",
          "2964:     }",
          "2965:     sqlite3_key_v2(db, zDb, zDecoded, i/2);",
          "2966:     return 1;",
          "2967:   }else if( (zKey = sqlite3_uri_parameter(zUri, \"key\"))!=0 ){",
          "2968:     sqlite3_key_v2(db, zDb, zKey, sqlite3Strlen30(zKey));",
          "2969:     return 1;",
          "2970:   }else if( (zKey = sqlite3_uri_parameter(zUri, \"textkey\"))!=0 ){",
          "2971:     sqlite3_key_v2(db, zDb, zKey, -1);",
          "2972:     return 1;",
          "2973:   }else{",
          "2974:     return 0;",
          "2975:   }",
          "2976: }",
          "2977: #endif",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3287:   }",
          "3288: #endif",
          "3289: #if defined(SQLITE_HAS_CODEC)",
          "3305: #endif",
          "3306:   sqlite3_free(zOpen);",
          "3307:   return rc & 0xff;",
          "3308: }",
          "",
          "[Removed Lines]",
          "3290:   if( rc==SQLITE_OK ){",
          "3291:     const char *zKey;",
          "3292:     if( (zKey = sqlite3_uri_parameter(zOpen, \"hexkey\"))!=0 && zKey[0] ){",
          "3293:       u8 iByte;",
          "3294:       int i;",
          "3295:       char zDecoded[40];",
          "3296:       for(i=0, iByte=0; i<sizeof(zDecoded)*2 && sqlite3Isxdigit(zKey[i]); i++){",
          "3297:         iByte = (iByte<<4) + sqlite3HexToInt(zKey[i]);",
          "3298:         if( (i&1)!=0 ) zDecoded[i/2] = iByte;",
          "3299:       }",
          "3300:       sqlite3_key_v2(db, 0, zDecoded, i/2);",
          "3301:     }else if( (zKey = sqlite3_uri_parameter(zOpen, \"key\"))!=0 ){",
          "3302:       sqlite3_key_v2(db, 0, zKey, sqlite3Strlen30(zKey));",
          "3303:     }",
          "3304:   }",
          "",
          "[Added Lines]",
          "3324:   if( rc==SQLITE_OK ) sqlite3CodecQueryParameters(db, 0, zOpen);",
          "",
          "---------------"
        ],
        "src/sqliteInt.h||src/sqliteInt.h": [
          "File: src/sqliteInt.h -> src/sqliteInt.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "3882: void sqlite3EndTable(Parse*,Token*,Token*,u8,Select*);",
          "3883: int sqlite3ParseUri(const char*,const char*,unsigned int*,",
          "3884:                     sqlite3_vfs**,char**,char **);",
          "3885: Btree *sqlite3DbNameToBtree(sqlite3*,const char*);",
          "3887: #ifdef SQLITE_UNTESTABLE",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3885: #ifdef SQLITE_HAS_CODEC",
          "3886:   int sqlite3CodecQueryParameters(sqlite3*,const char*,const char*);",
          "3887: #else",
          "3888: # define sqlite3CodecQueryParameters(A,B,C) 0",
          "3889: #endif",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "e3bd232e2df1f4e6f537ba25764ba7428b6acb22",
      "candidate_info": {
        "commit_hash": "e3bd232e2df1f4e6f537ba25764ba7428b6acb22",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/e3bd232e2df1f4e6f537ba25764ba7428b6acb22",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/insert.c"
        ],
        "message": "Add the ability to override the new corruption detection logic of the previous checkin, in order to exercise downstream corruption detection during testing.\n\nFossilOrigin-Name: e859d3184606dd453b9fc4ee388922d7be4b61aad84a66ac82107935ffd56f3a",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/insert.c||src/insert.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: af1e5873d44d31466023ae145bdfc6b4191eb48b62e5752c6e683bcf571980e7",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/insert.c||src/insert.c": [
          "File: src/insert.c -> src/insert.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2275:     if( pSrcIdx==0 ){",
          "2277:     }",
          "2280:     }",
          "2281:   }",
          "",
          "[Removed Lines]",
          "2278:     if( pSrcIdx->tnum==pDestIdx->tnum && pSrc->pSchema==pDest->pSchema ){",
          "",
          "[Added Lines]",
          "2278:     if( pSrcIdx->tnum==pDestIdx->tnum && pSrc->pSchema==pDest->pSchema",
          "2279:          && sqlite3FaultSim(411)==SQLITE_OK ){",
          "",
          "---------------"
        ]
      }
    }
  ]
}
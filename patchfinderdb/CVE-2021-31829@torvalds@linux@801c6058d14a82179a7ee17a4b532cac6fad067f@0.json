{
  "cve_id": "CVE-2021-31829",
  "cve_desc": "kernel/bpf/verifier.c in the Linux kernel through 5.12.1 performs undesirable speculative loads, leading to disclosure of stack content via side-channel attacks, aka CID-801c6058d14a. The specific concern is not protecting the BPF stack area against speculative loads. Also, the BPF stack can contain uninitialized data that might represent sensitive information previously operated on by the kernel.",
  "repo": "torvalds/linux",
  "patch_hash": "801c6058d14a82179a7ee17a4b532cac6fad067f",
  "patch_info": {
    "commit_hash": "801c6058d14a82179a7ee17a4b532cac6fad067f",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/801c6058d14a82179a7ee17a4b532cac6fad067f",
    "files": [
      "include/linux/bpf_verifier.h",
      "kernel/bpf/verifier.c"
    ],
    "message": "bpf: Fix leakage of uninitialized bpf stack under speculation\n\nThe current implemented mechanisms to mitigate data disclosure under\nspeculation mainly address stack and map value oob access from the\nspeculative domain. However, Piotr discovered that uninitialized BPF\nstack is not protected yet, and thus old data from the kernel stack,\npotentially including addresses of kernel structures, could still be\nextracted from that 512 bytes large window. The BPF stack is special\ncompared to map values since it's not zero initialized for every\nprogram invocation, whereas map values /are/ zero initialized upon\ntheir initial allocation and thus cannot leak any prior data in either\ndomain. In the non-speculative domain, the verifier ensures that every\nstack slot read must have a prior stack slot write by the BPF program\nto avoid such data leaking issue.\n\nHowever, this is not enough: for example, when the pointer arithmetic\noperation moves the stack pointer from the last valid stack offset to\nthe first valid offset, the sanitation logic allows for any intermediate\noffsets during speculative execution, which could then be used to\nextract any restricted stack content via side-channel.\n\nGiven for unprivileged stack pointer arithmetic the use of unknown\nbut bounded scalars is generally forbidden, we can simply turn the\nregister-based arithmetic operation into an immediate-based arithmetic\noperation without the need for masking. This also gives the benefit\nof reducing the needed instructions for the operation. Given after\nthe work in 7fedb63a8307 (\"bpf: Tighten speculative pointer arithmetic\nmask\"), the aux->alu_limit already holds the final immediate value for\nthe offset register with the known scalar. Thus, a simple mov of the\nimmediate to AX register with using AX as the source for the original\ninstruction is sufficient and possible now in this case.\n\nReported-by: Piotr Krysiuk <piotras@gmail.com>\nSigned-off-by: Daniel Borkmann <daniel@iogearbox.net>\nTested-by: Piotr Krysiuk <piotras@gmail.com>\nReviewed-by: Piotr Krysiuk <piotras@gmail.com>\nReviewed-by: John Fastabend <john.fastabend@gmail.com>\nAcked-by: Alexei Starovoitov <ast@kernel.org>",
    "before_after_code_files": [
      "include/linux/bpf_verifier.h||include/linux/bpf_verifier.h",
      "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
    ]
  },
  "patch_diff": {
    "include/linux/bpf_verifier.h||include/linux/bpf_verifier.h": [
      "File: include/linux/bpf_verifier.h -> include/linux/bpf_verifier.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "302: };",
      "307: #define BPF_ALU_NEG_VALUE  (1U << 2)",
      "308: #define BPF_ALU_NON_POINTER  (1U << 3)",
      "309: #define BPF_ALU_SANITIZE  (BPF_ALU_SANITIZE_SRC | \\",
      "310:       BPF_ALU_SANITIZE_DST)",
      "",
      "[Removed Lines]",
      "305: #define BPF_ALU_SANITIZE_SRC  1U",
      "306: #define BPF_ALU_SANITIZE_DST  2U",
      "",
      "[Added Lines]",
      "305: #define BPF_ALU_SANITIZE_SRC  (1U << 0)",
      "306: #define BPF_ALU_SANITIZE_DST  (1U << 1)",
      "309: #define BPF_ALU_IMMEDIATE  (1U << 4)",
      "",
      "---------------"
    ],
    "kernel/bpf/verifier.c||kernel/bpf/verifier.c": [
      "File: kernel/bpf/verifier.c -> kernel/bpf/verifier.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "6496: {",
      "6497:  struct bpf_insn_aux_data *aux = commit_window ? cur_aux(env) : tmp_aux;",
      "6498:  struct bpf_verifier_state *vstate = env->cur_state;",
      "6499:  bool off_is_neg = off_reg->smin_value < 0;",
      "6500:  bool ptr_is_dst_reg = ptr_reg == dst_reg;",
      "6501:  u8 opcode = BPF_OP(insn->code);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "6499:  bool off_is_imm = tnum_is_const(off_reg->var_off);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "6526:   alu_limit = abs(tmp_aux->alu_limit - alu_limit);",
      "6527:  } else {",
      "6528:   alu_state  = off_is_neg ? BPF_ALU_NEG_VALUE : 0;",
      "6529:   alu_state |= ptr_is_dst_reg ?",
      "6530:         BPF_ALU_SANITIZE_SRC : BPF_ALU_SANITIZE_DST;",
      "6531:  }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "6530:   alu_state |= off_is_imm ? BPF_ALU_IMMEDIATE : 0;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "12371:    const u8 code_add = BPF_ALU64 | BPF_ADD | BPF_X;",
      "12372:    const u8 code_sub = BPF_ALU64 | BPF_SUB | BPF_X;",
      "12373:    struct bpf_insn *patch = &insn_buf[0];",
      "12375:    u32 off_reg;",
      "12377:    aux = &env->insn_aux_data[i + delta];",
      "",
      "[Removed Lines]",
      "12374:    bool issrc, isneg;",
      "",
      "[Added Lines]",
      "12376:    bool issrc, isneg, isimm;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "12382:    isneg = aux->alu_state & BPF_ALU_NEG_VALUE;",
      "12383:    issrc = (aux->alu_state & BPF_ALU_SANITIZE) ==",
      "12384:     BPF_ALU_SANITIZE_SRC;",
      "12386:    off_reg = issrc ? insn->src_reg : insn->dst_reg;",
      "12395:    if (!issrc)",
      "12397:    insn->src_reg = BPF_REG_AX;",
      "",
      "[Removed Lines]",
      "12387:    if (isneg)",
      "",
      "[Added Lines]",
      "12387:    isimm = aux->alu_state & BPF_ALU_IMMEDIATE;",
      "12390:    if (isimm) {",
      "12392:    } else {",
      "12393:     if (isneg)",
      "12401:    }",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "12399:     insn->code = insn->code == code_add ?",
      "12400:           code_sub : code_add;",
      "12404:    cnt = patch - insn_buf;",
      "",
      "[Removed Lines]",
      "12402:    if (issrc && isneg)",
      "",
      "[Added Lines]",
      "12409:    if (issrc && isneg && !isimm)",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "b5871dca250cd391885218b99cc015aca1a51aea",
      "candidate_info": {
        "commit_hash": "b5871dca250cd391885218b99cc015aca1a51aea",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/b5871dca250cd391885218b99cc015aca1a51aea",
        "files": [
          "kernel/bpf/verifier.c"
        ],
        "message": "bpf: Simplify alu_limit masking for pointer arithmetic\n\nInstead of having the mov32 with aux->alu_limit - 1 immediate, move this\noperation to retrieve_ptr_limit() instead to simplify the logic and to\nallow for subsequent sanity boundary checks inside retrieve_ptr_limit().\nThis avoids in future that at the time of the verifier masking rewrite\nwe'd run into an underflow which would not sign extend due to the nature\nof mov32 instruction.\n\nSigned-off-by: Piotr Krysiuk <piotras@gmail.com>\nCo-developed-by: Daniel Borkmann <daniel@iogearbox.net>\nSigned-off-by: Daniel Borkmann <daniel@iogearbox.net>\nAcked-by: Alexei Starovoitov <ast@kernel.org>",
        "before_after_code_files": [
          "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
          ],
          "candidate": [
            "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
          ]
        }
      },
      "candidate_diff": {
        "kernel/bpf/verifier.c||kernel/bpf/verifier.c": [
          "File: kernel/bpf/verifier.c -> kernel/bpf/verifier.c"
        ]
      }
    },
    {
      "candidate_hash": "b9b34ddbe2076ade359cd5ce7537d5ed019e9807",
      "candidate_info": {
        "commit_hash": "b9b34ddbe2076ade359cd5ce7537d5ed019e9807",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/b9b34ddbe2076ade359cd5ce7537d5ed019e9807",
        "files": [
          "kernel/bpf/verifier.c"
        ],
        "message": "bpf: Fix masking negation logic upon negative dst register\n\nThe negation logic for the case where the off_reg is sitting in the\ndst register is not correct given then we cannot just invert the add\nto a sub or vice versa. As a fix, perform the final bitwise and-op\nunconditionally into AX from the off_reg, then move the pointer from\nthe src to dst and finally use AX as the source for the original\npointer arithmetic operation such that the inversion yields a correct\nresult. The single non-AX mov in between is possible given constant\nblinding is retaining it as it's not an immediate based operation.\n\nFixes: 979d63d50c0c (\"bpf: prevent out of bounds speculation on pointer arithmetic\")\nSigned-off-by: Daniel Borkmann <daniel@iogearbox.net>\nTested-by: Piotr Krysiuk <piotras@gmail.com>\nReviewed-by: Piotr Krysiuk <piotras@gmail.com>\nReviewed-by: John Fastabend <john.fastabend@gmail.com>\nAcked-by: Alexei Starovoitov <ast@kernel.org>",
        "before_after_code_files": [
          "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
          ],
          "candidate": [
            "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
          ]
        }
      },
      "candidate_diff": {
        "kernel/bpf/verifier.c||kernel/bpf/verifier.c": [
          "File: kernel/bpf/verifier.c -> kernel/bpf/verifier.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "12402:    if (isneg)",
          "12403:     insn->code = insn->code == code_add ?",
          "12404:           code_sub : code_add;",
          "",
          "[Removed Lines]",
          "12394:    if (issrc) {",
          "12396:         off_reg);",
          "12397:     insn->src_reg = BPF_REG_AX;",
          "12398:    } else {",
          "12400:         BPF_REG_AX);",
          "12401:    }",
          "",
          "[Added Lines]",
          "12395:    if (!issrc)",
          "12397:    insn->src_reg = BPF_REG_AX;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
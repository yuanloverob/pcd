{
  "cve_id": "CVE-2022-36027",
  "cve_desc": "TensorFlow is an open source platform for machine learning. When converting transposed convolutions using per-channel weight quantization the converter segfaults and crashes the Python process. We have patched the issue in GitHub commit aa0b852a4588cea4d36b74feb05d93055540b450. The fix will be included in TensorFlow 2.10.0. We will also cherrypick this commit on TensorFlow 2.9.1, TensorFlow 2.8.1, and TensorFlow 2.7.2, as these are also affected and still in supported range. There are no known workarounds for this issue.",
  "repo": "tensorflow/tensorflow",
  "patch_hash": "aa0b852a4588cea4d36b74feb05d93055540b450",
  "patch_info": {
    "commit_hash": "aa0b852a4588cea4d36b74feb05d93055540b450",
    "repo": "tensorflow/tensorflow",
    "commit_url": "https://github.com/tensorflow/tensorflow/commit/aa0b852a4588cea4d36b74feb05d93055540b450",
    "files": [
      "tensorflow/compiler/mlir/lite/quantization/quantization_utils.cc",
      "tensorflow/compiler/mlir/lite/transforms/prepare_tf.cc",
      "tensorflow/lite/python/lite_v2_test.py"
    ],
    "message": "Skip reordering dq-q patterns when the new quantization dimension is unknown.\n\nIt also adds the canonicalization patterns to remove redundant TF reshape ops\nto infer the quantization dimension from the user ops (e.g, conv2d, depthwise\nconv2d) over those redundant TF reshape ops.\n\nPiperOrigin-RevId: 463080509",
    "before_after_code_files": [
      "tensorflow/compiler/mlir/lite/quantization/quantization_utils.cc||tensorflow/compiler/mlir/lite/quantization/quantization_utils.cc",
      "tensorflow/compiler/mlir/lite/transforms/prepare_tf.cc||tensorflow/compiler/mlir/lite/transforms/prepare_tf.cc",
      "tensorflow/lite/python/lite_v2_test.py||tensorflow/lite/python/lite_v2_test.py"
    ]
  },
  "patch_diff": {
    "tensorflow/compiler/mlir/lite/quantization/quantization_utils.cc||tensorflow/compiler/mlir/lite/quantization/quantization_utils.cc": [
      "File: tensorflow/compiler/mlir/lite/quantization/quantization_utils.cc -> tensorflow/compiler/mlir/lite/quantization/quantization_utils.cc",
      "--- Hunk 1 ---",
      "[Context before]",
      "168:         BroadcastVector<int64_t>(shaped.getDimSize(quant_dim), zero_points)) {",
      "169:       return {};",
      "170:     }",
      "177:       return {};",
      "178:     }",
      "179:   } else {",
      "",
      "[Removed Lines]",
      "171:   } else if ((new_shape.size() == shape.size() + 1) && new_shape.back() == 1) {",
      "173:     if (std::equal(shape.begin(), shape.end(), new_shape.begin()) &&",
      "174:         quant_dim == -1) {",
      "175:       quant_dim = shape.size() + quant_dim;",
      "176:     } else {",
      "",
      "[Added Lines]",
      "171:   } else if ((new_shape.size() == shape.size() + 1) && new_shape.front() == 1) {",
      "173:     if (!(std::equal(shape.begin(), shape.end(), new_shape.begin() + 1) &&",
      "174:           quant_dim == new_shape.size() - 1)) {",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "344:   if (auto per_axis =",
      "345:           qtype.dyn_cast_or_null<quant::UniformQuantizedPerAxisType>()) {",
      "346:     qtype =",
      "347:         ResetAxisAndBroadcast(source_type.getShape(), per_axis, target, axis);",
      "348:   }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "347:     if (axis == -1) return {};",
      "",
      "---------------"
    ],
    "tensorflow/compiler/mlir/lite/transforms/prepare_tf.cc||tensorflow/compiler/mlir/lite/transforms/prepare_tf.cc": [
      "File: tensorflow/compiler/mlir/lite/transforms/prepare_tf.cc -> tensorflow/compiler/mlir/lite/transforms/prepare_tf.cc",
      "--- Hunk 1 ---",
      "[Context before]",
      "1371:   patterns.add<RemoveIdentity>(ctx);",
      "1372:   TFL::populateWithGenerated(patterns);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1374:   TF::ReshapeOp::getCanonicalizationPatterns(patterns, ctx);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1399:            ConvertRfftToRfft2d, RemoveIdentity>(ctx);",
      "1400:   phase_2_patterns.add<ConvertTFConv2D, ConvertTFDepthwiseConv2dNative>(",
      "1401:       ctx, allow_bf16_and_f16_type_legalization_);",
      "1403:   (void)applyPatternsAndFoldGreedily(func, std::move(phase_2_patterns));",
      "1404: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1405:   TF::ReshapeOp::getCanonicalizationPatterns(phase_2_patterns, ctx);",
      "",
      "---------------"
    ],
    "tensorflow/lite/python/lite_v2_test.py||tensorflow/lite/python/lite_v2_test.py": [
      "File: tensorflow/lite/python/lite_v2_test.py -> tensorflow/lite/python/lite_v2_test.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "2311:         list(output_details[0]['shape_signature']),",
      "2312:         list(model.layers[-1].output_shape))",
      "2314:   def _createModelWithInputShape(self, shape):",
      "2315:     \"\"\"Create a simple SavedModel with a certain shape.\"\"\"",
      "2316:     saved_model_dir = os.path.join(self.get_temp_dir(), 'input_shape_model')",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2314:   @test_util.run_v2_only",
      "2315:   def testKerasConv2DTransposedWithMismatchQuantizedAxes(self):",
      "2317:     class QuantConv2DTransposed(tf.keras.layers.Layer):",
      "2319:       def build(self, input_shape):",
      "2320:         self.kernel = self.add_weight('kernel', [3, 3, input_shape[-1], 24])",
      "2322:       def call(self, inputs):",
      "2323:         filters = tf.quantization.fake_quant_with_min_max_vars_per_channel(",
      "2324:             self.kernel,",
      "2325:             -3.0 * tf.ones([24]),",
      "2326:             3.0 * tf.ones([24]),",
      "2327:             narrow_range=True)",
      "2328:         filters = tf.transpose(filters, (0, 1, 3, 2))",
      "2329:         return tf.nn.conv2d_transpose(inputs, filters, [*inputs.shape[:-1], 24],",
      "2330:                                       1)",
      "2332:     inp = tf.keras.Input(shape=(6, 8, 48), batch_size=1)",
      "2333:     x = tf.quantization.fake_quant_with_min_max_vars(",
      "2334:         inp, -3.0, 3.0, narrow_range=True)",
      "2335:     x = QuantConv2DTransposed()(x)",
      "2336:     x = tf.quantization.fake_quant_with_min_max_vars(",
      "2337:         x, -3.0, 3.0, narrow_range=True)",
      "2339:     model = tf.keras.Model(inp, x)",
      "2341:     saved_model_dir = os.path.join(self.get_temp_dir(),",
      "2342:                                    'keras_conv2d_transpose')",
      "2343:     model.save(saved_model_dir)",
      "2344:     converter = tf.lite.TFLiteConverter.from_saved_model(saved_model_dir)",
      "2345:     converter.optimizations = [tf.lite.Optimize.DEFAULT]",
      "2347:     with self.assertRaises(convert.ConverterError) as error:",
      "2348:       _ = converter.convert()",
      "2349:     self.assertIn('mismatched quantized axes of input and output',",
      "2350:                   str(error.exception))",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "025a88e6602b4baa372b12cfd8492335f79c4cd8",
      "candidate_info": {
        "commit_hash": "025a88e6602b4baa372b12cfd8492335f79c4cd8",
        "repo": "tensorflow/tensorflow",
        "commit_url": "https://github.com/tensorflow/tensorflow/commit/025a88e6602b4baa372b12cfd8492335f79c4cd8",
        "files": [
          "tensorflow/compiler/mlir/lite/quantization/quantization_utils.cc",
          "tensorflow/compiler/mlir/lite/quantization/quantization_utils.h"
        ],
        "message": "[Cleanup] Change struct to class for QuantizationPattern\n\nThe base is also class, so there's no need to make it as struct.\n\nAlso moved internally referenced functions in quantization_utils.cc into anonymous namespace.\n\nPiperOrigin-RevId: 415274676\nChange-Id: I8cb76a6054abf53924a3bc374a08ffbad86a0c3d",
        "before_after_code_files": [
          "tensorflow/compiler/mlir/lite/quantization/quantization_utils.cc||tensorflow/compiler/mlir/lite/quantization/quantization_utils.cc",
          "tensorflow/compiler/mlir/lite/quantization/quantization_utils.h||tensorflow/compiler/mlir/lite/quantization/quantization_utils.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "tensorflow/compiler/mlir/lite/quantization/quantization_utils.cc||tensorflow/compiler/mlir/lite/quantization/quantization_utils.cc"
          ],
          "candidate": [
            "tensorflow/compiler/mlir/lite/quantization/quantization_utils.cc||tensorflow/compiler/mlir/lite/quantization/quantization_utils.cc"
          ]
        }
      },
      "candidate_diff": {
        "tensorflow/compiler/mlir/lite/quantization/quantization_utils.cc||tensorflow/compiler/mlir/lite/quantization/quantization_utils.cc": [
          "File: tensorflow/compiler/mlir/lite/quantization/quantization_utils.cc -> tensorflow/compiler/mlir/lite/quantization/quantization_utils.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "20: #include <iterator>",
          "21: #include <limits>",
          "22: #include <numeric>",
          "24: #include \"llvm/ADT/STLExtras.h\"",
          "25: #include \"llvm/ADT/SmallVector.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "23: #include <string>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "49: namespace quant {",
          "51: constexpr double kSmallestHalfRange = kNearZeroTolerance / 2;",
          "52: using QType = quant::QuantizedType;",
          "85:   for (auto arg : llvm::zip(mins, maxs)) {",
          "86:     double min = std::get<0>(arg);",
          "87:     double max = std::get<1>(arg);",
          "",
          "[Removed Lines]",
          "54: const char kQuantTraitAttr[] = \"_tfl_quant_trait\";",
          "55: const absl::string_view QuantTraitValues[] = {\"fully_quantizable\",",
          "56:                                               \"not_quantizable\"};",
          "58: bool IsOpNotQuantizable(Operation* op) {",
          "61:   bool attr_enforced_quantizable =",
          "62:       op->hasAttrOfType<StringAttr>(kQuantTraitAttr) &&",
          "63:       op->getAttrOfType<StringAttr>(kQuantTraitAttr).getValue().str() ==",
          "64:           QuantTraitValues[QuantizationTrait::FullyQuantizable];",
          "68:   if (llvm::isa<ConstantOp, arith::ConstantOp, quant::StatisticsOp>(op))",
          "69:     return false;",
          "71:   bool prop_enforced_quantizable =",
          "72:       op->hasTrait<OpTrait::quant::QuantizableResult>();",
          "74:   return op->hasTrait<OpTrait::IsTerminator>() ||",
          "75:          llvm::isa<quant::QuantizeCastOp, quant::DequantizeCastOp>(op) ||",
          "76:          (!attr_enforced_quantizable && !prop_enforced_quantizable);",
          "77: }",
          "82: static void ExpandVerySmallRange(ArrayRef<double> mins, ArrayRef<double> maxs,",
          "83:                                  SmallVectorImpl<double>* effective_mins,",
          "84:                                  SmallVectorImpl<double>* effective_maxs) {",
          "",
          "[Added Lines]",
          "52: namespace {",
          "56: constexpr char kQuantTraitAttr[] = \"_tfl_quant_trait\";",
          "57: constexpr absl::string_view QuantTraitValues[] = {\"fully_quantizable\",",
          "58:                                                   \"not_quantizable\"};",
          "63: void ExpandVerySmallRange(ArrayRef<double> mins, ArrayRef<double> maxs,",
          "64:                           SmallVectorImpl<double>* effective_mins,",
          "65:                           SmallVectorImpl<double>* effective_maxs) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "144:   return type;",
          "145: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "130: template <typename T>",
          "131: bool BroadcastVector(int target_size, SmallVectorImpl<T>& data) {",
          "132:   int size = data.size();",
          "133:   if (size != target_size) {",
          "134:     if (target_size % size != 0) return true;",
          "135:     data.reserve(target_size);",
          "136:     for (int i = 1, e = target_size / size; i != e; ++i) {",
          "137:       data.insert(data.end(), data.begin(), data.begin() + size);",
          "138:     }",
          "139:   }",
          "140:   return false;",
          "141: }",
          "145: quant::UniformQuantizedPerAxisType ResetAxisAndBroadcast(",
          "146:     ArrayRef<int64_t> shape, quant::UniformQuantizedPerAxisType qtype,",
          "147:     Type target, int quant_dim) {",
          "148:   auto shaped = target.dyn_cast<RankedTensorType>();",
          "149:   if (!shaped) return {};",
          "150:   ArrayRef<int64_t> new_shape = shaped.getShape();",
          "152:   SmallVector<double, 4> scales(qtype.getScales().begin(),",
          "153:                                 qtype.getScales().end());",
          "154:   SmallVector<int64_t, 4> zero_points(qtype.getZeroPoints().begin(),",
          "155:                                       qtype.getZeroPoints().end());",
          "157:   if (new_shape.size() == shape.size()) {  // same rank",
          "169:     if (BroadcastVector<double>(shaped.getDimSize(quant_dim), scales) ||",
          "170:         BroadcastVector<int64_t>(shaped.getDimSize(quant_dim), zero_points)) {",
          "171:       return {};",
          "172:     }",
          "173:   } else if ((new_shape.size() == shape.size() + 1) && new_shape.back() == 1) {",
          "175:     if (std::equal(shape.begin(), shape.end(), new_shape.begin()) &&",
          "176:         quant_dim == -1) {",
          "177:       quant_dim = shape.size() + quant_dim;",
          "178:     } else {",
          "179:       return {};",
          "180:     }",
          "181:   } else {",
          "182:     return {};",
          "183:   }",
          "185:   return quant::UniformQuantizedPerAxisType::get(",
          "186:       qtype.getFlags(), qtype.getStorageType(), qtype.getExpressedType(),",
          "187:       scales, zero_points, quant_dim, qtype.getStorageTypeMin(),",
          "188:       qtype.getStorageTypeMax());",
          "189: }",
          "191: }  // namespace",
          "193: bool IsOpNotQuantizable(Operation* op) {",
          "196:   bool attr_enforced_quantizable =",
          "197:       op->hasAttrOfType<StringAttr>(kQuantTraitAttr) &&",
          "198:       op->getAttrOfType<StringAttr>(kQuantTraitAttr).getValue().str() ==",
          "199:           QuantTraitValues[QuantizationTrait::FullyQuantizable];",
          "203:   if (llvm::isa<ConstantOp, arith::ConstantOp, quant::StatisticsOp>(op))",
          "204:     return false;",
          "206:   bool prop_enforced_quantizable =",
          "207:       op->hasTrait<OpTrait::quant::QuantizableResult>();",
          "209:   return op->hasTrait<OpTrait::IsTerminator>() ||",
          "210:          llvm::isa<quant::QuantizeCastOp, quant::DequantizeCastOp>(op) ||",
          "211:          (!attr_enforced_quantizable && !prop_enforced_quantizable);",
          "212: }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "267:   return TypeAttr::get(final_type);",
          "268: }",
          "333: TypeAttr CastQuantizedTypeAttrFromExpressedType(Builder builder,",
          "334:                                                 TypeAttr source, Type target,",
          "335:                                                 int axis) {",
          "",
          "[Removed Lines]",
          "272: template <typename T>",
          "273: static bool BroadcastVector(int target_size, SmallVectorImpl<T>& data) {",
          "274:   int size = data.size();",
          "275:   if (size != target_size) {",
          "276:     if (target_size % size != 0) return true;",
          "277:     data.reserve(target_size);",
          "278:     for (int i = 1, e = target_size / size; i != e; ++i) {",
          "279:       data.insert(data.end(), data.begin(), data.begin() + size);",
          "280:     }",
          "281:   }",
          "282:   return false;",
          "283: }",
          "287: static quant::UniformQuantizedPerAxisType ResetAxisAndBroadcast(",
          "288:     ArrayRef<int64_t> shape, quant::UniformQuantizedPerAxisType qtype,",
          "289:     Type target, int quant_dim) {",
          "290:   auto shaped = target.dyn_cast<RankedTensorType>();",
          "291:   if (!shaped) return {};",
          "292:   ArrayRef<int64_t> new_shape = shaped.getShape();",
          "294:   SmallVector<double, 4> scales(qtype.getScales().begin(),",
          "295:                                 qtype.getScales().end());",
          "296:   SmallVector<int64_t, 4> zero_points(qtype.getZeroPoints().begin(),",
          "297:                                       qtype.getZeroPoints().end());",
          "299:   if (new_shape.size() == shape.size()) {  // same rank",
          "311:     if (BroadcastVector<double>(shaped.getDimSize(quant_dim), scales) ||",
          "312:         BroadcastVector<int64_t>(shaped.getDimSize(quant_dim), zero_points)) {",
          "313:       return {};",
          "314:     }",
          "315:   } else if ((new_shape.size() == shape.size() + 1) && new_shape.back() == 1) {",
          "317:     if (std::equal(shape.begin(), shape.end(), new_shape.begin()) &&",
          "318:         quant_dim == -1) {",
          "319:       quant_dim = shape.size() + quant_dim;",
          "320:     } else {",
          "321:       return {};",
          "322:     }",
          "323:   } else {",
          "324:     return {};",
          "325:   }",
          "327:   return quant::UniformQuantizedPerAxisType::get(",
          "328:       qtype.getFlags(), qtype.getStorageType(), qtype.getExpressedType(),",
          "329:       scales, zero_points, quant_dim, qtype.getStorageTypeMin(),",
          "330:       qtype.getStorageTypeMax());",
          "331: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "493:   llvm::SmallVector<double, 4> scales(axis_size, 1.0);",
          "494:   for (auto op_type : op_types) {",
          "495:     if (auto type = op_type.dyn_cast<quant::UniformQuantizedPerAxisType>()) {",
          "497:         scales[index_scale.index()] *= index_scale.value();",
          "498:       }",
          "499:     } else if (auto type = op_type.dyn_cast<quant::UniformQuantizedType>()) {",
          "",
          "[Removed Lines]",
          "496:       for (auto index_scale : llvm::enumerate(type.getScales())) {",
          "",
          "[Added Lines]",
          "500:       for (const auto& index_scale : llvm::enumerate(type.getScales())) {",
          "",
          "---------------"
        ],
        "tensorflow/compiler/mlir/lite/quantization/quantization_utils.h||tensorflow/compiler/mlir/lite/quantization/quantization_utils.h": [
          "File: tensorflow/compiler/mlir/lite/quantization/quantization_utils.h -> tensorflow/compiler/mlir/lite/quantization/quantization_utils.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "19: #ifndef TENSORFLOW_COMPILER_MLIR_LITE_QUANTIZATION_QUANTIZATION_UTILS_H_",
          "20: #define TENSORFLOW_COMPILER_MLIR_LITE_QUANTIZATION_QUANTIZATION_UTILS_H_",
          "22: #include <string>",
          "23: #include <unordered_map>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "22: #include <algorithm>",
          "23: #include <functional>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "57: constexpr double kNearZeroTolerance = 1.0e-6;",
          "59: enum QuantizationTrait { FullyQuantizable, NotQuantizable };",
          "63: using QuantParams = quant::QuantizedType;",
          "64: using SignedInteger = std::pair<unsigned, unsigned>;  // bitwidth and sign",
          "",
          "[Removed Lines]",
          "60: extern const char kQuantTraitAttr[];",
          "61: extern const absl::string_view QuantTraitValues[];",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "261: template <typename ConcretTy, typename Q, typename DQ, typename VERIFIER,",
          "262:           typename RootOp = DQ>",
          "264:   using BaseType = QuantizationPattern<ConcretTy, Q, DQ, VERIFIER, RootOp>;",
          "266:   explicit QuantizationPattern(MLIRContext* context,",
          "267:                                const QuantPassSpec& quant_params)",
          "269:       : RewritePattern(RootOp::getOperationName(), 300, context),",
          "277:   LogicalResult matchAndRewrite(Operation* op,",
          "278:                                 PatternRewriter& rewriter) const override {",
          "",
          "[Removed Lines]",
          "263: struct QuantizationPattern : public RewritePattern {",
          "270:         enable_verify(quant_params.numeric_verify.verify_numeric),",
          "271:         error_tolerance(quant_params.numeric_verify.error_tolerance),",
          "272:         whole_model_verify(quant_params.numeric_verify.whole_model_verify),",
          "273:         log_if_failed(quant_params.numeric_verify.log_if_failed_flag),",
          "274:         ops_blocklist(quant_params.ops_blocklist),",
          "275:         nodes_blocklist(quant_params.nodes_blocklist) {}",
          "",
          "[Added Lines]",
          "263: class QuantizationPattern : public RewritePattern {",
          "264:  public:",
          "271:         enable_verify_(quant_params.numeric_verify.verify_numeric),",
          "272:         error_tolerance_(quant_params.numeric_verify.error_tolerance),",
          "273:         whole_model_verify_(quant_params.numeric_verify.whole_model_verify),",
          "274:         log_if_failed_(quant_params.numeric_verify.log_if_failed_flag),",
          "275:         ops_blocklist_(quant_params.ops_blocklist),",
          "276:         nodes_blocklist_(quant_params.nodes_blocklist) {}",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "317:         return failure();",
          "318:       }",
          "323:         return failure();",
          "324:       }",
          "327:         if (auto name_loc = quantized_op->getLoc().dyn_cast<NameLoc>()) {",
          "328:           std::string sloc = name_loc.getName().str();",
          "329:           if (!sloc.empty() &&",
          "331:             return failure();",
          "332:           }",
          "333:         }",
          "",
          "[Removed Lines]",
          "320:       if (!ops_blocklist.empty() &&",
          "321:           (ops_blocklist.find(quantized_op->getName().getStringRef().str()) !=",
          "322:            ops_blocklist.end())) {",
          "326:       if (!nodes_blocklist.empty()) {",
          "330:               (nodes_blocklist.find(sloc) != nodes_blocklist.end())) {",
          "",
          "[Added Lines]",
          "321:       if (!ops_blocklist_.empty() &&",
          "322:           (ops_blocklist_.find(quantized_op->getName().getStringRef().str()) !=",
          "323:            ops_blocklist_.end())) {",
          "327:       if (!nodes_blocklist_.empty()) {",
          "331:               (nodes_blocklist_.find(sloc) != nodes_blocklist_.end())) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "350:       }",
          "",
          "[Removed Lines]",
          "338:       if (enable_verify) {",
          "339:         bool used_by_verifier = false;",
          "340:         for (auto result : quantized_op->getResults()) {",
          "341:           if (used_by_verifier) break;",
          "342:           for (auto user : result.getUsers()) {",
          "343:             if (llvm::isa<VERIFIER>(user)) {",
          "344:               used_by_verifier = true;",
          "345:               break;",
          "346:             }",
          "347:           }",
          "348:         }",
          "349:         if (used_by_verifier) continue;",
          "",
          "[Added Lines]",
          "339:       if (enable_verify_ && usedByVerifier(quantized_op)) {",
          "340:         continue;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "380:       llvm::SmallDenseMap<Value, int> outputs_replaced;",
          "381:       SmallVector<Type, 4> output_types;",
          "382:       output_types.reserve(quantized_op->getNumResults());",
          "384:            llvm::enumerate(quantized_op->getResults())) {",
          "385:         Value result = enumerated_result.value();",
          "386:         Type result_type = result.getType();",
          "",
          "[Removed Lines]",
          "383:       for (auto enumerated_result :",
          "",
          "[Added Lines]",
          "374:       for (const auto& enumerated_result :",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "421:       }",
          "422:       Operation* new_op = rewriter.createOperation(new_state);",
          "423:       if (quantized_op->getNumRegions() != 0) {",
          "425:              llvm::enumerate(quantized_op->getRegions())) {",
          "426:           Region& target_region = new_op->getRegion(indexed_regions.index());",
          "427:           BlockAndValueMapping mapping;",
          "",
          "[Removed Lines]",
          "424:         for (auto indexed_regions :",
          "",
          "[Added Lines]",
          "415:         for (const auto& indexed_regions :",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "442:         for (int i = 0, e = new_op->getNumOperands(); i != e; ++i) {",
          "",
          "[Removed Lines]",
          "439:       if (enable_verify) {",
          "",
          "[Added Lines]",
          "430:       if (enable_verify_) {",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "461:             continue;",
          "462:           }",
          "463:           rewriter.setInsertionPointAfter(new_op);",
          "467:           rewriter.create<VERIFIER>(",
          "468:               quantized_op->getLoc(), new_op->getResult(i).getType(),",
          "469:               new_op->getResult(i), quantized_op->getResult(i), tolerance, log);",
          "",
          "[Removed Lines]",
          "464:           FloatAttr tolerance = rewriter.getF32FloatAttr(error_tolerance);",
          "465:           BoolAttr log = rewriter.getBoolAttr(log_if_failed);",
          "471:           if (!whole_model_verify) continue;",
          "",
          "[Added Lines]",
          "455:           FloatAttr tolerance = rewriter.getF32FloatAttr(error_tolerance_);",
          "456:           BoolAttr log = rewriter.getBoolAttr(log_if_failed_);",
          "462:           if (!whole_model_verify_) continue;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "489:     return success();",
          "490:   }",
          "498: };",
          "",
          "[Removed Lines]",
          "492:   bool enable_verify;",
          "493:   float error_tolerance;",
          "494:   bool whole_model_verify;",
          "495:   bool log_if_failed;",
          "496:   const StringSet ops_blocklist;",
          "497:   const StringSet nodes_blocklist;",
          "",
          "[Added Lines]",
          "483:  private:",
          "484:   bool usedByVerifier(Operation* op) const {",
          "485:     for (Operation* user : op->getUsers()) {",
          "486:       if (llvm::isa_and_nonnull<VERIFIER>(user)) return true;",
          "487:     }",
          "488:     return false;",
          "489:   }",
          "491:   bool enable_verify_;",
          "492:   float error_tolerance_;",
          "493:   bool whole_model_verify_;",
          "494:   bool log_if_failed_;",
          "495:   const StringSet ops_blocklist_;",
          "496:   const StringSet nodes_blocklist_;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
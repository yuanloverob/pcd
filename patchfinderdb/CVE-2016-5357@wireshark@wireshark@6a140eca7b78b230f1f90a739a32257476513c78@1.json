{
  "cve_id": "CVE-2016-5357",
  "cve_desc": "wiretap/netscreen.c in the NetScreen file parser in Wireshark 1.12.x before 1.12.12 and 2.x before 2.0.4 mishandles sscanf unsigned-integer processing, which allows remote attackers to cause a denial of service (application crash) via a crafted file.",
  "repo": "wireshark/wireshark",
  "patch_hash": "6a140eca7b78b230f1f90a739a32257476513c78",
  "patch_info": {
    "commit_hash": "6a140eca7b78b230f1f90a739a32257476513c78",
    "repo": "wireshark/wireshark",
    "commit_url": "https://github.com/wireshark/wireshark/commit/6a140eca7b78b230f1f90a739a32257476513c78",
    "files": [
      "wiretap/netscreen.c",
      "wiretap/netscreen.h"
    ],
    "message": "Fix packet length handling.\n\nTreat the packet length as unsigned - it shouldn't be negative in the\nfile.  If it is, that'll probably cause the sscanf to fail, so we'll\nreport the file as bad.\n\nCheck it against WTAP_MAX_PACKET_SIZE to make sure we don't try to\nallocate a huge amount of memory, just as we do in other file readers.\n\nUse the now-validated packet size as the length in\nws_buffer_assure_space(), so we are certain to have enough space, and\ndon't allocate too much space.\n\nMerge the header and packet data parsing routines while we're at it.\n\nBug: 12396\nChange-Id: I7f981f9cdcbea7ecdeb88bfff2f12d875de2244f\nReviewed-on: https://code.wireshark.org/review/15176\nReviewed-by: Guy Harris <guy@alum.mit.edu>",
    "before_after_code_files": [
      "wiretap/netscreen.c||wiretap/netscreen.c",
      "wiretap/netscreen.h||wiretap/netscreen.h"
    ]
  },
  "patch_diff": {
    "wiretap/netscreen.c||wiretap/netscreen.c": [
      "File: wiretap/netscreen.c -> wiretap/netscreen.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "69: static gboolean netscreen_seek_read(wtap *wth, gint64 seek_off,",
      "70:  struct wtap_pkthdr *phdr, Buffer *buf,",
      "71:  int *err, gchar **err_info);",
      "78: static int parse_single_hex_dump_line(char* rec, guint8 *buf,",
      "79:  guint byte_offset);",
      "",
      "[Removed Lines]",
      "72: static int parse_netscreen_rec_hdr(struct wtap_pkthdr *phdr, const char *line,",
      "73:  char *cap_int, gboolean *cap_dir, char *cap_dst,",
      "74:  int *err, gchar **err_info);",
      "75: static gboolean parse_netscreen_hex_dump(FILE_T fh, int pkt_len,",
      "76:  const char *cap_int, const char *cap_dst, struct wtap_pkthdr *phdr,",
      "77:  Buffer* buf, int *err, gchar **err_info);",
      "",
      "[Added Lines]",
      "72: static gboolean parse_netscreen_packet(FILE_T fh, struct wtap_pkthdr *phdr,",
      "73:  Buffer* buf, char *line, int *err, gchar **err_info);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "191:     gint64 *data_offset)",
      "192: {",
      "193:  gint64  offset;",
      "195:  char  line[NETSCREEN_LINE_LENGTH];",
      "201:  offset = netscreen_seek_next_packet(wth, err, err_info, line);",
      "202:  if (offset < 0)",
      "203:   return FALSE;",
      "215:   return FALSE;",
      "",
      "[Removed Lines]",
      "194:  int  pkt_len;",
      "196:  char  cap_int[NETSCREEN_MAX_INT_NAME_LENGTH];",
      "197:  gboolean cap_dir;",
      "198:  char  cap_dst[13];",
      "206:  pkt_len = parse_netscreen_rec_hdr(&wth->phdr, line, cap_int, &cap_dir,",
      "207:      cap_dst, err, err_info);",
      "208:  if (pkt_len == -1)",
      "209:   return FALSE;",
      "213:  if (!parse_netscreen_hex_dump(wth->fh, pkt_len, cap_int,",
      "214:      cap_dst, &wth->phdr, wth->frame_buffer, err, err_info))",
      "",
      "[Added Lines]",
      "198:  if (!parse_netscreen_packet(wth->fh, &wth->phdr,",
      "199:      wth->frame_buffer, line, err, err_info))",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "239:  struct wtap_pkthdr *phdr, Buffer *buf,",
      "240:  int *err, gchar **err_info)",
      "241: {",
      "243:  char  line[NETSCREEN_LINE_LENGTH];",
      "248:  if (file_seek(wth->random_fh, seek_off, SEEK_SET, err) == -1) {",
      "249:   return FALSE;",
      "",
      "[Removed Lines]",
      "242:  int  pkt_len;",
      "244:  char  cap_int[NETSCREEN_MAX_INT_NAME_LENGTH];",
      "245:  gboolean cap_dir;",
      "246:  char  cap_dst[13];",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "257:   return FALSE;",
      "258:  }",
      "269: }",
      "",
      "[Removed Lines]",
      "260:  pkt_len = parse_netscreen_rec_hdr(phdr, line, cap_int, &cap_dir,",
      "261:      cap_dst, err, err_info);",
      "262:  if (pkt_len == -1)",
      "263:   return FALSE;",
      "265:  if (!parse_netscreen_hex_dump(wth->random_fh, pkt_len, cap_int,",
      "266:      cap_dst, phdr, buf, err, err_info))",
      "267:   return FALSE;",
      "268:  return TRUE;",
      "",
      "[Added Lines]",
      "241:  return parse_netscreen_packet(wth->random_fh, phdr, buf, line,",
      "242:      err, err_info);",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "291: {",
      "297:  phdr->rec_type = REC_TYPE_PACKET;",
      "298:  phdr->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;",
      "301:      &sec, &dsec, cap_int, direction, &pkt_len, cap_src, cap_dst) < 5) {",
      "304:   return -1;",
      "305:  }",
      "309:  phdr->ts.secs  = sec;",
      "310:  phdr->ts.nsecs = dsec * 100000000;",
      "311:  phdr->len = pkt_len;",
      "331:  pd = ws_buffer_start_ptr(buf);",
      "333:  while(1) {",
      "",
      "[Removed Lines]",
      "288: static int",
      "289: parse_netscreen_rec_hdr(struct wtap_pkthdr *phdr, const char *line, char *cap_int,",
      "290:     gboolean *cap_dir, char *cap_dst, int *err, gchar **err_info)",
      "292:  int sec;",
      "293:  int dsec, pkt_len;",
      "294:  char direction[2];",
      "295:  char cap_src[13];",
      "300:  if (sscanf(line, \"%9d.%9d: %15[a-z0-9/:.-](%1[io]) len=%9d:%12s->%12s/\",",
      "313:  return pkt_len;",
      "314: }",
      "318: static gboolean",
      "319: parse_netscreen_hex_dump(FILE_T fh, int pkt_len, const char *cap_int,",
      "320:     const char *cap_dst, struct wtap_pkthdr *phdr, Buffer* buf,",
      "321:     int *err, gchar **err_info)",
      "322: {",
      "323:  guint8 *pd;",
      "324:  gchar line[NETSCREEN_LINE_LENGTH];",
      "325:  gchar *p;",
      "326:  int n, i = 0, offset = 0;",
      "327:  gchar dststr[13];",
      "330:  ws_buffer_assure_space(buf, NETSCREEN_MAX_PACKET_LEN);",
      "",
      "[Added Lines]",
      "262: static gboolean",
      "263: parse_netscreen_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer* buf,",
      "264:     char *line, int *err, gchar **err_info)",
      "266:  int  sec;",
      "267:  int  dsec;",
      "268:  char  cap_int[NETSCREEN_MAX_INT_NAME_LENGTH];",
      "269:  char  direction[2];",
      "270:  guint  pkt_len;",
      "271:  char  cap_src[13];",
      "272:  char  cap_dst[13];",
      "273:  guint8  *pd;",
      "274:  gchar  *p;",
      "275:  int  n, i = 0;",
      "276:  guint  offset = 0;",
      "277:  gchar  dststr[13];",
      "282:  if (sscanf(line, \"%9d.%9d: %15[a-z0-9/:.-](%1[io]) len=%9u:%12s->%12s/\",",
      "288:  if (pkt_len > WTAP_MAX_PACKET_SIZE) {",
      "295:       pkt_len, WTAP_MAX_PACKET_SIZE);",
      "296:   return FALSE;",
      "297:  }",
      "309:  ws_buffer_assure_space(buf, pkt_len);",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "379:    return FALSE;",
      "",
      "[Removed Lines]",
      "376:   if(n == -1) {",
      "",
      "[Added Lines]",
      "355:   if (n == -1) {",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "391:    return FALSE;",
      "",
      "[Removed Lines]",
      "388:   if(offset > pkt_len) {",
      "",
      "[Added Lines]",
      "367:   if (offset > pkt_len) {",
      "",
      "---------------"
    ],
    "wiretap/netscreen.h||wiretap/netscreen.h": [
      "File: wiretap/netscreen.h -> wiretap/netscreen.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "46: #define NETSCREEN_INGRESS  FALSE",
      "47: #define NETSCREEN_EGRESS  TRUE",
      "52: wtap_open_return_val netscreen_open(wtap *wth, int *err, gchar **err_info);",
      "54: #endif",
      "",
      "[Removed Lines]",
      "50: #define NETSCREEN_MAX_PACKET_LEN 65536",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "ffee94e57079a65cbf5c055ba77245b70522d22f",
      "candidate_info": {
        "commit_hash": "ffee94e57079a65cbf5c055ba77245b70522d22f",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/ffee94e57079a65cbf5c055ba77245b70522d22f",
        "files": [
          "wiretap/cosine.c"
        ],
        "message": "Fix packet length handling.\n\nTreat the packet length as unsigned - it shouldn't be negative in the\nfile.  If it is, that'll probably cause the sscanf to fail, so we'll\nreport the file as bad.\n\nCheck it against WTAP_MAX_PACKET_SIZE to make sure we don't try to\nallocate a huge amount of memory, just as we do in other file readers.\n\nUse the now-validated packet size as the length in\nws_buffer_assure_space(), so we are certain to have enough space, and\ndon't allocate too much space.\n\nMerge the header and packet data parsing routines while we're at it.\n\nBug: 12395\nChange-Id: Ia70f33b71ff28451190fcf144c333fd1362646b2\nReviewed-on: https://code.wireshark.org/review/15172\nReviewed-by: Guy Harris <guy@alum.mit.edu>\n(cherry picked from commit f5ec0afb766f19519ea9623152cca3bbe2229500)\nReviewed-on: https://code.wireshark.org/review/15173",
        "before_after_code_files": [
          "wiretap/cosine.c||wiretap/cosine.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "diff_branch_message": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "wiretap/cosine.c||wiretap/cosine.c": [
          "File: wiretap/cosine.c -> wiretap/cosine.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "157: #define COSINE_HEADER_LINES_TO_CHECK 200",
          "158: #define COSINE_LINE_LENGTH  240",
          "162: static gboolean empty_line(const gchar *line);",
          "163: static gint64 cosine_seek_next_packet(wtap *wth, int *err, gchar **err_info,",
          "164:  char *hdr);",
          "",
          "[Removed Lines]",
          "160: #define COSINE_MAX_PACKET_LEN 65536",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "167:  gint64 *data_offset);",
          "168: static gboolean cosine_seek_read(wtap *wth, gint64 seek_off,",
          "169:  struct wtap_pkthdr *phdr, Buffer *buf, int *err, gchar **err_info);",
          "174: static int parse_single_hex_dump_line(char* rec, guint8 *buf,",
          "175:  guint byte_offset);",
          "",
          "[Removed Lines]",
          "170: static int parse_cosine_rec_hdr(struct wtap_pkthdr *phdr, const char *line,",
          "171:  int *err, gchar **err_info);",
          "172: static gboolean parse_cosine_hex_dump(FILE_T fh, struct wtap_pkthdr *phdr,",
          "173:  int pkt_len, Buffer* buf, int *err, gchar **err_info);",
          "",
          "[Added Lines]",
          "168: static int parse_cosine_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer* buf,",
          "169:  char *line, int *err, gchar **err_info);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "287:     gint64 *data_offset)",
          "288: {",
          "289:  gint64 offset;",
          "291:  char line[COSINE_LINE_LENGTH];",
          "",
          "[Removed Lines]",
          "290:  int pkt_len;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "296:   return FALSE;",
          "307: }",
          "",
          "[Removed Lines]",
          "300:  pkt_len = parse_cosine_rec_hdr(&wth->phdr, line, err, err_info);",
          "301:  if (pkt_len == -1)",
          "302:   return FALSE;",
          "305:  return parse_cosine_hex_dump(wth->fh, &wth->phdr, pkt_len,",
          "306:      wth->frame_buffer, err, err_info);",
          "",
          "[Added Lines]",
          "295:  return parse_cosine_packet(wth->fh, &wth->phdr, wth->frame_buffer,",
          "296:      line, err, err_info);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "311: cosine_seek_read(wtap *wth, gint64 seek_off, struct wtap_pkthdr *phdr,",
          "312:  Buffer *buf, int *err, gchar **err_info)",
          "313: {",
          "315:  char line[COSINE_LINE_LENGTH];",
          "317:  if (file_seek(wth->random_fh, seek_off, SEEK_SET, err) == -1)",
          "",
          "[Removed Lines]",
          "314:  int pkt_len;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "325:   return FALSE;",
          "326:  }",
          "335:      err_info);",
          "336: }",
          "",
          "[Removed Lines]",
          "329:  pkt_len = parse_cosine_rec_hdr(phdr, line, err, err_info);",
          "330:  if (pkt_len == -1)",
          "331:   return FALSE;",
          "334:  return parse_cosine_hex_dump(wth->random_fh, phdr, pkt_len, buf, err,",
          "",
          "[Added Lines]",
          "318:  return parse_cosine_packet(wth->random_fh, phdr, buf, line, err,",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "340:         2002-5-10,20:1:31.4:  l2-tx (FR:3/7/1:1), Length:18, Pro:0, Off:0, Pri:0, RM:0, Err:0 [0x4000, 0x0]",
          "341:     2) output to PE without date and time",
          "346: {",
          "347:  union wtap_pseudo_header *pseudo_header = &phdr->pseudo_header;",
          "348:  int num_items_scanned;",
          "350:  int pro, off, pri, rm, error;",
          "351:  guint code1, code2;",
          "352:  char if_name[COSINE_MAX_IF_NAME_LEN] = \"\", direction[6] = \"\";",
          "353:  struct tm tm;",
          "355:  if (sscanf(line, \"%4d-%2d-%2d,%2d:%2d:%2d.%9d:\",",
          "356:      &yy, &mm, &dd, &hr, &min, &sec, &csec) == 7) {",
          "358:   num_items_scanned = sscanf(line,",
          "360:    &yy, &mm, &dd, &hr, &min, &sec, &csec,",
          "361:        direction, if_name, &pkt_len,",
          "362:        &pro, &off, &pri, &rm, &error,",
          "",
          "[Removed Lines]",
          "343: static int",
          "344: parse_cosine_rec_hdr(struct wtap_pkthdr *phdr, const char *line,",
          "345:      int *err, gchar **err_info)",
          "349:  int yy, mm, dd, hr, min, sec, csec, pkt_len;",
          "359:      \"%4d-%2d-%2d,%2d:%2d:%2d.%9d: %5s (%127[A-Za-z0-9/:]), Length:%9d, Pro:%9d, Off:%9d, Pri:%9d, RM:%9d, Err:%9d [%8x, %8x]\",",
          "",
          "[Added Lines]",
          "327: static gboolean",
          "328: parse_cosine_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer *buf,",
          "329:     char *line, int *err, gchar **err_info)",
          "333:  int yy, mm, dd, hr, min, sec, csec;",
          "334:  guint pkt_len;",
          "339:  guint8 *pd;",
          "340:  int i, hex_lines, n, caplen = 0;",
          "346:      \"%4d-%2d-%2d,%2d:%2d:%2d.%9d: %5s (%127[A-Za-z0-9/:]), Length:%9u, Pro:%9d, Off:%9d, Pri:%9d, RM:%9d, Err:%9d [%8x, %8x]\",",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "365:   if (num_items_scanned != 17) {",
          "369:   }",
          "370:  } else {",
          "372:   num_items_scanned = sscanf(line,",
          "374:        direction, if_name, &pkt_len,",
          "375:        &pro, &off, &pri, &rm, &error,",
          "376:        &code1, &code2);",
          "",
          "[Removed Lines]",
          "368:    return -1;",
          "373:      \"%5s (%127[A-Za-z0-9/:]), Length:%9d, Pro:%9d, Off:%9d, Pri:%9d, RM:%9d, Err:%9d [%8x, %8x]\",",
          "",
          "[Added Lines]",
          "355:    return FALSE;",
          "360:      \"%5s (%127[A-Za-z0-9/:]), Length:%9u, Pro:%9d, Off:%9d, Pri:%9d, RM:%9d, Err:%9d [%8x, %8x]\",",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "378:   if (num_items_scanned != 10) {",
          "382:   }",
          "383:   yy = mm = dd = hr = min = sec = csec = 0;",
          "384:  }",
          "386:  phdr->rec_type = REC_TYPE_PACKET;",
          "387:  phdr->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;",
          "",
          "[Removed Lines]",
          "381:    return -1;",
          "",
          "[Added Lines]",
          "368:    return FALSE;",
          "372:  if (pkt_len > WTAP_MAX_PACKET_SIZE) {",
          "379:       pkt_len, WTAP_MAX_PACKET_SIZE);",
          "380:   return FALSE;",
          "381:  }",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "430:  pseudo_header->cosine.rm = rm;",
          "431:  pseudo_header->cosine.err = error;",
          "448:  pd = ws_buffer_start_ptr(buf);",
          "",
          "[Removed Lines]",
          "433:  return pkt_len;",
          "434: }",
          "438: static gboolean",
          "439: parse_cosine_hex_dump(FILE_T fh, struct wtap_pkthdr *phdr, int pkt_len,",
          "440:     Buffer* buf, int *err, gchar **err_info)",
          "441: {",
          "442:  guint8 *pd;",
          "443:  gchar line[COSINE_LINE_LENGTH];",
          "444:  int i, hex_lines, n, caplen = 0;",
          "447:  ws_buffer_assure_space(buf, COSINE_MAX_PACKET_LEN);",
          "",
          "[Added Lines]",
          "431:  ws_buffer_assure_space(buf, pkt_len);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "f95b7960774e8d6e052edcb768cd030640c8e969",
      "candidate_info": {
        "commit_hash": "f95b7960774e8d6e052edcb768cd030640c8e969",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/f95b7960774e8d6e052edcb768cd030640c8e969",
        "files": [
          "wiretap/cosine.c"
        ],
        "message": "Fix packet length handling.\n\nTreat the packet length as unsigned - it shouldn't be negative in the\nfile.  If it is, that'll probably cause the sscanf to fail, so we'll\nreport the file as bad.\n\nCheck it against WTAP_MAX_PACKET_SIZE to make sure we don't try to\nallocate a huge amount of memory, just as we do in other file readers.\n\nUse the now-validated packet size as the length in\nws_buffer_assure_space(), so we are certain to have enough space, and\ndon't allocate too much space.\n\nMerge the header and packet data parsing routines while we're at it.\n\nBug: 12395\nChange-Id: I4bf4f62882cf046e3e4ceffe7ab2ff3b178cd612\nReviewed-on: https://code.wireshark.org/review/15174\nReviewed-by: Guy Harris <guy@alum.mit.edu>",
        "before_after_code_files": [
          "wiretap/cosine.c||wiretap/cosine.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "diff_branch_message": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "wiretap/cosine.c||wiretap/cosine.c": [
          "File: wiretap/cosine.c -> wiretap/cosine.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "159: #define COSINE_HEADER_LINES_TO_CHECK 200",
          "160: #define COSINE_LINE_LENGTH         240",
          "164: static gboolean empty_line(const gchar *line);",
          "165: static gint64 cosine_seek_next_packet(wtap *wth, int *err, gchar **err_info,",
          "166:  char *hdr);",
          "",
          "[Removed Lines]",
          "162: #define COSINE_MAX_PACKET_LEN 65536",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "169:  gint64 *data_offset);",
          "170: static gboolean cosine_seek_read(wtap *wth, gint64 seek_off,",
          "171:  struct wtap_pkthdr *phdr, Buffer *buf, int *err, gchar **err_info);",
          "176: static int parse_single_hex_dump_line(char* rec, guint8 *buf,",
          "177:  guint byte_offset);",
          "",
          "[Removed Lines]",
          "172: static int parse_cosine_rec_hdr(struct wtap_pkthdr *phdr, const char *line,",
          "173:  int *err, gchar **err_info);",
          "174: static gboolean parse_cosine_hex_dump(FILE_T fh, struct wtap_pkthdr *phdr,",
          "175:  int pkt_len, Buffer* buf, int *err, gchar **err_info);",
          "",
          "[Added Lines]",
          "170: static int parse_cosine_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer* buf,",
          "171:  char *line, int *err, gchar **err_info);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "289:     gint64 *data_offset)",
          "290: {",
          "291:  gint64 offset;",
          "293:  char line[COSINE_LINE_LENGTH];",
          "",
          "[Removed Lines]",
          "292:  int pkt_len;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "298:   return FALSE;",
          "309: }",
          "",
          "[Removed Lines]",
          "302:  pkt_len = parse_cosine_rec_hdr(&wth->phdr, line, err, err_info);",
          "303:  if (pkt_len == -1)",
          "304:   return FALSE;",
          "307:  return parse_cosine_hex_dump(wth->fh, &wth->phdr, pkt_len,",
          "308:      wth->frame_buffer, err, err_info);",
          "",
          "[Added Lines]",
          "297:  return parse_cosine_packet(wth->fh, &wth->phdr, wth->frame_buffer,",
          "298:      line, err, err_info);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "313: cosine_seek_read(wtap *wth, gint64 seek_off, struct wtap_pkthdr *phdr,",
          "314:  Buffer *buf, int *err, gchar **err_info)",
          "315: {",
          "317:  char line[COSINE_LINE_LENGTH];",
          "319:  if (file_seek(wth->random_fh, seek_off, SEEK_SET, err) == -1)",
          "",
          "[Removed Lines]",
          "316:  int pkt_len;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "327:   return FALSE;",
          "328:  }",
          "337:      err_info);",
          "338: }",
          "",
          "[Removed Lines]",
          "331:  pkt_len = parse_cosine_rec_hdr(phdr, line, err, err_info);",
          "332:  if (pkt_len == -1)",
          "333:   return FALSE;",
          "336:  return parse_cosine_hex_dump(wth->random_fh, phdr, pkt_len, buf, err,",
          "",
          "[Added Lines]",
          "320:  return parse_cosine_packet(wth->random_fh, phdr, buf, line, err,",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "342:         2002-5-10,20:1:31.4:  l2-tx (FR:3/7/1:1), Length:18, Pro:0, Off:0, Pri:0, RM:0, Err:0 [0x4000, 0x0]",
          "343:     2) output to PE without date and time",
          "348: {",
          "349:  union wtap_pseudo_header *pseudo_header = &phdr->pseudo_header;",
          "350:  int num_items_scanned;",
          "352:  int pro, off, pri, rm, error;",
          "353:  guint code1, code2;",
          "354:  char if_name[COSINE_MAX_IF_NAME_LEN] = \"\", direction[6] = \"\";",
          "355:  struct tm tm;",
          "357:  if (sscanf(line, \"%4d-%2d-%2d,%2d:%2d:%2d.%9d:\",",
          "358:      &yy, &mm, &dd, &hr, &min, &sec, &csec) == 7) {",
          "360:   num_items_scanned = sscanf(line,",
          "362:    &yy, &mm, &dd, &hr, &min, &sec, &csec,",
          "363:        direction, if_name, &pkt_len,",
          "364:        &pro, &off, &pri, &rm, &error,",
          "",
          "[Removed Lines]",
          "345: static int",
          "346: parse_cosine_rec_hdr(struct wtap_pkthdr *phdr, const char *line,",
          "347:      int *err, gchar **err_info)",
          "351:  int yy, mm, dd, hr, min, sec, csec, pkt_len;",
          "361:      \"%4d-%2d-%2d,%2d:%2d:%2d.%9d: %5s (%127[A-Za-z0-9/:]), Length:%9d, Pro:%9d, Off:%9d, Pri:%9d, RM:%9d, Err:%9d [%8x, %8x]\",",
          "",
          "[Added Lines]",
          "329: static gboolean",
          "330: parse_cosine_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer *buf,",
          "331:     char *line, int *err, gchar **err_info)",
          "335:  int yy, mm, dd, hr, min, sec, csec;",
          "336:  guint pkt_len;",
          "341:  guint8 *pd;",
          "342:  int i, hex_lines, n, caplen = 0;",
          "348:      \"%4d-%2d-%2d,%2d:%2d:%2d.%9d: %5s (%127[A-Za-z0-9/:]), Length:%9u, Pro:%9d, Off:%9d, Pri:%9d, RM:%9d, Err:%9d [%8x, %8x]\",",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "367:   if (num_items_scanned != 17) {",
          "371:   }",
          "372:  } else {",
          "374:   num_items_scanned = sscanf(line,",
          "376:        direction, if_name, &pkt_len,",
          "377:        &pro, &off, &pri, &rm, &error,",
          "378:        &code1, &code2);",
          "",
          "[Removed Lines]",
          "370:    return -1;",
          "375:      \"%5s (%127[A-Za-z0-9/:]), Length:%9d, Pro:%9d, Off:%9d, Pri:%9d, RM:%9d, Err:%9d [%8x, %8x]\",",
          "",
          "[Added Lines]",
          "357:    return FALSE;",
          "362:      \"%5s (%127[A-Za-z0-9/:]), Length:%9u, Pro:%9d, Off:%9d, Pri:%9d, RM:%9d, Err:%9d [%8x, %8x]\",",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "380:   if (num_items_scanned != 10) {",
          "384:   }",
          "385:   yy = mm = dd = hr = min = sec = csec = 0;",
          "386:  }",
          "388:  phdr->rec_type = REC_TYPE_PACKET;",
          "389:  phdr->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;",
          "",
          "[Removed Lines]",
          "383:    return -1;",
          "",
          "[Added Lines]",
          "370:    return FALSE;",
          "374:  if (pkt_len > WTAP_MAX_PACKET_SIZE) {",
          "381:       pkt_len, WTAP_MAX_PACKET_SIZE);",
          "382:   return FALSE;",
          "383:  }",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "432:  pseudo_header->cosine.rm = rm;",
          "433:  pseudo_header->cosine.err = error;",
          "450:  pd = buffer_start_ptr(buf);",
          "",
          "[Removed Lines]",
          "435:  return pkt_len;",
          "436: }",
          "440: static gboolean",
          "441: parse_cosine_hex_dump(FILE_T fh, struct wtap_pkthdr *phdr, int pkt_len,",
          "442:     Buffer* buf, int *err, gchar **err_info)",
          "443: {",
          "444:  guint8 *pd;",
          "445:  gchar line[COSINE_LINE_LENGTH];",
          "446:  int i, hex_lines, n, caplen = 0;",
          "449:  buffer_assure_space(buf, COSINE_MAX_PACKET_LEN);",
          "",
          "[Added Lines]",
          "433:  buffer_assure_space(buf, pkt_len);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "fb514c22fd797bd63042093b8cca8118b66dca3e",
      "candidate_info": {
        "commit_hash": "fb514c22fd797bd63042093b8cca8118b66dca3e",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/fb514c22fd797bd63042093b8cca8118b66dca3e",
        "files": [
          "wiretap/cosine.c"
        ],
        "message": "Fix packet length handling.\n\nTreat the packet length as unsigned - it shouldn't be negative in the\nfile.  If it is, that'll probably cause the sscanf to fail, so we'll\nreport the file as bad.\n\nCheck it against WTAP_MAX_PACKET_SIZE to make sure we don't try to\nallocate a huge amount of memory, just as we do in other file readers.\n\nUse the now-validated packet size as the length in\nws_buffer_assure_space(), so we are certain to have enough space, and\ndon't allocate too much space.\n\nMerge the header and packet data parsing routines while we're at it.\n\nBug: 12395\nChange-Id: I4bf4f62882cf046e3e4ceffe7ab2ff3b178cd612\nReviewed-on: https://code.wireshark.org/review/15174\nReviewed-by: Guy Harris <guy@alum.mit.edu>\n(cherry picked from commit f95b7960774e8d6e052edcb768cd030640c8e969)\nReviewed-on: https://code.wireshark.org/review/16113\nReviewed-by: Balint Reczey <balint@balintreczey.hu>",
        "before_after_code_files": [
          "wiretap/cosine.c||wiretap/cosine.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_message": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "wiretap/cosine.c||wiretap/cosine.c": [
          "File: wiretap/cosine.c -> wiretap/cosine.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "160: #define COSINE_HEADER_LINES_TO_CHECK 200",
          "161: #define COSINE_LINE_LENGTH         240",
          "165: static gboolean empty_line(const gchar *line);",
          "166: static gint64 cosine_seek_next_packet(wtap *wth, int *err, gchar **err_info,",
          "167:  char *hdr);",
          "",
          "[Removed Lines]",
          "163: #define COSINE_MAX_PACKET_LEN 65536",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "170:  gint64 *data_offset);",
          "171: static gboolean cosine_seek_read(wtap *wth, gint64 seek_off,",
          "172:  struct wtap_pkthdr *phdr, Buffer *buf, int *err, gchar **err_info);",
          "177: static int parse_single_hex_dump_line(char* rec, guint8 *buf,",
          "178:  guint byte_offset);",
          "",
          "[Removed Lines]",
          "173: static int parse_cosine_rec_hdr(struct wtap_pkthdr *phdr, const char *line,",
          "174:  int *err, gchar **err_info);",
          "175: static gboolean parse_cosine_hex_dump(FILE_T fh, struct wtap_pkthdr *phdr,",
          "176:  int pkt_len, Buffer* buf, int *err, gchar **err_info);",
          "",
          "[Added Lines]",
          "171: static int parse_cosine_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer* buf,",
          "172:  char *line, int *err, gchar **err_info);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "290:     gint64 *data_offset)",
          "291: {",
          "292:  gint64 offset;",
          "294:  char line[COSINE_LINE_LENGTH];",
          "",
          "[Removed Lines]",
          "293:  int pkt_len;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "299:   return FALSE;",
          "310: }",
          "",
          "[Removed Lines]",
          "303:  pkt_len = parse_cosine_rec_hdr(&wth->phdr, line, err, err_info);",
          "304:  if (pkt_len == -1)",
          "305:   return FALSE;",
          "308:  return parse_cosine_hex_dump(wth->fh, &wth->phdr, pkt_len,",
          "309:      wth->frame_buffer, err, err_info);",
          "",
          "[Added Lines]",
          "298:  return parse_cosine_packet(wth->fh, &wth->phdr, wth->frame_buffer,",
          "299:      line, err, err_info);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "314: cosine_seek_read(wtap *wth, gint64 seek_off, struct wtap_pkthdr *phdr,",
          "315:  Buffer *buf, int *err, gchar **err_info)",
          "316: {",
          "318:  char line[COSINE_LINE_LENGTH];",
          "320:  if (file_seek(wth->random_fh, seek_off, SEEK_SET, err) == -1)",
          "",
          "[Removed Lines]",
          "317:  int pkt_len;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "328:   return FALSE;",
          "329:  }",
          "338:      err_info);",
          "339: }",
          "",
          "[Removed Lines]",
          "332:  pkt_len = parse_cosine_rec_hdr(phdr, line, err, err_info);",
          "333:  if (pkt_len == -1)",
          "334:   return FALSE;",
          "337:  return parse_cosine_hex_dump(wth->random_fh, phdr, pkt_len, buf, err,",
          "",
          "[Added Lines]",
          "321:  return parse_cosine_packet(wth->random_fh, phdr, buf, line, err,",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "343:         2002-5-10,20:1:31.4:  l2-tx (FR:3/7/1:1), Length:18, Pro:0, Off:0, Pri:0, RM:0, Err:0 [0x4000, 0x0]",
          "344:     2) output to PE without date and time",
          "349: {",
          "350:  union wtap_pseudo_header *pseudo_header = &phdr->pseudo_header;",
          "351:  int num_items_scanned;",
          "353:  int pro, off, pri, rm, error;",
          "354:  guint code1, code2;",
          "355:  char if_name[COSINE_MAX_IF_NAME_LEN] = \"\", direction[6] = \"\";",
          "356:  struct tm tm;",
          "358:  if (sscanf(line, \"%4d-%2d-%2d,%2d:%2d:%2d.%9d:\",",
          "359:      &yy, &mm, &dd, &hr, &min, &sec, &csec) == 7) {",
          "361:   num_items_scanned = sscanf(line,",
          "363:    &yy, &mm, &dd, &hr, &min, &sec, &csec,",
          "364:        direction, if_name, &pkt_len,",
          "365:        &pro, &off, &pri, &rm, &error,",
          "",
          "[Removed Lines]",
          "346: static int",
          "347: parse_cosine_rec_hdr(struct wtap_pkthdr *phdr, const char *line,",
          "348:      int *err, gchar **err_info)",
          "352:  int yy, mm, dd, hr, min, sec, csec, pkt_len;",
          "362:      \"%4d-%2d-%2d,%2d:%2d:%2d.%9d: %5s (%127[A-Za-z0-9/:]), Length:%9d, Pro:%9d, Off:%9d, Pri:%9d, RM:%9d, Err:%9d [%8x, %8x]\",",
          "",
          "[Added Lines]",
          "330: static gboolean",
          "331: parse_cosine_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer *buf,",
          "332:     char *line, int *err, gchar **err_info)",
          "336:  int yy, mm, dd, hr, min, sec, csec;",
          "337:  guint pkt_len;",
          "342:  guint8 *pd;",
          "343:  int i, hex_lines, n, caplen = 0;",
          "349:      \"%4d-%2d-%2d,%2d:%2d:%2d.%9d: %5s (%127[A-Za-z0-9/:]), Length:%9u, Pro:%9d, Off:%9d, Pri:%9d, RM:%9d, Err:%9d [%8x, %8x]\",",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "368:   if (num_items_scanned != 17) {",
          "372:   }",
          "373:  } else {",
          "375:   num_items_scanned = sscanf(line,",
          "377:        direction, if_name, &pkt_len,",
          "378:        &pro, &off, &pri, &rm, &error,",
          "379:        &code1, &code2);",
          "",
          "[Removed Lines]",
          "371:    return -1;",
          "376:      \"%5s (%127[A-Za-z0-9/:]), Length:%9d, Pro:%9d, Off:%9d, Pri:%9d, RM:%9d, Err:%9d [%8x, %8x]\",",
          "",
          "[Added Lines]",
          "358:    return FALSE;",
          "363:      \"%5s (%127[A-Za-z0-9/:]), Length:%9u, Pro:%9d, Off:%9d, Pri:%9d, RM:%9d, Err:%9d [%8x, %8x]\",",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "381:   if (num_items_scanned != 10) {",
          "385:   }",
          "386:   yy = mm = dd = hr = min = sec = csec = 0;",
          "387:  }",
          "389:  phdr->rec_type = REC_TYPE_PACKET;",
          "390:  phdr->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;",
          "",
          "[Removed Lines]",
          "384:    return -1;",
          "",
          "[Added Lines]",
          "371:    return FALSE;",
          "375:  if (pkt_len > WTAP_MAX_PACKET_SIZE) {",
          "382:       pkt_len, WTAP_MAX_PACKET_SIZE);",
          "383:   return FALSE;",
          "384:  }",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "433:  pseudo_header->cosine.rm = rm;",
          "434:  pseudo_header->cosine.err = error;",
          "451:  pd = buffer_start_ptr(buf);",
          "",
          "[Removed Lines]",
          "436:  return pkt_len;",
          "437: }",
          "441: static gboolean",
          "442: parse_cosine_hex_dump(FILE_T fh, struct wtap_pkthdr *phdr, int pkt_len,",
          "443:     Buffer* buf, int *err, gchar **err_info)",
          "444: {",
          "445:  guint8 *pd;",
          "446:  gchar line[COSINE_LINE_LENGTH];",
          "447:  int i, hex_lines, n, caplen = 0;",
          "450:  buffer_assure_space(buf, COSINE_MAX_PACKET_LEN);",
          "",
          "[Added Lines]",
          "434:  buffer_assure_space(buf, pkt_len);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
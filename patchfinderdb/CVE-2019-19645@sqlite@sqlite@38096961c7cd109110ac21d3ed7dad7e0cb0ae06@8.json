{
  "cve_id": "CVE-2019-19645",
  "cve_desc": "alter.c in SQLite through 3.30.1 allows attackers to trigger infinite recursion via certain types of self-referential views in conjunction with ALTER TABLE statements.",
  "repo": "sqlite/sqlite",
  "patch_hash": "38096961c7cd109110ac21d3ed7dad7e0cb0ae06",
  "patch_info": {
    "commit_hash": "38096961c7cd109110ac21d3ed7dad7e0cb0ae06",
    "repo": "sqlite/sqlite",
    "commit_url": "https://github.com/sqlite/sqlite/commit/38096961c7cd109110ac21d3ed7dad7e0cb0ae06",
    "files": [
      "manifest",
      "manifest.uuid",
      "src/alter.c",
      "src/build.c",
      "src/sqliteInt.h",
      "test/altertab3.test"
    ],
    "message": "Avoid infinite recursion in the ALTER TABLE code when a view contains an unused CTE that references, directly or indirectly, the view itself.\n\nFossilOrigin-Name: 1d2e53a39b87e364685e21de137655b6eee725e4c6d27fc90865072d7c5892b5",
    "before_after_code_files": [
      "manifest.uuid||manifest.uuid",
      "src/alter.c||src/alter.c",
      "src/build.c||src/build.c",
      "src/sqliteInt.h||src/sqliteInt.h",
      "test/altertab3.test||test/altertab3.test"
    ]
  },
  "patch_diff": {
    "manifest.uuid||manifest.uuid": [
      "File: manifest.uuid -> manifest.uuid",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "1: c5d44143599f3fe98492b2b900fa3d77925c7be545096251055ceeab899a41f1",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "src/alter.c||src/alter.c": [
      "File: src/alter.c -> src/alter.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "760:   Parse *pParse = pWalker->pParse;",
      "761:   int i;",
      "762:   if( pParse->nErr ) return WRC_Abort;",
      "763:   if( ALWAYS(p->pEList) ){",
      "764:     ExprList *pList = p->pEList;",
      "765:     for(i=0; i<pList->nExpr; i++){",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "763:   if( p->selFlags & SF_View ) return WRC_Prune;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "853: static int renameColumnSelectCb(Walker *pWalker, Select *p){",
      "854:   renameWalkWith(pWalker, p);",
      "855:   return WRC_Continue;",
      "856: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "855:   if( p->selFlags & SF_View ) return WRC_Prune;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1316:   if( sParse.pNewTable ){",
      "1317:     Select *pSelect = sParse.pNewTable->pSelect;",
      "1318:     if( pSelect ){",
      "1319:       sParse.rc = SQLITE_OK;",
      "1321:       rc = (db->mallocFailed ? SQLITE_NOMEM : sParse.rc);",
      "1322:       if( rc==SQLITE_OK ){",
      "1323:         sqlite3WalkSelect(&sWalker, pSelect);",
      "",
      "[Removed Lines]",
      "1320:       sqlite3SelectPrep(&sParse, sParse.pNewTable->pSelect, 0);",
      "",
      "[Added Lines]",
      "1321:       pSelect->selFlags &= ~SF_View;",
      "1323:       sqlite3SelectPrep(&sParse, pSelect, 0);",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "1434:   int i;",
      "1435:   RenameCtx *p = pWalker->u.pRename;",
      "1436:   SrcList *pSrc = pSelect->pSrc;",
      "1437:   if( pSrc==0 ){",
      "1438:     assert( pWalker->pParse->db->mallocFailed );",
      "1439:     return WRC_Abort;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1440:   if( pSelect->selFlags & SF_View ) return WRC_Prune;",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "1514:         if( pTab->pSelect ){",
      "1515:           if( isLegacy==0 ){",
      "1516:             NameContext sNC;",
      "1517:             memset(&sNC, 0, sizeof(sNC));",
      "1518:             sNC.pParse = &sParse;",
      "1520:             sqlite3SelectPrep(&sParse, pTab->pSelect, &sNC);",
      "1521:             if( sParse.nErr ) rc = sParse.rc;",
      "1522:             sqlite3WalkSelect(&sWalker, pTab->pSelect);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1520:             Select *pSelect = pTab->pSelect;",
      "1525:             assert( pSelect->selFlags & SF_View );",
      "1526:             pSelect->selFlags &= ~SF_View;",
      "",
      "---------------"
    ],
    "src/build.c||src/build.c": [
      "File: src/build.c -> src/build.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "2488:   if( IN_RENAME_OBJECT ){",
      "2489:     p->pSelect = pSelect;",
      "2490:     pSelect = 0;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2488:   pSelect->selFlags |= SF_View;",
      "",
      "---------------"
    ],
    "src/sqliteInt.h||src/sqliteInt.h": [
      "File: src/sqliteInt.h -> src/sqliteInt.h"
    ],
    "test/altertab3.test||test/altertab3.test": [
      "File: test/altertab3.test -> test/altertab3.test",
      "--- Hunk 1 ---",
      "[Context before]",
      "487:   ALTER TABLE a RENAME a TO b;",
      "488: }",
      "491: finish_test",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "490: #------------------------------------------------------------------------",
      "491: #",
      "492: reset_db",
      "493: do_execsql_test 22.1 {",
      "494:   CREATE TABLE t1(a);",
      "495:   CREATE VIEW v2(b) AS SELECT * FROM v2;",
      "496: }",
      "498: do_catchsql_test 22.2 {",
      "499:   ALTER TABLE t1 RENAME TO t4;",
      "500: } {1 {error in view v2: view v2 is circularly defined}}",
      "502: do_execsql_test 22.3 {",
      "503:   DROP VIEW v2;",
      "504:   CREATE VIEW v2(b) AS WITH t3 AS (SELECT b FROM v2) SELECT * FROM t3;",
      "505: }",
      "507: breakpoint",
      "508: do_catchsql_test 22.4 {",
      "509:   ALTER TABLE t1 RENAME TO t4;",
      "510: } {1 {error in view v2: view v2 is circularly defined}}",
      "512: do_execsql_test 22.5 {",
      "513:   DROP VIEW v2;",
      "514:   CREATE VIEW v2(b) AS WITH t3 AS (SELECT b FROM v2) VALUES(1);",
      "515: }",
      "517: do_catchsql_test 22.6 {",
      "518:   ALTER TABLE t1 RENAME TO t4;",
      "519: } {0 {}}",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "90c21df2338651335ad7a922dd573f50c5f161ab",
      "candidate_info": {
        "commit_hash": "90c21df2338651335ad7a922dd573f50c5f161ab",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/90c21df2338651335ad7a922dd573f50c5f161ab",
        "files": [
          "manifest",
          "manifest.uuid",
          "test/fuzzdata8.db"
        ],
        "message": "New dbsqlfuzz find added to test/fuzzdata8.db.\n\nFossilOrigin-Name: 42af7c819bc52ccb6953a58b1c05d3bd47cc438c5119a9555b1b796764eb9f20",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 1660d7733eb443ab085ddef7666b998a1c75ac81cc54a9620960a8d3b377e28e",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b0b7db91b8cc880ae7d5f3c334607fda17364d62",
      "candidate_info": {
        "commit_hash": "b0b7db91b8cc880ae7d5f3c334607fda17364d62",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/b0b7db91b8cc880ae7d5f3c334607fda17364d62",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/parse.y",
          "src/sqliteInt.h",
          "src/vacuum.c",
          "src/vdbe.c"
        ],
        "message": "Prototype implementation for the VACUUM INTO command.\n\nFossilOrigin-Name: 036e3320a4af36c1311b25b2e504b0079c8b33df8ad7b7e5fddad07150e6f87d",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/parse.y||src/parse.y",
          "src/sqliteInt.h||src/sqliteInt.h",
          "src/vacuum.c||src/vacuum.c",
          "src/vdbe.c||src/vdbe.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid",
            "src/sqliteInt.h||src/sqliteInt.h"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid",
            "src/sqliteInt.h||src/sqliteInt.h"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 0d8e150434bbd179696f1ffe71d1e06cb3d43e6468496c7e481fca8486387bad",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/parse.y||src/parse.y": [
          "File: src/parse.y -> src/parse.y",
          "--- Hunk 1 ---",
          "[Context before]",
          "1368: %ifndef SQLITE_OMIT_VACUUM",
          "1369: %ifndef SQLITE_OMIT_ATTACH",
          "1372: %endif  SQLITE_OMIT_ATTACH",
          "1373: %endif  SQLITE_OMIT_VACUUM",
          "",
          "[Removed Lines]",
          "1370: cmd ::= VACUUM.                {sqlite3Vacuum(pParse,0);}",
          "1371: cmd ::= VACUUM nm(X).          {sqlite3Vacuum(pParse,&X);}",
          "",
          "[Added Lines]",
          "1370: %type vinto {Token}",
          "1371: cmd ::= VACUUM vinto(Y).                {sqlite3Vacuum(pParse,0,&Y);}",
          "1372: cmd ::= VACUUM nm(X) vinto(Y).          {sqlite3Vacuum(pParse,&X,&Y);}",
          "1373: vinto(A) ::= INTO nm(X).                {A = X;}",
          "1374: vinto(A) ::= .                          {A.z = 0;}",
          "",
          "---------------"
        ],
        "src/sqliteInt.h||src/sqliteInt.h": [
          "File: src/sqliteInt.h -> src/sqliteInt.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "3985: Index *sqlite3FindIndex(sqlite3*,const char*, const char*);",
          "3986: void sqlite3UnlinkAndDeleteTable(sqlite3*,int,const char*);",
          "3987: void sqlite3UnlinkAndDeleteIndex(sqlite3*,int,const char*);",
          "3990: char *sqlite3NameFromToken(sqlite3*, Token*);",
          "3991: int sqlite3ExprCompare(Parse*,Expr*, Expr*, int);",
          "3992: int sqlite3ExprCompareSkip(Expr*, Expr*, int);",
          "",
          "[Removed Lines]",
          "3988: void sqlite3Vacuum(Parse*,Token*);",
          "3989: int sqlite3RunVacuum(char**, sqlite3*, int);",
          "",
          "[Added Lines]",
          "3988: void sqlite3Vacuum(Parse*,Token*,Token*);",
          "3989: int sqlite3RunVacuum(char**, sqlite3*, int, const char*);",
          "",
          "---------------"
        ],
        "src/vacuum.c||src/vacuum.c": [
          "File: src/vacuum.c -> src/vacuum.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "106:   Vdbe *v = sqlite3GetVdbe(pParse);",
          "107:   int iDb = 0;",
          "108:   if( v==0 ) return;",
          "109:   if( pNm ){",
          "110: #ifndef SQLITE_BUG_COMPATIBLE_20160819",
          "",
          "[Removed Lines]",
          "105: void sqlite3Vacuum(Parse *pParse, Token *pNm){",
          "",
          "[Added Lines]",
          "105: void sqlite3Vacuum(Parse *pParse, Token *pNm, Token *pInto){",
          "108:   assert( pInto!=0 );",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "125:   if( iDb!=1 ){",
          "126:     sqlite3VdbeAddOp1(v, OP_Vacuum, iDb);",
          "127:     sqlite3VdbeUsesBtree(v, iDb);",
          "128:   }",
          "129:   return;",
          "130: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "129:     if( pInto->z ){",
          "130:       char *zName = sqlite3NameFromToken(pParse->db, pInto);",
          "131:       sqlite3VdbeChangeP4(v, -1, zName, P4_DYNAMIC);",
          "132:     }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "135: int sqlite3RunVacuum(char **pzErrMsg, sqlite3 *db, int iDb){",
          "",
          "[Added Lines]",
          "140: int sqlite3RunVacuum(char **pzErrMsg, sqlite3 *db, int iDb, const char *zOut){",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "191:   nDb = db->nDb;",
          "193:   if( rc!=SQLITE_OK ) goto end_of_vacuum;",
          "194:   assert( (db->nDb-1)==nDb );",
          "195:   pDb = &db->aDb[nDb];",
          "",
          "[Removed Lines]",
          "192:   rc = execSql(db, pzErrMsg, \"ATTACH''AS vacuum_db\");",
          "",
          "[Added Lines]",
          "197:   rc = execSqlF(db, pzErrMsg, \"ATTACH %Q AS vacuum_db\", zOut ? zOut : \"\");",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "226:   rc = execSql(db, pzErrMsg, \"BEGIN\");",
          "227:   if( rc!=SQLITE_OK ) goto end_of_vacuum;",
          "229:   if( rc!=SQLITE_OK ) goto end_of_vacuum;",
          "",
          "[Removed Lines]",
          "228:   rc = sqlite3BtreeBeginTrans(pMain, 2, 0);",
          "",
          "[Added Lines]",
          "233:   rc = sqlite3BtreeBeginTrans(pMain, zOut==0 ? 2 : 0, 0);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "320:     };",
          "322:     assert( 1==sqlite3BtreeIsInTrans(pTemp) );",
          "326:     for(i=0; i<ArraySize(aCopy); i+=2){",
          "",
          "[Removed Lines]",
          "323:     assert( 1==sqlite3BtreeIsInTrans(pMain) );",
          "",
          "[Added Lines]",
          "328:     assert( zOut!=0 || 1==sqlite3BtreeIsInTrans(pMain) );",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "331:       if( NEVER(rc!=SQLITE_OK) ) goto end_of_vacuum;",
          "332:     }",
          "335:     if( rc!=SQLITE_OK ) goto end_of_vacuum;",
          "336:     rc = sqlite3BtreeCommit(pTemp);",
          "337:     if( rc!=SQLITE_OK ) goto end_of_vacuum;",
          "338: #ifndef SQLITE_OMIT_AUTOVACUUM",
          "340: #endif",
          "341:   }",
          "343:   assert( rc==SQLITE_OK );",
          "346: end_of_vacuum:",
          "",
          "[Removed Lines]",
          "334:     rc = sqlite3BtreeCopyFile(pMain, pTemp);",
          "339:     sqlite3BtreeSetAutoVacuum(pMain, sqlite3BtreeGetAutoVacuum(pTemp));",
          "344:   rc = sqlite3BtreeSetPageSize(pMain, sqlite3BtreeGetPageSize(pTemp), nRes,1);",
          "",
          "[Added Lines]",
          "339:     if( zOut==0 ){",
          "340:       rc = sqlite3BtreeCopyFile(pMain, pTemp);",
          "341:     }else{",
          "342:       rc = sqlite3BtreeCommit(pMain);",
          "343:     }",
          "348:     if( zOut==0 ){",
          "349:       sqlite3BtreeSetAutoVacuum(pMain, sqlite3BtreeGetAutoVacuum(pTemp));",
          "350:     }",
          "355:   if( zOut==0 ){",
          "356:     rc = sqlite3BtreeSetPageSize(pMain, sqlite3BtreeGetPageSize(pTemp), nRes,1);",
          "357:   }",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "368:     pDb->pSchema = 0;",
          "369:   }",
          "375:   return rc;",
          "376: }",
          "",
          "[Removed Lines]",
          "373:   sqlite3ResetAllSchemasOfConnection(db);",
          "",
          "[Added Lines]",
          "384:   if( zOut==0 ){",
          "387:     sqlite3ResetAllSchemasOfConnection(db);",
          "388:   }",
          "",
          "---------------"
        ],
        "src/vdbe.c||src/vdbe.c": [
          "File: src/vdbe.c -> src/vdbe.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "6686: #if !defined(SQLITE_OMIT_VACUUM) && !defined(SQLITE_OMIT_ATTACH)",
          "6692: case OP_Vacuum: {",
          "6693:   assert( p->readOnly==0 );",
          "6695:   if( rc ) goto abort_due_to_error;",
          "6696:   break;",
          "6697: }",
          "",
          "[Removed Lines]",
          "6694:   rc = sqlite3RunVacuum(&p->zErrMsg, db, pOp->p1);",
          "",
          "[Added Lines]",
          "6698:   rc = sqlite3RunVacuum(&p->zErrMsg, db, pOp->p1, pOp->p4.z);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "df21659a40e9dcaaeb4faecb0d13704e359296f2",
      "candidate_info": {
        "commit_hash": "df21659a40e9dcaaeb4faecb0d13704e359296f2",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/df21659a40e9dcaaeb4faecb0d13704e359296f2",
        "files": [
          "manifest",
          "manifest.uuid",
          "test/fuzzcheck.c"
        ],
        "message": "Improved automatic detection of dbsqlfuzz cases in fuzzcheck.\n\nFossilOrigin-Name: 1ef24e89c9630fd383ba32f5aefcf9c27907f27f5072f3537a1cfd75a093a8d7",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "test/fuzzcheck.c||test/fuzzcheck.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: fb9074ff450a67feaa62ca61d19154de26d5c8a8d147409ee6d1fbd667b2914f",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "test/fuzzcheck.c||test/fuzzcheck.c": [
          "File: test/fuzzcheck.c -> test/fuzzcheck.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "604:   if( iDiff > p->mxInterval ) p->mxInterval = iDiff;",
          "605:   p->nCb++;",
          "606:   if( rc==0 && p->mxCb>0 && p->mxCb<=p->nCb ) rc = 1;",
          "608:     printf(\"Timeout on progress callback %d\\n\", p->nCb);",
          "609:     fflush(stdout);",
          "610:     p->timeoutHit = 1;",
          "",
          "[Removed Lines]",
          "607:   if( rc && !p->timeoutHit && eVerbosity ){",
          "",
          "[Added Lines]",
          "607:   if( rc && !p->timeoutHit && eVerbosity>=2 ){",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "653:   sqlite3_stmt *pStmt;",
          "654:   while( isspace(zSql[0]) ) zSql++;",
          "655:   if( zSql[0]==0 ) return SQLITE_OK;",
          "657:     printf(\"RUNNING-SQL: [%s]\\n\", zSql);",
          "658:     fflush(stdout);",
          "659:   }",
          "660:   rc = sqlite3_prepare_v2(db, zSql, -1, &pStmt, 0);",
          "661:   if( rc==SQLITE_OK ){",
          "662:     while( (rc = sqlite3_step(pStmt))==SQLITE_ROW ){",
          "664:         int j;",
          "665:         for(j=0; j<sqlite3_column_count(pStmt); j++){",
          "666:           if( j ) printf(\",\");",
          "",
          "[Removed Lines]",
          "656:   if( eVerbosity>=3 ){",
          "663:       if( eVerbosity>=4 ){",
          "",
          "[Added Lines]",
          "656:   if( eVerbosity>=4 ){",
          "663:       if( eVerbosity>=5 ){",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "707:         printf(\"\\n\");",
          "708:         fflush(stdout);",
          "712:       printf(\"SQL-ERROR: (%d) %s\\n\", rc, sqlite3_errmsg(db));",
          "713:       fflush(stdout);",
          "714:     }",
          "716:     printf(\"SQL-ERROR (%d): %s\\n\", rc, sqlite3_errmsg(db));",
          "717:     fflush(stdout);",
          "",
          "[Removed Lines]",
          "711:     if( rc!=SQLITE_DONE && eVerbosity>=3 ){",
          "715:   }else if( eVerbosity>=3 ){",
          "",
          "[Added Lines]",
          "711:     if( rc!=SQLITE_DONE && eVerbosity>=4 ){",
          "715:   }else if( eVerbosity>=4 ){",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "745:   iSql = decodeDatabase((unsigned char*)aData, (int)nByte, &aDb, &nDb);",
          "746:   if( iSql<0 ) return 0;",
          "747:   nSql = nByte - iSql;",
          "749:     printf(",
          "750:       \"****** %d-byte input, %d-byte database, %d-byte script \"",
          "751:       \"******\\n\", (int)nByte, nDb, nSql);",
          "",
          "[Removed Lines]",
          "748:   if( eVerbosity>=2 ){",
          "",
          "[Added Lines]",
          "748:   if( eVerbosity>=3 ){",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "830:   if( rc!=SQLITE_OK ){",
          "831:     fprintf(stdout, \"sqlite3_close() returns %d\\n\", rc);",
          "832:   }",
          "834:     fprintf(stdout, \"Peak memory usages: %f MB\\n\",",
          "835:        sqlite3_memory_highwater(1) / 1000000.0);",
          "836:   }",
          "",
          "[Removed Lines]",
          "833:   if( eVerbosity ){",
          "",
          "[Added Lines]",
          "833:   if( eVerbosity>=2 ){",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "856: static int isDbSql(unsigned char *a, int n){",
          "857:   if( n>4 && memcmp(a,\"\\n--\\n\",4)==0 ) return 1;",
          "858:   while( n>0 && isspace(a[0]) ){ a++; n--; }",
          "860:   return 0;",
          "861: }",
          "",
          "[Removed Lines]",
          "859:   if( n>8 && memcmp(a,\"53514c69\",8)==0 ) return 1;",
          "",
          "[Added Lines]",
          "857:   unsigned char buf[12];",
          "858:   int i;",
          "861:   for(i=0; n>0 && i<8; n--, a++){",
          "862:     if( isxdigit(a[0]) ) buf[i++] = a[0];",
          "863:   }",
          "864:   if( i==8 && memcmp(buf,\"53514c69\",8)==0 ) return 1;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "d4cd292c2aa7e453ee3879d47df0c0503b47db75",
      "candidate_info": {
        "commit_hash": "d4cd292c2aa7e453ee3879d47df0c0503b47db75",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/d4cd292c2aa7e453ee3879d47df0c0503b47db75",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/insert.c"
        ],
        "message": "Bug fix with INSERT using an explicit column list on a table with a non-final STORED column.\n\nFossilOrigin-Name: 61b4459ae6a6cc182c11abbc8b1dd629f77beb088d7ccad5e563d8d4769056df",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/insert.c||src/insert.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: fe7517bf4d360597576ab9aba29627d7926d23f2bbbfb3e7bf4d32761617574c",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/insert.c||src/insert.c": [
          "File: src/insert.c -> src/insert.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "698:   if( pColumn ){",
          "699:     for(i=0; i<pColumn->nId; i++){",
          "700:       pColumn->a[i].idx = -1;",
          "",
          "[Removed Lines]",
          "697:   bIdListInOrder = (pTab->tabFlags & TF_OOOHidden)==0;",
          "",
          "[Added Lines]",
          "697:   bIdListInOrder = (pTab->tabFlags & (TF_OOOHidden|TF_HasStored))==0;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "112e174020809d0b91249716fb9de4aa3ee7437d",
      "candidate_info": {
        "commit_hash": "112e174020809d0b91249716fb9de4aa3ee7437d",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/112e174020809d0b91249716fb9de4aa3ee7437d",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/test1.c",
          "test/releasetest.tcl"
        ],
        "message": "Avoid a sanitizer error in test1.c. Have releasetest.tcl/wapptest.tcl create a file called \"makecommand.sh\" that can be used to rerun a test from the command line.\n\nFossilOrigin-Name: 4de4480ffdea1e923c4b964692ccde92d713c8b6c056bb04bddf1ff55ee891ec",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/test1.c||src/test1.c",
          "test/releasetest.tcl||test/releasetest.tcl"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: ee886600297c2a03d9d1d10db88d3d107b48e5d4de5e5d91b0ab16cc7c447ede",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/test1.c||src/test1.c": [
          "File: src/test1.c -> src/test1.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4272:   }",
          "4273:   pzTail = objc>=5 ? &zTail : 0;",
          "4274:   rc = sqlite3_prepare_v2(db, zCopy, bytes, &pStmt, pzTail);",
          "4275:   free(zCopy);",
          "4278:   assert(rc==SQLITE_OK || pStmt==0);",
          "4279:   Tcl_ResetResult(interp);",
          "4280:   if( sqlite3TestErrCode(interp, db, rc) ) return TCL_ERROR;",
          "4282:     if( bytes>=0 ){",
          "4283:       bytes = bytes - (int)(zTail-zSql);",
          "4284:     }",
          "",
          "[Removed Lines]",
          "4276:   zTail = &zSql[(zTail - zCopy)];",
          "4281:   if( rc==SQLITE_OK && zTail && objc>=5 ){",
          "",
          "[Added Lines]",
          "4275:   if( objc>=5 ){",
          "4276:     zTail = &zSql[(zTail - zCopy)];",
          "4277:   }",
          "4283:   if( rc==SQLITE_OK && objc>=5 && zTail ){",
          "",
          "---------------"
        ],
        "test/releasetest.tcl||test/releasetest.tcl": [
          "File: test/releasetest.tcl -> test/releasetest.tcl",
          "--- Hunk 1 ---",
          "[Context before]",
          "501:       unset -nocomplain savedEnv(TCLSH_CMD)",
          "502:     }",
          "503:     set ::env(TCLSH_CMD) [file nativename [info nameofexecutable]]",
          "505:     if {[info exists savedEnv(TCLSH_CMD)]} {",
          "506:       set ::env(TCLSH_CMD) $savedEnv(TCLSH_CMD)",
          "507:     } else {",
          "",
          "[Removed Lines]",
          "504:     set rc [catch [makeCommand $testtarget $makeOpts $cflags $opts]]",
          "",
          "[Added Lines]",
          "505:     # Create a file called \"makecommand.sh\" containing the text of",
          "506:     # the make command line.",
          "507:     catch {",
          "508:       set cmd [makeCommand $testtarget $makeOpts $cflags $opts]",
          "509:       set fd [open makecommand.sh w]",
          "510:       foreach e $cmd {",
          "511:         if {[string first \" \" $e]>=0} {",
          "512:           puts -nonewline $fd \"\\\"$e\\\"\"",
          "513:         } else {",
          "514:           puts -nonewline $fd $e",
          "515:         }",
          "516:         puts -nonewline $fd \" \"",
          "517:       }",
          "518:       puts $fd \"\"",
          "519:       close $fd",
          "520:     } msg",
          "522:     # Run the make command.",
          "523:     set rc [catch {trace_cmd exec {*}$cmd >>& test.log} msg]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "737: # specified targets, compiler flags, and options.",
          "738: #",
          "739: proc makeCommand { targets makeOpts cflags opts } {",
          "741:   if {$::MSVC} {",
          "742:     set nmakeDir [file nativename $::SRCDIR]",
          "743:     set nmakeFile [file nativename [file join $nmakeDir Makefile.msc]]",
          "",
          "[Removed Lines]",
          "740:   set result [list trace_cmd exec]",
          "",
          "[Added Lines]",
          "759:   set result [list]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "758:   foreach target $targets {",
          "759:     lappend result $target",
          "760:   }",
          "762: }",
          "764: # The following procedure prints its arguments if ::TRACE is true.",
          "",
          "[Removed Lines]",
          "761:   lappend result CFLAGS=$cflags OPTS=$opts >>& test.log",
          "",
          "[Added Lines]",
          "780:   lappend result CFLAGS=$cflags OPTS=$opts",
          "",
          "---------------"
        ]
      }
    }
  ]
}
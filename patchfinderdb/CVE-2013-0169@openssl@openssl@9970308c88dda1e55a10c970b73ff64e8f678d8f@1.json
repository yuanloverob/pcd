{
  "cve_id": "CVE-2013-0169",
  "cve_desc": "The TLS protocol 1.1 and 1.2 and the DTLS protocol 1.0 and 1.2, as used in OpenSSL, OpenJDK, PolarSSL, and other products, do not properly consider timing side-channel attacks on a MAC check requirement during the processing of malformed CBC padding, which allows remote attackers to conduct distinguishing attacks and plaintext-recovery attacks via statistical analysis of timing data for crafted packets, aka the \"Lucky Thirteen\" issue.",
  "repo": "openssl/openssl",
  "patch_hash": "9970308c88dda1e55a10c970b73ff64e8f678d8f",
  "patch_info": {
    "commit_hash": "9970308c88dda1e55a10c970b73ff64e8f678d8f",
    "repo": "openssl/openssl",
    "commit_url": "https://github.com/openssl/openssl/commit/9970308c88dda1e55a10c970b73ff64e8f678d8f",
    "files": [
      "crypto/evp/c_allc.c",
      "crypto/evp/e_aes_cbc_hmac_sha1.c",
      "ssl/s3_cbc.c",
      "ssl/ssl_algs.c"
    ],
    "message": "e_aes_cbc_hmac_sha1.c: address the CBC decrypt timing issues.\n\nAddress CBC decrypt timing issues and reenable the AESNI+SHA1 stitch.\n(cherry picked from commit 125093b59f3c2a2d33785b5563d929d0472f1721)",
    "before_after_code_files": [
      "crypto/evp/c_allc.c||crypto/evp/c_allc.c",
      "crypto/evp/e_aes_cbc_hmac_sha1.c||crypto/evp/e_aes_cbc_hmac_sha1.c",
      "ssl/s3_cbc.c||ssl/s3_cbc.c",
      "ssl/ssl_algs.c||ssl/ssl_algs.c"
    ]
  },
  "patch_diff": {
    "crypto/evp/c_allc.c||crypto/evp/c_allc.c": [
      "File: crypto/evp/c_allc.c -> crypto/evp/c_allc.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "195:  EVP_add_cipher(EVP_aes_256_xts());",
      "196:  EVP_add_cipher_alias(SN_aes_256_cbc,\"AES256\");",
      "197:  EVP_add_cipher_alias(SN_aes_256_cbc,\"aes256\");",
      "199: #if !defined(OPENSSL_NO_SHA) && !defined(OPENSSL_NO_SHA1)",
      "200:  EVP_add_cipher(EVP_aes_128_cbc_hmac_sha1());",
      "201:  EVP_add_cipher(EVP_aes_256_cbc_hmac_sha1());",
      "202: #endif",
      "203: #endif",
      "206: #ifndef OPENSSL_NO_CAMELLIA",
      "207:  EVP_add_cipher(EVP_camellia_128_ecb());",
      "",
      "[Removed Lines]",
      "204: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "crypto/evp/e_aes_cbc_hmac_sha1.c||crypto/evp/e_aes_cbc_hmac_sha1.c": [
      "File: crypto/evp/e_aes_cbc_hmac_sha1.c -> crypto/evp/e_aes_cbc_hmac_sha1.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "89:  defined(_M_AMD64) || defined(_M_X64) || \\",
      "90:  defined(__INTEL__) )",
      "92: extern unsigned int OPENSSL_ia32cap_P[2];",
      "93: #define AESNI_CAPABLE   (1<<(57-32))",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "92: #if defined(__GNUC__) && __GNUC__>=2 && !defined(PEDANTIC)",
      "93: # define BSWAP(x) ({ unsigned int r=(x); asm (\"bswapl %0\":\"=r\"(r):\"0\"(r)); r; })",
      "94: #endif",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "166:   SHA1_Update(c,ptr,res);",
      "167: }",
      "169: #define SHA1_Update sha1_update",
      "171: static int aesni_cbc_hmac_sha1_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "173: #ifdef SHA1_Update",
      "174: #undef SHA1_Update",
      "175: #endif",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "183:  sha_off = SHA_CBLOCK-key->md.num;",
      "184: #endif",
      "186:  if (len%AES_BLOCK_SIZE) return 0;",
      "188:  if (ctx->encrypt) {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "193:  key->payload_length = NO_PAYLOAD_LENGTH;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "233:      &key->ks,ctx->iv,1);",
      "234:   }",
      "235:  } else {",
      "239:   aesni_cbc_encrypt(in,out,len,",
      "240:     &key->ks,ctx->iv,0);",
      "249:    if ((key->aux.tls_aad[plen-4]<<8|key->aux.tls_aad[plen-3])",
      "252:     iv = AES_BLOCK_SIZE;",
      "259:    key->md = key->head;",
      "260:    SHA1_Update(&key->md,key->aux.tls_aad,plen);",
      "264:    key->md = key->tail;",
      "270:   } else {",
      "271:    SHA1_Update(&key->md,out,len);",
      "272:   }",
      "273:  }",
      "277:  return 1;",
      "278:  }",
      "",
      "[Removed Lines]",
      "236:   unsigned char mac[SHA_DIGEST_LENGTH];",
      "244:    if (len<(size_t)(out[len-1]+1+SHA_DIGEST_LENGTH))",
      "245:     return 0;",
      "247:    len -= (out[len-1]+1+SHA_DIGEST_LENGTH);",
      "250:        >= TLS1_1_VERSION) {",
      "251:     len -= AES_BLOCK_SIZE;",
      "253:    }",
      "255:    key->aux.tls_aad[plen-2] = len>>8;",
      "256:    key->aux.tls_aad[plen-1] = len;",
      "261:    SHA1_Update(&key->md,out+iv,len);",
      "262:    SHA1_Final(mac,&key->md);",
      "265:    SHA1_Update(&key->md,mac,SHA_DIGEST_LENGTH);",
      "266:    SHA1_Final(mac,&key->md);",
      "268:    if (memcmp(out+iv+len,mac,SHA_DIGEST_LENGTH))",
      "269:     return 0;",
      "275:  key->payload_length = NO_PAYLOAD_LENGTH;",
      "",
      "[Added Lines]",
      "245:   union { unsigned int  u[SHA_DIGEST_LENGTH/sizeof(unsigned int)];",
      "246:    unsigned char c[SHA_DIGEST_LENGTH]; } mac;",
      "253:    size_t inp_len, mask, j, i;",
      "254:    unsigned int res, maxpad, pad, bitlen;",
      "255:    int ret = 1;",
      "256:    union { unsigned int  u[SHA_LBLOCK];",
      "257:     unsigned char c[SHA_CBLOCK]; }",
      "261:        >= TLS1_1_VERSION)",
      "264:    if (len<(iv+SHA_DIGEST_LENGTH+1))",
      "265:     return 0;",
      "268:    out += iv;",
      "269:    len -= iv;",
      "272:    pad = out[len-1];",
      "273:    maxpad = len-(SHA_DIGEST_LENGTH+1);",
      "274:    maxpad |= (255-maxpad)>>(sizeof(maxpad)*8-8);",
      "275:    maxpad &= 255;",
      "277:    inp_len = len - (SHA_DIGEST_LENGTH+pad+1);",
      "278:    mask = (0-((inp_len-len)>>(sizeof(inp_len)*8-1)));",
      "279:    inp_len &= mask;",
      "280:    ret &= (int)mask;",
      "282:    key->aux.tls_aad[plen-2] = inp_len>>8;",
      "283:    key->aux.tls_aad[plen-1] = inp_len;",
      "289: #if 1",
      "291:    if (len>=(256+SHA_CBLOCK)) {",
      "292:     j = (len-(256+SHA_CBLOCK))&(0-SHA_CBLOCK);",
      "293:     j += SHA_CBLOCK-key->md.num;",
      "294:     SHA1_Update(&key->md,out,j);",
      "295:     out += j;",
      "296:     len -= j;",
      "297:     inp_len -= j;",
      "298:    }",
      "302:    mac.c[0] = 0;",
      "303:    mac.c[1] = (unsigned char)(bitlen>>16);",
      "304:    mac.c[2] = (unsigned char)(bitlen>>8);",
      "305:    mac.c[3] = (unsigned char)bitlen;",
      "306:    bitlen = mac.u[0];",
      "308:    mac.u[0]=0;",
      "309:    mac.u[1]=0;",
      "310:    mac.u[2]=0;",
      "311:    mac.u[3]=0;",
      "312:    mac.u[4]=0;",
      "314:    for (res=key->md.num, j=0;j<len;j++) {",
      "315:     size_t c = out[j];",
      "316:     mask = (j-inp_len)>>(sizeof(j)*8-8);",
      "317:     c &= mask;",
      "318:     c |= 0x80&~mask&~((inp_len-j)>>(sizeof(j)*8-8));",
      "319:     data->c[res++]=(unsigned char)c;",
      "321:     if (res!=SHA_CBLOCK) continue;",
      "323:     mask = 0-((inp_len+8-j)>>(sizeof(j)*8-1));",
      "324:     data->u[SHA_LBLOCK-1] |= bitlen&mask;",
      "325:     sha1_block_data_order(&key->md,data,1);",
      "326:     mask &= 0-((j-inp_len-73)>>(sizeof(j)*8-1));",
      "327:     mac.u[0] |= key->md.h0 & mask;",
      "328:     mac.u[1] |= key->md.h1 & mask;",
      "329:     mac.u[2] |= key->md.h2 & mask;",
      "330:     mac.u[3] |= key->md.h3 & mask;",
      "331:     mac.u[4] |= key->md.h4 & mask;",
      "332:     res=0;",
      "333:    }",
      "335:    for(i=res;i<SHA_CBLOCK;i++,j++) data->c[i]=0;",
      "337:    if (res>SHA_CBLOCK-8) {",
      "338:     mask = 0-((inp_len+8-j)>>(sizeof(j)*8-1));",
      "339:     data->u[SHA_LBLOCK-1] |= bitlen&mask;",
      "340:     sha1_block_data_order(&key->md,data,1);",
      "341:     mask &= 0-((j-inp_len-73)>>(sizeof(j)*8-1));",
      "342:     mac.u[0] |= key->md.h0 & mask;",
      "343:     mac.u[1] |= key->md.h1 & mask;",
      "344:     mac.u[2] |= key->md.h2 & mask;",
      "345:     mac.u[3] |= key->md.h3 & mask;",
      "346:     mac.u[4] |= key->md.h4 & mask;",
      "348:     memset(data,0,SHA_CBLOCK);",
      "349:     j+=64;",
      "350:    }",
      "351:    data->u[SHA_LBLOCK-1] = bitlen;",
      "352:    sha1_block_data_order(&key->md,data,1);",
      "353:    mask = 0-((j-inp_len-73)>>(sizeof(j)*8-1));",
      "354:    mac.u[0] |= key->md.h0 & mask;",
      "355:    mac.u[1] |= key->md.h1 & mask;",
      "356:    mac.u[2] |= key->md.h2 & mask;",
      "357:    mac.u[3] |= key->md.h3 & mask;",
      "358:    mac.u[4] |= key->md.h4 & mask;",
      "360: #ifdef BSWAP",
      "361:    mac.u[0] = BSWAP(mac.u[0]);",
      "362:    mac.u[1] = BSWAP(mac.u[1]);",
      "363:    mac.u[2] = BSWAP(mac.u[2]);",
      "364:    mac.u[3] = BSWAP(mac.u[3]);",
      "365:    mac.u[4] = BSWAP(mac.u[4]);",
      "366: #else",
      "367:    for (i=0;i<5;i++) {",
      "368:     res = mac.u[i];",
      "369:     mac.c[4*i+0]=(unsigned char)(res>>24);",
      "370:     mac.c[4*i+1]=(unsigned char)(res>>16);",
      "371:     mac.c[4*i+2]=(unsigned char)(res>>8);",
      "372:     mac.c[4*i+3]=(unsigned char)res;",
      "373:    }",
      "374: #endif",
      "375:    len += SHA_DIGEST_LENGTH;",
      "376: #else",
      "377:    SHA1_Update(&key->md,out,inp_len);",
      "378:    res = key->md.num;",
      "379:    SHA1_Final(mac.c,&key->md);",
      "381:    {",
      "382:    unsigned int inp_blocks, pad_blocks;",
      "385:    inp_blocks = 1+((SHA_CBLOCK-9-res)>>(sizeof(res)*8-1));",
      "386:    res += (unsigned int)(len-inp_len);",
      "387:    pad_blocks = res / SHA_CBLOCK;",
      "388:    res %= SHA_CBLOCK;",
      "389:    pad_blocks += 1+((SHA_CBLOCK-9-res)>>(sizeof(res)*8-1));",
      "390:    for (;inp_blocks<pad_blocks;inp_blocks++)",
      "391:     sha1_block_data_order(&key->md,data,1);",
      "392:    }",
      "393: #endif",
      "395:    SHA1_Update(&key->md,mac.c,SHA_DIGEST_LENGTH);",
      "396:    SHA1_Final(mac.c,&key->md);",
      "399:    out += inp_len;",
      "400:    len -= inp_len;",
      "401: #if 1",
      "402:    {",
      "403:    unsigned char *p = out+len-1-maxpad-SHA_DIGEST_LENGTH;",
      "404:    size_t off = out-p;",
      "405:    unsigned int c, cmask;",
      "407:    maxpad += SHA_DIGEST_LENGTH;",
      "408:    for (res=0,i=0,j=0;j<maxpad;j++) {",
      "409:     c = p[j];",
      "410:     cmask = ((int)(j-off-SHA_DIGEST_LENGTH))>>(sizeof(int)*8-1);",
      "412:     cmask &= ((int)(off-1-j))>>(sizeof(int)*8-1);",
      "413:     res |= (c^mac.c[i])&cmask;",
      "414:     i += 1&cmask;",
      "415:    }",
      "416:    maxpad -= SHA_DIGEST_LENGTH;",
      "418:    res = 0-((0-res)>>(sizeof(res)*8-1));",
      "419:    ret &= (int)~res;",
      "420:    }",
      "421: #else",
      "422:    for (res=0,i=0;i<SHA_DIGEST_LENGTH;i++)",
      "423:     res |= out[i]^mac.c[i];",
      "424:    res = 0-((0-res)>>(sizeof(res)*8-1));",
      "425:    ret &= (int)~res;",
      "428:    pad = (pad&~res) | (maxpad&res);",
      "429:    out = out+len-1-pad;",
      "430:    for (res=0,i=0;i<pad;i++)",
      "431:     res |= out[i]^pad;",
      "433:    res = (0-res)>>(sizeof(res)*8-1);",
      "434:    ret &= (int)~res;",
      "435: #endif",
      "436:    return ret;",
      "",
      "---------------"
    ],
    "ssl/s3_cbc.c||ssl/s3_cbc.c": [
      "File: ssl/s3_cbc.c -> ssl/s3_cbc.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "150:  if (overhead > rec->length)",
      "151:   return 0;",
      "153:  padding_length = rec->data[rec->length-1];",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "161:  if (has_explicit_iv)",
      "162:   {",
      "163:   rec->data += block_size;",
      "164:   rec->input += block_size;",
      "165:   rec->length -= block_size;",
      "166:   }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "172:    }",
      "173:   }",
      "175:  good = constant_time_ge(rec->length, overhead+padding_length);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "190:  if (EVP_CIPHER_flags(s->enc_read_ctx->cipher)&EVP_CIPH_FLAG_AEAD_CIPHER)",
      "191:   {",
      "193:   rec->length -= padding_length;",
      "194:   return 1;",
      "195:   }",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "209:  rec->length -= padding_length;",
      "227:  return (int)((good & 1) | (~good & -1));",
      "228:  }",
      "",
      "[Removed Lines]",
      "220:  if (has_explicit_iv)",
      "221:   {",
      "222:   rec->data += block_size;",
      "223:   rec->input += block_size;",
      "224:   rec->length -= block_size;",
      "225:   }",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "ssl/ssl_algs.c||ssl/ssl_algs.c": [
      "File: ssl/ssl_algs.c -> ssl/ssl_algs.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "90:  EVP_add_cipher(EVP_aes_256_cbc());",
      "91:  EVP_add_cipher(EVP_aes_128_gcm());",
      "92:  EVP_add_cipher(EVP_aes_256_gcm());",
      "94: #if !defined(OPENSSL_NO_SHA) && !defined(OPENSSL_NO_SHA1)",
      "95:  EVP_add_cipher(EVP_aes_128_cbc_hmac_sha1());",
      "96:  EVP_add_cipher(EVP_aes_256_cbc_hmac_sha1());",
      "97: #endif",
      "100: #endif",
      "101: #ifndef OPENSSL_NO_CAMELLIA",
      "",
      "[Removed Lines]",
      "98: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "cbd64894ec687c6f37d8e43c16dff78e63f6be87",
      "candidate_info": {
        "commit_hash": "cbd64894ec687c6f37d8e43c16dff78e63f6be87",
        "repo": "openssl/openssl",
        "commit_url": "https://github.com/openssl/openssl/commit/cbd64894ec687c6f37d8e43c16dff78e63f6be87",
        "files": [
          "ssl/s3_cbc.c",
          "ssl/s3_clnt.c",
          "ssl/s3_lib.c",
          "ssl/s3_pkt.c",
          "ssl/s3_srvr.c",
          "ssl/ssl_lib.c",
          "ssl/ssl_locl.h",
          "ssl/t1_enc.c",
          "ssl/t1_lib.c",
          "ssl/t1_trce.c"
        ],
        "message": "Use enc_flags when deciding protocol variations.\n\nUse the enc_flags field to determine whether we should use explicit IV,\nsignature algorithms or SHA256 default PRF instead of hard coding which\nversions support each requirement.",
        "before_after_code_files": [
          "ssl/s3_cbc.c||ssl/s3_cbc.c",
          "ssl/s3_clnt.c||ssl/s3_clnt.c",
          "ssl/s3_lib.c||ssl/s3_lib.c",
          "ssl/s3_pkt.c||ssl/s3_pkt.c",
          "ssl/s3_srvr.c||ssl/s3_srvr.c",
          "ssl/ssl_lib.c||ssl/ssl_lib.c",
          "ssl/ssl_locl.h||ssl/ssl_locl.h",
          "ssl/t1_enc.c||ssl/t1_enc.c",
          "ssl/t1_lib.c||ssl/t1_lib.c",
          "ssl/t1_trce.c||ssl/t1_trce.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "ssl/s3_cbc.c||ssl/s3_cbc.c"
          ],
          "candidate": [
            "ssl/s3_cbc.c||ssl/s3_cbc.c"
          ]
        }
      },
      "candidate_diff": {
        "ssl/s3_cbc.c||ssl/s3_cbc.c": [
          "File: ssl/s3_cbc.c -> ssl/s3_cbc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "146:  unsigned padding_length, good, to_check, i;",
          "147:  const unsigned overhead = 1 /* padding length byte */ + mac_size;",
          "150:   {",
          "",
          "[Removed Lines]",
          "149:  if (s->version >= TLS1_1_VERSION || s->version == DTLS1_BAD_VER)",
          "",
          "[Added Lines]",
          "149:  if (SSL_USE_EXPLICIT_IV(s))",
          "",
          "---------------"
        ],
        "ssl/s3_clnt.c||ssl/s3_clnt.c": [
          "File: ssl/s3_clnt.c -> ssl/s3_clnt.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1030:    }",
          "1031:   }",
          "1032:  s->s3->tmp.new_cipher=c;",
          "1037:   goto f_err;",
          "",
          "[Removed Lines]",
          "1036:  if (TLS1_get_version(s) < TLS1_2_VERSION && !ssl3_digest_cached_records(s))",
          "",
          "[Added Lines]",
          "1036:  if (!SSL_USE_SIGALGS(s) && !ssl3_digest_cached_records(s))",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1786:  if (pkey != NULL)",
          "1787:   {",
          "1789:    {",
          "1790:    int rv = tls12_check_peer_sigalg(&md, s, p, pkey);",
          "1791:    if (rv == -1)",
          "",
          "[Removed Lines]",
          "1788:   if (TLS1_get_version(s) >= TLS1_2_VERSION)",
          "",
          "[Added Lines]",
          "1788:   if (SSL_USE_SIGALGS(s))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1817:    }",
          "1819: #ifndef OPENSSL_NO_RSA",
          "1821:    {",
          "1822:    int num;",
          "",
          "[Removed Lines]",
          "1820:   if (pkey->type == EVP_PKEY_RSA && TLS1_get_version(s) < TLS1_2_VERSION)",
          "",
          "[Added Lines]",
          "1820:   if (pkey->type == EVP_PKEY_RSA && !SSL_USE_SIGALGS(s))",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1991:  for (i=0; i<ctype_num; i++)",
          "1992:   s->s3->tmp.ctype[i]= p[i];",
          "1993:  p+=p[-1];",
          "1995:   {",
          "1996:   n2s(p, llen);",
          "",
          "[Removed Lines]",
          "1994:  if (TLS1_get_version(s) >= TLS1_2_VERSION)",
          "",
          "[Added Lines]",
          "1994:  if (SSL_USE_SIGALGS(s))",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "3051:   EVP_PKEY_sign_init(pctx);",
          "3052:   if (EVP_PKEY_CTX_set_signature_md(pctx, EVP_sha1())>0)",
          "3053:    {",
          "3055:     s->method->ssl3_enc->cert_verify_mac(s,",
          "3056:       NID_sha1,",
          "3057:       &(data[MD5_DIGEST_LENGTH]));",
          "",
          "[Removed Lines]",
          "3054:    if (TLS1_get_version(s) < TLS1_2_VERSION)",
          "",
          "[Added Lines]",
          "3054:    if (!SSL_USE_SIGALGS(s))",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "3067:    {",
          "3068:    long hdatalen = 0;",
          "3069:    void *hdata;",
          "",
          "[Removed Lines]",
          "3066:   if (TLS1_get_version(s) >= TLS1_2_VERSION)",
          "",
          "[Added Lines]",
          "3066:   if (SSL_USE_SIGALGS(s))",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "3193:  if (!s->cert || !s->cert->key->x509 || !s->cert->key->privatekey)",
          "3194:   return 0;",
          "3197:   return 0;",
          "",
          "[Removed Lines]",
          "3196:  if (TLS1_get_version(s) >= TLS1_2_VERSION && !s->cert->key->digest)",
          "",
          "[Added Lines]",
          "3196:  if (SSL_USE_SIGALGS(s) && !s->cert->key->digest)",
          "",
          "---------------"
        ],
        "ssl/s3_lib.c||ssl/s3_lib.c": [
          "File: ssl/s3_lib.c -> ssl/s3_lib.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4458:   }",
          "4459:  return(ret);",
          "4460:  }",
          "4464: long ssl_get_algorithm2(SSL *s)",
          "4465:  {",
          "4466:  long alg2 = s->s3->tmp.new_cipher->algorithm2;",
          "4469:   return SSL_HANDSHAKE_MAC_SHA256 | TLS1_PRF_SHA256;",
          "4470:  return alg2;",
          "4471:  }",
          "",
          "[Removed Lines]",
          "4467:  if (TLS1_get_version(s) >= TLS1_2_VERSION &&",
          "4468:      alg2 == (SSL_HANDSHAKE_MAC_DEFAULT|TLS1_PRF))",
          "",
          "[Added Lines]",
          "4467:  if (s->method->ssl3_enc->enc_flags & SSL_ENC_FLAG_SHA256_PRF",
          "4468:      && alg2 == (SSL_HANDSHAKE_MAC_DEFAULT|TLS1_PRF))",
          "",
          "---------------"
        ],
        "ssl/s3_pkt.c||ssl/s3_pkt.c": [
          "File: ssl/s3_pkt.c -> ssl/s3_pkt.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "184:   {",
          "185:   if (left > 0 && n > left)",
          "186:    n = left;",
          "",
          "[Removed Lines]",
          "183:  if (SSL_version(s) == DTLS1_VERSION || SSL_version(s) == DTLS1_BAD_VER)",
          "",
          "[Added Lines]",
          "183:  if (SSL_IS_DTLS(s))",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "248:    {",
          "249:    rb->left = left;",
          "250:    if (s->mode & SSL_MODE_RELEASE_BUFFERS &&",
          "252:     if (len+left == 0)",
          "253:      ssl3_release_read_buffer(s);",
          "254:    return(i);",
          "",
          "[Removed Lines]",
          "251:        SSL_version(s) != DTLS1_VERSION && SSL_version(s) != DTLS1_BAD_VER)",
          "",
          "[Added Lines]",
          "251:     !SSL_IS_DTLS(s))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "261:    {",
          "262:    if (n > left)",
          "",
          "[Removed Lines]",
          "260:   if (SSL_version(s) == DTLS1_VERSION || SSL_version(s) == DTLS1_BAD_VER)",
          "",
          "[Added Lines]",
          "260:   if (SSL_IS_DTLS(s))",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "758:  plen=p;",
          "759:  p+=2;",
          "762:   {",
          "763:   int mode = EVP_CIPHER_CTX_mode(s->enc_write_ctx);",
          "764:   if (mode == EVP_CIPH_CBC_MODE)",
          "",
          "[Removed Lines]",
          "761:  if (s->enc_write_ctx && s->version >= TLS1_1_VERSION)",
          "",
          "[Added Lines]",
          "761:  if (s->enc_write_ctx && SSL_USE_EXPLICIT_IV(s))",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "895:    wb->left=0;",
          "896:    wb->offset+=i;",
          "897:    if (s->mode & SSL_MODE_RELEASE_BUFFERS &&",
          "899:     ssl3_release_write_buffer(s);",
          "900:    s->rwstate=SSL_NOTHING;",
          "901:    return(s->s3->wpend_ret);",
          "",
          "[Removed Lines]",
          "898:        SSL_version(s) != DTLS1_VERSION && SSL_version(s) != DTLS1_BAD_VER)",
          "",
          "[Added Lines]",
          "898:     !SSL_IS_DTLS(s))",
          "",
          "---------------"
        ],
        "ssl/s3_srvr.c||ssl/s3_srvr.c": [
          "File: ssl/s3_srvr.c -> ssl/s3_srvr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "640: #endif",
          "641:     s->init_num = 0;",
          "642:     }",
          "644:     {",
          "645:     s->state=SSL3_ST_SR_CERT_VRFY_A;",
          "646:     s->init_num=0;",
          "647:     if (!s->session->peer)",
          "648:      break;",
          "652:     if (!s->s3->handshake_buffer)",
          "",
          "[Removed Lines]",
          "643:    else if (TLS1_get_version(s) >= TLS1_2_VERSION)",
          "",
          "[Added Lines]",
          "643:    else if (SSL_USE_SIGALGS(s))",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1038:  p+=j;",
          "1041:   {",
          "1043:   cookie_len = *(p++);",
          "",
          "[Removed Lines]",
          "1040:  if (s->version == DTLS1_VERSION || s->version == DTLS1_BAD_VER)",
          "",
          "[Added Lines]",
          "1040:  if (SSL_IS_DTLS(s))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1409:   s->s3->tmp.new_cipher=s->session->cipher;",
          "1410:   }",
          "1413:   {",
          "1414:   if (!ssl3_digest_cached_records(s))",
          "1415:    goto f_err;",
          "",
          "[Removed Lines]",
          "1412:  if (TLS1_get_version(s) < TLS1_2_VERSION || !(s->verify_mode & SSL_VERIFY_PEER))",
          "",
          "[Added Lines]",
          "1412:  if (!SSL_USE_SIGALGS(s) || !(s->verify_mode & SSL_VERIFY_PEER))",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1943: #ifndef OPENSSL_NO_RSA",
          "1946:     {",
          "1947:     q=md_buf;",
          "1948:     j=0;",
          "",
          "[Removed Lines]",
          "1944:    if (pkey->type == EVP_PKEY_RSA",
          "1945:      && TLS1_get_version(s) < TLS1_2_VERSION)",
          "",
          "[Added Lines]",
          "1944:    if (pkey->type == EVP_PKEY_RSA && !SSL_USE_SIGALGS(s))",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1973: #endif",
          "1974:    if (md)",
          "1975:     {",
          "1979:      {",
          "1980:      if (!tls12_get_sigandhash(p, pkey, md))",
          "1981:       {",
          "",
          "[Removed Lines]",
          "1978:     if (TLS1_get_version(s) >= TLS1_2_VERSION)",
          "",
          "[Added Lines]",
          "1976:     if (SSL_USE_SIGALGS(s))",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2002:      }",
          "2003:     s2n(i,p);",
          "2004:     n+=i+2;",
          "2006:      n+= 2;",
          "2007:     }",
          "2008:    else",
          "",
          "[Removed Lines]",
          "2005:     if (TLS1_get_version(s) >= TLS1_2_VERSION)",
          "",
          "[Added Lines]",
          "2003:     if (SSL_USE_SIGALGS(s))",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "2052:   p+=n;",
          "2053:   n++;",
          "2056:    {",
          "2057:    const unsigned char *psigs;",
          "2058:    nl = tls12_get_psigalgs(s, &psigs);",
          "",
          "[Removed Lines]",
          "2055:   if (TLS1_get_version(s) >= TLS1_2_VERSION)",
          "",
          "[Added Lines]",
          "2053:   if (SSL_USE_SIGALGS(s))",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "3024:   }",
          "3025:  else",
          "3026:   {",
          "3028:    {",
          "3029:    int rv = tls12_check_peer_sigalg(&md, s, p, pkey);",
          "3030:    if (rv == -1)",
          "",
          "[Removed Lines]",
          "3027:   if (TLS1_get_version(s) >= TLS1_2_VERSION)",
          "",
          "[Added Lines]",
          "3025:   if (SSL_USE_SIGALGS(s))",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "3060:   goto f_err;",
          "3061:   }",
          "3064:   {",
          "3065:   long hdatalen = 0;",
          "3066:   void *hdata;",
          "",
          "[Removed Lines]",
          "3063:  if (TLS1_get_version(s) >= TLS1_2_VERSION)",
          "",
          "[Added Lines]",
          "3061:  if (SSL_USE_SIGALGS(s))",
          "",
          "---------------"
        ],
        "ssl/ssl_lib.c||ssl/ssl_lib.c": [
          "File: ssl/ssl_lib.c -> ssl/ssl_lib.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1112:    return 0;",
          "1113: #endif",
          "1117:    {",
          "1118:    s->d1->mtu = larg;",
          "1119:    return larg;",
          "",
          "[Removed Lines]",
          "1115:   if (SSL_version(s) == DTLS1_VERSION ||",
          "1116:       SSL_version(s) == DTLS1_BAD_VER)",
          "",
          "[Added Lines]",
          "1115:   if (SSL_IS_DTLS(s))",
          "",
          "---------------"
        ],
        "ssl/ssl_locl.h||ssl/ssl_locl.h": [
          "File: ssl/ssl_locl.h -> ssl/ssl_locl.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "442: #define SSL_IS_DTLS(s) (s->method->ssl3_enc->enc_flags & SSL_ENC_FLAG_DTLS)",
          "446: #define SSL_PKEY_RSA_ENC 0",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "444: #define SSL_USE_EXPLICIT_IV(s) \\",
          "445:   (s->method->ssl3_enc->enc_flags & SSL_ENC_FLAG_EXPLICIT_IV)",
          "449: #define SSL_USE_SIGALGS(s) \\",
          "450:    (s->method->ssl3_enc->enc_flags & SSL_ENC_FLAG_SIGALGS)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "702: #define SSL_ENC_FLAG_EXPLICIT_IV 0x1",
          "704: #define SSL_ENC_FLAG_SIGALGS  0x2",
          "708: #ifndef OPENSSL_NO_COMP",
          "",
          "[Removed Lines]",
          "706: #define SSL_ENC_FLAG_DTLS  0x4",
          "",
          "[Added Lines]",
          "713: #define SSL_ENC_FLAG_SHA256_PRF  0x4",
          "715: #define SSL_ENC_FLAG_DTLS  0x8",
          "",
          "---------------"
        ],
        "ssl/t1_enc.c||ssl/t1_enc.c": [
          "File: ssl/t1_enc.c -> ssl/t1_enc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "780:    seq = send?s->s3->write_sequence:s->s3->read_sequence;",
          "783:     {",
          "784:     unsigned char dtlsseq[9],*p=dtlsseq;",
          "",
          "[Removed Lines]",
          "782:    if (s->version == DTLS1_VERSION || s->version == DTLS1_BAD_VER)",
          "",
          "[Added Lines]",
          "782:    if (SSL_IS_DTLS(s))",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1008:    mac_ctx = &hmac;",
          "1009:   }",
          "1012:   {",
          "1013:   unsigned char dtlsseq[8],*p=dtlsseq;",
          "",
          "[Removed Lines]",
          "1011:  if (ssl->version == DTLS1_VERSION || ssl->version == DTLS1_BAD_VER)",
          "",
          "[Added Lines]",
          "1011:  if (SSL_IS_DTLS(ssl))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1071: {unsigned int z; for (z=0; z<rec->length; z++) printf(\"%02X \",buf[z]); printf(\"\\n\"); }",
          "1072: #endif",
          "1075:   {",
          "1076:   for (i=7; i>=0; i--)",
          "1077:    {",
          "",
          "[Removed Lines]",
          "1074:  if (ssl->version != DTLS1_VERSION && ssl->version != DTLS1_BAD_VER)",
          "",
          "[Added Lines]",
          "1074:  if (SSL_IS_DTLS(ssl))",
          "",
          "---------------"
        ],
        "ssl/t1_lib.c||ssl/t1_lib.c": [
          "File: ssl/t1_lib.c -> ssl/t1_lib.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "178:  TLS_MD_SERVER_FINISH_CONST,TLS_MD_SERVER_FINISH_CONST_SIZE,",
          "179:  tls1_alert_code,",
          "180:  tls1_export_keying_material,",
          "182:  SSL3_HM_HEADER_LENGTH,",
          "183:  ssl3_set_handshake_header,",
          "184:  ssl3_handshake_write",
          "",
          "[Removed Lines]",
          "181:  SSL_ENC_FLAG_EXPLICIT_IV|SSL_ENC_FLAG_SIGALGS,",
          "",
          "[Added Lines]",
          "181:  SSL_ENC_FLAG_EXPLICIT_IV|SSL_ENC_FLAG_SIGALGS|SSL_ENC_FLAG_SHA256_PRF,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1297:   }",
          "1298:   skip_ext:",
          "1301:   {",
          "1302:   size_t salglen;",
          "1303:   const unsigned char *salg;",
          "",
          "[Removed Lines]",
          "1300:  if (TLS1_get_client_version(s) >= TLS1_2_VERSION)",
          "",
          "[Added Lines]",
          "1300:  if (SSL_USE_SIGALGS(s))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3031:  if (p >= limit)",
          "3032:   return -1;",
          "3035:   {",
          "3036:   i = *(p++);",
          "3037:   p+= i;",
          "",
          "[Removed Lines]",
          "3034:  if (s->version == DTLS1_VERSION || s->version == DTLS1_BAD_VER)",
          "",
          "[Added Lines]",
          "3034:  if (SSL_IS_DTLS(s))",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "3458:  const EVP_MD *md;",
          "3459:  CERT *c = s->cert;",
          "3460:  TLS_SIGALGS *sigptr;",
          "3463:   return 1;",
          "3465:  if (!c)",
          "",
          "[Removed Lines]",
          "3462:  if (TLS1_get_version(s) < TLS1_2_VERSION)",
          "",
          "[Added Lines]",
          "3462:  if (!SSL_USE_SIGALGS(s))",
          "",
          "---------------"
        ],
        "ssl/t1_trce.c||ssl/t1_trce.c": [
          "File: ssl/t1_trce.c -> ssl/t1_trce.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "531:  {",
          "532:  if (*pmsglen < 2)",
          "533:   return 0;",
          "535:   {",
          "536:   const unsigned char *p = *pmsg;",
          "537:   BIO_indent(bio, indent, 80);",
          "",
          "[Removed Lines]",
          "534:  if (TLS1_get_version(s) >= TLS1_2_VERSION)",
          "",
          "[Added Lines]",
          "534:  if (SSL_USE_SIGALGS(s))",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1046:   return 0;",
          "1047:  msg += xlen;",
          "1048:  msglen -= xlen + 1;",
          "1050:   goto skip_sig;",
          "1051:  if (msglen < 2)",
          "1052:   return 0;",
          "",
          "[Removed Lines]",
          "1049:  if (TLS1_get_version(s) < TLS1_2_VERSION)",
          "",
          "[Added Lines]",
          "1049:  if (!SSL_USE_SIGALGS(s))",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "5c60046553716fcf160718f59160493194f212dc",
      "candidate_info": {
        "commit_hash": "5c60046553716fcf160718f59160493194f212dc",
        "repo": "openssl/openssl",
        "commit_url": "https://github.com/openssl/openssl/commit/5c60046553716fcf160718f59160493194f212dc",
        "files": [
          "crypto/evp/e_aes_cbc_hmac_sha1.c"
        ],
        "message": "e_aes_cbc_hmac_sha1.c: fix rare bad record mac on AES-NI plaforms.\n\nPR: 3002",
        "before_after_code_files": [
          "crypto/evp/e_aes_cbc_hmac_sha1.c||crypto/evp/e_aes_cbc_hmac_sha1.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "crypto/evp/e_aes_cbc_hmac_sha1.c||crypto/evp/e_aes_cbc_hmac_sha1.c"
          ],
          "candidate": [
            "crypto/evp/e_aes_cbc_hmac_sha1.c||crypto/evp/e_aes_cbc_hmac_sha1.c"
          ]
        }
      },
      "candidate_diff": {
        "crypto/evp/e_aes_cbc_hmac_sha1.c||crypto/evp/e_aes_cbc_hmac_sha1.c": [
          "File: crypto/evp/e_aes_cbc_hmac_sha1.c -> crypto/evp/e_aes_cbc_hmac_sha1.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "328:     if (res!=SHA_CBLOCK) continue;",
          "331:     data->u[SHA_LBLOCK-1] |= bitlen&mask;",
          "332:     sha1_block_data_order(&key->md,data,1);",
          "334:     pmac->u[0] |= key->md.h0 & mask;",
          "335:     pmac->u[1] |= key->md.h1 & mask;",
          "336:     pmac->u[2] |= key->md.h2 & mask;",
          "",
          "[Removed Lines]",
          "330:     mask = 0-((inp_len+8-j)>>(sizeof(j)*8-1));",
          "333:     mask &= 0-((j-inp_len-73)>>(sizeof(j)*8-1));",
          "",
          "[Added Lines]",
          "331:     mask = 0-((inp_len+7-j)>>(sizeof(j)*8-1));",
          "334:     mask &= 0-((j-inp_len-72)>>(sizeof(j)*8-1));",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "2141e6f30b1fd2906830fd23d8eae71fe72acc47",
      "candidate_info": {
        "commit_hash": "2141e6f30b1fd2906830fd23d8eae71fe72acc47",
        "repo": "openssl/openssl",
        "commit_url": "https://github.com/openssl/openssl/commit/2141e6f30b1fd2906830fd23d8eae71fe72acc47",
        "files": [
          "crypto/evp/e_aes_cbc_hmac_sha1.c"
        ],
        "message": "e_aes_cbc_hmac_sha1.c: align calculated MAC at cache line.\n\nIt also ensures that valgring is happy.",
        "before_after_code_files": [
          "crypto/evp/e_aes_cbc_hmac_sha1.c||crypto/evp/e_aes_cbc_hmac_sha1.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "crypto/evp/e_aes_cbc_hmac_sha1.c||crypto/evp/e_aes_cbc_hmac_sha1.c"
          ],
          "candidate": [
            "crypto/evp/e_aes_cbc_hmac_sha1.c||crypto/evp/e_aes_cbc_hmac_sha1.c"
          ]
        }
      },
      "candidate_diff": {
        "crypto/evp/e_aes_cbc_hmac_sha1.c||crypto/evp/e_aes_cbc_hmac_sha1.c": [
          "File: crypto/evp/e_aes_cbc_hmac_sha1.c -> crypto/evp/e_aes_cbc_hmac_sha1.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "243:   }",
          "244:  } else {",
          "245:   union { unsigned int  u[SHA_DIGEST_LENGTH/sizeof(unsigned int)];",
          "249:   aesni_cbc_encrypt(in,out,len,",
          "",
          "[Removed Lines]",
          "246:    unsigned char c[SHA_DIGEST_LENGTH]; } mac;",
          "",
          "[Added Lines]",
          "246:    unsigned char c[32+SHA_DIGEST_LENGTH]; } mac, *pmac;",
          "249:   pmac = (void *)(((size_t)mac.c+31)&((size_t)0-32));",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "302:    mac.c[0] = 0;",
          "303:    mac.c[1] = (unsigned char)(bitlen>>16);",
          "304:    mac.c[2] = (unsigned char)(bitlen>>8);",
          "305:    mac.c[3] = (unsigned char)bitlen;",
          "306:    bitlen = mac.u[0];",
          "314:    for (res=key->md.num, j=0;j<len;j++) {",
          "315:     size_t c = out[j];",
          "",
          "[Removed Lines]",
          "308:    mac.u[0]=0;",
          "309:    mac.u[1]=0;",
          "310:    mac.u[2]=0;",
          "311:    mac.u[3]=0;",
          "312:    mac.u[4]=0;",
          "",
          "[Added Lines]",
          "305: #ifdef BSWAP",
          "306:    bitlen = BSWAP(bitlen);",
          "307: #else",
          "313: #endif",
          "315:    pmac->u[0]=0;",
          "316:    pmac->u[1]=0;",
          "317:    pmac->u[2]=0;",
          "318:    pmac->u[3]=0;",
          "319:    pmac->u[4]=0;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "324:     data->u[SHA_LBLOCK-1] |= bitlen&mask;",
          "325:     sha1_block_data_order(&key->md,data,1);",
          "326:     mask &= 0-((j-inp_len-73)>>(sizeof(j)*8-1));",
          "332:     res=0;",
          "333:    }",
          "",
          "[Removed Lines]",
          "327:     mac.u[0] |= key->md.h0 & mask;",
          "328:     mac.u[1] |= key->md.h1 & mask;",
          "329:     mac.u[2] |= key->md.h2 & mask;",
          "330:     mac.u[3] |= key->md.h3 & mask;",
          "331:     mac.u[4] |= key->md.h4 & mask;",
          "",
          "[Added Lines]",
          "334:     pmac->u[0] |= key->md.h0 & mask;",
          "335:     pmac->u[1] |= key->md.h1 & mask;",
          "336:     pmac->u[2] |= key->md.h2 & mask;",
          "337:     pmac->u[3] |= key->md.h3 & mask;",
          "338:     pmac->u[4] |= key->md.h4 & mask;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "339:     data->u[SHA_LBLOCK-1] |= bitlen&mask;",
          "340:     sha1_block_data_order(&key->md,data,1);",
          "341:     mask &= 0-((j-inp_len-73)>>(sizeof(j)*8-1));",
          "348:     memset(data,0,SHA_CBLOCK);",
          "349:     j+=64;",
          "",
          "[Removed Lines]",
          "342:     mac.u[0] |= key->md.h0 & mask;",
          "343:     mac.u[1] |= key->md.h1 & mask;",
          "344:     mac.u[2] |= key->md.h2 & mask;",
          "345:     mac.u[3] |= key->md.h3 & mask;",
          "346:     mac.u[4] |= key->md.h4 & mask;",
          "",
          "[Added Lines]",
          "349:     pmac->u[0] |= key->md.h0 & mask;",
          "350:     pmac->u[1] |= key->md.h1 & mask;",
          "351:     pmac->u[2] |= key->md.h2 & mask;",
          "352:     pmac->u[3] |= key->md.h3 & mask;",
          "353:     pmac->u[4] |= key->md.h4 & mask;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "351:    data->u[SHA_LBLOCK-1] = bitlen;",
          "352:    sha1_block_data_order(&key->md,data,1);",
          "353:    mask = 0-((j-inp_len-73)>>(sizeof(j)*8-1));",
          "360: #ifdef BSWAP",
          "366: #else",
          "367:    for (i=0;i<5;i++) {",
          "373:    }",
          "374: #endif",
          "375:    len += SHA_DIGEST_LENGTH;",
          "376: #else",
          "377:    SHA1_Update(&key->md,out,inp_len);",
          "378:    res = key->md.num;",
          "381:    {",
          "382:    unsigned int inp_blocks, pad_blocks;",
          "",
          "[Removed Lines]",
          "354:    mac.u[0] |= key->md.h0 & mask;",
          "355:    mac.u[1] |= key->md.h1 & mask;",
          "356:    mac.u[2] |= key->md.h2 & mask;",
          "357:    mac.u[3] |= key->md.h3 & mask;",
          "358:    mac.u[4] |= key->md.h4 & mask;",
          "361:    mac.u[0] = BSWAP(mac.u[0]);",
          "362:    mac.u[1] = BSWAP(mac.u[1]);",
          "363:    mac.u[2] = BSWAP(mac.u[2]);",
          "364:    mac.u[3] = BSWAP(mac.u[3]);",
          "365:    mac.u[4] = BSWAP(mac.u[4]);",
          "368:     res = mac.u[i];",
          "369:     mac.c[4*i+0]=(unsigned char)(res>>24);",
          "370:     mac.c[4*i+1]=(unsigned char)(res>>16);",
          "371:     mac.c[4*i+2]=(unsigned char)(res>>8);",
          "372:     mac.c[4*i+3]=(unsigned char)res;",
          "379:    SHA1_Final(mac.c,&key->md);",
          "",
          "[Added Lines]",
          "361:    pmac->u[0] |= key->md.h0 & mask;",
          "362:    pmac->u[1] |= key->md.h1 & mask;",
          "363:    pmac->u[2] |= key->md.h2 & mask;",
          "364:    pmac->u[3] |= key->md.h3 & mask;",
          "365:    pmac->u[4] |= key->md.h4 & mask;",
          "368:    pmac->u[0] = BSWAP(pmac->u[0]);",
          "369:    pmac->u[1] = BSWAP(pmac->u[1]);",
          "370:    pmac->u[2] = BSWAP(pmac->u[2]);",
          "371:    pmac->u[3] = BSWAP(pmac->u[3]);",
          "372:    pmac->u[4] = BSWAP(pmac->u[4]);",
          "375:     res = pmac->u[i];",
          "376:     pmac->c[4*i+0]=(unsigned char)(res>>24);",
          "377:     pmac->c[4*i+1]=(unsigned char)(res>>16);",
          "378:     pmac->c[4*i+2]=(unsigned char)(res>>8);",
          "379:     pmac->c[4*i+3]=(unsigned char)res;",
          "386:    SHA1_Final(pmac->c,&key->md);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "392:    }",
          "393: #endif",
          "394:    key->md = key->tail;",
          "399:    out += inp_len;",
          "",
          "[Removed Lines]",
          "395:    SHA1_Update(&key->md,mac.c,SHA_DIGEST_LENGTH);",
          "396:    SHA1_Final(mac.c,&key->md);",
          "",
          "[Added Lines]",
          "402:    SHA1_Update(&key->md,pmac->c,SHA_DIGEST_LENGTH);",
          "403:    SHA1_Final(pmac->c,&key->md);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "410:     cmask = ((int)(j-off-SHA_DIGEST_LENGTH))>>(sizeof(int)*8-1);",
          "412:     cmask &= ((int)(off-1-j))>>(sizeof(int)*8-1);",
          "414:     i += 1&cmask;",
          "415:    }",
          "416:    maxpad -= SHA_DIGEST_LENGTH;",
          "",
          "[Removed Lines]",
          "413:     res |= (c^mac.c[i])&cmask;",
          "",
          "[Added Lines]",
          "420:     res |= (c^pmac->c[i])&cmask;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "420:    }",
          "421: #else",
          "422:    for (res=0,i=0;i<SHA_DIGEST_LENGTH;i++)",
          "424:    res = 0-((0-res)>>(sizeof(res)*8-1));",
          "425:    ret &= (int)~res;",
          "",
          "[Removed Lines]",
          "423:     res |= out[i]^mac.c[i];",
          "",
          "[Added Lines]",
          "430:     res |= out[i]^pmac->c[i];",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "a693ead6dc75455f7f5bbbd631b3a0e7ee457965",
      "candidate_info": {
        "commit_hash": "a693ead6dc75455f7f5bbbd631b3a0e7ee457965",
        "repo": "openssl/openssl",
        "commit_url": "https://github.com/openssl/openssl/commit/a693ead6dc75455f7f5bbbd631b3a0e7ee457965",
        "files": [
          "ssl/s3_cbc.c"
        ],
        "message": "Oops. Add missing file. (cherry picked from commit 014265eb02e26f35c8db58e2ccbf100b0b2f0072)",
        "before_after_code_files": [
          "ssl/s3_cbc.c||ssl/s3_cbc.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "ssl/s3_cbc.c||ssl/s3_cbc.c"
          ],
          "candidate": [
            "ssl/s3_cbc.c||ssl/s3_cbc.c"
          ]
        }
      },
      "candidate_diff": {
        "ssl/s3_cbc.c||ssl/s3_cbc.c": [
          "File: ssl/s3_cbc.c -> ssl/s3_cbc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "56: #include <stdint.h>",
          "58: #include \"ssl_locl.h\"",
          "60: #include <openssl/md5.h>",
          "61: #include <openssl/sha.h>",
          "65: #define MAX_HASH_BIT_COUNT_BYTES 16",
          "70: #define MAX_HASH_BLOCK_SIZE 128",
          "78: #define DUPLICATE_MSB_TO_ALL(x) ( (unsigned)( (int)(x) >> (sizeof(int)*8-1) ) )",
          "79: #define DUPLICATE_MSB_TO_ALL_8(x) ((unsigned char)(DUPLICATE_MSB_TO_ALL(x)))",
          "82: static unsigned constant_time_ge(unsigned a, unsigned b)",
          "83:  {",
          "84:  a -= b;",
          "85:  return DUPLICATE_MSB_TO_ALL(~a);",
          "86:  }",
          "89: static unsigned char constant_time_eq_8(unsigned char a, unsigned char b)",
          "90:  {",
          "91:  unsigned c = a ^ b;",
          "92:  c--;",
          "93:  return DUPLICATE_MSB_TO_ALL_8(c);",
          "94:  }",
          "104: int ssl3_cbc_remove_padding(const SSL* s,",
          "105:        SSL3_RECORD *rec,",
          "106:        unsigned block_size,",
          "107:        unsigned mac_size)",
          "108:  {",
          "109:  unsigned padding_length, good;",
          "110:  const unsigned overhead = 1 /* padding length byte */ + mac_size;",
          "114:  if (overhead > rec->length)",
          "115:   return 0;",
          "117:  padding_length = rec->data[rec->length-1];",
          "118:  good = constant_time_ge(rec->length, padding_length+overhead);",
          "120:  good &= constant_time_ge(block_size, padding_length+1);",
          "121:  rec->length -= good & (padding_length+1);",
          "122:  return (int)((good & 1) | (~good & -1));",
          "123: }",
          "136: int tls1_cbc_remove_padding(const SSL* s,",
          "137:        SSL3_RECORD *rec,",
          "138:        unsigned block_size,",
          "139:        unsigned mac_size)",
          "140:  {",
          "141:  unsigned padding_length, good, to_check, i;",
          "142:  const char has_explicit_iv =",
          "143:   s->version >= TLS1_1_VERSION || s->version == DTLS1_VERSION;",
          "144:  const unsigned overhead = 1 /* padding length byte */ +",
          "145:       mac_size +",
          "146:       (has_explicit_iv ? block_size : 0);",
          "150:  if (overhead > rec->length)",
          "151:   return 0;",
          "153:  padding_length = rec->data[rec->length-1];",
          "160:  if ( (s->options&SSL_OP_TLS_BLOCK_PADDING_BUG) && !s->expand)",
          "161:   {",
          "163:   if ((memcmp(s->s3->read_sequence, \"\\0\\0\\0\\0\\0\\0\\0\\0\",8) == 0) &&",
          "164:       !(padding_length & 1))",
          "165:    {",
          "166:    s->s3->flags|=TLS1_FLAGS_TLS_PADDING_BUG;",
          "167:    }",
          "168:   if ((s->s3->flags & TLS1_FLAGS_TLS_PADDING_BUG) &&",
          "169:       padding_length > 0)",
          "170:    {",
          "171:    padding_length--;",
          "172:    }",
          "173:   }",
          "175:  good = constant_time_ge(rec->length, overhead+padding_length);",
          "186:  if (to_check > rec->length-1)",
          "187:   to_check = rec->length-1;",
          "189:  for (i = 0; i < to_check; i++)",
          "190:   {",
          "191:   unsigned char mask = constant_time_ge(padding_length, i);",
          "192:   unsigned char b = rec->data[rec->length-1-i];",
          "195:   good &= ~(mask&(padding_length ^ b));",
          "196:   }",
          "202:  good &= good >> 4;",
          "203:  good &= good >> 2;",
          "204:  good &= good >> 1;",
          "205:  good <<= sizeof(good)*8-1;",
          "206:  good = DUPLICATE_MSB_TO_ALL(good);",
          "208:  rec->length -= good & (padding_length+1);",
          "218:  if (has_explicit_iv)",
          "219:   {",
          "220:   rec->data += block_size;",
          "221:   rec->input += block_size;",
          "222:   rec->length -= block_size;",
          "223:   rec->orig_len -= block_size;",
          "224:   }",
          "226:  return (int)((good & 1) | (~good & -1));",
          "227:  }",
          "229: #if defined(_M_AMD64) || defined(__x86_64__)",
          "230: #define CBC_MAC_ROTATE_IN_PLACE",
          "231: #endif",
          "249: void ssl3_cbc_copy_mac(unsigned char* out,",
          "250:          const SSL3_RECORD *rec,",
          "251:          unsigned md_size)",
          "252:  {",
          "253: #if defined(CBC_MAC_ROTATE_IN_PLACE)",
          "254:  unsigned char rotated_mac_buf[EVP_MAX_MD_SIZE*2];",
          "255:  unsigned char *rotated_mac;",
          "256: #else",
          "257:  unsigned char rotated_mac[EVP_MAX_MD_SIZE];",
          "258: #endif",
          "261:  unsigned mac_end = rec->length;",
          "262:  unsigned mac_start = mac_end - md_size;",
          "265:  unsigned scan_start = 0;",
          "266:  unsigned i, j;",
          "267:  unsigned div_spoiler;",
          "268:  unsigned rotate_offset;",
          "270:  OPENSSL_assert(rec->orig_len >= md_size);",
          "271:  OPENSSL_assert(md_size <= EVP_MAX_MD_SIZE);",
          "273: #if defined(CBC_MAC_ROTATE_IN_PLACE)",
          "274:  rotated_mac = (unsigned char*) (((intptr_t)(rotated_mac_buf + 64)) & ~63);",
          "275: #endif",
          "278:  if (rec->orig_len > md_size + 255 + 1)",
          "279:   scan_start = rec->orig_len - (md_size + 255 + 1);",
          "287:  div_spoiler = md_size >> 1;",
          "288:  div_spoiler <<= (sizeof(div_spoiler)-1)*8;",
          "289:  rotate_offset = (div_spoiler + mac_start - scan_start) % md_size;",
          "291:  memset(rotated_mac, 0, md_size);",
          "292:  for (i = scan_start; i < rec->orig_len;)",
          "293:   {",
          "294:   for (j = 0; j < md_size && i < rec->orig_len; i++, j++)",
          "295:    {",
          "296:    unsigned char mac_started = constant_time_ge(i, mac_start);",
          "297:    unsigned char mac_ended = constant_time_ge(i, mac_end);",
          "298:    unsigned char b = 0;",
          "299:    b = rec->data[i];",
          "300:    rotated_mac[j] |= b & mac_started & ~mac_ended;",
          "301:    }",
          "302:   }",
          "305: #if defined(CBC_MAC_ROTATE_IN_PLACE)",
          "306:  j = 0;",
          "307:  for (i = 0; i < md_size; i++)",
          "308:   {",
          "309:   unsigned char offset = (div_spoiler + rotate_offset + i) % md_size;",
          "310:   out[j++] = rotated_mac[offset];",
          "311:   }",
          "312: #else",
          "313:  memset(out, 0, md_size);",
          "314:  for (i = 0; i < md_size; i++)",
          "315:   {",
          "316:   unsigned char offset = (div_spoiler + md_size - rotate_offset + i) % md_size;",
          "317:   for (j = 0; j < md_size; j++)",
          "318:    out[j] |= rotated_mac[i] & constant_time_eq_8(j, offset);",
          "319:   }",
          "320: #endif",
          "321:  }",
          "326: static void tls1_md5_final_raw(void* ctx, unsigned char *md_out)",
          "327:  {",
          "328:  MD5_CTX *md5 = ctx;",
          "329:  l2n(md5->A, md_out);",
          "330:  l2n(md5->B, md_out);",
          "331:  l2n(md5->C, md_out);",
          "332:  l2n(md5->D, md_out);",
          "333:  }",
          "335: static void tls1_sha1_final_raw(void* ctx, unsigned char *md_out)",
          "336:  {",
          "337:  SHA_CTX *sha1 = ctx;",
          "338:  l2n(sha1->h0, md_out);",
          "339:  l2n(sha1->h1, md_out);",
          "340:  l2n(sha1->h2, md_out);",
          "341:  l2n(sha1->h3, md_out);",
          "342:  l2n(sha1->h4, md_out);",
          "343:  }",
          "345: static void tls1_sha256_final_raw(void* ctx, unsigned char *md_out)",
          "346:  {",
          "347:  SHA256_CTX *sha256 = ctx;",
          "348:  unsigned i;",
          "350:  for (i = 0; i < 8; i++)",
          "351:   {",
          "352:   l2n(sha256->h[i], md_out);",
          "353:   }",
          "354:  }",
          "356: static void tls1_sha512_final_raw(void* ctx, unsigned char *md_out)",
          "357:  {",
          "358:  SHA512_CTX *sha512 = ctx;",
          "359:  unsigned i;",
          "361:  for (i = 0; i < 8; i++)",
          "362:   {",
          "363:   l2n8(sha512->h[i], md_out);",
          "364:   }",
          "365:  }",
          "369: char ssl3_cbc_record_digest_supported(const EVP_MD_CTX *ctx)",
          "370:  {",
          "371:  switch (ctx->digest->type)",
          "372:   {",
          "373:   case NID_md5:",
          "374:   case NID_sha1:",
          "375:   case NID_sha224:",
          "376:   case NID_sha256:",
          "377:   case NID_sha384:",
          "378:   case NID_sha512:",
          "379:    return 1;",
          "380:   default:",
          "381:    return 0;",
          "382:   }",
          "383:  }",
          "404: void ssl3_cbc_digest_record(",
          "405:  const EVP_MD_CTX *ctx,",
          "406:  unsigned char* md_out,",
          "407:  size_t* md_out_size,",
          "408:  const unsigned char header[13],",
          "409:  const unsigned char *data,",
          "410:  size_t data_plus_mac_size,",
          "411:  size_t data_plus_mac_plus_padding_size,",
          "412:  const unsigned char *mac_secret,",
          "413:  unsigned mac_secret_length,",
          "414:  char is_sslv3)",
          "415:  {",
          "416:  unsigned char md_state[sizeof(SHA512_CTX)];",
          "417:  void (*md_final_raw)(void *ctx, unsigned char *md_out);",
          "418:  void (*md_transform)(void *ctx, const unsigned char *block);",
          "419:  unsigned md_size, md_block_size = 64;",
          "420:  unsigned sslv3_pad_length = 40, header_length, variance_blocks,",
          "421:    len, max_mac_bytes, num_blocks,",
          "422:    num_starting_blocks, k, mac_end_offset, c, index_a, index_b;",
          "423:  uint64_t bits;",
          "424:  unsigned char length_bytes[MAX_HASH_BIT_COUNT_BYTES];",
          "426:  unsigned char hmac_pad[MAX_HASH_BLOCK_SIZE];",
          "427:  unsigned char first_block[MAX_HASH_BLOCK_SIZE];",
          "428:  unsigned char mac_out[EVP_MAX_MD_SIZE];",
          "429:  unsigned i, j, md_out_size_u;",
          "430:  EVP_MD_CTX md_ctx;",
          "433:  unsigned md_length_size = 8;",
          "437:  OPENSSL_assert(data_plus_mac_plus_padding_size < 1024*1024);",
          "439:  switch (ctx->digest->type)",
          "440:   {",
          "441:   case NID_md5:",
          "442:    MD5_Init((MD5_CTX*)md_state);",
          "443:    md_final_raw = tls1_md5_final_raw;",
          "444:    md_transform = (void(*)(void *ctx, const unsigned char *block)) MD5_Transform;",
          "445:    md_size = 16;",
          "446:    sslv3_pad_length = 48;",
          "447:    break;",
          "448:   case NID_sha1:",
          "449:    SHA1_Init((SHA_CTX*)md_state);",
          "450:    md_final_raw = tls1_sha1_final_raw;",
          "451:    md_transform = (void(*)(void *ctx, const unsigned char *block)) SHA1_Transform;",
          "452:    md_size = 20;",
          "453:    break;",
          "454:   case NID_sha224:",
          "455:    SHA224_Init((SHA256_CTX*)md_state);",
          "456:    md_final_raw = tls1_sha256_final_raw;",
          "457:    md_transform = (void(*)(void *ctx, const unsigned char *block)) SHA256_Transform;",
          "458:    md_size = 224/8;",
          "459:    break;",
          "460:   case NID_sha256:",
          "461:    SHA256_Init((SHA256_CTX*)md_state);",
          "462:    md_final_raw = tls1_sha256_final_raw;",
          "463:    md_transform = (void(*)(void *ctx, const unsigned char *block)) SHA256_Transform;",
          "464:    md_size = 32;",
          "465:    break;",
          "466:   case NID_sha384:",
          "467:    SHA384_Init((SHA512_CTX*)md_state);",
          "468:    md_final_raw = tls1_sha512_final_raw;",
          "469:    md_transform = (void(*)(void *ctx, const unsigned char *block)) SHA512_Transform;",
          "470:    md_size = 384/8;",
          "471:    md_block_size = 128;",
          "472:    md_length_size = 16;",
          "473:    break;",
          "474:   case NID_sha512:",
          "475:    SHA512_Init((SHA512_CTX*)md_state);",
          "476:    md_final_raw = tls1_sha512_final_raw;",
          "477:    md_transform = (void(*)(void *ctx, const unsigned char *block)) SHA512_Transform;",
          "478:    md_size = 64;",
          "479:    md_block_size = 128;",
          "480:    md_length_size = 16;",
          "481:    break;",
          "482:   default:",
          "486:    OPENSSL_assert(0);",
          "487:    if (md_out_size)",
          "489:    return;",
          "490:   }",
          "492:  OPENSSL_assert(md_length_size <= MAX_HASH_BIT_COUNT_BYTES);",
          "493:  OPENSSL_assert(md_block_size <= MAX_HASH_BLOCK_SIZE);",
          "494:  OPENSSL_assert(md_size <= EVP_MAX_MD_SIZE);",
          "496:  header_length = 13;",
          "497:  if (is_sslv3)",
          "498:   {",
          "499:   header_length =",
          "500:    mac_secret_length +",
          "501:    sslv3_pad_length +",
          "502:    8 /* sequence number */ +",
          "503:    1 /* record type */ +",
          "504:    2 /* record length */;",
          "505:   }",
          "523:  variance_blocks = is_sslv3 ? 2 : 6;",
          "527:  len = data_plus_mac_plus_padding_size + header_length;",
          "530:  max_mac_bytes = len - md_size - 1;",
          "532:  num_blocks = (max_mac_bytes + 1 + md_length_size + md_block_size - 1) / md_block_size;",
          "539:  num_starting_blocks = 0;",
          "542:  k = 0;",
          "545:  mac_end_offset = data_plus_mac_size + header_length - md_size;",
          "548:  c = mac_end_offset % md_block_size;",
          "551:  index_a = mac_end_offset / md_block_size;",
          "554:  index_b = (mac_end_offset + md_length_size) / md_block_size;",
          "561:  if (num_blocks > variance_blocks + (is_sslv3 ? 1 : 0))",
          "562:   {",
          "563:   num_starting_blocks = num_blocks - variance_blocks;",
          "564:   k = md_block_size*num_starting_blocks;",
          "565:   }",
          "567:  bits = 8*mac_end_offset;",
          "568:  if (!is_sslv3)",
          "569:   {",
          "573:   bits += 8*md_block_size;",
          "574:   memset(hmac_pad, 0, md_block_size);",
          "575:   OPENSSL_assert(mac_secret_length <= sizeof(hmac_pad));",
          "576:   memcpy(hmac_pad, mac_secret, mac_secret_length);",
          "577:   for (i = 0; i < md_block_size; i++)",
          "578:    hmac_pad[i] ^= 0x36;",
          "580:   md_transform(md_state, hmac_pad);",
          "581:   }",
          "583:  j = 0;",
          "584:  if (md_length_size == 16)",
          "585:   {",
          "586:   memset(length_bytes, 0, 8);",
          "587:   j = 8;",
          "588:   }",
          "589:  for (i = 0; i < 8; i++)",
          "590:   length_bytes[i+j] = bits >> (8*(7-i));",
          "592:  if (k > 0)",
          "593:   {",
          "594:   if (is_sslv3)",
          "595:    {",
          "600:    unsigned overhang = header_length-md_block_size;",
          "601:    md_transform(md_state, header);",
          "602:    memcpy(first_block, header + md_block_size, overhang);",
          "603:    memcpy(first_block + overhang, data, md_block_size-overhang);",
          "604:    md_transform(md_state, first_block);",
          "605:    for (i = 1; i < k/md_block_size - 1; i++)",
          "606:     md_transform(md_state, data + md_block_size*i - overhang);",
          "607:    }",
          "608:   else",
          "609:    {",
          "611:    memcpy(first_block, header, 13);",
          "612:    memcpy(first_block+13, data, md_block_size-13);",
          "613:    md_transform(md_state, first_block);",
          "614:    for (i = 1; i < k/md_block_size; i++)",
          "615:     md_transform(md_state, data + md_block_size*i - 13);",
          "616:    }",
          "617:   }",
          "619:  memset(mac_out, 0, sizeof(mac_out));",
          "625:  for (i = num_starting_blocks; i <= num_starting_blocks+variance_blocks; i++)",
          "626:   {",
          "627:   unsigned char block[MAX_HASH_BLOCK_SIZE];",
          "628:   unsigned char is_block_a = constant_time_eq_8(i, index_a);",
          "629:   unsigned char is_block_b = constant_time_eq_8(i, index_b);",
          "630:   for (j = 0; j < md_block_size; j++)",
          "631:    {",
          "632:    unsigned char b = 0, is_past_c, is_past_cp1;",
          "633:    if (k < header_length)",
          "634:     b = header[k];",
          "635:    else if (k < data_plus_mac_plus_padding_size + header_length)",
          "636:     b = data[k-header_length];",
          "637:    k++;",
          "639:    is_past_c = is_block_a & constant_time_ge(j, c);",
          "640:    is_past_cp1 = is_block_a & constant_time_ge(j, c+1);",
          "644:    b = (b&~is_past_c) | (0x80&is_past_c);",
          "648:    b = b&~is_past_cp1;",
          "653:    b &= ~is_block_b | is_block_a;",
          "657:    if (j >= md_block_size - md_length_size)",
          "658:     {",
          "660:     b = (b&~is_block_b) | (is_block_b&length_bytes[j-(md_block_size-md_length_size)]);",
          "661:     }",
          "662:    block[j] = b;",
          "663:    }",
          "665:   md_transform(md_state, block);",
          "666:   md_final_raw(md_state, block);",
          "668:   for (j = 0; j < md_size; j++)",
          "669:    mac_out[j] |= block[j]&is_block_b;",
          "670:   }",
          "672:  EVP_MD_CTX_init(&md_ctx);",
          "673:  EVP_DigestInit_ex(&md_ctx, ctx->digest, NULL /* engine */);",
          "674:  if (is_sslv3)",
          "675:   {",
          "677:   memset(hmac_pad, 0x5c, sslv3_pad_length);",
          "679:   EVP_DigestUpdate(&md_ctx, mac_secret, mac_secret_length);",
          "680:   EVP_DigestUpdate(&md_ctx, hmac_pad, sslv3_pad_length);",
          "681:   EVP_DigestUpdate(&md_ctx, mac_out, md_size);",
          "682:   }",
          "683:  else",
          "684:   {",
          "686:   for (i = 0; i < md_block_size; i++)",
          "687:    hmac_pad[i] ^= 0x6a;",
          "689:   EVP_DigestUpdate(&md_ctx, hmac_pad, md_block_size);",
          "690:   EVP_DigestUpdate(&md_ctx, mac_out, md_size);",
          "691:   }",
          "692:  EVP_DigestFinal(&md_ctx, md_out, &md_out_size_u);",
          "693:  if (md_out_size)",
          "695:  EVP_MD_CTX_cleanup(&md_ctx);",
          "696:  }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "d980abb22e22661e98e5cee33d760ab0c7584ecc",
      "candidate_info": {
        "commit_hash": "d980abb22e22661e98e5cee33d760ab0c7584ecc",
        "repo": "openssl/openssl",
        "commit_url": "https://github.com/openssl/openssl/commit/d980abb22e22661e98e5cee33d760ab0c7584ecc",
        "files": [
          "ssl/s3_cbc.c"
        ],
        "message": "Check DTLS_BAD_VER for version number.\n\nThe version check for DTLS1_VERSION was redundant as\nDTLS1_VERSION > TLS1_1_VERSION, however we do need to\ncheck for DTLS1_BAD_VER for compatibility.\n\nPR:2984",
        "before_after_code_files": [
          "ssl/s3_cbc.c||ssl/s3_cbc.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "ssl/s3_cbc.c||ssl/s3_cbc.c"
          ],
          "candidate": [
            "ssl/s3_cbc.c||ssl/s3_cbc.c"
          ]
        }
      },
      "candidate_diff": {
        "ssl/s3_cbc.c||ssl/s3_cbc.c": [
          "File: ssl/s3_cbc.c -> ssl/s3_cbc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "146:  unsigned padding_length, good, to_check, i;",
          "147:  const unsigned overhead = 1 /* padding length byte */ + mac_size;",
          "150:   {",
          "",
          "[Removed Lines]",
          "149:  if (s->version >= TLS1_1_VERSION || s->version == DTLS1_VERSION)",
          "",
          "[Added Lines]",
          "149:  if (s->version >= TLS1_1_VERSION || s->version == DTLS1_BAD_VER)",
          "",
          "---------------"
        ]
      }
    }
  ]
}
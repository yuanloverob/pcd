{
  "cve_id": "CVE-2017-7854",
  "cve_desc": "The consume_init_expr function in wasm.c in radare2 1.3.0 allows remote attackers to cause a denial of service (heap-based buffer over-read and application crash) via a crafted Web Assembly file.",
  "repo": "radare/radare2",
  "patch_hash": "d2632f6483a3ceb5d8e0a5fb11142c51c43978b4",
  "patch_info": {
    "commit_hash": "d2632f6483a3ceb5d8e0a5fb11142c51c43978b4",
    "repo": "radare/radare2",
    "commit_url": "https://github.com/radare/radare2/commit/d2632f6483a3ceb5d8e0a5fb11142c51c43978b4",
    "files": [
      "libr/bin/format/wasm/wasm.c"
    ],
    "message": "Fix crash in fuzzed wasm r2_hoobr_consume_init_expr",
    "before_after_code_files": [
      "libr/bin/format/wasm/wasm.c||libr/bin/format/wasm/wasm.c"
    ]
  },
  "patch_diff": {
    "libr/bin/format/wasm/wasm.c||libr/bin/format/wasm/wasm.c": [
      "File: libr/bin/format/wasm/wasm.c -> libr/bin/format/wasm/wasm.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "67:  if (offset) *offset += sz;",
      "68:  return sz;",
      "69: }",
      "70: static size_t consume_init_expr (ut8 *buf, ut8 *max, ut8 eoc, void *out, ut32 *offset) {",
      "71:  ut32 i = 0;",
      "72:  while (buf + i < max && buf[i] != eoc) {",
      "75:  }",
      "76:  if (buf[i] != eoc) {",
      "77:   return 0;",
      "",
      "[Removed Lines]",
      "74:   i += 1;",
      "",
      "[Added Lines]",
      "75:   i++;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "448: }",
      "450: static RList *r_bin_wasm_get_data_entries (RBinWasmObj *bin, RBinWasmSection *sec) {",
      "452:  RList *ret = NULL;",
      "453:  RBinWasmDataEntry *ptr = NULL;",
      "455:  if (!(ret = r_list_newf ((RListFree)free))) {",
      "456:   return NULL;",
      "457:  }",
      "459:  ut8* buf = bin->buf->buf + (ut32)sec->payload_data;",
      "461:  ut32 count = sec->count;",
      "462:  ut32 i = 0, r = 0;",
      "463:  size_t n = 0;",
      "467:   if (!(ptr = R_NEW0 (RBinWasmDataEntry))) {",
      "468:    return ret;",
      "469:   }",
      "471:   if (!(consume_u32 (buf + i, buf + len, &ptr->index, &i))) {",
      "474:   }",
      "476:   if (!(n = consume_init_expr (buf + i, buf + len, R_BIN_WASM_END_OF_CODE, NULL, &i))) {",
      "479:   }",
      "481:   ptr->offset.len = n;",
      "483:   if (!(consume_u32 (buf + i, buf + len, &ptr->size, &i))) {",
      "486:   }",
      "488:   ptr->data = sec->payload_data + i;",
      "490:   r_list_append (ret, ptr);",
      "",
      "[Removed Lines]",
      "460:  ut32 len =  sec->payload_len;",
      "465:  while (i < len && r < count) {",
      "472:    free (ptr);",
      "473:    return ret;",
      "477:    free (ptr);",
      "478:    return ret;",
      "484:    free (ptr);",
      "485:    return ret;",
      "",
      "[Added Lines]",
      "454:  ut32 len =  sec->payload_len;",
      "461:  int buflen = bin->buf->length - (ut32)sec->payload_data;",
      "466:  while (i < len && len < buflen && r < count) {",
      "471:    goto beach;",
      "472:   }",
      "473:   if (i + 4 >= buflen) {",
      "474:    goto beach;",
      "477:    goto beach;",
      "481:    goto beach;",
      "482:   }",
      "483:   if (i + 4 >= buflen) {",
      "484:    goto beach;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "492:   r += 1;",
      "494:  }",
      "496:  return ret;",
      "497: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "493:  return ret;",
      "494: beach:",
      "495:  free (ptr);",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "593: static RList *r_bin_wasm_get_global_entries (RBinWasmObj *bin, RBinWasmSection *sec) {",
      "594:  RList *ret = NULL;",
      "595:  RBinWasmGlobalEntry *ptr = NULL;",
      "601:  if (!(ret = r_list_newf ((RListFree)free))) {",
      "602:   return NULL;",
      "603:  }",
      "605:  ut8* buf = bin->buf->buf + (ut32)sec->payload_data;",
      "606:  ut32 len =  sec->payload_len;",
      "607:  ut32 count = sec->count;",
      "608:  ut32 i = 0, r = 0;",
      "",
      "[Removed Lines]",
      "596:  int buflen = bin->buf->length;",
      "597:  if (sec->payload_data + 32 > buflen) {",
      "598:   return NULL;",
      "599:  }",
      "",
      "[Added Lines]",
      "602:  int buflen = bin->buf->length - (ut32)sec->payload_data;",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "640:  }",
      "642:  ut8* buf = bin->buf->buf + (ut32)sec->payload_data;",
      "643:  ut32 len =  sec->payload_len;",
      "644:  ut32 count = sec->count;",
      "645:  ut32 i = 0, r = 0;",
      "649:   if (!(ptr = R_NEW0 (RBinWasmElementEntry))) {",
      "650:    return ret;",
      "651:   }",
      "653:   if (!(consume_u32 (buf + i, buf + len, &ptr->index, &i))) {",
      "656:   }",
      "658:   if (!(consume_init_expr (buf + i, buf + len, R_BIN_WASM_END_OF_CODE, NULL, &i))) {",
      "661:   }",
      "663:   if (!(consume_u32 (buf + i, buf + len, &ptr->num_elem, &i))) {",
      "666:   }",
      "668:   ut32 j = 0;",
      "671:    ut32 e;",
      "672:    if (!(consume_u32 (buf + i, buf + len, &e, &i))) {",
      "",
      "[Removed Lines]",
      "647:  while (i < len && r < count) {",
      "654:    free (ptr);",
      "655:    return ret;",
      "659:    free (ptr);",
      "660:    return ret;",
      "664:    free (ptr);",
      "665:    return ret;",
      "669:   while (i < len && j < ptr->num_elem ) {",
      "",
      "[Added Lines]",
      "639:  int buflen = bin->buf->length - (ut32)sec->payload_data;",
      "644:  while (i < len && len < buflen && r < count) {",
      "649:    goto beach;",
      "652:    goto beach;",
      "655:    goto beach;",
      "658:   while (i < len && j < ptr->num_elem) {",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "674:     return ret;",
      "675:    }",
      "676:   }",
      "678:   r_list_append (ret, ptr);",
      "680:   r += 1;",
      "682:  }",
      "684:  return ret;",
      "685: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "670:  return ret;",
      "671: beach:",
      "672:  free (ptr);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "40a33b3a267c769018c9e9c7ab40106aec783657",
      "candidate_info": {
        "commit_hash": "40a33b3a267c769018c9e9c7ab40106aec783657",
        "repo": "radare/radare2",
        "commit_url": "https://github.com/radare/radare2/commit/40a33b3a267c769018c9e9c7ab40106aec783657",
        "files": [
          "libr/asm/p/asm_wasm.c",
          "libr/bin/format/wasm/wasm.c",
          "libr/bin/format/wasm/wasm.h",
          "libr/bin/p/bin_wasm.c",
          "libr/util/uleb128.c"
        ],
        "message": "Rewrite WASM to fix all oob issues",
        "before_after_code_files": [
          "libr/asm/p/asm_wasm.c||libr/asm/p/asm_wasm.c",
          "libr/bin/format/wasm/wasm.c||libr/bin/format/wasm/wasm.c",
          "libr/bin/format/wasm/wasm.h||libr/bin/format/wasm/wasm.h",
          "libr/bin/p/bin_wasm.c||libr/bin/p/bin_wasm.c",
          "libr/util/uleb128.c||libr/util/uleb128.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libr/bin/format/wasm/wasm.c||libr/bin/format/wasm/wasm.c"
          ],
          "candidate": [
            "libr/bin/format/wasm/wasm.c||libr/bin/format/wasm/wasm.c"
          ]
        }
      },
      "candidate_diff": {
        "libr/asm/p/asm_wasm.c||libr/asm/p/asm_wasm.c": [
          "File: libr/asm/p/asm_wasm.c -> libr/asm/p/asm_wasm.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "8: #include <r_lib.h>",
          "9: #include <r_asm.h>",
          "11: static int disassemble(RAsm *a, RAsmOp *op, const ut8 *buf, int len) {",
          "12:  int rep = 1;",
          "17:  case 0x00:",
          "22:  case 0x01:",
          "44:  case 0x05:",
          "49:  case 0x0b:",
          "84:  case 0x0f:",
          "115:  case 0x1a:",
          "120:  case 0x1b:",
          "494:  case 0x45:",
          "498:  case 0x46:",
          "502:  case 0x47:",
          "506:  case 0x48:",
          "510:  case 0x49:",
          "514:  case 0x4a:",
          "518:  case 0x4b:",
          "522:  case 0x4c:",
          "526:  case 0x4d:",
          "530:  case 0x4e:",
          "534:  case 0x4f:",
          "538:  case 0x50:",
          "542:  case 0x51:",
          "546:  case 0x52:",
          "550:  case 0x53:",
          "554:  case 0x54:",
          "558:  case 0x55:",
          "562:  case 0x56:",
          "566:  case 0x57:",
          "570:  case 0x58:",
          "574:  case 0x59:",
          "578:  case 0x5a:",
          "582:  case 0x5b:",
          "586:  case 0x5c:",
          "590:  case 0x5d:",
          "594:  case 0x5e:",
          "598:  case 0x5f:",
          "602:  case 0x60:",
          "606:  case 0x61:",
          "610:  case 0x62:",
          "614:  case 0x63:",
          "618:  case 0x64:",
          "622:  case 0x65:",
          "626:  case 0x66:",
          "633:  case 0x67:",
          "637:  case 0x68:",
          "641:  case 0x69:",
          "645:  case 0x6a:",
          "649:  case 0x6b:",
          "653:  case 0x6c:",
          "657:  case 0x6d:",
          "661:  case 0x6e:",
          "665:  case 0x6f:",
          "669:  case 0x70:",
          "673:  case 0x71:",
          "677:  case 0x72:",
          "681:  case 0x73:",
          "685:  case 0x74:",
          "689:  case 0x75:",
          "693:  case 0x76:",
          "697:  case 0x77:",
          "701:  case 0x78:",
          "705:  case 0x79:",
          "709:  case 0x7a:",
          "713:  case 0x7b:",
          "717:  case 0x7c:",
          "721:  case 0x7d:",
          "725:  case 0x7e:",
          "729:  case 0x7f:",
          "733:  case 0x80:",
          "737:  case 0x81:",
          "741:  case 0x82:",
          "745:  case 0x83:",
          "749:  case 0x84:",
          "753:  case 0x85:",
          "757:  case 0x86:",
          "761:  case 0x87:",
          "765:  case 0x88:",
          "769:  case 0x89:",
          "773:  case 0x8a:",
          "777:  case 0x8b:",
          "781:  case 0x8c:",
          "785:  case 0x8d:",
          "789:  case 0x8e:",
          "793:  case 0x8f:",
          "797:  case 0x90:",
          "801:  case 0x91:",
          "805:  case 0x92:",
          "809:  case 0x93:",
          "813:  case 0x94:",
          "817:  case 0x95:",
          "821:  case 0x96:",
          "825:  case 0x97:",
          "829:  case 0x98:",
          "833:  case 0x99:",
          "837:  case 0x9a:",
          "841:  case 0x9b:",
          "845:  case 0x9c:",
          "849:  case 0x9d:",
          "853:  case 0x9e:",
          "857:  case 0x9f:",
          "861:  case 0xa0:",
          "865:  case 0xa1:",
          "869:  case 0xa2:",
          "873:  case 0xa3:",
          "877:  case 0xa4:",
          "881:  case 0xa5:",
          "885:  case 0xa6:",
          "892:  case 0xa7:",
          "896:  case 0xa8:",
          "900:  case 0xa9:",
          "904:  case 0xaa:",
          "908:  case 0xab:",
          "912:  case 0xac:",
          "916:  case 0xad:",
          "920:  case 0xae:",
          "924:  case 0xaf:",
          "928:  case 0xb0:",
          "932:  case 0xb1:",
          "936:  case 0xb2:",
          "940:  case 0xb3:",
          "944:  case 0xb4:",
          "948:  case 0xb5:",
          "952:  case 0xb6:",
          "956:  case 0xb7:",
          "960:  case 0xb8:",
          "964:  case 0xb9:",
          "968:  case 0xba:",
          "972:  case 0xbb:",
          "979:  case 0xbc:",
          "983:  case 0xbd:",
          "987:  case 0xbe:",
          "991:  case 0xbf:",
          "994:   break;",
          "998:  default:",
          "999:   break;",
          "1001:  }",
          "1003:  op->size = rep;",
          "1004:  return rep;",
          "1005: }",
          "",
          "[Removed Lines]",
          "14:  switch (buf[0]) {",
          "20:   sprintf (op->buf_asm, \"trap\");",
          "21:   break;",
          "25:   sprintf (op->buf_asm, \"nop\");",
          "26:   break;",
          "27:  case 0x02:",
          "30:   sprintf (op->buf_asm, \"block\");",
          "31:   rep = 2;",
          "32:   break;",
          "33:  case 0x03:",
          "36:   sprintf (op->buf_asm, \"loop %d\", buf[1]);",
          "37:   rep = 2;",
          "38:   break;",
          "39:  case 0x04:",
          "42:   sprintf (op->buf_asm, \"if\");",
          "43:   break;",
          "47:   sprintf (op->buf_asm, \"else\");",
          "48:   break;",
          "52:   sprintf (op->buf_asm, \"end\");",
          "53:   break;",
          "54:  case 0x0c:",
          "57:   {",
          "58:    ut32 val = 0;",
          "59:    size_t n = read_u32_leb128 (buf + 1, buf + len, &val);",
          "60:    sprintf (op->buf_asm, \"br 0x%04x\", val);",
          "61:    rep += n;",
          "62:   }",
          "63:   break;",
          "64:  case 0x0d:",
          "67:   {",
          "68:    ut32 val = 0;",
          "69:    size_t n = read_u32_leb128 (buf + 1, buf + len, &val);",
          "70:    sprintf (op->buf_asm, \"br_if 0x%04x\", val);",
          "71:    rep += n;",
          "72:   }",
          "73:   break;",
          "74:  case 0x0e:",
          "77:   {",
          "78:    ut32 val = 0;",
          "79:    size_t n = read_u32_leb128 (buf + 1, buf + len, &val);",
          "80:    sprintf (op->buf_asm, \"br_table 0x%04x\", val);",
          "81:    rep += n;",
          "82:   }",
          "83:   break;",
          "87:   sprintf (op->buf_asm, \"return\");",
          "88:   break;",
          "92:  case 0x10:",
          "95:   {",
          "96:    ut32 val = 0;",
          "97:    size_t n = read_u32_leb128 (buf + 1, buf + len, &val);",
          "98:    sprintf (op->buf_asm, \"call 0x%04x\", val);",
          "99:    rep += n;",
          "100:   }",
          "101:   break;",
          "102:  case 0x11:",
          "105:   {",
          "106:    ut32 val = 0;",
          "107:    size_t n = read_u32_leb128 (buf + 1, buf + len, &val);",
          "108:    sprintf (op->buf_asm, \"call_indirect 0x%04x\", val);",
          "109:    rep += n;",
          "110:   }",
          "111:   break;",
          "118:   sprintf (op->buf_asm, \"drop\");",
          "119:   break;",
          "123:   sprintf (op->buf_asm, \"select\");",
          "124:   break;",
          "128:  case 0x20:",
          "131:   {",
          "132:    ut32 val = 0;",
          "133:    size_t n = read_u32_leb128 (buf + 1, buf + len, &val);",
          "134:    sprintf (op->buf_asm, \"get_local 0x%04x\", val);",
          "135:    rep += n;",
          "136:   }",
          "137:   break;",
          "138:  case 0x21:",
          "141:   {",
          "142:    ut32 val = 0;",
          "143:    size_t n = read_u32_leb128 (buf + 1, buf + len, &val);",
          "144:    sprintf (op->buf_asm, \"set_local 0x%04x\", val);",
          "145:    rep += n;",
          "146:   }",
          "147:   break;",
          "148:  case 0x22:",
          "151:   {",
          "152:    ut32 val = 0;",
          "153:    size_t n = read_u32_leb128 (buf + 1, buf + len, &val);",
          "154:    sprintf (op->buf_asm, \"tee_local 0x%04x\", val);",
          "155:    rep += n;",
          "156:   }",
          "157:   break;",
          "158:  case 0x23:",
          "161:   {",
          "162:    ut32 val = 0;",
          "163:    size_t n = read_u32_leb128 (buf + 1, buf + len, &val);",
          "164:    sprintf (op->buf_asm, \"get_global 0x%04x\", val);",
          "165:    rep += n;",
          "166:   }",
          "167:   break;",
          "168:  case 0x24:",
          "171:   {",
          "172:    ut32 val = 0;",
          "173:    size_t n = read_u32_leb128 (buf + 1, buf + len, &val);",
          "174:    sprintf (op->buf_asm, \"set_global 0x%04x\", val);",
          "175:    rep += n;",
          "176:   }",
          "177:   break;",
          "181:  case 0x28:",
          "184:   {",
          "185:    ut32 flag = 0, offset = 0;",
          "186:    size_t n = read_u32_leb128 (buf + 1, buf + len, &flag);",
          "187:    size_t m = read_u32_leb128 (buf + 1 + n, buf + len, &offset);",
          "188:    sprintf (op->buf_asm, \"i32.load 0x%04x 0x%04x\", flag, offset);",
          "189:    rep += n + m;",
          "190:   }",
          "191:   break;",
          "192:  case 0x29:",
          "195:   {",
          "196:    ut32 flag = 0, offset = 0;",
          "197:    size_t n = read_u32_leb128 (buf + 1, buf + len, &flag);",
          "198:    size_t m = read_u32_leb128 (buf + 1 + n, buf + len, &offset);",
          "199:    sprintf (op->buf_asm, \"i64.load 0x%04x 0x%04x\", flag, offset);",
          "200:    rep += n + m;",
          "201:   }",
          "202:   break;",
          "203:  case 0x2a:",
          "206:   {",
          "207:    ut32 flag = 0, offset = 0;",
          "208:    size_t n = read_u32_leb128 (buf + 1, buf + len, &flag);",
          "209:    size_t m = read_u32_leb128 (buf + 1 + n, buf + len, &offset);",
          "210:    sprintf (op->buf_asm, \"f32.load 0x%04x 0x%04x\", flag, offset);",
          "211:    rep += n + m;",
          "212:   }",
          "213:   break;",
          "214:  case 0x2b:",
          "217:   {",
          "218:    ut32 flag = 0, offset = 0;",
          "219:    size_t n = read_u32_leb128 (buf + 1, buf + len, &flag);",
          "220:    size_t m = read_u32_leb128 (buf + 1 + n, buf + len, &offset);",
          "221:    sprintf (op->buf_asm, \"f64.load 0x%04x 0x%04x\", flag, offset);",
          "222:    rep += n + m;",
          "223:   }",
          "224:   break;",
          "225:  case 0x2c:",
          "228:   {",
          "229:    ut32 flag = 0, offset = 0;",
          "230:    size_t n = read_u32_leb128 (buf + 1, buf + len, &flag);",
          "231:    size_t m = read_u32_leb128 (buf + 1 + n, buf + len, &offset);",
          "232:    sprintf (op->buf_asm, \"i32.load8_s 0x%04x 0x%04x\", flag, offset);",
          "233:    rep += n + m;",
          "234:   }",
          "235:   break;",
          "236:  case 0x2d:",
          "239:   {",
          "240:    ut32 flag = 0, offset = 0;",
          "241:    size_t n = read_u32_leb128 (buf + 1, buf + len, &flag);",
          "242:    size_t m = read_u32_leb128 (buf + 1 + n, buf + len, &offset);",
          "243:    sprintf (op->buf_asm, \"i32.load8_u 0x%04x 0x%04x\", flag, offset);",
          "244:    rep += n + m;",
          "245:   }",
          "246:   break;",
          "247:  case 0x2e:",
          "250:   {",
          "251:    ut32 flag = 0, offset = 0;",
          "252:    size_t n = read_u32_leb128 (buf + 1, buf + len, &flag);",
          "253:    size_t m = read_u32_leb128 (buf + 1 + n, buf + len, &offset);",
          "254:    sprintf (op->buf_asm, \"i32.load16_s 0x%04x 0x%04x\", flag, offset);",
          "255:    rep += n + m;",
          "256:   }",
          "257:   break;",
          "258:  case 0x2f:",
          "261:   {",
          "262:    ut32 flag = 0, offset = 0;",
          "263:    size_t n = read_u32_leb128 (buf + 1, buf + len, &flag);",
          "264:    size_t m = read_u32_leb128 (buf + 1 + n, buf + len, &offset);",
          "265:    sprintf (op->buf_asm, \"i64.load16_u 0x%04x 0x%04x\", flag, offset);",
          "266:    rep += n + m;",
          "267:   }",
          "268:   break;",
          "269:  case 0x30:",
          "272:   {",
          "273:    ut32 flag = 0, offset = 0;",
          "274:    size_t n = read_u32_leb128 (buf + 1, buf + len, &flag);",
          "275:    size_t m = read_u32_leb128 (buf + 1 + n, buf + len, &offset);",
          "276:    sprintf (op->buf_asm, \"i64.load8_s 0x%04x 0x%04x\", flag, offset);",
          "277:    rep += n + m;",
          "278:   }",
          "279:   break;",
          "280:  case 0x31:",
          "283:   {",
          "284:    ut32 flag = 0, offset = 0;",
          "285:    size_t n = read_u32_leb128 (buf + 1, buf + len, &flag);",
          "286:    size_t m = read_u32_leb128 (buf + 1 + n, buf + len, &offset);",
          "287:    sprintf (op->buf_asm, \"i64.load8_u 0x%04x 0x%04x\", flag, offset);",
          "288:    rep += n + m;",
          "289:   }",
          "290:   break;",
          "291:  case 0x32:",
          "294:   {",
          "295:    ut32 flag = 0, offset = 0;",
          "296:    size_t n = read_u32_leb128 (buf + 1, buf + len, &flag);",
          "297:    size_t m = read_u32_leb128 (buf + 1 + n, buf + len, &offset);",
          "298:    sprintf (op->buf_asm, \"i64.load16_s 0x%04x 0x%04x\", flag, offset);",
          "299:    rep += n + m;",
          "300:   }",
          "301:   break;",
          "302:  case 0x33:",
          "305:   {",
          "306:    ut32 flag = 0, offset = 0;",
          "307:    size_t n = read_u32_leb128 (buf + 1, buf + len, &flag);",
          "308:    size_t m = read_u32_leb128 (buf + 1 + n, buf + len, &offset);",
          "309:    sprintf (op->buf_asm, \"i64.load16_u 0x%04x 0x%04x\", flag, offset);",
          "310:    rep += n + m;",
          "311:   }",
          "312:   break;",
          "313:  case 0x34:",
          "316:   {",
          "317:    ut32 flag = 0, offset = 0;",
          "318:    size_t n = read_u32_leb128 (buf + 1, buf + len, &flag);",
          "319:    size_t m = read_u32_leb128 (buf + 1 + n, buf + len, &offset);",
          "320:    sprintf (op->buf_asm, \"i64.load32_s 0x%04x 0x%04x\", flag, offset);",
          "321:    rep += n + m;",
          "322:   }",
          "323:   break;",
          "324:  case 0x35:",
          "327:   {",
          "328:    ut32 flag = 0, offset = 0;",
          "329:    size_t n = read_u32_leb128 (buf + 1, buf + len, &flag);",
          "330:    size_t m = read_u32_leb128 (buf + 1 + n, buf + len, &offset);",
          "331:    sprintf (op->buf_asm, \"i64.load32_u 0x%04x 0x%04x\", flag, offset);",
          "332:    rep += n + m;",
          "333:   }",
          "334:   break;",
          "335:  case 0x36:",
          "338:   {",
          "339:    ut32 flag = 0, offset = 0;",
          "340:    size_t n = read_u32_leb128 (buf + 1, buf + len, &flag);",
          "341:    size_t m = read_u32_leb128 (buf + 1 + n, buf + len, &offset);",
          "342:    sprintf (op->buf_asm, \"i32.store 0x%04x 0x%04x\", flag, offset);",
          "343:    rep += n + m;",
          "344:   }",
          "345:   break;",
          "346:  case 0x37:",
          "349:   {",
          "350:    ut32 flag = 0, offset = 0;",
          "351:    size_t n = read_u32_leb128 (buf + 1, buf + len, &flag);",
          "352:    size_t m = read_u32_leb128 (buf + 1 + n, buf + len, &offset);",
          "353:    sprintf (op->buf_asm, \"i64.store 0x%04x 0x%04x\", flag, offset);",
          "354:    rep += n + m;",
          "355:   }",
          "356:   break;",
          "357:  case 0x38:",
          "360:   {",
          "361:    ut32 flag = 0, offset = 0;",
          "362:    size_t n = read_u32_leb128 (buf + 1, buf + len, &flag);",
          "363:    size_t m = read_u32_leb128 (buf + 1 + n, buf + len, &offset);",
          "364:    sprintf (op->buf_asm, \"f64.store 0x%04x 0x%04x\", flag, offset);",
          "365:    rep += n + m;",
          "366:   }",
          "367:   break;",
          "368:  case 0x39:",
          "371:   {",
          "372:    ut32 flag = 0, offset = 0;",
          "373:    size_t n = read_u32_leb128 (buf + 1, buf + len, &flag);",
          "374:    size_t m = read_u32_leb128 (buf + 1 + n, buf + len, &offset);",
          "375:    sprintf (op->buf_asm, \"f64.store 0x%04x 0x%04x\", flag, offset);",
          "376:    rep += n + m;",
          "377:   }",
          "378:   break;",
          "379:  case 0x3a:",
          "382:   {",
          "383:    ut32 flag = 0, offset = 0;",
          "384:    size_t n = read_u32_leb128 (buf + 1, buf + len, &flag);",
          "385:    size_t m = read_u32_leb128 (buf + 1 + n, buf + len, &offset);",
          "386:    sprintf (op->buf_asm, \"i32.store8 0x%04x 0x%04x\", flag, offset);",
          "387:    rep += n + m;",
          "388:   }",
          "389:   break;",
          "390:  case 0x3b:",
          "393:   {",
          "394:    ut32 flag = 0, offset = 0;",
          "395:    size_t n = read_u32_leb128 (buf + 1, buf + len, &flag);",
          "396:    size_t m = read_u32_leb128 (buf + 1 + n, buf + len, &offset);",
          "397:    sprintf (op->buf_asm, \"i32.store16 0x%04x 0x%04x\", flag, offset);",
          "398:    rep += n + m;",
          "399:   }",
          "400:   break;",
          "401:  case 0x3c:",
          "404:   {",
          "405:    ut32 flag = 0, offset = 0;",
          "406:    size_t n = read_u32_leb128 (buf + 1, buf + len, &flag);",
          "407:    size_t m = read_u32_leb128 (buf + 1 + n, buf + len, &offset);",
          "408:    sprintf (op->buf_asm, \"i64.store8 0x%04x 0x%04x\", flag, offset);",
          "409:    rep += n + m;",
          "410:   }",
          "411:   break;",
          "412:  case 0x3d:",
          "415:   {",
          "416:    ut32 flag = 0, offset = 0;",
          "417:    size_t n = read_u32_leb128 (buf + 1, buf + len, &flag);",
          "418:    size_t m = read_u32_leb128 (buf + 1 + n, buf + len, &offset);",
          "419:    sprintf (op->buf_asm, \"i64.store16 0x%04x 0x%04x\", flag, offset);",
          "420:    rep += n + m;",
          "421:   }",
          "422:   break;",
          "423:  case 0x3e:",
          "426:   {",
          "427:    ut32 flag = 0, offset = 0;",
          "428:    size_t n = read_u32_leb128 (buf + 1, buf + len, &flag);",
          "429:    size_t m = read_u32_leb128 (buf + 1 + n, buf + len, &offset);",
          "430:    sprintf (op->buf_asm, \"i64.store32 0x%04x 0x%04x\", flag, offset);",
          "431:    rep += n + m;",
          "432:   }",
          "433:   break;",
          "434:  case 0x3f:",
          "437:   sprintf (op->buf_asm, \"current_memory\");",
          "438:   break;",
          "439:  case 0x40:",
          "442:   sprintf (op->buf_asm, \"grow_memory\");",
          "443:   break;",
          "447:  case 0x41:",
          "450:   {",
          "451:    st32 val = 0;",
          "452:    size_t n = read_i32_leb128 (buf + 1, buf + len, &val);",
          "453:    sprintf (op->buf_asm, \"i32.const 0x%04x\", val);",
          "454:    rep += n;",
          "455:   }",
          "456:   break;",
          "457:  case 0x42:",
          "460:   {",
          "461:    st64 val = 0;",
          "462:    size_t n = read_i64_leb128 (buf + 1, buf + len, &val);",
          "463:    if (val < 1) {",
          "464:     sprintf (op->buf_asm, \"i64.const %\" PFMT64d, val);",
          "465:    } else {",
          "466:     sprintf (op->buf_asm, \"i64.const 0x%08\" PFMT64x, val);",
          "467:    }",
          "468:    rep += n;",
          "469:   }",
          "470:   break;",
          "471:  case 0x43:",
          "474:   {",
          "475:    ut32 val = 0;",
          "476:    size_t n = read_u32_leb128 (buf + 1, buf + len, &val);",
          "477:    sprintf (op->buf_asm, \"f32.const 0x%04\"PFMT32x, val);",
          "478:    rep += n;",
          "479:   }",
          "480:   break;",
          "481:  case 0x44:",
          "484:   {",
          "485:    ut64 val = 0;",
          "486:    size_t n = read_u64_leb128 (buf + 1, buf + len, &val);",
          "487:    sprintf (op->buf_asm, \"f64.const 0x%08\"PFMT64x, val);",
          "488:    rep += n;",
          "489:   }",
          "490:   break;",
          "496:   sprintf (op->buf_asm, \"i32.eqz\");",
          "497:   break;",
          "500:   sprintf (op->buf_asm, \"i32.eq\");",
          "501:   break;",
          "504:   sprintf (op->buf_asm, \"i32.ne\");",
          "505:   break;",
          "508:   sprintf (op->buf_asm, \"i32.lt_s\");",
          "509:   break;",
          "512:   sprintf (op->buf_asm, \"i32.lt_u\");",
          "513:   break;",
          "516:   sprintf (op->buf_asm, \"i32.gt_s\");",
          "517:   break;",
          "520:   sprintf (op->buf_asm, \"i32.gt_u\");",
          "521:   break;",
          "524:   sprintf (op->buf_asm, \"i32.le_s\");",
          "525:   break;",
          "528:   sprintf (op->buf_asm, \"i32.le_u\");",
          "529:   break;",
          "532:   sprintf (op->buf_asm, \"i32.ge_s\");",
          "533:   break;",
          "536:   sprintf (op->buf_asm, \"i32.ge_u\");",
          "537:   break;",
          "540:   sprintf (op->buf_asm, \"i64.eqz\");",
          "541:   break;",
          "544:   sprintf (op->buf_asm, \"i64.eq\");",
          "545:   break;",
          "548:   sprintf (op->buf_asm, \"i64.ne\");",
          "549:   break;",
          "552:   sprintf (op->buf_asm, \"i64.lt_s\");",
          "553:   break;",
          "556:   sprintf (op->buf_asm, \"i64.lt_u\");",
          "557:   break;",
          "560:   sprintf (op->buf_asm, \"i64.gt_s\");",
          "561:   break;",
          "564:   sprintf (op->buf_asm, \"i64.gt_u\");",
          "565:   break;",
          "568:   sprintf (op->buf_asm, \"i64.le_s\");",
          "569:   break;",
          "572:   sprintf (op->buf_asm, \"i64.le_u\");",
          "573:   break;",
          "576:   sprintf (op->buf_asm, \"i64.ge_s\");",
          "577:   break;",
          "580:   sprintf (op->buf_asm, \"i64.ge_u\");",
          "581:   break;",
          "584:   sprintf (op->buf_asm, \"f32.eq\");",
          "585:   break;",
          "588:   sprintf (op->buf_asm, \"f32.ne\");",
          "589:   break;",
          "592:   sprintf (op->buf_asm, \"f32.lt\");",
          "593:   break;",
          "596:   sprintf (op->buf_asm, \"f32.gt\");",
          "597:   break;",
          "600:   sprintf (op->buf_asm, \"f32.le\");",
          "601:   break;",
          "604:   sprintf (op->buf_asm, \"f32.ge\");",
          "605:   break;",
          "608:   sprintf (op->buf_asm, \"f64.eq\");",
          "609:   break;",
          "612:   sprintf (op->buf_asm, \"f64.ne\");",
          "613:   break;",
          "616:   sprintf (op->buf_asm, \"f64.lt\");",
          "617:   break;",
          "620:   sprintf (op->buf_asm, \"f64.gt\");",
          "621:   break;",
          "624:   sprintf (op->buf_asm, \"f64.le\");",
          "625:   break;",
          "628:   sprintf (op->buf_asm, \"f64.ge\");",
          "629:   break;",
          "635:   sprintf (op->buf_asm, \"i32.clz\");",
          "636:   break;",
          "639:   sprintf (op->buf_asm, \"i32.ctz\");",
          "640:   break;",
          "643:   sprintf (op->buf_asm, \"i32.popcnt\");",
          "644:   break;",
          "647:   sprintf (op->buf_asm, \"i32.add\");",
          "648:   break;",
          "651:   sprintf (op->buf_asm, \"i32.sub\");",
          "652:   break;",
          "655:   sprintf (op->buf_asm, \"i32.mul\");",
          "656:   break;",
          "659:   sprintf (op->buf_asm, \"i32.div_s\");",
          "660:   break;",
          "663:   sprintf (op->buf_asm, \"i32.div_u\");",
          "664:   break;",
          "667:   sprintf (op->buf_asm, \"i32.rem_s\");",
          "668:   break;",
          "671:   sprintf (op->buf_asm, \"i32.rem_u\");",
          "672:   break;",
          "675:   sprintf (op->buf_asm, \"i32.and\");",
          "676:   break;",
          "679:   sprintf (op->buf_asm, \"i32.or\");",
          "680:   break;",
          "683:   sprintf (op->buf_asm, \"i32.xor\");",
          "684:   break;",
          "687:   sprintf (op->buf_asm, \"i32.shl\");",
          "688:   break;",
          "691:   sprintf (op->buf_asm, \"i32.shr_s\");",
          "692:   break;",
          "695:   sprintf (op->buf_asm, \"i32.shr_u\");",
          "696:   break;",
          "699:   sprintf (op->buf_asm, \"i32.rotl\");",
          "700:   break;",
          "703:   sprintf (op->buf_asm, \"i32.rotr\");",
          "704:   break;",
          "707:   sprintf (op->buf_asm, \"i64.clz\");",
          "708:   break;",
          "711:   sprintf (op->buf_asm, \"i64.ctz\");",
          "712:   break;",
          "715:   sprintf (op->buf_asm, \"i64.popcnt\");",
          "716:   break;",
          "719:   sprintf (op->buf_asm, \"i64.add\");",
          "720:   break;",
          "723:   sprintf (op->buf_asm, \"i64.sub\");",
          "724:   break;",
          "727:   sprintf (op->buf_asm, \"i64.mul\");",
          "728:   break;",
          "731:   sprintf (op->buf_asm, \"i64.div_s\");",
          "732:   break;",
          "735:   sprintf (op->buf_asm, \"i64.div_u\");",
          "736:   break;",
          "739:   sprintf (op->buf_asm, \"i64.rem_s\");",
          "740:   break;",
          "743:   sprintf (op->buf_asm, \"i64.rem_u\");",
          "744:   break;",
          "747:   sprintf (op->buf_asm, \"i64.and\");",
          "748:   break;",
          "751:   sprintf (op->buf_asm, \"i64.or\");",
          "752:   break;",
          "755:   sprintf (op->buf_asm, \"i64.xor\");",
          "756:   break;",
          "759:   sprintf (op->buf_asm, \"i64.shl\");",
          "760:   break;",
          "763:   sprintf (op->buf_asm, \"i64.shr_s\");",
          "764:   break;",
          "767:   sprintf (op->buf_asm, \"i64.shr_u\");",
          "768:   break;",
          "771:   sprintf (op->buf_asm, \"i64.rotl\");",
          "772:   break;",
          "775:   sprintf (op->buf_asm, \"i64.rotr\");",
          "776:   break;",
          "779:   sprintf (op->buf_asm, \"f32.abs\");",
          "780:   break;",
          "783:   sprintf (op->buf_asm, \"f32.neg\");",
          "784:   break;",
          "787:   sprintf (op->buf_asm, \"f32.ceil\");",
          "788:   break;",
          "791:   sprintf (op->buf_asm, \"f32.floor\");",
          "792:   break;",
          "795:   sprintf (op->buf_asm, \"f32.trunc\");",
          "796:   break;",
          "799:   sprintf (op->buf_asm, \"f32.nearest\");",
          "800:   break;",
          "803:   sprintf (op->buf_asm, \"f32.sqrt\");",
          "804:   break;",
          "807:   sprintf (op->buf_asm, \"f32.add\");",
          "808:   break;",
          "811:   sprintf (op->buf_asm, \"f32.sub\");",
          "812:   break;",
          "815:   sprintf (op->buf_asm, \"f32.mul\");",
          "816:   break;",
          "819:   sprintf (op->buf_asm, \"f32.div\");",
          "820:   break;",
          "823:   sprintf (op->buf_asm, \"f32.min\");",
          "824:   break;",
          "827:   sprintf (op->buf_asm, \"f32.max\");",
          "828:   break;",
          "831:   sprintf (op->buf_asm, \"f32.copysign\");",
          "832:   break;",
          "835:   sprintf (op->buf_asm, \"f64.abs\");",
          "836:   break;",
          "839:   sprintf (op->buf_asm, \"f64.neg\");",
          "840:   break;",
          "843:   sprintf (op->buf_asm, \"f64.ceil\");",
          "844:   break;",
          "847:   sprintf (op->buf_asm, \"f64.floor\");",
          "848:   break;",
          "851:   sprintf (op->buf_asm, \"f64.trunc\");",
          "852:   break;",
          "855:   sprintf (op->buf_asm, \"f64.nearest\");",
          "856:   break;",
          "859:   sprintf (op->buf_asm, \"f64.sqrt\");",
          "860:   break;",
          "863:   sprintf (op->buf_asm, \"f64.add\");",
          "864:   break;",
          "867:   sprintf (op->buf_asm, \"f64.sub\");",
          "868:   break;",
          "871:   sprintf (op->buf_asm, \"f64.mul\");",
          "872:   break;",
          "875:   sprintf (op->buf_asm, \"f64.div\");",
          "876:   break;",
          "879:   sprintf (op->buf_asm, \"f64.min\");",
          "880:   break;",
          "883:   sprintf (op->buf_asm, \"f64.max\");",
          "884:   break;",
          "887:   sprintf (op->buf_asm, \"f64.copysign\");",
          "888:   break;",
          "894:   sprintf (op->buf_asm, \"i32.wrap/i64\");",
          "895:   break;",
          "898:   sprintf (op->buf_asm, \"i32.trunc_s/f32\");",
          "899:   break;",
          "902:   sprintf (op->buf_asm, \"i32.trunc_u/f32\");",
          "903:   break;",
          "906:   sprintf (op->buf_asm, \"i32.trunc_s/f64\");",
          "907:   break;",
          "910:   sprintf (op->buf_asm, \"i32.trunc_u/f64\");",
          "911:   break;",
          "914:   sprintf (op->buf_asm, \"i64.extend_s/i32\");",
          "915:   break;",
          "918:   sprintf (op->buf_asm, \"i64.extend_u/i32\");",
          "919:   break;",
          "922:   sprintf (op->buf_asm, \"i64.trunc_s/f32\");",
          "923:   break;",
          "926:   sprintf (op->buf_asm, \"i64.trunc_u/f32\");",
          "927:   break;",
          "930:   sprintf (op->buf_asm, \"i64.trunc_s/f64\");",
          "931:   break;",
          "934:   sprintf (op->buf_asm, \"i64.trunc_u/f64\");",
          "935:   break;",
          "938:   sprintf (op->buf_asm, \"f32.convert_s/i32\");",
          "939:   break;",
          "942:   sprintf (op->buf_asm, \"f32.convert_u/i32\");",
          "943:   break;",
          "946:   sprintf (op->buf_asm, \"f32.convert_s/i64\");",
          "947:   break;",
          "950:   sprintf (op->buf_asm, \"f32.convert_u/i64\");",
          "951:   break;",
          "954:   sprintf (op->buf_asm, \"f32.demote/f64\");",
          "955:   break;",
          "958:   sprintf (op->buf_asm, \"f64.convert_s/i32\");",
          "959:   break;",
          "962:   sprintf (op->buf_asm, \"f64.convert_u/i32\");",
          "963:   break;",
          "966:   sprintf (op->buf_asm, \"f64.convert_s/i64\");",
          "967:   break;",
          "970:   sprintf (op->buf_asm, \"f64.convert_u/i64\");",
          "971:   break;",
          "974:   sprintf (op->buf_asm, \"f64.promote/f32\");",
          "975:   break;",
          "981:   sprintf (op->buf_asm, \"i32.reinterpret/f32\");",
          "982:   break;",
          "985:   sprintf (op->buf_asm, \"i64.reinterpret/f64\");",
          "986:   break;",
          "989:   sprintf (op->buf_asm, \"f32.reinterpret/i32\");",
          "990:   break;",
          "993:   sprintf (op->buf_asm, \"f64.reinterpret/i64\");",
          "",
          "[Added Lines]",
          "11: static const char * const opcodes[] = {",
          "13:  \"trap\",    // 0x00",
          "14:  \"nop\",    // 0x01",
          "15:  \"block\",   // 0x02",
          "16:  \"loop\",    // 0x03",
          "17:  \"if\",    // 0x04",
          "18:  \"else\",    // 0x05",
          "19:  NULL,NULL,NULL,NULL,NULL,",
          "20:  \"end\",    // 0x0b",
          "21:  \"br\",    // 0x0c",
          "22:  \"br_if\",   // 0x0d",
          "23:  \"br_table\",   // 0x0e",
          "24:  \"return\",   // 0x0f",
          "26:  \"call\",    // 0x10",
          "27:  \"call_indirect\",  // 0x11",
          "28:  NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,",
          "30:  \"drop\",    // 0x1a",
          "31:  \"select\",   // 0x1b",
          "32:  NULL,NULL,NULL,NULL,",
          "34:  \"get_local\",  // 0x20",
          "35:  \"set_local\",  // 0x21",
          "36:  \"tee_local\",  // 0x22",
          "37:  \"get_global\",  // 0x23",
          "38:  \"set_global\",  // 0x24",
          "39:  NULL,NULL,NULL,",
          "41:  \"i32.load\",   // 0x28",
          "42:  \"i64.load\",   // 0x29",
          "43:  \"f32.load\",   // 0x2a",
          "44:  \"f64.load\",   // 0x2b",
          "45:  \"i32.load8_s\",  // 0x2c",
          "46:  \"i32.load8_u\",  // 0x2d",
          "47:  \"i32.load16_s\",  // 0x2e",
          "48:  \"i64.load_16_u\", // 0x2f",
          "49:  \"i64.load8_s\",  // 0x30",
          "50:  \"i64.load8_u\",  // 0x31",
          "51:  \"i64.load16_s\",  // 0x32",
          "52:  \"i64.load16_u\",  // 0x33",
          "53:  \"i64.load32_s\",  // 0x34",
          "54:  \"i64.load32_u\",  // 0x35",
          "55:  \"i32.store\",  // 0x36",
          "56:  \"i64.store\",  // 0x37",
          "57:  \"f32.store\",  // 0x38",
          "58:  \"f64.store\",  // 0x39",
          "59:  \"i32.store8\",  // 0x3a",
          "60:  \"i32.store16\",  // 0x3b",
          "61:  \"i64.store8\",  // 0x3c",
          "62:  \"i64.store16\",  // 0x3d",
          "63:  \"i64.store32\",  // 0x3e",
          "64:  \"current_memory\", // 0x3f",
          "65:  \"grow_memory\",  // 0x40",
          "67:  \"i32.const\",  // 0x41",
          "68:  \"i64.const\",  // 0x42",
          "69:  \"f32.const\",  // 0x43",
          "70:  \"f64.const\",  // 0x44",
          "72:  \"i32.eqz\",   // 0x45",
          "73:  \"i32.eq\",   // 0x46",
          "74:  \"i32.ne\",   // 0x47",
          "75:  \"i32.lt_s\",   // 0x48",
          "76:  \"i32.lt_u\",   // 0x49",
          "77:  \"i32.gt_s\",   // 0x4a",
          "78:  \"i32.gt_u\",   // 0x4b",
          "79:  \"i32.le_s\",   // 0x4c",
          "80:  \"i32.le_u\",   // 0x4d",
          "81:  \"i32.ge_s\",   // 0x4e",
          "82:  \"i32.ge_u\",   // 0x4f",
          "83:  \"i64.eqz\",   // 0x50",
          "84:  \"i64.eq\",   // 0x51",
          "85:  \"i64.ne\",   // 0x52",
          "86:  \"i64.lt_s\",   // 0x53",
          "87:  \"i64.lt_u\",   // 0x54",
          "88:  \"i64.gt_s\",   // 0x55",
          "89:  \"i64.gt_u\",   // 0x56",
          "90:  \"i64.le_s\",   // 0x57",
          "91:  \"i64.le_u\",   // 0x58",
          "92:  \"i64.ge_s\",   // 0x59",
          "93:  \"i64.ge_u\",   // 0x5a",
          "94:  \"f32.eq\",   // 0x5b",
          "95:  \"f32.ne\",   // 0x5c",
          "96:  \"f32.lt\",   // 0x5d",
          "97:  \"f32.gt\",   // 0x5e",
          "98:  \"f32.le\",   // 0x5f",
          "99:  \"f32.ge\",   // 0x60",
          "100:  \"f64.eq\",   // 0x61",
          "101:  \"f64.ne\",   // 0x62",
          "102:  \"f64.lt\",   // 0x63",
          "103:  \"f64.gt\",   // 0x64",
          "104:  \"f64.le\",   // 0x65",
          "105:  \"f64.ge\",   // 0x66",
          "107:  \"i32.clz\",   // 0x67",
          "108:  \"i32.ctz\",   // 0x68",
          "109:  \"i32.popcnt\",  // 0x69",
          "110:  \"i32.add\",   // 0x6a",
          "111:  \"i32.sub\",   // 0x6b",
          "112:  \"i32.mul\",   // 0x6c",
          "113:  \"i32.div_s\",  // 0x6d",
          "114:  \"i32.div_u\",  // 0x6e",
          "115:  \"i32.rem_s\",  // 0x6f",
          "116:  \"i32.rem_u\",  // 0x7f",
          "117:  \"i32.and\",   // 0x71",
          "118:  \"i32.or\",   // 0x72",
          "119:  \"i32.xor\",   // 0x73",
          "120:  \"i32.shl\",   // 0x74",
          "121:  \"i32.shr_s\",  // 0x75",
          "122:  \"i32.shr_u\",  // 0x76",
          "123:  \"i32.rotl\",   // 0x77",
          "124:  \"i32.rotr\",   // 0x78",
          "125:  \"i64.clz\",   // 0x79",
          "126:  \"i64.ctz\",   // 0x7a",
          "127:  \"i64.popcnt\",  // 0x7b",
          "128:  \"i64.add\",   // 0x7c",
          "129:  \"i64.sub\",   // 0x7d",
          "130:  \"i64.mul\",   // 0x7e",
          "131:  \"i64.div_s\",  // 0x7f",
          "132:  \"i64.div_u\",  // 0x80",
          "133:  \"i64.rem_s\",  // 0x81",
          "134:  \"i64.rem_u\",  // 0x82",
          "135:  \"i64.and\",   // 0x83",
          "136:  \"i64.or\",   // 0x84",
          "137:  \"i64.xor\",   // 0x85",
          "138:  \"i64.shl\",   // 0x86",
          "139:  \"i64.shr_s\",  // 0x87",
          "140:  \"i64.shr_u\",  // 0x88",
          "141:  \"i64.rotl\",   // 0x89",
          "142:  \"i64.rotr\",   // 0x8a",
          "143:  \"f32.abs\",   // 0x8b",
          "144:  \"f32.neg\",   // 0x8c",
          "145:  \"f32.ceil\",   // 0x8d",
          "146:  \"f32.floor\",  // 0x8e",
          "147:  \"f32.trunc\",  // 0x8f",
          "148:  \"f32.nearest\",  // 0x90",
          "149:  \"f32.sqrt\",   // 0x91",
          "150:  \"f32.add\",   // 0x92",
          "151:  \"f32.sub\",   // 0x93",
          "152:  \"f32.mul\",   // 0x94",
          "153:  \"f32.div\",   // 0x95",
          "154:  \"f32.min\",   // 0x96",
          "155:  \"f32.max\",   // 0x97",
          "156:  \"f32.copysing\",  // 0x98",
          "157:  \"f64.abs\",   // 0x99",
          "158:  \"f64.neg\",   // 0x9a",
          "159:  \"f64.ceil\",   // 0x9b",
          "160:  \"f64.floor\",  // 0x9c",
          "161:  \"f64.trunc\",  // 0x9d",
          "162:  \"f64.nearest\",  // 0x9e",
          "163:  \"f64.sqrt\",   // 0x9f",
          "164:  \"f64.add\",   // 0xa0",
          "165:  \"f64.sub\",   // 0xa1",
          "166:  \"f64.mul\",   // 0xa2",
          "167:  \"f64.div\",   // 0xa3",
          "168:  \"f64.min\",   // 0xa4",
          "169:  \"f64.max\",   // 0xa5",
          "170:  \"f64.copysing\",  // 0xa6",
          "172:  \"i32.wrap/i64\",  // 0xa7",
          "173:  \"i32.trunc_s/f32\", // 0xa8",
          "174:  \"i32.trunc_u/f32\", // 0xa9",
          "175:  \"i32.trunc_s/f64\", // 0xaa",
          "176:  \"i32.trunc_u/f64\", // 0xab",
          "177:  \"i64.extend_s/i32\", // 0xac",
          "178:  \"i64.extend_u/i32\", // 0xad",
          "179:  \"i64.trunc_s/f32\", // 0xae",
          "180:  \"i64.trunc_u/f32\", // 0xaf",
          "181:  \"i64.trunc_s/f64\", // 0xb0",
          "182:  \"i64.trunc_u/f64\", // 0xb1",
          "183:  \"f32.convert_s/i32\",// 0xb2",
          "184:  \"f32.convert_u/i32\",// 0xb3",
          "185:  \"f32.convert_s/i64\",// 0xb4",
          "186:  \"f32.convert_u/i64\",// 0xb5",
          "187:  \"f32.demote/f64\", // 0xb6",
          "188:  \"f64.convert_s/i32\",// 0xb7",
          "189:  \"f64.convert_u/i32\",// 0xb8",
          "190:  \"f64.convert_s/i64\",// 0xb9",
          "191:  \"f64.convert_u/i64\",// 0xba",
          "192:  \"f64.promote/f32\", // 0xbb",
          "194:  \"i32.reinterpret/f32\", // 0xbc",
          "195:  \"i64.reinterpret/f64\", // 0xbd",
          "196:  \"f32.reinterpret/i32\", // 0xbe",
          "197:  \"f64/reinterpret/i64\", // 0xbf",
          "199: };",
          "204:  if (len < 1) goto err;",
          "206:  ut8 o = buf[0];",
          "208:  switch (o) {",
          "339:   snprintf (op->buf_asm, R_ASM_BUFSIZE, \"%s\", opcodes[o]);",
          "340:   break;",
          "341:  case 0x02:",
          "342:  case 0x03:",
          "343:  case 0x04:",
          "344:   {",
          "345:    if (len >= 2) {",
          "346:     if (buf[1] == 0x40) {",
          "347:      snprintf (op->buf_asm, R_ASM_BUFSIZE, \"%s\", opcodes[o]);",
          "348:     } else {",
          "350:      snprintf (op->buf_asm, R_ASM_BUFSIZE, \"%s ...\", opcodes[o]);",
          "351:     }",
          "352:     rep = 2;",
          "353:    }",
          "354:   }",
          "355:   break;",
          "356:  case 0x0c:",
          "357:  case 0x0d:",
          "358:  case 0x10:",
          "359:   {",
          "360:    ut32 val = 0;",
          "361:    size_t n = read_u32_leb128 (buf + 1, buf + len, &val);",
          "362:    if (n > 0 && n < len) {",
          "363:     snprintf (op->buf_asm, R_ASM_BUFSIZE, \"%s %d\", opcodes[o], val);",
          "364:     rep += n;",
          "365:    }",
          "366:   }",
          "367:   break;",
          "368:  case 0x0e:",
          "369:   {",
          "371:    ut32 count = 0, table = 0, def = 0;",
          "372:    size_t n = read_u32_leb128 (buf + 1, buf + len, &count);",
          "373:    if (n > 0 && n < len) {",
          "374:     rep += n;",
          "375:     int i;",
          "376:     for (i = 0; i < count; i++) {",
          "377:       n = read_u32_leb128 (buf + n + 1, buf + len, &table);",
          "378:       if (!n || len < rep + n) break;",
          "379:       rep += n;",
          "380:     }",
          "381:     n = read_u32_leb128 (buf + n + 1, buf + len, &count);",
          "382:     if (n > 0 && n + rep < len) {",
          "383:      snprintf (op->buf_asm, R_ASM_BUFSIZE, \"%s %d ... %d\", opcodes[o], count, def);",
          "384:      rep += n;",
          "385:     }",
          "386:    }",
          "387:   }",
          "388:   break;",
          "389:  case 0x11:",
          "390:   {",
          "391:    ut32 val = 0, reserved = 0;",
          "392:    size_t n = read_u32_leb128 (buf + 1, buf + len, &val);",
          "393:    if (n > 0 && n < len)  {",
          "394:     rep += n;",
          "395:     n = read_u32_leb128 (buf + n + 1, buf + len, &reserved);",
          "396:     if (n == 1 || n + rep < len)  {",
          "397:      reserved &= 0x1;",
          "398:      snprintf (op->buf_asm, R_ASM_BUFSIZE, \"call_indirect %d %d\", val, reserved);",
          "399:     }",
          "400:    }",
          "401:   }",
          "402:   break;",
          "403:  case 0x20:",
          "404:  case 0x21:",
          "405:  case 0x22:",
          "406:  case 0x23:",
          "407:  case 0x24:",
          "408:   {",
          "409:    ut32 val = 0;",
          "410:    size_t n = read_u32_leb128 (buf + 1, buf + len, &val);",
          "411:    if (n > 0 && n < len) {",
          "412:     snprintf (op->buf_asm, R_ASM_BUFSIZE, \"%s %d\", opcodes[o], val);",
          "413:     rep += n;",
          "414:    }",
          "415:   }",
          "416:   break;",
          "417:  case 0x28:",
          "418:  case 0x29:",
          "419:  case 0x2a:",
          "420:  case 0x2b:",
          "421:  case 0x2c:",
          "422:  case 0x2d:",
          "423:  case 0x2e:",
          "424:  case 0x2f:",
          "425:  case 0x30:",
          "426:  case 0x31:",
          "427:  case 0x32:",
          "428:  case 0x33:",
          "429:  case 0x34:",
          "430:  case 0x35:",
          "431:  case 0x36:",
          "432:  case 0x37:",
          "433:  case 0x38:",
          "434:  case 0x39:",
          "435:  case 0x3a:",
          "436:  case 0x3b:",
          "437:  case 0x3c:",
          "438:  case 0x3d:",
          "439:  case 0x3e:",
          "440:   {",
          "441:    ut32 flag = 0, offset = 0;",
          "442:    size_t n = read_u32_leb128 (buf + 1, buf + len, &flag);",
          "443:    if (n > 0 && n < len) {",
          "444:     rep += n;",
          "445:     size_t m = read_u32_leb128 (buf + 1 + n, buf + len, &offset);",
          "446:     if (m > 0 && rep + m < len) {",
          "447:      snprintf (op->buf_asm, R_ASM_BUFSIZE, \"%s %d %d\", opcodes[o], flag, offset);",
          "448:      rep += m;",
          "449:     }",
          "450:    }",
          "451:   }",
          "452:   break;",
          "453:  case 0x3f:",
          "454:  case 0x40:",
          "455:   {",
          "456:    ut32 reserved = 0;",
          "457:    size_t n = read_u32_leb128 (buf + 1, buf + len, &reserved);",
          "458:    if (n == 1 && n < len) {",
          "459:     reserved &= 0x1;",
          "460:     snprintf (op->buf_asm, R_ASM_BUFSIZE, \"%s %d\", opcodes[o], reserved);",
          "461:     rep += n;",
          "462:    }",
          "463:   }",
          "466:  case 0x41:",
          "467:   {",
          "468:    st32 val = 0;",
          "469:    size_t n = read_i32_leb128 (buf + 1, buf + len, &val);",
          "470:    if (n > 0 && n < len) {",
          "471:     snprintf (op->buf_asm, R_ASM_BUFSIZE, \"%s %\" PRId32, opcodes[o], val);",
          "472:     rep += n;",
          "473:    }",
          "474:   }",
          "475:   break;",
          "476:  case 0x42:",
          "477:   {",
          "478:    st64 val = 0;",
          "479:    size_t n = read_i64_leb128 (buf + 1, buf + len, &val);",
          "480:    if (n > 0 && n < len) {",
          "481:     snprintf (op->buf_asm, R_ASM_BUFSIZE, \"%s %\" PRId64, opcodes[o], val);",
          "482:     rep += n;",
          "483:    }",
          "484:   }",
          "485:   break;",
          "486:  case 0x43:",
          "487:   {",
          "488:    ut32 val = 0;",
          "489:    size_t n = read_u32_leb128 (buf + 1, buf + len, &val);",
          "490:    if (n > 0 && n < len) {",
          "491:     snprintf (op->buf_asm, R_ASM_BUFSIZE, \"%s %\" PFMT32d, opcodes[o], val);",
          "492:     rep += n;",
          "493:    }",
          "494:   }",
          "495:   break;",
          "496:  case 0x44:",
          "497:   {",
          "498:    ut64 val = 0;",
          "499:    size_t n = read_u64_leb128 (buf + 1, buf + len, &val);",
          "500:    if (n > 0 && n < len) {",
          "501:     snprintf (op->buf_asm, R_ASM_BUFSIZE, \"%s %\" PFMT64d, opcodes[o], val);",
          "502:     rep += n;",
          "503:    }",
          "504:   }",
          "505:   break;",
          "511: err:",
          "",
          "---------------"
        ],
        "libr/bin/format/wasm/wasm.c||libr/bin/format/wasm/wasm.c": [
          "File: libr/bin/format/wasm/wasm.c -> libr/bin/format/wasm/wasm.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "8: #include \"wasm.h\"",
          "12:  size_t n;",
          "14:   return 0;",
          "15:  }",
          "17:   return 0;",
          "18:  }",
          "21:  }",
          "22:  return n;",
          "23: }",
          "26:  size_t n;",
          "28:   return 0;",
          "29:  }",
          "31:   return 0;",
          "32:  }",
          "35:  }",
          "36:  return n;",
          "37: }",
          "40:  size_t n;",
          "41:  ut32 tmp;",
          "43:   return 0;",
          "44:  }",
          "47: }",
          "50:  size_t n;",
          "51:  ut32 tmp;",
          "53:   return 0;",
          "54:  }",
          "57: }",
          "61:   return 0;",
          "62:  }",
          "64:   return 0;",
          "65:  }",
          "68:  return sz;",
          "69: }",
          "72:  ut32 i = 0;",
          "75:   i++;",
          "76:  }",
          "78:   return 0;",
          "79:  }",
          "83:  return i + 1;",
          "84: }",
          "91:   return 0;",
          "92:  }",
          "101:    return 0;",
          "102:   }",
          "104:  }",
          "106:  return j;",
          "107: }",
          "116: }",
          "119: static RList *r_bin_wasm_get_sections_by_id (RList *sections, ut8 id) {",
          "120:  RBinWasmSection *sec = NULL;",
          "121:  RList *ret = NULL;",
          "126:   return NULL;",
          "127:  }",
          "128:  r_list_foreach (sections, iter, sec) {",
          "129:   if (sec->id == id) {",
          "130:    r_list_append(ret, sec);",
          "",
          "[Removed Lines]",
          "11: static size_t consume_u32 (ut8 *buf, ut8 *max, ut32 *out, ut32 *offset) {",
          "13:  if (!buf || !max || !out) {",
          "16:  if (!(n = read_u32_leb128 (buf, max, out)) || n > 5) {",
          "19:  if (offset) {",
          "25: static size_t consume_s32 (ut8 *buf, ut8 *max, st32 *out, ut32 *offset) {",
          "27:  if (!buf || !max || !out) {",
          "30:  if (!(n = read_i32_leb128 (buf, max, out)) || n > 5) {",
          "33:  if (offset) {",
          "39: static size_t consume_u8 (ut8 *buf, ut8 *max, ut8 *out, ut32 *offset) {",
          "42:  if (!(n = consume_u32 (buf, max, &tmp, offset)) || n > 1) {",
          "46:  return 1;",
          "49: static size_t consume_s8 (ut8 *buf, ut8 *max, st8 *out, ut32 *offset) {",
          "52:  if (!(n = consume_u32 (buf, max, &tmp, offset)) || n > 1) {",
          "56:  return 1;",
          "59: static size_t consume_str (ut8 *buf, ut8 *max, size_t sz, char *out, ut32 *offset) {",
          "60:  if (!buf || !max || !out || !sz) {",
          "63:  if (!(buf + sz < max)) {",
          "66:  strncpy ((char*)out, (char*)buf, R_MIN (R_BIN_WASM_STRING_LENGTH-1, sz));",
          "67:  if (offset) *offset += sz;",
          "71: static size_t consume_init_expr (ut8 *buf, ut8 *max, ut8 eoc, void *out, ut32 *offset) {",
          "73:  while (buf + i < max && buf[i] != eoc) {",
          "77:  if (buf[i] != eoc) {",
          "80:  if (offset) {",
          "82:  }",
          "86: static size_t consume_locals (ut8 *buf, ut8 *max, ut32 count, RBinWasmCodeEntry *out, ut32 *offset) {",
          "87:  ut32 i = 0, j = 0;",
          "88:  if (count < 1) return 0;",
          "90:  if (!(out->locals = (struct r_bin_wasm_local_entry_t*) malloc (sizeof(struct r_bin_wasm_local_entry_t) * count))) {",
          "93:  while (buf + i < max && j < count) {",
          "94:   if (!(consume_u32 (buf + i, max, &out->locals[j].count, &i))) {",
          "95:    free (out->locals);",
          "96:    return 0;",
          "97:   }",
          "99:   if (!(consume_s8 (buf + i, max, (st8*)&out->locals[j].type, &i))) {",
          "100:    free (out->locals);",
          "103:   j += 1;",
          "105:  if (offset) *offset += i;",
          "109: static size_t consume_limits (ut8 *buf, ut8 *max, struct r_bin_wasm_resizable_limits_t *out, ut32 *offset) {",
          "110:  ut32 i = 0;",
          "111:  if (!(consume_u8 (buf + i, max, &out->flags, &i))) return 0;",
          "112:  if (!(consume_u32 (buf + i, max, &out->initial, &i))) return 0;",
          "113:  if (out->flags && (!(consume_u32 (buf + i, max, &out->maximum, &i)))) return 0;",
          "114:  if (offset) *offset += i;",
          "115:  return i;",
          "122:  RListIter *iter = NULL;",
          "125:  if (!(ret = r_list_new ())) {",
          "",
          "[Added Lines]",
          "11: static size_t consume_u32_r (RBuffer *b, ut64 max, ut32 *out) {",
          "13:  ut32 tmp;",
          "14:  if (!b || !b->buf || max >= b->length || b->cur > max) {",
          "17:  if (!(n = read_u32_leb128 (&b->buf[b->cur], &b->buf[max + 1], &tmp))) {",
          "20:  r_buf_seek (b, n, R_IO_SEEK_CUR);",
          "21:  if (out) {",
          "27: static size_t consume_s32_r (RBuffer *b, ut64 max, st32 *out) {",
          "29:  st32 tmp;",
          "30:  if (!b || !b->buf || max >= b->length || b->cur > max) {",
          "33:  if (!(n = read_i32_leb128 (&b->buf[b->cur], &b->buf[max + 1], &tmp))) {",
          "36:  r_buf_seek (b, n, R_IO_SEEK_CUR);",
          "37:  if (out) {",
          "43: static size_t consume_u7_r (RBuffer *b, ut64 max, ut8 *out) {",
          "46:  if (!b || !b->buf || max >= b->length || b->cur > max) {",
          "47:   return 0;",
          "48:  }",
          "49:  if (!(n = read_u32_leb128 (&b->buf[b->cur], &b->buf[max + 1], &tmp))) {",
          "52:  r_buf_seek (b, n, R_IO_SEEK_CUR);",
          "53:  if (out) {",
          "55:  }",
          "56:  return n;",
          "59: static size_t consume_s7_r (RBuffer *b, ut64 max, st8 *out) {",
          "60:  size_t n;",
          "61:  st32 tmp;",
          "62:  if (!b || !b->buf || max >= b->length || b->cur > max) {",
          "63:   return 0;",
          "64:  }",
          "65:  if (!(n = read_i32_leb128 (&b->buf[b->cur], &b->buf[max + 1], &tmp)) || n > 2) {",
          "66:   return 0;",
          "67:  }",
          "68:  r_buf_seek (b, n, R_IO_SEEK_CUR);",
          "69:  if (out) {",
          "71:  }",
          "72:  return n;",
          "73: }",
          "75: static size_t consume_u1_r (RBuffer *b, ut64 max, ut8 *out) {",
          "78:  if (!b || !b->buf || max >= b->length || b->cur > max) {",
          "79:   return 0;",
          "80:  }",
          "81:  if (!(n = read_u32_leb128 (&b->buf[b->cur], &b->buf[max + 1], &tmp)) || n > 1) {",
          "84:  r_buf_seek (b, n, R_IO_SEEK_CUR);",
          "85:  if (out) {",
          "87:  }",
          "88:  return n;",
          "91: static size_t consume_str_r (RBuffer *b, ut64 max, size_t sz, char *out) {",
          "92:  if (!b || !b->buf || max >= b->length || b->cur > max) {",
          "95:  if (!(b->cur + sz - 1 <= max)) {",
          "98:  if (sz > 0) {",
          "99:   strncpy (out, (char*)&b->buf[b->cur], R_MIN (R_BIN_WASM_STRING_LENGTH - 1, sz));",
          "100:  } else {",
          "102:  }",
          "103:  r_buf_seek (b, sz, R_IO_SEEK_CUR);",
          "107: static size_t consume_init_expr_r (RBuffer *b, ut64 max, ut8 eoc, void *out) {",
          "108:  if (!b || !b->buf || max >= b->length || b->cur > max) {",
          "109:   return 0;",
          "110:  }",
          "112:  while (b->cur + i <= max && b->buf[b->cur + i] != eoc) {",
          "116:  if (*(ut8*)(&b->buf[b->cur + i]) != eoc) {",
          "119:  r_buf_seek (b, i + 1, R_IO_SEEK_CUR);",
          "123: static size_t consume_locals_r (RBuffer *b, ut64 max, RBinWasmCodeEntry *out) {",
          "124:  if (!b || !b->buf || max >= b->length || b->cur > max) {",
          "127:  ut32 count = out ? out->local_count : 0;",
          "128:  if (!(b->cur + (count * 7) <= max)) { // worst case 7 bytes",
          "129:   return 0;",
          "130:  }",
          "131:  if (count > 0) {",
          "132:   if (!(out->locals = R_NEWS0 (struct r_bin_wasm_local_entry_t, count))) {",
          "136:  ut32 j = 0;",
          "137:  while (b->cur <= max && j < count) {",
          "138:   if (!(consume_u32_r (b, max, (out? &out->locals[j].count: NULL)))) {",
          "139:    goto beach;",
          "140:   }",
          "141:   if (!(consume_s7_r (b, max, (out? (st8*)&out->locals[j].type: NULL)))) {",
          "142:    goto beach;",
          "143:   }",
          "144:   j++;",
          "145:  }",
          "146:  if (j != count) goto beach;",
          "148: beach:",
          "149:  free (out->locals);",
          "150:  out->locals = NULL;",
          "151:  return 0;",
          "154: static size_t consume_limits_r (RBuffer *b, ut64 max, struct r_bin_wasm_resizable_limits_t *out) {",
          "155:  if (!b || !b->buf || max >= b->length || b->cur > max || !out) {",
          "156:   return 0;",
          "157:  }",
          "158:  ut32 i = b->cur;",
          "159:  if (!(consume_u7_r (b, max, &out->flags))) {",
          "160:   return 0;",
          "161:  }",
          "162:  if (!(consume_u32_r (b, max, &out->initial))) {",
          "163:   return 0;",
          "164:  }",
          "165:  if (out->flags && (!(consume_u32_r (b, max, &out->maximum)))) {",
          "166:   return 0;",
          "167:  }",
          "168:  return (size_t)R_ABS (b->cur - i);",
          "176:  if (!(ret = r_list_newf (NULL))) {",
          "180:  RListIter *iter;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "133:  return ret;",
          "134: }",
          "152: }",
          "154: static char *r_bin_wasm_type_entry_to_string (RBinWasmTypeEntry *ptr) {",
          "156:   return NULL;",
          "157:  }",
          "167:   return NULL;",
          "168:  }",
          "175:   if (p < ptr->param_count - 1) {",
          "178:   }",
          "186:  }",
          "191: }",
          "194: static RList *r_bin_wasm_get_type_entries (RBinWasmObj *bin, RBinWasmSection *sec) {",
          "196:  RList *ret = NULL;",
          "197:  RBinWasmTypeEntry *ptr = NULL;",
          "200:   return NULL;",
          "201:  }",
          "209:   if (!(ptr = R_NEW0 (RBinWasmTypeEntry))) {",
          "210:    return ret;",
          "211:   }",
          "216:   }",
          "221:   }",
          "226:   }",
          "228:   int j;",
          "233:    }",
          "234:   }",
          "239:   }",
          "241:   if (ptr->return_count > 1) {",
          "244:   }",
          "246:   if (ptr->return_count == 1) {",
          "250:    }",
          "251:   }",
          "255:   r_list_append (ret, ptr);",
          "259:  }",
          "261:  return ret;",
          "263: }",
          "265: static RList *r_bin_wasm_get_import_entries (RBinWasmObj *bin, RBinWasmSection *sec) {",
          "",
          "[Removed Lines]",
          "136: #define R_BIN_WASM_VALUETYPETOSTRING(p, type, i) {\\",
          "137:  switch(type) {\\",
          "138:  case R_BIN_WASM_VALUETYPE_i32:\\",
          "139:   strcpy(p, \"i32\");\\",
          "140:   break;\\",
          "141:  case R_BIN_WASM_VALUETYPE_i64:\\",
          "142:   strcpy(p, \"i64\");\\",
          "143:   break;\\",
          "144:  case R_BIN_WASM_VALUETYPE_f32:\\",
          "145:   strcpy(p, \"f32\");\\",
          "146:   break;\\",
          "147:  case R_BIN_WASM_VALUETYPE_f64:\\",
          "148:   strcpy(p, \"f64\");\\",
          "149:   break;\\",
          "150:  }\\",
          "151:  i+= 3;\\",
          "155:  if (!ptr || ptr->to_str) {",
          "159:  char *ret;",
          "161:  int p, i = 0, sz;",
          "163:  sz = (ptr->param_count + ptr->return_count) * 5 + 9;",
          "166:  if (!(ret = (char*) malloc (sz * sizeof(char)))) {",
          "170:  strcpy (ret + i, \"(\");",
          "171:  i++;",
          "173:  for (p = 0; p < ptr->param_count; p++ ) {",
          "174:   R_BIN_WASM_VALUETYPETOSTRING (ret+i, ptr->param_types[p], i); // i+=3",
          "176:    strcpy (ret+i, \", \");",
          "177:    i += 2;",
          "179:  }",
          "181:  strcpy (ret + i, \") -> (\");",
          "182:  i += 6;",
          "184:  if (ptr->return_count == 1) {",
          "185:   R_BIN_WASM_VALUETYPETOSTRING (ret + i, ptr->return_type, i);",
          "188:  strcpy (ret + i, \")\");",
          "190:  return ret;",
          "199:  if (!(ret = r_list_newf ((RListFree)free))) {",
          "203:  ut8* buf = bin->buf->buf + (ut32)sec->payload_data;",
          "204:  ut32 len =  sec->payload_len;",
          "205:  ut32 count = sec->count;",
          "206:  ut32 i = 0, r = 0;",
          "208:  while (i < len && r < count) {",
          "213:   if (!(consume_u8 (buf + i, buf + len, &ptr->form, &i))) {",
          "214:    free (ptr);",
          "215:    return ret;",
          "218:   if (!(consume_u32 (buf + i, buf + len, &ptr->param_count, &i))) {",
          "219:    free (ptr);",
          "220:    return ret;",
          "223:   if (!(i + ptr->param_count < len)) {",
          "224:    free (ptr);",
          "225:    return ret;",
          "229:   for (j = 0; j < ptr->param_count; j++) {",
          "230:    if (!(consume_s8 (buf + i, buf + len, (st8*)&ptr->param_types[j], &i))) {",
          "231:     free (ptr);",
          "232:     return ret;",
          "236:   if (!(consume_s8 (buf + i, buf + len, &ptr->return_count, &i))) {",
          "237:    free (ptr);",
          "238:    return ret;",
          "242:    free(ptr);",
          "243:    return ret;",
          "247:    if (!(consume_s8 (buf + i, buf + len, (st8*)&ptr->return_type, &i))) {",
          "248:     free(ptr);",
          "249:     return ret;",
          "253:   ptr->to_str = r_bin_wasm_type_entry_to_string (ptr);",
          "257:   r += 1;",
          "",
          "[Added Lines]",
          "189: static const char *r_bin_wasm_valuetype_to_string (r_bin_wasm_value_type_t type) {",
          "190:  switch (type) {",
          "191:  case R_BIN_WASM_VALUETYPE_i32:",
          "192:   return r_str_const (\"i32\");",
          "193:  case R_BIN_WASM_VALUETYPE_i64:",
          "194:   return r_str_const (\"i62\");",
          "195:  case R_BIN_WASM_VALUETYPE_f32:",
          "196:   return r_str_const (\"f32\");",
          "197:  case R_BIN_WASM_VALUETYPE_f64:",
          "198:   return r_str_const (\"f64\");",
          "199:  default:",
          "200:   return r_str_const (\"?\");",
          "201:  }",
          "205:  if (!ptr) {",
          "208:  char *buf = NULL, *tmp = NULL;",
          "209:  if (!(buf = (char*)calloc (ptr->param_count, 5))) {",
          "212:  int p;",
          "213:  for (p = 0; p < ptr->param_count; p++) {",
          "214:   strcat (buf, r_bin_wasm_valuetype_to_string (ptr->param_types[p]));",
          "216:    strcat (buf, \", \");",
          "218:  }",
          "219:  tmp = strdup (buf);",
          "220:  free (buf);",
          "221:  snprintf(ptr->to_str, R_BIN_WASM_STRING_LENGTH, \"(%s) -> (%s)\",",
          "222:   (ptr->param_count > 0? tmp: \"\"),",
          "223:   (ptr->return_count == 1? r_bin_wasm_valuetype_to_string (ptr->return_type): \"\"));",
          "224:  return ptr->to_str;",
          "226: }",
          "229: static void r_bin_wasm_free_types (RBinWasmTypeEntry *ptr) {",
          "230:  if (ptr) {",
          "231:   free (ptr->param_types);",
          "233:  free (ptr);",
          "234: }",
          "236: static void r_bin_wasm_free_codes (RBinWasmCodeEntry *ptr) {",
          "237:  if (ptr) {",
          "238:   free (ptr->locals);",
          "239:  }",
          "240:  free (ptr);",
          "248:  if (!(ret = r_list_newf ((RListFree)r_bin_wasm_free_types))) {",
          "251:  if (!sec) {",
          "252:   r_list_free (ret);",
          "253:   return NULL;",
          "254:  }",
          "255:  RBuffer *b = bin->buf;",
          "256:  r_buf_seek (b, sec->payload_data, R_IO_SEEK_SET);",
          "257:  ut32 r = 0;",
          "258:  ut64 max = b->cur + sec->payload_len - 1;",
          "259:  if (!(max < b->length)) {",
          "260:   goto beach;",
          "261:  }",
          "262:  while (b->cur <= max && r < sec->count) {",
          "266:   if (!(consume_u7_r (b, max, &ptr->form))) {",
          "267:    goto beach;",
          "270:   if (!(consume_u32_r (b, max, &ptr->param_count))) {",
          "271:    goto beach;",
          "273:   ut32 count = ptr ? ptr->param_count : 0;",
          "274:   if (!(b->cur + (count * 3) <= max)) { // worst case 3 bytes",
          "275:    return 0;",
          "276:   }",
          "277:   if (count > 0) {",
          "278:    if (!(ptr->param_types = R_NEWS0 (r_bin_wasm_value_type_t, count))) {",
          "279:     goto beach;",
          "280:    }",
          "283:   for (j = 0; j < count; j++) {",
          "284:    if (!(consume_s7_r (b, max, (st8*)&ptr->param_types[j]))) {",
          "285:     goto beach;",
          "288:   if (!(consume_u1_r (b, max, (ut8*)&ptr->return_count))) {",
          "289:    goto beach;",
          "292:    goto beach;",
          "295:    if (!(consume_s7_r (b, max, (st8*)&ptr->return_type))) {",
          "296:     goto beach;",
          "301:   r++;",
          "304: beach:",
          "305:  eprintf(\"err: beach type entries\\n\");",
          "306:  free (ptr->param_types);",
          "307:  free (ptr);",
          "308:  return ret;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "269:  if (!(ret = r_list_newf ((RListFree)free))) {",
          "270:   return NULL;",
          "271:  }",
          "279:   if (!(ptr = R_NEW0 (RBinWasmImportEntry))) {",
          "280:    return ret;",
          "281:   }",
          "284:   }",
          "287:   }",
          "290:   }",
          "293:   }",
          "296:   }",
          "297:   switch (ptr->kind) {",
          "298:   case 0: // Function",
          "301:    }",
          "302:    break;",
          "303:   case 1: // Table",
          "306:    }",
          "309:    }",
          "310:    break;",
          "311:   case 2: // Memory",
          "314:    }",
          "315:    break;",
          "316:   case 3: // Global",
          "319:    }",
          "322:    }",
          "323:    break;",
          "324:   default:",
          "326:   }",
          "327:   r_list_append (ret, ptr);",
          "328:   r++;",
          "329:  }",
          "330:  return ret;",
          "334:  free (ptr);",
          "335:  return ret;",
          "336: }",
          "",
          "[Removed Lines]",
          "273:  ut8* buf = bin->buf->buf + (ut32)sec->payload_data;",
          "274:  ut32 len =  sec->payload_len;",
          "275:  ut32 count = sec->count;",
          "276:  ut32 i = 0, r = 0;",
          "278:  while (i < len && r < count) {",
          "282:   if (!(consume_u32 (buf + i, buf + len, &ptr->module_len, &i))) {",
          "283:    goto culvert;",
          "285:   if (!(consume_str (buf + i, buf + len, ptr->module_len, ptr->module_str, &i))) {",
          "286:    goto culvert;",
          "288:   if (!(consume_u32 (buf + i, buf + len, &ptr->field_len, &i))) {",
          "289:    goto culvert;",
          "291:   if (!(consume_str (buf + i, buf + len, ptr->field_len, ptr->field_str, &i))) {",
          "292:    goto culvert;",
          "294:   if (!(consume_u8 (buf + i, buf + len, &ptr->kind, &i))) {",
          "295:    goto culvert;",
          "299:    if (!(consume_u32 (buf + i, buf + len, &ptr->type_f, &i))) {",
          "300:     goto sewer;",
          "304:    if (!(consume_u8 (buf + i, buf + len, (ut8*)&ptr->type_t.elem_type, &i))) {",
          "305:     goto sewer; // varint7",
          "307:    if (!(consume_limits (buf + i, buf + len, &ptr->type_t.limits, &i))) {",
          "308:     goto sewer;",
          "312:    if (!(consume_limits (buf + i, buf + len, &ptr->type_m.limits, &i))) {",
          "313:     goto sewer;",
          "317:    if (!(consume_u8 (buf + i, buf + len, (ut8*)&ptr->type_g.content_type, &i))) {",
          "318:     goto sewer; // varint7",
          "320:    if (!(consume_u8 (buf + i, buf + len, (ut8*)&ptr->type_g.mutability, &i))) {",
          "321:     goto sewer; // varuint1",
          "325:    goto sewer;",
          "331: sewer:",
          "332:  ret = NULL;",
          "333: culvert:",
          "",
          "[Added Lines]",
          "318:  if (!sec) {",
          "319:   r_list_free (ret);",
          "320:   return NULL;",
          "321:  }",
          "322:  RBuffer *b = bin->buf;",
          "323:  r_buf_seek (b, sec->payload_data, R_IO_SEEK_SET);",
          "324:  ut64 max = b->cur + sec->payload_len - 1;",
          "325:  if (!(max < b->length)) {",
          "326:   goto beach;",
          "327:  }",
          "328:  ut32 r = 0;",
          "329:  while (b->cur <= max && r < sec->count) {",
          "333:   if (!(consume_u32_r (b, max, &ptr->module_len))) {",
          "334:    goto beach;",
          "336:   if (consume_str_r (b, max, ptr->module_len, ptr->module_str) < ptr->module_len) {",
          "337:    goto beach;",
          "339:   if (!(consume_u32_r (b, max, &ptr->field_len))) {",
          "340:    goto beach;",
          "342:   if (consume_str_r (b, max, ptr->field_len, ptr->field_str) < ptr->field_len) {",
          "343:    goto beach;",
          "345:   if (!(consume_u7_r (b, max, &ptr->kind))) {",
          "346:    goto beach;",
          "350:    if (!(consume_u32_r (b, max, &ptr->type_f))) {",
          "351:     goto beach;",
          "355:    if (!(consume_s7_r (b, max, (st8*)&ptr->type_t.elem_type))) {",
          "356:     goto beach;",
          "358:    if (!(consume_limits_r (b, max, &ptr->type_t.limits))) {",
          "359:     goto beach;",
          "363:    if (!(consume_limits_r (b, max, &ptr->type_m.limits))) {",
          "364:     goto beach;",
          "368:    if (!(consume_s7_r (b, max, (st8*)&ptr->type_g.content_type))) {",
          "369:     goto beach;",
          "371:    if (!(consume_u1_r (b, max, (ut8*)&ptr->type_g.mutability))) {",
          "372:     goto beach;",
          "376:    goto beach;",
          "382: beach:",
          "383:  eprintf(\"err: beach import entries\\n\");",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "342:  if (!(ret = r_list_newf ((RListFree)free))) {",
          "343:   return NULL;",
          "344:  }",
          "352:   if (!(ptr = R_NEW0 (RBinWasmExportEntry))) {",
          "353:    return ret;",
          "354:   }",
          "359:   }",
          "364:   }",
          "369:   }",
          "374:   }",
          "376:   r_list_append (ret, ptr);",
          "377:   r++;",
          "378:  }",
          "379:  return ret;",
          "380: }",
          "382: static RList *r_bin_wasm_get_code_entries (RBinWasmObj *bin, RBinWasmSection *sec) {",
          "383:  RList *ret = NULL;",
          "384:  RBinWasmCodeEntry *ptr = NULL;",
          "387:   return NULL;",
          "388:  }",
          "398:   if (!(ptr = R_NEW0 (RBinWasmCodeEntry))) {",
          "399:    return ret;",
          "400:   }",
          "410:   }",
          "417:   }",
          "422:   }",
          "432:   }",
          "434:   if (ptr->byte != R_BIN_WASM_END_OF_CODE) {",
          "437:   }",
          "442:   r_list_append (ret, ptr);",
          "446:  }",
          "448:  return ret;",
          "449: }",
          "451: static RList *r_bin_wasm_get_data_entries (RBinWasmObj *bin, RBinWasmSection *sec) {",
          "452:  RList *ret = NULL;",
          "453:  RBinWasmDataEntry *ptr = NULL;",
          "456:  if (!(ret = r_list_newf ((RListFree)free))) {",
          "457:   return NULL;",
          "458:  }",
          "467:   if (!(ptr = R_NEW0 (RBinWasmDataEntry))) {",
          "468:    return ret;",
          "469:   }",
          "477:    goto beach;",
          "478:   }",
          "481:    goto beach;",
          "482:   }",
          "484:    goto beach;",
          "485:   }",
          "488:   r_list_append (ret, ptr);",
          "492:  }",
          "493:  return ret;",
          "494: beach:",
          "495:  free (ptr);",
          "496:  return ret;",
          "497: }",
          "499: static RBinWasmStartEntry *r_bin_wasm_get_start (RBinWasmObj *bin, RBinWasmSection *sec) {",
          "501:  RBinWasmStartEntry *ptr;",
          "503:  if (!(ptr = R_NEW0 (RBinWasmStartEntry))) {",
          "504:   return NULL;",
          "505:  }",
          "514:  }",
          "516:  return ptr;",
          "518: }",
          "520: static RList *r_bin_wasm_get_memory_entries (RBinWasmObj *bin, RBinWasmSection *sec) {",
          "522:  RList *ret = NULL;",
          "523:  RBinWasmMemoryEntry *ptr = NULL;",
          "525:  if (!(ret = r_list_newf ((RListFree)free))) {",
          "526:   return NULL;",
          "527:  }",
          "536:   if (!(ptr = R_NEW0 (RBinWasmMemoryEntry))) {",
          "537:    return ret;",
          "538:   }",
          "543:   }",
          "545:   r_list_append (ret, ptr);",
          "549:  }",
          "551:  return ret;",
          "552: }",
          "554: static RList *r_bin_wasm_get_table_entries (RBinWasmObj *bin, RBinWasmSection *sec) {",
          "556:  RList *ret = NULL;",
          "557:  RBinWasmTableEntry *ptr = NULL;",
          "559:  if (!(ret = r_list_newf ((RListFree)free))) {",
          "560:   return NULL;",
          "561:  }",
          "570:   if (!(ptr = R_NEW0 (RBinWasmTableEntry))) {",
          "571:    return ret;",
          "572:   }",
          "577:   }",
          "582:   }",
          "584:   r_list_append (ret, ptr);",
          "588:  }",
          "590:  return ret;",
          "591: }",
          "",
          "[Removed Lines]",
          "346:  ut8* buf = bin->buf->buf + (ut32)sec->payload_data;",
          "347:  ut32 len =  sec->payload_len;",
          "348:  ut32 count = sec->count;",
          "349:  ut32 i = 0, r = 0;",
          "351:  while (i < len && r < count) {",
          "356:   if (!(consume_u32 (buf + i, buf + len, &ptr->field_len, &i))) {",
          "357:    free (ptr);",
          "358:    return ret;",
          "361:   if (!(consume_str (buf + i, buf + len, ptr->field_len, ptr->field_str, &i))) {",
          "362:    free (ptr);",
          "363:    return ret;",
          "366:   if (!(consume_u8 (buf + i, buf + len, &ptr->kind, &i))) {",
          "367:    free (ptr);",
          "368:    return ret;",
          "371:   if (!(consume_u32 (buf + i, buf + len, &ptr->index, &i))) {",
          "372:    free (ptr);",
          "373:    return ret;",
          "386:  if (!(ret = r_list_newf ((RListFree)free))) {",
          "390:  ut8* buf = bin->buf->buf + (ut32)sec->payload_data;",
          "391:  ut32 len =  sec->payload_len;",
          "392:  ut32 count = sec->count;",
          "393:  ut32 i = 0, j = 0, r = 0;",
          "394:  size_t n = 0;",
          "396:  while (i < len && r < count) {",
          "402:   if (!(n = consume_u32 (buf + i, buf + len, &ptr->body_size, &i))) {",
          "403:    free (ptr);",
          "404:    return ret;",
          "405:   }",
          "407:   if (!(i + ptr->body_size - 1 < len)) {",
          "408:    free (ptr);",
          "409:    return ret;",
          "412:   j = i;",
          "414:   if (!(n = consume_u32 (buf + i, buf + len, &ptr->local_count, &i))) {",
          "415:    free (ptr);",
          "416:    return ret;",
          "419:   if ((n = consume_locals (buf + i, buf + len, ptr->local_count,ptr, &i)) < ptr->local_count) {",
          "420:    free (ptr);",
          "421:    return ret;",
          "424:   ptr->code = sec->payload_data + i;",
          "425:   ptr->len = ptr->body_size - (i - j);",
          "427:   i += ptr->len - 1; // consume bytecode",
          "429:   if (!(consume_u8 (buf + i, buf + len, &ptr->byte, &i))) {",
          "430:    free (ptr);",
          "431:    return ret;",
          "435:    free (ptr);",
          "436:    return ret;",
          "444:   r += 1;",
          "454:  ut32 len =  sec->payload_len;",
          "460:  ut8* buf = bin->buf->buf + (ut32)sec->payload_data;",
          "461:  int buflen = bin->buf->length - (ut32)sec->payload_data;",
          "462:  ut32 count = sec->count;",
          "463:  ut32 i = 0, r = 0;",
          "464:  size_t n = 0;",
          "466:  while (i < len && len < buflen && r < count) {",
          "470:   if (!(consume_u32 (buf + i, buf + len, &ptr->index, &i))) {",
          "471:    goto beach;",
          "472:   }",
          "473:   if (i + 4 >= buflen) {",
          "474:    goto beach;",
          "475:   }",
          "476:   if (!(n = consume_init_expr (buf + i, buf + len, R_BIN_WASM_END_OF_CODE, NULL, &i))) {",
          "479:   ptr->offset.len = n;",
          "480:   if (!(consume_u32 (buf + i, buf + len, &ptr->size, &i))) {",
          "483:   if (i + 4 >= buflen) {",
          "486:   ptr->data = sec->payload_data + i;",
          "490:   r += 1;",
          "507:  ut8* buf = bin->buf->buf + (ut32)sec->payload_data;",
          "508:  ut32 len =  sec->payload_len;",
          "509:  ut32 i = 0;",
          "511:  if (!(consume_u32 (buf + i, buf + len, &ptr->index, &i))) {",
          "512:   free (ptr);",
          "513:   return NULL;",
          "529:  ut8* buf = bin->buf->buf + (ut32)sec->payload_data;",
          "530:  ut32 len =  sec->payload_len;",
          "531:  ut32 count = sec->count;",
          "532:  ut32 i = 0, r = 0;",
          "534:  while (i < len && r < count) {",
          "540:   if (!(consume_limits (buf + i, buf + len, &ptr->limits, &i))) {",
          "541:    free (ptr);",
          "542:    return ret;",
          "547:   r += 1;",
          "563:  ut8* buf = bin->buf->buf + (ut32)sec->payload_data;",
          "564:  ut32 len =  sec->payload_len;",
          "565:  ut32 count = sec->count;",
          "566:  ut32 i = 0, r = 0;",
          "568:  while (i < len && r < count) {",
          "574:   if (!(consume_u8 (buf + i, buf + len, &ptr->element_type, &i))) {",
          "575:    free (ptr);",
          "576:    return ret;",
          "579:   if (!(consume_limits (buf + i, buf + len, &ptr->limits, &i))) {",
          "580:    free (ptr);",
          "581:    return ret;",
          "586:   r += 1;",
          "",
          "[Added Lines]",
          "395:  if (!sec) {",
          "396:   r_list_free (ret);",
          "397:   return NULL;",
          "398:  }",
          "399:  RBuffer *b = bin->buf;",
          "400:  r_buf_seek (b, sec->payload_data, R_IO_SEEK_SET);",
          "401:  ut64 max = b->cur + sec->payload_len - 1;",
          "402:  if (!(max < b->length)) {",
          "403:   goto beach;",
          "404:  }",
          "405:  ut32 r = 0;",
          "406:  while (b->cur <= max && r < sec->count) {",
          "410:   if (!(consume_u32_r (b, max, &ptr->field_len))) {",
          "411:    goto beach;",
          "413:   if (consume_str_r (b, max, ptr->field_len, ptr->field_str) < ptr->field_len) {",
          "414:    goto beach;",
          "416:   if (!(consume_u7_r (b, max, &ptr->kind))) {",
          "417:    goto beach;",
          "419:   if (!(consume_u32_r (b, max, &ptr->index))) {",
          "420:    goto beach;",
          "426: beach:",
          "427:  eprintf(\"err: beach export entries\\n\");",
          "428:  free (ptr);",
          "429:  return ret;",
          "436:  if (!(ret = r_list_newf ((RListFree)r_bin_wasm_free_codes))) {",
          "439:  if (!sec) {",
          "440:   r_list_free (ret);",
          "441:   return NULL;",
          "442:  }",
          "443:  RBuffer *b = bin->buf;",
          "444:  r_buf_seek (b, sec->payload_data, R_IO_SEEK_SET);",
          "445:  ut64 max = b->cur + sec->payload_len - 1;",
          "446:  if (!(max < b->length)) {",
          "447:   goto beach;",
          "448:  }",
          "449:  ut32 r = 0;",
          "450:  while (b->cur <= max && r < sec->count) {",
          "454:   if (!(consume_u32_r (b, max, &ptr->body_size))) {",
          "455:    goto beach;",
          "457:   ut32 j = b->cur;",
          "458:   if (!(b->cur + ptr->body_size - 1 <= max)) {",
          "459:    goto beach;",
          "461:   if (!(consume_u32_r (b, max, &ptr->local_count))) {",
          "462:    goto beach;",
          "464:   if (consume_locals_r (b, max, ptr) < ptr->local_count) {",
          "465:    goto beach;",
          "467:   ptr->code = b->cur;",
          "468:   ptr->len = ptr->body_size - ptr->code + j;",
          "469:   r_buf_seek(b, ptr->len - 1, R_IO_SEEK_CUR); // consume bytecode",
          "470:   r_buf_read (b, &ptr->byte, 1);",
          "472:    goto beach;",
          "477:   r++;",
          "479:  return ret;",
          "480: beach:",
          "481:  eprintf(\"err: beach code entries\\n\");",
          "482:  free (ptr);",
          "493:  if (!sec) {",
          "494:   r_list_free (ret);",
          "495:   return NULL;",
          "496:  }",
          "497:  RBuffer *b = bin->buf;",
          "498:  r_buf_seek (b, sec->payload_data, R_IO_SEEK_SET);",
          "499:  ut64 max = b->cur + sec->payload_len - 1;",
          "500:  if (!(max < b->length)) {",
          "501:   goto beach;",
          "502:  }",
          "503:  ut32 r = 0;",
          "504:  while (b->cur <= max && r < sec->count) {",
          "508:   if (!(consume_u32_r (b, max, &ptr->index))) {",
          "511:   if (!(ptr->offset.len = consume_init_expr_r (b, max, R_BIN_WASM_END_OF_CODE, NULL))) {",
          "514:   if (!(consume_u32_r (b, max, &ptr->size))) {",
          "517:   ptr->data = b->cur;",
          "518:   r_buf_seek (b, ptr->size, R_IO_SEEK_CUR);",
          "520:   r++;",
          "524:  eprintf(\"err: beach data entries\\n\");",
          "536:  RBuffer *b = bin->buf;",
          "537:  r_buf_seek (b, sec->payload_data, R_IO_SEEK_SET);",
          "538:  ut64 max = b->cur + sec->payload_len - 1;",
          "539:  if (!(max < b->length)) {",
          "540:   goto beach;",
          "541:  }",
          "542:  if (!(consume_u32_r (b, max, &ptr->index))) {",
          "543:   goto beach;",
          "546: beach:",
          "547:  eprintf(\"err: beach start\\n\");",
          "548:  free (ptr);",
          "549:  return NULL;",
          "559:  if (!sec) {",
          "560:   r_list_free (ret);",
          "561:   return NULL;",
          "562:  }",
          "563:  RBuffer *b = bin->buf;",
          "564:  r_buf_seek (b, sec->payload_data, R_IO_SEEK_SET);",
          "565:  ut64 max =  b->cur + sec->payload_len - 1;",
          "566:  if (!(max < b->length)) {",
          "567:   goto beach;",
          "568:  }",
          "569:  ut32 r = 0;",
          "570:  while (b->cur <= max && r < sec->count) {",
          "574:   if (!(consume_limits_r (b, max, &ptr->limits))) {",
          "575:    goto beach;",
          "578:   r++;",
          "580:  return ret;",
          "581: beach:",
          "582:  eprintf(\"err: beach memory entries\\n\");",
          "583:  free (ptr);",
          "594:  if (!sec) {",
          "595:   r_list_free (ret);",
          "596:   return NULL;",
          "597:  }",
          "598:  RBuffer *b = bin->buf;",
          "599:  r_buf_seek (b, sec->payload_data, R_IO_SEEK_SET);",
          "600:  ut64 max = b->cur + sec->payload_len - 1;",
          "601:  if (!(max < b->length)) {",
          "602:   goto beach;",
          "603:  }",
          "604:  ut32 r = 0;",
          "605:  while (b->cur <= max && r < sec->count) {",
          "609:   if (!(consume_s7_r (b, max, (st8*)&ptr->element_type))) {",
          "610:    goto beach;",
          "612:   if (!(consume_limits_r (b, max, &ptr->limits))) {",
          "613:    goto beach;",
          "616:   r++;",
          "618:  return ret;",
          "619: beach:",
          "620:  eprintf(\"err: beach table entries\\n\");",
          "621:  free (ptr);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "597:  if (!(ret = r_list_newf ((RListFree)free))) {",
          "598:   return NULL;",
          "599:  }",
          "608:   if (!(ptr = R_NEW0 (RBinWasmGlobalEntry))) {",
          "609:    return ret;",
          "610:   }",
          "613:    goto beach;",
          "614:   }",
          "616:    goto beach;",
          "617:   }",
          "619:    goto beach;",
          "620:   }",
          "621:   r_list_append (ret, ptr);",
          "",
          "[Removed Lines]",
          "601:  ut8* buf = bin->buf->buf + (ut32)sec->payload_data;",
          "602:  int buflen = bin->buf->length - (ut32)sec->payload_data;",
          "603:  ut32 len =  sec->payload_len;",
          "604:  ut32 count = sec->count;",
          "605:  ut32 i = 0, r = 0;",
          "607:  while (i < len && len < buflen && r < count) {",
          "612:   if (len + 8 > buflen || !(consume_u8 (buf + i, buf + len, (ut8*)&ptr->content_type, &i))) {",
          "615:   if (len + 8 > buflen || !(consume_u8 (buf + i, buf + len, &ptr->mutability, &i))) {",
          "618:   if (len + 8 > buflen || !(consume_init_expr (buf + i, buf + len, R_BIN_WASM_END_OF_CODE, NULL, &i))) {",
          "",
          "[Added Lines]",
          "632:  if (!sec) {",
          "633:   r_list_free (ret);",
          "634:   return NULL;",
          "635:  }",
          "636:  RBuffer *b = bin->buf;",
          "637:  r_buf_seek (b, sec->payload_data, R_IO_SEEK_SET);",
          "638:  ut64 max = b->cur + sec->payload_len - 1;",
          "639:  if (!(max < b->length)) {",
          "640:   goto beach;",
          "641:  }",
          "642:  ut32 r = 0;",
          "643:  while (b->cur <= max && r < sec->count) {",
          "647:   if (!(consume_u7_r (b, max, (ut8*)&ptr->content_type))) {",
          "650:   if (!(consume_u1_r (b, max, &ptr->mutability))) {",
          "653:   if (!(consume_init_expr_r (b, max, R_BIN_WASM_END_OF_CODE, NULL))) {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "623:  }",
          "624:  return ret;",
          "625: beach:",
          "626:  free (ptr);",
          "627:  return ret;",
          "628: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "661:  eprintf(\"err: beach global entries\\n\");",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "634:  if (!(ret = r_list_newf ((RListFree)free))) {",
          "635:   return NULL;",
          "636:  }",
          "645:   if (!(ptr = R_NEW0 (RBinWasmElementEntry))) {",
          "646:    return ret;",
          "647:   }",
          "649:    goto beach;",
          "650:   }",
          "652:    goto beach;",
          "653:   }",
          "655:    goto beach;",
          "656:   }",
          "657:   ut32 j = 0;",
          "664:    }",
          "665:   }",
          "666:   r_list_append (ret, ptr);",
          "669:  }",
          "670:  return ret;",
          "671: beach:",
          "672:  free (ptr);",
          "673:  return ret;",
          "674: }",
          "",
          "[Removed Lines]",
          "638:  ut8* buf = bin->buf->buf + (ut32)sec->payload_data;",
          "639:  int buflen = bin->buf->length - (ut32)sec->payload_data;",
          "640:  ut32 len =  sec->payload_len;",
          "641:  ut32 count = sec->count;",
          "642:  ut32 i = 0, r = 0;",
          "644:  while (i < len && len < buflen && r < count) {",
          "648:   if (!(consume_u32 (buf + i, buf + len, &ptr->index, &i))) {",
          "651:   if (!(consume_init_expr (buf + i, buf + len, R_BIN_WASM_END_OF_CODE, NULL, &i))) {",
          "654:   if (!(consume_u32 (buf + i, buf + len, &ptr->num_elem, &i))) {",
          "658:   while (i < len && j < ptr->num_elem) {",
          "660:    ut32 e;",
          "661:    if (!(consume_u32 (buf + i, buf + len, &e, &i))) {",
          "662:     free (ptr);",
          "663:     return ret;",
          "668:   r += 1;",
          "",
          "[Added Lines]",
          "673:  if (!sec) {",
          "674:   r_list_free (ret);",
          "675:   return NULL;",
          "676:  }",
          "677:  RBuffer *b = bin->buf;",
          "678:  r_buf_seek (b, sec->payload_data, R_IO_SEEK_SET);",
          "679:  ut64 max = b->cur + sec->payload_len - 1;",
          "680:  if (!(max < b->length)) {",
          "681:   goto beach;",
          "682:  }",
          "683:  ut32 r = 0;",
          "684:  while (b->cur <= max && r < sec->count) {",
          "688:   if (!(consume_u32_r (b, max, &ptr->index))) {",
          "691:   if (!(consume_init_expr_r (b, max, R_BIN_WASM_END_OF_CODE, NULL))) {",
          "694:   if (!(consume_u32_r (b, max, &ptr->num_elem))) {",
          "698:   while (b->cur <= max && j < ptr->num_elem) {",
          "700:    if (!(consume_u32_r (b, max, NULL))) {",
          "701:     goto beach;",
          "705:   r++;",
          "709:  eprintf(\"err: beach element entries\\n\");",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "745:  if (bin->g_sections) {",
          "746:   return bin->g_sections;",
          "747:  }",
          "749:  if (!(ret = r_list_newf ((RListFree)free))) {",
          "750:   return NULL;",
          "751:  }",
          "759:   if (!(ptr = R_NEW0 (RBinWasmSection))) {",
          "760:    return ret;",
          "761:   }",
          "765:   }",
          "772:   ptr->count = 0;",
          "775:   switch (ptr->id) {",
          "777:   case R_BIN_WASM_SECTION_CUSTOM:",
          "782:    }",
          "787:    }",
          "789:    break;",
          "791:   case R_BIN_WASM_SECTION_TYPE:",
          "793:    strcpy (ptr->name, \"type\");",
          "794:    ptr->name_len = 4;",
          "795:    break;",
          "797:   case R_BIN_WASM_SECTION_IMPORT:",
          "799:    strcpy (ptr->name, \"import\");",
          "800:    ptr->name_len = 6;",
          "801:    break;",
          "803:   case R_BIN_WASM_SECTION_FUNCTION:",
          "805:    strcpy (ptr->name, \"function\");",
          "806:    ptr->name_len = 8;",
          "807:    break;",
          "809:   case R_BIN_WASM_SECTION_TABLE:",
          "811:    strcpy (ptr->name, \"table\");",
          "812:    ptr->name_len = 5;",
          "813:    break;",
          "815:   case R_BIN_WASM_SECTION_MEMORY:",
          "817:    strcpy (ptr->name, \"memory\");",
          "818:    ptr->name_len = 6;",
          "819:    break;",
          "821:   case R_BIN_WASM_SECTION_GLOBAL:",
          "823:    strcpy (ptr->name, \"global\");",
          "824:    ptr->name_len = 6;",
          "825:    break;",
          "827:   case R_BIN_WASM_SECTION_EXPORT:",
          "829:    strcpy (ptr->name, \"export\");",
          "830:    ptr->name_len = 6;",
          "831:    break;",
          "833:   case R_BIN_WASM_SECTION_START:",
          "835:    strcpy (ptr->name, \"start\");",
          "836:    ptr->name_len = 5;",
          "837:    break;",
          "839:   case R_BIN_WASM_SECTION_ELEMENT:",
          "842:    ptr->name_len = 7;",
          "843:    break;",
          "845:   case R_BIN_WASM_SECTION_CODE:",
          "848:    ptr->name_len = 4;",
          "849:    break;",
          "851:   case R_BIN_WASM_SECTION_DATA:",
          "854:    ptr->name_len = 4;",
          "855:    break;",
          "857:   default:",
          "858:    eprintf(\"unkown section id: %d\\n\", ptr->id);",
          "860:    continue;",
          "862:   }",
          "864:   if (ptr->id != R_BIN_WASM_SECTION_START",
          "865:     && ptr->id != R_BIN_WASM_SECTION_CUSTOM) {",
          "869:    }",
          "871:   }",
          "876:   r_list_append (ret, ptr);",
          "880:  }",
          "882:  bin->g_sections = ret;",
          "884:  return ret;",
          "886: }",
          "888: ut32 r_bin_wasm_get_entrypoint (RBinWasmObj *bin) {",
          "",
          "[Removed Lines]",
          "753:  ut8* buf = bin->buf->buf;",
          "754:  ut32 len = bin->size, i = 8; // skip magic bytes + version",
          "756:  while (i < len) {",
          "763:   if (!(consume_u8 (buf + i, buf + len, &ptr->id, &i))) {",
          "764:    return ret;",
          "767:   if (!(consume_u32 (buf + i, buf + len, &ptr->size, &i))) {",
          "768:    free(ptr);",
          "769:    return NULL;",
          "770:   }",
          "773:   ptr->offset = i;",
          "779:    if (!(consume_u32 (buf + i, buf + len, &ptr->name_len, &i))) {",
          "780:     free(ptr);",
          "781:     return ret;",
          "783:    if (!(consume_str (buf + i, buf + len, ptr->name_len,",
          "784:      ptr->name, &i))) {",
          "785:     free(ptr);",
          "786:     return ret;",
          "841:    strncpy (ptr->name, \"element\", R_BIN_WASM_STRING_LENGTH);",
          "847:    strncpy (ptr->name, \"code\", R_BIN_WASM_STRING_LENGTH);",
          "853:    strncpy (ptr->name, \"data\", R_BIN_WASM_STRING_LENGTH);",
          "859:    i += ptr->size - 1; // next",
          "866:    if (!(consume_u32 (buf + i, buf + len, &ptr->count, &i))) {",
          "867:     free (ptr);",
          "868:     return ret;",
          "873:   ptr->payload_data = i;",
          "874:   ptr->payload_len = ptr->size - (i - ptr->offset);",
          "878:   i += ptr->payload_len; // next",
          "",
          "[Added Lines]",
          "789:  RBuffer *b = bin->buf;",
          "790:  ut64 max = b->length - 1;",
          "791:  r_buf_seek (b, 8, R_IO_SEEK_SET);",
          "792:  while (b->cur <= max) {",
          "796:   if (!(consume_u7_r (b, max, &ptr->id))) {",
          "797:    goto beach;",
          "798:   }",
          "799:   if (!(consume_u32_r (b, max, &ptr->size))) {",
          "800:    goto beach;",
          "801:   }",
          "803:   if (ptr->size < 1) {",
          "804:    goto beach;",
          "807:   }",
          "808:   if (!(b->cur + (ut64)ptr->size - 1 <= max)) {",
          "809:    goto beach;",
          "812:   ptr->offset = b->cur;",
          "815:    eprintf(\"custom section: 0x%x, \", (ut32)b->cur);",
          "816:    if (!(consume_u32_r (b, max, &ptr->name_len))) {",
          "817:     goto beach;",
          "819:    if (consume_str_r (b, max, ptr->name_len, ptr->name) < ptr->name_len) {",
          "820:     goto beach;",
          "822:    eprintf(\"name: %s\\n\", ptr->name);",
          "825:    eprintf(\"section type: 0x%x, \", (ut32)b->cur);",
          "830:    eprintf(\"section import: 0x%x, \", (ut32)b->cur);",
          "835:    eprintf(\"section function: 0x%x, \", (ut32)b->cur);",
          "840:    eprintf(\"section table: 0x%x, \", (ut32)b->cur);",
          "845:    eprintf(\"section memory: 0x%x, \", (ut32)b->cur);",
          "850:    eprintf(\"section global: 0x%x, \", (ut32)b->cur);",
          "855:    eprintf(\"section export: 0x%x, \", (ut32)b->cur);",
          "860:    eprintf(\"section start: 0x%x\\n\", (ut32)b->cur);",
          "865:    eprintf(\"section element: 0x%x, \", (ut32)b->cur);",
          "866:    strcpy (ptr->name, \"element\");",
          "870:    eprintf(\"section code: 0x%x, \", (ut32)b->cur);",
          "871:    strcpy (ptr->name, \"code\");",
          "875:    eprintf(\"section data: 0x%x, \", (ut32)b->cur);",
          "876:    strcpy (ptr->name, \"data\");",
          "881:    r_buf_seek (b, ptr->size - 1, R_IO_SEEK_CUR);",
          "886:    if (!(consume_u32_r (b, max, &ptr->count))) {",
          "887:     goto beach;",
          "889:    eprintf(\"count %d\\n\", ptr->count);",
          "891:   ptr->payload_data = b->cur;",
          "892:   ptr->payload_len = ptr->size - (ptr->payload_data - ptr->offset);",
          "893:   if (ptr->payload_len > ptr->size) {",
          "894:    goto beach;",
          "895:   }",
          "896:   r_buf_seek (b, ptr->payload_len, R_IO_SEEK_CUR);",
          "901: beach:",
          "902:  eprintf(\"err: beach sections\\n\");",
          "903:  free (ptr);",
          "904:  return ret;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "902:  } else if (!(secs = r_bin_wasm_get_sections_by_id (bin->g_sections, R_BIN_WASM_SECTION_START))) {",
          "903:   return 0;",
          "904:  } else if (!(sec = (RBinWasmSection*) r_list_first (secs))) {",
          "905:   return 0;",
          "906:  } else {",
          "907:   start = r_bin_wasm_get_start (bin, sec);",
          "908:   bin->g_start = start;",
          "909:  }",
          "911:  if (!start) {",
          "912:   return 0;",
          "913:  }",
          "917:  return (ut32)func? func->code: 0;",
          "919: }",
          "921: RList *r_bin_wasm_get_imports (RBinWasmObj *bin) {",
          "",
          "[Removed Lines]",
          "916:  func = r_list_get_n (r_bin_wasm_get_codes (bin), start->index);",
          "",
          "[Added Lines]",
          "924:   r_list_free (secs);",
          "931:   r_list_free (secs);",
          "935:  if (!bin->g_codes) {",
          "936:   r_list_free (secs);",
          "937:   return 0;",
          "938:  }",
          "939:  func = r_list_get_n (bin->g_codes, start->index);",
          "940:  r_list_free (secs);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "934:  }",
          "936:  if (!(import = (RBinWasmSection*) r_list_first (imports))) {",
          "937:   return r_list_new();",
          "938:  }",
          "940: }",
          "942: RList *r_bin_wasm_get_exports (RBinWasmObj *bin) {",
          "944:  RBinWasmSection *export = NULL;",
          "945:  RList *exports = NULL;",
          "947:  if (!bin || !bin->g_sections) {",
          "948:   return NULL;",
          "949:  }",
          "951:  if (bin->g_exports) {",
          "952:   return bin->g_exports;",
          "953:  }",
          "955:  if (!(exports= r_bin_wasm_get_sections_by_id (bin->g_sections,",
          "956:       R_BIN_WASM_SECTION_EXPORT))) {",
          "957:   return r_list_new();",
          "958:  }",
          "961:  if (!(export = (RBinWasmSection*) r_list_first (exports))) {",
          "962:   return r_list_new();",
          "963:  }",
          "965:  bin->g_exports = r_bin_wasm_get_export_entries (bin, export);",
          "967:  return bin->g_exports;",
          "968: }",
          "",
          "[Removed Lines]",
          "939:  return bin->g_imports = r_bin_wasm_get_import_entries (bin, import);",
          "",
          "[Added Lines]",
          "960:   r_list_free (imports);",
          "963:  bin->g_imports = r_bin_wasm_get_import_entries (bin, import);",
          "964:  r_list_free (imports);",
          "965:  return bin->g_imports;",
          "984:   r_list_free (exports);",
          "988:  r_list_free (exports);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "974:  if (!bin || !bin->g_sections) {",
          "975:   return NULL;",
          "976:  }",
          "978:  if (bin->g_types) {",
          "979:   return bin->g_types;",
          "980:  }",
          "982:  if (!(types = r_bin_wasm_get_sections_by_id (bin->g_sections,",
          "983:       R_BIN_WASM_SECTION_TYPE))) {",
          "985:  }",
          "988:  if (!(type = (RBinWasmSection*) r_list_first (types))) {",
          "989:   return r_list_new();",
          "990:  }",
          "992:  bin->g_types = r_bin_wasm_get_type_entries (bin, type);",
          "994:  return bin->g_types;",
          "995: }",
          "",
          "[Removed Lines]",
          "984:   return r_list_new();",
          "",
          "[Added Lines]",
          "1004:   return r_list_new ();",
          "1008:   r_list_free (types);",
          "1012:  r_list_free (types);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1044:  if (!(memory = (RBinWasmSection*) r_list_first (memories))) {",
          "1045:   return r_list_new();",
          "1046:  }",
          "1048:  bin->g_memories = r_bin_wasm_get_memory_entries (bin, memory);",
          "1050:  return bin->g_memories;",
          "1051: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1059:   r_list_free (memories);",
          "1064:  r_list_free (memories);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1057:  if (!bin || !bin->g_sections) {",
          "1058:   return NULL;",
          "1059:  }",
          "1061:  if (bin->g_globals) {",
          "1062:   return bin->g_globals;",
          "1063:  }",
          "1065:  if (!(globals = r_bin_wasm_get_sections_by_id (bin->g_sections,",
          "1066:       R_BIN_WASM_SECTION_GLOBAL))) {",
          "1067:   return r_list_new();",
          "1068:  }",
          "1071:  if (!(global = (RBinWasmSection*) r_list_first (globals))) {",
          "1072:   return r_list_new();",
          "1073:  }",
          "1075:  bin->g_globals = r_bin_wasm_get_global_entries (bin, global);",
          "1077:  return bin->g_globals;",
          "1078: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1084:   r_list_free (globals);",
          "1088:  r_list_free (globals);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "1084:  if (!bin || !bin->g_sections) {",
          "1085:   return NULL;",
          "1086:  }",
          "1088:  if (bin->g_elements) {",
          "1089:   return bin->g_elements;",
          "1090:  }",
          "1092:  if (!(elements = r_bin_wasm_get_sections_by_id (bin->g_sections,",
          "1093:       R_BIN_WASM_SECTION_ELEMENT))) {",
          "1094:   return r_list_new();",
          "1095:  }",
          "1098:  if (!(element = (RBinWasmSection*) r_list_first (elements))) {",
          "1099:   return r_list_new();",
          "1100:  }",
          "1102:  bin->g_elements = r_bin_wasm_get_element_entries (bin, element);",
          "1104:  return bin->g_elements;",
          "1105: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1108:   r_list_free (elements);",
          "1112:  r_list_free (elements);",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "1111:  if (!bin || !bin->g_sections) {",
          "1112:   return NULL;",
          "1113:  }",
          "1115:  if (bin->g_codes) {",
          "1116:   return bin->g_codes;",
          "1117:  }",
          "1119:  if (!(codes = r_bin_wasm_get_sections_by_id (bin->g_sections,",
          "1120:       R_BIN_WASM_SECTION_CODE))) {",
          "1122:  }",
          "1125:  if (!(code = (RBinWasmSection*) r_list_first (codes))) {",
          "1126:   return r_list_new();",
          "1127:  }",
          "1129:  bin->g_codes = r_bin_wasm_get_code_entries (bin, code);",
          "1131:  return bin->g_codes;",
          "1132: }",
          "",
          "[Removed Lines]",
          "1121:   return r_list_new();",
          "",
          "[Added Lines]",
          "1128:   return r_list_new ();",
          "1132:   r_list_free (codes);",
          "1136:  r_list_free (codes);",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "1138:  if (!bin || !bin->g_sections) {",
          "1139:   return NULL;",
          "1140:  }",
          "1142:  if (bin->g_datas) {",
          "1143:   return bin->g_datas;",
          "1144:  }",
          "1146:  if (!(datas = r_bin_wasm_get_sections_by_id (bin->g_sections,",
          "1147:       R_BIN_WASM_SECTION_DATA))) {",
          "1148:   return r_list_new();",
          "1149:  }",
          "1152:  if (!(data = (RBinWasmSection*) r_list_first (datas))) {",
          "1153:   return r_list_new();",
          "1154:  }",
          "1156:  bin->g_datas = r_bin_wasm_get_data_entries (bin, data);",
          "1158:  return bin->g_datas;",
          "1159: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1156:   r_list_free (datas);",
          "1160:  r_list_free (datas);",
          "",
          "---------------"
        ],
        "libr/bin/format/wasm/wasm.h||libr/bin/format/wasm/wasm.h": [
          "File: libr/bin/format/wasm/wasm.h -> libr/bin/format/wasm/wasm.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "14: #define R_BIN_WASM_MAGIC_BYTES \"\\x00\" \"asm\"",
          "15: #define R_BIN_WASM_VERSION 0x1",
          "16: #define R_BIN_WASM_STRING_LENGTH 256",
          "18: #define R_BIN_WASM_END_OF_CODE 0xb",
          "20: #define R_BIN_WASM_SECTION_CUSTOM 0x0",
          "",
          "[Removed Lines]",
          "17: #define R_BIN_WASM_MAX_NUM_PARAM 16",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "69:  ut32 payload_data;",
          "70:  ut32 payload_len;",
          "71:  ut32 count;",
          "73: } RBinWasmSection;",
          "75: typedef struct r_bin_wasm_type_t {",
          "76:  ut8 form;",
          "77:  ut32 param_count;",
          "79:  st8 return_count; // MVP = 1",
          "80:  r_bin_wasm_value_type_t return_type;",
          "82: } RBinWasmTypeEntry;",
          "",
          "[Removed Lines]",
          "72:  RList *entries;",
          "78:  r_bin_wasm_value_type_t param_types[R_BIN_WASM_MAX_NUM_PARAM];",
          "81:  char *to_str;",
          "",
          "[Added Lines]",
          "76:  r_bin_wasm_value_type_t *param_types;",
          "79:  char to_str[R_BIN_WASM_STRING_LENGTH];",
          "",
          "---------------"
        ],
        "libr/bin/p/bin_wasm.c||libr/bin/p/bin_wasm.c": [
          "File: libr/bin/p/bin_wasm.c -> libr/bin/p/bin_wasm.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "51: static RList *sections(RBinFile *arch);",
          "53: static RList *entries(RBinFile *arch) {",
          "55:  RBinWasmObj *bin = arch && arch->o ? arch->o->bin_obj : NULL;",
          "60:  ut64 addr = 0x0;",
          "66:  if (!(addr = (ut64) r_bin_wasm_get_entrypoint (bin))) {",
          "67:   return NULL;",
          "68:  }",
          "76: }",
          "78: static RList *sections(RBinFile *arch) {",
          "80:  RBinWasmObj *bin = arch && arch->o ? arch->o->bin_obj : NULL;",
          "82:  RList *ret = NULL;",
          "83:  RList *secs = NULL;",
          "85:  RBinWasmSection *sec;",
          "87:  if (!(ret = r_list_newf ((RListFree)free))) {",
          "88:   return NULL;",
          "89:  }",
          "91:  if (!(secs = r_bin_wasm_get_sections (bin))) {",
          "92:   return NULL;",
          "93:  }",
          "95:  RListIter *iter;",
          "96:  r_list_foreach (secs, iter, sec) {",
          "98:   if (!(ptr = R_NEW0 (RBinSection))) {",
          "99:    break;",
          "100:   }",
          "102:   strncpy (ptr->name, (char*)sec->name, R_BIN_SIZEOF_STRINGS);",
          "103:   if (sec->id == R_BIN_WASM_SECTION_DATA || sec->id == R_BIN_WASM_SECTION_MEMORY) {",
          "104:    ptr->is_data = true;",
          "105:   }",
          "107:   ptr->size = sec->payload_len;",
          "108:   ptr->vsize = sec->payload_len;",
          "109:   ptr->vaddr = sec->offset;",
          "",
          "[Removed Lines]",
          "58:     RList *ret;",
          "59:     RBinAddr *ptr = NULL;",
          "62:     if (!(ret = r_list_newf ((RListFree)free))) {",
          "63:         return NULL;",
          "64:     }",
          "70:     if ((ptr = R_NEW0 (RBinAddr))) {",
          "71:         ptr->paddr = addr;",
          "72:         ptr->vaddr = addr;",
          "73:         r_list_append (ret, ptr);",
          "74:     }",
          "75:     return ret;",
          "84:     RBinSection *ptr = NULL;",
          "",
          "[Added Lines]",
          "54:  RList *ret;",
          "55:  RBinAddr *ptr = NULL;",
          "58:  if (!(ret = r_list_newf ((RListFree)free))) {",
          "59:   return NULL;",
          "60:  }",
          "62:   r_list_free (ret);",
          "65:  if ((ptr = R_NEW0 (RBinAddr))) {",
          "66:   ptr->paddr = addr;",
          "67:   ptr->vaddr = addr;",
          "68:   r_list_append (ret, ptr);",
          "69:  }",
          "70:  return ret;",
          "77:  RBinSection *ptr = NULL;",
          "84:   r_list_free (ret);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "111:   ptr->add = true;",
          "113:   ptr->srwx = 0;",
          "115:   r_list_append (ret, ptr);",
          "117:  }",
          "119:  return ret;",
          "121: }",
          "123: static RList *symbols(RBinFile *arch) {",
          "125:  RBinWasmObj *bin;",
          "129:  if (!arch || !arch->o || !arch->o->bin_obj) {",
          "130:   return NULL;",
          "131:  }",
          "132:  bin = arch->o->bin_obj;",
          "134:  if (!(ret = r_list_newf ((RListFree)free))) {",
          "135:   return NULL;",
          "136:  }",
          "138:  if (!(codes = r_bin_wasm_get_codes (bin))) {",
          "139:   return NULL;",
          "140:  }",
          "142:  if (!(imports = r_bin_wasm_get_imports (bin))) {",
          "143:   return NULL;",
          "144:  }",
          "149:  RBinWasmImportEntry *imp;",
          "150:  r_list_foreach (imports, iter, imp) {",
          "151:   if (!(ptr = R_NEW0 (RBinSymbol))) {",
          "152:    break;",
          "",
          "[Removed Lines]",
          "126:     RList *ret, *codes, *imports;",
          "127:     RBinSymbol *ptr = NULL;",
          "146:  RListIter *iter;",
          "147:  ut32 i = 0;",
          "",
          "[Added Lines]",
          "110:  RList *ret, *codes, *imports;",
          "111:  RBinSymbol *ptr = NULL;",
          "121:   free (ret);",
          "125:   free (ret);",
          "129:  ut32 i = 0;",
          "131:  RListIter *iter;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "207:   return NULL;",
          "208:  }",
          "209:  bin = arch->o->bin_obj;",
          "211:  if (!(ret = r_list_newf (r_bin_import_free))) {",
          "212:   return NULL;",
          "213:  }",
          "215:  if (!(imports = r_bin_wasm_get_imports (bin))) {",
          "216:   r_list_free (ret);",
          "217:   return NULL;",
          "218:  }",
          "221:  RBinWasmImportEntry *import = NULL;",
          "222:  ut32 i = 0;",
          "224:  r_list_foreach (imports, iter, import) {",
          "225:   if (!(ptr = R_NEW0 (RBinImport))) {",
          "226:    break;",
          "",
          "[Removed Lines]",
          "220:  RListIter *iter = NULL;",
          "",
          "[Added Lines]",
          "199:  RListIter *iter;",
          "",
          "---------------"
        ],
        "libr/util/uleb128.c||libr/util/uleb128.c": [
          "File: libr/util/uleb128.c -> libr/util/uleb128.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "109:   offset += 7;",
          "110:  }",
          "111:  while (*p++ & 0x80);",
          "117:  return result;",
          "118: }",
          "",
          "[Removed Lines]",
          "113:    if ((value & 0x40) != 0) {",
          "114:     result |= G_GINT64_CONSTANT (-1) << offset;",
          "115:    }",
          "",
          "[Added Lines]",
          "113:  if ((value & 0x40) != 0) {",
          "114:   result |= G_GINT64_CONSTANT (-1) << offset;",
          "115:  }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "122: #define BYTE_AT(type, i, shift) (((type)(p[i]) & 0x7f) << (shift))",
          "135: #define SHIFT_AMOUNT(type, sign_bit) (sizeof(type) * 8 - 1 - (sign_bit))",
          "136: #define SIGN_EXTEND(type, value, sign_bit) \\",
          "163: }",
          "195: }",
          "233: }",
          "285: }",
          "288: #if 0",
          "289: main() {",
          "",
          "[Removed Lines]",
          "124: #define LEB128_1(type) (BYTE_AT(type, 0, 0))",
          "125: #define LEB128_2(type) (BYTE_AT(type, 1, 7) | LEB128_1(type))",
          "126: #define LEB128_3(type) (BYTE_AT(type, 2, 14) | LEB128_2(type))",
          "127: #define LEB128_4(type) (BYTE_AT(type, 3, 21) | LEB128_3(type))",
          "128: #define LEB128_5(type) (BYTE_AT(type, 4, 28) | LEB128_4(type))",
          "129: #define LEB128_6(type) (BYTE_AT(type, 5, 35) | LEB128_5(type))",
          "130: #define LEB128_7(type) (BYTE_AT(type, 6, 42) | LEB128_6(type))",
          "131: #define LEB128_8(type) (BYTE_AT(type, 7, 49) | LEB128_7(type))",
          "132: #define LEB128_9(type) (BYTE_AT(type, 8, 56) | LEB128_8(type))",
          "133: #define LEB128_10(type) (BYTE_AT(type, 9, 63) | LEB128_9(type))",
          "137:       ((type)((value) << SHIFT_AMOUNT(type, sign_bit)) >> \\",
          "138:           SHIFT_AMOUNT(type, sign_bit))",
          "140: R_API size_t read_u32_leb128(const ut8* p, const ut8* max, ut32* out_value) {",
          "141:     if (p < max && (p[0] & 0x80) == 0) {",
          "143:         return 1;",
          "144:     } else if (p + 1 < max && (p[1] & 0x80) == 0) {",
          "146:         return 2;",
          "147:     } else if (p + 2 < max && (p[2] & 0x80) == 0) {",
          "149:         return 3;",
          "150:     } else if (p + 3 < max && (p[3] & 0x80) == 0) {",
          "152:         return 4;",
          "153:     } else if (p + 4 < max && (p[4] & 0x80) == 0) {",
          "157:         return 5;",
          "158:     } else {",
          "161:         return 0;",
          "162:     }",
          "165: R_API size_t read_i32_leb128(const ut8* p, const ut8* max, st32* out_value) {",
          "166:     if (p < max && (p[0] & 0x80) == 0) {",
          "167:         ut32 result = LEB128_1(ut32);",
          "169:         return 1;",
          "170:     } else if (p + 1 < max && (p[1] & 0x80) == 0) {",
          "171:         ut32 result = LEB128_2(ut32);",
          "173:         return 2;",
          "174:     } else if (p + 2 < max && (p[2] & 0x80) == 0) {",
          "175:         ut32 result = LEB128_3(ut32);",
          "177:         return 3;",
          "178:     } else if (p + 3 < max && (p[3] & 0x80) == 0) {",
          "179:         ut32 result = LEB128_4(ut32);",
          "181:         return 4;",
          "182:     } else if (p+4 < max && (p[4] & 0x80) == 0) {",
          "187:         ut32 result = LEB128_5(ut32);",
          "189:         return 5;",
          "190:     } else {",
          "193:         return 0;",
          "194:     }",
          "197: R_API size_t read_u64_leb128(const ut8* p, const ut8* max, ut64* out_value) {",
          "198:     if (p < max && (p[0] & 0x80) == 0) {",
          "200:         return 1;",
          "201:     } else if (p + 1 < max && (p[1] & 0x80) == 0) {",
          "203:         return 2;",
          "204:     } else if (p + 2 < max && (p[2] & 0x80) == 0) {",
          "206:         return 3;",
          "207:     } else if (p + 3 < max && (p[3] & 0x80) == 0) {",
          "209:         return 4;",
          "210:     } else if (p + 4 < max && (p[4] & 0x80) == 0) {",
          "212:         return 5;",
          "213:     } else if (p + 5 < max && (p[5] & 0x80) == 0) {",
          "215:         return 6;",
          "216:     } else if (p + 6 < max && (p[6] & 0x80) == 0) {",
          "218:         return 7;",
          "219:     } else if (p + 7 < max && (p[7] & 0x80) == 0) {",
          "221:         return 8;",
          "222:     } else if (p + 8 < max && (p[8] & 0x80) == 0) {",
          "224:         return 9;",
          "225:     } else if (p + 9 < max && (p[9] & 0x80) == 0) {",
          "227:         return 10;",
          "228:     } else {",
          "231:         return 0;",
          "232:     }",
          "235: R_API size_t read_i64_leb128(const ut8* p, const ut8* max, st64* out_value) {",
          "236:     if (p < max && (p[0] & 0x80) == 0) {",
          "237:         ut64 result = LEB128_1(ut64);",
          "239:         return 1;",
          "240:     } else if (p + 1 < max && (p[1] & 0x80) == 0) {",
          "241:         ut64 result = LEB128_2(ut64);",
          "243:         return 2;",
          "244:     } else if (p + 2 < max && (p[2] & 0x80) == 0) {",
          "245:         ut64 result = LEB128_3(ut64);",
          "247:         return 3;",
          "248:     } else if (p + 3 < max && (p[3] & 0x80) == 0) {",
          "249:         ut64 result = LEB128_4(ut64);",
          "251:         return 4;",
          "252:     } else if (p + 4 < max && (p[4] & 0x80) == 0) {",
          "253:         ut64 result = LEB128_5(ut64);",
          "255:         return 5;",
          "256:     } else if (p + 5 < max && (p[5] & 0x80) == 0) {",
          "257:         ut64 result = LEB128_6(ut64);",
          "259:         return 6;",
          "260:     } else if (p + 6 < max && (p[6] & 0x80) == 0) {",
          "261:         ut64 result = LEB128_7(ut64);",
          "263:         return 7;",
          "264:     } else if (p + 7 < max && (p[7] & 0x80) == 0) {",
          "265:         ut64 result = LEB128_8(ut64);",
          "267:         return 8;",
          "268:     } else if (p + 8 < max && (p[8] & 0x80) == 0) {",
          "269:         ut64 result = LEB128_9(ut64);",
          "271:         return 9;",
          "272:     } else if (p + 9 < max && (p[9] & 0x80) == 0) {",
          "277:         ut64 result = LEB128_10(ut64);",
          "279:         return 10;",
          "280:     } else {",
          "282:         return 0;",
          "283:     }",
          "",
          "[Added Lines]",
          "124: #define LEB128_1(type) (BYTE_AT (type, 0, 0))",
          "125: #define LEB128_2(type) (BYTE_AT (type, 1, 7) | LEB128_1 (type))",
          "126: #define LEB128_3(type) (BYTE_AT (type, 2, 14) | LEB128_2 (type))",
          "127: #define LEB128_4(type) (BYTE_AT (type, 3, 21) | LEB128_3 (type))",
          "128: #define LEB128_5(type) (BYTE_AT (type, 4, 28) | LEB128_4 (type))",
          "129: #define LEB128_6(type) (BYTE_AT (type, 5, 35) | LEB128_5 (type))",
          "130: #define LEB128_7(type) (BYTE_AT (type, 6, 42) | LEB128_6 (type))",
          "131: #define LEB128_8(type) (BYTE_AT (type, 7, 49) | LEB128_7 (type))",
          "132: #define LEB128_9(type) (BYTE_AT (type, 8, 56) | LEB128_8 (type))",
          "133: #define LEB128_10(type) (BYTE_AT (type, 9, 63) | LEB128_9 (type))",
          "137:  ((type)((value) << SHIFT_AMOUNT (type, sign_bit)) >> \\",
          "138:   SHIFT_AMOUNT (type, sign_bit))",
          "140: R_API size_t read_u32_leb128 (const ut8* p, const ut8* max, ut32* out_value) {",
          "141:  if (p < max && !(p[0] & 0x80)) {",
          "143:   return 1;",
          "144:  } else if (p + 1 < max && !(p[1] & 0x80)) {",
          "146:   return 2;",
          "147:  } else if (p + 2 < max && !(p[2] & 0x80)) {",
          "149:   return 3;",
          "150:  } else if (p + 3 < max && !(p[3] & 0x80)) {",
          "152:   return 4;",
          "153:  } else if (p + 4 < max && !(p[4] & 0x80)) {",
          "157:   return 5;",
          "158:  } else {",
          "161:   return 0;",
          "162:  }",
          "165: R_API size_t read_i32_leb128 (const ut8* p, const ut8* max, st32* out_value) {",
          "166:  if (p < max && !(p[0] & 0x80)) {",
          "167:   ut32 result = LEB128_1 (ut32);",
          "169:   return 1;",
          "170:  } else if (p + 1 < max && !(p[1] & 0x80)) {",
          "171:   ut32 result = LEB128_2 (ut32);",
          "173:   return 2;",
          "174:  } else if (p + 2 < max && !(p[2] & 0x80)) {",
          "175:   ut32 result = LEB128_3 (ut32);",
          "177:   return 3;",
          "178:  } else if (p + 3 < max && !(p[3] & 0x80)) {",
          "179:   ut32 result = LEB128_4 (ut32);",
          "181:   return 4;",
          "182:  } else if (p+4 < max && !(p[4] & 0x80)) {",
          "184:   bool sign_bit_set = (p[4] & 0x8);",
          "185:   int top_bits = p[4] & 0xf0;",
          "186:   if ((sign_bit_set && top_bits != 0x70) || (!sign_bit_set && top_bits != 0)) {",
          "187:    return 0;",
          "188:   }",
          "189:   ut32 result = LEB128_5 (ut32);",
          "191:   return 5;",
          "192:  } else {",
          "194:   return 0;",
          "195:  }",
          "198: R_API size_t read_u64_leb128 (const ut8* p, const ut8* max, ut64* out_value) {",
          "199:  if (p < max && !(p[0] & 0x80)) {",
          "201:   return 1;",
          "202:  } else if (p + 1 < max && !(p[1] & 0x80)) {",
          "204:   return 2;",
          "205:  } else if (p + 2 < max && !(p[2] & 0x80)) {",
          "207:   return 3;",
          "208:  } else if (p + 3 < max && !(p[3] & 0x80)) {",
          "210:   return 4;",
          "211:  } else if (p + 4 < max && !(p[4] & 0x80)) {",
          "213:   return 5;",
          "214:  } else if (p + 5 < max && !(p[5] & 0x80)) {",
          "216:   return 6;",
          "217:  } else if (p + 6 < max && !(p[6] & 0x80)) {",
          "219:   return 7;",
          "220:  } else if (p + 7 < max && !(p[7] & 0x80)) {",
          "222:   return 8;",
          "223:  } else if (p + 8 < max && !(p[8] & 0x80)) {",
          "225:   return 9;",
          "226:  } else if (p + 9 < max && !(p[9] & 0x80)) {",
          "228:   return 10;",
          "229:  } else {",
          "232:   return 0;",
          "233:  }",
          "236: R_API size_t read_i64_leb128 (const ut8* p, const ut8* max, st64* out_value) {",
          "237:  if (p < max && !(p[0] & 0x80)) {",
          "238:   ut64 result = LEB128_1 (ut64);",
          "240:   return 1;",
          "241:  } else if (p + 1 < max && !(p[1] & 0x80)) {",
          "242:   ut64 result = LEB128_2(ut64);",
          "244:   return 2;",
          "245:  } else if (p + 2 < max && !(p[2] & 0x80)) {",
          "246:   ut64 result = LEB128_3 (ut64);",
          "248:   return 3;",
          "249:  } else if (p + 3 < max && !(p[3] & 0x80)) {",
          "250:   ut64 result = LEB128_4 (ut64);",
          "252:   return 4;",
          "253:  } else if (p + 4 < max && !(p[4] & 0x80)) {",
          "254:   ut64 result = LEB128_5 (ut64);",
          "256:   return 5;",
          "257:  } else if (p + 5 < max && !(p[5] & 0x80)) {",
          "258:   ut64 result = LEB128_6 (ut64);",
          "260:   return 6;",
          "261:  } else if (p + 6 < max && !(p[6] & 0x80)) {",
          "262:   ut64 result = LEB128_7 (ut64);",
          "264:   return 7;",
          "265:  } else if (p + 7 < max && !(p[7] & 0x80)) {",
          "266:   ut64 result = LEB128_8 (ut64);",
          "268:   return 8;",
          "269:  } else if (p + 8 < max && !(p[8] & 0x80)) {",
          "270:   ut64 result = LEB128_9 (ut64);",
          "272:   return 9;",
          "273:  } else if (p + 9 < max && !(p[9] & 0x80)) {",
          "275:   bool sign_bit_set = (p[9] & 0x1);",
          "276:   int top_bits = p[9] & 0xfe;",
          "277:   if ((sign_bit_set && top_bits != 0x7e) || (!sign_bit_set && top_bits != 0)) {",
          "278:    return 0;",
          "279:   }",
          "280:   ut64 result = LEB128_10 (ut64);",
          "282:   return 10;",
          "283:  } else {",
          "285:   return 0;",
          "286:  }",
          "289: #undef BYTE_AT",
          "290: #undef LEB128_1",
          "291: #undef LEB128_2",
          "292: #undef LEB128_3",
          "293: #undef LEB128_4",
          "294: #undef LEB128_5",
          "295: #undef LEB128_6",
          "296: #undef LEB128_7",
          "297: #undef LEB128_8",
          "298: #undef LEB128_9",
          "299: #undef LEB128_10",
          "300: #undef SHIFT_AMOUNT",
          "301: #undef SIGN_EXTEND",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b4717e76a7b1ea45f7d35a12229b626bc50a897c",
      "candidate_info": {
        "commit_hash": "b4717e76a7b1ea45f7d35a12229b626bc50a897c",
        "repo": "radare/radare2",
        "commit_url": "https://github.com/radare/radare2/commit/b4717e76a7b1ea45f7d35a12229b626bc50a897c",
        "files": [
          "libr/bin/Jamroot",
          "libr/bin/format/wasm/wasm.c",
          "libr/bin/format/wasm/wasm.h",
          "libr/bin/p/Makefile",
          "libr/bin/p/bin_wasm.c",
          "libr/bin/p/wasm.mk"
        ],
        "message": "WASM bin initial support (#7220)\n\n* WASM bin initial support\n\n* Fix version number",
        "before_after_code_files": [
          "libr/bin/format/wasm/wasm.c||libr/bin/format/wasm/wasm.c",
          "libr/bin/format/wasm/wasm.h||libr/bin/format/wasm/wasm.h",
          "libr/bin/p/bin_wasm.c||libr/bin/p/bin_wasm.c",
          "libr/bin/p/wasm.mk||libr/bin/p/wasm.mk"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libr/bin/format/wasm/wasm.c||libr/bin/format/wasm/wasm.c"
          ],
          "candidate": [
            "libr/bin/format/wasm/wasm.c||libr/bin/format/wasm/wasm.c"
          ]
        }
      },
      "candidate_diff": {
        "libr/bin/format/wasm/wasm.c||libr/bin/format/wasm/wasm.c": [
          "File: libr/bin/format/wasm/wasm.c -> libr/bin/format/wasm/wasm.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: #include <r_types.h>",
          "4: #include <r_util.h>",
          "5: #include <r_lib.h>",
          "6: #include <r_bin.h>",
          "8: #include \"wasm.h\"",
          "11: static size_t consume_u32 (ut8 *buf, ut8 *max, ut32 *out, ut32 *offset) {",
          "12:  size_t n;",
          "13:  if (!buf || !max || !out) return 0;",
          "14:  if (!(n = read_u32_leb128 (buf, max, out)) || n > 5) return 0;",
          "15:  if (offset) *offset += n;",
          "16:  return n;",
          "17: }",
          "18: static size_t consume_s32 (ut8 *buf, ut8 *max, st32 *out, ut32 *offset) {",
          "19:  size_t n;",
          "20:  if (!buf || !max || !out) return 0;",
          "21:  if (!(n = read_i32_leb128 (buf, max, out)) || n > 5) return 0;",
          "22:  if (offset) *offset += n;",
          "23:  return n;",
          "24: }",
          "25: static size_t consume_u8 (ut8 *buf, ut8 *max, ut8 *out, ut32 *offset) {",
          "26:  size_t n;",
          "27:  ut32 tmp;",
          "28:  if (!(n = consume_u32 (buf, max, &tmp, offset)) || n > 1) return 0;",
          "30:  return 1;",
          "31: }",
          "32: static size_t consume_s8 (ut8 *buf, ut8 *max, st8 *out, ut32 *offset) {",
          "33:  size_t n;",
          "34:  ut32 tmp;",
          "35:  if (!(n = consume_u32 (buf, max, &tmp, offset)) || n > 1) return 0;",
          "37:  return 1;",
          "38: }",
          "39: static size_t consume_str (ut8 *buf, ut8 *max, size_t sz, char *out, ut32 *offset) {",
          "40:  if (!buf || !max || !out || !sz) return 0;",
          "41:  if (!(buf + sz < max)) return 0;",
          "42:  strncpy ((char*)out, (char*)buf, R_MIN (R_BIN_WASM_STRING_LENGTH-1, sz));",
          "43:  if (offset) *offset += sz;",
          "44:  return sz;",
          "45: }",
          "46: static size_t consume_init_expr (ut8 *buf, ut8 *max, ut8 eoc, void *out, ut32 *offset) {",
          "47:  ut32 i = 0;",
          "48:  while (buf + i < max && buf[i] != eoc) {",
          "50:   i += 1;",
          "51:  }",
          "52:  if (buf[i] != eoc) return 0;",
          "53:  if (offset) *offset += i + 1;",
          "54:  return i + 1;",
          "55: }",
          "56: static size_t consume_locals (ut8 *buf, ut8 *max, ut32 count, RBinWasmCodeEntry *out, ut32 *offset) {",
          "57:  ut32 i = 0, j = 0;",
          "58:  if (count < 1) return 0;",
          "60:  if (!(out->locals = (struct r_bin_wasm_local_entry_t*) malloc (sizeof(struct r_bin_wasm_local_entry_t) * count))) {",
          "61:   return 0;",
          "62:  }",
          "63:  while (buf + i < max && j < count) {",
          "64:   if (!(consume_u32 (buf + i, max, &out->locals[j].count, &i))) {",
          "65:    free (out->locals);",
          "66:    return 0;",
          "67:   }",
          "69:   if (!(consume_s8 (buf + i, max, (st8*)&out->locals[j].type, &i))) {",
          "70:    free (out->locals);",
          "71:    return 0;",
          "72:   }",
          "73:   j += 1;",
          "74:  }",
          "75:  if (offset) *offset += i;",
          "76:  return j;",
          "77: }",
          "78: static size_t consume_limits (ut8 *buf, ut8 *max, struct r_bin_wasm_resizable_limits_t *out, ut32 *offset) {",
          "79:  ut32 i = 0;",
          "80:  if (!(consume_u8 (buf + i, max, &out->flags, &i))) return 0;",
          "81:  if (!(consume_u32 (buf + i, max, &out->initial, &i))) return 0;",
          "82:  if (out->flags && (!(consume_u32 (buf + i, max, &out->maximum, &i)))) return 0;",
          "83:  if (offset) *offset += i;",
          "84:  return i;",
          "85: }",
          "88: static RList *r_bin_wasm_get_sections_by_id (RList *sections, ut8 id) {",
          "89:  RBinWasmSection *sec = NULL;",
          "90:  RList *ret = NULL;",
          "91:  RListIter *iter = NULL;",
          "94:  if (!(ret = r_list_new ())) {",
          "95:   return NULL;",
          "96:  }",
          "97:  r_list_foreach (sections, iter, sec) {",
          "98:   if (sec->id == id) {",
          "99:    r_list_append(ret, sec);",
          "100:   }",
          "101:  }",
          "102:  return ret;",
          "103: }",
          "105: #define R_BIN_WASM_VALUETYPETOSTRING(p, type, i) {\\",
          "106:  switch(type) {\\",
          "107:  case R_BIN_WASM_VALUETYPE_i32:\\",
          "108:   strncpy(p, \"i32\", 3);\\",
          "109:   break;\\",
          "110:  case R_BIN_WASM_VALUETYPE_i64:\\",
          "111:   strncpy(p, \"i64\", 3);\\",
          "112:   break;\\",
          "113:  case R_BIN_WASM_VALUETYPE_f32:\\",
          "114:   strncpy(p, \"f32\", 3);\\",
          "115:   break;\\",
          "116:  case R_BIN_WASM_VALUETYPE_f64:\\",
          "117:   strncpy(p, \"f64\", 3);\\",
          "118:   break;\\",
          "119:  }\\",
          "120:  i+= 3;\\",
          "121: }",
          "123: static char *r_bin_wasm_type_entry_to_string (RBinWasmTypeEntry *ptr) {",
          "125:  if (!ptr || ptr->to_str) {",
          "126:   return NULL;",
          "127:  }",
          "129:  char *ret;",
          "131:  int i = 0, sz;",
          "133:  sz = (ptr->param_count + ptr->return_count) * 5 + 9;",
          "136:  if (!(ret = (char*) malloc (sz * sizeof(char)))) {",
          "137:   return NULL;",
          "138:  }",
          "140:  strncpy (ret+i, \"(\", 1);",
          "141:  i += 1;",
          "143:  for (int p = 0; p < ptr->param_count; p++ ) {",
          "144:   R_BIN_WASM_VALUETYPETOSTRING (ret+i, ptr->param_types[p], i); // i+=3",
          "145:   if (p < ptr->param_count - 1) {",
          "146:    strncpy (ret+i, \", \", 2);",
          "147:    i += 2;",
          "148:   }",
          "149:  }",
          "151:  strncpy (ret+i, \") -> (\", 6);",
          "152:  i += 6;",
          "154:  if (ptr->return_count == 1) {",
          "155:   R_BIN_WASM_VALUETYPETOSTRING (ret+i, ptr->return_type, i);",
          "156:  }",
          "158:  strncpy(ret+i, \")\", 1);",
          "160:  return ret;",
          "162: }",
          "165: static RList *r_bin_wasm_get_type_entries (RBinWasmObj *bin, RBinWasmSection *sec) {",
          "167:  RList *ret = NULL;",
          "168:  RBinWasmTypeEntry *ptr = NULL;",
          "170:  if (!(ret = r_list_newf ((RListFree)free))) {",
          "171:   return NULL;",
          "172:  }",
          "174:  ut8* buf = bin->buf->buf + (ut32)sec->payload_data;",
          "175:  ut32 len =  sec->payload_len;",
          "176:  ut32 count = sec->count;",
          "177:  ut32 i = 0, r = 0;",
          "179:  while (i < len && r < count) {",
          "180:   if (!(ptr = R_NEW0 (RBinWasmTypeEntry))) {",
          "181:    return ret;",
          "182:   }",
          "184:   if (!(consume_u8 (buf + i, buf + len, &ptr->form, &i))) {",
          "185:    free (ptr);",
          "186:    return ret;",
          "187:   }",
          "189:   if (!(consume_u32 (buf + i, buf + len, &ptr->param_count, &i))) {",
          "190:    free (ptr);",
          "191:    return ret;",
          "192:   }",
          "194:   if (!(i + ptr->param_count < len)) {",
          "195:    free (ptr);",
          "196:    return ret;",
          "197:   }",
          "199:   for (int j = 0; j < ptr->param_count; j++) {",
          "200:    if (!(consume_s8 (buf + i, buf + len, (st8*)&ptr->param_types[j], &i))) {",
          "201:     free (ptr);",
          "202:     return ret;",
          "203:    }",
          "204:   }",
          "206:   if (!(consume_s8 (buf + i, buf + len, &ptr->return_count, &i))) {",
          "207:    free (ptr);",
          "208:    return ret;",
          "209:   }",
          "211:   if (ptr->return_count > 1) {",
          "212:    free(ptr);",
          "213:    return ret;",
          "214:   }",
          "216:   if (ptr->return_count == 1) {",
          "217:    if (!(consume_s8 (buf + i, buf + len, (st8*)&ptr->return_type, &i))) {",
          "218:     free(ptr);",
          "219:     return ret;",
          "220:    }",
          "221:   }",
          "223:   ptr->to_str = r_bin_wasm_type_entry_to_string (ptr);",
          "225:   r_list_append (ret, ptr);",
          "227:   r += 1;",
          "229:  }",
          "231:  return ret;",
          "233: }",
          "235: static RList *r_bin_wasm_get_import_entries (RBinWasmObj *bin, RBinWasmSection *sec) {",
          "237:  RList *ret = NULL;",
          "238:  RBinWasmImportEntry *ptr = NULL;",
          "240:  if (!(ret = r_list_newf ((RListFree)free))) {",
          "241:   return NULL;",
          "242:  }",
          "244:  ut8* buf = bin->buf->buf + (ut32)sec->payload_data;",
          "245:  ut32 len =  sec->payload_len;",
          "246:  ut32 count = sec->count;",
          "247:  ut32 i = 0, r = 0;",
          "249:  while (i < len && r < count) {",
          "251:   if (!(ptr = R_NEW0 (RBinWasmImportEntry))) {",
          "252:    return ret;",
          "253:   }",
          "255:   if (!(consume_u32 (buf + i, buf + len, &ptr->module_len, &i))) {",
          "256:    free (ptr);",
          "257:    return ret;",
          "258:   }",
          "260:   if (!(consume_str (buf + i, buf + len, ptr->module_len,",
          "261:     ptr->module_str, &i))) {",
          "262:    free (ptr);",
          "263:    return ret;",
          "264:   }",
          "266:   if (!(consume_u32 (buf + i, buf + len, &ptr->field_len, &i))) {",
          "267:    free (ptr);",
          "268:    return ret;",
          "269:   }",
          "271:   if (!(consume_str (buf + i, buf + len, ptr->field_len, ptr->field_str, &i))) {",
          "272:    free (ptr);",
          "273:    return ret;",
          "274:   }",
          "276:   if (!(consume_u8 (buf + i, buf + len, &ptr->kind, &i))) {",
          "277:    free (ptr);",
          "278:    return ret;",
          "279:   }",
          "281:   switch (ptr->kind) {",
          "282:   case 0: // Function",
          "283:    if (!(consume_u32 (buf + i, buf + len, &ptr->type_f, &i))) return 0;",
          "284:    break;",
          "285:   case 1: // Table",
          "286:    if (!(consume_u8 (buf + i, buf + len, (ut8*)&ptr->type_t.elem_type, &i))) return 0; // varint7",
          "287:    if (!(consume_limits (buf + i, buf + len, &ptr->type_t.limits, &i))) return 0;",
          "288:    break;",
          "289:   case 2: // Memory",
          "290:    if (!(consume_limits (buf + i, buf + len, &ptr->type_m.limits, &i))) return 0;",
          "291:    break;",
          "292:   case 3: // Global",
          "293:    if (!(consume_u8 (buf + i, buf + len, (ut8*)&ptr->type_g.content_type, &i))) return 0; // varint7",
          "294:    if (!(consume_u8 (buf + i, buf + len, (ut8*)&ptr->type_g.mutability, &i))) return 0; // varuint1",
          "295:    break;",
          "296:   default:",
          "297:    return 0;",
          "298:   }",
          "300:   r_list_append (ret, ptr);",
          "302:   r += 1;",
          "304:  }",
          "306:  return ret;",
          "307: }",
          "309: static RList *r_bin_wasm_get_export_entries (RBinWasmObj *bin, RBinWasmSection *sec) {",
          "311:  RList *ret = NULL;",
          "312:  RBinWasmExportEntry *ptr = NULL;",
          "314:  if (!(ret = r_list_newf ((RListFree)free))) {",
          "315:   return NULL;",
          "316:  }",
          "318:  ut8* buf = bin->buf->buf + (ut32)sec->payload_data;",
          "319:  ut32 len =  sec->payload_len;",
          "320:  ut32 count = sec->count;",
          "321:  ut32 i = 0, r = 0;",
          "323:  while (i < len && r < count) {",
          "325:   if (!(ptr = R_NEW0 (RBinWasmExportEntry))) {",
          "326:    return ret;",
          "327:   }",
          "329:   if (!(consume_u32 (buf + i, buf + len, &ptr->field_len, &i))) {",
          "330:    free (ptr);",
          "331:    return ret;",
          "332:   }",
          "334:   if (!(consume_str (buf + i, buf + len, ptr->field_len, ptr->field_str, &i))) {",
          "335:    free (ptr);",
          "336:    return ret;",
          "337:   }",
          "339:   if (!(consume_u8 (buf + i, buf + len, &ptr->kind, &i))) {",
          "340:    free (ptr);",
          "341:    return ret;",
          "342:   }",
          "344:   if (!(consume_u32 (buf + i, buf + len, &ptr->index, &i))) {",
          "345:    free (ptr);",
          "346:    return ret;",
          "347:   }",
          "349:   r_list_append (ret, ptr);",
          "351:   r += 1;",
          "353:  }",
          "355:  return ret;",
          "356: }",
          "358: static RList *r_bin_wasm_get_code_entries (RBinWasmObj *bin, RBinWasmSection *sec) {",
          "360:  RList *ret = NULL;",
          "361:  RBinWasmCodeEntry *ptr = NULL;",
          "363:  if (!(ret = r_list_newf ((RListFree)free))) {",
          "364:   return NULL;",
          "365:  }",
          "367:  ut8* buf = bin->buf->buf + (ut32)sec->payload_data;",
          "368:  ut32 len =  sec->payload_len;",
          "369:  ut32 count = sec->count;",
          "370:  ut32 i = 0, j = 0, r = 0;",
          "371:  size_t n = 0;",
          "373:  while (i < len && r < count) {",
          "375:   if (!(ptr = R_NEW0 (RBinWasmCodeEntry))) {",
          "376:    return ret;",
          "377:   }",
          "379:   if (!(n = consume_u32 (buf + i, buf + len, &ptr->body_size, &i))) {",
          "380:    free (ptr);",
          "381:    return ret;",
          "382:   }",
          "384:   if (!(i + ptr->body_size - 1 < len)) {",
          "385:    free (ptr);",
          "386:    return ret;",
          "387:   }",
          "389:   j = i;",
          "391:   if (!(n = consume_u32 (buf + i, buf + len, &ptr->local_count, &i))) {",
          "392:    free (ptr);",
          "393:    return ret;",
          "394:   }",
          "396:   if ((n = consume_locals (buf + i, buf + len, ptr->local_count,ptr, &i)) < ptr->local_count) {",
          "397:    free (ptr);",
          "398:    return ret;",
          "399:   }",
          "401:   ptr->code = sec->payload_data + i;",
          "402:   ptr->len = ptr->body_size - (i - j);",
          "404:   i += ptr->len - 1; // consume bytecode",
          "406:   if (!(consume_u8 (buf + i, buf + len, &ptr->byte, &i))) {",
          "407:    free (ptr);",
          "408:    return ret;",
          "409:   }",
          "411:   if (ptr->byte != R_BIN_WASM_END_OF_CODE) {",
          "412:    free (ptr);",
          "413:    return ret;",
          "414:   }",
          "419:   r_list_append (ret, ptr);",
          "421:   r += 1;",
          "423:  }",
          "425:  return ret;",
          "426: }",
          "428: static RList *r_bin_wasm_get_data_entries (RBinWasmObj *bin, RBinWasmSection *sec) {",
          "430:  RList *ret = NULL;",
          "431:  RBinWasmDataEntry *ptr = NULL;",
          "433:  if (!(ret = r_list_newf ((RListFree)free))) {",
          "434:   return NULL;",
          "435:  }",
          "437:  ut8* buf = bin->buf->buf + (ut32)sec->payload_data;",
          "438:  ut32 len =  sec->payload_len;",
          "439:  ut32 count = sec->count;",
          "440:  ut32 i = 0, r = 0;",
          "441:  size_t n = 0;",
          "443:  while (i < len && r < count) {",
          "445:   if (!(ptr = R_NEW0 (RBinWasmDataEntry))) {",
          "446:    return ret;",
          "447:   }",
          "449:   if (!(consume_u32 (buf + i, buf + len, &ptr->index, &i))) {",
          "450:    free (ptr);",
          "451:    return ret;",
          "452:   }",
          "454:   if (!(n = consume_init_expr (buf + i, buf + len, R_BIN_WASM_END_OF_CODE, NULL, &i))) {",
          "455:    free (ptr);",
          "456:    return ret;",
          "457:   }",
          "459:   ptr->offset.len = n;",
          "461:   if (!(consume_u32 (buf + i, buf + len, &ptr->size, &i))) {",
          "462:    free (ptr);",
          "463:    return ret;",
          "464:   }",
          "466:   ptr->data = sec->payload_data + i;",
          "468:   r_list_append (ret, ptr);",
          "470:   r += 1;",
          "472:  }",
          "474:  return ret;",
          "475: }",
          "477: static RBinWasmStartEntry *r_bin_wasm_get_start (RBinWasmObj *bin, RBinWasmSection *sec) {",
          "479:  RBinWasmStartEntry *ptr;",
          "481:  if (!(ptr = R_NEW0 (RBinWasmStartEntry))) {",
          "482:   return NULL;",
          "483:  }",
          "485:  ut8* buf = bin->buf->buf + (ut32)sec->payload_data;",
          "486:  ut32 len =  sec->payload_len;",
          "487:  ut32 i = 0;",
          "489:  if (!(consume_u32 (buf + i, buf + len, &ptr->index, &i))) {",
          "490:   free (ptr);",
          "491:   return NULL;",
          "492:  }",
          "494:  return ptr;",
          "496: }",
          "498: static RList *r_bin_wasm_get_memory_entries (RBinWasmObj *bin, RBinWasmSection *sec) {",
          "500:  RList *ret = NULL;",
          "501:  RBinWasmMemoryEntry *ptr = NULL;",
          "503:  if (!(ret = r_list_newf ((RListFree)free))) {",
          "504:   return NULL;",
          "505:  }",
          "507:  ut8* buf = bin->buf->buf + (ut32)sec->payload_data;",
          "508:  ut32 len =  sec->payload_len;",
          "509:  ut32 count = sec->count;",
          "510:  ut32 i = 0, r = 0;",
          "512:  while (i < len && r < count) {",
          "514:   if (!(ptr = R_NEW0 (RBinWasmMemoryEntry))) {",
          "515:    return ret;",
          "516:   }",
          "518:   if (!(consume_limits (buf + i, buf + len, &ptr->limits, &i))) {",
          "519:    free (ptr);",
          "520:    return ret;",
          "521:   }",
          "523:   r_list_append (ret, ptr);",
          "525:   r += 1;",
          "527:  }",
          "529:  return ret;",
          "530: }",
          "532: static RList *r_bin_wasm_get_table_entries (RBinWasmObj *bin, RBinWasmSection *sec) {",
          "534:  RList *ret = NULL;",
          "535:  RBinWasmTableEntry *ptr = NULL;",
          "537:  if (!(ret = r_list_newf ((RListFree)free))) {",
          "538:   return NULL;",
          "539:  }",
          "541:  ut8* buf = bin->buf->buf + (ut32)sec->payload_data;",
          "542:  ut32 len =  sec->payload_len;",
          "543:  ut32 count = sec->count;",
          "544:  ut32 i = 0, r = 0;",
          "546:  while (i < len && r < count) {",
          "548:   if (!(ptr = R_NEW0 (RBinWasmTableEntry))) {",
          "549:    return ret;",
          "550:   }",
          "552:   if (!(consume_u8 (buf + i, buf + len, &ptr->element_type, &i))) {",
          "553:    free (ptr);",
          "554:    return ret;",
          "555:   }",
          "557:   if (!(consume_limits (buf + i, buf + len, &ptr->limits, &i))) {",
          "558:    free (ptr);",
          "559:    return ret;",
          "560:   }",
          "562:   r_list_append (ret, ptr);",
          "564:   r += 1;",
          "566:  }",
          "568:  return ret;",
          "569: }",
          "571: static RList *r_bin_wasm_get_global_entries (RBinWasmObj *bin, RBinWasmSection *sec) {",
          "573:  RList *ret = NULL;",
          "574:  RBinWasmGlobalEntry *ptr = NULL;",
          "576:  if (!(ret = r_list_newf ((RListFree)free))) {",
          "577:   return NULL;",
          "578:  }",
          "580:  ut8* buf = bin->buf->buf + (ut32)sec->payload_data;",
          "581:  ut32 len =  sec->payload_len;",
          "582:  ut32 count = sec->count;",
          "583:  ut32 i = 0, r = 0;",
          "585:  while (i < len && r < count) {",
          "587:   if (!(ptr = R_NEW0 (RBinWasmGlobalEntry))) {",
          "588:    return ret;",
          "589:   }",
          "591:   if (!(consume_u8 (buf + i, buf + len, (ut8*)&ptr->content_type, &i))) {",
          "592:    free (ptr);",
          "593:    return ret;",
          "594:   }",
          "596:   if (!(consume_u8 (buf + i, buf + len, &ptr->mutability, &i))) {",
          "597:    free (ptr);",
          "598:    return ret;",
          "599:   }",
          "601:   if (!(consume_init_expr (buf + i, buf + len, R_BIN_WASM_END_OF_CODE, NULL, &i))) {",
          "602:    free (ptr);",
          "603:    return ret;",
          "604:   }",
          "606:   r_list_append (ret, ptr);",
          "608:   r += 1;",
          "610:  }",
          "612:  return ret;",
          "613: }",
          "615: static RList *r_bin_wasm_get_element_entries (RBinWasmObj *bin, RBinWasmSection *sec) {",
          "617:  RList *ret = NULL;",
          "618:  RBinWasmElementEntry *ptr = NULL;",
          "620:  if (!(ret = r_list_newf ((RListFree)free))) {",
          "621:   return NULL;",
          "622:  }",
          "624:  ut8* buf = bin->buf->buf + (ut32)sec->payload_data;",
          "625:  ut32 len =  sec->payload_len;",
          "626:  ut32 count = sec->count;",
          "627:  ut32 i = 0, r = 0;",
          "629:  while (i < len && r < count) {",
          "631:   if (!(ptr = R_NEW0 (RBinWasmElementEntry))) {",
          "632:    return ret;",
          "633:   }",
          "635:   if (!(consume_u32 (buf + i, buf + len, &ptr->index, &i))) {",
          "636:    free (ptr);",
          "637:    return ret;",
          "638:   }",
          "640:   if (!(consume_init_expr (buf + i, buf + len, R_BIN_WASM_END_OF_CODE, NULL, &i))) {",
          "641:    free (ptr);",
          "642:    return ret;",
          "643:   }",
          "645:   if (!(consume_u32 (buf + i, buf + len, &ptr->num_elem, &i))) {",
          "646:    free (ptr);",
          "647:    return ret;",
          "648:   }",
          "650:   ut32 j = 0;",
          "651:   while (i < len && j < ptr->num_elem ) {",
          "653:    ut32 e;",
          "654:    if (!(consume_u32 (buf + i, buf + len, &e, &i))) {",
          "655:     free (ptr);",
          "656:     return ret;",
          "657:    }",
          "658:   }",
          "660:   r_list_append (ret, ptr);",
          "662:   r += 1;",
          "664:  }",
          "666:  return ret;",
          "667: }",
          "669: RBinWasmObj *r_bin_wasm_init (RBinFile *arch) {",
          "671:  RBinWasmObj *bin = R_NEW0 (RBinWasmObj);",
          "672:  if (!bin) {",
          "673:   return NULL;",
          "674:  }",
          "675:  if (!(bin->buf = r_buf_new ())) {",
          "676:   free (bin);",
          "677:   return NULL;",
          "678:  }",
          "679:  bin->size = (ut32)arch->buf->length;",
          "680:  if (!r_buf_set_bytes (bin->buf, arch->buf->buf, bin->size)) {",
          "681:   r_bin_wasm_destroy (arch);",
          "682:   return NULL;",
          "683:  }",
          "685:  bin->g_sections = r_bin_wasm_get_sections (bin);",
          "689:  bin->g_types = r_bin_wasm_get_types (bin);",
          "690:  bin->g_imports = r_bin_wasm_get_imports (bin);",
          "691:  bin->g_exports = r_bin_wasm_get_exports (bin);",
          "692:  bin->g_tables = r_bin_wasm_get_tables (bin);",
          "693:  bin->g_memories= r_bin_wasm_get_memories (bin);",
          "694:  bin->g_globals = r_bin_wasm_get_globals (bin);",
          "695:  bin->g_codes = r_bin_wasm_get_codes (bin);",
          "696:  bin->g_datas = r_bin_wasm_get_datas (bin);",
          "699:  bin->entrypoint = r_bin_wasm_get_entrypoint (bin);",
          "701:  return bin;",
          "703: }",
          "705: void r_bin_wasm_destroy (RBinFile *arch) {",
          "707:  RBinWasmObj *bin;",
          "709:  if (!arch || !arch->o || !arch->o->bin_obj) {",
          "710:   return;",
          "711:  }",
          "713:  bin = arch->o->bin_obj;",
          "714:  r_buf_free (bin->buf);",
          "716:  r_list_free (bin->g_sections);",
          "717:  r_list_free (bin->g_types);",
          "719:  r_list_free (bin->g_imports);",
          "720:  r_list_free (bin->g_exports);",
          "721:  r_list_free (bin->g_tables);",
          "722:  r_list_free (bin->g_memories);",
          "723:  r_list_free (bin->g_globals);",
          "724:  r_list_free (bin->g_codes);",
          "725:  r_list_free (bin->g_datas);",
          "727:  free (bin->g_start);",
          "728:  free (bin);",
          "729:  arch->o->bin_obj = NULL;",
          "731: }",
          "733: RList *r_bin_wasm_get_sections (RBinWasmObj *bin) {",
          "735:  RList *ret = NULL;",
          "736:  RBinWasmSection *ptr = NULL;",
          "738:  if (!bin) {",
          "739:   return NULL;",
          "740:  }",
          "741:  if (bin->g_sections) {",
          "742:   return bin->g_sections;",
          "743:  }",
          "745:  if (!(ret = r_list_newf ((RListFree)free))) {",
          "746:   return NULL;",
          "747:  }",
          "749:  ut8* buf = bin->buf->buf;",
          "750:  ut32 len = bin->size, i = 8; // skip magic bytes + version",
          "752:  while (i < len) {",
          "755:   if (!(ptr = R_NEW0 (RBinWasmSection))) {",
          "756:    return ret;",
          "757:   }",
          "759:   if (!(consume_u8 (buf + i, buf + len, &ptr->id, &i))) {",
          "760:    return ret;",
          "761:   }",
          "763:   if (!(consume_u32 (buf + i, buf + len, &ptr->size, &i))) {",
          "764:    free(ptr);",
          "765:    return NULL;",
          "766:   }",
          "768:   ptr->count = 0;",
          "769:   ptr->offset = i;",
          "771:   switch (ptr->id) {",
          "773:   case R_BIN_WASM_SECTION_CUSTOM:",
          "775:    if (!(consume_u32 (buf + i, buf + len, &ptr->name_len, &i))) {",
          "776:     free(ptr);",
          "777:     return ret;",
          "778:    }",
          "779:    if (!(consume_str (buf + i, buf + len, ptr->name_len,",
          "780:      ptr->name, &i))) {",
          "781:     free(ptr);",
          "782:     return ret;",
          "783:    }",
          "785:    break;",
          "787:   case R_BIN_WASM_SECTION_TYPE:",
          "789:    strncpy (ptr->name, \"type\", R_BIN_WASM_STRING_LENGTH);",
          "790:    ptr->name_len = 4;",
          "791:    break;",
          "793:   case R_BIN_WASM_SECTION_IMPORT:",
          "795:    strncpy (ptr->name, \"import\", R_BIN_WASM_STRING_LENGTH);",
          "796:    ptr->name_len = 6;",
          "797:    break;",
          "799:   case R_BIN_WASM_SECTION_FUNCTION:",
          "801:    strncpy (ptr->name, \"function\", R_BIN_WASM_STRING_LENGTH);",
          "802:    ptr->name_len = 8;",
          "803:    break;",
          "805:   case R_BIN_WASM_SECTION_TABLE:",
          "807:    strncpy (ptr->name, \"table\", R_BIN_WASM_STRING_LENGTH);",
          "808:    ptr->name_len = 5;",
          "809:    break;",
          "811:   case R_BIN_WASM_SECTION_MEMORY:",
          "813:    strncpy (ptr->name, \"memory\", R_BIN_WASM_STRING_LENGTH);",
          "814:    ptr->name_len = 6;",
          "815:    break;",
          "817:   case R_BIN_WASM_SECTION_GLOBAL:",
          "819:    strncpy (ptr->name, \"global\", R_BIN_WASM_STRING_LENGTH);",
          "820:    ptr->name_len = 6;",
          "821:    break;",
          "823:   case R_BIN_WASM_SECTION_EXPORT:",
          "825:    strncpy (ptr->name, \"export\", R_BIN_WASM_STRING_LENGTH);",
          "826:    ptr->name_len = 6;",
          "827:    break;",
          "829:   case R_BIN_WASM_SECTION_START:",
          "831:    strncpy (ptr->name, \"start\", R_BIN_WASM_STRING_LENGTH);",
          "832:    ptr->name_len = 5;",
          "833:    break;",
          "835:   case R_BIN_WASM_SECTION_ELEMENT:",
          "837:    strncpy (ptr->name, \"element\", R_BIN_WASM_STRING_LENGTH);",
          "838:    ptr->name_len = 7;",
          "839:    break;",
          "841:   case R_BIN_WASM_SECTION_CODE:",
          "843:    strncpy (ptr->name, \"code\", R_BIN_WASM_STRING_LENGTH);",
          "844:    ptr->name_len = 4;",
          "845:    break;",
          "847:   case R_BIN_WASM_SECTION_DATA:",
          "849:    strncpy (ptr->name, \"data\", R_BIN_WASM_STRING_LENGTH);",
          "850:    ptr->name_len = 4;",
          "851:    break;",
          "853:   default:",
          "854:    eprintf(\"unkown section id: %d\\n\", ptr->id);",
          "855:    i += ptr->size - 1; // next",
          "856:    continue;",
          "858:   }",
          "860:   if (ptr->id != R_BIN_WASM_SECTION_START",
          "861:     && ptr->id != R_BIN_WASM_SECTION_CUSTOM) {",
          "862:    if (!(consume_u32 (buf + i, buf + len, &ptr->count, &i))) {",
          "863:     free (ptr);",
          "864:     return ret;",
          "865:    }",
          "867:   }",
          "869:   ptr->payload_data = i;",
          "870:   ptr->payload_len = ptr->size - (i - ptr->offset);",
          "872:   r_list_append (ret, ptr);",
          "874:   i += ptr->payload_len; // next",
          "876:  }",
          "878:  bin->g_sections = ret;",
          "880:  return ret;",
          "882: }",
          "884: ut32 r_bin_wasm_get_entrypoint (RBinWasmObj *bin) {",
          "886:  RList *secs = NULL;",
          "887:  RBinWasmStartEntry *start = NULL;",
          "888:  RBinWasmSection *sec = NULL;",
          "889:  RBinWasmCodeEntry *func = NULL;",
          "891:  if (!bin || !bin->g_sections) {",
          "892:   return 0x0;",
          "893:  }",
          "895:  if (bin->entrypoint) {",
          "896:   return bin->entrypoint;",
          "897:  }",
          "899:  if (bin->g_start) {",
          "900:   start = bin->g_start;",
          "901:  } else if (!(secs = r_bin_wasm_get_sections_by_id (bin->g_sections,",
          "902:        R_BIN_WASM_SECTION_START))) {",
          "903:   return 0x0;",
          "904:  } else if (!(sec = (RBinWasmSection*) r_list_first (secs))) {",
          "905:   return 0x0;",
          "906:  } else {",
          "907:   start = r_bin_wasm_get_start (bin, sec);",
          "908:   bin->g_start = start;",
          "909:  }",
          "911:  if (!start) {",
          "912:   return 0x0;",
          "913:  }",
          "916:  func = r_list_get_n (r_bin_wasm_get_codes (bin), start->index);",
          "917:  if (!func) {",
          "918:   return 0x0;",
          "919:  }",
          "921:  return (ut32)func->code;",
          "923: }",
          "925: RList *r_bin_wasm_get_imports (RBinWasmObj *bin) {",
          "927:  RBinWasmSection *import = NULL;",
          "928:  RList *imports = NULL;",
          "930:  if (!bin || !bin->g_sections) {",
          "931:   return NULL;",
          "932:  }",
          "934:  if (bin->g_imports) {",
          "935:   return bin->g_imports;",
          "936:  }",
          "938:  if (!(imports = r_bin_wasm_get_sections_by_id (bin->g_sections,",
          "939:       R_BIN_WASM_SECTION_IMPORT))) {",
          "940:   return r_list_new();",
          "941:  }",
          "944:  if (!(import = (RBinWasmSection*) r_list_first (imports))) {",
          "945:   return r_list_new();",
          "946:  }",
          "948:  bin->g_imports = r_bin_wasm_get_import_entries (bin, import);",
          "950:  return bin->g_imports;",
          "952: }",
          "954: RList *r_bin_wasm_get_exports (RBinWasmObj *bin) {",
          "956:  RBinWasmSection *export = NULL;",
          "957:  RList *exports = NULL;",
          "959:  if (!bin || !bin->g_sections) {",
          "960:   return NULL;",
          "961:  }",
          "963:  if (bin->g_exports) {",
          "964:   return bin->g_exports;",
          "965:  }",
          "967:  if (!(exports= r_bin_wasm_get_sections_by_id (bin->g_sections,",
          "968:       R_BIN_WASM_SECTION_EXPORT))) {",
          "969:   return r_list_new();",
          "970:  }",
          "973:  if (!(export = (RBinWasmSection*) r_list_first (exports))) {",
          "974:   return r_list_new();",
          "975:  }",
          "977:  bin->g_exports = r_bin_wasm_get_export_entries (bin, export);",
          "979:  return bin->g_exports;",
          "981: }",
          "983: RList *r_bin_wasm_get_types (RBinWasmObj *bin) {",
          "985:  RBinWasmSection *type = NULL;",
          "986:  RList *types = NULL;",
          "988:  if (!bin || !bin->g_sections) {",
          "989:   return NULL;",
          "990:  }",
          "992:  if (bin->g_types) {",
          "993:   return bin->g_types;",
          "994:  }",
          "996:  if (!(types = r_bin_wasm_get_sections_by_id (bin->g_sections,",
          "997:       R_BIN_WASM_SECTION_TYPE))) {",
          "998:   return r_list_new();",
          "999:  }",
          "1002:  if (!(type = (RBinWasmSection*) r_list_first (types))) {",
          "1003:   return r_list_new();",
          "1004:  }",
          "1006:  bin->g_types = r_bin_wasm_get_type_entries (bin, type);",
          "1008:  return bin->g_types;",
          "1010: }",
          "1012: RList *r_bin_wasm_get_tables (RBinWasmObj *bin) {",
          "1014:  RBinWasmSection *table = NULL;",
          "1015:  RList *tables = NULL;",
          "1017:  if (!bin || !bin->g_sections) {",
          "1018:   return NULL;",
          "1019:  }",
          "1021:  if (bin->g_tables) {",
          "1022:   return bin->g_tables;",
          "1023:  }",
          "1025:  if (!(tables = r_bin_wasm_get_sections_by_id (bin->g_sections,",
          "1026:       R_BIN_WASM_SECTION_TABLE))) {",
          "1027:   return r_list_new();",
          "1028:  }",
          "1031:  if (!(table = (RBinWasmSection*) r_list_first (tables))) {",
          "1032:   return r_list_new();",
          "1033:  }",
          "1035:  bin->g_tables = r_bin_wasm_get_table_entries (bin, table);",
          "1037:  return bin->g_tables;",
          "1039: }",
          "1041: RList *r_bin_wasm_get_memories (RBinWasmObj *bin) {",
          "1043:  RBinWasmSection *memory;",
          "1044:  RList *memories;",
          "1046:  if (!bin || !bin->g_sections) {",
          "1047:   return NULL;",
          "1048:  }",
          "1050:  if (bin->g_memories) {",
          "1051:   return bin->g_memories;",
          "1052:  }",
          "1054:  if (!(memories = r_bin_wasm_get_sections_by_id (bin->g_sections,",
          "1055:       R_BIN_WASM_SECTION_MEMORY))) {",
          "1056:   return r_list_new();",
          "1057:  }",
          "1060:  if (!(memory = (RBinWasmSection*) r_list_first (memories))) {",
          "1061:   return r_list_new();",
          "1062:  }",
          "1064:  bin->g_memories = r_bin_wasm_get_memory_entries (bin, memory);",
          "1066:  return bin->g_memories;",
          "1068: }",
          "1070: RList *r_bin_wasm_get_globals (RBinWasmObj *bin) {",
          "1072:  RBinWasmSection *global = NULL;",
          "1073:  RList *globals = NULL;",
          "1075:  if (!bin || !bin->g_sections) {",
          "1076:   return NULL;",
          "1077:  }",
          "1079:  if (bin->g_globals) {",
          "1080:   return bin->g_globals;",
          "1081:  }",
          "1083:  if (!(globals = r_bin_wasm_get_sections_by_id (bin->g_sections,",
          "1084:       R_BIN_WASM_SECTION_GLOBAL))) {",
          "1085:   return r_list_new();",
          "1086:  }",
          "1089:  if (!(global = (RBinWasmSection*) r_list_first (globals))) {",
          "1090:   return r_list_new();",
          "1091:  }",
          "1093:  bin->g_globals = r_bin_wasm_get_global_entries (bin, global);",
          "1095:  return bin->g_globals;",
          "1097: }",
          "1099: RList *r_bin_wasm_get_elements (RBinWasmObj *bin) {",
          "1101:  RBinWasmSection *element = NULL;",
          "1102:  RList *elements = NULL;",
          "1104:  if (!bin || !bin->g_sections) {",
          "1105:   return NULL;",
          "1106:  }",
          "1108:  if (bin->g_elements) {",
          "1109:   return bin->g_elements;",
          "1110:  }",
          "1112:  if (!(elements = r_bin_wasm_get_sections_by_id (bin->g_sections,",
          "1113:       R_BIN_WASM_SECTION_ELEMENT))) {",
          "1114:   return r_list_new();",
          "1115:  }",
          "1118:  if (!(element = (RBinWasmSection*) r_list_first (elements))) {",
          "1119:   return r_list_new();",
          "1120:  }",
          "1122:  bin->g_elements = r_bin_wasm_get_element_entries (bin, element);",
          "1124:  return bin->g_elements;",
          "1126: }",
          "1128: RList *r_bin_wasm_get_codes (RBinWasmObj *bin) {",
          "1130:  RBinWasmSection *code = NULL;;",
          "1131:  RList *codes = NULL;",
          "1133:  if (!bin || !bin->g_sections) {",
          "1134:   return NULL;",
          "1135:  }",
          "1137:  if (bin->g_codes) {",
          "1138:   return bin->g_codes;",
          "1139:  }",
          "1141:  if (!(codes = r_bin_wasm_get_sections_by_id (bin->g_sections,",
          "1142:       R_BIN_WASM_SECTION_CODE))) {",
          "1143:   return r_list_new();",
          "1144:  }",
          "1147:  if (!(code = (RBinWasmSection*) r_list_first (codes))) {",
          "1148:   return r_list_new();",
          "1149:  }",
          "1151:  bin->g_codes = r_bin_wasm_get_code_entries (bin, code);",
          "1153:  return bin->g_codes;",
          "1155: }",
          "1157: RList *r_bin_wasm_get_datas (RBinWasmObj *bin) {",
          "1159:  RBinWasmSection *data = NULL;",
          "1160:  RList *datas = NULL;",
          "1162:  if (!bin || !bin->g_sections) {",
          "1163:   return NULL;",
          "1164:  }",
          "1166:  if (bin->g_datas) {",
          "1167:   return bin->g_datas;",
          "1168:  }",
          "1170:  if (!(datas = r_bin_wasm_get_sections_by_id (bin->g_sections,",
          "1171:       R_BIN_WASM_SECTION_DATA))) {",
          "1172:   return r_list_new();",
          "1173:  }",
          "1176:  if (!(data = (RBinWasmSection*) r_list_first (datas))) {",
          "1177:   return r_list_new();",
          "1178:  }",
          "1180:  bin->g_datas = r_bin_wasm_get_data_entries (bin, data);",
          "1182:  return bin->g_datas;",
          "1184: }",
          "",
          "---------------"
        ],
        "libr/bin/format/wasm/wasm.h||libr/bin/format/wasm/wasm.h": [
          "File: libr/bin/format/wasm/wasm.h -> libr/bin/format/wasm/wasm.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: #include <r_types.h>",
          "4: #include <r_util.h>",
          "5: #include <r_lib.h>",
          "6: #include <r_bin.h>",
          "8: #ifndef _INCLUDE_WASM_H_",
          "9: #define _INCLUDE_WASM_H_",
          "14: #define R_BIN_WASM_MAGIC_BYTES \"\\x00\" \"asm\"",
          "15: #define R_BIN_WASM_VERSION 0x1",
          "16: #define R_BIN_WASM_STRING_LENGTH 256",
          "17: #define R_BIN_WASM_MAX_NUM_PARAM 16",
          "18: #define R_BIN_WASM_END_OF_CODE 0xb",
          "20: #define R_BIN_WASM_SECTION_CUSTOM 0x0",
          "21: #define R_BIN_WASM_SECTION_TYPE 0x1",
          "22: #define R_BIN_WASM_SECTION_IMPORT 0x2",
          "23: #define R_BIN_WASM_SECTION_FUNCTION 0x3",
          "24: #define R_BIN_WASM_SECTION_TABLE 0x4",
          "25: #define R_BIN_WASM_SECTION_MEMORY 0x5",
          "26: #define R_BIN_WASM_SECTION_GLOBAL 0x6",
          "27: #define R_BIN_WASM_SECTION_EXPORT 0x7",
          "28: #define R_BIN_WASM_SECTION_START 0x8",
          "29: #define R_BIN_WASM_SECTION_ELEMENT 0x9",
          "30: #define R_BIN_WASM_SECTION_CODE 0xa",
          "31: #define R_BIN_WASM_SECTION_DATA 0xb",
          "33: typedef enum {",
          "34:  R_BIN_WASM_VALUETYPE_i32 = 0x7f,",
          "35:  R_BIN_WASM_VALUETYPE_i64 = 0x7e,",
          "36:  R_BIN_WASM_VALUETYPE_f32 = 0x7d,",
          "37:  R_BIN_WASM_VALUETYPE_f64 = 0x7c,",
          "38: } r_bin_wasm_value_type_t;",
          "40: typedef enum {",
          "41:  R_BIN_WASM_EXTERNALKIND_Function = 0x0,",
          "42:  R_BIN_WASM_EXTERNALKIND_Table = 0x1,",
          "43:  R_BIN_WASM_EXTERNALKIND_Memory = 0x2,",
          "44:  R_BIN_WASM_EXTERNALKIND_Global = 0x3,",
          "45: } r_bin_wasm_external_kind_t;",
          "47: typedef enum {",
          "48:  R_BIN_WASM_NAMETYPE_Function = 0x1,",
          "49:  R_BIN_WASM_NAMETYPELocal = 0x2,",
          "50: } r_bin_wasm_name_type_t;",
          "52: struct r_bin_wasm_init_expr_t {",
          "54:  size_t len;",
          "55: };",
          "57: struct r_bin_wasm_resizable_limits_t {",
          "58:  ut8 flags; // 1 if max field is present, 0 otherwise",
          "59:  ut32 initial;",
          "60:  ut32 maximum;",
          "61: };",
          "63: typedef struct r_bin_wasm_section_t {",
          "64:  ut8 id;",
          "65:  ut32 size;",
          "66:  ut32 name_len;",
          "67:  char name[R_BIN_WASM_STRING_LENGTH];",
          "68:  ut32 offset;",
          "69:  ut32 payload_data;",
          "70:  ut32 payload_len;",
          "71:  ut32 count;",
          "72:  RList *entries;",
          "73: } RBinWasmSection;",
          "75: typedef struct r_bin_wasm_type_t {",
          "76:  ut8 form;",
          "77:  ut32 param_count;",
          "78:  r_bin_wasm_value_type_t param_types[R_BIN_WASM_MAX_NUM_PARAM];",
          "79:  st8 return_count; // MVP = 1",
          "80:  r_bin_wasm_value_type_t return_type;",
          "81:  char *to_str;",
          "82: } RBinWasmTypeEntry;",
          "85: struct r_bin_wasm_global_type_t {",
          "86:  r_bin_wasm_value_type_t content_type;",
          "87:  ut8 mutability;",
          "88: };",
          "90: struct r_bin_wasm_table_type_t {",
          "91:  r_bin_wasm_value_type_t elem_type;",
          "92:  struct r_bin_wasm_resizable_limits_t limits;",
          "93: };",
          "95: struct r_bin_wasm_memory_type_t {",
          "96:  struct r_bin_wasm_resizable_limits_t limits;",
          "97: };",
          "101: typedef struct r_bin_wasm_import_t {",
          "102:  ut32 module_len;",
          "103:  char module_str[R_BIN_WASM_STRING_LENGTH];",
          "104:  ut32 field_len;",
          "105:  char field_str[R_BIN_WASM_STRING_LENGTH];",
          "106:  ut8 kind;",
          "107:  union {",
          "108:   ut32 type_f;",
          "109:   struct r_bin_wasm_global_type_t type_g;",
          "110:   struct r_bin_wasm_table_type_t type_t;",
          "111:   struct r_bin_wasm_memory_type_t type_m;",
          "112:  };",
          "114: } RBinWasmImportEntry;",
          "116: typedef struct r_bin_wasm_function_t {",
          "117:  ut32 type_index; // index to Type entries",
          "118: } RBinWasmFunctionEntry;",
          "120: typedef struct r_bin_wasm_table_t {",
          "121:  ut8 element_type; // only anyfunc",
          "122:  struct r_bin_wasm_resizable_limits_t limits;",
          "123: } RBinWasmTableEntry;",
          "125: typedef struct r_bin_wasm_memory_t {",
          "126:  struct r_bin_wasm_resizable_limits_t limits;",
          "127: } RBinWasmMemoryEntry;",
          "129: typedef struct r_bin_wasm_global_t {",
          "130:  r_bin_wasm_value_type_t content_type;",
          "131:  ut8 mutability; // 0 if immutable, 1 if mutable",
          "132:  struct r_bin_wasm_init_expr_t init;",
          "133: } RBinWasmGlobalEntry;",
          "135: typedef struct r_bin_wasm_export_t {",
          "136:  ut32 field_len;",
          "137:  char field_str[R_BIN_WASM_STRING_LENGTH];",
          "138:  ut8 kind;",
          "139:  ut32 index;",
          "140: } RBinWasmExportEntry;",
          "142: typedef struct r_bin_wasm_start_t {",
          "143:  ut32 index;",
          "144: } RBinWasmStartEntry;",
          "146: struct r_bin_wasm_local_entry_t {",
          "147:  ut32 count;",
          "148:  r_bin_wasm_value_type_t type;",
          "149: };",
          "151: typedef struct r_bin_wasm_element_t {",
          "152:  ut32 index;",
          "153:  struct r_bin_wasm_init_expr_t init;",
          "154:  ut32 num_elem;",
          "155:  ut32 elems[];",
          "156: } RBinWasmElementEntry;",
          "158: typedef struct r_bin_wasm_code_t {",
          "159:  ut32 body_size;",
          "160:  ut32 local_count; // numer of local entries",
          "161:  struct r_bin_wasm_local_entry_t *locals;",
          "162:  ut32 code; // offset",
          "163:  ut32 len; // real bytecode length",
          "164:  ut8 byte; // 0xb, indicating end of the body",
          "165:  char name[R_BIN_WASM_STRING_LENGTH];",
          "166:  char *signature;",
          "167: } RBinWasmCodeEntry;",
          "169: typedef struct r_bin_wasm_data_t {",
          "170:  ut32 index; // linear memory index (0 in MVP)",
          "171:  struct r_bin_wasm_init_expr_t offset; // bytecode evaluated at runtime",
          "172:  ut32 size;",
          "173:  ut32 data; // offset",
          "174: } RBinWasmDataEntry;",
          "178: typedef struct r_bin_wasm_custom_name_t {",
          "179:  r_bin_wasm_name_type_t name_type;",
          "180:  ut32 name_payload_length;",
          "181:  ut32 name_payload_data;",
          "182: } RBinWasmCustomNameEntry;",
          "184: typedef struct r_bin_wasm_obj_t {",
          "186:  RBuffer *buf;",
          "187:  size_t size;",
          "189:  ut32 entrypoint;",
          "192:  RList *g_sections;",
          "193:  RList *g_types;",
          "194:  RList *g_imports;",
          "195:  RList *g_exports;",
          "196:  RList *g_tables;",
          "197:  RList *g_memories;",
          "198:  RList *g_globals;",
          "199:  RList *g_elements;",
          "200:  RList *g_codes;",
          "201:  RList *g_datas;",
          "202:  RBinWasmStartEntry *g_start;",
          "205: } RBinWasmObj;",
          "207: RBinWasmObj *r_bin_wasm_init (RBinFile *arch);",
          "208: void r_bin_wasm_destroy (RBinFile *arch);",
          "209: RList *r_bin_wasm_get_sections (RBinWasmObj *bin);",
          "210: RList *r_bin_wasm_get_types (RBinWasmObj *bin);",
          "211: RList *r_bin_wasm_get_imports (RBinWasmObj *bin);",
          "212: RList *r_bin_wasm_get_exports (RBinWasmObj *bin);",
          "213: RList *r_bin_wasm_get_tables (RBinWasmObj *bin);",
          "214: RList *r_bin_wasm_get_memories (RBinWasmObj *bin);",
          "215: RList *r_bin_wasm_get_globals (RBinWasmObj *bin);",
          "216: RList *r_bin_wasm_get_elements (RBinWasmObj *bin);",
          "217: RList *r_bin_wasm_get_codes (RBinWasmObj *bin);",
          "218: RList *r_bin_wasm_get_datas (RBinWasmObj *bin);",
          "219: ut32 r_bin_wasm_get_entrypoint (RBinWasmObj *bin);",
          "221: #endif",
          "",
          "---------------"
        ],
        "libr/bin/p/bin_wasm.c||libr/bin/p/bin_wasm.c": [
          "File: libr/bin/p/bin_wasm.c -> libr/bin/p/bin_wasm.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "7: #include <r_lib.h>",
          "8: #include <r_bin.h>",
          "10: static bool check_bytes(const ut8 *buf, ut64 length) {",
          "12: }",
          "16: static bool check(RBinFile *arch) {",
          "17:  const ut8 *bytes = arch? r_buf_buffer (arch->buf): NULL;",
          "18:  ut64 sz = arch? r_buf_size (arch->buf): 0;",
          "",
          "[Removed Lines]",
          "11:  return (buf && length >= 4 && !memcmp (buf, \"\\x00\" \"asm\", 4));",
          "14: static ut64 entrypoint = UT64_MAX;",
          "",
          "[Added Lines]",
          "10: #include \"wasm/wasm.h\"",
          "13:  return (buf && length >= 4 && !memcmp (buf, R_BIN_WASM_MAGIC_BYTES, 4));",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "20: }",
          "22: static void *load_bytes(RBinFile *arch, const ut8 *buf, ut64 sz, ut64 loadaddr, Sdb *sdb){",
          "24: }",
          "26: static bool load(RBinFile *arch) {",
          "28: }",
          "30: static int destroy(RBinFile *arch) {",
          "31:  return true;",
          "32: }",
          "",
          "[Removed Lines]",
          "23:  return (void *) (size_t) check_bytes (buf, sz);",
          "27:  return check (arch);",
          "",
          "[Added Lines]",
          "24:  if (!buf || !sz || sz == UT64_MAX) {",
          "25:   return NULL;",
          "26:  }",
          "27:  if (!check_bytes(buf, sz)) {",
          "28:   return NULL;",
          "29:  }",
          "30:  return r_bin_wasm_init (arch);",
          "35:  const ut8 *bytes = arch ? r_buf_buffer (arch->buf) : NULL;",
          "36:  ut64 sz = arch ? r_buf_size (arch->buf): 0;",
          "37:  if (!arch || !arch->o) {",
          "38:   return false;",
          "39:  }",
          "40:  arch->o->bin_obj = load_bytes (arch, bytes, sz, arch->o->loadaddr, arch->sdb);",
          "41:  return arch->o->bin_obj != NULL;",
          "45:  r_bin_wasm_destroy (arch);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "42: static RList *sections(RBinFile *arch);",
          "44: static RList *entries(RBinFile *arch) {",
          "49:   return NULL;",
          "50:  }",
          "53:  }",
          "58:   r_list_append (ret, ptr);",
          "59:  }",
          "60:  return ret;",
          "61: }",
          "68:   return NULL;",
          "69:  }",
          "72:   return NULL;",
          "73:  }",
          "114:    break;",
          "132:    break;",
          "135:    break;",
          "152:    break;",
          "155:    break;",
          "158:    break;",
          "162:    break;",
          "163:   }",
          "171:  }",
          "191: }",
          "193: static RList *libs(RBinFile *arch) {",
          "",
          "[Removed Lines]",
          "45:  RList *ret;",
          "46:  RBinAddr *ptr = NULL;",
          "48:  if (!(ret = r_list_new ())) {",
          "51:  if (entrypoint == UT64_MAX) {",
          "52:   r_list_free (sections (arch));",
          "54:  ret->free = free;",
          "55:  if ((ptr = R_NEW0 (RBinAddr))) {",
          "56:   ptr->paddr = entrypoint;",
          "57:   ptr->vaddr = entrypoint;",
          "63: static RList *sections(RBinFile *arch) {",
          "64:  RList *ret = NULL;",
          "65:  RBinSection *ptr = NULL;",
          "67:  if (!arch->o->info) {",
          "71:  if (!(ret = r_list_new ())) {",
          "74:  ret->free = free;",
          "76:  int next, i = 0;",
          "77:  ut8 *buf = arch->buf->buf; // skip magic + version",
          "78:  for (i = 8; i < arch->buf->length;) {",
          "79:   int id = buf[i];",
          "80: #if 0",
          "81:   1 Type Function signature declarations",
          "82:   2 Import Import declarations",
          "83:   3 Function Function declarations",
          "84:   4 Table Indirect function table and other tables",
          "85:   5 Memory Memory attributes",
          "86:   6 Global Global declarations",
          "87:   7 Export Exports",
          "88:   8 Start Start function declaration",
          "89:   9 Element Elements section",
          "90:   10 Code Function bodies(code)",
          "91:   11 Data Data segments",
          "92: #endif",
          "93:   ut64 res = 0;",
          "94:   ut8 *p = buf + i + 1;",
          "95:   const ut8 *afterBuf = r_uleb128 (p, 8, &res);",
          "96:   int payloadLen = res;",
          "97:   int payloadSize = (int) (size_t) (afterBuf - p);",
          "99:   p += payloadSize;",
          "101:   afterBuf = r_uleb128 (p, 8, &res);",
          "102:   int nameLen = res;",
          "103:   int nameSize = (int) (size_t) (afterBuf - p);",
          "105:   eprintf (\" 0x%x len = %d (%d) %d (%d): \", i, payloadLen, payloadSize, nameLen, nameSize);",
          "107:   next = i + payloadSize + nameSize + payloadLen; // payloadLen - payloadSize - nameSize; //nameSize - nameLen + 1; //payloadLen + nameLen + 1;",
          "108:   switch (id) {",
          "109:   case 1: // \"type\"",
          "110:    eprintf (\"type: function signature declarations\\n\");",
          "111:    break;",
          "112:   case 2:",
          "113:    eprintf (\"import:\\n\");",
          "115:   case 3:",
          "116:    eprintf (\"function:\\n\");",
          "117:    break;",
          "118:   case 4:",
          "119:    eprintf (\"table:\\n\");",
          "120:    break;",
          "121:   case 5:",
          "122:    eprintf (\"memory:\\n\");",
          "123:    break;",
          "124:   case 6:",
          "125:    eprintf (\"global:\\n\");",
          "126:    break;",
          "127:   case 7:",
          "128:    eprintf (\"export:\\n\");",
          "129:    break;",
          "130:   case 8:",
          "131:    eprintf (\"start:\\n\");",
          "133:   case 9:",
          "134:    eprintf (\"element:\\n\");",
          "136:   case 10: //",
          "137:    eprintf (\"code:\\n\");",
          "138:    if (!(ptr = R_NEW0 (RBinSection))) {",
          "139:     return ret;",
          "140:    }",
          "141:    strncpy (ptr->name, \"code\", R_BIN_SIZEOF_STRINGS);",
          "142:    ptr->size = payloadLen;",
          "143:    ptr->vsize = payloadLen;",
          "144:    ptr->paddr = i + nameLen + payloadSize + nameSize + 1 + payloadSize;",
          "145:    ptr->vaddr = ptr->paddr;",
          "146:    if (entrypoint == UT64_MAX) {",
          "147:     entrypoint = ptr->vaddr;",
          "148:    }",
          "149:    ptr->srwx = R_BIN_SCN_READABLE | R_BIN_SCN_EXECUTABLE | R_BIN_SCN_MAP; // r-x",
          "150:    ptr->add = true;",
          "151:    r_list_append (ret, ptr);",
          "153:   case 11: //",
          "154:    eprintf (\"data:\\n\");",
          "156:   default:",
          "157:    eprintf (\"unknown type id: %d\\n\", id);",
          "159:   }",
          "160:   if (next <= i) {",
          "161:    eprintf (\"Error: prevent infinite loop\\n\");",
          "164:   i = next;",
          "165:  }",
          "167: #if 0",
          "168:  textsize = r_mem_get_num (arch->buf->buf + 4, 4);",
          "169:  if (!(ptr = R_NEW0 (RBinSection))) {",
          "170:   return ret;",
          "172:  strncpy (ptr->name, \"text\", R_BIN_SIZEOF_STRINGS);",
          "173:  ptr->size = textsize;",
          "174:  ptr->vsize = textsize + (textsize % 4096);",
          "175:  ptr->paddr = 8 * 4;",
          "176:  ptr->vaddr = ptr->paddr;",
          "177:  ptr->srwx = R_BIN_SCN_READABLE | R_BIN_SCN_EXECUTABLE | R_BIN_SCN_MAP; // r-x",
          "178:  ptr->add = true;",
          "179:  r_list_append (ret, ptr);",
          "180: #endif",
          "181:  return ret;",
          "182: }",
          "184: static RList *symbols(RBinFile *arch) {",
          "186:  return NULL;",
          "187: }",
          "189: static RList *imports(RBinFile *arch) {",
          "190:  return NULL;",
          "",
          "[Added Lines]",
          "61:  RBinWasmObj *bin = arch && arch->o ? arch->o->bin_obj : NULL;",
          "64:     RList *ret;",
          "65:     RBinAddr *ptr = NULL;",
          "66:  ut64 addr = 0x0;",
          "68:     if (!(ret = r_list_newf ((RListFree)free))) {",
          "69:         return NULL;",
          "70:     }",
          "72:  if (!(addr = (ut64) r_bin_wasm_get_entrypoint (bin))) {",
          "76:     if ((ptr = R_NEW0 (RBinAddr))) {",
          "77:         ptr->paddr = addr;",
          "78:         ptr->vaddr = addr;",
          "79:         r_list_append (ret, ptr);",
          "80:     }",
          "81:     return ret;",
          "82: }",
          "84: static RList *sections(RBinFile *arch) {",
          "86:  RBinWasmObj *bin = arch && arch->o ? arch->o->bin_obj : NULL;",
          "88:  RList *ret = NULL;",
          "89:  RList *secs = NULL;",
          "90:     RBinSection *ptr = NULL;",
          "91:  RBinWasmSection *sec;",
          "93:  if (!(ret = r_list_newf ((RListFree)free))) {",
          "94:   return NULL;",
          "95:  }",
          "97:  if (!(secs = r_bin_wasm_get_sections (bin))) {",
          "98:   return NULL;",
          "101:  RListIter *iter;",
          "102:  r_list_foreach (secs, iter, sec) {",
          "104:   if (!(ptr = R_NEW0 (RBinSection))) {",
          "105:    break;",
          "106:   }",
          "108:   strncpy (ptr->name, (char*)sec->name, R_BIN_SIZEOF_STRINGS);",
          "109:   if (sec->id == R_BIN_WASM_SECTION_DATA || sec->id == R_BIN_WASM_SECTION_MEMORY) {",
          "110:    ptr->is_data = true;",
          "111:   }",
          "113:   ptr->size = sec->payload_len;",
          "114:   ptr->vsize = sec->payload_len;",
          "115:   ptr->vaddr = sec->offset;",
          "116:   ptr->paddr = sec->offset;",
          "117:   ptr->add = true;",
          "119:   ptr->srwx = 0;",
          "129: static RList *symbols(RBinFile *arch) {",
          "131:  RBinWasmObj *bin;",
          "132:     RList *ret, *codes, *imports;",
          "133:     RBinSymbol *ptr = NULL;",
          "135:  if (!arch || !arch->o || !arch->o->bin_obj) {",
          "138:  bin = arch->o->bin_obj;",
          "140:  if (!(ret = r_list_newf ((RListFree)free))) {",
          "144:  if (!(codes = r_bin_wasm_get_codes (bin))) {",
          "145:   return NULL;",
          "146:  }",
          "148:  if (!(imports = r_bin_wasm_get_imports (bin))) {",
          "149:   return NULL;",
          "150:  }",
          "152:  RListIter *iter;",
          "153:  ut32 i = 0;",
          "155:  RBinWasmImportEntry *imp;",
          "156:  r_list_foreach (imports, iter, imp) {",
          "157:   if (!(ptr = R_NEW0 (RBinSymbol))) {",
          "159:   }",
          "160:   char tmp[R_BIN_SIZEOF_STRINGS];",
          "161:   snprintf (tmp, R_BIN_SIZEOF_STRINGS, \"imp.%s.%s\", imp->module_str, imp->field_str);",
          "162:   ptr->name = strdup(tmp);",
          "163:   ptr->forwarder = r_str_const (\"NONE\");",
          "164:   ptr->bind = r_str_const (\"NONE\");",
          "165:   switch (imp->kind) {",
          "166:   case 0: ptr->type = r_str_const (\"FUNC\"); break;",
          "167:   case 1: ptr->type = r_str_const (\"TABLE\"); break;",
          "168:   case 2: ptr->type = r_str_const (\"MEMORY\"); break;",
          "169:   case 3: ptr->type = r_str_const (\"GLOBAL\"); break;",
          "170:   }",
          "171:   ptr->size = 0;",
          "172:   ptr->vaddr = 0;",
          "173:   ptr->paddr = 0;",
          "174:   ptr->ordinal = i;",
          "175:   i += 1;",
          "176:   r_list_append (ret, ptr);",
          "177:  }",
          "179:  RBinWasmCodeEntry *func;",
          "180:  r_list_foreach (codes, iter, func) {",
          "181:   if (!(ptr = R_NEW0 (RBinSymbol))) {",
          "183:   }",
          "184:   char tmp[R_BIN_SIZEOF_STRINGS];",
          "185:   snprintf (tmp, R_BIN_SIZEOF_STRINGS, \"fnc.%d\", i);",
          "186:   ptr->name = strdup(tmp);",
          "187:   ptr->forwarder = r_str_const (\"NONE\");",
          "188:   ptr->bind = r_str_const (\"NONE\");",
          "189:   ptr->type = r_str_const (\"FUNC\");",
          "190:   ptr->size = func->len;",
          "191:   ptr->vaddr = (ut64)func->code;",
          "192:   ptr->paddr = (ut64)func->code;",
          "193:   ptr->ordinal = i;",
          "194:   i += 1;",
          "195:   r_list_append (ret, ptr);",
          "196:  }",
          "201:  return ret;",
          "203: }",
          "205: static RList *imports(RBinFile *arch) {",
          "207:  RBinWasmObj *bin = NULL;",
          "208:  RList *imports = NULL;",
          "209:  RBinImport *ptr = NULL;",
          "210:  RList *ret = NULL;",
          "212:  if (!arch || !arch->o || !arch->o->bin_obj) {",
          "213:   return NULL;",
          "214:  }",
          "215:  bin = arch->o->bin_obj;",
          "217:  if (!(ret = r_list_newf (r_bin_import_free))) {",
          "218:   return NULL;",
          "219:  }",
          "221:  if (!(imports = r_bin_wasm_get_imports (bin))) {",
          "222:   r_list_free (ret);",
          "223:   return NULL;",
          "224:  }",
          "226:  RListIter *iter = NULL;",
          "227:  RBinWasmImportEntry *import = NULL;",
          "228:  ut32 i = 0;",
          "230:  r_list_foreach (imports, iter, import) {",
          "231:   if (!(ptr = R_NEW0 (RBinImport))) {",
          "233:   }",
          "234:   ptr->name = strdup (import->field_str);",
          "235:   ptr->classname = strdup (import->module_str);",
          "236:   ptr->ordinal = i;",
          "237:   ptr->bind = r_str_const (\"NONE\");",
          "238:   switch(import->kind) {",
          "239:   case R_BIN_WASM_EXTERNALKIND_Function:",
          "240:    ptr->type = r_str_const (\"FUNC\");",
          "242:   case R_BIN_WASM_EXTERNALKIND_Table:",
          "243:    ptr->type = r_str_const (\"TABLE\");",
          "245:   case R_BIN_WASM_EXTERNALKIND_Memory:",
          "246:    ptr->type = r_str_const (\"MEM\");",
          "248:   case R_BIN_WASM_EXTERNALKIND_Global:",
          "249:    ptr->type = r_str_const (\"GLOBAL\");",
          "252:   r_list_append (ret, ptr);",
          "255:  return ret;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "217: }",
          "219: static ut64 size(RBinFile *arch) {",
          "221:  if (!arch->o->info) {",
          "222:   arch->o->info = info (arch);",
          "223:  }",
          "224:  if (!arch->o->info) {",
          "225:   return 0;",
          "226:  }",
          "233: }",
          "",
          "[Removed Lines]",
          "220:  ut64 text, data, syms, spsz;",
          "228:  text = r_mem_get_num (arch->buf->buf + 4, 4);",
          "229:  data = r_mem_get_num (arch->buf->buf + 8, 4);",
          "230:  syms = r_mem_get_num (arch->buf->buf + 16, 4);",
          "231:  spsz = r_mem_get_num (arch->buf->buf + 24, 4);",
          "232:  return text + data + syms + spsz + (6 * 4);",
          "",
          "[Added Lines]",
          "294:  return arch->buf->length;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "238: #define B(x, y) r_buf_append_bytes (buf, (const ut8 *) x, y)",
          "239: #define D(x) r_buf_append_ut32 (buf, x)",
          "240:  B (\"\\x00\" \"asm\", 4);",
          "242:  return buf;",
          "243: }",
          "",
          "[Removed Lines]",
          "241:  D (0xc); // TODO: last version is 0xd",
          "",
          "[Added Lines]",
          "303:  B (\"\\x01\\x00\\x00\\x00\", 4);",
          "",
          "---------------"
        ],
        "libr/bin/p/wasm.mk||libr/bin/p/wasm.mk": [
          "File: libr/bin/p/wasm.mk -> libr/bin/p/wasm.mk",
          "--- Hunk 1 ---",
          "[Context before]",
          "3: STATIC_OBJ+=${OBJ_WASM}",
          "4: TARGET_WASM=bin_wasm.${EXT_SO}",
          "",
          "[Removed Lines]",
          "1: OBJ_WASM=bin_wasm.o",
          "",
          "[Added Lines]",
          "1: OBJ_WASM=bin_wasm.o ../format/wasm/wasm.o",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "6: ALL_TARGETS+=${TARGET_WASM}",
          "8: ${TARGET_WASM}: ${OBJ_WASM}",
          "",
          "[Removed Lines]",
          "9:  -${CC} $(call libname,bin_wasm) ${CFLAGS} ${OBJ_WASM}",
          "",
          "[Added Lines]",
          "9:  ${CC} $(call libname,bin_wasm) -shared ${CFLAGS} \\",
          "10:   -o ${TARGET_WASM} ${OBJ_WASM} $(LINK) $(LDFLAGS)",
          "",
          "---------------"
        ]
      }
    }
  ]
}
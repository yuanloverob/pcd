{
  "cve_id": "CVE-2016-4301",
  "cve_desc": "Stack-based buffer overflow in the parse_device function in archive_read_support_format_mtree.c in libarchive before 3.2.1 allows remote attackers to execute arbitrary code via a crafted mtree file.",
  "repo": "libarchive/libarchive",
  "patch_hash": "a550daeecf6bc689ade371349892ea17b5b97c77",
  "patch_info": {
    "commit_hash": "a550daeecf6bc689ade371349892ea17b5b97c77",
    "repo": "libarchive/libarchive",
    "commit_url": "https://github.com/libarchive/libarchive/commit/a550daeecf6bc689ade371349892ea17b5b97c77",
    "files": [
      "libarchive/archive_read_support_format_mtree.c"
    ],
    "message": "Fix libarchive/archive_read_support_format_mtree.c:1388:11: error: array subscript is above array bounds",
    "before_after_code_files": [
      "libarchive/archive_read_support_format_mtree.c||libarchive/archive_read_support_format_mtree.c"
    ]
  },
  "patch_diff": {
    "libarchive/archive_read_support_format_mtree.c||libarchive/archive_read_support_format_mtree.c": [
      "File: libarchive/archive_read_support_format_mtree.c -> libarchive/archive_read_support_format_mtree.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1385:         \"Missing number\");",
      "1386:     return ARCHIVE_WARN;",
      "1387:    }",
      "1390:     archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,",
      "1391:         \"Too many arguments\");",
      "1392:     return ARCHIVE_WARN;",
      "1393:    }",
      "1394:   }",
      "1395:   if (argc < 2) {",
      "1396:    archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,",
      "",
      "[Removed Lines]",
      "1388:    numbers[argc++] = (unsigned long)mtree_atol(&p);",
      "1389:    if (argc > MAX_PACK_ARGS) {",
      "",
      "[Added Lines]",
      "1388:    if (argc >= MAX_PACK_ARGS) {",
      "1393:    numbers[argc++] = (unsigned long)mtree_atol(&p);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "076563620b56988bc03db1bac8739b05d1f4efd0",
      "candidate_info": {
        "commit_hash": "076563620b56988bc03db1bac8739b05d1f4efd0",
        "repo": "libarchive/libarchive",
        "commit_url": "https://github.com/libarchive/libarchive/commit/076563620b56988bc03db1bac8739b05d1f4efd0",
        "files": [
          "libarchive/archive_read_support_format_mtree.c"
        ],
        "message": "Refactor numeric parsing routines into a single version without UB.\n\nReported-By:\tOSS-Fuzz issue 862",
        "before_after_code_files": [
          "libarchive/archive_read_support_format_mtree.c||libarchive/archive_read_support_format_mtree.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libarchive/archive_read_support_format_mtree.c||libarchive/archive_read_support_format_mtree.c"
          ],
          "candidate": [
            "libarchive/archive_read_support_format_mtree.c||libarchive/archive_read_support_format_mtree.c"
          ]
        }
      },
      "candidate_diff": {
        "libarchive/archive_read_support_format_mtree.c||libarchive/archive_read_support_format_mtree.c": [
          "File: libarchive/archive_read_support_format_mtree.c -> libarchive/archive_read_support_format_mtree.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "130: static int skip(struct archive_read *a);",
          "131: static int read_header(struct archive_read *,",
          "132:       struct archive_entry *);",
          "",
          "[Removed Lines]",
          "133: static int64_t mtree_atol10(char **);",
          "134: static int64_t mtree_atol8(char **);",
          "135: static int64_t mtree_atol(char **);",
          "",
          "[Added Lines]",
          "133: static int64_t mtree_atol(char **, int base);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1418:         \"Too many arguments\");",
          "1419:     return ARCHIVE_WARN;",
          "1420:    }",
          "1422:   }",
          "1423:   if (argc < 2) {",
          "1424:    archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,",
          "",
          "[Removed Lines]",
          "1421:    numbers[argc++] = (unsigned long)mtree_atol(&p);",
          "",
          "[Added Lines]",
          "1419:    numbers[argc++] = (unsigned long)mtree_atol(&p, 0);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1433:   }",
          "1434:  } else {",
          "1437:  }",
          "1439:  return ARCHIVE_OK;",
          "",
          "[Removed Lines]",
          "1436:   result = (dev_t)mtree_atol(&val);",
          "",
          "[Added Lines]",
          "1434:   result = (dev_t)mtree_atol(&val, 0);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1513:  case 'g':",
          "1514:   if (strcmp(key, \"gid\") == 0) {",
          "1517:    break;",
          "1518:   }",
          "1519:   if (strcmp(key, \"gname\") == 0) {",
          "",
          "[Removed Lines]",
          "1516:    archive_entry_set_gid(entry, mtree_atol10(&val));",
          "",
          "[Added Lines]",
          "1514:    archive_entry_set_gid(entry, mtree_atol(&val, 10));",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1523:   }",
          "1524:  case 'i':",
          "1525:   if (strcmp(key, \"inode\") == 0) {",
          "1527:    break;",
          "1528:   }",
          "1529:  case 'l':",
          "",
          "[Removed Lines]",
          "1526:    archive_entry_set_ino(entry, mtree_atol10(&val));",
          "",
          "[Added Lines]",
          "1524:    archive_entry_set_ino(entry, mtree_atol(&val, 10));",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1538:    if (val[0] >= '0' && val[0] <= '7') {",
          "1540:     archive_entry_set_perm(entry,",
          "1542:    } else {",
          "1543:     archive_set_error(&a->archive,",
          "1544:         ARCHIVE_ERRNO_FILE_FORMAT,",
          "",
          "[Removed Lines]",
          "1541:         (mode_t)mtree_atol8(&val));",
          "",
          "[Added Lines]",
          "1539:         (mode_t)mtree_atol(&val, 8));",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1551:   if (strcmp(key, \"nlink\") == 0) {",
          "1553:    archive_entry_set_nlink(entry,",
          "1555:    break;",
          "1556:   }",
          "1557:  case 'r':",
          "",
          "[Removed Lines]",
          "1554:     (unsigned int)mtree_atol10(&val));",
          "",
          "[Added Lines]",
          "1552:     (unsigned int)mtree_atol(&val, 10));",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1582:       strcmp(key, \"sha512digest\") == 0)",
          "1583:    break;",
          "1584:   if (strcmp(key, \"size\") == 0) {",
          "1586:    break;",
          "1587:   }",
          "1588:  case 't':",
          "",
          "[Removed Lines]",
          "1585:    archive_entry_set_size(entry, mtree_atol10(&val));",
          "",
          "[Added Lines]",
          "1583:    archive_entry_set_size(entry, mtree_atol(&val, 10));",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1601:    long ns = 0;",
          "1608:    if (*val == '.') {",
          "1609:     ++val;",
          "1611:     if (ns < 0)",
          "1612:      ns = 0;",
          "1613:     else if (ns > 999999999)",
          "",
          "[Removed Lines]",
          "1604:    m = mtree_atol10(&val);",
          "1610:     ns = (long)mtree_atol10(&val);",
          "",
          "[Added Lines]",
          "1602:    m = mtree_atol(&val, 10);",
          "1608:     ns = (long)mtree_atol(&val, 10);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1670:  case 'u':",
          "1671:   if (strcmp(key, \"uid\") == 0) {",
          "1674:    break;",
          "1675:   }",
          "1676:   if (strcmp(key, \"uname\") == 0) {",
          "",
          "[Removed Lines]",
          "1673:    archive_entry_set_uid(entry, mtree_atol10(&val));",
          "",
          "[Added Lines]",
          "1671:    archive_entry_set_uid(entry, mtree_atol(&val, 10));",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1826: }",
          "1897: static int",
          "1899: {",
          "1900:  if (c >= '0' && c <= '9')",
          "1901:   return c - '0';",
          "",
          "[Removed Lines]",
          "1833: static int64_t",
          "1834: mtree_atol8(char **p)",
          "1835: {",
          "1836:  int64_t l, limit, last_digit_limit;",
          "1837:  int digit, base;",
          "1839:  base = 8;",
          "1840:  limit = INT64_MAX / base;",
          "1841:  last_digit_limit = INT64_MAX % base;",
          "1843:  l = 0;",
          "1844:  digit = **p - '0';",
          "1845:  while (digit >= 0 && digit < base) {",
          "1846:   if (l>limit || (l == limit && digit > last_digit_limit)) {",
          "1848:    break;",
          "1849:   }",
          "1850:   l = (l * base) + digit;",
          "1851:   digit = *++(*p) - '0';",
          "1852:  }",
          "1853:  return (l);",
          "1854: }",
          "1865: static int64_t",
          "1866: mtree_atol10(char **p)",
          "1867: {",
          "1868:  const int base = 10;",
          "1869:  const int64_t limit = INT64_MAX / base;",
          "1870:  const int64_t last_digit_limit = INT64_MAX % base;",
          "1871:  int64_t l;",
          "1872:  int sign;",
          "1874:  if (**p == '-') {",
          "1875:   sign = -1;",
          "1876:   ++(*p);",
          "1877:  } else {",
          "1878:   sign = 1;",
          "1879:  }",
          "1881:  l = 0;",
          "1882:  while (**p >= '0' && **p < '0' + base) {",
          "1883:   int digit = **p - '0';",
          "1884:   if (l > limit || (l == limit && digit > last_digit_limit)) {",
          "1885:    while (**p >= '0' && **p < '0' + base) {",
          "1886:     ++(*p);",
          "1887:    }",
          "1888:    return (sign < 0) ? INT64_MIN : INT64_MAX;",
          "1889:   }",
          "1890:   l = (l * base) + digit;",
          "1891:   ++(*p);",
          "1892:  }",
          "1893:  return (sign < 0) ? -l : l;",
          "1894: }",
          "1898: parsehex(char c)",
          "",
          "[Added Lines]",
          "1828: parsedigit(char c)",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1915: static int64_t",
          "1917: {",
          "1923:  if (**p == '-') {",
          "1927:   ++(*p);",
          "1928:  } else {",
          "1930:   limit = INT64_MAX / base;",
          "1931:   last_digit_limit = INT64_MAX % base;",
          "1953:  }",
          "1955: }",
          "",
          "[Removed Lines]",
          "1916: mtree_atol16(char **p)",
          "1918:  int64_t l, limit, last_digit_limit;",
          "1919:  int base, digit, sign;",
          "1921:  base = 16;",
          "1924:   sign = -1;",
          "1925:   limit = ((uint64_t)(INT64_MAX) + 1) / base;",
          "1926:   last_digit_limit = ((uint64_t)(INT64_MAX) + 1) % base;",
          "1929:   sign = 1;",
          "1932:  }",
          "1934:  l = 0;",
          "1935:  digit = parsehex(**p);",
          "1936:  while (digit >= 0 && digit < base) {",
          "1937:   if (l > limit || (l == limit && digit > last_digit_limit))",
          "1938:    return (sign < 0) ? INT64_MIN : INT64_MAX;",
          "1939:   l = (l * base) + digit;",
          "1940:   digit = parsehex(*++(*p));",
          "1941:  }",
          "1942:  return (sign < 0) ? -l : l;",
          "1943: }",
          "1945: static int64_t",
          "1946: mtree_atol(char **p)",
          "1947: {",
          "1948:  if (**p != '0')",
          "1949:   return mtree_atol10(p);",
          "1950:  if ((*p)[1] == 'x' || (*p)[1] == 'X') {",
          "1952:   return mtree_atol16(p);",
          "1954:  return mtree_atol8(p);",
          "",
          "[Added Lines]",
          "1846: mtree_atol(char **p, int base)",
          "1848:  int64_t l, limit;",
          "1849:  int digit, last_digit_limit;",
          "1851:  if (base == 0) {",
          "1852:   if (**p != '0')",
          "1853:    base = 10;",
          "1854:   else if ((*p)[1] == 'x' || (*p)[1] == 'X') {",
          "1856:    base = 16;",
          "1857:   } else {",
          "1858:    base = 8;",
          "1859:   }",
          "1860:  }",
          "1863:   limit = INT64_MIN / base;",
          "1864:   last_digit_limit = INT64_MIN % base;",
          "1867:   l = 0;",
          "1868:   digit = parsedigit(**p);",
          "1869:   while (digit >= 0 && digit < base) {",
          "1870:    if (l < limit || (l == limit && digit > last_digit_limit))",
          "1871:     return INT64_MIN;",
          "1872:    l = (l * base) - digit;",
          "1873:    digit = parsedigit(*++(*p));",
          "1874:   }",
          "1875:   return l;",
          "1880:   l = 0;",
          "1881:   digit = parsedigit(**p);",
          "1882:   while (digit >= 0 && digit < base) {",
          "1883:    if (l > limit || (l == limit && digit > last_digit_limit))",
          "1884:     return INT64_MAX;",
          "1885:    l = (l * base) + digit;",
          "1886:    digit = parsedigit(*++(*p));",
          "1887:   }",
          "1888:   return l;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
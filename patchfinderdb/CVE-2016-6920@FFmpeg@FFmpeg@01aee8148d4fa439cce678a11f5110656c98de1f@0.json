{
  "cve_id": "CVE-2016-6920",
  "cve_desc": "Heap-based buffer overflow in the decode_block function in libavcodec/exr.c in FFmpeg before 3.1.3 allows remote attackers to cause a denial of service (application crash) via vectors involving tile positions.",
  "repo": "FFmpeg/FFmpeg",
  "patch_hash": "01aee8148d4fa439cce678a11f5110656c98de1f",
  "patch_info": {
    "commit_hash": "01aee8148d4fa439cce678a11f5110656c98de1f",
    "repo": "FFmpeg/FFmpeg",
    "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/01aee8148d4fa439cce678a11f5110656c98de1f",
    "files": [
      "libavcodec/exr.c"
    ],
    "message": "avcodec/exr: Check tile positions\n\nThis also disabled the case of mixed x/ymin with tiles, the code\nhandles these cases inconsistent for the 2 coordinate axis and is\nunlikely working correctly.\n\nFixes crash\nFixes: poc1.exr, poc2.exr\n\nFound-by: Yaoguang Chen of Aliapy unLimit Security Team\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>",
    "before_after_code_files": [
      "libavcodec/exr.c||libavcodec/exr.c"
    ]
  },
  "patch_diff": {
    "libavcodec/exr.c||libavcodec/exr.c": [
      "File: libavcodec/exr.c -> libavcodec/exr.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1029:     uint64_t line_offset, uncompressed_size;",
      "1030:     uint16_t *ptr_x;",
      "1031:     uint8_t *ptr;",
      "1034:     const uint8_t *src;",
      "",
      "[Removed Lines]",
      "1032:     uint32_t data_size, line, col = 0;",
      "1033:     uint32_t tileX, tileY, tileLevelX, tileLevelY;",
      "",
      "[Added Lines]",
      "1032:     uint32_t data_size;",
      "1033:     uint64_t line, col = 0;",
      "1034:     uint64_t tileX, tileY, tileLevelX, tileLevelY;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1062:             return AVERROR_PATCHWELCOME;",
      "1063:         }",
      "1065:         line = s->tile_attr.ySize * tileY;",
      "1066:         col = s->tile_attr.xSize * tileX;",
      "1068:         td->ysize = FFMIN(s->tile_attr.ySize, s->ydelta - tileY * s->tile_attr.ySize);",
      "1069:         td->xsize = FFMIN(s->tile_attr.xSize, s->xdelta - tileX * s->tile_attr.xSize);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1066:         if (s->xmin || s->ymin) {",
      "1067:             avpriv_report_missing_feature(s->avctx, \"Tiles with xmin/ymin\");",
      "1068:             return AVERROR_PATCHWELCOME;",
      "1069:         }",
      "1074:         if (line < s->ymin || line > s->ymax ||",
      "1075:             col  < s->xmin || col  > s->xmax)",
      "1076:             return AVERROR_INVALIDDATA;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "79f52a0dbd484aad111e4bf4a4f7047c7ceb6137",
      "candidate_info": {
        "commit_hash": "79f52a0dbd484aad111e4bf4a4f7047c7ceb6137",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/79f52a0dbd484aad111e4bf4a4f7047c7ceb6137",
        "files": [
          "libavcodec/exr.c"
        ],
        "message": "avcodec/exr: Check tile positions\n\nThis also disabled the case of mixed x/ymin with tiles, the code\nhandles these cases inconsistent for the 2 coordinate axis and is\nunlikely working correctly.\n\nFixes crash\nFixes: poc1.exr, poc2.exr\n\nFound-by: Yaoguang Chen of Aliapy unLimit Security Team\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>\n(cherry picked from commit 01aee8148d4fa439cce678a11f5110656c98de1f)\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>",
        "before_after_code_files": [
          "libavcodec/exr.c||libavcodec/exr.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "libavcodec/exr.c||libavcodec/exr.c"
          ],
          "candidate": [
            "libavcodec/exr.c||libavcodec/exr.c"
          ]
        }
      },
      "candidate_diff": {
        "libavcodec/exr.c||libavcodec/exr.c": [
          "File: libavcodec/exr.c -> libavcodec/exr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1027:     uint64_t line_offset, uncompressed_size;",
          "1028:     uint16_t *ptr_x;",
          "1029:     uint8_t *ptr;",
          "1032:     const uint8_t *src;",
          "",
          "[Removed Lines]",
          "1030:     uint32_t data_size, line, col = 0;",
          "1031:     uint32_t tileX, tileY, tileLevelX, tileLevelY;",
          "",
          "[Added Lines]",
          "1030:     uint32_t data_size;",
          "1031:     uint64_t line, col = 0;",
          "1032:     uint64_t tileX, tileY, tileLevelX, tileLevelY;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1059:             return AVERROR_PATCHWELCOME;",
          "1060:         }",
          "1062:         line = s->tile_attr.ySize * tileY;",
          "1063:         col = s->tile_attr.xSize * tileX;",
          "1065:         td->ysize = FFMIN(s->tile_attr.ySize, s->ydelta - tileY * s->tile_attr.ySize);",
          "1066:         td->xsize = FFMIN(s->tile_attr.xSize, s->xdelta - tileX * s->tile_attr.xSize);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1063:         if (s->xmin || s->ymin) {",
          "1064:             avpriv_report_missing_feature(s->avctx, \"Tiles with xmin/ymin\");",
          "1065:             return AVERROR_PATCHWELCOME;",
          "1066:         }",
          "1071:         if (line < s->ymin || line > s->ymax ||",
          "1072:             col  < s->xmin || col  > s->xmax)",
          "1073:             return AVERROR_INVALIDDATA;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "73ae60d7df0404b06141faf9a6f62fa87d0a770c",
      "candidate_info": {
        "commit_hash": "73ae60d7df0404b06141faf9a6f62fa87d0a770c",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/73ae60d7df0404b06141faf9a6f62fa87d0a770c",
        "files": [
          "libavcodec/exr.c"
        ],
        "message": "libavcodec/exr : cosmetics variable name\n\nrename tile variable to better follow ffmpeg coding style\n\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>",
        "before_after_code_files": [
          "libavcodec/exr.c||libavcodec/exr.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libavcodec/exr.c||libavcodec/exr.c"
          ],
          "candidate": [
            "libavcodec/exr.c||libavcodec/exr.c"
          ]
        }
      },
      "candidate_diff": {
        "libavcodec/exr.c||libavcodec/exr.c": [
          "File: libavcodec/exr.c -> libavcodec/exr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1063:     uint8_t *ptr;",
          "1064:     uint32_t data_size;",
          "1065:     uint64_t line, col = 0;",
          "1067:     const uint8_t *src;",
          "",
          "[Removed Lines]",
          "1066:     uint64_t tileX, tileY, tileLevelX, tileLevelY;",
          "",
          "[Added Lines]",
          "1066:     uint64_t tile_x, tile_y, tile_level_x, tile_level_y;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1082:         src  = buf + line_offset + 20;",
          "1089:         data_size = AV_RL32(src - 4);",
          "1090:         if (data_size <= 0 || data_size > buf_size)",
          "1091:             return AVERROR_INVALIDDATA;",
          "1094:             avpriv_report_missing_feature(s->avctx, \"Subres tile before full res tile\");",
          "1095:             return AVERROR_PATCHWELCOME;",
          "1096:         }",
          "",
          "[Removed Lines]",
          "1084:         tileX = AV_RL32(src - 20);",
          "1085:         tileY = AV_RL32(src - 16);",
          "1086:         tileLevelX = AV_RL32(src - 12);",
          "1087:         tileLevelY = AV_RL32(src - 8);",
          "",
          "[Added Lines]",
          "1084:         tile_x = AV_RL32(src - 20);",
          "1085:         tile_y = AV_RL32(src - 16);",
          "1086:         tile_level_x = AV_RL32(src - 12);",
          "1087:         tile_level_y = AV_RL32(src - 8);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1100:             return AVERROR_PATCHWELCOME;",
          "1101:         }",
          "1106:         if (line < s->ymin || line > s->ymax ||",
          "1107:             col  < s->xmin || col  > s->xmax)",
          "1108:             return AVERROR_INVALIDDATA;",
          "",
          "[Removed Lines]",
          "1103:         line = s->tile_attr.ySize * tileY;",
          "1104:         col = s->tile_attr.xSize * tileX;",
          "1110:         td->ysize = FFMIN(s->tile_attr.ySize, s->ydelta - tileY * s->tile_attr.ySize);",
          "1111:         td->xsize = FFMIN(s->tile_attr.xSize, s->xdelta - tileX * s->tile_attr.xSize);",
          "",
          "[Added Lines]",
          "1103:         line = s->tile_attr.ySize * tile_y;",
          "1104:         col = s->tile_attr.xSize * tile_x;",
          "1110:         td->ysize = FFMIN(s->tile_attr.ySize, s->ydelta - tile_y * s->tile_attr.ySize);",
          "1111:         td->xsize = FFMIN(s->tile_attr.xSize, s->xdelta - tile_x * s->tile_attr.xSize);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "25a01c52b889d64e77fb3f8f7e519d183d7635b8",
      "candidate_info": {
        "commit_hash": "25a01c52b889d64e77fb3f8f7e519d183d7635b8",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/25a01c52b889d64e77fb3f8f7e519d183d7635b8",
        "files": [
          "libavcodec/exr.c"
        ],
        "message": "libavcodec/exr: add tile support\n\nSigned-off-by: Paul B Mahol <onemda@gmail.com>",
        "before_after_code_files": [
          "libavcodec/exr.c||libavcodec/exr.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libavcodec/exr.c||libavcodec/exr.c"
          ],
          "candidate": [
            "libavcodec/exr.c||libavcodec/exr.c"
          ]
        }
      },
      "candidate_diff": {
        "libavcodec/exr.c||libavcodec/exr.c": [
          "File: libavcodec/exr.c -> libavcodec/exr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "67:     EXR_UNKNOWN,",
          "68: };",
          "70: typedef struct EXRChannel {",
          "71:     int xsub, ysub;",
          "72:     enum ExrPixelType pixel_type;",
          "73: } EXRChannel;",
          "75: typedef struct EXRThreadData {",
          "76:     uint8_t *uncompressed_data;",
          "77:     int uncompressed_size;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "72: enum ExrTileLevelMode {",
          "73:     EXR_TILE_LEVEL_ONE,",
          "74:     EXR_TILE_LEVEL_MIPMAP,",
          "75:     EXR_TILE_LEVEL_RIPMAP,",
          "76: };",
          "78: enum ExrTileLevelRound {",
          "79:     EXR_TILE_ROUND_UP,",
          "80:     EXR_TILE_ROUND_DOWN,",
          "81: };",
          "88: typedef struct EXRTileAttribute {",
          "89:     int32_t xSize;",
          "90:     int32_t ySize;",
          "91:     enum ExrTileLevelMode level_mode;",
          "92:     enum ExrTileLevelRound level_round;",
          "93: } EXRTileAttribute;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "97:     uint32_t xmax, xmin;",
          "98:     uint32_t ymax, ymin;",
          "99:     uint32_t xdelta, ydelta;",
          "102:     uint64_t scan_line_size;",
          "103:     int scan_lines_per_block;",
          "105:     GetByteContext gb;",
          "106:     const uint8_t *buf;",
          "107:     int buf_size;",
          "109:     EXRChannel *channels;",
          "110:     int nb_channels;",
          "112:     EXRThreadData *thread_data;",
          "",
          "[Removed Lines]",
          "100:     int ysize;",
          "",
          "[Added Lines]",
          "120:     int ysize, xsize;",
          "134:     int current_channel_offset;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "793:     if (uncompress(td->tmp, &dest_len, src, compressed_size) != Z_OK) {",
          "794:         return AVERROR_INVALIDDATA;",
          "796:         return AVERROR_INVALIDDATA;",
          "797:     }",
          "",
          "[Removed Lines]",
          "795:     } else if (dest_len != expected_len){",
          "",
          "[Added Lines]",
          "819:     } else if (dest_len != expected_len) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "891: static int b44_uncompress(EXRContext *s, const uint8_t *src, int compressed_size,",
          "893:     const int8_t *sr = src;",
          "894:     int stayToUncompress = compressed_size;",
          "895:     int nbB44BlockW, nbB44BlockH;",
          "",
          "[Removed Lines]",
          "892:                           int uncompressed_size, EXRThreadData *td){",
          "",
          "[Added Lines]",
          "916:                           int uncompressed_size, EXRThreadData *td) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "909:     for (c = 0; c < s->nb_channels; c++) {",
          "910:         for (iY = 0; iY < nbB44BlockH; iY++) {",
          "913:                     av_log(s, AV_LOG_ERROR, \"Not enough data for B44A block: %d\", stayToUncompress);",
          "914:                     return AVERROR_INVALIDDATA;",
          "915:                 }",
          "",
          "[Removed Lines]",
          "912:                 if (stayToUncompress < 3){",
          "",
          "[Added Lines]",
          "936:                 if (stayToUncompress < 3) {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "959:     uint32_t xdelta = s->xdelta;",
          "960:     uint16_t *ptr_x;",
          "961:     uint8_t *ptr;",
          "963:     const uint8_t *src;",
          "966:     int i, x, buf_size = s->buf_size;",
          "967:     float one_gamma = 1.0f / s->gamma;",
          "968:     avpriv_trc_function trc_func = avpriv_get_trc_function_from_trc(s->apply_trc_type);",
          "969:     int ret;",
          "971:     line_offset = AV_RL64(s->gb.buffer + jobnr * 8);",
          "992:     }",
          "994:     if (data_size < uncompressed_size) {",
          "995:         av_fast_padded_malloc(&td->uncompressed_data,",
          "996:                               &td->uncompressed_size, uncompressed_size);",
          "999:             return AVERROR(ENOMEM);",
          "1001:         ret = AVERROR_INVALIDDATA;",
          "",
          "[Removed Lines]",
          "962:     uint32_t data_size, line;",
          "964:     int axmax = (avctx->width - (s->xmax + 1)) * 2 * s->desc->nb_components;",
          "965:     int bxmin = s->xmin * 2 * s->desc->nb_components;",
          "973:     if (line_offset > buf_size - 8)",
          "974:         return AVERROR_INVALIDDATA;",
          "976:     src  = buf + line_offset + 8;",
          "977:     line = AV_RL32(src - 8);",
          "978:     if (line < s->ymin || line > s->ymax)",
          "979:         return AVERROR_INVALIDDATA;",
          "981:     data_size = AV_RL32(src - 4);",
          "982:     if (data_size <= 0 || data_size > buf_size)",
          "983:         return AVERROR_INVALIDDATA;",
          "985:     s->ysize          = FFMIN(s->scan_lines_per_block, s->ymax - line + 1);",
          "986:     uncompressed_size = s->scan_line_size * s->ysize;",
          "987:     if ((s->compression == EXR_RAW && (data_size != uncompressed_size ||",
          "988:                                  line_offset > buf_size - uncompressed_size)) ||",
          "989:         (s->compression != EXR_RAW && (data_size > uncompressed_size ||",
          "990:                                  line_offset > buf_size - data_size))) {",
          "991:         return AVERROR_INVALIDDATA;",
          "997:         av_fast_padded_malloc(&td->tmp, &td->tmp_size, uncompressed_size);",
          "998:         if (!td->uncompressed_data || !td->tmp)",
          "",
          "[Added Lines]",
          "986:     uint32_t data_size, line, col = 0;",
          "987:     uint32_t tileX, tileY, tileLevelX, tileLevelY;",
          "988:     int channelLineSize, indexSrc, tX, tY, tCh;",
          "999:     if (s->is_tile) {",
          "1000:         if (line_offset > buf_size - 20)",
          "1001:             return AVERROR_INVALIDDATA;",
          "1003:         src  = buf + line_offset + 20;",
          "1005:         tileX = AV_RL32(src - 20);",
          "1006:         tileY = AV_RL32(src - 16);",
          "1007:         tileLevelX = AV_RL32(src - 12);",
          "1008:         tileLevelY = AV_RL32(src - 8);",
          "1010:         data_size = AV_RL32(src - 4);",
          "1011:         if (data_size <= 0 || data_size > buf_size)",
          "1012:             return AVERROR_INVALIDDATA;",
          "1015:             av_log(s->avctx, AV_LOG_ERROR, \"Wrong Tile level %i / %i.\\n\", tileLevelX, tileLevelY);",
          "1016:             return AVERROR_INVALIDDATA;",
          "1017:         }",
          "1019:         line = s->tile_attr.ySize * tileY;",
          "1020:         col = s->tile_attr.xSize * tileX;",
          "1022:         s->ysize = FFMIN(s->tile_attr.ySize, s->ydelta - tileY * s->tile_attr.ySize);",
          "1023:         s->xsize = FFMIN(s->tile_attr.xSize, s->xdelta - tileX * s->tile_attr.xSize);",
          "1024:         uncompressed_size = s->current_channel_offset * s->ysize * s->xsize;",
          "1028:         }",
          "1032:     } else {",
          "1033:         if (line_offset > buf_size - 8)",
          "1034:             return AVERROR_INVALIDDATA;",
          "1036:         src  = buf + line_offset + 8;",
          "1037:         line = AV_RL32(src - 8);",
          "1038:         if (line < s->ymin || line > s->ymax)",
          "1039:             return AVERROR_INVALIDDATA;",
          "1041:         data_size = AV_RL32(src - 4);",
          "1042:         if (data_size <= 0 || data_size > buf_size)",
          "1043:             return AVERROR_INVALIDDATA;",
          "1046:         s->xsize          = s->xdelta;",
          "1047:         uncompressed_size = s->scan_line_size * s->ysize;",
          "1048:         if ((s->compression == EXR_RAW && (data_size != uncompressed_size ||",
          "1049:                                            line_offset > buf_size - uncompressed_size)) ||",
          "1050:             (s->compression != EXR_RAW && (data_size > uncompressed_size ||",
          "1051:                                            line_offset > buf_size - data_size))) {",
          "1052:             return AVERROR_INVALIDDATA;",
          "1053:         }",
          "1054:     }",
          "1057:         av_fast_padded_malloc(&td->tmp, &td->tmp_size, uncompressed_size);",
          "1058:         if (!td->tmp)",
          "1059:             return AVERROR(ENOMEM);",
          "1066:         if (!td->uncompressed_data)",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1025:         src = td->uncompressed_data;",
          "1026:     }",
          "1035:     for (i = 0;",
          "1038:         const uint8_t *r, *g, *b, *a;",
          "1040:         r = channel_buffer[0];",
          "",
          "[Removed Lines]",
          "1028:     channel_buffer[0] = src + xdelta * s->channel_offsets[0];",
          "1029:     channel_buffer[1] = src + xdelta * s->channel_offsets[1];",
          "1030:     channel_buffer[2] = src + xdelta * s->channel_offsets[2];",
          "1031:     if (s->channel_offsets[3] >= 0)",
          "1032:         channel_buffer[3] = src + xdelta * s->channel_offsets[3];",
          "1034:     ptr = p->data[0] + line * p->linesize[0];",
          "1036:          i < s->scan_lines_per_block && line + i <= s->ymax;",
          "1037:          i++, ptr += p->linesize[0]) {",
          "",
          "[Added Lines]",
          "1096:     if (s->is_tile) {",
          "1097:         indexSrc = 0;",
          "1098:         channelLineSize = s->xsize * 2;",
          "1099:         if (s->pixel_type == EXR_FLOAT)",
          "1100:             channelLineSize *= 2;",
          "1103:         for (tY = 0; tY < s->ysize; tY ++) {",
          "1104:             for (tCh = 0; tCh < s->nb_channels; tCh++) {",
          "1105:                 for (tX = 0; tX < channelLineSize; tX++) {",
          "1106:                     td->tmp[tCh * channelLineSize * s->ysize + tY * channelLineSize + tX] = src[indexSrc];",
          "1107:                     indexSrc++;",
          "1108:                 }",
          "1109:             }",
          "1110:         }",
          "1112:         channel_buffer[0] = td->tmp + s->xsize * s->channel_offsets[0]  * s->ysize;",
          "1113:         channel_buffer[1] = td->tmp + s->xsize * s->channel_offsets[1]  * s->ysize;",
          "1114:         channel_buffer[2] = td->tmp + s->xsize * s->channel_offsets[2]  * s->ysize;",
          "1115:         if (s->channel_offsets[3] >= 0)",
          "1116:             channel_buffer[3] = td->tmp + s->xsize * s->channel_offsets[3];",
          "1117:     } else {",
          "1118:         channel_buffer[0] = src + xdelta * s->channel_offsets[0];",
          "1119:         channel_buffer[1] = src + xdelta * s->channel_offsets[1];",
          "1120:         channel_buffer[2] = src + xdelta * s->channel_offsets[2];",
          "1121:         if (s->channel_offsets[3] >= 0)",
          "1122:             channel_buffer[3] = src + xdelta * s->channel_offsets[3];",
          "1123:     }",
          "1125:     ptr = p->data[0] + line * p->linesize[0] + (col * s->desc->nb_components * 2);",
          "1128:          i < s->ysize; i++, ptr += p->linesize[0]) {",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1049:         memset(ptr_x, 0, bxmin);",
          "1050:         ptr_x += s->xmin * s->desc->nb_components;",
          "1051:         if (s->pixel_type == EXR_FLOAT) {",
          "1053:             if (trc_func) {",
          "1055:                     union av_intfloat32 t;",
          "1056:                     t.i = bytestream_get_le32(&r);",
          "1057:                     t.f = trc_func(t.f);",
          "",
          "[Removed Lines]",
          "1054:                 for (x = 0; x < xdelta; x++) {",
          "",
          "[Added Lines]",
          "1147:                 for (x = 0; x < s->xsize; x++) {",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1069:                 }",
          "1070:             } else {",
          "1072:                     union av_intfloat32 t;",
          "1073:                     t.i = bytestream_get_le32(&r);",
          "",
          "[Removed Lines]",
          "1071:                 for (x = 0; x < xdelta; x++) {",
          "",
          "[Added Lines]",
          "1164:                 for (x = 0; x < s->xsize; x++) {",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1090:             }",
          "1091:         } else {",
          "",
          "[Removed Lines]",
          "1093:             for (x = 0; x < xdelta; x++) {",
          "",
          "[Added Lines]",
          "1186:             for (x = 0; x < s->xsize; x++) {",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1103:         memset(ptr_x, 0, axmax);",
          "1110:     }",
          "1112:     return 0;",
          "",
          "[Removed Lines]",
          "1105:         channel_buffer[0] += s->scan_line_size;",
          "1106:         channel_buffer[1] += s->scan_line_size;",
          "1107:         channel_buffer[2] += s->scan_line_size;",
          "1108:         if (channel_buffer[3])",
          "1109:             channel_buffer[3] += s->scan_line_size;",
          "",
          "[Added Lines]",
          "1198:         if (s->is_tile) {",
          "1199:             channel_buffer[0] += channelLineSize;",
          "1200:             channel_buffer[1] += channelLineSize;",
          "1201:             channel_buffer[2] += channelLineSize;",
          "1202:             if (channel_buffer[3])",
          "1203:                 channel_buffer[3] += channelLineSize;",
          "1204:         }",
          "1205:         else{",
          "1206:             channel_buffer[0] += s->scan_line_size;",
          "1207:             channel_buffer[1] += s->scan_line_size;",
          "1208:             channel_buffer[2] += s->scan_line_size;",
          "1209:             if (channel_buffer[3])",
          "1210:                 channel_buffer[3] += s->scan_line_size;",
          "1211:         }",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1156: static int decode_header(EXRContext *s)",
          "1157: {",
          "1161:     s->xmin               = ~0;",
          "1162:     s->xmax               = ~0;",
          "1163:     s->ymin               = ~0;",
          "",
          "[Removed Lines]",
          "1158:     int current_channel_offset = 0;",
          "1159:     int magic_number, version, flags, i, sar = 0;",
          "",
          "[Added Lines]",
          "1260:     int magic_number, version, i, flags, sar = 0;",
          "1262:     s->current_channel_offset = 0;",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1173:     s->nb_channels        = 0;",
          "1174:     s->w                  = 0;",
          "1175:     s->h                  = 0;",
          "1177:     if (bytestream2_get_bytes_left(&s->gb) < 10) {",
          "1178:         av_log(s->avctx, AV_LOG_ERROR, \"Header too short to parse.\\n\");",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1278:     s->tile_attr.xSize    = -1;",
          "1279:     s->tile_attr.ySize    = -1;",
          "1280:     s->is_tile            = 0;",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "1194:     }",
          "1196:     flags = bytestream2_get_le24(&s->gb);",
          "1199:         return AVERROR_PATCHWELCOME;",
          "1200:     }",
          "",
          "[Removed Lines]",
          "1197:     if (flags & 0x02) {",
          "1198:         avpriv_report_missing_feature(s->avctx, \"Tile support\");",
          "",
          "[Added Lines]",
          "1303:     if (flags == 0x00)",
          "1304:         s->is_tile = 0;",
          "1305:     else if (flags & 0x02)",
          "1306:         s->is_tile = 1;",
          "1307:     else{",
          "1308:         avpriv_report_missing_feature(s->avctx, \"flags %d\", flags);",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "1279:                         return AVERROR_INVALIDDATA;",
          "1280:                     }",
          "1281:                     s->pixel_type                     = current_pixel_type;",
          "1283:                 }",
          "1285:                 s->channels = av_realloc(s->channels,",
          "",
          "[Removed Lines]",
          "1282:                     s->channel_offsets[channel_index] = current_channel_offset;",
          "",
          "[Added Lines]",
          "1392:                     s->channel_offsets[channel_index] = s->current_channel_offset;",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "1291:                 channel->xsub       = xsub;",
          "1292:                 channel->ysub       = ysub;",
          "1295:             }",
          "",
          "[Removed Lines]",
          "1294:                 current_channel_offset += 1 << current_pixel_type;",
          "",
          "[Added Lines]",
          "1404:                 s->current_channel_offset += 1 << current_pixel_type;",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "1367:                 av_log(s->avctx, AV_LOG_WARNING,",
          "1368:                        \"Found more than one compression attribute.\\n\");",
          "1370:             continue;",
          "1371:         }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1480:             continue;",
          "1481:         } else if ((var_size = check_header_variable(s, \"tiles\",",
          "1482:                                                      \"tiledesc\", 22)) >= 0) {",
          "1483:             if (!s->is_tile)",
          "1484:                 av_log(s->avctx, AV_LOG_WARNING,",
          "1485:                        \"Found tile attribute and scanline flags. Exr will be interpreted as scanline.\\n\");",
          "1487:             s->tile_attr.xSize = bytestream2_get_le32(&s->gb);",
          "1488:             s->tile_attr.ySize = bytestream2_get_le32(&s->gb);",
          "1490:             char tileLevel = bytestream2_get_byte(&s->gb);",
          "1491:             s->tile_attr.level_mode = tileLevel & 0x0f;",
          "1492:             s->tile_attr.level_round = (tileLevel >> 4) & 0x0f;",
          "1494:             if (s->tile_attr.level_mode != EXR_TILE_LEVEL_ONE) {",
          "1495:                 avpriv_report_missing_feature(s->avctx, \"Tile level mode %d\",",
          "1496:                                               s->tile_attr.level_mode);",
          "1497:                 return AVERROR_PATCHWELCOME;",
          "1498:             }",
          "1500:             if (s->tile_attr.level_round != EXR_TILE_ROUND_UP) {",
          "1501:                 avpriv_report_missing_feature(s->avctx, \"Tile level round %d\",",
          "1502:                                               s->tile_attr.level_round);",
          "1503:                 return AVERROR_PATCHWELCOME;",
          "1504:             }",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "1390:         av_log(s->avctx, AV_LOG_ERROR, \"Missing compression attribute.\\n\");",
          "1391:         return AVERROR_INVALIDDATA;",
          "1392:     }",
          "1395:     if (bytestream2_get_bytes_left(&s->gb) <= 0) {",
          "1396:         av_log(s->avctx, AV_LOG_ERROR, \"Incomplete frame.\\n\");",
          "",
          "[Removed Lines]",
          "1393:     s->scan_line_size = s->xdelta * current_channel_offset;",
          "",
          "[Added Lines]",
          "1530:     if (s->is_tile) {",
          "1531:         if (s->tile_attr.xSize < 1 || s->tile_attr.ySize < 1) {",
          "1532:             av_log(s->avctx, AV_LOG_ERROR, \"Invalid tile attribute.\\n\");",
          "1533:             return AVERROR_INVALIDDATA;",
          "1534:         }",
          "1536:         if (s->compression != EXR_RAW) {",
          "1537:             avpriv_report_missing_feature(s->avctx, \"Compression in tile %d\", s->compression);",
          "1538:             return AVERROR_PATCHWELCOME;",
          "1539:         }",
          "1540:     }",
          "1542:     s->scan_line_size = s->xdelta * s->current_channel_offset;",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "1413:     int y, ret;",
          "1414:     int out_line_size;",
          "1417:     bytestream2_init(&s->gb, avpkt->data, avpkt->size);",
          "",
          "[Removed Lines]",
          "1415:     int scan_line_blocks;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "1476:     if (!s->desc)",
          "1477:         return AVERROR_INVALIDDATA;",
          "1478:     out_line_size    = avctx->width * 2 * s->desc->nb_components;",
          "1482:     if ((ret = ff_thread_get_buffer(avctx, &frame, 0)) < 0)",
          "1483:         return ret;",
          "1486:         return AVERROR_INVALIDDATA;",
          "",
          "[Removed Lines]",
          "1479:     scan_line_blocks = (s->ydelta + s->scan_lines_per_block - 1) /",
          "1480:                        s->scan_lines_per_block;",
          "1485:     if (bytestream2_get_bytes_left(&s->gb) < scan_line_blocks * 8)",
          "",
          "[Added Lines]",
          "1629:     if (s->is_tile) {",
          "1630:         nb_blocks = ((s->xdelta + s->tile_attr.xSize - 1) / s->tile_attr.xSize) *",
          "1631:         ((s->ydelta + s->tile_attr.ySize - 1) / s->tile_attr.ySize);",
          "1633:         nb_blocks = (s->ydelta + s->scan_lines_per_block - 1) /",
          "1634:         s->scan_lines_per_block;",
          "1635:     }",
          "1640:     if (bytestream2_get_bytes_left(&s->gb) < nb_blocks * 8)",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "1497:     }",
          "1499:     s->picture = picture;",
          "1503:     for (y = s->ymax + 1; y < avctx->height; y++) {",
          "",
          "[Removed Lines]",
          "1500:     avctx->execute2(avctx, decode_block, s->thread_data, NULL, scan_line_blocks);",
          "",
          "[Added Lines]",
          "1656:     avctx->execute2(avctx, decode_block, s->thread_data, NULL, nb_blocks);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
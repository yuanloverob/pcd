{
  "cve_id": "CVE-2017-7889",
  "cve_desc": "The mm subsystem in the Linux kernel through 3.2 does not properly enforce the CONFIG_STRICT_DEVMEM protection mechanism, which allows local users to read or write to kernel memory locations in the first megabyte (and bypass slab-allocation access restrictions) via an application that opens the /dev/mem file, related to arch/x86/mm/init.c and drivers/char/mem.c.",
  "repo": "torvalds/linux",
  "patch_hash": "a4866aa812518ed1a37d8ea0c881dc946409de94",
  "patch_info": {
    "commit_hash": "a4866aa812518ed1a37d8ea0c881dc946409de94",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/a4866aa812518ed1a37d8ea0c881dc946409de94",
    "files": [
      "arch/x86/mm/init.c",
      "drivers/char/mem.c"
    ],
    "message": "mm: Tighten x86 /dev/mem with zeroing reads\n\nUnder CONFIG_STRICT_DEVMEM, reading System RAM through /dev/mem is\ndisallowed. However, on x86, the first 1MB was always allowed for BIOS\nand similar things, regardless of it actually being System RAM. It was\npossible for heap to end up getting allocated in low 1MB RAM, and then\nread by things like x86info or dd, which would trip hardened usercopy:\n\nusercopy: kernel memory exposure attempt detected from ffff880000090000 (dma-kmalloc-256) (4096 bytes)\n\nThis changes the x86 exception for the low 1MB by reading back zeros for\nSystem RAM areas instead of blindly allowing them. More work is needed to\nextend this to mmap, but currently mmap doesn't go through usercopy, so\nhardened usercopy won't Oops the kernel.\n\nReported-by: Tommi Rantala <tommi.t.rantala@nokia.com>\nTested-by: Tommi Rantala <tommi.t.rantala@nokia.com>\nSigned-off-by: Kees Cook <keescook@chromium.org>",
    "before_after_code_files": [
      "arch/x86/mm/init.c||arch/x86/mm/init.c",
      "drivers/char/mem.c||drivers/char/mem.c"
    ]
  },
  "patch_diff": {
    "arch/x86/mm/init.c||arch/x86/mm/init.c": [
      "File: arch/x86/mm/init.c -> arch/x86/mm/init.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "652: int devmem_is_allowed(unsigned long pagenr)",
      "653: {",
      "657:   return 0;",
      "661: }",
      "663: void free_init_pages(char *what, unsigned long begin, unsigned long end)",
      "",
      "[Removed Lines]",
      "654:  if (pagenr < 256)",
      "655:   return 1;",
      "656:  if (iomem_is_exclusive(pagenr << PAGE_SHIFT))",
      "658:  if (!page_is_ram(pagenr))",
      "659:   return 1;",
      "660:  return 0;",
      "",
      "[Added Lines]",
      "656:  if (page_is_ram(pagenr)) {",
      "661:   if (pagenr < 256)",
      "662:    return 2;",
      "664:   return 0;",
      "665:  }",
      "671:  if (iomem_is_exclusive(pagenr << PAGE_SHIFT)) {",
      "673:   if (pagenr < 256)",
      "674:    return 1;",
      "677:  }",
      "679:  return 1;",
      "",
      "---------------"
    ],
    "drivers/char/mem.c||drivers/char/mem.c": [
      "File: drivers/char/mem.c -> drivers/char/mem.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "60: #endif",
      "62: #ifdef CONFIG_STRICT_DEVMEM",
      "63: static inline int range_is_allowed(unsigned long pfn, unsigned long size)",
      "64: {",
      "65:  u64 from = ((u64)pfn) << PAGE_SHIFT;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "63: static inline int page_is_allowed(unsigned long pfn)",
      "64: {",
      "65:  return devmem_is_allowed(pfn);",
      "66: }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "75:  return 1;",
      "76: }",
      "77: #else",
      "78: static inline int range_is_allowed(unsigned long pfn, unsigned long size)",
      "79: {",
      "80:  return 1;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "82: static inline int page_is_allowed(unsigned long pfn)",
      "83: {",
      "84:  return 1;",
      "85: }",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "123:  while (count > 0) {",
      "124:   unsigned long remaining;",
      "126:   sz = size_inside_page(p, count);",
      "129:    return -EPERM;",
      "142:   if (remaining)",
      "143:    return -EFAULT;",
      "",
      "[Removed Lines]",
      "128:   if (!range_is_allowed(p >> PAGE_SHIFT, count))",
      "136:   ptr = xlate_dev_mem_ptr(p);",
      "137:   if (!ptr)",
      "138:    return -EFAULT;",
      "140:   remaining = copy_to_user(buf, ptr, sz);",
      "141:   unxlate_dev_mem_ptr(p, ptr);",
      "",
      "[Added Lines]",
      "133:   int allowed;",
      "137:   allowed = page_is_allowed(p >> PAGE_SHIFT);",
      "138:   if (!allowed)",
      "140:   if (allowed == 2) {",
      "142:    remaining = clear_user(buf, sz);",
      "143:   } else {",
      "149:    ptr = xlate_dev_mem_ptr(p);",
      "150:    if (!ptr)",
      "151:     return -EFAULT;",
      "153:    remaining = copy_to_user(buf, ptr, sz);",
      "155:    unxlate_dev_mem_ptr(p, ptr);",
      "156:   }",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "181: #endif",
      "183:  while (count > 0) {",
      "184:   sz = size_inside_page(p, count);",
      "187:    return -EPERM;",
      "208:   }",
      "210:   buf += sz;",
      "",
      "[Removed Lines]",
      "186:   if (!range_is_allowed(p >> PAGE_SHIFT, sz))",
      "194:   ptr = xlate_dev_mem_ptr(p);",
      "195:   if (!ptr) {",
      "196:    if (written)",
      "197:     break;",
      "198:    return -EFAULT;",
      "199:   }",
      "201:   copied = copy_from_user(ptr, buf, sz);",
      "202:   unxlate_dev_mem_ptr(p, ptr);",
      "203:   if (copied) {",
      "204:    written += sz - copied;",
      "205:    if (written)",
      "206:     break;",
      "207:    return -EFAULT;",
      "",
      "[Added Lines]",
      "200:   int allowed;",
      "204:   allowed = page_is_allowed(p >> PAGE_SHIFT);",
      "205:   if (!allowed)",
      "209:   if (allowed == 1) {",
      "215:    ptr = xlate_dev_mem_ptr(p);",
      "216:    if (!ptr) {",
      "217:     if (written)",
      "218:      break;",
      "219:     return -EFAULT;",
      "220:    }",
      "222:    copied = copy_from_user(ptr, buf, sz);",
      "223:    unxlate_dev_mem_ptr(p, ptr);",
      "224:    if (copied) {",
      "225:     written += sz - copied;",
      "226:     if (written)",
      "227:      break;",
      "228:     return -EFAULT;",
      "229:    }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "22ec1a2aea73b9dfe340dff7945bd85af4cc6280",
      "candidate_info": {
        "commit_hash": "22ec1a2aea73b9dfe340dff7945bd85af4cc6280",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/22ec1a2aea73b9dfe340dff7945bd85af4cc6280",
        "files": [
          "drivers/char/mem.c",
          "security/Kconfig"
        ],
        "message": "/dev/mem: Add bounce buffer for copy-out\n\nAs done for /proc/kcore in\n\n  commit df04abfd181a (\"fs/proc/kcore.c: Add bounce buffer for ktext data\")\n\nthis adds a bounce buffer when reading memory via /dev/mem. This\nis needed to allow kernel text memory to be read out when built with\nCONFIG_HARDENED_USERCOPY (which refuses to read out kernel text) and\nwithout CONFIG_STRICT_DEVMEM (which would have refused to read any RAM\ncontents at all).\n\nSince this build configuration isn't common (most systems with\nCONFIG_HARDENED_USERCOPY also have CONFIG_STRICT_DEVMEM), this also tries\nto inform Kconfig about the recommended settings.\n\nThis patch is modified from Brad Spengler/PaX Team's changes to /dev/mem\ncode in the last public patch of grsecurity/PaX based on my understanding\nof the code. Changes or omissions from the original code are mine and\ndon't reflect the original grsecurity/PaX code.\n\nReported-by: Michael Holzheu <holzheu@linux.vnet.ibm.com>\nFixes: f5509cc18daa (\"mm: Hardened usercopy\")\nSigned-off-by: Kees Cook <keescook@chromium.org>\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>",
        "before_after_code_files": [
          "drivers/char/mem.c||drivers/char/mem.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "drivers/char/mem.c||drivers/char/mem.c"
          ],
          "candidate": [
            "drivers/char/mem.c||drivers/char/mem.c"
          ]
        }
      },
      "candidate_diff": {
        "drivers/char/mem.c||drivers/char/mem.c": [
          "File: drivers/char/mem.c -> drivers/char/mem.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "107:  phys_addr_t p = *ppos;",
          "108:  ssize_t read, sz;",
          "109:  void *ptr;",
          "111:  if (p != *ppos)",
          "112:   return 0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "110:  char *bounce;",
          "111:  int err;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "129:  }",
          "130: #endif",
          "132:  while (count > 0) {",
          "133:   unsigned long remaining;",
          "134:   int allowed;",
          "136:   sz = size_inside_page(p, count);",
          "138:   allowed = page_is_allowed(p >> PAGE_SHIFT);",
          "139:   if (!allowed)",
          "141:   if (allowed == 2) {",
          "143:    remaining = clear_user(buf, sz);",
          "",
          "[Removed Lines]",
          "140:    return -EPERM;",
          "",
          "[Added Lines]",
          "134:  bounce = kmalloc(PAGE_SIZE, GFP_KERNEL);",
          "135:  if (!bounce)",
          "136:   return -ENOMEM;",
          "144:   err = -EPERM;",
          "147:    goto failed;",
          "149:   err = -EFAULT;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "150:    ptr = xlate_dev_mem_ptr(p);",
          "151:    if (!ptr)",
          "156:    unxlate_dev_mem_ptr(p, ptr);",
          "157:   }",
          "159:   if (remaining)",
          "162:   buf += sz;",
          "163:   p += sz;",
          "164:   count -= sz;",
          "165:   read += sz;",
          "166:  }",
          "169:  return read;",
          "170: }",
          "172: static ssize_t write_mem(struct file *file, const char __user *buf,",
          "",
          "[Removed Lines]",
          "152:     return -EFAULT;",
          "154:    remaining = copy_to_user(buf, ptr, sz);",
          "160:    return -EFAULT;",
          "",
          "[Added Lines]",
          "161:     goto failed;",
          "163:    err = probe_kernel_read(bounce, ptr, sz);",
          "165:    if (err)",
          "166:     goto failed;",
          "168:    remaining = copy_to_user(buf, bounce, sz);",
          "172:    goto failed;",
          "179:  kfree(bounce);",
          "184: failed:",
          "185:  kfree(bounce);",
          "186:  return err;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b5b38200ebe54879a7264cb6f33821f61c586a7e",
      "candidate_info": {
        "commit_hash": "b5b38200ebe54879a7264cb6f33821f61c586a7e",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/b5b38200ebe54879a7264cb6f33821f61c586a7e",
        "files": [
          "drivers/char/mem.c"
        ],
        "message": "/dev/mem: Avoid overwriting \"err\" in read_mem()\n\nSuccesses in probe_kernel_read() would mask failures in copy_to_user()\nduring read_mem().\n\nReported-by: Brad Spengler <spender@grsecurity.net>\nFixes: 22ec1a2aea73 (\"/dev/mem: Add bounce buffer for copy-out\")\nCc: stable@vger.kernel.org\nSigned-off-by: Kees Cook <keescook@chromium.org>\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>",
        "before_after_code_files": [
          "drivers/char/mem.c||drivers/char/mem.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "drivers/char/mem.c||drivers/char/mem.c"
          ],
          "candidate": [
            "drivers/char/mem.c||drivers/char/mem.c"
          ]
        }
      },
      "candidate_diff": {
        "drivers/char/mem.c||drivers/char/mem.c": [
          "File: drivers/char/mem.c -> drivers/char/mem.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "138:  while (count > 0) {",
          "139:   unsigned long remaining;",
          "142:   sz = size_inside_page(p, count);",
          "",
          "[Removed Lines]",
          "140:   int allowed;",
          "",
          "[Added Lines]",
          "140:   int allowed, probe;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "160:    if (!ptr)",
          "161:     goto failed;",
          "164:    unxlate_dev_mem_ptr(p, ptr);",
          "166:     goto failed;",
          "168:    remaining = copy_to_user(buf, bounce, sz);",
          "",
          "[Removed Lines]",
          "163:    err = probe_kernel_read(bounce, ptr, sz);",
          "165:    if (err)",
          "",
          "[Added Lines]",
          "163:    probe = probe_kernel_read(bounce, ptr, sz);",
          "165:    if (probe)",
          "",
          "---------------"
        ]
      }
    }
  ]
}
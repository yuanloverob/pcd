{
  "cve_id": "CVE-2020-27194",
  "cve_desc": "An issue was discovered in the Linux kernel before 5.8.15. scalar32_min_max_or in kernel/bpf/verifier.c mishandles bounds tracking during use of 64-bit values, aka CID-5b9fbeb75b6a.",
  "repo": "torvalds/linux",
  "patch_hash": "5b9fbeb75b6a98955f628e205ac26689bcb1383e",
  "patch_info": {
    "commit_hash": "5b9fbeb75b6a98955f628e205ac26689bcb1383e",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/5b9fbeb75b6a98955f628e205ac26689bcb1383e",
    "files": [
      "kernel/bpf/verifier.c"
    ],
    "message": "bpf: Fix scalar32_min_max_or bounds tracking\n\nSimon reported an issue with the current scalar32_min_max_or() implementation.\nThat is, compared to the other 32 bit subreg tracking functions, the code in\nscalar32_min_max_or() stands out that it's using the 64 bit registers instead\nof 32 bit ones. This leads to bounds tracking issues, for example:\n\n  [...]\n  8: R0=map_value(id=0,off=0,ks=4,vs=48,imm=0) R10=fp0 fp-8=mmmmmmmm\n  8: (79) r1 = *(u64 *)(r0 +0)\n   R0=map_value(id=0,off=0,ks=4,vs=48,imm=0) R10=fp0 fp-8=mmmmmmmm\n  9: R0=map_value(id=0,off=0,ks=4,vs=48,imm=0) R1_w=inv(id=0) R10=fp0 fp-8=mmmmmmmm\n  9: (b7) r0 = 1\n  10: R0_w=inv1 R1_w=inv(id=0) R10=fp0 fp-8=mmmmmmmm\n  10: (18) r2 = 0x600000002\n  12: R0_w=inv1 R1_w=inv(id=0) R2_w=inv25769803778 R10=fp0 fp-8=mmmmmmmm\n  12: (ad) if r1 < r2 goto pc+1\n   R0_w=inv1 R1_w=inv(id=0,umin_value=25769803778) R2_w=inv25769803778 R10=fp0 fp-8=mmmmmmmm\n  13: R0_w=inv1 R1_w=inv(id=0,umin_value=25769803778) R2_w=inv25769803778 R10=fp0 fp-8=mmmmmmmm\n  13: (95) exit\n  14: R0_w=inv1 R1_w=inv(id=0,umax_value=25769803777,var_off=(0x0; 0x7ffffffff)) R2_w=inv25769803778 R10=fp0 fp-8=mmmmmmmm\n  14: (25) if r1 > 0x0 goto pc+1\n   R0_w=inv1 R1_w=inv(id=0,umax_value=0,var_off=(0x0; 0x7fffffff),u32_max_value=2147483647) R2_w=inv25769803778 R10=fp0 fp-8=mmmmmmmm\n  15: R0_w=inv1 R1_w=inv(id=0,umax_value=0,var_off=(0x0; 0x7fffffff),u32_max_value=2147483647) R2_w=inv25769803778 R10=fp0 fp-8=mmmmmmmm\n  15: (95) exit\n  16: R0_w=inv1 R1_w=inv(id=0,umin_value=1,umax_value=25769803777,var_off=(0x0; 0x77fffffff),u32_max_value=2147483647) R2_w=inv25769803778 R10=fp0 fp-8=mmmmmmmm\n  16: (47) r1 |= 0\n  17: R0_w=inv1 R1_w=inv(id=0,umin_value=1,umax_value=32212254719,var_off=(0x1; 0x700000000),s32_max_value=1,u32_max_value=1) R2_w=inv25769803778 R10=fp0 fp-8=mmmmmmmm\n  [...]\n\nThe bound tests on the map value force the upper unsigned bound to be 25769803777\nin 64 bit (0b11000000000000000000000000000000001) and then lower one to be 1. By\nusing OR they are truncated and thus result in the range [1,1] for the 32 bit reg\ntracker. This is incorrect given the only thing we know is that the value must be\npositive and thus 2147483647 (0b1111111111111111111111111111111) at max for the\nsubregs. Fix it by using the {u,s}32_{min,max}_value vars instead. This also makes\nsense, for example, for the case where we update dst_reg->s32_{min,max}_value in\nthe else branch we need to use the newly computed dst_reg->u32_{min,max}_value as\nwe know that these are positive. Previously, in the else branch the 64 bit values\nof umin_value=1 and umax_value=32212254719 were used and latter got truncated to\nbe 1 as upper bound there. After the fix the subreg range is now correct:\n\n  [...]\n  8: R0=map_value(id=0,off=0,ks=4,vs=48,imm=0) R10=fp0 fp-8=mmmmmmmm\n  8: (79) r1 = *(u64 *)(r0 +0)\n   R0=map_value(id=0,off=0,ks=4,vs=48,imm=0) R10=fp0 fp-8=mmmmmmmm\n  9: R0=map_value(id=0,off=0,ks=4,vs=48,imm=0) R1_w=inv(id=0) R10=fp0 fp-8=mmmmmmmm\n  9: (b7) r0 = 1\n  10: R0_w=inv1 R1_w=inv(id=0) R10=fp0 fp-8=mmmmmmmm\n  10: (18) r2 = 0x600000002\n  12: R0_w=inv1 R1_w=inv(id=0) R2_w=inv25769803778 R10=fp0 fp-8=mmmmmmmm\n  12: (ad) if r1 < r2 goto pc+1\n   R0_w=inv1 R1_w=inv(id=0,umin_value=25769803778) R2_w=inv25769803778 R10=fp0 fp-8=mmmmmmmm\n  13: R0_w=inv1 R1_w=inv(id=0,umin_value=25769803778) R2_w=inv25769803778 R10=fp0 fp-8=mmmmmmmm\n  13: (95) exit\n  14: R0_w=inv1 R1_w=inv(id=0,umax_value=25769803777,var_off=(0x0; 0x7ffffffff)) R2_w=inv25769803778 R10=fp0 fp-8=mmmmmmmm\n  14: (25) if r1 > 0x0 goto pc+1\n   R0_w=inv1 R1_w=inv(id=0,umax_value=0,var_off=(0x0; 0x7fffffff),u32_max_value=2147483647) R2_w=inv25769803778 R10=fp0 fp-8=mmmmmmmm\n  15: R0_w=inv1 R1_w=inv(id=0,umax_value=0,var_off=(0x0; 0x7fffffff),u32_max_value=2147483647) R2_w=inv25769803778 R10=fp0 fp-8=mmmmmmmm\n  15: (95) exit\n  16: R0_w=inv1 R1_w=inv(id=0,umin_value=1,umax_value=25769803777,var_off=(0x0; 0x77fffffff),u32_max_value=2147483647) R2_w=inv25769803778 R10=fp0 fp-8=mmmmmmmm\n  16: (47) r1 |= 0\n  17: R0_w=inv1 R1_w=inv(id=0,umin_value=1,umax_value=32212254719,var_off=(0x0; 0x77fffffff),u32_max_value=2147483647) R2_w=inv25769803778 R10=fp0 fp-8=mmmmmmmm\n  [...]\n\nFixes: 3f50f132d840 (\"bpf: Verifier, do explicit ALU32 bounds tracking\")\nReported-by: Simon Scannell <scannell.smn@gmail.com>\nSigned-off-by: Daniel Borkmann <daniel@iogearbox.net>\nReviewed-by: John Fastabend <john.fastabend@gmail.com>\nAcked-by: Alexei Starovoitov <ast@kernel.org>",
    "before_after_code_files": [
      "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
    ]
  },
  "patch_diff": {
    "kernel/bpf/verifier.c||kernel/bpf/verifier.c": [
      "File: kernel/bpf/verifier.c -> kernel/bpf/verifier.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "5667:  bool src_known = tnum_subreg_is_const(src_reg->var_off);",
      "5668:  bool dst_known = tnum_subreg_is_const(dst_reg->var_off);",
      "5669:  struct tnum var32_off = tnum_subreg(dst_reg->var_off);",
      "",
      "[Removed Lines]",
      "5670:  s32 smin_val = src_reg->smin_value;",
      "5671:  u32 umin_val = src_reg->umin_value;",
      "",
      "[Added Lines]",
      "5670:  s32 smin_val = src_reg->s32_min_value;",
      "5671:  u32 umin_val = src_reg->u32_min_value;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "5696:  }",
      "5697: }",
      "",
      "[Removed Lines]",
      "5694:   dst_reg->s32_min_value = dst_reg->umin_value;",
      "5695:   dst_reg->s32_max_value = dst_reg->umax_value;",
      "",
      "[Added Lines]",
      "5694:   dst_reg->s32_min_value = dst_reg->u32_min_value;",
      "5695:   dst_reg->s32_max_value = dst_reg->u32_max_value;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "3f50f132d8400e129fc9eb68b5020167ef80a244",
      "candidate_info": {
        "commit_hash": "3f50f132d8400e129fc9eb68b5020167ef80a244",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/3f50f132d8400e129fc9eb68b5020167ef80a244",
        "files": [
          "include/linux/bpf_verifier.h",
          "include/linux/limits.h",
          "include/linux/tnum.h",
          "kernel/bpf/tnum.c",
          "kernel/bpf/verifier.c"
        ],
        "message": "bpf: Verifier, do explicit ALU32 bounds tracking\n\nIt is not possible for the current verifier to track ALU32 and JMP ops\ncorrectly. This can result in the verifier aborting with errors even though\nthe program should be verifiable. BPF codes that hit this can work around\nit by changin int variables to 64-bit types, marking variables volatile,\netc. But this is all very ugly so it would be better to avoid these tricks.\n\nBut, the main reason to address this now is do_refine_retval_range() was\nassuming return values could not be negative. Once we fixed this code that\nwas previously working will no longer work. See do_refine_retval_range()\npatch for details. And we don't want to suddenly cause programs that used\nto work to fail.\n\nThe simplest example code snippet that illustrates the problem is likely\nthis,\n\n 53: w8 = w0                    // r8 <- [0, S32_MAX],\n                                // w8 <- [-S32_MIN, X]\n 54: w8 <s 0                    // r8 <- [0, U32_MAX]\n                                // w8 <- [0, X]\n\nThe expected 64-bit and 32-bit bounds after each line are shown on the\nright. The current issue is without the w* bounds we are forced to use\nthe worst case bound of [0, U32_MAX]. To resolve this type of case,\njmp32 creating divergent 32-bit bounds from 64-bit bounds, we add explicit\n32-bit register bounds s32_{min|max}_value and u32_{min|max}_value. Then\nfrom branch_taken logic creating new bounds we can track 32-bit bounds\nexplicitly.\n\nThe next case we observed is ALU ops after the jmp32,\n\n 53: w8 = w0                    // r8 <- [0, S32_MAX],\n                                // w8 <- [-S32_MIN, X]\n 54: w8 <s 0                    // r8 <- [0, U32_MAX]\n                                // w8 <- [0, X]\n 55: w8 += 1                    // r8 <- [0, U32_MAX+1]\n                                // w8 <- [0, X+1]\n\nIn order to keep the bounds accurate at this point we also need to track\nALU32 ops. To do this we add explicit ALU32 logic for each of the ALU\nops, mov, add, sub, etc.\n\nFinally there is a question of how and when to merge bounds. The cases\nenumerate here,\n\n1. MOV ALU32   - zext 32-bit -> 64-bit\n2. MOV ALU64   - copy 64-bit -> 32-bit\n3. op  ALU32   - zext 32-bit -> 64-bit\n4. op  ALU64   - n/a\n5. jmp ALU32   - 64-bit: var32_off | upper_32_bits(var64_off)\n6. jmp ALU64   - 32-bit: (>> (<< var64_off))\n\nDetails for each case,\n\nFor \"MOV ALU32\" BPF arch zero extends so we simply copy the bounds\nfrom 32-bit into 64-bit ensuring we truncate var_off and 64-bit\nbounds correctly. See zext_32_to_64.\n\nFor \"MOV ALU64\" copy all bounds including 32-bit into new register. If\nthe src register had 32-bit bounds the dst register will as well.\n\nFor \"op ALU32\" zero extend 32-bit into 64-bit the same as move,\nsee zext_32_to_64.\n\nFor \"op ALU64\" calculate both 32-bit and 64-bit bounds no merging\nis done here. Except we have a special case. When RSH or ARSH is\ndone we can't simply ignore shifting bits from 64-bit reg into the\n32-bit subreg. So currently just push bounds from 64-bit into 32-bit.\nThis will be correct in the sense that they will represent a valid\nstate of the register. However we could lose some accuracy if an\nARSH is following a jmp32 operation. We can handle this special\ncase in a follow up series.\n\nFor \"jmp ALU32\" mark 64-bit reg unknown and recalculate 64-bit bounds\nfrom tnum by setting var_off to ((<<(>>var_off)) | var32_off). We\nspecial case if 64-bit bounds has zero'd upper 32bits at which point\nwe can simply copy 32-bit bounds into 64-bit register. This catches\na common compiler trick where upper 32-bits are zeroed and then\n32-bit ops are used followed by a 64-bit compare or 64-bit op on\na pointer. See __reg_combine_64_into_32().\n\nFor \"jmp ALU64\" cast the bounds of the 64bit to their 32-bit\ncounterpart. For example s32_min_value = (s32)reg->smin_value. For\ntnum use only the lower 32bits via, (>>(<<var_off)). See\n__reg_combine_64_into_32().\n\nSigned-off-by: John Fastabend <john.fastabend@gmail.com>\nSigned-off-by: Alexei Starovoitov <ast@kernel.org>\nLink: https://lore.kernel.org/bpf/158560419880.10843.11448220440809118343.stgit@john-Precision-5820-Tower",
        "before_after_code_files": [
          "include/linux/bpf_verifier.h||include/linux/bpf_verifier.h",
          "include/linux/limits.h||include/linux/limits.h",
          "include/linux/tnum.h||include/linux/tnum.h",
          "kernel/bpf/tnum.c||kernel/bpf/tnum.c",
          "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
          ],
          "candidate": [
            "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
          ]
        }
      },
      "candidate_diff": {
        "include/linux/bpf_verifier.h||include/linux/bpf_verifier.h": [
          "File: include/linux/bpf_verifier.h -> include/linux/bpf_verifier.h"
        ],
        "include/linux/limits.h||include/linux/limits.h": [
          "File: include/linux/limits.h -> include/linux/limits.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "27: #define S16_MAX  ((s16)(U16_MAX >> 1))",
          "28: #define S16_MIN  ((s16)(-S16_MAX - 1))",
          "29: #define U32_MAX  ((u32)~0U)",
          "30: #define S32_MAX  ((s32)(U32_MAX >> 1))",
          "31: #define S32_MIN  ((s32)(-S32_MAX - 1))",
          "32: #define U64_MAX  ((u64)~0ULL)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "30: #define U32_MIN  ((u32)0)",
          "",
          "---------------"
        ],
        "include/linux/tnum.h||include/linux/tnum.h": [
          "File: include/linux/tnum.h -> include/linux/tnum.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "87: int tnum_sbin(char *str, size_t size, struct tnum a);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "90: struct tnum tnum_subreg(struct tnum a);",
          "92: struct tnum tnum_clear_subreg(struct tnum a);",
          "94: struct tnum tnum_const_subreg(struct tnum a, u32 value);",
          "96: static inline bool tnum_subreg_is_const(struct tnum a)",
          "97: {",
          "98:  return !(tnum_subreg(a)).mask;",
          "99: }",
          "",
          "---------------"
        ],
        "kernel/bpf/tnum.c||kernel/bpf/tnum.c": [
          "File: kernel/bpf/tnum.c -> kernel/bpf/tnum.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "194:  str[min(size - 1, (size_t)64)] = 0;",
          "195:  return 64;",
          "196: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "198: struct tnum tnum_subreg(struct tnum a)",
          "199: {",
          "200:  return tnum_cast(a, 4);",
          "201: }",
          "203: struct tnum tnum_clear_subreg(struct tnum a)",
          "204: {",
          "205:  return tnum_lshift(tnum_rshift(a, 32), 32);",
          "206: }",
          "208: struct tnum tnum_const_subreg(struct tnum a, u32 value)",
          "209: {",
          "210:  return tnum_or(tnum_clear_subreg(a), tnum_const(value));",
          "211: }",
          "",
          "---------------"
        ],
        "kernel/bpf/verifier.c||kernel/bpf/verifier.c": [
          "File: kernel/bpf/verifier.c -> kernel/bpf/verifier.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "550:      tnum_strn(tn_buf, sizeof(tn_buf), reg->var_off);",
          "551:      verbose(env, \",var_off=%s\", tn_buf);",
          "552:     }",
          "553:    }",
          "554:    verbose(env, \")\");",
          "555:   }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "553:     if (reg->s32_min_value != reg->smin_value &&",
          "554:         reg->s32_min_value != S32_MIN)",
          "555:      verbose(env, \",s32_min_value=%d\",",
          "556:       (int)(reg->s32_min_value));",
          "557:     if (reg->s32_max_value != reg->smax_value &&",
          "558:         reg->s32_max_value != S32_MAX)",
          "559:      verbose(env, \",s32_max_value=%d\",",
          "560:       (int)(reg->s32_max_value));",
          "561:     if (reg->u32_min_value != reg->umin_value &&",
          "562:         reg->u32_min_value != U32_MIN)",
          "563:      verbose(env, \",u32_min_value=%d\",",
          "564:       (int)(reg->u32_min_value));",
          "565:     if (reg->u32_max_value != reg->umax_value &&",
          "566:         reg->u32_max_value != U32_MAX)",
          "567:      verbose(env, \",u32_max_value=%d\",",
          "568:       (int)(reg->u32_max_value));",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "924:  reg->smax_value = (s64)imm;",
          "925:  reg->umin_value = imm;",
          "926:  reg->umax_value = imm;",
          "927: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "944:  reg->s32_min_value = (s32)imm;",
          "945:  reg->s32_max_value = (s32)imm;",
          "946:  reg->u32_min_value = (u32)imm;",
          "947:  reg->u32_max_value = (u32)imm;",
          "948: }",
          "950: static void __mark_reg32_known(struct bpf_reg_state *reg, u64 imm)",
          "951: {",
          "952:  reg->var_off = tnum_const_subreg(reg->var_off, imm);",
          "953:  reg->s32_min_value = (s32)imm;",
          "954:  reg->s32_max_value = (s32)imm;",
          "955:  reg->u32_min_value = (u32)imm;",
          "956:  reg->u32_max_value = (u32)imm;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "978:         tnum_equals_const(reg->var_off, 0);",
          "979: }",
          "983: {",
          "985:  reg->smin_value = max_t(s64, reg->smin_value,",
          "",
          "[Removed Lines]",
          "982: static void __update_reg_bounds(struct bpf_reg_state *reg)",
          "",
          "[Added Lines]",
          "1012: static void __mark_reg_unbounded(struct bpf_reg_state *reg)",
          "1013: {",
          "1014:  reg->smin_value = S64_MIN;",
          "1015:  reg->smax_value = S64_MAX;",
          "1016:  reg->umin_value = 0;",
          "1017:  reg->umax_value = U64_MAX;",
          "1019:  reg->s32_min_value = S32_MIN;",
          "1020:  reg->s32_max_value = S32_MAX;",
          "1021:  reg->u32_min_value = 0;",
          "1022:  reg->u32_max_value = U32_MAX;",
          "1023: }",
          "1025: static void __mark_reg64_unbounded(struct bpf_reg_state *reg)",
          "1026: {",
          "1027:  reg->smin_value = S64_MIN;",
          "1028:  reg->smax_value = S64_MAX;",
          "1029:  reg->umin_value = 0;",
          "1030:  reg->umax_value = U64_MAX;",
          "1031: }",
          "1033: static void __mark_reg32_unbounded(struct bpf_reg_state *reg)",
          "1034: {",
          "1035:  reg->s32_min_value = S32_MIN;",
          "1036:  reg->s32_max_value = S32_MAX;",
          "1037:  reg->u32_min_value = 0;",
          "1038:  reg->u32_max_value = U32_MAX;",
          "1039: }",
          "1041: static void __update_reg32_bounds(struct bpf_reg_state *reg)",
          "1042: {",
          "1043:  struct tnum var32_off = tnum_subreg(reg->var_off);",
          "1046:  reg->s32_min_value = max_t(s32, reg->s32_min_value,",
          "1047:    var32_off.value | (var32_off.mask & S32_MIN));",
          "1049:  reg->s32_max_value = min_t(s32, reg->s32_max_value,",
          "1050:    var32_off.value | (var32_off.mask & S32_MAX));",
          "1051:  reg->u32_min_value = max_t(u32, reg->u32_min_value, (u32)var32_off.value);",
          "1052:  reg->u32_max_value = min(reg->u32_max_value,",
          "1053:      (u32)(var32_off.value | var32_off.mask));",
          "1054: }",
          "1056: static void __update_reg64_bounds(struct bpf_reg_state *reg)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "992:          reg->var_off.value | reg->var_off.mask);",
          "993: }",
          "997: {",
          "",
          "[Removed Lines]",
          "996: static void __reg_deduce_bounds(struct bpf_reg_state *reg)",
          "",
          "[Added Lines]",
          "1069: static void __update_reg_bounds(struct bpf_reg_state *reg)",
          "1070: {",
          "1071:  __update_reg32_bounds(reg);",
          "1072:  __update_reg64_bounds(reg);",
          "1073: }",
          "1076: static void __reg32_deduce_bounds(struct bpf_reg_state *reg)",
          "1077: {",
          "1083:  if (reg->s32_min_value >= 0 || reg->s32_max_value < 0) {",
          "1084:   reg->s32_min_value = reg->u32_min_value =",
          "1085:    max_t(u32, reg->s32_min_value, reg->u32_min_value);",
          "1086:   reg->s32_max_value = reg->u32_max_value =",
          "1087:    min_t(u32, reg->s32_max_value, reg->u32_max_value);",
          "1088:   return;",
          "1089:  }",
          "1093:  if ((s32)reg->u32_max_value >= 0) {",
          "1097:   reg->s32_min_value = reg->u32_min_value;",
          "1098:   reg->s32_max_value = reg->u32_max_value =",
          "1099:    min_t(u32, reg->s32_max_value, reg->u32_max_value);",
          "1100:  } else if ((s32)reg->u32_min_value < 0) {",
          "1104:   reg->s32_min_value = reg->u32_min_value =",
          "1105:    max_t(u32, reg->s32_min_value, reg->u32_min_value);",
          "1106:   reg->s32_max_value = reg->u32_max_value;",
          "1107:  }",
          "1108: }",
          "1110: static void __reg64_deduce_bounds(struct bpf_reg_state *reg)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1027:  }",
          "1028: }",
          "1031: static void __reg_bound_offset(struct bpf_reg_state *reg)",
          "1032: {",
          "1036: }",
          "1040: {",
          "1045: }",
          "",
          "[Removed Lines]",
          "1033:  reg->var_off = tnum_intersect(reg->var_off,",
          "1034:           tnum_range(reg->umin_value,",
          "1035:        reg->umax_value));",
          "1039: static void __mark_reg_unbounded(struct bpf_reg_state *reg)",
          "1041:  reg->smin_value = S64_MIN;",
          "1042:  reg->smax_value = S64_MAX;",
          "1043:  reg->umin_value = 0;",
          "1044:  reg->umax_value = U64_MAX;",
          "",
          "[Added Lines]",
          "1144: static void __reg_deduce_bounds(struct bpf_reg_state *reg)",
          "1145: {",
          "1146:  __reg32_deduce_bounds(reg);",
          "1147:  __reg64_deduce_bounds(reg);",
          "1148: }",
          "1153:  struct tnum var64_off = tnum_intersect(reg->var_off,",
          "1154:             tnum_range(reg->umin_value,",
          "1155:          reg->umax_value));",
          "1156:  struct tnum var32_off = tnum_intersect(tnum_subreg(reg->var_off),",
          "1157:       tnum_range(reg->u32_min_value,",
          "1158:           reg->u32_max_value));",
          "1160:  reg->var_off = tnum_or(tnum_clear_subreg(var64_off), var32_off);",
          "1163: static void __reg_assign_32_into_64(struct bpf_reg_state *reg)",
          "1165:  reg->umin_value = reg->u32_min_value;",
          "1166:  reg->umax_value = reg->u32_max_value;",
          "1171:  if (reg->s32_min_value > 0)",
          "1172:   reg->smin_value = reg->s32_min_value;",
          "1173:  else",
          "1174:   reg->smin_value = 0;",
          "1175:  if (reg->s32_max_value > 0)",
          "1176:   reg->smax_value = reg->s32_max_value;",
          "1177:  else",
          "1178:   reg->smax_value = U32_MAX;",
          "1179: }",
          "1181: static void __reg_combine_32_into_64(struct bpf_reg_state *reg)",
          "1182: {",
          "1187:  if (tnum_equals_const(tnum_clear_subreg(reg->var_off), 0)) {",
          "1188:   __reg_assign_32_into_64(reg);",
          "1189:  } else {",
          "1197:   __mark_reg64_unbounded(reg);",
          "1198:   __update_reg_bounds(reg);",
          "1199:  }",
          "1205:  __reg_deduce_bounds(reg);",
          "1206:  __reg_bound_offset(reg);",
          "1207:  __update_reg_bounds(reg);",
          "1208: }",
          "1210: static bool __reg64_bound_s32(s64 a)",
          "1211: {",
          "1212:  if (a > S32_MIN && a < S32_MAX)",
          "1213:   return true;",
          "1214:  return false;",
          "1215: }",
          "1217: static bool __reg64_bound_u32(u64 a)",
          "1218: {",
          "1219:  if (a > U32_MIN && a < U32_MAX)",
          "1220:   return true;",
          "1221:  return false;",
          "1222: }",
          "1224: static void __reg_combine_64_into_32(struct bpf_reg_state *reg)",
          "1225: {",
          "1226:  __mark_reg32_unbounded(reg);",
          "1228:  if (__reg64_bound_s32(reg->smin_value))",
          "1229:   reg->s32_min_value = (s32)reg->smin_value;",
          "1230:  if (__reg64_bound_s32(reg->smax_value))",
          "1231:   reg->s32_max_value = (s32)reg->smax_value;",
          "1232:  if (__reg64_bound_u32(reg->umin_value))",
          "1233:   reg->u32_min_value = (u32)reg->umin_value;",
          "1234:  if (__reg64_bound_u32(reg->umax_value))",
          "1235:   reg->u32_max_value = (u32)reg->umax_value;",
          "1241:  __reg_deduce_bounds(reg);",
          "1242:  __reg_bound_offset(reg);",
          "1243:  __update_reg_bounds(reg);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2774:  return 0;",
          "2775: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2977: static void zext_32_to_64(struct bpf_reg_state *reg)",
          "2978: {",
          "2979:  reg->var_off = tnum_subreg(reg->var_off);",
          "2980:  __reg_assign_32_into_64(reg);",
          "2981: }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "2796:  }",
          "2797:  reg->smin_value = reg->umin_value;",
          "2798:  reg->smax_value = reg->umax_value;",
          "2799: }",
          "2801: static bool bpf_map_is_rdonly(const struct bpf_map *map)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3009:  if (size >= 4)",
          "3010:   return;",
          "3011:  __reg_combine_64_into_32(reg);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "4431:  return res < a;",
          "4432: }",
          "4435: {",
          "4437:  s64 res = (s64)((u64)a - (u64)b);",
          "",
          "[Removed Lines]",
          "4434: static bool signed_sub_overflows(s64 a, s64 b)",
          "",
          "[Added Lines]",
          "4647: static bool signed_add32_overflows(s64 a, s64 b)",
          "4648: {",
          "4650:  s32 res = (s32)((u32)a + (u32)b);",
          "4652:  if (b < 0)",
          "4653:   return res > a;",
          "4654:  return res < a;",
          "4655: }",
          "4657: static bool signed_sub_overflows(s32 a, s32 b)",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "4441:  return res > a;",
          "4442: }",
          "4444: static bool check_reg_sane_offset(struct bpf_verifier_env *env,",
          "4445:       const struct bpf_reg_state *reg,",
          "4446:       enum bpf_reg_type type)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4667: static bool signed_sub32_overflows(s32 a, s32 b)",
          "4668: {",
          "4670:  s32 res = (s32)((u32)a - (u32)b);",
          "4672:  if (b < 0)",
          "4673:   return res < a;",
          "4674:  return res > a;",
          "4675: }",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "4677:      !check_reg_sane_offset(env, ptr_reg, ptr_reg->type))",
          "4678:   return -EINVAL;",
          "4680:  switch (opcode) {",
          "4681:  case BPF_ADD:",
          "4682:   ret = sanitize_ptr_alu(env, insn, ptr_reg, dst_reg, smin_val < 0);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4914:  __mark_reg32_unbounded(dst_reg);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "4840:  return 0;",
          "4841: }",
          "4843: static void scalar_min_max_add(struct bpf_reg_state *dst_reg,",
          "4844:           struct bpf_reg_state *src_reg)",
          "4845: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5079: static void scalar32_min_max_add(struct bpf_reg_state *dst_reg,",
          "5080:      struct bpf_reg_state *src_reg)",
          "5081: {",
          "5082:  s32 smin_val = src_reg->s32_min_value;",
          "5083:  s32 smax_val = src_reg->s32_max_value;",
          "5084:  u32 umin_val = src_reg->u32_min_value;",
          "5085:  u32 umax_val = src_reg->u32_max_value;",
          "5087:  if (signed_add32_overflows(dst_reg->s32_min_value, smin_val) ||",
          "5088:      signed_add32_overflows(dst_reg->s32_max_value, smax_val)) {",
          "5089:   dst_reg->s32_min_value = S32_MIN;",
          "5090:   dst_reg->s32_max_value = S32_MAX;",
          "5091:  } else {",
          "5092:   dst_reg->s32_min_value += smin_val;",
          "5093:   dst_reg->s32_max_value += smax_val;",
          "5094:  }",
          "5095:  if (dst_reg->u32_min_value + umin_val < umin_val ||",
          "5096:      dst_reg->u32_max_value + umax_val < umax_val) {",
          "5097:   dst_reg->u32_min_value = 0;",
          "5098:   dst_reg->u32_max_value = U32_MAX;",
          "5099:  } else {",
          "5100:   dst_reg->u32_min_value += umin_val;",
          "5101:   dst_reg->u32_max_value += umax_val;",
          "5102:  }",
          "5103: }",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "4864:   dst_reg->umin_value += umin_val;",
          "4865:   dst_reg->umax_value += umax_val;",
          "4866:  }",
          "4868: }",
          "4870: static void scalar_min_max_sub(struct bpf_reg_state *dst_reg,",
          "",
          "[Removed Lines]",
          "4867:  dst_reg->var_off = tnum_add(dst_reg->var_off, src_reg->var_off);",
          "",
          "[Added Lines]",
          "5129: }",
          "5131: static void scalar32_min_max_sub(struct bpf_reg_state *dst_reg,",
          "5132:      struct bpf_reg_state *src_reg)",
          "5133: {",
          "5134:  s32 smin_val = src_reg->s32_min_value;",
          "5135:  s32 smax_val = src_reg->s32_max_value;",
          "5136:  u32 umin_val = src_reg->u32_min_value;",
          "5137:  u32 umax_val = src_reg->u32_max_value;",
          "5139:  if (signed_sub32_overflows(dst_reg->s32_min_value, smax_val) ||",
          "5140:      signed_sub32_overflows(dst_reg->s32_max_value, smin_val)) {",
          "5142:   dst_reg->s32_min_value = S32_MIN;",
          "5143:   dst_reg->s32_max_value = S32_MAX;",
          "5144:  } else {",
          "5145:   dst_reg->s32_min_value -= smax_val;",
          "5146:   dst_reg->s32_max_value -= smin_val;",
          "5147:  }",
          "5148:  if (dst_reg->u32_min_value < umax_val) {",
          "5150:   dst_reg->u32_min_value = 0;",
          "5151:   dst_reg->u32_max_value = U32_MAX;",
          "5152:  } else {",
          "5154:   dst_reg->u32_min_value -= umax_val;",
          "5155:   dst_reg->u32_max_value -= umin_val;",
          "5156:  }",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "4893:   dst_reg->umin_value -= umax_val;",
          "4894:   dst_reg->umax_value -= umin_val;",
          "4895:  }",
          "4897: }",
          "4899: static void scalar_min_max_mul(struct bpf_reg_state *dst_reg,",
          "",
          "[Removed Lines]",
          "4896:  dst_reg->var_off = tnum_sub(dst_reg->var_off, src_reg->var_off);",
          "",
          "[Added Lines]",
          "5185: }",
          "5187: static void scalar32_min_max_mul(struct bpf_reg_state *dst_reg,",
          "5188:      struct bpf_reg_state *src_reg)",
          "5189: {",
          "5190:  s32 smin_val = src_reg->s32_min_value;",
          "5191:  u32 umin_val = src_reg->u32_min_value;",
          "5192:  u32 umax_val = src_reg->u32_max_value;",
          "5194:  if (smin_val < 0 || dst_reg->s32_min_value < 0) {",
          "5196:   __mark_reg32_unbounded(dst_reg);",
          "5197:   return;",
          "5198:  }",
          "5202:  if (umax_val > U16_MAX || dst_reg->u32_max_value > U16_MAX) {",
          "5204:   __mark_reg32_unbounded(dst_reg);",
          "5205:   return;",
          "5206:  }",
          "5207:  dst_reg->u32_min_value *= umin_val;",
          "5208:  dst_reg->u32_max_value *= umax_val;",
          "5209:  if (dst_reg->u32_max_value > S32_MAX) {",
          "5211:   dst_reg->s32_min_value = S32_MIN;",
          "5212:   dst_reg->s32_max_value = S32_MAX;",
          "5213:  } else {",
          "5214:   dst_reg->s32_min_value = dst_reg->u32_min_value;",
          "5215:   dst_reg->s32_max_value = dst_reg->u32_max_value;",
          "5216:  }",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "4903:  u64 umin_val = src_reg->umin_value;",
          "4904:  u64 umax_val = src_reg->umax_value;",
          "4907:  if (smin_val < 0 || dst_reg->smin_value < 0) {",
          "4911:   return;",
          "4912:  }",
          "",
          "[Removed Lines]",
          "4906:  dst_reg->var_off = tnum_mul(dst_reg->var_off, src_reg->var_off);",
          "4909:   __mark_reg_unbounded(dst_reg);",
          "4910:   __update_reg_bounds(dst_reg);",
          "",
          "[Added Lines]",
          "5228:   __mark_reg64_unbounded(dst_reg);",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "4916:  if (umax_val > U32_MAX || dst_reg->umax_value > U32_MAX) {",
          "4921:   return;",
          "4922:  }",
          "4923:  dst_reg->umin_value *= umin_val;",
          "",
          "[Removed Lines]",
          "4918:   __mark_reg_unbounded(dst_reg);",
          "4920:   __update_reg_bounds(dst_reg);",
          "",
          "[Added Lines]",
          "5236:   __mark_reg64_unbounded(dst_reg);",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "4932:  }",
          "4933: }",
          "4935: static void scalar_min_max_and(struct bpf_reg_state *dst_reg,",
          "4936:           struct bpf_reg_state *src_reg)",
          "4937: {",
          "4938:  s64 smin_val = src_reg->smin_value;",
          "4939:  u64 umax_val = src_reg->umax_value;",
          "4945:  dst_reg->umin_value = dst_reg->var_off.value;",
          "4946:  dst_reg->umax_value = min(dst_reg->umax_value, umax_val);",
          "4947:  if (dst_reg->smin_value < 0 || smin_val < 0) {",
          "",
          "[Removed Lines]",
          "4944:  dst_reg->var_off = tnum_and(dst_reg->var_off, src_reg->var_off);",
          "",
          "[Added Lines]",
          "5251: static void scalar32_min_max_and(struct bpf_reg_state *dst_reg,",
          "5252:      struct bpf_reg_state *src_reg)",
          "5253: {",
          "5254:  bool src_known = tnum_subreg_is_const(src_reg->var_off);",
          "5255:  bool dst_known = tnum_subreg_is_const(dst_reg->var_off);",
          "5256:  struct tnum var32_off = tnum_subreg(dst_reg->var_off);",
          "5257:  s32 smin_val = src_reg->s32_min_value;",
          "5258:  u32 umax_val = src_reg->u32_max_value;",
          "5263:  if (src_known && dst_known)",
          "5264:   return;",
          "5269:  dst_reg->u32_min_value = var32_off.value;",
          "5270:  dst_reg->u32_max_value = min(dst_reg->u32_max_value, umax_val);",
          "5271:  if (dst_reg->s32_min_value < 0 || smin_val < 0) {",
          "5275:   dst_reg->s32_min_value = S32_MIN;",
          "5276:   dst_reg->s32_max_value = S32_MAX;",
          "5277:  } else {",
          "5281:   dst_reg->s32_min_value = dst_reg->u32_min_value;",
          "5282:   dst_reg->s32_max_value = dst_reg->u32_max_value;",
          "5283:  }",
          "5285: }",
          "5290:  bool src_known = tnum_is_const(src_reg->var_off);",
          "5291:  bool dst_known = tnum_is_const(dst_reg->var_off);",
          "5295:  if (src_known && dst_known) {",
          "5296:   __mark_reg_known(dst_reg, dst_reg->var_off.value &",
          "5297:        src_reg->var_off.value);",
          "5298:   return;",
          "5299:  }",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "4961:  __update_reg_bounds(dst_reg);",
          "4962: }",
          "4964: static void scalar_min_max_or(struct bpf_reg_state *dst_reg,",
          "4965:          struct bpf_reg_state *src_reg)",
          "4966: {",
          "4967:  s64 smin_val = src_reg->smin_value;",
          "4968:  u64 umin_val = src_reg->umin_value;",
          "4974:  dst_reg->umin_value = max(dst_reg->umin_value, umin_val);",
          "4975:  dst_reg->umax_value = dst_reg->var_off.value | dst_reg->var_off.mask;",
          "4976:  if (dst_reg->smin_value < 0 || smin_val < 0) {",
          "",
          "[Removed Lines]",
          "4973:  dst_reg->var_off = tnum_or(dst_reg->var_off, src_reg->var_off);",
          "",
          "[Added Lines]",
          "5323: static void scalar32_min_max_or(struct bpf_reg_state *dst_reg,",
          "5324:     struct bpf_reg_state *src_reg)",
          "5325: {",
          "5326:  bool src_known = tnum_subreg_is_const(src_reg->var_off);",
          "5327:  bool dst_known = tnum_subreg_is_const(dst_reg->var_off);",
          "5328:  struct tnum var32_off = tnum_subreg(dst_reg->var_off);",
          "5329:  s32 smin_val = src_reg->smin_value;",
          "5330:  u32 umin_val = src_reg->umin_value;",
          "5335:  if (src_known && dst_known)",
          "5336:   return;",
          "5341:  dst_reg->u32_min_value = max(dst_reg->u32_min_value, umin_val);",
          "5342:  dst_reg->u32_max_value = var32_off.value | var32_off.mask;",
          "5343:  if (dst_reg->s32_min_value < 0 || smin_val < 0) {",
          "5347:   dst_reg->s32_min_value = S32_MIN;",
          "5348:   dst_reg->s32_max_value = S32_MAX;",
          "5349:  } else {",
          "5353:   dst_reg->s32_min_value = dst_reg->umin_value;",
          "5354:   dst_reg->s32_max_value = dst_reg->umax_value;",
          "5355:  }",
          "5356: }",
          "5361:  bool src_known = tnum_is_const(src_reg->var_off);",
          "5362:  bool dst_known = tnum_is_const(dst_reg->var_off);",
          "5366:  if (src_known && dst_known) {",
          "5367:   __mark_reg_known(dst_reg, dst_reg->var_off.value |",
          "5368:        src_reg->var_off.value);",
          "5369:   return;",
          "5370:  }",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "4990:  __update_reg_bounds(dst_reg);",
          "4991: }",
          "4995: {",
          "5005:  if (dst_reg->umax_value > 1ULL << (63 - umax_val)) {",
          "5006:   dst_reg->umin_value = 0;",
          "",
          "[Removed Lines]",
          "4993: static void scalar_min_max_lsh(struct bpf_reg_state *dst_reg,",
          "4994:           struct bpf_reg_state *src_reg)",
          "4996:  u64 umax_val = src_reg->umax_value;",
          "4997:  u64 umin_val = src_reg->umin_value;",
          "5002:  dst_reg->smin_value = S64_MIN;",
          "5003:  dst_reg->smax_value = S64_MAX;",
          "",
          "[Added Lines]",
          "5394: static void __scalar32_min_max_lsh(struct bpf_reg_state *dst_reg,",
          "5395:        u64 umin_val, u64 umax_val)",
          "5400:  dst_reg->s32_min_value = S32_MIN;",
          "5401:  dst_reg->s32_max_value = S32_MAX;",
          "5403:  if (umax_val > 31 || dst_reg->u32_max_value > 1ULL << (31 - umax_val)) {",
          "5404:   dst_reg->u32_min_value = 0;",
          "5405:   dst_reg->u32_max_value = U32_MAX;",
          "5406:  } else {",
          "5407:   dst_reg->u32_min_value <<= umin_val;",
          "5408:   dst_reg->u32_max_value <<= umax_val;",
          "5409:  }",
          "5410: }",
          "5412: static void scalar32_min_max_lsh(struct bpf_reg_state *dst_reg,",
          "5413:      struct bpf_reg_state *src_reg)",
          "5414: {",
          "5415:  u32 umax_val = src_reg->u32_max_value;",
          "5416:  u32 umin_val = src_reg->u32_min_value;",
          "5418:  struct tnum subreg = tnum_subreg(dst_reg->var_off);",
          "5420:  __scalar32_min_max_lsh(dst_reg, umin_val, umax_val);",
          "5421:  dst_reg->var_off = tnum_subreg(tnum_lshift(subreg, umin_val));",
          "5426:  __mark_reg64_unbounded(dst_reg);",
          "5427:  __update_reg32_bounds(dst_reg);",
          "5428: }",
          "5430: static void __scalar64_min_max_lsh(struct bpf_reg_state *dst_reg,",
          "5431:        u64 umin_val, u64 umax_val)",
          "5432: {",
          "5440:  if (umin_val == 32 && umax_val == 32 && dst_reg->s32_max_value >= 0)",
          "5441:   dst_reg->smax_value = (s64)dst_reg->s32_max_value << 32;",
          "5442:  else",
          "5443:   dst_reg->smax_value = S64_MAX;",
          "5445:  if (umin_val == 32 && umax_val == 32 && dst_reg->s32_min_value >= 0)",
          "5446:   dst_reg->smin_value = (s64)dst_reg->s32_min_value << 32;",
          "5447:  else",
          "5448:   dst_reg->smin_value = S64_MIN;",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "5009:   dst_reg->umin_value <<= umin_val;",
          "5010:   dst_reg->umax_value <<= umax_val;",
          "5011:  }",
          "5012:  dst_reg->var_off = tnum_lshift(dst_reg->var_off, umin_val);",
          "5014:  __update_reg_bounds(dst_reg);",
          "5015: }",
          "5017: static void scalar_min_max_rsh(struct bpf_reg_state *dst_reg,",
          "5018:           struct bpf_reg_state *src_reg)",
          "5019: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5458: }",
          "5460: static void scalar_min_max_lsh(struct bpf_reg_state *dst_reg,",
          "5461:           struct bpf_reg_state *src_reg)",
          "5462: {",
          "5463:  u64 umax_val = src_reg->umax_value;",
          "5464:  u64 umin_val = src_reg->umin_value;",
          "5467:  __scalar64_min_max_lsh(dst_reg, umin_val, umax_val);",
          "5468:  __scalar32_min_max_lsh(dst_reg, umin_val, umax_val);",
          "5475: static void scalar32_min_max_rsh(struct bpf_reg_state *dst_reg,",
          "5476:      struct bpf_reg_state *src_reg)",
          "5477: {",
          "5478:  struct tnum subreg = tnum_subreg(dst_reg->var_off);",
          "5479:  u32 umax_val = src_reg->u32_max_value;",
          "5480:  u32 umin_val = src_reg->u32_min_value;",
          "5496:  dst_reg->s32_min_value = S32_MIN;",
          "5497:  dst_reg->s32_max_value = S32_MAX;",
          "5499:  dst_reg->var_off = tnum_rshift(subreg, umin_val);",
          "5500:  dst_reg->u32_min_value >>= umax_val;",
          "5501:  dst_reg->u32_max_value >>= umin_val;",
          "5503:  __mark_reg64_unbounded(dst_reg);",
          "5504:  __update_reg32_bounds(dst_reg);",
          "5505: }",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "5039:  dst_reg->var_off = tnum_rshift(dst_reg->var_off, umin_val);",
          "5040:  dst_reg->umin_value >>= umax_val;",
          "5041:  dst_reg->umax_value >>= umin_val;",
          "5043:  __update_reg_bounds(dst_reg);",
          "5044: }",
          "5049: {",
          "5069:  dst_reg->umin_value = 0;",
          "5070:  dst_reg->umax_value = U64_MAX;",
          "5071:  __update_reg_bounds(dst_reg);",
          "5072: }",
          "",
          "[Removed Lines]",
          "5046: static void scalar_min_max_arsh(struct bpf_reg_state *dst_reg,",
          "5047:            struct bpf_reg_state *src_reg,",
          "5048:     u64 insn_bitness)",
          "5050:  u64 umin_val = src_reg->umin_value;",
          "5055:  if (insn_bitness == 32) {",
          "5056:   dst_reg->smin_value = (u32)(((s32)dst_reg->smin_value) >> umin_val);",
          "5057:   dst_reg->smax_value = (u32)(((s32)dst_reg->smax_value) >> umin_val);",
          "5058:  } else {",
          "5059:   dst_reg->smin_value >>= umin_val;",
          "5060:   dst_reg->smax_value >>= umin_val;",
          "5061:  }",
          "5063:  dst_reg->var_off = tnum_arshift(dst_reg->var_off, umin_val,",
          "5064:      insn_bitness);",
          "",
          "[Added Lines]",
          "5537:  __mark_reg32_unbounded(dst_reg);",
          "5541: static void scalar32_min_max_arsh(struct bpf_reg_state *dst_reg,",
          "5542:       struct bpf_reg_state *src_reg)",
          "5544:  u64 umin_val = src_reg->u32_min_value;",
          "5549:  dst_reg->s32_min_value = (u32)(((s32)dst_reg->s32_min_value) >> umin_val);",
          "5550:  dst_reg->s32_max_value = (u32)(((s32)dst_reg->s32_max_value) >> umin_val);",
          "5552:  dst_reg->var_off = tnum_arshift(tnum_subreg(dst_reg->var_off), umin_val, 32);",
          "5557:  dst_reg->u32_min_value = 0;",
          "5558:  dst_reg->u32_max_value = U32_MAX;",
          "5560:  __mark_reg64_unbounded(dst_reg);",
          "5561:  __update_reg32_bounds(dst_reg);",
          "5562: }",
          "5564: static void scalar_min_max_arsh(struct bpf_reg_state *dst_reg,",
          "5565:     struct bpf_reg_state *src_reg)",
          "5566: {",
          "5567:  u64 umin_val = src_reg->umin_value;",
          "5572:  dst_reg->smin_value >>= umin_val;",
          "5573:  dst_reg->smax_value >>= umin_val;",
          "5575:  dst_reg->var_off = tnum_arshift(dst_reg->var_off, umin_val, 64);",
          "5587:  __mark_reg32_unbounded(dst_reg);",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "5085:  bool src_known, dst_known;",
          "5086:  s64 smin_val, smax_val;",
          "5087:  u64 umin_val, umax_val;",
          "5088:  u64 insn_bitness = (BPF_CLASS(insn->code) == BPF_ALU64) ? 64 : 32;",
          "5089:  u32 dst = insn->dst_reg;",
          "5090:  int ret;",
          "5101:  smin_val = src_reg.smin_value;",
          "5102:  smax_val = src_reg.smax_value;",
          "5103:  umin_val = src_reg.umin_value;",
          "5104:  umax_val = src_reg.umax_value;",
          "5115:  }",
          "5117:  if (!src_known &&",
          "",
          "[Removed Lines]",
          "5092:  if (insn_bitness == 32) {",
          "5097:   coerce_reg_to_size(dst_reg, 4);",
          "5098:   coerce_reg_to_size(&src_reg, 4);",
          "5099:  }",
          "5105:  src_known = tnum_is_const(src_reg.var_off);",
          "5106:  dst_known = tnum_is_const(dst_reg->var_off);",
          "5108:  if ((src_known && (smin_val != smax_val || umin_val != umax_val)) ||",
          "5109:      smin_val > smax_val || umin_val > umax_val) {",
          "5113:   __mark_reg_unknown(env, dst_reg);",
          "5114:   return 0;",
          "",
          "[Added Lines]",
          "5605:  s32 s32_min_val, s32_max_val;",
          "5606:  u32 u32_min_val, u32_max_val;",
          "5610:  bool alu32 = (BPF_CLASS(insn->code) != BPF_ALU64);",
          "5617:  s32_min_val = src_reg.s32_min_value;",
          "5618:  s32_max_val = src_reg.s32_max_value;",
          "5619:  u32_min_val = src_reg.u32_min_value;",
          "5620:  u32_max_val = src_reg.u32_max_value;",
          "5622:  if (alu32) {",
          "5623:   src_known = tnum_subreg_is_const(src_reg.var_off);",
          "5624:   dst_known = tnum_subreg_is_const(dst_reg->var_off);",
          "5625:   if ((src_known &&",
          "5626:        (s32_min_val != s32_max_val || u32_min_val != u32_max_val)) ||",
          "5627:       s32_min_val > s32_max_val || u32_min_val > u32_max_val) {",
          "5631:    __mark_reg_unknown(env, dst_reg);",
          "5632:    return 0;",
          "5633:   }",
          "5634:  } else {",
          "5635:   src_known = tnum_is_const(src_reg.var_off);",
          "5636:   dst_known = tnum_is_const(dst_reg->var_off);",
          "5637:   if ((src_known &&",
          "5638:        (smin_val != smax_val || umin_val != umax_val)) ||",
          "5639:       smin_val > smax_val || umin_val > umax_val) {",
          "5643:    __mark_reg_unknown(env, dst_reg);",
          "5644:    return 0;",
          "5645:   }",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "5127:    verbose(env, \"R%d tried to add from different pointers or scalars\\n\", dst);",
          "5128:    return ret;",
          "5129:   }",
          "5130:   scalar_min_max_add(dst_reg, &src_reg);",
          "5131:   break;",
          "5132:  case BPF_SUB:",
          "5133:   ret = sanitize_val_alu(env, insn);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5675:   scalar32_min_max_add(dst_reg, &src_reg);",
          "5677:   dst_reg->var_off = tnum_add(dst_reg->var_off, src_reg.var_off);",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "5135:    verbose(env, \"R%d tried to sub from different pointers or scalars\\n\", dst);",
          "5136:    return ret;",
          "5137:   }",
          "5138:   scalar_min_max_sub(dst_reg, &src_reg);",
          "5139:   break;",
          "5140:  case BPF_MUL:",
          "5141:   scalar_min_max_mul(dst_reg, &src_reg);",
          "5142:   break;",
          "5143:  case BPF_AND:",
          "5149:   scalar_min_max_and(dst_reg, &src_reg);",
          "5150:   break;",
          "5151:  case BPF_OR:",
          "5157:   scalar_min_max_or(dst_reg, &src_reg);",
          "5158:   break;",
          "5159:  case BPF_LSH:",
          "",
          "[Removed Lines]",
          "5144:   if (src_known && dst_known) {",
          "5145:    __mark_reg_known(dst_reg, dst_reg->var_off.value &",
          "5146:         src_reg.var_off.value);",
          "5147:    break;",
          "5148:   }",
          "5152:   if (src_known && dst_known) {",
          "5153:    __mark_reg_known(dst_reg, dst_reg->var_off.value |",
          "5154:         src_reg.var_off.value);",
          "5155:    break;",
          "5156:   }",
          "",
          "[Added Lines]",
          "5685:   scalar32_min_max_sub(dst_reg, &src_reg);",
          "5687:   dst_reg->var_off = tnum_sub(dst_reg->var_off, src_reg.var_off);",
          "5690:   dst_reg->var_off = tnum_mul(dst_reg->var_off, src_reg.var_off);",
          "5691:   scalar32_min_max_mul(dst_reg, &src_reg);",
          "5695:   dst_reg->var_off = tnum_and(dst_reg->var_off, src_reg.var_off);",
          "5696:   scalar32_min_max_and(dst_reg, &src_reg);",
          "5700:   dst_reg->var_off = tnum_or(dst_reg->var_off, src_reg.var_off);",
          "5701:   scalar32_min_max_or(dst_reg, &src_reg);",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "5164:    mark_reg_unknown(env, regs, insn->dst_reg);",
          "5165:    break;",
          "5166:   }",
          "5168:   break;",
          "5169:  case BPF_RSH:",
          "5170:   if (umax_val >= insn_bitness) {",
          "",
          "[Removed Lines]",
          "5167:   scalar_min_max_lsh(dst_reg, &src_reg);",
          "",
          "[Added Lines]",
          "5712:   if (alu32)",
          "5713:    scalar32_min_max_lsh(dst_reg, &src_reg);",
          "5714:   else",
          "5715:    scalar_min_max_lsh(dst_reg, &src_reg);",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "5174:    mark_reg_unknown(env, regs, insn->dst_reg);",
          "5175:    break;",
          "5176:   }",
          "5178:   break;",
          "5179:  case BPF_ARSH:",
          "5180:   if (umax_val >= insn_bitness) {",
          "",
          "[Removed Lines]",
          "5177:   scalar_min_max_rsh(dst_reg, &src_reg);",
          "",
          "[Added Lines]",
          "5725:   if (alu32)",
          "5726:    scalar32_min_max_rsh(dst_reg, &src_reg);",
          "5727:   else",
          "5728:    scalar_min_max_rsh(dst_reg, &src_reg);",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "5184:    mark_reg_unknown(env, regs, insn->dst_reg);",
          "5185:    break;",
          "5186:   }",
          "5188:   break;",
          "5189:  default:",
          "5190:   mark_reg_unknown(env, regs, insn->dst_reg);",
          "5191:   break;",
          "5192:  }",
          "5199:  __update_reg_bounds(dst_reg);",
          "5200:  __reg_deduce_bounds(dst_reg);",
          "",
          "[Removed Lines]",
          "5187:   scalar_min_max_arsh(dst_reg, &src_reg, insn_bitness);",
          "5194:  if (BPF_CLASS(insn->code) != BPF_ALU64) {",
          "5196:   coerce_reg_to_size(dst_reg, 4);",
          "5197:  }",
          "",
          "[Added Lines]",
          "5738:   if (alu32)",
          "5739:    scalar32_min_max_arsh(dst_reg, &src_reg);",
          "5740:   else",
          "5741:    scalar_min_max_arsh(dst_reg, &src_reg);",
          "5749:  if (alu32)",
          "5750:   zext_32_to_64(dst_reg);",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "5370:      mark_reg_unknown(env, regs,",
          "5371:         insn->dst_reg);",
          "5372:     }",
          "5374:    }",
          "5375:   } else {",
          "",
          "[Removed Lines]",
          "5373:     coerce_reg_to_size(dst_reg, 4);",
          "",
          "[Added Lines]",
          "5926:     zext_32_to_64(dst_reg);",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "5540:       new_range);",
          "5541: }",
          "5551: {",
          "5593:  switch (opcode) {",
          "5594:  case BPF_JEQ:",
          "",
          "[Removed Lines]",
          "5549: static int is_branch_taken(struct bpf_reg_state *reg, u64 val, u8 opcode,",
          "5550:       bool is_jmp32)",
          "5552:  struct bpf_reg_state reg_lo;",
          "5553:  s64 sval;",
          "5555:  if (__is_pointer_value(false, reg))",
          "5556:   return -1;",
          "5558:  if (is_jmp32) {",
          "5559:   reg_lo = *reg;",
          "5560:   reg = &reg_lo;",
          "5565:   coerce_reg_to_size(reg, 4);",
          "5579:   if ((reg->umax_value ^ reg->umin_value) &",
          "5580:       (1ULL << 31)) {",
          "5581:    reg->smin_value = S32_MIN;",
          "5582:    reg->smax_value = S32_MAX;",
          "5583:   }",
          "5584:   reg->smin_value = (s64)(s32)reg->smin_value;",
          "5585:   reg->smax_value = (s64)(s32)reg->smax_value;",
          "5587:   val = (u32)val;",
          "5588:   sval = (s64)(s32)val;",
          "5589:  } else {",
          "5590:   sval = (s64)val;",
          "5591:  }",
          "",
          "[Added Lines]",
          "6096: static int is_branch32_taken(struct bpf_reg_state *reg, u32 val, u8 opcode)",
          "6098:  struct tnum subreg = tnum_subreg(reg->var_off);",
          "6099:  s32 sval = (s32)val;",
          "6101:  switch (opcode) {",
          "6102:  case BPF_JEQ:",
          "6103:   if (tnum_is_const(subreg))",
          "6104:    return !!tnum_equals_const(subreg, val);",
          "6105:   break;",
          "6106:  case BPF_JNE:",
          "6107:   if (tnum_is_const(subreg))",
          "6108:    return !tnum_equals_const(subreg, val);",
          "6109:   break;",
          "6110:  case BPF_JSET:",
          "6111:   if ((~subreg.mask & subreg.value) & val)",
          "6112:    return 1;",
          "6113:   if (!((subreg.mask | subreg.value) & val))",
          "6114:    return 0;",
          "6115:   break;",
          "6116:  case BPF_JGT:",
          "6117:   if (reg->u32_min_value > val)",
          "6118:    return 1;",
          "6119:   else if (reg->u32_max_value <= val)",
          "6120:    return 0;",
          "6121:   break;",
          "6122:  case BPF_JSGT:",
          "6123:   if (reg->s32_min_value > sval)",
          "6124:    return 1;",
          "6125:   else if (reg->s32_max_value < sval)",
          "6126:    return 0;",
          "6127:   break;",
          "6128:  case BPF_JLT:",
          "6129:   if (reg->u32_max_value < val)",
          "6130:    return 1;",
          "6131:   else if (reg->u32_min_value >= val)",
          "6132:    return 0;",
          "6133:   break;",
          "6134:  case BPF_JSLT:",
          "6135:   if (reg->s32_max_value < sval)",
          "6136:    return 1;",
          "6137:   else if (reg->s32_min_value >= sval)",
          "6138:    return 0;",
          "6139:   break;",
          "6140:  case BPF_JGE:",
          "6141:   if (reg->u32_min_value >= val)",
          "6142:    return 1;",
          "6143:   else if (reg->u32_max_value < val)",
          "6144:    return 0;",
          "6145:   break;",
          "6146:  case BPF_JSGE:",
          "6147:   if (reg->s32_min_value >= sval)",
          "6148:    return 1;",
          "6149:   else if (reg->s32_max_value < sval)",
          "6150:    return 0;",
          "6151:   break;",
          "6152:  case BPF_JLE:",
          "6153:   if (reg->u32_max_value <= val)",
          "6154:    return 1;",
          "6155:   else if (reg->u32_min_value > val)",
          "6156:    return 0;",
          "6157:   break;",
          "6158:  case BPF_JSLE:",
          "6159:   if (reg->s32_max_value <= sval)",
          "6160:    return 1;",
          "6161:   else if (reg->s32_min_value > sval)",
          "6162:    return 0;",
          "6163:   break;",
          "6164:  }",
          "6166:  return -1;",
          "6167: }",
          "6170: static int is_branch64_taken(struct bpf_reg_state *reg, u64 val, u8 opcode)",
          "6171: {",
          "6172:  s64 sval = (s64)val;",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "5658:  return -1;",
          "5659: }",
          "5723: {",
          "5746: }",
          "",
          "[Removed Lines]",
          "5662: static u64 gen_hi_min(struct tnum var)",
          "5663: {",
          "5664:  return var.value & ~0xffffffffULL;",
          "5665: }",
          "5668: static u64 gen_hi_max(struct tnum var)",
          "5669: {",
          "5670:  return (var.value | var.mask) & ~0xffffffffULL;",
          "5671: }",
          "5676: static bool cmp_val_with_extended_s64(s64 sval, struct bpf_reg_state *reg)",
          "5677: {",
          "5678:  return ((s32)sval >= 0 &&",
          "5679:   reg->smin_value >= 0 && reg->smax_value <= S32_MAX) ||",
          "5680:         ((s32)sval < 0 &&",
          "5681:   reg->smax_value <= 0 && reg->smin_value >= S32_MIN);",
          "5682: }",
          "5689: static void set_upper_bound(struct bpf_reg_state *reg, u64 bound, bool is_jmp32,",
          "5690:        bool is_exclusive)",
          "5691: {",
          "5692:  if (is_exclusive) {",
          "5694:   if (bound == 0)",
          "5695:    return;",
          "5696:   bound--;",
          "5697:  }",
          "5698:  if (is_jmp32) {",
          "5705:   struct tnum t = tnum_range(0, bound);",
          "5708:   reg->var_off = tnum_intersect(reg->var_off, t);",
          "5711:   bound += gen_hi_max(reg->var_off);",
          "5712:  }",
          "5713:  reg->umax_value = min(reg->umax_value, bound);",
          "5714: }",
          "5721: static void set_lower_bound(struct bpf_reg_state *reg, u64 bound, bool is_jmp32,",
          "5722:        bool is_exclusive)",
          "5724:  if (is_exclusive) {",
          "5726:   if (bound == (is_jmp32 ? U32_MAX : U64_MAX))",
          "5727:    return;",
          "5728:   bound++;",
          "5729:  }",
          "5730:  if (is_jmp32) {",
          "5737:   struct tnum t = tnum_range(bound, U32_MAX);",
          "5740:   reg->var_off = tnum_intersect(reg->var_off, t);",
          "5743:   bound += gen_hi_min(reg->var_off);",
          "5744:  }",
          "5745:  reg->umin_value = max(reg->umin_value, bound);",
          "",
          "[Added Lines]",
          "6249: static int is_branch_taken(struct bpf_reg_state *reg, u64 val, u8 opcode,",
          "6250:       bool is_jmp32)",
          "6252:  if (__is_pointer_value(false, reg))",
          "6253:   return -1;",
          "6255:  if (is_jmp32)",
          "6256:   return is_branch32_taken(reg, val, opcode);",
          "6257:  return is_branch64_taken(reg, val, opcode);",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "5753: static void reg_set_min_max(struct bpf_reg_state *true_reg,",
          "5755:        u8 opcode, bool is_jmp32)",
          "5756: {",
          "",
          "[Removed Lines]",
          "5754:        struct bpf_reg_state *false_reg, u64 val,",
          "5757:  s64 sval;",
          "",
          "[Added Lines]",
          "6266:        struct bpf_reg_state *false_reg,",
          "6267:        u64 val, u32 val32,",
          "6270:  struct tnum false_32off = tnum_subreg(false_reg->var_off);",
          "6271:  struct tnum false_64off = false_reg->var_off;",
          "6272:  struct tnum true_32off = tnum_subreg(true_reg->var_off);",
          "6273:  struct tnum true_64off = true_reg->var_off;",
          "6274:  s64 sval = (s64)val;",
          "6275:  s32 sval32 = (s32)val32;",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "5765:  if (__is_pointer_value(false, false_reg))",
          "5766:   return;",
          "5771:  switch (opcode) {",
          "5772:  case BPF_JEQ:",
          "5773:  case BPF_JNE:",
          "",
          "[Removed Lines]",
          "5768:  val = is_jmp32 ? (u32)val : val;",
          "5769:  sval = is_jmp32 ? (s64)(s32)val : (s64)val;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "5789:    __mark_reg_known(reg, val);",
          "5791:   break;",
          "5792:  }",
          "5793:  case BPF_JSET:",
          "5799:   break;",
          "5800:  case BPF_JGE:",
          "5801:  case BPF_JGT:",
          "5802:  {",
          "5805:   break;",
          "5806:  }",
          "5807:  case BPF_JSGE:",
          "5808:  case BPF_JSGT:",
          "5809:  {",
          "5820:   break;",
          "5821:  }",
          "5822:  case BPF_JLE:",
          "5823:  case BPF_JLT:",
          "5824:  {",
          "5827:   break;",
          "5828:  }",
          "5829:  case BPF_JSLE:",
          "5830:  case BPF_JSLT:",
          "5831:  {",
          "5839:   break;",
          "5840:  }",
          "5841:  default:",
          "5842:   return;",
          "5843:  }",
          "5856: }",
          "5861: static void reg_set_min_max_inv(struct bpf_reg_state *true_reg,",
          "5863:     u8 opcode, bool is_jmp32)",
          "5864: {",
          "",
          "[Removed Lines]",
          "5782:   if (is_jmp32) {",
          "5783:    u64 old_v = reg->var_off.value;",
          "5784:    u64 hi_mask = ~0xffffffffULL;",
          "5786:    reg->var_off.value = (old_v & hi_mask) | val;",
          "5787:    reg->var_off.mask &= hi_mask;",
          "5788:   } else {",
          "5790:   }",
          "5794:   false_reg->var_off = tnum_and(false_reg->var_off,",
          "5795:            tnum_const(~val));",
          "5796:   if (is_power_of_2(val))",
          "5797:    true_reg->var_off = tnum_or(true_reg->var_off,",
          "5798:           tnum_const(val));",
          "5803:   set_upper_bound(false_reg, val, is_jmp32, opcode == BPF_JGE);",
          "5804:   set_lower_bound(true_reg, val, is_jmp32, opcode == BPF_JGT);",
          "5810:   s64 false_smax = opcode == BPF_JSGT ? sval    : sval - 1;",
          "5811:   s64 true_smin = opcode == BPF_JSGT ? sval + 1 : sval;",
          "5816:   if (is_jmp32 && !cmp_val_with_extended_s64(sval, false_reg))",
          "5817:    break;",
          "5818:   false_reg->smax_value = min(false_reg->smax_value, false_smax);",
          "5819:   true_reg->smin_value = max(true_reg->smin_value, true_smin);",
          "5825:   set_lower_bound(false_reg, val, is_jmp32, opcode == BPF_JLE);",
          "5826:   set_upper_bound(true_reg, val, is_jmp32, opcode == BPF_JLT);",
          "5832:   s64 false_smin = opcode == BPF_JSLT ? sval    : sval + 1;",
          "5833:   s64 true_smax = opcode == BPF_JSLT ? sval - 1 : sval;",
          "5835:   if (is_jmp32 && !cmp_val_with_extended_s64(sval, false_reg))",
          "5836:    break;",
          "5837:   false_reg->smin_value = max(false_reg->smin_value, false_smin);",
          "5838:   true_reg->smax_value = min(true_reg->smax_value, true_smax);",
          "5845:  __reg_deduce_bounds(false_reg);",
          "5846:  __reg_deduce_bounds(true_reg);",
          "5848:  __reg_bound_offset(false_reg);",
          "5849:  __reg_bound_offset(true_reg);",
          "5854:  __update_reg_bounds(false_reg);",
          "5855:  __update_reg_bounds(true_reg);",
          "5862:     struct bpf_reg_state *false_reg, u64 val,",
          "",
          "[Added Lines]",
          "6297:   if (is_jmp32)",
          "6298:    __mark_reg32_known(reg, val32);",
          "6299:   else",
          "6304:   if (is_jmp32) {",
          "6305:    false_32off = tnum_and(false_32off, tnum_const(~val32));",
          "6306:    if (is_power_of_2(val32))",
          "6307:     true_32off = tnum_or(true_32off,",
          "6308:            tnum_const(val32));",
          "6309:   } else {",
          "6310:    false_64off = tnum_and(false_64off, tnum_const(~val));",
          "6311:    if (is_power_of_2(val))",
          "6312:     true_64off = tnum_or(true_64off,",
          "6313:            tnum_const(val));",
          "6314:   }",
          "6319:   if (is_jmp32) {",
          "6320:    u32 false_umax = opcode == BPF_JGT ? val32  : val32 - 1;",
          "6321:    u32 true_umin = opcode == BPF_JGT ? val32 + 1 : val32;",
          "6323:    false_reg->u32_max_value = min(false_reg->u32_max_value,",
          "6324:              false_umax);",
          "6325:    true_reg->u32_min_value = max(true_reg->u32_min_value,",
          "6326:             true_umin);",
          "6327:   } else {",
          "6328:    u64 false_umax = opcode == BPF_JGT ? val    : val - 1;",
          "6329:    u64 true_umin = opcode == BPF_JGT ? val + 1 : val;",
          "6331:    false_reg->umax_value = min(false_reg->umax_value, false_umax);",
          "6332:    true_reg->umin_value = max(true_reg->umin_value, true_umin);",
          "6333:   }",
          "6339:   if (is_jmp32) {",
          "6340:    s32 false_smax = opcode == BPF_JSGT ? sval32    : sval32 - 1;",
          "6341:    s32 true_smin = opcode == BPF_JSGT ? sval32 + 1 : sval32;",
          "6343:    false_reg->s32_max_value = min(false_reg->s32_max_value, false_smax);",
          "6344:    true_reg->s32_min_value = max(true_reg->s32_min_value, true_smin);",
          "6345:   } else {",
          "6346:    s64 false_smax = opcode == BPF_JSGT ? sval    : sval - 1;",
          "6347:    s64 true_smin = opcode == BPF_JSGT ? sval + 1 : sval;",
          "6349:    false_reg->smax_value = min(false_reg->smax_value, false_smax);",
          "6350:    true_reg->smin_value = max(true_reg->smin_value, true_smin);",
          "6351:   }",
          "6357:   if (is_jmp32) {",
          "6358:    u32 false_umin = opcode == BPF_JLT ? val32  : val32 + 1;",
          "6359:    u32 true_umax = opcode == BPF_JLT ? val32 - 1 : val32;",
          "6361:    false_reg->u32_min_value = max(false_reg->u32_min_value,",
          "6362:              false_umin);",
          "6363:    true_reg->u32_max_value = min(true_reg->u32_max_value,",
          "6364:             true_umax);",
          "6365:   } else {",
          "6366:    u64 false_umin = opcode == BPF_JLT ? val    : val + 1;",
          "6367:    u64 true_umax = opcode == BPF_JLT ? val - 1 : val;",
          "6369:    false_reg->umin_value = max(false_reg->umin_value, false_umin);",
          "6370:    true_reg->umax_value = min(true_reg->umax_value, true_umax);",
          "6371:   }",
          "6377:   if (is_jmp32) {",
          "6378:    s32 false_smin = opcode == BPF_JSLT ? sval32    : sval32 + 1;",
          "6379:    s32 true_smax = opcode == BPF_JSLT ? sval32 - 1 : sval32;",
          "6381:    false_reg->s32_min_value = max(false_reg->s32_min_value, false_smin);",
          "6382:    true_reg->s32_max_value = min(true_reg->s32_max_value, true_smax);",
          "6383:   } else {",
          "6384:    s64 false_smin = opcode == BPF_JSLT ? sval    : sval + 1;",
          "6385:    s64 true_smax = opcode == BPF_JSLT ? sval - 1 : sval;",
          "6387:    false_reg->smin_value = max(false_reg->smin_value, false_smin);",
          "6388:    true_reg->smax_value = min(true_reg->smax_value, true_smax);",
          "6389:   }",
          "6396:  if (is_jmp32) {",
          "6397:   false_reg->var_off = tnum_or(tnum_clear_subreg(false_64off),",
          "6398:           tnum_subreg(false_32off));",
          "6399:   true_reg->var_off = tnum_or(tnum_clear_subreg(true_64off),",
          "6400:          tnum_subreg(true_32off));",
          "6401:   __reg_combine_32_into_64(false_reg);",
          "6402:   __reg_combine_32_into_64(true_reg);",
          "6403:  } else {",
          "6404:   false_reg->var_off = false_64off;",
          "6405:   true_reg->var_off = true_64off;",
          "6406:   __reg_combine_64_into_32(false_reg);",
          "6407:   __reg_combine_64_into_32(true_reg);",
          "6408:  }",
          "6415:     struct bpf_reg_state *false_reg,",
          "6416:     u64 val, u32 val32,",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "5885:  if (opcode)",
          "5887: }",
          "",
          "[Removed Lines]",
          "5886:   reg_set_min_max(true_reg, false_reg, val, opcode, is_jmp32);",
          "",
          "[Added Lines]",
          "6440:   reg_set_min_max(true_reg, false_reg, val, val32, opcode, is_jmp32);",
          "",
          "---------------",
          "--- Hunk 34 ---",
          "[Context before]",
          "6172:  dst_reg = &regs[insn->dst_reg];",
          "6173:  is_jmp32 = BPF_CLASS(insn->code) == BPF_JMP32;",
          "6182:  if (pred >= 0) {",
          "6183:   err = mark_chain_precision(env, insn->dst_reg);",
          "6184:   if (BPF_SRC(insn->code) == BPF_X && !err)",
          "",
          "[Removed Lines]",
          "6175:  if (BPF_SRC(insn->code) == BPF_K)",
          "6176:   pred = is_branch_taken(dst_reg, insn->imm,",
          "6177:            opcode, is_jmp32);",
          "6178:  else if (src_reg->type == SCALAR_VALUE &&",
          "6179:    tnum_is_const(src_reg->var_off))",
          "6180:   pred = is_branch_taken(dst_reg, src_reg->var_off.value,",
          "6181:            opcode, is_jmp32);",
          "",
          "[Added Lines]",
          "6729:  if (BPF_SRC(insn->code) == BPF_K) {",
          "6730:   pred = is_branch_taken(dst_reg, insn->imm, opcode, is_jmp32);",
          "6731:  } else if (src_reg->type == SCALAR_VALUE &&",
          "6732:      is_jmp32 && tnum_is_const(tnum_subreg(src_reg->var_off))) {",
          "6733:   pred = is_branch_taken(dst_reg,",
          "6734:            tnum_subreg(src_reg->var_off).value,",
          "6735:            opcode,",
          "6736:            is_jmp32);",
          "6737:  } else if (src_reg->type == SCALAR_VALUE &&",
          "6738:      !is_jmp32 && tnum_is_const(src_reg->var_off)) {",
          "6739:   pred = is_branch_taken(dst_reg,",
          "6740:            src_reg->var_off.value,",
          "6741:            opcode,",
          "6742:            is_jmp32);",
          "6743:  }",
          "",
          "---------------",
          "--- Hunk 35 ---",
          "[Context before]",
          "6213:  if (BPF_SRC(insn->code) == BPF_X) {",
          "6214:   struct bpf_reg_state *src_reg = &regs[insn->src_reg];",
          "6224:   if (dst_reg->type == SCALAR_VALUE &&",
          "6225:       src_reg->type == SCALAR_VALUE) {",
          "6226:    if (tnum_is_const(src_reg->var_off) ||",
          "6228:     reg_set_min_max(&other_branch_regs[insn->dst_reg],",
          "6229:       dst_reg,",
          "6233:       opcode, is_jmp32);",
          "6234:    else if (tnum_is_const(dst_reg->var_off) ||",
          "6236:     reg_set_min_max_inv(&other_branch_regs[insn->src_reg],",
          "6237:           src_reg,",
          "6241:           opcode, is_jmp32);",
          "6242:    else if (!is_jmp32 &&",
          "6243:      (opcode == BPF_JEQ || opcode == BPF_JNE))",
          "",
          "[Removed Lines]",
          "6215:   struct bpf_reg_state lo_reg0 = *dst_reg;",
          "6216:   struct bpf_reg_state lo_reg1 = *src_reg;",
          "6217:   struct bpf_reg_state *src_lo, *dst_lo;",
          "6219:   dst_lo = &lo_reg0;",
          "6220:   src_lo = &lo_reg1;",
          "6221:   coerce_reg_to_size(dst_lo, 4);",
          "6222:   coerce_reg_to_size(src_lo, 4);",
          "6227:        (is_jmp32 && tnum_is_const(src_lo->var_off)))",
          "6230:       is_jmp32",
          "6231:       ? src_lo->var_off.value",
          "6232:       : src_reg->var_off.value,",
          "6235:      (is_jmp32 && tnum_is_const(dst_lo->var_off)))",
          "6238:           is_jmp32",
          "6239:           ? dst_lo->var_off.value",
          "6240:           : dst_reg->var_off.value,",
          "",
          "[Added Lines]",
          "6782:        (is_jmp32 &&",
          "6783:         tnum_is_const(tnum_subreg(src_reg->var_off))))",
          "6786:       src_reg->var_off.value,",
          "6787:       tnum_subreg(src_reg->var_off).value,",
          "6790:      (is_jmp32 &&",
          "6791:       tnum_is_const(tnum_subreg(dst_reg->var_off))))",
          "6794:           dst_reg->var_off.value,",
          "6795:           tnum_subreg(dst_reg->var_off).value,",
          "",
          "---------------",
          "--- Hunk 36 ---",
          "[Context before]",
          "6248:   }",
          "6249:  } else if (dst_reg->type == SCALAR_VALUE) {",
          "6250:   reg_set_min_max(&other_branch_regs[insn->dst_reg],",
          "6252:  }",
          "",
          "[Removed Lines]",
          "6251:      dst_reg, insn->imm, opcode, is_jmp32);",
          "",
          "[Added Lines]",
          "6806:      dst_reg, insn->imm, (u32)insn->imm,",
          "6807:      opcode, is_jmp32);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
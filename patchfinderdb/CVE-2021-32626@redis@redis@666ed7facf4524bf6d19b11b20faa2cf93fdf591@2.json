{
  "cve_id": "CVE-2021-32626",
  "cve_desc": "Redis is an open source, in-memory database that persists on disk. In affected versions specially crafted Lua scripts executing in Redis can cause the heap-based Lua stack to be overflowed, due to incomplete checks for this condition. This can result with heap corruption and potentially remote code execution. This problem exists in all versions of Redis with Lua scripting support, starting from 2.6. The problem is fixed in versions 6.2.6, 6.0.16 and 5.0.14. For users unable to update an additional workaround to mitigate the problem without patching the redis-server executable is to prevent users from executing Lua scripts. This can be done using ACL to restrict EVAL and EVALSHA commands.",
  "repo": "redis/redis",
  "patch_hash": "666ed7facf4524bf6d19b11b20faa2cf93fdf591",
  "patch_info": {
    "commit_hash": "666ed7facf4524bf6d19b11b20faa2cf93fdf591",
    "repo": "redis/redis",
    "commit_url": "https://github.com/redis/redis/commit/666ed7facf4524bf6d19b11b20faa2cf93fdf591",
    "files": [
      "src/scripting.c"
    ],
    "message": "Fix invalid memory write on lua stack overflow {CVE-2021-32626}\n\nWhen LUA call our C code, by default, the LUA stack has room for 20\nelements. In most cases, this is more than enough but sometimes it's not\nand the caller must verify the LUA stack size before he pushes elements.\n\nOn 3 places in the code, there was no verification of the LUA stack size.\nOn specific inputs this missing verification could have lead to invalid\nmemory write:\n1. On 'luaReplyToRedisReply', one might return a nested reply that will\n   explode the LUA stack.\n2. On 'redisProtocolToLuaType', the Redis reply might be deep enough\n\u00a0 \u00a0to explode the LUA stack (notice that currently there is no such\n\u00a0 \u00a0command in Redis that returns such a nested reply, but modules might\n\u00a0 \u00a0do it)\n3. On 'ldbRedis', one might give a command with enough arguments to\n\u00a0 \u00a0explode the LUA stack (all the arguments will be pushed to the LUA\n\u00a0 \u00a0stack)\n\nThis commit is solving all those 3 issues by calling 'lua_checkstack' and\nverify that there is enough room in the LUA stack to push elements. In\ncase 'lua_checkstack' returns an error (there is not enough room in the\nLUA stack and it's not possible to increase the stack), we will do the\nfollowing:\n1. On 'luaReplyToRedisReply', we will return an error to the user.\n2. On 'redisProtocolToLuaType' we will exit with panic (we assume this\n   scenario is rare because it can only happen with a module).\n3. On 'ldbRedis', we return an error.",
    "before_after_code_files": [
      "src/scripting.c||src/scripting.c"
    ]
  },
  "patch_diff": {
    "src/scripting.c||src/scripting.c": [
      "File: src/scripting.c -> src/scripting.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "130: char *redisProtocolToLuaType(lua_State *lua, char* reply) {",
      "131:     char *p = reply;",
      "133:     switch(*p) {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "132:     if (!lua_checkstack(lua, 5)) {",
      "138:         serverPanic(\"lua stack limit reach when parsing redis.call reply\");",
      "139:     }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "220:             if (atype == '%') {",
      "221:                 p = redisProtocolToLuaType(lua,p);",
      "222:             } else {",
      "223:                 lua_pushboolean(lua,1);",
      "224:             }",
      "225:             lua_settable(lua,-3);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "233:                 if (!lua_checkstack(lua, 1)) {",
      "236:                     serverPanic(\"lua stack limit reach when parsing redis.call reply\");",
      "237:                 }",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "341: void luaReplyToRedisReply(client *c, lua_State *lua) {",
      "342:     int t = lua_type(lua,-1);",
      "344:     switch(t) {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "358:     if (!lua_checkstack(lua, 4)) {",
      "363:         addReplyErrorFormat(c, \"reached lua stack limit\");",
      "364:         lua_pop(lua,1); // pop the element from the stack",
      "365:         return;",
      "366:     }",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "2506: void ldbRedis(lua_State *lua, sds *argv, int argc) {",
      "2507:     int j, saved_rc = server.lua_replicate_commands;",
      "2509:     lua_getglobal(lua,\"redis\");",
      "2510:     lua_pushstring(lua,\"call\");",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2539:     if (!lua_checkstack(lua, argc + 1)) {",
      "2546:         ldbLogRedisReply(\"max lua stack reached\");",
      "2547:         return;",
      "2548:     }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "5895d119b1c2825ff0394f30e246e036c3972bc5",
      "candidate_info": {
        "commit_hash": "5895d119b1c2825ff0394f30e246e036c3972bc5",
        "repo": "redis/redis",
        "commit_url": "https://github.com/redis/redis/commit/5895d119b1c2825ff0394f30e246e036c3972bc5",
        "files": [
          "00-RELEASENOTES",
          "src/version.h"
        ],
        "message": "Redis 6.0.16",
        "before_after_code_files": [
          "src/version.h||src/version.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/redis/redis/pull/9584"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/version.h||src/version.h": [
          "File: src/version.h -> src/version.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: #define REDIS_VERSION \"6.0.15\"",
          "2: #define REDIS_VERSION_NUM 0x0006000f",
          "",
          "[Added Lines]",
          "1: #define REDIS_VERSION \"6.0.16\"",
          "2: #define REDIS_VERSION_NUM 0x00060010",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "f6a40570fa63d5afdd596c78083d754081d80ae3",
      "candidate_info": {
        "commit_hash": "f6a40570fa63d5afdd596c78083d754081d80ae3",
        "repo": "redis/redis",
        "commit_url": "https://github.com/redis/redis/commit/f6a40570fa63d5afdd596c78083d754081d80ae3",
        "files": [
          "src/geo.c",
          "src/listpack.c",
          "src/quicklist.c",
          "src/rdb.c",
          "src/server.h",
          "src/t_hash.c",
          "src/t_list.c",
          "src/t_stream.c",
          "src/t_zset.c",
          "src/ziplist.c",
          "src/ziplist.h",
          "tests/support/util.tcl",
          "tests/unit/violations.tcl"
        ],
        "message": "Fix ziplist and listpack overflows and truncations (CVE-2021-32627, CVE-2021-32628)\n\n- fix possible heap corruption in ziplist and listpack resulting by trying to\n  allocate more than the maximum size of 4GB.\n- prevent ziplist (hash and zset) from reaching size of above 1GB, will be\n  converted to HT encoding, that's not a useful size.\n- prevent listpack (stream) from reaching size of above 1GB.\n- XADD will start a new listpack if the new record may cause the previous\n  listpack to grow over 1GB.\n- XADD will respond with an error if a single stream record is over 1GB\n- List type (ziplist in quicklist) was truncating strings that were over 4GB,\n  now it'll respond with an error.",
        "before_after_code_files": [
          "src/geo.c||src/geo.c",
          "src/listpack.c||src/listpack.c",
          "src/quicklist.c||src/quicklist.c",
          "src/rdb.c||src/rdb.c",
          "src/server.h||src/server.h",
          "src/t_hash.c||src/t_hash.c",
          "src/t_list.c||src/t_list.c",
          "src/t_stream.c||src/t_stream.c",
          "src/t_zset.c||src/t_zset.c",
          "src/ziplist.c||src/ziplist.c",
          "src/ziplist.h||src/ziplist.h",
          "tests/support/util.tcl||tests/support/util.tcl",
          "tests/unit/violations.tcl||tests/unit/violations.tcl"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/redis/redis/pull/9584"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/geo.c||src/geo.c": [
          "File: src/geo.c -> src/geo.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "635:         robj *zobj;",
          "636:         zset *zs;",
          "637:         int i;",
          "640:         if (returned_items) {",
          "641:             zobj = createZsetObject();",
          "",
          "[Removed Lines]",
          "638:         size_t maxelelen = 0;",
          "",
          "[Added Lines]",
          "638:         size_t maxelelen = 0, totelelen = 0;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "650:             size_t elelen = sdslen(gp->member);",
          "652:             if (maxelelen < elelen) maxelelen = elelen;",
          "653:             znode = zslInsert(zs->zsl,score,gp->member);",
          "654:             serverAssert(dictAdd(zs->dict,gp->member,&znode->score) == DICT_OK);",
          "655:             gp->member = NULL;",
          "656:         }",
          "658:         if (returned_items) {",
          "660:             setKey(c,c->db,storekey,zobj);",
          "661:             decrRefCount(zobj);",
          "662:             notifyKeyspaceEvent(NOTIFY_ZSET,\"georadiusstore\",storekey,",
          "",
          "[Removed Lines]",
          "659:             zsetConvertToZiplistIfNeeded(zobj,maxelelen);",
          "",
          "[Added Lines]",
          "653:             totelelen += elelen;",
          "660:             zsetConvertToZiplistIfNeeded(zobj,maxelelen,totelelen);",
          "",
          "---------------"
        ],
        "src/listpack.c||src/listpack.c": [
          "File: src/listpack.c -> src/listpack.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "283:     } else {",
          "284:         if (size < 64) *enclen = 1+size;",
          "285:         else if (size < 4096) *enclen = 2+size;",
          "287:         return LP_ENCODING_STRING;",
          "288:     }",
          "289: }",
          "",
          "[Removed Lines]",
          "286:         else *enclen = 5+size;",
          "",
          "[Added Lines]",
          "286:         else *enclen = 5+(uint64_t)size;",
          "",
          "---------------"
        ],
        "src/quicklist.c||src/quicklist.c": [
          "File: src/quicklist.c -> src/quicklist.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "32: #include \"quicklist.h\"",
          "33: #include \"zmalloc.h\"",
          "34: #include \"ziplist.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "32: #include \"redisassert.h\"",
          "",
          "---------------"
        ],
        "src/rdb.c||src/rdb.c": [
          "File: src/rdb.c -> src/rdb.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1561:     } else if (rdbtype == RDB_TYPE_ZSET_2 || rdbtype == RDB_TYPE_ZSET) {",
          "1563:         uint64_t zsetlen;",
          "1565:         zset *zs;",
          "1567:         if ((zsetlen = rdbLoadLen(rdb,NULL)) == RDB_LENERR) return NULL;",
          "",
          "[Removed Lines]",
          "1564:         size_t maxelelen = 0;",
          "",
          "[Added Lines]",
          "1564:         size_t maxelelen = 0, totelelen = 0;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1600:             if (sdslen(sdsele) > maxelelen) maxelelen = sdslen(sdsele);",
          "1602:             znode = zslInsert(zs->zsl,score,sdsele);",
          "1603:             dictAdd(zs->dict,sdsele,&znode->score);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1601:             totelelen += sdslen(sdsele);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1607:         if (zsetLength(o) <= server.zset_max_ziplist_entries &&",
          "1610:     } else if (rdbtype == RDB_TYPE_HASH) {",
          "1611:         uint64_t len;",
          "1612:         int ret;",
          "",
          "[Removed Lines]",
          "1608:             maxelelen <= server.zset_max_ziplist_value)",
          "1609:                 zsetConvert(o,OBJ_ENCODING_ZIPLIST);",
          "",
          "[Added Lines]",
          "1609:             maxelelen <= server.zset_max_ziplist_value &&",
          "1610:             ziplistSafeToAdd(NULL, totelelen))",
          "1611:         {",
          "1612:             zsetConvert(o,OBJ_ENCODING_ZIPLIST);",
          "1613:         }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1635:                 return NULL;",
          "1636:             }",
          "1645:             if (sdslen(field) > server.hash_max_ziplist_value ||",
          "1647:             {",
          "1650:                 hashTypeConvert(o, OBJ_ENCODING_HT);",
          "1651:                 break;",
          "1652:             }",
          "1653:             sdsfree(field);",
          "1654:             sdsfree(value);",
          "1655:         }",
          "",
          "[Removed Lines]",
          "1639:             o->ptr = ziplistPush(o->ptr, (unsigned char*)field,",
          "1640:                     sdslen(field), ZIPLIST_TAIL);",
          "1641:             o->ptr = ziplistPush(o->ptr, (unsigned char*)value,",
          "1642:                     sdslen(value), ZIPLIST_TAIL);",
          "1646:                 sdslen(value) > server.hash_max_ziplist_value)",
          "1648:                 sdsfree(field);",
          "1649:                 sdsfree(value);",
          "",
          "[Added Lines]",
          "1644:                 sdslen(value) > server.hash_max_ziplist_value ||",
          "1645:                 !ziplistSafeToAdd(o->ptr, sdslen(field)+sdslen(value)))",
          "1648:                 ret = dictAdd((dict*)o->ptr, field, value);",
          "1649:                 if (ret == DICT_ERR) {",
          "1650:                     rdbExitReportCorruptRDB(\"Duplicate hash fields detected\");",
          "1651:                 }",
          "1656:             o->ptr = ziplistPush(o->ptr, (unsigned char*)field,",
          "1657:                     sdslen(field), ZIPLIST_TAIL);",
          "1658:             o->ptr = ziplistPush(o->ptr, (unsigned char*)value,",
          "1659:                     sdslen(value), ZIPLIST_TAIL);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1726:                     while ((zi = zipmapNext(zi, &fstr, &flen, &vstr, &vlen)) != NULL) {",
          "1727:                         if (flen > maxlen) maxlen = flen;",
          "1728:                         if (vlen > maxlen) maxlen = vlen;",
          "1729:                         zl = ziplistPush(zl, fstr, flen, ZIPLIST_TAIL);",
          "1730:                         zl = ziplistPush(zl, vstr, vlen, ZIPLIST_TAIL);",
          "1731:                     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1737:                         if (!ziplistSafeToAdd(zl, (size_t)flen + vlen)) {",
          "1738:                             rdbExitReportCorruptRDB(\"Hash zipmap too big (%u)\", flen);",
          "1739:                         }",
          "",
          "---------------"
        ],
        "src/server.h||src/server.h": [
          "File: src/server.h -> src/server.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "1999: unsigned char *zzlLastInRange(unsigned char *zl, zrangespec *range);",
          "2000: unsigned long zsetLength(const robj *zobj);",
          "2001: void zsetConvert(robj *zobj, int encoding);",
          "2003: int zsetScore(robj *zobj, sds member, double *score);",
          "2004: unsigned long zslGetRank(zskiplist *zsl, double score, sds o);",
          "2005: int zsetAdd(robj *zobj, double score, sds ele, int *flags, double *newscore);",
          "",
          "[Removed Lines]",
          "2002: void zsetConvertToZiplistIfNeeded(robj *zobj, size_t maxelelen);",
          "",
          "[Added Lines]",
          "2002: void zsetConvertToZiplistIfNeeded(robj *zobj, size_t maxelelen, size_t totelelen);",
          "",
          "---------------"
        ],
        "src/t_hash.c||src/t_hash.c": [
          "File: src/t_hash.c -> src/t_hash.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "40: void hashTypeTryConversion(robj *o, robj **argv, int start, int end) {",
          "41:     int i;",
          "43:     if (o->encoding != OBJ_ENCODING_ZIPLIST) return;",
          "45:     for (i = start; i <= end; i++) {",
          "49:             hashTypeConvert(o, OBJ_ENCODING_HT);",
          "51:         }",
          "52:     }",
          "53: }",
          "",
          "[Removed Lines]",
          "46:         if (sdsEncodedObject(argv[i]) &&",
          "47:             sdslen(argv[i]->ptr) > server.hash_max_ziplist_value)",
          "48:         {",
          "50:             break;",
          "",
          "[Added Lines]",
          "42:     size_t sum = 0;",
          "47:         if (!sdsEncodedObject(argv[i]))",
          "48:             continue;",
          "49:         size_t len = sdslen(argv[i]->ptr);",
          "50:         if (len > server.hash_max_ziplist_value) {",
          "52:             return;",
          "54:         sum += len;",
          "56:     if (!ziplistSafeToAdd(o->ptr, sum))",
          "57:         hashTypeConvert(o, OBJ_ENCODING_HT);",
          "",
          "---------------"
        ],
        "src/t_list.c||src/t_list.c": [
          "File: src/t_list.c -> src/t_list.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "30: #include \"server.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "32: #define LIST_MAX_ITEM_SIZE ((1ull<<32)-1024)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "197: void pushGenericCommand(client *c, int where) {",
          "198:     int j, pushed = 0;",
          "199:     robj *lobj = lookupKeyWrite(c->db,c->argv[1]);",
          "201:     if (lobj && lobj->type != OBJ_LIST) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "202:     for (j = 2; j < c->argc; j++) {",
          "203:         if (sdslen(c->argv[j]->ptr) > LIST_MAX_ITEM_SIZE) {",
          "204:             addReplyError(c, \"Element too large\");",
          "205:             return;",
          "206:         }",
          "207:     }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "277:         return;",
          "278:     }",
          "280:     if ((subject = lookupKeyWriteOrReply(c,c->argv[1],shared.czero)) == NULL ||",
          "281:         checkType(c,subject,OBJ_LIST)) return;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "290:     if (sdslen(c->argv[4]->ptr) > LIST_MAX_ITEM_SIZE) {",
          "291:         addReplyError(c, \"Element too large\");",
          "292:         return;",
          "293:     }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "344:     long index;",
          "345:     robj *value = c->argv[3];",
          "347:     if ((getLongFromObjectOrReply(c, c->argv[2], &index, NULL) != C_OK))",
          "348:         return;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "362:     if (sdslen(value->ptr) > LIST_MAX_ITEM_SIZE) {",
          "363:         addReplyError(c, \"Element too large\");",
          "364:         return;",
          "365:     }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "510:     int direction = LIST_TAIL;",
          "514:     for (int j = 3; j < c->argc; j++) {",
          "515:         char *opt = c->argv[j]->ptr;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "533:     if (sdslen(ele->ptr) > LIST_MAX_ITEM_SIZE) {",
          "534:         addReplyError(c, \"Element too large\");",
          "535:         return;",
          "536:     }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "610:     long toremove;",
          "611:     long removed = 0;",
          "613:     if ((getLongFromObjectOrReply(c, c->argv[2], &toremove, NULL) != C_OK))",
          "614:         return;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "638:     if (sdslen(obj->ptr) > LIST_MAX_ITEM_SIZE) {",
          "639:         addReplyError(c, \"Element too large\");",
          "640:         return;",
          "641:     }",
          "",
          "---------------"
        ],
        "src/t_stream.c||src/t_stream.c": [
          "File: src/t_stream.c -> src/t_stream.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "43: void streamFreeCG(streamCG *cg);",
          "44: void streamFreeNACK(streamNACK *na);",
          "45: size_t streamReplyWithRangeFromConsumerPEL(client *c, stream *s, streamID *start, streamID *end, size_t count, streamConsumer *consumer);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "47: #define STREAM_LISTPACK_MAX_SIZE (1<<30)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "212:     raxIterator ri;",
          "",
          "[Removed Lines]",
          "209:     if (streamCompareID(&id,&s->last_id) <= 0) return C_ERR;",
          "",
          "[Added Lines]",
          "218:     if (streamCompareID(&id,&s->last_id) <= 0) {",
          "219:         errno = EDOM;",
          "220:         return C_ERR;",
          "221:     }",
          "226:     size_t totelelen = 0;",
          "227:     for (int64_t i = 0; i < numfields*2; i++) {",
          "228:         sds ele = argv[i]->ptr;",
          "229:         totelelen += sdslen(ele);",
          "230:     }",
          "231:     if (totelelen > STREAM_LISTPACK_MAX_SIZE) {",
          "232:         errno = ERANGE;",
          "233:         return C_ERR;",
          "234:     }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "267:     if (lp != NULL) {",
          "271:             lp = NULL;",
          "272:         } else if (server.stream_node_max_entries) {",
          "273:             int64_t count = lpGetInteger(lpFirst(lp));",
          "",
          "[Removed Lines]",
          "268:         if (server.stream_node_max_bytes &&",
          "269:             lp_bytes >= server.stream_node_max_bytes)",
          "270:         {",
          "",
          "[Added Lines]",
          "293:         size_t node_max_bytes = server.stream_node_max_bytes;",
          "294:         if (node_max_bytes == 0 || node_max_bytes > STREAM_LISTPACK_MAX_SIZE)",
          "295:             node_max_bytes = STREAM_LISTPACK_MAX_SIZE;",
          "296:         if (lp_bytes + totelelen >= node_max_bytes) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1269:     if (streamAppendItem(s,c->argv+field_pos,(c->argc-field_pos)/2,",
          "1272:     {",
          "1275:         return;",
          "1276:     }",
          "1277:     addReplyStreamID(c,&id);",
          "",
          "[Removed Lines]",
          "1270:         &id, id_given ? &id : NULL)",
          "1271:         == C_ERR)",
          "1273:         addReplyError(c,\"The ID specified in XADD is equal or smaller than the \"",
          "1274:                         \"target stream top item\");",
          "",
          "[Added Lines]",
          "1296:         &id, id_given ? &id : NULL) == C_ERR)",
          "1298:         if (errno == EDOM)",
          "1299:             addReplyError(c,\"The ID specified in XADD is equal or smaller than \"",
          "1300:                             \"the target stream top item\");",
          "1301:         else",
          "1302:             addReplyError(c,\"Elements are too large to be stored\");",
          "",
          "---------------"
        ],
        "src/t_zset.c||src/t_zset.c": [
          "File: src/t_zset.c -> src/t_zset.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1238: }",
          "1244:     if (zobj->encoding == OBJ_ENCODING_ZIPLIST) return;",
          "1245:     zset *zset = zobj->ptr;",
          "1247:     if (zset->zsl->length <= server.zset_max_ziplist_entries &&",
          "1250: }",
          "",
          "[Removed Lines]",
          "1243: void zsetConvertToZiplistIfNeeded(robj *zobj, size_t maxelelen) {",
          "1248:         maxelelen <= server.zset_max_ziplist_value)",
          "1249:             zsetConvert(zobj,OBJ_ENCODING_ZIPLIST);",
          "",
          "[Added Lines]",
          "1243: void zsetConvertToZiplistIfNeeded(robj *zobj, size_t maxelelen, size_t totelelen) {",
          "1248:         maxelelen <= server.zset_max_ziplist_value &&",
          "1249:         ziplistSafeToAdd(NULL, totelelen))",
          "1250:     {",
          "1251:         zsetConvert(zobj,OBJ_ENCODING_ZIPLIST);",
          "1252:     }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1355:             }",
          "1356:             return 1;",
          "1357:         } else if (!xx) {",
          "1363:                 zsetConvert(zobj,OBJ_ENCODING_SKIPLIST);",
          "1367:         } else {",
          "1369:             return 1;",
          "1370:         }",
          "1372:         zset *zs = zobj->ptr;",
          "1373:         zskiplistNode *znode;",
          "1374:         dictEntry *de;",
          "",
          "[Removed Lines]",
          "1360:             zobj->ptr = zzlInsert(zobj->ptr,ele,score);",
          "1361:             if (zzlLength(zobj->ptr) > server.zset_max_ziplist_entries ||",
          "1362:                 sdslen(ele) > server.zset_max_ziplist_value)",
          "1364:             if (newscore) *newscore = score;",
          "1366:             return 1;",
          "1371:     } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {",
          "",
          "[Added Lines]",
          "1363:             if (zzlLength(zobj->ptr)+1 > server.zset_max_ziplist_entries ||",
          "1364:                 sdslen(ele) > server.zset_max_ziplist_value ||",
          "1365:                 !ziplistSafeToAdd(zobj->ptr, sdslen(ele)))",
          "1366:             {",
          "1368:             } else {",
          "1369:                 zobj->ptr = zzlInsert(zobj->ptr,ele,score);",
          "1370:                 if (newscore) *newscore = score;",
          "1372:                 return 1;",
          "1373:             }",
          "1378:     }",
          "1382:     if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2180:     zsetopsrc *src;",
          "2181:     zsetopval zval;",
          "2182:     sds tmp;",
          "2184:     robj *dstobj;",
          "2185:     zset *dstzset;",
          "2186:     zskiplistNode *znode;",
          "",
          "[Removed Lines]",
          "2183:     size_t maxelelen = 0;",
          "",
          "[Added Lines]",
          "2194:     size_t maxelelen = 0, totelelen = 0;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2304:                     tmp = zuiNewSdsFromValue(&zval);",
          "2305:                     znode = zslInsert(dstzset->zsl,score,tmp);",
          "2306:                     dictAdd(dstzset->dict,tmp,&znode->score);",
          "2307:                     if (sdslen(tmp) > maxelelen) maxelelen = sdslen(tmp);",
          "2308:                 }",
          "2309:             }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2318:                     totelelen += sdslen(tmp);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2343:                      if (sdslen(tmp) > maxelelen) maxelelen = sdslen(tmp);",
          "2345:                     dictSetKey(accumulator, de, tmp);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2355:                      totelelen += sdslen(tmp);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2380:     if (dbDelete(c->db,dstkey))",
          "2381:         touched = 1;",
          "2382:     if (dstzset->zsl->length) {",
          "2384:         dbAdd(c->db,dstkey,dstobj);",
          "2385:         addReplyLongLong(c,zsetLength(dstobj));",
          "2386:         signalModifiedKey(c,c->db,dstkey);",
          "",
          "[Removed Lines]",
          "2383:         zsetConvertToZiplistIfNeeded(dstobj,maxelelen);",
          "",
          "[Added Lines]",
          "2396:         zsetConvertToZiplistIfNeeded(dstobj,maxelelen,totelelen);",
          "",
          "---------------"
        ],
        "src/ziplist.c||src/ziplist.c": [
          "File: src/ziplist.c -> src/ziplist.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "265:         ZIPLIST_LENGTH(zl) = intrev16ifbe(intrev16ifbe(ZIPLIST_LENGTH(zl))+incr); \\",
          "266: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "270: #define ZIPLIST_MAX_SAFETY_SIZE (1<<30)",
          "271: int ziplistSafeToAdd(unsigned char* zl, size_t add) {",
          "272:     size_t len = zl? ziplistBlobLen(zl): 0;",
          "273:     if (len + add > ZIPLIST_MAX_SAFETY_SIZE)",
          "274:         return 0;",
          "275:     return 1;",
          "276: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "586: }",
          "590:     zl = zrealloc(zl,len);",
          "591:     ZIPLIST_BYTES(zl) = intrev32ifbe(len);",
          "592:     zl[len-1] = ZIP_END;",
          "",
          "[Removed Lines]",
          "589: unsigned char *ziplistResize(unsigned char *zl, unsigned int len) {",
          "",
          "[Added Lines]",
          "600: unsigned char *ziplistResize(unsigned char *zl, size_t len) {",
          "601:     assert(len < UINT32_MAX);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "899:     zllength = zllength < UINT16_MAX ? zllength : UINT16_MAX;",
          "902:     size_t first_offset = intrev32ifbe(ZIPLIST_TAIL_OFFSET(*first));",
          "903:     size_t second_offset = intrev32ifbe(ZIPLIST_TAIL_OFFSET(*second));",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "914:     assert(zlbytes < UINT32_MAX);",
          "",
          "---------------"
        ],
        "src/ziplist.h||src/ziplist.h": [
          "File: src/ziplist.h -> src/ziplist.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "49: unsigned int ziplistLen(unsigned char *zl);",
          "50: size_t ziplistBlobLen(unsigned char *zl);",
          "51: void ziplistRepr(unsigned char *zl);",
          "53: #ifdef REDIS_TEST",
          "54: int ziplistTest(int argc, char *argv[]);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "52: int ziplistSafeToAdd(unsigned char* zl, size_t add);",
          "",
          "---------------"
        ],
        "tests/support/util.tcl||tests/support/util.tcl": [
          "File: tests/support/util.tcl -> tests/support/util.tcl",
          "--- Hunk 1 ---",
          "[Context before]",
          "110: # count current log lines in server's stdout",
          "111: proc count_log_lines {srv_idx} {",
          "113: }",
          "115: # verify pattern exists in server's sdtout after a certain line number",
          "",
          "[Removed Lines]",
          "112:     set _ [exec wc -l < [srv $srv_idx stdout]]",
          "",
          "[Added Lines]",
          "112:     set _ [string trim [exec wc -l < [srv $srv_idx stdout]]]",
          "113: }",
          "115: # returns the number of times a line with that pattern appears in a file",
          "116: proc count_message_lines {file pattern} {",
          "117:     set res 0",
          "118:     # exec fails when grep exists with status other than 0 (when the patter wasn't found)",
          "119:     catch {",
          "120:         set res [string trim [exec grep $pattern $file 2> /dev/null | wc -l]]",
          "121:     }",
          "122:     return $res",
          "123: }",
          "125: # returns the number of times a line with that pattern appears in the log",
          "126: proc count_log_message {srv_idx pattern} {",
          "127:     set stdout [srv $srv_idx stdout]",
          "128:     return [count_message_lines $stdout $pattern]",
          "",
          "---------------"
        ],
        "tests/unit/violations.tcl||tests/unit/violations.tcl": [
          "File: tests/unit/violations.tcl -> tests/unit/violations.tcl",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: # These tests consume massive amounts of memory, and are not",
          "2: # suitable to be executed as part of the normal test suite",
          "3: set ::str500 [string repeat x 500000000] ;# 500mb",
          "5: # Utility function to write big argument into redis client connection",
          "6: proc write_big_bulk {size} {",
          "7:     r write \"\\$$size\\r\\n\"",
          "8:     while {$size >= 500000000} {",
          "9:         r write $::str500",
          "10:         incr size -500000000",
          "11:     }",
          "12:     if {$size > 0} {",
          "13:         r write [string repeat x $size]",
          "14:     }",
          "15:     r write \"\\r\\n\"",
          "16: }",
          "18: # One XADD with one huge 5GB field",
          "19: # Expected to fail resulting in an empty stream",
          "20: start_server [list overrides [list save \"\"] ] {",
          "21:     test {XADD one huge field} {",
          "22:         r config set proto-max-bulk-len 10000000000 ;#10gb",
          "23:         r config set client-query-buffer-limit 10000000000 ;#10gb",
          "24:         r write \"*5\\r\\n\\$4\\r\\nXADD\\r\\n\\$2\\r\\nS1\\r\\n\\$1\\r\\n*\\r\\n\"",
          "25:         r write \"\\$1\\r\\nA\\r\\n\"",
          "26:         write_big_bulk 5000000000 ;#5gb",
          "27:         r flush",
          "28:         catch {r read} err",
          "29:         assert_match {*too large*} $err",
          "30:         r xlen S1",
          "31:     } {0}",
          "32: }",
          "34: # One XADD with one huge (exactly nearly) 4GB field",
          "35: # This uncovers the overflow in lpEncodeGetType",
          "36: # Expected to fail resulting in an empty stream",
          "37: start_server [list overrides [list save \"\"] ] {",
          "38:     test {XADD one huge field - 1} {",
          "39:         r config set proto-max-bulk-len 10000000000 ;#10gb",
          "40:         r config set client-query-buffer-limit 10000000000 ;#10gb",
          "41:         r write \"*5\\r\\n\\$4\\r\\nXADD\\r\\n\\$2\\r\\nS1\\r\\n\\$1\\r\\n*\\r\\n\"",
          "42:         r write \"\\$1\\r\\nA\\r\\n\"",
          "43:         write_big_bulk 4294967295 ;#4gb-1",
          "44:         r flush",
          "45:         catch {r read} err",
          "46:         assert_match {*too large*} $err",
          "47:         r xlen S1",
          "48:     } {0}",
          "49: }",
          "51: # Gradually add big stream fields using repeated XADD calls",
          "52: start_server [list overrides [list save \"\"] ] {",
          "53:     test {several XADD big fields} {",
          "54:         r config set stream-node-max-bytes 0",
          "55:         for {set j 0} {$j<10} {incr j} {",
          "56:             r xadd stream * 1 $::str500 2 $::str500",
          "57:         }",
          "58:         r ping",
          "59:         r xlen stream",
          "60:     } {10}",
          "61: }",
          "63: # Add over 4GB to a single stream listpack (one XADD command)",
          "64: # Expected to fail resulting in an empty stream",
          "65: start_server [list overrides [list save \"\"] ] {",
          "66:     test {single XADD big fields} {",
          "67:         r write \"*23\\r\\n\\$4\\r\\nXADD\\r\\n\\$1\\r\\nS\\r\\n\\$1\\r\\n*\\r\\n\"",
          "68:         for {set j 0} {$j<10} {incr j} {",
          "69:             r write \"\\$1\\r\\n$j\\r\\n\"",
          "70:             write_big_bulk 500000000 ;#500mb",
          "71:         }",
          "72:         r flush",
          "73:         catch {r read} err",
          "74:         assert_match {*too large*} $err",
          "75:         r xlen S",
          "76:     } {0}",
          "77: }",
          "79: # Gradually add big hash fields using repeated HSET calls",
          "80: # This reproduces the overflow in the call to ziplistResize",
          "81: # Object will be converted to hashtable encoding",
          "82: start_server [list overrides [list save \"\"] ] {",
          "83:     r config set hash-max-ziplist-value 1000000000 ;#1gb",
          "84:     test {hash with many big fields} {",
          "85:         for {set j 0} {$j<10} {incr j} {",
          "86:             r hset h $j $::str500",
          "87:         }",
          "88:         r object encoding h",
          "89:     } {hashtable}",
          "90: }",
          "92: # Add over 4GB to a single hash field (one HSET command)",
          "93: # Object will be converted to hashtable encoding",
          "94: start_server [list overrides [list save \"\"] ] {",
          "95:     test {hash with one huge field} {",
          "96:         catch {r config set hash-max-ziplist-value 10000000000} ;#10gb",
          "97:         r config set proto-max-bulk-len 10000000000 ;#10gb",
          "98:         r config set client-query-buffer-limit 10000000000 ;#10gb",
          "99:         r write \"*4\\r\\n\\$4\\r\\nHSET\\r\\n\\$2\\r\\nH1\\r\\n\"",
          "100:         r write \"\\$1\\r\\nA\\r\\n\"",
          "101:         write_big_bulk 5000000000 ;#5gb",
          "102:         r flush",
          "103:         r read",
          "104:         r object encoding H1",
          "105:     } {hashtable}",
          "106: }",
          "108: # Add over 4GB to a single list member (one LPUSH command)",
          "109: # Currently unsupported, and expected to fail rather than being truncated",
          "110: # Expected to fail resulting in a non-existing list",
          "111: start_server [list overrides [list save \"\"] ] {",
          "112:     test {list with one huge field} {",
          "113:         r config set proto-max-bulk-len 10000000000 ;#10gb",
          "114:         r config set client-query-buffer-limit 10000000000 ;#10gb",
          "115:         r write \"*3\\r\\n\\$5\\r\\nLPUSH\\r\\n\\$2\\r\\nL1\\r\\n\"",
          "116:         write_big_bulk 5000000000 ;#5gb",
          "117:         r flush",
          "118:         catch {r read} err",
          "119:         assert_match {*too large*} $err",
          "120:         r exists L1",
          "121:     } {0}",
          "122: }",
          "124: # SORT which attempts to store an element larger than 4GB into a list.",
          "125: # Currently unsupported and results in an assertion instead of truncation",
          "126: start_server [list overrides [list save \"\"] ] {",
          "127:     test {SORT adds huge field to list} {",
          "128:         r config set proto-max-bulk-len 10000000000 ;#10gb",
          "129:         r config set client-query-buffer-limit 10000000000 ;#10gb",
          "130:         r write \"*3\\r\\n\\$3\\r\\nSET\\r\\n\\$2\\r\\nS1\\r\\n\"",
          "131:         write_big_bulk 5000000000 ;#5gb",
          "132:         r flush",
          "133:         r read",
          "134:         assert_equal [r strlen S1] 5000000000",
          "135:         r set S2 asdf",
          "136:         r sadd myset 1 2",
          "137:         r mset D1 1 D2 2",
          "138:         catch {r sort myset by D* get S* store mylist}",
          "139:         # assert_equal [count_log_message 0 \"crashed by signal\"] 0   - not suitable for 6.0",
          "140:         assert_equal [count_log_message 0 \"ASSERTION FAILED\"] 1",
          "141:     }",
          "142: }",
          "144: # SORT which stores an integer encoded element into a list.",
          "145: # Just for coverage, no news here.",
          "146: start_server [list overrides [list save \"\"] ] {",
          "147:     test {SORT adds integer field to list} {",
          "148:         r set S1 asdf",
          "149:         r set S2 123 ;# integer encoded",
          "150:         assert_encoding \"int\" S2",
          "151:         r sadd myset 1 2",
          "152:         r mset D1 1 D2 2",
          "153:         r sort myset by D* get S* store mylist",
          "154:         r llen mylist",
          "155:     } {2}",
          "156: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "a4b813d8b844094fcd77c511af596866043b20c8",
      "candidate_info": {
        "commit_hash": "a4b813d8b844094fcd77c511af596866043b20c8",
        "repo": "redis/redis",
        "commit_url": "https://github.com/redis/redis/commit/a4b813d8b844094fcd77c511af596866043b20c8",
        "files": [
          "src/scripting.c"
        ],
        "message": "Fix invalid memory write on lua stack overflow {CVE-2021-32626}\n\nWhen LUA call our C code, by default, the LUA stack has room for 20\nelements. In most cases, this is more than enough but sometimes it's not\nand the caller must verify the LUA stack size before he pushes elements.\n\nOn 3 places in the code, there was no verification of the LUA stack size.\nOn specific inputs this missing verification could have lead to invalid\nmemory write:\n1. On 'luaReplyToRedisReply', one might return a nested reply that will\n   explode the LUA stack.\n2. On 'redisProtocolToLuaType', the Redis reply might be deep enough\n\u00a0 \u00a0to explode the LUA stack (notice that currently there is no such\n\u00a0 \u00a0command in Redis that returns such a nested reply, but modules might\n\u00a0 \u00a0do it)\n3. On 'ldbRedis', one might give a command with enough arguments to\n\u00a0 \u00a0explode the LUA stack (all the arguments will be pushed to the LUA\n\u00a0 \u00a0stack)\n\nThis commit is solving all those 3 issues by calling 'lua_checkstack' and\nverify that there is enough room in the LUA stack to push elements. In\ncase 'lua_checkstack' returns an error (there is not enough room in the\nLUA stack and it's not possible to increase the stack), we will do the\nfollowing:\n1. On 'luaReplyToRedisReply', we will return an error to the user.\n2. On 'redisProtocolToLuaType' we will exit with panic (we assume this\n   scenario is rare because it can only happen with a module).\n3. On 'ldbRedis', we return an error.\n\n(cherry picked from commit d32a3f74f2a343846b50920e95754a955c1a10a9)",
        "before_after_code_files": [
          "src/scripting.c||src/scripting.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "src/scripting.c||src/scripting.c"
          ],
          "candidate": [
            "src/scripting.c||src/scripting.c"
          ]
        }
      },
      "candidate_diff": {
        "src/scripting.c||src/scripting.c": [
          "File: src/scripting.c -> src/scripting.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "127: char *redisProtocolToLuaType(lua_State *lua, char* reply) {",
          "128:     char *p = reply;",
          "130:     switch(*p) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "129:     if (!lua_checkstack(lua, 5)) {",
          "135:         serverPanic(\"lua stack limit reach when parsing redis.call reply\");",
          "136:     }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "277: void luaReplyToRedisReply(client *c, lua_State *lua) {",
          "278:     int t = lua_type(lua,-1);",
          "280:     switch(t) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "289:     if (!lua_checkstack(lua, 4)) {",
          "294:         addReplyErrorFormat(c, \"reached lua stack limit\");",
          "295:         lua_pop(lua,1); // pop the element from the stack",
          "296:         return;",
          "297:     }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2243: void ldbRedis(lua_State *lua, sds *argv, int argc) {",
          "2244:     int j, saved_rc = server.lua_replicate_commands;",
          "2246:     lua_getglobal(lua,\"redis\");",
          "2247:     lua_pushstring(lua,\"call\");",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2271:     if (!lua_checkstack(lua, argc + 1)) {",
          "2278:         ldbLogRedisReply(\"max lua stack reached\");",
          "2279:         return;",
          "2280:     }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "8f241ab3b8095186d008dbf78f0af90918f129bc",
      "candidate_info": {
        "commit_hash": "8f241ab3b8095186d008dbf78f0af90918f129bc",
        "repo": "redis/redis",
        "commit_url": "https://github.com/redis/redis/commit/8f241ab3b8095186d008dbf78f0af90918f129bc",
        "files": [
          "src/scripting.c"
        ],
        "message": "Fix invalid memory write on lua stack overflow {CVE-2021-32626}\n\nWhen LUA call our C code, by default, the LUA stack has room for 20\nelements. In most cases, this is more than enough but sometimes it's not\nand the caller must verify the LUA stack size before he pushes elements.\n\nOn 3 places in the code, there was no verification of the LUA stack size.\nOn specific inputs this missing verification could have lead to invalid\nmemory write:\n1. On 'luaReplyToRedisReply', one might return a nested reply that will\n   explode the LUA stack.\n2. On 'redisProtocolToLuaType', the Redis reply might be deep enough\n\u00a0 \u00a0to explode the LUA stack (notice that currently there is no such\n\u00a0 \u00a0command in Redis that returns such a nested reply, but modules might\n\u00a0 \u00a0do it)\n3. On 'ldbRedis', one might give a command with enough arguments to\n\u00a0 \u00a0explode the LUA stack (all the arguments will be pushed to the LUA\n\u00a0 \u00a0stack)\n\nThis commit is solving all those 3 issues by calling 'lua_checkstack' and\nverify that there is enough room in the LUA stack to push elements. In\ncase 'lua_checkstack' returns an error (there is not enough room in the\nLUA stack and it's not possible to increase the stack), we will do the\nfollowing:\n1. On 'luaReplyToRedisReply', we will return an error to the user.\n2. On 'redisProtocolToLuaType' we will exit with panic (we assume this\n   scenario is rare because it can only happen with a module).\n3. On 'ldbRedis', we return an error.",
        "before_after_code_files": [
          "src/scripting.c||src/scripting.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "src/scripting.c||src/scripting.c"
          ],
          "candidate": [
            "src/scripting.c||src/scripting.c"
          ]
        }
      },
      "candidate_diff": {
        "src/scripting.c||src/scripting.c": [
          "File: src/scripting.c -> src/scripting.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "131: char *redisProtocolToLuaType(lua_State *lua, char* reply) {",
          "132:     char *p = reply;",
          "134:     switch(*p) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "133:     if (!lua_checkstack(lua, 5)) {",
          "139:         serverPanic(\"lua stack limit reach when parsing redis.call reply\");",
          "140:     }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "221:             if (atype == '%') {",
          "222:                 p = redisProtocolToLuaType(lua,p);",
          "223:             } else {",
          "224:                 lua_pushboolean(lua,1);",
          "225:             }",
          "226:             lua_settable(lua,-3);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "234:                 if (!lua_checkstack(lua, 1)) {",
          "237:                     serverPanic(\"lua stack limit reach when parsing redis.call reply\");",
          "238:                 }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "342: void luaReplyToRedisReply(client *c, lua_State *lua) {",
          "343:     int t = lua_type(lua,-1);",
          "345:     switch(t) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "359:     if (!lua_checkstack(lua, 4)) {",
          "364:         addReplyErrorFormat(c, \"reached lua stack limit\");",
          "366:         return;",
          "367:     }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2561: void ldbRedis(lua_State *lua, sds *argv, int argc) {",
          "2562:     int j, saved_rc = server.lua_replicate_commands;",
          "2564:     lua_getglobal(lua,\"redis\");",
          "2565:     lua_pushstring(lua,\"call\");",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2594:     if (!lua_checkstack(lua, argc + 1)) {",
          "2601:         ldbLogRedisReply(\"max lua stack reached\");",
          "2602:         return;",
          "2603:     }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "0f8b634cd5cdfd77696d34d744dfc25fa97f3b73",
      "candidate_info": {
        "commit_hash": "0f8b634cd5cdfd77696d34d744dfc25fa97f3b73",
        "repo": "redis/redis",
        "commit_url": "https://github.com/redis/redis/commit/0f8b634cd5cdfd77696d34d744dfc25fa97f3b73",
        "files": [
          "src/scripting.c",
          "tests/unit/scripting.tcl"
        ],
        "message": "Fix invalid memory write on lua stack overflow (CVE-2021-32626) (#9591)\n\nWhen LUA call our C code, by default, the LUA stack has room for 10\nelements. In most cases, this is more than enough but sometimes it's not\nand the caller must verify the LUA stack size before he pushes elements.\n\nOn 3 places in the code, there was no verification of the LUA stack size.\nOn specific inputs this missing verification could have lead to invalid\nmemory write:\n1. On 'luaReplyToRedisReply', one might return a nested reply that will\n   explode the LUA stack.\n2. On 'redisProtocolToLuaType', the Redis reply might be deep enough\n   to explode the LUA stack (notice that currently there is no such\n   command in Redis that returns such a nested reply, but modules might\n   do it)\n3. On 'ldbRedis', one might give a command with enough arguments to\n   explode the LUA stack (all the arguments will be pushed to the LUA\n   stack)\n\nThis commit is solving all those 3 issues by calling 'lua_checkstack' and\nverify that there is enough room in the LUA stack to push elements. In\ncase 'lua_checkstack' returns an error (there is not enough room in the\nLUA stack and it's not possible to increase the stack), we will do the\nfollowing:\n1. On 'luaReplyToRedisReply', we will return an error to the user.\n2. On 'redisProtocolToLuaType' we will exit with panic (we assume this\n   scenario is rare because it can only happen with a module).\n3. On 'ldbRedis', we return an error.",
        "before_after_code_files": [
          "src/scripting.c||src/scripting.c",
          "tests/unit/scripting.tcl||tests/unit/scripting.tcl"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_olp_changes": 1,
        "olp_code_files": {
          "patch": [
            "src/scripting.c||src/scripting.c"
          ],
          "candidate": [
            "src/scripting.c||src/scripting.c"
          ]
        }
      },
      "candidate_diff": {
        "src/scripting.c||src/scripting.c": [
          "File: src/scripting.c -> src/scripting.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "169:     }",
          "171:     lua_State *lua = ctx;",
          "172:     lua_pushnumber(lua,(lua_Number)val);",
          "173: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "172:     if (!lua_checkstack(lua, 1)) {",
          "175:         serverPanic(\"lua stack limit reach when parsing redis.call reply\");",
          "176:     }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "180:     }",
          "182:     lua_State *lua = ctx;",
          "183:     lua_pushboolean(lua,0);",
          "184: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "188:     if (!lua_checkstack(lua, 1)) {",
          "191:         serverPanic(\"lua stack limit reach when parsing redis.call reply\");",
          "192:     }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "190:         return;",
          "191:     }",
          "192:     lua_State *lua = ctx;",
          "193:     lua_pushboolean(lua,0);",
          "194: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "203:     if (!lua_checkstack(lua, 1)) {",
          "206:         serverPanic(\"lua stack limit reach when parsing redis.call reply\");",
          "207:     }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "202:     }",
          "204:     lua_State *lua = ctx;",
          "205:     lua_pushlstring(lua,str,len);",
          "206: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "220:     if (!lua_checkstack(lua, 1)) {",
          "223:         serverPanic(\"lua stack limit reach when parsing redis.call reply\");",
          "224:     }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "213:     }",
          "215:     lua_State *lua = ctx;",
          "217:     lua_newtable(lua);",
          "218:     lua_pushstring(lua,\"ok\");",
          "219:     lua_pushlstring(lua,str,len);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "236:     if (!lua_checkstack(lua, 3)) {",
          "239:         serverPanic(\"lua stack limit reach when parsing redis.call reply\");",
          "240:     }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "228:     }",
          "230:     lua_State *lua = ctx;",
          "232:     lua_newtable(lua);",
          "233:     lua_pushstring(lua,\"err\");",
          "234:     lua_pushlstring(lua,str,len);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "255:     if (!lua_checkstack(lua, 3)) {",
          "258:         serverPanic(\"lua stack limit reach when parsing redis.call reply\");",
          "259:     }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "239:     UNUSED(proto);",
          "240:     lua_State *lua = ctx;",
          "241:     if (lua) {",
          "242:         lua_newtable(lua);",
          "243:         lua_pushstring(lua, \"map\");",
          "244:         lua_newtable(lua);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "270:         if (!lua_checkstack(lua, 3)) {",
          "273:             serverPanic(\"lua stack limit reach when parsing redis.call reply\");",
          "274:         }",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "257:     lua_State *lua = ctx;",
          "258:     if (lua) {",
          "259:         lua_newtable(lua);",
          "260:         lua_pushstring(lua, \"set\");",
          "261:         lua_newtable(lua);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "292:         if (!lua_checkstack(lua, 3)) {",
          "295:             serverPanic(\"lua stack limit reach when parsing redis.call reply\");",
          "296:         }",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "263:     for (size_t j = 0; j < len; j++) {",
          "264:         parseReply(parser,lua);",
          "265:         if (lua) {",
          "266:             lua_pushboolean(lua,1);",
          "267:             lua_settable(lua,-3);",
          "268:         }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "304:             if (!lua_checkstack(lua, 1)) {",
          "309:                 serverPanic(\"lua stack limit reach when parsing redis.call reply\");",
          "310:             }",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "274:     UNUSED(proto);",
          "276:     lua_State *lua = ctx;",
          "278:     for (size_t j = 0; j < len; j++) {",
          "279:         if (lua) lua_pushnumber(lua,j+1);",
          "280:         parseReply(parser,lua);",
          "",
          "[Removed Lines]",
          "277:     if (lua) lua_newtable(lua);",
          "",
          "[Added Lines]",
          "322:     if (lua){",
          "323:         if (!lua_checkstack(lua, 2)) {",
          "326:             serverPanic(\"lua stack limit reach when parsing redis.call reply\");",
          "327:         }",
          "328:         lua_newtable(lua);",
          "329:     }",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "306:     }",
          "308:     lua_State *lua = ctx;",
          "310:     lua_newtable(lua);",
          "311:     lua_pushstring(lua,\"verbatim_string\");",
          "312:     lua_newtable(lua);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "361:     if (!lua_checkstack(lua, 5)) {",
          "364:         serverPanic(\"lua stack limit reach when parsing redis.call reply\");",
          "365:     }",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "327:     }",
          "329:     lua_State *lua = ctx;",
          "331:     lua_newtable(lua);",
          "332:     lua_pushstring(lua,\"big_number\");",
          "333:     lua_pushlstring(lua,str,len);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "386:     if (!lua_checkstack(lua, 3)) {",
          "389:         serverPanic(\"lua stack limit reach when parsing redis.call reply\");",
          "390:     }",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "342:     }",
          "344:     lua_State *lua = ctx;",
          "345:     lua_pushnil(lua);",
          "346: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "405:     if (!lua_checkstack(lua, 1)) {",
          "408:         serverPanic(\"lua stack limit reach when parsing redis.call reply\");",
          "409:     }",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "353:     }",
          "355:     lua_State *lua = ctx;",
          "356:     lua_pushboolean(lua,val);",
          "357: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "421:     if (!lua_checkstack(lua, 1)) {",
          "424:         serverPanic(\"lua stack limit reach when parsing redis.call reply\");",
          "425:     }",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "364:     }",
          "366:     lua_State *lua = ctx;",
          "367:     lua_newtable(lua);",
          "368:     lua_pushstring(lua,\"double\");",
          "369:     lua_pushnumber(lua,d);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "437:     if (!lua_checkstack(lua, 3)) {",
          "440:         serverPanic(\"lua stack limit reach when parsing redis.call reply\");",
          "441:     }",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "449: void luaReplyToRedisReply(client *c, lua_State *lua) {",
          "450:     int t = lua_type(lua,-1);",
          "452:     switch(t) {",
          "453:     case LUA_TSTRING:",
          "454:         addReplyBulkCBuffer(c,(char*)lua_tostring(lua,-1),lua_strlen(lua,-1));",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "527:     if (!lua_checkstack(lua, 4)) {",
          "532:         addReplyErrorFormat(c, \"reached lua stack limit\");",
          "534:         return;",
          "535:     }",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "2723: void ldbRedis(lua_State *lua, sds *argv, int argc) {",
          "2724:     int j, saved_rc = server.lua_replicate_commands;",
          "2726:     lua_getglobal(lua,\"redis\");",
          "2727:     lua_pushstring(lua,\"call\");",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2815:     if (!lua_checkstack(lua, argc + 1)) {",
          "2822:         ldbLogRedisReply(\"max lua stack reached\");",
          "2823:         return;",
          "2824:     }",
          "",
          "---------------"
        ],
        "tests/unit/scripting.tcl||tests/unit/scripting.tcl": [
          "File: tests/unit/scripting.tcl -> tests/unit/scripting.tcl",
          "--- Hunk 1 ---",
          "[Context before]",
          "606:         set res [r eval {redis.setresp(2); return redis.call('hgetall', KEYS[1])} 1 hash]",
          "607:         assert_equal $res $expected_list",
          "608:     }",
          "609: }",
          "611: # Start a new server since the last test in this stanza will kill the",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "610:     test {Script return recursive object} {",
          "611:         r readraw 1",
          "612:         set res [r eval {local a = {}; local b = {a}; a[1] = b; return a} 0]",
          "613:         # drain the response",
          "614:         while {true} {",
          "615:             if {$res == \"-ERR reached lua stack limit\"} {",
          "616:                 break",
          "617:             }",
          "618:             assert_equal $res \"*1\"",
          "619:             set res [r read]",
          "620:         }",
          "621:         r readraw 0",
          "622:         # make sure the connection is still valid",
          "623:         assert_equal [r ping] {PONG}",
          "624:     }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "948:         catch {r '\\0hello\\0'} e",
          "949:         assert_match {*Unknown Redis Lua debugger command*} $e",
          "950:     }",
          "951: }",
          "953: start_server {tags {\"scripting resp3 needs:debug\"}} {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "968:     test {Test scripting debug lua stack overflow} {",
          "969:         r script debug sync",
          "970:         r eval {return 'hello'} 0",
          "971:         set cmd \"*101\\r\\n\\$5\\r\\nredis\\r\\n\"",
          "972:         append cmd [string repeat \"\\$4\\r\\ntest\\r\\n\" 100]",
          "973:         r write $cmd",
          "974:         r flush",
          "975:         set ret [r read]",
          "976:         assert_match {*Unknown Redis command called from Lua script*} $ret",
          "977:         # make sure the server is still ok",
          "978:         reconnect",
          "979:         assert_equal [r ping] {PONG}",
          "980:     }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
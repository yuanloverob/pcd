{
  "cve_id": "CVE-2016-7515",
  "cve_desc": "The ReadRLEImage function in coders/rle.c in ImageMagick allows remote attackers to cause a denial of service (out-of-bounds read) via vectors related to the number of pixels.",
  "repo": "ImageMagick/ImageMagick",
  "patch_hash": "2ad6d33493750a28a5a655d319a8e0b16c392de1",
  "patch_info": {
    "commit_hash": "2ad6d33493750a28a5a655d319a8e0b16c392de1",
    "repo": "ImageMagick/ImageMagick",
    "commit_url": "https://github.com/ImageMagick/ImageMagick/commit/2ad6d33493750a28a5a655d319a8e0b16c392de1",
    "files": [
      "coders/rle.c"
    ],
    "message": "Fixed check for the number of pixels that will be allocated.",
    "before_after_code_files": [
      "coders/rle.c||coders/rle.c"
    ]
  },
  "patch_diff": {
    "coders/rle.c||coders/rle.c": [
      "File: coders/rle.c -> coders/rle.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "174:   size_t",
      "175:     bits_per_pixel,",
      "176:     map_length,",
      "177:     number_colormaps,",
      "178:     number_planes,",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "176:     map_length,",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "309:       Allocate RLE pixels.",
      "312:       number_planes++;",
      "314:     if ((number_pixels*number_planes) != (size_t) (number_pixels*number_planes))",
      "315:       ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");",
      "316:     pixel_info_length=image->columns*image->rows*MagickMax(number_planes,4);",
      "",
      "[Removed Lines]",
      "311:     if (image->alpha_trait != UndefinedPixelTrait)",
      "313:     number_pixels=(MagickSizeType) image->columns*image->rows;",
      "",
      "[Added Lines]",
      "312:     if (image->alpha_trait != UndefinedPixelTrait)",
      "313:       number_planes++;",
      "314:     number_pixels=(MagickSizeType) image->columns*image->rows;",
      "315:     number_planes_filled=(number_planes % 2 == 0) ? number_planes :",
      "317:     if ((number_pixels*number_planes_filled) != (size_t) (number_pixels*",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "13db820f5e24cd993ee554e99377fea02a904e18",
      "candidate_info": {
        "commit_hash": "13db820f5e24cd993ee554e99377fea02a904e18",
        "repo": "ImageMagick/ImageMagick",
        "commit_url": "https://github.com/ImageMagick/ImageMagick/commit/13db820f5e24cd993ee554e99377fea02a904e18",
        "files": [
          "coders/rle.c"
        ],
        "message": "https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=29710",
        "before_after_code_files": [
          "coders/rle.c||coders/rle.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "coders/rle.c||coders/rle.c"
          ],
          "candidate": [
            "coders/rle.c||coders/rle.c"
          ]
        }
      },
      "candidate_diff": {
        "coders/rle.c||coders/rle.c": [
          "File: coders/rle.c -> coders/rle.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "316:     number_planes_filled=(number_planes % 2 == 0) ? number_planes :",
          "317:       number_planes+1;",
          "318:     if ((number_pixels*number_planes_filled) != (size_t) (number_pixels*",
          "320:       ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");",
          "321:     pixel_info=AcquireVirtualMemory(image->columns,image->rows*",
          "323:     if (pixel_info == (MemoryInfo *) NULL)",
          "324:       ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");",
          "325:     pixel_info_length=image->columns*image->rows*number_planes_filled;",
          "",
          "[Removed Lines]",
          "319:          number_planes_filled))",
          "322:       number_planes_filled*sizeof(*pixels));",
          "",
          "[Added Lines]",
          "319:          number_planes_filled))",
          "322:       MagickMax(number_planes_filled,4)*sizeof(*pixels));",
          "323:     if (pixel_info == (MemoryInfo *) NULL)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "2174484dfa68a594e2f9ad17f46217b6120db18d",
      "candidate_info": {
        "commit_hash": "2174484dfa68a594e2f9ad17f46217b6120db18d",
        "repo": "ImageMagick/ImageMagick",
        "commit_url": "https://github.com/ImageMagick/ImageMagick/commit/2174484dfa68a594e2f9ad17f46217b6120db18d",
        "files": [
          "MagickCore/memory.c",
          "coders/pict.c",
          "coders/rle.c",
          "coders/sun.c",
          "coders/viff.c"
        ],
        "message": "https://github.com/ImageMagick/ImageMagick/issues/82 https://github.com/ImageMagick/ImageMagick/issues/81 https://github.com/ImageMagick/ImageMagick/issues/80 https://github.com/ImageMagick/ImageMagick/issues/77",
        "before_after_code_files": [
          "MagickCore/memory.c||MagickCore/memory.c",
          "coders/pict.c||coders/pict.c",
          "coders/rle.c||coders/rle.c",
          "coders/sun.c||coders/sun.c",
          "coders/viff.c||coders/viff.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "coders/rle.c||coders/rle.c"
          ],
          "candidate": [
            "coders/rle.c||coders/rle.c"
          ]
        }
      },
      "candidate_diff": {
        "MagickCore/memory.c||MagickCore/memory.c": [
          "File: MagickCore/memory.c -> MagickCore/memory.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "233: %      void *AcquireAlignedMemory(const size_t count,const size_t quantum)",
          "234: %",
          "235: %  A description of each parameter follows:",
          "236: %",
          "237: %    o count: the number of quantum elements to allocate.",
          "238: %",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "236: %",
          "237: %    o count: the number of quantum elements to allocate.",
          "238: %",
          "239: %    o quantum: the number of bytes in each quantum.",
          "240: %",
          "242: static MagickBooleanType CheckMemoryOverflow(const size_t count,",
          "243:   const size_t quantum)",
          "244: {",
          "245:   size_t",
          "246:     size;",
          "248:   size=count*quantum;",
          "249:   if ((count == 0) || (quantum != (size/count)))",
          "250:     {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "247:   size_t",
          "248:     alignment,",
          "255:   size=count*quantum;",
          "256:   if ((count == 0) || (quantum != (size/count)))",
          "257:     {",
          "258:       errno=ENOMEM;",
          "259:       return((void *) NULL);",
          "",
          "[Removed Lines]",
          "249:     extent,",
          "250:     size;",
          "252:   void",
          "",
          "[Added Lines]",
          "264:     extent,",
          "265:     size;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "528: %      void *AcquireQuantumMemory(const size_t count,const size_t quantum)",
          "529: %",
          "530: %  A description of each parameter follows:",
          "532: %    o count: the number of quantum elements to allocate.",
          "540:     size;",
          "542:   size=count*quantum;",
          "543:   if ((count == 0) || (quantum != (size/count)))",
          "",
          "[Removed Lines]",
          "531: %",
          "533: %",
          "534: %    o quantum: the number of bytes in each quantum.",
          "535: %",
          "537: MagickExport void *AcquireQuantumMemory(const size_t count,const size_t quantum)",
          "538: {",
          "539:   size_t",
          "",
          "[Added Lines]",
          "543: %",
          "545: %",
          "546: %    o quantum: the number of bytes in each quantum.",
          "547: %",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "571: %",
          "572: %    o count: the number of quantum elements to allocate.",
          "573: %",
          "575: %",
          "583:   size_t",
          "584:     length;",
          "586:   length=count*quantum;",
          "588:     {",
          "590:       return((MemoryInfo *) NULL);",
          "592:   memory_info=(MemoryInfo *) MagickAssumeAligned(AcquireAlignedMemory(1,",
          "593:     sizeof(*memory_info)));",
          "594:   if (memory_info == (MemoryInfo *) NULL)",
          "595:     ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");",
          "596:   (void) ResetMagickMemory(memory_info,0,sizeof(*memory_info));",
          "597:   memory_info->length=length;",
          "600:     {",
          "601:       memory_info->blob=AcquireAlignedMemory(1,length);",
          "602:       if (memory_info->blob != NULL)",
          "603:         {",
          "605:           return(memory_info);",
          "606:         }",
          "607:     }",
          "608:   RelinquishMagickResource(MemoryResource,length);",
          "609:   if (AcquireMagickResource(MapResource,length) != MagickFalse)",
          "612:         Heap memory failed, try anonymous memory mapping.",
          "",
          "[Removed Lines]",
          "574: %    o quantum: the number of bytes in each quantum.",
          "577: MagickExport MemoryInfo *AcquireVirtualMemory(const size_t count,",
          "578:   const size_t quantum)",
          "579: {",
          "580:   MemoryInfo",
          "587:   if ((count == 0) || (quantum != (length/count)))",
          "589:       errno=ENOMEM;",
          "591:     }",
          "598:   memory_info->signature=MagickCoreSignature;",
          "599:   if (AcquireMagickResource(MemoryResource,length) != MagickFalse)",
          "604:           memory_info->type=AlignedVirtualMemory;",
          "610:     {",
          "",
          "[Added Lines]",
          "583: %    o quantum: the number of bytes in each quantum.",
          "586: MagickExport MemoryInfo *AcquireVirtualMemory(const size_t count,",
          "592:   size_t",
          "593:     extent;",
          "595:   if (CheckMemoryOverflow(count,quantum) != MagickFalse)",
          "597:   memory_info=(MemoryInfo *) MagickAssumeAligned(AcquireAlignedMemory(1,",
          "604:   memory_info->signature=MagickCoreSignature;",
          "605:   if (AcquireMagickResource(MemoryResource,extent) != MagickFalse)",
          "610:           memory_info->type=AlignedVirtualMemory;",
          "616:     {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "620:       if (AcquireMagickResource(DiskResource,length) != MagickFalse)",
          "621:         {",
          "622:           int",
          "627:             If the MapResource request failed, there is no point in trying",
          "628:             file-backed memory mapping.",
          "",
          "[Removed Lines]",
          "623:             file;",
          "626:             Anonymous memory mapping failed, try file-backed memory mapping.",
          "",
          "[Added Lines]",
          "629:             file;",
          "632:             Anonymous memory mapping failed, try file-backed memory mapping.",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "639:                       (void) close(file);",
          "640:                       memory_info->type=MapVirtualMemory;",
          "641:                       return(memory_info);",
          "643:                 }",
          "645:                 File-backed memory mapping failed, delete the temporary file.",
          "648:               (void) RelinquishUniqueFileResource(memory_info->filename);",
          "650:             }",
          "",
          "[Removed Lines]",
          "642:                     }",
          "647:               (void) close(file);",
          "",
          "[Added Lines]",
          "648:                     }",
          "653:               (void) close(file);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1208: %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%",
          "1209: %",
          "1210: %  ResizeQuantumMemory() changes the size of the memory and returns a pointer",
          "1212: %  lesser of the new and old sizes.",
          "1215: %",
          "1216: %      void *ResizeQuantumMemory(void *memory,const size_t count,",
          "1218: %",
          "1219: %  A description of each parameter follows:",
          "1221: %    o memory: A pointer to a memory allocation.",
          "1222: %",
          "1223: %    o count: the number of quantum elements to allocate.",
          "1224: %",
          "",
          "[Removed Lines]",
          "1211: %  to the (possibly moved) block.  The contents will be unchanged up to the",
          "1213: %",
          "1214: %  The format of the ResizeQuantumMemory method is:",
          "1217: %        const size_t quantum)",
          "1220: %",
          "",
          "[Added Lines]",
          "1217: %  to the (possibly moved) block.  The contents will be unchanged up to the",
          "1219: %",
          "1224: %",
          "1225: %  A description of each parameter follows:",
          "",
          "---------------"
        ],
        "coders/pict.c||coders/pict.c": [
          "File: coders/pict.c -> coders/pict.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2003:               green=scanline+2*image->columns;",
          "2004:               blue=scanline+3*image->columns;",
          "2005:             }",
          "",
          "[Removed Lines]",
          "2006:           for (x=0; x < (ssize_t) image->columns; x++)",
          "2007:           {",
          "",
          "[Added Lines]",
          "2006:           for (x=0; x < (ssize_t) image->columns; x++)",
          "",
          "---------------"
        ],
        "coders/rle.c||coders/rle.c": [
          "File: coders/rle.c -> coders/rle.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "314:     number_pixels=(MagickSizeType) image->columns*image->rows;",
          "315:     number_planes_filled=(number_planes % 2 == 0) ? number_planes :",
          "316:       number_planes+1;",
          "319:       ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");",
          "320:     pixel_info_length=image->columns*image->rows*number_planes_filled;",
          "321:     pixel_info=AcquireVirtualMemory(pixel_info_length,sizeof(*pixels));",
          "322:     if (pixel_info == (MemoryInfo *) NULL)",
          "323:       ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");",
          "",
          "[Removed Lines]",
          "317:     if ((number_pixels*number_planes_filled) != (size_t) (number_pixels*",
          "318:          number_planes_filled))",
          "",
          "[Added Lines]",
          "317:     if ((number_pixels*number_planes_filled) != (size_t) (number_pixels*",
          "318:          number_planes_filled))",
          "319:       ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");",
          "320:     if (image->rows < (image->rows*number_planes_filled*sizeof(*pixels)))",
          "323:       number_planes_filled*sizeof(*pixels));",
          "",
          "---------------"
        ],
        "coders/sun.c||coders/sun.c": [
          "File: coders/sun.c -> coders/sun.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "431:         ((bytes_per_line/sun_info.depth) != sun_info.width))",
          "432:       ThrowReaderException(ResourceLimitError,\"ImproperImageHeader\");",
          "433:     bytes_per_line+=15;",
          "435:     if ((bytes_per_line >> 1) != (sun_info.width*sun_info.depth+15))",
          "436:       ThrowReaderException(ResourceLimitError,\"ImproperImageHeader\");",
          "437:     bytes_per_line>>=4;",
          "438:     sun_pixels=(unsigned char *) AcquireQuantumMemory(height,",
          "439:       bytes_per_line*sizeof(*sun_pixels));",
          "",
          "[Removed Lines]",
          "434:     bytes_per_line<<=1;",
          "",
          "[Added Lines]",
          "434:     bytes_per_line<<=1;",
          "437:     bytes_per_line>>=4;",
          "438:     sun_pixels=(unsigned char *) AcquireQuantumMemory(height,",
          "",
          "---------------"
        ],
        "coders/viff.c||coders/viff.c": [
          "File: coders/viff.c -> coders/viff.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "407:           case VFF_MAPTYP_FLOAT: bytes_per_pixel=4; break;",
          "408:           case VFF_MAPTYP_DOUBLE: bytes_per_pixel=8; break;",
          "409:           default: bytes_per_pixel=1; break;",
          "410:         }",
          "411:         image->colors=viff_info.map_columns;",
          "412:         if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "410:         }",
          "411:         image->colors=viff_info.map_columns;",
          "412:         if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)",
          "",
          "---------------"
        ]
      }
    }
  ]
}
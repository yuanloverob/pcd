{
  "cve_id": "CVE-2019-15147",
  "cve_desc": "GoPro GPMF-parser 1.2.2 has an out-of-bounds read and SEGV in GPMF_Next in GPMF_parser.c.",
  "repo": "gopro/gpmf-parser",
  "patch_hash": "341f12cd5b97ab419e53853ca00176457c9f1681",
  "patch_info": {
    "commit_hash": "341f12cd5b97ab419e53853ca00176457c9f1681",
    "repo": "gopro/gpmf-parser",
    "commit_url": "https://github.com/gopro/gpmf-parser/commit/341f12cd5b97ab419e53853ca00176457c9f1681",
    "files": [
      "GPMF_parser.c",
      "GPMF_parser.h",
      "demo/GPMF_demo.c",
      "demo/GPMF_mp4reader.c",
      "demo/GPMF_mp4reader.h"
    ],
    "message": "fixed many security issues with the too crude mp4 reader",
    "before_after_code_files": [
      "GPMF_parser.c||GPMF_parser.c",
      "GPMF_parser.h||GPMF_parser.h",
      "demo/GPMF_demo.c||demo/GPMF_demo.c",
      "demo/GPMF_mp4reader.c||demo/GPMF_mp4reader.c",
      "demo/GPMF_mp4reader.h||demo/GPMF_mp4reader.h"
    ]
  },
  "patch_diff": {
    "GPMF_parser.c||GPMF_parser.c": [
      "File: GPMF_parser.c -> GPMF_parser.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "42: {",
      "43:  if (ms)",
      "44:  {",
      "46:   if (nestsize == 0 && ms->nest_level == 0)",
      "47:    nestsize = ms->buffer_size_longs;",
      "",
      "[Removed Lines]",
      "45:   int32_t nestsize = (int32_t)ms->nest_size[ms->nest_level];",
      "",
      "[Added Lines]",
      "45:   uint32_t nestsize = (uint32_t)ms->nest_size[ms->nest_level];",
      "",
      "---------------"
    ],
    "GPMF_parser.h||GPMF_parser.h": [
      "File: GPMF_parser.h -> GPMF_parser.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "126:  GPMF_KEY_UNITS =   MAKEID('U','N','I','T'),//UNIT - Freedform display string for metadata units (char sting like \"RPM\", \"MPH\", \"km/h\", etc)",
      "127:  GPMF_KEY_SCALE =   MAKEID('S','C','A','L'),//SCAL - divisor for input data to scale to the correct units.",
      "128:  GPMF_KEY_TYPE =    MAKEID('T','Y','P','E'),//TYPE - Type define for complex data structures",
      "130:  GPMF_KEY_TICK =    MAKEID('T','I','C','K'),//TICK - Used for slow data. Beginning of data timing in milliseconds.",
      "131:  GPMF_KEY_TOCK =    MAKEID('T','O','C','K'),//TOCK - Used for slow data. End of data timing in milliseconds.",
      "132:  GPMF_KEY_EMPTY_PAYLOADS = MAKEID('E','M','P','T'),//EMPT - Payloads that are empty since the device start (e.g. BLE disconnect.)",
      "",
      "[Removed Lines]",
      "129:  GPMF_KEY_TOTAL_SAMPLES = MAKEID('T','S','M','P'),//TOTL - Total Sample Count including the current payload",
      "",
      "[Added Lines]",
      "129:  GPMF_KEY_TOTAL_SAMPLES = MAKEID('T','S','M','P'),//TSMP - Total Sample Count including the current payload",
      "130:  GPMF_KEY_TIME_OFFSET =  MAKEID('T','I','M','O'),//TIMO - Time offset of the metadata stream that follows (single 4 byte float)",
      "131:  GPMF_KEY_TIMING_OFFSET = MAKEID('T','I','M','O'),//TIMO - duplicated, as older code might use the other version of TIMO",
      "132:  GPMF_KEY_TIME_STAMP =  MAKEID('S','T','M','P'),//STMP - Time stamp for the first sample.",
      "133:  GPMF_KEY_TIME_STAMPS =  MAKEID('S','T','P','S'),//STPS - Stream of all the timestamps delivered (Generally don't use this. This would be if your sensor has no peroidic times, yet precision is required, or for debugging.)",
      "",
      "---------------"
    ],
    "demo/GPMF_demo.c||demo/GPMF_demo.c": [
      "File: demo/GPMF_demo.c -> demo/GPMF_demo.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "46:  }",
      "48:  size_t mp4 = OpenMP4Source(argv[1], MOV_GPMF_TRAK_TYPE, MOV_GPMF_TRAK_SUBTYPE);",
      "51:  metadatalength = GetDuration(mp4);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "49:  if (mp4 == 0)",
      "50:  {",
      "51:   printf(\"error: %s is an invalid MP4/MOV\\n\", argv[1]);",
      "52:   return -1;",
      "53:  }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "90:   for (index = 0; index < payloads; index++)",
      "91:   {",
      "92:    uint32_t payloadsize = GetPayloadSize(mp4, index);",
      "94:    payload = GetPayload(mp4, payload, index);",
      "95:    if (payload == NULL)",
      "96:     goto cleanup;",
      "",
      "[Removed Lines]",
      "93:    float in = 0.0, out = 0.0; //times",
      "",
      "[Added Lines]",
      "99:    double in = 0.0, out = 0.0; //times",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "238:   {",
      "239:    if (GPMF_OK == GPMF_SeekToSamples(ms)) //find the last FOURCC within the stream",
      "240:    {",
      "241:     uint32_t fourcc = GPMF_Key(ms);",
      "244:    }",
      "245:   }",
      "246: #endif",
      "",
      "[Removed Lines]",
      "242:     double rate = GetGPMFSampleRate(mp4, fourcc, GPMF_SAMPLE_RATE_PRECISE);// GPMF_SAMPLE_RATE_FAST);",
      "243:     printf(\"%c%c%c%c sampling rate = %f Hz\\n\", PRINTF_4CC(fourcc), rate);",
      "",
      "[Added Lines]",
      "247:     double in = 0.0, out = 0.0;",
      "249:     double rate = GetGPMFSampleRate(mp4, fourcc, GPMF_SAMPLE_RATE_PRECISE, &in, &out);// GPMF_SAMPLE_RATE_FAST);",
      "250:     printf(\"%c%c%c%c sampling rate = %f Hz (from %f to %f)\\n\", PRINTF_4CC(fourcc), rate, in, out);",
      "",
      "---------------"
    ],
    "demo/GPMF_mp4reader.c||demo/GPMF_mp4reader.c": [
      "File: demo/GPMF_mp4reader.c -> demo/GPMF_mp4reader.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "26: #include <stdlib.h>",
      "27: #include <stdio.h>",
      "28: #include <string.h>",
      "29: #include <stdint.h>",
      "30: #include \"GPMF_mp4reader.h\"",
      "32: #define PRINT_MP4_STRUCTURE  0",
      "34: #ifdef WIN32",
      "36: #else",
      "38: #endif",
      "",
      "[Removed Lines]",
      "35: #define LONGSEEK  _fseeki64",
      "37: #define LONGSEEK  fseeko",
      "",
      "[Added Lines]",
      "28: #include <sys/types.h>",
      "29: #include <sys/stat.h>",
      "36: #define LONGSEEK _fseeki64",
      "37: #define stat64  _stat64",
      "39: #define LONGSEEK fseeko",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "64:   if (MP4buffer)",
      "65:   {",
      "69:   }",
      "70:  }",
      "71:  return NULL;",
      "72: }",
      "76: {",
      "82:  {",
      "85:  }",
      "87: }",
      "91: void FreePayload(uint32_t *lastpayload)",
      "92: {",
      "93:  if (lastpayload)",
      "",
      "[Removed Lines]",
      "66:    LONGSEEK(mp4->mediafp, mp4->metaoffsets[index], SEEK_SET);",
      "67:    fread(MP4buffer, 1, mp4->metasizes[index], mp4->mediafp);",
      "68:    return MP4buffer;",
      "75: void SavePayload(size_t handle, uint32_t *payload, uint32_t index)",
      "77:  mp4object *mp4 = (mp4object *)handle;",
      "78:  if (mp4 == NULL) return;",
      "80:  uint32_t *MP4buffer = NULL;",
      "81:  if (index < mp4->indexcount && mp4->mediafp && payload)",
      "83:   LONGSEEK(mp4->mediafp, mp4->metaoffsets[index], SEEK_SET);",
      "84:   fwrite(payload, 1, mp4->metasizes[index], mp4->mediafp);",
      "86:  return;",
      "",
      "[Added Lines]",
      "67:    if (mp4->filesize > mp4->metaoffsets[index]+mp4->metasizes[index])",
      "68:    {",
      "69:     LONGSEEK(mp4->mediafp, mp4->metaoffsets[index], SEEK_SET);",
      "70:     fread(MP4buffer, 1, mp4->metasizes[index], mp4->mediafp);",
      "71:     mp4->filepos = mp4->metaoffsets[index] + mp4->metasizes[index];",
      "72:     return MP4buffer;",
      "73:    }",
      "80: void LongSeek(mp4object *mp4, int64_t offset)",
      "82:  if (mp4 && offset)",
      "84:   if (mp4->filepos + offset < mp4->filesize)",
      "85:   {",
      "86:    LONGSEEK(mp4->mediafp, offset, SEEK_CUR);",
      "87:    mp4->filepos += offset;",
      "88:   }",
      "89:   else",
      "90:   {",
      "91:    mp4->filepos = mp4->filesize;",
      "92:   }",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "116:  memset(mp4, 0, sizeof(mp4object));",
      "118: #ifdef _WINDOWS",
      "119:  fopen_s(&mp4->mediafp, filename, \"rb\");",
      "120: #else",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "124:  struct stat64 mp4stat;",
      "125:  stat64(filename, &mp4stat);",
      "126:  mp4->filesize = mp4stat.st_size;",
      "128:  if (mp4->filesize < 64) return 0;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "129:   uint64_t nestsize[MAX_NEST_LEVEL] = { 0 };",
      "130:   uint64_t lastsize = 0, qtsize;",
      "132:   do",
      "133:   {",
      "134:    len = fread(&qtsize32, 1, 4, mp4->mediafp);",
      "135:    len += fread(&qttag, 1, 4, mp4->mediafp);",
      "137:    {",
      "138:     if (!VALID_FOURCC(qttag))",
      "139:     {",
      "144:     }",
      "146:     qtsize32 = BYTESWAP32(qtsize32);",
      "148:     if (qtsize32 == 1) // 64-bit Atom",
      "149:     {",
      "151:      qtsize = BYTESWAP64(qtsize) - 8;",
      "152:     }",
      "153:     else",
      "",
      "[Removed Lines]",
      "136:    if (len == 8)",
      "140:      LONGSEEK(mp4->mediafp, lastsize - 8 - 8, SEEK_CUR);",
      "142:      NESTSIZE(lastsize - 8);",
      "143:      continue;",
      "150:      fread(&qtsize, 1, 8, mp4->mediafp);",
      "",
      "[Added Lines]",
      "149:    mp4->filepos += len;",
      "150:    if (len == 8 && mp4->filepos < mp4->filesize)",
      "154:      CloseSource((size_t)mp4);",
      "155:      mp4 = NULL;",
      "156:      break;",
      "163:      len = fread(&qtsize, 1, 8, mp4->mediafp);",
      "164:      mp4->filepos += len;",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "169:     if (qttag == MAKEID('m', 'd', 'a', 't') ||",
      "170:      qttag == MAKEID('f', 't', 'y', 'p') ||",
      "172:     {",
      "175:      NESTSIZE(qtsize);",
      "",
      "[Removed Lines]",
      "171:      qttag == MAKEID('u', 'd', 't', 'a'))",
      "173:      LONGSEEK(mediafp, qtsize - 8, SEEK_CUR);",
      "",
      "[Added Lines]",
      "185:      qttag == MAKEID('u', 'd', 't', 'a') ||",
      "186:      qttag == MAKEID('f', 'r', 'e', 'e'))",
      "188:      LongSeek(mp4, qtsize - 8);",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "187:      qttag != MAKEID('d', 'i', 'n', 'f') &&",
      "188:      qttag != MAKEID('a', 'l', 'i', 's') &&",
      "189:      qttag != MAKEID('s', 't', 's', 'd') &&",
      "192:      qttag != MAKEID('s', 't', 'b', 'l') &&",
      "193:      qttag != MAKEID('s', 't', 't', 's') &&",
      "194:      qttag != MAKEID('s', 't', 's', 'c') &&",
      "",
      "[Removed Lines]",
      "190:      qttag != MAKEID('a', 'l', 'i', 's') &&",
      "191:      qttag != MAKEID('a', 'l', 'i', 's') &&",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "197:      qttag != MAKEID('c', 'o', '6', '4') &&",
      "198:      qttag != MAKEID('h', 'd', 'l', 'r'))",
      "199:     {",
      "202:      NESTSIZE(qtsize);",
      "203:     }",
      "",
      "[Removed Lines]",
      "200:      LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);",
      "",
      "[Added Lines]",
      "213:      LongSeek(mp4, qtsize - 8);",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "210:       len += fread(&skip, 1, 4, mp4->mediafp);",
      "211:       len += fread(&mp4->clockdemon, 1, 4, mp4->mediafp); mp4->clockdemon = BYTESWAP32(mp4->clockdemon);",
      "212:       len += fread(&mp4->clockcount, 1, 4, mp4->mediafp); mp4->clockcount = BYTESWAP32(mp4->clockcount);",
      "215:       NESTSIZE(qtsize);",
      "216:      }",
      "",
      "[Removed Lines]",
      "213:       LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over mvhd",
      "",
      "[Added Lines]",
      "227:       mp4->filepos += len;",
      "228:       LongSeek(mp4, qtsize - 8 - len); // skip over mvhd",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "233:         mp4->videolength = (float)((double)mp4->trak_clockcount / (double)mp4->trak_clockdemon);",
      "234:        }",
      "235:       }",
      "238:       NESTSIZE(qtsize);",
      "239:      }",
      "",
      "[Removed Lines]",
      "236:       LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over mvhd",
      "",
      "[Added Lines]",
      "252:       mp4->filepos += len;",
      "253:       LongSeek(mp4, qtsize - 8 - len); // skip over mvhd",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "244:       len += fread(&skip, 1, 4, mp4->mediafp);",
      "245:       len += fread(&temp, 1, 4, mp4->mediafp);  // type will be 'meta' for the correct trak.",
      "248:        type = temp;",
      "252:       NESTSIZE(qtsize);",
      "",
      "[Removed Lines]",
      "247:       if (temp != MAKEID('a', 'l', 'i', 's'))",
      "250:       LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over hldr",
      "",
      "[Added Lines]",
      "264:       if (temp != MAKEID('a', 'l', 'i', 's') && temp != MAKEID('u', 'r', 'l', ' '))",
      "267:       mp4->filepos += len;",
      "268:       LongSeek(mp4, qtsize - 8 - len); // skip over hldr",
      "",
      "---------------",
      "--- Hunk 11 ---",
      "[Context before]",
      "267:          type = 0; // MP4",
      "268:         }",
      "269:        }",
      "271:       }",
      "272:       else",
      "275:       NESTSIZE(qtsize);",
      "276:      }",
      "",
      "[Removed Lines]",
      "270:        LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over stsd",
      "273:        LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);",
      "",
      "[Added Lines]",
      "288:        mp4->filepos += len;",
      "289:        LongSeek(mp4, qtsize - 8 - len); // skip over stsd",
      "292:        LongSeek(mp4, qtsize - 8);",
      "",
      "---------------",
      "--- Hunk 12 ---",
      "[Context before]",
      "286:        {",
      "287:         mp4->metastsc_count = num;",
      "288:         if (mp4->metastsc) free(mp4->metastsc);",
      "291:         {",
      "296:          {",
      "305:         {",
      "309:         }",
      "310:        }",
      "312:       }",
      "313:       else",
      "316:       NESTSIZE(qtsize);",
      "317:      }",
      "",
      "[Removed Lines]",
      "289:         mp4->metastsc = (SampleToChunk *)malloc(num * 12);",
      "290:         if (mp4->metastsc)",
      "292:          uint32_t total_stsc = num;",
      "293:          len += fread(mp4->metastsc, 1, num * sizeof(SampleToChunk), mp4->mediafp);",
      "295:          do",
      "297:           num--;",
      "298:           mp4->metastsc[num].chunk_num = BYTESWAP32(mp4->metastsc[num].chunk_num);",
      "299:           mp4->metastsc[num].samples = BYTESWAP32(mp4->metastsc[num].samples);",
      "300:           mp4->metastsc[num].id = BYTESWAP32(mp4->metastsc[num].id);",
      "301:          } while (num > 0);",
      "302:         }",
      "304:         if (mp4->metastsc_count == 1 && mp4->metastsc[0].samples == 1) // Simplify if the stsc is not reporting any grouped chunks.",
      "306:          if (mp4->metastsc) free(mp4->metastsc);",
      "307:          mp4->metastsc = NULL;",
      "308:          mp4->metastsc_count = 0;",
      "311:        LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over stsx",
      "314:        LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);",
      "",
      "[Added Lines]",
      "308:         if (num > 0)",
      "310:          mp4->metastsc = (SampleToChunk *)malloc(num * sizeof(SampleToChunk));",
      "311:          if (mp4->metastsc)",
      "313:           len += fread(mp4->metastsc, 1, num * sizeof(SampleToChunk), mp4->mediafp);",
      "315:           do",
      "316:           {",
      "317:            num--;",
      "318:            mp4->metastsc[num].chunk_num = BYTESWAP32(mp4->metastsc[num].chunk_num);",
      "319:            mp4->metastsc[num].samples = BYTESWAP32(mp4->metastsc[num].samples);",
      "320:            mp4->metastsc[num].id = BYTESWAP32(mp4->metastsc[num].id);",
      "321:           } while (num > 0);",
      "322:          }",
      "323:         }",
      "324:         else",
      "327:          CloseSource((size_t)mp4);",
      "328:          mp4 = NULL;",
      "329:          break;",
      "332:        mp4->filepos += len;",
      "333:        LongSeek(mp4, qtsize - 8 - len); // skip over stsx",
      "336:        LongSeek(mp4, qtsize - 8);",
      "",
      "---------------",
      "--- Hunk 13 ---",
      "[Context before]",
      "330:        {",
      "331:         mp4->metasize_count = num;",
      "332:         if (mp4->metasizes) free(mp4->metasizes);",
      "335:         {",
      "337:          {",
      "340:           {",
      "349:           {",
      "353:          }",
      "354:         }",
      "355:        }",
      "357:       }",
      "358:       else",
      "361:       NESTSIZE(qtsize);",
      "362:      }",
      "",
      "[Removed Lines]",
      "333:         mp4->metasizes = (uint32_t *)malloc(num * 4);",
      "334:         if (mp4->metasizes)",
      "336:          if (equalsamplesize == 0)",
      "338:           len += fread(mp4->metasizes, 1, num * 4, mp4->mediafp);",
      "339:           do",
      "341:            num--;",
      "342:            mp4->metasizes[num] = BYTESWAP32(mp4->metasizes[num]);",
      "343:           } while (num > 0);",
      "344:          }",
      "345:          else",
      "346:          {",
      "347:           equalsamplesize = BYTESWAP32(equalsamplesize);",
      "348:           do",
      "350:            num--;",
      "351:            mp4->metasizes[num] = equalsamplesize;",
      "352:           } while (num > 0);",
      "356:        LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over stsz",
      "359:        LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);",
      "",
      "[Added Lines]",
      "355:         if(num > 0)",
      "357:          mp4->metasizes = (uint32_t *)malloc(num * 4);",
      "358:          if (mp4->metasizes)",
      "360:           if (equalsamplesize == 0)",
      "362:            len += fread(mp4->metasizes, 1, num * 4, mp4->mediafp);",
      "363:            do",
      "364:            {",
      "365:             num--;",
      "366:             mp4->metasizes[num] = BYTESWAP32(mp4->metasizes[num]);",
      "367:            } while (num > 0);",
      "368:           }",
      "369:           else",
      "371:            equalsamplesize = BYTESWAP32(equalsamplesize);",
      "372:            do",
      "373:            {",
      "374:             num--;",
      "375:             mp4->metasizes[num] = equalsamplesize;",
      "376:            } while (num > 0);",
      "377:           }",
      "380:         else",
      "381:         {",
      "383:          CloseSource((size_t)mp4);",
      "384:          mp4 = NULL;",
      "385:          break;",
      "386:         }",
      "388:        mp4->filepos += len;",
      "389:        LongSeek(mp4, qtsize - 8 - len); // skip over stsz",
      "392:        LongSeek(mp4, qtsize - 8);",
      "",
      "---------------",
      "--- Hunk 14 ---",
      "[Context before]",
      "369:        num = BYTESWAP32(num);",
      "370:        if (num * 4 <= qtsize - 8 - len)",
      "371:        {",
      "372:         if (mp4->metastsc_count > 0 && num != mp4->metasize_count)",
      "373:         {",
      "375:          if (mp4->metaoffsets) free(mp4->metaoffsets);",
      "378:          {",
      "382:           {",
      "397:            {",
      "399:             {",
      "411:             {",
      "414:             }",
      "421:            }",
      "428:           }",
      "429:          }",
      "430:         }",
      "431:         else",
      "432:         {",
      "433:          mp4->indexcount = num;",
      "434:          if (mp4->metaoffsets) free(mp4->metaoffsets);",
      "437:          {",
      "441:           {",
      "445:            {",
      "451:           }",
      "452:          }",
      "453:         }",
      "454:        }",
      "456:       }",
      "457:       else",
      "460:       NESTSIZE(qtsize);",
      "461:      }",
      "",
      "[Removed Lines]",
      "374:          mp4->indexcount = mp4->metasize_count;",
      "376:          mp4->metaoffsets = (uint64_t *)malloc(mp4->metasize_count * 8);",
      "377:          if (mp4->metaoffsets)",
      "379:           uint32_t *metaoffsets32 = NULL;",
      "380:           metaoffsets32 = (uint32_t *)malloc(num * 4);",
      "381:           if (metaoffsets32)",
      "383:            uint64_t fileoffset = 0;",
      "384:            int stsc_pos = 0;",
      "385:            int stco_pos = 0;",
      "386:            int repeat = 1;",
      "387:            len += fread(metaoffsets32, 1, num * 4, mp4->mediafp);",
      "388:            do",
      "389:            {",
      "390:             num--;",
      "391:             metaoffsets32[num] = BYTESWAP32(metaoffsets32[num]);",
      "392:            } while (num > 0);",
      "394:            mp4->metaoffsets[0] = fileoffset = metaoffsets32[stco_pos];",
      "395:            num = 1;",
      "396:            while (num < mp4->metasize_count)",
      "398:             if (stsc_pos + 1 < (int)mp4->metastsc_count && num == stsc_pos)",
      "400:              stco_pos++; stsc_pos++;",
      "401:              fileoffset = (uint64_t)metaoffsets32[stco_pos];",
      "402:              repeat = 1;",
      "403:             }",
      "404:             else if (repeat == mp4->metastsc[stsc_pos].samples)",
      "405:             {",
      "406:              stco_pos++;",
      "407:              fileoffset = (uint64_t)metaoffsets32[stco_pos];",
      "408:              repeat = 1;",
      "409:             }",
      "410:             else",
      "412:              fileoffset += (uint64_t)mp4->metasizes[num - 1];",
      "413:              repeat++;",
      "416:             mp4->metaoffsets[num] = fileoffset;",
      "420:             num++;",
      "423:            if (mp4->metastsc) free(mp4->metastsc);",
      "424:            mp4->metastsc = NULL;",
      "425:            mp4->metastsc_count = 0;",
      "427:            free(metaoffsets32);",
      "435:          mp4->metaoffsets = (uint64_t *)malloc(num * 8);",
      "436:          if (mp4->metaoffsets)",
      "438:           uint32_t *metaoffsets32 = NULL;",
      "439:           metaoffsets32 = (uint32_t *)malloc(num * 4);",
      "440:           if (metaoffsets32)",
      "442:            size_t readlen = fread(metaoffsets32, 1, num * 4, mp4->mediafp);",
      "443:            len += readlen;",
      "444:            do",
      "446:             num--;",
      "447:             mp4->metaoffsets[num] = BYTESWAP32(metaoffsets32[num]);",
      "448:            } while (num > 0);",
      "450:            free(metaoffsets32);",
      "455:        LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over stco",
      "458:        LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);",
      "",
      "[Added Lines]",
      "405:         uint32_t metastco_count = num;",
      "409:          mp4->indexcount = num;",
      "411:          if(num > 0)",
      "413:           mp4->metaoffsets = (uint64_t *)malloc(num * 8);",
      "414:           if (mp4->metaoffsets)",
      "416:            uint32_t *metaoffsets32 = NULL;",
      "417:            metaoffsets32 = (uint32_t *)malloc(num * 4);",
      "418:            if (metaoffsets32)",
      "420:             uint64_t fileoffset = 0;",
      "421:             int stsc_pos = 0;",
      "422:             int stco_pos = 0;",
      "423:             int repeat = 1;",
      "424:             len += fread(metaoffsets32, 1, num * 4, mp4->mediafp);",
      "425:             do",
      "427:              num--;",
      "428:              metaoffsets32[num] = BYTESWAP32(metaoffsets32[num]);",
      "429:             } while (num > 0);",
      "431:             mp4->metaoffsets[0] = fileoffset = metaoffsets32[stco_pos];",
      "432:             num = 1;",
      "433:             while (num < mp4->indexcount)",
      "435:              if ((uint32_t)repeat == mp4->metastsc[stsc_pos].samples)",
      "436:              {",
      "437:               if ((uint32_t)stco_pos + 1 < metastco_count)",
      "438:               {",
      "439:                stco_pos++;",
      "440:                fileoffset = (uint64_t)metaoffsets32[stco_pos];",
      "441:               }",
      "442:               else",
      "443:               {",
      "444:                fileoffset += (uint64_t)mp4->metasizes[num - 1];",
      "445:               }",
      "446:               if ((uint32_t)stsc_pos + 1 < mp4->metastsc_count)",
      "447:                if (mp4->metastsc[stsc_pos + 1].chunk_num == (uint32_t)stco_pos + 1)",
      "448:                 stsc_pos++;",
      "450:               repeat = 1;",
      "451:              }",
      "452:              else",
      "453:              {",
      "454:               fileoffset += (uint64_t)mp4->metasizes[num - 1];",
      "455:               repeat++;",
      "456:              }",
      "458:              mp4->metaoffsets[num] = fileoffset;",
      "462:              num++;",
      "465:             if (mp4->metastsc) free(mp4->metastsc);",
      "466:             mp4->metastsc = NULL;",
      "467:             mp4->metastsc_count = 0;",
      "469:             free(metaoffsets32);",
      "473:          else",
      "474:          {",
      "476:           CloseSource((size_t)mp4);",
      "477:           mp4 = NULL;",
      "478:           break;",
      "479:          }",
      "485:          if (num > 0)",
      "487:           mp4->metaoffsets = (uint64_t *)malloc(num * 8);",
      "488:           if (mp4->metaoffsets)",
      "490:            uint32_t *metaoffsets32 = NULL;",
      "491:            metaoffsets32 = (uint32_t *)malloc(num * 4);",
      "492:            if (metaoffsets32)",
      "494:             size_t readlen = fread(metaoffsets32, 1, num * 4, mp4->mediafp);",
      "495:             len += readlen;",
      "496:             do",
      "497:             {",
      "498:              num--;",
      "499:              mp4->metaoffsets[num] = BYTESWAP32(metaoffsets32[num]);",
      "500:             } while (num > 0);",
      "502:             free(metaoffsets32);",
      "503:            }",
      "506:          else",
      "507:          {",
      "509:           CloseSource((size_t)mp4);",
      "510:           mp4 = NULL;",
      "511:           break;",
      "512:          }",
      "515:        mp4->filepos += len;",
      "516:        LongSeek(mp4, qtsize - 8 - len); // skip over stco",
      "519:        LongSeek(mp4, qtsize - 8);",
      "",
      "---------------",
      "--- Hunk 15 ---",
      "[Context before]",
      "467:        len = fread(&skip, 1, 4, mp4->mediafp);",
      "468:        len += fread(&num, 1, 4, mp4->mediafp);",
      "469:        num = BYTESWAP32(num);",
      "470:        if (num * 8 <= qtsize - 8 - len)",
      "471:        {",
      "472:         if (mp4->metastsc_count > 0 && num != mp4->metasize_count)",
      "473:         {",
      "474:          mp4->indexcount = mp4->metasize_count;",
      "475:          if (mp4->metaoffsets) free(mp4->metaoffsets);",
      "478:          {",
      "482:           {",
      "488:            {",
      "506:             {",
      "508:             }",
      "515:            }",
      "522:           }",
      "523:          }",
      "524:         }",
      "525:         else",
      "526:         {",
      "",
      "[Removed Lines]",
      "476:          mp4->metaoffsets = (uint64_t *)malloc(mp4->metasize_count * 8);",
      "477:          if (mp4->metaoffsets)",
      "479:           uint64_t *metaoffsets64 = NULL;",
      "480:           metaoffsets64 = (uint64_t *)malloc(num * 8);",
      "481:           if (metaoffsets64)",
      "483:            uint64_t fileoffset = 0;",
      "484:            int stsc_pos = 0;",
      "485:            int stco_pos = 0;",
      "486:            len += fread(metaoffsets64, 1, num * 8, mp4->mediafp);",
      "487:            do",
      "489:             num--;",
      "490:             metaoffsets64[num] = BYTESWAP64(metaoffsets64[num]);",
      "491:            } while (num > 0);",
      "493:            fileoffset = metaoffsets64[0];",
      "494:            mp4->metaoffsets[0] = fileoffset;",
      "497:            num = 1;",
      "498:            while (num < mp4->metasize_count)",
      "499:            {",
      "500:             if (num != mp4->metastsc[stsc_pos].chunk_num - 1 && 0 == (num - (mp4->metastsc[stsc_pos].chunk_num - 1)) % mp4->metastsc[stsc_pos].samples)",
      "501:             {",
      "502:              stco_pos++;",
      "503:              fileoffset = (uint64_t)metaoffsets64[stco_pos];",
      "504:             }",
      "505:             else",
      "507:              fileoffset += (uint64_t)mp4->metasizes[num - 1];",
      "510:             mp4->metaoffsets[num] = fileoffset;",
      "514:             num++;",
      "517:            if (mp4->metastsc) free(mp4->metastsc);",
      "518:            mp4->metastsc = NULL;",
      "519:            mp4->metastsc_count = 0;",
      "521:            free(metaoffsets64);",
      "",
      "[Added Lines]",
      "532:        if(num == 0)",
      "533:        {",
      "535:         CloseSource((size_t)mp4);",
      "536:         mp4 = NULL;",
      "537:         break;",
      "538:        }",
      "546:          if (mp4->metasize_count)",
      "548:           mp4->metaoffsets = (uint64_t *)malloc(mp4->metasize_count * 8);",
      "549:           if (mp4->metaoffsets)",
      "551:            uint64_t *metaoffsets64 = NULL;",
      "552:            metaoffsets64 = (uint64_t *)malloc(num * 8);",
      "553:            if (metaoffsets64)",
      "555:             uint64_t fileoffset = 0;",
      "556:             int stsc_pos = 0;",
      "557:             int stco_pos = 0;",
      "558:             len += fread(metaoffsets64, 1, num * 8, mp4->mediafp);",
      "559:             do",
      "560:             {",
      "561:              num--;",
      "562:              metaoffsets64[num] = BYTESWAP64(metaoffsets64[num]);",
      "563:             } while (num > 0);",
      "565:             fileoffset = metaoffsets64[0];",
      "566:             mp4->metaoffsets[0] = fileoffset;",
      "569:             num = 1;",
      "570:             while (num < mp4->metasize_count)",
      "572:              if (num != mp4->metastsc[stsc_pos].chunk_num - 1 && 0 == (num - (mp4->metastsc[stsc_pos].chunk_num - 1)) % mp4->metastsc[stsc_pos].samples)",
      "573:              {",
      "574:               stco_pos++;",
      "575:               fileoffset = (uint64_t)metaoffsets64[stco_pos];",
      "576:              }",
      "577:              else",
      "578:              {",
      "579:               fileoffset += (uint64_t)mp4->metasizes[num - 1];",
      "580:              }",
      "582:              mp4->metaoffsets[num] = fileoffset;",
      "586:              num++;",
      "589:             if (mp4->metastsc) free(mp4->metastsc);",
      "590:             mp4->metastsc = NULL;",
      "591:             mp4->metastsc_count = 0;",
      "593:             free(metaoffsets64);",
      "597:          else",
      "598:          {",
      "600:           CloseSource((size_t)mp4);",
      "601:           mp4 = NULL;",
      "602:           break;",
      "603:          }",
      "",
      "---------------",
      "--- Hunk 16 ---",
      "[Context before]",
      "538:          }",
      "539:         }",
      "540:        }",
      "542:       }",
      "543:       else",
      "546:       NESTSIZE(qtsize);",
      "547:      }",
      "",
      "[Removed Lines]",
      "541:        LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over stco",
      "544:        LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);",
      "",
      "[Added Lines]",
      "621:        mp4->filepos += len;",
      "622:        LongSeek(mp4, qtsize - 8 - len); // skip over stco",
      "625:        LongSeek(mp4, qtsize - 8);",
      "",
      "---------------",
      "--- Hunk 17 ---",
      "[Context before]",
      "578:         }",
      "579:         mp4->basemetadataduration = mp4->metadatalength * (double)mp4->meta_clockdemon / (double)samples;",
      "580:        }",
      "582:       }",
      "583:       else",
      "586:       NESTSIZE(qtsize);",
      "587:      }",
      "",
      "[Removed Lines]",
      "581:        LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over stco",
      "584:        LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);",
      "",
      "[Added Lines]",
      "662:        mp4->filepos += len;",
      "663:        LongSeek(mp4, qtsize - 8 - len); // skip over stco",
      "666:        LongSeek(mp4, qtsize - 8);",
      "",
      "---------------",
      "--- Hunk 18 ---",
      "[Context before]",
      "595:     break;",
      "596:    }",
      "597:   } while (len > 0);",
      "598:  }",
      "599:  else",
      "600:  {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "681:   if (mp4)",
      "682:   {",
      "683:    if (mp4->metasizes == NULL || mp4->metaoffsets == NULL)",
      "684:    {",
      "685:     CloseSource((size_t)mp4);",
      "686:     mp4 = NULL;",
      "687:    }",
      "688:   }",
      "",
      "---------------",
      "--- Hunk 19 ---",
      "[Context before]",
      "631: }",
      "635: {",
      "636:  mp4object *mp4 = (mp4object *)handle;",
      "644: }",
      "649: size_t OpenMP4SourceUDTA(char *filename)",
      "650: {",
      "",
      "[Removed Lines]",
      "634: uint32_t GetPayloadTime(size_t handle, uint32_t index, float *in, float *out)",
      "637:  if (mp4 == NULL) return 0;",
      "639:  if (mp4->metaoffsets == 0 || mp4->basemetadataduration == 0 || mp4->meta_clockdemon == 0 || in == NULL || out == NULL) return 1;",
      "643:  return 0;",
      "",
      "[Added Lines]",
      "725: uint32_t GetPayloadTime(size_t handle, uint32_t index, double *in, double *out)",
      "728:  if (mp4 == NULL) return GPMF_ERROR_MEMORY;",
      "730:  if (mp4->metaoffsets == 0 || mp4->basemetadataduration == 0 || mp4->meta_clockdemon == 0 || in == NULL || out == NULL) return GPMF_ERROR_MEMORY;",
      "734:  return GPMF_OK;",
      "738: uint32_t GetPayloadRationalTime(size_t handle, uint32_t index, uint32_t *in_numerator, uint32_t *out_numerator, uint32_t *denominator)",
      "739: {",
      "740:     mp4object *mp4 = (mp4object *)handle;",
      "741:     if (mp4 == NULL) return GPMF_ERROR_MEMORY;",
      "743:     if (mp4->metaoffsets == 0 || mp4->basemetadataduration == 0 || mp4->meta_clockdemon == 0 || in_numerator == NULL || out_numerator == NULL) return GPMF_ERROR_MEMORY;",
      "749:     return GPMF_OK;",
      "750: }",
      "",
      "---------------",
      "--- Hunk 20 ---",
      "[Context before]",
      "662:  if (mp4->mediafp)",
      "663:  {",
      "665:   int32_t nest = 0;",
      "666:   uint64_t nestsize[MAX_NEST_LEVEL] = { 0 };",
      "667:   uint64_t lastsize = 0, qtsize;",
      "",
      "[Removed Lines]",
      "664:   uint32_t qttag, qtsize32, len;",
      "",
      "[Added Lines]",
      "767:   uint32_t qttag, qtsize32;",
      "768:   size_t len;",
      "",
      "---------------",
      "--- Hunk 21 ---",
      "[Context before]",
      "674:    {",
      "675:     if (!GPMF_VALID_FOURCC(qttag))",
      "676:     {",
      "679:      NESTSIZE(lastsize - 8);",
      "680:      continue;",
      "",
      "[Removed Lines]",
      "677:      LONGSEEK(mp4->mediafp, lastsize - 8 - 8, SEEK_CUR);",
      "",
      "[Added Lines]",
      "781:      LongSeek(mp4, lastsize - 8 - 8);",
      "",
      "---------------",
      "--- Hunk 22 ---",
      "[Context before]",
      "701:     if (qttag == MAKEID('m', 'd', 'a', 't') ||",
      "702:      qttag == MAKEID('f', 't', 'y', 'p'))",
      "703:     {",
      "705:      NESTSIZE(qtsize);",
      "706:      continue;",
      "707:     }",
      "",
      "[Removed Lines]",
      "704:      LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);",
      "",
      "[Added Lines]",
      "808:      LongSeek(mp4, qtsize - 8);",
      "",
      "---------------",
      "--- Hunk 23 ---",
      "[Context before]",
      "725:     if (qttag != MAKEID('m', 'o', 'o', 'v') && //skip over all but these atoms",
      "726:      qttag != MAKEID('u', 'd', 't', 'a'))",
      "727:     {",
      "729:      NESTSIZE(qtsize);",
      "730:      continue;",
      "731:     }",
      "",
      "[Removed Lines]",
      "728:      LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);",
      "",
      "[Added Lines]",
      "832:      LongSeek(mp4, qtsize - 8);",
      "",
      "---------------",
      "--- Hunk 24 ---",
      "[Context before]",
      "740: }",
      "744: {",
      "745:  mp4object *mp4 = (mp4object *)handle;",
      "746:  if (mp4 == NULL) return 0.0;",
      "",
      "[Removed Lines]",
      "743: double GetGPMFSampleRate(size_t handle, uint32_t fourcc, uint32_t flags)",
      "",
      "[Added Lines]",
      "847: double GetGPMFSampleRate(size_t handle, uint32_t fourcc, uint32_t flags, double *firstsampletime, double *lastsampletime)",
      "",
      "---------------",
      "--- Hunk 25 ---",
      "[Context before]",
      "750:  uint32_t testend = mp4->indexcount;",
      "751:  double rate = 0.0;",
      "753:  if (mp4->indexcount < 1)",
      "754:   return 0.0;",
      "766:  if (ret != GPMF_OK)",
      "767:   goto cleanup;",
      "769:  {",
      "770:   uint32_t startsamples = 0;",
      "771:   uint32_t endsamples = 0;",
      "775:   {",
      "777:    teststart++;",
      "778:    payload = GetPayload(handle, payload, teststart); // second last payload",
      "779:    payloadsize = GetPayloadSize(handle, teststart);",
      "780:    ret = GPMF_Init(ms, payload, payloadsize);",
      "781:   }",
      "792:   {",
      "794:    GPMF_stream find_stream;",
      "795:    GPMF_CopyState(ms, &find_stream);",
      "798:    {",
      "802:     payloadsize = GetPayloadSize(handle, testend);",
      "803:     ret = GPMF_Init(ms, payload, payloadsize);",
      "808:     {",
      "811:      {",
      "815:      }",
      "816:     }",
      "819:    }",
      "821:    {",
      "830:     {",
      "839:      {",
      "844:       {",
      "850:         {",
      "867:        {",
      "875:        }",
      "876:       }",
      "877:      }",
      "889:      {",
      "899: #if 0",
      "901:      {",
      "905:      }",
      "917:    }",
      "952:  }",
      "969:  return rate;",
      "970: }",
      "",
      "[Removed Lines]",
      "756:  if (mp4->indexcount > 3) // samples after first and before last are statistically the best, avoiding camera start up or shutdown anomollies.",
      "757:  {",
      "758:   teststart++;",
      "759:   testend--;",
      "760:  }",
      "762:  uint32_t *payload = GetPayload(handle, NULL, teststart); // second payload",
      "763:  uint32_t payloadsize = GetPayloadSize(handle, teststart);",
      "764:  int32_t ret = GPMF_Init(ms, payload, payloadsize);",
      "772:   uint32_t missing_samples = 0;",
      "774:   while (ret == GPMF_OK && GPMF_OK != GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS))",
      "776:    missing_samples = 1;",
      "783:   if (missing_samples)",
      "784:   {",
      "785:    teststart++;   //samples after sensor start are statistically the best",
      "786:    payload = GetPayload(handle, payload, teststart);",
      "787:    payloadsize = GetPayloadSize(handle, teststart);",
      "788:    ret = GPMF_Init(ms, payload, payloadsize);",
      "789:   }",
      "791:   if (ret == GPMF_OK)",
      "793:    uint32_t samples = GPMF_Repeat(ms);",
      "797:    if (!(flags & GPMF_SAMPLE_RATE_PRECISE) && GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TOTAL_SAMPLES, GPMF_CURRENT_LEVEL))",
      "799:     startsamples = BYTESWAP32(*(uint32_t *)GPMF_RawData(&find_stream)) - samples;",
      "801:     payload = GetPayload(handle, payload, testend); // second last payload",
      "804:     if (ret != GPMF_OK)",
      "805:      goto cleanup;",
      "807:     if (GPMF_OK == GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS))",
      "809:      GPMF_CopyState(ms, &find_stream);",
      "810:      if (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TOTAL_SAMPLES, GPMF_CURRENT_LEVEL))",
      "812:       endsamples = BYTESWAP32(*(uint32_t *)GPMF_RawData(&find_stream));",
      "813:       rate = (double)(endsamples - startsamples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);",
      "814:       goto cleanup;",
      "818:     rate = (double)(samples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);",
      "820:    else // for increased precision, for older GPMF streams sometimes missing the total sample count",
      "822:     uint32_t payloadpos = 0, payloadcount = 0;",
      "823:     double slope, top = 0.0, bot = 0.0, meanX = 0, meanY = 0;",
      "824:     uint32_t *repeatarray = malloc(mp4->indexcount * 4 + 4);",
      "825:     memset(repeatarray, 0, mp4->indexcount * 4 + 4);",
      "827:     samples = 0;",
      "829:     for (payloadpos = teststart; payloadpos < testend; payloadcount++, payloadpos++)",
      "831:      payload = GetPayload(handle, payload, payloadpos); // second last payload",
      "832:      payloadsize = GetPayloadSize(handle, payloadpos);",
      "833:      ret = GPMF_Init(ms, payload, payloadsize);",
      "835:      if (ret != GPMF_OK)",
      "836:       goto cleanup;",
      "838:      if (GPMF_OK == GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS))",
      "840:       GPMF_stream find_stream2;",
      "841:       GPMF_CopyState(ms, &find_stream2);",
      "843:       if (GPMF_OK == GPMF_FindNext(&find_stream2, fourcc, GPMF_CURRENT_LEVEL)) // Count the instances, not the repeats",
      "845:        if (repeatarray)",
      "846:        {",
      "847:         float in, out;",
      "849:         do",
      "851:          samples++;",
      "852:         } while (GPMF_OK == GPMF_FindNext(ms, fourcc, GPMF_CURRENT_LEVEL));",
      "854:         repeatarray[payloadpos] = samples;",
      "855:         meanY += (double)samples;",
      "857:         GetPayloadTime(handle, payloadpos, &in, &out);",
      "858:         meanX += out;",
      "859:        }",
      "860:       }",
      "861:       else",
      "862:       {",
      "863:        uint32_t repeat = GPMF_Repeat(ms);",
      "864:        samples += repeat;",
      "866:        if (repeatarray)",
      "868:         float in, out;",
      "870:         repeatarray[payloadpos] = samples;",
      "871:         meanY += (double)samples;",
      "873:         GetPayloadTime(handle, payloadpos, &in, &out);",
      "874:         meanX += out;",
      "878:     }",
      "883:     if (repeatarray)",
      "884:     {",
      "885:      meanY /= (double)payloadcount;",
      "886:      meanX /= (double)payloadcount;",
      "888:      for (payloadpos = teststart; payloadpos < testend; payloadpos++)",
      "890:       float in, out;",
      "891:       GetPayloadTime(handle, payloadpos, &in, &out);",
      "893:       top += ((double)out - meanX)*((double)repeatarray[payloadpos] - meanY);",
      "894:       bot += ((double)out - meanX)*((double)out - meanX);",
      "895:      }",
      "897:      slope = top / bot;",
      "902:       double intercept;",
      "903:       intercept = meanY - slope*meanX;",
      "904:       printf(\"%c%c%c%c start offset = %f (%.3fms)\\n\", PRINTF_4CC(fourcc), intercept, 1000.0 * intercept / slope);",
      "906: #endif",
      "907:      rate = slope;",
      "908:     }",
      "909:     else",
      "910:     {",
      "911:      rate = (double)(samples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);",
      "912:     }",
      "914:     free(repeatarray);",
      "916:     goto cleanup;",
      "918:   }",
      "919:  }",
      "921: cleanup:",
      "922:  if (payload)",
      "923:  {",
      "924:   FreePayload(payload);",
      "925:   payload = NULL;",
      "926:  }",
      "928:  return rate;",
      "929: }",
      "932: double GetGPMFSampleRateAndTimes(size_t handle, GPMF_stream *gs, double rate, uint32_t index, double *in, double *out)",
      "933: {",
      "934:  mp4object *mp4 = (mp4object *)handle;",
      "935:  if (mp4 == NULL) return 0.0;",
      "937:  uint32_t key, insamples;",
      "938:  uint32_t repeat, outsamples;",
      "939:  GPMF_stream find_stream;",
      "941:  if (gs == NULL || mp4->metaoffsets == 0 || mp4->indexcount == 0 || mp4->basemetadataduration == 0 || mp4->meta_clockdemon == 0 || in == NULL || out == NULL) return 0.0;",
      "943:  key = GPMF_Key(gs);",
      "944:  repeat = GPMF_Repeat(gs);",
      "945:  if (rate == 0.0)",
      "946:   rate = GetGPMFSampleRate(handle, key, GPMF_SAMPLE_RATE_FAST);",
      "948:  if (rate == 0.0)",
      "949:  {",
      "951:   return 0.0;",
      "954:  GPMF_CopyState(gs, &find_stream);",
      "955:  if (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TOTAL_SAMPLES, GPMF_CURRENT_LEVEL))",
      "956:  {",
      "957:   outsamples = BYTESWAP32(*(uint32_t *)GPMF_RawData(&find_stream));",
      "958:   insamples = outsamples - repeat;",
      "962:  }",
      "963:  else",
      "964:  {",
      "968:  }",
      "",
      "[Added Lines]",
      "857:  uint32_t *payload;",
      "858:  uint32_t payloadsize;",
      "859:  int32_t ret;",
      "864:  payload = GetPayload(handle, NULL, teststart);",
      "865:  payloadsize = GetPayloadSize(handle, teststart);",
      "866:  ret = GPMF_Init(ms, payload, payloadsize);",
      "872:   uint64_t minimumtimestamp = 0;",
      "873:   uint64_t starttimestamp = 0;",
      "874:   uint64_t endtimestamp = 0;",
      "877:   double intercept = 0.0;",
      "881:   while (teststart < mp4->indexcount && ret == GPMF_OK && GPMF_OK != GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS))",
      "889:   if (ret == GPMF_OK && payload)",
      "891:    uint32_t samples = GPMF_PayloadSampleCount(ms);",
      "894:    if (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TOTAL_SAMPLES, GPMF_CURRENT_LEVEL))",
      "895:     startsamples = BYTESWAP32(*(uint32_t *)GPMF_RawData(&find_stream)) - samples;",
      "897:    GPMF_CopyState(ms, &find_stream);",
      "898:    if (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TIME_STAMP, GPMF_CURRENT_LEVEL))",
      "899:     starttimestamp = BYTESWAP64(*(uint64_t *)GPMF_RawData(&find_stream));",
      "901:    if (starttimestamp) // is this earliest in the payload, examine the other streams in this early payload.",
      "903:     GPMF_stream any_stream;",
      "904:     GPMF_Init(&any_stream, payload, payloadsize);",
      "906:     minimumtimestamp = starttimestamp;",
      "907:     while (GPMF_OK == GPMF_FindNext(&any_stream, GPMF_KEY_TIME_STAMP, GPMF_RECURSE_LEVELS))",
      "908:     {",
      "909:      uint64_t timestamp = BYTESWAP64(*(uint64_t *)GPMF_RawData(&any_stream));",
      "910:      if (timestamp < minimumtimestamp)",
      "911:       minimumtimestamp = timestamp;",
      "912:     }",
      "913:    }",
      "915:    testend = mp4->indexcount;",
      "916:    do",
      "917:    {",
      "918:     testend--;// last payload with the fourcc needed",
      "919:     payload = GetPayload(handle, payload, testend);",
      "922:    } while (testend > 0 && GPMF_OK != GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS));",
      "924:    GPMF_CopyState(ms, &find_stream);",
      "925:    if (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TOTAL_SAMPLES, GPMF_CURRENT_LEVEL))",
      "926:     endsamples = BYTESWAP32(*(uint32_t *)GPMF_RawData(&find_stream));",
      "927:    else // If there is no TSMP we have to count the samples.",
      "928:    {",
      "929:     uint32_t i;",
      "930:     for (i = teststart; i <= testend; i++)",
      "932:      payload = GetPayload(handle,payload, i); // second last payload",
      "933:      payloadsize = GetPayloadSize(handle, i);",
      "934:      if (GPMF_OK == GPMF_Init(ms, payload, payloadsize))",
      "935:       if (GPMF_OK == GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS))",
      "936:        endsamples += GPMF_PayloadSampleCount(ms);",
      "937:     }",
      "938:    }",
      "940:    if (starttimestamp != 0)",
      "941:    {",
      "942:     uint32_t last_samples = GPMF_PayloadSampleCount(ms);",
      "943:     uint32_t totaltimestamped_samples = endsamples - last_samples - startsamples;",
      "944:     double time_stamp_scale = 1000000000.0; // scan for nanoseconds, microseconds to seconds, all base 10.",
      "946:     GPMF_CopyState(ms, &find_stream);",
      "947:     if (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TIME_STAMP, GPMF_CURRENT_LEVEL))",
      "948:      endtimestamp = BYTESWAP64(*(uint64_t *)GPMF_RawData(&find_stream));",
      "950:     if (endtimestamp)",
      "951:     {",
      "952:      double approxrate = 0.0;",
      "953:      if (endsamples > startsamples)",
      "954:       approxrate = (double)(endsamples - startsamples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);",
      "956:      if (approxrate == 0.0)",
      "957:       approxrate = (double)(samples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);",
      "960:      while (time_stamp_scale >= 1)",
      "962:       rate = (double)(totaltimestamped_samples) / ((double)(endtimestamp - starttimestamp) / time_stamp_scale);",
      "963:       if (rate*0.9 < approxrate && approxrate < rate*1.1)",
      "964:        break;",
      "966:       time_stamp_scale *= 0.1;",
      "968:      if (time_stamp_scale < 1.0) rate = 0.0;",
      "969:      intercept = (((double)minimumtimestamp - (double)starttimestamp) / time_stamp_scale) * rate;",
      "973:    if (rate == 0.0) //Timestamps didn't help weren't available",
      "975:     if (!(flags & GPMF_SAMPLE_RATE_PRECISE))",
      "976:     {",
      "977:      if (endsamples > startsamples)",
      "978:       rate = (double)(endsamples - startsamples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);",
      "980:      if (rate == 0.0)",
      "981:       rate = (double)(samples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);",
      "983:      double in, out;",
      "984:      if (GPMF_OK == GetPayloadTime(handle, teststart, &in, &out))",
      "985:       intercept = (double)-in * rate;",
      "986:     }",
      "987:     else // for increased precision, for older GPMF streams sometimes missing the total sample count",
      "989:      uint32_t payloadpos = 0, payloadcount = 0;",
      "990:      double slope, top = 0.0, bot = 0.0, meanX = 0, meanY = 0;",
      "991:      uint32_t *repeatarray = malloc(mp4->indexcount * 4 + 4);",
      "992:      memset(repeatarray, 0, mp4->indexcount * 4 + 4);",
      "994:      samples = 0;",
      "996:      for (payloadpos = teststart; payloadpos <= testend; payloadpos++)",
      "998:       payload = GetPayload(handle, payload, payloadpos); // second last payload",
      "999:       payloadsize = GetPayloadSize(handle, payloadpos);",
      "1000:       ret = GPMF_Init(ms, payload, payloadsize);",
      "1002:       if (ret != GPMF_OK)",
      "1003:        goto cleanup;",
      "1005:       if (GPMF_OK == GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS))",
      "1007:        GPMF_stream find_stream2;",
      "1008:        GPMF_CopyState(ms, &find_stream2);",
      "1010:        payloadcount++;",
      "1012:        if (GPMF_OK == GPMF_FindNext(&find_stream2, fourcc, GPMF_CURRENT_LEVEL)) // Count the instances, not the repeats",
      "1013:        {",
      "1014:         if (repeatarray)",
      "1016:          double in, out;",
      "1018:          do",
      "1019:          {",
      "1020:           samples++;",
      "1021:          } while (GPMF_OK == GPMF_FindNext(ms, fourcc, GPMF_CURRENT_LEVEL));",
      "1023:          repeatarray[payloadpos] = samples;",
      "1024:          meanY += (double)samples;",
      "1026:          if (GPMF_OK == GetPayloadTime(handle, payloadpos, &in, &out))",
      "1027:           meanX += out;",
      "1028:         }",
      "1029:        }",
      "1030:        else",
      "1032:         uint32_t repeat = GPMF_PayloadSampleCount(ms);",
      "1033:         samples += repeat;",
      "1035:         if (repeatarray)",
      "1036:         {",
      "1037:          double in, out;",
      "1039:          repeatarray[payloadpos] = samples;",
      "1040:          meanY += (double)samples;",
      "1042:          if (GPMF_OK == GetPayloadTime(handle, payloadpos, &in, &out))",
      "1043:           meanX += out;",
      "1044:         }",
      "1047:       else",
      "1048:       {",
      "1049:        repeatarray[payloadpos] = 0;",
      "1050:       }",
      "1056:      if (repeatarray)",
      "1058:       meanY /= (double)payloadcount;",
      "1059:       meanX /= (double)payloadcount;",
      "1061:       for (payloadpos = teststart; payloadpos <= testend; payloadpos++)",
      "1062:       {",
      "1063:        double in, out;",
      "1064:        if (repeatarray[payloadpos] && GPMF_OK == GetPayloadTime(handle, payloadpos, &in, &out))",
      "1065:        {",
      "1066:         top += ((double)out - meanX)*((double)repeatarray[payloadpos] - meanY);",
      "1067:         bot += ((double)out - meanX)*((double)out - meanX);",
      "1068:        }",
      "1069:       }",
      "1071:       slope = top / bot;",
      "1072:       rate = slope;",
      "1075:       intercept = meanY - slope * meanX;",
      "1077:       printf(\"%c%c%c%c start offset = %f (%.3fms) rate = %f\\n\", PRINTF_4CC(fourcc), intercept, 1000.0 * intercept / slope, rate);",
      "1078:       printf(\"%c%c%c%c first sample at time %.3fms\\n\", PRINTF_4CC(fourcc), -1000.0 * intercept / slope);",
      "1079: #endif",
      "1080:      }",
      "1081:      else",
      "1083:       rate = (double)(samples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);",
      "1086:      free(repeatarray);",
      "1087:     }",
      "1090:    if (firstsampletime && lastsampletime)",
      "1091:    {",
      "1092:     uint32_t endpayload = mp4->indexcount;",
      "1093:     do",
      "1094:     {",
      "1095:      endpayload--;// last payload with the fourcc needed",
      "1096:      payload = GetPayload(handle, payload, endpayload);",
      "1097:      payloadsize = GetPayloadSize(handle, endpayload);",
      "1098:      ret = GPMF_Init(ms, payload, payloadsize);",
      "1099:     } while (endpayload > 0 && GPMF_OK != GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS));",
      "1101:     if (endpayload > 0 && ret == GPMF_OK)",
      "1102:     {",
      "1103:      uint32_t totalsamples = endsamples - startsamples;",
      "1104:      float timo = 0.0;",
      "1106:      GPMF_CopyState(ms, &find_stream);",
      "1107:      if (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TIME_OFFSET, GPMF_CURRENT_LEVEL))",
      "1108:       GPMF_FormattedData(&find_stream, &timo, 4, 0, 1);",
      "1110:      double first, last;",
      "1111:      first = -intercept / rate - timo;",
      "1112:      last = first + (double)totalsamples / rate;",
      "1116:      if (firstsampletime) *firstsampletime = first;",
      "1118:      if (lastsampletime) *lastsampletime = last;",
      "1119:     }",
      "1120:    }",
      "1121:   }",
      "1124: cleanup:",
      "1125:  if (payload)",
      "1126:   FreePayload(payload);",
      "1127:  payload = NULL;",
      "",
      "---------------"
    ],
    "demo/GPMF_mp4reader.h||demo/GPMF_mp4reader.h": [
      "File: demo/GPMF_mp4reader.h -> demo/GPMF_mp4reader.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "64:  uint32_t meta_clockdemon, meta_clockcount;",
      "65:  double basemetadataduration;",
      "66:  FILE *mediafp;",
      "67: } mp4object;",
      "69: #define MAKEID(a,b,c,d)   (((d&0xff)<<24)|((c&0xff)<<16)|((b&0xff)<<8)|(a&0xff))",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "67:  uint64_t filesize;",
      "68:  uint64_t filepos;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "101: float GetDuration(size_t handle);",
      "102: uint32_t GetNumberPayloads(size_t handle);",
      "103: uint32_t *GetPayload(size_t handle, uint32_t *lastpayload, uint32_t index);",
      "105: void FreePayload(uint32_t *lastpayload);",
      "106: uint32_t GetPayloadSize(size_t handle, uint32_t index);",
      "109: #define GPMF_SAMPLE_RATE_FAST  0",
      "110: #define GPMF_SAMPLE_RATE_PRECISE 1",
      "115: #ifdef __cplusplus",
      "116: }",
      "",
      "[Removed Lines]",
      "104: void SavePayload(size_t handle, uint32_t *payload, uint32_t index);",
      "107: uint32_t GetPayloadTime(size_t handle, uint32_t index, float *in, float *out); //MP4 timestamps for the payload",
      "112: double GetGPMFSampleRate(size_t handle, uint32_t fourcc, uint32_t flags);",
      "113: double GetGPMFSampleRateAndTimes(size_t handle, GPMF_stream *gs, double lastrate, uint32_t index, double *in, double *out); //Jitter corrected sample(s) time, if lastrate is unknown, send 0.0 and it will be computed",
      "",
      "[Added Lines]",
      "108: uint32_t GetPayloadTime(size_t handle, uint32_t index, double *in, double *out); //MP4 timestamps for the payload",
      "109: uint32_t GetPayloadRationalTime(size_t handle, uint32_t index, uint32_t *in_numerator, uint32_t *out_numerator, uint32_t *denominator);",
      "114: double GetGPMFSampleRate(size_t handle, uint32_t fourcc, uint32_t flags, double *in, double *out);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "6cbace8761abb5a742b0acc50df0136cd16d76c8",
      "candidate_info": {
        "commit_hash": "6cbace8761abb5a742b0acc50df0136cd16d76c8",
        "repo": "gopro/gpmf-parser",
        "commit_url": "https://github.com/gopro/gpmf-parser/commit/6cbace8761abb5a742b0acc50df0136cd16d76c8",
        "files": [
          "demo/GPMF_demo.c",
          "demo/GPMF_mp4reader.c"
        ],
        "message": "fix for reading 'udta' GPMF",
        "before_after_code_files": [
          "demo/GPMF_demo.c||demo/GPMF_demo.c",
          "demo/GPMF_mp4reader.c||demo/GPMF_mp4reader.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "demo/GPMF_demo.c||demo/GPMF_demo.c",
            "demo/GPMF_mp4reader.c||demo/GPMF_mp4reader.c"
          ],
          "candidate": [
            "demo/GPMF_demo.c||demo/GPMF_demo.c",
            "demo/GPMF_mp4reader.c||demo/GPMF_mp4reader.c"
          ]
        }
      },
      "candidate_diff": {
        "demo/GPMF_demo.c||demo/GPMF_demo.c": [
          "File: demo/GPMF_demo.c -> demo/GPMF_demo.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "44:   printf(\"usage: %s <file_with_GPMF>\\n\", argv[0]);",
          "45:   return -1;",
          "46:  }",
          "48:  size_t mp4 = OpenMP4Source(argv[1], MOV_GPMF_TRAK_TYPE, MOV_GPMF_TRAK_SUBTYPE);",
          "49:  if (mp4 == 0)",
          "50:  {",
          "51:   printf(\"error: %s is an invalid MP4/MOV\\n\", argv[1]);",
          "52:   return -1;",
          "53:  }",
          "57:  metadatalength = GetDuration(mp4);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "47: #if 1",
          "49: #else",
          "50:  size_t mp4 = OpenMP4SourceUDTA(argv[1]);  //Search for GPMF payload with MP4's udta",
          "51: #endif",
          "",
          "---------------"
        ],
        "demo/GPMF_mp4reader.c||demo/GPMF_mp4reader.c": [
          "File: demo/GPMF_mp4reader.c -> demo/GPMF_mp4reader.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "764:  memset(mp4, 0, sizeof(mp4object));",
          "766: #ifdef _WINDOWS",
          "767:  fopen_s(&mp4->mediafp, filename, \"rb\");",
          "768: #else",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "766: #ifdef _WINDOWS",
          "767:  struct _stat64 mp4stat;",
          "768:  _stat64(filename, &mp4stat);",
          "769: #else",
          "770:  struct stat mp4stat;",
          "771:  stat(filename, &mp4stat);",
          "772: #endif",
          "773:  mp4->filesize = mp4stat.st_size;",
          "774:  if (mp4->filesize < 64) return 0;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "785:    {",
          "786:     if (!GPMF_VALID_FOURCC(qttag))",
          "787:     {",
          "790:      NESTSIZE(lastsize - 8);",
          "791:      continue;",
          "",
          "[Removed Lines]",
          "788:      LongSeek(mp4, lastsize - 8 - 8);",
          "",
          "[Added Lines]",
          "798:      mp4->filepos += len;",
          "799:      LongSeek(mp4, lastsize - 8 - len);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "796:     if (qtsize32 == 1) // 64-bit Atom",
          "797:     {",
          "799:      qtsize = BYTESWAP64(qtsize) - 8;",
          "800:     }",
          "801:     else",
          "",
          "[Removed Lines]",
          "798:      fread(&qtsize, 1, 8, mp4->mediafp);",
          "",
          "[Added Lines]",
          "809:      len += fread(&qtsize, 1, 8, mp4->mediafp);",
          "810:      mp4->filepos += len;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "868b741c4de415b41556e47b4383676295ceadf5",
      "candidate_info": {
        "commit_hash": "868b741c4de415b41556e47b4383676295ceadf5",
        "repo": "gopro/gpmf-parser",
        "commit_url": "https://github.com/gopro/gpmf-parser/commit/868b741c4de415b41556e47b4383676295ceadf5",
        "files": [
          "demo/GPMF_mp4reader.c"
        ],
        "message": "moved some fixed from develop: fix for corrupted mp4 crashing the mp4reader due to 32-bit overflows",
        "before_after_code_files": [
          "demo/GPMF_mp4reader.c||demo/GPMF_mp4reader.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "demo/GPMF_mp4reader.c||demo/GPMF_mp4reader.c"
          ],
          "candidate": [
            "demo/GPMF_mp4reader.c||demo/GPMF_mp4reader.c"
          ]
        }
      },
      "candidate_diff": {
        "demo/GPMF_mp4reader.c||demo/GPMF_mp4reader.c": [
          "File: demo/GPMF_mp4reader.c -> demo/GPMF_mp4reader.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "156:    mp4->filepos += len;",
          "157:    if (len == 8 && mp4->filepos < mp4->filesize)",
          "158:    {",
          "159:     if (!VALID_FOURCC(qttag))",
          "160:     {",
          "161:      CloseSource((size_t)mp4);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "159:     if (mp4->filepos == 8 && qttag != MAKEID('f', 't', 'y', 'p'))",
          "160:     {",
          "161:      CloseSource((size_t)mp4);",
          "162:      mp4 = NULL;",
          "163:      break;",
          "164:     }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "174:     else",
          "175:      qtsize = qtsize32;",
          "177:     nest++;",
          "179:     if (qtsize < 8) break;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "184:     if(qtsize-len > (mp4->filesize - mp4->filepos))  // not parser truncated files.",
          "185:     {",
          "186:      CloseSource((size_t)mp4);",
          "187:      mp4 = NULL;",
          "188:      break;",
          "189:     }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "308:        len += fread(&num, 1, 4, mp4->mediafp);",
          "310:        num = BYTESWAP32(num);",
          "312:        {",
          "313:         mp4->metastsc_count = num;",
          "314:         if (mp4->metastsc) free(mp4->metastsc);",
          "",
          "[Removed Lines]",
          "311:        if (num * 12 <= qtsize - 8 - len)",
          "",
          "[Added Lines]",
          "325:        if (num <= ((qtsize - 8 - len)/sizeof(SampleToChunk)))",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "355:        len += fread(&num, 1, 4, mp4->mediafp);",
          "357:        num = BYTESWAP32(num);",
          "359:        {",
          "360:         mp4->metasize_count = num;",
          "361:         if (mp4->metasizes) free(mp4->metasizes);",
          "",
          "[Removed Lines]",
          "358:        if (num * 4 <= qtsize - 8 - len)",
          "",
          "[Added Lines]",
          "372:        if (num <= ((qtsize - 8 - len)/sizeof(uint32_t)))",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "407:        len = fread(&skip, 1, 4, mp4->mediafp);",
          "408:        len += fread(&num, 1, 4, mp4->mediafp);",
          "409:        num = BYTESWAP32(num);",
          "411:        {",
          "412:         uint32_t metastco_count = num;",
          "",
          "[Removed Lines]",
          "410:        if (num * 4 <= qtsize - 8 - len)",
          "",
          "[Added Lines]",
          "424:        if (num <= ((qtsize - 8 - len)/sizeof(uint32_t)))",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "544:         break;",
          "545:        }",
          "548:        {",
          "549:         if (mp4->metastsc_count > 0 && num != mp4->metasize_count)",
          "550:         {",
          "",
          "[Removed Lines]",
          "547:        if (num * 8 <= qtsize - 8 - len)",
          "",
          "[Added Lines]",
          "561:        if (num <= ((qtsize - 8 - len)/sizeof(uint64_t)))",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "642:        len = fread(&skip, 1, 4, mp4->mediafp);",
          "643:        len += fread(&num, 1, 4, mp4->mediafp);",
          "644:        num = BYTESWAP32(num);",
          "646:        {",
          "647:         entries = num;",
          "",
          "[Removed Lines]",
          "645:        if (num * 8 <= qtsize - 8 - len)",
          "",
          "[Added Lines]",
          "659:        if (num <= ((qtsize - 8 - len)/8))",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "664:          totaldur += duration;",
          "665:          mp4->metadatalength += (double)((double)samplecount * (double)duration / (double)mp4->meta_clockdemon);",
          "666:         }",
          "668:        }",
          "669:        mp4->filepos += len;",
          "670:        LongSeek(mp4, qtsize - 8 - len); // skip over stco",
          "",
          "[Removed Lines]",
          "667:         mp4->basemetadataduration = mp4->metadatalength * (double)mp4->meta_clockdemon / (double)samples;",
          "",
          "[Added Lines]",
          "680:          if (samplecount > 1 || num == 1)",
          "681:           mp4->basemetadataduration = mp4->metadatalength * (double)mp4->meta_clockdemon / (double)samples;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "880:  if (mp4->indexcount < 1)",
          "881:   return 0.0;",
          "884:  payloadsize = GetPayloadSize(handle, teststart);",
          "885:  ret = GPMF_Init(ms, payload, payloadsize);",
          "888:  {",
          "889:   uint64_t minimumtimestamp = 0;",
          "",
          "[Removed Lines]",
          "883:  payload = GetPayload(handle, NULL, teststart);",
          "886:  if (ret != GPMF_OK) goto cleanup;",
          "",
          "[Added Lines]",
          "898:  payload = GetPayload(handle, NULL, teststart);",
          "902:  if (ret != GPMF_OK)",
          "903:   goto cleanup;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2015-0278",
  "cve_desc": "libuv before 0.10.34 does not properly drop group privileges, which allows context-dependent attackers to gain privileges via unspecified vectors.",
  "repo": "libuv/libuv",
  "patch_hash": "66ab38918c911bcff025562cf06237d7fedaba0c",
  "patch_info": {
    "commit_hash": "66ab38918c911bcff025562cf06237d7fedaba0c",
    "repo": "libuv/libuv",
    "commit_url": "https://github.com/libuv/libuv/commit/66ab38918c911bcff025562cf06237d7fedaba0c",
    "files": [
      "src/unix/process.c"
    ],
    "message": "unix: call setgoups before calling setuid/setgid\n\nPartial fix for #1093",
    "before_after_code_files": [
      "src/unix/process.c||src/unix/process.c"
    ]
  },
  "patch_diff": {
    "src/unix/process.c||src/unix/process.c": [
      "File: src/unix/process.c -> src/unix/process.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "330:     _exit(127);",
      "331:   }",
      "333:   if ((options->flags & UV_PROCESS_SETGID) && setgid(options->gid)) {",
      "334:     uv__write_int(error_fd, -errno);",
      "335:     perror(\"setgid()\");",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "333:   if (options->flags & (UV_PROCESS_SETUID | UV_PROCESS_SETGID)) {",
      "341:     SAVE_ERRNO(setgroups(0, NULL));",
      "342:   }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "2b2141924282a046b9f199374da2aa0da058656a",
      "candidate_info": {
        "commit_hash": "2b2141924282a046b9f199374da2aa0da058656a",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/2b2141924282a046b9f199374da2aa0da058656a",
        "files": [
          "src/inet.c",
          "test/test-ip6-addr.c",
          "test/test-list.h",
          "uv.gyp"
        ],
        "message": "inet: allow scopeid in uv_inet_pton\n\nWe already support it in `uv_ip6_addr` anyway.\n\nSee https://github.com/joyent/node/issues/7395",
        "before_after_code_files": [
          "src/inet.c||src/inet.c",
          "test/test-ip6-addr.c||test/test-ip6-addr.c",
          "test/test-list.h||test/test-list.h",
          "uv.gyp||uv.gyp"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/inet.c||src/inet.c": [
          "File: src/inet.c -> src/inet.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "225:   curtok = src;",
          "226:   seen_xdigits = 0;",
          "227:   val = 0;",
          "229:     const char *pch;",
          "231:     if ((pch = strchr((xdigits = xdigits_l), ch)) == NULL)",
          "",
          "[Removed Lines]",
          "228:   while ((ch = *src++) != '\\0') {",
          "",
          "[Added Lines]",
          "228:   while ((ch = *src++) != '\\0' && ch != '%') {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "256:       continue;",
          "257:     }",
          "258:     if (ch == '.' && ((tp + sizeof(struct in_addr)) <= endp)) {",
          "260:       if (err == 0) {",
          "261:         tp += sizeof(struct in_addr);",
          "262:         seen_xdigits = 0;",
          "",
          "[Removed Lines]",
          "259:       int err = inet_pton4(curtok, tp);",
          "",
          "[Added Lines]",
          "259:       int err;",
          "262:       pch = strchr(curtok, '%');",
          "263:       if (pch != NULL) {",
          "264:         char tmp[sizeof \"255.255.255.255\"];",
          "266:         memcpy(tmp, curtok, pch - curtok);",
          "267:         curtok = tmp;",
          "268:         src = pch;",
          "269:       }",
          "271:       err = inet_pton4(curtok, tp);",
          "",
          "---------------"
        ],
        "test/test-ip6-addr.c||test/test-ip6-addr.c": [
          "File: test/test-ip6-addr.c -> test/test-ip6-addr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "97:   RETURN_SKIP(\"Qualified link-local addresses are not supported.\");",
          "98: #endif",
          "99: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "102: #define GOOD_ADDR_LIST(X)                                                     \\",
          "103:     X(\"::\")                                                                   \\",
          "104:     X(\"::1\")                                                                  \\",
          "105:     X(\"fe80::1\")                                                              \\",
          "106:     X(\"fe80::\")                                                               \\",
          "107:     X(\"fe80::2acf:daff:fedd:342a\")                                            \\",
          "108:     X(\"fe80:0:0:0:2acf:daff:fedd:342a\")                                       \\",
          "109:     X(\"fe80:0:0:0:2acf:daff:1.2.3.4\")                                         \\",
          "111: #define BAD_ADDR_LIST(X)                                                      \\",
          "112:     X(\":::1\")                                                                 \\",
          "113:     X(\"abcde::1\")                                                             \\",
          "114:     X(\"fe80:0:0:0:2acf:daff:fedd:342a:5678\")                                  \\",
          "115:     X(\"fe80:0:0:0:2acf:daff:abcd:1.2.3.4\")                                    \\",
          "116:     X(\"fe80:0:0:2acf:daff:1.2.3.4.5\")                                         \\",
          "118: #define TEST_GOOD(ADDR)                                                       \\",
          "119:     ASSERT(0 == uv_inet_pton(AF_INET6, ADDR, &addr));                         \\",
          "120:     ASSERT(0 == uv_inet_pton(AF_INET6, ADDR \"%en1\", &addr));                  \\",
          "121:     ASSERT(0 == uv_inet_pton(AF_INET6, ADDR \"%%%%\", &addr));                  \\",
          "122:     ASSERT(0 == uv_inet_pton(AF_INET6, ADDR \"%en1:1.2.3.4\", &addr));          \\",
          "124: #define TEST_BAD(ADDR)                                                        \\",
          "125:     ASSERT(0 != uv_inet_pton(AF_INET6, ADDR, &addr));                         \\",
          "126:     ASSERT(0 != uv_inet_pton(AF_INET6, ADDR \"%en1\", &addr));                  \\",
          "127:     ASSERT(0 != uv_inet_pton(AF_INET6, ADDR \"%%%%\", &addr));                  \\",
          "128:     ASSERT(0 != uv_inet_pton(AF_INET6, ADDR \"%en1:1.2.3.4\", &addr));          \\",
          "130: TEST_IMPL(ip6_pton) {",
          "131:   struct in6_addr addr;",
          "133:   GOOD_ADDR_LIST(TEST_GOOD)",
          "134:   BAD_ADDR_LIST(TEST_BAD)",
          "136:   MAKE_VALGRIND_HAPPY();",
          "137:   return 0;",
          "138: }",
          "140: #undef GOOD_ADDR_LIST",
          "141: #undef BAD_ADDR_LIST",
          "",
          "---------------"
        ],
        "test/test-list.h||test/test-list.h": [
          "File: test/test-list.h -> test/test-list.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "41: TEST_DECLARE   (semaphore_3)",
          "42: TEST_DECLARE   (tty)",
          "43: TEST_DECLARE   (stdio_over_pipes)",
          "44: TEST_DECLARE   (ipc_listen_before_write)",
          "45: TEST_DECLARE   (ipc_listen_after_write)",
          "46: #ifndef _WIN32",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "44: TEST_DECLARE   (ip6_pton)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "295:   TEST_ENTRY  (pipe_server_close)",
          "296:   TEST_ENTRY  (tty)",
          "297:   TEST_ENTRY  (stdio_over_pipes)",
          "298:   TEST_ENTRY  (ipc_listen_before_write)",
          "299:   TEST_ENTRY  (ipc_listen_after_write)",
          "300: #ifndef _WIN32",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "299:   TEST_ENTRY  (ip6_pton)",
          "",
          "---------------"
        ],
        "uv.gyp||uv.gyp": [
          "File: uv.gyp -> uv.gyp",
          "--- Hunk 1 ---",
          "[Context before]",
          "321:         'test/test-getsockname.c',",
          "322:         'test/test-hrtime.c',",
          "323:         'test/test-idle.c',",
          "324:         'test/test-ipc.c',",
          "325:         'test/test-ipc-send-recv.c',",
          "326:         'test/test-list.h',",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "324:         'test/test-ip6-addr.c',",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "6ced8c2cc76b7951d25cf1a7c376b18750ffbab7",
      "candidate_info": {
        "commit_hash": "6ced8c2cc76b7951d25cf1a7c376b18750ffbab7",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/6ced8c2cc76b7951d25cf1a7c376b18750ffbab7",
        "files": [
          "include/uv-win.h",
          "src/win/core.c",
          "src/win/internal.h",
          "src/win/timer.c",
          "src/win/util.c"
        ],
        "message": "windows: improve timer precision\n\nImprove timing precision by using QueryPerformanceCounter.\n\nThis is part of the fix for Node.js' test-timers-first-fire.js.",
        "before_after_code_files": [
          "include/uv-win.h||include/uv-win.h",
          "src/win/core.c||src/win/core.c",
          "src/win/internal.h||src/win/internal.h",
          "src/win/timer.c||src/win/timer.c",
          "src/win/util.c||src/win/util.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "include/uv-win.h||include/uv-win.h": [
          "File: include/uv-win.h -> include/uv-win.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "316:   HANDLE iocp;                                                                \\",
          "318:   uint64_t time;                                                              \\",
          "",
          "[Removed Lines]",
          "320:   DWORD last_tick_count;                                                      \\",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/win/core.c||src/win/core.c": [
          "File: src/win/core.c -> src/win/core.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "139:   loop->time = 0;",
          "141:   uv_update_time(loop);",
          "143:   QUEUE_INIT(&loop->wq);",
          "",
          "[Removed Lines]",
          "140:   loop->last_tick_count = 0;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "315:     req = uv_overlapped_to_req(overlapped);",
          "316:     uv_insert_pending_req(loop, req);",
          "317:   } else if (GetLastError() != WAIT_TIMEOUT) {",
          "319:     uv_fatal_error(GetLastError(), \"GetQueuedCompletionStatus\");",
          "325:     uv__time_forward(loop, timeout);",
          "326:   }",
          "",
          "[Removed Lines]",
          "320:   } else {",
          "",
          "[Added Lines]",
          "320:     uv_update_time(loop);",
          "324:   } else if (timeout > 0) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "347:       req = uv_overlapped_to_req(overlappeds[i].lpOverlapped);",
          "348:       uv_insert_pending_req(loop, req);",
          "349:     }",
          "350:   } else if (GetLastError() != WAIT_TIMEOUT) {",
          "352:     uv_fatal_error(GetLastError(), \"GetQueuedCompletionStatusEx\");",
          "353:   } else if (timeout > 0) {",
          "358:     uv__time_forward(loop, timeout);",
          "359:   }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "357:     uv_update_time(loop);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "416:       uv_process_timers(loop);",
          "417:     }",
          "",
          "[Removed Lines]",
          "415:       uv_update_time(loop);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/win/internal.h||src/win/internal.h": [
          "File: src/win/internal.h -> src/win/internal.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "323: void uv__util_init();",
          "325: int uv_parent_pid();",
          "326: __declspec(noreturn) void uv_fatal_error(const int errorno, const char* syscall);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "325: uint64_t uv__hrtime(double scale);",
          "",
          "---------------"
        ],
        "src/win/timer.c||src/win/timer.c": [
          "File: src/win/timer.c -> src/win/timer.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "28: #include \"handle-inl.h\"",
          "61: }",
          "64: void uv__time_forward(uv_loop_t* loop, uint64_t msecs) {",
          "65:   loop->time += msecs;",
          "66: }",
          "",
          "[Removed Lines]",
          "31: void uv_update_time(uv_loop_t* loop) {",
          "32:   DWORD ticks;",
          "33:   ULARGE_INTEGER time;",
          "35:   ticks = GetTickCount();",
          "37:   time.QuadPart = loop->time;",
          "44:   time.LowPart = ticks;",
          "45:   if (ticks < loop->last_tick_count)",
          "46:     time.HighPart++;",
          "49:   loop->last_tick_count = ticks;",
          "59:   if (loop->time < time.QuadPart)",
          "60:     loop->time = time.QuadPart;",
          "",
          "[Added Lines]",
          "32: #define UV__MILLISEC 1000",
          "35: void uv_update_time(uv_loop_t* loop) {",
          "36:   uint64_t new_time = uv__hrtime(UV__MILLISEC);",
          "37:   if (new_time > loop->time) {",
          "38:     loop->time = new_time;",
          "39:   }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "191:   timer = RB_MIN(uv_timer_tree_s, &((uv_loop_t*)loop)->timers);",
          "192:   if (timer) {",
          "193:     delta = timer->due - loop->time;",
          "204:     } else if (delta < 0) {",
          "206:       return 0;",
          "",
          "[Removed Lines]",
          "194:     if (delta >= UINT_MAX >> 1) {",
          "203:       return UINT_MAX >> 1;",
          "",
          "[Added Lines]",
          "172:     if (delta >= UINT_MAX - 1) {",
          "174:       return UINT_MAX - 1;",
          "",
          "---------------"
        ],
        "src/win/util.c||src/win/util.c": [
          "File: src/win/util.c -> src/win/util.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "52: #define MAX_TITLE_LENGTH 8192",
          "60: static char *process_title;",
          "61: static CRITICAL_SECTION process_title_lock;",
          "",
          "[Removed Lines]",
          "55: #undef NANOSEC",
          "56: #define NANOSEC 1000000000",
          "64: static double hrtime_frequency_ = 0;",
          "",
          "[Added Lines]",
          "55: #define UV__NANOSEC 1000000000",
          "63: static double hrtime_interval_ = 0;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "74:   InitializeCriticalSection(&process_title_lock);",
          "81: }",
          "",
          "[Removed Lines]",
          "77:   if (QueryPerformanceFrequency(&perf_frequency))",
          "78:     hrtime_frequency_ = (double) perf_frequency.QuadPart / (double) NANOSEC;",
          "79:   else",
          "80:     hrtime_frequency_= 0;",
          "",
          "[Added Lines]",
          "78:   if (QueryPerformanceFrequency(&perf_frequency)) {",
          "79:     hrtime_interval_ = 1.0 / perf_frequency.QuadPart;",
          "80:   } else {",
          "81:     hrtime_interval_= 0;",
          "82:   }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "465: uint64_t uv_hrtime(void) {",
          "468:   uv__once_init();",
          "473:     return 0;",
          "474:   }",
          "476:   if (!QueryPerformanceCounter(&counter)) {",
          "478:     return 0;",
          "479:   }",
          "486: }",
          "",
          "[Removed Lines]",
          "466:   LARGE_INTEGER counter;",
          "471:   if (hrtime_frequency_ == 0) {",
          "485:   return (uint64_t) ((double) counter.QuadPart / hrtime_frequency_);",
          "",
          "[Added Lines]",
          "469:   return uv__hrtime(UV__NANOSEC);",
          "470: }",
          "472: uint64_t uv__hrtime(double scale) {",
          "473:   LARGE_INTEGER counter;",
          "476:   if (hrtime_interval_ == 0) {",
          "488:   return (uint64_t) ((double) counter.QuadPart * hrtime_interval_ * scale);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "02e1ebd40b807be5af46343ea873331b2ee4e9c1",
      "candidate_info": {
        "commit_hash": "02e1ebd40b807be5af46343ea873331b2ee4e9c1",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/02e1ebd40b807be5af46343ea873331b2ee4e9c1",
        "files": [
          "include/uv-errno.h"
        ],
        "message": "include: remove unneeded EADDRINFO errno\n\nEADDRINFO is not a readl errno, it was used to signal any error that\ngetaddrinfo would return, but we return actual errors now.",
        "before_after_code_files": [
          "include/uv-errno.h||include/uv-errno.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "include/uv-errno.h||include/uv-errno.h": [
          "File: include/uv-errno.h -> include/uv-errno.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "57: # define UV__EACCES (-4092)",
          "58: #endif",
          "66: #if defined(EADDRINUSE) && !defined(_WIN32)",
          "67: # define UV__EADDRINUSE (-EADDRINUSE)",
          "68: #else",
          "",
          "[Removed Lines]",
          "60: #if defined(EADDRINFO) && !defined(_WIN32)",
          "61: # define UV__EADDRINFO EADDRINFO",
          "62: #else",
          "63: # define UV__EADDRINFO (-4091)",
          "64: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "cd2794c01fc84a4118f79e31071cb1bca78918f5",
      "candidate_info": {
        "commit_hash": "cd2794c01fc84a4118f79e31071cb1bca78918f5",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/cd2794c01fc84a4118f79e31071cb1bca78918f5",
        "files": [
          "include/uv-darwin.h",
          "src/unix/darwin.c",
          "src/unix/fsevents.c",
          "src/unix/kqueue.c"
        ],
        "message": "fsevents: use shared FSEventStream\n\nIt seems that number of simultaneously opened FSEventStreams is\nlimited on OSX (i.e. you can have only fixed number of them on\none running system), getting past through this limit will cause\n`FSEventStreamCreate` to return false and write following message\nto stderr:\n\n    (CarbonCore.framework) FSEventStreamStart: register_with_server:\n    ERROR: f2d_register_rpc() => (null) (-21)\n\nTo prevent this, we must use only one shared FSEventStream with a\npaths for all uv_fsevent_t handles, and then filter out events for\neach handle using this paths again.\n\nSee https://github.com/joyent/node/issues/5463",
        "before_after_code_files": [
          "include/uv-darwin.h||include/uv-darwin.h",
          "src/unix/darwin.c||src/unix/darwin.c",
          "src/unix/fsevents.c||src/unix/fsevents.c",
          "src/unix/kqueue.c||src/unix/kqueue.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "include/uv-darwin.h||include/uv-darwin.h": [
          "File: include/uv-darwin.h -> include/uv-darwin.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "37: #define UV_PLATFORM_LOOP_FIELDS                                               \\",
          "38:   uv_thread_t cf_thread;                                                      \\",
          "41:   uv_mutex_t cf_mutex;                                                        \\",
          "42:   uv_sem_t cf_sem;                                                            \\",
          "43:   void* cf_signals[2];                                                        \\",
          "",
          "[Removed Lines]",
          "39:   void* cf_cb;                                                                \\",
          "40:   void* cf_loop;                                                              \\",
          "",
          "[Added Lines]",
          "39:   void* _cf_reserved;                                                         \\",
          "40:   void* cf_state;                                                             \\",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "47:   char* realpath;                                                             \\",
          "48:   int realpath_len;                                                           \\",
          "49:   int cf_flags;                                                               \\",
          "51:   uv_async_t* cf_cb;                                                          \\",
          "54:   uv_mutex_t cf_mutex;                                                        \\",
          "56: #define UV_STREAM_PRIVATE_PLATFORM_FIELDS                                     \\",
          "",
          "[Removed Lines]",
          "50:   void* cf_eventstream;                                                       \\",
          "52:   void* cf_events[2];                                                         \\",
          "53:   uv_sem_t cf_sem;                                                            \\",
          "",
          "[Added Lines]",
          "50:   void* cf_event;                                                             \\",
          "52:   void* cf_member[2];                                                         \\",
          "53:   uv_sem_t _cf_reserved;                                                      \\",
          "",
          "---------------"
        ],
        "src/unix/darwin.c||src/unix/darwin.c": [
          "File: src/unix/darwin.c -> src/unix/darwin.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "40: int uv__platform_loop_init(uv_loop_t* loop, int default_loop) {",
          "43:   if (uv__kqueue_init(loop))",
          "44:     return -errno;",
          "",
          "[Removed Lines]",
          "41:   loop->cf_loop = NULL;",
          "",
          "[Added Lines]",
          "41:   loop->cf_state = NULL;",
          "",
          "---------------"
        ],
        "src/unix/fsevents.c||src/unix/fsevents.c": [
          "File: src/unix/fsevents.c -> src/unix/fsevents.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "50: typedef struct uv__fsevents_event_s uv__fsevents_event_t;",
          "51: typedef struct uv__cf_loop_signal_s uv__cf_loop_signal_t;",
          "54: struct uv__cf_loop_signal_s {",
          "56:   QUEUE member;",
          "58: };",
          "60: struct uv__fsevents_event_s {",
          "61:   int events;",
          "63:   char path[1];",
          "64: };",
          "67: static void uv__cf_loop_cb(void* arg);",
          "68: static void* uv__cf_loop_runner(void* arg);",
          "77:       uv__fsevents_event_t* event;                                            \\",
          "78:       uv_mutex_lock(&(handle)->cf_mutex);                                     \\",
          "84:       uv_mutex_unlock(&(handle)->cf_mutex);                                   \\",
          "92:           block                                                               \\",
          "94:         free(event);                                                          \\",
          "95:       }                                                                       \\",
          "99: static void uv__fsevents_cb(uv_async_t* cb, int status) {",
          "100:   uv_fs_event_t* handle;",
          "102:   handle = cb->data;",
          "105:     if (handle->event_watcher.fd != -1)",
          "106:       handle->cb(handle, event->path[0] ? event->path : NULL, event->events, 0);",
          "107:   });",
          "111:     uv__fsevents_close(handle);",
          "113: }",
          "116: static void uv__fsevents_event_cb(ConstFSEventStreamRef streamRef,",
          "117:                                   void* info,",
          "118:                                   size_t numEvents,",
          "",
          "[Removed Lines]",
          "52: typedef void (*cf_loop_signal_cb)(void* arg);",
          "55:   cf_loop_signal_cb cb;",
          "57:   void* arg;",
          "62:   QUEUE member;",
          "69: static void uv__cf_loop_signal(uv_loop_t* loop,",
          "70:                                cf_loop_signal_cb cb,",
          "71:                                void* arg);",
          "73: #define UV__FSEVENTS_WALK(handle, block)                                      \\",
          "74:     {                                                                         \\",
          "75:       QUEUE* curr;                                                            \\",
          "76:       QUEUE split_head;                                                       \\",
          "79:       QUEUE_INIT(&split_head);                                                \\",
          "80:       if (!QUEUE_EMPTY(&(handle)->cf_events)) {                               \\",
          "81:         QUEUE* split_pos = QUEUE_HEAD(&(handle)->cf_events);                  \\",
          "82:         QUEUE_SPLIT(&(handle)->cf_events, split_pos, &split_head);            \\",
          "83:       }                                                                       \\",
          "85:       while (!QUEUE_EMPTY(&split_head)) {                                     \\",
          "86:         curr = QUEUE_HEAD(&split_head);                                       \\",
          "88:         event = QUEUE_DATA(curr, uv__fsevents_event_t, member);               \\",
          "89:         QUEUE_REMOVE(curr);                                                   \\",
          "91:         if (((handle)->flags & (UV_CLOSING | UV_CLOSED)) == 0)                \\",
          "96:     }",
          "104:   UV__FSEVENTS_WALK(handle, {",
          "109:   if ((handle->flags & (UV_CLOSING | UV_CLOSED)) == 0 &&",
          "110:       handle->event_watcher.fd == -1) {",
          "112:   }",
          "",
          "[Added Lines]",
          "52: typedef struct uv__cf_loop_state_s uv__cf_loop_state_t;",
          "54: struct uv__cf_loop_state_s {",
          "55:   CFRunLoopRef loop;",
          "56:   CFRunLoopSourceRef signal_source;",
          "57:   volatile int fsevent_need_reschedule;",
          "58:   FSEventStreamRef fsevent_stream;",
          "59:   uv_sem_t fsevent_sem;",
          "60:   uv_mutex_t fsevent_mutex;",
          "61:   void* fsevent_handles[2];",
          "62:   int fsevent_handle_count;",
          "63: };",
          "67:   uv_fs_event_t* handle;",
          "72:   void* next;",
          "76: static const int kFSEventsModified = kFSEventStreamEventFlagItemFinderInfoMod |",
          "77:                                      kFSEventStreamEventFlagItemModified |",
          "78:                                      kFSEventStreamEventFlagItemInodeMetaMod |",
          "79:                                      kFSEventStreamEventFlagItemChangeOwner |",
          "80:                                      kFSEventStreamEventFlagItemXattrMod;",
          "81: static const int kFSEventsRenamed = kFSEventStreamEventFlagItemCreated |",
          "82:                                     kFSEventStreamEventFlagItemRemoved |",
          "83:                                     kFSEventStreamEventFlagItemRenamed;",
          "84: static const int kFSEventsSystem = kFSEventStreamEventFlagUserDropped |",
          "85:                                    kFSEventStreamEventFlagKernelDropped |",
          "86:                                    kFSEventStreamEventFlagEventIdsWrapped |",
          "87:                                    kFSEventStreamEventFlagHistoryDone |",
          "88:                                    kFSEventStreamEventFlagMount |",
          "89:                                    kFSEventStreamEventFlagUnmount |",
          "90:                                    kFSEventStreamEventFlagRootChanged;",
          "95: static int uv__cf_loop_signal(uv_loop_t* loop, uv_fs_event_t* handle);",
          "97: #define UV__FSEVENTS_PROCESS(handle, block)                                   \\",
          "98:     do {                                                                      \\",
          "100:       uv__fsevents_event_t* next;                                             \\",
          "102:       event = (handle)->cf_event;                                             \\",
          "103:       (handle)->cf_event = NULL;                                              \\",
          "105:       while (event != NULL) {                                                 \\",
          "108:         if (!uv__is_closing((handle)))                                        \\",
          "111:         next = event->next;                                                   \\",
          "113:         event = next;                                                         \\",
          "115:     } while (0)",
          "124:   UV__FSEVENTS_PROCESS(handle, {",
          "129:   if (!uv__is_closing(handle) && handle->event_watcher.fd == -1)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "125:   char* path;",
          "126:   char* pos;",
          "127:   uv_fs_event_t* handle;",
          "128:   uv__fsevents_event_t* event;",
          "143:   paths = eventPaths;",
          "164:       path += handle->realpath_len;",
          "165:       len -= handle->realpath_len;",
          "",
          "[Removed Lines]",
          "129:   QUEUE add_list;",
          "130:   int kFSEventsModified;",
          "131:   int kFSEventsRenamed;",
          "133:   kFSEventsModified = kFSEventStreamEventFlagItemFinderInfoMod |",
          "134:                       kFSEventStreamEventFlagItemModified |",
          "135:                       kFSEventStreamEventFlagItemInodeMetaMod |",
          "136:                       kFSEventStreamEventFlagItemChangeOwner |",
          "137:                       kFSEventStreamEventFlagItemXattrMod;",
          "138:   kFSEventsRenamed = kFSEventStreamEventFlagItemCreated |",
          "139:                      kFSEventStreamEventFlagItemRemoved |",
          "140:                      kFSEventStreamEventFlagItemRenamed;",
          "142:   handle = info;",
          "144:   QUEUE_INIT(&add_list);",
          "146:   for (i = 0; i < numEvents; i++) {",
          "148:     if (eventFlags[i] & (kFSEventStreamEventFlagUserDropped |",
          "149:                          kFSEventStreamEventFlagKernelDropped |",
          "150:                          kFSEventStreamEventFlagEventIdsWrapped |",
          "151:                          kFSEventStreamEventFlagHistoryDone |",
          "152:                          kFSEventStreamEventFlagMount |",
          "153:                          kFSEventStreamEventFlagUnmount |",
          "154:                          kFSEventStreamEventFlagRootChanged)) {",
          "155:       continue;",
          "156:     }",
          "159:     path = paths[i];",
          "160:     len = strlen(path);",
          "163:     if (strstr(path, handle->realpath) == path) {",
          "",
          "[Added Lines]",
          "147:   QUEUE* q;",
          "148:   uv_loop_t* loop;",
          "149:   uv__cf_loop_state_t* state;",
          "151:   uv__fsevents_event_t* tail;",
          "153:   loop = info;",
          "154:   state = loop->cf_state;",
          "155:   assert(state != NULL);",
          "159:   QUEUE_FOREACH(q, &state->fsevent_handles) {",
          "160:     handle = QUEUE_DATA(q, uv_fs_event_t, cf_member);",
          "161:     tail = NULL;",
          "164:     for (i = 0; i < numEvents; i++) {",
          "166:       if (eventFlags[i] & kFSEventsSystem)",
          "167:         continue;",
          "169:       path = paths[i];",
          "170:       len = strlen(path);",
          "173:       if (strncmp(path, handle->realpath, handle->realpath_len) != 0)",
          "174:         continue;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "169:         path++;",
          "170:         len--;",
          "171:       }",
          "174: #ifdef MAC_OS_X_VERSION_10_7",
          "187: #ifndef MAC_OS_X_VERSION_10_7",
          "211: }",
          "216:   FSEventStreamContext ctx;",
          "217:   FSEventStreamRef ref;",
          "220:   CFAbsoluteTime latency;",
          "221:   FSEventStreamCreateFlags flags;",
          "226:   ctx.version = 0;",
          "228:   ctx.retain = NULL;",
          "229:   ctx.release = NULL;",
          "230:   ctx.copyDescription = NULL;",
          "240:   latency = 0.15;",
          "243:   flags = kFSEventStreamCreateFlagFileEvents;",
          "245:   ref = FSEventStreamCreate(NULL,",
          "246:                             &uv__fsevents_event_cb,",
          "247:                             &ctx,",
          "",
          "[Removed Lines]",
          "172:     }",
          "176:     if (len == 0)",
          "177:       continue;",
          "181:     pos = strchr(path, '/');",
          "182:     if ((handle->cf_flags & UV_FS_EVENT_RECURSIVE) == 0 &&",
          "183:         pos != NULL &&",
          "184:         pos != path + 1)",
          "185:       continue;",
          "188:     path = \"\";",
          "189:     len = 0;",
          "192:     event = malloc(sizeof(*event) + len);",
          "193:     if (event == NULL)",
          "194:       break;",
          "196:     memcpy(event->path, path, len + 1);",
          "198:     if ((eventFlags[i] & kFSEventsModified) != 0 &&",
          "199:         (eventFlags[i] & kFSEventsRenamed) == 0)",
          "200:       event->events = UV_CHANGE;",
          "201:     else",
          "202:       event->events = UV_RENAME;",
          "204:     QUEUE_INSERT_TAIL(&add_list, &event->member);",
          "205:   }",
          "206:   uv_mutex_lock(&handle->cf_mutex);",
          "207:   QUEUE_ADD(&handle->cf_events, &add_list);",
          "208:   uv_mutex_unlock(&handle->cf_mutex);",
          "210:   uv_async_send(handle->cf_cb);",
          "214: static void uv__fsevents_schedule(void* arg) {",
          "215:   uv_fs_event_t* handle;",
          "218:   CFStringRef path;",
          "219:   CFArrayRef paths;",
          "223:   handle = arg;",
          "227:   ctx.info = handle;",
          "233:   path = CFStringCreateWithCString(NULL,",
          "234:                                    handle->filename,",
          "235:                                    CFStringGetSystemEncoding());",
          "236:   assert(path != NULL);",
          "237:   paths = CFArrayCreate(NULL, (const void**)&path, 1, NULL);",
          "238:   assert(paths != NULL);",
          "",
          "[Added Lines]",
          "187:       if (len == 0)",
          "188:         continue;",
          "192:       if ((handle->cf_flags & UV_FS_EVENT_RECURSIVE) == 0) {",
          "193:         pos = strchr(path, '/');",
          "194:         if (pos != NULL && pos != path + 1)",
          "195:           continue;",
          "196:       }",
          "199:       path = \"\";",
          "200:       len = 0;",
          "203:       event = malloc(sizeof(*event) + len);",
          "204:       if (event == NULL)",
          "205:         break;",
          "207:       memset(event, 0, sizeof(*event));",
          "208:       memcpy(event->path, path, len + 1);",
          "210:       if ((eventFlags[i] & kFSEventsModified) != 0 &&",
          "211:           (eventFlags[i] & kFSEventsRenamed) == 0)",
          "212:         event->events = UV_CHANGE;",
          "213:       else",
          "214:         event->events = UV_RENAME;",
          "216:       if (tail != NULL)",
          "217:         tail->next = event;",
          "218:       tail = event;",
          "219:     }",
          "221:     if (tail != NULL) {",
          "222:       uv_mutex_lock(&handle->cf_mutex);",
          "223:       tail->next = handle->cf_event;",
          "224:       handle->cf_event = tail;",
          "225:       uv_mutex_unlock(&handle->cf_mutex);",
          "227:       uv_async_send(handle->cf_cb);",
          "228:     }",
          "229:   }",
          "234: static void uv__fsevents_create_stream(uv_loop_t* loop, CFArrayRef paths) {",
          "235:   uv__cf_loop_state_t* state;",
          "243:   ctx.info = loop;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "250:                             latency,",
          "251:                             flags);",
          "252:   assert(ref != NULL);",
          "257:                                    kCFRunLoopDefaultMode);",
          "259:     abort();",
          "260: }",
          "278: }",
          "281: static int uv__fsevents_loop_init(uv_loop_t* loop) {",
          "282:   CFRunLoopSourceContext ctx;",
          "283:   pthread_attr_t attr_storage;",
          "284:   pthread_attr_t* attr;",
          "285:   int err;",
          "288:     return 0;",
          "290:   err = uv_mutex_init(&loop->cf_mutex);",
          "291:   if (err)",
          "292:     return err;",
          "",
          "[Removed Lines]",
          "253:   handle->cf_eventstream = ref;",
          "255:   FSEventStreamScheduleWithRunLoop(handle->cf_eventstream,",
          "256:                                    handle->loop->cf_loop,",
          "258:   if (!FSEventStreamStart(handle->cf_eventstream))",
          "263: static void uv__fsevents_unschedule(void* arg) {",
          "264:   uv_fs_event_t* handle;",
          "266:   handle = arg;",
          "269:   FSEventStreamStop(handle->cf_eventstream);",
          "272:   FSEventStreamInvalidate(handle->cf_eventstream);",
          "273:   FSEventStreamRelease(handle->cf_eventstream);",
          "274:   handle->cf_eventstream = NULL;",
          "277:   uv_sem_post(&handle->cf_sem);",
          "287:   if (loop->cf_loop != NULL)",
          "",
          "[Added Lines]",
          "268:   state = loop->cf_state;",
          "269:   FSEventStreamScheduleWithRunLoop(ref,",
          "270:                                    state->loop,",
          "272:   if (!FSEventStreamStart(ref))",
          "275:   state->fsevent_stream = ref;",
          "280: static void uv__fsevents_destroy_stream(uv_loop_t* loop) {",
          "281:   uv__cf_loop_state_t* state;",
          "283:   state = loop->cf_state;",
          "285:   if (state->fsevent_stream == NULL)",
          "286:     return;",
          "289:   FSEventStreamFlushSync(state->fsevent_stream);",
          "292:   FSEventStreamStop(state->fsevent_stream);",
          "295:   FSEventStreamInvalidate(state->fsevent_stream);",
          "296:   FSEventStreamRelease(state->fsevent_stream);",
          "297:   state->fsevent_stream = NULL;",
          "298: }",
          "302: static void uv__fsevents_reschedule(uv_fs_event_t* handle) {",
          "303:   uv__cf_loop_state_t* state;",
          "304:   QUEUE* q;",
          "305:   uv_fs_event_t* curr;",
          "306:   CFArrayRef cf_paths;",
          "307:   CFStringRef* paths;",
          "308:   int i;",
          "309:   int path_count;",
          "311:   state = handle->loop->cf_state;",
          "316:   if (!state->fsevent_need_reschedule)",
          "317:     return;",
          "318:   state->fsevent_need_reschedule = 0;",
          "321:   uv__fsevents_destroy_stream(handle->loop);",
          "324:   uv_mutex_lock(&state->fsevent_mutex);",
          "325:   path_count = state->fsevent_handle_count;",
          "326:   if (path_count != 0) {",
          "327:     paths = malloc(sizeof(*paths) * path_count);",
          "328:     if (paths == NULL)",
          "329:       abort();",
          "331:     q = &state->fsevent_handles;",
          "332:     for (i = 0; i < path_count; i++) {",
          "333:       q = QUEUE_NEXT(q);",
          "334:       assert(q != &state->fsevent_handles);",
          "335:       curr = QUEUE_DATA(q, uv_fs_event_t, cf_member);",
          "337:       assert(curr->realpath != NULL);",
          "338:       paths[i] = CFStringCreateWithCString(NULL,",
          "339:                                            curr->realpath,",
          "340:                                            CFStringGetSystemEncoding());",
          "341:       if (paths[i] == NULL)",
          "342:         abort();",
          "343:     }",
          "344:   }",
          "345:   uv_mutex_unlock(&state->fsevent_mutex);",
          "347:   if (path_count != 0) {",
          "349:     cf_paths = CFArrayCreate(NULL, (const void**) paths, path_count, NULL);",
          "350:     if (cf_paths == NULL)",
          "351:       abort();",
          "352:     uv__fsevents_create_stream(handle->loop, cf_paths);",
          "353:   }",
          "361:   if (uv__is_closing(handle))",
          "362:     uv_sem_post(&state->fsevent_sem);",
          "369:   uv__cf_loop_state_t* state;",
          "374:   if (loop->cf_state != NULL)",
          "377:   state = calloc(1, sizeof(*state));",
          "378:   if (state == NULL)",
          "379:     return -ENOMEM;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "296:     goto fail_sem_init;",
          "298:   QUEUE_INIT(&loop->cf_signals);",
          "299:   memset(&ctx, 0, sizeof(ctx));",
          "300:   ctx.info = loop;",
          "301:   ctx.perform = uv__cf_loop_cb;",
          "",
          "[Removed Lines]",
          "302:   loop->cf_cb = CFRunLoopSourceCreate(NULL, 0, &ctx);",
          "",
          "[Added Lines]",
          "391:   err = uv_sem_init(&state->fsevent_sem, 0);",
          "392:   if (err)",
          "393:     goto fail_fsevent_sem_init;",
          "395:   err = uv_mutex_init(&state->fsevent_mutex);",
          "396:   if (err)",
          "397:     goto fail_fsevent_mutex_init;",
          "399:   QUEUE_INIT(&state->fsevent_handles);",
          "400:   state->fsevent_need_reschedule = 0;",
          "401:   state->fsevent_handle_count = 0;",
          "406:   state->signal_source = CFRunLoopSourceCreate(NULL, 0, &ctx);",
          "407:   if (state->signal_source == NULL) {",
          "408:     err = -ENOMEM;",
          "409:     goto fail_signal_source_create;",
          "410:   }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "313:     if (pthread_attr_setstacksize(attr, 3 * PTHREAD_STACK_MIN))",
          "314:       abort();",
          "317:   err = -pthread_create(&loop->cf_thread, attr, uv__cf_loop_runner, loop);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "424:   loop->cf_state = state;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "326:   uv_sem_wait(&loop->cf_sem);",
          "328:   return 0;",
          "330: fail_thread_create:",
          "331:   uv_sem_destroy(&loop->cf_sem);",
          "333: fail_sem_init:",
          "334:   uv_mutex_destroy(&loop->cf_mutex);",
          "335:   return err;",
          "336: }",
          "339: void uv__fsevents_loop_delete(uv_loop_t* loop) {",
          "340:   uv__cf_loop_signal_t* s;",
          "341:   QUEUE* q;",
          "344:     return;",
          "347:   uv_thread_join(&loop->cf_thread);",
          "348:   uv_sem_destroy(&loop->cf_sem);",
          "349:   uv_mutex_destroy(&loop->cf_mutex);",
          "",
          "[Removed Lines]",
          "327:   assert(loop->cf_loop != NULL);",
          "343:   if (loop->cf_loop == NULL)",
          "346:   uv__cf_loop_signal(loop, NULL, NULL);",
          "",
          "[Added Lines]",
          "440:   loop->cf_state = NULL;",
          "442: fail_signal_source_create:",
          "443:   uv_mutex_destroy(&state->fsevent_mutex);",
          "445: fail_fsevent_mutex_init:",
          "446:   uv_sem_destroy(&state->fsevent_sem);",
          "448: fail_fsevent_sem_init:",
          "453:   free(state);",
          "461:   uv__cf_loop_state_t* state;",
          "464:   if (loop->cf_state == NULL)",
          "467:   if (uv__cf_loop_signal(loop, NULL) != 0)",
          "468:     abort();",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "355:     QUEUE_REMOVE(q);",
          "356:     free(s);",
          "357:   }",
          "358: }",
          "361: static void* uv__cf_loop_runner(void* arg) {",
          "362:   uv_loop_t* loop;",
          "364:   loop = arg;",
          "369:                      kCFRunLoopDefaultMode);",
          "371:   uv_sem_post(&loop->cf_sem);",
          "373:   CFRunLoopRun();",
          "376:                         kCFRunLoopDefaultMode);",
          "378:   return NULL;",
          "379: }",
          "382: static void uv__cf_loop_cb(void* arg) {",
          "383:   uv_loop_t* loop;",
          "384:   QUEUE* item;",
          "385:   QUEUE split_head;",
          "386:   uv__cf_loop_signal_t* s;",
          "388:   loop = arg;",
          "390:   uv_mutex_lock(&loop->cf_mutex);",
          "392:   if (!QUEUE_EMPTY(&loop->cf_signals)) {",
          "393:     QUEUE* split_pos = QUEUE_HEAD(&loop->cf_signals);",
          "394:     QUEUE_SPLIT(&loop->cf_signals, split_pos, &split_head);",
          "",
          "[Removed Lines]",
          "365:   loop->cf_loop = CFRunLoopGetCurrent();",
          "367:   CFRunLoopAddSource(loop->cf_loop,",
          "368:                      loop->cf_cb,",
          "374:   CFRunLoopRemoveSource(loop->cf_loop,",
          "375:                         loop->cf_cb,",
          "391:   QUEUE_INIT(&split_head);",
          "",
          "[Added Lines]",
          "483:   state = loop->cf_state;",
          "484:   uv_sem_destroy(&state->fsevent_sem);",
          "485:   uv_mutex_destroy(&state->fsevent_mutex);",
          "486:   CFRelease(state->signal_source);",
          "487:   free(state);",
          "488:   loop->cf_state = NULL;",
          "495:   uv__cf_loop_state_t* state;",
          "498:   state = loop->cf_state;",
          "499:   state->loop = CFRunLoopGetCurrent();",
          "501:   CFRunLoopAddSource(state->loop,",
          "502:                      state->signal_source,",
          "508:   CFRunLoopRemoveSource(state->loop,",
          "509:                         state->signal_source,",
          "519:   uv__cf_loop_state_t* state;",
          "525:   state = loop->cf_state;",
          "526:   QUEUE_INIT(&split_head);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "401:     s = QUEUE_DATA(item, uv__cf_loop_signal_t, member);",
          "406:     else",
          "409:     QUEUE_REMOVE(item);",
          "410:     free(s);",
          "",
          "[Removed Lines]",
          "404:     if (s->cb == NULL)",
          "405:       CFRunLoopStop(loop->cf_loop);",
          "407:       s->cb(s->arg);",
          "",
          "[Added Lines]",
          "541:     if (s->handle == NULL)",
          "542:       CFRunLoopStop(state->loop);",
          "544:       uv__fsevents_reschedule(s->handle);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "412: }",
          "416:   uv__cf_loop_signal_t* item;",
          "418:   item = malloc(sizeof(*item));",
          "420:   if (item == NULL)",
          "426:   uv_mutex_lock(&loop->cf_mutex);",
          "427:   QUEUE_INSERT_TAIL(&loop->cf_signals, &item->member);",
          "428:   uv_mutex_unlock(&loop->cf_mutex);",
          "433: }",
          "436: int uv__fsevents_init(uv_fs_event_t* handle) {",
          "437:   int err;",
          "439:   err = uv__fsevents_loop_init(handle->loop);",
          "440:   if (err)",
          "",
          "[Removed Lines]",
          "415: void uv__cf_loop_signal(uv_loop_t* loop, cf_loop_signal_cb cb, void* arg) {",
          "421:     abort();",
          "423:   item->arg = arg;",
          "424:   item->cb = cb;",
          "430:   assert(loop->cf_loop != NULL);",
          "431:   CFRunLoopSourceSignal(loop->cf_cb);",
          "432:   CFRunLoopWakeUp(loop->cf_loop);",
          "",
          "[Added Lines]",
          "553: int uv__cf_loop_signal(uv_loop_t* loop, uv_fs_event_t* handle) {",
          "555:   uv__cf_loop_state_t* state;",
          "559:     return -ENOMEM;",
          "561:   item->handle = handle;",
          "567:   state = loop->cf_state;",
          "568:   assert(state != NULL);",
          "569:   CFRunLoopSourceSignal(state->signal_source);",
          "570:   CFRunLoopWakeUp(state->loop);",
          "572:   return 0;",
          "579:   uv__cf_loop_state_t* state;",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "444:   handle->realpath = realpath(handle->filename, NULL);",
          "453:   handle->cf_cb = malloc(sizeof(*handle->cf_cb));",
          "457:   handle->cf_cb->data = handle;",
          "458:   uv_async_init(handle->loop, handle->cf_cb, uv__fsevents_cb);",
          "459:   handle->cf_cb->flags |= UV__HANDLE_INTERNAL;",
          "460:   uv_unref((uv_handle_t*) handle->cf_cb);",
          "468:   return 0;",
          "469: }",
          "472: int uv__fsevents_close(uv_fs_event_t* handle) {",
          "473:   if (handle->cf_cb == NULL)",
          "474:     return -EINVAL;",
          "481:   uv_close((uv_handle_t*) handle->cf_cb, (uv_close_cb) free);",
          "482:   handle->cf_cb = NULL;",
          "489:   uv_mutex_destroy(&handle->cf_mutex);",
          "491:   free(handle->realpath);",
          "492:   handle->realpath = NULL;",
          "493:   handle->realpath_len = 0;",
          "",
          "[Removed Lines]",
          "445:   if (handle->realpath != NULL)",
          "446:     handle->realpath_len = strlen(handle->realpath);",
          "448:   handle->cf_eventstream = NULL;",
          "454:   if (handle->cf_cb == NULL)",
          "455:     return -ENOMEM;",
          "462:   uv_mutex_init(&handle->cf_mutex);",
          "463:   uv_sem_init(&handle->cf_sem, 0);",
          "464:   QUEUE_INIT(&handle->cf_events);",
          "466:   uv__cf_loop_signal(handle->loop, uv__fsevents_schedule, handle);",
          "476:   uv__cf_loop_signal(handle->loop, uv__fsevents_unschedule, handle);",
          "479:   uv_sem_wait(&handle->cf_sem);",
          "485:   UV__FSEVENTS_WALK(handle, {",
          "487:   })",
          "490:   uv_sem_destroy(&handle->cf_sem);",
          "",
          "[Added Lines]",
          "587:   if (handle->realpath == NULL)",
          "588:     return -errno;",
          "589:   handle->realpath_len = strlen(handle->realpath);",
          "592:   handle->cf_event = NULL;",
          "599:   if (handle->cf_cb == NULL) {",
          "600:     err = -ENOMEM;",
          "601:     goto fail_cf_cb_malloc;",
          "602:   }",
          "609:   err = uv_mutex_init(&handle->cf_mutex);",
          "610:   if (err)",
          "611:     goto fail_cf_mutex_init;",
          "614:   state = handle->loop->cf_state;",
          "615:   uv_mutex_lock(&state->fsevent_mutex);",
          "616:   QUEUE_INSERT_TAIL(&state->fsevent_handles, &handle->cf_member);",
          "617:   state->fsevent_handle_count++;",
          "618:   state->fsevent_need_reschedule = 1;",
          "619:   uv_mutex_unlock(&state->fsevent_mutex);",
          "622:   assert(handle != NULL);",
          "623:   err = uv__cf_loop_signal(handle->loop, handle);",
          "624:   if (err)",
          "625:     goto fail_loop_signal;",
          "629: fail_loop_signal:",
          "630:   uv_mutex_destroy(&handle->cf_mutex);",
          "632: fail_cf_mutex_init:",
          "633:   free(handle->cf_cb);",
          "634:   handle->cf_cb = NULL;",
          "636: fail_cf_cb_malloc:",
          "637:   free(handle->realpath);",
          "638:   handle->realpath = NULL;",
          "639:   handle->realpath_len = 0;",
          "641:   return err;",
          "647:   int err;",
          "648:   uv__cf_loop_state_t* state;",
          "654:   state = handle->loop->cf_state;",
          "655:   uv_mutex_lock(&state->fsevent_mutex);",
          "656:   QUEUE_REMOVE(&handle->cf_member);",
          "657:   state->fsevent_handle_count--;",
          "658:   state->fsevent_need_reschedule = 1;",
          "659:   uv_mutex_unlock(&state->fsevent_mutex);",
          "662:   assert(handle != NULL);",
          "663:   err = uv__cf_loop_signal(handle->loop, handle);",
          "664:   if (err)",
          "665:     return -err;",
          "668:   uv_sem_wait(&state->fsevent_sem);",
          "674:   UV__FSEVENTS_PROCESS(handle, {",
          "676:   });",
          "",
          "---------------"
        ],
        "src/unix/kqueue.c||src/unix/kqueue.c": [
          "File: src/unix/kqueue.c -> src/unix/kqueue.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "320: #if defined(__APPLE__)",
          "322:   handle->cf_cb = NULL;",
          "324:   handle->realpath = NULL;",
          "325:   handle->realpath_len = 0;",
          "326:   handle->cf_flags = flags;",
          "",
          "[Removed Lines]",
          "323:   handle->cf_eventstream = NULL;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "c6ecf97aafc858c2ad1089fb78da6c586d61d8b6",
      "candidate_info": {
        "commit_hash": "c6ecf97aafc858c2ad1089fb78da6c586d61d8b6",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/c6ecf97aafc858c2ad1089fb78da6c586d61d8b6",
        "files": [
          "src/win/fs.c"
        ],
        "message": "windows: use _snwprintf(), not swprintf()\n\nDrop the _CRT_NON_CONFORMING_SWPRINTFS hack and just use _snwprintf().\n\nIt's a long and complicated story but the gist of it is that the MS CRT\nhad a swprintf() function before ISO C did, with a different function\nprototype to boot: the ISO C one takes a |size| argument, the MS one\ndoes not.\n\nThe function prototype that's exported by mingw and mingw-w64 depends\non the mingw version and the _CRT_NON_CONFORMING_SWPRINTFS define.\nIf they don't match up, you get the wrong prototype and things will\ncrash at run-time.\n\nReduce the phase space by sidestepping the whole issue: drop swprintf()\naltogether and use _snwprintf() from now on.\n\nFixes #990.",
        "before_after_code_files": [
          "src/win/fs.c||src/win/fs.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/win/fs.c||src/win/fs.c": [
          "File: src/win/fs.c -> src/win/fs.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "738:     uv_fatal_error(ERROR_OUTOFMEMORY, \"malloc\");",
          "739:   }",
          "746:   dir = FindFirstFileW(path2, &ent);",
          "747:   free(path2);",
          "",
          "[Removed Lines]",
          "741: #ifdef _CRT_NON_CONFORMING_SWPRINTFS",
          "742:   swprintf(path2, fmt, pathw);",
          "743: #else",
          "744:   swprintf(path2, len + 3, fmt, pathw);",
          "745: #endif",
          "",
          "[Added Lines]",
          "741:   _snwprintf(path2, len + 3, fmt, pathw);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2015-8872",
  "cve_desc": "The set_fat function in fat.c in dosfstools before 4.0 might allow attackers to corrupt a FAT12 filesystem or cause a denial of service (invalid memory read and crash) by writing an odd number of clusters to the third to last entry on a FAT12 filesystem, which triggers an \"off-by-two error.\"",
  "repo": "dosfstools/dosfstools",
  "patch_hash": "07908124838afcc99c577d1d3e84cef2dbd39cb7",
  "patch_info": {
    "commit_hash": "07908124838afcc99c577d1d3e84cef2dbd39cb7",
    "repo": "dosfstools/dosfstools",
    "commit_url": "https://github.com/dosfstools/dosfstools/commit/07908124838afcc99c577d1d3e84cef2dbd39cb7",
    "files": [
      "src/fat.c"
    ],
    "message": "set_fat(): Fix off-by-2 error leading to corruption in FAT12\n\nIn FAT12 two 12 bit entries are combined to a 24 bit value (three\nbytes). Therefore, when an even numbered FAT entry is set in FAT12, it\nmust be be combined with the following entry. To prevent accessing\nbeyond the end of the FAT array, it must be checked that the cluster is\nnot the last one.\n\nPreviously, the check tested that the requested cluster was equal to\nfs->clusters - 1. However, fs->clusters is the number of data clusters\nnot including the two reserved FAT entries at the start so the test\ntriggered two clusters early.\n\nIf the third to last entry was written on a FAT12 filesystem with an\nodd number of clusters, the second to last entry would be corrupted.\nThis corruption may also lead to invalid memory accesses when the\ncorrupted entry becomes out of bounds and is used later.\n\nChange the test to fs->clusters + 1 to fix.\n\nReported-by: Hanno B\u00f6ck\nSigned-off-by: Andreas Bombe <aeb@debian.org>",
    "before_after_code_files": [
      "src/fat.c||src/fat.c"
    ]
  },
  "patch_diff": {
    "src/fat.c||src/fat.c": [
      "File: src/fat.c -> src/fat.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "205:      data[1] = new >> 4;",
      "206:  } else {",
      "207:      FAT_ENTRY subseqEntry;",
      "209:   get_fat(&subseqEntry, fs->fat, cluster + 1, fs);",
      "210:      else",
      "211:   subseqEntry.value = 0;",
      "",
      "[Removed Lines]",
      "208:      if (cluster != fs->clusters - 1)",
      "",
      "[Added Lines]",
      "208:      if (cluster != fs->clusters + 1)",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "bdc3d2a24b5ade769dfbaa00bf10538be1a90622",
      "candidate_info": {
        "commit_hash": "bdc3d2a24b5ade769dfbaa00bf10538be1a90622",
        "repo": "dosfstools/dosfstools",
        "commit_url": "https://github.com/dosfstools/dosfstools/commit/bdc3d2a24b5ade769dfbaa00bf10538be1a90622",
        "files": [
          "src/boot.c",
          "src/check.c",
          "src/fat.c",
          "src/fsck.fat.c",
          "src/fsck.fat.h"
        ],
        "message": "Rename clusters field in DOS_FS struct\n\nRename it to data_clusters to prevent mistaking the clusters field of\nthe DOS_FS struct as the total number of FAT entries instead of the\nnumber of data clusters (two less than the number of entries).\n\nSigned-off-by: Andreas Bombe <aeb@debian.org>",
        "before_after_code_files": [
          "src/boot.c||src/boot.c",
          "src/check.c||src/check.c",
          "src/fat.c||src/fat.c",
          "src/fsck.fat.c||src/fsck.fat.c",
          "src/fsck.fat.h||src/fsck.fat.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/fat.c||src/fat.c"
          ],
          "candidate": [
            "src/fat.c||src/fat.c"
          ]
        }
      },
      "candidate_diff": {
        "src/boot.c||src/boot.c": [
          "File: src/boot.c -> src/boot.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "115:     printf(\"Data area starts at byte %llu (sector %llu)\\n\",",
          "116:     (unsigned long long)fs->data_start,",
          "117:     (unsigned long long)fs->data_start / lss);",
          "120:     printf(\"%u sectors/track, %u heads\\n\", le16toh(b->secs_track),",
          "121:     le16toh(b->heads));",
          "122:     printf(\"%10u hidden sectors\\n\", atari_format ?",
          "",
          "[Removed Lines]",
          "118:     printf(\"%10lu data clusters (%llu bytes)\\n\", (unsigned long)fs->clusters,",
          "119:     (unsigned long long)fs->clusters * fs->cluster_size);",
          "",
          "[Added Lines]",
          "118:     printf(\"%10lu data clusters (%llu bytes)\\n\",",
          "119:     (unsigned long)fs->data_clusters,",
          "120:     (unsigned long long)fs->data_clusters * fs->cluster_size);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "364:        MSDOS_DIR_BITS,",
          "365:        logical_sector_size);",
          "366:     data_size = (loff_t) total_sectors *logical_sector_size - fs->data_start;",
          "",
          "[Removed Lines]",
          "367:     fs->clusters = data_size / fs->cluster_size;",
          "",
          "[Added Lines]",
          "368:     fs->data_clusters = data_size / fs->cluster_size;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "385:      printf(\"Warning: FAT32 root dir is in a cluster chain, but \"",
          "386:      \"a separate root dir\\n\"",
          "387:      \"  area is defined. Cannot fix this easily.\\n\");",
          "389:      printf(\"Warning: Filesystem is FAT32 according to fat_length \"",
          "390:      \"and fat32_length fields,\\n\"",
          "391:      \"  but has only %lu clusters, less than the required \"",
          "392:      \"minimum of %d.\\n\"",
          "393:      \"  This may lead to problems on some systems.\\n\",",
          "396:  check_fat_state_bit(fs, &b);",
          "397:  fs->backupboot_start = le16toh(b.backup_boot) * logical_sector_size;",
          "",
          "[Removed Lines]",
          "388:  if (fs->clusters < FAT16_THRESHOLD)",
          "394:      (unsigned long)fs->clusters, FAT16_THRESHOLD);",
          "",
          "[Added Lines]",
          "389:  if (fs->data_clusters < FAT16_THRESHOLD)",
          "395:      (unsigned long)fs->data_clusters, FAT16_THRESHOLD);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "401:     } else if (!atari_format) {",
          "407:  check_fat_state_bit(fs, &b);",
          "408:     } else {",
          "",
          "[Removed Lines]",
          "404:  fs->fat_bits = (fs->clusters >= FAT12_THRESHOLD) ? 16 : 12;",
          "405:  if (fs->clusters >= FAT16_THRESHOLD)",
          "406:      die(\"Too many clusters (%lu) for FAT16 filesystem.\", fs->clusters);",
          "",
          "[Added Lines]",
          "405:  fs->fat_bits = (fs->data_clusters >= FAT12_THRESHOLD) ? 16 : 12;",
          "406:  if (fs->data_clusters >= FAT16_THRESHOLD)",
          "407:      die(\"Too many clusters (%lu) for FAT16 filesystem.\", fs->data_clusters);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "416:      device_no == 2 ||",
          "",
          "[Removed Lines]",
          "414:  if (fs->clusters + 2 > fat_length * logical_sector_size * 8 / 16 ||",
          "",
          "[Added Lines]",
          "415:  if (fs->data_clusters + 2 > fat_length * logical_sector_size * 8 / 16 ||",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "439:      fs->label = NULL;",
          "440:     }",
          "443:  ((uint64_t)fs->fat_size * 8 / fs->fat_bits) - 2)",
          "444:  die(\"Filesystem has %d clusters but only space for %d FAT entries.\",",
          "446:      ((unsigned long long)fs->fat_size * 8 / fs->fat_bits) - 2);",
          "447:     if (!fs->root_entries && !fs->root_cluster)",
          "448:  die(\"Root directory has zero size.\");",
          "",
          "[Removed Lines]",
          "442:     if (fs->clusters >",
          "445:      fs->clusters,",
          "",
          "[Added Lines]",
          "443:     if (fs->data_clusters >",
          "446:      fs->data_clusters,",
          "",
          "---------------"
        ],
        "src/check.c||src/check.c": [
          "File: src/check.c -> src/check.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "111:      for (clu_num = prev + 1; clu_num != prev; clu_num++) {",
          "112:   FAT_ENTRY entry;",
          "115:       clu_num = 2;",
          "116:   get_fat(&entry, fs->fat, clu_num, fs);",
          "117:   if (!entry.value)",
          "",
          "[Removed Lines]",
          "114:   if (clu_num >= fs->clusters + 2)",
          "",
          "[Added Lines]",
          "114:   if (clu_num >= fs->data_clusters + 2)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "360:     if (file->lfn)",
          "361:  lfn_remove(file->lfn_offset, file->offset);",
          "362:     for (cluster = FSTART(file, fs); cluster > 0 && cluster <",
          "364:  set_owner(fs, cluster, NULL);",
          "365:     --n_files;",
          "366: }",
          "",
          "[Removed Lines]",
          "363:   fs->clusters + 2; cluster = next_cluster(fs, cluster))",
          "",
          "[Added Lines]",
          "363:   fs->data_clusters + 2; cluster = next_cluster(fs, cluster))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "556:      die(\"Bad FAT32 root directory! (bad start cluster 1)\\n\");",
          "557:  MODIFY_START(file, 0, fs);",
          "558:     }",
          "560:  printf",
          "561:      (\"%s\\n  Start cluster beyond limit (%lu > %lu). Truncating file.\\n\",",
          "563:  if (!file->offset)",
          "564:      die(\"Bad FAT32 root directory! (start cluster beyond limit: %lu > %lu)\\n\",",
          "566:  MODIFY_START(file, 0, fs);",
          "567:     }",
          "568:     clusters = prev = 0;",
          "",
          "[Removed Lines]",
          "559:     if (FSTART(file, fs) >= fs->clusters + 2) {",
          "562:       path_name(file), (unsigned long)FSTART(file, fs), (unsigned long)(fs->clusters + 1));",
          "565:   (unsigned long)FSTART(file, fs), (unsigned long)(fs->clusters + 1));",
          "",
          "[Added Lines]",
          "559:     if (FSTART(file, fs) >= fs->data_clusters + 2) {",
          "562:       path_name(file), (unsigned long)FSTART(file, fs),",
          "563:       (unsigned long)(fs->data_clusters + 1));",
          "566:   (unsigned long)FSTART(file, fs),",
          "567:   (unsigned long)(fs->data_clusters + 1));",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "848:     uint32_t walk, prev, clusters, next_clu;",
          "850:     prev = clusters = 0;",
          "852:   walk = next_clu) {",
          "853:  next_clu = next_cluster(fs, walk);",
          "",
          "[Removed Lines]",
          "851:     for (walk = FSTART(file, fs); walk > 1 && walk < fs->clusters + 2;",
          "",
          "[Added Lines]",
          "853:     for (walk = FSTART(file, fs); walk > 1 && walk < fs->data_clusters + 2;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "889:  set_owner(fs, walk, file);",
          "890:     }",
          "893:   walk = next_cluster(fs, walk))",
          "894:  if (bad_cluster(fs, walk))",
          "895:      break;",
          "",
          "[Removed Lines]",
          "892:     for (walk = FSTART(file, fs); walk > 1 && walk < fs->clusters + 2;",
          "",
          "[Added Lines]",
          "894:     for (walk = FSTART(file, fs); walk > 1 && walk < fs->data_clusters + 2;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "910:     walk = FSTART(file, fs);",
          "914:  FAT_ENTRY curEntry;",
          "915:  get_fat(&curEntry, fs->fat, walk, fs);",
          "",
          "[Removed Lines]",
          "912:     while (left && (walk >= 2) && (walk < fs->clusters + 2)) {",
          "",
          "[Added Lines]",
          "914:     while (left && (walk >= 2) && (walk < fs->data_clusters + 2)) {",
          "",
          "---------------"
        ],
        "src/fat.c||src/fat.c": [
          "File: src/fat.c -> src/fat.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "94:     fs->fat = NULL;",
          "95:     fs->cluster_owner = NULL;",
          "98:     eff_size = (total_num_clusters * fs->fat_bits + 7) / 8ULL;",
          "100:     if (fs->fat_bits != 12)",
          "",
          "[Removed Lines]",
          "97:     total_num_clusters = fs->clusters + 2UL;",
          "",
          "[Added Lines]",
          "97:     total_num_clusters = fs->data_clusters + 2;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "155:     memset(fs->cluster_owner, 0, (total_num_clusters * sizeof(DOS_FILE *)));",
          "159:  FAT_ENTRY curEntry;",
          "160:  get_fat(&curEntry, fs->fat, i, fs);",
          "161:  if (curEntry.value == 1) {",
          "163:      set_fat(fs, i, -1);",
          "164:  }",
          "166:      (curEntry.value < FAT_MIN_BAD(fs))) {",
          "167:      printf(\"Cluster %ld out of range (%ld > %ld). Setting to EOF.\\n\",",
          "169:      set_fat(fs, i, -1);",
          "170:  }",
          "171:     }",
          "",
          "[Removed Lines]",
          "158:     for (i = 2; i < fs->clusters + 2; i++) {",
          "162:      printf(\"Cluster %ld out of range (1). Setting to EOF.\\n\", (long)(i - 2));",
          "165:  if (curEntry.value >= fs->clusters + 2 &&",
          "168:      (long)(i - 2), (long)curEntry.value, (long)(fs->clusters + 2 - 1));",
          "",
          "[Added Lines]",
          "158:     for (i = 2; i < fs->data_clusters + 2; i++) {",
          "162:      printf(\"Cluster %ld out of range (1). Setting to EOF.\\n\",",
          "163:      (long)(i - 2));",
          "166:  if (curEntry.value >= fs->data_clusters + 2 &&",
          "169:      (long)(i - 2), (long)curEntry.value,",
          "170:      (long)(fs->data_clusters + 2 - 1));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "205:      data[1] = new >> 4;",
          "206:  } else {",
          "207:      FAT_ENTRY subseqEntry;",
          "209:   get_fat(&subseqEntry, fs->fat, cluster + 1, fs);",
          "210:      else",
          "211:   subseqEntry.value = 0;",
          "",
          "[Removed Lines]",
          "208:      if (cluster != fs->clusters + 1)",
          "",
          "[Added Lines]",
          "210:      if (cluster != fs->data_clusters + 1)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "315:     if (verbose)",
          "316:  printf(\"Checking for bad clusters.\\n\");",
          "318:  FAT_ENTRY curEntry;",
          "319:  get_fat(&curEntry, fs->fat, i, fs);",
          "",
          "[Removed Lines]",
          "317:     for (i = 2; i < fs->clusters + 2; i++) {",
          "",
          "[Added Lines]",
          "319:     for (i = 2; i < fs->data_clusters + 2; i++) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "334:     if (verbose)",
          "335:  printf(\"Checking for unused clusters.\\n\");",
          "336:     reclaimed = 0;",
          "338:  FAT_ENTRY curEntry;",
          "339:  get_fat(&curEntry, fs->fat, i, fs);",
          "",
          "[Removed Lines]",
          "337:     for (i = 2; i < fs->clusters + 2; i++) {",
          "",
          "[Added Lines]",
          "339:     for (i = 2; i < fs->data_clusters + 2; i++) {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "369:     if (start_cluster == 0)",
          "370:  start_cluster = 2;",
          "373:  FAT_ENTRY curEntry;",
          "374:  get_fat(&curEntry, fs->fat, i, fs);",
          "",
          "[Removed Lines]",
          "372:     for (i = start_cluster; i < fs->clusters + 2; i++) {",
          "",
          "[Added Lines]",
          "374:     for (i = start_cluster; i < fs->data_clusters + 2; i++) {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "420:     if (verbose)",
          "421:  printf(\"Reclaiming unconnected clusters.\\n\");",
          "424:     num_refs = alloc(total_num_clusters * sizeof(uint32_t));",
          "425:     memset(num_refs, 0, (total_num_clusters * sizeof(uint32_t)));",
          "",
          "[Removed Lines]",
          "423:     total_num_clusters = fs->clusters + 2UL;",
          "",
          "[Added Lines]",
          "425:     total_num_clusters = fs->data_clusters + 2;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "433:  get_fat(&curEntry, fs->fat, i, fs);",
          "435:  next = curEntry.value;",
          "438:      FAT_ENTRY nextEntry;",
          "439:      get_fat(&nextEntry, fs->fat, next, fs);",
          "",
          "[Removed Lines]",
          "436:  if (!get_owner(fs, i) && next && next < fs->clusters + 2) {",
          "",
          "[Added Lines]",
          "438:  if (!get_owner(fs, i) && next && next < fs->data_clusters + 2) {",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "513:     uint32_t free = 0;",
          "514:     int do_set = 0;",
          "517:  FAT_ENTRY curEntry;",
          "518:  get_fat(&curEntry, fs->fat, i, fs);",
          "",
          "[Removed Lines]",
          "516:     for (i = 2; i < fs->clusters + 2; i++) {",
          "",
          "[Added Lines]",
          "518:     for (i = 2; i < fs->data_clusters + 2; i++) {",
          "",
          "---------------"
        ],
        "src/fsck.fat.c||src/fsck.fat.c": [
          "File: src/fsck.fat.c -> src/fsck.fat.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "218:     if (!boot_only)",
          "219:  printf(\"%s: %u files, %lu/%lu clusters\\n\", argv[optind],",
          "222:     return fs_close(rw) ? 1 : 0;",
          "223: }",
          "",
          "[Removed Lines]",
          "220:         n_files, (unsigned long)fs.clusters - free_clusters, (unsigned long)fs.clusters);",
          "",
          "[Added Lines]",
          "220:         n_files, (unsigned long)fs.data_clusters - free_clusters,",
          "221:         (unsigned long)fs.data_clusters);",
          "",
          "---------------"
        ],
        "src/fsck.fat.h||src/fsck.fat.h": [
          "File: src/fsck.fat.h -> src/fsck.fat.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "158:     unsigned int root_entries;",
          "159:     loff_t data_start;",
          "160:     unsigned int cluster_size;",
          "163:     long free_clusters;",
          "",
          "[Removed Lines]",
          "161:     uint32_t clusters;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "39ce90fe75661ed8842551cd44ea7fec278a60a1",
      "candidate_info": {
        "commit_hash": "39ce90fe75661ed8842551cd44ea7fec278a60a1",
        "repo": "dosfstools/dosfstools",
        "commit_url": "https://github.com/dosfstools/dosfstools/commit/39ce90fe75661ed8842551cd44ea7fec278a60a1",
        "files": [
          "src/fat.c"
        ],
        "message": "set_fat(): Move FAT12 next cluster check up\n\nIn FAT12 two 12 bit entries are combined to a 24 bit value (three\nbytes). Therefore, when an even numbered FAT entry is set in FAT12, it\nmust be be combined with the following entry. To prevent accessing\nbeyond the end of the FAT array, it must be checked that the cluster is\nnot the last one.\n\nThis check was broken in ff1b24e9 (first included in 3.0.3) as the\nlookup was done unconditionally and the check influenced only using the\nlooked up value.\n\nMove the check up to fix.\n\nSigned-off-by: Andreas Bombe <aeb@debian.org>",
        "before_after_code_files": [
          "src/fat.c||src/fat.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/fat.c||src/fat.c"
          ],
          "candidate": [
            "src/fat.c||src/fat.c"
          ]
        }
      },
      "candidate_diff": {
        "src/fat.c||src/fat.c": [
          "File: src/fat.c -> src/fat.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "205:      data[1] = new >> 4;",
          "206:  } else {",
          "207:      FAT_ENTRY subseqEntry;",
          "209:      data[0] = new & 0xff;",
          "212:  }",
          "213:  size = 2;",
          "214:  break;",
          "",
          "[Removed Lines]",
          "208:      get_fat(&subseqEntry, fs->fat, cluster + 1, fs);",
          "210:      data[1] = (new >> 8) | (cluster == fs->clusters - 1 ? 0 :",
          "211:         (0xff & subseqEntry.value) << 4);",
          "",
          "[Added Lines]",
          "208:      if (cluster != fs->clusters - 1)",
          "209:   get_fat(&subseqEntry, fs->fat, cluster + 1, fs);",
          "210:      else",
          "211:   subseqEntry.value = 0;",
          "213:      data[1] = (new >> 8) | ((0xff & subseqEntry.value) << 4);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
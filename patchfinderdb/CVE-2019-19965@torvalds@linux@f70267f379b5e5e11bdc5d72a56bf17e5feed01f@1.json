{
  "cve_id": "CVE-2019-19965",
  "cve_desc": "In the Linux kernel through 5.4.6, there is a NULL pointer dereference in drivers/scsi/libsas/sas_discover.c because of mishandling of port disconnection during discovery, related to a PHY down race condition, aka CID-f70267f379b5.",
  "repo": "torvalds/linux",
  "patch_hash": "f70267f379b5e5e11bdc5d72a56bf17e5feed01f",
  "patch_info": {
    "commit_hash": "f70267f379b5e5e11bdc5d72a56bf17e5feed01f",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/f70267f379b5e5e11bdc5d72a56bf17e5feed01f",
    "files": [
      "drivers/scsi/libsas/sas_discover.c"
    ],
    "message": "scsi: libsas: stop discovering if oob mode is disconnected\n\nThe discovering of sas port is driven by workqueue in libsas. When libsas\nis processing port events or phy events in workqueue, new events may rise\nup and change the state of some structures such as asd_sas_phy.  This may\ncause some problems such as follows:\n\n==>thread 1                       ==>thread 2\n\n                                  ==>phy up\n                                  ==>phy_up_v3_hw()\n                                    ==>oob_mode = SATA_OOB_MODE;\n                                  ==>phy down quickly\n                                  ==>hisi_sas_phy_down()\n                                    ==>sas_ha->notify_phy_event()\n                                    ==>sas_phy_disconnected()\n                                      ==>oob_mode = OOB_NOT_CONNECTED\n==>workqueue wakeup\n==>sas_form_port()\n  ==>sas_discover_domain()\n    ==>sas_get_port_device()\n      ==>oob_mode is OOB_NOT_CONNECTED and device\n         is wrongly taken as expander\n\nThis at last lead to the panic when libsas trying to issue a command to\ndiscover the device.\n\n[183047.614035] Unable to handle kernel NULL pointer dereference at\nvirtual address 0000000000000058\n[183047.622896] Mem abort info:\n[183047.625762]   ESR = 0x96000004\n[183047.628893]   Exception class = DABT (current EL), IL = 32 bits\n[183047.634888]   SET = 0, FnV = 0\n[183047.638015]   EA = 0, S1PTW = 0\n[183047.641232] Data abort info:\n[183047.644189]   ISV = 0, ISS = 0x00000004\n[183047.648100]   CM = 0, WnR = 0\n[183047.651145] user pgtable: 4k pages, 48-bit VAs, pgdp =\n00000000b7df67be\n[183047.657834] [0000000000000058] pgd=0000000000000000\n[183047.662789] Internal error: Oops: 96000004 [#1] SMP\n[183047.667740] Process kworker/u16:2 (pid: 31291, stack limit =\n0x00000000417c4974)\n[183047.675208] CPU: 0 PID: 3291 Comm: kworker/u16:2 Tainted: G\nW  OE 4.19.36-vhulk1907.1.0.h410.eulerosv2r8.aarch64 #1\n[183047.687015] Hardware name: N/A N/A/Kunpeng Desktop Board D920S10,\nBIOS 0.15 10/22/2019\n[183047.695007] Workqueue: 0000:74:02.0_disco_q sas_discover_domain\n[183047.700999] pstate: 20c00009 (nzCv daif +PAN +UAO)\n[183047.705864] pc : prep_ata_v3_hw+0xf8/0x230 [hisi_sas_v3_hw]\n[183047.711510] lr : prep_ata_v3_hw+0xb0/0x230 [hisi_sas_v3_hw]\n[183047.717153] sp : ffff00000f28ba60\n[183047.720541] x29: ffff00000f28ba60 x28: ffff8026852d7228\n[183047.725925] x27: ffff8027dba3e0a8 x26: ffff8027c05fc200\n[183047.731310] x25: 0000000000000000 x24: ffff8026bafa8dc0\n[183047.736695] x23: ffff8027c05fc218 x22: ffff8026852d7228\n[183047.742079] x21: ffff80007c2f2940 x20: ffff8027c05fc200\n[183047.747464] x19: 0000000000f80800 x18: 0000000000000010\n[183047.752848] x17: 0000000000000000 x16: 0000000000000000\n[183047.758232] x15: ffff000089a5a4ff x14: 0000000000000005\n[183047.763617] x13: ffff000009a5a50e x12: ffff8026bafa1e20\n[183047.769001] x11: ffff0000087453b8 x10: ffff00000f28b870\n[183047.774385] x9 : 0000000000000000 x8 : ffff80007e58f9b0\n[183047.779770] x7 : 0000000000000000 x6 : 000000000000003f\n[183047.785154] x5 : 0000000000000040 x4 : ffffffffffffffe0\n[183047.790538] x3 : 00000000000000f8 x2 : 0000000002000007\n[183047.795922] x1 : 0000000000000008 x0 : 0000000000000000\n[183047.801307] Call trace:\n[183047.803827]  prep_ata_v3_hw+0xf8/0x230 [hisi_sas_v3_hw]\n[183047.809127]  hisi_sas_task_prep+0x750/0x888 [hisi_sas_main]\n[183047.814773]  hisi_sas_task_exec.isra.7+0x88/0x1f0 [hisi_sas_main]\n[183047.820939]  hisi_sas_queue_command+0x28/0x38 [hisi_sas_main]\n[183047.826757]  smp_execute_task_sg+0xec/0x218\n[183047.831013]  smp_execute_task+0x74/0xa0\n[183047.834921]  sas_discover_expander.part.7+0x9c/0x5f8\n[183047.839959]  sas_discover_root_expander+0x90/0x160\n[183047.844822]  sas_discover_domain+0x1b8/0x1e8\n[183047.849164]  process_one_work+0x1b4/0x3f8\n[183047.853246]  worker_thread+0x54/0x470\n[183047.856981]  kthread+0x134/0x138\n[183047.860283]  ret_from_fork+0x10/0x18\n[183047.863931] Code: f9407a80 528000e2 39409281 72a04002 (b9405800)\n[183047.870097] kernel fault(0x1) notification starting on CPU 0\n[183047.875828] kernel fault(0x1) notification finished on CPU 0\n[183047.881559] Modules linked in: unibsp(OE) hns3(OE) hclge(OE)\nhnae3(OE) mem_drv(OE) hisi_sas_v3_hw(OE) hisi_sas_main(OE)\n[183047.892418] ---[ end trace 4cc26083fc11b783  ]---\n[183047.897107] Kernel panic - not syncing: Fatal exception\n[183047.902403] kernel fault(0x5) notification starting on CPU 0\n[183047.908134] kernel fault(0x5) notification finished on CPU 0\n[183047.913865] SMP: stopping secondary CPUs\n[183047.917861] Kernel Offset: disabled\n[183047.921422] CPU features: 0x2,a2a00a38\n[183047.925243] Memory Limit: none\n[183047.928372] kernel reboot(0x2) notification starting on CPU 0\n[183047.934190] kernel reboot(0x2) notification finished on CPU 0\n[183047.940008] ---[ end Kernel panic - not syncing: Fatal exception\n]---\n\nFixes: 2908d778ab3e (\"[SCSI] aic94xx: new driver\")\nLink: https://lore.kernel.org/r/20191206011118.46909-1-yanaijie@huawei.com\nReported-by: Gao Chuan <gaochuan4@huawei.com>\nReviewed-by: John Garry <john.garry@huawei.com>\nSigned-off-by: Jason Yan <yanaijie@huawei.com>\nSigned-off-by: Martin K. Petersen <martin.petersen@oracle.com>",
    "before_after_code_files": [
      "drivers/scsi/libsas/sas_discover.c||drivers/scsi/libsas/sas_discover.c"
    ]
  },
  "patch_diff": {
    "drivers/scsi/libsas/sas_discover.c||drivers/scsi/libsas/sas_discover.c": [
      "File: drivers/scsi/libsas/sas_discover.c -> drivers/scsi/libsas/sas_discover.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "81:   else",
      "82:    dev->dev_type = SAS_SATA_DEV;",
      "83:   dev->tproto = SAS_PROTOCOL_SATA;",
      "85:   struct sas_identify_frame *id =",
      "86:    (struct sas_identify_frame *) dev->frame_rcvd;",
      "87:   dev->dev_type = id->dev_type;",
      "88:   dev->iproto = id->initiator_bits;",
      "89:   dev->tproto = id->target_bits;",
      "90:  }",
      "92:  sas_init_dev(dev);",
      "",
      "[Removed Lines]",
      "84:  } else {",
      "",
      "[Added Lines]",
      "84:  } else if (port->oob_mode == SAS_OOB_MODE) {",
      "90:  } else {",
      "95:   sas_put_device(dev);",
      "96:   pr_warn(\"Port %016llx is disconnected when discovering\\n\",",
      "97:    SAS_ADDR(port->attached_sas_addr));",
      "98:   return -ENODEV;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "71d873cc99309ff68d2488d32094774c77537e50",
      "candidate_info": {
        "commit_hash": "71d873cc99309ff68d2488d32094774c77537e50",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/71d873cc99309ff68d2488d32094774c77537e50",
        "files": [
          "drivers/gpu/drm/ast/ast_mode.c"
        ],
        "message": "drm/ast: Move modesetting code to CRTC's atomic_flush()\n\nWhen enabling the CRTC after waking up from a power-saving mode, the\nprimary plane's framebuffer might be NULL, which leads to a stack trace\nas shown below.\n\n  [  632.624608] BUG: kernel NULL pointer dereference, address: 0000000000000048\n  [  632.624631] #PF: supervisor read access in kernel mode\n  [  632.624639] #PF: error_code(0x0000) - not-present page\n  [  632.624647] PGD 0 P4D 0\n  [  632.624654] Oops: 0000 [#1] SMP PTI\n  [  632.624662] CPU: 0 PID: 2082 Comm: gnome-shell Tainted: G            E     5.4.0-rc7-1-default+ #114\n  [  632.624673] Hardware name: Sun Microsystems SUN FIRE X2270 M2/SUN FIRE X2270 M2, BIOS 2.05    07/01/2010\n  [  632.624689] RIP: 0010:ast_crtc_helper_atomic_enable+0x7d/0x680 [ast]\n  [  632.624698] Code: 48 8b 80 e0 02 00 00 4c 8b 60 10 31 c0 f3 48 ab 48 8b 83 78 04 00 00 4c 89 ef 48 8d 70 18 e8 9a e9 55 ce 48 8b 83 78 04 00 00 <49> 8b 7c 24 48 4c 89 ea 4c 8d 44 24 28 48 8d 4c 24 20 48 8d 70 18\n  [  632.624718] RSP: 0018:ffffbe9ec123fa40 EFLAGS: 00010246\n  [  632.624726] RAX: ffff95a13cfd3400 RBX: ffff95a13cf32000 RCX: 0000000000000000\n  [  632.624735] RDX: 0000000000000000 RSI: ffff95a13cfd34e8 RDI: ffffbe9ec123fb40\n  [  632.624744] RBP: ffffbe9ec123fb80 R08: 0000000000000000 R09: 0000000000000003\n  [  632.624753] R10: 0000000000000000 R11: 0000000000000000 R12: 0000000000000000\n  [  632.624762] R13: ffffbe9ec123fa70 R14: ffff95a13beb7000 R15: ffff95a13cf32800\n  [  632.624772] FS:  00007f6d2763e140(0000) GS:ffff95a134000000(0000) knlGS:0000000000000000\n  [  632.624782] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n  [  632.624790] CR2: 0000000000000048 CR3: 00000001192f8004 CR4: 00000000000206f0\n  [  632.624800] Call Trace:\n  [  632.624811]  ? __lock_acquire+0x409/0x7c0\n  [  632.624830]  drm_atomic_helper_commit_modeset_enables+0x1af/0x200\n  [  632.624840]  drm_atomic_helper_commit_tail+0x32/0x70\n  [  632.624849]  commit_tail+0xc7/0x110\n  [  632.624857]  drm_atomic_helper_commit+0x121/0x130\n  [  632.624867]  drm_atomic_connector_commit_dpms+0xd7/0x100\n  [  632.624878]  set_property_atomic+0xaf/0x110\n  [  632.624890]  drm_mode_obj_set_property_ioctl+0xbb/0x190\n  [  632.624899]  ? drm_mode_obj_find_prop_id+0x40/0x40\n  [  632.624909]  drm_ioctl_kernel+0x86/0xd0\n  [  632.624918]  drm_ioctl+0x1e4/0x36b\n  [  632.624925]  ? drm_mode_obj_find_prop_id+0x40/0x40\n  [  632.624939]  do_vfs_ioctl+0x4bd/0x6e0\n  [  632.624949]  ksys_ioctl+0x5e/0x90\n  [  632.624957]  __x64_sys_ioctl+0x16/0x20\n  [  632.624966]  do_syscall_64+0x5a/0x220\n  [  632.624976]  entry_SYSCALL_64_after_hwframe+0x49/0xbe\n  [  632.624984] RIP: 0033:0x7f6d2b0de387\n  [  632.624991] Code: 00 00 90 48 8b 05 f9 9a 0c 00 64 c7 00 26 00 00 00 48 c7 c0 ff ff ff ff c3 66 2e 0f 1f 84 00 00 00 00 00 b8 10 00 00 00 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 8b 0d c9 9a 0c 00 f7 d8 64 89 01 48\n  [  632.625011] RSP: 002b:00007fffb49def38 EFLAGS: 00000246 ORIG_RAX: 0000000000000010\n  [  632.625021] RAX: ffffffffffffffda RBX: 00007fffb49def70 RCX: 00007f6d2b0de387\n  [  632.625030] RDX: 00007fffb49def70 RSI: 00000000c01864ba RDI: 0000000000000009\n  [  632.625040] RBP: 00000000c01864ba R08: 0000000000000000 R09: 00000000c0c0c0c0\n  [  632.625049] R10: 0000000000000030 R11: 0000000000000246 R12: 000055bc367eb920\n  [  632.625058] R13: 0000000000000009 R14: 0000000000000002 R15: 0000000000000000\n  [  632.625071] Modules linked in: ebtable_filter(E) ebtables(E) ip6table_filter(E) ip6_tables(E) iptable_filter(E) ip_tables(E) x_tables(E) af_packet(E) scsi_transport_iscsi(E) dmi_sysfs(E) msr(E) xfs(E) intel_powerclamp(E) coretemp(E) k)\n  [  632.625185] CR2: 0000000000000048\n\nThe STR is\n\n\t* start gdm and wait for it to switch off the display\n\t* wake up the display by pressing a key\n\nCRTC modesetting depends on the new state of the CRTC and the primary\nplane's framebuffer. The bugfix moves the modesetting code into the\nCRTC's atomic_flush() function, where it is protected from the plane's\nframebuffer being NULL.\n\nThe CRTC's atomic-enable function, which is the modesetting's original\nlocation, still contains DPMS state handling. It's exactly the inverse\nof the atomic-disable function.\n\nv3:\n\t* protect modesetting from from fb == NULL\nv2:\n\t* do an atomic check for plane\n\t* reject invisible primary planes\n\nSigned-off-by: Thomas Zimmermann <tzimmermann@suse.de>\nAcked-by: Gerd Hoffmann <kraxel@redhat.com>\nFixes: b48e1b6ffd28 (\"drm/ast: Add CRTC helpers for atomic modesetting\")\nCc: Gerd Hoffmann <kraxel@redhat.com>\nCc: Dave Airlie <airlied@redhat.com>\nCc: Daniel Vetter <daniel.vetter@ffwll.ch>\nCc: \"Y.C. Chen\" <yc_chen@aspeedtech.com>\nCc: Sam Ravnborg <sam@ravnborg.org>\nLink: https://patchwork.freedesktop.org/patch/msgid/20191202111557.15176-2-tzimmermann@suse.de",
        "before_after_code_files": [
          "drivers/gpu/drm/ast/ast_mode.c||drivers/gpu/drm/ast/ast_mode.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/gpu/drm/ast/ast_mode.c||drivers/gpu/drm/ast/ast_mode.c": [
          "File: drivers/gpu/drm/ast/ast_mode.c -> drivers/gpu/drm/ast/ast_mode.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "790: static void ast_crtc_helper_atomic_flush(struct drm_crtc *crtc,",
          "791:       struct drm_crtc_state *old_crtc_state)",
          "792: {",
          "793:  const struct drm_framebuffer *fb = crtc->primary->state->fb;",
          "794:  struct drm_display_mode adjusted_mode;",
          "795:  struct ast_vbios_mode_info vbios_mode;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "793:  struct drm_device *dev = crtc->dev;",
          "794:  struct ast_private *ast = dev->dev_private;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "800:  if (!fb)",
          "801:   return;",
          "805:  memset(&adjusted_mode, 0, sizeof(adjusted_mode));",
          "806:  drm_mode_copy(&adjusted_mode, &crtc->state->adjusted_mode);",
          "808:  succ = ast_get_vbios_mode_info(fb, &crtc->state->adjusted_mode,",
          "809:            &adjusted_mode, &vbios_mode);",
          "810:  if (WARN_ON_ONCE(!succ))",
          "813:  ast_set_vbios_color_reg(crtc, fb, &vbios_mode);",
          "833:   return;",
          "835:  ast_set_vbios_mode_reg(crtc, &adjusted_mode, &vbios_mode);",
          "",
          "[Removed Lines]",
          "803:  ast_set_color_reg(crtc, fb);",
          "811:   return;",
          "814: }",
          "816: static void",
          "817: ast_crtc_helper_atomic_enable(struct drm_crtc *crtc,",
          "818:          struct drm_crtc_state *old_crtc_state)",
          "819: {",
          "820:  struct drm_device *dev = crtc->dev;",
          "821:  struct ast_private *ast = crtc->dev->dev_private;",
          "822:  const struct drm_framebuffer *fb = crtc->primary->state->fb;",
          "823:  struct drm_display_mode adjusted_mode;",
          "824:  struct ast_vbios_mode_info vbios_mode;",
          "825:  bool succ;",
          "827:  memset(&adjusted_mode, 0, sizeof(adjusted_mode));",
          "828:  drm_mode_copy(&adjusted_mode, &crtc->state->adjusted_mode);",
          "830:  succ = ast_get_vbios_mode_info(fb, &crtc->state->adjusted_mode,",
          "831:            &adjusted_mode, &vbios_mode);",
          "832:  if (WARN_ON_ONCE(!succ))",
          "",
          "[Added Lines]",
          "813:  ast_set_color_reg(crtc, fb);",
          "816:  if (!crtc->state->mode_changed)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "840:  ast_set_crtthd_reg(crtc);",
          "841:  ast_set_sync_reg(dev, &adjusted_mode, &vbios_mode);",
          "842:  ast_set_dac_reg(crtc, &adjusted_mode, &vbios_mode);",
          "844:  ast_crtc_dpms(crtc, DRM_MODE_DPMS_ON);",
          "845: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "827: }",
          "829: static void",
          "830: ast_crtc_helper_atomic_enable(struct drm_crtc *crtc,",
          "831:          struct drm_crtc_state *old_crtc_state)",
          "832: {",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b418d660bb9798d2249ac6a46c844389ef50b6a5",
      "candidate_info": {
        "commit_hash": "b418d660bb9798d2249ac6a46c844389ef50b6a5",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/b418d660bb9798d2249ac6a46c844389ef50b6a5",
        "files": [
          "drivers/firmware/efi/earlycon.c"
        ],
        "message": "efi/earlycon: Remap entire framebuffer after page initialization\n\nWhen commit:\n\n  69c1f396f25b (\"efi/x86: Convert x86 EFI earlyprintk into generic earlycon implementation\")\n\nmoved the x86 specific EFI earlyprintk implementation to a shared location,\nit also tweaked the behaviour. In particular, it dropped a trick with full\nframebuffer remapping after page initialization, leading to two regressions:\n\n  1) very slow scrolling after page initialization,\n  2) kernel hang when the 'keep_bootcon' command line argument is passed.\n\nPutting the tweak back fixes #2 and mitigates #1, i.e., it limits the slow\nbehavior to the early boot stages, presumably due to eliminating heavy\nmap()/unmap() operations per each pixel line on the screen.\n\n [ ardb: ensure efifb is unmapped again unless keep_bootcon is in effect. ]\n [ mingo: speling fixes. ]\n\nSigned-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>\nSigned-off-by: Ard Biesheuvel <ardb@kernel.org>\nCc: Arvind Sankar <nivedita@alum.mit.edu>\nCc: Bhupesh Sharma <bhsharma@redhat.com>\nCc: Masayoshi Mizuma <m.mizuma@jp.fujitsu.com>\nCc: linux-efi@vger.kernel.org\nFixes: 69c1f396f25b (\"efi/x86: Convert x86 EFI earlyprintk into generic earlycon implementation\")\nLink: https://lkml.kernel.org/r/20191206165542.31469-7-ardb@kernel.org\nSigned-off-by: Ingo Molnar <mingo@kernel.org>",
        "before_after_code_files": [
          "drivers/firmware/efi/earlycon.c||drivers/firmware/efi/earlycon.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/firmware/efi/earlycon.c||drivers/firmware/efi/earlycon.c": [
          "File: drivers/firmware/efi/earlycon.c -> drivers/firmware/efi/earlycon.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "14: #include <asm/early_ioremap.h>",
          "16: static const struct font_desc *font;",
          "17: static u32 efi_x, efi_y;",
          "18: static u64 fb_base;",
          "19: static pgprot_t fb_prot;",
          "21: static __ref void *efi_earlycon_map(unsigned long start, unsigned long len)",
          "22: {",
          "23:  return early_memremap_prot(fb_base + start, len, pgprot_val(fb_prot));",
          "24: }",
          "26: static __ref void efi_earlycon_unmap(void *addr, unsigned long len)",
          "27: {",
          "28:  early_memunmap(addr, len);",
          "29: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "16: static const struct console *earlycon_console __initdata;",
          "21: static void *efi_fb;",
          "30: static int __init efi_earlycon_remap_fb(void)",
          "31: {",
          "33:  if (!earlycon_console || !(earlycon_console->flags & CON_ENABLED))",
          "34:   return 0;",
          "36:  if (pgprot_val(fb_prot) == pgprot_val(PAGE_KERNEL))",
          "37:   efi_fb = memremap(fb_base, screen_info.lfb_size, MEMREMAP_WB);",
          "38:  else",
          "39:   efi_fb = memremap(fb_base, screen_info.lfb_size, MEMREMAP_WC);",
          "41:  return efi_fb ? 0 : -ENOMEM;",
          "42: }",
          "43: early_initcall(efi_earlycon_remap_fb);",
          "45: static int __init efi_earlycon_unmap_fb(void)",
          "46: {",
          "48:  if (efi_fb && !(earlycon_console->flags & CON_ENABLED))",
          "49:   memunmap(efi_fb);",
          "50:  return 0;",
          "51: }",
          "52: late_initcall(efi_earlycon_unmap_fb);",
          "56:  if (efi_fb)",
          "57:   return efi_fb + start;",
          "64:  if (efi_fb)",
          "65:   return;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "201:   efi_earlycon_scroll_up();",
          "203:  device->con->write = efi_earlycon_write;",
          "204:  return 0;",
          "205: }",
          "206: EARLYCON_DECLARE(efifb, efi_earlycon_setup);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "243:  earlycon_console = device->con;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "bbca083de291a03ffe1a1eb0832a0d74f8b64898",
      "candidate_info": {
        "commit_hash": "bbca083de291a03ffe1a1eb0832a0d74f8b64898",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/bbca083de291a03ffe1a1eb0832a0d74f8b64898",
        "files": [
          "drivers/gpu/drm/i915/i915_active.c"
        ],
        "message": "drm/i915: Serialise i915_active_acquire() with __active_retire()\n\nAs __active_retire() does it's final atomic_dec() under the\nref->tree_lock spinlock, in order to prevent ourselves from reusing the\nref->cache and ref->tree as they are being destroyed, we need to\nserialise with the retirement during i915_active_acquire().\n\n[  +0.000005] kernel BUG at drivers/gpu/drm/i915/i915_active.c:157!\n[  +0.000011] invalid opcode: 0000 [#1] SMP\n[  +0.000004] CPU: 7 PID: 188 Comm: kworker/u16:4 Not tainted 5.4.0-rc8-03070-gac5e57322614 #89\n[  +0.000002] Hardware name: Razer Razer Blade Stealth 13 Late 2019/LY320, BIOS 1.02 09/10/2019\n[  +0.000082] Workqueue: events_unbound active_work [i915]\n[  +0.000059] RIP: 0010:__active_retire+0x115/0x120 [i915]\n[  +0.000003] Code: 75 28 48 8b 3d 8c 6e 1a 00 48 89 ee e8 e4 5f a5 c0 48 8b 44 24 10 65 48 33 04 25 28 00 00 00 75 0f 48 83 c4 18 5b 5d 41 5c c3 <0f> 0b 0f 0b 0f 0b e8 a0 90 87 c0 0f 1f 44 00 00 48 8b 3d 54 6e 1a\n[  +0.000002] RSP: 0018:ffffb833003f7e48 EFLAGS: 00010286\n[  +0.000003] RAX: ffff8d6e8d726d00 RBX: ffff8d6f9db4e840 RCX: 0000000000000000\n[  +0.000001] RDX: ffffffff82605930 RSI: ffff8d6f9adc4908 RDI: ffff8d6e96cefe28\n[  +0.000002] RBP: ffff8d6e96cefe00 R08: 0000000000000000 R09: ffff8d6f9ffe9a50\n[  +0.000002] R10: 0000000000000048 R11: 0000000000000018 R12: ffff8d6f9adc4930\n[  +0.000001] R13: ffff8d6f9e04fb00 R14: 0000000000000000 R15: ffff8d6f9adc4988\n[  +0.000002] FS:  0000000000000000(0000) GS:ffff8d6f9ffc0000(0000) knlGS:0000000000000000\n[  +0.000002] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  +0.000002] CR2: 000055eb5a34cf10 CR3: 000000018d609002 CR4: 0000000000760ee0\n[  +0.000002] PKRU: 55555554\n[  +0.000001] Call Trace:\n[  +0.000010]  process_one_work+0x1aa/0x350\n[  +0.000004]  worker_thread+0x4d/0x3a0\n[  +0.000004]  kthread+0xfb/0x130\n[  +0.000004]  ? process_one_work+0x350/0x350\n[  +0.000003]  ? kthread_park+0x90/0x90\n[  +0.000005]  ret_from_fork+0x1f/0x40\n\nReported-by: Kenneth Graunke <kenneth@whitecape.org>\nFixes: c9ad602feabe (\"drm/i915: Split i915_active.mutex into an irq-safe spinlock for the rbtree\")\nSigned-off-by: Chris Wilson <chris@chris-wilson.co.uk>\nCc: Tvrtko Ursulin <tvrtko.ursulin@intel.com>\nCc: Kenneth Graunke <kenneth@whitecape.org>\nCc: Matthew Auld <matthew.auld@intel.com>\nTested-by: Kenneth Graunke <kenneth@whitecape.org>\nReviewed-by: Kenneth Graunke <kenneth@whitecape.org>\nLink: https://patchwork.freedesktop.org/patch/msgid/20191205183332.801237-1-chris@chris-wilson.co.uk",
        "before_after_code_files": [
          "drivers/gpu/drm/i915/i915_active.c||drivers/gpu/drm/i915/i915_active.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/gpu/drm/i915/i915_active.c||drivers/gpu/drm/i915/i915_active.c": [
          "File: drivers/gpu/drm/i915/i915_active.c -> drivers/gpu/drm/i915/i915_active.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "92: static void debug_active_activate(struct i915_active *ref)",
          "93: {",
          "96:   debug_object_activate(ref, &active_debug_desc);",
          "98: }",
          "100: static void debug_active_deactivate(struct i915_active *ref)",
          "",
          "[Removed Lines]",
          "94:  spin_lock_irq(&ref->tree_lock);",
          "97:  spin_unlock_irq(&ref->tree_lock);",
          "",
          "[Added Lines]",
          "94:  lockdep_assert_held(&ref->tree_lock);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "419:  if (!atomic_read(&ref->count) && ref->active)",
          "420:   err = ref->active(ref);",
          "421:  if (!err) {",
          "422:   debug_active_activate(ref);",
          "423:   atomic_inc(&ref->count);",
          "424:  }",
          "426:  mutex_unlock(&ref->mutex);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "424:   spin_unlock_irq(&ref->tree_lock);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "d5162f341e9625d00a275d5cbe55432e6627c3bf",
      "candidate_info": {
        "commit_hash": "d5162f341e9625d00a275d5cbe55432e6627c3bf",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/d5162f341e9625d00a275d5cbe55432e6627c3bf",
        "files": [
          "net/tipc/name_table.c"
        ],
        "message": "tipc: fix name table rbtree issues\n\nThe current rbtree for service ranges in the name table is built based\non the 'lower' & 'upper' range values resulting in a flaw in the rbtree\nsearching. Some issues have been observed in case of range overlapping:\n\nCase #1: unable to withdraw a name entry:\nAfter some name services are bound, all of them are withdrawn by user\nbut one remains in the name table forever. This corrupts the table and\nthat service becomes dummy i.e. no real port.\nE.g.\n\n                /\n           {22, 22}\n              /\n             /\n   --->  {10, 50}\n           /  \\\n          /    \\\n    {10, 30}  {20, 60}\n\nThe node {10, 30} cannot be removed since the rbtree searching stops at\nthe node's ancestor i.e. {10, 50}, so starting from it will never reach\nthe finding node.\n\nCase #2: failed to send data in some cases:\nE.g. Two service ranges: {20, 60}, {10, 50} are bound. The rbtree for\nthis service will be one of the two cases below depending on the order\nof the bindings:\n\n        {20, 60}             {10, 50} <--\n          /  \\                 /  \\\n         /    \\               /    \\\n    {10, 50}  NIL <--       NIL  {20, 60}\n\n          (a)                    (b)\n\nNow, try to send some data to service {30}, there will be two results:\n(a): Failed, no route to host.\n(b): Ok.\n\nThe reason is that the rbtree searching will stop at the pointing node\nas shown above.\n\nCase #3: Same as case #2b above but if the data sending's scope is\nlocal and the {10, 50} is published by a peer node, then it will result\nin 'no route to host' even though the other {20, 60} is for example on\nthe local node which should be able to get the data.\n\nThe issues are actually due to the way we built the rbtree. This commit\nfixes it by introducing an additional field to each node - named 'max',\nwhich is the largest 'upper' of that node subtree. The 'max' value for\neach subtrees will be propagated correctly whenever a node is inserted/\nremoved or the tree is rebalanced by the augmented rbtree callbacks.\n\nBy this way, we can change the rbtree searching appoarch to solve the\nissues above. Another benefit from this is that we can now improve the\nsearching for a next range matching e.g. in case of multicast, so get\nrid of the unneeded looping over all nodes in the tree.\n\nAcked-by: Jon Maloy <jon.maloy@ericsson.com>\nSigned-off-by: Tuong Lien <tuong.t.lien@dektech.com.au>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "net/tipc/name_table.c||net/tipc/name_table.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "net/tipc/name_table.c||net/tipc/name_table.c": [
          "File: net/tipc/name_table.c -> net/tipc/name_table.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "37: #include <net/sock.h>",
          "38: #include <linux/list_sort.h>",
          "39: #include \"core.h\"",
          "40: #include \"netlink.h\"",
          "41: #include \"name_table.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "39: #include <linux/rbtree_augmented.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "60:  u32 lower;",
          "61:  u32 upper;",
          "62:  struct rb_node tree_node;",
          "63:  struct list_head local_publ;",
          "64:  struct list_head all_publ;",
          "65: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "65:  u32 max;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "84:  struct rcu_head rcu;",
          "85: };",
          "87: static int hash(int x)",
          "88: {",
          "89:  return x & (TIPC_NAMETBL_SIZE - 1);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "90: #define service_range_upper(sr) ((sr)->upper)",
          "91: RB_DECLARE_CALLBACKS_MAX(static, sr_callbacks,",
          "92:     struct service_range, tree_node, u32, max,",
          "93:     service_range_upper)",
          "95: #define service_range_entry(rbtree_node)    \\",
          "96:  (container_of(rbtree_node, struct service_range, tree_node))",
          "98: #define service_range_overlap(sr, start, end)    \\",
          "99:  ((sr)->lower <= (end) && (sr)->upper >= (start))",
          "108: #define service_range_foreach_match(sr, sc, start, end)   \\",
          "109:  for (sr = service_range_match_first((sc)->ranges.rb_node, \\",
          "110:          start,   \\",
          "111:          end);   \\",
          "112:       sr;       \\",
          "113:       sr = service_range_match_next(&(sr)->tree_node,  \\",
          "114:         start,   \\",
          "115:         end))",
          "125: static struct service_range *service_range_match_first(struct rb_node *n,",
          "126:              u32 start, u32 end)",
          "127: {",
          "128:  struct service_range *sr;",
          "129:  struct rb_node *l, *r;",
          "132:  if (!n || service_range_entry(n)->max < start)",
          "133:   return NULL;",
          "135:  while (n) {",
          "136:   l = n->rb_left;",
          "137:   if (l && service_range_entry(l)->max >= start) {",
          "142:    n = l;",
          "143:    continue;",
          "144:   }",
          "149:   sr = service_range_entry(n);",
          "150:   if (service_range_overlap(sr, start, end))",
          "151:    return sr;",
          "154:   r = n->rb_right;",
          "155:   if (sr->lower <= end &&",
          "156:       r && service_range_entry(r)->max >= start) {",
          "157:    n = r;",
          "158:    continue;",
          "159:   }",
          "160:   break;",
          "161:  }",
          "163:  return NULL;",
          "164: }",
          "174: static struct service_range *service_range_match_next(struct rb_node *n,",
          "175:             u32 start, u32 end)",
          "176: {",
          "177:  struct service_range *sr;",
          "178:  struct rb_node *p, *r;",
          "180:  while (n) {",
          "181:   r = n->rb_right;",
          "182:   if (r && service_range_entry(r)->max >= start)",
          "188:    return service_range_match_first(r, start, end);",
          "193:   while ((p = rb_parent(n)) && n == p->rb_right)",
          "194:    n = p;",
          "195:   if (!p)",
          "196:    break;",
          "199:   sr = service_range_entry(p);",
          "200:   if (service_range_overlap(sr, start, end))",
          "201:    return sr;",
          "204:   if (sr->lower <= end) {",
          "205:    n = p;",
          "206:    continue;",
          "207:   }",
          "208:   break;",
          "209:  }",
          "211:  return NULL;",
          "212: }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "139:  return service;",
          "140: }",
          "167: static struct service_range *tipc_service_find_range(struct tipc_service *sc,",
          "168:            u32 lower, u32 upper)",
          "169: {",
          "171:  struct service_range *sr;",
          "182:  }",
          "187: }",
          "189: static struct service_range *tipc_service_create_range(struct tipc_service *sc,",
          "190:              u32 lower, u32 upper)",
          "191: {",
          "192:  struct rb_node **n, *parent = NULL;",
          "195:  n = &sc->ranges.rb_node;",
          "196:  while (*n) {",
          "198:   parent = *n;",
          "208:   else",
          "210:  }",
          "211:  sr = kzalloc(sizeof(*sr), GFP_ATOMIC);",
          "212:  if (!sr)",
          "213:   return NULL;",
          "214:  sr->lower = lower;",
          "215:  sr->upper = upper;",
          "216:  INIT_LIST_HEAD(&sr->local_publ);",
          "217:  INIT_LIST_HEAD(&sr->all_publ);",
          "218:  rb_link_node(&sr->tree_node, parent, n);",
          "220:  return sr;",
          "221: }",
          "",
          "[Removed Lines]",
          "147: static struct service_range *tipc_service_first_range(struct tipc_service *sc,",
          "148:             u32 instance)",
          "149: {",
          "150:  struct rb_node *n = sc->ranges.rb_node;",
          "151:  struct service_range *sr;",
          "153:  while (n) {",
          "154:   sr = container_of(n, struct service_range, tree_node);",
          "155:   if (sr->lower > instance)",
          "156:    n = n->rb_left;",
          "157:   else if (sr->upper < instance)",
          "158:    n = n->rb_right;",
          "159:   else",
          "160:    return sr;",
          "161:  }",
          "162:  return NULL;",
          "163: }",
          "170:  struct rb_node *n = sc->ranges.rb_node;",
          "173:  sr = tipc_service_first_range(sc, lower);",
          "174:  if (!sr)",
          "175:   return NULL;",
          "178:  for (n = &sr->tree_node; n; n = rb_next(n)) {",
          "179:   sr = container_of(n, struct service_range, tree_node);",
          "180:   if (sr->upper == upper)",
          "181:    break;",
          "183:  if (!n || sr->lower != lower || sr->upper != upper)",
          "184:   return NULL;",
          "186:  return sr;",
          "193:  struct service_range *sr, *tmp;",
          "197:   tmp = container_of(*n, struct service_range, tree_node);",
          "199:   tmp = container_of(parent, struct service_range, tree_node);",
          "200:   if (lower < tmp->lower)",
          "201:    n = &(*n)->rb_left;",
          "202:   else if (lower > tmp->lower)",
          "203:    n = &(*n)->rb_right;",
          "204:   else if (upper < tmp->upper)",
          "205:    n = &(*n)->rb_left;",
          "206:   else if (upper > tmp->upper)",
          "207:    n = &(*n)->rb_right;",
          "209:    return tmp;",
          "219:  rb_insert_color(&sr->tree_node, &sc->ranges);",
          "",
          "[Added Lines]",
          "276:  service_range_foreach_match(sr, sc, lower, upper) {",
          "278:   if (sr->lower == lower && sr->upper == upper)",
          "279:    return sr;",
          "282:  return NULL;",
          "289:  struct service_range *sr;",
          "294:   sr = service_range_entry(parent);",
          "295:   if (lower == sr->lower && upper == sr->upper)",
          "296:    return sr;",
          "297:   if (sr->max < upper)",
          "298:    sr->max = upper;",
          "299:   if (lower <= sr->lower)",
          "300:    n = &parent->rb_left;",
          "302:    n = &parent->rb_right;",
          "309:  sr->max = upper;",
          "313:  rb_insert_augmented(&sr->tree_node, &sc->ranges, &sr_callbacks);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "310:  struct list_head publ_list;",
          "311:  struct service_range *sr;",
          "312:  struct tipc_name_seq ns;",
          "314:  u32 filter;",
          "316:  ns.type = tipc_sub_read(sb, seq.type);",
          "",
          "[Removed Lines]",
          "313:  struct rb_node *n;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "325:   return;",
          "327:  INIT_LIST_HEAD(&publ_list);",
          "335:   first = NULL;",
          "336:   list_for_each_entry(p, &sr->all_publ, all_publ) {",
          "337:    if (filter & TIPC_SUB_PORTS)",
          "",
          "[Removed Lines]",
          "328:  for (n = rb_first(&service->ranges); n; n = rb_next(n)) {",
          "329:   sr = container_of(n, struct service_range, tree_node);",
          "330:   if (sr->lower > ns.upper)",
          "331:    break;",
          "332:   if (!tipc_sub_check_overlap(&ns, sr->lower, sr->upper))",
          "333:    continue;",
          "",
          "[Added Lines]",
          "421:  service_range_foreach_match(sr, service, ns.lower, ns.upper) {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "427:  if (list_empty(&sr->all_publ)) {",
          "429:   kfree(sr);",
          "430:  }",
          "",
          "[Removed Lines]",
          "428:   rb_erase(&sr->tree_node, &sc->ranges);",
          "",
          "[Added Lines]",
          "515:   rb_erase_augmented(&sr->tree_node, &sc->ranges, &sr_callbacks);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "473:  rcu_read_lock();",
          "474:  sc = tipc_service_find(net, type);",
          "475:  if (unlikely(!sc))",
          "478:  spin_lock_bh(&sc->lock);",
          "498:  }",
          "502:  spin_unlock_bh(&sc->lock);",
          "504:  rcu_read_unlock();",
          "506:  return port;",
          "",
          "[Removed Lines]",
          "476:   goto not_found;",
          "479:  sr = tipc_service_first_range(sc, instance);",
          "480:  if (unlikely(!sr))",
          "481:   goto no_match;",
          "484:  if (*dnode == self) {",
          "485:   list = &sr->local_publ;",
          "486:   if (list_empty(list))",
          "487:    goto no_match;",
          "488:   p = list_first_entry(list, struct publication, local_publ);",
          "489:   list_move_tail(&p->local_publ, &sr->local_publ);",
          "490:  } else if (legacy && !*dnode && !list_empty(&sr->local_publ)) {",
          "491:   list = &sr->local_publ;",
          "492:   p = list_first_entry(list, struct publication, local_publ);",
          "493:   list_move_tail(&p->local_publ, &sr->local_publ);",
          "494:  } else {",
          "495:   list = &sr->all_publ;",
          "496:   p = list_first_entry(list, struct publication, all_publ);",
          "497:   list_move_tail(&p->all_publ, &sr->all_publ);",
          "499:  port = p->port;",
          "500:  node = p->node;",
          "501: no_match:",
          "503: not_found:",
          "",
          "[Added Lines]",
          "563:   goto exit;",
          "566:  service_range_foreach_match(sr, sc, instance, instance) {",
          "568:   if (*dnode == self) {",
          "569:    list = &sr->local_publ;",
          "570:    if (list_empty(list))",
          "571:     continue;",
          "572:    p = list_first_entry(list, struct publication,",
          "573:           local_publ);",
          "574:    list_move_tail(&p->local_publ, &sr->local_publ);",
          "575:   } else if (legacy && !*dnode && !list_empty(&sr->local_publ)) {",
          "576:    list = &sr->local_publ;",
          "577:    p = list_first_entry(list, struct publication,",
          "578:           local_publ);",
          "579:    list_move_tail(&p->local_publ, &sr->local_publ);",
          "580:   } else {",
          "581:    list = &sr->all_publ;",
          "582:    p = list_first_entry(list, struct publication,",
          "583:           all_publ);",
          "584:    list_move_tail(&p->all_publ, &sr->all_publ);",
          "585:   }",
          "586:   port = p->port;",
          "587:   node = p->node;",
          "591:   break;",
          "595: exit:",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "524:  spin_lock_bh(&sc->lock);",
          "527:  if (!sr)",
          "528:   goto no_match;",
          "",
          "[Removed Lines]",
          "526:  sr = tipc_service_first_range(sc, instance);",
          "",
          "[Added Lines]",
          "619:  sr = service_range_match_first(sc->ranges.rb_node, instance, instance);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "552:  struct service_range *sr;",
          "553:  struct tipc_service *sc;",
          "554:  struct publication *p;",
          "557:  rcu_read_lock();",
          "558:  sc = tipc_service_find(net, type);",
          "",
          "[Removed Lines]",
          "555:  struct rb_node *n;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "560:   goto exit;",
          "562:  spin_lock_bh(&sc->lock);",
          "570:   list_for_each_entry(p, &sr->local_publ, local_publ) {",
          "571:    if (p->scope == scope || (!exact && p->scope < scope))",
          "572:     tipc_dest_push(dports, 0, p->port);",
          "",
          "[Removed Lines]",
          "564:  for (n = rb_first(&sc->ranges); n; n = rb_next(n)) {",
          "565:   sr = container_of(n, struct service_range, tree_node);",
          "566:   if (sr->upper < lower)",
          "567:    continue;",
          "568:   if (sr->lower > upper)",
          "569:    break;",
          "",
          "[Added Lines]",
          "655:  service_range_foreach_match(sr, sc, lower, upper) {",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "587:  struct service_range *sr;",
          "588:  struct tipc_service *sc;",
          "589:  struct publication *p;",
          "592:  rcu_read_lock();",
          "593:  sc = tipc_service_find(net, type);",
          "",
          "[Removed Lines]",
          "590:  struct rb_node *n;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "595:   goto exit;",
          "597:  spin_lock_bh(&sc->lock);",
          "605:   list_for_each_entry(p, &sr->all_publ, all_publ) {",
          "606:    tipc_nlist_add(nodes, p->node);",
          "607:   }",
          "",
          "[Removed Lines]",
          "599:  for (n = rb_first(&sc->ranges); n; n = rb_next(n)) {",
          "600:   sr = container_of(n, struct service_range, tree_node);",
          "601:   if (sr->upper < lower)",
          "602:    continue;",
          "603:   if (sr->lower > upper)",
          "604:    break;",
          "",
          "[Added Lines]",
          "683:  service_range_foreach_match(sr, sc, lower, upper) {",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "799:    tipc_service_remove_publ(sr, p->node, p->key);",
          "800:    kfree_rcu(p, rcu);",
          "801:   }",
          "803:   kfree(sr);",
          "804:  }",
          "805:  hlist_del_init_rcu(&sc->service_list);",
          "",
          "[Removed Lines]",
          "802:   rb_erase(&sr->tree_node, &sc->ranges);",
          "",
          "[Added Lines]",
          "881:   rb_erase_augmented(&sr->tree_node, &sc->ranges, &sr_callbacks);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "08802ed665e47243393f43501bdafa032112eb1c",
      "candidate_info": {
        "commit_hash": "08802ed665e47243393f43501bdafa032112eb1c",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/08802ed665e47243393f43501bdafa032112eb1c",
        "files": [
          "block/bfq-cgroup.c"
        ],
        "message": "bfq-iosched: Ensure bio->bi_blkg is valid before using it\n\nbio->bi_blkg will be NULL when the issue of the request\nhas bypassed the block layer as shown in the following oops:\n\n Internal error: Oops: 96000005 [#1] SMP\n CPU: 17 PID: 2996 Comm: scsi_id Not tainted 5.4.0 #4\n Call trace:\n  percpu_counter_add_batch+0x38/0x4c8\n  bfqg_stats_update_legacy_io+0x9c/0x280\n  bfq_insert_requests+0xbac/0x2190\n  blk_mq_sched_insert_request+0x288/0x670\n  blk_execute_rq_nowait+0x140/0x178\n  blk_execute_rq+0x8c/0x140\n  sg_io+0x604/0x9c0\n  scsi_cmd_ioctl+0xe38/0x10a8\n  scsi_cmd_blk_ioctl+0xac/0xe8\n  sd_ioctl+0xe4/0x238\n  blkdev_ioctl+0x590/0x20e0\n  block_ioctl+0x60/0x98\n  do_vfs_ioctl+0xe0/0x1b58\n  ksys_ioctl+0x80/0xd8\n  __arm64_sys_ioctl+0x40/0x78\n  el0_svc_handler+0xc4/0x270\n\nso ensure its validity before using it.\n\nFixes: fd41e60331b1 (\"bfq-iosched: stop using blkg->stat_bytes and ->stat_ios\")\nSigned-off-by: Hou Tao <houtao1@huawei.com>\nSigned-off-by: Jens Axboe <axboe@kernel.dk>",
        "before_after_code_files": [
          "block/bfq-cgroup.c||block/bfq-cgroup.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "block/bfq-cgroup.c||block/bfq-cgroup.c": [
          "File: block/bfq-cgroup.c -> block/bfq-cgroup.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "351: {",
          "352:  struct bfq_group *bfqg = blkg_to_bfqg(rq->bio->bi_blkg);",
          "354:  blkg_rwstat_add(&bfqg->stats.bytes, rq->cmd_flags, blk_rq_bytes(rq));",
          "355:  blkg_rwstat_add(&bfqg->stats.ios, rq->cmd_flags, 1);",
          "356: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "354:  if (!bfqg)",
          "355:   return;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
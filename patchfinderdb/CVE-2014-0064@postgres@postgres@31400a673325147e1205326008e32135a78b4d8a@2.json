{
  "cve_id": "CVE-2014-0064",
  "cve_desc": "Multiple integer overflows in the path_in and other unspecified functions in PostgreSQL before 8.4.20, 9.0.x before 9.0.16, 9.1.x before 9.1.12, 9.2.x before 9.2.7, and 9.3.x before 9.3.3 allow remote authenticated users to have unspecified impact and attack vectors, which trigger a buffer overflow.  NOTE: this identifier has been SPLIT due to different affected versions; use CVE-2014-2669 for the hstore vector.",
  "repo": "postgres/postgres",
  "patch_hash": "31400a673325147e1205326008e32135a78b4d8a",
  "patch_info": {
    "commit_hash": "31400a673325147e1205326008e32135a78b4d8a",
    "repo": "postgres/postgres",
    "commit_url": "https://github.com/postgres/postgres/commit/31400a673325147e1205326008e32135a78b4d8a",
    "files": [
      "contrib/hstore/hstore.h",
      "contrib/hstore/hstore_io.c",
      "contrib/hstore/hstore_op.c",
      "contrib/intarray/_int.h",
      "contrib/intarray/_int_bool.c",
      "contrib/ltree/ltree.h",
      "contrib/ltree/ltree_io.c",
      "contrib/ltree/ltxtquery_io.c",
      "src/backend/utils/adt/geo_ops.c",
      "src/backend/utils/adt/tsquery.c",
      "src/backend/utils/adt/tsquery_util.c",
      "src/backend/utils/adt/txid.c",
      "src/backend/utils/adt/varbit.c",
      "src/include/tsearch/ts_type.h",
      "src/include/utils/varbit.h"
    ],
    "message": "Predict integer overflow to avoid buffer overruns.\n\nSeveral functions, mostly type input functions, calculated an allocation\nsize such that the calculation wrapped to a small positive value when\narguments implied a sufficiently-large requirement.  Writes past the end\nof the inadvertent small allocation followed shortly thereafter.\nCoverity identified the path_in() vulnerability; code inspection led to\nthe rest.  In passing, add check_stack_depth() to prevent stack overflow\nin related functions.\n\nBack-patch to 8.4 (all supported versions).  The non-comment hstore\nchanges touch code that did not exist in 8.4, so that part stops at 9.0.\n\nNoah Misch and Heikki Linnakangas, reviewed by Tom Lane.\n\nSecurity: CVE-2014-0064",
    "before_after_code_files": [
      "contrib/hstore/hstore.h||contrib/hstore/hstore.h",
      "contrib/hstore/hstore_io.c||contrib/hstore/hstore_io.c",
      "contrib/hstore/hstore_op.c||contrib/hstore/hstore_op.c",
      "contrib/intarray/_int.h||contrib/intarray/_int.h",
      "contrib/intarray/_int_bool.c||contrib/intarray/_int_bool.c",
      "contrib/ltree/ltree.h||contrib/ltree/ltree.h",
      "contrib/ltree/ltree_io.c||contrib/ltree/ltree_io.c",
      "contrib/ltree/ltxtquery_io.c||contrib/ltree/ltxtquery_io.c",
      "src/backend/utils/adt/geo_ops.c||src/backend/utils/adt/geo_ops.c",
      "src/backend/utils/adt/tsquery.c||src/backend/utils/adt/tsquery.c",
      "src/backend/utils/adt/tsquery_util.c||src/backend/utils/adt/tsquery_util.c",
      "src/backend/utils/adt/txid.c||src/backend/utils/adt/txid.c",
      "src/backend/utils/adt/varbit.c||src/backend/utils/adt/varbit.c",
      "src/include/tsearch/ts_type.h||src/include/tsearch/ts_type.h",
      "src/include/utils/varbit.h||src/include/utils/varbit.h"
    ]
  },
  "patch_diff": {
    "contrib/hstore/hstore.h||contrib/hstore/hstore.h": [
      "File: contrib/hstore/hstore.h -> contrib/hstore/hstore.h"
    ],
    "contrib/hstore/hstore_io.c||contrib/hstore/hstore_io.c": [
      "File: contrib/hstore/hstore_io.c -> contrib/hstore/hstore_io.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "13: #include \"utils/builtins.h\"",
      "14: #include \"utils/json.h\"",
      "15: #include \"utils/lsyscache.h\"",
      "16: #include \"utils/typcache.h\"",
      "18: #include \"hstore.h\"",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "16: #include \"utils/memutils.h\"",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "439:   PG_RETURN_POINTER(out);",
      "440:  }",
      "442:  pairs = palloc(pcount * sizeof(Pairs));",
      "444:  for (i = 0; i < pcount; ++i)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "443:  if (pcount < 0 || pcount > MaxAllocSize / sizeof(Pairs))",
      "444:   ereport(ERROR,",
      "445:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
      "446:      errmsg(\"number of pairs (%d) exceeds the maximum allowed (%d)\",",
      "447:       pcount, (int) (MaxAllocSize / sizeof(Pairs)))));",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "554:        TEXTOID, -1, false, 'i',",
      "555:        &key_datums, &key_nulls, &key_count);",
      "559:  if (PG_ARGISNULL(1))",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "564:  if (key_count > MaxAllocSize / sizeof(Pairs))",
      "565:   ereport(ERROR,",
      "566:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
      "567:      errmsg(\"number of pairs (%d) exceeds the maximum allowed (%d)\",",
      "568:       key_count, (int) (MaxAllocSize / sizeof(Pairs)))));",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "677:  count = in_count / 2;",
      "679:  pairs = palloc(count * sizeof(Pairs));",
      "681:  for (i = 0; i < count; ++i)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "693:  if (count > MaxAllocSize / sizeof(Pairs))",
      "694:   ereport(ERROR,",
      "695:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
      "696:      errmsg(\"number of pairs (%d) exceeds the maximum allowed (%d)\",",
      "697:       count, (int) (MaxAllocSize / sizeof(Pairs)))));",
      "",
      "---------------"
    ],
    "contrib/hstore/hstore_op.c||contrib/hstore/hstore_op.c": [
      "File: contrib/hstore/hstore_op.c -> contrib/hstore/hstore_op.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "8: #include \"catalog/pg_type.h\"",
      "9: #include \"funcapi.h\"",
      "10: #include \"utils/builtins.h\"",
      "12: #include \"hstore.h\"",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "11: #include \"utils/memutils.h\"",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "90:   return NULL;",
      "91:  }",
      "93:  key_pairs = palloc(sizeof(Pairs) * key_count);",
      "95:  for (i = 0, j = 0; i < key_count; i++)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "101:  if (key_count > MaxAllocSize / sizeof(Pairs))",
      "102:   ereport(ERROR,",
      "103:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
      "104:      errmsg(\"number of pairs (%d) exceeds the maximum allowed (%d)\",",
      "105:       key_count, (int) (MaxAllocSize / sizeof(Pairs)))));",
      "",
      "---------------"
    ],
    "contrib/intarray/_int.h||contrib/intarray/_int.h": [
      "File: contrib/intarray/_int.h -> contrib/intarray/_int.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "5: #define ___INT_H__",
      "7: #include \"utils/array.h\"",
      "10: #define MAXNUMRANGE 100",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "8: #include \"utils/memutils.h\"",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "138: #define HDRSIZEQT offsetof(QUERYTYPE, items)",
      "139: #define COMPUTESIZE(size) ( HDRSIZEQT + (size) * sizeof(ITEM) )",
      "140: #define GETQUERY(x)  ( (x)->items )",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "141: #define QUERYTYPEMAXITEMS ((MaxAllocSize - HDRSIZEQT) / sizeof(ITEM))",
      "",
      "---------------"
    ],
    "contrib/intarray/_int_bool.c||contrib/intarray/_int_bool.c": [
      "File: contrib/intarray/_int_bool.c -> contrib/intarray/_int_bool.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "448: static void",
      "449: findoprnd(ITEM *ptr, int32 *pos)",
      "450: {",
      "451: #ifdef BS_DEBUG",
      "452:  elog(DEBUG3, (ptr[*pos].type == OPR) ?",
      "453:    \"%d  %c\" : \"%d  %d\", *pos, ptr[*pos].val);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "452:  check_stack_depth();",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "508:     (errcode(ERRCODE_INVALID_PARAMETER_VALUE),",
      "509:      errmsg(\"empty query\")));",
      "511:  commonlen = COMPUTESIZE(state.num);",
      "512:  query = (QUERYTYPE *) palloc(commonlen);",
      "513:  SET_VARSIZE(query, commonlen);",
      "514:  query->size = state.num;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "514:  if (state.num > QUERYTYPEMAXITEMS)",
      "515:   ereport(ERROR,",
      "516:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
      "517:   errmsg(\"number of query items (%d) exceeds the maximum allowed (%d)\",",
      "518:       state.num, (int) QUERYTYPEMAXITEMS)));",
      "",
      "---------------"
    ],
    "contrib/ltree/ltree.h||contrib/ltree/ltree.h": [
      "File: contrib/ltree/ltree.h -> contrib/ltree/ltree.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "6: #include \"fmgr.h\"",
      "7: #include \"tsearch/ts_locale.h\"",
      "9: typedef struct",
      "10: {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "8: #include \"utils/memutils.h\"",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "112: #define HDRSIZEQT  MAXALIGN(VARHDRSZ + sizeof(int32))",
      "113: #define COMPUTESIZE(size,lenofoperand) ( HDRSIZEQT + (size) * sizeof(ITEM) + (lenofoperand) )",
      "114: #define GETQUERY(x)  (ITEM*)( (char*)(x)+HDRSIZEQT )",
      "115: #define GETOPERAND(x) ( (char*)GETQUERY(x) + ((ltxtquery*)x)->size * sizeof(ITEM) )",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "115: #define LTXTQUERY_TOO_BIG(size,lenofoperand) \\",
      "116:  ((size) > (MaxAllocSize - HDRSIZEQT - (lenofoperand)) / sizeof(ITEM))",
      "",
      "---------------"
    ],
    "contrib/ltree/ltree_io.c||contrib/ltree/ltree_io.c": [
      "File: contrib/ltree/ltree_io.c -> contrib/ltree/ltree_io.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "8: #include <ctype.h>",
      "10: #include \"ltree.h\"",
      "11: #include \"crc32.h\"",
      "13: PG_FUNCTION_INFO_V1(ltree_in);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "11: #include \"utils/memutils.h\"",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "64:   ptr += charlen;",
      "65:  }",
      "67:  list = lptr = (nodeitem *) palloc(sizeof(nodeitem) * (num + 1));",
      "68:  ptr = buf;",
      "69:  while (*ptr)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "68:  if (num + 1 > MaxAllocSize / sizeof(nodeitem))",
      "69:   ereport(ERROR,",
      "70:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
      "71:     errmsg(\"number of levels (%d) exceeds the maximum allowed (%d)\",",
      "72:      num + 1, (int) (MaxAllocSize / sizeof(nodeitem)))));",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "228:  }",
      "230:  num++;",
      "231:  curqlevel = tmpql = (lquery_level *) palloc0(ITEMSIZE * num);",
      "232:  ptr = buf;",
      "233:  while (*ptr)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "237:  if (num > MaxAllocSize / ITEMSIZE)",
      "238:   ereport(ERROR,",
      "239:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
      "240:     errmsg(\"number of levels (%d) exceeds the maximum allowed (%d)\",",
      "241:      num, (int) (MaxAllocSize / ITEMSIZE))));",
      "",
      "---------------"
    ],
    "contrib/ltree/ltxtquery_io.c||contrib/ltree/ltxtquery_io.c": [
      "File: contrib/ltree/ltxtquery_io.c -> contrib/ltree/ltxtquery_io.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "10: #include \"crc32.h\"",
      "11: #include \"ltree.h\"",
      "13: PG_FUNCTION_INFO_V1(ltxtq_in);",
      "14: Datum  ltxtq_in(PG_FUNCTION_ARGS);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "12: #include \"miscadmin.h\"",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "212:  int32  lenstack = 0;",
      "213:  uint16  flag = 0;",
      "215:  while ((type = gettoken_query(state, &val, &lenval, &strval, &flag)) != END)",
      "216:  {",
      "217:   switch (type)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "217:  check_stack_depth();",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "276: static void",
      "277: findoprnd(ITEM *ptr, int32 *pos)",
      "278: {",
      "279:  if (ptr[*pos].type == VAL || ptr[*pos].type == VALTRUE)",
      "280:  {",
      "281:   ptr[*pos].left = 0;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "284:  check_stack_depth();",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "340:      errmsg(\"syntax error\"),",
      "341:      errdetail(\"Empty query.\")));",
      "344:  commonlen = COMPUTESIZE(state.num, state.sumlen);",
      "345:  query = (ltxtquery *) palloc(commonlen);",
      "346:  SET_VARSIZE(query, commonlen);",
      "347:  query->size = state.num;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "350:  if (LTXTQUERY_TOO_BIG(state.num, state.sumlen))",
      "351:   ereport(ERROR,",
      "352:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
      "353:      errmsg(\"ltxtquery is too large\")));",
      "",
      "---------------"
    ],
    "src/backend/utils/adt/geo_ops.c||src/backend/utils/adt/geo_ops.c": [
      "File: src/backend/utils/adt/geo_ops.c -> src/backend/utils/adt/geo_ops.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1366:  char    *s;",
      "1367:  int   npts;",
      "1368:  int   size;",
      "1369:  int   depth = 0;",
      "1371:  if ((npts = pair_count(str, ',')) <= 0)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1369:  int   base_size;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1384:   depth++;",
      "1385:  }",
      "1388:  path = (PATH *) palloc(size);",
      "1390:  SET_VARSIZE(path, size);",
      "",
      "[Removed Lines]",
      "1387:  size = offsetof(PATH, p[0]) +sizeof(path->p[0]) * npts;",
      "",
      "[Added Lines]",
      "1388:  base_size = sizeof(path->p[0]) * npts;",
      "1389:  size = offsetof(PATH, p[0]) + base_size;",
      "1392:  if (base_size / npts != sizeof(path->p[0]) || size <= base_size)",
      "1393:   ereport(ERROR,",
      "1394:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
      "1395:      errmsg(\"too many points requested\")));",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "3429:  POLYGON    *poly;",
      "3430:  int   npts;",
      "3431:  int   size;",
      "3432:  int   isopen;",
      "3433:  char    *s;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "3441:  int   base_size;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "3437:     (errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),",
      "3438:      errmsg(\"invalid input syntax for type polygon: \\\"%s\\\"\", str)));",
      "3443:  SET_VARSIZE(poly, size);",
      "",
      "[Removed Lines]",
      "3440:  size = offsetof(POLYGON, p[0]) +sizeof(poly->p[0]) * npts;",
      "",
      "[Added Lines]",
      "3450:  base_size = sizeof(poly->p[0]) * npts;",
      "3451:  size = offsetof(POLYGON, p[0]) + base_size;",
      "3454:  if (base_size / npts != sizeof(poly->p[0]) || size <= base_size)",
      "3455:   ereport(ERROR,",
      "3456:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
      "3457:      errmsg(\"too many points requested\")));",
      "",
      "---------------"
    ],
    "src/backend/utils/adt/tsquery.c||src/backend/utils/adt/tsquery.c": [
      "File: src/backend/utils/adt/tsquery.c -> src/backend/utils/adt/tsquery.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "514:   return query;",
      "515:  }",
      "518:  commonlen = COMPUTESIZE(list_length(state.polstr), state.sumlen);",
      "519:  query = (TSQuery) palloc0(commonlen);",
      "520:  SET_VARSIZE(query, commonlen);",
      "521:  query->size = list_length(state.polstr);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "517:  if (TSQUERY_TOO_BIG(list_length(state.polstr), state.sumlen))",
      "518:   ereport(ERROR,",
      "519:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
      "520:      errmsg(\"tsquery is too large\")));",
      "",
      "---------------"
    ],
    "src/backend/utils/adt/tsquery_util.c||src/backend/utils/adt/tsquery_util.c": [
      "File: src/backend/utils/adt/tsquery_util.c -> src/backend/utils/adt/tsquery_util.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "333:  QTN2QTState state;",
      "335:  cntsize(in, &sumlen, &nnode);",
      "336:  len = COMPUTESIZE(nnode, sumlen);",
      "338:  out = (TSQuery) palloc0(len);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "337:  if (TSQUERY_TOO_BIG(nnode, sumlen))",
      "338:   ereport(ERROR,",
      "339:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
      "340:      errmsg(\"tsquery is too large\")));",
      "",
      "---------------"
    ],
    "src/backend/utils/adt/txid.c||src/backend/utils/adt/txid.c": [
      "File: src/backend/utils/adt/txid.c -> src/backend/utils/adt/txid.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "26: #include \"funcapi.h\"",
      "27: #include \"miscadmin.h\"",
      "28: #include \"libpq/pqformat.h\"",
      "29: #include \"utils/builtins.h\"",
      "30: #include \"utils/snapmgr.h\"",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "29: #include \"postmaster/postmaster.h\"",
      "31: #include \"utils/memutils.h\"",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "67: #define TXID_SNAPSHOT_SIZE(nxip) \\",
      "68:  (offsetof(TxidSnapshot, xip) + sizeof(txid) * (nxip))",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "71: #define TXID_SNAPSHOT_MAX_NXIP \\",
      "72:  ((MaxAllocSize - offsetof(TxidSnapshot, xip)) / sizeof(txid))",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "369:  load_xid_epoch(&state);",
      "372:  nxip = cur->xcnt;",
      "373:  size = TXID_SNAPSHOT_SIZE(nxip);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "379:  StaticAssertStmt(MAX_BACKENDS * 2 <= TXID_SNAPSHOT_MAX_NXIP,",
      "380:       \"possible overflow in txid_current_snapshot()\");",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "445:  txid  last = 0;",
      "446:  int   nxip;",
      "447:  int   i;",
      "450:  txid  xmin,",
      "451:     xmax;",
      "458:  nxip = pq_getmsgint(buf, 4);",
      "462:   goto bad_format;",
      "464:  xmin = pq_getmsgint64(buf);",
      "",
      "[Removed Lines]",
      "448:  int   avail;",
      "449:  int   expect;",
      "459:  avail = buf->len - buf->cursor;",
      "460:  expect = 8 + 8 + nxip * 8;",
      "461:  if (nxip < 0 || nxip > avail || expect > avail)",
      "",
      "[Added Lines]",
      "464:  if (nxip < 0 || nxip > TXID_SNAPSHOT_MAX_NXIP)",
      "",
      "---------------"
    ],
    "src/backend/utils/adt/varbit.c||src/backend/utils/adt/varbit.c": [
      "File: src/backend/utils/adt/varbit.c -> src/backend/utils/adt/varbit.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "148:   sp = input_string;",
      "149:  }",
      "151:  slen = strlen(sp);",
      "153:  if (bit_not_hex)",
      "154:   bitlen = slen;",
      "155:  else",
      "156:   bitlen = slen * 4;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "159:  {",
      "160:   if (slen > VARBITMAXLEN / 4)",
      "161:    ereport(ERROR,",
      "162:      (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
      "163:      errmsg(\"bit string length exceeds the maximum allowed (%d)\",",
      "164:       VARBITMAXLEN)));",
      "166:  }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "450:   sp = input_string;",
      "451:  }",
      "453:  slen = strlen(sp);",
      "455:  if (bit_not_hex)",
      "456:   bitlen = slen;",
      "457:  else",
      "458:   bitlen = slen * 4;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "471:  {",
      "472:   if (slen > VARBITMAXLEN / 4)",
      "473:    ereport(ERROR,",
      "474:      (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
      "475:      errmsg(\"bit string length exceeds the maximum allowed (%d)\",",
      "476:       VARBITMAXLEN)));",
      "478:  }",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "944:  bitlen1 = VARBITLEN(arg1);",
      "945:  bitlen2 = VARBITLEN(arg2);",
      "947:  bytelen = VARBITTOTALLEN(bitlen1 + bitlen2);",
      "949:  result = (VarBit *) palloc(bytelen);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "970:  if (bitlen1 > VARBITMAXLEN - bitlen2)",
      "971:   ereport(ERROR,",
      "972:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
      "973:      errmsg(\"bit string length exceeds the maximum allowed (%d)\",",
      "974:       VARBITMAXLEN)));",
      "",
      "---------------"
    ],
    "src/include/tsearch/ts_type.h||src/include/tsearch/ts_type.h": [
      "File: src/include/tsearch/ts_type.h -> src/include/tsearch/ts_type.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "13: #define _PG_TSTYPE_H_",
      "15: #include \"fmgr.h\"",
      "16: #include \"utils/pg_crc.h\"",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "16: #include \"utils/memutils.h\"",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "246: #define COMPUTESIZE(size, lenofoperand) ( HDRSIZETQ + (size) * sizeof(QueryItem) + (lenofoperand) )",
      "249: #define GETQUERY(x)  ((QueryItem*)( (char*)(x)+HDRSIZETQ ))",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "248: #define TSQUERY_TOO_BIG(size, lenofoperand) \\",
      "249:  ((size) > (MaxAllocSize - HDRSIZETQ - (lenofoperand)) / sizeof(QueryItem))",
      "",
      "---------------"
    ],
    "src/include/utils/varbit.h||src/include/utils/varbit.h": [
      "File: src/include/utils/varbit.h -> src/include/utils/varbit.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "15: #ifndef VARBIT_H",
      "16: #define VARBIT_H",
      "18: #include \"fmgr.h\"",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "18: #include <limits.h>",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "54: #define VARBITTOTALLEN(BITLEN) (((BITLEN) + BITS_PER_BYTE-1)/BITS_PER_BYTE + \\",
      "55:          VARHDRSZ + VARBITHDRSZ)",
      "57: #define VARBITEND(PTR)  (((bits8 *) (PTR)) + VARSIZE(PTR))",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "62: #define VARBITMAXLEN  (INT_MAX - BITS_PER_BYTE + 1)",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "2c3203e18551343db11ed9d372cd2a25d65d3f35",
      "candidate_info": {
        "commit_hash": "2c3203e18551343db11ed9d372cd2a25d65d3f35",
        "repo": "postgres/postgres",
        "commit_url": "https://github.com/postgres/postgres/commit/2c3203e18551343db11ed9d372cd2a25d65d3f35",
        "files": [
          "contrib/hstore/hstore.h",
          "contrib/hstore/hstore_io.c",
          "contrib/hstore/hstore_op.c",
          "contrib/intarray/_int.h",
          "contrib/intarray/_int_bool.c",
          "contrib/ltree/ltree.h",
          "contrib/ltree/ltree_io.c",
          "contrib/ltree/ltxtquery_io.c",
          "src/backend/utils/adt/geo_ops.c",
          "src/backend/utils/adt/tsquery.c",
          "src/backend/utils/adt/tsquery_util.c",
          "src/backend/utils/adt/txid.c",
          "src/backend/utils/adt/varbit.c",
          "src/include/tsearch/ts_type.h",
          "src/include/utils/varbit.h"
        ],
        "message": "Predict integer overflow to avoid buffer overruns.\n\nSeveral functions, mostly type input functions, calculated an allocation\nsize such that the calculation wrapped to a small positive value when\narguments implied a sufficiently-large requirement.  Writes past the end\nof the inadvertent small allocation followed shortly thereafter.\nCoverity identified the path_in() vulnerability; code inspection led to\nthe rest.  In passing, add check_stack_depth() to prevent stack overflow\nin related functions.\n\nBack-patch to 8.4 (all supported versions).  The non-comment hstore\nchanges touch code that did not exist in 8.4, so that part stops at 9.0.\n\nNoah Misch and Heikki Linnakangas, reviewed by Tom Lane.\n\nSecurity: CVE-2014-0064",
        "before_after_code_files": [
          "contrib/hstore/hstore.h||contrib/hstore/hstore.h",
          "contrib/hstore/hstore_io.c||contrib/hstore/hstore_io.c",
          "contrib/hstore/hstore_op.c||contrib/hstore/hstore_op.c",
          "contrib/intarray/_int.h||contrib/intarray/_int.h",
          "contrib/intarray/_int_bool.c||contrib/intarray/_int_bool.c",
          "contrib/ltree/ltree.h||contrib/ltree/ltree.h",
          "contrib/ltree/ltree_io.c||contrib/ltree/ltree_io.c",
          "contrib/ltree/ltxtquery_io.c||contrib/ltree/ltxtquery_io.c",
          "src/backend/utils/adt/geo_ops.c||src/backend/utils/adt/geo_ops.c",
          "src/backend/utils/adt/tsquery.c||src/backend/utils/adt/tsquery.c",
          "src/backend/utils/adt/tsquery_util.c||src/backend/utils/adt/tsquery_util.c",
          "src/backend/utils/adt/txid.c||src/backend/utils/adt/txid.c",
          "src/backend/utils/adt/varbit.c||src/backend/utils/adt/varbit.c",
          "src/include/tsearch/ts_type.h||src/include/tsearch/ts_type.h",
          "src/include/utils/varbit.h||src/include/utils/varbit.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "contrib/hstore/hstore.h||contrib/hstore/hstore.h",
            "contrib/hstore/hstore_io.c||contrib/hstore/hstore_io.c",
            "contrib/hstore/hstore_op.c||contrib/hstore/hstore_op.c",
            "contrib/intarray/_int.h||contrib/intarray/_int.h",
            "contrib/intarray/_int_bool.c||contrib/intarray/_int_bool.c",
            "contrib/ltree/ltree.h||contrib/ltree/ltree.h",
            "contrib/ltree/ltree_io.c||contrib/ltree/ltree_io.c",
            "contrib/ltree/ltxtquery_io.c||contrib/ltree/ltxtquery_io.c",
            "src/backend/utils/adt/geo_ops.c||src/backend/utils/adt/geo_ops.c",
            "src/backend/utils/adt/tsquery.c||src/backend/utils/adt/tsquery.c",
            "src/backend/utils/adt/tsquery_util.c||src/backend/utils/adt/tsquery_util.c",
            "src/backend/utils/adt/txid.c||src/backend/utils/adt/txid.c",
            "src/backend/utils/adt/varbit.c||src/backend/utils/adt/varbit.c",
            "src/include/tsearch/ts_type.h||src/include/tsearch/ts_type.h",
            "src/include/utils/varbit.h||src/include/utils/varbit.h"
          ],
          "candidate": [
            "contrib/hstore/hstore.h||contrib/hstore/hstore.h",
            "contrib/hstore/hstore_io.c||contrib/hstore/hstore_io.c",
            "contrib/hstore/hstore_op.c||contrib/hstore/hstore_op.c",
            "contrib/intarray/_int.h||contrib/intarray/_int.h",
            "contrib/intarray/_int_bool.c||contrib/intarray/_int_bool.c",
            "contrib/ltree/ltree.h||contrib/ltree/ltree.h",
            "contrib/ltree/ltree_io.c||contrib/ltree/ltree_io.c",
            "contrib/ltree/ltxtquery_io.c||contrib/ltree/ltxtquery_io.c",
            "src/backend/utils/adt/geo_ops.c||src/backend/utils/adt/geo_ops.c",
            "src/backend/utils/adt/tsquery.c||src/backend/utils/adt/tsquery.c",
            "src/backend/utils/adt/tsquery_util.c||src/backend/utils/adt/tsquery_util.c",
            "src/backend/utils/adt/txid.c||src/backend/utils/adt/txid.c",
            "src/backend/utils/adt/varbit.c||src/backend/utils/adt/varbit.c",
            "src/include/tsearch/ts_type.h||src/include/tsearch/ts_type.h",
            "src/include/utils/varbit.h||src/include/utils/varbit.h"
          ]
        }
      },
      "candidate_diff": {
        "contrib/hstore/hstore.h||contrib/hstore/hstore.h": [
          "File: contrib/hstore/hstore.h -> contrib/hstore/hstore.h"
        ],
        "contrib/hstore/hstore_io.c||contrib/hstore/hstore_io.c": [
          "File: contrib/hstore/hstore_io.c -> contrib/hstore/hstore_io.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "11: #include \"funcapi.h\"",
          "12: #include \"libpq/pqformat.h\"",
          "13: #include \"utils/lsyscache.h\"",
          "14: #include \"utils/typcache.h\"",
          "16: #include \"hstore.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "14: #include \"utils/memutils.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "438:   PG_RETURN_POINTER(out);",
          "439:  }",
          "441:  pairs = palloc(pcount * sizeof(Pairs));",
          "443:  for (i = 0; i < pcount; ++i)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "442:  if (pcount < 0 || pcount > MaxAllocSize / sizeof(Pairs))",
          "443:   ereport(ERROR,",
          "444:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
          "445:      errmsg(\"number of pairs (%d) exceeds the maximum allowed (%d)\",",
          "446:       pcount, (int) (MaxAllocSize / sizeof(Pairs)))));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "553:        TEXTOID, -1, false, 'i',",
          "554:        &key_datums, &key_nulls, &key_count);",
          "558:  if (PG_ARGISNULL(1))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "563:  if (key_count > MaxAllocSize / sizeof(Pairs))",
          "564:   ereport(ERROR,",
          "565:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
          "566:      errmsg(\"number of pairs (%d) exceeds the maximum allowed (%d)\",",
          "567:       key_count, (int) (MaxAllocSize / sizeof(Pairs)))));",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "676:  count = in_count / 2;",
          "678:  pairs = palloc(count * sizeof(Pairs));",
          "680:  for (i = 0; i < count; ++i)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "692:  if (count > MaxAllocSize / sizeof(Pairs))",
          "693:   ereport(ERROR,",
          "694:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
          "695:      errmsg(\"number of pairs (%d) exceeds the maximum allowed (%d)\",",
          "696:       count, (int) (MaxAllocSize / sizeof(Pairs)))));",
          "",
          "---------------"
        ],
        "contrib/hstore/hstore_op.c||contrib/hstore/hstore_op.c": [
          "File: contrib/hstore/hstore_op.c -> contrib/hstore/hstore_op.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "9: #include \"catalog/pg_type.h\"",
          "10: #include \"funcapi.h\"",
          "11: #include \"utils/builtins.h\"",
          "13: #include \"hstore.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "12: #include \"utils/memutils.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "91:   return NULL;",
          "92:  }",
          "94:  key_pairs = palloc(sizeof(Pairs) * key_count);",
          "96:  for (i = 0, j = 0; i < key_count; i++)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "102:  if (key_count > MaxAllocSize / sizeof(Pairs))",
          "103:   ereport(ERROR,",
          "104:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
          "105:      errmsg(\"number of pairs (%d) exceeds the maximum allowed (%d)\",",
          "106:       key_count, (int) (MaxAllocSize / sizeof(Pairs)))));",
          "",
          "---------------"
        ],
        "contrib/intarray/_int.h||contrib/intarray/_int.h": [
          "File: contrib/intarray/_int.h -> contrib/intarray/_int.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "5: #define ___INT_H__",
          "7: #include \"utils/array.h\"",
          "10: #define MAXNUMRANGE 100",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "8: #include \"utils/memutils.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "143: #define HDRSIZEQT (VARHDRSZ + sizeof(int4))",
          "144: #define COMPUTESIZE(size) ( HDRSIZEQT + size * sizeof(ITEM) )",
          "145: #define GETQUERY(x)  (ITEM*)( (char*)(x)+HDRSIZEQT )",
          "147: #define END  0",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "146: #define QUERYTYPEMAXITEMS ((MaxAllocSize - HDRSIZEQT) / sizeof(ITEM))",
          "",
          "---------------"
        ],
        "contrib/intarray/_int_bool.c||contrib/intarray/_int_bool.c": [
          "File: contrib/intarray/_int_bool.c -> contrib/intarray/_int_bool.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "416: static void",
          "417: findoprnd(ITEM *ptr, int4 *pos)",
          "418: {",
          "419: #ifdef BS_DEBUG",
          "420:  elog(DEBUG3, (ptr[*pos].type == OPR) ?",
          "421:    \"%d  %c\" : \"%d  %d\", *pos, ptr[*pos].val);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "420:  check_stack_depth();",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "476:     (errcode(ERRCODE_INVALID_PARAMETER_VALUE),",
          "477:      errmsg(\"empty query\")));",
          "479:  commonlen = COMPUTESIZE(state.num);",
          "480:  query = (QUERYTYPE *) palloc(commonlen);",
          "481:  SET_VARSIZE(query, commonlen);",
          "482:  query->size = state.num;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "482:  if (state.num > QUERYTYPEMAXITEMS)",
          "483:   ereport(ERROR,",
          "484:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
          "485:   errmsg(\"number of query items (%d) exceeds the maximum allowed (%d)\",",
          "486:       state.num, (int) QUERYTYPEMAXITEMS)));",
          "",
          "---------------"
        ],
        "contrib/ltree/ltree.h||contrib/ltree/ltree.h": [
          "File: contrib/ltree/ltree.h -> contrib/ltree/ltree.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "6: #include \"postgres.h\"",
          "7: #include \"fmgr.h\"",
          "8: #include \"tsearch/ts_locale.h\"",
          "10: typedef struct",
          "11: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "9: #include \"utils/memutils.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "113: #define HDRSIZEQT  MAXALIGN(VARHDRSZ + sizeof(int4))",
          "114: #define COMPUTESIZE(size,lenofoperand) ( HDRSIZEQT + (size) * sizeof(ITEM) + (lenofoperand) )",
          "115: #define GETQUERY(x)  (ITEM*)( (char*)(x)+HDRSIZEQT )",
          "116: #define GETOPERAND(x) ( (char*)GETQUERY(x) + ((ltxtquery*)x)->size * sizeof(ITEM) )",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "116: #define LTXTQUERY_TOO_BIG(size,lenofoperand) \\",
          "117:  ((size) > (MaxAllocSize - HDRSIZEQT - (lenofoperand)) / sizeof(ITEM))",
          "",
          "---------------"
        ],
        "contrib/ltree/ltree_io.c||contrib/ltree/ltree_io.c": [
          "File: contrib/ltree/ltree_io.c -> contrib/ltree/ltree_io.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "8: #include <ctype.h>",
          "10: #include \"ltree.h\"",
          "11: #include \"crc32.h\"",
          "13: PG_FUNCTION_INFO_V1(ltree_in);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "11: #include \"utils/memutils.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "64:   ptr += charlen;",
          "65:  }",
          "67:  list = lptr = (nodeitem *) palloc(sizeof(nodeitem) * (num + 1));",
          "68:  ptr = buf;",
          "69:  while (*ptr)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "68:  if (num + 1 > MaxAllocSize / sizeof(nodeitem))",
          "69:   ereport(ERROR,",
          "70:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
          "71:     errmsg(\"number of levels (%d) exceeds the maximum allowed (%d)\",",
          "72:      num + 1, (int) (MaxAllocSize / sizeof(nodeitem)))));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "228:  }",
          "230:  num++;",
          "231:  curqlevel = tmpql = (lquery_level *) palloc0(ITEMSIZE * num);",
          "232:  ptr = buf;",
          "233:  while (*ptr)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "237:  if (num > MaxAllocSize / ITEMSIZE)",
          "238:   ereport(ERROR,",
          "239:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
          "240:     errmsg(\"number of levels (%d) exceeds the maximum allowed (%d)\",",
          "241:      num, (int) (MaxAllocSize / ITEMSIZE))));",
          "",
          "---------------"
        ],
        "contrib/ltree/ltxtquery_io.c||contrib/ltree/ltxtquery_io.c": [
          "File: contrib/ltree/ltxtquery_io.c -> contrib/ltree/ltxtquery_io.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "10: #include \"crc32.h\"",
          "11: #include \"ltree.h\"",
          "13: PG_FUNCTION_INFO_V1(ltxtq_in);",
          "14: Datum  ltxtq_in(PG_FUNCTION_ARGS);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "12: #include \"miscadmin.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "213:  int4  lenstack = 0;",
          "214:  uint16  flag = 0;",
          "216:  while ((type = gettoken_query(state, &val, &lenval, &strval, &flag)) != END)",
          "217:  {",
          "218:   switch (type)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "218:  check_stack_depth();",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "277: static void",
          "278: findoprnd(ITEM *ptr, int4 *pos)",
          "279: {",
          "280:  if (ptr[*pos].type == VAL || ptr[*pos].type == VALTRUE)",
          "281:  {",
          "282:   ptr[*pos].left = 0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "285:  check_stack_depth();",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "341:      errmsg(\"syntax error\"),",
          "342:      errdetail(\"Empty query.\")));",
          "345:  commonlen = COMPUTESIZE(state.num, state.sumlen);",
          "346:  query = (ltxtquery *) palloc(commonlen);",
          "347:  SET_VARSIZE(query, commonlen);",
          "348:  query->size = state.num;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "351:  if (LTXTQUERY_TOO_BIG(state.num, state.sumlen))",
          "352:   ereport(ERROR,",
          "353:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
          "354:      errmsg(\"ltxtquery is too large\")));",
          "",
          "---------------"
        ],
        "src/backend/utils/adt/geo_ops.c||src/backend/utils/adt/geo_ops.c": [
          "File: src/backend/utils/adt/geo_ops.c -> src/backend/utils/adt/geo_ops.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1403:  char    *s;",
          "1404:  int   npts;",
          "1405:  int   size;",
          "1406:  int   depth = 0;",
          "1408:  if ((npts = pair_count(str, ',')) <= 0)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1406:  int   base_size;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1421:   depth++;",
          "1422:  }",
          "1425:  path = (PATH *) palloc(size);",
          "1427:  SET_VARSIZE(path, size);",
          "",
          "[Removed Lines]",
          "1424:  size = offsetof(PATH, p[0]) +sizeof(path->p[0]) * npts;",
          "",
          "[Added Lines]",
          "1425:  base_size = sizeof(path->p[0]) * npts;",
          "1426:  size = offsetof(PATH, p[0]) + base_size;",
          "1429:  if (base_size / npts != sizeof(path->p[0]) || size <= base_size)",
          "1430:   ereport(ERROR,",
          "1431:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
          "1432:      errmsg(\"too many points requested\")));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3465:  POLYGON    *poly;",
          "3466:  int   npts;",
          "3467:  int   size;",
          "3468:  int   isopen;",
          "3469:  char    *s;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3477:  int   base_size;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "3473:     (errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),",
          "3474:      errmsg(\"invalid input syntax for type polygon: \\\"%s\\\"\", str)));",
          "3479:  SET_VARSIZE(poly, size);",
          "",
          "[Removed Lines]",
          "3476:  size = offsetof(POLYGON, p[0]) +sizeof(poly->p[0]) * npts;",
          "",
          "[Added Lines]",
          "3486:  base_size = sizeof(poly->p[0]) * npts;",
          "3487:  size = offsetof(POLYGON, p[0]) + base_size;",
          "3490:  if (base_size / npts != sizeof(poly->p[0]) || size <= base_size)",
          "3491:   ereport(ERROR,",
          "3492:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
          "3493:      errmsg(\"too many points requested\")));",
          "",
          "---------------"
        ],
        "src/backend/utils/adt/tsquery.c||src/backend/utils/adt/tsquery.c": [
          "File: src/backend/utils/adt/tsquery.c -> src/backend/utils/adt/tsquery.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "517:   return query;",
          "518:  }",
          "521:  commonlen = COMPUTESIZE(list_length(state.polstr), state.sumlen);",
          "522:  query = (TSQuery) palloc0(commonlen);",
          "523:  SET_VARSIZE(query, commonlen);",
          "524:  query->size = list_length(state.polstr);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "520:  if (TSQUERY_TOO_BIG(list_length(state.polstr), state.sumlen))",
          "521:   ereport(ERROR,",
          "522:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
          "523:      errmsg(\"tsquery is too large\")));",
          "",
          "---------------"
        ],
        "src/backend/utils/adt/tsquery_util.c||src/backend/utils/adt/tsquery_util.c": [
          "File: src/backend/utils/adt/tsquery_util.c -> src/backend/utils/adt/tsquery_util.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "334:  QTN2QTState state;",
          "336:  cntsize(in, &sumlen, &nnode);",
          "337:  len = COMPUTESIZE(nnode, sumlen);",
          "339:  out = (TSQuery) palloc0(len);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "338:  if (TSQUERY_TOO_BIG(nnode, sumlen))",
          "339:   ereport(ERROR,",
          "340:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
          "341:      errmsg(\"tsquery is too large\")));",
          "",
          "---------------"
        ],
        "src/backend/utils/adt/txid.c||src/backend/utils/adt/txid.c": [
          "File: src/backend/utils/adt/txid.c -> src/backend/utils/adt/txid.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "27: #include \"miscadmin.h\"",
          "28: #include \"libpq/pqformat.h\"",
          "29: #include \"utils/builtins.h\"",
          "30: #include \"utils/snapmgr.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "30: #include \"utils/memutils.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "67: #define TXID_SNAPSHOT_SIZE(nxip) \\",
          "68:  (offsetof(TxidSnapshot, xip) + sizeof(txid) * (nxip))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "70: #define TXID_SNAPSHOT_MAX_NXIP \\",
          "71:  ((MaxAllocSize - offsetof(TxidSnapshot, xip)) / sizeof(txid))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "444:  txid  last = 0;",
          "445:  int   nxip;",
          "446:  int   i;",
          "449:  txid  xmin,",
          "450:     xmax;",
          "457:  nxip = pq_getmsgint(buf, 4);",
          "461:   goto bad_format;",
          "463:  xmin = pq_getmsgint64(buf);",
          "",
          "[Removed Lines]",
          "447:  int   avail;",
          "448:  int   expect;",
          "458:  avail = buf->len - buf->cursor;",
          "459:  expect = 8 + 8 + nxip * 8;",
          "460:  if (nxip < 0 || nxip > avail || expect > avail)",
          "",
          "[Added Lines]",
          "455:  if (nxip < 0 || nxip > TXID_SNAPSHOT_MAX_NXIP)",
          "",
          "---------------"
        ],
        "src/backend/utils/adt/varbit.c||src/backend/utils/adt/varbit.c": [
          "File: src/backend/utils/adt/varbit.c -> src/backend/utils/adt/varbit.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "143:   sp = input_string;",
          "144:  }",
          "146:  slen = strlen(sp);",
          "148:  if (bit_not_hex)",
          "149:   bitlen = slen;",
          "150:  else",
          "151:   bitlen = slen * 4;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "154:  {",
          "155:   if (slen > VARBITMAXLEN / 4)",
          "156:    ereport(ERROR,",
          "157:      (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
          "158:      errmsg(\"bit string length exceeds the maximum allowed (%d)\",",
          "159:       VARBITMAXLEN)));",
          "161:  }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "441:   sp = input_string;",
          "442:  }",
          "444:  slen = strlen(sp);",
          "446:  if (bit_not_hex)",
          "447:   bitlen = slen;",
          "448:  else",
          "449:   bitlen = slen * 4;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "462:  {",
          "463:   if (slen > VARBITMAXLEN / 4)",
          "464:    ereport(ERROR,",
          "465:      (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
          "466:      errmsg(\"bit string length exceeds the maximum allowed (%d)\",",
          "467:       VARBITMAXLEN)));",
          "469:  }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "898:  bitlen1 = VARBITLEN(arg1);",
          "899:  bitlen2 = VARBITLEN(arg2);",
          "901:  bytelen = VARBITTOTALLEN(bitlen1 + bitlen2);",
          "903:  result = (VarBit *) palloc(bytelen);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "924:  if (bitlen1 > VARBITMAXLEN - bitlen2)",
          "925:   ereport(ERROR,",
          "926:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
          "927:      errmsg(\"bit string length exceeds the maximum allowed (%d)\",",
          "928:       VARBITMAXLEN)));",
          "",
          "---------------"
        ],
        "src/include/tsearch/ts_type.h||src/include/tsearch/ts_type.h": [
          "File: src/include/tsearch/ts_type.h -> src/include/tsearch/ts_type.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "13: #define _PG_TSTYPE_H_",
          "15: #include \"fmgr.h\"",
          "16: #include \"utils/pg_crc.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "16: #include \"utils/memutils.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "244: #define COMPUTESIZE(size, lenofoperand) ( HDRSIZETQ + (size) * sizeof(QueryItem) + (lenofoperand) )",
          "247: #define GETQUERY(x)  ((QueryItem*)( (char*)(x)+HDRSIZETQ ))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "246: #define TSQUERY_TOO_BIG(size, lenofoperand) \\",
          "247:  ((size) > (MaxAllocSize - HDRSIZETQ - (lenofoperand)) / sizeof(QueryItem))",
          "",
          "---------------"
        ],
        "src/include/utils/varbit.h||src/include/utils/varbit.h": [
          "File: src/include/utils/varbit.h -> src/include/utils/varbit.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "15: #ifndef VARBIT_H",
          "16: #define VARBIT_H",
          "18: #include \"fmgr.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "18: #include <limits.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "54: #define VARBITTOTALLEN(BITLEN) (((BITLEN) + BITS_PER_BYTE-1)/BITS_PER_BYTE + \\",
          "55:          VARHDRSZ + VARBITHDRSZ)",
          "57: #define VARBITEND(PTR)  (((bits8 *) (PTR)) + VARSIZE(PTR))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "62: #define VARBITMAXLEN  (INT_MAX - BITS_PER_BYTE + 1)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "1d701d28a796ea2d1a4d2be9e9ee06209eaea040",
      "candidate_info": {
        "commit_hash": "1d701d28a796ea2d1a4d2be9e9ee06209eaea040",
        "repo": "postgres/postgres",
        "commit_url": "https://github.com/postgres/postgres/commit/1d701d28a796ea2d1a4d2be9e9ee06209eaea040",
        "files": [
          "doc/src/sgml/plhandler.sgml",
          "src/backend/catalog/pg_proc.c",
          "src/backend/commands/functioncmds.c",
          "src/backend/utils/fmgr/fmgr.c",
          "src/include/fmgr.h",
          "src/pl/plperl/plperl.c",
          "src/pl/plpgsql/src/pl_handler.c",
          "src/pl/plpython/plpy_main.c"
        ],
        "message": "Prevent privilege escalation in explicit calls to PL validators.\n\nThe primary role of PL validators is to be called implicitly during\nCREATE FUNCTION, but they are also normal functions that a user can call\nexplicitly.  Add a permissions check to each validator to ensure that a\nuser cannot use explicit validator calls to achieve things he could not\notherwise achieve.  Back-patch to 8.4 (all supported versions).\nNon-core procedural language extensions ought to make the same two-line\nchange to their own validators.\n\nAndres Freund, reviewed by Tom Lane and Noah Misch.\n\nSecurity: CVE-2014-0061",
        "before_after_code_files": [
          "src/backend/catalog/pg_proc.c||src/backend/catalog/pg_proc.c",
          "src/backend/commands/functioncmds.c||src/backend/commands/functioncmds.c",
          "src/backend/utils/fmgr/fmgr.c||src/backend/utils/fmgr/fmgr.c",
          "src/include/fmgr.h||src/include/fmgr.h",
          "src/pl/plperl/plperl.c||src/pl/plperl/plperl.c",
          "src/pl/plpgsql/src/pl_handler.c||src/pl/plpgsql/src/pl_handler.c",
          "src/pl/plpython/plpy_main.c||src/pl/plpython/plpy_main.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/backend/catalog/pg_proc.c||src/backend/catalog/pg_proc.c": [
          "File: src/backend/catalog/pg_proc.c -> src/backend/catalog/pg_proc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "718:  Datum  tmp;",
          "719:  char    *prosrc;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "721:  if (!CheckFunctionValidatorAccess(fcinfo->flinfo->fn_oid, funcoid))",
          "722:   PG_RETURN_VOID();",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "763:  char    *prosrc;",
          "764:  char    *probin;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "769:  if (!CheckFunctionValidatorAccess(fcinfo->flinfo->fn_oid, funcoid))",
          "770:   PG_RETURN_VOID();",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "814:  bool  haspolyarg;",
          "815:  int   i;",
          "817:  tuple = SearchSysCache1(PROCOID, ObjectIdGetDatum(funcoid));",
          "818:  if (!HeapTupleIsValid(tuple))",
          "819:   elog(ERROR, \"cache lookup failed for function %u\", funcoid);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "823:  if (!CheckFunctionValidatorAccess(fcinfo->flinfo->fn_oid, funcoid))",
          "824:   PG_RETURN_VOID();",
          "",
          "---------------"
        ],
        "src/backend/commands/functioncmds.c||src/backend/commands/functioncmds.c": [
          "File: src/backend/commands/functioncmds.c -> src/backend/commands/functioncmds.c"
        ],
        "src/backend/utils/fmgr/fmgr.c||src/backend/utils/fmgr/fmgr.c": [
          "File: src/backend/utils/fmgr/fmgr.c -> src/backend/utils/fmgr/fmgr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "24: #include \"miscadmin.h\"",
          "25: #include \"nodes/nodeFuncs.h\"",
          "26: #include \"pgstat.h\"",
          "27: #include \"utils/builtins.h\"",
          "28: #include \"utils/fmgrtab.h\"",
          "29: #include \"utils/guc.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "27: #include \"utils/acl.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2446:  return false;",
          "2447: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2480: bool",
          "2481: CheckFunctionValidatorAccess(Oid validatorOid, Oid functionOid)",
          "2482: {",
          "2483:  HeapTuple procTup;",
          "2484:  HeapTuple langTup;",
          "2485:  Form_pg_proc procStruct;",
          "2486:  Form_pg_language langStruct;",
          "2487:  AclResult aclresult;",
          "2490:  procTup = SearchSysCache1(PROCOID, ObjectIdGetDatum(functionOid));",
          "2491:  if (!HeapTupleIsValid(procTup))",
          "2492:   elog(ERROR, \"cache lookup failed for function %u\", functionOid);",
          "2493:  procStruct = (Form_pg_proc) GETSTRUCT(procTup);",
          "2499:  langTup = SearchSysCache1(LANGOID, ObjectIdGetDatum(procStruct->prolang));",
          "2500:  if (!HeapTupleIsValid(langTup))",
          "2501:   elog(ERROR, \"cache lookup failed for language %u\", procStruct->prolang);",
          "2502:  langStruct = (Form_pg_language) GETSTRUCT(langTup);",
          "2504:  if (langStruct->lanvalidator != validatorOid)",
          "2505:   ereport(ERROR,",
          "2506:     (errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),",
          "2507:      errmsg(\"language validation function %u called for language %u instead of %u\",",
          "2508:       validatorOid, procStruct->prolang,",
          "2509:       langStruct->lanvalidator)));",
          "2512:  aclresult = pg_language_aclcheck(procStruct->prolang, GetUserId(),",
          "2513:           ACL_USAGE);",
          "2514:  if (aclresult != ACLCHECK_OK)",
          "2515:   aclcheck_error(aclresult, ACL_KIND_LANGUAGE,",
          "2516:         NameStr(langStruct->lanname));",
          "2523:  aclresult = pg_proc_aclcheck(functionOid, GetUserId(), ACL_EXECUTE);",
          "2524:  if (aclresult != ACLCHECK_OK)",
          "2525:   aclcheck_error(aclresult, ACL_KIND_PROC, NameStr(procStruct->proname));",
          "2527:  ReleaseSysCache(procTup);",
          "2528:  ReleaseSysCache(langTup);",
          "2530:  return true;",
          "2531: }",
          "",
          "---------------"
        ],
        "src/include/fmgr.h||src/include/fmgr.h": [
          "File: src/include/fmgr.h -> src/include/fmgr.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "624: extern Oid get_call_expr_argtype(fmNodePtr expr, int argnum);",
          "625: extern bool get_fn_expr_arg_stable(FmgrInfo *flinfo, int argnum);",
          "626: extern bool get_call_expr_arg_stable(fmNodePtr expr, int argnum);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "627: extern bool CheckFunctionValidatorAccess(Oid validatorOid, Oid functionOid);",
          "",
          "---------------"
        ],
        "src/pl/plperl/plperl.c||src/pl/plperl/plperl.c": [
          "File: src/pl/plperl/plperl.c -> src/pl/plperl/plperl.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1847:  bool  istrigger = false;",
          "1848:  int   i;",
          "1851:  tuple = SearchSysCache1(PROCOID, ObjectIdGetDatum(funcoid));",
          "1852:  if (!HeapTupleIsValid(tuple))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1850:  if (!CheckFunctionValidatorAccess(fcinfo->flinfo->fn_oid, funcoid))",
          "1851:   PG_RETURN_VOID();",
          "",
          "---------------"
        ],
        "src/pl/plpgsql/src/pl_handler.c||src/pl/plpgsql/src/pl_handler.c": [
          "File: src/pl/plpgsql/src/pl_handler.c -> src/pl/plpgsql/src/pl_handler.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "227:  bool  istrigger = false;",
          "228:  int   i;",
          "231:  tuple = SearchSysCache1(PROCOID, ObjectIdGetDatum(funcoid));",
          "232:  if (!HeapTupleIsValid(tuple))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "230:  if (!CheckFunctionValidatorAccess(fcinfo->flinfo->fn_oid, funcoid))",
          "231:   PG_RETURN_VOID();",
          "",
          "---------------"
        ],
        "src/pl/plpython/plpy_main.c||src/pl/plpython/plpy_main.c": [
          "File: src/pl/plpython/plpy_main.c -> src/pl/plpython/plpy_main.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "159:  Form_pg_proc procStruct;",
          "160:  bool  is_trigger;",
          "162:  if (!check_function_bodies)",
          "163:  {",
          "164:   PG_RETURN_VOID();",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "162:  if (!CheckFunctionValidatorAccess(fcinfo->flinfo->fn_oid, funcoid))",
          "163:   PG_RETURN_VOID();",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "d0ed1a6c044452a529c1d544647ea1fcb90dcb81",
      "candidate_info": {
        "commit_hash": "d0ed1a6c044452a529c1d544647ea1fcb90dcb81",
        "repo": "postgres/postgres",
        "commit_url": "https://github.com/postgres/postgres/commit/d0ed1a6c044452a529c1d544647ea1fcb90dcb81",
        "files": [
          "src/include/utils/datetime.h",
          "src/interfaces/ecpg/pgtypeslib/datetime.c",
          "src/interfaces/ecpg/pgtypeslib/dt.h",
          "src/interfaces/ecpg/pgtypeslib/dt_common.c",
          "src/interfaces/ecpg/pgtypeslib/interval.c",
          "src/interfaces/ecpg/pgtypeslib/timestamp.c",
          "src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.c",
          "src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.stdout",
          "src/interfaces/ecpg/test/pgtypeslib/dt_test2.pgc",
          "src/test/regress/expected/interval.out",
          "src/test/regress/sql/interval.sql"
        ],
        "message": "Fix handling of wide datetime input/output.\n\nMany server functions use the MAXDATELEN constant to size a buffer for\nparsing or displaying a datetime value.  It was much too small for the\nlongest possible interval output and slightly too small for certain\nvalid timestamp input, particularly input with a long timezone name.\nThe long input was rejected needlessly; the long output caused\ninterval_out() to overrun its buffer.  ECPG's pgtypes library has a copy\nof the vulnerable functions, which bore the same vulnerabilities along\nwith some of its own.  In contrast to the server, certain long inputs\ncaused stack overflow rather than failing cleanly.  Back-patch to 8.4\n(all supported versions).\n\nReported by Daniel Sch\u00fcssler, reviewed by Tom Lane.\n\nSecurity: CVE-2014-0063",
        "before_after_code_files": [
          "src/include/utils/datetime.h||src/include/utils/datetime.h",
          "src/interfaces/ecpg/pgtypeslib/datetime.c||src/interfaces/ecpg/pgtypeslib/datetime.c",
          "src/interfaces/ecpg/pgtypeslib/dt.h||src/interfaces/ecpg/pgtypeslib/dt.h",
          "src/interfaces/ecpg/pgtypeslib/dt_common.c||src/interfaces/ecpg/pgtypeslib/dt_common.c",
          "src/interfaces/ecpg/pgtypeslib/interval.c||src/interfaces/ecpg/pgtypeslib/interval.c",
          "src/interfaces/ecpg/pgtypeslib/timestamp.c||src/interfaces/ecpg/pgtypeslib/timestamp.c",
          "src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.c||src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.c",
          "src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.stdout||src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.stdout",
          "src/interfaces/ecpg/test/pgtypeslib/dt_test2.pgc||src/interfaces/ecpg/test/pgtypeslib/dt_test2.pgc",
          "src/test/regress/sql/interval.sql||src/test/regress/sql/interval.sql"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/include/utils/datetime.h||src/include/utils/datetime.h": [
          "File: src/include/utils/datetime.h -> src/include/utils/datetime.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "188: #define DTK_DATE_M  (DTK_M(YEAR) | DTK_M(MONTH) | DTK_M(DAY))",
          "189: #define DTK_TIME_M  (DTK_M(HOUR) | DTK_M(MINUTE) | DTK_ALL_SECS_M)",
          "199: typedef struct",
          "",
          "[Removed Lines]",
          "191: #define MAXDATELEN  63  /* maximum possible length of an input date",
          "193: #define MAXDATEFIELDS 25  /* maximum possible number of fields in a date",
          "195: #define TOKMAXLEN  10  /* only this many chars are stored in",
          "",
          "[Added Lines]",
          "197: #define MAXDATELEN  128",
          "199: #define MAXDATEFIELDS 25",
          "201: #define TOKMAXLEN  10",
          "",
          "---------------"
        ],
        "src/interfaces/ecpg/pgtypeslib/datetime.c||src/interfaces/ecpg/pgtypeslib/datetime.c": [
          "File: src/interfaces/ecpg/pgtypeslib/datetime.c -> src/interfaces/ecpg/pgtypeslib/datetime.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "61:  int   nf;",
          "62:  char    *field[MAXDATEFIELDS];",
          "63:  int   ftype[MAXDATEFIELDS];",
          "65:  char    *realptr;",
          "66:  char   **ptr = (endptr != NULL) ? endptr : &realptr;",
          "68:  bool  EuroDates = FALSE;",
          "70:  errno = 0;",
          "72:  {",
          "73:   errno = PGTYPES_DATE_BAD_DATE;",
          "74:   return INT_MIN;",
          "",
          "[Removed Lines]",
          "64:  char  lowstr[MAXDATELEN + 1];",
          "71:  if (strlen(str) >= sizeof(lowstr))",
          "",
          "[Added Lines]",
          "64:  char  lowstr[MAXDATELEN + MAXDATEFIELDS];",
          "71:  if (strlen(str) > MAXDATELEN)",
          "",
          "---------------"
        ],
        "src/interfaces/ecpg/pgtypeslib/dt.h||src/interfaces/ecpg/pgtypeslib/dt.h": [
          "File: src/interfaces/ecpg/pgtypeslib/dt.h -> src/interfaces/ecpg/pgtypeslib/dt.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "192: #define DTK_DATE_M  (DTK_M(YEAR) | DTK_M(MONTH) | DTK_M(DAY))",
          "193: #define DTK_TIME_M  (DTK_M(HOUR) | DTK_M(MINUTE) | DTK_M(SECOND))",
          "203: typedef struct",
          "",
          "[Removed Lines]",
          "195: #define MAXDATELEN  63  /* maximum possible length of an input date",
          "197: #define MAXDATEFIELDS 25  /* maximum possible number of fields in a date",
          "199: #define TOKMAXLEN  10  /* only this many chars are stored in",
          "",
          "[Added Lines]",
          "201: #define MAXDATELEN  128",
          "203: #define MAXDATEFIELDS 25",
          "205: #define TOKMAXLEN  10",
          "",
          "---------------"
        ],
        "src/interfaces/ecpg/pgtypeslib/dt_common.c||src/interfaces/ecpg/pgtypeslib/dt_common.c": [
          "File: src/interfaces/ecpg/pgtypeslib/dt_common.c -> src/interfaces/ecpg/pgtypeslib/dt_common.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1143:  if ((cp = strchr(str, '.')) != NULL)",
          "1144:  {",
          "1145: #ifdef HAVE_INT64_TIMESTAMP",
          "1156: #else",
          "",
          "[Removed Lines]",
          "1146:   char  fstr[MAXDATELEN + 1];",
          "1152:   strcpy(fstr, (cp + 1));",
          "1153:   strcpy(fstr + strlen(fstr), \"000000\");",
          "",
          "[Added Lines]",
          "1146:   char  fstr[7];",
          "1147:   int   i;",
          "1149:   cp++;",
          "1159:   for (i = 0; i < 6; i++)",
          "1160:    fstr[i] = *cp != '\\0' ? *cp++ : '0';",
          "1161:   fstr[i] = '\\0';",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1503:   else if (*cp == '.')",
          "1504:   {",
          "1505: #ifdef HAVE_INT64_TIMESTAMP",
          "1516: #else",
          "1517:    str = cp;",
          "",
          "[Removed Lines]",
          "1506:    char  fstr[MAXDATELEN + 1];",
          "1512:    strncpy(fstr, (cp + 1), 7);",
          "1513:    strcpy(fstr + strlen(fstr), \"000000\");",
          "",
          "[Added Lines]",
          "1513:    char  fstr[7];",
          "1514:    int   i;",
          "1516:    cp++;",
          "1526:    for (i = 0; i < 6; i++)",
          "1527:     fstr[i] = *cp != '\\0' ? *cp++ : '0';",
          "1528:    fstr[i] = '\\0';",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1650:  while (*(*endstr) != '\\0')",
          "1651:  {",
          "1652:   field[nf] = lp;",
          "1655:   if (isdigit((unsigned char) *(*endstr)))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1671:   if (nf >= MAXDATEFIELDS)",
          "1672:    return -1;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1792:   nf++;",
          "1795:  }",
          "",
          "[Removed Lines]",
          "1793:   if (nf > MAXDATEFIELDS)",
          "1794:    return -1;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/interfaces/ecpg/pgtypeslib/interval.c||src/interfaces/ecpg/pgtypeslib/interval.c": [
          "File: src/interfaces/ecpg/pgtypeslib/interval.c -> src/interfaces/ecpg/pgtypeslib/interval.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1092:  tm->tm_sec = 0;",
          "1093:  fsec = 0;",
          "1096:  {",
          "1097:   errno = PGTYPES_INTVL_BAD_INTERVAL;",
          "1098:   return NULL;",
          "",
          "[Removed Lines]",
          "1095:  if (strlen(str) >= sizeof(lowstr))",
          "",
          "[Added Lines]",
          "1095:  if (strlen(str) > MAXDATELEN)",
          "",
          "---------------"
        ],
        "src/interfaces/ecpg/pgtypeslib/timestamp.c||src/interfaces/ecpg/pgtypeslib/timestamp.c": [
          "File: src/interfaces/ecpg/pgtypeslib/timestamp.c -> src/interfaces/ecpg/pgtypeslib/timestamp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "299:  char    *realptr;",
          "300:  char   **ptr = (endptr != NULL) ? endptr : &realptr;",
          "303:  {",
          "304:   errno = PGTYPES_TS_BAD_TIMESTAMP;",
          "305:   return (noresult);",
          "",
          "[Removed Lines]",
          "302:  if (strlen(str) >= sizeof(lowstr))",
          "",
          "[Added Lines]",
          "302:  if (strlen(str) > MAXDATELEN)",
          "",
          "---------------"
        ],
        "src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.c||src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.c": [
          "File: src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.c -> src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "45:       \"1999.008\",",
          "46:       \"J2451187\",",
          "47:       \"January 8, 99 BC\",",
          "48:       NULL };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "52:       \"........................Xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"",
          "53:       \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",",
          "55:       \".........................aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"",
          "56:       \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "52:       \"1:59 PDT\",",
          "53:       \"13:24:40 -8:00\",",
          "54:       \"13:24:40.495+3\",",
          "55:       NULL };",
          "57: char *intervals[] = { \"1 minute\",",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "64:       \"13:24:40.123456789+3\",",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "77:  date date1 ;",
          "80:  timestamp ts1 , ts2 ;",
          "83:  char * text ;",
          "86:  interval * i1 ;",
          "89:  date * dc ;",
          "94:  int i, j;",
          "",
          "[Removed Lines]",
          "76: #line 52 \"dt_test2.pgc\"",
          "79: #line 53 \"dt_test2.pgc\"",
          "82: #line 54 \"dt_test2.pgc\"",
          "85: #line 55 \"dt_test2.pgc\"",
          "88: #line 56 \"dt_test2.pgc\"",
          "91: #line 57 \"dt_test2.pgc\"",
          "",
          "[Added Lines]",
          "86: #line 62 \"dt_test2.pgc\"",
          "89: #line 63 \"dt_test2.pgc\"",
          "92: #line 64 \"dt_test2.pgc\"",
          "95: #line 65 \"dt_test2.pgc\"",
          "98: #line 66 \"dt_test2.pgc\"",
          "101: #line 67 \"dt_test2.pgc\"",
          "",
          "---------------"
        ],
        "src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.stdout||src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.stdout": [
          "File: src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.stdout -> src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.stdout",
          "--- Hunk 1 ---",
          "[Context before]",
          "8: TS[3,1]: 1999-01-08 01:59:00",
          "9: TS[3,2]: 1999-01-08 13:24:40",
          "10: TS[3,3]: 1999-01-08 13:24:40.495",
          "11: Date[4]: 1999-01-08 (N - F)",
          "12: TS[4,0]: 1999-01-08 00:04:00",
          "13: TS[4,1]: 1999-01-08 01:59:00",
          "14: TS[4,2]: 1999-01-08 13:24:40",
          "15: TS[4,3]: 1999-01-08 13:24:40.495",
          "16: Date[5]: 1999-01-08 (N - F)",
          "17: TS[5,0]: 1999-01-08 00:04:00",
          "18: TS[5,1]: 1999-01-08 01:59:00",
          "19: TS[5,2]: 1999-01-08 13:24:40",
          "20: TS[5,3]: 1999-01-08 13:24:40.495",
          "21: Date[6]: 1999-01-18 (N - F)",
          "22: TS[6,0]: 1999-01-18 00:04:00",
          "23: TS[6,1]: 1999-01-18 01:59:00",
          "24: TS[6,2]: 1999-01-18 13:24:40",
          "25: TS[6,3]: 1999-01-18 13:24:40.495",
          "26: Date[7]: 2003-01-02 (N - F)",
          "27: TS[7,0]: 2003-01-02 00:04:00",
          "28: TS[7,1]: 2003-01-02 01:59:00",
          "29: TS[7,2]: 2003-01-02 13:24:40",
          "30: TS[7,3]: 2003-01-02 13:24:40.495",
          "31: Date[8]: 1999-01-08 (N - F)",
          "32: TS[8,0]: 1999-01-08 00:04:00",
          "33: TS[8,1]: 1999-01-08 01:59:00",
          "34: TS[8,2]: 1999-01-08 13:24:40",
          "35: TS[8,3]: 1999-01-08 13:24:40.495",
          "36: Date[9]: 1999-01-08 (N - F)",
          "37: TS[9,0]: 1999-01-08 00:04:00",
          "38: TS[9,1]: 1999-01-08 01:59:00",
          "39: TS[9,2]: 1999-01-08 13:24:40",
          "40: TS[9,3]: 1999-01-08 13:24:40.495",
          "41: Date[10]: 1999-01-08 (N - F)",
          "42: TS[10,0]: 1999-01-08 00:04:00",
          "43: TS[10,1]: 1999-01-08 01:59:00",
          "44: TS[10,2]: 1999-01-08 13:24:40",
          "45: TS[10,3]: 1999-01-08 13:24:40.495",
          "46: Date[11]: 1999-01-08 (N - F)",
          "47: TS[11,0]: 1999-01-08 00:04:00",
          "48: TS[11,1]: 1999-01-08 01:59:00",
          "49: TS[11,2]: 1999-01-08 13:24:40",
          "50: TS[11,3]: 1999-01-08 13:24:40.495",
          "51: Date[12]: 1999-01-08 (N - F)",
          "52: TS[12,0]: 1999-01-08 00:04:00",
          "53: TS[12,1]: 1999-01-08 01:59:00",
          "54: TS[12,2]: 1999-01-08 13:24:40",
          "55: TS[12,3]: 1999-01-08 13:24:40.495",
          "56: Date[13]: 2006-01-08 (N - F)",
          "57: TS[13,0]: 2006-01-08 00:04:00",
          "58: TS[13,1]: 2006-01-08 01:59:00",
          "59: TS[13,2]: 2006-01-08 13:24:40",
          "60: TS[13,3]: 2006-01-08 13:24:40.495",
          "61: Date[14]: 1999-01-08 (N - F)",
          "62: TS[14,0]: 1999-01-08 00:04:00",
          "63: TS[14,1]: 1999-01-08 01:59:00",
          "64: TS[14,2]: 1999-01-08 13:24:40",
          "65: TS[14,3]: 1999-01-08 13:24:40.495",
          "66: Date[15]: 1999-01-08 (N - F)",
          "67: TS[15,0]: 1999-01-08 00:04:00",
          "68: TS[15,1]: 1999-01-08 01:59:00",
          "69: TS[15,2]: 1999-01-08 13:24:40",
          "70: TS[15,3]: 1999-01-08 13:24:40.495",
          "71: Date[16]: 1999-01-08 (N - F)",
          "72: TS[16,0]: 1999-01-08 00:04:00",
          "73: TS[16,1]: 1999-01-08 01:59:00",
          "74: TS[16,2]: 1999-01-08 13:24:40",
          "75: TS[16,3]: 1999-01-08 13:24:40.495",
          "76: Date[17]: 1999-01-08 (N - F)",
          "77: TS[17,0]: 1999-01-08 00:04:00",
          "78: TS[17,1]: 1999-01-08 01:59:00",
          "79: TS[17,2]: 1999-01-08 13:24:40",
          "80: TS[17,3]: 1999-01-08 13:24:40.495",
          "81: Date[18]: 1999-01-08 (N - F)",
          "82: TS[18,0]: 1999-01-08 00:04:00",
          "83: TS[18,1]: 1999-01-08 01:59:00",
          "84: TS[18,2]: 1999-01-08 13:24:40",
          "85: TS[18,3]: 1999-01-08 13:24:40.495",
          "86: Date[19]: 0099-01-08 BC (N - F)",
          "87: TS[19,0]: 0099-01-08 00:04:00 BC",
          "88: TS[19,1]: 0099-01-08 01:59:00 BC",
          "89: TS[19,2]: 0099-01-08 13:24:40 BC",
          "90: interval[0]: @ 1 min",
          "91: interval_copy[0]: @ 1 min",
          "92: interval[1]: @ 1 day 12 hours 59 mins 10 secs",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "11: TS[3,4]: 1999-01-08 13:24:40.123456",
          "17: TS[4,4]: 1999-01-08 13:24:40.123456",
          "23: TS[5,4]: 1999-01-08 13:24:40.123456",
          "29: TS[6,4]: 1999-01-18 13:24:40.123456",
          "35: TS[7,4]: 2003-01-02 13:24:40.123456",
          "41: TS[8,4]: 1999-01-08 13:24:40.123456",
          "47: TS[9,4]: 1999-01-08 13:24:40.123456",
          "53: TS[10,4]: 1999-01-08 13:24:40.123456",
          "59: TS[11,4]: 1999-01-08 13:24:40.123456",
          "65: TS[12,4]: 1999-01-08 13:24:40.123456",
          "71: TS[13,4]: 2006-01-08 13:24:40.123456",
          "77: TS[14,4]: 1999-01-08 13:24:40.123456",
          "83: TS[15,4]: 1999-01-08 13:24:40.123456",
          "89: TS[16,4]: 1999-01-08 13:24:40.123456",
          "95: TS[17,4]: 1999-01-08 13:24:40.123456",
          "101: TS[18,4]: 1999-01-08 13:24:40.123456",
          "106: TS[19,4]: 0099-01-08 13:24:40.123456 BC",
          "107: Date[20]: - (N - T)",
          "108: Date[21]: - (N - T)",
          "",
          "---------------"
        ],
        "src/interfaces/ecpg/test/pgtypeslib/dt_test2.pgc||src/interfaces/ecpg/test/pgtypeslib/dt_test2.pgc": [
          "File: src/interfaces/ecpg/test/pgtypeslib/dt_test2.pgc -> src/interfaces/ecpg/test/pgtypeslib/dt_test2.pgc",
          "--- Hunk 1 ---",
          "[Context before]",
          "27:       \"1999.008\",",
          "28:       \"J2451187\",",
          "29:       \"January 8, 99 BC\",",
          "30:       NULL };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "34:       \"........................Xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"",
          "35:       \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",",
          "37:       \".........................aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"",
          "38:       \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "34:       \"1:59 PDT\",",
          "35:       \"13:24:40 -8:00\",",
          "36:       \"13:24:40.495+3\",",
          "37:       NULL };",
          "39: char *intervals[] = { \"1 minute\",",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "46:       \"13:24:40.123456789+3\",",
          "",
          "---------------"
        ],
        "src/test/regress/sql/interval.sql||src/test/regress/sql/interval.sql": [
          "File: src/test/regress/sql/interval.sql -> src/test/regress/sql/interval.sql",
          "--- Hunk 1 ---",
          "[Context before]",
          "108: -- test long interval input",
          "109: select '4 millenniums 5 centuries 4 decades 1 year 4 months 4 days 17 minutes 31 seconds'::interval;",
          "112: -- test justify_hours() and justify_days()",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "111: -- test long interval output",
          "112: select '100000000y 10mon -1000000000d -1000000000h -10min -10.000001s ago'::interval;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "0b7026d964c79515c8df00b37ab41d550bcdcbde",
      "candidate_info": {
        "commit_hash": "0b7026d964c79515c8df00b37ab41d550bcdcbde",
        "repo": "postgres/postgres",
        "commit_url": "https://github.com/postgres/postgres/commit/0b7026d964c79515c8df00b37ab41d550bcdcbde",
        "files": [
          "contrib/hstore/hstore.h",
          "contrib/hstore/hstore_io.c",
          "contrib/hstore/hstore_op.c",
          "contrib/intarray/_int.h",
          "contrib/intarray/_int_bool.c",
          "contrib/ltree/ltree.h",
          "contrib/ltree/ltree_io.c",
          "contrib/ltree/ltxtquery_io.c",
          "src/backend/utils/adt/geo_ops.c",
          "src/backend/utils/adt/tsquery.c",
          "src/backend/utils/adt/tsquery_util.c",
          "src/backend/utils/adt/txid.c",
          "src/backend/utils/adt/varbit.c",
          "src/include/tsearch/ts_type.h",
          "src/include/utils/varbit.h"
        ],
        "message": "Predict integer overflow to avoid buffer overruns.\n\nSeveral functions, mostly type input functions, calculated an allocation\nsize such that the calculation wrapped to a small positive value when\narguments implied a sufficiently-large requirement.  Writes past the end\nof the inadvertent small allocation followed shortly thereafter.\nCoverity identified the path_in() vulnerability; code inspection led to\nthe rest.  In passing, add check_stack_depth() to prevent stack overflow\nin related functions.\n\nBack-patch to 8.4 (all supported versions).  The non-comment hstore\nchanges touch code that did not exist in 8.4, so that part stops at 9.0.\n\nNoah Misch and Heikki Linnakangas, reviewed by Tom Lane.\n\nSecurity: CVE-2014-0064",
        "before_after_code_files": [
          "contrib/hstore/hstore.h||contrib/hstore/hstore.h",
          "contrib/hstore/hstore_io.c||contrib/hstore/hstore_io.c",
          "contrib/hstore/hstore_op.c||contrib/hstore/hstore_op.c",
          "contrib/intarray/_int.h||contrib/intarray/_int.h",
          "contrib/intarray/_int_bool.c||contrib/intarray/_int_bool.c",
          "contrib/ltree/ltree.h||contrib/ltree/ltree.h",
          "contrib/ltree/ltree_io.c||contrib/ltree/ltree_io.c",
          "contrib/ltree/ltxtquery_io.c||contrib/ltree/ltxtquery_io.c",
          "src/backend/utils/adt/geo_ops.c||src/backend/utils/adt/geo_ops.c",
          "src/backend/utils/adt/tsquery.c||src/backend/utils/adt/tsquery.c",
          "src/backend/utils/adt/tsquery_util.c||src/backend/utils/adt/tsquery_util.c",
          "src/backend/utils/adt/txid.c||src/backend/utils/adt/txid.c",
          "src/backend/utils/adt/varbit.c||src/backend/utils/adt/varbit.c",
          "src/include/tsearch/ts_type.h||src/include/tsearch/ts_type.h",
          "src/include/utils/varbit.h||src/include/utils/varbit.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "contrib/hstore/hstore.h||contrib/hstore/hstore.h",
            "contrib/hstore/hstore_io.c||contrib/hstore/hstore_io.c",
            "contrib/hstore/hstore_op.c||contrib/hstore/hstore_op.c",
            "contrib/intarray/_int.h||contrib/intarray/_int.h",
            "contrib/intarray/_int_bool.c||contrib/intarray/_int_bool.c",
            "contrib/ltree/ltree.h||contrib/ltree/ltree.h",
            "contrib/ltree/ltree_io.c||contrib/ltree/ltree_io.c",
            "contrib/ltree/ltxtquery_io.c||contrib/ltree/ltxtquery_io.c",
            "src/backend/utils/adt/geo_ops.c||src/backend/utils/adt/geo_ops.c",
            "src/backend/utils/adt/tsquery.c||src/backend/utils/adt/tsquery.c",
            "src/backend/utils/adt/tsquery_util.c||src/backend/utils/adt/tsquery_util.c",
            "src/backend/utils/adt/txid.c||src/backend/utils/adt/txid.c",
            "src/backend/utils/adt/varbit.c||src/backend/utils/adt/varbit.c",
            "src/include/tsearch/ts_type.h||src/include/tsearch/ts_type.h",
            "src/include/utils/varbit.h||src/include/utils/varbit.h"
          ],
          "candidate": [
            "contrib/hstore/hstore.h||contrib/hstore/hstore.h",
            "contrib/hstore/hstore_io.c||contrib/hstore/hstore_io.c",
            "contrib/hstore/hstore_op.c||contrib/hstore/hstore_op.c",
            "contrib/intarray/_int.h||contrib/intarray/_int.h",
            "contrib/intarray/_int_bool.c||contrib/intarray/_int_bool.c",
            "contrib/ltree/ltree.h||contrib/ltree/ltree.h",
            "contrib/ltree/ltree_io.c||contrib/ltree/ltree_io.c",
            "contrib/ltree/ltxtquery_io.c||contrib/ltree/ltxtquery_io.c",
            "src/backend/utils/adt/geo_ops.c||src/backend/utils/adt/geo_ops.c",
            "src/backend/utils/adt/tsquery.c||src/backend/utils/adt/tsquery.c",
            "src/backend/utils/adt/tsquery_util.c||src/backend/utils/adt/tsquery_util.c",
            "src/backend/utils/adt/txid.c||src/backend/utils/adt/txid.c",
            "src/backend/utils/adt/varbit.c||src/backend/utils/adt/varbit.c",
            "src/include/tsearch/ts_type.h||src/include/tsearch/ts_type.h",
            "src/include/utils/varbit.h||src/include/utils/varbit.h"
          ]
        }
      },
      "candidate_diff": {
        "contrib/hstore/hstore.h||contrib/hstore/hstore.h": [
          "File: contrib/hstore/hstore.h -> contrib/hstore/hstore.h"
        ],
        "contrib/hstore/hstore_io.c||contrib/hstore/hstore_io.c": [
          "File: contrib/hstore/hstore_io.c -> contrib/hstore/hstore_io.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "11: #include \"funcapi.h\"",
          "12: #include \"libpq/pqformat.h\"",
          "13: #include \"utils/lsyscache.h\"",
          "14: #include \"utils/typcache.h\"",
          "16: #include \"hstore.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "14: #include \"utils/memutils.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "438:   PG_RETURN_POINTER(out);",
          "439:  }",
          "441:  pairs = palloc(pcount * sizeof(Pairs));",
          "443:  for (i = 0; i < pcount; ++i)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "442:  if (pcount < 0 || pcount > MaxAllocSize / sizeof(Pairs))",
          "443:   ereport(ERROR,",
          "444:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
          "445:      errmsg(\"number of pairs (%d) exceeds the maximum allowed (%d)\",",
          "446:       pcount, (int) (MaxAllocSize / sizeof(Pairs)))));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "553:        TEXTOID, -1, false, 'i',",
          "554:        &key_datums, &key_nulls, &key_count);",
          "558:  if (PG_ARGISNULL(1))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "563:  if (key_count > MaxAllocSize / sizeof(Pairs))",
          "564:   ereport(ERROR,",
          "565:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
          "566:      errmsg(\"number of pairs (%d) exceeds the maximum allowed (%d)\",",
          "567:       key_count, (int) (MaxAllocSize / sizeof(Pairs)))));",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "676:  count = in_count / 2;",
          "678:  pairs = palloc(count * sizeof(Pairs));",
          "680:  for (i = 0; i < count; ++i)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "692:  if (count > MaxAllocSize / sizeof(Pairs))",
          "693:   ereport(ERROR,",
          "694:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
          "695:      errmsg(\"number of pairs (%d) exceeds the maximum allowed (%d)\",",
          "696:       count, (int) (MaxAllocSize / sizeof(Pairs)))));",
          "",
          "---------------"
        ],
        "contrib/hstore/hstore_op.c||contrib/hstore/hstore_op.c": [
          "File: contrib/hstore/hstore_op.c -> contrib/hstore/hstore_op.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "9: #include \"catalog/pg_type.h\"",
          "10: #include \"funcapi.h\"",
          "11: #include \"utils/builtins.h\"",
          "13: #include \"hstore.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "12: #include \"utils/memutils.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "91:   return NULL;",
          "92:  }",
          "94:  key_pairs = palloc(sizeof(Pairs) * key_count);",
          "96:  for (i = 0, j = 0; i < key_count; i++)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "102:  if (key_count > MaxAllocSize / sizeof(Pairs))",
          "103:   ereport(ERROR,",
          "104:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
          "105:      errmsg(\"number of pairs (%d) exceeds the maximum allowed (%d)\",",
          "106:       key_count, (int) (MaxAllocSize / sizeof(Pairs)))));",
          "",
          "---------------"
        ],
        "contrib/intarray/_int.h||contrib/intarray/_int.h": [
          "File: contrib/intarray/_int.h -> contrib/intarray/_int.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "5: #define ___INT_H__",
          "7: #include \"utils/array.h\"",
          "10: #define MAXNUMRANGE 100",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "8: #include \"utils/memutils.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "138: #define HDRSIZEQT offsetof(QUERYTYPE, items)",
          "139: #define COMPUTESIZE(size) ( HDRSIZEQT + (size) * sizeof(ITEM) )",
          "140: #define GETQUERY(x)  ( (x)->items )",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "141: #define QUERYTYPEMAXITEMS ((MaxAllocSize - HDRSIZEQT) / sizeof(ITEM))",
          "",
          "---------------"
        ],
        "contrib/intarray/_int_bool.c||contrib/intarray/_int_bool.c": [
          "File: contrib/intarray/_int_bool.c -> contrib/intarray/_int_bool.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "451: static void",
          "452: findoprnd(ITEM *ptr, int4 *pos)",
          "453: {",
          "454: #ifdef BS_DEBUG",
          "455:  elog(DEBUG3, (ptr[*pos].type == OPR) ?",
          "456:    \"%d  %c\" : \"%d  %d\", *pos, ptr[*pos].val);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "455:  check_stack_depth();",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "511:     (errcode(ERRCODE_INVALID_PARAMETER_VALUE),",
          "512:      errmsg(\"empty query\")));",
          "514:  commonlen = COMPUTESIZE(state.num);",
          "515:  query = (QUERYTYPE *) palloc(commonlen);",
          "516:  SET_VARSIZE(query, commonlen);",
          "517:  query->size = state.num;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "517:  if (state.num > QUERYTYPEMAXITEMS)",
          "518:   ereport(ERROR,",
          "519:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
          "520:   errmsg(\"number of query items (%d) exceeds the maximum allowed (%d)\",",
          "521:       state.num, (int) QUERYTYPEMAXITEMS)));",
          "",
          "---------------"
        ],
        "contrib/ltree/ltree.h||contrib/ltree/ltree.h": [
          "File: contrib/ltree/ltree.h -> contrib/ltree/ltree.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "6: #include \"postgres.h\"",
          "7: #include \"fmgr.h\"",
          "8: #include \"tsearch/ts_locale.h\"",
          "10: typedef struct",
          "11: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "9: #include \"utils/memutils.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "113: #define HDRSIZEQT  MAXALIGN(VARHDRSZ + sizeof(int4))",
          "114: #define COMPUTESIZE(size,lenofoperand) ( HDRSIZEQT + (size) * sizeof(ITEM) + (lenofoperand) )",
          "115: #define GETQUERY(x)  (ITEM*)( (char*)(x)+HDRSIZEQT )",
          "116: #define GETOPERAND(x) ( (char*)GETQUERY(x) + ((ltxtquery*)x)->size * sizeof(ITEM) )",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "116: #define LTXTQUERY_TOO_BIG(size,lenofoperand) \\",
          "117:  ((size) > (MaxAllocSize - HDRSIZEQT - (lenofoperand)) / sizeof(ITEM))",
          "",
          "---------------"
        ],
        "contrib/ltree/ltree_io.c||contrib/ltree/ltree_io.c": [
          "File: contrib/ltree/ltree_io.c -> contrib/ltree/ltree_io.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "8: #include <ctype.h>",
          "10: #include \"ltree.h\"",
          "11: #include \"crc32.h\"",
          "13: PG_FUNCTION_INFO_V1(ltree_in);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "11: #include \"utils/memutils.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "64:   ptr += charlen;",
          "65:  }",
          "67:  list = lptr = (nodeitem *) palloc(sizeof(nodeitem) * (num + 1));",
          "68:  ptr = buf;",
          "69:  while (*ptr)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "68:  if (num + 1 > MaxAllocSize / sizeof(nodeitem))",
          "69:   ereport(ERROR,",
          "70:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
          "71:     errmsg(\"number of levels (%d) exceeds the maximum allowed (%d)\",",
          "72:      num + 1, (int) (MaxAllocSize / sizeof(nodeitem)))));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "228:  }",
          "230:  num++;",
          "231:  curqlevel = tmpql = (lquery_level *) palloc0(ITEMSIZE * num);",
          "232:  ptr = buf;",
          "233:  while (*ptr)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "237:  if (num > MaxAllocSize / ITEMSIZE)",
          "238:   ereport(ERROR,",
          "239:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
          "240:     errmsg(\"number of levels (%d) exceeds the maximum allowed (%d)\",",
          "241:      num, (int) (MaxAllocSize / ITEMSIZE))));",
          "",
          "---------------"
        ],
        "contrib/ltree/ltxtquery_io.c||contrib/ltree/ltxtquery_io.c": [
          "File: contrib/ltree/ltxtquery_io.c -> contrib/ltree/ltxtquery_io.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "10: #include \"crc32.h\"",
          "11: #include \"ltree.h\"",
          "13: PG_FUNCTION_INFO_V1(ltxtq_in);",
          "14: Datum  ltxtq_in(PG_FUNCTION_ARGS);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "12: #include \"miscadmin.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "213:  int4  lenstack = 0;",
          "214:  uint16  flag = 0;",
          "216:  while ((type = gettoken_query(state, &val, &lenval, &strval, &flag)) != END)",
          "217:  {",
          "218:   switch (type)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "218:  check_stack_depth();",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "277: static void",
          "278: findoprnd(ITEM *ptr, int4 *pos)",
          "279: {",
          "280:  if (ptr[*pos].type == VAL || ptr[*pos].type == VALTRUE)",
          "281:  {",
          "282:   ptr[*pos].left = 0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "285:  check_stack_depth();",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "341:      errmsg(\"syntax error\"),",
          "342:      errdetail(\"Empty query.\")));",
          "345:  commonlen = COMPUTESIZE(state.num, state.sumlen);",
          "346:  query = (ltxtquery *) palloc(commonlen);",
          "347:  SET_VARSIZE(query, commonlen);",
          "348:  query->size = state.num;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "351:  if (LTXTQUERY_TOO_BIG(state.num, state.sumlen))",
          "352:   ereport(ERROR,",
          "353:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
          "354:      errmsg(\"ltxtquery is too large\")));",
          "",
          "---------------"
        ],
        "src/backend/utils/adt/geo_ops.c||src/backend/utils/adt/geo_ops.c": [
          "File: src/backend/utils/adt/geo_ops.c -> src/backend/utils/adt/geo_ops.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1403:  char    *s;",
          "1404:  int   npts;",
          "1405:  int   size;",
          "1406:  int   depth = 0;",
          "1408:  if ((npts = pair_count(str, ',')) <= 0)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1406:  int   base_size;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1421:   depth++;",
          "1422:  }",
          "1425:  path = (PATH *) palloc(size);",
          "1427:  SET_VARSIZE(path, size);",
          "",
          "[Removed Lines]",
          "1424:  size = offsetof(PATH, p[0]) +sizeof(path->p[0]) * npts;",
          "",
          "[Added Lines]",
          "1425:  base_size = sizeof(path->p[0]) * npts;",
          "1426:  size = offsetof(PATH, p[0]) + base_size;",
          "1429:  if (base_size / npts != sizeof(path->p[0]) || size <= base_size)",
          "1430:   ereport(ERROR,",
          "1431:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
          "1432:      errmsg(\"too many points requested\")));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3465:  POLYGON    *poly;",
          "3466:  int   npts;",
          "3467:  int   size;",
          "3468:  int   isopen;",
          "3469:  char    *s;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3477:  int   base_size;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "3473:     (errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),",
          "3474:      errmsg(\"invalid input syntax for type polygon: \\\"%s\\\"\", str)));",
          "3479:  SET_VARSIZE(poly, size);",
          "",
          "[Removed Lines]",
          "3476:  size = offsetof(POLYGON, p[0]) +sizeof(poly->p[0]) * npts;",
          "",
          "[Added Lines]",
          "3486:  base_size = sizeof(poly->p[0]) * npts;",
          "3487:  size = offsetof(POLYGON, p[0]) + base_size;",
          "3490:  if (base_size / npts != sizeof(poly->p[0]) || size <= base_size)",
          "3491:   ereport(ERROR,",
          "3492:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
          "3493:      errmsg(\"too many points requested\")));",
          "",
          "---------------"
        ],
        "src/backend/utils/adt/tsquery.c||src/backend/utils/adt/tsquery.c": [
          "File: src/backend/utils/adt/tsquery.c -> src/backend/utils/adt/tsquery.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "517:   return query;",
          "518:  }",
          "521:  commonlen = COMPUTESIZE(list_length(state.polstr), state.sumlen);",
          "522:  query = (TSQuery) palloc0(commonlen);",
          "523:  SET_VARSIZE(query, commonlen);",
          "524:  query->size = list_length(state.polstr);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "520:  if (TSQUERY_TOO_BIG(list_length(state.polstr), state.sumlen))",
          "521:   ereport(ERROR,",
          "522:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
          "523:      errmsg(\"tsquery is too large\")));",
          "",
          "---------------"
        ],
        "src/backend/utils/adt/tsquery_util.c||src/backend/utils/adt/tsquery_util.c": [
          "File: src/backend/utils/adt/tsquery_util.c -> src/backend/utils/adt/tsquery_util.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "334:  QTN2QTState state;",
          "336:  cntsize(in, &sumlen, &nnode);",
          "337:  len = COMPUTESIZE(nnode, sumlen);",
          "339:  out = (TSQuery) palloc0(len);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "338:  if (TSQUERY_TOO_BIG(nnode, sumlen))",
          "339:   ereport(ERROR,",
          "340:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
          "341:      errmsg(\"tsquery is too large\")));",
          "",
          "---------------"
        ],
        "src/backend/utils/adt/txid.c||src/backend/utils/adt/txid.c": [
          "File: src/backend/utils/adt/txid.c -> src/backend/utils/adt/txid.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "27: #include \"miscadmin.h\"",
          "28: #include \"libpq/pqformat.h\"",
          "29: #include \"utils/builtins.h\"",
          "30: #include \"utils/snapmgr.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "30: #include \"utils/memutils.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "67: #define TXID_SNAPSHOT_SIZE(nxip) \\",
          "68:  (offsetof(TxidSnapshot, xip) + sizeof(txid) * (nxip))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "70: #define TXID_SNAPSHOT_MAX_NXIP \\",
          "71:  ((MaxAllocSize - offsetof(TxidSnapshot, xip)) / sizeof(txid))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "444:  txid  last = 0;",
          "445:  int   nxip;",
          "446:  int   i;",
          "449:  txid  xmin,",
          "450:     xmax;",
          "457:  nxip = pq_getmsgint(buf, 4);",
          "461:   goto bad_format;",
          "463:  xmin = pq_getmsgint64(buf);",
          "",
          "[Removed Lines]",
          "447:  int   avail;",
          "448:  int   expect;",
          "458:  avail = buf->len - buf->cursor;",
          "459:  expect = 8 + 8 + nxip * 8;",
          "460:  if (nxip < 0 || nxip > avail || expect > avail)",
          "",
          "[Added Lines]",
          "455:  if (nxip < 0 || nxip > TXID_SNAPSHOT_MAX_NXIP)",
          "",
          "---------------"
        ],
        "src/backend/utils/adt/varbit.c||src/backend/utils/adt/varbit.c": [
          "File: src/backend/utils/adt/varbit.c -> src/backend/utils/adt/varbit.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "147:   sp = input_string;",
          "148:  }",
          "150:  slen = strlen(sp);",
          "152:  if (bit_not_hex)",
          "153:   bitlen = slen;",
          "154:  else",
          "155:   bitlen = slen * 4;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "158:  {",
          "159:   if (slen > VARBITMAXLEN / 4)",
          "160:    ereport(ERROR,",
          "161:      (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
          "162:      errmsg(\"bit string length exceeds the maximum allowed (%d)\",",
          "163:       VARBITMAXLEN)));",
          "165:  }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "449:   sp = input_string;",
          "450:  }",
          "452:  slen = strlen(sp);",
          "454:  if (bit_not_hex)",
          "455:   bitlen = slen;",
          "456:  else",
          "457:   bitlen = slen * 4;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "470:  {",
          "471:   if (slen > VARBITMAXLEN / 4)",
          "472:    ereport(ERROR,",
          "473:      (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
          "474:      errmsg(\"bit string length exceeds the maximum allowed (%d)\",",
          "475:       VARBITMAXLEN)));",
          "477:  }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "910:  bitlen1 = VARBITLEN(arg1);",
          "911:  bitlen2 = VARBITLEN(arg2);",
          "913:  bytelen = VARBITTOTALLEN(bitlen1 + bitlen2);",
          "915:  result = (VarBit *) palloc(bytelen);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "936:  if (bitlen1 > VARBITMAXLEN - bitlen2)",
          "937:   ereport(ERROR,",
          "938:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
          "939:      errmsg(\"bit string length exceeds the maximum allowed (%d)\",",
          "940:       VARBITMAXLEN)));",
          "",
          "---------------"
        ],
        "src/include/tsearch/ts_type.h||src/include/tsearch/ts_type.h": [
          "File: src/include/tsearch/ts_type.h -> src/include/tsearch/ts_type.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "13: #define _PG_TSTYPE_H_",
          "15: #include \"fmgr.h\"",
          "16: #include \"utils/pg_crc.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "16: #include \"utils/memutils.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "244: #define COMPUTESIZE(size, lenofoperand) ( HDRSIZETQ + (size) * sizeof(QueryItem) + (lenofoperand) )",
          "247: #define GETQUERY(x)  ((QueryItem*)( (char*)(x)+HDRSIZETQ ))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "246: #define TSQUERY_TOO_BIG(size, lenofoperand) \\",
          "247:  ((size) > (MaxAllocSize - HDRSIZETQ - (lenofoperand)) / sizeof(QueryItem))",
          "",
          "---------------"
        ],
        "src/include/utils/varbit.h||src/include/utils/varbit.h": [
          "File: src/include/utils/varbit.h -> src/include/utils/varbit.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "15: #ifndef VARBIT_H",
          "16: #define VARBIT_H",
          "18: #include \"fmgr.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "18: #include <limits.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "54: #define VARBITTOTALLEN(BITLEN) (((BITLEN) + BITS_PER_BYTE-1)/BITS_PER_BYTE + \\",
          "55:          VARHDRSZ + VARBITHDRSZ)",
          "57: #define VARBITEND(PTR)  (((bits8 *) (PTR)) + VARSIZE(PTR))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "62: #define VARBITMAXLEN  (INT_MAX - BITS_PER_BYTE + 1)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "e4a4fa22352b062bc3548c91fa9bfc6caed7b073",
      "candidate_info": {
        "commit_hash": "e4a4fa22352b062bc3548c91fa9bfc6caed7b073",
        "repo": "postgres/postgres",
        "commit_url": "https://github.com/postgres/postgres/commit/e4a4fa22352b062bc3548c91fa9bfc6caed7b073",
        "files": [
          "src/include/utils/datetime.h",
          "src/interfaces/ecpg/pgtypeslib/datetime.c",
          "src/interfaces/ecpg/pgtypeslib/dt.h",
          "src/interfaces/ecpg/pgtypeslib/dt_common.c",
          "src/interfaces/ecpg/pgtypeslib/interval.c",
          "src/interfaces/ecpg/pgtypeslib/timestamp.c",
          "src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.c",
          "src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.stdout",
          "src/interfaces/ecpg/test/pgtypeslib/dt_test2.pgc",
          "src/test/regress/expected/interval.out",
          "src/test/regress/sql/interval.sql"
        ],
        "message": "Fix handling of wide datetime input/output.\n\nMany server functions use the MAXDATELEN constant to size a buffer for\nparsing or displaying a datetime value.  It was much too small for the\nlongest possible interval output and slightly too small for certain\nvalid timestamp input, particularly input with a long timezone name.\nThe long input was rejected needlessly; the long output caused\ninterval_out() to overrun its buffer.  ECPG's pgtypes library has a copy\nof the vulnerable functions, which bore the same vulnerabilities along\nwith some of its own.  In contrast to the server, certain long inputs\ncaused stack overflow rather than failing cleanly.  Back-patch to 8.4\n(all supported versions).\n\nReported by Daniel Sch\u00fcssler, reviewed by Tom Lane.\n\nSecurity: CVE-2014-0063",
        "before_after_code_files": [
          "src/include/utils/datetime.h||src/include/utils/datetime.h",
          "src/interfaces/ecpg/pgtypeslib/datetime.c||src/interfaces/ecpg/pgtypeslib/datetime.c",
          "src/interfaces/ecpg/pgtypeslib/dt.h||src/interfaces/ecpg/pgtypeslib/dt.h",
          "src/interfaces/ecpg/pgtypeslib/dt_common.c||src/interfaces/ecpg/pgtypeslib/dt_common.c",
          "src/interfaces/ecpg/pgtypeslib/interval.c||src/interfaces/ecpg/pgtypeslib/interval.c",
          "src/interfaces/ecpg/pgtypeslib/timestamp.c||src/interfaces/ecpg/pgtypeslib/timestamp.c",
          "src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.c||src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.c",
          "src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.stdout||src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.stdout",
          "src/interfaces/ecpg/test/pgtypeslib/dt_test2.pgc||src/interfaces/ecpg/test/pgtypeslib/dt_test2.pgc",
          "src/test/regress/sql/interval.sql||src/test/regress/sql/interval.sql"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/include/utils/datetime.h||src/include/utils/datetime.h": [
          "File: src/include/utils/datetime.h -> src/include/utils/datetime.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "188: #define DTK_DATE_M  (DTK_M(YEAR) | DTK_M(MONTH) | DTK_M(DAY))",
          "189: #define DTK_TIME_M  (DTK_M(HOUR) | DTK_M(MINUTE) | DTK_ALL_SECS_M)",
          "199: typedef struct",
          "",
          "[Removed Lines]",
          "191: #define MAXDATELEN  63  /* maximum possible length of an input date",
          "193: #define MAXDATEFIELDS 25  /* maximum possible number of fields in a date",
          "195: #define TOKMAXLEN  10  /* only this many chars are stored in",
          "",
          "[Added Lines]",
          "197: #define MAXDATELEN  128",
          "199: #define MAXDATEFIELDS 25",
          "201: #define TOKMAXLEN  10",
          "",
          "---------------"
        ],
        "src/interfaces/ecpg/pgtypeslib/datetime.c||src/interfaces/ecpg/pgtypeslib/datetime.c": [
          "File: src/interfaces/ecpg/pgtypeslib/datetime.c -> src/interfaces/ecpg/pgtypeslib/datetime.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "60:  int   nf;",
          "61:  char    *field[MAXDATEFIELDS];",
          "62:  int   ftype[MAXDATEFIELDS];",
          "64:  char    *realptr;",
          "65:  char   **ptr = (endptr != NULL) ? endptr : &realptr;",
          "67:  bool  EuroDates = FALSE;",
          "69:  errno = 0;",
          "71:  {",
          "72:   errno = PGTYPES_DATE_BAD_DATE;",
          "73:   return INT_MIN;",
          "",
          "[Removed Lines]",
          "63:  char  lowstr[MAXDATELEN + 1];",
          "70:  if (strlen(str) >= sizeof(lowstr))",
          "",
          "[Added Lines]",
          "63:  char  lowstr[MAXDATELEN + MAXDATEFIELDS];",
          "70:  if (strlen(str) > MAXDATELEN)",
          "",
          "---------------"
        ],
        "src/interfaces/ecpg/pgtypeslib/dt.h||src/interfaces/ecpg/pgtypeslib/dt.h": [
          "File: src/interfaces/ecpg/pgtypeslib/dt.h -> src/interfaces/ecpg/pgtypeslib/dt.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "192: #define DTK_DATE_M  (DTK_M(YEAR) | DTK_M(MONTH) | DTK_M(DAY))",
          "193: #define DTK_TIME_M  (DTK_M(HOUR) | DTK_M(MINUTE) | DTK_M(SECOND))",
          "203: typedef struct",
          "",
          "[Removed Lines]",
          "195: #define MAXDATELEN  63  /* maximum possible length of an input date",
          "197: #define MAXDATEFIELDS 25  /* maximum possible number of fields in a date",
          "199: #define TOKMAXLEN  10  /* only this many chars are stored in",
          "",
          "[Added Lines]",
          "201: #define MAXDATELEN  128",
          "203: #define MAXDATEFIELDS 25",
          "205: #define TOKMAXLEN  10",
          "",
          "---------------"
        ],
        "src/interfaces/ecpg/pgtypeslib/dt_common.c||src/interfaces/ecpg/pgtypeslib/dt_common.c": [
          "File: src/interfaces/ecpg/pgtypeslib/dt_common.c -> src/interfaces/ecpg/pgtypeslib/dt_common.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1171:  if ((cp = strchr(str, '.')) != NULL)",
          "1172:  {",
          "1173: #ifdef HAVE_INT64_TIMESTAMP",
          "1184: #else",
          "",
          "[Removed Lines]",
          "1174:   char  fstr[MAXDATELEN + 1];",
          "1180:   strcpy(fstr, (cp + 1));",
          "1181:   strcpy(fstr + strlen(fstr), \"000000\");",
          "",
          "[Added Lines]",
          "1174:   char  fstr[7];",
          "1175:   int   i;",
          "1177:   cp++;",
          "1187:   for (i = 0; i < 6; i++)",
          "1188:    fstr[i] = *cp != '\\0' ? *cp++ : '0';",
          "1189:   fstr[i] = '\\0';",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1531:   else if (*cp == '.')",
          "1532:   {",
          "1533: #ifdef HAVE_INT64_TIMESTAMP",
          "1544: #else",
          "1545:    str = cp;",
          "",
          "[Removed Lines]",
          "1534:    char  fstr[MAXDATELEN + 1];",
          "1540:    strncpy(fstr, (cp + 1), 7);",
          "1541:    strcpy(fstr + strlen(fstr), \"000000\");",
          "",
          "[Added Lines]",
          "1541:    char  fstr[7];",
          "1542:    int   i;",
          "1544:    cp++;",
          "1554:    for (i = 0; i < 6; i++)",
          "1555:     fstr[i] = *cp != '\\0' ? *cp++ : '0';",
          "1556:    fstr[i] = '\\0';",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1678:  while (*(*endstr) != '\\0')",
          "1679:  {",
          "1680:   field[nf] = lp;",
          "1683:   if (isdigit((unsigned char) *(*endstr)))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1699:   if (nf >= MAXDATEFIELDS)",
          "1700:    return -1;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1820:   nf++;",
          "1823:  }",
          "",
          "[Removed Lines]",
          "1821:   if (nf > MAXDATEFIELDS)",
          "1822:    return -1;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/interfaces/ecpg/pgtypeslib/interval.c||src/interfaces/ecpg/pgtypeslib/interval.c": [
          "File: src/interfaces/ecpg/pgtypeslib/interval.c -> src/interfaces/ecpg/pgtypeslib/interval.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1091:  tm->tm_sec = 0;",
          "1092:  fsec = 0;",
          "1095:  {",
          "1096:   errno = PGTYPES_INTVL_BAD_INTERVAL;",
          "1097:   return NULL;",
          "",
          "[Removed Lines]",
          "1094:  if (strlen(str) >= sizeof(lowstr))",
          "",
          "[Added Lines]",
          "1094:  if (strlen(str) > MAXDATELEN)",
          "",
          "---------------"
        ],
        "src/interfaces/ecpg/pgtypeslib/timestamp.c||src/interfaces/ecpg/pgtypeslib/timestamp.c": [
          "File: src/interfaces/ecpg/pgtypeslib/timestamp.c -> src/interfaces/ecpg/pgtypeslib/timestamp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "297:  char    *realptr;",
          "298:  char   **ptr = (endptr != NULL) ? endptr : &realptr;",
          "301:  {",
          "302:   errno = PGTYPES_TS_BAD_TIMESTAMP;",
          "303:   return (noresult);",
          "",
          "[Removed Lines]",
          "300:  if (strlen(str) >= sizeof(lowstr))",
          "",
          "[Added Lines]",
          "300:  if (strlen(str) > MAXDATELEN)",
          "",
          "---------------"
        ],
        "src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.c||src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.c": [
          "File: src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.c -> src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "45:       \"1999.008\",",
          "46:       \"J2451187\",",
          "47:       \"January 8, 99 BC\",",
          "48:       NULL };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "52:       \"........................Xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"",
          "53:       \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",",
          "55:       \".........................aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"",
          "56:       \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "52:       \"1:59 PDT\",",
          "53:       \"13:24:40 -8:00\",",
          "54:       \"13:24:40.495+3\",",
          "55:       NULL };",
          "57: char *intervals[] = { \"1 minute\",",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "64:       \"13:24:40.123456789+3\",",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "77:  date date1 ;",
          "80:  timestamp ts1 , ts2 ;",
          "83:  char * text ;",
          "86:  interval * i1 ;",
          "89:  date * dc ;",
          "94:  int i, j;",
          "",
          "[Removed Lines]",
          "76: #line 52 \"dt_test2.pgc\"",
          "79: #line 53 \"dt_test2.pgc\"",
          "82: #line 54 \"dt_test2.pgc\"",
          "85: #line 55 \"dt_test2.pgc\"",
          "88: #line 56 \"dt_test2.pgc\"",
          "91: #line 57 \"dt_test2.pgc\"",
          "",
          "[Added Lines]",
          "86: #line 62 \"dt_test2.pgc\"",
          "89: #line 63 \"dt_test2.pgc\"",
          "92: #line 64 \"dt_test2.pgc\"",
          "95: #line 65 \"dt_test2.pgc\"",
          "98: #line 66 \"dt_test2.pgc\"",
          "101: #line 67 \"dt_test2.pgc\"",
          "",
          "---------------"
        ],
        "src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.stdout||src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.stdout": [
          "File: src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.stdout -> src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.stdout",
          "--- Hunk 1 ---",
          "[Context before]",
          "8: TS[3,1]: 1999-01-08 01:59:00",
          "9: TS[3,2]: 1999-01-08 13:24:40",
          "10: TS[3,3]: 1999-01-08 13:24:40.495",
          "11: Date[4]: 1999-01-08 (N - F)",
          "12: TS[4,0]: 1999-01-08 00:04:00",
          "13: TS[4,1]: 1999-01-08 01:59:00",
          "14: TS[4,2]: 1999-01-08 13:24:40",
          "15: TS[4,3]: 1999-01-08 13:24:40.495",
          "16: Date[5]: 1999-01-08 (N - F)",
          "17: TS[5,0]: 1999-01-08 00:04:00",
          "18: TS[5,1]: 1999-01-08 01:59:00",
          "19: TS[5,2]: 1999-01-08 13:24:40",
          "20: TS[5,3]: 1999-01-08 13:24:40.495",
          "21: Date[6]: 1999-01-18 (N - F)",
          "22: TS[6,0]: 1999-01-18 00:04:00",
          "23: TS[6,1]: 1999-01-18 01:59:00",
          "24: TS[6,2]: 1999-01-18 13:24:40",
          "25: TS[6,3]: 1999-01-18 13:24:40.495",
          "26: Date[7]: 2003-01-02 (N - F)",
          "27: TS[7,0]: 2003-01-02 00:04:00",
          "28: TS[7,1]: 2003-01-02 01:59:00",
          "29: TS[7,2]: 2003-01-02 13:24:40",
          "30: TS[7,3]: 2003-01-02 13:24:40.495",
          "31: Date[8]: 1999-01-08 (N - F)",
          "32: TS[8,0]: 1999-01-08 00:04:00",
          "33: TS[8,1]: 1999-01-08 01:59:00",
          "34: TS[8,2]: 1999-01-08 13:24:40",
          "35: TS[8,3]: 1999-01-08 13:24:40.495",
          "36: Date[9]: 1999-01-08 (N - F)",
          "37: TS[9,0]: 1999-01-08 00:04:00",
          "38: TS[9,1]: 1999-01-08 01:59:00",
          "39: TS[9,2]: 1999-01-08 13:24:40",
          "40: TS[9,3]: 1999-01-08 13:24:40.495",
          "41: Date[10]: 1999-01-08 (N - F)",
          "42: TS[10,0]: 1999-01-08 00:04:00",
          "43: TS[10,1]: 1999-01-08 01:59:00",
          "44: TS[10,2]: 1999-01-08 13:24:40",
          "45: TS[10,3]: 1999-01-08 13:24:40.495",
          "46: Date[11]: 1999-01-08 (N - F)",
          "47: TS[11,0]: 1999-01-08 00:04:00",
          "48: TS[11,1]: 1999-01-08 01:59:00",
          "49: TS[11,2]: 1999-01-08 13:24:40",
          "50: TS[11,3]: 1999-01-08 13:24:40.495",
          "51: Date[12]: 1999-01-08 (N - F)",
          "52: TS[12,0]: 1999-01-08 00:04:00",
          "53: TS[12,1]: 1999-01-08 01:59:00",
          "54: TS[12,2]: 1999-01-08 13:24:40",
          "55: TS[12,3]: 1999-01-08 13:24:40.495",
          "56: Date[13]: 2006-01-08 (N - F)",
          "57: TS[13,0]: 2006-01-08 00:04:00",
          "58: TS[13,1]: 2006-01-08 01:59:00",
          "59: TS[13,2]: 2006-01-08 13:24:40",
          "60: TS[13,3]: 2006-01-08 13:24:40.495",
          "61: Date[14]: 1999-01-08 (N - F)",
          "62: TS[14,0]: 1999-01-08 00:04:00",
          "63: TS[14,1]: 1999-01-08 01:59:00",
          "64: TS[14,2]: 1999-01-08 13:24:40",
          "65: TS[14,3]: 1999-01-08 13:24:40.495",
          "66: Date[15]: 1999-01-08 (N - F)",
          "67: TS[15,0]: 1999-01-08 00:04:00",
          "68: TS[15,1]: 1999-01-08 01:59:00",
          "69: TS[15,2]: 1999-01-08 13:24:40",
          "70: TS[15,3]: 1999-01-08 13:24:40.495",
          "71: Date[16]: 1999-01-08 (N - F)",
          "72: TS[16,0]: 1999-01-08 00:04:00",
          "73: TS[16,1]: 1999-01-08 01:59:00",
          "74: TS[16,2]: 1999-01-08 13:24:40",
          "75: TS[16,3]: 1999-01-08 13:24:40.495",
          "76: Date[17]: 1999-01-08 (N - F)",
          "77: TS[17,0]: 1999-01-08 00:04:00",
          "78: TS[17,1]: 1999-01-08 01:59:00",
          "79: TS[17,2]: 1999-01-08 13:24:40",
          "80: TS[17,3]: 1999-01-08 13:24:40.495",
          "81: Date[18]: 1999-01-08 (N - F)",
          "82: TS[18,0]: 1999-01-08 00:04:00",
          "83: TS[18,1]: 1999-01-08 01:59:00",
          "84: TS[18,2]: 1999-01-08 13:24:40",
          "85: TS[18,3]: 1999-01-08 13:24:40.495",
          "86: Date[19]: 0099-01-08 BC (N - F)",
          "87: TS[19,0]: 0099-01-08 00:04:00 BC",
          "88: TS[19,1]: 0099-01-08 01:59:00 BC",
          "89: TS[19,2]: 0099-01-08 13:24:40 BC",
          "90: interval[0]: @ 1 min",
          "91: interval_copy[0]: @ 1 min",
          "92: interval[1]: @ 1 day 12 hours 59 mins 10 secs",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "11: TS[3,4]: 1999-01-08 13:24:40.123456",
          "17: TS[4,4]: 1999-01-08 13:24:40.123456",
          "23: TS[5,4]: 1999-01-08 13:24:40.123456",
          "29: TS[6,4]: 1999-01-18 13:24:40.123456",
          "35: TS[7,4]: 2003-01-02 13:24:40.123456",
          "41: TS[8,4]: 1999-01-08 13:24:40.123456",
          "47: TS[9,4]: 1999-01-08 13:24:40.123456",
          "53: TS[10,4]: 1999-01-08 13:24:40.123456",
          "59: TS[11,4]: 1999-01-08 13:24:40.123456",
          "65: TS[12,4]: 1999-01-08 13:24:40.123456",
          "71: TS[13,4]: 2006-01-08 13:24:40.123456",
          "77: TS[14,4]: 1999-01-08 13:24:40.123456",
          "83: TS[15,4]: 1999-01-08 13:24:40.123456",
          "89: TS[16,4]: 1999-01-08 13:24:40.123456",
          "95: TS[17,4]: 1999-01-08 13:24:40.123456",
          "101: TS[18,4]: 1999-01-08 13:24:40.123456",
          "106: TS[19,4]: 0099-01-08 13:24:40.123456 BC",
          "107: Date[20]: - (N - T)",
          "108: Date[21]: - (N - T)",
          "",
          "---------------"
        ],
        "src/interfaces/ecpg/test/pgtypeslib/dt_test2.pgc||src/interfaces/ecpg/test/pgtypeslib/dt_test2.pgc": [
          "File: src/interfaces/ecpg/test/pgtypeslib/dt_test2.pgc -> src/interfaces/ecpg/test/pgtypeslib/dt_test2.pgc",
          "--- Hunk 1 ---",
          "[Context before]",
          "27:       \"1999.008\",",
          "28:       \"J2451187\",",
          "29:       \"January 8, 99 BC\",",
          "30:       NULL };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "34:       \"........................Xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"",
          "35:       \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",",
          "37:       \".........................aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"",
          "38:       \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "34:       \"1:59 PDT\",",
          "35:       \"13:24:40 -8:00\",",
          "36:       \"13:24:40.495+3\",",
          "37:       NULL };",
          "39: char *intervals[] = { \"1 minute\",",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "46:       \"13:24:40.123456789+3\",",
          "",
          "---------------"
        ],
        "src/test/regress/sql/interval.sql||src/test/regress/sql/interval.sql": [
          "File: src/test/regress/sql/interval.sql -> src/test/regress/sql/interval.sql",
          "--- Hunk 1 ---",
          "[Context before]",
          "108: -- test long interval input",
          "109: select '4 millenniums 5 centuries 4 decades 1 year 4 months 4 days 17 minutes 31 seconds'::interval;",
          "112: -- test justify_hours() and justify_days()",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "111: -- test long interval output",
          "112: select '100000000y 10mon -1000000000d -1000000000h -10min -10.000001s ago'::interval;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
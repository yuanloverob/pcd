{
  "cve_id": "CVE-2017-11472",
  "cve_desc": "The acpi_ns_terminate() function in drivers/acpi/acpica/nsutils.c in the Linux kernel before 4.12 does not flush the operand cache and causes a kernel stack dump, which allows local users to obtain sensitive information from kernel memory and bypass the KASLR protection mechanism (in the kernel through 4.9) via a crafted ACPI table.",
  "repo": "torvalds/linux",
  "patch_hash": "3b2d69114fefa474fca542e51119036dceb4aa6f",
  "patch_info": {
    "commit_hash": "3b2d69114fefa474fca542e51119036dceb4aa6f",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/3b2d69114fefa474fca542e51119036dceb4aa6f",
    "files": [
      "drivers/acpi/acpica/nsutils.c"
    ],
    "message": "ACPICA: Namespace: fix operand cache leak\n\nACPICA commit a23325b2e583556eae88ed3f764e457786bf4df6\n\nI found some ACPI operand cache leaks in ACPI early abort cases.\n\nBoot log of ACPI operand cache leak is as follows:\n>[    0.174332] ACPI: Added _OSI(Module Device)\n>[    0.175504] ACPI: Added _OSI(Processor Device)\n>[    0.176010] ACPI: Added _OSI(3.0 _SCP Extensions)\n>[    0.177032] ACPI: Added _OSI(Processor Aggregator Device)\n>[    0.178284] ACPI: SCI (IRQ16705) allocation failed\n>[    0.179352] ACPI Exception: AE_NOT_ACQUIRED, Unable to install\nSystem Control Interrupt handler (20160930/evevent-131)\n>[    0.180008] ACPI: Unable to start the ACPI Interpreter\n>[    0.181125] ACPI Error: Could not remove SCI handler\n(20160930/evmisc-281)\n>[    0.184068] kmem_cache_destroy Acpi-Operand: Slab cache still has\nobjects\n>[    0.185358] CPU: 0 PID: 1 Comm: swapper/0 Not tainted 4.10.0-rc3 #2\n>[    0.186820] Hardware name: innotek gmb_h virtual_box/virtual_box, BIOS\nvirtual_box 12/01/2006\n>[    0.188000] Call Trace:\n>[    0.188000]  ? dump_stack+0x5c/0x7d\n>[    0.188000]  ? kmem_cache_destroy+0x224/0x230\n>[    0.188000]  ? acpi_sleep_proc_init+0x22/0x22\n>[    0.188000]  ? acpi_os_delete_cache+0xa/0xd\n>[    0.188000]  ? acpi_ut_delete_caches+0x3f/0x7b\n>[    0.188000]  ? acpi_terminate+0x5/0xf\n>[    0.188000]  ? acpi_init+0x288/0x32e\n>[    0.188000]  ? __class_create+0x4c/0x80\n>[    0.188000]  ? video_setup+0x7a/0x7a\n>[    0.188000]  ? do_one_initcall+0x4e/0x1b0\n>[    0.188000]  ? kernel_init_freeable+0x194/0x21a\n>[    0.188000]  ? rest_init+0x80/0x80\n>[    0.188000]  ? kernel_init+0xa/0x100\n>[    0.188000]  ? ret_from_fork+0x25/0x30\n\nWhen early abort is occurred due to invalid ACPI information, Linux kernel\nterminates ACPI by calling acpi_terminate() function. The function calls\nacpi_ns_terminate() function to delete namespace data and ACPI operand cache\n(acpi_gbl_module_code_list).\n\nBut the deletion code in acpi_ns_terminate() function is wrapped in\nACPI_EXEC_APP definition, therefore the code is only executed when the\ndefinition exists. If the define doesn't exist, ACPI operand cache\n(acpi_gbl_module_code_list) is leaked, and stack dump is shown in kernel log.\n\nThis causes a security threat because the old kernel (<= 4.9) shows memory\nlocations of kernel functions in stack dump, therefore kernel ASLR can be\nneutralized.\n\nTo fix ACPI operand leak for enhancing security, I made a patch which\nremoves the ACPI_EXEC_APP define in acpi_ns_terminate() function for\nexecuting the deletion code unconditionally.\n\nLink: https://github.com/acpica/acpica/commit/a23325b2\nSigned-off-by: Seunghun Han <kkamagui@gmail.com>\nSigned-off-by: Lv Zheng <lv.zheng@intel.com>\nSigned-off-by: Bob Moore <robert.moore@intel.com>\nSigned-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>",
    "before_after_code_files": [
      "drivers/acpi/acpica/nsutils.c||drivers/acpi/acpica/nsutils.c"
    ]
  },
  "patch_diff": {
    "drivers/acpi/acpica/nsutils.c||drivers/acpi/acpica/nsutils.c": [
      "File: drivers/acpi/acpica/nsutils.c -> drivers/acpi/acpica/nsutils.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "594: void acpi_ns_terminate(void)",
      "595: {",
      "596:  acpi_status status;",
      "598:  ACPI_FUNCTION_TRACE(ns_terminate);",
      "614:  }",
      "",
      "[Removed Lines]",
      "600: #ifdef ACPI_EXEC_APP",
      "601:  {",
      "602:   union acpi_operand_object *prev;",
      "603:   union acpi_operand_object *next;",
      "607:   next = acpi_gbl_module_code_list;",
      "608:   while (next) {",
      "609:    prev = next;",
      "610:    next = next->method.mutex;",
      "612:    acpi_ut_remove_reference(prev);",
      "613:   }",
      "615: #endif",
      "",
      "[Added Lines]",
      "597:  union acpi_operand_object *prev;",
      "598:  union acpi_operand_object *next;",
      "604:  next = acpi_gbl_module_code_list;",
      "605:  while (next) {",
      "606:   prev = next;",
      "607:   next = next->method.mutex;",
      "609:   acpi_ut_remove_reference(prev);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "86c6737963e1c6019168512743908c8ee4e80f06",
      "candidate_info": {
        "commit_hash": "86c6737963e1c6019168512743908c8ee4e80f06",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/86c6737963e1c6019168512743908c8ee4e80f06",
        "files": [
          "drivers/scsi/lpfc/lpfc_crtn.h",
          "drivers/scsi/lpfc/lpfc_debugfs.c",
          "drivers/scsi/lpfc/lpfc_hw4.h",
          "drivers/scsi/lpfc/lpfc_init.c",
          "drivers/scsi/lpfc/lpfc_mbox.c",
          "drivers/scsi/lpfc/lpfc_nvme.c",
          "drivers/scsi/lpfc/lpfc_nvmet.c",
          "drivers/scsi/lpfc/lpfc_nvmet.h",
          "drivers/scsi/lpfc/lpfc_sli.c",
          "drivers/scsi/lpfc/lpfc_sli4.h"
        ],
        "message": "Update ABORT processing for NVMET.\n\nThe driver with nvme had this routine stubbed.\n\nRight now XRI_ABORTED_CQE is not handled and the FC NVMET\nTransport has a new API for the driver.\n\nMissing code path, new NVME abort API\nUpdate ABORT processing for NVMET\n\nThere are 3 new FC NVMET Transport API/ template routines for NVMET:\n\nlpfc_nvmet_xmt_fcp_release\nThis NVMET template callback routine called to release context\nassociated with an IO This routine is ALWAYS called last, even\nif the IO was aborted or completed in error.\n\nlpfc_nvmet_xmt_fcp_abort\nThis NVMET template callback routine called to abort an exchange that\nhas an IO in progress\n\nnvmet_fc_rcv_fcp_req\nWhen the lpfc driver receives an ABTS, this NVME FC transport layer\ncallback routine is called. For this case there are 2 paths thru the\ndriver: the driver either has an outstanding exchange / context for the\nXRI to be aborted or not.  If not, a BA_RJT is issued otherwise a BA_ACC\n\nNVMET Driver abort paths:\n\nThere are 2 paths for aborting an IO. The first one is we receive an IO and\ndecide not to process it because of lack of resources. An unsolicated ABTS\nis immediately sent back to the initiator as a response.\nlpfc_nvmet_unsol_fcp_buffer\n            lpfc_nvmet_unsol_issue_abort  (XMIT_SEQUENCE_WQE)\n\nThe second one is we sent the IO up to the NVMET transport layer to\nprocess, and for some reason the NVME Transport layer decided to abort the\nIO before it completes all its phases. For this case there are 2 paths\nthru the driver:\nthe driver either has an outstanding TSEND/TRECEIVE/TRSP WQE or no\noutstanding WQEs are present for the exchange / context.\nlpfc_nvmet_xmt_fcp_abort\n    if (LPFC_NVMET_IO_INP)\n        lpfc_nvmet_sol_fcp_issue_abort  (ABORT_WQE)\n                lpfc_nvmet_sol_fcp_abort_cmp\n    else\n        lpfc_nvmet_unsol_fcp_issue_abort\n                lpfc_nvmet_unsol_issue_abort  (XMIT_SEQUENCE_WQE)\n                        lpfc_nvmet_unsol_fcp_abort_cmp\n\nContext flags:\nLPFC_NVMET_IOP - his flag signifies an IO is in progress on the exchange.\nLPFC_NVMET_XBUSY  - this flag indicates the IO completed but the firmware\nis still busy with the corresponding exchange. The exchange should not be\nreused until after a XRI_ABORTED_CQE is received for that exchange.\nLPFC_NVMET_ABORT_OP - this flag signifies an ABORT_WQE was issued on the\nexchange.\nLPFC_NVMET_CTX_RLS  - this flag signifies a context free was requested,\nbut we are deferring it due to an XBUSY or ABORT in progress.\n\nA ctxlock is added to the context structure that is used whenever these\nflags are set/read  within the context of an IO.\nThe LPFC_NVMET_CTX_RLS flag is only set in the defer_relase routine when\nthe transport has resolved all IO associated with the buffer. The flag is\ncleared when the CTX is associated with a new IO.\n\nAn exchange can has both an LPFC_NVMET_XBUSY and a LPFC_NVMET_ABORT_OP\ncondition active simultaneously. Both conditions must complete before the\nexchange is freed.\nWhen the abort callback (lpfc_nvmet_xmt_fcp_abort) is envoked:\nIf there is an outstanding IO, the driver will issue an ABORT_WQE. This\nshould result in 3 completions for the exchange:\n1) IO cmpl with XB bit set\n2) Abort WQE cmpl\n3) XRI_ABORTED_CQE cmpl\nFor this scenerio, after completion #1, the NVMET Transport IO rsp\ncallback is called.  After completion #2, no action is taken with respect\nto the exchange / context.  After completion #3, the exchange context is\nfree for re-use on another IO.\n\nIf there is no outstanding activity on the exchange, the driver will send a\nABTS to the Initiator. Upon completion of this WQE, the exchange / context\nis freed for re-use on another IO.\n\nSigned-off-by: Dick Kennedy <dick.kennedy@broadcom.com>\nSigned-off-by: James Smart <james.smart@broadcom.com>\nReviewed-by: Johannes Thumshirn <jthumshirn@suse.de>",
        "before_after_code_files": [
          "drivers/scsi/lpfc/lpfc_crtn.h||drivers/scsi/lpfc/lpfc_crtn.h",
          "drivers/scsi/lpfc/lpfc_debugfs.c||drivers/scsi/lpfc/lpfc_debugfs.c",
          "drivers/scsi/lpfc/lpfc_hw4.h||drivers/scsi/lpfc/lpfc_hw4.h",
          "drivers/scsi/lpfc/lpfc_init.c||drivers/scsi/lpfc/lpfc_init.c",
          "drivers/scsi/lpfc/lpfc_mbox.c||drivers/scsi/lpfc/lpfc_mbox.c",
          "drivers/scsi/lpfc/lpfc_nvme.c||drivers/scsi/lpfc/lpfc_nvme.c",
          "drivers/scsi/lpfc/lpfc_nvmet.c||drivers/scsi/lpfc/lpfc_nvmet.c",
          "drivers/scsi/lpfc/lpfc_nvmet.h||drivers/scsi/lpfc/lpfc_nvmet.h",
          "drivers/scsi/lpfc/lpfc_sli.c||drivers/scsi/lpfc/lpfc_sli.c",
          "drivers/scsi/lpfc/lpfc_sli4.h||drivers/scsi/lpfc/lpfc_sli4.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/scsi/lpfc/lpfc_crtn.h||drivers/scsi/lpfc/lpfc_crtn.h": [
          "File: drivers/scsi/lpfc/lpfc_crtn.h -> drivers/scsi/lpfc/lpfc_crtn.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "25: struct fc_rport;",
          "26: struct fc_frame_header;",
          "27: void lpfc_down_link(struct lpfc_hba *, LPFC_MBOXQ_t *);",
          "28: void lpfc_sli_read_link_ste(struct lpfc_hba *);",
          "29: void lpfc_dump_mem(struct lpfc_hba *, LPFC_MBOXQ_t *, uint16_t, uint16_t);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "27: struct lpfc_nvmet_rcv_ctx;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "245: void lpfc_sli4_rb_free(struct lpfc_hba *, struct hbq_dmabuf *);",
          "246: struct rqb_dmabuf *lpfc_sli4_nvmet_alloc(struct lpfc_hba *phba);",
          "247: void lpfc_sli4_nvmet_free(struct lpfc_hba *phba, struct rqb_dmabuf *dmab);",
          "248: void lpfc_sli4_build_dflt_fcf_record(struct lpfc_hba *, struct fcf_record *,",
          "249:    uint16_t);",
          "250: int lpfc_sli4_rq_put(struct lpfc_queue *hq, struct lpfc_queue *dq,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "249: void lpfc_nvmet_rq_post(struct lpfc_hba *phba, struct lpfc_nvmet_rcv_ctx *ctxp,",
          "250:    struct lpfc_dmabuf *mp);",
          "251: int lpfc_nvmet_rcv_unsol_abort(struct lpfc_vport *vport,",
          "252:           struct fc_frame_header *fc_hdr);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "302: void lpfc_sli_handle_slow_ring_event(struct lpfc_hba *,",
          "303:         struct lpfc_sli_ring *, uint32_t);",
          "304: void lpfc_sli4_handle_received_buffer(struct lpfc_hba *, struct hbq_dmabuf *);",
          "305: void lpfc_sli_def_mbox_cmpl(struct lpfc_hba *, LPFC_MBOXQ_t *);",
          "306: void lpfc_sli4_unreg_rpi_cmpl_clr(struct lpfc_hba *, LPFC_MBOXQ_t *);",
          "307: int lpfc_sli_issue_iocb(struct lpfc_hba *, uint32_t,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "310: void lpfc_sli4_seq_abort_rsp(struct lpfc_vport *vport,",
          "311:         struct fc_frame_header *fc_hdr, bool aborted);",
          "",
          "---------------"
        ],
        "drivers/scsi/lpfc/lpfc_debugfs.c||drivers/scsi/lpfc/lpfc_debugfs.c": [
          "File: drivers/scsi/lpfc/lpfc_debugfs.c -> drivers/scsi/lpfc/lpfc_debugfs.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "745: {",
          "746:  struct lpfc_hba   *phba = vport->phba;",
          "747:  struct lpfc_nvmet_tgtport *tgtp;",
          "748:  int len = 0;",
          "750:  if (phba->nvmet_support) {",
          "751:   if (!phba->targetport)",
          "752:    return len;",
          "753:   tgtp = (struct lpfc_nvmet_tgtport *)phba->targetport->private;",
          "755:     \"\\nNVME Targetport Statistics\\n\");",
          "758:     \"LS: Rcv %08x Drop %08x Abort %08x\\n\",",
          "759:     atomic_read(&tgtp->rcv_ls_req_in),",
          "760:     atomic_read(&tgtp->rcv_ls_req_drop),",
          "761:     atomic_read(&tgtp->xmt_ls_abort));",
          "762:   if (atomic_read(&tgtp->rcv_ls_req_in) !=",
          "763:       atomic_read(&tgtp->rcv_ls_req_out)) {",
          "765:      \"Rcv LS: in %08x != out %08x\\n\",",
          "766:      atomic_read(&tgtp->rcv_ls_req_in),",
          "767:      atomic_read(&tgtp->rcv_ls_req_out));",
          "768:   }",
          "771:     \"LS: Xmt %08x Drop %08x Cmpl %08x Err %08x\\n\",",
          "772:     atomic_read(&tgtp->xmt_ls_rsp),",
          "773:     atomic_read(&tgtp->xmt_ls_drop),",
          "774:     atomic_read(&tgtp->xmt_ls_rsp_cmpl),",
          "775:     atomic_read(&tgtp->xmt_ls_rsp_error));",
          "778:     \"FCP: Rcv %08x Drop %08x\\n\",",
          "779:     atomic_read(&tgtp->rcv_fcp_cmd_in),",
          "780:     atomic_read(&tgtp->rcv_fcp_cmd_drop));",
          "782:   if (atomic_read(&tgtp->rcv_fcp_cmd_in) !=",
          "783:       atomic_read(&tgtp->rcv_fcp_cmd_out)) {",
          "785:      \"Rcv FCP: in %08x != out %08x\\n\",",
          "786:      atomic_read(&tgtp->rcv_fcp_cmd_in),",
          "787:      atomic_read(&tgtp->rcv_fcp_cmd_out));",
          "788:   }",
          "792:     atomic_read(&tgtp->xmt_fcp_read),",
          "793:     atomic_read(&tgtp->xmt_fcp_read_rsp),",
          "794:     atomic_read(&tgtp->xmt_fcp_write),",
          "795:     atomic_read(&tgtp->xmt_fcp_rsp));",
          "798:     \"FCP Rsp: abort %08x drop %08x\\n\",",
          "799:     atomic_read(&tgtp->xmt_fcp_abort),",
          "800:     atomic_read(&tgtp->xmt_fcp_drop));",
          "803:     \"FCP Rsp Cmpl: %08x err %08x drop %08x\\n\",",
          "804:     atomic_read(&tgtp->xmt_fcp_rsp_cmpl),",
          "805:     atomic_read(&tgtp->xmt_fcp_rsp_error),",
          "806:     atomic_read(&tgtp->xmt_fcp_rsp_drop));",
          "809:     \"ABORT: Xmt %08x Err %08x Cmpl %08x\",",
          "810:     atomic_read(&tgtp->xmt_abort_rsp),",
          "811:     atomic_read(&tgtp->xmt_abort_rsp_error),",
          "812:     atomic_read(&tgtp->xmt_abort_cmpl));",
          "815:  } else {",
          "816:   if (!(phba->cfg_enable_fc4_type & LPFC_ENABLE_NVME))",
          "817:    return len;",
          "",
          "[Removed Lines]",
          "754:   len += snprintf(buf+len, size-len,",
          "757:   len += snprintf(buf+len, size-len,",
          "764:    len += snprintf(buf+len, size-len,",
          "770:   len += snprintf(buf+len, size-len,",
          "777:   len += snprintf(buf+len, size-len,",
          "784:    len += snprintf(buf+len, size-len,",
          "790:   len += snprintf(buf+len, size-len,",
          "791:     \"FCP Rsp: read %08x readrsp %08x write %08x rsp %08x\\n\",",
          "797:   len += snprintf(buf+len, size-len,",
          "802:   len += snprintf(buf+len, size-len,",
          "808:   len += snprintf(buf+len, size-len,",
          "814:   len +=  snprintf(buf+len, size-len, \"\\n\");",
          "",
          "[Added Lines]",
          "748:  struct lpfc_nvmet_rcv_ctx *ctxp, *next_ctxp;",
          "750:  int cnt;",
          "756:   len += snprintf(buf + len, size - len,",
          "759:   len += snprintf(buf + len, size - len,",
          "766:    len += snprintf(buf + len, size - len,",
          "772:   len += snprintf(buf + len, size - len,",
          "779:   len += snprintf(buf + len, size - len,",
          "786:    len += snprintf(buf + len, size - len,",
          "792:   len += snprintf(buf + len, size - len,",
          "793:     \"FCP Rsp: read %08x readrsp %08x \"",
          "794:     \"write %08x rsp %08x\\n\",",
          "800:   len += snprintf(buf + len, size - len,",
          "805:   len += snprintf(buf + len, size - len,",
          "811:   len += snprintf(buf + len, size - len,",
          "817:   len +=  snprintf(buf + len, size - len, \"\\n\");",
          "819:   cnt = 0;",
          "820:   spin_lock(&phba->sli4_hba.abts_nvme_buf_list_lock);",
          "821:   list_for_each_entry_safe(ctxp, next_ctxp,",
          "822:     &phba->sli4_hba.lpfc_abts_nvmet_ctx_list,",
          "823:     list) {",
          "824:    cnt++;",
          "825:   }",
          "826:   spin_unlock(&phba->sli4_hba.abts_nvme_buf_list_lock);",
          "827:   if (cnt) {",
          "828:    len += snprintf(buf + len, size - len,",
          "829:      \"ABORT: %d ctx entries\\n\", cnt);",
          "830:    spin_lock(&phba->sli4_hba.abts_nvme_buf_list_lock);",
          "831:    list_for_each_entry_safe(ctxp, next_ctxp,",
          "832:         &phba->sli4_hba.lpfc_abts_nvmet_ctx_list,",
          "833:         list) {",
          "834:     if (len >= (size - LPFC_DEBUG_OUT_LINE_SZ))",
          "835:      break;",
          "836:     len += snprintf(buf + len, size - len,",
          "837:       \"Entry: oxid %x state %x \"",
          "838:       \"flag %x\\n\",",
          "839:       ctxp->oxid, ctxp->state,",
          "840:       ctxp->flag);",
          "841:    }",
          "842:    spin_unlock(&phba->sli4_hba.abts_nvme_buf_list_lock);",
          "843:   }",
          "",
          "---------------"
        ],
        "drivers/scsi/lpfc/lpfc_hw4.h||drivers/scsi/lpfc/lpfc_hw4.h": [
          "File: drivers/scsi/lpfc/lpfc_hw4.h -> drivers/scsi/lpfc/lpfc_hw4.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "2720: #define lpfc_mbx_rq_ftr_rq_ifip_SHIFT  7",
          "2721: #define lpfc_mbx_rq_ftr_rq_ifip_MASK  0x00000001",
          "2722: #define lpfc_mbx_rq_ftr_rq_ifip_WORD  word2",
          "2723: #define lpfc_mbx_rq_ftr_rq_perfh_SHIFT  11",
          "2724: #define lpfc_mbx_rq_ftr_rq_perfh_MASK  0x00000001",
          "2725: #define lpfc_mbx_rq_ftr_rq_perfh_WORD  word2",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2723: #define lpfc_mbx_rq_ftr_rq_iaar_SHIFT  9",
          "2724: #define lpfc_mbx_rq_ftr_rq_iaar_MASK  0x00000001",
          "2725: #define lpfc_mbx_rq_ftr_rq_iaar_WORD  word2",
          "",
          "---------------"
        ],
        "drivers/scsi/lpfc/lpfc_init.c||drivers/scsi/lpfc/lpfc_init.c": [
          "File: drivers/scsi/lpfc/lpfc_init.c -> drivers/scsi/lpfc/lpfc_init.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "42: #include <scsi/scsi_device.h>",
          "43: #include <scsi/scsi_host.h>",
          "44: #include <scsi/scsi_transport_fc.h>",
          "46: #include \"lpfc_hw4.h\"",
          "47: #include \"lpfc_hw.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "45: #include <scsi/scsi_tcq.h>",
          "46: #include <scsi/fc/fc_fs.h>",
          "48: #include <linux/nvme-fc-driver.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "52: #include \"lpfc.h\"",
          "53: #include \"lpfc_scsi.h\"",
          "54: #include \"lpfc_nvme.h\"",
          "55: #include \"lpfc_logmsg.h\"",
          "56: #include \"lpfc_crtn.h\"",
          "57: #include \"lpfc_vport.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "59: #include \"lpfc_nvmet.h\"",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1022: lpfc_hba_down_post_s4(struct lpfc_hba *phba)",
          "1023: {",
          "1024:  struct lpfc_scsi_buf *psb, *psb_next;",
          "1025:  LIST_HEAD(aborts);",
          "1026:  LIST_HEAD(nvme_aborts);",
          "1027:  unsigned long iflag = 0;",
          "1028:  struct lpfc_sglq *sglq_entry = NULL;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1030:  struct lpfc_nvmet_rcv_ctx *ctxp, *ctxp_next;",
          "1033:  LIST_HEAD(nvmet_aborts);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1046:  list_for_each_entry(sglq_entry,",
          "1047:   &phba->sli4_hba.lpfc_abts_els_sgl_list, list)",
          "1048:   sglq_entry->state = SGL_FREED;",
          "1053:  list_splice_init(&phba->sli4_hba.lpfc_abts_els_sgl_list,",
          "1054:    &phba->sli4_hba.lpfc_els_sgl_list);",
          "1060:  spin_unlock(&phba->sli4_hba.sgl_list_lock);",
          "",
          "[Removed Lines]",
          "1049:  list_for_each_entry(sglq_entry,",
          "1050:   &phba->sli4_hba.lpfc_abts_nvmet_sgl_list, list)",
          "1051:   sglq_entry->state = SGL_FREED;",
          "1056:  if (phba->sli4_hba.nvme_wq)",
          "1057:   list_splice_init(&phba->sli4_hba.lpfc_abts_nvmet_sgl_list,",
          "1058:      &phba->sli4_hba.lpfc_nvmet_sgl_list);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1072:   spin_lock(&phba->sli4_hba.abts_nvme_buf_list_lock);",
          "1073:   list_splice_init(&phba->sli4_hba.lpfc_abts_nvme_buf_list,",
          "1074:      &nvme_aborts);",
          "1075:   spin_unlock(&phba->sli4_hba.abts_nvme_buf_list_lock);",
          "1076:  }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1076:   list_splice_init(&phba->sli4_hba.lpfc_abts_nvmet_ctx_list,",
          "1077:      &nvmet_aborts);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1085:  list_splice(&aborts, &phba->lpfc_scsi_buf_list_put);",
          "1086:  spin_unlock_irqrestore(&phba->scsi_buf_list_put_lock, iflag);",
          "1091:  }",
          "1096:  lpfc_sli4_free_sp_events(phba);",
          "1097:  return 0;",
          "",
          "[Removed Lines]",
          "1088:  list_for_each_entry_safe(psb, psb_next, &nvme_aborts, list) {",
          "1089:   psb->pCmd = NULL;",
          "1090:   psb->status = IOSTAT_SUCCESS;",
          "1092:  spin_lock_irqsave(&phba->nvme_buf_list_put_lock, iflag);",
          "1093:  list_splice(&nvme_aborts, &phba->lpfc_nvme_buf_list_put);",
          "1094:  spin_unlock_irqrestore(&phba->nvme_buf_list_put_lock, iflag);",
          "",
          "[Added Lines]",
          "1091:  if (phba->cfg_enable_fc4_type & LPFC_ENABLE_NVME) {",
          "1092:   list_for_each_entry_safe(psb, psb_next, &nvme_aborts, list) {",
          "1093:    psb->pCmd = NULL;",
          "1094:    psb->status = IOSTAT_SUCCESS;",
          "1095:   }",
          "1096:   spin_lock_irqsave(&phba->nvme_buf_list_put_lock, iflag);",
          "1097:   list_splice(&nvme_aborts, &phba->lpfc_nvme_buf_list_put);",
          "1098:   spin_unlock_irqrestore(&phba->nvme_buf_list_put_lock, iflag);",
          "1100:   list_for_each_entry_safe(ctxp, ctxp_next, &nvmet_aborts, list) {",
          "1101:    ctxp->flag &= ~(LPFC_NVMET_XBUSY | LPFC_NVMET_ABORT_OP);",
          "1102:    lpfc_nvmet_rq_post(phba, ctxp, &ctxp->rqb_buffer->hbuf);",
          "1103:   }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "5813:   spin_lock_init(&phba->sli4_hba.abts_nvme_buf_list_lock);",
          "5814:   INIT_LIST_HEAD(&phba->sli4_hba.lpfc_abts_nvme_buf_list);",
          "5816:   INIT_LIST_HEAD(&phba->sli4_hba.sp_nvme_xri_aborted_work_queue);",
          "5817:  }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5825:   INIT_LIST_HEAD(&phba->sli4_hba.lpfc_abts_nvmet_ctx_list);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "6439:  INIT_LIST_HEAD(&phba->sli4_hba.lpfc_els_sgl_list);",
          "6440:  INIT_LIST_HEAD(&phba->sli4_hba.lpfc_abts_els_sgl_list);",
          "6441:  INIT_LIST_HEAD(&phba->sli4_hba.lpfc_nvmet_sgl_list);",
          "6445:  phba->sli4_hba.els_xri_cnt = 0;",
          "",
          "[Removed Lines]",
          "6442:  INIT_LIST_HEAD(&phba->sli4_hba.lpfc_abts_nvmet_sgl_list);",
          "",
          "[Added Lines]",
          "6453:  INIT_LIST_HEAD(&phba->sli4_hba.lpfc_abts_nvmet_ctx_list);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "9966: {",
          "9967:  int wait_time = 0;",
          "9968:  int nvme_xri_cmpl = 1;",
          "9969:  int fcp_xri_cmpl = 1;",
          "9970:  int els_xri_cmpl = list_empty(&phba->sli4_hba.lpfc_abts_els_sgl_list);",
          "9974:  if (phba->cfg_enable_fc4_type & LPFC_ENABLE_FCP)",
          "9975:   fcp_xri_cmpl =",
          "9976:    list_empty(&phba->sli4_hba.lpfc_abts_scsi_buf_list);",
          "9978:   nvme_xri_cmpl =",
          "9979:    list_empty(&phba->sli4_hba.lpfc_abts_nvme_buf_list);",
          "9981:  while (!fcp_xri_cmpl || !els_xri_cmpl || !nvme_xri_cmpl ||",
          "9982:         !nvmet_xri_cmpl) {",
          "",
          "[Removed Lines]",
          "9971:  int nvmet_xri_cmpl =",
          "9972:    list_empty(&phba->sli4_hba.lpfc_abts_nvmet_sgl_list);",
          "9977:  if (phba->cfg_enable_fc4_type & LPFC_ENABLE_NVME)",
          "",
          "[Added Lines]",
          "9980:  int nvmet_xri_cmpl = 1;",
          "9987:  if (phba->cfg_enable_fc4_type & LPFC_ENABLE_NVME) {",
          "9990:   nvmet_xri_cmpl =",
          "9991:    list_empty(&phba->sli4_hba.lpfc_abts_nvmet_ctx_list);",
          "9992:  }",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "10002:    msleep(LPFC_XRI_EXCH_BUSY_WAIT_T1);",
          "10003:    wait_time += LPFC_XRI_EXCH_BUSY_WAIT_T1;",
          "10004:   }",
          "10006:    nvme_xri_cmpl = list_empty(",
          "10007:     &phba->sli4_hba.lpfc_abts_nvme_buf_list);",
          "10009:   if (phba->cfg_enable_fc4_type & LPFC_ENABLE_FCP)",
          "10010:    fcp_xri_cmpl = list_empty(",
          "",
          "[Removed Lines]",
          "10005:   if (phba->cfg_enable_fc4_type & LPFC_ENABLE_NVME)",
          "",
          "[Added Lines]",
          "10018:   if (phba->cfg_enable_fc4_type & LPFC_ENABLE_NVME) {",
          "10021:    nvmet_xri_cmpl = list_empty(",
          "10022:     &phba->sli4_hba.lpfc_abts_nvmet_ctx_list);",
          "10023:   }",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "10013:   els_xri_cmpl =",
          "10014:    list_empty(&phba->sli4_hba.lpfc_abts_els_sgl_list);",
          "10018:  }",
          "10019: }",
          "",
          "[Removed Lines]",
          "10016:   nvmet_xri_cmpl =",
          "10017:    list_empty(&phba->sli4_hba.lpfc_abts_nvmet_sgl_list);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "drivers/scsi/lpfc/lpfc_mbox.c||drivers/scsi/lpfc/lpfc_mbox.c": [
          "File: drivers/scsi/lpfc/lpfc_mbox.c -> drivers/scsi/lpfc/lpfc_mbox.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2083:  if (phba->max_vpi && phba->cfg_enable_npiv)",
          "2084:   bf_set(lpfc_mbx_rq_ftr_rq_npiv, &mboxq->u.mqe.un.req_ftrs, 1);",
          "2087:   bf_set(lpfc_mbx_rq_ftr_rq_mrqp, &mboxq->u.mqe.un.req_ftrs, 1);",
          "2089:  return;",
          "2090: }",
          "",
          "[Removed Lines]",
          "2086:  if (phba->nvmet_support)",
          "",
          "[Added Lines]",
          "2086:  if (phba->nvmet_support) {",
          "2089:    bf_set(lpfc_mbx_rq_ftr_rq_iaab, &mboxq->u.mqe.un.req_ftrs, 0);",
          "2090:    bf_set(lpfc_mbx_rq_ftr_rq_iaar, &mboxq->u.mqe.un.req_ftrs, 0);",
          "2091:  }",
          "",
          "---------------"
        ],
        "drivers/scsi/lpfc/lpfc_nvme.c||drivers/scsi/lpfc/lpfc_nvme.c": [
          "File: drivers/scsi/lpfc/lpfc_nvme.c -> drivers/scsi/lpfc/lpfc_nvme.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "868:     break;",
          "869:    lpfc_printf_vlog(vport, KERN_ERR, LOG_NVME_IOERR,",
          "870:       \"6081 NVME Completion Protocol Error: \"",
          "872:       lpfc_ncmd->status, lpfc_ncmd->result,",
          "873:       wcqe->total_data_placed);",
          "874:    break;",
          "875:   default:",
          "876: out_err:",
          "877:    lpfc_printf_vlog(vport, KERN_ERR, LOG_NVME_IOERR,",
          "879:       \"status x%x result x%x placed x%x\\n\",",
          "880:       lpfc_ncmd->status, lpfc_ncmd->result,",
          "881:       wcqe->total_data_placed);",
          "882:    nCmd->transferred_length = 0;",
          "",
          "[Removed Lines]",
          "871:       \"status x%x result x%x placed x%x\\n\",",
          "878:       \"6072 NVME Completion Error: \"",
          "",
          "[Added Lines]",
          "871:       \"xri %x status x%x result x%x \"",
          "872:       \"placed x%x\\n\",",
          "873:       lpfc_ncmd->cur_iocbq.sli4_xritag,",
          "880:       \"6072 NVME Completion Error: xri %x \"",
          "882:       lpfc_ncmd->cur_iocbq.sli4_xritag,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1429:  phba = vport->phba;",
          "1433:     \"6002 Abort Request to rport DID x%06x \"",
          "1434:     \"for nvme_fc_req %p\\n\",",
          "1435:     pnvme_rport->port_id,",
          "",
          "[Removed Lines]",
          "1432:  lpfc_printf_vlog(vport, KERN_ERR, LOG_NVME_ABTS,",
          "",
          "[Added Lines]",
          "1435:  lpfc_printf_vlog(vport, KERN_INFO, LOG_NVME_ABTS,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1460:  if ((ndlp->nlp_state != NLP_STE_MAPPED_NODE) &&",
          "1461:      !(ndlp->nlp_type & NLP_NVME_TARGET)) {",
          "1463:      \"6048 rport %p, DID x%06x not ready for \"",
          "1464:      \"IO. State x%x, Type x%x\\n\",",
          "1465:      rport, pnvme_rport->port_id,",
          "",
          "[Removed Lines]",
          "1462:   lpfc_printf_vlog(vport, KERN_ERR, LOG_NODE | LOG_NVME_ABTS,",
          "",
          "[Added Lines]",
          "1465:   lpfc_printf_vlog(vport, KERN_ERR, LOG_NVME_ABTS,",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1475:  if (phba->hba_flag & HBA_NVME_IOQ_FLUSH) {",
          "1476:   spin_unlock_irqrestore(&phba->hbalock, flags);",
          "1478:      \"6139 Driver in reset cleanup - flushing \"",
          "1479:      \"NVME Req now.  hba_flag x%x\\n\",",
          "1480:      phba->hba_flag);",
          "",
          "[Removed Lines]",
          "1477:   lpfc_printf_vlog(vport, KERN_ERR, LOG_NVME,",
          "",
          "[Added Lines]",
          "1480:   lpfc_printf_vlog(vport, KERN_ERR, LOG_NVME_ABTS,",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1484:  lpfc_nbuf = (struct lpfc_nvme_buf *)pnvme_fcreq->private;",
          "1485:  if (!lpfc_nbuf) {",
          "1486:   spin_unlock_irqrestore(&phba->hbalock, flags);",
          "1488:      \"6140 NVME IO req has no matching lpfc nvme \"",
          "1489:      \"io buffer.  Skipping abort req.\\n\");",
          "1490:   return;",
          "1491:  } else if (!lpfc_nbuf->nvmeCmd) {",
          "1492:   spin_unlock_irqrestore(&phba->hbalock, flags);",
          "1494:      \"6141 lpfc NVME IO req has no nvme_fcreq \"",
          "1495:      \"io buffer.  Skipping abort req.\\n\");",
          "1496:   return;",
          "",
          "[Removed Lines]",
          "1487:   lpfc_printf_vlog(vport, KERN_ERR, LOG_NVME,",
          "1493:   lpfc_printf_vlog(vport, KERN_ERR, LOG_NVME,",
          "",
          "[Added Lines]",
          "1490:   lpfc_printf_vlog(vport, KERN_ERR, LOG_NVME_ABTS,",
          "1496:   lpfc_printf_vlog(vport, KERN_ERR, LOG_NVME_ABTS,",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1507:  if (lpfc_nbuf->nvmeCmd != pnvme_fcreq) {",
          "1508:   spin_unlock_irqrestore(&phba->hbalock, flags);",
          "1510:      \"6143 NVME req mismatch: \"",
          "1511:      \"lpfc_nbuf %p nvmeCmd %p, \"",
          "1512:      \"pnvme_fcreq %p.  Skipping Abort xri x%x\\n\",",
          "",
          "[Removed Lines]",
          "1509:   lpfc_printf_vlog(vport, KERN_ERR, LOG_NVME,",
          "",
          "[Added Lines]",
          "1512:   lpfc_printf_vlog(vport, KERN_ERR, LOG_NVME_ABTS,",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1519:  if (!(nvmereq_wqe->iocb_flag & LPFC_IO_ON_TXCMPLQ)) {",
          "1520:   spin_unlock_irqrestore(&phba->hbalock, flags);",
          "1522:      \"6142 NVME IO req %p not queued - skipping \"",
          "1523:      \"abort req xri x%x\\n\",",
          "1524:      pnvme_fcreq, nvmereq_wqe->sli4_xritag);",
          "",
          "[Removed Lines]",
          "1521:   lpfc_printf_vlog(vport, KERN_ERR, LOG_NVME,",
          "",
          "[Added Lines]",
          "1524:   lpfc_printf_vlog(vport, KERN_ERR, LOG_NVME_ABTS,",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1533:  if (nvmereq_wqe->iocb_flag & LPFC_DRIVER_ABORTED) {",
          "1534:   spin_unlock_irqrestore(&phba->hbalock, flags);",
          "1536:      \"6144 Outstanding NVME I/O Abort Request \"",
          "1537:      \"still pending on nvme_fcreq %p, \"",
          "1538:      \"lpfc_ncmd %p xri x%x\\n\",",
          "",
          "[Removed Lines]",
          "1535:   lpfc_printf_vlog(vport, KERN_ERR, LOG_NVME,",
          "",
          "[Added Lines]",
          "1538:   lpfc_printf_vlog(vport, KERN_ERR, LOG_NVME_ABTS,",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1544:  abts_buf = __lpfc_sli_get_iocbq(phba);",
          "1545:  if (!abts_buf) {",
          "1546:   spin_unlock_irqrestore(&phba->hbalock, flags);",
          "1548:      \"6136 No available abort wqes. Skipping \"",
          "1549:      \"Abts req for nvme_fcreq %p xri x%x\\n\",",
          "1550:      pnvme_fcreq, nvmereq_wqe->sli4_xritag);",
          "",
          "[Removed Lines]",
          "1547:   lpfc_printf_vlog(vport, KERN_ERR, LOG_NVME,",
          "",
          "[Added Lines]",
          "1550:   lpfc_printf_vlog(vport, KERN_ERR, LOG_NVME_ABTS,",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1596:  ret_val = lpfc_sli4_issue_wqe(phba, LPFC_FCP_RING, abts_buf);",
          "1597:  spin_unlock_irqrestore(&phba->hbalock, flags);",
          "1598:  if (ret_val == IOCB_ERROR) {",
          "1600:      \"6137 Failed abts issue_wqe with status x%x \"",
          "1601:      \"for nvme_fcreq %p.\\n\",",
          "1602:      ret_val, pnvme_fcreq);",
          "",
          "[Removed Lines]",
          "1599:   lpfc_printf_vlog(vport, KERN_ERR, LOG_NVME,",
          "",
          "[Added Lines]",
          "1602:   lpfc_printf_vlog(vport, KERN_ERR, LOG_NVME_ABTS,",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1604:   return;",
          "1605:  }",
          "1608:     \"6138 Transport Abort NVME Request Issued for \"",
          "1609:     \"ox_id x%x on reqtag x%x\\n\",",
          "1610:     nvmereq_wqe->sli4_xritag,",
          "",
          "[Removed Lines]",
          "1607:  lpfc_printf_vlog(vport, KERN_ERR, LOG_NVME,",
          "",
          "[Added Lines]",
          "1610:  lpfc_printf_vlog(vport, KERN_INFO, LOG_NVME_ABTS,",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "2109:  lpfc_ncmd->nonsg_phys = 0;",
          "2110:  if (lpfc_ncmd->flags & LPFC_SBUF_XBUSY) {",
          "2111:   spin_lock_irqsave(&phba->sli4_hba.abts_nvme_buf_list_lock,",
          "2112:      iflag);",
          "2113:   lpfc_ncmd->nvmeCmd = NULL;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2114:   lpfc_printf_log(phba, KERN_INFO, LOG_NVME_ABTS,",
          "2115:     \"6310 XB release deferred for \"",
          "2116:     \"ox_id x%x on reqtag x%x\\n\",",
          "2117:     lpfc_ncmd->cur_iocbq.sli4_xritag,",
          "2118:     lpfc_ncmd->cur_iocbq.iotag);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "2549:      rxid, 1);",
          "2550:     lpfc_sli4_abts_err_handler(phba, ndlp, axri);",
          "2551:    }",
          "2552:    lpfc_release_nvme_buf(phba, lpfc_ncmd);",
          "2553:    if (rrq_empty)",
          "2554:     lpfc_worker_wake_up(phba);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2562:    lpfc_printf_log(phba, KERN_INFO, LOG_NVME_ABTS,",
          "2563:      \"6311 XRI Aborted xri x%x tag x%x \"",
          "2564:      \"released\\n\",",
          "2565:      xri, lpfc_ncmd->cur_iocbq.iotag);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "2557:  }",
          "2558:  spin_unlock(&phba->sli4_hba.abts_nvme_buf_list_lock);",
          "2559:  spin_unlock_irqrestore(&phba->hbalock, iflag);",
          "2560: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2576:  lpfc_printf_log(phba, KERN_INFO, LOG_NVME_ABTS,",
          "2577:    \"6312 XRI Aborted xri x%x not found\\n\", xri);",
          "",
          "---------------"
        ],
        "drivers/scsi/lpfc/lpfc_nvmet.c||drivers/scsi/lpfc/lpfc_nvmet.c": [
          "File: drivers/scsi/lpfc/lpfc_nvmet.c -> drivers/scsi/lpfc/lpfc_nvmet.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "71:         struct lpfc_nvmet_rcv_ctx *,",
          "72:         uint32_t, uint16_t);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "74: void",
          "75: lpfc_nvmet_defer_release(struct lpfc_hba *phba, struct lpfc_nvmet_rcv_ctx *ctxp)",
          "76: {",
          "77:  unsigned long iflag;",
          "79:  lpfc_printf_log(phba, KERN_ERR, LOG_NVME_ABTS,",
          "80:    \"6313 NVMET Defer ctx release xri x%x flg x%x\\n\",",
          "81:    ctxp->oxid, ctxp->flag);",
          "83:  spin_lock_irqsave(&phba->sli4_hba.abts_nvme_buf_list_lock, iflag);",
          "84:  if (ctxp->flag & LPFC_NVMET_CTX_RLS) {",
          "85:   spin_unlock_irqrestore(&phba->sli4_hba.abts_nvme_buf_list_lock,",
          "86:            iflag);",
          "87:   return;",
          "88:  }",
          "89:  ctxp->flag |= LPFC_NVMET_CTX_RLS;",
          "90:  list_add_tail(&ctxp->list, &phba->sli4_hba.lpfc_abts_nvmet_ctx_list);",
          "91:  spin_unlock_irqrestore(&phba->sli4_hba.abts_nvme_buf_list_lock, iflag);",
          "92: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "139:      struct lpfc_dmabuf *mp)",
          "140: {",
          "141:  if (ctxp) {",
          "142:   if (ctxp->txrdy) {",
          "143:    pci_pool_free(phba->txrdy_payload_pool, ctxp->txrdy,",
          "144:           ctxp->txrdy_phys);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "162:   if (ctxp->flag)",
          "163:    lpfc_printf_log(phba, KERN_INFO, LOG_NVME_ABTS,",
          "164:     \"6314 rq_post ctx xri x%x flag x%x\\n\",",
          "165:     ctxp->oxid, ctxp->flag);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "337: #endif",
          "339:  ctxp = cmdwqe->context2;",
          "340:  rsp = &ctxp->ctx.fcp_req;",
          "341:  op = rsp->op;",
          "344:  status = bf_get(lpfc_wcqe_c_status, wcqe);",
          "345:  result = wcqe->parameter;",
          "350:  lpfc_nvmeio_data(phba, \"NVMET FCP CMPL: xri x%x op x%x status x%x\\n\",",
          "351:     ctxp->oxid, op, status);",
          "354:  if (status) {",
          "355:   rsp->fcp_error = NVME_SC_DATA_XFER_ERROR;",
          "356:   rsp->transferred_length = 0;",
          "358:  } else {",
          "359:   rsp->fcp_error = NVME_SC_SUCCESS;",
          "360:   if (op == NVMET_FCOP_RSP)",
          "361:    rsp->transferred_length = rsp->rsplen;",
          "362:   else",
          "363:    rsp->transferred_length = rsp->transfer_length;",
          "365:  }",
          "368:  if ((op == NVMET_FCOP_READDATA_RSP) ||",
          "369:      (op == NVMET_FCOP_RSP)) {",
          "371:   ctxp->state = LPFC_NVMET_STE_DONE;",
          "372:   ctxp->entry_cnt++;",
          "373: #ifdef CONFIG_SCSI_LPFC_DEBUG_FS",
          "374:   if (phba->ktime_on) {",
          "375:    if (rsp->op == NVMET_FCOP_READDATA_RSP) {",
          "",
          "[Removed Lines]",
          "342:  ctxp->flag &= ~LPFC_NVMET_IO_INP;",
          "347:  if (!phba->targetport)",
          "348:   goto out;",
          "353:  tgtp = (struct lpfc_nvmet_tgtport *)phba->targetport->private;",
          "357:   atomic_inc(&tgtp->xmt_fcp_rsp_error);",
          "364:   atomic_inc(&tgtp->xmt_fcp_rsp_cmpl);",
          "367: out:",
          "",
          "[Added Lines]",
          "365:  ctxp->flag &= ~LPFC_NVMET_IO_INP;",
          "373:  if (phba->targetport)",
          "374:   tgtp = (struct lpfc_nvmet_tgtport *)phba->targetport->private;",
          "375:  else",
          "376:   tgtp = NULL;",
          "384:   if (tgtp)",
          "385:    atomic_inc(&tgtp->xmt_fcp_rsp_error);",
          "388:   if (bf_get(lpfc_wcqe_c_xb, wcqe)) {",
          "389:    ctxp->flag |= LPFC_NVMET_XBUSY;",
          "391:    lpfc_printf_log(phba, KERN_INFO, LOG_NVME_ABTS,",
          "392:      \"6315 IO Cmpl XBUSY: xri x%x: %x/%x\\n\",",
          "393:      ctxp->oxid, status, result);",
          "394:   } else {",
          "395:    ctxp->flag &= ~LPFC_NVMET_XBUSY;",
          "396:   }",
          "404:   if (tgtp)",
          "405:    atomic_inc(&tgtp->xmt_fcp_rsp_cmpl);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "542: #endif",
          "546:   atomic_inc(&lpfc_nvmep->xmt_fcp_drop);",
          "547:   lpfc_printf_log(phba, KERN_ERR, LOG_NVME_IOERR,",
          "549:     ctxp->oxid);",
          "550:   rc = -ENXIO;",
          "551:   goto aerr;",
          "",
          "[Removed Lines]",
          "545:  if (ctxp->state == LPFC_NVMET_STE_ABORT) {",
          "548:     \"6102 Bad state IO x%x aborted\\n\",",
          "",
          "[Added Lines]",
          "586:  if ((ctxp->flag & LPFC_NVMET_ABTS_RCV) ||",
          "587:      (ctxp->state == LPFC_NVMET_STE_ABORT)) {",
          "590:     \"6102 IO xri x%x aborted\\n\",",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "615:  struct lpfc_nvmet_rcv_ctx *ctxp =",
          "616:   container_of(req, struct lpfc_nvmet_rcv_ctx, ctx.fcp_req);",
          "617:  struct lpfc_hba *phba = ctxp->phba;",
          "619:  lpfc_printf_log(phba, KERN_INFO, LOG_NVME_ABTS,",
          "626:  atomic_inc(&lpfc_nvmep->xmt_fcp_abort);",
          "627:  ctxp->entry_cnt++;",
          "628:  ctxp->flag |= LPFC_NVMET_ABORT_OP;",
          "629:  if (ctxp->flag & LPFC_NVMET_IO_INP)",
          "630:   lpfc_nvmet_sol_fcp_issue_abort(phba, ctxp, ctxp->sid,",
          "",
          "[Removed Lines]",
          "620:    \"6103 Abort op: oxri x%x %d cnt %d\\n\",",
          "621:    ctxp->oxid, ctxp->state, ctxp->entry_cnt);",
          "623:  lpfc_nvmeio_data(phba, \"NVMET FCP ABRT: xri x%x state x%x cnt x%x\\n\",",
          "624:     ctxp->oxid, ctxp->state, ctxp->entry_cnt);",
          "",
          "[Added Lines]",
          "660:  unsigned long flags;",
          "663:    \"6103 Abort op: oxri x%x flg x%x cnt %d\\n\",",
          "664:    ctxp->oxid, ctxp->flag, ctxp->entry_cnt);",
          "666:  lpfc_nvmeio_data(phba, \"NVMET FCP ABRT: \"",
          "667:     \"xri x%x flg x%x cnt x%x\\n\",",
          "668:     ctxp->oxid, ctxp->flag, ctxp->entry_cnt);",
          "672:  spin_lock_irqsave(&ctxp->ctxlock, flags);",
          "677:  if (ctxp->flag & LPFC_NVMET_XBUSY) {",
          "678:   spin_unlock_irqrestore(&ctxp->ctxlock, flags);",
          "679:   return;",
          "680:  }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "632:  else",
          "633:   lpfc_nvmet_unsol_fcp_issue_abort(phba, ctxp, ctxp->sid,",
          "634:        ctxp->oxid);",
          "635: }",
          "637: static void",
          "638: lpfc_nvmet_xmt_fcp_release(struct nvmet_fc_target_port *tgtport,",
          "639:       struct nvmefc_tgt_fcp_req *rsp)",
          "640: {",
          "642:  struct lpfc_nvmet_rcv_ctx *ctxp =",
          "643:   container_of(rsp, struct lpfc_nvmet_rcv_ctx, ctx.fcp_req);",
          "644:  struct lpfc_hba *phba = ctxp->phba;",
          "",
          "[Removed Lines]",
          "641:  struct lpfc_nvmet_tgtport *lpfc_nvmep = tgtport->private;",
          "",
          "[Added Lines]",
          "688:  spin_unlock_irqrestore(&ctxp->ctxlock, flags);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "646:  bool aborting = false;",
          "648:  spin_lock_irqsave(&ctxp->ctxlock, flags);",
          "650:   aborting = true;",
          "665:  }",
          "667:  lpfc_nvmeio_data(phba, \"NVMET FCP FREE: xri x%x ste %d\\n\", ctxp->oxid,",
          "668:     ctxp->state, 0);",
          "670:  lpfc_nvmet_rq_post(phba, ctxp, &ctxp->rqb_buffer->hbuf);",
          "671: }",
          "",
          "[Removed Lines]",
          "649:  if (ctxp->flag & LPFC_NVMET_ABORT_OP) {",
          "651:   ctxp->flag |= LPFC_NVMET_CTX_RLS;",
          "652:  }",
          "653:  spin_unlock_irqrestore(&ctxp->ctxlock, flags);",
          "655:  if (aborting)",
          "657:   return;",
          "660:  if (ctxp->state != LPFC_NVMET_STE_DONE) {",
          "661:   atomic_inc(&lpfc_nvmep->xmt_fcp_drop);",
          "662:   lpfc_printf_log(phba, KERN_ERR, LOG_NVME_IOERR,",
          "663:     \"6117 Bad state IO x%x aborted\\n\",",
          "664:     ctxp->oxid);",
          "",
          "[Added Lines]",
          "702:  if ((ctxp->flag & LPFC_NVMET_ABORT_OP) ||",
          "703:      (ctxp->flag & LPFC_NVMET_XBUSY)) {",
          "706:   lpfc_nvmet_defer_release(phba, ctxp);",
          "708:  spin_unlock_irqrestore(&ctxp->ctxlock, flags);",
          "713:  if (aborting)",
          "714:   return;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "801: lpfc_sli4_nvmet_xri_aborted(struct lpfc_hba *phba,",
          "802:        struct sli4_wcqe_xri_aborted *axri)",
          "803: {",
          "805: }",
          "807: void",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "850:  uint16_t xri = bf_get(lpfc_wcqe_xa_xri, axri);",
          "851:  uint16_t rxid = bf_get(lpfc_wcqe_xa_remote_xid, axri);",
          "852:  struct lpfc_nvmet_rcv_ctx *ctxp, *next_ctxp;",
          "853:  struct lpfc_nodelist *ndlp;",
          "854:  unsigned long iflag = 0;",
          "855:  int rrq_empty = 0;",
          "856:  bool released = false;",
          "858:  lpfc_printf_log(phba, KERN_INFO, LOG_NVME_ABTS,",
          "859:    \"6317 XB aborted xri x%x rxid x%x\\n\", xri, rxid);",
          "861:  if (!(phba->cfg_enable_fc4_type & LPFC_ENABLE_NVME))",
          "862:   return;",
          "863:  spin_lock_irqsave(&phba->hbalock, iflag);",
          "864:  spin_lock(&phba->sli4_hba.abts_nvme_buf_list_lock);",
          "865:  list_for_each_entry_safe(ctxp, next_ctxp,",
          "866:      &phba->sli4_hba.lpfc_abts_nvmet_ctx_list,",
          "867:      list) {",
          "868:   if (ctxp->rqb_buffer->sglq->sli4_xritag != xri)",
          "869:    continue;",
          "874:   if (ctxp->flag & LPFC_NVMET_CTX_RLS &&",
          "875:       !(ctxp->flag & LPFC_NVMET_ABORT_OP)) {",
          "876:    list_del(&ctxp->list);",
          "877:    released = true;",
          "878:   }",
          "879:   ctxp->flag &= ~LPFC_NVMET_XBUSY;",
          "880:   spin_unlock(&phba->sli4_hba.abts_nvme_buf_list_lock);",
          "882:   rrq_empty = list_empty(&phba->active_rrq_list);",
          "883:   spin_unlock_irqrestore(&phba->hbalock, iflag);",
          "884:   ndlp = lpfc_findnode_did(phba->pport, ctxp->sid);",
          "885:   if (ndlp && NLP_CHK_NODE_ACT(ndlp) &&",
          "886:       (ndlp->nlp_state == NLP_STE_UNMAPPED_NODE ||",
          "887:        ndlp->nlp_state == NLP_STE_MAPPED_NODE)) {",
          "888:    lpfc_set_rrq_active(phba, ndlp,",
          "889:     ctxp->rqb_buffer->sglq->sli4_lxritag,",
          "890:     rxid, 1);",
          "891:    lpfc_sli4_abts_err_handler(phba, ndlp, axri);",
          "892:   }",
          "894:   lpfc_printf_log(phba, KERN_INFO, LOG_NVME_ABTS,",
          "895:     \"6318 XB aborted %x flg x%x (%x)\\n\",",
          "896:     ctxp->oxid, ctxp->flag, released);",
          "897:   if (released)",
          "898:    lpfc_nvmet_rq_post(phba, ctxp,",
          "899:         &ctxp->rqb_buffer->hbuf);",
          "900:   if (rrq_empty)",
          "901:    lpfc_worker_wake_up(phba);",
          "902:   return;",
          "903:  }",
          "904:  spin_unlock(&phba->sli4_hba.abts_nvme_buf_list_lock);",
          "905:  spin_unlock_irqrestore(&phba->hbalock, iflag);",
          "906: }",
          "908: int",
          "909: lpfc_nvmet_rcv_unsol_abort(struct lpfc_vport *vport,",
          "910:       struct fc_frame_header *fc_hdr)",
          "912: {",
          "913: #if (IS_ENABLED(CONFIG_NVME_TARGET_FC))",
          "914:  struct lpfc_hba *phba = vport->phba;",
          "915:  struct lpfc_nvmet_rcv_ctx *ctxp, *next_ctxp;",
          "916:  struct nvmefc_tgt_fcp_req *rsp;",
          "917:  uint16_t xri;",
          "918:  unsigned long iflag = 0;",
          "920:  xri = be16_to_cpu(fc_hdr->fh_ox_id);",
          "922:  spin_lock_irqsave(&phba->hbalock, iflag);",
          "923:  spin_lock(&phba->sli4_hba.abts_nvme_buf_list_lock);",
          "924:  list_for_each_entry_safe(ctxp, next_ctxp,",
          "925:      &phba->sli4_hba.lpfc_abts_nvmet_ctx_list,",
          "926:      list) {",
          "927:   if (ctxp->rqb_buffer->sglq->sli4_xritag != xri)",
          "928:    continue;",
          "930:   spin_unlock(&phba->sli4_hba.abts_nvme_buf_list_lock);",
          "931:   spin_unlock_irqrestore(&phba->hbalock, iflag);",
          "933:   spin_lock_irqsave(&ctxp->ctxlock, iflag);",
          "934:   ctxp->flag |= LPFC_NVMET_ABTS_RCV;",
          "935:   spin_unlock_irqrestore(&ctxp->ctxlock, iflag);",
          "937:   lpfc_nvmeio_data(phba,",
          "938:    \"NVMET ABTS RCV: xri x%x CPU %02x rjt %d\\n\",",
          "939:    xri, smp_processor_id(), 0);",
          "941:   lpfc_printf_log(phba, KERN_INFO, LOG_NVME_ABTS,",
          "942:     \"6319 NVMET Rcv ABTS:acc xri x%x\\n\", xri);",
          "944:   rsp = &ctxp->ctx.fcp_req;",
          "945:   nvmet_fc_rcv_fcp_abort(phba->targetport, rsp);",
          "948:   lpfc_sli4_seq_abort_rsp(vport, fc_hdr, 1);",
          "949:   return 0;",
          "950:  }",
          "951:  spin_unlock(&phba->sli4_hba.abts_nvme_buf_list_lock);",
          "952:  spin_unlock_irqrestore(&phba->hbalock, iflag);",
          "954:  lpfc_nvmeio_data(phba, \"NVMET ABTS RCV: xri x%x CPU %02x rjt %d\\n\",",
          "955:     xri, smp_processor_id(), 1);",
          "957:  lpfc_printf_log(phba, KERN_INFO, LOG_NVME_ABTS,",
          "958:    \"6320 NVMET Rcv ABTS:rjt xri x%x\\n\", xri);",
          "961:  lpfc_sli4_seq_abort_rsp(vport, fc_hdr, 0);",
          "962:  return 0;",
          "963: #endif",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1655:  tgtp = (struct lpfc_nvmet_tgtport *)phba->targetport->private;",
          "1656:  atomic_inc(&tgtp->xmt_abort_cmpl);",
          "1663:  ctxp->state = LPFC_NVMET_STE_DONE;",
          "1664:  spin_lock_irqsave(&ctxp->ctxlock, flags);",
          "1666:   released = true;",
          "1667:  ctxp->flag &= ~LPFC_NVMET_ABORT_OP;",
          "1668:  spin_unlock_irqrestore(&ctxp->ctxlock, flags);",
          "",
          "[Removed Lines]",
          "1658:  lpfc_printf_log(phba, KERN_ERR, LOG_NVME_ABTS,",
          "1659:    \"6165 Abort cmpl: xri x%x WCQE: %08x %08x %08x %08x\\n\",",
          "1660:    ctxp->oxid, wcqe->word0, wcqe->total_data_placed,",
          "1661:    result, wcqe->word3);",
          "1665:  if (ctxp->flag & LPFC_NVMET_CTX_RLS)",
          "",
          "[Added Lines]",
          "1823:  if ((ctxp->flag & LPFC_NVMET_CTX_RLS) &&",
          "1824:      !(ctxp->flag & LPFC_NVMET_XBUSY)) {",
          "1825:   list_del(&ctxp->list);",
          "1827:  }",
          "1831:  lpfc_printf_log(phba, KERN_ERR, LOG_NVME_ABTS,",
          "1832:    \"6165 ABORT cmpl: xri x%x flg x%x (%d) \"",
          "1833:    \"WCQE: %08x %08x %08x %08x\\n\",",
          "1834:    ctxp->oxid, ctxp->flag, released,",
          "1835:    wcqe->word0, wcqe->total_data_placed,",
          "1836:    result, wcqe->word3);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1692: static void",
          "1695: {",
          "1696:  struct lpfc_nvmet_rcv_ctx *ctxp;",
          "1697:  struct lpfc_nvmet_tgtport *tgtp;",
          "",
          "[Removed Lines]",
          "1693: lpfc_nvmet_xmt_fcp_abort_cmp(struct lpfc_hba *phba, struct lpfc_iocbq *cmdwqe,",
          "1694:         struct lpfc_wcqe_complete *wcqe)",
          "",
          "[Added Lines]",
          "1866: lpfc_nvmet_unsol_fcp_abort_cmp(struct lpfc_hba *phba, struct lpfc_iocbq *cmdwqe,",
          "1867:           struct lpfc_wcqe_complete *wcqe)",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1706:  tgtp = (struct lpfc_nvmet_tgtport *)phba->targetport->private;",
          "1707:  atomic_inc(&tgtp->xmt_abort_cmpl);",
          "1709:  lpfc_printf_log(phba, KERN_INFO, LOG_NVME_ABTS,",
          "1712:    result, wcqe->word3);",
          "1738: }",
          "",
          "[Removed Lines]",
          "1710:    \"6070 Abort cmpl: ctx %p WCQE: %08x %08x %08x %08x\\n\",",
          "1711:    ctxp, wcqe->word0, wcqe->total_data_placed,",
          "1714:  if (ctxp) {",
          "1716:   if (ctxp->state != LPFC_NVMET_STE_ABORT) {",
          "1717:    lpfc_printf_log(phba, KERN_ERR, LOG_NVME_ABTS,",
          "1718:      \"6112 ABORT Wrong state:%d oxid x%x\\n\",",
          "1719:      ctxp->state, ctxp->oxid);",
          "1720:   }",
          "1721:   ctxp->state = LPFC_NVMET_STE_DONE;",
          "1722:   spin_lock_irqsave(&ctxp->ctxlock, flags);",
          "1723:   if (ctxp->flag & LPFC_NVMET_CTX_RLS)",
          "1724:    released = true;",
          "1725:   ctxp->flag &= ~LPFC_NVMET_ABORT_OP;",
          "1726:   spin_unlock_irqrestore(&ctxp->ctxlock, flags);",
          "1732:   if (released)",
          "1733:    lpfc_nvmet_rq_post(phba, ctxp, &ctxp->rqb_buffer->hbuf);",
          "1735:   cmdwqe->context2 = NULL;",
          "1736:   cmdwqe->context3 = NULL;",
          "1737:  }",
          "",
          "[Added Lines]",
          "1882:  if (!ctxp) {",
          "1884:   lpfc_printf_log(phba, KERN_INFO, LOG_NVME_ABTS,",
          "1885:     \"6070 ABTS cmpl: WCQE: %08x %08x %08x %08x\\n\",",
          "1886:     wcqe->word0, wcqe->total_data_placed,",
          "1887:     result, wcqe->word3);",
          "1888:   return;",
          "1889:  }",
          "1892:  if (ctxp->state != LPFC_NVMET_STE_ABORT) {",
          "1893:   lpfc_printf_log(phba, KERN_ERR, LOG_NVME_ABTS,",
          "1894:     \"6112 ABTS Wrong state:%d oxid x%x\\n\",",
          "1895:     ctxp->state, ctxp->oxid);",
          "1896:  }",
          "1901:  ctxp->state = LPFC_NVMET_STE_DONE;",
          "1902:  spin_lock_irqsave(&ctxp->ctxlock, flags);",
          "1903:  if ((ctxp->flag & LPFC_NVMET_CTX_RLS) &&",
          "1904:      !(ctxp->flag & LPFC_NVMET_XBUSY)) {",
          "1905:   list_del(&ctxp->list);",
          "1906:   released = true;",
          "1907:  }",
          "1908:  ctxp->flag &= ~LPFC_NVMET_ABORT_OP;",
          "1909:  spin_unlock_irqrestore(&ctxp->ctxlock, flags);",
          "1912:    \"6316 ABTS cmpl xri x%x flg x%x (%x) \"",
          "1913:    \"WCQE: %08x %08x %08x %08x\\n\",",
          "1914:    ctxp->oxid, ctxp->flag, released,",
          "1915:    wcqe->word0, wcqe->total_data_placed,",
          "1921:  if (released)",
          "1922:   lpfc_nvmet_rq_post(phba, ctxp, &ctxp->rqb_buffer->hbuf);",
          "1924:  cmdwqe->context2 = NULL;",
          "1925:  cmdwqe->context3 = NULL;",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1787:  struct lpfc_nodelist *ndlp;",
          "1789:  lpfc_printf_log(phba, KERN_INFO, LOG_NVME_ABTS,",
          "1791:    sid, xri, ctxp->wqeq->sli4_xritag);",
          "1793:  tgtp = (struct lpfc_nvmet_tgtport *)phba->targetport->private;",
          "1795:  ndlp = lpfc_findnode_did(phba->pport, sid);",
          "1796:  if (!ndlp || !NLP_CHK_NODE_ACT(ndlp) ||",
          "",
          "[Removed Lines]",
          "1790:    \"6067 Abort: sid %x xri x%x/x%x\\n\",",
          "",
          "[Added Lines]",
          "1983:    \"6067 ABTS: sid %x xri x%x/x%x\\n\",",
          "1987:  if (!ctxp->wqeq) {",
          "1988:   ctxp->wqeq = ctxp->rqb_buffer->iocbq;",
          "1989:   ctxp->wqeq->hba_wqidx = 0;",
          "1990:  }",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1896:      (ndlp->nlp_state != NLP_STE_MAPPED_NODE))) {",
          "1897:   atomic_inc(&tgtp->xmt_abort_rsp_error);",
          "1898:   lpfc_printf_log(phba, KERN_WARNING, LOG_NVME_ABTS,",
          "1900:     (ndlp) ? ndlp->nlp_state : NLP_STE_MAX_STATE);",
          "1903:   return 0;",
          "1904:  }",
          "",
          "[Removed Lines]",
          "1899:     \"6160 Drop ABTS - wrong NDLP state x%x.\\n\",",
          "",
          "[Added Lines]",
          "2096:     \"6160 Drop ABORT - wrong NDLP state x%x.\\n\",",
          "2100:   ctxp->flag &= ~LPFC_NVMET_ABORT_OP;",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "1907:  ctxp->abort_wqeq = lpfc_sli_get_iocbq(phba);",
          "1908:  if (!ctxp->abort_wqeq) {",
          "1909:   lpfc_printf_log(phba, KERN_WARNING, LOG_NVME_ABTS,",
          "1911:     \"xri: x%x\\n\", ctxp->oxid);",
          "1913:   return 0;",
          "1914:  }",
          "1915:  abts_wqeq = ctxp->abort_wqeq;",
          "",
          "[Removed Lines]",
          "1910:     \"6161 Abort failed: No wqeqs: \"",
          "",
          "[Added Lines]",
          "2108:     \"6161 ABORT failed: No wqeqs: \"",
          "2111:   ctxp->flag &= ~LPFC_NVMET_ABORT_OP;",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "1917:  ctxp->state = LPFC_NVMET_STE_ABORT;",
          "1922:    \"for xri x%x x%x\\n\",",
          "1923:    ctxp->sid, ctxp->oxid, ctxp->wqeq->sli4_xritag);",
          "",
          "[Removed Lines]",
          "1920:  lpfc_printf_log(phba, KERN_ERR, LOG_NVME_ABTS,",
          "1921:    \"6162 Abort Request to rport DID x%06x \"",
          "",
          "[Added Lines]",
          "2119:  lpfc_printf_log(phba, KERN_INFO, LOG_NVME_ABTS,",
          "2120:    \"6162 ABORT Request to rport DID x%06x \"",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "1934:     \"NVME Req now. hba_flag x%x oxid x%x\\n\",",
          "1935:     phba->hba_flag, ctxp->oxid);",
          "1936:   lpfc_sli_release_iocbq(phba, abts_wqeq);",
          "1937:   return 0;",
          "1938:  }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2136:   ctxp->flag &= ~LPFC_NVMET_ABORT_OP;",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "1945:     \"still pending on oxid x%x\\n\",",
          "1946:     ctxp->oxid);",
          "1947:   lpfc_sli_release_iocbq(phba, abts_wqeq);",
          "1948:   return 0;",
          "1949:  }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2148:   ctxp->flag &= ~LPFC_NVMET_ABORT_OP;",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "1992:  if (rc == WQE_SUCCESS)",
          "1993:   return 0;",
          "1995:  lpfc_sli_release_iocbq(phba, abts_wqeq);",
          "1998:    \"for oxid x%x.\\n\",",
          "1999:    rc, ctxp->oxid);",
          "2000:  return 1;",
          "",
          "[Removed Lines]",
          "1996:  lpfc_printf_log(phba, KERN_ERR, LOG_NVME,",
          "1997:    \"6166 Failed abts issue_wqe with status x%x \"",
          "",
          "[Added Lines]",
          "2196:  ctxp->flag &= ~LPFC_NVMET_ABORT_OP;",
          "2198:  lpfc_printf_log(phba, KERN_ERR, LOG_NVME_ABTS,",
          "2199:    \"6166 Failed ABORT issue_wqe with status x%x \"",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "2024:  spin_lock_irqsave(&phba->hbalock, flags);",
          "2025:  abts_wqeq = ctxp->wqeq;",
          "2028:  abts_wqeq->iocb_flag |= LPFC_IO_NVMET;",
          "2029:  rc = lpfc_sli4_issue_wqe(phba, LPFC_FCP_RING, abts_wqeq);",
          "2030:  spin_unlock_irqrestore(&phba->hbalock, flags);",
          "",
          "[Removed Lines]",
          "2026:  abts_wqeq->wqe_cmpl = lpfc_nvmet_xmt_fcp_abort_cmp;",
          "2027:  abts_wqeq->iocb_cmpl = 0;",
          "",
          "[Added Lines]",
          "2228:  abts_wqeq->wqe_cmpl = lpfc_nvmet_unsol_fcp_abort_cmp;",
          "2229:  abts_wqeq->iocb_cmpl = NULL;",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "2034:  }",
          "2036: aerr:",
          "2038:  atomic_inc(&tgtp->xmt_abort_rsp_error);",
          "2039:  lpfc_printf_log(phba, KERN_WARNING, LOG_NVME_ABTS,",
          "2040:    \"6135 Failed to Issue ABTS for oxid x%x. Status x%x\\n\",",
          "",
          "[Removed Lines]",
          "2037:  lpfc_nvmet_rq_post(phba, ctxp, &ctxp->rqb_buffer->hbuf);",
          "",
          "[Added Lines]",
          "2239:  ctxp->flag &= ~LPFC_NVMET_ABORT_OP;",
          "",
          "---------------"
        ],
        "drivers/scsi/lpfc/lpfc_nvmet.h||drivers/scsi/lpfc/lpfc_nvmet.h": [
          "File: drivers/scsi/lpfc/lpfc_nvmet.h -> drivers/scsi/lpfc/lpfc_nvmet.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "75:   struct nvmefc_tgt_ls_req ls_req;",
          "76:   struct nvmefc_tgt_fcp_req fcp_req;",
          "77:  } ctx;",
          "78:  struct lpfc_hba *phba;",
          "79:  struct lpfc_iocbq *wqeq;",
          "80:  struct lpfc_iocbq *abort_wqeq;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "78:  struct list_head list;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "96: #define LPFC_NVMET_STE_RSP  4",
          "97: #define LPFC_NVMET_STE_DONE  5",
          "98:  uint16_t flag;",
          "103:  struct rqb_dmabuf *rqb_buffer;",
          "105: #ifdef CONFIG_SCSI_LPFC_DEBUG_FS",
          "",
          "[Removed Lines]",
          "99: #define LPFC_NVMET_IO_INP  0x1",
          "100: #define LPFC_NVMET_ABORT_OP  0x2",
          "101: #define LPFC_NVMET_CTX_RLS  0x4",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "drivers/scsi/lpfc/lpfc_sli.c||drivers/scsi/lpfc/lpfc_sli.c": [
          "File: drivers/scsi/lpfc/lpfc_sli.c -> drivers/scsi/lpfc/lpfc_sli.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "16525: lpfc_sli4_seq_abort_rsp(struct lpfc_vport *vport,",
          "16526:    struct fc_frame_header *fc_hdr, bool aborted)",
          "16527: {",
          "",
          "[Removed Lines]",
          "16524: static void",
          "",
          "[Added Lines]",
          "16524: void",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "16697:  }",
          "16698:  lpfc_in_buf_free(phba, &dmabuf->dbuf);",
          "16701:  lpfc_sli4_seq_abort_rsp(vport, &fc_hdr, aborted);",
          "16702: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "16700:  if (phba->nvmet_support) {",
          "16701:   lpfc_nvmet_rcv_unsol_abort(vport, &fc_hdr);",
          "16702:   return;",
          "16703:  }",
          "",
          "---------------"
        ],
        "drivers/scsi/lpfc/lpfc_sli4.h||drivers/scsi/lpfc/lpfc_sli4.h": [
          "File: drivers/scsi/lpfc/lpfc_sli4.h -> drivers/scsi/lpfc/lpfc_sli4.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "620:  struct list_head lpfc_els_sgl_list;",
          "621:  struct list_head lpfc_abts_els_sgl_list;",
          "622:  struct list_head lpfc_nvmet_sgl_list;",
          "624:  struct list_head lpfc_abts_scsi_buf_list;",
          "625:  struct list_head lpfc_abts_nvme_buf_list;",
          "626:  struct lpfc_sglq **lpfc_sglq_active_list;",
          "",
          "[Removed Lines]",
          "623:  struct list_head lpfc_abts_nvmet_sgl_list;",
          "",
          "[Added Lines]",
          "623:  struct list_head lpfc_abts_nvmet_ctx_list;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "9b70de6d0266888b3743f03802502e43131043c8",
      "candidate_info": {
        "commit_hash": "9b70de6d0266888b3743f03802502e43131043c8",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/9b70de6d0266888b3743f03802502e43131043c8",
        "files": [
          "drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.c"
        ],
        "message": "bnx2x: Align RX buffers\n\nThe bnx2x driver is not providing proper alignment on the receive buffers it\npasses to build_skb(), causing skb_shared_info to be misaligned.\nskb_shared_info contains an atomic, and while PPC normally supports\nunaligned accesses, it does not support unaligned atomics.\n\nAligning the size of rx buffers will ensure that page_frag_alloc() returns\naligned addresses.\n\nThis can be reproduced on PPC by setting the network MTU to 1450 (or other\nnon-multiple-of-4) and then generating sufficient inbound network traffic\n(one or two large \"wget\"s usually does it), producing the following oops:\n\nUnable to handle kernel paging request for unaligned access at address 0xc00000ffc43af656\nFaulting instruction address: 0xc00000000080ef8c\nOops: Kernel access of bad area, sig: 7 [#1]\nSMP NR_CPUS=2048\nNUMA\nPowerNV\nModules linked in: vmx_crypto powernv_rng rng_core powernv_op_panel leds_powernv led_class nfsd ip_tables x_tables autofs4 xfs lpfc bnx2x mdio libcrc32c crc_t10dif crct10dif_generic crct10dif_common\nCPU: 104 PID: 0 Comm: swapper/104 Not tainted 4.11.0-rc8-00088-g4c761da #2\ntask: c00000ffd4892400 task.stack: c00000ffd4920000\nNIP: c00000000080ef8c LR: c00000000080eee8 CTR: c0000000001f8320\nREGS: c00000ffffc33710 TRAP: 0600   Not tainted  (4.11.0-rc8-00088-g4c761da)\nMSR: 9000000000009033 <SF,HV,EE,ME,IR,DR,RI,LE>\n  CR: 24082042  XER: 00000000\nCFAR: c00000000080eea0 DAR: c00000ffc43af656 DSISR: 00000000 SOFTE: 1\nGPR00: c000000000907f64 c00000ffffc33990 c000000000dd3b00 c00000ffcaf22100\nGPR04: c00000ffcaf22e00 0000000000000000 0000000000000000 0000000000000000\nGPR08: 0000000000b80008 c00000ffc43af636 c00000ffc43af656 0000000000000000\nGPR12: c0000000001f6f00 c00000000fe1a000 000000000000049f 000000000000c51f\nGPR16: 00000000ffffef33 0000000000000000 0000000000008a43 0000000000000001\nGPR20: c00000ffc58a90c0 0000000000000000 000000000000dd86 0000000000000000\nGPR24: c000007fd0ed10c0 00000000ffffffff 0000000000000158 000000000000014a\nGPR28: c00000ffc43af010 c00000ffc9144000 c00000ffcaf22e00 c00000ffcaf22100\nNIP [c00000000080ef8c] __skb_clone+0xdc/0x140\nLR [c00000000080eee8] __skb_clone+0x38/0x140\nCall Trace:\n[c00000ffffc33990] [c00000000080fb74] skb_clone+0x74/0x110 (unreliable)\n[c00000ffffc339c0] [c000000000907f64] packet_rcv+0x144/0x510\n[c00000ffffc33a40] [c000000000827b64] __netif_receive_skb_core+0x5b4/0xd80\n[c00000ffffc33b00] [c00000000082b2bc] netif_receive_skb_internal+0x2c/0xc0\n[c00000ffffc33b40] [c00000000082c49c] napi_gro_receive+0x11c/0x260\n[c00000ffffc33b80] [d000000066483d68] bnx2x_poll+0xcf8/0x17b0 [bnx2x]\n[c00000ffffc33d00] [c00000000082babc] net_rx_action+0x31c/0x480\n[c00000ffffc33e10] [c0000000000d5a44] __do_softirq+0x164/0x3d0\n[c00000ffffc33f00] [c0000000000d60a8] irq_exit+0x108/0x120\n[c00000ffffc33f20] [c000000000015b98] __do_irq+0x98/0x200\n[c00000ffffc33f90] [c000000000027f14] call_do_irq+0x14/0x24\n[c00000ffd4923a90] [c000000000015d94] do_IRQ+0x94/0x110\n[c00000ffd4923ae0] [c000000000008d90] hardware_interrupt_common+0x150/0x160\n\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.c||drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.c||drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.c": [
          "File: drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.c -> drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2021:       ETH_OVERHEAD +",
          "2022:       mtu +",
          "2023:       BNX2X_FW_RX_ALIGN_END;",
          "2025:   if (fp->rx_buf_size + NET_SKB_PAD <= PAGE_SIZE)",
          "2026:    fp->rx_frag_size = fp->rx_buf_size + NET_SKB_PAD;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2024:   fp->rx_buf_size = SKB_DATA_ALIGN(fp->rx_buf_size);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "a315e68f6e8b3006c29482dbfc4d928f098c449c",
      "candidate_info": {
        "commit_hash": "a315e68f6e8b3006c29482dbfc4d928f098c449c",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/a315e68f6e8b3006c29482dbfc4d928f098c449c",
        "files": [
          "fs/btrfs/extent_io.h",
          "fs/btrfs/inode.c"
        ],
        "message": "Btrfs: fix invalid attempt to free reserved space on failure to cow range\n\nWhen attempting to COW a file range (we are starting writeback and doing\nCOW), if we manage to reserve an extent for the range we will write into\nbut fail after reserving it and before creating the respective ordered\nextent, we end up in an error path where we attempt to decrement the\ndata space's bytes_may_use counter after we already did it while\nreserving the extent, leading to a warning/trace like the following:\n\n[  847.621524] ------------[ cut here ]------------\n[  847.625441] WARNING: CPU: 5 PID: 4905 at fs/btrfs/extent-tree.c:4316 btrfs_free_reserved_data_space_noquota+0x60/0x9f [btrfs]\n[  847.633704] Modules linked in: btrfs crc32c_generic xor raid6_pq acpi_cpufreq i2c_piix4 ppdev psmouse tpm_tis serio_raw pcspkr parport_pc tpm_tis_core i2c_core sg\n[  847.644616] CPU: 5 PID: 4905 Comm: xfs_io Not tainted 4.10.0-rc8-btrfs-next-37+ #2\n[  847.648601] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.9.1-0-gb3ef39f-prebuilt.qemu-project.org 04/01/2014\n[  847.648601] Call Trace:\n[  847.648601]  dump_stack+0x67/0x90\n[  847.648601]  __warn+0xc2/0xdd\n[  847.648601]  warn_slowpath_null+0x1d/0x1f\n[  847.648601]  btrfs_free_reserved_data_space_noquota+0x60/0x9f [btrfs]\n[  847.648601]  btrfs_clear_bit_hook+0x140/0x258 [btrfs]\n[  847.648601]  clear_state_bit+0x87/0x128 [btrfs]\n[  847.648601]  __clear_extent_bit+0x222/0x2b7 [btrfs]\n[  847.648601]  clear_extent_bit+0x17/0x19 [btrfs]\n[  847.648601]  extent_clear_unlock_delalloc+0x3b/0x6b [btrfs]\n[  847.648601]  cow_file_range.isra.39+0x387/0x39a [btrfs]\n[  847.648601]  run_delalloc_nocow+0x4d7/0x70e [btrfs]\n[  847.648601]  ? arch_local_irq_save+0x9/0xc\n[  847.648601]  run_delalloc_range+0xa7/0x2b5 [btrfs]\n[  847.648601]  writepage_delalloc.isra.31+0xb9/0x15c [btrfs]\n[  847.648601]  __extent_writepage+0x249/0x2e8 [btrfs]\n[  847.648601]  extent_write_cache_pages.constprop.33+0x28b/0x36c [btrfs]\n[  847.648601]  ? arch_local_irq_save+0x9/0xc\n[  847.648601]  ? mark_lock+0x24/0x201\n[  847.648601]  extent_writepages+0x4b/0x5c [btrfs]\n[  847.648601]  ? btrfs_writepage_start_hook+0xed/0xed [btrfs]\n[  847.648601]  btrfs_writepages+0x28/0x2a [btrfs]\n[  847.648601]  do_writepages+0x23/0x2c\n[  847.648601]  __filemap_fdatawrite_range+0x5a/0x61\n[  847.648601]  filemap_fdatawrite_range+0x13/0x15\n[  847.648601]  btrfs_fdatawrite_range+0x20/0x46 [btrfs]\n[  847.648601]  start_ordered_ops+0x19/0x23 [btrfs]\n[  847.648601]  btrfs_sync_file+0x136/0x42c [btrfs]\n[  847.648601]  vfs_fsync_range+0x8c/0x9e\n[  847.648601]  vfs_fsync+0x1c/0x1e\n[  847.648601]  do_fsync+0x31/0x4a\n[  847.648601]  SyS_fsync+0x10/0x14\n[  847.648601]  entry_SYSCALL_64_fastpath+0x18/0xad\n[  847.648601] RIP: 0033:0x7f5b05200800\n[  847.648601] RSP: 002b:00007ffe204f71c8 EFLAGS: 00000246 ORIG_RAX: 000000000000004a\n[  847.648601] RAX: ffffffffffffffda RBX: ffffffff8109637b RCX: 00007f5b05200800\n[  847.648601] RDX: 00000000008bd0a0 RSI: 00000000008bd2e0 RDI: 0000000000000003\n[  847.648601] RBP: ffffc90001d67f98 R08: 000000000000ffff R09: 000000000000001f\n[  847.648601] R10: 00000000000001f6 R11: 0000000000000246 R12: 0000000000000046\n[  847.648601] R13: ffffc90001d67f78 R14: 00007f5b054be740 R15: 00007f5b054be740\n[  847.648601]  ? trace_hardirqs_off_caller+0x3f/0xaa\n[  847.685787] ---[ end trace 2a4a3e15382508e8 ]---\n\nSo fix this by not attempting to decrement the data space info's\nbytes_may_use counter if we already reserved the extent and an error\nhappened before creating the ordered extent. We are already correctly\nfreeing the reserved extent if an error happens, so there's no additional\nmeasure needed.\n\nSigned-off-by: Filipe Manana <fdmanana@suse.com>\nReviewed-by: Liu Bo <bo.li.liu@oracle.com>",
        "before_after_code_files": [
          "fs/btrfs/extent_io.h||fs/btrfs/extent_io.h",
          "fs/btrfs/inode.c||fs/btrfs/inode.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "fs/btrfs/extent_io.h||fs/btrfs/extent_io.h": [
          "File: fs/btrfs/extent_io.h -> fs/btrfs/extent_io.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "14: #define EXTENT_DEFRAG  (1U << 6)",
          "15: #define EXTENT_BOUNDARY  (1U << 9)",
          "16: #define EXTENT_NODATASUM (1U << 10)",
          "18: #define EXTENT_FIRST_DELALLOC (1U << 12)",
          "19: #define EXTENT_NEED_WAIT (1U << 13)",
          "20: #define EXTENT_DAMAGED  (1U << 14)",
          "",
          "[Removed Lines]",
          "17: #define EXTENT_DO_ACCOUNTING (1U << 11)",
          "",
          "[Added Lines]",
          "17: #define EXTENT_CLEAR_META_RESV (1U << 11)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "22: #define EXTENT_QGROUP_RESERVED (1U << 16)",
          "23: #define EXTENT_CLEAR_DATA_RESV (1U << 17)",
          "24: #define EXTENT_IOBITS  (EXTENT_LOCKED | EXTENT_WRITEBACK)",
          "25: #define EXTENT_CTLBITS  (EXTENT_DO_ACCOUNTING | EXTENT_FIRST_DELALLOC)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "25: #define EXTENT_DO_ACCOUNTING    (EXTENT_CLEAR_META_RESV | \\",
          "26:      EXTENT_CLEAR_DATA_RESV)",
          "",
          "---------------"
        ],
        "fs/btrfs/inode.c||fs/btrfs/inode.c": [
          "File: fs/btrfs/inode.c -> fs/btrfs/inode.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "943:  u64 num_bytes;",
          "944:  unsigned long ram_size;",
          "945:  u64 disk_num_bytes;",
          "947:  u64 blocksize = fs_info->sectorsize;",
          "948:  struct btrfs_key ins;",
          "949:  struct extent_map *em;",
          "950:  int ret = 0;",
          "952:  if (btrfs_is_free_space_inode(BTRFS_I(inode))) {",
          "",
          "[Removed Lines]",
          "946:  u64 cur_alloc_size;",
          "",
          "[Added Lines]",
          "946:  u64 cur_alloc_size = 0;",
          "950:  unsigned clear_bits;",
          "951:  unsigned long page_ops;",
          "952:  bool extent_reserved = false;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "991:    start + num_bytes - 1, 0);",
          "993:  while (disk_num_bytes > 0) {",
          "996:   cur_alloc_size = disk_num_bytes;",
          "997:   ret = btrfs_reserve_extent(root, cur_alloc_size, cur_alloc_size,",
          "998:         fs_info->sectorsize, 0, alloc_hint,",
          "999:         &ins, 1, 1);",
          "1000:   if (ret < 0)",
          "1001:    goto out_unlock;",
          "1003:   ram_size = ins.offset;",
          "",
          "[Removed Lines]",
          "994:   unsigned long op;",
          "",
          "[Added Lines]",
          "1003:   cur_alloc_size = ins.offset;",
          "1004:   extent_reserved = true;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1013:    goto out_reserve;",
          "1014:   free_extent_map(em);",
          "1017:   ret = btrfs_add_ordered_extent(inode, start, ins.objectid,",
          "1018:             ram_size, cur_alloc_size, 0);",
          "1019:   if (ret)",
          "",
          "[Removed Lines]",
          "1016:   cur_alloc_size = ins.offset;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1054:   extent_clear_unlock_delalloc(inode, start,",
          "1055:           start + ram_size - 1,",
          "1056:           delalloc_end, locked_page,",
          "1057:           EXTENT_LOCKED | EXTENT_DELALLOC,",
          "1059:   if (disk_num_bytes < cur_alloc_size)",
          "1060:    disk_num_bytes = 0;",
          "1061:   else",
          "",
          "[Removed Lines]",
          "1051:   op = unlock ? PAGE_UNLOCK : 0;",
          "1052:   op |= PAGE_SET_PRIVATE2;",
          "1058:           op);",
          "",
          "[Added Lines]",
          "1053:   page_ops = unlock ? PAGE_UNLOCK : 0;",
          "1054:   page_ops |= PAGE_SET_PRIVATE2;",
          "1060:           page_ops);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1063:   num_bytes -= cur_alloc_size;",
          "1064:   alloc_hint = ins.objectid + ins.offset;",
          "1065:   start += cur_alloc_size;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1068:   extent_reserved = false;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1081:  btrfs_dec_block_group_reservations(fs_info, ins.objectid);",
          "1082:  btrfs_free_reserved_extent(fs_info, ins.objectid, ins.offset, 1);",
          "1083: out_unlock:",
          "1084:  extent_clear_unlock_delalloc(inode, start, end, delalloc_end,",
          "1085:          locked_page,",
          "1090:  goto out;",
          "1091: }",
          "",
          "[Removed Lines]",
          "1086:          EXTENT_LOCKED | EXTENT_DO_ACCOUNTING |",
          "1087:          EXTENT_DELALLOC | EXTENT_DEFRAG,",
          "1088:          PAGE_UNLOCK | PAGE_CLEAR_DIRTY |",
          "1089:          PAGE_SET_WRITEBACK | PAGE_END_WRITEBACK);",
          "",
          "[Added Lines]",
          "1087:  clear_bits = EXTENT_LOCKED | EXTENT_DELALLOC | EXTENT_DEFRAG |",
          "1088:   EXTENT_CLEAR_META_RESV;",
          "1089:  page_ops = PAGE_UNLOCK | PAGE_CLEAR_DIRTY | PAGE_SET_WRITEBACK |",
          "1090:   PAGE_END_WRITEBACK;",
          "1101:  if (extent_reserved) {",
          "1102:   extent_clear_unlock_delalloc(inode, start,",
          "1103:           start + cur_alloc_size,",
          "1104:           start + cur_alloc_size,",
          "1105:           locked_page,",
          "1106:           clear_bits,",
          "1107:           page_ops);",
          "1108:   start += cur_alloc_size;",
          "1109:   if (start >= end)",
          "1110:    goto out;",
          "1111:  }",
          "1114:          clear_bits | EXTENT_CLEAR_DATA_RESV,",
          "1115:          page_ops);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1777:   if (*bits & EXTENT_FIRST_DELALLOC) {",
          "1780:    spin_lock(&inode->lock);",
          "1781:    inode->outstanding_extents -= num_extents;",
          "1782:    spin_unlock(&inode->lock);",
          "",
          "[Removed Lines]",
          "1779:   } else if (!(*bits & EXTENT_DO_ACCOUNTING)) {",
          "",
          "[Added Lines]",
          "1805:   } else if (!(*bits & EXTENT_CLEAR_META_RESV)) {",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1791:       root != fs_info->tree_root)",
          "1792:    btrfs_delalloc_release_metadata(inode, len);",
          "",
          "[Removed Lines]",
          "1790:   if (*bits & EXTENT_DO_ACCOUNTING &&",
          "",
          "[Added Lines]",
          "1816:   if (*bits & EXTENT_CLEAR_META_RESV &&",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1795:   if (btrfs_is_testing(fs_info))",
          "1796:    return;",
          "1802:    btrfs_free_reserved_data_space_noquota(",
          "1803:      &inode->vfs_inode,",
          "1804:      state->start, len);",
          "",
          "[Removed Lines]",
          "1798:   if (root->root_key.objectid != BTRFS_DATA_RELOC_TREE_OBJECTID",
          "1799:       && do_list && !(state->state & EXTENT_NORESERVE)",
          "1800:       && (*bits & (EXTENT_DO_ACCOUNTING |",
          "1801:       EXTENT_CLEAR_DATA_RESV)))",
          "",
          "[Added Lines]",
          "1824:   if (root->root_key.objectid != BTRFS_DATA_RELOC_TREE_OBJECTID &&",
          "1825:       do_list && !(state->state & EXTENT_NORESERVE) &&",
          "1826:       (*bits & EXTENT_CLEAR_DATA_RESV))",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "1c81ba237bcecad9bc885a1ddcf02d725ea38482",
      "candidate_info": {
        "commit_hash": "1c81ba237bcecad9bc885a1ddcf02d725ea38482",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/1c81ba237bcecad9bc885a1ddcf02d725ea38482",
        "files": [
          "fs/btrfs/inode.c"
        ],
        "message": "Btrfs: fix incorrect space accounting after failure to insert inline extent\n\nWhen using compression, if we fail to insert an inline extent we\nincorrectly end up attempting to free the reserved data space twice,\nonce through extent_clear_unlock_delalloc(), because we pass it the\nflag EXTENT_DO_ACCOUNTING, and once through a direct call to\nbtrfs_free_reserved_data_space_noquota(). This results in a trace\nlike the following:\n\n[  834.576240] ------------[ cut here ]------------\n[  834.576825] WARNING: CPU: 2 PID: 486 at fs/btrfs/extent-tree.c:4316 btrfs_free_reserved_data_space_noquota+0x60/0x9f [btrfs]\n[  834.579501] Modules linked in: btrfs crc32c_generic xor raid6_pq ppdev i2c_piix4 acpi_cpufreq psmouse tpm_tis parport_pc pcspkr serio_raw tpm_tis_core sg parport evdev i2c_core tpm button loop autofs4 ext4 crc16 jbd2 mbcache sr_mod cdrom sd_mod ata_generic virtio_scsi ata_piix virtio_pci libata virtio_ring virtio scsi_mod e1000 floppy [last unloaded: btrfs]\n[  834.592116] CPU: 2 PID: 486 Comm: kworker/u32:4 Not tainted 4.10.0-rc8-btrfs-next-37+ #2\n[  834.593316] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.9.1-0-gb3ef39f-prebuilt.qemu-project.org 04/01/2014\n[  834.595273] Workqueue: btrfs-delalloc btrfs_delalloc_helper [btrfs]\n[  834.596103] Call Trace:\n[  834.596103]  dump_stack+0x67/0x90\n[  834.596103]  __warn+0xc2/0xdd\n[  834.596103]  warn_slowpath_null+0x1d/0x1f\n[  834.596103]  btrfs_free_reserved_data_space_noquota+0x60/0x9f [btrfs]\n[  834.596103]  compress_file_range.constprop.42+0x2fa/0x3fc [btrfs]\n[  834.596103]  ? submit_compressed_extents+0x3a7/0x3a7 [btrfs]\n[  834.596103]  async_cow_start+0x32/0x4d [btrfs]\n[  834.596103]  btrfs_scrubparity_helper+0x187/0x3e7 [btrfs]\n[  834.596103]  btrfs_delalloc_helper+0xe/0x10 [btrfs]\n[  834.596103]  process_one_work+0x273/0x4e4\n[  834.596103]  worker_thread+0x1eb/0x2ca\n[  834.596103]  ? rescuer_thread+0x2b6/0x2b6\n[  834.596103]  kthread+0x100/0x108\n[  834.596103]  ? __list_del_entry+0x22/0x22\n[  834.596103]  ret_from_fork+0x2e/0x40\n[  834.611656] ---[ end trace 719902fe6bdef08f ]---\n\nSo fix this by not calling directly btrfs_free_reserved_data_space_noquota()\nif an error happened.\n\nSigned-off-by: Filipe Manana <fdmanana@suse.com>",
        "before_after_code_files": [
          "fs/btrfs/inode.c||fs/btrfs/inode.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "fs/btrfs/inode.c||fs/btrfs/inode.c": [
          "File: fs/btrfs/inode.c -> fs/btrfs/inode.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "590:            PAGE_SET_WRITEBACK |",
          "591:            page_error_op |",
          "592:            PAGE_END_WRITEBACK);",
          "595:    goto free_pages_out;",
          "596:   }",
          "597:  }",
          "",
          "[Removed Lines]",
          "593:    btrfs_free_reserved_data_space_noquota(inode, start,",
          "594:       end - start + 1);",
          "",
          "[Added Lines]",
          "593:    if (ret == 0)",
          "594:     btrfs_free_reserved_data_space_noquota(inode,",
          "595:               start,",
          "596:               end - start + 1);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "633e8799ddc09431be2744c4a1efdbda13af2b0b",
      "candidate_info": {
        "commit_hash": "633e8799ddc09431be2744c4a1efdbda13af2b0b",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/633e8799ddc09431be2744c4a1efdbda13af2b0b",
        "files": [
          "drivers/power/supply/pda_power.c"
        ],
        "message": "power: supply: pda_power: move from timer to delayed_work\n\nThis changed is needed to avoid locking problem during\nboot as shown:\n\n<5>[    8.824096] Registering SWP/SWPB emulation handler\n<6>[    8.977294] clock: disabling unused clocks to save power\n<3>[    9.108154] BUG: sleeping function called from invalid context at kernel_albert/kernel/mutex.c:269\n<3>[    9.122894] in_atomic(): 1, irqs_disabled(): 0, pid: 1, name: swapper/0\n<4>[    9.130249] 3 locks held by swapper/0/1:\n<4>[    9.134613]  #0:  (&__lockdep_no_validate__){......}, at: [<c0342430>] __driver_attach+0x58/0xa8\n<4>[    9.144500]  #1:  (&__lockdep_no_validate__){......}, at: [<c0342440>] __driver_attach+0x68/0xa8\n<4>[    9.154357]  #2:  (&polling_timer){......}, at: [<c0053770>] run_timer_softirq+0x108/0x3ec\n<4>[    9.163726] Backtrace:\n<4>[    9.166473] [<c001269c>] (dump_backtrace+0x0/0x114) from [<c067e5f0>] (dump_stack+0x20/0x24)\n<4>[    9.175811]  r6:00203230 r5:0000010d r4:d782e000 r3:60000113\n<4>[    9.182250] [<c067e5d0>] (dump_stack+0x0/0x24) from [<c007441c>] (__might_sleep+0x10c/0x128)\n<4>[    9.191650] [<c0074310>] (__might_sleep+0x0/0x128) from [<c0688f60>] (mutex_lock_nested+0x34/0x36c)\n<4>[    9.201660]  r5:c02d5350 r4:d79a0c64\n<4>[    9.205688] [<c0688f2c>] (mutex_lock_nested+0x0/0x36c) from [<c02d5350>] (regulator_set_current_limit+0x30/0x118)\n<4>[    9.217071] [<c02d5320>] (regulator_set_current_limit+0x0/0x118) from [<c0435ce0>] (update_charger+0x84/0xc4)\n<4>[    9.228027]  r7:d782fb20 r6:00000101 r5:c1767e94 r4:00000000\n<4>[    9.234436] [<c0435c5c>] (update_charger+0x0/0xc4) from [<c0435d40>] (psy_changed+0x20/0x48)\n<4>[    9.243804]  r5:d782e000 r4:c1767e94\n<4>[    9.247802] [<c0435d20>] (psy_changed+0x0/0x48) from [<c0435dec>] (polling_timer_func+0x84/0xb8)\n<4>[    9.257537]  r4:c1767e94 r3:00000002\n<4>[    9.261566] [<c0435d68>] (polling_timer_func+0x0/0xb8) from [<c00537e4>] (run_timer_softirq+0x17c/0x3ec)\n<4>[    9.272033]  r4:c1767eb0 r3:00000000\n<4>[    9.276062] [<c0053668>] (run_timer_softirq+0x0/0x3ec) from [<c004b000>] (__do_softirq+0xf0/0x298)\n<4>[    9.286010] [<c004af10>] (__do_softirq+0x0/0x298) from [<c004b650>] (irq_exit+0x98/0xa0)\n<4>[    9.295013] [<c004b5b8>] (irq_exit+0x0/0xa0) from [<c000edbc>] (handle_IRQ+0x60/0xc0)\n<4>[    9.303680]  r4:c1194e98 r3:c00bc778\n<4>[    9.307708] [<c000ed5c>] (handle_IRQ+0x0/0xc0) from [<c0008504>] (gic_handle_irq+0x34/0x68)\n<4>[    9.316955]  r8:000ac383 r7:d782fc3c r6:d782fc08 r5:c11936c4 r4:e0802100\n<4>[    9.324310] r3:c026ba48\n<4>[    9.327301] [<c00084d0>] (gic_handle_irq+0x0/0x68) from [<c068c2c0>] (__irq_svc+0x40/0x74)\n<4>[    9.336456] Exception stack(0xd782fc08 to 0xd782fc50)\n<4>[    9.342041] fc00:                   d6e30e6c ac383627 00000000 ac383417 ea19c000 ea200000\n<4>[    9.351104] fc20: beffffff 00000667 000ac383 d6e30670 d6e3066c d782fc94 d782fbe8 d782fc50\n<4>[    9.360168] fc40: c026ba48 c001d1f0 00000113 ffffffff\n\nFixes: b2998049cfae (\"[BATTERY] pda_power platform driver\")\nSigned-off-by: Michael Trimarchi <michael@amarulasolutions.com>\nSigned-off-by: Anthony Brandon <anthony@amarulasolutions.com>\nSigned-off-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>",
        "before_after_code_files": [
          "drivers/power/supply/pda_power.c||drivers/power/supply/pda_power.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/power/supply/pda_power.c||drivers/power/supply/pda_power.c": [
          "File: drivers/power/supply/pda_power.c -> drivers/power/supply/pda_power.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "30: static struct device *dev;",
          "31: static struct pda_power_pdata *pdata;",
          "32: static struct resource *ac_irq, *usb_irq;",
          "36: static int polling;",
          "37: static struct power_supply *pda_psy_ac, *pda_psy_usb;",
          "",
          "[Removed Lines]",
          "33: static struct timer_list charger_timer;",
          "34: static struct timer_list supply_timer;",
          "35: static struct timer_list polling_timer;",
          "",
          "[Added Lines]",
          "33: static struct delayed_work charger_work;",
          "34: static struct delayed_work polling_work;",
          "35: static struct delayed_work supply_work;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "140:  }",
          "141: }",
          "144: {",
          "145:  if (ac_status == PDA_PSY_TO_CHANGE) {",
          "146:   ac_status = new_ac_status;",
          "",
          "[Removed Lines]",
          "143: static void supply_timer_func(unsigned long unused)",
          "",
          "[Added Lines]",
          "143: static void supply_work_func(struct work_struct *work)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "166: }",
          "169: {",
          "170:  update_status();",
          "171:  psy_changed();",
          "",
          "[Removed Lines]",
          "164:  mod_timer(&supply_timer,",
          "165:     jiffies + msecs_to_jiffies(pdata->wait_for_charger));",
          "168: static void charger_timer_func(unsigned long unused)",
          "",
          "[Added Lines]",
          "164:  cancel_delayed_work(&supply_work);",
          "165:  schedule_delayed_work(&supply_work,",
          "166:          msecs_to_jiffies(pdata->wait_for_charger));",
          "169: static void charger_work_func(struct work_struct *work)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "190:  return IRQ_HANDLED;",
          "191: }",
          "194: {",
          "195:  int changed = 0;",
          "",
          "[Removed Lines]",
          "187:  mod_timer(&charger_timer,",
          "188:     jiffies + msecs_to_jiffies(pdata->wait_for_status));",
          "193: static void polling_timer_func(unsigned long unused)",
          "",
          "[Added Lines]",
          "188:  cancel_delayed_work(&charger_work);",
          "189:  schedule_delayed_work(&charger_work,",
          "190:          msecs_to_jiffies(pdata->wait_for_status));",
          "195: static void polling_work_func(struct work_struct *work)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "211:  if (changed)",
          "212:   psy_changed();",
          "216: }",
          "218: #if IS_ENABLED(CONFIG_USB_PHY)",
          "",
          "[Removed Lines]",
          "214:  mod_timer(&polling_timer,",
          "215:     jiffies + msecs_to_jiffies(pdata->polling_interval));",
          "",
          "[Added Lines]",
          "216:  cancel_delayed_work(&polling_work);",
          "217:  schedule_delayed_work(&polling_work,",
          "218:          msecs_to_jiffies(pdata->polling_interval));",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "256:  return NOTIFY_OK;",
          "257: }",
          "",
          "[Removed Lines]",
          "253:  mod_timer(&charger_timer,",
          "254:     jiffies + msecs_to_jiffies(pdata->wait_for_status));",
          "",
          "[Added Lines]",
          "256:  cancel_delayed_work(&charger_work);",
          "257:  schedule_delayed_work(&charger_work,",
          "258:          msecs_to_jiffies(pdata->wait_for_status));",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "300:  if (!pdata->ac_max_uA)",
          "301:   pdata->ac_max_uA = 500000;",
          "306:  ac_irq = platform_get_resource_byname(pdev, IORESOURCE_IRQ, \"ac\");",
          "307:  usb_irq = platform_get_resource_byname(pdev, IORESOURCE_IRQ, \"usb\");",
          "",
          "[Removed Lines]",
          "303:  setup_timer(&charger_timer, charger_timer_func, 0);",
          "304:  setup_timer(&supply_timer, supply_timer_func, 0);",
          "",
          "[Added Lines]",
          "307:  INIT_DELAYED_WORK(&charger_work, charger_work_func);",
          "308:  INIT_DELAYED_WORK(&supply_work, supply_work_func);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "386:  if (polling) {",
          "387:   dev_dbg(dev, \"will poll for status\\n\");",
          "391:  }",
          "393:  if (ac_irq || usb_irq)",
          "",
          "[Removed Lines]",
          "388:   setup_timer(&polling_timer, polling_timer_func, 0);",
          "389:   mod_timer(&polling_timer,",
          "390:      jiffies + msecs_to_jiffies(pdata->polling_interval));",
          "",
          "[Added Lines]",
          "392:   INIT_DELAYED_WORK(&polling_work, polling_work_func);",
          "393:   cancel_delayed_work(&polling_work);",
          "394:   schedule_delayed_work(&polling_work,",
          "395:           msecs_to_jiffies(pdata->polling_interval));",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "433:   free_irq(ac_irq->start, pda_psy_ac);",
          "435:  if (polling)",
          "440:  if (pdata->is_usb_online)",
          "441:   power_supply_unregister(pda_psy_usb);",
          "",
          "[Removed Lines]",
          "436:   del_timer_sync(&polling_timer);",
          "437:  del_timer_sync(&charger_timer);",
          "438:  del_timer_sync(&supply_timer);",
          "",
          "[Added Lines]",
          "441:   cancel_delayed_work_sync(&polling_work);",
          "442:  cancel_delayed_work_sync(&charger_work);",
          "443:  cancel_delayed_work_sync(&supply_work);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2016-5353",
  "cve_desc": "epan/dissectors/packet-umts_fp.c in the UMTS FP dissector in Wireshark 1.12.x before 1.12.12 and 2.x before 2.0.4 mishandles the reserved C/T value, which allows remote attackers to cause a denial of service (application crash) via a crafted packet.",
  "repo": "wireshark/wireshark",
  "patch_hash": "7d7190695ce2ff269fdffb04e87139995cde21f4",
  "patch_info": {
    "commit_hash": "7d7190695ce2ff269fdffb04e87139995cde21f4",
    "repo": "wireshark/wireshark",
    "commit_url": "https://github.com/wireshark/wireshark/commit/7d7190695ce2ff269fdffb04e87139995cde21f4",
    "files": [
      "epan/dissectors/packet-umts_fp.c"
    ],
    "message": "UMTS_FP: fix handling reserved C/T value\n\nThe spec puts the reserved value at 0xf but our internal table has 'unknown' at\n0; since all the other values seem to be offset-by-one, just take the modulus\n0xf to avoid running off the end of the table.\n\nBug: 12191\nChange-Id: I83c8fb66797bbdee52a2246fb1eea6e37cbc7eb0\nReviewed-on: https://code.wireshark.org/review/15722\nReviewed-by: Evan Huus <eapache@gmail.com>\nPetri-Dish: Evan Huus <eapache@gmail.com>\nTested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>\nReviewed-by: Michael Mann <mmann78@netscape.net>",
    "before_after_code_files": [
      "epan/dissectors/packet-umts_fp.c||epan/dissectors/packet-umts_fp.c"
    ]
  },
  "patch_diff": {
    "epan/dissectors/packet-umts_fp.c||epan/dissectors/packet-umts_fp.c": [
      "File: epan/dissectors/packet-umts_fp.c -> epan/dissectors/packet-umts_fp.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "4106:                             }",
      "4107:                         } else {",
      "4108:                             fake_lchid = make_fake_lchid(pinfo, p_conv_data->dchs_in_flow_list[chan]);",
      "",
      "[Removed Lines]",
      "4102:                                 macinf->lchid[j+chan] = c_t+1;",
      "",
      "[Added Lines]",
      "4102:                                 macinf->lchid[j+chan] = c_t;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "ff27d85e3ec903d647847f8aeef3476fe8b27e91",
      "candidate_info": {
        "commit_hash": "ff27d85e3ec903d647847f8aeef3476fe8b27e91",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/ff27d85e3ec903d647847f8aeef3476fe8b27e91",
        "files": [
          "epan/dissectors/packet-umts_fp.c"
        ],
        "message": "UMTS_FP: fix handling reserved C/T value\n\nThe spec puts the reserved value at 0xf but our internal table has 'unknown' at\n0; since all the other values seem to be offset-by-one, just take the modulus\n0xf to avoid running off the end of the table.\n\nBug: 12191\nChange-Id: I83c8fb66797bbdee52a2246fb1eea6e37cbc7eb0\nReviewed-on: https://code.wireshark.org/review/15722\nReviewed-by: Evan Huus <eapache@gmail.com>\nPetri-Dish: Evan Huus <eapache@gmail.com>\nTested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>\nReviewed-by: Michael Mann <mmann78@netscape.net>\n(cherry picked from commit 7d7190695ce2ff269fdffb04e87139995cde21f4)\nReviewed-on: https://code.wireshark.org/review/15725\nPetri-Dish: Michael Mann <mmann78@netscape.net>",
        "before_after_code_files": [
          "epan/dissectors/packet-umts_fp.c||epan/dissectors/packet-umts_fp.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "epan/dissectors/packet-umts_fp.c||epan/dissectors/packet-umts_fp.c"
          ],
          "candidate": [
            "epan/dissectors/packet-umts_fp.c||epan/dissectors/packet-umts_fp.c"
          ]
        }
      },
      "candidate_diff": {
        "epan/dissectors/packet-umts_fp.c||epan/dissectors/packet-umts_fp.c": [
          "File: epan/dissectors/packet-umts_fp.c -> epan/dissectors/packet-umts_fp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4052:                             }",
          "4053:                         } else {",
          "4054:                             fake_lchid = make_fake_lchid(pinfo, p_conv_data->dchs_in_flow_list[chan]);",
          "",
          "[Removed Lines]",
          "4048:                                 macinf->lchid[j+chan] = c_t+1;",
          "",
          "[Added Lines]",
          "4048:                                 macinf->lchid[j+chan] = c_t;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "fb9dcfa8e5df3ea3207335491b86be8cbb21eeaf",
      "candidate_info": {
        "commit_hash": "fb9dcfa8e5df3ea3207335491b86be8cbb21eeaf",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/fb9dcfa8e5df3ea3207335491b86be8cbb21eeaf",
        "files": [
          "epan/dissectors/packet-umts_fp.c"
        ],
        "message": "UMTS_FP: fix handling reserved C/T value\n\nThe spec puts the reserved value at 0xf but our internal table has 'unknown' at\n0; since all the other values seem to be offset-by-one, just take the modulus\n0xf to avoid running off the end of the table.\n\n# Conflicts:\n#\tepan/dissectors/packet-umts_fp.c\n\nBug: 12191\nChange-Id: I83c8fb66797bbdee52a2246fb1eea6e37cbc7eb0\nReviewed-on: https://code.wireshark.org/review/15722\nReviewed-by: Evan Huus <eapache@gmail.com>\nPetri-Dish: Evan Huus <eapache@gmail.com>\nTested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>\nReviewed-by: Michael Mann <mmann78@netscape.net>\n(cherry picked from commit 7d7190695ce2ff269fdffb04e87139995cde21f4)\nReviewed-on: https://code.wireshark.org/review/15726",
        "before_after_code_files": [
          "epan/dissectors/packet-umts_fp.c||epan/dissectors/packet-umts_fp.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "epan/dissectors/packet-umts_fp.c||epan/dissectors/packet-umts_fp.c"
          ],
          "candidate": [
            "epan/dissectors/packet-umts_fp.c||epan/dissectors/packet-umts_fp.c"
          ]
        }
      },
      "candidate_diff": {
        "epan/dissectors/packet-umts_fp.c||epan/dissectors/packet-umts_fp.c": [
          "File: epan/dissectors/packet-umts_fp.c -> epan/dissectors/packet-umts_fp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4056:                             }",
          "4057:                         }else{",
          "4058:        fake_lchid = make_fake_lchid(pinfo,p_conv_data->dchs_in_flow_list[chan]);",
          "",
          "[Removed Lines]",
          "4052:                                 macinf->lchid[j+chan] = c_t+1;",
          "",
          "[Added Lines]",
          "4052:                                 macinf->lchid[j+chan] = c_t;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "024bf5dfd68da67dd00475a5fea7cfabf03da8fa",
      "candidate_info": {
        "commit_hash": "024bf5dfd68da67dd00475a5fea7cfabf03da8fa",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/024bf5dfd68da67dd00475a5fea7cfabf03da8fa",
        "files": [
          "epan/dissectors/packet-umts_fp.c"
        ],
        "message": "UMTS_FP: fix handling reserved C/T value\n\nThe spec puts the reserved value at 0xf but our internal table has 'unknown' at\n0; since all the other values seem to be offset-by-one, just take the modulus\n0xf to avoid running off the end of the table.\n\n# Conflicts:\n#\tepan/dissectors/packet-umts_fp.c\n\nBug: 12191\nChange-Id: I83c8fb66797bbdee52a2246fb1eea6e37cbc7eb0\nReviewed-on: https://code.wireshark.org/review/15722\nReviewed-by: Evan Huus <eapache@gmail.com>\nPetri-Dish: Evan Huus <eapache@gmail.com>\nTested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>\nReviewed-by: Michael Mann <mmann78@netscape.net>\n(cherry picked from commit 7d7190695ce2ff269fdffb04e87139995cde21f4)\nReviewed-on: https://code.wireshark.org/review/15726\n(cherry picked from commit fb9dcfa8e5df3ea3207335491b86be8cbb21eeaf)\nReviewed-on: https://code.wireshark.org/review/16118\nReviewed-by: Balint Reczey <balint@balintreczey.hu>",
        "before_after_code_files": [
          "epan/dissectors/packet-umts_fp.c||epan/dissectors/packet-umts_fp.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "epan/dissectors/packet-umts_fp.c||epan/dissectors/packet-umts_fp.c"
          ],
          "candidate": [
            "epan/dissectors/packet-umts_fp.c||epan/dissectors/packet-umts_fp.c"
          ]
        }
      },
      "candidate_diff": {
        "epan/dissectors/packet-umts_fp.c||epan/dissectors/packet-umts_fp.c": [
          "File: epan/dissectors/packet-umts_fp.c -> epan/dissectors/packet-umts_fp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4056:                             }",
          "4057:                         }else{",
          "4058:        fake_lchid = make_fake_lchid(pinfo,p_conv_data->dchs_in_flow_list[chan]);",
          "",
          "[Removed Lines]",
          "4052:                                 macinf->lchid[j+chan] = c_t+1;",
          "",
          "[Added Lines]",
          "4052:                                 macinf->lchid[j+chan] = c_t;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "cd55bd29258b8e0ffae9ea9471059b457ebb59ae",
      "candidate_info": {
        "commit_hash": "cd55bd29258b8e0ffae9ea9471059b457ebb59ae",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/cd55bd29258b8e0ffae9ea9471059b457ebb59ae",
        "files": [
          "epan/dissectors/packet-umts_fp.c"
        ],
        "message": "UMTS FP: Improved MAC multiplexing detection\n\nPrevious detection was based on DCH ID 31 or 24 and specific TB Size.\nNew method checks if the 'Transport Format' looks like the commonly used format for DCCH over DCH or DCH ID 24 and specific TB size (To not break that special case which I'm not familiar with personally)\n\nChange-Id: I59fe7772ec05f7cc15351ef78276085e25570461\nReviewed-on: https://code.wireshark.org/review/21304\nPetri-Dish: Anders Broman <a.broman58@gmail.com>\nTested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>\nReviewed-by: Anders Broman <a.broman58@gmail.com>",
        "before_after_code_files": [
          "epan/dissectors/packet-umts_fp.c||epan/dissectors/packet-umts_fp.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "epan/dissectors/packet-umts_fp.c||epan/dissectors/packet-umts_fp.c"
          ],
          "candidate": [
            "epan/dissectors/packet-umts_fp.c||epan/dissectors/packet-umts_fp.c"
          ]
        }
      },
      "candidate_diff": {
        "epan/dissectors/packet-umts_fp.c||epan/dissectors/packet-umts_fp.c": [
          "File: epan/dissectors/packet-umts_fp.c -> epan/dissectors/packet-umts_fp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4834:     guint8    tfi, c_t;",
          "4835:     int       offset = 0, i=0, j=0, num_tbs, chan, tb_size, tb_bit_off;",
          "4836:     gboolean  is_control_frame;",
          "4837:     umts_mac_info *macinf;",
          "4838:     rlc_info *rlcinf;",
          "4839:     guint8 fake_lchid=0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4837:     gboolean  is_known_dcch_tf,is_special_case_dch_24;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "4984:             rlcinf = wmem_new0(wmem_file_scope(), rlc_info);",
          "4985:             macinf = wmem_new0(wmem_file_scope(), umts_mac_info);",
          "5003:                     }",
          "5072:                         }",
          "5075: #if 0",
          "5083:                         rlcinf->ciphered[j+chan] = FALSE;",
          "5090:                     }",
          "5093:             }",
          "5094:             p_add_proto_data(wmem_file_scope(), pinfo, proto_umts_mac, 0, macinf);",
          "5095:             p_add_proto_data(wmem_file_scope(), pinfo, proto_rlc, 0, rlcinf);",
          "",
          "[Removed Lines]",
          "4992:                     tfi = tvb_get_bits8(tvb, 3+offset*8, 5);",
          "4995:                    num_tbs = (fpi->is_uplink) ? p_conv_data->fp_dch_channel_info[chan].ul_chan_num_tbs[tfi] : p_conv_data->fp_dch_channel_info[chan].dl_chan_num_tbs[tfi];",
          "4996:                    tb_size=  (fpi->is_uplink) ? p_conv_data->fp_dch_channel_info[i].ul_chan_tf_size[tfi] :    p_conv_data->fp_dch_channel_info[i].dl_chan_tf_size[tfi];",
          "5000:                     if ( p_conv_data->dchs_in_flow_list[chan] != 31 && (p_conv_data->dchs_in_flow_list[chan] == 24 &&",
          "5001:                      tb_size != 340) ) {",
          "5002:                         fake_lchid = make_fake_lchid(pinfo, p_conv_data->dchs_in_flow_list[chan]);",
          "5006:                     for (j=0; j < num_tbs && j+chan < MAX_MAC_FRAMES; j++) {",
          "5008:                         macinf->trchid[j+chan] = p_conv_data->dchs_in_flow_list[chan];",
          "5011:                         if ( p_conv_data->dchs_in_flow_list[chan] == 31 || p_conv_data->dchs_in_flow_list[chan] == 24) {",
          "5015:                             if (0/*p_conv_data->dchs_in_flow_list[chan] == 31 && num_tbs == 1*/) {",
          "5018:                                 macinf->lchid[j+chan] = 1;",
          "5023:                             }",
          "5025:                             else if (p_conv_data->dchs_in_flow_list[chan] == 24 && tb_size != 340) {",
          "5029:                                 macinf->lchid[j+chan] = fake_lchid;",
          "5030:                                 macinf->fake_chid[j+chan] = TRUE;",
          "5033:                             }",
          "5035:                             else {",
          "5041:                                 macinf->lchid[j+chan] = c_t;",
          "5045:                             }",
          "5046:                         } else {",
          "5047:                             fake_lchid = make_fake_lchid(pinfo, p_conv_data->dchs_in_flow_list[chan]);",
          "5050:                             macinf->content[j+chan] = lchId_type_table[fake_lchid];",
          "5053:                             rlcinf->mode[j+chan] = lchId_rlc_map[fake_lchid];",
          "5058:                             macinf->fake_chid[j+chan] = TRUE;",
          "5061:                         }",
          "5066:                         user_identity = p_conv_data->com_context_id;",
          "5067:                         if (p_conv_data->scrambling_code != 0) {",
          "5068:                             guint32 * mapped_urnti = (guint32 *)g_tree_lookup(rrc_scrambling_code_urnti, GUINT_TO_POINTER(p_conv_data->scrambling_code));",
          "5069:                             if (mapped_urnti != 0) {",
          "5070:                                 user_identity = GPOINTER_TO_UINT(mapped_urnti);",
          "5071:                             }",
          "5073:                         rlcinf->urnti[j + chan] = user_identity;",
          "5074:                         rlcinf->li_size[j+chan] = RLC_LI_7BITS;",
          "5077:                         if ( rrc_ciph_inf && g_tree_lookup(rrc_ciph_inf, GINT_TO_POINTER((gint)p_conv_data->com_context_id)) != NULL ) {",
          "5078:                             rlcinf->ciphered[j+chan] = TRUE;",
          "5079:                         } else {",
          "5080:                             rlcinf->ciphered[j+chan] = FALSE;",
          "5081:                         }",
          "5082: #endif",
          "5084:                         rlcinf->deciphered[j+chan] = FALSE;",
          "5085:                         rlcinf->rbid[j+chan] = macinf->lchid[j+chan];",
          "5089:                         tb_bit_off += tb_size+4;",
          "5092:                     offset++;",
          "",
          "[Added Lines]",
          "4992:                 tfi = tvb_get_bits8(tvb, 3+offset*8, 5);",
          "4995:                 num_tbs = (fpi->is_uplink) ? p_conv_data->fp_dch_channel_info[chan].ul_chan_num_tbs[tfi] : p_conv_data->fp_dch_channel_info[chan].dl_chan_num_tbs[tfi];",
          "4996:                 tb_size =  (fpi->is_uplink) ? p_conv_data->fp_dch_channel_info[i].ul_chan_tf_size[tfi] :    p_conv_data->fp_dch_channel_info[i].dl_chan_tf_size[tfi];",
          "5000:                 for (j=0; j < num_tbs && j+chan < MAX_MAC_FRAMES; j++) {",
          "5002:                     macinf->trchid[j+chan] = p_conv_data->dchs_in_flow_list[chan];",
          "5005:                     is_known_dcch_tf = (tfi == 1 && num_tbs == 1 && tb_size == 148);",
          "5007:                     is_special_case_dch_24 = (p_conv_data->dchs_in_flow_list[chan] == 24 && tb_size == 340);",
          "5010:                     if (is_known_dcch_tf || is_special_case_dch_24) {",
          "5012:                         macinf->ctmux[j+chan] = TRUE;",
          "5016:                         c_t = (tvb_get_bits8(tvb, tb_bit_off, 4) + 1) % 0xf;",
          "5021:                     else {",
          "5024:                         macinf->ctmux[j+chan] = FALSE;",
          "5028:                         fake_lchid = make_fake_lchid(pinfo, p_conv_data->dchs_in_flow_list[chan]);",
          "5029:                         macinf->content[j+chan] = lchId_type_table[fake_lchid];",
          "5030:                         rlcinf->mode[j+chan] = lchId_rlc_map[fake_lchid];",
          "5034:                         macinf->fake_chid[j+chan] = TRUE;",
          "5035:                         macinf->lchid[j+chan] = fake_lchid;",
          "5037:                     }",
          "5042:                     user_identity = p_conv_data->com_context_id;",
          "5043:                     if (p_conv_data->scrambling_code != 0) {",
          "5044:                         guint32 * mapped_urnti = (guint32 *)g_tree_lookup(rrc_scrambling_code_urnti, GUINT_TO_POINTER(p_conv_data->scrambling_code));",
          "5045:                         if (mapped_urnti != 0) {",
          "5046:                             user_identity = GPOINTER_TO_UINT(mapped_urnti);",
          "5048:                     }",
          "5049:                     rlcinf->urnti[j + chan] = user_identity;",
          "5050:                     rlcinf->li_size[j+chan] = RLC_LI_7BITS;",
          "5053:                     if ( rrc_ciph_inf && g_tree_lookup(rrc_ciph_inf, GINT_TO_POINTER((gint)p_conv_data->com_context_id)) != NULL ) {",
          "5054:                         rlcinf->ciphered[j+chan] = TRUE;",
          "5055:                     } else {",
          "5058: #endif",
          "5059:                     rlcinf->ciphered[j+chan] = FALSE;",
          "5060:                     rlcinf->deciphered[j+chan] = FALSE;",
          "5061:                     rlcinf->rbid[j+chan] = macinf->lchid[j+chan];",
          "5064:                     tb_bit_off += tb_size+4;",
          "5065:                 }",
          "5067:                 offset++;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
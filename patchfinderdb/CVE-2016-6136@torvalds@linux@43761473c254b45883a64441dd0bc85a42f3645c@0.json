{
  "cve_id": "CVE-2016-6136",
  "cve_desc": "Race condition in the audit_log_single_execve_arg function in kernel/auditsc.c in the Linux kernel through 4.7 allows local users to bypass intended character-set restrictions or disrupt system-call auditing by changing a certain string, aka a \"double fetch\" vulnerability.",
  "repo": "torvalds/linux",
  "patch_hash": "43761473c254b45883a64441dd0bc85a42f3645c",
  "patch_info": {
    "commit_hash": "43761473c254b45883a64441dd0bc85a42f3645c",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/43761473c254b45883a64441dd0bc85a42f3645c",
    "files": [
      "kernel/auditsc.c"
    ],
    "message": "audit: fix a double fetch in audit_log_single_execve_arg()\n\nThere is a double fetch problem in audit_log_single_execve_arg()\nwhere we first check the execve(2) argumnets for any \"bad\" characters\nwhich would require hex encoding and then re-fetch the arguments for\nlogging in the audit record[1].  Of course this leaves a window of\nopportunity for an unsavory application to munge with the data.\n\nThis patch reworks things by only fetching the argument data once[2]\ninto a buffer where it is scanned and logged into the audit\nrecords(s).  In addition to fixing the double fetch, this patch\nimproves on the original code in a few other ways: better handling\nof large arguments which require encoding, stricter record length\nchecking, and some performance improvements (completely unverified,\nbut we got rid of some strlen() calls, that's got to be a good\nthing).\n\nAs part of the development of this patch, I've also created a basic\nregression test for the audit-testsuite, the test can be tracked on\nGitHub at the following link:\n\n * https://github.com/linux-audit/audit-testsuite/issues/25\n\n[1] If you pay careful attention, there is actually a triple fetch\nproblem due to a strnlen_user() call at the top of the function.\n\n[2] This is a tiny white lie, we do make a call to strnlen_user()\nprior to fetching the argument data.  I don't like it, but due to the\nway the audit record is structured we really have no choice unless we\ncopy the entire argument at once (which would require a rather\nwasteful allocation).  The good news is that with this patch the\nkernel no longer relies on this strnlen_user() value for anything\nbeyond recording it in the log, we also update it with a trustworthy\nvalue whenever possible.\n\nReported-by: Pengfei Wang <wpengfeinudt@gmail.com>\nCc: <stable@vger.kernel.org>\nSigned-off-by: Paul Moore <paul@paul-moore.com>",
    "before_after_code_files": [
      "kernel/auditsc.c||kernel/auditsc.c"
    ]
  },
  "patch_diff": {
    "kernel/auditsc.c||kernel/auditsc.c": [
      "File: kernel/auditsc.c -> kernel/auditsc.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "73: #include <linux/compat.h>",
      "74: #include <linux/ctype.h>",
      "75: #include <linux/string.h>",
      "76: #include <uapi/linux/limits.h>",
      "78: #include \"audit.h\"",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "76: #include <linux/uaccess.h>",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "992:  return rc;",
      "993: }",
      "1012: {",
      "1034:  }",
      "1037:  do {",
      "1116:   }",
      "1173: }",
      "1175: static void show_special(struct audit_context *context, int *call_panic)",
      "",
      "[Removed Lines]",
      "1006: static int audit_log_single_execve_arg(struct audit_context *context,",
      "1007:      struct audit_buffer **ab,",
      "1008:      int arg_num,",
      "1009:      size_t *len_sent,",
      "1010:      const char __user *p,",
      "1011:      char *buf)",
      "1013:  char arg_num_len_buf[12];",
      "1014:  const char __user *tmp_p = p;",
      "1016:  size_t arg_num_len = snprintf(arg_num_len_buf, 12, \"%d\", arg_num) + 5;",
      "1017:  size_t len, len_left, to_send;",
      "1018:  size_t max_execve_audit_len = MAX_EXECVE_AUDIT_LEN;",
      "1019:  unsigned int i, has_cntl = 0, too_long = 0;",
      "1020:  int ret;",
      "1023:  len_left = len = strnlen_user(p, MAX_ARG_STRLEN) - 1;",
      "1031:  if (WARN_ON_ONCE(len < 0 || len > MAX_ARG_STRLEN - 1)) {",
      "1032:   send_sig(SIGKILL, current, 0);",
      "1033:   return -1;",
      "1038:   if (len_left > MAX_EXECVE_AUDIT_LEN)",
      "1039:    to_send = MAX_EXECVE_AUDIT_LEN;",
      "1040:   else",
      "1041:    to_send = len_left;",
      "1042:   ret = copy_from_user(buf, tmp_p, to_send);",
      "1048:   if (ret) {",
      "1049:    WARN_ON(1);",
      "1050:    send_sig(SIGKILL, current, 0);",
      "1051:    return -1;",
      "1052:   }",
      "1053:   buf[to_send] = '\\0';",
      "1054:   has_cntl = audit_string_contains_control(buf, to_send);",
      "1055:   if (has_cntl) {",
      "1060:    max_execve_audit_len = MAX_EXECVE_AUDIT_LEN / 2;",
      "1061:    break;",
      "1062:   }",
      "1063:   len_left -= to_send;",
      "1064:   tmp_p += to_send;",
      "1065:  } while (len_left > 0);",
      "1067:  len_left = len;",
      "1069:  if (len > max_execve_audit_len)",
      "1070:   too_long = 1;",
      "1073:  for (i = 0; len_left > 0; i++) {",
      "1074:   int room_left;",
      "1076:   if (len_left > max_execve_audit_len)",
      "1077:    to_send = max_execve_audit_len;",
      "1078:   else",
      "1079:    to_send = len_left;",
      "1082:   room_left = MAX_EXECVE_AUDIT_LEN - arg_num_len - *len_sent;",
      "1083:   if (has_cntl)",
      "1084:    room_left -= (to_send * 2);",
      "1085:   else",
      "1086:    room_left -= to_send;",
      "1087:   if (room_left < 0) {",
      "1089:    audit_log_end(*ab);",
      "1091:    if (!*ab)",
      "1092:     return 0;",
      "1093:   }",
      "1099:   if ((i == 0) && (too_long))",
      "1100:    audit_log_format(*ab, \" a%d_len=%zu\", arg_num,",
      "1101:       has_cntl ? 2*len : len);",
      "1108:   if (len >= max_execve_audit_len)",
      "1109:    ret = copy_from_user(buf, p, to_send);",
      "1110:   else",
      "1111:    ret = 0;",
      "1112:   if (ret) {",
      "1113:    WARN_ON(1);",
      "1114:    send_sig(SIGKILL, current, 0);",
      "1115:    return -1;",
      "1117:   buf[to_send] = '\\0';",
      "1120:   audit_log_format(*ab, \" a%d\", arg_num);",
      "1121:   if (too_long)",
      "1122:    audit_log_format(*ab, \"[%d]\", i);",
      "1123:   audit_log_format(*ab, \"=\");",
      "1124:   if (has_cntl)",
      "1125:    audit_log_n_hex(*ab, buf, to_send);",
      "1126:   else",
      "1127:    audit_log_string(*ab, buf);",
      "1129:   p += to_send;",
      "1130:   len_left -= to_send;",
      "1132:   if (has_cntl)",
      "1134:   else",
      "1136:  }",
      "1138:  return len + 1;",
      "1139: }",
      "1141: static void audit_log_execve_info(struct audit_context *context,",
      "1142:       struct audit_buffer **ab)",
      "1143: {",
      "1144:  int i, len;",
      "1145:  size_t len_sent = 0;",
      "1146:  const char __user *p;",
      "1147:  char *buf;",
      "1149:  p = (const char __user *)current->mm->arg_start;",
      "1151:  audit_log_format(*ab, \"argc=%d\", context->execve.argc);",
      "1159:  buf = kmalloc(MAX_EXECVE_AUDIT_LEN + 1, GFP_KERNEL);",
      "1160:  if (!buf) {",
      "1161:   audit_panic(\"out of memory for argv string\");",
      "1162:   return;",
      "1163:  }",
      "1165:  for (i = 0; i < context->execve.argc; i++) {",
      "1166:   len = audit_log_single_execve_arg(context, ab, i,",
      "1167:         &len_sent, p, buf);",
      "1168:   if (len <= 0)",
      "1169:    break;",
      "1170:   p += len;",
      "1171:  }",
      "1172:  kfree(buf);",
      "",
      "[Added Lines]",
      "997: static void audit_log_execve_info(struct audit_context *context,",
      "998:       struct audit_buffer **ab)",
      "1000:  long len_max;",
      "1001:  long len_rem;",
      "1002:  long len_full;",
      "1003:  long len_buf;",
      "1004:  long len_abuf;",
      "1005:  long len_tmp;",
      "1006:  bool require_data;",
      "1007:  bool encode;",
      "1008:  unsigned int iter;",
      "1009:  unsigned int arg;",
      "1010:  char *buf_head;",
      "1011:  char *buf;",
      "1012:  const char __user *p = (const char __user *)current->mm->arg_start;",
      "1017:  char abuf[96];",
      "1023:  WARN_ON_ONCE(MAX_EXECVE_AUDIT_LEN > 7500);",
      "1024:  len_max = MAX_EXECVE_AUDIT_LEN;",
      "1027:  buf_head = kmalloc(MAX_EXECVE_AUDIT_LEN + 1, GFP_KERNEL);",
      "1028:  if (!buf_head) {",
      "1029:   audit_panic(\"out of memory for argv string\");",
      "1030:   return;",
      "1032:  buf = buf_head;",
      "1034:  audit_log_format(*ab, \"argc=%d\", context->execve.argc);",
      "1036:  len_rem = len_max;",
      "1037:  len_buf = 0;",
      "1038:  len_full = 0;",
      "1039:  require_data = true;",
      "1040:  encode = false;",
      "1041:  iter = 0;",
      "1042:  arg = 0;",
      "1051:   if (len_full == 0)",
      "1052:    len_full = strnlen_user(p, MAX_ARG_STRLEN) - 1;",
      "1055:   if (require_data) {",
      "1057:    if (buf != buf_head) {",
      "1058:     memmove(buf_head, buf, len_buf);",
      "1059:     buf = buf_head;",
      "1060:    }",
      "1063:    len_tmp = strncpy_from_user(&buf_head[len_buf], p,",
      "1064:           len_max - len_buf);",
      "1065:    if (len_tmp == -EFAULT) {",
      "1067:     send_sig(SIGKILL, current, 0);",
      "1068:     goto out;",
      "1069:    } else if (len_tmp == (len_max - len_buf)) {",
      "1071:     require_data = true;",
      "1076:     encode = true;",
      "1077:     len_full = len_full * 2;",
      "1078:     p += len_tmp;",
      "1079:    } else {",
      "1080:     require_data = false;",
      "1081:     if (!encode)",
      "1082:      encode = audit_string_contains_control(",
      "1083:         buf, len_tmp);",
      "1085:     if (len_full < len_max)",
      "1086:      len_full = (encode ?",
      "1087:           len_tmp * 2 : len_tmp);",
      "1088:     p += len_tmp + 1;",
      "1089:    }",
      "1090:    len_buf += len_tmp;",
      "1091:    buf_head[len_buf] = '\\0';",
      "1094:    len_abuf = (encode ? len_buf * 2 : len_buf + 2);",
      "1098:   if (len_buf > 0) {",
      "1103:    if ((sizeof(abuf) + 8) > len_rem) {",
      "1104:     len_rem = len_max;",
      "1105:     audit_log_end(*ab);",
      "1107:             GFP_KERNEL, AUDIT_EXECVE);",
      "1108:     if (!*ab)",
      "1109:      goto out;",
      "1110:    }",
      "1113:    len_tmp = 0;",
      "1114:    if (require_data || (iter > 0) ||",
      "1115:        ((len_abuf + sizeof(abuf)) > len_rem)) {",
      "1116:     if (iter == 0) {",
      "1117:      len_tmp += snprintf(&abuf[len_tmp],",
      "1118:        sizeof(abuf) - len_tmp,",
      "1119:        \" a%d_len=%lu\",",
      "1120:        arg, len_full);",
      "1121:     }",
      "1122:     len_tmp += snprintf(&abuf[len_tmp],",
      "1123:           sizeof(abuf) - len_tmp,",
      "1124:           \" a%d[%d]=\", arg, iter++);",
      "1125:    } else",
      "1126:     len_tmp += snprintf(&abuf[len_tmp],",
      "1127:           sizeof(abuf) - len_tmp,",
      "1128:           \" a%d=\", arg);",
      "1129:    WARN_ON(len_tmp >= sizeof(abuf));",
      "1130:    abuf[sizeof(abuf) - 1] = '\\0';",
      "1133:    audit_log_format(*ab, \"%s\", abuf);",
      "1134:    len_rem -= len_tmp;",
      "1135:    len_tmp = len_buf;",
      "1136:    if (encode) {",
      "1137:     if (len_abuf > len_rem)",
      "1139:     audit_log_n_hex(*ab, buf, len_tmp);",
      "1140:     len_rem -= len_tmp * 2;",
      "1141:     len_abuf -= len_tmp * 2;",
      "1142:    } else {",
      "1143:     if (len_abuf > len_rem)",
      "1145:     audit_log_n_string(*ab, buf, len_tmp);",
      "1146:     len_rem -= len_tmp + 2;",
      "1149:     len_abuf -= len_tmp;",
      "1150:    }",
      "1151:    len_buf -= len_tmp;",
      "1152:    buf += len_tmp;",
      "1153:   }",
      "1156:   if ((len_buf == 0) && !require_data) {",
      "1157:    arg++;",
      "1158:    iter = 0;",
      "1159:    len_full = 0;",
      "1160:    require_data = true;",
      "1161:    encode = false;",
      "1162:   }",
      "1163:  } while (arg < context->execve.argc);",
      "1167: out:",
      "1168:  kfree(buf_head);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "8443075eacb51df8539916c4170d2fdfe7c81433",
      "candidate_info": {
        "commit_hash": "8443075eacb51df8539916c4170d2fdfe7c81433",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/8443075eacb51df8539916c4170d2fdfe7c81433",
        "files": [
          "kernel/auditsc.c"
        ],
        "message": "audit: tame initialization warning len_abuf in audit_log_execve_info\n\nTame initialization warning of len_abuf in audit_log_execve_info even\nthough there isn't presently a bug introduced by commit 43761473c254\n(\"audit: fix a double fetch in audit_log_single_execve_arg()\").  Using\nUNINITIALIZED_VAR instead may mask future bugs.\n\nSigned-off-by: Richard Guy Briggs <rgb@redhat.com>\nSigned-off-by: Paul Moore <paul@paul-moore.com>",
        "before_after_code_files": [
          "kernel/auditsc.c||kernel/auditsc.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "kernel/auditsc.c||kernel/auditsc.c"
          ],
          "candidate": [
            "kernel/auditsc.c||kernel/auditsc.c"
          ]
        }
      },
      "candidate_diff": {
        "kernel/auditsc.c||kernel/auditsc.c": [
          "File: kernel/auditsc.c -> kernel/auditsc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1000:  long len_rem;",
          "1001:  long len_full;",
          "1002:  long len_buf;",
          "1004:  long len_tmp;",
          "1005:  bool require_data;",
          "1006:  bool encode;",
          "",
          "[Removed Lines]",
          "1003:  long len_abuf;",
          "",
          "[Added Lines]",
          "1003:  long len_abuf = 0;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "45820c294fe1b1a9df495d57f40585ef2d069a39",
      "candidate_info": {
        "commit_hash": "45820c294fe1b1a9df495d57f40585ef2d069a39",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/45820c294fe1b1a9df495d57f40585ef2d069a39",
        "files": [
          "kernel/auditsc.c"
        ],
        "message": "Fix broken audit tests for exec arg len\n\nThe \"fix\" in commit 0b08c5e5944 (\"audit: Fix check of return value of\nstrnlen_user()\") didn't fix anything, it broke things.  As reported by\nSteven Rostedt:\n\n \"Yes, strnlen_user() returns 0 on fault, but if you look at what len is\n  set to, than you would notice that on fault len would be -1\"\n\nbecause we just subtracted one from the return value.  So testing\nagainst 0 doesn't test for a fault condition, it tests against a\nperfectly valid empty string.\n\nAlso fix up the usual braindamage wrt using WARN_ON() inside a\nconditional - make it part of the conditional and remove the explicit\nunlikely() (which is already part of the WARN_ON*() logic, exactly so\nthat you don't have to write unreadable code.\n\nReported-and-tested-by: Steven Rostedt <rostedt@goodmis.org>\nCc: Jan Kara <jack@suse.cz>\nCc: Paul Moore <pmoore@redhat.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "kernel/auditsc.c||kernel/auditsc.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "kernel/auditsc.c||kernel/auditsc.c"
          ],
          "candidate": [
            "kernel/auditsc.c||kernel/auditsc.c"
          ]
        }
      },
      "candidate_diff": {
        "kernel/auditsc.c||kernel/auditsc.c": [
          "File: kernel/auditsc.c -> kernel/auditsc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1026:   send_sig(SIGKILL, current, 0);",
          "1027:   return -1;",
          "1028:  }",
          "",
          "[Removed Lines]",
          "1024:  if (unlikely((len == 0) || len > MAX_ARG_STRLEN - 1)) {",
          "1025:   WARN_ON(1);",
          "",
          "[Added Lines]",
          "1024:  if (WARN_ON_ONCE(len < 0 || len > MAX_ARG_STRLEN - 1)) {",
          "",
          "---------------"
        ]
      }
    }
  ]
}
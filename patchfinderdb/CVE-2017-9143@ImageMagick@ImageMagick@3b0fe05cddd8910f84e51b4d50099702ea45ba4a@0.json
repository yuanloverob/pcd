{
  "cve_id": "CVE-2017-9143",
  "cve_desc": "In ImageMagick 7.0.5-5, the ReadARTImage function in coders/art.c allows attackers to cause a denial of service (memory leak) via a crafted .art file.",
  "repo": "ImageMagick/ImageMagick",
  "patch_hash": "3b0fe05cddd8910f84e51b4d50099702ea45ba4a",
  "patch_info": {
    "commit_hash": "3b0fe05cddd8910f84e51b4d50099702ea45ba4a",
    "repo": "ImageMagick/ImageMagick",
    "commit_url": "https://github.com/ImageMagick/ImageMagick/commit/3b0fe05cddd8910f84e51b4d50099702ea45ba4a",
    "files": [
      "coders/art.c"
    ],
    "message": "Fixed memory leak reported in #456.",
    "before_after_code_files": [
      "coders/art.c||coders/art.c"
    ]
  },
  "patch_diff": {
    "coders/art.c||coders/art.c": [
      "File: coders/art.c -> coders/art.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "168:     q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);",
      "169:     if (q == (Quantum *) NULL)",
      "170:       break;",
      "172:       GetQuantumPixels(quantum_info),&count);",
      "173:     if (count != (ssize_t) length)",
      "174:       ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");",
      "",
      "[Removed Lines]",
      "171:     pixels=(const unsigned char *) ReadBlobStream(image,length,",
      "",
      "[Added Lines]",
      "171:     pixels=(const unsigned char *) ReadBlobStream(image,length,",
      "172:       GetQuantumPixels(quantum_info),&count);",
      "173:     if (count != (ssize_t) length)",
      "174:       {",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "505b59d7377b55931e317cecacd470e5bce3147a",
      "candidate_info": {
        "commit_hash": "505b59d7377b55931e317cecacd470e5bce3147a",
        "repo": "ImageMagick/ImageMagick",
        "commit_url": "https://github.com/ImageMagick/ImageMagick/commit/505b59d7377b55931e317cecacd470e5bce3147a",
        "files": [
          "coders/art.c"
        ],
        "message": "https://github.com/ImageMagick/ImageMagick/issues/1042",
        "before_after_code_files": [
          "coders/art.c||coders/art.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "coders/art.c||coders/art.c"
          ],
          "candidate": [
            "coders/art.c||coders/art.c"
          ]
        }
      },
      "candidate_diff": {
        "coders/art.c||coders/art.c": [
          "File: coders/art.c -> coders/art.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "168:     q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);",
          "169:     if (q == (Quantum *) NULL)",
          "170:       break;",
          "175:         quantum_info=DestroyQuantumInfo(quantum_info);",
          "176:         ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");",
          "177:       }",
          "",
          "[Removed Lines]",
          "171:     pixels=(const unsigned char *) ReadBlobStream(image,length,",
          "172:       GetQuantumPixels(quantum_info),&count);",
          "173:     if (count != (ssize_t) length)",
          "174:       {",
          "",
          "[Added Lines]",
          "171:     pixels=(const unsigned char *) ReadBlobStream(image,length,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "183:       break;",
          "184:     if (SetImageProgress(image,LoadImageTag,y,image->rows) == MagickFalse)",
          "185:       break;",
          "186:   }",
          "187:   SetQuantumImageType(image,GrayQuantum);",
          "188:   quantum_info=DestroyQuantumInfo(quantum_info);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "183:   }",
          "184:   SetQuantumImageType(image,GrayQuantum);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
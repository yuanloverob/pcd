{
  "cve_id": "CVE-2019-15226",
  "cve_desc": "Upon receiving each incoming request header data, Envoy will iterate over existing request headers to verify that the total size of the headers stays below a maximum limit. The implementation in versions 1.10.0 through 1.11.1 for HTTP/1.x traffic and all versions of Envoy for HTTP/2 traffic had O(n^2) performance characteristics. A remote attacker may craft a request that stays below the maximum request header size but consists of many thousands of small headers to consume CPU and result in a denial-of-service attack.",
  "repo": "envoyproxy/envoy",
  "patch_hash": "afc39bea36fd436e54262f150c009e8d72db5014",
  "patch_info": {
    "commit_hash": "afc39bea36fd436e54262f150c009e8d72db5014",
    "repo": "envoyproxy/envoy",
    "commit_url": "https://github.com/envoyproxy/envoy/commit/afc39bea36fd436e54262f150c009e8d72db5014",
    "files": [
      "docs/root/intro/version_history.rst",
      "include/envoy/access_log/access_log.h",
      "include/envoy/http/header_map.h",
      "source/common/http/conn_manager_impl.cc",
      "source/common/http/header_map_impl.cc",
      "source/common/http/header_map_impl.h",
      "source/common/http/http1/codec_impl.cc",
      "source/common/http/http2/codec_impl.cc",
      "source/common/router/router.cc",
      "source/extensions/access_loggers/common/access_log_base.h",
      "source/extensions/access_loggers/grpc/http_grpc_access_log_impl.cc",
      "source/extensions/filters/common/expr/context.cc",
      "source/extensions/filters/http/rbac/rbac_filter.cc",
      "test/common/http/conn_manager_impl_test.cc",
      "test/common/http/header_map_impl_speed_test.cc",
      "test/common/http/header_map_impl_test.cc",
      "test/common/http/http2/codec_impl_test.cc",
      "test/integration/http2_integration_test.cc",
      "test/integration/http_integration.cc",
      "test/integration/http_integration.h",
      "test/integration/protocol_integration_test.cc"
    ],
    "message": "Track byteSize of HeaderMap internally.\n\nIntroduces a cached byte size updated internally in HeaderMap. The value\nis stored as an optional, and is cleared whenever a non-const pointer or\nreference to a HeaderEntry is accessed. The cached value can be set with\nrefreshByteSize() which performs an iteration over the HeaderMap to sum\nthe size of each key and value in the HeaderMap.\n\nSigned-off-by: Asra Ali <asraa@google.com>",
    "before_after_code_files": [
      "include/envoy/access_log/access_log.h||include/envoy/access_log/access_log.h",
      "include/envoy/http/header_map.h||include/envoy/http/header_map.h",
      "source/common/http/conn_manager_impl.cc||source/common/http/conn_manager_impl.cc",
      "source/common/http/header_map_impl.cc||source/common/http/header_map_impl.cc",
      "source/common/http/header_map_impl.h||source/common/http/header_map_impl.h",
      "source/common/http/http1/codec_impl.cc||source/common/http/http1/codec_impl.cc",
      "source/common/http/http2/codec_impl.cc||source/common/http/http2/codec_impl.cc",
      "source/common/router/router.cc||source/common/router/router.cc",
      "source/extensions/access_loggers/common/access_log_base.h||source/extensions/access_loggers/common/access_log_base.h",
      "source/extensions/access_loggers/grpc/http_grpc_access_log_impl.cc||source/extensions/access_loggers/grpc/http_grpc_access_log_impl.cc",
      "source/extensions/filters/common/expr/context.cc||source/extensions/filters/common/expr/context.cc",
      "source/extensions/filters/http/rbac/rbac_filter.cc||source/extensions/filters/http/rbac/rbac_filter.cc",
      "test/common/http/conn_manager_impl_test.cc||test/common/http/conn_manager_impl_test.cc",
      "test/common/http/header_map_impl_speed_test.cc||test/common/http/header_map_impl_speed_test.cc",
      "test/common/http/header_map_impl_test.cc||test/common/http/header_map_impl_test.cc",
      "test/common/http/http2/codec_impl_test.cc||test/common/http/http2/codec_impl_test.cc",
      "test/integration/http2_integration_test.cc||test/integration/http2_integration_test.cc",
      "test/integration/http_integration.cc||test/integration/http_integration.cc",
      "test/integration/http_integration.h||test/integration/http_integration.h",
      "test/integration/protocol_integration_test.cc||test/integration/protocol_integration_test.cc"
    ]
  },
  "patch_diff": {
    "include/envoy/access_log/access_log.h||include/envoy/access_log/access_log.h": [
      "File: include/envoy/access_log/access_log.h -> include/envoy/access_log/access_log.h"
    ],
    "include/envoy/http/header_map.h||include/envoy/http/header_map.h": [
      "File: include/envoy/http/header_map.h -> include/envoy/http/header_map.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "457:   virtual void setReferenceKey(const LowerCaseString& key, const std::string& value) PURE;",
      "",
      "[Removed Lines]",
      "462:   virtual uint64_t byteSize() const PURE;",
      "",
      "[Added Lines]",
      "473:   virtual absl::optional<uint64_t> byteSize() const PURE;",
      "484:   virtual uint64_t refreshByteSize() PURE;",
      "494:   virtual uint64_t byteSizeInternal() const PURE;",
      "",
      "---------------"
    ],
    "source/common/http/conn_manager_impl.cc||source/common/http/conn_manager_impl.cc": [
      "File: source/common/http/conn_manager_impl.cc -> source/common/http/conn_manager_impl.cc",
      "--- Hunk 1 ---",
      "[Context before]",
      "506:   }",
      "508:   connection_manager_.stats_.named_.downstream_rq_active_.dec();",
      "509:   for (const AccessLog::InstanceSharedPtr& access_log : connection_manager_.config_.accessLogs()) {",
      "510:     access_log->log(request_headers_.get(), response_headers_.get(), response_trailers_.get(),",
      "511:                     stream_info_);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "512:   if (request_headers_ != nullptr) {",
      "513:     request_headers_->refreshByteSize();",
      "514:   }",
      "515:   if (response_headers_ != nullptr) {",
      "516:     response_headers_->refreshByteSize();",
      "517:   }",
      "518:   if (response_trailers_ != nullptr) {",
      "519:     response_trailers_->refreshByteSize();",
      "520:   }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "719:     }",
      "720:   }",
      "",
      "[Removed Lines]",
      "722:   ASSERT(connection_manager_.config_.maxRequestHeadersKb() > 0);",
      "723:   if (request_headers_->byteSize() > (connection_manager_.config_.maxRequestHeadersKb() * 1024)) {",
      "724:     sendLocalReply(Grpc::Common::hasGrpcContentType(*request_headers_),",
      "725:                    Code::RequestHeaderFieldsTooLarge, \"\", nullptr, is_head_request_, absl::nullopt,",
      "726:                    StreamInfo::ResponseCodeDetails::get().RequestHeadersTooLarge);",
      "727:     return;",
      "728:   }",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "source/common/http/header_map_impl.cc||source/common/http/header_map_impl.cc": [
      "File: source/common/http/header_map_impl.cc -> source/common/http/header_map_impl.cc",
      "--- Hunk 1 ---",
      "[Context before]",
      "295:   }",
      "296: };",
      "299:   if (data.empty()) {",
      "301:   }",
      "302:   if (!header.empty()) {",
      "303:     header.append(\",\", 1);",
      "304:   }",
      "305:   header.append(data.data(), data.size());",
      "306: }",
      "308: HeaderMapImpl::HeaderMapImpl() { memset(&inline_headers_, 0, sizeof(inline_headers_)); }",
      "",
      "[Removed Lines]",
      "298: void HeaderMapImpl::appendToHeader(HeaderString& header, absl::string_view data) {",
      "300:     return;",
      "",
      "[Added Lines]",
      "298: uint64_t HeaderMapImpl::appendToHeader(HeaderString& header, absl::string_view data) {",
      "300:     return 0;",
      "302:   uint64_t byte_size = 0;",
      "305:     byte_size += 1;",
      "308:   return data.size() + byte_size;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "319:   }",
      "320: }",
      "322: void HeaderMapImpl::copyFrom(const HeaderMap& header_map) {",
      "323:   header_map.iterate(",
      "324:       [](const HeaderEntry& header, void* context) -> HeaderMap::Iterate {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "325: void HeaderMapImpl::addSize(uint64_t size) {",
      "327:   if (cached_byte_size_.has_value()) {",
      "328:     cached_byte_size_.value() += size;",
      "329:   }",
      "330: }",
      "332: void HeaderMapImpl::subtractSize(uint64_t size) {",
      "333:   if (cached_byte_size_.has_value()) {",
      "334:     ASSERT(cached_byte_size_ >= size);",
      "335:     cached_byte_size_.value() -= size;",
      "336:   }",
      "337: }",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "359:     if (*ref_lookup_response.entry_ == nullptr) {",
      "360:       maybeCreateInline(ref_lookup_response.entry_, *ref_lookup_response.key_, std::move(value));",
      "361:     } else {",
      "363:       value.clear();",
      "364:     }",
      "365:   } else {",
      "366:     std::list<HeaderEntryImpl>::iterator i = headers_.insert(std::move(key), std::move(value));",
      "367:     i->entry_ = i;",
      "368:   }",
      "",
      "[Removed Lines]",
      "362:       appendToHeader((*ref_lookup_response.entry_)->value(), value.getStringView());",
      "",
      "[Added Lines]",
      "379:       const uint64_t added_size =",
      "380:           appendToHeader((*ref_lookup_response.entry_)->value(), value.getStringView());",
      "381:       addSize(added_size);",
      "385:     addSize(key.size() + value.size());",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "374:   auto* entry = getExistingInline(key.getStringView());",
      "375:   if (entry != nullptr) {",
      "377:     key.clear();",
      "378:     value.clear();",
      "379:   } else {",
      "",
      "[Removed Lines]",
      "376:     appendToHeader(entry->value(), value.getStringView());",
      "",
      "[Added Lines]",
      "396:     const uint64_t added_size = appendToHeader(entry->value(), value.getStringView());",
      "397:     addSize(added_size);",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "408:   if (entry != nullptr) {",
      "409:     char buf[32];",
      "410:     StringUtil::itoa(buf, sizeof(buf), value);",
      "412:     return;",
      "413:   }",
      "414:   HeaderString new_key;",
      "",
      "[Removed Lines]",
      "411:     appendToHeader(entry->value(), buf);",
      "",
      "[Added Lines]",
      "432:     const uint64_t added_size = appendToHeader(entry->value(), buf);",
      "433:     addSize(added_size);",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "423: void HeaderMapImpl::addCopy(const LowerCaseString& key, const std::string& value) {",
      "424:   auto* entry = getExistingInline(key.get());",
      "425:   if (entry != nullptr) {",
      "427:     return;",
      "428:   }",
      "429:   HeaderString new_key;",
      "",
      "[Removed Lines]",
      "426:     appendToHeader(entry->value(), value);",
      "",
      "[Added Lines]",
      "448:     const uint64_t added_size = appendToHeader(entry->value(), value);",
      "449:     addSize(added_size);",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "451:   ASSERT(new_value.empty()); // NOLINT(bugprone-use-after-move)",
      "452: }",
      "455:   uint64_t byte_size = 0;",
      "456:   for (const HeaderEntryImpl& header : headers_) {",
      "457:     byte_size += header.key().size();",
      "458:     byte_size += header.value().size();",
      "459:   }",
      "461:   return byte_size;",
      "462: }",
      "",
      "[Removed Lines]",
      "454: uint64_t HeaderMapImpl::byteSize() const {",
      "",
      "[Added Lines]",
      "477: absl::optional<uint64_t> HeaderMapImpl::byteSize() const { return cached_byte_size_; }",
      "479: uint64_t HeaderMapImpl::refreshByteSize() {",
      "480:   if (!cached_byte_size_.has_value()) {",
      "483:     cached_byte_size_ = byteSizeInternal();",
      "484:   }",
      "485:   return cached_byte_size_.value();",
      "486: }",
      "488: uint64_t HeaderMapImpl::byteSizeInternal() const {",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "474: HeaderEntry* HeaderMapImpl::get(const LowerCaseString& key) {",
      "475:   for (HeaderEntryImpl& header : headers_) {",
      "476:     if (header.key() == key.get().c_str()) {",
      "477:       return &header;",
      "478:     }",
      "479:   }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "511:       cached_byte_size_.reset();",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "528:   } else {",
      "529:     for (auto i = headers_.begin(); i != headers_.end();) {",
      "530:       if (i->key() == key.get().c_str()) {",
      "531:         i = headers_.erase(i);",
      "532:       } else {",
      "533:         ++i;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "566:         subtractSize(i->key().size() + i->value().size());",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "537: }",
      "539: void HeaderMapImpl::removePrefix(const LowerCaseString& prefix) {",
      "541:     bool to_remove = absl::StartsWith(entry.key().getStringView(), prefix.get());",
      "542:     if (to_remove) {",
      "",
      "[Removed Lines]",
      "540:   headers_.remove_if([&](const HeaderEntryImpl& entry) {",
      "",
      "[Added Lines]",
      "576:   headers_.remove_if([&prefix, this](const HeaderEntryImpl& entry) {",
      "",
      "---------------",
      "--- Hunk 11 ---",
      "[Context before]",
      "546:       if (cb) {",
      "547:         StaticLookupResponse ref_lookup_response = cb(*this);",
      "548:         if (ref_lookup_response.entry_) {",
      "550:         }",
      "551:       }",
      "552:     }",
      "553:     return to_remove;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "585:           const uint32_t key_value_size = (*ref_lookup_response.entry_)->key().size() +",
      "586:                                           (*ref_lookup_response.entry_)->value().size();",
      "587:           subtractSize(key_value_size);",
      "590:       } else {",
      "591:         subtractSize(entry.key().size() + entry.value().size());",
      "",
      "---------------",
      "--- Hunk 12 ---",
      "[Context before]",
      "571: HeaderMapImpl::HeaderEntryImpl& HeaderMapImpl::maybeCreateInline(HeaderEntryImpl** entry,",
      "572:                                                                  const LowerCaseString& key) {",
      "573:   if (*entry) {",
      "574:     return **entry;",
      "575:   }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "614:   cached_byte_size_.reset();",
      "",
      "---------------",
      "--- Hunk 13 ---",
      "[Context before]",
      "588:     return **entry;",
      "589:   }",
      "591:   std::list<HeaderEntryImpl>::iterator i = headers_.insert(key, std::move(value));",
      "592:   i->entry_ = i;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "633:   addSize(key.get().size() + value.size());",
      "",
      "---------------",
      "--- Hunk 14 ---",
      "[Context before]",
      "609:   }",
      "611:   HeaderEntryImpl* entry = *ptr_to_entry;",
      "613:   headers_.erase(entry->entry_);",
      "614: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "655:   const uint64_t size_to_subtract = entry->entry_->key().size() + entry->entry_->value().size();",
      "656:   subtractSize(size_to_subtract);",
      "",
      "---------------"
    ],
    "source/common/http/header_map_impl.h||source/common/http/header_map_impl.h": [
      "File: source/common/http/header_map_impl.h -> source/common/http/header_map_impl.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "20: #define DEFINE_INLINE_HEADER_FUNCS(name)                                                           \\",
      "21: public:                                                                                            \\",
      "22:   const HeaderEntry* name() const override { return inline_headers_.name##_; }                     \\",
      "24:   HeaderEntry& insert##name() override {                                                           \\",
      "25:     return maybeCreateInline(&inline_headers_.name##_, Headers::get().name);                       \\",
      "26:   }                                                                                                \\",
      "27:   void remove##name() override { removeInline(&inline_headers_.name##_); }",
      "",
      "[Removed Lines]",
      "23:   HeaderEntry* name() override { return inline_headers_.name##_; }                                 \\",
      "",
      "[Added Lines]",
      "28:   HeaderEntry* name() override {                                                                   \\",
      "29:     cached_byte_size_.reset();                                                                     \\",
      "30:     return inline_headers_.name##_;                                                                \\",
      "31:   }                                                                                                \\",
      "33:     cached_byte_size_.reset();                                                                     \\",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "48:   HeaderMapImpl();",
      "49:   explicit HeaderMapImpl(",
      "",
      "[Removed Lines]",
      "46:   static void appendToHeader(HeaderString& header, absl::string_view data);",
      "",
      "[Added Lines]",
      "55:   static uint64_t appendToHeader(HeaderString& header, absl::string_view data);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "71:   void addCopy(const LowerCaseString& key, const std::string& value) override;",
      "72:   void setReference(const LowerCaseString& key, const std::string& value) override;",
      "73:   void setReferenceKey(const LowerCaseString& key, const std::string& value) override;",
      "75:   const HeaderEntry* get(const LowerCaseString& key) const override;",
      "76:   HeaderEntry* get(const LowerCaseString& key) override;",
      "77:   void iterate(ConstIterateCb cb, void* context) const override;",
      "",
      "[Removed Lines]",
      "74:   uint64_t byteSize() const override;",
      "",
      "[Added Lines]",
      "83:   absl::optional<uint64_t> byteSize() const override;",
      "84:   uint64_t refreshByteSize() override;",
      "85:   uint64_t byteSizeInternal() const override;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "195:   HeaderEntryImpl* getExistingInline(absl::string_view key);",
      "197:   void removeInline(HeaderEntryImpl** entry);",
      "199:   AllInlineHeaders inline_headers_;",
      "200:   HeaderList headers_;",
      "202:   ALL_INLINE_HEADERS(DEFINE_INLINE_HEADER_FUNCS)",
      "203: };",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "209:   void addSize(uint64_t size);",
      "210:   void subtractSize(uint64_t size);",
      "217:   absl::optional<uint64_t> cached_byte_size_ = 0;",
      "",
      "---------------"
    ],
    "source/common/http/http1/codec_impl.cc||source/common/http/http1/codec_impl.cc": [
      "File: source/common/http/http1/codec_impl.cc -> source/common/http/http1/codec_impl.cc",
      "--- Hunk 1 ---",
      "[Context before]",
      "460:   header_parsing_state_ = HeaderParsingState::Value;",
      "461:   current_header_value_.append(data, length);",
      "465:   if (total > (max_request_headers_kb_ * 1024)) {",
      "466:     error_code_ = Http::Code::RequestHeaderFieldsTooLarge;",
      "467:     sendProtocolError();",
      "",
      "[Removed Lines]",
      "463:   const uint32_t total =",
      "464:       current_header_field_.size() + current_header_value_.size() + current_header_map_->byteSize();",
      "",
      "[Added Lines]",
      "464:   ASSERT(current_header_map_->byteSize().has_value());",
      "465:   const uint32_t total = current_header_field_.size() + current_header_value_.size() +",
      "466:                          current_header_map_->byteSize().value();",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "472: int ConnectionImpl::onHeadersCompleteBase() {",
      "473:   ENVOY_CONN_LOG(trace, \"headers complete\", connection_);",
      "474:   completeLastHeader();",
      "475:   if (!(parser_.http_major == 1 && parser_.http_minor == 1)) {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "479:   ASSERT(current_header_map_->byteSize().has_value() &&",
      "480:          current_header_map_->byteSize() == current_header_map_->byteSizeInternal());",
      "",
      "---------------"
    ],
    "source/common/http/http2/codec_impl.cc||source/common/http/http2/codec_impl.cc": [
      "File: source/common/http/http2/codec_impl.cc -> source/common/http/http2/codec_impl.cc",
      "--- Hunk 1 ---",
      "[Context before]",
      "510:   switch (frame->hd.type) {",
      "511:   case NGHTTP2_HEADERS: {",
      "512:     stream->remote_end_stream_ = frame->hd.flags & NGHTTP2_FLAG_END_STREAM;",
      "513:     if (!stream->cookies_.empty()) {",
      "514:       HeaderString key(Headers::get().Cookie);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "514:     ASSERT(stream->headers_->byteSize().has_value() &&",
      "515:            stream->headers_->byteSize().value() == stream->headers_->byteSizeInternal());",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "620:   case NGHTTP2_HEADERS:",
      "621:   case NGHTTP2_DATA: {",
      "622:     StreamImpl* stream = getStream(frame->hd.stream_id);",
      "623:     stream->local_end_stream_sent_ = frame->hd.flags & NGHTTP2_FLAG_END_STREAM;",
      "624:     break;",
      "625:   }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "627:     if (stream->headers_) {",
      "630:       ASSERT(stream->headers_->byteSize().has_value() &&",
      "631:              stream->headers_->byteSize().value() == stream->headers_->byteSizeInternal());",
      "632:     }",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "808:     stats_.headers_cb_no_stream_.inc();",
      "809:     return 0;",
      "810:   }",
      "812:   stream->saveHeader(std::move(name), std::move(value));",
      "815:     stats_.header_overflow_.inc();",
      "816:     return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;",
      "",
      "[Removed Lines]",
      "813:   if (stream->headers_->byteSize() > max_request_headers_kb_ * 1024) {",
      "",
      "[Added Lines]",
      "823:   ASSERT(stream->headers_->byteSize().has_value());",
      "824:   if (stream->headers_->byteSize().value() > max_request_headers_kb_ * 1024) {",
      "",
      "---------------"
    ],
    "source/common/router/router.cc||source/common/router/router.cc": [
      "File: source/common/router/router.cc -> source/common/router/router.cc",
      "--- Hunk 1 ---",
      "[Context before]",
      "1399:   stream_info_.setUpstreamTiming(upstream_timing_);",
      "1400:   stream_info_.onRequestComplete();",
      "1401:   for (const auto& upstream_log : parent_.config_.upstream_logs_) {",
      "1402:     upstream_log->log(parent_.downstream_headers_, upstream_headers_.get(),",
      "1403:                       upstream_trailers_.get(), stream_info_);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1404:   if (upstream_headers_ != nullptr) {",
      "1405:     upstream_headers_->refreshByteSize();",
      "1406:   }",
      "1407:   if (upstream_trailers_ != nullptr) {",
      "1408:     upstream_trailers_->refreshByteSize();",
      "1409:   }",
      "",
      "---------------"
    ],
    "source/extensions/access_loggers/common/access_log_base.h||source/extensions/access_loggers/common/access_log_base.h": [
      "File: source/extensions/access_loggers/common/access_log_base.h -> source/extensions/access_loggers/common/access_log_base.h"
    ],
    "source/extensions/access_loggers/grpc/http_grpc_access_log_impl.cc||source/extensions/access_loggers/grpc/http_grpc_access_log_impl.cc": [
      "File: source/extensions/access_loggers/grpc/http_grpc_access_log_impl.cc -> source/extensions/access_loggers/grpc/http_grpc_access_log_impl.cc",
      "--- Hunk 1 ---",
      "[Context before]",
      "95:     request_properties->set_original_path(",
      "96:         std::string(request_headers.EnvoyOriginalPath()->value().getStringView()));",
      "97:   }",
      "99:   request_properties->set_request_body_bytes(stream_info.bytesReceived());",
      "100:   if (request_headers.Method() != nullptr) {",
      "101:     envoy::api::v2::core::RequestMethod method =",
      "",
      "[Removed Lines]",
      "98:   request_properties->set_request_headers_bytes(request_headers.byteSize());",
      "",
      "[Added Lines]",
      "98:   request_properties->set_request_headers_bytes(request_headers.byteSize().value());",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "123:   if (stream_info.responseCodeDetails()) {",
      "124:     response_properties->set_response_code_details(stream_info.responseCodeDetails().value());",
      "125:   }",
      "127:   response_properties->set_response_body_bytes(stream_info.bytesSent());",
      "128:   if (!response_headers_to_log_.empty()) {",
      "129:     auto* logged_headers = response_properties->mutable_response_headers();",
      "",
      "[Removed Lines]",
      "126:   response_properties->set_response_headers_bytes(response_headers.byteSize());",
      "",
      "[Added Lines]",
      "126:   response_properties->set_response_headers_bytes(response_headers.byteSize().value());",
      "",
      "---------------"
    ],
    "source/extensions/filters/common/expr/context.cc||source/extensions/filters/common/expr/context.cc": [
      "File: source/extensions/filters/common/expr/context.cc -> source/extensions/filters/common/expr/context.cc",
      "--- Hunk 1 ---",
      "[Context before]",
      "79:     } else if (value == UserAgent) {",
      "80:       return convertHeaderEntry(headers_.value_->UserAgent());",
      "81:     } else if (value == TotalSize) {",
      "83:     }",
      "84:   }",
      "85:   return {};",
      "",
      "[Removed Lines]",
      "82:       return CelValue::CreateInt64(info_.bytesReceived() + headers_.value_->byteSize());",
      "",
      "[Added Lines]",
      "82:       return CelValue::CreateInt64(info_.bytesReceived() + headers_.value_->byteSize().value());",
      "",
      "---------------"
    ],
    "source/extensions/filters/http/rbac/rbac_filter.cc||source/extensions/filters/http/rbac/rbac_filter.cc": [
      "File: source/extensions/filters/http/rbac/rbac_filter.cc -> source/extensions/filters/http/rbac/rbac_filter.cc",
      "--- Hunk 1 ---",
      "[Context before]",
      "76:   if (shadow_engine != nullptr) {",
      "77:     std::string shadow_resp_code =",
      "78:         Filters::Common::RBAC::DynamicMetadataKeysSingleton::get().EngineResultAllowed;",
      "79:     if (shadow_engine->allowed(*callbacks_->connection(), headers, callbacks_->streamInfo(),",
      "80:                                &effective_policy_id)) {",
      "81:       ENVOY_LOG(debug, \"shadow allowed\");",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "82:     headers.refreshByteSize();",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "105:   const auto engine =",
      "106:       config_->engine(callbacks_->route(), Filters::Common::RBAC::EnforcementMode::Enforced);",
      "107:   if (engine != nullptr) {",
      "108:     if (engine->allowed(*callbacks_->connection(), headers, callbacks_->streamInfo(), nullptr)) {",
      "109:       ENVOY_LOG(debug, \"enforced allowed\");",
      "110:       config_->stats().allowed_.inc();",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "115:     headers.refreshByteSize();",
      "",
      "---------------"
    ],
    "test/common/http/conn_manager_impl_test.cc||test/common/http/conn_manager_impl_test.cc": [
      "File: test/common/http/conn_manager_impl_test.cc -> test/common/http/conn_manager_impl_test.cc",
      "--- Hunk 1 ---",
      "[Context before]",
      "4409:   EXPECT_EQ(1U, stats_.named_.downstream_cx_overload_disable_keepalive_.value());",
      "4410: }",
      "4457: TEST_F(HttpConnectionManagerImplTest, TestStopAllIterationAndBufferOnDecodingPathFirstFilter) {",
      "4458:   setup(false, \"envoy-custom-server\", false);",
      "4459:   setUpEncoderAndDecoder(true, true);",
      "",
      "[Removed Lines]",
      "4412: TEST_F(HttpConnectionManagerImplTest, OverlyLongHeadersRejected) {",
      "4413:   setup(false, \"\");",
      "4415:   std::string response_code;",
      "4416:   std::string response_body;",
      "4417:   EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {",
      "4418:     StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);",
      "4419:     HeaderMapPtr headers{",
      "4420:         new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};",
      "4421:     headers->addCopy(LowerCaseString(\"Foo\"), std::string(60 * 1024, 'a'));",
      "4423:     EXPECT_CALL(response_encoder_, encodeHeaders(_, true))",
      "4424:         .WillOnce(Invoke([&response_code](const HeaderMap& headers, bool) -> void {",
      "4425:           response_code = std::string(headers.Status()->value().getStringView());",
      "4426:         }));",
      "4427:     decoder->decodeHeaders(std::move(headers), true);",
      "4428:     conn_manager_->newStream(response_encoder_);",
      "4429:   }));",
      "4431:   Buffer::OwnedImpl fake_input(\"1234\");",
      "4432:   conn_manager_->onData(fake_input, false); // kick off request",
      "4434:   EXPECT_EQ(\"431\", response_code);",
      "4435:   EXPECT_EQ(\"\", response_body);",
      "4436: }",
      "4438: TEST_F(HttpConnectionManagerImplTest, OverlyLongHeadersAcceptedIfConfigured) {",
      "4439:   max_request_headers_kb_ = 62;",
      "4440:   setup(false, \"\");",
      "4442:   EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {",
      "4443:     StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);",
      "4444:     HeaderMapPtr headers{",
      "4445:         new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};",
      "4446:     headers->addCopy(LowerCaseString(\"Foo\"), std::string(60 * 1024, 'a'));",
      "4448:     EXPECT_CALL(response_encoder_, encodeHeaders(_, _)).Times(0);",
      "4449:     decoder->decodeHeaders(std::move(headers), true);",
      "4450:     conn_manager_->newStream(response_encoder_);",
      "4451:   }));",
      "4453:   Buffer::OwnedImpl fake_input(\"1234\");",
      "4454:   conn_manager_->onData(fake_input, false); // kick off request",
      "4455: }",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "test/common/http/header_map_impl_speed_test.cc||test/common/http/header_map_impl_speed_test.cc": [
      "File: test/common/http/header_map_impl_speed_test.cc -> test/common/http/header_map_impl_speed_test.cc",
      "--- Hunk 1 ---",
      "[Context before]",
      "104:   addDummyHeaders(headers, state.range(0));",
      "105:   uint64_t size = 0;",
      "106:   for (auto _ : state) {",
      "108:   }",
      "109:   benchmark::DoNotOptimize(size);",
      "110: }",
      "",
      "[Removed Lines]",
      "107:     size += headers.byteSize();",
      "",
      "[Added Lines]",
      "107:     size += headers.byteSize().value();",
      "",
      "---------------"
    ],
    "test/common/http/header_map_impl_test.cc||test/common/http/header_map_impl_test.cc": [
      "File: test/common/http/header_map_impl_test.cc -> test/common/http/header_map_impl_test.cc",
      "--- Hunk 1 ---",
      "[Context before]",
      "366:   HeaderMapImpl headers;",
      "367:   EXPECT_TRUE(headers.empty());",
      "368:   EXPECT_EQ(0, headers.size());",
      "369:   EXPECT_EQ(nullptr, headers.Host());",
      "370:   headers.insertHost().value(std::string(\"hello\"));",
      "371:   EXPECT_FALSE(headers.empty());",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "369:   EXPECT_EQ(headers.byteSize().value(), 0);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "375:   EXPECT_EQ(\"hello\", headers.get(Headers::get().Host)->value().getStringView());",
      "376: }",
      "378: TEST(HeaderMapImplTest, MoveIntoInline) {",
      "379:   HeaderMapImpl headers;",
      "380:   HeaderString key;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "380: uint64_t countBytesForTest(const HeaderMapImpl& headers) {",
      "381:   uint64_t byte_size = 0;",
      "382:   headers.iterate(",
      "383:       [](const Http::HeaderEntry& header, void* context) -> Http::HeaderMap::Iterate {",
      "384:         auto* byte_size = static_cast<uint64_t*>(context);",
      "386:         return Http::HeaderMap::Iterate::Continue;",
      "387:       },",
      "388:       &byte_size);",
      "389:   return byte_size;",
      "390: }",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "392:   headers.addViaMove(std::move(key2), std::move(value2));",
      "393:   EXPECT_EQ(\"cache-control\", headers.CacheControl()->key().getStringView());",
      "394:   EXPECT_EQ(\"hello,there\", headers.CacheControl()->value().getStringView());",
      "395: }",
      "397: TEST(HeaderMapImplTest, Remove) {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "409:   EXPECT_EQ(headers.refreshByteSize(), countBytesForTest(headers));",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "401:   LowerCaseString static_key(\"hello\");",
      "402:   std::string ref_value(\"value\");",
      "403:   headers.addReference(static_key, ref_value);",
      "404:   EXPECT_EQ(\"value\", headers.get(static_key)->value().getStringView());",
      "405:   EXPECT_EQ(HeaderString::Type::Reference, headers.get(static_key)->value().type());",
      "406:   EXPECT_EQ(1UL, headers.size());",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "419:   EXPECT_EQ(headers.byteSize().value(), countBytesForTest(headers));",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "409:   EXPECT_EQ(nullptr, headers.get(static_key));",
      "410:   EXPECT_EQ(0UL, headers.size());",
      "411:   EXPECT_TRUE(headers.empty());",
      "414:   headers.insertContentLength().value(5);",
      "415:   EXPECT_EQ(\"5\", headers.ContentLength()->value().getStringView());",
      "416:   EXPECT_EQ(1UL, headers.size());",
      "417:   EXPECT_FALSE(headers.empty());",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "428:   EXPECT_EQ(headers.refreshByteSize(), 0);",
      "432:   EXPECT_EQ(headers.refreshByteSize(), countBytesForTest(headers));",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "419:   EXPECT_EQ(nullptr, headers.ContentLength());",
      "420:   EXPECT_EQ(0UL, headers.size());",
      "421:   EXPECT_TRUE(headers.empty());",
      "424:   headers.insertContentLength().value(5);",
      "425:   EXPECT_EQ(\"5\", headers.ContentLength()->value().getStringView());",
      "426:   EXPECT_EQ(1UL, headers.size());",
      "427:   EXPECT_FALSE(headers.empty());",
      "428:   headers.remove(Headers::get().ContentLength);",
      "429:   EXPECT_EQ(nullptr, headers.ContentLength());",
      "430:   EXPECT_EQ(0UL, headers.size());",
      "431:   EXPECT_TRUE(headers.empty());",
      "432: }",
      "434: TEST(HeaderMapImplTest, RemoveRegex) {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "440:   EXPECT_EQ(headers.refreshByteSize(), countBytesForTest(headers));",
      "447:   EXPECT_EQ(headers.refreshByteSize(), countBytesForTest(headers));",
      "452:   EXPECT_EQ(headers.refreshByteSize(), 0);",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "446:   headers.addReference(key3, \"value\");",
      "447:   headers.addReference(key4, \"value\");",
      "448:   headers.addReference(key5, \"value\");",
      "451:   headers.removePrefix(LowerCaseString(\"x-prefix-\"));",
      "452:   EXPECT_EQ(nullptr, headers.get(key1));",
      "453:   EXPECT_NE(nullptr, headers.get(key2));",
      "454:   EXPECT_EQ(nullptr, headers.get(key3));",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "470:   EXPECT_EQ(headers.byteSize().value(), countBytesForTest(headers));",
      "474:   EXPECT_EQ(headers.byteSize().value(), countBytesForTest(headers));",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "456:   EXPECT_EQ(nullptr, headers.get(key5));",
      "459:   headers.removePrefix(LowerCaseString(\"\"));",
      "460:   EXPECT_EQ(nullptr, headers.get(key2));",
      "461:   EXPECT_EQ(nullptr, headers.get(key4));",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "482:   headers.refreshByteSize();",
      "484:   EXPECT_EQ(headers.byteSize().value(), 0);",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "465:   EXPECT_EQ(\"5\", headers.ContentLength()->value().getStringView());",
      "466:   EXPECT_EQ(1UL, headers.size());",
      "467:   EXPECT_FALSE(headers.empty());",
      "468:   headers.removePrefix(LowerCaseString(\"content\"));",
      "469:   EXPECT_EQ(nullptr, headers.ContentLength());",
      "470: }",
      "472: TEST(HeaderMapImplTest, SetRemovesAllValues) {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "493:   EXPECT_EQ(headers.refreshByteSize(), countBytesForTest(headers));",
      "496:   EXPECT_EQ(headers.refreshByteSize(), 0);",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "484:   headers.addReference(key2, ref_value2);",
      "485:   headers.addReference(key1, ref_value3);",
      "486:   headers.addReference(key1, ref_value4);",
      "488:   using MockCb = testing::MockFunction<void(const std::string&, const std::string&)>;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "514:   EXPECT_EQ(headers.byteSize().value(), countBytesForTest(headers));",
      "",
      "---------------",
      "--- Hunk 11 ---",
      "[Context before]",
      "531:     const std::string bar(\"bar\");",
      "532:     headers.addReference(Headers::get().ContentLength, foo);",
      "533:     headers.addReference(Headers::get().ContentLength, bar);",
      "534:     EXPECT_EQ(\"foo,bar\", headers.ContentLength()->value().getStringView());",
      "535:     EXPECT_EQ(1UL, headers.size());",
      "536:   }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "562:     EXPECT_EQ(headers.byteSize().value(), countBytesForTest(headers));",
      "",
      "---------------",
      "--- Hunk 12 ---",
      "[Context before]",
      "538:     HeaderMapImpl headers;",
      "539:     headers.addReferenceKey(Headers::get().ContentLength, \"foo\");",
      "540:     headers.addReferenceKey(Headers::get().ContentLength, \"bar\");",
      "541:     EXPECT_EQ(\"foo,bar\", headers.ContentLength()->value().getStringView());",
      "542:     EXPECT_EQ(1UL, headers.size());",
      "543:   }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "570:     EXPECT_EQ(headers.byteSize().value(), countBytesForTest(headers));",
      "",
      "---------------",
      "--- Hunk 13 ---",
      "[Context before]",
      "545:     HeaderMapImpl headers;",
      "546:     headers.addReferenceKey(Headers::get().ContentLength, 5);",
      "547:     headers.addReferenceKey(Headers::get().ContentLength, 6);",
      "548:     EXPECT_EQ(\"5,6\", headers.ContentLength()->value().getStringView());",
      "549:     EXPECT_EQ(1UL, headers.size());",
      "550:   }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "578:     EXPECT_EQ(headers.byteSize().value(), countBytesForTest(headers));",
      "",
      "---------------",
      "--- Hunk 14 ---",
      "[Context before]",
      "553:     const std::string foo(\"foo\");",
      "554:     headers.addReference(Headers::get().ContentLength, foo);",
      "555:     headers.addReferenceKey(Headers::get().ContentLength, 6);",
      "556:     EXPECT_EQ(\"foo,6\", headers.ContentLength()->value().getStringView());",
      "557:     EXPECT_EQ(1UL, headers.size());",
      "558:   }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "587:     EXPECT_EQ(headers.byteSize().value(), countBytesForTest(headers));",
      "",
      "---------------",
      "--- Hunk 15 ---",
      "[Context before]",
      "568:   headers.addReference(set_cookie, foo);",
      "569:   headers.addReference(set_cookie, bar);",
      "570:   EXPECT_EQ(2UL, headers.size());",
      "572:   std::vector<absl::string_view> out;",
      "573:   Http::HeaderUtility::getAllOfHeader(headers, \"set-cookie\", out);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "603:   EXPECT_EQ(headers.byteSize().value(), countBytesForTest(headers));",
      "",
      "---------------",
      "--- Hunk 16 ---",
      "[Context before]",
      "580:   HeaderMapImpl headers;",
      "581:   headers.setReferenceKey(Headers::get().ContentType, \"blah\");",
      "582:   headers.setReferenceKey(Headers::get().ContentType, \"text/html\");",
      "583:   EXPECT_EQ(\"text/html\", headers.ContentType()->value().getStringView());",
      "584:   EXPECT_EQ(1UL, headers.size());",
      "585: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "616:   EXPECT_EQ(headers.byteSize().value(), countBytesForTest(headers));",
      "",
      "---------------",
      "--- Hunk 17 ---",
      "[Context before]",
      "588:   HeaderMapImpl headers;",
      "589:   LowerCaseString foo(\"hello\");",
      "590:   headers.addReferenceKey(foo, \"world\");",
      "591:   EXPECT_NE(\"world\", headers.get(foo)->value().getStringView().data());",
      "592:   EXPECT_EQ(\"world\", headers.get(foo)->value().getStringView());",
      "593: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "625:   EXPECT_EQ(headers.byteSize().value(), countBytesForTest(headers));",
      "",
      "---------------",
      "--- Hunk 18 ---",
      "[Context before]",
      "596:   HeaderMapImpl headers;",
      "597:   LowerCaseString foo(\"hello\");",
      "598:   headers.setReferenceKey(foo, \"world\");",
      "599:   EXPECT_NE(\"world\", headers.get(foo)->value().getStringView().data());",
      "600:   EXPECT_EQ(\"world\", headers.get(foo)->value().getStringView());",
      "602:   headers.setReferenceKey(foo, \"monde\");",
      "603:   EXPECT_NE(\"monde\", headers.get(foo)->value().getStringView().data());",
      "604:   EXPECT_EQ(\"monde\", headers.get(foo)->value().getStringView());",
      "605: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "634:   EXPECT_EQ(headers.byteSize().value(), countBytesForTest(headers));",
      "637:   headers.refreshByteSize();",
      "640:   EXPECT_EQ(headers.byteSize().value(), countBytesForTest(headers));",
      "",
      "---------------",
      "--- Hunk 19 ---",
      "[Context before]",
      "611:   std::unique_ptr<LowerCaseString> lcKeyPtr(new LowerCaseString(\"hello\"));",
      "612:   headers.addCopy(*lcKeyPtr, \"world\");",
      "614:   const HeaderString& value = headers.get(*lcKeyPtr)->value();",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "651:   EXPECT_EQ(headers.byteSize().value(), countBytesForTest(headers));",
      "",
      "---------------",
      "--- Hunk 20 ---",
      "[Context before]",
      "632:   headers.remove(LowerCaseString(\"hello\"));",
      "636:   lcKeyPtr = std::make_unique<LowerCaseString>(std::string(\"he\") + \"llo\");",
      "637:   EXPECT_STREQ(\"hello\", lcKeyPtr->get().c_str());",
      "639:   headers.addCopy(*lcKeyPtr, 42);",
      "641:   const HeaderString& value3 = headers.get(*lcKeyPtr)->value();",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "672:   headers.refreshByteSize();",
      "674:   EXPECT_EQ(headers.byteSize().value(), 0);",
      "681:   headers.refreshByteSize();",
      "683:   EXPECT_EQ(headers.byteSize().value(), countBytesForTest(headers));",
      "",
      "---------------",
      "--- Hunk 21 ---",
      "[Context before]",
      "662:   headers.addCopy(cache_control, \"max-age=1345\");",
      "663:   EXPECT_EQ(\"max-age=1345\", headers.get(cache_control)->value().getStringView());",
      "664:   EXPECT_EQ(\"max-age=1345\", headers.CacheControl()->value().getStringView());",
      "665:   headers.addCopy(cache_control, \"public\");",
      "666:   EXPECT_EQ(\"max-age=1345,public\", headers.get(cache_control)->value().getStringView());",
      "667:   headers.addCopy(cache_control, \"\");",
      "668:   EXPECT_EQ(\"max-age=1345,public\", headers.get(cache_control)->value().getStringView());",
      "669:   headers.addCopy(cache_control, 123);",
      "670:   EXPECT_EQ(\"max-age=1345,public,123\", headers.get(cache_control)->value().getStringView());",
      "671:   headers.addCopy(cache_control, std::numeric_limits<uint64_t>::max());",
      "672:   EXPECT_EQ(\"max-age=1345,public,123,18446744073709551615\",",
      "673:             headers.get(cache_control)->value().getStringView());",
      "674: }",
      "676: TEST(HeaderMapImplTest, Equality) {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "709:   EXPECT_EQ(headers.refreshByteSize(), countBytesForTest(headers));",
      "711:   EXPECT_EQ(headers.refreshByteSize(), countBytesForTest(headers));",
      "714:   EXPECT_EQ(headers.refreshByteSize(), countBytesForTest(headers));",
      "717:   EXPECT_EQ(headers.refreshByteSize(), countBytesForTest(headers));",
      "722:   EXPECT_EQ(headers.refreshByteSize(), countBytesForTest(headers));",
      "",
      "---------------",
      "--- Hunk 22 ---",
      "[Context before]",
      "690:   LowerCaseString static_key(\"\\x90hello\");",
      "691:   std::string ref_value(\"value\");",
      "692:   headers.addReference(static_key, ref_value);",
      "693:   EXPECT_EQ(\"value\", headers.get(static_key)->value().getStringView());",
      "694: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "742:   EXPECT_EQ(headers.byteSize().value(), countBytesForTest(headers));",
      "",
      "---------------",
      "--- Hunk 23 ---",
      "[Context before]",
      "844:   {",
      "845:     LowerCaseString foo(\"hello\");",
      "846:     Http::TestHeaderMapImpl headers{};",
      "847:     EXPECT_EQ(0UL, headers.size());",
      "848:     EXPECT_TRUE(headers.empty());",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "897:     EXPECT_EQ(headers.refreshByteSize(), 0);",
      "",
      "---------------"
    ],
    "test/common/http/http2/codec_impl_test.cc||test/common/http/http2/codec_impl_test.cc": [
      "File: test/common/http/http2/codec_impl_test.cc -> test/common/http/http2/codec_impl_test.cc",
      "--- Hunk 1 ---",
      "[Context before]",
      "1090:   TestHeaderMapImpl request_headers;",
      "1091:   HttpTestUtility::addDefaultHeaders(request_headers);",
      "1092:   std::string key = \"big\";",
      "1093:   uint32_t head_room = 77;",
      "1094:   uint32_t long_string_length =",
      "1096:   std::string long_string = std::string(long_string_length, 'q');",
      "1097:   request_headers.addCopy(key, long_string);",
      "1104:   EXPECT_CALL(request_decoder_, decodeHeaders_(_, _));",
      "1105:   request_encoder_->encodeHeaders(request_headers, true);",
      "",
      "[Removed Lines]",
      "1095:       codec_limit_kb * 1024 - request_headers.byteSize() - key.length() - head_room;",
      "1102:   ASSERT_EQ(request_headers.byteSize() + head_room, codec_limit_kb * 1024);",
      "",
      "[Added Lines]",
      "1093:   request_headers.refreshByteSize();",
      "1097:       codec_limit_kb * 1024 - request_headers.byteSize().value() - key.length() - head_room;",
      "1104:   ASSERT_EQ(request_headers.byteSize().value() + head_room, codec_limit_kb * 1024);",
      "",
      "---------------"
    ],
    "test/integration/http2_integration_test.cc||test/integration/http2_integration_test.cc": [
      "File: test/integration/http2_integration_test.cc -> test/integration/http2_integration_test.cc",
      "--- Hunk 1 ---",
      "[Context before]",
      "65: TEST_P(Http2IntegrationTest, RetryAttemptCount) { testRetryAttemptCountHeader(); }",
      "67: static std::string response_metadata_filter = R\"EOF(",
      "68: name: response-metadata-filter",
      "69: config: {}",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "67: TEST_P(Http2IntegrationTest, LargeRequestTrailersRejected) { testLargeRequestTrailers(66, 60); }",
      "",
      "---------------"
    ],
    "test/integration/http_integration.cc||test/integration/http_integration.cc": [
      "File: test/integration/http_integration.cc -> test/integration/http_integration.cc",
      "--- Hunk 1 ---",
      "[Context before]",
      "261: IntegrationStreamDecoderPtr HttpIntegrationTest::sendRequestAndWaitForResponse(",
      "262:     const Http::TestHeaderMapImpl& request_headers, uint32_t request_body_size,",
      "264:   ASSERT(codec_client_ != nullptr);",
      "266:   IntegrationStreamDecoderPtr response;",
      "",
      "[Removed Lines]",
      "263:     const Http::TestHeaderMapImpl& response_headers, uint32_t response_size, int upstream_index) {",
      "",
      "[Added Lines]",
      "263:     const Http::TestHeaderMapImpl& response_headers, uint32_t response_size, int upstream_index,",
      "264:     std::chrono::milliseconds time) {",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "269:   } else {",
      "270:     response = codec_client_->makeHeaderOnlyRequest(request_headers);",
      "271:   }",
      "274:   upstream_request_->encodeHeaders(response_headers, response_size == 0);",
      "",
      "[Removed Lines]",
      "272:   waitForNextUpstreamRequest(upstream_index);",
      "",
      "[Added Lines]",
      "273:   waitForNextUpstreamRequest(upstream_index, time);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "333: }",
      "335: uint64_t",
      "337:   uint64_t upstream_with_request;",
      "339:   if (!fake_upstream_connection_) {",
      "",
      "[Removed Lines]",
      "336: HttpIntegrationTest::waitForNextUpstreamRequest(const std::vector<uint64_t>& upstream_indices) {",
      "",
      "[Added Lines]",
      "337: HttpIntegrationTest::waitForNextUpstreamRequest(const std::vector<uint64_t>& upstream_indices,",
      "338:                                                 std::chrono::milliseconds connection_wait_timeout) {",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "361:   return upstream_with_request;",
      "362: }",
      "366: }",
      "368: void HttpIntegrationTest::checkSimpleRequestSuccess(uint64_t expected_request_size,",
      "",
      "[Removed Lines]",
      "364: void HttpIntegrationTest::waitForNextUpstreamRequest(uint64_t upstream_index) {",
      "365:   waitForNextUpstreamRequest(std::vector<uint64_t>({upstream_index}));",
      "",
      "[Added Lines]",
      "366: void HttpIntegrationTest::waitForNextUpstreamRequest(",
      "367:     uint64_t upstream_index, std::chrono::milliseconds connection_wait_timeout) {",
      "368:   waitForNextUpstreamRequest(std::vector<uint64_t>({upstream_index}), connection_wait_timeout);",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "916:   }",
      "917: }",
      "919: void HttpIntegrationTest::testDownstreamResetBeforeResponseComplete() {",
      "920:   initialize();",
      "921:   codec_client_ = makeHttpConnection(lookupPort(\"http\"));",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "922: void HttpIntegrationTest::testLargeRequestTrailers(uint32_t size, uint32_t max_size) {",
      "927:   config_helper_.addConfigModifier(",
      "928:       [&](envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager& hcm)",
      "929:           -> void { hcm.mutable_max_request_headers_kb()->set_value(max_size); });",
      "930:   max_request_headers_kb_ = max_size;",
      "931:   Http::TestHeaderMapImpl request_trailers{{\"trailer\", \"trailer\"}};",
      "932:   request_trailers.addCopy(\"big\", std::string(size * 1024, 'a'));",
      "934:   initialize();",
      "936:   codec_client_ = makeHttpConnection(lookupPort(\"http\"));",
      "937:   fake_upstreams_[0]->set_allow_unexpected_disconnects(true);",
      "939:   auto encoder_decoder = codec_client_->startRequest(default_request_headers_);",
      "940:   request_encoder_ = &encoder_decoder.first;",
      "941:   auto response = std::move(encoder_decoder.second);",
      "942:   codec_client_->sendData(*request_encoder_, 10, false);",
      "943:   codec_client_->sendTrailers(*request_encoder_, request_trailers);",
      "945:   if (size >= max_size && downstream_protocol_ == Http::CodecClient::Type::HTTP2) {",
      "948:     response->waitForReset();",
      "949:     codec_client_->close();",
      "950:     EXPECT_FALSE(response->complete());",
      "952:   } else {",
      "953:     waitForNextUpstreamRequest();",
      "954:     upstream_request_->encodeHeaders(default_response_headers_, true);",
      "955:     response->waitForEndStream();",
      "956:     EXPECT_TRUE(response->complete());",
      "957:   }",
      "958: }",
      "960: void HttpIntegrationTest::testManyRequestHeaders(std::chrono::milliseconds time) {",
      "961:   config_helper_.addConfigModifier(",
      "962:       [&](envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager& hcm)",
      "963:           -> void { hcm.mutable_max_request_headers_kb()->set_value(96); });",
      "964:   max_request_headers_kb_ = 96;",
      "966:   Http::TestHeaderMapImpl big_headers{",
      "967:       {\":method\", \"GET\"}, {\":path\", \"/test/long/url\"}, {\":scheme\", \"http\"}, {\":authority\", \"host\"}};",
      "969:   for (int i = 0; i < 20000; i++) {",
      "970:     big_headers.addCopy(std::to_string(i), std::string(0, 'a'));",
      "971:   }",
      "972:   initialize();",
      "974:   codec_client_ = makeHttpConnection(lookupPort(\"http\"));",
      "976:   auto response =",
      "977:       sendRequestAndWaitForResponse(big_headers, 0, default_response_headers_, 0, 0, time);",
      "979:   EXPECT_TRUE(response->complete());",
      "980:   EXPECT_EQ(\"200\", response->headers().Status()->value().getStringView());",
      "981: }",
      "",
      "---------------"
    ],
    "test/integration/http_integration.h||test/integration/http_integration.h": [
      "File: test/integration/http_integration.h -> test/integration/http_integration.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "139:   void cleanupUpstreamAndDownstream();",
      "",
      "[Removed Lines]",
      "125:   IntegrationStreamDecoderPtr",
      "126:   sendRequestAndWaitForResponse(const Http::TestHeaderMapImpl& request_headers,",
      "127:                                 uint32_t request_body_size,",
      "128:                                 const Http::TestHeaderMapImpl& response_headers,",
      "129:                                 uint32_t response_body_size, int upstream_index = 0);",
      "135:   uint64_t waitForNextUpstreamRequest(const std::vector<uint64_t>& upstream_indices);",
      "136:   void waitForNextUpstreamRequest(uint64_t upstream_index = 0);",
      "",
      "[Added Lines]",
      "125:   IntegrationStreamDecoderPtr sendRequestAndWaitForResponse(",
      "126:       const Http::TestHeaderMapImpl& request_headers, uint32_t request_body_size,",
      "127:       const Http::TestHeaderMapImpl& response_headers, uint32_t response_body_size,",
      "128:       int upstream_index = 0, std::chrono::milliseconds time = TestUtility::DefaultTimeout);",
      "134:   uint64_t waitForNextUpstreamRequest(",
      "135:       const std::vector<uint64_t>& upstream_indices,",
      "136:       std::chrono::milliseconds connection_wait_timeout = TestUtility::DefaultTimeout);",
      "137:   void waitForNextUpstreamRequest(",
      "138:       uint64_t upstream_index = 0,",
      "139:       std::chrono::milliseconds connection_wait_timeout = TestUtility::DefaultTimeout);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "185:   void testRouterUpstreamResponseBeforeRequestComplete();",
      "187:   void testTwoRequests(bool force_network_backup = false);",
      "188:   void testLargeRequestHeaders(uint32_t size, uint32_t max_size = 60);",
      "190:   void testAddEncodedTrailers();",
      "191:   void testRetry();",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "191:   void testLargeHeaders(Http::TestHeaderMapImpl request_headers,",
      "192:                         Http::TestHeaderMapImpl request_trailers, uint32_t size, uint32_t max_size);",
      "194:   void testLargeRequestTrailers(uint32_t size, uint32_t max_size = 60);",
      "195:   void testManyRequestHeaders(std::chrono::milliseconds time = TestUtility::DefaultTimeout);",
      "",
      "---------------"
    ],
    "test/integration/protocol_integration_test.cc||test/integration/protocol_integration_test.cc": [
      "File: test/integration/protocol_integration_test.cc -> test/integration/protocol_integration_test.cc",
      "--- Hunk 1 ---",
      "[Context before]",
      "576:   EXPECT_EQ(\"200\", response->headers().Status()->value().getStringView());",
      "577: }",
      "579: TEST_P(DownstreamProtocolIntegrationTest, InvalidContentLength) {",
      "580:   initialize();",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "580: TEST_P(DownstreamProtocolIntegrationTest, LargeCookieParsingConcatenated) {",
      "581:   initialize();",
      "583:   codec_client_ = makeHttpConnection(lookupPort(\"http\"));",
      "584:   Http::TestHeaderMapImpl request_headers{{\":method\", \"POST\"},",
      "585:                                           {\":path\", \"/test/long/url\"},",
      "586:                                           {\":scheme\", \"http\"},",
      "587:                                           {\":authority\", \"host\"},",
      "588:                                           {\"content-length\", \"0\"}};",
      "589:   std::vector<std::string> cookie_pieces;",
      "590:   for (int i = 0; i < 7000; i++) {",
      "591:     cookie_pieces.push_back(fmt::sprintf(\"a%x=b\", i));",
      "592:   }",
      "593:   request_headers.addCopy(\"cookie\", absl::StrJoin(cookie_pieces, \"; \"));",
      "594:   auto response = sendRequestAndWaitForResponse(request_headers, 0, default_response_headers_, 0);",
      "596:   ASSERT_TRUE(response->complete());",
      "597:   EXPECT_EQ(\"200\", response->headers().Status()->value().getStringView());",
      "598: }",
      "601: TEST_P(DownstreamProtocolIntegrationTest, LargeCookieParsingMany) {",
      "602:   initialize();",
      "604:   codec_client_ = makeHttpConnection(lookupPort(\"http\"));",
      "605:   Http::TestHeaderMapImpl request_headers{{\":method\", \"POST\"},",
      "606:                                           {\":path\", \"/test/long/url\"},",
      "607:                                           {\":scheme\", \"http\"},",
      "608:                                           {\":authority\", \"host\"},",
      "609:                                           {\"content-length\", \"0\"}};",
      "610:   for (int i = 0; i < 2000; i++) {",
      "611:     request_headers.addCopy(\"cookie\", fmt::sprintf(\"a%x=b\", i));",
      "612:   }",
      "613:   auto response = sendRequestAndWaitForResponse(request_headers, 0, default_response_headers_, 0);",
      "615:   ASSERT_TRUE(response->complete());",
      "616:   EXPECT_EQ(\"200\", response->headers().Status()->value().getStringView());",
      "617: }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "850:   testLargeRequestHeaders(95, 96);",
      "851: }",
      "855: TEST_P(DownstreamProtocolIntegrationTest, testDecodeHeadersReturnsStopAll) {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "893: TEST_P(DownstreamProtocolIntegrationTest, ManyRequestHeadersTimeout) {",
      "895:   testManyRequestHeaders(std::chrono::milliseconds(5000));",
      "896: }",
      "898: TEST_P(DownstreamProtocolIntegrationTest, LargeRequestTrailersAccepted) {",
      "899:   testLargeRequestTrailers(60, 96);",
      "900: }",
      "902: TEST_P(DownstreamProtocolIntegrationTest, LargeRequestTrailersRejected) {",
      "903:   testLargeRequestTrailers(66, 60);",
      "904: }",
      "906: TEST_P(DownstreamProtocolIntegrationTest, ManyTrailerHeaders) {",
      "907:   config_helper_.addConfigModifier(",
      "908:       [&](envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager& hcm)",
      "909:           -> void { hcm.mutable_max_request_headers_kb()->set_value(96); });",
      "911:   Http::TestHeaderMapImpl request_trailers{};",
      "912:   for (int i = 0; i < 20000; i++) {",
      "913:     request_trailers.addCopy(std::to_string(i), \"\");",
      "914:   }",
      "916:   initialize();",
      "917:   codec_client_ = makeHttpConnection(lookupPort(\"http\"));",
      "918:   auto encoder_decoder =",
      "919:       codec_client_->startRequest(Http::TestHeaderMapImpl{{\":method\", \"POST\"},",
      "920:                                                           {\":path\", \"/test/long/url\"},",
      "921:                                                           {\":scheme\", \"http\"},",
      "922:                                                           {\":authority\", \"host\"}});",
      "923:   request_encoder_ = &encoder_decoder.first;",
      "924:   auto response = std::move(encoder_decoder.second);",
      "925:   codec_client_->sendTrailers(*request_encoder_, request_trailers);",
      "926:   waitForNextUpstreamRequest();",
      "927:   upstream_request_->encodeHeaders(default_response_headers_, true);",
      "928:   response->waitForEndStream();",
      "930:   EXPECT_TRUE(upstream_request_->complete());",
      "931:   EXPECT_TRUE(response->complete());",
      "932:   EXPECT_EQ(\"200\", response->headers().Status()->value().getStringView());",
      "933: }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "0cb6bbf59d46ee60b938f9fb4c3eb51ed62ea41f",
      "candidate_info": {
        "commit_hash": "0cb6bbf59d46ee60b938f9fb4c3eb51ed62ea41f",
        "repo": "envoyproxy/envoy",
        "commit_url": "https://github.com/envoyproxy/envoy/commit/0cb6bbf59d46ee60b938f9fb4c3eb51ed62ea41f",
        "files": [
          "test/integration/http_integration.cc"
        ],
        "message": "test: optimize waitForNextUpstreamRequest() (#11026)\n\nCommit Message:\n//test/integration:protocol_integration_test\nAfter:\nStats over 50 runs: max = 11.8s, min = 1.2s, avg = 4.0s, dev = 4.3s\nBefore:\nStats over 50 runs: max = 2.6s, min = 1.4s, avg = 2.4s, dev = 0.3s\n\nSigned-off-by: Yuchen Dai silentdai@gmail.com\n\nAdditional Description:\nRisk Level: LOW\nTesting: test\nDocs Changes: n/a\nRelease Notes: n/a\n\nSigned-off-by: Yuchen Dai <silentdai@gmail.com>",
        "before_after_code_files": [
          "test/integration/http_integration.cc||test/integration/http_integration.cc"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "test/integration/http_integration.cc||test/integration/http_integration.cc"
          ],
          "candidate": [
            "test/integration/http_integration.cc||test/integration/http_integration.cc"
          ]
        }
      },
      "candidate_diff": {
        "test/integration/http_integration.cc||test/integration/http_integration.cc": [
          "File: test/integration/http_integration.cc -> test/integration/http_integration.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "357:   absl::optional<uint64_t> upstream_with_request;",
          "359:   if (!fake_upstream_connection_) {",
          "361:     AssertionResult result = AssertionFailure();",
          "366:       if (result) {",
          "367:         upstream_with_request = upstream_index;",
          "368:         break;",
          "369:       }",
          "370:     }",
          "371:     RELEASE_ASSERT(result, result.message());",
          "372:   }",
          "",
          "[Removed Lines]",
          "362:     for (auto upstream_index : upstream_indices) {",
          "363:       result = fake_upstreams_[upstream_index]->waitForHttpConnection(",
          "365:           max_request_headers_count_);",
          "",
          "[Added Lines]",
          "361:     int upstream_index = 0;",
          "362:     Event::TestTimeSystem& time_system = timeSystem();",
          "363:     auto end_time = time_system.monotonicTime() + connection_wait_timeout;",
          "365:     while (!result) {",
          "366:       upstream_index = upstream_index % upstream_indices.size();",
          "367:       result = fake_upstreams_[upstream_indices[upstream_index]]->waitForHttpConnection(",
          "369:           max_request_headers_kb_, max_request_headers_count_);",
          "373:       } else if (time_system.monotonicTime() >= end_time) {",
          "374:         result = (AssertionFailure() << \"Timed out waiting for new connection.\");",
          "375:         break;",
          "377:       ++upstream_index;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "c02fe0c6084830d0d9921dbba3be2d760fbb4fe4",
      "candidate_info": {
        "commit_hash": "c02fe0c6084830d0d9921dbba3be2d760fbb4fe4",
        "repo": "envoyproxy/envoy",
        "commit_url": "https://github.com/envoyproxy/envoy/commit/c02fe0c6084830d0d9921dbba3be2d760fbb4fe4",
        "files": [
          "test/integration/http_integration.cc"
        ],
        "message": "test: deflake coverage take two (#11970)\n\nMaking the known-slow many header test slightly less slow in the hopes of reducing timeouts.\n\nRisk Level: n/a\nTesting: n/a\nDocs Changes: n/a\nRelease Notes: n/a\n\nSigned-off-by: Alyssa Wilk <alyssar@chromium.org>",
        "before_after_code_files": [
          "test/integration/http_integration.cc||test/integration/http_integration.cc"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "test/integration/http_integration.cc||test/integration/http_integration.cc"
          ],
          "candidate": [
            "test/integration/http_integration.cc||test/integration/http_integration.cc"
          ]
        }
      },
      "candidate_diff": {
        "test/integration/http_integration.cc||test/integration/http_integration.cc": [
          "File: test/integration/http_integration.cc -> test/integration/http_integration.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "1098:   max_request_headers_kb_ = 96;",
          "1101:   config_helper_.addConfigModifier(",
          "1102:       [&](envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager&",
          "",
          "[Removed Lines]",
          "1099:   max_request_headers_count_ = 20005;",
          "",
          "[Added Lines]",
          "1099:   max_request_headers_count_ = 10005;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1112:        {Http::Headers::get().Scheme, \"http\"},",
          "1113:        {Http::Headers::get().Host, \"host\"}});",
          "1116:     big_headers->addCopy(Http::LowerCaseString(std::to_string(i)), std::string(0, 'a'));",
          "1117:   }",
          "1118:   initialize();",
          "",
          "[Removed Lines]",
          "1115:   for (int i = 0; i < 20000; i++) {",
          "",
          "[Added Lines]",
          "1115:   for (int i = 0; i < 10000; i++) {",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "82b5fd4fb05fac53ffc9c3b8d41ddfc24e317a23",
      "candidate_info": {
        "commit_hash": "82b5fd4fb05fac53ffc9c3b8d41ddfc24e317a23",
        "repo": "envoyproxy/envoy",
        "commit_url": "https://github.com/envoyproxy/envoy/commit/82b5fd4fb05fac53ffc9c3b8d41ddfc24e317a23",
        "files": [
          "docs/root/intro/version_history.rst",
          "source/common/http/http1/codec_impl.cc",
          "source/common/http/http1/codec_impl.h",
          "test/common/http/http1/codec_impl_test.cc"
        ],
        "message": "http: http/1 codec refactor (#10199)\n\nThese changes are required for fully splitting the header map into\ndiscrete types.\n1) Prepare for concrete types\n2) Fully remove client pipelining support as we don't actually use it\n   anywhere and it made the refactor more complicated.\n3) As a bonus, remove per-request/response heap allocations for HTTP/1.\n\nSigned-off-by: Matt Klein <mklein@lyft.com>",
        "before_after_code_files": [
          "source/common/http/http1/codec_impl.cc||source/common/http/http1/codec_impl.cc",
          "source/common/http/http1/codec_impl.h||source/common/http/http1/codec_impl.h",
          "test/common/http/http1/codec_impl_test.cc||test/common/http/http1/codec_impl_test.cc"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "source/common/http/http1/codec_impl.cc||source/common/http/http1/codec_impl.cc"
          ],
          "candidate": [
            "source/common/http/http1/codec_impl.cc||source/common/http/http1/codec_impl.cc"
          ]
        }
      },
      "candidate_diff": {
        "source/common/http/http1/codec_impl.cc||source/common/http/http1/codec_impl.cc": [
          "File: source/common/http/http1/codec_impl.cc -> source/common/http/http1/codec_impl.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "33:   const absl::string_view InvalidCharacters = \"http1.invalid_characters\";",
          "34:   const absl::string_view ConnectionHeaderSanitization = \"http1.connection_header_rejected\";",
          "35:   const absl::string_view InvalidUrl = \"http1.invalid_url\";",
          "36: };",
          "38: struct Http1HeaderTypesValues {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "36:   const absl::string_view InvalidTransferEncoding = \"http1.invalid_transfer_encoding\";",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "357:   if (method->value() == Headers::get().MethodValues.Head) {",
          "358:     head_request_ = true;",
          "359:   }",
          "361:   connection_.copyToBuffer(method->value().getStringView().data(), method->value().size());",
          "362:   connection_.addCharToBuffer(' ');",
          "363:   connection_.copyToBuffer(path->value().getStringView().data(), path->value().size());",
          "",
          "[Removed Lines]",
          "360:   connection_.onEncodeHeaders(headers);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "423:   ENVOY_CONN_LOG(trace, \"completed header: key={} value={}\", connection_,",
          "424:                  current_header_field_.getStringView(), current_header_value_.getStringView());",
          "426:   if (!current_header_field_.empty()) {",
          "427:     current_header_field_.inlineTransform([](char c) { return absl::ascii_tolower(c); });",
          "429:   }",
          "433:     error_code_ = Http::Code::RequestHeaderFieldsTooLarge;",
          "434:     sendProtocolError(Http1ResponseCodeDetails::get().TooManyHeaders);",
          "435:     const absl::string_view header_type =",
          "",
          "[Removed Lines]",
          "428:     headers().addViaMove(std::move(current_header_field_), std::move(current_header_value_));",
          "432:   if (headers().size() > max_headers_count_) {",
          "",
          "[Added Lines]",
          "426:   auto& headers_or_trailers = headersOrTrailers();",
          "429:     headers_or_trailers.addViaMove(std::move(current_header_field_),",
          "430:                                    std::move(current_header_value_));",
          "434:   if (headers_or_trailers.size() > max_headers_count_) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "553:   current_header_value_.append(header_value.data(), header_value.length());",
          "555:   const uint32_t total =",
          "557:   if (total > (max_headers_kb_ * 1024)) {",
          "558:     const absl::string_view header_type =",
          "559:         processing_trailers_ ? Http1HeaderTypes::get().Trailers : Http1HeaderTypes::get().Headers;",
          "",
          "[Removed Lines]",
          "556:       current_header_field_.size() + current_header_value_.size() + headers().byteSize();",
          "",
          "[Added Lines]",
          "558:       current_header_field_.size() + current_header_value_.size() + headersOrTrailers().byteSize();",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "564: }",
          "566: int ConnectionImpl::onHeadersCompleteBase() {",
          "570:   completeLastHeader();",
          "572:   if (!(parser_.http_major == 1 && parser_.http_minor == 1)) {",
          "",
          "[Removed Lines]",
          "567:   const absl::string_view header_type =",
          "568:       processing_trailers_ ? Http1HeaderTypes::get().Trailers : Http1HeaderTypes::get().Headers;",
          "569:   ENVOY_CONN_LOG(trace, \"onHeadersCompleteBase complete for {}\", connection_, header_type);",
          "",
          "[Added Lines]",
          "569:   ASSERT(!processing_trailers_);",
          "570:   ENVOY_CONN_LOG(trace, \"onHeadersCompleteBase\", connection_);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "575:     protocol_ = Protocol::Http10;",
          "576:   }",
          "583:                                Http::Headers::get().UpgradeValues.H2c)) {",
          "584:       ENVOY_CONN_LOG(trace, \"removing unsupported h2c upgrade headers.\", connection_);",
          "587:         const auto& tokens_to_remove = caseUnorderdSetContainingUpgradeAndHttp2Settings();",
          "588:         std::string new_value = StringUtil::removeTokens(",
          "590:         if (new_value.empty()) {",
          "592:         } else {",
          "594:         }",
          "595:       }",
          "597:     } else {",
          "598:       ENVOY_CONN_LOG(trace, \"codec entering upgrade mode.\", connection_);",
          "599:       handling_upgrade_ = true;",
          "600:     }",
          "611:   }",
          "617:     if (Runtime::runtimeFeatureEnabled(",
          "618:             \"envoy.reloadable_features.reject_unsupported_transfer_encodings\") &&",
          "619:         !absl::EqualsIgnoreCase(encoding, Headers::get().TransferEncodingValues.Identity) &&",
          "620:         !absl::EqualsIgnoreCase(encoding, Headers::get().TransferEncodingValues.Chunked)) {",
          "621:       error_code_ = Http::Code::NotImplemented;",
          "623:       throw CodecProtocolException(\"http/1.1 protocol error: unsupported transfer encoding\");",
          "624:     }",
          "625:   }",
          "",
          "[Removed Lines]",
          "577:   HeaderMap& current_headers = headers();",
          "578:   if (Utility::isUpgrade(current_headers)) {",
          "581:     if (current_headers.Upgrade() &&",
          "582:         absl::EqualsIgnoreCase(current_headers.Upgrade()->value().getStringView(),",
          "585:       current_headers.removeUpgrade();",
          "586:       if (current_headers.Connection()) {",
          "589:             current_headers.Connection()->value().getStringView(), \",\", tokens_to_remove, \",\");",
          "591:           current_headers.removeConnection();",
          "593:           current_headers.setConnection(new_value);",
          "596:       current_headers.remove(Headers::get().Http2Settings);",
          "601:   } else if (connection_header_sanitization_ && current_headers.Connection()) {",
          "603:     if (!Utility::sanitizeConnectionHeader(current_headers)) {",
          "604:       absl::string_view header_value = current_headers.Connection()->value().getStringView();",
          "605:       ENVOY_CONN_LOG(debug, \"Invalid nominated headers in Connection: {}\", connection_,",
          "606:                      header_value);",
          "607:       error_code_ = Http::Code::BadRequest;",
          "608:       sendProtocolError(Http1ResponseCodeDetails::get().ConnectionHeaderSanitization);",
          "609:       throw CodecProtocolException(\"Invalid nominated headers in Connection.\");",
          "610:     }",
          "615:   if (current_headers.TransferEncoding()) {",
          "616:     absl::string_view encoding = current_headers.TransferEncoding()->value().getStringView();",
          "622:       sendProtocolError();",
          "",
          "[Added Lines]",
          "578:   RequestOrResponseHeaderMap& request_or_response_headers = requestOrResponseHeaders();",
          "579:   if (Utility::isUpgrade(request_or_response_headers)) {",
          "582:     if (request_or_response_headers.Upgrade() &&",
          "583:         absl::EqualsIgnoreCase(request_or_response_headers.Upgrade()->value().getStringView(),",
          "586:       request_or_response_headers.removeUpgrade();",
          "587:       if (request_or_response_headers.Connection()) {",
          "590:             request_or_response_headers.Connection()->value().getStringView(), \",\",",
          "591:             tokens_to_remove, \",\");",
          "593:           request_or_response_headers.removeConnection();",
          "595:           request_or_response_headers.setConnection(new_value);",
          "598:       request_or_response_headers.remove(Headers::get().Http2Settings);",
          "607:   if (request_or_response_headers.TransferEncoding()) {",
          "608:     absl::string_view encoding =",
          "609:         request_or_response_headers.TransferEncoding()->value().getStringView();",
          "615:       sendProtocolError(Http1ResponseCodeDetails::get().InvalidTransferEncoding);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "691:           Runtime::runtimeFeatureEnabled(\"envoy.reloadable_features.http1_flood_protection\")) {}",
          "693: void ServerConnectionImpl::onEncodeComplete() {",
          "",
          "[Removed Lines]",
          "694:   ASSERT(active_request_);",
          "695:   if (active_request_->remote_complete_) {",
          "",
          "[Added Lines]",
          "687:   if (active_request_.value().remote_complete_) {",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "700:   }",
          "701: }",
          "704:   HeaderString path(Headers::get().Path);",
          "706:   bool is_connect = (method == HTTP_CONNECT);",
          "713:     return;",
          "714:   }",
          "718:   if (!codec_settings_.allow_absolute_url_) {",
          "720:     return;",
          "721:   }",
          "723:   if (is_connect) {",
          "725:     return;",
          "726:   }",
          "728:   Utility::Url absolute_url;",
          "730:     sendProtocolError(Http1ResponseCodeDetails::get().InvalidUrl);",
          "731:     throw CodecProtocolException(\"http/1.1 protocol error: invalid url in request line\");",
          "732:   }",
          "",
          "[Removed Lines]",
          "703: void ServerConnectionImpl::handlePath(HeaderMap& headers, unsigned int method) {",
          "709:   if (!active_request_->request_url_.getStringView().empty() &&",
          "710:       (active_request_->request_url_.getStringView()[0] == '/' ||",
          "711:        ((method == HTTP_OPTIONS) && active_request_->request_url_.getStringView()[0] == '*'))) {",
          "712:     headers.addViaMove(std::move(path), std::move(active_request_->request_url_));",
          "719:     headers.addViaMove(std::move(path), std::move(active_request_->request_url_));",
          "724:     headers.addViaMove(std::move(path), std::move(active_request_->request_url_));",
          "729:   if (!absolute_url.initialize(active_request_->request_url_.getStringView())) {",
          "",
          "[Added Lines]",
          "695: void ServerConnectionImpl::handlePath(RequestHeaderMap& headers, unsigned int method) {",
          "701:   auto& active_request = active_request_.value();",
          "702:   if (!active_request.request_url_.getStringView().empty() &&",
          "703:       (active_request.request_url_.getStringView()[0] == '/' ||",
          "704:        ((method == HTTP_OPTIONS) && active_request.request_url_.getStringView()[0] == '*'))) {",
          "705:     headers.addViaMove(std::move(path), std::move(active_request.request_url_));",
          "712:     headers.addViaMove(std::move(path), std::move(active_request.request_url_));",
          "717:     headers.addViaMove(std::move(path), std::move(active_request.request_url_));",
          "722:   if (!absolute_url.initialize(active_request.request_url_.getStringView())) {",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "740:   headers.setHost(absolute_url.host_and_port());",
          "742:   headers.setPath(absolute_url.path_and_query_params());",
          "744: }",
          "746: int ServerConnectionImpl::onHeadersComplete() {",
          "751:     auto& headers = absl::get<RequestHeaderMapPtr>(headers_or_trailers_);",
          "752:     ENVOY_CONN_LOG(trace, \"Server: onHeadersComplete size={}\", connection_, headers->size());",
          "753:     const char* method_string = http_method_str(static_cast<http_method>(parser_.method));",
          "761:     handlePath(*headers, parser_.method);",
          "764:     headers->setMethod(method_string);",
          "",
          "[Removed Lines]",
          "743:   active_request_->request_url_.clear();",
          "750:   if (active_request_) {",
          "757:     active_request_->response_encoder_.isResponseToHeadRequest(parser_.method == HTTP_HEAD);",
          "762:     ASSERT(active_request_->request_url_.empty());",
          "",
          "[Added Lines]",
          "736:   active_request.request_url_.clear();",
          "743:   if (active_request_.has_value()) {",
          "744:     auto& active_request = active_request_.value();",
          "749:     if (!handling_upgrade_ && connection_header_sanitization_ && headers->Connection()) {",
          "751:       if (!Utility::sanitizeConnectionHeader(*headers)) {",
          "752:         absl::string_view header_value = headers->Connection()->value().getStringView();",
          "753:         ENVOY_CONN_LOG(debug, \"Invalid nominated headers in Connection: {}\", connection_,",
          "754:                        header_value);",
          "755:         error_code_ = Http::Code::BadRequest;",
          "756:         sendProtocolError(Http1ResponseCodeDetails::get().ConnectionHeaderSanitization);",
          "757:         throw CodecProtocolException(\"Invalid nominated headers in Connection.\");",
          "758:       }",
          "759:     }",
          "763:     active_request.response_encoder_.isResponseToHeadRequest(parser_.method == HTTP_HEAD);",
          "768:     ASSERT(active_request.request_url_.empty());",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "780:     if (parser_.flags & F_CHUNKED ||",
          "781:         (parser_.content_length > 0 && parser_.content_length != ULLONG_MAX) || handling_upgrade_) {",
          "",
          "[Removed Lines]",
          "782:       active_request_->request_decoder_->decodeHeaders(std::move(headers), false);",
          "",
          "[Added Lines]",
          "788:       active_request.request_decoder_->decodeHeaders(std::move(headers), false);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "797: void ServerConnectionImpl::onMessageBegin() {",
          "798:   if (!resetStreamCalled()) {",
          "803:   }",
          "804: }",
          "806: void ServerConnectionImpl::onUrl(const char* data, size_t length) {",
          "809:   }",
          "810: }",
          "812: void ServerConnectionImpl::onBody(const char* data, size_t length) {",
          "813:   ASSERT(!deferred_end_stream_headers_);",
          "815:     ENVOY_CONN_LOG(trace, \"body size={}\", connection_, length);",
          "816:     Buffer::OwnedImpl buffer(data, length);",
          "818:   }",
          "819: }",
          "821: void ServerConnectionImpl::onMessageComplete() {",
          "824:     if (deferred_end_stream_headers_) {",
          "826:           std::move(absl::get<RequestHeaderMapPtr>(headers_or_trailers_)), true);",
          "827:       deferred_end_stream_headers_ = false;",
          "828:     } else if (processing_trailers_) {",
          "830:           std::move(absl::get<RequestTrailerMapPtr>(headers_or_trailers_)));",
          "831:     } else {",
          "832:       Buffer::OwnedImpl buffer;",
          "834:     }",
          "",
          "[Removed Lines]",
          "799:     ASSERT(!active_request_);",
          "800:     active_request_ =",
          "801:         std::make_unique<ActiveRequest>(*this, header_key_formatter_.get(), flood_checks_);",
          "802:     active_request_->request_decoder_ = &callbacks_.newStream(active_request_->response_encoder_);",
          "807:   if (active_request_) {",
          "808:     active_request_->request_url_.append(data, length);",
          "814:   if (active_request_) {",
          "817:     active_request_->request_decoder_->decodeData(buffer, false);",
          "822:   if (active_request_) {",
          "823:     active_request_->remote_complete_ = true;",
          "825:       active_request_->request_decoder_->decodeHeaders(",
          "829:       active_request_->request_decoder_->decodeTrailers(",
          "833:       active_request_->request_decoder_->decodeData(buffer, true);",
          "",
          "[Added Lines]",
          "805:     ASSERT(!active_request_.has_value());",
          "806:     active_request_.emplace(*this, header_key_formatter_.get(), flood_checks_);",
          "807:     auto& active_request = active_request_.value();",
          "808:     active_request.request_decoder_ = &callbacks_.newStream(active_request.response_encoder_);",
          "813:   if (active_request_.has_value()) {",
          "814:     active_request_.value().request_url_.append(data, length);",
          "820:   if (active_request_.has_value()) {",
          "823:     active_request_.value().request_decoder_->decodeData(buffer, false);",
          "828:   if (active_request_.has_value()) {",
          "829:     auto& active_request = active_request_.value();",
          "830:     active_request.remote_complete_ = true;",
          "832:       active_request.request_decoder_->decodeHeaders(",
          "836:       active_request.request_decoder_->decodeTrailers(",
          "840:       active_request.request_decoder_->decodeData(buffer, true);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "844: }",
          "846: void ServerConnectionImpl::onResetStream(StreamResetReason reason) {",
          "849:   active_request_.reset();",
          "850: }",
          "852: void ServerConnectionImpl::sendProtocolError(absl::string_view details) {",
          "855:   }",
          "861:     Buffer::OwnedImpl bad_request_response(",
          "862:         absl::StrCat(\"HTTP/1.1 \", error_code_, \" \", CodeUtility::toString(error_code_),",
          "863:                      \"\\r\\ncontent-length: 0\\r\\nconnection: close\\r\\n\\r\\n\"));",
          "",
          "[Removed Lines]",
          "847:   ASSERT(active_request_);",
          "848:   active_request_->response_encoder_.runResetCallbacks(reason);",
          "853:   if (active_request_) {",
          "854:     active_request_->response_encoder_.setDetails(details);",
          "860:   if (!active_request_ || !active_request_->response_encoder_.startedResponse()) {",
          "",
          "[Added Lines]",
          "854:   active_request_.value().response_encoder_.runResetCallbacks(reason);",
          "859:   if (active_request_.has_value()) {",
          "860:     active_request_.value().response_encoder_.setDetails(details);",
          "866:   if (!active_request_.has_value() ||",
          "867:       !active_request_.value().response_encoder_.startedResponse()) {",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "867: }",
          "869: void ServerConnectionImpl::onAboveHighWatermark() {",
          "872:   }",
          "873: }",
          "874: void ServerConnectionImpl::onBelowLowWatermark() {",
          "877:   }",
          "878: }",
          "",
          "[Removed Lines]",
          "870:   if (active_request_) {",
          "871:     active_request_->response_encoder_.runHighWatermarkCallbacks();",
          "875:   if (active_request_) {",
          "876:     active_request_->response_encoder_.runLowWatermarkCallbacks();",
          "",
          "[Added Lines]",
          "877:   if (active_request_.has_value()) {",
          "878:     active_request_.value().response_encoder_.runHighWatermarkCallbacks();",
          "882:   if (active_request_.has_value()) {",
          "883:     active_request_.value().response_encoder_.runLowWatermarkCallbacks();",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "891:                      max_response_headers_count, formatter(settings), settings.enable_trailers_) {}",
          "893: bool ClientConnectionImpl::cannotHaveBody() {",
          "895:       parser_.status_code == 204 || parser_.status_code == 304 ||",
          "896:       (parser_.status_code >= 200 && parser_.content_length == 0)) {",
          "897:     return true;",
          "",
          "[Removed Lines]",
          "894:   if ((!pending_responses_.empty() && pending_responses_.front().head_request_) ||",
          "",
          "[Added Lines]",
          "901:   if ((pending_response_.has_value() && pending_response_.value().encoder_.headRequest()) ||",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "906:   }",
          "910:   ASSERT(connection_.readEnabled());",
          "921: }",
          "923: int ClientConnectionImpl::onHeadersComplete() {",
          "928:     throw PrematureResponseException(static_cast<Http::Code>(parser_.status_code));",
          "930:     auto& headers = absl::get<ResponseHeaderMapPtr>(headers_or_trailers_);",
          "931:     ENVOY_CONN_LOG(trace, \"Client: onHeadersComplete size={}\", connection_, headers->size());",
          "932:     headers->setStatus(parser_.status_code);",
          "",
          "[Removed Lines]",
          "912:   request_encoder_ = std::make_unique<RequestEncoderImpl>(*this, header_key_formatter_.get());",
          "913:   pending_responses_.emplace_back(&response_decoder);",
          "914:   return *request_encoder_;",
          "915: }",
          "917: void ClientConnectionImpl::onEncodeHeaders(const HeaderMap& headers) {",
          "918:   if (headers.Method()->value() == Headers::get().MethodValues.Head.c_str()) {",
          "919:     pending_responses_.back().head_request_ = true;",
          "920:   }",
          "927:   if (pending_responses_.empty() && !resetStreamCalled()) {",
          "929:   } else if (!pending_responses_.empty()) {",
          "",
          "[Added Lines]",
          "919:   ASSERT(!pending_response_.has_value());",
          "920:   pending_response_.emplace(*this, header_key_formatter_.get(), &response_decoder);",
          "921:   return pending_response_.value().encoder_;",
          "928:   if (!pending_response_.has_value() && !resetStreamCalled()) {",
          "930:   } else if (pending_response_.has_value()) {",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "937:       ignore_message_complete_for_100_continue_ = true;",
          "",
          "[Removed Lines]",
          "938:       pending_responses_.front().decoder_->decode100ContinueHeaders(std::move(headers));",
          "",
          "[Added Lines]",
          "939:       pending_response_.value().decoder_->decode100ContinueHeaders(std::move(headers));",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "943:     } else if (cannotHaveBody()) {",
          "944:       deferred_end_stream_headers_ = true;",
          "945:     } else {",
          "947:     }",
          "948:   }",
          "",
          "[Removed Lines]",
          "946:       pending_responses_.front().decoder_->decodeHeaders(std::move(headers), false);",
          "",
          "[Added Lines]",
          "947:       pending_response_.value().decoder_->decodeHeaders(std::move(headers), false);",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "955: void ClientConnectionImpl::onBody(const char* data, size_t length) {",
          "956:   ASSERT(!deferred_end_stream_headers_);",
          "958:     Buffer::OwnedImpl buffer;",
          "959:     buffer.add(data, length);",
          "961:   }",
          "962: }",
          "",
          "[Removed Lines]",
          "957:   if (!pending_responses_.empty()) {",
          "960:     pending_responses_.front().decoder_->decodeData(buffer, false);",
          "",
          "[Added Lines]",
          "958:   if (pending_response_.has_value()) {",
          "961:     pending_response_.value().decoder_->decodeData(buffer, false);",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "967:     ignore_message_complete_for_100_continue_ = false;",
          "968:     return;",
          "969:   }",
          "982:       while (!connection_.readEnabled()) {",
          "983:         connection_.readDisable(false);",
          "984:       }",
          "",
          "[Removed Lines]",
          "970:   if (!pending_responses_.empty()) {",
          "972:     PendingResponse response = std::move(pending_responses_.front());",
          "973:     pending_responses_.pop_front();",
          "981:     if (connection_.state() == Network::Connection::State::Open && pending_responses_.empty()) {",
          "",
          "[Added Lines]",
          "971:   if (pending_response_.has_value()) {",
          "973:     PendingResponse response = std::move(pending_response_.value());",
          "974:     pending_response_.reset();",
          "981:     if (connection_.state() == Network::Connection::State::Open) {",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "1004: void ClientConnectionImpl::onResetStream(StreamResetReason reason) {",
          "1009:   }",
          "1010: }",
          "1012: void ClientConnectionImpl::sendProtocolError(absl::string_view details) {",
          "1015:   }",
          "1016: }",
          "1018: void ClientConnectionImpl::onAboveHighWatermark() {",
          "1022: }",
          "1024: void ClientConnectionImpl::onBelowLowWatermark() {",
          "1030:   }",
          "1031: }",
          "",
          "[Removed Lines]",
          "1006:   if (!pending_responses_.empty()) {",
          "1007:     pending_responses_.clear();",
          "1008:     request_encoder_->runResetCallbacks(reason);",
          "1013:   if (request_encoder_) {",
          "1014:     request_encoder_->setDetails(details);",
          "1020:   ASSERT(!pending_responses_.empty());",
          "1021:   request_encoder_->runHighWatermarkCallbacks();",
          "1028:   if (!pending_responses_.empty()) {",
          "1029:     request_encoder_->runLowWatermarkCallbacks();",
          "",
          "[Added Lines]",
          "1006:   if (pending_response_.has_value()) {",
          "1007:     pending_response_.value().encoder_.runResetCallbacks(reason);",
          "1008:     pending_response_.reset();",
          "1013:   if (pending_response_.has_value()) {",
          "1014:     pending_response_.value().encoder_.setDetails(details);",
          "1020:   pending_response_.value().encoder_.runHighWatermarkCallbacks();",
          "1027:   if (pending_response_.has_value()) {",
          "1028:     pending_response_.value().encoder_.runLowWatermarkCallbacks();",
          "",
          "---------------"
        ],
        "source/common/http/http1/codec_impl.h||source/common/http/http1/codec_impl.h": [
          "File: source/common/http/http1/codec_impl.h -> source/common/http/http1/codec_impl.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "165:   virtual void onEncodeComplete() PURE;",
          "",
          "[Removed Lines]",
          "170:   virtual void onEncodeHeaders(const HeaderMap& headers) PURE;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "231: private:",
          "232:   enum class HeaderParsingState { Field, Value, Done };",
          "235:   virtual void allocHeaders() PURE;",
          "236:   virtual void maybeAllocTrailers() PURE;",
          "",
          "[Removed Lines]",
          "234:   virtual HeaderMap& headers() PURE;",
          "",
          "[Added Lines]",
          "229:   virtual HeaderMap& headersOrTrailers() PURE;",
          "230:   virtual RequestOrResponseHeaderMap& requestOrResponseHeaders() PURE;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "308:   virtual void sendProtocolError(absl::string_view details = \"\") PURE;",
          "",
          "[Added Lines]",
          "304:   virtual void sendProtocolError(absl::string_view details) PURE;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "371:   void onEncodeComplete() override;",
          "373:   void onMessageBegin() override;",
          "374:   void onUrl(const char* data, size_t length) override;",
          "375:   int onHeadersComplete() override;",
          "",
          "[Removed Lines]",
          "368:   void handlePath(HeaderMap& headers, unsigned int method);",
          "372:   void onEncodeHeaders(const HeaderMap&) override {}",
          "",
          "[Added Lines]",
          "364:   void handlePath(RequestHeaderMap& headers, unsigned int method);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "379:   void sendProtocolError(absl::string_view details) override;",
          "380:   void onAboveHighWatermark() override;",
          "381:   void onBelowLowWatermark() override;",
          "383:     if (absl::holds_alternative<RequestHeaderMapPtr>(headers_or_trailers_)) {",
          "384:       return *absl::get<RequestHeaderMapPtr>(headers_or_trailers_);",
          "385:     } else {",
          "386:       return *absl::get<RequestTrailerMapPtr>(headers_or_trailers_);",
          "387:     }",
          "388:   }",
          "389:   void allocHeaders() override {",
          "390:     ASSERT(nullptr == absl::get<RequestHeaderMapPtr>(headers_or_trailers_));",
          "391:     headers_or_trailers_.emplace<RequestHeaderMapPtr>(std::make_unique<RequestHeaderMapImpl>());",
          "",
          "[Removed Lines]",
          "382:   HeaderMap& headers() override {",
          "",
          "[Added Lines]",
          "377:   HeaderMap& headersOrTrailers() override {",
          "384:   RequestOrResponseHeaderMap& requestOrResponseHeaders() override {",
          "385:     return *absl::get<RequestHeaderMapPtr>(headers_or_trailers_);",
          "386:   }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "404:   ServerConnectionCallbacks& callbacks_;",
          "405:   std::function<void()> flood_checks_{[&]() { this->doFloodProtectionChecks(); }};",
          "407:   Http1Settings codec_settings_;",
          "408:   const Buffer::OwnedBufferFragmentImpl::Releasor response_buffer_releasor_;",
          "409:   uint32_t outbound_responses_{};",
          "",
          "[Removed Lines]",
          "406:   std::unique_ptr<ActiveRequest> active_request_;",
          "",
          "[Added Lines]",
          "404:   absl::optional<ActiveRequest> active_request_;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "435: private:",
          "436:   struct PendingResponse {",
          "439:     ResponseDecoder* decoder_;",
          "441:   };",
          "443:   bool cannotHaveBody();",
          "446:   void onEncodeComplete() override {}",
          "448:   void onMessageBegin() override {}",
          "449:   void onUrl(const char*, size_t) override { NOT_IMPLEMENTED_GCOVR_EXCL_LINE; }",
          "450:   int onHeadersComplete() override;",
          "",
          "[Removed Lines]",
          "437:     PendingResponse(ResponseDecoder* decoder) : decoder_(decoder) {}",
          "440:     bool head_request_{};",
          "447:   void onEncodeHeaders(const HeaderMap& headers) override;",
          "",
          "[Added Lines]",
          "435:     PendingResponse(ConnectionImpl& connection, HeaderKeyFormatter* header_key_formatter,",
          "436:                     ResponseDecoder* decoder)",
          "437:         : encoder_(connection, header_key_formatter), decoder_(decoder) {}",
          "439:     RequestEncoderImpl encoder_;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "454:   void sendProtocolError(absl::string_view details) override;",
          "455:   void onAboveHighWatermark() override;",
          "456:   void onBelowLowWatermark() override;",
          "458:     if (absl::holds_alternative<ResponseHeaderMapPtr>(headers_or_trailers_)) {",
          "459:       return *absl::get<ResponseHeaderMapPtr>(headers_or_trailers_);",
          "460:     } else {",
          "461:       return *absl::get<ResponseTrailerMapPtr>(headers_or_trailers_);",
          "462:     }",
          "463:   }",
          "464:   void allocHeaders() override {",
          "465:     ASSERT(nullptr == absl::get<ResponseHeaderMapPtr>(headers_or_trailers_));",
          "466:     headers_or_trailers_.emplace<ResponseHeaderMapPtr>(std::make_unique<ResponseHeaderMapImpl>());",
          "",
          "[Removed Lines]",
          "457:   HeaderMap& headers() override {",
          "",
          "[Added Lines]",
          "456:   HeaderMap& headersOrTrailers() override {",
          "463:   RequestOrResponseHeaderMap& requestOrResponseHeaders() override {",
          "464:     return *absl::get<ResponseHeaderMapPtr>(headers_or_trailers_);",
          "465:   }",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "473:     }",
          "474:   }",
          "479:   bool ignore_message_complete_for_100_continue_{};",
          "",
          "[Removed Lines]",
          "476:   std::unique_ptr<RequestEncoderImpl> request_encoder_;",
          "477:   std::list<PendingResponse> pending_responses_;",
          "",
          "[Added Lines]",
          "478:   absl::optional<PendingResponse> pending_response_;",
          "",
          "---------------"
        ],
        "test/common/http/http1/codec_impl_test.cc||test/common/http/http1/codec_impl_test.cc": [
          "File: test/common/http/http1/codec_impl_test.cc -> test/common/http/http1/codec_impl_test.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "1248:   TestHeaderMapImpl expected_headers{{\":authority\", \"www.somewhere.com\"},",
          "1249:                                      {\":path\", \"/\"},",
          "1250:                                      {\":method\", \"GET\"},",
          "1252:   Buffer::OwnedImpl buffer(\"GET http://www.somewhere.com/ HTTP/1.1\\r\\nConnection: \"",
          "1253:                            \"Upgrade, Close, HTTP2-Settings, Etc\\r\\nUpgrade: h2c\\r\\nHTTP2-Settings: \"",
          "1254:                            \"token64\\r\\nHost: bah\\r\\n\\r\\n\");",
          "",
          "[Removed Lines]",
          "1251:                                      {\"connection\", \"Close,Etc\"}};",
          "",
          "[Added Lines]",
          "1251:                                      {\"connection\", \"Close\"}};",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1445:   std::string output;",
          "1446:   ON_CALL(connection_, write(_, _)).WillByDefault(AddBufferToString(&output));",
          "1449:   TestRequestHeaderMapImpl headers{{\":method\", \"GET\"}, {\":path\", \"/\"}, {\":authority\", \"host\"}};",
          "1450:   request_encoder->encodeHeaders(headers, true);",
          "1451:   EXPECT_EQ(\"GET / HTTP/1.1\\r\\nhost: host\\r\\ncontent-length: 0\\r\\n\\r\\n\", output);",
          "1452:   output.clear();",
          "1468:   EXPECT_CALL(connection_, readEnabled())",
          "",
          "[Removed Lines]",
          "1455:   request_encoder = &codec_->newStream(response_decoder);",
          "1456:   request_encoder->encodeHeaders(headers, false);",
          "1457:   Buffer::OwnedImpl empty;",
          "1458:   request_encoder->encodeData(empty, true);",
          "1459:   EXPECT_EQ(\"GET / HTTP/1.1\\r\\nhost: host\\r\\ntransfer-encoding: chunked\\r\\n\\r\\n0\\r\\n\\r\\n\", output);",
          "1462:   EXPECT_CALL(response_decoder, decodeHeaders_(_, true));",
          "1463:   Buffer::OwnedImpl response(\"HTTP/1.1 503 Service Unavailable\\r\\nContent-Length: 0\\r\\n\\r\\n\");",
          "1464:   codec_->dispatch(response);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1471:       .WillRepeatedly(Return(true));",
          "1472:   EXPECT_CALL(connection_, readDisable(false));",
          "1475:   EXPECT_CALL(response_decoder, decodeHeaders_(_, true));",
          "1478: }",
          "1480: TEST_F(Http1ClientConnectionImplTest, PrematureResponse) {",
          "",
          "[Removed Lines]",
          "1476:   Buffer::OwnedImpl response2(\"HTTP/1.1 503 Service Unavailable\\r\\nContent-Length: 0\\r\\n\\r\\n\");",
          "1477:   codec_->dispatch(response2);",
          "",
          "[Added Lines]",
          "1464:   Buffer::OwnedImpl response(\"HTTP/1.1 503 Service Unavailable\\r\\nContent-Length: 0\\r\\n\\r\\n\");",
          "1465:   codec_->dispatch(response);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "9ad469da374642c88d001cd6945d60e79537de30",
      "candidate_info": {
        "commit_hash": "9ad469da374642c88d001cd6945d60e79537de30",
        "repo": "envoyproxy/envoy",
        "commit_url": "https://github.com/envoyproxy/envoy/commit/9ad469da374642c88d001cd6945d60e79537de30",
        "files": [
          "docs/root/intro/version_history.rst",
          "include/envoy/http/BUILD",
          "include/envoy/http/codec.h",
          "source/common/http/http1/codec_impl.cc",
          "source/common/http/http1/codec_impl.h",
          "source/common/http/http2/codec_impl.h",
          "source/common/router/router.cc",
          "source/extensions/quic_listeners/quiche/envoy_quic_stream.h",
          "test/common/access_log/access_log_formatter_corpus/upstream_local_address",
          "test/common/router/router_test.cc",
          "test/common/router/router_upstream_log_test.cc",
          "test/fuzz/common.proto",
          "test/fuzz/utility.h",
          "test/integration/integration_test.cc",
          "test/mocks/http/stream.cc",
          "test/mocks/http/stream.h"
        ],
        "message": "Make %UPSTREAM_LOCAL_ADDRESS% access-log format work for HTTP requests. (#9362)\n\nSigned-off-by: Greg Greenway <ggreenway@apple.com>",
        "before_after_code_files": [
          "include/envoy/http/codec.h||include/envoy/http/codec.h",
          "source/common/http/http1/codec_impl.cc||source/common/http/http1/codec_impl.cc",
          "source/common/http/http1/codec_impl.h||source/common/http/http1/codec_impl.h",
          "source/common/http/http2/codec_impl.h||source/common/http/http2/codec_impl.h",
          "source/common/router/router.cc||source/common/router/router.cc",
          "source/extensions/quic_listeners/quiche/envoy_quic_stream.h||source/extensions/quic_listeners/quiche/envoy_quic_stream.h",
          "test/common/router/router_test.cc||test/common/router/router_test.cc",
          "test/common/router/router_upstream_log_test.cc||test/common/router/router_upstream_log_test.cc",
          "test/fuzz/common.proto||test/fuzz/common.proto",
          "test/fuzz/utility.h||test/fuzz/utility.h",
          "test/integration/integration_test.cc||test/integration/integration_test.cc",
          "test/mocks/http/stream.cc||test/mocks/http/stream.cc",
          "test/mocks/http/stream.h||test/mocks/http/stream.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "source/common/http/http1/codec_impl.cc||source/common/http/http1/codec_impl.cc",
            "source/common/router/router.cc||source/common/router/router.cc"
          ],
          "candidate": [
            "source/common/http/http1/codec_impl.cc||source/common/http/http1/codec_impl.cc",
            "source/common/router/router.cc||source/common/router/router.cc"
          ]
        }
      },
      "candidate_diff": {
        "include/envoy/http/codec.h||include/envoy/http/codec.h": [
          "File: include/envoy/http/codec.h -> include/envoy/http/codec.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "9: #include \"envoy/http/header_map.h\"",
          "10: #include \"envoy/http/metadata_interface.h\"",
          "11: #include \"envoy/http/protocol.h\"",
          "13: namespace Envoy {",
          "14: namespace Http {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "12: #include \"envoy/network/address.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "214:   virtual absl::string_view responseDetails() { return \"\"; }",
          "215: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "221:   virtual const Network::Address::InstanceConstSharedPtr& connectionLocalAddress() PURE;",
          "",
          "---------------"
        ],
        "source/common/http/http1/codec_impl.cc||source/common/http/http1/codec_impl.cc": [
          "File: source/common/http/http1/codec_impl.cc -> source/common/http/http1/codec_impl.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "302: uint32_t StreamEncoderImpl::bufferLimit() { return connection_.bufferLimit(); }",
          "304: static const char RESPONSE_PREFIX[] = \"HTTP/1.1 \";",
          "305: static const char HTTP_10_RESPONSE_PREFIX[] = \"HTTP/1.0 \";",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "304: const Network::Address::InstanceConstSharedPtr& StreamEncoderImpl::connectionLocalAddress() {",
          "305:   return connection_.connection().localAddress();",
          "306: }",
          "",
          "---------------"
        ],
        "source/common/http/http1/codec_impl.h||source/common/http/http1/codec_impl.h": [
          "File: source/common/http/http1/codec_impl.h -> source/common/http/http1/codec_impl.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "61:   void readDisable(bool disable) override;",
          "62:   uint32_t bufferLimit() override;",
          "63:   absl::string_view responseDetails() override { return details_; }",
          "65:   void isResponseToHeadRequest(bool value) { is_response_to_head_request_ = value; }",
          "66:   void setDetails(absl::string_view details) { details_ = details; }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "64:   const Network::Address::InstanceConstSharedPtr& connectionLocalAddress() override;",
          "",
          "---------------"
        ],
        "source/common/http/http2/codec_impl.h||source/common/http/http2/codec_impl.h": [
          "File: source/common/http/http2/codec_impl.h -> source/common/http/http2/codec_impl.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "173:     void resetStream(StreamResetReason reason) override;",
          "174:     void readDisable(bool disable) override;",
          "175:     uint32_t bufferLimit() override { return pending_recv_data_.highWatermark(); }",
          "177:     void setWriteBufferWatermarks(uint32_t low_watermark, uint32_t high_watermark) {",
          "178:       pending_recv_data_.setWatermarks(low_watermark, high_watermark);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "176:     const Network::Address::InstanceConstSharedPtr& connectionLocalAddress() override {",
          "177:       return parent_.connection_.localAddress();",
          "178:     }",
          "",
          "---------------"
        ],
        "source/common/router/router.cc||source/common/router/router.cc": [
          "File: source/common/router/router.cc -> source/common/router/router.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "1616:   host->outlierDetector().putResult(Upstream::Outlier::Result::LocalOriginConnectSuccess);",
          "1619:   onUpstreamHostSelected(host);",
          "1620:   request_encoder.getStream().addCallbacks(*this);",
          "1622:   stream_info_.setUpstreamSslConnection(info.downstreamSslConnection());",
          "1623:   parent_.callbacks_->streamInfo().setUpstreamSslConnection(info.downstreamSslConnection());",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1621:   stream_info_.setUpstreamLocalAddress(request_encoder.getStream().connectionLocalAddress());",
          "1622:   parent_.callbacks_->streamInfo().setUpstreamLocalAddress(",
          "1623:       request_encoder.getStream().connectionLocalAddress());",
          "",
          "---------------"
        ],
        "source/extensions/quic_listeners/quiche/envoy_quic_stream.h||source/extensions/quic_listeners/quiche/envoy_quic_stream.h": [
          "File: source/extensions/quic_listeners/quiche/envoy_quic_stream.h -> source/extensions/quic_listeners/quiche/envoy_quic_stream.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "76:   }",
          "77:   void removeCallbacks(Http::StreamCallbacks& callbacks) override { removeCallbacks_(callbacks); }",
          "78:   uint32_t bufferLimit() override { return send_buffer_simulation_.highWatermark(); }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "79:   const Network::Address::InstanceConstSharedPtr& connectionLocalAddress() override {",
          "80:     return connection()->localAddress();",
          "81:   }",
          "",
          "---------------"
        ],
        "test/common/router/router_test.cc||test/common/router/router_test.cc": [
          "File: test/common/router/router_test.cc -> test/common/router/router_test.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "4374:     EXPECT_CALL(stream_, addCallbacks(_)).WillOnce(Invoke([&](Http::StreamCallbacks& callbacks) {",
          "4375:       stream_callbacks_ = &callbacks;",
          "4376:     }));",
          "4378:     EXPECT_CALL(cm_.conn_pool_, newStream(_, _))",
          "4379:         .WillOnce(Invoke(",
          "4380:             [&](Http::StreamDecoder& decoder,",
          "",
          "[Removed Lines]",
          "4377:     EXPECT_CALL(encoder_, getStream()).WillOnce(ReturnRef(stream_));",
          "",
          "[Added Lines]",
          "4377:     EXPECT_CALL(encoder_, getStream()).WillRepeatedly(ReturnRef(stream_));",
          "",
          "---------------"
        ],
        "test/common/router/router_upstream_log_test.cc||test/common/router/router_upstream_log_test.cc": [
          "File: test/common/router/router_upstream_log_test.cc -> test/common/router/router_upstream_log_test.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "43:   \"@type\": type.googleapis.com/envoy.config.accesslog.v2.FileAccessLog",
          "44:   format: \"%REQ(:METHOD)% %REQ(X-ENVOY-ORIGINAL-PATH?:PATH)% %PROTOCOL% %RESPONSE_CODE%",
          "45:     %RESPONSE_FLAGS% %BYTES_RECEIVED% %BYTES_SENT% %REQ(:AUTHORITY)% %UPSTREAM_HOST%",
          "47:   path: \"/dev/null\"",
          "48:   )EOF\";",
          "",
          "[Removed Lines]",
          "46:     %RESP(X-UPSTREAM-HEADER)% %TRAILER(X-TRAILER)%\\n\"",
          "",
          "[Added Lines]",
          "46:     %UPSTREAM_LOCAL_ADDRESS% %RESP(X-UPSTREAM-HEADER)% %TRAILER(X-TRAILER)%\\n\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "133:             [&](Http::StreamDecoder& decoder,",
          "134:                 Http::ConnectionPool::Callbacks& callbacks) -> Http::ConnectionPool::Cancellable* {",
          "135:               response_decoder = &decoder;",
          "136:               callbacks.onPoolReady(encoder, context_.cluster_manager_.conn_pool_.host_,",
          "137:                                     stream_info_);",
          "138:               return nullptr;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "136:               EXPECT_CALL(encoder.stream_, connectionLocalAddress())",
          "137:                   .WillRepeatedly(ReturnRef(upstream_local_address1_));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "161:   void runWithRetry() {",
          "162:     NiceMock<Http::MockStreamEncoder> encoder1;",
          "163:     Http::StreamDecoder* response_decoder = nullptr;",
          "164:     EXPECT_CALL(context_.cluster_manager_.conn_pool_, newStream(_, _))",
          "165:         .WillOnce(Invoke(",
          "166:             [&](Http::StreamDecoder& decoder,",
          "167:                 Http::ConnectionPool::Callbacks& callbacks) -> Http::ConnectionPool::Cancellable* {",
          "168:               response_decoder = &decoder;",
          "169:               callbacks.onPoolReady(encoder1, context_.cluster_manager_.conn_pool_.host_,",
          "170:                                     stream_info_);",
          "171:               return nullptr;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "172:               EXPECT_CALL(encoder1.stream_, connectionLocalAddress())",
          "173:                   .WillRepeatedly(ReturnRef(upstream_local_address1_));",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "193:               response_decoder = &decoder;",
          "194:               EXPECT_CALL(context_.cluster_manager_.conn_pool_.host_->outlier_detector_,",
          "195:                           putResult(Upstream::Outlier::Result::LocalOriginConnectSuccess, _));",
          "196:               callbacks.onPoolReady(encoder2, context_.cluster_manager_.conn_pool_.host_,",
          "197:                                     stream_info_);",
          "198:               return nullptr;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "201:               EXPECT_CALL(encoder2.stream_, connectionLocalAddress())",
          "202:                   .WillRepeatedly(ReturnRef(upstream_local_address2_));",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "215:   envoy::api::v2::core::Locality upstream_locality_;",
          "216:   Network::Address::InstanceConstSharedPtr host_address_{",
          "217:       Network::Utility::resolveUrl(\"tcp://10.0.0.5:9211\")};",
          "218:   Event::MockTimer* response_timeout_{};",
          "219:   Event::MockTimer* per_try_timeout_{};",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "225:   Network::Address::InstanceConstSharedPtr upstream_local_address1_{",
          "226:       Network::Utility::resolveUrl(\"tcp://10.0.0.5:10211\")};",
          "227:   Network::Address::InstanceConstSharedPtr upstream_local_address2_{",
          "228:       Network::Utility::resolveUrl(\"tcp://10.0.0.5:10212\")};",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "236:   run();",
          "238:   EXPECT_EQ(output_.size(), 1U);",
          "240: }",
          "242: TEST_F(RouterUpstreamLogTest, LogRetries) {",
          "",
          "[Removed Lines]",
          "239:   EXPECT_EQ(output_.front(), \"GET / HTTP/1.0 200 - 0 0 host 10.0.0.5:9211 - -\\n\");",
          "",
          "[Added Lines]",
          "250:   EXPECT_EQ(output_.front(), \"GET / HTTP/1.0 200 - 0 0 host 10.0.0.5:9211 10.0.0.5:10211 - -\\n\");",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "244:   runWithRetry();",
          "246:   EXPECT_EQ(output_.size(), 2U);",
          "249: }",
          "251: TEST_F(RouterUpstreamLogTest, LogFailure) {",
          "",
          "[Removed Lines]",
          "247:   EXPECT_EQ(output_.front(), \"GET / HTTP/1.0 0 UT 0 0 host 10.0.0.5:9211 - -\\n\");",
          "248:   EXPECT_EQ(output_.back(), \"GET / HTTP/1.0 200 - 0 0 host 10.0.0.5:9211 - -\\n\");",
          "",
          "[Added Lines]",
          "258:   EXPECT_EQ(output_.front(), \"GET / HTTP/1.0 0 UT 0 0 host 10.0.0.5:9211 10.0.0.5:10211 - -\\n\");",
          "259:   EXPECT_EQ(output_.back(), \"GET / HTTP/1.0 200 - 0 0 host 10.0.0.5:9211 10.0.0.5:10212 - -\\n\");",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "253:   run(503, {}, {}, {});",
          "255:   EXPECT_EQ(output_.size(), 1U);",
          "257: }",
          "259: TEST_F(RouterUpstreamLogTest, LogHeaders) {",
          "",
          "[Removed Lines]",
          "256:   EXPECT_EQ(output_.front(), \"GET / HTTP/1.0 503 - 0 0 host 10.0.0.5:9211 - -\\n\");",
          "",
          "[Added Lines]",
          "267:   EXPECT_EQ(output_.front(), \"GET / HTTP/1.0 503 - 0 0 host 10.0.0.5:9211 10.0.0.5:10211 - -\\n\");",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "262:       {{\"x-trailer\", \"value\"}});",
          "264:   EXPECT_EQ(output_.size(), 1U);",
          "266: }",
          "",
          "[Removed Lines]",
          "265:   EXPECT_EQ(output_.front(), \"GET /foo HTTP/1.0 200 - 0 0 host 10.0.0.5:9211 abcdef value\\n\");",
          "",
          "[Added Lines]",
          "276:   EXPECT_EQ(output_.front(),",
          "277:             \"GET /foo HTTP/1.0 200 - 0 0 host 10.0.0.5:9211 10.0.0.5:10211 abcdef value\\n\");",
          "",
          "---------------"
        ],
        "test/fuzz/common.proto||test/fuzz/common.proto": [
          "File: test/fuzz/common.proto -> test/fuzz/common.proto",
          "--- Hunk 1 ---",
          "[Context before]",
          "22:   envoy.api.v2.core.Metadata upstream_metadata = 4;",
          "23:   string requested_server_name = 5;",
          "24:   envoy.api.v2.core.Address address = 6;",
          "25: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "25:   envoy.api.v2.core.Address upstream_local_address = 7;",
          "",
          "---------------"
        ],
        "test/fuzz/utility.h||test/fuzz/utility.h": [
          "File: test/fuzz/utility.h -> test/fuzz/utility.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "138:   auto address = stream_info.has_address()",
          "139:                      ? Envoy::Network::Address::resolveProtoAddress(stream_info.address())",
          "140:                      : Network::Utility::resolveUrl(\"tcp://10.0.0.1:443\");",
          "142:   test_stream_info.downstream_local_address_ = address;",
          "143:   test_stream_info.downstream_direct_remote_address_ = address;",
          "144:   test_stream_info.downstream_remote_address_ = address;",
          "",
          "[Removed Lines]",
          "141:   test_stream_info.upstream_local_address_ = address;",
          "",
          "[Added Lines]",
          "141:   auto upstream_local_address =",
          "142:       stream_info.has_upstream_local_address()",
          "143:           ? Envoy::Network::Address::resolveProtoAddress(stream_info.upstream_local_address())",
          "144:           : Network::Utility::resolveUrl(\"tcp://10.0.0.1:10000\");",
          "145:   test_stream_info.upstream_local_address_ = upstream_local_address;",
          "",
          "---------------"
        ],
        "test/integration/integration_test.cc||test/integration/integration_test.cc": [
          "File: test/integration/integration_test.cc -> test/integration/integration_test.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "831:     address_string = \"::1\";",
          "832:   }",
          "833:   config_helper_.setSourceAddress(address_string);",
          "834:   initialize();",
          "836:   codec_client_ = makeHttpConnection(lookupPort(\"http\"));",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "834:   useAccessLog(\"%UPSTREAM_LOCAL_ADDRESS%\\n\");",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "851:   ASSERT_TRUE(upstream_request_->waitForEndStream(*dispatcher_));",
          "853:   cleanupUpstreamAndDownstream();",
          "854: }",
          "856: TEST_P(IntegrationTest, TestFailedBind) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "855:   EXPECT_THAT(waitForAccessLog(access_log_name_), HasSubstr(address_string));",
          "",
          "---------------"
        ],
        "test/mocks/http/stream.cc||test/mocks/http/stream.cc": [
          "File: test/mocks/http/stream.cc -> test/mocks/http/stream.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "3: using testing::_;",
          "4: using testing::Invoke;",
          "6: namespace Envoy {",
          "7: namespace Http {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5: using testing::ReturnRef;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "20:       callbacks->onResetStream(reason, absl::string_view());",
          "21:     }",
          "22:   }));",
          "23: }",
          "25: MockStream::~MockStream() = default;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "25:   ON_CALL(*this, connectionLocalAddress()).WillByDefault(ReturnRef(connection_local_address_));",
          "",
          "---------------"
        ],
        "test/mocks/http/stream.h||test/mocks/http/stream.h": [
          "File: test/mocks/http/stream.h -> test/mocks/http/stream.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "19:   MOCK_METHOD1(readDisable, void(bool disable));",
          "20:   MOCK_METHOD2(setWriteBufferWatermarks, void(uint32_t, uint32_t));",
          "21:   MOCK_METHOD0(bufferLimit, uint32_t());",
          "23:   std::list<StreamCallbacks*> callbacks_{};",
          "25:   void runHighWatermarkCallbacks() {",
          "26:     for (auto* callback : callbacks_) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "22:   MOCK_METHOD0(connectionLocalAddress, const Network::Address::InstanceConstSharedPtr&());",
          "25:   Network::Address::InstanceConstSharedPtr connection_local_address_;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "2187f1070a76a124a4d7cebe72551804b1a5218b",
      "candidate_info": {
        "commit_hash": "2187f1070a76a124a4d7cebe72551804b1a5218b",
        "repo": "envoyproxy/envoy",
        "commit_url": "https://github.com/envoyproxy/envoy/commit/2187f1070a76a124a4d7cebe72551804b1a5218b",
        "files": [
          "source/common/http/http1/BUILD",
          "source/common/http/http1/codec_impl.cc",
          "source/common/http/http1/codec_impl.h",
          "test/common/http/codec_impl_fuzz_test.cc",
          "test/common/http/http1/codec_impl_test.cc"
        ],
        "message": "http1: remove exceptions from H/1 codec (#11778)\n\nCommit Message:\nRemove all throw statements from H/1 codec\nThis change removed all uses of C++ exceptions from H/1 codec. I modeled the flow after Yan's H/2 work (#11575). Codec status are set in uniform helper methods. This is the only change from the previous PR (#11101), besides merging newer exceptions.\n\nThis change replaces all throw statements with a return of corresponding error Status and adds plumbing to return the status to codec callers. The dispatch() method returns the encountered error to the caller, which will be handled accordingly.\n\nThe calls to the RequestEncoder::encodeHeaders() NOT called from dispatch() method will RELEASE_ASSERT if an error code is returned. This does not alter the existing behavior of abnormally terminating the process, just the method of termination: RELEASE_ASSERT vs uncaught exception.\n\nRisk Level: High (Codec changes)\nSigned-off-by: Asra Ali <asraa@google.com>",
        "before_after_code_files": [
          "source/common/http/http1/codec_impl.cc||source/common/http/http1/codec_impl.cc",
          "source/common/http/http1/codec_impl.h||source/common/http/http1/codec_impl.h",
          "test/common/http/codec_impl_fuzz_test.cc||test/common/http/codec_impl_fuzz_test.cc",
          "test/common/http/http1/codec_impl_test.cc||test/common/http/http1/codec_impl_test.cc"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "source/common/http/http1/codec_impl.cc||source/common/http/http1/codec_impl.cc"
          ],
          "candidate": [
            "source/common/http/http1/codec_impl.cc||source/common/http/http1/codec_impl.cc"
          ]
        }
      },
      "candidate_diff": {
        "source/common/http/http1/codec_impl.cc||source/common/http/http1/codec_impl.cc": [
          "File: source/common/http/http1/codec_impl.cc -> source/common/http/http1/codec_impl.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "9: #include \"envoy/http/header_map.h\"",
          "10: #include \"envoy/network/connection.h\"",
          "12: #include \"common/common/enum_to_int.h\"",
          "13: #include \"common/common/utility.h\"",
          "14: #include \"common/grpc/common.h\"",
          "15: #include \"common/http/exception.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "12: #include \"common/common/cleanup.h\"",
          "14: #include \"common/common/statusor.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "275:   outbound_responses_++;",
          "276: }",
          "279:   if (!flood_protection_) {",
          "281:   }",
          "",
          "[Removed Lines]",
          "278: void ServerConnectionImpl::doFloodProtectionChecks() const {",
          "280:     return;",
          "",
          "[Added Lines]",
          "280: Status ServerConnectionImpl::doFloodProtectionChecks() const {",
          "281:   ASSERT(dispatching_);",
          "283:     return okStatus();",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "285:     ENVOY_CONN_LOG(trace, \"error accepting request: too many pending responses queued\",",
          "286:                    connection_);",
          "287:     stats_.response_flood_.inc();",
          "289:   }",
          "290: }",
          "292: void ConnectionImpl::flushOutput(bool end_encode) {",
          "",
          "[Removed Lines]",
          "288:     throw FrameFloodException(\"Too many responses queued.\");",
          "",
          "[Added Lines]",
          "291:     return bufferFloodError(\"Too many responses queued.\");",
          "293:   return okStatus();",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "372:   const HeaderEntry* host = headers.Host();",
          "373:   bool is_connect = HeaderUtility::isConnect(headers);",
          "381:   if (method->value() == Headers::get().MethodValues.Head) {",
          "382:     head_request_ = true;",
          "383:   } else if (method->value() == Headers::get().MethodValues.Connect) {",
          "",
          "[Removed Lines]",
          "375:   if (!method || (!path && !is_connect)) {",
          "379:     throw CodecClientException(\":method and :path must be specified\");",
          "380:   }",
          "",
          "[Added Lines]",
          "385:   RELEASE_ASSERT(method && (path || is_connect), \":method and :path must be specified\");",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "400:   encodeHeadersBase(headers, absl::nullopt, end_stream);",
          "401: }",
          "403: http_parser_settings ConnectionImpl::settings_{",
          "404:     [](http_parser* parser) -> int {",
          "407:     },",
          "408:     [](http_parser* parser, const char* at, size_t length) -> int {",
          "411:     },",
          "412:     nullptr, // on_status",
          "413:     [](http_parser* parser, const char* at, size_t length) -> int {",
          "416:     },",
          "417:     [](http_parser* parser, const char* at, size_t length) -> int {",
          "420:     },",
          "421:     [](http_parser* parser) -> int {",
          "423:     },",
          "424:     [](http_parser* parser, const char* at, size_t length) -> int {",
          "425:       static_cast<ConnectionImpl*>(parser->data)->bufferBody(at, length);",
          "426:       return 0;",
          "427:     },",
          "428:     [](http_parser* parser) -> int {",
          "431:     },",
          "432:     [](http_parser* parser) -> int {",
          "",
          "[Removed Lines]",
          "405:       static_cast<ConnectionImpl*>(parser->data)->onMessageBeginBase();",
          "406:       return 0;",
          "409:       static_cast<ConnectionImpl*>(parser->data)->onUrl(at, length);",
          "410:       return 0;",
          "414:       static_cast<ConnectionImpl*>(parser->data)->onHeaderField(at, length);",
          "415:       return 0;",
          "418:       static_cast<ConnectionImpl*>(parser->data)->onHeaderValue(at, length);",
          "419:       return 0;",
          "422:       return static_cast<ConnectionImpl*>(parser->data)->onHeadersCompleteBase();",
          "429:       static_cast<ConnectionImpl*>(parser->data)->onMessageCompleteBase();",
          "430:       return 0;",
          "",
          "[Added Lines]",
          "409: int ConnectionImpl::setAndCheckCallbackStatus(Status&& status) {",
          "410:   ASSERT(codec_status_.ok());",
          "411:   codec_status_ = std::move(status);",
          "412:   return codec_status_.ok() ? enumToInt(HttpParserCode::Success) : enumToInt(HttpParserCode::Error);",
          "413: }",
          "415: int ConnectionImpl::setAndCheckCallbackStatusOr(Envoy::StatusOr<int>&& statusor) {",
          "416:   ASSERT(codec_status_.ok());",
          "417:   if (statusor.ok()) {",
          "418:     return statusor.value();",
          "419:   } else {",
          "420:     codec_status_ = std::move(statusor.status());",
          "421:     return enumToInt(HttpParserCode::Error);",
          "422:   }",
          "423: }",
          "427:       auto* conn_impl = static_cast<ConnectionImpl*>(parser->data);",
          "428:       auto status = conn_impl->onMessageBeginBase();",
          "429:       return conn_impl->setAndCheckCallbackStatus(std::move(status));",
          "432:       auto* conn_impl = static_cast<ConnectionImpl*>(parser->data);",
          "433:       auto status = conn_impl->onUrl(at, length);",
          "434:       return conn_impl->setAndCheckCallbackStatus(std::move(status));",
          "438:       auto* conn_impl = static_cast<ConnectionImpl*>(parser->data);",
          "439:       auto status = conn_impl->onHeaderField(at, length);",
          "440:       return conn_impl->setAndCheckCallbackStatus(std::move(status));",
          "443:       auto* conn_impl = static_cast<ConnectionImpl*>(parser->data);",
          "444:       auto status = conn_impl->onHeaderValue(at, length);",
          "445:       return conn_impl->setAndCheckCallbackStatus(std::move(status));",
          "448:       auto* conn_impl = static_cast<ConnectionImpl*>(parser->data);",
          "449:       auto statusor = conn_impl->onHeadersCompleteBase();",
          "450:       return conn_impl->setAndCheckCallbackStatusOr(std::move(statusor));",
          "457:       auto* conn_impl = static_cast<ConnectionImpl*>(parser->data);",
          "458:       auto status = conn_impl->onMessageCompleteBase();",
          "459:       return conn_impl->setAndCheckCallbackStatus(std::move(status));",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "453:       enable_trailers_(enable_trailers),",
          "454:       strict_1xx_and_204_headers_(Runtime::runtimeFeatureEnabled(",
          "455:           \"envoy.reloadable_features.strict_1xx_and_204_response_headers\")),",
          "456:       output_buffer_([&]() -> void { this->onBelowLowWatermark(); },",
          "457:                      [&]() -> void { this->onAboveHighWatermark(); },",
          "458:                      []() -> void { /* TODO(adisuissa): Handle overflow watermark */ }),",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "485:       dispatching_(false),",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "462:   parser_.data = this;",
          "463: }",
          "466:   ENVOY_CONN_LOG(trace, \"completed header: key={} value={}\", connection_,",
          "467:                  current_header_field_.getStringView(), current_header_value_.getStringView());",
          "470:   auto& headers_or_trailers = headersOrTrailers();",
          "471:   if (!current_header_field_.empty()) {",
          "472:     current_header_field_.inlineTransform([](char c) { return absl::ascii_tolower(c); });",
          "",
          "[Removed Lines]",
          "465: void ConnectionImpl::completeLastHeader() {",
          "469:   checkHeaderNameForUnderscores();",
          "",
          "[Added Lines]",
          "495: Status ConnectionImpl::completeLastHeader() {",
          "496:   ASSERT(dispatching_);",
          "500:   RETURN_IF_ERROR(checkHeaderNameForUnderscores());",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "482:   if (headers_or_trailers.size() > max_headers_count_) {",
          "483:     error_code_ = Http::Code::RequestHeaderFieldsTooLarge;",
          "485:     const absl::string_view header_type =",
          "486:         processing_trailers_ ? Http1HeaderTypes::get().Trailers : Http1HeaderTypes::get().Headers;",
          "488:   }",
          "490:   header_parsing_state_ = HeaderParsingState::Field;",
          "491:   ASSERT(current_header_field_.empty());",
          "492:   ASSERT(current_header_value_.empty());",
          "493: }",
          "495: uint32_t ConnectionImpl::getHeadersSize() {",
          "",
          "[Removed Lines]",
          "484:     sendProtocolError(Http1ResponseCodeDetails::get().TooManyHeaders);",
          "487:     throw CodecProtocolException(absl::StrCat(header_type, \" size exceeds limit\"));",
          "",
          "[Added Lines]",
          "515:     RETURN_IF_ERROR(sendProtocolError(Http1ResponseCodeDetails::get().TooManyHeaders));",
          "518:     return codecProtocolError(absl::StrCat(header_type, \" size exceeds limit\"));",
          "524:   return okStatus();",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "497:          headersOrTrailers().byteSize();",
          "498: }",
          "501:   const uint32_t total = getHeadersSize();",
          "502:   if (total > (max_headers_kb_ * 1024)) {",
          "503:     const absl::string_view header_type =",
          "504:         processing_trailers_ ? Http1HeaderTypes::get().Trailers : Http1HeaderTypes::get().Headers;",
          "505:     error_code_ = Http::Code::RequestHeaderFieldsTooLarge;",
          "508:   }",
          "509: }",
          "511: bool ConnectionImpl::maybeDirectDispatch(Buffer::Instance& data) {",
          "",
          "[Removed Lines]",
          "500: void ConnectionImpl::checkMaxHeadersSize() {",
          "506:     sendProtocolError(Http1ResponseCodeDetails::get().HeadersTooLarge);",
          "507:     throw CodecProtocolException(absl::StrCat(header_type, \" size exceeds limit\"));",
          "",
          "[Added Lines]",
          "532: Status ConnectionImpl::checkMaxHeadersSize() {",
          "538:     RETURN_IF_ERROR(sendProtocolError(Http1ResponseCodeDetails::get().HeadersTooLarge));",
          "539:     return codecProtocolError(absl::StrCat(header_type, \" size exceeds limit\"));",
          "541:   return okStatus();",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "531: Http::Status ConnectionImpl::innerDispatch(Buffer::Instance& data) {",
          "532:   ENVOY_CONN_LOG(trace, \"parsing {} bytes\", connection_, data.length());",
          "533:   ASSERT(buffered_body_.length() == 0);",
          "535:   if (maybeDirectDispatch(data)) {",
          "536:     return Http::okStatus();",
          "537:   }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "568:   Cleanup cleanup([this]() { dispatching_ = false; });",
          "569:   ASSERT(!dispatching_);",
          "570:   ASSERT(codec_status_.ok());",
          "573:   dispatching_ = true;",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "542:   ssize_t total_parsed = 0;",
          "543:   if (data.length() > 0) {",
          "544:     for (const Buffer::RawSlice& slice : data.getRawSlices()) {",
          "546:       if (HTTP_PARSER_ERRNO(&parser_) != HPE_OK) {",
          "",
          "[Removed Lines]",
          "545:       total_parsed += dispatchSlice(static_cast<const char*>(slice.mem_), slice.len_);",
          "",
          "[Added Lines]",
          "584:       auto statusor_parsed = dispatchSlice(static_cast<const char*>(slice.mem_), slice.len_);",
          "585:       if (!statusor_parsed.ok()) {",
          "586:         return statusor_parsed.status();",
          "587:       }",
          "588:       total_parsed += statusor_parsed.value();",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "552:     }",
          "553:     dispatchBufferedBody();",
          "554:   } else {",
          "556:   }",
          "557:   ASSERT(buffered_body_.length() == 0);",
          "",
          "[Removed Lines]",
          "555:     dispatchSlice(nullptr, 0);",
          "",
          "[Added Lines]",
          "598:     auto result = dispatchSlice(nullptr, 0);",
          "599:     if (!result.ok()) {",
          "600:       return result.status();",
          "601:     }",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "565:   return Http::okStatus();",
          "566: }",
          "569:   ssize_t rc = http_parser_execute(&parser_, &settings_, slice, len);",
          "570:   if (HTTP_PARSER_ERRNO(&parser_) != HPE_OK && HTTP_PARSER_ERRNO(&parser_) != HPE_PAUSED) {",
          "574:   }",
          "576:   return rc;",
          "577: }",
          "582:   if (header_parsing_state_ == HeaderParsingState::Done) {",
          "583:     if (!enable_trailers_) {",
          "586:     }",
          "587:     processing_trailers_ = true;",
          "588:     header_parsing_state_ = HeaderParsingState::Field;",
          "589:     allocTrailers();",
          "590:   }",
          "591:   if (header_parsing_state_ == HeaderParsingState::Value) {",
          "593:   }",
          "595:   current_header_field_.append(data, length);",
          "598: }",
          "601:   if (header_parsing_state_ == HeaderParsingState::Done && !enable_trailers_) {",
          "604:   }",
          "606:   absl::string_view header_value{data, length};",
          "607:   if (!Http::HeaderUtility::headerValueIsValid(header_value)) {",
          "608:     ENVOY_CONN_LOG(debug, \"invalid header value: {}\", connection_, header_value);",
          "609:     error_code_ = Http::Code::BadRequest;",
          "612:   }",
          "614:   header_parsing_state_ = HeaderParsingState::Value;",
          "",
          "[Removed Lines]",
          "568: size_t ConnectionImpl::dispatchSlice(const char* slice, size_t len) {",
          "571:     sendProtocolError(Http1ResponseCodeDetails::get().HttpCodecError);",
          "572:     throw CodecProtocolException(\"http/1.1 protocol error: \" +",
          "573:                                  std::string(http_errno_name(HTTP_PARSER_ERRNO(&parser_))));",
          "579: void ConnectionImpl::onHeaderField(const char* data, size_t length) {",
          "585:       return;",
          "592:     completeLastHeader();",
          "597:   checkMaxHeadersSize();",
          "600: void ConnectionImpl::onHeaderValue(const char* data, size_t length) {",
          "603:     return;",
          "610:     sendProtocolError(Http1ResponseCodeDetails::get().InvalidCharacters);",
          "611:     throw CodecProtocolException(\"http/1.1 protocol error: header value contains invalid chars\");",
          "",
          "[Added Lines]",
          "614: Envoy::StatusOr<size_t> ConnectionImpl::dispatchSlice(const char* slice, size_t len) {",
          "615:   ASSERT(codec_status_.ok() && dispatching_);",
          "617:   if (!codec_status_.ok()) {",
          "618:     return codec_status_;",
          "619:   }",
          "621:     RETURN_IF_ERROR(sendProtocolError(Http1ResponseCodeDetails::get().HttpCodecError));",
          "623:     ASSERT(codec_status_.ok());",
          "624:     codec_status_ = codecProtocolError(",
          "625:         absl::StrCat(\"http/1.1 protocol error: \", http_errno_name(HTTP_PARSER_ERRNO(&parser_))));",
          "626:     return codec_status_;",
          "632: Status ConnectionImpl::onHeaderField(const char* data, size_t length) {",
          "633:   ASSERT(dispatching_);",
          "639:       return okStatus();",
          "646:     RETURN_IF_ERROR(completeLastHeader());",
          "651:   return checkMaxHeadersSize();",
          "654: Status ConnectionImpl::onHeaderValue(const char* data, size_t length) {",
          "655:   ASSERT(dispatching_);",
          "658:     return okStatus();",
          "665:     RETURN_IF_ERROR(sendProtocolError(Http1ResponseCodeDetails::get().InvalidCharacters));",
          "666:     return codecProtocolError(\"http/1.1 protocol error: header value contains invalid chars\");",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "621:   }",
          "622:   current_header_value_.append(header_value.data(), header_value.length());",
          "625: }",
          "628:   ASSERT(!processing_trailers_);",
          "629:   ENVOY_CONN_LOG(trace, \"onHeadersCompleteBase\", connection_);",
          "632:   if (!(parser_.http_major == 1 && parser_.http_minor == 1)) {",
          "",
          "[Removed Lines]",
          "624:   checkMaxHeadersSize();",
          "627: int ConnectionImpl::onHeadersCompleteBase() {",
          "630:   completeLastHeader();",
          "",
          "[Added Lines]",
          "679:   return checkMaxHeadersSize();",
          "682: Envoy::StatusOr<int> ConnectionImpl::onHeadersCompleteBase() {",
          "684:   ASSERT(dispatching_);",
          "686:   RETURN_IF_ERROR(completeLastHeader());",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "668:         error_code_ = Http::Code::BadRequest;",
          "671:       }",
          "672:     }",
          "673:     ENVOY_CONN_LOG(trace, \"codec entering upgrade mode for CONNECT request.\", connection_);",
          "",
          "[Removed Lines]",
          "669:         sendProtocolError(Http1ResponseCodeDetails::get().BodyDisallowed);",
          "670:         throw CodecProtocolException(\"http/1.1 protocol error: unsupported content length\");",
          "",
          "[Added Lines]",
          "725:         RETURN_IF_ERROR(sendProtocolError(Http1ResponseCodeDetails::get().BodyDisallowed));",
          "726:         return codecProtocolError(\"http/1.1 protocol error: unsupported content length\");",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "683:     if (!absl::EqualsIgnoreCase(encoding, Headers::get().TransferEncodingValues.Chunked) ||",
          "684:         parser_.method == HTTP_CONNECT) {",
          "685:       error_code_ = Http::Code::NotImplemented;",
          "688:     }",
          "689:   }",
          "692:   header_parsing_state_ = HeaderParsingState::Done;",
          "696: }",
          "698: void ConnectionImpl::bufferBody(const char* data, size_t length) {",
          "",
          "[Removed Lines]",
          "686:       sendProtocolError(Http1ResponseCodeDetails::get().InvalidTransferEncoding);",
          "687:       throw CodecProtocolException(\"http/1.1 protocol error: unsupported transfer encoding\");",
          "691:   int rc = onHeadersComplete();",
          "695:   return handling_upgrade_ ? 2 : rc;",
          "",
          "[Added Lines]",
          "742:       RETURN_IF_ERROR(sendProtocolError(Http1ResponseCodeDetails::get().InvalidTransferEncoding));",
          "743:       return codecProtocolError(\"http/1.1 protocol error: unsupported transfer encoding\");",
          "747:   auto statusor = onHeadersComplete();",
          "748:   if (!statusor.ok()) {",
          "749:     RETURN_IF_ERROR(statusor.status());",
          "750:   }",
          "755:   return handling_upgrade_ ? 2 : statusor.value();",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "702: void ConnectionImpl::dispatchBufferedBody() {",
          "703:   ASSERT(HTTP_PARSER_ERRNO(&parser_) == HPE_OK || HTTP_PARSER_ERRNO(&parser_) == HPE_PAUSED);",
          "704:   if (buffered_body_.length() > 0) {",
          "705:     onBody(buffered_body_);",
          "706:     buffered_body_.drain(buffered_body_.length());",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "764:   ASSERT(codec_status_.ok());",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "715:   }",
          "716: }",
          "719:   ENVOY_CONN_LOG(trace, \"message complete\", connection_);",
          "721:   dispatchBufferedBody();",
          "",
          "[Removed Lines]",
          "718: void ConnectionImpl::onMessageCompleteBase() {",
          "",
          "[Added Lines]",
          "779: Status ConnectionImpl::onMessageCompleteBase() {",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "726:     ASSERT(!deferred_end_stream_headers_);",
          "727:     ENVOY_CONN_LOG(trace, \"Pausing parser due to upgrade.\", connection_);",
          "728:     http_parser_pause(&parser_, 1);",
          "730:   }",
          "734:   if (header_parsing_state_ == HeaderParsingState::Value) {",
          "736:   }",
          "738:   onMessageComplete();",
          "739: }",
          "742:   ENVOY_CONN_LOG(trace, \"message begin\", connection_);",
          "",
          "[Removed Lines]",
          "729:     return;",
          "735:     completeLastHeader();",
          "741: void ConnectionImpl::onMessageBeginBase() {",
          "",
          "[Added Lines]",
          "790:     return okStatus();",
          "796:     RETURN_IF_ERROR(completeLastHeader());",
          "800:   return okStatus();",
          "803: Status ConnectionImpl::onMessageBeginBase() {",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "747:   processing_trailers_ = false;",
          "748:   header_parsing_state_ = HeaderParsingState::Field;",
          "749:   allocHeaders();",
          "751: }",
          "753: void ConnectionImpl::onResetStreamBase(StreamResetReason reason) {",
          "",
          "[Removed Lines]",
          "750:   onMessageBegin();",
          "",
          "[Added Lines]",
          "812:   return onMessageBegin();",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "795:   }",
          "796: }",
          "799:   HeaderString path(Headers::get().Path);",
          "801:   bool is_connect = (method == HTTP_CONNECT);",
          "",
          "[Removed Lines]",
          "798: void ServerConnectionImpl::handlePath(RequestHeaderMap& headers, unsigned int method) {",
          "",
          "[Added Lines]",
          "860: Status ServerConnectionImpl::handlePath(RequestHeaderMap& headers, unsigned int method) {",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "806:       (active_request.request_url_.getStringView()[0] == '/' ||",
          "807:        ((method == HTTP_OPTIONS) && active_request.request_url_.getStringView()[0] == '*'))) {",
          "808:     headers.addViaMove(std::move(path), std::move(active_request.request_url_));",
          "810:   }",
          "",
          "[Removed Lines]",
          "809:     return;",
          "",
          "[Added Lines]",
          "871:     return okStatus();",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "816:   if (!codec_settings_.allow_absolute_url_ && !is_connect) {",
          "817:     headers.addViaMove(std::move(path), std::move(active_request.request_url_));",
          "819:   }",
          "821:   Utility::Url absolute_url;",
          "822:   if (!absolute_url.initialize(active_request.request_url_.getStringView(), is_connect)) {",
          "825:   }",
          "",
          "[Removed Lines]",
          "818:     return;",
          "823:     sendProtocolError(Http1ResponseCodeDetails::get().InvalidUrl);",
          "824:     throw CodecProtocolException(\"http/1.1 protocol error: invalid url in request line\");",
          "",
          "[Added Lines]",
          "880:     return okStatus();",
          "885:     RETURN_IF_ERROR(sendProtocolError(Http1ResponseCodeDetails::get().InvalidUrl));",
          "886:     return codecProtocolError(\"http/1.1 protocol error: invalid url in request line\");",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "836:     headers.setPath(absolute_url.pathAndQueryParams());",
          "837:   }",
          "838:   active_request.request_url_.clear();",
          "839: }",
          "",
          "[Removed Lines]",
          "841: int ServerConnectionImpl::onHeadersComplete() {",
          "",
          "[Added Lines]",
          "901:   return okStatus();",
          "904: Envoy::StatusOr<int> ServerConnectionImpl::onHeadersComplete() {",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "855:         ENVOY_CONN_LOG(debug, \"Invalid nominated headers in Connection: {}\", connection_,",
          "856:                        header_value);",
          "857:         error_code_ = Http::Code::BadRequest;",
          "860:       }",
          "861:     }",
          "",
          "[Removed Lines]",
          "858:         sendProtocolError(Http1ResponseCodeDetails::get().ConnectionHeaderSanitization);",
          "859:         throw CodecProtocolException(\"Invalid nominated headers in Connection.\");",
          "",
          "[Added Lines]",
          "921:         RETURN_IF_ERROR(",
          "922:             sendProtocolError(Http1ResponseCodeDetails::get().ConnectionHeaderSanitization));",
          "923:         return codecProtocolError(\"Invalid nominated headers in Connection.\");",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "865:     active_request.response_encoder_.setIsResponseToHeadRequest(parser_.method == HTTP_HEAD);",
          "866:     active_request.response_encoder_.setIsResponseToConnectRequest(parser_.method == HTTP_CONNECT);",
          "869:     ASSERT(active_request.request_url_.empty());",
          "871:     headers->setMethod(method_string);",
          "",
          "[Removed Lines]",
          "868:     handlePath(*headers, parser_.method);",
          "",
          "[Added Lines]",
          "932:     RETURN_IF_ERROR(handlePath(*headers, parser_.method));",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "874:     auto details = HeaderUtility::requestHeadersValid(*headers);",
          "875:     if (details.has_value()) {",
          "878:           \"http/1.1 protocol error: request headers failed spec compliance checks\");",
          "879:     }",
          "",
          "[Removed Lines]",
          "876:       sendProtocolError(details.value().get());",
          "877:       throw CodecProtocolException(",
          "",
          "[Added Lines]",
          "940:       RETURN_IF_ERROR(sendProtocolError(details.value().get()));",
          "941:       return codecProtocolError(",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "901:   return 0;",
          "902: }",
          "905:   if (!resetStreamCalled()) {",
          "906:     ASSERT(!active_request_.has_value());",
          "907:     active_request_.emplace(*this, header_key_formatter_.get());",
          "908:     auto& active_request = active_request_.value();",
          "909:     active_request.request_decoder_ = &callbacks_.newStream(active_request.response_encoder_);",
          "915:   }",
          "916: }",
          "919:   if (active_request_.has_value()) {",
          "920:     active_request_.value().request_url_.append(data, length);",
          "923:   }",
          "924: }",
          "926: void ServerConnectionImpl::onBody(Buffer::Instance& data) {",
          "",
          "[Removed Lines]",
          "904: void ServerConnectionImpl::onMessageBegin() {",
          "914:     doFloodProtectionChecks();",
          "918: void ServerConnectionImpl::onUrl(const char* data, size_t length) {",
          "922:     checkMaxHeadersSize();",
          "",
          "[Added Lines]",
          "968: Status ServerConnectionImpl::onMessageBegin() {",
          "973:     if (resetStreamCalled()) {",
          "974:       return codecClientError(\"cannot create new streams after calling reset\");",
          "975:     }",
          "981:     RETURN_IF_ERROR(doFloodProtectionChecks());",
          "983:   return okStatus();",
          "986: Status ServerConnectionImpl::onUrl(const char* data, size_t length) {",
          "990:     RETURN_IF_ERROR(checkMaxHeadersSize());",
          "992:   return okStatus();",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "985:   }",
          "986: }",
          "989:   if (!Runtime::runtimeFeatureEnabled(\"envoy.reloadable_features.early_errors_via_hcm\")) {",
          "990:     sendProtocolErrorOld(details);",
          "992:   }",
          "994:   if (!active_request_.has_value()) {",
          "996:   }",
          "997:   ASSERT(active_request_.has_value());",
          "",
          "[Removed Lines]",
          "988: void ServerConnectionImpl::sendProtocolError(absl::string_view details) {",
          "991:     return;",
          "995:     onMessageBeginBase();",
          "",
          "[Added Lines]",
          "1057: Status ServerConnectionImpl::sendProtocolError(absl::string_view details) {",
          "1060:     return okStatus();",
          "1064:     RETURN_IF_ERROR(onMessageBeginBase());",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "1009:     active_request_->request_decoder_->sendLocalReply(is_grpc_request, error_code_,",
          "1010:                                                       CodeUtility::toString(error_code_), nullptr,",
          "1011:                                                       absl::nullopt, details);",
          "1013:   }",
          "1014: }",
          "1016: void ServerConnectionImpl::onAboveHighWatermark() {",
          "",
          "[Removed Lines]",
          "1012:     return;",
          "",
          "[Added Lines]",
          "1082:   return okStatus();",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "1031:   delete fragment;",
          "1032: }",
          "1035:   if (headers_with_underscores_action_ != envoy::config::core::v3::HttpProtocolOptions::ALLOW &&",
          "1036:       Http::HeaderUtility::headerNameContainsUnderscore(current_header_field_.getStringView())) {",
          "1037:     if (headers_with_underscores_action_ ==",
          "",
          "[Removed Lines]",
          "1034: void ServerConnectionImpl::checkHeaderNameForUnderscores() {",
          "",
          "[Added Lines]",
          "1103: Status ServerConnectionImpl::checkHeaderNameForUnderscores() {",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "1045:       ENVOY_CONN_LOG(debug, \"Rejecting request due to header name with underscores: {}\",",
          "1046:                      connection_, current_header_field_.getStringView());",
          "1047:       error_code_ = Http::Code::BadRequest;",
          "1049:       stats_.requests_rejected_with_underscores_in_headers_.inc();",
          "1051:     }",
          "1052:   }",
          "1053: }",
          "1055: ClientConnectionImpl::ClientConnectionImpl(Network::Connection& connection, CodecStats& stats,",
          "",
          "[Removed Lines]",
          "1048:       sendProtocolError(Http1ResponseCodeDetails::get().InvalidUnderscore);",
          "1050:       throw CodecProtocolException(\"http/1.1 protocol error: header name contains underscores\");",
          "",
          "[Added Lines]",
          "1117:       RETURN_IF_ERROR(sendProtocolError(Http1ResponseCodeDetails::get().InvalidUnderscore));",
          "1119:       return codecProtocolError(\"http/1.1 protocol error: header name contains underscores\");",
          "1122:   return okStatus();",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "1071: }",
          "1073: RequestEncoder& ClientConnectionImpl::newStream(ResponseDecoder& response_decoder) {",
          "1080:   ASSERT(connection_.readEnabled());",
          "",
          "[Removed Lines]",
          "1074:   if (resetStreamCalled()) {",
          "1075:     throw CodecClientException(\"cannot create new streams after calling reset\");",
          "1076:   }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 34 ---",
          "[Context before]",
          "1086:   return pending_response_.value().encoder_;",
          "1087: }",
          "1090:   ENVOY_CONN_LOG(trace, \"status_code {}\", connection_, parser_.status_code);",
          "1095:   if (!pending_response_.has_value() && !resetStreamCalled()) {",
          "1097:   } else if (pending_response_.has_value()) {",
          "1098:     ASSERT(!pending_response_done_);",
          "1099:     auto& headers = absl::get<ResponseHeaderMapPtr>(headers_or_trailers_);",
          "",
          "[Removed Lines]",
          "1089: int ClientConnectionImpl::onHeadersComplete() {",
          "1096:     throw PrematureResponseException(static_cast<Http::Code>(parser_.status_code));",
          "",
          "[Added Lines]",
          "1155: Envoy::StatusOr<int> ClientConnectionImpl::onHeadersComplete() {",
          "1162:     return prematureResponseError(\"\", static_cast<Http::Code>(parser_.status_code));",
          "",
          "---------------",
          "--- Hunk 35 ---",
          "[Context before]",
          "1110:       if (headers->TransferEncoding() &&",
          "1111:           absl::EqualsIgnoreCase(headers->TransferEncoding()->value().getStringView(),",
          "1112:                                  Headers::get().TransferEncodingValues.Chunked)) {",
          "1115:       }",
          "1116:     }",
          "1118:     if (strict_1xx_and_204_headers_ && (parser_.status_code < 200 || parser_.status_code == 204)) {",
          "1119:       if (headers->TransferEncoding()) {",
          "1122:             \"http/1.1 protocol error: transfer encoding not allowed in 1xx or 204\");",
          "1123:       }",
          "1125:       if (headers->ContentLength()) {",
          "1127:         if (headers->ContentLength()->value().getStringView() != \"0\") {",
          "1130:               \"http/1.1 protocol error: content length not allowed in 1xx or 204\");",
          "1131:         }",
          "",
          "[Removed Lines]",
          "1113:         sendProtocolError(Http1ResponseCodeDetails::get().InvalidTransferEncoding);",
          "1114:         throw CodecProtocolException(\"http/1.1 protocol error: unsupported transfer encoding\");",
          "1120:         sendProtocolError(Http1ResponseCodeDetails::get().TransferEncodingNotAllowed);",
          "1121:         throw CodecProtocolException(",
          "1128:           sendProtocolError(Http1ResponseCodeDetails::get().ContentLengthNotAllowed);",
          "1129:           throw CodecProtocolException(",
          "",
          "[Added Lines]",
          "1179:         RETURN_IF_ERROR(sendProtocolError(Http1ResponseCodeDetails::get().InvalidTransferEncoding));",
          "1180:         return codecProtocolError(\"http/1.1 protocol error: unsupported transfer encoding\");",
          "1186:         RETURN_IF_ERROR(",
          "1187:             sendProtocolError(Http1ResponseCodeDetails::get().TransferEncodingNotAllowed));",
          "1188:         return codecProtocolError(",
          "1195:           RETURN_IF_ERROR(",
          "1196:               sendProtocolError(Http1ResponseCodeDetails::get().ContentLengthNotAllowed));",
          "1197:           return codecProtocolError(",
          "",
          "---------------",
          "--- Hunk 36 ---",
          "[Context before]",
          "1215:   }",
          "1216: }",
          "1219:   if (pending_response_.has_value()) {",
          "1220:     ASSERT(!pending_response_done_);",
          "1221:     pending_response_.value().encoder_.setDetails(details);",
          "1222:   }",
          "1223: }",
          "1225: void ClientConnectionImpl::onAboveHighWatermark() {",
          "",
          "[Removed Lines]",
          "1218: void ClientConnectionImpl::sendProtocolError(absl::string_view details) {",
          "",
          "[Added Lines]",
          "1286: Status ClientConnectionImpl::sendProtocolError(absl::string_view details) {",
          "1291:   return okStatus();",
          "",
          "---------------"
        ],
        "source/common/http/http1/codec_impl.h||source/common/http/http1/codec_impl.h": [
          "File: source/common/http/http1/codec_impl.h -> source/common/http/http1/codec_impl.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "218:   bool strict1xxAnd204Headers() { return strict_1xx_and_204_headers_; }",
          "220: protected:",
          "221:   ConnectionImpl(Network::Connection& connection, CodecStats& stats, http_parser_type type,",
          "222:                  uint32_t max_headers_kb, const uint32_t max_headers_count,",
          "223:                  HeaderKeyFormatterPtr&& header_key_formatter, bool enable_trailers);",
          "225:   bool resetStreamCalled() { return reset_stream_called_; }",
          "",
          "[Removed Lines]",
          "226:   void onMessageBeginBase();",
          "",
          "[Added Lines]",
          "220:   int setAndCheckCallbackStatus(Status&& status);",
          "221:   int setAndCheckCallbackStatusOr(Envoy::StatusOr<int>&& statusor);",
          "225:   Envoy::Http::Status codec_status_;",
          "236:   enum class HttpParserCode {",
          "240:     Error = -1,",
          "241:     Success = 0,",
          "244:     NoBody = 1,",
          "247:     NoBodyData = 2,",
          "248:   };",
          "251:   Status onMessageBeginBase();",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "242:   Network::Connection& connection_;",
          "243:   CodecStats& stats_;",
          "",
          "[Removed Lines]",
          "240:   void checkMaxHeadersSize();",
          "",
          "[Added Lines]",
          "265:   Status checkMaxHeadersSize();",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "256:   const bool connection_header_sanitization_ : 1;",
          "257:   const bool enable_trailers_ : 1;",
          "258:   const bool strict_1xx_and_204_headers_ : 1;",
          "260: private:",
          "261:   enum class HeaderParsingState { Field, Value, Done };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "284:   bool dispatching_ : 1;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "271:   void completeLastHeader();",
          "",
          "[Added Lines]",
          "298:   Status completeLastHeader();",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "299:   size_t dispatchSlice(const char* slice, size_t len);",
          "",
          "[Added Lines]",
          "326:   Envoy::StatusOr<size_t> dispatchSlice(const char* slice, size_t len);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "317:   virtual void onMessageBegin() PURE;",
          "324:   virtual void onUrl(const char* data, size_t length) PURE;",
          "331:   void onHeaderField(const char* data, size_t length);",
          "338:   void onHeaderValue(const char* data, size_t length);",
          "346:   int onHeadersCompleteBase();",
          "347:   virtual int onHeadersComplete() PURE;",
          "",
          "[Added Lines]",
          "344:   virtual Status onMessageBegin() PURE;",
          "351:   virtual Status onUrl(const char* data, size_t length) PURE;",
          "359:   Status onHeaderField(const char* data, size_t length);",
          "367:   Status onHeaderValue(const char* data, size_t length);",
          "375:   Envoy::StatusOr<int> onHeadersCompleteBase();",
          "376:   virtual Envoy::StatusOr<int> onHeadersComplete() PURE;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "370:   virtual void onMessageComplete() PURE;",
          "",
          "[Removed Lines]",
          "369:   void onMessageCompleteBase();",
          "",
          "[Added Lines]",
          "399:   Status onMessageCompleteBase();",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "385:   virtual void sendProtocolError(absl::string_view details) PURE;",
          "",
          "[Added Lines]",
          "415:   virtual Status sendProtocolError(absl::string_view details) PURE;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "405:   static http_parser_settings settings_;",
          "",
          "[Removed Lines]",
          "403:   virtual void checkHeaderNameForUnderscores() {}",
          "",
          "[Added Lines]",
          "434:   virtual Status checkHeaderNameForUnderscores() { return okStatus(); }",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "461:   void onEncodeComplete() override;",
          "466:   bool upgradeAllowed() const override { return true; }",
          "467:   void onBody(Buffer::Instance& data) override;",
          "468:   void onResetStream(StreamResetReason reason) override;",
          "470:   void onAboveHighWatermark() override;",
          "471:   void onBelowLowWatermark() override;",
          "472:   HeaderMap& headersOrTrailers() override {",
          "",
          "[Removed Lines]",
          "458:   void handlePath(RequestHeaderMap& headers, unsigned int method);",
          "462:   void onMessageBegin() override;",
          "463:   void onUrl(const char* data, size_t length) override;",
          "464:   int onHeadersComplete() override;",
          "469:   void sendProtocolError(absl::string_view details) override;",
          "",
          "[Added Lines]",
          "490:   Status handlePath(RequestHeaderMap& headers, unsigned int method);",
          "494:   Status onMessageBegin() override;",
          "495:   Status onUrl(const char* data, size_t length) override;",
          "496:   Envoy::StatusOr<int> onHeadersComplete() override;",
          "501:   Status sendProtocolError(absl::string_view details) override;",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "496:   void releaseOutboundResponse(const Buffer::OwnedBufferFragmentImpl* fragment);",
          "497:   void maybeAddSentinelBufferFragment(Buffer::WatermarkBuffer& output_buffer) override;",
          "501:   ServerConnectionCallbacks& callbacks_;",
          "502:   absl::optional<ActiveRequest> active_request_;",
          "",
          "[Removed Lines]",
          "498:   void doFloodProtectionChecks() const;",
          "499:   void checkHeaderNameForUnderscores() override;",
          "",
          "[Added Lines]",
          "530:   Status doFloodProtectionChecks() const;",
          "531:   Status checkHeaderNameForUnderscores() override;",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "547:   void onEncodeComplete() override {}",
          "551:   bool upgradeAllowed() const override;",
          "552:   void onBody(Buffer::Instance& data) override;",
          "553:   void onMessageComplete() override;",
          "554:   void onResetStream(StreamResetReason reason) override;",
          "556:   void onAboveHighWatermark() override;",
          "557:   void onBelowLowWatermark() override;",
          "558:   HeaderMap& headersOrTrailers() override {",
          "",
          "[Removed Lines]",
          "548:   void onMessageBegin() override {}",
          "549:   void onUrl(const char*, size_t) override { NOT_IMPLEMENTED_GCOVR_EXCL_LINE; }",
          "550:   int onHeadersComplete() override;",
          "555:   void sendProtocolError(absl::string_view details) override;",
          "",
          "[Added Lines]",
          "580:   Status onMessageBegin() override { return okStatus(); }",
          "581:   Status onUrl(const char*, size_t) override { NOT_IMPLEMENTED_GCOVR_EXCL_LINE; }",
          "582:   Envoy::StatusOr<int> onHeadersComplete() override;",
          "587:   Status sendProtocolError(absl::string_view details) override;",
          "",
          "---------------"
        ],
        "test/common/http/codec_impl_fuzz_test.cc||test/common/http/codec_impl_fuzz_test.cc": [
          "File: test/common/http/codec_impl_fuzz_test.cc -> test/common/http/codec_impl_fuzz_test.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "50: TestRequestHeaderMapImpl",
          "51: fromSanitizedHeaders<TestRequestHeaderMapImpl>(const test::fuzz::Headers& headers) {",
          "52:   return Fuzz::fromHeaders<TestRequestHeaderMapImpl>(headers, {\"transfer-encoding\"},",
          "54: }",
          "",
          "[Removed Lines]",
          "53:                                                      {\":authority\"});",
          "",
          "[Added Lines]",
          "53:                                                      {\":authority\", \":method\", \":path\"});",
          "",
          "---------------"
        ],
        "test/common/http/http1/codec_impl_test.cc||test/common/http/http1/codec_impl_test.cc": [
          "File: test/common/http/http1/codec_impl_test.cc -> test/common/http/http1/codec_impl_test.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "68: class Http1ServerConnectionImplTest : public Http1CodecTestBase,",
          "69:                                       public testing::TestWithParam<bool> {",
          "70: public:",
          "71:   void initialize() {",
          "73:       codec_ = std::make_unique<Http1::ServerConnectionImpl>(",
          "74:           connection_, http1CodecStats(), callbacks_, codec_settings_, max_request_headers_kb_,",
          "75:           max_request_headers_count_, headers_with_underscores_action_);",
          "",
          "[Removed Lines]",
          "72:     if (GetParam()) {",
          "",
          "[Added Lines]",
          "71:   bool testingNewCodec() { return GetParam(); }",
          "74:     if (testingNewCodec()) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "136:   if (allow_absolute_url) {",
          "137:     codec_settings_.allow_absolute_url_ = allow_absolute_url;",
          "139:       codec_ = std::make_unique<Http1::ServerConnectionImpl>(",
          "140:           connection_, http1CodecStats(), callbacks_, codec_settings_, max_request_headers_kb_,",
          "141:           max_request_headers_count_, envoy::config::core::v3::HttpProtocolOptions::ALLOW);",
          "",
          "[Removed Lines]",
          "138:     if (GetParam()) {",
          "",
          "[Added Lines]",
          "140:     if (testingNewCodec()) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "172:   if (allow_absolute_url) {",
          "173:     codec_settings_.allow_absolute_url_ = allow_absolute_url;",
          "175:       codec_ = std::make_unique<Http1::ServerConnectionImpl>(",
          "176:           connection_, http1CodecStats(), callbacks_, codec_settings_, max_request_headers_kb_,",
          "177:           max_request_headers_count_, envoy::config::core::v3::HttpProtocolOptions::ALLOW);",
          "",
          "[Removed Lines]",
          "174:     if (GetParam()) {",
          "",
          "[Added Lines]",
          "176:     if (testingNewCodec()) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "199:   if (enable_trailers) {",
          "200:     codec_settings_.enable_trailers_ = enable_trailers;",
          "202:       codec_ = std::make_unique<Http1::ServerConnectionImpl>(",
          "203:           connection_, http1CodecStats(), callbacks_, codec_settings_, max_request_headers_kb_,",
          "204:           max_request_headers_count_, envoy::config::core::v3::HttpProtocolOptions::ALLOW);",
          "",
          "[Removed Lines]",
          "201:     if (GetParam()) {",
          "",
          "[Added Lines]",
          "203:     if (testingNewCodec()) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "240:   initialize();",
          "242:   codec_settings_.enable_trailers_ = enable_trailers;",
          "244:     codec_ = std::make_unique<Http1::ServerConnectionImpl>(",
          "245:         connection_, http1CodecStats(), callbacks_, codec_settings_, max_request_headers_kb_,",
          "246:         max_request_headers_count_, envoy::config::core::v3::HttpProtocolOptions::ALLOW);",
          "",
          "[Removed Lines]",
          "243:   if (GetParam()) {",
          "",
          "[Added Lines]",
          "245:   if (testingNewCodec()) {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1841: class Http1ClientConnectionImplTest : public Http1CodecTestBase,",
          "1842:                                       public testing::TestWithParam<bool> {",
          "1843: public:",
          "1844:   void initialize() {",
          "1846:       codec_ = std::make_unique<Http1::ClientConnectionImpl>(",
          "1847:           connection_, http1CodecStats(), callbacks_, codec_settings_, max_response_headers_count_);",
          "1848:     } else {",
          "",
          "[Removed Lines]",
          "1845:     if (GetParam()) {",
          "",
          "[Added Lines]",
          "1846:   bool testingNewCodec() { return GetParam(); }",
          "1849:     if (testingNewCodec()) {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1852:   }",
          "1854:   void readDisableOnRequestEncoder(RequestEncoder* request_encoder, bool disable) {",
          "1856:       dynamic_cast<Http1::RequestEncoderImpl*>(request_encoder)->readDisable(disable);",
          "1857:     } else {",
          "1858:       dynamic_cast<Legacy::Http1::RequestEncoderImpl*>(request_encoder)->readDisable(disable);",
          "",
          "[Removed Lines]",
          "1855:     if (GetParam()) {",
          "",
          "[Added Lines]",
          "1859:     if (testingNewCodec()) {",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "2239:   NiceMock<MockResponseDecoder> response_decoder;",
          "2242:   Http::RequestEncoder& request_encoder = codec_->newStream(response_decoder);",
          "2247: }",
          "2249: TEST_P(Http1ClientConnectionImplTest, NoContentLengthResponse) {",
          "",
          "[Removed Lines]",
          "2243:   EXPECT_THROW(request_encoder.encodeHeaders(TestRequestHeaderMapImpl{{\":path\", \"/\"}}, true),",
          "2244:                CodecClientException);",
          "2245:   EXPECT_THROW(request_encoder.encodeHeaders(TestRequestHeaderMapImpl{{\":method\", \"GET\"}}, true),",
          "2246:                CodecClientException);",
          "",
          "[Added Lines]",
          "2251:   if (testingNewCodec()) {",
          "2252:     EXPECT_DEATH(request_encoder.encodeHeaders(TestRequestHeaderMapImpl{{\":path\", \"/\"}}, true),",
          "2253:                  \":method and :path must be specified\");",
          "2254:     EXPECT_DEATH(request_encoder.encodeHeaders(TestRequestHeaderMapImpl{{\":method\", \"GET\"}}, true),",
          "2255:                  \":method and :path must be specified\");",
          "2256:   } else {",
          "2257:     EXPECT_THROW(request_encoder.encodeHeaders(TestRequestHeaderMapImpl{{\":path\", \"/\"}}, true),",
          "2258:                  CodecClientException);",
          "2259:     EXPECT_THROW(request_encoder.encodeHeaders(TestRequestHeaderMapImpl{{\":method\", \"GET\"}}, true),",
          "2260:                  CodecClientException);",
          "2261:   }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2013-4358",
  "cve_desc": "libavcodec/h264.c in FFmpeg before 0.11.4 allows remote attackers to cause a denial of service (crash) via vectors related to alternating bit depths in H.264 data.",
  "repo": "FFmpeg/FFmpeg",
  "patch_hash": "072be3e8969f24113d599444be4d6a0ed04a6602",
  "patch_info": {
    "commit_hash": "072be3e8969f24113d599444be4d6a0ed04a6602",
    "repo": "FFmpeg/FFmpeg",
    "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/072be3e8969f24113d599444be4d6a0ed04a6602",
    "files": [
      "libavcodec/h264.c",
      "libavcodec/h264.h",
      "libavcodec/h264_ps.c"
    ],
    "message": "h264: set parameters from SPS whenever it changes\n\nFixes a crash in the fuzzed sample sample_varPAR.avi_s26638 with\nalternating bit depths.",
    "before_after_code_files": [
      "libavcodec/h264.c||libavcodec/h264.c",
      "libavcodec/h264.h||libavcodec/h264.h",
      "libavcodec/h264_ps.c||libavcodec/h264_ps.c"
    ]
  },
  "patch_diff": {
    "libavcodec/h264.c||libavcodec/h264.c": [
      "File: libavcodec/h264.c -> libavcodec/h264.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "2340:     return profile;",
      "2341: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2343: static int h264_set_parameter_from_sps(H264Context *h)",
      "2344: {",
      "2345:     MpegEncContext *s = &h->s;",
      "2347:     if (s->flags & CODEC_FLAG_LOW_DELAY ||",
      "2348:         (h->sps.bitstream_restriction_flag &&",
      "2349:          !h->sps.num_reorder_frames)) {",
      "2350:         if (s->avctx->has_b_frames > 1 || h->delayed_pic[0])",
      "2351:             av_log(h->s.avctx, AV_LOG_WARNING, \"Delayed frames seen. \"",
      "2352:                    \"Reenabling low delay requires a codec flush.\\n\");",
      "2353:         else",
      "2354:             s->low_delay = 1;",
      "2355:     }",
      "2357:     if (s->avctx->has_b_frames < 2)",
      "2358:         s->avctx->has_b_frames = !s->low_delay;",
      "2360:     if (s->avctx->bits_per_raw_sample != h->sps.bit_depth_luma ||",
      "2361:         h->cur_chroma_format_idc      != h->sps.chroma_format_idc) {",
      "2362:         if (s->avctx->codec &&",
      "2363:             s->avctx->codec->capabilities & CODEC_CAP_HWACCEL_VDPAU &&",
      "2364:             (h->sps.bit_depth_luma != 8 || h->sps.chroma_format_idc > 1)) {",
      "2365:             av_log(s->avctx, AV_LOG_ERROR,",
      "2366:                    \"VDPAU decoding does not support video colorspace.\\n\");",
      "2367:             return AVERROR_INVALIDDATA;",
      "2368:         }",
      "2369:         if (h->sps.bit_depth_luma >= 8 && h->sps.bit_depth_luma <= 10) {",
      "2370:             s->avctx->bits_per_raw_sample = h->sps.bit_depth_luma;",
      "2371:             h->cur_chroma_format_idc      = h->sps.chroma_format_idc;",
      "2372:             h->pixel_shift                = h->sps.bit_depth_luma > 8;",
      "2374:             ff_h264dsp_init(&h->h264dsp, h->sps.bit_depth_luma,",
      "2375:                             h->sps.chroma_format_idc);",
      "2376:             ff_h264_pred_init(&h->hpc, s->codec_id, h->sps.bit_depth_luma,",
      "2377:                               h->sps.chroma_format_idc);",
      "2378:             s->dsp.dct_bits = h->sps.bit_depth_luma > 8 ? 32 : 16;",
      "2379:             ff_dsputil_init(&s->dsp, s->avctx);",
      "2380:         } else {",
      "2381:             av_log(s->avctx, AV_LOG_ERROR, \"Unsupported bit depth: %d\\n\",",
      "2382:                    h->sps.bit_depth_luma);",
      "2383:             return AVERROR_INVALIDDATA;",
      "2384:         }",
      "2385:     }",
      "2386:     return 0;",
      "2387: }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "2356:     MpegEncContext *const s0 = &h0->s;",
      "2357:     unsigned int first_mb_in_slice;",
      "2358:     unsigned int pps_id;",
      "2360:     unsigned int slice_type, tmp, i, j;",
      "2361:     int default_ref_list_done = 0;",
      "2362:     int last_pic_structure, last_pic_droppable;",
      "",
      "[Removed Lines]",
      "2359:     int num_ref_idx_active_override_flag, max_refs;",
      "",
      "[Added Lines]",
      "2405:     int num_ref_idx_active_override_flag, max_refs, ret;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "2432:                h->pps.sps_id);",
      "2433:         return -1;",
      "2434:     }",
      "2437:     s->avctx->profile = ff_h264_get_profile(&h->sps);",
      "2438:     s->avctx->level   = h->sps.level_idc;",
      "",
      "[Removed Lines]",
      "2435:     h->sps = *h0->sps_buffers[h->pps.sps_id];",
      "",
      "[Added Lines]",
      "2482:     if (h->pps.sps_id != h->current_sps_id ||",
      "2483:         h0->sps_buffers[h->pps.sps_id]->new) {",
      "2484:         h0->sps_buffers[h->pps.sps_id]->new = 0;",
      "2486:         h->current_sps_id = h->pps.sps_id;",
      "2487:         h->sps            = *h0->sps_buffers[h->pps.sps_id];",
      "2489:         if ((ret = h264_set_parameter_from_sps(h)) < 0)",
      "2490:             return ret;",
      "2491:     }",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "3878:                     ff_h264_decode_seq_parameter_set(h);",
      "3879:                 }",
      "3926:                 }",
      "3927:                 break;",
      "3928:             case NAL_PPS:",
      "",
      "[Removed Lines]",
      "3881:                 if (s->flags & CODEC_FLAG_LOW_DELAY ||",
      "3882:                     (h->sps.bitstream_restriction_flag &&",
      "3883:                      !h->sps.num_reorder_frames)) {",
      "3884:                     if (s->avctx->has_b_frames > 1 || h->delayed_pic[0])",
      "3885:                         av_log(avctx, AV_LOG_WARNING, \"Delayed frames seen \"",
      "3886:                                \"reenabling low delay requires a codec \"",
      "3887:                                \"flush.\\n\");",
      "3888:                         else",
      "3889:                             s->low_delay = 1;",
      "3890:                 }",
      "3892:                 if (avctx->has_b_frames < 2)",
      "3893:                     avctx->has_b_frames = !s->low_delay;",
      "3895:                 if (avctx->bits_per_raw_sample != h->sps.bit_depth_luma ||",
      "3896:                     h->cur_chroma_format_idc   != h->sps.chroma_format_idc) {",
      "3897:                     if (s->avctx->codec &&",
      "3898:                         s->avctx->codec->capabilities & CODEC_CAP_HWACCEL_VDPAU",
      "3899:                         && (h->sps.bit_depth_luma != 8 ||",
      "3900:                             h->sps.chroma_format_idc > 1)) {",
      "3901:                         av_log(avctx, AV_LOG_ERROR,",
      "3902:                                \"VDPAU decoding does not support video \"",
      "3903:                                \"colorspace\\n\");",
      "3904:                         buf_index = -1;",
      "3905:                         goto end;",
      "3906:                     }",
      "3907:                     if (h->sps.bit_depth_luma >= 8 && h->sps.bit_depth_luma <= 10) {",
      "3908:                         avctx->bits_per_raw_sample = h->sps.bit_depth_luma;",
      "3909:                         h->cur_chroma_format_idc   = h->sps.chroma_format_idc;",
      "3910:                         h->pixel_shift             = h->sps.bit_depth_luma > 8;",
      "3912:                         ff_h264dsp_init(&h->h264dsp, h->sps.bit_depth_luma,",
      "3913:                                         h->sps.chroma_format_idc);",
      "3914:                         ff_h264_pred_init(&h->hpc, s->codec_id,",
      "3915:                                           h->sps.bit_depth_luma,",
      "3916:                                           h->sps.chroma_format_idc);",
      "3917:                         s->dsp.dct_bits = h->sps.bit_depth_luma > 8 ? 32 : 16;",
      "3918:                         ff_dsputil_init(&s->dsp, s->avctx);",
      "3919:                     } else {",
      "3920:                         av_log(avctx, AV_LOG_ERROR,",
      "3921:                                \"Unsupported bit depth: %d\\n\",",
      "3922:                                h->sps.bit_depth_luma);",
      "3923:                         buf_index = -1;",
      "3924:                         goto end;",
      "3925:                     }",
      "",
      "[Added Lines]",
      "3937:                 if (h264_set_parameter_from_sps(h) < 0) {",
      "3938:                     buf_index = -1;",
      "3939:                     goto end;",
      "",
      "---------------"
    ],
    "libavcodec/h264.h||libavcodec/h264.h": [
      "File: libavcodec/h264.h -> libavcodec/h264.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "203:     int bit_depth_chroma;                 ///< bit_depth_chroma_minus8 + 8",
      "204:     int residual_color_transform_flag;    ///< residual_colour_transform_flag",
      "205:     int constraint_set_flags;             ///< constraint_set[0-3]_flag",
      "206: } SPS;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "206:     int new;                              ///< flag to keep track if the decoder context needs re-init due to changed SPS",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "329:     int emu_edge_width;",
      "330:     int emu_edge_height;",
      "332:     SPS sps; ///< current sps",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "333:     unsigned current_sps_id; ///< id of the current SPS",
      "",
      "---------------"
    ],
    "libavcodec/h264_ps.c||libavcodec/h264_ps.c": [
      "File: libavcodec/h264_ps.c -> libavcodec/h264_ps.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "459:                sps->timing_info_present_flag ? sps->time_scale : 0",
      "460:                );",
      "461:     }",
      "463:     av_free(h->sps_buffers[sps_id]);",
      "466:     return 0;",
      "467: fail:",
      "468:     av_free(sps);",
      "",
      "[Removed Lines]",
      "464:     h->sps_buffers[sps_id]= sps;",
      "465:     h->sps = *sps;",
      "",
      "[Added Lines]",
      "462:     sps->new = 1;",
      "465:     h->sps_buffers[sps_id] = sps;",
      "466:     h->sps                 = *sps;",
      "467:     h->current_sps_id      = sps_id;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "85deb51a01f1ecc5ac5faa52ad8ea141c384e23a",
      "candidate_info": {
        "commit_hash": "85deb51a01f1ecc5ac5faa52ad8ea141c384e23a",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/85deb51a01f1ecc5ac5faa52ad8ea141c384e23a",
        "files": [
          "libavcodec/h264.c"
        ],
        "message": "h264: Only initialize dsputil if error resilience is enabled\n\nIt is only used for error resilience. This allows building the\nh264 decoder without dsputil, if error resilience is disabled.\n\nSigned-off-by: Martin Storsj\u00f6 <martin@martin.st>",
        "before_after_code_files": [
          "libavcodec/h264.c||libavcodec/h264.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libavcodec/h264.c||libavcodec/h264.c"
          ],
          "candidate": [
            "libavcodec/h264.c||libavcodec/h264.c"
          ]
        }
      },
      "candidate_diff": {
        "libavcodec/h264.c||libavcodec/h264.c": [
          "File: libavcodec/h264.c -> libavcodec/h264.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1440:     h->dequant_coeff_pps = -1;",
          "1444:     ff_videodsp_init(&h->vdsp, 8);",
          "1446:     memset(h->pps.scaling_matrix4, 16, 6 * 16 * sizeof(uint8_t));",
          "",
          "[Removed Lines]",
          "1443:     ff_dsputil_init(&h->dsp, h->avctx);",
          "",
          "[Added Lines]",
          "1443:     if (CONFIG_ERROR_RESILIENCE)",
          "1444:         ff_dsputil_init(&h->dsp, h->avctx);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2915:             ff_h264_pred_init(&h->hpc, h->avctx->codec_id, h->sps.bit_depth_luma,",
          "2916:                               h->sps.chroma_format_idc);",
          "2917:             h->dsp.dct_bits = h->sps.bit_depth_luma > 8 ? 32 : 16;",
          "2919:             ff_videodsp_init(&h->vdsp, h->sps.bit_depth_luma);",
          "2920:         } else {",
          "2921:             av_log(h->avctx, AV_LOG_ERROR, \"Unsupported bit depth: %d\\n\",",
          "",
          "[Removed Lines]",
          "2918:             ff_dsputil_init(&h->dsp, h->avctx);",
          "",
          "[Added Lines]",
          "2919:             if (CONFIG_ERROR_RESILIENCE)",
          "2920:                 ff_dsputil_init(&h->dsp, h->avctx);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "82f95d7fd7c0e99a59163e6d14c35cc11bb7f9d7",
      "candidate_info": {
        "commit_hash": "82f95d7fd7c0e99a59163e6d14c35cc11bb7f9d7",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/82f95d7fd7c0e99a59163e6d14c35cc11bb7f9d7",
        "files": [
          "libavcodec/h264.c"
        ],
        "message": "h264: drop special case for 9bit chroma422\n\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>",
        "before_after_code_files": [
          "libavcodec/h264.c||libavcodec/h264.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libavcodec/h264.c||libavcodec/h264.c"
          ],
          "candidate": [
            "libavcodec/h264.c||libavcodec/h264.c"
          ]
        }
      },
      "candidate_diff": {
        "libavcodec/h264.c||libavcodec/h264.c": [
          "File: libavcodec/h264.c -> libavcodec/h264.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2960:             return AVERROR_INVALIDDATA;",
          "2961:         }",
          "2962:         if (h->sps.bit_depth_luma >= 8 && h->sps.bit_depth_luma <= 14 &&",
          "2965:             h->avctx->bits_per_raw_sample = h->sps.bit_depth_luma;",
          "2966:             h->cur_chroma_format_idc      = h->sps.chroma_format_idc;",
          "2967:             h->pixel_shift                = h->sps.bit_depth_luma > 8;",
          "",
          "[Removed Lines]",
          "2963:             h->sps.bit_depth_luma != 11 && h->sps.bit_depth_luma != 13 &&",
          "2964:                 (h->sps.bit_depth_luma != 9 || !CHROMA422)) {",
          "",
          "[Added Lines]",
          "2963:             h->sps.bit_depth_luma != 11 && h->sps.bit_depth_luma != 13) {",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "3aa661ec561d7a20812b84b353b0d7855ac346c8",
      "candidate_info": {
        "commit_hash": "3aa661ec561d7a20812b84b353b0d7855ac346c8",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/3aa661ec561d7a20812b84b353b0d7855ac346c8",
        "files": [
          "libavcodec/h264.c",
          "libavcodec/h264_ps.c"
        ],
        "message": "h264: improve parsing of broken AVC SPS\n\nParsing the entire NAL as SPS fixes decoding of some AVC bitstreams\nwith broken escaping. Since the size of the NAL unit is known and\nchecked against the buffer end we can parse it entirely without buffer\noverreads.\n\nFixes playback of\nhttp://streams.videolan.org/streams/mp4/Mr_MrsSmith-h264_aac.mp4\n\nSigned-off-by: Janne Grunau <janne-libav@jannau.net>",
        "before_after_code_files": [
          "libavcodec/h264.c||libavcodec/h264.c",
          "libavcodec/h264_ps.c||libavcodec/h264_ps.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libavcodec/h264.c||libavcodec/h264.c",
            "libavcodec/h264_ps.c||libavcodec/h264_ps.c"
          ],
          "candidate": [
            "libavcodec/h264.c||libavcodec/h264.c",
            "libavcodec/h264_ps.c||libavcodec/h264_ps.c"
          ]
        }
      },
      "candidate_diff": {
        "libavcodec/h264.c||libavcodec/h264.c": [
          "File: libavcodec/h264.c -> libavcodec/h264.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3925:             break;",
          "3926:         case NAL_SPS:",
          "3927:             init_get_bits(&s->gb, ptr, bit_length);",
          "3930:             if (s->flags& CODEC_FLAG_LOW_DELAY ||",
          "3931:                 (h->sps.bitstream_restriction_flag && !h->sps.num_reorder_frames))",
          "",
          "[Removed Lines]",
          "3928:             ff_h264_decode_seq_parameter_set(h);",
          "",
          "[Added Lines]",
          "3928:             if (ff_h264_decode_seq_parameter_set(h) < 0 &&",
          "3929:                 h->is_avc && (nalsize != consumed) && nalsize) {",
          "3930:                 av_log(h->s.avctx, AV_LOG_DEBUG, \"SPS decoding failure, \"",
          "3931:                        \"try parsing the coomplete NAL\\n\");",
          "3932:                 init_get_bits(&s->gb, buf + buf_index + 1 - consumed,",
          "3933:                               8 * (nalsize - 1));",
          "3934:                 ff_h264_decode_seq_parameter_set(h);",
          "3935:             }",
          "",
          "---------------"
        ],
        "libavcodec/h264_ps.c||libavcodec/h264_ps.c": [
          "File: libavcodec/h264_ps.c -> libavcodec/h264_ps.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "230:         if (get_bits_left(&s->gb) < 0) {",
          "232:             sps->num_reorder_frames=0;",
          "233:             sps->bitstream_restriction_flag= 0;",
          "234:         }",
          "",
          "[Removed Lines]",
          "231:             av_log(h->s.avctx, AV_LOG_ERROR, \"Overread VUI by %d bits\\n\", -get_bits_left(&s->gb));",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "238:             return -1;",
          "239:         }",
          "240:     }",
          "242:     return 0;",
          "243: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "240:     if (get_bits_left(&s->gb) < 0) {",
          "241:         av_log(h->s.avctx, AV_LOG_ERROR, \"Overread VUI by %d bits\\n\", -get_bits_left(&s->gb));",
          "242:         return AVERROR_INVALIDDATA;",
          "243:     }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "1e26a48fa23ef8e1cbc424667d387184d8155f15",
      "candidate_info": {
        "commit_hash": "1e26a48fa23ef8e1cbc424667d387184d8155f15",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/1e26a48fa23ef8e1cbc424667d387184d8155f15",
        "files": [
          "libavcodec/h264.c"
        ],
        "message": "h264: fix deadlocks on incomplete reference frame decoding.\n\nIf decoding a second complementary field, and the first was\ndecoded in our thread, mark decoding of that field as complete.\nIf decoding fails, mark the decoded field/frame as complete.\nDo not allow switching between field modes or field/frame mode\nbetween slices within the same field/frame. Ensure that two\nsubsequent fields cover top/bottom (rather than top/frame,\nbottom/frame or such nonsense situations).\n\nFixes various deadlocks when decoding samples with errors in\nreference frames.\n\nFound-by: Mateusz \"j00ru\" Jurczyk and Gynvael Coldwind\nCC: libav-stable@libav.org",
        "before_after_code_files": [
          "libavcodec/h264.c||libavcodec/h264.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libavcodec/h264.c||libavcodec/h264.c"
          ],
          "candidate": [
            "libavcodec/h264.c||libavcodec/h264.c"
          ]
        }
      },
      "candidate_diff": {
        "libavcodec/h264.c||libavcodec/h264.c": [
          "File: libavcodec/h264.c -> libavcodec/h264.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2747:     s->mb_y = 0;",
          "2749:     if (!in_setup && !s->dropable)",
          "2752:                                   s->picture_structure == PICT_BOTTOM_FIELD);",
          "2754:     if (CONFIG_H264_VDPAU_DECODER &&",
          "",
          "[Removed Lines]",
          "2750:         ff_thread_report_progress(&s->current_picture_ptr->f,",
          "2751:                                   (16 * s->mb_height >> FIELD_PICTURE) - 1,",
          "",
          "[Added Lines]",
          "2750:         ff_thread_report_progress(&s->current_picture_ptr->f, INT_MAX,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2871:     int num_ref_idx_active_override_flag;",
          "2872:     unsigned int slice_type, tmp, i, j;",
          "2873:     int default_ref_list_done = 0;",
          "2879:     if ((s->avctx->flags2 & CODEC_FLAG2_FAST) &&",
          "",
          "[Removed Lines]",
          "2874:     int last_pic_structure;",
          "2876:     s->dropable = h->nal_ref_idc == 0;",
          "",
          "[Added Lines]",
          "2873:     int last_pic_structure, last_pic_dropable;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2893:         }",
          "2895:         h0->current_slice = 0;",
          "2897:             s->current_picture_ptr = NULL;",
          "2898:     }",
          "2900:     slice_type = get_ue_golomb_31(&s->gb);",
          "",
          "[Removed Lines]",
          "2896:         if (!s0->first_field)",
          "",
          "[Added Lines]",
          "2893:         if (!s0->first_field) {",
          "2894:             if (s->current_picture_ptr && !s->dropable &&",
          "2895:                 s->current_picture_ptr->owner2 == s) {",
          "2896:                 ff_thread_report_progress(&s->current_picture_ptr->f, INT_MAX,",
          "2897:                                           s->picture_structure == PICT_BOTTOM_FIELD);",
          "2898:             }",
          "2900:         }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "3103:     h->mb_mbaff        = 0;",
          "3104:     h->mb_aff_frame    = 0;",
          "3105:     last_pic_structure = s0->picture_structure;",
          "3106:     if (h->sps.frame_mbs_only_flag) {",
          "3107:         s->picture_structure = PICT_FRAME;",
          "3108:     } else {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3109:     last_pic_dropable  = s->dropable;",
          "3110:     s->dropable        = h->nal_ref_idc == 0;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "3115:     }",
          "3116:     h->mb_field_decoding_flag = s->picture_structure != PICT_FRAME;",
          "3121:         if (h->frame_num != h->prev_frame_num) {",
          "",
          "[Removed Lines]",
          "3118:     if (h0->current_slice == 0) {",
          "",
          "[Added Lines]",
          "3123:     if (h0->current_slice != 0) {",
          "3124:         if (last_pic_structure != s->picture_structure ||",
          "3125:             last_pic_dropable  != s->dropable) {",
          "3126:             av_log(h->s.avctx, AV_LOG_ERROR,",
          "3127:                    \"Changing field mode (%d -> %d) between slices is not allowed\\n\",",
          "3128:                    last_pic_structure, s->picture_structure);",
          "3129:             s->picture_structure = last_pic_structure;",
          "3130:             s->dropable          = last_pic_dropable;",
          "3131:             return AVERROR_INVALIDDATA;",
          "3132:         }",
          "3133:     } else {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "3134:             }",
          "3135:         }",
          "3137:         while (h->frame_num != h->prev_frame_num &&",
          "3138:                h->frame_num != (h->prev_frame_num + 1) % (1 << h->sps.log2_max_frame_num)) {",
          "3139:             Picture *prev = h->short_ref_count ? h->short_ref[0] : NULL;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3157:         if (s0->first_field) {",
          "3158:             assert(s0->current_picture_ptr);",
          "3159:             assert(s0->current_picture_ptr->f.data[0]);",
          "3160:             assert(s0->current_picture_ptr->f.reference != DELAYED_PIC_REF);",
          "3163:             if (!last_pic_dropable && s0->current_picture_ptr->owner2 == s0) {",
          "3164:                 ff_thread_report_progress(&s0->current_picture_ptr->f, INT_MAX,",
          "3165:                                           last_pic_structure == PICT_BOTTOM_FIELD);",
          "3166:             }",
          "3169:             if (!FIELD_PICTURE || s->picture_structure == last_pic_structure) {",
          "3172:                 if (!last_pic_dropable && last_pic_structure != PICT_FRAME) {",
          "3173:                     ff_thread_report_progress(&s0->current_picture_ptr->f, INT_MAX,",
          "3174:                                               last_pic_structure == PICT_TOP_FIELD);",
          "3175:                 }",
          "3176:             } else {",
          "3177:                 if (s0->current_picture_ptr->frame_num != h->frame_num) {",
          "3182:                     if (!last_pic_dropable && last_pic_structure != PICT_FRAME) {",
          "3183:                         ff_thread_report_progress(&s0->current_picture_ptr->f, INT_MAX,",
          "3184:                                                   last_pic_structure == PICT_TOP_FIELD);",
          "3185:                     }",
          "3186:                 } else {",
          "3188:                     if (!((last_pic_structure   == PICT_TOP_FIELD &&",
          "3189:                            s->picture_structure == PICT_BOTTOM_FIELD) ||",
          "3190:                           (last_pic_structure   == PICT_BOTTOM_FIELD &&",
          "3191:                            s->picture_structure == PICT_TOP_FIELD))) {",
          "3192:                         av_log(s->avctx, AV_LOG_ERROR,",
          "3193:                                \"Invalid field mode combination %d/%d\\n\",",
          "3194:                                last_pic_structure, s->picture_structure);",
          "3195:                         s->picture_structure = last_pic_structure;",
          "3196:                         s->dropable          = last_pic_dropable;",
          "3197:                         return AVERROR_INVALIDDATA;",
          "3198:                     } else if (last_pic_dropable != s->dropable) {",
          "3199:                         av_log(s->avctx, AV_LOG_ERROR,",
          "3200:                                \"Cannot combine reference and non-reference fields in the same frame\\n\");",
          "3201:                         av_log_ask_for_sample(s->avctx, NULL);",
          "3202:                         s->picture_structure = last_pic_structure;",
          "3203:                         s->dropable          = last_pic_dropable;",
          "3204:                         return AVERROR_INVALIDDATA;",
          "3205:                     }",
          "3213:                     s0->current_picture_ptr->owner2 = s0;",
          "3214:                 }",
          "3215:             }",
          "3216:         }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "3180:                 s0->current_picture_ptr = NULL;",
          "3181:                 s0->first_field         = FIELD_PICTURE;",
          "3182:             } else {",
          "3189:                     s0->first_field         = 1;",
          "3190:                     s0->current_picture_ptr = NULL;",
          "3191:                 } else {",
          "",
          "[Removed Lines]",
          "3183:                 if (h->nal_ref_idc &&",
          "3184:                     s0->current_picture_ptr->f.reference &&",
          "3185:                     s0->current_picture_ptr->frame_num != h->frame_num) {",
          "",
          "[Added Lines]",
          "3266:                 if (s0->current_picture_ptr->frame_num != h->frame_num) {",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "4130:             ptr = ff_h264_decode_nal(hx, buf + buf_index, &dst_length,",
          "4131:                                      &consumed, next_avc - buf_index);",
          "4134:             i = buf_index + consumed;",
          "4135:             if ((s->workaround_bugs & FF_BUG_AUTODETECT) && i + 3 < next_avc &&",
          "4136:                 buf[i]     == 0x00 && buf[i + 1] == 0x00 &&",
          "",
          "[Removed Lines]",
          "4132:             if (ptr == NULL || dst_length < 0)",
          "4133:                 return -1;",
          "",
          "[Added Lines]",
          "4213:             if (ptr == NULL || dst_length < 0) {",
          "4214:                 buf_index = -1;",
          "4215:                 goto end;",
          "4216:             }",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "4187:                 if (h->nal_unit_type != NAL_IDR_SLICE) {",
          "4188:                     av_log(h->s.avctx, AV_LOG_ERROR,",
          "4189:                            \"Invalid mix of idr and non-idr slices\");",
          "4191:                 }",
          "4192:                 idr(h); // FIXME ensure we don't lose some frames if there is reordering",
          "4193:             case NAL_SLICE:",
          "",
          "[Removed Lines]",
          "4190:                     return -1;",
          "",
          "[Added Lines]",
          "4273:                     buf_index = -1;",
          "4274:                     goto end;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "4311:                         av_log(avctx, AV_LOG_ERROR,",
          "4312:                                \"Unsupported bit depth: %d\\n\",",
          "4313:                                h->sps.bit_depth_luma);",
          "4315:                     }",
          "4316:                 }",
          "4317:                 break;",
          "",
          "[Removed Lines]",
          "4314:                         return -1;",
          "",
          "[Added Lines]",
          "4398:                         buf_index = -1;",
          "4399:                         goto end;",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "4352:     }",
          "4353:     if (context_count)",
          "4354:         execute_decode_slices(h, context_count);",
          "4355:     return buf_index;",
          "4356: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4441: end:",
          "4443:     if (s->current_picture_ptr && s->current_picture_ptr->owner2 == s &&",
          "4444:         !s->dropable) {",
          "4445:         ff_thread_report_progress(&s->current_picture_ptr->f, INT_MAX,",
          "4446:                                   s->picture_structure == PICT_BOTTOM_FIELD);",
          "4447:     }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b3dc260e7fa6f3f852dd5cb7d86763c4b5736714",
      "candidate_info": {
        "commit_hash": "b3dc260e7fa6f3f852dd5cb7d86763c4b5736714",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/b3dc260e7fa6f3f852dd5cb7d86763c4b5736714",
        "files": [
          "libavcodec/h264.c"
        ],
        "message": "h264: return meaningful values\n\nSigned-off-by: Anton Khirnov <anton@khirnov.net>",
        "before_after_code_files": [
          "libavcodec/h264.c||libavcodec/h264.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libavcodec/h264.c||libavcodec/h264.c"
          ],
          "candidate": [
            "libavcodec/h264.c||libavcodec/h264.c"
          ]
        }
      },
      "candidate_diff": {
        "libavcodec/h264.c||libavcodec/h264.c": [
          "File: libavcodec/h264.c -> libavcodec/h264.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "414:                 av_log(h->avctx, AV_LOG_ERROR,",
          "415:                        \"top block unavailable for requested intra4x4 mode %d at %d %d\\n\",",
          "416:                        status, h->mb_x, h->mb_y);",
          "418:             } else if (status) {",
          "419:                 h->intra4x4_pred_mode_cache[scan8[0] + i] = status;",
          "420:             }",
          "",
          "[Removed Lines]",
          "417:                 return -1;",
          "",
          "[Added Lines]",
          "417:                 return AVERROR_INVALIDDATA;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "430:                     av_log(h->avctx, AV_LOG_ERROR,",
          "431:                            \"left block unavailable for requested intra4x4 mode %d at %d %d\\n\",",
          "432:                            status, h->mb_x, h->mb_y);",
          "434:                 } else if (status) {",
          "435:                     h->intra4x4_pred_mode_cache[scan8[0] + 8 * i] = status;",
          "436:                 }",
          "",
          "[Removed Lines]",
          "433:                     return -1;",
          "",
          "[Added Lines]",
          "433:                     return AVERROR_INVALIDDATA;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "453:         av_log(h->avctx, AV_LOG_ERROR,",
          "454:                \"out of range intra chroma pred mode at %d %d\\n\",",
          "455:                h->mb_x, h->mb_y);",
          "457:     }",
          "459:     if (!(h->top_samples_available & 0x8000)) {",
          "",
          "[Removed Lines]",
          "456:         return -1;",
          "",
          "[Added Lines]",
          "456:         return AVERROR_INVALIDDATA;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "462:             av_log(h->avctx, AV_LOG_ERROR,",
          "463:                    \"top block unavailable for requested intra mode at %d %d\\n\",",
          "464:                    h->mb_x, h->mb_y);",
          "466:         }",
          "467:     }",
          "",
          "[Removed Lines]",
          "465:             return -1;",
          "",
          "[Added Lines]",
          "465:             return AVERROR_INVALIDDATA;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "478:             av_log(h->avctx, AV_LOG_ERROR,",
          "479:                    \"left block unavailable for requested intra mode at %d %d\\n\",",
          "480:                    h->mb_x, h->mb_y);",
          "482:         }",
          "483:     }",
          "",
          "[Removed Lines]",
          "481:             return -1;",
          "",
          "[Added Lines]",
          "481:             return AVERROR_INVALIDDATA;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1260: fail:",
          "1261:     free_tables(h, 1);",
          "1263: }",
          "",
          "[Removed Lines]",
          "1262:     return -1;",
          "",
          "[Added Lines]",
          "1262:     return AVERROR(ENOMEM);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1358:     return 0;",
          "1360: fail:",
          "1362: }",
          "1364: static int decode_nal_units(H264Context *h, const uint8_t *buf, int buf_size,",
          "",
          "[Removed Lines]",
          "1361:     return -1; // free_tables will clean up for us",
          "",
          "[Added Lines]",
          "1361:     return AVERROR(ENOMEM); // free_tables will clean up for us",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1367: int ff_h264_decode_extradata(H264Context *h)",
          "1368: {",
          "1369:     AVCodecContext *avctx = h->avctx;",
          "1371:     if (avctx->extradata[0] == 1) {",
          "1372:         int i, cnt, nalsize;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1370:     int ret;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1377:         if (avctx->extradata_size < 7) {",
          "1378:             av_log(avctx, AV_LOG_ERROR, \"avcC too short\\n\");",
          "1380:         }",
          "",
          "[Removed Lines]",
          "1379:             return -1;",
          "",
          "[Added Lines]",
          "1380:             return AVERROR_INVALIDDATA;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1387:         for (i = 0; i < cnt; i++) {",
          "1388:             nalsize = AV_RB16(p) + 2;",
          "1389:             if (p - avctx->extradata + nalsize > avctx->extradata_size)",
          "1392:                 av_log(avctx, AV_LOG_ERROR,",
          "1393:                        \"Decoding sps %d from avcC failed\\n\", i);",
          "1395:             }",
          "1396:             p += nalsize;",
          "1397:         }",
          "",
          "[Removed Lines]",
          "1390:                 return -1;",
          "1391:             if (decode_nal_units(h, p, nalsize, 1) < 0) {",
          "1394:                 return -1;",
          "",
          "[Added Lines]",
          "1391:                 return AVERROR_INVALIDDATA;",
          "1392:             ret = decode_nal_units(h, p, nalsize, 1);",
          "1393:             if (ret < 0) {",
          "1396:                 return ret;",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1400:         for (i = 0; i < cnt; i++) {",
          "1401:             nalsize = AV_RB16(p) + 2;",
          "1402:             if (p - avctx->extradata + nalsize > avctx->extradata_size)",
          "1405:                 av_log(avctx, AV_LOG_ERROR,",
          "1406:                        \"Decoding pps %d from avcC failed\\n\", i);",
          "1408:             }",
          "1409:             p += nalsize;",
          "1410:         }",
          "",
          "[Removed Lines]",
          "1403:                 return -1;",
          "1404:             if (decode_nal_units(h, p, nalsize, 1) < 0) {",
          "1407:                 return -1;",
          "",
          "[Added Lines]",
          "1405:                 return AVERROR_INVALIDDATA;",
          "1406:             ret = decode_nal_units(h, p, nalsize, 1);",
          "1407:             if (ret < 0) {",
          "1410:                 return ret;",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1412:         h->nal_length_size = (avctx->extradata[4] & 0x03) + 1;",
          "1413:     } else {",
          "1414:         h->is_avc = 0;",
          "1417:     }",
          "1418:     return 0;",
          "1419: }",
          "",
          "[Removed Lines]",
          "1415:         if (decode_nal_units(h, avctx->extradata, avctx->extradata_size, 1) < 0)",
          "1416:             return -1;",
          "",
          "[Added Lines]",
          "1418:         ret = decode_nal_units(h, avctx->extradata, avctx->extradata_size, 1);",
          "1419:         if (ret < 0)",
          "1420:             return ret;",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1422: {",
          "1423:     H264Context *h = avctx->priv_data;",
          "1424:     int i;",
          "1426:     h->avctx = avctx;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1429:     int ret;",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "1473:         avctx->ticks_per_frame = 2;",
          "1474:     }",
          "1480:     if (h->sps.bitstream_restriction_flag &&",
          "1481:         h->avctx->has_b_frames < h->sps.num_reorder_frames) {",
          "",
          "[Removed Lines]",
          "1476:     if (avctx->extradata_size > 0 && avctx->extradata &&",
          "1477:         ff_h264_decode_extradata(h))",
          "1478:         return -1;",
          "",
          "[Added Lines]",
          "1481:     if (avctx->extradata_size > 0 && avctx->extradata) {",
          "1482:        ret = ff_h264_decode_extradata(h);",
          "1483:        if (ret < 0)",
          "1484:            return ret;",
          "1485:     }",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "1625:         h->ref_index_pool    = NULL;",
          "1626:         h->motion_val_pool   = NULL;",
          "1629:             av_log(dst, AV_LOG_ERROR, \"Could not allocate memory for h264\\n\");",
          "1631:         }",
          "1632:         context_init(h);",
          "",
          "[Removed Lines]",
          "1628:         if (ff_h264_alloc_tables(h) < 0) {",
          "1630:             return AVERROR(ENOMEM);",
          "",
          "[Added Lines]",
          "1635:         ret = ff_h264_alloc_tables(h);",
          "1636:         if (ret < 0) {",
          "1638:             return ret;",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "3002:     int nb_slices = (HAVE_THREADS &&",
          "3003:                      h->avctx->active_thread_type & FF_THREAD_SLICE) ?",
          "3004:                     h->avctx->thread_count : 1;",
          "3007:     h->avctx->sample_aspect_ratio = h->sps.sar;",
          "3008:     av_assert0(h->avctx->sample_aspect_ratio.den);",
          "",
          "[Removed Lines]",
          "3005:     int i;",
          "",
          "[Added Lines]",
          "3013:     int i, ret;",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "3025:     h->prev_interlaced_frame = 1;",
          "3027:     init_scan_tables(h);",
          "3029:         av_log(h->avctx, AV_LOG_ERROR,",
          "3030:                \"Could not allocate memory for h264\\n\");",
          "3032:     }",
          "3034:     if (nb_slices > MAX_THREADS || (nb_slices > h->mb_height && h->mb_height)) {",
          "",
          "[Removed Lines]",
          "3028:     if (ff_h264_alloc_tables(h) < 0) {",
          "3031:         return AVERROR(ENOMEM);",
          "",
          "[Added Lines]",
          "3036:     ret = ff_h264_alloc_tables(h);",
          "3037:     if (ret < 0) {",
          "3040:         return ret;",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "3044:     h->slice_context_count = nb_slices;",
          "3046:     if (!HAVE_THREADS || !(h->avctx->active_thread_type & FF_THREAD_SLICE)) {",
          "3048:             av_log(h->avctx, AV_LOG_ERROR, \"context_init() failed.\\n\");",
          "3050:         }",
          "3051:     } else {",
          "3052:         for (i = 1; i < h->slice_context_count; i++) {",
          "",
          "[Removed Lines]",
          "3047:         if (context_init(h) < 0) {",
          "3049:             return -1;",
          "",
          "[Added Lines]",
          "3056:         ret = context_init(h);",
          "3057:         if (ret < 0) {",
          "3059:             return ret;",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "3085:         }",
          "3087:         for (i = 0; i < h->slice_context_count; i++)",
          "3089:                 av_log(h->avctx, AV_LOG_ERROR, \"context_init() failed.\\n\");",
          "3091:             }",
          "3092:     }",
          "",
          "[Removed Lines]",
          "3088:             if (context_init(h->thread_context[i]) < 0) {",
          "3090:                 return -1;",
          "",
          "[Added Lines]",
          "3098:             if ((ret = context_init(h->thread_context[i])) < 0) {",
          "3100:                 return ret;",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "3141:         av_log(h->avctx, AV_LOG_ERROR,",
          "3142:                \"slice type too large (%d) at %d %d\\n\",",
          "3143:                h->slice_type, h->mb_x, h->mb_y);",
          "3145:     }",
          "3146:     if (slice_type > 4) {",
          "3147:         slice_type -= 5;",
          "",
          "[Removed Lines]",
          "3144:         return -1;",
          "",
          "[Added Lines]",
          "3154:         return AVERROR_INVALIDDATA;",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "3163:     pps_id = get_ue_golomb(&h->gb);",
          "3164:     if (pps_id >= MAX_PPS_COUNT) {",
          "3165:         av_log(h->avctx, AV_LOG_ERROR, \"pps_id out of range\\n\");",
          "3167:     }",
          "3168:     if (!h0->pps_buffers[pps_id]) {",
          "3169:         av_log(h->avctx, AV_LOG_ERROR,",
          "3170:                \"non-existing PPS %u referenced\\n\",",
          "3171:                pps_id);",
          "3173:     }",
          "3174:     h->pps = *h0->pps_buffers[pps_id];",
          "",
          "[Removed Lines]",
          "3166:         return -1;",
          "3172:         return -1;",
          "",
          "[Added Lines]",
          "3176:         return AVERROR_INVALIDDATA;",
          "3182:         return AVERROR_INVALIDDATA;",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "3177:         av_log(h->avctx, AV_LOG_ERROR,",
          "3178:                \"non-existing SPS %u referenced\\n\",",
          "3179:                h->pps.sps_id);",
          "3181:     }",
          "3183:     if (h->pps.sps_id != h->current_sps_id ||",
          "",
          "[Removed Lines]",
          "3180:         return -1;",
          "",
          "[Added Lines]",
          "3190:         return AVERROR_INVALIDDATA;",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "3262:         if (h != h0) {",
          "3263:             av_log(h->avctx, AV_LOG_ERROR,",
          "3264:                    \"Cannot (re-)initialize context during parallel decoding.\\n\");",
          "3266:         }",
          "3268:         if ((ret = get_pixel_format(h)) < 0)",
          "",
          "[Removed Lines]",
          "3265:             return -1;",
          "",
          "[Added Lines]",
          "3275:             return AVERROR_PATCHWELCOME;",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "3390:             Picture *prev = h->short_ref_count ? h->short_ref[0] : NULL;",
          "3391:             av_log(h->avctx, AV_LOG_DEBUG, \"Frame num gap %d %d\\n\",",
          "3392:                    h->frame_num, h->prev_frame_num);",
          "3395:             h->prev_frame_num++;",
          "3396:             h->prev_frame_num        %= 1 << h->sps.log2_max_frame_num;",
          "3397:             h->cur_pic_ptr->frame_num = h->prev_frame_num;",
          "3398:             ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX, 0);",
          "3399:             ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX, 1);",
          "3402:                 return ret;",
          "",
          "[Removed Lines]",
          "3393:             if (h264_frame_start(h) < 0)",
          "3394:                 return -1;",
          "3400:             if ((ret = ff_generate_sliding_window_mmcos(h, 1)) < 0 &&",
          "3401:                 h->avctx->err_recognition & AV_EF_EXPLODE)",
          "3403:             if (ff_h264_execute_ref_pic_marking(h, h->mmco, h->mmco_index) < 0 &&",
          "3404:                 (h->avctx->err_recognition & AV_EF_EXPLODE))",
          "3405:                 return AVERROR_INVALIDDATA;",
          "",
          "[Added Lines]",
          "3403:             ret = h264_frame_start(h);",
          "3404:             if (ret < 0)",
          "3405:                 return ret;",
          "3411:             ret = ff_generate_sliding_window_mmcos(h, 1);",
          "3412:             if (ret < 0 && (h->avctx->err_recognition & AV_EF_EXPLODE))",
          "3413:                 return ret;",
          "3414:             ret = ff_h264_execute_ref_pic_marking(h, h->mmco, h->mmco_index);",
          "3415:             if (ret < 0 && (h->avctx->err_recognition & AV_EF_EXPLODE))",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "3459:         if (!FIELD_PICTURE(h) || h0->first_field) {",
          "3460:             if (h264_frame_start(h) < 0) {",
          "3461:                 h0->first_field = 0;",
          "3463:             }",
          "3464:         } else {",
          "3465:             release_unused_pictures(h, 0);",
          "",
          "[Removed Lines]",
          "3462:                 return -1;",
          "",
          "[Added Lines]",
          "3473:                 return AVERROR_INVALIDDATA;",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "3474:     if (first_mb_in_slice << FIELD_OR_MBAFF_PICTURE(h) >= h->mb_num ||",
          "3475:         first_mb_in_slice >= h->mb_num) {",
          "3476:         av_log(h->avctx, AV_LOG_ERROR, \"first_mb_in_slice overflow\\n\");",
          "3478:     }",
          "3479:     h->resync_mb_x = h->mb_x =  first_mb_in_slice % h->mb_width;",
          "3480:     h->resync_mb_y = h->mb_y = (first_mb_in_slice / h->mb_width) <<",
          "",
          "[Removed Lines]",
          "3477:         return -1;",
          "",
          "[Added Lines]",
          "3488:         return AVERROR_INVALIDDATA;",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "3553:     if (!default_ref_list_done)",
          "3554:         ff_h264_fill_default_ref_list(h);",
          "3560:     }",
          "3562:     if ((h->pps.weighted_pred && h->slice_type_nos == AV_PICTURE_TYPE_P) ||",
          "",
          "[Removed Lines]",
          "3556:     if (h->slice_type_nos != AV_PICTURE_TYPE_I &&",
          "3557:         ff_h264_decode_ref_pic_list_reordering(h) < 0) {",
          "3558:         h->ref_count[1] = h->ref_count[0] = 0;",
          "3559:         return -1;",
          "",
          "[Added Lines]",
          "3567:     if (h->slice_type_nos != AV_PICTURE_TYPE_I) {",
          "3568:        ret = ff_h264_decode_ref_pic_list_reordering(h);",
          "3569:        if (ret < 0) {",
          "3570:            h->ref_count[1] = h->ref_count[0] = 0;",
          "3571:            return ret;",
          "3572:        }",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "3589:     if (FRAME_MBAFF(h)) {",
          "3590:         ff_h264_fill_mbaff_ref_list(h);",
          "",
          "[Removed Lines]",
          "3582:     if (h->nal_ref_idc &&",
          "3583:         ff_h264_decode_ref_pic_marking(h0, &h->gb,",
          "3584:                                        !(h->avctx->active_thread_type & FF_THREAD_FRAME) ||",
          "3585:                                        h0->current_slice == 0) < 0 &&",
          "3586:         (h->avctx->err_recognition & AV_EF_EXPLODE))",
          "3587:         return AVERROR_INVALIDDATA;",
          "",
          "[Added Lines]",
          "3595:     if (h->nal_ref_idc) {",
          "3596:         ret = ff_h264_decode_ref_pic_marking(h0, &h->gb,",
          "3597:                                              !(h->avctx->active_thread_type & FF_THREAD_FRAME) ||",
          "3598:                                              h0->current_slice == 0);",
          "3599:         if (ret < 0 && (h->avctx->err_recognition & AV_EF_EXPLODE))",
          "3600:             return AVERROR_INVALIDDATA;",
          "3601:     }",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "3603:         tmp = get_ue_golomb_31(&h->gb);",
          "3604:         if (tmp > 2) {",
          "3605:             av_log(h->avctx, AV_LOG_ERROR, \"cabac_init_idc overflow\\n\");",
          "3607:         }",
          "3608:         h->cabac_init_idc = tmp;",
          "3609:     }",
          "",
          "[Removed Lines]",
          "3606:             return -1;",
          "",
          "[Added Lines]",
          "3620:             return AVERROR_INVALIDDATA;",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "3612:     tmp = h->pps.init_qp + get_se_golomb(&h->gb);",
          "3613:     if (tmp > 51 + 6 * (h->sps.bit_depth_luma - 8)) {",
          "3614:         av_log(h->avctx, AV_LOG_ERROR, \"QP %u out of range\\n\", tmp);",
          "3616:     }",
          "3617:     h->qscale       = tmp;",
          "3618:     h->chroma_qp[0] = get_chroma_qp(h, 0, h->qscale);",
          "",
          "[Removed Lines]",
          "3615:         return -1;",
          "",
          "[Added Lines]",
          "3629:         return AVERROR_INVALIDDATA;",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "3632:         if (tmp > 2) {",
          "3633:             av_log(h->avctx, AV_LOG_ERROR,",
          "3634:                    \"deblocking_filter_idc %u out of range\\n\", tmp);",
          "3636:         }",
          "3637:         h->deblocking_filter = tmp;",
          "3638:         if (h->deblocking_filter < 2)",
          "",
          "[Removed Lines]",
          "3635:             return -1;",
          "",
          "[Added Lines]",
          "3649:             return AVERROR_INVALIDDATA;",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "3646:                 av_log(h->avctx, AV_LOG_ERROR,",
          "3647:                        \"deblocking filter parameters %d %d out of range\\n\",",
          "3648:                        h->slice_alpha_c0_offset, h->slice_beta_offset);",
          "3650:             }",
          "3651:         }",
          "3652:     }",
          "",
          "[Removed Lines]",
          "3649:                 return -1;",
          "",
          "[Added Lines]",
          "3663:                 return AVERROR_INVALIDDATA;",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "3764:     case AV_PICTURE_TYPE_SI:",
          "3765:         return 4;",
          "3766:     default:",
          "3768:     }",
          "3769: }",
          "",
          "[Removed Lines]",
          "3767:         return -1;",
          "",
          "[Added Lines]",
          "3781:         return AVERROR_INVALIDDATA;",
          "",
          "---------------",
          "--- Hunk 34 ---",
          "[Context before]",
          "4180:                        h->cabac.bytestream_end - h->cabac.bytestream);",
          "4181:                 er_add_slice(h, h->resync_mb_x, h->resync_mb_y, h->mb_x,",
          "4182:                              h->mb_y, ER_MB_ERROR);",
          "4184:             }",
          "4186:             if (++h->mb_x >= h->mb_width) {",
          "",
          "[Removed Lines]",
          "4183:                 return -1;",
          "",
          "[Added Lines]",
          "4197:                 return AVERROR_INVALIDDATA;",
          "",
          "---------------",
          "--- Hunk 35 ---",
          "[Context before]",
          "4227:                        \"error while decoding MB %d %d\\n\", h->mb_x, h->mb_y);",
          "4228:                 er_add_slice(h, h->resync_mb_x, h->resync_mb_y, h->mb_x,",
          "4229:                              h->mb_y, ER_MB_ERROR);",
          "4231:             }",
          "4233:             if (++h->mb_x >= h->mb_width) {",
          "",
          "[Removed Lines]",
          "4230:                 return -1;",
          "",
          "[Added Lines]",
          "4244:                 return ret;",
          "",
          "---------------",
          "--- Hunk 36 ---",
          "[Context before]",
          "4255:                                      h->mb_x - 1, h->mb_y,",
          "4256:                                      ER_MB_END);",
          "4259:                     }",
          "4260:                 }",
          "4261:             }",
          "",
          "[Removed Lines]",
          "4258:                         return -1;",
          "",
          "[Added Lines]",
          "4272:                         return AVERROR_INVALIDDATA;",
          "",
          "---------------",
          "--- Hunk 37 ---",
          "[Context before]",
          "4275:                     er_add_slice(h, h->resync_mb_x, h->resync_mb_y, h->mb_x,",
          "4276:                                  h->mb_y, ER_MB_ERROR);",
          "4279:                 }",
          "4280:             }",
          "4281:         }",
          "",
          "[Removed Lines]",
          "4278:                     return -1;",
          "",
          "[Added Lines]",
          "4293:                     return AVERROR_INVALIDDATA;",
          "",
          "---------------",
          "--- Hunk 38 ---",
          "[Context before]",
          "4333:     int pass = !(avctx->active_thread_type & FF_THREAD_FRAME);",
          "4334:     int nals_needed = 0; ///< number of NALs that need decoding before the next frame thread starts",
          "4335:     int nal_index;",
          "4337:     h->max_contexts = h->slice_context_count;",
          "4338:     if (!(avctx->flags2 & CODEC_FLAG2_CHUNKS)) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4351:     int ret = 0;",
          "",
          "---------------",
          "--- Hunk 39 ---",
          "[Context before]",
          "4391:             ptr = ff_h264_decode_nal(hx, buf + buf_index, &dst_length,",
          "4392:                                      &consumed, next_avc - buf_index);",
          "4393:             if (ptr == NULL || dst_length < 0) {",
          "4395:                 goto end;",
          "4396:             }",
          "4397:             i = buf_index + consumed;",
          "",
          "[Removed Lines]",
          "4394:                 buf_index = -1;",
          "",
          "[Added Lines]",
          "4410:                 ret = -1;",
          "",
          "---------------",
          "--- Hunk 40 ---",
          "[Context before]",
          "4462:                 if (h->nal_unit_type != NAL_IDR_SLICE) {",
          "4463:                     av_log(h->avctx, AV_LOG_ERROR,",
          "4464:                            \"Invalid mix of idr and non-idr slices\\n\");",
          "4466:                     goto end;",
          "4467:                 }",
          "4468:                 idr(h); // FIXME ensure we don't lose some frames if there is reordering",
          "",
          "[Removed Lines]",
          "4465:                     buf_index = -1;",
          "",
          "[Added Lines]",
          "4481:                     ret = -1;",
          "",
          "---------------",
          "--- Hunk 41 ---",
          "[Context before]",
          "4484:                         decode_postinit(h, nal_index >= nals_needed);",
          "4486:                     if (h->avctx->hwaccel &&",
          "4489:                 }",
          "4491:                 if (hx->redundant_pic_count == 0 &&",
          "",
          "[Removed Lines]",
          "4487:                         h->avctx->hwaccel->start_frame(h->avctx, NULL, 0) < 0)",
          "4488:                         return -1;",
          "",
          "[Added Lines]",
          "4503:                         (ret = h->avctx->hwaccel->start_frame(h->avctx, NULL, 0)) < 0)",
          "4504:                         return ret;",
          "",
          "---------------",
          "--- Hunk 42 ---",
          "[Context before]",
          "4497:                      hx->slice_type_nos == AV_PICTURE_TYPE_I) &&",
          "4498:                     avctx->skip_frame < AVDISCARD_ALL) {",
          "4499:                     if (avctx->hwaccel) {",
          "4504:                     } else",
          "4505:                         context_count++;",
          "4506:                 }",
          "",
          "[Removed Lines]",
          "4500:                         if (avctx->hwaccel->decode_slice(avctx,",
          "4501:                                                          &buf[buf_index - consumed],",
          "4502:                                                          consumed) < 0)",
          "4503:                             return -1;",
          "",
          "[Added Lines]",
          "4516:                         ret = avctx->hwaccel->decode_slice(avctx,",
          "4517:                                                            &buf[buf_index - consumed],",
          "4518:                                                            consumed);",
          "4519:                         if (ret < 0)",
          "4520:                             return ret;",
          "",
          "---------------",
          "--- Hunk 43 ---",
          "[Context before]",
          "4541:                 break;",
          "4542:             case NAL_SPS:",
          "4543:                 init_get_bits(&h->gb, ptr, bit_length);",
          "4546:                     av_log(h->avctx, AV_LOG_DEBUG,",
          "4547:                            \"SPS decoding failure, trying again with the complete NAL\\n\");",
          "4548:                     init_get_bits(&h->gb, buf + buf_index + 1 - consumed,",
          "",
          "[Removed Lines]",
          "4544:                 if (ff_h264_decode_seq_parameter_set(h) < 0 &&",
          "4545:                     h->is_avc && (nalsize != consumed) && nalsize) {",
          "",
          "[Added Lines]",
          "4561:                 ret = ff_h264_decode_seq_parameter_set(h);",
          "4562:                 if (ret < 0 && h->is_avc && (nalsize != consumed) && nalsize) {",
          "",
          "---------------",
          "--- Hunk 44 ---",
          "[Context before]",
          "4550:                     ff_h264_decode_seq_parameter_set(h);",
          "4551:                 }",
          "4555:                     goto end;",
          "4557:                 break;",
          "4558:             case NAL_PPS:",
          "4559:                 init_get_bits(&h->gb, ptr, bit_length);",
          "",
          "[Removed Lines]",
          "4553:                 if (h264_set_parameter_from_sps(h) < 0) {",
          "4554:                     buf_index = -1;",
          "4556:                 }",
          "",
          "[Added Lines]",
          "4570:                 ret = h264_set_parameter_from_sps(h);",
          "4571:                 if (ret < 0)",
          "",
          "---------------",
          "--- Hunk 45 ---",
          "[Context before]",
          "4602:                                   h->picture_structure == PICT_BOTTOM_FIELD);",
          "4603:     }",
          "4606: }",
          "",
          "[Removed Lines]",
          "4605:     return buf_index;",
          "",
          "[Added Lines]",
          "4622:     return (ret < 0) ? ret : buf_index;",
          "",
          "---------------",
          "--- Hunk 46 ---",
          "[Context before]",
          "4687:     buf_index = decode_nal_units(h, buf, buf_size, 0);",
          "4688:     if (buf_index < 0)",
          "4691:     if (!h->cur_pic_ptr && h->nal_unit_type == NAL_END_SEQUENCE) {",
          "4692:         buf_size = 0;",
          "",
          "[Removed Lines]",
          "4689:         return -1;",
          "",
          "[Added Lines]",
          "4706:         return AVERROR_INVALIDDATA;",
          "",
          "---------------",
          "--- Hunk 47 ---",
          "[Context before]",
          "4697:         if (avctx->skip_frame >= AVDISCARD_NONREF)",
          "4698:             return 0;",
          "4699:         av_log(avctx, AV_LOG_ERROR, \"no frame!\\n\");",
          "4701:     }",
          "4703:     if (!(avctx->flags2 & CODEC_FLAG2_CHUNKS) ||",
          "",
          "[Removed Lines]",
          "4700:         return -1;",
          "",
          "[Added Lines]",
          "4717:         return AVERROR_INVALIDDATA;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
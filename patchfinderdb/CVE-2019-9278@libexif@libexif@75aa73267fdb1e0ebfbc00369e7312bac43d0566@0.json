{
  "cve_id": "CVE-2019-9278",
  "cve_desc": "In libexif, there is a possible out of bounds write due to an integer overflow. This could lead to remote escalation of privilege in the media content provider with no additional execution privileges needed. User interaction is needed for exploitation. Product: AndroidVersions: Android-10Android ID: A-112537774",
  "repo": "libexif/libexif",
  "patch_hash": "75aa73267fdb1e0ebfbc00369e7312bac43d0566",
  "patch_info": {
    "commit_hash": "75aa73267fdb1e0ebfbc00369e7312bac43d0566",
    "repo": "libexif/libexif",
    "commit_url": "https://github.com/libexif/libexif/commit/75aa73267fdb1e0ebfbc00369e7312bac43d0566",
    "files": [
      "libexif/exif-data.c"
    ],
    "message": "fix CVE-2019-9278\n\navoid the use of unsafe integer overflow checking constructs (unsigned integer operations cannot overflow, so \"u1 + u2 > u1\" can be optimized away)\n\ncheck for the actual sizes, which should also handle the overflows\ndocument other places google patched, but do not seem relevant due to other restrictions\n\nfixes https://github.com/libexif/libexif/issues/26",
    "before_after_code_files": [
      "libexif/exif-data.c||libexif/exif-data.c"
    ]
  },
  "patch_diff": {
    "libexif/exif-data.c||libexif/exif-data.c": [
      "File: libexif/exif-data.c -> libexif/exif-data.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "192:   doff = offset + 8;",
      "196:   exif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",",
      "198:   return 0;",
      "199:  }",
      "",
      "[Removed Lines]",
      "195:  if ((doff + s < doff) || (doff + s < s) || (doff + s > size)) {",
      "197:       \"Tag data past end of buffer (%u > %u)\", doff+s, size);",
      "",
      "[Added Lines]",
      "195:  if (doff >= size) {",
      "197:       \"Tag starts past end of buffer (%u > %u)\", doff, size);",
      "198:   return 0;",
      "199:  }",
      "201:  if (s > size - doff) {",
      "202:   exif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",",
      "203:       \"Tag data goes past end of buffer (%u > %u)\", doff+s, size);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "315:           unsigned int ds, ExifLong o, ExifLong s)",
      "316: {",
      "322:   return;",
      "323:  }",
      "325:  if (data->data)",
      "326:   exif_mem_free (data->priv->mem, data->data);",
      "327:  if (!(data->data = exif_data_alloc (data, s))) {",
      "",
      "[Removed Lines]",
      "318:  if ((o + s < o) || (o + s < s) || (o + s > ds) || (o > ds)) {",
      "319:   exif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",",
      "320:      \"Bogus thumbnail offset (%u) or size (%u).\",",
      "321:      o, s);",
      "",
      "[Added Lines]",
      "324:  if (o >= ds) {",
      "325:   exif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\", \"Bogus thumbnail offset (%u).\", o);",
      "326:   return;",
      "327:  }",
      "328:  if (s > ds - o) {",
      "329:   exif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\", \"Bogus thumbnail size (%u), max would be %u.\", s, ds-o);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "964:   exif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",",
      "965:      \"IFD 1 at %i.\", (int) offset);",
      "969:    exif_log (data->priv->log, EXIF_LOG_CODE_CORRUPT_DATA,",
      "970:       \"ExifData\", \"Bogus offset of IFD1.\");",
      "971:   } else {",
      "",
      "[Removed Lines]",
      "968:   if (offset > ds || offset + 6 > ds) {",
      "",
      "[Added Lines]",
      "976:   if (offset > ds - 6) {",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "ce03ad7ef4e8aeefce79192bf5b6f69fae396f0c",
      "candidate_info": {
        "commit_hash": "ce03ad7ef4e8aeefce79192bf5b6f69fae396f0c",
        "repo": "libexif/libexif",
        "commit_url": "https://github.com/libexif/libexif/commit/ce03ad7ef4e8aeefce79192bf5b6f69fae396f0c",
        "files": [
          "libexif/exif-data.c"
        ],
        "message": "fixed another unsigned integer overflow\n\nfirst fixed by google in android fork,\nhttps://android.googlesource.com/platform/external/libexif/+/1e187b62682ffab5003c702657d6d725b4278f16%5E%21/#F0\n\n(use a more generic overflow check method, also check second overflow instance.)\n\nhttps://security-tracker.debian.org/tracker/CVE-2020-0198",
        "before_after_code_files": [
          "libexif/exif-data.c||libexif/exif-data.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libexif/exif-data.c||libexif/exif-data.c"
          ],
          "candidate": [
            "libexif/exif-data.c||libexif/exif-data.c"
          ]
        }
      },
      "candidate_diff": {
        "libexif/exif-data.c||libexif/exif-data.c": [
          "File: libexif/exif-data.c -> libexif/exif-data.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "47: #undef JPEG_MARKER_APP1",
          "48: #define JPEG_MARKER_APP1 0xe1",
          "50: static const unsigned char ExifHeader[] = {0x45, 0x78, 0x69, 0x66, 0x00, 0x00};",
          "52: struct _ExifDataPrivate",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "50: #define CHECKOVERFLOW(offset,datasize,structsize) (( offset >= datasize) || (structsize > datasize) || (offset > datasize - structsize ))",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "327:   exif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\", \"Bogus thumbnail offset (%u).\", o);",
          "328:   return;",
          "329:  }",
          "331:   exif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\", \"Bogus thumbnail size (%u), max would be %u.\", s, ds-o);",
          "332:   return;",
          "333:  }",
          "",
          "[Removed Lines]",
          "330:  if (s > ds - o) {",
          "",
          "[Added Lines]",
          "332:  if (CHECKOVERFLOW(o,ds,s)) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "420:  }",
          "424:   exif_log (data->priv->log, EXIF_LOG_CODE_CORRUPT_DATA, \"ExifData\",",
          "426:   return;",
          "427:  }",
          "428:  n = exif_get_short (d + offset, data->priv->order);",
          "",
          "[Removed Lines]",
          "423:  if ((offset + 2 < offset) || (offset + 2 < 2) || (offset + 2 > ds)) {",
          "425:      \"Tag data past end of buffer (%u > %u)\", offset+2, ds);",
          "",
          "[Added Lines]",
          "425:  if (CHECKOVERFLOW(offset, ds, 2)) {",
          "427:      \"Tag data past end of buffer (%u+2 > %u)\", offset, ds);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "431:  offset += 2;",
          "435:   n = (ds - offset) / 12;",
          "436:   exif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",",
          "437:       \"Short data; only loading %hu entries...\", n);",
          "",
          "[Removed Lines]",
          "434:  if (offset + 12 * n > ds) {",
          "",
          "[Added Lines]",
          "436:  if (CHECKOVERFLOW(offset, ds, 12*n)) {",
          "",
          "---------------"
        ]
      }
    }
  ]
}
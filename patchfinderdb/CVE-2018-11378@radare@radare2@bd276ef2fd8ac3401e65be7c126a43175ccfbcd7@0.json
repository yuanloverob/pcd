{
  "cve_id": "CVE-2018-11378",
  "cve_desc": "The wasm_dis() function in libr/asm/arch/wasm/wasm.c in or possibly have unspecified other impact via a crafted WASM file.",
  "repo": "radare/radare2",
  "patch_hash": "bd276ef2fd8ac3401e65be7c126a43175ccfbcd7",
  "patch_info": {
    "commit_hash": "bd276ef2fd8ac3401e65be7c126a43175ccfbcd7",
    "repo": "radare/radare2",
    "commit_url": "https://github.com/radare/radare2/commit/bd276ef2fd8ac3401e65be7c126a43175ccfbcd7",
    "files": [
      "libr/asm/arch/wasm/wasm.c"
    ],
    "message": "Fix #9969 - Stack overflow in wasm disassembler",
    "before_after_code_files": [
      "libr/asm/arch/wasm/wasm.c||libr/asm/arch/wasm/wasm.c"
    ]
  },
  "patch_diff": {
    "libr/asm/arch/wasm/wasm.c||libr/asm/arch/wasm/wasm.c": [
      "File: libr/asm/arch/wasm/wasm.c -> libr/asm/arch/wasm/wasm.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "414:    }",
      "415:    op->len += n;",
      "416:    snprintf (op->txt, R_ASM_BUFSIZE, \"%s %d \", opdef->txt, count);",
      "420:    }",
      "422:    free (table);",
      "423:    break;",
      "425:    free (table);",
      "426:    goto err;",
      "427:   }",
      "",
      "[Removed Lines]",
      "417:    for (i = 0; i < count && strlen (op->txt) + 10 < R_ASM_BUFSIZE; i++) {",
      "418:     int optxtlen = strlen (op->txt);",
      "419:     snprintf (op->txt + optxtlen, R_ASM_BUFSIZE - optxtlen, \"%d \", table[i]);",
      "421:    snprintf (op->txt + strlen (op->txt), R_ASM_BUFSIZE, \"%d\", def);",
      "424:    beach:",
      "",
      "[Added Lines]",
      "417:    char *txt = op->txt;",
      "418:    int txtLen = strlen (op->txt);",
      "419:    int txtLeft = R_ASM_BUFSIZE - txtLen;",
      "420:    txt += txtLen;",
      "421:    for (i = 0; i < count && txtLen + 10 < R_ASM_BUFSIZE; i++) {",
      "422:     snprintf (txt, txtLeft, \"%d \", table[i]);",
      "423:     txtLen = strlen (txt);",
      "424:     txt += txtLen;",
      "425:     txtLeft -= txtLen;",
      "427:    snprintf (txt, txtLeft - 1, \"%d\", def);",
      "430:   beach:",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "5c3cdb44d5bcde46cb868de020a74bad47c8f3da",
      "candidate_info": {
        "commit_hash": "5c3cdb44d5bcde46cb868de020a74bad47c8f3da",
        "repo": "radare/radare2",
        "commit_url": "https://github.com/radare/radare2/commit/5c3cdb44d5bcde46cb868de020a74bad47c8f3da",
        "files": [
          "libr/asm/arch/wasm/wasm.c"
        ],
        "message": "Fixed coverity errors (#8595)",
        "before_after_code_files": [
          "libr/asm/arch/wasm/wasm.c||libr/asm/arch/wasm/wasm.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libr/asm/arch/wasm/wasm.c||libr/asm/arch/wasm/wasm.c"
          ],
          "candidate": [
            "libr/asm/arch/wasm/wasm.c||libr/asm/arch/wasm/wasm.c"
          ]
        }
      },
      "candidate_diff": {
        "libr/asm/arch/wasm/wasm.c||libr/asm/arch/wasm/wasm.c": [
          "File: libr/asm/arch/wasm/wasm.c -> libr/asm/arch/wasm/wasm.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "416: int wasm_dis(WasmOp *op, const unsigned char *buf, int buf_len) {",
          "417:  op->len = 1;",
          "418:  op->op = buf[0];",
          "419:  WasmOpDef *opdef = &opcodes[op->op];",
          "423:  switch (op->op) {",
          "424:  case WASM_OP_TRAP:",
          "425:  case WASM_OP_NOP:",
          "",
          "[Removed Lines]",
          "420:  if (!opdef) {",
          "421:   return op->len;",
          "422:  }",
          "",
          "[Added Lines]",
          "419:  if (op->op > 0xbf) return 1;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "606:    op->len += n;",
          "607:    for (i = 0; i < count; i++) {",
          "608:     n = read_u32_leb128 (buf + op->len, buf + buf_len, &table[i]);",
          "610:     op->len += n;",
          "611:    }",
          "612:    n = read_u32_leb128 (buf + op->len, buf + buf_len, &def);",
          "614:    op->len += n;",
          "615:    snprintf (op->txt, R_ASM_BUFSIZE, \"%s %d \", opdef->txt, count);",
          "617:     snprintf (op->txt + strlen (op->txt), R_ASM_BUFSIZE, \"%d \", table[i]);",
          "618:    }",
          "619:    snprintf (op->txt + strlen (op->txt), R_ASM_BUFSIZE, \"%d\", def);",
          "620:   }",
          "621:   break;",
          "622:  case WASM_OP_CALLINDIRECT:",
          "",
          "[Removed Lines]",
          "609:     if (!(op->len + n <= buf_len)) goto err;",
          "613:    if (!(n > 0 && n + op->len < buf_len)) goto err;",
          "616:    for (i = 0; i < count; i++) {",
          "",
          "[Added Lines]",
          "608:     if (!(op->len + n <= buf_len)) goto beach;",
          "612:    if (!(n > 0 && n + op->len < buf_len)) goto beach;",
          "615:    for (i = 0; i < count && strlen (op->txt) < R_ASM_BUFSIZE; i++) {",
          "619:    free (table);",
          "620:    break;",
          "621:    beach:",
          "622:     free (table);",
          "623:     goto err;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "52b1526443c1f433087928291d1c3d37a5600515",
      "candidate_info": {
        "commit_hash": "52b1526443c1f433087928291d1c3d37a5600515",
        "repo": "radare/radare2",
        "commit_url": "https://github.com/radare/radare2/commit/52b1526443c1f433087928291d1c3d37a5600515",
        "files": [
          "libr/asm/arch/wasm/wasm.c",
          "libr/flag/flag.c"
        ],
        "message": "Fix crash in wasm disassembler",
        "before_after_code_files": [
          "libr/asm/arch/wasm/wasm.c||libr/asm/arch/wasm/wasm.c",
          "libr/flag/flag.c||libr/flag/flag.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libr/asm/arch/wasm/wasm.c||libr/asm/arch/wasm/wasm.c"
          ],
          "candidate": [
            "libr/asm/arch/wasm/wasm.c||libr/asm/arch/wasm/wasm.c"
          ]
        }
      },
      "candidate_diff": {
        "libr/asm/arch/wasm/wasm.c||libr/asm/arch/wasm/wasm.c": [
          "File: libr/asm/arch/wasm/wasm.c -> libr/asm/arch/wasm/wasm.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "416: int wasm_dis(WasmOp *op, const unsigned char *buf, int buf_len) {",
          "417:  op->len = 1;",
          "418:  op->op = buf[0];",
          "421:  WasmOpDef *opdef = &opcodes[op->op];",
          "422:  switch (op->op) {",
          "",
          "[Removed Lines]",
          "419:  if (op->op > 0xbf) return 1;",
          "",
          "[Added Lines]",
          "419:  if (op->op > 0xbf) {",
          "420:   return 1;",
          "421:  }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "599:   {",
          "600:    ut32 count = 0, *table = NULL, def = 0;",
          "601:    size_t n = read_u32_leb128 (buf + 1, buf + buf_len, &count);",
          "604:    int i = 0;",
          "605:    op->len += n;",
          "606:    for (i = 0; i < count; i++) {",
          "607:     n = read_u32_leb128 (buf + op->len, buf + buf_len, &table[i]);",
          "609:     op->len += n;",
          "610:    }",
          "611:    n = read_u32_leb128 (buf + op->len, buf + buf_len, &def);",
          "613:    op->len += n;",
          "614:    snprintf (op->txt, R_ASM_BUFSIZE, \"%s %d \", opdef->txt, count);",
          "617:    }",
          "618:    snprintf (op->txt + strlen (op->txt), R_ASM_BUFSIZE, \"%d\", def);",
          "619:    free (table);",
          "620:    break;",
          "621:    beach:",
          "624:   }",
          "625:   break;",
          "626:  case WASM_OP_CALLINDIRECT:",
          "",
          "[Removed Lines]",
          "602:    if (!(n > 0 && n < buf_len)) goto err;",
          "603:    if (!(table = calloc (count, sizeof (ut32)))) goto err;",
          "608:     if (!(op->len + n <= buf_len)) goto beach;",
          "612:    if (!(n > 0 && n + op->len < buf_len)) goto beach;",
          "615:    for (i = 0; i < count && strlen (op->txt) < R_ASM_BUFSIZE; i++) {",
          "616:     snprintf (op->txt + strlen (op->txt), R_ASM_BUFSIZE, \"%d \", table[i]);",
          "622:     free (table);",
          "623:     goto err;",
          "",
          "[Added Lines]",
          "604:    if (!(n > 0 && n < buf_len)) {",
          "605:     goto err;",
          "606:    }",
          "607:    if (!(table = calloc (count, sizeof (ut32)))) {",
          "608:     goto err;",
          "609:    }",
          "614:     if (!(op->len + n <= buf_len)) {",
          "615:      goto beach;",
          "616:     }",
          "620:    if (!(n > 0 && n + op->len < buf_len)) {",
          "621:     goto beach;",
          "622:    }",
          "625:    for (i = 0; i < count && strlen (op->txt) + 10 < R_ASM_BUFSIZE; i++) {",
          "626:     int optxtlen = strlen (op->txt);",
          "627:     snprintf (op->txt + optxtlen, R_ASM_BUFSIZE - optxtlen, \"%d \", table[i]);",
          "633:    free (table);",
          "634:    goto err;",
          "",
          "---------------"
        ],
        "libr/flag/flag.c||libr/flag/flag.c": [
          "File: libr/flag/flag.c -> libr/flag/flag.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "74:  dir == -1 -> result <= off",
          "75:  dir == 0 ->  result == off",
          "78:  RFlagsAtOffset *flags = NULL;",
          "79:  RFlagsAtOffset key;",
          "80:  key.off = off;",
          "",
          "[Removed Lines]",
          "77: static  RFlagsAtOffset* r_flag_get_nearest_list(RFlag *f, ut64 off, int dir) {",
          "",
          "[Added Lines]",
          "77: static RFlagsAtOffset* r_flag_get_nearest_list(RFlag *f, ut64 off, int dir) {",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "ddb925a9b32c0ddf623bd8aea8431737c2365bb8",
      "candidate_info": {
        "commit_hash": "ddb925a9b32c0ddf623bd8aea8431737c2365bb8",
        "repo": "radare/radare2",
        "commit_url": "https://github.com/radare/radare2/commit/ddb925a9b32c0ddf623bd8aea8431737c2365bb8",
        "files": [
          "libr/anal/p/anal_wasm.c",
          "libr/asm/arch/wasm/wasm.c",
          "libr/asm/arch/wasm/wasm.h"
        ],
        "message": "Add initial Wasm support for atomic instructions. Fix get func offset from id. (#12833)",
        "before_after_code_files": [
          "libr/anal/p/anal_wasm.c||libr/anal/p/anal_wasm.c",
          "libr/asm/arch/wasm/wasm.c||libr/asm/arch/wasm/wasm.c",
          "libr/asm/arch/wasm/wasm.h||libr/asm/arch/wasm/wasm.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libr/asm/arch/wasm/wasm.c||libr/asm/arch/wasm/wasm.c"
          ],
          "candidate": [
            "libr/asm/arch/wasm/wasm.c||libr/asm/arch/wasm/wasm.c"
          ]
        }
      },
      "candidate_diff": {
        "libr/anal/p/anal_wasm.c||libr/anal/p/anal_wasm.c": [
          "File: libr/anal/p/anal_wasm.c -> libr/anal/p/anal_wasm.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "23:   return UT64_MAX;",
          "24:  }",
          "25:  r_cons_push ();",
          "28:  r_cons_pop ();",
          "29:  if (s) {",
          "30:   ut64 n = r_num_get (NULL, s);",
          "",
          "[Removed Lines]",
          "27:  char *s = anal->coreb.cmdstrf (anal->coreb.core, \"isq~0x0[0:%u]\", fcn_id);",
          "",
          "[Added Lines]",
          "28:  char *s = anal->coreb.cmdstrf (anal->coreb.core, \"is~FUNC[2:%u]\", fcn_id);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "42:  int size = 0;",
          "43:  while (anal->iob.read_at (anal->iob.io, address, buffer, sizeof (buffer))) {",
          "44:   size = wasm_dis (&wop, ptr, end - ptr);",
          "47:    break;",
          "48:   }",
          "65:   }",
          "66:   address += size;",
          "67:  }",
          "",
          "[Removed Lines]",
          "45:   if (!wop.txt || wop.op == WASM_OP_TRAP) {",
          "50:   if (wop.op == WASM_OP_LOOP || wop.op == WASM_OP_BLOCK || wop.op == WASM_OP_IF) {",
          "51:    depth++;",
          "52:   }",
          "54:   if (use_else && wop.op == WASM_OP_ELSE && !depth) {",
          "55:    op->type = expected_type;",
          "56:    op->jump = address + 1; // else size == 1",
          "57:    return true;",
          "58:   } else if (wop.op == WASM_OP_END && depth > 0) {",
          "60:    depth--;",
          "61:   } else if (wop.op == WASM_OP_END && !depth) {",
          "62:    op->type = expected_type;",
          "63:    op->jump = address;",
          "64:    return true;",
          "",
          "[Added Lines]",
          "46:   if (!wop.txt || (wop.type == WASM_TYPE_OP_CORE && wop.op.core == WASM_OP_TRAP)) {",
          "50:   if (wop.type == WASM_TYPE_OP_CORE) {",
          "51:    WasmOpCodes wopop = wop.op.core;",
          "52:    if (wopop == WASM_OP_LOOP || wopop == WASM_OP_BLOCK || wopop == WASM_OP_IF) {",
          "53:     depth++;",
          "54:    }",
          "55:    if (use_else && wopop == WASM_OP_ELSE && !depth) {",
          "56:     op->type = expected_type;",
          "57:     op->jump = address + 1; // else size == 1",
          "58:     return true;",
          "59:    } else if (wopop == WASM_OP_END && depth > 0) {",
          "61:     depth--;",
          "62:    } else if (wopop == WASM_OP_END && !depth) {",
          "63:     op->type = expected_type;",
          "64:     op->jump = address;",
          "65:     return true;",
          "66:    }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "81:  op->addr = addr;",
          "82:  op->sign = true;",
          "83:  op->type = R_ANAL_OP_TYPE_UNK;",
          "86:  if (!wop.txt || !strncmp (wop.txt, \"invalid\", 7)) {",
          "87:   op->type = R_ANAL_OP_TYPE_ILL;",
          "",
          "[Removed Lines]",
          "84:  op->id = wop.op;",
          "",
          "[Added Lines]",
          "86:  switch (wop.type) {",
          "87:   case WASM_TYPE_OP_CORE:",
          "88:    op->id = wop.op.core;",
          "89:    break;",
          "90:   case WASM_TYPE_OP_ATOMIC:",
          "91:    op->id = (0xfe << 8) | wop.op.atomic;",
          "92:    break;",
          "93:  }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "89:   return -1;",
          "90:  }",
          "93:   goto anal_end;",
          "94:  }",
          "120:     op->fail = addr + op->size;",
          "121:    }",
          "143:     op->type = R_ANAL_OP_TYPE_JMP;",
          "147:      op->type = R_ANAL_OP_TYPE_JMP;",
          "150:     } else {",
          "151:      if (advance_till_scope_end (anal, op, addr + op->size, R_ANAL_OP_TYPE_JMP, val, false)) {",
          "152:       r_anal_hint_set_jump (anal, addr, op->jump);",
          "153:      }",
          "154:     }",
          "162:    }",
          "177:      op->fail = addr + op->size;",
          "180:     } else {",
          "181:      if (advance_till_scope_end (anal, op, addr + op->size, R_ANAL_OP_TYPE_CJMP, val, false)) {",
          "182:       op->fail = addr + op->size;",
          "183:       r_anal_hint_set_jump (anal, addr, op->jump);",
          "184:      }",
          "185:     }",
          "191:     } else {",
          "193:     }",
          "194:    }",
          "200:    op->type = R_ANAL_OP_TYPE_NOP;",
          "228:    }",
          "229:   }",
          "230:   break;",
          "333:   }",
          "339:  default:",
          "340:   break;",
          "341:  }",
          "",
          "[Removed Lines]",
          "92:  if (addr_old == addr && wop.op != WASM_OP_END) {",
          "96:  switch (wop.op) {",
          "98:  case WASM_OP_LOOP:",
          "99:   op->type = R_ANAL_OP_TYPE_NOP;",
          "100:   if (!(hint = r_anal_hint_get (anal, addr))) {",
          "101:    scope_hint--;",
          "102:    r_anal_hint_set_opcode (anal, scope_hint, \"loop\");",
          "103:    r_anal_hint_set_jump (anal, scope_hint, addr);",
          "104:   }",
          "105:   break;",
          "106:  case WASM_OP_BLOCK:",
          "107:   op->type = R_ANAL_OP_TYPE_NOP;",
          "108:   if (!(hint = r_anal_hint_get (anal, addr))) {",
          "109:    scope_hint--;",
          "110:    r_anal_hint_set_opcode (anal, scope_hint, \"block\");",
          "111:    r_anal_hint_set_jump (anal, scope_hint, addr);",
          "112:   }",
          "113:   break;",
          "114:  case WASM_OP_IF:",
          "115:   if (!(hint = r_anal_hint_get (anal, addr))) {",
          "116:    scope_hint--;",
          "117:    r_anal_hint_set_opcode (anal, scope_hint, \"if\");",
          "118:    r_anal_hint_set_jump (anal, scope_hint, addr);",
          "119:    if (advance_till_scope_end (anal, op, addr + op->size, R_ANAL_OP_TYPE_CJMP, 0, true)) {",
          "122:   } else {",
          "123:    op->type = R_ANAL_OP_TYPE_CJMP;",
          "124:    op->jump = hint->jump;",
          "125:    op->fail = addr + op->size;",
          "126:   }",
          "127:   break;",
          "128:  case WASM_OP_ELSE:",
          "130:   if (!(hint = r_anal_hint_get (anal, addr))) {",
          "131:    advance_till_scope_end (anal, op, addr + op->size, R_ANAL_OP_TYPE_JMP, 0, true);",
          "132:   } else {",
          "133:    op->type = R_ANAL_OP_TYPE_JMP;",
          "134:    op->jump = hint->jump;",
          "135:   }",
          "136:   break;",
          "137:  case WASM_OP_BR:",
          "138:   {",
          "139:    RAnalHint *hint2 = NULL;",
          "140:    ut32 val;",
          "141:    read_u32_leb128 (data + 1, data + len, &val);",
          "142:    if ((hint2 = r_anal_hint_get (anal, addr)) && hint2->jump != UT64_MAX) {",
          "144:     op->jump = hint2->jump;",
          "145:    } else if ((hint = r_anal_hint_get (anal, scope_hint))) {",
          "146:     if (hint->opcode && !strncmp (\"loop\", hint->opcode, 4)) {",
          "148:      op->jump = hint->jump;",
          "149:      r_anal_hint_set_jump (anal, addr, op->jump);",
          "155:    } else {",
          "156:     if (advance_till_scope_end (anal, op, addr + op->size, R_ANAL_OP_TYPE_JMP, val, false)) {",
          "157:      eprintf (\"[wasm] cannot find jump type for br (using block type)\\n\");",
          "158:      r_anal_hint_set_jump (anal, addr, op->jump);",
          "159:     } else {",
          "160:      eprintf (\"[wasm] cannot find jump for br\\n\");",
          "161:     }",
          "163:    r_anal_hint_free (hint2);",
          "164:   }",
          "165:   break;",
          "166:  case WASM_OP_BRIF:",
          "167:   {",
          "168:    RAnalHint *hint2 = NULL;",
          "169:    ut32 val;",
          "170:    read_u32_leb128 (data + 1, data + len, &val);",
          "171:    if ((hint2 = r_anal_hint_get (anal, addr)) && hint2->jump != UT64_MAX) {",
          "172:     op->type = R_ANAL_OP_TYPE_CJMP;",
          "173:     op->jump = hint2->jump;",
          "174:     op->fail = addr + op->size;",
          "175:    } else if ((hint = r_anal_hint_get (anal, scope_hint))) {",
          "176:     if (hint->opcode && !strncmp (\"loop\", hint->opcode, 4)) {",
          "178:      op->jump = hint->jump;",
          "179:      r_anal_hint_set_jump (anal, addr, op->jump);",
          "186:    } else {",
          "187:     if (advance_till_scope_end (anal, op, addr + op->size, R_ANAL_OP_TYPE_CJMP, val, false)) {",
          "188:      eprintf (\"[wasm] cannot find jump type for br_if (using block type)\\n\");",
          "189:      op->fail = addr + op->size;",
          "190:      r_anal_hint_set_jump (anal, addr, op->jump);",
          "192:      eprintf (\"[wasm] cannot find jump for br_if\\n\");",
          "195:    r_anal_hint_free (hint2);",
          "196:   }",
          "197:   break;",
          "198:  case WASM_OP_END:",
          "199:   {",
          "201:    if (scope_hint < UT64_MAX) {",
          "202:     hint = r_anal_hint_get (anal, scope_hint);",
          "203:     if (hint && !strncmp (\"loop\", hint->opcode, 4)) {",
          "204:      r_anal_hint_set_jump (anal, addr, op->jump);",
          "205:      r_anal_hint_set_jump (anal, op->jump, addr);",
          "206:     } else if (hint && !strncmp (\"block\", hint->opcode, 5)) {",
          "208:      r_anal_hint_set_jump (anal, hint->jump, addr);",
          "209:      r_anal_hint_set_jump (anal, addr, UT64_MAX);",
          "210:     }",
          "211:     if (hint) {",
          "212:      r_anal_hint_set_opcode (anal, scope_hint, \"invalid\");",
          "213:      r_anal_hint_set_jump (anal, scope_hint, UT64_MAX);",
          "214:      r_anal_hint_del (anal, scope_hint, 1);",
          "215:      scope_hint++;",
          "216:     } else {",
          "218:      op->eob = true;",
          "219:      op->type = R_ANAL_OP_TYPE_RET;",
          "220:      scope_hint = UT64_MAX;",
          "221:     }",
          "222:    } else {",
          "223:     if (!(hint = r_anal_hint_get (anal, addr))) {",
          "225:      op->eob = true;",
          "226:      op->type = R_ANAL_OP_TYPE_RET;",
          "227:     }",
          "231:  case WASM_OP_I32REMS:",
          "232:  case WASM_OP_I32REMU:",
          "233:   op->type = R_ANAL_OP_TYPE_MOD;",
          "234:   break;",
          "235:  case WASM_OP_GETLOCAL:",
          "236:  case WASM_OP_I32LOAD:",
          "237:  case WASM_OP_I64LOAD:",
          "238:  case WASM_OP_F32LOAD:",
          "239:  case WASM_OP_F64LOAD:",
          "240:  case WASM_OP_I32LOAD8S:",
          "241:  case WASM_OP_I32LOAD8U:",
          "242:  case WASM_OP_I32LOAD16S:",
          "243:  case WASM_OP_I32LOAD16U:",
          "244:  case WASM_OP_I64LOAD8S:",
          "245:  case WASM_OP_I64LOAD8U:",
          "246:  case WASM_OP_I64LOAD16S:",
          "247:  case WASM_OP_I64LOAD16U:",
          "248:  case WASM_OP_I64LOAD32S:",
          "249:  case WASM_OP_I64LOAD32U:",
          "250:   op->type = R_ANAL_OP_TYPE_LOAD;",
          "251:   break;",
          "252:  case WASM_OP_SETLOCAL:",
          "253:  case WASM_OP_TEELOCAL:",
          "254:   op->type = R_ANAL_OP_TYPE_STORE;",
          "255:   break;",
          "256:  case WASM_OP_I32EQZ:",
          "257:  case WASM_OP_I32EQ:",
          "258:  case WASM_OP_I32NE:",
          "259:  case WASM_OP_I32LTS:",
          "260:  case WASM_OP_I32LTU:",
          "261:  case WASM_OP_I32GTS:",
          "262:  case WASM_OP_I32GTU:",
          "263:  case WASM_OP_I32LES:",
          "264:  case WASM_OP_I32LEU:",
          "265:  case WASM_OP_I32GES:",
          "266:  case WASM_OP_I32GEU:",
          "267:  case WASM_OP_I64EQZ:",
          "268:  case WASM_OP_I64EQ:",
          "269:  case WASM_OP_I64NE:",
          "270:  case WASM_OP_I64LTS:",
          "271:  case WASM_OP_I64LTU:",
          "272:  case WASM_OP_I64GTS:",
          "273:  case WASM_OP_I64GTU:",
          "274:  case WASM_OP_I64LES:",
          "275:  case WASM_OP_I64LEU:",
          "276:  case WASM_OP_I64GES:",
          "277:  case WASM_OP_I64GEU:",
          "278:  case WASM_OP_F32EQ:",
          "279:  case WASM_OP_F32NE:",
          "280:  case WASM_OP_F32LT:",
          "281:  case WASM_OP_F32GT:",
          "282:  case WASM_OP_F32LE:",
          "283:  case WASM_OP_F32GE:",
          "284:  case WASM_OP_F64EQ:",
          "285:  case WASM_OP_F64NE:",
          "286:  case WASM_OP_F64LT:",
          "287:  case WASM_OP_F64GT:",
          "288:  case WASM_OP_F64LE:",
          "289:  case WASM_OP_F64GE:",
          "290:   op->type = R_ANAL_OP_TYPE_CMP;",
          "291:   break;",
          "292:  case WASM_OP_I64OR:",
          "293:  case WASM_OP_I32OR:",
          "294:   op->type = R_ANAL_OP_TYPE_OR;",
          "295:   break;",
          "296:  case WASM_OP_I64XOR:",
          "297:  case WASM_OP_I32XOR:",
          "298:   op->type = R_ANAL_OP_TYPE_XOR;",
          "299:   break;",
          "300:  case WASM_OP_I32CONST:",
          "301:  case WASM_OP_I64CONST:",
          "302:  case WASM_OP_F32CONST:",
          "303:  case WASM_OP_F64CONST:",
          "304:   op->type = R_ANAL_OP_TYPE_MOV;",
          "305:   {",
          "306:    ut8 arg = data[1];",
          "307:    r_strbuf_setf (&op->esil, \"4,sp,-=,%d,sp,=[4]\", arg);",
          "308:   }",
          "309:   break;",
          "310:  case WASM_OP_I64ADD:",
          "311:  case WASM_OP_I32ADD:",
          "312:  case WASM_OP_F32ADD:",
          "313:  case WASM_OP_F64ADD:",
          "314:   op->type = R_ANAL_OP_TYPE_ADD;",
          "315:   break;",
          "316:  case WASM_OP_I64SUB:",
          "317:  case WASM_OP_I32SUB:",
          "318:  case WASM_OP_F32SUB:",
          "319:  case WASM_OP_F64SUB:",
          "320:   op->type = R_ANAL_OP_TYPE_SUB;",
          "321:   break;",
          "322:  case WASM_OP_NOP:",
          "323:   op->type = R_ANAL_OP_TYPE_NOP;",
          "324:   r_strbuf_setf (&op->esil, \"\");",
          "325:   break;",
          "326:  case WASM_OP_CALL:",
          "327:  case WASM_OP_CALLINDIRECT:",
          "328:   op->type = R_ANAL_OP_TYPE_CALL;",
          "329:   op->jump = get_cf_offset (anal, data, len);",
          "330:   op->fail = addr + op->size;",
          "331:   if (op->jump != UT64_MAX) {",
          "332:    op->ptr = op->jump;",
          "334:   r_strbuf_setf (&op->esil, \"4,sp,-=,0x%\"PFMT64x\",sp,=[4],0x%\"PFMT64x\",pc,=\", op->fail, op->jump);",
          "335:   break;",
          "336:  case WASM_OP_RETURN:",
          "338:   op->type = R_ANAL_OP_TYPE_CRET;",
          "",
          "[Added Lines]",
          "101:  if (addr_old == addr && (wop.type != WASM_TYPE_OP_CORE || wop.op.core != WASM_OP_END)) {",
          "105:  switch (wop.type) {",
          "106:  case WASM_TYPE_OP_CORE:",
          "107:   switch (wop.op.core) {",
          "109:   case WASM_OP_LOOP:",
          "110:    op->type = R_ANAL_OP_TYPE_NOP;",
          "111:    if (!(hint = r_anal_hint_get (anal, addr))) {",
          "112:     scope_hint--;",
          "113:     r_anal_hint_set_opcode (anal, scope_hint, \"loop\");",
          "114:     r_anal_hint_set_jump (anal, scope_hint, addr);",
          "115:    }",
          "116:    break;",
          "117:   case WASM_OP_BLOCK:",
          "118:    op->type = R_ANAL_OP_TYPE_NOP;",
          "119:    if (!(hint = r_anal_hint_get (anal, addr))) {",
          "120:     scope_hint--;",
          "121:     r_anal_hint_set_opcode (anal, scope_hint, \"block\");",
          "122:     r_anal_hint_set_jump (anal, scope_hint, addr);",
          "123:    }",
          "124:    break;",
          "125:   case WASM_OP_IF:",
          "126:    if (!(hint = r_anal_hint_get (anal, addr))) {",
          "127:     scope_hint--;",
          "128:     r_anal_hint_set_opcode (anal, scope_hint, \"if\");",
          "129:     r_anal_hint_set_jump (anal, scope_hint, addr);",
          "130:     if (advance_till_scope_end (anal, op, addr + op->size, R_ANAL_OP_TYPE_CJMP, 0, true)) {",
          "131:      op->fail = addr + op->size;",
          "132:     }",
          "133:    } else {",
          "134:     op->type = R_ANAL_OP_TYPE_CJMP;",
          "135:     op->jump = hint->jump;",
          "138:    break;",
          "139:   case WASM_OP_ELSE:",
          "141:    if (!(hint = r_anal_hint_get (anal, addr))) {",
          "142:     advance_till_scope_end (anal, op, addr + op->size, R_ANAL_OP_TYPE_JMP, 0, true);",
          "143:    } else {",
          "145:     op->jump = hint->jump;",
          "146:    }",
          "147:    break;",
          "148:   case WASM_OP_BR:",
          "149:    {",
          "150:     RAnalHint *hint2 = NULL;",
          "151:     ut32 val;",
          "152:     read_u32_leb128 (data + 1, data + len, &val);",
          "153:     if ((hint2 = r_anal_hint_get (anal, addr)) && hint2->jump != UT64_MAX) {",
          "155:      op->jump = hint2->jump;",
          "156:     } else if ((hint = r_anal_hint_get (anal, scope_hint))) {",
          "157:      if (hint->opcode && !strncmp (\"loop\", hint->opcode, 4)) {",
          "158:       op->type = R_ANAL_OP_TYPE_JMP;",
          "159:       op->jump = hint->jump;",
          "160:       r_anal_hint_set_jump (anal, addr, op->jump);",
          "161:      } else {",
          "162:       if (advance_till_scope_end (anal, op, addr + op->size, R_ANAL_OP_TYPE_JMP, val, false)) {",
          "163:        r_anal_hint_set_jump (anal, addr, op->jump);",
          "164:       }",
          "165:      }",
          "168:       eprintf (\"[wasm] cannot find jump type for br (using block type)\\n\");",
          "170:      } else {",
          "171:       eprintf (\"[wasm] cannot find jump for br\\n\");",
          "174:     r_anal_hint_free (hint2);",
          "176:    break;",
          "177:   case WASM_OP_BRIF:",
          "178:    {",
          "179:     RAnalHint *hint2 = NULL;",
          "180:     ut32 val;",
          "181:     read_u32_leb128 (data + 1, data + len, &val);",
          "182:     if ((hint2 = r_anal_hint_get (anal, addr)) && hint2->jump != UT64_MAX) {",
          "183:      op->type = R_ANAL_OP_TYPE_CJMP;",
          "184:      op->jump = hint2->jump;",
          "186:     } else if ((hint = r_anal_hint_get (anal, scope_hint))) {",
          "187:      if (hint->opcode && !strncmp (\"loop\", hint->opcode, 4)) {",
          "188:       op->fail = addr + op->size;",
          "189:       op->jump = hint->jump;",
          "190:       r_anal_hint_set_jump (anal, addr, op->jump);",
          "191:      } else {",
          "192:       if (advance_till_scope_end (anal, op, addr + op->size, R_ANAL_OP_TYPE_CJMP, val, false)) {",
          "193:        op->fail = addr + op->size;",
          "194:        r_anal_hint_set_jump (anal, addr, op->jump);",
          "195:       }",
          "196:      }",
          "199:       eprintf (\"[wasm] cannot find jump type for br_if (using block type)\\n\");",
          "202:      } else {",
          "203:       eprintf (\"[wasm] cannot find jump for br_if\\n\");",
          "206:     r_anal_hint_free (hint2);",
          "207:    }",
          "208:    break;",
          "209:   case WASM_OP_END:",
          "210:    {",
          "211:     op->type = R_ANAL_OP_TYPE_NOP;",
          "212:     if (scope_hint < UT64_MAX) {",
          "213:      hint = r_anal_hint_get (anal, scope_hint);",
          "214:      if (hint && !strncmp (\"loop\", hint->opcode, 4)) {",
          "215:       r_anal_hint_set_jump (anal, addr, op->jump);",
          "216:       r_anal_hint_set_jump (anal, op->jump, addr);",
          "217:      } else if (hint && !strncmp (\"block\", hint->opcode, 5)) {",
          "219:       r_anal_hint_set_jump (anal, hint->jump, addr);",
          "220:       r_anal_hint_set_jump (anal, addr, UT64_MAX);",
          "221:      }",
          "222:      if (hint) {",
          "223:       r_anal_hint_set_opcode (anal, scope_hint, \"invalid\");",
          "224:       r_anal_hint_set_jump (anal, scope_hint, UT64_MAX);",
          "225:       r_anal_hint_del (anal, scope_hint, 1);",
          "226:       scope_hint++;",
          "227:      } else {",
          "229:       op->eob = true;",
          "230:       op->type = R_ANAL_OP_TYPE_RET;",
          "231:       scope_hint = UT64_MAX;",
          "232:      }",
          "234:      if (!(hint = r_anal_hint_get (anal, addr))) {",
          "236:       op->eob = true;",
          "237:       op->type = R_ANAL_OP_TYPE_RET;",
          "238:      }",
          "241:    break;",
          "242:   case WASM_OP_I32REMS:",
          "243:   case WASM_OP_I32REMU:",
          "244:    op->type = R_ANAL_OP_TYPE_MOD;",
          "245:    break;",
          "246:   case WASM_OP_GETLOCAL:",
          "247:   case WASM_OP_I32LOAD:",
          "248:   case WASM_OP_I64LOAD:",
          "249:   case WASM_OP_F32LOAD:",
          "250:   case WASM_OP_F64LOAD:",
          "251:   case WASM_OP_I32LOAD8S:",
          "252:   case WASM_OP_I32LOAD8U:",
          "253:   case WASM_OP_I32LOAD16S:",
          "254:   case WASM_OP_I32LOAD16U:",
          "255:   case WASM_OP_I64LOAD8S:",
          "256:   case WASM_OP_I64LOAD8U:",
          "257:   case WASM_OP_I64LOAD16S:",
          "258:   case WASM_OP_I64LOAD16U:",
          "259:   case WASM_OP_I64LOAD32S:",
          "260:   case WASM_OP_I64LOAD32U:",
          "261:    op->type = R_ANAL_OP_TYPE_LOAD;",
          "262:    break;",
          "263:   case WASM_OP_SETLOCAL:",
          "264:   case WASM_OP_TEELOCAL:",
          "265:    op->type = R_ANAL_OP_TYPE_STORE;",
          "266:    break;",
          "267:   case WASM_OP_I32EQZ:",
          "268:   case WASM_OP_I32EQ:",
          "269:   case WASM_OP_I32NE:",
          "270:   case WASM_OP_I32LTS:",
          "271:   case WASM_OP_I32LTU:",
          "272:   case WASM_OP_I32GTS:",
          "273:   case WASM_OP_I32GTU:",
          "274:   case WASM_OP_I32LES:",
          "275:   case WASM_OP_I32LEU:",
          "276:   case WASM_OP_I32GES:",
          "277:   case WASM_OP_I32GEU:",
          "278:   case WASM_OP_I64EQZ:",
          "279:   case WASM_OP_I64EQ:",
          "280:   case WASM_OP_I64NE:",
          "281:   case WASM_OP_I64LTS:",
          "282:   case WASM_OP_I64LTU:",
          "283:   case WASM_OP_I64GTS:",
          "284:   case WASM_OP_I64GTU:",
          "285:   case WASM_OP_I64LES:",
          "286:   case WASM_OP_I64LEU:",
          "287:   case WASM_OP_I64GES:",
          "288:   case WASM_OP_I64GEU:",
          "289:   case WASM_OP_F32EQ:",
          "290:   case WASM_OP_F32NE:",
          "291:   case WASM_OP_F32LT:",
          "292:   case WASM_OP_F32GT:",
          "293:   case WASM_OP_F32LE:",
          "294:   case WASM_OP_F32GE:",
          "295:   case WASM_OP_F64EQ:",
          "296:   case WASM_OP_F64NE:",
          "297:   case WASM_OP_F64LT:",
          "298:   case WASM_OP_F64GT:",
          "299:   case WASM_OP_F64LE:",
          "300:   case WASM_OP_F64GE:",
          "301:    op->type = R_ANAL_OP_TYPE_CMP;",
          "302:    break;",
          "303:   case WASM_OP_I64OR:",
          "304:   case WASM_OP_I32OR:",
          "305:    op->type = R_ANAL_OP_TYPE_OR;",
          "306:    break;",
          "307:   case WASM_OP_I64XOR:",
          "308:   case WASM_OP_I32XOR:",
          "309:    op->type = R_ANAL_OP_TYPE_XOR;",
          "310:    break;",
          "311:   case WASM_OP_I32CONST:",
          "312:   case WASM_OP_I64CONST:",
          "313:   case WASM_OP_F32CONST:",
          "314:   case WASM_OP_F64CONST:",
          "315:    op->type = R_ANAL_OP_TYPE_MOV;",
          "316:    {",
          "317:     ut8 arg = data[1];",
          "318:     r_strbuf_setf (&op->esil, \"4,sp,-=,%d,sp,=[4]\", arg);",
          "319:    }",
          "320:    break;",
          "321:   case WASM_OP_I64ADD:",
          "322:   case WASM_OP_I32ADD:",
          "323:   case WASM_OP_F32ADD:",
          "324:   case WASM_OP_F64ADD:",
          "325:    op->type = R_ANAL_OP_TYPE_ADD;",
          "326:    break;",
          "327:   case WASM_OP_I64SUB:",
          "328:   case WASM_OP_I32SUB:",
          "329:   case WASM_OP_F32SUB:",
          "330:   case WASM_OP_F64SUB:",
          "331:    op->type = R_ANAL_OP_TYPE_SUB;",
          "332:    break;",
          "333:   case WASM_OP_NOP:",
          "335:    r_strbuf_setf (&op->esil, \"\");",
          "336:    break;",
          "337:   case WASM_OP_CALL:",
          "338:   case WASM_OP_CALLINDIRECT:",
          "339:    op->type = R_ANAL_OP_TYPE_CALL;",
          "340:    op->jump = get_cf_offset (anal, data, len);",
          "341:    op->fail = addr + op->size;",
          "342:    if (op->jump != UT64_MAX) {",
          "343:     op->ptr = op->jump;",
          "345:    r_strbuf_setf (&op->esil, \"4,sp,-=,0x%\"PFMT64x\",sp,=[4],0x%\"PFMT64x\",pc,=\", op->fail, op->jump);",
          "346:    break;",
          "347:   case WASM_OP_RETURN:",
          "349:    op->type = R_ANAL_OP_TYPE_CRET;",
          "350:   default:",
          "351:    break;",
          "354:  case WASM_TYPE_OP_ATOMIC:",
          "355:   switch (wop.op.atomic) {",
          "356:   case WASM_OP_I32ATOMICLOAD:",
          "357:   case WASM_OP_I64ATOMICLOAD:",
          "358:   case WASM_OP_I32ATOMICLOAD8U:",
          "359:   case WASM_OP_I32ATOMICLOAD16U:",
          "360:   case WASM_OP_I64ATOMICLOAD8U:",
          "361:   case WASM_OP_I64ATOMICLOAD16U:",
          "362:   case WASM_OP_I64ATOMICLOAD32U:",
          "363:    op->type = R_ANAL_OP_TYPE_LOAD;",
          "364:    break;",
          "365:   case WASM_OP_I32ATOMICSTORE:",
          "366:   case WASM_OP_I64ATOMICSTORE:",
          "367:   case WASM_OP_I32ATOMICSTORE8:",
          "368:   case WASM_OP_I32ATOMICSTORE16:",
          "369:   case WASM_OP_I64ATOMICSTORE8:",
          "370:   case WASM_OP_I64ATOMICSTORE16:",
          "371:   case WASM_OP_I64ATOMICSTORE32:",
          "372:    op->type = R_ANAL_OP_TYPE_STORE;",
          "373:    break;",
          "374:   case WASM_OP_I32ATOMICRMWADD:",
          "375:   case WASM_OP_I64ATOMICRMWADD:",
          "376:   case WASM_OP_I32ATOMICRMW8UADD:",
          "377:   case WASM_OP_I32ATOMICRMW16UADD:",
          "378:   case WASM_OP_I64ATOMICRMW8UADD:",
          "379:   case WASM_OP_I64ATOMICRMW16UADD:",
          "380:   case WASM_OP_I64ATOMICRMW32UADD:",
          "381:    op->type = R_ANAL_OP_TYPE_ADD;",
          "382:    break;",
          "383:   case WASM_OP_I32ATOMICRMW8USUB:",
          "384:   case WASM_OP_I32ATOMICRMW16USUB:",
          "385:   case WASM_OP_I32ATOMICRMWSUB:",
          "386:   case WASM_OP_I64ATOMICRMW8USUB:",
          "387:   case WASM_OP_I64ATOMICRMW16USUB:",
          "388:   case WASM_OP_I64ATOMICRMW32USUB:",
          "389:   case WASM_OP_I64ATOMICRMWSUB:",
          "390:    op->type = R_ANAL_OP_TYPE_SUB;",
          "391:    break;",
          "392:   case WASM_OP_I32ATOMICRMWAND:",
          "393:   case WASM_OP_I64ATOMICRMWAND:",
          "394:   case WASM_OP_I32ATOMICRMW8UAND:",
          "395:   case WASM_OP_I32ATOMICRMW16UAND:",
          "396:   case WASM_OP_I64ATOMICRMW8UAND:",
          "397:   case WASM_OP_I64ATOMICRMW16UAND:",
          "398:   case WASM_OP_I64ATOMICRMW32UAND:",
          "399:    op->type = R_ANAL_OP_TYPE_AND;",
          "400:    break;",
          "401:   case WASM_OP_I32ATOMICRMWOR:",
          "402:   case WASM_OP_I64ATOMICRMWOR:",
          "403:   case WASM_OP_I32ATOMICRMW8UOR:",
          "404:   case WASM_OP_I32ATOMICRMW16UOR:",
          "405:   case WASM_OP_I64ATOMICRMW8UOR:",
          "406:   case WASM_OP_I64ATOMICRMW16UOR:",
          "407:   case WASM_OP_I64ATOMICRMW32UOR:",
          "408:    op->type = R_ANAL_OP_TYPE_OR;",
          "409:    break;",
          "410:   case WASM_OP_I32ATOMICRMWXOR:",
          "411:   case WASM_OP_I64ATOMICRMWXOR:",
          "412:   case WASM_OP_I32ATOMICRMW8UXOR:",
          "413:   case WASM_OP_I32ATOMICRMW16UXOR:",
          "414:   case WASM_OP_I64ATOMICRMW8UXOR:",
          "415:   case WASM_OP_I64ATOMICRMW16UXOR:",
          "416:   case WASM_OP_I64ATOMICRMW32UXOR:",
          "417:    op->type = R_ANAL_OP_TYPE_XOR;",
          "418:    break;",
          "419:   case WASM_OP_I32ATOMICRMWXCHG:",
          "420:   case WASM_OP_I64ATOMICRMWXCHG:",
          "421:   case WASM_OP_I32ATOMICRMW8UXCHG:",
          "422:   case WASM_OP_I32ATOMICRMW16UXCHG:",
          "423:   case WASM_OP_I64ATOMICRMW8UXCHG:",
          "424:   case WASM_OP_I64ATOMICRMW16UXCHG:",
          "425:   case WASM_OP_I64ATOMICRMW32UXCHG:",
          "426:    op->type = R_ANAL_OP_TYPE_XCHG;",
          "427:    break;",
          "428:   default:",
          "429:    break;",
          "",
          "---------------"
        ],
        "libr/asm/arch/wasm/wasm.c||libr/asm/arch/wasm/wasm.c": [
          "File: libr/asm/arch/wasm/wasm.c -> libr/asm/arch/wasm/wasm.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "181:  [WASM_OP_I32REINTERPRETF32] = { \"i32.reinterpret/f32\", 1, 1 },",
          "182:  [WASM_OP_I64REINTERPRETF64] = { \"i64.reinterpret/f64\", 1, 1 },",
          "183:  [WASM_OP_F32REINTERPRETI32] = { \"f32.reinterpret/i32\", 1, 1 },",
          "185: };",
          "188: R_IPI int wasm_asm(const char *str, unsigned char *buf, int buf_len) {",
          "191:  char tmp[256];",
          "193:   tmp[i] = str[i];",
          "194:   i++;",
          "195:  }",
          "196:  tmp[i] = 0;",
          "197:  for (i = 0; i < 0xff; i++) {",
          "199:   if (opdef->txt) {",
          "200:    if (!strcmp (opdef->txt, tmp)) {",
          "203:    }",
          "204:   }",
          "205:  }",
          "206:  return len;",
          "207: }",
          "210: R_IPI int wasm_dis(WasmOp *op, const unsigned char *buf, int buf_len) {",
          "211:  RStrBuf *sb = r_strbuf_new (\"\");",
          "365:     r_strbuf_set (sb, opdef->txt);",
          "405:    }",
          "415:     }",
          "417:      break;",
          "418:     }",
          "419:     op->len += n;",
          "420:    }",
          "432:    break;",
          "444:    }",
          "448:     goto err;",
          "449:    }",
          "465:    }",
          "498:    }",
          "503:    }",
          "515:    }",
          "528:    }",
          "539:    }",
          "550:    }",
          "562:    }",
          "566:   }",
          "567:   break;",
          "569:   goto err;",
          "570:  }",
          "",
          "[Removed Lines]",
          "184:  [WASM_OP_F64REINTERPRETI64] = { \"f64/reinterpret/i64\", 1, 1 }",
          "190:  int i = 0, len = -1;",
          "192:  while (str[i] && str[i] != ' ' && i < sizeof (tmp)) {",
          "198:   WasmOpDef *opdef = &opcodes[i];",
          "201:     buf[0] = i;",
          "202:     return 1;",
          "212:  op->len = 1;",
          "213:  op->op = buf[0];",
          "214:  if (op->op > 0xbf) {",
          "215:   goto err;",
          "216:  }",
          "218:  WasmOpDef *opdef = &opcodes[op->op];",
          "219:  switch (op->op) {",
          "220:  case WASM_OP_TRAP:",
          "221:  case WASM_OP_NOP:",
          "222:  case WASM_OP_ELSE:",
          "223:  case WASM_OP_RETURN:",
          "224:  case WASM_OP_DROP:",
          "225:  case WASM_OP_SELECT:",
          "226:  case WASM_OP_I32EQZ:",
          "227:  case WASM_OP_I32EQ:",
          "228:  case WASM_OP_I32NE:",
          "229:  case WASM_OP_I32LTS:",
          "230:  case WASM_OP_I32LTU:",
          "231:  case WASM_OP_I32GTS:",
          "232:  case WASM_OP_I32GTU:",
          "233:  case WASM_OP_I32LES:",
          "234:  case WASM_OP_I32LEU:",
          "235:  case WASM_OP_I32GES:",
          "236:  case WASM_OP_I32GEU:",
          "237:  case WASM_OP_I64EQZ:",
          "238:  case WASM_OP_I64EQ:",
          "239:  case WASM_OP_I64NE:",
          "240:  case WASM_OP_I64LTS:",
          "241:  case WASM_OP_I64LTU:",
          "242:  case WASM_OP_I64GTS:",
          "243:  case WASM_OP_I64GTU:",
          "244:  case WASM_OP_I64LES:",
          "245:  case WASM_OP_I64LEU:",
          "246:  case WASM_OP_I64GES:",
          "247:  case WASM_OP_I64GEU:",
          "248:  case WASM_OP_F32EQ:",
          "249:  case WASM_OP_F32NE:",
          "250:  case WASM_OP_F32LT:",
          "251:  case WASM_OP_F32GT:",
          "252:  case WASM_OP_F32LE:",
          "253:  case WASM_OP_F32GE:",
          "254:  case WASM_OP_F64EQ:",
          "255:  case WASM_OP_F64NE:",
          "256:  case WASM_OP_F64LT:",
          "257:  case WASM_OP_F64GT:",
          "258:  case WASM_OP_F64LE:",
          "259:  case WASM_OP_F64GE:",
          "260:  case WASM_OP_I32CLZ:",
          "261:  case WASM_OP_I32CTZ:",
          "262:  case WASM_OP_I32POPCNT:",
          "263:  case WASM_OP_I32ADD:",
          "264:  case WASM_OP_I32SUB:",
          "265:  case WASM_OP_I32MUL:",
          "266:  case WASM_OP_I32DIVS:",
          "267:  case WASM_OP_I32DIVU:",
          "268:  case WASM_OP_I32REMS:",
          "269:  case WASM_OP_I32REMU:",
          "270:  case WASM_OP_I32AND:",
          "271:  case WASM_OP_I32OR:",
          "272:  case WASM_OP_I32XOR:",
          "273:  case WASM_OP_I32SHL:",
          "274:  case WASM_OP_I32SHRS:",
          "275:  case WASM_OP_I32SHRU:",
          "276:  case WASM_OP_I32ROTL:",
          "277:  case WASM_OP_I32ROTR:",
          "278:  case WASM_OP_I64CLZ:",
          "279:  case WASM_OP_I64CTZ:",
          "280:  case WASM_OP_I64POPCNT:",
          "281:  case WASM_OP_I64ADD:",
          "282:  case WASM_OP_I64SUB:",
          "283:  case WASM_OP_I64MUL:",
          "284:  case WASM_OP_I64DIVS:",
          "285:  case WASM_OP_I64DIVU:",
          "286:  case WASM_OP_I64REMS:",
          "287:  case WASM_OP_I64REMU:",
          "288:  case WASM_OP_I64AND:",
          "289:  case WASM_OP_I64OR:",
          "290:  case WASM_OP_I64XOR:",
          "291:  case WASM_OP_I64SHL:",
          "292:  case WASM_OP_I64SHRS:",
          "293:  case WASM_OP_I64SHRU:",
          "294:  case WASM_OP_I64ROTL:",
          "295:  case WASM_OP_I64ROTR:",
          "296:  case WASM_OP_F32ABS:",
          "297:  case WASM_OP_F32NEG:",
          "298:  case WASM_OP_F32CEIL:",
          "299:  case WASM_OP_F32FLOOR:",
          "300:  case WASM_OP_F32TRUNC:",
          "301:  case WASM_OP_F32NEAREST:",
          "302:  case WASM_OP_F32SQRT:",
          "303:  case WASM_OP_F32ADD:",
          "304:  case WASM_OP_F32SUB:",
          "305:  case WASM_OP_F32MUL:",
          "306:  case WASM_OP_F32DIV:",
          "307:  case WASM_OP_F32MIN:",
          "308:  case WASM_OP_F32MAX:",
          "309:  case WASM_OP_F32COPYSIGN:",
          "310:  case WASM_OP_F64ABS:",
          "311:  case WASM_OP_F64NEG:",
          "312:  case WASM_OP_F64CEIL:",
          "313:  case WASM_OP_F64FLOOR:",
          "314:  case WASM_OP_F64TRUNC:",
          "315:  case WASM_OP_F64NEAREST:",
          "316:  case WASM_OP_F64SQRT:",
          "317:  case WASM_OP_F64ADD:",
          "318:  case WASM_OP_F64SUB:",
          "319:  case WASM_OP_F64MUL:",
          "320:  case WASM_OP_F64DIV:",
          "321:  case WASM_OP_F64MIN:",
          "322:  case WASM_OP_F64MAX:",
          "323:  case WASM_OP_F64COPYSIGN:",
          "324:  case WASM_OP_I32WRAPI64:",
          "325:  case WASM_OP_I32TRUNCSF32:",
          "326:  case WASM_OP_I32TRUNCUF32:",
          "327:  case WASM_OP_I32TRUNCSF64:",
          "328:  case WASM_OP_I32TRUNCUF64:",
          "329:  case WASM_OP_I64EXTENDSI32:",
          "330:  case WASM_OP_I64EXTENDUI32:",
          "331:  case WASM_OP_I64TRUNCSF32:",
          "332:  case WASM_OP_I64TRUNCUF32:",
          "333:  case WASM_OP_I64TRUNCSF64:",
          "334:  case WASM_OP_I64TRUNCUF64:",
          "335:  case WASM_OP_F32CONVERTSI32:",
          "336:  case WASM_OP_F32CONVERTUI32:",
          "337:  case WASM_OP_F32CONVERTSI64:",
          "338:  case WASM_OP_F32CONVERTUI64:",
          "339:  case WASM_OP_F32DEMOTEF64:",
          "340:  case WASM_OP_F64CONVERTSI32:",
          "341:  case WASM_OP_F64CONVERTUI32:",
          "342:  case WASM_OP_F64CONVERTSI64:",
          "343:  case WASM_OP_F64CONVERTUI64:",
          "344:  case WASM_OP_F64PROMOTEF32:",
          "345:  case WASM_OP_I32REINTERPRETF32:",
          "346:  case WASM_OP_I64REINTERPRETF64:",
          "347:  case WASM_OP_F32REINTERPRETI32:",
          "348:  case WASM_OP_F64REINTERPRETI64:",
          "349:  case WASM_OP_END:",
          "350:   {",
          "351:    r_strbuf_set (sb, opdef->txt);",
          "352:   }",
          "353:   break;",
          "354:  case WASM_OP_BLOCK:",
          "355:  case WASM_OP_LOOP:",
          "356:  case WASM_OP_IF:",
          "357:   {",
          "358:    st32 val = 0;",
          "359:    size_t n = read_i32_leb128 (buf + 1, buf + buf_len, &val);",
          "360:    if (!(n > 0 && n < buf_len)) {",
          "361:     goto err;",
          "362:    }",
          "363:    switch (0x80 - val) {",
          "364:    case R_BIN_WASM_VALUETYPE_EMPTY:",
          "366:     break;",
          "367:    case R_BIN_WASM_VALUETYPE_i32:",
          "368:     r_strbuf_setf (sb, \"%s (result i32)\", opdef->txt);",
          "369:     break;",
          "370:    case R_BIN_WASM_VALUETYPE_i64:",
          "371:     r_strbuf_setf (sb, \"%s (result i64)\", opdef->txt);",
          "372:     break;",
          "373:    case R_BIN_WASM_VALUETYPE_f32:",
          "374:     r_strbuf_setf (sb, \"%s (result f32)\", opdef->txt);",
          "375:     break;",
          "376:    case R_BIN_WASM_VALUETYPE_f64:",
          "377:     r_strbuf_setf (sb, \"%s (result f64)\", opdef->txt);",
          "378:     break;",
          "379:    default:",
          "380:     r_strbuf_setf (sb, \"%s (result ?)\", opdef->txt);",
          "381:     break;",
          "382:    }",
          "383:    op->len += n;",
          "384:   }",
          "385:   break;",
          "386:  case WASM_OP_BR:",
          "387:  case WASM_OP_BRIF:",
          "388:  case WASM_OP_CALL:",
          "389:   {",
          "390:    ut32 val = 0;",
          "391:    size_t n = read_u32_leb128 (buf + 1, buf + buf_len, &val);",
          "392:    if (!(n > 0 && n < buf_len)) {",
          "393:     goto err;",
          "394:    }",
          "395:    r_strbuf_setf (sb, \"%s %d\", opdef->txt, val);",
          "396:    op->len += n;",
          "397:   }",
          "398:   break;",
          "399:  case WASM_OP_BRTABLE:",
          "400:   {",
          "401:    ut32 count = 0, *table = NULL, def = 0;",
          "402:    size_t n = read_u32_leb128 (buf + 1, buf + buf_len, &count);",
          "403:    if (!(n > 0 && n < buf_len && count < 0xffff)) {",
          "404:     goto err;",
          "406:    if (!(table = calloc (count, sizeof (ut32)))) {",
          "407:     goto err;",
          "408:    }",
          "409:    int i = 0;",
          "410:    op->len += n;",
          "411:    for (i = 0; i < count; i++) {",
          "412:     n = read_u32_leb128 (buf + op->len, buf + buf_len, &table[i]);",
          "413:     if (!(op->len + n <= buf_len)) {",
          "414:      goto beach;",
          "416:     if (n < 1) {",
          "421:    n = read_u32_leb128 (buf + op->len, buf + buf_len, &def);",
          "422:    if (!(n > 0 && n + op->len < buf_len)) {",
          "423:     goto beach;",
          "424:    }",
          "425:    op->len += n;",
          "426:    r_strbuf_setf (sb, \"%s %d \", opdef->txt, count);",
          "427:    for (i = 0; i < count; i++) {",
          "428:     r_strbuf_appendf (sb, \"%d \", table[i]);",
          "429:    }",
          "430:    r_strbuf_appendf (sb, \"%d\", def);",
          "431:    free (table);",
          "433:   beach:",
          "434:    free (table);",
          "435:    goto err;",
          "436:   }",
          "437:   break;",
          "438:  case WASM_OP_CALLINDIRECT:",
          "439:   {",
          "440:    ut32 val = 0, reserved = 0;",
          "441:    size_t n = read_u32_leb128 (buf + 1, buf + buf_len, &val);",
          "442:    if (!(n > 0 && n < buf_len)) {",
          "443:     goto err;",
          "445:    op->len += n;",
          "446:    n = read_u32_leb128 (buf + op->len, buf + buf_len, &reserved);",
          "447:    if (!(n == 1 && op->len + n <= buf_len)) {",
          "450:    reserved &= 0x1;",
          "451:    r_strbuf_setf (sb, \"%s %d %d\", opdef->txt, val, reserved);",
          "452:    op->len += n;",
          "453:   }",
          "454:   break;",
          "455:  case WASM_OP_GETLOCAL:",
          "456:  case WASM_OP_SETLOCAL:",
          "457:  case WASM_OP_TEELOCAL:",
          "458:  case WASM_OP_GETGLOBAL:",
          "459:  case WASM_OP_SETGLOBAL:",
          "460:   {",
          "461:    ut32 val = 0;",
          "462:    size_t n = read_u32_leb128 (buf + 1, buf + buf_len, &val);",
          "463:    if (!(n > 0 && n < buf_len)) {",
          "464:     goto err;",
          "466:    r_strbuf_setf (sb, \"%s %d\", opdef->txt, val);",
          "467:    op->len += n;",
          "468:   }",
          "469:   break;",
          "470:  case WASM_OP_I32LOAD:",
          "471:  case WASM_OP_I64LOAD:",
          "472:  case WASM_OP_F32LOAD:",
          "473:  case WASM_OP_F64LOAD:",
          "474:  case WASM_OP_I32LOAD8S:",
          "475:  case WASM_OP_I32LOAD8U:",
          "476:  case WASM_OP_I32LOAD16S:",
          "477:  case WASM_OP_I32LOAD16U:",
          "478:  case WASM_OP_I64LOAD8S:",
          "479:  case WASM_OP_I64LOAD8U:",
          "480:  case WASM_OP_I64LOAD16S:",
          "481:  case WASM_OP_I64LOAD16U:",
          "482:  case WASM_OP_I64LOAD32S:",
          "483:  case WASM_OP_I64LOAD32U:",
          "484:  case WASM_OP_I32STORE:",
          "485:  case WASM_OP_I64STORE:",
          "486:  case WASM_OP_F32STORE:",
          "487:  case WASM_OP_F64STORE:",
          "488:  case WASM_OP_I32STORE8:",
          "489:  case WASM_OP_I32STORE16:",
          "490:  case WASM_OP_I64STORE8:",
          "491:  case WASM_OP_I64STORE16:",
          "492:  case WASM_OP_I64STORE32:",
          "493:   {",
          "494:    ut32 flag = 0, offset = 0;",
          "495:    size_t n = read_u32_leb128 (buf + 1, buf + buf_len, &flag);",
          "496:    if (!(n > 0 && n < buf_len)) {",
          "497:     goto err;",
          "499:    op->len += n;",
          "500:    n = read_u32_leb128 (buf + op->len, buf + buf_len, &offset);",
          "501:    if (!(n > 0 && op->len + n <= buf_len)) {",
          "502:     goto err;",
          "504:    r_strbuf_setf (sb, \"%s %d %d\", opdef->txt, flag, offset);",
          "505:    op->len += n;",
          "506:   }",
          "507:   break;",
          "508:  case WASM_OP_CURRENTMEMORY:",
          "509:  case WASM_OP_GROWMEMORY:",
          "510:   {",
          "511:    ut32 reserved = 0;",
          "512:    size_t n = read_u32_leb128 (buf + 1, buf + buf_len, &reserved);",
          "513:    if (!(n == 1 && n < buf_len)) {",
          "514:     goto err;",
          "516:    reserved &= 0x1;",
          "517:    r_strbuf_setf (sb, \"%s %d\", opdef->txt, reserved);",
          "518:    op->len += n;",
          "519:   }",
          "520:   break;",
          "522:  case WASM_OP_I32CONST:",
          "523:   {",
          "524:    st32 val = 0;",
          "525:    size_t n = read_i32_leb128 (buf + 1, buf + buf_len, &val);",
          "526:    if (!(n > 0 && n < buf_len)) {",
          "527:     goto err;",
          "529:    r_strbuf_setf (sb, \"%s %\" PFMT32d, opdef->txt, val);",
          "530:    op->len += n;",
          "531:   }",
          "532:   break;",
          "533:  case WASM_OP_I64CONST:",
          "534:   {",
          "535:    st64 val = 0;",
          "536:    size_t n = read_i64_leb128 (buf + 1, buf + buf_len, &val);",
          "537:    if (!(n > 0 && n < buf_len)) {",
          "538:     goto err;",
          "540:    r_strbuf_setf (sb, \"%s %\" PFMT64d, opdef->txt, val);",
          "541:    op->len += n;",
          "542:   }",
          "543:   break;",
          "544:  case WASM_OP_F32CONST:",
          "545:   {",
          "546:    ut32 val = 0;",
          "547:    size_t n = read_u32_leb128 (buf + 1, buf + buf_len, &val);",
          "548:    if (!(n > 0 && n < buf_len)) {",
          "549:     goto err;",
          "551:    long double d =  (long double)val;",
          "552:    r_strbuf_setf (sb, \"%s %\" LDBLFMT, opdef->txt, d);",
          "553:    op->len += n;",
          "554:   }",
          "555:   break;",
          "556:  case WASM_OP_F64CONST:",
          "557:   {",
          "558:    ut64 val = 0;",
          "559:    size_t n = read_u64_leb128 (buf + 1, buf + buf_len, &val);",
          "560:    if (!(n > 0 && n < buf_len)) {",
          "561:     goto err;",
          "563:    long double d =  (long double) val;",
          "564:    r_strbuf_setf (sb, \"%s %\" LDBLFMT, opdef->txt, d);",
          "565:    op->len += n;",
          "568:  default:",
          "",
          "[Added Lines]",
          "184:  [WASM_OP_F64REINTERPRETI64] = { \"f64.reinterpret/i64\", 1, 1 }",
          "185: };",
          "187: static WasmOpDef opcodes_threads[256] = {",
          "188:  [WASM_OP_ATOMICNOTIFY] = { \"atomic.notify\", 1, 1 },",
          "189:  [WASM_OP_I32ATOMICWAIT ] = { \"i32.atomic.wait\", 1, 1 },",
          "190:  [WASM_OP_I64ATOMICWAIT ] = { \"i64.atomic.wait\", 1, 1 },",
          "191:  [WASM_OP_I32ATOMICLOAD] = { \"i32.atomic.load\", 3, 3 },",
          "192:  [WASM_OP_I64ATOMICLOAD] = { \"i64.atomic.load\", 3, 3 },",
          "193:  [WASM_OP_I32ATOMICLOAD16U] = { \"i32.atomic.load16_u\" , 3, 3 },",
          "194:  [WASM_OP_I64ATOMICLOAD8U] = { \"i64.atomic.load8_u\" , 3, 3 },",
          "195:  [WASM_OP_I64ATOMICLOAD16U] = { \"i64.atomic.load16_u\" , 3, 3 },",
          "196:  [WASM_OP_I64ATOMICLOAD32U] = { \"i64.atomic.load32_u\" , 3, 3 },",
          "197:  [WASM_OP_I32ATOMICSTORE] = { \"i32.atomic.store\" , 3, 3 },",
          "198:  [WASM_OP_I64ATOMICSTORE] = { \"i64.atomic.store\" , 3, 3 },",
          "199:  [WASM_OP_I32ATOMICSTORE8] = { \"i32.atomic.store8\" , 3, 3 },",
          "200:  [WASM_OP_I32ATOMICSTORE16] = { \"i32.atomic.store16\" , 3, 3 },",
          "201:  [WASM_OP_I64ATOMICSTORE8] = { \"i64.atomic.store8\" , 3, 3 },",
          "202:  [WASM_OP_I64ATOMICSTORE16] = { \"i64.atomic.store16\" , 3, 3 },",
          "203:  [WASM_OP_I64ATOMICSTORE32] = { \"i64.atomic.store32\" , 3, 3 },",
          "204:  [WASM_OP_I32ATOMICRMWADD] = { \"i32.atomic.rmw.add\" , 3, 3 },",
          "205:  [WASM_OP_I64ATOMICRMWADD] = { \"i64.atomic.rmw.add\" , 3, 3 },",
          "206:  [WASM_OP_I32ATOMICRMW8UADD] = { \"i32.atomic.rmw8_u.add\" , 3, 3 },",
          "207:  [WASM_OP_I32ATOMICRMW16UADD] = { \"i32.atomic.rmw16_u.add\" , 3, 3 },",
          "208:  [WASM_OP_I64ATOMICRMW8UADD] = { \"i64.atomic.rmw8_u.add\" , 3, 3 },",
          "209:  [WASM_OP_I64ATOMICRMW16UADD] = { \"i64.atomic.rmw16_u.add\" , 3, 3 },",
          "210:  [WASM_OP_I64ATOMICRMW32UADD] = { \"i64.atomic.rmw32_u.add\" , 3, 3 },",
          "211:  [WASM_OP_I32ATOMICRMW8USUB] = { \"i32.atomic.rmw8_u.sub\" , 3, 3 },",
          "212:  [WASM_OP_I32ATOMICRMW16USUB] = { \"i32.atomic.rmw16_u.sub\" , 3, 3 },",
          "213:  [WASM_OP_I32ATOMICRMWSUB] = { \"i32.atomic.rmw.sub\" , 3, 3 },",
          "214:  [WASM_OP_I64ATOMICRMW8USUB] = { \"i64.atomic.rmw8_u.sub\" , 3, 3 },",
          "215:  [WASM_OP_I64ATOMICRMW16USUB] = { \"i64.atomic.rmw16_u.sub\" , 3, 3 },",
          "216:  [WASM_OP_I64ATOMICRMW32USUB] = { \"i64.atomic.rmw32_u.sub\" , 3, 3 },",
          "217:  [WASM_OP_I64ATOMICRMWSUB] = { \"i64.atomic.rmw.sub\" , 3, 3 },",
          "218:  [WASM_OP_I32ATOMICRMWAND] = { \"i32.atomic.rmw.and\" , 3, 3 },",
          "219:  [WASM_OP_I64ATOMICRMWAND] = { \"i64.atomic.rmw.and\" , 3, 3 },",
          "220:  [WASM_OP_I32ATOMICRMW8UAND] = { \"i32.atomic.rmw8_u.and\" , 3, 3 },",
          "221:  [WASM_OP_I32ATOMICRMW16UAND] = { \"i32.atomic.rmw16_u.and\" , 3, 3 },",
          "222:  [WASM_OP_I64ATOMICRMW8UAND] = { \"i64.atomic.rmw8_u.and\" , 3, 3 },",
          "223:  [WASM_OP_I64ATOMICRMW16UAND] = { \"i64.atomic.rmw16_u.and\" , 3, 3 },",
          "224:  [WASM_OP_I64ATOMICRMW32UAND] = { \"i64.atomic.rmw32_u.and\" , 3, 3 },",
          "225:  [WASM_OP_I32ATOMICRMWOR] = { \"i32.atomic.rmw.or\" , 3, 3 },",
          "226:  [WASM_OP_I64ATOMICRMWOR] = { \"i64.atomic.rmw.or\" , 3, 3 },",
          "227:  [WASM_OP_I32ATOMICRMW8UOR] = { \"i32.atomic.rmw8_u.or\" , 3, 3 },",
          "228:  [WASM_OP_I32ATOMICRMW16UOR] = { \"i32.atomic.rmw16_u.or\" , 3, 3 },",
          "229:  [WASM_OP_I64ATOMICRMW8UOR] = { \"i64.atomic.rmw8_u.or\" , 3, 3 },",
          "230:  [WASM_OP_I64ATOMICRMW16UOR] = { \"i64.atomic.rmw16_u.or\" , 3, 3 },",
          "231:  [WASM_OP_I64ATOMICRMW32UOR] = { \"i64.atomic.rmw32_u.or\" , 3, 3 },",
          "232:  [WASM_OP_I32ATOMICRMWXOR] = { \"i32.atomic.rmw.xor\" , 3, 3 },",
          "233:  [WASM_OP_I64ATOMICRMWXOR] = { \"i64.atomic.rmw.xor\" , 3, 3 },",
          "234:  [WASM_OP_I32ATOMICRMW8UXOR] = { \"i32.atomic.rmw8_u.xor\" , 3, 3 },",
          "235:  [WASM_OP_I32ATOMICRMW16UXOR] = { \"i32.atomic.rmw16_u.xor\" , 3, 3 },",
          "236:  [WASM_OP_I64ATOMICRMW8UXOR] = { \"i64.atomic.rmw8_u.xor\" , 3, 3 },",
          "237:  [WASM_OP_I64ATOMICRMW16UXOR] = { \"i64.atomic.rmw16_u.xor\" , 3, 3 },",
          "238:  [WASM_OP_I64ATOMICRMW32UXOR] = { \"i64.atomic.rmw32_u.xor\" , 3, 3 },",
          "239:  [WASM_OP_I32ATOMICRMWXCHG] = { \"i32.atomic.rmw.xchg\" , 3, 3 },",
          "240:  [WASM_OP_I64ATOMICRMWXCHG] = { \"i64.atomic.rmw.xchg\" , 3, 3 },",
          "241:  [WASM_OP_I32ATOMICRMW8UXCHG] = { \"i32.atomic.rmw8_u.xchg\" , 3, 3 },",
          "242:  [WASM_OP_I32ATOMICRMW16UXCHG] = { \"i32.atomic.rmw16_u.xchg\" , 3, 3 },",
          "243:  [WASM_OP_I64ATOMICRMW8UXCHG] = { \"i64.atomic.rmw8_u.xchg\" , 3, 3 },",
          "244:  [WASM_OP_I64ATOMICRMW16UXCHG] = { \"i64.atomic.rmw16_u.xchg\" , 3, 3 },",
          "245:  [WASM_OP_I64ATOMICRMW32UXCHG] = { \"i64.atomic.rmw32_u.xchg\" , 3, 3 },",
          "246:  [WASM_OP_I32ATOMICRMWCMPXCHG] = { \"i32.atomic.rmw.cmpxchg\" , 3, 3 },",
          "247:  [WASM_OP_I64ATOMICRMWCMPXCHG] = { \"i64.atomic.rmw.cmpxchg\" , 3, 3 },",
          "248:  [WASM_OP_I32ATOMICRMW8UCMPXCHG] = { \"i32.atomic.rmw8_u.cmpxchg\" , 3, 3 },",
          "249:  [WASM_OP_I32ATOMICRMW16UCMPXCHG] = { \"i32.atomic.rmw16_u.cmpxchg\" , 3, 3 },",
          "250:  [WASM_OP_I64ATOMICRMW8UCMPXCHG] = { \"i64.atomic.rmw8_u.cmpxchg\" , 3, 3 },",
          "251:  [WASM_OP_I64ATOMICRMW16UCMPXCHG] = { \"i64.atomic.rmw16_u.cmpxchg\" , 3, 3 },",
          "252:  [WASM_OP_I64ATOMICRMW32UCMPXCHG] = { \"i64.atomic.rmw32_u.cmpxchg\" , 3, 3 }",
          "257:  int i = 0, len = 0;",
          "259:  WasmOpDef *opdef = NULL;",
          "260:  while (i < sizeof (tmp) && str[i] && str[i] != ' ') {",
          "267:   opdef = &opcodes[i];",
          "270:     buf[len++] = i;",
          "271:     break;",
          "272:    }",
          "273:   }",
          "274:  }",
          "276:  if (len == 0) {",
          "277:   for (i = 0; i < 0xff; i++) {",
          "278:    opdef = &opcodes_threads[i];",
          "279:    if (opdef->txt) {",
          "280:     if (!strcmp (opdef->txt, tmp)) {",
          "281:      buf[len++] = 0xfe;",
          "282:      buf[len++] = i;",
          "283:      break;",
          "284:     }",
          "289:  if (len == 0) goto err;",
          "292:  err:",
          "293:   return -1;",
          "299:  int id = buf[0];",
          "300:  if (id < 0xc0) {",
          "301:   op->type = WASM_TYPE_OP_CORE;",
          "302:   op->op.core = id;",
          "303:   op->len = 1;",
          "304:   WasmOpDef *opdef = &opcodes[id];",
          "305:   switch (id) {",
          "306:   case WASM_OP_TRAP:",
          "307:   case WASM_OP_NOP:",
          "308:   case WASM_OP_ELSE:",
          "309:   case WASM_OP_RETURN:",
          "310:   case WASM_OP_DROP:",
          "311:   case WASM_OP_SELECT:",
          "312:   case WASM_OP_I32EQZ:",
          "313:   case WASM_OP_I32EQ:",
          "314:   case WASM_OP_I32NE:",
          "315:   case WASM_OP_I32LTS:",
          "316:   case WASM_OP_I32LTU:",
          "317:   case WASM_OP_I32GTS:",
          "318:   case WASM_OP_I32GTU:",
          "319:   case WASM_OP_I32LES:",
          "320:   case WASM_OP_I32LEU:",
          "321:   case WASM_OP_I32GES:",
          "322:   case WASM_OP_I32GEU:",
          "323:   case WASM_OP_I64EQZ:",
          "324:   case WASM_OP_I64EQ:",
          "325:   case WASM_OP_I64NE:",
          "326:   case WASM_OP_I64LTS:",
          "327:   case WASM_OP_I64LTU:",
          "328:   case WASM_OP_I64GTS:",
          "329:   case WASM_OP_I64GTU:",
          "330:   case WASM_OP_I64LES:",
          "331:   case WASM_OP_I64LEU:",
          "332:   case WASM_OP_I64GES:",
          "333:   case WASM_OP_I64GEU:",
          "334:   case WASM_OP_F32EQ:",
          "335:   case WASM_OP_F32NE:",
          "336:   case WASM_OP_F32LT:",
          "337:   case WASM_OP_F32GT:",
          "338:   case WASM_OP_F32LE:",
          "339:   case WASM_OP_F32GE:",
          "340:   case WASM_OP_F64EQ:",
          "341:   case WASM_OP_F64NE:",
          "342:   case WASM_OP_F64LT:",
          "343:   case WASM_OP_F64GT:",
          "344:   case WASM_OP_F64LE:",
          "345:   case WASM_OP_F64GE:",
          "346:   case WASM_OP_I32CLZ:",
          "347:   case WASM_OP_I32CTZ:",
          "348:   case WASM_OP_I32POPCNT:",
          "349:   case WASM_OP_I32ADD:",
          "350:   case WASM_OP_I32SUB:",
          "351:   case WASM_OP_I32MUL:",
          "352:   case WASM_OP_I32DIVS:",
          "353:   case WASM_OP_I32DIVU:",
          "354:   case WASM_OP_I32REMS:",
          "355:   case WASM_OP_I32REMU:",
          "356:   case WASM_OP_I32AND:",
          "357:   case WASM_OP_I32OR:",
          "358:   case WASM_OP_I32XOR:",
          "359:   case WASM_OP_I32SHL:",
          "360:   case WASM_OP_I32SHRS:",
          "361:   case WASM_OP_I32SHRU:",
          "362:   case WASM_OP_I32ROTL:",
          "363:   case WASM_OP_I32ROTR:",
          "364:   case WASM_OP_I64CLZ:",
          "365:   case WASM_OP_I64CTZ:",
          "366:   case WASM_OP_I64POPCNT:",
          "367:   case WASM_OP_I64ADD:",
          "368:   case WASM_OP_I64SUB:",
          "369:   case WASM_OP_I64MUL:",
          "370:   case WASM_OP_I64DIVS:",
          "371:   case WASM_OP_I64DIVU:",
          "372:   case WASM_OP_I64REMS:",
          "373:   case WASM_OP_I64REMU:",
          "374:   case WASM_OP_I64AND:",
          "375:   case WASM_OP_I64OR:",
          "376:   case WASM_OP_I64XOR:",
          "377:   case WASM_OP_I64SHL:",
          "378:   case WASM_OP_I64SHRS:",
          "379:   case WASM_OP_I64SHRU:",
          "380:   case WASM_OP_I64ROTL:",
          "381:   case WASM_OP_I64ROTR:",
          "382:   case WASM_OP_F32ABS:",
          "383:   case WASM_OP_F32NEG:",
          "384:   case WASM_OP_F32CEIL:",
          "385:   case WASM_OP_F32FLOOR:",
          "386:   case WASM_OP_F32TRUNC:",
          "387:   case WASM_OP_F32NEAREST:",
          "388:   case WASM_OP_F32SQRT:",
          "389:   case WASM_OP_F32ADD:",
          "390:   case WASM_OP_F32SUB:",
          "391:   case WASM_OP_F32MUL:",
          "392:   case WASM_OP_F32DIV:",
          "393:   case WASM_OP_F32MIN:",
          "394:   case WASM_OP_F32MAX:",
          "395:   case WASM_OP_F32COPYSIGN:",
          "396:   case WASM_OP_F64ABS:",
          "397:   case WASM_OP_F64NEG:",
          "398:   case WASM_OP_F64CEIL:",
          "399:   case WASM_OP_F64FLOOR:",
          "400:   case WASM_OP_F64TRUNC:",
          "401:   case WASM_OP_F64NEAREST:",
          "402:   case WASM_OP_F64SQRT:",
          "403:   case WASM_OP_F64ADD:",
          "404:   case WASM_OP_F64SUB:",
          "405:   case WASM_OP_F64MUL:",
          "406:   case WASM_OP_F64DIV:",
          "407:   case WASM_OP_F64MIN:",
          "408:   case WASM_OP_F64MAX:",
          "409:   case WASM_OP_F64COPYSIGN:",
          "410:   case WASM_OP_I32WRAPI64:",
          "411:   case WASM_OP_I32TRUNCSF32:",
          "412:   case WASM_OP_I32TRUNCUF32:",
          "413:   case WASM_OP_I32TRUNCSF64:",
          "414:   case WASM_OP_I32TRUNCUF64:",
          "415:   case WASM_OP_I64EXTENDSI32:",
          "416:   case WASM_OP_I64EXTENDUI32:",
          "417:   case WASM_OP_I64TRUNCSF32:",
          "418:   case WASM_OP_I64TRUNCUF32:",
          "419:   case WASM_OP_I64TRUNCSF64:",
          "420:   case WASM_OP_I64TRUNCUF64:",
          "421:   case WASM_OP_F32CONVERTSI32:",
          "422:   case WASM_OP_F32CONVERTUI32:",
          "423:   case WASM_OP_F32CONVERTSI64:",
          "424:   case WASM_OP_F32CONVERTUI64:",
          "425:   case WASM_OP_F32DEMOTEF64:",
          "426:   case WASM_OP_F64CONVERTSI32:",
          "427:   case WASM_OP_F64CONVERTUI32:",
          "428:   case WASM_OP_F64CONVERTSI64:",
          "429:   case WASM_OP_F64CONVERTUI64:",
          "430:   case WASM_OP_F64PROMOTEF32:",
          "431:   case WASM_OP_I32REINTERPRETF32:",
          "432:   case WASM_OP_I64REINTERPRETF64:",
          "433:   case WASM_OP_F32REINTERPRETI32:",
          "434:   case WASM_OP_F64REINTERPRETI64:",
          "435:   case WASM_OP_END:",
          "436:    {",
          "439:    break;",
          "440:   case WASM_OP_BLOCK:",
          "441:   case WASM_OP_LOOP:",
          "442:   case WASM_OP_IF:",
          "443:    {",
          "444:     st32 val = 0;",
          "445:     size_t n = read_i32_leb128 (buf + 1, buf + buf_len, &val);",
          "446:     if (!(n > 0 && n < buf_len)) {",
          "447:      goto err;",
          "449:     switch (0x80 - val) {",
          "450:     case R_BIN_WASM_VALUETYPE_EMPTY:",
          "451:      r_strbuf_set (sb, opdef->txt);",
          "452:      break;",
          "453:     case R_BIN_WASM_VALUETYPE_i32:",
          "454:      r_strbuf_setf (sb, \"%s (result i32)\", opdef->txt);",
          "455:      break;",
          "456:     case R_BIN_WASM_VALUETYPE_i64:",
          "457:      r_strbuf_setf (sb, \"%s (result i64)\", opdef->txt);",
          "458:      break;",
          "459:     case R_BIN_WASM_VALUETYPE_f32:",
          "460:      r_strbuf_setf (sb, \"%s (result f32)\", opdef->txt);",
          "461:      break;",
          "462:     case R_BIN_WASM_VALUETYPE_f64:",
          "463:      r_strbuf_setf (sb, \"%s (result f64)\", opdef->txt);",
          "464:      break;",
          "465:     default:",
          "466:      r_strbuf_setf (sb, \"%s (result ?)\", opdef->txt);",
          "472:   case WASM_OP_BR:",
          "473:   case WASM_OP_BRIF:",
          "474:   case WASM_OP_CALL:",
          "475:    {",
          "476:     ut32 val = 0;",
          "477:     size_t n = read_u32_leb128 (buf + 1, buf + buf_len, &val);",
          "478:     if (!(n > 0 && n < buf_len)) {",
          "479:      goto err;",
          "480:     }",
          "481:     r_strbuf_setf (sb, \"%s %d\", opdef->txt, val);",
          "482:     op->len += n;",
          "484:    break;",
          "485:   case WASM_OP_BRTABLE:",
          "486:    {",
          "487:     ut32 count = 0, *table = NULL, def = 0;",
          "488:     size_t n = read_u32_leb128 (buf + 1, buf + buf_len, &count);",
          "489:     if (!(n > 0 && n < buf_len && count < 0xffff)) {",
          "490:      goto err;",
          "491:     }",
          "492:     if (!(table = calloc (count, sizeof (ut32)))) {",
          "493:      goto err;",
          "494:     }",
          "495:     int i = 0;",
          "496:     op->len += n;",
          "497:     for (i = 0; i < count; i++) {",
          "498:      n = read_u32_leb128 (buf + op->len, buf + buf_len, &table[i]);",
          "499:      if (!(op->len + n <= buf_len)) {",
          "500:       goto beach;",
          "501:      }",
          "502:      if (n < 1) {",
          "503:       break;",
          "504:      }",
          "505:      op->len += n;",
          "506:     }",
          "507:     n = read_u32_leb128 (buf + op->len, buf + buf_len, &def);",
          "508:     if (!(n > 0 && n + op->len < buf_len)) {",
          "509:      goto beach;",
          "510:     }",
          "511:     op->len += n;",
          "512:     r_strbuf_setf (sb, \"%s %d \", opdef->txt, count);",
          "513:     for (i = 0; i < count; i++) {",
          "514:      r_strbuf_appendf (sb, \"%d \", table[i]);",
          "515:     }",
          "516:     r_strbuf_appendf (sb, \"%d\", def);",
          "517:     free (table);",
          "518:     break;",
          "519:    beach:",
          "520:     free (table);",
          "523:    break;",
          "524:   case WASM_OP_CALLINDIRECT:",
          "525:    {",
          "526:     ut32 val = 0, reserved = 0;",
          "527:     size_t n = read_u32_leb128 (buf + 1, buf + buf_len, &val);",
          "528:     if (!(n > 0 && n < buf_len)) {",
          "529:      goto err;",
          "530:     }",
          "531:     op->len += n;",
          "532:     n = read_u32_leb128 (buf + op->len, buf + buf_len, &reserved);",
          "533:     if (!(n == 1 && op->len + n <= buf_len)) {",
          "534:      goto err;",
          "535:     }",
          "536:     reserved &= 0x1;",
          "537:     r_strbuf_setf (sb, \"%s %d %d\", opdef->txt, val, reserved);",
          "538:     op->len += n;",
          "540:    break;",
          "541:   case WASM_OP_GETLOCAL:",
          "542:   case WASM_OP_SETLOCAL:",
          "543:   case WASM_OP_TEELOCAL:",
          "544:   case WASM_OP_GETGLOBAL:",
          "545:   case WASM_OP_SETGLOBAL:",
          "546:    {",
          "547:     ut32 val = 0;",
          "548:     size_t n = read_u32_leb128 (buf + 1, buf + buf_len, &val);",
          "549:     if (!(n > 0 && n < buf_len)) {",
          "550:      goto err;",
          "551:     }",
          "552:     r_strbuf_setf (sb, \"%s %d\", opdef->txt, val);",
          "553:     op->len += n;",
          "555:    break;",
          "556:   case WASM_OP_I32LOAD:",
          "557:   case WASM_OP_I64LOAD:",
          "558:   case WASM_OP_F32LOAD:",
          "559:   case WASM_OP_F64LOAD:",
          "560:   case WASM_OP_I32LOAD8S:",
          "561:   case WASM_OP_I32LOAD8U:",
          "562:   case WASM_OP_I32LOAD16S:",
          "563:   case WASM_OP_I32LOAD16U:",
          "564:   case WASM_OP_I64LOAD8S:",
          "565:   case WASM_OP_I64LOAD8U:",
          "566:   case WASM_OP_I64LOAD16S:",
          "567:   case WASM_OP_I64LOAD16U:",
          "568:   case WASM_OP_I64LOAD32S:",
          "569:   case WASM_OP_I64LOAD32U:",
          "570:   case WASM_OP_I32STORE:",
          "571:   case WASM_OP_I64STORE:",
          "572:   case WASM_OP_F32STORE:",
          "573:   case WASM_OP_F64STORE:",
          "574:   case WASM_OP_I32STORE8:",
          "575:   case WASM_OP_I32STORE16:",
          "576:   case WASM_OP_I64STORE8:",
          "577:   case WASM_OP_I64STORE16:",
          "578:   case WASM_OP_I64STORE32:",
          "579:    {",
          "580:     ut32 flag = 0, offset = 0;",
          "581:     size_t n = read_u32_leb128 (buf + 1, buf + buf_len, &flag);",
          "582:     if (!(n > 0 && n < buf_len)) {",
          "583:      goto err;",
          "584:     }",
          "585:     op->len += n;",
          "586:     n = read_u32_leb128 (buf + op->len, buf + buf_len, &offset);",
          "587:     if (!(n > 0 && op->len + n <= buf_len)) {",
          "588:      goto err;",
          "589:     }",
          "590:     r_strbuf_setf (sb, \"%s %d %d\", opdef->txt, flag, offset);",
          "591:     op->len += n;",
          "593:    break;",
          "594:   case WASM_OP_CURRENTMEMORY:",
          "595:   case WASM_OP_GROWMEMORY:",
          "596:    {",
          "597:     ut32 reserved = 0;",
          "598:     size_t n = read_u32_leb128 (buf + 1, buf + buf_len, &reserved);",
          "599:     if (!(n == 1 && n < buf_len)) {",
          "600:      goto err;",
          "601:     }",
          "602:     reserved &= 0x1;",
          "603:     r_strbuf_setf (sb, \"%s %d\", opdef->txt, reserved);",
          "604:     op->len += n;",
          "606:    break;",
          "608:   case WASM_OP_I32CONST:",
          "609:    {",
          "610:     st32 val = 0;",
          "611:     size_t n = read_i32_leb128 (buf + 1, buf + buf_len, &val);",
          "612:     if (!(n > 0 && n < buf_len)) {",
          "613:      goto err;",
          "614:     }",
          "615:     r_strbuf_setf (sb, \"%s %\" PFMT32d, opdef->txt, val);",
          "616:     op->len += n;",
          "618:    break;",
          "619:   case WASM_OP_I64CONST:",
          "620:    {",
          "621:     st64 val = 0;",
          "622:     size_t n = read_i64_leb128 (buf + 1, buf + buf_len, &val);",
          "623:     if (!(n > 0 && n < buf_len)) {",
          "624:      goto err;",
          "625:     }",
          "626:     r_strbuf_setf (sb, \"%s %\" PFMT64d, opdef->txt, val);",
          "627:     op->len += n;",
          "629:    break;",
          "630:   case WASM_OP_F32CONST:",
          "631:    {",
          "632:     ut32 val = 0;",
          "633:     size_t n = read_u32_leb128 (buf + 1, buf + buf_len, &val);",
          "634:     if (!(n > 0 && n < buf_len)) {",
          "635:      goto err;",
          "636:     }",
          "637:     long double d =  (long double)val;",
          "638:     r_strbuf_setf (sb, \"%s %\" LDBLFMT, opdef->txt, d);",
          "639:     op->len += n;",
          "641:    break;",
          "642:   case WASM_OP_F64CONST:",
          "643:    {",
          "644:     ut64 val = 0;",
          "645:     size_t n = read_u64_leb128 (buf + 1, buf + buf_len, &val);",
          "646:     if (!(n > 0 && n < buf_len)) {",
          "647:      goto err;",
          "648:     }",
          "649:     long double d =  (long double) val;",
          "650:     r_strbuf_setf (sb, \"%s %\" LDBLFMT, opdef->txt, d);",
          "651:     op->len += n;",
          "653:    break;",
          "654:   default:",
          "655:    goto err;",
          "657:  } else if (id == 0xfe) {",
          "658:   op->type =  WASM_TYPE_OP_ATOMIC;",
          "659:   if (buf_len < 2) goto err;",
          "660:   op->len = 2;",
          "661:   id = buf[1]; // skip 0xfe",
          "662:   op->op.atomic = id;",
          "663:   WasmOpDef *opdef = &opcodes_threads[id];",
          "664:   switch (id) {",
          "665:   case WASM_OP_I32ATOMICLOAD:",
          "666:   case WASM_OP_I64ATOMICLOAD:",
          "667:   case WASM_OP_I32ATOMICLOAD8U:",
          "668:   case WASM_OP_I32ATOMICLOAD16U:",
          "669:   case WASM_OP_I64ATOMICLOAD8U:",
          "670:   case WASM_OP_I64ATOMICLOAD16U:",
          "671:   case WASM_OP_I64ATOMICLOAD32U:",
          "672:   case WASM_OP_I32ATOMICSTORE:",
          "673:   case WASM_OP_I64ATOMICSTORE:",
          "674:   case WASM_OP_I32ATOMICSTORE8:",
          "675:   case WASM_OP_I32ATOMICSTORE16:",
          "676:   case WASM_OP_I64ATOMICSTORE8:",
          "677:   case WASM_OP_I64ATOMICSTORE16:",
          "678:   case WASM_OP_I64ATOMICSTORE32:",
          "679:   case WASM_OP_I32ATOMICRMWADD:",
          "680:   case WASM_OP_I64ATOMICRMWADD:",
          "681:   case WASM_OP_I32ATOMICRMW8UADD:",
          "682:   case WASM_OP_I32ATOMICRMW16UADD:",
          "683:   case WASM_OP_I64ATOMICRMW8UADD:",
          "684:   case WASM_OP_I64ATOMICRMW16UADD:",
          "685:   case WASM_OP_I64ATOMICRMW32UADD:",
          "686:   case WASM_OP_I32ATOMICRMW8USUB:",
          "687:   case WASM_OP_I32ATOMICRMW16USUB:",
          "688:   case WASM_OP_I32ATOMICRMWSUB:",
          "689:   case WASM_OP_I64ATOMICRMW8USUB:",
          "690:   case WASM_OP_I64ATOMICRMW16USUB:",
          "691:   case WASM_OP_I64ATOMICRMW32USUB:",
          "692:   case WASM_OP_I64ATOMICRMWSUB:",
          "693:   case WASM_OP_I32ATOMICRMWAND:",
          "694:   case WASM_OP_I64ATOMICRMWAND:",
          "695:   case WASM_OP_I32ATOMICRMW8UAND:",
          "696:   case WASM_OP_I32ATOMICRMW16UAND:",
          "697:   case WASM_OP_I64ATOMICRMW8UAND:",
          "698:   case WASM_OP_I64ATOMICRMW16UAND:",
          "699:   case WASM_OP_I64ATOMICRMW32UAND:",
          "700:   case WASM_OP_I32ATOMICRMWOR:",
          "701:   case WASM_OP_I64ATOMICRMWOR:",
          "702:   case WASM_OP_I32ATOMICRMW8UOR:",
          "703:   case WASM_OP_I32ATOMICRMW16UOR:",
          "704:   case WASM_OP_I64ATOMICRMW8UOR:",
          "705:   case WASM_OP_I64ATOMICRMW16UOR:",
          "706:   case WASM_OP_I64ATOMICRMW32UOR:",
          "707:   case WASM_OP_I32ATOMICRMWXOR:",
          "708:   case WASM_OP_I64ATOMICRMWXOR:",
          "709:   case WASM_OP_I32ATOMICRMW8UXOR:",
          "710:   case WASM_OP_I32ATOMICRMW16UXOR:",
          "711:   case WASM_OP_I64ATOMICRMW8UXOR:",
          "712:   case WASM_OP_I64ATOMICRMW16UXOR:",
          "713:   case WASM_OP_I64ATOMICRMW32UXOR:",
          "714:   case WASM_OP_I32ATOMICRMWXCHG:",
          "715:   case WASM_OP_I64ATOMICRMWXCHG:",
          "716:   case WASM_OP_I32ATOMICRMW8UXCHG:",
          "717:   case WASM_OP_I32ATOMICRMW16UXCHG:",
          "718:   case WASM_OP_I64ATOMICRMW8UXCHG:",
          "719:   case WASM_OP_I64ATOMICRMW16UXCHG:",
          "720:   case WASM_OP_I64ATOMICRMW32UXCHG:",
          "721:    {",
          "722:     ut32 flag = 0, offset = 0;",
          "723:     size_t n = read_u32_leb128 (buf + 2, buf + buf_len, &flag);",
          "724:     if (!(n > 0 && n < buf_len)) {",
          "725:      goto err;",
          "726:     }",
          "727:     op->len += n;",
          "728:     n = read_u32_leb128 (buf + op->len, buf + buf_len, &offset);",
          "729:     if (!(n > 0 && op->len + n <= buf_len)) {",
          "730:      goto err;",
          "731:     }",
          "732:     r_strbuf_setf (sb, \"%s %d %d\", opdef->txt, flag, offset);",
          "733:     op->len += n;",
          "734:    }",
          "736:   default:",
          "737:    goto err;",
          "738:   }",
          "739:  } else {",
          "",
          "---------------"
        ],
        "libr/asm/arch/wasm/wasm.h||libr/asm/arch/wasm/wasm.h": [
          "File: libr/asm/arch/wasm/wasm.h -> libr/asm/arch/wasm/wasm.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "195:  WASM_OP_F32REINTERPRETI32,",
          "196:  WASM_OP_F64REINTERPRETI64,",
          "200: } WasmOpCodes;",
          "202: typedef struct {",
          "204:  int len;",
          "205:  char *txt;",
          "206: } WasmOp;",
          "",
          "[Removed Lines]",
          "203:  WasmOpCodes op;",
          "",
          "[Added Lines]",
          "207: typedef enum {",
          "210:  WASM_OP_ATOMICNOTIFY = 0x00,",
          "211:  WASM_OP_I32ATOMICWAIT,",
          "212:  WASM_OP_I64ATOMICWAIT,",
          "215:  WASM_OP_I32ATOMICLOAD = 0x10,",
          "216:  WASM_OP_I64ATOMICLOAD,",
          "217:  WASM_OP_I32ATOMICLOAD8U,",
          "218:  WASM_OP_I32ATOMICLOAD16U,",
          "219:  WASM_OP_I64ATOMICLOAD8U,",
          "220:  WASM_OP_I64ATOMICLOAD16U,",
          "221:  WASM_OP_I64ATOMICLOAD32U,",
          "222:  WASM_OP_I32ATOMICSTORE = 0x17,",
          "223:  WASM_OP_I64ATOMICSTORE,",
          "224:  WASM_OP_I32ATOMICSTORE8,",
          "225:  WASM_OP_I32ATOMICSTORE16,",
          "226:  WASM_OP_I64ATOMICSTORE8,",
          "227:  WASM_OP_I64ATOMICSTORE16,",
          "228:  WASM_OP_I64ATOMICSTORE32,",
          "231:  WASM_OP_I32ATOMICRMWADD = 0x1e,",
          "232:  WASM_OP_I64ATOMICRMWADD,",
          "233:  WASM_OP_I32ATOMICRMW8UADD,",
          "234:  WASM_OP_I32ATOMICRMW16UADD,",
          "235:  WASM_OP_I64ATOMICRMW8UADD,",
          "236:  WASM_OP_I64ATOMICRMW16UADD,",
          "237:  WASM_OP_I64ATOMICRMW32UADD,",
          "238:  WASM_OP_I32ATOMICRMW8USUB = 0x25,",
          "239:  WASM_OP_I32ATOMICRMW16USUB,",
          "240:  WASM_OP_I32ATOMICRMWSUB,",
          "241:  WASM_OP_I64ATOMICRMW8USUB,",
          "242:  WASM_OP_I64ATOMICRMW16USUB,",
          "243:  WASM_OP_I64ATOMICRMW32USUB,",
          "244:  WASM_OP_I64ATOMICRMWSUB,",
          "245:  WASM_OP_I32ATOMICRMWAND = 0x2c,",
          "246:  WASM_OP_I64ATOMICRMWAND,",
          "247:  WASM_OP_I32ATOMICRMW8UAND,",
          "248:  WASM_OP_I32ATOMICRMW16UAND,",
          "249:  WASM_OP_I64ATOMICRMW8UAND,",
          "250:  WASM_OP_I64ATOMICRMW16UAND,",
          "251:  WASM_OP_I64ATOMICRMW32UAND,",
          "252:  WASM_OP_I32ATOMICRMWOR = 0x33,",
          "253:  WASM_OP_I64ATOMICRMWOR,",
          "254:  WASM_OP_I32ATOMICRMW8UOR,",
          "255:  WASM_OP_I32ATOMICRMW16UOR,",
          "256:  WASM_OP_I64ATOMICRMW8UOR,",
          "257:  WASM_OP_I64ATOMICRMW16UOR,",
          "258:  WASM_OP_I64ATOMICRMW32UOR,",
          "259:  WASM_OP_I32ATOMICRMWXOR = 0x3a,",
          "260:  WASM_OP_I64ATOMICRMWXOR,",
          "261:  WASM_OP_I32ATOMICRMW8UXOR,",
          "262:  WASM_OP_I32ATOMICRMW16UXOR,",
          "263:  WASM_OP_I64ATOMICRMW8UXOR,",
          "264:  WASM_OP_I64ATOMICRMW16UXOR,",
          "265:  WASM_OP_I64ATOMICRMW32UXOR,",
          "266:  WASM_OP_I32ATOMICRMWXCHG = 0x41,",
          "267:  WASM_OP_I64ATOMICRMWXCHG,",
          "268:  WASM_OP_I32ATOMICRMW8UXCHG,",
          "269:  WASM_OP_I32ATOMICRMW16UXCHG,",
          "270:  WASM_OP_I64ATOMICRMW8UXCHG,",
          "271:  WASM_OP_I64ATOMICRMW16UXCHG,",
          "272:  WASM_OP_I64ATOMICRMW32UXCHG,",
          "275:  WASM_OP_I32ATOMICRMWCMPXCHG = 0x48,",
          "276:  WASM_OP_I64ATOMICRMWCMPXCHG,",
          "277:  WASM_OP_I32ATOMICRMW8UCMPXCHG,",
          "278:  WASM_OP_I32ATOMICRMW16UCMPXCHG,",
          "279:  WASM_OP_I64ATOMICRMW8UCMPXCHG,",
          "280:  WASM_OP_I64ATOMICRMW16UCMPXCHG,",
          "281:  WASM_OP_I64ATOMICRMW32UCMPXCHG,",
          "283: } WasmOpAtomicCodes;",
          "285: typedef enum {",
          "286:  WASM_TYPE_OP_CORE,",
          "287:  WASM_TYPE_OP_ATOMIC,",
          "288: } WasmTypeOp;",
          "291:  union {",
          "292:   WasmOpCodes core;",
          "293:   WasmOpAtomicCodes atomic;",
          "294:  } op;",
          "295:  WasmTypeOp type;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "214: R_IPI int wasm_asm(const char *str, unsigned char *buf, int buf_len);",
          "215: R_IPI int wasm_dis(WasmOp *op, const unsigned char *buf, int buf_len);",
          "",
          "[Removed Lines]",
          "217: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "cbbe87bf3f8ac3aeeb4c5c502875a4248f6c0bb5",
      "candidate_info": {
        "commit_hash": "cbbe87bf3f8ac3aeeb4c5c502875a4248f6c0bb5",
        "repo": "radare/radare2",
        "commit_url": "https://github.com/radare/radare2/commit/cbbe87bf3f8ac3aeeb4c5c502875a4248f6c0bb5",
        "files": [
          "libr/asm/arch/wasm/wasm.c",
          "libr/asm/p/asm_wasm.c",
          "libr/bin/format/wasm/wasm.c",
          "libr/bin/format/wasm/wasm.h",
          "libr/bin/p/bin_wasm.c"
        ],
        "message": "Wasm fixes (#8492)",
        "before_after_code_files": [
          "libr/asm/arch/wasm/wasm.c||libr/asm/arch/wasm/wasm.c",
          "libr/asm/p/asm_wasm.c||libr/asm/p/asm_wasm.c",
          "libr/bin/format/wasm/wasm.c||libr/bin/format/wasm/wasm.c",
          "libr/bin/format/wasm/wasm.h||libr/bin/format/wasm/wasm.h",
          "libr/bin/p/bin_wasm.c||libr/bin/p/bin_wasm.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libr/asm/arch/wasm/wasm.c||libr/asm/arch/wasm/wasm.c"
          ],
          "candidate": [
            "libr/asm/arch/wasm/wasm.c||libr/asm/arch/wasm/wasm.c"
          ]
        }
      },
      "candidate_diff": {
        "libr/asm/arch/wasm/wasm.c||libr/asm/arch/wasm/wasm.c": [
          "File: libr/asm/arch/wasm/wasm.c -> libr/asm/arch/wasm/wasm.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5: #include <stdio.h>",
          "6: #include <string.h>",
          "7: #include <stdint.h>",
          "8: #include <stdarg.h>",
          "9: #include <sys/types.h>",
          "10: #include \"../../bin/format/wasm/wasm.h\"",
          "12: typedef enum {",
          "14:  WASM_OP_TRAP = 0x00,",
          "15:  WASM_OP_NOP,",
          "16:  WASM_OP_BLOCK,",
          "17:  WASM_OP_LOOP,",
          "18:  WASM_OP_IF,",
          "19:  WASM_OP_ELSE,",
          "20:  WASM_OP_END = 0x0b,",
          "21:  WASM_OP_BR,",
          "22:  WASM_OP_BRIF,",
          "23:  WASM_OP_BRTABLE,",
          "24:  WASM_OP_RETURN,",
          "27:  WASM_OP_CALL = 0x10,",
          "28:  WASM_OP_CALLINDIRECT,",
          "31:  WASM_OP_DROP = 0x1a,",
          "32:  WASM_OP_SELECT,",
          "35:  WASM_OP_GETLOCAL = 0x20,",
          "36:  WASM_OP_SETLOCAL,",
          "37:  WASM_OP_TEELOCAL,",
          "38:  WASM_OP_GETGLOBAL,",
          "39:  WASM_OP_SETGLOBAL,",
          "42:  WASM_OP_I32LOAD = 0x28,",
          "43:  WASM_OP_I64LOAD,",
          "44:  WASM_OP_F32LOAD,",
          "45:  WASM_OP_F64LOAD,",
          "46:  WASM_OP_I32LOAD8S,",
          "47:  WASM_OP_I32LOAD8U,",
          "48:  WASM_OP_I32LOAD16S,",
          "49:  WASM_OP_I32LOAD16U,",
          "50:  WASM_OP_I64LOAD8S,",
          "51:  WASM_OP_I64LOAD8U,",
          "52:  WASM_OP_I64LOAD16S,",
          "53:  WASM_OP_I64LOAD16U,",
          "54:  WASM_OP_I64LOAD32S,",
          "55:  WASM_OP_I64LOAD32U,",
          "56:  WASM_OP_I32STORE,",
          "57:  WASM_OP_I64STORE,",
          "58:  WASM_OP_F32STORE,",
          "59:  WASM_OP_F64STORE,",
          "60:  WASM_OP_I32STORE8,",
          "61:  WASM_OP_I32STORE16,",
          "62:  WASM_OP_I64STORE8,",
          "63:  WASM_OP_I64STORE16,",
          "64:  WASM_OP_I64STORE32,",
          "65:  WASM_OP_CURRENTMEMORY,",
          "66:  WASM_OP_GROWMEMORY,",
          "69:  WASM_OP_I32CONST,",
          "70:  WASM_OP_I64CONST,",
          "71:  WASM_OP_F32CONST,",
          "72:  WASM_OP_F64CONST,",
          "75:  WASM_OP_I32EQZ,",
          "76:  WASM_OP_I32EQ,",
          "77:  WASM_OP_I32NE,",
          "78:  WASM_OP_I32LTS,",
          "79:  WASM_OP_I32LTU,",
          "80:  WASM_OP_I32GTS,",
          "81:  WASM_OP_I32GTU,",
          "82:  WASM_OP_I32LES,",
          "83:  WASM_OP_I32LEU,",
          "84:  WASM_OP_I32GES,",
          "85:  WASM_OP_I32GEU,",
          "86:  WASM_OP_I64EQZ,",
          "87:  WASM_OP_I64EQ,",
          "88:  WASM_OP_I64NE,",
          "89:  WASM_OP_I64LTS,",
          "90:  WASM_OP_I64LTU,",
          "91:  WASM_OP_I64GTS,",
          "92:  WASM_OP_I64GTU,",
          "93:  WASM_OP_I64LES,",
          "94:  WASM_OP_I64LEU,",
          "95:  WASM_OP_I64GES,",
          "96:  WASM_OP_I64GEU,",
          "97:  WASM_OP_F32EQ,",
          "98:  WASM_OP_F32NE,",
          "99:  WASM_OP_F32LT,",
          "100:  WASM_OP_F32GT,",
          "101:  WASM_OP_F32LE,",
          "102:  WASM_OP_F32GE,",
          "103:  WASM_OP_F64EQ,",
          "104:  WASM_OP_F64NE,",
          "105:  WASM_OP_F64LT,",
          "106:  WASM_OP_F64GT,",
          "107:  WASM_OP_F64LE,",
          "108:  WASM_OP_F64GE,",
          "111:  WASM_OP_I32CLZ,",
          "112:  WASM_OP_I32CTZ,",
          "113:  WASM_OP_I32POPCNT,",
          "114:  WASM_OP_I32ADD,",
          "115:  WASM_OP_I32SUB,",
          "116:  WASM_OP_I32MUL,",
          "117:  WASM_OP_I32DIVS,",
          "118:  WASM_OP_I32DIVU,",
          "119:  WASM_OP_I32REMS,",
          "120:  WASM_OP_I32REMU,",
          "121:  WASM_OP_I32AND,",
          "122:  WASM_OP_I32OR,",
          "123:  WASM_OP_I32XOR,",
          "124:  WASM_OP_I32SHL,",
          "125:  WASM_OP_I32SHRS,",
          "126:  WASM_OP_I32SHRU,",
          "127:  WASM_OP_I32ROTL,",
          "128:  WASM_OP_I32ROTR,",
          "129:  WASM_OP_I64CLZ,",
          "130:  WASM_OP_I64CTZ,",
          "131:  WASM_OP_I64POPCNT,",
          "132:  WASM_OP_I64ADD,",
          "133:  WASM_OP_I64SUB,",
          "134:  WASM_OP_I64MUL,",
          "135:  WASM_OP_I64DIVS,",
          "136:  WASM_OP_I64DIVU,",
          "137:  WASM_OP_I64REMS,",
          "138:  WASM_OP_I64REMU,",
          "139:  WASM_OP_I64AND,",
          "140:  WASM_OP_I64OR,",
          "141:  WASM_OP_I64XOR,",
          "142:  WASM_OP_I64SHL,",
          "143:  WASM_OP_I64SHRS,",
          "144:  WASM_OP_I64SHRU,",
          "145:  WASM_OP_I64ROTL,",
          "146:  WASM_OP_I64ROTR,",
          "147:  WASM_OP_F32ABS,",
          "148:  WASM_OP_F32NEG,",
          "149:  WASM_OP_F32CEIL,",
          "150:  WASM_OP_F32FLOOR,",
          "151:  WASM_OP_F32TRUNC,",
          "152:  WASM_OP_F32NEAREST,",
          "153:  WASM_OP_F32SQRT,",
          "154:  WASM_OP_F32ADD,",
          "155:  WASM_OP_F32SUB,",
          "156:  WASM_OP_F32MUL,",
          "157:  WASM_OP_F32DIV,",
          "158:  WASM_OP_F32MIN,",
          "159:  WASM_OP_F32MAX,",
          "160:  WASM_OP_F32COPYSIGN,",
          "161:  WASM_OP_F64ABS,",
          "162:  WASM_OP_F64NEG,",
          "163:  WASM_OP_F64CEIL,",
          "164:  WASM_OP_F64FLOOR,",
          "165:  WASM_OP_F64TRUNC,",
          "166:  WASM_OP_F64NEAREST,",
          "167:  WASM_OP_F64SQRT,",
          "168:  WASM_OP_F64ADD,",
          "169:  WASM_OP_F64SUB,",
          "170:  WASM_OP_F64MUL,",
          "171:  WASM_OP_F64DIV,",
          "172:  WASM_OP_F64MIN,",
          "173:  WASM_OP_F64MAX,",
          "174:  WASM_OP_F64COPYSIGN,",
          "177:  WASM_OP_I32WRAPI64,",
          "178:  WASM_OP_I32TRUNCSF32,",
          "179:  WASM_OP_I32TRUNCUF32,",
          "180:  WASM_OP_I32TRUNCSF64,",
          "181:  WASM_OP_I32TRUNCUF64,",
          "182:  WASM_OP_I64EXTENDSI32,",
          "183:  WASM_OP_I64EXTENDUI32,",
          "184:  WASM_OP_I64TRUNCSF32,",
          "185:  WASM_OP_I64TRUNCUF32,",
          "186:  WASM_OP_I64TRUNCSF64,",
          "187:  WASM_OP_I64TRUNCUF64,",
          "188:  WASM_OP_F32CONVERTSI32,",
          "189:  WASM_OP_F32CONVERTUI32,",
          "190:  WASM_OP_F32CONVERTSI64,",
          "191:  WASM_OP_F32CONVERTUI64,",
          "192:  WASM_OP_F32DEMOTEF64,",
          "193:  WASM_OP_F64CONVERTSI32,",
          "194:  WASM_OP_F64CONVERTUI32,",
          "195:  WASM_OP_F64CONVERTSI64,",
          "196:  WASM_OP_F64CONVERTUI64,",
          "197:  WASM_OP_F64PROMOTEF32,",
          "200:  WASM_OP_I32REINTERPRETF32,",
          "201:  WASM_OP_I64REINTERPRETF64,",
          "202:  WASM_OP_F32REINTERPRETI32,",
          "203:  WASM_OP_F64REINTERPRETI64,",
          "207: } WasmOpCodes;",
          "209: typedef struct {",
          "210:  WasmOpCodes op;",
          "211:  int len;",
          "212:  char txt[R_ASM_BUFSIZE];",
          "213: } WasmOp;",
          "215: typedef struct {",
          "216:  const char *txt;",
          "217:  size_t min, max;",
          "218: } WasmOpDef;",
          "220: static WasmOpDef opcodes[256] = {",
          "221:  [WASM_OP_TRAP] = { \"trap\", 1, 1 },",
          "222:  [WASM_OP_NOP] = { \"nop\", 1, 1 },",
          "223:  [WASM_OP_BLOCK] = { \"block\", 2, 2 },",
          "224:  [WASM_OP_LOOP] = { \"loop\", 2, 2 },",
          "225:  [WASM_OP_IF] = { \"if\", 2, 2 },",
          "226:  [WASM_OP_ELSE] = { \"else\", 1, 1 },",
          "227:  [WASM_OP_END] = { \"end\", 1, 1 },",
          "228:  [WASM_OP_BR] = { \"br\", 2, 2 },",
          "229:  [WASM_OP_BRIF] = { \"br_if\", 2, 2 },",
          "230:  [WASM_OP_BRTABLE] = { \"brtable\", 3, 0 },",
          "231:  [WASM_OP_RETURN] = { \"return\", 1, 1 },",
          "232:  [WASM_OP_CALL] = { \"call\" , 2, 2 },",
          "233:  [WASM_OP_CALLINDIRECT] = { \"call_indirect\", 3, 3 },",
          "234:  [WASM_OP_DROP] = { \"drop\", 1, 1 },",
          "235:  [WASM_OP_SELECT] = { \"select\", 1, 1 },",
          "236:  [WASM_OP_GETLOCAL] = { \"get_local\", 2, 2 },",
          "237:  [WASM_OP_SETLOCAL] = { \"set_local\", 2, 2 },",
          "238:  [WASM_OP_TEELOCAL] = { \"tee_local\", 2, 2 },",
          "239:  [WASM_OP_GETGLOBAL] = { \"get_global\", 2, 2 },",
          "240:  [WASM_OP_SETGLOBAL] = { \"set_global\", 2, 2 },",
          "241:  [WASM_OP_I32LOAD] = { \"i32.load\", 3, 3 },",
          "242:  [WASM_OP_I64LOAD] = { \"i64.load\", 3, 3 },",
          "243:  [WASM_OP_F32LOAD] = { \"f32.load\", 3, 3 },",
          "244:  [WASM_OP_F64LOAD] = { \"f64.load\", 3, 3 },",
          "245:  [WASM_OP_I32LOAD8S] = { \"i32.load8_s\", 3, 3 },",
          "246:  [WASM_OP_I32LOAD8U] = { \"i32.load8_u\", 3, 3 },",
          "247:  [WASM_OP_I32LOAD16S] = { \"i32.load16_s\", 3, 3 },",
          "248:  [WASM_OP_I32LOAD16U] = { \"i32.load_16_u\", 3, 3 },",
          "249:  [WASM_OP_I64LOAD8S] = { \"i64.load8_s\", 3, 3 },",
          "250:  [WASM_OP_I64LOAD8U] = { \"i64.load8_u\", 3, 3 },",
          "251:  [WASM_OP_I64LOAD16S] = { \"i64.load16_s\", 3, 3 },",
          "252:  [WASM_OP_I64LOAD16U] = { \"i64.load16_u\", 3, 3 },",
          "253:  [WASM_OP_I64LOAD32S] = { \"i64.load32_s\", 3, 3 },",
          "254:  [WASM_OP_I64LOAD32U] = { \"i64.load32_u\", 3, 3 },",
          "255:  [WASM_OP_I32STORE] = { \"i32.store\", 3, 3 },",
          "256:  [WASM_OP_I64STORE] = { \"i64.store\", 3, 3 },",
          "257:  [WASM_OP_F32STORE] = { \"f32.store\", 3, 3 },",
          "258:  [WASM_OP_F64STORE] = { \"f64.store\", 3, 3 },",
          "259:  [WASM_OP_I32STORE8] = { \"i32.store8\", 3, 3 },",
          "260:  [WASM_OP_I32STORE16] = { \"i32.store16\", 3, 3 },",
          "261:  [WASM_OP_I64STORE8] = { \"i64.store8\", 3, 3 },",
          "262:  [WASM_OP_I64STORE16] = { \"i64.store16\", 3, 3 },",
          "263:  [WASM_OP_I64STORE32] = { \"i64.store32\", 3, 3 },",
          "264:  [WASM_OP_CURRENTMEMORY] = { \"current_memory\", 2, 2 },",
          "265:  [WASM_OP_GROWMEMORY] = { \"grow_memory\", 2, 2 },",
          "266:  [WASM_OP_I32CONST] = { \"i32.const\", 2, 2 },",
          "267:  [WASM_OP_I64CONST] = { \"i64.const\", 2, 2 },",
          "268:  [WASM_OP_F32CONST] = { \"f32.const\", 2, 2 },",
          "269:  [WASM_OP_F64CONST] = { \"f64.const\", 2, 2 },",
          "270:  [WASM_OP_I32EQZ] = { \"i32.eqz\", 1, 1 },",
          "271:  [WASM_OP_I32EQ] = { \"i32.eq\", 1, 1 },",
          "272:  [WASM_OP_I32NE] = { \"i32.ne\", 1, 1},",
          "273:  [WASM_OP_I32LTS] = { \"i32.lt_s\", 1, 1 },",
          "274:  [WASM_OP_I32LTU] = { \"i32.lt_u\", 1, 1 },",
          "275:  [WASM_OP_I32GTS] = { \"i32.gt_s\", 1, 1 },",
          "276:  [WASM_OP_I32GTU] = { \"i32.gt_u\", 1, 1 },",
          "277:  [WASM_OP_I32LES] = { \"i32.le_s\", 1, 1 },",
          "278:  [WASM_OP_I32LEU] = { \"i32.le_u\", 1, 1 },",
          "279:  [WASM_OP_I32GES] = { \"i32.ge_s\", 1, 1 },",
          "280:  [WASM_OP_I32GEU] = { \"i32.ge_u\", 1, 1 },",
          "281:  [WASM_OP_I64EQZ] = { \"i64.eqz\", 1, 1 },",
          "282:  [WASM_OP_I64EQ] = {\" i64.eq\", 1, 1 },",
          "283:  [WASM_OP_I64NE] = {\" i64.ne\", 1, 1 },",
          "284:  [WASM_OP_I64LTS] = { \"i64.lt_s\", 1, 1 },",
          "285:  [WASM_OP_I64LTU] = { \"i64.lt_u\", 1, 1 },",
          "286:  [WASM_OP_I64GTS] = { \"i64.gt_s\", 1, 1 },",
          "287:  [WASM_OP_I64GTU] = { \"i64.gt_u\", 1, 1 },",
          "288:  [WASM_OP_I64LES] = { \"i64.le_s\", 1, 1 },",
          "289:  [WASM_OP_I64LEU] = { \"i64.le_u\", 1, 1 },",
          "290:  [WASM_OP_I64GES] = { \"i64.ge_s\", 1, 1 },",
          "291:  [WASM_OP_I64GEU] = { \"i64.ge_u\", 1, 1 },",
          "292:  [WASM_OP_F32EQ] = { \"f32.eq\", 1, 1 },",
          "293:  [WASM_OP_F32NE] = { \"f32.ne\", 1, 1 },",
          "294:  [WASM_OP_F32LT] = { \"f32.lt\", 1, 1 },",
          "295:  [WASM_OP_F32GT] = { \"f32.gt\", 1, 1 },",
          "296:  [WASM_OP_F32LE] = { \"f32.le\", 1, 1 },",
          "297:  [WASM_OP_F32GE] = { \"f32.ge\", 1, 1 },",
          "298:  [WASM_OP_F64EQ] = { \"f64.eq\", 1, 1 },",
          "299:  [WASM_OP_F64NE] = { \"f64.ne\", 1, 1 },",
          "300:  [WASM_OP_F64LT] = { \"f64.lt\", 1, 1 },",
          "301:  [WASM_OP_F64GT] = { \"f64.gt\", 1, 1 },",
          "302:  [WASM_OP_F64LE] = { \"f64.le\", 1, 1 },",
          "303:  [WASM_OP_F64GE] = { \"f64.ge\", 1, 1 },",
          "304:  [WASM_OP_I32CLZ] = { \"i32.clz\", 1, 1 },",
          "305:  [WASM_OP_I32CTZ] = { \"i32.ctz\", 1, 1 },",
          "306:  [WASM_OP_I32POPCNT] = { \"i32.popcnt\", 1, 1 },",
          "307:  [WASM_OP_I32ADD] = { \"i32.add\", 1, 1 },",
          "308:  [WASM_OP_I32SUB] = { \"i32.sub\", 1, 1 },",
          "309:  [WASM_OP_I32MUL] = { \"i32.mul\", 1, 1 },",
          "310:  [WASM_OP_I32DIVS] = { \"i32.div_s\", 1, 1 },",
          "311:  [WASM_OP_I32DIVU] = { \"i32.div_u\", 1, 1 },",
          "312:  [WASM_OP_I32REMS] = { \"i32.rem_s\", 1, 1 },",
          "313:  [WASM_OP_I32REMU] = { \"i32.rem_u\", 1, 1 },",
          "314:  [WASM_OP_I32AND] = { \"i32.and\", 1, 1 },",
          "315:  [WASM_OP_I32OR] = { \"i32.or\", 1, 1 },",
          "316:  [WASM_OP_I32XOR] = { \"i32.xor\", 1, 1 },",
          "317:  [WASM_OP_I32SHL] = { \"i32.shl\", 1, 1 },",
          "318:  [WASM_OP_I32SHRS] = { \"i32.shr_s\", 1, 1 },",
          "319:  [WASM_OP_I32SHRU] = { \"i32.shr_u\", 1, 1 },",
          "320:  [WASM_OP_I32ROTL] = { \"i32.rotl\", 1, 1 },",
          "321:  [WASM_OP_I32ROTR] = { \"i32.rotr\", 1, 1 },",
          "322:  [WASM_OP_I64CLZ] = { \"i64.clz\", 1, 1 },",
          "323:  [WASM_OP_I64CTZ] = { \"i64.ctz\", 1, 1 },",
          "324:  [WASM_OP_I64POPCNT] = { \"i64.popcnt\", 1, 1 },",
          "325:  [WASM_OP_I64ADD] = { \"i64.add\", 1, 1 },",
          "326:  [WASM_OP_I64SUB] = { \"i64.sub\", 1, 1 },",
          "327:  [WASM_OP_I64MUL] = { \"i64.mul\", 1, 1 },",
          "328:  [WASM_OP_I64DIVS] = { \"i64.div_s\", 1, 1 },",
          "329:  [WASM_OP_I64DIVU] = { \"i64.div_u\", 1, 1 },",
          "330:  [WASM_OP_I64REMS] = { \"i64.rem_s\", 1, 1 },",
          "331:  [WASM_OP_I64REMU] = { \"i64.rem_u\", 1, 1 },",
          "332:  [WASM_OP_I64AND] = { \"i64.and\", 1, 1 },",
          "333:  [WASM_OP_I64OR] = { \"i64.or\", 1, 1 },",
          "334:  [WASM_OP_I64XOR] = { \"i64.xor\", 1, 1 },",
          "335:  [WASM_OP_I64SHL] = { \"i64.shl\", 1, 1 },",
          "336:  [WASM_OP_I64SHRS] = { \"i64.shr_s\", 1, 1 },",
          "337:  [WASM_OP_I64SHRU] = { \"i64.shr_u\", 1, 1 },",
          "338:  [WASM_OP_I64ROTL] = { \"i64.rotl\", 1, 1 },",
          "339:  [WASM_OP_I64ROTR] = { \"i64.rotr\", 1, 1 },",
          "340:  [WASM_OP_F32ABS] = { \"f32.abs\", 1, 1 },",
          "341:  [WASM_OP_F32NEG] = { \"f32.neg\", 1, 1 },",
          "342:  [WASM_OP_F32CEIL] = { \"f32.ceil\", 1, 1 },",
          "343:  [WASM_OP_F32FLOOR] = { \"f32.floor\", 1, 1 },",
          "344:  [WASM_OP_F32TRUNC] = { \"f32.trunc\", 1, 1 },",
          "345:  [WASM_OP_F32NEAREST] = { \"f32.nearest\", 1, 1 },",
          "346:  [WASM_OP_F32SQRT] = { \"f32.sqrt\", 1, 1 },",
          "347:  [WASM_OP_F32ADD] = { \"f32.add\", 1, 1 },",
          "348:  [WASM_OP_F32SUB] =  { \"f32.sub\", 1, 1 },",
          "349:  [WASM_OP_F32MUL] = { \"f32.mul\", 1, 1 },",
          "350:  [WASM_OP_F32DIV] = { \"f32.div\", 1, 1 },",
          "351:  [WASM_OP_F32MIN] = { \"f32.min\", 1, 1 },",
          "352:  [WASM_OP_F32MAX] = { \"f32.max\", 1, 1 },",
          "353:  [WASM_OP_F32COPYSIGN] = {\" f32.copysign\", 1, 1 },",
          "354:  [WASM_OP_F64ABS] = { \"f64.abs\", 1, 1 },",
          "355:  [WASM_OP_F64NEG] = { \"f64.neg\", 1, 1 },",
          "356:  [WASM_OP_F64CEIL] = { \"f64.ceil\", 1, 1 },",
          "357:  [WASM_OP_F64FLOOR] = { \"f64.floor\", 1, 1 },",
          "358:  [WASM_OP_F64TRUNC] = { \"f64.trunc\", 1, 1 },",
          "359:  [WASM_OP_F64NEAREST] = { \"f64.nearest\", 1, 1 },",
          "360:  [WASM_OP_F64SQRT] = { \"f64.sqrt\", 1, 1 },",
          "361:  [WASM_OP_F64ADD] = { \"f64.add\", 1, 1 },",
          "362:  [WASM_OP_F64SUB] = { \"f64.sub\", 1, 1 },",
          "363:  [WASM_OP_F64MUL] = { \"f64.mul\", 1, 1 },",
          "364:  [WASM_OP_F64DIV] = { \"f64.div\", 1, 1 },",
          "365:  [WASM_OP_F64MIN] = { \"f64.min\", 1, 1 },",
          "366:  [WASM_OP_F64MAX] = { \"f64.max\", 1, 1 },",
          "367:  [WASM_OP_F64COPYSIGN] = { \"f64.copysign\", 1, 1 },",
          "368:  [WASM_OP_I32WRAPI64] = { \"i32.wrap/i64\", 1, 1 },",
          "369:  [WASM_OP_I32TRUNCSF32] = { \"i32.trunc_s/f32\", 1, 1 },",
          "370:  [WASM_OP_I32TRUNCUF32] = { \"i32.trunc_u/f32\", 1, 1 },",
          "371:  [WASM_OP_I32TRUNCSF64] = { \"i32.trunc_s/f64\", 1, 1 },",
          "372:  [WASM_OP_I32TRUNCUF64] = { \"i32.trunc_u/f64\", 1, 1 },",
          "373:  [WASM_OP_I64EXTENDSI32] = { \"i64.extend_s/i32\", 1, 1 },",
          "374:  [WASM_OP_I64EXTENDUI32] = { \"i64.extend_u/i32\", 1, 1 },",
          "375:  [WASM_OP_I64TRUNCSF32] = { \"i64.trunc_s/f32\", 1, 1 },",
          "376:  [WASM_OP_I64TRUNCUF32] = { \"i64.trunc_u/f32\", 1, 1 },",
          "377:  [WASM_OP_I64TRUNCSF64] = { \"i64.trunc_s/f64\", 1, 1 },",
          "378:  [WASM_OP_I64TRUNCUF64] = { \"i64.trunc_u/f64\", 1, 1 },",
          "379:  [WASM_OP_F32CONVERTSI32] = { \"f32.convert_s/i32\", 1, 1 },",
          "380:  [WASM_OP_F32CONVERTUI32] = { \"f32.convert_u/i32\", 1, 1 },",
          "381:  [WASM_OP_F32CONVERTSI64] = { \"f32.convert_s/i64\", 1, 1 },",
          "382:  [WASM_OP_F32CONVERTUI64] = { \"f32.convert_u/i64\", 1, 1 },",
          "383:  [WASM_OP_F32DEMOTEF64] = { \"f32.demote/f64\", 1, 1 },",
          "384:  [WASM_OP_F64CONVERTSI32] = { \"f64.convert_s/i32\", 1, 1 },",
          "385:  [WASM_OP_F64CONVERTUI32] = { \"f64.convert_u/i32\", 1, 1 },",
          "386:  [WASM_OP_F64CONVERTSI64] = { \"f64.convert_s/i64\", 1, 1 },",
          "387:  [WASM_OP_F64CONVERTUI64] = { \"f64.convert_u/i64\", 1, 1 },",
          "388:  [WASM_OP_F64PROMOTEF32] = { \"f64.promote/f32\", 1, 1 },",
          "389:  [WASM_OP_I32REINTERPRETF32] = { \"i32.reinterpret/f32\", 1, 1 },",
          "390:  [WASM_OP_I64REINTERPRETF64] = { \"i64.reinterpret/f64\", 1, 1 },",
          "391:  [WASM_OP_F32REINTERPRETI32] = { \"f32.reinterpret/i32\", 1, 1 },",
          "392:  [WASM_OP_F64REINTERPRETI64] = { \"f64/reinterpret/i64\", 1, 1 }",
          "393: };",
          "395: int wasm_asm(const char *str, unsigned char *buf, int buf_len) {",
          "397:  int i = 0, len = -1;",
          "398:  char tmp[R_ASM_BUFSIZE];",
          "399:  while (str[i] != ' ' && i < buf_len) tmp[i++] = str[i];",
          "400:  tmp[i] = 0;",
          "401:  for (i = 0; i< 0xff; i++) {",
          "402:   WasmOpDef *opdef = &opcodes[i];",
          "403:   if (opdef->txt) {",
          "404:    if (!strcmp (opdef->txt, tmp)) {",
          "405:     buf[0] = i;",
          "406:     return 1;",
          "407:    }",
          "408:   }",
          "409:  }",
          "410:  return len;",
          "411: }",
          "413: int wasm_dis(WasmOp *op, const unsigned char *buf, int buf_len) {",
          "414:  op->len = 1;",
          "415:  op->op = buf[0];",
          "416:  WasmOpDef *opdef = &opcodes[op->op];",
          "417:  if (!opdef) {",
          "418:   return op->len;",
          "419:  }",
          "420:  switch (op->op) {",
          "421:  case WASM_OP_TRAP:",
          "422:  case WASM_OP_NOP:",
          "423:  case WASM_OP_ELSE:",
          "424:  case WASM_OP_RETURN:",
          "425:  case WASM_OP_DROP:",
          "426:  case WASM_OP_SELECT:",
          "427:  case WASM_OP_I32EQZ:",
          "428:  case WASM_OP_I32EQ:",
          "429:  case WASM_OP_I32NE:",
          "430:  case WASM_OP_I32LTS:",
          "431:  case WASM_OP_I32LTU:",
          "432:  case WASM_OP_I32GTS:",
          "433:  case WASM_OP_I32GTU:",
          "434:  case WASM_OP_I32LES:",
          "435:  case WASM_OP_I32LEU:",
          "436:  case WASM_OP_I32GES:",
          "437:  case WASM_OP_I32GEU:",
          "438:  case WASM_OP_I64EQZ:",
          "439:  case WASM_OP_I64EQ:",
          "440:  case WASM_OP_I64NE:",
          "441:  case WASM_OP_I64LTS:",
          "442:  case WASM_OP_I64LTU:",
          "443:  case WASM_OP_I64GTS:",
          "444:  case WASM_OP_I64GTU:",
          "445:  case WASM_OP_I64LES:",
          "446:  case WASM_OP_I64LEU:",
          "447:  case WASM_OP_I64GES:",
          "448:  case WASM_OP_I64GEU:",
          "449:  case WASM_OP_F32EQ:",
          "450:  case WASM_OP_F32NE:",
          "451:  case WASM_OP_F32LT:",
          "452:  case WASM_OP_F32GT:",
          "453:  case WASM_OP_F32LE:",
          "454:  case WASM_OP_F32GE:",
          "455:  case WASM_OP_F64EQ:",
          "456:  case WASM_OP_F64NE:",
          "457:  case WASM_OP_F64LT:",
          "458:  case WASM_OP_F64GT:",
          "459:  case WASM_OP_F64LE:",
          "460:  case WASM_OP_F64GE:",
          "461:  case WASM_OP_I32CLZ:",
          "462:  case WASM_OP_I32CTZ:",
          "463:  case WASM_OP_I32POPCNT:",
          "464:  case WASM_OP_I32ADD:",
          "465:  case WASM_OP_I32SUB:",
          "466:  case WASM_OP_I32MUL:",
          "467:  case WASM_OP_I32DIVS:",
          "468:  case WASM_OP_I32DIVU:",
          "469:  case WASM_OP_I32REMS:",
          "470:  case WASM_OP_I32REMU:",
          "471:  case WASM_OP_I32AND:",
          "472:  case WASM_OP_I32OR:",
          "473:  case WASM_OP_I32XOR:",
          "474:  case WASM_OP_I32SHL:",
          "475:  case WASM_OP_I32SHRS:",
          "476:  case WASM_OP_I32SHRU:",
          "477:  case WASM_OP_I32ROTL:",
          "478:  case WASM_OP_I32ROTR:",
          "479:  case WASM_OP_I64CLZ:",
          "480:  case WASM_OP_I64CTZ:",
          "481:  case WASM_OP_I64POPCNT:",
          "482:  case WASM_OP_I64ADD:",
          "483:  case WASM_OP_I64SUB:",
          "484:  case WASM_OP_I64MUL:",
          "485:  case WASM_OP_I64DIVS:",
          "486:  case WASM_OP_I64DIVU:",
          "487:  case WASM_OP_I64REMS:",
          "488:  case WASM_OP_I64REMU:",
          "489:  case WASM_OP_I64AND:",
          "490:  case WASM_OP_I64OR:",
          "491:  case WASM_OP_I64XOR:",
          "492:  case WASM_OP_I64SHL:",
          "493:  case WASM_OP_I64SHRS:",
          "494:  case WASM_OP_I64SHRU:",
          "495:  case WASM_OP_I64ROTL:",
          "496:  case WASM_OP_I64ROTR:",
          "497:  case WASM_OP_F32ABS:",
          "498:  case WASM_OP_F32NEG:",
          "499:  case WASM_OP_F32CEIL:",
          "500:  case WASM_OP_F32FLOOR:",
          "501:  case WASM_OP_F32TRUNC:",
          "502:  case WASM_OP_F32NEAREST:",
          "503:  case WASM_OP_F32SQRT:",
          "504:  case WASM_OP_F32ADD:",
          "505:  case WASM_OP_F32SUB:",
          "506:  case WASM_OP_F32MUL:",
          "507:  case WASM_OP_F32DIV:",
          "508:  case WASM_OP_F32MIN:",
          "509:  case WASM_OP_F32MAX:",
          "510:  case WASM_OP_F32COPYSIGN:",
          "511:  case WASM_OP_F64ABS:",
          "512:  case WASM_OP_F64NEG:",
          "513:  case WASM_OP_F64CEIL:",
          "514:  case WASM_OP_F64FLOOR:",
          "515:  case WASM_OP_F64TRUNC:",
          "516:  case WASM_OP_F64NEAREST:",
          "517:  case WASM_OP_F64SQRT:",
          "518:  case WASM_OP_F64ADD:",
          "519:  case WASM_OP_F64SUB:",
          "520:  case WASM_OP_F64MUL:",
          "521:  case WASM_OP_F64DIV:",
          "522:  case WASM_OP_F64MIN:",
          "523:  case WASM_OP_F64MAX:",
          "524:  case WASM_OP_F64COPYSIGN:",
          "525:  case WASM_OP_I32WRAPI64:",
          "526:  case WASM_OP_I32TRUNCSF32:",
          "527:  case WASM_OP_I32TRUNCUF32:",
          "528:  case WASM_OP_I32TRUNCSF64:",
          "529:  case WASM_OP_I32TRUNCUF64:",
          "530:  case WASM_OP_I64EXTENDSI32:",
          "531:  case WASM_OP_I64EXTENDUI32:",
          "532:  case WASM_OP_I64TRUNCSF32:",
          "533:  case WASM_OP_I64TRUNCUF32:",
          "534:  case WASM_OP_I64TRUNCSF64:",
          "535:  case WASM_OP_I64TRUNCUF64:",
          "536:  case WASM_OP_F32CONVERTSI32:",
          "537:  case WASM_OP_F32CONVERTUI32:",
          "538:  case WASM_OP_F32CONVERTSI64:",
          "539:  case WASM_OP_F32CONVERTUI64:",
          "540:  case WASM_OP_F32DEMOTEF64:",
          "541:  case WASM_OP_F64CONVERTSI32:",
          "542:  case WASM_OP_F64CONVERTUI32:",
          "543:  case WASM_OP_F64CONVERTSI64:",
          "544:  case WASM_OP_F64CONVERTUI64:",
          "545:  case WASM_OP_F64PROMOTEF32:",
          "546:  case WASM_OP_I32REINTERPRETF32:",
          "547:  case WASM_OP_I64REINTERPRETF64:",
          "548:  case WASM_OP_F32REINTERPRETI32:",
          "549:  case WASM_OP_F64REINTERPRETI64:",
          "550:  case WASM_OP_END:",
          "551:   {",
          "552:    snprintf (op->txt, R_ASM_BUFSIZE, \"%s\", opdef->txt);",
          "553:   }",
          "554:   break;",
          "555:  case WASM_OP_BLOCK:",
          "556:  case WASM_OP_LOOP:",
          "557:  case WASM_OP_IF:",
          "558:   {",
          "559:    st32 val = 0;",
          "560:    size_t n = read_i32_leb128 (buf + 1, buf + buf_len, &val);",
          "561:    if (!(n > 0 && n < buf_len)) goto err;",
          "562:    switch (0x80 - val) {",
          "563:    case R_BIN_WASM_VALUETYPE_EMPTY:",
          "564:     snprintf (op->txt, R_ASM_BUFSIZE, \"%s\", opdef->txt);",
          "565:     break;",
          "566:    case R_BIN_WASM_VALUETYPE_i32:",
          "567:     snprintf (op->txt, R_ASM_BUFSIZE, \"%s (result i32)\", opdef->txt);",
          "568:     break;",
          "569:    case R_BIN_WASM_VALUETYPE_i64:",
          "570:     snprintf (op->txt, R_ASM_BUFSIZE, \"%s (result i64)\", opdef->txt);",
          "571:     break;",
          "572:    case R_BIN_WASM_VALUETYPE_f32:",
          "573:     snprintf (op->txt, R_ASM_BUFSIZE, \"%s (result f32)\", opdef->txt);",
          "574:     break;",
          "575:    case R_BIN_WASM_VALUETYPE_f64:",
          "576:     snprintf (op->txt, R_ASM_BUFSIZE, \"%s (result f64)\", opdef->txt);",
          "577:     break;",
          "578:    default:",
          "579:     snprintf (op->txt, R_ASM_BUFSIZE, \"%s (result ?)\", opdef->txt);",
          "580:     break;",
          "581:    }",
          "582:    op->len += n;",
          "583:   }",
          "584:   break;",
          "585:  case WASM_OP_BR:",
          "586:  case WASM_OP_BRIF:",
          "587:  case WASM_OP_CALL:",
          "588:   {",
          "589:    ut32 val = 0;",
          "590:    size_t n = read_u32_leb128 (buf + 1, buf + buf_len, &val);",
          "591:    if (!(n > 0 && n < buf_len)) goto err;",
          "592:    snprintf (op->txt, R_ASM_BUFSIZE, \"%s %d\", opdef->txt, val);",
          "593:    op->len += n;",
          "594:   }",
          "595:   break;",
          "596:  case WASM_OP_BRTABLE:",
          "597:   {",
          "598:    ut32 count = 0, *table = NULL, def = 0;",
          "599:    size_t n = read_u32_leb128 (buf + 1, buf + buf_len, &count);",
          "600:    if (!(n > 0 && n < buf_len)) goto err;",
          "601:    if (!(table = calloc (count, sizeof (ut32)))) goto err;",
          "602:    int i = 0;",
          "603:    op->len += n;",
          "604:    for (i = 0; i < count; i++) {",
          "605:     n = read_u32_leb128 (buf + op->len, buf + buf_len, &table[i]);",
          "606:     if (!(op->len + n <= buf_len)) goto err;",
          "607:     op->len += n;",
          "608:    }",
          "609:    n = read_u32_leb128 (buf + op->len, buf + buf_len, &def);",
          "610:    if (!(n > 0 && n + op->len < buf_len)) goto err;",
          "611:    op->len += n;",
          "612:    snprintf (op->txt, R_ASM_BUFSIZE, \"%s %d \", opdef->txt, count);",
          "613:    for (i = 0; i < count; i++) {",
          "614:     snprintf (op->txt + strlen (op->txt), R_ASM_BUFSIZE, \"%d \", table[i]);",
          "615:    }",
          "616:    snprintf (op->txt + strlen (op->txt), R_ASM_BUFSIZE, \"%d\", def);",
          "617:   }",
          "618:   break;",
          "619:  case WASM_OP_CALLINDIRECT:",
          "620:   {",
          "621:    ut32 val = 0, reserved = 0;",
          "622:    size_t n = read_u32_leb128 (buf + 1, buf + buf_len, &val);",
          "623:    if (!(n > 0 && n < buf_len)) goto err;",
          "624:    op->len += n;",
          "625:    n = read_u32_leb128 (buf + op->len, buf + buf_len, &reserved);",
          "626:    if (!(n == 1 && op->len + n <= buf_len)) goto err;",
          "627:    reserved &= 0x1;",
          "628:    snprintf (op->txt, R_ASM_BUFSIZE, \"%s %d %d\", opdef->txt, val, reserved);",
          "629:    op->len += n;",
          "630:   }",
          "631:   break;",
          "632:  case WASM_OP_GETLOCAL:",
          "633:  case WASM_OP_SETLOCAL:",
          "634:  case WASM_OP_TEELOCAL:",
          "635:  case WASM_OP_GETGLOBAL:",
          "636:  case WASM_OP_SETGLOBAL:",
          "637:   {",
          "638:    ut32 val = 0;",
          "639:    size_t n = read_u32_leb128 (buf + 1, buf + buf_len, &val);",
          "640:    if (!(n > 0 && n < buf_len)) goto err;",
          "641:    snprintf (op->txt, R_ASM_BUFSIZE, \"%s %d\", opdef->txt, val);",
          "642:    op->len += n;",
          "643:   }",
          "644:   break;",
          "645:  case WASM_OP_I32LOAD:",
          "646:  case WASM_OP_I64LOAD:",
          "647:  case WASM_OP_F32LOAD:",
          "648:  case WASM_OP_F64LOAD:",
          "649:  case WASM_OP_I32LOAD8S:",
          "650:  case WASM_OP_I32LOAD8U:",
          "651:  case WASM_OP_I32LOAD16S:",
          "652:  case WASM_OP_I32LOAD16U:",
          "653:  case WASM_OP_I64LOAD8S:",
          "654:  case WASM_OP_I64LOAD8U:",
          "655:  case WASM_OP_I64LOAD16S:",
          "656:  case WASM_OP_I64LOAD16U:",
          "657:  case WASM_OP_I64LOAD32S:",
          "658:  case WASM_OP_I64LOAD32U:",
          "659:  case WASM_OP_I32STORE:",
          "660:  case WASM_OP_I64STORE:",
          "661:  case WASM_OP_F32STORE:",
          "662:  case WASM_OP_F64STORE:",
          "663:  case WASM_OP_I32STORE8:",
          "664:  case WASM_OP_I32STORE16:",
          "665:  case WASM_OP_I64STORE8:",
          "666:  case WASM_OP_I64STORE16:",
          "667:  case WASM_OP_I64STORE32:",
          "668:   {",
          "669:    ut32 flag = 0, offset = 0;",
          "670:    size_t n = read_u32_leb128 (buf + 1, buf + buf_len, &flag);",
          "671:    if (!(n > 0 && n < buf_len)) goto err;",
          "672:    op->len += n;",
          "673:    n = read_u32_leb128 (buf + op->len, buf + buf_len, &offset);",
          "674:    if (!(n > 0 && op->len + n <= buf_len)) goto err;",
          "675:    snprintf (op->txt, R_ASM_BUFSIZE, \"%s %d %d\", opdef->txt, flag, offset);",
          "676:    op->len += n;",
          "677:   }",
          "678:   break;",
          "679:  case WASM_OP_CURRENTMEMORY:",
          "680:  case WASM_OP_GROWMEMORY:",
          "681:   {",
          "682:    ut32 reserved = 0;",
          "683:    size_t n = read_u32_leb128 (buf + 1, buf + buf_len, &reserved);",
          "684:    if (!(n == 1 && n < buf_len)) goto err;",
          "685:    reserved &= 0x1;",
          "686:    snprintf (op->txt, R_ASM_BUFSIZE, \"%s %d\", opdef->txt, reserved);",
          "687:    op->len += n;",
          "688:   }",
          "689:   break;",
          "691:  case WASM_OP_I32CONST:",
          "692:   {",
          "693:    st32 val = 0;",
          "694:    size_t n = read_i32_leb128 (buf + 1, buf + buf_len, &val);",
          "695:    if (!(n > 0 && n < buf_len)) goto err;",
          "696:    snprintf (op->txt, R_ASM_BUFSIZE, \"%s %\" PFMT32d, opdef->txt, val);",
          "697:    op->len += n;",
          "698:   }",
          "699:   break;",
          "700:  case WASM_OP_I64CONST:",
          "701:   {",
          "702:    st64 val = 0;",
          "703:    size_t n = read_i64_leb128 (buf + 1, buf + buf_len, &val);",
          "704:    if (!(n > 0 && n < buf_len)) goto err;",
          "705:    snprintf (op->txt, R_ASM_BUFSIZE, \"%s %\" PFMT64d, opdef->txt, val);",
          "706:    op->len += n;",
          "707:   }",
          "708:   break;",
          "709:  case WASM_OP_F32CONST:",
          "710:   {",
          "711:    ut32 val = 0;",
          "712:    size_t n = read_u32_leb128 (buf + 1, buf + buf_len, &val);",
          "713:    if (!(n > 0 && n < buf_len)) goto err;",
          "714:    long double d =  (long double)val;",
          "715:    snprintf (op->txt, R_ASM_BUFSIZE, \"%s %\" LDBLFMT, opdef->txt, d);",
          "716:    op->len += n;",
          "717:   }",
          "718:   break;",
          "719:  case WASM_OP_F64CONST:",
          "720:   {",
          "721:    ut64 val = 0;",
          "722:    size_t n = read_u64_leb128 (buf + 1, buf + buf_len, &val);",
          "723:    if (!(n > 0 && n < buf_len)) goto err;",
          "724:    long double d =  (long double)val;",
          "725:    snprintf (op->txt, R_ASM_BUFSIZE, \"%s %\" LDBLFMT, opdef->txt, d);",
          "726:    op->len += n;",
          "727:   }",
          "728:   break;",
          "729:  default:",
          "730:   goto err;",
          "731:  }",
          "733:  return op->len;",
          "735: err:",
          "736:  op->len = 1;",
          "737:  snprintf (op->txt, R_ASM_BUFSIZE, \"invalid\");",
          "738:  return op->len;",
          "739: }",
          "",
          "---------------"
        ],
        "libr/asm/p/asm_wasm.c||libr/asm/p/asm_wasm.c": [
          "File: libr/asm/p/asm_wasm.c -> libr/asm/p/asm_wasm.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "8: #include <r_lib.h>",
          "9: #include <r_asm.h>",
          "201: static int disassemble(RAsm *a, RAsmOp *op, const ut8 *buf, int len) {",
          "516: }",
          "518: RAsmPlugin r_asm_plugin_wasm = {",
          "519:  .name = \"wasm\",",
          "521:  .version = \"0.1.0\",",
          "522:  .arch = \"wasm\",",
          "523:  .license = \"MIT\",",
          "524:  .bits = 32,",
          "525:  .endian = R_SYS_ENDIAN_LITTLE,",
          "526:  .desc = \"WebAssembly\",",
          "528: };",
          "530: #ifndef CORELIB",
          "",
          "[Removed Lines]",
          "11: static const char * const opcodes[] = {",
          "13:  \"trap\",    // 0x00",
          "14:  \"nop\",    // 0x01",
          "15:  \"block\",   // 0x02",
          "16:  \"loop\",    // 0x03",
          "17:  \"if\",    // 0x04",
          "18:  \"else\",    // 0x05",
          "19:  NULL,NULL,NULL,NULL,NULL,",
          "20:  \"end\",    // 0x0b",
          "21:  \"br\",    // 0x0c",
          "22:  \"br_if\",   // 0x0d",
          "23:  \"br_table\",   // 0x0e",
          "24:  \"return\",   // 0x0f",
          "26:  \"call\",    // 0x10",
          "27:  \"call_indirect\",  // 0x11",
          "28:  NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,",
          "30:  \"drop\",    // 0x1a",
          "31:  \"select\",   // 0x1b",
          "32:  NULL,NULL,NULL,NULL,",
          "34:  \"get_local\",  // 0x20",
          "35:  \"set_local\",  // 0x21",
          "36:  \"tee_local\",  // 0x22",
          "37:  \"get_global\",  // 0x23",
          "38:  \"set_global\",  // 0x24",
          "39:  NULL,NULL,NULL,",
          "41:  \"i32.load\",   // 0x28",
          "42:  \"i64.load\",   // 0x29",
          "43:  \"f32.load\",   // 0x2a",
          "44:  \"f64.load\",   // 0x2b",
          "45:  \"i32.load8_s\",  // 0x2c",
          "46:  \"i32.load8_u\",  // 0x2d",
          "47:  \"i32.load16_s\",  // 0x2e",
          "48:  \"i64.load_16_u\", // 0x2f",
          "49:  \"i64.load8_s\",  // 0x30",
          "50:  \"i64.load8_u\",  // 0x31",
          "51:  \"i64.load16_s\",  // 0x32",
          "52:  \"i64.load16_u\",  // 0x33",
          "53:  \"i64.load32_s\",  // 0x34",
          "54:  \"i64.load32_u\",  // 0x35",
          "55:  \"i32.store\",  // 0x36",
          "56:  \"i64.store\",  // 0x37",
          "57:  \"f32.store\",  // 0x38",
          "58:  \"f64.store\",  // 0x39",
          "59:  \"i32.store8\",  // 0x3a",
          "60:  \"i32.store16\",  // 0x3b",
          "61:  \"i64.store8\",  // 0x3c",
          "62:  \"i64.store16\",  // 0x3d",
          "63:  \"i64.store32\",  // 0x3e",
          "64:  \"current_memory\", // 0x3f",
          "65:  \"grow_memory\",  // 0x40",
          "67:  \"i32.const\",  // 0x41",
          "68:  \"i64.const\",  // 0x42",
          "69:  \"f32.const\",  // 0x43",
          "70:  \"f64.const\",  // 0x44",
          "72:  \"i32.eqz\",   // 0x45",
          "73:  \"i32.eq\",   // 0x46",
          "74:  \"i32.ne\",   // 0x47",
          "75:  \"i32.lt_s\",   // 0x48",
          "76:  \"i32.lt_u\",   // 0x49",
          "77:  \"i32.gt_s\",   // 0x4a",
          "78:  \"i32.gt_u\",   // 0x4b",
          "79:  \"i32.le_s\",   // 0x4c",
          "80:  \"i32.le_u\",   // 0x4d",
          "81:  \"i32.ge_s\",   // 0x4e",
          "82:  \"i32.ge_u\",   // 0x4f",
          "83:  \"i64.eqz\",   // 0x50",
          "84:  \"i64.eq\",   // 0x51",
          "85:  \"i64.ne\",   // 0x52",
          "86:  \"i64.lt_s\",   // 0x53",
          "87:  \"i64.lt_u\",   // 0x54",
          "88:  \"i64.gt_s\",   // 0x55",
          "89:  \"i64.gt_u\",   // 0x56",
          "90:  \"i64.le_s\",   // 0x57",
          "91:  \"i64.le_u\",   // 0x58",
          "92:  \"i64.ge_s\",   // 0x59",
          "93:  \"i64.ge_u\",   // 0x5a",
          "94:  \"f32.eq\",   // 0x5b",
          "95:  \"f32.ne\",   // 0x5c",
          "96:  \"f32.lt\",   // 0x5d",
          "97:  \"f32.gt\",   // 0x5e",
          "98:  \"f32.le\",   // 0x5f",
          "99:  \"f32.ge\",   // 0x60",
          "100:  \"f64.eq\",   // 0x61",
          "101:  \"f64.ne\",   // 0x62",
          "102:  \"f64.lt\",   // 0x63",
          "103:  \"f64.gt\",   // 0x64",
          "104:  \"f64.le\",   // 0x65",
          "105:  \"f64.ge\",   // 0x66",
          "107:  \"i32.clz\",   // 0x67",
          "108:  \"i32.ctz\",   // 0x68",
          "109:  \"i32.popcnt\",  // 0x69",
          "110:  \"i32.add\",   // 0x6a",
          "111:  \"i32.sub\",   // 0x6b",
          "112:  \"i32.mul\",   // 0x6c",
          "113:  \"i32.div_s\",  // 0x6d",
          "114:  \"i32.div_u\",  // 0x6e",
          "115:  \"i32.rem_s\",  // 0x6f",
          "116:  \"i32.rem_u\",  // 0x7f",
          "117:  \"i32.and\",   // 0x71",
          "118:  \"i32.or\",   // 0x72",
          "119:  \"i32.xor\",   // 0x73",
          "120:  \"i32.shl\",   // 0x74",
          "121:  \"i32.shr_s\",  // 0x75",
          "122:  \"i32.shr_u\",  // 0x76",
          "123:  \"i32.rotl\",   // 0x77",
          "124:  \"i32.rotr\",   // 0x78",
          "125:  \"i64.clz\",   // 0x79",
          "126:  \"i64.ctz\",   // 0x7a",
          "127:  \"i64.popcnt\",  // 0x7b",
          "128:  \"i64.add\",   // 0x7c",
          "129:  \"i64.sub\",   // 0x7d",
          "130:  \"i64.mul\",   // 0x7e",
          "131:  \"i64.div_s\",  // 0x7f",
          "132:  \"i64.div_u\",  // 0x80",
          "133:  \"i64.rem_s\",  // 0x81",
          "134:  \"i64.rem_u\",  // 0x82",
          "135:  \"i64.and\",   // 0x83",
          "136:  \"i64.or\",   // 0x84",
          "137:  \"i64.xor\",   // 0x85",
          "138:  \"i64.shl\",   // 0x86",
          "139:  \"i64.shr_s\",  // 0x87",
          "140:  \"i64.shr_u\",  // 0x88",
          "141:  \"i64.rotl\",   // 0x89",
          "142:  \"i64.rotr\",   // 0x8a",
          "143:  \"f32.abs\",   // 0x8b",
          "144:  \"f32.neg\",   // 0x8c",
          "145:  \"f32.ceil\",   // 0x8d",
          "146:  \"f32.floor\",  // 0x8e",
          "147:  \"f32.trunc\",  // 0x8f",
          "148:  \"f32.nearest\",  // 0x90",
          "149:  \"f32.sqrt\",   // 0x91",
          "150:  \"f32.add\",   // 0x92",
          "151:  \"f32.sub\",   // 0x93",
          "152:  \"f32.mul\",   // 0x94",
          "153:  \"f32.div\",   // 0x95",
          "154:  \"f32.min\",   // 0x96",
          "155:  \"f32.max\",   // 0x97",
          "156:  \"f32.copysing\",  // 0x98",
          "157:  \"f64.abs\",   // 0x99",
          "158:  \"f64.neg\",   // 0x9a",
          "159:  \"f64.ceil\",   // 0x9b",
          "160:  \"f64.floor\",  // 0x9c",
          "161:  \"f64.trunc\",  // 0x9d",
          "162:  \"f64.nearest\",  // 0x9e",
          "163:  \"f64.sqrt\",   // 0x9f",
          "164:  \"f64.add\",   // 0xa0",
          "165:  \"f64.sub\",   // 0xa1",
          "166:  \"f64.mul\",   // 0xa2",
          "167:  \"f64.div\",   // 0xa3",
          "168:  \"f64.min\",   // 0xa4",
          "169:  \"f64.max\",   // 0xa5",
          "170:  \"f64.copysing\",  // 0xa6",
          "172:  \"i32.wrap/i64\",  // 0xa7",
          "173:  \"i32.trunc_s/f32\", // 0xa8",
          "174:  \"i32.trunc_u/f32\", // 0xa9",
          "175:  \"i32.trunc_s/f64\", // 0xaa",
          "176:  \"i32.trunc_u/f64\", // 0xab",
          "177:  \"i64.extend_s/i32\", // 0xac",
          "178:  \"i64.extend_u/i32\", // 0xad",
          "179:  \"i64.trunc_s/f32\", // 0xae",
          "180:  \"i64.trunc_u/f32\", // 0xaf",
          "181:  \"i64.trunc_s/f64\", // 0xb0",
          "182:  \"i64.trunc_u/f64\", // 0xb1",
          "183:  \"f32.convert_s/i32\",// 0xb2",
          "184:  \"f32.convert_u/i32\",// 0xb3",
          "185:  \"f32.convert_s/i64\",// 0xb4",
          "186:  \"f32.convert_u/i64\",// 0xb5",
          "187:  \"f32.demote/f64\", // 0xb6",
          "188:  \"f64.convert_s/i32\",// 0xb7",
          "189:  \"f64.convert_u/i32\",// 0xb8",
          "190:  \"f64.convert_s/i64\",// 0xb9",
          "191:  \"f64.convert_u/i64\",// 0xba",
          "192:  \"f64.promote/f32\", // 0xbb",
          "194:  \"i32.reinterpret/f32\", // 0xbc",
          "195:  \"i64.reinterpret/f64\", // 0xbd",
          "196:  \"f32.reinterpret/i32\", // 0xbe",
          "197:  \"f64/reinterpret/i64\", // 0xbf",
          "199: };",
          "202:  int rep = 1;",
          "204:  if (len < 1) goto err;",
          "206:  ut8 o = buf[0];",
          "208:  switch (o) {",
          "209:  case 0x00:",
          "210:  case 0x01:",
          "211:  case 0x05:",
          "212:  case 0x0b:",
          "213:  case 0x0f:",
          "214:  case 0x1a:",
          "215:  case 0x1b:",
          "216:  case 0x45:",
          "217:  case 0x46:",
          "218:  case 0x47:",
          "219:  case 0x48:",
          "220:  case 0x49:",
          "221:  case 0x4a:",
          "222:  case 0x4b:",
          "223:  case 0x4c:",
          "224:  case 0x4d:",
          "225:  case 0x4e:",
          "226:  case 0x4f:",
          "227:  case 0x50:",
          "228:  case 0x51:",
          "229:  case 0x52:",
          "230:  case 0x53:",
          "231:  case 0x54:",
          "232:  case 0x55:",
          "233:  case 0x56:",
          "234:  case 0x57:",
          "235:  case 0x58:",
          "236:  case 0x59:",
          "237:  case 0x5a:",
          "238:  case 0x5b:",
          "239:  case 0x5c:",
          "240:  case 0x5d:",
          "241:  case 0x5e:",
          "242:  case 0x5f:",
          "243:  case 0x60:",
          "244:  case 0x61:",
          "245:  case 0x62:",
          "246:  case 0x63:",
          "247:  case 0x64:",
          "248:  case 0x65:",
          "249:  case 0x66:",
          "250:  case 0x67:",
          "251:  case 0x68:",
          "252:  case 0x69:",
          "253:  case 0x6a:",
          "254:  case 0x6b:",
          "255:  case 0x6c:",
          "256:  case 0x6d:",
          "257:  case 0x6e:",
          "258:  case 0x6f:",
          "259:  case 0x70:",
          "260:  case 0x71:",
          "261:  case 0x72:",
          "262:  case 0x73:",
          "263:  case 0x74:",
          "264:  case 0x75:",
          "265:  case 0x76:",
          "266:  case 0x77:",
          "267:  case 0x78:",
          "268:  case 0x79:",
          "269:  case 0x7a:",
          "270:  case 0x7b:",
          "271:  case 0x7c:",
          "272:  case 0x7d:",
          "273:  case 0x7e:",
          "274:  case 0x7f:",
          "275:  case 0x80:",
          "276:  case 0x81:",
          "277:  case 0x82:",
          "278:  case 0x83:",
          "279:  case 0x84:",
          "280:  case 0x85:",
          "281:  case 0x86:",
          "282:  case 0x87:",
          "283:  case 0x88:",
          "284:  case 0x89:",
          "285:  case 0x8a:",
          "286:  case 0x8b:",
          "287:  case 0x8c:",
          "288:  case 0x8d:",
          "289:  case 0x8e:",
          "290:  case 0x8f:",
          "291:  case 0x90:",
          "292:  case 0x91:",
          "293:  case 0x92:",
          "294:  case 0x93:",
          "295:  case 0x94:",
          "296:  case 0x95:",
          "297:  case 0x96:",
          "298:  case 0x97:",
          "299:  case 0x98:",
          "300:  case 0x99:",
          "301:  case 0x9a:",
          "302:  case 0x9b:",
          "303:  case 0x9c:",
          "304:  case 0x9d:",
          "305:  case 0x9e:",
          "306:  case 0x9f:",
          "307:  case 0xa0:",
          "308:  case 0xa1:",
          "309:  case 0xa2:",
          "310:  case 0xa3:",
          "311:  case 0xa4:",
          "312:  case 0xa5:",
          "313:  case 0xa6:",
          "314:  case 0xa7:",
          "315:  case 0xa8:",
          "316:  case 0xa9:",
          "317:  case 0xaa:",
          "318:  case 0xab:",
          "319:  case 0xac:",
          "320:  case 0xad:",
          "321:  case 0xae:",
          "322:  case 0xaf:",
          "323:  case 0xb0:",
          "324:  case 0xb1:",
          "325:  case 0xb2:",
          "326:  case 0xb3:",
          "327:  case 0xb4:",
          "328:  case 0xb5:",
          "329:  case 0xb6:",
          "330:  case 0xb7:",
          "331:  case 0xb8:",
          "332:  case 0xb9:",
          "333:  case 0xba:",
          "334:  case 0xbb:",
          "335:  case 0xbc:",
          "336:  case 0xbd:",
          "337:  case 0xbe:",
          "338:  case 0xbf:",
          "339:   snprintf (op->buf_asm, R_ASM_BUFSIZE, \"%s\", opcodes[o]);",
          "340:   break;",
          "341:  case 0x02:",
          "342:  case 0x03:",
          "343:  case 0x04:",
          "344:   {",
          "345:    if (len >= 2) {",
          "346:     if (buf[1] == 0x40) {",
          "347:      snprintf (op->buf_asm, R_ASM_BUFSIZE, \"%s\", opcodes[o]);",
          "348:     } else {",
          "350:      snprintf (op->buf_asm, R_ASM_BUFSIZE, \"%s ...\", opcodes[o]);",
          "351:     }",
          "352:     rep = 2;",
          "353:    }",
          "354:   }",
          "355:   break;",
          "356:  case 0x0c:",
          "357:  case 0x0d:",
          "358:  case 0x10:",
          "359:   {",
          "360:    ut32 val = 0;",
          "361:    size_t n = read_u32_leb128 (buf + 1, buf + len, &val);",
          "362:    if (n > 0 && n < len) {",
          "363:     snprintf (op->buf_asm, R_ASM_BUFSIZE, \"%s %d\", opcodes[o], val);",
          "364:     rep += n;",
          "365:    }",
          "366:   }",
          "367:   break;",
          "368:  case 0x0e:",
          "369:   {",
          "371:    ut32 count = 0, table = 0, def = 0;",
          "372:    size_t n = read_u32_leb128 (buf + 1, buf + len, &count);",
          "373:    if (n > 0 && n < len) {",
          "374:     rep += n;",
          "375:     int i;",
          "376:     for (i = 0; i < count; i++) {",
          "377:       n = read_u32_leb128 (buf + n + 1, buf + len, &table);",
          "378:       if (!n || len < rep + n) break;",
          "379:       rep += n;",
          "380:     }",
          "381:     n = read_u32_leb128 (buf + n + 1, buf + len, &count);",
          "382:     if (n > 0 && n + rep < len) {",
          "383:      snprintf (op->buf_asm, R_ASM_BUFSIZE, \"%s %d ... %d\", opcodes[o], count, def);",
          "384:      rep += n;",
          "385:     }",
          "386:    }",
          "387:   }",
          "388:   break;",
          "389:  case 0x11:",
          "390:   {",
          "391:    ut32 val = 0, reserved = 0;",
          "392:    size_t n = read_u32_leb128 (buf + 1, buf + len, &val);",
          "393:    if (n > 0 && n < len)  {",
          "394:     rep += n;",
          "395:     n = read_u32_leb128 (buf + n + 1, buf + len, &reserved);",
          "396:     if (n == 1 || n + rep < len)  {",
          "397:      reserved &= 0x1;",
          "398:      snprintf (op->buf_asm, R_ASM_BUFSIZE, \"call_indirect %d %d\", val, reserved);",
          "399:     }",
          "400:    }",
          "401:   }",
          "402:   break;",
          "403:  case 0x20:",
          "404:  case 0x21:",
          "405:  case 0x22:",
          "406:  case 0x23:",
          "407:  case 0x24:",
          "408:   {",
          "409:    ut32 val = 0;",
          "410:    size_t n = read_u32_leb128 (buf + 1, buf + len, &val);",
          "411:    if (n > 0 && n < len) {",
          "412:     snprintf (op->buf_asm, R_ASM_BUFSIZE, \"%s %d\", opcodes[o], val);",
          "413:     rep += n;",
          "414:    }",
          "415:   }",
          "416:   break;",
          "417:  case 0x28:",
          "418:  case 0x29:",
          "419:  case 0x2a:",
          "420:  case 0x2b:",
          "421:  case 0x2c:",
          "422:  case 0x2d:",
          "423:  case 0x2e:",
          "424:  case 0x2f:",
          "425:  case 0x30:",
          "426:  case 0x31:",
          "427:  case 0x32:",
          "428:  case 0x33:",
          "429:  case 0x34:",
          "430:  case 0x35:",
          "431:  case 0x36:",
          "432:  case 0x37:",
          "433:  case 0x38:",
          "434:  case 0x39:",
          "435:  case 0x3a:",
          "436:  case 0x3b:",
          "437:  case 0x3c:",
          "438:  case 0x3d:",
          "439:  case 0x3e:",
          "440:   {",
          "441:    ut32 flag = 0, offset = 0;",
          "442:    size_t n = read_u32_leb128 (buf + 1, buf + len, &flag);",
          "443:    if (n > 0 && n < len) {",
          "444:     rep += n;",
          "445:     size_t m = read_u32_leb128 (buf + 1 + n, buf + len, &offset);",
          "446:     if (m > 0 && rep + m < len) {",
          "447:      snprintf (op->buf_asm, R_ASM_BUFSIZE, \"%s %d %d\", opcodes[o], flag, offset);",
          "448:      rep += m;",
          "449:     }",
          "450:    }",
          "451:   }",
          "452:   break;",
          "453:  case 0x3f:",
          "454:  case 0x40:",
          "455:   {",
          "456:    ut32 reserved = 0;",
          "457:    size_t n = read_u32_leb128 (buf + 1, buf + len, &reserved);",
          "458:    if (n == 1 && n < len) {",
          "459:     reserved &= 0x1;",
          "460:     snprintf (op->buf_asm, R_ASM_BUFSIZE, \"%s %d\", opcodes[o], reserved);",
          "461:     rep += n;",
          "462:    }",
          "463:   }",
          "464:   break;",
          "466:  case 0x41:",
          "467:   {",
          "468:    st32 val = 0;",
          "469:    size_t n = read_i32_leb128 (buf + 1, buf + len, &val);",
          "470:    if (n > 0 && n < len) {",
          "471:     snprintf (op->buf_asm, R_ASM_BUFSIZE, \"%s %\" PFMT32d, opcodes[o], val);",
          "472:     rep += n;",
          "473:    }",
          "474:   }",
          "475:   break;",
          "476:  case 0x42:",
          "477:   {",
          "478:    st64 val = 0;",
          "479:    size_t n = read_i64_leb128 (buf + 1, buf + len, &val);",
          "480:    if (n > 0 && n < len) {",
          "481:     snprintf (op->buf_asm, R_ASM_BUFSIZE, \"%s %\" PFMT64d, opcodes[o], val);",
          "482:     rep += n;",
          "483:    }",
          "484:   }",
          "485:   break;",
          "486:  case 0x43:",
          "487:   {",
          "488:    ut32 val = 0;",
          "489:    size_t n = read_u32_leb128 (buf + 1, buf + len, &val);",
          "490:    if (n > 0 && n < len) {",
          "491:     long double d =  (long double)val;",
          "492:     snprintf (op->buf_asm, R_ASM_BUFSIZE, \"%s %\" LDBLFMT, opcodes[o], d);",
          "493:     rep += n;",
          "494:    }",
          "495:   }",
          "496:   break;",
          "497:  case 0x44:",
          "498:   {",
          "499:    ut64 val = 0;",
          "500:    size_t n = read_u64_leb128 (buf + 1, buf + len, &val);",
          "501:    if (n > 0 && n < len) {",
          "502:     long double d =  (long double)val;",
          "503:     snprintf (op->buf_asm, R_ASM_BUFSIZE, \"%s %\" LDBLFMT, opcodes[o], d);",
          "504:     rep += n;",
          "505:    }",
          "506:   }",
          "507:   break;",
          "508:  default:",
          "509:   break;",
          "511:  }",
          "513: err:",
          "514:  op->size = rep;",
          "515:  return rep;",
          "520:  .author = \"pancake\",",
          "527:  .disassemble = &disassemble",
          "",
          "[Added Lines]",
          "11: #include \"../arch/wasm/wasm.c\"",
          "14:  WasmOp wop = {0};",
          "15:  int ret = wasm_dis (&wop, buf, len);",
          "16:  strncpy (op->buf_asm, wop.txt, sizeof (op->buf_asm));",
          "17:  op->buf_asm[sizeof (op->buf_asm) - 1] = 0;",
          "18:  op->size = ret;",
          "19:  return op->size;",
          "20: }",
          "22: static int assemble(RAsm *a, RAsmOp *op, const char *buf) {",
          "23:  op->size = wasm_asm (buf, op->buf, sizeof (op->buf));",
          "24:  return op->size;",
          "29:  .author = \"cgvwzq\",",
          "36:  .disassemble = &disassemble,",
          "37:  .assemble = &assemble",
          "",
          "---------------"
        ],
        "libr/bin/format/wasm/wasm.c||libr/bin/format/wasm/wasm.c": [
          "File: libr/bin/format/wasm/wasm.c -> libr/bin/format/wasm/wasm.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "186:  return ret;",
          "187: }",
          "191:  switch (type) {",
          "192:  case R_BIN_WASM_VALUETYPE_i32:",
          "193:   return r_str_const (\"i32\");",
          "",
          "[Removed Lines]",
          "189: #if 0",
          "190: static const char *r_bin_wasm_valuetype_to_string (r_bin_wasm_value_type_t type) {",
          "",
          "[Added Lines]",
          "189: # if 0",
          "190: const char *r_bin_wasm_valuetype_to_string (r_bin_wasm_value_type_t type) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "197:   return r_str_const (\"f32\");",
          "198:  case R_BIN_WASM_VALUETYPE_f64:",
          "199:   return r_str_const (\"f64\");",
          "200:  default:",
          "202:  }",
          "203: }",
          "",
          "[Removed Lines]",
          "201:   return r_str_const (\"?\");",
          "",
          "[Added Lines]",
          "200:  case R_BIN_WASM_VALUETYPE_ANYFUNC:",
          "201:   return r_str_const (\"ANYFUNC\");",
          "202:  case R_BIN_WASM_VALUETYPE_FUNC:",
          "203:   return r_str_const (\"FUNC\");",
          "205:   return r_str_const (\"<?>\");",
          "",
          "---------------"
        ],
        "libr/bin/format/wasm/wasm.h||libr/bin/format/wasm/wasm.h": [
          "File: libr/bin/format/wasm/wasm.h -> libr/bin/format/wasm/wasm.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "30: #define R_BIN_WASM_SECTION_DATA 0xb",
          "32: typedef enum {",
          "37: } r_bin_wasm_value_type_t;",
          "39: typedef enum {",
          "",
          "[Removed Lines]",
          "33:  R_BIN_WASM_VALUETYPE_i32 = 0x7f,",
          "34:  R_BIN_WASM_VALUETYPE_i64 = 0x7e,",
          "35:  R_BIN_WASM_VALUETYPE_f32 = 0x7d,",
          "36:  R_BIN_WASM_VALUETYPE_f64 = 0x7c,",
          "",
          "[Added Lines]",
          "33:  R_BIN_WASM_VALUETYPE_i32 = 0x1,",
          "34:  R_BIN_WASM_VALUETYPE_i64 = 0x2,",
          "35:  R_BIN_WASM_VALUETYPE_f32 = 0x3,",
          "36:  R_BIN_WASM_VALUETYPE_f64 = 0x4,",
          "37:  R_BIN_WASM_VALUETYPE_ANYFUNC = 0x10,",
          "38:  R_BIN_WASM_VALUETYPE_FUNC = 0x20,",
          "39:  R_BIN_WASM_VALUETYPE_EMPTY = 0x40,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "46: typedef enum {",
          "47:  R_BIN_WASM_NAMETYPE_Function = 0x1,",
          "49: } r_bin_wasm_name_type_t;",
          "51: struct r_bin_wasm_init_expr_t {",
          "",
          "[Removed Lines]",
          "48:  R_BIN_WASM_NAMETYPELocal = 0x2,",
          "",
          "[Added Lines]",
          "51:  R_BIN_WASM_NAMETYPE_Local = 0x2,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "213: RList *r_bin_wasm_get_codes (RBinWasmObj *bin);",
          "214: RList *r_bin_wasm_get_datas (RBinWasmObj *bin);",
          "215: ut32 r_bin_wasm_get_entrypoint (RBinWasmObj *bin);",
          "217: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "219: const char *r_bin_wasm_valuetype_to_string (r_bin_wasm_value_type_t type);",
          "",
          "---------------"
        ],
        "libr/bin/p/bin_wasm.c||libr/bin/p/bin_wasm.c": [
          "File: libr/bin/p/bin_wasm.c -> libr/bin/p/bin_wasm.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "17:  if (!buf || !sz || sz == UT64_MAX) {",
          "18:   return NULL;",
          "19:  }",
          "21:   return NULL;",
          "22:  }",
          "23:  return r_bin_wasm_init (arch);",
          "",
          "[Removed Lines]",
          "20:  if (!check_bytes(buf, sz)) {",
          "",
          "[Added Lines]",
          "20:  if (!check_bytes (buf, sz)) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "145:   case 3: ptr->type = r_str_const (\"GLOBAL\"); break;",
          "146:   }",
          "147:   ptr->size = 0;",
          "150:   ptr->ordinal = i;",
          "151:   i += 1;",
          "152:   r_list_append (ret, ptr);",
          "",
          "[Removed Lines]",
          "148:   ptr->vaddr = 0;",
          "149:   ptr->paddr = 0;",
          "",
          "[Added Lines]",
          "148:   ptr->vaddr = -1;",
          "149:   ptr->paddr = -1;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "167:   ptr->vaddr = (ut64)func->code;",
          "168:   ptr->paddr = (ut64)func->code;",
          "169:   ptr->ordinal = i;",
          "171:   r_list_append (ret, ptr);",
          "172:  }",
          "",
          "[Removed Lines]",
          "170:   i += 1;",
          "",
          "[Added Lines]",
          "170:   i++;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "251:  ret->subsystem = strdup (\"wasm\");",
          "252:  ret->type = strdup (\"EXEC\");",
          "253:  ret->bits = 32;",
          "255:  ret->big_endian = false;",
          "256:  ret->dbg_info = 0;",
          "258:  return ret;",
          "259: }",
          "",
          "[Removed Lines]",
          "254:  ret->has_va = true;",
          "257:  ret->dbg_info = 0;",
          "",
          "[Added Lines]",
          "254:  ret->has_va = 0;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "e5b9afffb2c4f06f61eb664060db909e8bf78bdc",
      "candidate_info": {
        "commit_hash": "e5b9afffb2c4f06f61eb664060db909e8bf78bdc",
        "repo": "radare/radare2",
        "commit_url": "https://github.com/radare/radare2/commit/e5b9afffb2c4f06f61eb664060db909e8bf78bdc",
        "files": [
          "libr/anal/p/anal_wasm.c",
          "libr/asm/arch/wasm/wasm.c",
          "libr/asm/arch/wasm/wasm.h"
        ],
        "message": "Fix 11141 - replaced R_ASM_BUFSIZE with RStrBuf*",
        "before_after_code_files": [
          "libr/anal/p/anal_wasm.c||libr/anal/p/anal_wasm.c",
          "libr/asm/arch/wasm/wasm.c||libr/asm/arch/wasm/wasm.c",
          "libr/asm/arch/wasm/wasm.h||libr/asm/arch/wasm/wasm.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libr/asm/arch/wasm/wasm.c||libr/asm/arch/wasm/wasm.c"
          ],
          "candidate": [
            "libr/asm/arch/wasm/wasm.c||libr/asm/arch/wasm/wasm.c"
          ]
        }
      },
      "candidate_diff": {
        "libr/anal/p/anal_wasm.c||libr/anal/p/anal_wasm.c": [
          "File: libr/anal/p/anal_wasm.c -> libr/anal/p/anal_wasm.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "64:    break;",
          "65:   case WASM_OP_ELSE:",
          "66:    if (!count && !is_loop) {",
          "67:     return offset + ret;",
          "68:    }",
          "69:    break;",
          "70:   case WASM_OP_END:",
          "71:    if (!count) {",
          "72:     return offset;",
          "73:    } else {",
          "74:     count--;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "67:     free (wop.txt);",
          "73:     free (wop.txt);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "80:   offset += ret;",
          "81:   data += ret;",
          "82:   len -= ret;",
          "83:  }",
          "84:  return UT64_MAX;",
          "85: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "85:   free (wop.txt);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "122:  op->type = R_ANAL_OP_TYPE_UNK;",
          "123:  op->id = wop.op;",
          "126:   op->type = R_ANAL_OP_TYPE_ILL;",
          "127:   wasm_stack_ptr = 0;",
          "128:   return -1;",
          "129:  }",
          "130:  if (wasm_stack_ptr >= WASM_STACK_SIZE) {",
          "131:   wasm_stack_ptr = 0;",
          "132:   op->type = R_ANAL_OP_TYPE_NULL;",
          "133:   return -1;",
          "134:  }",
          "135:  switch (wop.op) {",
          "",
          "[Removed Lines]",
          "125:  if (!strncmp (wop.txt, \"invalid\", 7)) {",
          "",
          "[Added Lines]",
          "128:  if (!wop.txt || !strncmp (wop.txt, \"invalid\", 7)) {",
          "131:   free (wop.txt);",
          "137:   free (wop.txt);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "316:  }",
          "317:  op_old = wop.op;",
          "318:  addr_old = addr;",
          "319:  return op->size;",
          "320: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "324:  free (wop.txt);",
          "",
          "---------------"
        ],
        "libr/asm/arch/wasm/wasm.c||libr/asm/arch/wasm/wasm.c": [
          "File: libr/asm/arch/wasm/wasm.c -> libr/asm/arch/wasm/wasm.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "184:  [WASM_OP_F64REINTERPRETI64] = { \"f64/reinterpret/i64\", 1, 1 }",
          "185: };",
          "187: R_IPI int wasm_asm(const char *str, unsigned char *buf, int buf_len) {",
          "189:  int i = 0, len = -1;",
          "192:   tmp[i] = str[i];",
          "193:   i++;",
          "194:  }",
          "",
          "[Removed Lines]",
          "190:  char tmp[R_ASM_BUFSIZE];",
          "191:  while (str[i] != ' ' && i < buf_len) {",
          "",
          "[Added Lines]",
          "191:  char tmp[256];",
          "192:  while (str[i] && str[i] != ' ' && i < sizeof (tmp)) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "205:  return len;",
          "206: }",
          "208: R_IPI int wasm_dis(WasmOp *op, const unsigned char *buf, int buf_len) {",
          "209:  op->len = 1;",
          "210:  op->op = buf[0];",
          "211:  if (op->op > 0xbf) {",
          "213:  }",
          "215:  WasmOpDef *opdef = &opcodes[op->op];",
          "",
          "[Removed Lines]",
          "212:   return 1;",
          "",
          "[Added Lines]",
          "211:  RStrBuf *sb = r_strbuf_new (\"\");",
          "215:   goto err;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "345:  case WASM_OP_F64REINTERPRETI64:",
          "346:  case WASM_OP_END:",
          "347:   {",
          "349:   }",
          "350:   break;",
          "351:  case WASM_OP_BLOCK:",
          "",
          "[Removed Lines]",
          "348:    snprintf (op->txt, R_ASM_BUFSIZE, \"%s\", opdef->txt);",
          "",
          "[Added Lines]",
          "351:    r_strbuf_set (sb, opdef->txt);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "359:    }",
          "360:    switch (0x80 - val) {",
          "361:    case R_BIN_WASM_VALUETYPE_EMPTY:",
          "363:     break;",
          "364:    case R_BIN_WASM_VALUETYPE_i32:",
          "366:     break;",
          "367:    case R_BIN_WASM_VALUETYPE_i64:",
          "369:     break;",
          "370:    case R_BIN_WASM_VALUETYPE_f32:",
          "372:     break;",
          "373:    case R_BIN_WASM_VALUETYPE_f64:",
          "375:     break;",
          "376:    default:",
          "378:     break;",
          "379:    }",
          "380:    op->len += n;",
          "",
          "[Removed Lines]",
          "362:     snprintf (op->txt, R_ASM_BUFSIZE, \"%s\", opdef->txt);",
          "365:     snprintf (op->txt, R_ASM_BUFSIZE, \"%s (result i32)\", opdef->txt);",
          "368:     snprintf (op->txt, R_ASM_BUFSIZE, \"%s (result i64)\", opdef->txt);",
          "371:     snprintf (op->txt, R_ASM_BUFSIZE, \"%s (result f32)\", opdef->txt);",
          "374:     snprintf (op->txt, R_ASM_BUFSIZE, \"%s (result f64)\", opdef->txt);",
          "377:     snprintf (op->txt, R_ASM_BUFSIZE, \"%s (result ?)\", opdef->txt);",
          "",
          "[Added Lines]",
          "365:     r_strbuf_set (sb, opdef->txt);",
          "368:     r_strbuf_setf (sb, \"%s (result i32)\", opdef->txt);",
          "371:     r_strbuf_setf (sb, \"%s (result i64)\", opdef->txt);",
          "374:     r_strbuf_setf (sb, \"%s (result f32)\", opdef->txt);",
          "377:     r_strbuf_setf (sb, \"%s (result f64)\", opdef->txt);",
          "380:     r_strbuf_setf (sb, \"%s (result ?)\", opdef->txt);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "389:    if (!(n > 0 && n < buf_len)) {",
          "390:     goto err;",
          "391:    }",
          "393:    op->len += n;",
          "394:   }",
          "395:   break;",
          "",
          "[Removed Lines]",
          "392:    snprintf (op->txt, R_ASM_BUFSIZE, \"%s %d\", opdef->txt, val);",
          "",
          "[Added Lines]",
          "395:    r_strbuf_setf (sb, \"%s %d\", opdef->txt, val);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "420:     goto beach;",
          "421:    }",
          "422:    op->len += n;",
          "433:    }",
          "435:    free (table);",
          "436:    break;",
          "437:   beach:",
          "",
          "[Removed Lines]",
          "423:    snprintf (op->txt, R_ASM_BUFSIZE, \"%s %d \", opdef->txt, count);",
          "424:    char *txt = op->txt;",
          "425:    int txtLen = strlen (op->txt);",
          "426:    int txtLeft = R_ASM_BUFSIZE - txtLen;",
          "427:    txt += txtLen;",
          "428:    for (i = 0; i < count && txtLen + 10 < R_ASM_BUFSIZE; i++) {",
          "429:     snprintf (txt, txtLeft, \"%d \", table[i]);",
          "430:     txtLen = strlen (txt);",
          "431:     txt += txtLen;",
          "432:     txtLeft -= txtLen;",
          "434:    snprintf (txt, txtLeft - 1, \"%d\", def);",
          "",
          "[Added Lines]",
          "426:    r_strbuf_setf (sb, \"%s %d \", opdef->txt, count);",
          "427:    for (i = 0; i < count; i++) {",
          "428:     r_strbuf_appendf (sb, \"%d \", table[i]);",
          "430:    r_strbuf_appendf (sb, \"%d\", def);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "452:     goto err;",
          "453:    }",
          "454:    reserved &= 0x1;",
          "456:    op->len += n;",
          "457:   }",
          "458:   break;",
          "",
          "[Removed Lines]",
          "455:    snprintf (op->txt, R_ASM_BUFSIZE, \"%s %d %d\", opdef->txt, val, reserved);",
          "",
          "[Added Lines]",
          "451:    r_strbuf_setf (sb, \"%s %d %d\", opdef->txt, val, reserved);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "467:    if (!(n > 0 && n < buf_len)) {",
          "468:     goto err;",
          "469:    }",
          "471:    op->len += n;",
          "472:   }",
          "473:   break;",
          "",
          "[Removed Lines]",
          "470:    snprintf (op->txt, R_ASM_BUFSIZE, \"%s %d\", opdef->txt, val);",
          "",
          "[Added Lines]",
          "466:    r_strbuf_setf (sb, \"%s %d\", opdef->txt, val);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "505:    if (!(n > 0 && op->len + n <= buf_len)) {",
          "506:     goto err;",
          "507:    }",
          "509:    op->len += n;",
          "510:   }",
          "511:   break;",
          "",
          "[Removed Lines]",
          "508:    snprintf (op->txt, R_ASM_BUFSIZE, \"%s %d %d\", opdef->txt, flag, offset);",
          "",
          "[Added Lines]",
          "504:    r_strbuf_setf (sb, \"%s %d %d\", opdef->txt, flag, offset);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "518:     goto err;",
          "519:    }",
          "520:    reserved &= 0x1;",
          "522:    op->len += n;",
          "523:   }",
          "524:   break;",
          "",
          "[Removed Lines]",
          "521:    snprintf (op->txt, R_ASM_BUFSIZE, \"%s %d\", opdef->txt, reserved);",
          "",
          "[Added Lines]",
          "517:    r_strbuf_setf (sb, \"%s %d\", opdef->txt, reserved);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "530:    if (!(n > 0 && n < buf_len)) {",
          "531:     goto err;",
          "532:    }",
          "534:    op->len += n;",
          "535:   }",
          "536:   break;",
          "",
          "[Removed Lines]",
          "533:    snprintf (op->txt, R_ASM_BUFSIZE, \"%s %\" PFMT32d, opdef->txt, val);",
          "",
          "[Added Lines]",
          "529:    r_strbuf_setf (sb, \"%s %\" PFMT32d, opdef->txt, val);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "541:    if (!(n > 0 && n < buf_len)) {",
          "542:     goto err;",
          "543:    }",
          "545:    op->len += n;",
          "546:   }",
          "547:   break;",
          "",
          "[Removed Lines]",
          "544:    snprintf (op->txt, R_ASM_BUFSIZE, \"%s %\" PFMT64d, opdef->txt, val);",
          "",
          "[Added Lines]",
          "540:    r_strbuf_setf (sb, \"%s %\" PFMT64d, opdef->txt, val);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "553:     goto err;",
          "554:    }",
          "555:    long double d =  (long double)val;",
          "557:    op->len += n;",
          "558:   }",
          "559:   break;",
          "",
          "[Removed Lines]",
          "556:    snprintf (op->txt, R_ASM_BUFSIZE, \"%s %\" LDBLFMT, opdef->txt, d);",
          "",
          "[Added Lines]",
          "552:    r_strbuf_setf (sb, \"%s %\" LDBLFMT, opdef->txt, d);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "564:    if (!(n > 0 && n < buf_len)) {",
          "565:     goto err;",
          "566:    }",
          "569:    op->len += n;",
          "570:   }",
          "571:   break;",
          "",
          "[Removed Lines]",
          "567:    long double d =  (long double)val;",
          "568:    snprintf (op->txt, R_ASM_BUFSIZE, \"%s %\" LDBLFMT, opdef->txt, d);",
          "",
          "[Added Lines]",
          "563:    long double d =  (long double) val;",
          "564:    r_strbuf_setf (sb, \"%s %\" LDBLFMT, opdef->txt, d);",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "573:   goto err;",
          "574:  }",
          "576:  return op->len;",
          "578: err:",
          "579:  op->len = 1;",
          "581:  return op->len;",
          "582: }",
          "",
          "[Removed Lines]",
          "580:  snprintf (op->txt, R_ASM_BUFSIZE, \"invalid\");",
          "",
          "[Added Lines]",
          "572:  op->txt = r_strbuf_drain (sb);",
          "577:  r_strbuf_set (sb, \"invalid\");",
          "578:  op->txt = r_strbuf_drain (sb);",
          "",
          "---------------"
        ],
        "libr/asm/arch/wasm/wasm.h||libr/asm/arch/wasm/wasm.h": [
          "File: libr/asm/arch/wasm/wasm.h -> libr/asm/arch/wasm/wasm.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: typedef enum {",
          "3:  WASM_OP_TRAP = 0x00,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: #ifndef WASM_ASM_H",
          "2: #define WASM_ASM_H",
          "3: #include <r_util.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "198: typedef struct {",
          "199:  WasmOpCodes op;",
          "200:  int len;",
          "202: } WasmOp;",
          "204: typedef struct {",
          "",
          "[Removed Lines]",
          "201:  char txt[R_ASM_BUFSIZE];",
          "",
          "[Added Lines]",
          "205:  char *txt;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "210: R_IPI int wasm_asm(const char *str, unsigned char *buf, int buf_len);",
          "211: R_IPI int wasm_dis(WasmOp *op, const unsigned char *buf, int buf_len);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "217: #endif",
          "",
          "---------------"
        ]
      }
    }
  ]
}
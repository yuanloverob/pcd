{
  "cve_id": "CVE-2022-0156",
  "cve_desc": "vim is vulnerable to Use After Free",
  "repo": "vim/vim",
  "patch_hash": "9f1a39a5d1cd7989ada2d1cb32f97d84360e050f",
  "patch_info": {
    "commit_hash": "9f1a39a5d1cd7989ada2d1cb32f97d84360e050f",
    "repo": "vim/vim",
    "commit_url": "https://github.com/vim/vim/commit/9f1a39a5d1cd7989ada2d1cb32f97d84360e050f",
    "files": [
      "src/alloc.c",
      "src/message.c",
      "src/proto/alloc.pro",
      "src/proto/userfunc.pro",
      "src/testdir/test_vim9_func.vim",
      "src/usercmd.c",
      "src/userfunc.c",
      "src/version.c",
      "src/vim9compile.c",
      "src/viminfo.c"
    ],
    "message": "patch 8.2.4040: keeping track of allocated lines is too complicated\n\nProblem:    Keeping track of allocated lines in user functions is too\n            complicated.\nSolution:   Instead of freeing individual lines keep them all until the end.",
    "before_after_code_files": [
      "src/alloc.c||src/alloc.c",
      "src/message.c||src/message.c",
      "src/proto/alloc.pro||src/proto/alloc.pro",
      "src/proto/userfunc.pro||src/proto/userfunc.pro",
      "src/testdir/test_vim9_func.vim||src/testdir/test_vim9_func.vim",
      "src/usercmd.c||src/usercmd.c",
      "src/userfunc.c||src/userfunc.c",
      "src/version.c||src/version.c",
      "src/vim9compile.c||src/vim9compile.c",
      "src/viminfo.c||src/viminfo.c"
    ]
  },
  "patch_diff": {
    "src/alloc.c||src/alloc.c": [
      "File: src/alloc.c -> src/alloc.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "702: }",
      "704:     void",
      "706: {",
      "707:     ga_init(gap);",
      "708:     gap->ga_itemsize = itemsize;",
      "",
      "[Removed Lines]",
      "705: ga_init2(garray_T *gap, int itemsize, int growsize)",
      "",
      "[Added Lines]",
      "705: ga_init2(garray_T *gap, size_t itemsize, int growsize)",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "791:     int",
      "793: {",
      "794:     char_u *cp = vim_strsave(p);",
      "",
      "[Removed Lines]",
      "792: ga_add_string(garray_T *gap, char_u *p)",
      "",
      "[Added Lines]",
      "792: ga_copy_string(garray_T *gap, char_u *p)",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "805:     return OK;",
      "806: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "812:     int",
      "813: ga_add_string(garray_T *gap, char_u *p)",
      "814: {",
      "815:     if (ga_grow(gap, 1) == FAIL)",
      "816:  return FAIL;",
      "817:     ((char_u **)(gap->ga_data))[gap->ga_len++] = p;",
      "818:     return OK;",
      "819: }",
      "",
      "---------------"
    ],
    "src/message.c||src/message.c": [
      "File: src/message.c -> src/message.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "587:     if (STRCMP(\"RESET\", error) == 0)",
      "588:  ga_clear_strings(&ignore_error_list);",
      "589:     else",
      "591: }",
      "593:     static int",
      "",
      "[Removed Lines]",
      "590:  ga_add_string(&ignore_error_list, error);",
      "",
      "[Added Lines]",
      "590:  ga_copy_string(&ignore_error_list, error);",
      "",
      "---------------"
    ],
    "src/proto/alloc.pro||src/proto/alloc.pro": [
      "File: src/proto/alloc.pro -> src/proto/alloc.pro",
      "--- Hunk 1 ---",
      "[Context before]",
      "17: void ga_clear_strings(garray_T *gap);",
      "18: int ga_copy_strings(garray_T *from, garray_T *to);",
      "19: void ga_init(garray_T *gap);",
      "21: int ga_grow(garray_T *gap, int n);",
      "22: int ga_grow_inner(garray_T *gap, int n);",
      "23: char_u *ga_concat_strings(garray_T *gap, char *sep);",
      "24: int ga_add_string(garray_T *gap, char_u *p);",
      "25: void ga_concat(garray_T *gap, char_u *s);",
      "26: void ga_concat_len(garray_T *gap, char_u *s, size_t len);",
      "",
      "[Removed Lines]",
      "20: void ga_init2(garray_T *gap, int itemsize, int growsize);",
      "",
      "[Added Lines]",
      "20: void ga_init2(garray_T *gap, size_t itemsize, int growsize);",
      "24: int ga_copy_string(garray_T *gap, char_u *p);",
      "",
      "---------------"
    ],
    "src/proto/userfunc.pro||src/proto/userfunc.pro": [
      "File: src/proto/userfunc.pro -> src/proto/userfunc.pro",
      "--- Hunk 1 ---",
      "[Context before]",
      "38: char_u *get_scriptlocal_funcname(char_u *funcname);",
      "39: char_u *save_function_name(char_u **name, int *is_global, int skip, int flags, funcdict_T *fudi);",
      "40: void list_functions(regmatch_T *regmatch);",
      "42: void ex_function(exarg_T *eap);",
      "43: void ex_defcompile(exarg_T *eap);",
      "44: int eval_fname_script(char_u *p);",
      "",
      "[Removed Lines]",
      "41: ufunc_T *define_function(exarg_T *eap, char_u *name_arg, char_u **line_to_free);",
      "",
      "[Added Lines]",
      "41: ufunc_T *define_function(exarg_T *eap, char_u *name_arg, garray_T *lines_to_free);",
      "",
      "---------------"
    ],
    "src/testdir/test_vim9_func.vim||src/testdir/test_vim9_func.vim": [
      "File: src/testdir/test_vim9_func.vim -> src/testdir/test_vim9_func.vim",
      "--- Hunk 1 ---",
      "[Context before]",
      "1757:   CheckScriptFailure(lines, 'E1173: Text found after endfunction: BBBB')",
      "1758: enddef",
      "1760: def Test_return_type_wrong()",
      "1761:   CheckScriptFailure([",
      "1762:         'def Func(): number',",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1760: def Test_error_in_function_args()",
      "1761:   var lines =<< trim END",
      "1762:       def FirstFunction()",
      "1763:         def SecondFunction(J  =",
      "1764:         # Nois",
      "1765:         # one",
      "1767:          enddef|BBBB",
      "1768:       enddef",
      "1769:       # Compile all functions",
      "1770:       defcompile",
      "1771:   END",
      "1772:   CheckScriptFailure(lines, 'E488:')",
      "1773: enddef",
      "",
      "---------------"
    ],
    "src/usercmd.c||src/usercmd.c": [
      "File: src/usercmd.c -> src/usercmd.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1021:  char_u     *line = NULL;",
      "1023:  ga_init2(&ga, sizeof(char_u *), 10);",
      "1025:      return retp;",
      "",
      "[Removed Lines]",
      "1024:  if (ga_add_string(&ga, p) == FAIL)",
      "",
      "[Added Lines]",
      "1024:  if (ga_copy_string(&ga, p) == FAIL)",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1038:       emsg(_(e_missing_rcurly));",
      "1039:       break;",
      "1040:   }",
      "1042:       break;",
      "1043:   if (*skipwhite(line) == '}')",
      "1044:       break;",
      "",
      "[Removed Lines]",
      "1041:   if (ga_add_string(&ga, line) == FAIL)",
      "",
      "[Added Lines]",
      "1041:   if (ga_copy_string(&ga, line) == FAIL)",
      "",
      "---------------"
    ],
    "src/userfunc.c||src/userfunc.c": [
      "File: src/userfunc.c -> src/userfunc.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "172:     static char_u *",
      "173: get_function_line(",
      "174:  exarg_T  *eap,",
      "176:  int  indent,",
      "177:  getline_opt_T getline_options)",
      "178: {",
      "",
      "[Removed Lines]",
      "175:  char_u  **line_to_free,",
      "",
      "[Added Lines]",
      "175:  garray_T *lines_to_free,",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "184:  theline = eap->getline(':', eap->cookie, indent, getline_options);",
      "185:     if (theline != NULL)",
      "186:     {",
      "191:     }",
      "193:     return theline;",
      "",
      "[Removed Lines]",
      "187:  if (*eap->cmdlinep == *line_to_free)",
      "189:  vim_free(*line_to_free);",
      "",
      "[Added Lines]",
      "187:  if (lines_to_free->ga_len > 0",
      "188:   && *eap->cmdlinep == ((char_u **)lines_to_free->ga_data)",
      "189:          [lines_to_free->ga_len - 1])",
      "191:  ga_add_string(lines_to_free, theline);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "210:     garray_T *default_args,",
      "211:     int  skip,",
      "212:     exarg_T *eap,",
      "214: {",
      "215:     int  mustend = FALSE;",
      "216:     char_u *arg;",
      "",
      "[Removed Lines]",
      "213:     char_u **line_to_free)",
      "",
      "[Added Lines]",
      "214:     garray_T *lines_to_free)",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "241:     && (*p == NUL || (VIM_ISWHITE(*whitep) && *p == '#')))",
      "242:  {",
      "245:          GETLINE_CONCAT_CONT);",
      "247:      if (theline == NULL)",
      "",
      "[Removed Lines]",
      "244:      char_u *theline = get_function_line(eap, line_to_free, 0,",
      "",
      "[Added Lines]",
      "245:      char_u *theline = get_function_line(eap, lines_to_free, 0,",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "677:  exarg_T     *eap,",
      "678:  garray_T    *newlines,",
      "679:  char_u     *line_arg_in,",
      "681: {",
      "682:     linenr_T sourcing_lnum_top = SOURCING_LNUM;",
      "683:     linenr_T sourcing_lnum_off;",
      "",
      "[Removed Lines]",
      "680:  char_u     **line_to_free)",
      "",
      "[Added Lines]",
      "681:  garray_T    *lines_to_free)",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "744:  }",
      "745:  else",
      "746:  {",
      "748:              getline_options);",
      "749:  }",
      "750:  if (KeyTyped)",
      "",
      "[Removed Lines]",
      "747:      theline = get_function_line(eap, line_to_free, indent,",
      "",
      "[Added Lines]",
      "748:      theline = get_function_line(eap, lines_to_free, indent,",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "854:       {",
      "858:    eap->nextcmd = nextcmd;",
      "861:    {",
      "862:        vim_free(*eap->cmdlinep);",
      "865:    }",
      "866:       }",
      "867:       break;",
      "",
      "[Removed Lines]",
      "859:    if (*line_to_free != NULL",
      "860:          && *eap->cmdlinep != *line_to_free)",
      "",
      "[Added Lines]",
      "861:    if (lines_to_free->ga_len > 0",
      "862:     && *eap->cmdlinep !=",
      "863:          ((char_u **)lines_to_free->ga_data)",
      "864:          [lines_to_free->ga_len - 1])",
      "870:          [lines_to_free->ga_len - 1];",
      "871:        --lines_to_free->ga_len;",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "1118:     garray_T newlines;",
      "1119:     char_u *cmdline = NULL;",
      "1120:     int  ret = FAIL;",
      "1122:     partial_T *pt;",
      "1123:     char_u *name;",
      "1124:     int  lnum_save = -1;",
      "",
      "[Removed Lines]",
      "1121:     char_u *line_to_free = NULL;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "1144:     }",
      "1146:     ga_init2(&newlines, (int)sizeof(char_u *), 10);",
      "1151:  goto erret;",
      "1155:     evalarg->eval_break_count += newlines.ga_len;",
      "",
      "[Removed Lines]",
      "1147:     if (get_function_body(&eap, &newlines, NULL, &line_to_free) == FAIL)",
      "1148:     {",
      "1149:  if (cmdline != line_to_free)",
      "1150:      vim_free(cmdline);",
      "1152:     }",
      "",
      "[Added Lines]",
      "1153:     if (get_function_body(&eap, &newlines, NULL,",
      "1154:           &evalarg->eval_tofree_ga) == FAIL)",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "1208:  {",
      "1209:      ((char_u **)(tfgap->ga_data))[tfgap->ga_len++] = cmdline;",
      "1210:      evalarg->eval_using_cmdline = TRUE;",
      "1213:  }",
      "1214:     }",
      "1215:     else",
      "",
      "[Removed Lines]",
      "1211:      if (cmdline == line_to_free)",
      "1212:   line_to_free = NULL;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 11 ---",
      "[Context before]",
      "1278: erret:",
      "1279:     if (lnum_save >= 0)",
      "1280:  SOURCING_LNUM = lnum_save;",
      "1282:     ga_clear_strings(&newlines);",
      "1283:     if (newargs != NULL)",
      "1284:  ga_clear_strings(newargs);",
      "",
      "[Removed Lines]",
      "1281:     vim_free(line_to_free);",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 12 ---",
      "[Context before]",
      "3962:     ufunc_T *",
      "3964: {",
      "3965:     int  j;",
      "3966:     int  c;",
      "",
      "[Removed Lines]",
      "3963: define_function(exarg_T *eap, char_u *name_arg, char_u **line_to_free)",
      "",
      "[Added Lines]",
      "3964: define_function(exarg_T *eap, char_u *name_arg, garray_T *lines_to_free)",
      "",
      "---------------",
      "--- Hunk 13 ---",
      "[Context before]",
      "4229:     if (get_function_args(&p, ')', &newargs,",
      "4230:    eap->cmdidx == CMD_def ? &argtypes : NULL, FALSE,",
      "4231:     NULL, &varargs, &default_args, eap->skip,",
      "4233:  goto errret_2;",
      "4234:     whitep = p;",
      "",
      "[Removed Lines]",
      "4232:     eap, line_to_free) == FAIL)",
      "",
      "[Added Lines]",
      "4233:     eap, lines_to_free) == FAIL)",
      "",
      "---------------",
      "--- Hunk 14 ---",
      "[Context before]",
      "4343:      || eap->skip)",
      "4344:  goto erret;",
      "",
      "[Removed Lines]",
      "4342:     if (get_function_body(eap, &newlines, line_arg, line_to_free) == FAIL",
      "",
      "[Added Lines]",
      "4343:     if (get_function_body(eap, &newlines, line_arg, lines_to_free) == FAIL",
      "",
      "---------------",
      "--- Hunk 15 ---",
      "[Context before]",
      "4645:     void",
      "4646: ex_function(exarg_T *eap)",
      "4647: {",
      "4652: }",
      "",
      "[Removed Lines]",
      "4648:     char_u *line_to_free = NULL;",
      "4650:     (void)define_function(eap, NULL, &line_to_free);",
      "4651:     vim_free(line_to_free);",
      "",
      "[Added Lines]",
      "4649:     garray_T lines_to_free;",
      "4651:     ga_init2(&lines_to_free, sizeof(char_u *), 50);",
      "4652:     (void)define_function(eap, NULL, &lines_to_free);",
      "4653:     ga_clear_strings(&lines_to_free);",
      "",
      "---------------"
    ],
    "src/version.c||src/version.c": [
      "File: src/version.c -> src/version.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "751: static int included_patches[] =",
      "754:     4039,",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "754:     4040,",
      "",
      "---------------"
    ],
    "src/vim9compile.c||src/vim9compile.c": [
      "File: src/vim9compile.c -> src/vim9compile.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "812:     static char_u *",
      "814: {",
      "815:     int  is_global = *eap->arg == 'g' && eap->arg[1] == ':';",
      "816:     char_u *name_start = eap->arg;",
      "",
      "[Removed Lines]",
      "813: compile_nested_function(exarg_T *eap, cctx_T *cctx, char_u **line_to_free)",
      "",
      "[Added Lines]",
      "813: compile_nested_function(exarg_T *eap, cctx_T *cctx, garray_T *lines_to_free)",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "876:  goto theend;",
      "877:     }",
      "880:     if (ufunc == NULL)",
      "881:     {",
      "882:  r = eap->skip ? OK : FAIL;",
      "",
      "[Removed Lines]",
      "879:     ufunc = define_function(eap, lambda_name, line_to_free);",
      "",
      "[Added Lines]",
      "879:     ufunc = define_function(eap, lambda_name, lines_to_free);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "2496:  cctx_T  *outer_cctx)",
      "2497: {",
      "2498:     char_u *line = NULL;",
      "2500:     char_u *p;",
      "2501:     char *errormsg = NULL; // error message",
      "2502:     cctx_T cctx;",
      "",
      "[Removed Lines]",
      "2499:     char_u *line_to_free = NULL;",
      "",
      "[Added Lines]",
      "2499:     garray_T lines_to_free;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "2514: #endif",
      "2515:     int  debug_lnum = -1;",
      "2519:     if (ufunc->uf_dfunc_idx > 0)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2518:     ga_init2(&lines_to_free, sizeof(char_u *), 50);",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "2681:      if (line != NULL)",
      "2682:      {",
      "2683:   line = vim_strsave(line);",
      "2686:      }",
      "2687:  }",
      "",
      "[Removed Lines]",
      "2684:   vim_free(line_to_free);",
      "2685:   line_to_free = line;",
      "",
      "[Added Lines]",
      "2687:   if (ga_add_string(&lines_to_free, line) == FAIL)",
      "2688:       goto erret;",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "2926:      case CMD_def:",
      "2927:      case CMD_function:",
      "2928:       ea.arg = p;",
      "2930:       break;",
      "2932:      case CMD_return:",
      "",
      "[Removed Lines]",
      "2929:       line = compile_nested_function(&ea, &cctx, &line_to_free);",
      "",
      "[Added Lines]",
      "2932:       line = compile_nested_function(&ea, &cctx, &lines_to_free);",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "3236:     if (do_estack_push)",
      "3237:  estack_pop();",
      "3240:     free_imported(&cctx);",
      "3241:     free_locals(&cctx);",
      "3242:     ga_clear(&cctx.ctx_type_stack);",
      "",
      "[Removed Lines]",
      "3239:     vim_free(line_to_free);",
      "",
      "[Added Lines]",
      "3242:     ga_clear_strings(&lines_to_free);",
      "",
      "---------------"
    ],
    "src/viminfo.c||src/viminfo.c": [
      "File: src/viminfo.c -> src/viminfo.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "2730:     {",
      "2732:  if (writing)",
      "2734:     }",
      "2735:     else",
      "2736:     {",
      "",
      "[Removed Lines]",
      "2733:      ga_add_string(&virp->vir_barlines, virp->vir_line);",
      "",
      "[Added Lines]",
      "2733:      ga_copy_string(&virp->vir_barlines, virp->vir_line);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "2769:      default:",
      "2771:   if (writing)",
      "2773:  }",
      "2774:  for (i = 0; i < values.ga_len; ++i)",
      "2775:  {",
      "",
      "[Removed Lines]",
      "2772:       ga_add_string(&virp->vir_barlines, virp->vir_line);",
      "",
      "[Added Lines]",
      "2772:       ga_copy_string(&virp->vir_barlines, virp->vir_line);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "cbae5802832b29f3a1af4cb6b0fc8cf69f17cbf4",
      "candidate_info": {
        "commit_hash": "cbae5802832b29f3a1af4cb6b0fc8cf69f17cbf4",
        "repo": "vim/vim",
        "commit_url": "https://github.com/vim/vim/commit/cbae5802832b29f3a1af4cb6b0fc8cf69f17cbf4",
        "files": [
          "Filelist",
          "src/Make_ami.mak",
          "src/Make_cyg_ming.mak",
          "src/Make_mvc.mak",
          "src/Make_vms.mms",
          "src/Makefile",
          "src/README.md",
          "src/alloc.c",
          "src/misc2.c",
          "src/proto.h",
          "src/proto/alloc.pro",
          "src/proto/misc2.pro",
          "src/version.c"
        ],
        "message": "patch 8.2.3301: memory allocation functions don't have their own place\n\nProblem:    Memory allocation functions don't have their own place.\nSolution:   Move memory allocation functions to alloc.c.  (Yegappan\n            Lakshmanan, closes #8717)",
        "before_after_code_files": [
          "src/Make_ami.mak||src/Make_ami.mak",
          "src/Make_cyg_ming.mak||src/Make_cyg_ming.mak",
          "src/Make_mvc.mak||src/Make_mvc.mak",
          "src/Make_vms.mms||src/Make_vms.mms",
          "src/alloc.c||src/alloc.c",
          "src/misc2.c||src/misc2.c",
          "src/proto.h||src/proto.h",
          "src/proto/alloc.pro||src/proto/alloc.pro",
          "src/proto/misc2.pro||src/proto/misc2.pro",
          "src/version.c||src/version.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/alloc.c||src/alloc.c",
            "src/proto/alloc.pro||src/proto/alloc.pro",
            "src/version.c||src/version.c"
          ],
          "candidate": [
            "src/alloc.c||src/alloc.c",
            "src/proto/alloc.pro||src/proto/alloc.pro",
            "src/version.c||src/version.c"
          ]
        }
      },
      "candidate_diff": {
        "src/Make_ami.mak||src/Make_ami.mak": [
          "File: src/Make_ami.mak -> src/Make_ami.mak",
          "--- Hunk 1 ---",
          "[Context before]",
          "81: # Common sources",
          "82: SRC += \\",
          "83:  arabic.c \\",
          "84:  arglist.c \\",
          "85:  autocmd.c \\",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "83:  alloc.c \\",
          "",
          "---------------"
        ],
        "src/Make_cyg_ming.mak||src/Make_cyg_ming.mak": [
          "File: src/Make_cyg_ming.mak -> src/Make_cyg_ming.mak",
          "--- Hunk 1 ---",
          "[Context before]",
          "723: GUIOBJ =  $(OUTDIR)/gui.o $(OUTDIR)/gui_w32.o $(OUTDIR)/gui_beval.o",
          "724: CUIOBJ = $(OUTDIR)/iscygpty.o",
          "725: OBJ = \\",
          "726:  $(OUTDIR)/arabic.o \\",
          "727:  $(OUTDIR)/arglist.o \\",
          "728:  $(OUTDIR)/autocmd.o \\",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "726:  $(OUTDIR)/alloc.o \\",
          "",
          "---------------"
        ],
        "src/Make_mvc.mak||src/Make_mvc.mak": [
          "File: src/Make_mvc.mak -> src/Make_mvc.mak",
          "--- Hunk 1 ---",
          "[Context before]",
          "733:  spell.h structs.h term.h beval.h $(NBDEBUG_INCL)",
          "735: OBJ = \\",
          "736:  $(OUTDIR)\\arabic.obj \\",
          "737:  $(OUTDIR)\\arglist.obj \\",
          "738:  $(OUTDIR)\\autocmd.obj \\",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "736:  $(OUTDIR)\\alloc.obj \\",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1542: .cpp{$(OUTDIR)/}.obj::",
          "1543:  $(CC) $(CFLAGS_OUTDIR) $<",
          "1545: $(OUTDIR)/arabic.obj: $(OUTDIR) arabic.c  $(INCL)",
          "1547: $(OUTDIR)/arglist.obj: $(OUTDIR) arglist.c  $(INCL)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1546: $(OUTDIR)/alloc.obj: $(OUTDIR) alloc.c  $(INCL)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1933: # End Custom Build",
          "1934: proto.h: \\",
          "1935:  proto/arabic.pro \\",
          "1936:  proto/arglist.pro \\",
          "1937:  proto/autocmd.pro \\",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1938:  proto/alloc.pro \\",
          "",
          "---------------"
        ],
        "src/Make_vms.mms||src/Make_vms.mms": [
          "File: src/Make_vms.mms -> src/Make_vms.mms",
          "--- Hunk 1 ---",
          "[Context before]",
          "306:     $(PERL_LIB) $(PYTHON_LIB) $(TCL_LIB) $(RUBY_LIB) $(LUA_LIB)",
          "308: SRC = \\",
          "309:  arabic.c \\",
          "310:  arglist.c \\",
          "311:  autocmd.c \\",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "309:  alloc.c \\",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "425:  $(XDIFF_SRC)",
          "427: OBJ = \\",
          "428:  arabic.obj \\",
          "429:  arglist.obj \\",
          "430:  autocmd.obj \\",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "429:  alloc.obj \\",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "738:  -@ !",
          "739: .ENDIF",
          "741: arabic.obj : arabic.c vim.h",
          "742: arglist.obj : arglist.c vim.h [.auto]config.h feature.h os_unix.h",
          "743: autocmd.obj : autocmd.c vim.h [.auto]config.h feature.h os_unix.h",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "743: alloc.obj : alloc.c vim.h [.auto]config.h feature.h os_unix.h \\",
          "744:  ascii.h keymap.h term.h macros.h structs.h regexp.h gui.h beval.h \\",
          "745:  [.proto]gui_beval.pro option.h ex_cmds.h proto.h errors.h globals.h",
          "",
          "---------------"
        ],
        "src/alloc.c||src/alloc.c": [
          "File: src/alloc.c -> src/alloc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "14: #include \"vim.h\"",
          "20: #if defined(MEM_PROFILE) || defined(PROTO)",
          "22: # define MEM_SIZES  8200",
          "23: static long_u mem_allocs[MEM_SIZES];",
          "24: static long_u mem_frees[MEM_SIZES];",
          "25: static long_u mem_allocated;",
          "26: static long_u mem_freed;",
          "27: static long_u mem_peak;",
          "28: static long_u num_alloc;",
          "29: static long_u num_freed;",
          "31:     static void",
          "32: mem_pre_alloc_s(size_t *sizep)",
          "33: {",
          "35: }",
          "37:     static void",
          "38: mem_pre_alloc_l(size_t *sizep)",
          "39: {",
          "41: }",
          "43:     static void",
          "44: mem_post_alloc(",
          "45:     void **pp,",
          "46:     size_t size)",
          "47: {",
          "48:     if (*pp == NULL)",
          "49:  return;",
          "50:     size -= sizeof(size_t);",
          "52:     if (size <= MEM_SIZES-1)",
          "53:  mem_allocs[size-1]++;",
          "54:     else",
          "55:  mem_allocs[MEM_SIZES-1]++;",
          "56:     mem_allocated += size;",
          "57:     if (mem_allocated - mem_freed > mem_peak)",
          "58:  mem_peak = mem_allocated - mem_freed;",
          "59:     num_alloc++;",
          "61: }",
          "63:     static void",
          "64: mem_pre_free(void **pp)",
          "65: {",
          "66:     long_u size;",
          "69:     size = *(size_t *)*pp;",
          "70:     if (size <= MEM_SIZES-1)",
          "71:  mem_frees[size-1]++;",
          "72:     else",
          "73:  mem_frees[MEM_SIZES-1]++;",
          "74:     mem_freed += size;",
          "75:     num_freed++;",
          "76: }",
          "81:     void",
          "82: vim_mem_profile_dump(void)",
          "83: {",
          "84:     int i, j;",
          "86:     printf(\"\\r\\n\");",
          "87:     j = 0;",
          "88:     for (i = 0; i < MEM_SIZES - 1; i++)",
          "89:     {",
          "90:  if (mem_allocs[i] || mem_frees[i])",
          "91:  {",
          "92:      if (mem_frees[i] > mem_allocs[i])",
          "93:   printf(\"\\r\\n%s\", _(\"ERROR: \"));",
          "94:      printf(\"[%4d / %4lu-%-4lu] \", i + 1, mem_allocs[i], mem_frees[i]);",
          "95:      j++;",
          "96:      if (j > 3)",
          "97:      {",
          "98:   j = 0;",
          "99:   printf(\"\\r\\n\");",
          "100:      }",
          "101:  }",
          "102:     }",
          "104:     i = MEM_SIZES - 1;",
          "105:     if (mem_allocs[i])",
          "106:     {",
          "107:  printf(\"\\r\\n\");",
          "108:  if (mem_frees[i] > mem_allocs[i])",
          "109:      puts(_(\"ERROR: \"));",
          "110:  printf(\"[>%d / %4lu-%-4lu]\", i, mem_allocs[i], mem_frees[i]);",
          "111:     }",
          "113:     printf(_(\"\\n[bytes] total alloc-freed %lu-%lu, in use %lu, peak use %lu\\n\"),",
          "114:      mem_allocated, mem_freed, mem_allocated - mem_freed, mem_peak);",
          "115:     printf(_(\"[calls] total re/malloc()'s %lu, total free()'s %lu\\n\\n\"),",
          "116:      num_alloc, num_freed);",
          "117: }",
          "119: #endif // MEM_PROFILE",
          "121: #ifdef FEAT_EVAL",
          "122:     int",
          "123: alloc_does_fail(size_t size)",
          "124: {",
          "125:     if (alloc_fail_countdown == 0)",
          "126:     {",
          "127:  if (--alloc_fail_repeat <= 0)",
          "128:      alloc_fail_id = 0;",
          "129:  do_outofmem_msg(size);",
          "130:  return TRUE;",
          "131:     }",
          "132:     --alloc_fail_countdown;",
          "133:     return FALSE;",
          "134: }",
          "135: #endif",
          "141: #define KEEP_ROOM (2 * 8192L)",
          "142: #define KEEP_ROOM_KB (KEEP_ROOM / 1024L)",
          "148:     void *",
          "149: alloc(size_t size)",
          "150: {",
          "151:     return lalloc(size, TRUE);",
          "152: }",
          "157:     void *",
          "158: alloc_id(size_t size, alloc_id_T id UNUSED)",
          "159: {",
          "160: #ifdef FEAT_EVAL",
          "161:     if (alloc_fail_id == id && alloc_does_fail(size))",
          "162:  return NULL;",
          "163: #endif",
          "164:     return lalloc(size, TRUE);",
          "165: }",
          "170:     void *",
          "171: alloc_clear(size_t size)",
          "172: {",
          "173:     void *p;",
          "175:     p = lalloc(size, TRUE);",
          "176:     if (p != NULL)",
          "177:  (void)vim_memset(p, 0, size);",
          "178:     return p;",
          "179: }",
          "184:     void *",
          "185: alloc_clear_id(size_t size, alloc_id_T id UNUSED)",
          "186: {",
          "187: #ifdef FEAT_EVAL",
          "188:     if (alloc_fail_id == id && alloc_does_fail(size))",
          "189:  return NULL;",
          "190: #endif",
          "191:     return alloc_clear(size);",
          "192: }",
          "197:     void *",
          "198: lalloc_clear(size_t size, int message)",
          "199: {",
          "200:     void *p;",
          "202:     p = lalloc(size, message);",
          "203:     if (p != NULL)",
          "204:  (void)vim_memset(p, 0, size);",
          "205:     return p;",
          "206: }",
          "212:     void *",
          "213: lalloc(size_t size, int message)",
          "214: {",
          "215:     void *p;      // pointer to new storage space",
          "216:     static int releasing = FALSE;  // don't do mf_release_all() recursive",
          "217:     int  try_again;",
          "218: #if defined(HAVE_AVAIL_MEM)",
          "219:     static size_t allocated = 0;    // allocated since last avail check",
          "220: #endif",
          "223:     if (size == 0)",
          "224:     {",
          "226:  emsg_silent = 0;",
          "227:  iemsg(_(\"E341: Internal error: lalloc(0, )\"));",
          "228:  return NULL;",
          "229:     }",
          "231: #ifdef MEM_PROFILE",
          "232:     mem_pre_alloc_l(&size);",
          "233: #endif",
          "239:     for (;;)",
          "240:     {",
          "248:  if ((p = malloc(size)) != NULL)",
          "249:  {",
          "250: #ifndef HAVE_AVAIL_MEM",
          "252:      goto theend;",
          "253: #else",
          "256:      allocated += size;",
          "257:      if (allocated < KEEP_ROOM / 2)",
          "258:   goto theend;",
          "259:      allocated = 0;",
          "262:      if (mch_avail_mem(TRUE) < KEEP_ROOM_KB && !releasing)",
          "263:      {",
          "264:   free(p); // System is low... no go!",
          "265:   p = NULL;",
          "266:      }",
          "267:      else",
          "268:   goto theend;",
          "269: #endif",
          "270:  }",
          "275:  if (releasing)",
          "276:      break;",
          "277:  releasing = TRUE;",
          "279:  clear_sb_text(TRUE);       // free any scrollback text",
          "280:  try_again = mf_release_all(); // release as many blocks as possible",
          "282:  releasing = FALSE;",
          "283:  if (!try_again)",
          "284:      break;",
          "285:     }",
          "287:     if (message && p == NULL)",
          "288:  do_outofmem_msg(size);",
          "290: theend:",
          "291: #ifdef MEM_PROFILE",
          "292:     mem_post_alloc(&p, size);",
          "293: #endif",
          "294:     return p;",
          "295: }",
          "300: #if defined(FEAT_SIGNS) || defined(PROTO)",
          "301:     void *",
          "302: lalloc_id(size_t size, int message, alloc_id_T id UNUSED)",
          "303: {",
          "304: #ifdef FEAT_EVAL",
          "305:     if (alloc_fail_id == id && alloc_does_fail(size))",
          "306:  return NULL;",
          "307: #endif",
          "308:     return (lalloc(size, message));",
          "309: }",
          "310: #endif",
          "312: #if defined(MEM_PROFILE) || defined(PROTO)",
          "316:     void *",
          "317: mem_realloc(void *ptr, size_t size)",
          "318: {",
          "319:     void *p;",
          "321:     mem_pre_free(&ptr);",
          "322:     mem_pre_alloc_s(&size);",
          "324:     p = realloc(ptr, size);",
          "326:     mem_post_alloc(&p, size);",
          "328:     return p;",
          "329: }",
          "330: #endif",
          "336:     void",
          "337: do_outofmem_msg(size_t size)",
          "338: {",
          "339:     if (!did_outofmem_msg)",
          "340:     {",
          "342:  emsg_silent = 0;",
          "346:  did_outofmem_msg = TRUE;",
          "348:  semsg(_(\"E342: Out of memory!  (allocating %lu bytes)\"), (long_u)size);",
          "350:  if (starting == NO_SCREEN)",
          "353:      mch_exit(123);",
          "354:     }",
          "355: }",
          "357: #if defined(EXITFREE) || defined(PROTO)",
          "366:     void",
          "367: free_all_mem(void)",
          "368: {",
          "369:     buf_T *buf, *nextbuf;",
          "373:     if (entered_free_all_mem)",
          "374:  return;",
          "375:     entered_free_all_mem = TRUE;",
          "377:     block_autocmds();",
          "380:     p_ea = FALSE;",
          "381:     if (first_tabpage != NULL && first_tabpage->tp_next != NULL)",
          "382:  do_cmdline_cmd((char_u *)\"tabonly!\");",
          "383:     if (!ONE_WINDOW)",
          "384:  do_cmdline_cmd((char_u *)\"only!\");",
          "386: # if defined(FEAT_SPELL)",
          "388:     spell_free_all();",
          "389: # endif",
          "391: # if defined(FEAT_BEVAL_TERM)",
          "392:     ui_remove_balloon();",
          "393: # endif",
          "394: # ifdef FEAT_PROP_POPUP",
          "395:     if (curwin != NULL)",
          "396:  close_all_popups(TRUE);",
          "397: # endif",
          "400:     ex_comclear(NULL);",
          "404:     if (curbuf != NULL)",
          "405:     {",
          "406: # ifdef FEAT_MENU",
          "408:  do_cmdline_cmd((char_u *)\"aunmenu *\");",
          "409: #  ifdef FEAT_MULTI_LANG",
          "410:  do_cmdline_cmd((char_u *)\"menutranslate clear\");",
          "411: #  endif",
          "412: # endif",
          "414:  do_cmdline_cmd((char_u *)\"lmapclear\");",
          "415:  do_cmdline_cmd((char_u *)\"xmapclear\");",
          "416:  do_cmdline_cmd((char_u *)\"mapclear\");",
          "417:  do_cmdline_cmd((char_u *)\"mapclear!\");",
          "418:  do_cmdline_cmd((char_u *)\"abclear\");",
          "419: # if defined(FEAT_EVAL)",
          "420:  do_cmdline_cmd((char_u *)\"breakdel *\");",
          "421: # endif",
          "422: # if defined(FEAT_PROFILE)",
          "423:  do_cmdline_cmd((char_u *)\"profdel *\");",
          "424: # endif",
          "425: # if defined(FEAT_KEYMAP)",
          "426:  do_cmdline_cmd((char_u *)\"set keymap=\");",
          "427: # endif",
          "428:     }",
          "430: # ifdef FEAT_TITLE",
          "431:     free_titles();",
          "432: # endif",
          "433: # if defined(FEAT_SEARCHPATH)",
          "434:     free_findfile();",
          "435: # endif",
          "438:     free_all_autocmds();",
          "439:     clear_termcodes();",
          "440:     free_all_marks();",
          "441:     alist_clear(&global_alist);",
          "442:     free_homedir();",
          "443:     free_users();",
          "444:     free_search_patterns();",
          "445:     free_old_sub();",
          "446:     free_last_insert();",
          "447:     free_insexpand_stuff();",
          "448:     free_prev_shellcmd();",
          "449:     free_regexp_stuff();",
          "450:     free_tag_stuff();",
          "451:     free_cd_dir();",
          "452: # ifdef FEAT_SIGNS",
          "453:     free_signs();",
          "454: # endif",
          "455: # ifdef FEAT_EVAL",
          "456:     set_expr_line(NULL, NULL);",
          "457: # endif",
          "458: # ifdef FEAT_DIFF",
          "459:     if (curtab != NULL)",
          "460:  diff_clear(curtab);",
          "461: # endif",
          "462:     clear_sb_text(TRUE);       // free any scrollback text",
          "465:     free_username();",
          "466: # ifdef FEAT_CLIPBOARD",
          "467:     vim_regfree(clip_exclude_prog);",
          "468: # endif",
          "469:     vim_free(last_cmdline);",
          "470:     vim_free(new_last_cmdline);",
          "471:     set_keep_msg(NULL, 0);",
          "474:     p_hi = 0;",
          "475:     init_history();",
          "476: # ifdef FEAT_PROP_POPUP",
          "477:     clear_global_prop_types();",
          "478: # endif",
          "480: # ifdef FEAT_QUICKFIX",
          "481:     {",
          "482:  win_T     *win;",
          "483:  tabpage_T   *tab;",
          "485:  qf_free_all(NULL);",
          "487:  FOR_ALL_TAB_WINDOWS(tab, win)",
          "488:      qf_free_all(win);",
          "489:     }",
          "490: # endif",
          "493:     close_all_scripts();",
          "495:     if (curwin != NULL)",
          "497:  win_free_all();",
          "500:     free_all_options();",
          "504: # ifdef FEAT_AUTOCHDIR",
          "505:     p_acd = FALSE;",
          "506: # endif",
          "507:     for (buf = firstbuf; buf != NULL; )",
          "508:     {",
          "509:  bufref_T    bufref;",
          "511:  set_bufref(&bufref, buf);",
          "512:  nextbuf = buf->b_next;",
          "513:  close_buffer(NULL, buf, DOBUF_WIPE, FALSE, FALSE);",
          "514:  if (bufref_valid(&bufref))",
          "515:      buf = nextbuf; // didn't work, try next one",
          "516:  else",
          "517:      buf = firstbuf;",
          "518:     }",
          "520: # ifdef FEAT_ARABIC",
          "521:     free_arshape_buf();",
          "522: # endif",
          "525:     clear_registers();",
          "526:     ResetRedobuff();",
          "527:     ResetRedobuff();",
          "529: # if defined(FEAT_CLIENTSERVER) && defined(FEAT_X11)",
          "530:     vim_free(serverDelayedStartName);",
          "531: # endif",
          "534:     free_highlight();",
          "536:     reset_last_sourcing();",
          "538:     if (first_tabpage != NULL)",
          "539:     {",
          "540:  free_tabpage(first_tabpage);",
          "541:  first_tabpage = NULL;",
          "542:     }",
          "544: # ifdef UNIX",
          "546:     mch_free_mem();",
          "547: # endif",
          "550:     for (;;)",
          "551:  if (delete_first_msg() == FAIL)",
          "552:      break;",
          "554: # ifdef FEAT_JOB_CHANNEL",
          "555:     channel_free_all();",
          "556: # endif",
          "557: # ifdef FEAT_TIMERS",
          "558:     timer_free_all();",
          "559: # endif",
          "560: # ifdef FEAT_EVAL",
          "562:     eval_clear();",
          "563: # endif",
          "564: # ifdef FEAT_JOB_CHANNEL",
          "566:     job_free_all();",
          "567: # endif",
          "569:     free_termoptions();",
          "572:     free_screenlines();",
          "574: # if defined(FEAT_SOUND)",
          "575:     sound_free();",
          "576: # endif",
          "577: # if defined(USE_XSMP)",
          "578:     xsmp_close();",
          "579: # endif",
          "580: # ifdef FEAT_GUI_GTK",
          "581:     gui_mch_free_all();",
          "582: # endif",
          "583:     clear_hl_tables();",
          "585:     vim_free(IObuff);",
          "586:     vim_free(NameBuff);",
          "587: # ifdef FEAT_QUICKFIX",
          "588:     check_quickfix_busy();",
          "589: # endif",
          "590: }",
          "591: #endif",
          "597:     char_u *",
          "598: vim_memsave(char_u *p, size_t len)",
          "599: {",
          "600:     char_u *ret = alloc(len);",
          "602:     if (ret != NULL)",
          "603:  mch_memmove(ret, p, len);",
          "604:     return ret;",
          "605: }",
          "614:     void",
          "615: vim_free(void *x)",
          "616: {",
          "617:     if (x != NULL && !really_exiting)",
          "618:     {",
          "619: #ifdef MEM_PROFILE",
          "620:  mem_pre_free(&x);",
          "621: #endif",
          "622:  free(x);",
          "623:     }",
          "624: }",
          "633:     void",
          "634: ga_clear(garray_T *gap)",
          "635: {",
          "636:     vim_free(gap->ga_data);",
          "637:     ga_init(gap);",
          "638: }",
          "643:     void",
          "644: ga_clear_strings(garray_T *gap)",
          "645: {",
          "646:     int  i;",
          "648:     if (gap->ga_data != NULL)",
          "649:  for (i = 0; i < gap->ga_len; ++i)",
          "650:      vim_free(((char_u **)(gap->ga_data))[i]);",
          "651:     ga_clear(gap);",
          "652: }",
          "657:     int",
          "658: ga_copy_strings(garray_T *from, garray_T *to)",
          "659: {",
          "660:     int  i;",
          "662:     ga_init2(to, sizeof(char_u *), 1);",
          "663:     if (ga_grow(to, from->ga_len) == FAIL)",
          "664:  return FAIL;",
          "666:     for (i = 0; i < from->ga_len; ++i)",
          "667:     {",
          "668:  char_u *orig = ((char_u **)from->ga_data)[i];",
          "669:  char_u *copy;",
          "671:  if (orig == NULL)",
          "672:      copy = NULL;",
          "673:  else",
          "674:  {",
          "675:      copy = vim_strsave(orig);",
          "676:      if (copy == NULL)",
          "677:      {",
          "678:   to->ga_len = i;",
          "679:   ga_clear_strings(to);",
          "680:   return FAIL;",
          "681:      }",
          "682:  }",
          "683:  ((char_u **)to->ga_data)[i] = copy;",
          "684:     }",
          "685:     to->ga_len = from->ga_len;",
          "686:     return OK;",
          "687: }",
          "693:     void",
          "694: ga_init(garray_T *gap)",
          "695: {",
          "696:     gap->ga_data = NULL;",
          "697:     gap->ga_maxlen = 0;",
          "698:     gap->ga_len = 0;",
          "699: }",
          "701:     void",
          "702: ga_init2(garray_T *gap, int itemsize, int growsize)",
          "703: {",
          "704:     ga_init(gap);",
          "705:     gap->ga_itemsize = itemsize;",
          "706:     gap->ga_growsize = growsize;",
          "707: }",
          "713:     int",
          "714: ga_grow(garray_T *gap, int n)",
          "715: {",
          "716:     if (gap->ga_maxlen - gap->ga_len < n)",
          "717:  return ga_grow_inner(gap, n);",
          "718:     return OK;",
          "719: }",
          "721:     int",
          "722: ga_grow_inner(garray_T *gap, int n)",
          "723: {",
          "724:     size_t old_len;",
          "725:     size_t new_len;",
          "726:     char_u *pp;",
          "728:     if (n < gap->ga_growsize)",
          "729:  n = gap->ga_growsize;",
          "734:     if (n < gap->ga_len / 2)",
          "735:  n = gap->ga_len / 2;",
          "737:     new_len = gap->ga_itemsize * (gap->ga_len + n);",
          "738:     pp = vim_realloc(gap->ga_data, new_len);",
          "739:     if (pp == NULL)",
          "740:  return FAIL;",
          "741:     old_len = gap->ga_itemsize * gap->ga_maxlen;",
          "742:     vim_memset(pp + old_len, 0, new_len - old_len);",
          "743:     gap->ga_maxlen = gap->ga_len + n;",
          "744:     gap->ga_data = pp;",
          "745:     return OK;",
          "746: }",
          "753:     char_u *",
          "754: ga_concat_strings(garray_T *gap, char *sep)",
          "755: {",
          "756:     int  i;",
          "757:     int  len = 0;",
          "758:     int  sep_len = (int)STRLEN(sep);",
          "759:     char_u *s;",
          "760:     char_u *p;",
          "762:     for (i = 0; i < gap->ga_len; ++i)",
          "763:  len += (int)STRLEN(((char_u **)(gap->ga_data))[i]) + sep_len;",
          "765:     s = alloc(len + 1);",
          "766:     if (s != NULL)",
          "767:     {",
          "769:  p = s;",
          "770:  for (i = 0; i < gap->ga_len; ++i)",
          "771:  {",
          "772:      if (p != s)",
          "773:      {",
          "774:   STRCPY(p, sep);",
          "775:   p += sep_len;",
          "776:      }",
          "777:      STRCPY(p, ((char_u **)(gap->ga_data))[i]);",
          "778:      p += STRLEN(p);",
          "779:  }",
          "780:     }",
          "781:     return s;",
          "782: }",
          "788:     int",
          "789: ga_add_string(garray_T *gap, char_u *p)",
          "790: {",
          "791:     char_u *cp = vim_strsave(p);",
          "793:     if (cp == NULL)",
          "794:  return FAIL;",
          "796:     if (ga_grow(gap, 1) == FAIL)",
          "797:     {",
          "798:  vim_free(cp);",
          "799:  return FAIL;",
          "800:     }",
          "801:     ((char_u **)(gap->ga_data))[gap->ga_len++] = cp;",
          "802:     return OK;",
          "803: }",
          "810:     void",
          "811: ga_concat(garray_T *gap, char_u *s)",
          "812: {",
          "813:     int    len;",
          "815:     if (s == NULL || *s == NUL)",
          "816:  return;",
          "817:     len = (int)STRLEN(s);",
          "818:     if (ga_grow(gap, len) == OK)",
          "819:     {",
          "820:  mch_memmove((char *)gap->ga_data + gap->ga_len, s, (size_t)len);",
          "821:  gap->ga_len += len;",
          "822:     }",
          "823: }",
          "829:     void",
          "830: ga_concat_len(garray_T *gap, char_u *s, size_t len)",
          "831: {",
          "832:     if (s == NULL || *s == NUL)",
          "833:  return;",
          "834:     if (ga_grow(gap, (int)len) == OK)",
          "835:     {",
          "836:  mch_memmove((char *)gap->ga_data + gap->ga_len, s, len);",
          "837:  gap->ga_len += (int)len;",
          "838:     }",
          "839: }",
          "844:     void",
          "845: ga_append(garray_T *gap, int c)",
          "846: {",
          "847:     if (ga_grow(gap, 1) == OK)",
          "848:     {",
          "850:  ++gap->ga_len;",
          "851:     }",
          "852: }",
          "854: #if (defined(UNIX) && !defined(USE_SYSTEM)) || defined(MSWIN) \\",
          "855:  || defined(PROTO)",
          "859:     void",
          "860: append_ga_line(garray_T *gap)",
          "861: {",
          "863:     if (gap->ga_len > 0",
          "864:      && !curbuf->b_p_bin",
          "865:      && ((char_u *)gap->ga_data)[gap->ga_len - 1] == CAR)",
          "866:  --gap->ga_len;",
          "867:     ga_append(gap, NUL);",
          "868:     ml_append(curwin->w_cursor.lnum++, gap->ga_data, 0, FALSE);",
          "869:     gap->ga_len = 0;",
          "870: }",
          "871: #endif",
          "",
          "---------------"
        ],
        "src/misc2.c||src/misc2.c": [
          "File: src/misc2.c -> src/misc2.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "693:     return retval;",
          "694: }",
          "",
          "[Removed Lines]",
          "700: #if defined(MEM_PROFILE) || defined(PROTO)",
          "702: # define MEM_SIZES  8200",
          "703: static long_u mem_allocs[MEM_SIZES];",
          "704: static long_u mem_frees[MEM_SIZES];",
          "705: static long_u mem_allocated;",
          "706: static long_u mem_freed;",
          "707: static long_u mem_peak;",
          "708: static long_u num_alloc;",
          "709: static long_u num_freed;",
          "711:     static void",
          "712: mem_pre_alloc_s(size_t *sizep)",
          "713: {",
          "715: }",
          "717:     static void",
          "718: mem_pre_alloc_l(size_t *sizep)",
          "719: {",
          "721: }",
          "723:     static void",
          "724: mem_post_alloc(",
          "725:     void **pp,",
          "726:     size_t size)",
          "727: {",
          "728:     if (*pp == NULL)",
          "729:  return;",
          "730:     size -= sizeof(size_t);",
          "732:     if (size <= MEM_SIZES-1)",
          "733:  mem_allocs[size-1]++;",
          "734:     else",
          "735:  mem_allocs[MEM_SIZES-1]++;",
          "736:     mem_allocated += size;",
          "737:     if (mem_allocated - mem_freed > mem_peak)",
          "738:  mem_peak = mem_allocated - mem_freed;",
          "739:     num_alloc++;",
          "741: }",
          "743:     static void",
          "744: mem_pre_free(void **pp)",
          "745: {",
          "746:     long_u size;",
          "749:     size = *(size_t *)*pp;",
          "750:     if (size <= MEM_SIZES-1)",
          "751:  mem_frees[size-1]++;",
          "752:     else",
          "753:  mem_frees[MEM_SIZES-1]++;",
          "754:     mem_freed += size;",
          "755:     num_freed++;",
          "756: }",
          "761:     void",
          "762: vim_mem_profile_dump(void)",
          "763: {",
          "764:     int i, j;",
          "766:     printf(\"\\r\\n\");",
          "767:     j = 0;",
          "768:     for (i = 0; i < MEM_SIZES - 1; i++)",
          "769:     {",
          "770:  if (mem_allocs[i] || mem_frees[i])",
          "771:  {",
          "772:      if (mem_frees[i] > mem_allocs[i])",
          "773:   printf(\"\\r\\n%s\", _(\"ERROR: \"));",
          "774:      printf(\"[%4d / %4lu-%-4lu] \", i + 1, mem_allocs[i], mem_frees[i]);",
          "775:      j++;",
          "776:      if (j > 3)",
          "777:      {",
          "778:   j = 0;",
          "779:   printf(\"\\r\\n\");",
          "780:      }",
          "781:  }",
          "782:     }",
          "784:     i = MEM_SIZES - 1;",
          "785:     if (mem_allocs[i])",
          "786:     {",
          "787:  printf(\"\\r\\n\");",
          "788:  if (mem_frees[i] > mem_allocs[i])",
          "789:      puts(_(\"ERROR: \"));",
          "790:  printf(\"[>%d / %4lu-%-4lu]\", i, mem_allocs[i], mem_frees[i]);",
          "791:     }",
          "793:     printf(_(\"\\n[bytes] total alloc-freed %lu-%lu, in use %lu, peak use %lu\\n\"),",
          "794:      mem_allocated, mem_freed, mem_allocated - mem_freed, mem_peak);",
          "795:     printf(_(\"[calls] total re/malloc()'s %lu, total free()'s %lu\\n\\n\"),",
          "796:      num_alloc, num_freed);",
          "797: }",
          "799: #endif // MEM_PROFILE",
          "801: #ifdef FEAT_EVAL",
          "802:     int",
          "803: alloc_does_fail(size_t size)",
          "804: {",
          "805:     if (alloc_fail_countdown == 0)",
          "806:     {",
          "807:  if (--alloc_fail_repeat <= 0)",
          "808:      alloc_fail_id = 0;",
          "809:  do_outofmem_msg(size);",
          "810:  return TRUE;",
          "811:     }",
          "812:     --alloc_fail_countdown;",
          "813:     return FALSE;",
          "814: }",
          "815: #endif",
          "821: #define KEEP_ROOM (2 * 8192L)",
          "822: #define KEEP_ROOM_KB (KEEP_ROOM / 1024L)",
          "828:     void *",
          "829: alloc(size_t size)",
          "830: {",
          "831:     return lalloc(size, TRUE);",
          "832: }",
          "837:     void *",
          "838: alloc_id(size_t size, alloc_id_T id UNUSED)",
          "839: {",
          "840: #ifdef FEAT_EVAL",
          "841:     if (alloc_fail_id == id && alloc_does_fail(size))",
          "842:  return NULL;",
          "843: #endif",
          "844:     return lalloc(size, TRUE);",
          "845: }",
          "850:     void *",
          "851: alloc_clear(size_t size)",
          "852: {",
          "853:     void *p;",
          "855:     p = lalloc(size, TRUE);",
          "856:     if (p != NULL)",
          "857:  (void)vim_memset(p, 0, size);",
          "858:     return p;",
          "859: }",
          "864:     void *",
          "865: alloc_clear_id(size_t size, alloc_id_T id UNUSED)",
          "866: {",
          "867: #ifdef FEAT_EVAL",
          "868:     if (alloc_fail_id == id && alloc_does_fail(size))",
          "869:  return NULL;",
          "870: #endif",
          "871:     return alloc_clear(size);",
          "872: }",
          "877:     void *",
          "878: lalloc_clear(size_t size, int message)",
          "879: {",
          "880:     void *p;",
          "882:     p = lalloc(size, message);",
          "883:     if (p != NULL)",
          "884:  (void)vim_memset(p, 0, size);",
          "885:     return p;",
          "886: }",
          "892:     void *",
          "893: lalloc(size_t size, int message)",
          "894: {",
          "895:     void *p;      // pointer to new storage space",
          "896:     static int releasing = FALSE;  // don't do mf_release_all() recursive",
          "897:     int  try_again;",
          "898: #if defined(HAVE_AVAIL_MEM)",
          "899:     static size_t allocated = 0;    // allocated since last avail check",
          "900: #endif",
          "903:     if (size == 0)",
          "904:     {",
          "906:  emsg_silent = 0;",
          "907:  iemsg(_(\"E341: Internal error: lalloc(0, )\"));",
          "908:  return NULL;",
          "909:     }",
          "911: #ifdef MEM_PROFILE",
          "912:     mem_pre_alloc_l(&size);",
          "913: #endif",
          "919:     for (;;)",
          "920:     {",
          "928:  if ((p = malloc(size)) != NULL)",
          "929:  {",
          "930: #ifndef HAVE_AVAIL_MEM",
          "932:      goto theend;",
          "933: #else",
          "936:      allocated += size;",
          "937:      if (allocated < KEEP_ROOM / 2)",
          "938:   goto theend;",
          "939:      allocated = 0;",
          "942:      if (mch_avail_mem(TRUE) < KEEP_ROOM_KB && !releasing)",
          "943:      {",
          "944:   free(p); // System is low... no go!",
          "945:   p = NULL;",
          "946:      }",
          "947:      else",
          "948:   goto theend;",
          "949: #endif",
          "950:  }",
          "955:  if (releasing)",
          "956:      break;",
          "957:  releasing = TRUE;",
          "959:  clear_sb_text(TRUE);       // free any scrollback text",
          "960:  try_again = mf_release_all(); // release as many blocks as possible",
          "962:  releasing = FALSE;",
          "963:  if (!try_again)",
          "964:      break;",
          "965:     }",
          "967:     if (message && p == NULL)",
          "968:  do_outofmem_msg(size);",
          "970: theend:",
          "971: #ifdef MEM_PROFILE",
          "972:     mem_post_alloc(&p, size);",
          "973: #endif",
          "974:     return p;",
          "975: }",
          "980: #if defined(FEAT_SIGNS) || defined(PROTO)",
          "981:     void *",
          "982: lalloc_id(size_t size, int message, alloc_id_T id UNUSED)",
          "983: {",
          "984: #ifdef FEAT_EVAL",
          "985:     if (alloc_fail_id == id && alloc_does_fail(size))",
          "986:  return NULL;",
          "987: #endif",
          "988:     return (lalloc(size, message));",
          "989: }",
          "990: #endif",
          "992: #if defined(MEM_PROFILE) || defined(PROTO)",
          "996:     void *",
          "997: mem_realloc(void *ptr, size_t size)",
          "998: {",
          "999:     void *p;",
          "1001:     mem_pre_free(&ptr);",
          "1002:     mem_pre_alloc_s(&size);",
          "1004:     p = realloc(ptr, size);",
          "1006:     mem_post_alloc(&p, size);",
          "1008:     return p;",
          "1009: }",
          "1010: #endif",
          "1016:     void",
          "1017: do_outofmem_msg(size_t size)",
          "1018: {",
          "1019:     if (!did_outofmem_msg)",
          "1020:     {",
          "1022:  emsg_silent = 0;",
          "1026:  did_outofmem_msg = TRUE;",
          "1028:  semsg(_(\"E342: Out of memory!  (allocating %lu bytes)\"), (long_u)size);",
          "1030:  if (starting == NO_SCREEN)",
          "1033:      mch_exit(123);",
          "1034:     }",
          "1035: }",
          "1037: #if defined(EXITFREE) || defined(PROTO)",
          "1046:     void",
          "1047: free_all_mem(void)",
          "1048: {",
          "1049:     buf_T *buf, *nextbuf;",
          "1053:     if (entered_free_all_mem)",
          "1054:  return;",
          "1055:     entered_free_all_mem = TRUE;",
          "1057:     block_autocmds();",
          "1060:     p_ea = FALSE;",
          "1061:     if (first_tabpage != NULL && first_tabpage->tp_next != NULL)",
          "1062:  do_cmdline_cmd((char_u *)\"tabonly!\");",
          "1063:     if (!ONE_WINDOW)",
          "1064:  do_cmdline_cmd((char_u *)\"only!\");",
          "1066: # if defined(FEAT_SPELL)",
          "1068:     spell_free_all();",
          "1069: # endif",
          "1071: # if defined(FEAT_BEVAL_TERM)",
          "1072:     ui_remove_balloon();",
          "1073: # endif",
          "1074: # ifdef FEAT_PROP_POPUP",
          "1075:     if (curwin != NULL)",
          "1076:  close_all_popups(TRUE);",
          "1077: # endif",
          "1080:     ex_comclear(NULL);",
          "1084:     if (curbuf != NULL)",
          "1085:     {",
          "1086: # ifdef FEAT_MENU",
          "1088:  do_cmdline_cmd((char_u *)\"aunmenu *\");",
          "1089: #  ifdef FEAT_MULTI_LANG",
          "1090:  do_cmdline_cmd((char_u *)\"menutranslate clear\");",
          "1091: #  endif",
          "1092: # endif",
          "1094:  do_cmdline_cmd((char_u *)\"lmapclear\");",
          "1095:  do_cmdline_cmd((char_u *)\"xmapclear\");",
          "1096:  do_cmdline_cmd((char_u *)\"mapclear\");",
          "1097:  do_cmdline_cmd((char_u *)\"mapclear!\");",
          "1098:  do_cmdline_cmd((char_u *)\"abclear\");",
          "1099: # if defined(FEAT_EVAL)",
          "1100:  do_cmdline_cmd((char_u *)\"breakdel *\");",
          "1101: # endif",
          "1102: # if defined(FEAT_PROFILE)",
          "1103:  do_cmdline_cmd((char_u *)\"profdel *\");",
          "1104: # endif",
          "1105: # if defined(FEAT_KEYMAP)",
          "1106:  do_cmdline_cmd((char_u *)\"set keymap=\");",
          "1107: # endif",
          "1108:     }",
          "1110: # ifdef FEAT_TITLE",
          "1111:     free_titles();",
          "1112: # endif",
          "1113: # if defined(FEAT_SEARCHPATH)",
          "1114:     free_findfile();",
          "1115: # endif",
          "1118:     free_all_autocmds();",
          "1119:     clear_termcodes();",
          "1120:     free_all_marks();",
          "1121:     alist_clear(&global_alist);",
          "1122:     free_homedir();",
          "1123:     free_users();",
          "1124:     free_search_patterns();",
          "1125:     free_old_sub();",
          "1126:     free_last_insert();",
          "1127:     free_insexpand_stuff();",
          "1128:     free_prev_shellcmd();",
          "1129:     free_regexp_stuff();",
          "1130:     free_tag_stuff();",
          "1131:     free_cd_dir();",
          "1132: # ifdef FEAT_SIGNS",
          "1133:     free_signs();",
          "1134: # endif",
          "1135: # ifdef FEAT_EVAL",
          "1136:     set_expr_line(NULL, NULL);",
          "1137: # endif",
          "1138: # ifdef FEAT_DIFF",
          "1139:     if (curtab != NULL)",
          "1140:  diff_clear(curtab);",
          "1141: # endif",
          "1142:     clear_sb_text(TRUE);       // free any scrollback text",
          "1145:     vim_free(username);",
          "1146: # ifdef FEAT_CLIPBOARD",
          "1147:     vim_regfree(clip_exclude_prog);",
          "1148: # endif",
          "1149:     vim_free(last_cmdline);",
          "1150:     vim_free(new_last_cmdline);",
          "1151:     set_keep_msg(NULL, 0);",
          "1154:     p_hi = 0;",
          "1155:     init_history();",
          "1156: # ifdef FEAT_PROP_POPUP",
          "1157:     clear_global_prop_types();",
          "1158: # endif",
          "1160: # ifdef FEAT_QUICKFIX",
          "1161:     {",
          "1162:  win_T     *win;",
          "1163:  tabpage_T   *tab;",
          "1165:  qf_free_all(NULL);",
          "1167:  FOR_ALL_TAB_WINDOWS(tab, win)",
          "1168:      qf_free_all(win);",
          "1169:     }",
          "1170: # endif",
          "1173:     close_all_scripts();",
          "1175:     if (curwin != NULL)",
          "1177:  win_free_all();",
          "1180:     free_all_options();",
          "1184: # ifdef FEAT_AUTOCHDIR",
          "1185:     p_acd = FALSE;",
          "1186: # endif",
          "1187:     for (buf = firstbuf; buf != NULL; )",
          "1188:     {",
          "1189:  bufref_T    bufref;",
          "1191:  set_bufref(&bufref, buf);",
          "1192:  nextbuf = buf->b_next;",
          "1193:  close_buffer(NULL, buf, DOBUF_WIPE, FALSE, FALSE);",
          "1194:  if (bufref_valid(&bufref))",
          "1195:      buf = nextbuf; // didn't work, try next one",
          "1196:  else",
          "1197:      buf = firstbuf;",
          "1198:     }",
          "1200: # ifdef FEAT_ARABIC",
          "1201:     free_arshape_buf();",
          "1202: # endif",
          "1205:     clear_registers();",
          "1206:     ResetRedobuff();",
          "1207:     ResetRedobuff();",
          "1209: # if defined(FEAT_CLIENTSERVER) && defined(FEAT_X11)",
          "1210:     vim_free(serverDelayedStartName);",
          "1211: # endif",
          "1214:     free_highlight();",
          "1216:     reset_last_sourcing();",
          "1218:     if (first_tabpage != NULL)",
          "1219:     {",
          "1220:  free_tabpage(first_tabpage);",
          "1221:  first_tabpage = NULL;",
          "1222:     }",
          "1224: # ifdef UNIX",
          "1226:     mch_free_mem();",
          "1227: # endif",
          "1230:     for (;;)",
          "1231:  if (delete_first_msg() == FAIL)",
          "1232:      break;",
          "1234: # ifdef FEAT_JOB_CHANNEL",
          "1235:     channel_free_all();",
          "1236: # endif",
          "1237: # ifdef FEAT_TIMERS",
          "1238:     timer_free_all();",
          "1239: # endif",
          "1240: # ifdef FEAT_EVAL",
          "1242:     eval_clear();",
          "1243: # endif",
          "1244: # ifdef FEAT_JOB_CHANNEL",
          "1246:     job_free_all();",
          "1247: # endif",
          "1249:     free_termoptions();",
          "1252:     free_screenlines();",
          "1254: # if defined(FEAT_SOUND)",
          "1255:     sound_free();",
          "1256: # endif",
          "1257: # if defined(USE_XSMP)",
          "1258:     xsmp_close();",
          "1259: # endif",
          "1260: # ifdef FEAT_GUI_GTK",
          "1261:     gui_mch_free_all();",
          "1262: # endif",
          "1263:     clear_hl_tables();",
          "1265:     vim_free(IObuff);",
          "1266:     vim_free(NameBuff);",
          "1267: # ifdef FEAT_QUICKFIX",
          "1268:     check_quickfix_busy();",
          "1269: # endif",
          "1270: }",
          "1271: #endif",
          "1277:     char_u *",
          "1278: vim_memsave(char_u *p, size_t len)",
          "1279: {",
          "1280:     char_u *ret = alloc(len);",
          "1282:     if (ret != NULL)",
          "1283:  mch_memmove(ret, p, len);",
          "1284:     return ret;",
          "1285: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1325:     return len;",
          "1326: }",
          "1347: #ifndef HAVE_MEMSET",
          "1348:     void *",
          "1349: vim_memset(void *ptr, int c, size_t size)",
          "",
          "[Removed Lines]",
          "1335:     void",
          "1336: vim_free(void *x)",
          "1337: {",
          "1338:     if (x != NULL && !really_exiting)",
          "1339:     {",
          "1340: #ifdef MEM_PROFILE",
          "1341:  mem_pre_free(&x);",
          "1342: #endif",
          "1343:  free(x);",
          "1344:     }",
          "1345: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1366:     return ((x >= 9 && x <= 13) || x == ' ');",
          "1367: }",
          "",
          "[Removed Lines]",
          "1376:     void",
          "1377: ga_clear(garray_T *gap)",
          "1378: {",
          "1379:     vim_free(gap->ga_data);",
          "1380:     ga_init(gap);",
          "1381: }",
          "1386:     void",
          "1387: ga_clear_strings(garray_T *gap)",
          "1388: {",
          "1389:     int  i;",
          "1391:     if (gap->ga_data != NULL)",
          "1392:  for (i = 0; i < gap->ga_len; ++i)",
          "1393:      vim_free(((char_u **)(gap->ga_data))[i]);",
          "1394:     ga_clear(gap);",
          "1395: }",
          "1400:     int",
          "1401: ga_copy_strings(garray_T *from, garray_T *to)",
          "1402: {",
          "1403:     int  i;",
          "1405:     ga_init2(to, sizeof(char_u *), 1);",
          "1406:     if (ga_grow(to, from->ga_len) == FAIL)",
          "1407:  return FAIL;",
          "1409:     for (i = 0; i < from->ga_len; ++i)",
          "1410:     {",
          "1411:  char_u *orig = ((char_u **)from->ga_data)[i];",
          "1412:  char_u *copy;",
          "1414:  if (orig == NULL)",
          "1415:      copy = NULL;",
          "1416:  else",
          "1417:  {",
          "1418:      copy = vim_strsave(orig);",
          "1419:      if (copy == NULL)",
          "1420:      {",
          "1421:   to->ga_len = i;",
          "1422:   ga_clear_strings(to);",
          "1423:   return FAIL;",
          "1424:      }",
          "1425:  }",
          "1426:  ((char_u **)to->ga_data)[i] = copy;",
          "1427:     }",
          "1428:     to->ga_len = from->ga_len;",
          "1429:     return OK;",
          "1430: }",
          "1436:     void",
          "1437: ga_init(garray_T *gap)",
          "1438: {",
          "1439:     gap->ga_data = NULL;",
          "1440:     gap->ga_maxlen = 0;",
          "1441:     gap->ga_len = 0;",
          "1442: }",
          "1444:     void",
          "1445: ga_init2(garray_T *gap, int itemsize, int growsize)",
          "1446: {",
          "1447:     ga_init(gap);",
          "1448:     gap->ga_itemsize = itemsize;",
          "1449:     gap->ga_growsize = growsize;",
          "1450: }",
          "1456:     int",
          "1457: ga_grow(garray_T *gap, int n)",
          "1458: {",
          "1459:     if (gap->ga_maxlen - gap->ga_len < n)",
          "1460:  return ga_grow_inner(gap, n);",
          "1461:     return OK;",
          "1462: }",
          "1464:     int",
          "1465: ga_grow_inner(garray_T *gap, int n)",
          "1466: {",
          "1467:     size_t old_len;",
          "1468:     size_t new_len;",
          "1469:     char_u *pp;",
          "1471:     if (n < gap->ga_growsize)",
          "1472:  n = gap->ga_growsize;",
          "1477:     if (n < gap->ga_len / 2)",
          "1478:  n = gap->ga_len / 2;",
          "1480:     new_len = gap->ga_itemsize * (gap->ga_len + n);",
          "1481:     pp = vim_realloc(gap->ga_data, new_len);",
          "1482:     if (pp == NULL)",
          "1483:  return FAIL;",
          "1484:     old_len = gap->ga_itemsize * gap->ga_maxlen;",
          "1485:     vim_memset(pp + old_len, 0, new_len - old_len);",
          "1486:     gap->ga_maxlen = gap->ga_len + n;",
          "1487:     gap->ga_data = pp;",
          "1488:     return OK;",
          "1489: }",
          "1496:     char_u *",
          "1497: ga_concat_strings(garray_T *gap, char *sep)",
          "1498: {",
          "1499:     int  i;",
          "1500:     int  len = 0;",
          "1501:     int  sep_len = (int)STRLEN(sep);",
          "1502:     char_u *s;",
          "1503:     char_u *p;",
          "1505:     for (i = 0; i < gap->ga_len; ++i)",
          "1506:  len += (int)STRLEN(((char_u **)(gap->ga_data))[i]) + sep_len;",
          "1508:     s = alloc(len + 1);",
          "1509:     if (s != NULL)",
          "1510:     {",
          "1512:  p = s;",
          "1513:  for (i = 0; i < gap->ga_len; ++i)",
          "1514:  {",
          "1515:      if (p != s)",
          "1516:      {",
          "1517:   STRCPY(p, sep);",
          "1518:   p += sep_len;",
          "1519:      }",
          "1520:      STRCPY(p, ((char_u **)(gap->ga_data))[i]);",
          "1521:      p += STRLEN(p);",
          "1522:  }",
          "1523:     }",
          "1524:     return s;",
          "1525: }",
          "1531:     int",
          "1532: ga_add_string(garray_T *gap, char_u *p)",
          "1533: {",
          "1534:     char_u *cp = vim_strsave(p);",
          "1536:     if (cp == NULL)",
          "1537:  return FAIL;",
          "1539:     if (ga_grow(gap, 1) == FAIL)",
          "1540:     {",
          "1541:  vim_free(cp);",
          "1542:  return FAIL;",
          "1543:     }",
          "1544:     ((char_u **)(gap->ga_data))[gap->ga_len++] = cp;",
          "1545:     return OK;",
          "1546: }",
          "1553:     void",
          "1554: ga_concat(garray_T *gap, char_u *s)",
          "1555: {",
          "1556:     int    len;",
          "1558:     if (s == NULL || *s == NUL)",
          "1559:  return;",
          "1560:     len = (int)STRLEN(s);",
          "1561:     if (ga_grow(gap, len) == OK)",
          "1562:     {",
          "1563:  mch_memmove((char *)gap->ga_data + gap->ga_len, s, (size_t)len);",
          "1564:  gap->ga_len += len;",
          "1565:     }",
          "1566: }",
          "1572:     void",
          "1573: ga_concat_len(garray_T *gap, char_u *s, size_t len)",
          "1574: {",
          "1575:     if (s == NULL || *s == NUL)",
          "1576:  return;",
          "1577:     if (ga_grow(gap, (int)len) == OK)",
          "1578:     {",
          "1579:  mch_memmove((char *)gap->ga_data + gap->ga_len, s, len);",
          "1580:  gap->ga_len += (int)len;",
          "1581:     }",
          "1582: }",
          "1587:     void",
          "1588: ga_append(garray_T *gap, int c)",
          "1589: {",
          "1590:     if (ga_grow(gap, 1) == OK)",
          "1591:     {",
          "1593:  ++gap->ga_len;",
          "1594:     }",
          "1595: }",
          "1597: #if (defined(UNIX) && !defined(USE_SYSTEM)) || defined(MSWIN) \\",
          "1598:  || defined(PROTO)",
          "1602:     void",
          "1603: append_ga_line(garray_T *gap)",
          "1604: {",
          "1606:     if (gap->ga_len > 0",
          "1607:      && !curbuf->b_p_bin",
          "1608:      && ((char_u *)gap->ga_data)[gap->ga_len - 1] == CAR)",
          "1609:  --gap->ga_len;",
          "1610:     ga_append(gap, NUL);",
          "1611:     ml_append(curwin->w_cursor.lnum++, gap->ga_data, 0, FALSE);",
          "1612:     gap->ga_len = 0;",
          "1613: }",
          "1614: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "3282:     return OK;",
          "3283: }",
          "3285: #ifndef HAVE_QSORT",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2431:     void",
          "2432: free_username(void)",
          "2433: {",
          "2434:     vim_free(username);",
          "2435: }",
          "",
          "---------------"
        ],
        "src/proto.h||src/proto.h": [
          "File: src/proto.h -> src/proto.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "58: #  include \"crypt.pro\"",
          "59: #  include \"crypt_zip.pro\"",
          "60: # endif",
          "61: # include \"arglist.pro\"",
          "62: # include \"autocmd.pro\"",
          "63: # include \"buffer.pro\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "61: # include \"alloc.pro\"",
          "",
          "---------------"
        ],
        "src/proto/alloc.pro||src/proto/alloc.pro": [
          "File: src/proto/alloc.pro -> src/proto/alloc.pro",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2: void vim_mem_profile_dump(void);",
          "3: int alloc_does_fail(size_t size);",
          "4: void *alloc(size_t size);",
          "5: void *alloc_id(size_t size, alloc_id_T id);",
          "6: void *alloc_clear(size_t size);",
          "7: void *alloc_clear_id(size_t size, alloc_id_T id);",
          "8: void *lalloc_clear(size_t size, int message);",
          "9: void *lalloc(size_t size, int message);",
          "10: void *lalloc_id(size_t size, int message, alloc_id_T id);",
          "11: void *mem_realloc(void *ptr, size_t size);",
          "12: void do_outofmem_msg(size_t size);",
          "13: void free_all_mem(void);",
          "14: char_u *vim_memsave(char_u *p, size_t len);",
          "15: void vim_free(void *x);",
          "16: void ga_clear(garray_T *gap);",
          "17: void ga_clear_strings(garray_T *gap);",
          "18: int ga_copy_strings(garray_T *from, garray_T *to);",
          "19: void ga_init(garray_T *gap);",
          "20: void ga_init2(garray_T *gap, int itemsize, int growsize);",
          "21: int ga_grow(garray_T *gap, int n);",
          "22: int ga_grow_inner(garray_T *gap, int n);",
          "23: char_u *ga_concat_strings(garray_T *gap, char *sep);",
          "24: int ga_add_string(garray_T *gap, char_u *p);",
          "25: void ga_concat(garray_T *gap, char_u *s);",
          "26: void ga_concat_len(garray_T *gap, char_u *s, size_t len);",
          "27: void ga_append(garray_T *gap, int c);",
          "28: void append_ga_line(garray_T *gap);",
          "",
          "---------------"
        ],
        "src/proto/misc2.pro||src/proto/misc2.pro": [
          "File: src/proto/misc2.pro -> src/proto/misc2.pro",
          "--- Hunk 1 ---",
          "[Context before]",
          "19: void check_cursor(void);",
          "20: void adjust_cursor_col(void);",
          "21: int leftcol_changed(void);",
          "35: int copy_option_part(char_u **option, char_u *buf, int maxlen, char *sep_chars);",
          "37: int vim_isspace(int x);",
          "51: int simplify_key(int key, int *modifiers);",
          "52: int handle_x_keys(int key);",
          "53: char_u *get_special_key_name(int c, int modifiers);",
          "",
          "[Removed Lines]",
          "22: void vim_mem_profile_dump(void);",
          "23: int alloc_does_fail(size_t size);",
          "24: void *alloc(size_t size);",
          "25: void *alloc_id(size_t size, alloc_id_T id);",
          "26: void *alloc_clear(size_t size);",
          "27: void *alloc_clear_id(size_t size, alloc_id_T id);",
          "28: void *lalloc_clear(size_t size, int message);",
          "29: void *lalloc(size_t size, int message);",
          "30: void *lalloc_id(size_t size, int message, alloc_id_T id);",
          "31: void *mem_realloc(void *ptr, size_t size);",
          "32: void do_outofmem_msg(size_t size);",
          "33: void free_all_mem(void);",
          "34: char_u *vim_memsave(char_u *p, size_t len);",
          "36: void vim_free(void *x);",
          "38: void ga_clear(garray_T *gap);",
          "39: void ga_clear_strings(garray_T *gap);",
          "40: int ga_copy_strings(garray_T *from, garray_T *to);",
          "41: void ga_init(garray_T *gap);",
          "42: void ga_init2(garray_T *gap, int itemsize, int growsize);",
          "43: int ga_grow(garray_T *gap, int n);",
          "44: int ga_grow_inner(garray_T *gap, int n);",
          "45: char_u *ga_concat_strings(garray_T *gap, char *sep);",
          "46: int ga_add_string(garray_T *gap, char_u *p);",
          "47: void ga_concat(garray_T *gap, char_u *s);",
          "48: void ga_concat_len(garray_T *gap, char_u *s, size_t len);",
          "49: void ga_append(garray_T *gap, int c);",
          "50: void append_ga_line(garray_T *gap);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "75: void update_mouseshape(int shape_idx);",
          "76: int vim_chdir(char_u *new_dir);",
          "77: int get_user_name(char_u *buf, int len);",
          "78: int filewritable(char_u *fname);",
          "79: int get2c(FILE *fd);",
          "80: int get3c(FILE *fd);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "51: void free_username(void);",
          "",
          "---------------"
        ],
        "src/version.c||src/version.c": [
          "File: src/version.c -> src/version.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "756: static int included_patches[] =",
          "759:     3300,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "759:     3301,",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "f62d73933af7830301989eb8162ce94a80e61fbf",
      "candidate_info": {
        "commit_hash": "f62d73933af7830301989eb8162ce94a80e61fbf",
        "repo": "vim/vim",
        "commit_url": "https://github.com/vim/vim/commit/f62d73933af7830301989eb8162ce94a80e61fbf",
        "files": [
          "src/testdir/test_vim9_disassemble.vim",
          "src/version.c",
          "src/vim9compile.c"
        ],
        "message": "patch 8.2.2762: Vim9: function line truncated when compiling\n\nProblem:    Vim9: function line truncated when compiling.\nSolution:   Copy the line before processing it. (closes #8101)",
        "before_after_code_files": [
          "src/testdir/test_vim9_disassemble.vim||src/testdir/test_vim9_disassemble.vim",
          "src/version.c||src/version.c",
          "src/vim9compile.c||src/vim9compile.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/version.c||src/version.c",
            "src/vim9compile.c||src/vim9compile.c"
          ],
          "candidate": [
            "src/version.c||src/version.c",
            "src/vim9compile.c||src/vim9compile.c"
          ]
        }
      },
      "candidate_diff": {
        "src/testdir/test_vim9_disassemble.vim||src/testdir/test_vim9_disassemble.vim": [
          "File: src/testdir/test_vim9_disassemble.vim -> src/testdir/test_vim9_disassemble.vim",
          "--- Hunk 1 ---",
          "[Context before]",
          "386:         res)",
          "387: enddef",
          "389: def s:ScriptFuncUnlet()",
          "390:   g:somevar = \"value\"",
          "391:   unlet g:somevar",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "389: def s:BlobIndexSlice()",
          "390:   var b: blob = 0z112233",
          "391:   echo b[1]",
          "392:   echo b[1 : 2]",
          "393: enddef",
          "395: def Test_disassemble_blob_index_slice()",
          "396:   var res = execute('disass s:BlobIndexSlice')",
          "397:   assert_match('<SNR>\\d*_BlobIndexSlice\\_s*' ..",
          "398:         'var b: blob = 0z112233\\_s*' ..",
          "399:         '\\d PUSHBLOB 0z112233\\_s*' ..",
          "400:         '\\d STORE $0\\_s*' ..",
          "401:         'echo b\\[1\\]\\_s*' ..",
          "402:         '\\d LOAD $0\\_s*' ..",
          "403:         '\\d PUSHNR 1\\_s*' ..",
          "404:         '\\d BLOBINDEX\\_s*' ..",
          "405:         '\\d ECHO 1\\_s*' ..",
          "406:         'echo b\\[1 : 2\\]\\_s*' ..",
          "407:         '\\d LOAD $0\\_s*' ..",
          "408:         '\\d PUSHNR 1\\_s*' ..",
          "409:         '\\d\\+ PUSHNR 2\\_s*' ..",
          "410:         '\\d\\+ BLOBSLICE\\_s*' ..",
          "411:         '\\d\\+ ECHO 1\\_s*' ..",
          "412:         '\\d\\+ RETURN 0',",
          "413:         res)",
          "414: enddef",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2018:         res)",
          "2019: enddef",
          "2022: \" vim: ts=8 sw=2 sts=2 expandtab tw=80 fdm=marker",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2048: def s:EchoMessages()",
          "2049:   echohl ErrorMsg | echom v:exception | echohl NONE",
          "2050: enddef",
          "2052: def Test_disassemble_nextcmd()",
          "2053:   # splitting commands and removing trailing blanks should not change the line",
          "2054:   var res = execute('disass s:EchoMessages')",
          "2055:   assert_match('<SNR>\\d*_EchoMessages\\_s*' ..",
          "2056:         'echohl ErrorMsg | echom v:exception | echohl NONE',",
          "2057:         res)",
          "2058: enddef",
          "",
          "---------------"
        ],
        "src/version.c||src/version.c": [
          "File: src/version.c -> src/version.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "751: static int included_patches[] =",
          "754:     2761,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "754:     2762,",
          "",
          "---------------"
        ],
        "src/vim9compile.c||src/vim9compile.c": [
          "File: src/vim9compile.c -> src/vim9compile.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "8486:  cctx_T     *outer_cctx)",
          "8487: {",
          "8488:     char_u *line = NULL;",
          "8489:     char_u *p;",
          "8490:     char *errormsg = NULL; // error message",
          "8491:     cctx_T cctx;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "8489:     char_u *line_to_free = NULL;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "8647: #endif",
          "8648:   break;",
          "8649:      }",
          "8650:  }",
          "8652:  CLEAR_FIELD(ea);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "8653:      if (line != NULL)",
          "8654:      {",
          "8655:   line = vim_strsave(line);",
          "8656:   vim_free(line_to_free);",
          "8657:   line_to_free = line;",
          "8658:      }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "9095:     if (do_estack_push)",
          "9096:  estack_pop();",
          "9098:     free_imported(&cctx);",
          "9099:     free_locals(&cctx);",
          "9100:     ga_clear(&cctx.ctx_type_stack);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "9107:     vim_free(line_to_free);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "9c23f9bb5fe435b28245ba8ac65aa0ca6b902c04",
      "candidate_info": {
        "commit_hash": "9c23f9bb5fe435b28245ba8ac65aa0ca6b902c04",
        "repo": "vim/vim",
        "commit_url": "https://github.com/vim/vim/commit/9c23f9bb5fe435b28245ba8ac65aa0ca6b902c04",
        "files": [
          "src/proto/userfunc.pro",
          "src/testdir/test_vim9_func.vim",
          "src/userfunc.c",
          "src/version.c",
          "src/vim9compile.c",
          "src/vim9execute.c"
        ],
        "message": "patch 8.2.3902: Vim9: double free with nested :def function\n\nProblem:    Vim9: double free with nested :def function.\nSolution:   Pass \"line_to_free\" from compile_def_function() and make sure\n            cmdlinep is valid.",
        "before_after_code_files": [
          "src/proto/userfunc.pro||src/proto/userfunc.pro",
          "src/testdir/test_vim9_func.vim||src/testdir/test_vim9_func.vim",
          "src/userfunc.c||src/userfunc.c",
          "src/version.c||src/version.c",
          "src/vim9compile.c||src/vim9compile.c",
          "src/vim9execute.c||src/vim9execute.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/proto/userfunc.pro||src/proto/userfunc.pro",
            "src/testdir/test_vim9_func.vim||src/testdir/test_vim9_func.vim",
            "src/userfunc.c||src/userfunc.c",
            "src/version.c||src/version.c",
            "src/vim9compile.c||src/vim9compile.c"
          ],
          "candidate": [
            "src/proto/userfunc.pro||src/proto/userfunc.pro",
            "src/testdir/test_vim9_func.vim||src/testdir/test_vim9_func.vim",
            "src/userfunc.c||src/userfunc.c",
            "src/version.c||src/version.c",
            "src/vim9compile.c||src/vim9compile.c"
          ]
        }
      },
      "candidate_diff": {
        "src/proto/userfunc.pro||src/proto/userfunc.pro": [
          "File: src/proto/userfunc.pro -> src/proto/userfunc.pro",
          "--- Hunk 1 ---",
          "[Context before]",
          "38: char_u *get_scriptlocal_funcname(char_u *funcname);",
          "39: char_u *save_function_name(char_u **name, int *is_global, int skip, int flags, funcdict_T *fudi);",
          "40: void list_functions(regmatch_T *regmatch);",
          "42: void ex_function(exarg_T *eap);",
          "43: void ex_defcompile(exarg_T *eap);",
          "44: int eval_fname_script(char_u *p);",
          "",
          "[Removed Lines]",
          "41: ufunc_T *define_function(exarg_T *eap, char_u *name_arg);",
          "",
          "[Added Lines]",
          "41: ufunc_T *define_function(exarg_T *eap, char_u *name_arg, char_u **line_to_free);",
          "",
          "---------------"
        ],
        "src/testdir/test_vim9_func.vim||src/testdir/test_vim9_func.vim": [
          "File: src/testdir/test_vim9_func.vim -> src/testdir/test_vim9_func.vim",
          "--- Hunk 1 ---",
          "[Context before]",
          "1669:   assert_fails('FuncWithForwardCall()', 'E1096:', '', 1, 'FuncWithForwardCall')",
          "1670: enddef",
          "1672: def Test_return_type_wrong()",
          "1673:   CheckScriptFailure([",
          "1674:         'def Func(): number',",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1672: def Test_nested_functin_with_nextcmd()",
          "1673:   var lines =<< trim END",
          "1674:       vim9script",
          "1675:       # Define an outer function",
          "1676:       def FirstFunction()",
          "1677:         # Define an inner function",
          "1678:         def SecondFunction()",
          "1679:           # the function has a body, a double free is detected.",
          "1680:           AAAAA",
          "1682:          # enddef followed by | or } followed by # one or more characters",
          "1683:          enddef|BBBB",
          "1684:       enddef",
          "1686:       # Compile all functions",
          "1687:       defcompile",
          "1688:   END",
          "1689:   CheckScriptFailure(lines, 'E476: Invalid command: AAAAA')",
          "1690: enddef",
          "",
          "---------------"
        ],
        "src/userfunc.c||src/userfunc.c": [
          "File: src/userfunc.c -> src/userfunc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "720:  }",
          "721:  else",
          "722:  {",
          "724:      if (eap->getline == NULL)",
          "725:   theline = getcmdline(':', 0L, indent, getline_options);",
          "726:      else",
          "727:   theline = eap->getline(':', eap->cookie, indent,",
          "728:              getline_options);",
          "730:  }",
          "731:  if (KeyTyped)",
          "",
          "[Removed Lines]",
          "723:      vim_free(*line_to_free);",
          "",
          "[Added Lines]",
          "728:      if (*eap->cmdlinep == *line_to_free)",
          "730:      vim_free(*line_to_free);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "839:    eap->nextcmd = nextcmd;",
          "841:    {",
          "842:        vim_free(*eap->cmdlinep);",
          "",
          "[Removed Lines]",
          "840:    if (*line_to_free != NULL)",
          "",
          "[Added Lines]",
          "842:    if (*line_to_free != NULL",
          "843:          && *eap->cmdlinep != *line_to_free)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1161:  }",
          "1162:  if (ga_grow(gap, 1) == FAIL || ga_grow(freegap, 1) == FAIL)",
          "1163:      goto erret;",
          "1166:      last = cmdline;",
          "1167:  else",
          "",
          "[Removed Lines]",
          "1164:  if (cmdline != NULL)",
          "",
          "[Added Lines]",
          "1167:  if (eap.nextcmd != NULL)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1175:  ((char_u **)freegap->ga_data)[freegap->ga_len++] = pnl;",
          "1176:     }",
          "1179:     {",
          "1180:  garray_T *tfgap = &evalarg->eval_tofree_ga;",
          "",
          "[Removed Lines]",
          "1178:     if (cmdline != NULL)",
          "",
          "[Added Lines]",
          "1181:     if (eap.nextcmd != NULL)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1187:  {",
          "1188:      ((char_u **)(tfgap->ga_data))[tfgap->ga_len++] = cmdline;",
          "1189:      evalarg->eval_using_cmdline = TRUE;",
          "1190:  }",
          "1191:     }",
          "1192:     else",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1193:      if (cmdline == line_to_free)",
          "1194:   line_to_free = NULL;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "3990:     ufunc_T *",
          "3992: {",
          "3994:     int  j;",
          "3995:     int  c;",
          "3996:     int  saved_did_emsg;",
          "",
          "[Removed Lines]",
          "3991: define_function(exarg_T *eap, char_u *name_arg)",
          "3993:     char_u *line_to_free = NULL;",
          "",
          "[Added Lines]",
          "3996: define_function(exarg_T *eap, char_u *name_arg, char_u **line_to_free)",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "4258:     if (get_function_args(&p, ')', &newargs,",
          "4259:    eap->cmdidx == CMD_def ? &argtypes : NULL, FALSE,",
          "4260:     NULL, &varargs, &default_args, eap->skip,",
          "4262:  goto errret_2;",
          "4263:     whitep = p;",
          "",
          "[Removed Lines]",
          "4261:     eap, &line_to_free) == FAIL)",
          "",
          "[Added Lines]",
          "4265:     eap, line_to_free) == FAIL)",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "4372:      || eap->skip)",
          "4373:  goto erret;",
          "",
          "[Removed Lines]",
          "4371:     if (get_function_body(eap, &newlines, line_arg, &line_to_free) == FAIL",
          "",
          "[Added Lines]",
          "4375:     if (get_function_body(eap, &newlines, line_arg, line_to_free) == FAIL",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "4660:     }",
          "4661: ret_free:",
          "4662:     ga_clear_strings(&argtypes);",
          "4664:     vim_free(fudi.fd_newkey);",
          "4665:     if (name != name_arg)",
          "4666:  vim_free(name);",
          "",
          "[Removed Lines]",
          "4663:     vim_free(line_to_free);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "4676:     void",
          "4677: ex_function(exarg_T *eap)",
          "4678: {",
          "4680: }",
          "",
          "[Removed Lines]",
          "4679:     (void)define_function(eap, NULL);",
          "",
          "[Added Lines]",
          "4682:     char_u *line_to_free = NULL;",
          "4684:     (void)define_function(eap, NULL, &line_to_free);",
          "4685:     vim_free(line_to_free);",
          "",
          "---------------"
        ],
        "src/version.c||src/version.c": [
          "File: src/version.c -> src/version.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "750: static int included_patches[] =",
          "753:     3901,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "753:     3902,",
          "",
          "---------------"
        ],
        "src/vim9compile.c||src/vim9compile.c": [
          "File: src/vim9compile.c -> src/vim9compile.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "814:     static char_u *",
          "816: {",
          "817:     int  is_global = *eap->arg == 'g' && eap->arg[1] == ':';",
          "818:     char_u *name_start = eap->arg;",
          "819:     char_u *name_end = to_name_end(eap->arg, TRUE);",
          "820:     char_u *lambda_name;",
          "821:     ufunc_T *ufunc;",
          "822:     int  r = FAIL;",
          "",
          "[Removed Lines]",
          "815: compile_nested_function(exarg_T *eap, cctx_T *cctx)",
          "",
          "[Added Lines]",
          "815: compile_nested_function(exarg_T *eap, cctx_T *cctx, char_u **line_to_free)",
          "820:     int  off;",
          "821:     char_u *func_name;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "866:     lambda_name = vim_strsave(get_lambda_name());",
          "867:     if (lambda_name == NULL)",
          "868:  return NULL;",
          "871:     if (ufunc == NULL)",
          "872:     {",
          "",
          "[Removed Lines]",
          "869:     ufunc = define_function(eap, lambda_name);",
          "",
          "[Added Lines]",
          "873:     off = is_global ? 2 : 0;",
          "874:     func_name = vim_strnsave(name_start + off, name_end - name_start - off);",
          "875:     if (func_name == NULL)",
          "876:     {",
          "877:  r = FAIL;",
          "878:  goto theend;",
          "879:     }",
          "881:     ufunc = define_function(eap, lambda_name, line_to_free);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "912:     if (is_global)",
          "913:     {",
          "924:     }",
          "925:     else",
          "926:     {",
          "929:           TRUE, ufunc->uf_func_type);",
          "931:  if (lvar == NULL)",
          "",
          "[Removed Lines]",
          "914:  char_u *func_name = vim_strnsave(name_start + 2,",
          "915:           name_end - name_start - 2);",
          "917:  if (func_name == NULL)",
          "918:      r = FAIL;",
          "919:  else",
          "920:  {",
          "921:      r = generate_NEWFUNC(cctx, lambda_name, func_name);",
          "922:      lambda_name = NULL;",
          "923:  }",
          "928:  lvar_T *lvar = reserve_local(cctx, name_start, name_end - name_start,",
          "",
          "[Added Lines]",
          "926:  r = generate_NEWFUNC(cctx, lambda_name, func_name);",
          "927:  func_name = NULL;",
          "928:  lambda_name = NULL;",
          "933:  lvar_T *lvar = reserve_local(cctx, func_name, name_end - name_start,",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "938: theend:",
          "939:     vim_free(lambda_name);",
          "940:     return r == FAIL ? NULL : (char_u *)\"\";",
          "941: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "945:     vim_free(func_name);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2861:      case CMD_def:",
          "2862:      case CMD_function:",
          "2863:       ea.arg = p;",
          "2865:       break;",
          "2867:      case CMD_return:",
          "",
          "[Removed Lines]",
          "2864:       line = compile_nested_function(&ea, &cctx);",
          "",
          "[Added Lines]",
          "2870:       line = compile_nested_function(&ea, &cctx, &line_to_free);",
          "",
          "---------------"
        ],
        "src/vim9execute.c||src/vim9execute.c": [
          "File: src/vim9execute.c -> src/vim9execute.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3345:   else",
          "3346:   {",
          "3347:       exarg_T ea;",
          "3349:       CLEAR_FIELD(ea);",
          "3350:       ea.cmd = ea.arg = iptr->isn_arg.string;",
          "3352:   }",
          "3353:   break;",
          "",
          "[Removed Lines]",
          "3351:       define_function(&ea, NULL);",
          "",
          "[Added Lines]",
          "3348:       char_u  *line_to_free = NULL;",
          "3352:       define_function(&ea, NULL, &line_to_free);",
          "3353:       vim_free(line_to_free);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "73b8b0ae3acac220e823076f8ca1c14524ed96dd",
      "candidate_info": {
        "commit_hash": "73b8b0ae3acac220e823076f8ca1c14524ed96dd",
        "repo": "vim/vim",
        "commit_url": "https://github.com/vim/vim/commit/73b8b0ae3acac220e823076f8ca1c14524ed96dd",
        "files": [
          "runtime/doc/autocmd.txt",
          "runtime/doc/map.txt",
          "src/autocmd.c",
          "src/ex_docmd.c",
          "src/proto/autocmd.pro",
          "src/proto/usercmd.pro",
          "src/testdir/test_autocmd.vim",
          "src/usercmd.c",
          "src/version.c",
          "src/vim.h"
        ],
        "message": "patch 8.2.3268: cannot use a block with :autocmd like with :command\n\nProblem:    Cannot use a block with :autocmd like with :command.\nSolution:   Add support for a {} block after :autocmd. (closes #8620)",
        "before_after_code_files": [
          "src/autocmd.c||src/autocmd.c",
          "src/ex_docmd.c||src/ex_docmd.c",
          "src/proto/autocmd.pro||src/proto/autocmd.pro",
          "src/proto/usercmd.pro||src/proto/usercmd.pro",
          "src/testdir/test_autocmd.vim||src/testdir/test_autocmd.vim",
          "src/usercmd.c||src/usercmd.c",
          "src/version.c||src/version.c",
          "src/vim.h||src/vim.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/usercmd.c||src/usercmd.c",
            "src/version.c||src/version.c"
          ],
          "candidate": [
            "src/usercmd.c||src/usercmd.c",
            "src/version.c||src/version.c"
          ]
        }
      },
      "candidate_diff": {
        "src/autocmd.c||src/autocmd.c": [
          "File: src/autocmd.c -> src/autocmd.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "259: static char_u *event_nr2name(event_T event);",
          "260: static int au_get_grouparg(char_u **argp);",
          "262: static int apply_autocmds_group(event_T event, char_u *fname, char_u *fname_io, int force, int group, buf_T *buf, exarg_T *eap);",
          "263: static void auto_next_pat(AutoPatCmd *apc, int stop_at_last);",
          "264: static int au_find_group(char_u *name);",
          "",
          "[Removed Lines]",
          "261: static int do_autocmd_event(event_T event, char_u *pat, int once, int nested, char_u *cmd, int forceit, int group);",
          "",
          "[Added Lines]",
          "261: static int do_autocmd_event(event_T event, char_u *pat, int once, int nested, char_u *cmd, int forceit, int group, int flags);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "616:     for (current_augroup = -1; current_augroup < augroups.ga_len;",
          "617:            ++current_augroup)",
          "620:     for (i = 0; i < augroups.ga_len; ++i)",
          "621:     {",
          "",
          "[Removed Lines]",
          "618:  do_autocmd((char_u *)\"\", TRUE);",
          "",
          "[Added Lines]",
          "618:  do_autocmd(NULL, (char_u *)\"\", TRUE);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "827:     void",
          "829: {",
          "830:     char_u *arg = arg_in;",
          "831:     char_u *pat;",
          "832:     char_u *envpat = NULL;",
          "833:     char_u *cmd;",
          "834:     event_T event;",
          "836:     int  nested = FALSE;",
          "837:     int  once = FALSE;",
          "838:     int  group;",
          "839:     int  i;",
          "841:     if (*arg == '|')",
          "842:     {",
          "",
          "[Removed Lines]",
          "828: do_autocmd(char_u *arg_in, int forceit)",
          "835:     int  need_free = FALSE;",
          "",
          "[Added Lines]",
          "829: do_autocmd(exarg_T *eap, char_u *arg_in, int forceit)",
          "835:     int  cmd_need_free = FALSE;",
          "837:     char_u *tofree = NULL;",
          "842:     int  flags = 0;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "936:  if (*cmd != NUL)",
          "937:  {",
          "938:      cmd = expand_sfile(cmd);",
          "939:      if (cmd == NULL)     // some error",
          "940:   return;",
          "942:  }",
          "943:     }",
          "",
          "[Removed Lines]",
          "941:      need_free = TRUE;",
          "",
          "[Added Lines]",
          "941:      if (eap != NULL)",
          "943:   cmd = may_get_cmd_block(eap, cmd, &tofree, &flags);",
          "948:      cmd_need_free = TRUE;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "962:      for (event = (event_T)0; (int)event < (int)NUM_EVENTS;",
          "963:           event = (event_T)((int)event + 1))",
          "964:   if (do_autocmd_event(event, pat,",
          "966:       break;",
          "967:     }",
          "968:     else",
          "969:     {",
          "970:  while (*arg && *arg != '|' && !VIM_ISWHITE(*arg))",
          "971:      if (do_autocmd_event(event_name2nr(arg, &arg), pat,",
          "973:   break;",
          "974:     }",
          "977:  vim_free(cmd);",
          "978:     vim_free(envpat);",
          "979: }",
          "",
          "[Removed Lines]",
          "965:         once, nested, cmd, forceit, group) == FAIL)",
          "972:      once, nested, cmd, forceit, group) == FAIL)",
          "976:     if (need_free)",
          "",
          "[Added Lines]",
          "972:         once, nested, cmd, forceit, group, flags) == FAIL)",
          "979:      once, nested, cmd, forceit, group, flags) == FAIL)",
          "983:     if (cmd_need_free)",
          "985:     vim_free(tofree);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1024:     int  nested,",
          "1025:     char_u *cmd,",
          "1026:     int  forceit,",
          "1028: {",
          "1029:     AutoPat *ap;",
          "1030:     AutoPat **prev_ap;",
          "",
          "[Removed Lines]",
          "1027:     int  group)",
          "",
          "[Added Lines]",
          "1035:     int  group,",
          "1036:     int  flags)",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1251:   return FAIL;",
          "1252:      ac->cmd = vim_strsave(cmd);",
          "1253:      ac->script_ctx = current_sctx;",
          "1254: #ifdef FEAT_EVAL",
          "1255:      ac->script_ctx.sc_lnum += SOURCING_LNUM;",
          "1256: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1263:      if (flags & UC_VIM9)",
          "1264:   ac->script_ctx.sc_version = SCRIPT_VERSION_VIM9;",
          "",
          "---------------"
        ],
        "src/ex_docmd.c||src/ex_docmd.c": [
          "File: src/ex_docmd.c -> src/ex_docmd.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "5203:        _(e_command_not_allowed_from_vimrc_in_current_dir_or_tag_search);",
          "5204:     }",
          "5205:     else if (eap->cmdidx == CMD_autocmd)",
          "5207:     else",
          "5208:  do_augroup(eap->arg, eap->forceit);",
          "5209: }",
          "",
          "[Removed Lines]",
          "5206:  do_autocmd(eap->arg, eap->forceit);",
          "",
          "[Added Lines]",
          "5206:  do_autocmd(eap, eap->arg, eap->forceit);",
          "",
          "---------------"
        ],
        "src/proto/autocmd.pro||src/proto/autocmd.pro": [
          "File: src/proto/autocmd.pro -> src/proto/autocmd.pro",
          "--- Hunk 1 ---",
          "[Context before]",
          "6: int check_ei(void);",
          "7: char_u *au_event_disable(char *what);",
          "8: void au_event_restore(char_u *old_ei);",
          "10: int do_doautocmd(char_u *arg, int do_msg, int *did_something);",
          "11: void ex_doautoall(exarg_T *eap);",
          "12: int check_nomodeline(char_u **argp);",
          "",
          "[Removed Lines]",
          "9: void do_autocmd(char_u *arg_in, int forceit);",
          "",
          "[Added Lines]",
          "9: void do_autocmd(exarg_T *eap, char_u *arg_in, int forceit);",
          "",
          "---------------"
        ],
        "src/proto/usercmd.pro||src/proto/usercmd.pro": [
          "File: src/proto/usercmd.pro -> src/proto/usercmd.pro",
          "--- Hunk 1 ---",
          "[Context before]",
          "10: int cmdcomplete_str_to_type(char_u *complete_str);",
          "11: char *uc_fun_cmd(void);",
          "12: int parse_compl_arg(char_u *value, int vallen, int *complp, long *argt, char_u **compl_arg);",
          "13: void ex_command(exarg_T *eap);",
          "14: void ex_comclear(exarg_T *eap);",
          "15: void uc_clear(garray_T *gap);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "13: char_u *may_get_cmd_block(exarg_T *eap, char_u *p, char_u **tofree, int *flags);",
          "",
          "---------------"
        ],
        "src/testdir/test_autocmd.vim||src/testdir/test_autocmd.vim": [
          "File: src/testdir/test_autocmd.vim -> src/testdir/test_autocmd.vim",
          "--- Hunk 1 ---",
          "[Context before]",
          "2810:   augroup END",
          "2811: endfunc",
          "2814: \" vim: shiftwidth=2 sts=2 expandtab",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2813: func Test_autocmd_with_block()",
          "2814:   augroup block_testing",
          "2815:     au BufReadPost *.xml {",
          "2816:             setlocal matchpairs+=<:>",
          "2817:             /<start",
          "2818:           }",
          "2819:   augroup END",
          "2821:   let expected = \"\\n--- Autocommands ---\\nblock_testing  BufRead\\n    *.xml     {^@            setlocal matchpairs+=<:>^@            /<start^@          }\"",
          "2822:   call assert_equal(expected, execute('au BufReadPost *.xml'))",
          "2824:   augroup block_testing",
          "2825:     au!",
          "2826:   augroup END",
          "2827: endfunc",
          "",
          "---------------"
        ],
        "src/usercmd.c||src/usercmd.c": [
          "File: src/usercmd.c -> src/usercmd.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "114:     {ADDR_NONE, NULL, NULL}",
          "115: };",
          "",
          "[Removed Lines]",
          "117: #define UC_BUFFER 1 // -buffer: local to current buffer",
          "118: #define UC_VIM9  2 // {} argument: Vim9 syntax.",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "974:     return FAIL;",
          "975: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "978:     char_u *",
          "979: may_get_cmd_block(exarg_T *eap, char_u *p, char_u **tofree, int *flags)",
          "980: {",
          "981:     char_u *retp = p;",
          "983:     if (*p == '{' && ends_excmd2(eap->arg, skipwhite(p + 1))",
          "984:              && eap->getline != NULL)",
          "985:     {",
          "986:  garray_T ga;",
          "987:  char_u *line = NULL;",
          "989:  ga_init2(&ga, sizeof(char_u *), 10);",
          "990:  if (ga_add_string(&ga, p) == FAIL)",
          "991:      return retp;",
          "995:  for (;;)",
          "996:  {",
          "997:      vim_free(line);",
          "998:      if ((line = eap->getline(':', eap->cookie,",
          "999:            0, GETLINE_CONCAT_CONTBAR)) == NULL)",
          "1000:      {",
          "1001:   emsg(_(e_missing_rcurly));",
          "1002:   break;",
          "1003:      }",
          "1004:      if (ga_add_string(&ga, line) == FAIL)",
          "1005:   break;",
          "1006:      if (*skipwhite(line) == '}')",
          "1007:   break;",
          "1008:  }",
          "1009:  vim_free(line);",
          "1010:  retp = *tofree = ga_concat_strings(&ga, \"\\n\");",
          "1011:  ga_clear_strings(&ga);",
          "1013:     }",
          "1014:     return retp;",
          "1015: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1043:     {",
          "1044:  char_u *tofree = NULL;",
          "1079:  uc_add_command(name, end - name, p, argt, def, flags, compl, compl_arg,",
          "1080:         addr_type_arg, eap->forceit);",
          "",
          "[Removed Lines]",
          "1046:  if (*p == '{' && ends_excmd2(eap->arg, skipwhite(p + 1))",
          "1047:              && eap->getline != NULL)",
          "1048:  {",
          "1049:      garray_T ga;",
          "1050:      char_u *line = NULL;",
          "1052:      ga_init2(&ga, sizeof(char_u *), 10);",
          "1053:      if (ga_add_string(&ga, p) == FAIL)",
          "1054:   return;",
          "1059:      for (;;)",
          "1060:      {",
          "1061:   vim_free(line);",
          "1062:   if ((line = eap->getline(':', eap->cookie,",
          "1063:         0, GETLINE_CONCAT_CONTBAR)) == NULL)",
          "1064:   {",
          "1065:       emsg(_(e_missing_rcurly));",
          "1066:       break;",
          "1067:   }",
          "1068:   if (ga_add_string(&ga, line) == FAIL)",
          "1069:       break;",
          "1070:   if (*skipwhite(line) == '}')",
          "1071:       break;",
          "1072:      }",
          "1073:      vim_free(line);",
          "1074:      p = tofree = ga_concat_strings(&ga, \"\\n\");",
          "1075:      ga_clear_strings(&ga);",
          "1076:      flags |= UC_VIM9;",
          "1077:  }",
          "",
          "[Added Lines]",
          "1086:  p = may_get_cmd_block(eap, p, &tofree, &flags);",
          "",
          "---------------"
        ],
        "src/version.c||src/version.c": [
          "File: src/version.c -> src/version.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "756: static int included_patches[] =",
          "759:     3267,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "759:     3268,",
          "",
          "---------------"
        ],
        "src/vim.h||src/vim.h": [
          "File: src/vim.h -> src/vim.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "2740: #define ETYPE_ARG_UNKNOWN 1",
          "2742: #endif // VIM__H",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2743: #define UC_BUFFER 1 // -buffer: local to current buffer",
          "2744: #define UC_VIM9  2 // {} argument: Vim9 syntax.",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "67da21a14726b106b49744f9773eba132fedd5f2",
      "candidate_info": {
        "commit_hash": "67da21a14726b106b49744f9773eba132fedd5f2",
        "repo": "vim/vim",
        "commit_url": "https://github.com/vim/vim/commit/67da21a14726b106b49744f9773eba132fedd5f2",
        "files": [
          "src/eval.c",
          "src/globals.h",
          "src/structs.h",
          "src/userfunc.c",
          "src/version.c",
          "src/vim9compile.c"
        ],
        "message": "patch 8.2.2636: memory leak when compiling inline function\n\nProblem:    Memory leak when compiling inline function.\nSolution:   Free the prefetched line.",
        "before_after_code_files": [
          "src/eval.c||src/eval.c",
          "src/globals.h||src/globals.h",
          "src/structs.h||src/structs.h",
          "src/userfunc.c||src/userfunc.c",
          "src/version.c||src/version.c",
          "src/vim9compile.c||src/vim9compile.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/userfunc.c||src/userfunc.c",
            "src/version.c||src/version.c",
            "src/vim9compile.c||src/vim9compile.c"
          ],
          "candidate": [
            "src/userfunc.c||src/userfunc.c",
            "src/version.c||src/version.c",
            "src/vim9compile.c||src/vim9compile.c"
          ]
        }
      },
      "candidate_diff": {
        "src/eval.c||src/eval.c": [
          "File: src/eval.c -> src/eval.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2179:      evalarg->eval_tofree = NULL;",
          "2180:  }",
          "2184:     }",
          "2185: }",
          "",
          "[Removed Lines]",
          "2182:  vim_free(evalarg->eval_tofree_lambda);",
          "2183:  evalarg->eval_tofree_lambda = NULL;",
          "",
          "[Added Lines]",
          "2182:  VIM_CLEAR(evalarg->eval_tofree_cmdline);",
          "2183:  VIM_CLEAR(evalarg->eval_tofree_lambda);",
          "",
          "---------------"
        ],
        "src/globals.h||src/globals.h": [
          "File: src/globals.h -> src/globals.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "1899: EXTERN evalarg_T EVALARG_EVALUATE",
          "1900: # ifdef DO_INIT",
          "1902: # endif",
          "1903:  ;",
          "1904: #endif",
          "",
          "[Removed Lines]",
          "1901:  = {EVAL_EVALUATE, 0, NULL, NULL, NULL, {0, 0, 0, 0, NULL}, NULL, NULL}",
          "",
          "[Added Lines]",
          "1901:  = {EVAL_EVALUATE, 0, NULL, NULL, NULL, {0, 0, 0, 0, NULL},",
          "1902:              NULL, NULL, NULL}",
          "",
          "---------------"
        ],
        "src/structs.h||src/structs.h": [
          "File: src/structs.h -> src/structs.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "1883:     char_u *eval_tofree;",
          "1886:     char_u *eval_tofree_lambda;",
          "1887: } evalarg_T;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1886:     char_u *eval_tofree_cmdline;",
          "",
          "---------------"
        ],
        "src/userfunc.c||src/userfunc.c": [
          "File: src/userfunc.c -> src/userfunc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "971:     ga_init2(&newlines, (int)sizeof(char_u *), 10);",
          "972:     if (get_function_body(&eap, &newlines, NULL, &line_to_free) == FAIL)",
          "973:  goto erret;",
          "974:     if (cmdline != NULL)",
          "975:     {",
          "984:     }",
          "985:     else",
          "",
          "[Removed Lines]",
          "978:  if (evalarg->eval_cctx == NULL)",
          "979:  {",
          "981:      vim_free(evalarg->eval_tofree_lambda);",
          "982:      evalarg->eval_tofree_lambda = cmdline;",
          "983:  }",
          "",
          "[Added Lines]",
          "973:     {",
          "974:  vim_free(cmdline);",
          "976:     }",
          "983:  vim_free(evalarg->eval_tofree_cmdline);",
          "984:  evalarg->eval_tofree_cmdline = cmdline;",
          "",
          "---------------"
        ],
        "src/version.c||src/version.c": [
          "File: src/version.c -> src/version.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "751: static int included_patches[] =",
          "754:     2635,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "754:     2636,",
          "",
          "---------------"
        ],
        "src/vim9compile.c||src/vim9compile.c": [
          "File: src/vim9compile.c -> src/vim9compile.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3203:     compile_def_function(ufunc, TRUE, PROFILING(ufunc), cctx);",
          "3205:     clear_evalarg(&evalarg, NULL);",
          "3207:     if (ufunc->uf_def_status == UF_COMPILED)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3207:     if (evalarg.eval_tofree_cmdline != NULL)",
          "3208:     {",
          "3209:  size_t off = *arg - evalarg.eval_tofree_cmdline;",
          "3212:           + off;",
          "3213:     }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
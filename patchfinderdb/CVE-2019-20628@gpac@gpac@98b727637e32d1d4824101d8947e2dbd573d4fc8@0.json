{
  "cve_id": "CVE-2019-20628",
  "cve_desc": "An issue was discovered in libgpac.a in GPAC before 0.8.0, as demonstrated by MP4Box. It contains a Use-After-Free vulnerability in gf_m2ts_process_pmt in media_tools/mpegts.c that can cause a denial of service via a crafted MP4 file.",
  "repo": "gpac/gpac",
  "patch_hash": "98b727637e32d1d4824101d8947e2dbd573d4fc8",
  "patch_info": {
    "commit_hash": "98b727637e32d1d4824101d8947e2dbd573d4fc8",
    "repo": "gpac/gpac",
    "commit_url": "https://github.com/gpac/gpac/commit/98b727637e32d1d4824101d8947e2dbd573d4fc8",
    "files": [
      "src/media_tools/mpegts.c"
    ],
    "message": "be stricter in PAT processing - cf #1269",
    "before_after_code_files": [
      "src/media_tools/mpegts.c||src/media_tools/mpegts.c"
    ]
  },
  "patch_diff": {
    "src/media_tools/mpegts.c||src/media_tools/mpegts.c": [
      "File: src/media_tools/mpegts.c -> src/media_tools/mpegts.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1667:    if (!ts->nit) {",
      "1668:     ts->nit = gf_m2ts_section_filter_new(gf_m2ts_process_nit, 0);",
      "1669:    }",
      "1671:    GF_SAFEALLOC(prog, GF_M2TS_Program);",
      "1672:    if (!prog) {",
      "1673:     GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Fail to allocate program for pid %d\\n\", pid));",
      "",
      "[Removed Lines]",
      "1670:   } else {",
      "",
      "[Added Lines]",
      "1670:   } else if (!pid) {",
      "1671:    GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Broken PAT found reserved PID 0, ignoring\\n\", pid));",
      "1672:   } else if (! ts->ess[pid]) {",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "1ab4860609f2e7a35634930571e7d0531297e090",
      "candidate_info": {
        "commit_hash": "1ab4860609f2e7a35634930571e7d0531297e090",
        "repo": "gpac/gpac",
        "commit_url": "https://github.com/gpac/gpac/commit/1ab4860609f2e7a35634930571e7d0531297e090",
        "files": [
          "src/media_tools/mpegts.c"
        ],
        "message": "fixed potential crash on PMT IOD parse - cf #1268 #1269",
        "before_after_code_files": [
          "src/media_tools/mpegts.c||src/media_tools/mpegts.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [
            "src/media_tools/mpegts.c||src/media_tools/mpegts.c"
          ],
          "candidate": [
            "src/media_tools/mpegts.c||src/media_tools/mpegts.c"
          ]
        }
      },
      "candidate_diff": {
        "src/media_tools/mpegts.c||src/media_tools/mpegts.c": [
          "File: src/media_tools/mpegts.c -> src/media_tools/mpegts.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1152:  pmt->program->pcr_pid = ((data[0] & 0x1f) << 8) | data[1];",
          "1154:  info_length = ((data[2]&0xf)<<8) | data[3];",
          "1157:   u8 tag, len;",
          "1158:   u32 first_loop_len = 0;",
          "",
          "[Removed Lines]",
          "1155:  if (info_length != 0) {",
          "",
          "[Added Lines]",
          "1155:  if (info_length + 4 > data_size) {",
          "1156:   GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Broken PMT first loop, %d bytes avail but first loop size %d\\n\", data_size, info_length));",
          "1157:   return;",
          "1158:  } else if (info_length != 0) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1160:   len = data[5];",
          "1161:   while (info_length > first_loop_len) {",
          "1162:    if (tag == GF_M2TS_MPEG4_IOD_DESCRIPTOR) {",
          "1176:      }",
          "1177:     }",
          "1178:    } else if (tag == GF_M2TS_METADATA_POINTER_DESCRIPTOR) {",
          "1179:     GF_BitStream *metadatapd_bs;",
          "",
          "[Removed Lines]",
          "1163:     u32 size;",
          "1164:     GF_BitStream *iod_bs;",
          "1165:     iod_bs = gf_bs_new((char *)data+8, len-2, GF_BITSTREAM_READ);",
          "1166:     if (pmt->program->pmt_iod) gf_odf_desc_del((GF_Descriptor *)pmt->program->pmt_iod);",
          "1167:     e = gf_odf_parse_descriptor(iod_bs , (GF_Descriptor **) &pmt->program->pmt_iod, &size);",
          "1168:     gf_bs_del(iod_bs );",
          "1169:     if (e==GF_OK) {",
          "1171:      if (pmt->program->pmt_iod) pmt->program->pmt_iod->ServiceID = pmt->program->number;",
          "1173:      if (!gf_list_count(pmt->program->pmt_iod->ESDescriptors)) {",
          "1174:       gf_odf_desc_del((GF_Descriptor *)pmt->program->pmt_iod);",
          "1175:       pmt->program->pmt_iod = NULL;",
          "",
          "[Added Lines]",
          "1166:     if ((len>2) && (len - 2 <= info_length)) {",
          "1167:      u32 size;",
          "1168:      GF_BitStream *iod_bs;",
          "1169:      iod_bs = gf_bs_new((char *)data+8, len-2, GF_BITSTREAM_READ);",
          "1170:      if (pmt->program->pmt_iod) gf_odf_desc_del((GF_Descriptor *)pmt->program->pmt_iod);",
          "1171:      e = gf_odf_parse_descriptor(iod_bs , (GF_Descriptor **) &pmt->program->pmt_iod, &size);",
          "1172:      gf_bs_del(iod_bs );",
          "1173:      if (e==GF_OK) {",
          "1175:       if (pmt->program->pmt_iod) pmt->program->pmt_iod->ServiceID = pmt->program->number;",
          "1177:       if (!gf_list_count(pmt->program->pmt_iod->ESDescriptors)) {",
          "1178:        gf_odf_desc_del((GF_Descriptor *)pmt->program->pmt_iod);",
          "1179:        pmt->program->pmt_iod = NULL;",
          "1180:       }",
          "1182:     } else {",
          "1183:      GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Broken IOD! len %d less than 2 bytes to declare IOD\\n\", len));",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2016-4440",
  "cve_desc": "arch/x86/kvm/vmx.c in the Linux kernel through 4.6.3 mishandles the APICv on/off state, which allows guest OS users to obtain direct APIC MSR access on the host OS, and consequently cause a denial of service (host OS crash) or possibly execute arbitrary code on the host OS, via x2APIC mode.",
  "repo": "torvalds/linux",
  "patch_hash": "3ce424e45411cf5a13105e0386b6ecf6eeb4f66f",
  "patch_info": {
    "commit_hash": "3ce424e45411cf5a13105e0386b6ecf6eeb4f66f",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/3ce424e45411cf5a13105e0386b6ecf6eeb4f66f",
    "files": [
      "arch/x86/kvm/vmx.c"
    ],
    "message": "kvm:vmx: more complete state update on APICv on/off\n\nThe function to update APICv on/off state (in particular, to deactivate\nit when enabling Hyper-V SynIC) is incomplete: it doesn't adjust\nAPICv-related fields among secondary processor-based VM-execution\ncontrols.  As a result, Windows 2012 guests get stuck when SynIC-based\nauto-EOI interrupt intersected with e.g. an IPI in the guest.\n\nIn addition, the MSR intercept bitmap isn't updated every time \"virtualize\nx2APIC mode\" is toggled.  This path can only be triggered by a malicious\nguest, because Windows didn't use x2APIC but rather their own synthetic\nAPIC access MSRs; however a guest running in a SynIC-enabled VM could\nswitch to x2APIC and thus obtain direct access to host APIC MSRs\n(CVE-2016-4440).\n\nThe patch fixes those omissions.\n\nSigned-off-by: Roman Kagan <rkagan@virtuozzo.com>\nReported-by: Steve Rutherford <srutherford@google.com>\nReported-by: Yang Zhang <yang.zhang.wz@gmail.com>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>",
    "before_after_code_files": [
      "arch/x86/kvm/vmx.c||arch/x86/kvm/vmx.c"
    ]
  },
  "patch_diff": {
    "arch/x86/kvm/vmx.c||arch/x86/kvm/vmx.c": [
      "File: arch/x86/kvm/vmx.c -> arch/x86/kvm/vmx.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "2419:  if (is_guest_mode(vcpu))",
      "2420:   msr_bitmap = vmx_msr_bitmap_nested;",
      "2422:   if (is_long_mode(vcpu))",
      "2423:    msr_bitmap = vmx_msr_bitmap_longmode_x2apic;",
      "2424:   else",
      "",
      "[Removed Lines]",
      "2421:  else if (vcpu->arch.apic_base & X2APIC_ENABLE) {",
      "",
      "[Added Lines]",
      "2421:  else if (cpu_has_secondary_exec_ctrls() &&",
      "2422:    (vmcs_read32(SECONDARY_VM_EXEC_CONTROL) &",
      "2423:     SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE)) {",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "4783:  struct vcpu_vmx *vmx = to_vmx(vcpu);",
      "4785:  vmcs_write32(PIN_BASED_VM_EXEC_CONTROL, vmx_pin_based_exec_ctrl(vmx));",
      "4786: }",
      "4788: static u32 vmx_exec_control(struct vcpu_vmx *vmx)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "4788:  if (cpu_has_secondary_exec_ctrls()) {",
      "4789:   if (kvm_vcpu_apicv_active(vcpu))",
      "4790:    vmcs_set_bits(SECONDARY_VM_EXEC_CONTROL,",
      "4791:           SECONDARY_EXEC_APIC_REGISTER_VIRT |",
      "4792:           SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY);",
      "4793:   else",
      "4794:    vmcs_clear_bits(SECONDARY_VM_EXEC_CONTROL,",
      "4795:      SECONDARY_EXEC_APIC_REGISTER_VIRT |",
      "4796:      SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY);",
      "4797:  }",
      "4799:  if (cpu_has_vmx_msr_bitmap())",
      "4800:   vmx_set_msr_bitmap(vcpu);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "6350:  if (enable_ept) {",
      "6351:   kvm_mmu_set_mask_ptes(0ull,",
      "",
      "[Removed Lines]",
      "6332:  if (enable_apicv) {",
      "6333:   for (msr = 0x800; msr <= 0x8ff; msr++)",
      "6334:    vmx_disable_intercept_msr_read_x2apic(msr);",
      "6339:   vmx_enable_intercept_msr_read_x2apic(0x802);",
      "6341:   vmx_enable_intercept_msr_read_x2apic(0x839);",
      "6343:   vmx_disable_intercept_msr_write_x2apic(0x808);",
      "6345:   vmx_disable_intercept_msr_write_x2apic(0x80b);",
      "6347:   vmx_disable_intercept_msr_write_x2apic(0x83f);",
      "6348:  }",
      "",
      "[Added Lines]",
      "6347:  for (msr = 0x800; msr <= 0x8ff; msr++)",
      "6348:   vmx_disable_intercept_msr_read_x2apic(msr);",
      "6352:  vmx_enable_intercept_msr_read_x2apic(0x802);",
      "6354:  vmx_enable_intercept_msr_read_x2apic(0x839);",
      "6356:  vmx_disable_intercept_msr_write_x2apic(0x808);",
      "6358:  vmx_disable_intercept_msr_write_x2apic(0x80b);",
      "6360:  vmx_disable_intercept_msr_write_x2apic(0x83f);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "f6e90f9e0ee3df5010e7f378e669d6838b9a25bf",
      "candidate_info": {
        "commit_hash": "f6e90f9e0ee3df5010e7f378e669d6838b9a25bf",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/f6e90f9e0ee3df5010e7f378e669d6838b9a25bf",
        "files": [
          "arch/x86/kvm/vmx.c"
        ],
        "message": "KVM: VMX: Enable MSR-BASED TPR shadow even if APICv is inactive\n\nI observed that kvmvapic(to optimize flexpriority=N or AMD) is used\nto boost TPR access when testing kvm-unit-test/eventinj.flat tpr case\non my haswell desktop (w/ flexpriority, w/o APICv). Commit (8d14695f9542\nx86, apicv: add virtual x2apic support) disable virtual x2apic mode\ncompletely if w/o APICv, and the author also told me that windows guest\ncan't enter into x2apic mode when he developed the APICv feature several\nyears ago. However, it is not truth currently, Interrupt Remapping and\nvIOMMU is added to qemu and the developers from Intel test windows 8 can\nwork in x2apic mode w/ Interrupt Remapping enabled recently.\n\nThis patch enables TPR shadow for virtual x2apic mode to boost\nwindows guest in x2apic mode even if w/o APICv.\n\nCan pass the kvm-unit-test.\n\nSuggested-by: Radim Kr\u010dm\u00e1\u0159 <rkrcmar@redhat.com>\nSuggested-by: Wincy Van <fanwenyi0529@gmail.com>\nReviewed-by: Radim Kr\u010dm\u00e1\u0159 <rkrcmar@redhat.com>\nCc: Paolo Bonzini <pbonzini@redhat.com>\nCc: Radim Kr\u010dm\u00e1\u0159 <rkrcmar@redhat.com>\nCc: Wincy Van <fanwenyi0529@gmail.com>\nCc: Yang Zhang <yang.zhang.wz@gmail.com>\nSigned-off-by: Wanpeng Li <wanpeng.li@hotmail.com>\nSigned-off-by: Radim Kr\u010dm\u00e1\u0159 <rkrcmar@redhat.com>",
        "before_after_code_files": [
          "arch/x86/kvm/vmx.c||arch/x86/kvm/vmx.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "arch/x86/kvm/vmx.c||arch/x86/kvm/vmx.c"
          ],
          "candidate": [
            "arch/x86/kvm/vmx.c||arch/x86/kvm/vmx.c"
          ]
        }
      },
      "candidate_diff": {
        "arch/x86/kvm/vmx.c||arch/x86/kvm/vmx.c": [
          "File: arch/x86/kvm/vmx.c -> arch/x86/kvm/vmx.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "927: static unsigned long *vmx_msr_bitmap_longmode;",
          "928: static unsigned long *vmx_msr_bitmap_legacy_x2apic;",
          "929: static unsigned long *vmx_msr_bitmap_longmode_x2apic;",
          "930: static unsigned long *vmx_vmread_bitmap;",
          "931: static unsigned long *vmx_vmwrite_bitmap;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "930: static unsigned long *vmx_msr_bitmap_legacy_x2apic_apicv_inactive;",
          "931: static unsigned long *vmx_msr_bitmap_longmode_x2apic_apicv_inactive;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2524:  else if (cpu_has_secondary_exec_ctrls() &&",
          "2525:    (vmcs_read32(SECONDARY_VM_EXEC_CONTROL) &",
          "2526:     SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE)) {",
          "2531:  } else {",
          "2532:   if (is_long_mode(vcpu))",
          "2533:    msr_bitmap = vmx_msr_bitmap_longmode;",
          "",
          "[Removed Lines]",
          "2527:   if (is_long_mode(vcpu))",
          "2528:    msr_bitmap = vmx_msr_bitmap_longmode_x2apic;",
          "2529:   else",
          "2530:    msr_bitmap = vmx_msr_bitmap_legacy_x2apic;",
          "",
          "[Added Lines]",
          "2529:   if (enable_apicv && kvm_vcpu_apicv_active(vcpu)) {",
          "2530:    if (is_long_mode(vcpu))",
          "2531:     msr_bitmap = vmx_msr_bitmap_longmode_x2apic;",
          "2532:    else",
          "2533:     msr_bitmap = vmx_msr_bitmap_legacy_x2apic;",
          "2534:   } else {",
          "2535:    if (is_long_mode(vcpu))",
          "2536:     msr_bitmap = vmx_msr_bitmap_longmode_x2apic_apicv_inactive;",
          "2537:    else",
          "2538:     msr_bitmap = vmx_msr_bitmap_legacy_x2apic_apicv_inactive;",
          "2539:   }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "4682:       msr, MSR_TYPE_R | MSR_TYPE_W);",
          "4683: }",
          "4686: {",
          "4691: }",
          "4694: {",
          "4699: }",
          "4702: {",
          "4707: }",
          "4709: static bool vmx_get_enable_apicv(void)",
          "",
          "[Removed Lines]",
          "4685: static void vmx_enable_intercept_msr_read_x2apic(u32 msr)",
          "4687:  __vmx_enable_intercept_for_msr(vmx_msr_bitmap_legacy_x2apic,",
          "4688:    msr, MSR_TYPE_R);",
          "4689:  __vmx_enable_intercept_for_msr(vmx_msr_bitmap_longmode_x2apic,",
          "4690:    msr, MSR_TYPE_R);",
          "4693: static void vmx_disable_intercept_msr_read_x2apic(u32 msr)",
          "4695:  __vmx_disable_intercept_for_msr(vmx_msr_bitmap_legacy_x2apic,",
          "4696:    msr, MSR_TYPE_R);",
          "4697:  __vmx_disable_intercept_for_msr(vmx_msr_bitmap_longmode_x2apic,",
          "4698:    msr, MSR_TYPE_R);",
          "4701: static void vmx_disable_intercept_msr_write_x2apic(u32 msr)",
          "4703:  __vmx_disable_intercept_for_msr(vmx_msr_bitmap_legacy_x2apic,",
          "4704:    msr, MSR_TYPE_W);",
          "4705:  __vmx_disable_intercept_for_msr(vmx_msr_bitmap_longmode_x2apic,",
          "4706:    msr, MSR_TYPE_W);",
          "",
          "[Added Lines]",
          "4694: static void vmx_enable_intercept_msr_read_x2apic(u32 msr, bool apicv_active)",
          "4696:  if (apicv_active) {",
          "4697:   __vmx_enable_intercept_for_msr(vmx_msr_bitmap_legacy_x2apic,",
          "4698:     msr, MSR_TYPE_R);",
          "4699:   __vmx_enable_intercept_for_msr(vmx_msr_bitmap_longmode_x2apic,",
          "4700:     msr, MSR_TYPE_R);",
          "4701:  } else {",
          "4702:   __vmx_enable_intercept_for_msr(vmx_msr_bitmap_legacy_x2apic_apicv_inactive,",
          "4703:     msr, MSR_TYPE_R);",
          "4704:   __vmx_enable_intercept_for_msr(vmx_msr_bitmap_longmode_x2apic_apicv_inactive,",
          "4705:     msr, MSR_TYPE_R);",
          "4706:  }",
          "4709: static void vmx_disable_intercept_msr_read_x2apic(u32 msr, bool apicv_active)",
          "4711:  if (apicv_active) {",
          "4712:   __vmx_disable_intercept_for_msr(vmx_msr_bitmap_legacy_x2apic,",
          "4713:     msr, MSR_TYPE_R);",
          "4714:   __vmx_disable_intercept_for_msr(vmx_msr_bitmap_longmode_x2apic,",
          "4715:     msr, MSR_TYPE_R);",
          "4716:  } else {",
          "4717:   __vmx_disable_intercept_for_msr(vmx_msr_bitmap_legacy_x2apic_apicv_inactive,",
          "4718:     msr, MSR_TYPE_R);",
          "4719:   __vmx_disable_intercept_for_msr(vmx_msr_bitmap_longmode_x2apic_apicv_inactive,",
          "4720:     msr, MSR_TYPE_R);",
          "4721:  }",
          "4724: static void vmx_disable_intercept_msr_write_x2apic(u32 msr, bool apicv_active)",
          "4726:  if (apicv_active) {",
          "4727:   __vmx_disable_intercept_for_msr(vmx_msr_bitmap_legacy_x2apic,",
          "4728:     msr, MSR_TYPE_W);",
          "4729:   __vmx_disable_intercept_for_msr(vmx_msr_bitmap_longmode_x2apic,",
          "4730:     msr, MSR_TYPE_W);",
          "4731:  } else {",
          "4732:   __vmx_disable_intercept_for_msr(vmx_msr_bitmap_legacy_x2apic_apicv_inactive,",
          "4733:     msr, MSR_TYPE_W);",
          "4734:   __vmx_disable_intercept_for_msr(vmx_msr_bitmap_longmode_x2apic_apicv_inactive,",
          "4735:     msr, MSR_TYPE_W);",
          "4736:  }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "6364:  if (!vmx_msr_bitmap_legacy_x2apic)",
          "6365:   goto out2;",
          "6367:  vmx_msr_bitmap_longmode = (unsigned long *)__get_free_page(GFP_KERNEL);",
          "6368:  if (!vmx_msr_bitmap_longmode)",
          "6371:  vmx_msr_bitmap_longmode_x2apic =",
          "6372:     (unsigned long *)__get_free_page(GFP_KERNEL);",
          "6373:  if (!vmx_msr_bitmap_longmode_x2apic)",
          "6376:  vmx_vmread_bitmap = (unsigned long *)__get_free_page(GFP_KERNEL);",
          "6377:  if (!vmx_vmread_bitmap)",
          "6380:  vmx_vmwrite_bitmap = (unsigned long *)__get_free_page(GFP_KERNEL);",
          "6381:  if (!vmx_vmwrite_bitmap)",
          "6384:  memset(vmx_vmread_bitmap, 0xff, PAGE_SIZE);",
          "6385:  memset(vmx_vmwrite_bitmap, 0xff, PAGE_SIZE);",
          "",
          "[Removed Lines]",
          "6369:   goto out3;",
          "6374:   goto out4;",
          "6378:   goto out6;",
          "6382:   goto out7;",
          "",
          "[Added Lines]",
          "6397:  vmx_msr_bitmap_legacy_x2apic_apicv_inactive =",
          "6398:     (unsigned long *)__get_free_page(GFP_KERNEL);",
          "6399:  if (!vmx_msr_bitmap_legacy_x2apic_apicv_inactive)",
          "6400:   goto out3;",
          "6404:   goto out4;",
          "6409:   goto out5;",
          "6411:  vmx_msr_bitmap_longmode_x2apic_apicv_inactive =",
          "6412:     (unsigned long *)__get_free_page(GFP_KERNEL);",
          "6413:  if (!vmx_msr_bitmap_longmode_x2apic_apicv_inactive)",
          "6414:   goto out6;",
          "6418:   goto out7;",
          "6422:   goto out8;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "6399:  if (setup_vmcs_config(&vmcs_config) < 0) {",
          "6400:   r = -EIO;",
          "6402:  }",
          "6404:  if (boot_cpu_has(X86_FEATURE_NX))",
          "",
          "[Removed Lines]",
          "6401:   goto out8;",
          "",
          "[Added Lines]",
          "6441:   goto out9;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "6465:    vmx_msr_bitmap_legacy, PAGE_SIZE);",
          "6466:  memcpy(vmx_msr_bitmap_longmode_x2apic,",
          "6467:    vmx_msr_bitmap_longmode, PAGE_SIZE);",
          "6471:  for (msr = 0x800; msr <= 0x8ff; msr++)",
          "6483:  if (enable_ept) {",
          "6484:   kvm_mmu_set_mask_ptes(VMX_EPT_READABLE_MASK,",
          "",
          "[Removed Lines]",
          "6472:   vmx_disable_intercept_msr_read_x2apic(msr);",
          "6475:  vmx_enable_intercept_msr_read_x2apic(0x839);",
          "6477:  vmx_disable_intercept_msr_write_x2apic(0x808);",
          "6479:  vmx_disable_intercept_msr_write_x2apic(0x80b);",
          "6481:  vmx_disable_intercept_msr_write_x2apic(0x83f);",
          "",
          "[Added Lines]",
          "6508:  memcpy(vmx_msr_bitmap_legacy_x2apic_apicv_inactive,",
          "6509:    vmx_msr_bitmap_legacy, PAGE_SIZE);",
          "6510:  memcpy(vmx_msr_bitmap_longmode_x2apic_apicv_inactive,",
          "6511:    vmx_msr_bitmap_longmode, PAGE_SIZE);",
          "6519:   vmx_disable_intercept_msr_read_x2apic(msr, true);",
          "6522:  vmx_enable_intercept_msr_read_x2apic(0x839, true);",
          "6524:  vmx_disable_intercept_msr_write_x2apic(0x808, true);",
          "6526:  vmx_disable_intercept_msr_write_x2apic(0x80b, true);",
          "6528:  vmx_disable_intercept_msr_write_x2apic(0x83f, true);",
          "6535:  vmx_disable_intercept_msr_read_x2apic(0x808, false);",
          "6536:  vmx_disable_intercept_msr_write_x2apic(0x808, false);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "6526:  return alloc_kvm_area();",
          "6529:  free_page((unsigned long)vmx_vmwrite_bitmap);",
          "6531:  free_page((unsigned long)vmx_vmread_bitmap);",
          "6532: out6:",
          "6533:  free_page((unsigned long)vmx_msr_bitmap_longmode_x2apic);",
          "6535:  free_page((unsigned long)vmx_msr_bitmap_longmode);",
          "6536: out3:",
          "6537:  free_page((unsigned long)vmx_msr_bitmap_legacy_x2apic);",
          "6538: out2:",
          "",
          "[Removed Lines]",
          "6528: out8:",
          "6530: out7:",
          "6534: out4:",
          "",
          "[Added Lines]",
          "6583: out9:",
          "6585: out8:",
          "6587: out7:",
          "6588:  free_page((unsigned long)vmx_msr_bitmap_longmode_x2apic_apicv_inactive);",
          "6591: out5:",
          "6593: out4:",
          "6594:  free_page((unsigned long)vmx_msr_bitmap_legacy_x2apic_apicv_inactive);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "6548: static __exit void hardware_unsetup(void)",
          "6549: {",
          "6550:  free_page((unsigned long)vmx_msr_bitmap_legacy_x2apic);",
          "6551:  free_page((unsigned long)vmx_msr_bitmap_longmode_x2apic);",
          "6552:  free_page((unsigned long)vmx_msr_bitmap_legacy);",
          "6553:  free_page((unsigned long)vmx_msr_bitmap_longmode);",
          "6554:  free_page((unsigned long)vmx_io_bitmap_b);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6610:  free_page((unsigned long)vmx_msr_bitmap_legacy_x2apic_apicv_inactive);",
          "6612:  free_page((unsigned long)vmx_msr_bitmap_longmode_x2apic_apicv_inactive);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "8439:   return;",
          "8440:  }",
          "8448:   return;",
          "8450:  if (!cpu_need_tpr_shadow(vcpu))",
          "",
          "[Removed Lines]",
          "8446:  if (!cpu_has_vmx_virtualize_x2apic_mode() ||",
          "8447:     !kvm_vcpu_apicv_active(vcpu))",
          "",
          "[Added Lines]",
          "8503:  if (!cpu_has_vmx_virtualize_x2apic_mode())",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "04bb92e4b4cf06a66889d37b892b78f926faa9d4",
      "candidate_info": {
        "commit_hash": "04bb92e4b4cf06a66889d37b892b78f926faa9d4",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/04bb92e4b4cf06a66889d37b892b78f926faa9d4",
        "files": [
          "arch/x86/kvm/vmx.c"
        ],
        "message": "KVM: vmx: fix VPID is 0000H in non-root operation\n\nReference SDM 28.1:\n\nThe current VPID is 0000H in the following situations:\n- Outside VMX operation. (This includes operation in system-management\n  mode under the default treatment of SMIs and SMM with VMX operation;\n  see Section 34.14.)\n- In VMX root operation.\n- In VMX non-root operation when the \u201cenable VPID\u201d VM-execution control\n  is 0.\n\nThe VPID should never be 0000H in non-root operation when \"enable VPID\"\nVM-execution control is 1. However, commit 34a1cd60 (\"kvm: x86: vmx:\nmove some vmx setting from vmx_init() to hardware_setup()\") remove the\ncodes which reserve 0000H for VMX root operation.\n\nThis patch fix it by again reserving 0000H for VMX root operation.\n\nCc: stable@vger.kernel.org # 3.19+\nFixes: 34a1cd60d17f62c1f077c1478a6c2ca8c3d17af4\nReported-by: Wincy Van <fanwenyi0529@gmail.com>\nSigned-off-by: Wanpeng Li <wanpeng.li@hotmail.com>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>",
        "before_after_code_files": [
          "arch/x86/kvm/vmx.c||arch/x86/kvm/vmx.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "arch/x86/kvm/vmx.c||arch/x86/kvm/vmx.c"
          ],
          "candidate": [
            "arch/x86/kvm/vmx.c||arch/x86/kvm/vmx.c"
          ]
        }
      },
      "candidate_diff": {
        "arch/x86/kvm/vmx.c||arch/x86/kvm/vmx.c": [
          "File: arch/x86/kvm/vmx.c -> arch/x86/kvm/vmx.c"
        ]
      }
    },
    {
      "candidate_hash": "40d8338d095e6117112f4d303e5d6cf776069e38",
      "candidate_info": {
        "commit_hash": "40d8338d095e6117112f4d303e5d6cf776069e38",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/40d8338d095e6117112f4d303e5d6cf776069e38",
        "files": [
          "arch/x86/kvm/vmx.c"
        ],
        "message": "KVM: VMX: remove functions that enable msr intercepts\n\nAll intercepts are enabled at the beginning, so they can only be used if\nwe disabled an intercept that we wanted to have enabled.\nThis was done for TMCCT to simplify a loop that disables all x2APIC MSR\nintercepts, but just keeping TMCCT enabled yields better results.\n\nSigned-off-by: Radim Kr\u010dm\u00e1\u0159 <rkrcmar@redhat.com>",
        "before_after_code_files": [
          "arch/x86/kvm/vmx.c||arch/x86/kvm/vmx.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "arch/x86/kvm/vmx.c||arch/x86/kvm/vmx.c"
          ],
          "candidate": [
            "arch/x86/kvm/vmx.c||arch/x86/kvm/vmx.c"
          ]
        }
      },
      "candidate_diff": {
        "arch/x86/kvm/vmx.c||arch/x86/kvm/vmx.c": [
          "File: arch/x86/kvm/vmx.c -> arch/x86/kvm/vmx.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4575:  }",
          "4576: }",
          "",
          "[Removed Lines]",
          "4578: static void __vmx_enable_intercept_for_msr(unsigned long *msr_bitmap,",
          "4579:       u32 msr, int type)",
          "4580: {",
          "4581:  int f = sizeof(unsigned long);",
          "4583:  if (!cpu_has_vmx_msr_bitmap())",
          "4584:   return;",
          "4591:  if (msr <= 0x1fff) {",
          "4592:   if (type & MSR_TYPE_R)",
          "4594:    __set_bit(msr, msr_bitmap + 0x000 / f);",
          "4596:   if (type & MSR_TYPE_W)",
          "4598:    __set_bit(msr, msr_bitmap + 0x800 / f);",
          "4600:  } else if ((msr >= 0xc0000000) && (msr <= 0xc0001fff)) {",
          "4601:   msr &= 0x1fff;",
          "4602:   if (type & MSR_TYPE_R)",
          "4604:    __set_bit(msr, msr_bitmap + 0x400 / f);",
          "4606:   if (type & MSR_TYPE_W)",
          "4608:    __set_bit(msr, msr_bitmap + 0xc00 / f);",
          "4610:  }",
          "4611: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "4665:       msr, MSR_TYPE_R | MSR_TYPE_W);",
          "4666: }",
          "4683: static void vmx_disable_intercept_msr_read_x2apic(u32 msr, bool apicv_active)",
          "4684: {",
          "4685:  if (apicv_active) {",
          "",
          "[Removed Lines]",
          "4668: static void vmx_enable_intercept_msr_read_x2apic(u32 msr, bool apicv_active)",
          "4669: {",
          "4670:  if (apicv_active) {",
          "4671:   __vmx_enable_intercept_for_msr(vmx_msr_bitmap_legacy_x2apic_apicv,",
          "4672:     msr, MSR_TYPE_R);",
          "4673:   __vmx_enable_intercept_for_msr(vmx_msr_bitmap_longmode_x2apic_apicv,",
          "4674:     msr, MSR_TYPE_R);",
          "4675:  } else {",
          "4676:   __vmx_enable_intercept_for_msr(vmx_msr_bitmap_legacy_x2apic,",
          "4677:     msr, MSR_TYPE_R);",
          "4678:   __vmx_enable_intercept_for_msr(vmx_msr_bitmap_longmode_x2apic,",
          "4679:     msr, MSR_TYPE_R);",
          "4680:  }",
          "4681: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "6494:   vmx_disable_intercept_msr_read_x2apic(msr, true);",
          "6499:  vmx_disable_intercept_msr_write_x2apic(0x808, true);",
          "",
          "[Removed Lines]",
          "6493:  for (msr = 0x800; msr <= 0x8ff; msr++)",
          "6497:  vmx_enable_intercept_msr_read_x2apic(0x839, true);",
          "",
          "[Added Lines]",
          "6443:  for (msr = 0x800; msr <= 0x8ff; msr++) {",
          "6444:   if (msr == 0x839 /* TMCCT */)",
          "6445:    continue;",
          "6447:  }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "2e69f8656139fc3f28079ed5019a2a475e175f0a",
      "candidate_info": {
        "commit_hash": "2e69f8656139fc3f28079ed5019a2a475e175f0a",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/2e69f8656139fc3f28079ed5019a2a475e175f0a",
        "files": [
          "arch/x86/kvm/vmx.c"
        ],
        "message": "KVM: VMX: join functions that disable x2apic msr intercepts\n\nvmx_disable_intercept_msr_read_x2apic() and\nvmx_disable_intercept_msr_write_x2apic() differed only in the type.\nPass the type to a new function.\n\n[Ordered and commented TPR intercept according to Paolo's suggestion.]\nSigned-off-by: Radim Kr\u010dm\u00e1\u0159 <rkrcmar@redhat.com>",
        "before_after_code_files": [
          "arch/x86/kvm/vmx.c||arch/x86/kvm/vmx.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "arch/x86/kvm/vmx.c||arch/x86/kvm/vmx.c"
          ],
          "candidate": [
            "arch/x86/kvm/vmx.c||arch/x86/kvm/vmx.c"
          ]
        }
      },
      "candidate_diff": {
        "arch/x86/kvm/vmx.c||arch/x86/kvm/vmx.c": [
          "File: arch/x86/kvm/vmx.c -> arch/x86/kvm/vmx.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4630:       msr, MSR_TYPE_R | MSR_TYPE_W);",
          "4631: }",
          "4634: {",
          "4635:  if (apicv_active) {",
          "4636:   __vmx_disable_intercept_for_msr(vmx_msr_bitmap_legacy_x2apic_apicv,",
          "4638:   __vmx_disable_intercept_for_msr(vmx_msr_bitmap_longmode_x2apic_apicv,",
          "4640:  } else {",
          "4641:   __vmx_disable_intercept_for_msr(vmx_msr_bitmap_legacy_x2apic,",
          "4643:   __vmx_disable_intercept_for_msr(vmx_msr_bitmap_longmode_x2apic,",
          "4660:  }",
          "4661: }",
          "",
          "[Removed Lines]",
          "4633: static void vmx_disable_intercept_msr_read_x2apic(u32 msr, bool apicv_active)",
          "4637:     msr, MSR_TYPE_R);",
          "4639:     msr, MSR_TYPE_R);",
          "4642:     msr, MSR_TYPE_R);",
          "4644:     msr, MSR_TYPE_R);",
          "4645:  }",
          "4646: }",
          "4648: static void vmx_disable_intercept_msr_write_x2apic(u32 msr, bool apicv_active)",
          "4649: {",
          "4650:  if (apicv_active) {",
          "4651:   __vmx_disable_intercept_for_msr(vmx_msr_bitmap_legacy_x2apic_apicv,",
          "4652:     msr, MSR_TYPE_W);",
          "4653:   __vmx_disable_intercept_for_msr(vmx_msr_bitmap_longmode_x2apic_apicv,",
          "4654:     msr, MSR_TYPE_W);",
          "4655:  } else {",
          "4656:   __vmx_disable_intercept_for_msr(vmx_msr_bitmap_legacy_x2apic,",
          "4657:     msr, MSR_TYPE_W);",
          "4658:   __vmx_disable_intercept_for_msr(vmx_msr_bitmap_longmode_x2apic,",
          "4659:     msr, MSR_TYPE_W);",
          "",
          "[Added Lines]",
          "4633: static void vmx_disable_intercept_msr_x2apic(u32 msr, int type, bool apicv_active)",
          "4637:     msr, type);",
          "4639:     msr, type);",
          "4642:     msr, type);",
          "4644:     msr, type);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "6443:  for (msr = 0x800; msr <= 0x8ff; msr++) {",
          "6444:   if (msr == 0x839 /* TMCCT */)",
          "6445:    continue;",
          "6447:  }",
          "6464:  if (enable_ept) {",
          "6465:   kvm_mmu_set_mask_ptes(VMX_EPT_READABLE_MASK,",
          "",
          "[Removed Lines]",
          "6446:   vmx_disable_intercept_msr_read_x2apic(msr, true);",
          "6450:  vmx_disable_intercept_msr_write_x2apic(0x808, true);",
          "6452:  vmx_disable_intercept_msr_write_x2apic(0x80b, true);",
          "6454:  vmx_disable_intercept_msr_write_x2apic(0x83f, true);",
          "6461:  vmx_disable_intercept_msr_read_x2apic(0x808, false);",
          "6462:  vmx_disable_intercept_msr_write_x2apic(0x808, false);",
          "",
          "[Added Lines]",
          "6428:   vmx_disable_intercept_msr_x2apic(msr, MSR_TYPE_R, true);",
          "6435:  vmx_disable_intercept_msr_x2apic(0x808, MSR_TYPE_W, true);",
          "6436:  vmx_disable_intercept_msr_x2apic(0x808, MSR_TYPE_R | MSR_TYPE_W, false);",
          "6439:  vmx_disable_intercept_msr_x2apic(0x80b, MSR_TYPE_W, true);",
          "6441:  vmx_disable_intercept_msr_x2apic(0x83f, MSR_TYPE_W, true);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
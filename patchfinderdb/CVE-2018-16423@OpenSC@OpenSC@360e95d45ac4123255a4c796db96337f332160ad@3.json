{
  "cve_id": "CVE-2018-16423",
  "cve_desc": "A double free when handling responses from a smartcard in sc_file_set_sec_attr in libopensc/sc.c in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to cause a denial of service (application crash) or possibly have unspecified other impact.",
  "repo": "OpenSC/OpenSC",
  "patch_hash": "360e95d45ac4123255a4c796db96337f332160ad",
  "patch_info": {
    "commit_hash": "360e95d45ac4123255a4c796db96337f332160ad",
    "repo": "OpenSC/OpenSC",
    "commit_url": "https://github.com/OpenSC/OpenSC/commit/360e95d45ac4123255a4c796db96337f332160ad",
    "files": [
      "src/libopensc/card-cac.c",
      "src/libopensc/card-epass2003.c",
      "src/libopensc/card-muscle.c",
      "src/libopensc/card-tcos.c",
      "src/libopensc/pkcs15-esteid.c",
      "src/libopensc/pkcs15-gemsafeV1.c",
      "src/libopensc/pkcs15-sc-hsm.c",
      "src/libopensc/sc.c",
      "src/tools/cryptoflex-tool.c",
      "src/tools/egk-tool.c",
      "src/tools/util.c"
    ],
    "message": "fixed out of bounds writes\n\nThanks to Eric Sesterhenn from X41 D-SEC GmbH\nfor reporting the problems.",
    "before_after_code_files": [
      "src/libopensc/card-cac.c||src/libopensc/card-cac.c",
      "src/libopensc/card-epass2003.c||src/libopensc/card-epass2003.c",
      "src/libopensc/card-muscle.c||src/libopensc/card-muscle.c",
      "src/libopensc/card-tcos.c||src/libopensc/card-tcos.c",
      "src/libopensc/pkcs15-esteid.c||src/libopensc/pkcs15-esteid.c",
      "src/libopensc/pkcs15-gemsafeV1.c||src/libopensc/pkcs15-gemsafeV1.c",
      "src/libopensc/pkcs15-sc-hsm.c||src/libopensc/pkcs15-sc-hsm.c",
      "src/libopensc/sc.c||src/libopensc/sc.c",
      "src/tools/cryptoflex-tool.c||src/tools/cryptoflex-tool.c",
      "src/tools/egk-tool.c||src/tools/egk-tool.c",
      "src/tools/util.c||src/tools/util.c"
    ]
  },
  "patch_diff": {
    "src/libopensc/card-cac.c||src/libopensc/card-cac.c": [
      "File: src/libopensc/card-cac.c -> src/libopensc/card-cac.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "794:         }",
      "795:  if (priv->cac_id_len) {",
      "796:   serial->len = MIN(priv->cac_id_len, SC_MAX_SERIALNR);",
      "798:   SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_SUCCESS);",
      "799:  }",
      "800:  SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_FILE_NOT_FOUND);",
      "",
      "[Removed Lines]",
      "797:   memcpy(serial->value, priv->cac_id, priv->cac_id_len);",
      "",
      "[Added Lines]",
      "797:   memcpy(serial->value, priv->cac_id, serial->len);",
      "",
      "---------------"
    ],
    "src/libopensc/card-epass2003.c||src/libopensc/card-epass2003.c": [
      "File: src/libopensc/card-epass2003.c -> src/libopensc/card-epass2003.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "951:  while (0x80 != plaintext[cipher_len - 2] && (cipher_len - 2 > 0))",
      "952:   cipher_len--;",
      "955:   return -1;",
      "957:  memcpy(out, plaintext, cipher_len - 2);",
      "",
      "[Removed Lines]",
      "954:  if (2 == cipher_len)",
      "",
      "[Added Lines]",
      "954:  if (2 == cipher_len || *out_len < cipher_len - 2)",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "977:  r = sc_check_sw(card, sm->sw1, sm->sw2);",
      "978:  if (r == SC_SUCCESS) {",
      "979:   if (exdata->sm) {",
      "980:    if (0 != decrypt_response(card, sm->resp, sm->resplen, plain->resp, &len))",
      "981:     return SC_ERROR_CARD_CMD_FAILED;",
      "982:   }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "980:    len = plain->resplen;",
      "",
      "---------------"
    ],
    "src/libopensc/card-muscle.c||src/libopensc/card-muscle.c": [
      "File: src/libopensc/card-muscle.c -> src/libopensc/card-muscle.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "518:  mscfs_check_cache(priv->fs);",
      "520:  for(x = 0; x < fs->cache.size; x++) {",
      "522:   sc_debug(card->ctx, SC_LOG_DEBUG_NORMAL,",
      "523:    \"FILE: %02X%02X%02X%02X\\n\",",
      "524:    oid[0],oid[1],oid[2],oid[3]);",
      "",
      "[Removed Lines]",
      "521:   u8* oid= fs->cache.array[x].objectId.id;",
      "",
      "[Added Lines]",
      "521:   u8* oid = fs->cache.array[x].objectId.id;",
      "522:   if (bufLen < 2)",
      "523:    break;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "527:    buf[1] = oid[3];",
      "529:    buf += 2;",
      "531:   }",
      "532:  }",
      "533:  return count;",
      "",
      "[Removed Lines]",
      "530:    count+=2;",
      "",
      "[Added Lines]",
      "532:    count += 2;",
      "533:    bufLen -= 2;",
      "",
      "---------------"
    ],
    "src/libopensc/card-tcos.c||src/libopensc/card-tcos.c": [
      "File: src/libopensc/card-tcos.c -> src/libopensc/card-tcos.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "408:  file->path = *in_path;",
      "410:  for(i=2; i+1<apdu.resplen && i+1+apdu.resp[i+1]<apdu.resplen; i+=2+apdu.resp[i+1]){",
      "412:   unsigned char type=apdu.resp[i], *d=apdu.resp+i+2;",
      "414:   switch (type) {",
      "",
      "[Removed Lines]",
      "411:   int j, len=apdu.resp[i+1];",
      "",
      "[Added Lines]",
      "411:   size_t j, len=apdu.resp[i+1];",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "432:    file->id = (d[0]<<8) | d[1];",
      "433:    break;",
      "434:   case 0x84:",
      "437:    break;",
      "438:   case 0x86:",
      "439:    sc_file_set_sec_attr(file, d, len);",
      "",
      "[Removed Lines]",
      "435:    memcpy(file->name, d, len);",
      "436:    file->namelen = len;",
      "",
      "[Added Lines]",
      "435:    file->namelen = MIN(sizeof file->name, len);",
      "436:    memcpy(file->name, d, file->namelen);",
      "",
      "---------------"
    ],
    "src/libopensc/pkcs15-esteid.c||src/libopensc/pkcs15-esteid.c": [
      "File: src/libopensc/pkcs15-esteid.c -> src/libopensc/pkcs15-esteid.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "80:  r = sc_read_record (card, SC_ESTEID_PD_DOCUMENT_NR, buff, sizeof(buff), SC_RECORD_BY_REC_NR);",
      "81:  SC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, \"read document number failed\");",
      "83:  set_string (&p15card->tokeninfo->serial_number, (const char *) buff);",
      "85:  p15card->tokeninfo->flags = SC_PKCS15_TOKEN_PRN_GENERATION",
      "",
      "[Removed Lines]",
      "82:  buff[r] = '\\0';",
      "",
      "[Added Lines]",
      "82:  buff[MIN((size_t) r, (sizeof buff)-1)] = '\\0';",
      "",
      "---------------"
    ],
    "src/libopensc/pkcs15-gemsafeV1.c||src/libopensc/pkcs15-gemsafeV1.c": [
      "File: src/libopensc/pkcs15-gemsafeV1.c -> src/libopensc/pkcs15-gemsafeV1.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "212:   if (ibuf[ind+1] == 0xFE) {",
      "213:    gemsafe_prkeys[i].ref = ibuf[ind+4];",
      "214:    sc_log(card->ctx, \"Key container %d is allocated and uses key_ref %d\",",
      "",
      "[Removed Lines]",
      "211:  while (ibuf[ind] == 0x01) {",
      "",
      "[Added Lines]",
      "211:  while (ibuf[ind] == 0x01 && i < gemsafe_cert_max) {",
      "",
      "---------------"
    ],
    "src/libopensc/pkcs15-sc-hsm.c||src/libopensc/pkcs15-sc-hsm.c": [
      "File: src/libopensc/pkcs15-sc-hsm.c -> src/libopensc/pkcs15-sc-hsm.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "837:   r = read_file(p15card, (u8 *) \"\\x2F\\x02\", efbin, &len, 1);",
      "838:   LOG_TEST_RET(card->ctx, r, \"Skipping optional EF.C_DevAut\");",
      "846:   }",
      "848:   ptr = efbin;",
      "",
      "[Removed Lines]",
      "841:   ptr = realloc(priv->EF_C_DevAut, len);",
      "842:   if (ptr) {",
      "843:    memcpy(ptr, efbin, len);",
      "844:    priv->EF_C_DevAut = ptr;",
      "845:    priv->EF_C_DevAut_len = len;",
      "",
      "[Added Lines]",
      "840:   if (len > 0) {",
      "842:    ptr = realloc(priv->EF_C_DevAut, len);",
      "843:    if (ptr) {",
      "844:     memcpy(ptr, efbin, len);",
      "845:     priv->EF_C_DevAut = ptr;",
      "846:     priv->EF_C_DevAut_len = len;",
      "847:    }",
      "",
      "---------------"
    ],
    "src/libopensc/sc.c||src/libopensc/sc.c": [
      "File: src/libopensc/sc.c -> src/libopensc/sc.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "628:   return SC_ERROR_INVALID_ARGUMENTS;",
      "629:  }",
      "632:   if (file->sec_attr != NULL)",
      "633:    free(file->sec_attr);",
      "634:   file->sec_attr = NULL;",
      "",
      "[Removed Lines]",
      "631:  if (sec_attr == NULL) {",
      "",
      "[Added Lines]",
      "631:  if (sec_attr == NULL || sec_attr_len) {",
      "",
      "---------------"
    ],
    "src/tools/cryptoflex-tool.c||src/tools/cryptoflex-tool.c": [
      "File: src/tools/cryptoflex-tool.c -> src/tools/cryptoflex-tool.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "21: #include \"config.h\"",
      "23: #include \"libopensc/sc-ossl-compat.h\"",
      "24: #include <openssl/bn.h>",
      "25: #include <openssl/rsa.h>",
      "26: #include <openssl/x509.h>",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "24: #include \"libopensc/internal.h\"",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "331:   fprintf(stderr, \"Unable to select public key file: %s\\n\", sc_strerror(r));",
      "332:   return 2;",
      "333:  }",
      "335:  sc_file_free(file);",
      "336:  r = sc_read_binary(card, 0, buf, bufsize, 0);",
      "337:  if (r < 0) {",
      "",
      "[Removed Lines]",
      "334:  bufsize = file->size;",
      "",
      "[Added Lines]",
      "335:  bufsize = MIN(file->size, sizeof buf);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "382:  e = sc_file_get_acl_entry(file, SC_AC_OP_READ);",
      "383:  if (e == NULL || e->method == SC_AC_NEVER)",
      "384:   return 10;",
      "386:  sc_file_free(file);",
      "387:  r = sc_read_binary(card, 0, buf, bufsize, 0);",
      "388:  if (r < 0) {",
      "",
      "[Removed Lines]",
      "385:  bufsize = file->size;",
      "",
      "[Added Lines]",
      "386:  bufsize = MIN(file->size, sizeof buf);",
      "",
      "---------------"
    ],
    "src/tools/egk-tool.c||src/tools/egk-tool.c": [
      "File: src/tools/egk-tool.c -> src/tools/egk-tool.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "149:   goto err;",
      "150:  }",
      "153:  p = realloc(*data, len);",
      "154:  if (!p) {",
      "155:   goto err;",
      "",
      "[Removed Lines]",
      "152:  len = file ? file->size : 4096;",
      "",
      "[Added Lines]",
      "152:  len = file && file->size > 0 ? file->size : 4096;",
      "",
      "---------------"
    ],
    "src/tools/util.c||src/tools/util.c": [
      "File: src/tools/util.c -> src/tools/util.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "339:    strcpy(buf, \"????\");",
      "340:    break;",
      "341:   }",
      "344:   e = e->next;",
      "345:  }",
      "347:  return line;",
      "348: }",
      "",
      "[Removed Lines]",
      "342:   strcat(line, buf);",
      "343:   strcat(line, \" \");",
      "",
      "[Added Lines]",
      "342:   strncat(line, buf, sizeof line);",
      "343:   strncat(line, \" \", sizeof line);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "60e8db4c22dba1c0a629cbc78759e5cc3406a758",
      "candidate_info": {
        "commit_hash": "60e8db4c22dba1c0a629cbc78759e5cc3406a758",
        "repo": "OpenSC/OpenSC",
        "commit_url": "https://github.com/OpenSC/OpenSC/commit/60e8db4c22dba1c0a629cbc78759e5cc3406a758",
        "files": [
          "src/tools/Makefile.am",
          "src/tools/Makefile.mak",
          "src/tools/egk-tool-cmdline.c",
          "src/tools/egk-tool-cmdline.h",
          "src/tools/egk-tool.1",
          "src/tools/egk-tool.c",
          "src/tools/egk-tool.ggo.in",
          "src/tools/opensc-notify.1"
        ],
        "message": "Added tool for German eGK\n\nFixes missing opensc-notify.1",
        "before_after_code_files": [
          "src/tools/Makefile.am||src/tools/Makefile.am",
          "src/tools/Makefile.mak||src/tools/Makefile.mak",
          "src/tools/egk-tool-cmdline.c||src/tools/egk-tool-cmdline.c",
          "src/tools/egk-tool-cmdline.h||src/tools/egk-tool-cmdline.h",
          "src/tools/egk-tool.1||src/tools/egk-tool.1",
          "src/tools/egk-tool.c||src/tools/egk-tool.c",
          "src/tools/egk-tool.ggo.in||src/tools/egk-tool.ggo.in",
          "src/tools/opensc-notify.1||src/tools/opensc-notify.1"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/tools/egk-tool.c||src/tools/egk-tool.c"
          ],
          "candidate": [
            "src/tools/egk-tool.c||src/tools/egk-tool.c"
          ]
        }
      },
      "candidate_diff": {
        "src/tools/Makefile.am||src/tools/Makefile.am": [
          "File: src/tools/Makefile.am -> src/tools/Makefile.am",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: include $(top_srcdir)/win32/ltrc.inc",
          "3: do_subst = $(SED) \\",
          "4:     -e 's,[@]CVCDIR[@],$(CVCDIR),g' \\",
          "5:     -e 's,[@]PACKAGE[@],$(PACKAGE),g' \\",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: if ENABLE_ZLIB",
          "4: VDFORMAT=XML",
          "5: else",
          "6: VDFORMAT=GZIP",
          "7: endif",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "9:     -e 's,[@]PACKAGE_URL[@],$(PACKAGE_URL),g' \\",
          "10:     -e 's,[@]PACKAGE_SUMMARY[@],$(PACKAGE_SUMMARY),g' \\",
          "11:     -e 's,[@]PACKAGE_VERSION[@],\"$(PACKAGE_VERSION)\",g' \\",
          "12:     -e 's,[@]X509DIR[@],$(X509DIR),g'",
          "14: NPA_TOOL_BUILT_SOURCES = npa-tool-cmdline.h npa-tool-cmdline.c",
          "15: OPENSC_NOTIFY_BUILT_SOURCES = opensc-notify-cmdline.h opensc-notify-cmdline.c",
          "17: MAINTAINERCLEANFILES = $(srcdir)/Makefile.in $(srcdir)/versioninfo-tools.rc $(srcdir)/versioninfo-opensc-notify.rc",
          "20: noinst_HEADERS = util.h fread_to_eof.h",
          "21: noinst_PROGRAMS = sceac-example",
          "22: bin_PROGRAMS = opensc-tool opensc-explorer opensc-notify \\",
          "23:  pkcs15-tool pkcs15-crypt pkcs11-tool \\",
          "25: if ENABLE_OPENSSL",
          "26: bin_PROGRAMS += cryptoflex-tool pkcs15-init netkey-tool piv-tool \\",
          "27:  westcos-tool sc-hsm-tool dnie-tool gids-tool npa-tool",
          "28: endif",
          "30: if ENABLE_MAN",
          "32: endif",
          "34: # compile with $(PTHREAD_CFLAGS) to allow debugging with gdb",
          "",
          "[Removed Lines]",
          "18: EXTRA_DIST = Makefile.mak versioninfo-tools.rc.in versioninfo-opensc-notify.rc.in npa-tool.ggo.in npa-tool.1 opensc-notify.ggo.in",
          "24:  cardos-tool eidenv openpgp-tool iasecc-tool",
          "31: dist_man1_MANS = npa-tool.1",
          "",
          "[Added Lines]",
          "18:     -e 's,[@]VDFORMAT[@],$(VDFORMAT),g' \\",
          "21: EGK_TOOL_BUILT_SOURCES = egk-tool-cmdline.h egk-tool-cmdline.c",
          "26: EXTRA_DIST = Makefile.mak versioninfo-tools.rc.in versioninfo-opensc-notify.rc.in npa-tool.ggo.in npa-tool.1 opensc-notify.ggo.in egk-tool.ggo.in egk-tool.1",
          "32:  cardos-tool eidenv openpgp-tool iasecc-tool egk-tool",
          "39: dist_man1_MANS = npa-tool.1 opensc-notify.1 egk-tool.1",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "126:   --source='$(PACKAGE_STRING)' \\",
          "127:   $(builddir)/opensc-notify$(EXEEXT)",
          "129: if WIN32",
          "130: opensc_tool_SOURCES += versioninfo-tools.rc",
          "131: piv_tool_SOURCES += versioninfo-tools.rc",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "137: egk_tool_SOURCES = egk-tool.c $(EGK_TOOL_BUILT_SOURCES)",
          "138: egk_tool_LDADD = $(top_builddir)/src/libopensc/libopensc.la $(OPTIONAL_ZLIB_LIBS)",
          "139: egk_tool_CFLAGS = -I$(top_srcdir)/src $(OPTIONAL_ZLIB_CFLAGS)",
          "140: egk_tool_CFLAGS += -Wno-unused-but-set-variable -Wno-unknown-warning-option",
          "142: egk-tool.c: $(abs_builddir)/egk-tool.ggo $(EGK_TOOL_BUILT_SOURCES)",
          "144: # We only want *cmdline* to be generated when they have explicitly been removed.",
          "145: $(EGK_TOOL_BUILT_SOURCES):",
          "146:  $(MAKE) $(abs_builddir)/egk-tool.ggo",
          "147:  $(GENGETOPT) --include-getopt --file-name=egk-tool-cmdline --output-dir=$(builddir) < $(abs_builddir)/egk-tool.ggo",
          "149: $(abs_builddir)/egk-tool.ggo: egk-tool.ggo.in",
          "150:  $(do_subst) < $(abs_srcdir)/egk-tool.ggo.in > $@",
          "152: # We only want egk-tool.1 to be generated when it has explicitly been removed.",
          "153: egk-tool.1:",
          "154:  $(MAKE) egk-tool$(EXEEXT)",
          "155:  $(HELP2MAN) \\",
          "156:   --output=$@ \\",
          "157:   --no-info \\",
          "158:   --source='$(PACKAGE_STRING)' \\",
          "159:   $(builddir)/egk-tool$(EXEEXT)",
          "",
          "---------------"
        ],
        "src/tools/Makefile.mak||src/tools/Makefile.mak": [
          "File: src/tools/Makefile.mak -> src/tools/Makefile.mak",
          "--- Hunk 1 ---",
          "[Context before]",
          "7: TARGETS = opensc-tool.exe opensc-explorer.exe pkcs15-tool.exe pkcs15-crypt.exe \\",
          "8:   pkcs11-tool.exe cardos-tool.exe eidenv.exe openpgp-tool.exe iasecc-tool.exe \\",
          "10:   $(PROGRAMS_OPENSSL)",
          "14: LIBS = $(TOPDIR)\\src\\common\\common.lib \\",
          "15:     $(TOPDIR)\\src\\scconf\\scconf.lib \\",
          "",
          "[Removed Lines]",
          "9:   opensc-notify.exe \\",
          "12: OBJECTS = util.obj npa-tool-cmdline.obj fread_to_eof.obj versioninfo-tools.res",
          "",
          "[Added Lines]",
          "9:   opensc-notify.exe egk-tool.exe \\",
          "12: OBJECTS = util.obj versioninfo-tools.res",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "25: opensc-notify.exe: opensc-notify-cmdline.obj versioninfo-opensc-notify.res $(LIBS)",
          "26:  cl $(COPTS) /c $*.c",
          "28:  mt -manifest exe.manifest -outputresource:$@;1",
          "30: .c.exe:",
          "31:  cl $(COPTS) /c $<",
          "33:  mt -manifest exe.manifest -outputresource:$@;1",
          "",
          "[Removed Lines]",
          "27:  link $(LINKFLAGS) /pdb:$*.pdb /out:$@ $*.obj opensc-notify-cmdline.obj versioninfo-opensc-notify.res $(LIBS) $(OPENPACE_LIB) $(OPENSSL_LIB) gdi32.lib shell32.lib User32.lib ws2_32.lib",
          "32:  link $(LINKFLAGS) /pdb:$*.pdb /out:$@ $*.obj $(OBJECTS) $(LIBS) $(OPENPACE_LIB) $(OPENSSL_LIB) gdi32.lib shell32.lib User32.lib ws2_32.lib",
          "",
          "[Added Lines]",
          "27:  link $(LINKFLAGS) /pdb:$*.pdb /out:$@ $*.obj opensc-notify-cmdline.obj versioninfo-opensc-notify.res $(LIBS) gdi32.lib shell32.lib User32.lib ws2_32.lib",
          "28:  mt -manifest exe.manifest -outputresource:$@;1",
          "30: npa-tool.exe: npa-tool-cmdline.obj fread_to_eof.obj $(LIBS)",
          "31:  cl $(COPTS) /c $*.c",
          "32:  link $(LINKFLAGS) /pdb:$*.pdb /out:$@ $*.obj npa-tool-cmdline.obj fread_to_eof.obj $(LIBS) $(OPENPACE_LIB) $(OPENSSL_LIB) gdi32.lib shell32.lib User32.lib ws2_32.lib",
          "33:  mt -manifest exe.manifest -outputresource:$@;1",
          "35: egk-tool.exe: egk-tool-cmdline.obj $(LIBS)",
          "36:  cl $(COPTS) /c $*.c",
          "37:  link $(LINKFLAGS) /pdb:$*.pdb /out:$@ $*.obj egk-tool-cmdline.obj $(LIBS) $(ZLIB_LIB) gdi32.lib shell32.lib User32.lib ws2_32.lib",
          "42:  link $(LINKFLAGS) /pdb:$*.pdb /out:$@ $*.obj $(OBJECTS) $(LIBS) $(OPENSSL_LIB) gdi32.lib shell32.lib User32.lib ws2_32.lib",
          "",
          "---------------"
        ],
        "src/tools/egk-tool-cmdline.c||src/tools/egk-tool-cmdline.c": [
          "File: src/tools/egk-tool-cmdline.c -> src/tools/egk-tool-cmdline.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2:   File autogenerated by gengetopt version 2.22.6",
          "3:   generated with the following command:",
          "4:   /usr/local/bin/gengetopt --include-getopt --file-name=egk-tool-cmdline --output-dir=.",
          "6:   The developers of gengetopt consider the fixed text that goes in all",
          "7:   gengetopt output files to be in the public domain:",
          "8:   we make no copyright claims on it.",
          "12: #ifdef HAVE_CONFIG_H",
          "13: #include \"config.h\"",
          "14: #endif",
          "16: #include <stdio.h>",
          "17: #include <stdlib.h>",
          "18: #include <string.h>",
          "20: #ifndef FIX_UNUSED",
          "22: #endif",
          "25: #include \"egk-tool-cmdline.h\"",
          "27: const char *gengetopt_args_info_purpose = \"\";",
          "29: const char *gengetopt_args_info_usage = \"Usage: egk-tool [OPTIONS]...\";",
          "31: const char *gengetopt_args_info_versiontext = \"\";",
          "33: const char *gengetopt_args_info_description = \"\";",
          "35: const char *gengetopt_args_info_help[] = {",
          "36:   \"  -h, --help        Print help and exit\",",
          "37:   \"  -V, --version     Print version and exit\",",
          "38:   \"  -r, --reader=INT  Number of the PC/SC reader to use (-1 for autodetect)\\n                      (default=`-1')\",",
          "39:   \"  -v, --verbose     Use (several times) to be more verbose\",",
          "40:   \"\\nHealth Care Application (HCA):\",",
          "41:   \"      --pd          Show 'Pers\u00f6nliche Versicherungsdaten' (XML)  (default=off)\",",
          "42:   \"      --vd          Show 'Allgemeine Versicherungsdaten' (XML)  (default=off)\",",
          "43:   \"      --gvd         Show 'Gesch\u00fctzte Versicherungsdaten' (XML)  (default=off)\",",
          "44:   \"      --vsd-status  Show 'Versichertenstammdaten-Status'  (default=off)\",",
          "45:   \"\\nReport bugs to opensc-devel@lists.sourceforge.net\\n\\nWritten by Frank Morgner <frankmorgner@gmail.com>\",",
          "46:     0",
          "47: };",
          "49: typedef enum {ARG_NO",
          "50:   , ARG_FLAG",
          "51:   , ARG_INT",
          "52: } cmdline_parser_arg_type;",
          "54: static",
          "55: void clear_given (struct gengetopt_args_info *args_info);",
          "56: static",
          "57: void clear_args (struct gengetopt_args_info *args_info);",
          "59: static int",
          "60: cmdline_parser_internal (int argc, char **argv, struct gengetopt_args_info *args_info,",
          "61:                         struct cmdline_parser_params *params, const char *additional_error);",
          "63: static int",
          "64: cmdline_parser_required2 (struct gengetopt_args_info *args_info, const char *prog_name, const char *additional_error);",
          "66: static char *",
          "67: gengetopt_strdup (const char *s);",
          "69: static",
          "70: void clear_given (struct gengetopt_args_info *args_info)",
          "71: {",
          "72:   args_info->help_given = 0 ;",
          "73:   args_info->version_given = 0 ;",
          "74:   args_info->reader_given = 0 ;",
          "75:   args_info->verbose_given = 0 ;",
          "76:   args_info->pd_given = 0 ;",
          "77:   args_info->vd_given = 0 ;",
          "78:   args_info->gvd_given = 0 ;",
          "79:   args_info->vsd_status_given = 0 ;",
          "80: }",
          "82: static",
          "83: void clear_args (struct gengetopt_args_info *args_info)",
          "84: {",
          "85:   FIX_UNUSED (args_info);",
          "86:   args_info->reader_arg = -1;",
          "87:   args_info->reader_orig = NULL;",
          "88:   args_info->pd_flag = 0;",
          "89:   args_info->vd_flag = 0;",
          "90:   args_info->gvd_flag = 0;",
          "91:   args_info->vsd_status_flag = 0;",
          "93: }",
          "95: static",
          "96: void init_args_info(struct gengetopt_args_info *args_info)",
          "97: {",
          "100:   args_info->help_help = gengetopt_args_info_help[0] ;",
          "101:   args_info->version_help = gengetopt_args_info_help[1] ;",
          "102:   args_info->reader_help = gengetopt_args_info_help[2] ;",
          "103:   args_info->verbose_help = gengetopt_args_info_help[3] ;",
          "104:   args_info->verbose_min = 0;",
          "105:   args_info->verbose_max = 0;",
          "106:   args_info->pd_help = gengetopt_args_info_help[5] ;",
          "107:   args_info->vd_help = gengetopt_args_info_help[6] ;",
          "108:   args_info->gvd_help = gengetopt_args_info_help[7] ;",
          "109:   args_info->vsd_status_help = gengetopt_args_info_help[8] ;",
          "111: }",
          "113: void",
          "114: cmdline_parser_print_version (void)",
          "115: {",
          "116:   printf (\"%s %s\\n\",",
          "117:      (strlen(CMDLINE_PARSER_PACKAGE_NAME) ? CMDLINE_PARSER_PACKAGE_NAME : CMDLINE_PARSER_PACKAGE),",
          "118:      CMDLINE_PARSER_VERSION);",
          "120:   if (strlen(gengetopt_args_info_versiontext) > 0)",
          "121:     printf(\"\\n%s\\n\", gengetopt_args_info_versiontext);",
          "122: }",
          "124: static void print_help_common(void) {",
          "125:   cmdline_parser_print_version ();",
          "127:   if (strlen(gengetopt_args_info_purpose) > 0)",
          "128:     printf(\"\\n%s\\n\", gengetopt_args_info_purpose);",
          "130:   if (strlen(gengetopt_args_info_usage) > 0)",
          "131:     printf(\"\\n%s\\n\", gengetopt_args_info_usage);",
          "133:   printf(\"\\n\");",
          "135:   if (strlen(gengetopt_args_info_description) > 0)",
          "136:     printf(\"%s\\n\\n\", gengetopt_args_info_description);",
          "137: }",
          "139: void",
          "140: cmdline_parser_print_help (void)",
          "141: {",
          "142:   int i = 0;",
          "143:   print_help_common();",
          "144:   while (gengetopt_args_info_help[i])",
          "145:     printf(\"%s\\n\", gengetopt_args_info_help[i++]);",
          "146: }",
          "148: void",
          "149: cmdline_parser_init (struct gengetopt_args_info *args_info)",
          "150: {",
          "151:   clear_given (args_info);",
          "152:   clear_args (args_info);",
          "153:   init_args_info (args_info);",
          "154: }",
          "156: void",
          "157: cmdline_parser_params_init(struct cmdline_parser_params *params)",
          "158: {",
          "159:   if (params)",
          "160:     {",
          "161:       params->override = 0;",
          "162:       params->initialize = 1;",
          "163:       params->check_required = 1;",
          "164:       params->check_ambiguity = 0;",
          "165:       params->print_errors = 1;",
          "166:     }",
          "167: }",
          "169: struct cmdline_parser_params *",
          "170: cmdline_parser_params_create(void)",
          "171: {",
          "172:   struct cmdline_parser_params *params =",
          "173:     (struct cmdline_parser_params *)malloc(sizeof(struct cmdline_parser_params));",
          "174:   cmdline_parser_params_init(params);",
          "175:   return params;",
          "176: }",
          "178: static void",
          "179: free_string_field (char **s)",
          "180: {",
          "181:   if (*s)",
          "182:     {",
          "183:       free (*s);",
          "185:     }",
          "186: }",
          "189: static void",
          "190: cmdline_parser_release (struct gengetopt_args_info *args_info)",
          "191: {",
          "193:   free_string_field (&(args_info->reader_orig));",
          "197:   clear_given (args_info);",
          "198: }",
          "201: static void",
          "202: write_into_file(FILE *outfile, const char *opt, const char *arg, const char *values[])",
          "203: {",
          "204:   FIX_UNUSED (values);",
          "205:   if (arg) {",
          "206:     fprintf(outfile, \"%s=\\\"%s\\\"\\n\", opt, arg);",
          "207:   } else {",
          "208:     fprintf(outfile, \"%s\\n\", opt);",
          "209:   }",
          "210: }",
          "212: static void",
          "213: write_multiple_into_file(FILE *outfile, int len, const char *opt, char **arg, const char *values[])",
          "214: {",
          "215:   int i;",
          "217:   for (i = 0; i < len; ++i)",
          "218:     write_into_file(outfile, opt, (arg ? arg[i] : 0), values);",
          "219: }",
          "221: int",
          "222: cmdline_parser_dump(FILE *outfile, struct gengetopt_args_info *args_info)",
          "223: {",
          "224:   int i = 0;",
          "226:   if (!outfile)",
          "227:     {",
          "228:       fprintf (stderr, \"%s: cannot dump options to stream\\n\", CMDLINE_PARSER_PACKAGE);",
          "229:       return EXIT_FAILURE;",
          "230:     }",
          "232:   if (args_info->help_given)",
          "233:     write_into_file(outfile, \"help\", 0, 0 );",
          "234:   if (args_info->version_given)",
          "235:     write_into_file(outfile, \"version\", 0, 0 );",
          "236:   if (args_info->reader_given)",
          "237:     write_into_file(outfile, \"reader\", args_info->reader_orig, 0);",
          "238:   write_multiple_into_file(outfile, args_info->verbose_given, \"verbose\", 0, 0);",
          "239:   if (args_info->pd_given)",
          "240:     write_into_file(outfile, \"pd\", 0, 0 );",
          "241:   if (args_info->vd_given)",
          "242:     write_into_file(outfile, \"vd\", 0, 0 );",
          "243:   if (args_info->gvd_given)",
          "244:     write_into_file(outfile, \"gvd\", 0, 0 );",
          "245:   if (args_info->vsd_status_given)",
          "246:     write_into_file(outfile, \"vsd-status\", 0, 0 );",
          "249:   i = EXIT_SUCCESS;",
          "250:   return i;",
          "251: }",
          "253: int",
          "254: cmdline_parser_file_save(const char *filename, struct gengetopt_args_info *args_info)",
          "255: {",
          "256:   FILE *outfile;",
          "257:   int i = 0;",
          "259:   outfile = fopen(filename, \"w\");",
          "261:   if (!outfile)",
          "262:     {",
          "263:       fprintf (stderr, \"%s: cannot open file for writing: %s\\n\", CMDLINE_PARSER_PACKAGE, filename);",
          "264:       return EXIT_FAILURE;",
          "265:     }",
          "267:   i = cmdline_parser_dump(outfile, args_info);",
          "268:   fclose (outfile);",
          "270:   return i;",
          "271: }",
          "273: void",
          "274: cmdline_parser_free (struct gengetopt_args_info *args_info)",
          "275: {",
          "276:   cmdline_parser_release (args_info);",
          "277: }",
          "280: char *",
          "281: gengetopt_strdup (const char *s)",
          "282: {",
          "283:   char *result = 0;",
          "284:   if (!s)",
          "285:     return result;",
          "287:   result = (char*)malloc(strlen(s) + 1);",
          "288:   if (result == (char*)0)",
          "289:     return (char*)0;",
          "290:   strcpy(result, s);",
          "291:   return result;",
          "292: }",
          "294: static int",
          "295: check_multiple_option_occurrences(const char *prog_name, unsigned int option_given, unsigned int min, unsigned int max, const char *option_desc);",
          "297: int",
          "298: check_multiple_option_occurrences(const char *prog_name, unsigned int option_given, unsigned int min, unsigned int max, const char *option_desc)",
          "299: {",
          "300:   int error_occurred = 0;",
          "302:   if (option_given && (min > 0 || max > 0))",
          "303:     {",
          "304:       if (min > 0 && max > 0)",
          "305:         {",
          "306:           if (min == max)",
          "307:             {",
          "309:               if (option_given != (unsigned int) min)",
          "310:                 {",
          "311:                   fprintf (stderr, \"%s: %s option occurrences must be %d\\n\",",
          "312:                     prog_name, option_desc, min);",
          "313:                   error_occurred = 1;",
          "314:                 }",
          "315:             }",
          "316:           else if (option_given < (unsigned int) min",
          "317:                 || option_given > (unsigned int) max)",
          "318:             {",
          "320:               fprintf (stderr, \"%s: %s option occurrences must be between %d and %d\\n\",",
          "321:                 prog_name, option_desc, min, max);",
          "322:               error_occurred = 1;",
          "323:             }",
          "324:         }",
          "325:       else if (min > 0)",
          "326:         {",
          "328:           if (option_given < min)",
          "329:             {",
          "330:               fprintf (stderr, \"%s: %s option occurrences must be at least %d\\n\",",
          "331:                 prog_name, option_desc, min);",
          "332:               error_occurred = 1;",
          "333:             }",
          "334:         }",
          "335:       else if (max > 0)",
          "336:         {",
          "338:           if (option_given > max)",
          "339:             {",
          "340:               fprintf (stderr, \"%s: %s option occurrences must be at most %d\\n\",",
          "341:                 prog_name, option_desc, max);",
          "342:               error_occurred = 1;",
          "343:             }",
          "344:         }",
          "345:     }",
          "347:   return error_occurred;",
          "348: }",
          "349: int",
          "350: cmdline_parser (int argc, char **argv, struct gengetopt_args_info *args_info)",
          "351: {",
          "352:   return cmdline_parser2 (argc, argv, args_info, 0, 1, 1);",
          "353: }",
          "355: int",
          "356: cmdline_parser_ext (int argc, char **argv, struct gengetopt_args_info *args_info,",
          "357:                    struct cmdline_parser_params *params)",
          "358: {",
          "359:   int result;",
          "360:   result = cmdline_parser_internal (argc, argv, args_info, params, 0);",
          "362:   if (result == EXIT_FAILURE)",
          "363:     {",
          "364:       cmdline_parser_free (args_info);",
          "365:       exit (EXIT_FAILURE);",
          "366:     }",
          "368:   return result;",
          "369: }",
          "371: int",
          "372: cmdline_parser2 (int argc, char **argv, struct gengetopt_args_info *args_info, int override, int initialize, int check_required)",
          "373: {",
          "374:   int result;",
          "375:   struct cmdline_parser_params params;",
          "377:   params.override = override;",
          "378:   params.initialize = initialize;",
          "379:   params.check_required = check_required;",
          "380:   params.check_ambiguity = 0;",
          "381:   params.print_errors = 1;",
          "383:   result = cmdline_parser_internal (argc, argv, args_info, &params, 0);",
          "385:   if (result == EXIT_FAILURE)",
          "386:     {",
          "387:       cmdline_parser_free (args_info);",
          "388:       exit (EXIT_FAILURE);",
          "389:     }",
          "391:   return result;",
          "392: }",
          "394: int",
          "395: cmdline_parser_required (struct gengetopt_args_info *args_info, const char *prog_name)",
          "396: {",
          "397:   int result = EXIT_SUCCESS;",
          "399:   if (cmdline_parser_required2(args_info, prog_name, 0) > 0)",
          "400:     result = EXIT_FAILURE;",
          "402:   if (result == EXIT_FAILURE)",
          "403:     {",
          "404:       cmdline_parser_free (args_info);",
          "405:       exit (EXIT_FAILURE);",
          "406:     }",
          "408:   return result;",
          "409: }",
          "411: int",
          "412: cmdline_parser_required2 (struct gengetopt_args_info *args_info, const char *prog_name, const char *additional_error)",
          "413: {",
          "414:   int error_occurred = 0;",
          "415:   FIX_UNUSED (additional_error);",
          "418:   if (check_multiple_option_occurrences(prog_name, args_info->verbose_given, args_info->verbose_min, args_info->verbose_max, \"'--verbose' ('-v')\"))",
          "419:      error_occurred = 1;",
          "424:   return error_occurred;",
          "425: }",
          "447: struct option",
          "448: {",
          "449:   const char *name;",
          "452:   int has_arg;",
          "453:   int *flag;",
          "454:   int val;",
          "455: };",
          "458:    but it behaves differently for the user, since it allows the user",
          "459:    to intersperse the options with the other arguments.",
          "461:    As `getopt' works, it permutes the elements of ARGV so that,",
          "462:    when it is done, all the options precede everything else.  Thus",
          "463:    all application programs are extended to handle flexible argument order.",
          "466:    If the field `flag' is not NULL, it points to a variable that is set",
          "467:    to the value given in the field `val' when the option is found, but",
          "468:    left unchanged if the option is not found.",
          "470:    To have a long-named option do something other than set an `int' to",
          "471:    a compiled-in constant, such as set a value from `custom_optarg', set the",
          "472:    option's `flag' field to zero and its `val' field to a nonzero",
          "473:    value (the equivalent single-letter option character, if there is",
          "474:    one).  For long options that have a zero `flag' field, `getopt'",
          "478: #ifndef no_argument",
          "479: #define no_argument  0",
          "480: #endif",
          "482: #ifndef required_argument",
          "483: #define required_argument 1",
          "484: #endif",
          "486: #ifndef optional_argument",
          "487: #define optional_argument 2",
          "488: #endif",
          "490: struct custom_getopt_data {",
          "495:  int custom_optind;",
          "496:  int custom_opterr;",
          "497:  int custom_optopt;",
          "498:  char *custom_optarg;",
          "501:  int initialized;",
          "509:  char *nextchar;",
          "516:  int first_nonopt;",
          "517:  int last_nonopt;",
          "518: };",
          "532: static char *custom_optarg;",
          "549: static int custom_optind = 1;",
          "555: static int custom_opterr = 1;",
          "561: static int custom_optopt = '?';",
          "571: static void exchange(char **argv, struct custom_getopt_data *d)",
          "572: {",
          "573:  int bottom = d->first_nonopt;",
          "574:  int middle = d->last_nonopt;",
          "575:  int top = d->custom_optind;",
          "576:  char *tem;",
          "584:  while (top > middle && middle > bottom) {",
          "585:   if (top - middle > middle - bottom) {",
          "587:    int len = middle - bottom;",
          "588:    int i;",
          "591:    for (i = 0; i < len; i++) {",
          "592:     tem = argv[bottom + i];",
          "593:     argv[bottom + i] =",
          "594:      argv[top - (middle - bottom) + i];",
          "595:     argv[top - (middle - bottom) + i] = tem;",
          "596:    }",
          "598:    top -= len;",
          "599:   } else {",
          "601:    int len = top - middle;",
          "602:    int i;",
          "605:    for (i = 0; i < len; i++) {",
          "606:     tem = argv[bottom + i];",
          "607:     argv[bottom + i] = argv[middle + i];",
          "608:     argv[middle + i] = tem;",
          "609:    }",
          "611:    bottom += len;",
          "612:   }",
          "613:  }",
          "615:  d->first_nonopt += (d->custom_optind - d->last_nonopt);",
          "616:  d->last_nonopt = d->custom_optind;",
          "617: }",
          "620: static void custom_getopt_initialize(struct custom_getopt_data *d)",
          "621: {",
          "627:  d->first_nonopt = d->last_nonopt = d->custom_optind;",
          "628:  d->nextchar = NULL;",
          "629:  d->initialized = 1;",
          "630: }",
          "632: #define NONOPTION_P (argv[d->custom_optind][0] != '-' || argv[d->custom_optind][1] == '\\0')",
          "635: static int shuffle_argv(int argc, char *const *argv,const struct option *longopts,",
          "636:  struct custom_getopt_data *d)",
          "637: {",
          "642:  if (d->last_nonopt > d->custom_optind)",
          "643:   d->last_nonopt = d->custom_optind;",
          "644:  if (d->first_nonopt > d->custom_optind)",
          "645:   d->first_nonopt = d->custom_optind;",
          "650:  if (d->first_nonopt != d->last_nonopt &&",
          "651:    d->last_nonopt != d->custom_optind)",
          "652:   exchange((char **) argv, d);",
          "653:  else if (d->last_nonopt != d->custom_optind)",
          "654:   d->first_nonopt = d->custom_optind;",
          "659:  while (d->custom_optind < argc && NONOPTION_P)",
          "660:   d->custom_optind++;",
          "661:  d->last_nonopt = d->custom_optind;",
          "667:  if (d->custom_optind != argc && !strcmp(argv[d->custom_optind], \"--\")) {",
          "668:   d->custom_optind++;",
          "669:   if (d->first_nonopt != d->last_nonopt",
          "670:     && d->last_nonopt != d->custom_optind)",
          "671:    exchange((char **) argv, d);",
          "672:   else if (d->first_nonopt == d->last_nonopt)",
          "673:    d->first_nonopt = d->custom_optind;",
          "674:   d->last_nonopt = argc;",
          "675:   d->custom_optind = argc;",
          "676:  }",
          "681:  if (d->custom_optind == argc) {",
          "686:   if (d->first_nonopt != d->last_nonopt)",
          "687:    d->custom_optind = d->first_nonopt;",
          "688:   return -1;",
          "689:  }",
          "694:  if (NONOPTION_P) {",
          "695:   d->custom_optarg = argv[d->custom_optind++];",
          "696:   return 1;",
          "697:  }",
          "702:  d->nextchar = (argv[d->custom_optind] + 1 + (longopts != NULL && argv[d->custom_optind][1] == '-'));",
          "703:  return 0;",
          "704: }",
          "716: static int check_long_opt(int argc, char *const *argv, const char *optstring,",
          "717:   const struct option *longopts, int *longind,",
          "718:   int print_errors, struct custom_getopt_data *d)",
          "719: {",
          "720:  char *nameend;",
          "721:  const struct option *p;",
          "722:  const struct option *pfound = NULL;",
          "723:  int exact = 0;",
          "724:  int ambig = 0;",
          "725:  int indfound = -1;",
          "726:  int option_index;",
          "728:  for (nameend = d->nextchar; *nameend && *nameend != '='; nameend++)",
          "732:  for (p = longopts, option_index = 0; p->name; p++, option_index++)",
          "733:   if (!strncmp(p->name, d->nextchar, nameend - d->nextchar)) {",
          "734:    if ((unsigned int) (nameend - d->nextchar)",
          "735:      == (unsigned int) strlen(p->name)) {",
          "737:     pfound = p;",
          "738:     indfound = option_index;",
          "739:     exact = 1;",
          "740:     break;",
          "741:    } else if (pfound == NULL) {",
          "743:     pfound = p;",
          "744:     indfound = option_index;",
          "745:    } else if (pfound->has_arg != p->has_arg",
          "746:      || pfound->flag != p->flag",
          "747:      || pfound->val != p->val)",
          "749:     ambig = 1;",
          "750:   }",
          "751:  if (ambig && !exact) {",
          "752:   if (print_errors) {",
          "753:    fprintf(stderr,",
          "754:     \"%s: option `%s' is ambiguous\\n\",",
          "755:     argv[0], argv[d->custom_optind]);",
          "756:   }",
          "757:   d->nextchar += strlen(d->nextchar);",
          "758:   d->custom_optind++;",
          "759:   d->custom_optopt = 0;",
          "760:   return '?';",
          "761:  }",
          "762:  if (pfound) {",
          "763:   option_index = indfound;",
          "764:   d->custom_optind++;",
          "765:   if (*nameend) {",
          "766:    if (pfound->has_arg != no_argument)",
          "767:     d->custom_optarg = nameend + 1;",
          "768:    else {",
          "769:     if (print_errors) {",
          "770:      if (argv[d->custom_optind - 1][1] == '-') {",
          "772:       fprintf(stderr, \"%s: option `--%s' doesn't allow an argument\\n\",",
          "773:        argv[0], pfound->name);",
          "774:      } else {",
          "776:       fprintf(stderr, \"%s: option `%c%s' doesn't allow an argument\\n\",",
          "777:        argv[0], argv[d->custom_optind - 1][0], pfound->name);",
          "778:      }",
          "780:     }",
          "781:     d->nextchar += strlen(d->nextchar);",
          "782:     d->custom_optopt = pfound->val;",
          "783:     return '?';",
          "784:    }",
          "785:   } else if (pfound->has_arg == required_argument) {",
          "786:    if (d->custom_optind < argc)",
          "787:     d->custom_optarg = argv[d->custom_optind++];",
          "788:    else {",
          "789:     if (print_errors) {",
          "790:      fprintf(stderr,",
          "791:       \"%s: option `%s' requires an argument\\n\",",
          "792:       argv[0],",
          "793:       argv[d->custom_optind - 1]);",
          "794:     }",
          "795:     d->nextchar += strlen(d->nextchar);",
          "796:     d->custom_optopt = pfound->val;",
          "797:     return optstring[0] == ':' ? ':' : '?';",
          "798:    }",
          "799:   }",
          "800:   d->nextchar += strlen(d->nextchar);",
          "801:   if (longind != NULL)",
          "803:   if (pfound->flag) {",
          "805:    return 0;",
          "806:   }",
          "807:   return pfound->val;",
          "808:  }",
          "814:  if (print_errors) {",
          "815:   if (argv[d->custom_optind][1] == '-') {",
          "817:    fprintf(stderr,",
          "818:     \"%s: unrecognized option `--%s'\\n\",",
          "819:     argv[0], d->nextchar);",
          "820:   } else {",
          "822:    fprintf(stderr,",
          "823:     \"%s: unrecognized option `%c%s'\\n\",",
          "824:     argv[0], argv[d->custom_optind][0],",
          "825:     d->nextchar);",
          "826:   }",
          "827:  }",
          "828:  d->nextchar = (char *) \"\";",
          "829:  d->custom_optind++;",
          "830:  d->custom_optopt = 0;",
          "831:  return '?';",
          "832: }",
          "834: static int check_short_opt(int argc, char *const *argv, const char *optstring,",
          "835:   int print_errors, struct custom_getopt_data *d)",
          "836: {",
          "837:  char c = *d->nextchar++;",
          "838:  const char *temp = strchr(optstring, c);",
          "841:  if (*d->nextchar == '\\0')",
          "842:   ++d->custom_optind;",
          "843:  if (!temp || c == ':') {",
          "844:   if (print_errors)",
          "845:    fprintf(stderr, \"%s: invalid option -- %c\\n\", argv[0], c);",
          "847:   d->custom_optopt = c;",
          "848:   return '?';",
          "849:  }",
          "850:  if (temp[1] == ':') {",
          "851:   if (temp[2] == ':') {",
          "853:    if (*d->nextchar != '\\0') {",
          "854:     d->custom_optarg = d->nextchar;",
          "855:     d->custom_optind++;",
          "856:    } else",
          "857:     d->custom_optarg = NULL;",
          "858:    d->nextchar = NULL;",
          "859:   } else {",
          "861:    if (*d->nextchar != '\\0') {",
          "862:     d->custom_optarg = d->nextchar;",
          "868:     d->custom_optind++;",
          "869:    } else if (d->custom_optind == argc) {",
          "870:     if (print_errors) {",
          "871:      fprintf(stderr,",
          "872:       \"%s: option requires an argument -- %c\\n\",",
          "873:       argv[0], c);",
          "874:     }",
          "875:     d->custom_optopt = c;",
          "876:     if (optstring[0] == ':')",
          "877:      c = ':';",
          "878:     else",
          "879:      c = '?';",
          "880:    } else",
          "886:     d->custom_optarg = argv[d->custom_optind++];",
          "887:    d->nextchar = NULL;",
          "888:   }",
          "889:  }",
          "890:  return c;",
          "891: }",
          "963: static int getopt_internal_r(int argc, char *const *argv, const char *optstring,",
          "964:   const struct option *longopts, int *longind,",
          "965:   struct custom_getopt_data *d)",
          "966: {",
          "967:  int ret, print_errors = d->custom_opterr;",
          "969:  if (optstring[0] == ':')",
          "970:   print_errors = 0;",
          "971:  if (argc < 1)",
          "972:   return -1;",
          "973:  d->custom_optarg = NULL;",
          "979:  if (d->custom_optind == 0 || !d->initialized) {",
          "980:   if (d->custom_optind == 0)",
          "982:   custom_getopt_initialize(d);",
          "983:  }",
          "984:  if (d->nextchar == NULL || *d->nextchar == '\\0') {",
          "985:   ret = shuffle_argv(argc, argv, longopts, d);",
          "986:   if (ret)",
          "987:    return ret;",
          "988:  }",
          "989:  if (longopts && (argv[d->custom_optind][1] == '-' ))",
          "990:   return check_long_opt(argc, argv, optstring, longopts,",
          "991:    longind, print_errors, d);",
          "992:  return check_short_opt(argc, argv, optstring, print_errors, d);",
          "993: }",
          "995: static int custom_getopt_internal(int argc, char *const *argv, const char *optstring,",
          "996:  const struct option *longopts, int *longind)",
          "997: {",
          "998:  int result;",
          "1000:  static struct custom_getopt_data d;",
          "1002:  d.custom_optind = custom_optind;",
          "1003:  d.custom_opterr = custom_opterr;",
          "1004:  result = getopt_internal_r(argc, argv, optstring, longopts,",
          "1005:   longind, &d);",
          "1006:  custom_optind = d.custom_optind;",
          "1007:  custom_optarg = d.custom_optarg;",
          "1008:  custom_optopt = d.custom_optopt;",
          "1009:  return result;",
          "1010: }",
          "1012: static int custom_getopt_long (int argc, char *const *argv, const char *options,",
          "1013:  const struct option *long_options, int *opt_index)",
          "1014: {",
          "1015:  return custom_getopt_internal(argc, argv, options, long_options,",
          "1016:   opt_index);",
          "1017: }",
          "1020: static char *package_name = 0;",
          "1040: static",
          "1041: int update_arg(void *field, char **orig_field,",
          "1042:                unsigned int *field_given, unsigned int *prev_given,",
          "1043:                char *value, const char *possible_values[],",
          "1044:                const char *default_value,",
          "1045:                cmdline_parser_arg_type arg_type,",
          "1046:                int check_ambiguity, int override,",
          "1047:                int no_free, int multiple_option,",
          "1048:                const char *long_opt, char short_opt,",
          "1049:                const char *additional_error)",
          "1050: {",
          "1051:   char *stop_char = 0;",
          "1052:   const char *val = value;",
          "1053:   int found;",
          "1054:   FIX_UNUSED (field);",
          "1056:   stop_char = 0;",
          "1057:   found = 0;",
          "1059:   if (!multiple_option && prev_given && (*prev_given || (check_ambiguity && *field_given)))",
          "1060:     {",
          "1061:       if (short_opt != '-')",
          "1062:         fprintf (stderr, \"%s: `--%s' (`-%c') option given more than once%s\\n\",",
          "1063:                package_name, long_opt, short_opt,",
          "1064:                (additional_error ? additional_error : \"\"));",
          "1065:       else",
          "1066:         fprintf (stderr, \"%s: `--%s' option given more than once%s\\n\",",
          "1067:                package_name, long_opt,",
          "1068:                (additional_error ? additional_error : \"\"));",
          "1070:     }",
          "1072:   FIX_UNUSED (default_value);",
          "1074:   if (field_given && *field_given && ! override)",
          "1075:     return 0;",
          "1076:   if (prev_given)",
          "1077:     (*prev_given)++;",
          "1078:   if (field_given)",
          "1079:     (*field_given)++;",
          "1080:   if (possible_values)",
          "1081:     val = possible_values[found];",
          "1083:   switch(arg_type) {",
          "1084:   case ARG_FLAG:",
          "1086:     break;",
          "1087:   case ARG_INT:",
          "1088:     if (val) *((int *)field) = strtol (val, &stop_char, 0);",
          "1089:     break;",
          "1090:   default:",
          "1091:     break;",
          "1092:   };",
          "1095:   switch(arg_type) {",
          "1096:   case ARG_INT:",
          "1097:     if (val && !(stop_char && *stop_char == '\\0')) {",
          "1098:       fprintf(stderr, \"%s: invalid numeric value: %s\\n\", package_name, val);",
          "1100:     }",
          "1101:     break;",
          "1102:   default:",
          "1103:     ;",
          "1104:   };",
          "1107:   switch(arg_type) {",
          "1108:   case ARG_NO:",
          "1109:   case ARG_FLAG:",
          "1110:     break;",
          "1111:   default:",
          "1112:     if (value && orig_field) {",
          "1113:       if (no_free) {",
          "1115:       } else {",
          "1116:         if (*orig_field)",
          "1119:       }",
          "1120:     }",
          "1121:   };",
          "1124: }",
          "1127: int",
          "1128: cmdline_parser_internal (",
          "1129:   int argc, char **argv, struct gengetopt_args_info *args_info,",
          "1130:                         struct cmdline_parser_params *params, const char *additional_error)",
          "1131: {",
          "1134:   int error_occurred = 0;",
          "1135:   struct gengetopt_args_info local_args_info;",
          "1137:   int override;",
          "1138:   int initialize;",
          "1139:   int check_required;",
          "1140:   int check_ambiguity;",
          "1142:   char *optarg;",
          "1143:   int optind;",
          "1144:   int opterr;",
          "1145:   int optopt;",
          "1147:   package_name = argv[0];",
          "1149:   override = params->override;",
          "1150:   initialize = params->initialize;",
          "1151:   check_required = params->check_required;",
          "1152:   check_ambiguity = params->check_ambiguity;",
          "1154:   if (initialize)",
          "1155:     cmdline_parser_init (args_info);",
          "1157:   cmdline_parser_init (&local_args_info);",
          "1159:   optarg = 0;",
          "1160:   optind = 0;",
          "1161:   opterr = params->print_errors;",
          "1162:   optopt = '?';",
          "1164:   while (1)",
          "1165:     {",
          "1166:       int option_index = 0;",
          "1168:       static struct option long_options[] = {",
          "1169:         { \"help\", 0, NULL, 'h' },",
          "1170:         { \"version\", 0, NULL, 'V' },",
          "1171:         { \"reader\", 1, NULL, 'r' },",
          "1172:         { \"verbose\", 0, NULL, 'v' },",
          "1173:         { \"pd\", 0, NULL, 0 },",
          "1174:         { \"vd\", 0, NULL, 0 },",
          "1175:         { \"gvd\", 0, NULL, 0 },",
          "1176:         { \"vsd-status\", 0, NULL, 0 },",
          "1177:         { 0,  0, 0, 0 }",
          "1178:       };",
          "1180:       custom_optarg = optarg;",
          "1181:       custom_optind = optind;",
          "1182:       custom_opterr = opterr;",
          "1183:       custom_optopt = optopt;",
          "1185:       c = custom_getopt_long (argc, argv, \"hVr:v\", long_options, &option_index);",
          "1187:       optarg = custom_optarg;",
          "1188:       optind = custom_optind;",
          "1189:       opterr = custom_opterr;",
          "1190:       optopt = custom_optopt;",
          "1194:       switch (c)",
          "1195:         {",
          "1197:           cmdline_parser_print_help ();",
          "1198:           cmdline_parser_free (&local_args_info);",
          "1199:           exit (EXIT_SUCCESS);",
          "1202:           cmdline_parser_print_version ();",
          "1203:           cmdline_parser_free (&local_args_info);",
          "1204:           exit (EXIT_SUCCESS);",
          "1209:           if (update_arg( (void *)&(args_info->reader_arg),",
          "1210:                &(args_info->reader_orig), &(args_info->reader_given),",
          "1211:               &(local_args_info.reader_given), optarg, 0, \"-1\", ARG_INT,",
          "1212:               check_ambiguity, override, 0, 0,",
          "1213:               \"reader\", 'r',",
          "1214:               additional_error))",
          "1215:             goto failure;",
          "1217:           break;",
          "1220:           local_args_info.verbose_given++;",
          "1222:           break;",
          "1226:           if (strcmp (long_options[option_index].name, \"pd\") == 0)",
          "1227:           {",
          "1230:             if (update_arg((void *)&(args_info->pd_flag), 0, &(args_info->pd_given),",
          "1231:                 &(local_args_info.pd_given), optarg, 0, 0, ARG_FLAG,",
          "1232:                 check_ambiguity, override, 1, 0, \"pd\", '-',",
          "1233:                 additional_error))",
          "1234:               goto failure;",
          "1236:           }",
          "1238:           else if (strcmp (long_options[option_index].name, \"vd\") == 0)",
          "1239:           {",
          "1242:             if (update_arg((void *)&(args_info->vd_flag), 0, &(args_info->vd_given),",
          "1243:                 &(local_args_info.vd_given), optarg, 0, 0, ARG_FLAG,",
          "1244:                 check_ambiguity, override, 1, 0, \"vd\", '-',",
          "1245:                 additional_error))",
          "1246:               goto failure;",
          "1248:           }",
          "1250:           else if (strcmp (long_options[option_index].name, \"gvd\") == 0)",
          "1251:           {",
          "1254:             if (update_arg((void *)&(args_info->gvd_flag), 0, &(args_info->gvd_given),",
          "1255:                 &(local_args_info.gvd_given), optarg, 0, 0, ARG_FLAG,",
          "1256:                 check_ambiguity, override, 1, 0, \"gvd\", '-',",
          "1257:                 additional_error))",
          "1258:               goto failure;",
          "1260:           }",
          "1262:           else if (strcmp (long_options[option_index].name, \"vsd-status\") == 0)",
          "1263:           {",
          "1266:             if (update_arg((void *)&(args_info->vsd_status_flag), 0, &(args_info->vsd_status_given),",
          "1267:                 &(local_args_info.vsd_status_given), optarg, 0, 0, ARG_FLAG,",
          "1268:                 check_ambiguity, override, 1, 0, \"vsd-status\", '-',",
          "1269:                 additional_error))",
          "1270:               goto failure;",
          "1272:           }",
          "1274:           break;",
          "1277:           goto failure;",
          "1280:           fprintf (stderr, \"%s: option unknown: %c%s\\n\", CMDLINE_PARSER_PACKAGE, c, (additional_error ? additional_error : \"\"));",
          "1281:           abort ();",
          "1287:   args_info->verbose_given += local_args_info.verbose_given;",
          "1288:   local_args_info.verbose_given = 0;",
          "1290:   if (check_required)",
          "1291:     {",
          "1292:       error_occurred += cmdline_parser_required2 (args_info, argv[0], additional_error);",
          "1293:     }",
          "1295:   cmdline_parser_release (&local_args_info);",
          "1297:   if ( error_occurred )",
          "1298:     return (EXIT_FAILURE);",
          "1300:   return 0;",
          "1302: failure:",
          "1304:   cmdline_parser_release (&local_args_info);",
          "1305:   return (EXIT_FAILURE);",
          "1306: }",
          "",
          "---------------"
        ],
        "src/tools/egk-tool-cmdline.h||src/tools/egk-tool-cmdline.h": [
          "File: src/tools/egk-tool-cmdline.h -> src/tools/egk-tool-cmdline.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "8: #ifndef EGK_TOOL_CMDLINE_H",
          "9: #define EGK_TOOL_CMDLINE_H",
          "12: #ifdef HAVE_CONFIG_H",
          "13: #include \"config.h\"",
          "14: #endif",
          "18: #ifdef __cplusplus",
          "19: extern \"C\" {",
          "22: #ifndef CMDLINE_PARSER_PACKAGE",
          "24: #define CMDLINE_PARSER_PACKAGE \"egk-tool\"",
          "25: #endif",
          "27: #ifndef CMDLINE_PARSER_PACKAGE_NAME",
          "29: #define CMDLINE_PARSER_PACKAGE_NAME \"egk-tool\"",
          "30: #endif",
          "32: #ifndef CMDLINE_PARSER_VERSION",
          "34: #define CMDLINE_PARSER_VERSION VERSION",
          "35: #endif",
          "38: struct gengetopt_args_info",
          "39: {",
          "66: } ;",
          "69: struct cmdline_parser_params",
          "70: {",
          "76: } ;",
          "79: extern const char *gengetopt_args_info_purpose;",
          "81: extern const char *gengetopt_args_info_usage;",
          "83: extern const char *gengetopt_args_info_description;",
          "85: extern const char *gengetopt_args_info_help[];",
          "94: int cmdline_parser (int argc, char **argv,",
          "95:   struct gengetopt_args_info *args_info);",
          "108: int cmdline_parser2 (int argc, char **argv,",
          "109:   struct gengetopt_args_info *args_info,",
          "110:   int override, int initialize, int check_required);",
          "120: int cmdline_parser_ext (int argc, char **argv,",
          "121:   struct gengetopt_args_info *args_info,",
          "122:   struct cmdline_parser_params *params);",
          "130: int cmdline_parser_dump(FILE *outfile,",
          "131:   struct gengetopt_args_info *args_info);",
          "140: int cmdline_parser_file_save(const char *filename,",
          "141:   struct gengetopt_args_info *args_info);",
          "146: void cmdline_parser_print_help(void);",
          "150: void cmdline_parser_print_version(void);",
          "157: void cmdline_parser_params_init(struct cmdline_parser_params *params);",
          "164: struct cmdline_parser_params *cmdline_parser_params_create(void);",
          "171: void cmdline_parser_init (struct gengetopt_args_info *args_info);",
          "177: void cmdline_parser_free (struct gengetopt_args_info *args_info);",
          "186: int cmdline_parser_required (struct gengetopt_args_info *args_info,",
          "187:   const char *prog_name);",
          "190: #ifdef __cplusplus",
          "191: }",
          "",
          "---------------"
        ],
        "src/tools/egk-tool.1||src/tools/egk-tool.1": [
          "File: src/tools/egk-tool.1 -> src/tools/egk-tool.1",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: .\\\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.47.4.",
          "2: .TH EGK-TOOL \"1\" \"Oktober 2017\" \"OpenSC 0.17.0\" \"User Commands\"",
          "3: .SH NAME",
          "4: egk-tool \\- manual page for egk-tool 0.17.0",
          "5: .SH SYNOPSIS",
          "6: .B egk-tool",
          "7: [\\fI\\,OPTIONS\\/\\fR]...",
          "8: .SH DESCRIPTION",
          "9: egk\\-tool 0.17.0",
          "10: .TP",
          "11: \\fB\\-h\\fR, \\fB\\-\\-help\\fR",
          "12: Print help and exit",
          "13: .TP",
          "14: \\fB\\-V\\fR, \\fB\\-\\-version\\fR",
          "15: Print version and exit",
          "16: .TP",
          "17: \\fB\\-r\\fR, \\fB\\-\\-reader\\fR=\\fI\\,INT\\/\\fR",
          "18: Number of the PC/SC reader to use (\\fB\\-1\\fR for autodetect)",
          "19: (default=`\\-1')",
          "20: .TP",
          "21: \\fB\\-v\\fR, \\fB\\-\\-verbose\\fR",
          "22: Use (several times) to be more verbose",
          "23: .SS \"Health Care Application (HCA):\"",
          "24: .TP",
          "25: \\fB\\-\\-pd\\fR",
          "26: Show 'Pers\u00f6nliche Versicherungsdaten' (XML)  (default=off)",
          "27: .TP",
          "28: \\fB\\-\\-vd\\fR",
          "29: Show 'Allgemeine Versicherungsdaten' (XML)  (default=off)",
          "30: .TP",
          "31: \\fB\\-\\-gvd\\fR",
          "32: Show 'Gesch\u00fctzte Versicherungsdaten' (XML)  (default=off)",
          "33: .TP",
          "34: \\fB\\-\\-vsd\\-status\\fR",
          "35: Show 'Versichertenstammdaten\\-Status'  (default=off)",
          "36: .SH AUTHOR",
          "37: Written by Frank Morgner <frankmorgner@gmail.com>",
          "38: .SH \"REPORTING BUGS\"",
          "39: Report bugs to opensc\\-devel@lists.sourceforge.net",
          "",
          "---------------"
        ],
        "src/tools/egk-tool.c||src/tools/egk-tool.c": [
          "File: src/tools/egk-tool.c -> src/tools/egk-tool.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "20: #ifdef HAVE_CONFIG_H",
          "21: #include \"config.h\"",
          "22: #endif",
          "24: #include \"egk-tool-cmdline.h\"",
          "25: #include \"libopensc/log.h\"",
          "26: #include \"libopensc/opensc.h\"",
          "27: #include <ctype.h>",
          "28: #include <stdlib.h>",
          "29: #include <string.h>",
          "31: #ifdef _WIN32",
          "32: #include <io.h>",
          "33: #include <fcntl.h>",
          "34: #endif",
          "36: #ifdef ENABLE_ZLIB",
          "37: #include <zlib.h>",
          "39: int uncompress_gzip(void* uncompressed, size_t *uncompressed_len,",
          "40:   const void* compressed, size_t compressed_len)",
          "41: {",
          "42:  z_stream stream;",
          "43:  memset(&stream, 0, sizeof stream);",
          "44:  stream.total_in = compressed_len;",
          "45:  stream.avail_in = compressed_len;",
          "46:  stream.total_out = *uncompressed_len;",
          "47:  stream.avail_out = *uncompressed_len;",
          "48:  stream.next_in = (Bytef *) compressed;",
          "49:  stream.next_out = (Bytef *) uncompressed;",
          "52:  if (Z_OK == inflateInit2(&stream, (15 + 32))",
          "53:    && Z_STREAM_END == inflate(&stream, Z_FINISH)) {",
          "55:  } else {",
          "56:   return SC_ERROR_INVALID_DATA;",
          "57:  }",
          "58:  inflateEnd(&stream);",
          "60:  return SC_SUCCESS;",
          "61: }",
          "62: #else",
          "63: int uncompress_gzip(const void* compressed, size_t compressed_len,",
          "64:      void* uncompressed, size_t *uncompressed_len)",
          "65: {",
          "66:  return SC_ERROR_NOT_SUPPORTED;",
          "67: }",
          "68: #endif",
          "70: #define PRINT(c) (isprint(c) ? c : '?')",
          "72: void dump_binary(void *buf, size_t buf_len)",
          "73: {",
          "74: #ifdef _WIN32",
          "75:  _setmode(fileno(stdout), _O_BINARY);",
          "76: #endif",
          "77:  fwrite(buf, 1, buf_len, stdout);",
          "78: #ifdef _WIN32",
          "79:  _setmode(fileno(stdout), _O_TEXT);",
          "80: #endif",
          "81: }",
          "83: const unsigned char aid_hca[] = {0xD2, 0x76, 0x00, 0x00, 0x01, 0x02};",
          "85: static int initialize(int reader_id, int verbose,",
          "86:   sc_context_t **ctx, sc_reader_t **reader)",
          "87: {",
          "88:  unsigned int i, reader_count;",
          "89:  int r;",
          "91:  if (!ctx || !reader)",
          "92:   return SC_ERROR_INVALID_ARGUMENTS;",
          "94:  r = sc_establish_context(ctx, \"\");",
          "95:  if (r < 0 || !*ctx) {",
          "96:   fprintf(stderr, \"Failed to create initial context: %s\", sc_strerror(r));",
          "97:   return r;",
          "98:  }",
          "100:  (*ctx)->debug = verbose;",
          "101:  (*ctx)->flags |= SC_CTX_FLAG_ENABLE_DEFAULT_DRIVER;",
          "103:  reader_count = sc_ctx_get_reader_count(*ctx);",
          "105:  if (reader_count == 0) {",
          "106:   sc_debug(*ctx, SC_LOG_DEBUG_NORMAL, \"No reader not found.\\n\");",
          "107:   return SC_ERROR_NO_READERS_FOUND;",
          "108:  }",
          "110:  if (reader_id < 0) {",
          "112:   for (i = 0; i < reader_count; i++) {",
          "114:    if (sc_detect_card_presence(*reader) & SC_READER_CARD_PRESENT) {",
          "115:     reader_id = i;",
          "116:     sc_debug(*ctx, SC_LOG_DEBUG_NORMAL, \"Using the first reader\"",
          "117:       \" with a card: %s\", (*reader)->name);",
          "118:     break;",
          "119:    }",
          "120:   }",
          "121:   if ((unsigned int) reader_id >= reader_count) {",
          "122:    sc_debug(*ctx, SC_LOG_DEBUG_NORMAL, \"No card found, using the first reader.\");",
          "123:    reader_id = 0;",
          "124:   }",
          "125:  }",
          "127:  if ((unsigned int) reader_id >= reader_count) {",
          "128:   sc_debug(*ctx, SC_LOG_DEBUG_NORMAL, \"Invalid reader number \"",
          "129:     \"(%d), only %d available.\\n\", reader_id, reader_count);",
          "130:   return SC_ERROR_NO_READERS_FOUND;",
          "131:  }",
          "135:  return SC_SUCCESS;",
          "136: }",
          "138: int read_file(struct sc_card *card, char *str_path, unsigned char **data, size_t *data_len)",
          "139: {",
          "140:  struct sc_path path;",
          "141:  struct sc_file *file;",
          "142:  unsigned char *p;",
          "143:  int ok = 0;",
          "144:  int r;",
          "145:  size_t len;",
          "147:  sc_format_path(str_path, &path);",
          "148:  if (SC_SUCCESS != sc_select_file(card, &path, &file)) {",
          "149:   goto err;",
          "150:  }",
          "152:  len = file ? file->size : 4096;",
          "153:  p = realloc(*data, len);",
          "154:  if (!p) {",
          "155:   goto err;",
          "156:  }",
          "160:  r = sc_read_binary(card, 0, p, len, 0);",
          "161:  if (r < 0)",
          "162:   goto err;",
          "165:  ok = 1;",
          "167: err:",
          "168:  sc_file_free(file);",
          "170:  return ok;",
          "171: }",
          "173: void decode_version(unsigned char *bcd, unsigned int *major, unsigned int *minor, unsigned int *fix)",
          "174: {",
          "180:  if ((bcd[0]>>4) < 10 && ((bcd[0]&0xF) < 10) && ((bcd[1]>>4) < 10)) {",
          "182:  }",
          "183:  if (((bcd[1]&0xF) < 10) && ((bcd[2]>>4) < 10) && ((bcd[2]&0xF) < 10)) {",
          "185:  }",
          "186:  if ((bcd[3]>>4) < 10 && ((bcd[3]&0xF) < 10)",
          "187:    && (bcd[4]>>4) < 10 && ((bcd[4]&0xF) < 10)) {",
          "189:    + (bcd[4]>>4)*10 + (bcd[4]&0xF);",
          "190:  }",
          "191: }",
          "193: int",
          "194: main (int argc, char **argv)",
          "195: {",
          "196:  struct gengetopt_args_info cmdline;",
          "197:  struct sc_path path;",
          "198:  struct sc_context *ctx;",
          "199:  struct sc_reader *reader;",
          "200:  struct sc_card *card;",
          "201:  unsigned char *data = NULL;",
          "202:  size_t data_len = 0;",
          "203:  int r;",
          "205:  if (cmdline_parser(argc, argv, &cmdline) != 0)",
          "206:   exit(1);",
          "208:  r = initialize(cmdline.reader_arg, cmdline.verbose_given, &ctx, &reader);",
          "209:  if (r < 0) {",
          "210:   fprintf(stderr, \"Can't initialize reader\\n\");",
          "211:   exit(1);",
          "212:  }",
          "214:  if (sc_connect_card(reader, &card) < 0) {",
          "215:   fprintf(stderr, \"Could not connect to card\\n\");",
          "216:   sc_release_context(ctx);",
          "217:   exit(1);",
          "218:  }",
          "220:  sc_path_set(&path, SC_PATH_TYPE_DF_NAME, aid_hca, sizeof aid_hca, 0, 0);",
          "221:  if (SC_SUCCESS != sc_select_file(card, &path, NULL))",
          "222:   goto err;",
          "224:  if (cmdline.pd_flag",
          "225:    && read_file(card, \"D001\", &data, &data_len)",
          "226:    && data_len >= 2) {",
          "227:   size_t len_pd = (data[0] << 8) | data[1];",
          "229:   if (len_pd + 2 <= data_len) {",
          "230:    unsigned char uncompressed[1024];",
          "231:    size_t uncompressed_len = sizeof uncompressed;",
          "233:    if (uncompress_gzip(uncompressed, &uncompressed_len,",
          "234:       data + 2, len_pd) == SC_SUCCESS) {",
          "235:     dump_binary(uncompressed, uncompressed_len);",
          "236:    } else {",
          "237:     dump_binary(data + 2, len_pd);",
          "238:    }",
          "239:   }",
          "240:  }",
          "242:  if ((cmdline.vd_flag || cmdline.gvd_flag)",
          "243:    && read_file(card, \"D001\", &data, &data_len)",
          "244:    && data_len >= 8) {",
          "245:   size_t off_vd  = (data[0] << 8) | data[1];",
          "246:   size_t end_vd  = (data[2] << 8) | data[3];",
          "247:   size_t off_gvd = (data[4] << 8) | data[5];",
          "248:   size_t end_gvd = (data[6] << 8) | data[7];",
          "249:   size_t len_vd = end_vd - off_vd + 1;",
          "250:   size_t len_gvd = end_gvd - off_gvd + 1;",
          "252:   if (off_vd <= end_vd && end_vd < data_len",
          "253:     && off_gvd <= end_gvd && end_gvd < data_len) {",
          "254:    unsigned char uncompressed[1024];",
          "255:    size_t uncompressed_len = sizeof uncompressed;",
          "257:    if (cmdline.vd_flag) {",
          "258:     if (uncompress_gzip(uncompressed, &uncompressed_len,",
          "259:        data + off_vd, len_vd) == SC_SUCCESS) {",
          "260:      dump_binary(uncompressed, uncompressed_len);",
          "261:     } else {",
          "262:      dump_binary(data + off_vd, len_vd);",
          "263:     }",
          "264:    }",
          "266:    if (cmdline.gvd_flag) {",
          "267:     if (uncompress_gzip(uncompressed, &uncompressed_len,",
          "268:        data + off_gvd, len_gvd) == SC_SUCCESS) {",
          "269:      dump_binary(uncompressed, uncompressed_len);",
          "270:     } else {",
          "271:      dump_binary(data + off_gvd, len_gvd);",
          "272:     }",
          "273:    }",
          "274:   }",
          "275:  }",
          "277:  if (cmdline.vsd_status_flag",
          "278:    && read_file(card, \"D00C\", &data, &data_len)",
          "279:    && data_len >= 25) {",
          "280:   char *status;",
          "281:   unsigned int major, minor, fix;",
          "283:   switch (data[0]) {",
          "284:    case '0':",
          "285:     status = \"Transactions pending\";",
          "286:     break;",
          "287:    case '1':",
          "288:     status = \"No transactions pending\";",
          "289:     break;",
          "290:    default:",
          "291:     status = \"Unknown\";",
          "292:     break;",
          "293:   }",
          "295:   decode_version(data+15, &major, &minor, &fix);",
          "297:   printf(",
          "298:     \"Status      %s\\n\"",
          "299:     \"Timestamp   %c%c.%c%c.%c%c%c%c at %c%c:%c%c:%c%c\\n\"",
          "300:     \"Version     %u.%u.%u\\n\",",
          "301:     status,",
          "302:     PRINT(data[7]), PRINT(data[8]),",
          "303:     PRINT(data[5]), PRINT(data[6]),",
          "304:     PRINT(data[1]), PRINT(data[2]), PRINT(data[3]), PRINT(data[4]),",
          "305:     PRINT(data[9]), PRINT(data[10]),",
          "306:     PRINT(data[11]), PRINT(data[12]),",
          "307:     PRINT(data[13]), PRINT(data[14]),",
          "308:     major, minor, fix);",
          "309:  }",
          "311: err:",
          "312:  sc_disconnect_card(card);",
          "313:  sc_release_context(ctx);",
          "314:  cmdline_parser_free (&cmdline);",
          "316:  return 0;",
          "317: }",
          "",
          "---------------"
        ],
        "src/tools/egk-tool.ggo.in||src/tools/egk-tool.ggo.in": [
          "File: src/tools/egk-tool.ggo.in -> src/tools/egk-tool.ggo.in",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: package \"egk-tool\"",
          "2: purpose \"@PACKAGE_SUMMARY@\"",
          "4: option \"reader\" r",
          "5:     \"Number of the PC/SC reader to use (-1 for autodetect)\"",
          "6:     int",
          "7:     default=\"-1\"",
          "8:     optional",
          "9: option \"verbose\" v",
          "10:     \"Use (several times) to be more verbose\"",
          "11:     multiple",
          "12:     optional",
          "14: section \"Health Care Application (HCA)\"",
          "15: option \"pd\" -",
          "16:     \"Show 'Pers\u00f6nliche Versicherungsdaten' (@VDFORMAT@)\"",
          "17:     flag off",
          "18: option \"vd\" -",
          "19:     \"Show 'Allgemeine Versicherungsdaten' (@VDFORMAT@)\"",
          "20:     flag off",
          "21: option \"gvd\" -",
          "22:     \"Show 'Gesch\u00fctzte Versicherungsdaten' (@VDFORMAT@)\"",
          "23:     flag off",
          "24: option \"vsd-status\" -",
          "25:     \"Show 'Versichertenstammdaten-Status'\"",
          "26:     flag off",
          "28: text \"",
          "29: Report bugs to @PACKAGE_BUGREPORT@",
          "31: Written by Frank Morgner <frankmorgner@gmail.com>\"",
          "",
          "---------------"
        ],
        "src/tools/opensc-notify.1||src/tools/opensc-notify.1": [
          "File: src/tools/opensc-notify.1 -> src/tools/opensc-notify.1",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: .\\\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.47.4.",
          "2: .TH OPENSC-NOTIFY \"1\" \"Oktober 2017\" \"OpenSC 0.17.0\" \"User Commands\"",
          "3: .SH NAME",
          "4: opensc-notify \\- manual page for opensc-notify 0.17.0",
          "5: .SH SYNOPSIS",
          "6: .B opensc-notify",
          "7: [\\fI\\,OPTIONS\\/\\fR]...",
          "8: .SH DESCRIPTION",
          "9: opensc\\-notify 0.17.0",
          "10: .PP",
          "11: If no arguments are given, monitor smart card events and send the appropriate",
          "12: notification.",
          "13: .TP",
          "14: \\fB\\-h\\fR, \\fB\\-\\-help\\fR",
          "15: Print help and exit",
          "16: .TP",
          "17: \\fB\\-V\\fR, \\fB\\-\\-version\\fR",
          "18: Print version and exit",
          "19: .IP",
          "20: Mode: customized",
          "21: .IP",
          "22: Send customized notifications.",
          "23: \\fB\\-t\\fR, \\fB\\-\\-title\\fR[=\\fI\\,STRING\\/\\fR]        Title of the notification",
          "24: \\fB\\-m\\fR, \\fB\\-\\-message\\fR[=\\fI\\,STRING\\/\\fR]      Main text of the notification",
          "25: .IP",
          "26: Mode: standard",
          "27: .IP",
          "28: Manually send standard notifications.",
          "29: \\fB\\-I\\fR, \\fB\\-\\-notify\\-card\\-inserted\\fR  See notify_card_inserted in opensc.conf",
          "30: .IP",
          "31: (default=off)",
          "32: .TP",
          "33: \\fB\\-R\\fR, \\fB\\-\\-notify\\-card\\-removed\\fR",
          "34: See notify_card_inserted in opensc.conf",
          "35: (default=off)",
          "36: .TP",
          "37: \\fB\\-G\\fR, \\fB\\-\\-notify\\-pin\\-good\\fR",
          "38: See notify_pin_good in opensc.conf  (default=off)",
          "39: .TP",
          "40: \\fB\\-B\\fR, \\fB\\-\\-notify\\-pin\\-bad\\fR",
          "41: See notify_pin_bad in opensc.conf  (default=off)",
          "42: .SH AUTHOR",
          "43: Written by Frank Morgner <frankmorgner@gmail.com>",
          "44: .SH \"REPORTING BUGS\"",
          "45: Report bugs to opensc\\-devel@lists.sourceforge.net",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "0b44793900ee9ad72909242da761702e23b12167",
      "candidate_info": {
        "commit_hash": "0b44793900ee9ad72909242da761702e23b12167",
        "repo": "OpenSC/OpenSC",
        "commit_url": "https://github.com/OpenSC/OpenSC/commit/0b44793900ee9ad72909242da761702e23b12167",
        "files": [
          "src/libopensc/card-tcos.c"
        ],
        "message": "tcos: use ISO7816 fci parser",
        "before_after_code_files": [
          "src/libopensc/card-tcos.c||src/libopensc/card-tcos.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/libopensc/card-tcos.c||src/libopensc/card-tcos.c"
          ],
          "candidate": [
            "src/libopensc/card-tcos.c||src/libopensc/card-tcos.c"
          ]
        }
      },
      "candidate_diff": {
        "src/libopensc/card-tcos.c||src/libopensc/card-tcos.c": [
          "File: src/libopensc/card-tcos.c -> src/libopensc/card-tcos.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "343:  sc_apdu_t apdu;",
          "344:  sc_file_t *file=NULL;",
          "345:  u8 buf[SC_MAX_APDU_BUFFER_SIZE], pathbuf[SC_MAX_PATH_SIZE], *path = pathbuf;",
          "347:  int r, pathlen;",
          "349:  assert(card != NULL && in_path != NULL);",
          "",
          "[Removed Lines]",
          "346:  unsigned int i;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "408:  file->path = *in_path;",
          "447:  parse_sec_attr(card, file, file->sec_attr, file->sec_attr_len);",
          "",
          "[Removed Lines]",
          "410:  for(i=2; i+1<apdu.resplen && i+1+apdu.resp[i+1]<apdu.resplen; i+=2+apdu.resp[i+1]){",
          "411:   size_t j, len=apdu.resp[i+1];",
          "412:   unsigned char type=apdu.resp[i], *d=apdu.resp+i+2;",
          "414:   switch (type) {",
          "415:   case 0x80:",
          "416:   case 0x81:",
          "417:    file->size=0;",
          "418:    for(j=0; j<len; ++j) file->size = (file->size<<8) | d[j];",
          "419:    break;",
          "420:   case 0x82:",
          "421:    file->shareable = (d[0] & 0x40) ? 1 : 0;",
          "422:    file->ef_structure = d[0] & 7;",
          "423:    switch ((d[0]>>3) & 7) {",
          "424:    case 0: file->type = SC_FILE_TYPE_WORKING_EF; break;",
          "425:    case 7: file->type = SC_FILE_TYPE_DF; break;",
          "426:    default:",
          "427:     sc_debug(ctx, SC_LOG_DEBUG_NORMAL, \"invalid file type %02X in file descriptor\\n\", d[0]);",
          "428:     SC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_UNKNOWN_DATA_RECEIVED);",
          "429:    }",
          "430:    break;",
          "431:   case 0x83:",
          "432:    file->id = (d[0]<<8) | d[1];",
          "433:    break;",
          "434:   case 0x84:",
          "435:    file->namelen = MIN(sizeof file->name, len);",
          "436:    memcpy(file->name, d, file->namelen);",
          "437:    break;",
          "438:   case 0x86:",
          "439:    sc_file_set_sec_attr(file, d, len);",
          "440:    break;",
          "441:   default:",
          "442:    if (len>0) sc_file_set_prop_attr(file, d, len);",
          "443:   }",
          "444:  }",
          "445:  file->magic = SC_FILE_MAGIC;",
          "",
          "[Added Lines]",
          "409:  iso_ops->process_fci(card, file, apdu.resp, apdu.resplen);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
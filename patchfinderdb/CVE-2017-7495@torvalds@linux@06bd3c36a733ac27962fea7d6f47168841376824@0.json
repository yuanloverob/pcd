{
  "cve_id": "CVE-2017-7495",
  "cve_desc": "fs/ext4/inode.c in the Linux kernel before 4.6.2, when ext4 data=ordered mode is used, mishandles a needs-flushing-before-commit list, which allows local users to obtain sensitive information from other users' files in opportunistic circumstances by waiting for a hardware reset, creating a new file, making write system calls, and reading this file.",
  "repo": "torvalds/linux",
  "patch_hash": "06bd3c36a733ac27962fea7d6f47168841376824",
  "patch_info": {
    "commit_hash": "06bd3c36a733ac27962fea7d6f47168841376824",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/06bd3c36a733ac27962fea7d6f47168841376824",
    "files": [
      "fs/ext4/inode.c"
    ],
    "message": "ext4: fix data exposure after a crash\n\nHuang has reported that in his powerfail testing he is seeing stale\nblock contents in some of recently allocated blocks although he mounts\next4 in data=ordered mode. After some investigation I have found out\nthat indeed when delayed allocation is used, we don't add inode to\ntransaction's list of inodes needing flushing before commit. Originally\nwe were doing that but commit f3b59291a69d removed the logic with a\nflawed argument that it is not needed.\n\nThe problem is that although for delayed allocated blocks we write their\ncontents immediately after allocating them, there is no guarantee that\nthe IO scheduler or device doesn't reorder things and thus transaction\nallocating blocks and attaching them to inode can reach stable storage\nbefore actual block contents. Actually whenever we attach freshly\nallocated blocks to inode using a written extent, we should add inode to\ntransaction's ordered inode list to make sure we properly wait for block\ncontents to be written before committing the transaction. So that is\nwhat we do in this patch. This also handles other cases where stale data\nexposure was possible - like filling hole via mmap in\ndata=ordered,nodelalloc mode.\n\nThe only exception to the above rule are extending direct IO writes where\nblkdev_direct_IO() waits for IO to complete before increasing i_size and\nthus stale data exposure is not possible. For now we don't complicate\nthe code with optimizing this special case since the overhead is pretty\nlow. In case this is observed to be a performance problem we can always\nhandle it using a special flag to ext4_map_blocks().\n\nCC: stable@vger.kernel.org\nFixes: f3b59291a69d0b734be1fc8be489fef2dd846d3d\nReported-by: \"HUANG Weller (CM/ESW12-CN)\" <Weller.Huang@cn.bosch.com>\nTested-by: \"HUANG Weller (CM/ESW12-CN)\" <Weller.Huang@cn.bosch.com>\nSigned-off-by: Jan Kara <jack@suse.cz>\nSigned-off-by: Theodore Ts'o <tytso@mit.edu>",
    "before_after_code_files": [
      "fs/ext4/inode.c||fs/ext4/inode.c"
    ]
  },
  "patch_diff": {
    "fs/ext4/inode.c||fs/ext4/inode.c": [
      "File: fs/ext4/inode.c -> fs/ext4/inode.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "684:   ret = check_block_validity(inode, map);",
      "685:   if (ret != 0)",
      "686:    return ret;",
      "687:  }",
      "688:  return retval;",
      "689: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "693:   if (map->m_flags & EXT4_MAP_NEW &&",
      "694:       !(map->m_flags & EXT4_MAP_UNWRITTEN) &&",
      "695:       !(flags & EXT4_GET_BLOCKS_ZERO) &&",
      "696:       !IS_NOQUOTA(inode) &&",
      "697:       ext4_should_order_data(inode)) {",
      "698:    ret = ext4_jbd2_file_inode(handle, inode);",
      "699:    if (ret)",
      "700:     return ret;",
      "701:   }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1289:  int i_size_changed = 0;",
      "1291:  trace_ext4_write_end(inode, pos, len, copied);",
      "1301:  if (ext4_has_inline_data(inode)) {",
      "1302:   ret = ext4_write_inline_data_end(inode, pos, len,",
      "1303:        copied, page);",
      "",
      "[Removed Lines]",
      "1292:  if (ext4_test_inode_state(inode, EXT4_STATE_ORDERED_MODE)) {",
      "1293:   ret = ext4_jbd2_file_inode(handle, inode);",
      "1294:   if (ret) {",
      "1295:    unlock_page(page);",
      "1296:    put_page(page);",
      "1297:    goto errout;",
      "1298:   }",
      "1299:  }",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "ee0876bc69ee8d24d524fb2e9e41e3682aaebb11",
      "candidate_info": {
        "commit_hash": "ee0876bc69ee8d24d524fb2e9e41e3682aaebb11",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/ee0876bc69ee8d24d524fb2e9e41e3682aaebb11",
        "files": [
          "fs/ext4/ext4.h",
          "fs/ext4/ext4_jbd2.h",
          "fs/ext4/inode.c",
          "fs/ext4/move_extent.c"
        ],
        "message": "ext4: do not ask jbd2 to write data for delalloc buffers\n\nCurrently we ask jbd2 to write all dirty allocated buffers before\ncommitting a transaction when doing writeback of delay allocated blocks.\nHowever this is unnecessary since we move all pages to writeback state\nbefore dropping a transaction handle and then submit all the necessary\nIO. We still need the transaction commit to wait for all the outstanding\nwriteback before flushing disk caches during transaction commit to avoid\ndata exposure issues though. Use the new jbd2 capability and ask it to\nonly wait for outstanding writeback during transaction commit when\nwriting back data in ext4_writepages().\n\nTested-by: \"HUANG Weller (CM/ESW12-CN)\" <Weller.Huang@cn.bosch.com>\nSigned-off-by: Jan Kara <jack@suse.cz>\nSigned-off-by: Theodore Ts'o <tytso@mit.edu>",
        "before_after_code_files": [
          "fs/ext4/ext4.h||fs/ext4/ext4.h",
          "fs/ext4/ext4_jbd2.h||fs/ext4/ext4_jbd2.h",
          "fs/ext4/inode.c||fs/ext4/inode.c",
          "fs/ext4/move_extent.c||fs/ext4/move_extent.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/ext4/inode.c||fs/ext4/inode.c"
          ],
          "candidate": [
            "fs/ext4/inode.c||fs/ext4/inode.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/ext4/ext4.h||fs/ext4/ext4.h": [
          "File: fs/ext4/ext4.h -> fs/ext4/ext4.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "581: #define EXT4_GET_BLOCKS_ZERO   0x0200",
          "582: #define EXT4_GET_BLOCKS_CREATE_ZERO  (EXT4_GET_BLOCKS_CREATE |\\",
          "583:      EXT4_GET_BLOCKS_ZERO)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "586: #define EXT4_GET_BLOCKS_IO_SUBMIT  0x0400",
          "",
          "---------------"
        ],
        "fs/ext4/ext4_jbd2.h||fs/ext4/ext4_jbd2.h": [
          "File: fs/ext4/ext4_jbd2.h -> fs/ext4/ext4_jbd2.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "359:  return 0;",
          "360: }",
          "363: {",
          "364:  if (ext4_handle_valid(handle))",
          "365:   return jbd2_journal_inode_add_write(handle,",
          "",
          "[Removed Lines]",
          "362: static inline int ext4_jbd2_file_inode(handle_t *handle, struct inode *inode)",
          "",
          "[Added Lines]",
          "362: static inline int ext4_jbd2_inode_add_write(handle_t *handle,",
          "363:          struct inode *inode)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "367:  return 0;",
          "368: }",
          "370: static inline void ext4_update_inode_fsync_trans(handle_t *handle,",
          "371:        struct inode *inode,",
          "372:        int datasync)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "371: static inline int ext4_jbd2_inode_add_wait(handle_t *handle,",
          "372:         struct inode *inode)",
          "373: {",
          "374:  if (ext4_handle_valid(handle))",
          "375:   return jbd2_journal_inode_add_wait(handle,",
          "376:          EXT4_I(inode)->jinode);",
          "377:  return 0;",
          "378: }",
          "",
          "---------------"
        ],
        "fs/ext4/inode.c||fs/ext4/inode.c": [
          "File: fs/ext4/inode.c -> fs/ext4/inode.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "695:       !(flags & EXT4_GET_BLOCKS_ZERO) &&",
          "696:       !IS_NOQUOTA(inode) &&",
          "697:       ext4_should_order_data(inode)) {",
          "699:    if (ret)",
          "700:     return ret;",
          "701:   }",
          "",
          "[Removed Lines]",
          "698:    ret = ext4_jbd2_file_inode(handle, inode);",
          "",
          "[Added Lines]",
          "698:    if (flags & EXT4_GET_BLOCKS_IO_SUBMIT)",
          "699:     ret = ext4_jbd2_inode_add_wait(handle, inode);",
          "700:    else",
          "701:     ret = ext4_jbd2_inode_add_write(handle, inode);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2321:  get_blocks_flags = EXT4_GET_BLOCKS_CREATE |",
          "2323:  dioread_nolock = ext4_should_dioread_nolock(inode);",
          "2324:  if (dioread_nolock)",
          "2325:   get_blocks_flags |= EXT4_GET_BLOCKS_IO_CREATE_EXT;",
          "",
          "[Removed Lines]",
          "2322:       EXT4_GET_BLOCKS_METADATA_NOFAIL;",
          "",
          "[Added Lines]",
          "2325:       EXT4_GET_BLOCKS_METADATA_NOFAIL |",
          "2326:       EXT4_GET_BLOCKS_IO_SUBMIT;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3634:   err = 0;",
          "3635:   mark_buffer_dirty(bh);",
          "3636:   if (ext4_should_order_data(inode))",
          "3638:  }",
          "3640: unlock:",
          "",
          "[Removed Lines]",
          "3637:    err = ext4_jbd2_file_inode(handle, inode);",
          "",
          "[Added Lines]",
          "3641:    err = ext4_jbd2_inode_add_write(handle, inode);",
          "",
          "---------------"
        ],
        "fs/ext4/move_extent.c||fs/ext4/move_extent.c": [
          "File: fs/ext4/move_extent.c -> fs/ext4/move_extent.c"
        ]
      }
    }
  ]
}
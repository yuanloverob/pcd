{
  "cve_id": "CVE-2021-31566",
  "cve_desc": "An improper link resolution flaw can occur while extracting an archive leading to changing modes, times, access control lists, and flags of a file outside of the archive. An attacker may provide a malicious archive to a victim user, who would trigger this flaw when trying to extract the archive. A local attacker may use this flaw to gain more privileges in a system.",
  "repo": "libarchive/libarchive",
  "patch_hash": "b41daecb5ccb4c8e3b2c53fd6147109fc12c3043",
  "patch_info": {
    "commit_hash": "b41daecb5ccb4c8e3b2c53fd6147109fc12c3043",
    "repo": "libarchive/libarchive",
    "commit_url": "https://github.com/libarchive/libarchive/commit/b41daecb5ccb4c8e3b2c53fd6147109fc12c3043",
    "files": [
      "Makefile.am",
      "libarchive/archive_write_disk_posix.c",
      "libarchive/test/CMakeLists.txt",
      "libarchive/test/test_write_disk_fixup.c"
    ],
    "message": "Do not follow symlinks when processing the fixup list\n\nUse lchmod() instead of chmod() and tell the remaining functions that the\nreal file to be modified is a symbolic link.\n\nFixes #1566",
    "before_after_code_files": [
      "Makefile.am||Makefile.am",
      "libarchive/archive_write_disk_posix.c||libarchive/archive_write_disk_posix.c",
      "libarchive/test/test_write_disk_fixup.c||libarchive/test/test_write_disk_fixup.c"
    ]
  },
  "patch_diff": {
    "Makefile.am||Makefile.am": [
      "File: Makefile.am -> Makefile.am",
      "--- Hunk 1 ---",
      "[Context before]",
      "560:  libarchive/test/test_write_disk.c \\",
      "561:  libarchive/test/test_write_disk_appledouble.c \\",
      "562:  libarchive/test/test_write_disk_failures.c \\",
      "563:  libarchive/test/test_write_disk_hardlink.c \\",
      "564:  libarchive/test/test_write_disk_hfs_compression.c \\",
      "565:  libarchive/test/test_write_disk_lookup.c \\",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "563:  libarchive/test/test_write_disk_fixup.c \\",
      "",
      "---------------"
    ],
    "libarchive/archive_write_disk_posix.c||libarchive/archive_write_disk_posix.c": [
      "File: libarchive/archive_write_disk_posix.c -> libarchive/archive_write_disk_posix.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "2461: {",
      "2462:  struct archive_write_disk *a = (struct archive_write_disk *)_a;",
      "2463:  struct fixup_entry *next, *p;",
      "2464:  int fd, ret;",
      "2466:  archive_check_magic(&a->archive, ARCHIVE_WRITE_DISK_MAGIC,",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2464:  struct stat st;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "2478:       (TODO_TIMES | TODO_MODE_BASE | TODO_ACLS | TODO_FFLAGS)) {",
      "2479:    fd = open(p->name,",
      "2480:        O_WRONLY | O_BINARY | O_NOFOLLOW | O_CLOEXEC);",
      "2481:   }",
      "2482:   if (p->fixup & TODO_TIMES) {",
      "2483:    set_times(a, fd, p->mode, p->name,",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2482:    if (fd == -1) {",
      "2484:     if (lstat(p->name, &st) != 0)",
      "2485:      goto skip_fixup_entry;",
      "2491:     if (S_ISLNK(st.st_mode)) {",
      "2492:      p->mode &= ~S_IFMT;",
      "2493:      p->mode |= S_IFLNK;",
      "2494:     }",
      "2495:    }",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "2492:     fchmod(fd, p->mode);",
      "2493:    else",
      "2494: #endif",
      "2496:   }",
      "2497:   if (p->fixup & TODO_ACLS)",
      "2498:    archive_write_disk_set_acls(&a->archive, fd,",
      "",
      "[Removed Lines]",
      "2495:    chmod(p->name, p->mode);",
      "",
      "[Added Lines]",
      "2510: #ifdef HAVE_LCHMOD",
      "2511:    lchmod(p->name, p->mode);",
      "2512: #else",
      "2513:    if (!S_ISLNK(p->mode))",
      "2514:     chmod(p->name, p->mode);",
      "2515: #endif",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "2503:   if (p->fixup & TODO_MAC_METADATA)",
      "2504:    set_mac_metadata(a, p->name, p->mac_metadata,",
      "2505:       p->mac_metadata_size);",
      "2506:   next = p->next;",
      "2507:   archive_acl_clear(&p->acl);",
      "2508:   free(p->mac_metadata);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2526: skip_fixup_entry:",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "2643:  fe->next = a->fixup_list;",
      "2644:  a->fixup_list = fe;",
      "2645:  fe->fixup = 0;",
      "2646:  fe->name = strdup(pathname);",
      "2647:  return (fe);",
      "2648: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2667:  fe->mode = 0;",
      "",
      "---------------"
    ],
    "libarchive/test/test_write_disk_fixup.c||libarchive/test/test_write_disk_fixup.c": [
      "File: libarchive/test/test_write_disk_fixup.c -> libarchive/test/test_write_disk_fixup.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "25: #include \"test.h\"",
      "30: DEFINE_TEST(test_write_disk_fixup)",
      "31: {",
      "32:  struct archive *ad;",
      "33:  struct archive_entry *ae;",
      "34:  int r;",
      "36:  if (!canSymlink()) {",
      "37:   skipping(\"Symlinks not supported\");",
      "38:   return;",
      "39:  }",
      "42:  assert((ad = archive_write_disk_new()) != NULL);",
      "47:  assertMakeFile(\"victim\", 0600, \"a\");",
      "54:         assert((ae = archive_entry_new()) != NULL);",
      "55:         archive_entry_copy_pathname(ae, \"dir\");",
      "56:         archive_entry_set_mode(ae, AE_IFDIR | 0606);",
      "57:  assertEqualIntA(ad, 0, archive_write_header(ad, ae));",
      "58:  assertEqualIntA(ad, 0, archive_write_finish_entry(ad));",
      "59:         archive_entry_free(ae);",
      "62:  assert((ae = archive_entry_new()) != NULL);",
      "63:  archive_entry_copy_pathname(ae, \"dir\");",
      "64:  archive_entry_set_mode(ae, AE_IFLNK | 0777);",
      "65:  archive_entry_set_size(ae, 0);",
      "66:  archive_entry_copy_symlink(ae, \"victim\");",
      "67:  assertEqualIntA(ad, 0, r = archive_write_header(ad, ae));",
      "68:  if (r >= ARCHIVE_WARN)",
      "69:   assertEqualIntA(ad, 0, archive_write_finish_entry(ad));",
      "70:  archive_entry_free(ae);",
      "72:  assertEqualInt(ARCHIVE_OK, archive_write_free(ad));",
      "75:  assertIsSymlink(\"dir\", \"victim\", 0);",
      "76:  assertFileMode(\"victim\", 0600);",
      "77: }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "ede459d2ebb879f5eedb6f7abea203be0b334230",
      "candidate_info": {
        "commit_hash": "ede459d2ebb879f5eedb6f7abea203be0b334230",
        "repo": "libarchive/libarchive",
        "commit_url": "https://github.com/libarchive/libarchive/commit/ede459d2ebb879f5eedb6f7abea203be0b334230",
        "files": [
          "libarchive/archive_write_disk_posix.c"
        ],
        "message": "archive_write_disk_posix: fix writing fflags broken in 8a1bd5c\n\nThe fixup list was erroneously assumed to be directories only.\nOnly in the case of critical file flags modification (e.g. SF_IMMUTABLE\non BSD systems), other file types (e.g. regular files or symbolic links)\nmay be added to the fixup list. We still need to verify that we are writing\nto the correct file type, so compare the archive entry file type with\nthe file type of the file to be modified.\n\nFixes #1617",
        "before_after_code_files": [
          "libarchive/archive_write_disk_posix.c||libarchive/archive_write_disk_posix.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libarchive/archive_write_disk_posix.c||libarchive/archive_write_disk_posix.c"
          ],
          "candidate": [
            "libarchive/archive_write_disk_posix.c||libarchive/archive_write_disk_posix.c"
          ]
        }
      },
      "candidate_diff": {
        "libarchive/archive_write_disk_posix.c||libarchive/archive_write_disk_posix.c": [
          "File: libarchive/archive_write_disk_posix.c -> libarchive/archive_write_disk_posix.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "173:  struct fixup_entry *next;",
          "174:  struct archive_acl  acl;",
          "175:  mode_t    mode;",
          "176:  int64_t    atime;",
          "177:  int64_t                  birthtime;",
          "178:  int64_t    mtime;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "176:  __LA_MODE_T   filetype;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "358: static int la_opendirat(int, const char *);",
          "359: static int la_mktemp(struct archive_write_disk *);",
          "360: static void fsobj_error(int *, struct archive_string *, int, const char *,",
          "361:       const char *);",
          "362: static int check_symlinks_fsobj(char *, int *, struct archive_string *,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "361: static int la_verify_filetype(mode_t, __LA_MODE_T);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "464: #endif",
          "465: }",
          "467: static int",
          "468: lazy_stat(struct archive_write_disk *a)",
          "469: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "469: static int",
          "470: la_verify_filetype(mode_t mode, __LA_MODE_T filetype) {",
          "471:  int ret = 0;",
          "473:  switch (filetype) {",
          "474:  case AE_IFREG:",
          "475:   ret = (S_ISREG(mode));",
          "476:   break;",
          "477:  case AE_IFDIR:",
          "478:   ret = (S_ISDIR(mode));",
          "479:   break;",
          "480:  case AE_IFLNK:",
          "481:   ret = (S_ISLNK(mode));",
          "482:   break;",
          "483:  case AE_IFSOCK:",
          "484:   ret = (S_ISSOCK(mode));",
          "485:   break;",
          "486:  case AE_IFCHR:",
          "487:   ret = (S_ISCHR(mode));",
          "488:   break;",
          "489:  case AE_IFBLK:",
          "490:   ret = (S_ISBLK(mode));",
          "491:   break;",
          "492:  case AE_IFIFO:",
          "493:   ret = (S_ISFIFO(mode));",
          "494:   break;",
          "495:  default:",
          "496:   break;",
          "497:  }",
          "499:  return (ret);",
          "500: }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "822:   fe = current_fixup(a, archive_entry_pathname(entry));",
          "823:   if (fe == NULL)",
          "824:    return (ARCHIVE_FATAL);",
          "825:   fe->fixup |= TODO_MODE_BASE;",
          "826:   fe->mode = a->mode;",
          "827:  }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "860:   fe->filetype = archive_entry_filetype(entry);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "832:   fe = current_fixup(a, archive_entry_pathname(entry));",
          "833:   if (fe == NULL)",
          "834:    return (ARCHIVE_FATAL);",
          "835:   fe->mode = a->mode;",
          "836:   fe->fixup |= TODO_TIMES;",
          "837:   if (archive_entry_atime_is_set(entry)) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "871:   fe->filetype = archive_entry_filetype(entry);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "865:   fe = current_fixup(a, archive_entry_pathname(entry));",
          "866:   if (fe == NULL)",
          "867:    return (ARCHIVE_FATAL);",
          "868:   fe->fixup |= TODO_ACLS;",
          "869:   archive_acl_copy(&fe->acl, archive_entry_acl(entry));",
          "870:  }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "905:   fe->filetype = archive_entry_filetype(entry);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "877:    fe = current_fixup(a, archive_entry_pathname(entry));",
          "878:    if (fe == NULL)",
          "879:     return (ARCHIVE_FATAL);",
          "880:    fe->mac_metadata = malloc(metadata_size);",
          "881:    if (fe->mac_metadata != NULL) {",
          "882:     memcpy(fe->mac_metadata, metadata,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "918:    fe->filetype = archive_entry_filetype(entry);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "891:   fe = current_fixup(a, archive_entry_pathname(entry));",
          "892:   if (fe == NULL)",
          "893:    return (ARCHIVE_FATAL);",
          "894:   fe->fixup |= TODO_FFLAGS;",
          "896:  }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "933:   fe->filetype = archive_entry_filetype(entry);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "2463:  struct fixup_entry *next, *p;",
          "2464:  struct stat st;",
          "2465:  char *c;",
          "2468:  archive_check_magic(&a->archive, ARCHIVE_WRITE_DISK_MAGIC,",
          "2469:      ARCHIVE_STATE_HEADER | ARCHIVE_STATE_DATA,",
          "",
          "[Removed Lines]",
          "2466:  int fd, ret;",
          "",
          "[Added Lines]",
          "2506:  int fd, ret, openflags;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "2490:   if (p->fixup == 0)",
          "2491:    goto skip_fixup_entry;",
          "2492:   else {",
          "2494: #if defined(O_DIRECTORY)",
          "2496: #endif",
          "2505:     if (lstat(p->name, &st) != 0 ||",
          "2507:      goto skip_fixup_entry;",
          "2508:     }",
          "2509:    }",
          "2510: #else",
          "2511: #if HAVE_FSTAT",
          "2512:    if (fd > 0 && (",
          "2514:     goto skip_fixup_entry;",
          "2515:    } else",
          "2516: #endif",
          "2517:    if (lstat(p->name, &st) != 0 ||",
          "2519:     goto skip_fixup_entry;",
          "2520:    }",
          "2521: #endif",
          "",
          "[Removed Lines]",
          "2493:    fd = open(p->name, O_BINARY | O_NOFOLLOW | O_RDONLY",
          "2495:        | O_DIRECTORY",
          "2497:        | O_CLOEXEC);",
          "2499:    `  * If we don't support O_DIRECTORY,",
          "2503: #if defined(O_DIRECTORY)",
          "2504:    if (fd == -1) {",
          "2506:         !S_ISDIR(st.st_mode)) {",
          "2513:        fstat(fd, &st) != 0 || !S_ISDIR(st.st_mode))) {",
          "2518:        !S_ISDIR(st.st_mode)) {",
          "",
          "[Added Lines]",
          "2538:    openflags = O_BINARY | O_NOFOLLOW | O_RDONLY",
          "2539:        | O_CLOEXEC;",
          "2541:    if (p->filetype == AE_IFDIR)",
          "2542:     openflags |= O_DIRECTORY;",
          "2544:    fd = open(p->name, openflags);",
          "2546: #if defined(O_DIRECTORY)",
          "2553:    if (fd == -1 || p->filetype != AE_IFDIR) {",
          "2554: #if HAVE_FSTAT",
          "2555:     if (fd > 0 && (",
          "2556:         fstat(fd, &st) != 0 ||",
          "2557:         la_verify_filetype(st.st_mode,",
          "2558:         p->filetype) == 0)) {",
          "2559:      goto skip_fixup_entry;",
          "2560:     } else",
          "2561: #endif",
          "2563:         la_verify_filetype(st.st_mode,",
          "2564:         p->filetype) == 0) {",
          "2571:        fstat(fd, &st) != 0 ||",
          "2572:        la_verify_filetype(st.st_mode,",
          "2573:        p->filetype) == 0)) {",
          "2578:        la_verify_filetype(st.st_mode,",
          "2579:        p->filetype) == 0) {",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "2689:  fe->next = a->fixup_list;",
          "2690:  a->fixup_list = fe;",
          "2691:  fe->fixup = 0;",
          "2692:  fe->name = strdup(pathname);",
          "2693:  return (fe);",
          "2694: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2753:  fe->filetype = 0;",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "3811:    le = current_fixup(a, a->name);",
          "3812:    if (le == NULL)",
          "3813:     return (ARCHIVE_FATAL);",
          "3814:    le->fixup |= TODO_FFLAGS;",
          "3815:    le->fflags_set = set;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3876:    le->filetype = archive_entry_filetype(a->entry);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "8a1bd5c18e896f0411a991240ce0d772bb02c840",
      "candidate_info": {
        "commit_hash": "8a1bd5c18e896f0411a991240ce0d772bb02c840",
        "repo": "libarchive/libarchive",
        "commit_url": "https://github.com/libarchive/libarchive/commit/8a1bd5c18e896f0411a991240ce0d772bb02c840",
        "files": [
          "libarchive/archive_write_disk_posix.c",
          "libarchive/test/test_write_disk_fixup.c"
        ],
        "message": "Fix following symlinks when processing the fixup list\n\nThe previous fix in b41daecb5 was incomplete. Fixup entries are\ngiven the original path without calling cleanup_pathname().\nTo make sure we don't follow a symlink, we must strip trailing\nslashes from the path.\n\nThe fixup entries are always directories. Make sure we try to modify\nonly directories by providing O_DIRECTORY to open() (if supported)\nand if it fails to check directory via lstat().\n\nFixes #1566",
        "before_after_code_files": [
          "libarchive/archive_write_disk_posix.c||libarchive/archive_write_disk_posix.c",
          "libarchive/test/test_write_disk_fixup.c||libarchive/test/test_write_disk_fixup.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libarchive/archive_write_disk_posix.c||libarchive/archive_write_disk_posix.c",
            "libarchive/test/test_write_disk_fixup.c||libarchive/test/test_write_disk_fixup.c"
          ],
          "candidate": [
            "libarchive/archive_write_disk_posix.c||libarchive/archive_write_disk_posix.c",
            "libarchive/test/test_write_disk_fixup.c||libarchive/test/test_write_disk_fixup.c"
          ]
        }
      },
      "candidate_diff": {
        "libarchive/archive_write_disk_posix.c||libarchive/archive_write_disk_posix.c": [
          "File: libarchive/archive_write_disk_posix.c -> libarchive/archive_write_disk_posix.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2462:  struct archive_write_disk *a = (struct archive_write_disk *)_a;",
          "2463:  struct fixup_entry *next, *p;",
          "2464:  struct stat st;",
          "2465:  int fd, ret;",
          "2467:  archive_check_magic(&a->archive, ARCHIVE_WRITE_DISK_MAGIC,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2465:  char *c;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2475:  while (p != NULL) {",
          "2476:   fd = -1;",
          "2482:    if (fd == -1) {",
          "2485:      goto skip_fixup_entry;",
          "2494:     }",
          "2495:    }",
          "2496:   }",
          "2497:   if (p->fixup & TODO_TIMES) {",
          "2498:    set_times(a, fd, p->mode, p->name,",
          "",
          "[Removed Lines]",
          "2478:   if (p->fixup &",
          "2479:       (TODO_TIMES | TODO_MODE_BASE | TODO_ACLS | TODO_FFLAGS)) {",
          "2480:    fd = open(p->name,",
          "2481:        O_WRONLY | O_BINARY | O_NOFOLLOW | O_CLOEXEC);",
          "2484:     if (lstat(p->name, &st) != 0)",
          "2491:     if (S_ISLNK(st.st_mode)) {",
          "2492:      p->mode &= ~S_IFMT;",
          "2493:      p->mode |= S_IFLNK;",
          "",
          "[Added Lines]",
          "2482:   c = p->name;",
          "2483:   while (*c != '\\0')",
          "2484:    c++;",
          "2485:   while (c != p->name && *(c - 1) == '/') {",
          "2486:    c--;",
          "2488:   }",
          "2490:   if (p->fixup == 0)",
          "2491:    goto skip_fixup_entry;",
          "2492:   else {",
          "2493:    fd = open(p->name, O_BINARY | O_NOFOLLOW | O_RDONLY",
          "2494: #if defined(O_DIRECTORY)",
          "2495:        | O_DIRECTORY",
          "2496: #endif",
          "2497:        | O_CLOEXEC);",
          "2499:    `  * If we don't support O_DIRECTORY,",
          "2503: #if defined(O_DIRECTORY)",
          "2505:     if (lstat(p->name, &st) != 0 ||",
          "2506:         !S_ISDIR(st.st_mode)) {",
          "2510: #else",
          "2511: #if HAVE_FSTAT",
          "2512:    if (fd > 0 && (",
          "2513:        fstat(fd, &st) != 0 || !S_ISDIR(st.st_mode))) {",
          "2514:     goto skip_fixup_entry;",
          "2515:    } else",
          "2516: #endif",
          "2517:    if (lstat(p->name, &st) != 0 ||",
          "2518:        !S_ISDIR(st.st_mode)) {",
          "2519:     goto skip_fixup_entry;",
          "2520:    }",
          "2521: #endif",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2504:   if (p->fixup & TODO_MODE_BASE) {",
          "2505: #ifdef HAVE_FCHMOD",
          "2506:    if (fd >= 0)",
          "2508:    else",
          "2509: #endif",
          "2510: #ifdef HAVE_LCHMOD",
          "2512: #else",
          "2515: #endif",
          "2516:   }",
          "2517:   if (p->fixup & TODO_ACLS)",
          "",
          "[Removed Lines]",
          "2507:     fchmod(fd, p->mode);",
          "2511:    lchmod(p->name, p->mode);",
          "2513:    if (!S_ISLNK(p->mode))",
          "2514:     chmod(p->name, p->mode);",
          "",
          "[Added Lines]",
          "2533:     fchmod(fd, p->mode & 07777);",
          "2537:    lchmod(p->name, p->mode & 07777);",
          "2539:    chmod(p->name, p->mode & 07777);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2664:  fe->next = a->fixup_list;",
          "2665:  a->fixup_list = fe;",
          "2666:  fe->fixup = 0;",
          "2668:  fe->name = strdup(pathname);",
          "2669:  return (fe);",
          "2670: }",
          "",
          "[Removed Lines]",
          "2667:  fe->mode = 0;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "libarchive/test/test_write_disk_fixup.c||libarchive/test/test_write_disk_fixup.c": [
          "File: libarchive/test/test_write_disk_fixup.c -> libarchive/test/test_write_disk_fixup.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "57:         assert((ae = archive_entry_new()) != NULL);",
          "60:  assertEqualIntA(ad, 0, archive_write_header(ad, ae));",
          "61:  assertEqualIntA(ad, 0, archive_write_finish_entry(ad));",
          "62:         archive_entry_free(ae);",
          "65:  assert((ae = archive_entry_new()) != NULL);",
          "67:  archive_entry_set_mode(ae, AE_IFLNK | 0777);",
          "68:  archive_entry_set_size(ae, 0);",
          "70:  assertEqualIntA(ad, 0, r = archive_write_header(ad, ae));",
          "71:  if (r >= ARCHIVE_WARN)",
          "72:   assertEqualIntA(ad, 0, archive_write_finish_entry(ad));",
          "",
          "[Removed Lines]",
          "50:  assertMakeFile(\"victim\", 0600, \"a\");",
          "58:         archive_entry_copy_pathname(ae, \"dir\");",
          "59:         archive_entry_set_mode(ae, AE_IFDIR | 0606);",
          "66:  archive_entry_copy_pathname(ae, \"dir\");",
          "69:  archive_entry_copy_symlink(ae, \"victim\");",
          "",
          "[Added Lines]",
          "50:  assertMakeFile(\"file\", 0600, \"a\");",
          "55:  assertMakeDir(\"dir\", 0700);",
          "62:         assert((ae = archive_entry_new()) != NULL);",
          "63:         archive_entry_copy_pathname(ae, \"dir1/\");",
          "64:         archive_entry_set_mode(ae, AE_IFDIR | 0555);",
          "65:  assertEqualIntA(ad, 0, archive_write_header(ad, ae));",
          "66:  assertEqualIntA(ad, 0, archive_write_finish_entry(ad));",
          "67:         archive_entry_free(ae);",
          "71:         archive_entry_copy_pathname(ae, \"dir2/\");",
          "72:         archive_entry_set_mode(ae, AE_IFDIR | 0555);",
          "78:  assert((ae = archive_entry_new()) != NULL);",
          "79:  archive_entry_copy_pathname(ae, \"dir1\");",
          "80:  archive_entry_set_mode(ae, AE_IFLNK | 0777);",
          "81:  archive_entry_set_size(ae, 0);",
          "82:  archive_entry_copy_symlink(ae, \"dir\");",
          "83:  assertEqualIntA(ad, 0, r = archive_write_header(ad, ae));",
          "84:  if (r >= ARCHIVE_WARN)",
          "85:   assertEqualIntA(ad, 0, archive_write_finish_entry(ad));",
          "86:  archive_entry_free(ae);",
          "90:  archive_entry_copy_pathname(ae, \"dir2\");",
          "93:  archive_entry_copy_symlink(ae, \"file\");",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "75:  assertEqualInt(ARCHIVE_OK, archive_write_free(ad));",
          "80: #endif",
          "81: }",
          "",
          "[Removed Lines]",
          "78:  assertIsSymlink(\"dir\", \"victim\", 0);",
          "79:  assertFileMode(\"victim\", 0600);",
          "",
          "[Added Lines]",
          "102:  assertIsSymlink(\"dir1\", \"dir\", 0);",
          "103:  assertIsSymlink(\"dir2\", \"file\", 0);",
          "104:  assertFileMode(\"dir\", 0700);",
          "105:  assertFileMode(\"file\", 0600);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "9516eda33d1ec0aaeb18266ea83780de8c7235bc",
      "candidate_info": {
        "commit_hash": "9516eda33d1ec0aaeb18266ea83780de8c7235bc",
        "repo": "libarchive/libarchive",
        "commit_url": "https://github.com/libarchive/libarchive/commit/9516eda33d1ec0aaeb18266ea83780de8c7235bc",
        "files": [
          "libarchive/archive_write_disk_posix.c"
        ],
        "message": "archive_write_disk_posix: fix writing fflags broken in 8a1bd5c\n\nThe fixup list was erroneously assumed to be directories only.\nOnly in the case of critical file flags modification (e.g. SF_IMMUTABLE\non BSD systems), other file types (e.g. regular files or symbolic links)\nmay be added to the fixup list. We still need to verify that we are writing\nto the correct file type, so compare the archive entry file type with\nthe file type of the file to be modified.\n\nFixes #1617",
        "before_after_code_files": [
          "libarchive/archive_write_disk_posix.c||libarchive/archive_write_disk_posix.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libarchive/archive_write_disk_posix.c||libarchive/archive_write_disk_posix.c"
          ],
          "candidate": [
            "libarchive/archive_write_disk_posix.c||libarchive/archive_write_disk_posix.c"
          ]
        }
      },
      "candidate_diff": {
        "libarchive/archive_write_disk_posix.c||libarchive/archive_write_disk_posix.c": [
          "File: libarchive/archive_write_disk_posix.c -> libarchive/archive_write_disk_posix.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "173:  struct fixup_entry *next;",
          "174:  struct archive_acl  acl;",
          "175:  mode_t    mode;",
          "176:  int64_t    atime;",
          "177:  int64_t                  birthtime;",
          "178:  int64_t    mtime;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "176:  __LA_MODE_T   filetype;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "358: static int la_opendirat(int, const char *);",
          "359: static int la_mktemp(struct archive_write_disk *);",
          "360: static void fsobj_error(int *, struct archive_string *, int, const char *,",
          "361:       const char *);",
          "362: static int check_symlinks_fsobj(char *, int *, struct archive_string *,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "361: static int la_verify_filetype(mode_t, __LA_MODE_T);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "464: #endif",
          "465: }",
          "467: static int",
          "468: lazy_stat(struct archive_write_disk *a)",
          "469: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "469: static int",
          "470: la_verify_filetype(mode_t mode, __LA_MODE_T filetype) {",
          "471:  int ret = 0;",
          "473:  switch (filetype) {",
          "474:  case AE_IFREG:",
          "475:   ret = (S_ISREG(mode));",
          "476:   break;",
          "477:  case AE_IFDIR:",
          "478:   ret = (S_ISDIR(mode));",
          "479:   break;",
          "480:  case AE_IFLNK:",
          "481:   ret = (S_ISLNK(mode));",
          "482:   break;",
          "483:  case AE_IFSOCK:",
          "484:   ret = (S_ISSOCK(mode));",
          "485:   break;",
          "486:  case AE_IFCHR:",
          "487:   ret = (S_ISCHR(mode));",
          "488:   break;",
          "489:  case AE_IFBLK:",
          "490:   ret = (S_ISBLK(mode));",
          "491:   break;",
          "492:  case AE_IFIFO:",
          "493:   ret = (S_ISFIFO(mode));",
          "494:   break;",
          "495:  default:",
          "496:   break;",
          "497:  }",
          "499:  return (ret);",
          "500: }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "822:   fe = current_fixup(a, archive_entry_pathname(entry));",
          "823:   if (fe == NULL)",
          "824:    return (ARCHIVE_FATAL);",
          "825:   fe->fixup |= TODO_MODE_BASE;",
          "826:   fe->mode = a->mode;",
          "827:  }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "860:   fe->filetype = archive_entry_filetype(entry);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "832:   fe = current_fixup(a, archive_entry_pathname(entry));",
          "833:   if (fe == NULL)",
          "834:    return (ARCHIVE_FATAL);",
          "835:   fe->mode = a->mode;",
          "836:   fe->fixup |= TODO_TIMES;",
          "837:   if (archive_entry_atime_is_set(entry)) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "871:   fe->filetype = archive_entry_filetype(entry);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "865:   fe = current_fixup(a, archive_entry_pathname(entry));",
          "866:   if (fe == NULL)",
          "867:    return (ARCHIVE_FATAL);",
          "868:   fe->fixup |= TODO_ACLS;",
          "869:   archive_acl_copy(&fe->acl, archive_entry_acl(entry));",
          "870:  }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "905:   fe->filetype = archive_entry_filetype(entry);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "877:    fe = current_fixup(a, archive_entry_pathname(entry));",
          "878:    if (fe == NULL)",
          "879:     return (ARCHIVE_FATAL);",
          "880:    fe->mac_metadata = malloc(metadata_size);",
          "881:    if (fe->mac_metadata != NULL) {",
          "882:     memcpy(fe->mac_metadata, metadata,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "918:    fe->filetype = archive_entry_filetype(entry);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "891:   fe = current_fixup(a, archive_entry_pathname(entry));",
          "892:   if (fe == NULL)",
          "893:    return (ARCHIVE_FATAL);",
          "894:   fe->fixup |= TODO_FFLAGS;",
          "896:  }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "933:   fe->filetype = archive_entry_filetype(entry);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "2463:  struct fixup_entry *next, *p;",
          "2464:  struct stat st;",
          "2465:  char *c;",
          "2468:  archive_check_magic(&a->archive, ARCHIVE_WRITE_DISK_MAGIC,",
          "2469:      ARCHIVE_STATE_HEADER | ARCHIVE_STATE_DATA,",
          "",
          "[Removed Lines]",
          "2466:  int fd, ret;",
          "",
          "[Added Lines]",
          "2506:  int fd, ret, openflags;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "2490:   if (p->fixup == 0)",
          "2491:    goto skip_fixup_entry;",
          "2492:   else {",
          "2494: #if defined(O_DIRECTORY)",
          "2496: #endif",
          "2505:     if (lstat(p->name, &st) != 0 ||",
          "2507:      goto skip_fixup_entry;",
          "2508:     }",
          "2509:    }",
          "2510: #else",
          "2511: #if HAVE_FSTAT",
          "2512:    if (fd > 0 && (",
          "2514:     goto skip_fixup_entry;",
          "2515:    } else",
          "2516: #endif",
          "2517:    if (lstat(p->name, &st) != 0 ||",
          "2519:     goto skip_fixup_entry;",
          "2520:    }",
          "2521: #endif",
          "",
          "[Removed Lines]",
          "2493:    fd = open(p->name, O_BINARY | O_NOFOLLOW | O_RDONLY",
          "2495:        | O_DIRECTORY",
          "2497:        | O_CLOEXEC);",
          "2499:    `  * If we don't support O_DIRECTORY,",
          "2503: #if defined(O_DIRECTORY)",
          "2504:    if (fd == -1) {",
          "2506:         !S_ISDIR(st.st_mode)) {",
          "2513:        fstat(fd, &st) != 0 || !S_ISDIR(st.st_mode))) {",
          "2518:        !S_ISDIR(st.st_mode)) {",
          "",
          "[Added Lines]",
          "2538:    openflags = O_BINARY | O_NOFOLLOW | O_RDONLY",
          "2539:        | O_CLOEXEC;",
          "2541:    if (p->filetype == AE_IFDIR)",
          "2542:     openflags |= O_DIRECTORY;",
          "2544:    fd = open(p->name, openflags);",
          "2546: #if defined(O_DIRECTORY)",
          "2553:    if (fd == -1 || p->filetype != AE_IFDIR) {",
          "2554: #if HAVE_FSTAT",
          "2555:     if (fd > 0 && (",
          "2556:         fstat(fd, &st) != 0 ||",
          "2557:         la_verify_filetype(st.st_mode,",
          "2558:         p->filetype) == 0)) {",
          "2559:      goto skip_fixup_entry;",
          "2560:     } else",
          "2561: #endif",
          "2563:         la_verify_filetype(st.st_mode,",
          "2564:         p->filetype) == 0) {",
          "2571:        fstat(fd, &st) != 0 ||",
          "2572:        la_verify_filetype(st.st_mode,",
          "2573:        p->filetype) == 0)) {",
          "2578:        la_verify_filetype(st.st_mode,",
          "2579:        p->filetype) == 0) {",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "2689:  fe->next = a->fixup_list;",
          "2690:  a->fixup_list = fe;",
          "2691:  fe->fixup = 0;",
          "2692:  fe->name = strdup(pathname);",
          "2693:  return (fe);",
          "2694: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2753:  fe->filetype = 0;",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "3811:    le = current_fixup(a, a->name);",
          "3812:    if (le == NULL)",
          "3813:     return (ARCHIVE_FATAL);",
          "3814:    le->fixup |= TODO_FFLAGS;",
          "3815:    le->fflags_set = set;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3876:    le->filetype = archive_entry_filetype(a->entry);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "4f8ad2f107be6bf64ecc085ea049df70b5ff2956",
      "candidate_info": {
        "commit_hash": "4f8ad2f107be6bf64ecc085ea049df70b5ff2956",
        "repo": "libarchive/libarchive",
        "commit_url": "https://github.com/libarchive/libarchive/commit/4f8ad2f107be6bf64ecc085ea049df70b5ff2956",
        "files": [
          "libarchive/archive_write_disk_posix.c",
          "libarchive/test/test_write_disk_fixup.c"
        ],
        "message": "Fix following symlinks when processing the fixup list\n\nThe previous fix in b41daecb5 was incomplete. Fixup entries are\ngiven the original path without calling cleanup_pathname().\nTo make sure we don't follow a symlink, we must strip trailing\nslashes from the path.\n\nThe fixup entries are always directories. Make sure we try to modify\nonly directories by providing O_DIRECTORY to open() (if supported)\nand if it fails to check directory via lstat().\n\nFixes #1566",
        "before_after_code_files": [
          "libarchive/archive_write_disk_posix.c||libarchive/archive_write_disk_posix.c",
          "libarchive/test/test_write_disk_fixup.c||libarchive/test/test_write_disk_fixup.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libarchive/archive_write_disk_posix.c||libarchive/archive_write_disk_posix.c",
            "libarchive/test/test_write_disk_fixup.c||libarchive/test/test_write_disk_fixup.c"
          ],
          "candidate": [
            "libarchive/archive_write_disk_posix.c||libarchive/archive_write_disk_posix.c",
            "libarchive/test/test_write_disk_fixup.c||libarchive/test/test_write_disk_fixup.c"
          ]
        }
      },
      "candidate_diff": {
        "libarchive/archive_write_disk_posix.c||libarchive/archive_write_disk_posix.c": [
          "File: libarchive/archive_write_disk_posix.c -> libarchive/archive_write_disk_posix.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2462:  struct archive_write_disk *a = (struct archive_write_disk *)_a;",
          "2463:  struct fixup_entry *next, *p;",
          "2464:  struct stat st;",
          "2465:  int fd, ret;",
          "2467:  archive_check_magic(&a->archive, ARCHIVE_WRITE_DISK_MAGIC,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2465:  char *c;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2475:  while (p != NULL) {",
          "2476:   fd = -1;",
          "2482:    if (fd == -1) {",
          "2485:      goto skip_fixup_entry;",
          "2494:     }",
          "2495:    }",
          "2496:   }",
          "2497:   if (p->fixup & TODO_TIMES) {",
          "2498:    set_times(a, fd, p->mode, p->name,",
          "",
          "[Removed Lines]",
          "2478:   if (p->fixup &",
          "2479:       (TODO_TIMES | TODO_MODE_BASE | TODO_ACLS | TODO_FFLAGS)) {",
          "2480:    fd = open(p->name,",
          "2481:        O_WRONLY | O_BINARY | O_NOFOLLOW | O_CLOEXEC);",
          "2484:     if (lstat(p->name, &st) != 0)",
          "2491:     if (S_ISLNK(st.st_mode)) {",
          "2492:      p->mode &= ~S_IFMT;",
          "2493:      p->mode |= S_IFLNK;",
          "",
          "[Added Lines]",
          "2482:   c = p->name;",
          "2483:   while (*c != '\\0')",
          "2484:    c++;",
          "2485:   while (c != p->name && *(c - 1) == '/') {",
          "2486:    c--;",
          "2488:   }",
          "2490:   if (p->fixup == 0)",
          "2491:    goto skip_fixup_entry;",
          "2492:   else {",
          "2493:    fd = open(p->name, O_BINARY | O_NOFOLLOW | O_RDONLY",
          "2494: #if defined(O_DIRECTORY)",
          "2495:        | O_DIRECTORY",
          "2496: #endif",
          "2497:        | O_CLOEXEC);",
          "2499:    `  * If we don't support O_DIRECTORY,",
          "2503: #if defined(O_DIRECTORY)",
          "2505:     if (lstat(p->name, &st) != 0 ||",
          "2506:         !S_ISDIR(st.st_mode)) {",
          "2510: #else",
          "2511: #if HAVE_FSTAT",
          "2512:    if (fd > 0 && (",
          "2513:        fstat(fd, &st) != 0 || !S_ISDIR(st.st_mode))) {",
          "2514:     goto skip_fixup_entry;",
          "2515:    } else",
          "2516: #endif",
          "2517:    if (lstat(p->name, &st) != 0 ||",
          "2518:        !S_ISDIR(st.st_mode)) {",
          "2519:     goto skip_fixup_entry;",
          "2520:    }",
          "2521: #endif",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2504:   if (p->fixup & TODO_MODE_BASE) {",
          "2505: #ifdef HAVE_FCHMOD",
          "2506:    if (fd >= 0)",
          "2508:    else",
          "2509: #endif",
          "2510: #ifdef HAVE_LCHMOD",
          "2512: #else",
          "2515: #endif",
          "2516:   }",
          "2517:   if (p->fixup & TODO_ACLS)",
          "",
          "[Removed Lines]",
          "2507:     fchmod(fd, p->mode);",
          "2511:    lchmod(p->name, p->mode);",
          "2513:    if (!S_ISLNK(p->mode))",
          "2514:     chmod(p->name, p->mode);",
          "",
          "[Added Lines]",
          "2533:     fchmod(fd, p->mode & 07777);",
          "2537:    lchmod(p->name, p->mode & 07777);",
          "2539:    chmod(p->name, p->mode & 07777);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2664:  fe->next = a->fixup_list;",
          "2665:  a->fixup_list = fe;",
          "2666:  fe->fixup = 0;",
          "2668:  fe->name = strdup(pathname);",
          "2669:  return (fe);",
          "2670: }",
          "",
          "[Removed Lines]",
          "2667:  fe->mode = 0;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "libarchive/test/test_write_disk_fixup.c||libarchive/test/test_write_disk_fixup.c": [
          "File: libarchive/test/test_write_disk_fixup.c -> libarchive/test/test_write_disk_fixup.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "57:         assert((ae = archive_entry_new()) != NULL);",
          "60:  assertEqualIntA(ad, 0, archive_write_header(ad, ae));",
          "61:  assertEqualIntA(ad, 0, archive_write_finish_entry(ad));",
          "62:         archive_entry_free(ae);",
          "65:  assert((ae = archive_entry_new()) != NULL);",
          "67:  archive_entry_set_mode(ae, AE_IFLNK | 0777);",
          "68:  archive_entry_set_size(ae, 0);",
          "70:  assertEqualIntA(ad, 0, r = archive_write_header(ad, ae));",
          "71:  if (r >= ARCHIVE_WARN)",
          "72:   assertEqualIntA(ad, 0, archive_write_finish_entry(ad));",
          "",
          "[Removed Lines]",
          "50:  assertMakeFile(\"victim\", 0600, \"a\");",
          "58:         archive_entry_copy_pathname(ae, \"dir\");",
          "59:         archive_entry_set_mode(ae, AE_IFDIR | 0606);",
          "66:  archive_entry_copy_pathname(ae, \"dir\");",
          "69:  archive_entry_copy_symlink(ae, \"victim\");",
          "",
          "[Added Lines]",
          "50:  assertMakeFile(\"file\", 0600, \"a\");",
          "55:  assertMakeDir(\"dir\", 0700);",
          "62:         assert((ae = archive_entry_new()) != NULL);",
          "63:         archive_entry_copy_pathname(ae, \"dir1/\");",
          "64:         archive_entry_set_mode(ae, AE_IFDIR | 0555);",
          "65:  assertEqualIntA(ad, 0, archive_write_header(ad, ae));",
          "66:  assertEqualIntA(ad, 0, archive_write_finish_entry(ad));",
          "67:         archive_entry_free(ae);",
          "71:         archive_entry_copy_pathname(ae, \"dir2/\");",
          "72:         archive_entry_set_mode(ae, AE_IFDIR | 0555);",
          "78:  assert((ae = archive_entry_new()) != NULL);",
          "79:  archive_entry_copy_pathname(ae, \"dir1\");",
          "80:  archive_entry_set_mode(ae, AE_IFLNK | 0777);",
          "81:  archive_entry_set_size(ae, 0);",
          "82:  archive_entry_copy_symlink(ae, \"dir\");",
          "83:  assertEqualIntA(ad, 0, r = archive_write_header(ad, ae));",
          "84:  if (r >= ARCHIVE_WARN)",
          "85:   assertEqualIntA(ad, 0, archive_write_finish_entry(ad));",
          "86:  archive_entry_free(ae);",
          "90:  archive_entry_copy_pathname(ae, \"dir2\");",
          "93:  archive_entry_copy_symlink(ae, \"file\");",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "75:  assertEqualInt(ARCHIVE_OK, archive_write_free(ad));",
          "80: #endif",
          "81: }",
          "",
          "[Removed Lines]",
          "78:  assertIsSymlink(\"dir\", \"victim\", 0);",
          "79:  assertFileMode(\"victim\", 0600);",
          "",
          "[Added Lines]",
          "102:  assertIsSymlink(\"dir1\", \"dir\", 0);",
          "103:  assertIsSymlink(\"dir2\", \"file\", 0);",
          "104:  assertFileMode(\"dir\", 0700);",
          "105:  assertFileMode(\"file\", 0600);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
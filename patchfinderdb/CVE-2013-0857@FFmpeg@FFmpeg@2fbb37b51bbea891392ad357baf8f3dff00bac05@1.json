{
  "cve_id": "CVE-2013-0857",
  "cve_desc": "The decode_frame_ilbm function in libavcodec/iff.c in FFmpeg before 1.1 allows remote attackers to have an unspecified impact via a crafted height value in IFF PBM/ILBM bitmap data.",
  "repo": "FFmpeg/FFmpeg",
  "patch_hash": "2fbb37b51bbea891392ad357baf8f3dff00bac05",
  "patch_info": {
    "commit_hash": "2fbb37b51bbea891392ad357baf8f3dff00bac05",
    "repo": "FFmpeg/FFmpeg",
    "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/2fbb37b51bbea891392ad357baf8f3dff00bac05",
    "files": [
      "libavcodec/iff.c"
    ],
    "message": "iff/ilbm: check remaining buffer size.\n\nFound-by: Mateusz \"j00ru\" Jurczyk and Gynvael Coldwind\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>",
    "before_after_code_files": [
      "libavcodec/iff.c||libavcodec/iff.c"
    ]
  },
  "patch_diff": {
    "libavcodec/iff.c||libavcodec/iff.c": [
      "File: libavcodec/iff.c -> libavcodec/iff.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "575:         }",
      "576:     } else if (avctx->codec_tag == MKTAG('P','B','M',' ')) { // IFF-PBM",
      "577:         if (avctx->pix_fmt == AV_PIX_FMT_PAL8 || avctx->pix_fmt == AV_PIX_FMT_GRAY8) {",
      "579:                 uint8_t *row = &s->frame.data[0][y * s->frame.linesize[0]];",
      "580:                 memcpy(row, buf, FFMIN(avctx->width, buf_end - buf));",
      "581:                 buf += avctx->width + (avctx->width % 2); // padding if odd",
      "582:             }",
      "583:         } else if (s->ham) { // IFF-PBM: HAM to AV_PIX_FMT_BGR32",
      "585:                 uint8_t *row = &s->frame.data[0][ y*s->frame.linesize[0] ];",
      "586:                 memcpy(s->ham_buf, buf, FFMIN(avctx->width, buf_end - buf));",
      "587:                 buf += avctx->width + (avctx->width & 1); // padding if odd",
      "",
      "[Removed Lines]",
      "578:             for(y = 0; y < avctx->height; y++ ) {",
      "584:             for (y = 0; y < avctx->height; y++) {",
      "",
      "[Added Lines]",
      "578:             for(y = 0; y < avctx->height && buf_end > buf; y++ ) {",
      "584:             for (y = 0; y < avctx->height && buf_end > buf; y++) {",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "f737e7602649b6e193bd92a923510a153c82e8ae",
      "candidate_info": {
        "commit_hash": "f737e7602649b6e193bd92a923510a153c82e8ae",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/f737e7602649b6e193bd92a923510a153c82e8ae",
        "files": [
          "libavcodec/iff.c"
        ],
        "message": "iff decoder: reindent\n\nSigned-off-by: Peter Ross <pross@xvid.org>",
        "before_after_code_files": [
          "libavcodec/iff.c||libavcodec/iff.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libavcodec/iff.c||libavcodec/iff.c"
          ],
          "candidate": [
            "libavcodec/iff.c||libavcodec/iff.c"
          ]
        }
      },
      "candidate_diff": {
        "libavcodec/iff.c||libavcodec/iff.c": [
          "File: libavcodec/iff.c -> libavcodec/iff.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "567:     switch (s->compression) {",
          "568:     case 0:",
          "577:                 }",
          "582:                 uint8_t *row = &s->frame.data[0][y * s->frame.linesize[0]];",
          "589:                 }",
          "591:             }",
          "615:                 }",
          "624:                 }",
          "634:                 }",
          "635:             }",
          "636:         }",
          "655:     case 1:",
          "664:                 }",
          "673:                 }",
          "683:                 }",
          "693:                 }",
          "694:             }",
          "695:         }",
          "717:         break;",
          "718:     default:",
          "719:         return unsupported(avctx);",
          "",
          "[Removed Lines]",
          "569:     if (avctx->codec_tag == MKTAG('A','C','B','M')) {",
          "570:         if (avctx->pix_fmt == AV_PIX_FMT_PAL8 || avctx->pix_fmt == AV_PIX_FMT_GRAY8) {",
          "571:             memset(s->frame.data[0], 0, avctx->height * s->frame.linesize[0]);",
          "572:             for (plane = 0; plane < s->bpp; plane++) {",
          "573:                 for(y = 0; y < avctx->height && buf < buf_end; y++ ) {",
          "574:                     uint8_t *row = &s->frame.data[0][ y*s->frame.linesize[0] ];",
          "575:                     decodeplane8(row, buf, FFMIN(s->planesize, buf_end - buf), plane);",
          "576:                     buf += s->planesize;",
          "578:             }",
          "579:         } else if (s->ham) { // HAM to AV_PIX_FMT_BGR32",
          "580:             memset(s->frame.data[0], 0, avctx->height * s->frame.linesize[0]);",
          "581:             for(y = 0; y < avctx->height; y++) {",
          "583:                 memset(s->ham_buf, 0, s->planesize * 8);",
          "584:                 for (plane = 0; plane < s->bpp; plane++) {",
          "585:                     const uint8_t * start = buf + (plane * avctx->height + y) * s->planesize;",
          "586:                     if (start >= buf_end)",
          "587:                         break;",
          "588:                     decodeplane8(s->ham_buf, start, FFMIN(s->planesize, buf_end - start), plane);",
          "590:                 decode_ham_plane32((uint32_t *) row, s->ham_buf, s->ham_palbuf, s->planesize);",
          "592:         } else",
          "593:             return unsupported(avctx);",
          "594:     } else if (avctx->codec_tag == MKTAG('D','E','E','P')) {",
          "595:         const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(avctx->pix_fmt);",
          "596:         int raw_width = avctx->width * (av_get_bits_per_pixel(desc) >> 3);",
          "597:         int x;",
          "598:         for(y = 0; y < avctx->height && buf < buf_end; y++ ) {",
          "599:             uint8_t *row = &s->frame.data[0][y * s->frame.linesize[0]];",
          "600:             memcpy(row, buf, FFMIN(raw_width, buf_end - buf));",
          "601:             buf += raw_width;",
          "602:             if (avctx->pix_fmt == AV_PIX_FMT_BGR32) {",
          "603:                 for(x = 0; x < avctx->width; x++)",
          "604:                     row[4 * x + 3] = row[4 * x + 3] & 0xF0 | (row[4 * x + 3] >> 4);",
          "605:             }",
          "606:         }",
          "607:     } else if (avctx->codec_tag == MKTAG('I','L','B','M')) { // interleaved",
          "608:         if (avctx->pix_fmt == AV_PIX_FMT_PAL8 || avctx->pix_fmt == AV_PIX_FMT_GRAY8) {",
          "609:             for(y = 0; y < avctx->height; y++ ) {",
          "610:                 uint8_t *row = &s->frame.data[0][ y*s->frame.linesize[0] ];",
          "611:                 memset(row, 0, avctx->width);",
          "612:                 for (plane = 0; plane < s->bpp && buf < buf_end; plane++) {",
          "613:                     decodeplane8(row, buf, FFMIN(s->planesize, buf_end - buf), plane);",
          "614:                     buf += s->planesize;",
          "616:             }",
          "617:         } else if (s->ham) { // HAM to AV_PIX_FMT_BGR32",
          "618:             for (y = 0; y < avctx->height; y++) {",
          "619:                 uint8_t *row = &s->frame.data[0][ y*s->frame.linesize[0] ];",
          "620:                 memset(s->ham_buf, 0, s->planesize * 8);",
          "621:                 for (plane = 0; plane < s->bpp && buf < buf_end; plane++) {",
          "622:                     decodeplane8(s->ham_buf, buf, FFMIN(s->planesize, buf_end - buf), plane);",
          "623:                     buf += s->planesize;",
          "625:                 decode_ham_plane32((uint32_t *) row, s->ham_buf, s->ham_palbuf, s->planesize);",
          "626:             }",
          "627:         } else { // AV_PIX_FMT_BGR32",
          "628:             for(y = 0; y < avctx->height; y++ ) {",
          "629:                 uint8_t *row = &s->frame.data[0][y*s->frame.linesize[0]];",
          "630:                 memset(row, 0, avctx->width << 2);",
          "631:                 for (plane = 0; plane < s->bpp && buf < buf_end; plane++) {",
          "632:                     decodeplane32((uint32_t *) row, buf, FFMIN(s->planesize, buf_end - buf), plane);",
          "633:                     buf += s->planesize;",
          "637:     } else if (avctx->codec_tag == MKTAG('P','B','M',' ')) { // IFF-PBM",
          "638:         if (avctx->pix_fmt == AV_PIX_FMT_PAL8 || avctx->pix_fmt == AV_PIX_FMT_GRAY8) {",
          "639:             for(y = 0; y < avctx->height && buf_end > buf; y++ ) {",
          "640:                 uint8_t *row = &s->frame.data[0][y * s->frame.linesize[0]];",
          "641:                 memcpy(row, buf, FFMIN(avctx->width, buf_end - buf));",
          "642:                 buf += avctx->width + (avctx->width % 2); // padding if odd",
          "643:             }",
          "644:         } else if (s->ham) { // IFF-PBM: HAM to AV_PIX_FMT_BGR32",
          "645:             for (y = 0; y < avctx->height && buf_end > buf; y++) {",
          "646:                 uint8_t *row = &s->frame.data[0][ y*s->frame.linesize[0] ];",
          "647:                 memcpy(s->ham_buf, buf, FFMIN(avctx->width, buf_end - buf));",
          "648:                 buf += avctx->width + (avctx->width & 1); // padding if odd",
          "649:                 decode_ham_plane32((uint32_t *) row, s->ham_buf, s->ham_palbuf, s->planesize);",
          "650:             }",
          "651:         } else",
          "652:             return unsupported(avctx);",
          "653:     }",
          "654:     break;",
          "656:     if (avctx->codec_tag == MKTAG('I','L','B','M')) { //interleaved",
          "657:         if (avctx->pix_fmt == AV_PIX_FMT_PAL8 || avctx->pix_fmt == AV_PIX_FMT_GRAY8) {",
          "658:             for(y = 0; y < avctx->height ; y++ ) {",
          "659:                 uint8_t *row = &s->frame.data[0][ y*s->frame.linesize[0] ];",
          "660:                 memset(row, 0, avctx->width);",
          "661:                 for (plane = 0; plane < s->bpp; plane++) {",
          "662:                     buf += decode_byterun(s->planebuf, s->planesize, buf, buf_end);",
          "663:                     decodeplane8(row, s->planebuf, s->planesize, plane);",
          "665:             }",
          "666:         } else if (avctx->bits_per_coded_sample <= 8) { //8-bit (+ mask) to AV_PIX_FMT_BGR32",
          "667:             for (y = 0; y < avctx->height ; y++ ) {",
          "668:                 uint8_t *row = &s->frame.data[0][y*s->frame.linesize[0]];",
          "669:                 memset(s->mask_buf, 0, avctx->width * sizeof(uint32_t));",
          "670:                 for (plane = 0; plane < s->bpp; plane++) {",
          "671:                     buf += decode_byterun(s->planebuf, s->planesize, buf, buf_end);",
          "672:                     decodeplane32(s->mask_buf, s->planebuf, s->planesize, plane);",
          "674:                 lookup_pal_indicies((uint32_t *) row, s->mask_buf, s->mask_palbuf, avctx->width);",
          "675:             }",
          "676:         } else if (s->ham) { // HAM to AV_PIX_FMT_BGR32",
          "677:             for (y = 0; y < avctx->height ; y++) {",
          "678:                 uint8_t *row = &s->frame.data[0][y*s->frame.linesize[0]];",
          "679:                 memset(s->ham_buf, 0, s->planesize * 8);",
          "680:                 for (plane = 0; plane < s->bpp; plane++) {",
          "681:                     buf += decode_byterun(s->planebuf, s->planesize, buf, buf_end);",
          "682:                     decodeplane8(s->ham_buf, s->planebuf, s->planesize, plane);",
          "684:                 decode_ham_plane32((uint32_t *) row, s->ham_buf, s->ham_palbuf, s->planesize);",
          "685:             }",
          "686:         } else { //AV_PIX_FMT_BGR32",
          "687:             for(y = 0; y < avctx->height ; y++ ) {",
          "688:                 uint8_t *row = &s->frame.data[0][y*s->frame.linesize[0]];",
          "689:                 memset(row, 0, avctx->width << 2);",
          "690:                 for (plane = 0; plane < s->bpp; plane++) {",
          "691:                     buf += decode_byterun(s->planebuf, s->planesize, buf, buf_end);",
          "692:                     decodeplane32((uint32_t *) row, s->planebuf, s->planesize, plane);",
          "696:     } else if (avctx->codec_tag == MKTAG('P','B','M',' ')) { // IFF-PBM",
          "697:         if (avctx->pix_fmt == AV_PIX_FMT_PAL8 || avctx->pix_fmt == AV_PIX_FMT_GRAY8) {",
          "698:             for(y = 0; y < avctx->height ; y++ ) {",
          "699:                 uint8_t *row = &s->frame.data[0][y*s->frame.linesize[0]];",
          "700:                 buf += decode_byterun(row, avctx->width, buf, buf_end);",
          "701:             }",
          "702:         } else if (s->ham) { // IFF-PBM: HAM to AV_PIX_FMT_BGR32",
          "703:             for (y = 0; y < avctx->height ; y++) {",
          "704:                 uint8_t *row = &s->frame.data[0][y*s->frame.linesize[0]];",
          "705:                 buf += decode_byterun(s->ham_buf, avctx->width, buf, buf_end);",
          "706:                 decode_ham_plane32((uint32_t *) row, s->ham_buf, s->ham_palbuf, s->planesize);",
          "707:             }",
          "708:         } else",
          "709:             return unsupported(avctx);",
          "710:     } else if (avctx->codec_tag == MKTAG('D','E','E','P')) { // IFF-DEEP",
          "711:         const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(avctx->pix_fmt);",
          "712:         if (av_get_bits_per_pixel(desc) == 32)",
          "713:             decode_deep_rle32(s->frame.data[0], buf, buf_size, avctx->width, avctx->height, s->frame.linesize[0]);",
          "714:         else",
          "715:             return unsupported(avctx);",
          "716:     }",
          "",
          "[Added Lines]",
          "569:         if (avctx->codec_tag == MKTAG('A','C','B','M')) {",
          "570:             if (avctx->pix_fmt == AV_PIX_FMT_PAL8 || avctx->pix_fmt == AV_PIX_FMT_GRAY8) {",
          "571:                 memset(s->frame.data[0], 0, avctx->height * s->frame.linesize[0]);",
          "572:                 for (plane = 0; plane < s->bpp; plane++) {",
          "573:                     for(y = 0; y < avctx->height && buf < buf_end; y++ ) {",
          "574:                         uint8_t *row = &s->frame.data[0][ y*s->frame.linesize[0] ];",
          "575:                         decodeplane8(row, buf, FFMIN(s->planesize, buf_end - buf), plane);",
          "576:                         buf += s->planesize;",
          "577:                     }",
          "579:             } else if (s->ham) { // HAM to AV_PIX_FMT_BGR32",
          "580:                 memset(s->frame.data[0], 0, avctx->height * s->frame.linesize[0]);",
          "581:                 for(y = 0; y < avctx->height; y++) {",
          "582:                     uint8_t *row = &s->frame.data[0][y * s->frame.linesize[0]];",
          "583:                     memset(s->ham_buf, 0, s->planesize * 8);",
          "584:                     for (plane = 0; plane < s->bpp; plane++) {",
          "585:                         const uint8_t * start = buf + (plane * avctx->height + y) * s->planesize;",
          "586:                         if (start >= buf_end)",
          "587:                             break;",
          "588:                         decodeplane8(s->ham_buf, start, FFMIN(s->planesize, buf_end - start), plane);",
          "589:                     }",
          "590:                     decode_ham_plane32((uint32_t *) row, s->ham_buf, s->ham_palbuf, s->planesize);",
          "591:                 }",
          "592:             } else",
          "593:                 return unsupported(avctx);",
          "594:         } else if (avctx->codec_tag == MKTAG('D','E','E','P')) {",
          "595:             const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(avctx->pix_fmt);",
          "596:             int raw_width = avctx->width * (av_get_bits_per_pixel(desc) >> 3);",
          "597:             int x;",
          "598:             for(y = 0; y < avctx->height && buf < buf_end; y++ ) {",
          "600:                 memcpy(row, buf, FFMIN(raw_width, buf_end - buf));",
          "601:                 buf += raw_width;",
          "602:                 if (avctx->pix_fmt == AV_PIX_FMT_BGR32) {",
          "603:                     for(x = 0; x < avctx->width; x++)",
          "604:                         row[4 * x + 3] = row[4 * x + 3] & 0xF0 | (row[4 * x + 3] >> 4);",
          "607:         } else if (avctx->codec_tag == MKTAG('I','L','B','M')) { // interleaved",
          "608:             if (avctx->pix_fmt == AV_PIX_FMT_PAL8 || avctx->pix_fmt == AV_PIX_FMT_GRAY8) {",
          "609:                 for(y = 0; y < avctx->height; y++ ) {",
          "610:                     uint8_t *row = &s->frame.data[0][ y*s->frame.linesize[0] ];",
          "611:                     memset(row, 0, avctx->width);",
          "612:                     for (plane = 0; plane < s->bpp && buf < buf_end; plane++) {",
          "613:                         decodeplane8(row, buf, FFMIN(s->planesize, buf_end - buf), plane);",
          "614:                         buf += s->planesize;",
          "615:                     }",
          "617:             } else if (s->ham) { // HAM to AV_PIX_FMT_BGR32",
          "618:                 for (y = 0; y < avctx->height; y++) {",
          "619:                     uint8_t *row = &s->frame.data[0][ y*s->frame.linesize[0] ];",
          "620:                     memset(s->ham_buf, 0, s->planesize * 8);",
          "621:                     for (plane = 0; plane < s->bpp && buf < buf_end; plane++) {",
          "622:                         decodeplane8(s->ham_buf, buf, FFMIN(s->planesize, buf_end - buf), plane);",
          "623:                         buf += s->planesize;",
          "624:                     }",
          "625:                     decode_ham_plane32((uint32_t *) row, s->ham_buf, s->ham_palbuf, s->planesize);",
          "627:             } else { // AV_PIX_FMT_BGR32",
          "628:                 for(y = 0; y < avctx->height; y++ ) {",
          "629:                     uint8_t *row = &s->frame.data[0][y*s->frame.linesize[0]];",
          "630:                     memset(row, 0, avctx->width << 2);",
          "631:                     for (plane = 0; plane < s->bpp && buf < buf_end; plane++) {",
          "632:                         decodeplane32((uint32_t *) row, buf, FFMIN(s->planesize, buf_end - buf), plane);",
          "633:                         buf += s->planesize;",
          "634:                     }",
          "637:         } else if (avctx->codec_tag == MKTAG('P','B','M',' ')) { // IFF-PBM",
          "638:             if (avctx->pix_fmt == AV_PIX_FMT_PAL8 || avctx->pix_fmt == AV_PIX_FMT_GRAY8) {",
          "639:                 for(y = 0; y < avctx->height && buf_end > buf; y++ ) {",
          "640:                     uint8_t *row = &s->frame.data[0][y * s->frame.linesize[0]];",
          "641:                     memcpy(row, buf, FFMIN(avctx->width, buf_end - buf));",
          "642:                     buf += avctx->width + (avctx->width % 2); // padding if odd",
          "643:                 }",
          "644:             } else if (s->ham) { // IFF-PBM: HAM to AV_PIX_FMT_BGR32",
          "645:                 for (y = 0; y < avctx->height && buf_end > buf; y++) {",
          "646:                     uint8_t *row = &s->frame.data[0][ y*s->frame.linesize[0] ];",
          "647:                     memcpy(s->ham_buf, buf, FFMIN(avctx->width, buf_end - buf));",
          "648:                     buf += avctx->width + (avctx->width & 1); // padding if odd",
          "649:                     decode_ham_plane32((uint32_t *) row, s->ham_buf, s->ham_palbuf, s->planesize);",
          "650:                 }",
          "651:             } else",
          "652:                 return unsupported(avctx);",
          "654:         break;",
          "656:         if (avctx->codec_tag == MKTAG('I','L','B','M')) { //interleaved",
          "657:             if (avctx->pix_fmt == AV_PIX_FMT_PAL8 || avctx->pix_fmt == AV_PIX_FMT_GRAY8) {",
          "658:                 for(y = 0; y < avctx->height ; y++ ) {",
          "659:                     uint8_t *row = &s->frame.data[0][ y*s->frame.linesize[0] ];",
          "660:                     memset(row, 0, avctx->width);",
          "661:                     for (plane = 0; plane < s->bpp; plane++) {",
          "662:                         buf += decode_byterun(s->planebuf, s->planesize, buf, buf_end);",
          "663:                         decodeplane8(row, s->planebuf, s->planesize, plane);",
          "664:                     }",
          "666:             } else if (avctx->bits_per_coded_sample <= 8) { //8-bit (+ mask) to AV_PIX_FMT_BGR32",
          "667:                 for (y = 0; y < avctx->height ; y++ ) {",
          "668:                     uint8_t *row = &s->frame.data[0][y*s->frame.linesize[0]];",
          "669:                     memset(s->mask_buf, 0, avctx->width * sizeof(uint32_t));",
          "670:                     for (plane = 0; plane < s->bpp; plane++) {",
          "671:                         buf += decode_byterun(s->planebuf, s->planesize, buf, buf_end);",
          "672:                         decodeplane32(s->mask_buf, s->planebuf, s->planesize, plane);",
          "673:                     }",
          "674:                     lookup_pal_indicies((uint32_t *) row, s->mask_buf, s->mask_palbuf, avctx->width);",
          "676:             } else if (s->ham) { // HAM to AV_PIX_FMT_BGR32",
          "677:                 for (y = 0; y < avctx->height ; y++) {",
          "678:                     uint8_t *row = &s->frame.data[0][y*s->frame.linesize[0]];",
          "679:                     memset(s->ham_buf, 0, s->planesize * 8);",
          "680:                     for (plane = 0; plane < s->bpp; plane++) {",
          "681:                         buf += decode_byterun(s->planebuf, s->planesize, buf, buf_end);",
          "682:                         decodeplane8(s->ham_buf, s->planebuf, s->planesize, plane);",
          "683:                     }",
          "684:                     decode_ham_plane32((uint32_t *) row, s->ham_buf, s->ham_palbuf, s->planesize);",
          "686:             } else { //AV_PIX_FMT_BGR32",
          "687:                 for(y = 0; y < avctx->height ; y++ ) {",
          "688:                     uint8_t *row = &s->frame.data[0][y*s->frame.linesize[0]];",
          "689:                     memset(row, 0, avctx->width << 2);",
          "690:                     for (plane = 0; plane < s->bpp; plane++) {",
          "691:                         buf += decode_byterun(s->planebuf, s->planesize, buf, buf_end);",
          "692:                         decodeplane32((uint32_t *) row, s->planebuf, s->planesize, plane);",
          "693:                     }",
          "696:         } else if (avctx->codec_tag == MKTAG('P','B','M',' ')) { // IFF-PBM",
          "697:             if (avctx->pix_fmt == AV_PIX_FMT_PAL8 || avctx->pix_fmt == AV_PIX_FMT_GRAY8) {",
          "698:                 for(y = 0; y < avctx->height ; y++ ) {",
          "699:                     uint8_t *row = &s->frame.data[0][y*s->frame.linesize[0]];",
          "700:                     buf += decode_byterun(row, avctx->width, buf, buf_end);",
          "701:                 }",
          "702:             } else if (s->ham) { // IFF-PBM: HAM to AV_PIX_FMT_BGR32",
          "703:                 for (y = 0; y < avctx->height ; y++) {",
          "704:                     uint8_t *row = &s->frame.data[0][y*s->frame.linesize[0]];",
          "705:                     buf += decode_byterun(s->ham_buf, avctx->width, buf, buf_end);",
          "706:                     decode_ham_plane32((uint32_t *) row, s->ham_buf, s->ham_palbuf, s->planesize);",
          "707:                 }",
          "708:             } else",
          "709:                 return unsupported(avctx);",
          "710:         } else if (avctx->codec_tag == MKTAG('D','E','E','P')) { // IFF-DEEP",
          "711:             const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(avctx->pix_fmt);",
          "712:             if (av_get_bits_per_pixel(desc) == 32)",
          "713:                 decode_deep_rle32(s->frame.data[0], buf, buf_size, avctx->width, avctx->height, s->frame.linesize[0]);",
          "714:             else",
          "715:                 return unsupported(avctx);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
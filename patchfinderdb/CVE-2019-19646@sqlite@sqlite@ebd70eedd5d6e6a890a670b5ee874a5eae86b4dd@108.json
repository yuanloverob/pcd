{
  "cve_id": "CVE-2019-19646",
  "cve_desc": "pragma.c in SQLite through 3.30.1 mishandles NOT NULL in an integrity_check PRAGMA command in certain cases of generated columns.",
  "repo": "sqlite/sqlite",
  "patch_hash": "ebd70eedd5d6e6a890a670b5ee874a5eae86b4dd",
  "patch_info": {
    "commit_hash": "ebd70eedd5d6e6a890a670b5ee874a5eae86b4dd",
    "repo": "sqlite/sqlite",
    "commit_url": "https://github.com/sqlite/sqlite/commit/ebd70eedd5d6e6a890a670b5ee874a5eae86b4dd",
    "files": [
      "manifest",
      "manifest.uuid",
      "src/pragma.c",
      "test/gencol1.test"
    ],
    "message": "Fix the NOT NULL verification logic in PRAGMA integrity_check so that it works for generated columns whose value is the result of a comparison operator. Ticket [bd8c280671ba44a7]\n\nFossilOrigin-Name: f3b39c71b88cb6721f443de56cdce4c08252453a5e340b00a2bd88dc10c42400",
    "before_after_code_files": [
      "manifest.uuid||manifest.uuid",
      "src/pragma.c||src/pragma.c",
      "test/gencol1.test||test/gencol1.test"
    ]
  },
  "patch_diff": {
    "manifest.uuid||manifest.uuid": [
      "File: manifest.uuid -> manifest.uuid",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "1: e3398c5ffb060b2b26334b8598e2c63953741e2d6f5124dbd6bdfc8e94742539",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "src/pragma.c||src/pragma.c": [
      "File: src/pragma.c -> src/pragma.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1596:           if( j==pTab->iPKey ) continue;",
      "1597:           if( pTab->aCol[j].notNull==0 ) continue;",
      "1598:           sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, j, 3);",
      "1600:           jmp2 = sqlite3VdbeAddOp1(v, OP_NotNull, 3); VdbeCoverage(v);",
      "1601:           zErr = sqlite3MPrintf(db, \"NULL value in %s.%s\", pTab->zName,",
      "1602:                               pTab->aCol[j].zName);",
      "",
      "[Removed Lines]",
      "1599:           sqlite3VdbeChangeP5(v, OPFLAG_TYPEOFARG);",
      "",
      "[Added Lines]",
      "1599:           if( sqlite3VdbeGetOp(v,-1)->opcode==OP_Column ){",
      "1600:             sqlite3VdbeChangeP5(v, OPFLAG_TYPEOFARG);",
      "1601:           }",
      "",
      "---------------"
    ],
    "test/gencol1.test||test/gencol1.test": [
      "File: test/gencol1.test -> test/gencol1.test",
      "--- Hunk 1 ---",
      "[Context before]",
      "328:   INSERT OR REPLACE INTO t0(c0, c1) VALUES (2, 1), (1, 0)",
      "329: } {1 {FOREIGN KEY constraint failed}}",
      "331: finish_test",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "331: # 2019-12-09 ticket bd8c280671ba44a7",
      "332: # With generated columns, the sqlite3ExprGetColumnOfTable() routine might",
      "333: # generate a code sequence that does not end with OP_Column.  So check to",
      "334: # make sure that the last instruction generated is an OP_column prior to",
      "335: # applying the OPFLAG_TYPEOFARG optimization to NOT NULL checks in the",
      "336: # PRAGMA integrity_check code.",
      "337: #",
      "338: sqlite3 db :memory:",
      "339: do_execsql_test gencol1-12.10 {",
      "340:   CREATE TABLE t0 (c0, c1 NOT NULL AS (c0==0));",
      "341:   INSERT INTO t0(c0) VALUES (0);",
      "342:   PRAGMA integrity_check;",
      "343: } {ok}",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "bffdd636339b32c706253e8c791ccca8b3f88f19",
      "candidate_info": {
        "commit_hash": "bffdd636339b32c706253e8c791ccca8b3f88f19",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/bffdd636339b32c706253e8c791ccca8b3f88f19",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/expr.c",
          "test/check.test",
          "test/indexexpr1.test"
        ],
        "message": "When computing an expression value for an index-on-expression or a CHECK constraint and the expressions uses a REAL table column, but the value of that column is an integer (in other words, when it is using the store-real-as-integer optimization) be sure to promote the value to real before evaluating the expression.  Ticket [57af00b6642ecd68].\n\nFossilOrigin-Name: 0658c16e311393c8a347b1bd41fa5dbfd2e184aa75d84c011aa8dbac79b632e9",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/expr.c||src/expr.c",
          "test/check.test||test/check.test",
          "test/indexexpr1.test||test/indexexpr1.test"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: f6d8956cf8b5993a4332b9330e89d5c3d5f8872ea5a2ce3d2e91127406cc1839",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/expr.c||src/expr.c": [
          "File: src/expr.c -> src/expr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3532:       if( iTab<0 ){",
          "3533:         if( pParse->iSelfTab<0 ){",
          "3536:         }else{",
          "",
          "[Removed Lines]",
          "3535:           return pExpr->iColumn - pParse->iSelfTab;",
          "",
          "[Added Lines]",
          "3535:           assert( pExpr->y.pTab!=0 );",
          "3536:           assert( pExpr->iColumn>=XN_ROWID );",
          "3537:           assert( pExpr->iColumn<pExpr->y.pTab->nCol );",
          "3538:           if( pExpr->iColumn>=0",
          "3539:             && pExpr->y.pTab->aCol[pExpr->iColumn].affinity==SQLITE_AFF_REAL",
          "3540:           ){",
          "3541:             sqlite3VdbeAddOp2(v, OP_SCopy, pExpr->iColumn - pParse->iSelfTab,",
          "3542:                               target);",
          "3543:             sqlite3VdbeAddOp1(v, OP_RealAffinity, target);",
          "3544:             return target;",
          "3545:           }else{",
          "3546:             return pExpr->iColumn - pParse->iSelfTab;",
          "3547:           }",
          "",
          "---------------"
        ],
        "test/check.test||test/check.test": [
          "File: test/check.test -> test/check.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "123:       y REAL CONSTRAINT two CHECK( typeof(coalesce(y,0.1))=='real' ),",
          "124:       z TEXT CONSTRAINT three CHECK( typeof(coalesce(z,''))=='text' )",
          "125:     );",
          "126:     PRAGMA writable_schema = 0;",
          "127:   }",
          "128: } {}",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "126:     CREATE TABLE t2n(",
          "127:       x INTEGER CONSTRAINT one CHECK( typeof(coalesce(x,0))==\"integer\" ),",
          "128:       y NUMERIC CONSTRAINT two CHECK( typeof(coalesce(y,0.1))=='real' ),",
          "129:       z TEXT CONSTRAINT three CHECK( typeof(coalesce(z,''))=='text' )",
          "130:     );",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "146:   }",
          "147: } {1 {CHECK constraint failed: one}}",
          "148: do_test check-2.5 {",
          "149:   catchsql {",
          "150:     INSERT INTO t2 VALUES(NULL, 5, NULL);",
          "151:   }",
          "152: } {1 {CHECK constraint failed: two}}",
          "153: do_test check-2.6 {",
          "154:   catchsql {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "154:   # The 5 gets automatically promoted to 5.0 because the column type is REAL",
          "158: } {0 {}}",
          "159: do_test check-2.5b {",
          "160:   # This time the column type is NUMERIC, so not automatic promption to REAL",
          "161:   # occurs and the constraint fails.",
          "162:   catchsql {",
          "163:     INSERT INTO t2n VALUES(NULL, 5, NULL);",
          "164:   }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "195:   execsql {",
          "196:     DROP TABLE IF EXISTS t2b;",
          "197:     DROP TABLE IF EXISTS t2c;",
          "198:   }",
          "199: } {}",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "211:     DROP TABLE IF EXISTS t2n;",
          "",
          "---------------"
        ],
        "test/indexexpr1.test||test/indexexpr1.test": [
          "File: test/indexexpr1.test -> test/indexexpr1.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "457:   SELECT * FROM t0 WHERE ((NULL IS FALSE) IS FALSE);",
          "458: } {0}",
          "460: finish_test",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "460: # 2019-09-02 https://www.sqlite.org/src/tktview/57af00b6642ecd6848",
          "461: # When the expression of an an index-on-expression references a",
          "462: # table column of type REAL that is actually holding an MEM_IntReal",
          "463: # value, be sure to use the REAL value and not the INT value when",
          "464: # computing the expression.",
          "465: #",
          "466: do_execsql_test indexexpr-1800 {",
          "467:   DROP TABLE IF EXISTS t0;",
          "468:   CREATE TABLE t0(c0 REAL, c1 TEXT);",
          "469:   CREATE INDEX i0 ON t0(+c0, c0);",
          "470:   INSERT INTO t0(c0) VALUES(0);",
          "471:   SELECT CAST(+ t0.c0 AS BLOB) LIKE 0 FROM t0;",
          "472: } {0}",
          "473: do_execsql_test indexexpr-1810 {",
          "474:   SELECT CAST(+ t0.c0 AS BLOB) LIKE '0.0' FROM t0;",
          "475: } {1}",
          "476: do_execsql_test indexexpr-1820 {",
          "477:   DROP TABLE IF EXISTS t1;",
          "478:   CREATE TABLE t1(x REAL);",
          "479:   CREATE INDEX t1x ON t1(x, +x);",
          "480:   INSERT INTO t1(x) VALUES(2);",
          "481:   SELECT +x FROM t1 WHERE x=2;",
          "482: } {2.0}",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "7fe2fc0dcb0bb214fe83a8a8fcdeb553fb20b97d",
      "candidate_info": {
        "commit_hash": "7fe2fc0dcb0bb214fe83a8a8fcdeb553fb20b97d",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/7fe2fc0dcb0bb214fe83a8a8fcdeb553fb20b97d",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/build.c",
          "src/expr.c",
          "test/gencol1.test"
        ],
        "message": "Fix a problem with foreign keys and generated columns discovered by Manuel Rigger.\n\nFossilOrigin-Name: 27c0fdab1ba4d4993b164eb4b777c63e82aa247c3fa406121dc8ed94970a0b35",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/build.c||src/build.c",
          "src/expr.c||src/expr.c",
          "test/gencol1.test||test/gencol1.test"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid",
            "test/gencol1.test||test/gencol1.test"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid",
            "test/gencol1.test||test/gencol1.test"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: ef73107f475e40e6bdd8b722e96992070f81fd2b7a3cb718ec8f251c89ca3e81",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/build.c||src/build.c": [
          "File: src/build.c -> src/build.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "952: i16 sqlite3TableColumnToStorage(Table *pTab, i16 iCol){",
          "953:   int i;",
          "954:   i16 n;",
          "955:   assert( iCol<pTab->nCol );",
          "957:   for(i=0, n=0; i<iCol; i++){",
          "958:     if( (pTab->aCol[i].colFlags & COLFLAG_VIRTUAL)==0 ) n++;",
          "959:   }",
          "",
          "[Removed Lines]",
          "956:   if( (pTab->tabFlags & TF_HasVirtual)==0 ) return iCol;",
          "",
          "[Added Lines]",
          "958:   if( (pTab->tabFlags & TF_HasVirtual)==0 || iCol<0 ) return iCol;",
          "",
          "---------------"
        ],
        "src/expr.c||src/expr.c": [
          "File: src/expr.c -> src/expr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4136:       Table *pTab = pExpr->y.pTab;",
          "4137:       int iCol = pExpr->iColumn;",
          "4138:       int p1 = pExpr->iTable * (pTab->nCol+1) + 1",
          "4141:       assert( pExpr->iTable==0 || pExpr->iTable==1 );",
          "4142:       assert( iCol>=-1 && iCol<pTab->nCol );",
          "",
          "[Removed Lines]",
          "4139:                      + (iCol>=0 ? sqlite3TableColumnToStorage(pTab, iCol) : -1);",
          "",
          "[Added Lines]",
          "4139:                      + sqlite3TableColumnToStorage(pTab, iCol);",
          "",
          "---------------"
        ],
        "test/gencol1.test||test/gencol1.test": [
          "File: test/gencol1.test -> test/gencol1.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "272:   PRAGMA integrity_check;",
          "273: } {ok}",
          "275: finish_test",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "275: # 2019-12-06 Found by mrigger",
          "276: #",
          "277: sqlite3 db :memory:",
          "278: do_execsql_test gencol1-11.10 {",
          "279:   PRAGMA foreign_keys = true;",
          "280:   CREATE TABLE t0(",
          "281:     c0,",
          "282:     c1 INTEGER PRIMARY KEY,",
          "283:     c2 BLOB UNIQUE DEFAULT x'00',",
          "284:     c3 BLOB GENERATED ALWAYS AS (1),",
          "285:     FOREIGN KEY(c1) REFERENCES t0(c2)",
          "286:   );",
          "287: }",
          "288: do_catchsql_test gencol1-11.20 {",
          "289:   INSERT OR REPLACE INTO t0(c0, c1) VALUES (2, 1), (1, 0)",
          "290: } {1 {FOREIGN KEY constraint failed}}",
          "291: do_execsql_test gencol1-11.30 {",
          "292:   DROP TABLE t0;",
          "293:   CREATE TABLE t0(",
          "294:     c0,",
          "295:     c1 INTEGER PRIMARY KEY,",
          "296:     c3 BLOB GENERATED ALWAYS AS (1),",
          "297:     c2 BLOB UNIQUE DEFAULT x'00',",
          "298:     FOREIGN KEY(c1) REFERENCES t0(c2)",
          "299:   );",
          "300: }",
          "301: do_catchsql_test gencol1-11.40 {",
          "302:   INSERT OR REPLACE INTO t0(c0, c1) VALUES (2, 1), (1, 0)",
          "303: } {1 {FOREIGN KEY constraint failed}}",
          "304: do_execsql_test gencol1-11.50 {",
          "305:   DROP TABLE t0;",
          "306:   CREATE TABLE t0(",
          "307:     c0,",
          "308:     c3 BLOB GENERATED ALWAYS AS (1),",
          "309:     c1 INTEGER PRIMARY KEY,",
          "310:     c2 BLOB UNIQUE DEFAULT x'00',",
          "311:     FOREIGN KEY(c1) REFERENCES t0(c2)",
          "312:   );",
          "313: }",
          "314: do_catchsql_test gencol1-11.60 {",
          "315:   INSERT OR REPLACE INTO t0(c0, c1) VALUES (2, 1), (1, 0)",
          "316: } {1 {FOREIGN KEY constraint failed}}",
          "317: do_execsql_test gencol1-11.70 {",
          "318:   DROP TABLE t0;",
          "319:   CREATE TABLE t0(",
          "320:     c3 BLOB GENERATED ALWAYS AS (1),",
          "321:     c0,",
          "322:     c1 INTEGER PRIMARY KEY,",
          "323:     c2 BLOB UNIQUE DEFAULT x'00',",
          "324:     FOREIGN KEY(c1) REFERENCES t0(c2)",
          "325:   );",
          "326: }",
          "327: do_catchsql_test gencol1-11.80 {",
          "328:   INSERT OR REPLACE INTO t0(c0, c1) VALUES (2, 1), (1, 0)",
          "329: } {1 {FOREIGN KEY constraint failed}}",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "d0fb7960cea5d26a40a0a7ca00c4274545e96efe",
      "candidate_info": {
        "commit_hash": "d0fb7960cea5d26a40a0a7ca00c4274545e96efe",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/d0fb7960cea5d26a40a0a7ca00c4274545e96efe",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/vdbe.c"
        ],
        "message": "Small changes to the OP_OpenEphemeral opcode to improve testability.\n\nFossilOrigin-Name: f856676c8438dbf52d299e78f6dd6148d929755dc05cdcabafd17d9a86439435",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/vdbe.c||src/vdbe.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 4678cb1044f0b4dc813e48f3bd0f85240a66e2ecf8763280d66726cc031c93a7",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/vdbe.c||src/vdbe.c": [
          "File: src/vdbe.c -> src/vdbe.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3669:     rc = sqlite3BtreeClearTable(pCx->pBtx, pCx->pgnoRoot, 0);",
          "3698:       }",
          "3705:     }",
          "3706:   }",
          "3707:   if( rc ) goto abort_due_to_error;",
          "3709:   break;",
          "3710: }",
          "",
          "[Removed Lines]",
          "3670:     if( rc ) goto abort_due_to_error;",
          "3671:     break;",
          "3672:   }",
          "3673:   pCx = allocateCursor(p, pOp->p1, pOp->p2, -1, CURTYPE_BTREE);",
          "3674:   if( pCx==0 ) goto no_mem;",
          "3675:   pCx->nullRow = 1;",
          "3676:   pCx->isEphemeral = 1;",
          "3677:   rc = sqlite3BtreeOpen(db->pVfs, 0, db, &pCx->pBtx,",
          "3678:                         BTREE_OMIT_JOURNAL | BTREE_SINGLE | pOp->p5, vfsFlags);",
          "3679:   if( rc==SQLITE_OK ){",
          "3680:     rc = sqlite3BtreeBeginTrans(pCx->pBtx, 1, 0);",
          "3681:   }",
          "3682:   if( rc==SQLITE_OK ){",
          "3688:     if( (pCx->pKeyInfo = pKeyInfo = pOp->p4.pKeyInfo)!=0 ){",
          "3689:       assert( pOp->p4type==P4_KEYINFO );",
          "3690:       rc = sqlite3BtreeCreateTable(pCx->pBtx, (int*)&pCx->pgnoRoot,",
          "3691:                                    BTREE_BLOBKEY | pOp->p5);",
          "3692:       if( rc==SQLITE_OK ){",
          "3693:         assert( pCx->pgnoRoot==MASTER_ROOT+1 );",
          "3694:         assert( pKeyInfo->db==db );",
          "3695:         assert( pKeyInfo->enc==ENC(db) );",
          "3696:         rc = sqlite3BtreeCursor(pCx->pBtx, pCx->pgnoRoot, BTREE_WRCSR,",
          "3697:                                 pKeyInfo, pCx->uc.pCursor);",
          "3699:       pCx->isTable = 0;",
          "3700:     }else{",
          "3701:       pCx->pgnoRoot = MASTER_ROOT;",
          "3702:       rc = sqlite3BtreeCursor(pCx->pBtx, MASTER_ROOT, BTREE_WRCSR,",
          "3703:                               0, pCx->uc.pCursor);",
          "3704:       pCx->isTable = 1;",
          "3708:   pCx->isOrdered = (pOp->p5!=BTREE_UNORDERED);",
          "",
          "[Added Lines]",
          "3670:   }else{",
          "3671:     pCx = allocateCursor(p, pOp->p1, pOp->p2, -1, CURTYPE_BTREE);",
          "3672:     if( pCx==0 ) goto no_mem;",
          "3673:     pCx->nullRow = 1;",
          "3674:     pCx->isEphemeral = 1;",
          "3675:     rc = sqlite3BtreeOpen(db->pVfs, 0, db, &pCx->pBtx,",
          "3676:                           BTREE_OMIT_JOURNAL | BTREE_SINGLE | pOp->p5,",
          "3677:                           vfsFlags);",
          "3678:     if( rc==SQLITE_OK ){",
          "3679:       rc = sqlite3BtreeBeginTrans(pCx->pBtx, 1, 0);",
          "3680:     }",
          "3681:     if( rc==SQLITE_OK ){",
          "3687:       if( (pCx->pKeyInfo = pKeyInfo = pOp->p4.pKeyInfo)!=0 ){",
          "3688:         assert( pOp->p4type==P4_KEYINFO );",
          "3689:         rc = sqlite3BtreeCreateTable(pCx->pBtx, (int*)&pCx->pgnoRoot,",
          "3690:                                      BTREE_BLOBKEY | pOp->p5);",
          "3691:         if( rc==SQLITE_OK ){",
          "3692:           assert( pCx->pgnoRoot==MASTER_ROOT+1 );",
          "3693:           assert( pKeyInfo->db==db );",
          "3694:           assert( pKeyInfo->enc==ENC(db) );",
          "3695:           rc = sqlite3BtreeCursor(pCx->pBtx, pCx->pgnoRoot, BTREE_WRCSR,",
          "3696:                                   pKeyInfo, pCx->uc.pCursor);",
          "3697:         }",
          "3698:         pCx->isTable = 0;",
          "3699:       }else{",
          "3700:         pCx->pgnoRoot = MASTER_ROOT;",
          "3701:         rc = sqlite3BtreeCursor(pCx->pBtx, MASTER_ROOT, BTREE_WRCSR,",
          "3702:                                 0, pCx->uc.pCursor);",
          "3703:         pCx->isTable = 1;",
          "3706:     pCx->isOrdered = (pOp->p5!=BTREE_UNORDERED);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "e45985b5951c8afc544361157c819717641df7ee",
      "candidate_info": {
        "commit_hash": "e45985b5951c8afc544361157c819717641df7ee",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/e45985b5951c8afc544361157c819717641df7ee",
        "files": [
          "manifest",
          "manifest.uuid",
          "test/fuzzcheck.c"
        ],
        "message": "Fix a bug in the custom in-memory VFS used by fuzzcheck.  This bug masks other bugs that should have caused some existing fuzzdata7.db entries to fail, and so this fix is initially on a branch until those other bugs can be repaired.\n\nFossilOrigin-Name: e0994e99955cf11f23dba029b5ed7f150f467887558848d5f03510e2fb5855f9",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "test/fuzzcheck.c||test/fuzzcheck.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 18740bd448887d618fafee0b5a7c004aa2f2632244f7d29e2428772baa36b828",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "test/fuzzcheck.c||test/fuzzcheck.c": [
          "File: test/fuzzcheck.c -> test/fuzzcheck.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "447:   if( iOfst+iAmt>pVFile->sz ){",
          "448:     memset(pData, 0, iAmt);",
          "449:     iAmt = (int)(pVFile->sz - iOfst);",
          "451:     return SQLITE_IOERR_SHORT_READ;",
          "452:   }",
          "453:   memcpy(pData, pVFile->a + iOfst, iAmt);",
          "",
          "[Removed Lines]",
          "450:     memcpy(pData, pVFile->a, iAmt);",
          "",
          "[Added Lines]",
          "450:     memcpy(pData, pVFile->a + iOfst, iAmt);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b008e4d744175052c219ab78db1ea3732682ceb3",
      "candidate_info": {
        "commit_hash": "b008e4d744175052c219ab78db1ea3732682ceb3",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/b008e4d744175052c219ab78db1ea3732682ceb3",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/loadext.c",
          "test/without_rowid1.test",
          "test/without_rowid6.test",
          "test/without_rowid7.test"
        ],
        "message": "Fix some test script issues that come up with SQLITE_OMIT_VIRTUALTABLE builds.\n\nFossilOrigin-Name: 3934d2d08ee14d644dc01f967c10f219b76b172c963c90a7a8141f2b08a7d5bf",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/loadext.c||src/loadext.c",
          "test/without_rowid1.test||test/without_rowid1.test",
          "test/without_rowid6.test||test/without_rowid6.test",
          "test/without_rowid7.test||test/without_rowid7.test"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 9e0d5d2640a92070967bc9fdf5c5b1653e41b9c04e04dcb70f18ead10f053aef",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/loadext.c||src/loadext.c": [
          "File: src/loadext.c -> src/loadext.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "463:   sqlite3_stmt_isexplain,",
          "464:   sqlite3_value_frombind,",
          "466:   sqlite3_drop_modules,",
          "467: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "466: #ifndef SQLITE_OMIT_VIRTUALTABLE",
          "468: #else",
          "469:   0,",
          "470: #endif",
          "",
          "---------------"
        ],
        "test/without_rowid1.test||test/without_rowid1.test": [
          "File: test/without_rowid1.test -> test/without_rowid1.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "17: source $testdir/tester.tcl",
          "18: set testprefix without_rowid1",
          "20: # Create and query a WITHOUT ROWID table.",
          "21: #",
          "22: do_execsql_test without_rowid1-1.0 {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "20: proc do_execsql_test_if_vtab {tn sql {res {}}} {",
          "21:   ifcapable vtab { uplevel [list do_execsql_test $tn $sql $res] }",
          "22: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "32: integrity_check without_rowid1-1.0ic",
          "35:   SELECT name, key FROM pragma_index_xinfo('t1');",
          "36: } {c 1 a 1 b 0 d 0}",
          "",
          "[Removed Lines]",
          "34: do_execsql_test without_rowid1-1.0ixi {",
          "",
          "[Added Lines]",
          "38: do_execsql_test_if_vtab without_rowid1-1.0ixi {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "119:   UPDATE t4 SET a = 'ABC';",
          "120:   SELECT * FROM t4;",
          "121: } {ABC def}",
          "123:   SELECT name, coll, key FROM pragma_index_xinfo('t4');",
          "124: } {a nocase 1 b BINARY 0}",
          "",
          "[Removed Lines]",
          "122: do_execsql_test 2.1.3 {",
          "",
          "[Added Lines]",
          "126: do_execsql_test_if_vtab 2.1.3 {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "135:   SELECT * FROM t4;",
          "136: } {xyz ABC}",
          "139:   SELECT name, coll, key FROM pragma_index_xinfo('t4');",
          "140: } {a nocase 1 b BINARY 0}",
          "",
          "[Removed Lines]",
          "138: do_execsql_test 2.2.3 {",
          "",
          "[Added Lines]",
          "142: do_execsql_test_if_vtab 2.2.3 {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "146:   UPDATE t5 SET a='abc', b='def';",
          "147: } {}",
          "150:   SELECT name, coll, key FROM pragma_index_xinfo('t5');",
          "151: } {b BINARY 1 a BINARY 1}",
          "",
          "[Removed Lines]",
          "149: do_execsql_test 2.3.2 {",
          "",
          "[Added Lines]",
          "153: do_execsql_test_if_vtab 2.3.2 {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "165:   SELECT * FROM t6 ORDER BY c;",
          "166: } {ABC def ghi ABC def ghi}",
          "169:   SELECT name, coll, key FROM pragma_index_xinfo('t6');",
          "170: } {b BINARY 1 a nocase 1 c BINARY 0}",
          "",
          "[Removed Lines]",
          "168: do_execsql_test 2.4.3 {",
          "",
          "[Added Lines]",
          "172: do_execsql_test_if_vtab 2.4.3 {",
          "",
          "---------------"
        ],
        "test/without_rowid6.test||test/without_rowid6.test": [
          "File: test/without_rowid6.test -> test/without_rowid6.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "16: set testdir [file dirname $argv0]",
          "17: source $testdir/tester.tcl",
          "19: do_execsql_test without_rowid6-100 {",
          "20:   CREATE TABLE t1(a,b,c,d,e, PRIMARY KEY(a,b,c,a,b,c,d,a,b,c)) WITHOUT ROWID;",
          "21:   CREATE INDEX t1a ON t1(b, b);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "19: proc do_execsql_test_if_vtab {tn sql {res {}}} {",
          "20:   ifcapable vtab { uplevel [list do_execsql_test $tn $sql $res] }",
          "21: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "24:   INSERT INTO t1(a,b,c,d,e) SELECT i, i+1000, printf('x%dy',i), 0, 0 FROM c;",
          "25:   ANALYZE;",
          "26: } {}",
          "28:   SELECT name, key FROM pragma_index_xinfo('t1');",
          "29: } {a 1 b 1 c 1 d 1 e 0}",
          "30: do_execsql_test without_rowid6-110 {",
          "",
          "[Removed Lines]",
          "27: do_execsql_test without_rowid6-101 {",
          "",
          "[Added Lines]",
          "31: do_execsql_test_if_vtab without_rowid6-101 {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "54:   INSERT INTO t1(a,b,c) VALUES(1,8,3),(4,5,6),(7,2,9);",
          "55:   SELECT a FROM t1 WHERE b>3 ORDER BY b;",
          "56: } {4 1}",
          "58:   SELECT name, key FROM pragma_index_xinfo('t1');",
          "59: } {b 1 a 0 c 0}",
          "60: do_execsql_test without_rowid6-210 {",
          "",
          "[Removed Lines]",
          "57: do_execsql_test without_rowid6-201 {",
          "",
          "[Added Lines]",
          "61: do_execsql_test_if_vtab without_rowid6-201 {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "111:   INSERT INTO t1(a,b,c) VALUES(1,8,3),(4,5,6),(7,2,9);",
          "112:   SELECT a FROM t1 WHERE b>3 ORDER BY b;",
          "113: } {4 1}",
          "115:   SELECT name, key FROM pragma_index_xinfo('t1');",
          "116: } {b 1 c 1 a 0}",
          "117: do_execsql_test without_rowid6-510 {",
          "",
          "[Removed Lines]",
          "114: do_execsql_test without_rowid6-501 {",
          "",
          "[Added Lines]",
          "118: do_execsql_test_if_vtab without_rowid6-501 {",
          "",
          "---------------"
        ],
        "test/without_rowid7.test||test/without_rowid7.test": [
          "File: test/without_rowid7.test -> test/without_rowid7.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "15: source $testdir/tester.tcl",
          "16: set testprefix without_rowid7",
          "18: do_execsql_test 1.0 {",
          "19:   CREATE TABLE t1(a, b COLLATE nocase, PRIMARY KEY(a, a, b)) WITHOUT ROWID;",
          "20: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "18: proc do_execsql_test_if_vtab {tn sql {res {}}} {",
          "19:   ifcapable vtab { uplevel [list do_execsql_test $tn $sql $res] }",
          "20: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "36: do_execsql_test 2.2a {",
          "37:   PRAGMA index_info(t2);",
          "38: } {0 0 a 1 0 a}",
          "40:   SELECT *, '|' FROM pragma_index_info('t2');",
          "41: } {0 0 a | 1 0 a |}",
          "42: do_execsql_test 2.3a {",
          "43:   PRAGMA index_xinfo(t2);",
          "44: } {0 0 a 0 nocase 1 1 0 a 0 BINARY 1 2 1 b 0 BINARY 0}",
          "46:   SELECT *, '|' FROM pragma_index_xinfo('t2');",
          "47: } {0 0 a 0 nocase 1 | 1 0 a 0 BINARY 1 | 2 1 b 0 BINARY 0 |}",
          "",
          "[Removed Lines]",
          "39: do_execsql_test 2.2b {",
          "45: do_execsql_test 2.3b {",
          "",
          "[Added Lines]",
          "43: do_execsql_test_if_vtab 2.2b {",
          "49: do_execsql_test_if_vtab 2.3b {",
          "",
          "---------------"
        ]
      }
    }
  ]
}
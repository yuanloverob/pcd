{
  "cve_id": "CVE-2018-18021",
  "cve_desc": "arch/arm64/kvm/guest.c in KVM in the Linux kernel before 4.18.12 on the arm64 platform mishandles the KVM_SET_ON_REG ioctl. This is exploitable by attackers who can create virtual machines. An attacker can arbitrarily redirect the hypervisor flow of control (with full register control). An attacker can also cause a denial of service (hypervisor panic) via an illegal exception return. This occurs because of insufficient restrictions on userspace access to the core register file, and because PSTATE.M validation does not prevent unintended execution modes.",
  "repo": "torvalds/linux",
  "patch_hash": "2a3f93459d689d990b3ecfbe782fec89b97d3279",
  "patch_info": {
    "commit_hash": "2a3f93459d689d990b3ecfbe782fec89b97d3279",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/2a3f93459d689d990b3ecfbe782fec89b97d3279",
    "files": [
      "arch/arm64/kvm/guest.c"
    ],
    "message": "arm64: KVM: Sanitize PSTATE.M when being set from userspace\n\nNot all execution modes are valid for a guest, and some of them\ndepend on what the HW actually supports. Let's verify that what\nuserspace provides is compatible with both the VM settings and\nthe HW capabilities.\n\nCc: <stable@vger.kernel.org>\nFixes: 0d854a60b1d7 (\"arm64: KVM: enable initialization of a 32bit vcpu\")\nReviewed-by: Christoffer Dall <christoffer.dall@arm.com>\nReviewed-by: Mark Rutland <mark.rutland@arm.com>\nReviewed-by: Dave Martin <Dave.Martin@arm.com>\nSigned-off-by: Marc Zyngier <marc.zyngier@arm.com>\nSigned-off-by: Will Deacon <will.deacon@arm.com>",
    "before_after_code_files": [
      "arch/arm64/kvm/guest.c||arch/arm64/kvm/guest.c"
    ]
  },
  "patch_diff": {
    "arch/arm64/kvm/guest.c||arch/arm64/kvm/guest.c": [
      "File: arch/arm64/kvm/guest.c -> arch/arm64/kvm/guest.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "152:  }",
      "154:  if (off == KVM_REG_ARM_CORE_REG(regs.pstate)) {",
      "156:   switch (mode) {",
      "157:   case PSR_AA32_MODE_USR:",
      "158:   case PSR_AA32_MODE_FIQ:",
      "159:   case PSR_AA32_MODE_IRQ:",
      "160:   case PSR_AA32_MODE_SVC:",
      "161:   case PSR_AA32_MODE_ABT:",
      "162:   case PSR_AA32_MODE_UND:",
      "163:   case PSR_MODE_EL0t:",
      "164:   case PSR_MODE_EL1t:",
      "165:   case PSR_MODE_EL1h:",
      "166:    break;",
      "167:   default:",
      "168:    err = -EINVAL;",
      "",
      "[Removed Lines]",
      "155:   u32 mode = (*(u32 *)valp) & PSR_AA32_MODE_MASK;",
      "",
      "[Added Lines]",
      "155:   u64 mode = (*(u64 *)valp) & PSR_AA32_MODE_MASK;",
      "158:    if (!system_supports_32bit_el0())",
      "159:     return -EINVAL;",
      "160:    break;",
      "166:    if (!vcpu_el1_is_32bit(vcpu))",
      "167:     return -EINVAL;",
      "168:    break;",
      "172:    if (vcpu_el1_is_32bit(vcpu))",
      "173:     return -EINVAL;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "256c0960b7b6453dc90a4e879da52ab76b4037f9",
      "candidate_info": {
        "commit_hash": "256c0960b7b6453dc90a4e879da52ab76b4037f9",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/256c0960b7b6453dc90a4e879da52ab76b4037f9",
        "files": [
          "arch/arm/include/asm/kvm_emulate.h",
          "arch/arm64/include/asm/kvm_emulate.h",
          "arch/arm64/kvm/guest.c",
          "arch/arm64/kvm/hyp/vgic-v2-cpuif-proxy.c",
          "arch/arm64/kvm/regmap.c",
          "arch/arm64/kvm/reset.c",
          "virt/kvm/arm/aarch32.c"
        ],
        "message": "kvm/arm: use PSR_AA32 definitions\n\nSome code cares about the SPSR_ELx format for exceptions taken from\nAArch32 to inspect or manipulate the SPSR_ELx value, which is already in\nthe SPSR_ELx format, and not in the AArch32 PSR format.\n\nTo separate these from cases where we care about the AArch32 PSR format,\nmigrate these cases to use the PSR_AA32_* definitions rather than\nCOMPAT_PSR_*.\n\nThere should be no functional change as a result of this patch.\n\nNote that arm64 KVM does not support a compat KVM API, and always uses\nthe SPSR_ELx format, even for AArch32 guests.\n\nSigned-off-by: Mark Rutland <mark.rutland@arm.com>\nAcked-by: Christoffer Dall <christoffer.dall@arm.com>\nAcked-by: Marc Zyngier <marc.zyngier@arm.com>\nSigned-off-by: Will Deacon <will.deacon@arm.com>",
        "before_after_code_files": [
          "arch/arm/include/asm/kvm_emulate.h||arch/arm/include/asm/kvm_emulate.h",
          "arch/arm64/include/asm/kvm_emulate.h||arch/arm64/include/asm/kvm_emulate.h",
          "arch/arm64/kvm/guest.c||arch/arm64/kvm/guest.c",
          "arch/arm64/kvm/hyp/vgic-v2-cpuif-proxy.c||arch/arm64/kvm/hyp/vgic-v2-cpuif-proxy.c",
          "arch/arm64/kvm/regmap.c||arch/arm64/kvm/regmap.c",
          "arch/arm64/kvm/reset.c||arch/arm64/kvm/reset.c",
          "virt/kvm/arm/aarch32.c||virt/kvm/arm/aarch32.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "arch/arm64/kvm/guest.c||arch/arm64/kvm/guest.c"
          ],
          "candidate": [
            "arch/arm64/kvm/guest.c||arch/arm64/kvm/guest.c"
          ]
        }
      },
      "candidate_diff": {
        "arch/arm/include/asm/kvm_emulate.h||arch/arm/include/asm/kvm_emulate.h": [
          "File: arch/arm/include/asm/kvm_emulate.h -> arch/arm/include/asm/kvm_emulate.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "26: #include <asm/cputype.h>",
          "37: unsigned long *vcpu_reg(struct kvm_vcpu *vcpu, u8 reg_num);",
          "",
          "[Removed Lines]",
          "29: #define COMPAT_PSR_MODE_ABT ABT_MODE",
          "30: #define COMPAT_PSR_MODE_UND UND_MODE",
          "31: #define COMPAT_PSR_T_BIT PSR_T_BIT",
          "32: #define COMPAT_PSR_I_BIT PSR_I_BIT",
          "33: #define COMPAT_PSR_A_BIT PSR_A_BIT",
          "34: #define COMPAT_PSR_E_BIT PSR_E_BIT",
          "35: #define COMPAT_PSR_IT_MASK PSR_IT_MASK",
          "",
          "[Added Lines]",
          "29: #define PSR_AA32_MODE_ABT ABT_MODE",
          "30: #define PSR_AA32_MODE_UND UND_MODE",
          "31: #define PSR_AA32_T_BIT  PSR_T_BIT",
          "32: #define PSR_AA32_I_BIT  PSR_I_BIT",
          "33: #define PSR_AA32_A_BIT  PSR_A_BIT",
          "34: #define PSR_AA32_E_BIT  PSR_E_BIT",
          "35: #define PSR_AA32_IT_MASK PSR_IT_MASK",
          "",
          "---------------"
        ],
        "arch/arm64/include/asm/kvm_emulate.h||arch/arm64/include/asm/kvm_emulate.h": [
          "File: arch/arm64/include/asm/kvm_emulate.h -> arch/arm64/include/asm/kvm_emulate.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "190:  u32 mode;",
          "192:  if (vcpu_mode_is_32bit(vcpu)) {",
          "195:  }",
          "197:  mode = *vcpu_cpsr(vcpu) & PSR_MODE_MASK;",
          "",
          "[Removed Lines]",
          "193:   mode = *vcpu_cpsr(vcpu) & COMPAT_PSR_MODE_MASK;",
          "194:   return mode > COMPAT_PSR_MODE_USR;",
          "",
          "[Added Lines]",
          "193:   mode = *vcpu_cpsr(vcpu) & PSR_AA32_MODE_MASK;",
          "194:   return mode > PSR_AA32_MODE_USR;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "340: static inline bool kvm_vcpu_is_be(struct kvm_vcpu *vcpu)",
          "341: {",
          "342:  if (vcpu_mode_is_32bit(vcpu))",
          "345:  return !!(vcpu_read_sys_reg(vcpu, SCTLR_EL1) & (1 << 25));",
          "346: }",
          "",
          "[Removed Lines]",
          "343:   return !!(*vcpu_cpsr(vcpu) & COMPAT_PSR_E_BIT);",
          "",
          "[Added Lines]",
          "343:   return !!(*vcpu_cpsr(vcpu) & PSR_AA32_E_BIT);",
          "",
          "---------------"
        ],
        "arch/arm64/kvm/guest.c||arch/arm64/kvm/guest.c": [
          "File: arch/arm64/kvm/guest.c -> arch/arm64/kvm/guest.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "107:  }",
          "109:  if (off == KVM_REG_ARM_CORE_REG(regs.pstate)) {",
          "111:   switch (mode) {",
          "118:   case PSR_MODE_EL0t:",
          "119:   case PSR_MODE_EL1t:",
          "120:   case PSR_MODE_EL1h:",
          "",
          "[Removed Lines]",
          "110:   u32 mode = (*(u32 *)valp) & COMPAT_PSR_MODE_MASK;",
          "112:   case COMPAT_PSR_MODE_USR:",
          "113:   case COMPAT_PSR_MODE_FIQ:",
          "114:   case COMPAT_PSR_MODE_IRQ:",
          "115:   case COMPAT_PSR_MODE_SVC:",
          "116:   case COMPAT_PSR_MODE_ABT:",
          "117:   case COMPAT_PSR_MODE_UND:",
          "",
          "[Added Lines]",
          "110:   u32 mode = (*(u32 *)valp) & PSR_AA32_MODE_MASK;",
          "112:   case PSR_AA32_MODE_USR:",
          "113:   case PSR_AA32_MODE_FIQ:",
          "114:   case PSR_AA32_MODE_IRQ:",
          "115:   case PSR_AA32_MODE_SVC:",
          "116:   case PSR_AA32_MODE_ABT:",
          "117:   case PSR_AA32_MODE_UND:",
          "",
          "---------------"
        ],
        "arch/arm64/kvm/hyp/vgic-v2-cpuif-proxy.c||arch/arm64/kvm/hyp/vgic-v2-cpuif-proxy.c": [
          "File: arch/arm64/kvm/hyp/vgic-v2-cpuif-proxy.c -> arch/arm64/kvm/hyp/vgic-v2-cpuif-proxy.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "27: static bool __hyp_text __is_be(struct kvm_vcpu *vcpu)",
          "28: {",
          "29:  if (vcpu_mode_is_32bit(vcpu))",
          "32:  return !!(read_sysreg(SCTLR_EL1) & SCTLR_ELx_EE);",
          "33: }",
          "",
          "[Removed Lines]",
          "30:   return !!(read_sysreg_el2(spsr) & COMPAT_PSR_E_BIT);",
          "",
          "[Added Lines]",
          "30:   return !!(read_sysreg_el2(spsr) & PSR_AA32_E_BIT);",
          "",
          "---------------"
        ],
        "arch/arm64/kvm/regmap.c||arch/arm64/kvm/regmap.c": [
          "File: arch/arm64/kvm/regmap.c -> arch/arm64/kvm/regmap.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "112: unsigned long *vcpu_reg32(const struct kvm_vcpu *vcpu, u8 reg_num)",
          "113: {",
          "114:  unsigned long *reg_array = (unsigned long *)&vcpu->arch.ctxt.gp_regs.regs;",
          "117:  switch (mode) {",
          "120:   break;",
          "123:   mode = 4;",
          "124:   break;",
          "127:   mode = 5;",
          "128:   break;",
          "132:   break;",
          "",
          "[Removed Lines]",
          "115:  unsigned long mode = *vcpu_cpsr(vcpu) & COMPAT_PSR_MODE_MASK;",
          "118:  case COMPAT_PSR_MODE_USR ... COMPAT_PSR_MODE_SVC:",
          "122:  case COMPAT_PSR_MODE_ABT:",
          "126:  case COMPAT_PSR_MODE_UND:",
          "130:  case COMPAT_PSR_MODE_SYS:",
          "",
          "[Added Lines]",
          "115:  unsigned long mode = *vcpu_cpsr(vcpu) & PSR_AA32_MODE_MASK;",
          "118:  case PSR_AA32_MODE_USR ... PSR_AA32_MODE_SVC:",
          "122:  case PSR_AA32_MODE_ABT:",
          "126:  case PSR_AA32_MODE_UND:",
          "130:  case PSR_AA32_MODE_SYS:",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "144: static int vcpu_spsr32_mode(const struct kvm_vcpu *vcpu)",
          "145: {",
          "147:  switch (mode) {",
          "153:  default: BUG();",
          "154:  }",
          "155: }",
          "",
          "[Removed Lines]",
          "146:  unsigned long mode = *vcpu_cpsr(vcpu) & COMPAT_PSR_MODE_MASK;",
          "148:  case COMPAT_PSR_MODE_SVC: return KVM_SPSR_SVC;",
          "149:  case COMPAT_PSR_MODE_ABT: return KVM_SPSR_ABT;",
          "150:  case COMPAT_PSR_MODE_UND: return KVM_SPSR_UND;",
          "151:  case COMPAT_PSR_MODE_IRQ: return KVM_SPSR_IRQ;",
          "152:  case COMPAT_PSR_MODE_FIQ: return KVM_SPSR_FIQ;",
          "",
          "[Added Lines]",
          "146:  unsigned long mode = *vcpu_cpsr(vcpu) & PSR_AA32_MODE_MASK;",
          "148:  case PSR_AA32_MODE_SVC: return KVM_SPSR_SVC;",
          "149:  case PSR_AA32_MODE_ABT: return KVM_SPSR_ABT;",
          "150:  case PSR_AA32_MODE_UND: return KVM_SPSR_UND;",
          "151:  case PSR_AA32_MODE_IRQ: return KVM_SPSR_IRQ;",
          "152:  case PSR_AA32_MODE_FIQ: return KVM_SPSR_FIQ;",
          "",
          "---------------"
        ],
        "arch/arm64/kvm/reset.c||arch/arm64/kvm/reset.c": [
          "File: arch/arm64/kvm/reset.c -> arch/arm64/kvm/reset.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "42: };",
          "44: static const struct kvm_regs default_regs_reset32 = {",
          "47: };",
          "49: static bool cpu_has_32bit_el1(void)",
          "",
          "[Removed Lines]",
          "45:  .regs.pstate = (COMPAT_PSR_MODE_SVC | COMPAT_PSR_A_BIT |",
          "46:    COMPAT_PSR_I_BIT | COMPAT_PSR_F_BIT),",
          "",
          "[Added Lines]",
          "45:  .regs.pstate = (PSR_AA32_MODE_SVC | PSR_AA32_A_BIT |",
          "46:    PSR_AA32_I_BIT | PSR_AA32_F_BIT),",
          "",
          "---------------"
        ],
        "virt/kvm/arm/aarch32.c||virt/kvm/arm/aarch32.c": [
          "File: virt/kvm/arm/aarch32.c -> virt/kvm/arm/aarch32.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "108: {",
          "109:  unsigned long itbits, cond;",
          "110:  unsigned long cpsr = *vcpu_cpsr(vcpu);",
          "114:   return;",
          "116:  cond = (cpsr & 0xe000) >> 13;",
          "",
          "[Removed Lines]",
          "111:  bool is_arm = !(cpsr & COMPAT_PSR_T_BIT);",
          "113:  if (is_arm || !(cpsr & COMPAT_PSR_IT_MASK))",
          "",
          "[Added Lines]",
          "111:  bool is_arm = !(cpsr & PSR_AA32_T_BIT);",
          "113:  if (is_arm || !(cpsr & PSR_AA32_IT_MASK))",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "123:  else",
          "124:   itbits = (itbits << 1) & 0x1f;",
          "127:  cpsr |= cond << 13;",
          "128:  cpsr |= (itbits & 0x1c) << (10 - 2);",
          "129:  cpsr |= (itbits & 0x3) << 25;",
          "",
          "[Removed Lines]",
          "126:  cpsr &= ~COMPAT_PSR_IT_MASK;",
          "",
          "[Added Lines]",
          "126:  cpsr &= ~PSR_AA32_IT_MASK;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "138: {",
          "139:  bool is_thumb;",
          "142:  if (is_thumb && !is_wide_instr)",
          "144:  else",
          "",
          "[Removed Lines]",
          "141:  is_thumb = !!(*vcpu_cpsr(vcpu) & COMPAT_PSR_T_BIT);",
          "",
          "[Added Lines]",
          "141:  is_thumb = !!(*vcpu_cpsr(vcpu) & PSR_AA32_T_BIT);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "164: {",
          "165:  unsigned long cpsr;",
          "166:  unsigned long new_spsr_value = *vcpu_cpsr(vcpu);",
          "168:  u32 return_offset = return_offsets[vect_offset >> 2][is_thumb];",
          "169:  u32 sctlr = vcpu_cp15(vcpu, c1_SCTLR);",
          "173:  if (sctlr & (1 << 30))",
          "175:  if (sctlr & (1 << 25))",
          "",
          "[Removed Lines]",
          "167:  bool is_thumb = (new_spsr_value & COMPAT_PSR_T_BIT);",
          "171:  cpsr = mode | COMPAT_PSR_I_BIT;",
          "174:   cpsr |= COMPAT_PSR_T_BIT;",
          "176:   cpsr |= COMPAT_PSR_E_BIT;",
          "",
          "[Added Lines]",
          "167:  bool is_thumb = (new_spsr_value & PSR_AA32_T_BIT);",
          "171:  cpsr = mode | PSR_AA32_I_BIT;",
          "174:   cpsr |= PSR_AA32_T_BIT;",
          "176:   cpsr |= PSR_AA32_E_BIT;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "193: void kvm_inject_undef32(struct kvm_vcpu *vcpu)",
          "194: {",
          "196: }",
          "",
          "[Removed Lines]",
          "195:  prepare_fault32(vcpu, COMPAT_PSR_MODE_UND, 4);",
          "",
          "[Added Lines]",
          "195:  prepare_fault32(vcpu, PSR_AA32_MODE_UND, 4);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "216:   fsr = &vcpu_cp15(vcpu, c5_DFSR);",
          "217:  }",
          "",
          "[Removed Lines]",
          "219:  prepare_fault32(vcpu, COMPAT_PSR_MODE_ABT | COMPAT_PSR_A_BIT, vect_offset);",
          "",
          "[Added Lines]",
          "219:  prepare_fault32(vcpu, PSR_AA32_MODE_ABT | PSR_AA32_A_BIT, vect_offset);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
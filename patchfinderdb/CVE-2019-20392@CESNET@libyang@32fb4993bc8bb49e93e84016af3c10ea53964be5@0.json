{
  "cve_id": "CVE-2019-20392",
  "cve_desc": "An invalid memory access flaw is present in libyang before v1.0-r1 in the function resolve_feature_value() when an if-feature statement is used inside a list key node, and the feature used is not defined. Applications that use libyang to parse untrusted input yang files may crash.",
  "repo": "CESNET/libyang",
  "patch_hash": "32fb4993bc8bb49e93e84016af3c10ea53964be5",
  "patch_info": {
    "commit_hash": "32fb4993bc8bb49e93e84016af3c10ea53964be5",
    "repo": "CESNET/libyang",
    "commit_url": "https://github.com/CESNET/libyang/commit/32fb4993bc8bb49e93e84016af3c10ea53964be5",
    "files": [
      "src/resolve.c",
      "src/tree_data.c",
      "src/tree_internal.h",
      "src/tree_schema.c"
    ],
    "message": "schema tree BUGFIX do not check features while still resolving schema\n\nFixes #723",
    "before_after_code_files": [
      "src/resolve.c||src/resolve.c",
      "src/tree_data.c||src/tree_data.c",
      "src/tree_internal.h||src/tree_internal.h",
      "src/tree_schema.c||src/tree_schema.c"
    ]
  },
  "patch_diff": {
    "src/resolve.c||src/resolve.c": [
      "File: src/resolve.c -> src/resolve.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "3941:         } else {",
      "3942:             trg_mod = lys_node_module(parent);",
      "3943:         }",
      "3945:         if (rc) {",
      "3946:             LOGVAL(ctx, LYE_NORESOLV, LY_VLOG_LYS, parent, \"leafref predicate\", path-parsed);",
      "3947:             return 0;",
      "",
      "[Removed Lines]",
      "3944:         rc = lys_getnext_data(trg_mod, context_node, source, sour_len, LYS_LEAF | LYS_LEAFLIST, &src_node);",
      "",
      "[Added Lines]",
      "3944:         rc = lys_getnext_data(trg_mod, context_node, source, sour_len, LYS_LEAF | LYS_LEAFLIST, LYS_GETNEXT_NOSTATECHECK,",
      "3945:                               &src_node);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "3984:             } else {",
      "3985:                 trg_mod = lys_node_module(parent);",
      "3986:             }",
      "3988:             if (rc) {",
      "3989:                 LOGVAL(ctx, LYE_NORESOLV, LY_VLOG_LYS, parent, \"leafref predicate\", path_key_expr);",
      "3990:                 return 0;",
      "",
      "[Removed Lines]",
      "3987:             rc = lys_getnext_data(trg_mod, dst_node, dest, dest_len, LYS_CONTAINER | LYS_LIST | LYS_LEAF, &dst_node);",
      "",
      "[Added Lines]",
      "3988:             rc = lys_getnext_data(trg_mod, dst_node, dest, dest_len, LYS_CONTAINER | LYS_LIST | LYS_LEAF,",
      "3989:                                   LYS_GETNEXT_NOSTATECHECK, &dst_node);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "6065:         }",
      "6067:         rc = lys_getnext_data(lys_node_module((struct lys_node *)list), (struct lys_node *)list, keys_str, len, LYS_LEAF,",
      "6069:         if (rc) {",
      "6070:             LOGVAL(ctx, LYE_INRESOLV, LY_VLOG_LYS, list, \"list key\", keys_str);",
      "6071:             return EXIT_FAILURE;",
      "",
      "[Removed Lines]",
      "6068:                               (const struct lys_node **)&list->keys[i]);",
      "",
      "[Added Lines]",
      "6070:                               LYS_GETNEXT_NOSTATECHECK, (const struct lys_node **)&list->keys[i]);",
      "",
      "---------------"
    ],
    "src/tree_data.c||src/tree_data.c": [
      "File: src/tree_data.c -> src/tree_data.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1172:     }",
      "1174:     if (lys_getnext_data(module, lys_parent(siblings), name, strlen(name), LYS_CONTAINER | LYS_LIST | LYS_NOTIF",
      "1176:         LOGERR(siblings->module->ctx, LY_EINVAL, \"Failed to find \\\"%s\\\" as a sibling to \\\"%s:%s\\\".\",",
      "1177:                name, lys_node_module(siblings)->name, siblings->name);",
      "1178:         return NULL;",
      "",
      "[Removed Lines]",
      "1175:                          | LYS_RPC | LYS_ACTION, &snode) || !snode) {",
      "",
      "[Added Lines]",
      "1175:                          | LYS_RPC | LYS_ACTION, 0, &snode) || !snode) {",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1265:         return NULL;",
      "1266:     }",
      "1269:         LOGERR(siblings->module->ctx, LY_EINVAL, \"Failed to find \\\"%s\\\" as a sibling to \\\"%s:%s\\\".\",",
      "1270:                name, lys_node_module(siblings)->name, siblings->name);",
      "1271:         return NULL;",
      "",
      "[Removed Lines]",
      "1268:     if (lys_getnext_data(module, lys_parent(siblings), name, strlen(name), LYS_LEAFLIST | LYS_LEAF, &snode) || !snode) {",
      "",
      "[Added Lines]",
      "1268:     if (lys_getnext_data(module, lys_parent(siblings), name, strlen(name), LYS_LEAFLIST | LYS_LEAF, 0, &snode) || !snode) {",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1513:         return NULL;",
      "1514:     }",
      "1517:         LOGERR(siblings->module->ctx, LY_EINVAL, \"Failed to find \\\"%s\\\" as a sibling to \\\"%s:%s\\\".\",",
      "1518:                name, lys_node_module(siblings)->name, siblings->name);",
      "1519:         return NULL;",
      "",
      "[Removed Lines]",
      "1516:     if (lys_getnext_data(module, lys_parent(siblings), name, strlen(name), LYS_ANYDATA, &snode) || !snode) {",
      "",
      "[Added Lines]",
      "1516:     if (lys_getnext_data(module, lys_parent(siblings), name, strlen(name), LYS_ANYDATA, 0, &snode) || !snode) {",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "1538:         return NULL;",
      "1539:     }",
      "1542:         LOGERR(module->ctx, LY_EINVAL, \"Failed to find \\\"%s\\\" as a container child of \\\"%s:%s\\\".\",",
      "1543:                name, module->name, schema->name);",
      "1544:         return NULL;",
      "",
      "[Removed Lines]",
      "1541:     if (lys_getnext_data(module, schema, name, strlen(name), LYS_CONTAINER, &snode) || !snode) {",
      "",
      "[Added Lines]",
      "1541:     if (lys_getnext_data(module, schema, name, strlen(name), LYS_CONTAINER, 0, &snode) || !snode) {",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "1564:     }",
      "1566:     if (lys_getnext_data(module, lys_parent(siblings), name, strlen(name), LYS_CONTAINER | LYS_LIST | LYS_NOTIF",
      "1568:         LOGERR(siblings->module->ctx, LY_EINVAL, \"Failed to find \\\"%s\\\" as a sibling to \\\"%s:%s\\\".\",",
      "1569:                name, lys_node_module(siblings)->name, siblings->name);",
      "1570:         return NULL;",
      "",
      "[Removed Lines]",
      "1567:                          | LYS_RPC | LYS_ACTION, &snode) || !snode) {",
      "",
      "[Added Lines]",
      "1567:                          | LYS_RPC | LYS_ACTION, 0, &snode) || !snode) {",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "1589:         return NULL;",
      "1590:     }",
      "1593:         LOGERR(siblings->module->ctx, LY_EINVAL, \"Failed to find \\\"%s\\\" as a sibling to \\\"%s:%s\\\".\",",
      "1594:                name, lys_node_module(siblings)->name, siblings->name);",
      "1595:         return NULL;",
      "",
      "[Removed Lines]",
      "1592:     if (lys_getnext_data(module, lys_parent(siblings), name, strlen(name), LYS_LEAFLIST | LYS_LEAF, &snode) || !snode) {",
      "",
      "[Added Lines]",
      "1592:     if (lys_getnext_data(module, lys_parent(siblings), name, strlen(name), LYS_LEAFLIST | LYS_LEAF, 0, &snode) || !snode) {",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "1615:         return NULL;",
      "1616:     }",
      "1619:         LOGERR(siblings->module->ctx, LY_EINVAL, \"Failed to find \\\"%s\\\" as a sibling to \\\"%s:%s\\\".\",",
      "1620:                name, lys_node_module(siblings)->name, siblings->name);",
      "1621:         return NULL;",
      "",
      "[Removed Lines]",
      "1618:     if (lys_getnext_data(module, lys_parent(siblings), name, strlen(name), LYS_ANYDATA, &snode) || !snode) {",
      "",
      "[Added Lines]",
      "1618:     if (lys_getnext_data(module, lys_parent(siblings), name, strlen(name), LYS_ANYDATA, 0, &snode) || !snode) {",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "5609:                 }",
      "5611:                 lys_getnext_data(trg_mod, parent->schema, elem->schema->name, strlen(elem->schema->name),",
      "5613:             } else {",
      "5615:                 schema = lyd_get_schema_inctx(elem, ctx);",
      "",
      "[Removed Lines]",
      "5612:                                  elem->schema->nodetype, (const struct lys_node **)&schema);",
      "",
      "[Added Lines]",
      "5612:                                  elem->schema->nodetype, 0, (const struct lys_node **)&schema);",
      "",
      "---------------"
    ],
    "src/tree_internal.h||src/tree_internal.h": [
      "File: src/tree_internal.h -> src/tree_internal.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "492: int lys_getnext_data(const struct lys_module *mod, const struct lys_node *parent, const char *name, int nam_len,",
      "495: int lyd_get_unique_default(const char* unique_expr, struct lyd_node *list, const char **dflt);",
      "",
      "[Removed Lines]",
      "493:                      LYS_NODE type, const struct lys_node **ret);",
      "",
      "[Added Lines]",
      "494:                      LYS_NODE type, int getnext_opts, const struct lys_node **ret);",
      "",
      "---------------"
    ],
    "src/tree_schema.c||src/tree_schema.c": [
      "File: src/tree_schema.c -> src/tree_schema.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "214: int",
      "215: lys_getnext_data(const struct lys_module *mod, const struct lys_node *parent, const char *name, int nam_len,",
      "217: {",
      "218:     const struct lys_node *node;",
      "",
      "[Removed Lines]",
      "216:                  LYS_NODE type, const struct lys_node **ret)",
      "",
      "[Added Lines]",
      "216:                  LYS_NODE type, int getnext_opts, const struct lys_node **ret)",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "228:     node = NULL;",
      "230:         if (!type || (node->nodetype & type)) {",
      "232:             if (lys_node_module(node) != lys_main_module(mod)) {",
      "",
      "[Removed Lines]",
      "229:     while ((node = lys_getnext(node, parent, mod, 0))) {",
      "",
      "[Added Lines]",
      "229:     while ((node = lys_getnext(node, parent, mod, getnext_opts))) {",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "ba8fd2bc54f2db7de4c190df9a43ac44e17b0910",
      "candidate_info": {
        "commit_hash": "ba8fd2bc54f2db7de4c190df9a43ac44e17b0910",
        "repo": "CESNET/libyang",
        "commit_url": "https://github.com/CESNET/libyang/commit/ba8fd2bc54f2db7de4c190df9a43ac44e17b0910",
        "files": [
          "src/resolve.c"
        ],
        "message": "resolve BUGFIX leafref predicate nodes from augments\n\nFixes #765",
        "before_after_code_files": [
          "src/resolve.c||src/resolve.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/resolve.c||src/resolve.c"
          ],
          "candidate": [
            "src/resolve.c||src/resolve.c"
          ]
        }
      },
      "candidate_diff": {
        "src/resolve.c||src/resolve.c": [
          "File: src/resolve.c -> src/resolve.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3955: static int",
          "3957: {",
          "3958:     const struct lys_module *trg_mod;",
          "3960:     const char *path_key_expr, *source, *sour_pref, *dest, *dest_pref;",
          "3961:     int pke_len, sour_len, sour_pref_len, dest_len, dest_pref_len, pke_parsed, parsed = 0;",
          "3962:     int has_predicate, dest_parent_times, i, rc;",
          "",
          "[Removed Lines]",
          "3956: resolve_schema_leafref_predicate(const char *path, const struct lys_node *context_node, struct lys_node *parent)",
          "3959:     const struct lys_node *src_node, *dst_node;",
          "",
          "[Added Lines]",
          "3956: resolve_schema_leafref_predicate(const char *path, const struct lys_node *context_node, struct lys_node *parent,",
          "3957:                                  struct ly_set *node_set)",
          "3960:     const struct lys_node *src_node, *dst_node, *tmp_parent;",
          "3961:     struct lys_node_augment *last_aug;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3965:     do {",
          "3966:         if ((i = parse_path_predicate(path, &sour_pref, &sour_pref_len, &source, &sour_len, &path_key_expr,",
          "3967:                                       &pke_len, &has_predicate)) < 1) {",
          "3970:         }",
          "3971:         parsed += i;",
          "3972:         path += i;",
          "",
          "[Removed Lines]",
          "3968:             LOGVAL(ctx, LYE_INCHAR, LY_VLOG_LYS, parent, path[-i], path-i);",
          "3969:             return -parsed+i;",
          "",
          "[Added Lines]",
          "3970:             LOGVAL(ctx, LYE_INCHAR, LY_VLOG_LYS, parent, path[-i], path - i);",
          "3971:             return -parsed + i;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "4016:                  dst_node = lys_parent(dst_node));",
          "4017:         }",
          "4018:         while (1) {",
          "4019:             if (dest_pref) {",
          "4020:                 trg_mod = lyp_get_module(lys_node_module(parent), NULL, 0, dest_pref, dest_pref_len, 0);",
          "4021:             } else {",
          "4022:                 trg_mod = lys_node_module(parent);",
          "4023:             }",
          "4025:                                   LYS_GETNEXT_NOSTATECHECK, &dst_node);",
          "4026:             if (rc) {",
          "4027:                 LOGVAL(ctx, LYE_NORESOLV, LY_VLOG_LYS, parent, \"leafref predicate\", path_key_expr);",
          "4028:                 return 0;",
          "4029:             }",
          "",
          "[Removed Lines]",
          "4024:             rc = lys_getnext_data(trg_mod, dst_node, dest, dest_len, LYS_CONTAINER | LYS_LIST | LYS_LEAF,",
          "",
          "[Added Lines]",
          "4021:             last_aug = NULL;",
          "4029:             if (!trg_mod->implemented && dst_node) {",
          "4030:     get_next_augment:",
          "4031:                 last_aug = lys_getnext_target_aug(last_aug, trg_mod, dst_node);",
          "4032:             }",
          "4034:             tmp_parent = (last_aug ? (struct lys_node *)last_aug : dst_node);",
          "4035:             rc = lys_getnext_data(trg_mod, tmp_parent, dest, dest_len, LYS_CONTAINER | LYS_LIST | LYS_LEAF,",
          "4038:                 if (last_aug) {",
          "4040:                     dst_node = last_aug->target;",
          "4041:                     goto get_next_augment;",
          "4042:                 }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "4035:             if ((i = parse_path_key_expr(path_key_expr + pke_parsed, &dest_pref, &dest_pref_len, &dest, &dest_len,",
          "4036:                                          &dest_parent_times)) < 1) {",
          "4037:                 LOGVAL(ctx, LYE_INCHAR, LY_VLOG_LYS, parent,",
          "4039:                 return -parsed;",
          "4040:             }",
          "4041:             pke_parsed += i;",
          "",
          "[Removed Lines]",
          "4038:                        (path_key_expr + pke_parsed)[-i], (path_key_expr + pke_parsed)-i);",
          "",
          "[Added Lines]",
          "4054:                        (path_key_expr + pke_parsed)[-i], (path_key_expr + pke_parsed) - i);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "4048:                    strnodetype(src_node->nodetype), strnodetype(dst_node->nodetype));",
          "4049:             return -parsed;",
          "4050:         }",
          "4051:     } while (has_predicate);",
          "4053:     return parsed;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4069:         ly_set_add(node_set, (void *)dst_node, 0);",
          "4070:         ly_set_add(node_set, (void *)src_node, 0);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "4175: resolve_schema_leafref(struct lys_type *type, struct lys_node *parent, struct unres_schema *unres)",
          "4176: {",
          "4177:     const struct lys_node *node, *op_node = NULL, *tmp_parent;",
          "4178:     struct lys_node_augment *last_aug;",
          "4179:     const struct lys_module *tmp_mod, *cur_module;",
          "4180:     const char *id, *prefix, *name;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4198:     struct ly_set *node_set;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "4182:     int i, first_iter;",
          "4183:     struct ly_ctx *ctx = parent->module->ctx;",
          "4242:                         }",
          "4243:                     }",
          "4247:                 }",
          "4248:             }",
          "4253:     get_next_augment:",
          "4268:             }",
          "4277:             }",
          "4285:             }",
          "4302:             }",
          "4310:         }",
          "4320:     }",
          "4323:     if (lys_node_module(parent)->implemented) {",
          "4330:                 }",
          "4331:             }",
          "4332:         }",
          "4335:         if (lys_leaf_add_leafref_target(type->info.lref.target, (struct lys_node *)type->parent)) {",
          "4336:             return -1;",
          "4337:         }",
          "4338:     }",
          "4341:     return check_leafref_features(type);",
          "",
          "[Removed Lines]",
          "4185:     if (!type->info.lref.target) {",
          "4186:         first_iter = 1;",
          "4187:         parent_times = 0;",
          "4188:         id = type->info.lref.path;",
          "4191:         for (op_node = lys_parent(parent);",
          "4192:             op_node && !(op_node->nodetype & (LYS_ACTION | LYS_NOTIF | LYS_RPC));",
          "4193:             op_node = lys_parent(op_node));",
          "4195:         cur_module = lys_node_module(parent);",
          "4196:         do {",
          "4197:             if ((i = parse_path_arg(cur_module, id, &prefix, &pref_len, &name, &nam_len, &parent_times, &has_predicate)) < 1) {",
          "4198:                 LOGVAL(ctx, LYE_INCHAR, LY_VLOG_LYS, parent, id[-i], &id[-i]);",
          "4199:                 return -1;",
          "4200:             }",
          "4201:             id += i;",
          "4204:             tmp_mod = prefix ? lyp_get_module(cur_module, NULL, 0, prefix, pref_len, 0) : cur_module;",
          "4205:             if (!tmp_mod) {",
          "4206:                 LOGVAL(ctx, LYE_NORESOLV, LY_VLOG_LYS, parent, \"leafref\", type->info.lref.path);",
          "4207:                 return EXIT_FAILURE;",
          "4208:             }",
          "4209:             last_aug = NULL;",
          "4211:             if (first_iter) {",
          "4212:                 if (parent_times == -1) {",
          "4214:                     node = NULL;",
          "4216:                 } else if (parent_times > 0) {",
          "4218:                     for (i = 0, node = parent; i < parent_times; i++) {",
          "4219:                         if (node->parent && (node->parent->nodetype == LYS_AUGMENT)",
          "4220:                                 && !((struct lys_node_augment *)node->parent)->target) {",
          "4222:                             LOGVAL(ctx, LYE_SPEC, LY_VLOG_LYS, node->parent,",
          "4223:                                 \"Cannot resolve leafref \\\"%s\\\" because it is in an unresolved augment.\", type->info.lref.path);",
          "4224:                             return EXIT_FAILURE;",
          "4225:                         }",
          "4229:                         for (node = lys_parent(node);",
          "4230:                             node && !(node->nodetype & (LYS_CONTAINER | LYS_LIST | LYS_ACTION | LYS_NOTIF | LYS_RPC));",
          "4231:                             node = lys_parent(node));",
          "4233:                         if (!node) {",
          "4234:                             if (i == parent_times - 1) {",
          "4236:                                 break;",
          "4237:                             }",
          "4240:                             LOGVAL(ctx, LYE_NORESOLV, LY_VLOG_LYS, parent, \"leafref\", type->info.lref.path);",
          "4241:                             return EXIT_FAILURE;",
          "4244:                 } else {",
          "4245:                     LOGINT(ctx);",
          "4246:                     return -1;",
          "4252:             if (!tmp_mod->implemented && node) {",
          "4254:                 last_aug = lys_getnext_target_aug(last_aug, tmp_mod, node);",
          "4255:             }",
          "4257:             tmp_parent = (last_aug ? (struct lys_node *)last_aug : node);",
          "4258:             node = NULL;",
          "4259:             while ((node = lys_getnext(node, tmp_parent, tmp_mod, LYS_GETNEXT_NOSTATECHECK))) {",
          "4260:                 if (lys_node_module(node) != lys_main_module(tmp_mod)) {",
          "4261:                     continue;",
          "4262:                 }",
          "4263:                 if (strncmp(node->name, name, nam_len) || node->name[nam_len]) {",
          "4264:                     continue;",
          "4265:                 }",
          "4267:                 break;",
          "4269:             if (!node) {",
          "4270:                 if (last_aug) {",
          "4272:                     node = last_aug->target;",
          "4273:                     goto get_next_augment;",
          "4274:                 }",
          "4275:                 LOGVAL(ctx, LYE_NORESOLV, LY_VLOG_LYS, parent, \"leafref\", type->info.lref.path);",
          "4276:                 return EXIT_FAILURE;",
          "4279:             if (first_iter) {",
          "4281:                 if (resolve_schema_leafref_valid_dep_flag(op_node, cur_module, node, (parent_times == -1 ? 1 : 0))) {",
          "4282:                     parent->flags |= LYS_LEAFREF_DEP;",
          "4283:                 }",
          "4284:                 first_iter = 0;",
          "4287:             if (has_predicate) {",
          "4289:                 if (node->nodetype != LYS_LIST) {",
          "4290:                     LOGVAL(ctx, LYE_NORESOLV, LY_VLOG_LYS, parent, \"leafref\", type->info.lref.path);",
          "4291:                     return -1;",
          "4292:                 }",
          "4294:                 i = resolve_schema_leafref_predicate(id, node, parent);",
          "4295:                 if (!i) {",
          "4296:                     return EXIT_FAILURE;",
          "4297:                 } else if (i < 0) {",
          "4298:                     return -1;",
          "4299:                 }",
          "4300:                 id += i;",
          "4301:                 has_predicate = 0;",
          "4303:         } while (id[0]);",
          "4306:         if ((node->nodetype != LYS_LEAF) && (node->nodetype != LYS_LEAFLIST)) {",
          "4307:             LOGVAL(ctx, LYE_NORESOLV, LY_VLOG_LYS, parent, \"leafref\", type->info.lref.path);",
          "4308:             LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"Leafref target \\\"%s\\\" is not a leaf nor a leaf-list.\", type->info.lref.path);",
          "4309:             return -1;",
          "4313:         if (lyp_check_status(parent->flags, parent->module, parent->name,",
          "4314:                         node->flags, node->module, node->name, node)) {",
          "4315:             return -1;",
          "4316:         }",
          "4319:         type->info.lref.target = (struct lys_node_leaf *)node;",
          "4325:         for (node = (struct lys_node *)type->info.lref.target; node; node = lys_parent(node)) {",
          "4326:             if (!lys_node_module(node)->implemented) {",
          "4327:                 lys_node_module(node)->implemented = 1;",
          "4328:                 if (unres_schema_add_node(lys_node_module(node), unres, NULL, UNRES_MOD_IMPLEMENT, NULL) == -1) {",
          "4329:                     return -1;",
          "",
          "[Added Lines]",
          "4206:     first_iter = 1;",
          "4207:     parent_times = 0;",
          "4208:     id = type->info.lref.path;",
          "4209:     node_set = ly_set_new();",
          "4210:     if (!node_set) {",
          "4211:         LOGMEM(ctx);",
          "4212:         return -1;",
          "4213:     }",
          "4216:     for (op_node = lys_parent(parent);",
          "4217:         op_node && !(op_node->nodetype & (LYS_ACTION | LYS_NOTIF | LYS_RPC));",
          "4218:         op_node = lys_parent(op_node));",
          "4220:     cur_module = lys_node_module(parent);",
          "4221:     do {",
          "4222:         if ((i = parse_path_arg(cur_module, id, &prefix, &pref_len, &name, &nam_len, &parent_times, &has_predicate)) < 1) {",
          "4223:             LOGVAL(ctx, LYE_INCHAR, LY_VLOG_LYS, parent, id[-i], &id[-i]);",
          "4224:             ly_set_free(node_set);",
          "4225:             return -1;",
          "4226:         }",
          "4227:         id += i;",
          "4230:         tmp_mod = prefix ? lyp_get_module(cur_module, NULL, 0, prefix, pref_len, 0) : cur_module;",
          "4231:         if (!tmp_mod) {",
          "4232:             LOGVAL(ctx, LYE_NORESOLV, LY_VLOG_LYS, parent, \"leafref\", type->info.lref.path);",
          "4233:             ly_set_free(node_set);",
          "4234:             return EXIT_FAILURE;",
          "4235:         }",
          "4236:         last_aug = NULL;",
          "4238:         if (first_iter) {",
          "4239:             if (parent_times == -1) {",
          "4241:                 node = NULL;",
          "4243:             } else if (parent_times > 0) {",
          "4245:                 for (i = 0, node = parent; i < parent_times; i++) {",
          "4246:                     if (node->parent && (node->parent->nodetype == LYS_AUGMENT)",
          "4247:                             && !((struct lys_node_augment *)node->parent)->target) {",
          "4249:                         LOGVAL(ctx, LYE_SPEC, LY_VLOG_LYS, node->parent,",
          "4250:                             \"Cannot resolve leafref \\\"%s\\\" because it is in an unresolved augment.\", type->info.lref.path);",
          "4251:                         ly_set_free(node_set);",
          "4252:                         return EXIT_FAILURE;",
          "4253:                     }",
          "4257:                     for (node = lys_parent(node);",
          "4258:                         node && !(node->nodetype & (LYS_CONTAINER | LYS_LIST | LYS_ACTION | LYS_NOTIF | LYS_RPC));",
          "4259:                         node = lys_parent(node));",
          "4261:                     if (!node) {",
          "4262:                         if (i == parent_times - 1) {",
          "4264:                             break;",
          "4268:                         LOGVAL(ctx, LYE_NORESOLV, LY_VLOG_LYS, parent, \"leafref\", type->info.lref.path);",
          "4269:                         ly_set_free(node_set);",
          "4270:                         return EXIT_FAILURE;",
          "4273:             } else {",
          "4274:                 LOGINT(ctx);",
          "4275:                 ly_set_free(node_set);",
          "4276:                 return -1;",
          "4278:         }",
          "4282:         if (!tmp_mod->implemented && node) {",
          "4284:             last_aug = lys_getnext_target_aug(last_aug, tmp_mod, node);",
          "4285:         }",
          "4287:         tmp_parent = (last_aug ? (struct lys_node *)last_aug : node);",
          "4288:         node = NULL;",
          "4289:         while ((node = lys_getnext(node, tmp_parent, tmp_mod, LYS_GETNEXT_NOSTATECHECK))) {",
          "4290:             if (lys_node_module(node) != lys_main_module(tmp_mod)) {",
          "4291:                 continue;",
          "4293:             if (strncmp(node->name, name, nam_len) || node->name[nam_len]) {",
          "4294:                 continue;",
          "4297:             break;",
          "4298:         }",
          "4299:         if (!node) {",
          "4300:             if (last_aug) {",
          "4302:                 node = last_aug->target;",
          "4303:                 goto get_next_augment;",
          "4305:             LOGVAL(ctx, LYE_NORESOLV, LY_VLOG_LYS, parent, \"leafref\", type->info.lref.path);",
          "4306:             ly_set_free(node_set);",
          "4307:             return EXIT_FAILURE;",
          "4308:         }",
          "4310:         if (first_iter) {",
          "4312:             if (resolve_schema_leafref_valid_dep_flag(op_node, cur_module, node, (parent_times == -1 ? 1 : 0))) {",
          "4313:                 parent->flags |= LYS_LEAFREF_DEP;",
          "4314:             }",
          "4315:             first_iter = 0;",
          "4316:         }",
          "4318:         if (has_predicate) {",
          "4320:             if (node->nodetype != LYS_LIST) {",
          "4321:                 LOGVAL(ctx, LYE_NORESOLV, LY_VLOG_LYS, parent, \"leafref\", type->info.lref.path);",
          "4322:                 ly_set_free(node_set);",
          "4323:                 return -1;",
          "4326:             i = resolve_schema_leafref_predicate(id, node, parent, node_set);",
          "4327:             if (!i) {",
          "4328:                 ly_set_free(node_set);",
          "4329:                 return EXIT_FAILURE;",
          "4330:             } else if (i < 0) {",
          "4331:                 ly_set_free(node_set);",
          "4332:                 return -1;",
          "4333:             }",
          "4334:             id += i;",
          "4335:             has_predicate = 0;",
          "4337:     } while (id[0]);",
          "4340:     if ((node->nodetype != LYS_LEAF) && (node->nodetype != LYS_LEAFLIST)) {",
          "4341:         LOGVAL(ctx, LYE_NORESOLV, LY_VLOG_LYS, parent, \"leafref\", type->info.lref.path);",
          "4342:         LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"Leafref target \\\"%s\\\" is not a leaf nor a leaf-list.\", type->info.lref.path);",
          "4343:         ly_set_free(node_set);",
          "4344:         return -1;",
          "4345:     }",
          "4348:     if (lyp_check_status(parent->flags, parent->module, parent->name,",
          "4349:                     node->flags, node->module, node->name, node)) {",
          "4350:         ly_set_free(node_set);",
          "4351:         return -1;",
          "4355:     type->info.lref.target = (struct lys_node_leaf *)node;",
          "4358:     ly_set_add(node_set, (void *)node, 0);",
          "4363:         for (i = 0; (unsigned)i < node_set->number; ++i) {",
          "4364:             for (node = node_set->set.s[i]; node; node = lys_parent(node)) {",
          "4365:                 if (!lys_node_module(node)->implemented) {",
          "4366:                     lys_node_module(node)->implemented = 1;",
          "4367:                     if (unres_schema_add_node(lys_node_module(node), unres, NULL, UNRES_MOD_IMPLEMENT, NULL) == -1) {",
          "4368:                         ly_set_free(node_set);",
          "4369:                         return -1;",
          "4370:                     }",
          "4377:             ly_set_free(node_set);",
          "4381:     ly_set_free(node_set);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "a091aad42430977028e7ddf219e908a46f231289",
      "candidate_info": {
        "commit_hash": "a091aad42430977028e7ddf219e908a46f231289",
        "repo": "CESNET/libyang",
        "commit_url": "https://github.com/CESNET/libyang/commit/a091aad42430977028e7ddf219e908a46f231289",
        "files": [
          "src/tree_data.c"
        ],
        "message": "data tre OPTIMIZE efficient lyd_dup_withsiblings on top-level\n\nRefs #685",
        "before_after_code_files": [
          "src/tree_data.c||src/tree_data.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/tree_data.c||src/tree_data.c"
          ],
          "candidate": [
            "src/tree_data.c||src/tree_data.c"
          ]
        }
      },
      "candidate_diff": {
        "src/tree_data.c||src/tree_data.c": [
          "File: src/tree_data.c -> src/tree_data.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "5382: static int",
          "5384: {",
          "5385:     struct lyd_attr *attr;",
          "5425:     if (!(options & LYD_DUP_OPT_NO_ATTR)) {",
          "5426:         LY_TREE_FOR(orig->attr, attr) {",
          "5428:         }",
          "5429:     }",
          "5436: #ifdef LY_ENABLED_CACHE",
          "5440:     }",
          "5441: #endif",
          "5443: #ifdef LY_ENABLED_LYD_PRIV",
          "5444:     if (ctx->priv_dup_clb) {",
          "5446:     }",
          "5447: #endif",
          "5451:     }",
          "5454: }",
          "5456: API struct lyd_node *",
          "5457: lyd_dup_to_ctx(const struct lyd_node *node, int options, struct ly_ctx *ctx)",
          "5458: {",
          "5459:     struct ly_ctx *log_ctx;",
          "5461:     struct lys_node_list *slist;",
          "5462:     const struct lyd_node *next, *elem;",
          "5463:     struct lyd_node *ret, *parent, *key, *key_dup, *new_node = NULL;",
          "5466:     uint16_t i;",
          "5469:     if (!node) {",
          "5470:         LOGARG;",
          "",
          "[Removed Lines]",
          "5383: lyd_dup_common(struct lyd_node *parent, struct lyd_node *new, const struct lyd_node *orig, struct ly_ctx *ctx, int options)",
          "5386:     const struct lys_module *trg_mod;",
          "5387:     const char *yang_data_name = NULL;",
          "5390:     if (ctx) {",
          "5392:         if (parent) {",
          "5393:             trg_mod = lyp_get_module(parent->schema->module, NULL, 0, lyd_node_module(orig)->name,",
          "5394:                                      strlen(lyd_node_module(orig)->name), 1);",
          "5395:             if (!trg_mod) {",
          "5396:                 LOGERR(ctx, LY_EINVAL, \"Target context does not contain model for the data node being duplicated (%s).\",",
          "5397:                        lyd_node_module(orig)->name);",
          "5398:                 return EXIT_FAILURE;",
          "5399:             }",
          "5401:             lys_getnext_data(trg_mod, parent->schema, orig->schema->name, strlen(orig->schema->name),",
          "5402:                              orig->schema->nodetype, (const struct lys_node **)&new->schema);",
          "5403:         } else {",
          "5405:             new->schema = lyd_get_schema_inctx(orig, ctx);",
          "5406:         }",
          "5408:         if (!new->schema) {",
          "5409:             yang_data_name = lyp_get_yang_data_template_name(orig);",
          "5410:             if (yang_data_name) {",
          "5411:                 LOGERR(ctx, LY_EINVAL, \"Target context does not contain schema node for the data node being duplicated \"",
          "5412:                                        \"(%s:#%s/%s).\", lyd_node_module(orig)->name, yang_data_name, orig->schema->name);",
          "5413:             } else {",
          "5414:                 LOGERR(ctx, LY_EINVAL, \"Target context does not contain schema node for the data node being duplicated \"",
          "5415:                                        \"(%s:%s).\", lyd_node_module(orig)->name, orig->schema->name);",
          "5416:             }",
          "5417:             return EXIT_FAILURE;",
          "5418:         }",
          "5419:     } else {",
          "5421:         new->schema = orig->schema;",
          "5422:         ctx = orig->schema->module->ctx;",
          "5423:     }",
          "5424:     new->attr = NULL;",
          "5427:             lyd_dup_attr(ctx, new, attr);",
          "5430:     new->next = NULL;",
          "5431:     new->prev = new;",
          "5432:     new->parent = NULL;",
          "5433:     new->validity = ly_new_node_validity(new->schema);",
          "5434:     new->dflt = orig->dflt;",
          "5435:     new->when_status = orig->when_status & LYD_WHEN;",
          "5438:     if ((new->schema->nodetype != LYS_LIST) || lyd_list_has_keys(new)) {",
          "5439:         new->hash = orig->hash;",
          "5445:         new->priv = ctx->priv_dup_clb(orig->priv);",
          "5449:     if (parent && lyd_insert(parent, new)) {",
          "5450:         return EXIT_FAILURE;",
          "5453:     return EXIT_SUCCESS;",
          "5460:     struct lys_node_leaf *sleaf;",
          "5464:     struct lyd_node_leaf_list *new_leaf;",
          "5465:     struct lyd_node_anydata *new_any, *old_any;",
          "5467:     int r;",
          "",
          "[Added Lines]",
          "5383: _lyd_dup_node_common(struct lyd_node *new_node, const struct lyd_node *orig, struct ly_ctx *ctx, int options)",
          "5387:     new_node->attr = NULL;",
          "5390:             lyd_dup_attr(ctx, new_node, attr);",
          "5393:     new_node->next = NULL;",
          "5394:     new_node->prev = new_node;",
          "5395:     new_node->parent = NULL;",
          "5396:     new_node->validity = ly_new_node_validity(new_node->schema);",
          "5397:     new_node->dflt = orig->dflt;",
          "5398:     new_node->when_status = orig->when_status & LYD_WHEN;",
          "5401:     if ((new_node->schema->nodetype != LYS_LIST) || lyd_list_has_keys(new_node)) {",
          "5402:         new_node->hash = orig->hash;",
          "5408:         new_node->priv = ctx->priv_dup_clb(orig->priv);",
          "5412:     return EXIT_SUCCESS;",
          "5413: }",
          "5415: static struct lyd_node *",
          "5416: _lyd_dup_node(const struct lyd_node *node, const struct lys_node *schema, struct ly_ctx *ctx, int options)",
          "5417: {",
          "5418:     struct lyd_node *new_node = NULL;",
          "5419:     struct lys_node_leaf *sleaf;",
          "5420:     struct lyd_node_leaf_list *new_leaf;",
          "5421:     struct lyd_node_anydata *new_any, *old_any;",
          "5422:     int r;",
          "5425:     switch (node->schema->nodetype) {",
          "5426:     case LYS_LEAF:",
          "5427:     case LYS_LEAFLIST:",
          "5428:         new_leaf = calloc(1, sizeof *new_leaf);",
          "5429:         new_node = (struct lyd_node *)new_leaf;",
          "5430:         LY_CHECK_ERR_GOTO(!new_node, LOGMEM(ctx), error);",
          "5431:         new_node->schema = (struct lys_node *)schema;",
          "5433:         new_leaf->value_str = lydict_insert(ctx, ((struct lyd_node_leaf_list *)node)->value_str, 0);",
          "5434:         new_leaf->value_type = ((struct lyd_node_leaf_list *)node)->value_type;",
          "5435:         new_leaf->value_flags = ((struct lyd_node_leaf_list *)node)->value_flags;",
          "5436:         if (_lyd_dup_node_common(new_node, node, ctx, options)) {",
          "5437:             goto error;",
          "5438:         }",
          "5441:         sleaf = (struct lys_node_leaf *)new_leaf->schema;",
          "5443:         switch (new_leaf->value_type) {",
          "5444:         case LY_TYPE_BINARY:",
          "5445:         case LY_TYPE_STRING:",
          "5447:             new_leaf->value.string = new_leaf->value_str;",
          "5448:             break;",
          "5449:         case LY_TYPE_LEAFREF:",
          "5450:             new_leaf->validity |= LYD_VAL_LEAFREF;",
          "5451:             lyp_parse_value(&sleaf->type, &new_leaf->value_str, NULL, new_leaf, NULL, NULL, 1, node->dflt, 0);",
          "5452:             break;",
          "5453:         case LY_TYPE_INST:",
          "5454:             new_leaf->value.instance = NULL;",
          "5455:             break;",
          "5456:         case LY_TYPE_UNION:",
          "5459:             new_leaf->value.string = lydict_insert(ctx, ((struct lyd_node_leaf_list *)node)->value.string, 0);",
          "5460:             break;",
          "5461:         case LY_TYPE_ENUM:",
          "5462:         case LY_TYPE_IDENT:",
          "5463:         case LY_TYPE_BITS:",
          "5467:             if (!lyp_parse_value(&sleaf->type, &new_leaf->value_str, NULL, new_leaf, NULL, NULL, 1, node->dflt, 0)) {",
          "5468:                 goto error;",
          "5469:             }",
          "5470:             break;",
          "5471:         default:",
          "5472:             new_leaf->value = ((struct lyd_node_leaf_list *)node)->value;",
          "5473:             break;",
          "5474:         }",
          "5476:         if (sleaf->type.der && sleaf->type.der->module) {",
          "5477:             r = lytype_store(sleaf->type.der->module, sleaf->type.der->name, new_leaf->value_str, &new_leaf->value);",
          "5478:             if (r == -1) {",
          "5479:                 goto error;",
          "5480:             } else if (!r) {",
          "5481:                 new_leaf->value_flags |= LY_VALUE_USER;",
          "5482:             }",
          "5483:         }",
          "5484:         break;",
          "5485:     case LYS_ANYXML:",
          "5486:     case LYS_ANYDATA:",
          "5487:         old_any = (struct lyd_node_anydata *)node;",
          "5488:         new_any = calloc(1, sizeof *new_any);",
          "5489:         new_node = (struct lyd_node *)new_any;",
          "5490:         LY_CHECK_ERR_GOTO(!new_node, LOGMEM(ctx), error);",
          "5491:         new_node->schema = (struct lys_node *)schema;",
          "5493:         if (_lyd_dup_node_common(new_node, node, ctx, options)) {",
          "5494:             goto error;",
          "5495:         }",
          "5497:         new_any->value_type = old_any->value_type;",
          "5498:         if (!(void*)old_any->value.tree) {",
          "5500:             break;",
          "5501:         }",
          "5503:         switch (old_any->value_type) {",
          "5504:         case LYD_ANYDATA_CONSTSTRING:",
          "5505:         case LYD_ANYDATA_SXML:",
          "5506:         case LYD_ANYDATA_JSON:",
          "5507:             new_any->value.str = lydict_insert(ctx, old_any->value.str, 0);",
          "5508:             break;",
          "5509:         case LYD_ANYDATA_DATATREE:",
          "5510:             new_any->value.tree = lyd_dup_to_ctx(old_any->value.tree, 1, ctx);",
          "5511:             break;",
          "5512:         case LYD_ANYDATA_XML:",
          "5513:             new_any->value.xml = lyxml_dup_elem(ctx, old_any->value.xml, NULL, 1);",
          "5514:             break;",
          "5515:         case LYD_ANYDATA_LYB:",
          "5516:             r = lyd_lyb_data_length(old_any->value.mem);",
          "5517:             if (r == -1) {",
          "5518:                 LOGERR(ctx, LY_EINVAL, \"Invalid LYB data.\");",
          "5519:                 goto error;",
          "5520:             }",
          "5521:             new_any->value.mem = malloc(r);",
          "5522:             LY_CHECK_ERR_GOTO(!new_any->value.mem, LOGMEM(ctx), error);",
          "5523:             memcpy(new_any->value.mem, old_any->value.mem, r);",
          "5524:             break;",
          "5525:         case LYD_ANYDATA_STRING:",
          "5526:         case LYD_ANYDATA_SXMLD:",
          "5527:         case LYD_ANYDATA_JSOND:",
          "5528:         case LYD_ANYDATA_LYBD:",
          "5530:             assert(0);",
          "5531:             break;",
          "5532:         }",
          "5533:         break;",
          "5534:     case LYS_CONTAINER:",
          "5535:     case LYS_LIST:",
          "5536:     case LYS_NOTIF:",
          "5537:     case LYS_RPC:",
          "5538:     case LYS_ACTION:",
          "5539:         new_node = calloc(1, sizeof *new_node);",
          "5540:         LY_CHECK_ERR_GOTO(!new_node, LOGMEM(ctx), error);",
          "5541:         new_node->schema = (struct lys_node *)schema;",
          "5543:         if (_lyd_dup_node_common(new_node, node, ctx, options)) {",
          "5544:             goto error;",
          "5545:         }",
          "5546:         break;",
          "5547:     default:",
          "5548:         LOGINT(ctx);",
          "5549:         goto error;",
          "5552:     return new_node;",
          "5554: error:",
          "5555:     lyd_free(new_node);",
          "5556:     return NULL;",
          "5564:     struct lys_node *schema;",
          "5565:     const char *yang_data_name;",
          "5566:     const struct lys_module *trg_mod;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "5485:     for (elem = next = node; elem; elem = next) {",
          "5543:                     goto error;",
          "5544:                 }",
          "5549:             }",
          "5557:                 }",
          "5567:                 goto error;",
          "5568:             }",
          "5621:             goto error;",
          "5622:         }",
          "5623:         if (!ret) {",
          "5624:             ret = new_node;",
          "5625:         }",
          "",
          "[Removed Lines]",
          "5488:         switch (elem->schema->nodetype) {",
          "5489:         case LYS_LEAF:",
          "5490:         case LYS_LEAFLIST:",
          "5491:             new_leaf = calloc(1, sizeof *new_leaf);",
          "5492:             new_node = (struct lyd_node *)new_leaf;",
          "5493:             LY_CHECK_ERR_GOTO(!new_node, LOGMEM(log_ctx), error);",
          "5495:             new_leaf->value_str = lydict_insert(ctx ? ctx : elem->schema->module->ctx,",
          "5496:                                                 ((struct lyd_node_leaf_list *)elem)->value_str, 0);",
          "5497:             new_leaf->value_type = ((struct lyd_node_leaf_list *)elem)->value_type;",
          "5498:             new_leaf->value_flags = ((struct lyd_node_leaf_list *)elem)->value_flags;",
          "5499:             if (lyd_dup_common(parent, new_node, elem, ctx, options)) {",
          "5500:                 if (!new_node->schema) {",
          "5503:                     lydict_remove(ctx ? ctx : elem->schema->module->ctx, new_leaf->value_str);",
          "5504:                 }",
          "5505:                 goto error;",
          "5506:             }",
          "5509:             sleaf = (struct lys_node_leaf *)new_leaf->schema;",
          "5511:             switch (new_leaf->value_type) {",
          "5512:             case LY_TYPE_BINARY:",
          "5513:             case LY_TYPE_STRING:",
          "5515:                 new_leaf->value.string = new_leaf->value_str;",
          "5516:                 break;",
          "5517:             case LY_TYPE_LEAFREF:",
          "5518:                 new_leaf->validity |= LYD_VAL_LEAFREF;",
          "5519:                 lyp_parse_value(&sleaf->type, &new_leaf->value_str, NULL, new_leaf, NULL, NULL, 1, elem->dflt, 0);",
          "5520:                 break;",
          "5521:             case LY_TYPE_INST:",
          "5522:                 new_leaf->value.instance = NULL;",
          "5523:                 break;",
          "5524:             case LY_TYPE_UNION:",
          "5527:                 new_leaf->value.string = lydict_insert(ctx ? ctx : elem->schema->module->ctx,",
          "5528:                                                        ((struct lyd_node_leaf_list *)elem)->value.string, 0);",
          "5529:                 break;",
          "5530:             case LY_TYPE_ENUM:",
          "5531:                 if (!ctx) {",
          "5533:                     new_leaf->value = ((struct lyd_node_leaf_list *)elem)->value;",
          "5534:                     break;",
          "5535:                 }",
          "5537:             case LY_TYPE_IDENT:",
          "5538:             case LY_TYPE_BITS:",
          "5542:                 if (!lyp_parse_value(&sleaf->type, &new_leaf->value_str, NULL, new_leaf, NULL, NULL, 1, elem->dflt, 0)) {",
          "5545:                 break;",
          "5546:             default:",
          "5547:                 new_leaf->value = ((struct lyd_node_leaf_list *)elem)->value;",
          "5548:                 break;",
          "5551:             if (sleaf->type.der && sleaf->type.der->module) {",
          "5552:                 r = lytype_store(sleaf->type.der->module, sleaf->type.der->name, new_leaf->value_str, &new_leaf->value);",
          "5553:                 if (r == -1) {",
          "5554:                     goto error;",
          "5555:                 } else if (!r) {",
          "5556:                     new_leaf->value_flags |= LY_VALUE_USER;",
          "5558:             }",
          "5559:             break;",
          "5560:         case LYS_ANYXML:",
          "5561:         case LYS_ANYDATA:",
          "5562:             old_any = (struct lyd_node_anydata *)elem;",
          "5563:             new_any = calloc(1, sizeof *new_any);",
          "5564:             new_node = (struct lyd_node *)new_any;",
          "5565:             LY_CHECK_ERR_GOTO(!new_node, LOGMEM(log_ctx), error);",
          "5566:             if (lyd_dup_common(parent, new_node, elem, ctx, options)) {",
          "5570:             new_any->value_type = old_any->value_type;",
          "5571:             if (!(void*)old_any->value.tree) {",
          "5573:                 break;",
          "5574:             }",
          "5576:             switch (old_any->value_type) {",
          "5577:             case LYD_ANYDATA_CONSTSTRING:",
          "5578:             case LYD_ANYDATA_SXML:",
          "5579:             case LYD_ANYDATA_JSON:",
          "5580:                 new_any->value.str = lydict_insert(ctx ? ctx : elem->schema->module->ctx, old_any->value.str, 0);",
          "5581:                 break;",
          "5582:             case LYD_ANYDATA_DATATREE:",
          "5583:                 new_any->value.tree = lyd_dup_to_ctx(old_any->value.tree, 1, ctx);",
          "5584:                 break;",
          "5585:             case LYD_ANYDATA_XML:",
          "5586:                 new_any->value.xml = lyxml_dup_elem(ctx ? ctx : elem->schema->module->ctx, old_any->value.xml, NULL, 1);",
          "5587:                 break;",
          "5588:             case LYD_ANYDATA_LYB:",
          "5589:                 r = lyd_lyb_data_length(old_any->value.mem);",
          "5590:                 if (r == -1) {",
          "5591:                     LOGERR(log_ctx, LY_EINVAL, \"Invalid LYB data.\");",
          "5592:                     goto error;",
          "5593:                 }",
          "5594:                 new_any->value.mem = malloc(r);",
          "5595:                 LY_CHECK_ERR_GOTO(!new_any->value.mem, LOGMEM(log_ctx), error);",
          "5596:                 memcpy(new_any->value.mem, old_any->value.mem, r);",
          "5597:                 break;",
          "5598:             case LYD_ANYDATA_STRING:",
          "5599:             case LYD_ANYDATA_SXMLD:",
          "5600:             case LYD_ANYDATA_JSOND:",
          "5601:             case LYD_ANYDATA_LYBD:",
          "5603:                 assert(0);",
          "5604:                 break;",
          "5605:             }",
          "5606:             break;",
          "5607:         case LYS_CONTAINER:",
          "5608:         case LYS_LIST:",
          "5609:         case LYS_NOTIF:",
          "5610:         case LYS_RPC:",
          "5611:         case LYS_ACTION:",
          "5612:             new_node = calloc(1, sizeof *new_node);",
          "5613:             LY_CHECK_ERR_GOTO(!new_node, LOGMEM(log_ctx), error);",
          "5615:             if (lyd_dup_common(parent, new_node, elem, ctx, options)) {",
          "5616:                 goto error;",
          "5617:             }",
          "5618:             break;",
          "5619:         default:",
          "5620:             LOGINT(log_ctx);",
          "",
          "[Added Lines]",
          "5590:         if (ctx) {",
          "5591:             schema = NULL;",
          "5592:             if (parent) {",
          "5593:                 trg_mod = lyp_get_module(parent->schema->module, NULL, 0, lyd_node_module(elem)->name,",
          "5594:                                          strlen(lyd_node_module(elem)->name), 1);",
          "5595:                 if (!trg_mod) {",
          "5596:                     LOGERR(log_ctx, LY_EINVAL, \"Target context does not contain model for the data node being duplicated (%s).\",",
          "5597:                                 lyd_node_module(elem)->name);",
          "5601:                 lys_getnext_data(trg_mod, parent->schema, elem->schema->name, strlen(elem->schema->name),",
          "5602:                                  elem->schema->nodetype, (const struct lys_node **)&schema);",
          "5603:             } else {",
          "5605:                 schema = lyd_get_schema_inctx(elem, ctx);",
          "5608:             if (!schema) {",
          "5609:                 yang_data_name = lyp_get_yang_data_template_name(elem);",
          "5610:                 if (yang_data_name) {",
          "5611:                     LOGERR(log_ctx, LY_EINVAL, \"Target context does not contain schema node for the data node being duplicated \"",
          "5612:                                         \"(%s:#%s/%s).\", lyd_node_module(elem)->name, yang_data_name, elem->schema->name);",
          "5613:                 } else {",
          "5614:                     LOGERR(log_ctx, LY_EINVAL, \"Target context does not contain schema node for the data node being duplicated \"",
          "5615:                                         \"(%s:%s).\", lyd_node_module(elem)->name, elem->schema->name);",
          "5619:         } else {",
          "5620:             schema = elem->schema;",
          "5621:         }",
          "5624:         new_node = _lyd_dup_node(elem, schema, log_ctx, options);",
          "5625:         if (!new_node) {",
          "5626:             goto error;",
          "5627:         }",
          "5629:         if (parent && lyd_insert(parent, new_node)) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "5705:     return ret;",
          "5707: error:",
          "5713:     lyd_free(ret);",
          "5714:     return NULL;",
          "5715: }",
          "",
          "[Removed Lines]",
          "5708:     if (new_node && new_node->schema) {",
          "5709:         lyd_free(new_node);",
          "5710:     } else {",
          "5711:         free(new_node);",
          "5712:     }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "5720:     return lyd_dup_to_ctx(node, options, NULL);",
          "5721: }",
          "5723: API struct lyd_node *",
          "5724: lyd_dup_withsiblings(const struct lyd_node *node, int options)",
          "5725: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5728: static struct lyd_node *",
          "5729: lyd_dup_withsiblings_r(const struct lyd_node *first, struct lyd_node *parent_dup, int options)",
          "5730: {",
          "5731:     struct lyd_node *first_dup = NULL, *prev_dup = NULL, *last_dup;",
          "5732:     const struct lyd_node *next;",
          "5734:     assert(first);",
          "5737:     LY_TREE_FOR(first, next) {",
          "5738:         last_dup = _lyd_dup_node(next, next->schema, next->schema->module->ctx, options);",
          "5739:         if (!last_dup) {",
          "5740:             goto error;",
          "5741:         }",
          "5744:         last_dup->validity = next->validity;",
          "5745:         last_dup->when_status = next->when_status;",
          "5747:         last_dup->parent = parent_dup;",
          "5748:         if (!first_dup) {",
          "5749:             first_dup = last_dup;",
          "5750:         } else {",
          "5751:             assert(prev_dup);",
          "5752:             prev_dup->next = last_dup;",
          "5753:             last_dup->prev = prev_dup;",
          "5754:         }",
          "5756:         if ((next->schema->nodetype & (LYS_LIST | LYS_CONTAINER | LYS_RPC | LYS_ACTION | LYS_NOTIF)) && next->child) {",
          "5758:             if (!lyd_dup_withsiblings_r(next->child, last_dup, options)) {",
          "5759:                 goto error;",
          "5760:             }",
          "5761:         }",
          "5763:         prev_dup = last_dup;",
          "5764:     }",
          "5767:     assert(!prev_dup->next);",
          "5768:     first_dup->prev = prev_dup;",
          "5769:     if (parent_dup) {",
          "5770:         parent_dup->child = first_dup;",
          "5771:     }",
          "5773:     return first_dup;",
          "5775: error:",
          "5777:     first_dup->parent = NULL;",
          "5778:     lyd_free_withsiblings(first_dup);",
          "5779:     return NULL;",
          "5780: }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "5730:         return NULL;",
          "5731:     }",
          "5736:     }",
          "5749:             return NULL;",
          "5750:         }",
          "5767:         }",
          "5770:     }",
          "5772:     return ret;",
          "",
          "[Removed Lines]",
          "5733:     ret = lyd_dup(node, options);",
          "5734:     if (!ret) {",
          "5735:         return NULL;",
          "5739:     ret_iter = ret;",
          "5740:     LY_TREE_FOR(node->next, iter) {",
          "5741:         tmp = lyd_dup(iter, options);",
          "5742:         if (!tmp) {",
          "5743:             lyd_free_withsiblings(ret);",
          "5744:             return NULL;",
          "5745:         }",
          "5747:         if (lyd_insert_after(ret_iter, tmp)) {",
          "5748:             lyd_free_withsiblings(ret);",
          "5751:         ret_iter = ret_iter->next;",
          "5752:         assert(ret_iter == tmp);",
          "5753:     }",
          "5756:     ret_iter = ret;",
          "5757:     for (iter = node->prev; iter->next; iter = iter->prev) {",
          "5758:         tmp = lyd_dup(iter, options);",
          "5759:         if (!tmp) {",
          "5760:             lyd_free_withsiblings(ret);",
          "5761:             return NULL;",
          "5762:         }",
          "5764:         if (lyd_insert_before(ret_iter, tmp)) {",
          "5765:             lyd_free_withsiblings(ret);",
          "5766:             return NULL;",
          "5768:         ret_iter = ret_iter->prev;",
          "5769:         assert(ret_iter == tmp);",
          "",
          "[Added Lines]",
          "5793:     while (node->prev->next) {",
          "5794:         node = node->prev;",
          "5797:     if (node->parent) {",
          "5798:         ret = lyd_dup(node, options);",
          "5799:         if (!ret) {",
          "5804:         ret_iter = ret;",
          "5805:         LY_TREE_FOR(node->next, iter) {",
          "5806:             tmp = lyd_dup(iter, options);",
          "5807:             if (!tmp) {",
          "5808:                 lyd_free_withsiblings(ret);",
          "5809:                 return NULL;",
          "5810:             }",
          "5812:             if (lyd_insert_after(ret_iter, tmp)) {",
          "5813:                 lyd_free_withsiblings(ret);",
          "5814:                 return NULL;",
          "5815:             }",
          "5816:             ret_iter = ret_iter->next;",
          "5817:             assert(ret_iter == tmp);",
          "5819:     } else {",
          "5821:         ret = lyd_dup_withsiblings_r(node, NULL, options);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
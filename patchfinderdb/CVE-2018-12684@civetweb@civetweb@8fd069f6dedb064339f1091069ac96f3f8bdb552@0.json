{
  "cve_id": "CVE-2018-12684",
  "cve_desc": "Out-of-bounds Read in the send_ssi_file function in civetweb.c in CivetWeb through 1.10 allows attackers to cause a Denial of Service or Information Disclosure via a crafted SSI file.",
  "repo": "civetweb/civetweb",
  "patch_hash": "8fd069f6dedb064339f1091069ac96f3f8bdb552",
  "patch_info": {
    "commit_hash": "8fd069f6dedb064339f1091069ac96f3f8bdb552",
    "repo": "civetweb/civetweb",
    "commit_url": "https://github.com/civetweb/civetweb/commit/8fd069f6dedb064339f1091069ac96f3f8bdb552",
    "files": [
      "src/civetweb.c"
    ],
    "message": "Check length of memcmp",
    "before_after_code_files": [
      "src/civetweb.c||src/civetweb.c"
    ]
  },
  "patch_diff": {
    "src/civetweb.c||src/civetweb.c": [
      "File: src/civetweb.c -> src/civetweb.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "11612:      buf[len] = 0;",
      "11615:       do_ssi_include(conn, path, buf + 12, include_level + 1);",
      "11616: #if !defined(NO_POPEN)",
      "11618:       do_ssi_exec(conn, buf + 9);",
      "11620:      } else {",
      "",
      "[Removed Lines]",
      "11614:      if (!memcmp(buf + 5, \"include\", 7)) {",
      "11617:      } else if (!memcmp(buf + 5, \"exec\", 4)) {",
      "",
      "[Added Lines]",
      "11614:      if ((len > 12) && !memcmp(buf + 5, \"include\", 7)) {",
      "11617:      } else if ((len > 9) && !memcmp(buf + 5, \"exec\", 4)) {",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "733a2fb29ecdf6ece9e2b2a692ebcf26344737be",
      "candidate_info": {
        "commit_hash": "733a2fb29ecdf6ece9e2b2a692ebcf26344737be",
        "repo": "civetweb/civetweb",
        "commit_url": "https://github.com/civetweb/civetweb/commit/733a2fb29ecdf6ece9e2b2a692ebcf26344737be",
        "files": [
          "src/civetweb.c"
        ],
        "message": "Indent and comment clock_gettime replacement code for Windows",
        "before_after_code_files": [
          "src/civetweb.c||src/civetweb.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/civetweb.c||src/civetweb.c"
          ],
          "candidate": [
            "src/civetweb.c||src/civetweb.c"
          ]
        }
      },
      "candidate_diff": {
        "src/civetweb.c||src/civetweb.c": [
          "File: src/civetweb.c -> src/civetweb.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "531:   }",
          "534:  }",
          "535: #endif",
          "549: #include \"file_ops.inl\"",
          "570: #if defined(_WIN32) && !defined(POLLIN)",
          "571: #ifndef HAVE_POLL",
          "577: #define POLLIN (0x0300)",
          "578: #endif",
          "579: #endif",
          "",
          "[Removed Lines]",
          "533:   return ok ? 0 : -1;",
          "540:  static int pthread_mutex_lock(pthread_mutex_t *);",
          "541:  static int pthread_mutex_unlock(pthread_mutex_t *);",
          "542:  static void path_to_unicode(const struct mg_connection *conn,",
          "543:                              const char *path,",
          "544:                              wchar_t *wbuf,",
          "545:                              size_t wbuf_len);",
          "551:  struct mg_file;",
          "553:  static const char *mg_fgets(char *buf,",
          "554:                              size_t size,",
          "555:                              struct mg_file *filep,",
          "556:                              char **p);",
          "560:  struct dirent {",
          "561:   char d_name[PATH_MAX];",
          "562:  };",
          "564:  typedef struct DIR {",
          "565:   HANDLE handle;",
          "566:   WIN32_FIND_DATAW info;",
          "567:   struct dirent result;",
          "568:  } DIR;",
          "572:  struct pollfd {",
          "573:   SOCKET fd;",
          "574:   short events;",
          "575:   short revents;",
          "576:  };",
          "",
          "[Added Lines]",
          "533:  return ok ? 0 : -1;",
          "534: }",
          "540: static int pthread_mutex_lock(pthread_mutex_t *);",
          "541: static int pthread_mutex_unlock(pthread_mutex_t *);",
          "542: static void path_to_unicode(const struct mg_connection *conn,",
          "543:                             const char *path,",
          "544:                             wchar_t *wbuf,",
          "545:                             size_t wbuf_len);",
          "551: struct mg_file;",
          "553: static const char *",
          "554: mg_fgets(char *buf, size_t size, struct mg_file *filep, char **p);",
          "558: struct dirent {",
          "559:  char d_name[PATH_MAX];",
          "560: };",
          "562: typedef struct DIR {",
          "563:  HANDLE handle;",
          "564:  WIN32_FIND_DATAW info;",
          "565:  struct dirent result;",
          "566: } DIR;",
          "570: struct pollfd {",
          "571:  SOCKET fd;",
          "572:  short events;",
          "573:  short revents;",
          "574: };",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "676: #endif",
          "701:  }",
          "724: #if defined(__MINGW32__)",
          "726: #pragma GCC diagnostic pop",
          "727: #endif",
          "730: #else",
          "731: static pthread_mutexattr_t pthread_mutex_attr;",
          "",
          "[Removed Lines]",
          "679:  static CRITICAL_SECTION global_log_file_lock;",
          "681:  FUNCTION_MAY_BE_UNUSED",
          "682:  static DWORD pthread_self(void)",
          "683:  {",
          "684:   return GetCurrentThreadId();",
          "685:  }",
          "688:  FUNCTION_MAY_BE_UNUSED",
          "689:  static int pthread_key_create(",
          "690:      pthread_key_t * key,",
          "692:      )",
          "693:  {",
          "694:   (void)_ignored;",
          "696:   if ((key != 0)) {",
          "698:    return (*key != TLS_OUT_OF_INDEXES) ? 0 : -1;",
          "699:   }",
          "700:   return -2;",
          "704:  FUNCTION_MAY_BE_UNUSED",
          "705:  static int pthread_key_delete(pthread_key_t key)",
          "706:  {",
          "707:   return TlsFree(key) ? 0 : 1;",
          "708:  }",
          "711:  FUNCTION_MAY_BE_UNUSED",
          "712:  static int pthread_setspecific(pthread_key_t key, void *value)",
          "713:  {",
          "714:   return TlsSetValue(key, value) ? 0 : 1;",
          "715:  }",
          "718:  FUNCTION_MAY_BE_UNUSED",
          "719:  static void *pthread_getspecific(pthread_key_t key)",
          "720:  {",
          "721:   return TlsGetValue(key);",
          "722:  }",
          "729:  static struct pthread_mutex_undefined_struct *pthread_mutex_attr = NULL;",
          "",
          "[Added Lines]",
          "677: static CRITICAL_SECTION global_log_file_lock;",
          "679: FUNCTION_MAY_BE_UNUSED",
          "680: static DWORD",
          "681: pthread_self(void)",
          "682: {",
          "683:  return GetCurrentThreadId();",
          "684: }",
          "687: FUNCTION_MAY_BE_UNUSED",
          "688: static int",
          "689: pthread_key_create(",
          "690:     pthread_key_t *key,",
          "692:     )",
          "693: {",
          "694:  (void)_ignored;",
          "696:  if ((key != 0)) {",
          "698:   return (*key != TLS_OUT_OF_INDEXES) ? 0 : -1;",
          "700:  return -2;",
          "701: }",
          "704: FUNCTION_MAY_BE_UNUSED",
          "705: static int",
          "706: pthread_key_delete(pthread_key_t key)",
          "707: {",
          "708:  return TlsFree(key) ? 0 : 1;",
          "709: }",
          "712: FUNCTION_MAY_BE_UNUSED",
          "713: static int",
          "714: pthread_setspecific(pthread_key_t key, void *value)",
          "715: {",
          "716:  return TlsSetValue(key, value) ? 0 : 1;",
          "717: }",
          "720: FUNCTION_MAY_BE_UNUSED",
          "721: static void *",
          "722: pthread_getspecific(pthread_key_t key)",
          "723: {",
          "724:  return TlsGetValue(key);",
          "725: }",
          "732: static struct pthread_mutex_undefined_struct *pthread_mutex_attr = NULL;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "750: #endif",
          "769:  }",
          "799:  }",
          "843: #define _beginthreadex(psec, stack, func, prm, flags, ptid)                    \\",
          "844:  (uintptr_t) CreateThread(psec, stack, func, prm, flags, ptid)",
          "",
          "[Removed Lines]",
          "753:  FUNCTION_MAY_BE_UNUSED",
          "754:  static time_t time(time_t * ptime)",
          "755:  {",
          "756:   time_t t;",
          "757:   SYSTEMTIME st;",
          "758:   FILETIME ft;",
          "760:   GetSystemTime(&st);",
          "761:   SystemTimeToFileTime(&st, &ft);",
          "762:   t = SYS2UNIX_TIME(ft.dwLowDateTime, ft.dwHighDateTime);",
          "764:   if (ptime != NULL) {",
          "766:   }",
          "768:   return t;",
          "772:  FUNCTION_MAY_BE_UNUSED",
          "773:  static struct tm *localtime_s(const time_t *ptime, struct tm *ptm)",
          "774:  {",
          "775:   int64_t t = ((int64_t)*ptime) * RATE_DIFF + EPOCH_DIFF;",
          "776:   FILETIME ft, lft;",
          "777:   SYSTEMTIME st;",
          "778:   TIME_ZONE_INFORMATION tzinfo;",
          "780:   if (ptm == NULL) {",
          "781:    return NULL;",
          "782:   }",
          "785:   FileTimeToLocalFileTime(&ft, &lft);",
          "786:   FileTimeToSystemTime(&lft, &st);",
          "787:   ptm->tm_year = st.wYear - 1900;",
          "788:   ptm->tm_mon = st.wMonth - 1;",
          "789:   ptm->tm_wday = st.wDayOfWeek;",
          "790:   ptm->tm_mday = st.wDay;",
          "791:   ptm->tm_hour = st.wHour;",
          "792:   ptm->tm_min = st.wMinute;",
          "793:   ptm->tm_sec = st.wSecond;",
          "795:   ptm->tm_isdst =",
          "796:       (GetTimeZoneInformation(&tzinfo) == TIME_ZONE_ID_DAYLIGHT) ? 1 : 0;",
          "798:   return ptm;",
          "802:  FUNCTION_MAY_BE_UNUSED",
          "803:  static struct tm *gmtime_s(const time_t *ptime, struct tm *ptm)",
          "804:  {",
          "806:   return localtime_s(ptime, ptm);",
          "807:  }",
          "810:  static int mg_atomic_inc(volatile int *addr);",
          "811:  static struct tm tm_array[MAX_WORKER_THREADS];",
          "812:  static int tm_index = 0;",
          "815:  FUNCTION_MAY_BE_UNUSED",
          "816:  static struct tm *localtime(const time_t *ptime)",
          "817:  {",
          "818:   int i =",
          "819:       mg_atomic_inc(&tm_index) % (sizeof(tm_array) / sizeof(tm_array[0]));",
          "820:   return localtime_s(ptime, tm_array + i);",
          "821:  }",
          "824:  FUNCTION_MAY_BE_UNUSED",
          "825:  static struct tm *gmtime(const time_t *ptime)",
          "826:  {",
          "827:   int i = mg_atomic_inc(&tm_index) % ARRAY_SIZE(tm_array);",
          "828:   return gmtime_s(ptime, tm_array + i);",
          "829:  }",
          "832:  FUNCTION_MAY_BE_UNUSED",
          "833:  static size_t strftime(char *dst,",
          "834:                         size_t dst_size,",
          "835:                         const char *fmt,",
          "836:                         const struct tm *tm)",
          "837:  {",
          "840:   return 0;",
          "841:  }",
          "",
          "[Added Lines]",
          "756: FUNCTION_MAY_BE_UNUSED",
          "757: static time_t",
          "758: time(time_t *ptime)",
          "759: {",
          "760:  time_t t;",
          "761:  SYSTEMTIME st;",
          "762:  FILETIME ft;",
          "764:  GetSystemTime(&st);",
          "765:  SystemTimeToFileTime(&st, &ft);",
          "766:  t = SYS2UNIX_TIME(ft.dwLowDateTime, ft.dwHighDateTime);",
          "768:  if (ptime != NULL) {",
          "772:  return t;",
          "773: }",
          "776: FUNCTION_MAY_BE_UNUSED",
          "777: static struct tm *",
          "778: localtime_s(const time_t *ptime, struct tm *ptm)",
          "779: {",
          "780:  int64_t t = ((int64_t)*ptime) * RATE_DIFF + EPOCH_DIFF;",
          "781:  FILETIME ft, lft;",
          "782:  SYSTEMTIME st;",
          "783:  TIME_ZONE_INFORMATION tzinfo;",
          "785:  if (ptm == NULL) {",
          "786:   return NULL;",
          "790:  FileTimeToLocalFileTime(&ft, &lft);",
          "791:  FileTimeToSystemTime(&lft, &st);",
          "792:  ptm->tm_year = st.wYear - 1900;",
          "793:  ptm->tm_mon = st.wMonth - 1;",
          "794:  ptm->tm_wday = st.wDayOfWeek;",
          "795:  ptm->tm_mday = st.wDay;",
          "796:  ptm->tm_hour = st.wHour;",
          "797:  ptm->tm_min = st.wMinute;",
          "798:  ptm->tm_sec = st.wSecond;",
          "800:  ptm->tm_isdst =",
          "801:      (GetTimeZoneInformation(&tzinfo) == TIME_ZONE_ID_DAYLIGHT) ? 1 : 0;",
          "803:  return ptm;",
          "804: }",
          "807: FUNCTION_MAY_BE_UNUSED",
          "808: static struct tm *",
          "809: gmtime_s(const time_t *ptime, struct tm *ptm)",
          "810: {",
          "812:  return localtime_s(ptime, ptm);",
          "813: }",
          "816: static int mg_atomic_inc(volatile int *addr);",
          "817: static struct tm tm_array[MAX_WORKER_THREADS];",
          "818: static int tm_index = 0;",
          "821: FUNCTION_MAY_BE_UNUSED",
          "822: static struct tm *",
          "823: localtime(const time_t *ptime)",
          "824: {",
          "825:  int i = mg_atomic_inc(&tm_index) % (sizeof(tm_array) / sizeof(tm_array[0]));",
          "826:  return localtime_s(ptime, tm_array + i);",
          "827: }",
          "830: FUNCTION_MAY_BE_UNUSED",
          "831: static struct tm *",
          "832: gmtime(const time_t *ptime)",
          "833: {",
          "834:  int i = mg_atomic_inc(&tm_index) % ARRAY_SIZE(tm_array);",
          "835:  return gmtime_s(ptime, tm_array + i);",
          "836: }",
          "839: FUNCTION_MAY_BE_UNUSED",
          "840: static size_t",
          "841: strftime(char *dst, size_t dst_size, const char *fmt, const struct tm *tm)",
          "842: {",
          "845:  return 0;",
          "846: }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "846: #define remove(f) mg_remove(NULL, f)",
          "892:  }",
          "",
          "[Removed Lines]",
          "849:  FUNCTION_MAY_BE_UNUSED",
          "850:  static int rename(const char *a, const char *b)",
          "851:  {",
          "852:   wchar_t wa[PATH_MAX];",
          "853:   wchar_t wb[PATH_MAX];",
          "854:   path_to_unicode(NULL, a, wa, ARRAY_SIZE(wa));",
          "855:   path_to_unicode(NULL, b, wb, ARRAY_SIZE(wb));",
          "857:   return MoveFileW(wa, wb) ? 0 : -1;",
          "858:  }",
          "861:  struct stat {",
          "862:   int64_t st_size;",
          "863:   time_t st_mtime;",
          "864:  };",
          "867:  FUNCTION_MAY_BE_UNUSED",
          "868:  static int stat(const char *name, struct stat *st)",
          "869:  {",
          "870:   wchar_t wbuf[PATH_MAX];",
          "871:   WIN32_FILE_ATTRIBUTE_DATA attr;",
          "872:   time_t creation_time, write_time;",
          "874:   path_to_unicode(NULL, name, wbuf, ARRAY_SIZE(wbuf));",
          "875:   memset(&attr, 0, sizeof(attr));",
          "877:   GetFileAttributesExW(wbuf, GetFileExInfoStandard, &attr);",
          "878:   st->st_size =",
          "879:       (((int64_t)attr.nFileSizeHigh) << 32) + (int64_t)attr.nFileSizeLow;",
          "881:   write_time = SYS2UNIX_TIME(attr.ftLastWriteTime.dwLowDateTime,",
          "882:                              attr.ftLastWriteTime.dwHighDateTime);",
          "883:   creation_time = SYS2UNIX_TIME(attr.ftCreationTime.dwLowDateTime,",
          "884:                                 attr.ftCreationTime.dwHighDateTime);",
          "886:   if (creation_time > write_time) {",
          "887:    st->st_mtime = creation_time;",
          "888:   } else {",
          "889:    st->st_mtime = write_time;",
          "890:   }",
          "891:   return 0;",
          "",
          "[Added Lines]",
          "854: FUNCTION_MAY_BE_UNUSED",
          "855: static int",
          "856: rename(const char *a, const char *b)",
          "857: {",
          "858:  wchar_t wa[PATH_MAX];",
          "859:  wchar_t wb[PATH_MAX];",
          "860:  path_to_unicode(NULL, a, wa, ARRAY_SIZE(wa));",
          "861:  path_to_unicode(NULL, b, wb, ARRAY_SIZE(wb));",
          "863:  return MoveFileW(wa, wb) ? 0 : -1;",
          "864: }",
          "867: struct stat {",
          "868:  int64_t st_size;",
          "869:  time_t st_mtime;",
          "870: };",
          "873: FUNCTION_MAY_BE_UNUSED",
          "874: static int",
          "875: stat(const char *name, struct stat *st)",
          "876: {",
          "877:  wchar_t wbuf[PATH_MAX];",
          "878:  WIN32_FILE_ATTRIBUTE_DATA attr;",
          "879:  time_t creation_time, write_time;",
          "881:  path_to_unicode(NULL, name, wbuf, ARRAY_SIZE(wbuf));",
          "882:  memset(&attr, 0, sizeof(attr));",
          "884:  GetFileAttributesExW(wbuf, GetFileExInfoStandard, &attr);",
          "885:  st->st_size =",
          "886:      (((int64_t)attr.nFileSizeHigh) << 32) + (int64_t)attr.nFileSizeLow;",
          "888:  write_time = SYS2UNIX_TIME(attr.ftLastWriteTime.dwLowDateTime,",
          "889:                             attr.ftLastWriteTime.dwHighDateTime);",
          "890:  creation_time = SYS2UNIX_TIME(attr.ftCreationTime.dwLowDateTime,",
          "891:                                attr.ftCreationTime.dwHighDateTime);",
          "893:  if (creation_time > write_time) {",
          "894:   st->st_mtime = creation_time;",
          "895:  } else {",
          "896:   st->st_mtime = write_time;",
          "898:  return 0;",
          "899: }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "922: #pragma clang diagnostic ignored \"-Wunused-function\"",
          "923: #endif",
          "928: #if defined(_WIN32) && !defined(__SYMBIAN32__)",
          "935: #endif",
          "956: #if defined(_WIN32) && !defined(__SYMBIAN32__) && !defined(NO_ATOMICS)",
          "961: #elif defined(__GNUC__)                                                        \\",
          "962:     && ((__GNUC__ > 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ > 0)))           \\",
          "963:     && !defined(NO_ATOMICS)",
          "",
          "[Removed Lines]",
          "925:  static pthread_mutex_t global_lock_mutex;",
          "930:  FUNCTION_MAY_BE_UNUSED",
          "931:  static int pthread_mutex_lock(pthread_mutex_t * mutex);",
          "933:  FUNCTION_MAY_BE_UNUSED",
          "934:  static int pthread_mutex_unlock(pthread_mutex_t * mutex);",
          "938:  FUNCTION_MAY_BE_UNUSED",
          "939:  static void mg_global_lock(void)",
          "940:  {",
          "941:   (void)pthread_mutex_lock(&global_lock_mutex);",
          "942:  }",
          "945:  FUNCTION_MAY_BE_UNUSED",
          "946:  static void mg_global_unlock(void)",
          "947:  {",
          "948:   (void)pthread_mutex_unlock(&global_lock_mutex);",
          "949:  }",
          "952:  FUNCTION_MAY_BE_UNUSED",
          "953:  static int mg_atomic_inc(volatile int *addr)",
          "954:  {",
          "955:   int ret;",
          "960:   ret = InterlockedIncrement((volatile long *)addr);",
          "",
          "[Added Lines]",
          "932: static pthread_mutex_t global_lock_mutex;",
          "937: FUNCTION_MAY_BE_UNUSED",
          "938: static int pthread_mutex_lock(pthread_mutex_t *mutex);",
          "940: FUNCTION_MAY_BE_UNUSED",
          "941: static int pthread_mutex_unlock(pthread_mutex_t *mutex);",
          "945: FUNCTION_MAY_BE_UNUSED",
          "946: static void",
          "947: mg_global_lock(void)",
          "948: {",
          "949:  (void)pthread_mutex_lock(&global_lock_mutex);",
          "950: }",
          "953: FUNCTION_MAY_BE_UNUSED",
          "954: static void",
          "955: mg_global_unlock(void)",
          "956: {",
          "957:  (void)pthread_mutex_unlock(&global_lock_mutex);",
          "958: }",
          "961: FUNCTION_MAY_BE_UNUSED",
          "962: static int",
          "963: mg_atomic_inc(volatile int *addr)",
          "964: {",
          "965:  int ret;",
          "970:  ret = InterlockedIncrement((volatile long *)addr);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "967:  ret = (++(*addr));",
          "968:  mg_global_unlock();",
          "969: #endif",
          "978: #if defined(_WIN32) && !defined(__SYMBIAN32__) && !defined(NO_ATOMICS)",
          "983: #elif defined(__GNUC__)                                                        \\",
          "984:     && ((__GNUC__ > 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ > 0)))           \\",
          "985:     && !defined(NO_ATOMICS)",
          "",
          "[Removed Lines]",
          "970:   return ret;",
          "971:  }",
          "974:  FUNCTION_MAY_BE_UNUSED",
          "975:  static int mg_atomic_dec(volatile int *addr)",
          "976:  {",
          "977:   int ret;",
          "982:   ret = InterlockedDecrement((volatile long *)addr);",
          "",
          "[Added Lines]",
          "980:  return ret;",
          "981: }",
          "984: FUNCTION_MAY_BE_UNUSED",
          "985: static int",
          "986: mg_atomic_dec(volatile int *addr)",
          "987: {",
          "988:  int ret;",
          "993:  ret = InterlockedDecrement((volatile long *)addr);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "989:  ret = (--(*addr));",
          "990:  mg_global_unlock();",
          "991: #endif",
          "996: #if defined(USE_SERVER_STATS)",
          "1000: #if defined(_WIN32) && !defined(__SYMBIAN32__) && !defined(NO_ATOMICS)",
          "1002: #elif defined(__GNUC__)                                                        \\",
          "1003:     && ((__GNUC__ > 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ > 0)))           \\",
          "1004:     && !defined(NO_ATOMICS)",
          "",
          "[Removed Lines]",
          "992:   return ret;",
          "993:  }",
          "997:  static int64_t mg_atomic_add(volatile int64_t * addr, int64_t value)",
          "998:  {",
          "999:   int64_t ret;",
          "1001:   ret = InterlockedAdd64(addr, value);",
          "",
          "[Added Lines]",
          "1003:  return ret;",
          "1004: }",
          "1008: static int64_t",
          "1009: mg_atomic_add(volatile int64_t *addr, int64_t value)",
          "1010: {",
          "1011:  int64_t ret;",
          "1013:  ret = InterlockedAdd64(addr, value);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1009:  ret = (*addr);",
          "1010:  mg_global_unlock();",
          "1011: #endif",
          "1014: #endif",
          "",
          "[Removed Lines]",
          "1012:   return ret;",
          "1013:  }",
          "",
          "[Added Lines]",
          "1024:  return ret;",
          "1025: }",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1029: #if defined(USE_SERVER_STATS)",
          "1050: #if defined(MEMORY_DEBUGGING)",
          "1052: #else",
          "1053:  (void)file;",
          "1054:  (void)line;",
          "1055: #endif",
          "1069:   }",
          "1071: #if defined(MEMORY_DEBUGGING)",
          "1080: #if defined(_WIN32)",
          "1082: #else",
          "1084: #endif",
          "1085: #endif",
          "1103:  }",
          "1111: #if defined(MEMORY_DEBUGGING)",
          "1113: #else",
          "1114:  (void)file;",
          "1115:  (void)line;",
          "1116: #endif",
          "1124: #if defined(MEMORY_DEBUGGING)",
          "1133: #if defined(_WIN32)",
          "1135: #else",
          "1137: #endif",
          "1138: #endif",
          "1141:  }",
          "1154: #if defined(MEMORY_DEBUGGING)",
          "1156: #else",
          "1157:  (void)file;",
          "1158:  (void)line;",
          "1159: #endif",
          "1172: #if defined(MEMORY_DEBUGGING)",
          "1181: #if defined(_WIN32)",
          "1183: #else",
          "1185: #endif",
          "1186: #endif",
          "1188: #if defined(MEMORY_DEBUGGING)",
          "1197: #if defined(_WIN32)",
          "1199: #else",
          "1201: #endif",
          "1202: #endif",
          "1206: #if defined(MEMORY_DEBUGGING)",
          "1207: #if defined(_WIN32)",
          "1209: #else",
          "1211: #endif",
          "1212: #endif",
          "1218:    }",
          "1219:   } else {",
          "1223:   }",
          "1226:  }",
          "1228: #define mg_malloc(a) mg_malloc_ex(a, NULL, __FILE__, __LINE__)",
          "1229: #define mg_calloc(a, b) mg_calloc_ex(a, b, NULL, __FILE__, __LINE__)",
          "1230: #define mg_realloc(a, b) mg_realloc_ex(a, b, NULL, __FILE__, __LINE__)",
          "",
          "[Removed Lines]",
          "1031:  struct mg_memory_stat {",
          "1032:   volatile int64_t totalMemUsed;",
          "1033:   volatile int64_t maxMemUsed;",
          "1034:   volatile int blockCount;",
          "1035:  };",
          "1038:  static struct mg_memory_stat *get_memory_stat(struct mg_context * ctx);",
          "1041:  static void *mg_malloc_ex(size_t size,",
          "1042:                            struct mg_context * ctx,",
          "1043:                            const char *file,",
          "1044:                            unsigned line)",
          "1045:  {",
          "1046:   void *data = malloc(size + 2 * sizeof(uintptr_t));",
          "1047:   void *memory = 0;",
          "1048:   struct mg_memory_stat *mstat = get_memory_stat(ctx);",
          "1051:   char mallocStr[256];",
          "1057:   if (data) {",
          "1058:    int64_t mmem = mg_atomic_add(&mstat->totalMemUsed, (int64_t)size);",
          "1059:    if (mmem > mstat->maxMemUsed) {",
          "1062:     mstat->maxMemUsed = mmem;",
          "1063:    }",
          "1065:    mg_atomic_inc(&mstat->blockCount);",
          "1066:    ((uintptr_t *)data)[0] = size;",
          "1067:    ((uintptr_t *)data)[1] = (uintptr_t)mstat;",
          "1068:    memory = (void *)(((char *)data) + 2 * sizeof(uintptr_t));",
          "1072:   sprintf(mallocStr,",
          "1073:           \"MEM: %p %5lu alloc   %7lu %4lu --- %s:%u\\n\",",
          "1074:           memory,",
          "1075:           (unsigned long)size,",
          "1076:           (unsigned long)mstat->totalMemUsed,",
          "1077:           (unsigned long)mstat->blockCount,",
          "1078:           file,",
          "1079:           line);",
          "1081:   OutputDebugStringA(mallocStr);",
          "1083:   DEBUG_TRACE(\"%s\", mallocStr);",
          "1087:   return memory;",
          "1088:  }",
          "1091:  static void *mg_calloc_ex(size_t count,",
          "1092:                            size_t size,",
          "1093:                            struct mg_context * ctx,",
          "1094:                            const char *file,",
          "1095:                            unsigned line)",
          "1096:  {",
          "1097:   void *data = mg_malloc_ex(size * count, ctx, file, line);",
          "1099:   if (data) {",
          "1100:    memset(data, 0, size * count);",
          "1101:   }",
          "1102:   return data;",
          "1106:  static void mg_free_ex(void *memory, const char *file, unsigned line)",
          "1107:  {",
          "1108:   void *data = (void *)(((char *)memory) - 2 * sizeof(uintptr_t));",
          "1112:   char mallocStr[256];",
          "1118:   if (memory) {",
          "1119:    uintptr_t size = ((uintptr_t *)data)[0];",
          "1120:    struct mg_memory_stat *mstat =",
          "1121:        (struct mg_memory_stat *)(((uintptr_t *)data)[1]);",
          "1122:    mg_atomic_add(&mstat->totalMemUsed, -(int64_t)size);",
          "1123:    mg_atomic_dec(&mstat->blockCount);",
          "1125:    sprintf(mallocStr,",
          "1126:            \"MEM: %p %5lu free    %7lu %4lu --- %s:%u\\n\",",
          "1127:            memory,",
          "1128:            (unsigned long)size,",
          "1129:            (unsigned long)mstat->totalMemUsed,",
          "1130:            (unsigned long)mstat->blockCount,",
          "1131:            file,",
          "1132:            line);",
          "1134:    OutputDebugStringA(mallocStr);",
          "1136:    DEBUG_TRACE(\"%s\", mallocStr);",
          "1139:    free(data);",
          "1140:   }",
          "1144:  static void *mg_realloc_ex(void *memory,",
          "1145:                             size_t newsize,",
          "1146:                             struct mg_context *ctx,",
          "1147:                             const char *file,",
          "1148:                             unsigned line)",
          "1149:  {",
          "1150:   void *data;",
          "1151:   void *_realloc;",
          "1152:   uintptr_t oldsize;",
          "1155:   char mallocStr[256];",
          "1161:   if (newsize) {",
          "1162:    if (memory) {",
          "1164:     struct mg_memory_stat *mstat;",
          "1165:     data = (void *)(((char *)memory) - 2 * sizeof(uintptr_t));",
          "1166:     oldsize = ((uintptr_t *)data)[0];",
          "1167:     mstat = (struct mg_memory_stat *)((uintptr_t *)data)[1];",
          "1168:     _realloc = realloc(data, newsize + 2 * sizeof(uintptr_t));",
          "1169:     if (_realloc) {",
          "1170:      data = _realloc;",
          "1171:      mg_atomic_add(&mstat->totalMemUsed, -(int64_t)oldsize);",
          "1173:      sprintf(mallocStr,",
          "1174:              \"MEM: %p %5lu r-free  %7lu %4lu --- %s:%u\\n\",",
          "1175:              memory,",
          "1176:              (unsigned long)oldsize,",
          "1177:              (unsigned long)mstat->totalMemUsed,",
          "1178:              (unsigned long)mstat->blockCount,",
          "1179:              file,",
          "1180:              line);",
          "1182:      OutputDebugStringA(mallocStr);",
          "1184:      DEBUG_TRACE(\"%s\", mallocStr);",
          "1187:      mg_atomic_add(&mstat->totalMemUsed, (int64_t)newsize);",
          "1189:      sprintf(mallocStr,",
          "1190:              \"MEM: %p %5lu r-alloc %7lu %4lu --- %s:%u\\n\",",
          "1191:              memory,",
          "1192:              (unsigned long)newsize,",
          "1193:              (unsigned long)mstat->totalMemUsed,",
          "1194:              (unsigned long)mstat->blockCount,",
          "1195:              file,",
          "1196:              line);",
          "1198:      OutputDebugStringA(mallocStr);",
          "1200:      DEBUG_TRACE(\"%s\", mallocStr);",
          "1204:      data = (void *)(((char *)data) + 2 * sizeof(uintptr_t));",
          "1205:     } else {",
          "1208:      OutputDebugStringA(\"MEM: realloc failed\\n\");",
          "1210:      DEBUG_TRACE(\"%s\", \"MEM: realloc failed\\n\");",
          "1213:      return _realloc;",
          "1214:     }",
          "1215:    } else {",
          "1217:     data = mg_malloc_ex(newsize, ctx, file, line);",
          "1221:    data = 0;",
          "1222:    mg_free_ex(memory, file, line);",
          "1225:   return data;",
          "",
          "[Added Lines]",
          "1043: struct mg_memory_stat {",
          "1044:  volatile int64_t totalMemUsed;",
          "1045:  volatile int64_t maxMemUsed;",
          "1046:  volatile int blockCount;",
          "1047: };",
          "1050: static struct mg_memory_stat *get_memory_stat(struct mg_context *ctx);",
          "1053: static void *",
          "1054: mg_malloc_ex(size_t size,",
          "1055:              struct mg_context *ctx,",
          "1056:              const char *file,",
          "1057:              unsigned line)",
          "1058: {",
          "1059:  void *data = malloc(size + 2 * sizeof(uintptr_t));",
          "1060:  void *memory = 0;",
          "1061:  struct mg_memory_stat *mstat = get_memory_stat(ctx);",
          "1064:  char mallocStr[256];",
          "1070:  if (data) {",
          "1071:   int64_t mmem = mg_atomic_add(&mstat->totalMemUsed, (int64_t)size);",
          "1072:   if (mmem > mstat->maxMemUsed) {",
          "1075:    mstat->maxMemUsed = mmem;",
          "1078:   mg_atomic_inc(&mstat->blockCount);",
          "1079:   ((uintptr_t *)data)[0] = size;",
          "1080:   ((uintptr_t *)data)[1] = (uintptr_t)mstat;",
          "1081:   memory = (void *)(((char *)data) + 2 * sizeof(uintptr_t));",
          "1082:  }",
          "1085:  sprintf(mallocStr,",
          "1086:          \"MEM: %p %5lu alloc   %7lu %4lu --- %s:%u\\n\",",
          "1087:          memory,",
          "1088:          (unsigned long)size,",
          "1089:          (unsigned long)mstat->totalMemUsed,",
          "1090:          (unsigned long)mstat->blockCount,",
          "1091:          file,",
          "1092:          line);",
          "1094:  OutputDebugStringA(mallocStr);",
          "1096:  DEBUG_TRACE(\"%s\", mallocStr);",
          "1100:  return memory;",
          "1101: }",
          "1104: static void *",
          "1105: mg_calloc_ex(size_t count,",
          "1106:              size_t size,",
          "1107:              struct mg_context *ctx,",
          "1108:              const char *file,",
          "1109:              unsigned line)",
          "1110: {",
          "1111:  void *data = mg_malloc_ex(size * count, ctx, file, line);",
          "1113:  if (data) {",
          "1114:   memset(data, 0, size * count);",
          "1116:  return data;",
          "1117: }",
          "1120: static void",
          "1121: mg_free_ex(void *memory, const char *file, unsigned line)",
          "1122: {",
          "1123:  void *data = (void *)(((char *)memory) - 2 * sizeof(uintptr_t));",
          "1127:  char mallocStr[256];",
          "1133:  if (memory) {",
          "1134:   uintptr_t size = ((uintptr_t *)data)[0];",
          "1135:   struct mg_memory_stat *mstat =",
          "1136:       (struct mg_memory_stat *)(((uintptr_t *)data)[1]);",
          "1137:   mg_atomic_add(&mstat->totalMemUsed, -(int64_t)size);",
          "1138:   mg_atomic_dec(&mstat->blockCount);",
          "1140:   sprintf(mallocStr,",
          "1141:           \"MEM: %p %5lu free    %7lu %4lu --- %s:%u\\n\",",
          "1142:           memory,",
          "1143:           (unsigned long)size,",
          "1144:           (unsigned long)mstat->totalMemUsed,",
          "1145:           (unsigned long)mstat->blockCount,",
          "1146:           file,",
          "1147:           line);",
          "1149:   OutputDebugStringA(mallocStr);",
          "1151:   DEBUG_TRACE(\"%s\", mallocStr);",
          "1154:   free(data);",
          "1156: }",
          "1159: static void *",
          "1160: mg_realloc_ex(void *memory,",
          "1161:               size_t newsize,",
          "1162:               struct mg_context *ctx,",
          "1163:               const char *file,",
          "1164:               unsigned line)",
          "1165: {",
          "1166:  void *data;",
          "1167:  void *_realloc;",
          "1168:  uintptr_t oldsize;",
          "1171:  char mallocStr[256];",
          "1177:  if (newsize) {",
          "1178:   if (memory) {",
          "1180:    struct mg_memory_stat *mstat;",
          "1181:    data = (void *)(((char *)memory) - 2 * sizeof(uintptr_t));",
          "1182:    oldsize = ((uintptr_t *)data)[0];",
          "1183:    mstat = (struct mg_memory_stat *)((uintptr_t *)data)[1];",
          "1184:    _realloc = realloc(data, newsize + 2 * sizeof(uintptr_t));",
          "1185:    if (_realloc) {",
          "1186:     data = _realloc;",
          "1187:     mg_atomic_add(&mstat->totalMemUsed, -(int64_t)oldsize);",
          "1189:     sprintf(mallocStr,",
          "1190:             \"MEM: %p %5lu r-free  %7lu %4lu --- %s:%u\\n\",",
          "1191:             memory,",
          "1192:             (unsigned long)oldsize,",
          "1193:             (unsigned long)mstat->totalMemUsed,",
          "1194:             (unsigned long)mstat->blockCount,",
          "1195:             file,",
          "1196:             line);",
          "1198:     OutputDebugStringA(mallocStr);",
          "1200:     DEBUG_TRACE(\"%s\", mallocStr);",
          "1203:     mg_atomic_add(&mstat->totalMemUsed, (int64_t)newsize);",
          "1205:     sprintf(mallocStr,",
          "1206:             \"MEM: %p %5lu r-alloc %7lu %4lu --- %s:%u\\n\",",
          "1207:             memory,",
          "1208:             (unsigned long)newsize,",
          "1209:             (unsigned long)mstat->totalMemUsed,",
          "1210:             (unsigned long)mstat->blockCount,",
          "1211:             file,",
          "1212:             line);",
          "1214:     OutputDebugStringA(mallocStr);",
          "1216:     DEBUG_TRACE(\"%s\", mallocStr);",
          "1220:     data = (void *)(((char *)data) + 2 * sizeof(uintptr_t));",
          "1221:    } else {",
          "1224:     OutputDebugStringA(\"MEM: realloc failed\\n\");",
          "1226:     DEBUG_TRACE(\"%s\", \"MEM: realloc failed\\n\");",
          "1229:     return _realloc;",
          "1233:    data = mg_malloc_ex(newsize, ctx, file, line);",
          "1235:  } else {",
          "1237:   data = 0;",
          "1238:   mg_free_ex(memory, file, line);",
          "1241:  return data;",
          "1242: }",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1271:  static void mg_vsnprintf(const struct mg_connection *conn,",
          "1272:                           int *truncated,",
          "1273:                           char *buf,",
          "1274:                           size_t buflen,",
          "1275:                           const char *fmt,",
          "1276:                           va_list ap);",
          "1278:  static void mg_snprintf(const struct mg_connection *conn,",
          "1279:                          int *truncated,",
          "1280:                          char *buf,",
          "1281:                          size_t buflen,",
          "1282:                          PRINTF_FORMAT_STRING(const char *fmt),",
          "1283:                          ...) PRINTF_ARGS(5, 6);",
          "",
          "[Added Lines]",
          "1287: static void mg_vsnprintf(const struct mg_connection *conn,",
          "1288:                          int *truncated,",
          "1289:                          char *buf,",
          "1290:                          size_t buflen,",
          "1291:                          const char *fmt,",
          "1292:                          va_list ap);",
          "1294: static void mg_snprintf(const struct mg_connection *conn,",
          "1295:                         int *truncated,",
          "1296:                         char *buf,",
          "1297:                         size_t buflen,",
          "1298:                         PRINTF_FORMAT_STRING(const char *fmt),",
          "1299:                         ...) PRINTF_ARGS(5, 6);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1313: #endif",
          "1319: #if !defined(NO_SSL)",
          "1321: #endif",
          "1330: #if defined(_WIN32) && !defined(__SYMBIAN32__)",
          "1333: #endif",
          "1337: #if defined(__GNUC__) || defined(__MINGW32__)",
          "",
          "[Removed Lines]",
          "1317:  static int mg_init_library_called = 0;",
          "1320:  static int mg_ssl_initialized = 0;",
          "1324:  static int thread_idx_max = 0;",
          "1327:  struct mg_workerTLS {",
          "1328:   int is_master;",
          "1329:   unsigned long thread_idx;",
          "1331:   HANDLE pthread_cond_helper_mutex;",
          "1332:   struct mg_workerTLS *next_waiting_thread;",
          "1334:  };",
          "",
          "[Added Lines]",
          "1333: static int mg_init_library_called = 0;",
          "1336: static int mg_ssl_initialized = 0;",
          "1340: static int thread_idx_max = 0;",
          "1343: struct mg_workerTLS {",
          "1344:  int is_master;",
          "1345:  unsigned long thread_idx;",
          "1347:  HANDLE pthread_cond_helper_mutex;",
          "1348:  struct mg_workerTLS *next_waiting_thread;",
          "1350: };",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1348: #endif",
          "1364: #ifdef _WIN32",
          "1366: #else",
          "1368: #ifdef __clang__",
          "",
          "[Removed Lines]",
          "1361:  FUNCTION_MAY_BE_UNUSED",
          "1362:  static unsigned long mg_current_thread_id(void)",
          "1363:  {",
          "1365:   return GetCurrentThreadId();",
          "",
          "[Added Lines]",
          "1377: FUNCTION_MAY_BE_UNUSED",
          "1378: static unsigned long",
          "1379: mg_current_thread_id(void)",
          "1380: {",
          "1382:  return GetCurrentThreadId();",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1404: #endif",
          "1406: #endif",
          "1420: #if defined(__GNUC__)",
          "",
          "[Removed Lines]",
          "1407:  }",
          "1410:  FUNCTION_MAY_BE_UNUSED",
          "1411:  static uint64_t mg_get_current_time_ns(void)",
          "1412:  {",
          "1413:   struct timespec tsnow;",
          "1414:   clock_gettime(CLOCK_REALTIME, &tsnow);",
          "1415:   return (((uint64_t)tsnow.tv_sec) * 1000000000)",
          "1416:          + (uint64_t)tsnow.tv_nsec;",
          "1417:  }",
          "",
          "[Added Lines]",
          "1424: }",
          "1427: FUNCTION_MAY_BE_UNUSED",
          "1428: static uint64_t",
          "1429: mg_get_current_time_ns(void)",
          "1430: {",
          "1431:  struct timespec tsnow;",
          "1432:  clock_gettime(CLOCK_REALTIME, &tsnow);",
          "1433:  return (((uint64_t)tsnow.tv_sec) * 1000000000) + (uint64_t)tsnow.tv_nsec;",
          "1434: }",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "1432: #if !defined(DEBUG_TRACE)",
          "1433: #if defined(DEBUG)",
          "1474:   nslast = nsnow;",
          "1475:  }",
          "1477: #define DEBUG_TRACE(fmt, ...)                                                  \\",
          "1478:  DEBUG_TRACE_FUNC(__func__, __LINE__, fmt, __VA_ARGS__)",
          "",
          "[Removed Lines]",
          "1434:  static void DEBUG_TRACE_FUNC(const char *func,",
          "1435:                               unsigned line,",
          "1436:                               PRINTF_FORMAT_STRING(const char *fmt),",
          "1437:                               ...) PRINTF_ARGS(3, 4);",
          "1439:  static void DEBUG_TRACE_FUNC(const char *func,",
          "1440:                               unsigned line,",
          "1441:                               const char *fmt,",
          "1442:                               ...)",
          "1443:  {",
          "1444:   va_list args;",
          "1445:   uint64_t nsnow;",
          "1446:   static uint64_t nslast;",
          "1447:   struct timespec tsnow;",
          "1450:   unsigned long thread_id = mg_current_thread_id();",
          "1452:   clock_gettime(CLOCK_REALTIME, &tsnow);",
          "1453:   nsnow = ((uint64_t)tsnow.tv_sec) * ((uint64_t)1000000000)",
          "1454:           + ((uint64_t)tsnow.tv_nsec);",
          "1456:   if (!nslast) {",
          "1457:    nslast = nsnow;",
          "1458:   }",
          "1460:   flockfile(stdout);",
          "1461:   printf(\"*** %lu.%09lu %12\" INT64_FMT \" %lu %s:%u: \",",
          "1462:          (unsigned long)tsnow.tv_sec,",
          "1463:          (unsigned long)tsnow.tv_nsec,",
          "1464:          nsnow - nslast,",
          "1465:          thread_id,",
          "1466:          func,",
          "1467:          line);",
          "1468:   va_start(args, fmt);",
          "1469:   vprintf(fmt, args);",
          "1470:   va_end(args);",
          "1471:   putchar('\\n');",
          "1472:   fflush(stdout);",
          "1473:   funlockfile(stdout);",
          "",
          "[Added Lines]",
          "1451: static void DEBUG_TRACE_FUNC(const char *func,",
          "1452:                              unsigned line,",
          "1453:                              PRINTF_FORMAT_STRING(const char *fmt),",
          "1454:                              ...) PRINTF_ARGS(3, 4);",
          "1456: static void",
          "1457: DEBUG_TRACE_FUNC(const char *func, unsigned line, const char *fmt, ...)",
          "1458: {",
          "1459:  va_list args;",
          "1460:  uint64_t nsnow;",
          "1461:  static uint64_t nslast;",
          "1462:  struct timespec tsnow;",
          "1465:  unsigned long thread_id = mg_current_thread_id();",
          "1467:  clock_gettime(CLOCK_REALTIME, &tsnow);",
          "1468:  nsnow = ((uint64_t)tsnow.tv_sec) * ((uint64_t)1000000000)",
          "1469:          + ((uint64_t)tsnow.tv_nsec);",
          "1471:  if (!nslast) {",
          "1475:  flockfile(stdout);",
          "1476:  printf(\"*** %lu.%09lu %12\" INT64_FMT \" %lu %s:%u: \",",
          "1477:         (unsigned long)tsnow.tv_sec,",
          "1478:         (unsigned long)tsnow.tv_nsec,",
          "1479:         nsnow - nslast,",
          "1480:         thread_id,",
          "1481:         func,",
          "1482:         line);",
          "1483:  va_start(args, fmt);",
          "1484:  vprintf(fmt, args);",
          "1485:  va_end(args);",
          "1486:  putchar('\\n');",
          "1487:  fflush(stdout);",
          "1488:  funlockfile(stdout);",
          "1489:  nslast = nsnow;",
          "1490: }",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "1492: #ifdef NO_SOCKLEN_T",
          "1495: #define _DARWIN_UNLIMITED_SELECT",
          "",
          "[Removed Lines]",
          "1493:  typedef int socklen_t;",
          "",
          "[Added Lines]",
          "1508: typedef int socklen_t;",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "1513: #if defined(NO_SSL)",
          "1516: #else",
          "1517: #if defined(NO_SSL_DL)",
          "1518: #include <openssl/ssl.h>",
          "",
          "[Removed Lines]",
          "1515:  typedef struct SSL_CTX SSL_CTX;",
          "",
          "[Added Lines]",
          "1530: typedef struct SSL_CTX SSL_CTX;",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "1893: #if !defined(NO_CACHING)",
          "1914: #if defined(USE_IPV6)",
          "1955: #define STRUCT_FILE_INITIALIZER                                                \\",
          "1956:  {                                                                          \\",
          "",
          "[Removed Lines]",
          "1894:  static const char *month_names[] = {\"Jan\",",
          "1895:                                      \"Feb\",",
          "1896:                                      \"Mar\",",
          "1897:                                      \"Apr\",",
          "1898:                                      \"May\",",
          "1899:                                      \"Jun\",",
          "1900:                                      \"Jul\",",
          "1901:                                      \"Aug\",",
          "1902:                                      \"Sep\",",
          "1903:                                      \"Oct\",",
          "1904:                                      \"Nov\",",
          "1905:                                      \"Dec\"};",
          "1911:  union usa {",
          "1912:   struct sockaddr sa;",
          "1913:   struct sockaddr_in sin;",
          "1915:   struct sockaddr_in6 sin6;",
          "1916: #endif",
          "1917:  };",
          "1920:  struct vec {",
          "1921:   const char *ptr;",
          "1922:   size_t len;",
          "1923:  };",
          "1925:  struct mg_file_stat {",
          "1927:   uint64_t size;",
          "1928:   time_t last_modified;",
          "1930:   int is_gzipped;   /* Set to 1 if the content is gzipped, in which",
          "1933:  };",
          "1935:  struct mg_file_in_memory {",
          "1936:   char *p;",
          "1937:   uint32_t pos;",
          "1938:   char mode;",
          "1939:  };",
          "1941:  struct mg_file_access {",
          "1943:   FILE *fp;",
          "1947:   const char *membuf;",
          "1948:  };",
          "1950:  struct mg_file {",
          "1951:   struct mg_file_stat stat;",
          "1952:   struct mg_file_access access;",
          "1953:  };",
          "",
          "[Added Lines]",
          "1909: static const char *month_names[] = {\"Jan\",",
          "1910:                                     \"Feb\",",
          "1911:                                     \"Mar\",",
          "1912:                                     \"Apr\",",
          "1913:                                     \"May\",",
          "1914:                                     \"Jun\",",
          "1915:                                     \"Jul\",",
          "1916:                                     \"Aug\",",
          "1917:                                     \"Sep\",",
          "1918:                                     \"Oct\",",
          "1919:                                     \"Nov\",",
          "1920:                                     \"Dec\"};",
          "1926: union usa {",
          "1927:  struct sockaddr sa;",
          "1928:  struct sockaddr_in sin;",
          "1930:  struct sockaddr_in6 sin6;",
          "1931: #endif",
          "1932: };",
          "1935: struct vec {",
          "1936:  const char *ptr;",
          "1937:  size_t len;",
          "1938: };",
          "1940: struct mg_file_stat {",
          "1942:  uint64_t size;",
          "1943:  time_t last_modified;",
          "1945:  int is_gzipped;   /* Set to 1 if the content is gzipped, in which",
          "1948: };",
          "1950: struct mg_file_in_memory {",
          "1951:  char *p;",
          "1952:  uint32_t pos;",
          "1953:  char mode;",
          "1954: };",
          "1956: struct mg_file_access {",
          "1958:  FILE *fp;",
          "1962:  const char *membuf;",
          "1963: };",
          "1965: struct mg_file {",
          "1966:  struct mg_file_stat stat;",
          "1967:  struct mg_file_access access;",
          "1968: };",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "1963:   }                                                                      \\",
          "1964:  }",
          "2018: #if defined(USE_WEBSOCKET)",
          "2020: #endif",
          "2024: #if defined(USE_LUA)",
          "2028: #endif",
          "2029: #if defined(USE_DUKTAPE)",
          "2031: #endif",
          "2033: #if defined(USE_WEBSOCKET)",
          "2035: #endif",
          "2036: #if defined(USE_LUA) && defined(USE_WEBSOCKET)",
          "2038: #endif",
          "2046: #if !defined(NO_CACHING)",
          "2048: #endif",
          "2049: #if !defined(NO_SSL)",
          "2051: #endif",
          "2052: #if defined(__linux__)",
          "2054: #endif",
          "2055: #if defined(_WIN32)",
          "2057: #endif",
          "2058: #if defined(USE_LUA)",
          "2085: #ifdef USE_LUA",
          "2089: #else",
          "2090:      \"index.xhtml,index.html,index.htm,index.cgi,index.shtml,index.php\"},",
          "2091: #endif",
          "2117: #if defined(USE_WEBSOCKET)",
          "2119: #endif",
          "2122: #if defined(USE_LUA)",
          "2126: #endif",
          "2127: #if defined(USE_DUKTAPE)",
          "2131: #endif",
          "2133: #if defined(USE_WEBSOCKET)",
          "2135: #endif",
          "2136: #if defined(USE_LUA) && defined(USE_WEBSOCKET)",
          "2138: #endif",
          "2144: #if !defined(NO_CACHING)",
          "2146: #endif",
          "2147: #if !defined(NO_SSL)",
          "2149: #endif",
          "2150: #if defined(__linux__)",
          "2152: #endif",
          "2153: #if defined(_WIN32)",
          "2155: #endif",
          "2156: #if defined(USE_LUA)",
          "2158: #endif",
          "2222: #ifdef ALTERNATIVE_QUEUE",
          "2225: #else",
          "",
          "[Removed Lines]",
          "1968:  struct socket {",
          "1973:   unsigned char",
          "1974:       ssl_redir;        /* Is port supposed to redirect everything to SSL",
          "1977:  };",
          "1980:  enum {",
          "1981:   CGI_EXTENSIONS,",
          "1982:   CGI_ENVIRONMENT,",
          "1983:   PUT_DELETE_PASSWORDS_FILE,",
          "1984:   CGI_INTERPRETER,",
          "1985:   PROTECT_URI,",
          "1986:   AUTHENTICATION_DOMAIN,",
          "1987:   ENABLE_AUTH_DOMAIN_CHECK,",
          "1988:   SSI_EXTENSIONS,",
          "1989:   THROTTLE,",
          "1990:   ACCESS_LOG_FILE,",
          "1991:   ENABLE_DIRECTORY_LISTING,",
          "1992:   ERROR_LOG_FILE,",
          "1993:   GLOBAL_PASSWORDS_FILE,",
          "1994:   INDEX_FILES,",
          "1995:   ENABLE_KEEP_ALIVE,",
          "1996:   ACCESS_CONTROL_LIST,",
          "1997:   EXTRA_MIME_TYPES,",
          "1998:   LISTENING_PORTS,",
          "1999:   DOCUMENT_ROOT,",
          "2000:   SSL_CERTIFICATE,",
          "2001:   SSL_CERTIFICATE_CHAIN,",
          "2002:   NUM_THREADS,",
          "2003:   RUN_AS_USER,",
          "2004:   URL_REWRITE_PATTERN,",
          "2005:   HIDE_FILES,",
          "2006:   REQUEST_TIMEOUT,",
          "2007:   KEEP_ALIVE_TIMEOUT,",
          "2008:   LINGER_TIMEOUT,",
          "2009:   SSL_DO_VERIFY_PEER,",
          "2010:   SSL_CA_PATH,",
          "2011:   SSL_CA_FILE,",
          "2012:   SSL_VERIFY_DEPTH,",
          "2013:   SSL_DEFAULT_VERIFY_PATHS,",
          "2014:   SSL_CIPHER_LIST,",
          "2015:   SSL_PROTOCOL_VERSION,",
          "2016:   SSL_SHORT_TRUST,",
          "2019:   WEBSOCKET_TIMEOUT,",
          "2022:   DECODE_URL,",
          "2025:   LUA_PRELOAD_FILE,",
          "2026:   LUA_SCRIPT_EXTENSIONS,",
          "2027:   LUA_SERVER_PAGE_EXTENSIONS,",
          "2030:   DUKTAPE_SCRIPT_EXTENSIONS,",
          "2034:   WEBSOCKET_ROOT,",
          "2037:   LUA_WEBSOCKET_EXTENSIONS,",
          "2040:   ACCESS_CONTROL_ALLOW_ORIGIN,",
          "2041:   ACCESS_CONTROL_ALLOW_METHODS,",
          "2042:   ACCESS_CONTROL_ALLOW_HEADERS,",
          "2043:   ERROR_PAGES,",
          "2044:   CONFIG_TCP_NODELAY, /* Prepended CONFIG_ to avoid conflict with the",
          "2047:   STATIC_FILE_MAX_AGE,",
          "2050:   STRICT_HTTPS_MAX_AGE,",
          "2053:   ALLOW_SENDFILE_CALL,",
          "2056:   CASE_SENSITIVE_FILES,",
          "2059:   LUA_BACKGROUND_SCRIPT,",
          "2060: #endif",
          "2061:   ADDITIONAL_HEADER,",
          "2062:   MAX_REQUEST_SIZE,",
          "2064:   NUM_OPTIONS",
          "2065:  };",
          "2069:  static struct mg_option config_options[] = {",
          "2070:      {\"cgi_pattern\", CONFIG_TYPE_EXT_PATTERN, \"**.cgi$|**.pl$|**.php$\"},",
          "2071:      {\"cgi_environment\", CONFIG_TYPE_STRING_LIST, NULL},",
          "2072:      {\"put_delete_auth_file\", CONFIG_TYPE_FILE, NULL},",
          "2073:      {\"cgi_interpreter\", CONFIG_TYPE_FILE, NULL},",
          "2074:      {\"protect_uri\", CONFIG_TYPE_STRING_LIST, NULL},",
          "2075:      {\"authentication_domain\", CONFIG_TYPE_STRING, \"mydomain.com\"},",
          "2076:      {\"enable_auth_domain_check\", CONFIG_TYPE_BOOLEAN, \"yes\"},",
          "2077:      {\"ssi_pattern\", CONFIG_TYPE_EXT_PATTERN, \"**.shtml$|**.shtm$\"},",
          "2078:      {\"throttle\", CONFIG_TYPE_STRING_LIST, NULL},",
          "2079:      {\"access_log_file\", CONFIG_TYPE_FILE, NULL},",
          "2080:      {\"enable_directory_listing\", CONFIG_TYPE_BOOLEAN, \"yes\"},",
          "2081:      {\"error_log_file\", CONFIG_TYPE_FILE, NULL},",
          "2082:      {\"global_auth_file\", CONFIG_TYPE_FILE, NULL},",
          "2083:      {\"index_files\",",
          "2084:       CONFIG_TYPE_STRING_LIST,",
          "2086:       \"index.xhtml,index.html,index.htm,index.lp,index.lsp,index.lua,index.\"",
          "2087:       \"cgi,\"",
          "2088:       \"index.shtml,index.php\"},",
          "2092:      {\"enable_keep_alive\", CONFIG_TYPE_BOOLEAN, \"no\"},",
          "2093:      {\"access_control_list\", CONFIG_TYPE_STRING_LIST, NULL},",
          "2094:      {\"extra_mime_types\", CONFIG_TYPE_STRING_LIST, NULL},",
          "2095:      {\"listening_ports\", CONFIG_TYPE_STRING_LIST, \"8080\"},",
          "2096:      {\"document_root\", CONFIG_TYPE_DIRECTORY, NULL},",
          "2097:      {\"ssl_certificate\", CONFIG_TYPE_FILE, NULL},",
          "2098:      {\"ssl_certificate_chain\", CONFIG_TYPE_FILE, NULL},",
          "2099:      {\"num_threads\", CONFIG_TYPE_NUMBER, \"50\"},",
          "2100:      {\"run_as_user\", CONFIG_TYPE_STRING, NULL},",
          "2101:      {\"url_rewrite_patterns\", CONFIG_TYPE_STRING_LIST, NULL},",
          "2102:      {\"hide_files_patterns\", CONFIG_TYPE_EXT_PATTERN, NULL},",
          "2103:      {\"request_timeout_ms\", CONFIG_TYPE_NUMBER, \"30000\"},",
          "2104:      {\"keep_alive_timeout_ms\", CONFIG_TYPE_NUMBER, \"500\"},",
          "2105:      {\"linger_timeout_ms\", CONFIG_TYPE_NUMBER, NULL},",
          "2108:      {\"ssl_verify_peer\", CONFIG_TYPE_BOOLEAN, \"no\"},",
          "2110:      {\"ssl_ca_path\", CONFIG_TYPE_DIRECTORY, NULL},",
          "2111:      {\"ssl_ca_file\", CONFIG_TYPE_FILE, NULL},",
          "2112:      {\"ssl_verify_depth\", CONFIG_TYPE_NUMBER, \"9\"},",
          "2113:      {\"ssl_default_verify_paths\", CONFIG_TYPE_BOOLEAN, \"yes\"},",
          "2114:      {\"ssl_cipher_list\", CONFIG_TYPE_STRING, NULL},",
          "2115:      {\"ssl_protocol_version\", CONFIG_TYPE_NUMBER, \"0\"},",
          "2116:      {\"ssl_short_trust\", CONFIG_TYPE_BOOLEAN, \"no\"},",
          "2118:      {\"websocket_timeout_ms\", CONFIG_TYPE_NUMBER, \"30000\"},",
          "2120:      {\"decode_url\", CONFIG_TYPE_BOOLEAN, \"yes\"},",
          "2123:      {\"lua_preload_file\", CONFIG_TYPE_FILE, NULL},",
          "2124:      {\"lua_script_pattern\", CONFIG_TYPE_EXT_PATTERN, \"**.lua$\"},",
          "2125:      {\"lua_server_page_pattern\", CONFIG_TYPE_EXT_PATTERN, \"**.lp$|**.lsp$\"},",
          "2130:      {\"duktape_script_pattern\", CONFIG_TYPE_EXT_PATTERN, \"**.ssjs$\"},",
          "2134:      {\"websocket_root\", CONFIG_TYPE_DIRECTORY, NULL},",
          "2137:      {\"lua_websocket_pattern\", CONFIG_TYPE_EXT_PATTERN, \"**.lua$\"},",
          "2139:      {\"access_control_allow_origin\", CONFIG_TYPE_STRING, \"*\"},",
          "2140:      {\"access_control_allow_methods\", CONFIG_TYPE_STRING, \"*\"},",
          "2141:      {\"access_control_allow_headers\", CONFIG_TYPE_STRING, \"*\"},",
          "2142:      {\"error_pages\", CONFIG_TYPE_DIRECTORY, NULL},",
          "2143:      {\"tcp_nodelay\", CONFIG_TYPE_NUMBER, \"0\"},",
          "2145:      {\"static_file_max_age\", CONFIG_TYPE_NUMBER, \"3600\"},",
          "2148:      {\"strict_transport_security_max_age\", CONFIG_TYPE_NUMBER, NULL},",
          "2151:      {\"allow_sendfile_call\", CONFIG_TYPE_BOOLEAN, \"yes\"},",
          "2154:      {\"case_sensitive\", CONFIG_TYPE_BOOLEAN, \"no\"},",
          "2157:      {\"lua_background_script\", CONFIG_TYPE_FILE, NULL},",
          "2159:      {\"additional_header\", CONFIG_TYPE_STRING_MULTILINE, NULL},",
          "2160:      {\"max_request_size\", CONFIG_TYPE_NUMBER, \"16384\"},",
          "2162:      {NULL, CONFIG_TYPE_UNKNOWN, NULL}};",
          "2167:  mg_static_assert((sizeof(config_options) / sizeof(config_options[0]))",
          "2168:                       == (NUM_OPTIONS + 1),",
          "2169:                   \"config_options and enum not sync\");",
          "2172:  enum { REQUEST_HANDLER, WEBSOCKET_HANDLER, AUTH_HANDLER };",
          "2175:  struct mg_handler_info {",
          "2177:   char *uri;",
          "2178:   size_t uri_len;",
          "2181:   int handler_type;",
          "2184:   mg_request_handler handler;",
          "2187:   mg_websocket_connect_handler connect_handler;",
          "2188:   mg_websocket_ready_handler ready_handler;",
          "2189:   mg_websocket_data_handler data_handler;",
          "2190:   mg_websocket_close_handler close_handler;",
          "2193:   struct mg_websocket_subprotocols *subprotocols;",
          "2196:   mg_authorization_handler auth_handler;",
          "2199:   void *cbdata;",
          "2202:   struct mg_handler_info *next;",
          "2203:  };",
          "2206:  struct mg_context {",
          "2212:   int context_type;              /* 1 = server context,",
          "2216:   struct socket *listening_sockets;",
          "2217:   struct pollfd *listening_socket_fds;",
          "2218:   unsigned int num_listening_sockets;",
          "2223:   struct socket *client_socks;",
          "2224:   void **client_wait_events;",
          "",
          "[Added Lines]",
          "1983: struct socket {",
          "1988:  unsigned char ssl_redir; /* Is port supposed to redirect everything to SSL",
          "1991: };",
          "1994: enum {",
          "1995:  CGI_EXTENSIONS,",
          "1996:  CGI_ENVIRONMENT,",
          "1997:  PUT_DELETE_PASSWORDS_FILE,",
          "1998:  CGI_INTERPRETER,",
          "1999:  PROTECT_URI,",
          "2000:  AUTHENTICATION_DOMAIN,",
          "2001:  ENABLE_AUTH_DOMAIN_CHECK,",
          "2002:  SSI_EXTENSIONS,",
          "2003:  THROTTLE,",
          "2004:  ACCESS_LOG_FILE,",
          "2005:  ENABLE_DIRECTORY_LISTING,",
          "2006:  ERROR_LOG_FILE,",
          "2007:  GLOBAL_PASSWORDS_FILE,",
          "2008:  INDEX_FILES,",
          "2009:  ENABLE_KEEP_ALIVE,",
          "2010:  ACCESS_CONTROL_LIST,",
          "2011:  EXTRA_MIME_TYPES,",
          "2012:  LISTENING_PORTS,",
          "2013:  DOCUMENT_ROOT,",
          "2014:  SSL_CERTIFICATE,",
          "2015:  SSL_CERTIFICATE_CHAIN,",
          "2016:  NUM_THREADS,",
          "2017:  RUN_AS_USER,",
          "2018:  URL_REWRITE_PATTERN,",
          "2019:  HIDE_FILES,",
          "2020:  REQUEST_TIMEOUT,",
          "2021:  KEEP_ALIVE_TIMEOUT,",
          "2022:  LINGER_TIMEOUT,",
          "2023:  SSL_DO_VERIFY_PEER,",
          "2024:  SSL_CA_PATH,",
          "2025:  SSL_CA_FILE,",
          "2026:  SSL_VERIFY_DEPTH,",
          "2027:  SSL_DEFAULT_VERIFY_PATHS,",
          "2028:  SSL_CIPHER_LIST,",
          "2029:  SSL_PROTOCOL_VERSION,",
          "2030:  SSL_SHORT_TRUST,",
          "2033:  WEBSOCKET_TIMEOUT,",
          "2036:  DECODE_URL,",
          "2039:  LUA_PRELOAD_FILE,",
          "2040:  LUA_SCRIPT_EXTENSIONS,",
          "2041:  LUA_SERVER_PAGE_EXTENSIONS,",
          "2044:  DUKTAPE_SCRIPT_EXTENSIONS,",
          "2048:  WEBSOCKET_ROOT,",
          "2051:  LUA_WEBSOCKET_EXTENSIONS,",
          "2054:  ACCESS_CONTROL_ALLOW_ORIGIN,",
          "2055:  ACCESS_CONTROL_ALLOW_METHODS,",
          "2056:  ACCESS_CONTROL_ALLOW_HEADERS,",
          "2057:  ERROR_PAGES,",
          "2058:  CONFIG_TCP_NODELAY, /* Prepended CONFIG_ to avoid conflict with the",
          "2061:  STATIC_FILE_MAX_AGE,",
          "2064:  STRICT_HTTPS_MAX_AGE,",
          "2067:  ALLOW_SENDFILE_CALL,",
          "2070:  CASE_SENSITIVE_FILES,",
          "2073:  LUA_BACKGROUND_SCRIPT,",
          "2074: #endif",
          "2075:  ADDITIONAL_HEADER,",
          "2076:  MAX_REQUEST_SIZE,",
          "2078:  NUM_OPTIONS",
          "2079: };",
          "2083: static struct mg_option config_options[] = {",
          "2084:     {\"cgi_pattern\", CONFIG_TYPE_EXT_PATTERN, \"**.cgi$|**.pl$|**.php$\"},",
          "2085:     {\"cgi_environment\", CONFIG_TYPE_STRING_LIST, NULL},",
          "2086:     {\"put_delete_auth_file\", CONFIG_TYPE_FILE, NULL},",
          "2087:     {\"cgi_interpreter\", CONFIG_TYPE_FILE, NULL},",
          "2088:     {\"protect_uri\", CONFIG_TYPE_STRING_LIST, NULL},",
          "2089:     {\"authentication_domain\", CONFIG_TYPE_STRING, \"mydomain.com\"},",
          "2090:     {\"enable_auth_domain_check\", CONFIG_TYPE_BOOLEAN, \"yes\"},",
          "2091:     {\"ssi_pattern\", CONFIG_TYPE_EXT_PATTERN, \"**.shtml$|**.shtm$\"},",
          "2092:     {\"throttle\", CONFIG_TYPE_STRING_LIST, NULL},",
          "2093:     {\"access_log_file\", CONFIG_TYPE_FILE, NULL},",
          "2094:     {\"enable_directory_listing\", CONFIG_TYPE_BOOLEAN, \"yes\"},",
          "2095:     {\"error_log_file\", CONFIG_TYPE_FILE, NULL},",
          "2096:     {\"global_auth_file\", CONFIG_TYPE_FILE, NULL},",
          "2097:     {\"index_files\",",
          "2098:      CONFIG_TYPE_STRING_LIST,",
          "2100:      \"index.xhtml,index.html,index.htm,index.lp,index.lsp,index.lua,index.\"",
          "2101:      \"cgi,\"",
          "2102:      \"index.shtml,index.php\"},",
          "2106:     {\"enable_keep_alive\", CONFIG_TYPE_BOOLEAN, \"no\"},",
          "2107:     {\"access_control_list\", CONFIG_TYPE_STRING_LIST, NULL},",
          "2108:     {\"extra_mime_types\", CONFIG_TYPE_STRING_LIST, NULL},",
          "2109:     {\"listening_ports\", CONFIG_TYPE_STRING_LIST, \"8080\"},",
          "2110:     {\"document_root\", CONFIG_TYPE_DIRECTORY, NULL},",
          "2111:     {\"ssl_certificate\", CONFIG_TYPE_FILE, NULL},",
          "2112:     {\"ssl_certificate_chain\", CONFIG_TYPE_FILE, NULL},",
          "2113:     {\"num_threads\", CONFIG_TYPE_NUMBER, \"50\"},",
          "2114:     {\"run_as_user\", CONFIG_TYPE_STRING, NULL},",
          "2115:     {\"url_rewrite_patterns\", CONFIG_TYPE_STRING_LIST, NULL},",
          "2116:     {\"hide_files_patterns\", CONFIG_TYPE_EXT_PATTERN, NULL},",
          "2117:     {\"request_timeout_ms\", CONFIG_TYPE_NUMBER, \"30000\"},",
          "2118:     {\"keep_alive_timeout_ms\", CONFIG_TYPE_NUMBER, \"500\"},",
          "2119:     {\"linger_timeout_ms\", CONFIG_TYPE_NUMBER, NULL},",
          "2122:     {\"ssl_verify_peer\", CONFIG_TYPE_BOOLEAN, \"no\"},",
          "2124:     {\"ssl_ca_path\", CONFIG_TYPE_DIRECTORY, NULL},",
          "2125:     {\"ssl_ca_file\", CONFIG_TYPE_FILE, NULL},",
          "2126:     {\"ssl_verify_depth\", CONFIG_TYPE_NUMBER, \"9\"},",
          "2127:     {\"ssl_default_verify_paths\", CONFIG_TYPE_BOOLEAN, \"yes\"},",
          "2128:     {\"ssl_cipher_list\", CONFIG_TYPE_STRING, NULL},",
          "2129:     {\"ssl_protocol_version\", CONFIG_TYPE_NUMBER, \"0\"},",
          "2130:     {\"ssl_short_trust\", CONFIG_TYPE_BOOLEAN, \"no\"},",
          "2132:     {\"websocket_timeout_ms\", CONFIG_TYPE_NUMBER, \"30000\"},",
          "2134:     {\"decode_url\", CONFIG_TYPE_BOOLEAN, \"yes\"},",
          "2137:     {\"lua_preload_file\", CONFIG_TYPE_FILE, NULL},",
          "2138:     {\"lua_script_pattern\", CONFIG_TYPE_EXT_PATTERN, \"**.lua$\"},",
          "2139:     {\"lua_server_page_pattern\", CONFIG_TYPE_EXT_PATTERN, \"**.lp$|**.lsp$\"},",
          "2144:     {\"duktape_script_pattern\", CONFIG_TYPE_EXT_PATTERN, \"**.ssjs$\"},",
          "2148:     {\"websocket_root\", CONFIG_TYPE_DIRECTORY, NULL},",
          "2151:     {\"lua_websocket_pattern\", CONFIG_TYPE_EXT_PATTERN, \"**.lua$\"},",
          "2153:     {\"access_control_allow_origin\", CONFIG_TYPE_STRING, \"*\"},",
          "2154:     {\"access_control_allow_methods\", CONFIG_TYPE_STRING, \"*\"},",
          "2155:     {\"access_control_allow_headers\", CONFIG_TYPE_STRING, \"*\"},",
          "2156:     {\"error_pages\", CONFIG_TYPE_DIRECTORY, NULL},",
          "2157:     {\"tcp_nodelay\", CONFIG_TYPE_NUMBER, \"0\"},",
          "2159:     {\"static_file_max_age\", CONFIG_TYPE_NUMBER, \"3600\"},",
          "2162:     {\"strict_transport_security_max_age\", CONFIG_TYPE_NUMBER, NULL},",
          "2165:     {\"allow_sendfile_call\", CONFIG_TYPE_BOOLEAN, \"yes\"},",
          "2168:     {\"case_sensitive\", CONFIG_TYPE_BOOLEAN, \"no\"},",
          "2171:     {\"lua_background_script\", CONFIG_TYPE_FILE, NULL},",
          "2173:     {\"additional_header\", CONFIG_TYPE_STRING_MULTILINE, NULL},",
          "2174:     {\"max_request_size\", CONFIG_TYPE_NUMBER, \"16384\"},",
          "2176:     {NULL, CONFIG_TYPE_UNKNOWN, NULL}};",
          "2181: mg_static_assert((sizeof(config_options) / sizeof(config_options[0]))",
          "2182:                      == (NUM_OPTIONS + 1),",
          "2183:                  \"config_options and enum not sync\");",
          "2186: enum { REQUEST_HANDLER, WEBSOCKET_HANDLER, AUTH_HANDLER };",
          "2189: struct mg_handler_info {",
          "2191:  char *uri;",
          "2192:  size_t uri_len;",
          "2195:  int handler_type;",
          "2198:  mg_request_handler handler;",
          "2201:  mg_websocket_connect_handler connect_handler;",
          "2202:  mg_websocket_ready_handler ready_handler;",
          "2203:  mg_websocket_data_handler data_handler;",
          "2204:  mg_websocket_close_handler close_handler;",
          "2207:  struct mg_websocket_subprotocols *subprotocols;",
          "2210:  mg_authorization_handler auth_handler;",
          "2213:  void *cbdata;",
          "2216:  struct mg_handler_info *next;",
          "2217: };",
          "2220: struct mg_context {",
          "2226:  int context_type;              /* 1 = server context,",
          "2230:  struct socket *listening_sockets;",
          "2231:  struct pollfd *listening_socket_fds;",
          "2232:  unsigned int num_listening_sockets;",
          "2237:  struct socket *client_socks;",
          "2238:  void **client_wait_events;",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "2231: #endif",
          "2255: #if defined(USE_LUA) && defined(USE_WEBSOCKET)",
          "2258: #endif",
          "2260: #if defined(USE_TIMERS)",
          "2262: #endif",
          "2264: #if defined(USE_LUA)",
          "2266: #endif",
          "2268: #if defined(USE_SERVER_STATS)",
          "2274: #endif",
          "2278: #if defined(USE_SERVER_STATS)",
          "2333: #if defined(USE_LUA) && defined(USE_WEBSOCKET)",
          "2335: #endif",
          "2349: #if defined(USE_WEBSOCKET)",
          "2351: #else",
          "2352: #define is_websocket_protocol(conn) (0)",
          "2353: #endif",
          "",
          "[Removed Lines]",
          "2236:   unsigned int",
          "2239:   struct mg_connection *",
          "2240:       worker_connections; /* The connection struct, pre-",
          "2243:   time_t start_time; /* Server start time, used for authentication",
          "2253:   struct mg_handler_info *handlers;",
          "2257:   struct mg_shared_lua_websocket_list *shared_lua_websockets;",
          "2261:   struct ttimers *timers;",
          "2265:   void *lua_background_state;",
          "2269:   int active_connections;",
          "2270:   int max_connections;",
          "2271:   int64_t total_connections;",
          "2272:   int64_t total_requests;",
          "2273:   struct mg_memory_stat ctx_memory;",
          "2275:  };",
          "2279:  static struct mg_memory_stat mg_common_memory = {0, 0, 0};",
          "2281:  static struct mg_memory_stat *get_memory_stat(struct mg_context * ctx)",
          "2282:  {",
          "2283:   if (ctx) {",
          "2284:    return &(ctx->ctx_memory);",
          "2285:   }",
          "2286:   return &mg_common_memory;",
          "2287:  }",
          "2288: #endif",
          "2291:  struct mg_connection {",
          "2292:   int connection_type; /* 0 none",
          "2297:   struct mg_request_info request_info;",
          "2298:   struct mg_response_info response_info;",
          "2300:   struct mg_context *ctx;",
          "2305:   time_t conn_birth_time;   /* Time (wall clock) when connection was",
          "2307:   struct timespec req_time; /* Time (since system start) when the request",
          "2312:   int is_chunked;           /* Transfer-Encoding is chunked: 0=no, 1=yes:",
          "2319:   int in_error_handler; /* 1 if in handler for user defined error",
          "2321:   int handled_requests; /* Number of requests handled by this connection",
          "2327:   int throttle;         /* Throttling, bytes/sec. <= 0 means no",
          "2331:   pthread_mutex_t mutex;       /* Used by mg_(un)lock_connection to ensure",
          "2338:  };",
          "2342:  struct de {",
          "2343:   struct mg_connection *conn;",
          "2344:   char *file_name;",
          "2345:   struct mg_file_stat file;",
          "2346:  };",
          "2350:  static int is_websocket_protocol(const struct mg_connection *conn);",
          "",
          "[Added Lines]",
          "2250:  unsigned int",
          "2253:  struct mg_connection *worker_connections; /* The connection struct, pre-",
          "2256:  time_t start_time; /* Server start time, used for authentication",
          "2266:  struct mg_handler_info *handlers;",
          "2270:  struct mg_shared_lua_websocket_list *shared_lua_websockets;",
          "2274:  struct ttimers *timers;",
          "2278:  void *lua_background_state;",
          "2282:  int active_connections;",
          "2283:  int max_connections;",
          "2284:  int64_t total_connections;",
          "2285:  int64_t total_requests;",
          "2286:  struct mg_memory_stat ctx_memory;",
          "2288: };",
          "2292: static struct mg_memory_stat mg_common_memory = {0, 0, 0};",
          "2294: static struct mg_memory_stat *",
          "2295: get_memory_stat(struct mg_context *ctx)",
          "2296: {",
          "2297:  if (ctx) {",
          "2298:   return &(ctx->ctx_memory);",
          "2299:  }",
          "2300:  return &mg_common_memory;",
          "2301: }",
          "2302: #endif",
          "2305: struct mg_connection {",
          "2306:  int connection_type; /* 0 none",
          "2311:  struct mg_request_info request_info;",
          "2312:  struct mg_response_info response_info;",
          "2314:  struct mg_context *ctx;",
          "2319:  time_t conn_birth_time;   /* Time (wall clock) when connection was",
          "2321:  struct timespec req_time; /* Time (since system start) when the request",
          "2326:  int is_chunked;           /* Transfer-Encoding is chunked: 0=no, 1=yes:",
          "2333:  int in_error_handler;      /* 1 if in handler for user defined error",
          "2335:  int handled_requests;      /* Number of requests handled by this connection",
          "2341:  int throttle;              /* Throttling, bytes/sec. <= 0 means no",
          "2345:  pthread_mutex_t mutex;       /* Used by mg_(un)lock_connection to ensure",
          "2352: };",
          "2356: struct de {",
          "2357:  struct mg_connection *conn;",
          "2358:  char *file_name;",
          "2359:  struct mg_file_stat file;",
          "2360: };",
          "2364: static int is_websocket_protocol(const struct mg_connection *conn);",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "2361: #pragma pack(push, 8)",
          "2368: #pragma pack(pop)",
          "2370: #elif defined(__linux__)",
          "",
          "[Removed Lines]",
          "2362:  typedef struct tagTHREADNAME_INFO {",
          "2367:  } THREADNAME_INFO;",
          "",
          "[Added Lines]",
          "2376: typedef struct tagTHREADNAME_INFO {",
          "2381: } THREADNAME_INFO;",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "2431: #if !defined(__linux__) && !defined(_WIN32) && defined(ALTERNATIVE_QUEUE)",
          "2458:  }",
          "2488: #endif",
          "2498: #if defined(_WIN32)",
          "2499: #if defined(_MSC_VER)",
          "2517: #elif defined(__MINGW32__)",
          "2519: #endif",
          "",
          "[Removed Lines]",
          "2433:  struct posix_event {",
          "2434:   pthread_mutex_t mutex;",
          "2435:   pthread_cond_t cond;",
          "2436:  };",
          "2439:  static void *event_create(void)",
          "2440:  {",
          "2441:   struct posix_event *ret = mg_malloc(sizeof(struct posix_event));",
          "2442:   if (ret == 0) {",
          "2444:    return 0;",
          "2445:   }",
          "2446:   if (0 != pthread_mutex_init(&(ret->mutex), NULL)) {",
          "2448:    mg_free(ret);",
          "2449:    return 0;",
          "2450:   }",
          "2451:   if (0 != pthread_cond_init(&(ret->cond), NULL)) {",
          "2453:    pthread_mutex_destroy(&(ret->mutex));",
          "2454:    mg_free(ret);",
          "2455:    return 0;",
          "2456:   }",
          "2457:   return (void *)ret;",
          "2461:  static int event_wait(void *eventhdl)",
          "2462:  {",
          "2463:   struct posix_event *ev = (struct posix_event *)eventhdl;",
          "2464:   pthread_mutex_lock(&(ev->mutex));",
          "2465:   pthread_cond_wait(&(ev->cond), &(ev->mutex));",
          "2466:   pthread_mutex_unlock(&(ev->mutex));",
          "2467:   return 1;",
          "2468:  }",
          "2471:  static int event_signal(void *eventhdl)",
          "2472:  {",
          "2473:   struct posix_event *ev = (struct posix_event *)eventhdl;",
          "2474:   pthread_mutex_lock(&(ev->mutex));",
          "2475:   pthread_cond_signal(&(ev->cond));",
          "2476:   pthread_mutex_unlock(&(ev->mutex));",
          "2477:   return 1;",
          "2478:  }",
          "2481:  static void event_destroy(void *eventhdl)",
          "2482:  {",
          "2483:   struct posix_event *ev = (struct posix_event *)eventhdl;",
          "2484:   pthread_cond_destroy(&(ev->cond));",
          "2485:   pthread_mutex_destroy(&(ev->mutex));",
          "2486:   mg_free(ev);",
          "2487:  }",
          "2491:  static void mg_set_thread_name(const char *name)",
          "2492:  {",
          "2495:   mg_snprintf(",
          "2496:       NULL, NULL, threadName, sizeof(threadName), \"civetweb-%s\", name);",
          "2501:   __try",
          "2502:   {",
          "2503:    THREADNAME_INFO info;",
          "2504:    info.dwType = 0x1000;",
          "2505:    info.szName = threadName;",
          "2506:    info.dwThreadID = ~0U;",
          "2507:    info.dwFlags = 0;",
          "2509:    RaiseException(0x406D1388,",
          "2510:                   0,",
          "2511:                   sizeof(info) / sizeof(ULONG_PTR),",
          "2512:                   (ULONG_PTR *)&info);",
          "2513:   }",
          "2514:   __except(EXCEPTION_EXECUTE_HANDLER)",
          "2515:   {",
          "2516:   }",
          "",
          "[Added Lines]",
          "2447: struct posix_event {",
          "2448:  pthread_mutex_t mutex;",
          "2449:  pthread_cond_t cond;",
          "2450: };",
          "2453: static void *",
          "2454: event_create(void)",
          "2455: {",
          "2456:  struct posix_event *ret = mg_malloc(sizeof(struct posix_event));",
          "2457:  if (ret == 0) {",
          "2459:   return 0;",
          "2460:  }",
          "2461:  if (0 != pthread_mutex_init(&(ret->mutex), NULL)) {",
          "2463:   mg_free(ret);",
          "2464:   return 0;",
          "2466:  if (0 != pthread_cond_init(&(ret->cond), NULL)) {",
          "2468:   pthread_mutex_destroy(&(ret->mutex));",
          "2469:   mg_free(ret);",
          "2470:   return 0;",
          "2471:  }",
          "2472:  return (void *)ret;",
          "2473: }",
          "2476: static int",
          "2477: event_wait(void *eventhdl)",
          "2478: {",
          "2479:  struct posix_event *ev = (struct posix_event *)eventhdl;",
          "2480:  pthread_mutex_lock(&(ev->mutex));",
          "2481:  pthread_cond_wait(&(ev->cond), &(ev->mutex));",
          "2482:  pthread_mutex_unlock(&(ev->mutex));",
          "2483:  return 1;",
          "2484: }",
          "2487: static int",
          "2488: event_signal(void *eventhdl)",
          "2489: {",
          "2490:  struct posix_event *ev = (struct posix_event *)eventhdl;",
          "2491:  pthread_mutex_lock(&(ev->mutex));",
          "2492:  pthread_cond_signal(&(ev->cond));",
          "2493:  pthread_mutex_unlock(&(ev->mutex));",
          "2494:  return 1;",
          "2495: }",
          "2498: static void",
          "2499: event_destroy(void *eventhdl)",
          "2500: {",
          "2501:  struct posix_event *ev = (struct posix_event *)eventhdl;",
          "2502:  pthread_cond_destroy(&(ev->cond));",
          "2503:  pthread_mutex_destroy(&(ev->mutex));",
          "2504:  mg_free(ev);",
          "2505: }",
          "2509: static void",
          "2510: mg_set_thread_name(const char *name)",
          "2511: {",
          "2514:  mg_snprintf(",
          "2515:      NULL, NULL, threadName, sizeof(threadName), \"civetweb-%s\", name);",
          "2520:  __try",
          "2521:  {",
          "2522:   THREADNAME_INFO info;",
          "2523:   info.dwType = 0x1000;",
          "2524:   info.szName = threadName;",
          "2525:   info.dwThreadID = ~0U;",
          "2526:   info.dwFlags = 0;",
          "2528:   RaiseException(0x406D1388,",
          "2529:                  0,",
          "2530:                  sizeof(info) / sizeof(ULONG_PTR),",
          "2531:                  (ULONG_PTR *)&info);",
          "2532:  }",
          "2533:  __except(EXCEPTION_EXECUTE_HANDLER)",
          "2534:  {",
          "2535:  }",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "2526:  (void)prctl(PR_SET_NAME, threadName, 0, 0, 0);",
          "2527: #endif",
          "2530: void",
          "2531: mg_set_thread_name(const char *threadName)",
          "",
          "[Removed Lines]",
          "2528:  }",
          "",
          "[Added Lines]",
          "2547: }",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "2537: #if defined(MG_LEGACY_INTERFACE)",
          "2551:  }",
          "2552: #endif",
          "",
          "[Removed Lines]",
          "2538:  const char **mg_get_valid_option_names(void)",
          "2539:  {",
          "2541:   static const char *",
          "2542:       data[2 * sizeof(config_options) / sizeof(config_options[0])] = {0};",
          "2543:   int i;",
          "2545:   for (i = 0; config_options[i].name != NULL; i++) {",
          "2546:    data[i * 2] = config_options[i].name;",
          "2547:    data[i * 2 + 1] = config_options[i].default_value;",
          "2548:   }",
          "2550:   return data;",
          "2555:  const struct mg_option *mg_get_valid_options(void)",
          "2556:  {",
          "2557:   return config_options;",
          "2558:  }",
          "",
          "[Added Lines]",
          "2557: const char **",
          "2558: mg_get_valid_option_names(void)",
          "2559: {",
          "2561:  static const char *",
          "2562:      data[2 * sizeof(config_options) / sizeof(config_options[0])] = {0};",
          "2563:  int i;",
          "2565:  for (i = 0; config_options[i].name != NULL; i++) {",
          "2566:   data[i * 2] = config_options[i].name;",
          "2567:   data[i * 2 + 1] = config_options[i].default_value;",
          "2570:  return data;",
          "2571: }",
          "2575: const struct mg_option *",
          "2576: mg_get_valid_options(void)",
          "2577: {",
          "2578:  return config_options;",
          "2579: }",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "2571: #define MG_FOPEN_MODE_APPEND (4)",
          "2582: #if defined(MG_USE_OPEN_FILE)",
          "2621:   }",
          "2625: #else",
          "2626:  (void)conn;",
          "",
          "[Removed Lines]",
          "2577:  static int open_file_in_memory(const struct mg_connection *conn,",
          "2578:                                 const char *path,",
          "2579:                                 struct mg_file *filep,",
          "2580:                                 int mode)",
          "2581:  {",
          "2584:   size_t size = 0;",
          "2585:   const char *buf = NULL;",
          "2586:   if (!conn) {",
          "2587:    return 0;",
          "2588:   }",
          "2590:   if ((mode != MG_FOPEN_MODE_NONE) && (mode != MG_FOPEN_MODE_READ)) {",
          "2591:    return 0;",
          "2592:   }",
          "2594:   if (conn->ctx->callbacks.open_file) {",
          "2595:    buf = conn->ctx->callbacks.open_file(conn, path, &size);",
          "2596:    if (buf != NULL) {",
          "2597:     if (filep == NULL) {",
          "2602:      return 1;",
          "2603:     }",
          "2608:     filep->access.membuf = buf;",
          "2609:     filep->access.fp = NULL;",
          "2612:     filep->stat.size = size;",
          "2616:     filep->stat.last_modified = time(NULL);",
          "2618:     filep->stat.is_directory = 0;",
          "2619:     filep->stat.is_gzipped = 0;",
          "2620:    }",
          "2623:   return (buf != NULL);",
          "",
          "[Added Lines]",
          "2598: static int",
          "2599: open_file_in_memory(const struct mg_connection *conn,",
          "2600:                     const char *path,",
          "2601:                     struct mg_file *filep,",
          "2602:                     int mode)",
          "2603: {",
          "2606:  size_t size = 0;",
          "2607:  const char *buf = NULL;",
          "2608:  if (!conn) {",
          "2609:   return 0;",
          "2610:  }",
          "2612:  if ((mode != MG_FOPEN_MODE_NONE) && (mode != MG_FOPEN_MODE_READ)) {",
          "2613:   return 0;",
          "2614:  }",
          "2616:  if (conn->ctx->callbacks.open_file) {",
          "2617:   buf = conn->ctx->callbacks.open_file(conn, path, &size);",
          "2618:   if (buf != NULL) {",
          "2619:    if (filep == NULL) {",
          "2624:     return 1;",
          "2625:    }",
          "2630:    filep->access.membuf = buf;",
          "2631:    filep->access.fp = NULL;",
          "2634:    filep->stat.size = size;",
          "2638:    filep->stat.last_modified = time(NULL);",
          "2640:    filep->stat.is_directory = 0;",
          "2641:    filep->stat.is_gzipped = 0;",
          "2643:  }",
          "2645:  return (buf != NULL);",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "2631:  return 0;",
          "2633: #endif",
          "2650:  }",
          "2688: #ifdef _WIN32",
          "2703:    }",
          "2704: #else",
          "2706:   switch (mode) {",
          "",
          "[Removed Lines]",
          "2634:  }",
          "2637:  static int is_file_in_memory(const struct mg_connection *conn,",
          "2638:                               const char *path)",
          "2639:  {",
          "2640:   return open_file_in_memory(conn, path, NULL, MG_FOPEN_MODE_NONE);",
          "2641:  }",
          "2644:  static int is_file_opened(const struct mg_file_access *fileacc)",
          "2645:  {",
          "2646:   if (!fileacc) {",
          "2647:    return 0;",
          "2648:   }",
          "2649:   return (fileacc->membuf != NULL) || (fileacc->fp != NULL);",
          "2653:  static int mg_stat(const struct mg_connection *conn,",
          "2654:                     const char *path,",
          "2655:                     struct mg_file_stat *filep);",
          "2664:  static int mg_fopen(const struct mg_connection *conn,",
          "2665:                      const char *path,",
          "2666:                      int mode,",
          "2667:                      struct mg_file *filep)",
          "2668:  {",
          "2669:   int found;",
          "2671:   if (!filep) {",
          "2672:    return 0;",
          "2673:   }",
          "2674:   filep->access.fp = NULL;",
          "2675:   filep->access.membuf = NULL;",
          "2677:   if (!is_file_in_memory(conn, path)) {",
          "2681:    found = mg_stat(conn, path, &(filep->stat));",
          "2683:    if ((mode == MG_FOPEN_MODE_READ) && (!found)) {",
          "2685:     return 0;",
          "2686:    }",
          "2689:    {",
          "2690:     wchar_t wbuf[PATH_MAX];",
          "2691:     path_to_unicode(conn, path, wbuf, ARRAY_SIZE(wbuf));",
          "2692:     switch (mode) {",
          "2693:     case MG_FOPEN_MODE_READ:",
          "2694:      filep->access.fp = _wfopen(wbuf, L\"rb\");",
          "2695:      break;",
          "2696:     case MG_FOPEN_MODE_WRITE:",
          "2697:      filep->access.fp = _wfopen(wbuf, L\"wb\");",
          "2698:      break;",
          "2699:     case MG_FOPEN_MODE_APPEND:",
          "2700:      filep->access.fp = _wfopen(wbuf, L\"ab\");",
          "2701:      break;",
          "2702:     }",
          "",
          "[Added Lines]",
          "2656: }",
          "2659: static int",
          "2660: is_file_in_memory(const struct mg_connection *conn, const char *path)",
          "2661: {",
          "2662:  return open_file_in_memory(conn, path, NULL, MG_FOPEN_MODE_NONE);",
          "2663: }",
          "2666: static int",
          "2667: is_file_opened(const struct mg_file_access *fileacc)",
          "2668: {",
          "2669:  if (!fileacc) {",
          "2670:   return 0;",
          "2672:  return (fileacc->membuf != NULL) || (fileacc->fp != NULL);",
          "2673: }",
          "2676: static int mg_stat(const struct mg_connection *conn,",
          "2677:                    const char *path,",
          "2678:                    struct mg_file_stat *filep);",
          "2687: static int",
          "2688: mg_fopen(const struct mg_connection *conn,",
          "2689:          const char *path,",
          "2690:          int mode,",
          "2691:          struct mg_file *filep)",
          "2692: {",
          "2693:  int found;",
          "2695:  if (!filep) {",
          "2696:   return 0;",
          "2697:  }",
          "2698:  filep->access.fp = NULL;",
          "2699:  filep->access.membuf = NULL;",
          "2701:  if (!is_file_in_memory(conn, path)) {",
          "2705:   found = mg_stat(conn, path, &(filep->stat));",
          "2707:   if ((mode == MG_FOPEN_MODE_READ) && (!found)) {",
          "2709:    return 0;",
          "2710:   }",
          "2713:   {",
          "2714:    wchar_t wbuf[PATH_MAX];",
          "2715:    path_to_unicode(conn, path, wbuf, ARRAY_SIZE(wbuf));",
          "2716:    switch (mode) {",
          "2717:    case MG_FOPEN_MODE_READ:",
          "2718:     filep->access.fp = _wfopen(wbuf, L\"rb\");",
          "2719:     break;",
          "2720:    case MG_FOPEN_MODE_WRITE:",
          "2721:     filep->access.fp = _wfopen(wbuf, L\"wb\");",
          "2722:     break;",
          "2723:    case MG_FOPEN_MODE_APPEND:",
          "2724:     filep->access.fp = _wfopen(wbuf, L\"ab\");",
          "2725:     break;",
          "2727:   }",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "2716:   }",
          "2718: #endif",
          "2736:   }",
          "2755:   }",
          "2757:  }",
          "2766:   }",
          "2768:  }",
          "2774:  }",
          "2788:  }",
          "2812:  }",
          "2830:    }",
          "2831:   }",
          "2834:  }",
          "2853:   }",
          "2855: #ifdef __clang__",
          "2856: #pragma clang diagnostic push",
          "",
          "[Removed Lines]",
          "2719:    if (!found) {",
          "2723:     found = mg_stat(conn, path, &(filep->stat));",
          "2724:     (void)found;",
          "2725:    }",
          "2728:    return (filep->access.fp != NULL);",
          "2730:   } else {",
          "2732:    if (open_file_in_memory(conn, path, filep, mode)) {",
          "2734:     return (filep->access.membuf != NULL);",
          "2735:    }",
          "2739:   return 0;",
          "2740:  }",
          "2744:  static int mg_fclose(struct mg_file_access * fileacc)",
          "2745:  {",
          "2746:   int ret = -1;",
          "2747:   if (fileacc != NULL) {",
          "2748:    if (fileacc->fp != NULL) {",
          "2749:     ret = fclose(fileacc->fp);",
          "2750:    } else if (fileacc->membuf != NULL) {",
          "2751:     ret = 0;",
          "2752:    }",
          "2754:    memset(fileacc, 0, sizeof(*fileacc));",
          "2756:   return ret;",
          "2760:  static void mg_strlcpy(register char *dst,",
          "2761:                         register const char *src,",
          "2762:                         size_t n)",
          "2763:  {",
          "2764:   for (; *src != '\\0' && n > 1; n--) {",
          "2771:  static int lowercase(const char *s)",
          "2772:  {",
          "2773:   return tolower(*(const unsigned char *)s);",
          "2777:  int mg_strncasecmp(const char *s1, const char *s2, size_t len)",
          "2778:  {",
          "2779:   int diff = 0;",
          "2781:   if (len > 0) {",
          "2782:    do {",
          "2783:     diff = lowercase(s1++) - lowercase(s2++);",
          "2784:    } while (diff == 0 && s1[-1] != '\\0' && --len > 0);",
          "2785:   }",
          "2787:   return diff;",
          "2791:  int mg_strcasecmp(const char *s1, const char *s2)",
          "2792:  {",
          "2793:   int diff;",
          "2795:   do {",
          "2796:    diff = lowercase(s1++) - lowercase(s2++);",
          "2797:   } while (diff == 0 && s1[-1] != '\\0');",
          "2799:   return diff;",
          "2800:  }",
          "2803:  static char *mg_strndup(const char *ptr, size_t len)",
          "2804:  {",
          "2805:   char *p;",
          "2807:   if ((p = (char *)mg_malloc(len + 1)) != NULL) {",
          "2808:    mg_strlcpy(p, ptr, len + 1);",
          "2809:   }",
          "2811:   return p;",
          "2815:  static char *mg_strdup(const char *str)",
          "2816:  {",
          "2817:   return mg_strndup(str, strlen(str));",
          "2818:  }",
          "2821:  static const char *mg_strcasestr(const char *big_str, const char *small_str)",
          "2822:  {",
          "2823:   size_t i, big_len = strlen(big_str), small_len = strlen(small_str);",
          "2825:   if (big_len >= small_len) {",
          "2826:    for (i = 0; i <= (big_len - small_len); i++) {",
          "2827:     if (mg_strncasecmp(big_str + i, small_str, small_len) == 0) {",
          "2828:      return big_str + i;",
          "2829:     }",
          "2833:   return NULL;",
          "2839:  static void mg_vsnprintf(const struct mg_connection *conn,",
          "2840:                           int *truncated,",
          "2841:                           char *buf,",
          "2842:                           size_t buflen,",
          "2843:                           const char *fmt,",
          "2844:                           va_list ap)",
          "2845:  {",
          "2846:   int n, ok;",
          "2848:   if (buflen == 0) {",
          "2849:    if (truncated) {",
          "2851:    }",
          "2852:    return;",
          "",
          "[Added Lines]",
          "2743:   if (!found) {",
          "2747:    found = mg_stat(conn, path, &(filep->stat));",
          "2748:    (void)found;",
          "2752:   return (filep->access.fp != NULL);",
          "2754:  } else {",
          "2756:   if (open_file_in_memory(conn, path, filep, mode)) {",
          "2758:    return (filep->access.membuf != NULL);",
          "2763:  return 0;",
          "2764: }",
          "2768: static int",
          "2769: mg_fclose(struct mg_file_access *fileacc)",
          "2770: {",
          "2771:  int ret = -1;",
          "2772:  if (fileacc != NULL) {",
          "2773:   if (fileacc->fp != NULL) {",
          "2774:    ret = fclose(fileacc->fp);",
          "2775:   } else if (fileacc->membuf != NULL) {",
          "2776:    ret = 0;",
          "2779:   memset(fileacc, 0, sizeof(*fileacc));",
          "2781:  return ret;",
          "2782: }",
          "2785: static void",
          "2786: mg_strlcpy(register char *dst, register const char *src, size_t n)",
          "2787: {",
          "2788:  for (; *src != '\\0' && n > 1; n--) {",
          "2792: }",
          "2795: static int",
          "2796: lowercase(const char *s)",
          "2797: {",
          "2798:  return tolower(*(const unsigned char *)s);",
          "2799: }",
          "2802: int",
          "2803: mg_strncasecmp(const char *s1, const char *s2, size_t len)",
          "2804: {",
          "2805:  int diff = 0;",
          "2807:  if (len > 0) {",
          "2808:   do {",
          "2809:    diff = lowercase(s1++) - lowercase(s2++);",
          "2810:   } while (diff == 0 && s1[-1] != '\\0' && --len > 0);",
          "2813:  return diff;",
          "2814: }",
          "2817: int",
          "2818: mg_strcasecmp(const char *s1, const char *s2)",
          "2819: {",
          "2820:  int diff;",
          "2822:  do {",
          "2823:   diff = lowercase(s1++) - lowercase(s2++);",
          "2824:  } while (diff == 0 && s1[-1] != '\\0');",
          "2826:  return diff;",
          "2827: }",
          "2830: static char *",
          "2831: mg_strndup(const char *ptr, size_t len)",
          "2832: {",
          "2833:  char *p;",
          "2835:  if ((p = (char *)mg_malloc(len + 1)) != NULL) {",
          "2836:   mg_strlcpy(p, ptr, len + 1);",
          "2839:  return p;",
          "2840: }",
          "2843: static char *",
          "2844: mg_strdup(const char *str)",
          "2845: {",
          "2846:  return mg_strndup(str, strlen(str));",
          "2847: }",
          "2850: static const char *",
          "2851: mg_strcasestr(const char *big_str, const char *small_str)",
          "2852: {",
          "2853:  size_t i, big_len = strlen(big_str), small_len = strlen(small_str);",
          "2855:  if (big_len >= small_len) {",
          "2856:   for (i = 0; i <= (big_len - small_len); i++) {",
          "2857:    if (mg_strncasecmp(big_str + i, small_str, small_len) == 0) {",
          "2858:     return big_str + i;",
          "2863:  return NULL;",
          "2864: }",
          "2869: static void",
          "2870: mg_vsnprintf(const struct mg_connection *conn,",
          "2871:              int *truncated,",
          "2872:              char *buf,",
          "2873:              size_t buflen,",
          "2874:              const char *fmt,",
          "2875:              va_list ap)",
          "2876: {",
          "2877:  int n, ok;",
          "2879:  if (buflen == 0) {",
          "2880:   if (truncated) {",
          "2883:   return;",
          "2884:  }",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "2860: #endif",
          "2865: #ifdef __clang__",
          "2866: #pragma clang diagnostic pop",
          "2867: #endif",
          "2882:   }",
          "2884:  }",
          "2910:   }",
          "2912:  }",
          "2925:  }",
          "2945:  }",
          "2954:  }",
          "2957: #if defined(MG_LEGACY_INTERFACE)",
          "2971: #if defined(USE_IPV6)",
          "2975: #endif",
          "2979:  }",
          "2980: #endif",
          "3003: #if defined(USE_IPV6)",
          "3024:  }",
          "3055:  }",
          "3071:  }",
          "3080:  }",
          "3115:     fi.access.fp = NULL;",
          "3116:    }",
          "3145:    }",
          "3146:   }",
          "3147:  }",
          "3192:  }",
          "3205:  }",
          "3219: #ifdef __clang__",
          "3220: #pragma clang diagnostic push",
          "",
          "[Removed Lines]",
          "2862:   n = (int)vsnprintf_impl(buf, buflen, fmt, ap);",
          "2863:   ok = (n >= 0) && ((size_t)n < buflen);",
          "2869:   if (ok) {",
          "2870:    if (truncated) {",
          "2872:    }",
          "2873:   } else {",
          "2874:    if (truncated) {",
          "2876:    }",
          "2877:    mg_cry(conn,",
          "2878:           \"truncating vsnprintf buffer: [%.*s]\",",
          "2879:           (int)((buflen > 200) ? 200 : (buflen - 1)),",
          "2880:           buf);",
          "2881:    n = (int)buflen - 1;",
          "2883:   buf[n] = '\\0';",
          "2887:  static void mg_snprintf(const struct mg_connection *conn,",
          "2888:                          int *truncated,",
          "2889:                          char *buf,",
          "2890:                          size_t buflen,",
          "2891:                          const char *fmt,",
          "2892:                          ...)",
          "2893:  {",
          "2894:   va_list ap;",
          "2896:   va_start(ap, fmt);",
          "2897:   mg_vsnprintf(conn, truncated, buf, buflen, fmt, ap);",
          "2898:   va_end(ap);",
          "2899:  }",
          "2902:  static int get_option_index(const char *name)",
          "2903:  {",
          "2904:   int i;",
          "2906:   for (i = 0; config_options[i].name != NULL; i++) {",
          "2907:    if (strcmp(config_options[i].name, name) == 0) {",
          "2908:     return i;",
          "2909:    }",
          "2911:   return -1;",
          "2915:  const char *mg_get_option(const struct mg_context *ctx, const char *name)",
          "2916:  {",
          "2917:   int i;",
          "2918:   if ((i = get_option_index(name)) == -1) {",
          "2919:    return NULL;",
          "2920:   } else if (!ctx || ctx->config[i] == NULL) {",
          "2921:    return \"\";",
          "2922:   } else {",
          "2923:    return ctx->config[i];",
          "2924:   }",
          "2928:  struct mg_context *mg_get_context(const struct mg_connection *conn)",
          "2929:  {",
          "2930:   return (conn == NULL) ? (struct mg_context *)NULL : (conn->ctx);",
          "2931:  }",
          "2934:  void *mg_get_user_data(const struct mg_context *ctx)",
          "2935:  {",
          "2936:   return (ctx == NULL) ? NULL : ctx->user_data;",
          "2937:  }",
          "2940:  void mg_set_user_connection_data(struct mg_connection * conn, void *data)",
          "2941:  {",
          "2942:   if (conn != NULL) {",
          "2943:    conn->request_info.conn_data = data;",
          "2944:   }",
          "2948:  void *mg_get_user_connection_data(const struct mg_connection *conn)",
          "2949:  {",
          "2950:   if (conn != NULL) {",
          "2951:    return conn->request_info.conn_data;",
          "2952:   }",
          "2953:   return NULL;",
          "2959:  size_t mg_get_ports(const struct mg_context *ctx,",
          "2960:                      size_t size,",
          "2961:                      int *ports,",
          "2962:                      int *ssl)",
          "2963:  {",
          "2964:   size_t i;",
          "2965:   if (!ctx) {",
          "2966:    return 0;",
          "2967:   }",
          "2968:   for (i = 0; i < size && i < ctx->num_listening_sockets; i++) {",
          "2969:    ssl[i] = ctx->listening_sockets[i].is_ssl;",
          "2970:    ports[i] =",
          "2972:        (ctx->listening_sockets[i].lsa.sa.sa_family == AF_INET6)",
          "2973:            ? ntohs(ctx->listening_sockets[i].lsa.sin6.sin6_port)",
          "2974:            :",
          "2976:            ntohs(ctx->listening_sockets[i].lsa.sin.sin_port);",
          "2977:   }",
          "2978:   return i;",
          "2983:  int mg_get_server_ports(const struct mg_context *ctx,",
          "2984:                          int size,",
          "2985:                          struct mg_server_ports *ports)",
          "2986:  {",
          "2987:   int i, cnt = 0;",
          "2989:   if (size <= 0) {",
          "2990:    return -1;",
          "2991:   }",
          "2992:   memset(ports, 0, sizeof(*ports) * (size_t)size);",
          "2993:   if (!ctx) {",
          "2994:    return -1;",
          "2995:   }",
          "2996:   if (!ctx->listening_sockets) {",
          "2997:    return -1;",
          "2998:   }",
          "3000:   for (i = 0; (i < size) && (i < (int)ctx->num_listening_sockets); i++) {",
          "3002:    ports[cnt].port =",
          "3004:        (ctx->listening_sockets[i].lsa.sa.sa_family == AF_INET6)",
          "3005:            ? ntohs(ctx->listening_sockets[i].lsa.sin6.sin6_port)",
          "3006:            :",
          "3007: #endif",
          "3008:            ntohs(ctx->listening_sockets[i].lsa.sin.sin_port);",
          "3009:    ports[cnt].is_ssl = ctx->listening_sockets[i].is_ssl;",
          "3010:    ports[cnt].is_redirect = ctx->listening_sockets[i].ssl_redir;",
          "3012:    if (ctx->listening_sockets[i].lsa.sa.sa_family == AF_INET) {",
          "3014:     ports[cnt].protocol = 1;",
          "3015:     cnt++;",
          "3016:    } else if (ctx->listening_sockets[i].lsa.sa.sa_family == AF_INET6) {",
          "3018:     ports[cnt].protocol = 3;",
          "3019:     cnt++;",
          "3020:    }",
          "3021:   }",
          "3023:   return cnt;",
          "3027:  static void sockaddr_to_string(char *buf, size_t len, const union usa *usa)",
          "3028:  {",
          "3029:   buf[0] = '\\0';",
          "3031:   if (!usa) {",
          "3032:    return;",
          "3033:   }",
          "3035:   if (usa->sa.sa_family == AF_INET) {",
          "3036:    getnameinfo(&usa->sa,",
          "3037:                sizeof(usa->sin),",
          "3038:                buf,",
          "3039:                (unsigned)len,",
          "3040:                NULL,",
          "3041:                0,",
          "3042:                NI_NUMERICHOST);",
          "3043:   }",
          "3044: #if defined(USE_IPV6)",
          "3045:   else if (usa->sa.sa_family == AF_INET6) {",
          "3046:    getnameinfo(&usa->sa,",
          "3047:                sizeof(usa->sin6),",
          "3048:                buf,",
          "3049:                (unsigned)len,",
          "3050:                NULL,",
          "3051:                0,",
          "3052:                NI_NUMERICHOST);",
          "3053:   }",
          "3054: #endif",
          "3060:  static void gmt_time_string(char *buf, size_t buf_len, time_t *t)",
          "3061:  {",
          "3062:   struct tm *tm;",
          "3064:   tm = ((t != NULL) ? gmtime(t) : NULL);",
          "3065:   if (tm != NULL) {",
          "3066:    strftime(buf, buf_len, \"%a, %d %b %Y %H:%M:%S GMT\", tm);",
          "3067:   } else {",
          "3068:    mg_strlcpy(buf, \"Thu, 01 Jan 1970 00:00:00 GMT\", buf_len);",
          "3069:    buf[buf_len - 1] = '\\0';",
          "3070:   }",
          "3075:  static double mg_difftimespec(const struct timespec *ts_now,",
          "3076:                                const struct timespec *ts_before)",
          "3077:  {",
          "3078:   return (double)(ts_now->tv_nsec - ts_before->tv_nsec) * 1.0E-9",
          "3079:          + (double)(ts_now->tv_sec - ts_before->tv_sec);",
          "3084:  void mg_cry(const struct mg_connection *conn, const char *fmt, ...)",
          "3085:  {",
          "3086:   char buf[MG_BUF_LEN], src_addr[IP_ADDR_STR_LEN];",
          "3087:   va_list ap;",
          "3088:   struct mg_file fi;",
          "3089:   time_t timestamp;",
          "3091:   va_start(ap, fmt);",
          "3092:   IGNORE_UNUSED_RESULT(vsnprintf_impl(buf, sizeof(buf), fmt, ap));",
          "3093:   va_end(ap);",
          "3094:   buf[sizeof(buf) - 1] = 0;",
          "3096:   if (!conn) {",
          "3097:    puts(buf);",
          "3098:    return;",
          "3099:   }",
          "3104:   if ((conn->ctx->callbacks.log_message == NULL)",
          "3105:       || (conn->ctx->callbacks.log_message(conn, buf) == 0)) {",
          "3107:    if (conn->ctx->config[ERROR_LOG_FILE] != NULL) {",
          "3108:     if (mg_fopen(conn,",
          "3109:                  conn->ctx->config[ERROR_LOG_FILE],",
          "3110:                  MG_FOPEN_MODE_APPEND,",
          "3111:                  &fi) == 0) {",
          "3112:      fi.access.fp = NULL;",
          "3113:     }",
          "3114:    } else {",
          "3118:    if (fi.access.fp != NULL) {",
          "3119:     flockfile(fi.access.fp);",
          "3120:     timestamp = time(NULL);",
          "3122:     sockaddr_to_string(src_addr,",
          "3123:                        sizeof(src_addr),",
          "3124:                        &conn->client.rsa);",
          "3125:     fprintf(fi.access.fp,",
          "3126:             \"[%010lu] [error] [client %s] \",",
          "3127:             (unsigned long)timestamp,",
          "3128:             src_addr);",
          "3130:     if (conn->request_info.request_method != NULL) {",
          "3131:      fprintf(fi.access.fp,",
          "3132:              \"%s %s: \",",
          "3133:              conn->request_info.request_method,",
          "3134:              conn->request_info.request_uri",
          "3135:                  ? conn->request_info.request_uri",
          "3136:                  : \"\");",
          "3137:     }",
          "3139:     fprintf(fi.access.fp, \"%s\", buf);",
          "3140:     fputc('\\n', fi.access.fp);",
          "3141:     fflush(fi.access.fp);",
          "3142:     funlockfile(fi.access.fp);",
          "3143:     (void)mg_fclose(&fi.access); /* Ignore errors. We can't call",
          "3152:  static struct mg_connection *fc(struct mg_context * ctx)",
          "3153:  {",
          "3154:   static struct mg_connection fake_connection;",
          "3155:   fake_connection.ctx = ctx;",
          "3156:   return &fake_connection;",
          "3157:  }",
          "3160:  const char *mg_version(void)",
          "3161:  {",
          "3162:   return CIVETWEB_VERSION;",
          "3163:  }",
          "3166:  const struct mg_request_info *mg_get_request_info(",
          "3167:      const struct mg_connection *conn)",
          "3168:  {",
          "3169:   if (!conn) {",
          "3170:    return NULL;",
          "3171:   }",
          "3173:   if (conn->connection_type == 2) {",
          "3174:    static char txt[16];",
          "3175:    sprintf(txt, \"%03i\", conn->response_info.status_code);",
          "3177:    ((struct mg_connection *)conn)->request_info.local_uri =",
          "3178:        ((struct mg_connection *)conn)->request_info.request_uri =",
          "3181:    ((struct mg_connection *)conn)->request_info.num_headers =",
          "3182:        conn->response_info.num_headers;",
          "3183:    memcpy(((struct mg_connection *)conn)->request_info.http_headers,",
          "3184:           conn->response_info.http_headers,",
          "3185:           sizeof(conn->response_info.http_headers));",
          "3186:   } else",
          "3187: #endif",
          "3188:       if (conn->connection_type != 1) {",
          "3189:    return NULL;",
          "3190:   }",
          "3191:   return &conn->request_info;",
          "3195:  const struct mg_response_info *mg_get_response_info(",
          "3196:      const struct mg_connection *conn)",
          "3197:  {",
          "3198:   if (!conn) {",
          "3199:    return NULL;",
          "3200:   }",
          "3201:   if (conn->connection_type != 2) {",
          "3202:    return NULL;",
          "3203:   }",
          "3204:   return &conn->response_info;",
          "3208:  int mg_get_request_link(const struct mg_connection *conn,",
          "3209:                          char *buf,",
          "3210:                          size_t buflen)",
          "3211:  {",
          "3212:   if ((buflen < 1) || (buf == 0) || (conn == 0)) {",
          "3213:    return -1;",
          "3214:   } else {",
          "3216:    int truncated = 0;",
          "3217:    const struct mg_request_info *ri = &conn->request_info;",
          "",
          "[Added Lines]",
          "2893:  n = (int)vsnprintf_impl(buf, buflen, fmt, ap);",
          "2894:  ok = (n >= 0) && ((size_t)n < buflen);",
          "2900:  if (ok) {",
          "2901:   if (truncated) {",
          "2903:   }",
          "2904:  } else {",
          "2905:   if (truncated) {",
          "2908:   mg_cry(conn,",
          "2909:          \"truncating vsnprintf buffer: [%.*s]\",",
          "2910:          (int)((buflen > 200) ? 200 : (buflen - 1)),",
          "2911:          buf);",
          "2912:   n = (int)buflen - 1;",
          "2914:  buf[n] = '\\0';",
          "2915: }",
          "2918: static void",
          "2919: mg_snprintf(const struct mg_connection *conn,",
          "2920:             int *truncated,",
          "2921:             char *buf,",
          "2922:             size_t buflen,",
          "2923:             const char *fmt,",
          "2924:             ...)",
          "2925: {",
          "2926:  va_list ap;",
          "2928:  va_start(ap, fmt);",
          "2929:  mg_vsnprintf(conn, truncated, buf, buflen, fmt, ap);",
          "2930:  va_end(ap);",
          "2931: }",
          "2934: static int",
          "2935: get_option_index(const char *name)",
          "2936: {",
          "2937:  int i;",
          "2939:  for (i = 0; config_options[i].name != NULL; i++) {",
          "2940:   if (strcmp(config_options[i].name, name) == 0) {",
          "2941:    return i;",
          "2944:  return -1;",
          "2945: }",
          "2948: const char *",
          "2949: mg_get_option(const struct mg_context *ctx, const char *name)",
          "2950: {",
          "2951:  int i;",
          "2952:  if ((i = get_option_index(name)) == -1) {",
          "2953:   return NULL;",
          "2954:  } else if (!ctx || ctx->config[i] == NULL) {",
          "2955:   return \"\";",
          "2956:  } else {",
          "2957:   return ctx->config[i];",
          "2959: }",
          "2962: struct mg_context *",
          "2963: mg_get_context(const struct mg_connection *conn)",
          "2964: {",
          "2965:  return (conn == NULL) ? (struct mg_context *)NULL : (conn->ctx);",
          "2966: }",
          "2969: void *",
          "2970: mg_get_user_data(const struct mg_context *ctx)",
          "2971: {",
          "2972:  return (ctx == NULL) ? NULL : ctx->user_data;",
          "2973: }",
          "2976: void",
          "2977: mg_set_user_connection_data(struct mg_connection *conn, void *data)",
          "2978: {",
          "2979:  if (conn != NULL) {",
          "2980:   conn->request_info.conn_data = data;",
          "2982: }",
          "2985: void *",
          "2986: mg_get_user_connection_data(const struct mg_connection *conn)",
          "2987: {",
          "2988:  if (conn != NULL) {",
          "2989:   return conn->request_info.conn_data;",
          "2991:  return NULL;",
          "2992: }",
          "2997: size_t",
          "2998: mg_get_ports(const struct mg_context *ctx, size_t size, int *ports, int *ssl)",
          "2999: {",
          "3000:  size_t i;",
          "3001:  if (!ctx) {",
          "3002:   return 0;",
          "3003:  }",
          "3004:  for (i = 0; i < size && i < ctx->num_listening_sockets; i++) {",
          "3005:   ssl[i] = ctx->listening_sockets[i].is_ssl;",
          "3006:   ports[i] =",
          "3008:       (ctx->listening_sockets[i].lsa.sa.sa_family == AF_INET6)",
          "3009:           ? ntohs(ctx->listening_sockets[i].lsa.sin6.sin6_port)",
          "3010:           :",
          "3012:           ntohs(ctx->listening_sockets[i].lsa.sin.sin_port);",
          "3014:  return i;",
          "3015: }",
          "3019: int",
          "3020: mg_get_server_ports(const struct mg_context *ctx,",
          "3021:                     int size,",
          "3022:                     struct mg_server_ports *ports)",
          "3023: {",
          "3024:  int i, cnt = 0;",
          "3026:  if (size <= 0) {",
          "3027:   return -1;",
          "3028:  }",
          "3029:  memset(ports, 0, sizeof(*ports) * (size_t)size);",
          "3030:  if (!ctx) {",
          "3031:   return -1;",
          "3032:  }",
          "3033:  if (!ctx->listening_sockets) {",
          "3034:   return -1;",
          "3035:  }",
          "3037:  for (i = 0; (i < size) && (i < (int)ctx->num_listening_sockets); i++) {",
          "3039:   ports[cnt].port =",
          "3041:       (ctx->listening_sockets[i].lsa.sa.sa_family == AF_INET6)",
          "3042:           ? ntohs(ctx->listening_sockets[i].lsa.sin6.sin6_port)",
          "3043:           :",
          "3044: #endif",
          "3045:           ntohs(ctx->listening_sockets[i].lsa.sin.sin_port);",
          "3046:   ports[cnt].is_ssl = ctx->listening_sockets[i].is_ssl;",
          "3047:   ports[cnt].is_redirect = ctx->listening_sockets[i].ssl_redir;",
          "3049:   if (ctx->listening_sockets[i].lsa.sa.sa_family == AF_INET) {",
          "3051:    ports[cnt].protocol = 1;",
          "3052:    cnt++;",
          "3053:   } else if (ctx->listening_sockets[i].lsa.sa.sa_family == AF_INET6) {",
          "3055:    ports[cnt].protocol = 3;",
          "3056:    cnt++;",
          "3057:   }",
          "3060:  return cnt;",
          "3061: }",
          "3064: static void",
          "3065: sockaddr_to_string(char *buf, size_t len, const union usa *usa)",
          "3066: {",
          "3067:  buf[0] = '\\0';",
          "3069:  if (!usa) {",
          "3070:   return;",
          "3073:  if (usa->sa.sa_family == AF_INET) {",
          "3074:   getnameinfo(&usa->sa,",
          "3075:               sizeof(usa->sin),",
          "3076:               buf,",
          "3077:               (unsigned)len,",
          "3078:               NULL,",
          "3079:               0,",
          "3080:               NI_NUMERICHOST);",
          "3081:  }",
          "3082: #if defined(USE_IPV6)",
          "3083:  else if (usa->sa.sa_family == AF_INET6) {",
          "3084:   getnameinfo(&usa->sa,",
          "3085:               sizeof(usa->sin6),",
          "3086:               buf,",
          "3087:               (unsigned)len,",
          "3088:               NULL,",
          "3089:               0,",
          "3090:               NI_NUMERICHOST);",
          "3092: #endif",
          "3093: }",
          "3098: static void",
          "3099: gmt_time_string(char *buf, size_t buf_len, time_t *t)",
          "3100: {",
          "3101:  struct tm *tm;",
          "3103:  tm = ((t != NULL) ? gmtime(t) : NULL);",
          "3104:  if (tm != NULL) {",
          "3105:   strftime(buf, buf_len, \"%a, %d %b %Y %H:%M:%S GMT\", tm);",
          "3106:  } else {",
          "3107:   mg_strlcpy(buf, \"Thu, 01 Jan 1970 00:00:00 GMT\", buf_len);",
          "3108:   buf[buf_len - 1] = '\\0';",
          "3110: }",
          "3114: static double",
          "3115: mg_difftimespec(const struct timespec *ts_now, const struct timespec *ts_before)",
          "3116: {",
          "3117:  return (double)(ts_now->tv_nsec - ts_before->tv_nsec) * 1.0E-9",
          "3118:         + (double)(ts_now->tv_sec - ts_before->tv_sec);",
          "3119: }",
          "3123: void",
          "3124: mg_cry(const struct mg_connection *conn, const char *fmt, ...)",
          "3125: {",
          "3126:  char buf[MG_BUF_LEN], src_addr[IP_ADDR_STR_LEN];",
          "3127:  va_list ap;",
          "3128:  struct mg_file fi;",
          "3129:  time_t timestamp;",
          "3131:  va_start(ap, fmt);",
          "3132:  IGNORE_UNUSED_RESULT(vsnprintf_impl(buf, sizeof(buf), fmt, ap));",
          "3133:  va_end(ap);",
          "3134:  buf[sizeof(buf) - 1] = 0;",
          "3136:  if (!conn) {",
          "3137:   puts(buf);",
          "3138:   return;",
          "3139:  }",
          "3144:  if ((conn->ctx->callbacks.log_message == NULL)",
          "3145:      || (conn->ctx->callbacks.log_message(conn, buf) == 0)) {",
          "3147:   if (conn->ctx->config[ERROR_LOG_FILE] != NULL) {",
          "3148:    if (mg_fopen(conn,",
          "3149:                 conn->ctx->config[ERROR_LOG_FILE],",
          "3150:                 MG_FOPEN_MODE_APPEND,",
          "3151:                 &fi) == 0) {",
          "3154:   } else {",
          "3155:    fi.access.fp = NULL;",
          "3156:   }",
          "3158:   if (fi.access.fp != NULL) {",
          "3159:    flockfile(fi.access.fp);",
          "3160:    timestamp = time(NULL);",
          "3162:    sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);",
          "3163:    fprintf(fi.access.fp,",
          "3164:            \"[%010lu] [error] [client %s] \",",
          "3165:            (unsigned long)timestamp,",
          "3166:            src_addr);",
          "3168:    if (conn->request_info.request_method != NULL) {",
          "3169:     fprintf(fi.access.fp,",
          "3170:             \"%s %s: \",",
          "3171:             conn->request_info.request_method,",
          "3172:             conn->request_info.request_uri",
          "3173:                 ? conn->request_info.request_uri",
          "3174:                 : \"\");",
          "3177:    fprintf(fi.access.fp, \"%s\", buf);",
          "3178:    fputc('\\n', fi.access.fp);",
          "3179:    fflush(fi.access.fp);",
          "3180:    funlockfile(fi.access.fp);",
          "3181:    (void)mg_fclose(&fi.access); /* Ignore errors. We can't call",
          "3185: }",
          "3190: static struct mg_connection *",
          "3191: fc(struct mg_context *ctx)",
          "3192: {",
          "3193:  static struct mg_connection fake_connection;",
          "3194:  fake_connection.ctx = ctx;",
          "3195:  return &fake_connection;",
          "3196: }",
          "3199: const char *",
          "3200: mg_version(void)",
          "3201: {",
          "3202:  return CIVETWEB_VERSION;",
          "3203: }",
          "3206: const struct mg_request_info *",
          "3207: mg_get_request_info(const struct mg_connection *conn)",
          "3208: {",
          "3209:  if (!conn) {",
          "3210:   return NULL;",
          "3211:  }",
          "3213:  if (conn->connection_type == 2) {",
          "3214:   static char txt[16];",
          "3215:   sprintf(txt, \"%03i\", conn->response_info.status_code);",
          "3217:   ((struct mg_connection *)conn)->request_info.local_uri =",
          "3218:       ((struct mg_connection *)conn)->request_info.request_uri =",
          "3221:   ((struct mg_connection *)conn)->request_info.num_headers =",
          "3222:       conn->response_info.num_headers;",
          "3223:   memcpy(((struct mg_connection *)conn)->request_info.http_headers,",
          "3224:          conn->response_info.http_headers,",
          "3225:          sizeof(conn->response_info.http_headers));",
          "3226:  } else",
          "3227: #endif",
          "3228:      if (conn->connection_type != 1) {",
          "3229:   return NULL;",
          "3231:  return &conn->request_info;",
          "3232: }",
          "3235: const struct mg_response_info *",
          "3236: mg_get_response_info(const struct mg_connection *conn)",
          "3237: {",
          "3238:  if (!conn) {",
          "3239:   return NULL;",
          "3240:  }",
          "3241:  if (conn->connection_type != 2) {",
          "3242:   return NULL;",
          "3244:  return &conn->response_info;",
          "3245: }",
          "3248: int",
          "3249: mg_get_request_link(const struct mg_connection *conn, char *buf, size_t buflen)",
          "3250: {",
          "3251:  if ((buflen < 1) || (buf == 0) || (conn == 0)) {",
          "3252:   return -1;",
          "3253:  } else {",
          "3255:   int truncated = 0;",
          "3256:   const struct mg_request_info *ri = &conn->request_info;",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "3227: #endif",
          "3233: #ifdef __clang__",
          "3234: #pragma clang diagnostic pop",
          "3235: #endif",
          "3238:     return -1;",
          "3239:    }",
          "3256: #if defined(USE_IPV6)",
          "3260: #else",
          "3261:    int port = htons(conn->client.lsa.sin.sin_port);",
          "3262: #endif",
          "3302:    }",
          "3303:   }",
          "3304:  }",
          "3343:    }",
          "3344:   }",
          "3350: #if defined(__GNUC__) || defined(__MINGW32__)",
          "",
          "[Removed Lines]",
          "3229:    const char *proto =",
          "3230:        (is_websocket_protocol(conn) ? (ri->is_ssl ? \"wss\" : \"ws\")",
          "3231:                                     : (ri->is_ssl ? \"https\" : \"http\"));",
          "3237:    if (ri->local_uri == NULL) {",
          "3241:    if ((ri->request_uri != NULL)",
          "3242:        && strcmp(ri->local_uri, ri->request_uri)) {",
          "3243:     mg_snprintf(conn,",
          "3244:                 &truncated,",
          "3245:                 buf,",
          "3246:                 buflen,",
          "3247:                 \"%s://%s\",",
          "3248:                 proto,",
          "3249:                 ri->request_uri);",
          "3250:     if (truncated) {",
          "3251:      return -1;",
          "3252:     }",
          "3253:     return 0;",
          "3254:    } else {",
          "3257:     int is_ipv6 = (conn->client.lsa.sa.sa_family == AF_INET6);",
          "3258:     int port = is_ipv6 ? htons(conn->client.lsa.sin6.sin6_port)",
          "3259:                        : htons(conn->client.lsa.sin.sin_port);",
          "3263:     int def_port = ri->is_ssl ? 443 : 80;",
          "3264:     int auth_domain_check_enabled =",
          "3265:         conn->ctx->config[ENABLE_AUTH_DOMAIN_CHECK]",
          "3266:         && (!strcmp(conn->ctx->config[ENABLE_AUTH_DOMAIN_CHECK],",
          "3267:                     \"yes\"));",
          "3268:     const char *server_domain =",
          "3269:         conn->ctx->config[AUTHENTICATION_DOMAIN];",
          "3271:     char portstr[16];",
          "3272:     char server_ip[48];",
          "3274:     if (port != def_port) {",
          "3275:      sprintf(portstr, \":%u\", (unsigned)port);",
          "3276:     } else {",
          "3277:      portstr[0] = 0;",
          "3278:     }",
          "3280:     if (!auth_domain_check_enabled || !server_domain) {",
          "3282:      sockaddr_to_string(server_ip,",
          "3283:                         sizeof(server_ip),",
          "3284:                         &conn->client.lsa);",
          "3286:      server_domain = server_ip;",
          "3287:     }",
          "3289:     mg_snprintf(conn,",
          "3290:                 &truncated,",
          "3291:                 buf,",
          "3292:                 buflen,",
          "3293:                 \"%s://%s%s%s\",",
          "3294:                 proto,",
          "3295:                 server_domain,",
          "3296:                 portstr,",
          "3297:                 ri->local_uri);",
          "3298:     if (truncated) {",
          "3299:      return -1;",
          "3300:     }",
          "3301:     return 0;",
          "3311:  static char *skip_quoted(char **buf,",
          "3312:                           const char *delimiters,",
          "3313:                           const char *whitespace,",
          "3314:                           char quotechar)",
          "3315:  {",
          "3316:   char *p, *begin_word, *end_word, *end_whitespace;",
          "3318:   begin_word = *buf;",
          "3319:   end_word = begin_word + strcspn(begin_word, delimiters);",
          "3322:   if (end_word > begin_word) {",
          "3323:    p = end_word - 1;",
          "3324:    while (*p == quotechar) {",
          "3331:     if (*end_word != '\\0') {",
          "3332:      size_t end_off = strcspn(end_word + 1, delimiters);",
          "3333:      memmove(p, end_word, end_off + 1);",
          "3335:      end_word += end_off + 1;",
          "3336:     } else {",
          "3338:      break;",
          "3339:     }",
          "3340:    }",
          "3341:    for (p++; p < end_word; p++) {",
          "3346:   if (*end_word == '\\0') {",
          "3348:   } else {",
          "",
          "[Added Lines]",
          "3268:   const char *proto =",
          "3269:       (is_websocket_protocol(conn) ? (ri->is_ssl ? \"wss\" : \"ws\")",
          "3270:                                    : (ri->is_ssl ? \"https\" : \"http\"));",
          "3276:   if (ri->local_uri == NULL) {",
          "3277:    return -1;",
          "3278:   }",
          "3280:   if ((ri->request_uri != NULL)",
          "3281:       && strcmp(ri->local_uri, ri->request_uri)) {",
          "3282:    mg_snprintf(conn,",
          "3283:                &truncated,",
          "3284:                buf,",
          "3285:                buflen,",
          "3286:                \"%s://%s\",",
          "3287:                proto,",
          "3288:                ri->request_uri);",
          "3289:    if (truncated) {",
          "3292:    return 0;",
          "3293:   } else {",
          "3296:    int is_ipv6 = (conn->client.lsa.sa.sa_family == AF_INET6);",
          "3297:    int port = is_ipv6 ? htons(conn->client.lsa.sin6.sin6_port)",
          "3298:                       : htons(conn->client.lsa.sin.sin_port);",
          "3302:    int def_port = ri->is_ssl ? 443 : 80;",
          "3303:    int auth_domain_check_enabled =",
          "3304:        conn->ctx->config[ENABLE_AUTH_DOMAIN_CHECK]",
          "3305:        && (!strcmp(conn->ctx->config[ENABLE_AUTH_DOMAIN_CHECK],",
          "3306:                    \"yes\"));",
          "3307:    const char *server_domain =",
          "3308:        conn->ctx->config[AUTHENTICATION_DOMAIN];",
          "3310:    char portstr[16];",
          "3311:    char server_ip[48];",
          "3313:    if (port != def_port) {",
          "3314:     sprintf(portstr, \":%u\", (unsigned)port);",
          "3315:    } else {",
          "3316:     portstr[0] = 0;",
          "3317:    }",
          "3319:    if (!auth_domain_check_enabled || !server_domain) {",
          "3321:     sockaddr_to_string(server_ip,",
          "3322:                        sizeof(server_ip),",
          "3323:                        &conn->client.lsa);",
          "3325:     server_domain = server_ip;",
          "3326:    }",
          "3328:    mg_snprintf(conn,",
          "3329:                &truncated,",
          "3330:                buf,",
          "3331:                buflen,",
          "3332:                \"%s://%s%s%s\",",
          "3333:                proto,",
          "3334:                server_domain,",
          "3335:                portstr,",
          "3336:                ri->local_uri);",
          "3337:    if (truncated) {",
          "3338:     return -1;",
          "3340:    return 0;",
          "3343: }",
          "3350: static char *",
          "3351: skip_quoted(char **buf,",
          "3352:             const char *delimiters,",
          "3353:             const char *whitespace,",
          "3354:             char quotechar)",
          "3355: {",
          "3356:  char *p, *begin_word, *end_word, *end_whitespace;",
          "3358:  begin_word = *buf;",
          "3359:  end_word = begin_word + strcspn(begin_word, delimiters);",
          "3362:  if (end_word > begin_word) {",
          "3363:   p = end_word - 1;",
          "3364:   while (*p == quotechar) {",
          "3371:    if (*end_word != '\\0') {",
          "3372:     size_t end_off = strcspn(end_word + 1, delimiters);",
          "3373:     memmove(p, end_word, end_off + 1);",
          "3375:     end_word += end_off + 1;",
          "3376:    } else {",
          "3378:     break;",
          "3381:   for (p++; p < end_word; p++) {",
          "3383:   }",
          "3384:  }",
          "3386:  if (*end_word == '\\0') {",
          "3388:  } else {",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "3360: #if defined(__GNUC__) || defined(__MINGW32__)",
          "3361: #if GCC_VERSION >= 40500",
          "",
          "[Removed Lines]",
          "3358:    end_whitespace = end_word + strspn(&end_word[1], whitespace) + 1;",
          "",
          "[Added Lines]",
          "3398:   end_whitespace = end_word + strspn(&end_word[1], whitespace) + 1;",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "3371:   }",
          "3374:  }",
          "3390:  }",
          "3393: #if defined(USE_WEBSOCKET)",
          "3408:    }",
          "3409:   }",
          "3411:  }",
          "3412: #endif",
          "3432:   return NULL;",
          "3433:  }",
          "3448:   return NULL;",
          "3449:  }",
          "3468:   } else {",
          "3506:    }",
          "3507:   }",
          "3510:  }",
          "3533:  }",
          "3561:     i++;",
          "3579:    }",
          "3580:   }",
          "3582:  }",
          "3618:    return 1;",
          "3619:   }",
          "3622:   return 0;",
          "3623:  }",
          "3633:  }",
          "3656: #if !defined(NO_CACHING)",
          "3681:  return send_no_cache_header(conn);",
          "3691: #if !defined(NO_SSL)",
          "3699:   }",
          "3700: #endif",
          "3707:  }",
          "3908:   }",
          "3909:  }",
          "3996:       }",
          "3997:      }",
          "3998:     }",
          "4006:    }",
          "4023:    mg_printf(conn,",
          "4043:    }",
          "4044:   }",
          "4045:  }",
          "4047: #if defined(_WIN32) && !defined(__SYMBIAN32__)",
          "",
          "[Removed Lines]",
          "3366:    for (p = end_word; p < end_whitespace; p++) {",
          "3368:    }",
          "3373:   return begin_word;",
          "3378:  static const char *get_header(const struct mg_header *hdr,",
          "3379:                                int num_hdr,",
          "3380:                                const char *name)",
          "3381:  {",
          "3382:   int i;",
          "3383:   for (i = 0; i < num_hdr; i++) {",
          "3384:    if (!mg_strcasecmp(name, hdr[i].name)) {",
          "3385:     return hdr[i].value;",
          "3386:    }",
          "3387:   }",
          "3389:   return NULL;",
          "3396:  static int get_req_headers(const struct mg_request_info *ri,",
          "3397:                             const char *name,",
          "3398:                             const char **output,",
          "3399:                             int output_max_size)",
          "3400:  {",
          "3401:   int i;",
          "3402:   int cnt = 0;",
          "3403:   if (ri) {",
          "3404:    for (i = 0; i < ri->num_headers && cnt < output_max_size; i++) {",
          "3405:     if (!mg_strcasecmp(name, ri->http_headers[i].name)) {",
          "3406:      output[cnt++] = ri->http_headers[i].value;",
          "3407:     }",
          "3410:   return cnt;",
          "3415:  const char *mg_get_header(const struct mg_connection *conn,",
          "3416:                            const char *name)",
          "3417:  {",
          "3418:   if (!conn) {",
          "3419:    return NULL;",
          "3420:   }",
          "3422:   if (conn->connection_type == 1) {",
          "3423:    return get_header(conn->request_info.http_headers,",
          "3424:                      conn->request_info.num_headers,",
          "3425:                      name);",
          "3426:   }",
          "3427:   if (conn->connection_type == 2) {",
          "3428:    return get_header(conn->response_info.http_headers,",
          "3429:                      conn->request_info.num_headers,",
          "3430:                      name);",
          "3431:   }",
          "3436:  static const char *get_http_version(const struct mg_connection *conn)",
          "3437:  {",
          "3438:   if (!conn) {",
          "3439:    return NULL;",
          "3440:   }",
          "3442:   if (conn->connection_type == 1) {",
          "3443:    return conn->request_info.http_version;",
          "3444:   }",
          "3445:   if (conn->connection_type == 2) {",
          "3446:    return conn->response_info.http_version;",
          "3447:   }",
          "3458:  static const char *next_option(const char *list,",
          "3459:                                 struct vec *val,",
          "3460:                                 struct vec *eq_val)",
          "3461:  {",
          "3462:   int end;",
          "3464:  reparse:",
          "3465:   if (val == NULL || list == NULL || *list == '\\0') {",
          "3467:    list = NULL;",
          "3470:    while (*list == ' ' || *list == '\\t')",
          "3471:     list++;",
          "3473:    val->ptr = list;",
          "3474:    if ((list = strchr(val->ptr, ',')) != NULL) {",
          "3476:     val->len = ((size_t)(list - val->ptr));",
          "3477:     list++;",
          "3478:    } else {",
          "3480:     list = val->ptr + strlen(val->ptr);",
          "3481:     val->len = ((size_t)(list - val->ptr));",
          "3482:    }",
          "3485:    end = (int)val->len - 1;",
          "3486:    while (end >= 0",
          "3487:           && ((val->ptr[end] == ' ') || (val->ptr[end] == '\\t')))",
          "3488:     end--;",
          "3489:    val->len = (size_t)(end + 1);",
          "3491:    if (val->len == 0) {",
          "3493:     goto reparse;",
          "3494:    }",
          "3496:    if (eq_val != NULL) {",
          "3499:     eq_val->len = 0;",
          "3500:     eq_val->ptr = (const char *)memchr(val->ptr, '=', val->len);",
          "3501:     if (eq_val->ptr != NULL) {",
          "3503:      eq_val->len = ((size_t)(val->ptr - eq_val->ptr)) + val->len;",
          "3504:      val->len = ((size_t)(eq_val->ptr - val->ptr)) - 1;",
          "3505:     }",
          "3509:   return list;",
          "3517:  static int header_has_option(const char *header, const char *option)",
          "3518:  {",
          "3519:   struct vec opt_vec;",
          "3520:   struct vec eq_vec;",
          "3523:   assert(option != NULL);",
          "3524:   assert(option[0] != '\\0');",
          "3527:   while ((header = next_option(header, &opt_vec, &eq_vec)) != NULL) {",
          "3528:    if (mg_strncasecmp(option, opt_vec.ptr, opt_vec.len) == 0)",
          "3529:     return 1;",
          "3530:   }",
          "3532:   return 0;",
          "3537:  static int match_prefix(const char *pattern,",
          "3538:                          size_t pattern_len,",
          "3539:                          const char *str)",
          "3540:  {",
          "3541:   const char *or_str;",
          "3542:   size_t i;",
          "3543:   int j, len, res;",
          "3545:   if ((or_str = (const char *)memchr(pattern, '|', pattern_len))",
          "3546:       != NULL) {",
          "3547:    res = match_prefix(pattern, (size_t)(or_str - pattern), str);",
          "3548:    return (res > 0) ? res",
          "3549:                     : match_prefix(or_str + 1,",
          "3550:                                    (size_t)((pattern + pattern_len)",
          "3551:                                             - (or_str + 1)),",
          "3552:                                    str);",
          "3553:   }",
          "3555:   for (i = 0, j = 0; (i < pattern_len); i++, j++) {",
          "3556:    if ((pattern[i] == '?') && (str[j] != '\\0')) {",
          "3557:     continue;",
          "3558:    } else if (pattern[i] == '$') {",
          "3559:     return (str[j] == '\\0') ? j : -1;",
          "3560:    } else if (pattern[i] == '*') {",
          "3562:     if (pattern[i] == '*') {",
          "3563:      i++;",
          "3564:      len = (int)strlen(str + j);",
          "3565:     } else {",
          "3566:      len = (int)strcspn(str + j, \"/\");",
          "3567:     }",
          "3568:     if (i == pattern_len) {",
          "3569:      return j + len;",
          "3570:     }",
          "3571:     do {",
          "3572:      res = match_prefix(pattern + i,",
          "3573:                         pattern_len - i,",
          "3574:                         str + j + len);",
          "3575:     } while (res == -1 && len-- > 0);",
          "3576:     return (res == -1) ? -1 : j + res + len;",
          "3577:    } else if (lowercase(&pattern[i]) != lowercase(&str[j])) {",
          "3578:     return -1;",
          "3581:   return j;",
          "3588:  static int should_keep_alive(const struct mg_connection *conn)",
          "3589:  {",
          "3590:   const char *http_version;",
          "3591:   const char *header;",
          "3594:   if ((conn == NULL) || conn->must_close) {",
          "3596:    return 0;",
          "3597:   }",
          "3599:   if (mg_strcasecmp(conn->ctx->config[ENABLE_KEEP_ALIVE], \"yes\") != 0) {",
          "3601:    return 0;",
          "3602:   }",
          "3605:   header = mg_get_header(conn, \"Connection\");",
          "3606:   if (header) {",
          "3608:    if (header_has_option(header, \"keep-alive\")) {",
          "3609:     return 1;",
          "3610:    }",
          "3611:    return 0;",
          "3612:   }",
          "3615:   http_version = get_http_version(conn);",
          "3616:   if (http_version && (0 == strcmp(http_version, \"1.1\"))) {",
          "3626:  static int should_decode_url(const struct mg_connection *conn)",
          "3627:  {",
          "3628:   if (!conn || !conn->ctx) {",
          "3629:    return 0;",
          "3630:   }",
          "3632:   return (mg_strcasecmp(conn->ctx->config[DECODE_URL], \"yes\") == 0);",
          "3636:  static const char *suggest_connection_header(",
          "3637:      const struct mg_connection *conn)",
          "3638:  {",
          "3639:   return should_keep_alive(conn) ? \"keep-alive\" : \"close\";",
          "3640:  }",
          "3643:  static int send_no_cache_header(struct mg_connection * conn)",
          "3644:  {",
          "3646:   return mg_printf(conn,",
          "3647:                    \"Cache-Control: no-cache, no-store, \"",
          "3648:                    \"must-revalidate, private, max-age=0\\r\\n\"",
          "3649:                    \"Pragma: no-cache\\r\\n\"",
          "3650:                    \"Expires: 0\\r\\n\");",
          "3651:  }",
          "3654:  static int send_static_cache_header(struct mg_connection * conn)",
          "3655:  {",
          "3659:   int max_age = atoi(conn->ctx->config[STATIC_FILE_MAX_AGE]);",
          "3660:   if (max_age <= 0) {",
          "3665:    return send_no_cache_header(conn);",
          "3666:   }",
          "3677:   return mg_printf(conn,",
          "3678:                    \"Cache-Control: max-age=%u\\r\\n\",",
          "3679:                    (unsigned)max_age);",
          "3683:  }",
          "3686:  static int send_additional_header(struct mg_connection * conn)",
          "3687:  {",
          "3688:   int i = 0;",
          "3689:   const char *header = conn->ctx->config[ADDITIONAL_HEADER];",
          "3692:   if (conn->ctx->config[STRICT_HTTPS_MAX_AGE]) {",
          "3693:    int max_age = atoi(conn->ctx->config[STRICT_HTTPS_MAX_AGE]);",
          "3694:    if (max_age >= 0) {",
          "3695:     i += mg_printf(conn,",
          "3696:                    \"Strict-Transport-Security: max-age=%u\\r\\n\",",
          "3697:                    (unsigned)max_age);",
          "3698:    }",
          "3702:   if (header && header[0]) {",
          "3703:    i += mg_printf(conn, \"%s\\r\\n\", header);",
          "3704:   }",
          "3706:   return i;",
          "3710:  static void handle_file_based_request(struct mg_connection * conn,",
          "3711:                                        const char *path,",
          "3712:                                        struct mg_file *filep);",
          "3715:  const char *mg_get_response_code_text(const struct mg_connection *conn,",
          "3716:                                        int response_code)",
          "3717:  {",
          "3722:   switch (response_code) {",
          "3724:   case 100:",
          "3726:   case 101:",
          "3728:   case 102:",
          "3732:   case 200:",
          "3734:   case 201:",
          "3736:   case 202:",
          "3738:   case 203:",
          "3740:   case 204:",
          "3742:   case 205:",
          "3744:   case 206:",
          "3746:   case 207:",
          "3747:    return \"Multi-Status\"; /* RFC2518 Section 10.2, RFC4918 Section 11.1",
          "3749:   case 208:",
          "3752:   case 226:",
          "3756:   case 300:",
          "3758:   case 301:",
          "3760:   case 302:",
          "3762:   case 303:",
          "3764:   case 304:",
          "3766:   case 305:",
          "3768:   case 307:",
          "3770:   case 308:",
          "3774:   case 400:",
          "3776:   case 401:",
          "3778:   case 402:",
          "3780:   case 403:",
          "3782:   case 404:",
          "3784:   case 405:",
          "3786:   case 406:",
          "3788:   case 407:",
          "3790:   case 408:",
          "3792:   case 409:",
          "3794:   case 410:",
          "3796:   case 411:",
          "3798:   case 412:",
          "3800:   case 413:",
          "3802:   case 414:",
          "3804:   case 415:",
          "3806:   case 416:",
          "3807:    return \"Requested range not satisfiable\"; /* RFC2616 Section 10.4.17",
          "3809:   case 417:",
          "3812:   case 421:",
          "3814:   case 422:",
          "3815:    return \"Unproccessable entity\"; /* RFC2518 Section 10.3, RFC4918",
          "3817:   case 423:",
          "3819:   case 424:",
          "3820:    return \"Failed Dependency\"; /* RFC2518 Section 10.5, RFC4918",
          "3823:   case 426:",
          "3826:   case 428:",
          "3828:   case 429:",
          "3831:   case 431:",
          "3834:   case 451:",
          "3835:    return \"Unavailable For Legal Reasons\"; /* draft-tbray-http-legally-restricted-status-05,",
          "3839:   case 500:",
          "3841:   case 501:",
          "3843:   case 502:",
          "3845:   case 503:",
          "3847:   case 504:",
          "3849:   case 505:",
          "3851:   case 506:",
          "3853:   case 507:",
          "3854:    return \"Insufficient Storage\"; /* RFC2518 Section 10.6, RFC4918",
          "3856:   case 508:",
          "3859:   case 510:",
          "3861:   case 511:",
          "3867:   case 418:",
          "3869:   case 419:",
          "3871:   case 420:",
          "3873:   case 440:",
          "3875:   case 509:",
          "3878:   default:",
          "3880:    if (conn) {",
          "3881:     mg_cry(conn, \"Unknown HTTP response code: %u\", response_code);",
          "3882:    }",
          "3885:    if (response_code >= 100 && response_code < 200) {",
          "3887:     return \"Information\";",
          "3888:    }",
          "3889:    if (response_code >= 200 && response_code < 300) {",
          "3891:     return \"Success\";",
          "3892:    }",
          "3893:    if (response_code >= 300 && response_code < 400) {",
          "3895:     return \"Redirection\";",
          "3896:    }",
          "3897:    if (response_code >= 400 && response_code < 500) {",
          "3899:     return \"Client Error\";",
          "3900:    }",
          "3901:    if (response_code >= 500 && response_code < 600) {",
          "3903:     return \"Server Error\";",
          "3904:    }",
          "3907:    return \"\";",
          "3912:  void mg_send_http_error(struct mg_connection * conn,",
          "3913:                          int status,",
          "3914:                          const char *fmt,",
          "3915:                          ...)",
          "3916:  {",
          "3917:   char buf[MG_BUF_LEN];",
          "3918:   va_list ap;",
          "3919:   int len, i, page_handler_found, scope, truncated, has_body;",
          "3920:   char date[64];",
          "3921:   time_t curtime = time(NULL);",
          "3922:   const char *error_handler = NULL;",
          "3923:   struct mg_file error_page_file = STRUCT_FILE_INITIALIZER;",
          "3924:   const char *error_page_file_ext, *tstr;",
          "3926:   const char *status_text = mg_get_response_code_text(conn, status);",
          "3928:   if (conn == NULL) {",
          "3929:    return;",
          "3930:   }",
          "3932:   conn->status_code = status;",
          "3933:   if (conn->in_error_handler || (conn->ctx->callbacks.http_error == NULL)",
          "3934:       || conn->ctx->callbacks.http_error(conn, status)) {",
          "3935:    if (!conn->in_error_handler) {",
          "3937:     error_handler = conn->ctx->config[ERROR_PAGES];",
          "3938:     error_page_file_ext = conn->ctx->config[INDEX_FILES];",
          "3939:     page_handler_found = 0;",
          "3940:     if (error_handler != NULL) {",
          "3941:      for (scope = 1; (scope <= 3) && !page_handler_found;",
          "3942:           scope++) {",
          "3943:       switch (scope) {",
          "3945:        mg_snprintf(conn,",
          "3946:                    &truncated,",
          "3947:                    buf,",
          "3948:                    sizeof(buf) - 32,",
          "3949:                    \"%serror%03u.\",",
          "3950:                    error_handler,",
          "3951:                    status);",
          "3952:        break;",
          "3953:       case 2: /* Handler for error group, e.g., 5xx error",
          "3956:        mg_snprintf(conn,",
          "3957:                    &truncated,",
          "3958:                    buf,",
          "3959:                    sizeof(buf) - 32,",
          "3960:                    \"%serror%01uxx.\",",
          "3961:                    error_handler,",
          "3962:                    status / 100);",
          "3963:        break;",
          "3965:        mg_snprintf(conn,",
          "3966:                    &truncated,",
          "3967:                    buf,",
          "3968:                    sizeof(buf) - 32,",
          "3969:                    \"%serror.\",",
          "3970:                    error_handler);",
          "3971:        break;",
          "3972:       }",
          "3979:       (void)truncated;",
          "3981:       len = (int)strlen(buf);",
          "3983:       tstr = strchr(error_page_file_ext, '.');",
          "3985:       while (tstr) {",
          "3986:        for (i = 1;",
          "3987:             (i < 32) && (tstr[i] != 0) && (tstr[i] != ',');",
          "3988:             i++)",
          "3989:         buf[len + i - 1] = tstr[i];",
          "3990:        buf[len + i - 1] = 0;",
          "3991:        if (mg_stat(conn, buf, &error_page_file.stat)) {",
          "3992:         page_handler_found = 1;",
          "3993:         break;",
          "3994:        }",
          "3995:        tstr = strchr(tstr + i, '.');",
          "4000:     if (page_handler_found) {",
          "4001:      conn->in_error_handler = 1;",
          "4002:      handle_file_based_request(conn, buf, &error_page_file);",
          "4003:      conn->in_error_handler = 0;",
          "4004:      return;",
          "4005:     }",
          "4009:    gmt_time_string(date, sizeof(date), &curtime);",
          "4012:    has_body = ((status > 199) && (status != 204) && (status != 304));",
          "4014:    conn->must_close = 1;",
          "4015:    mg_printf(conn, \"HTTP/1.1 %d %s\\r\\n\", status, status_text);",
          "4016:    send_no_cache_header(conn);",
          "4017:    send_additional_header(conn);",
          "4018:    if (has_body) {",
          "4019:     mg_printf(conn,",
          "4020:               \"%s\",",
          "4021:               \"Content-Type: text/plain; charset=utf-8\\r\\n\");",
          "4022:    }",
          "4024:              \"Date: %s\\r\\n\"",
          "4025:              \"Connection: close\\r\\n\\r\\n\",",
          "4026:              date);",
          "4029:    if (has_body) {",
          "4030:     mg_printf(conn, \"Error %d: %s\\n\", status, status_text);",
          "4032:     if (fmt != NULL) {",
          "4033:      va_start(ap, fmt);",
          "4034:      mg_vsnprintf(conn, NULL, buf, sizeof(buf), fmt, ap);",
          "4035:      va_end(ap);",
          "4036:      mg_write(conn, buf, strlen(buf));",
          "4037:      DEBUG_TRACE(\"Error %i - [%s]\", status, buf);",
          "4038:     }",
          "4040:    } else {",
          "4042:     DEBUG_TRACE(\"Error %i\", status);",
          "",
          "[Added Lines]",
          "3406:   for (p = end_word; p < end_whitespace; p++) {",
          "3413:  return begin_word;",
          "3414: }",
          "3418: static const char *",
          "3419: get_header(const struct mg_header *hdr, int num_hdr, const char *name)",
          "3420: {",
          "3421:  int i;",
          "3422:  for (i = 0; i < num_hdr; i++) {",
          "3423:   if (!mg_strcasecmp(name, hdr[i].name)) {",
          "3424:    return hdr[i].value;",
          "3425:   }",
          "3428:  return NULL;",
          "3429: }",
          "3435: static int",
          "3436: get_req_headers(const struct mg_request_info *ri,",
          "3437:                 const char *name,",
          "3438:                 const char **output,",
          "3439:                 int output_max_size)",
          "3440: {",
          "3441:  int i;",
          "3442:  int cnt = 0;",
          "3443:  if (ri) {",
          "3444:   for (i = 0; i < ri->num_headers && cnt < output_max_size; i++) {",
          "3445:    if (!mg_strcasecmp(name, ri->http_headers[i].name)) {",
          "3446:     output[cnt++] = ri->http_headers[i].value;",
          "3450:  return cnt;",
          "3451: }",
          "3455: const char *",
          "3456: mg_get_header(const struct mg_connection *conn, const char *name)",
          "3457: {",
          "3458:  if (!conn) {",
          "3462:  if (conn->connection_type == 1) {",
          "3463:   return get_header(conn->request_info.http_headers,",
          "3464:                     conn->request_info.num_headers,",
          "3465:                     name);",
          "3466:  }",
          "3467:  if (conn->connection_type == 2) {",
          "3468:   return get_header(conn->response_info.http_headers,",
          "3469:                     conn->request_info.num_headers,",
          "3470:                     name);",
          "3471:  }",
          "3472:  return NULL;",
          "3473: }",
          "3476: static const char *",
          "3477: get_http_version(const struct mg_connection *conn)",
          "3478: {",
          "3479:  if (!conn) {",
          "3483:  if (conn->connection_type == 1) {",
          "3484:   return conn->request_info.http_version;",
          "3485:  }",
          "3486:  if (conn->connection_type == 2) {",
          "3487:   return conn->response_info.http_version;",
          "3488:  }",
          "3489:  return NULL;",
          "3490: }",
          "3499: static const char *",
          "3500: next_option(const char *list, struct vec *val, struct vec *eq_val)",
          "3501: {",
          "3502:  int end;",
          "3504: reparse:",
          "3505:  if (val == NULL || list == NULL || *list == '\\0') {",
          "3507:   list = NULL;",
          "3508:  } else {",
          "3510:   while (*list == ' ' || *list == '\\t')",
          "3511:    list++;",
          "3513:   val->ptr = list;",
          "3514:   if ((list = strchr(val->ptr, ',')) != NULL) {",
          "3516:    val->len = ((size_t)(list - val->ptr));",
          "3517:    list++;",
          "3520:    list = val->ptr + strlen(val->ptr);",
          "3521:    val->len = ((size_t)(list - val->ptr));",
          "3522:   }",
          "3525:   end = (int)val->len - 1;",
          "3526:   while (end >= 0 && ((val->ptr[end] == ' ') || (val->ptr[end] == '\\t')))",
          "3527:    end--;",
          "3528:   val->len = (size_t)(end + 1);",
          "3530:   if (val->len == 0) {",
          "3532:    goto reparse;",
          "3533:   }",
          "3535:   if (eq_val != NULL) {",
          "3538:    eq_val->len = 0;",
          "3539:    eq_val->ptr = (const char *)memchr(val->ptr, '=', val->len);",
          "3540:    if (eq_val->ptr != NULL) {",
          "3542:     eq_val->len = ((size_t)(val->ptr - eq_val->ptr)) + val->len;",
          "3543:     val->len = ((size_t)(eq_val->ptr - val->ptr)) - 1;",
          "3548:  return list;",
          "3549: }",
          "3556: static int",
          "3557: header_has_option(const char *header, const char *option)",
          "3558: {",
          "3559:  struct vec opt_vec;",
          "3560:  struct vec eq_vec;",
          "3563:  assert(option != NULL);",
          "3564:  assert(option[0] != '\\0');",
          "3567:  while ((header = next_option(header, &opt_vec, &eq_vec)) != NULL) {",
          "3568:   if (mg_strncasecmp(option, opt_vec.ptr, opt_vec.len) == 0)",
          "3569:    return 1;",
          "3572:  return 0;",
          "3573: }",
          "3577: static int",
          "3578: match_prefix(const char *pattern, size_t pattern_len, const char *str)",
          "3579: {",
          "3580:  const char *or_str;",
          "3581:  size_t i;",
          "3582:  int j, len, res;",
          "3584:  if ((or_str = (const char *)memchr(pattern, '|', pattern_len)) != NULL) {",
          "3585:   res = match_prefix(pattern, (size_t)(or_str - pattern), str);",
          "3586:   return (res > 0) ? res : match_prefix(or_str + 1,",
          "3587:                                         (size_t)((pattern + pattern_len)",
          "3588:                                                  - (or_str + 1)),",
          "3589:                                         str);",
          "3590:  }",
          "3592:  for (i = 0, j = 0; (i < pattern_len); i++, j++) {",
          "3593:   if ((pattern[i] == '?') && (str[j] != '\\0')) {",
          "3594:    continue;",
          "3595:   } else if (pattern[i] == '$') {",
          "3596:    return (str[j] == '\\0') ? j : -1;",
          "3597:   } else if (pattern[i] == '*') {",
          "3598:    i++;",
          "3599:    if (pattern[i] == '*') {",
          "3601:     len = (int)strlen(str + j);",
          "3602:    } else {",
          "3603:     len = (int)strcspn(str + j, \"/\");",
          "3604:    }",
          "3605:    if (i == pattern_len) {",
          "3606:     return j + len;",
          "3608:    do {",
          "3609:     res = match_prefix(pattern + i, pattern_len - i, str + j + len);",
          "3610:    } while (res == -1 && len-- > 0);",
          "3611:    return (res == -1) ? -1 : j + res + len;",
          "3612:   } else if (lowercase(&pattern[i]) != lowercase(&str[j])) {",
          "3613:    return -1;",
          "3616:  return j;",
          "3617: }",
          "3623: static int",
          "3624: should_keep_alive(const struct mg_connection *conn)",
          "3625: {",
          "3626:  const char *http_version;",
          "3627:  const char *header;",
          "3630:  if ((conn == NULL) || conn->must_close) {",
          "3632:   return 0;",
          "3633:  }",
          "3635:  if (mg_strcasecmp(conn->ctx->config[ENABLE_KEEP_ALIVE], \"yes\") != 0) {",
          "3637:   return 0;",
          "3638:  }",
          "3641:  header = mg_get_header(conn, \"Connection\");",
          "3642:  if (header) {",
          "3644:   if (header_has_option(header, \"keep-alive\")) {",
          "3651:  http_version = get_http_version(conn);",
          "3652:  if (http_version && (0 == strcmp(http_version, \"1.1\"))) {",
          "3654:   return 1;",
          "3655:  }",
          "3658:  return 0;",
          "3659: }",
          "3662: static int",
          "3663: should_decode_url(const struct mg_connection *conn)",
          "3664: {",
          "3665:  if (!conn || !conn->ctx) {",
          "3666:   return 0;",
          "3669:  return (mg_strcasecmp(conn->ctx->config[DECODE_URL], \"yes\") == 0);",
          "3670: }",
          "3673: static const char *",
          "3674: suggest_connection_header(const struct mg_connection *conn)",
          "3675: {",
          "3676:  return should_keep_alive(conn) ? \"keep-alive\" : \"close\";",
          "3677: }",
          "3680: static int",
          "3681: send_no_cache_header(struct mg_connection *conn)",
          "3682: {",
          "3684:  return mg_printf(conn,",
          "3685:                   \"Cache-Control: no-cache, no-store, \"",
          "3686:                   \"must-revalidate, private, max-age=0\\r\\n\"",
          "3687:                   \"Pragma: no-cache\\r\\n\"",
          "3688:                   \"Expires: 0\\r\\n\");",
          "3689: }",
          "3692: static int",
          "3693: send_static_cache_header(struct mg_connection *conn)",
          "3694: {",
          "3698:  int max_age = atoi(conn->ctx->config[STATIC_FILE_MAX_AGE]);",
          "3699:  if (max_age <= 0) {",
          "3704:   return send_no_cache_header(conn);",
          "3705:  }",
          "3716:  return mg_printf(conn, \"Cache-Control: max-age=%u\\r\\n\", (unsigned)max_age);",
          "3720: }",
          "3723: static int",
          "3724: send_additional_header(struct mg_connection *conn)",
          "3725: {",
          "3726:  int i = 0;",
          "3727:  const char *header = conn->ctx->config[ADDITIONAL_HEADER];",
          "3730:  if (conn->ctx->config[STRICT_HTTPS_MAX_AGE]) {",
          "3731:   int max_age = atoi(conn->ctx->config[STRICT_HTTPS_MAX_AGE]);",
          "3732:   if (max_age >= 0) {",
          "3733:    i += mg_printf(conn,",
          "3734:                   \"Strict-Transport-Security: max-age=%u\\r\\n\",",
          "3735:                   (unsigned)max_age);",
          "3737:  }",
          "3740:  if (header && header[0]) {",
          "3741:   i += mg_printf(conn, \"%s\\r\\n\", header);",
          "3744:  return i;",
          "3745: }",
          "3748: static void handle_file_based_request(struct mg_connection *conn,",
          "3749:                                       const char *path,",
          "3750:                                       struct mg_file *filep);",
          "3753: const char *",
          "3754: mg_get_response_code_text(const struct mg_connection *conn, int response_code)",
          "3755: {",
          "3760:  switch (response_code) {",
          "3762:  case 100:",
          "3764:  case 101:",
          "3766:  case 102:",
          "3770:  case 200:",
          "3772:  case 201:",
          "3774:  case 202:",
          "3776:  case 203:",
          "3778:  case 204:",
          "3780:  case 205:",
          "3782:  case 206:",
          "3784:  case 207:",
          "3785:   return \"Multi-Status\"; /* RFC2518 Section 10.2, RFC4918 Section 11.1",
          "3787:  case 208:",
          "3790:  case 226:",
          "3794:  case 300:",
          "3796:  case 301:",
          "3798:  case 302:",
          "3800:  case 303:",
          "3802:  case 304:",
          "3804:  case 305:",
          "3806:  case 307:",
          "3808:  case 308:",
          "3812:  case 400:",
          "3814:  case 401:",
          "3816:  case 402:",
          "3818:  case 403:",
          "3820:  case 404:",
          "3822:  case 405:",
          "3824:  case 406:",
          "3826:  case 407:",
          "3828:  case 408:",
          "3830:  case 409:",
          "3832:  case 410:",
          "3834:  case 411:",
          "3836:  case 412:",
          "3838:  case 413:",
          "3840:  case 414:",
          "3842:  case 415:",
          "3844:  case 416:",
          "3845:   return \"Requested range not satisfiable\"; /* RFC2616 Section 10.4.17",
          "3847:  case 417:",
          "3850:  case 421:",
          "3852:  case 422:",
          "3853:   return \"Unproccessable entity\"; /* RFC2518 Section 10.3, RFC4918",
          "3855:  case 423:",
          "3857:  case 424:",
          "3858:   return \"Failed Dependency\"; /* RFC2518 Section 10.5, RFC4918",
          "3861:  case 426:",
          "3864:  case 428:",
          "3866:  case 429:",
          "3869:  case 431:",
          "3872:  case 451:",
          "3873:   return \"Unavailable For Legal Reasons\"; /* draft-tbray-http-legally-restricted-status-05,",
          "3877:  case 500:",
          "3879:  case 501:",
          "3881:  case 502:",
          "3883:  case 503:",
          "3885:  case 504:",
          "3887:  case 505:",
          "3889:  case 506:",
          "3891:  case 507:",
          "3892:   return \"Insufficient Storage\"; /* RFC2518 Section 10.6, RFC4918",
          "3894:  case 508:",
          "3897:  case 510:",
          "3899:  case 511:",
          "3905:  case 418:",
          "3907:  case 419:",
          "3909:  case 420:",
          "3911:  case 440:",
          "3913:  case 509:",
          "3916:  default:",
          "3918:   if (conn) {",
          "3919:    mg_cry(conn, \"Unknown HTTP response code: %u\", response_code);",
          "3920:   }",
          "3923:   if (response_code >= 100 && response_code < 200) {",
          "3925:    return \"Information\";",
          "3926:   }",
          "3927:   if (response_code >= 200 && response_code < 300) {",
          "3929:    return \"Success\";",
          "3930:   }",
          "3931:   if (response_code >= 300 && response_code < 400) {",
          "3933:    return \"Redirection\";",
          "3935:   if (response_code >= 400 && response_code < 500) {",
          "3937:    return \"Client Error\";",
          "3938:   }",
          "3939:   if (response_code >= 500 && response_code < 600) {",
          "3941:    return \"Server Error\";",
          "3942:   }",
          "3945:   return \"\";",
          "3947: }",
          "3950: void",
          "3951: mg_send_http_error(struct mg_connection *conn, int status, const char *fmt, ...)",
          "3952: {",
          "3953:  char buf[MG_BUF_LEN];",
          "3954:  va_list ap;",
          "3955:  int len, i, page_handler_found, scope, truncated, has_body;",
          "3956:  char date[64];",
          "3957:  time_t curtime = time(NULL);",
          "3958:  const char *error_handler = NULL;",
          "3959:  struct mg_file error_page_file = STRUCT_FILE_INITIALIZER;",
          "3960:  const char *error_page_file_ext, *tstr;",
          "3962:  const char *status_text = mg_get_response_code_text(conn, status);",
          "3964:  if (conn == NULL) {",
          "3965:   return;",
          "3966:  }",
          "3968:  conn->status_code = status;",
          "3969:  if (conn->in_error_handler || (conn->ctx->callbacks.http_error == NULL)",
          "3970:      || conn->ctx->callbacks.http_error(conn, status)) {",
          "3971:   if (!conn->in_error_handler) {",
          "3973:    error_handler = conn->ctx->config[ERROR_PAGES];",
          "3974:    error_page_file_ext = conn->ctx->config[INDEX_FILES];",
          "3975:    page_handler_found = 0;",
          "3976:    if (error_handler != NULL) {",
          "3977:     for (scope = 1; (scope <= 3) && !page_handler_found; scope++) {",
          "3978:      switch (scope) {",
          "3980:       mg_snprintf(conn,",
          "3981:                   &truncated,",
          "3982:                   buf,",
          "3983:                   sizeof(buf) - 32,",
          "3984:                   \"%serror%03u.\",",
          "3985:                   error_handler,",
          "3986:                   status);",
          "3987:       break;",
          "3988:      case 2: /* Handler for error group, e.g., 5xx error",
          "3991:       mg_snprintf(conn,",
          "3992:                   &truncated,",
          "3993:                   buf,",
          "3994:                   sizeof(buf) - 32,",
          "3995:                   \"%serror%01uxx.\",",
          "3996:                   error_handler,",
          "3997:                   status / 100);",
          "3998:       break;",
          "4000:       mg_snprintf(conn,",
          "4001:                   &truncated,",
          "4002:                   buf,",
          "4003:                   sizeof(buf) - 32,",
          "4004:                   \"%serror.\",",
          "4005:                   error_handler);",
          "4006:       break;",
          "4007:      }",
          "4014:      (void)truncated;",
          "4016:      len = (int)strlen(buf);",
          "4018:      tstr = strchr(error_page_file_ext, '.');",
          "4020:      while (tstr) {",
          "4021:       for (i = 1;",
          "4022:            (i < 32) && (tstr[i] != 0) && (tstr[i] != ',');",
          "4023:            i++)",
          "4024:        buf[len + i - 1] = tstr[i];",
          "4025:       buf[len + i - 1] = 0;",
          "4026:       if (mg_stat(conn, buf, &error_page_file.stat)) {",
          "4027:        page_handler_found = 1;",
          "4028:        break;",
          "4030:       tstr = strchr(tstr + i, '.');",
          "4033:    }",
          "4035:    if (page_handler_found) {",
          "4036:     conn->in_error_handler = 1;",
          "4037:     handle_file_based_request(conn, buf, &error_page_file);",
          "4038:     conn->in_error_handler = 0;",
          "4039:     return;",
          "4041:   }",
          "4044:   gmt_time_string(date, sizeof(date), &curtime);",
          "4047:   has_body = ((status > 199) && (status != 204) && (status != 304));",
          "4049:   conn->must_close = 1;",
          "4050:   mg_printf(conn, \"HTTP/1.1 %d %s\\r\\n\", status, status_text);",
          "4051:   send_no_cache_header(conn);",
          "4052:   send_additional_header(conn);",
          "4053:   if (has_body) {",
          "4055:              \"%s\",",
          "4056:              \"Content-Type: text/plain; charset=utf-8\\r\\n\");",
          "4057:   }",
          "4058:   mg_printf(conn,",
          "4059:             \"Date: %s\\r\\n\"",
          "4060:             \"Connection: close\\r\\n\\r\\n\",",
          "4061:             date);",
          "4064:   if (has_body) {",
          "4065:    mg_printf(conn, \"Error %d: %s\\n\", status, status_text);",
          "4067:    if (fmt != NULL) {",
          "4068:     va_start(ap, fmt);",
          "4069:     mg_vsnprintf(conn, NULL, buf, sizeof(buf), fmt, ap);",
          "4070:     va_end(ap);",
          "4071:     mg_write(conn, buf, strlen(buf));",
          "4072:     DEBUG_TRACE(\"Error %i - [%s]\", status, buf);",
          "4075:   } else {",
          "4077:    DEBUG_TRACE(\"Error %i\", status);",
          "4080: }",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "4054: #endif",
          "4080: #ifdef ENABLE_UNUSED_PTHREAD_FUNCTIONS",
          "4091:  }",
          "4092: #endif",
          "4123:   EnterCriticalSection(&cv->threadIdSec);",
          "4125:   ptls = &cv->waiting_thread;",
          "4139:    }",
          "4143:   }",
          "4164:   }",
          "4169:  }",
          "4196:  }",
          "4209:  }",
          "4224: #ifdef ALTERNATIVE_QUEUE",
          "4252: #endif",
          "",
          "[Removed Lines]",
          "4057:  FUNCTION_MAY_BE_UNUSED",
          "4058:  static int pthread_mutex_init(pthread_mutex_t * mutex, void *unused)",
          "4059:  {",
          "4060:   (void)unused;",
          "4062:   return (*mutex == NULL) ? -1 : 0;",
          "4063:  }",
          "4065:  FUNCTION_MAY_BE_UNUSED",
          "4066:  static int pthread_mutex_destroy(pthread_mutex_t * mutex)",
          "4067:  {",
          "4068:   return (CloseHandle(*mutex) == 0) ? -1 : 0;",
          "4069:  }",
          "4072:  FUNCTION_MAY_BE_UNUSED",
          "4073:  static int pthread_mutex_lock(pthread_mutex_t * mutex)",
          "4074:  {",
          "4075:   return (WaitForSingleObject(*mutex, INFINITE) == WAIT_OBJECT_0) ? 0",
          "4076:                                                                   : -1;",
          "4077:  }",
          "4081:  FUNCTION_MAY_BE_UNUSED",
          "4082:  static int pthread_mutex_trylock(pthread_mutex_t * mutex)",
          "4083:  {",
          "4084:   switch (WaitForSingleObject(*mutex, 0)) {",
          "4085:   case WAIT_OBJECT_0:",
          "4086:    return 0;",
          "4087:   case WAIT_TIMEOUT:",
          "4089:   }",
          "4090:   return -1;",
          "4095:  FUNCTION_MAY_BE_UNUSED",
          "4096:  static int pthread_mutex_unlock(pthread_mutex_t * mutex)",
          "4097:  {",
          "4098:   return (ReleaseMutex(*mutex) == 0) ? -1 : 0;",
          "4099:  }",
          "4102:  FUNCTION_MAY_BE_UNUSED",
          "4103:  static int pthread_cond_init(pthread_cond_t * cv, const void *unused)",
          "4104:  {",
          "4105:   (void)unused;",
          "4106:   InitializeCriticalSection(&cv->threadIdSec);",
          "4107:   cv->waiting_thread = NULL;",
          "4108:   return 0;",
          "4109:  }",
          "4112:  FUNCTION_MAY_BE_UNUSED",
          "4113:  static int pthread_cond_timedwait(pthread_cond_t * cv,",
          "4114:                                    pthread_mutex_t * mutex,",
          "4115:                                    const struct timespec *abstime)",
          "4116:  {",
          "4117:   struct mg_workerTLS **ptls,",
          "4119:   int ok;",
          "4120:   int64_t nsnow, nswaitabs, nswaitrel;",
          "4121:   DWORD mswaitrel;",
          "4126:   for (; *ptls != NULL; ptls = &(*ptls)->next_waiting_thread)",
          "4127:    ;",
          "4128:   tls->next_waiting_thread = NULL;",
          "4130:   LeaveCriticalSection(&cv->threadIdSec);",
          "4132:   if (abstime) {",
          "4133:    nsnow = mg_get_current_time_ns();",
          "4134:    nswaitabs =",
          "4135:        (((int64_t)abstime->tv_sec) * 1000000000) + abstime->tv_nsec;",
          "4136:    nswaitrel = nswaitabs - nsnow;",
          "4137:    if (nswaitrel < 0) {",
          "4138:     nswaitrel = 0;",
          "4140:    mswaitrel = (DWORD)(nswaitrel / 1000000);",
          "4141:   } else {",
          "4142:    mswaitrel = INFINITE;",
          "4145:   pthread_mutex_unlock(mutex);",
          "4146:   ok =",
          "4147:       (WAIT_OBJECT_0",
          "4148:        == WaitForSingleObject(tls->pthread_cond_helper_mutex, mswaitrel));",
          "4149:   if (!ok) {",
          "4150:    ok = 1;",
          "4151:    EnterCriticalSection(&cv->threadIdSec);",
          "4152:    ptls = &cv->waiting_thread;",
          "4153:    for (; *ptls != NULL; ptls = &(*ptls)->next_waiting_thread) {",
          "4154:     if (*ptls == tls) {",
          "4156:      ok = 0;",
          "4157:      break;",
          "4158:     }",
          "4159:    }",
          "4160:    LeaveCriticalSection(&cv->threadIdSec);",
          "4161:    if (ok) {",
          "4162:     WaitForSingleObject(tls->pthread_cond_helper_mutex, INFINITE);",
          "4163:    }",
          "4166:   pthread_mutex_lock(mutex);",
          "4168:   return ok ? 0 : -1;",
          "4172:  FUNCTION_MAY_BE_UNUSED",
          "4173:  static int pthread_cond_wait(pthread_cond_t * cv, pthread_mutex_t * mutex)",
          "4174:  {",
          "4175:   return pthread_cond_timedwait(cv, mutex, NULL);",
          "4176:  }",
          "4179:  FUNCTION_MAY_BE_UNUSED",
          "4180:  static int pthread_cond_signal(pthread_cond_t * cv)",
          "4181:  {",
          "4182:   HANDLE wkup = NULL;",
          "4183:   BOOL ok = FALSE;",
          "4185:   EnterCriticalSection(&cv->threadIdSec);",
          "4186:   if (cv->waiting_thread) {",
          "4187:    wkup = cv->waiting_thread->pthread_cond_helper_mutex;",
          "4188:    cv->waiting_thread = cv->waiting_thread->next_waiting_thread;",
          "4190:    ok = SetEvent(wkup);",
          "4191:    assert(ok);",
          "4192:   }",
          "4193:   LeaveCriticalSection(&cv->threadIdSec);",
          "4195:   return ok ? 0 : 1;",
          "4199:  FUNCTION_MAY_BE_UNUSED",
          "4200:  static int pthread_cond_broadcast(pthread_cond_t * cv)",
          "4201:  {",
          "4202:   EnterCriticalSection(&cv->threadIdSec);",
          "4203:   while (cv->waiting_thread) {",
          "4204:    pthread_cond_signal(cv);",
          "4205:   }",
          "4206:   LeaveCriticalSection(&cv->threadIdSec);",
          "4208:   return 0;",
          "4212:  FUNCTION_MAY_BE_UNUSED",
          "4213:  static int pthread_cond_destroy(pthread_cond_t * cv)",
          "4214:  {",
          "4215:   EnterCriticalSection(&cv->threadIdSec);",
          "4216:   assert(cv->waiting_thread == NULL);",
          "4217:   LeaveCriticalSection(&cv->threadIdSec);",
          "4218:   DeleteCriticalSection(&cv->threadIdSec);",
          "4220:   return 0;",
          "4221:  }",
          "4225:  FUNCTION_MAY_BE_UNUSED",
          "4226:  static void *event_create(void)",
          "4227:  {",
          "4228:   return (void *)CreateEvent(NULL, FALSE, FALSE, NULL);",
          "4229:  }",
          "4232:  FUNCTION_MAY_BE_UNUSED",
          "4233:  static int event_wait(void *eventhdl)",
          "4234:  {",
          "4235:   int res = WaitForSingleObject((HANDLE)eventhdl, INFINITE);",
          "4236:   return (res == WAIT_OBJECT_0);",
          "4237:  }",
          "4240:  FUNCTION_MAY_BE_UNUSED",
          "4241:  static int event_signal(void *eventhdl)",
          "4242:  {",
          "4243:   return (int)SetEvent((HANDLE)eventhdl);",
          "4244:  }",
          "4247:  FUNCTION_MAY_BE_UNUSED",
          "4248:  static void event_destroy(void *eventhdl)",
          "4249:  {",
          "4250:   CloseHandle((HANDLE)eventhdl);",
          "4251:  }",
          "",
          "[Added Lines]",
          "4092: FUNCTION_MAY_BE_UNUSED",
          "4093: static int",
          "4094: pthread_mutex_init(pthread_mutex_t *mutex, void *unused)",
          "4095: {",
          "4096:  (void)unused;",
          "4098:  return (*mutex == NULL) ? -1 : 0;",
          "4099: }",
          "4101: FUNCTION_MAY_BE_UNUSED",
          "4102: static int",
          "4103: pthread_mutex_destroy(pthread_mutex_t *mutex)",
          "4104: {",
          "4105:  return (CloseHandle(*mutex) == 0) ? -1 : 0;",
          "4106: }",
          "4109: FUNCTION_MAY_BE_UNUSED",
          "4110: static int",
          "4111: pthread_mutex_lock(pthread_mutex_t *mutex)",
          "4112: {",
          "4113:  return (WaitForSingleObject(*mutex, INFINITE) == WAIT_OBJECT_0) ? 0 : -1;",
          "4114: }",
          "4118: FUNCTION_MAY_BE_UNUSED",
          "4119: static int",
          "4120: pthread_mutex_trylock(pthread_mutex_t *mutex)",
          "4121: {",
          "4122:  switch (WaitForSingleObject(*mutex, 0)) {",
          "4123:  case WAIT_OBJECT_0:",
          "4124:   return 0;",
          "4125:  case WAIT_TIMEOUT:",
          "4128:  return -1;",
          "4129: }",
          "4133: FUNCTION_MAY_BE_UNUSED",
          "4134: static int",
          "4135: pthread_mutex_unlock(pthread_mutex_t *mutex)",
          "4136: {",
          "4137:  return (ReleaseMutex(*mutex) == 0) ? -1 : 0;",
          "4138: }",
          "4141: FUNCTION_MAY_BE_UNUSED",
          "4142: static int",
          "4143: pthread_cond_init(pthread_cond_t *cv, const void *unused)",
          "4144: {",
          "4145:  (void)unused;",
          "4146:  InitializeCriticalSection(&cv->threadIdSec);",
          "4147:  cv->waiting_thread = NULL;",
          "4148:  return 0;",
          "4149: }",
          "4152: FUNCTION_MAY_BE_UNUSED",
          "4153: static int",
          "4154: pthread_cond_timedwait(pthread_cond_t *cv,",
          "4155:                        pthread_mutex_t *mutex,",
          "4156:                        const struct timespec *abstime)",
          "4157: {",
          "4158:  struct mg_workerTLS **ptls,",
          "4160:  int ok;",
          "4161:  int64_t nsnow, nswaitabs, nswaitrel;",
          "4162:  DWORD mswaitrel;",
          "4164:  EnterCriticalSection(&cv->threadIdSec);",
          "4166:  ptls = &cv->waiting_thread;",
          "4167:  for (; *ptls != NULL; ptls = &(*ptls)->next_waiting_thread)",
          "4168:   ;",
          "4169:  tls->next_waiting_thread = NULL;",
          "4171:  LeaveCriticalSection(&cv->threadIdSec);",
          "4173:  if (abstime) {",
          "4174:   nsnow = mg_get_current_time_ns();",
          "4175:   nswaitabs =",
          "4176:       (((int64_t)abstime->tv_sec) * 1000000000) + abstime->tv_nsec;",
          "4177:   nswaitrel = nswaitabs - nsnow;",
          "4178:   if (nswaitrel < 0) {",
          "4179:    nswaitrel = 0;",
          "4180:   }",
          "4181:   mswaitrel = (DWORD)(nswaitrel / 1000000);",
          "4182:  } else {",
          "4183:   mswaitrel = INFINITE;",
          "4184:  }",
          "4186:  pthread_mutex_unlock(mutex);",
          "4187:  ok = (WAIT_OBJECT_0",
          "4188:        == WaitForSingleObject(tls->pthread_cond_helper_mutex, mswaitrel));",
          "4189:  if (!ok) {",
          "4190:   ok = 1;",
          "4193:   for (; *ptls != NULL; ptls = &(*ptls)->next_waiting_thread) {",
          "4194:    if (*ptls == tls) {",
          "4196:     ok = 0;",
          "4197:     break;",
          "4200:   LeaveCriticalSection(&cv->threadIdSec);",
          "4201:   if (ok) {",
          "4202:    WaitForSingleObject(tls->pthread_cond_helper_mutex, INFINITE);",
          "4206:  pthread_mutex_lock(mutex);",
          "4208:  return ok ? 0 : -1;",
          "4209: }",
          "4212: FUNCTION_MAY_BE_UNUSED",
          "4213: static int",
          "4214: pthread_cond_wait(pthread_cond_t *cv, pthread_mutex_t *mutex)",
          "4215: {",
          "4216:  return pthread_cond_timedwait(cv, mutex, NULL);",
          "4217: }",
          "4220: FUNCTION_MAY_BE_UNUSED",
          "4221: static int",
          "4222: pthread_cond_signal(pthread_cond_t *cv)",
          "4223: {",
          "4224:  HANDLE wkup = NULL;",
          "4225:  BOOL ok = FALSE;",
          "4227:  EnterCriticalSection(&cv->threadIdSec);",
          "4228:  if (cv->waiting_thread) {",
          "4229:   wkup = cv->waiting_thread->pthread_cond_helper_mutex;",
          "4230:   cv->waiting_thread = cv->waiting_thread->next_waiting_thread;",
          "4232:   ok = SetEvent(wkup);",
          "4233:   assert(ok);",
          "4235:  LeaveCriticalSection(&cv->threadIdSec);",
          "4237:  return ok ? 0 : 1;",
          "4238: }",
          "4241: FUNCTION_MAY_BE_UNUSED",
          "4242: static int",
          "4243: pthread_cond_broadcast(pthread_cond_t *cv)",
          "4244: {",
          "4245:  EnterCriticalSection(&cv->threadIdSec);",
          "4246:  while (cv->waiting_thread) {",
          "4247:   pthread_cond_signal(cv);",
          "4249:  LeaveCriticalSection(&cv->threadIdSec);",
          "4251:  return 0;",
          "4252: }",
          "4255: FUNCTION_MAY_BE_UNUSED",
          "4256: static int",
          "4257: pthread_cond_destroy(pthread_cond_t *cv)",
          "4258: {",
          "4259:  EnterCriticalSection(&cv->threadIdSec);",
          "4260:  assert(cv->waiting_thread == NULL);",
          "4261:  LeaveCriticalSection(&cv->threadIdSec);",
          "4262:  DeleteCriticalSection(&cv->threadIdSec);",
          "4264:  return 0;",
          "4265: }",
          "4269: FUNCTION_MAY_BE_UNUSED",
          "4270: static void *",
          "4271: event_create(void)",
          "4272: {",
          "4273:  return (void *)CreateEvent(NULL, FALSE, FALSE, NULL);",
          "4274: }",
          "4277: FUNCTION_MAY_BE_UNUSED",
          "4278: static int",
          "4279: event_wait(void *eventhdl)",
          "4280: {",
          "4281:  int res = WaitForSingleObject((HANDLE)eventhdl, INFINITE);",
          "4282:  return (res == WAIT_OBJECT_0);",
          "4283: }",
          "4286: FUNCTION_MAY_BE_UNUSED",
          "4287: static int",
          "4288: event_signal(void *eventhdl)",
          "4289: {",
          "4290:  return (int)SetEvent((HANDLE)eventhdl);",
          "4291: }",
          "4294: FUNCTION_MAY_BE_UNUSED",
          "4295: static void",
          "4296: event_destroy(void *eventhdl)",
          "4297: {",
          "4298:  CloseHandle((HANDLE)eventhdl);",
          "4299: }",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "4258: #endif",
          "4279:    }",
          "4280:   }",
          "4281:  }",
          "4339:   }",
          "4342: #if !defined(_WIN32_WCE)",
          "4356:   }",
          "4357: #else",
          "4358:  (void)long_len;",
          "4359:  (void)wbuf2;",
          "",
          "[Removed Lines]",
          "4262:  static void change_slashes_to_backslashes(char *path)",
          "4263:  {",
          "4264:   int i;",
          "4266:   for (i = 0; path[i] != '\\0'; i++) {",
          "4267:    if (path[i] == '/') {",
          "4268:     path[i] = '\\\\';",
          "4269:    }",
          "4273:    if ((path[i] == '\\\\') && (i > 0)) {",
          "4274:     while ((path[i + 1] == '\\\\') || (path[i + 1] == '/')) {",
          "4275:      (void)memmove(path + i + 1,",
          "4276:                    path + i + 2,",
          "4277:                    strlen(path + i + 1));",
          "4278:     }",
          "4284:  static int mg_wcscasecmp(const wchar_t *s1, const wchar_t *s2)",
          "4285:  {",
          "4286:   int diff;",
          "4288:   do {",
          "4289:    diff = tolower(*s1) - tolower(*s2);",
          "4290:    s1++;",
          "4291:    s2++;",
          "4292:   } while ((diff == 0) && (s1[-1] != '\\0'));",
          "4294:   return diff;",
          "4295:  }",
          "4300:  static void path_to_unicode(const struct mg_connection *conn,",
          "4301:                              const char *path,",
          "4302:                              wchar_t *wbuf,",
          "4303:                              size_t wbuf_len)",
          "4304:  {",
          "4305:   char buf[PATH_MAX], buf2[PATH_MAX];",
          "4306:   wchar_t wbuf2[MAX_PATH + 1];",
          "4307:   DWORD long_len, err;",
          "4308:   int (*fcompare)(const wchar_t *, const wchar_t *) = mg_wcscasecmp;",
          "4310:   mg_strlcpy(buf, path, sizeof(buf));",
          "4311:   change_slashes_to_backslashes(buf);",
          "4315:   memset(wbuf, 0, wbuf_len * sizeof(wchar_t));",
          "4316:   MultiByteToWideChar(CP_UTF8, 0, buf, -1, wbuf, (int)wbuf_len);",
          "4317:   WideCharToMultiByte(",
          "4318:       CP_UTF8, 0, wbuf, (int)wbuf_len, buf2, sizeof(buf2), NULL, NULL);",
          "4319:   if (strcmp(buf, buf2) != 0) {",
          "4320:    wbuf[0] = L'\\0';",
          "4321:   }",
          "4332:   if (conn) {",
          "4333:    if (conn->ctx->config[CASE_SENSITIVE_FILES]",
          "4334:        && !mg_strcasecmp(conn->ctx->config[CASE_SENSITIVE_FILES],",
          "4335:                          \"yes\")) {",
          "4337:     fcompare = wcscmp;",
          "4338:    }",
          "4344:   memset(wbuf2, 0, ARRAY_SIZE(wbuf2) * sizeof(wchar_t));",
          "4345:   long_len = GetLongPathNameW(wbuf, wbuf2, ARRAY_SIZE(wbuf2) - 1);",
          "4346:   if (long_len == 0) {",
          "4347:    err = GetLastError();",
          "4348:    if (err == ERROR_FILE_NOT_FOUND) {",
          "4350:     return;",
          "4351:    }",
          "4352:   }",
          "4353:   if ((long_len >= ARRAY_SIZE(wbuf2)) || (fcompare(wbuf, wbuf2) != 0)) {",
          "4355:    wbuf[0] = L'\\0';",
          "",
          "[Added Lines]",
          "4310: static void",
          "4311: change_slashes_to_backslashes(char *path)",
          "4312: {",
          "4313:  int i;",
          "4315:  for (i = 0; path[i] != '\\0'; i++) {",
          "4316:   if (path[i] == '/') {",
          "4317:    path[i] = '\\\\';",
          "4318:   }",
          "4322:   if ((path[i] == '\\\\') && (i > 0)) {",
          "4323:    while ((path[i + 1] == '\\\\') || (path[i + 1] == '/')) {",
          "4324:     (void)memmove(path + i + 1, path + i + 2, strlen(path + i + 1));",
          "4328: }",
          "4331: static int",
          "4332: mg_wcscasecmp(const wchar_t *s1, const wchar_t *s2)",
          "4333: {",
          "4334:  int diff;",
          "4336:  do {",
          "4337:   diff = tolower(*s1) - tolower(*s2);",
          "4338:   s1++;",
          "4339:   s2++;",
          "4340:  } while ((diff == 0) && (s1[-1] != '\\0'));",
          "4342:  return diff;",
          "4343: }",
          "4348: static void",
          "4349: path_to_unicode(const struct mg_connection *conn,",
          "4350:                 const char *path,",
          "4351:                 wchar_t *wbuf,",
          "4352:                 size_t wbuf_len)",
          "4353: {",
          "4354:  char buf[PATH_MAX], buf2[PATH_MAX];",
          "4355:  wchar_t wbuf2[MAX_PATH + 1];",
          "4356:  DWORD long_len, err;",
          "4357:  int (*fcompare)(const wchar_t *, const wchar_t *) = mg_wcscasecmp;",
          "4359:  mg_strlcpy(buf, path, sizeof(buf));",
          "4360:  change_slashes_to_backslashes(buf);",
          "4364:  memset(wbuf, 0, wbuf_len * sizeof(wchar_t));",
          "4365:  MultiByteToWideChar(CP_UTF8, 0, buf, -1, wbuf, (int)wbuf_len);",
          "4366:  WideCharToMultiByte(",
          "4367:      CP_UTF8, 0, wbuf, (int)wbuf_len, buf2, sizeof(buf2), NULL, NULL);",
          "4368:  if (strcmp(buf, buf2) != 0) {",
          "4369:   wbuf[0] = L'\\0';",
          "4370:  }",
          "4381:  if (conn) {",
          "4382:   if (conn->ctx->config[CASE_SENSITIVE_FILES]",
          "4383:       && !mg_strcasecmp(conn->ctx->config[CASE_SENSITIVE_FILES], \"yes\")) {",
          "4385:    fcompare = wcscmp;",
          "4387:  }",
          "4392:  memset(wbuf2, 0, ARRAY_SIZE(wbuf2) * sizeof(wchar_t));",
          "4393:  long_len = GetLongPathNameW(wbuf, wbuf2, ARRAY_SIZE(wbuf2) - 1);",
          "4394:  if (long_len == 0) {",
          "4395:   err = GetLastError();",
          "4396:   if (err == ERROR_FILE_NOT_FOUND) {",
          "4398:    return;",
          "4400:  }",
          "4401:  if ((long_len >= ARRAY_SIZE(wbuf2)) || (fcompare(wbuf, wbuf2) != 0)) {",
          "4403:   wbuf[0] = L'\\0';",
          "4404:  }",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "4363:   wbuf[0] = L'\\0';",
          "4364:  }",
          "4365: #endif",
          "4452:   }",
          "4455:  }",
          "",
          "[Removed Lines]",
          "4366:  }",
          "4373:  static int path_cannot_disclose_cgi(const char *path)",
          "4374:  {",
          "4375:   static const char *allowed_last_characters = \"_-\";",
          "4376:   int last = path[strlen(path) - 1];",
          "4377:   return isalnum(last) || strchr(allowed_last_characters, last) != NULL;",
          "4378:  }",
          "4381:  static int mg_stat(const struct mg_connection *conn,",
          "4382:                     const char *path,",
          "4383:                     struct mg_file_stat *filep)",
          "4384:  {",
          "4385:   wchar_t wbuf[PATH_MAX];",
          "4386:   WIN32_FILE_ATTRIBUTE_DATA info;",
          "4387:   time_t creation_time;",
          "4389:   if (!filep) {",
          "4390:    return 0;",
          "4391:   }",
          "4392:   memset(filep, 0, sizeof(*filep));",
          "4394:   if (conn && is_file_in_memory(conn, path)) {",
          "4400:    struct mg_file tmp_file = STRUCT_FILE_INITIALIZER;",
          "4401:    open_file_in_memory(conn, path, &tmp_file, MG_FOPEN_MODE_NONE);",
          "4402:    filep->size = tmp_file.stat.size;",
          "4403:    filep->location = 2;",
          "4420:    return 1;",
          "4421:   }",
          "4423:   path_to_unicode(conn, path, wbuf, ARRAY_SIZE(wbuf));",
          "4424:   if (GetFileAttributesExW(wbuf, GetFileExInfoStandard, &info) != 0) {",
          "4425:    filep->size = MAKEUQUAD(info.nFileSizeLow, info.nFileSizeHigh);",
          "4426:    filep->last_modified =",
          "4427:        SYS2UNIX_TIME(info.ftLastWriteTime.dwLowDateTime,",
          "4428:                      info.ftLastWriteTime.dwHighDateTime);",
          "4434:    creation_time = SYS2UNIX_TIME(info.ftCreationTime.dwLowDateTime,",
          "4435:                                  info.ftCreationTime.dwHighDateTime);",
          "4436:    if (creation_time > filep->last_modified) {",
          "4437:     filep->last_modified = creation_time;",
          "4438:    }",
          "4440:    filep->is_directory =",
          "4441:        info.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY;",
          "4446:    if (!filep->is_directory && !path_cannot_disclose_cgi(path)) {",
          "4447:     memset(filep, 0, sizeof(*filep));",
          "4448:     return 0;",
          "4449:    }",
          "4451:    return 1;",
          "4454:   return 0;",
          "4458:  static int mg_remove(const struct mg_connection *conn, const char *path)",
          "4459:  {",
          "4460:   wchar_t wbuf[PATH_MAX];",
          "4461:   path_to_unicode(conn, path, wbuf, ARRAY_SIZE(wbuf));",
          "4462:   return DeleteFileW(wbuf) ? 0 : -1;",
          "4463:  }",
          "4466:  static int mg_mkdir(const struct mg_connection *conn,",
          "4467:                      const char *path,",
          "4468:                      int mode)",
          "4469:  {",
          "4470:   wchar_t wbuf[PATH_MAX];",
          "4471:   (void)mode;",
          "4472:   path_to_unicode(conn, path, wbuf, ARRAY_SIZE(wbuf));",
          "4473:   return CreateDirectoryW(wbuf, NULL) ? 0 : -1;",
          "4474:  }",
          "",
          "[Added Lines]",
          "4414: }",
          "4421: static int",
          "4422: path_cannot_disclose_cgi(const char *path)",
          "4423: {",
          "4424:  static const char *allowed_last_characters = \"_-\";",
          "4425:  int last = path[strlen(path) - 1];",
          "4426:  return isalnum(last) || strchr(allowed_last_characters, last) != NULL;",
          "4427: }",
          "4430: static int",
          "4431: mg_stat(const struct mg_connection *conn,",
          "4432:         const char *path,",
          "4433:         struct mg_file_stat *filep)",
          "4434: {",
          "4435:  wchar_t wbuf[PATH_MAX];",
          "4436:  WIN32_FILE_ATTRIBUTE_DATA info;",
          "4437:  time_t creation_time;",
          "4439:  if (!filep) {",
          "4440:   return 0;",
          "4441:  }",
          "4442:  memset(filep, 0, sizeof(*filep));",
          "4444:  if (conn && is_file_in_memory(conn, path)) {",
          "4450:   struct mg_file tmp_file = STRUCT_FILE_INITIALIZER;",
          "4451:   open_file_in_memory(conn, path, &tmp_file, MG_FOPEN_MODE_NONE);",
          "4452:   filep->size = tmp_file.stat.size;",
          "4453:   filep->location = 2;",
          "4470:   return 1;",
          "4471:  }",
          "4473:  path_to_unicode(conn, path, wbuf, ARRAY_SIZE(wbuf));",
          "4474:  if (GetFileAttributesExW(wbuf, GetFileExInfoStandard, &info) != 0) {",
          "4475:   filep->size = MAKEUQUAD(info.nFileSizeLow, info.nFileSizeHigh);",
          "4476:   filep->last_modified =",
          "4477:       SYS2UNIX_TIME(info.ftLastWriteTime.dwLowDateTime,",
          "4478:                     info.ftLastWriteTime.dwHighDateTime);",
          "4484:   creation_time = SYS2UNIX_TIME(info.ftCreationTime.dwLowDateTime,",
          "4485:                                 info.ftCreationTime.dwHighDateTime);",
          "4486:   if (creation_time > filep->last_modified) {",
          "4487:    filep->last_modified = creation_time;",
          "4488:   }",
          "4490:   filep->is_directory = info.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY;",
          "4495:   if (!filep->is_directory && !path_cannot_disclose_cgi(path)) {",
          "4496:    memset(filep, 0, sizeof(*filep));",
          "4497:    return 0;",
          "4500:   return 1;",
          "4503:  return 0;",
          "4504: }",
          "4507: static int",
          "4508: mg_remove(const struct mg_connection *conn, const char *path)",
          "4509: {",
          "4510:  wchar_t wbuf[PATH_MAX];",
          "4511:  path_to_unicode(conn, path, wbuf, ARRAY_SIZE(wbuf));",
          "4512:  return DeleteFileW(wbuf) ? 0 : -1;",
          "4513: }",
          "4516: static int",
          "4517: mg_mkdir(const struct mg_connection *conn, const char *path, int mode)",
          "4518: {",
          "4519:  wchar_t wbuf[PATH_MAX];",
          "4520:  (void)mode;",
          "4521:  path_to_unicode(conn, path, wbuf, ARRAY_SIZE(wbuf));",
          "4522:  return CreateDirectoryW(wbuf, NULL) ? 0 : -1;",
          "4523: }",
          "",
          "---------------",
          "--- Hunk 34 ---",
          "[Context before]",
          "4483: #endif",
          "4498:   } else {",
          "4510:   }",
          "4513:  }",
          "4532:  }",
          "4559:    }",
          "4560:   } else {",
          "4562:   }",
          "4565:  }",
          "4568: #ifndef HAVE_POLL",
          "4590:   }",
          "4597:    }",
          "4598:   }",
          "",
          "[Removed Lines]",
          "4487:  FUNCTION_MAY_BE_UNUSED",
          "4488:  static DIR *mg_opendir(const struct mg_connection *conn, const char *name)",
          "4489:  {",
          "4490:   DIR *dir = NULL;",
          "4491:   wchar_t wpath[PATH_MAX];",
          "4492:   DWORD attrs;",
          "4494:   if (name == NULL) {",
          "4495:    SetLastError(ERROR_BAD_ARGUMENTS);",
          "4496:   } else if ((dir = (DIR *)mg_malloc(sizeof(*dir))) == NULL) {",
          "4497:    SetLastError(ERROR_NOT_ENOUGH_MEMORY);",
          "4499:    path_to_unicode(conn, name, wpath, ARRAY_SIZE(wpath));",
          "4500:    attrs = GetFileAttributesW(wpath);",
          "4501:    if (attrs != 0xFFFFFFFF && ((attrs & FILE_ATTRIBUTE_DIRECTORY)",
          "4502:                                == FILE_ATTRIBUTE_DIRECTORY)) {",
          "4503:     (void)wcscat(wpath, L\"\\\\*\");",
          "4504:     dir->handle = FindFirstFileW(wpath, &dir->info);",
          "4505:     dir->result.d_name[0] = '\\0';",
          "4506:    } else {",
          "4507:     mg_free(dir);",
          "4508:     dir = NULL;",
          "4509:    }",
          "4512:   return dir;",
          "4516:  FUNCTION_MAY_BE_UNUSED",
          "4517:  static int mg_closedir(DIR * dir)",
          "4518:  {",
          "4519:   int result = 0;",
          "4521:   if (dir != NULL) {",
          "4522:    if (dir->handle != INVALID_HANDLE_VALUE)",
          "4523:     result = FindClose(dir->handle) ? 0 : -1;",
          "4525:    mg_free(dir);",
          "4526:   } else {",
          "4527:    result = -1;",
          "4528:    SetLastError(ERROR_BAD_ARGUMENTS);",
          "4529:   }",
          "4531:   return result;",
          "4535:  FUNCTION_MAY_BE_UNUSED",
          "4536:  static struct dirent *mg_readdir(DIR * dir)",
          "4537:  {",
          "4538:   struct dirent *result = 0;",
          "4540:   if (dir) {",
          "4541:    if (dir->handle != INVALID_HANDLE_VALUE) {",
          "4542:     result = &dir->result;",
          "4543:     (void)WideCharToMultiByte(CP_UTF8,",
          "4544:                               0,",
          "4545:                               dir->info.cFileName,",
          "4546:                               -1,",
          "4547:                               result->d_name,",
          "4548:                               sizeof(result->d_name),",
          "4549:                               NULL,",
          "4550:                               NULL);",
          "4552:     if (!FindNextFileW(dir->handle, &dir->info)) {",
          "4553:      (void)FindClose(dir->handle);",
          "4554:      dir->handle = INVALID_HANDLE_VALUE;",
          "4555:     }",
          "4557:    } else {",
          "4558:     SetLastError(ERROR_FILE_NOT_FOUND);",
          "4561:    SetLastError(ERROR_BAD_ARGUMENTS);",
          "4564:   return result;",
          "4569:  FUNCTION_MAY_BE_UNUSED",
          "4570:  static int poll(struct pollfd * pfd, unsigned int n, int milliseconds)",
          "4571:  {",
          "4572:   struct timeval tv;",
          "4573:   fd_set set;",
          "4574:   unsigned int i;",
          "4575:   int result;",
          "4576:   SOCKET maxfd = 0;",
          "4578:   memset(&tv, 0, sizeof(tv));",
          "4579:   tv.tv_sec = milliseconds / 1000;",
          "4580:   tv.tv_usec = (milliseconds % 1000) * 1000;",
          "4581:   FD_ZERO(&set);",
          "4583:   for (i = 0; i < n; i++) {",
          "4584:    FD_SET((SOCKET)pfd[i].fd, &set);",
          "4585:    pfd[i].revents = 0;",
          "4587:    if (pfd[i].fd > maxfd) {",
          "4588:     maxfd = pfd[i].fd;",
          "4589:    }",
          "4592:   if ((result = select((int)maxfd + 1, &set, NULL, NULL, &tv)) > 0) {",
          "4593:    for (i = 0; i < n; i++) {",
          "4594:     if (FD_ISSET(pfd[i].fd, &set)) {",
          "4595:      pfd[i].revents = POLLIN;",
          "4596:     }",
          "4607:   return result;",
          "4608:  }",
          "",
          "[Added Lines]",
          "4536: FUNCTION_MAY_BE_UNUSED",
          "4537: static DIR *",
          "4538: mg_opendir(const struct mg_connection *conn, const char *name)",
          "4539: {",
          "4540:  DIR *dir = NULL;",
          "4541:  wchar_t wpath[PATH_MAX];",
          "4542:  DWORD attrs;",
          "4544:  if (name == NULL) {",
          "4545:   SetLastError(ERROR_BAD_ARGUMENTS);",
          "4546:  } else if ((dir = (DIR *)mg_malloc(sizeof(*dir))) == NULL) {",
          "4547:   SetLastError(ERROR_NOT_ENOUGH_MEMORY);",
          "4548:  } else {",
          "4549:   path_to_unicode(conn, name, wpath, ARRAY_SIZE(wpath));",
          "4550:   attrs = GetFileAttributesW(wpath);",
          "4551:   if (attrs != 0xFFFFFFFF && ((attrs & FILE_ATTRIBUTE_DIRECTORY)",
          "4552:                               == FILE_ATTRIBUTE_DIRECTORY)) {",
          "4553:    (void)wcscat(wpath, L\"\\\\*\");",
          "4554:    dir->handle = FindFirstFileW(wpath, &dir->info);",
          "4555:    dir->result.d_name[0] = '\\0';",
          "4557:    mg_free(dir);",
          "4558:    dir = NULL;",
          "4562:  return dir;",
          "4563: }",
          "4566: FUNCTION_MAY_BE_UNUSED",
          "4567: static int",
          "4568: mg_closedir(DIR *dir)",
          "4569: {",
          "4570:  int result = 0;",
          "4572:  if (dir != NULL) {",
          "4573:   if (dir->handle != INVALID_HANDLE_VALUE)",
          "4574:    result = FindClose(dir->handle) ? 0 : -1;",
          "4576:   mg_free(dir);",
          "4577:  } else {",
          "4578:   result = -1;",
          "4579:   SetLastError(ERROR_BAD_ARGUMENTS);",
          "4582:  return result;",
          "4583: }",
          "4586: FUNCTION_MAY_BE_UNUSED",
          "4587: static struct dirent *",
          "4588: mg_readdir(DIR *dir)",
          "4589: {",
          "4590:  struct dirent *result = 0;",
          "4592:  if (dir) {",
          "4593:   if (dir->handle != INVALID_HANDLE_VALUE) {",
          "4594:    result = &dir->result;",
          "4595:    (void)WideCharToMultiByte(CP_UTF8,",
          "4596:                              0,",
          "4597:                              dir->info.cFileName,",
          "4598:                              -1,",
          "4599:                              result->d_name,",
          "4600:                              sizeof(result->d_name),",
          "4601:                              NULL,",
          "4602:                              NULL);",
          "4604:    if (!FindNextFileW(dir->handle, &dir->info)) {",
          "4605:     (void)FindClose(dir->handle);",
          "4606:     dir->handle = INVALID_HANDLE_VALUE;",
          "4610:    SetLastError(ERROR_FILE_NOT_FOUND);",
          "4612:  } else {",
          "4613:   SetLastError(ERROR_BAD_ARGUMENTS);",
          "4616:  return result;",
          "4617: }",
          "4621: FUNCTION_MAY_BE_UNUSED",
          "4622: static int",
          "4623: poll(struct pollfd *pfd, unsigned int n, int milliseconds)",
          "4624: {",
          "4625:  struct timeval tv;",
          "4626:  fd_set set;",
          "4627:  unsigned int i;",
          "4628:  int result;",
          "4629:  SOCKET maxfd = 0;",
          "4631:  memset(&tv, 0, sizeof(tv));",
          "4632:  tv.tv_sec = milliseconds / 1000;",
          "4633:  tv.tv_usec = (milliseconds % 1000) * 1000;",
          "4634:  FD_ZERO(&set);",
          "4636:  for (i = 0; i < n; i++) {",
          "4637:   FD_SET((SOCKET)pfd[i].fd, &set);",
          "4638:   pfd[i].revents = 0;",
          "4640:   if (pfd[i].fd > maxfd) {",
          "4641:    maxfd = pfd[i].fd;",
          "4643:  }",
          "4645:  if ((result = select((int)maxfd + 1, &set, NULL, NULL, &tv)) > 0) {",
          "4646:   for (i = 0; i < n; i++) {",
          "4647:    if (FD_ISSET(pfd[i].fd, &set)) {",
          "4648:     pfd[i].revents = POLLIN;",
          "4651:  }",
          "4660:  return result;",
          "4661: }",
          "",
          "---------------",
          "--- Hunk 35 ---",
          "[Context before]",
          "4615: #endif",
          "4622: #if defined(_WIN32_WCE)",
          "4624: #else",
          "4625:  (void)SetHandleInformation((HANDLE)(intptr_t)sock, HANDLE_FLAG_INHERIT, 0);",
          "4626: #endif",
          "4632: #if defined(USE_STACK_SIZE) && (USE_STACK_SIZE > 1)",
          "4640: #else",
          "4641:  return (",
          "4642:      (_beginthread((void(__cdecl *)(void *))f, 0, p) == ((uintptr_t)(-1L)))",
          "4643:          ? -1",
          "4644:          : 0);",
          "4667:  }",
          "4688:  }",
          "4690: #if !defined(NO_SSL_DL) && !defined(NO_SSL)",
          "",
          "[Removed Lines]",
          "4618:  static void set_close_on_exec(SOCKET sock,",
          "4619:                                struct mg_connection * conn /* may be null */)",
          "4620:  {",
          "4623:   (void)sock;",
          "4627:  }",
          "4630:  int mg_start_thread(mg_thread_func_t f, void *p)",
          "4631:  {",
          "4636:   return ((_beginthread((void(__cdecl *)(void *))f, USE_STACK_SIZE, p)",
          "4637:            == ((uintptr_t)(-1L)))",
          "4638:               ? -1",
          "4639:               : 0);",
          "4646:  }",
          "4650:  static int mg_start_thread_with_id(unsigned(__stdcall * f)(void *),",
          "4651:                                     void *p,",
          "4652:                                     pthread_t *threadidptr)",
          "4653:  {",
          "4654:   uintptr_t uip;",
          "4655:   HANDLE threadhandle;",
          "4656:   int result = -1;",
          "4658:   uip = _beginthreadex(",
          "4659:       NULL, 0, (unsigned(__stdcall *)(void *))f, p, 0, NULL);",
          "4660:   threadhandle = (HANDLE)uip;",
          "4661:   if ((uip != (uintptr_t)(-1L)) && (threadidptr != NULL)) {",
          "4663:    result = 0;",
          "4664:   }",
          "4666:   return result;",
          "4671:  static int mg_join_thread(pthread_t threadid)",
          "4672:  {",
          "4673:   int result;",
          "4674:   DWORD dwevent;",
          "4676:   result = -1;",
          "4677:   dwevent = WaitForSingleObject(threadid, INFINITE);",
          "4678:   if (dwevent == WAIT_FAILED) {",
          "4679:    DEBUG_TRACE(\"WaitForSingleObject() failed, error %d\", ERRNO);",
          "4680:   } else {",
          "4681:    if (dwevent == WAIT_OBJECT_0) {",
          "4682:     CloseHandle(threadid);",
          "4683:     result = 0;",
          "4684:    }",
          "4685:   }",
          "4687:   return result;",
          "",
          "[Added Lines]",
          "4671: static void",
          "4672: set_close_on_exec(SOCKET sock, struct mg_connection *conn /* may be null */)",
          "4673: {",
          "4676:  (void)sock;",
          "4680: }",
          "4683: int",
          "4684: mg_start_thread(mg_thread_func_t f, void *p)",
          "4685: {",
          "4690:  return ((_beginthread((void(__cdecl *)(void *))f, USE_STACK_SIZE, p)",
          "4691:           == ((uintptr_t)(-1L)))",
          "4692:              ? -1",
          "4693:              : 0);",
          "4700: }",
          "4704: static int",
          "4705: mg_start_thread_with_id(unsigned(__stdcall *f)(void *),",
          "4706:                         void *p,",
          "4707:                         pthread_t *threadidptr)",
          "4708: {",
          "4709:  uintptr_t uip;",
          "4710:  HANDLE threadhandle;",
          "4711:  int result = -1;",
          "4713:  uip = _beginthreadex(NULL, 0, (unsigned(__stdcall *)(void *))f, p, 0, NULL);",
          "4714:  threadhandle = (HANDLE)uip;",
          "4715:  if ((uip != (uintptr_t)(-1L)) && (threadidptr != NULL)) {",
          "4717:   result = 0;",
          "4720:  return result;",
          "4721: }",
          "4725: static int",
          "4726: mg_join_thread(pthread_t threadid)",
          "4727: {",
          "4728:  int result;",
          "4729:  DWORD dwevent;",
          "4731:  result = -1;",
          "4732:  dwevent = WaitForSingleObject(threadid, INFINITE);",
          "4733:  if (dwevent == WAIT_FAILED) {",
          "4734:   DEBUG_TRACE(\"WaitForSingleObject() failed, error %d\", ERRNO);",
          "4735:  } else {",
          "4736:   if (dwevent == WAIT_OBJECT_0) {",
          "4737:    CloseHandle(threadid);",
          "4738:    result = 0;",
          "4739:   }",
          "4742:  return result;",
          "4743: }",
          "",
          "---------------",
          "--- Hunk 36 ---",
          "[Context before]",
          "4698: #endif",
          "4723:  }",
          "4726: #if defined(__MINGW32__)",
          "",
          "[Removed Lines]",
          "4701:  FUNCTION_MAY_BE_UNUSED",
          "4702:  static HANDLE dlopen(const char *dll_name, int flags)",
          "4703:  {",
          "4704:   wchar_t wbuf[PATH_MAX];",
          "4705:   (void)flags;",
          "4706:   path_to_unicode(NULL, dll_name, wbuf, ARRAY_SIZE(wbuf));",
          "4707:   return LoadLibraryW(wbuf);",
          "4708:  }",
          "4711:  FUNCTION_MAY_BE_UNUSED",
          "4712:  static int dlclose(void *handle)",
          "4713:  {",
          "4714:   int result;",
          "4716:   if (FreeLibrary((HMODULE)handle) != 0) {",
          "4717:    result = 0;",
          "4718:   } else {",
          "4719:    result = -1;",
          "4720:   }",
          "4722:   return result;",
          "",
          "[Added Lines]",
          "4756: FUNCTION_MAY_BE_UNUSED",
          "4757: static HANDLE",
          "4758: dlopen(const char *dll_name, int flags)",
          "4759: {",
          "4760:  wchar_t wbuf[PATH_MAX];",
          "4761:  (void)flags;",
          "4762:  path_to_unicode(NULL, dll_name, wbuf, ARRAY_SIZE(wbuf));",
          "4763:  return LoadLibraryW(wbuf);",
          "4764: }",
          "4767: FUNCTION_MAY_BE_UNUSED",
          "4768: static int",
          "4769: dlclose(void *handle)",
          "4770: {",
          "4771:  int result;",
          "4773:  if (FreeLibrary((HMODULE)handle) != 0) {",
          "4774:   result = 0;",
          "4775:  } else {",
          "4776:   result = -1;",
          "4779:  return result;",
          "4780: }",
          "",
          "---------------",
          "--- Hunk 37 ---",
          "[Context before]",
          "4734: #if !defined(NO_CGI)",
          "4735: #define SIGKILL (0)",
          "4751:  }",
          "4870:   if (truncated) {",
          "4871:    pi.hProcess = (pid_t)-1;",
          "4872:    goto spawn_cleanup;",
          "4873:   }",
          "4893:   }",
          "4901:   }",
          "4904:  }",
          "4914: #else",
          "",
          "[Removed Lines]",
          "4737:  static int kill(pid_t pid, int sig_num)",
          "4738:  {",
          "4739:   (void)TerminateProcess((HANDLE)pid, (UINT)sig_num);",
          "4740:   (void)CloseHandle((HANDLE)pid);",
          "4741:   return 0;",
          "4742:  }",
          "4745:  static void trim_trailing_whitespaces(char *s)",
          "4746:  {",
          "4747:   char *e = s + strlen(s) - 1;",
          "4748:   while ((e > s) && isspace(*(unsigned char *)e)) {",
          "4750:   }",
          "4754:  static pid_t spawn_process(struct mg_connection * conn,",
          "4755:                             const char *prog,",
          "4756:                             char *envblk,",
          "4757:                             char *envp[],",
          "4758:                             int fdin[2],",
          "4759:                             int fdout[2],",
          "4760:                             int fderr[2],",
          "4761:                             const char *dir)",
          "4762:  {",
          "4763:   HANDLE me;",
          "4764:   char *p, *interp, full_interp[PATH_MAX], full_dir[PATH_MAX],",
          "4765:       cmdline[PATH_MAX], buf[PATH_MAX];",
          "4766:   int truncated;",
          "4767:   struct mg_file file = STRUCT_FILE_INITIALIZER;",
          "4768:   STARTUPINFOA si;",
          "4769:   PROCESS_INFORMATION pi = {0};",
          "4771:   (void)envp;",
          "4773:   memset(&si, 0, sizeof(si));",
          "4774:   si.cb = sizeof(si);",
          "4776:   si.dwFlags = STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW;",
          "4777:   si.wShowWindow = SW_HIDE;",
          "4779:   me = GetCurrentProcess();",
          "4780:   DuplicateHandle(me,",
          "4781:                   (HANDLE)_get_osfhandle(fdin[0]),",
          "4782:                   me,",
          "4783:                   &si.hStdInput,",
          "4784:                   0,",
          "4785:                   TRUE,",
          "4786:                   DUPLICATE_SAME_ACCESS);",
          "4787:   DuplicateHandle(me,",
          "4788:                   (HANDLE)_get_osfhandle(fdout[1]),",
          "4789:                   me,",
          "4790:                   &si.hStdOutput,",
          "4791:                   0,",
          "4792:                   TRUE,",
          "4793:                   DUPLICATE_SAME_ACCESS);",
          "4794:   DuplicateHandle(me,",
          "4795:                   (HANDLE)_get_osfhandle(fderr[1]),",
          "4796:                   me,",
          "4797:                   &si.hStdError,",
          "4798:                   0,",
          "4799:                   TRUE,",
          "4800:                   DUPLICATE_SAME_ACCESS);",
          "4805:   SetHandleInformation((HANDLE)_get_osfhandle(fdin[1]),",
          "4806:                        HANDLE_FLAG_INHERIT,",
          "4807:                        0);",
          "4808:   SetHandleInformation((HANDLE)_get_osfhandle(fdout[0]),",
          "4809:                        HANDLE_FLAG_INHERIT,",
          "4810:                        0);",
          "4811:   SetHandleInformation((HANDLE)_get_osfhandle(fderr[0]),",
          "4812:                        HANDLE_FLAG_INHERIT,",
          "4813:                        0);",
          "4816:   interp = conn->ctx->config[CGI_INTERPRETER];",
          "4817:   if (interp == NULL) {",
          "4818:    buf[0] = buf[1] = '\\0';",
          "4821:    mg_snprintf(",
          "4822:        conn, &truncated, cmdline, sizeof(cmdline), \"%s/%s\", dir, prog);",
          "4824:    if (truncated) {",
          "4825:     pi.hProcess = (pid_t)-1;",
          "4826:     goto spawn_cleanup;",
          "4827:    }",
          "4829:    if (mg_fopen(conn, cmdline, MG_FOPEN_MODE_READ, &file)) {",
          "4830:     p = (char *)file.access.membuf;",
          "4831:     mg_fgets(buf, sizeof(buf), &file, &p);",
          "4832:     (void)mg_fclose(",
          "4834:     buf[sizeof(buf) - 1] = '\\0';",
          "4835:    }",
          "4837:    if ((buf[0] == '#') && (buf[1] == '!')) {",
          "4838:     trim_trailing_whitespaces(buf + 2);",
          "4839:    } else {",
          "4840:     buf[2] = '\\0';",
          "4841:    }",
          "4842:    interp = buf + 2;",
          "4843:   }",
          "4845:   if (interp[0] != '\\0') {",
          "4846:    GetFullPathNameA(interp, sizeof(full_interp), full_interp, NULL);",
          "4847:    interp = full_interp;",
          "4848:   }",
          "4849:   GetFullPathNameA(dir, sizeof(full_dir), full_dir, NULL);",
          "4851:   if (interp[0] != '\\0') {",
          "4852:    mg_snprintf(conn,",
          "4853:                &truncated,",
          "4854:                cmdline,",
          "4855:                sizeof(cmdline),",
          "4856:                \"\\\"%s\\\" \\\"%s\\\\%s\\\"\",",
          "4857:                interp,",
          "4858:                full_dir,",
          "4859:                prog);",
          "4860:   } else {",
          "4861:    mg_snprintf(conn,",
          "4862:                &truncated,",
          "4863:                cmdline,",
          "4864:                sizeof(cmdline),",
          "4865:                \"\\\"%s\\\\%s\\\"\",",
          "4866:                full_dir,",
          "4867:                prog);",
          "4868:   }",
          "4875:   DEBUG_TRACE(\"Running [%s]\", cmdline);",
          "4876:   if (CreateProcessA(NULL,",
          "4877:                      cmdline,",
          "4878:                      NULL,",
          "4879:                      NULL,",
          "4880:                      TRUE,",
          "4881:                      CREATE_NEW_PROCESS_GROUP,",
          "4882:                      envblk,",
          "4883:                      NULL,",
          "4884:                      &si,",
          "4885:                      &pi) == 0) {",
          "4886:    mg_cry(conn,",
          "4887:           \"%s: CreateProcess(%s): %ld\",",
          "4888:           __func__,",
          "4889:           cmdline,",
          "4890:           (long)ERRNO);",
          "4891:    pi.hProcess = (pid_t)-1;",
          "4895:  spawn_cleanup:",
          "4896:   (void)CloseHandle(si.hStdOutput);",
          "4897:   (void)CloseHandle(si.hStdError);",
          "4898:   (void)CloseHandle(si.hStdInput);",
          "4899:   if (pi.hThread != NULL) {",
          "4900:    (void)CloseHandle(pi.hThread);",
          "4903:   return (pid_t)pi.hProcess;",
          "4908:  static int set_blocking_mode(SOCKET sock, int blocking)",
          "4909:  {",
          "4910:   unsigned long non_blocking = !blocking;",
          "4911:   return ioctlsocket(sock, (long)FIONBIO, &non_blocking);",
          "4912:  }",
          "",
          "[Added Lines]",
          "4794: static int",
          "4795: kill(pid_t pid, int sig_num)",
          "4796: {",
          "4797:  (void)TerminateProcess((HANDLE)pid, (UINT)sig_num);",
          "4798:  (void)CloseHandle((HANDLE)pid);",
          "4799:  return 0;",
          "4800: }",
          "4803: static void",
          "4804: trim_trailing_whitespaces(char *s)",
          "4805: {",
          "4806:  char *e = s + strlen(s) - 1;",
          "4807:  while ((e > s) && isspace(*(unsigned char *)e)) {",
          "4810: }",
          "4813: static pid_t",
          "4814: spawn_process(struct mg_connection *conn,",
          "4815:               const char *prog,",
          "4816:               char *envblk,",
          "4817:               char *envp[],",
          "4818:               int fdin[2],",
          "4819:               int fdout[2],",
          "4820:               int fderr[2],",
          "4821:               const char *dir)",
          "4822: {",
          "4823:  HANDLE me;",
          "4824:  char *p, *interp, full_interp[PATH_MAX], full_dir[PATH_MAX],",
          "4825:      cmdline[PATH_MAX], buf[PATH_MAX];",
          "4826:  int truncated;",
          "4827:  struct mg_file file = STRUCT_FILE_INITIALIZER;",
          "4828:  STARTUPINFOA si;",
          "4829:  PROCESS_INFORMATION pi = {0};",
          "4831:  (void)envp;",
          "4833:  memset(&si, 0, sizeof(si));",
          "4834:  si.cb = sizeof(si);",
          "4836:  si.dwFlags = STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW;",
          "4837:  si.wShowWindow = SW_HIDE;",
          "4839:  me = GetCurrentProcess();",
          "4840:  DuplicateHandle(me,",
          "4841:                  (HANDLE)_get_osfhandle(fdin[0]),",
          "4842:                  me,",
          "4843:                  &si.hStdInput,",
          "4844:                  0,",
          "4845:                  TRUE,",
          "4846:                  DUPLICATE_SAME_ACCESS);",
          "4847:  DuplicateHandle(me,",
          "4848:                  (HANDLE)_get_osfhandle(fdout[1]),",
          "4849:                  me,",
          "4850:                  &si.hStdOutput,",
          "4851:                  0,",
          "4852:                  TRUE,",
          "4853:                  DUPLICATE_SAME_ACCESS);",
          "4854:  DuplicateHandle(me,",
          "4855:                  (HANDLE)_get_osfhandle(fderr[1]),",
          "4856:                  me,",
          "4857:                  &si.hStdError,",
          "4858:                  0,",
          "4859:                  TRUE,",
          "4860:                  DUPLICATE_SAME_ACCESS);",
          "4865:  SetHandleInformation((HANDLE)_get_osfhandle(fdin[1]),",
          "4866:                       HANDLE_FLAG_INHERIT,",
          "4867:                       0);",
          "4868:  SetHandleInformation((HANDLE)_get_osfhandle(fdout[0]),",
          "4869:                       HANDLE_FLAG_INHERIT,",
          "4870:                       0);",
          "4871:  SetHandleInformation((HANDLE)_get_osfhandle(fderr[0]),",
          "4872:                       HANDLE_FLAG_INHERIT,",
          "4873:                       0);",
          "4876:  interp = conn->ctx->config[CGI_INTERPRETER];",
          "4877:  if (interp == NULL) {",
          "4878:   buf[0] = buf[1] = '\\0';",
          "4881:   mg_snprintf(",
          "4882:       conn, &truncated, cmdline, sizeof(cmdline), \"%s/%s\", dir, prog);",
          "4889:   if (mg_fopen(conn, cmdline, MG_FOPEN_MODE_READ, &file)) {",
          "4890:    p = (char *)file.access.membuf;",
          "4891:    mg_fgets(buf, sizeof(buf), &file, &p);",
          "4893:    buf[sizeof(buf) - 1] = '\\0';",
          "4896:   if ((buf[0] == '#') && (buf[1] == '!')) {",
          "4897:    trim_trailing_whitespaces(buf + 2);",
          "4898:   } else {",
          "4899:    buf[2] = '\\0';",
          "4901:   interp = buf + 2;",
          "4902:  }",
          "4904:  if (interp[0] != '\\0') {",
          "4905:   GetFullPathNameA(interp, sizeof(full_interp), full_interp, NULL);",
          "4906:   interp = full_interp;",
          "4908:  GetFullPathNameA(dir, sizeof(full_dir), full_dir, NULL);",
          "4910:  if (interp[0] != '\\0') {",
          "4911:   mg_snprintf(conn,",
          "4912:               &truncated,",
          "4913:               cmdline,",
          "4914:               sizeof(cmdline),",
          "4915:               \"\\\"%s\\\" \\\"%s\\\\%s\\\"\",",
          "4916:               interp,",
          "4917:               full_dir,",
          "4918:               prog);",
          "4919:  } else {",
          "4920:   mg_snprintf(conn,",
          "4921:               &truncated,",
          "4922:               cmdline,",
          "4923:               sizeof(cmdline),",
          "4924:               \"\\\"%s\\\\%s\\\"\",",
          "4925:               full_dir,",
          "4926:               prog);",
          "4927:  }",
          "4929:  if (truncated) {",
          "4930:   pi.hProcess = (pid_t)-1;",
          "4931:   goto spawn_cleanup;",
          "4932:  }",
          "4934:  DEBUG_TRACE(\"Running [%s]\", cmdline);",
          "4935:  if (CreateProcessA(NULL,",
          "4936:                     cmdline,",
          "4937:                     NULL,",
          "4938:                     NULL,",
          "4939:                     TRUE,",
          "4940:                     CREATE_NEW_PROCESS_GROUP,",
          "4941:                     envblk,",
          "4942:                     NULL,",
          "4943:                     &si,",
          "4944:                     &pi) == 0) {",
          "4945:   mg_cry(",
          "4946:       conn, \"%s: CreateProcess(%s): %ld\", __func__, cmdline, (long)ERRNO);",
          "4947:   pi.hProcess = (pid_t)-1;",
          "4949:  }",
          "4951: spawn_cleanup:",
          "4952:  (void)CloseHandle(si.hStdOutput);",
          "4953:  (void)CloseHandle(si.hStdError);",
          "4954:  (void)CloseHandle(si.hStdInput);",
          "4955:  if (pi.hThread != NULL) {",
          "4956:   (void)CloseHandle(pi.hThread);",
          "4957:  }",
          "4959:  return (pid_t)pi.hProcess;",
          "4960: }",
          "4964: static int",
          "4965: set_blocking_mode(SOCKET sock, int blocking)",
          "4966: {",
          "4967:  unsigned long non_blocking = !blocking;",
          "4968:  return ioctlsocket(sock, (long)FIONBIO, &non_blocking);",
          "4969: }",
          "",
          "---------------",
          "--- Hunk 38 ---",
          "[Context before]",
          "5133:  return 0;",
          "5134: }",
          "5166:  }",
          "5228: #ifdef _WIN32",
          "5230: #else",
          "5231:  typedef size_t len_t;",
          "5232: #endif",
          "5244: #ifdef NO_SSL",
          "5248: #endif",
          "5254: #ifndef NO_SSL",
          "5277:      err = ERRNO;",
          "5278:     } else {",
          "5280:     }",
          "5281:    } else {",
          "5284: #ifdef _WIN32",
          "5289: #else",
          "5290:    if (err == EWOULDBLOCK) {",
          "5291:     err = 0;",
          "5292:     n = 0;",
          "5293:    }",
          "5294: #endif",
          "5309:    if (n < 0) {",
          "5319:     return -2;",
          "5320:    }",
          "5335: #if defined(__GNUC__) || defined(__MINGW32__)",
          "",
          "[Removed Lines]",
          "5140:  static uint64_t get_random(void)",
          "5141:  {",
          "5144:   uint64_t now = mg_get_current_time_ns();",
          "5146:   if (lfsr == 0) {",
          "5149:    lfsr = mg_get_current_time_ns();",
          "5150:    lcg = mg_get_current_time_ns();",
          "5151:   } else {",
          "5153:    lfsr =",
          "5154:        (lfsr >> 1)",
          "5155:        | ((((lfsr >> 0) ^ (lfsr >> 1) ^ (lfsr >> 3) ^ (lfsr >> 4)) & 1)",
          "5156:           << 63);",
          "5157:    lcg = lcg * 6364136223846793005LL + 1442695040888963407LL;",
          "5158:   }",
          "5165:   return (lfsr ^ lcg ^ now);",
          "5169:  static int mg_poll(struct pollfd * pfd,",
          "5170:                     unsigned int n,",
          "5171:                     int milliseconds,",
          "5172:                     volatile int *stop_server)",
          "5173:  {",
          "5174:   int ms_now, result;",
          "5181:   do {",
          "5182:    if (*stop_server) {",
          "5184:     return -2;",
          "5185:    }",
          "5187:    if ((milliseconds >= 0) && (milliseconds < ms_now)) {",
          "5188:     ms_now = milliseconds;",
          "5189:    }",
          "5191:    result = poll(pfd, n, ms_now);",
          "5192:    if (result != 0) {",
          "5195:     return result;",
          "5196:    }",
          "5199:    if (milliseconds > 0) {",
          "5200:     milliseconds -= ms_now;",
          "5201:    }",
          "5203:   } while (milliseconds != 0);",
          "5205:   return result;",
          "5206:  }",
          "5216:  static int push_inner(struct mg_context * ctx,",
          "5217:                        FILE * fp,",
          "5218:                        SOCKET sock,",
          "5219:                        SSL * ssl,",
          "5220:                        const char *buf,",
          "5221:                        int len,",
          "5222:                        double timeout)",
          "5223:  {",
          "5224:   uint64_t start = 0, now = 0, timeout_ns = 0;",
          "5225:   int n, err;",
          "5229:   typedef int len_t;",
          "5234:   if (timeout > 0) {",
          "5235:    now = mg_get_current_time_ns();",
          "5236:    start = now;",
          "5237:    timeout_ns = (uint64_t)(timeout * 1.0E9);",
          "5238:   }",
          "5240:   if (ctx == NULL) {",
          "5241:    return -2;",
          "5242:   }",
          "5245:   if (ssl) {",
          "5246:    return -2;",
          "5247:   }",
          "5252:   for (;;) {",
          "5255:    if (ssl != NULL) {",
          "5256:     n = SSL_write(ssl, buf, len);",
          "5257:     if (n <= 0) {",
          "5258:      err = SSL_get_error(ssl, n);",
          "5259:      if ((err == SSL_ERROR_SYSCALL) && (n == -1)) {",
          "5260:       err = ERRNO;",
          "5261:      } else if ((err == SSL_ERROR_WANT_READ)",
          "5262:                 || (err == SSL_ERROR_WANT_WRITE)) {",
          "5263:       n = 0;",
          "5264:      } else {",
          "5265:       DEBUG_TRACE(\"SSL_write() failed, error %d\", err);",
          "5266:       return -2;",
          "5267:      }",
          "5268:     } else {",
          "5269:      err = 0;",
          "5270:     }",
          "5271:    } else",
          "5272: #endif",
          "5273:        if (fp != NULL) {",
          "5274:     n = (int)fwrite(buf, 1, (size_t)len, fp);",
          "5275:     if (ferror(fp)) {",
          "5276:      n = -1;",
          "5279:      err = 0;",
          "5282:     n = (int)send(sock, buf, (len_t)len, MSG_NOSIGNAL);",
          "5283:     err = (n < 0) ? ERRNO : 0;",
          "5285:     if (err == WSAEWOULDBLOCK) {",
          "5286:      err = 0;",
          "5287:      n = 0;",
          "5288:     }",
          "5295:     if (n < 0) {",
          "5297:      return -2;",
          "5298:     }",
          "5299:    }",
          "5301:    if (ctx->stop_flag) {",
          "5302:     return -2;",
          "5303:    }",
          "5305:    if ((n > 0) || ((n == 0) && (len == 0))) {",
          "5307:     return n;",
          "5308:    }",
          "5311:     DEBUG_TRACE(\"send() failed, error %d\", err);",
          "5325:    if (fp != NULL) {",
          "5328:     mg_sleep(ms_wait > 10 ? 10 : ms_wait);",
          "5329:    } else {",
          "5331:     fd_set wfds;",
          "5332:     struct timeval tv;",
          "5333:     int sret;",
          "",
          "[Added Lines]",
          "5197: static uint64_t",
          "5198: get_random(void)",
          "5199: {",
          "5202:  uint64_t now = mg_get_current_time_ns();",
          "5204:  if (lfsr == 0) {",
          "5207:   lfsr = mg_get_current_time_ns();",
          "5208:   lcg = mg_get_current_time_ns();",
          "5209:  } else {",
          "5211:   lfsr = (lfsr >> 1)",
          "5212:          | ((((lfsr >> 0) ^ (lfsr >> 1) ^ (lfsr >> 3) ^ (lfsr >> 4)) & 1)",
          "5213:             << 63);",
          "5214:   lcg = lcg * 6364136223846793005LL + 1442695040888963407LL;",
          "5222:  return (lfsr ^ lcg ^ now);",
          "5223: }",
          "5226: static int",
          "5227: mg_poll(struct pollfd *pfd,",
          "5228:         unsigned int n,",
          "5229:         int milliseconds,",
          "5230:         volatile int *stop_server)",
          "5231: {",
          "5232:  int ms_now, result;",
          "5239:  do {",
          "5240:   if (*stop_server) {",
          "5242:    return -2;",
          "5243:   }",
          "5245:   if ((milliseconds >= 0) && (milliseconds < ms_now)) {",
          "5246:    ms_now = milliseconds;",
          "5247:   }",
          "5249:   result = poll(pfd, n, ms_now);",
          "5250:   if (result != 0) {",
          "5253:    return result;",
          "5254:   }",
          "5257:   if (milliseconds > 0) {",
          "5258:    milliseconds -= ms_now;",
          "5259:   }",
          "5261:  } while (milliseconds != 0);",
          "5263:  return result;",
          "5264: }",
          "5274: static int",
          "5275: push_inner(struct mg_context *ctx,",
          "5276:            FILE *fp,",
          "5277:            SOCKET sock,",
          "5278:            SSL *ssl,",
          "5279:            const char *buf,",
          "5280:            int len,",
          "5281:            double timeout)",
          "5282: {",
          "5283:  uint64_t start = 0, now = 0, timeout_ns = 0;",
          "5284:  int n, err;",
          "5288:  typedef int len_t;",
          "5293:  if (timeout > 0) {",
          "5294:   now = mg_get_current_time_ns();",
          "5295:   start = now;",
          "5296:   timeout_ns = (uint64_t)(timeout * 1.0E9);",
          "5297:  }",
          "5299:  if (ctx == NULL) {",
          "5300:   return -2;",
          "5301:  }",
          "5304:  if (ssl) {",
          "5305:   return -2;",
          "5306:  }",
          "5311:  for (;;) {",
          "5314:   if (ssl != NULL) {",
          "5315:    n = SSL_write(ssl, buf, len);",
          "5316:    if (n <= 0) {",
          "5317:     err = SSL_get_error(ssl, n);",
          "5318:     if ((err == SSL_ERROR_SYSCALL) && (n == -1)) {",
          "5320:     } else if ((err == SSL_ERROR_WANT_READ)",
          "5321:                || (err == SSL_ERROR_WANT_WRITE)) {",
          "5322:      n = 0;",
          "5324:      DEBUG_TRACE(\"SSL_write() failed, error %d\", err);",
          "5325:      return -2;",
          "5328:     err = 0;",
          "5329:    }",
          "5330:   } else",
          "5331: #endif",
          "5332:       if (fp != NULL) {",
          "5333:    n = (int)fwrite(buf, 1, (size_t)len, fp);",
          "5334:    if (ferror(fp)) {",
          "5335:     n = -1;",
          "5336:     err = ERRNO;",
          "5337:    } else {",
          "5338:     err = 0;",
          "5339:    }",
          "5340:   } else {",
          "5341:    n = (int)send(sock, buf, (len_t)len, MSG_NOSIGNAL);",
          "5342:    err = (n < 0) ? ERRNO : 0;",
          "5344:    if (err == WSAEWOULDBLOCK) {",
          "5345:     err = 0;",
          "5346:     n = 0;",
          "5347:    }",
          "5358:   }",
          "5360:   if (ctx->stop_flag) {",
          "5361:    return -2;",
          "5362:   }",
          "5364:   if ((n > 0) || ((n == 0) && (len == 0))) {",
          "5366:    return n;",
          "5367:   }",
          "5368:   if (n < 0) {",
          "5370:    DEBUG_TRACE(\"send() failed, error %d\", err);",
          "5378:    return -2;",
          "5379:   }",
          "5384:   if (fp != NULL) {",
          "5387:    mg_sleep(ms_wait > 10 ? 10 : ms_wait);",
          "5388:   } else {",
          "5390:    fd_set wfds;",
          "5391:    struct timeval tv;",
          "5392:    int sret;",
          "",
          "---------------",
          "--- Hunk 39 ---",
          "[Context before]",
          "5340: #pragma GCC diagnostic ignored \"-Wsign-conversion\"",
          "5341: #endif",
          "5350: #if defined(__GNUC__) || defined(__MINGW32__)",
          "5351: #pragma GCC diagnostic pop",
          "5352: #endif",
          "5359:    }",
          "5367:    }",
          "5368:   }",
          "5409:    }",
          "5410:   }",
          "5413:  }",
          "5430: #ifdef _WIN32",
          "5432: #else",
          "5433:  typedef size_t len_t;",
          "5434: #endif",
          "5435: #ifndef NO_SSL",
          "5437: #endif",
          "5445: #if !defined(_WIN32_WCE)",
          "5451: #else",
          "5453:   nread = (int)fread(buf, 1, (size_t)len, fp);",
          "5454: #endif",
          "5457: #ifndef NO_SSL",
          "5465:    }",
          "5467:    if (nread <= 0) {",
          "5468:     err = SSL_get_error(conn->ssl, nread);",
          "5469:     if ((err == SSL_ERROR_SYSCALL) && (nread == -1)) {",
          "",
          "[Removed Lines]",
          "5343:     FD_ZERO(&wfds);",
          "5344:     FD_SET(sock, &wfds);",
          "5345:     tv.tv_sec = (time_t)(ms_wait / 1000);",
          "5346:     tv.tv_usec = (long)((ms_wait % 1000) * 1000);",
          "5348:     sret = select((int)sock + 1, NULL, &wfds, NULL, &tv);",
          "5354:     if (sret > 0) {",
          "5357:      continue;",
          "5358:     }",
          "5361:    if (timeout > 0) {",
          "5362:     now = mg_get_current_time_ns();",
          "5363:     if ((now - start) > timeout_ns) {",
          "5365:      break;",
          "5366:     }",
          "5370:   (void)",
          "5371:       err; /* Avoid unused warning if NO_SSL is set and DEBUG_TRACE is not",
          "5374:   return -1;",
          "5375:  }",
          "5378:  static int64_t push_all(struct mg_context * ctx,",
          "5379:                          FILE * fp,",
          "5380:                          SOCKET sock,",
          "5381:                          SSL * ssl,",
          "5382:                          const char *buf,",
          "5383:                          int64_t len)",
          "5384:  {",
          "5385:   double timeout = -1.0;",
          "5386:   int64_t n, nwritten = 0;",
          "5388:   if (ctx == NULL) {",
          "5389:    return -1;",
          "5390:   }",
          "5392:   if (ctx->config[REQUEST_TIMEOUT]) {",
          "5393:    timeout = atoi(ctx->config[REQUEST_TIMEOUT]) / 1000.0;",
          "5394:   }",
          "5396:   while ((len > 0) && (ctx->stop_flag == 0)) {",
          "5397:    n = push_inner(",
          "5398:        ctx, fp, sock, ssl, buf + nwritten, (int)len, timeout);",
          "5399:    if (n < 0) {",
          "5400:     if (nwritten == 0) {",
          "5402:     }",
          "5403:     break;",
          "5404:    } else if (n == 0) {",
          "5406:    } else {",
          "5407:     nwritten += n;",
          "5408:     len -= n;",
          "5412:   return nwritten;",
          "5422:  static int pull_inner(FILE * fp,",
          "5423:                        struct mg_connection * conn,",
          "5424:                        char *buf,",
          "5425:                        int len,",
          "5426:                        double timeout)",
          "5427:  {",
          "5428:   int nread, err = 0;",
          "5431:   typedef int len_t;",
          "5436:   int ssl_pending;",
          "5444:   if (fp != NULL) {",
          "5450:    nread = (int)read(fileno(fp), buf, (size_t)len);",
          "5455:    err = (nread < 0) ? ERRNO : 0;",
          "5458:   } else if ((conn->ssl != NULL)",
          "5459:              && ((ssl_pending = SSL_pending(conn->ssl)) > 0)) {",
          "5463:    if (ssl_pending > len) {",
          "5464:     ssl_pending = len;",
          "5466:    nread = SSL_read(conn->ssl, buf, ssl_pending);",
          "",
          "[Added Lines]",
          "5402:    FD_ZERO(&wfds);",
          "5403:    FD_SET(sock, &wfds);",
          "5404:    tv.tv_sec = (time_t)(ms_wait / 1000);",
          "5405:    tv.tv_usec = (long)((ms_wait % 1000) * 1000);",
          "5407:    sret = select((int)sock + 1, NULL, &wfds, NULL, &tv);",
          "5413:    if (sret > 0) {",
          "5416:     continue;",
          "5418:   }",
          "5420:   if (timeout > 0) {",
          "5421:    now = mg_get_current_time_ns();",
          "5422:    if ((now - start) > timeout_ns) {",
          "5424:     break;",
          "5427:  }",
          "5429:  (void)err; /* Avoid unused warning if NO_SSL is set and DEBUG_TRACE is not",
          "5432:  return -1;",
          "5433: }",
          "5436: static int64_t",
          "5437: push_all(struct mg_context *ctx,",
          "5438:          FILE *fp,",
          "5439:          SOCKET sock,",
          "5440:          SSL *ssl,",
          "5441:          const char *buf,",
          "5442:          int64_t len)",
          "5443: {",
          "5444:  double timeout = -1.0;",
          "5445:  int64_t n, nwritten = 0;",
          "5447:  if (ctx == NULL) {",
          "5448:   return -1;",
          "5449:  }",
          "5451:  if (ctx->config[REQUEST_TIMEOUT]) {",
          "5452:   timeout = atoi(ctx->config[REQUEST_TIMEOUT]) / 1000.0;",
          "5453:  }",
          "5455:  while ((len > 0) && (ctx->stop_flag == 0)) {",
          "5456:   n = push_inner(ctx, fp, sock, ssl, buf + nwritten, (int)len, timeout);",
          "5457:   if (n < 0) {",
          "5458:    if (nwritten == 0) {",
          "5461:    break;",
          "5462:   } else if (n == 0) {",
          "5464:   } else {",
          "5465:    nwritten += n;",
          "5466:    len -= n;",
          "5470:  return nwritten;",
          "5471: }",
          "5480: static int",
          "5481: pull_inner(FILE *fp,",
          "5482:            struct mg_connection *conn,",
          "5483:            char *buf,",
          "5484:            int len,",
          "5485:            double timeout)",
          "5486: {",
          "5487:  int nread, err = 0;",
          "5490:  typedef int len_t;",
          "5495:  int ssl_pending;",
          "5503:  if (fp != NULL) {",
          "5509:   nread = (int)read(fileno(fp), buf, (size_t)len);",
          "5514:   err = (nread < 0) ? ERRNO : 0;",
          "5517:  } else if ((conn->ssl != NULL)",
          "5518:             && ((ssl_pending = SSL_pending(conn->ssl)) > 0)) {",
          "5522:   if (ssl_pending > len) {",
          "5523:    ssl_pending = len;",
          "5524:   }",
          "5525:   nread = SSL_read(conn->ssl, buf, ssl_pending);",
          "5526:   if (nread <= 0) {",
          "5527:    err = SSL_get_error(conn->ssl, nread);",
          "5528:    if ((err == SSL_ERROR_SYSCALL) && (nread == -1)) {",
          "5529:     err = ERRNO;",
          "5530:    } else if ((err == SSL_ERROR_WANT_READ)",
          "5531:               || (err == SSL_ERROR_WANT_WRITE)) {",
          "5532:     nread = 0;",
          "5533:    } else {",
          "5534:     DEBUG_TRACE(\"SSL_read() failed, error %d\", err);",
          "5535:     return -1;",
          "5537:   } else {",
          "5538:    err = 0;",
          "5539:   }",
          "5541:  } else if (conn->ssl != NULL) {",
          "5543:   struct pollfd pfd[1];",
          "5544:   int pollres;",
          "5546:   pfd[0].fd = conn->client.sock;",
          "5547:   pfd[0].events = POLLIN;",
          "5548:   pollres =",
          "5549:       mg_poll(pfd, 1, (int)(timeout * 1000.0), &(conn->ctx->stop_flag));",
          "5550:   if (conn->ctx->stop_flag) {",
          "5551:    return -2;",
          "5552:   }",
          "5553:   if (pollres > 0) {",
          "5554:    nread = SSL_read(conn->ssl, buf, len);",
          "",
          "---------------",
          "--- Hunk 40 ---",
          "[Context before]",
          "5473:      nread = 0;",
          "5474:     } else {",
          "5475:      DEBUG_TRACE(\"SSL_read() failed, error %d\", err);",
          "5477:     }",
          "5478:    } else {",
          "5479:     err = 0;",
          "5480:    }",
          "5515:     return -2;",
          "5519:    }",
          "5522:   } else {",
          "5549:   }",
          "5562: #ifdef _WIN32",
          "5578: #else",
          "",
          "[Removed Lines]",
          "5476:      return -1;",
          "5482:   } else if (conn->ssl != NULL) {",
          "5484:    struct pollfd pfd[1];",
          "5485:    int pollres;",
          "5487:    pfd[0].fd = conn->client.sock;",
          "5488:    pfd[0].events = POLLIN;",
          "5489:    pollres = mg_poll(pfd,",
          "5490:                      1,",
          "5491:                      (int)(timeout * 1000.0),",
          "5492:                      &(conn->ctx->stop_flag));",
          "5493:    if (conn->ctx->stop_flag) {",
          "5494:     return -2;",
          "5495:    }",
          "5496:    if (pollres > 0) {",
          "5497:     nread = SSL_read(conn->ssl, buf, len);",
          "5498:     if (nread <= 0) {",
          "5499:      err = SSL_get_error(conn->ssl, nread);",
          "5500:      if ((err == SSL_ERROR_SYSCALL) && (nread == -1)) {",
          "5501:       err = ERRNO;",
          "5502:      } else if ((err == SSL_ERROR_WANT_READ)",
          "5503:                 || (err == SSL_ERROR_WANT_WRITE)) {",
          "5504:       nread = 0;",
          "5505:      } else {",
          "5506:       DEBUG_TRACE(\"SSL_read() failed, error %d\", err);",
          "5507:       return -2;",
          "5508:      }",
          "5509:     } else {",
          "5510:      err = 0;",
          "5511:     }",
          "5513:    } else if (pollres < 0) {",
          "5516:    } else {",
          "5518:     nread = 0;",
          "5520: #endif",
          "5523:    struct pollfd pfd[1];",
          "5524:    int pollres;",
          "5526:    pfd[0].fd = conn->client.sock;",
          "5527:    pfd[0].events = POLLIN;",
          "5528:    pollres = mg_poll(pfd,",
          "5529:                      1,",
          "5530:                      (int)(timeout * 1000.0),",
          "5531:                      &(conn->ctx->stop_flag));",
          "5532:    if (conn->ctx->stop_flag) {",
          "5533:     return -2;",
          "5534:    }",
          "5535:    if (pollres > 0) {",
          "5536:     nread = (int)recv(conn->client.sock, buf, (len_t)len, 0);",
          "5537:     err = (nread < 0) ? ERRNO : 0;",
          "5538:     if (nread <= 0) {",
          "5540:      return -2;",
          "5541:     }",
          "5542:    } else if (pollres < 0) {",
          "5544:     return -2;",
          "5545:    } else {",
          "5547:     nread = 0;",
          "5548:    }",
          "5551:   if (conn->ctx->stop_flag) {",
          "5552:    return -2;",
          "5553:   }",
          "5555:   if ((nread > 0) || ((nread == 0) && (len == 0))) {",
          "5557:    return nread;",
          "5558:   }",
          "5560:   if (nread < 0) {",
          "5563:    if (err == WSAEWOULDBLOCK) {",
          "5566:     return -2;",
          "5567:    } else if (err == WSAETIMEDOUT) {",
          "5570:     return 0;",
          "5571:    } else if (err == WSAECONNABORTED) {",
          "5573:     return -2;",
          "5574:    } else {",
          "5575:     DEBUG_TRACE(\"recv() failed, error %d\", err);",
          "5576:     return -2;",
          "5577:    }",
          "",
          "[Added Lines]",
          "5564:      return -2;",
          "5570:   } else if (pollres < 0) {",
          "5572:    return -2;",
          "5573:   } else {",
          "5575:    nread = 0;",
          "5576:   }",
          "5577: #endif",
          "5579:  } else {",
          "5580:   struct pollfd pfd[1];",
          "5581:   int pollres;",
          "5583:   pfd[0].fd = conn->client.sock;",
          "5584:   pfd[0].events = POLLIN;",
          "5585:   pollres =",
          "5586:       mg_poll(pfd, 1, (int)(timeout * 1000.0), &(conn->ctx->stop_flag));",
          "5587:   if (conn->ctx->stop_flag) {",
          "5588:    return -2;",
          "5589:   }",
          "5590:   if (pollres > 0) {",
          "5591:    nread = (int)recv(conn->client.sock, buf, (len_t)len, 0);",
          "5592:    err = (nread < 0) ? ERRNO : 0;",
          "5593:    if (nread <= 0) {",
          "5597:   } else if (pollres < 0) {",
          "5599:    return -2;",
          "5602:    nread = 0;",
          "5604:  }",
          "5606:  if (conn->ctx->stop_flag) {",
          "5607:   return -2;",
          "5608:  }",
          "5610:  if ((nread > 0) || ((nread == 0) && (len == 0))) {",
          "5612:   return nread;",
          "5613:  }",
          "5615:  if (nread < 0) {",
          "5618:   if (err == WSAEWOULDBLOCK) {",
          "5621:    return -2;",
          "5622:   } else if (err == WSAETIMEDOUT) {",
          "5625:    return 0;",
          "5626:   } else if (err == WSAECONNABORTED) {",
          "5628:    return -2;",
          "5629:   } else {",
          "5630:    DEBUG_TRACE(\"recv() failed, error %d\", err);",
          "5631:    return -2;",
          "5632:   }",
          "",
          "---------------",
          "--- Hunk 41 ---",
          "[Context before]",
          "5598:    return -2;",
          "5599:   }",
          "5600: #endif",
          "5605:  }",
          "5639:     }",
          "5647:    }",
          "5648:   }",
          "5651:  }",
          "5674:    }",
          "5689:    }",
          "5690:   }",
          "5691:  }",
          "5748:    }",
          "5749:   }",
          "5751:  }",
          "5765:  }",
          "5801:       return -1;",
          "5802:      }",
          "5817:      }",
          "5845:       }",
          "5846:      }",
          "5849:       return -1;",
          "5850:      }",
          "5856:     }",
          "5860:   }",
          "5862:  }",
          "5908:     }",
          "5909:    }",
          "5920:   }",
          "5922:  }",
          "5959:  }",
          "5985:   }",
          "5988:  }",
          "6010:   va_copy(ap_copy, ap);",
          "6012:   va_end(ap_copy);",
          "6045:   }",
          "6048:  }",
          "6067:  }",
          "6090: #define HEXTOI(x) (isdigit(x) ? (x - '0') : (x - 'W'))",
          "6105:   }",
          "6172:     }",
          "6173:    }",
          "6174:   }",
          "6177:  }",
          "6222:     }",
          "6223:    }",
          "6224:   }",
          "6226:  }",
          "6229: #if defined(USE_WEBSOCKET) || defined(USE_LUA)",
          "6249:   }",
          "6252:   }",
          "6254:  }",
          "6255: #endif",
          "6258: #if defined(USE_LUA)",
          "6280:  }",
          "6320:    }",
          "6321:   }",
          "6323:  }",
          "6324: #endif",
          "6336:  }",
          "6339: #if !defined(NO_FILES)",
          "6345: #if !defined(NO_CGI)",
          "6351: #endif",
          "6352: #if defined(USE_LUA)",
          "6358: #endif",
          "6359: #if defined(USE_DUKTAPE)",
          "6372:  }",
          "6413:   }",
          "6418:   }",
          "6421:  }",
          "6422: #endif",
          "6436: #if !defined(NO_FILES)",
          "6445: #if !defined(NO_CGI) || defined(USE_LUA) || defined(USE_DUKTAPE)",
          "6448: #endif",
          "6449: #else",
          "6451: #endif",
          "6464: #if defined(USE_WEBSOCKET)",
          "6466: #if !defined(NO_FILES)",
          "6475: #if !defined(NO_FILES)",
          "6516:   }",
          "6568:     }",
          "6571:    }",
          "6573:   }",
          "6603:     }",
          "6604:    }",
          "6605:   }",
          "6607: #if !defined(NO_CGI) || defined(USE_LUA) || defined(USE_DUKTAPE)",
          "6631:      filename[sep_pos] = 0;",
          "6635:      conn->path_info = filename + sep_pos + 1;",
          "6639:      break;",
          "6640:     }",
          "6678:    }",
          "6679:   }",
          "6687: #if !defined(NO_FILES)",
          "6733:    }",
          "6734:   }",
          "6737:  }",
          "6740: #if !defined(NO_CACHING)",
          "6750:   }",
          "6753:  }",
          "6808:  }",
          "6834:     }",
          "6835:    }",
          "6836:   }",
          "6959:  }",
          "6991:   }",
          "6995:  }",
          "7032:  }",
          "7074:  }",
          "7092: #ifdef DEBUG",
          "7095: #endif",
          "7114: #ifdef DEBUG",
          "7119: #endif",
          "7120:     }",
          "7139: #ifdef DEBUG",
          "7144: #endif",
          "7146:    }",
          "7147:   }",
          "7148:  }",
          "7191:     s++;",
          "7219:    }",
          "7220:   }",
          "7226:   }",
          "7231:   }",
          "7255: #else",
          "7256:  (void)nonce;",
          "7257: #endif",
          "7267:  }",
          "7300:   } else {",
          "7303:  }",
          "",
          "[Removed Lines]",
          "5601:   }",
          "5604:   return -1;",
          "5608:  static int pull_all(FILE * fp,",
          "5609:                      struct mg_connection * conn,",
          "5610:                      char *buf,",
          "5611:                      int len)",
          "5612:  {",
          "5613:   int n, nread = 0;",
          "5614:   double timeout = -1.0;",
          "5615:   uint64_t start_time = 0, now = 0, timeout_ns = 0;",
          "5617:   if (conn->ctx->config[REQUEST_TIMEOUT]) {",
          "5618:    timeout = atoi(conn->ctx->config[REQUEST_TIMEOUT]) / 1000.0;",
          "5619:   }",
          "5620:   if (timeout >= 0.0) {",
          "5621:    start_time = mg_get_current_time_ns();",
          "5622:    timeout_ns = (uint64_t)(timeout * 1.0E9);",
          "5623:   }",
          "5625:   while ((len > 0) && (conn->ctx->stop_flag == 0)) {",
          "5626:    n = pull_inner(fp, conn, buf + nread, len, timeout);",
          "5627:    if (n == -2) {",
          "5628:     if (nread == 0) {",
          "5630:     }",
          "5631:     break;",
          "5632:    } else if (n == -1) {",
          "5634:     if (timeout >= 0.0) {",
          "5635:      now = mg_get_current_time_ns();",
          "5636:      if ((now - start_time) <= timeout_ns) {",
          "5637:       continue;",
          "5638:      }",
          "5640:     break;",
          "5641:    } else if (n == 0) {",
          "5643:    } else {",
          "5644:     conn->consumed_content += n;",
          "5645:     nread += n;",
          "5646:     len -= n;",
          "5650:   return nread;",
          "5654:  static void discard_unread_request_data(struct mg_connection * conn)",
          "5655:  {",
          "5656:   char buf[MG_BUF_LEN];",
          "5657:   size_t to_read;",
          "5658:   int nread;",
          "5660:   if (conn == NULL) {",
          "5661:    return;",
          "5662:   }",
          "5664:   to_read = sizeof(buf);",
          "5666:   if (conn->is_chunked) {",
          "5669:    while (conn->is_chunked == 1) {",
          "5670:     nread = mg_read(conn, buf, to_read);",
          "5671:     if (nread <= 0) {",
          "5672:      break;",
          "5673:     }",
          "5676:   } else {",
          "5678:    while (conn->consumed_content < conn->content_len) {",
          "5679:     if (to_read",
          "5680:         > (size_t)(conn->content_len - conn->consumed_content)) {",
          "5681:      to_read =",
          "5682:          (size_t)(conn->content_len - conn->consumed_content);",
          "5683:     }",
          "5685:     nread = mg_read(conn, buf, to_read);",
          "5686:     if (nread <= 0) {",
          "5687:      break;",
          "5688:     }",
          "5694:  static int mg_read_inner(struct mg_connection * conn, void *buf, size_t len)",
          "5695:  {",
          "5696:   int64_t n, buffered_len, nread;",
          "5697:   int64_t len64 = (int64_t)(",
          "5698:       (len > INT_MAX) ? INT_MAX : len); /* since the return value is",
          "5701:   const char *body;",
          "5703:   if (conn == NULL) {",
          "5704:    return 0;",
          "5705:   }",
          "5709:   if ((conn->consumed_content) == 0 && (conn->content_len == -1)) {",
          "5710:    conn->content_len = INT64_MAX;",
          "5711:    conn->must_close = 1;",
          "5712:   }",
          "5714:   nread = 0;",
          "5715:   if (conn->consumed_content < conn->content_len) {",
          "5717:    int64_t left_to_read = conn->content_len - conn->consumed_content;",
          "5718:    if (left_to_read < len64) {",
          "5722:     len64 = left_to_read;",
          "5723:    }",
          "5726:    buffered_len = (int64_t)(conn->data_len)",
          "5727:                   - (int64_t)conn->request_len",
          "5728:                   - conn->consumed_content;",
          "5729:    if (buffered_len > 0) {",
          "5730:     if (len64 < buffered_len) {",
          "5731:      buffered_len = len64;",
          "5732:     }",
          "5733:     body = conn->buf + conn->request_len + conn->consumed_content;",
          "5734:     memcpy(buf, body, (size_t)buffered_len);",
          "5735:     len64 -= buffered_len;",
          "5736:     conn->consumed_content += buffered_len;",
          "5737:     nread += buffered_len;",
          "5738:     buf = (char *)buf + buffered_len;",
          "5739:    }",
          "5744:    if ((n = pull_all(NULL, conn, (char *)buf, (int)len64)) >= 0) {",
          "5745:     nread += n;",
          "5746:    } else {",
          "5747:     nread = ((nread > 0) ? nread : n);",
          "5750:   return (int)nread;",
          "5754:  static char mg_getc(struct mg_connection * conn)",
          "5755:  {",
          "5756:   char c;",
          "5757:   if (conn == NULL) {",
          "5758:    return 0;",
          "5759:   }",
          "5760:   conn->content_len++;",
          "5761:   if (mg_read_inner(conn, &c, 1) <= 0) {",
          "5762:    return (char)0;",
          "5763:   }",
          "5764:   return c;",
          "5768:  int mg_read(struct mg_connection * conn, void *buf, size_t len)",
          "5769:  {",
          "5770:   if (len > INT_MAX) {",
          "5771:    len = INT_MAX;",
          "5772:   }",
          "5774:   if (conn == NULL) {",
          "5775:    return 0;",
          "5776:   }",
          "5778:   if (conn->is_chunked) {",
          "5779:    size_t all_read = 0;",
          "5781:    while (len > 0) {",
          "5783:     if (conn->is_chunked == 2) {",
          "5785:      return 0;",
          "5786:     }",
          "5788:     if (conn->chunk_remainder) {",
          "5790:      long read_ret;",
          "5791:      size_t read_now = ((conn->chunk_remainder > len)",
          "5792:                             ? (len)",
          "5793:                             : (conn->chunk_remainder));",
          "5795:      conn->content_len += (int)read_now;",
          "5796:      read_ret =",
          "5797:          mg_read_inner(conn, (char *)buf + all_read, read_now);",
          "5799:      if (read_ret < 1) {",
          "5804:      all_read += (size_t)read_ret;",
          "5805:      conn->chunk_remainder -= (size_t)read_ret;",
          "5806:      len -= (size_t)read_ret;",
          "5808:      if (conn->chunk_remainder == 0) {",
          "5811:       char x1 = mg_getc(conn);",
          "5812:       char x2 = mg_getc(conn);",
          "5813:       if ((x1 != '\\r') || (x2 != '\\n')) {",
          "5815:        return -1;",
          "5816:       }",
          "5819:     } else {",
          "5821:      int i = 0;",
          "5822:      char lenbuf[64];",
          "5823:      char *end = 0;",
          "5824:      unsigned long chunkSize = 0;",
          "5826:      for (i = 0; i < ((int)sizeof(lenbuf) - 1); i++) {",
          "5827:       lenbuf[i] = mg_getc(conn);",
          "5828:       if ((i > 0) && (lenbuf[i] == '\\r')",
          "5829:           && (lenbuf[i - 1] != '\\r')) {",
          "5830:        continue;",
          "5831:       }",
          "5832:       if ((i > 1) && (lenbuf[i] == '\\n')",
          "5833:           && (lenbuf[i - 1] == '\\r')) {",
          "5834:        lenbuf[i + 1] = 0;",
          "5835:        chunkSize = strtoul(lenbuf, &end, 16);",
          "5836:        if (chunkSize == 0) {",
          "5838:         conn->is_chunked = 2;",
          "5839:        }",
          "5840:        break;",
          "5841:       }",
          "5842:       if (!isxdigit(lenbuf[i])) {",
          "5844:        return -1;",
          "5847:      if ((end == NULL) || (*end != '\\r')) {",
          "5851:      if (chunkSize == 0) {",
          "5852:       break;",
          "5853:      }",
          "5855:      conn->chunk_remainder = chunkSize;",
          "5857:    }",
          "5859:    return (int)all_read;",
          "5861:   return mg_read_inner(conn, buf, len);",
          "5865:  int mg_write(struct mg_connection * conn, const void *buf, size_t len)",
          "5866:  {",
          "5867:   time_t now;",
          "5868:   int64_t n, total, allowed;",
          "5870:   if (conn == NULL) {",
          "5871:    return 0;",
          "5872:   }",
          "5874:   if (conn->throttle > 0) {",
          "5875:    if ((now = time(NULL)) != conn->last_throttle_time) {",
          "5876:     conn->last_throttle_time = now;",
          "5877:     conn->last_throttle_bytes = 0;",
          "5878:    }",
          "5879:    allowed = conn->throttle - conn->last_throttle_bytes;",
          "5880:    if (allowed > (int64_t)len) {",
          "5881:     allowed = (int64_t)len;",
          "5882:    }",
          "5883:    if ((total = push_all(conn->ctx,",
          "5884:                          NULL,",
          "5885:                          conn->client.sock,",
          "5886:                          conn->ssl,",
          "5887:                          (const char *)buf,",
          "5888:                          (int64_t)allowed)) == allowed) {",
          "5889:     buf = (const char *)buf + total;",
          "5890:     conn->last_throttle_bytes += total;",
          "5891:     while ((total < (int64_t)len) && (conn->ctx->stop_flag == 0)) {",
          "5892:      allowed = (conn->throttle > ((int64_t)len - total))",
          "5893:                    ? (int64_t)len - total",
          "5894:                    : conn->throttle;",
          "5895:      if ((n = push_all(conn->ctx,",
          "5896:                        NULL,",
          "5897:                        conn->client.sock,",
          "5898:                        conn->ssl,",
          "5899:                        (const char *)buf,",
          "5900:                        (int64_t)allowed)) != allowed) {",
          "5901:       break;",
          "5902:      }",
          "5903:      sleep(1);",
          "5904:      conn->last_throttle_bytes = allowed;",
          "5905:      conn->last_throttle_time = time(NULL);",
          "5906:      buf = (const char *)buf + n;",
          "5907:      total += n;",
          "5910:   } else {",
          "5911:    total = push_all(conn->ctx,",
          "5912:                     NULL,",
          "5913:                     conn->client.sock,",
          "5914:                     conn->ssl,",
          "5915:                     (const char *)buf,",
          "5916:                     (int64_t)len);",
          "5917:   }",
          "5918:   if (total > 0) {",
          "5919:    conn->num_bytes_sent += total;",
          "5921:   return (int)total;",
          "5926:  int mg_send_chunk(struct mg_connection * conn,",
          "5927:                    const char *chunk,",
          "5928:                    unsigned int chunk_len)",
          "5929:  {",
          "5930:   char lenbuf[16];",
          "5931:   size_t lenbuf_len;",
          "5932:   int ret;",
          "5933:   int t;",
          "5936:   sprintf(lenbuf, \"%x\\r\\n\", chunk_len);",
          "5937:   lenbuf_len = strlen(lenbuf);",
          "5940:   ret = mg_write(conn, lenbuf, lenbuf_len);",
          "5941:   if (ret != (int)lenbuf_len) {",
          "5942:    return -1;",
          "5943:   }",
          "5944:   t = ret;",
          "5946:   ret = mg_write(conn, chunk, chunk_len);",
          "5947:   if (ret != (int)chunk_len) {",
          "5948:    return -1;",
          "5949:   }",
          "5950:   t += ret;",
          "5952:   ret = mg_write(conn, \"\\r\\n\", 2);",
          "5953:   if (ret != 2) {",
          "5954:    return -1;",
          "5955:   }",
          "5956:   t += ret;",
          "5958:   return t;",
          "5963:  static int alloc_vprintf2(char **buf, const char *fmt, va_list ap)",
          "5964:  {",
          "5965:   va_list ap_copy;",
          "5966:   size_t size = MG_BUF_LEN / 4;",
          "5967:   int len = -1;",
          "5970:   while (len < 0) {",
          "5971:    if (*buf) {",
          "5972:     mg_free(*buf);",
          "5973:    }",
          "5975:    size *= 4;",
          "5977:    if (!*buf) {",
          "5978:     break;",
          "5979:    }",
          "5981:    va_copy(ap_copy, ap);",
          "5982:    len = vsnprintf_impl(*buf, size - 1, fmt, ap_copy);",
          "5983:    va_end(ap_copy);",
          "5984:    (*buf)[size - 1] = 0;",
          "5987:   return len;",
          "5995:  static int alloc_vprintf(char **out_buf,",
          "5996:                           char *prealloc_buf,",
          "5997:                           size_t prealloc_size,",
          "5998:                           const char *fmt,",
          "5999:                           va_list ap)",
          "6000:  {",
          "6001:   va_list ap_copy;",
          "6002:   int len;",
          "6011:   len = vsnprintf_impl(NULL, 0, fmt, ap_copy);",
          "6014:   if (len < 0) {",
          "6019:    va_copy(ap_copy, ap);",
          "6020:    len = alloc_vprintf2(out_buf, fmt, ap_copy);",
          "6021:    va_end(ap_copy);",
          "6023:   } else if ((size_t)(len) >= prealloc_size) {",
          "6027:    if (!*out_buf) {",
          "6029:     return -1;",
          "6030:    }",
          "6032:    va_copy(ap_copy, ap);",
          "6033:    IGNORE_UNUSED_RESULT(",
          "6034:        vsnprintf_impl(*out_buf, (size_t)(len) + 1, fmt, ap_copy));",
          "6035:    va_end(ap_copy);",
          "6037:   } else {",
          "6040:    va_copy(ap_copy, ap);",
          "6041:    IGNORE_UNUSED_RESULT(",
          "6042:        vsnprintf_impl(prealloc_buf, prealloc_size, fmt, ap_copy));",
          "6043:    va_end(ap_copy);",
          "6047:   return len;",
          "6051:  static int mg_vprintf(struct mg_connection * conn,",
          "6052:                        const char *fmt,",
          "6053:                        va_list ap)",
          "6054:  {",
          "6055:   char mem[MG_BUF_LEN];",
          "6056:   char *buf = NULL;",
          "6057:   int len;",
          "6059:   if ((len = alloc_vprintf(&buf, mem, sizeof(mem), fmt, ap)) > 0) {",
          "6060:    len = mg_write(conn, buf, (size_t)len);",
          "6061:   }",
          "6062:   if ((buf != mem) && (buf != NULL)) {",
          "6063:    mg_free(buf);",
          "6064:   }",
          "6066:   return len;",
          "6070:  int mg_printf(struct mg_connection * conn, const char *fmt, ...)",
          "6071:  {",
          "6072:   va_list ap;",
          "6073:   int result;",
          "6075:   va_start(ap, fmt);",
          "6076:   result = mg_vprintf(conn, fmt, ap);",
          "6077:   va_end(ap);",
          "6079:   return result;",
          "6080:  }",
          "6083:  int mg_url_decode(const char *src,",
          "6084:                    int src_len,",
          "6085:                    char *dst,",
          "6086:                    int dst_len,",
          "6087:                    int is_form_url_encoded)",
          "6088:  {",
          "6089:   int i, j, a, b;",
          "6092:   for (i = j = 0; (i < src_len) && (j < (dst_len - 1)); i++, j++) {",
          "6093:    if ((i < src_len - 2) && (src[i] == '%')",
          "6094:        && isxdigit(*(const unsigned char *)(src + i + 1))",
          "6095:        && isxdigit(*(const unsigned char *)(src + i + 2))) {",
          "6096:     a = tolower(*(const unsigned char *)(src + i + 1));",
          "6097:     b = tolower(*(const unsigned char *)(src + i + 2));",
          "6098:     dst[j] = (char)((HEXTOI(a) << 4) | HEXTOI(b));",
          "6099:     i += 2;",
          "6100:    } else if (is_form_url_encoded && (src[i] == '+')) {",
          "6101:     dst[j] = ' ';",
          "6102:    } else {",
          "6103:     dst[j] = src[i];",
          "6104:    }",
          "6109:   return (i >= src_len) ? j : -1;",
          "6110:  }",
          "6113:  int mg_get_var(const char *data,",
          "6114:                 size_t data_len,",
          "6115:                 const char *name,",
          "6116:                 char *dst,",
          "6117:                 size_t dst_len)",
          "6118:  {",
          "6119:   return mg_get_var2(data, data_len, name, dst, dst_len, 0);",
          "6120:  }",
          "6123:  int mg_get_var2(const char *data,",
          "6124:                  size_t data_len,",
          "6125:                  const char *name,",
          "6126:                  char *dst,",
          "6127:                  size_t dst_len,",
          "6128:                  size_t occurrence)",
          "6129:  {",
          "6130:   const char *p, *e, *s;",
          "6131:   size_t name_len;",
          "6132:   int len;",
          "6134:   if ((dst == NULL) || (dst_len == 0)) {",
          "6135:    len = -2;",
          "6136:   } else if ((data == NULL) || (name == NULL) || (data_len == 0)) {",
          "6137:    len = -1;",
          "6138:    dst[0] = '\\0';",
          "6139:   } else {",
          "6140:    name_len = strlen(name);",
          "6141:    e = data + data_len;",
          "6142:    len = -1;",
          "6143:    dst[0] = '\\0';",
          "6146:    for (p = data; p + name_len < e; p++) {",
          "6147:     if (((p == data) || (p[-1] == '&')) && (p[name_len] == '=')",
          "6148:         && !mg_strncasecmp(name, p, name_len)",
          "6149:         && 0 == occurrence--) {",
          "6151:      p += name_len + 1;",
          "6154:      s = (const char *)memchr(p, '&', (size_t)(e - p));",
          "6155:      if (s == NULL) {",
          "6156:       s = e;",
          "6157:      }",
          "6159:      if (s < p) {",
          "6160:       return -3;",
          "6161:      }",
          "6164:      len = mg_url_decode(p, (int)(s - p), dst, (int)dst_len, 1);",
          "6168:      if (len == -1) {",
          "6169:       len = -2;",
          "6170:      }",
          "6171:      break;",
          "6176:   return len;",
          "6181:  int mg_get_cookie(const char *cookie_header,",
          "6182:                    const char *var_name,",
          "6183:                    char *dst,",
          "6184:                    size_t dst_size)",
          "6185:  {",
          "6186:   const char *s, *p, *end;",
          "6187:   int name_len, len = -1;",
          "6189:   if ((dst == NULL) || (dst_size == 0)) {",
          "6190:    return -2;",
          "6191:   }",
          "6193:   dst[0] = '\\0';",
          "6194:   if ((var_name == NULL) || ((s = cookie_header) == NULL)) {",
          "6195:    return -1;",
          "6196:   }",
          "6198:   name_len = (int)strlen(var_name);",
          "6199:   end = s + strlen(s);",
          "6200:   for (; (s = mg_strcasestr(s, var_name)) != NULL; s += name_len) {",
          "6201:    if (s[name_len] == '=') {",
          "6203:     if ((s == cookie_header) || (s[-1] == ' ')) {",
          "6204:      s += name_len + 1;",
          "6205:      if ((p = strchr(s, ' ')) == NULL) {",
          "6206:       p = end;",
          "6207:      }",
          "6208:      if (p[-1] == ';') {",
          "6209:       p--;",
          "6210:      }",
          "6211:      if ((*s == '\"') && (p[-1] == '\"') && (p > s + 1)) {",
          "6212:       s++;",
          "6213:       p--;",
          "6214:      }",
          "6215:      if ((size_t)(p - s) < dst_size) {",
          "6216:       len = (int)(p - s);",
          "6217:       mg_strlcpy(dst, s, (size_t)len + 1);",
          "6218:      } else {",
          "6219:       len = -3;",
          "6220:      }",
          "6221:      break;",
          "6225:   return len;",
          "6230:  static void base64_encode(const unsigned char *src, int src_len, char *dst)",
          "6231:  {",
          "6232:   static const char *b64 =",
          "6233:       \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";",
          "6234:   int i, j, a, b, c;",
          "6236:   for (i = j = 0; i < src_len; i += 3) {",
          "6237:    a = src[i];",
          "6238:    b = ((i + 1) >= src_len) ? 0 : src[i + 1];",
          "6239:    c = ((i + 2) >= src_len) ? 0 : src[i + 2];",
          "6241:    dst[j++] = b64[a >> 2];",
          "6242:    dst[j++] = b64[((a & 3) << 4) | (b >> 4)];",
          "6243:    if (i + 1 < src_len) {",
          "6244:     dst[j++] = b64[(b & 15) << 2 | (c >> 6)];",
          "6245:    }",
          "6246:    if (i + 2 < src_len) {",
          "6247:     dst[j++] = b64[c & 63];",
          "6248:    }",
          "6250:   while (j % 4 != 0) {",
          "6251:    dst[j++] = '=';",
          "6253:   dst[j++] = '\\0';",
          "6259:  static unsigned char b64reverse(char letter)",
          "6260:  {",
          "6261:   if ((letter >= 'A') && (letter <= 'Z')) {",
          "6262:    return letter - 'A';",
          "6263:   }",
          "6264:   if ((letter >= 'a') && (letter <= 'z')) {",
          "6265:    return letter - 'a' + 26;",
          "6266:   }",
          "6267:   if ((letter >= '0') && (letter <= '9')) {",
          "6268:    return letter - '0' + 52;",
          "6269:   }",
          "6270:   if (letter == '+') {",
          "6271:    return 62;",
          "6272:   }",
          "6273:   if (letter == '/') {",
          "6274:    return 63;",
          "6275:   }",
          "6276:   if (letter == '=') {",
          "6278:   }",
          "6283:  static int base64_decode(const unsigned char *src,",
          "6284:                           int src_len,",
          "6285:                           char *dst,",
          "6286:                           size_t *dst_len)",
          "6287:  {",
          "6288:   int i;",
          "6289:   unsigned char a, b, c, d;",
          "6293:   for (i = 0; i < src_len; i += 4) {",
          "6294:    a = b64reverse(src[i]);",
          "6295:    if (a >= 254) {",
          "6296:     return i;",
          "6297:    }",
          "6299:    b = b64reverse(((i + 1) >= src_len) ? 0 : src[i + 1]);",
          "6300:    if (b >= 254) {",
          "6301:     return i + 1;",
          "6302:    }",
          "6304:    c = b64reverse(((i + 2) >= src_len) ? 0 : src[i + 2]);",
          "6305:    if (c == 254) {",
          "6306:     return i + 2;",
          "6307:    }",
          "6309:    d = b64reverse(((i + 3) >= src_len) ? 0 : src[i + 3]);",
          "6310:    if (d == 254) {",
          "6311:     return i + 3;",
          "6312:    }",
          "6314:    dst[(*dst_len)++] = (a << 2) + (b >> 4);",
          "6315:    if (c != 255) {",
          "6316:     dst[(*dst_len)++] = (b << 4) + (c >> 2);",
          "6317:     if (d != 255) {",
          "6318:      dst[(*dst_len)++] = (c << 6) + d;",
          "6319:     }",
          "6322:   return -1;",
          "6327:  static int is_put_or_delete_method(const struct mg_connection *conn)",
          "6328:  {",
          "6329:   if (conn) {",
          "6330:    const char *s = conn->request_info.request_method;",
          "6331:    return (s != NULL)",
          "6332:           && (!strcmp(s, \"PUT\") || !strcmp(s, \"DELETE\")",
          "6333:               || !strcmp(s, \"MKCOL\") || !strcmp(s, \"PATCH\"));",
          "6334:   }",
          "6335:   return 0;",
          "6340:  static int extention_matches_script(",
          "6343:      )",
          "6344:  {",
          "6346:   if (match_prefix(conn->ctx->config[CGI_EXTENSIONS],",
          "6347:                    strlen(conn->ctx->config[CGI_EXTENSIONS]),",
          "6348:                    filename) > 0) {",
          "6349:    return 1;",
          "6350:   }",
          "6353:   if (match_prefix(conn->ctx->config[LUA_SCRIPT_EXTENSIONS],",
          "6354:                    strlen(conn->ctx->config[LUA_SCRIPT_EXTENSIONS]),",
          "6355:                    filename) > 0) {",
          "6356:    return 1;",
          "6357:   }",
          "6360:   if (match_prefix(conn->ctx->config[DUKTAPE_SCRIPT_EXTENSIONS],",
          "6361:                    strlen(conn->ctx->config[DUKTAPE_SCRIPT_EXTENSIONS]),",
          "6362:                    filename) > 0) {",
          "6363:    return 1;",
          "6364:   }",
          "6365: #endif",
          "6368:   (void)filename;",
          "6369:   (void)conn;",
          "6371:   return 0;",
          "6378:  static int substitute_index_file(struct mg_connection * conn,",
          "6379:                                   char *path,",
          "6380:                                   size_t path_len,",
          "6381:                                   struct mg_file_stat *filestat)",
          "6382:  {",
          "6383:   const char *list = conn->ctx->config[INDEX_FILES];",
          "6384:   struct vec filename_vec;",
          "6385:   size_t n = strlen(path);",
          "6386:   int found = 0;",
          "6391:   while ((n > 0) && (path[n - 1] == '/')) {",
          "6392:    n--;",
          "6393:   }",
          "6394:   path[n] = '/';",
          "6398:   while ((list = next_option(list, &filename_vec, NULL)) != NULL) {",
          "6400:    if (filename_vec.len > (path_len - (n + 2))) {",
          "6401:     continue;",
          "6402:    }",
          "6405:    mg_strlcpy(path + n + 1, filename_vec.ptr, filename_vec.len + 1);",
          "6408:    if (mg_stat(conn, path, filestat)) {",
          "6410:     found = 1;",
          "6411:     break;",
          "6412:    }",
          "6416:   if (!found) {",
          "6417:    path[n] = '\\0';",
          "6420:   return found;",
          "6425:  static void interpret_uri(",
          "6434:      )",
          "6435:  {",
          "6437:   const char *uri = conn->request_info.local_uri;",
          "6438:   const char *root = conn->ctx->config[DOCUMENT_ROOT];",
          "6439:   const char *rewrite;",
          "6440:   struct vec a, b;",
          "6441:   int match_len;",
          "6442:   char gz_path[PATH_MAX];",
          "6443:   char const *accept_encoding;",
          "6444:   int truncated;",
          "6446:   char *tmp_str;",
          "6447:   size_t tmp_str_len, sep_pos;",
          "6454:   memset(filestat, 0, sizeof(*filestat));",
          "6467:   if (*is_websocket_request && conn->ctx->config[WEBSOCKET_ROOT]) {",
          "6468:    root = conn->ctx->config[WEBSOCKET_ROOT];",
          "6469:   }",
          "6480:   if (root == NULL) {",
          "6483:    return;",
          "6484:   }",
          "6490:   mg_snprintf(conn,",
          "6491:               &truncated,",
          "6492:               filename,",
          "6493:               filename_buf_len - 1,",
          "6494:               \"%s%s\",",
          "6495:               root,",
          "6496:               uri);",
          "6498:   if (truncated) {",
          "6499:    goto interpret_cleanup;",
          "6500:   }",
          "6503:   rewrite = conn->ctx->config[URL_REWRITE_PATTERN];",
          "6504:   while ((rewrite = next_option(rewrite, &a, &b)) != NULL) {",
          "6505:    if ((match_len = match_prefix(a.ptr, a.len, uri)) > 0) {",
          "6506:     mg_snprintf(conn,",
          "6507:                 &truncated,",
          "6508:                 filename,",
          "6509:                 filename_buf_len - 1,",
          "6510:                 \"%.*s%s\",",
          "6511:                 (int)b.len,",
          "6512:                 b.ptr,",
          "6513:                 uri + match_len);",
          "6514:     break;",
          "6515:    }",
          "6518:   if (truncated) {",
          "6519:    goto interpret_cleanup;",
          "6520:   }",
          "6525:   if (mg_stat(conn, filename, filestat)) {",
          "6530:    if (extention_matches_script(conn, filename)) {",
          "6543:    }",
          "6547:    if (filestat->is_directory) {",
          "6550:     struct mg_file_stat tmp_filestat;",
          "6551:     memset(&tmp_filestat, 0, sizeof(tmp_filestat));",
          "6553:     if (substitute_index_file(",
          "6554:             conn, filename, filename_buf_len, &tmp_filestat)) {",
          "6560:      if (extention_matches_script(conn, filename)) {",
          "6563:      } else {",
          "6567:      }",
          "6572:    return;",
          "6582:   if ((accept_encoding = mg_get_header(conn, \"Accept-Encoding\"))",
          "6583:       != NULL) {",
          "6584:    if (strstr(accept_encoding, \"gzip\") != NULL) {",
          "6585:     mg_snprintf(conn,",
          "6586:                 &truncated,",
          "6587:                 gz_path,",
          "6588:                 sizeof(gz_path),",
          "6589:                 \"%s.gz\",",
          "6590:                 filename);",
          "6592:     if (truncated) {",
          "6593:      goto interpret_cleanup;",
          "6594:     }",
          "6596:     if (mg_stat(conn, gz_path, filestat)) {",
          "6597:      if (filestat) {",
          "6598:       filestat->is_gzipped = 1;",
          "6600:      }",
          "6602:      return;",
          "6610:   tmp_str_len = strlen(filename);",
          "6611:   tmp_str = mg_malloc_ctx(tmp_str_len + PATH_MAX + 1, conn->ctx);",
          "6612:   if (!tmp_str) {",
          "6614:    goto interpret_cleanup;",
          "6615:   }",
          "6616:   memcpy(tmp_str, filename, tmp_str_len + 1);",
          "6618:   sep_pos = tmp_str_len;",
          "6619:   while (sep_pos > 0) {",
          "6620:    sep_pos--;",
          "6621:    if (tmp_str[sep_pos] == '/') {",
          "6622:     int is_script = 0, does_exist = 0;",
          "6624:     tmp_str[sep_pos] = 0;",
          "6625:     if (tmp_str[0]) {",
          "6626:      is_script = extention_matches_script(conn, tmp_str);",
          "6627:      does_exist = mg_stat(conn, tmp_str, filestat);",
          "6628:     }",
          "6630:     if (does_exist && is_script) {",
          "6632:      memmove(filename + sep_pos + 2,",
          "6633:              filename + sep_pos + 1,",
          "6634:              strlen(filename + sep_pos + 1) + 1);",
          "6636:      filename[sep_pos + 1] = '/';",
          "6641:     if (substitute_index_file(",
          "6642:             conn, tmp_str, tmp_str_len + PATH_MAX, filestat)) {",
          "6644:      if (extention_matches_script(conn, tmp_str)) {",
          "6647:       char *tmp_str2 = mg_strdup(filename + sep_pos + 1);",
          "6648:       mg_snprintf(conn,",
          "6649:                   &truncated,",
          "6650:                   filename,",
          "6651:                   filename_buf_len,",
          "6652:                   \"%s//%s\",",
          "6653:                   tmp_str,",
          "6654:                   tmp_str2);",
          "6655:       mg_free(tmp_str2);",
          "6657:       if (truncated) {",
          "6658:        mg_free(tmp_str);",
          "6659:        goto interpret_cleanup;",
          "6660:       }",
          "6661:       sep_pos = strlen(tmp_str);",
          "6662:       filename[sep_pos] = 0;",
          "6663:       conn->path_info = filename + sep_pos + 1;",
          "6666:       break;",
          "6667:      } else {",
          "6669:       filename[sep_pos] = 0;",
          "6670:       conn->path_info = 0;",
          "6673:       break;",
          "6674:      }",
          "6675:     }",
          "6677:     tmp_str[sep_pos] = '/';",
          "6681:   mg_free(tmp_str);",
          "6685:   return;",
          "6689:  interpret_cleanup:",
          "6690:   memset(filestat, 0, sizeof(*filestat));",
          "6697:  }",
          "6704:  static int get_http_header_len(const char *buf, int buflen)",
          "6705:  {",
          "6706:   int i;",
          "6707:   for (i = 0; i < buflen; i++) {",
          "6709:    const unsigned char c = ((const unsigned char *)buf)[i];",
          "6711:    if ((c < 128) && ((char)c != '\\r') && ((char)c != '\\n')",
          "6712:        && !isprint(c)) {",
          "6714:     return -1;",
          "6715:    }",
          "6717:    if (i < buflen - 1) {",
          "6718:     if ((buf[i] == '\\n') && (buf[i + 1] == '\\n')) {",
          "6723:      return i + 2;",
          "6724:     }",
          "6725:    }",
          "6727:    if (i < buflen - 3) {",
          "6728:     if ((buf[i] == '\\r') && (buf[i + 1] == '\\n')",
          "6729:         && (buf[i + 2] == '\\r') && (buf[i + 3] == '\\n')) {",
          "6731:      return i + 4;",
          "6732:     }",
          "6736:   return 0;",
          "6742:  static int get_month_index(const char *s)",
          "6743:  {",
          "6744:   size_t i;",
          "6746:   for (i = 0; i < ARRAY_SIZE(month_names); i++) {",
          "6747:    if (!strcmp(s, month_names[i])) {",
          "6748:     return (int)i;",
          "6749:    }",
          "6752:   return -1;",
          "6757:  static time_t parse_date_string(const char *datetime)",
          "6758:  {",
          "6759:   char month_str[32] = {0};",
          "6760:   int second, minute, hour, day, month, year;",
          "6761:   time_t result = (time_t)0;",
          "6762:   struct tm tm;",
          "6764:   if ((sscanf(datetime,",
          "6765:               \"%d/%3s/%d %d:%d:%d\",",
          "6766:               &day,",
          "6767:               month_str,",
          "6768:               &year,",
          "6769:               &hour,",
          "6770:               &minute,",
          "6771:               &second) == 6) || (sscanf(datetime,",
          "6772:                                         \"%d %3s %d %d:%d:%d\",",
          "6773:                                         &day,",
          "6774:                                         month_str,",
          "6775:                                         &year,",
          "6776:                                         &hour,",
          "6777:                                         &minute,",
          "6778:                                         &second) == 6)",
          "6779:       || (sscanf(datetime,",
          "6780:                  \"%*3s, %d %3s %d %d:%d:%d\",",
          "6781:                  &day,",
          "6782:                  month_str,",
          "6783:                  &year,",
          "6784:                  &hour,",
          "6785:                  &minute,",
          "6786:                  &second) == 6) || (sscanf(datetime,",
          "6787:                                            \"%d-%3s-%d %d:%d:%d\",",
          "6788:                                            &day,",
          "6789:                                            month_str,",
          "6790:                                            &year,",
          "6791:                                            &hour,",
          "6792:                                            &minute,",
          "6793:                                            &second) == 6)) {",
          "6794:    month = get_month_index(month_str);",
          "6795:    if ((month >= 0) && (year >= 1970)) {",
          "6796:     memset(&tm, 0, sizeof(tm));",
          "6797:     tm.tm_year = year - 1900;",
          "6798:     tm.tm_mon = month;",
          "6799:     tm.tm_mday = day;",
          "6800:     tm.tm_hour = hour;",
          "6801:     tm.tm_min = minute;",
          "6802:     tm.tm_sec = second;",
          "6803:     result = timegm(&tm);",
          "6804:    }",
          "6805:   }",
          "6807:   return result;",
          "6814:  static void remove_double_dots_and_double_slashes(char *s)",
          "6815:  {",
          "6816:   char *p = s;",
          "6818:   while ((s[0] == '.') && (s[1] == '.')) {",
          "6819:    s++;",
          "6820:   }",
          "6822:   while (*s != '\\0') {",
          "6824:    if ((s[-1] == '/') || (s[-1] == '\\\\')) {",
          "6826:     while (s[0] != '\\0') {",
          "6827:      if ((s[0] == '/') || (s[0] == '\\\\')) {",
          "6828:       s++;",
          "6829:      } else if ((s[0] == '.') && (s[1] == '.')) {",
          "6830:       s += 2;",
          "6831:      } else {",
          "6832:       break;",
          "6833:      }",
          "6838:  }",
          "6841:  static const struct {",
          "6842:   const char *extension;",
          "6843:   size_t ext_len;",
          "6844:   const char *mime_type;",
          "6845:  } builtin_mime_types[] = {",
          "6849:      {\".doc\", 4, \"application/msword\"},",
          "6850:      {\".eps\", 4, \"application/postscript\"},",
          "6851:      {\".exe\", 4, \"application/octet-stream\"},",
          "6852:      {\".js\", 3, \"application/javascript\"},",
          "6853:      {\".json\", 5, \"application/json\"},",
          "6854:      {\".pdf\", 4, \"application/pdf\"},",
          "6855:      {\".ps\", 3, \"application/postscript\"},",
          "6856:      {\".rtf\", 4, \"application/rtf\"},",
          "6857:      {\".xhtml\", 6, \"application/xhtml+xml\"},",
          "6858:      {\".xsl\", 4, \"application/xml\"},",
          "6859:      {\".xslt\", 5, \"application/xml\"},",
          "6862:      {\".ttf\", 4, \"application/font-sfnt\"},",
          "6863:      {\".cff\", 4, \"application/font-sfnt\"},",
          "6864:      {\".otf\", 4, \"application/font-sfnt\"},",
          "6865:      {\".aat\", 4, \"application/font-sfnt\"},",
          "6866:      {\".sil\", 4, \"application/font-sfnt\"},",
          "6867:      {\".pfr\", 4, \"application/font-tdpfr\"},",
          "6868:      {\".woff\", 5, \"application/font-woff\"},",
          "6871:      {\".mp3\", 4, \"audio/mpeg\"},",
          "6872:      {\".oga\", 4, \"audio/ogg\"},",
          "6873:      {\".ogg\", 4, \"audio/ogg\"},",
          "6876:      {\".gif\", 4, \"image/gif\"},",
          "6877:      {\".ief\", 4, \"image/ief\"},",
          "6878:      {\".jpeg\", 5, \"image/jpeg\"},",
          "6879:      {\".jpg\", 4, \"image/jpeg\"},",
          "6880:      {\".jpm\", 4, \"image/jpm\"},",
          "6881:      {\".jpx\", 4, \"image/jpx\"},",
          "6882:      {\".png\", 4, \"image/png\"},",
          "6883:      {\".svg\", 4, \"image/svg+xml\"},",
          "6884:      {\".tif\", 4, \"image/tiff\"},",
          "6885:      {\".tiff\", 5, \"image/tiff\"},",
          "6888:      {\".wrl\", 4, \"model/vrml\"},",
          "6891:      {\".css\", 4, \"text/css\"},",
          "6892:      {\".csv\", 4, \"text/csv\"},",
          "6893:      {\".htm\", 4, \"text/html\"},",
          "6894:      {\".html\", 5, \"text/html\"},",
          "6895:      {\".sgm\", 4, \"text/sgml\"},",
          "6896:      {\".shtm\", 5, \"text/html\"},",
          "6897:      {\".shtml\", 6, \"text/html\"},",
          "6898:      {\".txt\", 4, \"text/plain\"},",
          "6899:      {\".xml\", 4, \"text/xml\"},",
          "6902:      {\".mov\", 4, \"video/quicktime\"},",
          "6903:      {\".mp4\", 4, \"video/mp4\"},",
          "6904:      {\".mpeg\", 5, \"video/mpeg\"},",
          "6905:      {\".mpg\", 4, \"video/mpeg\"},",
          "6906:      {\".ogv\", 4, \"video/ogg\"},",
          "6907:      {\".qt\", 3, \"video/quicktime\"},",
          "6912:      {\".arj\", 4, \"application/x-arj-compressed\"},",
          "6913:      {\".gz\", 3, \"application/x-gunzip\"},",
          "6914:      {\".rar\", 4, \"application/x-arj-compressed\"},",
          "6915:      {\".swf\", 4, \"application/x-shockwave-flash\"},",
          "6916:      {\".tar\", 4, \"application/x-tar\"},",
          "6917:      {\".tgz\", 4, \"application/x-tar-gz\"},",
          "6918:      {\".torrent\", 8, \"application/x-bittorrent\"},",
          "6919:      {\".ppt\", 4, \"application/x-mspowerpoint\"},",
          "6920:      {\".xls\", 4, \"application/x-msexcel\"},",
          "6921:      {\".zip\", 4, \"application/x-zip-compressed\"},",
          "6922:      {\".aac\",",
          "6923:       4,",
          "6925:      {\".aif\", 4, \"audio/x-aif\"},",
          "6926:      {\".m3u\", 4, \"audio/x-mpegurl\"},",
          "6927:      {\".mid\", 4, \"audio/x-midi\"},",
          "6928:      {\".ra\", 3, \"audio/x-pn-realaudio\"},",
          "6929:      {\".ram\", 4, \"audio/x-pn-realaudio\"},",
          "6930:      {\".wav\", 4, \"audio/x-wav\"},",
          "6931:      {\".bmp\", 4, \"image/bmp\"},",
          "6932:      {\".ico\", 4, \"image/x-icon\"},",
          "6933:      {\".pct\", 4, \"image/x-pct\"},",
          "6934:      {\".pict\", 5, \"image/pict\"},",
          "6935:      {\".rgb\", 4, \"image/x-rgb\"},",
          "6937:      {\".asf\", 4, \"video/x-ms-asf\"},",
          "6938:      {\".avi\", 4, \"video/x-msvideo\"},",
          "6939:      {\".m4v\", 4, \"video/x-m4v\"},",
          "6940:      {NULL, 0, NULL}};",
          "6943:  const char *mg_get_builtin_mime_type(const char *path)",
          "6944:  {",
          "6945:   const char *ext;",
          "6946:   size_t i, path_len;",
          "6948:   path_len = strlen(path);",
          "6950:   for (i = 0; builtin_mime_types[i].extension != NULL; i++) {",
          "6951:    ext = path + (path_len - builtin_mime_types[i].ext_len);",
          "6952:    if ((path_len > builtin_mime_types[i].ext_len)",
          "6953:        && (mg_strcasecmp(ext, builtin_mime_types[i].extension) == 0)) {",
          "6954:     return builtin_mime_types[i].mime_type;",
          "6955:    }",
          "6956:   }",
          "6958:   return \"text/plain\";",
          "6964:  static void get_mime_type(struct mg_context * ctx,",
          "6965:                            const char *path,",
          "6966:                            struct vec *vec)",
          "6967:  {",
          "6968:   struct vec ext_vec, mime_vec;",
          "6969:   const char *list, *ext;",
          "6970:   size_t path_len;",
          "6972:   path_len = strlen(path);",
          "6974:   if ((ctx == NULL) || (vec == NULL)) {",
          "6975:    if (vec != NULL) {",
          "6976:     memset(vec, '\\0', sizeof(struct vec));",
          "6977:    }",
          "6978:    return;",
          "6979:   }",
          "6983:   list = ctx->config[EXTRA_MIME_TYPES];",
          "6984:   while ((list = next_option(list, &ext_vec, &mime_vec)) != NULL) {",
          "6986:    ext = path + path_len - ext_vec.len;",
          "6987:    if (mg_strncasecmp(ext, ext_vec.ptr, ext_vec.len) == 0) {",
          "6989:     return;",
          "6990:    }",
          "6993:   vec->ptr = mg_get_builtin_mime_type(path);",
          "6994:   vec->len = strlen(vec->ptr);",
          "7000:  static void bin2str(char *to, const unsigned char *p, size_t len)",
          "7001:  {",
          "7002:   static const char *hex = \"0123456789abcdef\";",
          "7004:   for (; len--; p++) {",
          "7007:   }",
          "7009:  }",
          "7014:  char *mg_md5(char buf[33], ...)",
          "7015:  {",
          "7016:   md5_byte_t hash[16];",
          "7017:   const char *p;",
          "7018:   va_list ap;",
          "7019:   md5_state_t ctx;",
          "7021:   md5_init(&ctx);",
          "7023:   va_start(ap, buf);",
          "7024:   while ((p = va_arg(ap, const char *)) != NULL) {",
          "7025:    md5_append(&ctx, (const md5_byte_t *)p, strlen(p));",
          "7026:   }",
          "7027:   va_end(ap);",
          "7029:   md5_finish(&ctx, hash);",
          "7030:   bin2str(buf, hash, sizeof(hash));",
          "7031:   return buf;",
          "7036:  static int check_password(const char *method,",
          "7037:                            const char *ha1,",
          "7038:                            const char *uri,",
          "7039:                            const char *nonce,",
          "7040:                            const char *nc,",
          "7041:                            const char *cnonce,",
          "7042:                            const char *qop,",
          "7043:                            const char *response)",
          "7044:  {",
          "7045:   char ha2[32 + 1], expected_response[32 + 1];",
          "7048:   if ((method == NULL) || (nonce == NULL) || (nc == NULL)",
          "7049:       || (cnonce == NULL) || (qop == NULL) || (response == NULL)) {",
          "7050:    return 0;",
          "7051:   }",
          "7054:   if (strlen(response) != 32) {",
          "7055:    return 0;",
          "7056:   }",
          "7058:   mg_md5(ha2, method, \":\", uri, NULL);",
          "7059:   mg_md5(expected_response,",
          "7060:          ha1,",
          "7061:          \":\",",
          "7062:          nonce,",
          "7063:          \":\",",
          "7064:          nc,",
          "7065:          \":\",",
          "7066:          cnonce,",
          "7067:          \":\",",
          "7068:          qop,",
          "7069:          \":\",",
          "7070:          ha2,",
          "7071:          NULL);",
          "7073:   return mg_strcasecmp(response, expected_response) == 0;",
          "7079:  static void open_auth_file(struct mg_connection * conn,",
          "7080:                             const char *path,",
          "7081:                             struct mg_file *filep)",
          "7082:  {",
          "7083:   if ((conn != NULL) && (conn->ctx != NULL)) {",
          "7084:    char name[PATH_MAX];",
          "7085:    const char *p, *e,",
          "7087:    int truncated;",
          "7089:    if (gpass != NULL) {",
          "7091:     if (!mg_fopen(conn, gpass, MG_FOPEN_MODE_READ, filep)) {",
          "7094:      mg_cry(conn, \"fopen(%s): %s\", gpass, strerror(ERRNO));",
          "7096:     }",
          "7102:    } else if (mg_stat(conn, path, &filep->stat)",
          "7103:               && filep->stat.is_directory) {",
          "7104:     mg_snprintf(conn,",
          "7105:                 &truncated,",
          "7106:                 name,",
          "7107:                 sizeof(name),",
          "7108:                 \"%s/%s\",",
          "7109:                 path,",
          "7110:                 PASSWORDS_FILE_NAME);",
          "7112:     if (truncated",
          "7113:         || !mg_fopen(conn, name, MG_FOPEN_MODE_READ, filep)) {",
          "7118:      DEBUG_TRACE(\"fopen(%s): %s\", name, strerror(ERRNO));",
          "7121:    } else {",
          "7123:     for (p = path, e = p + strlen(p) - 1; e > p; e--) {",
          "7124:      if (e[0] == '/') {",
          "7125:       break;",
          "7126:      }",
          "7127:     }",
          "7128:     mg_snprintf(conn,",
          "7129:                 &truncated,",
          "7130:                 name,",
          "7131:                 sizeof(name),",
          "7132:                 \"%.*s/%s\",",
          "7133:                 (int)(e - p),",
          "7134:                 p,",
          "7135:                 PASSWORDS_FILE_NAME);",
          "7137:     if (truncated",
          "7138:         || !mg_fopen(conn, name, MG_FOPEN_MODE_READ, filep)) {",
          "7143:      DEBUG_TRACE(\"fopen(%s): %s\", name, strerror(ERRNO));",
          "7145:     }",
          "7152:  struct ah {",
          "7153:   char *user, *uri, *cnonce, *response, *qop, *nc, *nonce;",
          "7154:  };",
          "7158:  static int parse_auth_header(struct mg_connection * conn,",
          "7159:                               char *buf,",
          "7160:                               size_t buf_size,",
          "7161:                               struct ah *ah)",
          "7162:  {",
          "7163:   char *name, *value, *s;",
          "7164:   const char *auth_header;",
          "7165:   uint64_t nonce;",
          "7167:   if (!ah || !conn) {",
          "7168:    return 0;",
          "7169:   }",
          "7171:   (void)memset(ah, 0, sizeof(*ah));",
          "7172:   if (((auth_header = mg_get_header(conn, \"Authorization\")) == NULL)",
          "7173:       || mg_strncasecmp(auth_header, \"Digest \", 7) != 0) {",
          "7174:    return 0;",
          "7175:   }",
          "7178:   (void)mg_strlcpy(buf, auth_header + 7, buf_size);",
          "7179:   s = buf;",
          "7182:   for (;;) {",
          "7184:    while (isspace(*(unsigned char *)s)) {",
          "7185:     s++;",
          "7186:    }",
          "7187:    name = skip_quoted(&s, \"=\", \" \", 0);",
          "7190:    if (s[0] == '\\\"') {",
          "7192:     value = skip_quoted(&s, \"\\\"\", \" \", '\\\\');",
          "7193:     if (s[0] == ',') {",
          "7194:      s++;",
          "7195:     }",
          "7196:    } else {",
          "7197:     value =",
          "7198:         skip_quoted(&s, \", \", \" \", 0); /* IE uses commas, FF uses",
          "7200:    }",
          "7201:    if (*name == '\\0') {",
          "7202:     break;",
          "7203:    }",
          "7205:    if (!strcmp(name, \"username\")) {",
          "7206:     ah->user = value;",
          "7207:    } else if (!strcmp(name, \"cnonce\")) {",
          "7208:     ah->cnonce = value;",
          "7209:    } else if (!strcmp(name, \"response\")) {",
          "7210:     ah->response = value;",
          "7211:    } else if (!strcmp(name, \"uri\")) {",
          "7212:     ah->uri = value;",
          "7213:    } else if (!strcmp(name, \"qop\")) {",
          "7214:     ah->qop = value;",
          "7215:    } else if (!strcmp(name, \"nc\")) {",
          "7216:     ah->nc = value;",
          "7217:    } else if (!strcmp(name, \"nonce\")) {",
          "7218:     ah->nonce = value;",
          "7222: #ifndef NO_NONCE_CHECK",
          "7224:   if (ah->nonce == NULL) {",
          "7225:    return 0;",
          "7227:   s = NULL;",
          "7228:   nonce = strtoull(ah->nonce, &s, 10);",
          "7229:   if ((s == NULL) || (*s != 0)) {",
          "7230:    return 0;",
          "7234:   nonce ^= conn->ctx->auth_nonce_mask;",
          "7244:   if (nonce < (uint64_t)conn->ctx->start_time) {",
          "7247:    return 0;",
          "7248:   }",
          "7251:   if (nonce",
          "7252:       >= ((uint64_t)conn->ctx->start_time + conn->ctx->nonce_count)) {",
          "7253:    return 0;",
          "7254:   }",
          "7260:   if (ah->user != NULL) {",
          "7261:    conn->request_info.remote_user = mg_strdup(ah->user);",
          "7262:   } else {",
          "7263:    return 0;",
          "7264:   }",
          "7266:   return 1;",
          "7270:  static const char *mg_fgets(char *buf,",
          "7271:                              size_t size,",
          "7272:                              struct mg_file *filep,",
          "7273:                              char **p)",
          "7274:  {",
          "7275:   const char *eof;",
          "7276:   size_t len;",
          "7277:   const char *memend;",
          "7279:   if (!filep) {",
          "7280:    return NULL;",
          "7281:   }",
          "7283:   if ((filep->access.membuf != NULL) && (*p != NULL)) {",
          "7284:    memend = (const char *)&filep->access.membuf[filep->stat.size];",
          "7286:    eof = (char *)memchr(*p, '\\n', (size_t)(memend - *p));",
          "7287:    if (eof != NULL) {",
          "7289:    } else {",
          "7291:    }",
          "7292:    len = ((size_t)(eof - *p) > (size - 1)) ? (size - 1)",
          "7293:                                            : (size_t)(eof - *p);",
          "7294:    memcpy(buf, *p, len);",
          "7295:    buf[len] = '\\0';",
          "7297:    return len ? eof : NULL;",
          "7298:   } else if (filep->access.fp != NULL) {",
          "7299:    return fgets(buf, (int)size, filep->access.fp);",
          "7301:    return NULL;",
          "7302:   }",
          "",
          "[Added Lines]",
          "5659:  return -1;",
          "5660: }",
          "5663: static int",
          "5664: pull_all(FILE *fp, struct mg_connection *conn, char *buf, int len)",
          "5665: {",
          "5666:  int n, nread = 0;",
          "5667:  double timeout = -1.0;",
          "5668:  uint64_t start_time = 0, now = 0, timeout_ns = 0;",
          "5670:  if (conn->ctx->config[REQUEST_TIMEOUT]) {",
          "5671:   timeout = atoi(conn->ctx->config[REQUEST_TIMEOUT]) / 1000.0;",
          "5672:  }",
          "5673:  if (timeout >= 0.0) {",
          "5674:   start_time = mg_get_current_time_ns();",
          "5675:   timeout_ns = (uint64_t)(timeout * 1.0E9);",
          "5676:  }",
          "5678:  while ((len > 0) && (conn->ctx->stop_flag == 0)) {",
          "5679:   n = pull_inner(fp, conn, buf + nread, len, timeout);",
          "5680:   if (n == -2) {",
          "5681:    if (nread == 0) {",
          "5683:    }",
          "5684:    break;",
          "5685:   } else if (n == -1) {",
          "5687:    if (timeout >= 0.0) {",
          "5688:     now = mg_get_current_time_ns();",
          "5689:     if ((now - start_time) <= timeout_ns) {",
          "5690:      continue;",
          "5693:    break;",
          "5694:   } else if (n == 0) {",
          "5696:   } else {",
          "5697:    conn->consumed_content += n;",
          "5698:    nread += n;",
          "5699:    len -= n;",
          "5703:  return nread;",
          "5704: }",
          "5707: static void",
          "5708: discard_unread_request_data(struct mg_connection *conn)",
          "5709: {",
          "5710:  char buf[MG_BUF_LEN];",
          "5711:  size_t to_read;",
          "5712:  int nread;",
          "5714:  if (conn == NULL) {",
          "5715:   return;",
          "5716:  }",
          "5718:  to_read = sizeof(buf);",
          "5720:  if (conn->is_chunked) {",
          "5723:   while (conn->is_chunked == 1) {",
          "5724:    nread = mg_read(conn, buf, to_read);",
          "5725:    if (nread <= 0) {",
          "5726:     break;",
          "5728:   }",
          "5730:  } else {",
          "5732:   while (conn->consumed_content < conn->content_len) {",
          "5733:    if (to_read",
          "5734:        > (size_t)(conn->content_len - conn->consumed_content)) {",
          "5735:     to_read = (size_t)(conn->content_len - conn->consumed_content);",
          "5736:    }",
          "5738:    nread = mg_read(conn, buf, to_read);",
          "5739:    if (nread <= 0) {",
          "5740:     break;",
          "5744: }",
          "5747: static int",
          "5748: mg_read_inner(struct mg_connection *conn, void *buf, size_t len)",
          "5749: {",
          "5750:  int64_t n, buffered_len, nread;",
          "5751:  int64_t len64 =",
          "5752:      (int64_t)((len > INT_MAX) ? INT_MAX : len); /* since the return value is",
          "5755:  const char *body;",
          "5757:  if (conn == NULL) {",
          "5758:   return 0;",
          "5759:  }",
          "5763:  if ((conn->consumed_content) == 0 && (conn->content_len == -1)) {",
          "5764:   conn->content_len = INT64_MAX;",
          "5765:   conn->must_close = 1;",
          "5766:  }",
          "5768:  nread = 0;",
          "5769:  if (conn->consumed_content < conn->content_len) {",
          "5771:   int64_t left_to_read = conn->content_len - conn->consumed_content;",
          "5772:   if (left_to_read < len64) {",
          "5776:    len64 = left_to_read;",
          "5777:   }",
          "5780:   buffered_len = (int64_t)(conn->data_len) - (int64_t)conn->request_len",
          "5781:                  - conn->consumed_content;",
          "5782:   if (buffered_len > 0) {",
          "5783:    if (len64 < buffered_len) {",
          "5784:     buffered_len = len64;",
          "5786:    body = conn->buf + conn->request_len + conn->consumed_content;",
          "5787:    memcpy(buf, body, (size_t)buffered_len);",
          "5788:    len64 -= buffered_len;",
          "5789:    conn->consumed_content += buffered_len;",
          "5790:    nread += buffered_len;",
          "5791:    buf = (char *)buf + buffered_len;",
          "5792:   }",
          "5797:   if ((n = pull_all(NULL, conn, (char *)buf, (int)len64)) >= 0) {",
          "5798:    nread += n;",
          "5799:   } else {",
          "5800:    nread = ((nread > 0) ? nread : n);",
          "5803:  return (int)nread;",
          "5804: }",
          "5807: static char",
          "5808: mg_getc(struct mg_connection *conn)",
          "5809: {",
          "5810:  char c;",
          "5811:  if (conn == NULL) {",
          "5812:   return 0;",
          "5814:  conn->content_len++;",
          "5815:  if (mg_read_inner(conn, &c, 1) <= 0) {",
          "5816:   return (char)0;",
          "5817:  }",
          "5818:  return c;",
          "5819: }",
          "5822: int",
          "5823: mg_read(struct mg_connection *conn, void *buf, size_t len)",
          "5824: {",
          "5825:  if (len > INT_MAX) {",
          "5826:   len = INT_MAX;",
          "5827:  }",
          "5829:  if (conn == NULL) {",
          "5830:   return 0;",
          "5831:  }",
          "5833:  if (conn->is_chunked) {",
          "5834:   size_t all_read = 0;",
          "5836:   while (len > 0) {",
          "5838:    if (conn->is_chunked == 2) {",
          "5840:     return 0;",
          "5841:    }",
          "5843:    if (conn->chunk_remainder) {",
          "5845:     long read_ret;",
          "5846:     size_t read_now =",
          "5847:         ((conn->chunk_remainder > len) ? (len)",
          "5848:                                        : (conn->chunk_remainder));",
          "5850:     conn->content_len += (int)read_now;",
          "5851:     read_ret =",
          "5852:         mg_read_inner(conn, (char *)buf + all_read, read_now);",
          "5854:     if (read_ret < 1) {",
          "5856:      return -1;",
          "5857:     }",
          "5859:     all_read += (size_t)read_ret;",
          "5860:     conn->chunk_remainder -= (size_t)read_ret;",
          "5861:     len -= (size_t)read_ret;",
          "5863:     if (conn->chunk_remainder == 0) {",
          "5866:      char x1 = mg_getc(conn);",
          "5867:      char x2 = mg_getc(conn);",
          "5868:      if ((x1 != '\\r') || (x2 != '\\n')) {",
          "5872:     }",
          "5874:    } else {",
          "5876:     int i = 0;",
          "5877:     char lenbuf[64];",
          "5878:     char *end = 0;",
          "5879:     unsigned long chunkSize = 0;",
          "5881:     for (i = 0; i < ((int)sizeof(lenbuf) - 1); i++) {",
          "5882:      lenbuf[i] = mg_getc(conn);",
          "5883:      if ((i > 0) && (lenbuf[i] == '\\r')",
          "5884:          && (lenbuf[i - 1] != '\\r')) {",
          "5885:       continue;",
          "5887:      if ((i > 1) && (lenbuf[i] == '\\n')",
          "5888:          && (lenbuf[i - 1] == '\\r')) {",
          "5889:       lenbuf[i + 1] = 0;",
          "5890:       chunkSize = strtoul(lenbuf, &end, 16);",
          "5891:       if (chunkSize == 0) {",
          "5893:        conn->is_chunked = 2;",
          "5895:       break;",
          "5897:      if (!isxdigit(lenbuf[i])) {",
          "5902:     if ((end == NULL) || (*end != '\\r')) {",
          "5904:      return -1;",
          "5905:     }",
          "5906:     if (chunkSize == 0) {",
          "5907:      break;",
          "5908:     }",
          "5910:     conn->chunk_remainder = chunkSize;",
          "5911:    }",
          "5914:   return (int)all_read;",
          "5916:  return mg_read_inner(conn, buf, len);",
          "5917: }",
          "5920: int",
          "5921: mg_write(struct mg_connection *conn, const void *buf, size_t len)",
          "5922: {",
          "5923:  time_t now;",
          "5924:  int64_t n, total, allowed;",
          "5926:  if (conn == NULL) {",
          "5927:   return 0;",
          "5928:  }",
          "5930:  if (conn->throttle > 0) {",
          "5931:   if ((now = time(NULL)) != conn->last_throttle_time) {",
          "5932:    conn->last_throttle_time = now;",
          "5933:    conn->last_throttle_bytes = 0;",
          "5934:   }",
          "5935:   allowed = conn->throttle - conn->last_throttle_bytes;",
          "5936:   if (allowed > (int64_t)len) {",
          "5937:    allowed = (int64_t)len;",
          "5938:   }",
          "5939:   if ((total = push_all(conn->ctx,",
          "5940:                         NULL,",
          "5941:                         conn->client.sock,",
          "5942:                         conn->ssl,",
          "5943:                         (const char *)buf,",
          "5944:                         (int64_t)allowed)) == allowed) {",
          "5945:    buf = (const char *)buf + total;",
          "5946:    conn->last_throttle_bytes += total;",
          "5947:    while ((total < (int64_t)len) && (conn->ctx->stop_flag == 0)) {",
          "5948:     allowed = (conn->throttle > ((int64_t)len - total))",
          "5949:                   ? (int64_t)len - total",
          "5950:                   : conn->throttle;",
          "5951:     if ((n = push_all(conn->ctx,",
          "5952:                       NULL,",
          "5953:                       conn->client.sock,",
          "5954:                       conn->ssl,",
          "5955:                       (const char *)buf,",
          "5956:                       (int64_t)allowed)) != allowed) {",
          "5957:      break;",
          "5959:     sleep(1);",
          "5960:     conn->last_throttle_bytes = allowed;",
          "5961:     conn->last_throttle_time = time(NULL);",
          "5962:     buf = (const char *)buf + n;",
          "5963:     total += n;",
          "5966:  } else {",
          "5967:   total = push_all(conn->ctx,",
          "5968:                    NULL,",
          "5969:                    conn->client.sock,",
          "5970:                    conn->ssl,",
          "5971:                    (const char *)buf,",
          "5972:                    (int64_t)len);",
          "5974:  if (total > 0) {",
          "5975:   conn->num_bytes_sent += total;",
          "5976:  }",
          "5977:  return (int)total;",
          "5978: }",
          "5982: int",
          "5983: mg_send_chunk(struct mg_connection *conn,",
          "5984:               const char *chunk,",
          "5985:               unsigned int chunk_len)",
          "5986: {",
          "5987:  char lenbuf[16];",
          "5988:  size_t lenbuf_len;",
          "5989:  int ret;",
          "5990:  int t;",
          "5993:  sprintf(lenbuf, \"%x\\r\\n\", chunk_len);",
          "5994:  lenbuf_len = strlen(lenbuf);",
          "5997:  ret = mg_write(conn, lenbuf, lenbuf_len);",
          "5998:  if (ret != (int)lenbuf_len) {",
          "5999:   return -1;",
          "6000:  }",
          "6001:  t = ret;",
          "6003:  ret = mg_write(conn, chunk, chunk_len);",
          "6004:  if (ret != (int)chunk_len) {",
          "6005:   return -1;",
          "6006:  }",
          "6007:  t += ret;",
          "6009:  ret = mg_write(conn, \"\\r\\n\", 2);",
          "6010:  if (ret != 2) {",
          "6011:   return -1;",
          "6013:  t += ret;",
          "6015:  return t;",
          "6016: }",
          "6020: static int",
          "6021: alloc_vprintf2(char **buf, const char *fmt, va_list ap)",
          "6022: {",
          "6023:  va_list ap_copy;",
          "6024:  size_t size = MG_BUF_LEN / 4;",
          "6025:  int len = -1;",
          "6028:  while (len < 0) {",
          "6029:   if (*buf) {",
          "6030:    mg_free(*buf);",
          "6031:   }",
          "6033:   size *= 4;",
          "6035:   if (!*buf) {",
          "6036:    break;",
          "6039:   va_copy(ap_copy, ap);",
          "6040:   len = vsnprintf_impl(*buf, size - 1, fmt, ap_copy);",
          "6041:   va_end(ap_copy);",
          "6042:   (*buf)[size - 1] = 0;",
          "6045:  return len;",
          "6046: }",
          "6053: static int",
          "6054: alloc_vprintf(char **out_buf,",
          "6055:               char *prealloc_buf,",
          "6056:               size_t prealloc_size,",
          "6057:               const char *fmt,",
          "6058:               va_list ap)",
          "6059: {",
          "6060:  va_list ap_copy;",
          "6061:  int len;",
          "6069:  va_copy(ap_copy, ap);",
          "6070:  len = vsnprintf_impl(NULL, 0, fmt, ap_copy);",
          "6071:  va_end(ap_copy);",
          "6073:  if (len < 0) {",
          "6079:   len = alloc_vprintf2(out_buf, fmt, ap_copy);",
          "6082:  } else if ((size_t)(len) >= prealloc_size) {",
          "6086:   if (!*out_buf) {",
          "6088:    return -1;",
          "6091:   va_copy(ap_copy, ap);",
          "6092:   IGNORE_UNUSED_RESULT(",
          "6093:       vsnprintf_impl(*out_buf, (size_t)(len) + 1, fmt, ap_copy));",
          "6094:   va_end(ap_copy);",
          "6096:  } else {",
          "6099:   va_copy(ap_copy, ap);",
          "6100:   IGNORE_UNUSED_RESULT(",
          "6101:       vsnprintf_impl(prealloc_buf, prealloc_size, fmt, ap_copy));",
          "6102:   va_end(ap_copy);",
          "6106:  return len;",
          "6107: }",
          "6110: static int",
          "6111: mg_vprintf(struct mg_connection *conn, const char *fmt, va_list ap)",
          "6112: {",
          "6113:  char mem[MG_BUF_LEN];",
          "6114:  char *buf = NULL;",
          "6115:  int len;",
          "6117:  if ((len = alloc_vprintf(&buf, mem, sizeof(mem), fmt, ap)) > 0) {",
          "6118:   len = mg_write(conn, buf, (size_t)len);",
          "6120:  if ((buf != mem) && (buf != NULL)) {",
          "6121:   mg_free(buf);",
          "6122:  }",
          "6124:  return len;",
          "6125: }",
          "6128: int",
          "6129: mg_printf(struct mg_connection *conn, const char *fmt, ...)",
          "6130: {",
          "6131:  va_list ap;",
          "6132:  int result;",
          "6134:  va_start(ap, fmt);",
          "6135:  result = mg_vprintf(conn, fmt, ap);",
          "6136:  va_end(ap);",
          "6138:  return result;",
          "6139: }",
          "6142: int",
          "6143: mg_url_decode(const char *src,",
          "6144:               int src_len,",
          "6145:               char *dst,",
          "6146:               int dst_len,",
          "6147:               int is_form_url_encoded)",
          "6148: {",
          "6149:  int i, j, a, b;",
          "6152:  for (i = j = 0; (i < src_len) && (j < (dst_len - 1)); i++, j++) {",
          "6153:   if ((i < src_len - 2) && (src[i] == '%')",
          "6154:       && isxdigit(*(const unsigned char *)(src + i + 1))",
          "6155:       && isxdigit(*(const unsigned char *)(src + i + 2))) {",
          "6156:    a = tolower(*(const unsigned char *)(src + i + 1));",
          "6157:    b = tolower(*(const unsigned char *)(src + i + 2));",
          "6158:    dst[j] = (char)((HEXTOI(a) << 4) | HEXTOI(b));",
          "6159:    i += 2;",
          "6160:   } else if (is_form_url_encoded && (src[i] == '+')) {",
          "6161:    dst[j] = ' ';",
          "6162:   } else {",
          "6163:    dst[j] = src[i];",
          "6165:  }",
          "6169:  return (i >= src_len) ? j : -1;",
          "6170: }",
          "6173: int",
          "6174: mg_get_var(const char *data,",
          "6175:            size_t data_len,",
          "6176:            const char *name,",
          "6177:            char *dst,",
          "6178:            size_t dst_len)",
          "6179: {",
          "6180:  return mg_get_var2(data, data_len, name, dst, dst_len, 0);",
          "6181: }",
          "6184: int",
          "6185: mg_get_var2(const char *data,",
          "6186:             size_t data_len,",
          "6187:             const char *name,",
          "6188:             char *dst,",
          "6189:             size_t dst_len,",
          "6190:             size_t occurrence)",
          "6191: {",
          "6192:  const char *p, *e, *s;",
          "6193:  size_t name_len;",
          "6194:  int len;",
          "6196:  if ((dst == NULL) || (dst_len == 0)) {",
          "6197:   len = -2;",
          "6198:  } else if ((data == NULL) || (name == NULL) || (data_len == 0)) {",
          "6199:   len = -1;",
          "6200:   dst[0] = '\\0';",
          "6201:  } else {",
          "6202:   name_len = strlen(name);",
          "6203:   e = data + data_len;",
          "6204:   len = -1;",
          "6205:   dst[0] = '\\0';",
          "6208:   for (p = data; p + name_len < e; p++) {",
          "6209:    if (((p == data) || (p[-1] == '&')) && (p[name_len] == '=')",
          "6210:        && !mg_strncasecmp(name, p, name_len) && 0 == occurrence--) {",
          "6212:     p += name_len + 1;",
          "6215:     s = (const char *)memchr(p, '&', (size_t)(e - p));",
          "6216:     if (s == NULL) {",
          "6217:      s = e;",
          "6218:     }",
          "6220:     if (s < p) {",
          "6221:      return -3;",
          "6222:     }",
          "6225:     len = mg_url_decode(p, (int)(s - p), dst, (int)dst_len, 1);",
          "6229:     if (len == -1) {",
          "6230:      len = -2;",
          "6232:     break;",
          "6237:  return len;",
          "6238: }",
          "6242: int",
          "6243: mg_get_cookie(const char *cookie_header,",
          "6244:               const char *var_name,",
          "6245:               char *dst,",
          "6246:               size_t dst_size)",
          "6247: {",
          "6248:  const char *s, *p, *end;",
          "6249:  int name_len, len = -1;",
          "6251:  if ((dst == NULL) || (dst_size == 0)) {",
          "6252:   return -2;",
          "6253:  }",
          "6255:  dst[0] = '\\0';",
          "6256:  if ((var_name == NULL) || ((s = cookie_header) == NULL)) {",
          "6257:   return -1;",
          "6258:  }",
          "6260:  name_len = (int)strlen(var_name);",
          "6261:  end = s + strlen(s);",
          "6262:  for (; (s = mg_strcasestr(s, var_name)) != NULL; s += name_len) {",
          "6263:   if (s[name_len] == '=') {",
          "6265:    if ((s == cookie_header) || (s[-1] == ' ')) {",
          "6266:     s += name_len + 1;",
          "6267:     if ((p = strchr(s, ' ')) == NULL) {",
          "6268:      p = end;",
          "6269:     }",
          "6270:     if (p[-1] == ';') {",
          "6271:      p--;",
          "6272:     }",
          "6273:     if ((*s == '\"') && (p[-1] == '\"') && (p > s + 1)) {",
          "6274:      s++;",
          "6275:      p--;",
          "6276:     }",
          "6277:     if ((size_t)(p - s) < dst_size) {",
          "6278:      len = (int)(p - s);",
          "6279:      mg_strlcpy(dst, s, (size_t)len + 1);",
          "6280:     } else {",
          "6281:      len = -3;",
          "6283:     break;",
          "6287:  return len;",
          "6288: }",
          "6292: static void",
          "6293: base64_encode(const unsigned char *src, int src_len, char *dst)",
          "6294: {",
          "6295:  static const char *b64 =",
          "6296:      \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";",
          "6297:  int i, j, a, b, c;",
          "6299:  for (i = j = 0; i < src_len; i += 3) {",
          "6300:   a = src[i];",
          "6301:   b = ((i + 1) >= src_len) ? 0 : src[i + 1];",
          "6302:   c = ((i + 2) >= src_len) ? 0 : src[i + 2];",
          "6304:   dst[j++] = b64[a >> 2];",
          "6305:   dst[j++] = b64[((a & 3) << 4) | (b >> 4)];",
          "6306:   if (i + 1 < src_len) {",
          "6307:    dst[j++] = b64[(b & 15) << 2 | (c >> 6)];",
          "6309:   if (i + 2 < src_len) {",
          "6310:    dst[j++] = b64[c & 63];",
          "6313:  while (j % 4 != 0) {",
          "6314:   dst[j++] = '=';",
          "6315:  }",
          "6316:  dst[j++] = '\\0';",
          "6317: }",
          "6322: static unsigned char",
          "6323: b64reverse(char letter)",
          "6324: {",
          "6325:  if ((letter >= 'A') && (letter <= 'Z')) {",
          "6326:   return letter - 'A';",
          "6327:  }",
          "6328:  if ((letter >= 'a') && (letter <= 'z')) {",
          "6329:   return letter - 'a' + 26;",
          "6330:  }",
          "6331:  if ((letter >= '0') && (letter <= '9')) {",
          "6332:   return letter - '0' + 52;",
          "6333:  }",
          "6334:  if (letter == '+') {",
          "6335:   return 62;",
          "6336:  }",
          "6337:  if (letter == '/') {",
          "6338:   return 63;",
          "6340:  if (letter == '=') {",
          "6342:  }",
          "6344: }",
          "6347: static int",
          "6348: base64_decode(const unsigned char *src, int src_len, char *dst, size_t *dst_len)",
          "6349: {",
          "6350:  int i;",
          "6351:  unsigned char a, b, c, d;",
          "6355:  for (i = 0; i < src_len; i += 4) {",
          "6356:   a = b64reverse(src[i]);",
          "6357:   if (a >= 254) {",
          "6358:    return i;",
          "6359:   }",
          "6361:   b = b64reverse(((i + 1) >= src_len) ? 0 : src[i + 1]);",
          "6362:   if (b >= 254) {",
          "6363:    return i + 1;",
          "6364:   }",
          "6366:   c = b64reverse(((i + 2) >= src_len) ? 0 : src[i + 2]);",
          "6367:   if (c == 254) {",
          "6368:    return i + 2;",
          "6369:   }",
          "6371:   d = b64reverse(((i + 3) >= src_len) ? 0 : src[i + 3]);",
          "6372:   if (d == 254) {",
          "6373:    return i + 3;",
          "6374:   }",
          "6376:   dst[(*dst_len)++] = (a << 2) + (b >> 4);",
          "6377:   if (c != 255) {",
          "6378:    dst[(*dst_len)++] = (b << 4) + (c >> 2);",
          "6379:    if (d != 255) {",
          "6380:     dst[(*dst_len)++] = (c << 6) + d;",
          "6384:  return -1;",
          "6385: }",
          "6389: static int",
          "6390: is_put_or_delete_method(const struct mg_connection *conn)",
          "6391: {",
          "6392:  if (conn) {",
          "6393:   const char *s = conn->request_info.request_method;",
          "6394:   return (s != NULL) && (!strcmp(s, \"PUT\") || !strcmp(s, \"DELETE\")",
          "6395:                          || !strcmp(s, \"MKCOL\") || !strcmp(s, \"PATCH\"));",
          "6397:  return 0;",
          "6398: }",
          "6402: static int",
          "6403: extention_matches_script(",
          "6406:     )",
          "6407: {",
          "6409:  if (match_prefix(conn->ctx->config[CGI_EXTENSIONS],",
          "6410:                   strlen(conn->ctx->config[CGI_EXTENSIONS]),",
          "6411:                   filename) > 0) {",
          "6412:   return 1;",
          "6413:  }",
          "6416:  if (match_prefix(conn->ctx->config[LUA_SCRIPT_EXTENSIONS],",
          "6417:                   strlen(conn->ctx->config[LUA_SCRIPT_EXTENSIONS]),",
          "6418:                   filename) > 0) {",
          "6419:   return 1;",
          "6420:  }",
          "6423:  if (match_prefix(conn->ctx->config[DUKTAPE_SCRIPT_EXTENSIONS],",
          "6424:                   strlen(conn->ctx->config[DUKTAPE_SCRIPT_EXTENSIONS]),",
          "6425:                   filename) > 0) {",
          "6426:   return 1;",
          "6428: #endif",
          "6431:  (void)filename;",
          "6432:  (void)conn;",
          "6434:  return 0;",
          "6435: }",
          "6441: static int",
          "6442: substitute_index_file(struct mg_connection *conn,",
          "6443:                       char *path,",
          "6444:                       size_t path_len,",
          "6445:                       struct mg_file_stat *filestat)",
          "6446: {",
          "6447:  const char *list = conn->ctx->config[INDEX_FILES];",
          "6448:  struct vec filename_vec;",
          "6449:  size_t n = strlen(path);",
          "6450:  int found = 0;",
          "6455:  while ((n > 0) && (path[n - 1] == '/')) {",
          "6456:   n--;",
          "6457:  }",
          "6458:  path[n] = '/';",
          "6462:  while ((list = next_option(list, &filename_vec, NULL)) != NULL) {",
          "6464:   if (filename_vec.len > (path_len - (n + 2))) {",
          "6465:    continue;",
          "6469:   mg_strlcpy(path + n + 1, filename_vec.ptr, filename_vec.len + 1);",
          "6472:   if (mg_stat(conn, path, filestat)) {",
          "6474:    found = 1;",
          "6475:    break;",
          "6477:  }",
          "6480:  if (!found) {",
          "6481:   path[n] = '\\0';",
          "6484:  return found;",
          "6485: }",
          "6489: static void",
          "6498:               )",
          "6499: {",
          "6501:  const char *uri = conn->request_info.local_uri;",
          "6502:  const char *root = conn->ctx->config[DOCUMENT_ROOT];",
          "6503:  const char *rewrite;",
          "6504:  struct vec a, b;",
          "6505:  int match_len;",
          "6506:  char gz_path[PATH_MAX];",
          "6507:  char const *accept_encoding;",
          "6508:  int truncated;",
          "6510:  char *tmp_str;",
          "6511:  size_t tmp_str_len, sep_pos;",
          "6518:  memset(filestat, 0, sizeof(*filestat));",
          "6531:  if (*is_websocket_request && conn->ctx->config[WEBSOCKET_ROOT]) {",
          "6532:   root = conn->ctx->config[WEBSOCKET_ROOT];",
          "6533:  }",
          "6544:  if (root == NULL) {",
          "6547:   return;",
          "6548:  }",
          "6554:  mg_snprintf(",
          "6555:      conn, &truncated, filename, filename_buf_len - 1, \"%s%s\", root, uri);",
          "6557:  if (truncated) {",
          "6558:   goto interpret_cleanup;",
          "6559:  }",
          "6562:  rewrite = conn->ctx->config[URL_REWRITE_PATTERN];",
          "6563:  while ((rewrite = next_option(rewrite, &a, &b)) != NULL) {",
          "6564:   if ((match_len = match_prefix(a.ptr, a.len, uri)) > 0) {",
          "6565:    mg_snprintf(conn,",
          "6566:                &truncated,",
          "6567:                filename,",
          "6568:                filename_buf_len - 1,",
          "6569:                \"%.*s%s\",",
          "6570:                (int)b.len,",
          "6571:                b.ptr,",
          "6572:                uri + match_len);",
          "6573:    break;",
          "6575:  }",
          "6577:  if (truncated) {",
          "6578:   goto interpret_cleanup;",
          "6579:  }",
          "6584:  if (mg_stat(conn, filename, filestat)) {",
          "6589:   if (extention_matches_script(conn, filename)) {",
          "6602:   }",
          "6606:   if (filestat->is_directory) {",
          "6609:    struct mg_file_stat tmp_filestat;",
          "6610:    memset(&tmp_filestat, 0, sizeof(tmp_filestat));",
          "6612:    if (substitute_index_file(",
          "6613:            conn, filename, filename_buf_len, &tmp_filestat)) {",
          "6619:     if (extention_matches_script(conn, filename)) {",
          "6622:     } else {",
          "6631:   return;",
          "6632:  }",
          "6641:  if ((accept_encoding = mg_get_header(conn, \"Accept-Encoding\")) != NULL) {",
          "6642:   if (strstr(accept_encoding, \"gzip\") != NULL) {",
          "6643:    mg_snprintf(",
          "6644:        conn, &truncated, gz_path, sizeof(gz_path), \"%s.gz\", filename);",
          "6646:    if (truncated) {",
          "6647:     goto interpret_cleanup;",
          "6648:    }",
          "6650:    if (mg_stat(conn, gz_path, filestat)) {",
          "6651:     if (filestat) {",
          "6652:      filestat->is_gzipped = 1;",
          "6656:     return;",
          "6659:  }",
          "6664:  tmp_str_len = strlen(filename);",
          "6665:  tmp_str = mg_malloc_ctx(tmp_str_len + PATH_MAX + 1, conn->ctx);",
          "6666:  if (!tmp_str) {",
          "6668:   goto interpret_cleanup;",
          "6669:  }",
          "6670:  memcpy(tmp_str, filename, tmp_str_len + 1);",
          "6672:  sep_pos = tmp_str_len;",
          "6673:  while (sep_pos > 0) {",
          "6674:   sep_pos--;",
          "6675:   if (tmp_str[sep_pos] == '/') {",
          "6676:    int is_script = 0, does_exist = 0;",
          "6678:    tmp_str[sep_pos] = 0;",
          "6679:    if (tmp_str[0]) {",
          "6680:     is_script = extention_matches_script(conn, tmp_str);",
          "6681:     does_exist = mg_stat(conn, tmp_str, filestat);",
          "6682:    }",
          "6684:    if (does_exist && is_script) {",
          "6685:     filename[sep_pos] = 0;",
          "6686:     memmove(filename + sep_pos + 2,",
          "6687:             filename + sep_pos + 1,",
          "6688:             strlen(filename + sep_pos + 1) + 1);",
          "6689:     conn->path_info = filename + sep_pos + 1;",
          "6690:     filename[sep_pos + 1] = '/';",
          "6693:     break;",
          "6694:    }",
          "6695:    if (substitute_index_file(",
          "6696:            conn, tmp_str, tmp_str_len + PATH_MAX, filestat)) {",
          "6698:     if (extention_matches_script(conn, tmp_str)) {",
          "6701:      char *tmp_str2 = mg_strdup(filename + sep_pos + 1);",
          "6702:      mg_snprintf(conn,",
          "6703:                  &truncated,",
          "6704:                  filename,",
          "6705:                  filename_buf_len,",
          "6706:                  \"%s//%s\",",
          "6707:                  tmp_str,",
          "6708:                  tmp_str2);",
          "6709:      mg_free(tmp_str2);",
          "6711:      if (truncated) {",
          "6712:       mg_free(tmp_str);",
          "6713:       goto interpret_cleanup;",
          "6714:      }",
          "6715:      sep_pos = strlen(tmp_str);",
          "6721:     } else {",
          "6723:      filename[sep_pos] = 0;",
          "6724:      conn->path_info = 0;",
          "6727:      break;",
          "6731:    tmp_str[sep_pos] = '/';",
          "6733:  }",
          "6735:  mg_free(tmp_str);",
          "6739:  return;",
          "6743: interpret_cleanup:",
          "6744:  memset(filestat, 0, sizeof(*filestat));",
          "6751: }",
          "6758: static int",
          "6759: get_http_header_len(const char *buf, int buflen)",
          "6760: {",
          "6761:  int i;",
          "6762:  for (i = 0; i < buflen; i++) {",
          "6764:   const unsigned char c = ((const unsigned char *)buf)[i];",
          "6766:   if ((c < 128) && ((char)c != '\\r') && ((char)c != '\\n')",
          "6767:       && !isprint(c)) {",
          "6769:    return -1;",
          "6770:   }",
          "6772:   if (i < buflen - 1) {",
          "6773:    if ((buf[i] == '\\n') && (buf[i + 1] == '\\n')) {",
          "6778:     return i + 2;",
          "6782:   if (i < buflen - 3) {",
          "6783:    if ((buf[i] == '\\r') && (buf[i + 1] == '\\n') && (buf[i + 2] == '\\r')",
          "6784:        && (buf[i + 3] == '\\n')) {",
          "6786:     return i + 4;",
          "6787:    }",
          "6788:   }",
          "6791:  return 0;",
          "6792: }",
          "6797: static int",
          "6798: get_month_index(const char *s)",
          "6799: {",
          "6800:  size_t i;",
          "6802:  for (i = 0; i < ARRAY_SIZE(month_names); i++) {",
          "6803:   if (!strcmp(s, month_names[i])) {",
          "6804:    return (int)i;",
          "6808:  return -1;",
          "6809: }",
          "6813: static time_t",
          "6814: parse_date_string(const char *datetime)",
          "6815: {",
          "6816:  char month_str[32] = {0};",
          "6817:  int second, minute, hour, day, month, year;",
          "6818:  time_t result = (time_t)0;",
          "6819:  struct tm tm;",
          "6821:  if ((sscanf(datetime,",
          "6822:              \"%d/%3s/%d %d:%d:%d\",",
          "6823:              &day,",
          "6824:              month_str,",
          "6825:              &year,",
          "6826:              &hour,",
          "6827:              &minute,",
          "6828:              &second) == 6) || (sscanf(datetime,",
          "6829:                                        \"%d %3s %d %d:%d:%d\",",
          "6830:                                        &day,",
          "6831:                                        month_str,",
          "6832:                                        &year,",
          "6833:                                        &hour,",
          "6834:                                        &minute,",
          "6835:                                        &second) == 6)",
          "6836:      || (sscanf(datetime,",
          "6837:                 \"%*3s, %d %3s %d %d:%d:%d\",",
          "6838:                 &day,",
          "6839:                 month_str,",
          "6840:                 &year,",
          "6841:                 &hour,",
          "6842:                 &minute,",
          "6843:                 &second) == 6) || (sscanf(datetime,",
          "6844:                                           \"%d-%3s-%d %d:%d:%d\",",
          "6845:                                           &day,",
          "6846:                                           month_str,",
          "6847:                                           &year,",
          "6848:                                           &hour,",
          "6849:                                           &minute,",
          "6850:                                           &second) == 6)) {",
          "6851:   month = get_month_index(month_str);",
          "6852:   if ((month >= 0) && (year >= 1970)) {",
          "6853:    memset(&tm, 0, sizeof(tm));",
          "6854:    tm.tm_year = year - 1900;",
          "6855:    tm.tm_mon = month;",
          "6856:    tm.tm_mday = day;",
          "6857:    tm.tm_hour = hour;",
          "6858:    tm.tm_min = minute;",
          "6859:    tm.tm_sec = second;",
          "6860:    result = timegm(&tm);",
          "6861:   }",
          "6864:  return result;",
          "6865: }",
          "6871: static void",
          "6872: remove_double_dots_and_double_slashes(char *s)",
          "6873: {",
          "6874:  char *p = s;",
          "6876:  while ((s[0] == '.') && (s[1] == '.')) {",
          "6877:   s++;",
          "6878:  }",
          "6880:  while (*s != '\\0') {",
          "6882:   if ((s[-1] == '/') || (s[-1] == '\\\\')) {",
          "6884:    while (s[0] != '\\0') {",
          "6885:     if ((s[0] == '/') || (s[0] == '\\\\')) {",
          "6886:      s++;",
          "6887:     } else if ((s[0] == '.') && (s[1] == '.')) {",
          "6888:      s += 2;",
          "6889:     } else {",
          "6890:      break;",
          "6894:  }",
          "6896: }",
          "6899: static const struct {",
          "6900:  const char *extension;",
          "6901:  size_t ext_len;",
          "6902:  const char *mime_type;",
          "6903: } builtin_mime_types[] = {",
          "6907:     {\".doc\", 4, \"application/msword\"},",
          "6908:     {\".eps\", 4, \"application/postscript\"},",
          "6909:     {\".exe\", 4, \"application/octet-stream\"},",
          "6910:     {\".js\", 3, \"application/javascript\"},",
          "6911:     {\".json\", 5, \"application/json\"},",
          "6912:     {\".pdf\", 4, \"application/pdf\"},",
          "6913:     {\".ps\", 3, \"application/postscript\"},",
          "6914:     {\".rtf\", 4, \"application/rtf\"},",
          "6915:     {\".xhtml\", 6, \"application/xhtml+xml\"},",
          "6916:     {\".xsl\", 4, \"application/xml\"},",
          "6917:     {\".xslt\", 5, \"application/xml\"},",
          "6920:     {\".ttf\", 4, \"application/font-sfnt\"},",
          "6921:     {\".cff\", 4, \"application/font-sfnt\"},",
          "6922:     {\".otf\", 4, \"application/font-sfnt\"},",
          "6923:     {\".aat\", 4, \"application/font-sfnt\"},",
          "6924:     {\".sil\", 4, \"application/font-sfnt\"},",
          "6925:     {\".pfr\", 4, \"application/font-tdpfr\"},",
          "6926:     {\".woff\", 5, \"application/font-woff\"},",
          "6929:     {\".mp3\", 4, \"audio/mpeg\"},",
          "6930:     {\".oga\", 4, \"audio/ogg\"},",
          "6931:     {\".ogg\", 4, \"audio/ogg\"},",
          "6934:     {\".gif\", 4, \"image/gif\"},",
          "6935:     {\".ief\", 4, \"image/ief\"},",
          "6936:     {\".jpeg\", 5, \"image/jpeg\"},",
          "6937:     {\".jpg\", 4, \"image/jpeg\"},",
          "6938:     {\".jpm\", 4, \"image/jpm\"},",
          "6939:     {\".jpx\", 4, \"image/jpx\"},",
          "6940:     {\".png\", 4, \"image/png\"},",
          "6941:     {\".svg\", 4, \"image/svg+xml\"},",
          "6942:     {\".tif\", 4, \"image/tiff\"},",
          "6943:     {\".tiff\", 5, \"image/tiff\"},",
          "6946:     {\".wrl\", 4, \"model/vrml\"},",
          "6949:     {\".css\", 4, \"text/css\"},",
          "6950:     {\".csv\", 4, \"text/csv\"},",
          "6951:     {\".htm\", 4, \"text/html\"},",
          "6952:     {\".html\", 5, \"text/html\"},",
          "6953:     {\".sgm\", 4, \"text/sgml\"},",
          "6954:     {\".shtm\", 5, \"text/html\"},",
          "6955:     {\".shtml\", 6, \"text/html\"},",
          "6956:     {\".txt\", 4, \"text/plain\"},",
          "6957:     {\".xml\", 4, \"text/xml\"},",
          "6960:     {\".mov\", 4, \"video/quicktime\"},",
          "6961:     {\".mp4\", 4, \"video/mp4\"},",
          "6962:     {\".mpeg\", 5, \"video/mpeg\"},",
          "6963:     {\".mpg\", 4, \"video/mpeg\"},",
          "6964:     {\".ogv\", 4, \"video/ogg\"},",
          "6965:     {\".qt\", 3, \"video/quicktime\"},",
          "6970:     {\".arj\", 4, \"application/x-arj-compressed\"},",
          "6971:     {\".gz\", 3, \"application/x-gunzip\"},",
          "6972:     {\".rar\", 4, \"application/x-arj-compressed\"},",
          "6973:     {\".swf\", 4, \"application/x-shockwave-flash\"},",
          "6974:     {\".tar\", 4, \"application/x-tar\"},",
          "6975:     {\".tgz\", 4, \"application/x-tar-gz\"},",
          "6976:     {\".torrent\", 8, \"application/x-bittorrent\"},",
          "6977:     {\".ppt\", 4, \"application/x-mspowerpoint\"},",
          "6978:     {\".xls\", 4, \"application/x-msexcel\"},",
          "6979:     {\".zip\", 4, \"application/x-zip-compressed\"},",
          "6980:     {\".aac\",",
          "6981:      4,",
          "6983:     {\".aif\", 4, \"audio/x-aif\"},",
          "6984:     {\".m3u\", 4, \"audio/x-mpegurl\"},",
          "6985:     {\".mid\", 4, \"audio/x-midi\"},",
          "6986:     {\".ra\", 3, \"audio/x-pn-realaudio\"},",
          "6987:     {\".ram\", 4, \"audio/x-pn-realaudio\"},",
          "6988:     {\".wav\", 4, \"audio/x-wav\"},",
          "6989:     {\".bmp\", 4, \"image/bmp\"},",
          "6990:     {\".ico\", 4, \"image/x-icon\"},",
          "6991:     {\".pct\", 4, \"image/x-pct\"},",
          "6992:     {\".pict\", 5, \"image/pict\"},",
          "6993:     {\".rgb\", 4, \"image/x-rgb\"},",
          "6995:     {\".asf\", 4, \"video/x-ms-asf\"},",
          "6996:     {\".avi\", 4, \"video/x-msvideo\"},",
          "6997:     {\".m4v\", 4, \"video/x-m4v\"},",
          "6998:     {NULL, 0, NULL}};",
          "7001: const char *",
          "7002: mg_get_builtin_mime_type(const char *path)",
          "7003: {",
          "7004:  const char *ext;",
          "7005:  size_t i, path_len;",
          "7007:  path_len = strlen(path);",
          "7009:  for (i = 0; builtin_mime_types[i].extension != NULL; i++) {",
          "7010:   ext = path + (path_len - builtin_mime_types[i].ext_len);",
          "7011:   if ((path_len > builtin_mime_types[i].ext_len)",
          "7012:       && (mg_strcasecmp(ext, builtin_mime_types[i].extension) == 0)) {",
          "7013:    return builtin_mime_types[i].mime_type;",
          "7014:   }",
          "7017:  return \"text/plain\";",
          "7018: }",
          "7023: static void",
          "7024: get_mime_type(struct mg_context *ctx, const char *path, struct vec *vec)",
          "7025: {",
          "7026:  struct vec ext_vec, mime_vec;",
          "7027:  const char *list, *ext;",
          "7028:  size_t path_len;",
          "7030:  path_len = strlen(path);",
          "7032:  if ((ctx == NULL) || (vec == NULL)) {",
          "7033:   if (vec != NULL) {",
          "7034:    memset(vec, '\\0', sizeof(struct vec));",
          "7036:   return;",
          "7037:  }",
          "7041:  list = ctx->config[EXTRA_MIME_TYPES];",
          "7042:  while ((list = next_option(list, &ext_vec, &mime_vec)) != NULL) {",
          "7044:   ext = path + path_len - ext_vec.len;",
          "7045:   if (mg_strncasecmp(ext, ext_vec.ptr, ext_vec.len) == 0) {",
          "7047:    return;",
          "7048:   }",
          "7051:  vec->ptr = mg_get_builtin_mime_type(path);",
          "7052:  vec->len = strlen(vec->ptr);",
          "7053: }",
          "7058: static void",
          "7059: bin2str(char *to, const unsigned char *p, size_t len)",
          "7060: {",
          "7061:  static const char *hex = \"0123456789abcdef\";",
          "7063:  for (; len--; p++) {",
          "7066:  }",
          "7068: }",
          "7073: char *",
          "7074: mg_md5(char buf[33], ...)",
          "7075: {",
          "7076:  md5_byte_t hash[16];",
          "7077:  const char *p;",
          "7078:  va_list ap;",
          "7079:  md5_state_t ctx;",
          "7081:  md5_init(&ctx);",
          "7083:  va_start(ap, buf);",
          "7084:  while ((p = va_arg(ap, const char *)) != NULL) {",
          "7085:   md5_append(&ctx, (const md5_byte_t *)p, strlen(p));",
          "7087:  va_end(ap);",
          "7089:  md5_finish(&ctx, hash);",
          "7090:  bin2str(buf, hash, sizeof(hash));",
          "7091:  return buf;",
          "7092: }",
          "7096: static int",
          "7097: check_password(const char *method,",
          "7098:                const char *ha1,",
          "7099:                const char *uri,",
          "7100:                const char *nonce,",
          "7101:                const char *nc,",
          "7102:                const char *cnonce,",
          "7103:                const char *qop,",
          "7104:                const char *response)",
          "7105: {",
          "7106:  char ha2[32 + 1], expected_response[32 + 1];",
          "7109:  if ((method == NULL) || (nonce == NULL) || (nc == NULL) || (cnonce == NULL)",
          "7110:      || (qop == NULL) || (response == NULL)) {",
          "7111:   return 0;",
          "7112:  }",
          "7115:  if (strlen(response) != 32) {",
          "7116:   return 0;",
          "7119:  mg_md5(ha2, method, \":\", uri, NULL);",
          "7120:  mg_md5(expected_response,",
          "7121:         ha1,",
          "7122:         \":\",",
          "7123:         nonce,",
          "7124:         \":\",",
          "7125:         nc,",
          "7126:         \":\",",
          "7127:         cnonce,",
          "7128:         \":\",",
          "7129:         qop,",
          "7130:         \":\",",
          "7131:         ha2,",
          "7132:         NULL);",
          "7134:  return mg_strcasecmp(response, expected_response) == 0;",
          "7135: }",
          "7140: static void",
          "7141: open_auth_file(struct mg_connection *conn,",
          "7142:                const char *path,",
          "7143:                struct mg_file *filep)",
          "7144: {",
          "7145:  if ((conn != NULL) && (conn->ctx != NULL)) {",
          "7146:   char name[PATH_MAX];",
          "7147:   const char *p, *e, *gpass = conn->ctx->config[GLOBAL_PASSWORDS_FILE];",
          "7148:   int truncated;",
          "7150:   if (gpass != NULL) {",
          "7152:    if (!mg_fopen(conn, gpass, MG_FOPEN_MODE_READ, filep)) {",
          "7155:     mg_cry(conn, \"fopen(%s): %s\", gpass, strerror(ERRNO));",
          "7157:    }",
          "7163:   } else if (mg_stat(conn, path, &filep->stat)",
          "7164:              && filep->stat.is_directory) {",
          "7165:    mg_snprintf(conn,",
          "7166:                &truncated,",
          "7167:                name,",
          "7168:                sizeof(name),",
          "7169:                \"%s/%s\",",
          "7170:                path,",
          "7171:                PASSWORDS_FILE_NAME);",
          "7173:    if (truncated || !mg_fopen(conn, name, MG_FOPEN_MODE_READ, filep)) {",
          "7178:     DEBUG_TRACE(\"fopen(%s): %s\", name, strerror(ERRNO));",
          "7180:    }",
          "7181:   } else {",
          "7183:    for (p = path, e = p + strlen(p) - 1; e > p; e--) {",
          "7184:     if (e[0] == '/') {",
          "7185:      break;",
          "7187:    }",
          "7188:    mg_snprintf(conn,",
          "7189:                &truncated,",
          "7190:                name,",
          "7191:                sizeof(name),",
          "7192:                \"%.*s/%s\",",
          "7193:                (int)(e - p),",
          "7194:                p,",
          "7195:                PASSWORDS_FILE_NAME);",
          "7197:    if (truncated || !mg_fopen(conn, name, MG_FOPEN_MODE_READ, filep)) {",
          "7202:     DEBUG_TRACE(\"fopen(%s): %s\", name, strerror(ERRNO));",
          "7207: }",
          "7211: struct ah {",
          "7212:  char *user, *uri, *cnonce, *response, *qop, *nc, *nonce;",
          "7213: };",
          "7217: static int",
          "7218: parse_auth_header(struct mg_connection *conn,",
          "7219:                   char *buf,",
          "7220:                   size_t buf_size,",
          "7221:                   struct ah *ah)",
          "7222: {",
          "7223:  char *name, *value, *s;",
          "7224:  const char *auth_header;",
          "7225:  uint64_t nonce;",
          "7227:  if (!ah || !conn) {",
          "7228:   return 0;",
          "7229:  }",
          "7231:  (void)memset(ah, 0, sizeof(*ah));",
          "7232:  if (((auth_header = mg_get_header(conn, \"Authorization\")) == NULL)",
          "7233:      || mg_strncasecmp(auth_header, \"Digest \", 7) != 0) {",
          "7234:   return 0;",
          "7235:  }",
          "7238:  (void)mg_strlcpy(buf, auth_header + 7, buf_size);",
          "7239:  s = buf;",
          "7242:  for (;;) {",
          "7244:   while (isspace(*(unsigned char *)s)) {",
          "7245:    s++;",
          "7246:   }",
          "7247:   name = skip_quoted(&s, \"=\", \" \", 0);",
          "7250:   if (s[0] == '\\\"') {",
          "7251:    s++;",
          "7252:    value = skip_quoted(&s, \"\\\"\", \" \", '\\\\');",
          "7253:    if (s[0] == ',') {",
          "7256:   } else {",
          "7257:    value = skip_quoted(&s, \", \", \" \", 0); /* IE uses commas, FF uses",
          "7260:   if (*name == '\\0') {",
          "7261:    break;",
          "7264:   if (!strcmp(name, \"username\")) {",
          "7265:    ah->user = value;",
          "7266:   } else if (!strcmp(name, \"cnonce\")) {",
          "7267:    ah->cnonce = value;",
          "7268:   } else if (!strcmp(name, \"response\")) {",
          "7269:    ah->response = value;",
          "7270:   } else if (!strcmp(name, \"uri\")) {",
          "7271:    ah->uri = value;",
          "7272:   } else if (!strcmp(name, \"qop\")) {",
          "7273:    ah->qop = value;",
          "7274:   } else if (!strcmp(name, \"nc\")) {",
          "7275:    ah->nc = value;",
          "7276:   } else if (!strcmp(name, \"nonce\")) {",
          "7277:    ah->nonce = value;",
          "7279:  }",
          "7281: #ifndef NO_NONCE_CHECK",
          "7283:  if (ah->nonce == NULL) {",
          "7284:   return 0;",
          "7285:  }",
          "7286:  s = NULL;",
          "7287:  nonce = strtoull(ah->nonce, &s, 10);",
          "7288:  if ((s == NULL) || (*s != 0)) {",
          "7289:   return 0;",
          "7290:  }",
          "7293:  nonce ^= conn->ctx->auth_nonce_mask;",
          "7303:  if (nonce < (uint64_t)conn->ctx->start_time) {",
          "7306:   return 0;",
          "7307:  }",
          "7310:  if (nonce >= ((uint64_t)conn->ctx->start_time + conn->ctx->nonce_count)) {",
          "7311:   return 0;",
          "7312:  }",
          "7318:  if (ah->user != NULL) {",
          "7319:   conn->request_info.remote_user = mg_strdup(ah->user);",
          "7320:  } else {",
          "7321:   return 0;",
          "7324:  return 1;",
          "7325: }",
          "7328: static const char *",
          "7329: mg_fgets(char *buf, size_t size, struct mg_file *filep, char **p)",
          "7330: {",
          "7331:  const char *eof;",
          "7332:  size_t len;",
          "7333:  const char *memend;",
          "7335:  if (!filep) {",
          "7336:   return NULL;",
          "7337:  }",
          "7339:  if ((filep->access.membuf != NULL) && (*p != NULL)) {",
          "7340:   memend = (const char *)&filep->access.membuf[filep->stat.size];",
          "7342:   eof = (char *)memchr(*p, '\\n', (size_t)(memend - *p));",
          "7343:   if (eof != NULL) {",
          "7347:   }",
          "7348:   len =",
          "7349:       ((size_t)(eof - *p) > (size - 1)) ? (size - 1) : (size_t)(eof - *p);",
          "7350:   memcpy(buf, *p, len);",
          "7351:   buf[len] = '\\0';",
          "7353:   return len ? eof : NULL;",
          "7354:  } else if (filep->access.fp != NULL) {",
          "7355:   return fgets(buf, (int)size, filep->access.fp);",
          "7356:  } else {",
          "7357:   return NULL;",
          "7359: }",
          "",
          "---------------",
          "--- Hunk 42 ---",
          "[Context before]",
          "7313: #error Bad INITIAL_DEPTH for recursion, set to at least 1",
          "7314: #endif",
          "7388:      }",
          "7390:     }",
          "7397:     continue;",
          "7398:    }",
          "7434:   }",
          "7437:  }",
          "7459:  }",
          "7503:   }",
          "7511:  }",
          "7547:  }",
          "7550: #if !defined(NO_FILES)",
          "7566:   }",
          "7568:  }",
          "7569: #endif",
          "7612:    return 0;",
          "7613:   }",
          "7620:    return 0;",
          "7621:   }",
          "7644:   }",
          "7662:    }",
          "7663:   }",
          "7718:   }",
          "7722:  }",
          "7764: #if !defined(NO_SSL)",
          "7765: #if !defined(NO_SSL_DL)",
          "7766: #ifdef OPENSSL_API_1_1",
          "7776: #else",
          "7788: #else",
          "",
          "[Removed Lines]",
          "7316:  struct read_auth_file_struct {",
          "7317:   struct mg_connection *conn;",
          "7318:   struct ah ah;",
          "7319:   char *domain;",
          "7320:   char buf[256 + 256 + 40];",
          "7321:   char *f_user;",
          "7322:   char *f_domain;",
          "7323:   char *f_ha1;",
          "7324:  };",
          "7327:  static int read_auth_file(struct mg_file * filep,",
          "7328:                            struct read_auth_file_struct * workdata,",
          "7329:                            int depth)",
          "7330:  {",
          "7331:   char *p;",
          "7332:   int is_authorized = 0;",
          "7333:   struct mg_file fp;",
          "7334:   size_t l;",
          "7336:   if (!filep || !workdata || (0 == depth)) {",
          "7337:    return 0;",
          "7338:   }",
          "7341:   p = (char *)filep->access.membuf;",
          "7342:   while (mg_fgets(workdata->buf, sizeof(workdata->buf), filep, &p)",
          "7343:          != NULL) {",
          "7344:    l = strlen(workdata->buf);",
          "7345:    while (l > 0) {",
          "7346:     if (isspace(workdata->buf[l - 1])",
          "7347:         || iscntrl(workdata->buf[l - 1])) {",
          "7348:      l--;",
          "7349:      workdata->buf[l] = 0;",
          "7350:     } else",
          "7351:      break;",
          "7352:    }",
          "7353:    if (l < 1) {",
          "7354:     continue;",
          "7355:    }",
          "7357:    workdata->f_user = workdata->buf;",
          "7359:    if (workdata->f_user[0] == ':') {",
          "7363:     if (workdata->f_user[1] == '#') {",
          "7365:      continue;",
          "7366:     } else if (!strncmp(workdata->f_user + 1, \"include=\", 8)) {",
          "7367:      if (mg_fopen(workdata->conn,",
          "7368:                   workdata->f_user + 9,",
          "7369:                   MG_FOPEN_MODE_READ,",
          "7370:                   &fp)) {",
          "7371:       is_authorized =",
          "7372:           read_auth_file(&fp, workdata, depth - 1);",
          "7373:       (void)mg_fclose(",
          "7380:       if (is_authorized) {",
          "7381:        return is_authorized;",
          "7382:       }",
          "7383:      } else {",
          "7384:       mg_cry(workdata->conn,",
          "7385:              \"%s: cannot open authorization file: %s\",",
          "7386:              __func__,",
          "7387:              workdata->buf);",
          "7389:      continue;",
          "7393:     mg_cry(workdata->conn,",
          "7394:            \"%s: syntax error in authorization file: %s\",",
          "7395:            __func__,",
          "7396:            workdata->buf);",
          "7400:    workdata->f_domain = strchr(workdata->f_user, ':');",
          "7401:    if (workdata->f_domain == NULL) {",
          "7402:     mg_cry(workdata->conn,",
          "7403:            \"%s: syntax error in authorization file: %s\",",
          "7404:            __func__,",
          "7405:            workdata->buf);",
          "7406:     continue;",
          "7407:    }",
          "7409:    (workdata->f_domain)++;",
          "7411:    workdata->f_ha1 = strchr(workdata->f_domain, ':');",
          "7412:    if (workdata->f_ha1 == NULL) {",
          "7413:     mg_cry(workdata->conn,",
          "7414:            \"%s: syntax error in authorization file: %s\",",
          "7415:            __func__,",
          "7416:            workdata->buf);",
          "7417:     continue;",
          "7418:    }",
          "7420:    (workdata->f_ha1)++;",
          "7422:    if (!strcmp(workdata->ah.user, workdata->f_user)",
          "7423:        && !strcmp(workdata->domain, workdata->f_domain)) {",
          "7424:     return check_password(",
          "7425:         workdata->conn->request_info.request_method,",
          "7426:         workdata->f_ha1,",
          "7427:         workdata->ah.uri,",
          "7428:         workdata->ah.nonce,",
          "7429:         workdata->ah.nc,",
          "7430:         workdata->ah.cnonce,",
          "7431:         workdata->ah.qop,",
          "7432:         workdata->ah.response);",
          "7433:    }",
          "7436:   return is_authorized;",
          "7441:  static int authorize(struct mg_connection * conn, struct mg_file * filep)",
          "7442:  {",
          "7443:   struct read_auth_file_struct workdata;",
          "7444:   char buf[MG_BUF_LEN];",
          "7446:   if (!conn || !conn->ctx) {",
          "7447:    return 0;",
          "7448:   }",
          "7450:   memset(&workdata, 0, sizeof(workdata));",
          "7451:   workdata.conn = conn;",
          "7453:   if (!parse_auth_header(conn, buf, sizeof(buf), &workdata.ah)) {",
          "7454:    return 0;",
          "7455:   }",
          "7456:   workdata.domain = conn->ctx->config[AUTHENTICATION_DOMAIN];",
          "7458:   return read_auth_file(filep, &workdata, INITIAL_DEPTH);",
          "7463:  static int check_authorization(struct mg_connection * conn,",
          "7464:                                 const char *path)",
          "7465:  {",
          "7466:   char fname[PATH_MAX];",
          "7467:   struct vec uri_vec, filename_vec;",
          "7468:   const char *list;",
          "7469:   struct mg_file file = STRUCT_FILE_INITIALIZER;",
          "7470:   int authorized = 1, truncated;",
          "7472:   if (!conn || !conn->ctx) {",
          "7473:    return 0;",
          "7474:   }",
          "7476:   list = conn->ctx->config[PROTECT_URI];",
          "7477:   while ((list = next_option(list, &uri_vec, &filename_vec)) != NULL) {",
          "7478:    if (!memcmp(conn->request_info.local_uri,",
          "7479:                uri_vec.ptr,",
          "7480:                uri_vec.len)) {",
          "7481:     mg_snprintf(conn,",
          "7482:                 &truncated,",
          "7483:                 fname,",
          "7484:                 sizeof(fname),",
          "7485:                 \"%.*s\",",
          "7486:                 (int)filename_vec.len,",
          "7487:                 filename_vec.ptr);",
          "7489:     if (truncated",
          "7490:         || !mg_fopen(conn, fname, MG_FOPEN_MODE_READ, &file)) {",
          "7491:      mg_cry(conn,",
          "7492:             \"%s: cannot open %s: %s\",",
          "7493:             __func__,",
          "7494:             fname,",
          "7495:             strerror(errno));",
          "7496:     }",
          "7497:     break;",
          "7498:    }",
          "7499:   }",
          "7501:   if (!is_file_opened(&file.access)) {",
          "7502:    open_auth_file(conn, path, &file);",
          "7505:   if (is_file_opened(&file.access)) {",
          "7506:    authorized = authorize(conn, &file);",
          "7508:   }",
          "7510:   return authorized;",
          "7514:  static void send_authorization_request(struct mg_connection * conn)",
          "7515:  {",
          "7516:   char date[64];",
          "7517:   time_t curtime = time(NULL);",
          "7519:   if (conn && conn->ctx) {",
          "7520:    uint64_t nonce = (uint64_t)(conn->ctx->start_time);",
          "7522:    (void)pthread_mutex_lock(&conn->ctx->nonce_mutex);",
          "7523:    nonce += conn->ctx->nonce_count;",
          "7524:    ++conn->ctx->nonce_count;",
          "7525:    (void)pthread_mutex_unlock(&conn->ctx->nonce_mutex);",
          "7527:    nonce ^= conn->ctx->auth_nonce_mask;",
          "7528:    conn->status_code = 401;",
          "7529:    conn->must_close = 1;",
          "7531:    gmt_time_string(date, sizeof(date), &curtime);",
          "7533:    mg_printf(conn, \"HTTP/1.1 401 Unauthorized\\r\\n\");",
          "7534:    send_no_cache_header(conn);",
          "7535:    send_additional_header(conn);",
          "7536:    mg_printf(conn,",
          "7537:              \"Date: %s\\r\\n\"",
          "7538:              \"Connection: %s\\r\\n\"",
          "7539:              \"Content-Length: 0\\r\\n\"",
          "7540:              \"WWW-Authenticate: Digest qop=\\\"auth\\\", realm=\\\"%s\\\", \"",
          "7541:              \"nonce=\\\"%\" UINT64_FMT \"\\\"\\r\\n\\r\\n\",",
          "7542:              date,",
          "7543:              suggest_connection_header(conn),",
          "7544:              conn->ctx->config[AUTHENTICATION_DOMAIN],",
          "7545:              nonce);",
          "7546:   }",
          "7551:  static int is_authorized_for_put(struct mg_connection * conn)",
          "7552:  {",
          "7553:   if (conn) {",
          "7554:    struct mg_file file = STRUCT_FILE_INITIALIZER;",
          "7555:    const char *passfile = conn->ctx->config[PUT_DELETE_PASSWORDS_FILE];",
          "7556:    int ret = 0;",
          "7558:    if (passfile != NULL",
          "7559:        && mg_fopen(conn, passfile, MG_FOPEN_MODE_READ, &file)) {",
          "7560:     ret = authorize(conn, &file);",
          "7561:     (void)mg_fclose(",
          "7563:    }",
          "7565:    return ret;",
          "7567:   return 0;",
          "7572:  int mg_modify_passwords_file(const char *fname,",
          "7573:                               const char *domain,",
          "7574:                               const char *user,",
          "7575:                               const char *pass)",
          "7576:  {",
          "7577:   int found, i;",
          "7578:   char line[512], u[512] = \"\", d[512] = \"\", ha1[33], tmp[PATH_MAX + 8];",
          "7579:   FILE *fp, *fp2;",
          "7581:   found = 0;",
          "7582:   fp = fp2 = NULL;",
          "7585:   if ((pass != NULL) && (pass[0] == '\\0')) {",
          "7586:    pass = NULL;",
          "7587:   }",
          "7590:   if ((fname == NULL) || (domain == NULL) || (user == NULL)) {",
          "7591:    return 0;",
          "7592:   }",
          "7597:   if (strchr(user, ':') != NULL) {",
          "7598:    return 0;",
          "7599:   }",
          "7600:   if (strchr(domain, ':') != NULL) {",
          "7601:    return 0;",
          "7602:   }",
          "7606:   for (i = 0; ((i < 255) && (user[i] != 0)); i++) {",
          "7607:    if (iscntrl(user[i])) {",
          "7608:     return 0;",
          "7609:    }",
          "7610:   }",
          "7611:   if (user[i]) {",
          "7614:   for (i = 0; ((i < 255) && (domain[i] != 0)); i++) {",
          "7615:    if (iscntrl(domain[i])) {",
          "7616:     return 0;",
          "7617:    }",
          "7618:   }",
          "7619:   if (domain[i]) {",
          "7624:   if ((strlen(fname) + 4) >= PATH_MAX) {",
          "7625:    return 0;",
          "7626:   }",
          "7629:   strcpy(tmp, fname);",
          "7630:   strcat(tmp, \".tmp\");",
          "7634:   if ((fp = fopen(fname, \"a+\")) != NULL) {",
          "7635:    (void)fclose(fp);",
          "7636:   }",
          "7639:   if ((fp = fopen(fname, \"r\")) == NULL) {",
          "7640:    return 0;",
          "7641:   } else if ((fp2 = fopen(tmp, \"w+\")) == NULL) {",
          "7642:    fclose(fp);",
          "7643:    return 0;",
          "7647:   while (fgets(line, sizeof(line), fp) != NULL) {",
          "7648:    if (sscanf(line, \"%255[^:]:%255[^:]:%*s\", u, d) != 2) {",
          "7649:     continue;",
          "7650:    }",
          "7651:    u[255] = 0;",
          "7652:    d[255] = 0;",
          "7654:    if (!strcmp(u, user) && !strcmp(d, domain)) {",
          "7655:     found++;",
          "7656:     if (pass != NULL) {",
          "7657:      mg_md5(ha1, user, \":\", domain, \":\", pass, NULL);",
          "7658:      fprintf(fp2, \"%s:%s:%s\\n\", user, domain, ha1);",
          "7659:     }",
          "7660:    } else {",
          "7661:     fprintf(fp2, \"%s\", line);",
          "7666:   if (!found && (pass != NULL)) {",
          "7667:    mg_md5(ha1, user, \":\", domain, \":\", pass, NULL);",
          "7668:    fprintf(fp2, \"%s:%s:%s\\n\", user, domain, ha1);",
          "7669:   }",
          "7672:   fclose(fp);",
          "7673:   fclose(fp2);",
          "7676:   IGNORE_UNUSED_RESULT(remove(fname));",
          "7677:   IGNORE_UNUSED_RESULT(rename(tmp, fname));",
          "7679:   return 1;",
          "7680:  }",
          "7683:  static int is_valid_port(unsigned long port)",
          "7684:  {",
          "7685:   return (port <= 0xffff);",
          "7686:  }",
          "7689:  static int mg_inet_pton(int af, const char *src, void *dst, size_t dstlen)",
          "7690:  {",
          "7691:   struct addrinfo hints, *res, *ressave;",
          "7692:   int func_ret = 0;",
          "7693:   int gai_ret;",
          "7695:   memset(&hints, 0, sizeof(struct addrinfo));",
          "7696:   hints.ai_family = af;",
          "7698:   gai_ret = getaddrinfo(src, NULL, &hints, &res);",
          "7699:   if (gai_ret != 0) {",
          "7707:    return 0;",
          "7708:   }",
          "7710:   ressave = res;",
          "7712:   while (res) {",
          "7713:    if (dstlen >= (size_t)res->ai_addrlen) {",
          "7714:     memcpy(dst, res->ai_addr, res->ai_addrlen);",
          "7715:     func_ret = 1;",
          "7716:    }",
          "7717:    res = res->ai_next;",
          "7720:   freeaddrinfo(ressave);",
          "7721:   return func_ret;",
          "7725:  static int connect_socket(",
          "7726:      struct mg_context * ctx /* may be NULL */,",
          "7727:      const char *host,",
          "7728:      int port,",
          "7729:      int use_ssl,",
          "7730:      char *ebuf,",
          "7731:      size_t ebuf_len,",
          "7732:      SOCKET *sock /* output: socket, must not be NULL */,",
          "7734:      )",
          "7735:  {",
          "7736:   int ip_ver = 0;",
          "7738:   memset(sa, 0, sizeof(*sa));",
          "7740:   if (ebuf_len > 0) {",
          "7742:   }",
          "7744:   if (host == NULL) {",
          "7745:    mg_snprintf(NULL,",
          "7747:                ebuf,",
          "7748:                ebuf_len,",
          "7749:                \"%s\",",
          "7750:                \"NULL host\");",
          "7751:    return 0;",
          "7752:   }",
          "7754:   if ((port <= 0) || !is_valid_port((unsigned)port)) {",
          "7755:    mg_snprintf(NULL,",
          "7757:                ebuf,",
          "7758:                ebuf_len,",
          "7759:                \"%s\",",
          "7760:                \"invalid port\");",
          "7761:    return 0;",
          "7762:   }",
          "7767:   if (use_ssl && (TLS_client_method == NULL)) {",
          "7768:    mg_snprintf(NULL,",
          "7770:                ebuf,",
          "7771:                ebuf_len,",
          "7772:                \"%s\",",
          "7773:                \"SSL is not initialized\");",
          "7774:    return 0;",
          "7775:   }",
          "7777:   if (use_ssl && (SSLv23_client_method == NULL)) {",
          "7778:    mg_snprintf(NULL,",
          "7780:                ebuf,",
          "7781:                ebuf_len,",
          "7782:                \"%s\",",
          "7783:                \"SSL is not initialized\");",
          "7784:    return 0;",
          "7785:   }",
          "",
          "[Added Lines]",
          "7372: struct read_auth_file_struct {",
          "7373:  struct mg_connection *conn;",
          "7374:  struct ah ah;",
          "7375:  char *domain;",
          "7376:  char buf[256 + 256 + 40];",
          "7377:  char *f_user;",
          "7378:  char *f_domain;",
          "7379:  char *f_ha1;",
          "7380: };",
          "7383: static int",
          "7384: read_auth_file(struct mg_file *filep,",
          "7385:                struct read_auth_file_struct *workdata,",
          "7386:                int depth)",
          "7387: {",
          "7388:  char *p;",
          "7389:  int is_authorized = 0;",
          "7390:  struct mg_file fp;",
          "7391:  size_t l;",
          "7393:  if (!filep || !workdata || (0 == depth)) {",
          "7394:   return 0;",
          "7395:  }",
          "7398:  p = (char *)filep->access.membuf;",
          "7399:  while (mg_fgets(workdata->buf, sizeof(workdata->buf), filep, &p) != NULL) {",
          "7400:   l = strlen(workdata->buf);",
          "7401:   while (l > 0) {",
          "7402:    if (isspace(workdata->buf[l - 1])",
          "7403:        || iscntrl(workdata->buf[l - 1])) {",
          "7404:     l--;",
          "7405:     workdata->buf[l] = 0;",
          "7406:    } else",
          "7407:     break;",
          "7408:   }",
          "7409:   if (l < 1) {",
          "7410:    continue;",
          "7411:   }",
          "7413:   workdata->f_user = workdata->buf;",
          "7415:   if (workdata->f_user[0] == ':') {",
          "7419:    if (workdata->f_user[1] == '#') {",
          "7421:     continue;",
          "7422:    } else if (!strncmp(workdata->f_user + 1, \"include=\", 8)) {",
          "7423:     if (mg_fopen(workdata->conn,",
          "7424:                  workdata->f_user + 9,",
          "7425:                  MG_FOPEN_MODE_READ,",
          "7426:                  &fp)) {",
          "7427:      is_authorized = read_auth_file(&fp, workdata, depth - 1);",
          "7428:      (void)mg_fclose(",
          "7435:      if (is_authorized) {",
          "7436:       return is_authorized;",
          "7438:     } else {",
          "7439:      mg_cry(workdata->conn,",
          "7440:             \"%s: cannot open authorization file: %s\",",
          "7441:             __func__,",
          "7442:             workdata->buf);",
          "7448:    mg_cry(workdata->conn,",
          "7449:           \"%s: syntax error in authorization file: %s\",",
          "7450:           __func__,",
          "7451:           workdata->buf);",
          "7452:    continue;",
          "7453:   }",
          "7455:   workdata->f_domain = strchr(workdata->f_user, ':');",
          "7456:   if (workdata->f_domain == NULL) {",
          "7457:    mg_cry(workdata->conn,",
          "7458:           \"%s: syntax error in authorization file: %s\",",
          "7459:           __func__,",
          "7460:           workdata->buf);",
          "7461:    continue;",
          "7462:   }",
          "7464:   (workdata->f_domain)++;",
          "7466:   workdata->f_ha1 = strchr(workdata->f_domain, ':');",
          "7467:   if (workdata->f_ha1 == NULL) {",
          "7468:    mg_cry(workdata->conn,",
          "7469:           \"%s: syntax error in authorization file: %s\",",
          "7470:           __func__,",
          "7471:           workdata->buf);",
          "7472:    continue;",
          "7475:   (workdata->f_ha1)++;",
          "7477:   if (!strcmp(workdata->ah.user, workdata->f_user)",
          "7478:       && !strcmp(workdata->domain, workdata->f_domain)) {",
          "7479:    return check_password(workdata->conn->request_info.request_method,",
          "7480:                          workdata->f_ha1,",
          "7481:                          workdata->ah.uri,",
          "7482:                          workdata->ah.nonce,",
          "7483:                          workdata->ah.nc,",
          "7484:                          workdata->ah.cnonce,",
          "7485:                          workdata->ah.qop,",
          "7486:                          workdata->ah.response);",
          "7487:   }",
          "7490:  return is_authorized;",
          "7491: }",
          "7495: static int",
          "7496: authorize(struct mg_connection *conn, struct mg_file *filep)",
          "7497: {",
          "7498:  struct read_auth_file_struct workdata;",
          "7499:  char buf[MG_BUF_LEN];",
          "7501:  if (!conn || !conn->ctx) {",
          "7502:   return 0;",
          "7503:  }",
          "7505:  memset(&workdata, 0, sizeof(workdata));",
          "7506:  workdata.conn = conn;",
          "7508:  if (!parse_auth_header(conn, buf, sizeof(buf), &workdata.ah)) {",
          "7509:   return 0;",
          "7511:  workdata.domain = conn->ctx->config[AUTHENTICATION_DOMAIN];",
          "7513:  return read_auth_file(filep, &workdata, INITIAL_DEPTH);",
          "7514: }",
          "7518: static int",
          "7519: check_authorization(struct mg_connection *conn, const char *path)",
          "7520: {",
          "7521:  char fname[PATH_MAX];",
          "7522:  struct vec uri_vec, filename_vec;",
          "7523:  const char *list;",
          "7524:  struct mg_file file = STRUCT_FILE_INITIALIZER;",
          "7525:  int authorized = 1, truncated;",
          "7527:  if (!conn || !conn->ctx) {",
          "7528:   return 0;",
          "7529:  }",
          "7531:  list = conn->ctx->config[PROTECT_URI];",
          "7532:  while ((list = next_option(list, &uri_vec, &filename_vec)) != NULL) {",
          "7533:   if (!memcmp(conn->request_info.local_uri, uri_vec.ptr, uri_vec.len)) {",
          "7534:    mg_snprintf(conn,",
          "7535:                &truncated,",
          "7536:                fname,",
          "7537:                sizeof(fname),",
          "7538:                \"%.*s\",",
          "7539:                (int)filename_vec.len,",
          "7540:                filename_vec.ptr);",
          "7542:    if (truncated",
          "7543:        || !mg_fopen(conn, fname, MG_FOPEN_MODE_READ, &file)) {",
          "7544:     mg_cry(conn,",
          "7545:            \"%s: cannot open %s: %s\",",
          "7546:            __func__,",
          "7547:            fname,",
          "7548:            strerror(errno));",
          "7549:    }",
          "7550:    break;",
          "7552:  }",
          "7554:  if (!is_file_opened(&file.access)) {",
          "7555:   open_auth_file(conn, path, &file);",
          "7556:  }",
          "7558:  if (is_file_opened(&file.access)) {",
          "7559:   authorized = authorize(conn, &file);",
          "7563:  return authorized;",
          "7564: }",
          "7567: static void",
          "7568: send_authorization_request(struct mg_connection *conn)",
          "7569: {",
          "7570:  char date[64];",
          "7571:  time_t curtime = time(NULL);",
          "7573:  if (conn && conn->ctx) {",
          "7574:   uint64_t nonce = (uint64_t)(conn->ctx->start_time);",
          "7576:   (void)pthread_mutex_lock(&conn->ctx->nonce_mutex);",
          "7577:   nonce += conn->ctx->nonce_count;",
          "7578:   ++conn->ctx->nonce_count;",
          "7579:   (void)pthread_mutex_unlock(&conn->ctx->nonce_mutex);",
          "7581:   nonce ^= conn->ctx->auth_nonce_mask;",
          "7582:   conn->status_code = 401;",
          "7583:   conn->must_close = 1;",
          "7585:   gmt_time_string(date, sizeof(date), &curtime);",
          "7587:   mg_printf(conn, \"HTTP/1.1 401 Unauthorized\\r\\n\");",
          "7588:   send_no_cache_header(conn);",
          "7589:   send_additional_header(conn);",
          "7590:   mg_printf(conn,",
          "7591:             \"Date: %s\\r\\n\"",
          "7592:             \"Connection: %s\\r\\n\"",
          "7593:             \"Content-Length: 0\\r\\n\"",
          "7594:             \"WWW-Authenticate: Digest qop=\\\"auth\\\", realm=\\\"%s\\\", \"",
          "7595:             \"nonce=\\\"%\" UINT64_FMT \"\\\"\\r\\n\\r\\n\",",
          "7596:             date,",
          "7597:             suggest_connection_header(conn),",
          "7598:             conn->ctx->config[AUTHENTICATION_DOMAIN],",
          "7599:             nonce);",
          "7601: }",
          "7605: static int",
          "7606: is_authorized_for_put(struct mg_connection *conn)",
          "7607: {",
          "7608:  if (conn) {",
          "7609:   struct mg_file file = STRUCT_FILE_INITIALIZER;",
          "7610:   const char *passfile = conn->ctx->config[PUT_DELETE_PASSWORDS_FILE];",
          "7611:   int ret = 0;",
          "7613:   if (passfile != NULL",
          "7614:       && mg_fopen(conn, passfile, MG_FOPEN_MODE_READ, &file)) {",
          "7615:    ret = authorize(conn, &file);",
          "7619:   return ret;",
          "7621:  return 0;",
          "7622: }",
          "7626: int",
          "7627: mg_modify_passwords_file(const char *fname,",
          "7628:                          const char *domain,",
          "7629:                          const char *user,",
          "7630:                          const char *pass)",
          "7631: {",
          "7632:  int found, i;",
          "7633:  char line[512], u[512] = \"\", d[512] = \"\", ha1[33], tmp[PATH_MAX + 8];",
          "7634:  FILE *fp, *fp2;",
          "7636:  found = 0;",
          "7637:  fp = fp2 = NULL;",
          "7640:  if ((pass != NULL) && (pass[0] == '\\0')) {",
          "7641:   pass = NULL;",
          "7642:  }",
          "7645:  if ((fname == NULL) || (domain == NULL) || (user == NULL)) {",
          "7646:   return 0;",
          "7647:  }",
          "7652:  if (strchr(user, ':') != NULL) {",
          "7653:   return 0;",
          "7654:  }",
          "7655:  if (strchr(domain, ':') != NULL) {",
          "7656:   return 0;",
          "7657:  }",
          "7661:  for (i = 0; ((i < 255) && (user[i] != 0)); i++) {",
          "7662:   if (iscntrl(user[i])) {",
          "7665:  }",
          "7666:  if (user[i]) {",
          "7667:   return 0;",
          "7668:  }",
          "7669:  for (i = 0; ((i < 255) && (domain[i] != 0)); i++) {",
          "7670:   if (iscntrl(domain[i])) {",
          "7673:  }",
          "7674:  if (domain[i]) {",
          "7675:   return 0;",
          "7676:  }",
          "7679:  if ((strlen(fname) + 4) >= PATH_MAX) {",
          "7680:   return 0;",
          "7681:  }",
          "7684:  strcpy(tmp, fname);",
          "7685:  strcat(tmp, \".tmp\");",
          "7689:  if ((fp = fopen(fname, \"a+\")) != NULL) {",
          "7690:   (void)fclose(fp);",
          "7691:  }",
          "7694:  if ((fp = fopen(fname, \"r\")) == NULL) {",
          "7695:   return 0;",
          "7696:  } else if ((fp2 = fopen(tmp, \"w+\")) == NULL) {",
          "7697:   fclose(fp);",
          "7698:   return 0;",
          "7699:  }",
          "7702:  while (fgets(line, sizeof(line), fp) != NULL) {",
          "7703:   if (sscanf(line, \"%255[^:]:%255[^:]:%*s\", u, d) != 2) {",
          "7704:    continue;",
          "7706:   u[255] = 0;",
          "7707:   d[255] = 0;",
          "7709:   if (!strcmp(u, user) && !strcmp(d, domain)) {",
          "7710:    found++;",
          "7711:    if (pass != NULL) {",
          "7712:     mg_md5(ha1, user, \":\", domain, \":\", pass, NULL);",
          "7713:     fprintf(fp2, \"%s:%s:%s\\n\", user, domain, ha1);",
          "7715:   } else {",
          "7716:    fprintf(fp2, \"%s\", line);",
          "7718:  }",
          "7721:  if (!found && (pass != NULL)) {",
          "7722:   mg_md5(ha1, user, \":\", domain, \":\", pass, NULL);",
          "7723:   fprintf(fp2, \"%s:%s:%s\\n\", user, domain, ha1);",
          "7724:  }",
          "7727:  fclose(fp);",
          "7728:  fclose(fp2);",
          "7731:  IGNORE_UNUSED_RESULT(remove(fname));",
          "7732:  IGNORE_UNUSED_RESULT(rename(tmp, fname));",
          "7734:  return 1;",
          "7735: }",
          "7738: static int",
          "7739: is_valid_port(unsigned long port)",
          "7740: {",
          "7741:  return (port <= 0xffff);",
          "7742: }",
          "7745: static int",
          "7746: mg_inet_pton(int af, const char *src, void *dst, size_t dstlen)",
          "7747: {",
          "7748:  struct addrinfo hints, *res, *ressave;",
          "7749:  int func_ret = 0;",
          "7750:  int gai_ret;",
          "7752:  memset(&hints, 0, sizeof(struct addrinfo));",
          "7753:  hints.ai_family = af;",
          "7755:  gai_ret = getaddrinfo(src, NULL, &hints, &res);",
          "7756:  if (gai_ret != 0) {",
          "7764:   return 0;",
          "7765:  }",
          "7767:  ressave = res;",
          "7769:  while (res) {",
          "7770:   if (dstlen >= (size_t)res->ai_addrlen) {",
          "7771:    memcpy(dst, res->ai_addr, res->ai_addrlen);",
          "7772:    func_ret = 1;",
          "7774:   res = res->ai_next;",
          "7777:  freeaddrinfo(ressave);",
          "7778:  return func_ret;",
          "7779: }",
          "7782: static int",
          "7783: connect_socket(struct mg_context *ctx /* may be NULL */,",
          "7784:                const char *host,",
          "7785:                int port,",
          "7786:                int use_ssl,",
          "7787:                char *ebuf,",
          "7788:                size_t ebuf_len,",
          "7789:                SOCKET *sock /* output: socket, must not be NULL */,",
          "7791:                )",
          "7792: {",
          "7793:  int ip_ver = 0;",
          "7795:  memset(sa, 0, sizeof(*sa));",
          "7797:  if (ebuf_len > 0) {",
          "7799:  }",
          "7801:  if (host == NULL) {",
          "7802:   mg_snprintf(NULL,",
          "7804:               ebuf,",
          "7805:               ebuf_len,",
          "7806:               \"%s\",",
          "7807:               \"NULL host\");",
          "7808:   return 0;",
          "7809:  }",
          "7811:  if ((port <= 0) || !is_valid_port((unsigned)port)) {",
          "7812:   mg_snprintf(NULL,",
          "7814:               ebuf,",
          "7815:               ebuf_len,",
          "7816:               \"%s\",",
          "7817:               \"invalid port\");",
          "7818:   return 0;",
          "7819:  }",
          "7824:  if (use_ssl && (TLS_client_method == NULL)) {",
          "7825:   mg_snprintf(NULL,",
          "7827:               ebuf,",
          "7828:               ebuf_len,",
          "7829:               \"%s\",",
          "7830:               \"SSL is not initialized\");",
          "7831:   return 0;",
          "7832:  }",
          "7834:  if (use_ssl && (SSLv23_client_method == NULL)) {",
          "7835:   mg_snprintf(NULL,",
          "7837:               ebuf,",
          "7838:               ebuf_len,",
          "7839:               \"%s\",",
          "7840:               \"SSL is not initialized\");",
          "7841:   return 0;",
          "7842:  }",
          "",
          "---------------",
          "--- Hunk 43 ---",
          "[Context before]",
          "7792:  (void)use_ssl;",
          "7799: #ifdef USE_IPV6",
          "7817:    }",
          "7867:   }",
          "7868: #endif",
          "7871:   mg_snprintf(NULL,",
          "7873:               ebuf,",
          "7874:               ebuf_len,",
          "7882:   return 0;",
          "7883:  }",
          "7909:  }",
          "7924:   }",
          "7926:    mg_snprintf(de->conn,",
          "7928:                size,",
          "7929:                sizeof(size),",
          "7932:   } else {",
          "7964:   }",
          "7989:  }",
          "8030:  }",
          "8043:  }",
          "8098:    }",
          "8100:   }",
          "8102:  }",
          "8105: #if !defined(NO_FILES)",
          "8154:      ok = 0;",
          "8155:     }",
          "8166:     }",
          "8167:    }",
          "8171:   }",
          "8174:  }",
          "8175: #endif",
          "8193:  }",
          "8217:  }",
          "8312:   }",
          "8327: #if defined(__linux__)",
          "8363:     if (sf_sent > 0) {",
          "8365:     }",
          "8371:    }",
          "8406:     }",
          "8407:    }",
          "8408:   }",
          "8409:  }",
          "8432:  }",
          "8439: #ifdef _WIN32",
          "8441: #else",
          "8442:   if (fcntl(fileno(filep->fp), F_SETFD, FD_CLOEXEC) != 0) {",
          "8443:    mg_cry(conn,",
          "",
          "[Removed Lines]",
          "7795:   if (mg_inet_pton(AF_INET, host, &sa->sin, sizeof(sa->sin))) {",
          "7796:    sa->sin.sin_family = AF_INET;",
          "7797:    sa->sin.sin_port = htons((uint16_t)port);",
          "7798:    ip_ver = 4;",
          "7800:   } else if (mg_inet_pton(AF_INET6, host, &sa->sin6, sizeof(sa->sin6))) {",
          "7801:    sa->sin6.sin6_family = AF_INET6;",
          "7802:    sa->sin6.sin6_port = htons((uint16_t)port);",
          "7803:    ip_ver = 6;",
          "7804:   } else if (host[0] == '[') {",
          "7807:    size_t l = strlen(host + 1);",
          "7808:    char *h = (l > 1) ? mg_strdup(host + 1) : NULL;",
          "7809:    if (h) {",
          "7810:     h[l - 1] = 0;",
          "7811:     if (mg_inet_pton(AF_INET6, h, &sa->sin6, sizeof(sa->sin6))) {",
          "7812:      sa->sin6.sin6_family = AF_INET6;",
          "7813:      sa->sin6.sin6_port = htons((uint16_t)port);",
          "7814:      ip_ver = 6;",
          "7815:     }",
          "7816:     mg_free(h);",
          "7818: #endif",
          "7819:   }",
          "7821:   if (ip_ver == 0) {",
          "7822:    mg_snprintf(NULL,",
          "7824:                ebuf,",
          "7825:                ebuf_len,",
          "7826:                \"%s\",",
          "7827:                \"host not found\");",
          "7828:    return 0;",
          "7829:   }",
          "7831:   if (ip_ver == 4) {",
          "7833:   }",
          "7834: #ifdef USE_IPV6",
          "7835:   else if (ip_ver == 6) {",
          "7837:   }",
          "7838: #endif",
          "7840:   if (*sock == INVALID_SOCKET) {",
          "7841:    mg_snprintf(NULL,",
          "7843:                ebuf,",
          "7844:                ebuf_len,",
          "7845:                \"socket(): %s\",",
          "7846:                strerror(ERRNO));",
          "7847:    return 0;",
          "7848:   }",
          "7850:   set_close_on_exec(*sock, fc(ctx));",
          "7852:   if ((ip_ver == 4)",
          "7853:       && (connect(*sock, (struct sockaddr *)&sa->sin, sizeof(sa->sin))",
          "7854:           == 0)) {",
          "7856:    set_blocking_mode(*sock, 0);",
          "7857:    return 1;",
          "7858:   }",
          "7860: #ifdef USE_IPV6",
          "7861:   if ((ip_ver == 6)",
          "7862:       && (connect(*sock, (struct sockaddr *)&sa->sin6, sizeof(sa->sin6))",
          "7863:           == 0)) {",
          "7865:    set_blocking_mode(*sock, 0);",
          "7866:    return 1;",
          "7875:               \"connect(%s:%d): %s\",",
          "7876:               host,",
          "7877:               port,",
          "7878:               strerror(ERRNO));",
          "7879:   closesocket(*sock);",
          "7886:  int mg_url_encode(const char *src, char *dst, size_t dst_len)",
          "7887:  {",
          "7888:   static const char *dont_escape = \"._-$,;~()\";",
          "7889:   static const char *hex = \"0123456789abcdef\";",
          "7890:   char *pos = dst;",
          "7891:   const char *end = dst + dst_len - 1;",
          "7893:   for (; ((*src != '\\0') && (pos < end)); src++, pos++) {",
          "7894:    if (isalnum(*(const unsigned char *)src)",
          "7895:        || (strchr(dont_escape, *(const unsigned char *)src) != NULL)) {",
          "7897:    } else if (pos + 2 < end) {",
          "7898:     pos[0] = '%';",
          "7899:     pos[1] = hex[(*(const unsigned char *)src) >> 4];",
          "7900:     pos[2] = hex[(*(const unsigned char *)src) & 0xf];",
          "7901:     pos += 2;",
          "7902:    } else {",
          "7903:     break;",
          "7904:    }",
          "7905:   }",
          "7908:   return (*src == '\\0') ? (int)(pos - dst) : -1;",
          "7913:  static int print_dir_entry(struct de * de)",
          "7914:  {",
          "7915:   size_t hrefsize;",
          "7916:   char *href;",
          "7917:   char size[64], mod[64];",
          "7918:   struct tm *tm;",
          "7921:   href = mg_malloc(hrefsize);",
          "7922:   if (href == NULL) {",
          "7923:    return -1;",
          "7925:   if (de->file.is_directory) {",
          "7930:                \"%s\",",
          "7931:                \"[DIRECTORY]\");",
          "7935:    if (de->file.size < 1024) {",
          "7936:     mg_snprintf(de->conn,",
          "7938:                 size,",
          "7939:                 sizeof(size),",
          "7940:                 \"%d\",",
          "7941:                 (int)de->file.size);",
          "7942:    } else if (de->file.size < 0x100000) {",
          "7943:     mg_snprintf(de->conn,",
          "7945:                 size,",
          "7946:                 sizeof(size),",
          "7947:                 \"%.1fk\",",
          "7948:                 (double)de->file.size / 1024.0);",
          "7949:    } else if (de->file.size < 0x40000000) {",
          "7950:     mg_snprintf(de->conn,",
          "7952:                 size,",
          "7953:                 sizeof(size),",
          "7954:                 \"%.1fM\",",
          "7955:                 (double)de->file.size / 1048576);",
          "7956:    } else {",
          "7957:     mg_snprintf(de->conn,",
          "7959:                 size,",
          "7960:                 sizeof(size),",
          "7961:                 \"%.1fG\",",
          "7962:                 (double)de->file.size / 1073741824);",
          "7963:    }",
          "7969:   tm = localtime(&de->file.last_modified);",
          "7970:   if (tm != NULL) {",
          "7971:    strftime(mod, sizeof(mod), \"%d-%b-%Y %H:%M\", tm);",
          "7972:   } else {",
          "7973:    mg_strlcpy(mod, \"01-Jan-1970 00:00\", sizeof(mod));",
          "7974:    mod[sizeof(mod) - 1] = '\\0';",
          "7975:   }",
          "7976:   mg_url_encode(de->file_name, href, hrefsize);",
          "7977:   mg_printf(de->conn,",
          "7978:             \"<tr><td><a href=\\\"%s%s%s\\\">%s%s</a></td>\"",
          "7979:             \"<td>&nbsp;%s</td><td>&nbsp;&nbsp;%s</td></tr>\\n\",",
          "7980:             de->conn->request_info.local_uri,",
          "7981:             href,",
          "7982:             de->file.is_directory ? \"/\" : \"\",",
          "7983:             de->file_name,",
          "7984:             de->file.is_directory ? \"/\" : \"\",",
          "7985:             mod,",
          "7986:             size);",
          "7987:   mg_free(href);",
          "7988:   return 0;",
          "7996:  static int WINCDECL compare_dir_entries(const void *p1, const void *p2)",
          "7997:  {",
          "7998:   if (p1 && p2) {",
          "7999:    const struct de *a = (const struct de *)p1,",
          "8001:    const char *query_string = a->conn->request_info.query_string;",
          "8002:    int cmp_result = 0;",
          "8004:    if (query_string == NULL) {",
          "8005:     query_string = \"na\";",
          "8006:    }",
          "8008:    if (a->file.is_directory && !b->file.is_directory) {",
          "8010:    } else if (!a->file.is_directory && b->file.is_directory) {",
          "8012:    } else if (*query_string == 'n') {",
          "8013:     cmp_result = strcmp(a->file_name, b->file_name);",
          "8014:    } else if (*query_string == 's') {",
          "8015:     cmp_result = (a->file.size == b->file.size)",
          "8016:                      ? 0",
          "8017:                      : ((a->file.size > b->file.size) ? 1 : -1);",
          "8018:    } else if (*query_string == 'd') {",
          "8019:     cmp_result =",
          "8020:         (a->file.last_modified == b->file.last_modified)",
          "8021:             ? 0",
          "8022:             : ((a->file.last_modified > b->file.last_modified)",
          "8023:                    ? 1",
          "8024:                    : -1);",
          "8025:    }",
          "8027:    return (query_string[1] == 'd') ? -cmp_result : cmp_result;",
          "8028:   }",
          "8029:   return 0;",
          "8033:  static int must_hide_file(struct mg_connection * conn, const char *path)",
          "8034:  {",
          "8035:   if (conn && conn->ctx) {",
          "8036:    const char *pw_pattern = \"**\" PASSWORDS_FILE_NAME \"$\";",
          "8037:    const char *pattern = conn->ctx->config[HIDE_FILES];",
          "8038:    return (match_prefix(pw_pattern, strlen(pw_pattern), path) > 0)",
          "8039:           || ((pattern != NULL)",
          "8040:               && (match_prefix(pattern, strlen(pattern), path) > 0));",
          "8041:   }",
          "8042:   return 0;",
          "8046:  static int scan_directory(struct mg_connection * conn,",
          "8047:                            const char *dir,",
          "8048:                            void *data,",
          "8049:                            int (*cb)(struct de *, void *))",
          "8050:  {",
          "8051:   char path[PATH_MAX];",
          "8052:   struct dirent *dp;",
          "8053:   DIR *dirp;",
          "8054:   struct de de;",
          "8055:   int truncated;",
          "8057:   if ((dirp = mg_opendir(conn, dir)) == NULL) {",
          "8058:    return 0;",
          "8059:   } else {",
          "8060:    de.conn = conn;",
          "8062:    while ((dp = mg_readdir(dirp)) != NULL) {",
          "8064:     if (!strcmp(dp->d_name, \".\") || !strcmp(dp->d_name, \"..\")",
          "8065:         || must_hide_file(conn, dp->d_name)) {",
          "8066:      continue;",
          "8067:     }",
          "8069:     mg_snprintf(conn,",
          "8070:                 &truncated,",
          "8071:                 path,",
          "8072:                 sizeof(path),",
          "8073:                 \"%s/%s\",",
          "8074:                 dir,",
          "8075:                 dp->d_name);",
          "8082:     memset(&de.file, 0, sizeof(de.file));",
          "8084:     if (truncated) {",
          "8086:      continue;",
          "8087:     }",
          "8089:     if (!mg_stat(conn, path, &de.file)) {",
          "8090:      mg_cry(conn,",
          "8091:             \"%s: mg_stat(%s) failed: %s\",",
          "8092:             __func__,",
          "8093:             path,",
          "8094:             strerror(ERRNO));",
          "8095:     }",
          "8096:     de.file_name = dp->d_name;",
          "8097:     cb(&de, data);",
          "8099:    (void)mg_closedir(dirp);",
          "8101:   return 1;",
          "8106:  static int remove_directory(struct mg_connection * conn, const char *dir)",
          "8107:  {",
          "8108:   char path[PATH_MAX];",
          "8109:   struct dirent *dp;",
          "8110:   DIR *dirp;",
          "8111:   struct de de;",
          "8112:   int truncated;",
          "8113:   int ok = 1;",
          "8115:   if ((dirp = mg_opendir(conn, dir)) == NULL) {",
          "8116:    return 0;",
          "8117:   } else {",
          "8118:    de.conn = conn;",
          "8120:    while ((dp = mg_readdir(dirp)) != NULL) {",
          "8123:     if (!strcmp(dp->d_name, \".\") || !strcmp(dp->d_name, \"..\")) {",
          "8124:      continue;",
          "8125:     }",
          "8127:     mg_snprintf(conn,",
          "8128:                 &truncated,",
          "8129:                 path,",
          "8130:                 sizeof(path),",
          "8131:                 \"%s/%s\",",
          "8132:                 dir,",
          "8133:                 dp->d_name);",
          "8140:     memset(&de.file, 0, sizeof(de.file));",
          "8142:     if (truncated) {",
          "8144:      ok = 0;",
          "8145:      continue;",
          "8146:     }",
          "8148:     if (!mg_stat(conn, path, &de.file)) {",
          "8149:      mg_cry(conn,",
          "8150:             \"%s: mg_stat(%s) failed: %s\",",
          "8151:             __func__,",
          "8152:             path,",
          "8153:             strerror(ERRNO));",
          "8157:     if (de.file.is_directory) {",
          "8158:      if (remove_directory(conn, path) == 0) {",
          "8159:       ok = 0;",
          "8160:      }",
          "8161:     } else {",
          "8163:      if (mg_remove(conn, path) == 0) {",
          "8164:       ok = 0;",
          "8165:      }",
          "8168:    (void)mg_closedir(dirp);",
          "8170:    IGNORE_UNUSED_RESULT(rmdir(dir));",
          "8173:   return ok;",
          "8178:  struct dir_scan_data {",
          "8179:   struct de *entries;",
          "8180:   unsigned int num_entries;",
          "8181:   unsigned int arr_size;",
          "8182:  };",
          "8186:  static void *realloc2(void *ptr, size_t size)",
          "8187:  {",
          "8188:   void *new_ptr = mg_realloc(ptr, size);",
          "8189:   if (new_ptr == NULL) {",
          "8190:    mg_free(ptr);",
          "8191:   }",
          "8192:   return new_ptr;",
          "8196:  static int dir_scan_callback(struct de * de, void *data)",
          "8197:  {",
          "8198:   struct dir_scan_data *dsd = (struct dir_scan_data *)data;",
          "8200:   if ((dsd->entries == NULL) || (dsd->num_entries >= dsd->arr_size)) {",
          "8201:    dsd->arr_size *= 2;",
          "8202:    dsd->entries =",
          "8203:        (struct de *)realloc2(dsd->entries,",
          "8204:                              dsd->arr_size * sizeof(dsd->entries[0]));",
          "8205:   }",
          "8206:   if (dsd->entries == NULL) {",
          "8208:    dsd->num_entries = 0;",
          "8209:   } else {",
          "8210:    dsd->entries[dsd->num_entries].file_name = mg_strdup(de->file_name);",
          "8211:    dsd->entries[dsd->num_entries].file = de->file;",
          "8212:    dsd->entries[dsd->num_entries].conn = de->conn;",
          "8213:    dsd->num_entries++;",
          "8214:   }",
          "8216:   return 0;",
          "8220:  static void handle_directory_request(struct mg_connection * conn,",
          "8221:                                       const char *dir)",
          "8222:  {",
          "8223:   unsigned int i;",
          "8224:   int sort_direction;",
          "8225:   struct dir_scan_data data = {NULL, 0, 128};",
          "8226:   char date[64];",
          "8227:   time_t curtime = time(NULL);",
          "8229:   if (!scan_directory(conn, dir, &data, dir_scan_callback)) {",
          "8230:    mg_send_http_error(conn,",
          "8231:                       500,",
          "8232:                       \"Error: Cannot open directory\\nopendir(%s): %s\",",
          "8233:                       dir,",
          "8234:                       strerror(ERRNO));",
          "8235:    return;",
          "8236:   }",
          "8238:   gmt_time_string(date, sizeof(date), &curtime);",
          "8240:   if (!conn) {",
          "8241:    return;",
          "8242:   }",
          "8244:   sort_direction = ((conn->request_info.query_string != NULL)",
          "8245:                     && (conn->request_info.query_string[1] == 'd'))",
          "8246:                        ? 'a'",
          "8247:                        : 'd';",
          "8249:   conn->must_close = 1;",
          "8250:   mg_printf(conn, \"HTTP/1.1 200 OK\\r\\n\");",
          "8251:   send_static_cache_header(conn);",
          "8252:   send_additional_header(conn);",
          "8253:   mg_printf(conn,",
          "8254:             \"Date: %s\\r\\n\"",
          "8255:             \"Connection: close\\r\\n\"",
          "8256:             \"Content-Type: text/html; charset=utf-8\\r\\n\\r\\n\",",
          "8257:             date);",
          "8258:   mg_printf(conn,",
          "8259:             \"<html><head><title>Index of %s</title>\"",
          "8260:             \"<style>th {text-align: left;}</style></head>\"",
          "8261:             \"<body><h1>Index of %s</h1><pre><table cellpadding=\\\"0\\\">\"",
          "8262:             \"<tr><th><a href=\\\"?n%c\\\">Name</a></th>\"",
          "8263:             \"<th><a href=\\\"?d%c\\\">Modified</a></th>\"",
          "8264:             \"<th><a href=\\\"?s%c\\\">Size</a></th></tr>\"",
          "8265:             \"<tr><td colspan=\\\"3\\\"><hr></td></tr>\",",
          "8266:             conn->request_info.local_uri,",
          "8267:             conn->request_info.local_uri,",
          "8268:             sort_direction,",
          "8269:             sort_direction,",
          "8270:             sort_direction);",
          "8273:   mg_printf(conn,",
          "8274:             \"<tr><td><a href=\\\"%s%s\\\">%s</a></td>\"",
          "8275:             \"<td>&nbsp;%s</td><td>&nbsp;&nbsp;%s</td></tr>\\n\",",
          "8276:             conn->request_info.local_uri,",
          "8277:             \"..\",",
          "8278:             \"Parent directory\",",
          "8279:             \"-\",",
          "8280:             \"-\");",
          "8283:   if (data.entries != NULL) {",
          "8284:    qsort(data.entries,",
          "8285:          (size_t)data.num_entries,",
          "8286:          sizeof(data.entries[0]),",
          "8287:          compare_dir_entries);",
          "8288:    for (i = 0; i < data.num_entries; i++) {",
          "8289:     print_dir_entry(&data.entries[i]);",
          "8290:     mg_free(data.entries[i].file_name);",
          "8291:    }",
          "8292:    mg_free(data.entries);",
          "8293:   }",
          "8295:   mg_printf(conn, \"%s\", \"</table></body></html>\");",
          "8296:   conn->status_code = 200;",
          "8297:  }",
          "8301:  static void send_file_data(struct mg_connection * conn,",
          "8302:                             struct mg_file * filep,",
          "8303:                             int64_t offset,",
          "8304:                             int64_t len)",
          "8305:  {",
          "8306:   char buf[MG_BUF_LEN];",
          "8307:   int to_read, num_read, num_written;",
          "8308:   int64_t size;",
          "8310:   if (!filep || !conn) {",
          "8311:    return;",
          "8315:   size = (filep->stat.size > INT64_MAX) ? INT64_MAX",
          "8316:                                         : (int64_t)(filep->stat.size);",
          "8317:   offset = (offset < 0) ? 0 : ((offset > size) ? size : offset);",
          "8319:   if ((len > 0) && (filep->access.membuf != NULL) && (size > 0)) {",
          "8321:    if (len > size - offset) {",
          "8322:     len = size - offset;",
          "8323:    }",
          "8324:    mg_write(conn, filep->access.membuf + offset, (size_t)len);",
          "8325:   } else if (len > 0 && filep->access.fp != NULL) {",
          "8329:    if ((conn->ssl == 0) && (conn->throttle == 0)",
          "8330:        && (!mg_strcasecmp(conn->ctx->config[ALLOW_SENDFILE_CALL],",
          "8331:                           \"yes\"))) {",
          "8332:     off_t sf_offs = (off_t)offset;",
          "8333:     ssize_t sf_sent;",
          "8334:     int sf_file = fileno(filep->access.fp);",
          "8335:     int loop_cnt = 0;",
          "8337:     do {",
          "8340:      size_t sf_tosend =",
          "8341:          (size_t)((len < 0x7FFFF000) ? len : 0x7FFFF000);",
          "8342:      sf_sent = sendfile(conn->client.sock,",
          "8343:                         sf_file,",
          "8344:                         &sf_offs,",
          "8345:                         sf_tosend);",
          "8346:      if (sf_sent > 0) {",
          "8347:       len -= sf_sent;",
          "8348:       offset += sf_sent;",
          "8349:      } else if (loop_cnt == 0) {",
          "8354:       break;",
          "8355:      } else if (sf_sent == 0) {",
          "8357:       return;",
          "8358:      }",
          "8359:      loop_cnt++;",
          "8361:     } while ((len > 0) && (sf_sent >= 0));",
          "8370:     offset = (int64_t)sf_offs;",
          "8372: #endif",
          "8373:    if ((offset > 0)",
          "8374:        && (fseeko(filep->access.fp, offset, SEEK_SET) != 0)) {",
          "8375:     mg_cry(conn,",
          "8376:            \"%s: fseeko() failed: %s\",",
          "8377:            __func__,",
          "8378:            strerror(ERRNO));",
          "8379:     mg_send_http_error(",
          "8380:         conn,",
          "8381:         500,",
          "8382:         \"%s\",",
          "8383:         \"Error: Unable to access file at requested position.\");",
          "8384:    } else {",
          "8385:     while (len > 0) {",
          "8387:      to_read = sizeof(buf);",
          "8388:      if ((int64_t)to_read > len) {",
          "8389:       to_read = (int)len;",
          "8390:      }",
          "8393:      if ((num_read = (int)fread(",
          "8394:               buf, 1, (size_t)to_read, filep->access.fp)) <= 0) {",
          "8395:       break;",
          "8396:      }",
          "8399:      if ((num_written = mg_write(conn, buf, (size_t)num_read))",
          "8400:          != num_read) {",
          "8401:       break;",
          "8402:      }",
          "8405:      len -= num_written;",
          "8412:  static int parse_range_header(const char *header, int64_t *a, int64_t *b)",
          "8413:  {",
          "8414:   return sscanf(header, \"bytes=%\" INT64_FMT \"-%\" INT64_FMT, a, b);",
          "8415:  }",
          "8418:  static void construct_etag(char *buf,",
          "8419:                             size_t buf_len,",
          "8420:                             const struct mg_file_stat *filestat)",
          "8421:  {",
          "8422:   if ((filestat != NULL) && (buf != NULL)) {",
          "8423:    mg_snprintf(",
          "8424:        NULL,",
          "8426:        buf,",
          "8427:        buf_len,",
          "8428:        \"\\\"%lx.%\" INT64_FMT \"\\\"\",",
          "8429:        (unsigned long)filestat->last_modified,",
          "8430:        filestat->size);",
          "8431:   }",
          "8435:  static void fclose_on_exec(struct mg_file_access * filep,",
          "8436:                             struct mg_connection * conn)",
          "8437:  {",
          "8438:   if (filep != NULL && filep->fp != NULL) {",
          "",
          "[Added Lines]",
          "7852:  if (mg_inet_pton(AF_INET, host, &sa->sin, sizeof(sa->sin))) {",
          "7853:   sa->sin.sin_family = AF_INET;",
          "7854:   sa->sin.sin_port = htons((uint16_t)port);",
          "7855:   ip_ver = 4;",
          "7857:  } else if (mg_inet_pton(AF_INET6, host, &sa->sin6, sizeof(sa->sin6))) {",
          "7858:   sa->sin6.sin6_family = AF_INET6;",
          "7859:   sa->sin6.sin6_port = htons((uint16_t)port);",
          "7860:   ip_ver = 6;",
          "7861:  } else if (host[0] == '[') {",
          "7864:   size_t l = strlen(host + 1);",
          "7865:   char *h = (l > 1) ? mg_strdup(host + 1) : NULL;",
          "7866:   if (h) {",
          "7867:    h[l - 1] = 0;",
          "7868:    if (mg_inet_pton(AF_INET6, h, &sa->sin6, sizeof(sa->sin6))) {",
          "7869:     sa->sin6.sin6_family = AF_INET6;",
          "7870:     sa->sin6.sin6_port = htons((uint16_t)port);",
          "7871:     ip_ver = 6;",
          "7873:    mg_free(h);",
          "7876:  }",
          "7878:  if (ip_ver == 0) {",
          "7883:               \"%s\",",
          "7884:               \"host not found\");",
          "7888:  if (ip_ver == 4) {",
          "7890:  }",
          "7891: #ifdef USE_IPV6",
          "7892:  else if (ip_ver == 6) {",
          "7894:  }",
          "7895: #endif",
          "7897:  if (*sock == INVALID_SOCKET) {",
          "7898:   mg_snprintf(NULL,",
          "7900:               ebuf,",
          "7901:               ebuf_len,",
          "7902:               \"socket(): %s\",",
          "7903:               strerror(ERRNO));",
          "7904:   return 0;",
          "7905:  }",
          "7907:  set_close_on_exec(*sock, fc(ctx));",
          "7909:  if ((ip_ver == 4)",
          "7910:      && (connect(*sock, (struct sockaddr *)&sa->sin, sizeof(sa->sin))",
          "7911:          == 0)) {",
          "7913:   set_blocking_mode(*sock, 0);",
          "7914:   return 1;",
          "7917: #ifdef USE_IPV6",
          "7918:  if ((ip_ver == 6)",
          "7919:      && (connect(*sock, (struct sockaddr *)&sa->sin6, sizeof(sa->sin6))",
          "7920:          == 0)) {",
          "7922:   set_blocking_mode(*sock, 0);",
          "7923:   return 1;",
          "7924:  }",
          "7925: #endif",
          "7928:  mg_snprintf(NULL,",
          "7930:              ebuf,",
          "7931:              ebuf_len,",
          "7932:              \"connect(%s:%d): %s\",",
          "7933:              host,",
          "7934:              port,",
          "7935:              strerror(ERRNO));",
          "7936:  closesocket(*sock);",
          "7939:  return 0;",
          "7940: }",
          "7943: int",
          "7944: mg_url_encode(const char *src, char *dst, size_t dst_len)",
          "7945: {",
          "7946:  static const char *dont_escape = \"._-$,;~()\";",
          "7947:  static const char *hex = \"0123456789abcdef\";",
          "7948:  char *pos = dst;",
          "7949:  const char *end = dst + dst_len - 1;",
          "7951:  for (; ((*src != '\\0') && (pos < end)); src++, pos++) {",
          "7952:   if (isalnum(*(const unsigned char *)src)",
          "7953:       || (strchr(dont_escape, *(const unsigned char *)src) != NULL)) {",
          "7955:   } else if (pos + 2 < end) {",
          "7956:    pos[0] = '%';",
          "7957:    pos[1] = hex[(*(const unsigned char *)src) >> 4];",
          "7958:    pos[2] = hex[(*(const unsigned char *)src) & 0xf];",
          "7959:    pos += 2;",
          "7960:   } else {",
          "7961:    break;",
          "7963:  }",
          "7966:  return (*src == '\\0') ? (int)(pos - dst) : -1;",
          "7967: }",
          "7971: static int",
          "7972: print_dir_entry(struct de *de)",
          "7973: {",
          "7974:  size_t hrefsize;",
          "7975:  char *href;",
          "7976:  char size[64], mod[64];",
          "7977:  struct tm *tm;",
          "7980:  href = mg_malloc(hrefsize);",
          "7981:  if (href == NULL) {",
          "7982:   return -1;",
          "7983:  }",
          "7984:  if (de->file.is_directory) {",
          "7985:   mg_snprintf(de->conn,",
          "7987:               size,",
          "7988:               sizeof(size),",
          "7989:               \"%s\",",
          "7990:               \"[DIRECTORY]\");",
          "7991:  } else {",
          "7994:   if (de->file.size < 1024) {",
          "7999:                \"%d\",",
          "8000:                (int)de->file.size);",
          "8001:   } else if (de->file.size < 0x100000) {",
          "8002:    mg_snprintf(de->conn,",
          "8004:                size,",
          "8005:                sizeof(size),",
          "8006:                \"%.1fk\",",
          "8007:                (double)de->file.size / 1024.0);",
          "8008:   } else if (de->file.size < 0x40000000) {",
          "8009:    mg_snprintf(de->conn,",
          "8011:                size,",
          "8012:                sizeof(size),",
          "8013:                \"%.1fM\",",
          "8014:                (double)de->file.size / 1048576);",
          "8016:    mg_snprintf(de->conn,",
          "8018:                size,",
          "8019:                sizeof(size),",
          "8020:                \"%.1fG\",",
          "8021:                (double)de->file.size / 1073741824);",
          "8028:  tm = localtime(&de->file.last_modified);",
          "8029:  if (tm != NULL) {",
          "8030:   strftime(mod, sizeof(mod), \"%d-%b-%Y %H:%M\", tm);",
          "8031:  } else {",
          "8032:   mg_strlcpy(mod, \"01-Jan-1970 00:00\", sizeof(mod));",
          "8033:   mod[sizeof(mod) - 1] = '\\0';",
          "8034:  }",
          "8035:  mg_url_encode(de->file_name, href, hrefsize);",
          "8036:  mg_printf(de->conn,",
          "8037:            \"<tr><td><a href=\\\"%s%s%s\\\">%s%s</a></td>\"",
          "8038:            \"<td>&nbsp;%s</td><td>&nbsp;&nbsp;%s</td></tr>\\n\",",
          "8039:            de->conn->request_info.local_uri,",
          "8040:            href,",
          "8041:            de->file.is_directory ? \"/\" : \"\",",
          "8042:            de->file_name,",
          "8043:            de->file.is_directory ? \"/\" : \"\",",
          "8044:            mod,",
          "8045:            size);",
          "8046:  mg_free(href);",
          "8047:  return 0;",
          "8048: }",
          "8055: static int WINCDECL",
          "8056: compare_dir_entries(const void *p1, const void *p2)",
          "8057: {",
          "8058:  if (p1 && p2) {",
          "8059:   const struct de *a = (const struct de *)p1, *b = (const struct de *)p2;",
          "8060:   const char *query_string = a->conn->request_info.query_string;",
          "8061:   int cmp_result = 0;",
          "8063:   if (query_string == NULL) {",
          "8064:    query_string = \"na\";",
          "8065:   }",
          "8067:   if (a->file.is_directory && !b->file.is_directory) {",
          "8069:   } else if (!a->file.is_directory && b->file.is_directory) {",
          "8071:   } else if (*query_string == 'n') {",
          "8072:    cmp_result = strcmp(a->file_name, b->file_name);",
          "8073:   } else if (*query_string == 's') {",
          "8074:    cmp_result = (a->file.size == b->file.size)",
          "8075:                     ? 0",
          "8076:                     : ((a->file.size > b->file.size) ? 1 : -1);",
          "8077:   } else if (*query_string == 'd') {",
          "8078:    cmp_result =",
          "8079:        (a->file.last_modified == b->file.last_modified)",
          "8080:            ? 0",
          "8081:            : ((a->file.last_modified > b->file.last_modified) ? 1",
          "8082:                                                               : -1);",
          "8083:   }",
          "8085:   return (query_string[1] == 'd') ? -cmp_result : cmp_result;",
          "8087:  return 0;",
          "8088: }",
          "8091: static int",
          "8092: must_hide_file(struct mg_connection *conn, const char *path)",
          "8093: {",
          "8094:  if (conn && conn->ctx) {",
          "8095:   const char *pw_pattern = \"**\" PASSWORDS_FILE_NAME \"$\";",
          "8096:   const char *pattern = conn->ctx->config[HIDE_FILES];",
          "8097:   return (match_prefix(pw_pattern, strlen(pw_pattern), path) > 0)",
          "8098:          || ((pattern != NULL)",
          "8099:              && (match_prefix(pattern, strlen(pattern), path) > 0));",
          "8101:  return 0;",
          "8102: }",
          "8105: static int",
          "8106: scan_directory(struct mg_connection *conn,",
          "8107:                const char *dir,",
          "8108:                void *data,",
          "8109:                int (*cb)(struct de *, void *))",
          "8110: {",
          "8111:  char path[PATH_MAX];",
          "8112:  struct dirent *dp;",
          "8113:  DIR *dirp;",
          "8114:  struct de de;",
          "8115:  int truncated;",
          "8117:  if ((dirp = mg_opendir(conn, dir)) == NULL) {",
          "8118:   return 0;",
          "8119:  } else {",
          "8120:   de.conn = conn;",
          "8122:   while ((dp = mg_readdir(dirp)) != NULL) {",
          "8124:    if (!strcmp(dp->d_name, \".\") || !strcmp(dp->d_name, \"..\")",
          "8125:        || must_hide_file(conn, dp->d_name)) {",
          "8126:     continue;",
          "8127:    }",
          "8129:    mg_snprintf(",
          "8130:        conn, &truncated, path, sizeof(path), \"%s/%s\", dir, dp->d_name);",
          "8137:    memset(&de.file, 0, sizeof(de.file));",
          "8139:    if (truncated) {",
          "8141:     continue;",
          "8142:    }",
          "8144:    if (!mg_stat(conn, path, &de.file)) {",
          "8145:     mg_cry(conn,",
          "8146:            \"%s: mg_stat(%s) failed: %s\",",
          "8147:            __func__,",
          "8148:            path,",
          "8149:            strerror(ERRNO));",
          "8151:    de.file_name = dp->d_name;",
          "8152:    cb(&de, data);",
          "8154:   (void)mg_closedir(dirp);",
          "8156:  return 1;",
          "8157: }",
          "8161: static int",
          "8162: remove_directory(struct mg_connection *conn, const char *dir)",
          "8163: {",
          "8164:  char path[PATH_MAX];",
          "8165:  struct dirent *dp;",
          "8166:  DIR *dirp;",
          "8167:  struct de de;",
          "8168:  int truncated;",
          "8169:  int ok = 1;",
          "8171:  if ((dirp = mg_opendir(conn, dir)) == NULL) {",
          "8172:   return 0;",
          "8173:  } else {",
          "8174:   de.conn = conn;",
          "8176:   while ((dp = mg_readdir(dirp)) != NULL) {",
          "8179:    if (!strcmp(dp->d_name, \".\") || !strcmp(dp->d_name, \"..\")) {",
          "8180:     continue;",
          "8181:    }",
          "8183:    mg_snprintf(",
          "8184:        conn, &truncated, path, sizeof(path), \"%s/%s\", dir, dp->d_name);",
          "8191:    memset(&de.file, 0, sizeof(de.file));",
          "8193:    if (truncated) {",
          "8195:     ok = 0;",
          "8196:     continue;",
          "8197:    }",
          "8199:    if (!mg_stat(conn, path, &de.file)) {",
          "8200:     mg_cry(conn,",
          "8201:            \"%s: mg_stat(%s) failed: %s\",",
          "8202:            __func__,",
          "8203:            path,",
          "8204:            strerror(ERRNO));",
          "8205:     ok = 0;",
          "8206:    }",
          "8208:    if (de.file.is_directory) {",
          "8209:     if (remove_directory(conn, path) == 0) {",
          "8212:    } else {",
          "8214:     if (mg_remove(conn, path) == 0) {",
          "8215:      ok = 0;",
          "8219:   (void)mg_closedir(dirp);",
          "8221:   IGNORE_UNUSED_RESULT(rmdir(dir));",
          "8224:  return ok;",
          "8225: }",
          "8229: struct dir_scan_data {",
          "8230:  struct de *entries;",
          "8231:  unsigned int num_entries;",
          "8232:  unsigned int arr_size;",
          "8233: };",
          "8237: static void *",
          "8238: realloc2(void *ptr, size_t size)",
          "8239: {",
          "8240:  void *new_ptr = mg_realloc(ptr, size);",
          "8241:  if (new_ptr == NULL) {",
          "8242:   mg_free(ptr);",
          "8244:  return new_ptr;",
          "8245: }",
          "8248: static int",
          "8249: dir_scan_callback(struct de *de, void *data)",
          "8250: {",
          "8251:  struct dir_scan_data *dsd = (struct dir_scan_data *)data;",
          "8253:  if ((dsd->entries == NULL) || (dsd->num_entries >= dsd->arr_size)) {",
          "8254:   dsd->arr_size *= 2;",
          "8255:   dsd->entries =",
          "8256:       (struct de *)realloc2(dsd->entries,",
          "8257:                             dsd->arr_size * sizeof(dsd->entries[0]));",
          "8258:  }",
          "8259:  if (dsd->entries == NULL) {",
          "8261:   dsd->num_entries = 0;",
          "8262:  } else {",
          "8263:   dsd->entries[dsd->num_entries].file_name = mg_strdup(de->file_name);",
          "8264:   dsd->entries[dsd->num_entries].file = de->file;",
          "8265:   dsd->entries[dsd->num_entries].conn = de->conn;",
          "8266:   dsd->num_entries++;",
          "8269:  return 0;",
          "8270: }",
          "8273: static void",
          "8274: handle_directory_request(struct mg_connection *conn, const char *dir)",
          "8275: {",
          "8276:  unsigned int i;",
          "8277:  int sort_direction;",
          "8278:  struct dir_scan_data data = {NULL, 0, 128};",
          "8279:  char date[64];",
          "8280:  time_t curtime = time(NULL);",
          "8282:  if (!scan_directory(conn, dir, &data, dir_scan_callback)) {",
          "8283:   mg_send_http_error(conn,",
          "8284:                      500,",
          "8285:                      \"Error: Cannot open directory\\nopendir(%s): %s\",",
          "8286:                      dir,",
          "8287:                      strerror(ERRNO));",
          "8288:   return;",
          "8289:  }",
          "8291:  gmt_time_string(date, sizeof(date), &curtime);",
          "8293:  if (!conn) {",
          "8294:   return;",
          "8295:  }",
          "8297:  sort_direction = ((conn->request_info.query_string != NULL)",
          "8298:                    && (conn->request_info.query_string[1] == 'd'))",
          "8299:                       ? 'a'",
          "8300:                       : 'd';",
          "8302:  conn->must_close = 1;",
          "8303:  mg_printf(conn, \"HTTP/1.1 200 OK\\r\\n\");",
          "8304:  send_static_cache_header(conn);",
          "8305:  send_additional_header(conn);",
          "8306:  mg_printf(conn,",
          "8307:            \"Date: %s\\r\\n\"",
          "8308:            \"Connection: close\\r\\n\"",
          "8309:            \"Content-Type: text/html; charset=utf-8\\r\\n\\r\\n\",",
          "8310:            date);",
          "8311:  mg_printf(conn,",
          "8312:            \"<html><head><title>Index of %s</title>\"",
          "8313:            \"<style>th {text-align: left;}</style></head>\"",
          "8314:            \"<body><h1>Index of %s</h1><pre><table cellpadding=\\\"0\\\">\"",
          "8315:            \"<tr><th><a href=\\\"?n%c\\\">Name</a></th>\"",
          "8316:            \"<th><a href=\\\"?d%c\\\">Modified</a></th>\"",
          "8317:            \"<th><a href=\\\"?s%c\\\">Size</a></th></tr>\"",
          "8318:            \"<tr><td colspan=\\\"3\\\"><hr></td></tr>\",",
          "8319:            conn->request_info.local_uri,",
          "8320:            conn->request_info.local_uri,",
          "8321:            sort_direction,",
          "8322:            sort_direction,",
          "8323:            sort_direction);",
          "8326:  mg_printf(conn,",
          "8327:            \"<tr><td><a href=\\\"%s%s\\\">%s</a></td>\"",
          "8328:            \"<td>&nbsp;%s</td><td>&nbsp;&nbsp;%s</td></tr>\\n\",",
          "8329:            conn->request_info.local_uri,",
          "8330:            \"..\",",
          "8331:            \"Parent directory\",",
          "8332:            \"-\",",
          "8333:            \"-\");",
          "8336:  if (data.entries != NULL) {",
          "8337:   qsort(data.entries,",
          "8338:         (size_t)data.num_entries,",
          "8339:         sizeof(data.entries[0]),",
          "8340:         compare_dir_entries);",
          "8341:   for (i = 0; i < data.num_entries; i++) {",
          "8342:    print_dir_entry(&data.entries[i]);",
          "8343:    mg_free(data.entries[i].file_name);",
          "8344:   }",
          "8345:   mg_free(data.entries);",
          "8346:  }",
          "8348:  mg_printf(conn, \"%s\", \"</table></body></html>\");",
          "8349:  conn->status_code = 200;",
          "8350: }",
          "8354: static void",
          "8355: send_file_data(struct mg_connection *conn,",
          "8356:                struct mg_file *filep,",
          "8357:                int64_t offset,",
          "8358:                int64_t len)",
          "8359: {",
          "8360:  char buf[MG_BUF_LEN];",
          "8361:  int to_read, num_read, num_written;",
          "8362:  int64_t size;",
          "8364:  if (!filep || !conn) {",
          "8365:   return;",
          "8366:  }",
          "8369:  size = (filep->stat.size > INT64_MAX) ? INT64_MAX",
          "8370:                                        : (int64_t)(filep->stat.size);",
          "8371:  offset = (offset < 0) ? 0 : ((offset > size) ? size : offset);",
          "8373:  if ((len > 0) && (filep->access.membuf != NULL) && (size > 0)) {",
          "8375:   if (len > size - offset) {",
          "8376:    len = size - offset;",
          "8378:   mg_write(conn, filep->access.membuf + offset, (size_t)len);",
          "8379:  } else if (len > 0 && filep->access.fp != NULL) {",
          "8383:   if ((conn->ssl == 0) && (conn->throttle == 0)",
          "8384:       && (!mg_strcasecmp(conn->ctx->config[ALLOW_SENDFILE_CALL],",
          "8385:                          \"yes\"))) {",
          "8386:    off_t sf_offs = (off_t)offset;",
          "8387:    ssize_t sf_sent;",
          "8388:    int sf_file = fileno(filep->access.fp);",
          "8389:    int loop_cnt = 0;",
          "8391:    do {",
          "8394:     size_t sf_tosend =",
          "8395:         (size_t)((len < 0x7FFFF000) ? len : 0x7FFFF000);",
          "8396:     sf_sent =",
          "8397:         sendfile(conn->client.sock, sf_file, &sf_offs, sf_tosend);",
          "8399:      len -= sf_sent;",
          "8400:      offset += sf_sent;",
          "8401:     } else if (loop_cnt == 0) {",
          "8406:      break;",
          "8407:     } else if (sf_sent == 0) {",
          "8409:      return;",
          "8411:     loop_cnt++;",
          "8413:    } while ((len > 0) && (sf_sent >= 0));",
          "8415:    if (sf_sent > 0) {",
          "8422:    offset = (int64_t)sf_offs;",
          "8423:   }",
          "8424: #endif",
          "8425:   if ((offset > 0) && (fseeko(filep->access.fp, offset, SEEK_SET) != 0)) {",
          "8426:    mg_cry(conn, \"%s: fseeko() failed: %s\", __func__, strerror(ERRNO));",
          "8427:    mg_send_http_error(",
          "8428:        conn,",
          "8429:        500,",
          "8430:        \"%s\",",
          "8431:        \"Error: Unable to access file at requested position.\");",
          "8432:   } else {",
          "8433:    while (len > 0) {",
          "8435:     to_read = sizeof(buf);",
          "8436:     if ((int64_t)to_read > len) {",
          "8437:      to_read = (int)len;",
          "8438:     }",
          "8441:     if ((num_read =",
          "8442:              (int)fread(buf, 1, (size_t)to_read, filep->access.fp))",
          "8443:         <= 0) {",
          "8444:      break;",
          "8445:     }",
          "8448:     if ((num_written = mg_write(conn, buf, (size_t)num_read))",
          "8449:         != num_read) {",
          "8450:      break;",
          "8454:     len -= num_written;",
          "8458: }",
          "8461: static int",
          "8462: parse_range_header(const char *header, int64_t *a, int64_t *b)",
          "8463: {",
          "8464:  return sscanf(header, \"bytes=%\" INT64_FMT \"-%\" INT64_FMT, a, b);",
          "8465: }",
          "8468: static void",
          "8469: construct_etag(char *buf, size_t buf_len, const struct mg_file_stat *filestat)",
          "8470: {",
          "8471:  if ((filestat != NULL) && (buf != NULL)) {",
          "8472:   mg_snprintf(NULL,",
          "8474:               buf,",
          "8475:               buf_len,",
          "8476:               \"\\\"%lx.%\" INT64_FMT \"\\\"\",",
          "8477:               (unsigned long)filestat->last_modified,",
          "8478:               filestat->size);",
          "8480: }",
          "8483: static void",
          "8484: fclose_on_exec(struct mg_file_access *filep, struct mg_connection *conn)",
          "8485: {",
          "8486:  if (filep != NULL && filep->fp != NULL) {",
          "",
          "---------------",
          "--- Hunk 44 ---",
          "[Context before]",
          "8446:           strerror(ERRNO));",
          "8447:   }",
          "8448: #endif",
          "8450:  }",
          "8512:    mg_send_http_error(conn,",
          "8513:                       500,",
          "8517:    return;",
          "8518:   }",
          "8613:   }",
          "8619:  }",
          "8622: #if !defined(NO_CACHING)",
          "8654:  }",
          "8655: #endif",
          "8692:    } else {",
          "8695:    }",
          "8696:   } else {",
          "8698:   }",
          "8699:  }",
          "8739:   }",
          "8742:  }",
          "8799:    remove_bad_file(conn, path);",
          "8801:   }",
          "8804:  }",
          "8844:   }",
          "8848:  }",
          "8904:   }",
          "8906:  }",
          "8991:   }",
          "8997:   }",
          "9001:    return -1;",
          "9002:   }",
          "9009:   }",
          "9014:   }",
          "9021:   }",
          "9046:  }",
          "9159:  }",
          "9237:  }",
          "9271:   }",
          "9274:   }",
          "9281:   }",
          "9297:   } else {",
          "9303:    }",
          "9324:    }",
          "9336:      break;",
          "9337:     }",
          "9349:    }",
          "9358:   }",
          "9361:  }",
          "9362: #endif",
          "9364: #if !defined(NO_CGI)",
          "9438:    }",
          "9458:  }",
          "9507: #if defined(USE_IPV6)",
          "9513: #endif",
          "9543:   } else {",
          "9549:   }",
          "9584: #if defined(_WIN32)",
          "9600: #else",
          "9601:  if ((s = getenv(\"LD_LIBRARY_PATH\")) != NULL) {",
          "9602:   addenv(env, \"LD_LIBRARY_PATH=%s\", s);",
          "9603:  }",
          "9645:   }",
          "9651:   }",
          "9657:  }",
          "9755:    mg_cry(conn,",
          "9763:    goto done;",
          "9764:   }",
          "9768:    mg_cry(conn,",
          "9770:           prog,",
          "9772:    mg_send_http_error(conn,",
          "9773:                       500,",
          "9781:    mg_cry(conn,",
          "9785:    mg_send_http_error(conn,",
          "9786:                       500,",
          "9924: #if !defined(_WIN32)",
          "9937:   }",
          "9960:  }",
          "9964: #if !defined(NO_FILES)",
          "10034:   }",
          "10035:  }",
          "10088:   } else {",
          "10169:   }",
          "10171:   gmt_time_string(date, sizeof(date), &curtime);",
          "10172:   mg_printf(conn,",
          "10173:             \"HTTP/1.1 %d %s\\r\\n\",",
          "",
          "[Removed Lines]",
          "8449:   }",
          "8453:  static void handle_static_file_request(struct mg_connection * conn,",
          "8454:                                         const char *path,",
          "8455:                                         struct mg_file *filep,",
          "8456:                                         const char *mime_type,",
          "8457:                                         const char *additional_headers)",
          "8458:  {",
          "8459:   char date[64], lm[64], etag[64];",
          "8461:   const char *msg = \"OK\", *hdr;",
          "8462:   time_t curtime = time(NULL);",
          "8463:   int64_t cl, r1, r2;",
          "8464:   struct vec mime_vec;",
          "8465:   int n, truncated;",
          "8466:   char gz_path[PATH_MAX];",
          "8467:   const char *encoding = \"\";",
          "8468:   const char *cors1, *cors2, *cors3;",
          "8470:   if ((conn == NULL) || (conn->ctx == NULL) || (filep == NULL)) {",
          "8471:    return;",
          "8472:   }",
          "8474:   if (mime_type == NULL) {",
          "8475:    get_mime_type(conn->ctx, path, &mime_vec);",
          "8476:   } else {",
          "8477:    mime_vec.ptr = mime_type;",
          "8478:    mime_vec.len = strlen(mime_type);",
          "8479:   }",
          "8480:   if (filep->stat.size > INT64_MAX) {",
          "8481:    mg_send_http_error(",
          "8482:        conn,",
          "8483:        500,",
          "8484:        \"Error: File size is too large to send\\n%\" INT64_FMT,",
          "8485:        filep->stat.size);",
          "8486:    return;",
          "8487:   }",
          "8488:   cl = (int64_t)filep->stat.size;",
          "8489:   conn->status_code = 200;",
          "8490:   range[0] = '\\0';",
          "8495:   if (filep->stat.is_gzipped) {",
          "8496:    mg_snprintf(",
          "8497:        conn, &truncated, gz_path, sizeof(gz_path), \"%s.gz\", path);",
          "8499:    if (truncated) {",
          "8500:     mg_send_http_error(conn,",
          "8501:                        500,",
          "8502:                        \"Error: Path of zipped file too long (%s)\",",
          "8503:                        path);",
          "8504:     return;",
          "8505:    }",
          "8507:    path = gz_path;",
          "8508:    encoding = \"Content-Encoding: gzip\\r\\n\";",
          "8509:   }",
          "8511:   if (!mg_fopen(conn, path, MG_FOPEN_MODE_READ, filep)) {",
          "8514:                       \"Error: Cannot open file\\nfopen(%s): %s\",",
          "8515:                       path,",
          "8516:                       strerror(ERRNO));",
          "8520:   fclose_on_exec(&filep->access, conn);",
          "8523:   r1 = r2 = 0;",
          "8524:   hdr = mg_get_header(conn, \"Range\");",
          "8525:   if ((hdr != NULL) && ((n = parse_range_header(hdr, &r1, &r2)) > 0)",
          "8526:       && (r1 >= 0) && (r2 >= 0)) {",
          "8529:    if (filep->stat.is_gzipped) {",
          "8530:     mg_send_http_error(",
          "8531:         conn,",
          "8533:         \"%s\",",
          "8534:         \"Error: Range requests in gzipped files are not supported\");",
          "8535:     (void)mg_fclose(",
          "8537:     return;",
          "8538:    }",
          "8539:    conn->status_code = 206;",
          "8540:    cl = (n == 2) ? (((r2 > cl) ? cl : r2) - r1 + 1) : (cl - r1);",
          "8541:    mg_snprintf(conn,",
          "8543:                range,",
          "8544:                sizeof(range),",
          "8545:                \"Content-Range: bytes \"",
          "8546:                \"%\" INT64_FMT \"-%\" INT64_FMT \"/%\" INT64_FMT \"\\r\\n\",",
          "8547:                r1,",
          "8548:                r1 + cl - 1,",
          "8549:                filep->stat.size);",
          "8550:    msg = \"Partial Content\";",
          "8551:   }",
          "8553:   hdr = mg_get_header(conn, \"Origin\");",
          "8554:   if (hdr) {",
          "8560:    cors1 = \"Access-Control-Allow-Origin: \";",
          "8561:    cors2 = conn->ctx->config[ACCESS_CONTROL_ALLOW_ORIGIN];",
          "8562:    cors3 = \"\\r\\n\";",
          "8563:   } else {",
          "8564:    cors1 = cors2 = cors3 = \"\";",
          "8565:   }",
          "8570:   gmt_time_string(date, sizeof(date), &curtime);",
          "8571:   gmt_time_string(lm, sizeof(lm), &filep->stat.last_modified);",
          "8572:   construct_etag(etag, sizeof(etag), &filep->stat);",
          "8574:   (void)mg_printf(conn,",
          "8575:                   \"HTTP/1.1 %d %s\\r\\n\"",
          "8576:                   \"%s%s%s\"",
          "8577:                   \"Date: %s\\r\\n\",",
          "8578:                   conn->status_code,",
          "8579:                   msg,",
          "8580:                   cors1,",
          "8581:                   cors2,",
          "8582:                   cors3,",
          "8583:                   date);",
          "8584:   send_static_cache_header(conn);",
          "8585:   send_additional_header(conn);",
          "8586:   (void)mg_printf(conn,",
          "8587:                   \"Last-Modified: %s\\r\\n\"",
          "8588:                   \"Etag: %s\\r\\n\"",
          "8589:                   \"Content-Type: %.*s\\r\\n\"",
          "8590:                   \"Content-Length: %\" INT64_FMT \"\\r\\n\"",
          "8591:                   \"Connection: %s\\r\\n\"",
          "8592:                   \"Accept-Ranges: bytes\\r\\n\"",
          "8593:                   \"%s%s\",",
          "8594:                   lm,",
          "8595:                   etag,",
          "8596:                   (int)mime_vec.len,",
          "8597:                   mime_vec.ptr,",
          "8598:                   cl,",
          "8599:                   suggest_connection_header(conn),",
          "8600:                   range,",
          "8601:                   encoding);",
          "8606:   if (additional_headers != NULL) {",
          "8607:    (void)mg_printf(conn,",
          "8608:                    \"%.*s\\r\\n\\r\\n\",",
          "8609:                    (int)strlen(additional_headers),",
          "8610:                    additional_headers);",
          "8611:   } else {",
          "8612:    (void)mg_printf(conn, \"\\r\\n\");",
          "8615:   if (strcmp(conn->request_info.request_method, \"HEAD\") != 0) {",
          "8616:    send_file_data(conn, filep, r1, cl);",
          "8617:   }",
          "8623:  static void handle_not_modified_static_file_request(struct mg_connection",
          "8625:                                                      struct mg_file * filep)",
          "8626:  {",
          "8627:   char date[64], lm[64], etag[64];",
          "8628:   time_t curtime = time(NULL);",
          "8630:   if ((conn == NULL) || (filep == NULL)) {",
          "8631:    return;",
          "8632:   }",
          "8633:   conn->status_code = 304;",
          "8634:   gmt_time_string(date, sizeof(date), &curtime);",
          "8635:   gmt_time_string(lm, sizeof(lm), &filep->stat.last_modified);",
          "8636:   construct_etag(etag, sizeof(etag), &filep->stat);",
          "8638:   (void)mg_printf(conn,",
          "8639:                   \"HTTP/1.1 %d %s\\r\\n\"",
          "8640:                   \"Date: %s\\r\\n\",",
          "8641:                   conn->status_code,",
          "8642:                   mg_get_response_code_text(conn, conn->status_code),",
          "8643:                   date);",
          "8644:   send_static_cache_header(conn);",
          "8645:   send_additional_header(conn);",
          "8646:   (void)mg_printf(conn,",
          "8647:                   \"Last-Modified: %s\\r\\n\"",
          "8648:                   \"Etag: %s\\r\\n\"",
          "8649:                   \"Connection: %s\\r\\n\"",
          "8650:                   \"\\r\\n\",",
          "8651:                   lm,",
          "8652:                   etag,",
          "8653:                   suggest_connection_header(conn));",
          "8658:  void mg_send_file(struct mg_connection * conn, const char *path)",
          "8659:  {",
          "8660:   mg_send_mime_file(conn, path, NULL);",
          "8661:  }",
          "8664:  void mg_send_mime_file(struct mg_connection * conn,",
          "8665:                         const char *path,",
          "8666:                         const char *mime_type)",
          "8667:  {",
          "8668:   mg_send_mime_file2(conn, path, mime_type, NULL);",
          "8669:  }",
          "8672:  void mg_send_mime_file2(struct mg_connection * conn,",
          "8673:                          const char *path,",
          "8674:                          const char *mime_type,",
          "8675:                          const char *additional_headers)",
          "8676:  {",
          "8677:   struct mg_file file = STRUCT_FILE_INITIALIZER;",
          "8678:   if (mg_stat(conn, path, &file.stat)) {",
          "8679:    if (file.stat.is_directory) {",
          "8680:     if (!conn) {",
          "8681:      return;",
          "8682:     }",
          "8683:     if (!mg_strcasecmp(conn->ctx->config[ENABLE_DIRECTORY_LISTING],",
          "8684:                        \"yes\")) {",
          "8685:      handle_directory_request(conn, path);",
          "8686:     } else {",
          "8687:      mg_send_http_error(conn,",
          "8688:                         403,",
          "8689:                         \"%s\",",
          "8690:                         \"Error: Directory listing denied\");",
          "8691:     }",
          "8693:     handle_static_file_request(",
          "8694:         conn, path, &file, mime_type, additional_headers);",
          "8697:    mg_send_http_error(conn, 404, \"%s\", \"Error: File not found\");",
          "8708:  static int put_dir(struct mg_connection * conn, const char *path)",
          "8709:  {",
          "8710:   char buf[PATH_MAX];",
          "8711:   const char *s, *p;",
          "8712:   struct mg_file file = STRUCT_FILE_INITIALIZER;",
          "8713:   size_t len;",
          "8714:   int res = 1;",
          "8716:   for (s = p = path + 2; (p = strchr(s, '/')) != NULL; s = ++p) {",
          "8717:    len = (size_t)(p - path);",
          "8718:    if (len >= sizeof(buf)) {",
          "8720:     res = -1;",
          "8721:     break;",
          "8722:    }",
          "8723:    memcpy(buf, path, len);",
          "8724:    buf[len] = '\\0';",
          "8727:    DEBUG_TRACE(\"mkdir(%s)\", buf);",
          "8728:    if (!mg_stat(conn, buf, &file.stat)",
          "8729:        && mg_mkdir(conn, buf, 0755) != 0) {",
          "8731:     res = -2;",
          "8732:     break;",
          "8733:    }",
          "8736:    if (p[1] == '\\0') {",
          "8737:     res = 0;",
          "8738:    }",
          "8741:   return res;",
          "8745:  static void remove_bad_file(const struct mg_connection *conn,",
          "8746:                              const char *path)",
          "8747:  {",
          "8748:   int r = mg_remove(conn, path);",
          "8749:   if (r != 0) {",
          "8750:    mg_cry(conn, \"%s: Cannot remove invalid file %s\", __func__, path);",
          "8751:   }",
          "8752:  }",
          "8755:  long long mg_store_body(struct mg_connection * conn, const char *path)",
          "8756:  {",
          "8757:   char buf[MG_BUF_LEN];",
          "8758:   long long len = 0;",
          "8759:   int ret, n;",
          "8760:   struct mg_file fi;",
          "8762:   if (conn->consumed_content != 0) {",
          "8763:    mg_cry(conn, \"%s: Contents already consumed\", __func__);",
          "8764:    return -11;",
          "8765:   }",
          "8767:   ret = put_dir(conn, path);",
          "8768:   if (ret < 0) {",
          "8771:    return ret;",
          "8772:   }",
          "8773:   if (ret != 1) {",
          "8775:    return 0;",
          "8776:   }",
          "8778:   if (mg_fopen(conn, path, MG_FOPEN_MODE_WRITE, &fi) == 0) {",
          "8779:    return -12;",
          "8780:   }",
          "8782:   ret = mg_read(conn, buf, sizeof(buf));",
          "8783:   while (ret > 0) {",
          "8784:    n = (int)fwrite(buf, 1, (size_t)ret, fi.access.fp);",
          "8785:    if (n != ret) {",
          "8786:     (void)mg_fclose(",
          "8788:     remove_bad_file(conn, path);",
          "8789:     return -13;",
          "8790:    }",
          "8791:    len += ret;",
          "8792:    ret = mg_read(conn, buf, sizeof(buf));",
          "8793:   }",
          "8798:   if (mg_fclose(&fi.access) != 0) {",
          "8800:    return -14;",
          "8803:   return len;",
          "8811:  static int skip_to_end_of_word_and_terminate(char **ppw, int eol)",
          "8812:  {",
          "8815:   while (isgraph(**ppw)) {",
          "8816:    (*ppw)++;",
          "8817:   }",
          "8820:   if (eol) {",
          "8822:    if ((**ppw != '\\r') && (**ppw != '\\n')) {",
          "8823:     return -1;",
          "8824:    }",
          "8825:   } else {",
          "8827:    if (**ppw != ' ') {",
          "8828:     return -1;",
          "8829:    }",
          "8830:   }",
          "8833:   do {",
          "8835:    (*ppw)++;",
          "8836:   } while ((**ppw) && isspace(**ppw));",
          "8839:   if (!eol) {",
          "8841:    if (!isgraph(**ppw)) {",
          "8842:     return -1;",
          "8843:    }",
          "8847:   return 1;",
          "8855:  static int parse_http_headers(char **buf,",
          "8856:                                struct mg_header hdr[MG_MAX_HEADERS])",
          "8857:  {",
          "8858:   int i;",
          "8859:   int num_headers = 0;",
          "8861:   for (i = 0; i < (int)MG_MAX_HEADERS; i++) {",
          "8862:    char *dp = *buf;",
          "8863:    while ((*dp != ':') && (*dp >= 33) && (*dp <= 126)) {",
          "8864:     dp++;",
          "8865:    }",
          "8866:    if (dp == *buf) {",
          "8868:     break;",
          "8869:    }",
          "8870:    if (*dp != ':') {",
          "8872:     return -1;",
          "8873:    }",
          "8878:    hdr[i].name = *buf;",
          "8879:    do {",
          "8880:     dp++;",
          "8881:    } while (*dp == ' ');",
          "8884:    hdr[i].value = dp;",
          "8886:    if (((*buf)[0] != '\\r') || ((*buf)[1] != '\\n')) {",
          "8888:    }",
          "8890:    num_headers = i + 1;",
          "8891:    if (*buf) {",
          "8892:     (*buf)[0] = 0;",
          "8893:     (*buf)[1] = 0;",
          "8895:    } else {",
          "8897:     break;",
          "8898:    }",
          "8900:    if ((*buf)[0] == '\\r') {",
          "8902:     break;",
          "8903:    }",
          "8905:   return num_headers;",
          "8909:  static int is_valid_http_method(const char *method)",
          "8910:  {",
          "8948:       ;",
          "8949:  }",
          "8961:  static int parse_http_request(char *buf,",
          "8962:                                int len,",
          "8963:                                struct mg_request_info *ri)",
          "8964:  {",
          "8965:   int request_length;",
          "8966:   int init_skip = 0;",
          "8970:   ri->remote_user = ri->request_method = ri->request_uri =",
          "8971:       ri->http_version = NULL;",
          "8972:   ri->num_headers = 0;",
          "8977:   while ((len > 0) && isspace(*(unsigned char *)buf)) {",
          "8978:    buf++;",
          "8979:    len--;",
          "8980:    init_skip++;",
          "8981:   }",
          "8983:   if (len == 0) {",
          "8985:    return 0;",
          "8986:   }",
          "8989:   if (iscntrl(*(unsigned char *)buf)) {",
          "8990:    return -1;",
          "8994:   request_length = get_http_header_len(buf, len);",
          "8995:   if (request_length <= 0) {",
          "8996:    return request_length;",
          "8998:   buf[request_length - 1] = '\\0';",
          "9000:   if ((*buf == 0) || (*buf == '\\r') || (*buf == '\\n')) {",
          "9005:   ri->request_method = buf;",
          "9007:   if (skip_to_end_of_word_and_terminate(&buf, 0) <= 0) {",
          "9008:    return -1;",
          "9012:   if (!is_valid_http_method(ri->request_method)) {",
          "9013:    return -1;",
          "9017:   ri->request_uri = buf;",
          "9019:   if (skip_to_end_of_word_and_terminate(&buf, 0) <= 0) {",
          "9020:    return -1;",
          "9024:   ri->http_version = buf;",
          "9026:   if (skip_to_end_of_word_and_terminate(&buf, 1) <= 0) {",
          "9027:    return -1;",
          "9028:   }",
          "9031:   if (strncmp(ri->http_version, \"HTTP/\", 5) != 0) {",
          "9033:    return -1;",
          "9034:   }",
          "9035:   ri->http_version += 5;",
          "9039:   ri->num_headers = parse_http_headers(&buf, ri->http_headers);",
          "9040:   if (ri->num_headers < 0) {",
          "9042:    return -1;",
          "9043:   }",
          "9045:   return request_length + init_skip;",
          "9049:  static int parse_http_response(char *buf,",
          "9050:                                 int len,",
          "9051:                                 struct mg_response_info *ri)",
          "9052:  {",
          "9053:   int response_length;",
          "9054:   int init_skip = 0;",
          "9055:   char *tmp, *tmp2;",
          "9056:   long l;",
          "9059:   ri->http_version = ri->status_text = NULL;",
          "9060:   ri->num_headers = ri->status_code = 0;",
          "9065:   while ((len > 0) && isspace(*(unsigned char *)buf)) {",
          "9066:    buf++;",
          "9067:    len--;",
          "9068:    init_skip++;",
          "9069:   }",
          "9071:   if (len == 0) {",
          "9073:    return 0;",
          "9074:   }",
          "9077:   if (iscntrl(*(unsigned char *)buf)) {",
          "9078:    return -1;",
          "9079:   }",
          "9082:   response_length = get_http_header_len(buf, len);",
          "9083:   if (response_length <= 0) {",
          "9084:    return response_length;",
          "9085:   }",
          "9086:   buf[response_length - 1] = '\\0';",
          "9090:   (void)buf;",
          "9091:   (void)len;",
          "9092:   (void)ri;",
          "9095:   while ((*buf != '\\0') && isspace(*(unsigned char *)buf)) {",
          "9096:    buf++;",
          "9097:   }",
          "9098:   if ((*buf == 0) || (*buf == '\\r') || (*buf == '\\n')) {",
          "9099:    return -1;",
          "9100:   }",
          "9104:   if (strncmp(buf, \"HTTP/\", 5) != 0) {",
          "9106:    return -1;",
          "9107:   }",
          "9108:   buf += 5;",
          "9109:   if (!isgraph(buf[0])) {",
          "9111:    return -1;",
          "9112:   }",
          "9113:   ri->http_version = buf;",
          "9115:   if (skip_to_end_of_word_and_terminate(&buf, 0) <= 0) {",
          "9116:    return -1;",
          "9117:   }",
          "9120:   tmp = buf;",
          "9122:   if (skip_to_end_of_word_and_terminate(&buf, 0) <= 0) {",
          "9123:    return -1;",
          "9124:   }",
          "9126:   l = strtol(tmp, &tmp2, 10);",
          "9127:   if ((l < 100) || (l >= 1000) || ((tmp2 - tmp) != 3) || (*tmp2 != 0)) {",
          "9129:    return -1;",
          "9130:   }",
          "9131:   ri->status_code = (int)l;",
          "9134:   ri->status_text = buf;",
          "9138:   while (isprint(*buf)) {",
          "9139:    buf++;",
          "9140:   }",
          "9141:   if ((*buf != '\\r') && (*buf != '\\n')) {",
          "9142:    return -1;",
          "9143:   }",
          "9145:   do {",
          "9147:    buf++;",
          "9148:   } while ((*buf) && isspace(*buf));",
          "9152:   ri->num_headers = parse_http_headers(&buf, ri->http_headers);",
          "9153:   if (ri->num_headers < 0) {",
          "9155:    return -1;",
          "9156:   }",
          "9158:   return response_length + init_skip;",
          "9167:  static int read_message(FILE * fp,",
          "9168:                          struct mg_connection * conn,",
          "9169:                          char *buf,",
          "9170:                          int bufsiz,",
          "9171:                          int *nread)",
          "9172:  {",
          "9173:   int request_len, n = 0;",
          "9174:   struct timespec last_action_time;",
          "9175:   double request_timeout;",
          "9177:   if (!conn) {",
          "9178:    return 0;",
          "9179:   }",
          "9181:   memset(&last_action_time, 0, sizeof(last_action_time));",
          "9183:   if (conn->ctx->config[REQUEST_TIMEOUT]) {",
          "9185:    request_timeout = atof(conn->ctx->config[REQUEST_TIMEOUT]) / 1000.0;",
          "9186:   } else {",
          "9187:    request_timeout = -1.0;",
          "9188:   }",
          "9189:   if (conn->handled_requests > 0) {",
          "9190:    if (conn->ctx->config[KEEP_ALIVE_TIMEOUT]) {",
          "9191:     request_timeout =",
          "9192:         atof(conn->ctx->config[KEEP_ALIVE_TIMEOUT]) / 1000.0;",
          "9193:    }",
          "9194:   }",
          "9196:   request_len = get_http_header_len(buf, *nread);",
          "9199:   clock_gettime(CLOCK_MONOTONIC, &last_action_time);",
          "9201:   while (request_len == 0) {",
          "9203:    if (conn->ctx->stop_flag != 0) {",
          "9205:     return -1;",
          "9206:    }",
          "9208:    if (*nread >= bufsiz) {",
          "9210:     return -2;",
          "9211:    }",
          "9213:    n = pull_inner(",
          "9214:        fp, conn, buf + *nread, bufsiz - *nread, request_timeout);",
          "9215:    if (n == -2) {",
          "9217:     return -1;",
          "9218:    }",
          "9219:    if (n > 0) {",
          "9221:     request_len = get_http_header_len(buf, *nread);",
          "9222:    } else {",
          "9223:     request_len = 0;",
          "9224:    }",
          "9226:    if ((request_len == 0) && (request_timeout >= 0)) {",
          "9227:     if (mg_difftimespec(&last_action_time, &(conn->req_time))",
          "9228:         > request_timeout) {",
          "9230:      return -1;",
          "9231:     }",
          "9232:     clock_gettime(CLOCK_MONOTONIC, &last_action_time);",
          "9233:    }",
          "9234:   }",
          "9236:   return request_len;",
          "9240: #if !defined(NO_CACHING)",
          "9242:  static int is_not_modified(const struct mg_connection *conn,",
          "9243:                             const struct mg_file_stat *filestat)",
          "9244:  {",
          "9245:   char etag[64];",
          "9246:   const char *ims = mg_get_header(conn, \"If-Modified-Since\");",
          "9247:   const char *inm = mg_get_header(conn, \"If-None-Match\");",
          "9248:   construct_etag(etag, sizeof(etag), filestat);",
          "9250:   return ((inm != NULL) && !mg_strcasecmp(etag, inm))",
          "9251:          || ((ims != NULL)",
          "9252:              && (filestat->last_modified <= parse_date_string(ims)));",
          "9253:  }",
          "9257: #if !defined(NO_CGI) || !defined(NO_FILES)",
          "9258:  static int forward_body_data(struct mg_connection * conn,",
          "9259:                               FILE * fp,",
          "9260:                               SOCKET sock,",
          "9261:                               SSL * ssl)",
          "9262:  {",
          "9263:   const char *expect, *body;",
          "9264:   char buf[MG_BUF_LEN];",
          "9265:   int to_read, nread, success = 0;",
          "9266:   int64_t buffered_len;",
          "9267:   double timeout = -1.0;",
          "9269:   if (!conn) {",
          "9270:    return 0;",
          "9272:   if (conn->ctx->config[REQUEST_TIMEOUT]) {",
          "9273:    timeout = atoi(conn->ctx->config[REQUEST_TIMEOUT]) / 1000.0;",
          "9276:   expect = mg_get_header(conn, \"Expect\");",
          "9278:   if (!fp) {",
          "9279:    mg_send_http_error(conn, 500, \"%s\", \"Error: NULL File\");",
          "9280:    return 0;",
          "9283:   if ((conn->content_len == -1) && !conn->is_chunked) {",
          "9285:    mg_send_http_error(conn,",
          "9286:                       411,",
          "9287:                       \"%s\",",
          "9288:                       \"Error: Client did not specify content length\");",
          "9289:   } else if ((expect != NULL)",
          "9290:              && (mg_strcasecmp(expect, \"100-continue\") != 0)) {",
          "9293:    mg_send_http_error(conn,",
          "9294:                       417,",
          "9295:                       \"Error: Can not fulfill expectation %s\",",
          "9296:                       expect);",
          "9298:    if (expect != NULL) {",
          "9299:     (void)mg_printf(conn, \"%s\", \"HTTP/1.1 100 Continue\\r\\n\\r\\n\");",
          "9300:     conn->status_code = 100;",
          "9301:    } else {",
          "9302:     conn->status_code = 200;",
          "9305:    buffered_len = (int64_t)(conn->data_len)",
          "9306:                   - (int64_t)conn->request_len",
          "9307:                   - conn->consumed_content;",
          "9312:    if ((buffered_len < 0) || (conn->consumed_content != 0)) {",
          "9313:     mg_send_http_error(conn, 500, \"%s\", \"Error: Size mismatch\");",
          "9314:     return 0;",
          "9315:    }",
          "9317:    if (buffered_len > 0) {",
          "9318:     if ((int64_t)buffered_len > conn->content_len) {",
          "9319:      buffered_len = (int)conn->content_len;",
          "9320:     }",
          "9321:     body = conn->buf + conn->request_len + conn->consumed_content;",
          "9322:     push_all(conn->ctx, fp, sock, ssl, body, (int64_t)buffered_len);",
          "9323:     conn->consumed_content += buffered_len;",
          "9326:    nread = 0;",
          "9327:    while (conn->consumed_content < conn->content_len) {",
          "9328:     to_read = sizeof(buf);",
          "9329:     if ((int64_t)to_read > conn->content_len",
          "9330:                                - conn->consumed_content) {",
          "9331:      to_read = (int)(conn->content_len - conn->consumed_content);",
          "9332:     }",
          "9333:     nread = pull_inner(NULL, conn, buf, to_read, timeout);",
          "9334:     if (nread == -2) {",
          "9338:     if (nread > 0) {",
          "9339:      if (push_all(conn->ctx, fp, sock, ssl, buf, nread)",
          "9340:          != nread) {",
          "9341:       break;",
          "9342:      }",
          "9343:     }",
          "9344:     conn->consumed_content += nread;",
          "9345:    }",
          "9347:    if (conn->consumed_content == conn->content_len) {",
          "9348:     success = (nread >= 0);",
          "9352:    if (!success) {",
          "9356:     mg_send_http_error(conn, 500, \"%s\", \"\");",
          "9357:    }",
          "9360:   return success;",
          "9375:  struct cgi_environment {",
          "9376:   struct mg_connection *conn;",
          "9385:  };",
          "9388:  static void addenv(struct cgi_environment * env,",
          "9389:                     PRINTF_FORMAT_STRING(const char *fmt),",
          "9390:                     ...) PRINTF_ARGS(2, 3);",
          "9394:  static void addenv(struct cgi_environment * env, const char *fmt, ...)",
          "9395:  {",
          "9396:   size_t n, space;",
          "9397:   int truncated = 0;",
          "9398:   char *added;",
          "9399:   va_list ap;",
          "9402:   space = (env->buflen - env->bufused);",
          "9405:   n = strlen(fmt) + 2 + 128;",
          "9407:   do {",
          "9408:    if (space <= n) {",
          "9410:     n = env->buflen + CGI_ENVIRONMENT_SIZE;",
          "9411:     added = (char *)mg_realloc_ctx(env->buf, n, env->conn->ctx);",
          "9412:     if (!added) {",
          "9414:      mg_cry(env->conn,",
          "9415:             \"%s: Cannot allocate memory for CGI variable [%s]\",",
          "9416:             __func__,",
          "9417:             fmt);",
          "9418:      return;",
          "9419:     }",
          "9420:     env->buf = added;",
          "9421:     env->buflen = n;",
          "9422:     space = (env->buflen - env->bufused);",
          "9423:    }",
          "9426:    added = env->buf + env->bufused;",
          "9429:    va_start(ap, fmt);",
          "9430:    mg_vsnprintf(env->conn, &truncated, added, (size_t)space, fmt, ap);",
          "9431:    va_end(ap);",
          "9434:    if (truncated) {",
          "9436:     space = 0;",
          "9437:     n = 1;",
          "9439:   } while (truncated);",
          "9442:   n = strlen(added) + 1;",
          "9443:   env->bufused += n;",
          "9446:   space = (env->varlen - env->varused);",
          "9447:   if (space < 2) {",
          "9448:    mg_cry(env->conn,",
          "9449:           \"%s: Cannot register CGI variable [%s]\",",
          "9450:           __func__,",
          "9451:           fmt);",
          "9452:    return;",
          "9453:   }",
          "9456:   env->var[env->varused] = added;",
          "9457:   env->varused++;",
          "9462:  static int prepare_cgi_environment(struct mg_connection * conn,",
          "9463:                                     const char *prog,",
          "9464:                                     struct cgi_environment *env)",
          "9465:  {",
          "9466:   const char *s;",
          "9467:   struct vec var_vec;",
          "9468:   char *p, src_addr[IP_ADDR_STR_LEN], http_var_name[128];",
          "9469:   int i, truncated, uri_len;",
          "9471:   if ((conn == NULL) || (prog == NULL) || (env == NULL)) {",
          "9472:    return -1;",
          "9473:   }",
          "9475:   env->conn = conn;",
          "9476:   env->buflen = CGI_ENVIRONMENT_SIZE;",
          "9477:   env->bufused = 0;",
          "9478:   env->buf = (char *)mg_malloc_ctx(env->buflen, conn->ctx);",
          "9479:   if (env->buf == NULL) {",
          "9480:    mg_cry(conn,",
          "9481:           \"%s: Not enough memory for environmental buffer\",",
          "9482:           __func__);",
          "9483:    return -1;",
          "9484:   }",
          "9485:   env->varlen = MAX_CGI_ENVIR_VARS;",
          "9486:   env->varused = 0;",
          "9487:   env->var =",
          "9488:       (char **)mg_malloc_ctx(env->buflen * sizeof(char *), conn->ctx);",
          "9489:   if (env->var == NULL) {",
          "9490:    mg_cry(conn,",
          "9491:           \"%s: Not enough memory for environmental variables\",",
          "9492:           __func__);",
          "9493:    mg_free(env->buf);",
          "9494:    return -1;",
          "9495:   }",
          "9497:   addenv(env, \"SERVER_NAME=%s\", conn->ctx->config[AUTHENTICATION_DOMAIN]);",
          "9498:   addenv(env, \"SERVER_ROOT=%s\", conn->ctx->config[DOCUMENT_ROOT]);",
          "9499:   addenv(env, \"DOCUMENT_ROOT=%s\", conn->ctx->config[DOCUMENT_ROOT]);",
          "9500:   addenv(env, \"SERVER_SOFTWARE=%s/%s\", \"Civetweb\", mg_version());",
          "9503:   addenv(env, \"%s\", \"GATEWAY_INTERFACE=CGI/1.1\");",
          "9504:   addenv(env, \"%s\", \"SERVER_PROTOCOL=HTTP/1.1\");",
          "9508:   if (conn->client.lsa.sa.sa_family == AF_INET6) {",
          "9509:    addenv(env,",
          "9510:           \"SERVER_PORT=%d\",",
          "9511:           ntohs(conn->client.lsa.sin6.sin6_port));",
          "9512:   } else",
          "9514:   {",
          "9515:    addenv(env, \"SERVER_PORT=%d\", ntohs(conn->client.lsa.sin.sin_port));",
          "9516:   }",
          "9518:   sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);",
          "9519:   addenv(env, \"REMOTE_ADDR=%s\", src_addr);",
          "9521:   addenv(env, \"REQUEST_METHOD=%s\", conn->request_info.request_method);",
          "9522:   addenv(env, \"REMOTE_PORT=%d\", conn->request_info.remote_port);",
          "9524:   addenv(env, \"REQUEST_URI=%s\", conn->request_info.request_uri);",
          "9525:   addenv(env, \"LOCAL_URI=%s\", conn->request_info.local_uri);",
          "9528:   uri_len = (int)strlen(conn->request_info.local_uri);",
          "9529:   if (conn->path_info == NULL) {",
          "9530:    if (conn->request_info.local_uri[uri_len - 1] != '/') {",
          "9532:     addenv(env, \"SCRIPT_NAME=%s\", conn->request_info.local_uri);",
          "9533:    } else {",
          "9535:     const char *index_file = strrchr(prog, '/');",
          "9536:     if (index_file) {",
          "9537:      addenv(env,",
          "9538:             \"SCRIPT_NAME=%s%s\",",
          "9539:             conn->request_info.local_uri,",
          "9540:             index_file + 1);",
          "9541:     }",
          "9542:    }",
          "9545:    addenv(env,",
          "9546:           \"SCRIPT_NAME=%.*s\",",
          "9547:           uri_len - (int)strlen(conn->path_info),",
          "9548:           conn->request_info.local_uri);",
          "9551:   addenv(env, \"SCRIPT_FILENAME=%s\", prog);",
          "9552:   if (conn->path_info == NULL) {",
          "9553:    addenv(env, \"PATH_TRANSLATED=%s\", conn->ctx->config[DOCUMENT_ROOT]);",
          "9554:   } else {",
          "9555:    addenv(env,",
          "9556:           \"PATH_TRANSLATED=%s%s\",",
          "9557:           conn->ctx->config[DOCUMENT_ROOT],",
          "9558:           conn->path_info);",
          "9559:   }",
          "9561:   addenv(env, \"HTTPS=%s\", (conn->ssl == NULL) ? \"off\" : \"on\");",
          "9563:   if ((s = mg_get_header(conn, \"Content-Type\")) != NULL) {",
          "9564:    addenv(env, \"CONTENT_TYPE=%s\", s);",
          "9565:   }",
          "9566:   if (conn->request_info.query_string != NULL) {",
          "9567:    addenv(env, \"QUERY_STRING=%s\", conn->request_info.query_string);",
          "9568:   }",
          "9569:   if ((s = mg_get_header(conn, \"Content-Length\")) != NULL) {",
          "9570:    addenv(env, \"CONTENT_LENGTH=%s\", s);",
          "9571:   }",
          "9572:   if ((s = getenv(\"PATH\")) != NULL) {",
          "9573:    addenv(env, \"PATH=%s\", s);",
          "9574:   }",
          "9575:   if (conn->path_info != NULL) {",
          "9576:    addenv(env, \"PATH_INFO=%s\", conn->path_info);",
          "9577:   }",
          "9579:   if (conn->status_code > 0) {",
          "9581:    addenv(env, \"STATUS=%d\", conn->status_code);",
          "9582:   }",
          "9585:   if ((s = getenv(\"COMSPEC\")) != NULL) {",
          "9586:    addenv(env, \"COMSPEC=%s\", s);",
          "9587:   }",
          "9588:   if ((s = getenv(\"SYSTEMROOT\")) != NULL) {",
          "9589:    addenv(env, \"SYSTEMROOT=%s\", s);",
          "9590:   }",
          "9591:   if ((s = getenv(\"SystemDrive\")) != NULL) {",
          "9592:    addenv(env, \"SystemDrive=%s\", s);",
          "9593:   }",
          "9594:   if ((s = getenv(\"ProgramFiles\")) != NULL) {",
          "9595:    addenv(env, \"ProgramFiles=%s\", s);",
          "9596:   }",
          "9597:   if ((s = getenv(\"ProgramFiles(x86)\")) != NULL) {",
          "9598:    addenv(env, \"ProgramFiles(x86)=%s\", s);",
          "9599:   }",
          "9606:   if ((s = getenv(\"PERLLIB\")) != NULL) {",
          "9607:    addenv(env, \"PERLLIB=%s\", s);",
          "9608:   }",
          "9610:   if (conn->request_info.remote_user != NULL) {",
          "9611:    addenv(env, \"REMOTE_USER=%s\", conn->request_info.remote_user);",
          "9612:    addenv(env, \"%s\", \"AUTH_TYPE=Digest\");",
          "9613:   }",
          "9616:   for (i = 0; i < conn->request_info.num_headers; i++) {",
          "9618:    (void)mg_snprintf(conn,",
          "9619:                      &truncated,",
          "9620:                      http_var_name,",
          "9621:                      sizeof(http_var_name),",
          "9622:                      \"HTTP_%s\",",
          "9623:                      conn->request_info.http_headers[i].name);",
          "9625:    if (truncated) {",
          "9626:     mg_cry(conn,",
          "9627:            \"%s: HTTP header variable too long [%s]\",",
          "9628:            __func__,",
          "9629:            conn->request_info.http_headers[i].name);",
          "9630:     continue;",
          "9631:    }",
          "9634:    for (p = http_var_name; *p != '\\0'; p++) {",
          "9635:     if (*p == '-') {",
          "9637:     }",
          "9639:    }",
          "9641:    addenv(env,",
          "9642:           \"%s=%s\",",
          "9643:           http_var_name,",
          "9644:           conn->request_info.http_headers[i].value);",
          "9648:   s = conn->ctx->config[CGI_ENVIRONMENT];",
          "9649:   while ((s = next_option(s, &var_vec, NULL)) != NULL) {",
          "9650:    addenv(env, \"%.*s\", (int)var_vec.len, var_vec.ptr);",
          "9653:   env->var[env->varused] = NULL;",
          "9654:   env->buf[env->bufused] = '\\0';",
          "9656:   return 0;",
          "9660:  static void handle_cgi_request(struct mg_connection * conn,",
          "9661:                                 const char *prog)",
          "9662:  {",
          "9663:   char *buf;",
          "9664:   size_t buflen;",
          "9665:   int headers_len, data_len, i, truncated;",
          "9666:   int fdin[2] = {-1, -1}, fdout[2] = {-1, -1}, fderr[2] = {-1, -1};",
          "9667:   const char *status, *status_text, *connection_state;",
          "9668:   char *pbuf, dir[PATH_MAX], *p;",
          "9669:   struct mg_request_info ri;",
          "9670:   struct cgi_environment blk;",
          "9671:   FILE *in = NULL, *out = NULL, *err = NULL;",
          "9672:   struct mg_file fout = STRUCT_FILE_INITIALIZER;",
          "9673:   pid_t pid = (pid_t)-1;",
          "9675:   if (conn == NULL) {",
          "9676:    return;",
          "9677:   }",
          "9679:   buf = NULL;",
          "9680:   buflen = 16384;",
          "9681:   i = prepare_cgi_environment(conn, prog, &blk);",
          "9682:   if (i != 0) {",
          "9683:    blk.buf = NULL;",
          "9684:    blk.var = NULL;",
          "9685:    goto done;",
          "9686:   }",
          "9691:   (void)mg_snprintf(conn, &truncated, dir, sizeof(dir), \"%s\", prog);",
          "9693:   if (truncated) {",
          "9694:    mg_cry(conn, \"Error: CGI program \\\"%s\\\": Path too long\", prog);",
          "9695:    mg_send_http_error(conn, 500, \"Error: %s\", \"CGI path too long\");",
          "9696:    goto done;",
          "9697:   }",
          "9699:   if ((p = strrchr(dir, '/')) != NULL) {",
          "9701:   } else {",
          "9702:    dir[0] = '.', dir[1] = '\\0';",
          "9703:    p = (char *)prog;",
          "9704:   }",
          "9706:   if ((pipe(fdin) != 0) || (pipe(fdout) != 0) || (pipe(fderr) != 0)) {",
          "9707:    status = strerror(ERRNO);",
          "9708:    mg_cry(conn,",
          "9709:           \"Error: CGI program \\\"%s\\\": Can not create CGI pipes: %s\",",
          "9710:           prog,",
          "9711:           status);",
          "9712:    mg_send_http_error(conn,",
          "9713:                       500,",
          "9714:                       \"Error: Cannot create CGI pipe: %s\",",
          "9715:                       status);",
          "9716:    goto done;",
          "9717:   }",
          "9719:   pid = spawn_process(conn, p, blk.buf, blk.var, fdin, fdout, fderr, dir);",
          "9721:   if (pid == (pid_t)-1) {",
          "9722:    status = strerror(ERRNO);",
          "9723:    mg_cry(conn,",
          "9724:           \"Error: CGI program \\\"%s\\\": Can not spawn CGI process: %s\",",
          "9725:           prog,",
          "9726:           status);",
          "9727:    mg_send_http_error(conn,",
          "9728:                       500,",
          "9729:                       \"Error: Cannot spawn CGI process [%s]: %s\",",
          "9730:                       prog,",
          "9731:                       status);",
          "9732:    goto done;",
          "9733:   }",
          "9748:   (void)close(fdin[0]);",
          "9749:   (void)close(fdout[1]);",
          "9750:   (void)close(fderr[1]);",
          "9751:   fdin[0] = fdout[1] = fderr[1] = -1;",
          "9753:   if ((in = fdopen(fdin[1], \"wb\")) == NULL) {",
          "9754:    status = strerror(ERRNO);",
          "9756:           \"Error: CGI program \\\"%s\\\": Can not open stdin: %s\",",
          "9757:           prog,",
          "9758:           status);",
          "9759:    mg_send_http_error(conn,",
          "9760:                       500,",
          "9761:                       \"Error: CGI can not open fdin\\nfopen: %s\",",
          "9762:                       status);",
          "9766:   if ((out = fdopen(fdout[0], \"rb\")) == NULL) {",
          "9767:    status = strerror(ERRNO);",
          "9769:           \"Error: CGI program \\\"%s\\\": Can not open stdout: %s\",",
          "9771:           status);",
          "9774:                       \"Error: CGI can not open fdout\\nfopen: %s\",",
          "9775:                       status);",
          "9776:    goto done;",
          "9777:   }",
          "9779:   if ((err = fdopen(fderr[0], \"rb\")) == NULL) {",
          "9780:    status = strerror(ERRNO);",
          "9782:           \"Error: CGI program \\\"%s\\\": Can not open stderr: %s\",",
          "9783:           prog,",
          "9784:           status);",
          "9787:                       \"Error: CGI can not open fdout\\nfopen: %s\",",
          "9788:                       status);",
          "9789:    goto done;",
          "9790:   }",
          "9792:   setbuf(in, NULL);",
          "9793:   setbuf(out, NULL);",
          "9794:   setbuf(err, NULL);",
          "9795:   fout.access.fp = out;",
          "9797:   if ((conn->request_info.content_length > 0) || conn->is_chunked) {",
          "9799:    if (!forward_body_data(conn, in, INVALID_SOCKET, NULL)) {",
          "9801:     mg_cry(conn,",
          "9802:            \"Error: CGI program \\\"%s\\\": Forward body data failed\",",
          "9803:            prog);",
          "9804:     goto done;",
          "9805:    }",
          "9806:   }",
          "9809:   fclose(in);",
          "9810:   in = NULL;",
          "9811:   fdin[1] = -1;",
          "9817:   data_len = 0;",
          "9818:   buf = (char *)mg_malloc_ctx(buflen, conn->ctx);",
          "9819:   if (buf == NULL) {",
          "9820:    mg_send_http_error(",
          "9821:        conn,",
          "9822:        500,",
          "9823:        \"Error: Not enough memory for CGI buffer (%u bytes)\",",
          "9824:        (unsigned int)buflen);",
          "9825:    mg_cry(",
          "9826:        conn,",
          "9827:        \"Error: CGI program \\\"%s\\\": Not enough memory for buffer (%u \"",
          "9828:        \"bytes)\",",
          "9829:        prog,",
          "9830:        (unsigned int)buflen);",
          "9831:    goto done;",
          "9832:   }",
          "9833:   headers_len = read_message(out, conn, buf, (int)buflen, &data_len);",
          "9834:   if (headers_len <= 0) {",
          "9838:    i = pull_all(err, conn, buf, (int)buflen);",
          "9839:    if (i > 0) {",
          "9840:     mg_cry(conn,",
          "9841:            \"Error: CGI program \\\"%s\\\" sent error \"",
          "9842:            \"message: [%.*s]\",",
          "9843:            prog,",
          "9844:            i,",
          "9845:            buf);",
          "9846:     mg_send_http_error(conn,",
          "9847:                        500,",
          "9848:                        \"Error: CGI program \\\"%s\\\" sent error \"",
          "9849:                        \"message: [%.*s]\",",
          "9850:                        prog,",
          "9851:                        i,",
          "9852:                        buf);",
          "9853:    } else {",
          "9854:     mg_cry(conn,",
          "9855:            \"Error: CGI program sent malformed or too big \"",
          "9856:            \"(>%u bytes) HTTP headers: [%.*s]\",",
          "9857:            (unsigned)buflen,",
          "9858:            data_len,",
          "9859:            buf);",
          "9861:     mg_send_http_error(",
          "9862:         conn,",
          "9863:         500,",
          "9864:         \"Error: CGI program sent malformed or too big \"",
          "9865:         \"(>%u bytes) HTTP headers: [%.*s]\",",
          "9866:         (unsigned)buflen,",
          "9867:         data_len,",
          "9868:         buf);",
          "9869:    }",
          "9871:    goto done;",
          "9872:   }",
          "9873:   pbuf = buf;",
          "9874:   buf[headers_len - 1] = '\\0';",
          "9875:   ri.num_headers = parse_http_headers(&pbuf, ri.http_headers);",
          "9878:   status_text = \"OK\";",
          "9879:   if ((status = get_header(ri.http_headers, ri.num_headers, \"Status\"))",
          "9880:       != NULL) {",
          "9881:    conn->status_code = atoi(status);",
          "9882:    status_text = status;",
          "9883:    while (isdigit(*(const unsigned char *)status_text)",
          "9884:           || *status_text == ' ') {",
          "9885:     status_text++;",
          "9886:    }",
          "9887:   } else if (get_header(ri.http_headers, ri.num_headers, \"Location\")",
          "9888:              != NULL) {",
          "9889:    conn->status_code = 302;",
          "9890:   } else {",
          "9891:    conn->status_code = 200;",
          "9892:   }",
          "9893:   connection_state =",
          "9894:       get_header(ri.http_headers, ri.num_headers, \"Connection\");",
          "9895:   if (!header_has_option(connection_state, \"keep-alive\")) {",
          "9896:    conn->must_close = 1;",
          "9897:   }",
          "9898:   (void)mg_printf(conn,",
          "9899:                   \"HTTP/1.1 %d %s\\r\\n\",",
          "9900:                   conn->status_code,",
          "9901:                   status_text);",
          "9904:   for (i = 0; i < ri.num_headers; i++) {",
          "9905:    mg_printf(conn,",
          "9906:              \"%s: %s\\r\\n\",",
          "9907:              ri.http_headers[i].name,",
          "9908:              ri.http_headers[i].value);",
          "9909:   }",
          "9910:   mg_write(conn, \"\\r\\n\", 2);",
          "9913:   mg_write(conn, buf + headers_len, (size_t)(data_len - headers_len));",
          "9916:   send_file_data(conn, &fout, 0, INT64_MAX);",
          "9918:  done:",
          "9919:   mg_free(blk.var);",
          "9920:   mg_free(blk.buf);",
          "9922:   if (pid != (pid_t)-1) {",
          "9923:    kill(pid, SIGKILL);",
          "9925:    {",
          "9926:     int st;",
          "9927:     while (waitpid(pid, &st, 0) != -1)",
          "9929:    }",
          "9930: #endif",
          "9931:   }",
          "9932:   if (fdin[0] != -1) {",
          "9933:    close(fdin[0]);",
          "9934:   }",
          "9935:   if (fdout[1] != -1) {",
          "9936:    close(fdout[1]);",
          "9939:   if (in != NULL) {",
          "9940:    fclose(in);",
          "9941:   } else if (fdin[1] != -1) {",
          "9942:    close(fdin[1]);",
          "9943:   }",
          "9945:   if (out != NULL) {",
          "9946:    fclose(out);",
          "9947:   } else if (fdout[0] != -1) {",
          "9948:    close(fdout[0]);",
          "9949:   }",
          "9951:   if (err != NULL) {",
          "9952:    fclose(err);",
          "9953:   } else if (fderr[0] != -1) {",
          "9954:    close(fderr[0]);",
          "9955:   }",
          "9957:   if (buf != NULL) {",
          "9958:    mg_free(buf);",
          "9959:   }",
          "9965:  static void mkcol(struct mg_connection * conn, const char *path)",
          "9966:  {",
          "9967:   int rc, body_len;",
          "9968:   struct de de;",
          "9969:   char date[64];",
          "9970:   time_t curtime = time(NULL);",
          "9972:   if (conn == NULL) {",
          "9973:    return;",
          "9974:   }",
          "9979:   memset(&de.file, 0, sizeof(de.file));",
          "9980:   if (!mg_stat(conn, path, &de.file)) {",
          "9981:    mg_cry(conn,",
          "9982:           \"%s: mg_stat(%s) failed: %s\",",
          "9983:           __func__,",
          "9984:           path,",
          "9985:           strerror(ERRNO));",
          "9986:   }",
          "9988:   if (de.file.last_modified) {",
          "9992:    mg_send_http_error(",
          "9993:        conn, 405, \"Error: mkcol(%s): %s\", path, strerror(ERRNO));",
          "9994:    return;",
          "9995:   }",
          "9997:   body_len = conn->data_len - conn->request_len;",
          "9998:   if (body_len > 0) {",
          "9999:    mg_send_http_error(",
          "10000:        conn, 415, \"Error: mkcol(%s): %s\", path, strerror(ERRNO));",
          "10001:    return;",
          "10002:   }",
          "10004:   rc = mg_mkdir(conn, path, 0755);",
          "10006:   if (rc == 0) {",
          "10007:    conn->status_code = 201;",
          "10008:    gmt_time_string(date, sizeof(date), &curtime);",
          "10009:    mg_printf(conn,",
          "10010:              \"HTTP/1.1 %d Created\\r\\n\"",
          "10011:              \"Date: %s\\r\\n\",",
          "10012:              conn->status_code,",
          "10013:              date);",
          "10014:    send_static_cache_header(conn);",
          "10015:    send_additional_header(conn);",
          "10016:    mg_printf(conn,",
          "10017:              \"Content-Length: 0\\r\\n\"",
          "10018:              \"Connection: %s\\r\\n\\r\\n\",",
          "10019:              suggest_connection_header(conn));",
          "10020:   } else if (rc == -1) {",
          "10021:    if (errno == EEXIST) {",
          "10022:     mg_send_http_error(",
          "10023:         conn, 405, \"Error: mkcol(%s): %s\", path, strerror(ERRNO));",
          "10024:    } else if (errno == EACCES) {",
          "10025:     mg_send_http_error(",
          "10026:         conn, 403, \"Error: mkcol(%s): %s\", path, strerror(ERRNO));",
          "10027:    } else if (errno == ENOENT) {",
          "10028:     mg_send_http_error(",
          "10029:         conn, 409, \"Error: mkcol(%s): %s\", path, strerror(ERRNO));",
          "10030:    } else {",
          "10031:     mg_send_http_error(",
          "10032:         conn, 500, \"fopen(%s): %s\", path, strerror(ERRNO));",
          "10033:    }",
          "10038:  static void put_file(struct mg_connection * conn, const char *path)",
          "10039:  {",
          "10040:   struct mg_file file = STRUCT_FILE_INITIALIZER;",
          "10041:   const char *range;",
          "10042:   int64_t r1, r2;",
          "10043:   int rc;",
          "10044:   char date[64];",
          "10045:   time_t curtime = time(NULL);",
          "10047:   if (conn == NULL) {",
          "10048:    return;",
          "10049:   }",
          "10051:   if (mg_stat(conn, path, &file.stat)) {",
          "10053:    conn->status_code = 200;",
          "10055:    if (file.stat.is_directory) {",
          "10058:     rc = 0;",
          "10060:    } else {",
          "10064:     if (file.access.membuf != NULL) {",
          "10066:      mg_send_http_error(conn,",
          "10067:                         405,",
          "10068:                         \"Error: Put not possible\\nReplacing %s \"",
          "10069:                         \"is not supported\",",
          "10070:                         path);",
          "10071:      return;",
          "10072:     }",
          "10075:     if (access(path, W_OK) == 0) {",
          "10077:      conn->status_code = 200;",
          "10078:      rc = 1;",
          "10079:     } else {",
          "10080:      mg_send_http_error(",
          "10081:          conn,",
          "10082:          403,",
          "10083:          \"Error: Put not possible\\nReplacing %s is not allowed\",",
          "10084:          path);",
          "10085:      return;",
          "10086:     }",
          "10087:    }",
          "10090:    conn->status_code = 201;",
          "10091:    rc = put_dir(conn, path);",
          "10092:   }",
          "10094:   if (rc == 0) {",
          "10096:    gmt_time_string(date, sizeof(date), &curtime);",
          "10097:    mg_printf(conn,",
          "10098:              \"HTTP/1.1 %d %s\\r\\n\",",
          "10099:              conn->status_code,",
          "10100:              mg_get_response_code_text(NULL, conn->status_code));",
          "10101:    send_no_cache_header(conn);",
          "10102:    send_additional_header(conn);",
          "10103:    mg_printf(conn,",
          "10104:              \"Date: %s\\r\\n\"",
          "10105:              \"Content-Length: 0\\r\\n\"",
          "10106:              \"Connection: %s\\r\\n\\r\\n\",",
          "10107:              date,",
          "10108:              suggest_connection_header(conn));",
          "10112:    return;",
          "10113:   }",
          "10115:   if (rc == -1) {",
          "10117:    mg_send_http_error(conn,",
          "10118:                       414,",
          "10119:                       \"Error: Path too long\\nput_dir(%s): %s\",",
          "10120:                       path,",
          "10121:                       strerror(ERRNO));",
          "10122:    return;",
          "10123:   }",
          "10125:   if (rc == -2) {",
          "10127:    mg_send_http_error(",
          "10128:        conn,",
          "10129:        500,",
          "10130:        \"Error: Can not create directory\\nput_dir(%s): %s\",",
          "10131:        path,",
          "10132:        strerror(ERRNO));",
          "10133:    return;",
          "10134:   }",
          "10138:   if (!mg_fopen(conn, path, MG_FOPEN_MODE_WRITE, &file)",
          "10139:       || file.access.fp == NULL) {",
          "10140:    (void)mg_fclose(&file.access);",
          "10141:    mg_send_http_error(conn,",
          "10142:                       500,",
          "10143:                       \"Error: Can not create file\\nfopen(%s): %s\",",
          "10144:                       path,",
          "10145:                       strerror(ERRNO));",
          "10146:    return;",
          "10147:   }",
          "10149:   fclose_on_exec(&file.access, conn);",
          "10150:   range = mg_get_header(conn, \"Content-Range\");",
          "10151:   r1 = r2 = 0;",
          "10152:   if ((range != NULL) && parse_range_header(range, &r1, &r2) > 0) {",
          "10154:    fseeko(file.access.fp, r1, SEEK_SET);",
          "10155:   }",
          "10157:   if (!forward_body_data(conn, file.access.fp, INVALID_SOCKET, NULL)) {",
          "10161:    (void)mg_fclose(&file.access);",
          "10162:    return;",
          "10163:   }",
          "10165:   if (mg_fclose(&file.access) != 0) {",
          "10168:    conn->status_code = 507;",
          "",
          "[Added Lines]",
          "8498: }",
          "8501: static void",
          "8502: handle_static_file_request(struct mg_connection *conn,",
          "8503:                            const char *path,",
          "8504:                            struct mg_file *filep,",
          "8505:                            const char *mime_type,",
          "8506:                            const char *additional_headers)",
          "8507: {",
          "8508:  char date[64], lm[64], etag[64];",
          "8510:  const char *msg = \"OK\", *hdr;",
          "8511:  time_t curtime = time(NULL);",
          "8512:  int64_t cl, r1, r2;",
          "8513:  struct vec mime_vec;",
          "8514:  int n, truncated;",
          "8515:  char gz_path[PATH_MAX];",
          "8516:  const char *encoding = \"\";",
          "8517:  const char *cors1, *cors2, *cors3;",
          "8519:  if ((conn == NULL) || (conn->ctx == NULL) || (filep == NULL)) {",
          "8520:   return;",
          "8521:  }",
          "8523:  if (mime_type == NULL) {",
          "8524:   get_mime_type(conn->ctx, path, &mime_vec);",
          "8525:  } else {",
          "8526:   mime_vec.ptr = mime_type;",
          "8527:   mime_vec.len = strlen(mime_type);",
          "8528:  }",
          "8529:  if (filep->stat.size > INT64_MAX) {",
          "8530:   mg_send_http_error(conn,",
          "8531:                      500,",
          "8532:                      \"Error: File size is too large to send\\n%\" INT64_FMT,",
          "8533:                      filep->stat.size);",
          "8534:   return;",
          "8535:  }",
          "8536:  cl = (int64_t)filep->stat.size;",
          "8537:  conn->status_code = 200;",
          "8538:  range[0] = '\\0';",
          "8543:  if (filep->stat.is_gzipped) {",
          "8544:   mg_snprintf(conn, &truncated, gz_path, sizeof(gz_path), \"%s.gz\", path);",
          "8546:   if (truncated) {",
          "8549:                       \"Error: Path of zipped file too long (%s)\",",
          "8550:                       path);",
          "8554:   path = gz_path;",
          "8555:   encoding = \"Content-Encoding: gzip\\r\\n\";",
          "8556:  }",
          "8558:  if (!mg_fopen(conn, path, MG_FOPEN_MODE_READ, filep)) {",
          "8559:   mg_send_http_error(conn,",
          "8560:                      500,",
          "8561:                      \"Error: Cannot open file\\nfopen(%s): %s\",",
          "8562:                      path,",
          "8563:                      strerror(ERRNO));",
          "8564:   return;",
          "8565:  }",
          "8567:  fclose_on_exec(&filep->access, conn);",
          "8570:  r1 = r2 = 0;",
          "8571:  hdr = mg_get_header(conn, \"Range\");",
          "8572:  if ((hdr != NULL) && ((n = parse_range_header(hdr, &r1, &r2)) > 0)",
          "8573:      && (r1 >= 0) && (r2 >= 0)) {",
          "8576:   if (filep->stat.is_gzipped) {",
          "8577:    mg_send_http_error(",
          "8578:        conn,",
          "8580:        \"%s\",",
          "8581:        \"Error: Range requests in gzipped files are not supported\");",
          "8582:    (void)mg_fclose(",
          "8584:    return;",
          "8586:   conn->status_code = 206;",
          "8587:   cl = (n == 2) ? (((r2 > cl) ? cl : r2) - r1 + 1) : (cl - r1);",
          "8588:   mg_snprintf(conn,",
          "8590:               range,",
          "8591:               sizeof(range),",
          "8592:               \"Content-Range: bytes \"",
          "8593:               \"%\" INT64_FMT \"-%\" INT64_FMT \"/%\" INT64_FMT \"\\r\\n\",",
          "8594:               r1,",
          "8595:               r1 + cl - 1,",
          "8596:               filep->stat.size);",
          "8597:   msg = \"Partial Content\";",
          "8598:  }",
          "8600:  hdr = mg_get_header(conn, \"Origin\");",
          "8601:  if (hdr) {",
          "8607:   cors1 = \"Access-Control-Allow-Origin: \";",
          "8608:   cors2 = conn->ctx->config[ACCESS_CONTROL_ALLOW_ORIGIN];",
          "8609:   cors3 = \"\\r\\n\";",
          "8610:  } else {",
          "8611:   cors1 = cors2 = cors3 = \"\";",
          "8612:  }",
          "8617:  gmt_time_string(date, sizeof(date), &curtime);",
          "8618:  gmt_time_string(lm, sizeof(lm), &filep->stat.last_modified);",
          "8619:  construct_etag(etag, sizeof(etag), &filep->stat);",
          "8621:  (void)mg_printf(conn,",
          "8622:                  \"HTTP/1.1 %d %s\\r\\n\"",
          "8623:                  \"%s%s%s\"",
          "8624:                  \"Date: %s\\r\\n\",",
          "8625:                  conn->status_code,",
          "8626:                  msg,",
          "8627:                  cors1,",
          "8628:                  cors2,",
          "8629:                  cors3,",
          "8630:                  date);",
          "8631:  send_static_cache_header(conn);",
          "8632:  send_additional_header(conn);",
          "8633:  (void)mg_printf(conn,",
          "8634:                  \"Last-Modified: %s\\r\\n\"",
          "8635:                  \"Etag: %s\\r\\n\"",
          "8636:                  \"Content-Type: %.*s\\r\\n\"",
          "8637:                  \"Content-Length: %\" INT64_FMT \"\\r\\n\"",
          "8638:                  \"Connection: %s\\r\\n\"",
          "8639:                  \"Accept-Ranges: bytes\\r\\n\"",
          "8640:                  \"%s%s\",",
          "8641:                  lm,",
          "8642:                  etag,",
          "8643:                  (int)mime_vec.len,",
          "8644:                  mime_vec.ptr,",
          "8645:                  cl,",
          "8646:                  suggest_connection_header(conn),",
          "8647:                  range,",
          "8648:                  encoding);",
          "8653:  if (additional_headers != NULL) {",
          "8654:   (void)mg_printf(conn,",
          "8655:                   \"%.*s\\r\\n\\r\\n\",",
          "8656:                   (int)strlen(additional_headers),",
          "8657:                   additional_headers);",
          "8658:  } else {",
          "8659:   (void)mg_printf(conn, \"\\r\\n\");",
          "8660:  }",
          "8662:  if (strcmp(conn->request_info.request_method, \"HEAD\") != 0) {",
          "8663:   send_file_data(conn, filep, r1, cl);",
          "8666: }",
          "8670: static void",
          "8671: handle_not_modified_static_file_request(struct mg_connection *conn,",
          "8672:                                         struct mg_file *filep)",
          "8673: {",
          "8674:  char date[64], lm[64], etag[64];",
          "8675:  time_t curtime = time(NULL);",
          "8677:  if ((conn == NULL) || (filep == NULL)) {",
          "8678:   return;",
          "8680:  conn->status_code = 304;",
          "8681:  gmt_time_string(date, sizeof(date), &curtime);",
          "8682:  gmt_time_string(lm, sizeof(lm), &filep->stat.last_modified);",
          "8683:  construct_etag(etag, sizeof(etag), &filep->stat);",
          "8685:  (void)mg_printf(conn,",
          "8686:                  \"HTTP/1.1 %d %s\\r\\n\"",
          "8687:                  \"Date: %s\\r\\n\",",
          "8688:                  conn->status_code,",
          "8689:                  mg_get_response_code_text(conn, conn->status_code),",
          "8690:                  date);",
          "8691:  send_static_cache_header(conn);",
          "8692:  send_additional_header(conn);",
          "8693:  (void)mg_printf(conn,",
          "8694:                  \"Last-Modified: %s\\r\\n\"",
          "8695:                  \"Etag: %s\\r\\n\"",
          "8696:                  \"Connection: %s\\r\\n\"",
          "8697:                  \"\\r\\n\",",
          "8698:                  lm,",
          "8699:                  etag,",
          "8700:                  suggest_connection_header(conn));",
          "8701: }",
          "8705: void",
          "8706: mg_send_file(struct mg_connection *conn, const char *path)",
          "8707: {",
          "8708:  mg_send_mime_file(conn, path, NULL);",
          "8709: }",
          "8712: void",
          "8713: mg_send_mime_file(struct mg_connection *conn,",
          "8714:                   const char *path,",
          "8715:                   const char *mime_type)",
          "8716: {",
          "8717:  mg_send_mime_file2(conn, path, mime_type, NULL);",
          "8718: }",
          "8721: void",
          "8722: mg_send_mime_file2(struct mg_connection *conn,",
          "8723:                    const char *path,",
          "8724:                    const char *mime_type,",
          "8725:                    const char *additional_headers)",
          "8726: {",
          "8727:  struct mg_file file = STRUCT_FILE_INITIALIZER;",
          "8728:  if (mg_stat(conn, path, &file.stat)) {",
          "8729:   if (file.stat.is_directory) {",
          "8730:    if (!conn) {",
          "8731:     return;",
          "8732:    }",
          "8733:    if (!mg_strcasecmp(conn->ctx->config[ENABLE_DIRECTORY_LISTING],",
          "8734:                       \"yes\")) {",
          "8735:     handle_directory_request(conn, path);",
          "8737:     mg_send_http_error(conn,",
          "8738:                        403,",
          "8739:                        \"%s\",",
          "8740:                        \"Error: Directory listing denied\");",
          "8743:    handle_static_file_request(",
          "8744:        conn, path, &file, mime_type, additional_headers);",
          "8746:  } else {",
          "8747:   mg_send_http_error(conn, 404, \"%s\", \"Error: File not found\");",
          "8749: }",
          "8758: static int",
          "8759: put_dir(struct mg_connection *conn, const char *path)",
          "8760: {",
          "8761:  char buf[PATH_MAX];",
          "8762:  const char *s, *p;",
          "8763:  struct mg_file file = STRUCT_FILE_INITIALIZER;",
          "8764:  size_t len;",
          "8765:  int res = 1;",
          "8767:  for (s = p = path + 2; (p = strchr(s, '/')) != NULL; s = ++p) {",
          "8768:   len = (size_t)(p - path);",
          "8769:   if (len >= sizeof(buf)) {",
          "8771:    res = -1;",
          "8772:    break;",
          "8773:   }",
          "8774:   memcpy(buf, path, len);",
          "8775:   buf[len] = '\\0';",
          "8778:   DEBUG_TRACE(\"mkdir(%s)\", buf);",
          "8779:   if (!mg_stat(conn, buf, &file.stat) && mg_mkdir(conn, buf, 0755) != 0) {",
          "8781:    res = -2;",
          "8782:    break;",
          "8786:   if (p[1] == '\\0') {",
          "8787:    res = 0;",
          "8788:   }",
          "8791:  return res;",
          "8792: }",
          "8795: static void",
          "8796: remove_bad_file(const struct mg_connection *conn, const char *path)",
          "8797: {",
          "8798:  int r = mg_remove(conn, path);",
          "8799:  if (r != 0) {",
          "8800:   mg_cry(conn, \"%s: Cannot remove invalid file %s\", __func__, path);",
          "8801:  }",
          "8802: }",
          "8805: long long",
          "8806: mg_store_body(struct mg_connection *conn, const char *path)",
          "8807: {",
          "8808:  char buf[MG_BUF_LEN];",
          "8809:  long long len = 0;",
          "8810:  int ret, n;",
          "8811:  struct mg_file fi;",
          "8813:  if (conn->consumed_content != 0) {",
          "8814:   mg_cry(conn, \"%s: Contents already consumed\", __func__);",
          "8815:   return -11;",
          "8816:  }",
          "8818:  ret = put_dir(conn, path);",
          "8819:  if (ret < 0) {",
          "8822:   return ret;",
          "8823:  }",
          "8824:  if (ret != 1) {",
          "8826:   return 0;",
          "8827:  }",
          "8829:  if (mg_fopen(conn, path, MG_FOPEN_MODE_WRITE, &fi) == 0) {",
          "8830:   return -12;",
          "8831:  }",
          "8833:  ret = mg_read(conn, buf, sizeof(buf));",
          "8834:  while (ret > 0) {",
          "8835:   n = (int)fwrite(buf, 1, (size_t)ret, fi.access.fp);",
          "8836:   if (n != ret) {",
          "8837:    (void)mg_fclose(",
          "8840:    return -13;",
          "8842:   len += ret;",
          "8843:   ret = mg_read(conn, buf, sizeof(buf));",
          "8844:  }",
          "8849:  if (mg_fclose(&fi.access) != 0) {",
          "8850:   remove_bad_file(conn, path);",
          "8851:   return -14;",
          "8854:  return len;",
          "8855: }",
          "8862: static int",
          "8863: skip_to_end_of_word_and_terminate(char **ppw, int eol)",
          "8864: {",
          "8867:  while (isgraph(**ppw)) {",
          "8868:   (*ppw)++;",
          "8869:  }",
          "8872:  if (eol) {",
          "8874:   if ((**ppw != '\\r') && (**ppw != '\\n')) {",
          "8875:    return -1;",
          "8876:   }",
          "8877:  } else {",
          "8879:   if (**ppw != ' ') {",
          "8880:    return -1;",
          "8885:  do {",
          "8887:   (*ppw)++;",
          "8888:  } while ((**ppw) && isspace(**ppw));",
          "8891:  if (!eol) {",
          "8893:   if (!isgraph(**ppw)) {",
          "8894:    return -1;",
          "8899:  return 1;",
          "8900: }",
          "8907: static int",
          "8908: parse_http_headers(char **buf, struct mg_header hdr[MG_MAX_HEADERS])",
          "8909: {",
          "8910:  int i;",
          "8911:  int num_headers = 0;",
          "8913:  for (i = 0; i < (int)MG_MAX_HEADERS; i++) {",
          "8914:   char *dp = *buf;",
          "8915:   while ((*dp != ':') && (*dp >= 33) && (*dp <= 126)) {",
          "8916:    dp++;",
          "8918:   if (dp == *buf) {",
          "8920:    break;",
          "8922:   if (*dp != ':') {",
          "8930:   hdr[i].name = *buf;",
          "8931:   do {",
          "8932:    dp++;",
          "8933:   } while (*dp == ' ');",
          "8936:   hdr[i].value = dp;",
          "8938:   if (((*buf)[0] != '\\r') || ((*buf)[1] != '\\n')) {",
          "8942:   num_headers = i + 1;",
          "8943:   if (*buf) {",
          "8944:    (*buf)[0] = 0;",
          "8945:    (*buf)[1] = 0;",
          "8947:   } else {",
          "8949:    break;",
          "8952:   if ((*buf)[0] == '\\r') {",
          "8954:    break;",
          "8956:  }",
          "8957:  return num_headers;",
          "8958: }",
          "8961: static int",
          "8962: is_valid_http_method(const char *method)",
          "8963: {",
          "9001:      ;",
          "9002: }",
          "9014: static int",
          "9015: parse_http_request(char *buf, int len, struct mg_request_info *ri)",
          "9016: {",
          "9017:  int request_length;",
          "9018:  int init_skip = 0;",
          "9022:  ri->remote_user = ri->request_method = ri->request_uri = ri->http_version =",
          "9023:      NULL;",
          "9024:  ri->num_headers = 0;",
          "9029:  while ((len > 0) && isspace(*(unsigned char *)buf)) {",
          "9030:   buf++;",
          "9031:   len--;",
          "9032:   init_skip++;",
          "9033:  }",
          "9035:  if (len == 0) {",
          "9037:   return 0;",
          "9038:  }",
          "9041:  if (iscntrl(*(unsigned char *)buf)) {",
          "9042:   return -1;",
          "9046:  request_length = get_http_header_len(buf, len);",
          "9047:  if (request_length <= 0) {",
          "9048:   return request_length;",
          "9049:  }",
          "9050:  buf[request_length - 1] = '\\0';",
          "9052:  if ((*buf == 0) || (*buf == '\\r') || (*buf == '\\n')) {",
          "9053:   return -1;",
          "9054:  }",
          "9057:  ri->request_method = buf;",
          "9059:  if (skip_to_end_of_word_and_terminate(&buf, 0) <= 0) {",
          "9060:   return -1;",
          "9061:  }",
          "9064:  if (!is_valid_http_method(ri->request_method)) {",
          "9065:   return -1;",
          "9066:  }",
          "9069:  ri->request_uri = buf;",
          "9071:  if (skip_to_end_of_word_and_terminate(&buf, 0) <= 0) {",
          "9072:   return -1;",
          "9073:  }",
          "9076:  ri->http_version = buf;",
          "9078:  if (skip_to_end_of_word_and_terminate(&buf, 1) <= 0) {",
          "9079:   return -1;",
          "9080:  }",
          "9083:  if (strncmp(ri->http_version, \"HTTP/\", 5) != 0) {",
          "9085:   return -1;",
          "9086:  }",
          "9087:  ri->http_version += 5;",
          "9091:  ri->num_headers = parse_http_headers(&buf, ri->http_headers);",
          "9092:  if (ri->num_headers < 0) {",
          "9094:   return -1;",
          "9095:  }",
          "9097:  return request_length + init_skip;",
          "9098: }",
          "9101: static int",
          "9102: parse_http_response(char *buf, int len, struct mg_response_info *ri)",
          "9103: {",
          "9104:  int response_length;",
          "9105:  int init_skip = 0;",
          "9106:  char *tmp, *tmp2;",
          "9107:  long l;",
          "9110:  ri->http_version = ri->status_text = NULL;",
          "9111:  ri->num_headers = ri->status_code = 0;",
          "9116:  while ((len > 0) && isspace(*(unsigned char *)buf)) {",
          "9117:   buf++;",
          "9118:   len--;",
          "9119:   init_skip++;",
          "9120:  }",
          "9122:  if (len == 0) {",
          "9124:   return 0;",
          "9125:  }",
          "9128:  if (iscntrl(*(unsigned char *)buf)) {",
          "9129:   return -1;",
          "9130:  }",
          "9133:  response_length = get_http_header_len(buf, len);",
          "9134:  if (response_length <= 0) {",
          "9135:   return response_length;",
          "9137:  buf[response_length - 1] = '\\0';",
          "9141:  (void)buf;",
          "9142:  (void)len;",
          "9143:  (void)ri;",
          "9146:  while ((*buf != '\\0') && isspace(*(unsigned char *)buf)) {",
          "9147:   buf++;",
          "9148:  }",
          "9149:  if ((*buf == 0) || (*buf == '\\r') || (*buf == '\\n')) {",
          "9150:   return -1;",
          "9151:  }",
          "9155:  if (strncmp(buf, \"HTTP/\", 5) != 0) {",
          "9157:   return -1;",
          "9158:  }",
          "9159:  buf += 5;",
          "9160:  if (!isgraph(buf[0])) {",
          "9162:   return -1;",
          "9163:  }",
          "9164:  ri->http_version = buf;",
          "9166:  if (skip_to_end_of_word_and_terminate(&buf, 0) <= 0) {",
          "9167:   return -1;",
          "9168:  }",
          "9171:  tmp = buf;",
          "9173:  if (skip_to_end_of_word_and_terminate(&buf, 0) <= 0) {",
          "9174:   return -1;",
          "9175:  }",
          "9177:  l = strtol(tmp, &tmp2, 10);",
          "9178:  if ((l < 100) || (l >= 1000) || ((tmp2 - tmp) != 3) || (*tmp2 != 0)) {",
          "9180:   return -1;",
          "9181:  }",
          "9182:  ri->status_code = (int)l;",
          "9185:  ri->status_text = buf;",
          "9189:  while (isprint(*buf)) {",
          "9190:   buf++;",
          "9191:  }",
          "9192:  if ((*buf != '\\r') && (*buf != '\\n')) {",
          "9193:   return -1;",
          "9194:  }",
          "9196:  do {",
          "9198:   buf++;",
          "9199:  } while ((*buf) && isspace(*buf));",
          "9203:  ri->num_headers = parse_http_headers(&buf, ri->http_headers);",
          "9204:  if (ri->num_headers < 0) {",
          "9206:   return -1;",
          "9209:  return response_length + init_skip;",
          "9210: }",
          "9218: static int",
          "9219: read_message(FILE *fp,",
          "9220:              struct mg_connection *conn,",
          "9221:              char *buf,",
          "9222:              int bufsiz,",
          "9223:              int *nread)",
          "9224: {",
          "9225:  int request_len, n = 0;",
          "9226:  struct timespec last_action_time;",
          "9227:  double request_timeout;",
          "9229:  if (!conn) {",
          "9230:   return 0;",
          "9231:  }",
          "9233:  memset(&last_action_time, 0, sizeof(last_action_time));",
          "9235:  if (conn->ctx->config[REQUEST_TIMEOUT]) {",
          "9237:   request_timeout = atof(conn->ctx->config[REQUEST_TIMEOUT]) / 1000.0;",
          "9238:  } else {",
          "9239:   request_timeout = -1.0;",
          "9240:  }",
          "9241:  if (conn->handled_requests > 0) {",
          "9242:   if (conn->ctx->config[KEEP_ALIVE_TIMEOUT]) {",
          "9243:    request_timeout =",
          "9244:        atof(conn->ctx->config[KEEP_ALIVE_TIMEOUT]) / 1000.0;",
          "9246:  }",
          "9248:  request_len = get_http_header_len(buf, *nread);",
          "9251:  clock_gettime(CLOCK_MONOTONIC, &last_action_time);",
          "9253:  while (request_len == 0) {",
          "9255:   if (conn->ctx->stop_flag != 0) {",
          "9257:    return -1;",
          "9260:   if (*nread >= bufsiz) {",
          "9262:    return -2;",
          "9265:   n = pull_inner(",
          "9266:       fp, conn, buf + *nread, bufsiz - *nread, request_timeout);",
          "9267:   if (n == -2) {",
          "9269:    return -1;",
          "9270:   }",
          "9271:   if (n > 0) {",
          "9273:    request_len = get_http_header_len(buf, *nread);",
          "9275:    request_len = 0;",
          "9276:   }",
          "9278:   if ((request_len == 0) && (request_timeout >= 0)) {",
          "9279:    if (mg_difftimespec(&last_action_time, &(conn->req_time))",
          "9280:        > request_timeout) {",
          "9282:     return -1;",
          "9284:    clock_gettime(CLOCK_MONOTONIC, &last_action_time);",
          "9285:   }",
          "9286:  }",
          "9288:  return request_len;",
          "9289: }",
          "9292: #if !defined(NO_CACHING)",
          "9294: static int",
          "9295: is_not_modified(const struct mg_connection *conn,",
          "9296:                 const struct mg_file_stat *filestat)",
          "9297: {",
          "9298:  char etag[64];",
          "9299:  const char *ims = mg_get_header(conn, \"If-Modified-Since\");",
          "9300:  const char *inm = mg_get_header(conn, \"If-None-Match\");",
          "9301:  construct_etag(etag, sizeof(etag), filestat);",
          "9303:  return ((inm != NULL) && !mg_strcasecmp(etag, inm))",
          "9304:         || ((ims != NULL)",
          "9305:             && (filestat->last_modified <= parse_date_string(ims)));",
          "9306: }",
          "9310: #if !defined(NO_CGI) || !defined(NO_FILES)",
          "9311: static int",
          "9312: forward_body_data(struct mg_connection *conn, FILE *fp, SOCKET sock, SSL *ssl)",
          "9313: {",
          "9314:  const char *expect, *body;",
          "9315:  char buf[MG_BUF_LEN];",
          "9316:  int to_read, nread, success = 0;",
          "9317:  int64_t buffered_len;",
          "9318:  double timeout = -1.0;",
          "9320:  if (!conn) {",
          "9321:   return 0;",
          "9322:  }",
          "9323:  if (conn->ctx->config[REQUEST_TIMEOUT]) {",
          "9324:   timeout = atoi(conn->ctx->config[REQUEST_TIMEOUT]) / 1000.0;",
          "9325:  }",
          "9327:  expect = mg_get_header(conn, \"Expect\");",
          "9329:  if (!fp) {",
          "9330:   mg_send_http_error(conn, 500, \"%s\", \"Error: NULL File\");",
          "9331:   return 0;",
          "9332:  }",
          "9334:  if ((conn->content_len == -1) && !conn->is_chunked) {",
          "9336:   mg_send_http_error(conn,",
          "9337:                      411,",
          "9338:                      \"%s\",",
          "9339:                      \"Error: Client did not specify content length\");",
          "9340:  } else if ((expect != NULL)",
          "9341:             && (mg_strcasecmp(expect, \"100-continue\") != 0)) {",
          "9344:   mg_send_http_error(conn,",
          "9345:                      417,",
          "9346:                      \"Error: Can not fulfill expectation %s\",",
          "9347:                      expect);",
          "9348:  } else {",
          "9349:   if (expect != NULL) {",
          "9350:    (void)mg_printf(conn, \"%s\", \"HTTP/1.1 100 Continue\\r\\n\\r\\n\");",
          "9351:    conn->status_code = 100;",
          "9352:   } else {",
          "9353:    conn->status_code = 200;",
          "9354:   }",
          "9356:   buffered_len = (int64_t)(conn->data_len) - (int64_t)conn->request_len",
          "9357:                  - conn->consumed_content;",
          "9362:   if ((buffered_len < 0) || (conn->consumed_content != 0)) {",
          "9363:    mg_send_http_error(conn, 500, \"%s\", \"Error: Size mismatch\");",
          "9364:    return 0;",
          "9365:   }",
          "9367:   if (buffered_len > 0) {",
          "9368:    if ((int64_t)buffered_len > conn->content_len) {",
          "9369:     buffered_len = (int)conn->content_len;",
          "9371:    body = conn->buf + conn->request_len + conn->consumed_content;",
          "9372:    push_all(conn->ctx, fp, sock, ssl, body, (int64_t)buffered_len);",
          "9373:    conn->consumed_content += buffered_len;",
          "9374:   }",
          "9376:   nread = 0;",
          "9377:   while (conn->consumed_content < conn->content_len) {",
          "9378:    to_read = sizeof(buf);",
          "9379:    if ((int64_t)to_read > conn->content_len - conn->consumed_content) {",
          "9380:     to_read = (int)(conn->content_len - conn->consumed_content);",
          "9381:    }",
          "9382:    nread = pull_inner(NULL, conn, buf, to_read, timeout);",
          "9383:    if (nread == -2) {",
          "9385:     break;",
          "9386:    }",
          "9387:    if (nread > 0) {",
          "9388:     if (push_all(conn->ctx, fp, sock, ssl, buf, nread) != nread) {",
          "9392:    conn->consumed_content += nread;",
          "9393:   }",
          "9395:   if (conn->consumed_content == conn->content_len) {",
          "9396:    success = (nread >= 0);",
          "9400:   if (!success) {",
          "9404:    mg_send_http_error(conn, 500, \"%s\", \"\");",
          "9405:   }",
          "9408:  return success;",
          "9409: }",
          "9423: struct cgi_environment {",
          "9424:  struct mg_connection *conn;",
          "9433: };",
          "9436: static void addenv(struct cgi_environment *env,",
          "9437:                    PRINTF_FORMAT_STRING(const char *fmt),",
          "9438:                    ...) PRINTF_ARGS(2, 3);",
          "9442: static void",
          "9443: addenv(struct cgi_environment *env, const char *fmt, ...)",
          "9444: {",
          "9445:  size_t n, space;",
          "9446:  int truncated = 0;",
          "9447:  char *added;",
          "9448:  va_list ap;",
          "9451:  space = (env->buflen - env->bufused);",
          "9454:  n = strlen(fmt) + 2 + 128;",
          "9456:  do {",
          "9457:   if (space <= n) {",
          "9459:    n = env->buflen + CGI_ENVIRONMENT_SIZE;",
          "9460:    added = (char *)mg_realloc_ctx(env->buf, n, env->conn->ctx);",
          "9461:    if (!added) {",
          "9463:     mg_cry(env->conn,",
          "9464:            \"%s: Cannot allocate memory for CGI variable [%s]\",",
          "9465:            __func__,",
          "9466:            fmt);",
          "9467:     return;",
          "9469:    env->buf = added;",
          "9470:    env->buflen = n;",
          "9471:    space = (env->buflen - env->bufused);",
          "9472:   }",
          "9475:   added = env->buf + env->bufused;",
          "9478:   va_start(ap, fmt);",
          "9479:   mg_vsnprintf(env->conn, &truncated, added, (size_t)space, fmt, ap);",
          "9480:   va_end(ap);",
          "9483:   if (truncated) {",
          "9485:    space = 0;",
          "9486:    n = 1;",
          "9487:   }",
          "9488:  } while (truncated);",
          "9491:  n = strlen(added) + 1;",
          "9492:  env->bufused += n;",
          "9495:  space = (env->varlen - env->varused);",
          "9496:  if (space < 2) {",
          "9497:   mg_cry(env->conn,",
          "9498:          \"%s: Cannot register CGI variable [%s]\",",
          "9499:          __func__,",
          "9500:          fmt);",
          "9501:   return;",
          "9505:  env->var[env->varused] = added;",
          "9506:  env->varused++;",
          "9507: }",
          "9511: static int",
          "9512: prepare_cgi_environment(struct mg_connection *conn,",
          "9513:                         const char *prog,",
          "9514:                         struct cgi_environment *env)",
          "9515: {",
          "9516:  const char *s;",
          "9517:  struct vec var_vec;",
          "9518:  char *p, src_addr[IP_ADDR_STR_LEN], http_var_name[128];",
          "9519:  int i, truncated, uri_len;",
          "9521:  if ((conn == NULL) || (prog == NULL) || (env == NULL)) {",
          "9522:   return -1;",
          "9523:  }",
          "9525:  env->conn = conn;",
          "9526:  env->buflen = CGI_ENVIRONMENT_SIZE;",
          "9527:  env->bufused = 0;",
          "9528:  env->buf = (char *)mg_malloc_ctx(env->buflen, conn->ctx);",
          "9529:  if (env->buf == NULL) {",
          "9530:   mg_cry(conn,",
          "9531:          \"%s: Not enough memory for environmental buffer\",",
          "9532:          __func__);",
          "9533:   return -1;",
          "9534:  }",
          "9535:  env->varlen = MAX_CGI_ENVIR_VARS;",
          "9536:  env->varused = 0;",
          "9537:  env->var = (char **)mg_malloc_ctx(env->buflen * sizeof(char *), conn->ctx);",
          "9538:  if (env->var == NULL) {",
          "9539:   mg_cry(conn,",
          "9540:          \"%s: Not enough memory for environmental variables\",",
          "9541:          __func__);",
          "9542:   mg_free(env->buf);",
          "9543:   return -1;",
          "9544:  }",
          "9546:  addenv(env, \"SERVER_NAME=%s\", conn->ctx->config[AUTHENTICATION_DOMAIN]);",
          "9547:  addenv(env, \"SERVER_ROOT=%s\", conn->ctx->config[DOCUMENT_ROOT]);",
          "9548:  addenv(env, \"DOCUMENT_ROOT=%s\", conn->ctx->config[DOCUMENT_ROOT]);",
          "9549:  addenv(env, \"SERVER_SOFTWARE=%s/%s\", \"Civetweb\", mg_version());",
          "9552:  addenv(env, \"%s\", \"GATEWAY_INTERFACE=CGI/1.1\");",
          "9553:  addenv(env, \"%s\", \"SERVER_PROTOCOL=HTTP/1.1\");",
          "9557:  if (conn->client.lsa.sa.sa_family == AF_INET6) {",
          "9558:   addenv(env, \"SERVER_PORT=%d\", ntohs(conn->client.lsa.sin6.sin6_port));",
          "9559:  } else",
          "9561:  {",
          "9562:   addenv(env, \"SERVER_PORT=%d\", ntohs(conn->client.lsa.sin.sin_port));",
          "9563:  }",
          "9565:  sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);",
          "9566:  addenv(env, \"REMOTE_ADDR=%s\", src_addr);",
          "9568:  addenv(env, \"REQUEST_METHOD=%s\", conn->request_info.request_method);",
          "9569:  addenv(env, \"REMOTE_PORT=%d\", conn->request_info.remote_port);",
          "9571:  addenv(env, \"REQUEST_URI=%s\", conn->request_info.request_uri);",
          "9572:  addenv(env, \"LOCAL_URI=%s\", conn->request_info.local_uri);",
          "9575:  uri_len = (int)strlen(conn->request_info.local_uri);",
          "9576:  if (conn->path_info == NULL) {",
          "9577:   if (conn->request_info.local_uri[uri_len - 1] != '/') {",
          "9579:    addenv(env, \"SCRIPT_NAME=%s\", conn->request_info.local_uri);",
          "9582:    const char *index_file = strrchr(prog, '/');",
          "9583:    if (index_file) {",
          "9584:     addenv(env,",
          "9585:            \"SCRIPT_NAME=%s%s\",",
          "9586:            conn->request_info.local_uri,",
          "9587:            index_file + 1);",
          "9588:    }",
          "9590:  } else {",
          "9592:   addenv(env,",
          "9593:          \"SCRIPT_NAME=%.*s\",",
          "9594:          uri_len - (int)strlen(conn->path_info),",
          "9595:          conn->request_info.local_uri);",
          "9596:  }",
          "9598:  addenv(env, \"SCRIPT_FILENAME=%s\", prog);",
          "9599:  if (conn->path_info == NULL) {",
          "9600:   addenv(env, \"PATH_TRANSLATED=%s\", conn->ctx->config[DOCUMENT_ROOT]);",
          "9601:  } else {",
          "9602:   addenv(env,",
          "9603:          \"PATH_TRANSLATED=%s%s\",",
          "9604:          conn->ctx->config[DOCUMENT_ROOT],",
          "9605:          conn->path_info);",
          "9606:  }",
          "9608:  addenv(env, \"HTTPS=%s\", (conn->ssl == NULL) ? \"off\" : \"on\");",
          "9610:  if ((s = mg_get_header(conn, \"Content-Type\")) != NULL) {",
          "9611:   addenv(env, \"CONTENT_TYPE=%s\", s);",
          "9612:  }",
          "9613:  if (conn->request_info.query_string != NULL) {",
          "9614:   addenv(env, \"QUERY_STRING=%s\", conn->request_info.query_string);",
          "9615:  }",
          "9616:  if ((s = mg_get_header(conn, \"Content-Length\")) != NULL) {",
          "9617:   addenv(env, \"CONTENT_LENGTH=%s\", s);",
          "9618:  }",
          "9619:  if ((s = getenv(\"PATH\")) != NULL) {",
          "9620:   addenv(env, \"PATH=%s\", s);",
          "9621:  }",
          "9622:  if (conn->path_info != NULL) {",
          "9623:   addenv(env, \"PATH_INFO=%s\", conn->path_info);",
          "9624:  }",
          "9626:  if (conn->status_code > 0) {",
          "9628:   addenv(env, \"STATUS=%d\", conn->status_code);",
          "9629:  }",
          "9632:  if ((s = getenv(\"COMSPEC\")) != NULL) {",
          "9633:   addenv(env, \"COMSPEC=%s\", s);",
          "9634:  }",
          "9635:  if ((s = getenv(\"SYSTEMROOT\")) != NULL) {",
          "9636:   addenv(env, \"SYSTEMROOT=%s\", s);",
          "9637:  }",
          "9638:  if ((s = getenv(\"SystemDrive\")) != NULL) {",
          "9639:   addenv(env, \"SystemDrive=%s\", s);",
          "9640:  }",
          "9641:  if ((s = getenv(\"ProgramFiles\")) != NULL) {",
          "9642:   addenv(env, \"ProgramFiles=%s\", s);",
          "9643:  }",
          "9644:  if ((s = getenv(\"ProgramFiles(x86)\")) != NULL) {",
          "9645:   addenv(env, \"ProgramFiles(x86)=%s\", s);",
          "9646:  }",
          "9653:  if ((s = getenv(\"PERLLIB\")) != NULL) {",
          "9654:   addenv(env, \"PERLLIB=%s\", s);",
          "9655:  }",
          "9657:  if (conn->request_info.remote_user != NULL) {",
          "9658:   addenv(env, \"REMOTE_USER=%s\", conn->request_info.remote_user);",
          "9659:   addenv(env, \"%s\", \"AUTH_TYPE=Digest\");",
          "9660:  }",
          "9663:  for (i = 0; i < conn->request_info.num_headers; i++) {",
          "9665:   (void)mg_snprintf(conn,",
          "9666:                     &truncated,",
          "9667:                     http_var_name,",
          "9668:                     sizeof(http_var_name),",
          "9669:                     \"HTTP_%s\",",
          "9670:                     conn->request_info.http_headers[i].name);",
          "9672:   if (truncated) {",
          "9673:    mg_cry(conn,",
          "9674:           \"%s: HTTP header variable too long [%s]\",",
          "9675:           __func__,",
          "9676:           conn->request_info.http_headers[i].name);",
          "9677:    continue;",
          "9681:   for (p = http_var_name; *p != '\\0'; p++) {",
          "9682:    if (*p == '-') {",
          "9684:    }",
          "9688:   addenv(env,",
          "9689:          \"%s=%s\",",
          "9690:          http_var_name,",
          "9691:          conn->request_info.http_headers[i].value);",
          "9692:  }",
          "9695:  s = conn->ctx->config[CGI_ENVIRONMENT];",
          "9696:  while ((s = next_option(s, &var_vec, NULL)) != NULL) {",
          "9697:   addenv(env, \"%.*s\", (int)var_vec.len, var_vec.ptr);",
          "9700:  env->var[env->varused] = NULL;",
          "9701:  env->buf[env->bufused] = '\\0';",
          "9703:  return 0;",
          "9704: }",
          "9707: static void",
          "9708: handle_cgi_request(struct mg_connection *conn, const char *prog)",
          "9709: {",
          "9710:  char *buf;",
          "9711:  size_t buflen;",
          "9712:  int headers_len, data_len, i, truncated;",
          "9713:  int fdin[2] = {-1, -1}, fdout[2] = {-1, -1}, fderr[2] = {-1, -1};",
          "9714:  const char *status, *status_text, *connection_state;",
          "9715:  char *pbuf, dir[PATH_MAX], *p;",
          "9716:  struct mg_request_info ri;",
          "9717:  struct cgi_environment blk;",
          "9718:  FILE *in = NULL, *out = NULL, *err = NULL;",
          "9719:  struct mg_file fout = STRUCT_FILE_INITIALIZER;",
          "9720:  pid_t pid = (pid_t)-1;",
          "9722:  if (conn == NULL) {",
          "9723:   return;",
          "9724:  }",
          "9726:  buf = NULL;",
          "9727:  buflen = 16384;",
          "9728:  i = prepare_cgi_environment(conn, prog, &blk);",
          "9729:  if (i != 0) {",
          "9730:   blk.buf = NULL;",
          "9731:   blk.var = NULL;",
          "9732:   goto done;",
          "9733:  }",
          "9738:  (void)mg_snprintf(conn, &truncated, dir, sizeof(dir), \"%s\", prog);",
          "9740:  if (truncated) {",
          "9741:   mg_cry(conn, \"Error: CGI program \\\"%s\\\": Path too long\", prog);",
          "9742:   mg_send_http_error(conn, 500, \"Error: %s\", \"CGI path too long\");",
          "9743:   goto done;",
          "9744:  }",
          "9746:  if ((p = strrchr(dir, '/')) != NULL) {",
          "9748:  } else {",
          "9749:   dir[0] = '.', dir[1] = '\\0';",
          "9750:   p = (char *)prog;",
          "9751:  }",
          "9753:  if ((pipe(fdin) != 0) || (pipe(fdout) != 0) || (pipe(fderr) != 0)) {",
          "9754:   status = strerror(ERRNO);",
          "9755:   mg_cry(conn,",
          "9756:          \"Error: CGI program \\\"%s\\\": Can not create CGI pipes: %s\",",
          "9757:          prog,",
          "9758:          status);",
          "9759:   mg_send_http_error(conn,",
          "9760:                      500,",
          "9761:                      \"Error: Cannot create CGI pipe: %s\",",
          "9762:                      status);",
          "9763:   goto done;",
          "9764:  }",
          "9766:  pid = spawn_process(conn, p, blk.buf, blk.var, fdin, fdout, fderr, dir);",
          "9768:  if (pid == (pid_t)-1) {",
          "9769:   status = strerror(ERRNO);",
          "9770:   mg_cry(conn,",
          "9771:          \"Error: CGI program \\\"%s\\\": Can not spawn CGI process: %s\",",
          "9772:          prog,",
          "9773:          status);",
          "9774:   mg_send_http_error(conn,",
          "9775:                      500,",
          "9776:                      \"Error: Cannot spawn CGI process [%s]: %s\",",
          "9777:                      prog,",
          "9778:                      status);",
          "9779:   goto done;",
          "9780:  }",
          "9795:  (void)close(fdin[0]);",
          "9796:  (void)close(fdout[1]);",
          "9797:  (void)close(fderr[1]);",
          "9798:  fdin[0] = fdout[1] = fderr[1] = -1;",
          "9800:  if ((in = fdopen(fdin[1], \"wb\")) == NULL) {",
          "9801:   status = strerror(ERRNO);",
          "9802:   mg_cry(conn,",
          "9803:          \"Error: CGI program \\\"%s\\\": Can not open stdin: %s\",",
          "9804:          prog,",
          "9805:          status);",
          "9806:   mg_send_http_error(conn,",
          "9807:                      500,",
          "9808:                      \"Error: CGI can not open fdin\\nfopen: %s\",",
          "9809:                      status);",
          "9810:   goto done;",
          "9811:  }",
          "9813:  if ((out = fdopen(fdout[0], \"rb\")) == NULL) {",
          "9814:   status = strerror(ERRNO);",
          "9815:   mg_cry(conn,",
          "9816:          \"Error: CGI program \\\"%s\\\": Can not open stdout: %s\",",
          "9817:          prog,",
          "9818:          status);",
          "9819:   mg_send_http_error(conn,",
          "9820:                      500,",
          "9821:                      \"Error: CGI can not open fdout\\nfopen: %s\",",
          "9822:                      status);",
          "9823:   goto done;",
          "9824:  }",
          "9826:  if ((err = fdopen(fderr[0], \"rb\")) == NULL) {",
          "9827:   status = strerror(ERRNO);",
          "9828:   mg_cry(conn,",
          "9829:          \"Error: CGI program \\\"%s\\\": Can not open stderr: %s\",",
          "9830:          prog,",
          "9831:          status);",
          "9832:   mg_send_http_error(conn,",
          "9833:                      500,",
          "9834:                      \"Error: CGI can not open fdout\\nfopen: %s\",",
          "9835:                      status);",
          "9836:   goto done;",
          "9837:  }",
          "9839:  setbuf(in, NULL);",
          "9840:  setbuf(out, NULL);",
          "9841:  setbuf(err, NULL);",
          "9842:  fout.access.fp = out;",
          "9844:  if ((conn->request_info.content_length > 0) || conn->is_chunked) {",
          "9846:   if (!forward_body_data(conn, in, INVALID_SOCKET, NULL)) {",
          "9849:           \"Error: CGI program \\\"%s\\\": Forward body data failed\",",
          "9850:           prog);",
          "9853:  }",
          "9856:  fclose(in);",
          "9857:  in = NULL;",
          "9858:  fdin[1] = -1;",
          "9864:  data_len = 0;",
          "9865:  buf = (char *)mg_malloc_ctx(buflen, conn->ctx);",
          "9866:  if (buf == NULL) {",
          "9867:   mg_send_http_error(conn,",
          "9868:                      500,",
          "9869:                      \"Error: Not enough memory for CGI buffer (%u bytes)\",",
          "9870:                      (unsigned int)buflen);",
          "9871:   mg_cry(conn,",
          "9872:          \"Error: CGI program \\\"%s\\\": Not enough memory for buffer (%u \"",
          "9873:          \"bytes)\",",
          "9874:          prog,",
          "9875:          (unsigned int)buflen);",
          "9876:   goto done;",
          "9877:  }",
          "9878:  headers_len = read_message(out, conn, buf, (int)buflen, &data_len);",
          "9879:  if (headers_len <= 0) {",
          "9883:   i = pull_all(err, conn, buf, (int)buflen);",
          "9884:   if (i > 0) {",
          "9886:           \"Error: CGI program \\\"%s\\\" sent error \"",
          "9887:           \"message: [%.*s]\",",
          "9889:           i,",
          "9890:           buf);",
          "9893:                       \"Error: CGI program \\\"%s\\\" sent error \"",
          "9894:                       \"message: [%.*s]\",",
          "9895:                       prog,",
          "9896:                       i,",
          "9897:                       buf);",
          "9898:   } else {",
          "9900:           \"Error: CGI program sent malformed or too big \"",
          "9901:           \"(>%u bytes) HTTP headers: [%.*s]\",",
          "9902:           (unsigned)buflen,",
          "9903:           data_len,",
          "9904:           buf);",
          "9908:                       \"Error: CGI program sent malformed or too big \"",
          "9909:                       \"(>%u bytes) HTTP headers: [%.*s]\",",
          "9910:                       (unsigned)buflen,",
          "9911:                       data_len,",
          "9912:                       buf);",
          "9913:   }",
          "9915:   goto done;",
          "9916:  }",
          "9917:  pbuf = buf;",
          "9918:  buf[headers_len - 1] = '\\0';",
          "9919:  ri.num_headers = parse_http_headers(&pbuf, ri.http_headers);",
          "9922:  status_text = \"OK\";",
          "9923:  if ((status = get_header(ri.http_headers, ri.num_headers, \"Status\"))",
          "9924:      != NULL) {",
          "9925:   conn->status_code = atoi(status);",
          "9926:   status_text = status;",
          "9927:   while (isdigit(*(const unsigned char *)status_text)",
          "9928:          || *status_text == ' ') {",
          "9929:    status_text++;",
          "9930:   }",
          "9931:  } else if (get_header(ri.http_headers, ri.num_headers, \"Location\")",
          "9932:             != NULL) {",
          "9933:   conn->status_code = 302;",
          "9934:  } else {",
          "9935:   conn->status_code = 200;",
          "9936:  }",
          "9937:  connection_state =",
          "9938:      get_header(ri.http_headers, ri.num_headers, \"Connection\");",
          "9939:  if (!header_has_option(connection_state, \"keep-alive\")) {",
          "9940:   conn->must_close = 1;",
          "9941:  }",
          "9942:  (void)mg_printf(conn, \"HTTP/1.1 %d %s\\r\\n\", conn->status_code, status_text);",
          "9945:  for (i = 0; i < ri.num_headers; i++) {",
          "9946:   mg_printf(conn,",
          "9947:             \"%s: %s\\r\\n\",",
          "9948:             ri.http_headers[i].name,",
          "9949:             ri.http_headers[i].value);",
          "9950:  }",
          "9951:  mg_write(conn, \"\\r\\n\", 2);",
          "9954:  mg_write(conn, buf + headers_len, (size_t)(data_len - headers_len));",
          "9957:  send_file_data(conn, &fout, 0, INT64_MAX);",
          "9959: done:",
          "9960:  mg_free(blk.var);",
          "9961:  mg_free(blk.buf);",
          "9963:  if (pid != (pid_t)-1) {",
          "9964:   kill(pid, SIGKILL);",
          "9966:   {",
          "9967:    int st;",
          "9968:    while (waitpid(pid, &st, 0) != -1)",
          "9971: #endif",
          "9972:  }",
          "9973:  if (fdin[0] != -1) {",
          "9974:   close(fdin[0]);",
          "9975:  }",
          "9976:  if (fdout[1] != -1) {",
          "9977:   close(fdout[1]);",
          "9978:  }",
          "9980:  if (in != NULL) {",
          "9981:   fclose(in);",
          "9982:  } else if (fdin[1] != -1) {",
          "9983:   close(fdin[1]);",
          "9984:  }",
          "9986:  if (out != NULL) {",
          "9987:   fclose(out);",
          "9988:  } else if (fdout[0] != -1) {",
          "9989:   close(fdout[0]);",
          "9990:  }",
          "9992:  if (err != NULL) {",
          "9993:   fclose(err);",
          "9994:  } else if (fderr[0] != -1) {",
          "9995:   close(fderr[0]);",
          "9996:  }",
          "9998:  if (buf != NULL) {",
          "9999:   mg_free(buf);",
          "10001: }",
          "10006: static void",
          "10007: mkcol(struct mg_connection *conn, const char *path)",
          "10008: {",
          "10009:  int rc, body_len;",
          "10010:  struct de de;",
          "10011:  char date[64];",
          "10012:  time_t curtime = time(NULL);",
          "10014:  if (conn == NULL) {",
          "10015:   return;",
          "10016:  }",
          "10021:  memset(&de.file, 0, sizeof(de.file));",
          "10022:  if (!mg_stat(conn, path, &de.file)) {",
          "10023:   mg_cry(conn,",
          "10024:          \"%s: mg_stat(%s) failed: %s\",",
          "10025:          __func__,",
          "10026:          path,",
          "10027:          strerror(ERRNO));",
          "10028:  }",
          "10030:  if (de.file.last_modified) {",
          "10034:   mg_send_http_error(",
          "10035:       conn, 405, \"Error: mkcol(%s): %s\", path, strerror(ERRNO));",
          "10036:   return;",
          "10037:  }",
          "10039:  body_len = conn->data_len - conn->request_len;",
          "10040:  if (body_len > 0) {",
          "10041:   mg_send_http_error(",
          "10042:       conn, 415, \"Error: mkcol(%s): %s\", path, strerror(ERRNO));",
          "10043:   return;",
          "10044:  }",
          "10046:  rc = mg_mkdir(conn, path, 0755);",
          "10048:  if (rc == 0) {",
          "10049:   conn->status_code = 201;",
          "10050:   gmt_time_string(date, sizeof(date), &curtime);",
          "10051:   mg_printf(conn,",
          "10052:             \"HTTP/1.1 %d Created\\r\\n\"",
          "10053:             \"Date: %s\\r\\n\",",
          "10054:             conn->status_code,",
          "10055:             date);",
          "10056:   send_static_cache_header(conn);",
          "10057:   send_additional_header(conn);",
          "10058:   mg_printf(conn,",
          "10059:             \"Content-Length: 0\\r\\n\"",
          "10060:             \"Connection: %s\\r\\n\\r\\n\",",
          "10061:             suggest_connection_header(conn));",
          "10062:  } else if (rc == -1) {",
          "10063:   if (errno == EEXIST) {",
          "10064:    mg_send_http_error(",
          "10065:        conn, 405, \"Error: mkcol(%s): %s\", path, strerror(ERRNO));",
          "10066:   } else if (errno == EACCES) {",
          "10067:    mg_send_http_error(",
          "10068:        conn, 403, \"Error: mkcol(%s): %s\", path, strerror(ERRNO));",
          "10069:   } else if (errno == ENOENT) {",
          "10070:    mg_send_http_error(",
          "10071:        conn, 409, \"Error: mkcol(%s): %s\", path, strerror(ERRNO));",
          "10072:   } else {",
          "10073:    mg_send_http_error(",
          "10074:        conn, 500, \"fopen(%s): %s\", path, strerror(ERRNO));",
          "10077: }",
          "10080: static void",
          "10081: put_file(struct mg_connection *conn, const char *path)",
          "10082: {",
          "10083:  struct mg_file file = STRUCT_FILE_INITIALIZER;",
          "10084:  const char *range;",
          "10085:  int64_t r1, r2;",
          "10086:  int rc;",
          "10087:  char date[64];",
          "10088:  time_t curtime = time(NULL);",
          "10090:  if (conn == NULL) {",
          "10091:   return;",
          "10092:  }",
          "10094:  if (mg_stat(conn, path, &file.stat)) {",
          "10096:   conn->status_code = 200;",
          "10098:   if (file.stat.is_directory) {",
          "10101:    rc = 0;",
          "10107:    if (file.access.membuf != NULL) {",
          "10109:     mg_send_http_error(conn,",
          "10110:                        405,",
          "10111:                        \"Error: Put not possible\\nReplacing %s \"",
          "10112:                        \"is not supported\",",
          "10113:                        path);",
          "10114:     return;",
          "10115:    }",
          "10118:    if (access(path, W_OK) == 0) {",
          "10120:     conn->status_code = 200;",
          "10121:     rc = 1;",
          "10122:    } else {",
          "10123:     mg_send_http_error(",
          "10124:         conn,",
          "10125:         403,",
          "10126:         \"Error: Put not possible\\nReplacing %s is not allowed\",",
          "10127:         path);",
          "10128:     return;",
          "10129:    }",
          "10131:  } else {",
          "10133:   conn->status_code = 201;",
          "10134:   rc = put_dir(conn, path);",
          "10135:  }",
          "10137:  if (rc == 0) {",
          "",
          "---------------",
          "--- Hunk 45 ---",
          "[Context before]",
          "10181:             \"Connection: %s\\r\\n\\r\\n\",",
          "10182:             date,",
          "10183:             suggest_connection_header(conn));",
          "10184:  }",
          "10201:  if (de.access.membuf != NULL) {",
          "",
          "[Removed Lines]",
          "10187:  static void delete_file(struct mg_connection * conn, const char *path)",
          "10188:  {",
          "10189:   struct de de;",
          "10190:   memset(&de.file, 0, sizeof(de.file));",
          "10191:   if (!mg_stat(conn, path, &de.file)) {",
          "10193:    mg_send_http_error(conn,",
          "10194:                       404,",
          "10195:                       \"Error: Cannot delete file\\nFile %s not found\",",
          "10196:                       path);",
          "10197:    return;",
          "10198:   }",
          "",
          "[Added Lines]",
          "10155:   return;",
          "10158:  if (rc == -1) {",
          "10160:   mg_send_http_error(conn,",
          "10161:                      414,",
          "10162:                      \"Error: Path too long\\nput_dir(%s): %s\",",
          "10163:                      path,",
          "10164:                      strerror(ERRNO));",
          "10165:   return;",
          "10166:  }",
          "10168:  if (rc == -2) {",
          "10170:   mg_send_http_error(conn,",
          "10171:                      500,",
          "10172:                      \"Error: Can not create directory\\nput_dir(%s): %s\",",
          "10173:                      path,",
          "10174:                      strerror(ERRNO));",
          "10175:   return;",
          "10176:  }",
          "10180:  if (!mg_fopen(conn, path, MG_FOPEN_MODE_WRITE, &file)",
          "10181:      || file.access.fp == NULL) {",
          "10182:   (void)mg_fclose(&file.access);",
          "10183:   mg_send_http_error(conn,",
          "10184:                      500,",
          "10185:                      \"Error: Can not create file\\nfopen(%s): %s\",",
          "10186:                      path,",
          "10187:                      strerror(ERRNO));",
          "10188:   return;",
          "10189:  }",
          "10191:  fclose_on_exec(&file.access, conn);",
          "10192:  range = mg_get_header(conn, \"Content-Range\");",
          "10193:  r1 = r2 = 0;",
          "10194:  if ((range != NULL) && parse_range_header(range, &r1, &r2) > 0) {",
          "10196:   fseeko(file.access.fp, r1, SEEK_SET);",
          "10197:  }",
          "10199:  if (!forward_body_data(conn, file.access.fp, INVALID_SOCKET, NULL)) {",
          "10203:   (void)mg_fclose(&file.access);",
          "10204:   return;",
          "10205:  }",
          "10207:  if (mg_fclose(&file.access) != 0) {",
          "10210:   conn->status_code = 507;",
          "10211:  }",
          "10213:  gmt_time_string(date, sizeof(date), &curtime);",
          "10214:  mg_printf(conn,",
          "10215:            \"HTTP/1.1 %d %s\\r\\n\",",
          "10216:            conn->status_code,",
          "10217:            mg_get_response_code_text(NULL, conn->status_code));",
          "10218:  send_no_cache_header(conn);",
          "10219:  send_additional_header(conn);",
          "10220:  mg_printf(conn,",
          "10221:            \"Date: %s\\r\\n\"",
          "10222:            \"Content-Length: 0\\r\\n\"",
          "10223:            \"Connection: %s\\r\\n\\r\\n\",",
          "10224:            date,",
          "10225:            suggest_connection_header(conn));",
          "10226: }",
          "10229: static void",
          "10230: delete_file(struct mg_connection *conn, const char *path)",
          "10231: {",
          "10232:  struct de de;",
          "10233:  memset(&de.file, 0, sizeof(de.file));",
          "10234:  if (!mg_stat(conn, path, &de.file)) {",
          "10236:   mg_send_http_error(conn,",
          "10237:                      404,",
          "10238:                      \"Error: Cannot delete file\\nFile %s not found\",",
          "10239:                      path);",
          "10240:   return;",
          "10241:  }",
          "",
          "---------------",
          "--- Hunk 46 ---",
          "[Context before]",
          "10209:  }",
          "10210: #endif",
          "10241:    mg_send_http_error(conn, 204, \"%s\", \"\");",
          "10242:   } else {",
          "10249:   }",
          "10250:  }",
          "10280:    (void)mg_snprintf(conn,",
          "10281:                      &truncated,",
          "10286:                      file_name);",
          "10317:   }",
          "10330:   } else {",
          "10341:   }",
          "10342:  }",
          "10345: #if !defined(NO_POPEN)",
          "10353:   } else {",
          "10364:   }",
          "10365:  }",
          "10382:  }",
          "10419: #if !defined(NO_POPEN)",
          "10433:      } else {",
          "10439:      }",
          "10441:     } else {",
          "10456:     }",
          "10458:    } else {",
          "10479:     }",
          "10480:    }",
          "10509:   }",
          "10540:  }",
          "10554:   conn->must_close = 1;",
          "10555:   gmt_time_string(date, sizeof(date), &curtime);",
          "10560:   mg_printf(conn,",
          "10562:             \"Date: %s\\r\\n\"",
          "10567:             date,",
          "10568:             suggest_connection_header(conn));",
          "10571:  }",
          "10637:  }",
          "10652:   }",
          "10684:  }",
          "10685: #endif",
          "10692:  }",
          "10699:  }",
          "10706:  }",
          "10713:  }",
          "10715: #if defined(USE_TIMERS)",
          "10716: #define TIMER_API static",
          "",
          "[Removed Lines]",
          "10212:   if (de.file.is_directory) {",
          "10213:    if (remove_directory(conn, path)) {",
          "10215:     mg_send_http_error(conn, 204, \"%s\", \"\");",
          "10216:    } else {",
          "10218:     mg_send_http_error(conn,",
          "10219:                        500,",
          "10220:                        \"Error: Could not delete %s\",",
          "10221:                        path);",
          "10222:    }",
          "10223:    return;",
          "10224:   }",
          "10228:   if (access(path, W_OK) != 0) {",
          "10230:    mg_send_http_error(",
          "10231:        conn,",
          "10232:        403,",
          "10233:        \"Error: Delete not possible\\nDeleting %s is not allowed\",",
          "10234:        path);",
          "10235:    return;",
          "10236:   }",
          "10239:   if (mg_remove(conn, path) == 0) {",
          "10244:    mg_send_http_error(conn,",
          "10245:                       423,",
          "10246:                       \"Error: Cannot delete file\\nremove(%s): %s\",",
          "10247:                       path,",
          "10248:                       strerror(ERRNO));",
          "10254:  static void send_ssi_file(struct mg_connection *,",
          "10255:                            const char *,",
          "10256:                            struct mg_file *,",
          "10257:                            int);",
          "10260:  static void do_ssi_include(struct mg_connection * conn,",
          "10261:                             const char *ssi,",
          "10262:                             char *tag,",
          "10263:                             int include_level)",
          "10264:  {",
          "10265:   char file_name[MG_BUF_LEN], path[512], *p;",
          "10266:   struct mg_file file = STRUCT_FILE_INITIALIZER;",
          "10267:   size_t len;",
          "10268:   int truncated = 0;",
          "10270:   if (conn == NULL) {",
          "10271:    return;",
          "10272:   }",
          "10277:   if (sscanf(tag, \" virtual=\\\"%511[^\\\"]\\\"\", file_name) == 1) {",
          "10279:    file_name[511] = 0;",
          "10282:                      path,",
          "10283:                      sizeof(path),",
          "10284:                      \"%s/%s\",",
          "10285:                      conn->ctx->config[DOCUMENT_ROOT],",
          "10288:   } else if (sscanf(tag, \" abspath=\\\"%511[^\\\"]\\\"\", file_name) == 1) {",
          "10291:    file_name[511] = 0;",
          "10292:    (void)mg_snprintf(",
          "10293:        conn, &truncated, path, sizeof(path), \"%s\", file_name);",
          "10295:   } else if ((sscanf(tag, \" file=\\\"%511[^\\\"]\\\"\", file_name) == 1)",
          "10296:              || (sscanf(tag, \" \\\"%511[^\\\"]\\\"\", file_name) == 1)) {",
          "10298:    file_name[511] = 0;",
          "10299:    (void)mg_snprintf(conn, &truncated, path, sizeof(path), \"%s\", ssi);",
          "10301:    if (!truncated) {",
          "10302:     if ((p = strrchr(path, '/')) != NULL) {",
          "10303:      p[1] = '\\0';",
          "10304:     }",
          "10305:     len = strlen(path);",
          "10306:     (void)mg_snprintf(conn,",
          "10307:                       &truncated,",
          "10308:                       path + len,",
          "10309:                       sizeof(path) - len,",
          "10310:                       \"%s\",",
          "10311:                       file_name);",
          "10312:    }",
          "10314:   } else {",
          "10315:    mg_cry(conn, \"Bad SSI #include: [%s]\", tag);",
          "10316:    return;",
          "10319:   if (truncated) {",
          "10320:    mg_cry(conn, \"SSI #include path length overflow: [%s]\", tag);",
          "10321:    return;",
          "10322:   }",
          "10324:   if (!mg_fopen(conn, path, MG_FOPEN_MODE_READ, &file)) {",
          "10325:    mg_cry(conn,",
          "10326:           \"Cannot open SSI #include: [%s]: fopen(%s): %s\",",
          "10327:           tag,",
          "10328:           path,",
          "10329:           strerror(ERRNO));",
          "10331:    fclose_on_exec(&file.access, conn);",
          "10332:    if (match_prefix(conn->ctx->config[SSI_EXTENSIONS],",
          "10333:                     strlen(conn->ctx->config[SSI_EXTENSIONS]),",
          "10334:                     path) > 0) {",
          "10335:     send_ssi_file(conn, path, &file, include_level + 1);",
          "10336:    } else {",
          "10337:     send_file_data(conn, &file, 0, INT64_MAX);",
          "10338:    }",
          "10339:    (void)mg_fclose(",
          "10346:  static void do_ssi_exec(struct mg_connection * conn, char *tag)",
          "10347:  {",
          "10348:   char cmd[1024] = \"\";",
          "10349:   struct mg_file file = STRUCT_FILE_INITIALIZER;",
          "10351:   if (sscanf(tag, \" \\\"%1023[^\\\"]\\\"\", cmd) != 1) {",
          "10352:    mg_cry(conn, \"Bad SSI #exec: [%s]\", tag);",
          "10354:    cmd[1023] = 0;",
          "10355:    if ((file.access.fp = popen(cmd, \"r\")) == NULL) {",
          "10356:     mg_cry(conn,",
          "10357:            \"Cannot SSI #exec: [%s]: %s\",",
          "10358:            cmd,",
          "10359:            strerror(ERRNO));",
          "10360:    } else {",
          "10361:     send_file_data(conn, &file, 0, INT64_MAX);",
          "10362:     pclose(file.access.fp);",
          "10363:    }",
          "10369:  static int mg_fgetc(struct mg_file * filep, int offset)",
          "10370:  {",
          "10371:   if (filep == NULL) {",
          "10372:    return EOF;",
          "10373:   }",
          "10374:   if ((filep->access.membuf != NULL) && (offset >= 0)",
          "10375:       && (((unsigned int)(offset)) < filep->stat.size)) {",
          "10376:    return ((const unsigned char *)filep->access.membuf)[offset];",
          "10377:   } else if (filep->access.fp != NULL) {",
          "10378:    return fgetc(filep->access.fp);",
          "10379:   } else {",
          "10380:    return EOF;",
          "10381:   }",
          "10385:  static void send_ssi_file(struct mg_connection * conn,",
          "10386:                            const char *path,",
          "10387:                            struct mg_file *filep,",
          "10388:                            int include_level)",
          "10389:  {",
          "10390:   char buf[MG_BUF_LEN];",
          "10391:   int ch, offset, len, in_tag, in_ssi_tag;",
          "10393:   if (include_level > 10) {",
          "10394:    mg_cry(conn, \"SSI #include level is too deep (%s)\", path);",
          "10395:    return;",
          "10396:   }",
          "10398:   in_tag = in_ssi_tag = len = offset = 0;",
          "10401:   while ((ch = mg_fgetc(filep, offset++)) != EOF) {",
          "10403:    if (in_tag) {",
          "10406:     if (ch == '>') {",
          "10408:      buf[len++] = '>';",
          "10410:      if (in_ssi_tag) {",
          "10412:       buf[len] = 0;",
          "10414:       if (!memcmp(buf + 5, \"include\", 7)) {",
          "10415:        do_ssi_include(conn,",
          "10416:                       path,",
          "10417:                       buf + 12,",
          "10418:                       include_level + 1);",
          "10420:       } else if (!memcmp(buf + 5, \"exec\", 4)) {",
          "10421:        do_ssi_exec(conn, buf + 9);",
          "10423:       } else {",
          "10424:        mg_cry(conn,",
          "10425:               \"%s: unknown SSI \"",
          "10426:               \"command: \\\"%s\\\"\",",
          "10427:               path,",
          "10428:               buf);",
          "10429:       }",
          "10430:       len = 0;",
          "10431:       in_ssi_tag = in_tag = 0;",
          "10436:       (void)mg_write(conn, buf, (size_t)len);",
          "10437:       len = 0;",
          "10438:       in_tag = 0;",
          "10443:      buf[len++] = (char)(ch & 0xff);",
          "10445:      if ((len == 5) && !memcmp(buf, \"<!--#\", 5)) {",
          "10447:       in_ssi_tag = 1;",
          "10448:      }",
          "10450:      if ((len + 2) > (int)sizeof(buf)) {",
          "10452:       mg_cry(conn, \"%s: tag is too large\", path);",
          "10453:       len = 0;",
          "10454:       return;",
          "10455:      }",
          "10461:     if (ch == '<') {",
          "10463:      in_tag = 1;",
          "10465:      (void)mg_write(conn, buf, (size_t)len);",
          "10467:      len = 1;",
          "10468:      buf[0] = '<';",
          "10470:     } else {",
          "10473:      buf[len++] = (char)(ch & 0xff);",
          "10475:      if (len == (int)sizeof(buf)) {",
          "10476:       mg_write(conn, buf, (size_t)len);",
          "10477:       len = 0;",
          "10478:      }",
          "10481:   }",
          "10484:   if (len > 0) {",
          "10485:    mg_write(conn, buf, (size_t)len);",
          "10486:   }",
          "10487:  }",
          "10490:  static void handle_ssi_file_request(struct mg_connection * conn,",
          "10491:                                      const char *path,",
          "10492:                                      struct mg_file *filep)",
          "10493:  {",
          "10494:   char date[64];",
          "10495:   time_t curtime = time(NULL);",
          "10496:   const char *cors1, *cors2, *cors3;",
          "10498:   if ((conn == NULL) || (path == NULL) || (filep == NULL)) {",
          "10499:    return;",
          "10500:   }",
          "10502:   if (mg_get_header(conn, \"Origin\")) {",
          "10504:    cors1 = \"Access-Control-Allow-Origin: \";",
          "10505:    cors2 = conn->ctx->config[ACCESS_CONTROL_ALLOW_ORIGIN];",
          "10506:    cors3 = \"\\r\\n\";",
          "10507:   } else {",
          "10508:    cors1 = cors2 = cors3 = \"\";",
          "10511:   if (!mg_fopen(conn, path, MG_FOPEN_MODE_READ, filep)) {",
          "10514:    mg_send_http_error(conn,",
          "10515:                       500,",
          "10516:                       \"Error: Cannot read file\\nfopen(%s): %s\",",
          "10517:                       path,",
          "10518:                       strerror(ERRNO));",
          "10519:   } else {",
          "10520:    conn->must_close = 1;",
          "10521:    gmt_time_string(date, sizeof(date), &curtime);",
          "10522:    fclose_on_exec(&filep->access, conn);",
          "10523:    mg_printf(conn, \"HTTP/1.1 200 OK\\r\\n\");",
          "10524:    send_no_cache_header(conn);",
          "10525:    send_additional_header(conn);",
          "10526:    mg_printf(conn,",
          "10527:              \"%s%s%s\"",
          "10528:              \"Date: %s\\r\\n\"",
          "10529:              \"Content-Type: text/html\\r\\n\"",
          "10530:              \"Connection: %s\\r\\n\\r\\n\",",
          "10531:              cors1,",
          "10532:              cors2,",
          "10533:              cors3,",
          "10534:              date,",
          "10535:              suggest_connection_header(conn));",
          "10536:    send_ssi_file(conn, path, filep, 0);",
          "10537:    (void)mg_fclose(",
          "10539:   }",
          "10543: #if !defined(NO_FILES)",
          "10544:  static void send_options(struct mg_connection * conn)",
          "10545:  {",
          "10546:   char date[64];",
          "10547:   time_t curtime = time(NULL);",
          "10549:   if (!conn) {",
          "10550:    return;",
          "10551:   }",
          "10553:   conn->status_code = 200;",
          "10561:             \"HTTP/1.1 200 OK\\r\\n\"",
          "10563:             \"Connection: %s\\r\\n\"",
          "10564:             \"Allow: GET, POST, HEAD, CONNECT, PUT, DELETE, OPTIONS, \"",
          "10565:             \"PROPFIND, MKCOL\\r\\n\"",
          "10566:             \"DAV: 1\\r\\n\",",
          "10569:   send_additional_header(conn);",
          "10570:   mg_printf(conn, \"\\r\\n\");",
          "10575:  static void print_props(struct mg_connection * conn,",
          "10576:                          const char *uri,",
          "10577:                          struct mg_file_stat *filep)",
          "10578:  {",
          "10579:   char mtime[64];",
          "10581:   if ((conn == NULL) || (uri == NULL) || (filep == NULL)) {",
          "10582:    return;",
          "10583:   }",
          "10585:   gmt_time_string(mtime, sizeof(mtime), &filep->last_modified);",
          "10586:   mg_printf(conn,",
          "10587:             \"<d:response>\"",
          "10588:             \"<d:href>%s</d:href>\"",
          "10589:             \"<d:propstat>\"",
          "10590:             \"<d:prop>\"",
          "10591:             \"<d:resourcetype>%s</d:resourcetype>\"",
          "10592:             \"<d:getcontentlength>%\" INT64_FMT \"</d:getcontentlength>\"",
          "10593:             \"<d:getlastmodified>%s</d:getlastmodified>\"",
          "10594:             \"</d:prop>\"",
          "10595:             \"<d:status>HTTP/1.1 200 OK</d:status>\"",
          "10596:             \"</d:propstat>\"",
          "10597:             \"</d:response>\\n\",",
          "10598:             uri,",
          "10599:             filep->is_directory ? \"<d:collection/>\" : \"\",",
          "10600:             filep->size,",
          "10601:             mtime);",
          "10602:  }",
          "10605:  static int print_dav_dir_entry(struct de * de, void *data)",
          "10606:  {",
          "10607:   char href[PATH_MAX];",
          "10608:   int truncated;",
          "10610:   struct mg_connection *conn = (struct mg_connection *)data;",
          "10611:   if (!de || !conn) {",
          "10612:    return -1;",
          "10613:   }",
          "10614:   mg_snprintf(conn,",
          "10615:               &truncated,",
          "10616:               href,",
          "10617:               sizeof(href),",
          "10618:               \"%s%s\",",
          "10619:               conn->request_info.local_uri,",
          "10620:               de->file_name);",
          "10622:   if (!truncated) {",
          "10623:    size_t href_encoded_size;",
          "10624:    char *href_encoded;",
          "10627:    href_encoded = mg_malloc(href_encoded_size);",
          "10628:    if (href_encoded == NULL) {",
          "10629:     return -1;",
          "10630:    }",
          "10631:    mg_url_encode(href, href_encoded, href_encoded_size);",
          "10632:    print_props(conn, href_encoded, &de->file);",
          "10633:    mg_free(href_encoded);",
          "10634:   }",
          "10636:   return 0;",
          "10640:  static void handle_propfind(struct mg_connection * conn,",
          "10641:                              const char *path,",
          "10642:                              struct mg_file_stat *filep)",
          "10643:  {",
          "10644:   const char *depth = mg_get_header(conn, \"Depth\");",
          "10645:   char date[64];",
          "10646:   time_t curtime = time(NULL);",
          "10648:   gmt_time_string(date, sizeof(date), &curtime);",
          "10650:   if (!conn || !path || !filep || !conn->ctx) {",
          "10651:    return;",
          "10654:   conn->must_close = 1;",
          "10655:   conn->status_code = 207;",
          "10656:   mg_printf(conn,",
          "10657:             \"HTTP/1.1 207 Multi-Status\\r\\n\"",
          "10658:             \"Date: %s\\r\\n\",",
          "10659:             date);",
          "10660:   send_static_cache_header(conn);",
          "10661:   send_additional_header(conn);",
          "10662:   mg_printf(conn,",
          "10663:             \"Connection: %s\\r\\n\"",
          "10664:             \"Content-Type: text/xml; charset=utf-8\\r\\n\\r\\n\",",
          "10665:             suggest_connection_header(conn));",
          "10667:   mg_printf(conn,",
          "10668:             \"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\"",
          "10669:             \"<d:multistatus xmlns:d='DAV:'>\\n\");",
          "10672:   print_props(conn, conn->request_info.local_uri, filep);",
          "10676:   if (filep && filep->is_directory",
          "10677:       && !mg_strcasecmp(conn->ctx->config[ENABLE_DIRECTORY_LISTING],",
          "10678:                         \"yes\")",
          "10679:       && ((depth == NULL) || (strcmp(depth, \"0\") != 0))) {",
          "10680:    scan_directory(conn, path, conn, &print_dav_dir_entry);",
          "10681:   }",
          "10683:   mg_printf(conn, \"%s\\n\", \"</d:multistatus>\");",
          "10687:  void mg_lock_connection(struct mg_connection * conn)",
          "10688:  {",
          "10689:   if (conn) {",
          "10690:    (void)pthread_mutex_lock(&conn->mutex);",
          "10691:   }",
          "10694:  void mg_unlock_connection(struct mg_connection * conn)",
          "10695:  {",
          "10696:   if (conn) {",
          "10697:    (void)pthread_mutex_unlock(&conn->mutex);",
          "10698:   }",
          "10701:  void mg_lock_context(struct mg_context * ctx)",
          "10702:  {",
          "10703:   if (ctx) {",
          "10704:    (void)pthread_mutex_lock(&ctx->nonce_mutex);",
          "10705:   }",
          "10708:  void mg_unlock_context(struct mg_context * ctx)",
          "10709:  {",
          "10710:   if (ctx) {",
          "10711:    (void)pthread_mutex_unlock(&ctx->nonce_mutex);",
          "10712:   }",
          "",
          "[Added Lines]",
          "10255:  if (de.file.is_directory) {",
          "10256:   if (remove_directory(conn, path)) {",
          "10261:    mg_send_http_error(conn, 500, \"Error: Could not delete %s\", path);",
          "10263:   return;",
          "10264:  }",
          "10268:  if (access(path, W_OK) != 0) {",
          "10270:   mg_send_http_error(",
          "10271:       conn,",
          "10272:       403,",
          "10273:       \"Error: Delete not possible\\nDeleting %s is not allowed\",",
          "10274:       path);",
          "10275:   return;",
          "10279:  if (mg_remove(conn, path) == 0) {",
          "10281:   mg_send_http_error(conn, 204, \"%s\", \"\");",
          "10282:  } else {",
          "10284:   mg_send_http_error(conn,",
          "10285:                      423,",
          "10286:                      \"Error: Cannot delete file\\nremove(%s): %s\",",
          "10287:                      path,",
          "10288:                      strerror(ERRNO));",
          "10289:  }",
          "10290: }",
          "10294: static void",
          "10295: send_ssi_file(struct mg_connection *, const char *, struct mg_file *, int);",
          "10298: static void",
          "10299: do_ssi_include(struct mg_connection *conn,",
          "10300:                const char *ssi,",
          "10301:                char *tag,",
          "10302:                int include_level)",
          "10303: {",
          "10304:  char file_name[MG_BUF_LEN], path[512], *p;",
          "10305:  struct mg_file file = STRUCT_FILE_INITIALIZER;",
          "10306:  size_t len;",
          "10307:  int truncated = 0;",
          "10309:  if (conn == NULL) {",
          "10310:   return;",
          "10311:  }",
          "10316:  if (sscanf(tag, \" virtual=\\\"%511[^\\\"]\\\"\", file_name) == 1) {",
          "10318:   file_name[511] = 0;",
          "10319:   (void)mg_snprintf(conn,",
          "10320:                     &truncated,",
          "10321:                     path,",
          "10322:                     sizeof(path),",
          "10323:                     \"%s/%s\",",
          "10324:                     conn->ctx->config[DOCUMENT_ROOT],",
          "10325:                     file_name);",
          "10327:  } else if (sscanf(tag, \" abspath=\\\"%511[^\\\"]\\\"\", file_name) == 1) {",
          "10330:   file_name[511] = 0;",
          "10331:   (void)",
          "10332:       mg_snprintf(conn, &truncated, path, sizeof(path), \"%s\", file_name);",
          "10334:  } else if ((sscanf(tag, \" file=\\\"%511[^\\\"]\\\"\", file_name) == 1)",
          "10335:             || (sscanf(tag, \" \\\"%511[^\\\"]\\\"\", file_name) == 1)) {",
          "10337:   file_name[511] = 0;",
          "10338:   (void)mg_snprintf(conn, &truncated, path, sizeof(path), \"%s\", ssi);",
          "10340:   if (!truncated) {",
          "10341:    if ((p = strrchr(path, '/')) != NULL) {",
          "10342:     p[1] = '\\0';",
          "10343:    }",
          "10344:    len = strlen(path);",
          "10347:                      path + len,",
          "10348:                      sizeof(path) - len,",
          "10349:                      \"%s\",",
          "10353:  } else {",
          "10354:   mg_cry(conn, \"Bad SSI #include: [%s]\", tag);",
          "10355:   return;",
          "10356:  }",
          "10358:  if (truncated) {",
          "10359:   mg_cry(conn, \"SSI #include path length overflow: [%s]\", tag);",
          "10360:   return;",
          "10361:  }",
          "10363:  if (!mg_fopen(conn, path, MG_FOPEN_MODE_READ, &file)) {",
          "10364:   mg_cry(conn,",
          "10365:          \"Cannot open SSI #include: [%s]: fopen(%s): %s\",",
          "10366:          tag,",
          "10367:          path,",
          "10368:          strerror(ERRNO));",
          "10369:  } else {",
          "10370:   fclose_on_exec(&file.access, conn);",
          "10371:   if (match_prefix(conn->ctx->config[SSI_EXTENSIONS],",
          "10372:                    strlen(conn->ctx->config[SSI_EXTENSIONS]),",
          "10373:                    path) > 0) {",
          "10374:    send_ssi_file(conn, path, &file, include_level + 1);",
          "10376:    send_file_data(conn, &file, 0, INT64_MAX);",
          "10380: }",
          "10384: static void",
          "10385: do_ssi_exec(struct mg_connection *conn, char *tag)",
          "10386: {",
          "10387:  char cmd[1024] = \"\";",
          "10388:  struct mg_file file = STRUCT_FILE_INITIALIZER;",
          "10390:  if (sscanf(tag, \" \\\"%1023[^\\\"]\\\"\", cmd) != 1) {",
          "10391:   mg_cry(conn, \"Bad SSI #exec: [%s]\", tag);",
          "10392:  } else {",
          "10393:   cmd[1023] = 0;",
          "10394:   if ((file.access.fp = popen(cmd, \"r\")) == NULL) {",
          "10395:    mg_cry(conn, \"Cannot SSI #exec: [%s]: %s\", cmd, strerror(ERRNO));",
          "10397:    send_file_data(conn, &file, 0, INT64_MAX);",
          "10398:    pclose(file.access.fp);",
          "10401: }",
          "10405: static int",
          "10406: mg_fgetc(struct mg_file *filep, int offset)",
          "10407: {",
          "10408:  if (filep == NULL) {",
          "10409:   return EOF;",
          "10410:  }",
          "10411:  if ((filep->access.membuf != NULL) && (offset >= 0)",
          "10412:      && (((unsigned int)(offset)) < filep->stat.size)) {",
          "10413:   return ((const unsigned char *)filep->access.membuf)[offset];",
          "10414:  } else if (filep->access.fp != NULL) {",
          "10415:   return fgetc(filep->access.fp);",
          "10416:  } else {",
          "10417:   return EOF;",
          "10419: }",
          "10422: static void",
          "10423: send_ssi_file(struct mg_connection *conn,",
          "10424:               const char *path,",
          "10425:               struct mg_file *filep,",
          "10426:               int include_level)",
          "10427: {",
          "10428:  char buf[MG_BUF_LEN];",
          "10429:  int ch, offset, len, in_tag, in_ssi_tag;",
          "10431:  if (include_level > 10) {",
          "10432:   mg_cry(conn, \"SSI #include level is too deep (%s)\", path);",
          "10433:   return;",
          "10434:  }",
          "10436:  in_tag = in_ssi_tag = len = offset = 0;",
          "10439:  while ((ch = mg_fgetc(filep, offset++)) != EOF) {",
          "10441:   if (in_tag) {",
          "10444:    if (ch == '>') {",
          "10446:     buf[len++] = '>';",
          "10448:     if (in_ssi_tag) {",
          "10450:      buf[len] = 0;",
          "10452:      if (!memcmp(buf + 5, \"include\", 7)) {",
          "10453:       do_ssi_include(conn, path, buf + 12, include_level + 1);",
          "10455:      } else if (!memcmp(buf + 5, \"exec\", 4)) {",
          "10456:       do_ssi_exec(conn, buf + 9);",
          "10459:       mg_cry(conn,",
          "10460:              \"%s: unknown SSI \"",
          "10461:              \"command: \\\"%s\\\"\",",
          "10462:              path,",
          "10463:              buf);",
          "10465:      len = 0;",
          "10466:      in_ssi_tag = in_tag = 0;",
          "10471:      (void)mg_write(conn, buf, (size_t)len);",
          "10472:      len = 0;",
          "10473:      in_tag = 0;",
          "10478:     buf[len++] = (char)(ch & 0xff);",
          "10480:     if ((len == 5) && !memcmp(buf, \"<!--#\", 5)) {",
          "10482:      in_ssi_tag = 1;",
          "10483:     }",
          "10485:     if ((len + 2) > (int)sizeof(buf)) {",
          "10487:      mg_cry(conn, \"%s: tag is too large\", path);",
          "10488:      len = 0;",
          "10489:      return;",
          "10493:   } else {",
          "10496:    if (ch == '<') {",
          "10498:     in_tag = 1;",
          "10500:     (void)mg_write(conn, buf, (size_t)len);",
          "10502:     len = 1;",
          "10503:     buf[0] = '<';",
          "10505:    } else {",
          "10508:     buf[len++] = (char)(ch & 0xff);",
          "10510:     if (len == (int)sizeof(buf)) {",
          "10511:      mg_write(conn, buf, (size_t)len);",
          "10512:      len = 0;",
          "10513:     }",
          "10514:    }",
          "10516:  }",
          "10519:  if (len > 0) {",
          "10520:   mg_write(conn, buf, (size_t)len);",
          "10522: }",
          "10525: static void",
          "10526: handle_ssi_file_request(struct mg_connection *conn,",
          "10527:                         const char *path,",
          "10528:                         struct mg_file *filep)",
          "10529: {",
          "10530:  char date[64];",
          "10531:  time_t curtime = time(NULL);",
          "10532:  const char *cors1, *cors2, *cors3;",
          "10534:  if ((conn == NULL) || (path == NULL) || (filep == NULL)) {",
          "10535:   return;",
          "10536:  }",
          "10538:  if (mg_get_header(conn, \"Origin\")) {",
          "10540:   cors1 = \"Access-Control-Allow-Origin: \";",
          "10541:   cors2 = conn->ctx->config[ACCESS_CONTROL_ALLOW_ORIGIN];",
          "10542:   cors3 = \"\\r\\n\";",
          "10543:  } else {",
          "10544:   cors1 = cors2 = cors3 = \"\";",
          "10545:  }",
          "10547:  if (!mg_fopen(conn, path, MG_FOPEN_MODE_READ, filep)) {",
          "10550:   mg_send_http_error(conn,",
          "10551:                      500,",
          "10552:                      \"Error: Cannot read file\\nfopen(%s): %s\",",
          "10553:                      path,",
          "10554:                      strerror(ERRNO));",
          "10555:  } else {",
          "10558:   fclose_on_exec(&filep->access, conn);",
          "10559:   mg_printf(conn, \"HTTP/1.1 200 OK\\r\\n\");",
          "10560:   send_no_cache_header(conn);",
          "10561:   send_additional_header(conn);",
          "10563:             \"%s%s%s\"",
          "10565:             \"Content-Type: text/html\\r\\n\"",
          "10566:             \"Connection: %s\\r\\n\\r\\n\",",
          "10567:             cors1,",
          "10568:             cors2,",
          "10569:             cors3,",
          "10572:   send_ssi_file(conn, path, filep, 0);",
          "10575: }",
          "10578: #if !defined(NO_FILES)",
          "10579: static void",
          "10580: send_options(struct mg_connection *conn)",
          "10581: {",
          "10582:  char date[64];",
          "10583:  time_t curtime = time(NULL);",
          "10585:  if (!conn) {",
          "10586:   return;",
          "10587:  }",
          "10589:  conn->status_code = 200;",
          "10590:  conn->must_close = 1;",
          "10591:  gmt_time_string(date, sizeof(date), &curtime);",
          "10596:  mg_printf(conn,",
          "10597:            \"HTTP/1.1 200 OK\\r\\n\"",
          "10598:            \"Date: %s\\r\\n\"",
          "10599:            \"Connection: %s\\r\\n\"",
          "10600:            \"Allow: GET, POST, HEAD, CONNECT, PUT, DELETE, OPTIONS, \"",
          "10601:            \"PROPFIND, MKCOL\\r\\n\"",
          "10602:            \"DAV: 1\\r\\n\",",
          "10603:            date,",
          "10604:            suggest_connection_header(conn));",
          "10605:  send_additional_header(conn);",
          "10606:  mg_printf(conn, \"\\r\\n\");",
          "10607: }",
          "10611: static void",
          "10612: print_props(struct mg_connection *conn,",
          "10613:             const char *uri,",
          "10614:             struct mg_file_stat *filep)",
          "10615: {",
          "10616:  char mtime[64];",
          "10618:  if ((conn == NULL) || (uri == NULL) || (filep == NULL)) {",
          "10619:   return;",
          "10622:  gmt_time_string(mtime, sizeof(mtime), &filep->last_modified);",
          "10623:  mg_printf(conn,",
          "10624:            \"<d:response>\"",
          "10625:            \"<d:href>%s</d:href>\"",
          "10626:            \"<d:propstat>\"",
          "10627:            \"<d:prop>\"",
          "10628:            \"<d:resourcetype>%s</d:resourcetype>\"",
          "10629:            \"<d:getcontentlength>%\" INT64_FMT \"</d:getcontentlength>\"",
          "10630:            \"<d:getlastmodified>%s</d:getlastmodified>\"",
          "10631:            \"</d:prop>\"",
          "10632:            \"<d:status>HTTP/1.1 200 OK</d:status>\"",
          "10633:            \"</d:propstat>\"",
          "10634:            \"</d:response>\\n\",",
          "10635:            uri,",
          "10636:            filep->is_directory ? \"<d:collection/>\" : \"\",",
          "10637:            filep->size,",
          "10638:            mtime);",
          "10639: }",
          "10642: static int",
          "10643: print_dav_dir_entry(struct de *de, void *data)",
          "10644: {",
          "10645:  char href[PATH_MAX];",
          "10646:  int truncated;",
          "10648:  struct mg_connection *conn = (struct mg_connection *)data;",
          "10649:  if (!de || !conn) {",
          "10650:   return -1;",
          "10651:  }",
          "10652:  mg_snprintf(conn,",
          "10653:              &truncated,",
          "10654:              href,",
          "10655:              sizeof(href),",
          "10656:              \"%s%s\",",
          "10657:              conn->request_info.local_uri,",
          "10658:              de->file_name);",
          "10660:  if (!truncated) {",
          "10661:   size_t href_encoded_size;",
          "10662:   char *href_encoded;",
          "10665:   href_encoded = mg_malloc(href_encoded_size);",
          "10666:   if (href_encoded == NULL) {",
          "10667:    return -1;",
          "10669:   mg_url_encode(href, href_encoded, href_encoded_size);",
          "10670:   print_props(conn, href_encoded, &de->file);",
          "10671:   mg_free(href_encoded);",
          "10672:  }",
          "10674:  return 0;",
          "10675: }",
          "10678: static void",
          "10679: handle_propfind(struct mg_connection *conn,",
          "10680:                 const char *path,",
          "10681:                 struct mg_file_stat *filep)",
          "10682: {",
          "10683:  const char *depth = mg_get_header(conn, \"Depth\");",
          "10684:  char date[64];",
          "10685:  time_t curtime = time(NULL);",
          "10687:  gmt_time_string(date, sizeof(date), &curtime);",
          "10689:  if (!conn || !path || !filep || !conn->ctx) {",
          "10690:   return;",
          "10691:  }",
          "10693:  conn->must_close = 1;",
          "10694:  conn->status_code = 207;",
          "10695:  mg_printf(conn,",
          "10696:            \"HTTP/1.1 207 Multi-Status\\r\\n\"",
          "10697:            \"Date: %s\\r\\n\",",
          "10698:            date);",
          "10699:  send_static_cache_header(conn);",
          "10700:  send_additional_header(conn);",
          "10701:  mg_printf(conn,",
          "10702:            \"Connection: %s\\r\\n\"",
          "10703:            \"Content-Type: text/xml; charset=utf-8\\r\\n\\r\\n\",",
          "10704:            suggest_connection_header(conn));",
          "10706:  mg_printf(conn,",
          "10707:            \"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\"",
          "10708:            \"<d:multistatus xmlns:d='DAV:'>\\n\");",
          "10711:  print_props(conn, conn->request_info.local_uri, filep);",
          "10715:  if (filep && filep->is_directory",
          "10716:      && !mg_strcasecmp(conn->ctx->config[ENABLE_DIRECTORY_LISTING], \"yes\")",
          "10717:      && ((depth == NULL) || (strcmp(depth, \"0\") != 0))) {",
          "10718:   scan_directory(conn, path, conn, &print_dav_dir_entry);",
          "10721:  mg_printf(conn, \"%s\\n\", \"</d:multistatus>\");",
          "10722: }",
          "10725: void",
          "10726: mg_lock_connection(struct mg_connection *conn)",
          "10727: {",
          "10728:  if (conn) {",
          "10729:   (void)pthread_mutex_lock(&conn->mutex);",
          "10731: }",
          "10733: void",
          "10734: mg_unlock_connection(struct mg_connection *conn)",
          "10735: {",
          "10736:  if (conn) {",
          "10737:   (void)pthread_mutex_unlock(&conn->mutex);",
          "10739: }",
          "10741: void",
          "10742: mg_lock_context(struct mg_context *ctx)",
          "10743: {",
          "10744:  if (ctx) {",
          "10745:   (void)pthread_mutex_lock(&ctx->nonce_mutex);",
          "10747: }",
          "10749: void",
          "10750: mg_unlock_context(struct mg_context *ctx)",
          "10751: {",
          "10752:  if (ctx) {",
          "10753:   (void)pthread_mutex_unlock(&ctx->nonce_mutex);",
          "10755: }",
          "",
          "---------------",
          "--- Hunk 47 ---",
          "[Context before]",
          "10732: #include \"sha1.inl\"",
          "10733: #endif",
          "10755:   mg_printf(conn,",
          "10770:  }",
          "10859:     }",
          "10866:     }",
          "10896:       break;",
          "10897:      }",
          "10922:     }",
          "10944:    } else {",
          "10962:    }",
          "10963:   }",
          "10966:  }",
          "10980: #if defined(__GNUC__) || defined(__MINGW32__)",
          "",
          "[Removed Lines]",
          "10735:  static int send_websocket_handshake(struct mg_connection * conn,",
          "10736:                                      const char *websock_key)",
          "10737:  {",
          "10738:   static const char *magic = \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\";",
          "10739:   char buf[100], sha[20], b64_sha[sizeof(sha) * 2];",
          "10740:   SHA_CTX sha_ctx;",
          "10741:   int truncated;",
          "10744:   mg_snprintf(",
          "10745:       conn, &truncated, buf, sizeof(buf), \"%s%s\", websock_key, magic);",
          "10746:   if (truncated) {",
          "10747:    conn->must_close = 1;",
          "10748:    return 0;",
          "10749:   }",
          "10751:   SHA1_Init(&sha_ctx);",
          "10752:   SHA1_Update(&sha_ctx, (unsigned char *)buf, (uint32_t)strlen(buf));",
          "10753:   SHA1_Final((unsigned char *)sha, &sha_ctx);",
          "10754:   base64_encode((unsigned char *)sha, sizeof(sha), b64_sha);",
          "10756:             \"HTTP/1.1 101 Switching Protocols\\r\\n\"",
          "10757:             \"Upgrade: websocket\\r\\n\"",
          "10758:             \"Connection: Upgrade\\r\\n\"",
          "10759:             \"Sec-WebSocket-Accept: %s\\r\\n\",",
          "10760:             b64_sha);",
          "10761:   if (conn->request_info.acceptedWebSocketSubprotocol) {",
          "10762:    mg_printf(conn,",
          "10763:              \"Sec-WebSocket-Protocol: %s\\r\\n\\r\\n\",",
          "10764:              conn->request_info.acceptedWebSocketSubprotocol);",
          "10765:   } else {",
          "10766:    mg_printf(conn, \"%s\", \"\\r\\n\");",
          "10767:   }",
          "10769:   return 1;",
          "10773:  static void read_websocket(struct mg_connection * conn,",
          "10774:                             mg_websocket_data_handler ws_data_handler,",
          "10775:                             void *callback_data)",
          "10776:  {",
          "10781:   unsigned char *buf = (unsigned char *)conn->buf + conn->request_len;",
          "10782:   int n, error, exit_by_callback;",
          "10788:   size_t i, len, mask_len = 0, data_len = 0, header_len, body_len;",
          "10793:   unsigned char mask[4];",
          "10799:   unsigned char mem[4096];",
          "10800:   unsigned char *data = mem;",
          "10802:   double timeout = -1.0;",
          "10804:   if (conn->ctx->config[WEBSOCKET_TIMEOUT]) {",
          "10805:    timeout = atoi(conn->ctx->config[WEBSOCKET_TIMEOUT]) / 1000.0;",
          "10806:   }",
          "10807:   if ((timeout <= 0.0) && (conn->ctx->config[REQUEST_TIMEOUT])) {",
          "10808:    timeout = atoi(conn->ctx->config[REQUEST_TIMEOUT]) / 1000.0;",
          "10809:   }",
          "10811:   mg_set_thread_name(\"wsock\");",
          "10815:   while (!conn->ctx->stop_flag) {",
          "10816:    header_len = 0;",
          "10817:    assert(conn->data_len >= conn->request_len);",
          "10818:    if ((body_len = (size_t)(conn->data_len - conn->request_len))",
          "10819:        >= 2) {",
          "10820:     len = buf[1] & 127;",
          "10821:     mask_len = (buf[1] & 128) ? 4 : 0;",
          "10822:     if ((len < 126) && (body_len >= mask_len)) {",
          "10824:      data_len = len;",
          "10825:      header_len = 2 + mask_len;",
          "10826:     } else if ((len == 126) && (body_len >= (4 + mask_len))) {",
          "10828:      header_len = 4 + mask_len;",
          "10829:      data_len = ((((size_t)buf[2]) << 8) + buf[3]);",
          "10830:     } else if (body_len >= (10 + mask_len)) {",
          "10832:      uint32_t l1, l2;",
          "10834:      memcpy(&l2, &buf[6], 4);",
          "10835:      header_len = 10 + mask_len;",
          "10836:      data_len = (((uint64_t)ntohl(l1)) << 32) + ntohl(l2);",
          "10838:      if (data_len > (uint64_t)0x7FFF0000ul) {",
          "10840:       mg_cry(conn,",
          "10841:              \"websocket out of memory; closing connection\");",
          "10842:       break;",
          "10843:      }",
          "10844:     }",
          "10845:    }",
          "10847:    if ((header_len > 0) && (body_len >= header_len)) {",
          "10849:     data = mem;",
          "10850:     if (data_len > sizeof(mem)) {",
          "10851:      data = (unsigned char *)mg_malloc_ctx(data_len, conn->ctx);",
          "10852:      if (data == NULL) {",
          "10855:       mg_cry(conn,",
          "10856:              \"websocket out of memory; closing connection\");",
          "10857:       break;",
          "10858:      }",
          "10862:     if (mask_len > 0) {",
          "10863:      memcpy(mask, buf + header_len - mask_len, sizeof(mask));",
          "10864:     } else {",
          "10865:      memset(mask, 0, sizeof(mask));",
          "10870:     assert(body_len >= header_len);",
          "10871:     if (data_len + header_len > body_len) {",
          "10874:      len = body_len - header_len;",
          "10875:      memcpy(data, buf + header_len, len);",
          "10876:      error = 0;",
          "10877:      while (len < data_len) {",
          "10878:       n = pull_inner(NULL,",
          "10879:                      conn,",
          "10880:                      (char *)(data + len),",
          "10881:                      (int)(data_len - len),",
          "10882:                      timeout);",
          "10883:       if (n <= -2) {",
          "10884:        error = 1;",
          "10885:        break;",
          "10886:       } else if (n > 0) {",
          "10887:        len += (size_t)n;",
          "10888:       } else {",
          "10891:       }",
          "10892:      }",
          "10893:      if (error) {",
          "10894:       mg_cry(conn,",
          "10895:              \"Websocket pull failed; closing connection\");",
          "10898:      conn->data_len = conn->request_len;",
          "10899:     } else {",
          "10900:      mop = buf[0]; /* current mask and opcode, overwritten by",
          "10904:      len = data_len + header_len;",
          "10908:      memcpy(data, buf + header_len, data_len);",
          "10911:      memmove(buf, buf + len, body_len - len);",
          "10914:      conn->data_len -= (int)len;",
          "10915:     }",
          "10918:     if (mask_len > 0) {",
          "10919:      for (i = 0; i < data_len; ++i) {",
          "10920:       data[i] ^= mask[i & 3];",
          "10921:      }",
          "10926:     exit_by_callback = 0;",
          "10927:     if ((ws_data_handler != NULL)",
          "10928:         && !ws_data_handler(",
          "10929:                conn, mop, (char *)data, data_len, callback_data)) {",
          "10930:      exit_by_callback = 1;",
          "10931:     }",
          "10933:     if (data != mem) {",
          "10934:      mg_free(data);",
          "10935:     }",
          "10937:     if (exit_by_callback",
          "10938:         || ((mop & 0xf) == WEBSOCKET_OPCODE_CONNECTION_CLOSE)) {",
          "10940:      break;",
          "10941:     }",
          "10947:     n = pull_inner(NULL,",
          "10948:                    conn,",
          "10949:                    conn->buf + conn->data_len,",
          "10950:                    conn->buf_size - conn->data_len,",
          "10951:                    timeout);",
          "10952:     if (n <= -2) {",
          "10954:      break;",
          "10955:     }",
          "10956:     if (n > 0) {",
          "10957:      conn->data_len += n;",
          "10958:     } else {",
          "10961:     }",
          "10965:   mg_set_thread_name(\"worker\");",
          "10969:  static int mg_websocket_write_exec(struct mg_connection * conn,",
          "10970:                                     int opcode,",
          "10971:                                     const char *data,",
          "10972:                                     size_t dataLen,",
          "10973:                                     uint32_t masking_key)",
          "10974:  {",
          "10975:   unsigned char header[14];",
          "10976:   size_t headerLen = 1;",
          "10978:   int retval = -1;",
          "",
          "[Added Lines]",
          "10777: static int",
          "10778: send_websocket_handshake(struct mg_connection *conn, const char *websock_key)",
          "10779: {",
          "10780:  static const char *magic = \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\";",
          "10781:  char buf[100], sha[20], b64_sha[sizeof(sha) * 2];",
          "10782:  SHA_CTX sha_ctx;",
          "10783:  int truncated;",
          "10786:  mg_snprintf(conn, &truncated, buf, sizeof(buf), \"%s%s\", websock_key, magic);",
          "10787:  if (truncated) {",
          "10788:   conn->must_close = 1;",
          "10789:   return 0;",
          "10790:  }",
          "10792:  SHA1_Init(&sha_ctx);",
          "10793:  SHA1_Update(&sha_ctx, (unsigned char *)buf, (uint32_t)strlen(buf));",
          "10794:  SHA1_Final((unsigned char *)sha, &sha_ctx);",
          "10795:  base64_encode((unsigned char *)sha, sizeof(sha), b64_sha);",
          "10796:  mg_printf(conn,",
          "10797:            \"HTTP/1.1 101 Switching Protocols\\r\\n\"",
          "10798:            \"Upgrade: websocket\\r\\n\"",
          "10799:            \"Connection: Upgrade\\r\\n\"",
          "10800:            \"Sec-WebSocket-Accept: %s\\r\\n\",",
          "10801:            b64_sha);",
          "10802:  if (conn->request_info.acceptedWebSocketSubprotocol) {",
          "10804:             \"Sec-WebSocket-Protocol: %s\\r\\n\\r\\n\",",
          "10805:             conn->request_info.acceptedWebSocketSubprotocol);",
          "10806:  } else {",
          "10807:   mg_printf(conn, \"%s\", \"\\r\\n\");",
          "10810:  return 1;",
          "10811: }",
          "10814: static void",
          "10815: read_websocket(struct mg_connection *conn,",
          "10816:                mg_websocket_data_handler ws_data_handler,",
          "10817:                void *callback_data)",
          "10818: {",
          "10823:  unsigned char *buf = (unsigned char *)conn->buf + conn->request_len;",
          "10824:  int n, error, exit_by_callback;",
          "10830:  size_t i, len, mask_len = 0, data_len = 0, header_len, body_len;",
          "10835:  unsigned char mask[4];",
          "10841:  unsigned char mem[4096];",
          "10842:  unsigned char *data = mem;",
          "10844:  double timeout = -1.0;",
          "10846:  if (conn->ctx->config[WEBSOCKET_TIMEOUT]) {",
          "10847:   timeout = atoi(conn->ctx->config[WEBSOCKET_TIMEOUT]) / 1000.0;",
          "10848:  }",
          "10849:  if ((timeout <= 0.0) && (conn->ctx->config[REQUEST_TIMEOUT])) {",
          "10850:   timeout = atoi(conn->ctx->config[REQUEST_TIMEOUT]) / 1000.0;",
          "10851:  }",
          "10853:  mg_set_thread_name(\"wsock\");",
          "10857:  while (!conn->ctx->stop_flag) {",
          "10858:   header_len = 0;",
          "10859:   assert(conn->data_len >= conn->request_len);",
          "10860:   if ((body_len = (size_t)(conn->data_len - conn->request_len)) >= 2) {",
          "10861:    len = buf[1] & 127;",
          "10862:    mask_len = (buf[1] & 128) ? 4 : 0;",
          "10863:    if ((len < 126) && (body_len >= mask_len)) {",
          "10865:     data_len = len;",
          "10866:     header_len = 2 + mask_len;",
          "10867:    } else if ((len == 126) && (body_len >= (4 + mask_len))) {",
          "10869:     header_len = 4 + mask_len;",
          "10870:     data_len = ((((size_t)buf[2]) << 8) + buf[3]);",
          "10871:    } else if (body_len >= (10 + mask_len)) {",
          "10873:     uint32_t l1, l2;",
          "10875:     memcpy(&l2, &buf[6], 4);",
          "10876:     header_len = 10 + mask_len;",
          "10877:     data_len = (((uint64_t)ntohl(l1)) << 32) + ntohl(l2);",
          "10879:     if (data_len > (uint64_t)0x7FFF0000ul) {",
          "10881:      mg_cry(conn, \"websocket out of memory; closing connection\");",
          "10882:      break;",
          "10884:    }",
          "10885:   }",
          "10887:   if ((header_len > 0) && (body_len >= header_len)) {",
          "10889:    data = mem;",
          "10890:    if (data_len > sizeof(mem)) {",
          "10891:     data = (unsigned char *)mg_malloc_ctx(data_len, conn->ctx);",
          "10892:     if (data == NULL) {",
          "10895:      mg_cry(conn, \"websocket out of memory; closing connection\");",
          "10896:      break;",
          "10898:    }",
          "10901:    if (mask_len > 0) {",
          "10902:     memcpy(mask, buf + header_len - mask_len, sizeof(mask));",
          "10903:    } else {",
          "10904:     memset(mask, 0, sizeof(mask));",
          "10905:    }",
          "10909:    assert(body_len >= header_len);",
          "10910:    if (data_len + header_len > body_len) {",
          "10913:     len = body_len - header_len;",
          "10914:     memcpy(data, buf + header_len, len);",
          "10915:     error = 0;",
          "10916:     while (len < data_len) {",
          "10917:      n = pull_inner(NULL,",
          "10918:                     conn,",
          "10919:                     (char *)(data + len),",
          "10920:                     (int)(data_len - len),",
          "10921:                     timeout);",
          "10922:      if (n <= -2) {",
          "10923:       error = 1;",
          "10925:      } else if (n > 0) {",
          "10926:       len += (size_t)n;",
          "10927:      } else {",
          "10931:     }",
          "10932:     if (error) {",
          "10933:      mg_cry(conn, \"Websocket pull failed; closing connection\");",
          "10934:      break;",
          "10935:     }",
          "10936:     conn->data_len = conn->request_len;",
          "10937:    } else {",
          "10938:     mop = buf[0]; /* current mask and opcode, overwritten by",
          "10942:     len = data_len + header_len;",
          "10946:     memcpy(data, buf + header_len, data_len);",
          "10949:     memmove(buf, buf + len, body_len - len);",
          "10952:     conn->data_len -= (int)len;",
          "10953:    }",
          "10956:    if (mask_len > 0) {",
          "10957:     for (i = 0; i < data_len; ++i) {",
          "10958:      data[i] ^= mask[i & 3];",
          "10960:    }",
          "10964:    exit_by_callback = 0;",
          "10965:    if ((ws_data_handler != NULL)",
          "10966:        && !ws_data_handler(",
          "10967:               conn, mop, (char *)data, data_len, callback_data)) {",
          "10968:     exit_by_callback = 1;",
          "10969:    }",
          "10971:    if (data != mem) {",
          "10972:     mg_free(data);",
          "10973:    }",
          "10975:    if (exit_by_callback",
          "10976:        || ((mop & 0xf) == WEBSOCKET_OPCODE_CONNECTION_CLOSE)) {",
          "10978:     break;",
          "10979:    }",
          "10982:   } else {",
          "10985:    n = pull_inner(NULL,",
          "10986:                   conn,",
          "10987:                   conn->buf + conn->data_len,",
          "10988:                   conn->buf_size - conn->data_len,",
          "10989:                   timeout);",
          "10990:    if (n <= -2) {",
          "10992:     break;",
          "10993:    }",
          "10994:    if (n > 0) {",
          "10995:     conn->data_len += n;",
          "11003:  mg_set_thread_name(\"worker\");",
          "11004: }",
          "11007: static int",
          "11008: mg_websocket_write_exec(struct mg_connection *conn,",
          "11009:                         int opcode,",
          "11010:                         const char *data,",
          "11011:                         size_t dataLen,",
          "11012:                         uint32_t masking_key)",
          "11013: {",
          "11014:  unsigned char header[14];",
          "11015:  size_t headerLen = 1;",
          "11017:  int retval = -1;",
          "",
          "---------------",
          "--- Hunk 48 ---",
          "[Context before]",
          "10983: #pragma GCC diagnostic ignored \"-Wconversion\"",
          "10984: #endif",
          "10988: #if defined(__GNUC__) || defined(__MINGW32__)",
          "10989: #pragma GCC diagnostic pop",
          "10990: #endif",
          "11069:   }",
          "11078:   }",
          "11079:  }",
          "11125: #if !defined(USE_LUA)",
          "11127: #endif",
          "11153:    }",
          "11157:   }",
          "11187:     do {",
          "11210:       }",
          "11239:      }",
          "11241:     }",
          "11242:    }",
          "11253:   }",
          "11254: #if defined(USE_LUA)",
          "11272:    }",
          "11273:   }",
          "11274: #endif",
          "11297: #if defined(USE_LUA)",
          "11304:   }",
          "11309: #if defined(USE_LUA)",
          "11312: #endif",
          "11319:  }",
          "11383:  }",
          "11413:     throttle = (int)v;",
          "11414:    }",
          "11415:   }",
          "11418:  }",
          "11427:  }",
          "",
          "[Removed Lines]",
          "10986:   header[0] = 0x80u | (unsigned char)((unsigned)opcode & 0xf);",
          "10993:   if (dataLen < 126) {",
          "10995:    header[1] = (unsigned char)dataLen;",
          "10996:    headerLen = 2;",
          "10997:   } else if (dataLen <= 0xFFFF) {",
          "10999:    uint16_t len = htons((uint16_t)dataLen);",
          "11000:    header[1] = 126;",
          "11001:    memcpy(header + 2, &len, 2);",
          "11002:    headerLen = 4;",
          "11003:   } else {",
          "11005:    uint32_t len1 = htonl((uint32_t)((uint64_t)dataLen >> 32));",
          "11006:    uint32_t len2 = htonl((uint32_t)(dataLen & 0xFFFFFFFFu));",
          "11007:    header[1] = 127;",
          "11008:    memcpy(header + 2, &len1, 4);",
          "11009:    memcpy(header + 6, &len2, 4);",
          "11010:    headerLen = 10;",
          "11011:   }",
          "11013:   if (masking_key) {",
          "11015:    header[1] |= 0x80;",
          "11016:    memcpy(header + headerLen, &masking_key, 4);",
          "11017:    headerLen += 4;",
          "11018:   }",
          "11032:   (void)mg_lock_connection(conn);",
          "11034:   retval = mg_write(conn, header, headerLen);",
          "11035:   if (dataLen > 0) {",
          "11036:    retval = mg_write(conn, data, dataLen);",
          "11037:   }",
          "11040:   mg_unlock_connection(conn);",
          "11042:   return retval;",
          "11043:  }",
          "11045:  int mg_websocket_write(struct mg_connection * conn,",
          "11046:                         int opcode,",
          "11047:                         const char *data,",
          "11048:                         size_t dataLen)",
          "11049:  {",
          "11050:   return mg_websocket_write_exec(conn, opcode, data, dataLen, 0);",
          "11051:  }",
          "11054:  static void mask_data(const char *in,",
          "11055:                        size_t in_len,",
          "11056:                        uint32_t masking_key,",
          "11057:                        char *out)",
          "11058:  {",
          "11059:   size_t i = 0;",
          "11061:   i = 0;",
          "11062:   if ((in_len > 3) && ((ptrdiff_t)in % 4) == 0) {",
          "11064:    while (i < (in_len - 3)) {",
          "11067:     i += 4;",
          "11068:    }",
          "11070:   if (i != in_len) {",
          "11072:    while (i < in_len) {",
          "11075:         ^ *(((uint8_t *)&masking_key) + (i % 4));",
          "11076:     i++;",
          "11077:    }",
          "11082:  int mg_websocket_client_write(struct mg_connection * conn,",
          "11083:                                int opcode,",
          "11084:                                const char *data,",
          "11085:                                size_t dataLen)",
          "11086:  {",
          "11087:   int retval = -1;",
          "11088:   char *masked_data =",
          "11089:       (char *)mg_malloc_ctx(((dataLen + 7) / 4) * 4, conn->ctx);",
          "11090:   uint32_t masking_key = (uint32_t)get_random();",
          "11092:   if (masked_data == NULL) {",
          "11094:    mg_cry(conn,",
          "11095:           \"Cannot allocate buffer for masked websocket response: \"",
          "11096:           \"Out of memory\");",
          "11097:    return -1;",
          "11098:   }",
          "11100:   mask_data(data, dataLen, masking_key, masked_data);",
          "11102:   retval = mg_websocket_write_exec(",
          "11103:       conn, opcode, masked_data, dataLen, masking_key);",
          "11104:   mg_free(masked_data);",
          "11106:   return retval;",
          "11107:  }",
          "11110:  static void handle_websocket_request(",
          "11111:      struct mg_connection * conn,",
          "11112:      const char *path,",
          "11113:      int is_callback_resource,",
          "11114:      struct mg_websocket_subprotocols *subprotocols,",
          "11115:      mg_websocket_connect_handler ws_connect_handler,",
          "11116:      mg_websocket_ready_handler ws_ready_handler,",
          "11117:      mg_websocket_data_handler ws_data_handler,",
          "11118:      mg_websocket_close_handler ws_close_handler,",
          "11119:      void *cbData)",
          "11120:  {",
          "11121:   const char *websock_key = mg_get_header(conn, \"Sec-WebSocket-Key\");",
          "11122:   const char *version = mg_get_header(conn, \"Sec-WebSocket-Version\");",
          "11123:   int lua_websock = 0;",
          "11126:   (void)path;",
          "11131:   if (!websock_key) {",
          "11138:    const char *key1 = mg_get_header(conn, \"Sec-WebSocket-Key1\");",
          "11139:    const char *key2 = mg_get_header(conn, \"Sec-WebSocket-Key2\");",
          "11140:    char key3[8];",
          "11142:    if ((key1 != NULL) && (key2 != NULL)) {",
          "11144:     conn->content_len = 8;",
          "11145:     if (8 == mg_read(conn, key3, 8)) {",
          "11147:      mg_send_http_error(conn,",
          "11148:                         426,",
          "11149:                         \"%s\",",
          "11150:                         \"Protocol upgrade to RFC 6455 required\");",
          "11151:      return;",
          "11152:     }",
          "11155:    mg_send_http_error(conn, 400, \"%s\", \"Malformed websocket request\");",
          "11156:    return;",
          "11161:   if ((version == NULL) || (strcmp(version, \"13\") != 0)) {",
          "11163:    mg_send_http_error(conn, 426, \"%s\", \"Protocol upgrade required\");",
          "11164:    return;",
          "11165:   }",
          "11171:   if (is_callback_resource) {",
          "11173:    const char *protocols[64]; // max 64 headers",
          "11174:    int nbSubprotocolHeader = get_req_headers(&conn->request_info,",
          "11175:                                              \"Sec-WebSocket-Protocol\",",
          "11176:                                              protocols,",
          "11177:                                              64);",
          "11178:    if ((nbSubprotocolHeader > 0) && subprotocols) {",
          "11179:     int cnt = 0;",
          "11180:     int idx;",
          "11181:     unsigned long len;",
          "11182:     const char *sep, *curSubProtocol,",
          "11188:      const char *protocol = protocols[cnt];",
          "11190:      do {",
          "11191:       sep = strchr(protocol, ',');",
          "11192:       curSubProtocol = protocol;",
          "11193:       len = sep ? (unsigned long)(sep - protocol)",
          "11194:                 : (unsigned long)strlen(protocol);",
          "11195:       while (sep && isspace(*++sep))",
          "11196:        ; // ignore leading whitespaces",
          "11197:       protocol = sep;",
          "11200:       for (idx = 0; idx < subprotocols->nb_subprotocols;",
          "11201:            idx++) {",
          "11202:        if ((strlen(subprotocols->subprotocols[idx]) == len)",
          "11203:            && (strncmp(curSubProtocol,",
          "11204:                        subprotocols->subprotocols[idx],",
          "11205:                        len) == 0)) {",
          "11206:         acceptedWebSocketSubprotocol =",
          "11207:             subprotocols->subprotocols[idx];",
          "11208:         break;",
          "11209:        }",
          "11211:      } while (sep && !acceptedWebSocketSubprotocol);",
          "11212:     } while (++cnt < nbSubprotocolHeader",
          "11213:              && !acceptedWebSocketSubprotocol);",
          "11215:     conn->request_info.acceptedWebSocketSubprotocol =",
          "11216:         acceptedWebSocketSubprotocol;",
          "11217:    } else if (nbSubprotocolHeader > 0) {",
          "11219:     const char *protocol = protocols[0];",
          "11224:     const char *sep = strrchr(protocol, ',');",
          "11225:     if (sep == NULL) {",
          "11227:      conn->request_info.acceptedWebSocketSubprotocol = protocol;",
          "11228:     } else {",
          "11237:      while (isspace(*++sep)) {",
          "11240:      conn->request_info.acceptedWebSocketSubprotocol = sep;",
          "11244:    if ((ws_connect_handler != NULL)",
          "11245:        && (ws_connect_handler(conn, cbData) != 0)) {",
          "11251:     return;",
          "11252:    }",
          "11256:   else {",
          "11258:    if (conn->ctx->config[LUA_WEBSOCKET_EXTENSIONS]) {",
          "11259:     lua_websock = match_prefix(",
          "11260:         conn->ctx->config[LUA_WEBSOCKET_EXTENSIONS],",
          "11261:         strlen(conn->ctx->config[LUA_WEBSOCKET_EXTENSIONS]),",
          "11262:         path);",
          "11263:    }",
          "11265:    if (lua_websock) {",
          "11267:     conn->lua_websocket_state = lua_websocket_new(path, conn);",
          "11268:     if (!conn->lua_websocket_state) {",
          "11270:      return;",
          "11271:     }",
          "11277:   if (!is_callback_resource && !lua_websock) {",
          "11282:    mg_send_http_error(conn, 404, \"%s\", \"Not found\");",
          "11283:    return;",
          "11284:   }",
          "11287:   if (!send_websocket_handshake(conn, websock_key)) {",
          "11288:    mg_send_http_error(conn, 500, \"%s\", \"Websocket handshake failed\");",
          "11289:    return;",
          "11290:   }",
          "11293:   if (is_callback_resource) {",
          "11294:    if (ws_ready_handler != NULL) {",
          "11295:     ws_ready_handler(conn, cbData);",
          "11296:    }",
          "11298:   } else if (lua_websock) {",
          "11299:    if (!lua_websocket_ready(conn, conn->lua_websocket_state)) {",
          "11301:     return;",
          "11302:    }",
          "11303: #endif",
          "11307:   if (is_callback_resource) {",
          "11308:    read_websocket(conn, ws_data_handler, cbData);",
          "11310:   } else if (lua_websock) {",
          "11311:    read_websocket(conn, lua_websocket_data, conn->lua_websocket_state);",
          "11313:   }",
          "11316:   if (ws_close_handler) {",
          "11317:    ws_close_handler(conn, cbData);",
          "11318:   }",
          "11322:  static int is_websocket_protocol(const struct mg_connection *conn)",
          "11323:  {",
          "11324:   const char *upgrade, *connection;",
          "11332:   upgrade = mg_get_header(conn, \"Upgrade\");",
          "11333:   if (upgrade == NULL) {",
          "11334:    return 0; /* fail early, don't waste time checking other header",
          "11337:   }",
          "11338:   if (!mg_strcasestr(upgrade, \"websocket\")) {",
          "11339:    return 0;",
          "11340:   }",
          "11342:   connection = mg_get_header(conn, \"Connection\");",
          "11343:   if (connection == NULL) {",
          "11344:    return 0;",
          "11345:   }",
          "11346:   if (!mg_strcasestr(connection, \"upgrade\")) {",
          "11347:    return 0;",
          "11348:   }",
          "11357:   return 1;",
          "11358:  }",
          "11362:  static int isbyte(int n)",
          "11363:  {",
          "11364:   return (n >= 0) && (n <= 255);",
          "11365:  }",
          "11368:  static int parse_net(const char *spec, uint32_t *net, uint32_t *mask)",
          "11369:  {",
          "11370:   int n, a, b, c, d, slash = 32, len = 0;",
          "11372:   if (((sscanf(spec, \"%d.%d.%d.%d/%d%n\", &a, &b, &c, &d, &slash, &n) == 5)",
          "11373:        || (sscanf(spec, \"%d.%d.%d.%d%n\", &a, &b, &c, &d, &n) == 4))",
          "11374:       && isbyte(a) && isbyte(b) && isbyte(c) && isbyte(d) && (slash >= 0)",
          "11375:       && (slash < 33)) {",
          "11376:    len = n;",
          "11378:           | ((uint32_t)c << 8) | (uint32_t)d;",
          "11380:   }",
          "11382:   return len;",
          "11386:  static int set_throttle(const char *spec,",
          "11387:                          uint32_t remote_ip,",
          "11388:                          const char *uri)",
          "11389:  {",
          "11390:   int throttle = 0;",
          "11391:   struct vec vec, val;",
          "11392:   uint32_t net, mask;",
          "11393:   char mult;",
          "11394:   double v;",
          "11396:   while ((spec = next_option(spec, &vec, &val)) != NULL) {",
          "11397:    mult = ',';",
          "11398:    if ((val.ptr == NULL) || (sscanf(val.ptr, \"%lf%c\", &v, &mult) < 1)",
          "11399:        || (v < 0) || ((lowercase(&mult) != 'k')",
          "11400:                       && (lowercase(&mult) != 'm') && (mult != ','))) {",
          "11401:     continue;",
          "11402:    }",
          "11403:    v *= (lowercase(&mult) == 'k')",
          "11404:             ? 1024",
          "11405:             : ((lowercase(&mult) == 'm') ? 1048576 : 1);",
          "11406:    if (vec.len == 1 && vec.ptr[0] == '*') {",
          "11407:     throttle = (int)v;",
          "11408:    } else if (parse_net(vec.ptr, &net, &mask) > 0) {",
          "11409:     if ((remote_ip & mask) == net) {",
          "11410:      throttle = (int)v;",
          "11411:     }",
          "11412:    } else if (match_prefix(vec.ptr, vec.len, uri) > 0) {",
          "11417:   return throttle;",
          "11421:  static uint32_t get_remote_ip(const struct mg_connection *conn)",
          "11422:  {",
          "11423:   if (!conn) {",
          "11424:    return 0;",
          "11425:   }",
          "11426:   return ntohl(*(const uint32_t *)&conn->client.rsa.sin.sin_addr);",
          "",
          "[Added Lines]",
          "11025:  header[0] = 0x80u | (unsigned char)((unsigned)opcode & 0xf);",
          "11032:  if (dataLen < 126) {",
          "11034:   header[1] = (unsigned char)dataLen;",
          "11035:   headerLen = 2;",
          "11036:  } else if (dataLen <= 0xFFFF) {",
          "11038:   uint16_t len = htons((uint16_t)dataLen);",
          "11039:   header[1] = 126;",
          "11040:   memcpy(header + 2, &len, 2);",
          "11041:   headerLen = 4;",
          "11042:  } else {",
          "11044:   uint32_t len1 = htonl((uint32_t)((uint64_t)dataLen >> 32));",
          "11045:   uint32_t len2 = htonl((uint32_t)(dataLen & 0xFFFFFFFFu));",
          "11046:   header[1] = 127;",
          "11047:   memcpy(header + 2, &len1, 4);",
          "11048:   memcpy(header + 6, &len2, 4);",
          "11049:   headerLen = 10;",
          "11050:  }",
          "11052:  if (masking_key) {",
          "11054:   header[1] |= 0x80;",
          "11055:   memcpy(header + headerLen, &masking_key, 4);",
          "11056:   headerLen += 4;",
          "11057:  }",
          "11071:  (void)mg_lock_connection(conn);",
          "11073:  retval = mg_write(conn, header, headerLen);",
          "11074:  if (dataLen > 0) {",
          "11075:   retval = mg_write(conn, data, dataLen);",
          "11076:  }",
          "11079:  mg_unlock_connection(conn);",
          "11081:  return retval;",
          "11082: }",
          "11084: int",
          "11085: mg_websocket_write(struct mg_connection *conn,",
          "11086:                    int opcode,",
          "11087:                    const char *data,",
          "11088:                    size_t dataLen)",
          "11089: {",
          "11090:  return mg_websocket_write_exec(conn, opcode, data, dataLen, 0);",
          "11091: }",
          "11094: static void",
          "11095: mask_data(const char *in, size_t in_len, uint32_t masking_key, char *out)",
          "11096: {",
          "11097:  size_t i = 0;",
          "11099:  i = 0;",
          "11100:  if ((in_len > 3) && ((ptrdiff_t)in % 4) == 0) {",
          "11102:   while (i < (in_len - 3)) {",
          "11105:    i += 4;",
          "11107:  }",
          "11108:  if (i != in_len) {",
          "11110:   while (i < in_len) {",
          "11113:        ^ *(((uint8_t *)&masking_key) + (i % 4));",
          "11114:    i++;",
          "11117: }",
          "11120: int",
          "11121: mg_websocket_client_write(struct mg_connection *conn,",
          "11122:                           int opcode,",
          "11123:                           const char *data,",
          "11124:                           size_t dataLen)",
          "11125: {",
          "11126:  int retval = -1;",
          "11127:  char *masked_data =",
          "11128:      (char *)mg_malloc_ctx(((dataLen + 7) / 4) * 4, conn->ctx);",
          "11129:  uint32_t masking_key = (uint32_t)get_random();",
          "11131:  if (masked_data == NULL) {",
          "11133:   mg_cry(conn,",
          "11134:          \"Cannot allocate buffer for masked websocket response: \"",
          "11135:          \"Out of memory\");",
          "11136:   return -1;",
          "11137:  }",
          "11139:  mask_data(data, dataLen, masking_key, masked_data);",
          "11141:  retval = mg_websocket_write_exec(",
          "11142:      conn, opcode, masked_data, dataLen, masking_key);",
          "11143:  mg_free(masked_data);",
          "11145:  return retval;",
          "11146: }",
          "11149: static void",
          "11150: handle_websocket_request(struct mg_connection *conn,",
          "11151:                          const char *path,",
          "11152:                          int is_callback_resource,",
          "11153:                          struct mg_websocket_subprotocols *subprotocols,",
          "11154:                          mg_websocket_connect_handler ws_connect_handler,",
          "11155:                          mg_websocket_ready_handler ws_ready_handler,",
          "11156:                          mg_websocket_data_handler ws_data_handler,",
          "11157:                          mg_websocket_close_handler ws_close_handler,",
          "11158:                          void *cbData)",
          "11159: {",
          "11160:  const char *websock_key = mg_get_header(conn, \"Sec-WebSocket-Key\");",
          "11161:  const char *version = mg_get_header(conn, \"Sec-WebSocket-Version\");",
          "11162:  int lua_websock = 0;",
          "11165:  (void)path;",
          "11170:  if (!websock_key) {",
          "11177:   const char *key1 = mg_get_header(conn, \"Sec-WebSocket-Key1\");",
          "11178:   const char *key2 = mg_get_header(conn, \"Sec-WebSocket-Key2\");",
          "11179:   char key3[8];",
          "11181:   if ((key1 != NULL) && (key2 != NULL)) {",
          "11183:    conn->content_len = 8;",
          "11184:    if (8 == mg_read(conn, key3, 8)) {",
          "11186:     mg_send_http_error(conn,",
          "11187:                        426,",
          "11188:                        \"%s\",",
          "11189:                        \"Protocol upgrade to RFC 6455 required\");",
          "11190:     return;",
          "11194:   mg_send_http_error(conn, 400, \"%s\", \"Malformed websocket request\");",
          "11195:   return;",
          "11196:  }",
          "11200:  if ((version == NULL) || (strcmp(version, \"13\") != 0)) {",
          "11202:   mg_send_http_error(conn, 426, \"%s\", \"Protocol upgrade required\");",
          "11203:   return;",
          "11204:  }",
          "11210:  if (is_callback_resource) {",
          "11212:   const char *protocols[64]; // max 64 headers",
          "11213:   int nbSubprotocolHeader = get_req_headers(&conn->request_info,",
          "11214:                                             \"Sec-WebSocket-Protocol\",",
          "11215:                                             protocols,",
          "11216:                                             64);",
          "11217:   if ((nbSubprotocolHeader > 0) && subprotocols) {",
          "11218:    int cnt = 0;",
          "11219:    int idx;",
          "11220:    unsigned long len;",
          "11221:    const char *sep, *curSubProtocol,",
          "11226:    do {",
          "11227:     const char *protocol = protocols[cnt];",
          "11230:      sep = strchr(protocol, ',');",
          "11231:      curSubProtocol = protocol;",
          "11232:      len = sep ? (unsigned long)(sep - protocol)",
          "11233:                : (unsigned long)strlen(protocol);",
          "11234:      while (sep && isspace(*++sep))",
          "11235:       ; // ignore leading whitespaces",
          "11236:      protocol = sep;",
          "11239:      for (idx = 0; idx < subprotocols->nb_subprotocols; idx++) {",
          "11240:       if ((strlen(subprotocols->subprotocols[idx]) == len)",
          "11241:           && (strncmp(curSubProtocol,",
          "11242:                       subprotocols->subprotocols[idx],",
          "11243:                       len) == 0)) {",
          "11244:        acceptedWebSocketSubprotocol =",
          "11245:            subprotocols->subprotocols[idx];",
          "11246:        break;",
          "11249:     } while (sep && !acceptedWebSocketSubprotocol);",
          "11250:    } while (++cnt < nbSubprotocolHeader",
          "11251:             && !acceptedWebSocketSubprotocol);",
          "11253:    conn->request_info.acceptedWebSocketSubprotocol =",
          "11254:        acceptedWebSocketSubprotocol;",
          "11255:   } else if (nbSubprotocolHeader > 0) {",
          "11257:    const char *protocol = protocols[0];",
          "11262:    const char *sep = strrchr(protocol, ',');",
          "11263:    if (sep == NULL) {",
          "11265:     conn->request_info.acceptedWebSocketSubprotocol = protocol;",
          "11266:    } else {",
          "11275:     while (isspace(*++sep)) {",
          "11278:     conn->request_info.acceptedWebSocketSubprotocol = sep;",
          "11280:   }",
          "11282:   if ((ws_connect_handler != NULL)",
          "11283:       && (ws_connect_handler(conn, cbData) != 0)) {",
          "11289:    return;",
          "11291:  }",
          "11294:  else {",
          "11296:   if (conn->ctx->config[LUA_WEBSOCKET_EXTENSIONS]) {",
          "11297:    lua_websock =",
          "11298:        match_prefix(conn->ctx->config[LUA_WEBSOCKET_EXTENSIONS],",
          "11299:                     strlen(",
          "11300:                         conn->ctx->config[LUA_WEBSOCKET_EXTENSIONS]),",
          "11301:                     path);",
          "11302:   }",
          "11304:   if (lua_websock) {",
          "11306:    conn->lua_websocket_state = lua_websocket_new(path, conn);",
          "11307:    if (!conn->lua_websocket_state) {",
          "11309:     return;",
          "11312:  }",
          "11316:  if (!is_callback_resource && !lua_websock) {",
          "11321:   mg_send_http_error(conn, 404, \"%s\", \"Not found\");",
          "11322:   return;",
          "11323:  }",
          "11326:  if (!send_websocket_handshake(conn, websock_key)) {",
          "11327:   mg_send_http_error(conn, 500, \"%s\", \"Websocket handshake failed\");",
          "11328:   return;",
          "11329:  }",
          "11332:  if (is_callback_resource) {",
          "11333:   if (ws_ready_handler != NULL) {",
          "11334:    ws_ready_handler(conn, cbData);",
          "11335:   }",
          "11337:  } else if (lua_websock) {",
          "11338:   if (!lua_websocket_ready(conn, conn->lua_websocket_state)) {",
          "11340:    return;",
          "11342: #endif",
          "11343:  }",
          "11346:  if (is_callback_resource) {",
          "11347:   read_websocket(conn, ws_data_handler, cbData);",
          "11349:  } else if (lua_websock) {",
          "11350:   read_websocket(conn, lua_websocket_data, conn->lua_websocket_state);",
          "11352:  }",
          "11355:  if (ws_close_handler) {",
          "11356:   ws_close_handler(conn, cbData);",
          "11358: }",
          "11361: static int",
          "11362: is_websocket_protocol(const struct mg_connection *conn)",
          "11363: {",
          "11364:  const char *upgrade, *connection;",
          "11372:  upgrade = mg_get_header(conn, \"Upgrade\");",
          "11373:  if (upgrade == NULL) {",
          "11374:   return 0; /* fail early, don't waste time checking other header",
          "11377:  }",
          "11378:  if (!mg_strcasestr(upgrade, \"websocket\")) {",
          "11379:   return 0;",
          "11380:  }",
          "11382:  connection = mg_get_header(conn, \"Connection\");",
          "11383:  if (connection == NULL) {",
          "11384:   return 0;",
          "11385:  }",
          "11386:  if (!mg_strcasestr(connection, \"upgrade\")) {",
          "11387:   return 0;",
          "11388:  }",
          "11397:  return 1;",
          "11398: }",
          "11402: static int",
          "11403: isbyte(int n)",
          "11404: {",
          "11405:  return (n >= 0) && (n <= 255);",
          "11406: }",
          "11409: static int",
          "11410: parse_net(const char *spec, uint32_t *net, uint32_t *mask)",
          "11411: {",
          "11412:  int n, a, b, c, d, slash = 32, len = 0;",
          "11414:  if (((sscanf(spec, \"%d.%d.%d.%d/%d%n\", &a, &b, &c, &d, &slash, &n) == 5)",
          "11415:       || (sscanf(spec, \"%d.%d.%d.%d%n\", &a, &b, &c, &d, &n) == 4))",
          "11416:      && isbyte(a) && isbyte(b) && isbyte(c) && isbyte(d) && (slash >= 0)",
          "11417:      && (slash < 33)) {",
          "11418:   len = n;",
          "11420:          | (uint32_t)d;",
          "11424:  return len;",
          "11425: }",
          "11428: static int",
          "11429: set_throttle(const char *spec, uint32_t remote_ip, const char *uri)",
          "11430: {",
          "11431:  int throttle = 0;",
          "11432:  struct vec vec, val;",
          "11433:  uint32_t net, mask;",
          "11434:  char mult;",
          "11435:  double v;",
          "11437:  while ((spec = next_option(spec, &vec, &val)) != NULL) {",
          "11438:   mult = ',';",
          "11439:   if ((val.ptr == NULL) || (sscanf(val.ptr, \"%lf%c\", &v, &mult) < 1)",
          "11440:       || (v < 0) || ((lowercase(&mult) != 'k')",
          "11441:                      && (lowercase(&mult) != 'm') && (mult != ','))) {",
          "11442:    continue;",
          "11443:   }",
          "11444:   v *= (lowercase(&mult) == 'k')",
          "11445:            ? 1024",
          "11446:            : ((lowercase(&mult) == 'm') ? 1048576 : 1);",
          "11447:   if (vec.len == 1 && vec.ptr[0] == '*') {",
          "11448:    throttle = (int)v;",
          "11449:   } else if (parse_net(vec.ptr, &net, &mask) > 0) {",
          "11450:    if ((remote_ip & mask) == net) {",
          "11453:   } else if (match_prefix(vec.ptr, vec.len, uri) > 0) {",
          "11454:    throttle = (int)v;",
          "11458:  return throttle;",
          "11459: }",
          "11462: static uint32_t",
          "11463: get_remote_ip(const struct mg_connection *conn)",
          "11464: {",
          "11465:  if (!conn) {",
          "11466:   return 0;",
          "11468:  return ntohl(*(const uint32_t *)&conn->client.rsa.sin.sin_addr);",
          "11469: }",
          "",
          "---------------",
          "--- Hunk 49 ---",
          "[Context before]",
          "11434: #if defined(MG_LEGACY_INTERFACE)",
          "11528:  }",
          "11529: #endif",
          "11541:   }",
          "11543:  }",
          "11573:   if (conn) {",
          "11578: #if defined(USE_IPV6)",
          "11665:    return;",
          "11666:   }",
          "11694:      }",
          "11697:     }",
          "11698:    }",
          "11700:   }",
          "11744:   mg_unlock_context(ctx);",
          "11745:  }",
          "11879:      }",
          "11880:     }",
          "11881:    }",
          "11904:      }",
          "11905:     }",
          "11906:    }",
          "11927:      }",
          "11928:     }",
          "11929:    }",
          "11932:   }",
          "11934:  }",
          "11952: #if defined(USE_WEBSOCKET) && defined(MG_LEGACY_INTERFACE)",
          "11962:  }",
          "11972:  }",
          "11987:  }",
          "11988: #endif",
          "12042:   }",
          "12049:   }",
          "12148:     }",
          "12153:    }",
          "12154:   }",
          "12162: #if defined(USE_WEBSOCKET)",
          "12165: #else",
          "12166:  handler_type = REQUEST_HANDLER;",
          "12221: #if defined(NO_FILES)",
          "12223: #else",
          "12224:   if (conn->ctx->config[DOCUMENT_ROOT] == NULL) {",
          "12225: #endif",
          "12235: #if !defined(NO_FILES)",
          "12243: #endif",
          "12253:   }",
          "12306:    } else {",
          "12307: #if defined(USE_WEBSOCKET)",
          "12317: #endif",
          "12320:   }",
          "12323: #if defined(USE_WEBSOCKET)",
          "12342:    } else {",
          "12343: #if defined(MG_LEGACY_INTERFACE)",
          "12354: #else",
          "12355:    mg_send_http_error(conn, 404, \"%s\", \"Not found\");",
          "12356: #endif",
          "12360: #endif",
          "12362: #if defined(NO_FILES)",
          "12368: #else",
          "",
          "[Removed Lines]",
          "11440:  struct mg_upload_user_data {",
          "11441:   struct mg_connection *conn;",
          "11442:   const char *destination_dir;",
          "11443:   int num_uploaded_files;",
          "11444:  };",
          "11448:  static int mg_upload_field_found(const char *key,",
          "11449:                                   const char *filename,",
          "11450:                                   char *path,",
          "11451:                                   size_t pathlen,",
          "11452:                                   void *user_data)",
          "11453:  {",
          "11454:   int truncated = 0;",
          "11455:   struct mg_upload_user_data *fud =",
          "11456:       (struct mg_upload_user_data *)user_data;",
          "11457:   (void)key;",
          "11459:   if (!filename) {",
          "11460:    mg_cry(fud->conn, \"%s: No filename set\", __func__);",
          "11461:    return FORM_FIELD_STORAGE_ABORT;",
          "11462:   }",
          "11463:   mg_snprintf(fud->conn,",
          "11464:               &truncated,",
          "11465:               path,",
          "11466:               pathlen - 1,",
          "11467:               \"%s/%s\",",
          "11468:               fud->destination_dir,",
          "11469:               filename);",
          "11470:   if (!truncated) {",
          "11471:    mg_cry(fud->conn, \"%s: File path too long\", __func__);",
          "11472:    return FORM_FIELD_STORAGE_ABORT;",
          "11473:   }",
          "11474:   return FORM_FIELD_STORAGE_STORE;",
          "11475:  }",
          "11479:  static int mg_upload_field_get(const char *key,",
          "11480:                                 const char *value,",
          "11481:                                 size_t value_size,",
          "11482:                                 void *user_data)",
          "11483:  {",
          "11485:   (void)key;",
          "11486:   (void)value;",
          "11487:   (void)value_size;",
          "11488:   (void)user_data;",
          "11490:   return 0;",
          "11491:  }",
          "11495:  static int mg_upload_field_stored(const char *path,",
          "11496:                                    long long file_size,",
          "11497:                                    void *user_data)",
          "11498:  {",
          "11499:   struct mg_upload_user_data *fud =",
          "11500:       (struct mg_upload_user_data *)user_data;",
          "11501:   (void)file_size;",
          "11503:   fud->num_uploaded_files++;",
          "11504:   fud->conn->ctx->callbacks.upload(fud->conn, path);",
          "11506:   return 0;",
          "11507:  }",
          "11511:  int mg_upload(struct mg_connection * conn, const char *destination_dir)",
          "11512:  {",
          "11513:   struct mg_upload_user_data fud = {conn, destination_dir, 0};",
          "11514:   struct mg_form_data_handler fdh = {mg_upload_field_found,",
          "11515:                                      mg_upload_field_get,",
          "11516:                                      mg_upload_field_stored,",
          "11517:                                      0};",
          "11518:   int ret;",
          "11520:   fdh.user_data = (void *)&fud;",
          "11521:   ret = mg_handle_form_request(conn, &fdh);",
          "11523:   if (ret < 0) {",
          "11524:    mg_cry(conn, \"%s: Error while parsing the request\", __func__);",
          "11525:   }",
          "11527:   return fud.num_uploaded_files;",
          "11532:  static int get_first_ssl_listener_index(const struct mg_context *ctx)",
          "11533:  {",
          "11534:   unsigned int i;",
          "11535:   int idx = -1;",
          "11536:   if (ctx) {",
          "11537:    for (i = 0; ((idx == -1) && (i < ctx->num_listening_sockets));",
          "11538:         i++) {",
          "11539:     idx = ctx->listening_sockets[i].is_ssl ? ((int)(i)) : -1;",
          "11540:    }",
          "11542:   return idx;",
          "11546:  static void redirect_to_https_port(struct mg_connection * conn,",
          "11547:                                     int ssl_index)",
          "11548:  {",
          "11549:   char host[1025];",
          "11550:   const char *host_header;",
          "11551:   size_t hostlen;",
          "11553:   host_header = mg_get_header(conn, \"Host\");",
          "11554:   hostlen = sizeof(host);",
          "11555:   if (host_header != NULL) {",
          "11556:    char *pos;",
          "11558:    mg_strlcpy(host, host_header, hostlen);",
          "11559:    host[hostlen - 1] = '\\0';",
          "11560:    pos = strchr(host, ':');",
          "11561:    if (pos != NULL) {",
          "11563:    }",
          "11564:   } else {",
          "11567:    if (conn) {",
          "11568:     sockaddr_to_string(host, hostlen, &conn->client.lsa);",
          "11569:    }",
          "11570:   }",
          "11574:    mg_printf(",
          "11575:        conn,",
          "11576:        \"HTTP/1.1 302 Found\\r\\nLocation: https://%s:%d%s%s%s\\r\\n\\r\\n\",",
          "11577:        host,",
          "11579:        (conn->ctx->listening_sockets[ssl_index].lsa.sa.sa_family",
          "11580:         == AF_INET6)",
          "11581:            ? (int)ntohs(conn->ctx->listening_sockets[ssl_index]",
          "11582:                             .lsa.sin6.sin6_port)",
          "11583:            :",
          "11584: #endif",
          "11585:            (int)ntohs(conn->ctx->listening_sockets[ssl_index]",
          "11586:                           .lsa.sin.sin_port),",
          "11587:        conn->request_info.local_uri,",
          "11588:        (conn->request_info.query_string == NULL) ? \"\" : \"?\",",
          "11589:        (conn->request_info.query_string == NULL)",
          "11590:            ? \"\"",
          "11591:            : conn->request_info.query_string);",
          "11592:   }",
          "11593:  }",
          "11596:  static void mg_set_handler_type(",
          "11597:      struct mg_context * ctx,",
          "11598:      const char *uri,",
          "11599:      int handler_type,",
          "11600:      int is_delete_request,",
          "11601:      mg_request_handler handler,",
          "11602:      struct mg_websocket_subprotocols *subprotocols,",
          "11603:      mg_websocket_connect_handler connect_handler,",
          "11604:      mg_websocket_ready_handler ready_handler,",
          "11605:      mg_websocket_data_handler data_handler,",
          "11606:      mg_websocket_close_handler close_handler,",
          "11607:      mg_authorization_handler auth_handler,",
          "11608:      void *cbdata)",
          "11609:  {",
          "11610:   struct mg_handler_info *tmp_rh, **lastref;",
          "11611:   size_t urilen = strlen(uri);",
          "11613:   if (handler_type == WEBSOCKET_HANDLER) {",
          "11620:    if (handler != NULL) {",
          "11621:     return;",
          "11622:    }",
          "11623:    if (!is_delete_request && (connect_handler == NULL)",
          "11624:        && (ready_handler == NULL) && (data_handler == NULL)",
          "11625:        && (close_handler == NULL)) {",
          "11626:     return;",
          "11627:    }",
          "11628:    if (auth_handler != NULL) {",
          "11629:     return;",
          "11630:    }",
          "11631:   } else if (handler_type == REQUEST_HANDLER) {",
          "11637:    if ((connect_handler != NULL) || (ready_handler != NULL)",
          "11638:        || (data_handler != NULL) || (close_handler != NULL)) {",
          "11639:     return;",
          "11640:    }",
          "11641:    if (!is_delete_request && (handler == NULL)) {",
          "11642:     return;",
          "11643:    }",
          "11644:    if (auth_handler != NULL) {",
          "11645:     return;",
          "11646:    }",
          "11652:    if (handler != NULL) {",
          "11653:     return;",
          "11654:    }",
          "11655:    if ((connect_handler != NULL) || (ready_handler != NULL)",
          "11656:        || (data_handler != NULL) || (close_handler != NULL)) {",
          "11657:     return;",
          "11658:    }",
          "11659:    if (!is_delete_request && (auth_handler == NULL)) {",
          "11660:     return;",
          "11661:    }",
          "11662:   }",
          "11664:   if (!ctx) {",
          "11668:   mg_lock_context(ctx);",
          "11671:   lastref = &(ctx->handlers);",
          "11672:   for (tmp_rh = ctx->handlers; tmp_rh != NULL; tmp_rh = tmp_rh->next) {",
          "11673:    if (tmp_rh->handler_type == handler_type) {",
          "11674:     if ((urilen == tmp_rh->uri_len) && !strcmp(tmp_rh->uri, uri)) {",
          "11675:      if (!is_delete_request) {",
          "11677:       if (handler_type == REQUEST_HANDLER) {",
          "11678:        tmp_rh->handler = handler;",
          "11679:       } else if (handler_type == WEBSOCKET_HANDLER) {",
          "11680:        tmp_rh->subprotocols = subprotocols;",
          "11681:        tmp_rh->connect_handler = connect_handler;",
          "11682:        tmp_rh->ready_handler = ready_handler;",
          "11683:        tmp_rh->data_handler = data_handler;",
          "11684:        tmp_rh->close_handler = close_handler;",
          "11686:        tmp_rh->auth_handler = auth_handler;",
          "11687:       }",
          "11688:       tmp_rh->cbdata = cbdata;",
          "11689:      } else {",
          "11692:       mg_free(tmp_rh->uri);",
          "11693:       mg_free(tmp_rh);",
          "11695:      mg_unlock_context(ctx);",
          "11696:      return;",
          "11699:    lastref = &(tmp_rh->next);",
          "11702:   if (is_delete_request) {",
          "11705:    mg_unlock_context(ctx);",
          "11706:    return;",
          "11707:   }",
          "11709:   tmp_rh = (struct mg_handler_info *)",
          "11710:       mg_calloc_ctx(sizeof(struct mg_handler_info), 1, ctx);",
          "11711:   if (tmp_rh == NULL) {",
          "11712:    mg_unlock_context(ctx);",
          "11713:    mg_cry(fc(ctx),",
          "11714:           \"%s\",",
          "11715:           \"Cannot create new request handler struct, OOM\");",
          "11716:    return;",
          "11717:   }",
          "11718:   tmp_rh->uri = mg_strdup(uri);",
          "11719:   if (!tmp_rh->uri) {",
          "11720:    mg_unlock_context(ctx);",
          "11721:    mg_free(tmp_rh);",
          "11722:    mg_cry(fc(ctx),",
          "11723:           \"%s\",",
          "11724:           \"Cannot create new request handler struct, OOM\");",
          "11725:    return;",
          "11726:   }",
          "11727:   tmp_rh->uri_len = urilen;",
          "11728:   if (handler_type == REQUEST_HANDLER) {",
          "11729:    tmp_rh->handler = handler;",
          "11730:   } else if (handler_type == WEBSOCKET_HANDLER) {",
          "11731:    tmp_rh->subprotocols = subprotocols;",
          "11732:    tmp_rh->connect_handler = connect_handler;",
          "11733:    tmp_rh->ready_handler = ready_handler;",
          "11734:    tmp_rh->data_handler = data_handler;",
          "11735:    tmp_rh->close_handler = close_handler;",
          "11737:    tmp_rh->auth_handler = auth_handler;",
          "11738:   }",
          "11739:   tmp_rh->cbdata = cbdata;",
          "11740:   tmp_rh->handler_type = handler_type;",
          "11741:   tmp_rh->next = NULL;",
          "11748:  void mg_set_request_handler(struct mg_context * ctx,",
          "11749:                              const char *uri,",
          "11750:                              mg_request_handler handler,",
          "11751:                              void *cbdata)",
          "11752:  {",
          "11753:   mg_set_handler_type(ctx,",
          "11754:                       uri,",
          "11755:                       REQUEST_HANDLER,",
          "11756:                       handler == NULL,",
          "11757:                       handler,",
          "11758:                       NULL,",
          "11759:                       NULL,",
          "11760:                       NULL,",
          "11761:                       NULL,",
          "11762:                       NULL,",
          "11763:                       NULL,",
          "11764:                       cbdata);",
          "11765:  }",
          "11768:  void mg_set_websocket_handler(struct mg_context * ctx,",
          "11769:                                const char *uri,",
          "11770:                                mg_websocket_connect_handler connect_handler,",
          "11771:                                mg_websocket_ready_handler ready_handler,",
          "11772:                                mg_websocket_data_handler data_handler,",
          "11773:                                mg_websocket_close_handler close_handler,",
          "11774:                                void *cbdata)",
          "11775:  {",
          "11776:   mg_set_websocket_handler_with_subprotocols(ctx,",
          "11777:                                              uri,",
          "11778:                                              NULL,",
          "11779:                                              connect_handler,",
          "11780:                                              ready_handler,",
          "11781:                                              data_handler,",
          "11782:                                              close_handler,",
          "11783:                                              cbdata);",
          "11784:  }",
          "11787:  void mg_set_websocket_handler_with_subprotocols(",
          "11788:      struct mg_context * ctx,",
          "11789:      const char *uri,",
          "11790:      struct mg_websocket_subprotocols *subprotocols,",
          "11791:      mg_websocket_connect_handler connect_handler,",
          "11792:      mg_websocket_ready_handler ready_handler,",
          "11793:      mg_websocket_data_handler data_handler,",
          "11794:      mg_websocket_close_handler close_handler,",
          "11795:      void *cbdata)",
          "11796:  {",
          "11797:   int is_delete_request =",
          "11798:       (connect_handler == NULL) && (ready_handler == NULL)",
          "11799:       && (data_handler == NULL) && (close_handler == NULL);",
          "11800:   mg_set_handler_type(ctx,",
          "11801:                       uri,",
          "11802:                       WEBSOCKET_HANDLER,",
          "11803:                       is_delete_request,",
          "11804:                       NULL,",
          "11805:                       subprotocols,",
          "11806:                       connect_handler,",
          "11807:                       ready_handler,",
          "11808:                       data_handler,",
          "11809:                       close_handler,",
          "11810:                       NULL,",
          "11811:                       cbdata);",
          "11812:  }",
          "11815:  void mg_set_auth_handler(struct mg_context * ctx,",
          "11816:                           const char *uri,",
          "11817:                           mg_request_handler handler,",
          "11818:                           void *cbdata)",
          "11819:  {",
          "11820:   mg_set_handler_type(ctx,",
          "11821:                       uri,",
          "11822:                       AUTH_HANDLER,",
          "11823:                       handler == NULL,",
          "11824:                       NULL,",
          "11825:                       NULL,",
          "11826:                       NULL,",
          "11827:                       NULL,",
          "11828:                       NULL,",
          "11829:                       NULL,",
          "11830:                       handler,",
          "11831:                       cbdata);",
          "11832:  }",
          "11835:  static int get_request_handler(",
          "11836:      struct mg_connection * conn,",
          "11837:      int handler_type,",
          "11838:      mg_request_handler *handler,",
          "11839:      struct mg_websocket_subprotocols **subprotocols,",
          "11840:      mg_websocket_connect_handler *connect_handler,",
          "11841:      mg_websocket_ready_handler *ready_handler,",
          "11842:      mg_websocket_data_handler *data_handler,",
          "11843:      mg_websocket_close_handler *close_handler,",
          "11844:      mg_authorization_handler *auth_handler,",
          "11845:      void **cbdata)",
          "11846:  {",
          "11847:   const struct mg_request_info *request_info = mg_get_request_info(conn);",
          "11848:   if (request_info) {",
          "11849:    const char *uri = request_info->local_uri;",
          "11850:    size_t urilen = strlen(uri);",
          "11851:    struct mg_handler_info *tmp_rh;",
          "11853:    if (!conn || !conn->ctx) {",
          "11854:     return 0;",
          "11855:    }",
          "11857:    mg_lock_context(conn->ctx);",
          "11860:    for (tmp_rh = conn->ctx->handlers; tmp_rh != NULL;",
          "11861:         tmp_rh = tmp_rh->next) {",
          "11862:     if (tmp_rh->handler_type == handler_type) {",
          "11863:      if ((urilen == tmp_rh->uri_len)",
          "11864:          && !strcmp(tmp_rh->uri, uri)) {",
          "11865:       if (handler_type == WEBSOCKET_HANDLER) {",
          "11871:       } else if (handler_type == REQUEST_HANDLER) {",
          "11875:       }",
          "11877:       mg_unlock_context(conn->ctx);",
          "11878:       return 1;",
          "11884:    for (tmp_rh = conn->ctx->handlers; tmp_rh != NULL;",
          "11885:         tmp_rh = tmp_rh->next) {",
          "11886:     if (tmp_rh->handler_type == handler_type) {",
          "11887:      if ((tmp_rh->uri_len < urilen)",
          "11888:          && (uri[tmp_rh->uri_len] == '/')",
          "11889:          && (memcmp(tmp_rh->uri, uri, tmp_rh->uri_len) == 0)) {",
          "11890:       if (handler_type == WEBSOCKET_HANDLER) {",
          "11896:       } else if (handler_type == REQUEST_HANDLER) {",
          "11900:       }",
          "11902:       mg_unlock_context(conn->ctx);",
          "11903:       return 1;",
          "11909:    for (tmp_rh = conn->ctx->handlers; tmp_rh != NULL;",
          "11910:         tmp_rh = tmp_rh->next) {",
          "11911:     if (tmp_rh->handler_type == handler_type) {",
          "11912:      if (match_prefix(tmp_rh->uri, tmp_rh->uri_len, uri) > 0) {",
          "11913:       if (handler_type == WEBSOCKET_HANDLER) {",
          "11919:       } else if (handler_type == REQUEST_HANDLER) {",
          "11923:       }",
          "11925:       mg_unlock_context(conn->ctx);",
          "11926:       return 1;",
          "11931:    mg_unlock_context(conn->ctx);",
          "11941:  static int is_in_script_path(const struct mg_connection *conn,",
          "11942:                               const char *path)",
          "11943:  {",
          "11946:   (void)conn;",
          "11947:   (void)path;",
          "11948:   return 1;",
          "11949:  }",
          "11953:  static int deprecated_websocket_connect_wrapper(",
          "11954:      const struct mg_connection *conn, void *cbdata)",
          "11955:  {",
          "11956:   struct mg_callbacks *pcallbacks = (struct mg_callbacks *)cbdata;",
          "11957:   if (pcallbacks->websocket_connect) {",
          "11958:    return pcallbacks->websocket_connect(conn);",
          "11959:   }",
          "11961:   return 0;",
          "11965:  static void deprecated_websocket_ready_wrapper(struct mg_connection * conn,",
          "11966:                                                 void *cbdata)",
          "11967:  {",
          "11968:   struct mg_callbacks *pcallbacks = (struct mg_callbacks *)cbdata;",
          "11969:   if (pcallbacks->websocket_ready) {",
          "11970:    pcallbacks->websocket_ready(conn);",
          "11971:   }",
          "11975:  static int deprecated_websocket_data_wrapper(struct mg_connection * conn,",
          "11976:                                               int bits,",
          "11977:                                               char *data,",
          "11978:                                               size_t len,",
          "11979:                                               void *cbdata)",
          "11980:  {",
          "11981:   struct mg_callbacks *pcallbacks = (struct mg_callbacks *)cbdata;",
          "11982:   if (pcallbacks->websocket_data) {",
          "11983:    return pcallbacks->websocket_data(conn, bits, data, len);",
          "11984:   }",
          "11986:   return 1;",
          "11995:  static void handle_request(struct mg_connection * conn)",
          "11996:  {",
          "11997:   struct mg_request_info *ri = &conn->request_info;",
          "11998:   char path[PATH_MAX];",
          "11999:   int uri_len, ssl_index;",
          "12000:   int is_found = 0, is_script_resource = 0, is_websocket_request = 0,",
          "12001:       is_put_or_delete_request = 0, is_callback_resource = 0;",
          "12002:   int i;",
          "12003:   struct mg_file file = STRUCT_FILE_INITIALIZER;",
          "12004:   mg_request_handler callback_handler = NULL;",
          "12005:   struct mg_websocket_subprotocols *subprotocols;",
          "12006:   mg_websocket_connect_handler ws_connect_handler = NULL;",
          "12007:   mg_websocket_ready_handler ws_ready_handler = NULL;",
          "12008:   mg_websocket_data_handler ws_data_handler = NULL;",
          "12009:   mg_websocket_close_handler ws_close_handler = NULL;",
          "12010:   void *callback_data = NULL;",
          "12011:   mg_authorization_handler auth_handler = NULL;",
          "12012:   void *auth_callback_data = NULL;",
          "12013:   int handler_type;",
          "12014:   time_t curtime = time(NULL);",
          "12015:   char date[64];",
          "12017:   path[0] = 0;",
          "12021:   if ((conn->request_info.query_string = strchr(ri->request_uri, '?'))",
          "12022:       != NULL) {",
          "12024:   }",
          "12027:   if (!conn->client.is_ssl && conn->client.ssl_redir) {",
          "12028:    ssl_index = get_first_ssl_listener_index(conn->ctx);",
          "12029:    if (ssl_index >= 0) {",
          "12030:     redirect_to_https_port(conn, ssl_index);",
          "12031:    } else {",
          "12034:     mg_send_http_error(",
          "12035:         conn,",
          "12036:         503,",
          "12037:         \"%s\",",
          "12038:         \"Error: SSL forward not configured properly\");",
          "12039:     mg_cry(conn, \"Can not redirect to SSL, no SSL port available\");",
          "12040:    }",
          "12041:    return;",
          "12043:   uri_len = (int)strlen(ri->local_uri);",
          "12046:   if (should_decode_url(conn)) {",
          "12047:    mg_url_decode(",
          "12048:        ri->local_uri, uri_len, (char *)ri->local_uri, uri_len + 1, 0);",
          "12053:   remove_double_dots_and_double_slashes((char *)ri->local_uri);",
          "12056:   uri_len = (int)strlen(ri->local_uri);",
          "12057:   DEBUG_TRACE(\"URL: %s\", ri->local_uri);",
          "12060:   conn->throttle = set_throttle(conn->ctx->config[THROTTLE],",
          "12061:                                 get_remote_ip(conn),",
          "12062:                                 ri->local_uri);",
          "12065:   if (conn->ctx->callbacks.begin_request != NULL) {",
          "12069:    i = conn->ctx->callbacks.begin_request(conn);",
          "12070:    if (i > 0) {",
          "12073:     conn->status_code = i;",
          "12074:     discard_unread_request_data(conn);",
          "12075:     return;",
          "12076:    } else if (i == 0) {",
          "12078:    } else {",
          "12080:     return;",
          "12081:    }",
          "12082:   }",
          "12090:   if (!strcmp(ri->request_method, \"OPTIONS\")) {",
          "12094:    const char *cors_meth_cfg =",
          "12095:        conn->ctx->config[ACCESS_CONTROL_ALLOW_METHODS];",
          "12096:    const char *cors_orig_cfg =",
          "12097:        conn->ctx->config[ACCESS_CONTROL_ALLOW_ORIGIN];",
          "12098:    const char *cors_origin =",
          "12099:        get_header(ri->http_headers, ri->num_headers, \"Origin\");",
          "12100:    const char *cors_acrm = get_header(ri->http_headers,",
          "12101:                                       ri->num_headers,",
          "12102:                                       \"Access-Control-Request-Method\");",
          "12107:    if ((cors_meth_cfg != NULL) && (*cors_meth_cfg != 0)",
          "12108:        && (cors_orig_cfg != NULL) && (*cors_orig_cfg != 0)",
          "12109:        && (cors_origin != NULL) && (cors_acrm != NULL)) {",
          "12113:     const char *cors_acrh =",
          "12114:         get_header(ri->http_headers,",
          "12115:                    ri->num_headers,",
          "12116:                    \"Access-Control-Request-Headers\");",
          "12118:     gmt_time_string(date, sizeof(date), &curtime);",
          "12119:     mg_printf(conn,",
          "12120:               \"HTTP/1.1 200 OK\\r\\n\"",
          "12121:               \"Date: %s\\r\\n\"",
          "12122:               \"Access-Control-Allow-Origin: %s\\r\\n\"",
          "12123:               \"Access-Control-Allow-Methods: %s\\r\\n\"",
          "12124:               \"Content-Length: 0\\r\\n\"",
          "12125:               \"Connection: %s\\r\\n\",",
          "12126:               date,",
          "12127:               cors_orig_cfg,",
          "12128:               ((cors_meth_cfg[0] == '*') ? cors_acrm",
          "12129:                                          : cors_meth_cfg),",
          "12130:               suggest_connection_header(conn));",
          "12132:     if (cors_acrh != NULL) {",
          "12134:      const char *cors_hdr_cfg =",
          "12135:          conn->ctx->config[ACCESS_CONTROL_ALLOW_HEADERS];",
          "12137:      if ((cors_hdr_cfg != NULL) && (*cors_hdr_cfg != 0)) {",
          "12143:       mg_printf(conn,",
          "12144:                 \"Access-Control-Allow-Headers: %s\\r\\n\",",
          "12145:                 ((cors_hdr_cfg[0] == '*') ? cors_acrh",
          "12146:                                           : cors_hdr_cfg));",
          "12147:      }",
          "12149:     mg_printf(conn, \"Access-Control-Max-Age: 60\\r\\n\");",
          "12151:     mg_printf(conn, \"\\r\\n\");",
          "12152:     return;",
          "12161:   is_websocket_request = is_websocket_protocol(conn);",
          "12163:   handler_type =",
          "12164:       is_websocket_request ? WEBSOCKET_HANDLER : REQUEST_HANDLER;",
          "12169:   if (get_request_handler(conn,",
          "12170:                           handler_type,",
          "12171:                           &callback_handler,",
          "12172:                           &subprotocols,",
          "12173:                           &ws_connect_handler,",
          "12174:                           &ws_ready_handler,",
          "12175:                           &ws_data_handler,",
          "12176:                           &ws_close_handler,",
          "12177:                           NULL,",
          "12178:                           &callback_data)) {",
          "12183:    is_callback_resource = 1;",
          "12184:    is_script_resource = 1;",
          "12185:    is_put_or_delete_request = is_put_or_delete_method(conn);",
          "12186:   } else {",
          "12187:   no_callback_resource:",
          "12191:    is_callback_resource = 0;",
          "12192:    interpret_uri(conn,",
          "12193:                  path,",
          "12194:                  sizeof(path),",
          "12195:                  &file.stat,",
          "12196:                  &is_found,",
          "12197:                  &is_script_resource,",
          "12198:                  &is_websocket_request,",
          "12199:                  &is_put_or_delete_request);",
          "12200:   }",
          "12204:   if (get_request_handler(conn,",
          "12205:                           AUTH_HANDLER,",
          "12206:                           NULL,",
          "12207:                           NULL,",
          "12208:                           NULL,",
          "12209:                           NULL,",
          "12210:                           NULL,",
          "12211:                           NULL,",
          "12212:                           &auth_handler,",
          "12213:                           &auth_callback_data)) {",
          "12214:    if (!auth_handler(conn, auth_callback_data)) {",
          "12215:     return;",
          "12216:    }",
          "12217:   } else if (is_put_or_delete_request && !is_script_resource",
          "12218:              && !is_callback_resource) {",
          "12222:    if (1) {",
          "12228:     mg_send_http_error(conn,",
          "12229:                        405,",
          "12230:                        \"%s method not allowed\",",
          "12231:                        conn->request_info.request_method);",
          "12232:     return;",
          "12233:    }",
          "12239:    if (!is_authorized_for_put(conn)) {",
          "12240:     send_authorization_request(conn);",
          "12241:     return;",
          "12242:    }",
          "12245:   } else {",
          "12249:    if (!check_authorization(conn, path)) {",
          "12250:     send_authorization_request(conn);",
          "12251:     return;",
          "12252:    }",
          "12258:   if (is_callback_resource) {",
          "12259:    if (!is_websocket_request) {",
          "12260:     i = callback_handler(conn, callback_data);",
          "12261:     if (i > 0) {",
          "12265:      conn->status_code = i;",
          "12266:      discard_unread_request_data(conn);",
          "12267:     } else {",
          "12285:      interpret_uri(conn,",
          "12286:                    path,",
          "12287:                    sizeof(path),",
          "12288:                    &file.stat,",
          "12289:                    &is_found,",
          "12290:                    &is_script_resource,",
          "12291:                    &is_websocket_request,",
          "12292:                    &is_put_or_delete_request);",
          "12293:      callback_handler = NULL;",
          "12304:      goto no_callback_resource;",
          "12305:     }",
          "12308:     handle_websocket_request(conn,",
          "12309:                              path,",
          "12310:                              is_callback_resource,",
          "12311:                              subprotocols,",
          "12312:                              ws_connect_handler,",
          "12313:                              ws_ready_handler,",
          "12314:                              ws_data_handler,",
          "12315:                              ws_close_handler,",
          "12316:                              callback_data);",
          "12318:    }",
          "12319:    return;",
          "12324:   if (is_websocket_request) {",
          "12325:    if (is_script_resource) {",
          "12327:     if (is_in_script_path(conn, path)) {",
          "12329:      handle_websocket_request(conn,",
          "12330:                               path,",
          "12331:                               0 /* Lua Script */,",
          "12332:                               NULL,",
          "12333:                               NULL,",
          "12334:                               NULL,",
          "12335:                               NULL,",
          "12336:                               NULL,",
          "12337:                               &conn->ctx->callbacks);",
          "12338:     } else {",
          "12340:      mg_send_http_error(conn, 403, \"%s\", \"Forbidden\");",
          "12341:     }",
          "12344:     handle_websocket_request(",
          "12345:         conn,",
          "12346:         path,",
          "12347:         !is_script_resource /* could be deprecated global callback */,",
          "12348:         NULL,",
          "12349:         deprecated_websocket_connect_wrapper,",
          "12350:         deprecated_websocket_ready_wrapper,",
          "12351:         deprecated_websocket_data_wrapper,",
          "12352:         NULL,",
          "12353:         &conn->ctx->callbacks);",
          "12357:    }",
          "12358:    return;",
          "12359:   } else",
          "12366:    mg_send_http_error(conn, 404, \"%s\", \"Not Found\");",
          "",
          "[Added Lines]",
          "11482: struct mg_upload_user_data {",
          "11483:  struct mg_connection *conn;",
          "11484:  const char *destination_dir;",
          "11485:  int num_uploaded_files;",
          "11486: };",
          "11490: static int",
          "11491: mg_upload_field_found(const char *key,",
          "11492:                       const char *filename,",
          "11493:                       char *path,",
          "11494:                       size_t pathlen,",
          "11495:                       void *user_data)",
          "11496: {",
          "11497:  int truncated = 0;",
          "11498:  struct mg_upload_user_data *fud = (struct mg_upload_user_data *)user_data;",
          "11499:  (void)key;",
          "11501:  if (!filename) {",
          "11502:   mg_cry(fud->conn, \"%s: No filename set\", __func__);",
          "11503:   return FORM_FIELD_STORAGE_ABORT;",
          "11504:  }",
          "11505:  mg_snprintf(fud->conn,",
          "11506:              &truncated,",
          "11507:              path,",
          "11508:              pathlen - 1,",
          "11509:              \"%s/%s\",",
          "11510:              fud->destination_dir,",
          "11511:              filename);",
          "11512:  if (!truncated) {",
          "11513:   mg_cry(fud->conn, \"%s: File path too long\", __func__);",
          "11514:   return FORM_FIELD_STORAGE_ABORT;",
          "11515:  }",
          "11516:  return FORM_FIELD_STORAGE_STORE;",
          "11517: }",
          "11521: static int",
          "11522: mg_upload_field_get(const char *key,",
          "11523:                     const char *value,",
          "11524:                     size_t value_size,",
          "11525:                     void *user_data)",
          "11526: {",
          "11528:  (void)key;",
          "11529:  (void)value;",
          "11530:  (void)value_size;",
          "11531:  (void)user_data;",
          "11533:  return 0;",
          "11534: }",
          "11538: static int",
          "11539: mg_upload_field_stored(const char *path, long long file_size, void *user_data)",
          "11540: {",
          "11541:  struct mg_upload_user_data *fud = (struct mg_upload_user_data *)user_data;",
          "11542:  (void)file_size;",
          "11544:  fud->num_uploaded_files++;",
          "11545:  fud->conn->ctx->callbacks.upload(fud->conn, path);",
          "11547:  return 0;",
          "11548: }",
          "11552: int",
          "11553: mg_upload(struct mg_connection *conn, const char *destination_dir)",
          "11554: {",
          "11555:  struct mg_upload_user_data fud = {conn, destination_dir, 0};",
          "11556:  struct mg_form_data_handler fdh = {mg_upload_field_found,",
          "11557:                                     mg_upload_field_get,",
          "11558:                                     mg_upload_field_stored,",
          "11559:                                     0};",
          "11560:  int ret;",
          "11562:  fdh.user_data = (void *)&fud;",
          "11563:  ret = mg_handle_form_request(conn, &fdh);",
          "11565:  if (ret < 0) {",
          "11566:   mg_cry(conn, \"%s: Error while parsing the request\", __func__);",
          "11569:  return fud.num_uploaded_files;",
          "11570: }",
          "11574: static int",
          "11575: get_first_ssl_listener_index(const struct mg_context *ctx)",
          "11576: {",
          "11577:  unsigned int i;",
          "11578:  int idx = -1;",
          "11579:  if (ctx) {",
          "11580:   for (i = 0; ((idx == -1) && (i < ctx->num_listening_sockets)); i++) {",
          "11581:    idx = ctx->listening_sockets[i].is_ssl ? ((int)(i)) : -1;",
          "11584:  return idx;",
          "11585: }",
          "11588: static void",
          "11589: redirect_to_https_port(struct mg_connection *conn, int ssl_index)",
          "11590: {",
          "11591:  char host[1025];",
          "11592:  const char *host_header;",
          "11593:  size_t hostlen;",
          "11595:  host_header = mg_get_header(conn, \"Host\");",
          "11596:  hostlen = sizeof(host);",
          "11597:  if (host_header != NULL) {",
          "11598:   char *pos;",
          "11600:   mg_strlcpy(host, host_header, hostlen);",
          "11601:   host[hostlen - 1] = '\\0';",
          "11602:   pos = strchr(host, ':');",
          "11603:   if (pos != NULL) {",
          "11605:   }",
          "11606:  } else {",
          "11610:    sockaddr_to_string(host, hostlen, &conn->client.lsa);",
          "11611:   }",
          "11612:  }",
          "11615:  if (conn) {",
          "11616:   mg_printf(conn,",
          "11617:             \"HTTP/1.1 302 Found\\r\\nLocation: https://%s:%d%s%s%s\\r\\n\\r\\n\",",
          "11618:             host,",
          "11620:             (conn->ctx->listening_sockets[ssl_index].lsa.sa.sa_family",
          "11621:              == AF_INET6)",
          "11622:                 ? (int)ntohs(conn->ctx->listening_sockets[ssl_index]",
          "11623:                                  .lsa.sin6.sin6_port)",
          "11624:                 :",
          "11625: #endif",
          "11626:                 (int)ntohs(conn->ctx->listening_sockets[ssl_index]",
          "11627:                                .lsa.sin.sin_port),",
          "11628:             conn->request_info.local_uri,",
          "11629:             (conn->request_info.query_string == NULL) ? \"\" : \"?\",",
          "11630:             (conn->request_info.query_string == NULL)",
          "11631:                 ? \"\"",
          "11632:                 : conn->request_info.query_string);",
          "11633:  }",
          "11634: }",
          "11637: static void",
          "11638: mg_set_handler_type(struct mg_context *ctx,",
          "11639:                     const char *uri,",
          "11640:                     int handler_type,",
          "11641:                     int is_delete_request,",
          "11642:                     mg_request_handler handler,",
          "11643:                     struct mg_websocket_subprotocols *subprotocols,",
          "11644:                     mg_websocket_connect_handler connect_handler,",
          "11645:                     mg_websocket_ready_handler ready_handler,",
          "11646:                     mg_websocket_data_handler data_handler,",
          "11647:                     mg_websocket_close_handler close_handler,",
          "11648:                     mg_authorization_handler auth_handler,",
          "11649:                     void *cbdata)",
          "11650: {",
          "11651:  struct mg_handler_info *tmp_rh, **lastref;",
          "11652:  size_t urilen = strlen(uri);",
          "11654:  if (handler_type == WEBSOCKET_HANDLER) {",
          "11661:   if (handler != NULL) {",
          "11662:    return;",
          "11663:   }",
          "11664:   if (!is_delete_request && (connect_handler == NULL)",
          "11665:       && (ready_handler == NULL) && (data_handler == NULL)",
          "11666:       && (close_handler == NULL)) {",
          "11667:    return;",
          "11668:   }",
          "11669:   if (auth_handler != NULL) {",
          "11670:    return;",
          "11671:   }",
          "11672:  } else if (handler_type == REQUEST_HANDLER) {",
          "11678:   if ((connect_handler != NULL) || (ready_handler != NULL)",
          "11679:       || (data_handler != NULL) || (close_handler != NULL)) {",
          "11680:    return;",
          "11681:   }",
          "11682:   if (!is_delete_request && (handler == NULL)) {",
          "11683:    return;",
          "11684:   }",
          "11685:   if (auth_handler != NULL) {",
          "11686:    return;",
          "11687:   }",
          "11693:   if (handler != NULL) {",
          "11696:   if ((connect_handler != NULL) || (ready_handler != NULL)",
          "11697:       || (data_handler != NULL) || (close_handler != NULL)) {",
          "11698:    return;",
          "11699:   }",
          "11700:   if (!is_delete_request && (auth_handler == NULL)) {",
          "11701:    return;",
          "11702:   }",
          "11703:  }",
          "11705:  if (!ctx) {",
          "11706:   return;",
          "11707:  }",
          "11709:  mg_lock_context(ctx);",
          "11712:  lastref = &(ctx->handlers);",
          "11713:  for (tmp_rh = ctx->handlers; tmp_rh != NULL; tmp_rh = tmp_rh->next) {",
          "11714:   if (tmp_rh->handler_type == handler_type) {",
          "11715:    if ((urilen == tmp_rh->uri_len) && !strcmp(tmp_rh->uri, uri)) {",
          "11716:     if (!is_delete_request) {",
          "11718:      if (handler_type == REQUEST_HANDLER) {",
          "11719:       tmp_rh->handler = handler;",
          "11720:      } else if (handler_type == WEBSOCKET_HANDLER) {",
          "11721:       tmp_rh->subprotocols = subprotocols;",
          "11722:       tmp_rh->connect_handler = connect_handler;",
          "11723:       tmp_rh->ready_handler = ready_handler;",
          "11724:       tmp_rh->data_handler = data_handler;",
          "11725:       tmp_rh->close_handler = close_handler;",
          "11727:       tmp_rh->auth_handler = auth_handler;",
          "11729:      tmp_rh->cbdata = cbdata;",
          "11730:     } else {",
          "11733:      mg_free(tmp_rh->uri);",
          "11734:      mg_free(tmp_rh);",
          "11736:     mg_unlock_context(ctx);",
          "11737:     return;",
          "11740:   lastref = &(tmp_rh->next);",
          "11741:  }",
          "11743:  if (is_delete_request) {",
          "11746:   mg_unlock_context(ctx);",
          "11747:   return;",
          "11748:  }",
          "11750:  tmp_rh =",
          "11751:      (struct mg_handler_info *)mg_calloc_ctx(sizeof(struct mg_handler_info),",
          "11752:                                              1,",
          "11753:                                              ctx);",
          "11754:  if (tmp_rh == NULL) {",
          "11755:   mg_unlock_context(ctx);",
          "11756:   mg_cry(fc(ctx), \"%s\", \"Cannot create new request handler struct, OOM\");",
          "11757:   return;",
          "11758:  }",
          "11759:  tmp_rh->uri = mg_strdup(uri);",
          "11760:  if (!tmp_rh->uri) {",
          "11762:   mg_free(tmp_rh);",
          "11763:   mg_cry(fc(ctx), \"%s\", \"Cannot create new request handler struct, OOM\");",
          "11764:   return;",
          "11766:  tmp_rh->uri_len = urilen;",
          "11767:  if (handler_type == REQUEST_HANDLER) {",
          "11768:   tmp_rh->handler = handler;",
          "11769:  } else if (handler_type == WEBSOCKET_HANDLER) {",
          "11770:   tmp_rh->subprotocols = subprotocols;",
          "11771:   tmp_rh->connect_handler = connect_handler;",
          "11772:   tmp_rh->ready_handler = ready_handler;",
          "11773:   tmp_rh->data_handler = data_handler;",
          "11774:   tmp_rh->close_handler = close_handler;",
          "11776:   tmp_rh->auth_handler = auth_handler;",
          "11777:  }",
          "11778:  tmp_rh->cbdata = cbdata;",
          "11779:  tmp_rh->handler_type = handler_type;",
          "11780:  tmp_rh->next = NULL;",
          "11783:  mg_unlock_context(ctx);",
          "11784: }",
          "11787: void",
          "11788: mg_set_request_handler(struct mg_context *ctx,",
          "11789:                        const char *uri,",
          "11790:                        mg_request_handler handler,",
          "11791:                        void *cbdata)",
          "11792: {",
          "11793:  mg_set_handler_type(ctx,",
          "11794:                      uri,",
          "11795:                      REQUEST_HANDLER,",
          "11796:                      handler == NULL,",
          "11797:                      handler,",
          "11798:                      NULL,",
          "11799:                      NULL,",
          "11800:                      NULL,",
          "11801:                      NULL,",
          "11802:                      NULL,",
          "11803:                      NULL,",
          "11804:                      cbdata);",
          "11805: }",
          "11808: void",
          "11809: mg_set_websocket_handler(struct mg_context *ctx,",
          "11810:                          const char *uri,",
          "11811:                          mg_websocket_connect_handler connect_handler,",
          "11812:                          mg_websocket_ready_handler ready_handler,",
          "11813:                          mg_websocket_data_handler data_handler,",
          "11814:                          mg_websocket_close_handler close_handler,",
          "11815:                          void *cbdata)",
          "11816: {",
          "11817:  mg_set_websocket_handler_with_subprotocols(ctx,",
          "11818:                                             uri,",
          "11819:                                             NULL,",
          "11820:                                             connect_handler,",
          "11821:                                             ready_handler,",
          "11822:                                             data_handler,",
          "11823:                                             close_handler,",
          "11824:                                             cbdata);",
          "11825: }",
          "11828: void",
          "11829: mg_set_websocket_handler_with_subprotocols(",
          "11830:     struct mg_context *ctx,",
          "11831:     const char *uri,",
          "11832:     struct mg_websocket_subprotocols *subprotocols,",
          "11833:     mg_websocket_connect_handler connect_handler,",
          "11834:     mg_websocket_ready_handler ready_handler,",
          "11835:     mg_websocket_data_handler data_handler,",
          "11836:     mg_websocket_close_handler close_handler,",
          "11837:     void *cbdata)",
          "11838: {",
          "11839:  int is_delete_request = (connect_handler == NULL) && (ready_handler == NULL)",
          "11840:                          && (data_handler == NULL)",
          "11841:                          && (close_handler == NULL);",
          "11842:  mg_set_handler_type(ctx,",
          "11843:                      uri,",
          "11844:                      WEBSOCKET_HANDLER,",
          "11845:                      is_delete_request,",
          "11846:                      NULL,",
          "11847:                      subprotocols,",
          "11848:                      connect_handler,",
          "11849:                      ready_handler,",
          "11850:                      data_handler,",
          "11851:                      close_handler,",
          "11852:                      NULL,",
          "11853:                      cbdata);",
          "11854: }",
          "11857: void",
          "11858: mg_set_auth_handler(struct mg_context *ctx,",
          "11859:                     const char *uri,",
          "11860:                     mg_request_handler handler,",
          "11861:                     void *cbdata)",
          "11862: {",
          "11863:  mg_set_handler_type(ctx,",
          "11864:                      uri,",
          "11865:                      AUTH_HANDLER,",
          "11866:                      handler == NULL,",
          "11867:                      NULL,",
          "11868:                      NULL,",
          "11869:                      NULL,",
          "11870:                      NULL,",
          "11871:                      NULL,",
          "11872:                      NULL,",
          "11873:                      handler,",
          "11874:                      cbdata);",
          "11875: }",
          "11878: static int",
          "11879: get_request_handler(struct mg_connection *conn,",
          "11880:                     int handler_type,",
          "11881:                     mg_request_handler *handler,",
          "11882:                     struct mg_websocket_subprotocols **subprotocols,",
          "11883:                     mg_websocket_connect_handler *connect_handler,",
          "11884:                     mg_websocket_ready_handler *ready_handler,",
          "11885:                     mg_websocket_data_handler *data_handler,",
          "11886:                     mg_websocket_close_handler *close_handler,",
          "11887:                     mg_authorization_handler *auth_handler,",
          "11888:                     void **cbdata)",
          "11889: {",
          "11890:  const struct mg_request_info *request_info = mg_get_request_info(conn);",
          "11891:  if (request_info) {",
          "11892:   const char *uri = request_info->local_uri;",
          "11893:   size_t urilen = strlen(uri);",
          "11894:   struct mg_handler_info *tmp_rh;",
          "11896:   if (!conn || !conn->ctx) {",
          "11897:    return 0;",
          "11898:   }",
          "11900:   mg_lock_context(conn->ctx);",
          "11903:   for (tmp_rh = conn->ctx->handlers; tmp_rh != NULL;",
          "11904:        tmp_rh = tmp_rh->next) {",
          "11905:    if (tmp_rh->handler_type == handler_type) {",
          "11906:     if ((urilen == tmp_rh->uri_len) && !strcmp(tmp_rh->uri, uri)) {",
          "11907:      if (handler_type == WEBSOCKET_HANDLER) {",
          "11913:      } else if (handler_type == REQUEST_HANDLER) {",
          "11919:      mg_unlock_context(conn->ctx);",
          "11920:      return 1;",
          "11923:   }",
          "11926:   for (tmp_rh = conn->ctx->handlers; tmp_rh != NULL;",
          "11927:        tmp_rh = tmp_rh->next) {",
          "11928:    if (tmp_rh->handler_type == handler_type) {",
          "11929:     if ((tmp_rh->uri_len < urilen) && (uri[tmp_rh->uri_len] == '/')",
          "11930:         && (memcmp(tmp_rh->uri, uri, tmp_rh->uri_len) == 0)) {",
          "11931:      if (handler_type == WEBSOCKET_HANDLER) {",
          "11937:      } else if (handler_type == REQUEST_HANDLER) {",
          "11943:      mg_unlock_context(conn->ctx);",
          "11944:      return 1;",
          "11947:   }",
          "11950:   for (tmp_rh = conn->ctx->handlers; tmp_rh != NULL;",
          "11951:        tmp_rh = tmp_rh->next) {",
          "11952:    if (tmp_rh->handler_type == handler_type) {",
          "11953:     if (match_prefix(tmp_rh->uri, tmp_rh->uri_len, uri) > 0) {",
          "11954:      if (handler_type == WEBSOCKET_HANDLER) {",
          "11960:      } else if (handler_type == REQUEST_HANDLER) {",
          "11966:      mg_unlock_context(conn->ctx);",
          "11967:      return 1;",
          "11972:   mg_unlock_context(conn->ctx);",
          "11975: }",
          "11982: static int",
          "11983: is_in_script_path(const struct mg_connection *conn, const char *path)",
          "11984: {",
          "11987:  (void)conn;",
          "11988:  (void)path;",
          "11989:  return 1;",
          "11990: }",
          "11994: static int",
          "11995: deprecated_websocket_connect_wrapper(const struct mg_connection *conn,",
          "11996:                                      void *cbdata)",
          "11997: {",
          "11998:  struct mg_callbacks *pcallbacks = (struct mg_callbacks *)cbdata;",
          "11999:  if (pcallbacks->websocket_connect) {",
          "12000:   return pcallbacks->websocket_connect(conn);",
          "12003:  return 0;",
          "12004: }",
          "12007: static void",
          "12008: deprecated_websocket_ready_wrapper(struct mg_connection *conn, void *cbdata)",
          "12009: {",
          "12010:  struct mg_callbacks *pcallbacks = (struct mg_callbacks *)cbdata;",
          "12011:  if (pcallbacks->websocket_ready) {",
          "12012:   pcallbacks->websocket_ready(conn);",
          "12014: }",
          "12017: static int",
          "12018: deprecated_websocket_data_wrapper(struct mg_connection *conn,",
          "12019:                                   int bits,",
          "12020:                                   char *data,",
          "12021:                                   size_t len,",
          "12022:                                   void *cbdata)",
          "12023: {",
          "12024:  struct mg_callbacks *pcallbacks = (struct mg_callbacks *)cbdata;",
          "12025:  if (pcallbacks->websocket_data) {",
          "12026:   return pcallbacks->websocket_data(conn, bits, data, len);",
          "12029:  return 1;",
          "12030: }",
          "12038: static void",
          "12039: handle_request(struct mg_connection *conn)",
          "12040: {",
          "12041:  struct mg_request_info *ri = &conn->request_info;",
          "12042:  char path[PATH_MAX];",
          "12043:  int uri_len, ssl_index;",
          "12044:  int is_found = 0, is_script_resource = 0, is_websocket_request = 0,",
          "12045:      is_put_or_delete_request = 0, is_callback_resource = 0;",
          "12046:  int i;",
          "12047:  struct mg_file file = STRUCT_FILE_INITIALIZER;",
          "12048:  mg_request_handler callback_handler = NULL;",
          "12049:  struct mg_websocket_subprotocols *subprotocols;",
          "12050:  mg_websocket_connect_handler ws_connect_handler = NULL;",
          "12051:  mg_websocket_ready_handler ws_ready_handler = NULL;",
          "12052:  mg_websocket_data_handler ws_data_handler = NULL;",
          "12053:  mg_websocket_close_handler ws_close_handler = NULL;",
          "12054:  void *callback_data = NULL;",
          "12055:  mg_authorization_handler auth_handler = NULL;",
          "12056:  void *auth_callback_data = NULL;",
          "12057:  int handler_type;",
          "12058:  time_t curtime = time(NULL);",
          "12059:  char date[64];",
          "12061:  path[0] = 0;",
          "12065:  if ((conn->request_info.query_string = strchr(ri->request_uri, '?'))",
          "12066:      != NULL) {",
          "12068:  }",
          "12071:  if (!conn->client.is_ssl && conn->client.ssl_redir) {",
          "12072:   ssl_index = get_first_ssl_listener_index(conn->ctx);",
          "12073:   if (ssl_index >= 0) {",
          "12074:    redirect_to_https_port(conn, ssl_index);",
          "12075:   } else {",
          "12078:    mg_send_http_error(conn,",
          "12079:                       503,",
          "12080:                       \"%s\",",
          "12081:                       \"Error: SSL forward not configured properly\");",
          "12082:    mg_cry(conn, \"Can not redirect to SSL, no SSL port available\");",
          "12084:   return;",
          "12085:  }",
          "12086:  uri_len = (int)strlen(ri->local_uri);",
          "12089:  if (should_decode_url(conn)) {",
          "12090:   mg_url_decode(",
          "12091:       ri->local_uri, uri_len, (char *)ri->local_uri, uri_len + 1, 0);",
          "12092:  }",
          "12096:  remove_double_dots_and_double_slashes((char *)ri->local_uri);",
          "12099:  uri_len = (int)strlen(ri->local_uri);",
          "12100:  DEBUG_TRACE(\"URL: %s\", ri->local_uri);",
          "12103:  conn->throttle = set_throttle(conn->ctx->config[THROTTLE],",
          "12104:                                get_remote_ip(conn),",
          "12105:                                ri->local_uri);",
          "12108:  if (conn->ctx->callbacks.begin_request != NULL) {",
          "12112:   i = conn->ctx->callbacks.begin_request(conn);",
          "12113:   if (i > 0) {",
          "12116:    conn->status_code = i;",
          "12117:    discard_unread_request_data(conn);",
          "12118:    return;",
          "12119:   } else if (i == 0) {",
          "12121:   } else {",
          "12123:    return;",
          "12125:  }",
          "12133:  if (!strcmp(ri->request_method, \"OPTIONS\")) {",
          "12137:   const char *cors_meth_cfg =",
          "12138:       conn->ctx->config[ACCESS_CONTROL_ALLOW_METHODS];",
          "12139:   const char *cors_orig_cfg =",
          "12140:       conn->ctx->config[ACCESS_CONTROL_ALLOW_ORIGIN];",
          "12141:   const char *cors_origin =",
          "12142:       get_header(ri->http_headers, ri->num_headers, \"Origin\");",
          "12143:   const char *cors_acrm = get_header(ri->http_headers,",
          "12144:                                      ri->num_headers,",
          "12145:                                      \"Access-Control-Request-Method\");",
          "12150:   if ((cors_meth_cfg != NULL) && (*cors_meth_cfg != 0)",
          "12151:       && (cors_orig_cfg != NULL) && (*cors_orig_cfg != 0)",
          "12152:       && (cors_origin != NULL) && (cors_acrm != NULL)) {",
          "12156:    const char *cors_acrh =",
          "12157:        get_header(ri->http_headers,",
          "12158:                   ri->num_headers,",
          "12159:                   \"Access-Control-Request-Headers\");",
          "12161:    gmt_time_string(date, sizeof(date), &curtime);",
          "12162:    mg_printf(conn,",
          "12163:              \"HTTP/1.1 200 OK\\r\\n\"",
          "12164:              \"Date: %s\\r\\n\"",
          "12165:              \"Access-Control-Allow-Origin: %s\\r\\n\"",
          "12166:              \"Access-Control-Allow-Methods: %s\\r\\n\"",
          "12167:              \"Content-Length: 0\\r\\n\"",
          "12168:              \"Connection: %s\\r\\n\",",
          "12169:              date,",
          "12170:              cors_orig_cfg,",
          "12171:              ((cors_meth_cfg[0] == '*') ? cors_acrm : cors_meth_cfg),",
          "12172:              suggest_connection_header(conn));",
          "12174:    if (cors_acrh != NULL) {",
          "12176:     const char *cors_hdr_cfg =",
          "12177:         conn->ctx->config[ACCESS_CONTROL_ALLOW_HEADERS];",
          "12179:     if ((cors_hdr_cfg != NULL) && (*cors_hdr_cfg != 0)) {",
          "12185:      mg_printf(conn,",
          "12186:                \"Access-Control-Allow-Headers: %s\\r\\n\",",
          "12187:                ((cors_hdr_cfg[0] == '*') ? cors_acrh",
          "12188:                                          : cors_hdr_cfg));",
          "12191:    mg_printf(conn, \"Access-Control-Max-Age: 60\\r\\n\");",
          "12193:    mg_printf(conn, \"\\r\\n\");",
          "12194:    return;",
          "12196:  }",
          "12203:  is_websocket_request = is_websocket_protocol(conn);",
          "12205:  handler_type = is_websocket_request ? WEBSOCKET_HANDLER : REQUEST_HANDLER;",
          "12210:  if (get_request_handler(conn,",
          "12211:                          handler_type,",
          "12212:                          &callback_handler,",
          "12213:                          &subprotocols,",
          "12214:                          &ws_connect_handler,",
          "12215:                          &ws_ready_handler,",
          "12216:                          &ws_data_handler,",
          "12217:                          &ws_close_handler,",
          "12218:                          NULL,",
          "12219:                          &callback_data)) {",
          "12224:   is_callback_resource = 1;",
          "12225:   is_script_resource = 1;",
          "12226:   is_put_or_delete_request = is_put_or_delete_method(conn);",
          "12227:  } else {",
          "12228:  no_callback_resource:",
          "12232:   is_callback_resource = 0;",
          "12233:   interpret_uri(conn,",
          "12234:                 path,",
          "12235:                 sizeof(path),",
          "12236:                 &file.stat,",
          "12237:                 &is_found,",
          "12238:                 &is_script_resource,",
          "12239:                 &is_websocket_request,",
          "12240:                 &is_put_or_delete_request);",
          "12241:  }",
          "12245:  if (get_request_handler(conn,",
          "12246:                          AUTH_HANDLER,",
          "12247:                          NULL,",
          "12248:                          NULL,",
          "12249:                          NULL,",
          "12250:                          NULL,",
          "12251:                          NULL,",
          "12252:                          NULL,",
          "12253:                          &auth_handler,",
          "12254:                          &auth_callback_data)) {",
          "12255:   if (!auth_handler(conn, auth_callback_data)) {",
          "12256:    return;",
          "12257:   }",
          "12258:  } else if (is_put_or_delete_request && !is_script_resource",
          "12259:             && !is_callback_resource) {",
          "12263:   if (1) {",
          "12269:    mg_send_http_error(conn,",
          "12270:                       405,",
          "12271:                       \"%s method not allowed\",",
          "12272:                       conn->request_info.request_method);",
          "12273:    return;",
          "12274:   }",
          "12280:   if (!is_authorized_for_put(conn)) {",
          "12281:    send_authorization_request(conn);",
          "12282:    return;",
          "12283:   }",
          "12286:  } else {",
          "12290:   if (!check_authorization(conn, path)) {",
          "12291:    send_authorization_request(conn);",
          "12292:    return;",
          "12294:  }",
          "12299:  if (is_callback_resource) {",
          "12300:   if (!is_websocket_request) {",
          "12301:    i = callback_handler(conn, callback_data);",
          "12302:    if (i > 0) {",
          "12306:     conn->status_code = i;",
          "12307:     discard_unread_request_data(conn);",
          "12326:     interpret_uri(conn,",
          "12327:                   path,",
          "12328:                   sizeof(path),",
          "12329:                   &file.stat,",
          "12330:                   &is_found,",
          "12331:                   &is_script_resource,",
          "12332:                   &is_websocket_request,",
          "12333:                   &is_put_or_delete_request);",
          "12334:     callback_handler = NULL;",
          "12345:     goto no_callback_resource;",
          "12346:    }",
          "12347:   } else {",
          "12349:    handle_websocket_request(conn,",
          "12350:                             path,",
          "12351:                             is_callback_resource,",
          "12352:                             subprotocols,",
          "12353:                             ws_connect_handler,",
          "12354:                             ws_ready_handler,",
          "12355:                             ws_data_handler,",
          "12356:                             ws_close_handler,",
          "12357:                             callback_data);",
          "12360:   return;",
          "12361:  }",
          "12365:  if (is_websocket_request) {",
          "12366:   if (is_script_resource) {",
          "12368:    if (is_in_script_path(conn, path)) {",
          "12370:     handle_websocket_request(conn,",
          "12371:                              path,",
          "12372:                              0 /* Lua Script */,",
          "12373:                              NULL,",
          "12374:                              NULL,",
          "12375:                              NULL,",
          "12376:                              NULL,",
          "12377:                              NULL,",
          "12378:                              &conn->ctx->callbacks);",
          "12381:     mg_send_http_error(conn, 403, \"%s\", \"Forbidden\");",
          "12382:    }",
          "12383:   } else {",
          "12385:    handle_websocket_request(",
          "12386:        conn,",
          "12387:        path,",
          "12388:        !is_script_resource /* could be deprecated global callback */,",
          "12389:        NULL,",
          "12390:        deprecated_websocket_connect_wrapper,",
          "12391:        deprecated_websocket_ready_wrapper,",
          "12392:        deprecated_websocket_data_wrapper,",
          "12393:        NULL,",
          "12394:        &conn->ctx->callbacks);",
          "12398:   }",
          "12399:   return;",
          "12400:  } else",
          "12407:   mg_send_http_error(conn, 404, \"%s\", \"Not Found\");",
          "",
          "---------------",
          "--- Hunk 50 ---",
          "[Context before]",
          "12486: #endif",
          "12499: #ifdef USE_LUA",
          "12529: #endif",
          "12530: #if defined(USE_DUKTAPE)",
          "12542: #endif",
          "12543: #if !defined(NO_CGI)",
          "12570:   } else {",
          "12572:   }",
          "12573:  }",
          "12639: #if defined(USE_IPV6)",
          "12648: #endif",
          "12657: #if defined(USE_IPV6)",
          "12662: #else",
          "12664:   so->lsa.sin.sin_port = htons((uint16_t)port);",
          "12666: #endif",
          "12692: #if defined(USE_IPV6)",
          "12707:    }",
          "12727:   }",
          "12731:   return 0;",
          "12732:  }",
          "12739: #if defined(USE_IPV6)",
          "12741: #endif",
          "12777: #if !defined(NO_SSL)",
          "12786: #endif",
          "12795: #ifdef _WIN32",
          "12817: #else",
          "12818:   if (setsockopt(so.sock,",
          "12819:                  SOL_SOCKET,",
          "",
          "[Removed Lines]",
          "12487:  }",
          "12490:  static void handle_file_based_request(struct mg_connection * conn,",
          "12491:                                        const char *path,",
          "12492:                                        struct mg_file *file)",
          "12493:  {",
          "12494:   if (!conn || !conn->ctx) {",
          "12495:    return;",
          "12496:   }",
          "12498:   if (0) {",
          "12500:   } else if (match_prefix(",
          "12501:                  conn->ctx->config[LUA_SERVER_PAGE_EXTENSIONS],",
          "12502:                  strlen(conn->ctx->config[LUA_SERVER_PAGE_EXTENSIONS]),",
          "12503:                  path) > 0) {",
          "12504:    if (is_in_script_path(conn, path)) {",
          "12509:     handle_lsp_request(conn, path, file, NULL);",
          "12510:    } else {",
          "12512:     mg_send_http_error(conn, 403, \"%s\", \"Forbidden\");",
          "12513:    }",
          "12515:   } else if (match_prefix(conn->ctx->config[LUA_SCRIPT_EXTENSIONS],",
          "12516:                           strlen(",
          "12517:                               conn->ctx->config[LUA_SCRIPT_EXTENSIONS]),",
          "12518:                           path) > 0) {",
          "12519:    if (is_in_script_path(conn, path)) {",
          "12524:     mg_exec_lua_script(conn, path, NULL);",
          "12525:    } else {",
          "12527:     mg_send_http_error(conn, 403, \"%s\", \"Forbidden\");",
          "12528:    }",
          "12531:   } else if (match_prefix(",
          "12532:                  conn->ctx->config[DUKTAPE_SCRIPT_EXTENSIONS],",
          "12533:                  strlen(conn->ctx->config[DUKTAPE_SCRIPT_EXTENSIONS]),",
          "12534:                  path) > 0) {",
          "12535:    if (is_in_script_path(conn, path)) {",
          "12537:     mg_exec_duktape_script(conn, path);",
          "12538:    } else {",
          "12540:     mg_send_http_error(conn, 403, \"%s\", \"Forbidden\");",
          "12541:    }",
          "12544:   } else if (match_prefix(conn->ctx->config[CGI_EXTENSIONS],",
          "12545:                           strlen(conn->ctx->config[CGI_EXTENSIONS]),",
          "12546:                           path) > 0) {",
          "12547:    if (is_in_script_path(conn, path)) {",
          "12549:     handle_cgi_request(conn, path);",
          "12550:    } else {",
          "12552:     mg_send_http_error(conn, 403, \"%s\", \"Forbidden\");",
          "12553:    }",
          "12555:   } else if (match_prefix(conn->ctx->config[SSI_EXTENSIONS],",
          "12556:                           strlen(conn->ctx->config[SSI_EXTENSIONS]),",
          "12557:                           path) > 0) {",
          "12558:    if (is_in_script_path(conn, path)) {",
          "12559:     handle_ssi_file_request(conn, path, file);",
          "12560:    } else {",
          "12562:     mg_send_http_error(conn, 403, \"%s\", \"Forbidden\");",
          "12563:    }",
          "12564: #if !defined(NO_CACHING)",
          "12565:   } else if ((!conn->in_error_handler)",
          "12566:              && is_not_modified(conn, &file->stat)) {",
          "12568:    handle_not_modified_static_file_request(conn, file);",
          "12571:    handle_static_file_request(conn, path, file, NULL, NULL);",
          "12576:  static void close_all_listening_sockets(struct mg_context * ctx)",
          "12577:  {",
          "12578:   unsigned int i;",
          "12579:   if (!ctx) {",
          "12580:    return;",
          "12581:   }",
          "12583:   for (i = 0; i < ctx->num_listening_sockets; i++) {",
          "12584:    closesocket(ctx->listening_sockets[i].sock);",
          "12585:    ctx->listening_sockets[i].sock = INVALID_SOCKET;",
          "12586:   }",
          "12587:   mg_free(ctx->listening_sockets);",
          "12588:   ctx->listening_sockets = NULL;",
          "12589:   mg_free(ctx->listening_socket_fds);",
          "12590:   ctx->listening_socket_fds = NULL;",
          "12591:  }",
          "12608:  static int parse_port_string(const struct vec *vec,",
          "12609:                               struct socket *so,",
          "12610:                               int *ip_version)",
          "12611:  {",
          "12612:   unsigned int a, b, c, d, port;",
          "12613:   int ch, len;",
          "12614:   char *cb;",
          "12615: #if defined(USE_IPV6)",
          "12616:   char buf[100] = {0};",
          "12617: #endif",
          "12622:   memset(so, 0, sizeof(*so));",
          "12623:   so->lsa.sin.sin_family = AF_INET;",
          "12627:   port = 0;",
          "12628:   len = 0;",
          "12631:   if (sscanf(vec->ptr, \"%u.%u.%u.%u:%u%n\", &a, &b, &c, &d, &port, &len)",
          "12632:       == 5) {",
          "12634:    so->lsa.sin.sin_addr.s_addr =",
          "12635:        htonl((a << 24) | (b << 16) | (c << 8) | d);",
          "12636:    so->lsa.sin.sin_port = htons((uint16_t)port);",
          "12640:   } else if (sscanf(vec->ptr, \"[%49[^]]]:%u%n\", buf, &port, &len) == 2",
          "12641:              && mg_inet_pton(",
          "12642:                     AF_INET6, buf, &so->lsa.sin6, sizeof(so->lsa.sin6))) {",
          "12646:    so->lsa.sin6.sin6_port = htons((uint16_t)port);",
          "12650:   } else if ((vec->ptr[0] == '+')",
          "12651:              && (sscanf(vec->ptr + 1, \"%u%n\", &port, &len) == 1)) {",
          "12655:    len++;",
          "12659:    so->lsa.sin6.sin6_family = AF_INET6;",
          "12660:    so->lsa.sin6.sin6_port = htons((uint16_t)port);",
          "12668:   } else if (sscanf(vec->ptr, \"%u%n\", &port, &len) == 1) {",
          "12670:    so->lsa.sin.sin_port = htons((uint16_t)port);",
          "12673:   } else if ((cb = strchr(vec->ptr, ':')) != NULL) {",
          "12681:    if (mg_inet_pton(",
          "12682:            AF_INET, vec->ptr, &so->lsa.sin, sizeof(so->lsa.sin))) {",
          "12683:     if (sscanf(cb + 1, \"%u%n\", &port, &len) == 1) {",
          "12685:      so->lsa.sin.sin_family = AF_INET;",
          "12686:      so->lsa.sin.sin_port = htons((uint16_t)port);",
          "12687:      len += (int)(cb - vec->ptr) + 1;",
          "12688:     } else {",
          "12689:      port = 0;",
          "12690:      len = 0;",
          "12691:     }",
          "12693:    } else if (mg_inet_pton(AF_INET6,",
          "12694:                            vec->ptr,",
          "12695:                            &so->lsa.sin6,",
          "12696:                            sizeof(so->lsa.sin6))) {",
          "12697:     if (sscanf(cb + 1, \"%u%n\", &port, &len) == 1) {",
          "12699:      so->lsa.sin6.sin6_family = AF_INET6;",
          "12700:      so->lsa.sin.sin_port = htons((uint16_t)port);",
          "12701:      len += (int)(cb - vec->ptr) + 1;",
          "12702:     } else {",
          "12703:      port = 0;",
          "12704:      len = 0;",
          "12705:     }",
          "12706: #endif",
          "12709:   } else {",
          "12711:   }",
          "12715:   if ((len < 0) && ((unsigned)len > (unsigned)vec->len)) {",
          "12717:    return 0;",
          "12718:   }",
          "12720:   so->is_ssl = (ch == 's');",
          "12721:   so->ssl_redir = (ch == 'r');",
          "12724:   if (is_valid_port(port)",
          "12725:       && ((ch == '\\0') || (ch == 's') || (ch == 'r') || (ch == ','))) {",
          "12726:    return 1;",
          "12735:  static int set_ports_option(struct mg_context * ctx)",
          "12736:  {",
          "12737:   const char *list;",
          "12738:   int on = 1;",
          "12740:   int off = 0;",
          "12742:   struct vec vec;",
          "12743:   struct socket so, *ptr;",
          "12745:   struct pollfd *pfd;",
          "12746:   union usa usa;",
          "12747:   socklen_t len;",
          "12748:   int ip_version;",
          "12750:   int portsTotal = 0;",
          "12751:   int portsOk = 0;",
          "12753:   if (!ctx) {",
          "12754:    return 0;",
          "12755:   }",
          "12757:   memset(&so, 0, sizeof(so));",
          "12758:   memset(&usa, 0, sizeof(usa));",
          "12759:   len = sizeof(usa);",
          "12760:   list = ctx->config[LISTENING_PORTS];",
          "12762:   while ((list = next_option(list, &vec, NULL)) != NULL) {",
          "12764:    portsTotal++;",
          "12766:    if (!parse_port_string(&vec, &so, &ip_version)) {",
          "12767:     mg_cry(",
          "12768:         fc(ctx),",
          "12769:         \"%.*s: invalid port spec (entry %i). Expecting list of: %s\",",
          "12770:         (int)vec.len,",
          "12771:         vec.ptr,",
          "12772:         portsTotal,",
          "12773:         \"[IP_ADDRESS:]PORT[s|r]\");",
          "12774:     continue;",
          "12775:    }",
          "12778:    if (so.is_ssl && ctx->ssl_ctx == NULL) {",
          "12780:     mg_cry(fc(ctx),",
          "12781:            \"Cannot add SSL socket (entry %i). Is -ssl_certificate \"",
          "12782:            \"option set?\",",
          "12783:            portsTotal);",
          "12784:     continue;",
          "12785:    }",
          "12788:    if ((so.sock = socket(so.lsa.sa.sa_family, SOCK_STREAM, 6))",
          "12789:        == INVALID_SOCKET) {",
          "12791:     mg_cry(fc(ctx), \"cannot create socket (entry %i)\", portsTotal);",
          "12792:     continue;",
          "12793:    }",
          "12805:    if (setsockopt(so.sock,",
          "12806:                   SOL_SOCKET,",
          "12807:                   SO_EXCLUSIVEADDRUSE,",
          "12808:                   (SOCK_OPT_TYPE)&on,",
          "12809:                   sizeof(on)) != 0) {",
          "12812:     mg_cry(",
          "12813:         fc(ctx),",
          "12814:         \"cannot set socket option SO_EXCLUSIVEADDRUSE (entry %i)\",",
          "12815:         portsTotal);",
          "12816:    }",
          "",
          "[Added Lines]",
          "12528: }",
          "12531: static void",
          "12532: handle_file_based_request(struct mg_connection *conn,",
          "12533:                           const char *path,",
          "12534:                           struct mg_file *file)",
          "12535: {",
          "12536:  if (!conn || !conn->ctx) {",
          "12537:   return;",
          "12538:  }",
          "12540:  if (0) {",
          "12542:  } else if (match_prefix(conn->ctx->config[LUA_SERVER_PAGE_EXTENSIONS],",
          "12543:                          strlen(",
          "12544:                              conn->ctx->config[LUA_SERVER_PAGE_EXTENSIONS]),",
          "12545:                          path) > 0) {",
          "12546:   if (is_in_script_path(conn, path)) {",
          "12551:    handle_lsp_request(conn, path, file, NULL);",
          "12552:   } else {",
          "12554:    mg_send_http_error(conn, 403, \"%s\", \"Forbidden\");",
          "12555:   }",
          "12557:  } else if (match_prefix(conn->ctx->config[LUA_SCRIPT_EXTENSIONS],",
          "12558:                          strlen(conn->ctx->config[LUA_SCRIPT_EXTENSIONS]),",
          "12559:                          path) > 0) {",
          "12560:   if (is_in_script_path(conn, path)) {",
          "12565:    mg_exec_lua_script(conn, path, NULL);",
          "12566:   } else {",
          "12568:    mg_send_http_error(conn, 403, \"%s\", \"Forbidden\");",
          "12569:   }",
          "12572:  } else if (match_prefix(conn->ctx->config[DUKTAPE_SCRIPT_EXTENSIONS],",
          "12573:                          strlen(",
          "12574:                              conn->ctx->config[DUKTAPE_SCRIPT_EXTENSIONS]),",
          "12575:                          path) > 0) {",
          "12576:   if (is_in_script_path(conn, path)) {",
          "12578:    mg_exec_duktape_script(conn, path);",
          "12579:   } else {",
          "12581:    mg_send_http_error(conn, 403, \"%s\", \"Forbidden\");",
          "12582:   }",
          "12585:  } else if (match_prefix(conn->ctx->config[CGI_EXTENSIONS],",
          "12586:                          strlen(conn->ctx->config[CGI_EXTENSIONS]),",
          "12587:                          path) > 0) {",
          "12588:   if (is_in_script_path(conn, path)) {",
          "12590:    handle_cgi_request(conn, path);",
          "12591:   } else {",
          "12593:    mg_send_http_error(conn, 403, \"%s\", \"Forbidden\");",
          "12594:   }",
          "12596:  } else if (match_prefix(conn->ctx->config[SSI_EXTENSIONS],",
          "12597:                          strlen(conn->ctx->config[SSI_EXTENSIONS]),",
          "12598:                          path) > 0) {",
          "12599:   if (is_in_script_path(conn, path)) {",
          "12600:    handle_ssi_file_request(conn, path, file);",
          "12603:    mg_send_http_error(conn, 403, \"%s\", \"Forbidden\");",
          "12605: #if !defined(NO_CACHING)",
          "12606:  } else if ((!conn->in_error_handler)",
          "12607:             && is_not_modified(conn, &file->stat)) {",
          "12609:   handle_not_modified_static_file_request(conn, file);",
          "12611:  } else {",
          "12612:   handle_static_file_request(conn, path, file, NULL, NULL);",
          "12614: }",
          "12617: static void",
          "12618: close_all_listening_sockets(struct mg_context *ctx)",
          "12619: {",
          "12620:  unsigned int i;",
          "12621:  if (!ctx) {",
          "12622:   return;",
          "12623:  }",
          "12625:  for (i = 0; i < ctx->num_listening_sockets; i++) {",
          "12626:   closesocket(ctx->listening_sockets[i].sock);",
          "12627:   ctx->listening_sockets[i].sock = INVALID_SOCKET;",
          "12628:  }",
          "12629:  mg_free(ctx->listening_sockets);",
          "12630:  ctx->listening_sockets = NULL;",
          "12631:  mg_free(ctx->listening_socket_fds);",
          "12632:  ctx->listening_socket_fds = NULL;",
          "12633: }",
          "12650: static int",
          "12651: parse_port_string(const struct vec *vec, struct socket *so, int *ip_version)",
          "12652: {",
          "12653:  unsigned int a, b, c, d, port;",
          "12654:  int ch, len;",
          "12655:  char *cb;",
          "12656: #if defined(USE_IPV6)",
          "12657:  char buf[100] = {0};",
          "12658: #endif",
          "12663:  memset(so, 0, sizeof(*so));",
          "12664:  so->lsa.sin.sin_family = AF_INET;",
          "12668:  port = 0;",
          "12669:  len = 0;",
          "12672:  if (sscanf(vec->ptr, \"%u.%u.%u.%u:%u%n\", &a, &b, &c, &d, &port, &len)",
          "12673:      == 5) {",
          "12675:   so->lsa.sin.sin_addr.s_addr =",
          "12676:       htonl((a << 24) | (b << 16) | (c << 8) | d);",
          "12677:   so->lsa.sin.sin_port = htons((uint16_t)port);",
          "12681:  } else if (sscanf(vec->ptr, \"[%49[^]]]:%u%n\", buf, &port, &len) == 2",
          "12682:             && mg_inet_pton(",
          "12683:                    AF_INET6, buf, &so->lsa.sin6, sizeof(so->lsa.sin6))) {",
          "12687:   so->lsa.sin6.sin6_port = htons((uint16_t)port);",
          "12691:  } else if ((vec->ptr[0] == '+')",
          "12692:             && (sscanf(vec->ptr + 1, \"%u%n\", &port, &len) == 1)) {",
          "12696:   len++;",
          "12700:   so->lsa.sin6.sin6_family = AF_INET6;",
          "12701:   so->lsa.sin6.sin6_port = htons((uint16_t)port);",
          "12709:  } else if (sscanf(vec->ptr, \"%u%n\", &port, &len) == 1) {",
          "12711:   so->lsa.sin.sin_port = htons((uint16_t)port);",
          "12714:  } else if ((cb = strchr(vec->ptr, ':')) != NULL) {",
          "12722:   if (mg_inet_pton(",
          "12723:           AF_INET, vec->ptr, &so->lsa.sin, sizeof(so->lsa.sin))) {",
          "12724:    if (sscanf(cb + 1, \"%u%n\", &port, &len) == 1) {",
          "12726:     so->lsa.sin.sin_family = AF_INET;",
          "12727:     so->lsa.sin.sin_port = htons((uint16_t)port);",
          "12728:     len += (int)(cb - vec->ptr) + 1;",
          "12729:    } else {",
          "12730:     port = 0;",
          "12731:     len = 0;",
          "12732:    }",
          "12734:   } else if (mg_inet_pton(AF_INET6,",
          "12735:                           vec->ptr,",
          "12736:                           &so->lsa.sin6,",
          "12737:                           sizeof(so->lsa.sin6))) {",
          "12738:    if (sscanf(cb + 1, \"%u%n\", &port, &len) == 1) {",
          "12740:     so->lsa.sin6.sin6_family = AF_INET6;",
          "12741:     so->lsa.sin.sin_port = htons((uint16_t)port);",
          "12742:     len += (int)(cb - vec->ptr) + 1;",
          "12743:    } else {",
          "12744:     port = 0;",
          "12745:     len = 0;",
          "12747: #endif",
          "12750:  } else {",
          "12752:  }",
          "12756:  if ((len < 0) && ((unsigned)len > (unsigned)vec->len)) {",
          "12761:  so->is_ssl = (ch == 's');",
          "12762:  so->ssl_redir = (ch == 'r');",
          "12765:  if (is_valid_port(port)",
          "12766:      && ((ch == '\\0') || (ch == 's') || (ch == 'r') || (ch == ','))) {",
          "12767:   return 1;",
          "12768:  }",
          "12772:  return 0;",
          "12773: }",
          "12776: static int",
          "12777: set_ports_option(struct mg_context *ctx)",
          "12778: {",
          "12779:  const char *list;",
          "12780:  int on = 1;",
          "12782:  int off = 0;",
          "12784:  struct vec vec;",
          "12785:  struct socket so, *ptr;",
          "12787:  struct pollfd *pfd;",
          "12788:  union usa usa;",
          "12789:  socklen_t len;",
          "12790:  int ip_version;",
          "12792:  int portsTotal = 0;",
          "12793:  int portsOk = 0;",
          "12795:  if (!ctx) {",
          "12796:   return 0;",
          "12797:  }",
          "12799:  memset(&so, 0, sizeof(so));",
          "12800:  memset(&usa, 0, sizeof(usa));",
          "12801:  len = sizeof(usa);",
          "12802:  list = ctx->config[LISTENING_PORTS];",
          "12804:  while ((list = next_option(list, &vec, NULL)) != NULL) {",
          "12806:   portsTotal++;",
          "12808:   if (!parse_port_string(&vec, &so, &ip_version)) {",
          "12809:    mg_cry(fc(ctx),",
          "12810:           \"%.*s: invalid port spec (entry %i). Expecting list of: %s\",",
          "12811:           (int)vec.len,",
          "12812:           vec.ptr,",
          "12813:           portsTotal,",
          "12814:           \"[IP_ADDRESS:]PORT[s|r]\");",
          "12815:    continue;",
          "12816:   }",
          "12819:   if (so.is_ssl && ctx->ssl_ctx == NULL) {",
          "12821:    mg_cry(fc(ctx),",
          "12822:           \"Cannot add SSL socket (entry %i). Is -ssl_certificate \"",
          "12823:           \"option set?\",",
          "12824:           portsTotal);",
          "12825:    continue;",
          "12826:   }",
          "12829:   if ((so.sock = socket(so.lsa.sa.sa_family, SOCK_STREAM, 6))",
          "12830:       == INVALID_SOCKET) {",
          "12832:    mg_cry(fc(ctx), \"cannot create socket (entry %i)\", portsTotal);",
          "12833:    continue;",
          "12834:   }",
          "12846:   if (setsockopt(so.sock,",
          "12847:                  SOL_SOCKET,",
          "12848:                  SO_EXCLUSIVEADDRUSE,",
          "12849:                  (SOCK_OPT_TYPE)&on,",
          "12850:                  sizeof(on)) != 0) {",
          "12853:    mg_cry(fc(ctx),",
          "12854:           \"cannot set socket option SO_EXCLUSIVEADDRUSE (entry %i)\",",
          "12855:           portsTotal);",
          "12856:   }",
          "",
          "---------------",
          "--- Hunk 51 ---",
          "[Context before]",
          "12828:   }",
          "12829: #endif",
          "12832: #if defined(USE_IPV6)",
          "12847:     }",
          "12848: #else",
          "12849:    mg_cry(fc(ctx), \"IPv6 not available\");",
          "12850:    closesocket(so.sock);",
          "12851:    so.sock = INVALID_SOCKET;",
          "12852:    continue;",
          "12853: #endif",
          "12899:     mg_cry(fc(ctx),",
          "12901:            (int)vec.len,",
          "12902:            vec.ptr,",
          "12903:            (int)ERRNO,",
          "",
          "[Removed Lines]",
          "12831:    if (ip_version > 4) {",
          "12833:     if (ip_version == 6) {",
          "12834:      if (so.lsa.sa.sa_family == AF_INET6",
          "12835:          && setsockopt(so.sock,",
          "12836:                        IPPROTO_IPV6,",
          "12837:                        IPV6_V6ONLY,",
          "12838:                        (void *)&off,",
          "12839:                        sizeof(off)) != 0) {",
          "12842:       mg_cry(",
          "12843:           fc(ctx),",
          "12844:           \"cannot set socket option IPV6_V6ONLY (entry %i)\",",
          "12845:           portsTotal);",
          "12846:      }",
          "12854:    }",
          "12856:    if (so.lsa.sa.sa_family == AF_INET) {",
          "12858:     len = sizeof(so.lsa.sin);",
          "12859:     if (bind(so.sock, &so.lsa.sa, len) != 0) {",
          "12860:      mg_cry(fc(ctx),",
          "12861:             \"cannot bind to %.*s: %d (%s)\",",
          "12862:             (int)vec.len,",
          "12863:             vec.ptr,",
          "12864:             (int)ERRNO,",
          "12865:             strerror(errno));",
          "12866:      closesocket(so.sock);",
          "12867:      so.sock = INVALID_SOCKET;",
          "12868:      continue;",
          "12869:     }",
          "12870:    }",
          "12871: #if defined(USE_IPV6)",
          "12872:    else if (so.lsa.sa.sa_family == AF_INET6) {",
          "12874:     len = sizeof(so.lsa.sin6);",
          "12875:     if (bind(so.sock, &so.lsa.sa, len) != 0) {",
          "12876:      mg_cry(fc(ctx),",
          "12877:             \"cannot bind to IPv6 %.*s: %d (%s)\",",
          "12878:             (int)vec.len,",
          "12879:             vec.ptr,",
          "12880:             (int)ERRNO,",
          "12881:             strerror(errno));",
          "12882:      closesocket(so.sock);",
          "12883:      so.sock = INVALID_SOCKET;",
          "12884:      continue;",
          "12885:     }",
          "12886:    }",
          "12887: #endif",
          "12888:    else {",
          "12889:     mg_cry(fc(ctx),",
          "12890:            \"cannot bind: address family not supported (entry %i)\",",
          "12891:            portsTotal);",
          "12892:     closesocket(so.sock);",
          "12893:     so.sock = INVALID_SOCKET;",
          "12894:     continue;",
          "12895:    }",
          "12897:    if (listen(so.sock, SOMAXCONN) != 0) {",
          "12900:            \"cannot listen to %.*s: %d (%s)\",",
          "",
          "[Added Lines]",
          "12871:   if (ip_version > 4) {",
          "12873:    if (ip_version == 6) {",
          "12874:     if (so.lsa.sa.sa_family == AF_INET6",
          "12875:         && setsockopt(so.sock,",
          "12876:                       IPPROTO_IPV6,",
          "12877:                       IPV6_V6ONLY,",
          "12878:                       (void *)&off,",
          "12879:                       sizeof(off)) != 0) {",
          "12882:      mg_cry(fc(ctx),",
          "12883:             \"cannot set socket option IPV6_V6ONLY (entry %i)\",",
          "12884:             portsTotal);",
          "12886:    }",
          "12893:   }",
          "12895:   if (so.lsa.sa.sa_family == AF_INET) {",
          "12897:    len = sizeof(so.lsa.sin);",
          "12898:    if (bind(so.sock, &so.lsa.sa, len) != 0) {",
          "12900:            \"cannot bind to %.*s: %d (%s)\",",
          "",
          "---------------",
          "--- Hunk 52 ---",
          "[Context before]",
          "12906:     so.sock = INVALID_SOCKET;",
          "12907:     continue;",
          "12908:    }",
          "12914:     mg_cry(fc(ctx),",
          "12916:            (int)vec.len,",
          "12917:            vec.ptr,",
          "12919:            strerror(errno));",
          "12920:     closesocket(so.sock);",
          "12921:     so.sock = INVALID_SOCKET;",
          "12922:     continue;",
          "12923:    }",
          "12926: #if defined(USE_IPV6)",
          "12930: #endif",
          "12966:   }",
          "12974:  }",
          "12987:  }",
          "13014:    fi.access.fp = NULL;",
          "13015:   }",
          "13030:   }",
          "13079:   }",
          "13080:  }",
          "13111:    }",
          "13114:   }",
          "13116:  }",
          "13119: #if !defined(_WIN32)",
          "13129:    } else {",
          "13152:    }",
          "13155:   }",
          "13157:  }",
          "13171:   }",
          "13173:  }",
          "13176: #if !defined(NO_SSL)",
          "13227:    }",
          "13244:    }",
          "13251:    }",
          "13252:   }",
          "13259:  }",
          "13261: #ifdef OPENSSL_API_1_1",
          "13262: #else",
          "13263: static pthread_mutex_t *ssl_mutexes;",
          "13288:   }",
          "13303: #ifndef OPENSSL_API_1_1",
          "13305: #endif",
          "13338:      break;",
          "13339:     }",
          "13341:    } else {",
          "13343:     break;",
          "13344:    }",
          "13345:   }",
          "13352: #ifndef OPENSSL_API_1_1",
          "13354: #endif",
          "13359:  }",
          "13393:  }",
          "13478:  }",
          "13481: #ifdef OPENSSL_API_1_1",
          "",
          "[Removed Lines]",
          "12910:    if ((getsockname(so.sock, &(usa.sa), &len) != 0)",
          "12911:        || (usa.sa.sa_family != so.lsa.sa.sa_family)) {",
          "12913:     int err = (int)ERRNO;",
          "12915:            \"call to getsockname failed %.*s: %d (%s)\",",
          "12918:            err,",
          "12927:    if (so.lsa.sa.sa_family == AF_INET6) {",
          "12928:     so.lsa.sin6.sin6_port = usa.sin6.sin6_port;",
          "12929:    } else",
          "12931:    {",
          "12932:     so.lsa.sin.sin_port = usa.sin.sin_port;",
          "12933:    }",
          "12935:    if ((ptr = (struct socket *)",
          "12936:             mg_realloc_ctx(ctx->listening_sockets,",
          "12937:                            (ctx->num_listening_sockets + 1)",
          "12939:                            ctx)) == NULL) {",
          "12941:     mg_cry(fc(ctx), \"%s\", \"Out of memory\");",
          "12942:     closesocket(so.sock);",
          "12943:     so.sock = INVALID_SOCKET;",
          "12944:     continue;",
          "12945:    }",
          "12947:    if ((pfd = (struct pollfd *)",
          "12948:             mg_realloc_ctx(ctx->listening_socket_fds,",
          "12949:                            (ctx->num_listening_sockets + 1)",
          "12951:                            ctx)) == NULL) {",
          "12953:     mg_cry(fc(ctx), \"%s\", \"Out of memory\");",
          "12954:     closesocket(so.sock);",
          "12955:     so.sock = INVALID_SOCKET;",
          "12956:     mg_free(ptr);",
          "12957:     continue;",
          "12958:    }",
          "12960:    set_close_on_exec(so.sock, fc(ctx));",
          "12961:    ctx->listening_sockets = ptr;",
          "12962:    ctx->listening_sockets[ctx->num_listening_sockets] = so;",
          "12963:    ctx->listening_socket_fds = pfd;",
          "12964:    ctx->num_listening_sockets++;",
          "12965:    portsOk++;",
          "12968:   if (portsOk != portsTotal) {",
          "12969:    close_all_listening_sockets(ctx);",
          "12970:    portsOk = 0;",
          "12971:   }",
          "12973:   return portsOk;",
          "12977:  static const char *header_val(const struct mg_connection *conn,",
          "12978:                                const char *header)",
          "12979:  {",
          "12980:   const char *header_value;",
          "12982:   if ((header_value = mg_get_header(conn, header)) == NULL) {",
          "12983:    return \"-\";",
          "12984:   } else {",
          "12985:    return header_value;",
          "12986:   }",
          "12990:  static void log_access(const struct mg_connection *conn)",
          "12991:  {",
          "12992:   const struct mg_request_info *ri;",
          "12993:   struct mg_file fi;",
          "12994:   char date[64], src_addr[IP_ADDR_STR_LEN];",
          "12995:   struct tm *tm;",
          "12997:   const char *referer;",
          "12998:   const char *user_agent;",
          "13000:   char buf[4096];",
          "13002:   if (!conn || !conn->ctx) {",
          "13003:    return;",
          "13004:   }",
          "13006:   if (conn->ctx->config[ACCESS_LOG_FILE] != NULL) {",
          "13007:    if (mg_fopen(conn,",
          "13008:                 conn->ctx->config[ACCESS_LOG_FILE],",
          "13009:                 MG_FOPEN_MODE_APPEND,",
          "13010:                 &fi) == 0) {",
          "13011:     fi.access.fp = NULL;",
          "13012:    }",
          "13013:   } else {",
          "13019:   if ((fi.access.fp == NULL)",
          "13020:       && (conn->ctx->callbacks.log_access == NULL)) {",
          "13021:    return;",
          "13022:   }",
          "13024:   tm = localtime(&conn->conn_birth_time);",
          "13025:   if (tm != NULL) {",
          "13026:    strftime(date, sizeof(date), \"%d/%b/%Y:%H:%M:%S %z\", tm);",
          "13027:   } else {",
          "13028:    mg_strlcpy(date, \"01/Jan/1970:00:00:00 +0000\", sizeof(date));",
          "13029:    date[sizeof(date) - 1] = '\\0';",
          "13032:   ri = &conn->request_info;",
          "13034:   sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);",
          "13035:   referer = header_val(conn, \"Referer\");",
          "13036:   user_agent = header_val(conn, \"User-Agent\");",
          "13038:   mg_snprintf(conn,",
          "13040:               buf,",
          "13041:               sizeof(buf),",
          "13042:               \"%s - %s [%s] \\\"%s %s%s%s HTTP/%s\\\" %d %\" INT64_FMT",
          "13043:               \" %s %s\",",
          "13044:               src_addr,",
          "13045:               (ri->remote_user == NULL) ? \"-\" : ri->remote_user,",
          "13046:               date,",
          "13047:               ri->request_method ? ri->request_method : \"-\",",
          "13048:               ri->request_uri ? ri->request_uri : \"-\",",
          "13049:               ri->query_string ? \"?\" : \"\",",
          "13050:               ri->query_string ? ri->query_string : \"\",",
          "13051:               ri->http_version,",
          "13052:               conn->status_code,",
          "13053:               conn->num_bytes_sent,",
          "13054:               referer,",
          "13055:               user_agent);",
          "13057:   if (conn->ctx->callbacks.log_access) {",
          "13058:    conn->ctx->callbacks.log_access(conn, buf);",
          "13059:   }",
          "13061:   if (fi.access.fp) {",
          "13062:    int ok = 1;",
          "13063:    flockfile(fi.access.fp);",
          "13064:    if (fprintf(fi.access.fp, \"%s\\n\", buf) < 1) {",
          "13065:     ok = 0;",
          "13066:    }",
          "13067:    if (fflush(fi.access.fp) != 0) {",
          "13068:     ok = 0;",
          "13069:    }",
          "13070:    funlockfile(fi.access.fp);",
          "13071:    if (mg_fclose(&fi.access) != 0) {",
          "13072:     ok = 0;",
          "13073:    }",
          "13074:    if (!ok) {",
          "13075:     mg_cry(conn,",
          "13076:            \"Error writing log file %s\",",
          "13077:            conn->ctx->config[ACCESS_LOG_FILE]);",
          "13078:    }",
          "13086:  static int check_acl(struct mg_context * ctx, uint32_t remote_ip)",
          "13087:  {",
          "13088:   int allowed, flag;",
          "13089:   uint32_t net, mask;",
          "13090:   struct vec vec;",
          "13092:   if (ctx) {",
          "13093:    const char *list = ctx->config[ACCESS_CONTROL_LIST];",
          "13096:    allowed = (list == NULL) ? '+' : '-';",
          "13098:    while ((list = next_option(list, &vec, NULL)) != NULL) {",
          "13099:     flag = vec.ptr[0];",
          "13100:     if ((flag != '+' && flag != '-')",
          "13101:         || (parse_net(&vec.ptr[1], &net, &mask) == 0)) {",
          "13102:      mg_cry(fc(ctx),",
          "13103:             \"%s: subnet must be [+|-]x.x.x.x[/x]\",",
          "13104:             __func__);",
          "13105:      return -1;",
          "13106:     }",
          "13108:     if (net == (remote_ip & mask)) {",
          "13109:      allowed = flag;",
          "13110:     }",
          "13113:    return allowed == '+';",
          "13115:   return -1;",
          "13120:  static int set_uid_option(struct mg_context * ctx)",
          "13121:  {",
          "13122:   struct passwd *pw;",
          "13123:   if (ctx) {",
          "13124:    const char *uid = ctx->config[RUN_AS_USER];",
          "13125:    int success = 0;",
          "13127:    if (uid == NULL) {",
          "13128:     success = 1;",
          "13130:     if ((pw = getpwnam(uid)) == NULL) {",
          "13131:      mg_cry(fc(ctx), \"%s: unknown user [%s]\", __func__, uid);",
          "13132:     } else if (setgid(pw->pw_gid) == -1) {",
          "13133:      mg_cry(fc(ctx),",
          "13134:             \"%s: setgid(%s): %s\",",
          "13135:             __func__,",
          "13136:             uid,",
          "13137:             strerror(errno));",
          "13138:     } else if (setgroups(0, NULL)) {",
          "13139:      mg_cry(fc(ctx),",
          "13140:             \"%s: setgroups(): %s\",",
          "13141:             __func__,",
          "13142:             strerror(errno));",
          "13143:     } else if (setuid(pw->pw_uid) == -1) {",
          "13144:      mg_cry(fc(ctx),",
          "13145:             \"%s: setuid(%s): %s\",",
          "13146:             __func__,",
          "13147:             uid,",
          "13148:             strerror(errno));",
          "13149:     } else {",
          "13150:      success = 1;",
          "13151:     }",
          "13154:    return success;",
          "13156:   return 0;",
          "13161:  static void tls_dtor(void *key)",
          "13162:  {",
          "13163:   struct mg_workerTLS *tls = (struct mg_workerTLS *)key;",
          "13166:   if (tls) {",
          "13167:    if (tls->is_master == 2) {",
          "13169:     mg_free(tls);",
          "13170:    }",
          "13172:   pthread_setspecific(sTlsKey, NULL);",
          "13178:  static int ssl_use_pem_file(struct mg_context * ctx,",
          "13179:                              const char *pem,",
          "13180:                              const char *chain);",
          "13181:  static const char *ssl_error(void);",
          "13184:  static int refresh_trust(struct mg_connection * conn)",
          "13185:  {",
          "13186:   static int reload_lock = 0;",
          "13187:   static long int data_check = 0;",
          "13188:   volatile int *p_reload_lock = (volatile int *)&reload_lock;",
          "13190:   struct stat cert_buf;",
          "13191:   long int t;",
          "13192:   const char *pem;",
          "13193:   const char *chain;",
          "13194:   int should_verify_peer;",
          "13196:   if ((pem = conn->ctx->config[SSL_CERTIFICATE]) == NULL) {",
          "13199:    return 0;",
          "13200:   }",
          "13201:   chain = conn->ctx->config[SSL_CERTIFICATE_CHAIN];",
          "13202:   if (chain == NULL) {",
          "13204:    chain = pem;",
          "13205:   }",
          "13206:   if (*chain == 0) {",
          "13207:    chain = NULL;",
          "13208:   }",
          "13210:   t = data_check;",
          "13211:   if (stat(pem, &cert_buf) != -1) {",
          "13212:    t = (long int)cert_buf.st_mtime;",
          "13213:   }",
          "13215:   if (data_check != t) {",
          "13216:    data_check = t;",
          "13218:    should_verify_peer = 0;",
          "13219:    if (conn->ctx->config[SSL_DO_VERIFY_PEER] != NULL) {",
          "13220:     if (mg_strcasecmp(conn->ctx->config[SSL_DO_VERIFY_PEER], \"yes\")",
          "13221:         == 0) {",
          "13222:      should_verify_peer = 1;",
          "13223:     } else if (mg_strcasecmp(conn->ctx->config[SSL_DO_VERIFY_PEER],",
          "13224:                              \"optional\") == 0) {",
          "13225:      should_verify_peer = 1;",
          "13226:     }",
          "13229:    if (should_verify_peer) {",
          "13230:     char *ca_path = conn->ctx->config[SSL_CA_PATH];",
          "13231:     char *ca_file = conn->ctx->config[SSL_CA_FILE];",
          "13232:     if (SSL_CTX_load_verify_locations(conn->ctx->ssl_ctx,",
          "13233:                                       ca_file,",
          "13234:                                       ca_path) != 1) {",
          "13235:      mg_cry(fc(conn->ctx),",
          "13236:             \"SSL_CTX_load_verify_locations error: %s \"",
          "13237:             \"ssl_verify_peer requires setting \"",
          "13238:             \"either ssl_ca_path or ssl_ca_file. Is any of them \"",
          "13239:             \"present in \"",
          "13240:             \"the .conf file?\",",
          "13241:             ssl_error());",
          "13242:      return 0;",
          "13243:     }",
          "13246:    if (1 == mg_atomic_inc(p_reload_lock)) {",
          "13247:     if (ssl_use_pem_file(conn->ctx, pem, chain) == 0) {",
          "13248:      return 0;",
          "13249:     }",
          "13254:   while (*p_reload_lock) {",
          "13255:    sleep(1);",
          "13256:   }",
          "13258:   return 1;",
          "13266:  static int sslize(struct mg_connection * conn,",
          "13267:                    SSL_CTX * s,",
          "13268:                    int (*func)(SSL *),",
          "13269:                    volatile int *stop_server)",
          "13270:  {",
          "13271:   int ret, err;",
          "13272:   int short_trust;",
          "13273:   unsigned i;",
          "13275:   if (!conn) {",
          "13276:    return 0;",
          "13277:   }",
          "13279:   short_trust =",
          "13280:       (conn->ctx->config[SSL_SHORT_TRUST] != NULL)",
          "13281:       && (mg_strcasecmp(conn->ctx->config[SSL_SHORT_TRUST], \"yes\") == 0);",
          "13283:   if (short_trust) {",
          "13284:    int trust_ret = refresh_trust(conn);",
          "13285:    if (!trust_ret) {",
          "13286:     return trust_ret;",
          "13287:    }",
          "13290:   conn->ssl = SSL_new(s);",
          "13291:   if (conn->ssl == NULL) {",
          "13292:    return 0;",
          "13293:   }",
          "13295:   ret = SSL_set_fd(conn->ssl, conn->client.sock);",
          "13296:   if (ret != 1) {",
          "13297:    err = SSL_get_error(conn->ssl, ret);",
          "13299:    SSL_free(conn->ssl);",
          "13300:    conn->ssl = NULL;",
          "13304:    ERR_remove_state(0);",
          "13306:    return 0;",
          "13307:   }",
          "13312:   for (i = 16; i <= 1024; i *= 2) {",
          "13313:    ret = func(conn->ssl);",
          "13314:    if (ret != 1) {",
          "13315:     err = SSL_get_error(conn->ssl, ret);",
          "13316:     if ((err == SSL_ERROR_WANT_CONNECT)",
          "13317:         || (err == SSL_ERROR_WANT_ACCEPT)",
          "13318:         || (err == SSL_ERROR_WANT_READ)",
          "13319:         || (err == SSL_ERROR_WANT_WRITE)) {",
          "13323:      if (*stop_server) {",
          "13325:       break;",
          "13326:      }",
          "13327:      mg_sleep(i);",
          "13329:     } else if (err == SSL_ERROR_SYSCALL) {",
          "13331:      err = errno;",
          "13333:      (void)err;",
          "13334:      break;",
          "13335:     } else {",
          "13347:   if (ret != 1) {",
          "13348:    SSL_free(conn->ssl);",
          "13349:    conn->ssl = NULL;",
          "13353:    ERR_remove_state(0);",
          "13355:    return 0;",
          "13356:   }",
          "13358:   return 1;",
          "13363:  static const char *ssl_error(void)",
          "13364:  {",
          "13365:   unsigned long err;",
          "13366:   err = ERR_get_error();",
          "13367:   return ((err == 0) ? \"\" : ERR_error_string(err, NULL));",
          "13368:  }",
          "13371:  static int hexdump2string(void *mem, int memlen, char *buf, int buflen)",
          "13372:  {",
          "13373:   int i;",
          "13374:   const char hexdigit[] = \"0123456789abcdef\";",
          "13376:   if ((memlen <= 0) || (buflen <= 0)) {",
          "13377:    return 0;",
          "13378:   }",
          "13379:   if (buflen < (3 * memlen)) {",
          "13380:    return 0;",
          "13381:   }",
          "13383:   for (i = 0; i < memlen; i++) {",
          "13384:    if (i > 0) {",
          "13385:     buf[3 * i - 1] = ' ';",
          "13386:    }",
          "13387:    buf[3 * i] = hexdigit[(((uint8_t *)mem)[i] >> 4) & 0xF];",
          "13388:    buf[3 * i + 1] = hexdigit[((uint8_t *)mem)[i] & 0xF];",
          "13389:   }",
          "13390:   buf[3 * memlen - 1] = 0;",
          "13392:   return 1;",
          "13396:  static void ssl_get_client_cert_info(struct mg_connection * conn)",
          "13397:  {",
          "13398:   X509 *cert = SSL_get_peer_certificate(conn->ssl);",
          "13399:   if (cert) {",
          "13400:    char str_subject[1024];",
          "13401:    char str_issuer[1024];",
          "13402:    char str_finger[1024];",
          "13403:    unsigned char buf[256];",
          "13404:    char *str_serial = NULL;",
          "13405:    unsigned int ulen;",
          "13406:    int ilen;",
          "13407:    unsigned char *tmp_buf;",
          "13408:    unsigned char *tmp_p;",
          "13411:    const EVP_MD *digest = EVP_get_digestbyname(\"sha1\");",
          "13414:    X509_NAME *subj = X509_get_subject_name(cert);",
          "13415:    X509_NAME *iss = X509_get_issuer_name(cert);",
          "13418:    ASN1_INTEGER *serial = X509_get_serialNumber(cert);",
          "13421:    BIGNUM *serial_bn = ASN1_INTEGER_to_BN(serial, NULL);",
          "13422:    str_serial = BN_bn2hex(serial_bn);",
          "13423:    BN_free(serial_bn);",
          "13426:    (void)X509_NAME_oneline(subj,",
          "13427:                            str_subject,",
          "13428:                            (int)sizeof(str_subject));",
          "13429:    (void)X509_NAME_oneline(iss, str_issuer, (int)sizeof(str_issuer));",
          "13432:    ulen = 0;",
          "13436:    ilen = i2d_X509((void *)cert, NULL);",
          "13437:    tmp_buf = (ilen > 0)",
          "13438:                  ? (unsigned char *)mg_malloc_ctx((unsigned)ilen + 1,",
          "13439:                                                   conn->ctx)",
          "13440:                  : NULL;",
          "13441:    if (tmp_buf) {",
          "13442:     tmp_p = tmp_buf;",
          "13443:     (void)i2d_X509((void *)cert, &tmp_p);",
          "13444:     if (!EVP_Digest(",
          "13445:             tmp_buf, (unsigned)ilen, buf, &ulen, digest, NULL)) {",
          "13446:      ulen = 0;",
          "13447:     }",
          "13448:     mg_free(tmp_buf);",
          "13449:    }",
          "13451:    if (!hexdump2string(",
          "13452:            buf, (int)ulen, str_finger, (int)sizeof(str_finger))) {",
          "13454:    }",
          "13456:    conn->request_info.client_cert =",
          "13457:        (struct client_cert *)mg_malloc_ctx(sizeof(struct client_cert),",
          "13458:                                            conn->ctx);",
          "13459:    if (conn->request_info.client_cert) {",
          "13460:     conn->request_info.client_cert->subject =",
          "13461:         mg_strdup(str_subject);",
          "13462:     conn->request_info.client_cert->issuer = mg_strdup(str_issuer);",
          "13463:     conn->request_info.client_cert->serial = mg_strdup(str_serial);",
          "13464:     conn->request_info.client_cert->finger = mg_strdup(str_finger);",
          "13465:    } else {",
          "13466:     mg_cry(conn,",
          "13467:            \"Out of memory: Cannot allocate memory for client \"",
          "13468:            \"certificate\");",
          "13469:    }",
          "13473:    OPENSSL_free(str_serial);",
          "13476:    X509_free(cert);",
          "13477:   }",
          "",
          "[Added Lines]",
          "12909:   }",
          "12910: #if defined(USE_IPV6)",
          "12911:   else if (so.lsa.sa.sa_family == AF_INET6) {",
          "12913:    len = sizeof(so.lsa.sin6);",
          "12914:    if (bind(so.sock, &so.lsa.sa, len) != 0) {",
          "12916:            \"cannot bind to IPv6 %.*s: %d (%s)\",",
          "12919:            (int)ERRNO,",
          "12925:   }",
          "12926: #endif",
          "12927:   else {",
          "12928:    mg_cry(fc(ctx),",
          "12929:           \"cannot bind: address family not supported (entry %i)\",",
          "12930:           portsTotal);",
          "12931:    closesocket(so.sock);",
          "12932:    so.sock = INVALID_SOCKET;",
          "12933:    continue;",
          "12934:   }",
          "12936:   if (listen(so.sock, SOMAXCONN) != 0) {",
          "12938:    mg_cry(fc(ctx),",
          "12939:           \"cannot listen to %.*s: %d (%s)\",",
          "12940:           (int)vec.len,",
          "12941:           vec.ptr,",
          "12942:           (int)ERRNO,",
          "12943:           strerror(errno));",
          "12944:    closesocket(so.sock);",
          "12945:    so.sock = INVALID_SOCKET;",
          "12946:    continue;",
          "12947:   }",
          "12949:   if ((getsockname(so.sock, &(usa.sa), &len) != 0)",
          "12950:       || (usa.sa.sa_family != so.lsa.sa.sa_family)) {",
          "12952:    int err = (int)ERRNO;",
          "12953:    mg_cry(fc(ctx),",
          "12954:           \"call to getsockname failed %.*s: %d (%s)\",",
          "12955:           (int)vec.len,",
          "12956:           vec.ptr,",
          "12957:           err,",
          "12958:           strerror(errno));",
          "12959:    closesocket(so.sock);",
          "12960:    so.sock = INVALID_SOCKET;",
          "12961:    continue;",
          "12962:   }",
          "12966:   if (so.lsa.sa.sa_family == AF_INET6) {",
          "12967:    so.lsa.sin6.sin6_port = usa.sin6.sin6_port;",
          "12968:   } else",
          "12970:   {",
          "12971:    so.lsa.sin.sin_port = usa.sin.sin_port;",
          "12972:   }",
          "12974:   if ((ptr = (struct socket *)",
          "12975:            mg_realloc_ctx(ctx->listening_sockets,",
          "12976:                           (ctx->num_listening_sockets + 1)",
          "12978:                           ctx)) == NULL) {",
          "12980:    mg_cry(fc(ctx), \"%s\", \"Out of memory\");",
          "12981:    closesocket(so.sock);",
          "12982:    so.sock = INVALID_SOCKET;",
          "12983:    continue;",
          "12984:   }",
          "12986:   if ((pfd = (struct pollfd *)",
          "12987:            mg_realloc_ctx(ctx->listening_socket_fds,",
          "12988:                           (ctx->num_listening_sockets + 1)",
          "12990:                           ctx)) == NULL) {",
          "12992:    mg_cry(fc(ctx), \"%s\", \"Out of memory\");",
          "12993:    closesocket(so.sock);",
          "12994:    so.sock = INVALID_SOCKET;",
          "12995:    mg_free(ptr);",
          "12996:    continue;",
          "12999:   set_close_on_exec(so.sock, fc(ctx));",
          "13000:   ctx->listening_sockets = ptr;",
          "13001:   ctx->listening_sockets[ctx->num_listening_sockets] = so;",
          "13002:   ctx->listening_socket_fds = pfd;",
          "13003:   ctx->num_listening_sockets++;",
          "13004:   portsOk++;",
          "13005:  }",
          "13007:  if (portsOk != portsTotal) {",
          "13008:   close_all_listening_sockets(ctx);",
          "13009:   portsOk = 0;",
          "13012:  return portsOk;",
          "13013: }",
          "13016: static const char *",
          "13017: header_val(const struct mg_connection *conn, const char *header)",
          "13018: {",
          "13019:  const char *header_value;",
          "13021:  if ((header_value = mg_get_header(conn, header)) == NULL) {",
          "13022:   return \"-\";",
          "13023:  } else {",
          "13024:   return header_value;",
          "13026: }",
          "13029: static void",
          "13030: log_access(const struct mg_connection *conn)",
          "13031: {",
          "13032:  const struct mg_request_info *ri;",
          "13033:  struct mg_file fi;",
          "13034:  char date[64], src_addr[IP_ADDR_STR_LEN];",
          "13035:  struct tm *tm;",
          "13037:  const char *referer;",
          "13038:  const char *user_agent;",
          "13040:  char buf[4096];",
          "13042:  if (!conn || !conn->ctx) {",
          "13043:   return;",
          "13044:  }",
          "13046:  if (conn->ctx->config[ACCESS_LOG_FILE] != NULL) {",
          "13047:   if (mg_fopen(conn,",
          "13048:                conn->ctx->config[ACCESS_LOG_FILE],",
          "13049:                MG_FOPEN_MODE_APPEND,",
          "13050:                &fi) == 0) {",
          "13053:  } else {",
          "13054:   fi.access.fp = NULL;",
          "13055:  }",
          "13059:  if ((fi.access.fp == NULL) && (conn->ctx->callbacks.log_access == NULL)) {",
          "13060:   return;",
          "13061:  }",
          "13063:  tm = localtime(&conn->conn_birth_time);",
          "13064:  if (tm != NULL) {",
          "13065:   strftime(date, sizeof(date), \"%d/%b/%Y:%H:%M:%S %z\", tm);",
          "13066:  } else {",
          "13067:   mg_strlcpy(date, \"01/Jan/1970:00:00:00 +0000\", sizeof(date));",
          "13068:   date[sizeof(date) - 1] = '\\0';",
          "13069:  }",
          "13071:  ri = &conn->request_info;",
          "13073:  sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);",
          "13074:  referer = header_val(conn, \"Referer\");",
          "13075:  user_agent = header_val(conn, \"User-Agent\");",
          "13077:  mg_snprintf(conn,",
          "13079:              buf,",
          "13080:              sizeof(buf),",
          "13081:              \"%s - %s [%s] \\\"%s %s%s%s HTTP/%s\\\" %d %\" INT64_FMT \" %s %s\",",
          "13082:              src_addr,",
          "13083:              (ri->remote_user == NULL) ? \"-\" : ri->remote_user,",
          "13084:              date,",
          "13085:              ri->request_method ? ri->request_method : \"-\",",
          "13086:              ri->request_uri ? ri->request_uri : \"-\",",
          "13087:              ri->query_string ? \"?\" : \"\",",
          "13088:              ri->query_string ? ri->query_string : \"\",",
          "13089:              ri->http_version,",
          "13090:              conn->status_code,",
          "13091:              conn->num_bytes_sent,",
          "13092:              referer,",
          "13093:              user_agent);",
          "13095:  if (conn->ctx->callbacks.log_access) {",
          "13096:   conn->ctx->callbacks.log_access(conn, buf);",
          "13097:  }",
          "13099:  if (fi.access.fp) {",
          "13100:   int ok = 1;",
          "13101:   flockfile(fi.access.fp);",
          "13102:   if (fprintf(fi.access.fp, \"%s\\n\", buf) < 1) {",
          "13103:    ok = 0;",
          "13105:   if (fflush(fi.access.fp) != 0) {",
          "13106:    ok = 0;",
          "13107:   }",
          "13108:   funlockfile(fi.access.fp);",
          "13109:   if (mg_fclose(&fi.access) != 0) {",
          "13110:    ok = 0;",
          "13111:   }",
          "13112:   if (!ok) {",
          "13113:    mg_cry(conn,",
          "13114:           \"Error writing log file %s\",",
          "13115:           conn->ctx->config[ACCESS_LOG_FILE]);",
          "13118: }",
          "13124: static int",
          "13125: check_acl(struct mg_context *ctx, uint32_t remote_ip)",
          "13126: {",
          "13127:  int allowed, flag;",
          "13128:  uint32_t net, mask;",
          "13129:  struct vec vec;",
          "13131:  if (ctx) {",
          "13132:   const char *list = ctx->config[ACCESS_CONTROL_LIST];",
          "13135:   allowed = (list == NULL) ? '+' : '-';",
          "13137:   while ((list = next_option(list, &vec, NULL)) != NULL) {",
          "13138:    flag = vec.ptr[0];",
          "13139:    if ((flag != '+' && flag != '-')",
          "13140:        || (parse_net(&vec.ptr[1], &net, &mask) == 0)) {",
          "13141:     mg_cry(fc(ctx),",
          "13142:            \"%s: subnet must be [+|-]x.x.x.x[/x]\",",
          "13143:            __func__);",
          "13144:     return -1;",
          "13147:    if (net == (remote_ip & mask)) {",
          "13148:     allowed = flag;",
          "13149:    }",
          "13152:   return allowed == '+';",
          "13154:  return -1;",
          "13155: }",
          "13159: static int",
          "13160: set_uid_option(struct mg_context *ctx)",
          "13161: {",
          "13162:  struct passwd *pw;",
          "13163:  if (ctx) {",
          "13164:   const char *uid = ctx->config[RUN_AS_USER];",
          "13165:   int success = 0;",
          "13167:   if (uid == NULL) {",
          "13168:    success = 1;",
          "13169:   } else {",
          "13170:    if ((pw = getpwnam(uid)) == NULL) {",
          "13171:     mg_cry(fc(ctx), \"%s: unknown user [%s]\", __func__, uid);",
          "13172:    } else if (setgid(pw->pw_gid) == -1) {",
          "13173:     mg_cry(fc(ctx),",
          "13174:            \"%s: setgid(%s): %s\",",
          "13175:            __func__,",
          "13176:            uid,",
          "13177:            strerror(errno));",
          "13178:    } else if (setgroups(0, NULL)) {",
          "13179:     mg_cry(fc(ctx),",
          "13180:            \"%s: setgroups(): %s\",",
          "13181:            __func__,",
          "13182:            strerror(errno));",
          "13183:    } else if (setuid(pw->pw_uid) == -1) {",
          "13184:     mg_cry(fc(ctx),",
          "13185:            \"%s: setuid(%s): %s\",",
          "13186:            __func__,",
          "13187:            uid,",
          "13188:            strerror(errno));",
          "13190:     success = 1;",
          "13194:   return success;",
          "13196:  return 0;",
          "13197: }",
          "13201: static void",
          "13202: tls_dtor(void *key)",
          "13203: {",
          "13204:  struct mg_workerTLS *tls = (struct mg_workerTLS *)key;",
          "13207:  if (tls) {",
          "13208:   if (tls->is_master == 2) {",
          "13210:    mg_free(tls);",
          "13213:  pthread_setspecific(sTlsKey, NULL);",
          "13214: }",
          "13219: static int",
          "13220: ssl_use_pem_file(struct mg_context *ctx, const char *pem, const char *chain);",
          "13221: static const char *ssl_error(void);",
          "13224: static int",
          "13225: refresh_trust(struct mg_connection *conn)",
          "13226: {",
          "13227:  static int reload_lock = 0;",
          "13228:  static long int data_check = 0;",
          "13229:  volatile int *p_reload_lock = (volatile int *)&reload_lock;",
          "13231:  struct stat cert_buf;",
          "13232:  long int t;",
          "13233:  const char *pem;",
          "13234:  const char *chain;",
          "13235:  int should_verify_peer;",
          "13237:  if ((pem = conn->ctx->config[SSL_CERTIFICATE]) == NULL) {",
          "13240:   return 0;",
          "13241:  }",
          "13242:  chain = conn->ctx->config[SSL_CERTIFICATE_CHAIN];",
          "13243:  if (chain == NULL) {",
          "13245:   chain = pem;",
          "13246:  }",
          "13247:  if (*chain == 0) {",
          "13248:   chain = NULL;",
          "13249:  }",
          "13251:  t = data_check;",
          "13252:  if (stat(pem, &cert_buf) != -1) {",
          "13253:   t = (long int)cert_buf.st_mtime;",
          "13254:  }",
          "13256:  if (data_check != t) {",
          "13257:   data_check = t;",
          "13259:   should_verify_peer = 0;",
          "13260:   if (conn->ctx->config[SSL_DO_VERIFY_PEER] != NULL) {",
          "13261:    if (mg_strcasecmp(conn->ctx->config[SSL_DO_VERIFY_PEER], \"yes\")",
          "13262:        == 0) {",
          "13263:     should_verify_peer = 1;",
          "13264:    } else if (mg_strcasecmp(conn->ctx->config[SSL_DO_VERIFY_PEER],",
          "13265:                             \"optional\") == 0) {",
          "13266:     should_verify_peer = 1;",
          "13268:   }",
          "13270:   if (should_verify_peer) {",
          "13271:    char *ca_path = conn->ctx->config[SSL_CA_PATH];",
          "13272:    char *ca_file = conn->ctx->config[SSL_CA_FILE];",
          "13273:    if (SSL_CTX_load_verify_locations(conn->ctx->ssl_ctx,",
          "13274:                                      ca_file,",
          "13275:                                      ca_path) != 1) {",
          "13276:     mg_cry(fc(conn->ctx),",
          "13277:            \"SSL_CTX_load_verify_locations error: %s \"",
          "13278:            \"ssl_verify_peer requires setting \"",
          "13279:            \"either ssl_ca_path or ssl_ca_file. Is any of them \"",
          "13280:            \"present in \"",
          "13281:            \"the .conf file?\",",
          "13282:            ssl_error());",
          "13283:     return 0;",
          "13285:   }",
          "13287:   if (1 == mg_atomic_inc(p_reload_lock)) {",
          "13288:    if (ssl_use_pem_file(conn->ctx, pem, chain) == 0) {",
          "13289:     return 0;",
          "13295:  while (*p_reload_lock) {",
          "13296:   sleep(1);",
          "13297:  }",
          "13299:  return 1;",
          "13300: }",
          "13307: static int",
          "13308: sslize(struct mg_connection *conn,",
          "13309:        SSL_CTX *s,",
          "13310:        int (*func)(SSL *),",
          "13311:        volatile int *stop_server)",
          "13312: {",
          "13313:  int ret, err;",
          "13314:  int short_trust;",
          "13315:  unsigned i;",
          "13317:  if (!conn) {",
          "13318:   return 0;",
          "13319:  }",
          "13321:  short_trust =",
          "13322:      (conn->ctx->config[SSL_SHORT_TRUST] != NULL)",
          "13323:      && (mg_strcasecmp(conn->ctx->config[SSL_SHORT_TRUST], \"yes\") == 0);",
          "13325:  if (short_trust) {",
          "13326:   int trust_ret = refresh_trust(conn);",
          "13327:   if (!trust_ret) {",
          "13328:    return trust_ret;",
          "13330:  }",
          "13332:  conn->ssl = SSL_new(s);",
          "13333:  if (conn->ssl == NULL) {",
          "13334:   return 0;",
          "13335:  }",
          "13337:  ret = SSL_set_fd(conn->ssl, conn->client.sock);",
          "13338:  if (ret != 1) {",
          "13339:   err = SSL_get_error(conn->ssl, ret);",
          "13341:   SSL_free(conn->ssl);",
          "13342:   conn->ssl = NULL;",
          "13346:   ERR_remove_state(0);",
          "13348:   return 0;",
          "13349:  }",
          "13354:  for (i = 16; i <= 1024; i *= 2) {",
          "13355:   ret = func(conn->ssl);",
          "13356:   if (ret != 1) {",
          "13357:    err = SSL_get_error(conn->ssl, ret);",
          "13358:    if ((err == SSL_ERROR_WANT_CONNECT)",
          "13359:        || (err == SSL_ERROR_WANT_ACCEPT)",
          "13360:        || (err == SSL_ERROR_WANT_READ)",
          "13361:        || (err == SSL_ERROR_WANT_WRITE)) {",
          "13365:     if (*stop_server) {",
          "13369:     mg_sleep(i);",
          "13371:    } else if (err == SSL_ERROR_SYSCALL) {",
          "13373:     err = errno;",
          "13375:     (void)err;",
          "13376:     break;",
          "13383:   } else {",
          "13385:    break;",
          "13387:  }",
          "13389:  if (ret != 1) {",
          "13390:   SSL_free(conn->ssl);",
          "13391:   conn->ssl = NULL;",
          "13395:   ERR_remove_state(0);",
          "13397:   return 0;",
          "13400:  return 1;",
          "13401: }",
          "13405: static const char *",
          "13406: ssl_error(void)",
          "13407: {",
          "13408:  unsigned long err;",
          "13409:  err = ERR_get_error();",
          "13410:  return ((err == 0) ? \"\" : ERR_error_string(err, NULL));",
          "13411: }",
          "13414: static int",
          "13415: hexdump2string(void *mem, int memlen, char *buf, int buflen)",
          "13416: {",
          "13417:  int i;",
          "13418:  const char hexdigit[] = \"0123456789abcdef\";",
          "13420:  if ((memlen <= 0) || (buflen <= 0)) {",
          "13421:   return 0;",
          "13422:  }",
          "13423:  if (buflen < (3 * memlen)) {",
          "13424:   return 0;",
          "13427:  for (i = 0; i < memlen; i++) {",
          "13428:   if (i > 0) {",
          "13429:    buf[3 * i - 1] = ' ';",
          "13430:   }",
          "13431:   buf[3 * i] = hexdigit[(((uint8_t *)mem)[i] >> 4) & 0xF];",
          "13432:   buf[3 * i + 1] = hexdigit[((uint8_t *)mem)[i] & 0xF];",
          "13433:  }",
          "13434:  buf[3 * memlen - 1] = 0;",
          "13436:  return 1;",
          "13437: }",
          "13440: static void",
          "13441: ssl_get_client_cert_info(struct mg_connection *conn)",
          "13442: {",
          "13443:  X509 *cert = SSL_get_peer_certificate(conn->ssl);",
          "13444:  if (cert) {",
          "13445:   char str_subject[1024];",
          "13446:   char str_issuer[1024];",
          "13447:   char str_finger[1024];",
          "13448:   unsigned char buf[256];",
          "13449:   char *str_serial = NULL;",
          "13450:   unsigned int ulen;",
          "13451:   int ilen;",
          "13452:   unsigned char *tmp_buf;",
          "13453:   unsigned char *tmp_p;",
          "13456:   const EVP_MD *digest = EVP_get_digestbyname(\"sha1\");",
          "13459:   X509_NAME *subj = X509_get_subject_name(cert);",
          "13460:   X509_NAME *iss = X509_get_issuer_name(cert);",
          "13463:   ASN1_INTEGER *serial = X509_get_serialNumber(cert);",
          "13466:   BIGNUM *serial_bn = ASN1_INTEGER_to_BN(serial, NULL);",
          "13467:   str_serial = BN_bn2hex(serial_bn);",
          "13468:   BN_free(serial_bn);",
          "13471:   (void)X509_NAME_oneline(subj, str_subject, (int)sizeof(str_subject));",
          "13472:   (void)X509_NAME_oneline(iss, str_issuer, (int)sizeof(str_issuer));",
          "13475:   ulen = 0;",
          "13479:   ilen = i2d_X509((void *)cert, NULL);",
          "13480:   tmp_buf =",
          "13481:       (ilen > 0)",
          "13482:           ? (unsigned char *)mg_malloc_ctx((unsigned)ilen + 1, conn->ctx)",
          "13483:           : NULL;",
          "13484:   if (tmp_buf) {",
          "13485:    tmp_p = tmp_buf;",
          "13486:    (void)i2d_X509((void *)cert, &tmp_p);",
          "13487:    if (!EVP_Digest(",
          "13488:            tmp_buf, (unsigned)ilen, buf, &ulen, digest, NULL)) {",
          "13489:     ulen = 0;",
          "13490:    }",
          "13491:    mg_free(tmp_buf);",
          "13492:   }",
          "13494:   if (!hexdump2string(",
          "13495:           buf, (int)ulen, str_finger, (int)sizeof(str_finger))) {",
          "13497:   }",
          "13499:   conn->request_info.client_cert =",
          "13500:       (struct client_cert *)mg_malloc_ctx(sizeof(struct client_cert),",
          "13501:                                           conn->ctx);",
          "13502:   if (conn->request_info.client_cert) {",
          "13503:    conn->request_info.client_cert->subject = mg_strdup(str_subject);",
          "13504:    conn->request_info.client_cert->issuer = mg_strdup(str_issuer);",
          "13505:    conn->request_info.client_cert->serial = mg_strdup(str_serial);",
          "13506:    conn->request_info.client_cert->finger = mg_strdup(str_finger);",
          "13507:   } else {",
          "13508:    mg_cry(conn,",
          "13509:           \"Out of memory: Cannot allocate memory for client \"",
          "13510:           \"certificate\");",
          "13511:   }",
          "13515:   OPENSSL_free(str_serial);",
          "13518:   X509_free(cert);",
          "13520: }",
          "",
          "---------------",
          "--- Hunk 53 ---",
          "[Context before]",
          "13499: #if !defined(NO_SSL_DL)",
          "13527: #ifdef _WIN32",
          "13530: #else",
          "13538:      mg_snprintf(NULL,",
          "13539:                  &truncated,",
          "13545:                  fp->name);",
          "13560:      }",
          "13561:     }",
          "13566:    }",
          "13567:   }",
          "13575:  }",
          "13584: #if defined(SSL_ALREADY_INITIALIZED)",
          "13586: #else",
          "13588: #endif",
          "13593: #ifdef OPENSSL_API_1_1",
          "13598: #if !defined(NO_SSL_DL)",
          "13599:   if (!cryptolib_dll_handle) {",
          "13605:   }",
          "13613:  int i;",
          "",
          "[Removed Lines]",
          "13500:  static void *load_dll(char *ebuf,",
          "13501:                        size_t ebuf_len,",
          "13502:                        const char *dll_name,",
          "13503:                        struct ssl_func *sw)",
          "13504:  {",
          "13505:   union {",
          "13506:    void *p;",
          "13507:    void (*fp)(void);",
          "13508:   } u;",
          "13509:   void *dll_handle;",
          "13510:   struct ssl_func *fp;",
          "13511:   int ok;",
          "13512:   int truncated = 0;",
          "13514:   if ((dll_handle = dlopen(dll_name, RTLD_LAZY)) == NULL) {",
          "13515:    mg_snprintf(NULL,",
          "13517:                ebuf,",
          "13518:                ebuf_len,",
          "13519:                \"%s: cannot load %s\",",
          "13520:                __func__,",
          "13521:                dll_name);",
          "13522:    return NULL;",
          "13523:   }",
          "13525:   ok = 1;",
          "13526:   for (fp = sw; fp->name != NULL; fp++) {",
          "13529:    u.fp = (void (*)(void))dlsym(dll_handle, fp->name);",
          "13534:    u.p = dlsym(dll_handle, fp->name);",
          "13536:    if (u.fp == NULL) {",
          "13537:     if (ok) {",
          "13540:                  ebuf,",
          "13541:                  ebuf_len,",
          "13542:                  \"%s: %s: cannot find %s\",",
          "13543:                  __func__,",
          "13544:                  dll_name,",
          "13546:      ok = 0;",
          "13547:     } else {",
          "13548:      size_t cur_len = strlen(ebuf);",
          "13549:      if (!truncated) {",
          "13550:       mg_snprintf(NULL,",
          "13551:                   &truncated,",
          "13552:                   ebuf + cur_len,",
          "13553:                   ebuf_len - cur_len - 3,",
          "13554:                   \", %s\",",
          "13555:                   fp->name);",
          "13556:       if (truncated) {",
          "13558:        strcat(ebuf, \"...\");",
          "13559:       }",
          "13564:    } else {",
          "13565:     fp->ptr = u.fp;",
          "13569:   if (!ok) {",
          "13570:    (void)dlclose(dll_handle);",
          "13571:    return NULL;",
          "13572:   }",
          "13574:   return dll_handle;",
          "13591:  static int initialize_ssl(char *ebuf, size_t ebuf_len)",
          "13592:  {",
          "13594:   if (ebuf_len > 0) {",
          "13595:    ebuf[0] = 0;",
          "13596:   }",
          "13600:    cryptolib_dll_handle =",
          "13601:        load_dll(ebuf, ebuf_len, CRYPTO_LIB, crypto_sw);",
          "13602:    if (!cryptolib_dll_handle) {",
          "13603:     return 0;",
          "13604:    }",
          "13608:   if (mg_atomic_inc(&cryptolib_users) > 1) {",
          "13609:    return 1;",
          "13610:   }",
          "",
          "[Added Lines]",
          "13542: static void *",
          "13543: load_dll(char *ebuf, size_t ebuf_len, const char *dll_name, struct ssl_func *sw)",
          "13544: {",
          "13545:  union {",
          "13546:   void *p;",
          "13547:   void (*fp)(void);",
          "13548:  } u;",
          "13549:  void *dll_handle;",
          "13550:  struct ssl_func *fp;",
          "13551:  int ok;",
          "13552:  int truncated = 0;",
          "13554:  if ((dll_handle = dlopen(dll_name, RTLD_LAZY)) == NULL) {",
          "13555:   mg_snprintf(NULL,",
          "13557:               ebuf,",
          "13558:               ebuf_len,",
          "13559:               \"%s: cannot load %s\",",
          "13560:               __func__,",
          "13561:               dll_name);",
          "13562:   return NULL;",
          "13563:  }",
          "13565:  ok = 1;",
          "13566:  for (fp = sw; fp->name != NULL; fp++) {",
          "13569:   u.fp = (void (*)(void))dlsym(dll_handle, fp->name);",
          "13574:   u.p = dlsym(dll_handle, fp->name);",
          "13576:   if (u.fp == NULL) {",
          "13577:    if (ok) {",
          "13578:     mg_snprintf(NULL,",
          "13579:                 &truncated,",
          "13580:                 ebuf,",
          "13581:                 ebuf_len,",
          "13582:                 \"%s: %s: cannot find %s\",",
          "13583:                 __func__,",
          "13584:                 dll_name,",
          "13585:                 fp->name);",
          "13586:     ok = 0;",
          "13587:    } else {",
          "13588:     size_t cur_len = strlen(ebuf);",
          "13589:     if (!truncated) {",
          "13592:                  ebuf + cur_len,",
          "13593:                  ebuf_len - cur_len - 3,",
          "13594:                  \", %s\",",
          "13596:      if (truncated) {",
          "13598:       strcat(ebuf, \"...\");",
          "13604:   } else {",
          "13605:    fp->ptr = u.fp;",
          "13607:  }",
          "13609:  if (!ok) {",
          "13610:   (void)dlclose(dll_handle);",
          "13611:   return NULL;",
          "13614:  return dll_handle;",
          "13615: }",
          "13631: static int",
          "13632: initialize_ssl(char *ebuf, size_t ebuf_len)",
          "13633: {",
          "13635:  if (ebuf_len > 0) {",
          "13636:   ebuf[0] = 0;",
          "13637:  }",
          "13640:  if (!cryptolib_dll_handle) {",
          "13641:   cryptolib_dll_handle = load_dll(ebuf, ebuf_len, CRYPTO_LIB, crypto_sw);",
          "13643:    return 0;",
          "13645:  }",
          "13648:  if (mg_atomic_inc(&cryptolib_users) > 1) {",
          "13649:   return 1;",
          "13650:  }",
          "",
          "---------------",
          "--- Hunk 54 ---",
          "[Context before]",
          "13661:  CRYPTO_set_id_callback(&mg_current_thread_id);",
          "13665:  }",
          "13683:    mg_cry(fc(ctx),",
          "13685:           __func__,",
          "13686:           pem,",
          "13687:           ssl_error());",
          "13688:    return 0;",
          "13689:   }",
          "13718:  }",
          "13721: #ifdef OPENSSL_API_1_1",
          "13735: #else",
          "13736: static long",
          "13737: ssl_get_protocol(int version_id)",
          "",
          "[Removed Lines]",
          "13664:   return 1;",
          "13668:  static int ssl_use_pem_file(struct mg_context * ctx,",
          "13669:                              const char *pem,",
          "13670:                              const char *chain)",
          "13671:  {",
          "13672:   if (SSL_CTX_use_certificate_file(ctx->ssl_ctx, pem, 1) == 0) {",
          "13673:    mg_cry(fc(ctx),",
          "13674:           \"%s: cannot open certificate file %s: %s\",",
          "13675:           __func__,",
          "13676:           pem,",
          "13677:           ssl_error());",
          "13678:    return 0;",
          "13679:   }",
          "13682:   if (SSL_CTX_use_PrivateKey_file(ctx->ssl_ctx, pem, 1) == 0) {",
          "13684:           \"%s: cannot open private key file %s: %s\",",
          "13691:   if (SSL_CTX_check_private_key(ctx->ssl_ctx) == 0) {",
          "13692:    mg_cry(fc(ctx),",
          "13693:           \"%s: certificate and private key do not match: %s\",",
          "13694:           __func__,",
          "13695:           pem);",
          "13696:    return 0;",
          "13697:   }",
          "13707:   if (chain) {",
          "13708:    if (SSL_CTX_use_certificate_chain_file(ctx->ssl_ctx, chain) == 0) {",
          "13709:     mg_cry(fc(ctx),",
          "13710:            \"%s: cannot use certificate chain file %s: %s\",",
          "13711:            __func__,",
          "13712:            pem,",
          "13713:            ssl_error());",
          "13714:     return 0;",
          "13715:    }",
          "13716:   }",
          "13717:   return 1;",
          "13722:  static unsigned long ssl_get_protocol(int version_id)",
          "13723:  {",
          "13724:   long unsigned ret = SSL_OP_ALL;",
          "13725:   if (version_id > 0)",
          "13726:    ret |= SSL_OP_NO_SSLv2;",
          "13727:   if (version_id > 1)",
          "13728:    ret |= SSL_OP_NO_SSLv3;",
          "13729:   if (version_id > 2)",
          "13730:    ret |= SSL_OP_NO_TLSv1;",
          "13731:   if (version_id > 3)",
          "13732:    ret |= SSL_OP_NO_TLSv1_1;",
          "13733:   return ret;",
          "13734:  }",
          "",
          "[Added Lines]",
          "13704:  return 1;",
          "13705: }",
          "13708: static int",
          "13709: ssl_use_pem_file(struct mg_context *ctx, const char *pem, const char *chain)",
          "13710: {",
          "13711:  if (SSL_CTX_use_certificate_file(ctx->ssl_ctx, pem, 1) == 0) {",
          "13712:   mg_cry(fc(ctx),",
          "13713:          \"%s: cannot open certificate file %s: %s\",",
          "13714:          __func__,",
          "13715:          pem,",
          "13716:          ssl_error());",
          "13717:   return 0;",
          "13721:  if (SSL_CTX_use_PrivateKey_file(ctx->ssl_ctx, pem, 1) == 0) {",
          "13722:   mg_cry(fc(ctx),",
          "13723:          \"%s: cannot open private key file %s: %s\",",
          "13724:          __func__,",
          "13725:          pem,",
          "13726:          ssl_error());",
          "13727:   return 0;",
          "13728:  }",
          "13730:  if (SSL_CTX_check_private_key(ctx->ssl_ctx) == 0) {",
          "13731:   mg_cry(fc(ctx),",
          "13732:          \"%s: certificate and private key do not match: %s\",",
          "13733:          __func__,",
          "13734:          pem);",
          "13735:   return 0;",
          "13736:  }",
          "13746:  if (chain) {",
          "13747:   if (SSL_CTX_use_certificate_chain_file(ctx->ssl_ctx, chain) == 0) {",
          "13749:           \"%s: cannot use certificate chain file %s: %s\",",
          "13756:  return 1;",
          "13757: }",
          "13761: static unsigned long",
          "13762: ssl_get_protocol(int version_id)",
          "13763: {",
          "13764:  long unsigned ret = SSL_OP_ALL;",
          "13765:  if (version_id > 0)",
          "13766:   ret |= SSL_OP_NO_SSLv2;",
          "13767:  if (version_id > 1)",
          "13768:   ret |= SSL_OP_NO_SSLv3;",
          "13769:  if (version_id > 2)",
          "13770:   ret |= SSL_OP_NO_TLSv1;",
          "13771:  if (version_id > 3)",
          "13772:   ret |= SSL_OP_NO_TLSv1_1;",
          "13773:  return ret;",
          "13774: }",
          "",
          "---------------",
          "--- Hunk 55 ---",
          "[Context before]",
          "13794: #if !defined(NO_SSL_DL)",
          "13795:   if (!ssllib_dll_handle) {",
          "13801:   }",
          "13804: #ifdef OPENSSL_API_1_1",
          "13815: #else",
          "13817:  SSL_library_init();",
          "",
          "[Removed Lines]",
          "13754:  static int set_ssl_option(struct mg_context * ctx)",
          "13755:  {",
          "13756:   const char *pem;",
          "13757:   const char *chain;",
          "13758:   int callback_ret;",
          "13759:   int should_verify_peer;",
          "13760:   int peer_certificate_optional;",
          "13761:   const char *ca_path;",
          "13762:   const char *ca_file;",
          "13763:   int use_default_verify_paths;",
          "13764:   int verify_depth;",
          "13765:   time_t now_rt = time(NULL);",
          "13766:   struct timespec now_mt;",
          "13767:   md5_byte_t ssl_context_id[16];",
          "13768:   md5_state_t md5state;",
          "13769:   int protocol_ver;",
          "13770:   char ebuf[128];",
          "13774:   if (!ctx) {",
          "13775:    return 0;",
          "13776:   }",
          "13777:   if ((pem = ctx->config[SSL_CERTIFICATE]) == NULL",
          "13778:       && ctx->callbacks.init_ssl == NULL) {",
          "13779:    return 1;",
          "13780:   }",
          "13781:   chain = ctx->config[SSL_CERTIFICATE_CHAIN];",
          "13782:   if (chain == NULL) {",
          "13783:    chain = pem;",
          "13784:   }",
          "13785:   if ((chain != NULL) && (*chain == 0)) {",
          "13786:    chain = NULL;",
          "13787:   }",
          "13789:   if (!initialize_ssl(ebuf, sizeof(ebuf))) {",
          "13790:    mg_cry(fc(ctx), \"%s\", ebuf);",
          "13791:    return 0;",
          "13792:   }",
          "13796:    ssllib_dll_handle = load_dll(ebuf, sizeof(ebuf), SSL_LIB, ssl_sw);",
          "13797:    if (!ssllib_dll_handle) {",
          "13798:     mg_cry(fc(ctx), \"%s\", ebuf);",
          "13799:     return 0;",
          "13800:    }",
          "13806:   OPENSSL_init_ssl(0, NULL);",
          "13807:   OPENSSL_init_ssl(OPENSSL_INIT_LOAD_SSL_STRINGS",
          "13808:                        | OPENSSL_INIT_LOAD_CRYPTO_STRINGS,",
          "13809:                    NULL);",
          "13811:   if ((ctx->ssl_ctx = SSL_CTX_new(TLS_server_method())) == NULL) {",
          "13812:    mg_cry(fc(ctx), \"SSL_CTX_new (server) error: %s\", ssl_error());",
          "13813:    return 0;",
          "13814:   }",
          "",
          "[Added Lines]",
          "13794: static int",
          "13795: set_ssl_option(struct mg_context *ctx)",
          "13796: {",
          "13797:  const char *pem;",
          "13798:  const char *chain;",
          "13799:  int callback_ret;",
          "13800:  int should_verify_peer;",
          "13801:  int peer_certificate_optional;",
          "13802:  const char *ca_path;",
          "13803:  const char *ca_file;",
          "13804:  int use_default_verify_paths;",
          "13805:  int verify_depth;",
          "13806:  time_t now_rt = time(NULL);",
          "13807:  struct timespec now_mt;",
          "13808:  md5_byte_t ssl_context_id[16];",
          "13809:  md5_state_t md5state;",
          "13810:  int protocol_ver;",
          "13811:  char ebuf[128];",
          "13815:  if (!ctx) {",
          "13816:   return 0;",
          "13817:  }",
          "13818:  if ((pem = ctx->config[SSL_CERTIFICATE]) == NULL",
          "13819:      && ctx->callbacks.init_ssl == NULL) {",
          "13820:   return 1;",
          "13821:  }",
          "13822:  chain = ctx->config[SSL_CERTIFICATE_CHAIN];",
          "13823:  if (chain == NULL) {",
          "13824:   chain = pem;",
          "13825:  }",
          "13826:  if ((chain != NULL) && (*chain == 0)) {",
          "13827:   chain = NULL;",
          "13828:  }",
          "13830:  if (!initialize_ssl(ebuf, sizeof(ebuf))) {",
          "13831:   mg_cry(fc(ctx), \"%s\", ebuf);",
          "13832:   return 0;",
          "13833:  }",
          "13836:  if (!ssllib_dll_handle) {",
          "13837:   ssllib_dll_handle = load_dll(ebuf, sizeof(ebuf), SSL_LIB, ssl_sw);",
          "13839:    mg_cry(fc(ctx), \"%s\", ebuf);",
          "13840:    return 0;",
          "13842:  }",
          "13847:  OPENSSL_init_ssl(0, NULL);",
          "13848:  OPENSSL_init_ssl(OPENSSL_INIT_LOAD_SSL_STRINGS",
          "13849:                       | OPENSSL_INIT_LOAD_CRYPTO_STRINGS,",
          "13850:                   NULL);",
          "13852:  if ((ctx->ssl_ctx = SSL_CTX_new(TLS_server_method())) == NULL) {",
          "13853:   mg_cry(fc(ctx), \"SSL_CTX_new (server) error: %s\", ssl_error());",
          "13854:   return 0;",
          "13855:  }",
          "",
          "---------------",
          "--- Hunk 56 ---",
          "[Context before]",
          "13823:  }",
          "13833: #if !defined(NO_SSL_DL)",
          "13855:   }",
          "13876:   }",
          "13893:   }",
          "13936:   }",
          "13945:   }",
          "13948:  }",
          "13953: #ifdef OPENSSL_API_1_1",
          "13962: #else",
          "13963:  int i;",
          "",
          "[Removed Lines]",
          "13826:   SSL_CTX_clear_options(ctx->ssl_ctx,",
          "13827:                         SSL_OP_NO_SSLv2 | SSL_OP_NO_SSLv3",
          "13828:                             | SSL_OP_NO_TLSv1 | SSL_OP_NO_TLSv1_1);",
          "13829:   protocol_ver = atoi(ctx->config[SSL_PROTOCOL_VERSION]);",
          "13830:   SSL_CTX_set_options(ctx->ssl_ctx, ssl_get_protocol(protocol_ver));",
          "13831:   SSL_CTX_set_options(ctx->ssl_ctx, SSL_OP_SINGLE_DH_USE);",
          "13832:   SSL_CTX_set_options(ctx->ssl_ctx, SSL_OP_CIPHER_SERVER_PREFERENCE);",
          "13834:   SSL_CTX_set_ecdh_auto(ctx->ssl_ctx, 1);",
          "13838:   callback_ret =",
          "13839:       (ctx->callbacks.init_ssl == NULL)",
          "13840:           ? 0",
          "13841:           : (ctx->callbacks.init_ssl(ctx->ssl_ctx, ctx->user_data));",
          "13846:   if (callback_ret < 0) {",
          "13847:    mg_cry(fc(ctx), \"SSL callback returned error: %i\", callback_ret);",
          "13848:    return 0;",
          "13849:   }",
          "13850:   if (callback_ret > 0) {",
          "13851:    if (pem != NULL) {",
          "13852:     (void)SSL_CTX_use_certificate_chain_file(ctx->ssl_ctx, pem);",
          "13853:    }",
          "13854:    return 1;",
          "13858:   md5_init(&md5state);",
          "13859:   md5_append(&md5state, (const md5_byte_t *)&now_rt, sizeof(now_rt));",
          "13860:   clock_gettime(CLOCK_MONOTONIC, &now_mt);",
          "13861:   md5_append(&md5state, (const md5_byte_t *)&now_mt, sizeof(now_mt));",
          "13862:   md5_append(&md5state,",
          "13863:              (const md5_byte_t *)ctx->config[LISTENING_PORTS],",
          "13864:              strlen(ctx->config[LISTENING_PORTS]));",
          "13865:   md5_append(&md5state, (const md5_byte_t *)ctx, sizeof(*ctx));",
          "13866:   md5_finish(&md5state, ssl_context_id);",
          "13868:   SSL_CTX_set_session_id_context(ctx->ssl_ctx,",
          "13869:                                  (const unsigned char *)&ssl_context_id,",
          "13870:                                  sizeof(ssl_context_id));",
          "13872:   if (pem != NULL) {",
          "13873:    if (!ssl_use_pem_file(ctx, pem, chain)) {",
          "13874:     return 0;",
          "13875:    }",
          "13880:   should_verify_peer = 0;",
          "13881:   peer_certificate_optional = 0;",
          "13882:   if (ctx->config[SSL_DO_VERIFY_PEER] != NULL) {",
          "13883:    if (mg_strcasecmp(ctx->config[SSL_DO_VERIFY_PEER], \"yes\") == 0) {",
          "13885:     should_verify_peer = 1;",
          "13886:     peer_certificate_optional = 0;",
          "13887:    } else if (mg_strcasecmp(ctx->config[SSL_DO_VERIFY_PEER],",
          "13888:                             \"optional\") == 0) {",
          "13890:     should_verify_peer = 1;",
          "13891:     peer_certificate_optional = 1;",
          "13892:    }",
          "13895:   use_default_verify_paths =",
          "13896:       (ctx->config[SSL_DEFAULT_VERIFY_PATHS] != NULL)",
          "13897:       && (mg_strcasecmp(ctx->config[SSL_DEFAULT_VERIFY_PATHS], \"yes\")",
          "13898:           == 0);",
          "13900:   if (should_verify_peer) {",
          "13901:    ca_path = ctx->config[SSL_CA_PATH];",
          "13902:    ca_file = ctx->config[SSL_CA_FILE];",
          "13903:    if (SSL_CTX_load_verify_locations(ctx->ssl_ctx, ca_file, ca_path)",
          "13904:        != 1) {",
          "13905:     mg_cry(fc(ctx),",
          "13906:            \"SSL_CTX_load_verify_locations error: %s \"",
          "13907:            \"ssl_verify_peer requires setting \"",
          "13908:            \"either ssl_ca_path or ssl_ca_file. Is any of them \"",
          "13909:            \"present in \"",
          "13910:            \"the .conf file?\",",
          "13911:            ssl_error());",
          "13912:     return 0;",
          "13913:    }",
          "13915:    if (peer_certificate_optional) {",
          "13916:     SSL_CTX_set_verify(ctx->ssl_ctx, SSL_VERIFY_PEER, NULL);",
          "13917:    } else {",
          "13918:     SSL_CTX_set_verify(ctx->ssl_ctx,",
          "13919:                        SSL_VERIFY_PEER",
          "13920:                            | SSL_VERIFY_FAIL_IF_NO_PEER_CERT,",
          "13921:                        NULL);",
          "13922:    }",
          "13924:    if (use_default_verify_paths",
          "13925:        && (SSL_CTX_set_default_verify_paths(ctx->ssl_ctx) != 1)) {",
          "13926:     mg_cry(fc(ctx),",
          "13927:            \"SSL_CTX_set_default_verify_paths error: %s\",",
          "13928:            ssl_error());",
          "13929:     return 0;",
          "13930:    }",
          "13932:    if (ctx->config[SSL_VERIFY_DEPTH]) {",
          "13933:     verify_depth = atoi(ctx->config[SSL_VERIFY_DEPTH]);",
          "13934:     SSL_CTX_set_verify_depth(ctx->ssl_ctx, verify_depth);",
          "13935:    }",
          "13938:   if (ctx->config[SSL_CIPHER_LIST] != NULL) {",
          "13939:    if (SSL_CTX_set_cipher_list(ctx->ssl_ctx,",
          "13940:                                ctx->config[SSL_CIPHER_LIST]) != 1) {",
          "13941:     mg_cry(fc(ctx),",
          "13942:            \"SSL_CTX_set_cipher_list error: %s\",",
          "13943:            ssl_error());",
          "13944:    }",
          "13947:   return 1;",
          "13951:  static void uninitialize_ssl(void)",
          "13952:  {",
          "13955:   if (mg_atomic_dec(&cryptolib_users) == 0) {",
          "13961:    CONF_modules_unload(1);",
          "",
          "[Added Lines]",
          "13867:  SSL_CTX_clear_options(ctx->ssl_ctx,",
          "13868:                        SSL_OP_NO_SSLv2 | SSL_OP_NO_SSLv3 | SSL_OP_NO_TLSv1",
          "13869:                            | SSL_OP_NO_TLSv1_1);",
          "13870:  protocol_ver = atoi(ctx->config[SSL_PROTOCOL_VERSION]);",
          "13871:  SSL_CTX_set_options(ctx->ssl_ctx, ssl_get_protocol(protocol_ver));",
          "13872:  SSL_CTX_set_options(ctx->ssl_ctx, SSL_OP_SINGLE_DH_USE);",
          "13873:  SSL_CTX_set_options(ctx->ssl_ctx, SSL_OP_CIPHER_SERVER_PREFERENCE);",
          "13875:  SSL_CTX_set_ecdh_auto(ctx->ssl_ctx, 1);",
          "13879:  callback_ret =",
          "13880:      (ctx->callbacks.init_ssl == NULL)",
          "13881:          ? 0",
          "13882:          : (ctx->callbacks.init_ssl(ctx->ssl_ctx, ctx->user_data));",
          "13887:  if (callback_ret < 0) {",
          "13888:   mg_cry(fc(ctx), \"SSL callback returned error: %i\", callback_ret);",
          "13889:   return 0;",
          "13890:  }",
          "13891:  if (callback_ret > 0) {",
          "13892:   if (pem != NULL) {",
          "13893:    (void)SSL_CTX_use_certificate_chain_file(ctx->ssl_ctx, pem);",
          "13895:   return 1;",
          "13896:  }",
          "13899:  md5_init(&md5state);",
          "13900:  md5_append(&md5state, (const md5_byte_t *)&now_rt, sizeof(now_rt));",
          "13901:  clock_gettime(CLOCK_MONOTONIC, &now_mt);",
          "13902:  md5_append(&md5state, (const md5_byte_t *)&now_mt, sizeof(now_mt));",
          "13903:  md5_append(&md5state,",
          "13904:             (const md5_byte_t *)ctx->config[LISTENING_PORTS],",
          "13905:             strlen(ctx->config[LISTENING_PORTS]));",
          "13906:  md5_append(&md5state, (const md5_byte_t *)ctx, sizeof(*ctx));",
          "13907:  md5_finish(&md5state, ssl_context_id);",
          "13909:  SSL_CTX_set_session_id_context(ctx->ssl_ctx,",
          "13910:                                 (const unsigned char *)&ssl_context_id,",
          "13911:                                 sizeof(ssl_context_id));",
          "13913:  if (pem != NULL) {",
          "13914:   if (!ssl_use_pem_file(ctx, pem, chain)) {",
          "13915:    return 0;",
          "13917:  }",
          "13921:  should_verify_peer = 0;",
          "13922:  peer_certificate_optional = 0;",
          "13923:  if (ctx->config[SSL_DO_VERIFY_PEER] != NULL) {",
          "13924:   if (mg_strcasecmp(ctx->config[SSL_DO_VERIFY_PEER], \"yes\") == 0) {",
          "13926:    should_verify_peer = 1;",
          "13927:    peer_certificate_optional = 0;",
          "13928:   } else if (mg_strcasecmp(ctx->config[SSL_DO_VERIFY_PEER], \"optional\")",
          "13929:              == 0) {",
          "13931:    should_verify_peer = 1;",
          "13932:    peer_certificate_optional = 1;",
          "13934:  }",
          "13936:  use_default_verify_paths =",
          "13937:      (ctx->config[SSL_DEFAULT_VERIFY_PATHS] != NULL)",
          "13938:      && (mg_strcasecmp(ctx->config[SSL_DEFAULT_VERIFY_PATHS], \"yes\") == 0);",
          "13940:  if (should_verify_peer) {",
          "13941:   ca_path = ctx->config[SSL_CA_PATH];",
          "13942:   ca_file = ctx->config[SSL_CA_FILE];",
          "13943:   if (SSL_CTX_load_verify_locations(ctx->ssl_ctx, ca_file, ca_path)",
          "13944:       != 1) {",
          "13945:    mg_cry(fc(ctx),",
          "13946:           \"SSL_CTX_load_verify_locations error: %s \"",
          "13947:           \"ssl_verify_peer requires setting \"",
          "13948:           \"either ssl_ca_path or ssl_ca_file. Is any of them \"",
          "13949:           \"present in \"",
          "13950:           \"the .conf file?\",",
          "13951:           ssl_error());",
          "13952:    return 0;",
          "13953:   }",
          "13955:   if (peer_certificate_optional) {",
          "13956:    SSL_CTX_set_verify(ctx->ssl_ctx, SSL_VERIFY_PEER, NULL);",
          "13957:   } else {",
          "13958:    SSL_CTX_set_verify(ctx->ssl_ctx,",
          "13959:                       SSL_VERIFY_PEER",
          "13960:                           | SSL_VERIFY_FAIL_IF_NO_PEER_CERT,",
          "13961:                       NULL);",
          "13962:   }",
          "13964:   if (use_default_verify_paths",
          "13965:       && (SSL_CTX_set_default_verify_paths(ctx->ssl_ctx) != 1)) {",
          "13966:    mg_cry(fc(ctx),",
          "13967:           \"SSL_CTX_set_default_verify_paths error: %s\",",
          "13968:           ssl_error());",
          "13969:    return 0;",
          "13972:   if (ctx->config[SSL_VERIFY_DEPTH]) {",
          "13973:    verify_depth = atoi(ctx->config[SSL_VERIFY_DEPTH]);",
          "13974:    SSL_CTX_set_verify_depth(ctx->ssl_ctx, verify_depth);",
          "13976:  }",
          "13978:  if (ctx->config[SSL_CIPHER_LIST] != NULL) {",
          "13979:   if (SSL_CTX_set_cipher_list(ctx->ssl_ctx, ctx->config[SSL_CIPHER_LIST])",
          "13980:       != 1) {",
          "13981:    mg_cry(fc(ctx), \"SSL_CTX_set_cipher_list error: %s\", ssl_error());",
          "13982:   }",
          "13985:  return 1;",
          "13986: }",
          "13989: static void",
          "13990: uninitialize_ssl(void)",
          "13991: {",
          "13994:  if (mg_atomic_dec(&cryptolib_users) == 0) {",
          "14000:   CONF_modules_unload(1);",
          "",
          "---------------",
          "--- Hunk 57 ---",
          "[Context before]",
          "13983:   mg_free(ssl_mutexes);",
          "13984:   ssl_mutexes = NULL;",
          "13987:  }",
          "14001:   }",
          "14009:  }",
          "14042: #if defined(MG_LEGACY_INTERFACE)",
          "14045: #endif",
          "14049: #if 0",
          "",
          "[Removed Lines]",
          "13986:   }",
          "13991:  static int set_gpass_option(struct mg_context * ctx)",
          "13992:  {",
          "13993:   if (ctx) {",
          "13994:    struct mg_file file = STRUCT_FILE_INITIALIZER;",
          "13995:    const char *path = ctx->config[GLOBAL_PASSWORDS_FILE];",
          "13996:    if ((path != NULL) && !mg_stat(fc(ctx), path, &file.stat)) {",
          "13997:     mg_cry(fc(ctx), \"Cannot open %s: %s\", path, strerror(ERRNO));",
          "13998:     return 0;",
          "13999:    }",
          "14000:    return 1;",
          "14002:   return 0;",
          "14003:  }",
          "14006:  static int set_acl_option(struct mg_context * ctx)",
          "14007:  {",
          "14008:   return check_acl(ctx, (uint32_t)0x7f000001UL) != -1;",
          "14012:  static void reset_per_request_attributes(struct mg_connection * conn)",
          "14013:  {",
          "14014:   if (!conn) {",
          "14015:    return;",
          "14016:   }",
          "14019:   conn->path_info = NULL;",
          "14020:   conn->num_bytes_sent = conn->consumed_content = 0;",
          "14021:   conn->status_code = -1;",
          "14022:   conn->is_chunked = 0;",
          "14023:   conn->must_close = 0;",
          "14024:   conn->request_len = 0;",
          "14025:   conn->throttle = 0;",
          "14026:   conn->data_len = 0;",
          "14027:   conn->chunk_remainder = 0;",
          "14029:   conn->response_info.content_length = conn->request_info.content_length =",
          "14030:       -1;",
          "14031:   conn->response_info.http_version = conn->request_info.http_version =",
          "14032:       NULL;",
          "14033:   conn->response_info.num_headers = conn->request_info.num_headers = 0;",
          "14034:   conn->response_info.status_text = NULL;",
          "14035:   conn->response_info.status_code = 0;",
          "14037:   conn->request_info.remote_user = NULL;",
          "14038:   conn->request_info.request_method = NULL;",
          "14039:   conn->request_info.request_uri = NULL;",
          "14040:   conn->request_info.local_uri = NULL;",
          "14044:   conn->request_info.uri = NULL;",
          "14046:  }",
          "",
          "[Added Lines]",
          "14026: }",
          "14030: static int",
          "14031: set_gpass_option(struct mg_context *ctx)",
          "14032: {",
          "14033:  if (ctx) {",
          "14034:   struct mg_file file = STRUCT_FILE_INITIALIZER;",
          "14035:   const char *path = ctx->config[GLOBAL_PASSWORDS_FILE];",
          "14036:   if ((path != NULL) && !mg_stat(fc(ctx), path, &file.stat)) {",
          "14037:    mg_cry(fc(ctx), \"Cannot open %s: %s\", path, strerror(ERRNO));",
          "14038:    return 0;",
          "14040:   return 1;",
          "14042:  return 0;",
          "14043: }",
          "14046: static int",
          "14047: set_acl_option(struct mg_context *ctx)",
          "14048: {",
          "14049:  return check_acl(ctx, (uint32_t)0x7f000001UL) != -1;",
          "14050: }",
          "14053: static void",
          "14054: reset_per_request_attributes(struct mg_connection *conn)",
          "14055: {",
          "14056:  if (!conn) {",
          "14057:   return;",
          "14058:  }",
          "14061:  conn->path_info = NULL;",
          "14062:  conn->num_bytes_sent = conn->consumed_content = 0;",
          "14063:  conn->status_code = -1;",
          "14064:  conn->is_chunked = 0;",
          "14065:  conn->must_close = 0;",
          "14066:  conn->request_len = 0;",
          "14067:  conn->throttle = 0;",
          "14068:  conn->data_len = 0;",
          "14069:  conn->chunk_remainder = 0;",
          "14071:  conn->response_info.content_length = conn->request_info.content_length = -1;",
          "14072:  conn->response_info.http_version = conn->request_info.http_version = NULL;",
          "14073:  conn->response_info.num_headers = conn->request_info.num_headers = 0;",
          "14074:  conn->response_info.status_text = NULL;",
          "14075:  conn->response_info.status_code = 0;",
          "14077:  conn->request_info.remote_user = NULL;",
          "14078:  conn->request_info.request_method = NULL;",
          "14079:  conn->request_info.request_uri = NULL;",
          "14080:  conn->request_info.local_uri = NULL;",
          "14084:  conn->request_info.uri = NULL;",
          "14086: }",
          "",
          "---------------",
          "--- Hunk 58 ---",
          "[Context before]",
          "14095: #endif",
          "14110:  }",
          "14115: #if defined(_WIN32)",
          "14118: #endif",
          "14137: #if defined(_WIN32)",
          "14159: #if defined(_MSC_VER)",
          "14160: #pragma warning(push)",
          "14161: #pragma warning(disable : 4244)",
          "14162: #endif",
          "14164: #if defined(_MSC_VER)",
          "14165: #pragma warning(pop)",
          "14166: #endif",
          "14182:    mg_cry(conn,",
          "14184:           __func__,",
          "14185:           strerror(ERRNO));",
          "14204:   }",
          "14209:  }",
          "14218: #if defined(USE_LUA) && defined(USE_WEBSOCKET)",
          "14223: #endif",
          "14240: #ifndef NO_SSL",
          "14248: #ifndef OPENSSL_API_1_1",
          "14250: #endif",
          "14253: #endif",
          "14260:  }",
          "14265: #if defined(USE_WEBSOCKET)",
          "14273: #if defined(USE_WEBSOCKET)",
          "14293:    }",
          "14294:   }",
          "14299: #ifndef NO_SSL",
          "14303: #endif",
          "14305: #if defined(USE_WEBSOCKET)",
          "14315: #else",
          "14317:   mg_free(conn);",
          "14318:  }",
          "14361: #ifndef NO_SSL",
          "14362: #ifdef OPENSSL_API_1_1",
          "14375: #else",
          "14376:  if (use_ssl",
          "14377:      && (conn->client_ssl_ctx = SSL_CTX_new(SSLv23_client_method()))",
          "",
          "[Removed Lines]",
          "14098:  static int set_tcp_nodelay(SOCKET sock, int nodelay_on)",
          "14099:  {",
          "14100:   if (setsockopt(sock,",
          "14101:                  IPPROTO_TCP,",
          "14102:                  TCP_NODELAY,",
          "14103:                  (SOCK_OPT_TYPE)&nodelay_on,",
          "14104:                  sizeof(nodelay_on)) != 0) {",
          "14106:    return 1;",
          "14107:   }",
          "14109:   return 0;",
          "14113:  static void close_socket_gracefully(struct mg_connection * conn)",
          "14114:  {",
          "14116:   char buf[MG_BUF_LEN];",
          "14117:   int n;",
          "14119:   struct linger linger;",
          "14120:   int error_code = 0;",
          "14121:   int linger_timeout = -2;",
          "14122:   socklen_t opt_len = sizeof(error_code);",
          "14124:   if (!conn) {",
          "14125:    return;",
          "14126:   }",
          "14131:   set_blocking_mode(conn->client.sock, 1);",
          "14134:   shutdown(conn->client.sock, SHUTDOWN_WR);",
          "14144:   do {",
          "14145:    n = pull_inner(",
          "14146:        NULL, conn, buf, sizeof(buf), /* Timeout in s: */ 1.0);",
          "14147:   } while (n > 0);",
          "14148: #endif",
          "14150:   if (conn->ctx->config[LINGER_TIMEOUT]) {",
          "14151:    linger_timeout = atoi(conn->ctx->config[LINGER_TIMEOUT]);",
          "14152:   }",
          "14155:   if (linger_timeout >= 0) {",
          "14158:    linger.l_onoff = 1;",
          "14163:    linger.l_linger = (linger_timeout + 999) / 1000;",
          "14167:   } else {",
          "14168:    linger.l_onoff = 0;",
          "14169:    linger.l_linger = 0;",
          "14170:   }",
          "14172:   if (linger_timeout < -1) {",
          "14174:   } else if (getsockopt(conn->client.sock,",
          "14175:                         SOL_SOCKET,",
          "14176:                         SO_ERROR,",
          "14177:                         (char *)&error_code,",
          "14178:                         &opt_len) != 0) {",
          "14183:           \"%s: getsockopt(SOL_SOCKET SO_ERROR) failed: %s\",",
          "14186:   } else if (error_code == ECONNRESET) {",
          "14189:   } else {",
          "14192:    if (setsockopt(conn->client.sock,",
          "14193:                   SOL_SOCKET,",
          "14194:                   SO_LINGER,",
          "14195:                   (char *)&linger,",
          "14196:                   sizeof(linger)) != 0) {",
          "14197:     mg_cry(conn,",
          "14198:            \"%s: setsockopt(SOL_SOCKET SO_LINGER(%i,%i)) failed: %s\",",
          "14199:            __func__,",
          "14200:            linger.l_onoff,",
          "14201:            linger.l_linger,",
          "14202:            strerror(ERRNO));",
          "14203:    }",
          "14207:   closesocket(conn->client.sock);",
          "14208:   conn->client.sock = INVALID_SOCKET;",
          "14212:  static void close_connection(struct mg_connection * conn)",
          "14213:  {",
          "14214:   if (!conn || !conn->ctx) {",
          "14215:    return;",
          "14216:   }",
          "14219:   if (conn->lua_websocket_state) {",
          "14220:    lua_websocket_close(conn, conn->lua_websocket_state);",
          "14221:    conn->lua_websocket_state = NULL;",
          "14222:   }",
          "14226:   if ((conn->ctx->callbacks.connection_close != NULL)",
          "14227:       && (conn->ctx->context_type == 1)) {",
          "14228:    conn->ctx->callbacks.connection_close(conn);",
          "14229:   }",
          "14234:   mg_set_user_connection_data(conn, NULL);",
          "14236:   mg_lock_connection(conn);",
          "14238:   conn->must_close = 1;",
          "14241:   if (conn->ssl != NULL) {",
          "14244:    SSL_shutdown(conn->ssl);",
          "14245:    SSL_free(conn->ssl);",
          "14249:    ERR_remove_state(0);",
          "14251:    conn->ssl = NULL;",
          "14252:   }",
          "14254:   if (conn->client.sock != INVALID_SOCKET) {",
          "14255:    close_socket_gracefully(conn);",
          "14256:    conn->client.sock = INVALID_SOCKET;",
          "14257:   }",
          "14259:   mg_unlock_connection(conn);",
          "14263:  void mg_close_connection(struct mg_connection * conn)",
          "14264:  {",
          "14266:   struct mg_context *client_ctx = NULL;",
          "14269:   if (conn == NULL) {",
          "14270:    return;",
          "14271:   }",
          "14274:   if (conn->ctx->context_type == 2) {",
          "14275:    unsigned int i;",
          "14278:    client_ctx = conn->ctx;",
          "14281:    conn->ctx->stop_flag = 1;",
          "14289:    for (i = 0; i < client_ctx->cfg_worker_threads; i++) {",
          "14290:     if (client_ctx->worker_threadids[i] != 0) {",
          "14291:      mg_join_thread(client_ctx->worker_threadids[i]);",
          "14292:     }",
          "14297:   close_connection(conn);",
          "14300:   if (conn->client_ssl_ctx != NULL) {",
          "14301:    SSL_CTX_free((SSL_CTX *)conn->client_ssl_ctx);",
          "14302:   }",
          "14306:   if (client_ctx != NULL) {",
          "14308:    mg_free(client_ctx->worker_threadids);",
          "14309:    mg_free(client_ctx);",
          "14310:    (void)pthread_mutex_destroy(&conn->mutex);",
          "14311:    mg_free(conn);",
          "14313:    mg_free(conn);",
          "14314:   }",
          "14320:  }",
          "14323:  static struct mg_context common_client_context;",
          "14326:  static struct mg_connection *mg_connect_client_impl(",
          "14327:      const struct mg_client_options *client_options,",
          "14328:      int use_ssl,",
          "14329:      char *ebuf,",
          "14330:      size_t ebuf_len)",
          "14331:  {",
          "14332:   struct mg_connection *conn = NULL;",
          "14333:   SOCKET sock;",
          "14334:   union usa sa;",
          "14335:   unsigned max_req_size =",
          "14336:       (unsigned)atoi(config_options[MAX_REQUEST_SIZE].default_value);",
          "14338:   if (!connect_socket(&common_client_context,",
          "14339:                       client_options->host,",
          "14340:                       client_options->port,",
          "14341:                       use_ssl,",
          "14342:                       ebuf,",
          "14343:                       ebuf_len,",
          "14344:                       &sock,",
          "14345:                       &sa)) {",
          "14346:    return NULL;",
          "14347:   }",
          "14348:   if ((conn = (struct mg_connection *)mg_calloc_ctx(",
          "14349:            1, sizeof(*conn) + max_req_size, &common_client_context))",
          "14350:       == NULL) {",
          "14351:    mg_snprintf(NULL,",
          "14353:                ebuf,",
          "14354:                ebuf_len,",
          "14355:                \"calloc(): %s\",",
          "14356:                strerror(ERRNO));",
          "14357:    closesocket(sock);",
          "14358:    return NULL;",
          "14359:   }",
          "14363:   if (use_ssl",
          "14364:       && (conn->client_ssl_ctx = SSL_CTX_new(TLS_client_method()))",
          "14365:              == NULL) {",
          "14366:    mg_snprintf(NULL,",
          "14368:                ebuf,",
          "14369:                ebuf_len,",
          "14370:                \"SSL_CTX_new error\");",
          "14371:    closesocket(sock);",
          "14372:    mg_free(conn);",
          "14373:    return NULL;",
          "14374:   }",
          "",
          "[Added Lines]",
          "14138: static int",
          "14139: set_tcp_nodelay(SOCKET sock, int nodelay_on)",
          "14140: {",
          "14141:  if (setsockopt(sock,",
          "14142:                 IPPROTO_TCP,",
          "14143:                 TCP_NODELAY,",
          "14144:                 (SOCK_OPT_TYPE)&nodelay_on,",
          "14145:                 sizeof(nodelay_on)) != 0) {",
          "14147:   return 1;",
          "14150:  return 0;",
          "14151: }",
          "14154: static void",
          "14155: close_socket_gracefully(struct mg_connection *conn)",
          "14156: {",
          "14158:  char buf[MG_BUF_LEN];",
          "14159:  int n;",
          "14161:  struct linger linger;",
          "14162:  int error_code = 0;",
          "14163:  int linger_timeout = -2;",
          "14164:  socklen_t opt_len = sizeof(error_code);",
          "14166:  if (!conn) {",
          "14167:   return;",
          "14168:  }",
          "14173:  set_blocking_mode(conn->client.sock, 1);",
          "14176:  shutdown(conn->client.sock, SHUTDOWN_WR);",
          "14186:  do {",
          "14187:   n = pull_inner(NULL, conn, buf, sizeof(buf), /* Timeout in s: */ 1.0);",
          "14188:  } while (n > 0);",
          "14189: #endif",
          "14191:  if (conn->ctx->config[LINGER_TIMEOUT]) {",
          "14192:   linger_timeout = atoi(conn->ctx->config[LINGER_TIMEOUT]);",
          "14193:  }",
          "14196:  if (linger_timeout >= 0) {",
          "14199:   linger.l_onoff = 1;",
          "14204:   linger.l_linger = (linger_timeout + 999) / 1000;",
          "14208:  } else {",
          "14209:   linger.l_onoff = 0;",
          "14210:   linger.l_linger = 0;",
          "14211:  }",
          "14213:  if (linger_timeout < -1) {",
          "14215:  } else if (getsockopt(conn->client.sock,",
          "14216:                        SOL_SOCKET,",
          "14217:                        SO_ERROR,",
          "14218:                        (char *)&error_code,",
          "14219:                        &opt_len) != 0) {",
          "14223:   mg_cry(conn,",
          "14224:          \"%s: getsockopt(SOL_SOCKET SO_ERROR) failed: %s\",",
          "14225:          __func__,",
          "14226:          strerror(ERRNO));",
          "14227:  } else if (error_code == ECONNRESET) {",
          "14230:  } else {",
          "14233:   if (setsockopt(conn->client.sock,",
          "14234:                  SOL_SOCKET,",
          "14235:                  SO_LINGER,",
          "14236:                  (char *)&linger,",
          "14237:                  sizeof(linger)) != 0) {",
          "14239:           \"%s: setsockopt(SOL_SOCKET SO_LINGER(%i,%i)) failed: %s\",",
          "14241:           linger.l_onoff,",
          "14242:           linger.l_linger,",
          "14248:  closesocket(conn->client.sock);",
          "14249:  conn->client.sock = INVALID_SOCKET;",
          "14250: }",
          "14253: static void",
          "14254: close_connection(struct mg_connection *conn)",
          "14255: {",
          "14256:  if (!conn || !conn->ctx) {",
          "14257:   return;",
          "14258:  }",
          "14261:  if (conn->lua_websocket_state) {",
          "14262:   lua_websocket_close(conn, conn->lua_websocket_state);",
          "14263:   conn->lua_websocket_state = NULL;",
          "14264:  }",
          "14268:  if ((conn->ctx->callbacks.connection_close != NULL)",
          "14269:      && (conn->ctx->context_type == 1)) {",
          "14270:   conn->ctx->callbacks.connection_close(conn);",
          "14271:  }",
          "14276:  mg_set_user_connection_data(conn, NULL);",
          "14278:  mg_lock_connection(conn);",
          "14280:  conn->must_close = 1;",
          "14283:  if (conn->ssl != NULL) {",
          "14286:   SSL_shutdown(conn->ssl);",
          "14287:   SSL_free(conn->ssl);",
          "14291:   ERR_remove_state(0);",
          "14293:   conn->ssl = NULL;",
          "14294:  }",
          "14296:  if (conn->client.sock != INVALID_SOCKET) {",
          "14297:   close_socket_gracefully(conn);",
          "14298:   conn->client.sock = INVALID_SOCKET;",
          "14301:  mg_unlock_connection(conn);",
          "14302: }",
          "14305: void",
          "14306: mg_close_connection(struct mg_connection *conn)",
          "14307: {",
          "14309:  struct mg_context *client_ctx = NULL;",
          "14312:  if (conn == NULL) {",
          "14313:   return;",
          "14314:  }",
          "14317:  if (conn->ctx->context_type == 2) {",
          "14318:   unsigned int i;",
          "14321:   client_ctx = conn->ctx;",
          "14324:   conn->ctx->stop_flag = 1;",
          "14332:   for (i = 0; i < client_ctx->cfg_worker_threads; i++) {",
          "14333:    if (client_ctx->worker_threadids[i] != 0) {",
          "14334:     mg_join_thread(client_ctx->worker_threadids[i]);",
          "14337:  }",
          "14340:  close_connection(conn);",
          "14343:  if (conn->client_ssl_ctx != NULL) {",
          "14344:   SSL_CTX_free((SSL_CTX *)conn->client_ssl_ctx);",
          "14345:  }",
          "14349:  if (client_ctx != NULL) {",
          "14351:   mg_free(client_ctx->worker_threadids);",
          "14352:   mg_free(client_ctx);",
          "14353:   (void)pthread_mutex_destroy(&conn->mutex);",
          "14354:   mg_free(conn);",
          "14356:   mg_free(conn);",
          "14357:  }",
          "14363: }",
          "14366: static struct mg_context common_client_context;",
          "14369: static struct mg_connection *",
          "14370: mg_connect_client_impl(const struct mg_client_options *client_options,",
          "14371:                        int use_ssl,",
          "14372:                        char *ebuf,",
          "14373:                        size_t ebuf_len)",
          "14374: {",
          "14375:  struct mg_connection *conn = NULL;",
          "14376:  SOCKET sock;",
          "14377:  union usa sa;",
          "14378:  unsigned max_req_size =",
          "14379:      (unsigned)atoi(config_options[MAX_REQUEST_SIZE].default_value);",
          "14381:  if (!connect_socket(&common_client_context,",
          "14382:                      client_options->host,",
          "14383:                      client_options->port,",
          "14384:                      use_ssl,",
          "14385:                      ebuf,",
          "14386:                      ebuf_len,",
          "14387:                      &sock,",
          "14388:                      &sa)) {",
          "14389:   return NULL;",
          "14390:  }",
          "14391:  if ((conn = (struct mg_connection *)mg_calloc_ctx(",
          "14392:           1, sizeof(*conn) + max_req_size, &common_client_context))",
          "14393:      == NULL) {",
          "14394:   mg_snprintf(NULL,",
          "14396:               ebuf,",
          "14397:               ebuf_len,",
          "14398:               \"calloc(): %s\",",
          "14399:               strerror(ERRNO));",
          "14400:   closesocket(sock);",
          "14401:   return NULL;",
          "14402:  }",
          "14406:  if (use_ssl",
          "14407:      && (conn->client_ssl_ctx = SSL_CTX_new(TLS_client_method())) == NULL) {",
          "14408:   mg_snprintf(NULL,",
          "14410:               ebuf,",
          "14411:               ebuf_len,",
          "14412:               \"SSL_CTX_new error\");",
          "14413:   closesocket(sock);",
          "14414:   mg_free(conn);",
          "14415:   return NULL;",
          "14416:  }",
          "",
          "---------------",
          "--- Hunk 59 ---",
          "[Context before]",
          "14392: #ifdef USE_IPV6",
          "14400: #else",
          "14401:  socklen_t len = sizeof(conn->client.rsa.sin);",
          "14402:  struct sockaddr *psa = (struct sockaddr *)&(conn->client.rsa.sin);",
          "14403: #endif",
          "14421: #ifndef NO_SSL",
          "14461:     mg_snprintf(NULL,",
          "14463:                 ebuf,",
          "14464:                 ebuf_len,",
          "14466:     SSL_CTX_free(conn->client_ssl_ctx);",
          "14467:     closesocket(sock);",
          "14468:     mg_free(conn);",
          "14469:     return NULL;",
          "14470:    }",
          "14471:   }",
          "14477:  }",
          "14540:   }",
          "14551:     return 0;",
          "14552:    }",
          "14555:     return 0;",
          "14572:    }",
          "14579:   }",
          "14599:     port = strtoul(portbegin + 1, &portend, 10);",
          "14600:     if ((portend != hostend) || (port <= 0)",
          "14601:         || !is_valid_port(port)) {",
          "14602:      return 0;",
          "14603:     }",
          "14606:    }",
          "14607:   }",
          "14609:   return 0;",
          "14610:  }",
          "14636:    return 0;",
          "14637:   }",
          "14640:    return 0;",
          "14641:   }",
          "14669:    }",
          "14683:     return 0;",
          "14684:    }",
          "14690:     return 0;",
          "14691:    }",
          "14692:   }",
          "14736:  }",
          "14770:    mg_snprintf(conn,",
          "14772:                ebuf,",
          "14773:                ebuf_len,",
          "14774:                \"%s\",",
          "14781:    mg_snprintf(conn,",
          "14783:                ebuf,",
          "14784:                ebuf_len,",
          "14785:                \"%s\",",
          "14812:   }",
          "14814:  }",
          "14829:    mg_snprintf(conn,",
          "14831:                ebuf,",
          "14832:                ebuf_len,",
          "14833:                \"%s\",",
          "14834:                \"Bad request\");",
          "14836:    return 0;",
          "14837:   }",
          "14896:    mg_snprintf(conn,",
          "14898:                ebuf,",
          "14899:                ebuf_len,",
          "14900:                \"%s\",",
          "14903:    return 0;",
          "14904:   }",
          "14983: #if defined(MG_LEGACY_INTERFACE)",
          "14987: #endif",
          "15030: #if defined(MG_LEGACY_INTERFACE)",
          "15034: #endif",
          "15043:   }",
          "15047:  }",
          "15058: #if defined(USE_WEBSOCKET)",
          "15059: #ifdef _WIN32",
          "15061: #else",
          "15062: static void *",
          "15063: websocket_client_thread(void *data)",
          "15064: #endif",
          "15077:   }",
          "15093: #ifdef _WIN32",
          "15095: #else",
          "15096:  return NULL;",
          "15097: #endif",
          "15099: #endif",
          "15116: #if defined(USE_WEBSOCKET)",
          "15164:   }",
          "15218:   }",
          "15220: #else",
          "15222:  (void)host;",
          "",
          "[Removed Lines]",
          "14393:   socklen_t len = (sa.sa.sa_family == AF_INET)",
          "14394:                       ? sizeof(conn->client.rsa.sin)",
          "14395:                       : sizeof(conn->client.rsa.sin6);",
          "14396:   struct sockaddr *psa =",
          "14397:       (sa.sa.sa_family == AF_INET)",
          "14398:           ? (struct sockaddr *)&(conn->client.rsa.sin)",
          "14399:           : (struct sockaddr *)&(conn->client.rsa.sin6);",
          "14405:   conn->buf_size = (int)max_req_size;",
          "14406:   conn->buf = (char *)(conn + 1);",
          "14407:   conn->ctx = &common_client_context;",
          "14408:   conn->client.sock = sock;",
          "14409:   conn->client.lsa = sa;",
          "14411:   if (getsockname(sock, psa, &len) != 0) {",
          "14412:    mg_cry(conn,",
          "14413:           \"%s: getsockname() failed: %s\",",
          "14414:           __func__,",
          "14415:           strerror(ERRNO));",
          "14416:   }",
          "14418:   conn->client.is_ssl = use_ssl ? 1 : 0;",
          "14419:   (void)pthread_mutex_init(&conn->mutex, &pthread_mutex_attr);",
          "14422:   if (use_ssl) {",
          "14423:    common_client_context.ssl_ctx = conn->client_ssl_ctx;",
          "14432:    if (client_options->client_cert) {",
          "14433:     if (!ssl_use_pem_file(&common_client_context,",
          "14434:                           client_options->client_cert,",
          "14435:                           NULL)) {",
          "14436:      mg_snprintf(NULL,",
          "14438:                  ebuf,",
          "14439:                  ebuf_len,",
          "14440:                  \"Can not use SSL client certificate\");",
          "14441:      SSL_CTX_free(conn->client_ssl_ctx);",
          "14442:      closesocket(sock);",
          "14443:      mg_free(conn);",
          "14444:      return NULL;",
          "14445:     }",
          "14446:    }",
          "14448:    if (client_options->server_cert) {",
          "14449:     SSL_CTX_load_verify_locations(conn->client_ssl_ctx,",
          "14450:                                   client_options->server_cert,",
          "14451:                                   NULL);",
          "14452:     SSL_CTX_set_verify(conn->client_ssl_ctx, SSL_VERIFY_PEER, NULL);",
          "14453:    } else {",
          "14454:     SSL_CTX_set_verify(conn->client_ssl_ctx, SSL_VERIFY_NONE, NULL);",
          "14455:    }",
          "14457:    if (!sslize(conn,",
          "14458:                conn->client_ssl_ctx,",
          "14459:                SSL_connect,",
          "14460:                &(conn->ctx->stop_flag))) {",
          "14465:                 \"SSL connection error\");",
          "14472: #endif",
          "14474:   set_blocking_mode(sock, 0);",
          "14476:   return conn;",
          "14480:  CIVETWEB_API struct mg_connection *mg_connect_client_secure(",
          "14481:      const struct mg_client_options *client_options,",
          "14482:      char *error_buffer,",
          "14483:      size_t error_buffer_size)",
          "14484:  {",
          "14485:   return mg_connect_client_impl(client_options,",
          "14486:                                 1,",
          "14487:                                 error_buffer,",
          "14488:                                 error_buffer_size);",
          "14489:  }",
          "14492:  struct mg_connection *mg_connect_client(const char *host,",
          "14493:                                          int port,",
          "14494:                                          int use_ssl,",
          "14495:                                          char *error_buffer,",
          "14496:                                          size_t error_buffer_size)",
          "14497:  {",
          "14498:   struct mg_client_options opts;",
          "14499:   memset(&opts, 0, sizeof(opts));",
          "14500:   opts.host = host;",
          "14501:   opts.port = port;",
          "14502:   return mg_connect_client_impl(&opts,",
          "14503:                                 use_ssl,",
          "14504:                                 error_buffer,",
          "14505:                                 error_buffer_size);",
          "14506:  }",
          "14509:  static const struct {",
          "14510:   const char *proto;",
          "14511:   size_t proto_len;",
          "14512:   unsigned default_port;",
          "14513:  } abs_uri_protocols[] = {{\"http://\", 7, 80},",
          "14514:                           {\"https://\", 8, 443},",
          "14515:                           {\"ws://\", 5, 80},",
          "14516:                           {\"wss://\", 6, 443},",
          "14517:                           {NULL, 0, 0}};",
          "14526:  static int get_uri_type(const char *uri)",
          "14527:  {",
          "14528:   int i;",
          "14529:   const char *hostend, *portbegin;",
          "14530:   char *portend;",
          "14531:   unsigned long port;",
          "14537:   if ((uri[0] == '*') && (uri[1] == '\\0')) {",
          "14539:    return 1;",
          "14548:   for (i = 0; uri[i] != 0; i++) {",
          "14549:    if (uri[i] < 33) {",
          "14553:    if (uri[i] > 126) {",
          "14556:    } else {",
          "14557:     switch (uri[i]) {",
          "14567:      return 0;",
          "14568:     default:",
          "14570:      break;",
          "14571:     }",
          "14573:   }",
          "14576:   if (uri[0] == '/') {",
          "14578:    return 2;",
          "14585:   for (i = 0; abs_uri_protocols[i].proto != NULL; i++) {",
          "14586:    if (mg_strncasecmp(uri,",
          "14587:                       abs_uri_protocols[i].proto,",
          "14588:                       abs_uri_protocols[i].proto_len) == 0) {",
          "14590:     hostend = strchr(uri + abs_uri_protocols[i].proto_len, '/');",
          "14591:     if (!hostend) {",
          "14592:      return 0;",
          "14593:     }",
          "14594:     portbegin = strchr(uri + abs_uri_protocols[i].proto_len, ':');",
          "14595:     if (!portbegin) {",
          "14596:      return 3;",
          "14597:     }",
          "14605:     return 4;",
          "14614:  static const char *get_rel_url_at_current_server(",
          "14615:      const char *uri, const struct mg_connection *conn)",
          "14616:  {",
          "14617:   const char *server_domain;",
          "14618:   size_t server_domain_len;",
          "14619:   size_t request_domain_len = 0;",
          "14620:   unsigned long port = 0;",
          "14621:   int i, auth_domain_check_enabled;",
          "14622:   const char *hostbegin = NULL;",
          "14623:   const char *hostend = NULL;",
          "14624:   const char *portbegin;",
          "14625:   char *portend;",
          "14627:   auth_domain_check_enabled =",
          "14628:       !strcmp(conn->ctx->config[ENABLE_AUTH_DOMAIN_CHECK], \"yes\");",
          "14630:   if (!auth_domain_check_enabled) {",
          "14631:    return 0;",
          "14632:   }",
          "14634:   server_domain = conn->ctx->config[AUTHENTICATION_DOMAIN];",
          "14635:   if (!server_domain) {",
          "14638:   server_domain_len = strlen(server_domain);",
          "14639:   if (!server_domain_len) {",
          "14645:   for (i = 0; abs_uri_protocols[i].proto != NULL; i++) {",
          "14646:    if (mg_strncasecmp(uri,",
          "14647:                       abs_uri_protocols[i].proto,",
          "14648:                       abs_uri_protocols[i].proto_len) == 0) {",
          "14650:     hostbegin = uri + abs_uri_protocols[i].proto_len;",
          "14651:     hostend = strchr(hostbegin, '/');",
          "14652:     if (!hostend) {",
          "14653:      return 0;",
          "14654:     }",
          "14655:     portbegin = strchr(hostbegin, ':');",
          "14656:     if ((!portbegin) || (portbegin > hostend)) {",
          "14657:      port = abs_uri_protocols[i].default_port;",
          "14658:      request_domain_len = (size_t)(hostend - hostbegin);",
          "14659:     } else {",
          "14660:      port = strtoul(portbegin + 1, &portend, 10);",
          "14661:      if ((portend != hostend) || (port <= 0)",
          "14662:          || !is_valid_port(port)) {",
          "14663:       return 0;",
          "14664:      }",
          "14665:      request_domain_len = (size_t)(portbegin - hostbegin);",
          "14666:     }",
          "14668:     break;",
          "14670:   }",
          "14672:   if (!port) {",
          "14674:    return 0;",
          "14675:   }",
          "14679: #if defined(USE_IPV6)",
          "14680:   if (conn->client.lsa.sa.sa_family == AF_INET6) {",
          "14681:    if (ntohs(conn->client.lsa.sin6.sin6_port) != port) {",
          "14685:   } else",
          "14686: #endif",
          "14687:   {",
          "14688:    if (ntohs(conn->client.lsa.sin.sin_port) != port) {",
          "14702:   if (auth_domain_check_enabled) {",
          "14703:    if ((request_domain_len == server_domain_len)",
          "14704:        && (!memcmp(server_domain, hostbegin, server_domain_len))) {",
          "14706:    } else {",
          "14707:     if (request_domain_len < (server_domain_len + 2)) {",
          "14715:      return 0;",
          "14716:     }",
          "14717:     if (hostbegin[request_domain_len - server_domain_len - 1]",
          "14718:         != '.') {",
          "14722:      return 0;",
          "14723:     }",
          "14724:     if (0 != memcmp(server_domain,",
          "14725:                     hostbegin + request_domain_len",
          "14726:                         - server_domain_len,",
          "14727:                     server_domain_len)) {",
          "14730:      return 0;",
          "14731:     }",
          "14732:    }",
          "14733:   }",
          "14735:   return hostend;",
          "14739:  static int get_message(struct mg_connection * conn,",
          "14740:                         char *ebuf,",
          "14741:                         size_t ebuf_len,",
          "14742:                         int *err)",
          "14743:  {",
          "14744:   if (ebuf_len > 0) {",
          "14745:    ebuf[0] = '\\0';",
          "14746:   }",
          "14749:   reset_per_request_attributes(conn);",
          "14751:   if (!conn) {",
          "14752:    mg_snprintf(conn,",
          "14754:                ebuf,",
          "14755:                ebuf_len,",
          "14756:                \"%s\",",
          "14757:                \"Internal error\");",
          "14759:    return 0;",
          "14760:   }",
          "14763:   clock_gettime(CLOCK_MONOTONIC, &(conn->req_time));",
          "14765:   conn->request_len = read_message(",
          "14766:       NULL, conn, conn->buf, conn->buf_size, &conn->data_len);",
          "14769:   if ((conn->request_len >= 0) && (conn->data_len < conn->request_len)) {",
          "14775:                \"Invalid message size\");",
          "14777:    return 0;",
          "14778:   }",
          "14780:   if ((conn->request_len == 0) && (conn->data_len == conn->buf_size)) {",
          "14786:                \"Message too large\");",
          "14788:    return 0;",
          "14789:   }",
          "14791:   if (conn->request_len <= 0) {",
          "14792:    if (conn->data_len > 0) {",
          "14793:     mg_snprintf(conn,",
          "14795:                 ebuf,",
          "14796:                 ebuf_len,",
          "14797:                 \"%s\",",
          "14798:                 \"Malformed message\");",
          "14800:    } else {",
          "14802:     conn->must_close = 1;",
          "14803:     mg_snprintf(conn,",
          "14805:                 ebuf,",
          "14806:                 ebuf_len,",
          "14807:                 \"%s\",",
          "14808:                 \"No data received\");",
          "14810:    }",
          "14811:    return 0;",
          "14813:   return 1;",
          "14817:  static int get_request(struct mg_connection * conn,",
          "14818:                         char *ebuf,",
          "14819:                         size_t ebuf_len,",
          "14820:                         int *err)",
          "14821:  {",
          "14822:   const char *cl;",
          "14823:   if (!get_message(conn, ebuf, ebuf_len, err)) {",
          "14824:    return 0;",
          "14825:   }",
          "14827:   if (parse_http_request(conn->buf, conn->buf_size, &conn->request_info)",
          "14828:       <= 0) {",
          "14840:   if ((cl = get_header(conn->request_info.http_headers,",
          "14841:                        conn->request_info.num_headers,",
          "14842:                        \"Content-Length\")) != NULL) {",
          "14844:    char *endptr = NULL;",
          "14845:    conn->content_len = strtoll(cl, &endptr, 10);",
          "14846:    if (endptr == cl) {",
          "14847:     mg_snprintf(conn,",
          "14849:                 ebuf,",
          "14850:                 ebuf_len,",
          "14851:                 \"%s\",",
          "14852:                 \"Bad request\");",
          "14854:     return 0;",
          "14855:    }",
          "14857:    conn->request_info.content_length = conn->content_len;",
          "14858:   } else if ((cl = get_header(conn->request_info.http_headers,",
          "14859:                               conn->request_info.num_headers,",
          "14860:                               \"Transfer-Encoding\")) != NULL",
          "14861:              && !mg_strcasecmp(cl, \"chunked\")) {",
          "14862:    conn->is_chunked = 1;",
          "14863:   } else if (!mg_strcasecmp(conn->request_info.request_method, \"POST\")",
          "14864:              || !mg_strcasecmp(conn->request_info.request_method,",
          "14865:                                \"PUT\")) {",
          "14867:    conn->content_len = -1;",
          "14868:   } else if (!mg_strncasecmp(conn->request_info.request_method,",
          "14869:                              \"HTTP/\",",
          "14870:                              5)) {",
          "14872:    conn->content_len = -1;",
          "14873:   } else {",
          "14875:    conn->content_len = 0;",
          "14876:   }",
          "14879:   return 1;",
          "14880:  }",
          "14884:  static int get_response(struct mg_connection * conn,",
          "14885:                          char *ebuf,",
          "14886:                          size_t ebuf_len,",
          "14887:                          int *err)",
          "14888:  {",
          "14889:   const char *cl;",
          "14890:   if (!get_message(conn, ebuf, ebuf_len, err)) {",
          "14891:    return 0;",
          "14892:   }",
          "14894:   if (parse_http_response(conn->buf, conn->buf_size, &conn->response_info)",
          "14895:       <= 0) {",
          "14901:                \"Bad response\");",
          "14907:   if ((cl = get_header(conn->response_info.http_headers,",
          "14908:                        conn->response_info.num_headers,",
          "14909:                        \"Content-Length\")) != NULL) {",
          "14911:    char *endptr = NULL;",
          "14912:    conn->content_len = strtoll(cl, &endptr, 10);",
          "14913:    if (endptr == cl) {",
          "14914:     mg_snprintf(conn,",
          "14916:                 ebuf,",
          "14917:                 ebuf_len,",
          "14918:                 \"%s\",",
          "14919:                 \"Bad request\");",
          "14921:     return 0;",
          "14922:    }",
          "14924:    conn->response_info.content_length = conn->content_len;",
          "14927:    conn->request_info.content_length = conn->content_len;",
          "14929:   } else if ((cl = get_header(conn->response_info.http_headers,",
          "14930:                               conn->response_info.num_headers,",
          "14931:                               \"Transfer-Encoding\")) != NULL",
          "14932:              && !mg_strcasecmp(cl, \"chunked\")) {",
          "14933:    conn->is_chunked = 1;",
          "14934:   } else {",
          "14935:    conn->content_len = -1;",
          "14936:   }",
          "14940:   return 1;",
          "14941:  }",
          "14944:  int mg_get_response(struct mg_connection * conn,",
          "14945:                      char *ebuf,",
          "14946:                      size_t ebuf_len,",
          "14947:                      int timeout)",
          "14948:  {",
          "14949:   if (ebuf_len > 0) {",
          "14950:    ebuf[0] = '\\0';",
          "14951:   }",
          "14953:   if (!conn) {",
          "14954:    mg_snprintf(conn,",
          "14956:                ebuf,",
          "14957:                ebuf_len,",
          "14958:                \"%s\",",
          "14959:                \"Parameter error\");",
          "14960:    return -1;",
          "14961:   }",
          "14964:   int err, ret;",
          "14965:   struct mg_context *octx = conn->ctx;",
          "14966:   struct mg_context rctx = *(conn->ctx);",
          "14969:   if (timeout >= 0) {",
          "14970:    mg_snprintf(conn, NULL, txt, sizeof(txt), \"%i\", timeout);",
          "14971:    rctx.config[REQUEST_TIMEOUT] = txt;",
          "14973:    set_sock_timeout(conn->client.sock, timeout);",
          "14975:   } else {",
          "14976:    rctx.config[REQUEST_TIMEOUT] = NULL;",
          "14977:   }",
          "14979:   conn->ctx = &rctx;",
          "14980:   ret = get_response(conn, ebuf, ebuf_len, &err);",
          "14981:   conn->ctx = octx;",
          "14986:   conn->request_info.uri = conn->request_info.request_uri;",
          "14988:   conn->request_info.local_uri = conn->request_info.request_uri;",
          "14992:   return (ret == 0) ? -1 : +1;",
          "14993:  }",
          "14996:  struct mg_connection *mg_download(const char *host,",
          "14997:                                    int port,",
          "14998:                                    int use_ssl,",
          "14999:                                    char *ebuf,",
          "15000:                                    size_t ebuf_len,",
          "15001:                                    const char *fmt,",
          "15002:                                    ...)",
          "15003:  {",
          "15004:   struct mg_connection *conn;",
          "15005:   va_list ap;",
          "15006:   int i;",
          "15007:   int reqerr;",
          "15009:   if (ebuf_len > 0) {",
          "15010:    ebuf[0] = '\\0';",
          "15011:   }",
          "15013:   va_start(ap, fmt);",
          "15016:   conn = mg_connect_client(host, port, use_ssl, ebuf, ebuf_len);",
          "15018:   if (conn != NULL) {",
          "15019:    i = mg_vprintf(conn, fmt, ap);",
          "15020:    if (i <= 0) {",
          "15021:     mg_snprintf(conn,",
          "15023:                 ebuf,",
          "15024:                 ebuf_len,",
          "15025:                 \"%s\",",
          "15026:                 \"Error sending request\");",
          "15027:    } else {",
          "15028:     get_response(conn, ebuf, ebuf_len, &reqerr);",
          "15033:     conn->request_info.uri = conn->request_info.request_uri;",
          "15035:     conn->request_info.local_uri = conn->request_info.request_uri;",
          "15036:    }",
          "15037:   }",
          "15040:   if ((ebuf[0] != '\\0') && (conn != NULL)) {",
          "15041:    mg_close_connection(conn);",
          "15042:    conn = NULL;",
          "15045:   va_end(ap);",
          "15046:   return conn;",
          "15050:  struct websocket_client_thread_data {",
          "15051:   struct mg_connection *conn;",
          "15052:   mg_websocket_data_handler data_handler;",
          "15053:   mg_websocket_close_handler close_handler;",
          "15054:   void *callback_data;",
          "15055:  };",
          "15060:  static unsigned __stdcall websocket_client_thread(void *data)",
          "15065:  {",
          "15066:   struct websocket_client_thread_data *cdata =",
          "15067:       (struct websocket_client_thread_data *)data;",
          "15069:   mg_set_thread_name(\"ws-clnt\");",
          "15071:   if (cdata->conn->ctx) {",
          "15072:    if (cdata->conn->ctx->callbacks.init_thread) {",
          "15075:     cdata->conn->ctx->callbacks.init_thread(cdata->conn->ctx, 3);",
          "15076:    }",
          "15079:   read_websocket(cdata->conn, cdata->data_handler, cdata->callback_data);",
          "15081:   DEBUG_TRACE(\"%s\", \"Websocket client thread exited\\n\");",
          "15083:   if (cdata->close_handler != NULL) {",
          "15084:    cdata->close_handler(cdata->conn, cdata->callback_data);",
          "15085:   }",
          "15089:   cdata->conn->ctx->stop_flag = 2;",
          "15091:   mg_free((void *)cdata);",
          "15094:   return 0;",
          "15098:  }",
          "15102:  struct mg_connection *mg_connect_websocket_client(",
          "15103:      const char *host,",
          "15104:      int port,",
          "15105:      int use_ssl,",
          "15106:      char *error_buffer,",
          "15107:      size_t error_buffer_size,",
          "15108:      const char *path,",
          "15109:      const char *origin,",
          "15110:      mg_websocket_data_handler data_func,",
          "15111:      mg_websocket_close_handler close_func,",
          "15112:      void *user_data)",
          "15113:  {",
          "15114:   struct mg_connection *conn = NULL;",
          "15117:   struct mg_context *newctx = NULL;",
          "15118:   struct websocket_client_thread_data *thread_data;",
          "15119:   static const char *magic = \"x3JJHMbDL1EzLkh9GBhXDw==\";",
          "15120:   static const char *handshake_req;",
          "15122:   if (origin != NULL) {",
          "15123:    handshake_req = \"GET %s HTTP/1.1\\r\\n\"",
          "15124:                    \"Host: %s\\r\\n\"",
          "15125:                    \"Upgrade: websocket\\r\\n\"",
          "15126:                    \"Connection: Upgrade\\r\\n\"",
          "15127:                    \"Sec-WebSocket-Key: %s\\r\\n\"",
          "15128:                    \"Sec-WebSocket-Version: 13\\r\\n\"",
          "15129:                    \"Origin: %s\\r\\n\"",
          "15130:                    \"\\r\\n\";",
          "15131:   } else {",
          "15132:    handshake_req = \"GET %s HTTP/1.1\\r\\n\"",
          "15133:                    \"Host: %s\\r\\n\"",
          "15134:                    \"Upgrade: websocket\\r\\n\"",
          "15135:                    \"Connection: Upgrade\\r\\n\"",
          "15136:                    \"Sec-WebSocket-Key: %s\\r\\n\"",
          "15137:                    \"Sec-WebSocket-Version: 13\\r\\n\"",
          "15138:                    \"\\r\\n\";",
          "15139:   }",
          "15142:   conn = mg_download(host,",
          "15143:                      port,",
          "15144:                      use_ssl,",
          "15145:                      error_buffer,",
          "15146:                      error_buffer_size,",
          "15147:                      handshake_req,",
          "15148:                      path,",
          "15149:                      host,",
          "15150:                      magic,",
          "15151:                      origin);",
          "15154:   if (conn == NULL) {",
          "15155:    if (!*error_buffer) {",
          "15157:     mg_snprintf(conn,",
          "15159:                 error_buffer,",
          "15160:                 error_buffer_size,",
          "15161:                 \"Unexpected error\");",
          "15162:    }",
          "15163:    return NULL;",
          "15166:   if (conn->response_info.status_code != 101) {",
          "15171:    if (!*error_buffer) {",
          "15173:     mg_snprintf(conn,",
          "15175:                 error_buffer,",
          "15176:                 error_buffer_size,",
          "15177:                 \"Unexpected server reply\");",
          "15178:    }",
          "15180:    DEBUG_TRACE(\"Websocket client connect error: %s\\r\\n\", error_buffer);",
          "15181:    mg_free(conn);",
          "15182:    return conn;",
          "15183:   }",
          "15187:   newctx = (struct mg_context *)mg_malloc(sizeof(struct mg_context));",
          "15188:   memcpy(newctx, conn->ctx, sizeof(struct mg_context));",
          "15189:   newctx->user_data = user_data;",
          "15192:   newctx->worker_threadids =",
          "15193:       (pthread_t *)mg_calloc_ctx(newctx->cfg_worker_threads,",
          "15194:                                  sizeof(pthread_t),",
          "15195:                                  newctx);",
          "15196:   conn->ctx = newctx;",
          "15197:   thread_data = (struct websocket_client_thread_data *)mg_calloc_ctx(",
          "15198:       sizeof(struct websocket_client_thread_data), 1, newctx);",
          "15199:   thread_data->conn = conn;",
          "15200:   thread_data->data_handler = data_func;",
          "15201:   thread_data->close_handler = close_func;",
          "15202:   thread_data->callback_data = user_data;",
          "15207:   if (mg_start_thread_with_id(websocket_client_thread,",
          "15208:                               (void *)thread_data,",
          "15209:                               newctx->worker_threadids) != 0) {",
          "15210:    mg_free((void *)thread_data);",
          "15211:    mg_free((void *)newctx->worker_threadids);",
          "15212:    mg_free((void *)newctx);",
          "15213:    mg_free((void *)conn);",
          "15214:    conn = NULL;",
          "15215:    DEBUG_TRACE(",
          "15216:        \"%s\",",
          "15217:        \"Websocket client connect thread could not be started\\r\\n\");",
          "",
          "[Added Lines]",
          "14435:  socklen_t len = (sa.sa.sa_family == AF_INET)",
          "14436:                      ? sizeof(conn->client.rsa.sin)",
          "14437:                      : sizeof(conn->client.rsa.sin6);",
          "14438:  struct sockaddr *psa = (sa.sa.sa_family == AF_INET)",
          "14439:                             ? (struct sockaddr *)&(conn->client.rsa.sin)",
          "14440:                             : (struct sockaddr *)&(conn->client.rsa.sin6);",
          "14446:  conn->buf_size = (int)max_req_size;",
          "14447:  conn->buf = (char *)(conn + 1);",
          "14448:  conn->ctx = &common_client_context;",
          "14449:  conn->client.sock = sock;",
          "14450:  conn->client.lsa = sa;",
          "14452:  if (getsockname(sock, psa, &len) != 0) {",
          "14453:   mg_cry(conn, \"%s: getsockname() failed: %s\", __func__, strerror(ERRNO));",
          "14454:  }",
          "14456:  conn->client.is_ssl = use_ssl ? 1 : 0;",
          "14457:  (void)pthread_mutex_init(&conn->mutex, &pthread_mutex_attr);",
          "14460:  if (use_ssl) {",
          "14461:   common_client_context.ssl_ctx = conn->client_ssl_ctx;",
          "14470:   if (client_options->client_cert) {",
          "14471:    if (!ssl_use_pem_file(&common_client_context,",
          "14472:                          client_options->client_cert,",
          "14473:                          NULL)) {",
          "14478:                 \"Can not use SSL client certificate\");",
          "14486:   if (client_options->server_cert) {",
          "14487:    SSL_CTX_load_verify_locations(conn->client_ssl_ctx,",
          "14488:                                  client_options->server_cert,",
          "14489:                                  NULL);",
          "14490:    SSL_CTX_set_verify(conn->client_ssl_ctx, SSL_VERIFY_PEER, NULL);",
          "14491:   } else {",
          "14492:    SSL_CTX_set_verify(conn->client_ssl_ctx, SSL_VERIFY_NONE, NULL);",
          "14493:   }",
          "14495:   if (!sslize(conn,",
          "14496:               conn->client_ssl_ctx,",
          "14497:               SSL_connect,",
          "14498:               &(conn->ctx->stop_flag))) {",
          "14499:    mg_snprintf(NULL,",
          "14501:                ebuf,",
          "14502:                ebuf_len,",
          "14503:                \"SSL connection error\");",
          "14504:    SSL_CTX_free(conn->client_ssl_ctx);",
          "14505:    closesocket(sock);",
          "14506:    mg_free(conn);",
          "14507:    return NULL;",
          "14508:   }",
          "14510: #endif",
          "14512:  set_blocking_mode(sock, 0);",
          "14514:  return conn;",
          "14515: }",
          "14518: CIVETWEB_API struct mg_connection *",
          "14519: mg_connect_client_secure(const struct mg_client_options *client_options,",
          "14520:                          char *error_buffer,",
          "14521:                          size_t error_buffer_size)",
          "14522: {",
          "14523:  return mg_connect_client_impl(client_options,",
          "14524:                                1,",
          "14525:                                error_buffer,",
          "14526:                                error_buffer_size);",
          "14527: }",
          "14530: struct mg_connection *",
          "14531: mg_connect_client(const char *host,",
          "14532:                   int port,",
          "14533:                   int use_ssl,",
          "14534:                   char *error_buffer,",
          "14535:                   size_t error_buffer_size)",
          "14536: {",
          "14537:  struct mg_client_options opts;",
          "14538:  memset(&opts, 0, sizeof(opts));",
          "14539:  opts.host = host;",
          "14540:  opts.port = port;",
          "14541:  return mg_connect_client_impl(&opts,",
          "14542:                                use_ssl,",
          "14543:                                error_buffer,",
          "14544:                                error_buffer_size);",
          "14545: }",
          "14548: static const struct {",
          "14549:  const char *proto;",
          "14550:  size_t proto_len;",
          "14551:  unsigned default_port;",
          "14552: } abs_uri_protocols[] = {{\"http://\", 7, 80},",
          "14553:                          {\"https://\", 8, 443},",
          "14554:                          {\"ws://\", 5, 80},",
          "14555:                          {\"wss://\", 6, 443},",
          "14556:                          {NULL, 0, 0}};",
          "14565: static int",
          "14566: get_uri_type(const char *uri)",
          "14567: {",
          "14568:  int i;",
          "14569:  const char *hostend, *portbegin;",
          "14570:  char *portend;",
          "14571:  unsigned long port;",
          "14577:  if ((uri[0] == '*') && (uri[1] == '\\0')) {",
          "14579:   return 1;",
          "14580:  }",
          "14588:  for (i = 0; uri[i] != 0; i++) {",
          "14589:   if (uri[i] < 33) {",
          "14591:    return 0;",
          "14592:   }",
          "14593:   if (uri[i] > 126) {",
          "14595:    return 0;",
          "14596:   } else {",
          "14597:    switch (uri[i]) {",
          "14607:     return 0;",
          "14608:    default:",
          "14610:     break;",
          "14611:    }",
          "14613:  }",
          "14616:  if (uri[0] == '/') {",
          "14618:   return 2;",
          "14619:  }",
          "14625:  for (i = 0; abs_uri_protocols[i].proto != NULL; i++) {",
          "14626:   if (mg_strncasecmp(uri,",
          "14627:                      abs_uri_protocols[i].proto,",
          "14628:                      abs_uri_protocols[i].proto_len) == 0) {",
          "14630:    hostend = strchr(uri + abs_uri_protocols[i].proto_len, '/');",
          "14631:    if (!hostend) {",
          "14634:    portbegin = strchr(uri + abs_uri_protocols[i].proto_len, ':');",
          "14635:    if (!portbegin) {",
          "14636:     return 3;",
          "14637:    }",
          "14639:    port = strtoul(portbegin + 1, &portend, 10);",
          "14640:    if ((portend != hostend) || (port <= 0) || !is_valid_port(port)) {",
          "14644:    return 4;",
          "14646:  }",
          "14648:  return 0;",
          "14649: }",
          "14653: static const char *",
          "14654: get_rel_url_at_current_server(const char *uri, const struct mg_connection *conn)",
          "14655: {",
          "14656:  const char *server_domain;",
          "14657:  size_t server_domain_len;",
          "14658:  size_t request_domain_len = 0;",
          "14659:  unsigned long port = 0;",
          "14660:  int i, auth_domain_check_enabled;",
          "14661:  const char *hostbegin = NULL;",
          "14662:  const char *hostend = NULL;",
          "14663:  const char *portbegin;",
          "14664:  char *portend;",
          "14666:  auth_domain_check_enabled =",
          "14667:      !strcmp(conn->ctx->config[ENABLE_AUTH_DOMAIN_CHECK], \"yes\");",
          "14669:  if (!auth_domain_check_enabled) {",
          "14670:   return 0;",
          "14671:  }",
          "14673:  server_domain = conn->ctx->config[AUTHENTICATION_DOMAIN];",
          "14674:  if (!server_domain) {",
          "14675:   return 0;",
          "14676:  }",
          "14677:  server_domain_len = strlen(server_domain);",
          "14678:  if (!server_domain_len) {",
          "14679:   return 0;",
          "14680:  }",
          "14684:  for (i = 0; abs_uri_protocols[i].proto != NULL; i++) {",
          "14685:   if (mg_strncasecmp(uri,",
          "14686:                      abs_uri_protocols[i].proto,",
          "14687:                      abs_uri_protocols[i].proto_len) == 0) {",
          "14689:    hostbegin = uri + abs_uri_protocols[i].proto_len;",
          "14690:    hostend = strchr(hostbegin, '/');",
          "14691:    if (!hostend) {",
          "14692:     return 0;",
          "14693:    }",
          "14694:    portbegin = strchr(hostbegin, ':');",
          "14695:    if ((!portbegin) || (portbegin > hostend)) {",
          "14696:     port = abs_uri_protocols[i].default_port;",
          "14697:     request_domain_len = (size_t)(hostend - hostbegin);",
          "14698:    } else {",
          "14704:     request_domain_len = (size_t)(portbegin - hostbegin);",
          "14707:    break;",
          "14709:  }",
          "14711:  if (!port) {",
          "14718: #if defined(USE_IPV6)",
          "14719:  if (conn->client.lsa.sa.sa_family == AF_INET6) {",
          "14720:   if (ntohs(conn->client.lsa.sin6.sin6_port) != port) {",
          "14724:  } else",
          "14725: #endif",
          "14726:  {",
          "14727:   if (ntohs(conn->client.lsa.sin.sin_port) != port) {",
          "14731:  }",
          "14741:  if (auth_domain_check_enabled) {",
          "14742:   if ((request_domain_len == server_domain_len)",
          "14743:       && (!memcmp(server_domain, hostbegin, server_domain_len))) {",
          "14745:   } else {",
          "14746:    if (request_domain_len < (server_domain_len + 2)) {",
          "14754:     return 0;",
          "14756:    if (hostbegin[request_domain_len - server_domain_len - 1] != '.') {",
          "14762:    if (0 != memcmp(server_domain,",
          "14763:                    hostbegin + request_domain_len - server_domain_len,",
          "14764:                    server_domain_len)) {",
          "14770:  }",
          "14772:  return hostend;",
          "14773: }",
          "14776: static int",
          "14777: get_message(struct mg_connection *conn, char *ebuf, size_t ebuf_len, int *err)",
          "14778: {",
          "14779:  if (ebuf_len > 0) {",
          "14780:   ebuf[0] = '\\0';",
          "14784:  reset_per_request_attributes(conn);",
          "14786:  if (!conn) {",
          "14787:   mg_snprintf(conn,",
          "14789:               ebuf,",
          "14790:               ebuf_len,",
          "14791:               \"%s\",",
          "14792:               \"Internal error\");",
          "14794:   return 0;",
          "14795:  }",
          "14798:  clock_gettime(CLOCK_MONOTONIC, &(conn->req_time));",
          "14800:  conn->request_len =",
          "14801:      read_message(NULL, conn, conn->buf, conn->buf_size, &conn->data_len);",
          "14804:  if ((conn->request_len >= 0) && (conn->data_len < conn->request_len)) {",
          "14805:   mg_snprintf(conn,",
          "14807:               ebuf,",
          "14808:               ebuf_len,",
          "14809:               \"%s\",",
          "14810:               \"Invalid message size\");",
          "14812:   return 0;",
          "14813:  }",
          "14815:  if ((conn->request_len == 0) && (conn->data_len == conn->buf_size)) {",
          "14816:   mg_snprintf(conn,",
          "14818:               ebuf,",
          "14819:               ebuf_len,",
          "14820:               \"%s\",",
          "14821:               \"Message too large\");",
          "14823:   return 0;",
          "14824:  }",
          "14826:  if (conn->request_len <= 0) {",
          "14827:   if (conn->data_len > 0) {",
          "14833:                \"Malformed message\");",
          "14835:   } else {",
          "14837:    conn->must_close = 1;",
          "14843:                \"No data received\");",
          "14846:   return 0;",
          "14848:  return 1;",
          "14849: }",
          "14852: static int",
          "14853: get_request(struct mg_connection *conn, char *ebuf, size_t ebuf_len, int *err)",
          "14854: {",
          "14855:  const char *cl;",
          "14856:  if (!get_message(conn, ebuf, ebuf_len, err)) {",
          "14857:   return 0;",
          "14858:  }",
          "14860:  if (parse_http_request(conn->buf, conn->buf_size, &conn->request_info)",
          "14861:      <= 0) {",
          "14862:   mg_snprintf(conn,",
          "14864:               ebuf,",
          "14865:               ebuf_len,",
          "14866:               \"%s\",",
          "14867:               \"Bad request\");",
          "14869:   return 0;",
          "14870:  }",
          "14873:  if ((cl = get_header(conn->request_info.http_headers,",
          "14874:                       conn->request_info.num_headers,",
          "14875:                       \"Content-Length\")) != NULL) {",
          "14877:   char *endptr = NULL;",
          "14878:   conn->content_len = strtoll(cl, &endptr, 10);",
          "14879:   if (endptr == cl) {",
          "14890:   conn->request_info.content_length = conn->content_len;",
          "14891:  } else if ((cl = get_header(conn->request_info.http_headers,",
          "14892:                              conn->request_info.num_headers,",
          "14893:                              \"Transfer-Encoding\")) != NULL",
          "14894:             && !mg_strcasecmp(cl, \"chunked\")) {",
          "14895:   conn->is_chunked = 1;",
          "14896:  } else if (!mg_strcasecmp(conn->request_info.request_method, \"POST\")",
          "14897:             || !mg_strcasecmp(conn->request_info.request_method, \"PUT\")) {",
          "14899:   conn->content_len = -1;",
          "14900:  } else if (!mg_strncasecmp(conn->request_info.request_method, \"HTTP/\", 5)) {",
          "14902:   conn->content_len = -1;",
          "14903:  } else {",
          "14905:   conn->content_len = 0;",
          "14906:  }",
          "14909:  return 1;",
          "14910: }",
          "14914: static int",
          "14915: get_response(struct mg_connection *conn, char *ebuf, size_t ebuf_len, int *err)",
          "14916: {",
          "14917:  const char *cl;",
          "14918:  if (!get_message(conn, ebuf, ebuf_len, err)) {",
          "14919:   return 0;",
          "14920:  }",
          "14922:  if (parse_http_response(conn->buf, conn->buf_size, &conn->response_info)",
          "14923:      <= 0) {",
          "14924:   mg_snprintf(conn,",
          "14926:               ebuf,",
          "14927:               ebuf_len,",
          "14928:               \"%s\",",
          "14929:               \"Bad response\");",
          "14931:   return 0;",
          "14932:  }",
          "14935:  if ((cl = get_header(conn->response_info.http_headers,",
          "14936:                       conn->response_info.num_headers,",
          "14937:                       \"Content-Length\")) != NULL) {",
          "14939:   char *endptr = NULL;",
          "14940:   conn->content_len = strtoll(cl, &endptr, 10);",
          "14941:   if (endptr == cl) {",
          "14947:                \"Bad request\");",
          "14952:   conn->response_info.content_length = conn->content_len;",
          "14955:   conn->request_info.content_length = conn->content_len;",
          "14957:  } else if ((cl = get_header(conn->response_info.http_headers,",
          "14958:                              conn->response_info.num_headers,",
          "14959:                              \"Transfer-Encoding\")) != NULL",
          "14960:             && !mg_strcasecmp(cl, \"chunked\")) {",
          "14961:   conn->is_chunked = 1;",
          "14962:  } else {",
          "14963:   conn->content_len = -1;",
          "14964:  }",
          "14968:  return 1;",
          "14969: }",
          "14972: int",
          "14973: mg_get_response(struct mg_connection *conn,",
          "14974:                 char *ebuf,",
          "14975:                 size_t ebuf_len,",
          "14976:                 int timeout)",
          "14977: {",
          "14978:  if (ebuf_len > 0) {",
          "14979:   ebuf[0] = '\\0';",
          "14980:  }",
          "14982:  if (!conn) {",
          "14983:   mg_snprintf(conn,",
          "14985:               ebuf,",
          "14986:               ebuf_len,",
          "14987:               \"%s\",",
          "14988:               \"Parameter error\");",
          "14989:   return -1;",
          "14990:  }",
          "14993:  int err, ret;",
          "14994:  struct mg_context *octx = conn->ctx;",
          "14995:  struct mg_context rctx = *(conn->ctx);",
          "14998:  if (timeout >= 0) {",
          "14999:   mg_snprintf(conn, NULL, txt, sizeof(txt), \"%i\", timeout);",
          "15000:   rctx.config[REQUEST_TIMEOUT] = txt;",
          "15002:   set_sock_timeout(conn->client.sock, timeout);",
          "15004:  } else {",
          "15005:   rctx.config[REQUEST_TIMEOUT] = NULL;",
          "15006:  }",
          "15008:  conn->ctx = &rctx;",
          "15009:  ret = get_response(conn, ebuf, ebuf_len, &err);",
          "15010:  conn->ctx = octx;",
          "15015:  conn->request_info.uri = conn->request_info.request_uri;",
          "15017:  conn->request_info.local_uri = conn->request_info.request_uri;",
          "15021:  return (ret == 0) ? -1 : +1;",
          "15022: }",
          "15025: struct mg_connection *",
          "15026: mg_download(const char *host,",
          "15027:             int port,",
          "15028:             int use_ssl,",
          "15029:             char *ebuf,",
          "15030:             size_t ebuf_len,",
          "15031:             const char *fmt,",
          "15032:             ...)",
          "15033: {",
          "15034:  struct mg_connection *conn;",
          "15035:  va_list ap;",
          "15036:  int i;",
          "15037:  int reqerr;",
          "15039:  if (ebuf_len > 0) {",
          "15040:   ebuf[0] = '\\0';",
          "15041:  }",
          "15043:  va_start(ap, fmt);",
          "15046:  conn = mg_connect_client(host, port, use_ssl, ebuf, ebuf_len);",
          "15048:  if (conn != NULL) {",
          "15049:   i = mg_vprintf(conn, fmt, ap);",
          "15050:   if (i <= 0) {",
          "15051:    mg_snprintf(conn,",
          "15053:                ebuf,",
          "15054:                ebuf_len,",
          "15055:                \"%s\",",
          "15056:                \"Error sending request\");",
          "15057:   } else {",
          "15058:    get_response(conn, ebuf, ebuf_len, &reqerr);",
          "15063:    conn->request_info.uri = conn->request_info.request_uri;",
          "15065:    conn->request_info.local_uri = conn->request_info.request_uri;",
          "15067:  }",
          "15070:  if ((ebuf[0] != '\\0') && (conn != NULL)) {",
          "15071:   mg_close_connection(conn);",
          "15072:   conn = NULL;",
          "15075:  va_end(ap);",
          "15076:  return conn;",
          "15077: }",
          "15080: struct websocket_client_thread_data {",
          "15081:  struct mg_connection *conn;",
          "15082:  mg_websocket_data_handler data_handler;",
          "15083:  mg_websocket_close_handler close_handler;",
          "15084:  void *callback_data;",
          "15085: };",
          "15090: static unsigned __stdcall websocket_client_thread(void *data)",
          "15095: {",
          "15096:  struct websocket_client_thread_data *cdata =",
          "15097:      (struct websocket_client_thread_data *)data;",
          "15099:  mg_set_thread_name(\"ws-clnt\");",
          "15101:  if (cdata->conn->ctx) {",
          "15102:   if (cdata->conn->ctx->callbacks.init_thread) {",
          "15105:    cdata->conn->ctx->callbacks.init_thread(cdata->conn->ctx, 3);",
          "15107:  }",
          "15109:  read_websocket(cdata->conn, cdata->data_handler, cdata->callback_data);",
          "15111:  DEBUG_TRACE(\"%s\", \"Websocket client thread exited\\n\");",
          "15113:  if (cdata->close_handler != NULL) {",
          "15114:   cdata->close_handler(cdata->conn, cdata->callback_data);",
          "15115:  }",
          "15119:  cdata->conn->ctx->stop_flag = 2;",
          "15121:  mg_free((void *)cdata);",
          "15124:  return 0;",
          "15128: }",
          "15132: struct mg_connection *",
          "15133: mg_connect_websocket_client(const char *host,",
          "15134:                             int port,",
          "15135:                             int use_ssl,",
          "15136:                             char *error_buffer,",
          "15137:                             size_t error_buffer_size,",
          "15138:                             const char *path,",
          "15139:                             const char *origin,",
          "15140:                             mg_websocket_data_handler data_func,",
          "15141:                             mg_websocket_close_handler close_func,",
          "15142:                             void *user_data)",
          "15143: {",
          "15144:  struct mg_connection *conn = NULL;",
          "15147:  struct mg_context *newctx = NULL;",
          "15148:  struct websocket_client_thread_data *thread_data;",
          "15149:  static const char *magic = \"x3JJHMbDL1EzLkh9GBhXDw==\";",
          "15150:  static const char *handshake_req;",
          "15152:  if (origin != NULL) {",
          "15153:   handshake_req = \"GET %s HTTP/1.1\\r\\n\"",
          "15154:                   \"Host: %s\\r\\n\"",
          "15155:                   \"Upgrade: websocket\\r\\n\"",
          "15156:                   \"Connection: Upgrade\\r\\n\"",
          "15157:                   \"Sec-WebSocket-Key: %s\\r\\n\"",
          "15158:                   \"Sec-WebSocket-Version: 13\\r\\n\"",
          "15159:                   \"Origin: %s\\r\\n\"",
          "15160:                   \"\\r\\n\";",
          "15161:  } else {",
          "15162:   handshake_req = \"GET %s HTTP/1.1\\r\\n\"",
          "15163:                   \"Host: %s\\r\\n\"",
          "15164:                   \"Upgrade: websocket\\r\\n\"",
          "15165:                   \"Connection: Upgrade\\r\\n\"",
          "15166:                   \"Sec-WebSocket-Key: %s\\r\\n\"",
          "15167:                   \"Sec-WebSocket-Version: 13\\r\\n\"",
          "15168:                   \"\\r\\n\";",
          "15169:  }",
          "15172:  conn = mg_download(host,",
          "15173:                     port,",
          "15174:                     use_ssl,",
          "15175:                     error_buffer,",
          "15176:                     error_buffer_size,",
          "15177:                     handshake_req,",
          "15178:                     path,",
          "15179:                     host,",
          "15180:                     magic,",
          "15181:                     origin);",
          "15184:  if (conn == NULL) {",
          "15185:   if (!*error_buffer) {",
          "15187:    mg_snprintf(conn,",
          "15189:                error_buffer,",
          "15190:                error_buffer_size,",
          "15191:                \"Unexpected error\");",
          "15193:   return NULL;",
          "15194:  }",
          "15196:  if (conn->response_info.status_code != 101) {",
          "15201:   if (!*error_buffer) {",
          "15203:    mg_snprintf(conn,",
          "15205:                error_buffer,",
          "15206:                error_buffer_size,",
          "15207:                \"Unexpected server reply\");",
          "15210:   DEBUG_TRACE(\"Websocket client connect error: %s\\r\\n\", error_buffer);",
          "15211:   mg_free(conn);",
          "15212:   return conn;",
          "15213:  }",
          "15217:  newctx = (struct mg_context *)mg_malloc(sizeof(struct mg_context));",
          "15218:  memcpy(newctx, conn->ctx, sizeof(struct mg_context));",
          "15219:  newctx->user_data = user_data;",
          "15222:  newctx->worker_threadids =",
          "15223:      (pthread_t *)mg_calloc_ctx(newctx->cfg_worker_threads,",
          "15224:                                 sizeof(pthread_t),",
          "15225:                                 newctx);",
          "15226:  conn->ctx = newctx;",
          "15227:  thread_data = (struct websocket_client_thread_data *)",
          "15228:      mg_calloc_ctx(sizeof(struct websocket_client_thread_data), 1, newctx);",
          "15229:  thread_data->conn = conn;",
          "15230:  thread_data->data_handler = data_func;",
          "15231:  thread_data->close_handler = close_func;",
          "15232:  thread_data->callback_data = user_data;",
          "15237:  if (mg_start_thread_with_id(websocket_client_thread,",
          "15238:                              (void *)thread_data,",
          "15239:                              newctx->worker_threadids) != 0) {",
          "15240:   mg_free((void *)thread_data);",
          "15241:   mg_free((void *)newctx->worker_threadids);",
          "15242:   mg_free((void *)newctx);",
          "15243:   mg_free((void *)conn);",
          "15244:   conn = NULL;",
          "15245:   DEBUG_TRACE(\"%s\",",
          "15246:               \"Websocket client connect thread could not be started\\r\\n\");",
          "15247:  }",
          "",
          "---------------",
          "--- Hunk 60 ---",
          "[Context before]",
          "15231:  (void)close_func;",
          "15232: #endif",
          "15247: #if defined(USE_SERVER_STATS)",
          "15255: #endif",
          "15277:      }",
          "15280:      mg_snprintf(conn,",
          "15282:                  ebuf,",
          "15283:                  sizeof(ebuf),",
          "15287:     }",
          "15323: #if defined(MG_LEGACY_INTERFACE)",
          "15326: #endif",
          "15347:      }",
          "15348:     } else {",
          "15349:      conn->must_close = 1;",
          "15350:     }",
          "15408: #if defined(USE_SERVER_STATS)",
          "15411: #endif",
          "15413:  }",
          "15416: #if defined(ALTERNATIVE_QUEUE)",
          "15431:    }",
          "15434:   }",
          "15435:  }",
          "",
          "[Removed Lines]",
          "15234:   return conn;",
          "15235:  }",
          "15238:  static void process_new_connection(struct mg_connection * conn)",
          "15239:  {",
          "15240:   if (conn && conn->ctx) {",
          "15241:    struct mg_request_info *ri = &conn->request_info;",
          "15242:    int keep_alive_enabled, keep_alive, discard_len;",
          "15243:    char ebuf[100];",
          "15244:    const char *hostend;",
          "15245:    int reqerr, uri_type;",
          "15248:    int mcon = mg_atomic_inc(&(conn->ctx->active_connections));",
          "15249:    mg_atomic_add(&(conn->ctx->total_connections), 1);",
          "15250:    if (mcon > (conn->ctx->max_connections)) {",
          "15253:     conn->ctx->max_connections = mcon;",
          "15254:    }",
          "15257:    keep_alive_enabled =",
          "15258:        !strcmp(conn->ctx->config[ENABLE_KEEP_ALIVE], \"yes\");",
          "15262:    conn->data_len = 0;",
          "15263:    conn->handled_requests = 0;",
          "15264:    do {",
          "15266:     DEBUG_TRACE(",
          "15267:         \"calling get_request (%i times for this connection)\",",
          "15268:         conn->handled_requests + 1);",
          "15270:     if (!get_request(conn, ebuf, sizeof(ebuf), &reqerr)) {",
          "15274:      if (reqerr > 0) {",
          "15276:       mg_send_http_error(conn, reqerr, \"%s\", ebuf);",
          "15278:     } else if (strcmp(ri->http_version, \"1.0\")",
          "15279:                && strcmp(ri->http_version, \"1.1\")) {",
          "15284:                  \"Bad HTTP version: [%s]\",",
          "15285:                  ri->http_version);",
          "15286:      mg_send_http_error(conn, 505, \"%s\", ebuf);",
          "15289:     if (ebuf[0] == '\\0') {",
          "15290:      uri_type = get_uri_type(conn->request_info.request_uri);",
          "15291:      switch (uri_type) {",
          "15292:      case 1:",
          "15294:       conn->request_info.local_uri = NULL;",
          "15295:       break;",
          "15296:      case 2:",
          "15298:       conn->request_info.local_uri =",
          "15299:           conn->request_info.request_uri;",
          "15300:       break;",
          "15301:      case 3:",
          "15302:      case 4:",
          "15304:       hostend = get_rel_url_at_current_server(",
          "15305:           conn->request_info.request_uri, conn);",
          "15306:       if (hostend) {",
          "15307:        conn->request_info.local_uri = hostend;",
          "15308:       } else {",
          "15309:        conn->request_info.local_uri = NULL;",
          "15310:       }",
          "15311:       break;",
          "15312:      default:",
          "15313:       mg_snprintf(conn,",
          "15315:                   ebuf,",
          "15316:                   sizeof(ebuf),",
          "15317:                   \"Invalid URI\");",
          "15318:       mg_send_http_error(conn, 400, \"%s\", ebuf);",
          "15319:       conn->request_info.local_uri = NULL;",
          "15320:       break;",
          "15321:      }",
          "15325:      conn->request_info.uri = conn->request_info.local_uri;",
          "15327:     }",
          "15329:     DEBUG_TRACE(\"http: %s, error: %s\",",
          "15330:                 (ri->http_version ? ri->http_version : \"none\"),",
          "15331:                 (ebuf[0] ? ebuf : \"none\"));",
          "15333:     if (ebuf[0] == '\\0') {",
          "15334:      if (conn->request_info.local_uri) {",
          "15336:       handle_request(conn);",
          "15337:       DEBUG_TRACE(\"%s\", \"handle_request done\");",
          "15338:       if (conn->ctx->callbacks.end_request != NULL) {",
          "15339:        conn->ctx->callbacks.end_request(conn,",
          "15340:                                         conn->status_code);",
          "15341:        DEBUG_TRACE(\"%s\", \"end_request callback done\");",
          "15342:       }",
          "15343:       log_access(conn);",
          "15344:      } else {",
          "15346:       conn->must_close = 1;",
          "15352:     if (ri->remote_user != NULL) {",
          "15353:      mg_free((void *)ri->remote_user);",
          "15356:      ri->remote_user = NULL;",
          "15357:     }",
          "15366:     keep_alive = (conn->ctx->stop_flag == 0) && keep_alive_enabled",
          "15367:                  && (conn->content_len >= 0)",
          "15368:                  && should_keep_alive(conn);",
          "15372:     discard_len =",
          "15373:         ((conn->content_len >= 0) && (conn->request_len > 0)",
          "15374:          && ((conn->request_len + conn->content_len)",
          "15375:              < (int64_t)conn->data_len))",
          "15376:             ? (int)(conn->request_len + conn->content_len)",
          "15377:             : conn->data_len;",
          "15379:     if (discard_len < 0) {",
          "15380:      DEBUG_TRACE(\"internal error: discard_len = %li\",",
          "15381:                  (long int)discard_len);",
          "15382:      break;",
          "15383:     }",
          "15384:     conn->data_len -= discard_len;",
          "15385:     if (conn->data_len > 0) {",
          "15386:      DEBUG_TRACE(\"discard_len = %lu\",",
          "15387:                  (long unsigned)discard_len);",
          "15388:      memmove(conn->buf,",
          "15389:              conn->buf + discard_len,",
          "15390:              (size_t)conn->data_len);",
          "15391:     }",
          "15396:     if ((conn->data_len < 0) || (conn->data_len > conn->buf_size)) {",
          "15397:      DEBUG_TRACE(",
          "15398:          \"internal error: data_len = %li, buf_size = %li\",",
          "15399:          (long int)conn->data_len,",
          "15400:          (long int)conn->buf_size);",
          "15401:      break;",
          "15402:     }",
          "15404:     conn->handled_requests++;",
          "15406:    } while (keep_alive);",
          "15409:    mg_atomic_add(&(conn->ctx->total_requests), conn->handled_requests);",
          "15410:    mg_atomic_dec(&(conn->ctx->active_connections));",
          "15412:   }",
          "15418:  static void produce_socket(struct mg_context * ctx, const struct socket *sp)",
          "15419:  {",
          "15420:   unsigned int i;",
          "15422:   for (;;) {",
          "15423:    for (i = 0; i < ctx->cfg_worker_threads; i++) {",
          "15425:     if (ctx->client_socks[i].in_use == 0) {",
          "15426:      ctx->client_socks[i] = *sp;",
          "15427:      ctx->client_socks[i].in_use = 1;",
          "15428:      event_signal(ctx->client_wait_events[i]);",
          "15429:      return;",
          "15430:     }",
          "15433:    mg_sleep(1);",
          "15438:  static int consume_socket(struct mg_context * ctx,",
          "15439:                            struct socket * sp,",
          "15440:                            int thread_index)",
          "15441:  {",
          "15442:   DEBUG_TRACE(\"%s\", \"going idle\");",
          "15443:   ctx->client_socks[thread_index].in_use = 0;",
          "15444:   event_wait(ctx->client_wait_events[thread_index]);",
          "15446:   DEBUG_TRACE(\"grabbed socket %d, going busy\", sp ? sp->sock : -1);",
          "15448:   return !ctx->stop_flag;",
          "15449:  }",
          "",
          "[Added Lines]",
          "15263:  return conn;",
          "15264: }",
          "15267: static void",
          "15268: process_new_connection(struct mg_connection *conn)",
          "15269: {",
          "15270:  if (conn && conn->ctx) {",
          "15271:   struct mg_request_info *ri = &conn->request_info;",
          "15272:   int keep_alive_enabled, keep_alive, discard_len;",
          "15273:   char ebuf[100];",
          "15274:   const char *hostend;",
          "15275:   int reqerr, uri_type;",
          "15278:   int mcon = mg_atomic_inc(&(conn->ctx->active_connections));",
          "15279:   mg_atomic_add(&(conn->ctx->total_connections), 1);",
          "15280:   if (mcon > (conn->ctx->max_connections)) {",
          "15283:    conn->ctx->max_connections = mcon;",
          "15284:   }",
          "15287:   keep_alive_enabled =",
          "15288:       !strcmp(conn->ctx->config[ENABLE_KEEP_ALIVE], \"yes\");",
          "15292:   conn->data_len = 0;",
          "15293:   conn->handled_requests = 0;",
          "15294:   do {",
          "15296:    DEBUG_TRACE(\"calling get_request (%i times for this connection)\",",
          "15297:                conn->handled_requests + 1);",
          "15299:    if (!get_request(conn, ebuf, sizeof(ebuf), &reqerr)) {",
          "15303:     if (reqerr > 0) {",
          "15305:      mg_send_http_error(conn, reqerr, \"%s\", ebuf);",
          "15306:     }",
          "15307:    } else if (strcmp(ri->http_version, \"1.0\")",
          "15308:               && strcmp(ri->http_version, \"1.1\")) {",
          "15309:     mg_snprintf(conn,",
          "15311:                 ebuf,",
          "15312:                 sizeof(ebuf),",
          "15313:                 \"Bad HTTP version: [%s]\",",
          "15314:                 ri->http_version);",
          "15315:     mg_send_http_error(conn, 505, \"%s\", ebuf);",
          "15316:    }",
          "15318:    if (ebuf[0] == '\\0') {",
          "15319:     uri_type = get_uri_type(conn->request_info.request_uri);",
          "15320:     switch (uri_type) {",
          "15321:     case 1:",
          "15323:      conn->request_info.local_uri = NULL;",
          "15324:      break;",
          "15325:     case 2:",
          "15327:      conn->request_info.local_uri =",
          "15328:          conn->request_info.request_uri;",
          "15329:      break;",
          "15330:     case 3:",
          "15331:     case 4:",
          "15333:      hostend = get_rel_url_at_current_server(",
          "15334:          conn->request_info.request_uri, conn);",
          "15335:      if (hostend) {",
          "15336:       conn->request_info.local_uri = hostend;",
          "15337:      } else {",
          "15338:       conn->request_info.local_uri = NULL;",
          "15340:      break;",
          "15341:     default:",
          "15346:                  \"Invalid URI\");",
          "15347:      mg_send_http_error(conn, 400, \"%s\", ebuf);",
          "15348:      conn->request_info.local_uri = NULL;",
          "15349:      break;",
          "15354:     conn->request_info.uri = conn->request_info.local_uri;",
          "15356:    }",
          "15358:    DEBUG_TRACE(\"http: %s, error: %s\",",
          "15359:                (ri->http_version ? ri->http_version : \"none\"),",
          "15360:                (ebuf[0] ? ebuf : \"none\"));",
          "15362:    if (ebuf[0] == '\\0') {",
          "15363:     if (conn->request_info.local_uri) {",
          "15365:      handle_request(conn);",
          "15366:      DEBUG_TRACE(\"%s\", \"handle_request done\");",
          "15367:      if (conn->ctx->callbacks.end_request != NULL) {",
          "15368:       conn->ctx->callbacks.end_request(conn,",
          "15369:                                        conn->status_code);",
          "15370:       DEBUG_TRACE(\"%s\", \"end_request callback done\");",
          "15372:      log_access(conn);",
          "15377:    } else {",
          "15378:     conn->must_close = 1;",
          "15379:    }",
          "15381:    if (ri->remote_user != NULL) {",
          "15382:     mg_free((void *)ri->remote_user);",
          "15385:     ri->remote_user = NULL;",
          "15386:    }",
          "15395:    keep_alive = (conn->ctx->stop_flag == 0) && keep_alive_enabled",
          "15396:                 && (conn->content_len >= 0) && should_keep_alive(conn);",
          "15400:    discard_len = ((conn->content_len >= 0) && (conn->request_len > 0)",
          "15401:                   && ((conn->request_len + conn->content_len)",
          "15402:                       < (int64_t)conn->data_len))",
          "15403:                      ? (int)(conn->request_len + conn->content_len)",
          "15404:                      : conn->data_len;",
          "15406:    if (discard_len < 0) {",
          "15407:     DEBUG_TRACE(\"internal error: discard_len = %li\",",
          "15408:                 (long int)discard_len);",
          "15409:     break;",
          "15410:    }",
          "15411:    conn->data_len -= discard_len;",
          "15412:    if (conn->data_len > 0) {",
          "15413:     DEBUG_TRACE(\"discard_len = %lu\", (long unsigned)discard_len);",
          "15414:     memmove(conn->buf,",
          "15415:             conn->buf + discard_len,",
          "15416:             (size_t)conn->data_len);",
          "15417:    }",
          "15422:    if ((conn->data_len < 0) || (conn->data_len > conn->buf_size)) {",
          "15423:     DEBUG_TRACE(\"internal error: data_len = %li, buf_size = %li\",",
          "15424:                 (long int)conn->data_len,",
          "15425:                 (long int)conn->buf_size);",
          "15426:     break;",
          "15427:    }",
          "15429:    conn->handled_requests++;",
          "15431:   } while (keep_alive);",
          "15434:   mg_atomic_add(&(conn->ctx->total_requests), conn->handled_requests);",
          "15435:   mg_atomic_dec(&(conn->ctx->active_connections));",
          "15438: }",
          "15443: static void",
          "15444: produce_socket(struct mg_context *ctx, const struct socket *sp)",
          "15445: {",
          "15446:  unsigned int i;",
          "15448:  for (;;) {",
          "15449:   for (i = 0; i < ctx->cfg_worker_threads; i++) {",
          "15451:    if (ctx->client_socks[i].in_use == 0) {",
          "15452:     ctx->client_socks[i] = *sp;",
          "15453:     ctx->client_socks[i].in_use = 1;",
          "15454:     event_signal(ctx->client_wait_events[i]);",
          "15455:     return;",
          "15459:   mg_sleep(1);",
          "15461: }",
          "15464: static int",
          "15465: consume_socket(struct mg_context *ctx, struct socket *sp, int thread_index)",
          "15466: {",
          "15467:  DEBUG_TRACE(\"%s\", \"going idle\");",
          "15468:  ctx->client_socks[thread_index].in_use = 0;",
          "15469:  event_wait(ctx->client_wait_events[thread_index]);",
          "15471:  DEBUG_TRACE(\"grabbed socket %d, going busy\", sp ? sp->sock : -1);",
          "15473:  return !ctx->stop_flag;",
          "15474: }",
          "",
          "---------------",
          "--- Hunk 61 ---",
          "[Context before]",
          "15533: #if defined(MG_LEGACY_INTERFACE)",
          "15535: #endif",
          "15541: #if defined(_WIN32) && !defined(__SYMBIAN32__)",
          "15543: #endif",
          "15594: #if defined(USE_IPV6)",
          "15599: #endif",
          "15612: #if defined(MG_LEGACY_INTERFACE)",
          "15616: #endif",
          "15621: #ifndef NO_SSL",
          "15654:     process_new_connection(conn);",
          "15655:    }",
          "15668: #if defined(_WIN32) && !defined(__SYMBIAN32__)",
          "15670: #endif",
          "15684: #ifdef _WIN32",
          "15693: #else",
          "15694: static void *",
          "15695: worker_thread(void *thread_func_param)",
          "",
          "[Removed Lines]",
          "15522:  struct worker_thread_args {",
          "15523:   struct mg_context *ctx;",
          "15524:   int index;",
          "15525:  };",
          "15528:  static void *worker_thread_run(struct worker_thread_args * thread_args)",
          "15529:  {",
          "15530:   struct mg_context *ctx = thread_args->ctx;",
          "15531:   struct mg_connection *conn;",
          "15532:   struct mg_workerTLS tls;",
          "15534:   uint32_t addr;",
          "15537:   mg_set_thread_name(\"worker\");",
          "15539:   tls.is_master = 0;",
          "15540:   tls.thread_idx = (unsigned)mg_atomic_inc(&thread_idx_max);",
          "15542:   tls.pthread_cond_helper_mutex = CreateEvent(NULL, FALSE, FALSE, NULL);",
          "15546:   pthread_setspecific(sTlsKey, &tls);",
          "15548:   if (ctx->callbacks.init_thread) {",
          "15550:    ctx->callbacks.init_thread(ctx, 1);",
          "15551:   }",
          "15554:   if (((int)thread_args->index < 0)",
          "15555:       || ((unsigned)thread_args->index",
          "15556:           >= (unsigned)ctx->cfg_worker_threads)) {",
          "15557:    mg_cry(fc(ctx),",
          "15558:           \"Internal error: Invalid worker index %i\",",
          "15559:           (int)thread_args->index);",
          "15560:    return NULL;",
          "15561:   }",
          "15562:   conn = ctx->worker_connections + thread_args->index;",
          "15567:   conn->buf = (char *)mg_malloc_ctx(ctx->max_request_size, conn->ctx);",
          "15568:   if (conn->buf == NULL) {",
          "15569:    mg_cry(fc(ctx),",
          "15570:           \"Out of memory: Cannot allocate buffer for worker %i\",",
          "15571:           (int)thread_args->index);",
          "15572:    return NULL;",
          "15573:   }",
          "15574:   conn->buf_size = (int)ctx->max_request_size;",
          "15576:   conn->ctx = ctx;",
          "15577:   conn->thread_index = thread_args->index;",
          "15578:   conn->request_info.user_data = ctx->user_data;",
          "15582:   (void)pthread_mutex_init(&conn->mutex, &pthread_mutex_attr);",
          "15587:   while (consume_socket(ctx, &conn->client, conn->thread_index)) {",
          "15588:    conn->conn_birth_time = time(NULL);",
          "15595:    if (conn->client.rsa.sa.sa_family == AF_INET6) {",
          "15596:     conn->request_info.remote_port =",
          "15597:         ntohs(conn->client.rsa.sin6.sin6_port);",
          "15598:    } else",
          "15600:    {",
          "15601:     conn->request_info.remote_port =",
          "15602:         ntohs(conn->client.rsa.sin.sin_port);",
          "15603:    }",
          "15605:    sockaddr_to_string(conn->request_info.remote_addr,",
          "15606:                       sizeof(conn->request_info.remote_addr),",
          "15607:                       &conn->client.rsa);",
          "15609:    DEBUG_TRACE(\"Start processing connection from %s\",",
          "15610:                conn->request_info.remote_addr);",
          "15614:    addr = ntohl(conn->client.rsa.sin.sin_addr.s_addr);",
          "15615:    memcpy(&conn->request_info.remote_ip, &addr, 4);",
          "15618:    conn->request_info.is_ssl = conn->client.is_ssl;",
          "15620:    if (conn->client.is_ssl) {",
          "15623:     if (sslize(conn,",
          "15624:                conn->ctx->ssl_ctx,",
          "15625:                SSL_accept,",
          "15626:                &(conn->ctx->stop_flag))) {",
          "15628:      ssl_get_client_cert_info(conn);",
          "15631:      process_new_connection(conn);",
          "15634:      if (conn->request_info.client_cert) {",
          "15635:       mg_free(",
          "15636:           (void *)(conn->request_info.client_cert->subject));",
          "15637:       mg_free(",
          "15638:           (void *)(conn->request_info.client_cert->issuer));",
          "15639:       mg_free(",
          "15640:           (void *)(conn->request_info.client_cert->serial));",
          "15641:       mg_free(",
          "15642:           (void *)(conn->request_info.client_cert->finger));",
          "15643:       conn->request_info.client_cert->subject = 0;",
          "15644:       conn->request_info.client_cert->issuer = 0;",
          "15645:       conn->request_info.client_cert->serial = 0;",
          "15646:       conn->request_info.client_cert->finger = 0;",
          "15647:       mg_free(conn->request_info.client_cert);",
          "15648:       conn->request_info.client_cert = 0;",
          "15649:      }",
          "15650:     }",
          "15651: #endif",
          "15652:    } else {",
          "15657:    DEBUG_TRACE(\"Done processing connection from %s (%f sec)\",",
          "15658:                conn->request_info.remote_addr,",
          "15659:                difftime(time(NULL), conn->conn_birth_time));",
          "15661:    close_connection(conn);",
          "15663:    DEBUG_TRACE(\"%s\", \"Connection closed\");",
          "15664:   }",
          "15667:   pthread_setspecific(sTlsKey, NULL);",
          "15669:   CloseHandle(tls.pthread_cond_helper_mutex);",
          "15671:   pthread_mutex_destroy(&conn->mutex);",
          "15674:   conn->buf_size = 0;",
          "15675:   mg_free(conn->buf);",
          "15676:   conn->buf = NULL;",
          "15678:   DEBUG_TRACE(\"%s\", \"exiting\");",
          "15679:   return NULL;",
          "15680:  }",
          "15685:  static unsigned __stdcall worker_thread(void *thread_func_param)",
          "15686:  {",
          "15687:   struct worker_thread_args *pwta =",
          "15688:       (struct worker_thread_args *)thread_func_param;",
          "15689:   worker_thread_run(pwta);",
          "15690:   mg_free(thread_func_param);",
          "15691:   return 0;",
          "15692:  }",
          "",
          "[Added Lines]",
          "15547: struct worker_thread_args {",
          "15548:  struct mg_context *ctx;",
          "15549:  int index;",
          "15550: };",
          "15553: static void *",
          "15554: worker_thread_run(struct worker_thread_args *thread_args)",
          "15555: {",
          "15556:  struct mg_context *ctx = thread_args->ctx;",
          "15557:  struct mg_connection *conn;",
          "15558:  struct mg_workerTLS tls;",
          "15560:  uint32_t addr;",
          "15563:  mg_set_thread_name(\"worker\");",
          "15565:  tls.is_master = 0;",
          "15566:  tls.thread_idx = (unsigned)mg_atomic_inc(&thread_idx_max);",
          "15568:  tls.pthread_cond_helper_mutex = CreateEvent(NULL, FALSE, FALSE, NULL);",
          "15572:  pthread_setspecific(sTlsKey, &tls);",
          "15574:  if (ctx->callbacks.init_thread) {",
          "15576:   ctx->callbacks.init_thread(ctx, 1);",
          "15577:  }",
          "15580:  if (((int)thread_args->index < 0)",
          "15581:      || ((unsigned)thread_args->index",
          "15582:          >= (unsigned)ctx->cfg_worker_threads)) {",
          "15583:   mg_cry(fc(ctx),",
          "15584:          \"Internal error: Invalid worker index %i\",",
          "15585:          (int)thread_args->index);",
          "15586:   return NULL;",
          "15587:  }",
          "15588:  conn = ctx->worker_connections + thread_args->index;",
          "15593:  conn->buf = (char *)mg_malloc_ctx(ctx->max_request_size, conn->ctx);",
          "15594:  if (conn->buf == NULL) {",
          "15595:   mg_cry(fc(ctx),",
          "15596:          \"Out of memory: Cannot allocate buffer for worker %i\",",
          "15597:          (int)thread_args->index);",
          "15598:   return NULL;",
          "15599:  }",
          "15600:  conn->buf_size = (int)ctx->max_request_size;",
          "15602:  conn->ctx = ctx;",
          "15603:  conn->thread_index = thread_args->index;",
          "15604:  conn->request_info.user_data = ctx->user_data;",
          "15608:  (void)pthread_mutex_init(&conn->mutex, &pthread_mutex_attr);",
          "15613:  while (consume_socket(ctx, &conn->client, conn->thread_index)) {",
          "15614:   conn->conn_birth_time = time(NULL);",
          "15621:   if (conn->client.rsa.sa.sa_family == AF_INET6) {",
          "15622:    conn->request_info.remote_port =",
          "15623:        ntohs(conn->client.rsa.sin6.sin6_port);",
          "15624:   } else",
          "15626:   {",
          "15627:    conn->request_info.remote_port =",
          "15628:        ntohs(conn->client.rsa.sin.sin_port);",
          "15629:   }",
          "15631:   sockaddr_to_string(conn->request_info.remote_addr,",
          "15632:                      sizeof(conn->request_info.remote_addr),",
          "15633:                      &conn->client.rsa);",
          "15635:   DEBUG_TRACE(\"Start processing connection from %s\",",
          "15636:               conn->request_info.remote_addr);",
          "15640:   addr = ntohl(conn->client.rsa.sin.sin_addr.s_addr);",
          "15641:   memcpy(&conn->request_info.remote_ip, &addr, 4);",
          "15644:   conn->request_info.is_ssl = conn->client.is_ssl;",
          "15646:   if (conn->client.is_ssl) {",
          "15649:    if (sslize(conn,",
          "15650:               conn->ctx->ssl_ctx,",
          "15651:               SSL_accept,",
          "15652:               &(conn->ctx->stop_flag))) {",
          "15654:     ssl_get_client_cert_info(conn);",
          "15660:     if (conn->request_info.client_cert) {",
          "15661:      mg_free((void *)(conn->request_info.client_cert->subject));",
          "15662:      mg_free((void *)(conn->request_info.client_cert->issuer));",
          "15663:      mg_free((void *)(conn->request_info.client_cert->serial));",
          "15664:      mg_free((void *)(conn->request_info.client_cert->finger));",
          "15665:      conn->request_info.client_cert->subject = 0;",
          "15666:      conn->request_info.client_cert->issuer = 0;",
          "15667:      conn->request_info.client_cert->serial = 0;",
          "15668:      conn->request_info.client_cert->finger = 0;",
          "15669:      mg_free(conn->request_info.client_cert);",
          "15670:      conn->request_info.client_cert = 0;",
          "15671:     }",
          "15673: #endif",
          "15674:   } else {",
          "15676:    process_new_connection(conn);",
          "15677:   }",
          "15679:   DEBUG_TRACE(\"Done processing connection from %s (%f sec)\",",
          "15680:               conn->request_info.remote_addr,",
          "15681:               difftime(time(NULL), conn->conn_birth_time));",
          "15683:   close_connection(conn);",
          "15685:   DEBUG_TRACE(\"%s\", \"Connection closed\");",
          "15686:  }",
          "15689:  pthread_setspecific(sTlsKey, NULL);",
          "15691:  CloseHandle(tls.pthread_cond_helper_mutex);",
          "15693:  pthread_mutex_destroy(&conn->mutex);",
          "15696:  conn->buf_size = 0;",
          "15697:  mg_free(conn->buf);",
          "15698:  conn->buf = NULL;",
          "15700:  DEBUG_TRACE(\"%s\", \"exiting\");",
          "15701:  return NULL;",
          "15702: }",
          "15707: static unsigned __stdcall worker_thread(void *thread_func_param)",
          "15708: {",
          "15709:  struct worker_thread_args *pwta =",
          "15710:      (struct worker_thread_args *)thread_func_param;",
          "15711:  worker_thread_run(pwta);",
          "15712:  mg_free(thread_func_param);",
          "15713:  return 0;",
          "15714: }",
          "",
          "---------------",
          "--- Hunk 62 ---",
          "[Context before]",
          "15716:   }",
          "15722:    mg_cry(fc(ctx),",
          "15724:           __func__,",
          "15752:     mg_cry(fc(ctx),",
          "15754:            __func__,",
          "15755:            strerror(ERRNO));",
          "15756:    }",
          "15784:  }",
          "15802: #if defined(_WIN32)",
          "15804: #elif defined(USE_MASTER_THREAD_PRIORITY)",
          "15805:  int min_prio = sched_get_priority_min(SCHED_RR);",
          "15806:  int max_prio = sched_get_priority_max(SCHED_RR);",
          "",
          "[Removed Lines]",
          "15706:  static void accept_new_connection(const struct socket *listener,",
          "15707:                                    struct mg_context *ctx)",
          "15708:  {",
          "15709:   struct socket so;",
          "15710:   char src_addr[IP_ADDR_STR_LEN];",
          "15711:   socklen_t len = sizeof(so.rsa);",
          "15712:   int on = 1;",
          "15714:   if (!listener) {",
          "15715:    return;",
          "15718:   if ((so.sock = accept(listener->sock, &so.rsa.sa, &len))",
          "15719:       == INVALID_SOCKET) {",
          "15720:   } else if (!check_acl(ctx, ntohl(*(uint32_t *)&so.rsa.sin.sin_addr))) {",
          "15721:    sockaddr_to_string(src_addr, sizeof(src_addr), &so.rsa);",
          "15723:           \"%s: %s is not allowed to connect\",",
          "15725:           src_addr);",
          "15726:    closesocket(so.sock);",
          "15727:   } else {",
          "15729:    DEBUG_TRACE(\"Accepted socket %d\", (int)so.sock);",
          "15730:    set_close_on_exec(so.sock, fc(ctx));",
          "15731:    so.is_ssl = listener->is_ssl;",
          "15732:    so.ssl_redir = listener->ssl_redir;",
          "15733:    if (getsockname(so.sock, &so.lsa.sa, &len) != 0) {",
          "15734:     mg_cry(fc(ctx),",
          "15735:            \"%s: getsockname() failed: %s\",",
          "15736:            __func__,",
          "15737:            strerror(ERRNO));",
          "15738:    }",
          "15747:    if (setsockopt(so.sock,",
          "15748:                   SOL_SOCKET,",
          "15749:                   SO_KEEPALIVE,",
          "15750:                   (SOCK_OPT_TYPE)&on,",
          "15751:                   sizeof(on)) != 0) {",
          "15753:            \"%s: setsockopt(SOL_SOCKET SO_KEEPALIVE) failed: %s\",",
          "15765:    if ((ctx != NULL) && (ctx->config[CONFIG_TCP_NODELAY] != NULL)",
          "15766:        && (!strcmp(ctx->config[CONFIG_TCP_NODELAY], \"1\"))) {",
          "15767:     if (set_tcp_nodelay(so.sock, 1) != 0) {",
          "15768:      mg_cry(fc(ctx),",
          "15769:             \"%s: setsockopt(IPPROTO_TCP TCP_NODELAY) failed: %s\",",
          "15770:             __func__,",
          "15771:             strerror(ERRNO));",
          "15772:     }",
          "15773:    }",
          "15779:    set_blocking_mode(so.sock, 0);",
          "15781:    so.in_use = 0;",
          "15782:    produce_socket(ctx, &so);",
          "15783:   }",
          "15787:  static void master_thread_run(void *thread_func_param)",
          "15788:  {",
          "15789:   struct mg_context *ctx = (struct mg_context *)thread_func_param;",
          "15790:   struct mg_workerTLS tls;",
          "15791:   struct pollfd *pfd;",
          "15792:   unsigned int i;",
          "15793:   unsigned int workerthreadcount;",
          "15795:   if (!ctx) {",
          "15796:    return;",
          "15797:   }",
          "15799:   mg_set_thread_name(\"master\");",
          "15803:   SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_ABOVE_NORMAL);",
          "",
          "[Added Lines]",
          "15728: static void",
          "15729: accept_new_connection(const struct socket *listener, struct mg_context *ctx)",
          "15730: {",
          "15731:  struct socket so;",
          "15732:  char src_addr[IP_ADDR_STR_LEN];",
          "15733:  socklen_t len = sizeof(so.rsa);",
          "15734:  int on = 1;",
          "15736:  if (!listener) {",
          "15737:   return;",
          "15738:  }",
          "15740:  if ((so.sock = accept(listener->sock, &so.rsa.sa, &len))",
          "15741:      == INVALID_SOCKET) {",
          "15742:  } else if (!check_acl(ctx, ntohl(*(uint32_t *)&so.rsa.sin.sin_addr))) {",
          "15743:   sockaddr_to_string(src_addr, sizeof(src_addr), &so.rsa);",
          "15744:   mg_cry(fc(ctx), \"%s: %s is not allowed to connect\", __func__, src_addr);",
          "15745:   closesocket(so.sock);",
          "15746:  } else {",
          "15748:   DEBUG_TRACE(\"Accepted socket %d\", (int)so.sock);",
          "15749:   set_close_on_exec(so.sock, fc(ctx));",
          "15750:   so.is_ssl = listener->is_ssl;",
          "15751:   so.ssl_redir = listener->ssl_redir;",
          "15752:   if (getsockname(so.sock, &so.lsa.sa, &len) != 0) {",
          "15753:    mg_cry(fc(ctx),",
          "15754:           \"%s: getsockname() failed: %s\",",
          "15755:           __func__,",
          "15756:           strerror(ERRNO));",
          "15766:   if (setsockopt(so.sock,",
          "15767:                  SOL_SOCKET,",
          "15768:                  SO_KEEPALIVE,",
          "15769:                  (SOCK_OPT_TYPE)&on,",
          "15770:                  sizeof(on)) != 0) {",
          "15772:           \"%s: setsockopt(SOL_SOCKET SO_KEEPALIVE) failed: %s\",",
          "15774:           strerror(ERRNO));",
          "15775:   }",
          "15784:   if ((ctx != NULL) && (ctx->config[CONFIG_TCP_NODELAY] != NULL)",
          "15785:       && (!strcmp(ctx->config[CONFIG_TCP_NODELAY], \"1\"))) {",
          "15786:    if (set_tcp_nodelay(so.sock, 1) != 0) {",
          "15788:            \"%s: setsockopt(IPPROTO_TCP TCP_NODELAY) failed: %s\",",
          "15792:   }",
          "15798:   set_blocking_mode(so.sock, 0);",
          "15800:   so.in_use = 0;",
          "15801:   produce_socket(ctx, &so);",
          "15803: }",
          "15806: static void",
          "15807: master_thread_run(void *thread_func_param)",
          "15808: {",
          "15809:  struct mg_context *ctx = (struct mg_context *)thread_func_param;",
          "15810:  struct mg_workerTLS tls;",
          "15811:  struct pollfd *pfd;",
          "15812:  unsigned int i;",
          "15813:  unsigned int workerthreadcount;",
          "15815:  if (!ctx) {",
          "15816:   return;",
          "15817:  }",
          "15819:  mg_set_thread_name(\"master\");",
          "15823:  SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_ABOVE_NORMAL);",
          "",
          "---------------",
          "--- Hunk 63 ---",
          "[Context before]",
          "15817: #if defined(_WIN32) && !defined(__SYMBIAN32__)",
          "15819: #endif",
          "15849:     }",
          "15850:    }",
          "15851:   }",
          "15861: #if defined(ALTERNATIVE_QUEUE)",
          "15869:   }",
          "15870: #else",
          "15871:  pthread_cond_broadcast(&ctx->sq_full);",
          "15872: #endif",
          "15881:   }",
          "15883: #if defined(USE_LUA)",
          "15889: #endif",
          "15893: #if defined(_WIN32) && !defined(__SYMBIAN32__)",
          "15895: #endif",
          "15906: #ifdef _WIN32",
          "15912: #else",
          "15913: static void *",
          "15914: master_thread(void *thread_func_param)",
          "",
          "[Removed Lines]",
          "15818:   tls.pthread_cond_helper_mutex = CreateEvent(NULL, FALSE, FALSE, NULL);",
          "15820:   tls.is_master = 1;",
          "15821:   pthread_setspecific(sTlsKey, &tls);",
          "15823:   if (ctx->callbacks.init_thread) {",
          "15825:    ctx->callbacks.init_thread(ctx, 0);",
          "15826:   }",
          "15829:   ctx->start_time = time(NULL);",
          "15832:   pfd = ctx->listening_socket_fds;",
          "15833:   while (ctx->stop_flag == 0) {",
          "15834:    for (i = 0; i < ctx->num_listening_sockets; i++) {",
          "15835:     pfd[i].fd = ctx->listening_sockets[i].sock;",
          "15836:     pfd[i].events = POLLIN;",
          "15837:    }",
          "15839:    if (poll(pfd, ctx->num_listening_sockets, 200) > 0) {",
          "15840:     for (i = 0; i < ctx->num_listening_sockets; i++) {",
          "15846:      if ((ctx->stop_flag == 0) && (pfd[i].revents & POLLIN)) {",
          "15847:       accept_new_connection(&ctx->listening_sockets[i], ctx);",
          "15848:      }",
          "15854:   DEBUG_TRACE(\"%s\", \"stopping workers\");",
          "15857:   close_all_listening_sockets(ctx);",
          "15860:   (void)pthread_mutex_lock(&ctx->thread_mutex);",
          "15862:   for (i = 0; i < ctx->cfg_worker_threads; i++) {",
          "15863:    event_signal(ctx->client_wait_events[i]);",
          "15866:    if (ctx->client_socks[i].in_use) {",
          "15867:     shutdown(ctx->client_socks[i].sock, SHUTDOWN_BOTH);",
          "15868:    }",
          "15873:   (void)pthread_mutex_unlock(&ctx->thread_mutex);",
          "15876:   workerthreadcount = ctx->cfg_worker_threads;",
          "15877:   for (i = 0; i < workerthreadcount; i++) {",
          "15878:    if (ctx->worker_threadids[i] != 0) {",
          "15879:     mg_join_thread(ctx->worker_threadids[i]);",
          "15880:    }",
          "15885:   if (ctx->lua_background_state) {",
          "15886:    lua_close((lua_State *)ctx->lua_background_state);",
          "15887:    ctx->lua_background_state = 0;",
          "15888:   }",
          "15891:   DEBUG_TRACE(\"%s\", \"exiting\");",
          "15894:   CloseHandle(tls.pthread_cond_helper_mutex);",
          "15896:   pthread_setspecific(sTlsKey, NULL);",
          "15901:   ctx->stop_flag = 2;",
          "15902:  }",
          "15907:  static unsigned __stdcall master_thread(void *thread_func_param)",
          "15908:  {",
          "15909:   master_thread_run(thread_func_param);",
          "15910:   return 0;",
          "15911:  }",
          "",
          "[Added Lines]",
          "15838:  tls.pthread_cond_helper_mutex = CreateEvent(NULL, FALSE, FALSE, NULL);",
          "15840:  tls.is_master = 1;",
          "15841:  pthread_setspecific(sTlsKey, &tls);",
          "15843:  if (ctx->callbacks.init_thread) {",
          "15845:   ctx->callbacks.init_thread(ctx, 0);",
          "15846:  }",
          "15849:  ctx->start_time = time(NULL);",
          "15852:  pfd = ctx->listening_socket_fds;",
          "15853:  while (ctx->stop_flag == 0) {",
          "15854:   for (i = 0; i < ctx->num_listening_sockets; i++) {",
          "15855:    pfd[i].fd = ctx->listening_sockets[i].sock;",
          "15856:    pfd[i].events = POLLIN;",
          "15857:   }",
          "15859:   if (poll(pfd, ctx->num_listening_sockets, 200) > 0) {",
          "15860:    for (i = 0; i < ctx->num_listening_sockets; i++) {",
          "15866:     if ((ctx->stop_flag == 0) && (pfd[i].revents & POLLIN)) {",
          "15867:      accept_new_connection(&ctx->listening_sockets[i], ctx);",
          "15871:  }",
          "15874:  DEBUG_TRACE(\"%s\", \"stopping workers\");",
          "15877:  close_all_listening_sockets(ctx);",
          "15880:  (void)pthread_mutex_lock(&ctx->thread_mutex);",
          "15882:  for (i = 0; i < ctx->cfg_worker_threads; i++) {",
          "15883:   event_signal(ctx->client_wait_events[i]);",
          "15886:   if (ctx->client_socks[i].in_use) {",
          "15887:    shutdown(ctx->client_socks[i].sock, SHUTDOWN_BOTH);",
          "15889:  }",
          "15893:  (void)pthread_mutex_unlock(&ctx->thread_mutex);",
          "15896:  workerthreadcount = ctx->cfg_worker_threads;",
          "15897:  for (i = 0; i < workerthreadcount; i++) {",
          "15898:   if (ctx->worker_threadids[i] != 0) {",
          "15899:    mg_join_thread(ctx->worker_threadids[i]);",
          "15901:  }",
          "15905:  if (ctx->lua_background_state) {",
          "15906:   lua_close((lua_State *)ctx->lua_background_state);",
          "15907:   ctx->lua_background_state = 0;",
          "15908:  }",
          "15911:  DEBUG_TRACE(\"%s\", \"exiting\");",
          "15914:  CloseHandle(tls.pthread_cond_helper_mutex);",
          "15916:  pthread_setspecific(sTlsKey, NULL);",
          "15921:  ctx->stop_flag = 2;",
          "15922: }",
          "15927: static unsigned __stdcall master_thread(void *thread_func_param)",
          "15928: {",
          "15929:  master_thread_run(thread_func_param);",
          "15930:  return 0;",
          "15931: }",
          "",
          "---------------",
          "--- Hunk 64 ---",
          "[Context before]",
          "15939: #if defined(ALTERNATIVE_QUEUE)",
          "15945: #else",
          "15946:  (void)pthread_cond_destroy(&ctx->sq_empty);",
          "15947:  (void)pthread_cond_destroy(&ctx->sq_full);",
          "15948: #endif",
          "15953: #if defined(USE_TIMERS)",
          "15955: #endif",
          "15960: #if defined(_MSC_VER)",
          "15961: #pragma warning(suppress : 6001)",
          "15962: #endif",
          "15965:   }",
          "15975: #ifndef NO_SSL",
          "16027: #if defined(_WIN32) && !defined(__SYMBIAN32__)",
          "16035: #if defined(_WIN32)",
          "16036: #if !defined(__SYMBIAN32__)",
          "16037: #if defined(_WIN32_WCE)",
          "16039: #else",
          "16047: #ifdef _MSC_VER",
          "16048: #pragma warning(push)",
          "16050: #pragma warning(disable : 4996)",
          "16051: #endif",
          "16053: #ifdef _MSC_VER",
          "16054: #pragma warning(pop)",
          "16055: #endif",
          "16071: #endif",
          "16072: #else",
          "",
          "[Removed Lines]",
          "15922:  static void free_context(struct mg_context * ctx)",
          "15923:  {",
          "15924:   int i;",
          "15925:   struct mg_handler_info *tmp_rh;",
          "15927:   if (ctx == NULL) {",
          "15928:    return;",
          "15929:   }",
          "15931:   if (ctx->callbacks.exit_context) {",
          "15932:    ctx->callbacks.exit_context(ctx);",
          "15933:   }",
          "15938:   (void)pthread_mutex_destroy(&ctx->thread_mutex);",
          "15940:   mg_free(ctx->client_socks);",
          "15941:   for (i = 0; (unsigned)i < ctx->cfg_worker_threads; i++) {",
          "15942:    event_destroy(ctx->client_wait_events[i]);",
          "15943:   }",
          "15944:   mg_free(ctx->client_wait_events);",
          "15951:   (void)pthread_mutex_destroy(&ctx->nonce_mutex);",
          "15954:   timers_exit(ctx);",
          "15958:   for (i = 0; i < NUM_OPTIONS; i++) {",
          "15959:    if (ctx->config[i] != NULL) {",
          "15963:     mg_free(ctx->config[i]);",
          "15964:    }",
          "15968:   while (ctx->handlers) {",
          "15969:    tmp_rh = ctx->handlers;",
          "15970:    ctx->handlers = tmp_rh->next;",
          "15971:    mg_free(tmp_rh->uri);",
          "15972:    mg_free(tmp_rh);",
          "15973:   }",
          "15977:   if (ctx->ssl_ctx != NULL) {",
          "15978:    SSL_CTX_free(ctx->ssl_ctx);",
          "15979:   }",
          "15983:   if (ctx->worker_threadids != NULL) {",
          "15984:    mg_free(ctx->worker_threadids);",
          "15985:   }",
          "15988:   if (ctx->worker_connections != NULL) {",
          "15989:    mg_free(ctx->worker_connections);",
          "15990:   }",
          "15993:   mg_free(ctx->systemName);",
          "15996:   mg_free(ctx);",
          "15997:  }",
          "16000:  void mg_stop(struct mg_context * ctx)",
          "16001:  {",
          "16002:   pthread_t mt;",
          "16003:   if (!ctx) {",
          "16004:    return;",
          "16005:   }",
          "16009:   mt = ctx->masterthreadid;",
          "16010:   if (mt == 0) {",
          "16011:    return;",
          "16012:   }",
          "16014:   ctx->masterthreadid = 0;",
          "16017:   ctx->stop_flag = 1;",
          "16020:   while (ctx->stop_flag != 2) {",
          "16021:    (void)mg_sleep(10);",
          "16022:   }",
          "16024:   mg_join_thread(mt);",
          "16025:   free_context(ctx);",
          "16028:   (void)WSACleanup();",
          "16030:  }",
          "16033:  static void get_system_name(char **sysName)",
          "16034:  {",
          "16040:   char name[128];",
          "16041:   DWORD dwVersion = 0;",
          "16042:   DWORD dwMajorVersion = 0;",
          "16043:   DWORD dwMinorVersion = 0;",
          "16044:   DWORD dwBuild = 0;",
          "16045:   BOOL wowRet, isWoW = FALSE;",
          "16052:   dwVersion = GetVersion();",
          "16057:   dwMajorVersion = (DWORD)(LOBYTE(LOWORD(dwVersion)));",
          "16058:   dwMinorVersion = (DWORD)(HIBYTE(LOWORD(dwVersion)));",
          "16059:   dwBuild = ((dwVersion < 0x80000000) ? (DWORD)(HIWORD(dwVersion)) : 0);",
          "16060:   (void)dwBuild;",
          "16062:   wowRet = IsWow64Process(GetCurrentProcess(), &isWoW);",
          "16064:   sprintf(name,",
          "16065:           \"Windows %u.%u%s\",",
          "16066:           (unsigned)dwMajorVersion,",
          "16067:           (unsigned)dwMinorVersion,",
          "16068:           (wowRet ? (isWoW ? \" (WoW64)\" : \"\") : \" (?)\"));",
          "",
          "[Added Lines]",
          "15942: static void",
          "15943: free_context(struct mg_context *ctx)",
          "15944: {",
          "15945:  int i;",
          "15946:  struct mg_handler_info *tmp_rh;",
          "15948:  if (ctx == NULL) {",
          "15949:   return;",
          "15950:  }",
          "15952:  if (ctx->callbacks.exit_context) {",
          "15953:   ctx->callbacks.exit_context(ctx);",
          "15954:  }",
          "15959:  (void)pthread_mutex_destroy(&ctx->thread_mutex);",
          "15961:  mg_free(ctx->client_socks);",
          "15962:  for (i = 0; (unsigned)i < ctx->cfg_worker_threads; i++) {",
          "15963:   event_destroy(ctx->client_wait_events[i]);",
          "15964:  }",
          "15965:  mg_free(ctx->client_wait_events);",
          "15972:  (void)pthread_mutex_destroy(&ctx->nonce_mutex);",
          "15975:  timers_exit(ctx);",
          "15979:  for (i = 0; i < NUM_OPTIONS; i++) {",
          "15980:   if (ctx->config[i] != NULL) {",
          "15984:    mg_free(ctx->config[i]);",
          "15986:  }",
          "15989:  while (ctx->handlers) {",
          "15990:   tmp_rh = ctx->handlers;",
          "15991:   ctx->handlers = tmp_rh->next;",
          "15992:   mg_free(tmp_rh->uri);",
          "15993:   mg_free(tmp_rh);",
          "15994:  }",
          "15998:  if (ctx->ssl_ctx != NULL) {",
          "15999:   SSL_CTX_free(ctx->ssl_ctx);",
          "16000:  }",
          "16004:  if (ctx->worker_threadids != NULL) {",
          "16005:   mg_free(ctx->worker_threadids);",
          "16006:  }",
          "16009:  if (ctx->worker_connections != NULL) {",
          "16010:   mg_free(ctx->worker_connections);",
          "16011:  }",
          "16014:  mg_free(ctx->systemName);",
          "16017:  mg_free(ctx);",
          "16018: }",
          "16021: void",
          "16022: mg_stop(struct mg_context *ctx)",
          "16023: {",
          "16024:  pthread_t mt;",
          "16025:  if (!ctx) {",
          "16026:   return;",
          "16027:  }",
          "16031:  mt = ctx->masterthreadid;",
          "16032:  if (mt == 0) {",
          "16033:   return;",
          "16034:  }",
          "16036:  ctx->masterthreadid = 0;",
          "16039:  ctx->stop_flag = 1;",
          "16042:  while (ctx->stop_flag != 2) {",
          "16043:   (void)mg_sleep(10);",
          "16044:  }",
          "16046:  mg_join_thread(mt);",
          "16047:  free_context(ctx);",
          "16050:  (void)WSACleanup();",
          "16052: }",
          "16055: static void",
          "16056: get_system_name(char **sysName)",
          "16057: {",
          "16063:  char name[128];",
          "16064:  DWORD dwVersion = 0;",
          "16065:  DWORD dwMajorVersion = 0;",
          "16066:  DWORD dwMinorVersion = 0;",
          "16067:  DWORD dwBuild = 0;",
          "16068:  BOOL wowRet, isWoW = FALSE;",
          "16075:  dwVersion = GetVersion();",
          "16080:  dwMajorVersion = (DWORD)(LOBYTE(LOWORD(dwVersion)));",
          "16081:  dwMinorVersion = (DWORD)(HIBYTE(LOWORD(dwVersion)));",
          "16082:  dwBuild = ((dwVersion < 0x80000000) ? (DWORD)(HIWORD(dwVersion)) : 0);",
          "16083:  (void)dwBuild;",
          "16085:  wowRet = IsWow64Process(GetCurrentProcess(), &isWoW);",
          "16087:  sprintf(name,",
          "16088:          \"Windows %u.%u%s\",",
          "16089:          (unsigned)dwMajorVersion,",
          "16090:          (unsigned)dwMinorVersion,",
          "16091:          (wowRet ? (isWoW ? \" (WoW64)\" : \"\") : \" (?)\"));",
          "",
          "---------------",
          "--- Hunk 65 ---",
          "[Context before]",
          "16078:  uname(&name);",
          "16080: #endif",
          "16097: #if defined(_WIN32) && !defined(__SYMBIAN32__)",
          "16119: #if defined(_WIN32) && !defined(__SYMBIAN32__)",
          "16121: #endif",
          "16125: #if !defined(ALTERNATIVE_QUEUE)",
          "16147: #if defined(USE_LUA) && defined(USE_WEBSOCKET)",
          "16149: #endif",
          "16183:    free_context(ctx);",
          "16184:    pthread_setspecific(sTlsKey, NULL);",
          "16185:    return NULL;",
          "16193:    free_context(ctx);",
          "16194:    pthread_setspecific(sTlsKey, NULL);",
          "16195:    return NULL;",
          "16196:   }",
          "16203:   }",
          "16205: #if defined(NO_FILES)",
          "16212: #endif",
          "16216: #if defined(USE_LUA)",
          "16231:   }",
          "16232: #endif",
          "16237: #if !defined(NO_SSL)",
          "16239: #endif",
          "16241: #if !defined(_WIN32)",
          "16243: #endif",
          "16250: #if !defined(_WIN32) && !defined(__SYMBIAN32__)",
          "16280: #if defined(ALTERNATIVE_QUEUE)",
          "16298:    mg_free(ctx->client_socks);",
          "16299:    mg_free(ctx->worker_threadids);",
          "16300:    free_context(ctx);",
          "16301:    pthread_setspecific(sTlsKey, NULL);",
          "16302:    return NULL;",
          "16303:   }",
          "16320: #endif",
          "16323: #if defined(USE_TIMERS)",
          "16330: #endif",
          "16375:    }",
          "16380:  }",
          "16390: #if !defined(NO_FILES)",
          "16392: #endif",
          "16393: #if !defined(NO_SSL)",
          "16395: #endif",
          "16396: #if !defined(NO_CGI)",
          "16398: #endif",
          "16399: #if defined(USE_IPV6)",
          "16401: #endif",
          "16402: #if defined(USE_WEBSOCKET)",
          "16404: #endif",
          "16405: #if defined(USE_LUA)",
          "16407: #endif",
          "16408: #if defined(USE_DUKTAPE)",
          "16410: #endif",
          "16411: #if !defined(NO_CACHING)",
          "16413: #endif",
          "16414: #if defined(USE_SERVER_STATS)",
          "16416: #endif",
          "16420: #if defined(MG_LEGACY_INTERFACE)",
          "16422: #endif",
          "16423: #if defined(MEMORY_DEBUGGING)",
          "16425: #endif",
          "16426: #if defined(USE_TIMERS)",
          "16428: #endif",
          "16429: #if !defined(NO_NONCE_CHECK)",
          "16431: #endif",
          "16432: #if !defined(NO_POPEN)",
          "16434: #endif",
          "16447: #if defined(_WIN32)",
          "16449: #else",
          "16450:  const char *eol = \"\\n\";",
          "16451: #endif",
          "16474:   }",
          "16478: #if defined(_WIN32)",
          "16479: #if !defined(__SYMBIAN32__)",
          "16487: #ifdef _MSC_VER",
          "16488: #pragma warning(push)",
          "16490: #pragma warning(disable : 4996)",
          "16491: #endif",
          "16493: #ifdef _MSC_VER",
          "16494: #pragma warning(pop)",
          "16495: #endif",
          "16527: #else",
          "16528:   mg_snprintf(NULL, NULL, block, sizeof(block), \"%s - Symbian%s\", eol);",
          "",
          "[Removed Lines]",
          "16081:  }",
          "16084:  struct mg_context *mg_start(const struct mg_callbacks *callbacks,",
          "16085:                              void *user_data,",
          "16086:                              const char **options)",
          "16087:  {",
          "16088:   struct mg_context *ctx;",
          "16089:   const char *name, *value, *default_value;",
          "16090:   int idx, ok, workerthreadcount;",
          "16091:   unsigned int i;",
          "16092:   int itmp;",
          "16093:   void (*exit_callback)(const struct mg_context *ctx) = 0;",
          "16095:   struct mg_workerTLS tls;",
          "16098:   WSADATA data;",
          "16099:   WSAStartup(MAKEWORD(2, 2), &data);",
          "16103:   if ((ctx = (struct mg_context *)mg_calloc(1, sizeof(*ctx))) == NULL) {",
          "16104:    return NULL;",
          "16105:   }",
          "16108:   ctx->auth_nonce_mask =",
          "16109:       (uint64_t)get_random() ^ (uint64_t)(ptrdiff_t)(options);",
          "16111:   if (mg_init_library_called == 0) {",
          "16114:    mg_init_library(0);",
          "16115:   }",
          "16117:   tls.is_master = -1;",
          "16118:   tls.thread_idx = (unsigned)mg_atomic_inc(&thread_idx_max);",
          "16120:   tls.pthread_cond_helper_mutex = NULL;",
          "16122:   pthread_setspecific(sTlsKey, &tls);",
          "16124:   ok = 0 == pthread_mutex_init(&ctx->thread_mutex, &pthread_mutex_attr);",
          "16126:   ok &= 0 == pthread_cond_init(&ctx->sq_empty, NULL);",
          "16127:   ok &= 0 == pthread_cond_init(&ctx->sq_full, NULL);",
          "16128: #endif",
          "16129:   ok &= 0 == pthread_mutex_init(&ctx->nonce_mutex, &pthread_mutex_attr);",
          "16130:   if (!ok) {",
          "16133:    mg_cry(fc(ctx), \"Cannot initialize thread synchronization objects\");",
          "16134:    mg_free(ctx);",
          "16135:    pthread_setspecific(sTlsKey, NULL);",
          "16136:    return NULL;",
          "16137:   }",
          "16139:   if (callbacks) {",
          "16140:    ctx->callbacks = *callbacks;",
          "16141:    exit_callback = callbacks->exit_context;",
          "16142:    ctx->callbacks.exit_context = 0;",
          "16143:   }",
          "16144:   ctx->user_data = user_data;",
          "16145:   ctx->handlers = NULL;",
          "16148:   ctx->shared_lua_websockets = 0;",
          "16151:   while (options && (name = *options++) != NULL) {",
          "16152:    if ((idx = get_option_index(name)) == -1) {",
          "16153:     mg_cry(fc(ctx), \"Invalid option: %s\", name);",
          "16154:     free_context(ctx);",
          "16155:     pthread_setspecific(sTlsKey, NULL);",
          "16156:     return NULL;",
          "16157:    } else if ((value = *options++) == NULL) {",
          "16158:     mg_cry(fc(ctx), \"%s: option value cannot be NULL\", name);",
          "16159:     free_context(ctx);",
          "16160:     pthread_setspecific(sTlsKey, NULL);",
          "16161:     return NULL;",
          "16162:    }",
          "16163:    if (ctx->config[idx] != NULL) {",
          "16164:     mg_cry(fc(ctx), \"warning: %s: duplicate option\", name);",
          "16165:     mg_free(ctx->config[idx]);",
          "16166:    }",
          "16167:    ctx->config[idx] = mg_strdup(value);",
          "16168:    DEBUG_TRACE(\"[%s] -> [%s]\", name, value);",
          "16169:   }",
          "16172:   for (i = 0; config_options[i].name != NULL; i++) {",
          "16173:    default_value = config_options[i].default_value;",
          "16174:    if ((ctx->config[i] == NULL) && (default_value != NULL)) {",
          "16175:     ctx->config[i] = mg_strdup(default_value);",
          "16176:    }",
          "16177:   }",
          "16179:   itmp = atoi(ctx->config[MAX_REQUEST_SIZE]);",
          "16181:   if (itmp < 1024) {",
          "16182:    mg_cry(fc(ctx), \"max_request_size too small\");",
          "16186:   }",
          "16187:   ctx->max_request_size = (unsigned)itmp;",
          "16189:   workerthreadcount = atoi(ctx->config[NUM_THREADS]);",
          "16191:   if (workerthreadcount > MAX_WORKER_THREADS) {",
          "16192:    mg_cry(fc(ctx), \"Too many worker threads\");",
          "16198:   if (workerthreadcount <= 0) {",
          "16199:    mg_cry(fc(ctx), \"Invalid number of worker threads\");",
          "16200:    free_context(ctx);",
          "16201:    pthread_setspecific(sTlsKey, NULL);",
          "16202:    return NULL;",
          "16206:   if (ctx->config[DOCUMENT_ROOT] != NULL) {",
          "16207:    mg_cry(fc(ctx), \"%s\", \"Document root must not be set\");",
          "16208:    free_context(ctx);",
          "16209:    pthread_setspecific(sTlsKey, NULL);",
          "16210:    return NULL;",
          "16211:   }",
          "16214:   get_system_name(&ctx->systemName);",
          "16218:   if (ctx->config[LUA_BACKGROUND_SCRIPT] != NULL) {",
          "16219:    char ebuf[256];",
          "16220:    void *state = (void *)mg_prepare_lua_context_script(",
          "16221:        ctx->config[LUA_BACKGROUND_SCRIPT], ctx, ebuf, sizeof(ebuf));",
          "16222:    if (!state) {",
          "16223:     mg_cry(fc(ctx), \"lua_background_script error: %s\", ebuf);",
          "16224:     free_context(ctx);",
          "16225:     pthread_setspecific(sTlsKey, NULL);",
          "16226:     return NULL;",
          "16227:    }",
          "16228:    ctx->lua_background_state = state;",
          "16229:   } else {",
          "16230:    ctx->lua_background_state = 0;",
          "16236:   if (!set_gpass_option(ctx) ||",
          "16238:       !set_ssl_option(ctx) ||",
          "16240:       !set_ports_option(ctx) ||",
          "16242:       !set_uid_option(ctx) ||",
          "16244:       !set_acl_option(ctx)) {",
          "16245:    free_context(ctx);",
          "16246:    pthread_setspecific(sTlsKey, NULL);",
          "16247:    return NULL;",
          "16248:   }",
          "16253:   (void)signal(SIGPIPE, SIG_IGN);",
          "16256:   ctx->cfg_worker_threads = ((unsigned int)(workerthreadcount));",
          "16257:   ctx->worker_threadids =",
          "16258:       (pthread_t *)mg_calloc_ctx(ctx->cfg_worker_threads,",
          "16259:                                  sizeof(pthread_t),",
          "16260:                                  ctx);",
          "16261:   if (ctx->worker_threadids == NULL) {",
          "16262:    mg_cry(fc(ctx), \"Not enough memory for worker thread ID array\");",
          "16263:    free_context(ctx);",
          "16264:    pthread_setspecific(sTlsKey, NULL);",
          "16265:    return NULL;",
          "16266:   }",
          "16267:   ctx->worker_connections =",
          "16268:       (struct mg_connection *)mg_calloc_ctx(ctx->cfg_worker_threads,",
          "16269:                                             sizeof(struct mg_connection),",
          "16270:                                             ctx);",
          "16271:   if (ctx->worker_connections == NULL) {",
          "16272:    mg_cry(fc(ctx),",
          "16273:           \"Not enough memory for worker thread connection array\");",
          "16274:    free_context(ctx);",
          "16275:    pthread_setspecific(sTlsKey, NULL);",
          "16276:    return NULL;",
          "16277:   }",
          "16281:   ctx->client_wait_events =",
          "16282:       mg_calloc_ctx(sizeof(ctx->client_wait_events[0]),",
          "16283:                     ctx->cfg_worker_threads,",
          "16284:                     ctx);",
          "16285:   if (ctx->client_wait_events == NULL) {",
          "16286:    mg_cry(fc(ctx), \"Not enough memory for worker event array\");",
          "16287:    mg_free(ctx->worker_threadids);",
          "16288:    free_context(ctx);",
          "16289:    pthread_setspecific(sTlsKey, NULL);",
          "16290:    return NULL;",
          "16291:   }",
          "16293:   ctx->client_socks = mg_calloc_ctx(sizeof(ctx->client_socks[0]),",
          "16294:                                     ctx->cfg_worker_threads,",
          "16295:                                     ctx);",
          "16296:   if (ctx->client_wait_events == NULL) {",
          "16297:    mg_cry(fc(ctx), \"Not enough memory for worker socket array\");",
          "16305:   for (i = 0; (unsigned)i < ctx->cfg_worker_threads; i++) {",
          "16306:    ctx->client_wait_events[i] = event_create();",
          "16307:    if (ctx->client_wait_events[i] == 0) {",
          "16308:     mg_cry(fc(ctx), \"Error creating worker event %i\", i);",
          "16309:     while (i > 0) {",
          "16310:      i--;",
          "16311:      event_destroy(ctx->client_wait_events[i]);",
          "16312:     }",
          "16313:     mg_free(ctx->client_socks);",
          "16314:     mg_free(ctx->worker_threadids);",
          "16315:     free_context(ctx);",
          "16316:     pthread_setspecific(sTlsKey, NULL);",
          "16317:     return NULL;",
          "16318:    }",
          "16319:   }",
          "16324:   if (timers_init(ctx) != 0) {",
          "16325:    mg_cry(fc(ctx), \"Error creating timers\");",
          "16326:    free_context(ctx);",
          "16327:    pthread_setspecific(sTlsKey, NULL);",
          "16328:    return NULL;",
          "16329:   }",
          "16333:   if (ctx->callbacks.init_context) {",
          "16334:    ctx->callbacks.init_context(ctx);",
          "16335:   }",
          "16336:   ctx->callbacks.exit_context = exit_callback;",
          "16340:   mg_start_thread_with_id(master_thread, ctx, &ctx->masterthreadid);",
          "16343:   for (i = 0; i < ctx->cfg_worker_threads; i++) {",
          "16344:    struct worker_thread_args *wta = (struct worker_thread_args *)",
          "16345:        mg_malloc_ctx(sizeof(struct worker_thread_args), ctx);",
          "16346:    if (wta) {",
          "16347:     wta->ctx = ctx;",
          "16348:     wta->index = (int)i;",
          "16349:    }",
          "16351:    if ((wta == NULL)",
          "16352:        || (mg_start_thread_with_id(worker_thread,",
          "16353:                                    wta,",
          "16354:                                    &ctx->worker_threadids[i]) != 0)) {",
          "16357:     if (wta != NULL) {",
          "16358:      mg_free(wta);",
          "16359:     }",
          "16361:     if (i > 0) {",
          "16362:      mg_cry(fc(ctx),",
          "16363:             \"Cannot start worker thread %i: error %ld\",",
          "16364:             i + 1,",
          "16365:             (long)ERRNO);",
          "16366:     } else {",
          "16367:      mg_cry(fc(ctx),",
          "16368:             \"Cannot create threads: error %ld\",",
          "16369:             (long)ERRNO);",
          "16370:      free_context(ctx);",
          "16371:      pthread_setspecific(sTlsKey, NULL);",
          "16372:      return NULL;",
          "16373:     }",
          "16374:     break;",
          "16376:   }",
          "16378:   pthread_setspecific(sTlsKey, NULL);",
          "16379:   return ctx;",
          "16384:  unsigned mg_check_feature(unsigned feature)",
          "16385:  {",
          "16386:   static const unsigned feature_set = 0",
          "16391:                                       | 0x0001u",
          "16394:                                       | 0x0002u",
          "16397:                                       | 0x0004u",
          "16400:                                       | 0x0008u",
          "16403:                                       | 0x0010u",
          "16406:                                       | 0x0020u",
          "16409:                                       | 0x0040u",
          "16412:                                       | 0x0080u",
          "16415:                                       | 0x0100u",
          "16421:                                       | 0x8000u",
          "16424:                                       | 0x0100u",
          "16427:                                       | 0x0200u",
          "16430:                                       | 0x0400u",
          "16433:                                       | 0x0800u",
          "16435:       ;",
          "16436:   return (feature & feature_set);",
          "16437:  }",
          "16442:  static int mg_get_system_info_impl(char *buffer, int buflen)",
          "16443:  {",
          "16444:   char block[256];",
          "16445:   int system_info_length = 0;",
          "16448:   const char *eol = \"\\r\\n\";",
          "16453:   if (buffer == NULL) {",
          "16457:    buflen = 0;",
          "16458:   }",
          "16461:   {",
          "16462:    const char *version = mg_version();",
          "16463:    mg_snprintf(NULL,",
          "16464:                NULL,",
          "16465:                block,",
          "16466:                sizeof(block),",
          "16467:                \"Server Version: %s%s\",",
          "16468:                version,",
          "16469:                eol);",
          "16470:    system_info_length += (int)strlen(block);",
          "16471:    if (system_info_length < buflen) {",
          "16472:     strcat(buffer, block);",
          "16473:    }",
          "16477:   {",
          "16480:    DWORD dwVersion = 0;",
          "16481:    DWORD dwMajorVersion = 0;",
          "16482:    DWORD dwMinorVersion = 0;",
          "16483:    SYSTEM_INFO si;",
          "16485:    GetSystemInfo(&si);",
          "16492:    dwVersion = GetVersion();",
          "16497:    dwMajorVersion = (DWORD)(LOBYTE(LOWORD(dwVersion)));",
          "16498:    dwMinorVersion = (DWORD)(HIBYTE(LOWORD(dwVersion)));",
          "16500:    mg_snprintf(NULL,",
          "16501:                NULL,",
          "16502:                block,",
          "16503:                sizeof(block),",
          "16504:                \"Windows %u.%u%s\",",
          "16505:                (unsigned)dwMajorVersion,",
          "16506:                (unsigned)dwMinorVersion,",
          "16507:                eol);",
          "16508:    system_info_length += (int)strlen(block);",
          "16509:    if (system_info_length < buflen) {",
          "16510:     strcat(buffer, block);",
          "16511:    }",
          "16513:    mg_snprintf(NULL,",
          "16514:                NULL,",
          "16515:                block,",
          "16516:                sizeof(block),",
          "16517:                \"CPU: type %u, cores %u, mask %x%s\",",
          "16518:                (unsigned)si.wProcessorArchitecture,",
          "16519:                (unsigned)si.dwNumberOfProcessors,",
          "16520:                (unsigned)si.dwActiveProcessorMask,",
          "16521:                eol);",
          "16522:    system_info_length += (int)strlen(block);",
          "16523:    if (system_info_length < buflen) {",
          "16524:     strcat(buffer, block);",
          "16525:    }",
          "",
          "[Added Lines]",
          "16104: }",
          "16107: struct mg_context *",
          "16108: mg_start(const struct mg_callbacks *callbacks,",
          "16109:          void *user_data,",
          "16110:          const char **options)",
          "16111: {",
          "16112:  struct mg_context *ctx;",
          "16113:  const char *name, *value, *default_value;",
          "16114:  int idx, ok, workerthreadcount;",
          "16115:  unsigned int i;",
          "16116:  int itmp;",
          "16117:  void (*exit_callback)(const struct mg_context *ctx) = 0;",
          "16119:  struct mg_workerTLS tls;",
          "16122:  WSADATA data;",
          "16123:  WSAStartup(MAKEWORD(2, 2), &data);",
          "16127:  if ((ctx = (struct mg_context *)mg_calloc(1, sizeof(*ctx))) == NULL) {",
          "16128:   return NULL;",
          "16129:  }",
          "16132:  ctx->auth_nonce_mask =",
          "16133:      (uint64_t)get_random() ^ (uint64_t)(ptrdiff_t)(options);",
          "16135:  if (mg_init_library_called == 0) {",
          "16138:   mg_init_library(0);",
          "16139:  }",
          "16141:  tls.is_master = -1;",
          "16142:  tls.thread_idx = (unsigned)mg_atomic_inc(&thread_idx_max);",
          "16144:  tls.pthread_cond_helper_mutex = NULL;",
          "16146:  pthread_setspecific(sTlsKey, &tls);",
          "16148:  ok = 0 == pthread_mutex_init(&ctx->thread_mutex, &pthread_mutex_attr);",
          "16150:  ok &= 0 == pthread_cond_init(&ctx->sq_empty, NULL);",
          "16151:  ok &= 0 == pthread_cond_init(&ctx->sq_full, NULL);",
          "16152: #endif",
          "16153:  ok &= 0 == pthread_mutex_init(&ctx->nonce_mutex, &pthread_mutex_attr);",
          "16154:  if (!ok) {",
          "16157:   mg_cry(fc(ctx), \"Cannot initialize thread synchronization objects\");",
          "16158:   mg_free(ctx);",
          "16159:   pthread_setspecific(sTlsKey, NULL);",
          "16160:   return NULL;",
          "16161:  }",
          "16163:  if (callbacks) {",
          "16164:   ctx->callbacks = *callbacks;",
          "16165:   exit_callback = callbacks->exit_context;",
          "16166:   ctx->callbacks.exit_context = 0;",
          "16167:  }",
          "16168:  ctx->user_data = user_data;",
          "16169:  ctx->handlers = NULL;",
          "16172:  ctx->shared_lua_websockets = 0;",
          "16175:  while (options && (name = *options++) != NULL) {",
          "16176:   if ((idx = get_option_index(name)) == -1) {",
          "16177:    mg_cry(fc(ctx), \"Invalid option: %s\", name);",
          "16181:   } else if ((value = *options++) == NULL) {",
          "16182:    mg_cry(fc(ctx), \"%s: option value cannot be NULL\", name);",
          "16187:   if (ctx->config[idx] != NULL) {",
          "16188:    mg_cry(fc(ctx), \"warning: %s: duplicate option\", name);",
          "16189:    mg_free(ctx->config[idx]);",
          "16190:   }",
          "16191:   ctx->config[idx] = mg_strdup(value);",
          "16192:   DEBUG_TRACE(\"[%s] -> [%s]\", name, value);",
          "16193:  }",
          "16196:  for (i = 0; config_options[i].name != NULL; i++) {",
          "16197:   default_value = config_options[i].default_value;",
          "16198:   if ((ctx->config[i] == NULL) && (default_value != NULL)) {",
          "16199:    ctx->config[i] = mg_strdup(default_value);",
          "16201:  }",
          "16203:  itmp = atoi(ctx->config[MAX_REQUEST_SIZE]);",
          "16205:  if (itmp < 1024) {",
          "16206:   mg_cry(fc(ctx), \"max_request_size too small\");",
          "16207:   free_context(ctx);",
          "16208:   pthread_setspecific(sTlsKey, NULL);",
          "16209:   return NULL;",
          "16210:  }",
          "16211:  ctx->max_request_size = (unsigned)itmp;",
          "16213:  workerthreadcount = atoi(ctx->config[NUM_THREADS]);",
          "16215:  if (workerthreadcount > MAX_WORKER_THREADS) {",
          "16216:   mg_cry(fc(ctx), \"Too many worker threads\");",
          "16217:   free_context(ctx);",
          "16218:   pthread_setspecific(sTlsKey, NULL);",
          "16219:   return NULL;",
          "16220:  }",
          "16222:  if (workerthreadcount <= 0) {",
          "16223:   mg_cry(fc(ctx), \"Invalid number of worker threads\");",
          "16224:   free_context(ctx);",
          "16225:   pthread_setspecific(sTlsKey, NULL);",
          "16226:   return NULL;",
          "16227:  }",
          "16230:  if (ctx->config[DOCUMENT_ROOT] != NULL) {",
          "16231:   mg_cry(fc(ctx), \"%s\", \"Document root must not be set\");",
          "16232:   free_context(ctx);",
          "16233:   pthread_setspecific(sTlsKey, NULL);",
          "16234:   return NULL;",
          "16235:  }",
          "16238:  get_system_name(&ctx->systemName);",
          "16242:  if (ctx->config[LUA_BACKGROUND_SCRIPT] != NULL) {",
          "16243:   char ebuf[256];",
          "16244:   void *state = (void *)mg_prepare_lua_context_script(",
          "16245:       ctx->config[LUA_BACKGROUND_SCRIPT], ctx, ebuf, sizeof(ebuf));",
          "16246:   if (!state) {",
          "16247:    mg_cry(fc(ctx), \"lua_background_script error: %s\", ebuf);",
          "16248:    free_context(ctx);",
          "16249:    pthread_setspecific(sTlsKey, NULL);",
          "16250:    return NULL;",
          "16252:   ctx->lua_background_state = state;",
          "16253:  } else {",
          "16254:   ctx->lua_background_state = 0;",
          "16255:  }",
          "16260:  if (!set_gpass_option(ctx) ||",
          "16262:      !set_ssl_option(ctx) ||",
          "16264:      !set_ports_option(ctx) ||",
          "16266:      !set_uid_option(ctx) ||",
          "16268:      !set_acl_option(ctx)) {",
          "16269:   free_context(ctx);",
          "16270:   pthread_setspecific(sTlsKey, NULL);",
          "16271:   return NULL;",
          "16272:  }",
          "16277:  (void)signal(SIGPIPE, SIG_IGN);",
          "16280:  ctx->cfg_worker_threads = ((unsigned int)(workerthreadcount));",
          "16281:  ctx->worker_threadids = (pthread_t *)mg_calloc_ctx(ctx->cfg_worker_threads,",
          "16282:                                                     sizeof(pthread_t),",
          "16283:                                                     ctx);",
          "16284:  if (ctx->worker_threadids == NULL) {",
          "16285:   mg_cry(fc(ctx), \"Not enough memory for worker thread ID array\");",
          "16286:   free_context(ctx);",
          "16287:   pthread_setspecific(sTlsKey, NULL);",
          "16288:   return NULL;",
          "16289:  }",
          "16290:  ctx->worker_connections =",
          "16291:      (struct mg_connection *)mg_calloc_ctx(ctx->cfg_worker_threads,",
          "16292:                                            sizeof(struct mg_connection),",
          "16293:                                            ctx);",
          "16294:  if (ctx->worker_connections == NULL) {",
          "16295:   mg_cry(fc(ctx), \"Not enough memory for worker thread connection array\");",
          "16296:   free_context(ctx);",
          "16297:   pthread_setspecific(sTlsKey, NULL);",
          "16298:   return NULL;",
          "16299:  }",
          "16303:  ctx->client_wait_events = mg_calloc_ctx(sizeof(ctx->client_wait_events[0]),",
          "16304:                                          ctx->cfg_worker_threads,",
          "16305:                                          ctx);",
          "16306:  if (ctx->client_wait_events == NULL) {",
          "16307:   mg_cry(fc(ctx), \"Not enough memory for worker event array\");",
          "16308:   mg_free(ctx->worker_threadids);",
          "16309:   free_context(ctx);",
          "16310:   pthread_setspecific(sTlsKey, NULL);",
          "16311:   return NULL;",
          "16312:  }",
          "16314:  ctx->client_socks = mg_calloc_ctx(sizeof(ctx->client_socks[0]),",
          "16315:                                    ctx->cfg_worker_threads,",
          "16316:                                    ctx);",
          "16317:  if (ctx->client_wait_events == NULL) {",
          "16318:   mg_cry(fc(ctx), \"Not enough memory for worker socket array\");",
          "16319:   mg_free(ctx->client_socks);",
          "16320:   mg_free(ctx->worker_threadids);",
          "16321:   free_context(ctx);",
          "16322:   pthread_setspecific(sTlsKey, NULL);",
          "16323:   return NULL;",
          "16324:  }",
          "16326:  for (i = 0; (unsigned)i < ctx->cfg_worker_threads; i++) {",
          "16327:   ctx->client_wait_events[i] = event_create();",
          "16328:   if (ctx->client_wait_events[i] == 0) {",
          "16329:    mg_cry(fc(ctx), \"Error creating worker event %i\", i);",
          "16330:    while (i > 0) {",
          "16331:     i--;",
          "16332:     event_destroy(ctx->client_wait_events[i]);",
          "16333:    }",
          "16340:  }",
          "16345:  if (timers_init(ctx) != 0) {",
          "16346:   mg_cry(fc(ctx), \"Error creating timers\");",
          "16347:   free_context(ctx);",
          "16348:   pthread_setspecific(sTlsKey, NULL);",
          "16349:   return NULL;",
          "16350:  }",
          "16354:  if (ctx->callbacks.init_context) {",
          "16355:   ctx->callbacks.init_context(ctx);",
          "16356:  }",
          "16357:  ctx->callbacks.exit_context = exit_callback;",
          "16361:  mg_start_thread_with_id(master_thread, ctx, &ctx->masterthreadid);",
          "16364:  for (i = 0; i < ctx->cfg_worker_threads; i++) {",
          "16365:   struct worker_thread_args *wta = (struct worker_thread_args *)",
          "16366:       mg_malloc_ctx(sizeof(struct worker_thread_args), ctx);",
          "16367:   if (wta) {",
          "16368:    wta->ctx = ctx;",
          "16369:    wta->index = (int)i;",
          "16370:   }",
          "16372:   if ((wta == NULL)",
          "16373:       || (mg_start_thread_with_id(worker_thread,",
          "16374:                                   wta,",
          "16375:                                   &ctx->worker_threadids[i]) != 0)) {",
          "16378:    if (wta != NULL) {",
          "16379:     mg_free(wta);",
          "16382:    if (i > 0) {",
          "16383:     mg_cry(fc(ctx),",
          "16384:            \"Cannot start worker thread %i: error %ld\",",
          "16385:            i + 1,",
          "16386:            (long)ERRNO);",
          "16387:    } else {",
          "16388:     mg_cry(fc(ctx),",
          "16389:            \"Cannot create threads: error %ld\",",
          "16390:            (long)ERRNO);",
          "16391:     free_context(ctx);",
          "16392:     pthread_setspecific(sTlsKey, NULL);",
          "16393:     return NULL;",
          "16394:    }",
          "16395:    break;",
          "16396:   }",
          "16399:  pthread_setspecific(sTlsKey, NULL);",
          "16400:  return ctx;",
          "16401: }",
          "16405: unsigned",
          "16406: mg_check_feature(unsigned feature)",
          "16407: {",
          "16408:  static const unsigned feature_set = 0",
          "16413:                                      | 0x0001u",
          "16416:                                      | 0x0002u",
          "16419:                                      | 0x0004u",
          "16422:                                      | 0x0008u",
          "16425:                                      | 0x0010u",
          "16428:                                      | 0x0020u",
          "16431:                                      | 0x0040u",
          "16434:                                      | 0x0080u",
          "16437:                                      | 0x0100u",
          "16443:                                      | 0x8000u",
          "16446:                                      | 0x0100u",
          "16449:                                      | 0x0200u",
          "16452:                                      | 0x0400u",
          "16455:                                      | 0x0800u",
          "16457:      ;",
          "16458:  return (feature & feature_set);",
          "16459: }",
          "16464: static int",
          "16465: mg_get_system_info_impl(char *buffer, int buflen)",
          "16466: {",
          "16467:  char block[256];",
          "16468:  int system_info_length = 0;",
          "16471:  const char *eol = \"\\r\\n\";",
          "16476:  if (buffer == NULL) {",
          "16480:   buflen = 0;",
          "16481:  }",
          "16484:  {",
          "16485:   const char *version = mg_version();",
          "16486:   mg_snprintf(NULL,",
          "16487:               NULL,",
          "16488:               block,",
          "16489:               sizeof(block),",
          "16490:               \"Server Version: %s%s\",",
          "16491:               version,",
          "16492:               eol);",
          "16493:   system_info_length += (int)strlen(block);",
          "16494:   if (system_info_length < buflen) {",
          "16495:    strcat(buffer, block);",
          "16497:  }",
          "16500:  {",
          "16503:   DWORD dwVersion = 0;",
          "16504:   DWORD dwMajorVersion = 0;",
          "16505:   DWORD dwMinorVersion = 0;",
          "16506:   SYSTEM_INFO si;",
          "16508:   GetSystemInfo(&si);",
          "16515:   dwVersion = GetVersion();",
          "16520:   dwMajorVersion = (DWORD)(LOBYTE(LOWORD(dwVersion)));",
          "16521:   dwMinorVersion = (DWORD)(HIBYTE(LOWORD(dwVersion)));",
          "16523:   mg_snprintf(NULL,",
          "16524:               NULL,",
          "16525:               block,",
          "16526:               sizeof(block),",
          "16527:               \"Windows %u.%u%s\",",
          "16528:               (unsigned)dwMajorVersion,",
          "16529:               (unsigned)dwMinorVersion,",
          "16530:               eol);",
          "16531:   system_info_length += (int)strlen(block);",
          "16532:   if (system_info_length < buflen) {",
          "16533:    strcat(buffer, block);",
          "16534:   }",
          "16536:   mg_snprintf(NULL,",
          "16537:               NULL,",
          "16538:               block,",
          "16539:               sizeof(block),",
          "16540:               \"CPU: type %u, cores %u, mask %x%s\",",
          "16541:               (unsigned)si.wProcessorArchitecture,",
          "16542:               (unsigned)si.dwNumberOfProcessors,",
          "16543:               (unsigned)si.dwActiveProcessorMask,",
          "16544:               eol);",
          "16545:   system_info_length += (int)strlen(block);",
          "16546:   if (system_info_length < buflen) {",
          "16547:    strcat(buffer, block);",
          "16548:   }",
          "",
          "---------------",
          "--- Hunk 66 ---",
          "[Context before]",
          "16551:    strcat(buffer, block);",
          "16552:   }",
          "16553: #endif",
          "16579: #ifdef USE_LUA",
          "16592: #endif",
          "16593: #if defined(USE_DUKTAPE)",
          "16608:   }",
          "16618:   }",
          "16624: #if defined(_MSC_VER)",
          "16637: #elif defined(__MINGW64__)",
          "16638:   mg_snprintf(NULL,",
          "16639:               NULL,",
          "",
          "[Removed Lines]",
          "16554:   }",
          "16557:   {",
          "16558:    mg_snprintf(NULL,",
          "16559:                NULL,",
          "16560:                block,",
          "16561:                sizeof(block),",
          "16562:                \"Features: %X%s%s%s%s%s%s%s%s%s%s\",",
          "16563:                mg_check_feature(0xFFFFFFFFu),",
          "16564:                eol,",
          "16565:                mg_check_feature(1) ? \" Files\" : \"\",",
          "16566:                mg_check_feature(2) ? \" HTTPS\" : \"\",",
          "16567:                mg_check_feature(4) ? \" CGI\" : \"\",",
          "16568:                mg_check_feature(8) ? \" IPv6\" : \"\",",
          "16569:                mg_check_feature(16) ? \" WebSockets\" : \"\",",
          "16570:                mg_check_feature(32) ? \" Lua\" : \"\",",
          "16571:                mg_check_feature(64) ? \" JavaScript\" : \"\",",
          "16572:                mg_check_feature(128) ? \" Cache\" : \"\",",
          "16573:                eol);",
          "16574:    system_info_length += (int)strlen(block);",
          "16575:    if (system_info_length < buflen) {",
          "16576:     strcat(buffer, block);",
          "16577:    }",
          "16580:    mg_snprintf(NULL,",
          "16581:                NULL,",
          "16582:                block,",
          "16583:                sizeof(block),",
          "16584:                \"Lua Version: %u (%s)%s\",",
          "16585:                (unsigned)LUA_VERSION_NUM,",
          "16586:                LUA_RELEASE,",
          "16587:                eol);",
          "16588:    system_info_length += (int)strlen(block);",
          "16589:    if (system_info_length < buflen) {",
          "16590:     strcat(buffer, block);",
          "16591:    }",
          "16594:    mg_snprintf(NULL,",
          "16595:                NULL,",
          "16596:                block,",
          "16597:                sizeof(block),",
          "16598:                \"JavaScript: Duktape %u.%u.%u%s\",",
          "16599:                (unsigned)DUK_VERSION / 10000,",
          "16600:                ((unsigned)DUK_VERSION / 100) % 100,",
          "16601:                (unsigned)DUK_VERSION % 100,",
          "16602:                eol);",
          "16603:    system_info_length += (int)strlen(block);",
          "16604:    if (system_info_length < buflen) {",
          "16605:     strcat(buffer, block);",
          "16606:    }",
          "16607: #endif",
          "16611:   {",
          "16612:    mg_snprintf(",
          "16613:        NULL, NULL, block, sizeof(block), \"Build: %s%s\", __DATE__, eol);",
          "16614:    system_info_length += (int)strlen(block);",
          "16615:    if (system_info_length < buflen) {",
          "16616:     strcat(buffer, block);",
          "16617:    }",
          "16623:   {",
          "16625:    mg_snprintf(NULL,",
          "16626:                NULL,",
          "16627:                block,",
          "16628:                sizeof(block),",
          "16629:                \"MSC: %u (%u)%s\",",
          "16630:                (unsigned)_MSC_VER,",
          "16631:                (unsigned)_MSC_FULL_VER,",
          "16632:                eol);",
          "16633:    system_info_length += (int)strlen(block);",
          "16634:    if (system_info_length < buflen) {",
          "16635:     strcat(buffer, block);",
          "16636:    }",
          "",
          "[Added Lines]",
          "16577:  }",
          "16580:  {",
          "16581:   mg_snprintf(NULL,",
          "16582:               NULL,",
          "16583:               block,",
          "16584:               sizeof(block),",
          "16585:               \"Features: %X%s%s%s%s%s%s%s%s%s%s\",",
          "16586:               mg_check_feature(0xFFFFFFFFu),",
          "16587:               eol,",
          "16588:               mg_check_feature(1) ? \" Files\" : \"\",",
          "16589:               mg_check_feature(2) ? \" HTTPS\" : \"\",",
          "16590:               mg_check_feature(4) ? \" CGI\" : \"\",",
          "16591:               mg_check_feature(8) ? \" IPv6\" : \"\",",
          "16592:               mg_check_feature(16) ? \" WebSockets\" : \"\",",
          "16593:               mg_check_feature(32) ? \" Lua\" : \"\",",
          "16594:               mg_check_feature(64) ? \" JavaScript\" : \"\",",
          "16595:               mg_check_feature(128) ? \" Cache\" : \"\",",
          "16596:               eol);",
          "16597:   system_info_length += (int)strlen(block);",
          "16598:   if (system_info_length < buflen) {",
          "16599:    strcat(buffer, block);",
          "16600:   }",
          "16603:   mg_snprintf(NULL,",
          "16604:               NULL,",
          "16605:               block,",
          "16606:               sizeof(block),",
          "16607:               \"Lua Version: %u (%s)%s\",",
          "16608:               (unsigned)LUA_VERSION_NUM,",
          "16609:               LUA_RELEASE,",
          "16610:               eol);",
          "16611:   system_info_length += (int)strlen(block);",
          "16612:   if (system_info_length < buflen) {",
          "16613:    strcat(buffer, block);",
          "16614:   }",
          "16617:   mg_snprintf(NULL,",
          "16618:               NULL,",
          "16619:               block,",
          "16620:               sizeof(block),",
          "16621:               \"JavaScript: Duktape %u.%u.%u%s\",",
          "16622:               (unsigned)DUK_VERSION / 10000,",
          "16623:               ((unsigned)DUK_VERSION / 100) % 100,",
          "16624:               (unsigned)DUK_VERSION % 100,",
          "16625:               eol);",
          "16626:   system_info_length += (int)strlen(block);",
          "16627:   if (system_info_length < buflen) {",
          "16628:    strcat(buffer, block);",
          "16630: #endif",
          "16631:  }",
          "16634:  {",
          "16635:   mg_snprintf(",
          "16636:       NULL, NULL, block, sizeof(block), \"Build: %s%s\", __DATE__, eol);",
          "16637:   system_info_length += (int)strlen(block);",
          "16638:   if (system_info_length < buflen) {",
          "16639:    strcat(buffer, block);",
          "16641:  }",
          "16646:  {",
          "16648:   mg_snprintf(NULL,",
          "16649:               NULL,",
          "16650:               block,",
          "16651:               sizeof(block),",
          "16652:               \"MSC: %u (%u)%s\",",
          "16653:               (unsigned)_MSC_VER,",
          "16654:               (unsigned)_MSC_FULL_VER,",
          "16655:               eol);",
          "16656:   system_info_length += (int)strlen(block);",
          "16657:   if (system_info_length < buflen) {",
          "16658:    strcat(buffer, block);",
          "16659:   }",
          "",
          "---------------",
          "--- Hunk 67 ---",
          "[Context before]",
          "16744:    strcat(buffer, block);",
          "16745:   }",
          "16746: #endif",
          "16776:   }",
          "16779:  }",
          "16782: #if defined(USE_SERVER_STATS)",
          "16793: #if defined(_WIN32)",
          "16795: #else",
          "16796:  const char *eol = \"\\n\";",
          "16797: #endif",
          "16808:   context_info_length += (int)strlen(block);",
          "16810:    strcat(buffer, block);",
          "16811:   }",
          "16865:   }",
          "16885:   }",
          "16930:   }",
          "16933:  }",
          "16934: #endif",
          "16948:  }",
          "16957: #if defined(USE_SERVER_STATS)",
          "16965: #else",
          "16966:  (void)ctx;",
          "16967:  if ((buffer != NULL) && (buflen > 0)) {",
          "",
          "[Removed Lines]",
          "16747:   }",
          "16751:   {",
          "16752:    mg_snprintf(",
          "16753:        NULL,",
          "16754:        NULL,",
          "16755:        block,",
          "16756:        sizeof(block),",
          "16757:        \"Data model: int:%u/%u/%u/%u, float:%u/%u/%u, char:%u/%u, \"",
          "16758:        \"ptr:%u, size:%u, time:%u%s\",",
          "16759:        (unsigned)sizeof(short),",
          "16760:        (unsigned)sizeof(int),",
          "16761:        (unsigned)sizeof(long),",
          "16762:        (unsigned)sizeof(long long),",
          "16763:        (unsigned)sizeof(float),",
          "16764:        (unsigned)sizeof(double),",
          "16765:        (unsigned)sizeof(long double),",
          "16766:        (unsigned)sizeof(char),",
          "16767:        (unsigned)sizeof(wchar_t),",
          "16768:        (unsigned)sizeof(void *),",
          "16769:        (unsigned)sizeof(size_t),",
          "16770:        (unsigned)sizeof(time_t),",
          "16771:        eol);",
          "16772:    system_info_length += (int)strlen(block);",
          "16773:    if (system_info_length < buflen) {",
          "16774:     strcat(buffer, block);",
          "16775:    }",
          "16778:   return system_info_length;",
          "16785:  static int mg_get_context_info_impl(const struct mg_context *ctx,",
          "16786:                                      char *buffer,",
          "16787:                                      int buflen)",
          "16789:  {",
          "16790:   char block[256];",
          "16791:   int context_info_length = 0;",
          "16794:   const char *eol = \"\\r\\n\";",
          "16798:   struct mg_memory_stat *ms = get_memory_stat((struct mg_context *)ctx);",
          "16800:   const char *eoobj = \"}\";",
          "16801:   int reserved_len = (int)strlen(eoobj) + (int)strlen(eol);",
          "16803:   if ((buffer == NULL) || (buflen < 10)) {",
          "16804:    buflen = 0;",
          "16805:   }",
          "16807:   mg_snprintf(NULL, NULL, block, sizeof(block), \"{%s\", eol);",
          "16809:   if (context_info_length < buflen) {",
          "16814:   if (ms) {",
          "16815:    mg_snprintf(NULL,",
          "16816:                NULL,",
          "16817:                block,",
          "16818:                sizeof(block),",
          "16819:                \"\\\"memory\\\" : {%s\"",
          "16820:                \"\\\"blocks\\\" : %i,%s\"",
          "16821:                \"\\\"used\\\" : %\" INT64_FMT \",%s\"",
          "16822:                \"\\\"maxUsed\\\" : %\" INT64_FMT \"%s\"",
          "16823:                \"}%s%s\",",
          "16824:                eol,",
          "16825:                ms->blockCount,",
          "16826:                eol,",
          "16827:                ms->totalMemUsed,",
          "16828:                eol,",
          "16829:                ms->maxMemUsed,",
          "16830:                eol,",
          "16831:                (ctx ? \",\" : \"\"),",
          "16832:                eol);",
          "16834:    context_info_length += (int)strlen(block);",
          "16835:    if (context_info_length + reserved_len < buflen) {",
          "16836:     strcat(buffer, block);",
          "16837:    }",
          "16838:   }",
          "16842:   if (ctx) {",
          "16843:    mg_snprintf(NULL,",
          "16844:                NULL,",
          "16845:                block,",
          "16846:                sizeof(block),",
          "16847:                \"\\\"connections\\\" : {%s\"",
          "16848:                \"\\\"active\\\" : %i,%s\"",
          "16849:                \"\\\"maxActive\\\" : %i,%s\"",
          "16850:                \"\\\"total\\\" : %\" INT64_FMT \"%s\"",
          "16851:                \"},%s\",",
          "16852:                eol,",
          "16853:                ctx->active_connections,",
          "16854:                eol,",
          "16855:                ctx->max_connections,",
          "16856:                eol,",
          "16857:                ctx->total_connections,",
          "16858:                eol,",
          "16859:                eol);",
          "16861:    context_info_length += (int)strlen(block);",
          "16862:    if (context_info_length + reserved_len < buflen) {",
          "16863:     strcat(buffer, block);",
          "16864:    }",
          "16868:   if (ctx) {",
          "16869:    mg_snprintf(NULL,",
          "16870:                NULL,",
          "16871:                block,",
          "16872:                sizeof(block),",
          "16873:                \"\\\"requests\\\" : {%s\"",
          "16874:                \"\\\"total\\\" : %\" INT64_FMT \"%s\"",
          "16875:                \"},%s\",",
          "16876:                eol,",
          "16877:                ctx->total_requests,",
          "16878:                eol,",
          "16879:                eol);",
          "16881:    context_info_length += (int)strlen(block);",
          "16882:    if (context_info_length + reserved_len < buflen) {",
          "16883:     strcat(buffer, block);",
          "16884:    }",
          "16888:   if (ctx) {",
          "16889:    char start_time_str[64] = {0};",
          "16890:    char now_str[64] = {0};",
          "16891:    time_t start_time = ctx->start_time;",
          "16892:    time_t now = time(NULL);",
          "16894:    gmt_time_string(start_time_str,",
          "16895:                    sizeof(start_time_str) - 1,",
          "16896:                    &start_time);",
          "16897:    gmt_time_string(now_str, sizeof(now_str) - 1, &now);",
          "16899:    mg_snprintf(NULL,",
          "16900:                NULL,",
          "16901:                block,",
          "16902:                sizeof(block),",
          "16903:                \"\\\"time\\\" : {%s\"",
          "16904:                \"\\\"uptime\\\" : %.0f,%s\"",
          "16905:                \"\\\"start\\\" : \\\"%s\\\",%s\"",
          "16906:                \"\\\"now\\\" : \\\"%s\\\"%s\"",
          "16907:                \"}%s\",",
          "16908:                eol,",
          "16909:                difftime(now, start_time),",
          "16910:                eol,",
          "16911:                start_time_str,",
          "16912:                eol,",
          "16913:                now_str,",
          "16914:                eol,",
          "16915:                eol);",
          "16917:    context_info_length += (int)strlen(block);",
          "16918:    if (context_info_length + reserved_len < buflen) {",
          "16919:     strcat(buffer, block);",
          "16920:    }",
          "16921:   }",
          "16924:   if ((buflen > 0) && buffer && buffer[0]) {",
          "16925:    if (context_info_length < buflen) {",
          "16926:     strcat(buffer, eoobj);",
          "16927:     strcat(buffer, eol);",
          "16928:     context_info_length += reserved_len;",
          "16929:    }",
          "16932:   return context_info_length;",
          "16939:  int mg_get_system_info(char *buffer, int buflen)",
          "16940:  {",
          "16941:   if ((buffer == NULL) || (buflen < 1)) {",
          "16942:    return mg_get_system_info_impl(NULL, 0);",
          "16943:   } else {",
          "16945:    buffer[0] = 0;",
          "16946:    return mg_get_system_info_impl(buffer, buflen);",
          "16947:   }",
          "16953:  int mg_get_context_info(const struct mg_context *ctx,",
          "16954:                          char *buffer,",
          "16955:                          int buflen)",
          "16956:  {",
          "16958:   if ((buffer == NULL) || (buflen < 1)) {",
          "16959:    return mg_get_context_info_impl(ctx, NULL, 0);",
          "16960:   } else {",
          "16962:    buffer[0] = 0;",
          "16963:    return mg_get_context_info_impl(ctx, buffer, buflen);",
          "16964:   }",
          "",
          "[Added Lines]",
          "16770:  }",
          "16774:  {",
          "16775:   mg_snprintf(NULL,",
          "16776:               NULL,",
          "16777:               block,",
          "16778:               sizeof(block),",
          "16779:               \"Data model: int:%u/%u/%u/%u, float:%u/%u/%u, char:%u/%u, \"",
          "16780:               \"ptr:%u, size:%u, time:%u%s\",",
          "16781:               (unsigned)sizeof(short),",
          "16782:               (unsigned)sizeof(int),",
          "16783:               (unsigned)sizeof(long),",
          "16784:               (unsigned)sizeof(long long),",
          "16785:               (unsigned)sizeof(float),",
          "16786:               (unsigned)sizeof(double),",
          "16787:               (unsigned)sizeof(long double),",
          "16788:               (unsigned)sizeof(char),",
          "16789:               (unsigned)sizeof(wchar_t),",
          "16790:               (unsigned)sizeof(void *),",
          "16791:               (unsigned)sizeof(size_t),",
          "16792:               (unsigned)sizeof(time_t),",
          "16793:               eol);",
          "16794:   system_info_length += (int)strlen(block);",
          "16795:   if (system_info_length < buflen) {",
          "16796:    strcat(buffer, block);",
          "16800:  return system_info_length;",
          "16801: }",
          "16807: static int",
          "16808: mg_get_context_info_impl(const struct mg_context *ctx, char *buffer, int buflen)",
          "16810: {",
          "16811:  char block[256];",
          "16812:  int context_info_length = 0;",
          "16815:  const char *eol = \"\\r\\n\";",
          "16819:  struct mg_memory_stat *ms = get_memory_stat((struct mg_context *)ctx);",
          "16821:  const char *eoobj = \"}\";",
          "16822:  int reserved_len = (int)strlen(eoobj) + (int)strlen(eol);",
          "16824:  if ((buffer == NULL) || (buflen < 10)) {",
          "16825:   buflen = 0;",
          "16826:  }",
          "16828:  mg_snprintf(NULL, NULL, block, sizeof(block), \"{%s\", eol);",
          "16829:  context_info_length += (int)strlen(block);",
          "16830:  if (context_info_length < buflen) {",
          "16831:   strcat(buffer, block);",
          "16832:  }",
          "16835:  if (ms) {",
          "16836:   mg_snprintf(NULL,",
          "16837:               NULL,",
          "16838:               block,",
          "16839:               sizeof(block),",
          "16840:               \"\\\"memory\\\" : {%s\"",
          "16841:               \"\\\"blocks\\\" : %i,%s\"",
          "16842:               \"\\\"used\\\" : %\" INT64_FMT \",%s\"",
          "16843:               \"\\\"maxUsed\\\" : %\" INT64_FMT \"%s\"",
          "16844:               \"}%s%s\",",
          "16845:               eol,",
          "16846:               ms->blockCount,",
          "16847:               eol,",
          "16848:               ms->totalMemUsed,",
          "16849:               eol,",
          "16850:               ms->maxMemUsed,",
          "16851:               eol,",
          "16852:               (ctx ? \",\" : \"\"),",
          "16853:               eol);",
          "16856:   if (context_info_length + reserved_len < buflen) {",
          "16859:  }",
          "16863:  if (ctx) {",
          "16864:   mg_snprintf(NULL,",
          "16865:               NULL,",
          "16866:               block,",
          "16867:               sizeof(block),",
          "16868:               \"\\\"connections\\\" : {%s\"",
          "16869:               \"\\\"active\\\" : %i,%s\"",
          "16870:               \"\\\"maxActive\\\" : %i,%s\"",
          "16871:               \"\\\"total\\\" : %\" INT64_FMT \"%s\"",
          "16872:               \"},%s\",",
          "16873:               eol,",
          "16874:               ctx->active_connections,",
          "16875:               eol,",
          "16876:               ctx->max_connections,",
          "16877:               eol,",
          "16878:               ctx->total_connections,",
          "16879:               eol,",
          "16880:               eol);",
          "16882:   context_info_length += (int)strlen(block);",
          "16883:   if (context_info_length + reserved_len < buflen) {",
          "16884:    strcat(buffer, block);",
          "16886:  }",
          "16889:  if (ctx) {",
          "16890:   mg_snprintf(NULL,",
          "16891:               NULL,",
          "16892:               block,",
          "16893:               sizeof(block),",
          "16894:               \"\\\"requests\\\" : {%s\"",
          "16895:               \"\\\"total\\\" : %\" INT64_FMT \"%s\"",
          "16896:               \"},%s\",",
          "16897:               eol,",
          "16898:               ctx->total_requests,",
          "16899:               eol,",
          "16900:               eol);",
          "16902:   context_info_length += (int)strlen(block);",
          "16903:   if (context_info_length + reserved_len < buflen) {",
          "16904:    strcat(buffer, block);",
          "16906:  }",
          "16909:  if (ctx) {",
          "16910:   char start_time_str[64] = {0};",
          "16911:   char now_str[64] = {0};",
          "16912:   time_t start_time = ctx->start_time;",
          "16913:   time_t now = time(NULL);",
          "16915:   gmt_time_string(start_time_str,",
          "16916:                   sizeof(start_time_str) - 1,",
          "16917:                   &start_time);",
          "16918:   gmt_time_string(now_str, sizeof(now_str) - 1, &now);",
          "16920:   mg_snprintf(NULL,",
          "16921:               NULL,",
          "16922:               block,",
          "16923:               sizeof(block),",
          "16924:               \"\\\"time\\\" : {%s\"",
          "16925:               \"\\\"uptime\\\" : %.0f,%s\"",
          "16926:               \"\\\"start\\\" : \\\"%s\\\",%s\"",
          "16927:               \"\\\"now\\\" : \\\"%s\\\"%s\"",
          "16928:               \"}%s\",",
          "16929:               eol,",
          "16930:               difftime(now, start_time),",
          "16931:               eol,",
          "16932:               start_time_str,",
          "16933:               eol,",
          "16934:               now_str,",
          "16935:               eol,",
          "16936:               eol);",
          "16938:   context_info_length += (int)strlen(block);",
          "16939:   if (context_info_length + reserved_len < buflen) {",
          "16940:    strcat(buffer, block);",
          "16942:  }",
          "16945:  if ((buflen > 0) && buffer && buffer[0]) {",
          "16946:   if (context_info_length < buflen) {",
          "16947:    strcat(buffer, eoobj);",
          "16948:    strcat(buffer, eol);",
          "16949:    context_info_length += reserved_len;",
          "16950:   }",
          "16953:  return context_info_length;",
          "16954: }",
          "16960: int",
          "16961: mg_get_system_info(char *buffer, int buflen)",
          "16962: {",
          "16963:  if ((buffer == NULL) || (buflen < 1)) {",
          "16964:   return mg_get_system_info_impl(NULL, 0);",
          "16965:  } else {",
          "16967:   buffer[0] = 0;",
          "16968:   return mg_get_system_info_impl(buffer, buflen);",
          "16970: }",
          "16975: int",
          "16976: mg_get_context_info(const struct mg_context *ctx, char *buffer, int buflen)",
          "16977: {",
          "16979:  if ((buffer == NULL) || (buflen < 1)) {",
          "16980:   return mg_get_context_info_impl(ctx, NULL, 0);",
          "16981:  } else {",
          "16983:   buffer[0] = 0;",
          "16984:   return mg_get_context_info_impl(ctx, buffer, buflen);",
          "16985:  }",
          "",
          "---------------",
          "--- Hunk 68 ---",
          "[Context before]",
          "16969:  }",
          "16970:  return 0;",
          "16971: #endif",
          "16979: #if !defined(NO_SSL)",
          "16981: #endif",
          "16991:   }",
          "17002: #if defined(_WIN32) && !defined(__SYMBIAN32__)",
          "17005: #if !defined(_WIN32)",
          "17009: #endif",
          "17011: #if defined(USE_LUA)",
          "17013: #endif",
          "17017: #if !defined(NO_SSL)",
          "17027:    } else {",
          "17029:    }",
          "17030:   }",
          "17031: #endif",
          "17035: #if defined(_WIN32) && !defined(__SYMBIAN32__)",
          "17061: #if defined(_WIN32) && !defined(__SYMBIAN32__)",
          "17064: #if !defined(NO_SSL)",
          "17069: #endif",
          "17071: #if defined(_WIN32) && !defined(__SYMBIAN32__)",
          "17074: #if !defined(_WIN32)",
          "17076: #endif",
          "17080: #if defined(USE_LUA)",
          "17082: #endif",
          "17089:   mg_global_unlock();",
          "17090:   return 1;",
          "17091:  }",
          "",
          "[Removed Lines]",
          "16972:  }",
          "16977:  unsigned mg_init_library(unsigned features)",
          "16978:  {",
          "16980:   char ebuf[128];",
          "16983:   unsigned features_to_init = mg_check_feature(features & 0xFFu);",
          "16984:   unsigned features_inited = features_to_init;",
          "16986:   if (mg_init_library_called <= 0) {",
          "16988:    if (0 != pthread_mutex_init(&global_lock_mutex, NULL)) {",
          "16989:     return 0;",
          "16990:    }",
          "16993:   mg_global_lock();",
          "16995:   if (mg_init_library_called <= 0) {",
          "16996:    if (0 != pthread_key_create(&sTlsKey, tls_dtor)) {",
          "16999:     return 0;",
          "17000:    }",
          "17003:    InitializeCriticalSection(&global_log_file_lock);",
          "17006:    pthread_mutexattr_init(&pthread_mutex_attr);",
          "17007:    pthread_mutexattr_settype(&pthread_mutex_attr,",
          "17008:                              PTHREAD_MUTEX_RECURSIVE);",
          "17012:    lua_init_optional_libraries();",
          "17014:   }",
          "17018:   if (features_to_init & 2) {",
          "17019:    if (!mg_ssl_initialized) {",
          "17020:     if (initialize_ssl(ebuf, sizeof(ebuf))) {",
          "17021:      mg_ssl_initialized = 1;",
          "17022:     } else {",
          "17023:      (void)ebuf;",
          "17025:      features_inited &= ~(2u);",
          "17026:     }",
          "17034:   if (mg_init_library_called <= 0) {",
          "17036:    WSADATA data;",
          "17037:    WSAStartup(MAKEWORD(2, 2), &data);",
          "17039:    mg_init_library_called = 1;",
          "17040:   } else {",
          "17041:    mg_init_library_called++;",
          "17042:   }",
          "17044:   mg_global_unlock();",
          "17046:   return features_inited;",
          "17047:  }",
          "17051:  unsigned mg_exit_library(void)",
          "17052:  {",
          "17053:   if (mg_init_library_called <= 0) {",
          "17054:    return 0;",
          "17055:   }",
          "17057:   mg_global_lock();",
          "17059:   mg_init_library_called--;",
          "17060:   if (mg_init_library_called == 0) {",
          "17062:    (void)WSACleanup();",
          "17065:    if (mg_ssl_initialized) {",
          "17066:     uninitialize_ssl();",
          "17067:     mg_ssl_initialized = 0;",
          "17068:    }",
          "17072:    (void)DeleteCriticalSection(&global_log_file_lock);",
          "17075:    (void)pthread_mutexattr_destroy(&pthread_mutex_attr);",
          "17078:    (void)pthread_key_delete(sTlsKey);",
          "17081:    lua_exit_optional_libraries();",
          "17084:    mg_global_unlock();",
          "17085:    (void)pthread_mutex_destroy(&global_lock_mutex);",
          "17086:    return 1;",
          "17087:   }",
          "",
          "[Added Lines]",
          "16993: }",
          "16998: unsigned",
          "16999: mg_init_library(unsigned features)",
          "17000: {",
          "17002:  char ebuf[128];",
          "17005:  unsigned features_to_init = mg_check_feature(features & 0xFFu);",
          "17006:  unsigned features_inited = features_to_init;",
          "17008:  if (mg_init_library_called <= 0) {",
          "17010:   if (0 != pthread_mutex_init(&global_lock_mutex, NULL)) {",
          "17011:    return 0;",
          "17013:  }",
          "17015:  mg_global_lock();",
          "17017:  if (mg_init_library_called <= 0) {",
          "17018:   if (0 != pthread_key_create(&sTlsKey, tls_dtor)) {",
          "17021:    return 0;",
          "17022:   }",
          "17025:   InitializeCriticalSection(&global_log_file_lock);",
          "17028:   pthread_mutexattr_init(&pthread_mutex_attr);",
          "17029:   pthread_mutexattr_settype(&pthread_mutex_attr, PTHREAD_MUTEX_RECURSIVE);",
          "17033:   lua_init_optional_libraries();",
          "17035:  }",
          "17039:  if (features_to_init & 2) {",
          "17040:   if (!mg_ssl_initialized) {",
          "17041:    if (initialize_ssl(ebuf, sizeof(ebuf))) {",
          "17042:     mg_ssl_initialized = 1;",
          "17044:     (void)ebuf;",
          "17046:     features_inited &= ~(2u);",
          "17048:   } else {",
          "17051:  }",
          "17055:  if (mg_init_library_called <= 0) {",
          "17057:   WSADATA data;",
          "17058:   WSAStartup(MAKEWORD(2, 2), &data);",
          "17060:   mg_init_library_called = 1;",
          "17061:  } else {",
          "17062:   mg_init_library_called++;",
          "17063:  }",
          "17065:  mg_global_unlock();",
          "17067:  return features_inited;",
          "17068: }",
          "17072: unsigned",
          "17073: mg_exit_library(void)",
          "17074: {",
          "17075:  if (mg_init_library_called <= 0) {",
          "17076:   return 0;",
          "17077:  }",
          "17079:  mg_global_lock();",
          "17081:  mg_init_library_called--;",
          "17082:  if (mg_init_library_called == 0) {",
          "17084:   (void)WSACleanup();",
          "17087:   if (mg_ssl_initialized) {",
          "17088:    uninitialize_ssl();",
          "17089:    mg_ssl_initialized = 0;",
          "17090:   }",
          "17094:   (void)DeleteCriticalSection(&global_log_file_lock);",
          "17097:   (void)pthread_mutexattr_destroy(&pthread_mutex_attr);",
          "17100:   (void)pthread_key_delete(sTlsKey);",
          "17103:   lua_exit_optional_libraries();",
          "17107:   (void)pthread_mutex_destroy(&global_lock_mutex);",
          "17111:  mg_global_unlock();",
          "17112:  return 1;",
          "17113: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "a786eea649973e1c571b8052eae454254dafee8a",
      "candidate_info": {
        "commit_hash": "a786eea649973e1c571b8052eae454254dafee8a",
        "repo": "civetweb/civetweb",
        "commit_url": "https://github.com/civetweb/civetweb/commit/a786eea649973e1c571b8052eae454254dafee8a",
        "files": [
          "src/civetweb.c"
        ],
        "message": "Indent and comment clock_gettime replacement code for Windows",
        "before_after_code_files": [
          "src/civetweb.c||src/civetweb.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/civetweb.c||src/civetweb.c"
          ],
          "candidate": [
            "src/civetweb.c||src/civetweb.c"
          ]
        }
      },
      "candidate_diff": {
        "src/civetweb.c||src/civetweb.c": [
          "File: src/civetweb.c -> src/civetweb.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "489:     tp->tv_nsec = (long)(li.QuadPart % 10000000) * 100;",
          "490:     ok = TRUE;",
          "491:    }",
          "492:   }",
          "510: #endif",
          "524: #include \"file_ops.inl\"",
          "543: #if defined(_WIN32) && !defined(POLLIN)",
          "544: #ifndef HAVE_POLL",
          "550: #define POLLIN (0x0300)",
          "551: #endif",
          "552: #endif",
          "",
          "[Removed Lines]",
          "493:  } else if (clk_id == CLOCK_PROCESS) {",
          "494:   FILETIME t_create, t_exit, t_kernel, t_user;",
          "495:   if (GetProcessTimes(",
          "496:           GetCurrentProcess(), &t_create, &t_exit, &t_kernel, &t_user)) {",
          "497:    li.LowPart = t_user.dwLowDateTime;",
          "498:    li.HighPart = t_user.dwHighDateTime;",
          "499:    li2.LowPart = t_kernel.dwLowDateTime;",
          "500:    li2.HighPart = t_kernel.dwHighDateTime;",
          "501:    li.QuadPart += li2.QuadPart;",
          "502:    tp->tv_sec = (time_t)(li.QuadPart / 10000000);",
          "503:    tp->tv_nsec = (long)(li.QuadPart % 10000000) * 100;",
          "504:    ok = TRUE;",
          "505:   }",
          "506:  }",
          "508:  return ok ? 0 : -1;",
          "509: }",
          "515: static int pthread_mutex_lock(pthread_mutex_t *);",
          "516: static int pthread_mutex_unlock(pthread_mutex_t *);",
          "517: static void path_to_unicode(const struct mg_connection *conn,",
          "518:                             const char *path,",
          "519:                             wchar_t *wbuf,",
          "520:                             size_t wbuf_len);",
          "526: struct mg_file;",
          "528: static const char *",
          "529: mg_fgets(char *buf, size_t size, struct mg_file *filep, char **p);",
          "533: struct dirent {",
          "534:  char d_name[PATH_MAX];",
          "535: };",
          "537: typedef struct DIR {",
          "538:  HANDLE handle;",
          "539:  WIN32_FIND_DATAW info;",
          "540:  struct dirent result;",
          "541: } DIR;",
          "545: struct pollfd {",
          "546:  SOCKET fd;",
          "547:  short events;",
          "548:  short revents;",
          "549: };",
          "",
          "[Added Lines]",
          "505:   } else if (clk_id == CLOCK_PROCESS) {",
          "508:    FILETIME t_create, t_exit, t_kernel, t_user;",
          "509:    if (GetProcessTimes(GetCurrentProcess(),",
          "510:                        &t_create,",
          "511:                        &t_exit,",
          "512:                        &t_kernel,",
          "513:                        &t_user)) {",
          "514:     li.LowPart = t_user.dwLowDateTime;",
          "515:     li.HighPart = t_user.dwHighDateTime;",
          "516:     li2.LowPart = t_kernel.dwLowDateTime;",
          "517:     li2.HighPart = t_kernel.dwHighDateTime;",
          "518:     li.QuadPart += li2.QuadPart;",
          "519:     tp->tv_sec = (time_t)(li.QuadPart / 10000000);",
          "520:     tp->tv_nsec = (long)(li.QuadPart % 10000000) * 100;",
          "521:     ok = TRUE;",
          "522:    }",
          "525:   } else {",
          "533:   return ok ? 0 : -1;",
          "534:  }",
          "540:  static int pthread_mutex_lock(pthread_mutex_t *);",
          "541:  static int pthread_mutex_unlock(pthread_mutex_t *);",
          "542:  static void path_to_unicode(const struct mg_connection *conn,",
          "543:                              const char *path,",
          "544:                              wchar_t *wbuf,",
          "545:                              size_t wbuf_len);",
          "551:  struct mg_file;",
          "553:  static const char *mg_fgets(char *buf,",
          "554:                              size_t size,",
          "555:                              struct mg_file *filep,",
          "556:                              char **p);",
          "560:  struct dirent {",
          "561:   char d_name[PATH_MAX];",
          "562:  };",
          "564:  typedef struct DIR {",
          "565:   HANDLE handle;",
          "566:   WIN32_FIND_DATAW info;",
          "567:   struct dirent result;",
          "568:  } DIR;",
          "572:  struct pollfd {",
          "573:   SOCKET fd;",
          "574:   short events;",
          "575:   short revents;",
          "576:  };",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "649: #endif",
          "674:  }",
          "702: #if defined(__MINGW32__)",
          "704: #pragma GCC diagnostic pop",
          "705: #endif",
          "708: #else",
          "709: static pthread_mutexattr_t pthread_mutex_attr;",
          "",
          "[Removed Lines]",
          "652: static CRITICAL_SECTION global_log_file_lock;",
          "654: FUNCTION_MAY_BE_UNUSED",
          "655: static DWORD",
          "656: pthread_self(void)",
          "657: {",
          "658:  return GetCurrentThreadId();",
          "659: }",
          "662: FUNCTION_MAY_BE_UNUSED",
          "663: static int",
          "664: pthread_key_create(",
          "665:     pthread_key_t *key,",
          "667:     )",
          "668: {",
          "669:  (void)_ignored;",
          "671:  if ((key != 0)) {",
          "673:   return (*key != TLS_OUT_OF_INDEXES) ? 0 : -1;",
          "675:  return -2;",
          "676: }",
          "679: FUNCTION_MAY_BE_UNUSED",
          "680: static int",
          "681: pthread_key_delete(pthread_key_t key)",
          "682: {",
          "683:  return TlsFree(key) ? 0 : 1;",
          "684: }",
          "687: FUNCTION_MAY_BE_UNUSED",
          "688: static int",
          "689: pthread_setspecific(pthread_key_t key, void *value)",
          "690: {",
          "691:  return TlsSetValue(key, value) ? 0 : 1;",
          "692: }",
          "695: FUNCTION_MAY_BE_UNUSED",
          "696: static void *",
          "697: pthread_getspecific(pthread_key_t key)",
          "698: {",
          "699:  return TlsGetValue(key);",
          "700: }",
          "707: static struct pthread_mutex_undefined_struct *pthread_mutex_attr = NULL;",
          "",
          "[Added Lines]",
          "679:  static CRITICAL_SECTION global_log_file_lock;",
          "681:  FUNCTION_MAY_BE_UNUSED",
          "682:  static DWORD pthread_self(void)",
          "683:  {",
          "684:   return GetCurrentThreadId();",
          "685:  }",
          "688:  FUNCTION_MAY_BE_UNUSED",
          "689:  static int pthread_key_create(",
          "690:      pthread_key_t * key,",
          "692:      )",
          "693:  {",
          "694:   (void)_ignored;",
          "696:   if ((key != 0)) {",
          "698:    return (*key != TLS_OUT_OF_INDEXES) ? 0 : -1;",
          "699:   }",
          "700:   return -2;",
          "704:  FUNCTION_MAY_BE_UNUSED",
          "705:  static int pthread_key_delete(pthread_key_t key)",
          "706:  {",
          "707:   return TlsFree(key) ? 0 : 1;",
          "708:  }",
          "711:  FUNCTION_MAY_BE_UNUSED",
          "712:  static int pthread_setspecific(pthread_key_t key, void *value)",
          "713:  {",
          "714:   return TlsSetValue(key, value) ? 0 : 1;",
          "715:  }",
          "718:  FUNCTION_MAY_BE_UNUSED",
          "719:  static void *pthread_getspecific(pthread_key_t key)",
          "720:  {",
          "721:   return TlsGetValue(key);",
          "722:  }",
          "729:  static struct pthread_mutex_undefined_struct *pthread_mutex_attr = NULL;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "728: #endif",
          "745:  }",
          "823: #define _beginthreadex(psec, stack, func, prm, flags, ptid)                    \\",
          "824:  (uintptr_t) CreateThread(psec, stack, func, prm, flags, ptid)",
          "",
          "[Removed Lines]",
          "731: FUNCTION_MAY_BE_UNUSED",
          "732: static time_t",
          "733: time(time_t *ptime)",
          "734: {",
          "735:  time_t t;",
          "736:  SYSTEMTIME st;",
          "737:  FILETIME ft;",
          "739:  GetSystemTime(&st);",
          "740:  SystemTimeToFileTime(&st, &ft);",
          "741:  t = SYS2UNIX_TIME(ft.dwLowDateTime, ft.dwHighDateTime);",
          "743:  if (ptime != NULL) {",
          "747:  return t;",
          "748: }",
          "751: FUNCTION_MAY_BE_UNUSED",
          "752: static struct tm *",
          "753: localtime_s(const time_t *ptime, struct tm *ptm)",
          "754: {",
          "755:  int64_t t = ((int64_t)*ptime) * RATE_DIFF + EPOCH_DIFF;",
          "756:  FILETIME ft, lft;",
          "757:  SYSTEMTIME st;",
          "758:  TIME_ZONE_INFORMATION tzinfo;",
          "760:  if (ptm == NULL) {",
          "761:   return NULL;",
          "762:  }",
          "765:  FileTimeToLocalFileTime(&ft, &lft);",
          "766:  FileTimeToSystemTime(&lft, &st);",
          "767:  ptm->tm_year = st.wYear - 1900;",
          "768:  ptm->tm_mon = st.wMonth - 1;",
          "769:  ptm->tm_wday = st.wDayOfWeek;",
          "770:  ptm->tm_mday = st.wDay;",
          "771:  ptm->tm_hour = st.wHour;",
          "772:  ptm->tm_min = st.wMinute;",
          "773:  ptm->tm_sec = st.wSecond;",
          "775:  ptm->tm_isdst =",
          "776:      (GetTimeZoneInformation(&tzinfo) == TIME_ZONE_ID_DAYLIGHT) ? 1 : 0;",
          "778:  return ptm;",
          "779: }",
          "782: FUNCTION_MAY_BE_UNUSED",
          "783: static struct tm *",
          "784: gmtime_s(const time_t *ptime, struct tm *ptm)",
          "785: {",
          "787:  return localtime_s(ptime, ptm);",
          "788: }",
          "791: static int mg_atomic_inc(volatile int *addr);",
          "792: static struct tm tm_array[MAX_WORKER_THREADS];",
          "793: static int tm_index = 0;",
          "796: FUNCTION_MAY_BE_UNUSED",
          "797: static struct tm *",
          "798: localtime(const time_t *ptime)",
          "799: {",
          "800:  int i = mg_atomic_inc(&tm_index) % (sizeof(tm_array) / sizeof(tm_array[0]));",
          "801:  return localtime_s(ptime, tm_array + i);",
          "802: }",
          "805: FUNCTION_MAY_BE_UNUSED",
          "806: static struct tm *",
          "807: gmtime(const time_t *ptime)",
          "808: {",
          "809:  int i = mg_atomic_inc(&tm_index) % ARRAY_SIZE(tm_array);",
          "810:  return gmtime_s(ptime, tm_array + i);",
          "811: }",
          "814: FUNCTION_MAY_BE_UNUSED",
          "815: static size_t",
          "816: strftime(char *dst, size_t dst_size, const char *fmt, const struct tm *tm)",
          "817: {",
          "820:  return 0;",
          "821: }",
          "",
          "[Added Lines]",
          "753:  FUNCTION_MAY_BE_UNUSED",
          "754:  static time_t time(time_t * ptime)",
          "755:  {",
          "756:   time_t t;",
          "757:   SYSTEMTIME st;",
          "758:   FILETIME ft;",
          "760:   GetSystemTime(&st);",
          "761:   SystemTimeToFileTime(&st, &ft);",
          "762:   t = SYS2UNIX_TIME(ft.dwLowDateTime, ft.dwHighDateTime);",
          "764:   if (ptime != NULL) {",
          "766:   }",
          "768:   return t;",
          "772:  FUNCTION_MAY_BE_UNUSED",
          "773:  static struct tm *localtime_s(const time_t *ptime, struct tm *ptm)",
          "774:  {",
          "775:   int64_t t = ((int64_t)*ptime) * RATE_DIFF + EPOCH_DIFF;",
          "776:   FILETIME ft, lft;",
          "777:   SYSTEMTIME st;",
          "778:   TIME_ZONE_INFORMATION tzinfo;",
          "780:   if (ptm == NULL) {",
          "781:    return NULL;",
          "782:   }",
          "785:   FileTimeToLocalFileTime(&ft, &lft);",
          "786:   FileTimeToSystemTime(&lft, &st);",
          "787:   ptm->tm_year = st.wYear - 1900;",
          "788:   ptm->tm_mon = st.wMonth - 1;",
          "789:   ptm->tm_wday = st.wDayOfWeek;",
          "790:   ptm->tm_mday = st.wDay;",
          "791:   ptm->tm_hour = st.wHour;",
          "792:   ptm->tm_min = st.wMinute;",
          "793:   ptm->tm_sec = st.wSecond;",
          "795:   ptm->tm_isdst =",
          "796:       (GetTimeZoneInformation(&tzinfo) == TIME_ZONE_ID_DAYLIGHT) ? 1 : 0;",
          "798:   return ptm;",
          "799:  }",
          "802:  FUNCTION_MAY_BE_UNUSED",
          "803:  static struct tm *gmtime_s(const time_t *ptime, struct tm *ptm)",
          "804:  {",
          "806:   return localtime_s(ptime, ptm);",
          "807:  }",
          "810:  static int mg_atomic_inc(volatile int *addr);",
          "811:  static struct tm tm_array[MAX_WORKER_THREADS];",
          "812:  static int tm_index = 0;",
          "815:  FUNCTION_MAY_BE_UNUSED",
          "816:  static struct tm *localtime(const time_t *ptime)",
          "817:  {",
          "818:   int i =",
          "819:       mg_atomic_inc(&tm_index) % (sizeof(tm_array) / sizeof(tm_array[0]));",
          "820:   return localtime_s(ptime, tm_array + i);",
          "821:  }",
          "824:  FUNCTION_MAY_BE_UNUSED",
          "825:  static struct tm *gmtime(const time_t *ptime)",
          "826:  {",
          "827:   int i = mg_atomic_inc(&tm_index) % ARRAY_SIZE(tm_array);",
          "828:   return gmtime_s(ptime, tm_array + i);",
          "829:  }",
          "832:  FUNCTION_MAY_BE_UNUSED",
          "833:  static size_t strftime(char *dst,",
          "834:                         size_t dst_size,",
          "835:                         const char *fmt,",
          "836:                         const struct tm *tm)",
          "837:  {",
          "840:   return 0;",
          "841:  }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "826: #define remove(f) mg_remove(NULL, f)",
          "872:  }",
          "",
          "[Removed Lines]",
          "829: FUNCTION_MAY_BE_UNUSED",
          "830: static int",
          "831: rename(const char *a, const char *b)",
          "832: {",
          "833:  wchar_t wa[PATH_MAX];",
          "834:  wchar_t wb[PATH_MAX];",
          "835:  path_to_unicode(NULL, a, wa, ARRAY_SIZE(wa));",
          "836:  path_to_unicode(NULL, b, wb, ARRAY_SIZE(wb));",
          "838:  return MoveFileW(wa, wb) ? 0 : -1;",
          "839: }",
          "842: struct stat {",
          "843:  int64_t st_size;",
          "844:  time_t st_mtime;",
          "845: };",
          "848: FUNCTION_MAY_BE_UNUSED",
          "849: static int",
          "850: stat(const char *name, struct stat *st)",
          "851: {",
          "852:  wchar_t wbuf[PATH_MAX];",
          "853:  WIN32_FILE_ATTRIBUTE_DATA attr;",
          "854:  time_t creation_time, write_time;",
          "856:  path_to_unicode(NULL, name, wbuf, ARRAY_SIZE(wbuf));",
          "857:  memset(&attr, 0, sizeof(attr));",
          "859:  GetFileAttributesExW(wbuf, GetFileExInfoStandard, &attr);",
          "860:  st->st_size =",
          "861:      (((int64_t)attr.nFileSizeHigh) << 32) + (int64_t)attr.nFileSizeLow;",
          "863:  write_time = SYS2UNIX_TIME(attr.ftLastWriteTime.dwLowDateTime,",
          "864:                             attr.ftLastWriteTime.dwHighDateTime);",
          "865:  creation_time = SYS2UNIX_TIME(attr.ftCreationTime.dwLowDateTime,",
          "866:                                attr.ftCreationTime.dwHighDateTime);",
          "868:  if (creation_time > write_time) {",
          "869:   st->st_mtime = creation_time;",
          "870:  } else {",
          "871:   st->st_mtime = write_time;",
          "873:  return 0;",
          "874: }",
          "",
          "[Added Lines]",
          "849:  FUNCTION_MAY_BE_UNUSED",
          "850:  static int rename(const char *a, const char *b)",
          "851:  {",
          "852:   wchar_t wa[PATH_MAX];",
          "853:   wchar_t wb[PATH_MAX];",
          "854:   path_to_unicode(NULL, a, wa, ARRAY_SIZE(wa));",
          "855:   path_to_unicode(NULL, b, wb, ARRAY_SIZE(wb));",
          "857:   return MoveFileW(wa, wb) ? 0 : -1;",
          "858:  }",
          "861:  struct stat {",
          "862:   int64_t st_size;",
          "863:   time_t st_mtime;",
          "864:  };",
          "867:  FUNCTION_MAY_BE_UNUSED",
          "868:  static int stat(const char *name, struct stat *st)",
          "869:  {",
          "870:   wchar_t wbuf[PATH_MAX];",
          "871:   WIN32_FILE_ATTRIBUTE_DATA attr;",
          "872:   time_t creation_time, write_time;",
          "874:   path_to_unicode(NULL, name, wbuf, ARRAY_SIZE(wbuf));",
          "875:   memset(&attr, 0, sizeof(attr));",
          "877:   GetFileAttributesExW(wbuf, GetFileExInfoStandard, &attr);",
          "878:   st->st_size =",
          "879:       (((int64_t)attr.nFileSizeHigh) << 32) + (int64_t)attr.nFileSizeLow;",
          "881:   write_time = SYS2UNIX_TIME(attr.ftLastWriteTime.dwLowDateTime,",
          "882:                              attr.ftLastWriteTime.dwHighDateTime);",
          "883:   creation_time = SYS2UNIX_TIME(attr.ftCreationTime.dwLowDateTime,",
          "884:                                 attr.ftCreationTime.dwHighDateTime);",
          "886:   if (creation_time > write_time) {",
          "887:    st->st_mtime = creation_time;",
          "888:   } else {",
          "889:    st->st_mtime = write_time;",
          "890:   }",
          "891:   return 0;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "904: #pragma clang diagnostic ignored \"-Wunused-function\"",
          "905: #endif",
          "910: #if defined(_WIN32) && !defined(__SYMBIAN32__)",
          "917: #endif",
          "941: #if defined(_WIN32) && !defined(__SYMBIAN32__) && !defined(NO_ATOMICS)",
          "946: #elif defined(__GNUC__)                                                        \\",
          "947:     && ((__GNUC__ > 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ > 0)))           \\",
          "948:     && !defined(NO_ATOMICS)",
          "",
          "[Removed Lines]",
          "907: static pthread_mutex_t global_lock_mutex;",
          "912: FUNCTION_MAY_BE_UNUSED",
          "913: static int pthread_mutex_lock(pthread_mutex_t *mutex);",
          "915: FUNCTION_MAY_BE_UNUSED",
          "916: static int pthread_mutex_unlock(pthread_mutex_t *mutex);",
          "920: FUNCTION_MAY_BE_UNUSED",
          "921: static void",
          "922: mg_global_lock(void)",
          "923: {",
          "924:  (void)pthread_mutex_lock(&global_lock_mutex);",
          "925: }",
          "928: FUNCTION_MAY_BE_UNUSED",
          "929: static void",
          "930: mg_global_unlock(void)",
          "931: {",
          "932:  (void)pthread_mutex_unlock(&global_lock_mutex);",
          "933: }",
          "936: FUNCTION_MAY_BE_UNUSED",
          "937: static int",
          "938: mg_atomic_inc(volatile int *addr)",
          "939: {",
          "940:  int ret;",
          "945:  ret = InterlockedIncrement((volatile long *)addr);",
          "",
          "[Added Lines]",
          "925:  static pthread_mutex_t global_lock_mutex;",
          "930:  FUNCTION_MAY_BE_UNUSED",
          "931:  static int pthread_mutex_lock(pthread_mutex_t * mutex);",
          "933:  FUNCTION_MAY_BE_UNUSED",
          "934:  static int pthread_mutex_unlock(pthread_mutex_t * mutex);",
          "938:  FUNCTION_MAY_BE_UNUSED",
          "939:  static void mg_global_lock(void)",
          "940:  {",
          "941:   (void)pthread_mutex_lock(&global_lock_mutex);",
          "942:  }",
          "945:  FUNCTION_MAY_BE_UNUSED",
          "946:  static void mg_global_unlock(void)",
          "947:  {",
          "948:   (void)pthread_mutex_unlock(&global_lock_mutex);",
          "949:  }",
          "952:  FUNCTION_MAY_BE_UNUSED",
          "953:  static int mg_atomic_inc(volatile int *addr)",
          "954:  {",
          "955:   int ret;",
          "960:   ret = InterlockedIncrement((volatile long *)addr);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "952:  ret = (++(*addr));",
          "953:  mg_global_unlock();",
          "954: #endif",
          "964: #if defined(_WIN32) && !defined(__SYMBIAN32__) && !defined(NO_ATOMICS)",
          "969: #elif defined(__GNUC__)                                                        \\",
          "970:     && ((__GNUC__ > 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ > 0)))           \\",
          "971:     && !defined(NO_ATOMICS)",
          "",
          "[Removed Lines]",
          "955:  return ret;",
          "956: }",
          "959: FUNCTION_MAY_BE_UNUSED",
          "960: static int",
          "961: mg_atomic_dec(volatile int *addr)",
          "962: {",
          "963:  int ret;",
          "968:  ret = InterlockedDecrement((volatile long *)addr);",
          "",
          "[Added Lines]",
          "970:   return ret;",
          "971:  }",
          "974:  FUNCTION_MAY_BE_UNUSED",
          "975:  static int mg_atomic_dec(volatile int *addr)",
          "976:  {",
          "977:   int ret;",
          "982:   ret = InterlockedDecrement((volatile long *)addr);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "975:  ret = (--(*addr));",
          "976:  mg_global_unlock();",
          "977: #endif",
          "982: #if defined(USE_SERVER_STATS)",
          "987: #if defined(_WIN32) && !defined(__SYMBIAN32__) && !defined(NO_ATOMICS)",
          "989: #elif defined(__GNUC__)                                                        \\",
          "990:     && ((__GNUC__ > 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ > 0)))           \\",
          "991:     && !defined(NO_ATOMICS)",
          "",
          "[Removed Lines]",
          "978:  return ret;",
          "979: }",
          "983: static int64_t",
          "984: mg_atomic_add(volatile int64_t *addr, int64_t value)",
          "985: {",
          "986:  int64_t ret;",
          "988:  ret = InterlockedAdd64(addr, value);",
          "",
          "[Added Lines]",
          "992:   return ret;",
          "993:  }",
          "997:  static int64_t mg_atomic_add(volatile int64_t * addr, int64_t value)",
          "998:  {",
          "999:   int64_t ret;",
          "1001:   ret = InterlockedAdd64(addr, value);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "996:  ret = (*addr);",
          "997:  mg_global_unlock();",
          "998: #endif",
          "1001: #endif",
          "",
          "[Removed Lines]",
          "999:  return ret;",
          "1000: }",
          "",
          "[Added Lines]",
          "1012:   return ret;",
          "1013:  }",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1016: #if defined(USE_SERVER_STATS)",
          "1038: #if defined(MEMORY_DEBUGGING)",
          "1040: #else",
          "1041:  (void)file;",
          "1042:  (void)line;",
          "1043: #endif",
          "1059: #if defined(MEMORY_DEBUGGING)",
          "1068: #if defined(_WIN32)",
          "1070: #else",
          "1072: #endif",
          "1073: #endif",
          "1090:  }",
          "1101: #if defined(MEMORY_DEBUGGING)",
          "1103: #else",
          "1104:  (void)file;",
          "1105:  (void)line;",
          "1106: #endif",
          "1114: #if defined(MEMORY_DEBUGGING)",
          "1123: #if defined(_WIN32)",
          "1125: #else",
          "1127: #endif",
          "1128: #endif",
          "1130:  }",
          "1145: #if defined(MEMORY_DEBUGGING)",
          "1147: #else",
          "1148:  (void)file;",
          "1149:  (void)line;",
          "1150: #endif",
          "1163: #if defined(MEMORY_DEBUGGING)",
          "1172: #if defined(_WIN32)",
          "1174: #else",
          "1176: #endif",
          "1177: #endif",
          "1179: #if defined(MEMORY_DEBUGGING)",
          "1188: #if defined(_WIN32)",
          "1190: #else",
          "1192: #endif",
          "1193: #endif",
          "1197: #if defined(MEMORY_DEBUGGING)",
          "1198: #if defined(_WIN32)",
          "1200: #else",
          "1202: #endif",
          "1203: #endif",
          "1205:    }",
          "1206:   } else {",
          "1209:   }",
          "1219: #define mg_malloc(a) mg_malloc_ex(a, NULL, __FILE__, __LINE__)",
          "1220: #define mg_calloc(a, b) mg_calloc_ex(a, b, NULL, __FILE__, __LINE__)",
          "",
          "[Removed Lines]",
          "1018: struct mg_memory_stat {",
          "1019:  volatile int64_t totalMemUsed;",
          "1020:  volatile int64_t maxMemUsed;",
          "1021:  volatile int blockCount;",
          "1022: };",
          "1025: static struct mg_memory_stat *get_memory_stat(struct mg_context *ctx);",
          "1028: static void *",
          "1029: mg_malloc_ex(size_t size,",
          "1030:              struct mg_context *ctx,",
          "1031:              const char *file,",
          "1032:              unsigned line)",
          "1033: {",
          "1034:  void *data = malloc(size + 2 * sizeof(uintptr_t));",
          "1035:  void *memory = 0;",
          "1036:  struct mg_memory_stat *mstat = get_memory_stat(ctx);",
          "1039:  char mallocStr[256];",
          "1045:  if (data) {",
          "1046:   int64_t mmem = mg_atomic_add(&mstat->totalMemUsed, (int64_t)size);",
          "1047:   if (mmem > mstat->maxMemUsed) {",
          "1050:    mstat->maxMemUsed = mmem;",
          "1051:   }",
          "1053:   mg_atomic_inc(&mstat->blockCount);",
          "1054:   ((uintptr_t *)data)[0] = size;",
          "1055:   ((uintptr_t *)data)[1] = (uintptr_t)mstat;",
          "1056:   memory = (void *)(((char *)data) + 2 * sizeof(uintptr_t));",
          "1057:  }",
          "1060:  sprintf(mallocStr,",
          "1061:          \"MEM: %p %5lu alloc   %7lu %4lu --- %s:%u\\n\",",
          "1062:          memory,",
          "1063:          (unsigned long)size,",
          "1064:          (unsigned long)mstat->totalMemUsed,",
          "1065:          (unsigned long)mstat->blockCount,",
          "1066:          file,",
          "1067:          line);",
          "1069:  OutputDebugStringA(mallocStr);",
          "1071:  DEBUG_TRACE(\"%s\", mallocStr);",
          "1075:  return memory;",
          "1076: }",
          "1079: static void *",
          "1080: mg_calloc_ex(size_t count,",
          "1081:              size_t size,",
          "1082:              struct mg_context *ctx,",
          "1083:              const char *file,",
          "1084:              unsigned line)",
          "1085: {",
          "1086:  void *data = mg_malloc_ex(size * count, ctx, file, line);",
          "1088:  if (data) {",
          "1089:   memset(data, 0, size * count);",
          "1091:  return data;",
          "1092: }",
          "1095: static void",
          "1096: mg_free_ex(void *memory, const char *file, unsigned line)",
          "1097: {",
          "1098:  void *data = (void *)(((char *)memory) - 2 * sizeof(uintptr_t));",
          "1102:  char mallocStr[256];",
          "1108:  if (memory) {",
          "1109:   uintptr_t size = ((uintptr_t *)data)[0];",
          "1110:   struct mg_memory_stat *mstat =",
          "1111:       (struct mg_memory_stat *)(((uintptr_t *)data)[1]);",
          "1112:   mg_atomic_add(&mstat->totalMemUsed, -(int64_t)size);",
          "1113:   mg_atomic_dec(&mstat->blockCount);",
          "1115:   sprintf(mallocStr,",
          "1116:           \"MEM: %p %5lu free    %7lu %4lu --- %s:%u\\n\",",
          "1117:           memory,",
          "1118:           (unsigned long)size,",
          "1119:           (unsigned long)mstat->totalMemUsed,",
          "1120:           (unsigned long)mstat->blockCount,",
          "1121:           file,",
          "1122:           line);",
          "1124:   OutputDebugStringA(mallocStr);",
          "1126:   DEBUG_TRACE(\"%s\", mallocStr);",
          "1129:   free(data);",
          "1131: }",
          "1134: static void *",
          "1135: mg_realloc_ex(void *memory,",
          "1136:               size_t newsize,",
          "1137:               struct mg_context *ctx,",
          "1138:               const char *file,",
          "1139:               unsigned line)",
          "1140: {",
          "1141:  void *data;",
          "1142:  void *_realloc;",
          "1143:  uintptr_t oldsize;",
          "1146:  char mallocStr[256];",
          "1152:  if (newsize) {",
          "1153:   if (memory) {",
          "1155:    struct mg_memory_stat *mstat;",
          "1156:    data = (void *)(((char *)memory) - 2 * sizeof(uintptr_t));",
          "1157:    oldsize = ((uintptr_t *)data)[0];",
          "1158:    mstat = (struct mg_memory_stat *)((uintptr_t *)data)[1];",
          "1159:    _realloc = realloc(data, newsize + 2 * sizeof(uintptr_t));",
          "1160:    if (_realloc) {",
          "1161:     data = _realloc;",
          "1162:     mg_atomic_add(&mstat->totalMemUsed, -(int64_t)oldsize);",
          "1164:     sprintf(mallocStr,",
          "1165:             \"MEM: %p %5lu r-free  %7lu %4lu --- %s:%u\\n\",",
          "1166:             memory,",
          "1167:             (unsigned long)oldsize,",
          "1168:             (unsigned long)mstat->totalMemUsed,",
          "1169:             (unsigned long)mstat->blockCount,",
          "1170:             file,",
          "1171:             line);",
          "1173:     OutputDebugStringA(mallocStr);",
          "1175:     DEBUG_TRACE(\"%s\", mallocStr);",
          "1178:     mg_atomic_add(&mstat->totalMemUsed, (int64_t)newsize);",
          "1180:     sprintf(mallocStr,",
          "1181:             \"MEM: %p %5lu r-alloc %7lu %4lu --- %s:%u\\n\",",
          "1182:             memory,",
          "1183:             (unsigned long)newsize,",
          "1184:             (unsigned long)mstat->totalMemUsed,",
          "1185:             (unsigned long)mstat->blockCount,",
          "1186:             file,",
          "1187:             line);",
          "1189:     OutputDebugStringA(mallocStr);",
          "1191:     DEBUG_TRACE(\"%s\", mallocStr);",
          "1195:     data = (void *)(((char *)data) + 2 * sizeof(uintptr_t));",
          "1196:    } else {",
          "1199:     OutputDebugStringA(\"MEM: realloc failed\\n\");",
          "1201:     DEBUG_TRACE(\"%s\", \"MEM: realloc failed\\n\");",
          "1204:     return _realloc;",
          "1208:    data = mg_malloc_ex(newsize, ctx, file, line);",
          "1210:  } else {",
          "1212:   data = 0;",
          "1213:   mg_free_ex(memory, file, line);",
          "1214:  }",
          "1216:  return data;",
          "1217: }",
          "",
          "[Added Lines]",
          "1031:  struct mg_memory_stat {",
          "1032:   volatile int64_t totalMemUsed;",
          "1033:   volatile int64_t maxMemUsed;",
          "1034:   volatile int blockCount;",
          "1035:  };",
          "1038:  static struct mg_memory_stat *get_memory_stat(struct mg_context * ctx);",
          "1041:  static void *mg_malloc_ex(size_t size,",
          "1042:                            struct mg_context * ctx,",
          "1043:                            const char *file,",
          "1044:                            unsigned line)",
          "1045:  {",
          "1046:   void *data = malloc(size + 2 * sizeof(uintptr_t));",
          "1047:   void *memory = 0;",
          "1048:   struct mg_memory_stat *mstat = get_memory_stat(ctx);",
          "1051:   char mallocStr[256];",
          "1057:   if (data) {",
          "1058:    int64_t mmem = mg_atomic_add(&mstat->totalMemUsed, (int64_t)size);",
          "1059:    if (mmem > mstat->maxMemUsed) {",
          "1062:     mstat->maxMemUsed = mmem;",
          "1063:    }",
          "1065:    mg_atomic_inc(&mstat->blockCount);",
          "1066:    ((uintptr_t *)data)[0] = size;",
          "1067:    ((uintptr_t *)data)[1] = (uintptr_t)mstat;",
          "1068:    memory = (void *)(((char *)data) + 2 * sizeof(uintptr_t));",
          "1069:   }",
          "1072:   sprintf(mallocStr,",
          "1073:           \"MEM: %p %5lu alloc   %7lu %4lu --- %s:%u\\n\",",
          "1074:           memory,",
          "1075:           (unsigned long)size,",
          "1076:           (unsigned long)mstat->totalMemUsed,",
          "1077:           (unsigned long)mstat->blockCount,",
          "1078:           file,",
          "1079:           line);",
          "1081:   OutputDebugStringA(mallocStr);",
          "1083:   DEBUG_TRACE(\"%s\", mallocStr);",
          "1087:   return memory;",
          "1088:  }",
          "1091:  static void *mg_calloc_ex(size_t count,",
          "1092:                            size_t size,",
          "1093:                            struct mg_context * ctx,",
          "1094:                            const char *file,",
          "1095:                            unsigned line)",
          "1096:  {",
          "1097:   void *data = mg_malloc_ex(size * count, ctx, file, line);",
          "1099:   if (data) {",
          "1100:    memset(data, 0, size * count);",
          "1101:   }",
          "1102:   return data;",
          "1106:  static void mg_free_ex(void *memory, const char *file, unsigned line)",
          "1107:  {",
          "1108:   void *data = (void *)(((char *)memory) - 2 * sizeof(uintptr_t));",
          "1112:   char mallocStr[256];",
          "1118:   if (memory) {",
          "1119:    uintptr_t size = ((uintptr_t *)data)[0];",
          "1120:    struct mg_memory_stat *mstat =",
          "1121:        (struct mg_memory_stat *)(((uintptr_t *)data)[1]);",
          "1122:    mg_atomic_add(&mstat->totalMemUsed, -(int64_t)size);",
          "1123:    mg_atomic_dec(&mstat->blockCount);",
          "1125:    sprintf(mallocStr,",
          "1126:            \"MEM: %p %5lu free    %7lu %4lu --- %s:%u\\n\",",
          "1127:            memory,",
          "1128:            (unsigned long)size,",
          "1129:            (unsigned long)mstat->totalMemUsed,",
          "1130:            (unsigned long)mstat->blockCount,",
          "1131:            file,",
          "1132:            line);",
          "1134:    OutputDebugStringA(mallocStr);",
          "1136:    DEBUG_TRACE(\"%s\", mallocStr);",
          "1139:    free(data);",
          "1140:   }",
          "1144:  static void *mg_realloc_ex(void *memory,",
          "1145:                             size_t newsize,",
          "1146:                             struct mg_context *ctx,",
          "1147:                             const char *file,",
          "1148:                             unsigned line)",
          "1149:  {",
          "1150:   void *data;",
          "1151:   void *_realloc;",
          "1152:   uintptr_t oldsize;",
          "1155:   char mallocStr[256];",
          "1161:   if (newsize) {",
          "1162:    if (memory) {",
          "1164:     struct mg_memory_stat *mstat;",
          "1165:     data = (void *)(((char *)memory) - 2 * sizeof(uintptr_t));",
          "1166:     oldsize = ((uintptr_t *)data)[0];",
          "1167:     mstat = (struct mg_memory_stat *)((uintptr_t *)data)[1];",
          "1168:     _realloc = realloc(data, newsize + 2 * sizeof(uintptr_t));",
          "1169:     if (_realloc) {",
          "1170:      data = _realloc;",
          "1171:      mg_atomic_add(&mstat->totalMemUsed, -(int64_t)oldsize);",
          "1173:      sprintf(mallocStr,",
          "1174:              \"MEM: %p %5lu r-free  %7lu %4lu --- %s:%u\\n\",",
          "1175:              memory,",
          "1176:              (unsigned long)oldsize,",
          "1177:              (unsigned long)mstat->totalMemUsed,",
          "1178:              (unsigned long)mstat->blockCount,",
          "1179:              file,",
          "1180:              line);",
          "1182:      OutputDebugStringA(mallocStr);",
          "1184:      DEBUG_TRACE(\"%s\", mallocStr);",
          "1187:      mg_atomic_add(&mstat->totalMemUsed, (int64_t)newsize);",
          "1189:      sprintf(mallocStr,",
          "1190:              \"MEM: %p %5lu r-alloc %7lu %4lu --- %s:%u\\n\",",
          "1191:              memory,",
          "1192:              (unsigned long)newsize,",
          "1193:              (unsigned long)mstat->totalMemUsed,",
          "1194:              (unsigned long)mstat->blockCount,",
          "1195:              file,",
          "1196:              line);",
          "1198:      OutputDebugStringA(mallocStr);",
          "1200:      DEBUG_TRACE(\"%s\", mallocStr);",
          "1204:      data = (void *)(((char *)data) + 2 * sizeof(uintptr_t));",
          "1205:     } else {",
          "1208:      OutputDebugStringA(\"MEM: realloc failed\\n\");",
          "1210:      DEBUG_TRACE(\"%s\", \"MEM: realloc failed\\n\");",
          "1213:      return _realloc;",
          "1214:     }",
          "1215:    } else {",
          "1217:     data = mg_malloc_ex(newsize, ctx, file, line);",
          "1221:    data = 0;",
          "1222:    mg_free_ex(memory, file, line);",
          "1225:   return data;",
          "1226:  }",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1262: static void mg_vsnprintf(const struct mg_connection *conn,",
          "1263:                          int *truncated,",
          "1264:                          char *buf,",
          "1265:                          size_t buflen,",
          "1266:                          const char *fmt,",
          "1267:                          va_list ap);",
          "1269: static void mg_snprintf(const struct mg_connection *conn,",
          "1270:                         int *truncated,",
          "1271:                         char *buf,",
          "1272:                         size_t buflen,",
          "1273:                         PRINTF_FORMAT_STRING(const char *fmt),",
          "1274:                         ...) PRINTF_ARGS(5, 6);",
          "",
          "[Added Lines]",
          "1271:  static void mg_vsnprintf(const struct mg_connection *conn,",
          "1272:                           int *truncated,",
          "1273:                           char *buf,",
          "1274:                           size_t buflen,",
          "1275:                           const char *fmt,",
          "1276:                           va_list ap);",
          "1278:  static void mg_snprintf(const struct mg_connection *conn,",
          "1279:                          int *truncated,",
          "1280:                          char *buf,",
          "1281:                          size_t buflen,",
          "1282:                          PRINTF_FORMAT_STRING(const char *fmt),",
          "1283:                          ...) PRINTF_ARGS(5, 6);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1304: #endif",
          "1310: #if !defined(NO_SSL)",
          "1312: #endif",
          "1321: #if defined(_WIN32) && !defined(__SYMBIAN32__)",
          "1324: #endif",
          "1328: #if defined(__GNUC__) || defined(__MINGW32__)",
          "",
          "[Removed Lines]",
          "1308: static int mg_init_library_called = 0;",
          "1311: static int mg_ssl_initialized = 0;",
          "1315: static int thread_idx_max = 0;",
          "1318: struct mg_workerTLS {",
          "1319:  int is_master;",
          "1320:  unsigned long thread_idx;",
          "1322:  HANDLE pthread_cond_helper_mutex;",
          "1323:  struct mg_workerTLS *next_waiting_thread;",
          "1325: };",
          "",
          "[Added Lines]",
          "1317:  static int mg_init_library_called = 0;",
          "1320:  static int mg_ssl_initialized = 0;",
          "1324:  static int thread_idx_max = 0;",
          "1327:  struct mg_workerTLS {",
          "1328:   int is_master;",
          "1329:   unsigned long thread_idx;",
          "1331:   HANDLE pthread_cond_helper_mutex;",
          "1332:   struct mg_workerTLS *next_waiting_thread;",
          "1334:  };",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1339: #endif",
          "1356: #ifdef _WIN32",
          "1358: #else",
          "1360: #ifdef __clang__",
          "",
          "[Removed Lines]",
          "1352: FUNCTION_MAY_BE_UNUSED",
          "1353: static unsigned long",
          "1354: mg_current_thread_id(void)",
          "1355: {",
          "1357:  return GetCurrentThreadId();",
          "",
          "[Added Lines]",
          "1361:  FUNCTION_MAY_BE_UNUSED",
          "1362:  static unsigned long mg_current_thread_id(void)",
          "1363:  {",
          "1365:   return GetCurrentThreadId();",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1396: #endif",
          "1398: #endif",
          "1412: #if defined(__GNUC__)",
          "",
          "[Removed Lines]",
          "1399: }",
          "1402: FUNCTION_MAY_BE_UNUSED",
          "1403: static uint64_t",
          "1404: mg_get_current_time_ns(void)",
          "1405: {",
          "1406:  struct timespec tsnow;",
          "1407:  clock_gettime(CLOCK_REALTIME, &tsnow);",
          "1408:  return (((uint64_t)tsnow.tv_sec) * 1000000000) + (uint64_t)tsnow.tv_nsec;",
          "1409: }",
          "",
          "[Added Lines]",
          "1407:  }",
          "1410:  FUNCTION_MAY_BE_UNUSED",
          "1411:  static uint64_t mg_get_current_time_ns(void)",
          "1412:  {",
          "1413:   struct timespec tsnow;",
          "1414:   clock_gettime(CLOCK_REALTIME, &tsnow);",
          "1415:   return (((uint64_t)tsnow.tv_sec) * 1000000000)",
          "1416:          + (uint64_t)tsnow.tv_nsec;",
          "1417:  }",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "1424: #if !defined(DEBUG_TRACE)",
          "1425: #if defined(DEBUG)",
          "1447:   nslast = nsnow;",
          "1448:  }",
          "1467: #define DEBUG_TRACE(fmt, ...)                                                  \\",
          "1468:  DEBUG_TRACE_FUNC(__func__, __LINE__, fmt, __VA_ARGS__)",
          "",
          "[Removed Lines]",
          "1426: static void DEBUG_TRACE_FUNC(const char *func,",
          "1427:                              unsigned line,",
          "1428:                              PRINTF_FORMAT_STRING(const char *fmt),",
          "1429:                              ...) PRINTF_ARGS(3, 4);",
          "1431: static void",
          "1432: DEBUG_TRACE_FUNC(const char *func, unsigned line, const char *fmt, ...)",
          "1433: {",
          "1434:  va_list args;",
          "1435:  uint64_t nsnow;",
          "1436:  static uint64_t nslast;",
          "1437:  struct timespec tsnow;",
          "1440:  unsigned long thread_id = mg_current_thread_id();",
          "1442:  clock_gettime(CLOCK_REALTIME, &tsnow);",
          "1443:  nsnow = ((uint64_t)tsnow.tv_sec) * ((uint64_t)1000000000)",
          "1444:          + ((uint64_t)tsnow.tv_nsec);",
          "1446:  if (!nslast) {",
          "1450:  flockfile(stdout);",
          "1451:  printf(\"*** %lu.%09lu %12\" INT64_FMT \" %lu %s:%u: \",",
          "1452:         (unsigned long)tsnow.tv_sec,",
          "1453:         (unsigned long)tsnow.tv_nsec,",
          "1454:         nsnow - nslast,",
          "1455:         thread_id,",
          "1456:         func,",
          "1457:         line);",
          "1458:  va_start(args, fmt);",
          "1459:  vprintf(fmt, args);",
          "1460:  va_end(args);",
          "1461:  putchar('\\n');",
          "1462:  fflush(stdout);",
          "1463:  funlockfile(stdout);",
          "1464:  nslast = nsnow;",
          "1465: }",
          "",
          "[Added Lines]",
          "1434:  static void DEBUG_TRACE_FUNC(const char *func,",
          "1435:                               unsigned line,",
          "1436:                               PRINTF_FORMAT_STRING(const char *fmt),",
          "1437:                               ...) PRINTF_ARGS(3, 4);",
          "1439:  static void DEBUG_TRACE_FUNC(const char *func,",
          "1440:                               unsigned line,",
          "1441:                               const char *fmt,",
          "1442:                               ...)",
          "1443:  {",
          "1444:   va_list args;",
          "1445:   uint64_t nsnow;",
          "1446:   static uint64_t nslast;",
          "1447:   struct timespec tsnow;",
          "1450:   unsigned long thread_id = mg_current_thread_id();",
          "1452:   clock_gettime(CLOCK_REALTIME, &tsnow);",
          "1453:   nsnow = ((uint64_t)tsnow.tv_sec) * ((uint64_t)1000000000)",
          "1454:           + ((uint64_t)tsnow.tv_nsec);",
          "1456:   if (!nslast) {",
          "1457:    nslast = nsnow;",
          "1458:   }",
          "1460:   flockfile(stdout);",
          "1461:   printf(\"*** %lu.%09lu %12\" INT64_FMT \" %lu %s:%u: \",",
          "1462:          (unsigned long)tsnow.tv_sec,",
          "1463:          (unsigned long)tsnow.tv_nsec,",
          "1464:          nsnow - nslast,",
          "1465:          thread_id,",
          "1466:          func,",
          "1467:          line);",
          "1468:   va_start(args, fmt);",
          "1469:   vprintf(fmt, args);",
          "1470:   va_end(args);",
          "1471:   putchar('\\n');",
          "1472:   fflush(stdout);",
          "1473:   funlockfile(stdout);",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "1482: #ifdef NO_SOCKLEN_T",
          "1485: #define _DARWIN_UNLIMITED_SELECT",
          "",
          "[Removed Lines]",
          "1483: typedef int socklen_t;",
          "",
          "[Added Lines]",
          "1493:  typedef int socklen_t;",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "1503: #if defined(NO_SSL)",
          "1506: #else",
          "1507: #if defined(NO_SSL_DL)",
          "1508: #include <openssl/ssl.h>",
          "",
          "[Removed Lines]",
          "1505: typedef struct SSL_CTX SSL_CTX;",
          "",
          "[Added Lines]",
          "1515:  typedef struct SSL_CTX SSL_CTX;",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "1883: #if !defined(NO_CACHING)",
          "1903: #if defined(USE_IPV6)",
          "1944: #define STRUCT_FILE_INITIALIZER                                                \\",
          "1945:  {                                                                          \\",
          "",
          "[Removed Lines]",
          "1884: static const char *month_names[] = {\"Jan\",",
          "1885:                                     \"Feb\",",
          "1886:                                     \"Mar\",",
          "1887:                                     \"Apr\",",
          "1888:                                     \"May\",",
          "1889:                                     \"Jun\",",
          "1890:                                     \"Jul\",",
          "1891:                                     \"Aug\",",
          "1892:                                     \"Sep\",",
          "1893:                                     \"Oct\",",
          "1894:                                     \"Nov\",",
          "1895:                                     \"Dec\"};",
          "1900: union usa {",
          "1901:  struct sockaddr sa;",
          "1902:  struct sockaddr_in sin;",
          "1904:  struct sockaddr_in6 sin6;",
          "1905: #endif",
          "1906: };",
          "1909: struct vec {",
          "1910:  const char *ptr;",
          "1911:  size_t len;",
          "1912: };",
          "1914: struct mg_file_stat {",
          "1916:  uint64_t size;",
          "1917:  time_t last_modified;",
          "1919:  int is_gzipped;   /* Set to 1 if the content is gzipped, in which",
          "1922: };",
          "1924: struct mg_file_in_memory {",
          "1925:  char *p;",
          "1926:  uint32_t pos;",
          "1927:  char mode;",
          "1928: };",
          "1930: struct mg_file_access {",
          "1932:  FILE *fp;",
          "1936:  const char *membuf;",
          "1937: };",
          "1939: struct mg_file {",
          "1940:  struct mg_file_stat stat;",
          "1941:  struct mg_file_access access;",
          "1942: };",
          "",
          "[Added Lines]",
          "1894:  static const char *month_names[] = {\"Jan\",",
          "1895:                                      \"Feb\",",
          "1896:                                      \"Mar\",",
          "1897:                                      \"Apr\",",
          "1898:                                      \"May\",",
          "1899:                                      \"Jun\",",
          "1900:                                      \"Jul\",",
          "1901:                                      \"Aug\",",
          "1902:                                      \"Sep\",",
          "1903:                                      \"Oct\",",
          "1904:                                      \"Nov\",",
          "1905:                                      \"Dec\"};",
          "1911:  union usa {",
          "1912:   struct sockaddr sa;",
          "1913:   struct sockaddr_in sin;",
          "1915:   struct sockaddr_in6 sin6;",
          "1916: #endif",
          "1917:  };",
          "1920:  struct vec {",
          "1921:   const char *ptr;",
          "1922:   size_t len;",
          "1923:  };",
          "1925:  struct mg_file_stat {",
          "1927:   uint64_t size;",
          "1928:   time_t last_modified;",
          "1930:   int is_gzipped;   /* Set to 1 if the content is gzipped, in which",
          "1933:  };",
          "1935:  struct mg_file_in_memory {",
          "1936:   char *p;",
          "1937:   uint32_t pos;",
          "1938:   char mode;",
          "1939:  };",
          "1941:  struct mg_file_access {",
          "1943:   FILE *fp;",
          "1947:   const char *membuf;",
          "1948:  };",
          "1950:  struct mg_file {",
          "1951:   struct mg_file_stat stat;",
          "1952:   struct mg_file_access access;",
          "1953:  };",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "1952:   }                                                                      \\",
          "1953:  }",
          "2006: #if defined(USE_WEBSOCKET)",
          "2008: #endif",
          "2012: #if defined(USE_LUA)",
          "2016: #endif",
          "2017: #if defined(USE_DUKTAPE)",
          "2019: #endif",
          "2021: #if defined(USE_WEBSOCKET)",
          "2023: #endif",
          "2024: #if defined(USE_LUA) && defined(USE_WEBSOCKET)",
          "2026: #endif",
          "2034: #if !defined(NO_CACHING)",
          "2036: #endif",
          "2037: #if !defined(NO_SSL)",
          "2039: #endif",
          "2040: #if defined(__linux__)",
          "2042: #endif",
          "2043: #if defined(_WIN32)",
          "2045: #endif",
          "2046: #if defined(USE_LUA)",
          "2073: #ifdef USE_LUA",
          "2076: #else",
          "2077:      \"index.xhtml,index.html,index.htm,index.cgi,index.shtml,index.php\"},",
          "2078: #endif",
          "2104: #if defined(USE_WEBSOCKET)",
          "2106: #endif",
          "2109: #if defined(USE_LUA)",
          "2113: #endif",
          "2114: #if defined(USE_DUKTAPE)",
          "2118: #endif",
          "2120: #if defined(USE_WEBSOCKET)",
          "2122: #endif",
          "2123: #if defined(USE_LUA) && defined(USE_WEBSOCKET)",
          "2125: #endif",
          "2131: #if !defined(NO_CACHING)",
          "2133: #endif",
          "2134: #if !defined(NO_SSL)",
          "2136: #endif",
          "2137: #if defined(__linux__)",
          "2139: #endif",
          "2140: #if defined(_WIN32)",
          "2142: #endif",
          "2143: #if defined(USE_LUA)",
          "2145: #endif",
          "2209: #ifdef ALTERNATIVE_QUEUE",
          "2212: #else",
          "",
          "[Removed Lines]",
          "1957: struct socket {",
          "1962:  unsigned char ssl_redir; /* Is port supposed to redirect everything to SSL",
          "1965: };",
          "1968: enum {",
          "1969:  CGI_EXTENSIONS,",
          "1970:  CGI_ENVIRONMENT,",
          "1971:  PUT_DELETE_PASSWORDS_FILE,",
          "1972:  CGI_INTERPRETER,",
          "1973:  PROTECT_URI,",
          "1974:  AUTHENTICATION_DOMAIN,",
          "1975:  ENABLE_AUTH_DOMAIN_CHECK,",
          "1976:  SSI_EXTENSIONS,",
          "1977:  THROTTLE,",
          "1978:  ACCESS_LOG_FILE,",
          "1979:  ENABLE_DIRECTORY_LISTING,",
          "1980:  ERROR_LOG_FILE,",
          "1981:  GLOBAL_PASSWORDS_FILE,",
          "1982:  INDEX_FILES,",
          "1983:  ENABLE_KEEP_ALIVE,",
          "1984:  ACCESS_CONTROL_LIST,",
          "1985:  EXTRA_MIME_TYPES,",
          "1986:  LISTENING_PORTS,",
          "1987:  DOCUMENT_ROOT,",
          "1988:  SSL_CERTIFICATE,",
          "1989:  SSL_CERTIFICATE_CHAIN,",
          "1990:  NUM_THREADS,",
          "1991:  RUN_AS_USER,",
          "1992:  URL_REWRITE_PATTERN,",
          "1993:  HIDE_FILES,",
          "1994:  REQUEST_TIMEOUT,",
          "1995:  KEEP_ALIVE_TIMEOUT,",
          "1996:  LINGER_TIMEOUT,",
          "1997:  SSL_DO_VERIFY_PEER,",
          "1998:  SSL_CA_PATH,",
          "1999:  SSL_CA_FILE,",
          "2000:  SSL_VERIFY_DEPTH,",
          "2001:  SSL_DEFAULT_VERIFY_PATHS,",
          "2002:  SSL_CIPHER_LIST,",
          "2003:  SSL_PROTOCOL_VERSION,",
          "2004:  SSL_SHORT_TRUST,",
          "2007:  WEBSOCKET_TIMEOUT,",
          "2010:  DECODE_URL,",
          "2013:  LUA_PRELOAD_FILE,",
          "2014:  LUA_SCRIPT_EXTENSIONS,",
          "2015:  LUA_SERVER_PAGE_EXTENSIONS,",
          "2018:  DUKTAPE_SCRIPT_EXTENSIONS,",
          "2022:  WEBSOCKET_ROOT,",
          "2025:  LUA_WEBSOCKET_EXTENSIONS,",
          "2028:  ACCESS_CONTROL_ALLOW_ORIGIN,",
          "2029:  ACCESS_CONTROL_ALLOW_METHODS,",
          "2030:  ACCESS_CONTROL_ALLOW_HEADERS,",
          "2031:  ERROR_PAGES,",
          "2032:  CONFIG_TCP_NODELAY, /* Prepended CONFIG_ to avoid conflict with the",
          "2035:  STATIC_FILE_MAX_AGE,",
          "2038:  STRICT_HTTPS_MAX_AGE,",
          "2041:  ALLOW_SENDFILE_CALL,",
          "2044:  CASE_SENSITIVE_FILES,",
          "2047:  LUA_BACKGROUND_SCRIPT,",
          "2048: #endif",
          "2049:  ADDITIONAL_HEADER,",
          "2050:  MAX_REQUEST_SIZE,",
          "2052:  NUM_OPTIONS",
          "2053: };",
          "2057: static struct mg_option config_options[] = {",
          "2058:     {\"cgi_pattern\", CONFIG_TYPE_EXT_PATTERN, \"**.cgi$|**.pl$|**.php$\"},",
          "2059:     {\"cgi_environment\", CONFIG_TYPE_STRING_LIST, NULL},",
          "2060:     {\"put_delete_auth_file\", CONFIG_TYPE_FILE, NULL},",
          "2061:     {\"cgi_interpreter\", CONFIG_TYPE_FILE, NULL},",
          "2062:     {\"protect_uri\", CONFIG_TYPE_STRING_LIST, NULL},",
          "2063:     {\"authentication_domain\", CONFIG_TYPE_STRING, \"mydomain.com\"},",
          "2064:     {\"enable_auth_domain_check\", CONFIG_TYPE_BOOLEAN, \"yes\"},",
          "2065:     {\"ssi_pattern\", CONFIG_TYPE_EXT_PATTERN, \"**.shtml$|**.shtm$\"},",
          "2066:     {\"throttle\", CONFIG_TYPE_STRING_LIST, NULL},",
          "2067:     {\"access_log_file\", CONFIG_TYPE_FILE, NULL},",
          "2068:     {\"enable_directory_listing\", CONFIG_TYPE_BOOLEAN, \"yes\"},",
          "2069:     {\"error_log_file\", CONFIG_TYPE_FILE, NULL},",
          "2070:     {\"global_auth_file\", CONFIG_TYPE_FILE, NULL},",
          "2071:     {\"index_files\",",
          "2072:      CONFIG_TYPE_STRING_LIST,",
          "2074:      \"index.xhtml,index.html,index.htm,index.lp,index.lsp,index.lua,index.cgi,\"",
          "2075:      \"index.shtml,index.php\"},",
          "2079:     {\"enable_keep_alive\", CONFIG_TYPE_BOOLEAN, \"no\"},",
          "2080:     {\"access_control_list\", CONFIG_TYPE_STRING_LIST, NULL},",
          "2081:     {\"extra_mime_types\", CONFIG_TYPE_STRING_LIST, NULL},",
          "2082:     {\"listening_ports\", CONFIG_TYPE_STRING_LIST, \"8080\"},",
          "2083:     {\"document_root\", CONFIG_TYPE_DIRECTORY, NULL},",
          "2084:     {\"ssl_certificate\", CONFIG_TYPE_FILE, NULL},",
          "2085:     {\"ssl_certificate_chain\", CONFIG_TYPE_FILE, NULL},",
          "2086:     {\"num_threads\", CONFIG_TYPE_NUMBER, \"50\"},",
          "2087:     {\"run_as_user\", CONFIG_TYPE_STRING, NULL},",
          "2088:     {\"url_rewrite_patterns\", CONFIG_TYPE_STRING_LIST, NULL},",
          "2089:     {\"hide_files_patterns\", CONFIG_TYPE_EXT_PATTERN, NULL},",
          "2090:     {\"request_timeout_ms\", CONFIG_TYPE_NUMBER, \"30000\"},",
          "2091:     {\"keep_alive_timeout_ms\", CONFIG_TYPE_NUMBER, \"500\"},",
          "2092:     {\"linger_timeout_ms\", CONFIG_TYPE_NUMBER, NULL},",
          "2095:     {\"ssl_verify_peer\", CONFIG_TYPE_BOOLEAN, \"no\"},",
          "2097:     {\"ssl_ca_path\", CONFIG_TYPE_DIRECTORY, NULL},",
          "2098:     {\"ssl_ca_file\", CONFIG_TYPE_FILE, NULL},",
          "2099:     {\"ssl_verify_depth\", CONFIG_TYPE_NUMBER, \"9\"},",
          "2100:     {\"ssl_default_verify_paths\", CONFIG_TYPE_BOOLEAN, \"yes\"},",
          "2101:     {\"ssl_cipher_list\", CONFIG_TYPE_STRING, NULL},",
          "2102:     {\"ssl_protocol_version\", CONFIG_TYPE_NUMBER, \"0\"},",
          "2103:     {\"ssl_short_trust\", CONFIG_TYPE_BOOLEAN, \"no\"},",
          "2105:     {\"websocket_timeout_ms\", CONFIG_TYPE_NUMBER, \"30000\"},",
          "2107:     {\"decode_url\", CONFIG_TYPE_BOOLEAN, \"yes\"},",
          "2110:     {\"lua_preload_file\", CONFIG_TYPE_FILE, NULL},",
          "2111:     {\"lua_script_pattern\", CONFIG_TYPE_EXT_PATTERN, \"**.lua$\"},",
          "2112:     {\"lua_server_page_pattern\", CONFIG_TYPE_EXT_PATTERN, \"**.lp$|**.lsp$\"},",
          "2117:     {\"duktape_script_pattern\", CONFIG_TYPE_EXT_PATTERN, \"**.ssjs$\"},",
          "2121:     {\"websocket_root\", CONFIG_TYPE_DIRECTORY, NULL},",
          "2124:     {\"lua_websocket_pattern\", CONFIG_TYPE_EXT_PATTERN, \"**.lua$\"},",
          "2126:     {\"access_control_allow_origin\", CONFIG_TYPE_STRING, \"*\"},",
          "2127:     {\"access_control_allow_methods\", CONFIG_TYPE_STRING, \"*\"},",
          "2128:     {\"access_control_allow_headers\", CONFIG_TYPE_STRING, \"*\"},",
          "2129:     {\"error_pages\", CONFIG_TYPE_DIRECTORY, NULL},",
          "2130:     {\"tcp_nodelay\", CONFIG_TYPE_NUMBER, \"0\"},",
          "2132:     {\"static_file_max_age\", CONFIG_TYPE_NUMBER, \"3600\"},",
          "2135:     {\"strict_transport_security_max_age\", CONFIG_TYPE_NUMBER, NULL},",
          "2138:     {\"allow_sendfile_call\", CONFIG_TYPE_BOOLEAN, \"yes\"},",
          "2141:     {\"case_sensitive\", CONFIG_TYPE_BOOLEAN, \"no\"},",
          "2144:     {\"lua_background_script\", CONFIG_TYPE_FILE, NULL},",
          "2146:     {\"additional_header\", CONFIG_TYPE_STRING_MULTILINE, NULL},",
          "2147:     {\"max_request_size\", CONFIG_TYPE_NUMBER, \"16384\"},",
          "2149:     {NULL, CONFIG_TYPE_UNKNOWN, NULL}};",
          "2154: mg_static_assert((sizeof(config_options) / sizeof(config_options[0]))",
          "2155:                      == (NUM_OPTIONS + 1),",
          "2156:                  \"config_options and enum not sync\");",
          "2159: enum { REQUEST_HANDLER, WEBSOCKET_HANDLER, AUTH_HANDLER };",
          "2162: struct mg_handler_info {",
          "2164:  char *uri;",
          "2165:  size_t uri_len;",
          "2168:  int handler_type;",
          "2171:  mg_request_handler handler;",
          "2174:  mg_websocket_connect_handler connect_handler;",
          "2175:  mg_websocket_ready_handler ready_handler;",
          "2176:  mg_websocket_data_handler data_handler;",
          "2177:  mg_websocket_close_handler close_handler;",
          "2180:  struct mg_websocket_subprotocols *subprotocols;",
          "2183:  mg_authorization_handler auth_handler;",
          "2186:  void *cbdata;",
          "2189:  struct mg_handler_info *next;",
          "2190: };",
          "2193: struct mg_context {",
          "2199:  int context_type;              /* 1 = server context,",
          "2203:  struct socket *listening_sockets;",
          "2204:  struct pollfd *listening_socket_fds;",
          "2205:  unsigned int num_listening_sockets;",
          "2210:  struct socket *client_socks;",
          "2211:  void **client_wait_events;",
          "",
          "[Added Lines]",
          "1968:  struct socket {",
          "1973:   unsigned char",
          "1974:       ssl_redir;        /* Is port supposed to redirect everything to SSL",
          "1977:  };",
          "1980:  enum {",
          "1981:   CGI_EXTENSIONS,",
          "1982:   CGI_ENVIRONMENT,",
          "1983:   PUT_DELETE_PASSWORDS_FILE,",
          "1984:   CGI_INTERPRETER,",
          "1985:   PROTECT_URI,",
          "1986:   AUTHENTICATION_DOMAIN,",
          "1987:   ENABLE_AUTH_DOMAIN_CHECK,",
          "1988:   SSI_EXTENSIONS,",
          "1989:   THROTTLE,",
          "1990:   ACCESS_LOG_FILE,",
          "1991:   ENABLE_DIRECTORY_LISTING,",
          "1992:   ERROR_LOG_FILE,",
          "1993:   GLOBAL_PASSWORDS_FILE,",
          "1994:   INDEX_FILES,",
          "1995:   ENABLE_KEEP_ALIVE,",
          "1996:   ACCESS_CONTROL_LIST,",
          "1997:   EXTRA_MIME_TYPES,",
          "1998:   LISTENING_PORTS,",
          "1999:   DOCUMENT_ROOT,",
          "2000:   SSL_CERTIFICATE,",
          "2001:   SSL_CERTIFICATE_CHAIN,",
          "2002:   NUM_THREADS,",
          "2003:   RUN_AS_USER,",
          "2004:   URL_REWRITE_PATTERN,",
          "2005:   HIDE_FILES,",
          "2006:   REQUEST_TIMEOUT,",
          "2007:   KEEP_ALIVE_TIMEOUT,",
          "2008:   LINGER_TIMEOUT,",
          "2009:   SSL_DO_VERIFY_PEER,",
          "2010:   SSL_CA_PATH,",
          "2011:   SSL_CA_FILE,",
          "2012:   SSL_VERIFY_DEPTH,",
          "2013:   SSL_DEFAULT_VERIFY_PATHS,",
          "2014:   SSL_CIPHER_LIST,",
          "2015:   SSL_PROTOCOL_VERSION,",
          "2016:   SSL_SHORT_TRUST,",
          "2019:   WEBSOCKET_TIMEOUT,",
          "2022:   DECODE_URL,",
          "2025:   LUA_PRELOAD_FILE,",
          "2026:   LUA_SCRIPT_EXTENSIONS,",
          "2027:   LUA_SERVER_PAGE_EXTENSIONS,",
          "2030:   DUKTAPE_SCRIPT_EXTENSIONS,",
          "2034:   WEBSOCKET_ROOT,",
          "2037:   LUA_WEBSOCKET_EXTENSIONS,",
          "2040:   ACCESS_CONTROL_ALLOW_ORIGIN,",
          "2041:   ACCESS_CONTROL_ALLOW_METHODS,",
          "2042:   ACCESS_CONTROL_ALLOW_HEADERS,",
          "2043:   ERROR_PAGES,",
          "2044:   CONFIG_TCP_NODELAY, /* Prepended CONFIG_ to avoid conflict with the",
          "2047:   STATIC_FILE_MAX_AGE,",
          "2050:   STRICT_HTTPS_MAX_AGE,",
          "2053:   ALLOW_SENDFILE_CALL,",
          "2056:   CASE_SENSITIVE_FILES,",
          "2059:   LUA_BACKGROUND_SCRIPT,",
          "2060: #endif",
          "2061:   ADDITIONAL_HEADER,",
          "2062:   MAX_REQUEST_SIZE,",
          "2064:   NUM_OPTIONS",
          "2065:  };",
          "2069:  static struct mg_option config_options[] = {",
          "2070:      {\"cgi_pattern\", CONFIG_TYPE_EXT_PATTERN, \"**.cgi$|**.pl$|**.php$\"},",
          "2071:      {\"cgi_environment\", CONFIG_TYPE_STRING_LIST, NULL},",
          "2072:      {\"put_delete_auth_file\", CONFIG_TYPE_FILE, NULL},",
          "2073:      {\"cgi_interpreter\", CONFIG_TYPE_FILE, NULL},",
          "2074:      {\"protect_uri\", CONFIG_TYPE_STRING_LIST, NULL},",
          "2075:      {\"authentication_domain\", CONFIG_TYPE_STRING, \"mydomain.com\"},",
          "2076:      {\"enable_auth_domain_check\", CONFIG_TYPE_BOOLEAN, \"yes\"},",
          "2077:      {\"ssi_pattern\", CONFIG_TYPE_EXT_PATTERN, \"**.shtml$|**.shtm$\"},",
          "2078:      {\"throttle\", CONFIG_TYPE_STRING_LIST, NULL},",
          "2079:      {\"access_log_file\", CONFIG_TYPE_FILE, NULL},",
          "2080:      {\"enable_directory_listing\", CONFIG_TYPE_BOOLEAN, \"yes\"},",
          "2081:      {\"error_log_file\", CONFIG_TYPE_FILE, NULL},",
          "2082:      {\"global_auth_file\", CONFIG_TYPE_FILE, NULL},",
          "2083:      {\"index_files\",",
          "2084:       CONFIG_TYPE_STRING_LIST,",
          "2086:       \"index.xhtml,index.html,index.htm,index.lp,index.lsp,index.lua,index.\"",
          "2087:       \"cgi,\"",
          "2088:       \"index.shtml,index.php\"},",
          "2092:      {\"enable_keep_alive\", CONFIG_TYPE_BOOLEAN, \"no\"},",
          "2093:      {\"access_control_list\", CONFIG_TYPE_STRING_LIST, NULL},",
          "2094:      {\"extra_mime_types\", CONFIG_TYPE_STRING_LIST, NULL},",
          "2095:      {\"listening_ports\", CONFIG_TYPE_STRING_LIST, \"8080\"},",
          "2096:      {\"document_root\", CONFIG_TYPE_DIRECTORY, NULL},",
          "2097:      {\"ssl_certificate\", CONFIG_TYPE_FILE, NULL},",
          "2098:      {\"ssl_certificate_chain\", CONFIG_TYPE_FILE, NULL},",
          "2099:      {\"num_threads\", CONFIG_TYPE_NUMBER, \"50\"},",
          "2100:      {\"run_as_user\", CONFIG_TYPE_STRING, NULL},",
          "2101:      {\"url_rewrite_patterns\", CONFIG_TYPE_STRING_LIST, NULL},",
          "2102:      {\"hide_files_patterns\", CONFIG_TYPE_EXT_PATTERN, NULL},",
          "2103:      {\"request_timeout_ms\", CONFIG_TYPE_NUMBER, \"30000\"},",
          "2104:      {\"keep_alive_timeout_ms\", CONFIG_TYPE_NUMBER, \"500\"},",
          "2105:      {\"linger_timeout_ms\", CONFIG_TYPE_NUMBER, NULL},",
          "2108:      {\"ssl_verify_peer\", CONFIG_TYPE_BOOLEAN, \"no\"},",
          "2110:      {\"ssl_ca_path\", CONFIG_TYPE_DIRECTORY, NULL},",
          "2111:      {\"ssl_ca_file\", CONFIG_TYPE_FILE, NULL},",
          "2112:      {\"ssl_verify_depth\", CONFIG_TYPE_NUMBER, \"9\"},",
          "2113:      {\"ssl_default_verify_paths\", CONFIG_TYPE_BOOLEAN, \"yes\"},",
          "2114:      {\"ssl_cipher_list\", CONFIG_TYPE_STRING, NULL},",
          "2115:      {\"ssl_protocol_version\", CONFIG_TYPE_NUMBER, \"0\"},",
          "2116:      {\"ssl_short_trust\", CONFIG_TYPE_BOOLEAN, \"no\"},",
          "2118:      {\"websocket_timeout_ms\", CONFIG_TYPE_NUMBER, \"30000\"},",
          "2120:      {\"decode_url\", CONFIG_TYPE_BOOLEAN, \"yes\"},",
          "2123:      {\"lua_preload_file\", CONFIG_TYPE_FILE, NULL},",
          "2124:      {\"lua_script_pattern\", CONFIG_TYPE_EXT_PATTERN, \"**.lua$\"},",
          "2125:      {\"lua_server_page_pattern\", CONFIG_TYPE_EXT_PATTERN, \"**.lp$|**.lsp$\"},",
          "2130:      {\"duktape_script_pattern\", CONFIG_TYPE_EXT_PATTERN, \"**.ssjs$\"},",
          "2134:      {\"websocket_root\", CONFIG_TYPE_DIRECTORY, NULL},",
          "2137:      {\"lua_websocket_pattern\", CONFIG_TYPE_EXT_PATTERN, \"**.lua$\"},",
          "2139:      {\"access_control_allow_origin\", CONFIG_TYPE_STRING, \"*\"},",
          "2140:      {\"access_control_allow_methods\", CONFIG_TYPE_STRING, \"*\"},",
          "2141:      {\"access_control_allow_headers\", CONFIG_TYPE_STRING, \"*\"},",
          "2142:      {\"error_pages\", CONFIG_TYPE_DIRECTORY, NULL},",
          "2143:      {\"tcp_nodelay\", CONFIG_TYPE_NUMBER, \"0\"},",
          "2145:      {\"static_file_max_age\", CONFIG_TYPE_NUMBER, \"3600\"},",
          "2148:      {\"strict_transport_security_max_age\", CONFIG_TYPE_NUMBER, NULL},",
          "2151:      {\"allow_sendfile_call\", CONFIG_TYPE_BOOLEAN, \"yes\"},",
          "2154:      {\"case_sensitive\", CONFIG_TYPE_BOOLEAN, \"no\"},",
          "2157:      {\"lua_background_script\", CONFIG_TYPE_FILE, NULL},",
          "2159:      {\"additional_header\", CONFIG_TYPE_STRING_MULTILINE, NULL},",
          "2160:      {\"max_request_size\", CONFIG_TYPE_NUMBER, \"16384\"},",
          "2162:      {NULL, CONFIG_TYPE_UNKNOWN, NULL}};",
          "2167:  mg_static_assert((sizeof(config_options) / sizeof(config_options[0]))",
          "2168:                       == (NUM_OPTIONS + 1),",
          "2169:                   \"config_options and enum not sync\");",
          "2172:  enum { REQUEST_HANDLER, WEBSOCKET_HANDLER, AUTH_HANDLER };",
          "2175:  struct mg_handler_info {",
          "2177:   char *uri;",
          "2178:   size_t uri_len;",
          "2181:   int handler_type;",
          "2184:   mg_request_handler handler;",
          "2187:   mg_websocket_connect_handler connect_handler;",
          "2188:   mg_websocket_ready_handler ready_handler;",
          "2189:   mg_websocket_data_handler data_handler;",
          "2190:   mg_websocket_close_handler close_handler;",
          "2193:   struct mg_websocket_subprotocols *subprotocols;",
          "2196:   mg_authorization_handler auth_handler;",
          "2199:   void *cbdata;",
          "2202:   struct mg_handler_info *next;",
          "2203:  };",
          "2206:  struct mg_context {",
          "2212:   int context_type;              /* 1 = server context,",
          "2216:   struct socket *listening_sockets;",
          "2217:   struct pollfd *listening_socket_fds;",
          "2218:   unsigned int num_listening_sockets;",
          "2223:   struct socket *client_socks;",
          "2224:   void **client_wait_events;",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "2218: #endif",
          "2241: #if defined(USE_LUA) && defined(USE_WEBSOCKET)",
          "2244: #endif",
          "2246: #if defined(USE_TIMERS)",
          "2248: #endif",
          "2250: #if defined(USE_LUA)",
          "2252: #endif",
          "2254: #if defined(USE_SERVER_STATS)",
          "2260: #endif",
          "2264: #if defined(USE_SERVER_STATS)",
          "2319: #if defined(USE_LUA) && defined(USE_WEBSOCKET)",
          "2321: #endif",
          "2335: #if defined(USE_WEBSOCKET)",
          "2337: #else",
          "2338: #define is_websocket_protocol(conn) (0)",
          "2339: #endif",
          "",
          "[Removed Lines]",
          "2223:  unsigned int",
          "2226:  struct mg_connection *worker_connections; /* The connection struct, pre-",
          "2229:  time_t start_time; /* Server start time, used for authentication",
          "2239:  struct mg_handler_info *handlers;",
          "2243:  struct mg_shared_lua_websocket_list *shared_lua_websockets;",
          "2247:  struct ttimers *timers;",
          "2251:  void *lua_background_state;",
          "2255:  int active_connections;",
          "2256:  int max_connections;",
          "2257:  int64_t total_connections;",
          "2258:  int64_t total_requests;",
          "2259:  struct mg_memory_stat ctx_memory;",
          "2261: };",
          "2265: static struct mg_memory_stat mg_common_memory = {0, 0, 0};",
          "2267: static struct mg_memory_stat *",
          "2268: get_memory_stat(struct mg_context *ctx)",
          "2269: {",
          "2270:  if (ctx) {",
          "2271:   return &(ctx->ctx_memory);",
          "2272:  }",
          "2273:  return &mg_common_memory;",
          "2274: }",
          "2275: #endif",
          "2278: struct mg_connection {",
          "2279:  int connection_type; /* 0 none",
          "2284:  struct mg_request_info request_info;",
          "2285:  struct mg_response_info response_info;",
          "2287:  struct mg_context *ctx;",
          "2292:  time_t conn_birth_time;   /* Time (wall clock) when connection was",
          "2294:  struct timespec req_time; /* Time (since system start) when the request",
          "2299:  int is_chunked;           /* Transfer-Encoding is chunked: 0=no, 1=yes:",
          "2306:  int in_error_handler; /* 1 if in handler for user defined error",
          "2313:  int throttle;         /* Throttling, bytes/sec. <= 0 means no",
          "2317:  pthread_mutex_t mutex;       /* Used by mg_(un)lock_connection to ensure",
          "2324: };",
          "2328: struct de {",
          "2329:  struct mg_connection *conn;",
          "2330:  char *file_name;",
          "2331:  struct mg_file_stat file;",
          "2332: };",
          "2336: static int is_websocket_protocol(const struct mg_connection *conn);",
          "",
          "[Added Lines]",
          "2236:   unsigned int",
          "2239:   struct mg_connection *",
          "2240:       worker_connections; /* The connection struct, pre-",
          "2243:   time_t start_time; /* Server start time, used for authentication",
          "2253:   struct mg_handler_info *handlers;",
          "2257:   struct mg_shared_lua_websocket_list *shared_lua_websockets;",
          "2261:   struct ttimers *timers;",
          "2265:   void *lua_background_state;",
          "2269:   int active_connections;",
          "2270:   int max_connections;",
          "2271:   int64_t total_connections;",
          "2272:   int64_t total_requests;",
          "2273:   struct mg_memory_stat ctx_memory;",
          "2275:  };",
          "2279:  static struct mg_memory_stat mg_common_memory = {0, 0, 0};",
          "2281:  static struct mg_memory_stat *get_memory_stat(struct mg_context * ctx)",
          "2282:  {",
          "2283:   if (ctx) {",
          "2284:    return &(ctx->ctx_memory);",
          "2285:   }",
          "2286:   return &mg_common_memory;",
          "2287:  }",
          "2288: #endif",
          "2291:  struct mg_connection {",
          "2292:   int connection_type; /* 0 none",
          "2297:   struct mg_request_info request_info;",
          "2298:   struct mg_response_info response_info;",
          "2300:   struct mg_context *ctx;",
          "2305:   time_t conn_birth_time;   /* Time (wall clock) when connection was",
          "2307:   struct timespec req_time; /* Time (since system start) when the request",
          "2312:   int is_chunked;           /* Transfer-Encoding is chunked: 0=no, 1=yes:",
          "2319:   int in_error_handler; /* 1 if in handler for user defined error",
          "2321:   int handled_requests; /* Number of requests handled by this connection",
          "2327:   int throttle;         /* Throttling, bytes/sec. <= 0 means no",
          "2331:   pthread_mutex_t mutex;       /* Used by mg_(un)lock_connection to ensure",
          "2338:  };",
          "2342:  struct de {",
          "2343:   struct mg_connection *conn;",
          "2344:   char *file_name;",
          "2345:   struct mg_file_stat file;",
          "2346:  };",
          "2350:  static int is_websocket_protocol(const struct mg_connection *conn);",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "2347: #pragma pack(push, 8)",
          "2354: #pragma pack(pop)",
          "2356: #elif defined(__linux__)",
          "",
          "[Removed Lines]",
          "2348: typedef struct tagTHREADNAME_INFO {",
          "2353: } THREADNAME_INFO;",
          "",
          "[Added Lines]",
          "2362:  typedef struct tagTHREADNAME_INFO {",
          "2367:  } THREADNAME_INFO;",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "2417: #if !defined(__linux__) && !defined(_WIN32) && defined(ALTERNATIVE_QUEUE)",
          "2437:  }",
          "2443:  }",
          "2478: #endif",
          "2489: #if defined(_WIN32)",
          "2490: #if defined(_MSC_VER)",
          "2508: #elif defined(__MINGW32__)",
          "2510: #endif",
          "",
          "[Removed Lines]",
          "2419: struct posix_event {",
          "2420:  pthread_mutex_t mutex;",
          "2421:  pthread_cond_t cond;",
          "2422: };",
          "2425: static void *",
          "2426: event_create(void)",
          "2427: {",
          "2428:  struct posix_event *ret = mg_malloc(sizeof(struct posix_event));",
          "2429:  if (ret == 0) {",
          "2431:   return 0;",
          "2432:  }",
          "2433:  if (0 != pthread_mutex_init(&(ret->mutex), NULL)) {",
          "2435:   mg_free(ret);",
          "2436:   return 0;",
          "2438:  if (0 != pthread_cond_init(&(ret->cond), NULL)) {",
          "2440:   pthread_mutex_destroy(&(ret->mutex));",
          "2441:   mg_free(ret);",
          "2442:   return 0;",
          "2444:  return (void *)ret;",
          "2445: }",
          "2448: static int",
          "2449: event_wait(void *eventhdl)",
          "2450: {",
          "2451:  struct posix_event *ev = (struct posix_event *)eventhdl;",
          "2452:  pthread_mutex_lock(&(ev->mutex));",
          "2453:  pthread_cond_wait(&(ev->cond), &(ev->mutex));",
          "2454:  pthread_mutex_unlock(&(ev->mutex));",
          "2455:  return 1;",
          "2456: }",
          "2459: static int",
          "2460: event_signal(void *eventhdl)",
          "2461: {",
          "2462:  struct posix_event *ev = (struct posix_event *)eventhdl;",
          "2463:  pthread_mutex_lock(&(ev->mutex));",
          "2464:  pthread_cond_signal(&(ev->cond));",
          "2465:  pthread_mutex_unlock(&(ev->mutex));",
          "2466:  return 1;",
          "2467: }",
          "2470: static void",
          "2471: event_destroy(void *eventhdl)",
          "2472: {",
          "2473:  struct posix_event *ev = (struct posix_event *)eventhdl;",
          "2474:  pthread_cond_destroy(&(ev->cond));",
          "2475:  pthread_mutex_destroy(&(ev->mutex));",
          "2476:  mg_free(ev);",
          "2477: }",
          "2481: static void",
          "2482: mg_set_thread_name(const char *name)",
          "2483: {",
          "2486:  mg_snprintf(",
          "2487:      NULL, NULL, threadName, sizeof(threadName), \"civetweb-%s\", name);",
          "2492:  __try",
          "2493:  {",
          "2494:   THREADNAME_INFO info;",
          "2495:   info.dwType = 0x1000;",
          "2496:   info.szName = threadName;",
          "2497:   info.dwThreadID = ~0U;",
          "2498:   info.dwFlags = 0;",
          "2500:   RaiseException(0x406D1388,",
          "2501:                  0,",
          "2502:                  sizeof(info) / sizeof(ULONG_PTR),",
          "2503:                  (ULONG_PTR *)&info);",
          "2504:  }",
          "2505:  __except(EXCEPTION_EXECUTE_HANDLER)",
          "2506:  {",
          "2507:  }",
          "",
          "[Added Lines]",
          "2433:  struct posix_event {",
          "2434:   pthread_mutex_t mutex;",
          "2435:   pthread_cond_t cond;",
          "2436:  };",
          "2439:  static void *event_create(void)",
          "2440:  {",
          "2441:   struct posix_event *ret = mg_malloc(sizeof(struct posix_event));",
          "2442:   if (ret == 0) {",
          "2444:    return 0;",
          "2445:   }",
          "2446:   if (0 != pthread_mutex_init(&(ret->mutex), NULL)) {",
          "2448:    mg_free(ret);",
          "2449:    return 0;",
          "2450:   }",
          "2451:   if (0 != pthread_cond_init(&(ret->cond), NULL)) {",
          "2453:    pthread_mutex_destroy(&(ret->mutex));",
          "2454:    mg_free(ret);",
          "2455:    return 0;",
          "2456:   }",
          "2457:   return (void *)ret;",
          "2461:  static int event_wait(void *eventhdl)",
          "2462:  {",
          "2463:   struct posix_event *ev = (struct posix_event *)eventhdl;",
          "2464:   pthread_mutex_lock(&(ev->mutex));",
          "2465:   pthread_cond_wait(&(ev->cond), &(ev->mutex));",
          "2466:   pthread_mutex_unlock(&(ev->mutex));",
          "2467:   return 1;",
          "2471:  static int event_signal(void *eventhdl)",
          "2472:  {",
          "2473:   struct posix_event *ev = (struct posix_event *)eventhdl;",
          "2474:   pthread_mutex_lock(&(ev->mutex));",
          "2475:   pthread_cond_signal(&(ev->cond));",
          "2476:   pthread_mutex_unlock(&(ev->mutex));",
          "2477:   return 1;",
          "2478:  }",
          "2481:  static void event_destroy(void *eventhdl)",
          "2482:  {",
          "2483:   struct posix_event *ev = (struct posix_event *)eventhdl;",
          "2484:   pthread_cond_destroy(&(ev->cond));",
          "2485:   pthread_mutex_destroy(&(ev->mutex));",
          "2486:   mg_free(ev);",
          "2487:  }",
          "2491:  static void mg_set_thread_name(const char *name)",
          "2492:  {",
          "2495:   mg_snprintf(",
          "2496:       NULL, NULL, threadName, sizeof(threadName), \"civetweb-%s\", name);",
          "2501:   __try",
          "2502:   {",
          "2503:    THREADNAME_INFO info;",
          "2504:    info.dwType = 0x1000;",
          "2505:    info.szName = threadName;",
          "2506:    info.dwThreadID = ~0U;",
          "2507:    info.dwFlags = 0;",
          "2509:    RaiseException(0x406D1388,",
          "2510:                   0,",
          "2511:                   sizeof(info) / sizeof(ULONG_PTR),",
          "2512:                   (ULONG_PTR *)&info);",
          "2513:   }",
          "2514:   __except(EXCEPTION_EXECUTE_HANDLER)",
          "2515:   {",
          "2516:   }",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "2517:  (void)prctl(PR_SET_NAME, threadName, 0, 0, 0);",
          "2518: #endif",
          "2521: void",
          "2522: mg_set_thread_name(const char *threadName)",
          "",
          "[Removed Lines]",
          "2519: }",
          "",
          "[Added Lines]",
          "2528:  }",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "2528: #if defined(MG_LEGACY_INTERFACE)",
          "2544: #endif",
          "",
          "[Removed Lines]",
          "2529: const char **",
          "2530: mg_get_valid_option_names(void)",
          "2531: {",
          "2533:  static const char *",
          "2534:      data[2 * sizeof(config_options) / sizeof(config_options[0])] = {0};",
          "2535:  int i;",
          "2537:  for (i = 0; config_options[i].name != NULL; i++) {",
          "2538:   data[i * 2] = config_options[i].name;",
          "2539:   data[i * 2 + 1] = config_options[i].default_value;",
          "2540:  }",
          "2542:  return data;",
          "2543: }",
          "2547: const struct mg_option *",
          "2548: mg_get_valid_options(void)",
          "2549: {",
          "2550:  return config_options;",
          "2551: }",
          "",
          "[Added Lines]",
          "2538:  const char **mg_get_valid_option_names(void)",
          "2539:  {",
          "2541:   static const char *",
          "2542:       data[2 * sizeof(config_options) / sizeof(config_options[0])] = {0};",
          "2543:   int i;",
          "2545:   for (i = 0; config_options[i].name != NULL; i++) {",
          "2546:    data[i * 2] = config_options[i].name;",
          "2547:    data[i * 2 + 1] = config_options[i].default_value;",
          "2548:   }",
          "2550:   return data;",
          "2551:  }",
          "2555:  const struct mg_option *mg_get_valid_options(void)",
          "2556:  {",
          "2557:   return config_options;",
          "2558:  }",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "2564: #define MG_FOPEN_MODE_APPEND (4)",
          "2575: #if defined(MG_USE_OPEN_FILE)",
          "2611:   }",
          "2616: #else",
          "2617:  (void)conn;",
          "",
          "[Removed Lines]",
          "2569: static int",
          "2570: open_file_in_memory(const struct mg_connection *conn,",
          "2571:                     const char *path,",
          "2572:                     struct mg_file *filep,",
          "2573:                     int mode)",
          "2574: {",
          "2577:  size_t size = 0;",
          "2578:  const char *buf = NULL;",
          "2579:  if (!conn) {",
          "2580:   return 0;",
          "2581:  }",
          "2583:  if ((mode != MG_FOPEN_MODE_NONE) && (mode != MG_FOPEN_MODE_READ)) {",
          "2584:   return 0;",
          "2585:  }",
          "2587:  if (conn->ctx->callbacks.open_file) {",
          "2588:   buf = conn->ctx->callbacks.open_file(conn, path, &size);",
          "2589:   if (buf != NULL) {",
          "2590:    if (filep == NULL) {",
          "2594:     return 1;",
          "2595:    }",
          "2599:    filep->access.membuf = buf;",
          "2600:    filep->access.fp = NULL;",
          "2603:    filep->stat.size = size;",
          "2607:    filep->stat.last_modified = time(NULL);",
          "2609:    filep->stat.is_directory = 0;",
          "2610:    filep->stat.is_gzipped = 0;",
          "2612:  }",
          "2614:  return (buf != NULL);",
          "",
          "[Added Lines]",
          "2577:  static int open_file_in_memory(const struct mg_connection *conn,",
          "2578:                                 const char *path,",
          "2579:                                 struct mg_file *filep,",
          "2580:                                 int mode)",
          "2581:  {",
          "2584:   size_t size = 0;",
          "2585:   const char *buf = NULL;",
          "2586:   if (!conn) {",
          "2587:    return 0;",
          "2588:   }",
          "2590:   if ((mode != MG_FOPEN_MODE_NONE) && (mode != MG_FOPEN_MODE_READ)) {",
          "2591:    return 0;",
          "2592:   }",
          "2594:   if (conn->ctx->callbacks.open_file) {",
          "2595:    buf = conn->ctx->callbacks.open_file(conn, path, &size);",
          "2596:    if (buf != NULL) {",
          "2597:     if (filep == NULL) {",
          "2602:      return 1;",
          "2603:     }",
          "2608:     filep->access.membuf = buf;",
          "2609:     filep->access.fp = NULL;",
          "2612:     filep->stat.size = size;",
          "2616:     filep->stat.last_modified = time(NULL);",
          "2618:     filep->stat.is_directory = 0;",
          "2619:     filep->stat.is_gzipped = 0;",
          "2620:    }",
          "2623:   return (buf != NULL);",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "2622:  return 0;",
          "2624: #endif",
          "2640:  }",
          "2681: #ifdef _WIN32",
          "2695:    }",
          "2697: #else",
          "2699:   switch (mode) {",
          "",
          "[Removed Lines]",
          "2625: }",
          "2628: static int",
          "2629: is_file_in_memory(const struct mg_connection *conn, const char *path)",
          "2630: {",
          "2631:  return open_file_in_memory(conn, path, NULL, MG_FOPEN_MODE_NONE);",
          "2632: }",
          "2635: static int",
          "2636: is_file_opened(const struct mg_file_access *fileacc)",
          "2637: {",
          "2638:  if (!fileacc) {",
          "2639:   return 0;",
          "2641:  return (fileacc->membuf != NULL) || (fileacc->fp != NULL);",
          "2642: }",
          "2645: static int mg_stat(const struct mg_connection *conn,",
          "2646:                    const char *path,",
          "2647:                    struct mg_file_stat *filep);",
          "2656: static int",
          "2657: mg_fopen(const struct mg_connection *conn,",
          "2658:          const char *path,",
          "2659:          int mode,",
          "2660:          struct mg_file *filep)",
          "2661: {",
          "2662:  int found;",
          "2664:  if (!filep) {",
          "2665:   return 0;",
          "2666:  }",
          "2667:  filep->access.fp = NULL;",
          "2668:  filep->access.membuf = NULL;",
          "2670:  if (!is_file_in_memory(conn, path)) {",
          "2674:   found = mg_stat(conn, path, &(filep->stat));",
          "2676:   if ((mode == MG_FOPEN_MODE_READ) && (!found)) {",
          "2678:    return 0;",
          "2679:   }",
          "2682:   {",
          "2683:    wchar_t wbuf[PATH_MAX];",
          "2684:    path_to_unicode(conn, path, wbuf, ARRAY_SIZE(wbuf));",
          "2685:    switch (mode) {",
          "2686:    case MG_FOPEN_MODE_READ:",
          "2687:     filep->access.fp = _wfopen(wbuf, L\"rb\");",
          "2688:     break;",
          "2689:    case MG_FOPEN_MODE_WRITE:",
          "2690:     filep->access.fp = _wfopen(wbuf, L\"wb\");",
          "2691:     break;",
          "2692:    case MG_FOPEN_MODE_APPEND:",
          "2693:     filep->access.fp = _wfopen(wbuf, L\"ab\");",
          "2694:     break;",
          "2696:   }",
          "",
          "[Added Lines]",
          "2634:  }",
          "2637:  static int is_file_in_memory(const struct mg_connection *conn,",
          "2638:                               const char *path)",
          "2639:  {",
          "2640:   return open_file_in_memory(conn, path, NULL, MG_FOPEN_MODE_NONE);",
          "2641:  }",
          "2644:  static int is_file_opened(const struct mg_file_access *fileacc)",
          "2645:  {",
          "2646:   if (!fileacc) {",
          "2647:    return 0;",
          "2648:   }",
          "2649:   return (fileacc->membuf != NULL) || (fileacc->fp != NULL);",
          "2653:  static int mg_stat(const struct mg_connection *conn,",
          "2654:                     const char *path,",
          "2655:                     struct mg_file_stat *filep);",
          "2664:  static int mg_fopen(const struct mg_connection *conn,",
          "2665:                      const char *path,",
          "2666:                      int mode,",
          "2667:                      struct mg_file *filep)",
          "2668:  {",
          "2669:   int found;",
          "2671:   if (!filep) {",
          "2672:    return 0;",
          "2673:   }",
          "2674:   filep->access.fp = NULL;",
          "2675:   filep->access.membuf = NULL;",
          "2677:   if (!is_file_in_memory(conn, path)) {",
          "2681:    found = mg_stat(conn, path, &(filep->stat));",
          "2683:    if ((mode == MG_FOPEN_MODE_READ) && (!found)) {",
          "2685:     return 0;",
          "2686:    }",
          "2689:    {",
          "2690:     wchar_t wbuf[PATH_MAX];",
          "2691:     path_to_unicode(conn, path, wbuf, ARRAY_SIZE(wbuf));",
          "2692:     switch (mode) {",
          "2693:     case MG_FOPEN_MODE_READ:",
          "2694:      filep->access.fp = _wfopen(wbuf, L\"rb\");",
          "2695:      break;",
          "2696:     case MG_FOPEN_MODE_WRITE:",
          "2697:      filep->access.fp = _wfopen(wbuf, L\"wb\");",
          "2698:      break;",
          "2699:     case MG_FOPEN_MODE_APPEND:",
          "2700:      filep->access.fp = _wfopen(wbuf, L\"ab\");",
          "2701:      break;",
          "2702:     }",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "2709:   }",
          "2711: #endif",
          "2728:   }",
          "2746:   }",
          "2749:  }",
          "2759:  }",
          "2780:  }",
          "2806:  }",
          "2828:    }",
          "2829:   }",
          "2851:   }",
          "2855: #ifdef __clang__",
          "2856: #pragma clang diagnostic push",
          "",
          "[Removed Lines]",
          "2712:   if (!found) {",
          "2716:    found = mg_stat(conn, path, &(filep->stat));",
          "2717:    (void)found;",
          "2718:   }",
          "2721:   return (filep->access.fp != NULL);",
          "2723:  } else {",
          "2725:   if (open_file_in_memory(conn, path, filep, mode)) {",
          "2727:    return (filep->access.membuf != NULL);",
          "2729:  }",
          "2732:  return 0;",
          "2733: }",
          "2737: static int",
          "2738: mg_fclose(struct mg_file_access *fileacc)",
          "2739: {",
          "2740:  int ret = -1;",
          "2741:  if (fileacc != NULL) {",
          "2742:   if (fileacc->fp != NULL) {",
          "2743:    ret = fclose(fileacc->fp);",
          "2744:   } else if (fileacc->membuf != NULL) {",
          "2745:    ret = 0;",
          "2748:   memset(fileacc, 0, sizeof(*fileacc));",
          "2750:  return ret;",
          "2751: }",
          "2754: static void",
          "2755: mg_strlcpy(register char *dst, register const char *src, size_t n)",
          "2756: {",
          "2757:  for (; *src != '\\0' && n > 1; n--) {",
          "2761: }",
          "2764: static int",
          "2765: lowercase(const char *s)",
          "2766: {",
          "2767:  return tolower(*(const unsigned char *)s);",
          "2768: }",
          "2771: int",
          "2772: mg_strncasecmp(const char *s1, const char *s2, size_t len)",
          "2773: {",
          "2774:  int diff = 0;",
          "2776:  if (len > 0) {",
          "2777:   do {",
          "2778:    diff = lowercase(s1++) - lowercase(s2++);",
          "2779:   } while (diff == 0 && s1[-1] != '\\0' && --len > 0);",
          "2782:  return diff;",
          "2783: }",
          "2786: int",
          "2787: mg_strcasecmp(const char *s1, const char *s2)",
          "2788: {",
          "2789:  int diff;",
          "2791:  do {",
          "2792:   diff = lowercase(s1++) - lowercase(s2++);",
          "2793:  } while (diff == 0 && s1[-1] != '\\0');",
          "2795:  return diff;",
          "2796: }",
          "2799: static char *",
          "2800: mg_strndup(const char *ptr, size_t len)",
          "2801: {",
          "2802:  char *p;",
          "2804:  if ((p = (char *)mg_malloc(len + 1)) != NULL) {",
          "2805:   mg_strlcpy(p, ptr, len + 1);",
          "2808:  return p;",
          "2809: }",
          "2812: static char *",
          "2813: mg_strdup(const char *str)",
          "2814: {",
          "2815:  return mg_strndup(str, strlen(str));",
          "2816: }",
          "2819: static const char *",
          "2820: mg_strcasestr(const char *big_str, const char *small_str)",
          "2821: {",
          "2822:  size_t i, big_len = strlen(big_str), small_len = strlen(small_str);",
          "2824:  if (big_len >= small_len) {",
          "2825:   for (i = 0; i <= (big_len - small_len); i++) {",
          "2826:    if (mg_strncasecmp(big_str + i, small_str, small_len) == 0) {",
          "2827:     return big_str + i;",
          "2830:  }",
          "2832:  return NULL;",
          "2833: }",
          "2838: static void",
          "2839: mg_vsnprintf(const struct mg_connection *conn,",
          "2840:              int *truncated,",
          "2841:              char *buf,",
          "2842:              size_t buflen,",
          "2843:              const char *fmt,",
          "2844:              va_list ap)",
          "2845: {",
          "2846:  int n, ok;",
          "2848:  if (buflen == 0) {",
          "2849:   if (truncated) {",
          "2852:   return;",
          "2853:  }",
          "",
          "[Added Lines]",
          "2719:    if (!found) {",
          "2723:     found = mg_stat(conn, path, &(filep->stat));",
          "2724:     (void)found;",
          "2725:    }",
          "2728:    return (filep->access.fp != NULL);",
          "2730:   } else {",
          "2732:    if (open_file_in_memory(conn, path, filep, mode)) {",
          "2734:     return (filep->access.membuf != NULL);",
          "2735:    }",
          "2739:   return 0;",
          "2740:  }",
          "2744:  static int mg_fclose(struct mg_file_access * fileacc)",
          "2745:  {",
          "2746:   int ret = -1;",
          "2747:   if (fileacc != NULL) {",
          "2748:    if (fileacc->fp != NULL) {",
          "2749:     ret = fclose(fileacc->fp);",
          "2750:    } else if (fileacc->membuf != NULL) {",
          "2751:     ret = 0;",
          "2752:    }",
          "2754:    memset(fileacc, 0, sizeof(*fileacc));",
          "2756:   return ret;",
          "2760:  static void mg_strlcpy(register char *dst,",
          "2761:                         register const char *src,",
          "2762:                         size_t n)",
          "2763:  {",
          "2764:   for (; *src != '\\0' && n > 1; n--) {",
          "2766:   }",
          "2771:  static int lowercase(const char *s)",
          "2772:  {",
          "2773:   return tolower(*(const unsigned char *)s);",
          "2774:  }",
          "2777:  int mg_strncasecmp(const char *s1, const char *s2, size_t len)",
          "2778:  {",
          "2779:   int diff = 0;",
          "2781:   if (len > 0) {",
          "2782:    do {",
          "2783:     diff = lowercase(s1++) - lowercase(s2++);",
          "2784:    } while (diff == 0 && s1[-1] != '\\0' && --len > 0);",
          "2785:   }",
          "2787:   return diff;",
          "2791:  int mg_strcasecmp(const char *s1, const char *s2)",
          "2792:  {",
          "2793:   int diff;",
          "2795:   do {",
          "2796:    diff = lowercase(s1++) - lowercase(s2++);",
          "2797:   } while (diff == 0 && s1[-1] != '\\0');",
          "2799:   return diff;",
          "2800:  }",
          "2803:  static char *mg_strndup(const char *ptr, size_t len)",
          "2804:  {",
          "2805:   char *p;",
          "2807:   if ((p = (char *)mg_malloc(len + 1)) != NULL) {",
          "2808:    mg_strlcpy(p, ptr, len + 1);",
          "2809:   }",
          "2811:   return p;",
          "2815:  static char *mg_strdup(const char *str)",
          "2816:  {",
          "2817:   return mg_strndup(str, strlen(str));",
          "2818:  }",
          "2821:  static const char *mg_strcasestr(const char *big_str, const char *small_str)",
          "2822:  {",
          "2823:   size_t i, big_len = strlen(big_str), small_len = strlen(small_str);",
          "2825:   if (big_len >= small_len) {",
          "2826:    for (i = 0; i <= (big_len - small_len); i++) {",
          "2827:     if (mg_strncasecmp(big_str + i, small_str, small_len) == 0) {",
          "2828:      return big_str + i;",
          "2829:     }",
          "2833:   return NULL;",
          "2834:  }",
          "2839:  static void mg_vsnprintf(const struct mg_connection *conn,",
          "2840:                           int *truncated,",
          "2841:                           char *buf,",
          "2842:                           size_t buflen,",
          "2843:                           const char *fmt,",
          "2844:                           va_list ap)",
          "2845:  {",
          "2846:   int n, ok;",
          "2848:   if (buflen == 0) {",
          "2849:    if (truncated) {",
          "2851:    }",
          "2852:    return;",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "2860: #endif",
          "2865: #ifdef __clang__",
          "2866: #pragma clang diagnostic pop",
          "2867: #endif",
          "2876:   }",
          "2882:  }",
          "2911:   }",
          "2912:  }",
          "2927:  }",
          "2950:  }",
          "2959:  }",
          "2964: #if defined(MG_LEGACY_INTERFACE)",
          "2976: #if defined(USE_IPV6)",
          "2980: #endif",
          "2982:  }",
          "2985: #endif",
          "3009: #if defined(USE_IPV6)",
          "3026:   }",
          "3027:  }",
          "3051: #if defined(USE_IPV6)",
          "3061: #endif",
          "3078:  }",
          "3125:   }",
          "3138:     fprintf(fi.access.fp,",
          "3152:   }",
          "3153:  }",
          "3199:  }",
          "3212:  }",
          "3227: #ifdef __clang__",
          "3228: #pragma clang diagnostic push",
          "",
          "[Removed Lines]",
          "2862:  n = (int)vsnprintf_impl(buf, buflen, fmt, ap);",
          "2863:  ok = (n >= 0) && ((size_t)n < buflen);",
          "2869:  if (ok) {",
          "2870:   if (truncated) {",
          "2872:   }",
          "2873:  } else {",
          "2874:   if (truncated) {",
          "2877:   mg_cry(conn,",
          "2878:          \"truncating vsnprintf buffer: [%.*s]\",",
          "2879:          (int)((buflen > 200) ? 200 : (buflen - 1)),",
          "2880:          buf);",
          "2881:   n = (int)buflen - 1;",
          "2883:  buf[n] = '\\0';",
          "2884: }",
          "2887: static void",
          "2888: mg_snprintf(const struct mg_connection *conn,",
          "2889:             int *truncated,",
          "2890:             char *buf,",
          "2891:             size_t buflen,",
          "2892:             const char *fmt,",
          "2893:             ...)",
          "2894: {",
          "2895:  va_list ap;",
          "2897:  va_start(ap, fmt);",
          "2898:  mg_vsnprintf(conn, truncated, buf, buflen, fmt, ap);",
          "2899:  va_end(ap);",
          "2900: }",
          "2903: static int",
          "2904: get_option_index(const char *name)",
          "2905: {",
          "2906:  int i;",
          "2908:  for (i = 0; config_options[i].name != NULL; i++) {",
          "2909:   if (strcmp(config_options[i].name, name) == 0) {",
          "2910:    return i;",
          "2913:  return -1;",
          "2914: }",
          "2917: const char *",
          "2918: mg_get_option(const struct mg_context *ctx, const char *name)",
          "2919: {",
          "2920:  int i;",
          "2921:  if ((i = get_option_index(name)) == -1) {",
          "2922:   return NULL;",
          "2923:  } else if (!ctx || ctx->config[i] == NULL) {",
          "2924:   return \"\";",
          "2925:  } else {",
          "2926:   return ctx->config[i];",
          "2928: }",
          "2931: struct mg_context *",
          "2932: mg_get_context(const struct mg_connection *conn)",
          "2933: {",
          "2934:  return (conn == NULL) ? (struct mg_context *)NULL : (conn->ctx);",
          "2935: }",
          "2938: void *",
          "2939: mg_get_user_data(const struct mg_context *ctx)",
          "2940: {",
          "2941:  return (ctx == NULL) ? NULL : ctx->user_data;",
          "2942: }",
          "2945: void",
          "2946: mg_set_user_connection_data(struct mg_connection *conn, void *data)",
          "2947: {",
          "2948:  if (conn != NULL) {",
          "2949:   conn->request_info.conn_data = data;",
          "2951: }",
          "2954: void *",
          "2955: mg_get_user_connection_data(const struct mg_connection *conn)",
          "2956: {",
          "2957:  if (conn != NULL) {",
          "2958:   return conn->request_info.conn_data;",
          "2960:  return NULL;",
          "2961: }",
          "2966: size_t",
          "2967: mg_get_ports(const struct mg_context *ctx, size_t size, int *ports, int *ssl)",
          "2968: {",
          "2969:  size_t i;",
          "2970:  if (!ctx) {",
          "2971:   return 0;",
          "2972:  }",
          "2973:  for (i = 0; i < size && i < ctx->num_listening_sockets; i++) {",
          "2974:   ssl[i] = ctx->listening_sockets[i].is_ssl;",
          "2975:   ports[i] =",
          "2977:       (ctx->listening_sockets[i].lsa.sa.sa_family == AF_INET6)",
          "2978:           ? ntohs(ctx->listening_sockets[i].lsa.sin6.sin6_port)",
          "2979:           :",
          "2981:           ntohs(ctx->listening_sockets[i].lsa.sin.sin_port);",
          "2983:  return i;",
          "2984: }",
          "2988: int",
          "2989: mg_get_server_ports(const struct mg_context *ctx,",
          "2990:                     int size,",
          "2991:                     struct mg_server_ports *ports)",
          "2992: {",
          "2993:  int i, cnt = 0;",
          "2995:  if (size <= 0) {",
          "2996:   return -1;",
          "2997:  }",
          "2998:  memset(ports, 0, sizeof(*ports) * (size_t)size);",
          "2999:  if (!ctx) {",
          "3000:   return -1;",
          "3001:  }",
          "3002:  if (!ctx->listening_sockets) {",
          "3003:   return -1;",
          "3004:  }",
          "3006:  for (i = 0; (i < size) && (i < (int)ctx->num_listening_sockets); i++) {",
          "3008:   ports[cnt].port =",
          "3010:       (ctx->listening_sockets[i].lsa.sa.sa_family == AF_INET6)",
          "3011:           ? ntohs(ctx->listening_sockets[i].lsa.sin6.sin6_port)",
          "3012:           :",
          "3013: #endif",
          "3014:           ntohs(ctx->listening_sockets[i].lsa.sin.sin_port);",
          "3015:   ports[cnt].is_ssl = ctx->listening_sockets[i].is_ssl;",
          "3016:   ports[cnt].is_redirect = ctx->listening_sockets[i].ssl_redir;",
          "3018:   if (ctx->listening_sockets[i].lsa.sa.sa_family == AF_INET) {",
          "3020:    ports[cnt].protocol = 1;",
          "3021:    cnt++;",
          "3022:   } else if (ctx->listening_sockets[i].lsa.sa.sa_family == AF_INET6) {",
          "3024:    ports[cnt].protocol = 3;",
          "3025:    cnt++;",
          "3029:  return cnt;",
          "3030: }",
          "3033: static void",
          "3034: sockaddr_to_string(char *buf, size_t len, const union usa *usa)",
          "3035: {",
          "3036:  buf[0] = '\\0';",
          "3038:  if (!usa) {",
          "3039:   return;",
          "3040:  }",
          "3042:  if (usa->sa.sa_family == AF_INET) {",
          "3043:   getnameinfo(&usa->sa,",
          "3044:               sizeof(usa->sin),",
          "3045:               buf,",
          "3046:               (unsigned)len,",
          "3047:               NULL,",
          "3048:               0,",
          "3049:               NI_NUMERICHOST);",
          "3050:  }",
          "3052:  else if (usa->sa.sa_family == AF_INET6) {",
          "3053:   getnameinfo(&usa->sa,",
          "3054:               sizeof(usa->sin6),",
          "3055:               buf,",
          "3056:               (unsigned)len,",
          "3057:               NULL,",
          "3058:               0,",
          "3059:               NI_NUMERICHOST);",
          "3060:  }",
          "3062: }",
          "3067: static void",
          "3068: gmt_time_string(char *buf, size_t buf_len, time_t *t)",
          "3069: {",
          "3070:  struct tm *tm;",
          "3072:  tm = ((t != NULL) ? gmtime(t) : NULL);",
          "3073:  if (tm != NULL) {",
          "3074:   strftime(buf, buf_len, \"%a, %d %b %Y %H:%M:%S GMT\", tm);",
          "3075:  } else {",
          "3076:   mg_strlcpy(buf, \"Thu, 01 Jan 1970 00:00:00 GMT\", buf_len);",
          "3077:   buf[buf_len - 1] = '\\0';",
          "3079: }",
          "3083: static double",
          "3084: mg_difftimespec(const struct timespec *ts_now, const struct timespec *ts_before)",
          "3085: {",
          "3086:  return (double)(ts_now->tv_nsec - ts_before->tv_nsec) * 1.0E-9",
          "3087:         + (double)(ts_now->tv_sec - ts_before->tv_sec);",
          "3088: }",
          "3092: void",
          "3093: mg_cry(const struct mg_connection *conn, const char *fmt, ...)",
          "3094: {",
          "3095:  char buf[MG_BUF_LEN], src_addr[IP_ADDR_STR_LEN];",
          "3096:  va_list ap;",
          "3097:  struct mg_file fi;",
          "3098:  time_t timestamp;",
          "3100:  va_start(ap, fmt);",
          "3101:  IGNORE_UNUSED_RESULT(vsnprintf_impl(buf, sizeof(buf), fmt, ap));",
          "3102:  va_end(ap);",
          "3103:  buf[sizeof(buf) - 1] = 0;",
          "3105:  if (!conn) {",
          "3106:   puts(buf);",
          "3107:   return;",
          "3108:  }",
          "3113:  if ((conn->ctx->callbacks.log_message == NULL)",
          "3114:      || (conn->ctx->callbacks.log_message(conn, buf) == 0)) {",
          "3116:   if (conn->ctx->config[ERROR_LOG_FILE] != NULL) {",
          "3117:    if (mg_fopen(conn,",
          "3118:                 conn->ctx->config[ERROR_LOG_FILE],",
          "3119:                 MG_FOPEN_MODE_APPEND,",
          "3120:                 &fi) == 0) {",
          "3121:     fi.access.fp = NULL;",
          "3122:    }",
          "3123:   } else {",
          "3124:    fi.access.fp = NULL;",
          "3127:   if (fi.access.fp != NULL) {",
          "3128:    flockfile(fi.access.fp);",
          "3129:    timestamp = time(NULL);",
          "3131:    sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);",
          "3132:    fprintf(fi.access.fp,",
          "3133:            \"[%010lu] [error] [client %s] \",",
          "3134:            (unsigned long)timestamp,",
          "3135:            src_addr);",
          "3137:    if (conn->request_info.request_method != NULL) {",
          "3139:             \"%s %s: \",",
          "3140:             conn->request_info.request_method,",
          "3141:             conn->request_info.request_uri",
          "3142:                 ? conn->request_info.request_uri",
          "3143:                 : \"\");",
          "3144:    }",
          "3146:    fprintf(fi.access.fp, \"%s\", buf);",
          "3147:    fputc('\\n', fi.access.fp);",
          "3148:    fflush(fi.access.fp);",
          "3149:    funlockfile(fi.access.fp);",
          "3150:    (void)mg_fclose(&fi.access); /* Ignore errors. We can't call",
          "3154: }",
          "3159: static struct mg_connection *",
          "3160: fc(struct mg_context *ctx)",
          "3161: {",
          "3162:  static struct mg_connection fake_connection;",
          "3163:  fake_connection.ctx = ctx;",
          "3164:  return &fake_connection;",
          "3165: }",
          "3168: const char *",
          "3169: mg_version(void)",
          "3170: {",
          "3171:  return CIVETWEB_VERSION;",
          "3172: }",
          "3175: const struct mg_request_info *",
          "3176: mg_get_request_info(const struct mg_connection *conn)",
          "3177: {",
          "3178:  if (!conn) {",
          "3179:   return NULL;",
          "3180:  }",
          "3182:  if (conn->connection_type == 2) {",
          "3183:   static char txt[16];",
          "3184:   sprintf(txt, \"%03i\", conn->response_info.status_code);",
          "3186:   ((struct mg_connection *)conn)->request_info.local_uri =",
          "3187:       ((struct mg_connection *)conn)->request_info.request_uri =",
          "3190:   ((struct mg_connection *)conn)->request_info.num_headers =",
          "3191:       conn->response_info.num_headers;",
          "3192:   memcpy(((struct mg_connection *)conn)->request_info.http_headers,",
          "3193:          conn->response_info.http_headers,",
          "3194:          sizeof(conn->response_info.http_headers));",
          "3195:  } else",
          "3196: #endif",
          "3197:      if (conn->connection_type != 1) {",
          "3198:   return NULL;",
          "3200:  return &conn->request_info;",
          "3201: }",
          "3204: const struct mg_response_info *",
          "3205: mg_get_response_info(const struct mg_connection *conn)",
          "3206: {",
          "3207:  if (!conn) {",
          "3208:   return NULL;",
          "3209:  }",
          "3210:  if (conn->connection_type != 2) {",
          "3211:   return NULL;",
          "3213:  return &conn->response_info;",
          "3214: }",
          "3217: int",
          "3218: mg_get_request_link(const struct mg_connection *conn, char *buf, size_t buflen)",
          "3219: {",
          "3220:  if ((buflen < 1) || (buf == 0) || (conn == 0)) {",
          "3221:   return -1;",
          "3222:  } else {",
          "3224:   int truncated = 0;",
          "3225:   const struct mg_request_info *ri = &conn->request_info;",
          "",
          "[Added Lines]",
          "2862:   n = (int)vsnprintf_impl(buf, buflen, fmt, ap);",
          "2863:   ok = (n >= 0) && ((size_t)n < buflen);",
          "2869:   if (ok) {",
          "2870:    if (truncated) {",
          "2872:    }",
          "2873:   } else {",
          "2874:    if (truncated) {",
          "2876:    }",
          "2877:    mg_cry(conn,",
          "2878:           \"truncating vsnprintf buffer: [%.*s]\",",
          "2879:           (int)((buflen > 200) ? 200 : (buflen - 1)),",
          "2880:           buf);",
          "2881:    n = (int)buflen - 1;",
          "2883:   buf[n] = '\\0';",
          "2887:  static void mg_snprintf(const struct mg_connection *conn,",
          "2888:                          int *truncated,",
          "2889:                          char *buf,",
          "2890:                          size_t buflen,",
          "2891:                          const char *fmt,",
          "2892:                          ...)",
          "2893:  {",
          "2894:   va_list ap;",
          "2896:   va_start(ap, fmt);",
          "2897:   mg_vsnprintf(conn, truncated, buf, buflen, fmt, ap);",
          "2898:   va_end(ap);",
          "2899:  }",
          "2902:  static int get_option_index(const char *name)",
          "2903:  {",
          "2904:   int i;",
          "2906:   for (i = 0; config_options[i].name != NULL; i++) {",
          "2907:    if (strcmp(config_options[i].name, name) == 0) {",
          "2908:     return i;",
          "2909:    }",
          "2911:   return -1;",
          "2915:  const char *mg_get_option(const struct mg_context *ctx, const char *name)",
          "2916:  {",
          "2917:   int i;",
          "2918:   if ((i = get_option_index(name)) == -1) {",
          "2919:    return NULL;",
          "2920:   } else if (!ctx || ctx->config[i] == NULL) {",
          "2921:    return \"\";",
          "2922:   } else {",
          "2923:    return ctx->config[i];",
          "2924:   }",
          "2928:  struct mg_context *mg_get_context(const struct mg_connection *conn)",
          "2929:  {",
          "2930:   return (conn == NULL) ? (struct mg_context *)NULL : (conn->ctx);",
          "2931:  }",
          "2934:  void *mg_get_user_data(const struct mg_context *ctx)",
          "2935:  {",
          "2936:   return (ctx == NULL) ? NULL : ctx->user_data;",
          "2937:  }",
          "2940:  void mg_set_user_connection_data(struct mg_connection * conn, void *data)",
          "2941:  {",
          "2942:   if (conn != NULL) {",
          "2943:    conn->request_info.conn_data = data;",
          "2944:   }",
          "2948:  void *mg_get_user_connection_data(const struct mg_connection *conn)",
          "2949:  {",
          "2950:   if (conn != NULL) {",
          "2951:    return conn->request_info.conn_data;",
          "2952:   }",
          "2953:   return NULL;",
          "2959:  size_t mg_get_ports(const struct mg_context *ctx,",
          "2960:                      size_t size,",
          "2961:                      int *ports,",
          "2962:                      int *ssl)",
          "2963:  {",
          "2964:   size_t i;",
          "2965:   if (!ctx) {",
          "2966:    return 0;",
          "2967:   }",
          "2968:   for (i = 0; i < size && i < ctx->num_listening_sockets; i++) {",
          "2969:    ssl[i] = ctx->listening_sockets[i].is_ssl;",
          "2970:    ports[i] =",
          "2972:        (ctx->listening_sockets[i].lsa.sa.sa_family == AF_INET6)",
          "2973:            ? ntohs(ctx->listening_sockets[i].lsa.sin6.sin6_port)",
          "2974:            :",
          "2976:            ntohs(ctx->listening_sockets[i].lsa.sin.sin_port);",
          "2977:   }",
          "2978:   return i;",
          "2983:  int mg_get_server_ports(const struct mg_context *ctx,",
          "2984:                          int size,",
          "2985:                          struct mg_server_ports *ports)",
          "2986:  {",
          "2987:   int i, cnt = 0;",
          "2989:   if (size <= 0) {",
          "2990:    return -1;",
          "2991:   }",
          "2992:   memset(ports, 0, sizeof(*ports) * (size_t)size);",
          "2993:   if (!ctx) {",
          "2994:    return -1;",
          "2995:   }",
          "2996:   if (!ctx->listening_sockets) {",
          "2997:    return -1;",
          "2998:   }",
          "3000:   for (i = 0; (i < size) && (i < (int)ctx->num_listening_sockets); i++) {",
          "3002:    ports[cnt].port =",
          "3004:        (ctx->listening_sockets[i].lsa.sa.sa_family == AF_INET6)",
          "3005:            ? ntohs(ctx->listening_sockets[i].lsa.sin6.sin6_port)",
          "3006:            :",
          "3007: #endif",
          "3008:            ntohs(ctx->listening_sockets[i].lsa.sin.sin_port);",
          "3009:    ports[cnt].is_ssl = ctx->listening_sockets[i].is_ssl;",
          "3010:    ports[cnt].is_redirect = ctx->listening_sockets[i].ssl_redir;",
          "3012:    if (ctx->listening_sockets[i].lsa.sa.sa_family == AF_INET) {",
          "3014:     ports[cnt].protocol = 1;",
          "3015:     cnt++;",
          "3016:    } else if (ctx->listening_sockets[i].lsa.sa.sa_family == AF_INET6) {",
          "3018:     ports[cnt].protocol = 3;",
          "3019:     cnt++;",
          "3020:    }",
          "3023:   return cnt;",
          "3027:  static void sockaddr_to_string(char *buf, size_t len, const union usa *usa)",
          "3028:  {",
          "3029:   buf[0] = '\\0';",
          "3031:   if (!usa) {",
          "3032:    return;",
          "3033:   }",
          "3035:   if (usa->sa.sa_family == AF_INET) {",
          "3036:    getnameinfo(&usa->sa,",
          "3037:                sizeof(usa->sin),",
          "3038:                buf,",
          "3039:                (unsigned)len,",
          "3040:                NULL,",
          "3041:                0,",
          "3042:                NI_NUMERICHOST);",
          "3043:   }",
          "3045:   else if (usa->sa.sa_family == AF_INET6) {",
          "3046:    getnameinfo(&usa->sa,",
          "3047:                sizeof(usa->sin6),",
          "3048:                buf,",
          "3049:                (unsigned)len,",
          "3050:                NULL,",
          "3051:                0,",
          "3052:                NI_NUMERICHOST);",
          "3053:   }",
          "3055:  }",
          "3060:  static void gmt_time_string(char *buf, size_t buf_len, time_t *t)",
          "3061:  {",
          "3062:   struct tm *tm;",
          "3064:   tm = ((t != NULL) ? gmtime(t) : NULL);",
          "3065:   if (tm != NULL) {",
          "3066:    strftime(buf, buf_len, \"%a, %d %b %Y %H:%M:%S GMT\", tm);",
          "3067:   } else {",
          "3068:    mg_strlcpy(buf, \"Thu, 01 Jan 1970 00:00:00 GMT\", buf_len);",
          "3069:    buf[buf_len - 1] = '\\0';",
          "3070:   }",
          "3075:  static double mg_difftimespec(const struct timespec *ts_now,",
          "3076:                                const struct timespec *ts_before)",
          "3077:  {",
          "3078:   return (double)(ts_now->tv_nsec - ts_before->tv_nsec) * 1.0E-9",
          "3079:          + (double)(ts_now->tv_sec - ts_before->tv_sec);",
          "3080:  }",
          "3084:  void mg_cry(const struct mg_connection *conn, const char *fmt, ...)",
          "3085:  {",
          "3086:   char buf[MG_BUF_LEN], src_addr[IP_ADDR_STR_LEN];",
          "3087:   va_list ap;",
          "3088:   struct mg_file fi;",
          "3089:   time_t timestamp;",
          "3091:   va_start(ap, fmt);",
          "3092:   IGNORE_UNUSED_RESULT(vsnprintf_impl(buf, sizeof(buf), fmt, ap));",
          "3093:   va_end(ap);",
          "3094:   buf[sizeof(buf) - 1] = 0;",
          "3096:   if (!conn) {",
          "3097:    puts(buf);",
          "3098:    return;",
          "3104:   if ((conn->ctx->callbacks.log_message == NULL)",
          "3105:       || (conn->ctx->callbacks.log_message(conn, buf) == 0)) {",
          "3107:    if (conn->ctx->config[ERROR_LOG_FILE] != NULL) {",
          "3108:     if (mg_fopen(conn,",
          "3109:                  conn->ctx->config[ERROR_LOG_FILE],",
          "3110:                  MG_FOPEN_MODE_APPEND,",
          "3111:                  &fi) == 0) {",
          "3112:      fi.access.fp = NULL;",
          "3113:     }",
          "3114:    } else {",
          "3115:     fi.access.fp = NULL;",
          "3116:    }",
          "3118:    if (fi.access.fp != NULL) {",
          "3119:     flockfile(fi.access.fp);",
          "3120:     timestamp = time(NULL);",
          "3122:     sockaddr_to_string(src_addr,",
          "3123:                        sizeof(src_addr),",
          "3124:                        &conn->client.rsa);",
          "3126:             \"[%010lu] [error] [client %s] \",",
          "3127:             (unsigned long)timestamp,",
          "3128:             src_addr);",
          "3130:     if (conn->request_info.request_method != NULL) {",
          "3131:      fprintf(fi.access.fp,",
          "3132:              \"%s %s: \",",
          "3133:              conn->request_info.request_method,",
          "3134:              conn->request_info.request_uri",
          "3135:                  ? conn->request_info.request_uri",
          "3136:                  : \"\");",
          "3137:     }",
          "3139:     fprintf(fi.access.fp, \"%s\", buf);",
          "3140:     fputc('\\n', fi.access.fp);",
          "3141:     fflush(fi.access.fp);",
          "3142:     funlockfile(fi.access.fp);",
          "3143:     (void)mg_fclose(&fi.access); /* Ignore errors. We can't call",
          "3145:    }",
          "3152:  static struct mg_connection *fc(struct mg_context * ctx)",
          "3153:  {",
          "3154:   static struct mg_connection fake_connection;",
          "3155:   fake_connection.ctx = ctx;",
          "3156:   return &fake_connection;",
          "3157:  }",
          "3160:  const char *mg_version(void)",
          "3161:  {",
          "3162:   return CIVETWEB_VERSION;",
          "3163:  }",
          "3166:  const struct mg_request_info *mg_get_request_info(",
          "3167:      const struct mg_connection *conn)",
          "3168:  {",
          "3169:   if (!conn) {",
          "3170:    return NULL;",
          "3171:   }",
          "3173:   if (conn->connection_type == 2) {",
          "3174:    static char txt[16];",
          "3175:    sprintf(txt, \"%03i\", conn->response_info.status_code);",
          "3177:    ((struct mg_connection *)conn)->request_info.local_uri =",
          "3178:        ((struct mg_connection *)conn)->request_info.request_uri =",
          "3181:    ((struct mg_connection *)conn)->request_info.num_headers =",
          "3182:        conn->response_info.num_headers;",
          "3183:    memcpy(((struct mg_connection *)conn)->request_info.http_headers,",
          "3184:           conn->response_info.http_headers,",
          "3185:           sizeof(conn->response_info.http_headers));",
          "3186:   } else",
          "3187: #endif",
          "3188:       if (conn->connection_type != 1) {",
          "3189:    return NULL;",
          "3190:   }",
          "3191:   return &conn->request_info;",
          "3195:  const struct mg_response_info *mg_get_response_info(",
          "3196:      const struct mg_connection *conn)",
          "3197:  {",
          "3198:   if (!conn) {",
          "3199:    return NULL;",
          "3200:   }",
          "3201:   if (conn->connection_type != 2) {",
          "3202:    return NULL;",
          "3203:   }",
          "3204:   return &conn->response_info;",
          "3208:  int mg_get_request_link(const struct mg_connection *conn,",
          "3209:                          char *buf,",
          "3210:                          size_t buflen)",
          "3211:  {",
          "3212:   if ((buflen < 1) || (buf == 0) || (conn == 0)) {",
          "3213:    return -1;",
          "3214:   } else {",
          "3216:    int truncated = 0;",
          "3217:    const struct mg_request_info *ri = &conn->request_info;",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "3235: #endif",
          "3241: #ifdef __clang__",
          "3242: #pragma clang diagnostic pop",
          "3243: #endif",
          "3259:     return -1;",
          "3260:    }",
          "3264: #if defined(USE_IPV6)",
          "3268: #else",
          "3269:    int port = htons(conn->client.lsa.sin.sin_port);",
          "3270: #endif",
          "3308:    }",
          "3310:   }",
          "3311:  }",
          "3346:    }",
          "3347:   }",
          "3357: #if defined(__GNUC__) || defined(__MINGW32__)",
          "",
          "[Removed Lines]",
          "3237:   const char *proto =",
          "3238:       (is_websocket_protocol(conn) ? (ri->is_ssl ? \"wss\" : \"ws\")",
          "3239:                                    : (ri->is_ssl ? \"https\" : \"http\"));",
          "3245:   if (ri->local_uri == NULL) {",
          "3246:    return -1;",
          "3247:   }",
          "3249:   if ((ri->request_uri != NULL)",
          "3250:       && strcmp(ri->local_uri, ri->request_uri)) {",
          "3251:    mg_snprintf(conn,",
          "3252:                &truncated,",
          "3253:                buf,",
          "3254:                buflen,",
          "3255:                \"%s://%s\",",
          "3256:                proto,",
          "3257:                ri->request_uri);",
          "3258:    if (truncated) {",
          "3261:    return 0;",
          "3262:   } else {",
          "3265:    int is_ipv6 = (conn->client.lsa.sa.sa_family == AF_INET6);",
          "3266:    int port = is_ipv6 ? htons(conn->client.lsa.sin6.sin6_port)",
          "3267:                       : htons(conn->client.lsa.sin.sin_port);",
          "3271:    int def_port = ri->is_ssl ? 443 : 80;",
          "3272:    int auth_domain_check_enabled =",
          "3273:        conn->ctx->config[ENABLE_AUTH_DOMAIN_CHECK]",
          "3274:        && (!strcmp(conn->ctx->config[ENABLE_AUTH_DOMAIN_CHECK],",
          "3275:                    \"yes\"));",
          "3276:    const char *server_domain =",
          "3277:        conn->ctx->config[AUTHENTICATION_DOMAIN];",
          "3279:    char portstr[16];",
          "3280:    char server_ip[48];",
          "3282:    if (port != def_port) {",
          "3283:     sprintf(portstr, \":%u\", (unsigned)port);",
          "3284:    } else {",
          "3285:     portstr[0] = 0;",
          "3286:    }",
          "3288:    if (!auth_domain_check_enabled || !server_domain) {",
          "3290:     sockaddr_to_string(server_ip,",
          "3291:                        sizeof(server_ip),",
          "3292:                        &conn->client.lsa);",
          "3294:     server_domain = server_ip;",
          "3295:    }",
          "3297:    mg_snprintf(conn,",
          "3298:                &truncated,",
          "3299:                buf,",
          "3300:                buflen,",
          "3301:                \"%s://%s%s%s\",",
          "3302:                proto,",
          "3303:                server_domain,",
          "3304:                portstr,",
          "3305:                ri->local_uri);",
          "3306:    if (truncated) {",
          "3307:     return -1;",
          "3309:    return 0;",
          "3312: }",
          "3318: static char *",
          "3319: skip_quoted(char **buf,",
          "3320:             const char *delimiters,",
          "3321:             const char *whitespace,",
          "3322:             char quotechar)",
          "3323: {",
          "3324:  char *p, *begin_word, *end_word, *end_whitespace;",
          "3326:  begin_word = *buf;",
          "3327:  end_word = begin_word + strcspn(begin_word, delimiters);",
          "3330:  if (end_word > begin_word) {",
          "3331:   p = end_word - 1;",
          "3332:   while (*p == quotechar) {",
          "3338:    if (*end_word != '\\0') {",
          "3339:     size_t end_off = strcspn(end_word + 1, delimiters);",
          "3340:     memmove(p, end_word, end_off + 1);",
          "3342:     end_word += end_off + 1;",
          "3343:    } else {",
          "3345:     break;",
          "3348:   for (p++; p < end_word; p++) {",
          "3350:   }",
          "3351:  }",
          "3353:  if (*end_word == '\\0') {",
          "3355:  } else {",
          "",
          "[Added Lines]",
          "3229:    const char *proto =",
          "3230:        (is_websocket_protocol(conn) ? (ri->is_ssl ? \"wss\" : \"ws\")",
          "3231:                                     : (ri->is_ssl ? \"https\" : \"http\"));",
          "3237:    if (ri->local_uri == NULL) {",
          "3241:    if ((ri->request_uri != NULL)",
          "3242:        && strcmp(ri->local_uri, ri->request_uri)) {",
          "3243:     mg_snprintf(conn,",
          "3244:                 &truncated,",
          "3245:                 buf,",
          "3246:                 buflen,",
          "3247:                 \"%s://%s\",",
          "3248:                 proto,",
          "3249:                 ri->request_uri);",
          "3250:     if (truncated) {",
          "3251:      return -1;",
          "3252:     }",
          "3253:     return 0;",
          "3254:    } else {",
          "3257:     int is_ipv6 = (conn->client.lsa.sa.sa_family == AF_INET6);",
          "3258:     int port = is_ipv6 ? htons(conn->client.lsa.sin6.sin6_port)",
          "3259:                        : htons(conn->client.lsa.sin.sin_port);",
          "3263:     int def_port = ri->is_ssl ? 443 : 80;",
          "3264:     int auth_domain_check_enabled =",
          "3265:         conn->ctx->config[ENABLE_AUTH_DOMAIN_CHECK]",
          "3266:         && (!strcmp(conn->ctx->config[ENABLE_AUTH_DOMAIN_CHECK],",
          "3267:                     \"yes\"));",
          "3268:     const char *server_domain =",
          "3269:         conn->ctx->config[AUTHENTICATION_DOMAIN];",
          "3271:     char portstr[16];",
          "3272:     char server_ip[48];",
          "3274:     if (port != def_port) {",
          "3275:      sprintf(portstr, \":%u\", (unsigned)port);",
          "3276:     } else {",
          "3277:      portstr[0] = 0;",
          "3278:     }",
          "3280:     if (!auth_domain_check_enabled || !server_domain) {",
          "3282:      sockaddr_to_string(server_ip,",
          "3283:                         sizeof(server_ip),",
          "3284:                         &conn->client.lsa);",
          "3286:      server_domain = server_ip;",
          "3287:     }",
          "3289:     mg_snprintf(conn,",
          "3290:                 &truncated,",
          "3291:                 buf,",
          "3292:                 buflen,",
          "3293:                 \"%s://%s%s%s\",",
          "3294:                 proto,",
          "3295:                 server_domain,",
          "3296:                 portstr,",
          "3297:                 ri->local_uri);",
          "3298:     if (truncated) {",
          "3299:      return -1;",
          "3300:     }",
          "3301:     return 0;",
          "3311:  static char *skip_quoted(char **buf,",
          "3312:                           const char *delimiters,",
          "3313:                           const char *whitespace,",
          "3314:                           char quotechar)",
          "3315:  {",
          "3316:   char *p, *begin_word, *end_word, *end_whitespace;",
          "3318:   begin_word = *buf;",
          "3319:   end_word = begin_word + strcspn(begin_word, delimiters);",
          "3322:   if (end_word > begin_word) {",
          "3323:    p = end_word - 1;",
          "3324:    while (*p == quotechar) {",
          "3331:     if (*end_word != '\\0') {",
          "3332:      size_t end_off = strcspn(end_word + 1, delimiters);",
          "3333:      memmove(p, end_word, end_off + 1);",
          "3335:      end_word += end_off + 1;",
          "3336:     } else {",
          "3338:      break;",
          "3339:     }",
          "3340:    }",
          "3341:    for (p++; p < end_word; p++) {",
          "3346:   if (*end_word == '\\0') {",
          "3348:   } else {",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "3367: #if defined(__GNUC__) || defined(__MINGW32__)",
          "3368: #if GCC_VERSION >= 40500",
          "",
          "[Removed Lines]",
          "3365:   end_whitespace = end_word + strspn(&end_word[1], whitespace) + 1;",
          "",
          "[Added Lines]",
          "3358:    end_whitespace = end_word + strspn(&end_word[1], whitespace) + 1;",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "3375:   }",
          "3378:  }",
          "3392:   }",
          "3399: #if defined(USE_WEBSOCKET)",
          "3414:    }",
          "3415:   }",
          "3416:  }",
          "3419: #endif",
          "3426:   return NULL;",
          "3427:  }",
          "3447:   return NULL;",
          "3448:  }",
          "3485:   } else {",
          "3511:    }",
          "3512:   }",
          "3513:  }",
          "3536:  }",
          "3566:     i++;",
          "3573:    }",
          "3580:   }",
          "3581:  }",
          "3611:    return 1;",
          "3612:   }",
          "3613:   return 0;",
          "3614:  }",
          "3621:  }",
          "3661: #if !defined(NO_CACHING)",
          "3683:  return send_no_cache_header(conn);",
          "3694: #if !defined(NO_SSL)",
          "3701:   }",
          "3703: #endif",
          "3707:  }",
          "3900:   }",
          "3928:  }",
          "3987:        break;",
          "3988:       }",
          "3990:      }",
          "3991:     }",
          "3999:    }",
          "4013:    mg_printf(conn,",
          "4032:    }",
          "4037:   }",
          "4038:  }",
          "4041: #if defined(_WIN32) && !defined(__SYMBIAN32__)",
          "",
          "[Removed Lines]",
          "3373:   for (p = end_word; p < end_whitespace; p++) {",
          "3380:  return begin_word;",
          "3381: }",
          "3385: static const char *",
          "3386: get_header(const struct mg_header *hdr, int num_hdr, const char *name)",
          "3387: {",
          "3388:  int i;",
          "3389:  for (i = 0; i < num_hdr; i++) {",
          "3390:   if (!mg_strcasecmp(name, hdr[i].name)) {",
          "3391:    return hdr[i].value;",
          "3393:  }",
          "3395:  return NULL;",
          "3396: }",
          "3402: static int",
          "3403: get_req_headers(const struct mg_request_info *ri,",
          "3404:                 const char *name,",
          "3405:                 const char **output,",
          "3406:                 int output_max_size)",
          "3407: {",
          "3408:  int i;",
          "3409:  int cnt = 0;",
          "3410:  if (ri) {",
          "3411:   for (i = 0; i < ri->num_headers && cnt < output_max_size; i++) {",
          "3412:    if (!mg_strcasecmp(name, ri->http_headers[i].name)) {",
          "3413:     output[cnt++] = ri->http_headers[i].value;",
          "3417:  return cnt;",
          "3418: }",
          "3422: const char *",
          "3423: mg_get_header(const struct mg_connection *conn, const char *name)",
          "3424: {",
          "3425:  if (!conn) {",
          "3429:  if (conn->connection_type == 1) {",
          "3430:   return get_header(conn->request_info.http_headers,",
          "3431:                     conn->request_info.num_headers,",
          "3432:                     name);",
          "3433:  }",
          "3434:  if (conn->connection_type == 2) {",
          "3435:   return get_header(conn->response_info.http_headers,",
          "3436:                     conn->request_info.num_headers,",
          "3437:                     name);",
          "3438:  }",
          "3439:  return NULL;",
          "3440: }",
          "3443: static const char *",
          "3444: get_http_version(const struct mg_connection *conn)",
          "3445: {",
          "3446:  if (!conn) {",
          "3450:  if (conn->connection_type == 1) {",
          "3451:   return conn->request_info.http_version;",
          "3452:  }",
          "3453:  if (conn->connection_type == 2) {",
          "3454:   return conn->response_info.http_version;",
          "3455:  }",
          "3456:  return NULL;",
          "3457: }",
          "3466: static const char *",
          "3467: next_option(const char *list, struct vec *val, struct vec *eq_val)",
          "3468: {",
          "3469:  int end;",
          "3471: reparse:",
          "3472:  if (val == NULL || list == NULL || *list == '\\0') {",
          "3474:   list = NULL;",
          "3475:  } else {",
          "3477:   while (*list == ' ' || *list == '\\t')",
          "3478:    list++;",
          "3480:   val->ptr = list;",
          "3481:   if ((list = strchr(val->ptr, ',')) != NULL) {",
          "3483:    val->len = ((size_t)(list - val->ptr));",
          "3484:    list++;",
          "3487:    list = val->ptr + strlen(val->ptr);",
          "3488:    val->len = ((size_t)(list - val->ptr));",
          "3489:   }",
          "3492:   end = (int)val->len - 1;",
          "3493:   while (end >= 0 && ((val->ptr[end] == ' ') || (val->ptr[end] == '\\t')))",
          "3494:    end--;",
          "3495:   val->len = (size_t)(end + 1);",
          "3497:   if (val->len == 0) {",
          "3499:    goto reparse;",
          "3500:   }",
          "3502:   if (eq_val != NULL) {",
          "3505:    eq_val->len = 0;",
          "3506:    eq_val->ptr = (const char *)memchr(val->ptr, '=', val->len);",
          "3507:    if (eq_val->ptr != NULL) {",
          "3509:     eq_val->len = ((size_t)(val->ptr - eq_val->ptr)) + val->len;",
          "3510:     val->len = ((size_t)(eq_val->ptr - val->ptr)) - 1;",
          "3515:  return list;",
          "3516: }",
          "3522: static int",
          "3523: header_has_option(const char *header, const char *option)",
          "3524: {",
          "3525:  struct vec opt_vec;",
          "3526:  struct vec eq_vec;",
          "3529:  assert(option != NULL);",
          "3530:  assert(option[0] != '\\0');",
          "3533:  while ((header = next_option(header, &opt_vec, &eq_vec)) != NULL) {",
          "3534:   if (mg_strncasecmp(option, opt_vec.ptr, opt_vec.len) == 0)",
          "3535:    return 1;",
          "3538:  return 0;",
          "3539: }",
          "3543: static int",
          "3544: match_prefix(const char *pattern, size_t pattern_len, const char *str)",
          "3545: {",
          "3546:  const char *or_str;",
          "3547:  size_t i;",
          "3548:  int j, len, res;",
          "3550:  if ((or_str = (const char *)memchr(pattern, '|', pattern_len)) != NULL) {",
          "3551:   res = match_prefix(pattern, (size_t)(or_str - pattern), str);",
          "3552:   return (res > 0) ? res : match_prefix(or_str + 1,",
          "3553:                                         (size_t)((pattern + pattern_len)",
          "3554:                                                  - (or_str + 1)),",
          "3555:                                         str);",
          "3556:  }",
          "3558:  for (i = 0, j = 0; (i < pattern_len); i++, j++) {",
          "3559:   if ((pattern[i] == '?') && (str[j] != '\\0')) {",
          "3560:    continue;",
          "3561:   } else if (pattern[i] == '$') {",
          "3562:    return (str[j] == '\\0') ? j : -1;",
          "3563:   } else if (pattern[i] == '*') {",
          "3564:    i++;",
          "3565:    if (pattern[i] == '*') {",
          "3567:     len = (int)strlen(str + j);",
          "3568:    } else {",
          "3569:     len = (int)strcspn(str + j, \"/\");",
          "3570:    }",
          "3571:    if (i == pattern_len) {",
          "3572:     return j + len;",
          "3574:    do {",
          "3575:     res = match_prefix(pattern + i, pattern_len - i, str + j + len);",
          "3576:    } while (res == -1 && len-- > 0);",
          "3577:    return (res == -1) ? -1 : j + res + len;",
          "3578:   } else if (lowercase(&pattern[i]) != lowercase(&str[j])) {",
          "3579:    return -1;",
          "3582:  return j;",
          "3583: }",
          "3589: static int",
          "3590: should_keep_alive(const struct mg_connection *conn)",
          "3591: {",
          "3592:  const char *http_version;",
          "3593:  const char *header;",
          "3596:  if ((conn == NULL) || conn->must_close) {",
          "3598:   return 0;",
          "3599:  }",
          "3601:  if (mg_strcasecmp(conn->ctx->config[ENABLE_KEEP_ALIVE], \"yes\") != 0) {",
          "3603:   return 0;",
          "3604:  }",
          "3607:  header = mg_get_header(conn, \"Connection\");",
          "3608:  if (header) {",
          "3610:   if (header_has_option(header, \"keep-alive\")) {",
          "3617:  http_version = get_http_version(conn);",
          "3618:  if (http_version && (0 == strcmp(http_version, \"1.1\"))) {",
          "3620:   return 1;",
          "3624:  return 0;",
          "3625: }",
          "3628: static int",
          "3629: should_decode_url(const struct mg_connection *conn)",
          "3630: {",
          "3631:  if (!conn || !conn->ctx) {",
          "3632:   return 0;",
          "3633:  }",
          "3635:  return (mg_strcasecmp(conn->ctx->config[DECODE_URL], \"yes\") == 0);",
          "3636: }",
          "3639: static const char *",
          "3640: suggest_connection_header(const struct mg_connection *conn)",
          "3641: {",
          "3642:  return should_keep_alive(conn) ? \"keep-alive\" : \"close\";",
          "3643: }",
          "3646: static int",
          "3647: send_no_cache_header(struct mg_connection *conn)",
          "3648: {",
          "3650:  return mg_printf(conn,",
          "3651:                   \"Cache-Control: no-cache, no-store, \"",
          "3652:                   \"must-revalidate, private, max-age=0\\r\\n\"",
          "3653:                   \"Pragma: no-cache\\r\\n\"",
          "3654:                   \"Expires: 0\\r\\n\");",
          "3655: }",
          "3658: static int",
          "3659: send_static_cache_header(struct mg_connection *conn)",
          "3660: {",
          "3664:  int max_age = atoi(conn->ctx->config[STATIC_FILE_MAX_AGE]);",
          "3665:  if (max_age <= 0) {",
          "3670:   return send_no_cache_header(conn);",
          "3671:  }",
          "3681:  return mg_printf(conn, \"Cache-Control: max-age=%u\\r\\n\", (unsigned)max_age);",
          "3685: }",
          "3688: static int",
          "3689: send_additional_header(struct mg_connection *conn)",
          "3690: {",
          "3691:  int i = 0;",
          "3692:  const char *header = conn->ctx->config[ADDITIONAL_HEADER];",
          "3695:  if (conn->ctx->config[STRICT_HTTPS_MAX_AGE]) {",
          "3696:   int max_age = atoi(conn->ctx->config[STRICT_HTTPS_MAX_AGE]);",
          "3697:   if (max_age >= 0) {",
          "3698:    i += mg_printf(conn,",
          "3699:                   \"Strict-Transport-Security: max-age=%u\\r\\n\",",
          "3700:                   (unsigned)max_age);",
          "3702:  }",
          "3705:  if (header && header[0]) {",
          "3706:   i += mg_printf(conn, \"%s\\r\\n\", header);",
          "3709:  return i;",
          "3710: }",
          "3713: static void handle_file_based_request(struct mg_connection *conn,",
          "3714:                                       const char *path,",
          "3715:                                       struct mg_file *filep);",
          "3718: const char *",
          "3719: mg_get_response_code_text(const struct mg_connection *conn, int response_code)",
          "3720: {",
          "3725:  switch (response_code) {",
          "3727:  case 100:",
          "3729:  case 101:",
          "3731:  case 102:",
          "3735:  case 200:",
          "3737:  case 201:",
          "3739:  case 202:",
          "3741:  case 203:",
          "3743:  case 204:",
          "3745:  case 205:",
          "3747:  case 206:",
          "3749:  case 207:",
          "3751:  case 208:",
          "3754:  case 226:",
          "3758:  case 300:",
          "3760:  case 301:",
          "3762:  case 302:",
          "3764:  case 303:",
          "3766:  case 304:",
          "3768:  case 305:",
          "3770:  case 307:",
          "3772:  case 308:",
          "3776:  case 400:",
          "3778:  case 401:",
          "3780:  case 402:",
          "3782:  case 403:",
          "3784:  case 404:",
          "3786:  case 405:",
          "3788:  case 406:",
          "3790:  case 407:",
          "3792:  case 408:",
          "3794:  case 409:",
          "3796:  case 410:",
          "3798:  case 411:",
          "3800:  case 412:",
          "3802:  case 413:",
          "3804:  case 414:",
          "3806:  case 415:",
          "3808:  case 416:",
          "3810:  case 417:",
          "3813:  case 421:",
          "3815:  case 422:",
          "3816:   return \"Unproccessable entity\"; /* RFC2518 Section 10.3, RFC4918",
          "3818:  case 423:",
          "3820:  case 424:",
          "3821:   return \"Failed Dependency\"; /* RFC2518 Section 10.5, RFC4918",
          "3824:  case 426:",
          "3827:  case 428:",
          "3829:  case 429:",
          "3832:  case 431:",
          "3835:  case 451:",
          "3836:   return \"Unavailable For Legal Reasons\"; /* draft-tbray-http-legally-restricted-status-05,",
          "3840:  case 500:",
          "3842:  case 501:",
          "3844:  case 502:",
          "3846:  case 503:",
          "3848:  case 504:",
          "3850:  case 505:",
          "3852:  case 506:",
          "3854:  case 507:",
          "3855:   return \"Insufficient Storage\"; /* RFC2518 Section 10.6, RFC4918",
          "3857:  case 508:",
          "3860:  case 510:",
          "3862:  case 511:",
          "3867:  case 418:",
          "3869:  case 419:",
          "3871:  case 420:",
          "3873:  case 440:",
          "3875:  case 509:",
          "3878:  default:",
          "3880:   if (conn) {",
          "3881:    mg_cry(conn, \"Unknown HTTP response code: %u\", response_code);",
          "3882:   }",
          "3885:   if (response_code >= 100 && response_code < 200) {",
          "3887:    return \"Information\";",
          "3888:   }",
          "3889:   if (response_code >= 200 && response_code < 300) {",
          "3891:    return \"Success\";",
          "3892:   }",
          "3893:   if (response_code >= 300 && response_code < 400) {",
          "3895:    return \"Redirection\";",
          "3896:   }",
          "3897:   if (response_code >= 400 && response_code < 500) {",
          "3899:    return \"Client Error\";",
          "3901:   if (response_code >= 500 && response_code < 600) {",
          "3903:    return \"Server Error\";",
          "3904:   }",
          "3907:   return \"\";",
          "3908:  }",
          "3909: }",
          "3912: void",
          "3913: mg_send_http_error(struct mg_connection *conn, int status, const char *fmt, ...)",
          "3914: {",
          "3915:  char buf[MG_BUF_LEN];",
          "3916:  va_list ap;",
          "3917:  int len, i, page_handler_found, scope, truncated, has_body;",
          "3918:  char date[64];",
          "3919:  time_t curtime = time(NULL);",
          "3920:  const char *error_handler = NULL;",
          "3921:  struct mg_file error_page_file = STRUCT_FILE_INITIALIZER;",
          "3922:  const char *error_page_file_ext, *tstr;",
          "3924:  const char *status_text = mg_get_response_code_text(conn, status);",
          "3926:  if (conn == NULL) {",
          "3927:   return;",
          "3930:  conn->status_code = status;",
          "3931:  if (conn->in_error_handler || (conn->ctx->callbacks.http_error == NULL)",
          "3932:      || conn->ctx->callbacks.http_error(conn, status)) {",
          "3933:   if (!conn->in_error_handler) {",
          "3935:    error_handler = conn->ctx->config[ERROR_PAGES];",
          "3936:    error_page_file_ext = conn->ctx->config[INDEX_FILES];",
          "3937:    page_handler_found = 0;",
          "3938:    if (error_handler != NULL) {",
          "3939:     for (scope = 1; (scope <= 3) && !page_handler_found; scope++) {",
          "3940:      switch (scope) {",
          "3942:       mg_snprintf(conn,",
          "3943:                   &truncated,",
          "3944:                   buf,",
          "3945:                   sizeof(buf) - 32,",
          "3946:                   \"%serror%03u.\",",
          "3947:                   error_handler,",
          "3948:                   status);",
          "3949:       break;",
          "3950:      case 2: /* Handler for error group, e.g., 5xx error handler",
          "3952:       mg_snprintf(conn,",
          "3953:                   &truncated,",
          "3954:                   buf,",
          "3955:                   sizeof(buf) - 32,",
          "3956:                   \"%serror%01uxx.\",",
          "3957:                   error_handler,",
          "3958:                   status / 100);",
          "3959:       break;",
          "3961:       mg_snprintf(conn,",
          "3962:                   &truncated,",
          "3963:                   buf,",
          "3964:                   sizeof(buf) - 32,",
          "3965:                   \"%serror.\",",
          "3966:                   error_handler);",
          "3967:       break;",
          "3968:      }",
          "3973:      (void)truncated;",
          "3975:      len = (int)strlen(buf);",
          "3977:      tstr = strchr(error_page_file_ext, '.');",
          "3979:      while (tstr) {",
          "3980:       for (i = 1;",
          "3981:            (i < 32) && (tstr[i] != 0) && (tstr[i] != ',');",
          "3982:            i++)",
          "3983:        buf[len + i - 1] = tstr[i];",
          "3984:       buf[len + i - 1] = 0;",
          "3985:       if (mg_stat(conn, buf, &error_page_file.stat)) {",
          "3986:        page_handler_found = 1;",
          "3989:       tstr = strchr(tstr + i, '.');",
          "3992:    }",
          "3994:    if (page_handler_found) {",
          "3995:     conn->in_error_handler = 1;",
          "3996:     handle_file_based_request(conn, buf, &error_page_file);",
          "3997:     conn->in_error_handler = 0;",
          "3998:     return;",
          "4000:   }",
          "4003:   gmt_time_string(date, sizeof(date), &curtime);",
          "4006:   has_body = ((status > 199) && (status != 204) && (status != 304));",
          "4008:   conn->must_close = 1;",
          "4009:   mg_printf(conn, \"HTTP/1.1 %d %s\\r\\n\", status, status_text);",
          "4010:   send_no_cache_header(conn);",
          "4011:   send_additional_header(conn);",
          "4012:   if (has_body) {",
          "4014:              \"%s\",",
          "4015:              \"Content-Type: text/plain; charset=utf-8\\r\\n\");",
          "4016:   }",
          "4017:   mg_printf(conn,",
          "4018:             \"Date: %s\\r\\n\"",
          "4019:             \"Connection: close\\r\\n\\r\\n\",",
          "4020:             date);",
          "4023:   if (has_body) {",
          "4024:    mg_printf(conn, \"Error %d: %s\\n\", status, status_text);",
          "4026:    if (fmt != NULL) {",
          "4027:     va_start(ap, fmt);",
          "4028:     mg_vsnprintf(conn, NULL, buf, sizeof(buf), fmt, ap);",
          "4029:     va_end(ap);",
          "4030:     mg_write(conn, buf, strlen(buf));",
          "4031:     DEBUG_TRACE(\"Error %i - [%s]\", status, buf);",
          "4034:   } else {",
          "4036:    DEBUG_TRACE(\"Error %i\", status);",
          "4039: }",
          "",
          "[Added Lines]",
          "3366:    for (p = end_word; p < end_whitespace; p++) {",
          "3368:    }",
          "3373:   return begin_word;",
          "3378:  static const char *get_header(const struct mg_header *hdr,",
          "3379:                                int num_hdr,",
          "3380:                                const char *name)",
          "3381:  {",
          "3382:   int i;",
          "3383:   for (i = 0; i < num_hdr; i++) {",
          "3384:    if (!mg_strcasecmp(name, hdr[i].name)) {",
          "3385:     return hdr[i].value;",
          "3386:    }",
          "3389:   return NULL;",
          "3390:  }",
          "3396:  static int get_req_headers(const struct mg_request_info *ri,",
          "3397:                             const char *name,",
          "3398:                             const char **output,",
          "3399:                             int output_max_size)",
          "3400:  {",
          "3401:   int i;",
          "3402:   int cnt = 0;",
          "3403:   if (ri) {",
          "3404:    for (i = 0; i < ri->num_headers && cnt < output_max_size; i++) {",
          "3405:     if (!mg_strcasecmp(name, ri->http_headers[i].name)) {",
          "3406:      output[cnt++] = ri->http_headers[i].value;",
          "3407:     }",
          "3410:   return cnt;",
          "3415:  const char *mg_get_header(const struct mg_connection *conn,",
          "3416:                            const char *name)",
          "3417:  {",
          "3418:   if (!conn) {",
          "3419:    return NULL;",
          "3420:   }",
          "3422:   if (conn->connection_type == 1) {",
          "3423:    return get_header(conn->request_info.http_headers,",
          "3424:                      conn->request_info.num_headers,",
          "3425:                      name);",
          "3426:   }",
          "3427:   if (conn->connection_type == 2) {",
          "3428:    return get_header(conn->response_info.http_headers,",
          "3429:                      conn->request_info.num_headers,",
          "3430:                      name);",
          "3431:   }",
          "3436:  static const char *get_http_version(const struct mg_connection *conn)",
          "3437:  {",
          "3438:   if (!conn) {",
          "3439:    return NULL;",
          "3440:   }",
          "3442:   if (conn->connection_type == 1) {",
          "3443:    return conn->request_info.http_version;",
          "3444:   }",
          "3445:   if (conn->connection_type == 2) {",
          "3446:    return conn->response_info.http_version;",
          "3447:   }",
          "3458:  static const char *next_option(const char *list,",
          "3459:                                 struct vec *val,",
          "3460:                                 struct vec *eq_val)",
          "3461:  {",
          "3462:   int end;",
          "3464:  reparse:",
          "3465:   if (val == NULL || list == NULL || *list == '\\0') {",
          "3467:    list = NULL;",
          "3470:    while (*list == ' ' || *list == '\\t')",
          "3471:     list++;",
          "3473:    val->ptr = list;",
          "3474:    if ((list = strchr(val->ptr, ',')) != NULL) {",
          "3476:     val->len = ((size_t)(list - val->ptr));",
          "3477:     list++;",
          "3478:    } else {",
          "3480:     list = val->ptr + strlen(val->ptr);",
          "3481:     val->len = ((size_t)(list - val->ptr));",
          "3482:    }",
          "3485:    end = (int)val->len - 1;",
          "3486:    while (end >= 0",
          "3487:           && ((val->ptr[end] == ' ') || (val->ptr[end] == '\\t')))",
          "3488:     end--;",
          "3489:    val->len = (size_t)(end + 1);",
          "3491:    if (val->len == 0) {",
          "3493:     goto reparse;",
          "3494:    }",
          "3496:    if (eq_val != NULL) {",
          "3499:     eq_val->len = 0;",
          "3500:     eq_val->ptr = (const char *)memchr(val->ptr, '=', val->len);",
          "3501:     if (eq_val->ptr != NULL) {",
          "3503:      eq_val->len = ((size_t)(val->ptr - eq_val->ptr)) + val->len;",
          "3504:      val->len = ((size_t)(eq_val->ptr - val->ptr)) - 1;",
          "3505:     }",
          "3509:   return list;",
          "3517:  static int header_has_option(const char *header, const char *option)",
          "3518:  {",
          "3519:   struct vec opt_vec;",
          "3520:   struct vec eq_vec;",
          "3523:   assert(option != NULL);",
          "3524:   assert(option[0] != '\\0');",
          "3527:   while ((header = next_option(header, &opt_vec, &eq_vec)) != NULL) {",
          "3528:    if (mg_strncasecmp(option, opt_vec.ptr, opt_vec.len) == 0)",
          "3529:     return 1;",
          "3530:   }",
          "3532:   return 0;",
          "3537:  static int match_prefix(const char *pattern,",
          "3538:                          size_t pattern_len,",
          "3539:                          const char *str)",
          "3540:  {",
          "3541:   const char *or_str;",
          "3542:   size_t i;",
          "3543:   int j, len, res;",
          "3545:   if ((or_str = (const char *)memchr(pattern, '|', pattern_len))",
          "3546:       != NULL) {",
          "3547:    res = match_prefix(pattern, (size_t)(or_str - pattern), str);",
          "3548:    return (res > 0) ? res",
          "3549:                     : match_prefix(or_str + 1,",
          "3550:                                    (size_t)((pattern + pattern_len)",
          "3551:                                             - (or_str + 1)),",
          "3552:                                    str);",
          "3553:   }",
          "3555:   for (i = 0, j = 0; (i < pattern_len); i++, j++) {",
          "3556:    if ((pattern[i] == '?') && (str[j] != '\\0')) {",
          "3557:     continue;",
          "3558:    } else if (pattern[i] == '$') {",
          "3559:     return (str[j] == '\\0') ? j : -1;",
          "3560:    } else if (pattern[i] == '*') {",
          "3562:     if (pattern[i] == '*') {",
          "3563:      i++;",
          "3564:      len = (int)strlen(str + j);",
          "3565:     } else {",
          "3566:      len = (int)strcspn(str + j, \"/\");",
          "3567:     }",
          "3568:     if (i == pattern_len) {",
          "3569:      return j + len;",
          "3570:     }",
          "3571:     do {",
          "3572:      res = match_prefix(pattern + i,",
          "3573:                         pattern_len - i,",
          "3574:                         str + j + len);",
          "3575:     } while (res == -1 && len-- > 0);",
          "3576:     return (res == -1) ? -1 : j + res + len;",
          "3577:    } else if (lowercase(&pattern[i]) != lowercase(&str[j])) {",
          "3578:     return -1;",
          "3581:   return j;",
          "3588:  static int should_keep_alive(const struct mg_connection *conn)",
          "3589:  {",
          "3590:   const char *http_version;",
          "3591:   const char *header;",
          "3594:   if ((conn == NULL) || conn->must_close) {",
          "3596:    return 0;",
          "3597:   }",
          "3599:   if (mg_strcasecmp(conn->ctx->config[ENABLE_KEEP_ALIVE], \"yes\") != 0) {",
          "3601:    return 0;",
          "3602:   }",
          "3605:   header = mg_get_header(conn, \"Connection\");",
          "3606:   if (header) {",
          "3608:    if (header_has_option(header, \"keep-alive\")) {",
          "3609:     return 1;",
          "3610:    }",
          "3611:    return 0;",
          "3612:   }",
          "3615:   http_version = get_http_version(conn);",
          "3616:   if (http_version && (0 == strcmp(http_version, \"1.1\"))) {",
          "3626:  static int should_decode_url(const struct mg_connection *conn)",
          "3627:  {",
          "3628:   if (!conn || !conn->ctx) {",
          "3629:    return 0;",
          "3630:   }",
          "3632:   return (mg_strcasecmp(conn->ctx->config[DECODE_URL], \"yes\") == 0);",
          "3636:  static const char *suggest_connection_header(",
          "3637:      const struct mg_connection *conn)",
          "3638:  {",
          "3639:   return should_keep_alive(conn) ? \"keep-alive\" : \"close\";",
          "3640:  }",
          "3643:  static int send_no_cache_header(struct mg_connection * conn)",
          "3644:  {",
          "3646:   return mg_printf(conn,",
          "3647:                    \"Cache-Control: no-cache, no-store, \"",
          "3648:                    \"must-revalidate, private, max-age=0\\r\\n\"",
          "3649:                    \"Pragma: no-cache\\r\\n\"",
          "3650:                    \"Expires: 0\\r\\n\");",
          "3651:  }",
          "3654:  static int send_static_cache_header(struct mg_connection * conn)",
          "3655:  {",
          "3659:   int max_age = atoi(conn->ctx->config[STATIC_FILE_MAX_AGE]);",
          "3660:   if (max_age <= 0) {",
          "3665:    return send_no_cache_header(conn);",
          "3666:   }",
          "3677:   return mg_printf(conn,",
          "3678:                    \"Cache-Control: max-age=%u\\r\\n\",",
          "3679:                    (unsigned)max_age);",
          "3683:  }",
          "3686:  static int send_additional_header(struct mg_connection * conn)",
          "3687:  {",
          "3688:   int i = 0;",
          "3689:   const char *header = conn->ctx->config[ADDITIONAL_HEADER];",
          "3692:   if (conn->ctx->config[STRICT_HTTPS_MAX_AGE]) {",
          "3693:    int max_age = atoi(conn->ctx->config[STRICT_HTTPS_MAX_AGE]);",
          "3694:    if (max_age >= 0) {",
          "3695:     i += mg_printf(conn,",
          "3696:                    \"Strict-Transport-Security: max-age=%u\\r\\n\",",
          "3697:                    (unsigned)max_age);",
          "3698:    }",
          "3702:   if (header && header[0]) {",
          "3703:    i += mg_printf(conn, \"%s\\r\\n\", header);",
          "3704:   }",
          "3706:   return i;",
          "3710:  static void handle_file_based_request(struct mg_connection * conn,",
          "3711:                                        const char *path,",
          "3712:                                        struct mg_file *filep);",
          "3715:  const char *mg_get_response_code_text(const struct mg_connection *conn,",
          "3716:                                        int response_code)",
          "3717:  {",
          "3722:   switch (response_code) {",
          "3724:   case 100:",
          "3726:   case 101:",
          "3728:   case 102:",
          "3732:   case 200:",
          "3734:   case 201:",
          "3736:   case 202:",
          "3738:   case 203:",
          "3740:   case 204:",
          "3742:   case 205:",
          "3744:   case 206:",
          "3746:   case 207:",
          "3747:    return \"Multi-Status\"; /* RFC2518 Section 10.2, RFC4918 Section 11.1",
          "3749:   case 208:",
          "3752:   case 226:",
          "3756:   case 300:",
          "3758:   case 301:",
          "3760:   case 302:",
          "3762:   case 303:",
          "3764:   case 304:",
          "3766:   case 305:",
          "3768:   case 307:",
          "3770:   case 308:",
          "3774:   case 400:",
          "3776:   case 401:",
          "3778:   case 402:",
          "3780:   case 403:",
          "3782:   case 404:",
          "3784:   case 405:",
          "3786:   case 406:",
          "3788:   case 407:",
          "3790:   case 408:",
          "3792:   case 409:",
          "3794:   case 410:",
          "3796:   case 411:",
          "3798:   case 412:",
          "3800:   case 413:",
          "3802:   case 414:",
          "3804:   case 415:",
          "3806:   case 416:",
          "3807:    return \"Requested range not satisfiable\"; /* RFC2616 Section 10.4.17",
          "3809:   case 417:",
          "3812:   case 421:",
          "3814:   case 422:",
          "3815:    return \"Unproccessable entity\"; /* RFC2518 Section 10.3, RFC4918",
          "3817:   case 423:",
          "3819:   case 424:",
          "3820:    return \"Failed Dependency\"; /* RFC2518 Section 10.5, RFC4918",
          "3823:   case 426:",
          "3826:   case 428:",
          "3828:   case 429:",
          "3831:   case 431:",
          "3834:   case 451:",
          "3835:    return \"Unavailable For Legal Reasons\"; /* draft-tbray-http-legally-restricted-status-05,",
          "3839:   case 500:",
          "3841:   case 501:",
          "3843:   case 502:",
          "3845:   case 503:",
          "3847:   case 504:",
          "3849:   case 505:",
          "3851:   case 506:",
          "3853:   case 507:",
          "3854:    return \"Insufficient Storage\"; /* RFC2518 Section 10.6, RFC4918",
          "3856:   case 508:",
          "3859:   case 510:",
          "3861:   case 511:",
          "3867:   case 418:",
          "3869:   case 419:",
          "3871:   case 420:",
          "3873:   case 440:",
          "3875:   case 509:",
          "3878:   default:",
          "3880:    if (conn) {",
          "3881:     mg_cry(conn, \"Unknown HTTP response code: %u\", response_code);",
          "3882:    }",
          "3885:    if (response_code >= 100 && response_code < 200) {",
          "3887:     return \"Information\";",
          "3888:    }",
          "3889:    if (response_code >= 200 && response_code < 300) {",
          "3891:     return \"Success\";",
          "3892:    }",
          "3893:    if (response_code >= 300 && response_code < 400) {",
          "3895:     return \"Redirection\";",
          "3896:    }",
          "3897:    if (response_code >= 400 && response_code < 500) {",
          "3899:     return \"Client Error\";",
          "3900:    }",
          "3901:    if (response_code >= 500 && response_code < 600) {",
          "3903:     return \"Server Error\";",
          "3904:    }",
          "3907:    return \"\";",
          "3912:  void mg_send_http_error(struct mg_connection * conn,",
          "3913:                          int status,",
          "3914:                          const char *fmt,",
          "3915:                          ...)",
          "3916:  {",
          "3917:   char buf[MG_BUF_LEN];",
          "3918:   va_list ap;",
          "3919:   int len, i, page_handler_found, scope, truncated, has_body;",
          "3920:   char date[64];",
          "3921:   time_t curtime = time(NULL);",
          "3922:   const char *error_handler = NULL;",
          "3923:   struct mg_file error_page_file = STRUCT_FILE_INITIALIZER;",
          "3924:   const char *error_page_file_ext, *tstr;",
          "3926:   const char *status_text = mg_get_response_code_text(conn, status);",
          "3928:   if (conn == NULL) {",
          "3929:    return;",
          "3930:   }",
          "3932:   conn->status_code = status;",
          "3933:   if (conn->in_error_handler || (conn->ctx->callbacks.http_error == NULL)",
          "3934:       || conn->ctx->callbacks.http_error(conn, status)) {",
          "3935:    if (!conn->in_error_handler) {",
          "3937:     error_handler = conn->ctx->config[ERROR_PAGES];",
          "3938:     error_page_file_ext = conn->ctx->config[INDEX_FILES];",
          "3939:     page_handler_found = 0;",
          "3940:     if (error_handler != NULL) {",
          "3941:      for (scope = 1; (scope <= 3) && !page_handler_found;",
          "3942:           scope++) {",
          "3943:       switch (scope) {",
          "3945:        mg_snprintf(conn,",
          "3946:                    &truncated,",
          "3947:                    buf,",
          "3948:                    sizeof(buf) - 32,",
          "3949:                    \"%serror%03u.\",",
          "3950:                    error_handler,",
          "3951:                    status);",
          "3952:        break;",
          "3953:       case 2: /* Handler for error group, e.g., 5xx error",
          "3956:        mg_snprintf(conn,",
          "3957:                    &truncated,",
          "3958:                    buf,",
          "3959:                    sizeof(buf) - 32,",
          "3960:                    \"%serror%01uxx.\",",
          "3961:                    error_handler,",
          "3962:                    status / 100);",
          "3965:        mg_snprintf(conn,",
          "3966:                    &truncated,",
          "3967:                    buf,",
          "3968:                    sizeof(buf) - 32,",
          "3969:                    \"%serror.\",",
          "3970:                    error_handler);",
          "3971:        break;",
          "3972:       }",
          "3979:       (void)truncated;",
          "3981:       len = (int)strlen(buf);",
          "3983:       tstr = strchr(error_page_file_ext, '.');",
          "3985:       while (tstr) {",
          "3986:        for (i = 1;",
          "3987:             (i < 32) && (tstr[i] != 0) && (tstr[i] != ',');",
          "3988:             i++)",
          "3989:         buf[len + i - 1] = tstr[i];",
          "3990:        buf[len + i - 1] = 0;",
          "3991:        if (mg_stat(conn, buf, &error_page_file.stat)) {",
          "3992:         page_handler_found = 1;",
          "3993:         break;",
          "3994:        }",
          "3995:        tstr = strchr(tstr + i, '.');",
          "4000:     if (page_handler_found) {",
          "4001:      conn->in_error_handler = 1;",
          "4002:      handle_file_based_request(conn, buf, &error_page_file);",
          "4003:      conn->in_error_handler = 0;",
          "4004:      return;",
          "4005:     }",
          "4009:    gmt_time_string(date, sizeof(date), &curtime);",
          "4012:    has_body = ((status > 199) && (status != 204) && (status != 304));",
          "4014:    conn->must_close = 1;",
          "4015:    mg_printf(conn, \"HTTP/1.1 %d %s\\r\\n\", status, status_text);",
          "4016:    send_no_cache_header(conn);",
          "4017:    send_additional_header(conn);",
          "4018:    if (has_body) {",
          "4019:     mg_printf(conn,",
          "4020:               \"%s\",",
          "4021:               \"Content-Type: text/plain; charset=utf-8\\r\\n\");",
          "4022:    }",
          "4024:              \"Date: %s\\r\\n\"",
          "4025:              \"Connection: close\\r\\n\\r\\n\",",
          "4026:              date);",
          "4029:    if (has_body) {",
          "4030:     mg_printf(conn, \"Error %d: %s\\n\", status, status_text);",
          "4032:     if (fmt != NULL) {",
          "4033:      va_start(ap, fmt);",
          "4034:      mg_vsnprintf(conn, NULL, buf, sizeof(buf), fmt, ap);",
          "4035:      va_end(ap);",
          "4036:      mg_write(conn, buf, strlen(buf));",
          "4037:      DEBUG_TRACE(\"Error %i - [%s]\", status, buf);",
          "4038:     }",
          "4040:    } else {",
          "4042:     DEBUG_TRACE(\"Error %i\", status);",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "4048: #endif",
          "4076: #ifdef ENABLE_UNUSED_PTHREAD_FUNCTIONS",
          "4086:  }",
          "4089: #endif",
          "4150:   EnterCriticalSection(&cv->threadIdSec);",
          "4151:   ptls = &cv->waiting_thread;",
          "4157:    }",
          "4158:   }",
          "4162:   }",
          "4163:  }",
          "4193:  }",
          "4207:  }",
          "4227: #ifdef ALTERNATIVE_QUEUE",
          "4259: #endif",
          "",
          "[Removed Lines]",
          "4051: FUNCTION_MAY_BE_UNUSED",
          "4052: static int",
          "4053: pthread_mutex_init(pthread_mutex_t *mutex, void *unused)",
          "4054: {",
          "4055:  (void)unused;",
          "4057:  return (*mutex == NULL) ? -1 : 0;",
          "4058: }",
          "4060: FUNCTION_MAY_BE_UNUSED",
          "4061: static int",
          "4062: pthread_mutex_destroy(pthread_mutex_t *mutex)",
          "4063: {",
          "4064:  return (CloseHandle(*mutex) == 0) ? -1 : 0;",
          "4065: }",
          "4068: FUNCTION_MAY_BE_UNUSED",
          "4069: static int",
          "4070: pthread_mutex_lock(pthread_mutex_t *mutex)",
          "4071: {",
          "4072:  return (WaitForSingleObject(*mutex, INFINITE) == WAIT_OBJECT_0) ? 0 : -1;",
          "4073: }",
          "4077: FUNCTION_MAY_BE_UNUSED",
          "4078: static int",
          "4079: pthread_mutex_trylock(pthread_mutex_t *mutex)",
          "4080: {",
          "4081:  switch (WaitForSingleObject(*mutex, 0)) {",
          "4082:  case WAIT_OBJECT_0:",
          "4083:   return 0;",
          "4084:  case WAIT_TIMEOUT:",
          "4087:  return -1;",
          "4088: }",
          "4092: FUNCTION_MAY_BE_UNUSED",
          "4093: static int",
          "4094: pthread_mutex_unlock(pthread_mutex_t *mutex)",
          "4095: {",
          "4096:  return (ReleaseMutex(*mutex) == 0) ? -1 : 0;",
          "4097: }",
          "4100: FUNCTION_MAY_BE_UNUSED",
          "4101: static int",
          "4102: pthread_cond_init(pthread_cond_t *cv, const void *unused)",
          "4103: {",
          "4104:  (void)unused;",
          "4105:  InitializeCriticalSection(&cv->threadIdSec);",
          "4106:  cv->waiting_thread = NULL;",
          "4107:  return 0;",
          "4108: }",
          "4111: FUNCTION_MAY_BE_UNUSED",
          "4112: static int",
          "4113: pthread_cond_timedwait(pthread_cond_t *cv,",
          "4114:                        pthread_mutex_t *mutex,",
          "4115:                        const struct timespec *abstime)",
          "4116: {",
          "4117:  struct mg_workerTLS **ptls,",
          "4119:  int ok;",
          "4120:  int64_t nsnow, nswaitabs, nswaitrel;",
          "4121:  DWORD mswaitrel;",
          "4123:  EnterCriticalSection(&cv->threadIdSec);",
          "4125:  ptls = &cv->waiting_thread;",
          "4126:  for (; *ptls != NULL; ptls = &(*ptls)->next_waiting_thread)",
          "4127:   ;",
          "4128:  tls->next_waiting_thread = NULL;",
          "4130:  LeaveCriticalSection(&cv->threadIdSec);",
          "4132:  if (abstime) {",
          "4133:   nsnow = mg_get_current_time_ns();",
          "4134:   nswaitabs =",
          "4135:       (((int64_t)abstime->tv_sec) * 1000000000) + abstime->tv_nsec;",
          "4136:   nswaitrel = nswaitabs - nsnow;",
          "4137:   if (nswaitrel < 0) {",
          "4138:    nswaitrel = 0;",
          "4139:   }",
          "4140:   mswaitrel = (DWORD)(nswaitrel / 1000000);",
          "4141:  } else {",
          "4142:   mswaitrel = INFINITE;",
          "4143:  }",
          "4145:  pthread_mutex_unlock(mutex);",
          "4146:  ok = (WAIT_OBJECT_0",
          "4147:        == WaitForSingleObject(tls->pthread_cond_helper_mutex, mswaitrel));",
          "4148:  if (!ok) {",
          "4149:   ok = 1;",
          "4152:   for (; *ptls != NULL; ptls = &(*ptls)->next_waiting_thread) {",
          "4153:    if (*ptls == tls) {",
          "4155:     ok = 0;",
          "4156:     break;",
          "4159:   LeaveCriticalSection(&cv->threadIdSec);",
          "4160:   if (ok) {",
          "4161:    WaitForSingleObject(tls->pthread_cond_helper_mutex, INFINITE);",
          "4165:  pthread_mutex_lock(mutex);",
          "4167:  return ok ? 0 : -1;",
          "4168: }",
          "4171: FUNCTION_MAY_BE_UNUSED",
          "4172: static int",
          "4173: pthread_cond_wait(pthread_cond_t *cv, pthread_mutex_t *mutex)",
          "4174: {",
          "4175:  return pthread_cond_timedwait(cv, mutex, NULL);",
          "4176: }",
          "4179: FUNCTION_MAY_BE_UNUSED",
          "4180: static int",
          "4181: pthread_cond_signal(pthread_cond_t *cv)",
          "4182: {",
          "4183:  HANDLE wkup = NULL;",
          "4184:  BOOL ok = FALSE;",
          "4186:  EnterCriticalSection(&cv->threadIdSec);",
          "4187:  if (cv->waiting_thread) {",
          "4188:   wkup = cv->waiting_thread->pthread_cond_helper_mutex;",
          "4189:   cv->waiting_thread = cv->waiting_thread->next_waiting_thread;",
          "4191:   ok = SetEvent(wkup);",
          "4192:   assert(ok);",
          "4194:  LeaveCriticalSection(&cv->threadIdSec);",
          "4196:  return ok ? 0 : 1;",
          "4197: }",
          "4200: FUNCTION_MAY_BE_UNUSED",
          "4201: static int",
          "4202: pthread_cond_broadcast(pthread_cond_t *cv)",
          "4203: {",
          "4204:  EnterCriticalSection(&cv->threadIdSec);",
          "4205:  while (cv->waiting_thread) {",
          "4206:   pthread_cond_signal(cv);",
          "4208:  LeaveCriticalSection(&cv->threadIdSec);",
          "4210:  return 0;",
          "4211: }",
          "4214: FUNCTION_MAY_BE_UNUSED",
          "4215: static int",
          "4216: pthread_cond_destroy(pthread_cond_t *cv)",
          "4217: {",
          "4218:  EnterCriticalSection(&cv->threadIdSec);",
          "4219:  assert(cv->waiting_thread == NULL);",
          "4220:  LeaveCriticalSection(&cv->threadIdSec);",
          "4221:  DeleteCriticalSection(&cv->threadIdSec);",
          "4223:  return 0;",
          "4224: }",
          "4228: FUNCTION_MAY_BE_UNUSED",
          "4229: static void *",
          "4230: event_create(void)",
          "4231: {",
          "4232:  return (void *)CreateEvent(NULL, FALSE, FALSE, NULL);",
          "4233: }",
          "4236: FUNCTION_MAY_BE_UNUSED",
          "4237: static int",
          "4238: event_wait(void *eventhdl)",
          "4239: {",
          "4240:  int res = WaitForSingleObject((HANDLE)eventhdl, INFINITE);",
          "4241:  return (res == WAIT_OBJECT_0);",
          "4242: }",
          "4245: FUNCTION_MAY_BE_UNUSED",
          "4246: static int",
          "4247: event_signal(void *eventhdl)",
          "4248: {",
          "4249:  return (int)SetEvent((HANDLE)eventhdl);",
          "4250: }",
          "4253: FUNCTION_MAY_BE_UNUSED",
          "4254: static void",
          "4255: event_destroy(void *eventhdl)",
          "4256: {",
          "4257:  CloseHandle((HANDLE)eventhdl);",
          "4258: }",
          "",
          "[Added Lines]",
          "4057:  FUNCTION_MAY_BE_UNUSED",
          "4058:  static int pthread_mutex_init(pthread_mutex_t * mutex, void *unused)",
          "4059:  {",
          "4060:   (void)unused;",
          "4062:   return (*mutex == NULL) ? -1 : 0;",
          "4063:  }",
          "4065:  FUNCTION_MAY_BE_UNUSED",
          "4066:  static int pthread_mutex_destroy(pthread_mutex_t * mutex)",
          "4067:  {",
          "4068:   return (CloseHandle(*mutex) == 0) ? -1 : 0;",
          "4069:  }",
          "4072:  FUNCTION_MAY_BE_UNUSED",
          "4073:  static int pthread_mutex_lock(pthread_mutex_t * mutex)",
          "4074:  {",
          "4075:   return (WaitForSingleObject(*mutex, INFINITE) == WAIT_OBJECT_0) ? 0",
          "4076:                                                                   : -1;",
          "4077:  }",
          "4081:  FUNCTION_MAY_BE_UNUSED",
          "4082:  static int pthread_mutex_trylock(pthread_mutex_t * mutex)",
          "4083:  {",
          "4084:   switch (WaitForSingleObject(*mutex, 0)) {",
          "4085:   case WAIT_OBJECT_0:",
          "4086:    return 0;",
          "4087:   case WAIT_TIMEOUT:",
          "4089:   }",
          "4090:   return -1;",
          "4095:  FUNCTION_MAY_BE_UNUSED",
          "4096:  static int pthread_mutex_unlock(pthread_mutex_t * mutex)",
          "4097:  {",
          "4098:   return (ReleaseMutex(*mutex) == 0) ? -1 : 0;",
          "4099:  }",
          "4102:  FUNCTION_MAY_BE_UNUSED",
          "4103:  static int pthread_cond_init(pthread_cond_t * cv, const void *unused)",
          "4104:  {",
          "4105:   (void)unused;",
          "4106:   InitializeCriticalSection(&cv->threadIdSec);",
          "4107:   cv->waiting_thread = NULL;",
          "4108:   return 0;",
          "4109:  }",
          "4112:  FUNCTION_MAY_BE_UNUSED",
          "4113:  static int pthread_cond_timedwait(pthread_cond_t * cv,",
          "4114:                                    pthread_mutex_t * mutex,",
          "4115:                                    const struct timespec *abstime)",
          "4116:  {",
          "4117:   struct mg_workerTLS **ptls,",
          "4119:   int ok;",
          "4120:   int64_t nsnow, nswaitabs, nswaitrel;",
          "4121:   DWORD mswaitrel;",
          "4126:   for (; *ptls != NULL; ptls = &(*ptls)->next_waiting_thread)",
          "4127:    ;",
          "4128:   tls->next_waiting_thread = NULL;",
          "4130:   LeaveCriticalSection(&cv->threadIdSec);",
          "4132:   if (abstime) {",
          "4133:    nsnow = mg_get_current_time_ns();",
          "4134:    nswaitabs =",
          "4135:        (((int64_t)abstime->tv_sec) * 1000000000) + abstime->tv_nsec;",
          "4136:    nswaitrel = nswaitabs - nsnow;",
          "4137:    if (nswaitrel < 0) {",
          "4138:     nswaitrel = 0;",
          "4140:    mswaitrel = (DWORD)(nswaitrel / 1000000);",
          "4141:   } else {",
          "4142:    mswaitrel = INFINITE;",
          "4145:   pthread_mutex_unlock(mutex);",
          "4146:   ok =",
          "4147:       (WAIT_OBJECT_0",
          "4148:        == WaitForSingleObject(tls->pthread_cond_helper_mutex, mswaitrel));",
          "4149:   if (!ok) {",
          "4150:    ok = 1;",
          "4151:    EnterCriticalSection(&cv->threadIdSec);",
          "4152:    ptls = &cv->waiting_thread;",
          "4153:    for (; *ptls != NULL; ptls = &(*ptls)->next_waiting_thread) {",
          "4154:     if (*ptls == tls) {",
          "4156:      ok = 0;",
          "4157:      break;",
          "4158:     }",
          "4159:    }",
          "4160:    LeaveCriticalSection(&cv->threadIdSec);",
          "4161:    if (ok) {",
          "4162:     WaitForSingleObject(tls->pthread_cond_helper_mutex, INFINITE);",
          "4163:    }",
          "4166:   pthread_mutex_lock(mutex);",
          "4168:   return ok ? 0 : -1;",
          "4172:  FUNCTION_MAY_BE_UNUSED",
          "4173:  static int pthread_cond_wait(pthread_cond_t * cv, pthread_mutex_t * mutex)",
          "4174:  {",
          "4175:   return pthread_cond_timedwait(cv, mutex, NULL);",
          "4176:  }",
          "4179:  FUNCTION_MAY_BE_UNUSED",
          "4180:  static int pthread_cond_signal(pthread_cond_t * cv)",
          "4181:  {",
          "4182:   HANDLE wkup = NULL;",
          "4183:   BOOL ok = FALSE;",
          "4185:   EnterCriticalSection(&cv->threadIdSec);",
          "4186:   if (cv->waiting_thread) {",
          "4187:    wkup = cv->waiting_thread->pthread_cond_helper_mutex;",
          "4188:    cv->waiting_thread = cv->waiting_thread->next_waiting_thread;",
          "4190:    ok = SetEvent(wkup);",
          "4191:    assert(ok);",
          "4192:   }",
          "4193:   LeaveCriticalSection(&cv->threadIdSec);",
          "4195:   return ok ? 0 : 1;",
          "4199:  FUNCTION_MAY_BE_UNUSED",
          "4200:  static int pthread_cond_broadcast(pthread_cond_t * cv)",
          "4201:  {",
          "4202:   EnterCriticalSection(&cv->threadIdSec);",
          "4203:   while (cv->waiting_thread) {",
          "4204:    pthread_cond_signal(cv);",
          "4205:   }",
          "4206:   LeaveCriticalSection(&cv->threadIdSec);",
          "4208:   return 0;",
          "4212:  FUNCTION_MAY_BE_UNUSED",
          "4213:  static int pthread_cond_destroy(pthread_cond_t * cv)",
          "4214:  {",
          "4215:   EnterCriticalSection(&cv->threadIdSec);",
          "4216:   assert(cv->waiting_thread == NULL);",
          "4217:   LeaveCriticalSection(&cv->threadIdSec);",
          "4218:   DeleteCriticalSection(&cv->threadIdSec);",
          "4220:   return 0;",
          "4221:  }",
          "4225:  FUNCTION_MAY_BE_UNUSED",
          "4226:  static void *event_create(void)",
          "4227:  {",
          "4228:   return (void *)CreateEvent(NULL, FALSE, FALSE, NULL);",
          "4229:  }",
          "4232:  FUNCTION_MAY_BE_UNUSED",
          "4233:  static int event_wait(void *eventhdl)",
          "4234:  {",
          "4235:   int res = WaitForSingleObject((HANDLE)eventhdl, INFINITE);",
          "4236:   return (res == WAIT_OBJECT_0);",
          "4237:  }",
          "4240:  FUNCTION_MAY_BE_UNUSED",
          "4241:  static int event_signal(void *eventhdl)",
          "4242:  {",
          "4243:   return (int)SetEvent((HANDLE)eventhdl);",
          "4244:  }",
          "4247:  FUNCTION_MAY_BE_UNUSED",
          "4248:  static void event_destroy(void *eventhdl)",
          "4249:  {",
          "4250:   CloseHandle((HANDLE)eventhdl);",
          "4251:  }",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "4265: #endif",
          "4284:    }",
          "4285:   }",
          "4286:  }",
          "4329:  }",
          "4345:   }",
          "4349: #if !defined(_WIN32_WCE)",
          "4358:   }",
          "4364: #else",
          "4365:  (void)long_len;",
          "4366:  (void)wbuf2;",
          "",
          "[Removed Lines]",
          "4269: static void",
          "4270: change_slashes_to_backslashes(char *path)",
          "4271: {",
          "4272:  int i;",
          "4274:  for (i = 0; path[i] != '\\0'; i++) {",
          "4275:   if (path[i] == '/') {",
          "4276:    path[i] = '\\\\';",
          "4277:   }",
          "4281:   if ((path[i] == '\\\\') && (i > 0)) {",
          "4282:    while ((path[i + 1] == '\\\\') || (path[i + 1] == '/')) {",
          "4283:     (void)memmove(path + i + 1, path + i + 2, strlen(path + i + 1));",
          "4287: }",
          "4290: static int",
          "4291: mg_wcscasecmp(const wchar_t *s1, const wchar_t *s2)",
          "4292: {",
          "4293:  int diff;",
          "4295:  do {",
          "4296:   diff = tolower(*s1) - tolower(*s2);",
          "4297:   s1++;",
          "4298:   s2++;",
          "4299:  } while ((diff == 0) && (s1[-1] != '\\0'));",
          "4301:  return diff;",
          "4302: }",
          "4307: static void",
          "4308: path_to_unicode(const struct mg_connection *conn,",
          "4309:                 const char *path,",
          "4310:                 wchar_t *wbuf,",
          "4311:                 size_t wbuf_len)",
          "4312: {",
          "4313:  char buf[PATH_MAX], buf2[PATH_MAX];",
          "4314:  wchar_t wbuf2[MAX_PATH + 1];",
          "4315:  DWORD long_len, err;",
          "4316:  int (*fcompare)(const wchar_t *, const wchar_t *) = mg_wcscasecmp;",
          "4318:  mg_strlcpy(buf, path, sizeof(buf));",
          "4319:  change_slashes_to_backslashes(buf);",
          "4323:  memset(wbuf, 0, wbuf_len * sizeof(wchar_t));",
          "4324:  MultiByteToWideChar(CP_UTF8, 0, buf, -1, wbuf, (int)wbuf_len);",
          "4325:  WideCharToMultiByte(",
          "4326:      CP_UTF8, 0, wbuf, (int)wbuf_len, buf2, sizeof(buf2), NULL, NULL);",
          "4327:  if (strcmp(buf, buf2) != 0) {",
          "4328:   wbuf[0] = L'\\0';",
          "4340:  if (conn) {",
          "4341:   if (conn->ctx->config[CASE_SENSITIVE_FILES]",
          "4342:       && !mg_strcasecmp(conn->ctx->config[CASE_SENSITIVE_FILES], \"yes\")) {",
          "4344:    fcompare = wcscmp;",
          "4346:  }",
          "4351:  memset(wbuf2, 0, ARRAY_SIZE(wbuf2) * sizeof(wchar_t));",
          "4352:  long_len = GetLongPathNameW(wbuf, wbuf2, ARRAY_SIZE(wbuf2) - 1);",
          "4353:  if (long_len == 0) {",
          "4354:   err = GetLastError();",
          "4355:   if (err == ERROR_FILE_NOT_FOUND) {",
          "4357:    return;",
          "4359:  }",
          "4360:  if ((long_len >= ARRAY_SIZE(wbuf2)) || (fcompare(wbuf, wbuf2) != 0)) {",
          "4362:   wbuf[0] = L'\\0';",
          "4363:  }",
          "",
          "[Added Lines]",
          "4262:  static void change_slashes_to_backslashes(char *path)",
          "4263:  {",
          "4264:   int i;",
          "4266:   for (i = 0; path[i] != '\\0'; i++) {",
          "4267:    if (path[i] == '/') {",
          "4268:     path[i] = '\\\\';",
          "4269:    }",
          "4273:    if ((path[i] == '\\\\') && (i > 0)) {",
          "4274:     while ((path[i + 1] == '\\\\') || (path[i + 1] == '/')) {",
          "4275:      (void)memmove(path + i + 1,",
          "4276:                    path + i + 2,",
          "4277:                    strlen(path + i + 1));",
          "4278:     }",
          "4284:  static int mg_wcscasecmp(const wchar_t *s1, const wchar_t *s2)",
          "4285:  {",
          "4286:   int diff;",
          "4288:   do {",
          "4289:    diff = tolower(*s1) - tolower(*s2);",
          "4290:    s1++;",
          "4291:    s2++;",
          "4292:   } while ((diff == 0) && (s1[-1] != '\\0'));",
          "4294:   return diff;",
          "4300:  static void path_to_unicode(const struct mg_connection *conn,",
          "4301:                              const char *path,",
          "4302:                              wchar_t *wbuf,",
          "4303:                              size_t wbuf_len)",
          "4304:  {",
          "4305:   char buf[PATH_MAX], buf2[PATH_MAX];",
          "4306:   wchar_t wbuf2[MAX_PATH + 1];",
          "4307:   DWORD long_len, err;",
          "4308:   int (*fcompare)(const wchar_t *, const wchar_t *) = mg_wcscasecmp;",
          "4310:   mg_strlcpy(buf, path, sizeof(buf));",
          "4311:   change_slashes_to_backslashes(buf);",
          "4315:   memset(wbuf, 0, wbuf_len * sizeof(wchar_t));",
          "4316:   MultiByteToWideChar(CP_UTF8, 0, buf, -1, wbuf, (int)wbuf_len);",
          "4317:   WideCharToMultiByte(",
          "4318:       CP_UTF8, 0, wbuf, (int)wbuf_len, buf2, sizeof(buf2), NULL, NULL);",
          "4319:   if (strcmp(buf, buf2) != 0) {",
          "4320:    wbuf[0] = L'\\0';",
          "4321:   }",
          "4332:   if (conn) {",
          "4333:    if (conn->ctx->config[CASE_SENSITIVE_FILES]",
          "4334:        && !mg_strcasecmp(conn->ctx->config[CASE_SENSITIVE_FILES],",
          "4335:                          \"yes\")) {",
          "4337:     fcompare = wcscmp;",
          "4338:    }",
          "4344:   memset(wbuf2, 0, ARRAY_SIZE(wbuf2) * sizeof(wchar_t));",
          "4345:   long_len = GetLongPathNameW(wbuf, wbuf2, ARRAY_SIZE(wbuf2) - 1);",
          "4346:   if (long_len == 0) {",
          "4347:    err = GetLastError();",
          "4348:    if (err == ERROR_FILE_NOT_FOUND) {",
          "4350:     return;",
          "4351:    }",
          "4352:   }",
          "4353:   if ((long_len >= ARRAY_SIZE(wbuf2)) || (fcompare(wbuf, wbuf2) != 0)) {",
          "4355:    wbuf[0] = L'\\0';",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "4370:   wbuf[0] = L'\\0';",
          "4371:  }",
          "4372: #endif",
          "4455:   }",
          "4458:  }",
          "",
          "[Removed Lines]",
          "4373: }",
          "4380: static int",
          "4381: path_cannot_disclose_cgi(const char *path)",
          "4382: {",
          "4383:  static const char *allowed_last_characters = \"_-\";",
          "4384:  int last = path[strlen(path) - 1];",
          "4385:  return isalnum(last) || strchr(allowed_last_characters, last) != NULL;",
          "4386: }",
          "4389: static int",
          "4390: mg_stat(const struct mg_connection *conn,",
          "4391:         const char *path,",
          "4392:         struct mg_file_stat *filep)",
          "4393: {",
          "4394:  wchar_t wbuf[PATH_MAX];",
          "4395:  WIN32_FILE_ATTRIBUTE_DATA info;",
          "4396:  time_t creation_time;",
          "4398:  if (!filep) {",
          "4399:   return 0;",
          "4400:  }",
          "4401:  memset(filep, 0, sizeof(*filep));",
          "4403:  if (conn && is_file_in_memory(conn, path)) {",
          "4409:   struct mg_file tmp_file = STRUCT_FILE_INITIALIZER;",
          "4410:   open_file_in_memory(conn, path, &tmp_file, MG_FOPEN_MODE_NONE);",
          "4411:   filep->size = tmp_file.stat.size;",
          "4412:   filep->location = 2;",
          "4427:   return 1;",
          "4428:  }",
          "4430:  path_to_unicode(conn, path, wbuf, ARRAY_SIZE(wbuf));",
          "4431:  if (GetFileAttributesExW(wbuf, GetFileExInfoStandard, &info) != 0) {",
          "4432:   filep->size = MAKEUQUAD(info.nFileSizeLow, info.nFileSizeHigh);",
          "4433:   filep->last_modified =",
          "4434:       SYS2UNIX_TIME(info.ftLastWriteTime.dwLowDateTime,",
          "4435:                     info.ftLastWriteTime.dwHighDateTime);",
          "4441:   creation_time = SYS2UNIX_TIME(info.ftCreationTime.dwLowDateTime,",
          "4442:                                 info.ftCreationTime.dwHighDateTime);",
          "4443:   if (creation_time > filep->last_modified) {",
          "4444:    filep->last_modified = creation_time;",
          "4445:   }",
          "4447:   filep->is_directory = info.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY;",
          "4452:   if (!filep->is_directory && !path_cannot_disclose_cgi(path)) {",
          "4453:    memset(filep, 0, sizeof(*filep));",
          "4454:    return 0;",
          "4457:   return 1;",
          "4460:  return 0;",
          "4461: }",
          "4464: static int",
          "4465: mg_remove(const struct mg_connection *conn, const char *path)",
          "4466: {",
          "4467:  wchar_t wbuf[PATH_MAX];",
          "4468:  path_to_unicode(conn, path, wbuf, ARRAY_SIZE(wbuf));",
          "4469:  return DeleteFileW(wbuf) ? 0 : -1;",
          "4470: }",
          "4473: static int",
          "4474: mg_mkdir(const struct mg_connection *conn, const char *path, int mode)",
          "4475: {",
          "4476:  wchar_t wbuf[PATH_MAX];",
          "4477:  (void)mode;",
          "4478:  path_to_unicode(conn, path, wbuf, ARRAY_SIZE(wbuf));",
          "4479:  return CreateDirectoryW(wbuf, NULL) ? 0 : -1;",
          "4480: }",
          "",
          "[Added Lines]",
          "4366:  }",
          "4373:  static int path_cannot_disclose_cgi(const char *path)",
          "4374:  {",
          "4375:   static const char *allowed_last_characters = \"_-\";",
          "4376:   int last = path[strlen(path) - 1];",
          "4377:   return isalnum(last) || strchr(allowed_last_characters, last) != NULL;",
          "4378:  }",
          "4381:  static int mg_stat(const struct mg_connection *conn,",
          "4382:                     const char *path,",
          "4383:                     struct mg_file_stat *filep)",
          "4384:  {",
          "4385:   wchar_t wbuf[PATH_MAX];",
          "4386:   WIN32_FILE_ATTRIBUTE_DATA info;",
          "4387:   time_t creation_time;",
          "4389:   if (!filep) {",
          "4390:    return 0;",
          "4391:   }",
          "4392:   memset(filep, 0, sizeof(*filep));",
          "4394:   if (conn && is_file_in_memory(conn, path)) {",
          "4400:    struct mg_file tmp_file = STRUCT_FILE_INITIALIZER;",
          "4401:    open_file_in_memory(conn, path, &tmp_file, MG_FOPEN_MODE_NONE);",
          "4402:    filep->size = tmp_file.stat.size;",
          "4403:    filep->location = 2;",
          "4420:    return 1;",
          "4421:   }",
          "4423:   path_to_unicode(conn, path, wbuf, ARRAY_SIZE(wbuf));",
          "4424:   if (GetFileAttributesExW(wbuf, GetFileExInfoStandard, &info) != 0) {",
          "4425:    filep->size = MAKEUQUAD(info.nFileSizeLow, info.nFileSizeHigh);",
          "4426:    filep->last_modified =",
          "4427:        SYS2UNIX_TIME(info.ftLastWriteTime.dwLowDateTime,",
          "4428:                      info.ftLastWriteTime.dwHighDateTime);",
          "4434:    creation_time = SYS2UNIX_TIME(info.ftCreationTime.dwLowDateTime,",
          "4435:                                  info.ftCreationTime.dwHighDateTime);",
          "4436:    if (creation_time > filep->last_modified) {",
          "4437:     filep->last_modified = creation_time;",
          "4438:    }",
          "4440:    filep->is_directory =",
          "4441:        info.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY;",
          "4446:    if (!filep->is_directory && !path_cannot_disclose_cgi(path)) {",
          "4447:     memset(filep, 0, sizeof(*filep));",
          "4448:     return 0;",
          "4449:    }",
          "4451:    return 1;",
          "4454:   return 0;",
          "4458:  static int mg_remove(const struct mg_connection *conn, const char *path)",
          "4459:  {",
          "4460:   wchar_t wbuf[PATH_MAX];",
          "4461:   path_to_unicode(conn, path, wbuf, ARRAY_SIZE(wbuf));",
          "4462:   return DeleteFileW(wbuf) ? 0 : -1;",
          "4463:  }",
          "4466:  static int mg_mkdir(const struct mg_connection *conn,",
          "4467:                      const char *path,",
          "4468:                      int mode)",
          "4469:  {",
          "4470:   wchar_t wbuf[PATH_MAX];",
          "4471:   (void)mode;",
          "4472:   path_to_unicode(conn, path, wbuf, ARRAY_SIZE(wbuf));",
          "4473:   return CreateDirectoryW(wbuf, NULL) ? 0 : -1;",
          "4474:  }",
          "",
          "---------------",
          "--- Hunk 34 ---",
          "[Context before]",
          "4489: #endif",
          "4513:   } else {",
          "4516:   }",
          "4517:  }",
          "4537:  }",
          "4564:    }",
          "4566:   } else {",
          "4568:   }",
          "4577: #ifndef HAVE_POLL",
          "4599:   }",
          "4606:    }",
          "4607:   }",
          "",
          "[Removed Lines]",
          "4493: FUNCTION_MAY_BE_UNUSED",
          "4494: static DIR *",
          "4495: mg_opendir(const struct mg_connection *conn, const char *name)",
          "4496: {",
          "4497:  DIR *dir = NULL;",
          "4498:  wchar_t wpath[PATH_MAX];",
          "4499:  DWORD attrs;",
          "4501:  if (name == NULL) {",
          "4502:   SetLastError(ERROR_BAD_ARGUMENTS);",
          "4503:  } else if ((dir = (DIR *)mg_malloc(sizeof(*dir))) == NULL) {",
          "4504:   SetLastError(ERROR_NOT_ENOUGH_MEMORY);",
          "4505:  } else {",
          "4506:   path_to_unicode(conn, name, wpath, ARRAY_SIZE(wpath));",
          "4507:   attrs = GetFileAttributesW(wpath);",
          "4508:   if (attrs != 0xFFFFFFFF && ((attrs & FILE_ATTRIBUTE_DIRECTORY)",
          "4509:                               == FILE_ATTRIBUTE_DIRECTORY)) {",
          "4510:    (void)wcscat(wpath, L\"\\\\*\");",
          "4511:    dir->handle = FindFirstFileW(wpath, &dir->info);",
          "4512:    dir->result.d_name[0] = '\\0';",
          "4514:    mg_free(dir);",
          "4515:    dir = NULL;",
          "4519:  return dir;",
          "4520: }",
          "4523: FUNCTION_MAY_BE_UNUSED",
          "4524: static int",
          "4525: mg_closedir(DIR *dir)",
          "4526: {",
          "4527:  int result = 0;",
          "4529:  if (dir != NULL) {",
          "4530:   if (dir->handle != INVALID_HANDLE_VALUE)",
          "4531:    result = FindClose(dir->handle) ? 0 : -1;",
          "4533:   mg_free(dir);",
          "4534:  } else {",
          "4535:   result = -1;",
          "4536:   SetLastError(ERROR_BAD_ARGUMENTS);",
          "4539:  return result;",
          "4540: }",
          "4543: FUNCTION_MAY_BE_UNUSED",
          "4544: static struct dirent *",
          "4545: mg_readdir(DIR *dir)",
          "4546: {",
          "4547:  struct dirent *result = 0;",
          "4549:  if (dir) {",
          "4550:   if (dir->handle != INVALID_HANDLE_VALUE) {",
          "4551:    result = &dir->result;",
          "4552:    (void)WideCharToMultiByte(CP_UTF8,",
          "4553:                              0,",
          "4554:                              dir->info.cFileName,",
          "4555:                              -1,",
          "4556:                              result->d_name,",
          "4557:                              sizeof(result->d_name),",
          "4558:                              NULL,",
          "4559:                              NULL);",
          "4561:    if (!FindNextFileW(dir->handle, &dir->info)) {",
          "4562:     (void)FindClose(dir->handle);",
          "4563:     dir->handle = INVALID_HANDLE_VALUE;",
          "4567:    SetLastError(ERROR_FILE_NOT_FOUND);",
          "4569:  } else {",
          "4570:   SetLastError(ERROR_BAD_ARGUMENTS);",
          "4571:  }",
          "4573:  return result;",
          "4574: }",
          "4578: FUNCTION_MAY_BE_UNUSED",
          "4579: static int",
          "4580: poll(struct pollfd *pfd, unsigned int n, int milliseconds)",
          "4581: {",
          "4582:  struct timeval tv;",
          "4583:  fd_set set;",
          "4584:  unsigned int i;",
          "4585:  int result;",
          "4586:  SOCKET maxfd = 0;",
          "4588:  memset(&tv, 0, sizeof(tv));",
          "4589:  tv.tv_sec = milliseconds / 1000;",
          "4590:  tv.tv_usec = (milliseconds % 1000) * 1000;",
          "4591:  FD_ZERO(&set);",
          "4593:  for (i = 0; i < n; i++) {",
          "4594:   FD_SET((SOCKET)pfd[i].fd, &set);",
          "4595:   pfd[i].revents = 0;",
          "4597:   if (pfd[i].fd > maxfd) {",
          "4598:    maxfd = pfd[i].fd;",
          "4600:  }",
          "4602:  if ((result = select((int)maxfd + 1, &set, NULL, NULL, &tv)) > 0) {",
          "4603:   for (i = 0; i < n; i++) {",
          "4604:    if (FD_ISSET(pfd[i].fd, &set)) {",
          "4605:     pfd[i].revents = POLLIN;",
          "4608:  }",
          "4617:  return result;",
          "4618: }",
          "",
          "[Added Lines]",
          "4487:  FUNCTION_MAY_BE_UNUSED",
          "4488:  static DIR *mg_opendir(const struct mg_connection *conn, const char *name)",
          "4489:  {",
          "4490:   DIR *dir = NULL;",
          "4491:   wchar_t wpath[PATH_MAX];",
          "4492:   DWORD attrs;",
          "4494:   if (name == NULL) {",
          "4495:    SetLastError(ERROR_BAD_ARGUMENTS);",
          "4496:   } else if ((dir = (DIR *)mg_malloc(sizeof(*dir))) == NULL) {",
          "4497:    SetLastError(ERROR_NOT_ENOUGH_MEMORY);",
          "4499:    path_to_unicode(conn, name, wpath, ARRAY_SIZE(wpath));",
          "4500:    attrs = GetFileAttributesW(wpath);",
          "4501:    if (attrs != 0xFFFFFFFF && ((attrs & FILE_ATTRIBUTE_DIRECTORY)",
          "4502:                                == FILE_ATTRIBUTE_DIRECTORY)) {",
          "4503:     (void)wcscat(wpath, L\"\\\\*\");",
          "4504:     dir->handle = FindFirstFileW(wpath, &dir->info);",
          "4505:     dir->result.d_name[0] = '\\0';",
          "4506:    } else {",
          "4507:     mg_free(dir);",
          "4508:     dir = NULL;",
          "4509:    }",
          "4512:   return dir;",
          "4516:  FUNCTION_MAY_BE_UNUSED",
          "4517:  static int mg_closedir(DIR * dir)",
          "4518:  {",
          "4519:   int result = 0;",
          "4521:   if (dir != NULL) {",
          "4522:    if (dir->handle != INVALID_HANDLE_VALUE)",
          "4523:     result = FindClose(dir->handle) ? 0 : -1;",
          "4525:    mg_free(dir);",
          "4526:   } else {",
          "4527:    result = -1;",
          "4528:    SetLastError(ERROR_BAD_ARGUMENTS);",
          "4529:   }",
          "4531:   return result;",
          "4535:  FUNCTION_MAY_BE_UNUSED",
          "4536:  static struct dirent *mg_readdir(DIR * dir)",
          "4537:  {",
          "4538:   struct dirent *result = 0;",
          "4540:   if (dir) {",
          "4541:    if (dir->handle != INVALID_HANDLE_VALUE) {",
          "4542:     result = &dir->result;",
          "4543:     (void)WideCharToMultiByte(CP_UTF8,",
          "4544:                               0,",
          "4545:                               dir->info.cFileName,",
          "4546:                               -1,",
          "4547:                               result->d_name,",
          "4548:                               sizeof(result->d_name),",
          "4549:                               NULL,",
          "4550:                               NULL);",
          "4552:     if (!FindNextFileW(dir->handle, &dir->info)) {",
          "4553:      (void)FindClose(dir->handle);",
          "4554:      dir->handle = INVALID_HANDLE_VALUE;",
          "4555:     }",
          "4557:    } else {",
          "4558:     SetLastError(ERROR_FILE_NOT_FOUND);",
          "4561:    SetLastError(ERROR_BAD_ARGUMENTS);",
          "4564:   return result;",
          "4565:  }",
          "4569:  FUNCTION_MAY_BE_UNUSED",
          "4570:  static int poll(struct pollfd * pfd, unsigned int n, int milliseconds)",
          "4571:  {",
          "4572:   struct timeval tv;",
          "4573:   fd_set set;",
          "4574:   unsigned int i;",
          "4575:   int result;",
          "4576:   SOCKET maxfd = 0;",
          "4578:   memset(&tv, 0, sizeof(tv));",
          "4579:   tv.tv_sec = milliseconds / 1000;",
          "4580:   tv.tv_usec = (milliseconds % 1000) * 1000;",
          "4581:   FD_ZERO(&set);",
          "4583:   for (i = 0; i < n; i++) {",
          "4584:    FD_SET((SOCKET)pfd[i].fd, &set);",
          "4585:    pfd[i].revents = 0;",
          "4587:    if (pfd[i].fd > maxfd) {",
          "4588:     maxfd = pfd[i].fd;",
          "4589:    }",
          "4592:   if ((result = select((int)maxfd + 1, &set, NULL, NULL, &tv)) > 0) {",
          "4593:    for (i = 0; i < n; i++) {",
          "4594:     if (FD_ISSET(pfd[i].fd, &set)) {",
          "4595:      pfd[i].revents = POLLIN;",
          "4596:     }",
          "4607:   return result;",
          "4608:  }",
          "",
          "---------------",
          "--- Hunk 35 ---",
          "[Context before]",
          "4625: #endif",
          "4632: #if defined(_WIN32_WCE)",
          "4634: #else",
          "4635:  (void)SetHandleInformation((HANDLE)(intptr_t)sock, HANDLE_FLAG_INHERIT, 0);",
          "4636: #endif",
          "4643: #if defined(USE_STACK_SIZE) && (USE_STACK_SIZE > 1)",
          "4650: #else",
          "4651:  return (",
          "4652:      (_beginthread((void(__cdecl *)(void *))f, 0, p) == ((uintptr_t)(-1L)))",
          "4653:          ? -1",
          "4654:          : 0);",
          "4674:  }",
          "4695:   }",
          "4701: #if !defined(NO_SSL_DL) && !defined(NO_SSL)",
          "",
          "[Removed Lines]",
          "4628: static void",
          "4629: set_close_on_exec(SOCKET sock, struct mg_connection *conn /* may be null */)",
          "4630: {",
          "4633:  (void)sock;",
          "4637: }",
          "4640: int",
          "4641: mg_start_thread(mg_thread_func_t f, void *p)",
          "4642: {",
          "4646:  return ((_beginthread((void(__cdecl *)(void *))f, USE_STACK_SIZE, p)",
          "4647:           == ((uintptr_t)(-1L)))",
          "4648:              ? -1",
          "4649:              : 0);",
          "4656: }",
          "4660: static int",
          "4661: mg_start_thread_with_id(unsigned(__stdcall *f)(void *),",
          "4662:                         void *p,",
          "4663:                         pthread_t *threadidptr)",
          "4664: {",
          "4665:  uintptr_t uip;",
          "4666:  HANDLE threadhandle;",
          "4667:  int result = -1;",
          "4669:  uip = _beginthreadex(NULL, 0, (unsigned(__stdcall *)(void *))f, p, 0, NULL);",
          "4670:  threadhandle = (HANDLE)uip;",
          "4671:  if ((uip != (uintptr_t)(-1L)) && (threadidptr != NULL)) {",
          "4673:   result = 0;",
          "4676:  return result;",
          "4677: }",
          "4681: static int",
          "4682: mg_join_thread(pthread_t threadid)",
          "4683: {",
          "4684:  int result;",
          "4685:  DWORD dwevent;",
          "4687:  result = -1;",
          "4688:  dwevent = WaitForSingleObject(threadid, INFINITE);",
          "4689:  if (dwevent == WAIT_FAILED) {",
          "4690:   DEBUG_TRACE(\"WaitForSingleObject() failed, error %d\", ERRNO);",
          "4691:  } else {",
          "4692:   if (dwevent == WAIT_OBJECT_0) {",
          "4693:    CloseHandle(threadid);",
          "4694:    result = 0;",
          "4696:  }",
          "4698:  return result;",
          "4699: }",
          "",
          "[Added Lines]",
          "4618:  static void set_close_on_exec(SOCKET sock,",
          "4619:                                struct mg_connection * conn /* may be null */)",
          "4620:  {",
          "4623:   (void)sock;",
          "4627:  }",
          "4630:  int mg_start_thread(mg_thread_func_t f, void *p)",
          "4631:  {",
          "4636:   return ((_beginthread((void(__cdecl *)(void *))f, USE_STACK_SIZE, p)",
          "4637:            == ((uintptr_t)(-1L)))",
          "4638:               ? -1",
          "4639:               : 0);",
          "4646:  }",
          "4650:  static int mg_start_thread_with_id(unsigned(__stdcall * f)(void *),",
          "4651:                                     void *p,",
          "4652:                                     pthread_t *threadidptr)",
          "4653:  {",
          "4654:   uintptr_t uip;",
          "4655:   HANDLE threadhandle;",
          "4656:   int result = -1;",
          "4658:   uip = _beginthreadex(",
          "4659:       NULL, 0, (unsigned(__stdcall *)(void *))f, p, 0, NULL);",
          "4660:   threadhandle = (HANDLE)uip;",
          "4661:   if ((uip != (uintptr_t)(-1L)) && (threadidptr != NULL)) {",
          "4663:    result = 0;",
          "4664:   }",
          "4666:   return result;",
          "4671:  static int mg_join_thread(pthread_t threadid)",
          "4672:  {",
          "4673:   int result;",
          "4674:   DWORD dwevent;",
          "4676:   result = -1;",
          "4677:   dwevent = WaitForSingleObject(threadid, INFINITE);",
          "4678:   if (dwevent == WAIT_FAILED) {",
          "4679:    DEBUG_TRACE(\"WaitForSingleObject() failed, error %d\", ERRNO);",
          "4680:   } else {",
          "4681:    if (dwevent == WAIT_OBJECT_0) {",
          "4682:     CloseHandle(threadid);",
          "4683:     result = 0;",
          "4684:    }",
          "4687:   return result;",
          "4688:  }",
          "",
          "---------------",
          "--- Hunk 36 ---",
          "[Context before]",
          "4709: #endif",
          "4739: #if defined(__MINGW32__)",
          "",
          "[Removed Lines]",
          "4712: FUNCTION_MAY_BE_UNUSED",
          "4713: static HANDLE",
          "4714: dlopen(const char *dll_name, int flags)",
          "4715: {",
          "4716:  wchar_t wbuf[PATH_MAX];",
          "4717:  (void)flags;",
          "4718:  path_to_unicode(NULL, dll_name, wbuf, ARRAY_SIZE(wbuf));",
          "4719:  return LoadLibraryW(wbuf);",
          "4720: }",
          "4723: FUNCTION_MAY_BE_UNUSED",
          "4724: static int",
          "4725: dlclose(void *handle)",
          "4726: {",
          "4727:  int result;",
          "4729:  if (FreeLibrary((HMODULE)handle) != 0) {",
          "4730:   result = 0;",
          "4731:  } else {",
          "4732:   result = -1;",
          "4733:  }",
          "4735:  return result;",
          "4736: }",
          "",
          "[Added Lines]",
          "4701:  FUNCTION_MAY_BE_UNUSED",
          "4702:  static HANDLE dlopen(const char *dll_name, int flags)",
          "4703:  {",
          "4704:   wchar_t wbuf[PATH_MAX];",
          "4705:   (void)flags;",
          "4706:   path_to_unicode(NULL, dll_name, wbuf, ARRAY_SIZE(wbuf));",
          "4707:   return LoadLibraryW(wbuf);",
          "4708:  }",
          "4711:  FUNCTION_MAY_BE_UNUSED",
          "4712:  static int dlclose(void *handle)",
          "4713:  {",
          "4714:   int result;",
          "4716:   if (FreeLibrary((HMODULE)handle) != 0) {",
          "4717:    result = 0;",
          "4718:   } else {",
          "4719:    result = -1;",
          "4720:   }",
          "4722:   return result;",
          "4723:  }",
          "",
          "---------------",
          "--- Hunk 37 ---",
          "[Context before]",
          "4747: #if !defined(NO_CGI)",
          "4748: #define SIGKILL (0)",
          "4765:  }",
          "4840:   if (truncated) {",
          "4841:    pi.hProcess = (pid_t)-1;",
          "4842:    goto spawn_cleanup;",
          "4843:   }",
          "4850:   }",
          "4856:   }",
          "4863:  }",
          "4927: #else",
          "",
          "[Removed Lines]",
          "4750: static int",
          "4751: kill(pid_t pid, int sig_num)",
          "4752: {",
          "4753:  (void)TerminateProcess((HANDLE)pid, (UINT)sig_num);",
          "4754:  (void)CloseHandle((HANDLE)pid);",
          "4755:  return 0;",
          "4756: }",
          "4759: static void",
          "4760: trim_trailing_whitespaces(char *s)",
          "4761: {",
          "4762:  char *e = s + strlen(s) - 1;",
          "4763:  while ((e > s) && isspace(*(unsigned char *)e)) {",
          "4766: }",
          "4769: static pid_t",
          "4770: spawn_process(struct mg_connection *conn,",
          "4771:               const char *prog,",
          "4772:               char *envblk,",
          "4773:               char *envp[],",
          "4774:               int fdin[2],",
          "4775:               int fdout[2],",
          "4776:               int fderr[2],",
          "4777:               const char *dir)",
          "4778: {",
          "4779:  HANDLE me;",
          "4780:  char *p, *interp, full_interp[PATH_MAX], full_dir[PATH_MAX],",
          "4781:      cmdline[PATH_MAX], buf[PATH_MAX];",
          "4782:  int truncated;",
          "4783:  struct mg_file file = STRUCT_FILE_INITIALIZER;",
          "4784:  STARTUPINFOA si;",
          "4785:  PROCESS_INFORMATION pi = {0};",
          "4787:  (void)envp;",
          "4789:  memset(&si, 0, sizeof(si));",
          "4790:  si.cb = sizeof(si);",
          "4792:  si.dwFlags = STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW;",
          "4793:  si.wShowWindow = SW_HIDE;",
          "4795:  me = GetCurrentProcess();",
          "4796:  DuplicateHandle(me,",
          "4797:                  (HANDLE)_get_osfhandle(fdin[0]),",
          "4798:                  me,",
          "4799:                  &si.hStdInput,",
          "4800:                  0,",
          "4801:                  TRUE,",
          "4802:                  DUPLICATE_SAME_ACCESS);",
          "4803:  DuplicateHandle(me,",
          "4804:                  (HANDLE)_get_osfhandle(fdout[1]),",
          "4805:                  me,",
          "4806:                  &si.hStdOutput,",
          "4807:                  0,",
          "4808:                  TRUE,",
          "4809:                  DUPLICATE_SAME_ACCESS);",
          "4810:  DuplicateHandle(me,",
          "4811:                  (HANDLE)_get_osfhandle(fderr[1]),",
          "4812:                  me,",
          "4813:                  &si.hStdError,",
          "4814:                  0,",
          "4815:                  TRUE,",
          "4816:                  DUPLICATE_SAME_ACCESS);",
          "4821:  SetHandleInformation((HANDLE)_get_osfhandle(fdin[1]),",
          "4822:                       HANDLE_FLAG_INHERIT,",
          "4823:                       0);",
          "4824:  SetHandleInformation((HANDLE)_get_osfhandle(fdout[0]),",
          "4825:                       HANDLE_FLAG_INHERIT,",
          "4826:                       0);",
          "4827:  SetHandleInformation((HANDLE)_get_osfhandle(fderr[0]),",
          "4828:                       HANDLE_FLAG_INHERIT,",
          "4829:                       0);",
          "4832:  interp = conn->ctx->config[CGI_INTERPRETER];",
          "4833:  if (interp == NULL) {",
          "4834:   buf[0] = buf[1] = '\\0';",
          "4837:   mg_snprintf(",
          "4838:       conn, &truncated, cmdline, sizeof(cmdline), \"%s/%s\", dir, prog);",
          "4845:   if (mg_fopen(conn, cmdline, MG_FOPEN_MODE_READ, &file)) {",
          "4846:    p = (char *)file.access.membuf;",
          "4847:    mg_fgets(buf, sizeof(buf), &file, &p);",
          "4849:    buf[sizeof(buf) - 1] = '\\0';",
          "4852:   if ((buf[0] == '#') && (buf[1] == '!')) {",
          "4853:    trim_trailing_whitespaces(buf + 2);",
          "4854:   } else {",
          "4855:    buf[2] = '\\0';",
          "4857:   interp = buf + 2;",
          "4858:  }",
          "4860:  if (interp[0] != '\\0') {",
          "4861:   GetFullPathNameA(interp, sizeof(full_interp), full_interp, NULL);",
          "4862:   interp = full_interp;",
          "4864:  GetFullPathNameA(dir, sizeof(full_dir), full_dir, NULL);",
          "4866:  if (interp[0] != '\\0') {",
          "4867:   mg_snprintf(conn,",
          "4868:               &truncated,",
          "4869:               cmdline,",
          "4870:               sizeof(cmdline),",
          "4871:               \"\\\"%s\\\" \\\"%s\\\\%s\\\"\",",
          "4872:               interp,",
          "4873:               full_dir,",
          "4874:               prog);",
          "4875:  } else {",
          "4876:   mg_snprintf(conn,",
          "4877:               &truncated,",
          "4878:               cmdline,",
          "4879:               sizeof(cmdline),",
          "4880:               \"\\\"%s\\\\%s\\\"\",",
          "4881:               full_dir,",
          "4882:               prog);",
          "4883:  }",
          "4885:  if (truncated) {",
          "4886:   pi.hProcess = (pid_t)-1;",
          "4887:   goto spawn_cleanup;",
          "4888:  }",
          "4890:  DEBUG_TRACE(\"Running [%s]\", cmdline);",
          "4891:  if (CreateProcessA(NULL,",
          "4892:                     cmdline,",
          "4893:                     NULL,",
          "4894:                     NULL,",
          "4895:                     TRUE,",
          "4896:                     CREATE_NEW_PROCESS_GROUP,",
          "4897:                     envblk,",
          "4898:                     NULL,",
          "4899:                     &si,",
          "4900:                     &pi) == 0) {",
          "4901:   mg_cry(",
          "4902:       conn, \"%s: CreateProcess(%s): %ld\", __func__, cmdline, (long)ERRNO);",
          "4903:   pi.hProcess = (pid_t)-1;",
          "4905:  }",
          "4907: spawn_cleanup:",
          "4908:  (void)CloseHandle(si.hStdOutput);",
          "4909:  (void)CloseHandle(si.hStdError);",
          "4910:  (void)CloseHandle(si.hStdInput);",
          "4911:  if (pi.hThread != NULL) {",
          "4912:   (void)CloseHandle(pi.hThread);",
          "4913:  }",
          "4915:  return (pid_t)pi.hProcess;",
          "4916: }",
          "4920: static int",
          "4921: set_blocking_mode(SOCKET sock, int blocking)",
          "4922: {",
          "4923:  unsigned long non_blocking = !blocking;",
          "4924:  return ioctlsocket(sock, (long)FIONBIO, &non_blocking);",
          "4925: }",
          "",
          "[Added Lines]",
          "4737:  static int kill(pid_t pid, int sig_num)",
          "4738:  {",
          "4739:   (void)TerminateProcess((HANDLE)pid, (UINT)sig_num);",
          "4740:   (void)CloseHandle((HANDLE)pid);",
          "4741:   return 0;",
          "4742:  }",
          "4745:  static void trim_trailing_whitespaces(char *s)",
          "4746:  {",
          "4747:   char *e = s + strlen(s) - 1;",
          "4748:   while ((e > s) && isspace(*(unsigned char *)e)) {",
          "4750:   }",
          "4754:  static pid_t spawn_process(struct mg_connection * conn,",
          "4755:                             const char *prog,",
          "4756:                             char *envblk,",
          "4757:                             char *envp[],",
          "4758:                             int fdin[2],",
          "4759:                             int fdout[2],",
          "4760:                             int fderr[2],",
          "4761:                             const char *dir)",
          "4762:  {",
          "4763:   HANDLE me;",
          "4764:   char *p, *interp, full_interp[PATH_MAX], full_dir[PATH_MAX],",
          "4765:       cmdline[PATH_MAX], buf[PATH_MAX];",
          "4766:   int truncated;",
          "4767:   struct mg_file file = STRUCT_FILE_INITIALIZER;",
          "4768:   STARTUPINFOA si;",
          "4769:   PROCESS_INFORMATION pi = {0};",
          "4771:   (void)envp;",
          "4773:   memset(&si, 0, sizeof(si));",
          "4774:   si.cb = sizeof(si);",
          "4776:   si.dwFlags = STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW;",
          "4777:   si.wShowWindow = SW_HIDE;",
          "4779:   me = GetCurrentProcess();",
          "4780:   DuplicateHandle(me,",
          "4781:                   (HANDLE)_get_osfhandle(fdin[0]),",
          "4782:                   me,",
          "4783:                   &si.hStdInput,",
          "4784:                   0,",
          "4785:                   TRUE,",
          "4786:                   DUPLICATE_SAME_ACCESS);",
          "4787:   DuplicateHandle(me,",
          "4788:                   (HANDLE)_get_osfhandle(fdout[1]),",
          "4789:                   me,",
          "4790:                   &si.hStdOutput,",
          "4791:                   0,",
          "4792:                   TRUE,",
          "4793:                   DUPLICATE_SAME_ACCESS);",
          "4794:   DuplicateHandle(me,",
          "4795:                   (HANDLE)_get_osfhandle(fderr[1]),",
          "4796:                   me,",
          "4797:                   &si.hStdError,",
          "4798:                   0,",
          "4799:                   TRUE,",
          "4800:                   DUPLICATE_SAME_ACCESS);",
          "4805:   SetHandleInformation((HANDLE)_get_osfhandle(fdin[1]),",
          "4806:                        HANDLE_FLAG_INHERIT,",
          "4807:                        0);",
          "4808:   SetHandleInformation((HANDLE)_get_osfhandle(fdout[0]),",
          "4809:                        HANDLE_FLAG_INHERIT,",
          "4810:                        0);",
          "4811:   SetHandleInformation((HANDLE)_get_osfhandle(fderr[0]),",
          "4812:                        HANDLE_FLAG_INHERIT,",
          "4813:                        0);",
          "4816:   interp = conn->ctx->config[CGI_INTERPRETER];",
          "4817:   if (interp == NULL) {",
          "4818:    buf[0] = buf[1] = '\\0';",
          "4821:    mg_snprintf(",
          "4822:        conn, &truncated, cmdline, sizeof(cmdline), \"%s/%s\", dir, prog);",
          "4824:    if (truncated) {",
          "4825:     pi.hProcess = (pid_t)-1;",
          "4826:     goto spawn_cleanup;",
          "4827:    }",
          "4829:    if (mg_fopen(conn, cmdline, MG_FOPEN_MODE_READ, &file)) {",
          "4830:     p = (char *)file.access.membuf;",
          "4831:     mg_fgets(buf, sizeof(buf), &file, &p);",
          "4832:     (void)mg_fclose(",
          "4834:     buf[sizeof(buf) - 1] = '\\0';",
          "4835:    }",
          "4837:    if ((buf[0] == '#') && (buf[1] == '!')) {",
          "4838:     trim_trailing_whitespaces(buf + 2);",
          "4839:    } else {",
          "4840:     buf[2] = '\\0';",
          "4841:    }",
          "4842:    interp = buf + 2;",
          "4843:   }",
          "4845:   if (interp[0] != '\\0') {",
          "4846:    GetFullPathNameA(interp, sizeof(full_interp), full_interp, NULL);",
          "4847:    interp = full_interp;",
          "4848:   }",
          "4849:   GetFullPathNameA(dir, sizeof(full_dir), full_dir, NULL);",
          "4851:   if (interp[0] != '\\0') {",
          "4852:    mg_snprintf(conn,",
          "4853:                &truncated,",
          "4854:                cmdline,",
          "4855:                sizeof(cmdline),",
          "4856:                \"\\\"%s\\\" \\\"%s\\\\%s\\\"\",",
          "4857:                interp,",
          "4858:                full_dir,",
          "4859:                prog);",
          "4860:   } else {",
          "4861:    mg_snprintf(conn,",
          "4862:                &truncated,",
          "4863:                cmdline,",
          "4864:                sizeof(cmdline),",
          "4865:                \"\\\"%s\\\\%s\\\"\",",
          "4866:                full_dir,",
          "4867:                prog);",
          "4868:   }",
          "4875:   DEBUG_TRACE(\"Running [%s]\", cmdline);",
          "4876:   if (CreateProcessA(NULL,",
          "4877:                      cmdline,",
          "4878:                      NULL,",
          "4879:                      NULL,",
          "4880:                      TRUE,",
          "4881:                      CREATE_NEW_PROCESS_GROUP,",
          "4882:                      envblk,",
          "4883:                      NULL,",
          "4884:                      &si,",
          "4885:                      &pi) == 0) {",
          "4886:    mg_cry(conn,",
          "4887:           \"%s: CreateProcess(%s): %ld\",",
          "4888:           __func__,",
          "4889:           cmdline,",
          "4890:           (long)ERRNO);",
          "4891:    pi.hProcess = (pid_t)-1;",
          "4895:  spawn_cleanup:",
          "4896:   (void)CloseHandle(si.hStdOutput);",
          "4897:   (void)CloseHandle(si.hStdError);",
          "4898:   (void)CloseHandle(si.hStdInput);",
          "4899:   if (pi.hThread != NULL) {",
          "4900:    (void)CloseHandle(pi.hThread);",
          "4903:   return (pid_t)pi.hProcess;",
          "4908:  static int set_blocking_mode(SOCKET sock, int blocking)",
          "4909:  {",
          "4910:   unsigned long non_blocking = !blocking;",
          "4911:   return ioctlsocket(sock, (long)FIONBIO, &non_blocking);",
          "4912:  }",
          "",
          "---------------",
          "--- Hunk 38 ---",
          "[Context before]",
          "5146:  return 0;",
          "5147: }",
          "5241: #ifdef _WIN32",
          "5243: #else",
          "5244:  typedef size_t len_t;",
          "5245: #endif",
          "5257: #ifdef NO_SSL",
          "5261: #endif",
          "5267: #ifndef NO_SSL",
          "5277:     } else {",
          "5280:     }",
          "5285: #endif",
          "5291:    } else {",
          "5297: #ifdef _WIN32",
          "5302: #else",
          "5303:    if (err == EWOULDBLOCK) {",
          "5304:     err = 0;",
          "5305:     n = 0;",
          "5306:    }",
          "5307: #endif",
          "5311:    }",
          "5348: #if defined(__GNUC__) || defined(__MINGW32__)",
          "",
          "[Removed Lines]",
          "5153: static uint64_t",
          "5154: get_random(void)",
          "5155: {",
          "5158:  uint64_t now = mg_get_current_time_ns();",
          "5160:  if (lfsr == 0) {",
          "5163:   lfsr = mg_get_current_time_ns();",
          "5164:   lcg = mg_get_current_time_ns();",
          "5165:  } else {",
          "5167:   lfsr = (lfsr >> 1)",
          "5168:          | ((((lfsr >> 0) ^ (lfsr >> 1) ^ (lfsr >> 3) ^ (lfsr >> 4)) & 1)",
          "5169:             << 63);",
          "5170:   lcg = lcg * 6364136223846793005LL + 1442695040888963407LL;",
          "5171:  }",
          "5176:  return (lfsr ^ lcg ^ now);",
          "5177: }",
          "5180: static int",
          "5181: mg_poll(struct pollfd *pfd,",
          "5182:         unsigned int n,",
          "5183:         int milliseconds,",
          "5184:         volatile int *stop_server)",
          "5185: {",
          "5186:  int ms_now, result;",
          "5193:  do {",
          "5194:   if (*stop_server) {",
          "5196:    return -2;",
          "5197:   }",
          "5199:   if ((milliseconds >= 0) && (milliseconds < ms_now)) {",
          "5200:    ms_now = milliseconds;",
          "5201:   }",
          "5203:   result = poll(pfd, n, ms_now);",
          "5204:   if (result != 0) {",
          "5207:    return result;",
          "5208:   }",
          "5211:   if (milliseconds > 0) {",
          "5212:    milliseconds -= ms_now;",
          "5213:   }",
          "5215:  } while (milliseconds != 0);",
          "5217:  return result;",
          "5218: }",
          "5228: static int",
          "5229: push_inner(struct mg_context *ctx,",
          "5230:            FILE *fp,",
          "5231:            SOCKET sock,",
          "5232:            SSL *ssl,",
          "5233:            const char *buf,",
          "5234:            int len,",
          "5235:            double timeout)",
          "5236: {",
          "5237:  uint64_t start = 0, now = 0, timeout_ns = 0;",
          "5238:  int n, err;",
          "5242:  typedef int len_t;",
          "5247:  if (timeout > 0) {",
          "5248:   now = mg_get_current_time_ns();",
          "5249:   start = now;",
          "5250:   timeout_ns = (uint64_t)(timeout * 1.0E9);",
          "5251:  }",
          "5253:  if (ctx == NULL) {",
          "5254:   return -2;",
          "5255:  }",
          "5258:  if (ssl) {",
          "5259:   return -2;",
          "5260:  }",
          "5265:  for (;;) {",
          "5268:   if (ssl != NULL) {",
          "5269:    n = SSL_write(ssl, buf, len);",
          "5270:    if (n <= 0) {",
          "5271:     err = SSL_get_error(ssl, n);",
          "5272:     if ((err == SSL_ERROR_SYSCALL) && (n == -1)) {",
          "5273:      err = ERRNO;",
          "5274:     } else if ((err == SSL_ERROR_WANT_READ)",
          "5275:                || (err == SSL_ERROR_WANT_WRITE)) {",
          "5276:      n = 0;",
          "5278:      DEBUG_TRACE(\"SSL_write() failed, error %d\", err);",
          "5279:      return -2;",
          "5281:    } else {",
          "5282:     err = 0;",
          "5283:    }",
          "5284:   } else",
          "5286:       if (fp != NULL) {",
          "5287:    n = (int)fwrite(buf, 1, (size_t)len, fp);",
          "5288:    if (ferror(fp)) {",
          "5289:     n = -1;",
          "5290:     err = ERRNO;",
          "5292:     err = 0;",
          "5293:    }",
          "5294:   } else {",
          "5295:    n = (int)send(sock, buf, (len_t)len, MSG_NOSIGNAL);",
          "5296:    err = (n < 0) ? ERRNO : 0;",
          "5298:    if (err == WSAEWOULDBLOCK) {",
          "5299:     err = 0;",
          "5300:     n = 0;",
          "5301:    }",
          "5308:    if (n < 0) {",
          "5310:     return -2;",
          "5312:   }",
          "5314:   if (ctx->stop_flag) {",
          "5315:    return -2;",
          "5316:   }",
          "5318:   if ((n > 0) || ((n == 0) && (len == 0))) {",
          "5320:    return n;",
          "5321:   }",
          "5322:   if (n < 0) {",
          "5324:    DEBUG_TRACE(\"send() failed, error %d\", err);",
          "5332:    return -2;",
          "5333:   }",
          "5338:   if (fp != NULL) {",
          "5341:    mg_sleep(ms_wait > 10 ? 10 : ms_wait);",
          "5342:   } else {",
          "5344:    fd_set wfds;",
          "5345:    struct timeval tv;",
          "5346:    int sret;",
          "",
          "[Added Lines]",
          "5140:  static uint64_t get_random(void)",
          "5141:  {",
          "5144:   uint64_t now = mg_get_current_time_ns();",
          "5146:   if (lfsr == 0) {",
          "5149:    lfsr = mg_get_current_time_ns();",
          "5150:    lcg = mg_get_current_time_ns();",
          "5151:   } else {",
          "5153:    lfsr =",
          "5154:        (lfsr >> 1)",
          "5155:        | ((((lfsr >> 0) ^ (lfsr >> 1) ^ (lfsr >> 3) ^ (lfsr >> 4)) & 1)",
          "5156:           << 63);",
          "5157:    lcg = lcg * 6364136223846793005LL + 1442695040888963407LL;",
          "5158:   }",
          "5165:   return (lfsr ^ lcg ^ now);",
          "5166:  }",
          "5169:  static int mg_poll(struct pollfd * pfd,",
          "5170:                     unsigned int n,",
          "5171:                     int milliseconds,",
          "5172:                     volatile int *stop_server)",
          "5173:  {",
          "5174:   int ms_now, result;",
          "5181:   do {",
          "5182:    if (*stop_server) {",
          "5184:     return -2;",
          "5185:    }",
          "5187:    if ((milliseconds >= 0) && (milliseconds < ms_now)) {",
          "5188:     ms_now = milliseconds;",
          "5189:    }",
          "5191:    result = poll(pfd, n, ms_now);",
          "5192:    if (result != 0) {",
          "5195:     return result;",
          "5196:    }",
          "5199:    if (milliseconds > 0) {",
          "5200:     milliseconds -= ms_now;",
          "5201:    }",
          "5203:   } while (milliseconds != 0);",
          "5205:   return result;",
          "5206:  }",
          "5216:  static int push_inner(struct mg_context * ctx,",
          "5217:                        FILE * fp,",
          "5218:                        SOCKET sock,",
          "5219:                        SSL * ssl,",
          "5220:                        const char *buf,",
          "5221:                        int len,",
          "5222:                        double timeout)",
          "5223:  {",
          "5224:   uint64_t start = 0, now = 0, timeout_ns = 0;",
          "5225:   int n, err;",
          "5229:   typedef int len_t;",
          "5234:   if (timeout > 0) {",
          "5235:    now = mg_get_current_time_ns();",
          "5236:    start = now;",
          "5237:    timeout_ns = (uint64_t)(timeout * 1.0E9);",
          "5238:   }",
          "5240:   if (ctx == NULL) {",
          "5241:    return -2;",
          "5242:   }",
          "5245:   if (ssl) {",
          "5246:    return -2;",
          "5247:   }",
          "5252:   for (;;) {",
          "5255:    if (ssl != NULL) {",
          "5256:     n = SSL_write(ssl, buf, len);",
          "5257:     if (n <= 0) {",
          "5258:      err = SSL_get_error(ssl, n);",
          "5259:      if ((err == SSL_ERROR_SYSCALL) && (n == -1)) {",
          "5260:       err = ERRNO;",
          "5261:      } else if ((err == SSL_ERROR_WANT_READ)",
          "5262:                 || (err == SSL_ERROR_WANT_WRITE)) {",
          "5263:       n = 0;",
          "5264:      } else {",
          "5265:       DEBUG_TRACE(\"SSL_write() failed, error %d\", err);",
          "5266:       return -2;",
          "5267:      }",
          "5269:      err = 0;",
          "5271:    } else",
          "5273:        if (fp != NULL) {",
          "5274:     n = (int)fwrite(buf, 1, (size_t)len, fp);",
          "5275:     if (ferror(fp)) {",
          "5276:      n = -1;",
          "5277:      err = ERRNO;",
          "5278:     } else {",
          "5279:      err = 0;",
          "5280:     }",
          "5282:     n = (int)send(sock, buf, (len_t)len, MSG_NOSIGNAL);",
          "5283:     err = (n < 0) ? ERRNO : 0;",
          "5285:     if (err == WSAEWOULDBLOCK) {",
          "5286:      err = 0;",
          "5287:      n = 0;",
          "5288:     }",
          "5295:     if (n < 0) {",
          "5297:      return -2;",
          "5298:     }",
          "5301:    if (ctx->stop_flag) {",
          "5302:     return -2;",
          "5303:    }",
          "5305:    if ((n > 0) || ((n == 0) && (len == 0))) {",
          "5307:     return n;",
          "5308:    }",
          "5309:    if (n < 0) {",
          "5311:     DEBUG_TRACE(\"send() failed, error %d\", err);",
          "5319:     return -2;",
          "5320:    }",
          "5325:    if (fp != NULL) {",
          "5328:     mg_sleep(ms_wait > 10 ? 10 : ms_wait);",
          "5329:    } else {",
          "5331:     fd_set wfds;",
          "5332:     struct timeval tv;",
          "5333:     int sret;",
          "",
          "---------------",
          "--- Hunk 39 ---",
          "[Context before]",
          "5353: #pragma GCC diagnostic ignored \"-Wsign-conversion\"",
          "5354: #endif",
          "5363: #if defined(__GNUC__) || defined(__MINGW32__)",
          "5364: #pragma GCC diagnostic pop",
          "5365: #endif",
          "5371:    }",
          "5379:    }",
          "5380:   }",
          "5414:    }",
          "5421:   }",
          "5443: #ifdef _WIN32",
          "5445: #else",
          "5446:  typedef size_t len_t;",
          "5447: #endif",
          "5448: #ifndef NO_SSL",
          "5450: #endif",
          "5458: #if !defined(_WIN32_WCE)",
          "5464: #else",
          "5466:   nread = (int)fread(buf, 1, (size_t)len, fp);",
          "5467: #endif",
          "5470: #ifndef NO_SSL",
          "5490:    }",
          "5509:    if (nread <= 0) {",
          "5510:     err = SSL_get_error(conn->ssl, nread);",
          "5511:     if ((err == SSL_ERROR_SYSCALL) && (nread == -1)) {",
          "",
          "[Removed Lines]",
          "5356:    FD_ZERO(&wfds);",
          "5357:    FD_SET(sock, &wfds);",
          "5358:    tv.tv_sec = (time_t)(ms_wait / 1000);",
          "5359:    tv.tv_usec = (long)((ms_wait % 1000) * 1000);",
          "5361:    sret = select((int)sock + 1, NULL, &wfds, NULL, &tv);",
          "5367:    if (sret > 0) {",
          "5370:     continue;",
          "5372:   }",
          "5374:   if (timeout > 0) {",
          "5375:    now = mg_get_current_time_ns();",
          "5376:    if ((now - start) > timeout_ns) {",
          "5378:     break;",
          "5381:  }",
          "5383:  (void)err; /* Avoid unused warning if NO_SSL is set and DEBUG_TRACE is not",
          "5386:  return -1;",
          "5387: }",
          "5390: static int64_t",
          "5391: push_all(struct mg_context *ctx,",
          "5392:          FILE *fp,",
          "5393:          SOCKET sock,",
          "5394:          SSL *ssl,",
          "5395:          const char *buf,",
          "5396:          int64_t len)",
          "5397: {",
          "5398:  double timeout = -1.0;",
          "5399:  int64_t n, nwritten = 0;",
          "5401:  if (ctx == NULL) {",
          "5402:   return -1;",
          "5403:  }",
          "5405:  if (ctx->config[REQUEST_TIMEOUT]) {",
          "5406:   timeout = atoi(ctx->config[REQUEST_TIMEOUT]) / 1000.0;",
          "5407:  }",
          "5409:  while ((len > 0) && (ctx->stop_flag == 0)) {",
          "5410:   n = push_inner(ctx, fp, sock, ssl, buf + nwritten, (int)len, timeout);",
          "5411:   if (n < 0) {",
          "5412:    if (nwritten == 0) {",
          "5415:    break;",
          "5416:   } else if (n == 0) {",
          "5418:   } else {",
          "5419:    nwritten += n;",
          "5420:    len -= n;",
          "5422:  }",
          "5424:  return nwritten;",
          "5425: }",
          "5434: static int",
          "5435: pull_inner(FILE *fp,",
          "5436:            struct mg_connection *conn,",
          "5437:            char *buf,",
          "5438:            int len,",
          "5439:            double timeout)",
          "5440: {",
          "5441:  int nread, err = 0;",
          "5444:  typedef int len_t;",
          "5449:  int ssl_pending;",
          "5457:  if (fp != NULL) {",
          "5463:   nread = (int)read(fileno(fp), buf, (size_t)len);",
          "5468:   err = (nread < 0) ? ERRNO : 0;",
          "5471:  } else if ((conn->ssl != NULL)",
          "5472:             && ((ssl_pending = SSL_pending(conn->ssl)) > 0)) {",
          "5476:   if (ssl_pending > len) {",
          "5477:    ssl_pending = len;",
          "5478:   }",
          "5479:   nread = SSL_read(conn->ssl, buf, ssl_pending);",
          "5480:   if (nread <= 0) {",
          "5481:    err = SSL_get_error(conn->ssl, nread);",
          "5482:    if ((err == SSL_ERROR_SYSCALL) && (nread == -1)) {",
          "5483:     err = ERRNO;",
          "5484:    } else if ((err == SSL_ERROR_WANT_READ)",
          "5485:               || (err == SSL_ERROR_WANT_WRITE)) {",
          "5486:     nread = 0;",
          "5487:    } else {",
          "5488:     DEBUG_TRACE(\"SSL_read() failed, error %d\", err);",
          "5489:     return -1;",
          "5491:   } else {",
          "5492:    err = 0;",
          "5493:   }",
          "5495:  } else if (conn->ssl != NULL) {",
          "5497:   struct pollfd pfd[1];",
          "5498:   int pollres;",
          "5500:   pfd[0].fd = conn->client.sock;",
          "5501:   pfd[0].events = POLLIN;",
          "5502:   pollres =",
          "5503:       mg_poll(pfd, 1, (int)(timeout * 1000.0), &(conn->ctx->stop_flag));",
          "5504:   if (conn->ctx->stop_flag) {",
          "5505:    return -2;",
          "5506:   }",
          "5507:   if (pollres > 0) {",
          "5508:    nread = SSL_read(conn->ssl, buf, len);",
          "",
          "[Added Lines]",
          "5343:     FD_ZERO(&wfds);",
          "5344:     FD_SET(sock, &wfds);",
          "5345:     tv.tv_sec = (time_t)(ms_wait / 1000);",
          "5346:     tv.tv_usec = (long)((ms_wait % 1000) * 1000);",
          "5348:     sret = select((int)sock + 1, NULL, &wfds, NULL, &tv);",
          "5354:     if (sret > 0) {",
          "5357:      continue;",
          "5358:     }",
          "5361:    if (timeout > 0) {",
          "5362:     now = mg_get_current_time_ns();",
          "5363:     if ((now - start) > timeout_ns) {",
          "5365:      break;",
          "5366:     }",
          "5370:   (void)",
          "5371:       err; /* Avoid unused warning if NO_SSL is set and DEBUG_TRACE is not",
          "5374:   return -1;",
          "5375:  }",
          "5378:  static int64_t push_all(struct mg_context * ctx,",
          "5379:                          FILE * fp,",
          "5380:                          SOCKET sock,",
          "5381:                          SSL * ssl,",
          "5382:                          const char *buf,",
          "5383:                          int64_t len)",
          "5384:  {",
          "5385:   double timeout = -1.0;",
          "5386:   int64_t n, nwritten = 0;",
          "5388:   if (ctx == NULL) {",
          "5389:    return -1;",
          "5390:   }",
          "5392:   if (ctx->config[REQUEST_TIMEOUT]) {",
          "5393:    timeout = atoi(ctx->config[REQUEST_TIMEOUT]) / 1000.0;",
          "5394:   }",
          "5396:   while ((len > 0) && (ctx->stop_flag == 0)) {",
          "5397:    n = push_inner(",
          "5398:        ctx, fp, sock, ssl, buf + nwritten, (int)len, timeout);",
          "5399:    if (n < 0) {",
          "5400:     if (nwritten == 0) {",
          "5402:     }",
          "5403:     break;",
          "5404:    } else if (n == 0) {",
          "5406:    } else {",
          "5407:     nwritten += n;",
          "5408:     len -= n;",
          "5412:   return nwritten;",
          "5413:  }",
          "5422:  static int pull_inner(FILE * fp,",
          "5423:                        struct mg_connection * conn,",
          "5424:                        char *buf,",
          "5425:                        int len,",
          "5426:                        double timeout)",
          "5427:  {",
          "5428:   int nread, err = 0;",
          "5431:   typedef int len_t;",
          "5436:   int ssl_pending;",
          "5444:   if (fp != NULL) {",
          "5450:    nread = (int)read(fileno(fp), buf, (size_t)len);",
          "5455:    err = (nread < 0) ? ERRNO : 0;",
          "5458:   } else if ((conn->ssl != NULL)",
          "5459:              && ((ssl_pending = SSL_pending(conn->ssl)) > 0)) {",
          "5463:    if (ssl_pending > len) {",
          "5464:     ssl_pending = len;",
          "5466:    nread = SSL_read(conn->ssl, buf, ssl_pending);",
          "",
          "---------------",
          "--- Hunk 40 ---",
          "[Context before]",
          "5515:      nread = 0;",
          "5516:     } else {",
          "5517:      DEBUG_TRACE(\"SSL_read() failed, error %d\", err);",
          "5519:     }",
          "5520:    } else {",
          "5521:     err = 0;",
          "5522:    }",
          "5549:     return -2;",
          "5550:    }",
          "5554:   } else {",
          "5557:   }",
          "5571: #ifdef _WIN32",
          "5587: #else",
          "",
          "[Removed Lines]",
          "5518:      return -2;",
          "5524:   } else if (pollres < 0) {",
          "5526:    return -2;",
          "5527:   } else {",
          "5529:    nread = 0;",
          "5530:   }",
          "5531: #endif",
          "5533:  } else {",
          "5534:   struct pollfd pfd[1];",
          "5535:   int pollres;",
          "5537:   pfd[0].fd = conn->client.sock;",
          "5538:   pfd[0].events = POLLIN;",
          "5539:   pollres =",
          "5540:       mg_poll(pfd, 1, (int)(timeout * 1000.0), &(conn->ctx->stop_flag));",
          "5541:   if (conn->ctx->stop_flag) {",
          "5542:    return -2;",
          "5543:   }",
          "5544:   if (pollres > 0) {",
          "5545:    nread = (int)recv(conn->client.sock, buf, (len_t)len, 0);",
          "5546:    err = (nread < 0) ? ERRNO : 0;",
          "5547:    if (nread <= 0) {",
          "5551:   } else if (pollres < 0) {",
          "5553:    return -2;",
          "5556:    nread = 0;",
          "5558:  }",
          "5560:  if (conn->ctx->stop_flag) {",
          "5561:   return -2;",
          "5562:  }",
          "5564:  if ((nread > 0) || ((nread == 0) && (len == 0))) {",
          "5566:   return nread;",
          "5567:  }",
          "5569:  if (nread < 0) {",
          "5572:   if (err == WSAEWOULDBLOCK) {",
          "5575:    return -2;",
          "5576:   } else if (err == WSAETIMEDOUT) {",
          "5579:    return 0;",
          "5580:   } else if (err == WSAECONNABORTED) {",
          "5582:    return -2;",
          "5583:   } else {",
          "5584:    DEBUG_TRACE(\"recv() failed, error %d\", err);",
          "5585:    return -2;",
          "5586:   }",
          "",
          "[Added Lines]",
          "5476:      return -1;",
          "5482:   } else if (conn->ssl != NULL) {",
          "5484:    struct pollfd pfd[1];",
          "5485:    int pollres;",
          "5487:    pfd[0].fd = conn->client.sock;",
          "5488:    pfd[0].events = POLLIN;",
          "5489:    pollres = mg_poll(pfd,",
          "5490:                      1,",
          "5491:                      (int)(timeout * 1000.0),",
          "5492:                      &(conn->ctx->stop_flag));",
          "5493:    if (conn->ctx->stop_flag) {",
          "5496:    if (pollres > 0) {",
          "5497:     nread = SSL_read(conn->ssl, buf, len);",
          "5498:     if (nread <= 0) {",
          "5499:      err = SSL_get_error(conn->ssl, nread);",
          "5500:      if ((err == SSL_ERROR_SYSCALL) && (nread == -1)) {",
          "5501:       err = ERRNO;",
          "5502:      } else if ((err == SSL_ERROR_WANT_READ)",
          "5503:                 || (err == SSL_ERROR_WANT_WRITE)) {",
          "5504:       nread = 0;",
          "5505:      } else {",
          "5506:       DEBUG_TRACE(\"SSL_read() failed, error %d\", err);",
          "5507:       return -2;",
          "5508:      }",
          "5509:     } else {",
          "5510:      err = 0;",
          "5511:     }",
          "5513:    } else if (pollres < 0) {",
          "5515:     return -2;",
          "5516:    } else {",
          "5518:     nread = 0;",
          "5519:    }",
          "5520: #endif",
          "5523:    struct pollfd pfd[1];",
          "5524:    int pollres;",
          "5526:    pfd[0].fd = conn->client.sock;",
          "5527:    pfd[0].events = POLLIN;",
          "5528:    pollres = mg_poll(pfd,",
          "5529:                      1,",
          "5530:                      (int)(timeout * 1000.0),",
          "5531:                      &(conn->ctx->stop_flag));",
          "5532:    if (conn->ctx->stop_flag) {",
          "5533:     return -2;",
          "5534:    }",
          "5535:    if (pollres > 0) {",
          "5536:     nread = (int)recv(conn->client.sock, buf, (len_t)len, 0);",
          "5537:     err = (nread < 0) ? ERRNO : 0;",
          "5538:     if (nread <= 0) {",
          "5540:      return -2;",
          "5541:     }",
          "5542:    } else if (pollres < 0) {",
          "5544:     return -2;",
          "5545:    } else {",
          "5547:     nread = 0;",
          "5548:    }",
          "5551:   if (conn->ctx->stop_flag) {",
          "5552:    return -2;",
          "5553:   }",
          "5555:   if ((nread > 0) || ((nread == 0) && (len == 0))) {",
          "5557:    return nread;",
          "5558:   }",
          "5560:   if (nread < 0) {",
          "5563:    if (err == WSAEWOULDBLOCK) {",
          "5566:     return -2;",
          "5567:    } else if (err == WSAETIMEDOUT) {",
          "5570:     return 0;",
          "5571:    } else if (err == WSAECONNABORTED) {",
          "5573:     return -2;",
          "5574:    } else {",
          "5575:     DEBUG_TRACE(\"recv() failed, error %d\", err);",
          "5576:     return -2;",
          "5577:    }",
          "",
          "---------------",
          "--- Hunk 41 ---",
          "[Context before]",
          "5607:    return -2;",
          "5608:   }",
          "5609: #endif",
          "5645:     }",
          "5646:    }",
          "5654:   }",
          "5681:    }",
          "5695:    }",
          "5696:   }",
          "5697:  }",
          "5730:   }",
          "5738:    }",
          "5754:   }",
          "5755:  }",
          "5770:  }",
          "5823:       return -1;",
          "5824:      }",
          "5839:      }",
          "5847:       }",
          "5849:      }",
          "5852:       return -1;",
          "5853:      }",
          "5864:    }",
          "5868:  }",
          "5911:     }",
          "5917:    }",
          "5918:   }",
          "5929:  }",
          "5990:   }",
          "5996:  }",
          "6029:   va_copy(ap_copy, ap);",
          "6031:   va_end(ap_copy);",
          "6040:   }",
          "6055:  }",
          "6073:  }",
          "6101: #define HEXTOI(x) (isdigit(x) ? (x - '0') : (x - 'W'))",
          "6115:   }",
          "6182:     }",
          "6184:    }",
          "6185:   }",
          "6233:     }",
          "6235:    }",
          "6236:   }",
          "6237:  }",
          "6242: #if defined(USE_WEBSOCKET) || defined(USE_LUA)",
          "6259:   }",
          "6262:   }",
          "6263:  }",
          "6269: #endif",
          "6272: #if defined(USE_LUA)",
          "6293:  }",
          "6332:    }",
          "6333:   }",
          "6334:  }",
          "6337: #endif",
          "6347:  }",
          "6352: #if !defined(NO_FILES)",
          "6359: #if !defined(NO_CGI)",
          "6365: #endif",
          "6366: #if defined(USE_LUA)",
          "6372: #endif",
          "6373: #if defined(USE_DUKTAPE)",
          "6379: #endif",
          "6427:   }",
          "6437: #endif",
          "6451: #if !defined(NO_FILES)",
          "6460: #if !defined(NO_CGI) || defined(USE_LUA) || defined(USE_DUKTAPE)",
          "6463: #endif",
          "6464: #else",
          "6466: #endif",
          "6479: #if defined(USE_WEBSOCKET)",
          "6481: #if !defined(NO_FILES)",
          "6490: #if !defined(NO_FILES)",
          "6525:   }",
          "6553:   }",
          "6577:     }",
          "6578:    }",
          "6581:   }",
          "6605:     }",
          "6608:    }",
          "6609:   }",
          "6612: #if !defined(NO_CGI) || defined(USE_LUA) || defined(USE_DUKTAPE)",
          "6667:      filename[sep_pos] = 0;",
          "6668:      conn->path_info = filename + sep_pos + 1;",
          "6671:      break;",
          "6679:     }",
          "6683:   }",
          "6692: #if !defined(NO_FILES)",
          "6729:    }",
          "6737:    }",
          "6738:   }",
          "6745: #if !defined(NO_CACHING)",
          "6755:   }",
          "6811:   }",
          "6841:     }",
          "6842:    }",
          "6843:   }",
          "6963:   }",
          "6984:   }",
          "6997:   }",
          "7015:  }",
          "7101: #ifdef DEBUG",
          "7104: #endif",
          "7122: #ifdef DEBUG",
          "7127: #endif",
          "7134:     }",
          "7146: #ifdef DEBUG",
          "7151: #endif",
          "7152:    }",
          "7153:   }",
          "7154:  }",
          "7201:     s++;",
          "7202:    }",
          "7225:   }",
          "7228: #ifndef NO_NONCE_CHECK",
          "7260: #else",
          "7261:  (void)nonce;",
          "7262: #endif",
          "7292:   } else {",
          "7305:  }",
          "",
          "[Removed Lines]",
          "5610:  }",
          "5613:  return -1;",
          "5614: }",
          "5617: static int",
          "5618: pull_all(FILE *fp, struct mg_connection *conn, char *buf, int len)",
          "5619: {",
          "5620:  int n, nread = 0;",
          "5621:  double timeout = -1.0;",
          "5622:  uint64_t start_time = 0, now = 0, timeout_ns = 0;",
          "5624:  if (conn->ctx->config[REQUEST_TIMEOUT]) {",
          "5625:   timeout = atoi(conn->ctx->config[REQUEST_TIMEOUT]) / 1000.0;",
          "5626:  }",
          "5627:  if (timeout >= 0.0) {",
          "5628:   start_time = mg_get_current_time_ns();",
          "5629:   timeout_ns = (uint64_t)(timeout * 1.0E9);",
          "5630:  }",
          "5632:  while ((len > 0) && (conn->ctx->stop_flag == 0)) {",
          "5633:   n = pull_inner(fp, conn, buf + nread, len, timeout);",
          "5634:   if (n == -2) {",
          "5635:    if (nread == 0) {",
          "5637:    }",
          "5638:    break;",
          "5639:   } else if (n == -1) {",
          "5641:    if (timeout >= 0.0) {",
          "5642:     now = mg_get_current_time_ns();",
          "5643:     if ((now - start_time) <= timeout_ns) {",
          "5644:      continue;",
          "5647:    break;",
          "5648:   } else if (n == 0) {",
          "5650:   } else {",
          "5651:    conn->consumed_content += n;",
          "5652:    nread += n;",
          "5653:    len -= n;",
          "5655:  }",
          "5657:  return nread;",
          "5658: }",
          "5661: static void",
          "5662: discard_unread_request_data(struct mg_connection *conn)",
          "5663: {",
          "5664:  char buf[MG_BUF_LEN];",
          "5665:  size_t to_read;",
          "5666:  int nread;",
          "5668:  if (conn == NULL) {",
          "5669:   return;",
          "5670:  }",
          "5672:  to_read = sizeof(buf);",
          "5674:  if (conn->is_chunked) {",
          "5677:   while (conn->is_chunked == 1) {",
          "5678:    nread = mg_read(conn, buf, to_read);",
          "5679:    if (nread <= 0) {",
          "5680:     break;",
          "5682:   }",
          "5684:  } else {",
          "5686:   while (conn->consumed_content < conn->content_len) {",
          "5687:    if (to_read",
          "5688:        > (size_t)(conn->content_len - conn->consumed_content)) {",
          "5689:     to_read = (size_t)(conn->content_len - conn->consumed_content);",
          "5690:    }",
          "5692:    nread = mg_read(conn, buf, to_read);",
          "5693:    if (nread <= 0) {",
          "5694:     break;",
          "5698: }",
          "5701: static int",
          "5702: mg_read_inner(struct mg_connection *conn, void *buf, size_t len)",
          "5703: {",
          "5704:  int64_t n, buffered_len, nread;",
          "5705:  int64_t len64 =",
          "5706:      (int64_t)((len > INT_MAX) ? INT_MAX : len); /* since the return value is",
          "5709:  const char *body;",
          "5711:  if (conn == NULL) {",
          "5712:   return 0;",
          "5713:  }",
          "5717:  if ((conn->consumed_content) == 0 && (conn->content_len == -1)) {",
          "5718:   conn->content_len = INT64_MAX;",
          "5719:   conn->must_close = 1;",
          "5720:  }",
          "5722:  nread = 0;",
          "5723:  if (conn->consumed_content < conn->content_len) {",
          "5725:   int64_t left_to_read = conn->content_len - conn->consumed_content;",
          "5726:   if (left_to_read < len64) {",
          "5729:    len64 = left_to_read;",
          "5733:   buffered_len = (int64_t)(conn->data_len) - (int64_t)conn->request_len",
          "5734:                  - conn->consumed_content;",
          "5735:   if (buffered_len > 0) {",
          "5736:    if (len64 < buffered_len) {",
          "5737:     buffered_len = len64;",
          "5739:    body = conn->buf + conn->request_len + conn->consumed_content;",
          "5740:    memcpy(buf, body, (size_t)buffered_len);",
          "5741:    len64 -= buffered_len;",
          "5742:    conn->consumed_content += buffered_len;",
          "5743:    nread += buffered_len;",
          "5744:    buf = (char *)buf + buffered_len;",
          "5745:   }",
          "5750:   if ((n = pull_all(NULL, conn, (char *)buf, (int)len64)) >= 0) {",
          "5751:    nread += n;",
          "5752:   } else {",
          "5753:    nread = ((nread > 0) ? nread : n);",
          "5756:  return (int)nread;",
          "5757: }",
          "5760: static char",
          "5761: mg_getc(struct mg_connection *conn)",
          "5762: {",
          "5763:  char c;",
          "5764:  if (conn == NULL) {",
          "5765:   return 0;",
          "5766:  }",
          "5767:  conn->content_len++;",
          "5768:  if (mg_read_inner(conn, &c, 1) <= 0) {",
          "5769:   return (char)0;",
          "5771:  return c;",
          "5772: }",
          "5775: int",
          "5776: mg_read(struct mg_connection *conn, void *buf, size_t len)",
          "5777: {",
          "5778:  if (len > INT_MAX) {",
          "5779:   len = INT_MAX;",
          "5780:  }",
          "5782:  if (conn == NULL) {",
          "5783:   return 0;",
          "5784:  }",
          "5786:  if (conn->is_chunked) {",
          "5787:   size_t all_read = 0;",
          "5789:   while (len > 0) {",
          "5791:    if (conn->is_chunked == 2) {",
          "5793:     return 0;",
          "5794:    }",
          "5796:    if (conn->chunk_remainder) {",
          "5798:     long read_ret;",
          "5799:     size_t read_now =",
          "5800:         ((conn->chunk_remainder > len) ? (len)",
          "5801:                                        : (conn->chunk_remainder));",
          "5803:     conn->content_len += (int)read_now;",
          "5804:     read_ret =",
          "5805:         mg_read_inner(conn, (char *)buf + all_read, read_now);",
          "5807:     if (read_ret < 1) {",
          "5809:      return -1;",
          "5810:     }",
          "5812:     all_read += (size_t)read_ret;",
          "5813:     conn->chunk_remainder -= (size_t)read_ret;",
          "5814:     len -= (size_t)read_ret;",
          "5816:     if (conn->chunk_remainder == 0) {",
          "5819:      char x1 = mg_getc(conn);",
          "5820:      char x2 = mg_getc(conn);",
          "5821:      if ((x1 != '\\r') || (x2 != '\\n')) {",
          "5825:     }",
          "5827:    } else {",
          "5829:     int i = 0;",
          "5830:     char lenbuf[64];",
          "5831:     char *end = 0;",
          "5832:     unsigned long chunkSize = 0;",
          "5834:     for (i = 0; i < ((int)sizeof(lenbuf) - 1); i++) {",
          "5835:      lenbuf[i] = mg_getc(conn);",
          "5836:      if ((i > 0) && (lenbuf[i] == '\\r')",
          "5837:          && (lenbuf[i - 1] != '\\r')) {",
          "5838:       continue;",
          "5840:      if ((i > 1) && (lenbuf[i] == '\\n')",
          "5841:          && (lenbuf[i - 1] == '\\r')) {",
          "5842:       lenbuf[i + 1] = 0;",
          "5843:       chunkSize = strtoul(lenbuf, &end, 16);",
          "5844:       if (chunkSize == 0) {",
          "5846:        conn->is_chunked = 2;",
          "5848:       break;",
          "5850:      if (!isxdigit(lenbuf[i])) {",
          "5854:     }",
          "5855:     if ((end == NULL) || (*end != '\\r')) {",
          "5857:      return -1;",
          "5858:     }",
          "5859:     if (chunkSize == 0) {",
          "5860:      break;",
          "5861:     }",
          "5863:     conn->chunk_remainder = chunkSize;",
          "5865:   }",
          "5867:   return (int)all_read;",
          "5869:  return mg_read_inner(conn, buf, len);",
          "5870: }",
          "5873: int",
          "5874: mg_write(struct mg_connection *conn, const void *buf, size_t len)",
          "5875: {",
          "5876:  time_t now;",
          "5877:  int64_t n, total, allowed;",
          "5879:  if (conn == NULL) {",
          "5880:   return 0;",
          "5881:  }",
          "5883:  if (conn->throttle > 0) {",
          "5884:   if ((now = time(NULL)) != conn->last_throttle_time) {",
          "5885:    conn->last_throttle_time = now;",
          "5886:    conn->last_throttle_bytes = 0;",
          "5887:   }",
          "5888:   allowed = conn->throttle - conn->last_throttle_bytes;",
          "5889:   if (allowed > (int64_t)len) {",
          "5890:    allowed = (int64_t)len;",
          "5891:   }",
          "5892:   if ((total = push_all(conn->ctx,",
          "5893:                         NULL,",
          "5894:                         conn->client.sock,",
          "5895:                         conn->ssl,",
          "5896:                         (const char *)buf,",
          "5897:                         (int64_t)allowed)) == allowed) {",
          "5898:    buf = (const char *)buf + total;",
          "5899:    conn->last_throttle_bytes += total;",
          "5900:    while ((total < (int64_t)len) && (conn->ctx->stop_flag == 0)) {",
          "5901:     allowed = (conn->throttle > ((int64_t)len - total))",
          "5902:                   ? (int64_t)len - total",
          "5903:                   : conn->throttle;",
          "5904:     if ((n = push_all(conn->ctx,",
          "5905:                       NULL,",
          "5906:                       conn->client.sock,",
          "5907:                       conn->ssl,",
          "5908:                       (const char *)buf,",
          "5909:                       (int64_t)allowed)) != allowed) {",
          "5910:      break;",
          "5912:     sleep(1);",
          "5913:     conn->last_throttle_bytes = allowed;",
          "5914:     conn->last_throttle_time = time(NULL);",
          "5915:     buf = (const char *)buf + n;",
          "5916:     total += n;",
          "5919:  } else {",
          "5920:   total = push_all(conn->ctx,",
          "5921:                    NULL,",
          "5922:                    conn->client.sock,",
          "5923:                    conn->ssl,",
          "5924:                    (const char *)buf,",
          "5925:                    (int64_t)len);",
          "5926:  }",
          "5927:  if (total > 0) {",
          "5928:   conn->num_bytes_sent += total;",
          "5930:  return (int)total;",
          "5931: }",
          "5935: int",
          "5936: mg_send_chunk(struct mg_connection *conn,",
          "5937:               const char *chunk,",
          "5938:               unsigned int chunk_len)",
          "5939: {",
          "5940:  char lenbuf[16];",
          "5941:  size_t lenbuf_len;",
          "5942:  int ret;",
          "5943:  int t;",
          "5946:  sprintf(lenbuf, \"%x\\r\\n\", chunk_len);",
          "5947:  lenbuf_len = strlen(lenbuf);",
          "5950:  ret = mg_write(conn, lenbuf, lenbuf_len);",
          "5951:  if (ret != (int)lenbuf_len) {",
          "5952:   return -1;",
          "5953:  }",
          "5954:  t = ret;",
          "5956:  ret = mg_write(conn, chunk, chunk_len);",
          "5957:  if (ret != (int)chunk_len) {",
          "5958:   return -1;",
          "5959:  }",
          "5960:  t += ret;",
          "5962:  ret = mg_write(conn, \"\\r\\n\", 2);",
          "5963:  if (ret != 2) {",
          "5964:   return -1;",
          "5965:  }",
          "5966:  t += ret;",
          "5968:  return t;",
          "5969: }",
          "5973: static int",
          "5974: alloc_vprintf2(char **buf, const char *fmt, va_list ap)",
          "5975: {",
          "5976:  va_list ap_copy;",
          "5977:  size_t size = MG_BUF_LEN / 4;",
          "5978:  int len = -1;",
          "5981:  while (len < 0) {",
          "5982:   if (*buf) {",
          "5983:    mg_free(*buf);",
          "5984:   }",
          "5986:   size *= 4;",
          "5988:   if (!*buf) {",
          "5989:    break;",
          "5992:   va_copy(ap_copy, ap);",
          "5993:   len = vsnprintf_impl(*buf, size - 1, fmt, ap_copy);",
          "5994:   va_end(ap_copy);",
          "5995:   (*buf)[size - 1] = 0;",
          "5998:  return len;",
          "5999: }",
          "6005: static int",
          "6006: alloc_vprintf(char **out_buf,",
          "6007:               char *prealloc_buf,",
          "6008:               size_t prealloc_size,",
          "6009:               const char *fmt,",
          "6010:               va_list ap)",
          "6011: {",
          "6012:  va_list ap_copy;",
          "6013:  int len;",
          "6021:  va_copy(ap_copy, ap);",
          "6022:  len = vsnprintf_impl(NULL, 0, fmt, ap_copy);",
          "6023:  va_end(ap_copy);",
          "6025:  if (len < 0) {",
          "6030:   len = alloc_vprintf2(out_buf, fmt, ap_copy);",
          "6033:  } else if ((size_t)(len) >= prealloc_size) {",
          "6037:   if (!*out_buf) {",
          "6039:    return -1;",
          "6042:   va_copy(ap_copy, ap);",
          "6043:   IGNORE_UNUSED_RESULT(",
          "6044:       vsnprintf_impl(*out_buf, (size_t)(len) + 1, fmt, ap_copy));",
          "6045:   va_end(ap_copy);",
          "6047:  } else {",
          "6050:   va_copy(ap_copy, ap);",
          "6051:   IGNORE_UNUSED_RESULT(",
          "6052:       vsnprintf_impl(prealloc_buf, prealloc_size, fmt, ap_copy));",
          "6053:   va_end(ap_copy);",
          "6057:  return len;",
          "6058: }",
          "6061: static int",
          "6062: mg_vprintf(struct mg_connection *conn, const char *fmt, va_list ap)",
          "6063: {",
          "6064:  char mem[MG_BUF_LEN];",
          "6065:  char *buf = NULL;",
          "6066:  int len;",
          "6068:  if ((len = alloc_vprintf(&buf, mem, sizeof(mem), fmt, ap)) > 0) {",
          "6069:   len = mg_write(conn, buf, (size_t)len);",
          "6070:  }",
          "6071:  if ((buf != mem) && (buf != NULL)) {",
          "6072:   mg_free(buf);",
          "6075:  return len;",
          "6076: }",
          "6079: int",
          "6080: mg_printf(struct mg_connection *conn, const char *fmt, ...)",
          "6081: {",
          "6082:  va_list ap;",
          "6083:  int result;",
          "6085:  va_start(ap, fmt);",
          "6086:  result = mg_vprintf(conn, fmt, ap);",
          "6087:  va_end(ap);",
          "6089:  return result;",
          "6090: }",
          "6093: int",
          "6094: mg_url_decode(const char *src,",
          "6095:               int src_len,",
          "6096:               char *dst,",
          "6097:               int dst_len,",
          "6098:               int is_form_url_encoded)",
          "6099: {",
          "6100:  int i, j, a, b;",
          "6103:  for (i = j = 0; (i < src_len) && (j < (dst_len - 1)); i++, j++) {",
          "6104:   if ((i < src_len - 2) && (src[i] == '%')",
          "6105:       && isxdigit(*(const unsigned char *)(src + i + 1))",
          "6106:       && isxdigit(*(const unsigned char *)(src + i + 2))) {",
          "6107:    a = tolower(*(const unsigned char *)(src + i + 1));",
          "6108:    b = tolower(*(const unsigned char *)(src + i + 2));",
          "6109:    dst[j] = (char)((HEXTOI(a) << 4) | HEXTOI(b));",
          "6110:    i += 2;",
          "6111:   } else if (is_form_url_encoded && (src[i] == '+')) {",
          "6112:    dst[j] = ' ';",
          "6113:   } else {",
          "6114:    dst[j] = src[i];",
          "6116:  }",
          "6120:  return (i >= src_len) ? j : -1;",
          "6121: }",
          "6124: int",
          "6125: mg_get_var(const char *data,",
          "6126:            size_t data_len,",
          "6127:            const char *name,",
          "6128:            char *dst,",
          "6129:            size_t dst_len)",
          "6130: {",
          "6131:  return mg_get_var2(data, data_len, name, dst, dst_len, 0);",
          "6132: }",
          "6135: int",
          "6136: mg_get_var2(const char *data,",
          "6137:             size_t data_len,",
          "6138:             const char *name,",
          "6139:             char *dst,",
          "6140:             size_t dst_len,",
          "6141:             size_t occurrence)",
          "6142: {",
          "6143:  const char *p, *e, *s;",
          "6144:  size_t name_len;",
          "6145:  int len;",
          "6147:  if ((dst == NULL) || (dst_len == 0)) {",
          "6148:   len = -2;",
          "6149:  } else if ((data == NULL) || (name == NULL) || (data_len == 0)) {",
          "6150:   len = -1;",
          "6151:   dst[0] = '\\0';",
          "6152:  } else {",
          "6153:   name_len = strlen(name);",
          "6154:   e = data + data_len;",
          "6155:   len = -1;",
          "6156:   dst[0] = '\\0';",
          "6159:   for (p = data; p + name_len < e; p++) {",
          "6160:    if (((p == data) || (p[-1] == '&')) && (p[name_len] == '=')",
          "6161:        && !mg_strncasecmp(name, p, name_len) && 0 == occurrence--) {",
          "6163:     p += name_len + 1;",
          "6166:     s = (const char *)memchr(p, '&', (size_t)(e - p));",
          "6167:     if (s == NULL) {",
          "6168:      s = e;",
          "6169:     }",
          "6171:     if (s < p) {",
          "6172:      return -3;",
          "6173:     }",
          "6176:     len = mg_url_decode(p, (int)(s - p), dst, (int)dst_len, 1);",
          "6180:     if (len == -1) {",
          "6181:      len = -2;",
          "6183:     break;",
          "6186:  }",
          "6188:  return len;",
          "6189: }",
          "6193: int",
          "6194: mg_get_cookie(const char *cookie_header,",
          "6195:               const char *var_name,",
          "6196:               char *dst,",
          "6197:               size_t dst_size)",
          "6198: {",
          "6199:  const char *s, *p, *end;",
          "6200:  int name_len, len = -1;",
          "6202:  if ((dst == NULL) || (dst_size == 0)) {",
          "6203:   return -2;",
          "6204:  }",
          "6206:  dst[0] = '\\0';",
          "6207:  if ((var_name == NULL) || ((s = cookie_header) == NULL)) {",
          "6208:   return -1;",
          "6209:  }",
          "6211:  name_len = (int)strlen(var_name);",
          "6212:  end = s + strlen(s);",
          "6213:  for (; (s = mg_strcasestr(s, var_name)) != NULL; s += name_len) {",
          "6214:   if (s[name_len] == '=') {",
          "6216:    if ((s == cookie_header) || (s[-1] == ' ')) {",
          "6217:     s += name_len + 1;",
          "6218:     if ((p = strchr(s, ' ')) == NULL) {",
          "6219:      p = end;",
          "6220:     }",
          "6221:     if (p[-1] == ';') {",
          "6222:      p--;",
          "6223:     }",
          "6224:     if ((*s == '\"') && (p[-1] == '\"') && (p > s + 1)) {",
          "6225:      s++;",
          "6226:      p--;",
          "6227:     }",
          "6228:     if ((size_t)(p - s) < dst_size) {",
          "6229:      len = (int)(p - s);",
          "6230:      mg_strlcpy(dst, s, (size_t)len + 1);",
          "6231:     } else {",
          "6232:      len = -3;",
          "6234:     break;",
          "6238:  return len;",
          "6239: }",
          "6243: static void",
          "6244: base64_encode(const unsigned char *src, int src_len, char *dst)",
          "6245: {",
          "6246:  static const char *b64 =",
          "6247:      \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";",
          "6248:  int i, j, a, b, c;",
          "6250:  for (i = j = 0; i < src_len; i += 3) {",
          "6251:   a = src[i];",
          "6252:   b = ((i + 1) >= src_len) ? 0 : src[i + 1];",
          "6253:   c = ((i + 2) >= src_len) ? 0 : src[i + 2];",
          "6255:   dst[j++] = b64[a >> 2];",
          "6256:   dst[j++] = b64[((a & 3) << 4) | (b >> 4)];",
          "6257:   if (i + 1 < src_len) {",
          "6258:    dst[j++] = b64[(b & 15) << 2 | (c >> 6)];",
          "6260:   if (i + 2 < src_len) {",
          "6261:    dst[j++] = b64[c & 63];",
          "6264:  while (j % 4 != 0) {",
          "6265:   dst[j++] = '=';",
          "6266:  }",
          "6267:  dst[j++] = '\\0';",
          "6268: }",
          "6273: static unsigned char",
          "6274: b64reverse(char letter)",
          "6275: {",
          "6276:  if ((letter >= 'A') && (letter <= 'Z')) {",
          "6277:   return letter - 'A';",
          "6278:  }",
          "6279:  if ((letter >= 'a') && (letter <= 'z')) {",
          "6280:   return letter - 'a' + 26;",
          "6281:  }",
          "6282:  if ((letter >= '0') && (letter <= '9')) {",
          "6283:   return letter - '0' + 52;",
          "6284:  }",
          "6285:  if (letter == '+') {",
          "6286:   return 62;",
          "6287:  }",
          "6288:  if (letter == '/') {",
          "6289:   return 63;",
          "6290:  }",
          "6291:  if (letter == '=') {",
          "6295: }",
          "6298: static int",
          "6299: base64_decode(const unsigned char *src, int src_len, char *dst, size_t *dst_len)",
          "6300: {",
          "6301:  int i;",
          "6302:  unsigned char a, b, c, d;",
          "6306:  for (i = 0; i < src_len; i += 4) {",
          "6307:   a = b64reverse(src[i]);",
          "6308:   if (a >= 254) {",
          "6309:    return i;",
          "6310:   }",
          "6312:   b = b64reverse(((i + 1) >= src_len) ? 0 : src[i + 1]);",
          "6313:   if (b >= 254) {",
          "6314:    return i + 1;",
          "6315:   }",
          "6317:   c = b64reverse(((i + 2) >= src_len) ? 0 : src[i + 2]);",
          "6318:   if (c == 254) {",
          "6319:    return i + 2;",
          "6320:   }",
          "6322:   d = b64reverse(((i + 3) >= src_len) ? 0 : src[i + 3]);",
          "6323:   if (d == 254) {",
          "6324:    return i + 3;",
          "6325:   }",
          "6327:   dst[(*dst_len)++] = (a << 2) + (b >> 4);",
          "6328:   if (c != 255) {",
          "6329:    dst[(*dst_len)++] = (b << 4) + (c >> 2);",
          "6330:    if (d != 255) {",
          "6331:     dst[(*dst_len)++] = (c << 6) + d;",
          "6335:  return -1;",
          "6336: }",
          "6340: static int",
          "6341: is_put_or_delete_method(const struct mg_connection *conn)",
          "6342: {",
          "6343:  if (conn) {",
          "6344:   const char *s = conn->request_info.request_method;",
          "6345:   return (s != NULL) && (!strcmp(s, \"PUT\") || !strcmp(s, \"DELETE\")",
          "6346:                          || !strcmp(s, \"MKCOL\") || !strcmp(s, \"PATCH\"));",
          "6348:  return 0;",
          "6349: }",
          "6353: static int",
          "6354: extention_matches_script(",
          "6357:     )",
          "6358: {",
          "6360:  if (match_prefix(conn->ctx->config[CGI_EXTENSIONS],",
          "6361:                   strlen(conn->ctx->config[CGI_EXTENSIONS]),",
          "6362:                   filename) > 0) {",
          "6363:   return 1;",
          "6364:  }",
          "6367:  if (match_prefix(conn->ctx->config[LUA_SCRIPT_EXTENSIONS],",
          "6368:                   strlen(conn->ctx->config[LUA_SCRIPT_EXTENSIONS]),",
          "6369:                   filename) > 0) {",
          "6370:   return 1;",
          "6371:  }",
          "6374:  if (match_prefix(conn->ctx->config[DUKTAPE_SCRIPT_EXTENSIONS],",
          "6375:                   strlen(conn->ctx->config[DUKTAPE_SCRIPT_EXTENSIONS]),",
          "6376:                   filename) > 0) {",
          "6377:   return 1;",
          "6378:  }",
          "6382:  (void)filename;",
          "6383:  (void)conn;",
          "6385:  return 0;",
          "6386: }",
          "6392: static int",
          "6393: substitute_index_file(struct mg_connection *conn,",
          "6394:                       char *path,",
          "6395:                       size_t path_len,",
          "6396:                       struct mg_file_stat *filestat)",
          "6397: {",
          "6398:  const char *list = conn->ctx->config[INDEX_FILES];",
          "6399:  struct vec filename_vec;",
          "6400:  size_t n = strlen(path);",
          "6401:  int found = 0;",
          "6406:  while ((n > 0) && (path[n - 1] == '/')) {",
          "6407:   n--;",
          "6408:  }",
          "6409:  path[n] = '/';",
          "6413:  while ((list = next_option(list, &filename_vec, NULL)) != NULL) {",
          "6415:   if (filename_vec.len > (path_len - (n + 2))) {",
          "6416:    continue;",
          "6417:   }",
          "6420:   mg_strlcpy(path + n + 1, filename_vec.ptr, filename_vec.len + 1);",
          "6423:   if (mg_stat(conn, path, filestat)) {",
          "6425:    found = 1;",
          "6426:    break;",
          "6428:  }",
          "6431:  if (!found) {",
          "6432:   path[n] = '\\0';",
          "6433:  }",
          "6435:  return found;",
          "6436: }",
          "6440: static void",
          "6449:               )",
          "6450: {",
          "6452:  const char *uri = conn->request_info.local_uri;",
          "6453:  const char *root = conn->ctx->config[DOCUMENT_ROOT];",
          "6454:  const char *rewrite;",
          "6455:  struct vec a, b;",
          "6456:  int match_len;",
          "6457:  char gz_path[PATH_MAX];",
          "6458:  char const *accept_encoding;",
          "6459:  int truncated;",
          "6461:  char *tmp_str;",
          "6462:  size_t tmp_str_len, sep_pos;",
          "6469:  memset(filestat, 0, sizeof(*filestat));",
          "6482:  if (*is_websocket_request && conn->ctx->config[WEBSOCKET_ROOT]) {",
          "6483:   root = conn->ctx->config[WEBSOCKET_ROOT];",
          "6484:  }",
          "6495:  if (root == NULL) {",
          "6498:   return;",
          "6499:  }",
          "6505:  mg_snprintf(",
          "6506:      conn, &truncated, filename, filename_buf_len - 1, \"%s%s\", root, uri);",
          "6508:  if (truncated) {",
          "6509:   goto interpret_cleanup;",
          "6510:  }",
          "6513:  rewrite = conn->ctx->config[URL_REWRITE_PATTERN];",
          "6514:  while ((rewrite = next_option(rewrite, &a, &b)) != NULL) {",
          "6515:   if ((match_len = match_prefix(a.ptr, a.len, uri)) > 0) {",
          "6516:    mg_snprintf(conn,",
          "6517:                &truncated,",
          "6518:                filename,",
          "6519:                filename_buf_len - 1,",
          "6520:                \"%.*s%s\",",
          "6521:                (int)b.len,",
          "6522:                b.ptr,",
          "6523:                uri + match_len);",
          "6524:    break;",
          "6526:  }",
          "6528:  if (truncated) {",
          "6529:   goto interpret_cleanup;",
          "6530:  }",
          "6535:  if (mg_stat(conn, filename, filestat)) {",
          "6540:   if (extention_matches_script(conn, filename)) {",
          "6557:   if (filestat->is_directory) {",
          "6560:    struct mg_file_stat tmp_filestat;",
          "6561:    memset(&tmp_filestat, 0, sizeof(tmp_filestat));",
          "6563:    if (substitute_index_file(",
          "6564:            conn, filename, filename_buf_len, &tmp_filestat)) {",
          "6570:     if (extention_matches_script(conn, filename)) {",
          "6573:     } else {",
          "6582:   return;",
          "6583:  }",
          "6592:  if ((accept_encoding = mg_get_header(conn, \"Accept-Encoding\")) != NULL) {",
          "6593:   if (strstr(accept_encoding, \"gzip\") != NULL) {",
          "6594:    mg_snprintf(",
          "6595:        conn, &truncated, gz_path, sizeof(gz_path), \"%s.gz\", filename);",
          "6597:    if (truncated) {",
          "6598:     goto interpret_cleanup;",
          "6599:    }",
          "6601:    if (mg_stat(conn, gz_path, filestat)) {",
          "6602:     if (filestat) {",
          "6603:      filestat->is_gzipped = 1;",
          "6607:     return;",
          "6610:  }",
          "6615:  tmp_str_len = strlen(filename);",
          "6616:  tmp_str = mg_malloc_ctx(tmp_str_len + PATH_MAX + 1, conn->ctx);",
          "6617:  if (!tmp_str) {",
          "6619:   goto interpret_cleanup;",
          "6620:  }",
          "6621:  memcpy(tmp_str, filename, tmp_str_len + 1);",
          "6623:  sep_pos = tmp_str_len;",
          "6624:  while (sep_pos > 0) {",
          "6625:   sep_pos--;",
          "6626:   if (tmp_str[sep_pos] == '/') {",
          "6627:    int is_script = 0, does_exist = 0;",
          "6629:    tmp_str[sep_pos] = 0;",
          "6630:    if (tmp_str[0]) {",
          "6631:     is_script = extention_matches_script(conn, tmp_str);",
          "6632:     does_exist = mg_stat(conn, tmp_str, filestat);",
          "6633:    }",
          "6635:    if (does_exist && is_script) {",
          "6636:     filename[sep_pos] = 0;",
          "6637:     memmove(filename + sep_pos + 2,",
          "6638:             filename + sep_pos + 1,",
          "6639:             strlen(filename + sep_pos + 1) + 1);",
          "6640:     conn->path_info = filename + sep_pos + 1;",
          "6641:     filename[sep_pos + 1] = '/';",
          "6644:     break;",
          "6645:    }",
          "6646:    if (substitute_index_file(",
          "6647:            conn, tmp_str, tmp_str_len + PATH_MAX, filestat)) {",
          "6649:     if (extention_matches_script(conn, tmp_str)) {",
          "6652:      char *tmp_str2 = mg_strdup(filename + sep_pos + 1);",
          "6653:      mg_snprintf(conn,",
          "6654:                  &truncated,",
          "6655:                  filename,",
          "6656:                  filename_buf_len,",
          "6657:                  \"%s//%s\",",
          "6658:                  tmp_str,",
          "6659:                  tmp_str2);",
          "6660:      mg_free(tmp_str2);",
          "6662:      if (truncated) {",
          "6663:       mg_free(tmp_str);",
          "6664:       goto interpret_cleanup;",
          "6665:      }",
          "6666:      sep_pos = strlen(tmp_str);",
          "6672:     } else {",
          "6674:      filename[sep_pos] = 0;",
          "6675:      conn->path_info = 0;",
          "6678:      break;",
          "6680:    }",
          "6682:    tmp_str[sep_pos] = '/';",
          "6684:  }",
          "6686:  mg_free(tmp_str);",
          "6690:  return;",
          "6694: interpret_cleanup:",
          "6695:  memset(filestat, 0, sizeof(*filestat));",
          "6702: }",
          "6709: static int",
          "6710: get_http_header_len(const char *buf, int buflen)",
          "6711: {",
          "6712:  int i;",
          "6713:  for (i = 0; i < buflen; i++) {",
          "6715:   const unsigned char c = ((const unsigned char *)buf)[i];",
          "6717:   if ((c < 128) && ((char)c != '\\r') && ((char)c != '\\n')",
          "6718:       && !isprint(c)) {",
          "6720:    return -1;",
          "6721:   }",
          "6723:   if (i < buflen - 1) {",
          "6724:    if ((buf[i] == '\\n') && (buf[i + 1] == '\\n')) {",
          "6728:     return i + 2;",
          "6730:   }",
          "6732:   if (i < buflen - 3) {",
          "6733:    if ((buf[i] == '\\r') && (buf[i + 1] == '\\n') && (buf[i + 2] == '\\r')",
          "6734:        && (buf[i + 3] == '\\n')) {",
          "6736:     return i + 4;",
          "6739:  }",
          "6741:  return 0;",
          "6742: }",
          "6747: static int",
          "6748: get_month_index(const char *s)",
          "6749: {",
          "6750:  size_t i;",
          "6752:  for (i = 0; i < ARRAY_SIZE(month_names); i++) {",
          "6753:   if (!strcmp(s, month_names[i])) {",
          "6754:    return (int)i;",
          "6756:  }",
          "6758:  return -1;",
          "6759: }",
          "6763: static time_t",
          "6764: parse_date_string(const char *datetime)",
          "6765: {",
          "6766:  char month_str[32] = {0};",
          "6767:  int second, minute, hour, day, month, year;",
          "6768:  time_t result = (time_t)0;",
          "6769:  struct tm tm;",
          "6771:  if ((sscanf(datetime,",
          "6772:              \"%d/%3s/%d %d:%d:%d\",",
          "6773:              &day,",
          "6774:              month_str,",
          "6775:              &year,",
          "6776:              &hour,",
          "6777:              &minute,",
          "6778:              &second) == 6) || (sscanf(datetime,",
          "6779:                                        \"%d %3s %d %d:%d:%d\",",
          "6780:                                        &day,",
          "6781:                                        month_str,",
          "6782:                                        &year,",
          "6783:                                        &hour,",
          "6784:                                        &minute,",
          "6785:                                        &second) == 6)",
          "6786:      || (sscanf(datetime,",
          "6787:                 \"%*3s, %d %3s %d %d:%d:%d\",",
          "6788:                 &day,",
          "6789:                 month_str,",
          "6790:                 &year,",
          "6791:                 &hour,",
          "6792:                 &minute,",
          "6793:                 &second) == 6) || (sscanf(datetime,",
          "6794:                                           \"%d-%3s-%d %d:%d:%d\",",
          "6795:                                           &day,",
          "6796:                                           month_str,",
          "6797:                                           &year,",
          "6798:                                           &hour,",
          "6799:                                           &minute,",
          "6800:                                           &second) == 6)) {",
          "6801:   month = get_month_index(month_str);",
          "6802:   if ((month >= 0) && (year >= 1970)) {",
          "6803:    memset(&tm, 0, sizeof(tm));",
          "6804:    tm.tm_year = year - 1900;",
          "6805:    tm.tm_mon = month;",
          "6806:    tm.tm_mday = day;",
          "6807:    tm.tm_hour = hour;",
          "6808:    tm.tm_min = minute;",
          "6809:    tm.tm_sec = second;",
          "6810:    result = timegm(&tm);",
          "6812:  }",
          "6814:  return result;",
          "6815: }",
          "6821: static void",
          "6822: remove_double_dots_and_double_slashes(char *s)",
          "6823: {",
          "6824:  char *p = s;",
          "6826:  while ((s[0] == '.') && (s[1] == '.')) {",
          "6827:   s++;",
          "6828:  }",
          "6830:  while (*s != '\\0') {",
          "6832:   if ((s[-1] == '/') || (s[-1] == '\\\\')) {",
          "6834:    while (s[0] != '\\0') {",
          "6835:     if ((s[0] == '/') || (s[0] == '\\\\')) {",
          "6836:      s++;",
          "6837:     } else if ((s[0] == '.') && (s[1] == '.')) {",
          "6838:      s += 2;",
          "6839:     } else {",
          "6840:      break;",
          "6844:  }",
          "6846: }",
          "6849: static const struct {",
          "6850:  const char *extension;",
          "6851:  size_t ext_len;",
          "6852:  const char *mime_type;",
          "6853: } builtin_mime_types[] = {",
          "6856:     {\".doc\", 4, \"application/msword\"},",
          "6857:     {\".eps\", 4, \"application/postscript\"},",
          "6858:     {\".exe\", 4, \"application/octet-stream\"},",
          "6859:     {\".js\", 3, \"application/javascript\"},",
          "6860:     {\".json\", 5, \"application/json\"},",
          "6861:     {\".pdf\", 4, \"application/pdf\"},",
          "6862:     {\".ps\", 3, \"application/postscript\"},",
          "6863:     {\".rtf\", 4, \"application/rtf\"},",
          "6864:     {\".xhtml\", 6, \"application/xhtml+xml\"},",
          "6865:     {\".xsl\", 4, \"application/xml\"},",
          "6866:     {\".xslt\", 5, \"application/xml\"},",
          "6869:     {\".ttf\", 4, \"application/font-sfnt\"},",
          "6870:     {\".cff\", 4, \"application/font-sfnt\"},",
          "6871:     {\".otf\", 4, \"application/font-sfnt\"},",
          "6872:     {\".aat\", 4, \"application/font-sfnt\"},",
          "6873:     {\".sil\", 4, \"application/font-sfnt\"},",
          "6874:     {\".pfr\", 4, \"application/font-tdpfr\"},",
          "6875:     {\".woff\", 5, \"application/font-woff\"},",
          "6878:     {\".mp3\", 4, \"audio/mpeg\"},",
          "6879:     {\".oga\", 4, \"audio/ogg\"},",
          "6880:     {\".ogg\", 4, \"audio/ogg\"},",
          "6883:     {\".gif\", 4, \"image/gif\"},",
          "6884:     {\".ief\", 4, \"image/ief\"},",
          "6885:     {\".jpeg\", 5, \"image/jpeg\"},",
          "6886:     {\".jpg\", 4, \"image/jpeg\"},",
          "6887:     {\".jpm\", 4, \"image/jpm\"},",
          "6888:     {\".jpx\", 4, \"image/jpx\"},",
          "6889:     {\".png\", 4, \"image/png\"},",
          "6890:     {\".svg\", 4, \"image/svg+xml\"},",
          "6891:     {\".tif\", 4, \"image/tiff\"},",
          "6892:     {\".tiff\", 5, \"image/tiff\"},",
          "6895:     {\".wrl\", 4, \"model/vrml\"},",
          "6898:     {\".css\", 4, \"text/css\"},",
          "6899:     {\".csv\", 4, \"text/csv\"},",
          "6900:     {\".htm\", 4, \"text/html\"},",
          "6901:     {\".html\", 5, \"text/html\"},",
          "6902:     {\".sgm\", 4, \"text/sgml\"},",
          "6903:     {\".shtm\", 5, \"text/html\"},",
          "6904:     {\".shtml\", 6, \"text/html\"},",
          "6905:     {\".txt\", 4, \"text/plain\"},",
          "6906:     {\".xml\", 4, \"text/xml\"},",
          "6909:     {\".mov\", 4, \"video/quicktime\"},",
          "6910:     {\".mp4\", 4, \"video/mp4\"},",
          "6911:     {\".mpeg\", 5, \"video/mpeg\"},",
          "6912:     {\".mpg\", 4, \"video/mpeg\"},",
          "6913:     {\".ogv\", 4, \"video/ogg\"},",
          "6914:     {\".qt\", 3, \"video/quicktime\"},",
          "6919:     {\".arj\", 4, \"application/x-arj-compressed\"},",
          "6920:     {\".gz\", 3, \"application/x-gunzip\"},",
          "6921:     {\".rar\", 4, \"application/x-arj-compressed\"},",
          "6922:     {\".swf\", 4, \"application/x-shockwave-flash\"},",
          "6923:     {\".tar\", 4, \"application/x-tar\"},",
          "6924:     {\".tgz\", 4, \"application/x-tar-gz\"},",
          "6925:     {\".torrent\", 8, \"application/x-bittorrent\"},",
          "6926:     {\".ppt\", 4, \"application/x-mspowerpoint\"},",
          "6927:     {\".xls\", 4, \"application/x-msexcel\"},",
          "6928:     {\".zip\", 4, \"application/x-zip-compressed\"},",
          "6929:     {\".aac\",",
          "6930:      4,",
          "6932:     {\".aif\", 4, \"audio/x-aif\"},",
          "6933:     {\".m3u\", 4, \"audio/x-mpegurl\"},",
          "6934:     {\".mid\", 4, \"audio/x-midi\"},",
          "6935:     {\".ra\", 3, \"audio/x-pn-realaudio\"},",
          "6936:     {\".ram\", 4, \"audio/x-pn-realaudio\"},",
          "6937:     {\".wav\", 4, \"audio/x-wav\"},",
          "6938:     {\".bmp\", 4, \"image/bmp\"},",
          "6939:     {\".ico\", 4, \"image/x-icon\"},",
          "6940:     {\".pct\", 4, \"image/x-pct\"},",
          "6941:     {\".pict\", 5, \"image/pict\"},",
          "6942:     {\".rgb\", 4, \"image/x-rgb\"},",
          "6944:     {\".asf\", 4, \"video/x-ms-asf\"},",
          "6945:     {\".avi\", 4, \"video/x-msvideo\"},",
          "6946:     {\".m4v\", 4, \"video/x-m4v\"},",
          "6947:     {NULL, 0, NULL}};",
          "6950: const char *",
          "6951: mg_get_builtin_mime_type(const char *path)",
          "6952: {",
          "6953:  const char *ext;",
          "6954:  size_t i, path_len;",
          "6956:  path_len = strlen(path);",
          "6958:  for (i = 0; builtin_mime_types[i].extension != NULL; i++) {",
          "6959:   ext = path + (path_len - builtin_mime_types[i].ext_len);",
          "6960:   if ((path_len > builtin_mime_types[i].ext_len)",
          "6961:       && (mg_strcasecmp(ext, builtin_mime_types[i].extension) == 0)) {",
          "6962:    return builtin_mime_types[i].mime_type;",
          "6964:  }",
          "6966:  return \"text/plain\";",
          "6967: }",
          "6972: static void",
          "6973: get_mime_type(struct mg_context *ctx, const char *path, struct vec *vec)",
          "6974: {",
          "6975:  struct vec ext_vec, mime_vec;",
          "6976:  const char *list, *ext;",
          "6977:  size_t path_len;",
          "6979:  path_len = strlen(path);",
          "6981:  if ((ctx == NULL) || (vec == NULL)) {",
          "6982:   if (vec != NULL) {",
          "6983:    memset(vec, '\\0', sizeof(struct vec));",
          "6985:   return;",
          "6986:  }",
          "6990:  list = ctx->config[EXTRA_MIME_TYPES];",
          "6991:  while ((list = next_option(list, &ext_vec, &mime_vec)) != NULL) {",
          "6993:   ext = path + path_len - ext_vec.len;",
          "6994:   if (mg_strncasecmp(ext, ext_vec.ptr, ext_vec.len) == 0) {",
          "6996:    return;",
          "6998:  }",
          "7000:  vec->ptr = mg_get_builtin_mime_type(path);",
          "7001:  vec->len = strlen(vec->ptr);",
          "7002: }",
          "7007: static void",
          "7008: bin2str(char *to, const unsigned char *p, size_t len)",
          "7009: {",
          "7010:  static const char *hex = \"0123456789abcdef\";",
          "7012:  for (; len--; p++) {",
          "7017: }",
          "7021: char *",
          "7022: mg_md5(char buf[33], ...)",
          "7023: {",
          "7024:  md5_byte_t hash[16];",
          "7025:  const char *p;",
          "7026:  va_list ap;",
          "7027:  md5_state_t ctx;",
          "7029:  md5_init(&ctx);",
          "7031:  va_start(ap, buf);",
          "7032:  while ((p = va_arg(ap, const char *)) != NULL) {",
          "7033:   md5_append(&ctx, (const md5_byte_t *)p, strlen(p));",
          "7034:  }",
          "7035:  va_end(ap);",
          "7037:  md5_finish(&ctx, hash);",
          "7038:  bin2str(buf, hash, sizeof(hash));",
          "7039:  return buf;",
          "7040: }",
          "7044: static int",
          "7045: check_password(const char *method,",
          "7046:                const char *ha1,",
          "7047:                const char *uri,",
          "7048:                const char *nonce,",
          "7049:                const char *nc,",
          "7050:                const char *cnonce,",
          "7051:                const char *qop,",
          "7052:                const char *response)",
          "7053: {",
          "7054:  char ha2[32 + 1], expected_response[32 + 1];",
          "7057:  if ((method == NULL) || (nonce == NULL) || (nc == NULL) || (cnonce == NULL)",
          "7058:      || (qop == NULL) || (response == NULL)) {",
          "7059:   return 0;",
          "7060:  }",
          "7063:  if (strlen(response) != 32) {",
          "7064:   return 0;",
          "7065:  }",
          "7067:  mg_md5(ha2, method, \":\", uri, NULL);",
          "7068:  mg_md5(expected_response,",
          "7069:         ha1,",
          "7070:         \":\",",
          "7071:         nonce,",
          "7072:         \":\",",
          "7073:         nc,",
          "7074:         \":\",",
          "7075:         cnonce,",
          "7076:         \":\",",
          "7077:         qop,",
          "7078:         \":\",",
          "7079:         ha2,",
          "7080:         NULL);",
          "7082:  return mg_strcasecmp(response, expected_response) == 0;",
          "7083: }",
          "7088: static void",
          "7089: open_auth_file(struct mg_connection *conn,",
          "7090:                const char *path,",
          "7091:                struct mg_file *filep)",
          "7092: {",
          "7093:  if ((conn != NULL) && (conn->ctx != NULL)) {",
          "7094:   char name[PATH_MAX];",
          "7095:   const char *p, *e, *gpass = conn->ctx->config[GLOBAL_PASSWORDS_FILE];",
          "7096:   int truncated;",
          "7098:   if (gpass != NULL) {",
          "7100:    if (!mg_fopen(conn, gpass, MG_FOPEN_MODE_READ, filep)) {",
          "7103:     mg_cry(conn, \"fopen(%s): %s\", gpass, strerror(ERRNO));",
          "7105:    }",
          "7111:   } else if (mg_stat(conn, path, &filep->stat)",
          "7112:              && filep->stat.is_directory) {",
          "7113:    mg_snprintf(conn,",
          "7114:                &truncated,",
          "7115:                name,",
          "7116:                sizeof(name),",
          "7117:                \"%s/%s\",",
          "7118:                path,",
          "7119:                PASSWORDS_FILE_NAME);",
          "7121:    if (truncated || !mg_fopen(conn, name, MG_FOPEN_MODE_READ, filep)) {",
          "7126:     DEBUG_TRACE(\"fopen(%s): %s\", name, strerror(ERRNO));",
          "7128:    }",
          "7129:   } else {",
          "7131:    for (p = path, e = p + strlen(p) - 1; e > p; e--) {",
          "7132:     if (e[0] == '/') {",
          "7133:      break;",
          "7135:    }",
          "7136:    mg_snprintf(conn,",
          "7137:                &truncated,",
          "7138:                name,",
          "7139:                sizeof(name),",
          "7140:                \"%.*s/%s\",",
          "7141:                (int)(e - p),",
          "7142:                p,",
          "7143:                PASSWORDS_FILE_NAME);",
          "7145:    if (truncated || !mg_fopen(conn, name, MG_FOPEN_MODE_READ, filep)) {",
          "7150:     DEBUG_TRACE(\"fopen(%s): %s\", name, strerror(ERRNO));",
          "7155: }",
          "7159: struct ah {",
          "7160:  char *user, *uri, *cnonce, *response, *qop, *nc, *nonce;",
          "7161: };",
          "7165: static int",
          "7166: parse_auth_header(struct mg_connection *conn,",
          "7167:                   char *buf,",
          "7168:                   size_t buf_size,",
          "7169:                   struct ah *ah)",
          "7170: {",
          "7171:  char *name, *value, *s;",
          "7172:  const char *auth_header;",
          "7173:  uint64_t nonce;",
          "7175:  if (!ah || !conn) {",
          "7176:   return 0;",
          "7177:  }",
          "7179:  (void)memset(ah, 0, sizeof(*ah));",
          "7180:  if (((auth_header = mg_get_header(conn, \"Authorization\")) == NULL)",
          "7181:      || mg_strncasecmp(auth_header, \"Digest \", 7) != 0) {",
          "7182:   return 0;",
          "7183:  }",
          "7186:  (void)mg_strlcpy(buf, auth_header + 7, buf_size);",
          "7187:  s = buf;",
          "7190:  for (;;) {",
          "7192:   while (isspace(*(unsigned char *)s)) {",
          "7193:    s++;",
          "7194:   }",
          "7195:   name = skip_quoted(&s, \"=\", \" \", 0);",
          "7197:   if (s[0] == '\\\"') {",
          "7198:    s++;",
          "7199:    value = skip_quoted(&s, \"\\\"\", \" \", '\\\\');",
          "7200:    if (s[0] == ',') {",
          "7203:   } else {",
          "7204:    value = skip_quoted(&s, \", \", \" \", 0); /* IE uses commas, FF uses",
          "7206:   }",
          "7207:   if (*name == '\\0') {",
          "7208:    break;",
          "7209:   }",
          "7211:   if (!strcmp(name, \"username\")) {",
          "7212:    ah->user = value;",
          "7213:   } else if (!strcmp(name, \"cnonce\")) {",
          "7214:    ah->cnonce = value;",
          "7215:   } else if (!strcmp(name, \"response\")) {",
          "7216:    ah->response = value;",
          "7217:   } else if (!strcmp(name, \"uri\")) {",
          "7218:    ah->uri = value;",
          "7219:   } else if (!strcmp(name, \"qop\")) {",
          "7220:    ah->qop = value;",
          "7221:   } else if (!strcmp(name, \"nc\")) {",
          "7222:    ah->nc = value;",
          "7223:   } else if (!strcmp(name, \"nonce\")) {",
          "7224:    ah->nonce = value;",
          "7226:  }",
          "7230:  if (ah->nonce == NULL) {",
          "7231:   return 0;",
          "7232:  }",
          "7233:  s = NULL;",
          "7234:  nonce = strtoull(ah->nonce, &s, 10);",
          "7235:  if ((s == NULL) || (*s != 0)) {",
          "7236:   return 0;",
          "7237:  }",
          "7240:  nonce ^= conn->ctx->auth_nonce_mask;",
          "7250:  if (nonce < (uint64_t)conn->ctx->start_time) {",
          "7253:   return 0;",
          "7254:  }",
          "7257:  if (nonce >= ((uint64_t)conn->ctx->start_time + conn->ctx->nonce_count)) {",
          "7258:   return 0;",
          "7259:  }",
          "7265:  if (ah->user != NULL) {",
          "7266:   conn->request_info.remote_user = mg_strdup(ah->user);",
          "7267:  } else {",
          "7268:   return 0;",
          "7269:  }",
          "7271:  return 1;",
          "7272: }",
          "7275: static const char *",
          "7276: mg_fgets(char *buf, size_t size, struct mg_file *filep, char **p)",
          "7277: {",
          "7278:  const char *eof;",
          "7279:  size_t len;",
          "7280:  const char *memend;",
          "7282:  if (!filep) {",
          "7283:   return NULL;",
          "7284:  }",
          "7286:  if ((filep->access.membuf != NULL) && (*p != NULL)) {",
          "7287:   memend = (const char *)&filep->access.membuf[filep->stat.size];",
          "7289:   eof = (char *)memchr(*p, '\\n', (size_t)(memend - *p));",
          "7290:   if (eof != NULL) {",
          "7294:   }",
          "7295:   len =",
          "7296:       ((size_t)(eof - *p) > (size - 1)) ? (size - 1) : (size_t)(eof - *p);",
          "7297:   memcpy(buf, *p, len);",
          "7298:   buf[len] = '\\0';",
          "7300:   return len ? eof : NULL;",
          "7301:  } else if (filep->access.fp != NULL) {",
          "7302:   return fgets(buf, (int)size, filep->access.fp);",
          "7303:  } else {",
          "7304:   return NULL;",
          "7306: }",
          "",
          "[Added Lines]",
          "5601:   }",
          "5604:   return -1;",
          "5605:  }",
          "5608:  static int pull_all(FILE * fp,",
          "5609:                      struct mg_connection * conn,",
          "5610:                      char *buf,",
          "5611:                      int len)",
          "5612:  {",
          "5613:   int n, nread = 0;",
          "5614:   double timeout = -1.0;",
          "5615:   uint64_t start_time = 0, now = 0, timeout_ns = 0;",
          "5617:   if (conn->ctx->config[REQUEST_TIMEOUT]) {",
          "5618:    timeout = atoi(conn->ctx->config[REQUEST_TIMEOUT]) / 1000.0;",
          "5619:   }",
          "5620:   if (timeout >= 0.0) {",
          "5621:    start_time = mg_get_current_time_ns();",
          "5622:    timeout_ns = (uint64_t)(timeout * 1.0E9);",
          "5623:   }",
          "5625:   while ((len > 0) && (conn->ctx->stop_flag == 0)) {",
          "5626:    n = pull_inner(fp, conn, buf + nread, len, timeout);",
          "5627:    if (n == -2) {",
          "5628:     if (nread == 0) {",
          "5630:     }",
          "5631:     break;",
          "5632:    } else if (n == -1) {",
          "5634:     if (timeout >= 0.0) {",
          "5635:      now = mg_get_current_time_ns();",
          "5636:      if ((now - start_time) <= timeout_ns) {",
          "5637:       continue;",
          "5638:      }",
          "5640:     break;",
          "5641:    } else if (n == 0) {",
          "5643:    } else {",
          "5644:     conn->consumed_content += n;",
          "5645:     nread += n;",
          "5646:     len -= n;",
          "5650:   return nread;",
          "5651:  }",
          "5654:  static void discard_unread_request_data(struct mg_connection * conn)",
          "5655:  {",
          "5656:   char buf[MG_BUF_LEN];",
          "5657:   size_t to_read;",
          "5658:   int nread;",
          "5660:   if (conn == NULL) {",
          "5661:    return;",
          "5662:   }",
          "5664:   to_read = sizeof(buf);",
          "5666:   if (conn->is_chunked) {",
          "5669:    while (conn->is_chunked == 1) {",
          "5670:     nread = mg_read(conn, buf, to_read);",
          "5671:     if (nread <= 0) {",
          "5672:      break;",
          "5673:     }",
          "5676:   } else {",
          "5678:    while (conn->consumed_content < conn->content_len) {",
          "5679:     if (to_read",
          "5680:         > (size_t)(conn->content_len - conn->consumed_content)) {",
          "5681:      to_read =",
          "5682:          (size_t)(conn->content_len - conn->consumed_content);",
          "5683:     }",
          "5685:     nread = mg_read(conn, buf, to_read);",
          "5686:     if (nread <= 0) {",
          "5687:      break;",
          "5688:     }",
          "5694:  static int mg_read_inner(struct mg_connection * conn, void *buf, size_t len)",
          "5695:  {",
          "5696:   int64_t n, buffered_len, nread;",
          "5697:   int64_t len64 = (int64_t)(",
          "5698:       (len > INT_MAX) ? INT_MAX : len); /* since the return value is",
          "5701:   const char *body;",
          "5703:   if (conn == NULL) {",
          "5704:    return 0;",
          "5705:   }",
          "5709:   if ((conn->consumed_content) == 0 && (conn->content_len == -1)) {",
          "5710:    conn->content_len = INT64_MAX;",
          "5711:    conn->must_close = 1;",
          "5714:   nread = 0;",
          "5715:   if (conn->consumed_content < conn->content_len) {",
          "5717:    int64_t left_to_read = conn->content_len - conn->consumed_content;",
          "5718:    if (left_to_read < len64) {",
          "5722:     len64 = left_to_read;",
          "5726:    buffered_len = (int64_t)(conn->data_len)",
          "5727:                   - (int64_t)conn->request_len",
          "5728:                   - conn->consumed_content;",
          "5729:    if (buffered_len > 0) {",
          "5730:     if (len64 < buffered_len) {",
          "5731:      buffered_len = len64;",
          "5732:     }",
          "5733:     body = conn->buf + conn->request_len + conn->consumed_content;",
          "5734:     memcpy(buf, body, (size_t)buffered_len);",
          "5735:     len64 -= buffered_len;",
          "5736:     conn->consumed_content += buffered_len;",
          "5737:     nread += buffered_len;",
          "5738:     buf = (char *)buf + buffered_len;",
          "5739:    }",
          "5744:    if ((n = pull_all(NULL, conn, (char *)buf, (int)len64)) >= 0) {",
          "5745:     nread += n;",
          "5746:    } else {",
          "5747:     nread = ((nread > 0) ? nread : n);",
          "5748:    }",
          "5750:   return (int)nread;",
          "5754:  static char mg_getc(struct mg_connection * conn)",
          "5755:  {",
          "5756:   char c;",
          "5757:   if (conn == NULL) {",
          "5758:    return 0;",
          "5759:   }",
          "5760:   conn->content_len++;",
          "5761:   if (mg_read_inner(conn, &c, 1) <= 0) {",
          "5762:    return (char)0;",
          "5763:   }",
          "5764:   return c;",
          "5768:  int mg_read(struct mg_connection * conn, void *buf, size_t len)",
          "5769:  {",
          "5770:   if (len > INT_MAX) {",
          "5771:    len = INT_MAX;",
          "5772:   }",
          "5774:   if (conn == NULL) {",
          "5775:    return 0;",
          "5776:   }",
          "5778:   if (conn->is_chunked) {",
          "5779:    size_t all_read = 0;",
          "5781:    while (len > 0) {",
          "5783:     if (conn->is_chunked == 2) {",
          "5785:      return 0;",
          "5786:     }",
          "5788:     if (conn->chunk_remainder) {",
          "5790:      long read_ret;",
          "5791:      size_t read_now = ((conn->chunk_remainder > len)",
          "5792:                             ? (len)",
          "5793:                             : (conn->chunk_remainder));",
          "5795:      conn->content_len += (int)read_now;",
          "5796:      read_ret =",
          "5797:          mg_read_inner(conn, (char *)buf + all_read, read_now);",
          "5799:      if (read_ret < 1) {",
          "5804:      all_read += (size_t)read_ret;",
          "5805:      conn->chunk_remainder -= (size_t)read_ret;",
          "5806:      len -= (size_t)read_ret;",
          "5808:      if (conn->chunk_remainder == 0) {",
          "5811:       char x1 = mg_getc(conn);",
          "5812:       char x2 = mg_getc(conn);",
          "5813:       if ((x1 != '\\r') || (x2 != '\\n')) {",
          "5815:        return -1;",
          "5816:       }",
          "5819:     } else {",
          "5821:      int i = 0;",
          "5822:      char lenbuf[64];",
          "5823:      char *end = 0;",
          "5824:      unsigned long chunkSize = 0;",
          "5826:      for (i = 0; i < ((int)sizeof(lenbuf) - 1); i++) {",
          "5827:       lenbuf[i] = mg_getc(conn);",
          "5828:       if ((i > 0) && (lenbuf[i] == '\\r')",
          "5829:           && (lenbuf[i - 1] != '\\r')) {",
          "5830:        continue;",
          "5831:       }",
          "5832:       if ((i > 1) && (lenbuf[i] == '\\n')",
          "5833:           && (lenbuf[i - 1] == '\\r')) {",
          "5834:        lenbuf[i + 1] = 0;",
          "5835:        chunkSize = strtoul(lenbuf, &end, 16);",
          "5836:        if (chunkSize == 0) {",
          "5838:         conn->is_chunked = 2;",
          "5839:        }",
          "5840:        break;",
          "5841:       }",
          "5842:       if (!isxdigit(lenbuf[i])) {",
          "5844:        return -1;",
          "5847:      if ((end == NULL) || (*end != '\\r')) {",
          "5851:      if (chunkSize == 0) {",
          "5852:       break;",
          "5853:      }",
          "5855:      conn->chunk_remainder = chunkSize;",
          "5856:     }",
          "5859:    return (int)all_read;",
          "5860:   }",
          "5861:   return mg_read_inner(conn, buf, len);",
          "5865:  int mg_write(struct mg_connection * conn, const void *buf, size_t len)",
          "5866:  {",
          "5867:   time_t now;",
          "5868:   int64_t n, total, allowed;",
          "5870:   if (conn == NULL) {",
          "5871:    return 0;",
          "5872:   }",
          "5874:   if (conn->throttle > 0) {",
          "5875:    if ((now = time(NULL)) != conn->last_throttle_time) {",
          "5876:     conn->last_throttle_time = now;",
          "5877:     conn->last_throttle_bytes = 0;",
          "5878:    }",
          "5879:    allowed = conn->throttle - conn->last_throttle_bytes;",
          "5880:    if (allowed > (int64_t)len) {",
          "5881:     allowed = (int64_t)len;",
          "5882:    }",
          "5883:    if ((total = push_all(conn->ctx,",
          "5884:                          NULL,",
          "5885:                          conn->client.sock,",
          "5886:                          conn->ssl,",
          "5887:                          (const char *)buf,",
          "5888:                          (int64_t)allowed)) == allowed) {",
          "5889:     buf = (const char *)buf + total;",
          "5890:     conn->last_throttle_bytes += total;",
          "5891:     while ((total < (int64_t)len) && (conn->ctx->stop_flag == 0)) {",
          "5892:      allowed = (conn->throttle > ((int64_t)len - total))",
          "5893:                    ? (int64_t)len - total",
          "5894:                    : conn->throttle;",
          "5895:      if ((n = push_all(conn->ctx,",
          "5896:                        NULL,",
          "5897:                        conn->client.sock,",
          "5898:                        conn->ssl,",
          "5899:                        (const char *)buf,",
          "5900:                        (int64_t)allowed)) != allowed) {",
          "5901:       break;",
          "5902:      }",
          "5903:      sleep(1);",
          "5904:      conn->last_throttle_bytes = allowed;",
          "5905:      conn->last_throttle_time = time(NULL);",
          "5906:      buf = (const char *)buf + n;",
          "5907:      total += n;",
          "5910:   } else {",
          "5911:    total = push_all(conn->ctx,",
          "5912:                     NULL,",
          "5913:                     conn->client.sock,",
          "5914:                     conn->ssl,",
          "5915:                     (const char *)buf,",
          "5916:                     (int64_t)len);",
          "5918:   if (total > 0) {",
          "5919:    conn->num_bytes_sent += total;",
          "5920:   }",
          "5921:   return (int)total;",
          "5926:  int mg_send_chunk(struct mg_connection * conn,",
          "5927:                    const char *chunk,",
          "5928:                    unsigned int chunk_len)",
          "5929:  {",
          "5930:   char lenbuf[16];",
          "5931:   size_t lenbuf_len;",
          "5932:   int ret;",
          "5933:   int t;",
          "5936:   sprintf(lenbuf, \"%x\\r\\n\", chunk_len);",
          "5937:   lenbuf_len = strlen(lenbuf);",
          "5940:   ret = mg_write(conn, lenbuf, lenbuf_len);",
          "5941:   if (ret != (int)lenbuf_len) {",
          "5942:    return -1;",
          "5943:   }",
          "5944:   t = ret;",
          "5946:   ret = mg_write(conn, chunk, chunk_len);",
          "5947:   if (ret != (int)chunk_len) {",
          "5948:    return -1;",
          "5949:   }",
          "5950:   t += ret;",
          "5952:   ret = mg_write(conn, \"\\r\\n\", 2);",
          "5953:   if (ret != 2) {",
          "5954:    return -1;",
          "5955:   }",
          "5956:   t += ret;",
          "5958:   return t;",
          "5959:  }",
          "5963:  static int alloc_vprintf2(char **buf, const char *fmt, va_list ap)",
          "5964:  {",
          "5965:   va_list ap_copy;",
          "5966:   size_t size = MG_BUF_LEN / 4;",
          "5967:   int len = -1;",
          "5970:   while (len < 0) {",
          "5971:    if (*buf) {",
          "5972:     mg_free(*buf);",
          "5973:    }",
          "5975:    size *= 4;",
          "5977:    if (!*buf) {",
          "5978:     break;",
          "5979:    }",
          "5981:    va_copy(ap_copy, ap);",
          "5982:    len = vsnprintf_impl(*buf, size - 1, fmt, ap_copy);",
          "5983:    va_end(ap_copy);",
          "5984:    (*buf)[size - 1] = 0;",
          "5987:   return len;",
          "5995:  static int alloc_vprintf(char **out_buf,",
          "5996:                           char *prealloc_buf,",
          "5997:                           size_t prealloc_size,",
          "5998:                           const char *fmt,",
          "5999:                           va_list ap)",
          "6000:  {",
          "6001:   va_list ap_copy;",
          "6002:   int len;",
          "6011:   len = vsnprintf_impl(NULL, 0, fmt, ap_copy);",
          "6014:   if (len < 0) {",
          "6019:    va_copy(ap_copy, ap);",
          "6020:    len = alloc_vprintf2(out_buf, fmt, ap_copy);",
          "6021:    va_end(ap_copy);",
          "6023:   } else if ((size_t)(len) >= prealloc_size) {",
          "6027:    if (!*out_buf) {",
          "6029:     return -1;",
          "6030:    }",
          "6032:    va_copy(ap_copy, ap);",
          "6033:    IGNORE_UNUSED_RESULT(",
          "6034:        vsnprintf_impl(*out_buf, (size_t)(len) + 1, fmt, ap_copy));",
          "6035:    va_end(ap_copy);",
          "6037:   } else {",
          "6040:    va_copy(ap_copy, ap);",
          "6041:    IGNORE_UNUSED_RESULT(",
          "6042:        vsnprintf_impl(prealloc_buf, prealloc_size, fmt, ap_copy));",
          "6043:    va_end(ap_copy);",
          "6047:   return len;",
          "6051:  static int mg_vprintf(struct mg_connection * conn,",
          "6052:                        const char *fmt,",
          "6053:                        va_list ap)",
          "6054:  {",
          "6055:   char mem[MG_BUF_LEN];",
          "6056:   char *buf = NULL;",
          "6057:   int len;",
          "6059:   if ((len = alloc_vprintf(&buf, mem, sizeof(mem), fmt, ap)) > 0) {",
          "6060:    len = mg_write(conn, buf, (size_t)len);",
          "6061:   }",
          "6062:   if ((buf != mem) && (buf != NULL)) {",
          "6063:    mg_free(buf);",
          "6064:   }",
          "6066:   return len;",
          "6070:  int mg_printf(struct mg_connection * conn, const char *fmt, ...)",
          "6071:  {",
          "6072:   va_list ap;",
          "6073:   int result;",
          "6075:   va_start(ap, fmt);",
          "6076:   result = mg_vprintf(conn, fmt, ap);",
          "6077:   va_end(ap);",
          "6079:   return result;",
          "6080:  }",
          "6083:  int mg_url_decode(const char *src,",
          "6084:                    int src_len,",
          "6085:                    char *dst,",
          "6086:                    int dst_len,",
          "6087:                    int is_form_url_encoded)",
          "6088:  {",
          "6089:   int i, j, a, b;",
          "6092:   for (i = j = 0; (i < src_len) && (j < (dst_len - 1)); i++, j++) {",
          "6093:    if ((i < src_len - 2) && (src[i] == '%')",
          "6094:        && isxdigit(*(const unsigned char *)(src + i + 1))",
          "6095:        && isxdigit(*(const unsigned char *)(src + i + 2))) {",
          "6096:     a = tolower(*(const unsigned char *)(src + i + 1));",
          "6097:     b = tolower(*(const unsigned char *)(src + i + 2));",
          "6098:     dst[j] = (char)((HEXTOI(a) << 4) | HEXTOI(b));",
          "6099:     i += 2;",
          "6100:    } else if (is_form_url_encoded && (src[i] == '+')) {",
          "6101:     dst[j] = ' ';",
          "6102:    } else {",
          "6103:     dst[j] = src[i];",
          "6104:    }",
          "6109:   return (i >= src_len) ? j : -1;",
          "6110:  }",
          "6113:  int mg_get_var(const char *data,",
          "6114:                 size_t data_len,",
          "6115:                 const char *name,",
          "6116:                 char *dst,",
          "6117:                 size_t dst_len)",
          "6118:  {",
          "6119:   return mg_get_var2(data, data_len, name, dst, dst_len, 0);",
          "6120:  }",
          "6123:  int mg_get_var2(const char *data,",
          "6124:                  size_t data_len,",
          "6125:                  const char *name,",
          "6126:                  char *dst,",
          "6127:                  size_t dst_len,",
          "6128:                  size_t occurrence)",
          "6129:  {",
          "6130:   const char *p, *e, *s;",
          "6131:   size_t name_len;",
          "6132:   int len;",
          "6134:   if ((dst == NULL) || (dst_len == 0)) {",
          "6135:    len = -2;",
          "6136:   } else if ((data == NULL) || (name == NULL) || (data_len == 0)) {",
          "6137:    len = -1;",
          "6138:    dst[0] = '\\0';",
          "6139:   } else {",
          "6140:    name_len = strlen(name);",
          "6141:    e = data + data_len;",
          "6142:    len = -1;",
          "6143:    dst[0] = '\\0';",
          "6146:    for (p = data; p + name_len < e; p++) {",
          "6147:     if (((p == data) || (p[-1] == '&')) && (p[name_len] == '=')",
          "6148:         && !mg_strncasecmp(name, p, name_len)",
          "6149:         && 0 == occurrence--) {",
          "6151:      p += name_len + 1;",
          "6154:      s = (const char *)memchr(p, '&', (size_t)(e - p));",
          "6155:      if (s == NULL) {",
          "6156:       s = e;",
          "6157:      }",
          "6159:      if (s < p) {",
          "6160:       return -3;",
          "6161:      }",
          "6164:      len = mg_url_decode(p, (int)(s - p), dst, (int)dst_len, 1);",
          "6168:      if (len == -1) {",
          "6169:       len = -2;",
          "6170:      }",
          "6171:      break;",
          "6176:   return len;",
          "6177:  }",
          "6181:  int mg_get_cookie(const char *cookie_header,",
          "6182:                    const char *var_name,",
          "6183:                    char *dst,",
          "6184:                    size_t dst_size)",
          "6185:  {",
          "6186:   const char *s, *p, *end;",
          "6187:   int name_len, len = -1;",
          "6189:   if ((dst == NULL) || (dst_size == 0)) {",
          "6190:    return -2;",
          "6191:   }",
          "6193:   dst[0] = '\\0';",
          "6194:   if ((var_name == NULL) || ((s = cookie_header) == NULL)) {",
          "6195:    return -1;",
          "6196:   }",
          "6198:   name_len = (int)strlen(var_name);",
          "6199:   end = s + strlen(s);",
          "6200:   for (; (s = mg_strcasestr(s, var_name)) != NULL; s += name_len) {",
          "6201:    if (s[name_len] == '=') {",
          "6203:     if ((s == cookie_header) || (s[-1] == ' ')) {",
          "6204:      s += name_len + 1;",
          "6205:      if ((p = strchr(s, ' ')) == NULL) {",
          "6206:       p = end;",
          "6207:      }",
          "6208:      if (p[-1] == ';') {",
          "6209:       p--;",
          "6210:      }",
          "6211:      if ((*s == '\"') && (p[-1] == '\"') && (p > s + 1)) {",
          "6212:       s++;",
          "6213:       p--;",
          "6214:      }",
          "6215:      if ((size_t)(p - s) < dst_size) {",
          "6216:       len = (int)(p - s);",
          "6217:       mg_strlcpy(dst, s, (size_t)len + 1);",
          "6218:      } else {",
          "6219:       len = -3;",
          "6220:      }",
          "6221:      break;",
          "6225:   return len;",
          "6230:  static void base64_encode(const unsigned char *src, int src_len, char *dst)",
          "6231:  {",
          "6232:   static const char *b64 =",
          "6233:       \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";",
          "6234:   int i, j, a, b, c;",
          "6236:   for (i = j = 0; i < src_len; i += 3) {",
          "6237:    a = src[i];",
          "6238:    b = ((i + 1) >= src_len) ? 0 : src[i + 1];",
          "6239:    c = ((i + 2) >= src_len) ? 0 : src[i + 2];",
          "6241:    dst[j++] = b64[a >> 2];",
          "6242:    dst[j++] = b64[((a & 3) << 4) | (b >> 4)];",
          "6243:    if (i + 1 < src_len) {",
          "6244:     dst[j++] = b64[(b & 15) << 2 | (c >> 6)];",
          "6245:    }",
          "6246:    if (i + 2 < src_len) {",
          "6247:     dst[j++] = b64[c & 63];",
          "6248:    }",
          "6250:   while (j % 4 != 0) {",
          "6251:    dst[j++] = '=';",
          "6253:   dst[j++] = '\\0';",
          "6259:  static unsigned char b64reverse(char letter)",
          "6260:  {",
          "6261:   if ((letter >= 'A') && (letter <= 'Z')) {",
          "6262:    return letter - 'A';",
          "6263:   }",
          "6264:   if ((letter >= 'a') && (letter <= 'z')) {",
          "6265:    return letter - 'a' + 26;",
          "6266:   }",
          "6267:   if ((letter >= '0') && (letter <= '9')) {",
          "6268:    return letter - '0' + 52;",
          "6269:   }",
          "6270:   if (letter == '+') {",
          "6271:    return 62;",
          "6272:   }",
          "6273:   if (letter == '/') {",
          "6274:    return 63;",
          "6275:   }",
          "6276:   if (letter == '=') {",
          "6278:   }",
          "6283:  static int base64_decode(const unsigned char *src,",
          "6284:                           int src_len,",
          "6285:                           char *dst,",
          "6286:                           size_t *dst_len)",
          "6287:  {",
          "6288:   int i;",
          "6289:   unsigned char a, b, c, d;",
          "6293:   for (i = 0; i < src_len; i += 4) {",
          "6294:    a = b64reverse(src[i]);",
          "6295:    if (a >= 254) {",
          "6296:     return i;",
          "6297:    }",
          "6299:    b = b64reverse(((i + 1) >= src_len) ? 0 : src[i + 1]);",
          "6300:    if (b >= 254) {",
          "6301:     return i + 1;",
          "6302:    }",
          "6304:    c = b64reverse(((i + 2) >= src_len) ? 0 : src[i + 2]);",
          "6305:    if (c == 254) {",
          "6306:     return i + 2;",
          "6307:    }",
          "6309:    d = b64reverse(((i + 3) >= src_len) ? 0 : src[i + 3]);",
          "6310:    if (d == 254) {",
          "6311:     return i + 3;",
          "6312:    }",
          "6314:    dst[(*dst_len)++] = (a << 2) + (b >> 4);",
          "6315:    if (c != 255) {",
          "6316:     dst[(*dst_len)++] = (b << 4) + (c >> 2);",
          "6317:     if (d != 255) {",
          "6318:      dst[(*dst_len)++] = (c << 6) + d;",
          "6319:     }",
          "6322:   return -1;",
          "6327:  static int is_put_or_delete_method(const struct mg_connection *conn)",
          "6328:  {",
          "6329:   if (conn) {",
          "6330:    const char *s = conn->request_info.request_method;",
          "6331:    return (s != NULL)",
          "6332:           && (!strcmp(s, \"PUT\") || !strcmp(s, \"DELETE\")",
          "6333:               || !strcmp(s, \"MKCOL\") || !strcmp(s, \"PATCH\"));",
          "6334:   }",
          "6335:   return 0;",
          "6340:  static int extention_matches_script(",
          "6343:      )",
          "6344:  {",
          "6346:   if (match_prefix(conn->ctx->config[CGI_EXTENSIONS],",
          "6347:                    strlen(conn->ctx->config[CGI_EXTENSIONS]),",
          "6348:                    filename) > 0) {",
          "6349:    return 1;",
          "6350:   }",
          "6353:   if (match_prefix(conn->ctx->config[LUA_SCRIPT_EXTENSIONS],",
          "6354:                    strlen(conn->ctx->config[LUA_SCRIPT_EXTENSIONS]),",
          "6355:                    filename) > 0) {",
          "6356:    return 1;",
          "6357:   }",
          "6360:   if (match_prefix(conn->ctx->config[DUKTAPE_SCRIPT_EXTENSIONS],",
          "6361:                    strlen(conn->ctx->config[DUKTAPE_SCRIPT_EXTENSIONS]),",
          "6362:                    filename) > 0) {",
          "6363:    return 1;",
          "6364:   }",
          "6368:   (void)filename;",
          "6369:   (void)conn;",
          "6371:   return 0;",
          "6372:  }",
          "6378:  static int substitute_index_file(struct mg_connection * conn,",
          "6379:                                   char *path,",
          "6380:                                   size_t path_len,",
          "6381:                                   struct mg_file_stat *filestat)",
          "6382:  {",
          "6383:   const char *list = conn->ctx->config[INDEX_FILES];",
          "6384:   struct vec filename_vec;",
          "6385:   size_t n = strlen(path);",
          "6386:   int found = 0;",
          "6391:   while ((n > 0) && (path[n - 1] == '/')) {",
          "6392:    n--;",
          "6393:   }",
          "6394:   path[n] = '/';",
          "6398:   while ((list = next_option(list, &filename_vec, NULL)) != NULL) {",
          "6400:    if (filename_vec.len > (path_len - (n + 2))) {",
          "6401:     continue;",
          "6402:    }",
          "6405:    mg_strlcpy(path + n + 1, filename_vec.ptr, filename_vec.len + 1);",
          "6408:    if (mg_stat(conn, path, filestat)) {",
          "6410:     found = 1;",
          "6411:     break;",
          "6412:    }",
          "6416:   if (!found) {",
          "6417:    path[n] = '\\0';",
          "6418:   }",
          "6420:   return found;",
          "6421:  }",
          "6425:  static void interpret_uri(",
          "6434:      )",
          "6435:  {",
          "6437:   const char *uri = conn->request_info.local_uri;",
          "6438:   const char *root = conn->ctx->config[DOCUMENT_ROOT];",
          "6439:   const char *rewrite;",
          "6440:   struct vec a, b;",
          "6441:   int match_len;",
          "6442:   char gz_path[PATH_MAX];",
          "6443:   char const *accept_encoding;",
          "6444:   int truncated;",
          "6446:   char *tmp_str;",
          "6447:   size_t tmp_str_len, sep_pos;",
          "6454:   memset(filestat, 0, sizeof(*filestat));",
          "6467:   if (*is_websocket_request && conn->ctx->config[WEBSOCKET_ROOT]) {",
          "6468:    root = conn->ctx->config[WEBSOCKET_ROOT];",
          "6469:   }",
          "6480:   if (root == NULL) {",
          "6483:    return;",
          "6484:   }",
          "6490:   mg_snprintf(conn,",
          "6491:               &truncated,",
          "6492:               filename,",
          "6493:               filename_buf_len - 1,",
          "6494:               \"%s%s\",",
          "6495:               root,",
          "6496:               uri);",
          "6498:   if (truncated) {",
          "6499:    goto interpret_cleanup;",
          "6503:   rewrite = conn->ctx->config[URL_REWRITE_PATTERN];",
          "6504:   while ((rewrite = next_option(rewrite, &a, &b)) != NULL) {",
          "6505:    if ((match_len = match_prefix(a.ptr, a.len, uri)) > 0) {",
          "6506:     mg_snprintf(conn,",
          "6507:                 &truncated,",
          "6508:                 filename,",
          "6509:                 filename_buf_len - 1,",
          "6510:                 \"%.*s%s\",",
          "6511:                 (int)b.len,",
          "6512:                 b.ptr,",
          "6513:                 uri + match_len);",
          "6514:     break;",
          "6515:    }",
          "6518:   if (truncated) {",
          "6519:    goto interpret_cleanup;",
          "6520:   }",
          "6525:   if (mg_stat(conn, filename, filestat)) {",
          "6530:    if (extention_matches_script(conn, filename)) {",
          "6543:    }",
          "6547:    if (filestat->is_directory) {",
          "6550:     struct mg_file_stat tmp_filestat;",
          "6551:     memset(&tmp_filestat, 0, sizeof(tmp_filestat));",
          "6553:     if (substitute_index_file(",
          "6554:             conn, filename, filename_buf_len, &tmp_filestat)) {",
          "6560:      if (extention_matches_script(conn, filename)) {",
          "6563:      } else {",
          "6567:      }",
          "6572:    return;",
          "6582:   if ((accept_encoding = mg_get_header(conn, \"Accept-Encoding\"))",
          "6583:       != NULL) {",
          "6584:    if (strstr(accept_encoding, \"gzip\") != NULL) {",
          "6585:     mg_snprintf(conn,",
          "6586:                 &truncated,",
          "6587:                 gz_path,",
          "6588:                 sizeof(gz_path),",
          "6589:                 \"%s.gz\",",
          "6590:                 filename);",
          "6592:     if (truncated) {",
          "6593:      goto interpret_cleanup;",
          "6594:     }",
          "6596:     if (mg_stat(conn, gz_path, filestat)) {",
          "6597:      if (filestat) {",
          "6598:       filestat->is_gzipped = 1;",
          "6600:      }",
          "6602:      return;",
          "6610:   tmp_str_len = strlen(filename);",
          "6611:   tmp_str = mg_malloc_ctx(tmp_str_len + PATH_MAX + 1, conn->ctx);",
          "6612:   if (!tmp_str) {",
          "6614:    goto interpret_cleanup;",
          "6615:   }",
          "6616:   memcpy(tmp_str, filename, tmp_str_len + 1);",
          "6618:   sep_pos = tmp_str_len;",
          "6619:   while (sep_pos > 0) {",
          "6620:    sep_pos--;",
          "6621:    if (tmp_str[sep_pos] == '/') {",
          "6622:     int is_script = 0, does_exist = 0;",
          "6624:     tmp_str[sep_pos] = 0;",
          "6625:     if (tmp_str[0]) {",
          "6626:      is_script = extention_matches_script(conn, tmp_str);",
          "6627:      does_exist = mg_stat(conn, tmp_str, filestat);",
          "6628:     }",
          "6630:     if (does_exist && is_script) {",
          "6632:      memmove(filename + sep_pos + 2,",
          "6633:              filename + sep_pos + 1,",
          "6634:              strlen(filename + sep_pos + 1) + 1);",
          "6636:      filename[sep_pos + 1] = '/';",
          "6641:     if (substitute_index_file(",
          "6642:             conn, tmp_str, tmp_str_len + PATH_MAX, filestat)) {",
          "6644:      if (extention_matches_script(conn, tmp_str)) {",
          "6647:       char *tmp_str2 = mg_strdup(filename + sep_pos + 1);",
          "6648:       mg_snprintf(conn,",
          "6649:                   &truncated,",
          "6650:                   filename,",
          "6651:                   filename_buf_len,",
          "6652:                   \"%s//%s\",",
          "6653:                   tmp_str,",
          "6654:                   tmp_str2);",
          "6655:       mg_free(tmp_str2);",
          "6657:       if (truncated) {",
          "6658:        mg_free(tmp_str);",
          "6659:        goto interpret_cleanup;",
          "6660:       }",
          "6661:       sep_pos = strlen(tmp_str);",
          "6662:       filename[sep_pos] = 0;",
          "6663:       conn->path_info = filename + sep_pos + 1;",
          "6666:       break;",
          "6667:      } else {",
          "6669:       filename[sep_pos] = 0;",
          "6670:       conn->path_info = 0;",
          "6673:       break;",
          "6674:      }",
          "6675:     }",
          "6677:     tmp_str[sep_pos] = '/';",
          "6678:    }",
          "6681:   mg_free(tmp_str);",
          "6685:   return;",
          "6689:  interpret_cleanup:",
          "6690:   memset(filestat, 0, sizeof(*filestat));",
          "6697:  }",
          "6704:  static int get_http_header_len(const char *buf, int buflen)",
          "6705:  {",
          "6706:   int i;",
          "6707:   for (i = 0; i < buflen; i++) {",
          "6709:    const unsigned char c = ((const unsigned char *)buf)[i];",
          "6711:    if ((c < 128) && ((char)c != '\\r') && ((char)c != '\\n')",
          "6712:        && !isprint(c)) {",
          "6714:     return -1;",
          "6715:    }",
          "6717:    if (i < buflen - 1) {",
          "6718:     if ((buf[i] == '\\n') && (buf[i + 1] == '\\n')) {",
          "6723:      return i + 2;",
          "6724:     }",
          "6727:    if (i < buflen - 3) {",
          "6728:     if ((buf[i] == '\\r') && (buf[i + 1] == '\\n')",
          "6729:         && (buf[i + 2] == '\\r') && (buf[i + 3] == '\\n')) {",
          "6731:      return i + 4;",
          "6732:     }",
          "6736:   return 0;",
          "6737:  }",
          "6742:  static int get_month_index(const char *s)",
          "6743:  {",
          "6744:   size_t i;",
          "6746:   for (i = 0; i < ARRAY_SIZE(month_names); i++) {",
          "6747:    if (!strcmp(s, month_names[i])) {",
          "6748:     return (int)i;",
          "6749:    }",
          "6752:   return -1;",
          "6753:  }",
          "6757:  static time_t parse_date_string(const char *datetime)",
          "6758:  {",
          "6759:   char month_str[32] = {0};",
          "6760:   int second, minute, hour, day, month, year;",
          "6761:   time_t result = (time_t)0;",
          "6762:   struct tm tm;",
          "6764:   if ((sscanf(datetime,",
          "6765:               \"%d/%3s/%d %d:%d:%d\",",
          "6766:               &day,",
          "6767:               month_str,",
          "6768:               &year,",
          "6769:               &hour,",
          "6770:               &minute,",
          "6771:               &second) == 6) || (sscanf(datetime,",
          "6772:                                         \"%d %3s %d %d:%d:%d\",",
          "6773:                                         &day,",
          "6774:                                         month_str,",
          "6775:                                         &year,",
          "6776:                                         &hour,",
          "6777:                                         &minute,",
          "6778:                                         &second) == 6)",
          "6779:       || (sscanf(datetime,",
          "6780:                  \"%*3s, %d %3s %d %d:%d:%d\",",
          "6781:                  &day,",
          "6782:                  month_str,",
          "6783:                  &year,",
          "6784:                  &hour,",
          "6785:                  &minute,",
          "6786:                  &second) == 6) || (sscanf(datetime,",
          "6787:                                            \"%d-%3s-%d %d:%d:%d\",",
          "6788:                                            &day,",
          "6789:                                            month_str,",
          "6790:                                            &year,",
          "6791:                                            &hour,",
          "6792:                                            &minute,",
          "6793:                                            &second) == 6)) {",
          "6794:    month = get_month_index(month_str);",
          "6795:    if ((month >= 0) && (year >= 1970)) {",
          "6796:     memset(&tm, 0, sizeof(tm));",
          "6797:     tm.tm_year = year - 1900;",
          "6798:     tm.tm_mon = month;",
          "6799:     tm.tm_mday = day;",
          "6800:     tm.tm_hour = hour;",
          "6801:     tm.tm_min = minute;",
          "6802:     tm.tm_sec = second;",
          "6803:     result = timegm(&tm);",
          "6804:    }",
          "6807:   return result;",
          "6808:  }",
          "6814:  static void remove_double_dots_and_double_slashes(char *s)",
          "6815:  {",
          "6816:   char *p = s;",
          "6818:   while ((s[0] == '.') && (s[1] == '.')) {",
          "6819:    s++;",
          "6820:   }",
          "6822:   while (*s != '\\0') {",
          "6824:    if ((s[-1] == '/') || (s[-1] == '\\\\')) {",
          "6826:     while (s[0] != '\\0') {",
          "6827:      if ((s[0] == '/') || (s[0] == '\\\\')) {",
          "6828:       s++;",
          "6829:      } else if ((s[0] == '.') && (s[1] == '.')) {",
          "6830:       s += 2;",
          "6831:      } else {",
          "6832:       break;",
          "6833:      }",
          "6838:  }",
          "6841:  static const struct {",
          "6842:   const char *extension;",
          "6843:   size_t ext_len;",
          "6844:   const char *mime_type;",
          "6845:  } builtin_mime_types[] = {",
          "6849:      {\".doc\", 4, \"application/msword\"},",
          "6850:      {\".eps\", 4, \"application/postscript\"},",
          "6851:      {\".exe\", 4, \"application/octet-stream\"},",
          "6852:      {\".js\", 3, \"application/javascript\"},",
          "6853:      {\".json\", 5, \"application/json\"},",
          "6854:      {\".pdf\", 4, \"application/pdf\"},",
          "6855:      {\".ps\", 3, \"application/postscript\"},",
          "6856:      {\".rtf\", 4, \"application/rtf\"},",
          "6857:      {\".xhtml\", 6, \"application/xhtml+xml\"},",
          "6858:      {\".xsl\", 4, \"application/xml\"},",
          "6859:      {\".xslt\", 5, \"application/xml\"},",
          "6862:      {\".ttf\", 4, \"application/font-sfnt\"},",
          "6863:      {\".cff\", 4, \"application/font-sfnt\"},",
          "6864:      {\".otf\", 4, \"application/font-sfnt\"},",
          "6865:      {\".aat\", 4, \"application/font-sfnt\"},",
          "6866:      {\".sil\", 4, \"application/font-sfnt\"},",
          "6867:      {\".pfr\", 4, \"application/font-tdpfr\"},",
          "6868:      {\".woff\", 5, \"application/font-woff\"},",
          "6871:      {\".mp3\", 4, \"audio/mpeg\"},",
          "6872:      {\".oga\", 4, \"audio/ogg\"},",
          "6873:      {\".ogg\", 4, \"audio/ogg\"},",
          "6876:      {\".gif\", 4, \"image/gif\"},",
          "6877:      {\".ief\", 4, \"image/ief\"},",
          "6878:      {\".jpeg\", 5, \"image/jpeg\"},",
          "6879:      {\".jpg\", 4, \"image/jpeg\"},",
          "6880:      {\".jpm\", 4, \"image/jpm\"},",
          "6881:      {\".jpx\", 4, \"image/jpx\"},",
          "6882:      {\".png\", 4, \"image/png\"},",
          "6883:      {\".svg\", 4, \"image/svg+xml\"},",
          "6884:      {\".tif\", 4, \"image/tiff\"},",
          "6885:      {\".tiff\", 5, \"image/tiff\"},",
          "6888:      {\".wrl\", 4, \"model/vrml\"},",
          "6891:      {\".css\", 4, \"text/css\"},",
          "6892:      {\".csv\", 4, \"text/csv\"},",
          "6893:      {\".htm\", 4, \"text/html\"},",
          "6894:      {\".html\", 5, \"text/html\"},",
          "6895:      {\".sgm\", 4, \"text/sgml\"},",
          "6896:      {\".shtm\", 5, \"text/html\"},",
          "6897:      {\".shtml\", 6, \"text/html\"},",
          "6898:      {\".txt\", 4, \"text/plain\"},",
          "6899:      {\".xml\", 4, \"text/xml\"},",
          "6902:      {\".mov\", 4, \"video/quicktime\"},",
          "6903:      {\".mp4\", 4, \"video/mp4\"},",
          "6904:      {\".mpeg\", 5, \"video/mpeg\"},",
          "6905:      {\".mpg\", 4, \"video/mpeg\"},",
          "6906:      {\".ogv\", 4, \"video/ogg\"},",
          "6907:      {\".qt\", 3, \"video/quicktime\"},",
          "6912:      {\".arj\", 4, \"application/x-arj-compressed\"},",
          "6913:      {\".gz\", 3, \"application/x-gunzip\"},",
          "6914:      {\".rar\", 4, \"application/x-arj-compressed\"},",
          "6915:      {\".swf\", 4, \"application/x-shockwave-flash\"},",
          "6916:      {\".tar\", 4, \"application/x-tar\"},",
          "6917:      {\".tgz\", 4, \"application/x-tar-gz\"},",
          "6918:      {\".torrent\", 8, \"application/x-bittorrent\"},",
          "6919:      {\".ppt\", 4, \"application/x-mspowerpoint\"},",
          "6920:      {\".xls\", 4, \"application/x-msexcel\"},",
          "6921:      {\".zip\", 4, \"application/x-zip-compressed\"},",
          "6922:      {\".aac\",",
          "6923:       4,",
          "6925:      {\".aif\", 4, \"audio/x-aif\"},",
          "6926:      {\".m3u\", 4, \"audio/x-mpegurl\"},",
          "6927:      {\".mid\", 4, \"audio/x-midi\"},",
          "6928:      {\".ra\", 3, \"audio/x-pn-realaudio\"},",
          "6929:      {\".ram\", 4, \"audio/x-pn-realaudio\"},",
          "6930:      {\".wav\", 4, \"audio/x-wav\"},",
          "6931:      {\".bmp\", 4, \"image/bmp\"},",
          "6932:      {\".ico\", 4, \"image/x-icon\"},",
          "6933:      {\".pct\", 4, \"image/x-pct\"},",
          "6934:      {\".pict\", 5, \"image/pict\"},",
          "6935:      {\".rgb\", 4, \"image/x-rgb\"},",
          "6937:      {\".asf\", 4, \"video/x-ms-asf\"},",
          "6938:      {\".avi\", 4, \"video/x-msvideo\"},",
          "6939:      {\".m4v\", 4, \"video/x-m4v\"},",
          "6940:      {NULL, 0, NULL}};",
          "6943:  const char *mg_get_builtin_mime_type(const char *path)",
          "6944:  {",
          "6945:   const char *ext;",
          "6946:   size_t i, path_len;",
          "6948:   path_len = strlen(path);",
          "6950:   for (i = 0; builtin_mime_types[i].extension != NULL; i++) {",
          "6951:    ext = path + (path_len - builtin_mime_types[i].ext_len);",
          "6952:    if ((path_len > builtin_mime_types[i].ext_len)",
          "6953:        && (mg_strcasecmp(ext, builtin_mime_types[i].extension) == 0)) {",
          "6954:     return builtin_mime_types[i].mime_type;",
          "6955:    }",
          "6958:   return \"text/plain\";",
          "6959:  }",
          "6964:  static void get_mime_type(struct mg_context * ctx,",
          "6965:                            const char *path,",
          "6966:                            struct vec *vec)",
          "6967:  {",
          "6968:   struct vec ext_vec, mime_vec;",
          "6969:   const char *list, *ext;",
          "6970:   size_t path_len;",
          "6972:   path_len = strlen(path);",
          "6974:   if ((ctx == NULL) || (vec == NULL)) {",
          "6975:    if (vec != NULL) {",
          "6976:     memset(vec, '\\0', sizeof(struct vec));",
          "6977:    }",
          "6978:    return;",
          "6983:   list = ctx->config[EXTRA_MIME_TYPES];",
          "6984:   while ((list = next_option(list, &ext_vec, &mime_vec)) != NULL) {",
          "6986:    ext = path + path_len - ext_vec.len;",
          "6987:    if (mg_strncasecmp(ext, ext_vec.ptr, ext_vec.len) == 0) {",
          "6989:     return;",
          "6990:    }",
          "6993:   vec->ptr = mg_get_builtin_mime_type(path);",
          "6994:   vec->len = strlen(vec->ptr);",
          "6995:  }",
          "7000:  static void bin2str(char *to, const unsigned char *p, size_t len)",
          "7001:  {",
          "7002:   static const char *hex = \"0123456789abcdef\";",
          "7004:   for (; len--; p++) {",
          "7007:   }",
          "7014:  char *mg_md5(char buf[33], ...)",
          "7015:  {",
          "7016:   md5_byte_t hash[16];",
          "7017:   const char *p;",
          "7018:   va_list ap;",
          "7019:   md5_state_t ctx;",
          "7021:   md5_init(&ctx);",
          "7023:   va_start(ap, buf);",
          "7024:   while ((p = va_arg(ap, const char *)) != NULL) {",
          "7025:    md5_append(&ctx, (const md5_byte_t *)p, strlen(p));",
          "7026:   }",
          "7027:   va_end(ap);",
          "7029:   md5_finish(&ctx, hash);",
          "7030:   bin2str(buf, hash, sizeof(hash));",
          "7031:   return buf;",
          "7032:  }",
          "7036:  static int check_password(const char *method,",
          "7037:                            const char *ha1,",
          "7038:                            const char *uri,",
          "7039:                            const char *nonce,",
          "7040:                            const char *nc,",
          "7041:                            const char *cnonce,",
          "7042:                            const char *qop,",
          "7043:                            const char *response)",
          "7044:  {",
          "7045:   char ha2[32 + 1], expected_response[32 + 1];",
          "7048:   if ((method == NULL) || (nonce == NULL) || (nc == NULL)",
          "7049:       || (cnonce == NULL) || (qop == NULL) || (response == NULL)) {",
          "7050:    return 0;",
          "7051:   }",
          "7054:   if (strlen(response) != 32) {",
          "7055:    return 0;",
          "7056:   }",
          "7058:   mg_md5(ha2, method, \":\", uri, NULL);",
          "7059:   mg_md5(expected_response,",
          "7060:          ha1,",
          "7061:          \":\",",
          "7062:          nonce,",
          "7063:          \":\",",
          "7064:          nc,",
          "7065:          \":\",",
          "7066:          cnonce,",
          "7067:          \":\",",
          "7068:          qop,",
          "7069:          \":\",",
          "7070:          ha2,",
          "7071:          NULL);",
          "7073:   return mg_strcasecmp(response, expected_response) == 0;",
          "7074:  }",
          "7079:  static void open_auth_file(struct mg_connection * conn,",
          "7080:                             const char *path,",
          "7081:                             struct mg_file *filep)",
          "7082:  {",
          "7083:   if ((conn != NULL) && (conn->ctx != NULL)) {",
          "7084:    char name[PATH_MAX];",
          "7085:    const char *p, *e,",
          "7087:    int truncated;",
          "7089:    if (gpass != NULL) {",
          "7091:     if (!mg_fopen(conn, gpass, MG_FOPEN_MODE_READ, filep)) {",
          "7094:      mg_cry(conn, \"fopen(%s): %s\", gpass, strerror(ERRNO));",
          "7096:     }",
          "7102:    } else if (mg_stat(conn, path, &filep->stat)",
          "7103:               && filep->stat.is_directory) {",
          "7104:     mg_snprintf(conn,",
          "7105:                 &truncated,",
          "7106:                 name,",
          "7107:                 sizeof(name),",
          "7108:                 \"%s/%s\",",
          "7109:                 path,",
          "7110:                 PASSWORDS_FILE_NAME);",
          "7112:     if (truncated",
          "7113:         || !mg_fopen(conn, name, MG_FOPEN_MODE_READ, filep)) {",
          "7118:      DEBUG_TRACE(\"fopen(%s): %s\", name, strerror(ERRNO));",
          "7121:    } else {",
          "7123:     for (p = path, e = p + strlen(p) - 1; e > p; e--) {",
          "7124:      if (e[0] == '/') {",
          "7125:       break;",
          "7126:      }",
          "7127:     }",
          "7128:     mg_snprintf(conn,",
          "7129:                 &truncated,",
          "7130:                 name,",
          "7131:                 sizeof(name),",
          "7132:                 \"%.*s/%s\",",
          "7133:                 (int)(e - p),",
          "7134:                 p,",
          "7135:                 PASSWORDS_FILE_NAME);",
          "7137:     if (truncated",
          "7138:         || !mg_fopen(conn, name, MG_FOPEN_MODE_READ, filep)) {",
          "7143:      DEBUG_TRACE(\"fopen(%s): %s\", name, strerror(ERRNO));",
          "7145:     }",
          "7152:  struct ah {",
          "7153:   char *user, *uri, *cnonce, *response, *qop, *nc, *nonce;",
          "7154:  };",
          "7158:  static int parse_auth_header(struct mg_connection * conn,",
          "7159:                               char *buf,",
          "7160:                               size_t buf_size,",
          "7161:                               struct ah *ah)",
          "7162:  {",
          "7163:   char *name, *value, *s;",
          "7164:   const char *auth_header;",
          "7165:   uint64_t nonce;",
          "7167:   if (!ah || !conn) {",
          "7168:    return 0;",
          "7169:   }",
          "7171:   (void)memset(ah, 0, sizeof(*ah));",
          "7172:   if (((auth_header = mg_get_header(conn, \"Authorization\")) == NULL)",
          "7173:       || mg_strncasecmp(auth_header, \"Digest \", 7) != 0) {",
          "7174:    return 0;",
          "7175:   }",
          "7178:   (void)mg_strlcpy(buf, auth_header + 7, buf_size);",
          "7179:   s = buf;",
          "7182:   for (;;) {",
          "7184:    while (isspace(*(unsigned char *)s)) {",
          "7187:    name = skip_quoted(&s, \"=\", \" \", 0);",
          "7190:    if (s[0] == '\\\"') {",
          "7191:     s++;",
          "7192:     value = skip_quoted(&s, \"\\\"\", \" \", '\\\\');",
          "7193:     if (s[0] == ',') {",
          "7194:      s++;",
          "7195:     }",
          "7196:    } else {",
          "7197:     value =",
          "7198:         skip_quoted(&s, \", \", \" \", 0); /* IE uses commas, FF uses",
          "7200:    }",
          "7201:    if (*name == '\\0') {",
          "7202:     break;",
          "7203:    }",
          "7205:    if (!strcmp(name, \"username\")) {",
          "7206:     ah->user = value;",
          "7207:    } else if (!strcmp(name, \"cnonce\")) {",
          "7208:     ah->cnonce = value;",
          "7209:    } else if (!strcmp(name, \"response\")) {",
          "7210:     ah->response = value;",
          "7211:    } else if (!strcmp(name, \"uri\")) {",
          "7212:     ah->uri = value;",
          "7213:    } else if (!strcmp(name, \"qop\")) {",
          "7214:     ah->qop = value;",
          "7215:    } else if (!strcmp(name, \"nc\")) {",
          "7216:     ah->nc = value;",
          "7217:    } else if (!strcmp(name, \"nonce\")) {",
          "7218:     ah->nonce = value;",
          "7219:    }",
          "7224:   if (ah->nonce == NULL) {",
          "7225:    return 0;",
          "7226:   }",
          "7227:   s = NULL;",
          "7228:   nonce = strtoull(ah->nonce, &s, 10);",
          "7229:   if ((s == NULL) || (*s != 0)) {",
          "7230:    return 0;",
          "7231:   }",
          "7234:   nonce ^= conn->ctx->auth_nonce_mask;",
          "7244:   if (nonce < (uint64_t)conn->ctx->start_time) {",
          "7247:    return 0;",
          "7248:   }",
          "7251:   if (nonce",
          "7252:       >= ((uint64_t)conn->ctx->start_time + conn->ctx->nonce_count)) {",
          "7253:    return 0;",
          "7254:   }",
          "7260:   if (ah->user != NULL) {",
          "7261:    conn->request_info.remote_user = mg_strdup(ah->user);",
          "7262:   } else {",
          "7263:    return 0;",
          "7264:   }",
          "7266:   return 1;",
          "7267:  }",
          "7270:  static const char *mg_fgets(char *buf,",
          "7271:                              size_t size,",
          "7272:                              struct mg_file *filep,",
          "7273:                              char **p)",
          "7274:  {",
          "7275:   const char *eof;",
          "7276:   size_t len;",
          "7277:   const char *memend;",
          "7279:   if (!filep) {",
          "7280:    return NULL;",
          "7281:   }",
          "7283:   if ((filep->access.membuf != NULL) && (*p != NULL)) {",
          "7284:    memend = (const char *)&filep->access.membuf[filep->stat.size];",
          "7286:    eof = (char *)memchr(*p, '\\n', (size_t)(memend - *p));",
          "7287:    if (eof != NULL) {",
          "7289:    } else {",
          "7291:    }",
          "7292:    len = ((size_t)(eof - *p) > (size - 1)) ? (size - 1)",
          "7293:                                            : (size_t)(eof - *p);",
          "7294:    memcpy(buf, *p, len);",
          "7295:    buf[len] = '\\0';",
          "7297:    return len ? eof : NULL;",
          "7298:   } else if (filep->access.fp != NULL) {",
          "7299:    return fgets(buf, (int)size, filep->access.fp);",
          "7301:    return NULL;",
          "7302:   }",
          "",
          "---------------",
          "--- Hunk 42 ---",
          "[Context before]",
          "7316: #error Bad INITIAL_DEPTH for recursion, set to at least 1",
          "7317: #endif",
          "7358:   }",
          "7367:     continue;",
          "7383:      }",
          "7389:     }",
          "7390:     continue;",
          "7391:    }",
          "7419:   }",
          "7434:  }",
          "7456:  }",
          "7495:    }",
          "7497:   }",
          "7546:  }",
          "7550: #if !defined(NO_FILES)",
          "7563:   }",
          "7566:  }",
          "7569: #endif",
          "7608:    return 0;",
          "7609:   }",
          "7616:    return 0;",
          "7617:   }",
          "7650:   }",
          "7659:    }",
          "7662:   }",
          "7718:   }",
          "7766: #if !defined(NO_SSL)",
          "7767: #if !defined(NO_SSL_DL)",
          "7768: #ifdef OPENSSL_API_1_1",
          "7778: #else",
          "7790: #else",
          "",
          "[Removed Lines]",
          "7319: struct read_auth_file_struct {",
          "7320:  struct mg_connection *conn;",
          "7321:  struct ah ah;",
          "7322:  char *domain;",
          "7323:  char buf[256 + 256 + 40];",
          "7324:  char *f_user;",
          "7325:  char *f_domain;",
          "7326:  char *f_ha1;",
          "7327: };",
          "7330: static int",
          "7331: read_auth_file(struct mg_file *filep,",
          "7332:                struct read_auth_file_struct *workdata,",
          "7333:                int depth)",
          "7334: {",
          "7335:  char *p;",
          "7336:  int is_authorized = 0;",
          "7337:  struct mg_file fp;",
          "7338:  size_t l;",
          "7340:  if (!filep || !workdata || (0 == depth)) {",
          "7341:   return 0;",
          "7342:  }",
          "7345:  p = (char *)filep->access.membuf;",
          "7346:  while (mg_fgets(workdata->buf, sizeof(workdata->buf), filep, &p) != NULL) {",
          "7347:   l = strlen(workdata->buf);",
          "7348:   while (l > 0) {",
          "7349:    if (isspace(workdata->buf[l - 1])",
          "7350:        || iscntrl(workdata->buf[l - 1])) {",
          "7351:     l--;",
          "7352:     workdata->buf[l] = 0;",
          "7353:    } else",
          "7354:     break;",
          "7355:   }",
          "7356:   if (l < 1) {",
          "7357:    continue;",
          "7360:   workdata->f_user = workdata->buf;",
          "7362:   if (workdata->f_user[0] == ':') {",
          "7365:    if (workdata->f_user[1] == '#') {",
          "7368:    } else if (!strncmp(workdata->f_user + 1, \"include=\", 8)) {",
          "7369:     if (mg_fopen(workdata->conn,",
          "7370:                  workdata->f_user + 9,",
          "7371:                  MG_FOPEN_MODE_READ,",
          "7372:                  &fp)) {",
          "7373:      is_authorized = read_auth_file(&fp, workdata, depth - 1);",
          "7374:      (void)mg_fclose(",
          "7381:      if (is_authorized) {",
          "7382:       return is_authorized;",
          "7384:     } else {",
          "7385:      mg_cry(workdata->conn,",
          "7386:             \"%s: cannot open authorization file: %s\",",
          "7387:             __func__,",
          "7388:             workdata->buf);",
          "7394:    mg_cry(workdata->conn,",
          "7395:           \"%s: syntax error in authorization file: %s\",",
          "7396:           __func__,",
          "7397:           workdata->buf);",
          "7398:    continue;",
          "7399:   }",
          "7401:   workdata->f_domain = strchr(workdata->f_user, ':');",
          "7402:   if (workdata->f_domain == NULL) {",
          "7403:    mg_cry(workdata->conn,",
          "7404:           \"%s: syntax error in authorization file: %s\",",
          "7405:           __func__,",
          "7406:           workdata->buf);",
          "7407:    continue;",
          "7408:   }",
          "7410:   (workdata->f_domain)++;",
          "7412:   workdata->f_ha1 = strchr(workdata->f_domain, ':');",
          "7413:   if (workdata->f_ha1 == NULL) {",
          "7414:    mg_cry(workdata->conn,",
          "7415:           \"%s: syntax error in authorization file: %s\",",
          "7416:           __func__,",
          "7417:           workdata->buf);",
          "7418:    continue;",
          "7421:   (workdata->f_ha1)++;",
          "7423:   if (!strcmp(workdata->ah.user, workdata->f_user)",
          "7424:       && !strcmp(workdata->domain, workdata->f_domain)) {",
          "7425:    return check_password(workdata->conn->request_info.request_method,",
          "7426:                          workdata->f_ha1,",
          "7427:                          workdata->ah.uri,",
          "7428:                          workdata->ah.nonce,",
          "7429:                          workdata->ah.nc,",
          "7430:                          workdata->ah.cnonce,",
          "7431:                          workdata->ah.qop,",
          "7432:                          workdata->ah.response);",
          "7433:   }",
          "7436:  return is_authorized;",
          "7437: }",
          "7441: static int",
          "7442: authorize(struct mg_connection *conn, struct mg_file *filep)",
          "7443: {",
          "7444:  struct read_auth_file_struct workdata;",
          "7445:  char buf[MG_BUF_LEN];",
          "7447:  if (!conn || !conn->ctx) {",
          "7448:   return 0;",
          "7449:  }",
          "7451:  memset(&workdata, 0, sizeof(workdata));",
          "7452:  workdata.conn = conn;",
          "7454:  if (!parse_auth_header(conn, buf, sizeof(buf), &workdata.ah)) {",
          "7455:   return 0;",
          "7457:  workdata.domain = conn->ctx->config[AUTHENTICATION_DOMAIN];",
          "7459:  return read_auth_file(filep, &workdata, INITIAL_DEPTH);",
          "7460: }",
          "7464: static int",
          "7465: check_authorization(struct mg_connection *conn, const char *path)",
          "7466: {",
          "7467:  char fname[PATH_MAX];",
          "7468:  struct vec uri_vec, filename_vec;",
          "7469:  const char *list;",
          "7470:  struct mg_file file = STRUCT_FILE_INITIALIZER;",
          "7471:  int authorized = 1, truncated;",
          "7473:  if (!conn || !conn->ctx) {",
          "7474:   return 0;",
          "7475:  }",
          "7477:  list = conn->ctx->config[PROTECT_URI];",
          "7478:  while ((list = next_option(list, &uri_vec, &filename_vec)) != NULL) {",
          "7479:   if (!memcmp(conn->request_info.local_uri, uri_vec.ptr, uri_vec.len)) {",
          "7480:    mg_snprintf(conn,",
          "7481:                &truncated,",
          "7482:                fname,",
          "7483:                sizeof(fname),",
          "7484:                \"%.*s\",",
          "7485:                (int)filename_vec.len,",
          "7486:                filename_vec.ptr);",
          "7488:    if (truncated",
          "7489:        || !mg_fopen(conn, fname, MG_FOPEN_MODE_READ, &file)) {",
          "7490:     mg_cry(conn,",
          "7491:            \"%s: cannot open %s: %s\",",
          "7492:            __func__,",
          "7493:            fname,",
          "7494:            strerror(errno));",
          "7496:    break;",
          "7498:  }",
          "7500:  if (!is_file_opened(&file.access)) {",
          "7501:   open_auth_file(conn, path, &file);",
          "7502:  }",
          "7504:  if (is_file_opened(&file.access)) {",
          "7505:   authorized = authorize(conn, &file);",
          "7507:  }",
          "7509:  return authorized;",
          "7510: }",
          "7513: static void",
          "7514: send_authorization_request(struct mg_connection *conn)",
          "7515: {",
          "7516:  char date[64];",
          "7517:  time_t curtime = time(NULL);",
          "7519:  if (conn && conn->ctx) {",
          "7520:   uint64_t nonce = (uint64_t)(conn->ctx->start_time);",
          "7522:   (void)pthread_mutex_lock(&conn->ctx->nonce_mutex);",
          "7523:   nonce += conn->ctx->nonce_count;",
          "7524:   ++conn->ctx->nonce_count;",
          "7525:   (void)pthread_mutex_unlock(&conn->ctx->nonce_mutex);",
          "7527:   nonce ^= conn->ctx->auth_nonce_mask;",
          "7528:   conn->status_code = 401;",
          "7529:   conn->must_close = 1;",
          "7531:   gmt_time_string(date, sizeof(date), &curtime);",
          "7533:   mg_printf(conn, \"HTTP/1.1 401 Unauthorized\\r\\n\");",
          "7534:   send_no_cache_header(conn);",
          "7535:   send_additional_header(conn);",
          "7536:   mg_printf(conn,",
          "7537:             \"Date: %s\\r\\n\"",
          "7538:             \"Connection: %s\\r\\n\"",
          "7539:             \"Content-Length: 0\\r\\n\"",
          "7540:             \"WWW-Authenticate: Digest qop=\\\"auth\\\", realm=\\\"%s\\\", \"",
          "7541:             \"nonce=\\\"%\" UINT64_FMT \"\\\"\\r\\n\\r\\n\",",
          "7542:             date,",
          "7543:             suggest_connection_header(conn),",
          "7544:             conn->ctx->config[AUTHENTICATION_DOMAIN],",
          "7545:             nonce);",
          "7547: }",
          "7551: static int",
          "7552: is_authorized_for_put(struct mg_connection *conn)",
          "7553: {",
          "7554:  if (conn) {",
          "7555:   struct mg_file file = STRUCT_FILE_INITIALIZER;",
          "7556:   const char *passfile = conn->ctx->config[PUT_DELETE_PASSWORDS_FILE];",
          "7557:   int ret = 0;",
          "7559:   if (passfile != NULL",
          "7560:       && mg_fopen(conn, passfile, MG_FOPEN_MODE_READ, &file)) {",
          "7561:    ret = authorize(conn, &file);",
          "7565:   return ret;",
          "7567:  return 0;",
          "7568: }",
          "7572: int",
          "7573: mg_modify_passwords_file(const char *fname,",
          "7574:                          const char *domain,",
          "7575:                          const char *user,",
          "7576:                          const char *pass)",
          "7577: {",
          "7578:  int found, i;",
          "7579:  char line[512], u[512] = \"\", d[512] = \"\", ha1[33], tmp[PATH_MAX + 8];",
          "7580:  FILE *fp, *fp2;",
          "7582:  found = 0;",
          "7583:  fp = fp2 = NULL;",
          "7586:  if ((pass != NULL) && (pass[0] == '\\0')) {",
          "7587:   pass = NULL;",
          "7588:  }",
          "7591:  if ((fname == NULL) || (domain == NULL) || (user == NULL)) {",
          "7592:   return 0;",
          "7593:  }",
          "7597:  if (strchr(user, ':') != NULL) {",
          "7598:   return 0;",
          "7599:  }",
          "7600:  if (strchr(domain, ':') != NULL) {",
          "7601:   return 0;",
          "7602:  }",
          "7606:  for (i = 0; ((i < 255) && (user[i] != 0)); i++) {",
          "7607:   if (iscntrl(user[i])) {",
          "7610:  }",
          "7611:  if (user[i]) {",
          "7612:   return 0;",
          "7613:  }",
          "7614:  for (i = 0; ((i < 255) && (domain[i] != 0)); i++) {",
          "7615:   if (iscntrl(domain[i])) {",
          "7618:  }",
          "7619:  if (domain[i]) {",
          "7620:   return 0;",
          "7621:  }",
          "7624:  if ((strlen(fname) + 4) >= PATH_MAX) {",
          "7625:   return 0;",
          "7626:  }",
          "7629:  strcpy(tmp, fname);",
          "7630:  strcat(tmp, \".tmp\");",
          "7634:  if ((fp = fopen(fname, \"a+\")) != NULL) {",
          "7635:   (void)fclose(fp);",
          "7636:  }",
          "7639:  if ((fp = fopen(fname, \"r\")) == NULL) {",
          "7640:   return 0;",
          "7641:  } else if ((fp2 = fopen(tmp, \"w+\")) == NULL) {",
          "7642:   fclose(fp);",
          "7643:   return 0;",
          "7644:  }",
          "7647:  while (fgets(line, sizeof(line), fp) != NULL) {",
          "7648:   if (sscanf(line, \"%255[^:]:%255[^:]:%*s\", u, d) != 2) {",
          "7649:    continue;",
          "7651:   u[255] = 0;",
          "7652:   d[255] = 0;",
          "7654:   if (!strcmp(u, user) && !strcmp(d, domain)) {",
          "7655:    found++;",
          "7656:    if (pass != NULL) {",
          "7657:     mg_md5(ha1, user, \":\", domain, \":\", pass, NULL);",
          "7658:     fprintf(fp2, \"%s:%s:%s\\n\", user, domain, ha1);",
          "7660:   } else {",
          "7661:    fprintf(fp2, \"%s\", line);",
          "7663:  }",
          "7666:  if (!found && (pass != NULL)) {",
          "7667:   mg_md5(ha1, user, \":\", domain, \":\", pass, NULL);",
          "7668:   fprintf(fp2, \"%s:%s:%s\\n\", user, domain, ha1);",
          "7669:  }",
          "7672:  fclose(fp);",
          "7673:  fclose(fp2);",
          "7676:  IGNORE_UNUSED_RESULT(remove(fname));",
          "7677:  IGNORE_UNUSED_RESULT(rename(tmp, fname));",
          "7679:  return 1;",
          "7680: }",
          "7683: static int",
          "7684: is_valid_port(unsigned long port)",
          "7685: {",
          "7686:  return (port <= 0xffff);",
          "7687: }",
          "7690: static int",
          "7691: mg_inet_pton(int af, const char *src, void *dst, size_t dstlen)",
          "7692: {",
          "7693:  struct addrinfo hints, *res, *ressave;",
          "7694:  int func_ret = 0;",
          "7695:  int gai_ret;",
          "7697:  memset(&hints, 0, sizeof(struct addrinfo));",
          "7698:  hints.ai_family = af;",
          "7700:  gai_ret = getaddrinfo(src, NULL, &hints, &res);",
          "7701:  if (gai_ret != 0) {",
          "7709:   return 0;",
          "7710:  }",
          "7712:  ressave = res;",
          "7714:  while (res) {",
          "7715:   if (dstlen >= (size_t)res->ai_addrlen) {",
          "7716:    memcpy(dst, res->ai_addr, res->ai_addrlen);",
          "7717:    func_ret = 1;",
          "7719:   res = res->ai_next;",
          "7720:  }",
          "7722:  freeaddrinfo(ressave);",
          "7723:  return func_ret;",
          "7724: }",
          "7727: static int",
          "7728: connect_socket(struct mg_context *ctx /* may be NULL */,",
          "7729:                const char *host,",
          "7730:                int port,",
          "7731:                int use_ssl,",
          "7732:                char *ebuf,",
          "7733:                size_t ebuf_len,",
          "7734:                SOCKET *sock /* output: socket, must not be NULL */,",
          "7736:                )",
          "7737: {",
          "7738:  int ip_ver = 0;",
          "7740:  memset(sa, 0, sizeof(*sa));",
          "7742:  if (ebuf_len > 0) {",
          "7744:  }",
          "7746:  if (host == NULL) {",
          "7747:   mg_snprintf(NULL,",
          "7749:               ebuf,",
          "7750:               ebuf_len,",
          "7751:               \"%s\",",
          "7752:               \"NULL host\");",
          "7753:   return 0;",
          "7754:  }",
          "7756:  if ((port <= 0) || !is_valid_port((unsigned)port)) {",
          "7757:   mg_snprintf(NULL,",
          "7759:               ebuf,",
          "7760:               ebuf_len,",
          "7761:               \"%s\",",
          "7762:               \"invalid port\");",
          "7763:   return 0;",
          "7764:  }",
          "7769:  if (use_ssl && (TLS_client_method == NULL)) {",
          "7770:   mg_snprintf(NULL,",
          "7772:               ebuf,",
          "7773:               ebuf_len,",
          "7774:               \"%s\",",
          "7775:               \"SSL is not initialized\");",
          "7776:   return 0;",
          "7777:  }",
          "7779:  if (use_ssl && (SSLv23_client_method == NULL)) {",
          "7780:   mg_snprintf(NULL,",
          "7782:               ebuf,",
          "7783:               ebuf_len,",
          "7784:               \"%s\",",
          "7785:               \"SSL is not initialized\");",
          "7786:   return 0;",
          "7787:  }",
          "",
          "[Added Lines]",
          "7316:  struct read_auth_file_struct {",
          "7317:   struct mg_connection *conn;",
          "7318:   struct ah ah;",
          "7319:   char *domain;",
          "7320:   char buf[256 + 256 + 40];",
          "7321:   char *f_user;",
          "7322:   char *f_domain;",
          "7323:   char *f_ha1;",
          "7324:  };",
          "7327:  static int read_auth_file(struct mg_file * filep,",
          "7328:                            struct read_auth_file_struct * workdata,",
          "7329:                            int depth)",
          "7330:  {",
          "7331:   char *p;",
          "7332:   int is_authorized = 0;",
          "7333:   struct mg_file fp;",
          "7334:   size_t l;",
          "7336:   if (!filep || !workdata || (0 == depth)) {",
          "7337:    return 0;",
          "7341:   p = (char *)filep->access.membuf;",
          "7342:   while (mg_fgets(workdata->buf, sizeof(workdata->buf), filep, &p)",
          "7343:          != NULL) {",
          "7344:    l = strlen(workdata->buf);",
          "7345:    while (l > 0) {",
          "7346:     if (isspace(workdata->buf[l - 1])",
          "7347:         || iscntrl(workdata->buf[l - 1])) {",
          "7348:      l--;",
          "7349:      workdata->buf[l] = 0;",
          "7350:     } else",
          "7351:      break;",
          "7352:    }",
          "7353:    if (l < 1) {",
          "7355:    }",
          "7357:    workdata->f_user = workdata->buf;",
          "7359:    if (workdata->f_user[0] == ':') {",
          "7363:     if (workdata->f_user[1] == '#') {",
          "7365:      continue;",
          "7366:     } else if (!strncmp(workdata->f_user + 1, \"include=\", 8)) {",
          "7367:      if (mg_fopen(workdata->conn,",
          "7368:                   workdata->f_user + 9,",
          "7369:                   MG_FOPEN_MODE_READ,",
          "7370:                   &fp)) {",
          "7371:       is_authorized =",
          "7372:           read_auth_file(&fp, workdata, depth - 1);",
          "7373:       (void)mg_fclose(",
          "7380:       if (is_authorized) {",
          "7381:        return is_authorized;",
          "7382:       }",
          "7383:      } else {",
          "7384:       mg_cry(workdata->conn,",
          "7385:              \"%s: cannot open authorization file: %s\",",
          "7386:              __func__,",
          "7387:              workdata->buf);",
          "7389:      continue;",
          "7393:     mg_cry(workdata->conn,",
          "7394:            \"%s: syntax error in authorization file: %s\",",
          "7395:            __func__,",
          "7396:            workdata->buf);",
          "7400:    workdata->f_domain = strchr(workdata->f_user, ':');",
          "7401:    if (workdata->f_domain == NULL) {",
          "7402:     mg_cry(workdata->conn,",
          "7403:            \"%s: syntax error in authorization file: %s\",",
          "7404:            __func__,",
          "7405:            workdata->buf);",
          "7406:     continue;",
          "7407:    }",
          "7409:    (workdata->f_domain)++;",
          "7411:    workdata->f_ha1 = strchr(workdata->f_domain, ':');",
          "7412:    if (workdata->f_ha1 == NULL) {",
          "7413:     mg_cry(workdata->conn,",
          "7414:            \"%s: syntax error in authorization file: %s\",",
          "7415:            __func__,",
          "7416:            workdata->buf);",
          "7417:     continue;",
          "7418:    }",
          "7420:    (workdata->f_ha1)++;",
          "7422:    if (!strcmp(workdata->ah.user, workdata->f_user)",
          "7423:        && !strcmp(workdata->domain, workdata->f_domain)) {",
          "7424:     return check_password(",
          "7425:         workdata->conn->request_info.request_method,",
          "7426:         workdata->f_ha1,",
          "7427:         workdata->ah.uri,",
          "7428:         workdata->ah.nonce,",
          "7429:         workdata->ah.nc,",
          "7430:         workdata->ah.cnonce,",
          "7431:         workdata->ah.qop,",
          "7432:         workdata->ah.response);",
          "7433:    }",
          "7436:   return is_authorized;",
          "7441:  static int authorize(struct mg_connection * conn, struct mg_file * filep)",
          "7442:  {",
          "7443:   struct read_auth_file_struct workdata;",
          "7444:   char buf[MG_BUF_LEN];",
          "7446:   if (!conn || !conn->ctx) {",
          "7447:    return 0;",
          "7448:   }",
          "7450:   memset(&workdata, 0, sizeof(workdata));",
          "7451:   workdata.conn = conn;",
          "7453:   if (!parse_auth_header(conn, buf, sizeof(buf), &workdata.ah)) {",
          "7454:    return 0;",
          "7455:   }",
          "7456:   workdata.domain = conn->ctx->config[AUTHENTICATION_DOMAIN];",
          "7458:   return read_auth_file(filep, &workdata, INITIAL_DEPTH);",
          "7463:  static int check_authorization(struct mg_connection * conn,",
          "7464:                                 const char *path)",
          "7465:  {",
          "7466:   char fname[PATH_MAX];",
          "7467:   struct vec uri_vec, filename_vec;",
          "7468:   const char *list;",
          "7469:   struct mg_file file = STRUCT_FILE_INITIALIZER;",
          "7470:   int authorized = 1, truncated;",
          "7472:   if (!conn || !conn->ctx) {",
          "7473:    return 0;",
          "7474:   }",
          "7476:   list = conn->ctx->config[PROTECT_URI];",
          "7477:   while ((list = next_option(list, &uri_vec, &filename_vec)) != NULL) {",
          "7478:    if (!memcmp(conn->request_info.local_uri,",
          "7479:                uri_vec.ptr,",
          "7480:                uri_vec.len)) {",
          "7481:     mg_snprintf(conn,",
          "7482:                 &truncated,",
          "7483:                 fname,",
          "7484:                 sizeof(fname),",
          "7485:                 \"%.*s\",",
          "7486:                 (int)filename_vec.len,",
          "7487:                 filename_vec.ptr);",
          "7489:     if (truncated",
          "7490:         || !mg_fopen(conn, fname, MG_FOPEN_MODE_READ, &file)) {",
          "7491:      mg_cry(conn,",
          "7492:             \"%s: cannot open %s: %s\",",
          "7493:             __func__,",
          "7494:             fname,",
          "7495:             strerror(errno));",
          "7496:     }",
          "7497:     break;",
          "7501:   if (!is_file_opened(&file.access)) {",
          "7502:    open_auth_file(conn, path, &file);",
          "7503:   }",
          "7505:   if (is_file_opened(&file.access)) {",
          "7506:    authorized = authorize(conn, &file);",
          "7508:   }",
          "7510:   return authorized;",
          "7511:  }",
          "7514:  static void send_authorization_request(struct mg_connection * conn)",
          "7515:  {",
          "7516:   char date[64];",
          "7517:   time_t curtime = time(NULL);",
          "7519:   if (conn && conn->ctx) {",
          "7520:    uint64_t nonce = (uint64_t)(conn->ctx->start_time);",
          "7522:    (void)pthread_mutex_lock(&conn->ctx->nonce_mutex);",
          "7523:    nonce += conn->ctx->nonce_count;",
          "7524:    ++conn->ctx->nonce_count;",
          "7525:    (void)pthread_mutex_unlock(&conn->ctx->nonce_mutex);",
          "7527:    nonce ^= conn->ctx->auth_nonce_mask;",
          "7528:    conn->status_code = 401;",
          "7529:    conn->must_close = 1;",
          "7531:    gmt_time_string(date, sizeof(date), &curtime);",
          "7533:    mg_printf(conn, \"HTTP/1.1 401 Unauthorized\\r\\n\");",
          "7534:    send_no_cache_header(conn);",
          "7535:    send_additional_header(conn);",
          "7536:    mg_printf(conn,",
          "7537:              \"Date: %s\\r\\n\"",
          "7538:              \"Connection: %s\\r\\n\"",
          "7539:              \"Content-Length: 0\\r\\n\"",
          "7540:              \"WWW-Authenticate: Digest qop=\\\"auth\\\", realm=\\\"%s\\\", \"",
          "7541:              \"nonce=\\\"%\" UINT64_FMT \"\\\"\\r\\n\\r\\n\",",
          "7542:              date,",
          "7543:              suggest_connection_header(conn),",
          "7544:              conn->ctx->config[AUTHENTICATION_DOMAIN],",
          "7545:              nonce);",
          "7546:   }",
          "7551:  static int is_authorized_for_put(struct mg_connection * conn)",
          "7552:  {",
          "7553:   if (conn) {",
          "7554:    struct mg_file file = STRUCT_FILE_INITIALIZER;",
          "7555:    const char *passfile = conn->ctx->config[PUT_DELETE_PASSWORDS_FILE];",
          "7556:    int ret = 0;",
          "7558:    if (passfile != NULL",
          "7559:        && mg_fopen(conn, passfile, MG_FOPEN_MODE_READ, &file)) {",
          "7560:     ret = authorize(conn, &file);",
          "7561:     (void)mg_fclose(",
          "7563:    }",
          "7565:    return ret;",
          "7567:   return 0;",
          "7572:  int mg_modify_passwords_file(const char *fname,",
          "7573:                               const char *domain,",
          "7574:                               const char *user,",
          "7575:                               const char *pass)",
          "7576:  {",
          "7577:   int found, i;",
          "7578:   char line[512], u[512] = \"\", d[512] = \"\", ha1[33], tmp[PATH_MAX + 8];",
          "7579:   FILE *fp, *fp2;",
          "7581:   found = 0;",
          "7582:   fp = fp2 = NULL;",
          "7585:   if ((pass != NULL) && (pass[0] == '\\0')) {",
          "7586:    pass = NULL;",
          "7587:   }",
          "7590:   if ((fname == NULL) || (domain == NULL) || (user == NULL)) {",
          "7591:    return 0;",
          "7592:   }",
          "7597:   if (strchr(user, ':') != NULL) {",
          "7600:   if (strchr(domain, ':') != NULL) {",
          "7606:   for (i = 0; ((i < 255) && (user[i] != 0)); i++) {",
          "7607:    if (iscntrl(user[i])) {",
          "7608:     return 0;",
          "7609:    }",
          "7610:   }",
          "7611:   if (user[i]) {",
          "7612:    return 0;",
          "7613:   }",
          "7614:   for (i = 0; ((i < 255) && (domain[i] != 0)); i++) {",
          "7615:    if (iscntrl(domain[i])) {",
          "7616:     return 0;",
          "7617:    }",
          "7618:   }",
          "7619:   if (domain[i]) {",
          "7620:    return 0;",
          "7621:   }",
          "7624:   if ((strlen(fname) + 4) >= PATH_MAX) {",
          "7625:    return 0;",
          "7626:   }",
          "7629:   strcpy(tmp, fname);",
          "7630:   strcat(tmp, \".tmp\");",
          "7634:   if ((fp = fopen(fname, \"a+\")) != NULL) {",
          "7635:    (void)fclose(fp);",
          "7636:   }",
          "7639:   if ((fp = fopen(fname, \"r\")) == NULL) {",
          "7640:    return 0;",
          "7641:   } else if ((fp2 = fopen(tmp, \"w+\")) == NULL) {",
          "7642:    fclose(fp);",
          "7643:    return 0;",
          "7647:   while (fgets(line, sizeof(line), fp) != NULL) {",
          "7648:    if (sscanf(line, \"%255[^:]:%255[^:]:%*s\", u, d) != 2) {",
          "7649:     continue;",
          "7650:    }",
          "7651:    u[255] = 0;",
          "7652:    d[255] = 0;",
          "7654:    if (!strcmp(u, user) && !strcmp(d, domain)) {",
          "7655:     found++;",
          "7656:     if (pass != NULL) {",
          "7657:      mg_md5(ha1, user, \":\", domain, \":\", pass, NULL);",
          "7658:      fprintf(fp2, \"%s:%s:%s\\n\", user, domain, ha1);",
          "7659:     }",
          "7660:    } else {",
          "7661:     fprintf(fp2, \"%s\", line);",
          "7666:   if (!found && (pass != NULL)) {",
          "7667:    mg_md5(ha1, user, \":\", domain, \":\", pass, NULL);",
          "7668:    fprintf(fp2, \"%s:%s:%s\\n\", user, domain, ha1);",
          "7669:   }",
          "7672:   fclose(fp);",
          "7673:   fclose(fp2);",
          "7676:   IGNORE_UNUSED_RESULT(remove(fname));",
          "7677:   IGNORE_UNUSED_RESULT(rename(tmp, fname));",
          "7679:   return 1;",
          "7680:  }",
          "7683:  static int is_valid_port(unsigned long port)",
          "7684:  {",
          "7685:   return (port <= 0xffff);",
          "7686:  }",
          "7689:  static int mg_inet_pton(int af, const char *src, void *dst, size_t dstlen)",
          "7690:  {",
          "7691:   struct addrinfo hints, *res, *ressave;",
          "7692:   int func_ret = 0;",
          "7693:   int gai_ret;",
          "7695:   memset(&hints, 0, sizeof(struct addrinfo));",
          "7696:   hints.ai_family = af;",
          "7698:   gai_ret = getaddrinfo(src, NULL, &hints, &res);",
          "7699:   if (gai_ret != 0) {",
          "7707:    return 0;",
          "7708:   }",
          "7710:   ressave = res;",
          "7712:   while (res) {",
          "7713:    if (dstlen >= (size_t)res->ai_addrlen) {",
          "7714:     memcpy(dst, res->ai_addr, res->ai_addrlen);",
          "7715:     func_ret = 1;",
          "7716:    }",
          "7717:    res = res->ai_next;",
          "7720:   freeaddrinfo(ressave);",
          "7721:   return func_ret;",
          "7722:  }",
          "7725:  static int connect_socket(",
          "7726:      struct mg_context * ctx /* may be NULL */,",
          "7727:      const char *host,",
          "7728:      int port,",
          "7729:      int use_ssl,",
          "7730:      char *ebuf,",
          "7731:      size_t ebuf_len,",
          "7732:      SOCKET *sock /* output: socket, must not be NULL */,",
          "7734:      )",
          "7735:  {",
          "7736:   int ip_ver = 0;",
          "7738:   memset(sa, 0, sizeof(*sa));",
          "7740:   if (ebuf_len > 0) {",
          "7742:   }",
          "7744:   if (host == NULL) {",
          "7745:    mg_snprintf(NULL,",
          "7747:                ebuf,",
          "7748:                ebuf_len,",
          "7749:                \"%s\",",
          "7750:                \"NULL host\");",
          "7751:    return 0;",
          "7752:   }",
          "7754:   if ((port <= 0) || !is_valid_port((unsigned)port)) {",
          "7755:    mg_snprintf(NULL,",
          "7757:                ebuf,",
          "7758:                ebuf_len,",
          "7759:                \"%s\",",
          "7760:                \"invalid port\");",
          "7761:    return 0;",
          "7762:   }",
          "7767:   if (use_ssl && (TLS_client_method == NULL)) {",
          "7768:    mg_snprintf(NULL,",
          "7770:                ebuf,",
          "7771:                ebuf_len,",
          "7772:                \"%s\",",
          "7773:                \"SSL is not initialized\");",
          "7774:    return 0;",
          "7775:   }",
          "7777:   if (use_ssl && (SSLv23_client_method == NULL)) {",
          "7778:    mg_snprintf(NULL,",
          "7780:                ebuf,",
          "7781:                ebuf_len,",
          "7782:                \"%s\",",
          "7783:                \"SSL is not initialized\");",
          "7784:    return 0;",
          "7785:   }",
          "",
          "---------------",
          "--- Hunk 43 ---",
          "[Context before]",
          "7794:  (void)use_ssl;",
          "7801: #ifdef USE_IPV6",
          "7817:    }",
          "7820: #endif",
          "7836: #ifdef USE_IPV6",
          "7840: #endif",
          "7843:   mg_snprintf(NULL,",
          "7845:               ebuf,",
          "7846:               ebuf_len,",
          "7848:               strerror(ERRNO));",
          "7849:   return 0;",
          "7850:  }",
          "7869:  }",
          "7907:   }",
          "7940:    mg_snprintf(de->conn,",
          "7942:                size,",
          "7943:                sizeof(size),",
          "7960:   } else {",
          "7967:   }",
          "8045:  }",
          "8063:   return 0;",
          "8095:    }",
          "8098:   }",
          "8100:  }",
          "8105: #if !defined(NO_FILES)",
          "8155:      ok = 0;",
          "8156:     }",
          "8160:      ok = 0;",
          "8161:     }",
          "8162:    }",
          "8163:   }",
          "8167:  }",
          "8171: #endif",
          "8188:  }",
          "8311:  }",
          "8322:   }",
          "8326: #if defined(__linux__)",
          "8343:     if (sf_sent > 0) {",
          "8355:     }",
          "8362:    }",
          "8369: #endif",
          "8400:    }",
          "8401:   }",
          "8402:  }",
          "8424:  }",
          "8432: #ifdef _WIN32",
          "8434: #else",
          "8435:   if (fcntl(fileno(filep->fp), F_SETFD, FD_CLOEXEC) != 0) {",
          "8436:    mg_cry(conn,",
          "",
          "[Removed Lines]",
          "7797:  if (mg_inet_pton(AF_INET, host, &sa->sin, sizeof(sa->sin))) {",
          "7798:   sa->sin.sin_family = AF_INET;",
          "7799:   sa->sin.sin_port = htons((uint16_t)port);",
          "7800:   ip_ver = 4;",
          "7802:  } else if (mg_inet_pton(AF_INET6, host, &sa->sin6, sizeof(sa->sin6))) {",
          "7803:   sa->sin6.sin6_family = AF_INET6;",
          "7804:   sa->sin6.sin6_port = htons((uint16_t)port);",
          "7805:   ip_ver = 6;",
          "7806:  } else if (host[0] == '[') {",
          "7809:   size_t l = strlen(host + 1);",
          "7810:   char *h = (l > 1) ? mg_strdup(host + 1) : NULL;",
          "7811:   if (h) {",
          "7812:    h[l - 1] = 0;",
          "7813:    if (mg_inet_pton(AF_INET6, h, &sa->sin6, sizeof(sa->sin6))) {",
          "7814:     sa->sin6.sin6_family = AF_INET6;",
          "7815:     sa->sin6.sin6_port = htons((uint16_t)port);",
          "7816:     ip_ver = 6;",
          "7818:    mg_free(h);",
          "7819:   }",
          "7821:  }",
          "7823:  if (ip_ver == 0) {",
          "7824:   mg_snprintf(NULL,",
          "7826:               ebuf,",
          "7827:               ebuf_len,",
          "7828:               \"%s\",",
          "7829:               \"host not found\");",
          "7830:   return 0;",
          "7831:  }",
          "7833:  if (ip_ver == 4) {",
          "7835:  }",
          "7837:  else if (ip_ver == 6) {",
          "7839:  }",
          "7842:  if (*sock == INVALID_SOCKET) {",
          "7847:               \"socket(): %s\",",
          "7852:  set_close_on_exec(*sock, fc(ctx));",
          "7854:  if ((ip_ver == 4)",
          "7855:      && (connect(*sock, (struct sockaddr *)&sa->sin, sizeof(sa->sin))",
          "7856:          == 0)) {",
          "7858:   set_blocking_mode(*sock, 0);",
          "7859:   return 1;",
          "7860:  }",
          "7862: #ifdef USE_IPV6",
          "7863:  if ((ip_ver == 6)",
          "7864:      && (connect(*sock, (struct sockaddr *)&sa->sin6, sizeof(sa->sin6))",
          "7865:          == 0)) {",
          "7867:   set_blocking_mode(*sock, 0);",
          "7868:   return 1;",
          "7870: #endif",
          "7873:  mg_snprintf(NULL,",
          "7875:              ebuf,",
          "7876:              ebuf_len,",
          "7877:              \"connect(%s:%d): %s\",",
          "7878:              host,",
          "7879:              port,",
          "7880:              strerror(ERRNO));",
          "7881:  closesocket(*sock);",
          "7884:  return 0;",
          "7885: }",
          "7888: int",
          "7889: mg_url_encode(const char *src, char *dst, size_t dst_len)",
          "7890: {",
          "7891:  static const char *dont_escape = \"._-$,;~()\";",
          "7892:  static const char *hex = \"0123456789abcdef\";",
          "7893:  char *pos = dst;",
          "7894:  const char *end = dst + dst_len - 1;",
          "7896:  for (; ((*src != '\\0') && (pos < end)); src++, pos++) {",
          "7897:   if (isalnum(*(const unsigned char *)src)",
          "7898:       || (strchr(dont_escape, *(const unsigned char *)src) != NULL)) {",
          "7900:   } else if (pos + 2 < end) {",
          "7901:    pos[0] = '%';",
          "7902:    pos[1] = hex[(*(const unsigned char *)src) >> 4];",
          "7903:    pos[2] = hex[(*(const unsigned char *)src) & 0xf];",
          "7904:    pos += 2;",
          "7905:   } else {",
          "7906:    break;",
          "7908:  }",
          "7911:  return (*src == '\\0') ? (int)(pos - dst) : -1;",
          "7912: }",
          "7916: static int",
          "7917: print_dir_entry(struct de *de)",
          "7918: {",
          "7919:  size_t hrefsize;",
          "7920:  char *href;",
          "7921:  char size[64], mod[64];",
          "7922:  struct tm *tm;",
          "7925:  href = mg_malloc(hrefsize);",
          "7926:  if (href == NULL) {",
          "7927:   return -1;",
          "7928:  }",
          "7929:  if (de->file.is_directory) {",
          "7930:   mg_snprintf(de->conn,",
          "7932:               size,",
          "7933:               sizeof(size),",
          "7934:               \"%s\",",
          "7935:               \"[DIRECTORY]\");",
          "7936:  } else {",
          "7939:   if (de->file.size < 1024) {",
          "7944:                \"%d\",",
          "7945:                (int)de->file.size);",
          "7946:   } else if (de->file.size < 0x100000) {",
          "7947:    mg_snprintf(de->conn,",
          "7949:                size,",
          "7950:                sizeof(size),",
          "7951:                \"%.1fk\",",
          "7952:                (double)de->file.size / 1024.0);",
          "7953:   } else if (de->file.size < 0x40000000) {",
          "7954:    mg_snprintf(de->conn,",
          "7956:                size,",
          "7957:                sizeof(size),",
          "7958:                \"%.1fM\",",
          "7959:                (double)de->file.size / 1048576);",
          "7961:    mg_snprintf(de->conn,",
          "7963:                size,",
          "7964:                sizeof(size),",
          "7965:                \"%.1fG\",",
          "7966:                (double)de->file.size / 1073741824);",
          "7968:  }",
          "7973:  tm = localtime(&de->file.last_modified);",
          "7974:  if (tm != NULL) {",
          "7975:   strftime(mod, sizeof(mod), \"%d-%b-%Y %H:%M\", tm);",
          "7976:  } else {",
          "7977:   mg_strlcpy(mod, \"01-Jan-1970 00:00\", sizeof(mod));",
          "7978:   mod[sizeof(mod) - 1] = '\\0';",
          "7979:  }",
          "7980:  mg_url_encode(de->file_name, href, hrefsize);",
          "7981:  mg_printf(de->conn,",
          "7982:            \"<tr><td><a href=\\\"%s%s%s\\\">%s%s</a></td>\"",
          "7983:            \"<td>&nbsp;%s</td><td>&nbsp;&nbsp;%s</td></tr>\\n\",",
          "7984:            de->conn->request_info.local_uri,",
          "7985:            href,",
          "7986:            de->file.is_directory ? \"/\" : \"\",",
          "7987:            de->file_name,",
          "7988:            de->file.is_directory ? \"/\" : \"\",",
          "7989:            mod,",
          "7990:            size);",
          "7991:  mg_free(href);",
          "7992:  return 0;",
          "7993: }",
          "8000: static int WINCDECL",
          "8001: compare_dir_entries(const void *p1, const void *p2)",
          "8002: {",
          "8003:  if (p1 && p2) {",
          "8004:   const struct de *a = (const struct de *)p1, *b = (const struct de *)p2;",
          "8005:   const char *query_string = a->conn->request_info.query_string;",
          "8006:   int cmp_result = 0;",
          "8008:   if (query_string == NULL) {",
          "8009:    query_string = \"na\";",
          "8010:   }",
          "8012:   if (a->file.is_directory && !b->file.is_directory) {",
          "8014:   } else if (!a->file.is_directory && b->file.is_directory) {",
          "8016:   } else if (*query_string == 'n') {",
          "8017:    cmp_result = strcmp(a->file_name, b->file_name);",
          "8018:   } else if (*query_string == 's') {",
          "8019:    cmp_result = (a->file.size == b->file.size)",
          "8020:                     ? 0",
          "8021:                     : ((a->file.size > b->file.size) ? 1 : -1);",
          "8022:   } else if (*query_string == 'd') {",
          "8023:    cmp_result =",
          "8024:        (a->file.last_modified == b->file.last_modified)",
          "8025:            ? 0",
          "8026:            : ((a->file.last_modified > b->file.last_modified) ? 1",
          "8027:                                                               : -1);",
          "8028:   }",
          "8030:   return (query_string[1] == 'd') ? -cmp_result : cmp_result;",
          "8031:  }",
          "8032:  return 0;",
          "8033: }",
          "8036: static int",
          "8037: must_hide_file(struct mg_connection *conn, const char *path)",
          "8038: {",
          "8039:  if (conn && conn->ctx) {",
          "8040:   const char *pw_pattern = \"**\" PASSWORDS_FILE_NAME \"$\";",
          "8041:   const char *pattern = conn->ctx->config[HIDE_FILES];",
          "8042:   return (match_prefix(pw_pattern, strlen(pw_pattern), path) > 0)",
          "8043:          || ((pattern != NULL)",
          "8044:              && (match_prefix(pattern, strlen(pattern), path) > 0));",
          "8046:  return 0;",
          "8047: }",
          "8050: static int",
          "8051: scan_directory(struct mg_connection *conn,",
          "8052:                const char *dir,",
          "8053:                void *data,",
          "8054:                int (*cb)(struct de *, void *))",
          "8055: {",
          "8056:  char path[PATH_MAX];",
          "8057:  struct dirent *dp;",
          "8058:  DIR *dirp;",
          "8059:  struct de de;",
          "8060:  int truncated;",
          "8062:  if ((dirp = mg_opendir(conn, dir)) == NULL) {",
          "8064:  } else {",
          "8065:   de.conn = conn;",
          "8067:   while ((dp = mg_readdir(dirp)) != NULL) {",
          "8069:    if (!strcmp(dp->d_name, \".\") || !strcmp(dp->d_name, \"..\")",
          "8070:        || must_hide_file(conn, dp->d_name)) {",
          "8071:     continue;",
          "8072:    }",
          "8074:    mg_snprintf(",
          "8075:        conn, &truncated, path, sizeof(path), \"%s/%s\", dir, dp->d_name);",
          "8082:    memset(&de.file, 0, sizeof(de.file));",
          "8084:    if (truncated) {",
          "8086:     continue;",
          "8087:    }",
          "8089:    if (!mg_stat(conn, path, &de.file)) {",
          "8090:     mg_cry(conn,",
          "8091:            \"%s: mg_stat(%s) failed: %s\",",
          "8092:            __func__,",
          "8093:            path,",
          "8094:            strerror(ERRNO));",
          "8096:    de.file_name = dp->d_name;",
          "8097:    cb(&de, data);",
          "8099:   (void)mg_closedir(dirp);",
          "8101:  return 1;",
          "8102: }",
          "8106: static int",
          "8107: remove_directory(struct mg_connection *conn, const char *dir)",
          "8108: {",
          "8109:  char path[PATH_MAX];",
          "8110:  struct dirent *dp;",
          "8111:  DIR *dirp;",
          "8112:  struct de de;",
          "8113:  int truncated;",
          "8114:  int ok = 1;",
          "8116:  if ((dirp = mg_opendir(conn, dir)) == NULL) {",
          "8117:   return 0;",
          "8118:  } else {",
          "8119:   de.conn = conn;",
          "8121:   while ((dp = mg_readdir(dirp)) != NULL) {",
          "8124:    if (!strcmp(dp->d_name, \".\") || !strcmp(dp->d_name, \"..\")) {",
          "8125:     continue;",
          "8126:    }",
          "8128:    mg_snprintf(",
          "8129:        conn, &truncated, path, sizeof(path), \"%s/%s\", dir, dp->d_name);",
          "8136:    memset(&de.file, 0, sizeof(de.file));",
          "8138:    if (truncated) {",
          "8140:     ok = 0;",
          "8141:     continue;",
          "8142:    }",
          "8144:    if (!mg_stat(conn, path, &de.file)) {",
          "8145:     mg_cry(conn,",
          "8146:            \"%s: mg_stat(%s) failed: %s\",",
          "8147:            __func__,",
          "8148:            path,",
          "8149:            strerror(ERRNO));",
          "8150:     ok = 0;",
          "8151:    }",
          "8153:    if (de.file.is_directory) {",
          "8154:     if (remove_directory(conn, path) == 0) {",
          "8157:    } else {",
          "8159:     if (mg_remove(conn, path) == 0) {",
          "8164:   (void)mg_closedir(dirp);",
          "8166:   IGNORE_UNUSED_RESULT(rmdir(dir));",
          "8169:  return ok;",
          "8170: }",
          "8174: struct dir_scan_data {",
          "8175:  struct de *entries;",
          "8176:  unsigned int num_entries;",
          "8177:  unsigned int arr_size;",
          "8178: };",
          "8182: static void *",
          "8183: realloc2(void *ptr, size_t size)",
          "8184: {",
          "8185:  void *new_ptr = mg_realloc(ptr, size);",
          "8186:  if (new_ptr == NULL) {",
          "8187:   mg_free(ptr);",
          "8189:  return new_ptr;",
          "8190: }",
          "8193: static int",
          "8194: dir_scan_callback(struct de *de, void *data)",
          "8195: {",
          "8196:  struct dir_scan_data *dsd = (struct dir_scan_data *)data;",
          "8198:  if ((dsd->entries == NULL) || (dsd->num_entries >= dsd->arr_size)) {",
          "8199:   dsd->arr_size *= 2;",
          "8200:   dsd->entries =",
          "8201:       (struct de *)realloc2(dsd->entries,",
          "8202:                             dsd->arr_size * sizeof(dsd->entries[0]));",
          "8203:  }",
          "8204:  if (dsd->entries == NULL) {",
          "8206:   dsd->num_entries = 0;",
          "8207:  } else {",
          "8208:   dsd->entries[dsd->num_entries].file_name = mg_strdup(de->file_name);",
          "8209:   dsd->entries[dsd->num_entries].file = de->file;",
          "8210:   dsd->entries[dsd->num_entries].conn = de->conn;",
          "8211:   dsd->num_entries++;",
          "8212:  }",
          "8214:  return 0;",
          "8215: }",
          "8218: static void",
          "8219: handle_directory_request(struct mg_connection *conn, const char *dir)",
          "8220: {",
          "8221:  unsigned int i;",
          "8222:  int sort_direction;",
          "8223:  struct dir_scan_data data = {NULL, 0, 128};",
          "8224:  char date[64];",
          "8225:  time_t curtime = time(NULL);",
          "8227:  if (!scan_directory(conn, dir, &data, dir_scan_callback)) {",
          "8228:   mg_send_http_error(conn,",
          "8229:                      500,",
          "8230:                      \"Error: Cannot open directory\\nopendir(%s): %s\",",
          "8231:                      dir,",
          "8232:                      strerror(ERRNO));",
          "8233:   return;",
          "8234:  }",
          "8236:  gmt_time_string(date, sizeof(date), &curtime);",
          "8238:  if (!conn) {",
          "8239:   return;",
          "8240:  }",
          "8242:  sort_direction = ((conn->request_info.query_string != NULL)",
          "8243:                    && (conn->request_info.query_string[1] == 'd'))",
          "8244:                       ? 'a'",
          "8245:                       : 'd';",
          "8247:  conn->must_close = 1;",
          "8248:  mg_printf(conn, \"HTTP/1.1 200 OK\\r\\n\");",
          "8249:  send_static_cache_header(conn);",
          "8250:  send_additional_header(conn);",
          "8251:  mg_printf(conn,",
          "8252:            \"Date: %s\\r\\n\"",
          "8253:            \"Connection: close\\r\\n\"",
          "8254:            \"Content-Type: text/html; charset=utf-8\\r\\n\\r\\n\",",
          "8255:            date);",
          "8256:  mg_printf(conn,",
          "8257:            \"<html><head><title>Index of %s</title>\"",
          "8258:            \"<style>th {text-align: left;}</style></head>\"",
          "8259:            \"<body><h1>Index of %s</h1><pre><table cellpadding=\\\"0\\\">\"",
          "8260:            \"<tr><th><a href=\\\"?n%c\\\">Name</a></th>\"",
          "8261:            \"<th><a href=\\\"?d%c\\\">Modified</a></th>\"",
          "8262:            \"<th><a href=\\\"?s%c\\\">Size</a></th></tr>\"",
          "8263:            \"<tr><td colspan=\\\"3\\\"><hr></td></tr>\",",
          "8264:            conn->request_info.local_uri,",
          "8265:            conn->request_info.local_uri,",
          "8266:            sort_direction,",
          "8267:            sort_direction,",
          "8268:            sort_direction);",
          "8271:  mg_printf(conn,",
          "8272:            \"<tr><td><a href=\\\"%s%s\\\">%s</a></td>\"",
          "8273:            \"<td>&nbsp;%s</td><td>&nbsp;&nbsp;%s</td></tr>\\n\",",
          "8274:            conn->request_info.local_uri,",
          "8275:            \"..\",",
          "8276:            \"Parent directory\",",
          "8277:            \"-\",",
          "8278:            \"-\");",
          "8281:  if (data.entries != NULL) {",
          "8282:   qsort(data.entries,",
          "8283:         (size_t)data.num_entries,",
          "8284:         sizeof(data.entries[0]),",
          "8285:         compare_dir_entries);",
          "8286:   for (i = 0; i < data.num_entries; i++) {",
          "8287:    print_dir_entry(&data.entries[i]);",
          "8288:    mg_free(data.entries[i].file_name);",
          "8289:   }",
          "8290:   mg_free(data.entries);",
          "8291:  }",
          "8293:  mg_printf(conn, \"%s\", \"</table></body></html>\");",
          "8294:  conn->status_code = 200;",
          "8295: }",
          "8299: static void",
          "8300: send_file_data(struct mg_connection *conn,",
          "8301:                struct mg_file *filep,",
          "8302:                int64_t offset,",
          "8303:                int64_t len)",
          "8304: {",
          "8305:  char buf[MG_BUF_LEN];",
          "8306:  int to_read, num_read, num_written;",
          "8307:  int64_t size;",
          "8309:  if (!filep || !conn) {",
          "8310:   return;",
          "8314:  size = (filep->stat.size > INT64_MAX) ? INT64_MAX",
          "8315:                                        : (int64_t)(filep->stat.size);",
          "8316:  offset = (offset < 0) ? 0 : ((offset > size) ? size : offset);",
          "8318:  if ((len > 0) && (filep->access.membuf != NULL) && (size > 0)) {",
          "8320:   if (len > size - offset) {",
          "8321:    len = size - offset;",
          "8323:   mg_write(conn, filep->access.membuf + offset, (size_t)len);",
          "8324:  } else if (len > 0 && filep->access.fp != NULL) {",
          "8328:   if ((conn->ssl == 0) && (conn->throttle == 0)",
          "8329:       && (!mg_strcasecmp(conn->ctx->config[ALLOW_SENDFILE_CALL],",
          "8330:                          \"yes\"))) {",
          "8331:    off_t sf_offs = (off_t)offset;",
          "8332:    ssize_t sf_sent;",
          "8333:    int sf_file = fileno(filep->access.fp);",
          "8334:    int loop_cnt = 0;",
          "8336:    do {",
          "8339:     size_t sf_tosend =",
          "8340:         (size_t)((len < 0x7FFFF000) ? len : 0x7FFFF000);",
          "8341:     sf_sent =",
          "8342:         sendfile(conn->client.sock, sf_file, &sf_offs, sf_tosend);",
          "8344:      len -= sf_sent;",
          "8345:      offset += sf_sent;",
          "8346:     } else if (loop_cnt == 0) {",
          "8351:      break;",
          "8352:     } else if (sf_sent == 0) {",
          "8354:      return;",
          "8356:     loop_cnt++;",
          "8358:    } while ((len > 0) && (sf_sent >= 0));",
          "8360:    if (sf_sent > 0) {",
          "8367:    offset = (int64_t)sf_offs;",
          "8368:   }",
          "8370:   if ((offset > 0) && (fseeko(filep->access.fp, offset, SEEK_SET) != 0)) {",
          "8371:    mg_cry(conn, \"%s: fseeko() failed: %s\", __func__, strerror(ERRNO));",
          "8372:    mg_send_http_error(",
          "8373:        conn,",
          "8374:        500,",
          "8375:        \"%s\",",
          "8376:        \"Error: Unable to access file at requested position.\");",
          "8377:   } else {",
          "8378:    while (len > 0) {",
          "8380:     to_read = sizeof(buf);",
          "8381:     if ((int64_t)to_read > len) {",
          "8382:      to_read = (int)len;",
          "8383:     }",
          "8386:     if ((num_read =",
          "8387:              (int)fread(buf, 1, (size_t)to_read, filep->access.fp))",
          "8388:         <= 0) {",
          "8389:      break;",
          "8390:     }",
          "8393:     if ((num_written = mg_write(conn, buf, (size_t)num_read))",
          "8394:         != num_read) {",
          "8395:      break;",
          "8396:     }",
          "8399:     len -= num_written;",
          "8403: }",
          "8406: static int",
          "8407: parse_range_header(const char *header, int64_t *a, int64_t *b)",
          "8408: {",
          "8409:  return sscanf(header, \"bytes=%\" INT64_FMT \"-%\" INT64_FMT, a, b);",
          "8410: }",
          "8413: static void",
          "8414: construct_etag(char *buf, size_t buf_len, const struct mg_file_stat *filestat)",
          "8415: {",
          "8416:  if ((filestat != NULL) && (buf != NULL)) {",
          "8417:   mg_snprintf(NULL,",
          "8419:               buf,",
          "8420:               buf_len,",
          "8421:               \"\\\"%lx.%\" INT64_FMT \"\\\"\",",
          "8422:               (unsigned long)filestat->last_modified,",
          "8423:               filestat->size);",
          "8425: }",
          "8428: static void",
          "8429: fclose_on_exec(struct mg_file_access *filep, struct mg_connection *conn)",
          "8430: {",
          "8431:  if (filep != NULL && filep->fp != NULL) {",
          "",
          "[Added Lines]",
          "7795:   if (mg_inet_pton(AF_INET, host, &sa->sin, sizeof(sa->sin))) {",
          "7796:    sa->sin.sin_family = AF_INET;",
          "7797:    sa->sin.sin_port = htons((uint16_t)port);",
          "7798:    ip_ver = 4;",
          "7800:   } else if (mg_inet_pton(AF_INET6, host, &sa->sin6, sizeof(sa->sin6))) {",
          "7801:    sa->sin6.sin6_family = AF_INET6;",
          "7802:    sa->sin6.sin6_port = htons((uint16_t)port);",
          "7803:    ip_ver = 6;",
          "7804:   } else if (host[0] == '[') {",
          "7807:    size_t l = strlen(host + 1);",
          "7808:    char *h = (l > 1) ? mg_strdup(host + 1) : NULL;",
          "7809:    if (h) {",
          "7810:     h[l - 1] = 0;",
          "7811:     if (mg_inet_pton(AF_INET6, h, &sa->sin6, sizeof(sa->sin6))) {",
          "7812:      sa->sin6.sin6_family = AF_INET6;",
          "7813:      sa->sin6.sin6_port = htons((uint16_t)port);",
          "7814:      ip_ver = 6;",
          "7815:     }",
          "7816:     mg_free(h);",
          "7819:   }",
          "7821:   if (ip_ver == 0) {",
          "7822:    mg_snprintf(NULL,",
          "7824:                ebuf,",
          "7825:                ebuf_len,",
          "7826:                \"%s\",",
          "7827:                \"host not found\");",
          "7828:    return 0;",
          "7829:   }",
          "7831:   if (ip_ver == 4) {",
          "7833:   }",
          "7835:   else if (ip_ver == 6) {",
          "7837:   }",
          "7838: #endif",
          "7840:   if (*sock == INVALID_SOCKET) {",
          "7841:    mg_snprintf(NULL,",
          "7843:                ebuf,",
          "7844:                ebuf_len,",
          "7845:                \"socket(): %s\",",
          "7846:                strerror(ERRNO));",
          "7847:    return 0;",
          "7848:   }",
          "7850:   set_close_on_exec(*sock, fc(ctx));",
          "7852:   if ((ip_ver == 4)",
          "7853:       && (connect(*sock, (struct sockaddr *)&sa->sin, sizeof(sa->sin))",
          "7854:           == 0)) {",
          "7856:    set_blocking_mode(*sock, 0);",
          "7857:    return 1;",
          "7858:   }",
          "7860: #ifdef USE_IPV6",
          "7861:   if ((ip_ver == 6)",
          "7862:       && (connect(*sock, (struct sockaddr *)&sa->sin6, sizeof(sa->sin6))",
          "7863:           == 0)) {",
          "7865:    set_blocking_mode(*sock, 0);",
          "7866:    return 1;",
          "7867:   }",
          "7875:               \"connect(%s:%d): %s\",",
          "7876:               host,",
          "7877:               port,",
          "7879:   closesocket(*sock);",
          "7886:  int mg_url_encode(const char *src, char *dst, size_t dst_len)",
          "7887:  {",
          "7888:   static const char *dont_escape = \"._-$,;~()\";",
          "7889:   static const char *hex = \"0123456789abcdef\";",
          "7890:   char *pos = dst;",
          "7891:   const char *end = dst + dst_len - 1;",
          "7893:   for (; ((*src != '\\0') && (pos < end)); src++, pos++) {",
          "7894:    if (isalnum(*(const unsigned char *)src)",
          "7895:        || (strchr(dont_escape, *(const unsigned char *)src) != NULL)) {",
          "7897:    } else if (pos + 2 < end) {",
          "7898:     pos[0] = '%';",
          "7899:     pos[1] = hex[(*(const unsigned char *)src) >> 4];",
          "7900:     pos[2] = hex[(*(const unsigned char *)src) & 0xf];",
          "7901:     pos += 2;",
          "7902:    } else {",
          "7903:     break;",
          "7904:    }",
          "7905:   }",
          "7908:   return (*src == '\\0') ? (int)(pos - dst) : -1;",
          "7913:  static int print_dir_entry(struct de * de)",
          "7914:  {",
          "7915:   size_t hrefsize;",
          "7916:   char *href;",
          "7917:   char size[64], mod[64];",
          "7918:   struct tm *tm;",
          "7921:   href = mg_malloc(hrefsize);",
          "7922:   if (href == NULL) {",
          "7923:    return -1;",
          "7925:   if (de->file.is_directory) {",
          "7930:                \"%s\",",
          "7931:                \"[DIRECTORY]\");",
          "7935:    if (de->file.size < 1024) {",
          "7936:     mg_snprintf(de->conn,",
          "7938:                 size,",
          "7939:                 sizeof(size),",
          "7940:                 \"%d\",",
          "7941:                 (int)de->file.size);",
          "7942:    } else if (de->file.size < 0x100000) {",
          "7943:     mg_snprintf(de->conn,",
          "7945:                 size,",
          "7946:                 sizeof(size),",
          "7947:                 \"%.1fk\",",
          "7948:                 (double)de->file.size / 1024.0);",
          "7949:    } else if (de->file.size < 0x40000000) {",
          "7950:     mg_snprintf(de->conn,",
          "7952:                 size,",
          "7953:                 sizeof(size),",
          "7954:                 \"%.1fM\",",
          "7955:                 (double)de->file.size / 1048576);",
          "7956:    } else {",
          "7957:     mg_snprintf(de->conn,",
          "7959:                 size,",
          "7960:                 sizeof(size),",
          "7961:                 \"%.1fG\",",
          "7962:                 (double)de->file.size / 1073741824);",
          "7963:    }",
          "7969:   tm = localtime(&de->file.last_modified);",
          "7970:   if (tm != NULL) {",
          "7971:    strftime(mod, sizeof(mod), \"%d-%b-%Y %H:%M\", tm);",
          "7972:   } else {",
          "7973:    mg_strlcpy(mod, \"01-Jan-1970 00:00\", sizeof(mod));",
          "7974:    mod[sizeof(mod) - 1] = '\\0';",
          "7975:   }",
          "7976:   mg_url_encode(de->file_name, href, hrefsize);",
          "7977:   mg_printf(de->conn,",
          "7978:             \"<tr><td><a href=\\\"%s%s%s\\\">%s%s</a></td>\"",
          "7979:             \"<td>&nbsp;%s</td><td>&nbsp;&nbsp;%s</td></tr>\\n\",",
          "7980:             de->conn->request_info.local_uri,",
          "7981:             href,",
          "7982:             de->file.is_directory ? \"/\" : \"\",",
          "7983:             de->file_name,",
          "7984:             de->file.is_directory ? \"/\" : \"\",",
          "7985:             mod,",
          "7986:             size);",
          "7987:   mg_free(href);",
          "7988:   return 0;",
          "7989:  }",
          "7996:  static int WINCDECL compare_dir_entries(const void *p1, const void *p2)",
          "7997:  {",
          "7998:   if (p1 && p2) {",
          "7999:    const struct de *a = (const struct de *)p1,",
          "8001:    const char *query_string = a->conn->request_info.query_string;",
          "8002:    int cmp_result = 0;",
          "8004:    if (query_string == NULL) {",
          "8005:     query_string = \"na\";",
          "8006:    }",
          "8008:    if (a->file.is_directory && !b->file.is_directory) {",
          "8010:    } else if (!a->file.is_directory && b->file.is_directory) {",
          "8012:    } else if (*query_string == 'n') {",
          "8013:     cmp_result = strcmp(a->file_name, b->file_name);",
          "8014:    } else if (*query_string == 's') {",
          "8015:     cmp_result = (a->file.size == b->file.size)",
          "8016:                      ? 0",
          "8017:                      : ((a->file.size > b->file.size) ? 1 : -1);",
          "8018:    } else if (*query_string == 'd') {",
          "8019:     cmp_result =",
          "8020:         (a->file.last_modified == b->file.last_modified)",
          "8021:             ? 0",
          "8022:             : ((a->file.last_modified > b->file.last_modified)",
          "8023:                    ? 1",
          "8024:                    : -1);",
          "8025:    }",
          "8027:    return (query_string[1] == 'd') ? -cmp_result : cmp_result;",
          "8028:   }",
          "8029:   return 0;",
          "8033:  static int must_hide_file(struct mg_connection * conn, const char *path)",
          "8034:  {",
          "8035:   if (conn && conn->ctx) {",
          "8036:    const char *pw_pattern = \"**\" PASSWORDS_FILE_NAME \"$\";",
          "8037:    const char *pattern = conn->ctx->config[HIDE_FILES];",
          "8038:    return (match_prefix(pw_pattern, strlen(pw_pattern), path) > 0)",
          "8039:           || ((pattern != NULL)",
          "8040:               && (match_prefix(pattern, strlen(pattern), path) > 0));",
          "8041:   }",
          "8043:  }",
          "8046:  static int scan_directory(struct mg_connection * conn,",
          "8047:                            const char *dir,",
          "8048:                            void *data,",
          "8049:                            int (*cb)(struct de *, void *))",
          "8050:  {",
          "8051:   char path[PATH_MAX];",
          "8052:   struct dirent *dp;",
          "8053:   DIR *dirp;",
          "8054:   struct de de;",
          "8055:   int truncated;",
          "8057:   if ((dirp = mg_opendir(conn, dir)) == NULL) {",
          "8058:    return 0;",
          "8059:   } else {",
          "8060:    de.conn = conn;",
          "8062:    while ((dp = mg_readdir(dirp)) != NULL) {",
          "8064:     if (!strcmp(dp->d_name, \".\") || !strcmp(dp->d_name, \"..\")",
          "8065:         || must_hide_file(conn, dp->d_name)) {",
          "8066:      continue;",
          "8067:     }",
          "8069:     mg_snprintf(conn,",
          "8070:                 &truncated,",
          "8071:                 path,",
          "8072:                 sizeof(path),",
          "8073:                 \"%s/%s\",",
          "8074:                 dir,",
          "8075:                 dp->d_name);",
          "8082:     memset(&de.file, 0, sizeof(de.file));",
          "8084:     if (truncated) {",
          "8086:      continue;",
          "8087:     }",
          "8089:     if (!mg_stat(conn, path, &de.file)) {",
          "8090:      mg_cry(conn,",
          "8091:             \"%s: mg_stat(%s) failed: %s\",",
          "8092:             __func__,",
          "8093:             path,",
          "8094:             strerror(ERRNO));",
          "8095:     }",
          "8096:     de.file_name = dp->d_name;",
          "8097:     cb(&de, data);",
          "8099:    (void)mg_closedir(dirp);",
          "8101:   return 1;",
          "8106:  static int remove_directory(struct mg_connection * conn, const char *dir)",
          "8107:  {",
          "8108:   char path[PATH_MAX];",
          "8109:   struct dirent *dp;",
          "8110:   DIR *dirp;",
          "8111:   struct de de;",
          "8112:   int truncated;",
          "8113:   int ok = 1;",
          "8115:   if ((dirp = mg_opendir(conn, dir)) == NULL) {",
          "8116:    return 0;",
          "8117:   } else {",
          "8118:    de.conn = conn;",
          "8120:    while ((dp = mg_readdir(dirp)) != NULL) {",
          "8123:     if (!strcmp(dp->d_name, \".\") || !strcmp(dp->d_name, \"..\")) {",
          "8124:      continue;",
          "8125:     }",
          "8127:     mg_snprintf(conn,",
          "8128:                 &truncated,",
          "8129:                 path,",
          "8130:                 sizeof(path),",
          "8131:                 \"%s/%s\",",
          "8132:                 dir,",
          "8133:                 dp->d_name);",
          "8140:     memset(&de.file, 0, sizeof(de.file));",
          "8142:     if (truncated) {",
          "8145:      continue;",
          "8148:     if (!mg_stat(conn, path, &de.file)) {",
          "8149:      mg_cry(conn,",
          "8150:             \"%s: mg_stat(%s) failed: %s\",",
          "8151:             __func__,",
          "8152:             path,",
          "8153:             strerror(ERRNO));",
          "8157:     if (de.file.is_directory) {",
          "8158:      if (remove_directory(conn, path) == 0) {",
          "8159:       ok = 0;",
          "8160:      }",
          "8161:     } else {",
          "8163:      if (mg_remove(conn, path) == 0) {",
          "8164:       ok = 0;",
          "8165:      }",
          "8166:     }",
          "8168:    (void)mg_closedir(dirp);",
          "8170:    IGNORE_UNUSED_RESULT(rmdir(dir));",
          "8173:   return ok;",
          "8178:  struct dir_scan_data {",
          "8179:   struct de *entries;",
          "8180:   unsigned int num_entries;",
          "8181:   unsigned int arr_size;",
          "8182:  };",
          "8186:  static void *realloc2(void *ptr, size_t size)",
          "8187:  {",
          "8188:   void *new_ptr = mg_realloc(ptr, size);",
          "8189:   if (new_ptr == NULL) {",
          "8190:    mg_free(ptr);",
          "8191:   }",
          "8192:   return new_ptr;",
          "8196:  static int dir_scan_callback(struct de * de, void *data)",
          "8197:  {",
          "8198:   struct dir_scan_data *dsd = (struct dir_scan_data *)data;",
          "8200:   if ((dsd->entries == NULL) || (dsd->num_entries >= dsd->arr_size)) {",
          "8201:    dsd->arr_size *= 2;",
          "8202:    dsd->entries =",
          "8203:        (struct de *)realloc2(dsd->entries,",
          "8204:                              dsd->arr_size * sizeof(dsd->entries[0]));",
          "8205:   }",
          "8206:   if (dsd->entries == NULL) {",
          "8208:    dsd->num_entries = 0;",
          "8209:   } else {",
          "8210:    dsd->entries[dsd->num_entries].file_name = mg_strdup(de->file_name);",
          "8211:    dsd->entries[dsd->num_entries].file = de->file;",
          "8212:    dsd->entries[dsd->num_entries].conn = de->conn;",
          "8213:    dsd->num_entries++;",
          "8214:   }",
          "8216:   return 0;",
          "8217:  }",
          "8220:  static void handle_directory_request(struct mg_connection * conn,",
          "8221:                                       const char *dir)",
          "8222:  {",
          "8223:   unsigned int i;",
          "8224:   int sort_direction;",
          "8225:   struct dir_scan_data data = {NULL, 0, 128};",
          "8226:   char date[64];",
          "8227:   time_t curtime = time(NULL);",
          "8229:   if (!scan_directory(conn, dir, &data, dir_scan_callback)) {",
          "8230:    mg_send_http_error(conn,",
          "8231:                       500,",
          "8232:                       \"Error: Cannot open directory\\nopendir(%s): %s\",",
          "8233:                       dir,",
          "8234:                       strerror(ERRNO));",
          "8235:    return;",
          "8236:   }",
          "8238:   gmt_time_string(date, sizeof(date), &curtime);",
          "8240:   if (!conn) {",
          "8241:    return;",
          "8242:   }",
          "8244:   sort_direction = ((conn->request_info.query_string != NULL)",
          "8245:                     && (conn->request_info.query_string[1] == 'd'))",
          "8246:                        ? 'a'",
          "8247:                        : 'd';",
          "8249:   conn->must_close = 1;",
          "8250:   mg_printf(conn, \"HTTP/1.1 200 OK\\r\\n\");",
          "8251:   send_static_cache_header(conn);",
          "8252:   send_additional_header(conn);",
          "8253:   mg_printf(conn,",
          "8254:             \"Date: %s\\r\\n\"",
          "8255:             \"Connection: close\\r\\n\"",
          "8256:             \"Content-Type: text/html; charset=utf-8\\r\\n\\r\\n\",",
          "8257:             date);",
          "8258:   mg_printf(conn,",
          "8259:             \"<html><head><title>Index of %s</title>\"",
          "8260:             \"<style>th {text-align: left;}</style></head>\"",
          "8261:             \"<body><h1>Index of %s</h1><pre><table cellpadding=\\\"0\\\">\"",
          "8262:             \"<tr><th><a href=\\\"?n%c\\\">Name</a></th>\"",
          "8263:             \"<th><a href=\\\"?d%c\\\">Modified</a></th>\"",
          "8264:             \"<th><a href=\\\"?s%c\\\">Size</a></th></tr>\"",
          "8265:             \"<tr><td colspan=\\\"3\\\"><hr></td></tr>\",",
          "8266:             conn->request_info.local_uri,",
          "8267:             conn->request_info.local_uri,",
          "8268:             sort_direction,",
          "8269:             sort_direction,",
          "8270:             sort_direction);",
          "8273:   mg_printf(conn,",
          "8274:             \"<tr><td><a href=\\\"%s%s\\\">%s</a></td>\"",
          "8275:             \"<td>&nbsp;%s</td><td>&nbsp;&nbsp;%s</td></tr>\\n\",",
          "8276:             conn->request_info.local_uri,",
          "8277:             \"..\",",
          "8278:             \"Parent directory\",",
          "8279:             \"-\",",
          "8280:             \"-\");",
          "8283:   if (data.entries != NULL) {",
          "8284:    qsort(data.entries,",
          "8285:          (size_t)data.num_entries,",
          "8286:          sizeof(data.entries[0]),",
          "8287:          compare_dir_entries);",
          "8288:    for (i = 0; i < data.num_entries; i++) {",
          "8289:     print_dir_entry(&data.entries[i]);",
          "8290:     mg_free(data.entries[i].file_name);",
          "8291:    }",
          "8292:    mg_free(data.entries);",
          "8293:   }",
          "8295:   mg_printf(conn, \"%s\", \"</table></body></html>\");",
          "8296:   conn->status_code = 200;",
          "8301:  static void send_file_data(struct mg_connection * conn,",
          "8302:                             struct mg_file * filep,",
          "8303:                             int64_t offset,",
          "8304:                             int64_t len)",
          "8305:  {",
          "8306:   char buf[MG_BUF_LEN];",
          "8307:   int to_read, num_read, num_written;",
          "8308:   int64_t size;",
          "8310:   if (!filep || !conn) {",
          "8311:    return;",
          "8315:   size = (filep->stat.size > INT64_MAX) ? INT64_MAX",
          "8316:                                         : (int64_t)(filep->stat.size);",
          "8317:   offset = (offset < 0) ? 0 : ((offset > size) ? size : offset);",
          "8319:   if ((len > 0) && (filep->access.membuf != NULL) && (size > 0)) {",
          "8321:    if (len > size - offset) {",
          "8322:     len = size - offset;",
          "8323:    }",
          "8324:    mg_write(conn, filep->access.membuf + offset, (size_t)len);",
          "8325:   } else if (len > 0 && filep->access.fp != NULL) {",
          "8329:    if ((conn->ssl == 0) && (conn->throttle == 0)",
          "8330:        && (!mg_strcasecmp(conn->ctx->config[ALLOW_SENDFILE_CALL],",
          "8331:                           \"yes\"))) {",
          "8332:     off_t sf_offs = (off_t)offset;",
          "8333:     ssize_t sf_sent;",
          "8334:     int sf_file = fileno(filep->access.fp);",
          "8335:     int loop_cnt = 0;",
          "8337:     do {",
          "8340:      size_t sf_tosend =",
          "8341:          (size_t)((len < 0x7FFFF000) ? len : 0x7FFFF000);",
          "8342:      sf_sent = sendfile(conn->client.sock,",
          "8343:                         sf_file,",
          "8344:                         &sf_offs,",
          "8345:                         sf_tosend);",
          "8346:      if (sf_sent > 0) {",
          "8347:       len -= sf_sent;",
          "8348:       offset += sf_sent;",
          "8349:      } else if (loop_cnt == 0) {",
          "8354:       break;",
          "8355:      } else if (sf_sent == 0) {",
          "8357:       return;",
          "8358:      }",
          "8359:      loop_cnt++;",
          "8361:     } while ((len > 0) && (sf_sent >= 0));",
          "8370:     offset = (int64_t)sf_offs;",
          "8373:    if ((offset > 0)",
          "8374:        && (fseeko(filep->access.fp, offset, SEEK_SET) != 0)) {",
          "8375:     mg_cry(conn,",
          "8376:            \"%s: fseeko() failed: %s\",",
          "8377:            __func__,",
          "8378:            strerror(ERRNO));",
          "8379:     mg_send_http_error(",
          "8380:         conn,",
          "8381:         500,",
          "8382:         \"%s\",",
          "8383:         \"Error: Unable to access file at requested position.\");",
          "8384:    } else {",
          "8385:     while (len > 0) {",
          "8387:      to_read = sizeof(buf);",
          "8388:      if ((int64_t)to_read > len) {",
          "8389:       to_read = (int)len;",
          "8390:      }",
          "8393:      if ((num_read = (int)fread(",
          "8394:               buf, 1, (size_t)to_read, filep->access.fp)) <= 0) {",
          "8395:       break;",
          "8396:      }",
          "8399:      if ((num_written = mg_write(conn, buf, (size_t)num_read))",
          "8400:          != num_read) {",
          "8401:       break;",
          "8402:      }",
          "8405:      len -= num_written;",
          "8406:     }",
          "8412:  static int parse_range_header(const char *header, int64_t *a, int64_t *b)",
          "8413:  {",
          "8414:   return sscanf(header, \"bytes=%\" INT64_FMT \"-%\" INT64_FMT, a, b);",
          "8415:  }",
          "8418:  static void construct_etag(char *buf,",
          "8419:                             size_t buf_len,",
          "8420:                             const struct mg_file_stat *filestat)",
          "8421:  {",
          "8422:   if ((filestat != NULL) && (buf != NULL)) {",
          "8423:    mg_snprintf(",
          "8424:        NULL,",
          "8426:        buf,",
          "8427:        buf_len,",
          "8428:        \"\\\"%lx.%\" INT64_FMT \"\\\"\",",
          "8429:        (unsigned long)filestat->last_modified,",
          "8430:        filestat->size);",
          "8431:   }",
          "8435:  static void fclose_on_exec(struct mg_file_access * filep,",
          "8436:                             struct mg_connection * conn)",
          "8437:  {",
          "8438:   if (filep != NULL && filep->fp != NULL) {",
          "",
          "---------------",
          "--- Hunk 44 ---",
          "[Context before]",
          "8439:           strerror(ERRNO));",
          "8440:   }",
          "8441: #endif",
          "8442:  }",
          "8496:    return;",
          "8497:   }",
          "8522:    mg_send_http_error(",
          "8523:        conn,",
          "8529:    return;",
          "8530:   }",
          "8674:     return;",
          "8675:    }",
          "8685:   } else {",
          "8688:   }",
          "8726:   }",
          "8731:   }",
          "8732:  }",
          "8744:  }",
          "8759:  }",
          "8774:  }",
          "8795:  }",
          "8824:   }",
          "8825:  }",
          "8838:   }",
          "8839:  }",
          "8860:   }",
          "8864:   }",
          "8868:   }",
          "8883:   }",
          "8893:   }",
          "8898:   }",
          "8899:  }",
          "8991:  }",
          "9015:  }",
          "9117:  }",
          "9187:   }",
          "9199:    return -1;",
          "9200:   }",
          "9211:    return -1;",
          "9212:   }",
          "9216:   } else {",
          "9218:   }",
          "9224:     return -1;",
          "9225:    }",
          "9227:   }",
          "9234: #if !defined(NO_CACHING)",
          "9252: #if !defined(NO_CGI) || !defined(NO_FILES)",
          "9295:   }",
          "9311:    }",
          "9327:    }",
          "9330:      break;",
          "9331:     }",
          "9332:    }",
          "9346:   }",
          "9351: #endif",
          "9353: #if !defined(NO_CGI)",
          "9407:    }",
          "9462:  }",
          "9495: #if defined(USE_IPV6)",
          "9499: #endif",
          "9527:    }",
          "9528:   }",
          "9570: #if defined(_WIN32)",
          "9586: #else",
          "9587:  if ((s = getenv(\"LD_LIBRARY_PATH\")) != NULL) {",
          "9588:   addenv(env, \"LD_LIBRARY_PATH=%s\", s);",
          "9589:  }",
          "9617:   }",
          "9625:   }",
          "9690:  }",
          "9786:    mg_cry(conn,",
          "9789:    goto done;",
          "9790:   }",
          "9823:    mg_cry(conn,",
          "9826:           prog,",
          "9829:    mg_send_http_error(conn,",
          "9830:                       500,",
          "9833:                       prog,",
          "9837:    mg_cry(conn,",
          "9844:    mg_send_http_error(conn,",
          "9845:                       500,",
          "9908:   }",
          "9909: #endif",
          "9938:  }",
          "9943: #if !defined(NO_FILES)",
          "10001:    mg_send_http_error(",
          "10002:        conn, 405, \"Error: mkcol(%s): %s\", path, strerror(ERRNO));",
          "10012:   }",
          "10029:  }",
          "10059:    } else {",
          "10066:    }",
          "10067:   }",
          "10076:   gmt_time_string(date, sizeof(date), &curtime);",
          "10077:   mg_printf(conn,",
          "10078:             \"HTTP/1.1 %d %s\\r\\n\",",
          "",
          "[Removed Lines]",
          "8443: }",
          "8446: static void",
          "8447: handle_static_file_request(struct mg_connection *conn,",
          "8448:                            const char *path,",
          "8449:                            struct mg_file *filep,",
          "8450:                            const char *mime_type,",
          "8451:                            const char *additional_headers)",
          "8452: {",
          "8453:  char date[64], lm[64], etag[64];",
          "8455:  const char *msg = \"OK\", *hdr;",
          "8456:  time_t curtime = time(NULL);",
          "8457:  int64_t cl, r1, r2;",
          "8458:  struct vec mime_vec;",
          "8459:  int n, truncated;",
          "8460:  char gz_path[PATH_MAX];",
          "8461:  const char *encoding = \"\";",
          "8462:  const char *cors1, *cors2, *cors3;",
          "8464:  if ((conn == NULL) || (conn->ctx == NULL) || (filep == NULL)) {",
          "8465:   return;",
          "8466:  }",
          "8468:  if (mime_type == NULL) {",
          "8469:   get_mime_type(conn->ctx, path, &mime_vec);",
          "8470:  } else {",
          "8471:   mime_vec.ptr = mime_type;",
          "8472:   mime_vec.len = strlen(mime_type);",
          "8473:  }",
          "8474:  if (filep->stat.size > INT64_MAX) {",
          "8475:   mg_send_http_error(conn,",
          "8476:                      500,",
          "8477:                      \"Error: File size is too large to send\\n%\" INT64_FMT,",
          "8478:                      filep->stat.size);",
          "8479:   return;",
          "8480:  }",
          "8481:  cl = (int64_t)filep->stat.size;",
          "8482:  conn->status_code = 200;",
          "8483:  range[0] = '\\0';",
          "8488:  if (filep->stat.is_gzipped) {",
          "8489:   mg_snprintf(conn, &truncated, gz_path, sizeof(gz_path), \"%s.gz\", path);",
          "8491:   if (truncated) {",
          "8492:    mg_send_http_error(conn,",
          "8493:                       500,",
          "8494:                       \"Error: Path of zipped file too long (%s)\",",
          "8495:                       path);",
          "8499:   path = gz_path;",
          "8500:   encoding = \"Content-Encoding: gzip\\r\\n\";",
          "8501:  }",
          "8503:  if (!mg_fopen(conn, path, MG_FOPEN_MODE_READ, filep)) {",
          "8504:   mg_send_http_error(conn,",
          "8505:                      500,",
          "8506:                      \"Error: Cannot open file\\nfopen(%s): %s\",",
          "8507:                      path,",
          "8508:                      strerror(ERRNO));",
          "8509:   return;",
          "8510:  }",
          "8512:  fclose_on_exec(&filep->access, conn);",
          "8515:  r1 = r2 = 0;",
          "8516:  hdr = mg_get_header(conn, \"Range\");",
          "8517:  if ((hdr != NULL) && ((n = parse_range_header(hdr, &r1, &r2)) > 0)",
          "8518:      && (r1 >= 0) && (r2 >= 0)) {",
          "8521:   if (filep->stat.is_gzipped) {",
          "8525:        \"%s\",",
          "8526:        \"Error: Range requests in gzipped files are not supported\");",
          "8527:    (void)mg_fclose(",
          "8531:   conn->status_code = 206;",
          "8532:   cl = (n == 2) ? (((r2 > cl) ? cl : r2) - r1 + 1) : (cl - r1);",
          "8533:   mg_snprintf(conn,",
          "8535:               range,",
          "8536:               sizeof(range),",
          "8537:               \"Content-Range: bytes \"",
          "8538:               \"%\" INT64_FMT \"-%\" INT64_FMT \"/%\" INT64_FMT \"\\r\\n\",",
          "8539:               r1,",
          "8540:               r1 + cl - 1,",
          "8541:               filep->stat.size);",
          "8542:   msg = \"Partial Content\";",
          "8543:  }",
          "8545:  hdr = mg_get_header(conn, \"Origin\");",
          "8546:  if (hdr) {",
          "8551:   cors1 = \"Access-Control-Allow-Origin: \";",
          "8552:   cors2 = conn->ctx->config[ACCESS_CONTROL_ALLOW_ORIGIN];",
          "8553:   cors3 = \"\\r\\n\";",
          "8554:  } else {",
          "8555:   cors1 = cors2 = cors3 = \"\";",
          "8556:  }",
          "8560:  gmt_time_string(date, sizeof(date), &curtime);",
          "8561:  gmt_time_string(lm, sizeof(lm), &filep->stat.last_modified);",
          "8562:  construct_etag(etag, sizeof(etag), &filep->stat);",
          "8564:  (void)mg_printf(conn,",
          "8565:                  \"HTTP/1.1 %d %s\\r\\n\"",
          "8566:                  \"%s%s%s\"",
          "8567:                  \"Date: %s\\r\\n\",",
          "8568:                  conn->status_code,",
          "8569:                  msg,",
          "8570:                  cors1,",
          "8571:                  cors2,",
          "8572:                  cors3,",
          "8573:                  date);",
          "8574:  send_static_cache_header(conn);",
          "8575:  send_additional_header(conn);",
          "8576:  (void)mg_printf(conn,",
          "8577:                  \"Last-Modified: %s\\r\\n\"",
          "8578:                  \"Etag: %s\\r\\n\"",
          "8579:                  \"Content-Type: %.*s\\r\\n\"",
          "8580:                  \"Content-Length: %\" INT64_FMT \"\\r\\n\"",
          "8581:                  \"Connection: %s\\r\\n\"",
          "8582:                  \"Accept-Ranges: bytes\\r\\n\"",
          "8583:                  \"%s%s\",",
          "8584:                  lm,",
          "8585:                  etag,",
          "8586:                  (int)mime_vec.len,",
          "8587:                  mime_vec.ptr,",
          "8588:                  cl,",
          "8589:                  suggest_connection_header(conn),",
          "8590:                  range,",
          "8591:                  encoding);",
          "8596:  if (additional_headers != NULL) {",
          "8597:   (void)mg_printf(conn,",
          "8598:                   \"%.*s\\r\\n\\r\\n\",",
          "8599:                   (int)strlen(additional_headers),",
          "8600:                   additional_headers);",
          "8601:  } else {",
          "8602:   (void)mg_printf(conn, \"\\r\\n\");",
          "8603:  }",
          "8605:  if (strcmp(conn->request_info.request_method, \"HEAD\") != 0) {",
          "8606:   send_file_data(conn, filep, r1, cl);",
          "8607:  }",
          "8609: }",
          "8612: #if !defined(NO_CACHING)",
          "8613: static void",
          "8614: handle_not_modified_static_file_request(struct mg_connection *conn,",
          "8615:                                         struct mg_file *filep)",
          "8616: {",
          "8617:  char date[64], lm[64], etag[64];",
          "8618:  time_t curtime = time(NULL);",
          "8620:  if ((conn == NULL) || (filep == NULL)) {",
          "8621:   return;",
          "8622:  }",
          "8623:  conn->status_code = 304;",
          "8624:  gmt_time_string(date, sizeof(date), &curtime);",
          "8625:  gmt_time_string(lm, sizeof(lm), &filep->stat.last_modified);",
          "8626:  construct_etag(etag, sizeof(etag), &filep->stat);",
          "8628:  (void)mg_printf(conn,",
          "8629:                  \"HTTP/1.1 %d %s\\r\\n\"",
          "8630:                  \"Date: %s\\r\\n\",",
          "8631:                  conn->status_code,",
          "8632:                  mg_get_response_code_text(conn, conn->status_code),",
          "8633:                  date);",
          "8634:  send_static_cache_header(conn);",
          "8635:  send_additional_header(conn);",
          "8636:  (void)mg_printf(conn,",
          "8637:                  \"Last-Modified: %s\\r\\n\"",
          "8638:                  \"Etag: %s\\r\\n\"",
          "8639:                  \"Connection: %s\\r\\n\"",
          "8640:                  \"\\r\\n\",",
          "8641:                  lm,",
          "8642:                  etag,",
          "8643:                  suggest_connection_header(conn));",
          "8644: }",
          "8645: #endif",
          "8648: void",
          "8649: mg_send_file(struct mg_connection *conn, const char *path)",
          "8650: {",
          "8651:  mg_send_mime_file(conn, path, NULL);",
          "8652: }",
          "8655: void",
          "8656: mg_send_mime_file(struct mg_connection *conn,",
          "8657:                   const char *path,",
          "8658:                   const char *mime_type)",
          "8659: {",
          "8660:  mg_send_mime_file2(conn, path, mime_type, NULL);",
          "8661: }",
          "8664: void",
          "8665: mg_send_mime_file2(struct mg_connection *conn,",
          "8666:                    const char *path,",
          "8667:                    const char *mime_type,",
          "8668:                    const char *additional_headers)",
          "8669: {",
          "8670:  struct mg_file file = STRUCT_FILE_INITIALIZER;",
          "8671:  if (mg_stat(conn, path, &file.stat)) {",
          "8672:   if (file.stat.is_directory) {",
          "8673:    if (!conn) {",
          "8676:    if (!mg_strcasecmp(conn->ctx->config[ENABLE_DIRECTORY_LISTING],",
          "8677:                       \"yes\")) {",
          "8678:     handle_directory_request(conn, path);",
          "8679:    } else {",
          "8680:     mg_send_http_error(conn,",
          "8681:                        403,",
          "8682:                        \"%s\",",
          "8683:                        \"Error: Directory listing denied\");",
          "8684:    }",
          "8686:    handle_static_file_request(",
          "8687:        conn, path, &file, mime_type, additional_headers);",
          "8689:  } else {",
          "8690:   mg_send_http_error(conn, 404, \"%s\", \"Error: File not found\");",
          "8691:  }",
          "8692: }",
          "8701: static int",
          "8702: put_dir(struct mg_connection *conn, const char *path)",
          "8703: {",
          "8704:  char buf[PATH_MAX];",
          "8705:  const char *s, *p;",
          "8706:  struct mg_file file = STRUCT_FILE_INITIALIZER;",
          "8707:  size_t len;",
          "8708:  int res = 1;",
          "8710:  for (s = p = path + 2; (p = strchr(s, '/')) != NULL; s = ++p) {",
          "8711:   len = (size_t)(p - path);",
          "8712:   if (len >= sizeof(buf)) {",
          "8714:    res = -1;",
          "8715:    break;",
          "8716:   }",
          "8717:   memcpy(buf, path, len);",
          "8718:   buf[len] = '\\0';",
          "8721:   DEBUG_TRACE(\"mkdir(%s)\", buf);",
          "8722:   if (!mg_stat(conn, buf, &file.stat) && mg_mkdir(conn, buf, 0755) != 0) {",
          "8724:    res = -2;",
          "8725:    break;",
          "8729:   if (p[1] == '\\0') {",
          "8730:    res = 0;",
          "8734:  return res;",
          "8735: }",
          "8738: static void",
          "8739: remove_bad_file(const struct mg_connection *conn, const char *path)",
          "8740: {",
          "8741:  int r = mg_remove(conn, path);",
          "8742:  if (r != 0) {",
          "8743:   mg_cry(conn, \"%s: Cannot remove invalid file %s\", __func__, path);",
          "8745: }",
          "8748: long long",
          "8749: mg_store_body(struct mg_connection *conn, const char *path)",
          "8750: {",
          "8751:  char buf[MG_BUF_LEN];",
          "8752:  long long len = 0;",
          "8753:  int ret, n;",
          "8754:  struct mg_file fi;",
          "8756:  if (conn->consumed_content != 0) {",
          "8757:   mg_cry(conn, \"%s: Contents already consumed\", __func__);",
          "8758:   return -11;",
          "8761:  ret = put_dir(conn, path);",
          "8762:  if (ret < 0) {",
          "8765:   return ret;",
          "8766:  }",
          "8767:  if (ret != 1) {",
          "8769:   return 0;",
          "8770:  }",
          "8772:  if (mg_fopen(conn, path, MG_FOPEN_MODE_WRITE, &fi) == 0) {",
          "8773:   return -12;",
          "8776:  ret = mg_read(conn, buf, sizeof(buf));",
          "8777:  while (ret > 0) {",
          "8778:   n = (int)fwrite(buf, 1, (size_t)ret, fi.access.fp);",
          "8779:   if (n != ret) {",
          "8780:    (void)mg_fclose(",
          "8782:    remove_bad_file(conn, path);",
          "8783:    return -13;",
          "8784:   }",
          "8785:   len += ret;",
          "8786:   ret = mg_read(conn, buf, sizeof(buf));",
          "8787:  }",
          "8792:  if (mg_fclose(&fi.access) != 0) {",
          "8793:   remove_bad_file(conn, path);",
          "8794:   return -14;",
          "8797:  return len;",
          "8798: }",
          "8805: static int",
          "8806: skip_to_end_of_word_and_terminate(char **ppw, int eol)",
          "8807: {",
          "8810:  while (isgraph(**ppw)) {",
          "8811:   (*ppw)++;",
          "8812:  }",
          "8815:  if (eol) {",
          "8817:   if ((**ppw != '\\r') && (**ppw != '\\n')) {",
          "8818:    return -1;",
          "8819:   }",
          "8820:  } else {",
          "8822:   if (**ppw != ' ') {",
          "8823:    return -1;",
          "8828:  do {",
          "8830:   (*ppw)++;",
          "8831:  } while ((**ppw) && isspace(**ppw));",
          "8834:  if (!eol) {",
          "8836:   if (!isgraph(**ppw)) {",
          "8837:    return -1;",
          "8842:  return 1;",
          "8843: }",
          "8850: static int",
          "8851: parse_http_headers(char **buf, struct mg_header hdr[MG_MAX_HEADERS])",
          "8852: {",
          "8853:  int i;",
          "8854:  int num_headers = 0;",
          "8856:  for (i = 0; i < (int)MG_MAX_HEADERS; i++) {",
          "8857:   char *dp = *buf;",
          "8858:   while ((*dp != ':') && (*dp >= 33) && (*dp <= 126)) {",
          "8859:    dp++;",
          "8861:   if (dp == *buf) {",
          "8863:    break;",
          "8865:   if (*dp != ':') {",
          "8867:    return -1;",
          "8873:   hdr[i].name = *buf;",
          "8874:   do {",
          "8875:    dp++;",
          "8876:   } while (*dp == ' ');",
          "8879:   hdr[i].value = dp;",
          "8881:   if (((*buf)[0] != '\\r') || ((*buf)[1] != '\\n')) {",
          "8885:   num_headers = i + 1;",
          "8886:   if (*buf) {",
          "8887:    (*buf)[0] = 0;",
          "8888:    (*buf)[1] = 0;",
          "8890:   } else {",
          "8892:    break;",
          "8895:   if ((*buf)[0] == '\\r') {",
          "8897:    break;",
          "8900:  return num_headers;",
          "8901: }",
          "8904: static int",
          "8905: is_valid_http_method(const char *method)",
          "8906: {",
          "8943:      ;",
          "8944: }",
          "8956: static int",
          "8957: parse_http_request(char *buf, int len, struct mg_request_info *ri)",
          "8958: {",
          "8959:  int request_length;",
          "8960:  int init_skip = 0;",
          "8964:  ri->remote_user = ri->request_method = ri->request_uri = ri->http_version =",
          "8965:      NULL;",
          "8966:  ri->num_headers = 0;",
          "8971:  while ((len > 0) && isspace(*(unsigned char *)buf)) {",
          "8972:   buf++;",
          "8973:   len--;",
          "8974:   init_skip++;",
          "8975:  }",
          "8977:  if (len == 0) {",
          "8979:   return 0;",
          "8980:  }",
          "8983:  if (iscntrl(*(unsigned char *)buf)) {",
          "8984:   return -1;",
          "8985:  }",
          "8988:  request_length = get_http_header_len(buf, len);",
          "8989:  if (request_length <= 0) {",
          "8990:   return request_length;",
          "8992:  buf[request_length - 1] = '\\0';",
          "8994:  if ((*buf == 0) || (*buf == '\\r') || (*buf == '\\n')) {",
          "8995:   return -1;",
          "8996:  }",
          "8999:  ri->request_method = buf;",
          "9001:  if (skip_to_end_of_word_and_terminate(&buf, 0) <= 0) {",
          "9002:   return -1;",
          "9003:  }",
          "9006:  if (!is_valid_http_method(ri->request_method)) {",
          "9007:   return -1;",
          "9008:  }",
          "9011:  ri->request_uri = buf;",
          "9013:  if (skip_to_end_of_word_and_terminate(&buf, 0) <= 0) {",
          "9014:   return -1;",
          "9018:  ri->http_version = buf;",
          "9020:  if (skip_to_end_of_word_and_terminate(&buf, 1) <= 0) {",
          "9021:   return -1;",
          "9022:  }",
          "9025:  if (strncmp(ri->http_version, \"HTTP/\", 5) != 0) {",
          "9027:   return -1;",
          "9028:  }",
          "9029:  ri->http_version += 5;",
          "9033:  ri->num_headers = parse_http_headers(&buf, ri->http_headers);",
          "9034:  if (ri->num_headers < 0) {",
          "9036:   return -1;",
          "9037:  }",
          "9039:  return request_length + init_skip;",
          "9040: }",
          "9043: static int",
          "9044: parse_http_response(char *buf, int len, struct mg_response_info *ri)",
          "9045: {",
          "9046:  int response_length;",
          "9047:  int init_skip = 0;",
          "9048:  char *tmp, *tmp2;",
          "9049:  long l;",
          "9052:  ri->http_version = ri->status_text = NULL;",
          "9053:  ri->num_headers = ri->status_code = 0;",
          "9058:  while ((len > 0) && isspace(*(unsigned char *)buf)) {",
          "9059:   buf++;",
          "9060:   len--;",
          "9061:   init_skip++;",
          "9062:  }",
          "9064:  if (len == 0) {",
          "9066:   return 0;",
          "9067:  }",
          "9070:  if (iscntrl(*(unsigned char *)buf)) {",
          "9071:   return -1;",
          "9072:  }",
          "9075:  response_length = get_http_header_len(buf, len);",
          "9076:  if (response_length <= 0) {",
          "9077:   return response_length;",
          "9078:  }",
          "9079:  buf[response_length - 1] = '\\0';",
          "9083:  (void)buf;",
          "9084:  (void)len;",
          "9085:  (void)ri;",
          "9088:  while ((*buf != '\\0') && isspace(*(unsigned char *)buf)) {",
          "9089:   buf++;",
          "9090:  }",
          "9091:  if ((*buf == 0) || (*buf == '\\r') || (*buf == '\\n')) {",
          "9092:   return -1;",
          "9093:  }",
          "9097:  if (strncmp(buf, \"HTTP/\", 5) != 0) {",
          "9099:   return -1;",
          "9100:  }",
          "9101:  buf += 5;",
          "9102:  if (!isgraph(buf[0])) {",
          "9104:   return -1;",
          "9105:  }",
          "9106:  ri->http_version = buf;",
          "9108:  if (skip_to_end_of_word_and_terminate(&buf, 0) <= 0) {",
          "9109:   return -1;",
          "9110:  }",
          "9113:  tmp = buf;",
          "9115:  if (skip_to_end_of_word_and_terminate(&buf, 0) <= 0) {",
          "9116:   return -1;",
          "9119:  l = strtol(tmp, &tmp2, 10);",
          "9120:  if ((l < 100) || (l >= 1000) || ((tmp2 - tmp) != 3) || (*tmp2 != 0)) {",
          "9122:   return -1;",
          "9123:  }",
          "9124:  ri->status_code = (int)l;",
          "9127:  ri->status_text = buf;",
          "9131:  while (isprint(*buf)) {",
          "9132:   buf++;",
          "9133:  }",
          "9134:  if ((*buf != '\\r') && (*buf != '\\n')) {",
          "9135:   return -1;",
          "9136:  }",
          "9138:  do {",
          "9140:   buf++;",
          "9141:  } while ((*buf) && isspace(*buf));",
          "9145:  ri->num_headers = parse_http_headers(&buf, ri->http_headers);",
          "9146:  if (ri->num_headers < 0) {",
          "9148:   return -1;",
          "9149:  }",
          "9151:  return response_length + init_skip;",
          "9152: }",
          "9160: static int",
          "9161: read_message(FILE *fp,",
          "9162:              struct mg_connection *conn,",
          "9163:              char *buf,",
          "9164:              int bufsiz,",
          "9165:              int *nread)",
          "9166: {",
          "9167:  int request_len, n = 0;",
          "9168:  struct timespec last_action_time;",
          "9169:  double request_timeout;",
          "9171:  if (!conn) {",
          "9172:   return 0;",
          "9173:  }",
          "9175:  memset(&last_action_time, 0, sizeof(last_action_time));",
          "9177:  if (conn->ctx->config[REQUEST_TIMEOUT]) {",
          "9179:   request_timeout = atof(conn->ctx->config[REQUEST_TIMEOUT]) / 1000.0;",
          "9180:  } else {",
          "9181:   request_timeout = -1.0;",
          "9182:  }",
          "9183:  if (conn->handled_requests > 0) {",
          "9184:   if (conn->ctx->config[KEEP_ALIVE_TIMEOUT]) {",
          "9185:    request_timeout =",
          "9186:        atof(conn->ctx->config[KEEP_ALIVE_TIMEOUT]) / 1000.0;",
          "9188:  }",
          "9190:  request_len = get_http_header_len(buf, *nread);",
          "9193:  clock_gettime(CLOCK_MONOTONIC, &last_action_time);",
          "9195:  while (request_len == 0) {",
          "9197:   if (conn->ctx->stop_flag != 0) {",
          "9202:   if (*nread >= bufsiz) {",
          "9204:    return -2;",
          "9205:   }",
          "9207:   n = pull_inner(",
          "9208:       fp, conn, buf + *nread, bufsiz - *nread, request_timeout);",
          "9209:   if (n == -2) {",
          "9213:   if (n > 0) {",
          "9215:    request_len = get_http_header_len(buf, *nread);",
          "9217:    request_len = 0;",
          "9220:   if ((request_len == 0) && (request_timeout >= 0)) {",
          "9221:    if (mg_difftimespec(&last_action_time, &(conn->req_time))",
          "9222:        > request_timeout) {",
          "9226:    clock_gettime(CLOCK_MONOTONIC, &last_action_time);",
          "9228:  }",
          "9230:  return request_len;",
          "9231: }",
          "9236: static int",
          "9237: is_not_modified(const struct mg_connection *conn,",
          "9238:                 const struct mg_file_stat *filestat)",
          "9239: {",
          "9240:  char etag[64];",
          "9241:  const char *ims = mg_get_header(conn, \"If-Modified-Since\");",
          "9242:  const char *inm = mg_get_header(conn, \"If-None-Match\");",
          "9243:  construct_etag(etag, sizeof(etag), filestat);",
          "9245:  return ((inm != NULL) && !mg_strcasecmp(etag, inm))",
          "9246:         || ((ims != NULL)",
          "9247:             && (filestat->last_modified <= parse_date_string(ims)));",
          "9248: }",
          "9253: static int",
          "9254: forward_body_data(struct mg_connection *conn, FILE *fp, SOCKET sock, SSL *ssl)",
          "9255: {",
          "9256:  const char *expect, *body;",
          "9257:  char buf[MG_BUF_LEN];",
          "9258:  int to_read, nread, success = 0;",
          "9259:  int64_t buffered_len;",
          "9260:  double timeout = -1.0;",
          "9262:  if (!conn) {",
          "9263:   return 0;",
          "9264:  }",
          "9265:  if (conn->ctx->config[REQUEST_TIMEOUT]) {",
          "9266:   timeout = atoi(conn->ctx->config[REQUEST_TIMEOUT]) / 1000.0;",
          "9267:  }",
          "9269:  expect = mg_get_header(conn, \"Expect\");",
          "9271:  if (!fp) {",
          "9272:   mg_send_http_error(conn, 500, \"%s\", \"Error: NULL File\");",
          "9273:   return 0;",
          "9274:  }",
          "9276:  if ((conn->content_len == -1) && !conn->is_chunked) {",
          "9278:   mg_send_http_error(conn,",
          "9279:                      411,",
          "9280:                      \"%s\",",
          "9281:                      \"Error: Client did not specify content length\");",
          "9282:  } else if ((expect != NULL)",
          "9283:             && (mg_strcasecmp(expect, \"100-continue\") != 0)) {",
          "9285:   mg_send_http_error(conn,",
          "9286:                      417,",
          "9287:                      \"Error: Can not fulfill expectation %s\",",
          "9288:                      expect);",
          "9289:  } else {",
          "9290:   if (expect != NULL) {",
          "9291:    (void)mg_printf(conn, \"%s\", \"HTTP/1.1 100 Continue\\r\\n\\r\\n\");",
          "9292:    conn->status_code = 100;",
          "9293:   } else {",
          "9294:    conn->status_code = 200;",
          "9297:   buffered_len = (int64_t)(conn->data_len) - (int64_t)conn->request_len",
          "9298:                  - conn->consumed_content;",
          "9303:   if ((buffered_len < 0) || (conn->consumed_content != 0)) {",
          "9304:    mg_send_http_error(conn, 500, \"%s\", \"Error: Size mismatch\");",
          "9305:    return 0;",
          "9306:   }",
          "9308:   if (buffered_len > 0) {",
          "9309:    if ((int64_t)buffered_len > conn->content_len) {",
          "9310:     buffered_len = (int)conn->content_len;",
          "9312:    body = conn->buf + conn->request_len + conn->consumed_content;",
          "9313:    push_all(conn->ctx, fp, sock, ssl, body, (int64_t)buffered_len);",
          "9314:    conn->consumed_content += buffered_len;",
          "9315:   }",
          "9317:   nread = 0;",
          "9318:   while (conn->consumed_content < conn->content_len) {",
          "9319:    to_read = sizeof(buf);",
          "9320:    if ((int64_t)to_read > conn->content_len - conn->consumed_content) {",
          "9321:     to_read = (int)(conn->content_len - conn->consumed_content);",
          "9322:    }",
          "9323:    nread = pull_inner(NULL, conn, buf, to_read, timeout);",
          "9324:    if (nread == -2) {",
          "9326:     break;",
          "9328:    if (nread > 0) {",
          "9329:     if (push_all(conn->ctx, fp, sock, ssl, buf, nread) != nread) {",
          "9333:    conn->consumed_content += nread;",
          "9334:   }",
          "9336:   if (conn->consumed_content == conn->content_len) {",
          "9337:    success = (nread >= 0);",
          "9338:   }",
          "9341:   if (!success) {",
          "9345:    mg_send_http_error(conn, 500, \"%s\", \"\");",
          "9347:  }",
          "9349:  return success;",
          "9350: }",
          "9362: struct cgi_environment {",
          "9363:  struct mg_connection *conn;",
          "9372: };",
          "9375: static void addenv(struct cgi_environment *env,",
          "9376:                    PRINTF_FORMAT_STRING(const char *fmt),",
          "9377:                    ...) PRINTF_ARGS(2, 3);",
          "9381: static void",
          "9382: addenv(struct cgi_environment *env, const char *fmt, ...)",
          "9383: {",
          "9384:  size_t n, space;",
          "9385:  int truncated = 0;",
          "9386:  char *added;",
          "9387:  va_list ap;",
          "9390:  space = (env->buflen - env->bufused);",
          "9393:  n = strlen(fmt) + 2 + 128;",
          "9395:  do {",
          "9396:   if (space <= n) {",
          "9398:    n = env->buflen + CGI_ENVIRONMENT_SIZE;",
          "9399:    added = (char *)mg_realloc_ctx(env->buf, n, env->conn->ctx);",
          "9400:    if (!added) {",
          "9402:     mg_cry(env->conn,",
          "9403:            \"%s: Cannot allocate memory for CGI variable [%s]\",",
          "9404:            __func__,",
          "9405:            fmt);",
          "9406:     return;",
          "9408:    env->buf = added;",
          "9409:    env->buflen = n;",
          "9410:    space = (env->buflen - env->bufused);",
          "9411:   }",
          "9414:   added = env->buf + env->bufused;",
          "9417:   va_start(ap, fmt);",
          "9418:   mg_vsnprintf(env->conn, &truncated, added, (size_t)space, fmt, ap);",
          "9419:   va_end(ap);",
          "9422:   if (truncated) {",
          "9424:    space = 0;",
          "9425:    n = 1;",
          "9426:   }",
          "9427:  } while (truncated);",
          "9430:  n = strlen(added) + 1;",
          "9431:  env->bufused += n;",
          "9434:  space = (env->varlen - env->varused);",
          "9435:  if (space < 2) {",
          "9436:   mg_cry(env->conn,",
          "9437:          \"%s: Cannot register CGI variable [%s]\",",
          "9438:          __func__,",
          "9439:          fmt);",
          "9440:   return;",
          "9441:  }",
          "9444:  env->var[env->varused] = added;",
          "9445:  env->varused++;",
          "9446: }",
          "9450: static int",
          "9451: prepare_cgi_environment(struct mg_connection *conn,",
          "9452:                         const char *prog,",
          "9453:                         struct cgi_environment *env)",
          "9454: {",
          "9455:  const char *s;",
          "9456:  struct vec var_vec;",
          "9457:  char *p, src_addr[IP_ADDR_STR_LEN], http_var_name[128];",
          "9458:  int i, truncated, uri_len;",
          "9460:  if ((conn == NULL) || (prog == NULL) || (env == NULL)) {",
          "9461:   return -1;",
          "9464:  env->conn = conn;",
          "9465:  env->buflen = CGI_ENVIRONMENT_SIZE;",
          "9466:  env->bufused = 0;",
          "9467:  env->buf = (char *)mg_malloc_ctx(env->buflen, conn->ctx);",
          "9468:  if (env->buf == NULL) {",
          "9469:   mg_cry(conn,",
          "9470:          \"%s: Not enough memory for environmental buffer\",",
          "9471:          __func__);",
          "9472:   return -1;",
          "9473:  }",
          "9474:  env->varlen = MAX_CGI_ENVIR_VARS;",
          "9475:  env->varused = 0;",
          "9476:  env->var = (char **)mg_malloc_ctx(env->buflen * sizeof(char *), conn->ctx);",
          "9477:  if (env->var == NULL) {",
          "9478:   mg_cry(conn,",
          "9479:          \"%s: Not enough memory for environmental variables\",",
          "9480:          __func__);",
          "9481:   mg_free(env->buf);",
          "9482:   return -1;",
          "9483:  }",
          "9485:  addenv(env, \"SERVER_NAME=%s\", conn->ctx->config[AUTHENTICATION_DOMAIN]);",
          "9486:  addenv(env, \"SERVER_ROOT=%s\", conn->ctx->config[DOCUMENT_ROOT]);",
          "9487:  addenv(env, \"DOCUMENT_ROOT=%s\", conn->ctx->config[DOCUMENT_ROOT]);",
          "9488:  addenv(env, \"SERVER_SOFTWARE=%s/%s\", \"Civetweb\", mg_version());",
          "9491:  addenv(env, \"%s\", \"GATEWAY_INTERFACE=CGI/1.1\");",
          "9492:  addenv(env, \"%s\", \"SERVER_PROTOCOL=HTTP/1.1\");",
          "9496:  if (conn->client.lsa.sa.sa_family == AF_INET6) {",
          "9497:   addenv(env, \"SERVER_PORT=%d\", ntohs(conn->client.lsa.sin6.sin6_port));",
          "9498:  } else",
          "9500:  {",
          "9501:   addenv(env, \"SERVER_PORT=%d\", ntohs(conn->client.lsa.sin.sin_port));",
          "9502:  }",
          "9504:  sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);",
          "9505:  addenv(env, \"REMOTE_ADDR=%s\", src_addr);",
          "9507:  addenv(env, \"REQUEST_METHOD=%s\", conn->request_info.request_method);",
          "9508:  addenv(env, \"REMOTE_PORT=%d\", conn->request_info.remote_port);",
          "9510:  addenv(env, \"REQUEST_URI=%s\", conn->request_info.request_uri);",
          "9511:  addenv(env, \"LOCAL_URI=%s\", conn->request_info.local_uri);",
          "9514:  uri_len = (int)strlen(conn->request_info.local_uri);",
          "9515:  if (conn->path_info == NULL) {",
          "9516:   if (conn->request_info.local_uri[uri_len - 1] != '/') {",
          "9518:    addenv(env, \"SCRIPT_NAME=%s\", conn->request_info.local_uri);",
          "9519:   } else {",
          "9521:    const char *index_file = strrchr(prog, '/');",
          "9522:    if (index_file) {",
          "9523:     addenv(env,",
          "9524:            \"SCRIPT_NAME=%s%s\",",
          "9525:            conn->request_info.local_uri,",
          "9526:            index_file + 1);",
          "9529:  } else {",
          "9531:   addenv(env,",
          "9532:          \"SCRIPT_NAME=%.*s\",",
          "9533:          uri_len - (int)strlen(conn->path_info),",
          "9534:          conn->request_info.local_uri);",
          "9535:  }",
          "9537:  addenv(env, \"SCRIPT_FILENAME=%s\", prog);",
          "9538:  if (conn->path_info == NULL) {",
          "9539:   addenv(env, \"PATH_TRANSLATED=%s\", conn->ctx->config[DOCUMENT_ROOT]);",
          "9540:  } else {",
          "9541:   addenv(env,",
          "9542:          \"PATH_TRANSLATED=%s%s\",",
          "9543:          conn->ctx->config[DOCUMENT_ROOT],",
          "9544:          conn->path_info);",
          "9545:  }",
          "9547:  addenv(env, \"HTTPS=%s\", (conn->ssl == NULL) ? \"off\" : \"on\");",
          "9549:  if ((s = mg_get_header(conn, \"Content-Type\")) != NULL) {",
          "9550:   addenv(env, \"CONTENT_TYPE=%s\", s);",
          "9551:  }",
          "9552:  if (conn->request_info.query_string != NULL) {",
          "9553:   addenv(env, \"QUERY_STRING=%s\", conn->request_info.query_string);",
          "9554:  }",
          "9555:  if ((s = mg_get_header(conn, \"Content-Length\")) != NULL) {",
          "9556:   addenv(env, \"CONTENT_LENGTH=%s\", s);",
          "9557:  }",
          "9558:  if ((s = getenv(\"PATH\")) != NULL) {",
          "9559:   addenv(env, \"PATH=%s\", s);",
          "9560:  }",
          "9561:  if (conn->path_info != NULL) {",
          "9562:   addenv(env, \"PATH_INFO=%s\", conn->path_info);",
          "9563:  }",
          "9565:  if (conn->status_code > 0) {",
          "9567:   addenv(env, \"STATUS=%d\", conn->status_code);",
          "9568:  }",
          "9571:  if ((s = getenv(\"COMSPEC\")) != NULL) {",
          "9572:   addenv(env, \"COMSPEC=%s\", s);",
          "9573:  }",
          "9574:  if ((s = getenv(\"SYSTEMROOT\")) != NULL) {",
          "9575:   addenv(env, \"SYSTEMROOT=%s\", s);",
          "9576:  }",
          "9577:  if ((s = getenv(\"SystemDrive\")) != NULL) {",
          "9578:   addenv(env, \"SystemDrive=%s\", s);",
          "9579:  }",
          "9580:  if ((s = getenv(\"ProgramFiles\")) != NULL) {",
          "9581:   addenv(env, \"ProgramFiles=%s\", s);",
          "9582:  }",
          "9583:  if ((s = getenv(\"ProgramFiles(x86)\")) != NULL) {",
          "9584:   addenv(env, \"ProgramFiles(x86)=%s\", s);",
          "9585:  }",
          "9592:  if ((s = getenv(\"PERLLIB\")) != NULL) {",
          "9593:   addenv(env, \"PERLLIB=%s\", s);",
          "9594:  }",
          "9596:  if (conn->request_info.remote_user != NULL) {",
          "9597:   addenv(env, \"REMOTE_USER=%s\", conn->request_info.remote_user);",
          "9598:   addenv(env, \"%s\", \"AUTH_TYPE=Digest\");",
          "9599:  }",
          "9602:  for (i = 0; i < conn->request_info.num_headers; i++) {",
          "9604:   (void)mg_snprintf(conn,",
          "9605:                     &truncated,",
          "9606:                     http_var_name,",
          "9607:                     sizeof(http_var_name),",
          "9608:                     \"HTTP_%s\",",
          "9609:                     conn->request_info.http_headers[i].name);",
          "9611:   if (truncated) {",
          "9612:    mg_cry(conn,",
          "9613:           \"%s: HTTP header variable too long [%s]\",",
          "9614:           __func__,",
          "9615:           conn->request_info.http_headers[i].name);",
          "9616:    continue;",
          "9620:   for (p = http_var_name; *p != '\\0'; p++) {",
          "9621:    if (*p == '-') {",
          "9623:    }",
          "9627:   addenv(env,",
          "9628:          \"%s=%s\",",
          "9629:          http_var_name,",
          "9630:          conn->request_info.http_headers[i].value);",
          "9631:  }",
          "9634:  s = conn->ctx->config[CGI_ENVIRONMENT];",
          "9635:  while ((s = next_option(s, &var_vec, NULL)) != NULL) {",
          "9636:   addenv(env, \"%.*s\", (int)var_vec.len, var_vec.ptr);",
          "9637:  }",
          "9639:  env->var[env->varused] = NULL;",
          "9640:  env->buf[env->bufused] = '\\0';",
          "9642:  return 0;",
          "9643: }",
          "9646: static void",
          "9647: handle_cgi_request(struct mg_connection *conn, const char *prog)",
          "9648: {",
          "9649:  char *buf;",
          "9650:  size_t buflen;",
          "9651:  int headers_len, data_len, i, truncated;",
          "9652:  int fdin[2] = {-1, -1}, fdout[2] = {-1, -1}, fderr[2] = {-1, -1};",
          "9653:  const char *status, *status_text, *connection_state;",
          "9654:  char *pbuf, dir[PATH_MAX], *p;",
          "9655:  struct mg_request_info ri;",
          "9656:  struct cgi_environment blk;",
          "9657:  FILE *in = NULL, *out = NULL, *err = NULL;",
          "9658:  struct mg_file fout = STRUCT_FILE_INITIALIZER;",
          "9659:  pid_t pid = (pid_t)-1;",
          "9661:  if (conn == NULL) {",
          "9662:   return;",
          "9663:  }",
          "9665:  buf = NULL;",
          "9666:  buflen = 16384;",
          "9667:  i = prepare_cgi_environment(conn, prog, &blk);",
          "9668:  if (i != 0) {",
          "9669:   blk.buf = NULL;",
          "9670:   blk.var = NULL;",
          "9671:   goto done;",
          "9672:  }",
          "9677:  (void)mg_snprintf(conn, &truncated, dir, sizeof(dir), \"%s\", prog);",
          "9679:  if (truncated) {",
          "9680:   mg_cry(conn, \"Error: CGI program \\\"%s\\\": Path too long\", prog);",
          "9681:   mg_send_http_error(conn, 500, \"Error: %s\", \"CGI path too long\");",
          "9682:   goto done;",
          "9683:  }",
          "9685:  if ((p = strrchr(dir, '/')) != NULL) {",
          "9687:  } else {",
          "9688:   dir[0] = '.', dir[1] = '\\0';",
          "9689:   p = (char *)prog;",
          "9692:  if ((pipe(fdin) != 0) || (pipe(fdout) != 0) || (pipe(fderr) != 0)) {",
          "9693:   status = strerror(ERRNO);",
          "9694:   mg_cry(conn,",
          "9695:          \"Error: CGI program \\\"%s\\\": Can not create CGI pipes: %s\",",
          "9696:          prog,",
          "9697:          status);",
          "9698:   mg_send_http_error(conn,",
          "9699:                      500,",
          "9700:                      \"Error: Cannot create CGI pipe: %s\",",
          "9701:                      status);",
          "9702:   goto done;",
          "9703:  }",
          "9705:  pid = spawn_process(conn, p, blk.buf, blk.var, fdin, fdout, fderr, dir);",
          "9707:  if (pid == (pid_t)-1) {",
          "9708:   status = strerror(ERRNO);",
          "9709:   mg_cry(conn,",
          "9710:          \"Error: CGI program \\\"%s\\\": Can not spawn CGI process: %s\",",
          "9711:          prog,",
          "9712:          status);",
          "9713:   mg_send_http_error(conn,",
          "9714:                      500,",
          "9715:                      \"Error: Cannot spawn CGI process [%s]: %s\",",
          "9716:                      prog,",
          "9717:                      status);",
          "9718:   goto done;",
          "9719:  }",
          "9733:  (void)close(fdin[0]);",
          "9734:  (void)close(fdout[1]);",
          "9735:  (void)close(fderr[1]);",
          "9736:  fdin[0] = fdout[1] = fderr[1] = -1;",
          "9738:  if ((in = fdopen(fdin[1], \"wb\")) == NULL) {",
          "9739:   status = strerror(ERRNO);",
          "9740:   mg_cry(conn,",
          "9741:          \"Error: CGI program \\\"%s\\\": Can not open stdin: %s\",",
          "9742:          prog,",
          "9743:          status);",
          "9744:   mg_send_http_error(conn,",
          "9745:                      500,",
          "9746:                      \"Error: CGI can not open fdin\\nfopen: %s\",",
          "9747:                      status);",
          "9748:   goto done;",
          "9749:  }",
          "9751:  if ((out = fdopen(fdout[0], \"rb\")) == NULL) {",
          "9752:   status = strerror(ERRNO);",
          "9753:   mg_cry(conn,",
          "9754:          \"Error: CGI program \\\"%s\\\": Can not open stdout: %s\",",
          "9755:          prog,",
          "9756:          status);",
          "9757:   mg_send_http_error(conn,",
          "9758:                      500,",
          "9759:                      \"Error: CGI can not open fdout\\nfopen: %s\",",
          "9760:                      status);",
          "9761:   goto done;",
          "9762:  }",
          "9764:  if ((err = fdopen(fderr[0], \"rb\")) == NULL) {",
          "9765:   status = strerror(ERRNO);",
          "9766:   mg_cry(conn,",
          "9767:          \"Error: CGI program \\\"%s\\\": Can not open stderr: %s\",",
          "9768:          prog,",
          "9769:          status);",
          "9770:   mg_send_http_error(conn,",
          "9771:                      500,",
          "9772:                      \"Error: CGI can not open fdout\\nfopen: %s\",",
          "9773:                      status);",
          "9774:   goto done;",
          "9775:  }",
          "9777:  setbuf(in, NULL);",
          "9778:  setbuf(out, NULL);",
          "9779:  setbuf(err, NULL);",
          "9780:  fout.access.fp = out;",
          "9782:  if ((conn->request_info.content_length > 0) || conn->is_chunked) {",
          "9784:   if (!forward_body_data(conn, in, INVALID_SOCKET, NULL)) {",
          "9787:           \"Error: CGI program \\\"%s\\\": Forward body data failed\",",
          "9788:           prog);",
          "9791:  }",
          "9794:  fclose(in);",
          "9795:  in = NULL;",
          "9796:  fdin[1] = -1;",
          "9802:  data_len = 0;",
          "9803:  buf = (char *)mg_malloc_ctx(buflen, conn->ctx);",
          "9804:  if (buf == NULL) {",
          "9805:   mg_send_http_error(conn,",
          "9806:                      500,",
          "9807:                      \"Error: Not enough memory for CGI buffer (%u bytes)\",",
          "9808:                      (unsigned int)buflen);",
          "9809:   mg_cry(conn,",
          "9810:          \"Error: CGI program \\\"%s\\\": Not enough memory for buffer (%u \"",
          "9811:          \"bytes)\",",
          "9812:          prog,",
          "9813:          (unsigned int)buflen);",
          "9814:   goto done;",
          "9815:  }",
          "9816:  headers_len = read_message(out, conn, buf, (int)buflen, &data_len);",
          "9817:  if (headers_len <= 0) {",
          "9821:   i = pull_all(err, conn, buf, (int)buflen);",
          "9822:   if (i > 0) {",
          "9824:           \"Error: CGI program \\\"%s\\\" sent error \"",
          "9825:           \"message: [%.*s]\",",
          "9827:           i,",
          "9828:           buf);",
          "9831:                       \"Error: CGI program \\\"%s\\\" sent error \"",
          "9832:                       \"message: [%.*s]\",",
          "9834:                       i,",
          "9835:                       buf);",
          "9836:   } else {",
          "9838:           \"Error: CGI program sent malformed or too big \"",
          "9839:           \"(>%u bytes) HTTP headers: [%.*s]\",",
          "9840:           (unsigned)buflen,",
          "9841:           data_len,",
          "9842:           buf);",
          "9846:                       \"Error: CGI program sent malformed or too big \"",
          "9847:                       \"(>%u bytes) HTTP headers: [%.*s]\",",
          "9848:                       (unsigned)buflen,",
          "9849:                       data_len,",
          "9850:                       buf);",
          "9851:   }",
          "9853:   goto done;",
          "9854:  }",
          "9855:  pbuf = buf;",
          "9856:  buf[headers_len - 1] = '\\0';",
          "9857:  ri.num_headers = parse_http_headers(&pbuf, ri.http_headers);",
          "9860:  status_text = \"OK\";",
          "9861:  if ((status = get_header(ri.http_headers, ri.num_headers, \"Status\"))",
          "9862:      != NULL) {",
          "9863:   conn->status_code = atoi(status);",
          "9864:   status_text = status;",
          "9865:   while (isdigit(*(const unsigned char *)status_text)",
          "9866:          || *status_text == ' ') {",
          "9867:    status_text++;",
          "9868:   }",
          "9869:  } else if (get_header(ri.http_headers, ri.num_headers, \"Location\")",
          "9870:             != NULL) {",
          "9871:   conn->status_code = 302;",
          "9872:  } else {",
          "9873:   conn->status_code = 200;",
          "9874:  }",
          "9875:  connection_state =",
          "9876:      get_header(ri.http_headers, ri.num_headers, \"Connection\");",
          "9877:  if (!header_has_option(connection_state, \"keep-alive\")) {",
          "9878:   conn->must_close = 1;",
          "9879:  }",
          "9880:  (void)mg_printf(conn, \"HTTP/1.1 %d %s\\r\\n\", conn->status_code, status_text);",
          "9883:  for (i = 0; i < ri.num_headers; i++) {",
          "9884:   mg_printf(conn,",
          "9885:             \"%s: %s\\r\\n\",",
          "9886:             ri.http_headers[i].name,",
          "9887:             ri.http_headers[i].value);",
          "9888:  }",
          "9889:  mg_write(conn, \"\\r\\n\", 2);",
          "9892:  mg_write(conn, buf + headers_len, (size_t)(data_len - headers_len));",
          "9895:  send_file_data(conn, &fout, 0, INT64_MAX);",
          "9897: done:",
          "9898:  mg_free(blk.var);",
          "9899:  mg_free(blk.buf);",
          "9901:  if (pid != (pid_t)-1) {",
          "9902:   kill(pid, SIGKILL);",
          "9903: #if !defined(_WIN32)",
          "9904:   {",
          "9905:    int st;",
          "9906:    while (waitpid(pid, &st, 0) != -1)",
          "9910:  }",
          "9911:  if (fdin[0] != -1) {",
          "9912:   close(fdin[0]);",
          "9913:  }",
          "9914:  if (fdout[1] != -1) {",
          "9915:   close(fdout[1]);",
          "9916:  }",
          "9918:  if (in != NULL) {",
          "9919:   fclose(in);",
          "9920:  } else if (fdin[1] != -1) {",
          "9921:   close(fdin[1]);",
          "9922:  }",
          "9924:  if (out != NULL) {",
          "9925:   fclose(out);",
          "9926:  } else if (fdout[0] != -1) {",
          "9927:   close(fdout[0]);",
          "9928:  }",
          "9930:  if (err != NULL) {",
          "9931:   fclose(err);",
          "9932:  } else if (fderr[0] != -1) {",
          "9933:   close(fderr[0]);",
          "9934:  }",
          "9936:  if (buf != NULL) {",
          "9937:   mg_free(buf);",
          "9939: }",
          "9944: static void",
          "9945: mkcol(struct mg_connection *conn, const char *path)",
          "9946: {",
          "9947:  int rc, body_len;",
          "9948:  struct de de;",
          "9949:  char date[64];",
          "9950:  time_t curtime = time(NULL);",
          "9952:  if (conn == NULL) {",
          "9953:   return;",
          "9954:  }",
          "9958:  memset(&de.file, 0, sizeof(de.file));",
          "9959:  if (!mg_stat(conn, path, &de.file)) {",
          "9960:   mg_cry(conn,",
          "9961:          \"%s: mg_stat(%s) failed: %s\",",
          "9962:          __func__,",
          "9963:          path,",
          "9964:          strerror(ERRNO));",
          "9965:  }",
          "9967:  if (de.file.last_modified) {",
          "9971:   mg_send_http_error(",
          "9972:       conn, 405, \"Error: mkcol(%s): %s\", path, strerror(ERRNO));",
          "9973:   return;",
          "9974:  }",
          "9976:  body_len = conn->data_len - conn->request_len;",
          "9977:  if (body_len > 0) {",
          "9978:   mg_send_http_error(",
          "9979:       conn, 415, \"Error: mkcol(%s): %s\", path, strerror(ERRNO));",
          "9980:   return;",
          "9981:  }",
          "9983:  rc = mg_mkdir(conn, path, 0755);",
          "9985:  if (rc == 0) {",
          "9986:   conn->status_code = 201;",
          "9987:   gmt_time_string(date, sizeof(date), &curtime);",
          "9988:   mg_printf(conn,",
          "9989:             \"HTTP/1.1 %d Created\\r\\n\"",
          "9990:             \"Date: %s\\r\\n\",",
          "9991:             conn->status_code,",
          "9992:             date);",
          "9993:   send_static_cache_header(conn);",
          "9994:   send_additional_header(conn);",
          "9995:   mg_printf(conn,",
          "9996:             \"Content-Length: 0\\r\\n\"",
          "9997:             \"Connection: %s\\r\\n\\r\\n\",",
          "9998:             suggest_connection_header(conn));",
          "9999:  } else if (rc == -1) {",
          "10000:   if (errno == EEXIST) {",
          "10003:   } else if (errno == EACCES) {",
          "10004:    mg_send_http_error(",
          "10005:        conn, 403, \"Error: mkcol(%s): %s\", path, strerror(ERRNO));",
          "10006:   } else if (errno == ENOENT) {",
          "10007:    mg_send_http_error(",
          "10008:        conn, 409, \"Error: mkcol(%s): %s\", path, strerror(ERRNO));",
          "10009:   } else {",
          "10010:    mg_send_http_error(",
          "10011:        conn, 500, \"fopen(%s): %s\", path, strerror(ERRNO));",
          "10013:  }",
          "10014: }",
          "10017: static void",
          "10018: put_file(struct mg_connection *conn, const char *path)",
          "10019: {",
          "10020:  struct mg_file file = STRUCT_FILE_INITIALIZER;",
          "10021:  const char *range;",
          "10022:  int64_t r1, r2;",
          "10023:  int rc;",
          "10024:  char date[64];",
          "10025:  time_t curtime = time(NULL);",
          "10027:  if (conn == NULL) {",
          "10028:   return;",
          "10031:  if (mg_stat(conn, path, &file.stat)) {",
          "10033:   conn->status_code = 200;",
          "10035:   if (file.stat.is_directory) {",
          "10038:    rc = 0;",
          "10040:   } else {",
          "10044:    if (file.access.membuf != NULL) {",
          "10046:     mg_send_http_error(",
          "10047:         conn,",
          "10048:         405,",
          "10049:         \"Error: Put not possible\\nReplacing %s is not supported\",",
          "10050:         path);",
          "10051:     return;",
          "10052:    }",
          "10055:    if (access(path, W_OK) == 0) {",
          "10057:     conn->status_code = 200;",
          "10058:     rc = 1;",
          "10060:     mg_send_http_error(",
          "10061:         conn,",
          "10062:         403,",
          "10063:         \"Error: Put not possible\\nReplacing %s is not allowed\",",
          "10064:         path);",
          "10065:     return;",
          "10068:  } else {",
          "10070:   conn->status_code = 201;",
          "10071:   rc = put_dir(conn, path);",
          "10072:  }",
          "10074:  if (rc == 0) {",
          "",
          "[Added Lines]",
          "8449:   }",
          "8453:  static void handle_static_file_request(struct mg_connection * conn,",
          "8454:                                         const char *path,",
          "8455:                                         struct mg_file *filep,",
          "8456:                                         const char *mime_type,",
          "8457:                                         const char *additional_headers)",
          "8458:  {",
          "8459:   char date[64], lm[64], etag[64];",
          "8461:   const char *msg = \"OK\", *hdr;",
          "8462:   time_t curtime = time(NULL);",
          "8463:   int64_t cl, r1, r2;",
          "8464:   struct vec mime_vec;",
          "8465:   int n, truncated;",
          "8466:   char gz_path[PATH_MAX];",
          "8467:   const char *encoding = \"\";",
          "8468:   const char *cors1, *cors2, *cors3;",
          "8470:   if ((conn == NULL) || (conn->ctx == NULL) || (filep == NULL)) {",
          "8474:   if (mime_type == NULL) {",
          "8475:    get_mime_type(conn->ctx, path, &mime_vec);",
          "8476:   } else {",
          "8477:    mime_vec.ptr = mime_type;",
          "8478:    mime_vec.len = strlen(mime_type);",
          "8479:   }",
          "8480:   if (filep->stat.size > INT64_MAX) {",
          "8483:        500,",
          "8484:        \"Error: File size is too large to send\\n%\" INT64_FMT,",
          "8485:        filep->stat.size);",
          "8488:   cl = (int64_t)filep->stat.size;",
          "8489:   conn->status_code = 200;",
          "8490:   range[0] = '\\0';",
          "8495:   if (filep->stat.is_gzipped) {",
          "8496:    mg_snprintf(",
          "8497:        conn, &truncated, gz_path, sizeof(gz_path), \"%s.gz\", path);",
          "8499:    if (truncated) {",
          "8500:     mg_send_http_error(conn,",
          "8501:                        500,",
          "8502:                        \"Error: Path of zipped file too long (%s)\",",
          "8503:                        path);",
          "8504:     return;",
          "8505:    }",
          "8507:    path = gz_path;",
          "8508:    encoding = \"Content-Encoding: gzip\\r\\n\";",
          "8509:   }",
          "8511:   if (!mg_fopen(conn, path, MG_FOPEN_MODE_READ, filep)) {",
          "8512:    mg_send_http_error(conn,",
          "8513:                       500,",
          "8514:                       \"Error: Cannot open file\\nfopen(%s): %s\",",
          "8515:                       path,",
          "8516:                       strerror(ERRNO));",
          "8517:    return;",
          "8518:   }",
          "8520:   fclose_on_exec(&filep->access, conn);",
          "8523:   r1 = r2 = 0;",
          "8524:   hdr = mg_get_header(conn, \"Range\");",
          "8525:   if ((hdr != NULL) && ((n = parse_range_header(hdr, &r1, &r2)) > 0)",
          "8526:       && (r1 >= 0) && (r2 >= 0)) {",
          "8529:    if (filep->stat.is_gzipped) {",
          "8530:     mg_send_http_error(",
          "8531:         conn,",
          "8533:         \"%s\",",
          "8534:         \"Error: Range requests in gzipped files are not supported\");",
          "8535:     (void)mg_fclose(",
          "8539:    conn->status_code = 206;",
          "8540:    cl = (n == 2) ? (((r2 > cl) ? cl : r2) - r1 + 1) : (cl - r1);",
          "8541:    mg_snprintf(conn,",
          "8543:                range,",
          "8544:                sizeof(range),",
          "8545:                \"Content-Range: bytes \"",
          "8546:                \"%\" INT64_FMT \"-%\" INT64_FMT \"/%\" INT64_FMT \"\\r\\n\",",
          "8547:                r1,",
          "8548:                r1 + cl - 1,",
          "8549:                filep->stat.size);",
          "8550:    msg = \"Partial Content\";",
          "8551:   }",
          "8553:   hdr = mg_get_header(conn, \"Origin\");",
          "8554:   if (hdr) {",
          "8560:    cors1 = \"Access-Control-Allow-Origin: \";",
          "8561:    cors2 = conn->ctx->config[ACCESS_CONTROL_ALLOW_ORIGIN];",
          "8562:    cors3 = \"\\r\\n\";",
          "8564:    cors1 = cors2 = cors3 = \"\";",
          "8570:   gmt_time_string(date, sizeof(date), &curtime);",
          "8571:   gmt_time_string(lm, sizeof(lm), &filep->stat.last_modified);",
          "8572:   construct_etag(etag, sizeof(etag), &filep->stat);",
          "8574:   (void)mg_printf(conn,",
          "8575:                   \"HTTP/1.1 %d %s\\r\\n\"",
          "8576:                   \"%s%s%s\"",
          "8577:                   \"Date: %s\\r\\n\",",
          "8578:                   conn->status_code,",
          "8579:                   msg,",
          "8580:                   cors1,",
          "8581:                   cors2,",
          "8582:                   cors3,",
          "8583:                   date);",
          "8584:   send_static_cache_header(conn);",
          "8585:   send_additional_header(conn);",
          "8586:   (void)mg_printf(conn,",
          "8587:                   \"Last-Modified: %s\\r\\n\"",
          "8588:                   \"Etag: %s\\r\\n\"",
          "8589:                   \"Content-Type: %.*s\\r\\n\"",
          "8590:                   \"Content-Length: %\" INT64_FMT \"\\r\\n\"",
          "8591:                   \"Connection: %s\\r\\n\"",
          "8592:                   \"Accept-Ranges: bytes\\r\\n\"",
          "8593:                   \"%s%s\",",
          "8594:                   lm,",
          "8595:                   etag,",
          "8596:                   (int)mime_vec.len,",
          "8597:                   mime_vec.ptr,",
          "8598:                   cl,",
          "8599:                   suggest_connection_header(conn),",
          "8600:                   range,",
          "8601:                   encoding);",
          "8606:   if (additional_headers != NULL) {",
          "8607:    (void)mg_printf(conn,",
          "8608:                    \"%.*s\\r\\n\\r\\n\",",
          "8609:                    (int)strlen(additional_headers),",
          "8610:                    additional_headers);",
          "8611:   } else {",
          "8612:    (void)mg_printf(conn, \"\\r\\n\");",
          "8615:   if (strcmp(conn->request_info.request_method, \"HEAD\") != 0) {",
          "8616:    send_file_data(conn, filep, r1, cl);",
          "8622: #if !defined(NO_CACHING)",
          "8623:  static void handle_not_modified_static_file_request(struct mg_connection",
          "8625:                                                      struct mg_file * filep)",
          "8626:  {",
          "8627:   char date[64], lm[64], etag[64];",
          "8628:   time_t curtime = time(NULL);",
          "8630:   if ((conn == NULL) || (filep == NULL)) {",
          "8631:    return;",
          "8632:   }",
          "8633:   conn->status_code = 304;",
          "8634:   gmt_time_string(date, sizeof(date), &curtime);",
          "8635:   gmt_time_string(lm, sizeof(lm), &filep->stat.last_modified);",
          "8636:   construct_etag(etag, sizeof(etag), &filep->stat);",
          "8638:   (void)mg_printf(conn,",
          "8639:                   \"HTTP/1.1 %d %s\\r\\n\"",
          "8640:                   \"Date: %s\\r\\n\",",
          "8641:                   conn->status_code,",
          "8642:                   mg_get_response_code_text(conn, conn->status_code),",
          "8643:                   date);",
          "8644:   send_static_cache_header(conn);",
          "8645:   send_additional_header(conn);",
          "8646:   (void)mg_printf(conn,",
          "8647:                   \"Last-Modified: %s\\r\\n\"",
          "8648:                   \"Etag: %s\\r\\n\"",
          "8649:                   \"Connection: %s\\r\\n\"",
          "8650:                   \"\\r\\n\",",
          "8651:                   lm,",
          "8652:                   etag,",
          "8653:                   suggest_connection_header(conn));",
          "8655: #endif",
          "8658:  void mg_send_file(struct mg_connection * conn, const char *path)",
          "8659:  {",
          "8660:   mg_send_mime_file(conn, path, NULL);",
          "8664:  void mg_send_mime_file(struct mg_connection * conn,",
          "8665:                         const char *path,",
          "8666:                         const char *mime_type)",
          "8667:  {",
          "8668:   mg_send_mime_file2(conn, path, mime_type, NULL);",
          "8672:  void mg_send_mime_file2(struct mg_connection * conn,",
          "8673:                          const char *path,",
          "8674:                          const char *mime_type,",
          "8675:                          const char *additional_headers)",
          "8676:  {",
          "8677:   struct mg_file file = STRUCT_FILE_INITIALIZER;",
          "8678:   if (mg_stat(conn, path, &file.stat)) {",
          "8679:    if (file.stat.is_directory) {",
          "8680:     if (!conn) {",
          "8681:      return;",
          "8682:     }",
          "8683:     if (!mg_strcasecmp(conn->ctx->config[ENABLE_DIRECTORY_LISTING],",
          "8684:                        \"yes\")) {",
          "8685:      handle_directory_request(conn, path);",
          "8686:     } else {",
          "8687:      mg_send_http_error(conn,",
          "8688:                         403,",
          "8689:                         \"%s\",",
          "8690:                         \"Error: Directory listing denied\");",
          "8691:     }",
          "8692:    } else {",
          "8693:     handle_static_file_request(",
          "8694:         conn, path, &file, mime_type, additional_headers);",
          "8695:    }",
          "8696:   } else {",
          "8697:    mg_send_http_error(conn, 404, \"%s\", \"Error: File not found\");",
          "8698:   }",
          "8708:  static int put_dir(struct mg_connection * conn, const char *path)",
          "8709:  {",
          "8710:   char buf[PATH_MAX];",
          "8711:   const char *s, *p;",
          "8712:   struct mg_file file = STRUCT_FILE_INITIALIZER;",
          "8713:   size_t len;",
          "8714:   int res = 1;",
          "8716:   for (s = p = path + 2; (p = strchr(s, '/')) != NULL; s = ++p) {",
          "8717:    len = (size_t)(p - path);",
          "8718:    if (len >= sizeof(buf)) {",
          "8720:     res = -1;",
          "8721:     break;",
          "8722:    }",
          "8723:    memcpy(buf, path, len);",
          "8724:    buf[len] = '\\0';",
          "8727:    DEBUG_TRACE(\"mkdir(%s)\", buf);",
          "8728:    if (!mg_stat(conn, buf, &file.stat)",
          "8729:        && mg_mkdir(conn, buf, 0755) != 0) {",
          "8731:     res = -2;",
          "8732:     break;",
          "8733:    }",
          "8736:    if (p[1] == '\\0') {",
          "8737:     res = 0;",
          "8738:    }",
          "8741:   return res;",
          "8745:  static void remove_bad_file(const struct mg_connection *conn,",
          "8746:                              const char *path)",
          "8747:  {",
          "8748:   int r = mg_remove(conn, path);",
          "8749:   if (r != 0) {",
          "8750:    mg_cry(conn, \"%s: Cannot remove invalid file %s\", __func__, path);",
          "8755:  long long mg_store_body(struct mg_connection * conn, const char *path)",
          "8756:  {",
          "8757:   char buf[MG_BUF_LEN];",
          "8758:   long long len = 0;",
          "8759:   int ret, n;",
          "8760:   struct mg_file fi;",
          "8762:   if (conn->consumed_content != 0) {",
          "8763:    mg_cry(conn, \"%s: Contents already consumed\", __func__);",
          "8764:    return -11;",
          "8767:   ret = put_dir(conn, path);",
          "8768:   if (ret < 0) {",
          "8771:    return ret;",
          "8773:   if (ret != 1) {",
          "8775:    return 0;",
          "8778:   if (mg_fopen(conn, path, MG_FOPEN_MODE_WRITE, &fi) == 0) {",
          "8779:    return -12;",
          "8782:   ret = mg_read(conn, buf, sizeof(buf));",
          "8783:   while (ret > 0) {",
          "8784:    n = (int)fwrite(buf, 1, (size_t)ret, fi.access.fp);",
          "8785:    if (n != ret) {",
          "8786:     (void)mg_fclose(",
          "8788:     remove_bad_file(conn, path);",
          "8789:     return -13;",
          "8790:    }",
          "8791:    len += ret;",
          "8792:    ret = mg_read(conn, buf, sizeof(buf));",
          "8798:   if (mg_fclose(&fi.access) != 0) {",
          "8799:    remove_bad_file(conn, path);",
          "8800:    return -14;",
          "8803:   return len;",
          "8811:  static int skip_to_end_of_word_and_terminate(char **ppw, int eol)",
          "8812:  {",
          "8815:   while (isgraph(**ppw)) {",
          "8816:    (*ppw)++;",
          "8817:   }",
          "8820:   if (eol) {",
          "8822:    if ((**ppw != '\\r') && (**ppw != '\\n')) {",
          "8823:     return -1;",
          "8824:    }",
          "8825:   } else {",
          "8827:    if (**ppw != ' ') {",
          "8828:     return -1;",
          "8829:    }",
          "8830:   }",
          "8833:   do {",
          "8835:    (*ppw)++;",
          "8836:   } while ((**ppw) && isspace(**ppw));",
          "8839:   if (!eol) {",
          "8841:    if (!isgraph(**ppw)) {",
          "8842:     return -1;",
          "8843:    }",
          "8844:   }",
          "8847:   return 1;",
          "8855:  static int parse_http_headers(char **buf,",
          "8856:                                struct mg_header hdr[MG_MAX_HEADERS])",
          "8857:  {",
          "8858:   int i;",
          "8859:   int num_headers = 0;",
          "8861:   for (i = 0; i < (int)MG_MAX_HEADERS; i++) {",
          "8862:    char *dp = *buf;",
          "8863:    while ((*dp != ':') && (*dp >= 33) && (*dp <= 126)) {",
          "8864:     dp++;",
          "8865:    }",
          "8866:    if (dp == *buf) {",
          "8868:     break;",
          "8869:    }",
          "8870:    if (*dp != ':') {",
          "8872:     return -1;",
          "8873:    }",
          "8878:    hdr[i].name = *buf;",
          "8879:    do {",
          "8880:     dp++;",
          "8881:    } while (*dp == ' ');",
          "8884:    hdr[i].value = dp;",
          "8886:    if (((*buf)[0] != '\\r') || ((*buf)[1] != '\\n')) {",
          "8888:    }",
          "8890:    num_headers = i + 1;",
          "8891:    if (*buf) {",
          "8892:     (*buf)[0] = 0;",
          "8893:     (*buf)[1] = 0;",
          "8895:    } else {",
          "8897:     break;",
          "8898:    }",
          "8900:    if ((*buf)[0] == '\\r') {",
          "8902:     break;",
          "8903:    }",
          "8904:   }",
          "8905:   return num_headers;",
          "8909:  static int is_valid_http_method(const char *method)",
          "8910:  {",
          "8948:       ;",
          "8949:  }",
          "8961:  static int parse_http_request(char *buf,",
          "8962:                                int len,",
          "8963:                                struct mg_request_info *ri)",
          "8964:  {",
          "8965:   int request_length;",
          "8966:   int init_skip = 0;",
          "8970:   ri->remote_user = ri->request_method = ri->request_uri =",
          "8971:       ri->http_version = NULL;",
          "8972:   ri->num_headers = 0;",
          "8977:   while ((len > 0) && isspace(*(unsigned char *)buf)) {",
          "8978:    buf++;",
          "8979:    len--;",
          "8980:    init_skip++;",
          "8981:   }",
          "8983:   if (len == 0) {",
          "8985:    return 0;",
          "8986:   }",
          "8989:   if (iscntrl(*(unsigned char *)buf)) {",
          "8990:    return -1;",
          "8991:   }",
          "8994:   request_length = get_http_header_len(buf, len);",
          "8995:   if (request_length <= 0) {",
          "8996:    return request_length;",
          "8997:   }",
          "8998:   buf[request_length - 1] = '\\0';",
          "9000:   if ((*buf == 0) || (*buf == '\\r') || (*buf == '\\n')) {",
          "9001:    return -1;",
          "9002:   }",
          "9005:   ri->request_method = buf;",
          "9007:   if (skip_to_end_of_word_and_terminate(&buf, 0) <= 0) {",
          "9008:    return -1;",
          "9009:   }",
          "9012:   if (!is_valid_http_method(ri->request_method)) {",
          "9013:    return -1;",
          "9014:   }",
          "9017:   ri->request_uri = buf;",
          "9019:   if (skip_to_end_of_word_and_terminate(&buf, 0) <= 0) {",
          "9020:    return -1;",
          "9021:   }",
          "9024:   ri->http_version = buf;",
          "9026:   if (skip_to_end_of_word_and_terminate(&buf, 1) <= 0) {",
          "9027:    return -1;",
          "9028:   }",
          "9031:   if (strncmp(ri->http_version, \"HTTP/\", 5) != 0) {",
          "9033:    return -1;",
          "9034:   }",
          "9035:   ri->http_version += 5;",
          "9039:   ri->num_headers = parse_http_headers(&buf, ri->http_headers);",
          "9040:   if (ri->num_headers < 0) {",
          "9042:    return -1;",
          "9043:   }",
          "9045:   return request_length + init_skip;",
          "9049:  static int parse_http_response(char *buf,",
          "9050:                                 int len,",
          "9051:                                 struct mg_response_info *ri)",
          "9052:  {",
          "9053:   int response_length;",
          "9054:   int init_skip = 0;",
          "9055:   char *tmp, *tmp2;",
          "9056:   long l;",
          "9059:   ri->http_version = ri->status_text = NULL;",
          "9060:   ri->num_headers = ri->status_code = 0;",
          "9065:   while ((len > 0) && isspace(*(unsigned char *)buf)) {",
          "9066:    buf++;",
          "9067:    len--;",
          "9068:    init_skip++;",
          "9069:   }",
          "9071:   if (len == 0) {",
          "9073:    return 0;",
          "9074:   }",
          "9077:   if (iscntrl(*(unsigned char *)buf)) {",
          "9078:    return -1;",
          "9079:   }",
          "9082:   response_length = get_http_header_len(buf, len);",
          "9083:   if (response_length <= 0) {",
          "9084:    return response_length;",
          "9085:   }",
          "9086:   buf[response_length - 1] = '\\0';",
          "9090:   (void)buf;",
          "9091:   (void)len;",
          "9092:   (void)ri;",
          "9095:   while ((*buf != '\\0') && isspace(*(unsigned char *)buf)) {",
          "9096:    buf++;",
          "9097:   }",
          "9098:   if ((*buf == 0) || (*buf == '\\r') || (*buf == '\\n')) {",
          "9099:    return -1;",
          "9100:   }",
          "9104:   if (strncmp(buf, \"HTTP/\", 5) != 0) {",
          "9106:    return -1;",
          "9107:   }",
          "9108:   buf += 5;",
          "9109:   if (!isgraph(buf[0])) {",
          "9111:    return -1;",
          "9112:   }",
          "9113:   ri->http_version = buf;",
          "9115:   if (skip_to_end_of_word_and_terminate(&buf, 0) <= 0) {",
          "9116:    return -1;",
          "9117:   }",
          "9120:   tmp = buf;",
          "9122:   if (skip_to_end_of_word_and_terminate(&buf, 0) <= 0) {",
          "9123:    return -1;",
          "9126:   l = strtol(tmp, &tmp2, 10);",
          "9127:   if ((l < 100) || (l >= 1000) || ((tmp2 - tmp) != 3) || (*tmp2 != 0)) {",
          "9129:    return -1;",
          "9130:   }",
          "9131:   ri->status_code = (int)l;",
          "9134:   ri->status_text = buf;",
          "9138:   while (isprint(*buf)) {",
          "9139:    buf++;",
          "9140:   }",
          "9141:   if ((*buf != '\\r') && (*buf != '\\n')) {",
          "9145:   do {",
          "9147:    buf++;",
          "9148:   } while ((*buf) && isspace(*buf));",
          "9152:   ri->num_headers = parse_http_headers(&buf, ri->http_headers);",
          "9153:   if (ri->num_headers < 0) {",
          "9158:   return response_length + init_skip;",
          "9159:  }",
          "9167:  static int read_message(FILE * fp,",
          "9168:                          struct mg_connection * conn,",
          "9169:                          char *buf,",
          "9170:                          int bufsiz,",
          "9171:                          int *nread)",
          "9172:  {",
          "9173:   int request_len, n = 0;",
          "9174:   struct timespec last_action_time;",
          "9175:   double request_timeout;",
          "9177:   if (!conn) {",
          "9178:    return 0;",
          "9179:   }",
          "9181:   memset(&last_action_time, 0, sizeof(last_action_time));",
          "9183:   if (conn->ctx->config[REQUEST_TIMEOUT]) {",
          "9185:    request_timeout = atof(conn->ctx->config[REQUEST_TIMEOUT]) / 1000.0;",
          "9187:    request_timeout = -1.0;",
          "9188:   }",
          "9189:   if (conn->handled_requests > 0) {",
          "9190:    if (conn->ctx->config[KEEP_ALIVE_TIMEOUT]) {",
          "9191:     request_timeout =",
          "9192:         atof(conn->ctx->config[KEEP_ALIVE_TIMEOUT]) / 1000.0;",
          "9193:    }",
          "9196:   request_len = get_http_header_len(buf, *nread);",
          "9199:   clock_gettime(CLOCK_MONOTONIC, &last_action_time);",
          "9201:   while (request_len == 0) {",
          "9203:    if (conn->ctx->stop_flag != 0) {",
          "9205:     return -1;",
          "9206:    }",
          "9208:    if (*nread >= bufsiz) {",
          "9210:     return -2;",
          "9211:    }",
          "9213:    n = pull_inner(",
          "9214:        fp, conn, buf + *nread, bufsiz - *nread, request_timeout);",
          "9215:    if (n == -2) {",
          "9219:    if (n > 0) {",
          "9221:     request_len = get_http_header_len(buf, *nread);",
          "9222:    } else {",
          "9223:     request_len = 0;",
          "9224:    }",
          "9226:    if ((request_len == 0) && (request_timeout >= 0)) {",
          "9227:     if (mg_difftimespec(&last_action_time, &(conn->req_time))",
          "9228:         > request_timeout) {",
          "9230:      return -1;",
          "9231:     }",
          "9232:     clock_gettime(CLOCK_MONOTONIC, &last_action_time);",
          "9233:    }",
          "9236:   return request_len;",
          "9237:  }",
          "9242:  static int is_not_modified(const struct mg_connection *conn,",
          "9243:                             const struct mg_file_stat *filestat)",
          "9244:  {",
          "9245:   char etag[64];",
          "9246:   const char *ims = mg_get_header(conn, \"If-Modified-Since\");",
          "9247:   const char *inm = mg_get_header(conn, \"If-None-Match\");",
          "9248:   construct_etag(etag, sizeof(etag), filestat);",
          "9250:   return ((inm != NULL) && !mg_strcasecmp(etag, inm))",
          "9251:          || ((ims != NULL)",
          "9252:              && (filestat->last_modified <= parse_date_string(ims)));",
          "9253:  }",
          "9258:  static int forward_body_data(struct mg_connection * conn,",
          "9259:                               FILE * fp,",
          "9260:                               SOCKET sock,",
          "9261:                               SSL * ssl)",
          "9262:  {",
          "9263:   const char *expect, *body;",
          "9264:   char buf[MG_BUF_LEN];",
          "9265:   int to_read, nread, success = 0;",
          "9266:   int64_t buffered_len;",
          "9267:   double timeout = -1.0;",
          "9269:   if (!conn) {",
          "9270:    return 0;",
          "9271:   }",
          "9272:   if (conn->ctx->config[REQUEST_TIMEOUT]) {",
          "9273:    timeout = atoi(conn->ctx->config[REQUEST_TIMEOUT]) / 1000.0;",
          "9274:   }",
          "9276:   expect = mg_get_header(conn, \"Expect\");",
          "9278:   if (!fp) {",
          "9279:    mg_send_http_error(conn, 500, \"%s\", \"Error: NULL File\");",
          "9280:    return 0;",
          "9283:   if ((conn->content_len == -1) && !conn->is_chunked) {",
          "9285:    mg_send_http_error(conn,",
          "9286:                       411,",
          "9287:                       \"%s\",",
          "9288:                       \"Error: Client did not specify content length\");",
          "9289:   } else if ((expect != NULL)",
          "9290:              && (mg_strcasecmp(expect, \"100-continue\") != 0)) {",
          "9293:    mg_send_http_error(conn,",
          "9294:                       417,",
          "9295:                       \"Error: Can not fulfill expectation %s\",",
          "9296:                       expect);",
          "9297:   } else {",
          "9298:    if (expect != NULL) {",
          "9299:     (void)mg_printf(conn, \"%s\", \"HTTP/1.1 100 Continue\\r\\n\\r\\n\");",
          "9300:     conn->status_code = 100;",
          "9301:    } else {",
          "9302:     conn->status_code = 200;",
          "9303:    }",
          "9305:    buffered_len = (int64_t)(conn->data_len)",
          "9306:                   - (int64_t)conn->request_len",
          "9307:                   - conn->consumed_content;",
          "9312:    if ((buffered_len < 0) || (conn->consumed_content != 0)) {",
          "9313:     mg_send_http_error(conn, 500, \"%s\", \"Error: Size mismatch\");",
          "9314:     return 0;",
          "9317:    if (buffered_len > 0) {",
          "9318:     if ((int64_t)buffered_len > conn->content_len) {",
          "9319:      buffered_len = (int)conn->content_len;",
          "9320:     }",
          "9321:     body = conn->buf + conn->request_len + conn->consumed_content;",
          "9322:     push_all(conn->ctx, fp, sock, ssl, body, (int64_t)buffered_len);",
          "9323:     conn->consumed_content += buffered_len;",
          "9326:    nread = 0;",
          "9327:    while (conn->consumed_content < conn->content_len) {",
          "9328:     to_read = sizeof(buf);",
          "9329:     if ((int64_t)to_read > conn->content_len",
          "9330:                                - conn->consumed_content) {",
          "9331:      to_read = (int)(conn->content_len - conn->consumed_content);",
          "9332:     }",
          "9333:     nread = pull_inner(NULL, conn, buf, to_read, timeout);",
          "9334:     if (nread == -2) {",
          "9338:     if (nread > 0) {",
          "9339:      if (push_all(conn->ctx, fp, sock, ssl, buf, nread)",
          "9340:          != nread) {",
          "9341:       break;",
          "9342:      }",
          "9343:     }",
          "9344:     conn->consumed_content += nread;",
          "9347:    if (conn->consumed_content == conn->content_len) {",
          "9348:     success = (nread >= 0);",
          "9349:    }",
          "9352:    if (!success) {",
          "9356:     mg_send_http_error(conn, 500, \"%s\", \"\");",
          "9357:    }",
          "9360:   return success;",
          "9361:  }",
          "9375:  struct cgi_environment {",
          "9376:   struct mg_connection *conn;",
          "9385:  };",
          "9388:  static void addenv(struct cgi_environment * env,",
          "9389:                     PRINTF_FORMAT_STRING(const char *fmt),",
          "9390:                     ...) PRINTF_ARGS(2, 3);",
          "9394:  static void addenv(struct cgi_environment * env, const char *fmt, ...)",
          "9395:  {",
          "9396:   size_t n, space;",
          "9397:   int truncated = 0;",
          "9398:   char *added;",
          "9399:   va_list ap;",
          "9402:   space = (env->buflen - env->bufused);",
          "9405:   n = strlen(fmt) + 2 + 128;",
          "9407:   do {",
          "9408:    if (space <= n) {",
          "9410:     n = env->buflen + CGI_ENVIRONMENT_SIZE;",
          "9411:     added = (char *)mg_realloc_ctx(env->buf, n, env->conn->ctx);",
          "9412:     if (!added) {",
          "9414:      mg_cry(env->conn,",
          "9415:             \"%s: Cannot allocate memory for CGI variable [%s]\",",
          "9416:             __func__,",
          "9417:             fmt);",
          "9418:      return;",
          "9419:     }",
          "9420:     env->buf = added;",
          "9421:     env->buflen = n;",
          "9422:     space = (env->buflen - env->bufused);",
          "9426:    added = env->buf + env->bufused;",
          "9429:    va_start(ap, fmt);",
          "9430:    mg_vsnprintf(env->conn, &truncated, added, (size_t)space, fmt, ap);",
          "9431:    va_end(ap);",
          "9434:    if (truncated) {",
          "9436:     space = 0;",
          "9437:     n = 1;",
          "9438:    }",
          "9439:   } while (truncated);",
          "9442:   n = strlen(added) + 1;",
          "9443:   env->bufused += n;",
          "9446:   space = (env->varlen - env->varused);",
          "9447:   if (space < 2) {",
          "9448:    mg_cry(env->conn,",
          "9449:           \"%s: Cannot register CGI variable [%s]\",",
          "9450:           __func__,",
          "9451:           fmt);",
          "9452:    return;",
          "9453:   }",
          "9456:   env->var[env->varused] = added;",
          "9457:   env->varused++;",
          "9462:  static int prepare_cgi_environment(struct mg_connection * conn,",
          "9463:                                     const char *prog,",
          "9464:                                     struct cgi_environment *env)",
          "9465:  {",
          "9466:   const char *s;",
          "9467:   struct vec var_vec;",
          "9468:   char *p, src_addr[IP_ADDR_STR_LEN], http_var_name[128];",
          "9469:   int i, truncated, uri_len;",
          "9471:   if ((conn == NULL) || (prog == NULL) || (env == NULL)) {",
          "9472:    return -1;",
          "9473:   }",
          "9475:   env->conn = conn;",
          "9476:   env->buflen = CGI_ENVIRONMENT_SIZE;",
          "9477:   env->bufused = 0;",
          "9478:   env->buf = (char *)mg_malloc_ctx(env->buflen, conn->ctx);",
          "9479:   if (env->buf == NULL) {",
          "9480:    mg_cry(conn,",
          "9481:           \"%s: Not enough memory for environmental buffer\",",
          "9482:           __func__);",
          "9483:    return -1;",
          "9484:   }",
          "9485:   env->varlen = MAX_CGI_ENVIR_VARS;",
          "9486:   env->varused = 0;",
          "9487:   env->var =",
          "9488:       (char **)mg_malloc_ctx(env->buflen * sizeof(char *), conn->ctx);",
          "9489:   if (env->var == NULL) {",
          "9490:    mg_cry(conn,",
          "9491:           \"%s: Not enough memory for environmental variables\",",
          "9492:           __func__);",
          "9493:    mg_free(env->buf);",
          "9494:    return -1;",
          "9495:   }",
          "9497:   addenv(env, \"SERVER_NAME=%s\", conn->ctx->config[AUTHENTICATION_DOMAIN]);",
          "9498:   addenv(env, \"SERVER_ROOT=%s\", conn->ctx->config[DOCUMENT_ROOT]);",
          "9499:   addenv(env, \"DOCUMENT_ROOT=%s\", conn->ctx->config[DOCUMENT_ROOT]);",
          "9500:   addenv(env, \"SERVER_SOFTWARE=%s/%s\", \"Civetweb\", mg_version());",
          "9503:   addenv(env, \"%s\", \"GATEWAY_INTERFACE=CGI/1.1\");",
          "9504:   addenv(env, \"%s\", \"SERVER_PROTOCOL=HTTP/1.1\");",
          "9508:   if (conn->client.lsa.sa.sa_family == AF_INET6) {",
          "9509:    addenv(env,",
          "9510:           \"SERVER_PORT=%d\",",
          "9511:           ntohs(conn->client.lsa.sin6.sin6_port));",
          "9512:   } else",
          "9514:   {",
          "9515:    addenv(env, \"SERVER_PORT=%d\", ntohs(conn->client.lsa.sin.sin_port));",
          "9516:   }",
          "9518:   sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);",
          "9519:   addenv(env, \"REMOTE_ADDR=%s\", src_addr);",
          "9521:   addenv(env, \"REQUEST_METHOD=%s\", conn->request_info.request_method);",
          "9522:   addenv(env, \"REMOTE_PORT=%d\", conn->request_info.remote_port);",
          "9524:   addenv(env, \"REQUEST_URI=%s\", conn->request_info.request_uri);",
          "9525:   addenv(env, \"LOCAL_URI=%s\", conn->request_info.local_uri);",
          "9528:   uri_len = (int)strlen(conn->request_info.local_uri);",
          "9529:   if (conn->path_info == NULL) {",
          "9530:    if (conn->request_info.local_uri[uri_len - 1] != '/') {",
          "9532:     addenv(env, \"SCRIPT_NAME=%s\", conn->request_info.local_uri);",
          "9533:    } else {",
          "9535:     const char *index_file = strrchr(prog, '/');",
          "9536:     if (index_file) {",
          "9537:      addenv(env,",
          "9538:             \"SCRIPT_NAME=%s%s\",",
          "9539:             conn->request_info.local_uri,",
          "9540:             index_file + 1);",
          "9541:     }",
          "9543:   } else {",
          "9545:    addenv(env,",
          "9546:           \"SCRIPT_NAME=%.*s\",",
          "9547:           uri_len - (int)strlen(conn->path_info),",
          "9548:           conn->request_info.local_uri);",
          "9551:   addenv(env, \"SCRIPT_FILENAME=%s\", prog);",
          "9552:   if (conn->path_info == NULL) {",
          "9553:    addenv(env, \"PATH_TRANSLATED=%s\", conn->ctx->config[DOCUMENT_ROOT]);",
          "9554:   } else {",
          "9555:    addenv(env,",
          "9556:           \"PATH_TRANSLATED=%s%s\",",
          "9557:           conn->ctx->config[DOCUMENT_ROOT],",
          "9558:           conn->path_info);",
          "9559:   }",
          "9561:   addenv(env, \"HTTPS=%s\", (conn->ssl == NULL) ? \"off\" : \"on\");",
          "9563:   if ((s = mg_get_header(conn, \"Content-Type\")) != NULL) {",
          "9564:    addenv(env, \"CONTENT_TYPE=%s\", s);",
          "9565:   }",
          "9566:   if (conn->request_info.query_string != NULL) {",
          "9567:    addenv(env, \"QUERY_STRING=%s\", conn->request_info.query_string);",
          "9568:   }",
          "9569:   if ((s = mg_get_header(conn, \"Content-Length\")) != NULL) {",
          "9570:    addenv(env, \"CONTENT_LENGTH=%s\", s);",
          "9571:   }",
          "9572:   if ((s = getenv(\"PATH\")) != NULL) {",
          "9573:    addenv(env, \"PATH=%s\", s);",
          "9574:   }",
          "9575:   if (conn->path_info != NULL) {",
          "9576:    addenv(env, \"PATH_INFO=%s\", conn->path_info);",
          "9577:   }",
          "9579:   if (conn->status_code > 0) {",
          "9581:    addenv(env, \"STATUS=%d\", conn->status_code);",
          "9582:   }",
          "9585:   if ((s = getenv(\"COMSPEC\")) != NULL) {",
          "9586:    addenv(env, \"COMSPEC=%s\", s);",
          "9587:   }",
          "9588:   if ((s = getenv(\"SYSTEMROOT\")) != NULL) {",
          "9589:    addenv(env, \"SYSTEMROOT=%s\", s);",
          "9590:   }",
          "9591:   if ((s = getenv(\"SystemDrive\")) != NULL) {",
          "9592:    addenv(env, \"SystemDrive=%s\", s);",
          "9593:   }",
          "9594:   if ((s = getenv(\"ProgramFiles\")) != NULL) {",
          "9595:    addenv(env, \"ProgramFiles=%s\", s);",
          "9596:   }",
          "9597:   if ((s = getenv(\"ProgramFiles(x86)\")) != NULL) {",
          "9598:    addenv(env, \"ProgramFiles(x86)=%s\", s);",
          "9599:   }",
          "9606:   if ((s = getenv(\"PERLLIB\")) != NULL) {",
          "9607:    addenv(env, \"PERLLIB=%s\", s);",
          "9610:   if (conn->request_info.remote_user != NULL) {",
          "9611:    addenv(env, \"REMOTE_USER=%s\", conn->request_info.remote_user);",
          "9612:    addenv(env, \"%s\", \"AUTH_TYPE=Digest\");",
          "9616:   for (i = 0; i < conn->request_info.num_headers; i++) {",
          "9618:    (void)mg_snprintf(conn,",
          "9619:                      &truncated,",
          "9620:                      http_var_name,",
          "9621:                      sizeof(http_var_name),",
          "9622:                      \"HTTP_%s\",",
          "9623:                      conn->request_info.http_headers[i].name);",
          "9625:    if (truncated) {",
          "9626:     mg_cry(conn,",
          "9627:            \"%s: HTTP header variable too long [%s]\",",
          "9628:            __func__,",
          "9629:            conn->request_info.http_headers[i].name);",
          "9630:     continue;",
          "9631:    }",
          "9634:    for (p = http_var_name; *p != '\\0'; p++) {",
          "9635:     if (*p == '-') {",
          "9637:     }",
          "9639:    }",
          "9641:    addenv(env,",
          "9642:           \"%s=%s\",",
          "9643:           http_var_name,",
          "9644:           conn->request_info.http_headers[i].value);",
          "9645:   }",
          "9648:   s = conn->ctx->config[CGI_ENVIRONMENT];",
          "9649:   while ((s = next_option(s, &var_vec, NULL)) != NULL) {",
          "9650:    addenv(env, \"%.*s\", (int)var_vec.len, var_vec.ptr);",
          "9651:   }",
          "9653:   env->var[env->varused] = NULL;",
          "9654:   env->buf[env->bufused] = '\\0';",
          "9656:   return 0;",
          "9660:  static void handle_cgi_request(struct mg_connection * conn,",
          "9661:                                 const char *prog)",
          "9662:  {",
          "9663:   char *buf;",
          "9664:   size_t buflen;",
          "9665:   int headers_len, data_len, i, truncated;",
          "9666:   int fdin[2] = {-1, -1}, fdout[2] = {-1, -1}, fderr[2] = {-1, -1};",
          "9667:   const char *status, *status_text, *connection_state;",
          "9668:   char *pbuf, dir[PATH_MAX], *p;",
          "9669:   struct mg_request_info ri;",
          "9670:   struct cgi_environment blk;",
          "9671:   FILE *in = NULL, *out = NULL, *err = NULL;",
          "9672:   struct mg_file fout = STRUCT_FILE_INITIALIZER;",
          "9673:   pid_t pid = (pid_t)-1;",
          "9675:   if (conn == NULL) {",
          "9676:    return;",
          "9677:   }",
          "9679:   buf = NULL;",
          "9680:   buflen = 16384;",
          "9681:   i = prepare_cgi_environment(conn, prog, &blk);",
          "9682:   if (i != 0) {",
          "9683:    blk.buf = NULL;",
          "9684:    blk.var = NULL;",
          "9685:    goto done;",
          "9686:   }",
          "9691:   (void)mg_snprintf(conn, &truncated, dir, sizeof(dir), \"%s\", prog);",
          "9693:   if (truncated) {",
          "9694:    mg_cry(conn, \"Error: CGI program \\\"%s\\\": Path too long\", prog);",
          "9695:    mg_send_http_error(conn, 500, \"Error: %s\", \"CGI path too long\");",
          "9696:    goto done;",
          "9697:   }",
          "9699:   if ((p = strrchr(dir, '/')) != NULL) {",
          "9701:   } else {",
          "9702:    dir[0] = '.', dir[1] = '\\0';",
          "9703:    p = (char *)prog;",
          "9704:   }",
          "9706:   if ((pipe(fdin) != 0) || (pipe(fdout) != 0) || (pipe(fderr) != 0)) {",
          "9707:    status = strerror(ERRNO);",
          "9709:           \"Error: CGI program \\\"%s\\\": Can not create CGI pipes: %s\",",
          "9710:           prog,",
          "9711:           status);",
          "9712:    mg_send_http_error(conn,",
          "9713:                       500,",
          "9714:                       \"Error: Cannot create CGI pipe: %s\",",
          "9715:                       status);",
          "9719:   pid = spawn_process(conn, p, blk.buf, blk.var, fdin, fdout, fderr, dir);",
          "9721:   if (pid == (pid_t)-1) {",
          "9722:    status = strerror(ERRNO);",
          "9724:           \"Error: CGI program \\\"%s\\\": Can not spawn CGI process: %s\",",
          "9726:           status);",
          "9729:                       \"Error: Cannot spawn CGI process [%s]: %s\",",
          "9731:                       status);",
          "9732:    goto done;",
          "9733:   }",
          "9748:   (void)close(fdin[0]);",
          "9749:   (void)close(fdout[1]);",
          "9750:   (void)close(fderr[1]);",
          "9751:   fdin[0] = fdout[1] = fderr[1] = -1;",
          "9753:   if ((in = fdopen(fdin[1], \"wb\")) == NULL) {",
          "9754:    status = strerror(ERRNO);",
          "9756:           \"Error: CGI program \\\"%s\\\": Can not open stdin: %s\",",
          "9757:           prog,",
          "9758:           status);",
          "9759:    mg_send_http_error(conn,",
          "9760:                       500,",
          "9761:                       \"Error: CGI can not open fdin\\nfopen: %s\",",
          "9762:                       status);",
          "9763:    goto done;",
          "9764:   }",
          "9766:   if ((out = fdopen(fdout[0], \"rb\")) == NULL) {",
          "9767:    status = strerror(ERRNO);",
          "9768:    mg_cry(conn,",
          "9769:           \"Error: CGI program \\\"%s\\\": Can not open stdout: %s\",",
          "9770:           prog,",
          "9771:           status);",
          "9774:                       \"Error: CGI can not open fdout\\nfopen: %s\",",
          "9775:                       status);",
          "9776:    goto done;",
          "9777:   }",
          "9779:   if ((err = fdopen(fderr[0], \"rb\")) == NULL) {",
          "9780:    status = strerror(ERRNO);",
          "9781:    mg_cry(conn,",
          "9782:           \"Error: CGI program \\\"%s\\\": Can not open stderr: %s\",",
          "9783:           prog,",
          "9784:           status);",
          "9785:    mg_send_http_error(conn,",
          "9786:                       500,",
          "9787:                       \"Error: CGI can not open fdout\\nfopen: %s\",",
          "9788:                       status);",
          "9789:    goto done;",
          "9790:   }",
          "9792:   setbuf(in, NULL);",
          "9793:   setbuf(out, NULL);",
          "9794:   setbuf(err, NULL);",
          "9795:   fout.access.fp = out;",
          "9797:   if ((conn->request_info.content_length > 0) || conn->is_chunked) {",
          "9799:    if (!forward_body_data(conn, in, INVALID_SOCKET, NULL)) {",
          "9801:     mg_cry(conn,",
          "9802:            \"Error: CGI program \\\"%s\\\": Forward body data failed\",",
          "9803:            prog);",
          "9804:     goto done;",
          "9805:    }",
          "9806:   }",
          "9809:   fclose(in);",
          "9810:   in = NULL;",
          "9811:   fdin[1] = -1;",
          "9817:   data_len = 0;",
          "9818:   buf = (char *)mg_malloc_ctx(buflen, conn->ctx);",
          "9819:   if (buf == NULL) {",
          "9820:    mg_send_http_error(",
          "9821:        conn,",
          "9822:        500,",
          "9823:        \"Error: Not enough memory for CGI buffer (%u bytes)\",",
          "9824:        (unsigned int)buflen);",
          "9825:    mg_cry(",
          "9826:        conn,",
          "9827:        \"Error: CGI program \\\"%s\\\": Not enough memory for buffer (%u \"",
          "9828:        \"bytes)\",",
          "9829:        prog,",
          "9830:        (unsigned int)buflen);",
          "9831:    goto done;",
          "9832:   }",
          "9833:   headers_len = read_message(out, conn, buf, (int)buflen, &data_len);",
          "9834:   if (headers_len <= 0) {",
          "9838:    i = pull_all(err, conn, buf, (int)buflen);",
          "9839:    if (i > 0) {",
          "9840:     mg_cry(conn,",
          "9841:            \"Error: CGI program \\\"%s\\\" sent error \"",
          "9842:            \"message: [%.*s]\",",
          "9843:            prog,",
          "9844:            i,",
          "9845:            buf);",
          "9846:     mg_send_http_error(conn,",
          "9847:                        500,",
          "9848:                        \"Error: CGI program \\\"%s\\\" sent error \"",
          "9849:                        \"message: [%.*s]\",",
          "9850:                        prog,",
          "9851:                        i,",
          "9852:                        buf);",
          "9853:    } else {",
          "9854:     mg_cry(conn,",
          "9855:            \"Error: CGI program sent malformed or too big \"",
          "9856:            \"(>%u bytes) HTTP headers: [%.*s]\",",
          "9857:            (unsigned)buflen,",
          "9858:            data_len,",
          "9859:            buf);",
          "9861:     mg_send_http_error(",
          "9862:         conn,",
          "9863:         500,",
          "9864:         \"Error: CGI program sent malformed or too big \"",
          "9865:         \"(>%u bytes) HTTP headers: [%.*s]\",",
          "9866:         (unsigned)buflen,",
          "9867:         data_len,",
          "9868:         buf);",
          "9869:    }",
          "9871:    goto done;",
          "9872:   }",
          "9873:   pbuf = buf;",
          "9874:   buf[headers_len - 1] = '\\0';",
          "9875:   ri.num_headers = parse_http_headers(&pbuf, ri.http_headers);",
          "9878:   status_text = \"OK\";",
          "9879:   if ((status = get_header(ri.http_headers, ri.num_headers, \"Status\"))",
          "9880:       != NULL) {",
          "9881:    conn->status_code = atoi(status);",
          "9882:    status_text = status;",
          "9883:    while (isdigit(*(const unsigned char *)status_text)",
          "9884:           || *status_text == ' ') {",
          "9885:     status_text++;",
          "9886:    }",
          "9887:   } else if (get_header(ri.http_headers, ri.num_headers, \"Location\")",
          "9888:              != NULL) {",
          "9889:    conn->status_code = 302;",
          "9890:   } else {",
          "9891:    conn->status_code = 200;",
          "9892:   }",
          "9893:   connection_state =",
          "9894:       get_header(ri.http_headers, ri.num_headers, \"Connection\");",
          "9895:   if (!header_has_option(connection_state, \"keep-alive\")) {",
          "9896:    conn->must_close = 1;",
          "9897:   }",
          "9898:   (void)mg_printf(conn,",
          "9899:                   \"HTTP/1.1 %d %s\\r\\n\",",
          "9900:                   conn->status_code,",
          "9901:                   status_text);",
          "9904:   for (i = 0; i < ri.num_headers; i++) {",
          "9905:    mg_printf(conn,",
          "9906:              \"%s: %s\\r\\n\",",
          "9907:              ri.http_headers[i].name,",
          "9908:              ri.http_headers[i].value);",
          "9910:   mg_write(conn, \"\\r\\n\", 2);",
          "9913:   mg_write(conn, buf + headers_len, (size_t)(data_len - headers_len));",
          "9916:   send_file_data(conn, &fout, 0, INT64_MAX);",
          "9918:  done:",
          "9919:   mg_free(blk.var);",
          "9920:   mg_free(blk.buf);",
          "9922:   if (pid != (pid_t)-1) {",
          "9923:    kill(pid, SIGKILL);",
          "9924: #if !defined(_WIN32)",
          "9925:    {",
          "9926:     int st;",
          "9927:     while (waitpid(pid, &st, 0) != -1)",
          "9929:    }",
          "9931:   }",
          "9932:   if (fdin[0] != -1) {",
          "9933:    close(fdin[0]);",
          "9934:   }",
          "9935:   if (fdout[1] != -1) {",
          "9936:    close(fdout[1]);",
          "9937:   }",
          "9939:   if (in != NULL) {",
          "9940:    fclose(in);",
          "9941:   } else if (fdin[1] != -1) {",
          "9942:    close(fdin[1]);",
          "9943:   }",
          "9945:   if (out != NULL) {",
          "9946:    fclose(out);",
          "9947:   } else if (fdout[0] != -1) {",
          "9948:    close(fdout[0]);",
          "9949:   }",
          "9951:   if (err != NULL) {",
          "9952:    fclose(err);",
          "9953:   } else if (fderr[0] != -1) {",
          "9954:    close(fderr[0]);",
          "9955:   }",
          "9957:   if (buf != NULL) {",
          "9958:    mg_free(buf);",
          "9959:   }",
          "9965:  static void mkcol(struct mg_connection * conn, const char *path)",
          "9966:  {",
          "9967:   int rc, body_len;",
          "9968:   struct de de;",
          "9969:   char date[64];",
          "9970:   time_t curtime = time(NULL);",
          "9972:   if (conn == NULL) {",
          "9973:    return;",
          "9974:   }",
          "9979:   memset(&de.file, 0, sizeof(de.file));",
          "9980:   if (!mg_stat(conn, path, &de.file)) {",
          "9981:    mg_cry(conn,",
          "9982:           \"%s: mg_stat(%s) failed: %s\",",
          "9983:           __func__,",
          "9984:           path,",
          "9985:           strerror(ERRNO));",
          "9986:   }",
          "9988:   if (de.file.last_modified) {",
          "9994:    return;",
          "9997:   body_len = conn->data_len - conn->request_len;",
          "9998:   if (body_len > 0) {",
          "9999:    mg_send_http_error(",
          "10000:        conn, 415, \"Error: mkcol(%s): %s\", path, strerror(ERRNO));",
          "10001:    return;",
          "10002:   }",
          "10004:   rc = mg_mkdir(conn, path, 0755);",
          "10006:   if (rc == 0) {",
          "10007:    conn->status_code = 201;",
          "10008:    gmt_time_string(date, sizeof(date), &curtime);",
          "10009:    mg_printf(conn,",
          "10010:              \"HTTP/1.1 %d Created\\r\\n\"",
          "10011:              \"Date: %s\\r\\n\",",
          "10012:              conn->status_code,",
          "10013:              date);",
          "10014:    send_static_cache_header(conn);",
          "10015:    send_additional_header(conn);",
          "10016:    mg_printf(conn,",
          "10017:              \"Content-Length: 0\\r\\n\"",
          "10018:              \"Connection: %s\\r\\n\\r\\n\",",
          "10019:              suggest_connection_header(conn));",
          "10020:   } else if (rc == -1) {",
          "10021:    if (errno == EEXIST) {",
          "10022:     mg_send_http_error(",
          "10023:         conn, 405, \"Error: mkcol(%s): %s\", path, strerror(ERRNO));",
          "10024:    } else if (errno == EACCES) {",
          "10025:     mg_send_http_error(",
          "10026:         conn, 403, \"Error: mkcol(%s): %s\", path, strerror(ERRNO));",
          "10027:    } else if (errno == ENOENT) {",
          "10028:     mg_send_http_error(",
          "10029:         conn, 409, \"Error: mkcol(%s): %s\", path, strerror(ERRNO));",
          "10030:    } else {",
          "10031:     mg_send_http_error(",
          "10032:         conn, 500, \"fopen(%s): %s\", path, strerror(ERRNO));",
          "10033:    }",
          "10034:   }",
          "10038:  static void put_file(struct mg_connection * conn, const char *path)",
          "10039:  {",
          "10040:   struct mg_file file = STRUCT_FILE_INITIALIZER;",
          "10041:   const char *range;",
          "10042:   int64_t r1, r2;",
          "10043:   int rc;",
          "10044:   char date[64];",
          "10045:   time_t curtime = time(NULL);",
          "10047:   if (conn == NULL) {",
          "10048:    return;",
          "10049:   }",
          "10051:   if (mg_stat(conn, path, &file.stat)) {",
          "10053:    conn->status_code = 200;",
          "10055:    if (file.stat.is_directory) {",
          "10058:     rc = 0;",
          "10064:     if (file.access.membuf != NULL) {",
          "10066:      mg_send_http_error(conn,",
          "10067:                         405,",
          "10068:                         \"Error: Put not possible\\nReplacing %s \"",
          "10069:                         \"is not supported\",",
          "10070:                         path);",
          "10071:      return;",
          "10072:     }",
          "10075:     if (access(path, W_OK) == 0) {",
          "10077:      conn->status_code = 200;",
          "10078:      rc = 1;",
          "10079:     } else {",
          "10080:      mg_send_http_error(",
          "10081:          conn,",
          "10082:          403,",
          "10083:          \"Error: Put not possible\\nReplacing %s is not allowed\",",
          "10084:          path);",
          "10085:      return;",
          "10086:     }",
          "10088:   } else {",
          "10090:    conn->status_code = 201;",
          "10091:    rc = put_dir(conn, path);",
          "10092:   }",
          "10094:   if (rc == 0) {",
          "10096:    gmt_time_string(date, sizeof(date), &curtime);",
          "10097:    mg_printf(conn,",
          "10098:              \"HTTP/1.1 %d %s\\r\\n\",",
          "10099:              conn->status_code,",
          "10100:              mg_get_response_code_text(NULL, conn->status_code));",
          "10101:    send_no_cache_header(conn);",
          "10102:    send_additional_header(conn);",
          "10103:    mg_printf(conn,",
          "10104:              \"Date: %s\\r\\n\"",
          "10105:              \"Content-Length: 0\\r\\n\"",
          "10106:              \"Connection: %s\\r\\n\\r\\n\",",
          "10107:              date,",
          "10108:              suggest_connection_header(conn));",
          "10112:    return;",
          "10113:   }",
          "10115:   if (rc == -1) {",
          "10117:    mg_send_http_error(conn,",
          "10118:                       414,",
          "10119:                       \"Error: Path too long\\nput_dir(%s): %s\",",
          "10120:                       path,",
          "10121:                       strerror(ERRNO));",
          "10122:    return;",
          "10123:   }",
          "10125:   if (rc == -2) {",
          "10127:    mg_send_http_error(",
          "10128:        conn,",
          "10129:        500,",
          "10130:        \"Error: Can not create directory\\nput_dir(%s): %s\",",
          "10131:        path,",
          "10132:        strerror(ERRNO));",
          "10133:    return;",
          "10134:   }",
          "10138:   if (!mg_fopen(conn, path, MG_FOPEN_MODE_WRITE, &file)",
          "10139:       || file.access.fp == NULL) {",
          "10140:    (void)mg_fclose(&file.access);",
          "10141:    mg_send_http_error(conn,",
          "10142:                       500,",
          "10143:                       \"Error: Can not create file\\nfopen(%s): %s\",",
          "10144:                       path,",
          "10145:                       strerror(ERRNO));",
          "10146:    return;",
          "10147:   }",
          "10149:   fclose_on_exec(&file.access, conn);",
          "10150:   range = mg_get_header(conn, \"Content-Range\");",
          "10151:   r1 = r2 = 0;",
          "10152:   if ((range != NULL) && parse_range_header(range, &r1, &r2) > 0) {",
          "10154:    fseeko(file.access.fp, r1, SEEK_SET);",
          "10155:   }",
          "10157:   if (!forward_body_data(conn, file.access.fp, INVALID_SOCKET, NULL)) {",
          "10161:    (void)mg_fclose(&file.access);",
          "10162:    return;",
          "10163:   }",
          "10165:   if (mg_fclose(&file.access) != 0) {",
          "10168:    conn->status_code = 507;",
          "",
          "---------------",
          "--- Hunk 45 ---",
          "[Context before]",
          "10086:             \"Connection: %s\\r\\n\\r\\n\",",
          "10087:             date,",
          "10088:             suggest_connection_header(conn));",
          "10142:  }",
          "10181:  if (de.access.membuf != NULL) {",
          "",
          "[Removed Lines]",
          "10092:   return;",
          "10093:  }",
          "10095:  if (rc == -1) {",
          "10097:   mg_send_http_error(conn,",
          "10098:                      414,",
          "10099:                      \"Error: Path too long\\nput_dir(%s): %s\",",
          "10100:                      path,",
          "10101:                      strerror(ERRNO));",
          "10102:   return;",
          "10103:  }",
          "10105:  if (rc == -2) {",
          "10107:   mg_send_http_error(conn,",
          "10108:                      500,",
          "10109:                      \"Error: Can not create directory\\nput_dir(%s): %s\",",
          "10110:                      path,",
          "10111:                      strerror(ERRNO));",
          "10112:   return;",
          "10113:  }",
          "10117:  if (!mg_fopen(conn, path, MG_FOPEN_MODE_WRITE, &file)",
          "10118:      || file.access.fp == NULL) {",
          "10119:   (void)mg_fclose(&file.access);",
          "10120:   mg_send_http_error(conn,",
          "10121:                      500,",
          "10122:                      \"Error: Can not create file\\nfopen(%s): %s\",",
          "10123:                      path,",
          "10124:                      strerror(ERRNO));",
          "10125:   return;",
          "10126:  }",
          "10128:  fclose_on_exec(&file.access, conn);",
          "10129:  range = mg_get_header(conn, \"Content-Range\");",
          "10130:  r1 = r2 = 0;",
          "10131:  if ((range != NULL) && parse_range_header(range, &r1, &r2) > 0) {",
          "10133:   fseeko(file.access.fp, r1, SEEK_SET);",
          "10134:  }",
          "10136:  if (!forward_body_data(conn, file.access.fp, INVALID_SOCKET, NULL)) {",
          "10140:   (void)mg_fclose(&file.access);",
          "10141:   return;",
          "10144:  if (mg_fclose(&file.access) != 0) {",
          "10147:   conn->status_code = 507;",
          "10148:  }",
          "10150:  gmt_time_string(date, sizeof(date), &curtime);",
          "10151:  mg_printf(conn,",
          "10152:            \"HTTP/1.1 %d %s\\r\\n\",",
          "10153:            conn->status_code,",
          "10154:            mg_get_response_code_text(NULL, conn->status_code));",
          "10155:  send_no_cache_header(conn);",
          "10156:  send_additional_header(conn);",
          "10157:  mg_printf(conn,",
          "10158:            \"Date: %s\\r\\n\"",
          "10159:            \"Content-Length: 0\\r\\n\"",
          "10160:            \"Connection: %s\\r\\n\\r\\n\",",
          "10161:            date,",
          "10162:            suggest_connection_header(conn));",
          "10163: }",
          "10166: static void",
          "10167: delete_file(struct mg_connection *conn, const char *path)",
          "10168: {",
          "10169:  struct de de;",
          "10170:  memset(&de.file, 0, sizeof(de.file));",
          "10171:  if (!mg_stat(conn, path, &de.file)) {",
          "10173:   mg_send_http_error(conn,",
          "10174:                      404,",
          "10175:                      \"Error: Cannot delete file\\nFile %s not found\",",
          "10176:                      path);",
          "10177:   return;",
          "10178:  }",
          "",
          "[Added Lines]",
          "10187:  static void delete_file(struct mg_connection * conn, const char *path)",
          "10188:  {",
          "10189:   struct de de;",
          "10190:   memset(&de.file, 0, sizeof(de.file));",
          "10191:   if (!mg_stat(conn, path, &de.file)) {",
          "10193:    mg_send_http_error(conn,",
          "10194:                       404,",
          "10195:                       \"Error: Cannot delete file\\nFile %s not found\",",
          "10196:                       path);",
          "10197:    return;",
          "10198:   }",
          "",
          "---------------",
          "--- Hunk 46 ---",
          "[Context before]",
          "10189:  }",
          "10190: #endif",
          "10199:   }",
          "10226:  }",
          "10282:    (void)mg_snprintf(conn,",
          "10283:                      &truncated,",
          "10287:                      file_name);",
          "10312:   } else {",
          "10314:   }",
          "10316:  }",
          "10320: #if !defined(NO_POPEN)",
          "10333:   } else {",
          "10336:   }",
          "10337:  }",
          "10355:  }",
          "10391: #if !defined(NO_POPEN)",
          "10395:      } else {",
          "10401:      }",
          "10405:     } else {",
          "10427:     }",
          "10450:     }",
          "10451:    }",
          "10452:   }",
          "10458:  }",
          "10482:  }",
          "10493:   conn->must_close = 1;",
          "10494:   gmt_time_string(date, sizeof(date), &curtime);",
          "10499:   mg_printf(conn,",
          "10501:             \"Date: %s\\r\\n\"",
          "10507:             date,",
          "10508:             suggest_connection_header(conn));",
          "10524:  }",
          "10605:   }",
          "10609:  }",
          "10655:  }",
          "10659: #endif",
          "10666:  }",
          "10674:  }",
          "10682:  }",
          "10690:  }",
          "10693: #if defined(USE_TIMERS)",
          "10694: #define TIMER_API static",
          "",
          "[Removed Lines]",
          "10192:  if (de.file.is_directory) {",
          "10193:   if (remove_directory(conn, path)) {",
          "10195:    mg_send_http_error(conn, 204, \"%s\", \"\");",
          "10196:   } else {",
          "10198:    mg_send_http_error(conn, 500, \"Error: Could not delete %s\", path);",
          "10200:   return;",
          "10201:  }",
          "10205:  if (access(path, W_OK) != 0) {",
          "10207:   mg_send_http_error(",
          "10208:       conn,",
          "10209:       403,",
          "10210:       \"Error: Delete not possible\\nDeleting %s is not allowed\",",
          "10211:       path);",
          "10212:   return;",
          "10213:  }",
          "10216:  if (mg_remove(conn, path) == 0) {",
          "10218:   mg_send_http_error(conn, 204, \"%s\", \"\");",
          "10219:  } else {",
          "10221:   mg_send_http_error(conn,",
          "10222:                      423,",
          "10223:                      \"Error: Cannot delete file\\nremove(%s): %s\",",
          "10224:                      path,",
          "10225:                      strerror(ERRNO));",
          "10227: }",
          "10231: static void",
          "10232: send_ssi_file(struct mg_connection *, const char *, struct mg_file *, int);",
          "10235: static void",
          "10236: do_ssi_include(struct mg_connection *conn,",
          "10237:                const char *ssi,",
          "10238:                char *tag,",
          "10239:                int include_level)",
          "10240: {",
          "10241:  char file_name[MG_BUF_LEN], path[512], *p;",
          "10242:  struct mg_file file = STRUCT_FILE_INITIALIZER;",
          "10243:  size_t len;",
          "10244:  int truncated = 0;",
          "10246:  if (conn == NULL) {",
          "10247:   return;",
          "10248:  }",
          "10253:  if (sscanf(tag, \" virtual=\\\"%511[^\\\"]\\\"\", file_name) == 1) {",
          "10255:   file_name[511] = 0;",
          "10256:   (void)mg_snprintf(conn,",
          "10257:                     &truncated,",
          "10258:                     path,",
          "10259:                     sizeof(path),",
          "10260:                     \"%s/%s\",",
          "10261:                     conn->ctx->config[DOCUMENT_ROOT],",
          "10262:                     file_name);",
          "10264:  } else if (sscanf(tag, \" abspath=\\\"%511[^\\\"]\\\"\", file_name) == 1) {",
          "10267:   file_name[511] = 0;",
          "10268:   (void)",
          "10269:       mg_snprintf(conn, &truncated, path, sizeof(path), \"%s\", file_name);",
          "10271:  } else if ((sscanf(tag, \" file=\\\"%511[^\\\"]\\\"\", file_name) == 1)",
          "10272:             || (sscanf(tag, \" \\\"%511[^\\\"]\\\"\", file_name) == 1)) {",
          "10274:   file_name[511] = 0;",
          "10275:   (void)mg_snprintf(conn, &truncated, path, sizeof(path), \"%s\", ssi);",
          "10277:   if (!truncated) {",
          "10278:    if ((p = strrchr(path, '/')) != NULL) {",
          "10279:     p[1] = '\\0';",
          "10280:    }",
          "10281:    len = strlen(path);",
          "10284:                      path + len,",
          "10285:                      sizeof(path) - len,",
          "10286:                      \"%s\",",
          "10288:   }",
          "10290:  } else {",
          "10291:   mg_cry(conn, \"Bad SSI #include: [%s]\", tag);",
          "10292:   return;",
          "10293:  }",
          "10295:  if (truncated) {",
          "10296:   mg_cry(conn, \"SSI #include path length overflow: [%s]\", tag);",
          "10297:   return;",
          "10298:  }",
          "10300:  if (!mg_fopen(conn, path, MG_FOPEN_MODE_READ, &file)) {",
          "10301:   mg_cry(conn,",
          "10302:          \"Cannot open SSI #include: [%s]: fopen(%s): %s\",",
          "10303:          tag,",
          "10304:          path,",
          "10305:          strerror(ERRNO));",
          "10306:  } else {",
          "10307:   fclose_on_exec(&file.access, conn);",
          "10308:   if (match_prefix(conn->ctx->config[SSI_EXTENSIONS],",
          "10309:                    strlen(conn->ctx->config[SSI_EXTENSIONS]),",
          "10310:                    path) > 0) {",
          "10311:    send_ssi_file(conn, path, &file, include_level + 1);",
          "10313:    send_file_data(conn, &file, 0, INT64_MAX);",
          "10317: }",
          "10321: static void",
          "10322: do_ssi_exec(struct mg_connection *conn, char *tag)",
          "10323: {",
          "10324:  char cmd[1024] = \"\";",
          "10325:  struct mg_file file = STRUCT_FILE_INITIALIZER;",
          "10327:  if (sscanf(tag, \" \\\"%1023[^\\\"]\\\"\", cmd) != 1) {",
          "10328:   mg_cry(conn, \"Bad SSI #exec: [%s]\", tag);",
          "10329:  } else {",
          "10330:   cmd[1023] = 0;",
          "10331:   if ((file.access.fp = popen(cmd, \"r\")) == NULL) {",
          "10332:    mg_cry(conn, \"Cannot SSI #exec: [%s]: %s\", cmd, strerror(ERRNO));",
          "10334:    send_file_data(conn, &file, 0, INT64_MAX);",
          "10335:    pclose(file.access.fp);",
          "10338: }",
          "10342: static int",
          "10343: mg_fgetc(struct mg_file *filep, int offset)",
          "10344: {",
          "10345:  if (filep == NULL) {",
          "10346:   return EOF;",
          "10347:  }",
          "10348:  if ((filep->access.membuf != NULL) && (offset >= 0)",
          "10349:      && (((unsigned int)(offset)) < filep->stat.size)) {",
          "10350:   return ((const unsigned char *)filep->access.membuf)[offset];",
          "10351:  } else if (filep->access.fp != NULL) {",
          "10352:   return fgetc(filep->access.fp);",
          "10353:  } else {",
          "10354:   return EOF;",
          "10356: }",
          "10359: static void",
          "10360: send_ssi_file(struct mg_connection *conn,",
          "10361:               const char *path,",
          "10362:               struct mg_file *filep,",
          "10363:               int include_level)",
          "10364: {",
          "10365:  char buf[MG_BUF_LEN];",
          "10366:  int ch, offset, len, in_tag, in_ssi_tag;",
          "10368:  if (include_level > 10) {",
          "10369:   mg_cry(conn, \"SSI #include level is too deep (%s)\", path);",
          "10370:   return;",
          "10371:  }",
          "10373:  in_tag = in_ssi_tag = len = offset = 0;",
          "10376:  while ((ch = mg_fgetc(filep, offset++)) != EOF) {",
          "10378:   if (in_tag) {",
          "10381:    if (ch == '>') {",
          "10383:     buf[len++] = '>';",
          "10385:     if (in_ssi_tag) {",
          "10387:      buf[len] = 0;",
          "10389:      if (!memcmp(buf + 5, \"include\", 7)) {",
          "10390:       do_ssi_include(conn, path, buf + 12, include_level + 1);",
          "10392:      } else if (!memcmp(buf + 5, \"exec\", 4)) {",
          "10393:       do_ssi_exec(conn, buf + 9);",
          "10396:       mg_cry(conn,",
          "10397:              \"%s: unknown SSI \"",
          "10398:              \"command: \\\"%s\\\"\",",
          "10399:              path,",
          "10400:              buf);",
          "10402:      len = 0;",
          "10403:      in_ssi_tag = in_tag = 0;",
          "10408:      (void)mg_write(conn, buf, (size_t)len);",
          "10409:      len = 0;",
          "10410:      in_tag = 0;",
          "10411:     }",
          "10413:    } else {",
          "10415:     buf[len++] = (char)(ch & 0xff);",
          "10417:     if ((len == 5) && !memcmp(buf, \"<!--#\", 5)) {",
          "10419:      in_ssi_tag = 1;",
          "10420:     }",
          "10422:     if ((len + 2) > (int)sizeof(buf)) {",
          "10424:      mg_cry(conn, \"%s: tag is too large\", path);",
          "10425:      len = 0;",
          "10426:      return;",
          "10428:    }",
          "10430:   } else {",
          "10433:    if (ch == '<') {",
          "10435:     in_tag = 1;",
          "10437:     (void)mg_write(conn, buf, (size_t)len);",
          "10439:     len = 1;",
          "10440:     buf[0] = '<';",
          "10442:    } else {",
          "10445:     buf[len++] = (char)(ch & 0xff);",
          "10447:     if (len == (int)sizeof(buf)) {",
          "10448:      mg_write(conn, buf, (size_t)len);",
          "10449:      len = 0;",
          "10453:  }",
          "10456:  if (len > 0) {",
          "10457:   mg_write(conn, buf, (size_t)len);",
          "10459: }",
          "10462: static void",
          "10463: handle_ssi_file_request(struct mg_connection *conn,",
          "10464:                         const char *path,",
          "10465:                         struct mg_file *filep)",
          "10466: {",
          "10467:  char date[64];",
          "10468:  time_t curtime = time(NULL);",
          "10469:  const char *cors1, *cors2, *cors3;",
          "10471:  if ((conn == NULL) || (path == NULL) || (filep == NULL)) {",
          "10472:   return;",
          "10473:  }",
          "10475:  if (mg_get_header(conn, \"Origin\")) {",
          "10477:   cors1 = \"Access-Control-Allow-Origin: \";",
          "10478:   cors2 = conn->ctx->config[ACCESS_CONTROL_ALLOW_ORIGIN];",
          "10479:   cors3 = \"\\r\\n\";",
          "10480:  } else {",
          "10481:   cors1 = cors2 = cors3 = \"\";",
          "10484:  if (!mg_fopen(conn, path, MG_FOPEN_MODE_READ, filep)) {",
          "10487:   mg_send_http_error(conn,",
          "10488:                      500,",
          "10489:                      \"Error: Cannot read file\\nfopen(%s): %s\",",
          "10490:                      path,",
          "10491:                      strerror(ERRNO));",
          "10492:  } else {",
          "10495:   fclose_on_exec(&filep->access, conn);",
          "10496:   mg_printf(conn, \"HTTP/1.1 200 OK\\r\\n\");",
          "10497:   send_no_cache_header(conn);",
          "10498:   send_additional_header(conn);",
          "10500:             \"%s%s%s\"",
          "10502:             \"Content-Type: text/html\\r\\n\"",
          "10503:             \"Connection: %s\\r\\n\\r\\n\",",
          "10504:             cors1,",
          "10505:             cors2,",
          "10506:             cors3,",
          "10509:   send_ssi_file(conn, path, filep, 0);",
          "10511:  }",
          "10512: }",
          "10515: #if !defined(NO_FILES)",
          "10516: static void",
          "10517: send_options(struct mg_connection *conn)",
          "10518: {",
          "10519:  char date[64];",
          "10520:  time_t curtime = time(NULL);",
          "10522:  if (!conn) {",
          "10523:   return;",
          "10526:  conn->status_code = 200;",
          "10527:  conn->must_close = 1;",
          "10528:  gmt_time_string(date, sizeof(date), &curtime);",
          "10533:  mg_printf(conn,",
          "10534:            \"HTTP/1.1 200 OK\\r\\n\"",
          "10535:            \"Date: %s\\r\\n\"",
          "10536:            \"Connection: %s\\r\\n\"",
          "10537:            \"Allow: GET, POST, HEAD, CONNECT, PUT, DELETE, OPTIONS, \"",
          "10538:            \"PROPFIND, MKCOL\\r\\n\"",
          "10539:            \"DAV: 1\\r\\n\",",
          "10540:            date,",
          "10541:            suggest_connection_header(conn));",
          "10542:  send_additional_header(conn);",
          "10543:  mg_printf(conn, \"\\r\\n\");",
          "10544: }",
          "10548: static void",
          "10549: print_props(struct mg_connection *conn,",
          "10550:             const char *uri,",
          "10551:             struct mg_file_stat *filep)",
          "10552: {",
          "10553:  char mtime[64];",
          "10555:  if ((conn == NULL) || (uri == NULL) || (filep == NULL)) {",
          "10556:   return;",
          "10557:  }",
          "10559:  gmt_time_string(mtime, sizeof(mtime), &filep->last_modified);",
          "10560:  mg_printf(conn,",
          "10561:            \"<d:response>\"",
          "10562:            \"<d:href>%s</d:href>\"",
          "10563:            \"<d:propstat>\"",
          "10564:            \"<d:prop>\"",
          "10565:            \"<d:resourcetype>%s</d:resourcetype>\"",
          "10566:            \"<d:getcontentlength>%\" INT64_FMT \"</d:getcontentlength>\"",
          "10567:            \"<d:getlastmodified>%s</d:getlastmodified>\"",
          "10568:            \"</d:prop>\"",
          "10569:            \"<d:status>HTTP/1.1 200 OK</d:status>\"",
          "10570:            \"</d:propstat>\"",
          "10571:            \"</d:response>\\n\",",
          "10572:            uri,",
          "10573:            filep->is_directory ? \"<d:collection/>\" : \"\",",
          "10574:            filep->size,",
          "10575:            mtime);",
          "10576: }",
          "10579: static int",
          "10580: print_dav_dir_entry(struct de *de, void *data)",
          "10581: {",
          "10582:  char href[PATH_MAX];",
          "10583:  int truncated;",
          "10585:  struct mg_connection *conn = (struct mg_connection *)data;",
          "10586:  if (!de || !conn) {",
          "10587:   return -1;",
          "10588:  }",
          "10589:  mg_snprintf(conn,",
          "10590:              &truncated,",
          "10591:              href,",
          "10592:              sizeof(href),",
          "10593:              \"%s%s\",",
          "10594:              conn->request_info.local_uri,",
          "10595:              de->file_name);",
          "10597:  if (!truncated) {",
          "10598:   size_t href_encoded_size;",
          "10599:   char *href_encoded;",
          "10602:   href_encoded = mg_malloc(href_encoded_size);",
          "10603:   if (href_encoded == NULL) {",
          "10604:    return -1;",
          "10606:   mg_url_encode(href, href_encoded, href_encoded_size);",
          "10607:   print_props(conn, href_encoded, &de->file);",
          "10608:   mg_free(href_encoded);",
          "10611:  return 0;",
          "10612: }",
          "10615: static void",
          "10616: handle_propfind(struct mg_connection *conn,",
          "10617:                 const char *path,",
          "10618:                 struct mg_file_stat *filep)",
          "10619: {",
          "10620:  const char *depth = mg_get_header(conn, \"Depth\");",
          "10621:  char date[64];",
          "10622:  time_t curtime = time(NULL);",
          "10624:  gmt_time_string(date, sizeof(date), &curtime);",
          "10626:  if (!conn || !path || !filep || !conn->ctx) {",
          "10627:   return;",
          "10628:  }",
          "10630:  conn->must_close = 1;",
          "10631:  conn->status_code = 207;",
          "10632:  mg_printf(conn,",
          "10633:            \"HTTP/1.1 207 Multi-Status\\r\\n\"",
          "10634:            \"Date: %s\\r\\n\",",
          "10635:            date);",
          "10636:  send_static_cache_header(conn);",
          "10637:  send_additional_header(conn);",
          "10638:  mg_printf(conn,",
          "10639:            \"Connection: %s\\r\\n\"",
          "10640:            \"Content-Type: text/xml; charset=utf-8\\r\\n\\r\\n\",",
          "10641:            suggest_connection_header(conn));",
          "10643:  mg_printf(conn,",
          "10644:            \"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\"",
          "10645:            \"<d:multistatus xmlns:d='DAV:'>\\n\");",
          "10648:  print_props(conn, conn->request_info.local_uri, filep);",
          "10651:  if (filep && filep->is_directory",
          "10652:      && !mg_strcasecmp(conn->ctx->config[ENABLE_DIRECTORY_LISTING], \"yes\")",
          "10653:      && ((depth == NULL) || (strcmp(depth, \"0\") != 0))) {",
          "10654:   scan_directory(conn, path, conn, &print_dav_dir_entry);",
          "10657:  mg_printf(conn, \"%s\\n\", \"</d:multistatus>\");",
          "10658: }",
          "10661: void",
          "10662: mg_lock_connection(struct mg_connection *conn)",
          "10663: {",
          "10664:  if (conn) {",
          "10665:   (void)pthread_mutex_lock(&conn->mutex);",
          "10667: }",
          "10669: void",
          "10670: mg_unlock_connection(struct mg_connection *conn)",
          "10671: {",
          "10672:  if (conn) {",
          "10673:   (void)pthread_mutex_unlock(&conn->mutex);",
          "10675: }",
          "10677: void",
          "10678: mg_lock_context(struct mg_context *ctx)",
          "10679: {",
          "10680:  if (ctx) {",
          "10681:   (void)pthread_mutex_lock(&ctx->nonce_mutex);",
          "10683: }",
          "10685: void",
          "10686: mg_unlock_context(struct mg_context *ctx)",
          "10687: {",
          "10688:  if (ctx) {",
          "10689:   (void)pthread_mutex_unlock(&ctx->nonce_mutex);",
          "10691: }",
          "",
          "[Added Lines]",
          "10212:   if (de.file.is_directory) {",
          "10213:    if (remove_directory(conn, path)) {",
          "10215:     mg_send_http_error(conn, 204, \"%s\", \"\");",
          "10216:    } else {",
          "10218:     mg_send_http_error(conn,",
          "10219:                        500,",
          "10220:                        \"Error: Could not delete %s\",",
          "10221:                        path);",
          "10222:    }",
          "10223:    return;",
          "10228:   if (access(path, W_OK) != 0) {",
          "10230:    mg_send_http_error(",
          "10231:        conn,",
          "10232:        403,",
          "10233:        \"Error: Delete not possible\\nDeleting %s is not allowed\",",
          "10234:        path);",
          "10235:    return;",
          "10236:   }",
          "10239:   if (mg_remove(conn, path) == 0) {",
          "10241:    mg_send_http_error(conn, 204, \"%s\", \"\");",
          "10242:   } else {",
          "10244:    mg_send_http_error(conn,",
          "10245:                       423,",
          "10246:                       \"Error: Cannot delete file\\nremove(%s): %s\",",
          "10247:                       path,",
          "10248:                       strerror(ERRNO));",
          "10249:   }",
          "10254:  static void send_ssi_file(struct mg_connection *,",
          "10255:                            const char *,",
          "10256:                            struct mg_file *,",
          "10257:                            int);",
          "10260:  static void do_ssi_include(struct mg_connection * conn,",
          "10261:                             const char *ssi,",
          "10262:                             char *tag,",
          "10263:                             int include_level)",
          "10264:  {",
          "10265:   char file_name[MG_BUF_LEN], path[512], *p;",
          "10266:   struct mg_file file = STRUCT_FILE_INITIALIZER;",
          "10267:   size_t len;",
          "10268:   int truncated = 0;",
          "10270:   if (conn == NULL) {",
          "10271:    return;",
          "10272:   }",
          "10277:   if (sscanf(tag, \" virtual=\\\"%511[^\\\"]\\\"\", file_name) == 1) {",
          "10279:    file_name[511] = 0;",
          "10282:                      path,",
          "10283:                      sizeof(path),",
          "10284:                      \"%s/%s\",",
          "10285:                      conn->ctx->config[DOCUMENT_ROOT],",
          "10288:   } else if (sscanf(tag, \" abspath=\\\"%511[^\\\"]\\\"\", file_name) == 1) {",
          "10291:    file_name[511] = 0;",
          "10292:    (void)mg_snprintf(",
          "10293:        conn, &truncated, path, sizeof(path), \"%s\", file_name);",
          "10295:   } else if ((sscanf(tag, \" file=\\\"%511[^\\\"]\\\"\", file_name) == 1)",
          "10296:              || (sscanf(tag, \" \\\"%511[^\\\"]\\\"\", file_name) == 1)) {",
          "10298:    file_name[511] = 0;",
          "10299:    (void)mg_snprintf(conn, &truncated, path, sizeof(path), \"%s\", ssi);",
          "10301:    if (!truncated) {",
          "10302:     if ((p = strrchr(path, '/')) != NULL) {",
          "10303:      p[1] = '\\0';",
          "10304:     }",
          "10305:     len = strlen(path);",
          "10306:     (void)mg_snprintf(conn,",
          "10307:                       &truncated,",
          "10308:                       path + len,",
          "10309:                       sizeof(path) - len,",
          "10310:                       \"%s\",",
          "10311:                       file_name);",
          "10312:    }",
          "10314:   } else {",
          "10315:    mg_cry(conn, \"Bad SSI #include: [%s]\", tag);",
          "10316:    return;",
          "10317:   }",
          "10319:   if (truncated) {",
          "10320:    mg_cry(conn, \"SSI #include path length overflow: [%s]\", tag);",
          "10321:    return;",
          "10322:   }",
          "10324:   if (!mg_fopen(conn, path, MG_FOPEN_MODE_READ, &file)) {",
          "10325:    mg_cry(conn,",
          "10326:           \"Cannot open SSI #include: [%s]: fopen(%s): %s\",",
          "10327:           tag,",
          "10328:           path,",
          "10329:           strerror(ERRNO));",
          "10331:    fclose_on_exec(&file.access, conn);",
          "10332:    if (match_prefix(conn->ctx->config[SSI_EXTENSIONS],",
          "10333:                     strlen(conn->ctx->config[SSI_EXTENSIONS]),",
          "10334:                     path) > 0) {",
          "10335:     send_ssi_file(conn, path, &file, include_level + 1);",
          "10336:    } else {",
          "10337:     send_file_data(conn, &file, 0, INT64_MAX);",
          "10338:    }",
          "10339:    (void)mg_fclose(",
          "10346:  static void do_ssi_exec(struct mg_connection * conn, char *tag)",
          "10347:  {",
          "10348:   char cmd[1024] = \"\";",
          "10349:   struct mg_file file = STRUCT_FILE_INITIALIZER;",
          "10351:   if (sscanf(tag, \" \\\"%1023[^\\\"]\\\"\", cmd) != 1) {",
          "10352:    mg_cry(conn, \"Bad SSI #exec: [%s]\", tag);",
          "10354:    cmd[1023] = 0;",
          "10355:    if ((file.access.fp = popen(cmd, \"r\")) == NULL) {",
          "10356:     mg_cry(conn,",
          "10357:            \"Cannot SSI #exec: [%s]: %s\",",
          "10358:            cmd,",
          "10359:            strerror(ERRNO));",
          "10360:    } else {",
          "10361:     send_file_data(conn, &file, 0, INT64_MAX);",
          "10362:     pclose(file.access.fp);",
          "10363:    }",
          "10369:  static int mg_fgetc(struct mg_file * filep, int offset)",
          "10370:  {",
          "10371:   if (filep == NULL) {",
          "10372:    return EOF;",
          "10373:   }",
          "10374:   if ((filep->access.membuf != NULL) && (offset >= 0)",
          "10375:       && (((unsigned int)(offset)) < filep->stat.size)) {",
          "10376:    return ((const unsigned char *)filep->access.membuf)[offset];",
          "10377:   } else if (filep->access.fp != NULL) {",
          "10378:    return fgetc(filep->access.fp);",
          "10379:   } else {",
          "10380:    return EOF;",
          "10381:   }",
          "10385:  static void send_ssi_file(struct mg_connection * conn,",
          "10386:                            const char *path,",
          "10387:                            struct mg_file *filep,",
          "10388:                            int include_level)",
          "10389:  {",
          "10390:   char buf[MG_BUF_LEN];",
          "10391:   int ch, offset, len, in_tag, in_ssi_tag;",
          "10393:   if (include_level > 10) {",
          "10394:    mg_cry(conn, \"SSI #include level is too deep (%s)\", path);",
          "10395:    return;",
          "10396:   }",
          "10398:   in_tag = in_ssi_tag = len = offset = 0;",
          "10401:   while ((ch = mg_fgetc(filep, offset++)) != EOF) {",
          "10403:    if (in_tag) {",
          "10406:     if (ch == '>') {",
          "10408:      buf[len++] = '>';",
          "10410:      if (in_ssi_tag) {",
          "10412:       buf[len] = 0;",
          "10414:       if (!memcmp(buf + 5, \"include\", 7)) {",
          "10415:        do_ssi_include(conn,",
          "10416:                       path,",
          "10417:                       buf + 12,",
          "10418:                       include_level + 1);",
          "10420:       } else if (!memcmp(buf + 5, \"exec\", 4)) {",
          "10421:        do_ssi_exec(conn, buf + 9);",
          "10423:       } else {",
          "10424:        mg_cry(conn,",
          "10425:               \"%s: unknown SSI \"",
          "10426:               \"command: \\\"%s\\\"\",",
          "10427:               path,",
          "10428:               buf);",
          "10429:       }",
          "10430:       len = 0;",
          "10431:       in_ssi_tag = in_tag = 0;",
          "10436:       (void)mg_write(conn, buf, (size_t)len);",
          "10437:       len = 0;",
          "10438:       in_tag = 0;",
          "10443:      buf[len++] = (char)(ch & 0xff);",
          "10445:      if ((len == 5) && !memcmp(buf, \"<!--#\", 5)) {",
          "10447:       in_ssi_tag = 1;",
          "10448:      }",
          "10450:      if ((len + 2) > (int)sizeof(buf)) {",
          "10452:       mg_cry(conn, \"%s: tag is too large\", path);",
          "10453:       len = 0;",
          "10454:       return;",
          "10455:      }",
          "10458:    } else {",
          "10461:     if (ch == '<') {",
          "10463:      in_tag = 1;",
          "10465:      (void)mg_write(conn, buf, (size_t)len);",
          "10467:      len = 1;",
          "10468:      buf[0] = '<';",
          "10470:     } else {",
          "10473:      buf[len++] = (char)(ch & 0xff);",
          "10475:      if (len == (int)sizeof(buf)) {",
          "10476:       mg_write(conn, buf, (size_t)len);",
          "10477:       len = 0;",
          "10478:      }",
          "10484:   if (len > 0) {",
          "10485:    mg_write(conn, buf, (size_t)len);",
          "10486:   }",
          "10490:  static void handle_ssi_file_request(struct mg_connection * conn,",
          "10491:                                      const char *path,",
          "10492:                                      struct mg_file *filep)",
          "10493:  {",
          "10494:   char date[64];",
          "10495:   time_t curtime = time(NULL);",
          "10496:   const char *cors1, *cors2, *cors3;",
          "10498:   if ((conn == NULL) || (path == NULL) || (filep == NULL)) {",
          "10499:    return;",
          "10500:   }",
          "10502:   if (mg_get_header(conn, \"Origin\")) {",
          "10504:    cors1 = \"Access-Control-Allow-Origin: \";",
          "10505:    cors2 = conn->ctx->config[ACCESS_CONTROL_ALLOW_ORIGIN];",
          "10506:    cors3 = \"\\r\\n\";",
          "10507:   } else {",
          "10508:    cors1 = cors2 = cors3 = \"\";",
          "10509:   }",
          "10511:   if (!mg_fopen(conn, path, MG_FOPEN_MODE_READ, filep)) {",
          "10514:    mg_send_http_error(conn,",
          "10515:                       500,",
          "10516:                       \"Error: Cannot read file\\nfopen(%s): %s\",",
          "10517:                       path,",
          "10518:                       strerror(ERRNO));",
          "10519:   } else {",
          "10520:    conn->must_close = 1;",
          "10521:    gmt_time_string(date, sizeof(date), &curtime);",
          "10522:    fclose_on_exec(&filep->access, conn);",
          "10523:    mg_printf(conn, \"HTTP/1.1 200 OK\\r\\n\");",
          "10524:    send_no_cache_header(conn);",
          "10525:    send_additional_header(conn);",
          "10526:    mg_printf(conn,",
          "10527:              \"%s%s%s\"",
          "10528:              \"Date: %s\\r\\n\"",
          "10529:              \"Content-Type: text/html\\r\\n\"",
          "10530:              \"Connection: %s\\r\\n\\r\\n\",",
          "10531:              cors1,",
          "10532:              cors2,",
          "10533:              cors3,",
          "10534:              date,",
          "10535:              suggest_connection_header(conn));",
          "10536:    send_ssi_file(conn, path, filep, 0);",
          "10537:    (void)mg_fclose(",
          "10539:   }",
          "10543: #if !defined(NO_FILES)",
          "10544:  static void send_options(struct mg_connection * conn)",
          "10545:  {",
          "10546:   char date[64];",
          "10547:   time_t curtime = time(NULL);",
          "10549:   if (!conn) {",
          "10550:    return;",
          "10551:   }",
          "10553:   conn->status_code = 200;",
          "10561:             \"HTTP/1.1 200 OK\\r\\n\"",
          "10563:             \"Connection: %s\\r\\n\"",
          "10564:             \"Allow: GET, POST, HEAD, CONNECT, PUT, DELETE, OPTIONS, \"",
          "10565:             \"PROPFIND, MKCOL\\r\\n\"",
          "10566:             \"DAV: 1\\r\\n\",",
          "10569:   send_additional_header(conn);",
          "10570:   mg_printf(conn, \"\\r\\n\");",
          "10575:  static void print_props(struct mg_connection * conn,",
          "10576:                          const char *uri,",
          "10577:                          struct mg_file_stat *filep)",
          "10578:  {",
          "10579:   char mtime[64];",
          "10581:   if ((conn == NULL) || (uri == NULL) || (filep == NULL)) {",
          "10582:    return;",
          "10583:   }",
          "10585:   gmt_time_string(mtime, sizeof(mtime), &filep->last_modified);",
          "10586:   mg_printf(conn,",
          "10587:             \"<d:response>\"",
          "10588:             \"<d:href>%s</d:href>\"",
          "10589:             \"<d:propstat>\"",
          "10590:             \"<d:prop>\"",
          "10591:             \"<d:resourcetype>%s</d:resourcetype>\"",
          "10592:             \"<d:getcontentlength>%\" INT64_FMT \"</d:getcontentlength>\"",
          "10593:             \"<d:getlastmodified>%s</d:getlastmodified>\"",
          "10594:             \"</d:prop>\"",
          "10595:             \"<d:status>HTTP/1.1 200 OK</d:status>\"",
          "10596:             \"</d:propstat>\"",
          "10597:             \"</d:response>\\n\",",
          "10598:             uri,",
          "10599:             filep->is_directory ? \"<d:collection/>\" : \"\",",
          "10600:             filep->size,",
          "10601:             mtime);",
          "10602:  }",
          "10605:  static int print_dav_dir_entry(struct de * de, void *data)",
          "10606:  {",
          "10607:   char href[PATH_MAX];",
          "10608:   int truncated;",
          "10610:   struct mg_connection *conn = (struct mg_connection *)data;",
          "10611:   if (!de || !conn) {",
          "10612:    return -1;",
          "10613:   }",
          "10614:   mg_snprintf(conn,",
          "10615:               &truncated,",
          "10616:               href,",
          "10617:               sizeof(href),",
          "10618:               \"%s%s\",",
          "10619:               conn->request_info.local_uri,",
          "10620:               de->file_name);",
          "10622:   if (!truncated) {",
          "10623:    size_t href_encoded_size;",
          "10624:    char *href_encoded;",
          "10627:    href_encoded = mg_malloc(href_encoded_size);",
          "10628:    if (href_encoded == NULL) {",
          "10629:     return -1;",
          "10630:    }",
          "10631:    mg_url_encode(href, href_encoded, href_encoded_size);",
          "10632:    print_props(conn, href_encoded, &de->file);",
          "10633:    mg_free(href_encoded);",
          "10636:   return 0;",
          "10640:  static void handle_propfind(struct mg_connection * conn,",
          "10641:                              const char *path,",
          "10642:                              struct mg_file_stat *filep)",
          "10643:  {",
          "10644:   const char *depth = mg_get_header(conn, \"Depth\");",
          "10645:   char date[64];",
          "10646:   time_t curtime = time(NULL);",
          "10648:   gmt_time_string(date, sizeof(date), &curtime);",
          "10650:   if (!conn || !path || !filep || !conn->ctx) {",
          "10651:    return;",
          "10652:   }",
          "10654:   conn->must_close = 1;",
          "10655:   conn->status_code = 207;",
          "10656:   mg_printf(conn,",
          "10657:             \"HTTP/1.1 207 Multi-Status\\r\\n\"",
          "10658:             \"Date: %s\\r\\n\",",
          "10659:             date);",
          "10660:   send_static_cache_header(conn);",
          "10661:   send_additional_header(conn);",
          "10662:   mg_printf(conn,",
          "10663:             \"Connection: %s\\r\\n\"",
          "10664:             \"Content-Type: text/xml; charset=utf-8\\r\\n\\r\\n\",",
          "10665:             suggest_connection_header(conn));",
          "10667:   mg_printf(conn,",
          "10668:             \"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\"",
          "10669:             \"<d:multistatus xmlns:d='DAV:'>\\n\");",
          "10672:   print_props(conn, conn->request_info.local_uri, filep);",
          "10676:   if (filep && filep->is_directory",
          "10677:       && !mg_strcasecmp(conn->ctx->config[ENABLE_DIRECTORY_LISTING],",
          "10678:                         \"yes\")",
          "10679:       && ((depth == NULL) || (strcmp(depth, \"0\") != 0))) {",
          "10680:    scan_directory(conn, path, conn, &print_dav_dir_entry);",
          "10681:   }",
          "10683:   mg_printf(conn, \"%s\\n\", \"</d:multistatus>\");",
          "10687:  void mg_lock_connection(struct mg_connection * conn)",
          "10688:  {",
          "10689:   if (conn) {",
          "10690:    (void)pthread_mutex_lock(&conn->mutex);",
          "10691:   }",
          "10694:  void mg_unlock_connection(struct mg_connection * conn)",
          "10695:  {",
          "10696:   if (conn) {",
          "10697:    (void)pthread_mutex_unlock(&conn->mutex);",
          "10698:   }",
          "10701:  void mg_lock_context(struct mg_context * ctx)",
          "10702:  {",
          "10703:   if (ctx) {",
          "10704:    (void)pthread_mutex_lock(&ctx->nonce_mutex);",
          "10705:   }",
          "10708:  void mg_unlock_context(struct mg_context * ctx)",
          "10709:  {",
          "10710:   if (ctx) {",
          "10711:    (void)pthread_mutex_unlock(&ctx->nonce_mutex);",
          "10712:   }",
          "",
          "---------------",
          "--- Hunk 47 ---",
          "[Context before]",
          "10710: #include \"sha1.inl\"",
          "10711: #endif",
          "10833:     }",
          "10834:    }",
          "10860:       break;",
          "10866:      }",
          "10867:     }",
          "10871:     }",
          "10895:     }",
          "10932:    } else {",
          "10935:    }",
          "10936:   }",
          "10955: #if defined(__GNUC__) || defined(__MINGW32__)",
          "",
          "[Removed Lines]",
          "10713: static int",
          "10714: send_websocket_handshake(struct mg_connection *conn, const char *websock_key)",
          "10715: {",
          "10716:  static const char *magic = \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\";",
          "10717:  char buf[100], sha[20], b64_sha[sizeof(sha) * 2];",
          "10718:  SHA_CTX sha_ctx;",
          "10719:  int truncated;",
          "10722:  mg_snprintf(conn, &truncated, buf, sizeof(buf), \"%s%s\", websock_key, magic);",
          "10723:  if (truncated) {",
          "10724:   conn->must_close = 1;",
          "10725:   return 0;",
          "10726:  }",
          "10728:  SHA1_Init(&sha_ctx);",
          "10729:  SHA1_Update(&sha_ctx, (unsigned char *)buf, (uint32_t)strlen(buf));",
          "10730:  SHA1_Final((unsigned char *)sha, &sha_ctx);",
          "10731:  base64_encode((unsigned char *)sha, sizeof(sha), b64_sha);",
          "10732:  mg_printf(conn,",
          "10733:            \"HTTP/1.1 101 Switching Protocols\\r\\n\"",
          "10734:            \"Upgrade: websocket\\r\\n\"",
          "10735:            \"Connection: Upgrade\\r\\n\"",
          "10736:            \"Sec-WebSocket-Accept: %s\\r\\n\",",
          "10737:            b64_sha);",
          "10738:  if (conn->request_info.acceptedWebSocketSubprotocol) {",
          "10739:   mg_printf(conn,",
          "10740:             \"Sec-WebSocket-Protocol: %s\\r\\n\\r\\n\",",
          "10741:             conn->request_info.acceptedWebSocketSubprotocol);",
          "10742:  } else {",
          "10743:   mg_printf(conn, \"%s\", \"\\r\\n\");",
          "10744:  }",
          "10746:  return 1;",
          "10747: }",
          "10750: static void",
          "10751: read_websocket(struct mg_connection *conn,",
          "10752:                mg_websocket_data_handler ws_data_handler,",
          "10753:                void *callback_data)",
          "10754: {",
          "10759:  unsigned char *buf = (unsigned char *)conn->buf + conn->request_len;",
          "10760:  int n, error, exit_by_callback;",
          "10766:  size_t i, len, mask_len = 0, data_len = 0, header_len, body_len;",
          "10771:  unsigned char mask[4];",
          "10777:  unsigned char mem[4096];",
          "10778:  unsigned char *data = mem;",
          "10780:  double timeout = -1.0;",
          "10782:  if (conn->ctx->config[WEBSOCKET_TIMEOUT]) {",
          "10783:   timeout = atoi(conn->ctx->config[WEBSOCKET_TIMEOUT]) / 1000.0;",
          "10784:  }",
          "10785:  if ((timeout <= 0.0) && (conn->ctx->config[REQUEST_TIMEOUT])) {",
          "10786:   timeout = atoi(conn->ctx->config[REQUEST_TIMEOUT]) / 1000.0;",
          "10787:  }",
          "10789:  mg_set_thread_name(\"wsock\");",
          "10793:  while (!conn->ctx->stop_flag) {",
          "10794:   header_len = 0;",
          "10795:   assert(conn->data_len >= conn->request_len);",
          "10796:   if ((body_len = (size_t)(conn->data_len - conn->request_len)) >= 2) {",
          "10797:    len = buf[1] & 127;",
          "10798:    mask_len = (buf[1] & 128) ? 4 : 0;",
          "10799:    if ((len < 126) && (body_len >= mask_len)) {",
          "10801:     data_len = len;",
          "10802:     header_len = 2 + mask_len;",
          "10803:    } else if ((len == 126) && (body_len >= (4 + mask_len))) {",
          "10805:     header_len = 4 + mask_len;",
          "10806:     data_len = ((((size_t)buf[2]) << 8) + buf[3]);",
          "10807:    } else if (body_len >= (10 + mask_len)) {",
          "10809:     uint32_t l1, l2;",
          "10811:     memcpy(&l2, &buf[6], 4);",
          "10812:     header_len = 10 + mask_len;",
          "10813:     data_len = (((uint64_t)ntohl(l1)) << 32) + ntohl(l2);",
          "10815:     if (data_len > (uint64_t)0x7FFF0000ul) {",
          "10817:      mg_cry(conn, \"websocket out of memory; closing connection\");",
          "10818:      break;",
          "10819:     }",
          "10820:    }",
          "10821:   }",
          "10823:   if ((header_len > 0) && (body_len >= header_len)) {",
          "10825:    data = mem;",
          "10826:    if (data_len > sizeof(mem)) {",
          "10827:     data = (unsigned char *)mg_malloc_ctx(data_len, conn->ctx);",
          "10828:     if (data == NULL) {",
          "10831:      mg_cry(conn, \"websocket out of memory; closing connection\");",
          "10832:      break;",
          "10837:    if (mask_len > 0) {",
          "10838:     memcpy(mask, buf + header_len - mask_len, sizeof(mask));",
          "10839:    } else {",
          "10840:     memset(mask, 0, sizeof(mask));",
          "10841:    }",
          "10845:    assert(body_len >= header_len);",
          "10846:    if (data_len + header_len > body_len) {",
          "10849:     len = body_len - header_len;",
          "10850:     memcpy(data, buf + header_len, len);",
          "10851:     error = 0;",
          "10852:     while (len < data_len) {",
          "10853:      n = pull_inner(NULL,",
          "10854:                     conn,",
          "10855:                     (char *)(data + len),",
          "10856:                     (int)(data_len - len),",
          "10857:                     timeout);",
          "10858:      if (n <= -2) {",
          "10859:       error = 1;",
          "10861:      } else if (n > 0) {",
          "10862:       len += (size_t)n;",
          "10863:      } else {",
          "10868:     if (error) {",
          "10869:      mg_cry(conn, \"Websocket pull failed; closing connection\");",
          "10870:      break;",
          "10872:     conn->data_len = conn->request_len;",
          "10873:    } else {",
          "10874:     mop = buf[0]; /* current mask and opcode, overwritten by",
          "10878:     len = data_len + header_len;",
          "10882:     memcpy(data, buf + header_len, data_len);",
          "10885:     memmove(buf, buf + len, body_len - len);",
          "10888:     conn->data_len -= (int)len;",
          "10889:    }",
          "10892:    if (mask_len > 0) {",
          "10893:     for (i = 0; i < data_len; ++i) {",
          "10894:      data[i] ^= mask[i & 3];",
          "10896:    }",
          "10900:    exit_by_callback = 0;",
          "10901:    if ((ws_data_handler != NULL)",
          "10902:        && !ws_data_handler(",
          "10903:               conn, mop, (char *)data, data_len, callback_data)) {",
          "10904:     exit_by_callback = 1;",
          "10905:    }",
          "10907:    if (data != mem) {",
          "10908:     mg_free(data);",
          "10909:    }",
          "10911:    if (exit_by_callback",
          "10912:        || ((mop & 0xf) == WEBSOCKET_OPCODE_CONNECTION_CLOSE)) {",
          "10914:     break;",
          "10915:    }",
          "10918:   } else {",
          "10921:    n = pull_inner(NULL,",
          "10922:                   conn,",
          "10923:                   conn->buf + conn->data_len,",
          "10924:                   conn->buf_size - conn->data_len,",
          "10925:                   timeout);",
          "10926:    if (n <= -2) {",
          "10928:     break;",
          "10929:    }",
          "10930:    if (n > 0) {",
          "10931:     conn->data_len += n;",
          "10937:  }",
          "10939:  mg_set_thread_name(\"worker\");",
          "10940: }",
          "10943: static int",
          "10944: mg_websocket_write_exec(struct mg_connection *conn,",
          "10945:                         int opcode,",
          "10946:                         const char *data,",
          "10947:                         size_t dataLen,",
          "10948:                         uint32_t masking_key)",
          "10949: {",
          "10950:  unsigned char header[14];",
          "10951:  size_t headerLen = 1;",
          "10953:  int retval = -1;",
          "",
          "[Added Lines]",
          "10735:  static int send_websocket_handshake(struct mg_connection * conn,",
          "10736:                                      const char *websock_key)",
          "10737:  {",
          "10738:   static const char *magic = \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\";",
          "10739:   char buf[100], sha[20], b64_sha[sizeof(sha) * 2];",
          "10740:   SHA_CTX sha_ctx;",
          "10741:   int truncated;",
          "10744:   mg_snprintf(",
          "10745:       conn, &truncated, buf, sizeof(buf), \"%s%s\", websock_key, magic);",
          "10746:   if (truncated) {",
          "10747:    conn->must_close = 1;",
          "10748:    return 0;",
          "10749:   }",
          "10751:   SHA1_Init(&sha_ctx);",
          "10752:   SHA1_Update(&sha_ctx, (unsigned char *)buf, (uint32_t)strlen(buf));",
          "10753:   SHA1_Final((unsigned char *)sha, &sha_ctx);",
          "10754:   base64_encode((unsigned char *)sha, sizeof(sha), b64_sha);",
          "10755:   mg_printf(conn,",
          "10756:             \"HTTP/1.1 101 Switching Protocols\\r\\n\"",
          "10757:             \"Upgrade: websocket\\r\\n\"",
          "10758:             \"Connection: Upgrade\\r\\n\"",
          "10759:             \"Sec-WebSocket-Accept: %s\\r\\n\",",
          "10760:             b64_sha);",
          "10761:   if (conn->request_info.acceptedWebSocketSubprotocol) {",
          "10762:    mg_printf(conn,",
          "10763:              \"Sec-WebSocket-Protocol: %s\\r\\n\\r\\n\",",
          "10764:              conn->request_info.acceptedWebSocketSubprotocol);",
          "10765:   } else {",
          "10766:    mg_printf(conn, \"%s\", \"\\r\\n\");",
          "10767:   }",
          "10769:   return 1;",
          "10770:  }",
          "10773:  static void read_websocket(struct mg_connection * conn,",
          "10774:                             mg_websocket_data_handler ws_data_handler,",
          "10775:                             void *callback_data)",
          "10776:  {",
          "10781:   unsigned char *buf = (unsigned char *)conn->buf + conn->request_len;",
          "10782:   int n, error, exit_by_callback;",
          "10788:   size_t i, len, mask_len = 0, data_len = 0, header_len, body_len;",
          "10793:   unsigned char mask[4];",
          "10799:   unsigned char mem[4096];",
          "10800:   unsigned char *data = mem;",
          "10802:   double timeout = -1.0;",
          "10804:   if (conn->ctx->config[WEBSOCKET_TIMEOUT]) {",
          "10805:    timeout = atoi(conn->ctx->config[WEBSOCKET_TIMEOUT]) / 1000.0;",
          "10806:   }",
          "10807:   if ((timeout <= 0.0) && (conn->ctx->config[REQUEST_TIMEOUT])) {",
          "10808:    timeout = atoi(conn->ctx->config[REQUEST_TIMEOUT]) / 1000.0;",
          "10809:   }",
          "10811:   mg_set_thread_name(\"wsock\");",
          "10815:   while (!conn->ctx->stop_flag) {",
          "10816:    header_len = 0;",
          "10817:    assert(conn->data_len >= conn->request_len);",
          "10818:    if ((body_len = (size_t)(conn->data_len - conn->request_len))",
          "10819:        >= 2) {",
          "10820:     len = buf[1] & 127;",
          "10821:     mask_len = (buf[1] & 128) ? 4 : 0;",
          "10822:     if ((len < 126) && (body_len >= mask_len)) {",
          "10824:      data_len = len;",
          "10825:      header_len = 2 + mask_len;",
          "10826:     } else if ((len == 126) && (body_len >= (4 + mask_len))) {",
          "10828:      header_len = 4 + mask_len;",
          "10829:      data_len = ((((size_t)buf[2]) << 8) + buf[3]);",
          "10830:     } else if (body_len >= (10 + mask_len)) {",
          "10832:      uint32_t l1, l2;",
          "10834:      memcpy(&l2, &buf[6], 4);",
          "10835:      header_len = 10 + mask_len;",
          "10836:      data_len = (((uint64_t)ntohl(l1)) << 32) + ntohl(l2);",
          "10838:      if (data_len > (uint64_t)0x7FFF0000ul) {",
          "10840:       mg_cry(conn,",
          "10841:              \"websocket out of memory; closing connection\");",
          "10842:       break;",
          "10843:      }",
          "10847:    if ((header_len > 0) && (body_len >= header_len)) {",
          "10849:     data = mem;",
          "10850:     if (data_len > sizeof(mem)) {",
          "10851:      data = (unsigned char *)mg_malloc_ctx(data_len, conn->ctx);",
          "10852:      if (data == NULL) {",
          "10855:       mg_cry(conn,",
          "10856:              \"websocket out of memory; closing connection\");",
          "10862:     if (mask_len > 0) {",
          "10863:      memcpy(mask, buf + header_len - mask_len, sizeof(mask));",
          "10864:     } else {",
          "10865:      memset(mask, 0, sizeof(mask));",
          "10870:     assert(body_len >= header_len);",
          "10871:     if (data_len + header_len > body_len) {",
          "10874:      len = body_len - header_len;",
          "10875:      memcpy(data, buf + header_len, len);",
          "10876:      error = 0;",
          "10877:      while (len < data_len) {",
          "10878:       n = pull_inner(NULL,",
          "10879:                      conn,",
          "10880:                      (char *)(data + len),",
          "10881:                      (int)(data_len - len),",
          "10882:                      timeout);",
          "10883:       if (n <= -2) {",
          "10884:        error = 1;",
          "10885:        break;",
          "10886:       } else if (n > 0) {",
          "10887:        len += (size_t)n;",
          "10888:       } else {",
          "10891:       }",
          "10892:      }",
          "10893:      if (error) {",
          "10894:       mg_cry(conn,",
          "10895:              \"Websocket pull failed; closing connection\");",
          "10896:       break;",
          "10897:      }",
          "10898:      conn->data_len = conn->request_len;",
          "10899:     } else {",
          "10900:      mop = buf[0]; /* current mask and opcode, overwritten by",
          "10904:      len = data_len + header_len;",
          "10908:      memcpy(data, buf + header_len, data_len);",
          "10911:      memmove(buf, buf + len, body_len - len);",
          "10914:      conn->data_len -= (int)len;",
          "10918:     if (mask_len > 0) {",
          "10919:      for (i = 0; i < data_len; ++i) {",
          "10920:       data[i] ^= mask[i & 3];",
          "10921:      }",
          "10922:     }",
          "10926:     exit_by_callback = 0;",
          "10927:     if ((ws_data_handler != NULL)",
          "10928:         && !ws_data_handler(",
          "10929:                conn, mop, (char *)data, data_len, callback_data)) {",
          "10930:      exit_by_callback = 1;",
          "10931:     }",
          "10933:     if (data != mem) {",
          "10934:      mg_free(data);",
          "10935:     }",
          "10937:     if (exit_by_callback",
          "10938:         || ((mop & 0xf) == WEBSOCKET_OPCODE_CONNECTION_CLOSE)) {",
          "10940:      break;",
          "10941:     }",
          "10947:     n = pull_inner(NULL,",
          "10948:                    conn,",
          "10949:                    conn->buf + conn->data_len,",
          "10950:                    conn->buf_size - conn->data_len,",
          "10951:                    timeout);",
          "10952:     if (n <= -2) {",
          "10954:      break;",
          "10955:     }",
          "10956:     if (n > 0) {",
          "10957:      conn->data_len += n;",
          "10958:     } else {",
          "10961:     }",
          "10965:   mg_set_thread_name(\"worker\");",
          "10966:  }",
          "10969:  static int mg_websocket_write_exec(struct mg_connection * conn,",
          "10970:                                     int opcode,",
          "10971:                                     const char *data,",
          "10972:                                     size_t dataLen,",
          "10973:                                     uint32_t masking_key)",
          "10974:  {",
          "10975:   unsigned char header[14];",
          "10976:   size_t headerLen = 1;",
          "10978:   int retval = -1;",
          "",
          "---------------",
          "--- Hunk 48 ---",
          "[Context before]",
          "10958: #pragma GCC diagnostic ignored \"-Wconversion\"",
          "10959: #endif",
          "10963: #if defined(__GNUC__) || defined(__MINGW32__)",
          "10964: #pragma GCC diagnostic pop",
          "10965: #endif",
          "11042:   }",
          "11051:   }",
          "11052:  }",
          "11100: #if !defined(USE_LUA)",
          "11102: #endif",
          "11127:    }",
          "11128:   }",
          "11165:     do {",
          "11183:       }",
          "11184:      }",
          "11212:     }",
          "11214:    }",
          "11225:   }",
          "11227: #if defined(USE_LUA)",
          "11245:    }",
          "11246:   }",
          "11248: #endif",
          "11270:   }",
          "11275:    return;",
          "11276:   }",
          "11277: #endif",
          "11283: #if defined(USE_LUA)",
          "11286: #endif",
          "11292:  }",
          "11386:     throttle = (int)v;",
          "11387:    }",
          "11390:   }",
          "11402:  }",
          "",
          "[Removed Lines]",
          "10961:  header[0] = 0x80u | (unsigned char)((unsigned)opcode & 0xf);",
          "10968:  if (dataLen < 126) {",
          "10970:   header[1] = (unsigned char)dataLen;",
          "10971:   headerLen = 2;",
          "10972:  } else if (dataLen <= 0xFFFF) {",
          "10974:   uint16_t len = htons((uint16_t)dataLen);",
          "10975:   header[1] = 126;",
          "10976:   memcpy(header + 2, &len, 2);",
          "10977:   headerLen = 4;",
          "10978:  } else {",
          "10980:   uint32_t len1 = htonl((uint32_t)((uint64_t)dataLen >> 32));",
          "10981:   uint32_t len2 = htonl((uint32_t)(dataLen & 0xFFFFFFFFu));",
          "10982:   header[1] = 127;",
          "10983:   memcpy(header + 2, &len1, 4);",
          "10984:   memcpy(header + 6, &len2, 4);",
          "10985:   headerLen = 10;",
          "10986:  }",
          "10988:  if (masking_key) {",
          "10990:   header[1] |= 0x80;",
          "10991:   memcpy(header + headerLen, &masking_key, 4);",
          "10992:   headerLen += 4;",
          "10993:  }",
          "11007:  (void)mg_lock_connection(conn);",
          "11009:  retval = mg_write(conn, header, headerLen);",
          "11010:  if (dataLen > 0) {",
          "11011:   retval = mg_write(conn, data, dataLen);",
          "11012:  }",
          "11015:  mg_unlock_connection(conn);",
          "11017:  return retval;",
          "11018: }",
          "11020: int",
          "11021: mg_websocket_write(struct mg_connection *conn,",
          "11022:                    int opcode,",
          "11023:                    const char *data,",
          "11024:                    size_t dataLen)",
          "11025: {",
          "11026:  return mg_websocket_write_exec(conn, opcode, data, dataLen, 0);",
          "11027: }",
          "11030: static void",
          "11031: mask_data(const char *in, size_t in_len, uint32_t masking_key, char *out)",
          "11032: {",
          "11033:  size_t i = 0;",
          "11035:  i = 0;",
          "11036:  if ((in_len > 3) && ((ptrdiff_t)in % 4) == 0) {",
          "11038:   while (i < (in_len - 3)) {",
          "11041:    i += 4;",
          "11043:  }",
          "11044:  if (i != in_len) {",
          "11046:   while (i < in_len) {",
          "11049:        ^ *(((uint8_t *)&masking_key) + (i % 4));",
          "11050:    i++;",
          "11053: }",
          "11056: int",
          "11057: mg_websocket_client_write(struct mg_connection *conn,",
          "11058:                           int opcode,",
          "11059:                           const char *data,",
          "11060:                           size_t dataLen)",
          "11061: {",
          "11062:  int retval = -1;",
          "11063:  char *masked_data =",
          "11064:      (char *)mg_malloc_ctx(((dataLen + 7) / 4) * 4, conn->ctx);",
          "11065:  uint32_t masking_key = (uint32_t)get_random();",
          "11067:  if (masked_data == NULL) {",
          "11069:   mg_cry(conn,",
          "11070:          \"Cannot allocate buffer for masked websocket response: \"",
          "11071:          \"Out of memory\");",
          "11072:   return -1;",
          "11073:  }",
          "11075:  mask_data(data, dataLen, masking_key, masked_data);",
          "11077:  retval = mg_websocket_write_exec(",
          "11078:      conn, opcode, masked_data, dataLen, masking_key);",
          "11079:  mg_free(masked_data);",
          "11081:  return retval;",
          "11082: }",
          "11085: static void",
          "11086: handle_websocket_request(struct mg_connection *conn,",
          "11087:                          const char *path,",
          "11088:                          int is_callback_resource,",
          "11089:                          struct mg_websocket_subprotocols *subprotocols,",
          "11090:                          mg_websocket_connect_handler ws_connect_handler,",
          "11091:                          mg_websocket_ready_handler ws_ready_handler,",
          "11092:                          mg_websocket_data_handler ws_data_handler,",
          "11093:                          mg_websocket_close_handler ws_close_handler,",
          "11094:                          void *cbData)",
          "11095: {",
          "11096:  const char *websock_key = mg_get_header(conn, \"Sec-WebSocket-Key\");",
          "11097:  const char *version = mg_get_header(conn, \"Sec-WebSocket-Version\");",
          "11098:  int lua_websock = 0;",
          "11101:  (void)path;",
          "11106:  if (!websock_key) {",
          "11113:   const char *key1 = mg_get_header(conn, \"Sec-WebSocket-Key1\");",
          "11114:   const char *key2 = mg_get_header(conn, \"Sec-WebSocket-Key2\");",
          "11115:   char key3[8];",
          "11117:   if ((key1 != NULL) && (key2 != NULL)) {",
          "11119:    conn->content_len = 8;",
          "11120:    if (8 == mg_read(conn, key3, 8)) {",
          "11122:     mg_send_http_error(conn,",
          "11123:                        426,",
          "11124:                        \"%s\",",
          "11125:                        \"Protocol upgrade to RFC 6455 required\");",
          "11126:     return;",
          "11130:   mg_send_http_error(conn, 400, \"%s\", \"Malformed websocket request\");",
          "11131:   return;",
          "11132:  }",
          "11136:  if ((version == NULL) || (strcmp(version, \"13\") != 0)) {",
          "11138:   mg_send_http_error(conn, 426, \"%s\", \"Protocol upgrade required\");",
          "11139:   return;",
          "11140:  }",
          "11146:  if (is_callback_resource) {",
          "11148:   const char *protocols[64]; // max 64 headers",
          "11149:   int nbSubprotocolHeader = get_req_headers(&conn->request_info,",
          "11150:                                             \"Sec-WebSocket-Protocol\",",
          "11151:                                             protocols,",
          "11152:                                             64);",
          "11153:   if ((nbSubprotocolHeader > 0) && subprotocols) {",
          "11154:    int cnt = 0;",
          "11155:    int idx;",
          "11156:    unsigned long len;",
          "11157:    const char *sep, *curSubProtocol,",
          "11162:    do {",
          "11163:     const char *protocol = protocols[cnt];",
          "11166:      sep = strchr(protocol, ',');",
          "11167:      curSubProtocol = protocol;",
          "11168:      len = sep ? (unsigned long)(sep - protocol)",
          "11169:                : (unsigned long)strlen(protocol);",
          "11170:      while (sep && isspace(*++sep))",
          "11171:       ; // ignore leading whitespaces",
          "11172:      protocol = sep;",
          "11175:      for (idx = 0; idx < subprotocols->nb_subprotocols; idx++) {",
          "11176:       if ((strlen(subprotocols->subprotocols[idx]) == len)",
          "11177:           && (strncmp(curSubProtocol,",
          "11178:                       subprotocols->subprotocols[idx],",
          "11179:                       len) == 0)) {",
          "11180:        acceptedWebSocketSubprotocol =",
          "11181:            subprotocols->subprotocols[idx];",
          "11182:        break;",
          "11185:     } while (sep && !acceptedWebSocketSubprotocol);",
          "11186:    } while (++cnt < nbSubprotocolHeader",
          "11187:             && !acceptedWebSocketSubprotocol);",
          "11189:    conn->request_info.acceptedWebSocketSubprotocol =",
          "11190:        acceptedWebSocketSubprotocol;",
          "11191:   } else if (nbSubprotocolHeader > 0) {",
          "11193:    const char *protocol = protocols[0];",
          "11198:    const char *sep = strrchr(protocol, ',');",
          "11199:    if (sep == NULL) {",
          "11201:     conn->request_info.acceptedWebSocketSubprotocol = protocol;",
          "11202:    } else {",
          "11210:     while (isspace(*++sep)) {",
          "11213:     conn->request_info.acceptedWebSocketSubprotocol = sep;",
          "11215:   }",
          "11217:   if ((ws_connect_handler != NULL)",
          "11218:       && (ws_connect_handler(conn, cbData) != 0)) {",
          "11224:    return;",
          "11226:  }",
          "11229:  else {",
          "11231:   if (conn->ctx->config[LUA_WEBSOCKET_EXTENSIONS]) {",
          "11232:    lua_websock =",
          "11233:        match_prefix(conn->ctx->config[LUA_WEBSOCKET_EXTENSIONS],",
          "11234:                     strlen(",
          "11235:                         conn->ctx->config[LUA_WEBSOCKET_EXTENSIONS]),",
          "11236:                     path);",
          "11237:   }",
          "11239:   if (lua_websock) {",
          "11241:    conn->lua_websocket_state = lua_websocket_new(path, conn);",
          "11242:    if (!conn->lua_websocket_state) {",
          "11244:     return;",
          "11247:  }",
          "11251:  if (!is_callback_resource && !lua_websock) {",
          "11256:   mg_send_http_error(conn, 404, \"%s\", \"Not found\");",
          "11257:   return;",
          "11258:  }",
          "11261:  if (!send_websocket_handshake(conn, websock_key)) {",
          "11262:   mg_send_http_error(conn, 500, \"%s\", \"Websocket handshake failed\");",
          "11263:   return;",
          "11264:  }",
          "11267:  if (is_callback_resource) {",
          "11268:   if (ws_ready_handler != NULL) {",
          "11269:    ws_ready_handler(conn, cbData);",
          "11271: #if defined(USE_LUA)",
          "11272:  } else if (lua_websock) {",
          "11273:   if (!lua_websocket_ready(conn, conn->lua_websocket_state)) {",
          "11278:  }",
          "11281:  if (is_callback_resource) {",
          "11282:   read_websocket(conn, ws_data_handler, cbData);",
          "11284:  } else if (lua_websock) {",
          "11285:   read_websocket(conn, lua_websocket_data, conn->lua_websocket_state);",
          "11287:  }",
          "11290:  if (ws_close_handler) {",
          "11291:   ws_close_handler(conn, cbData);",
          "11293: }",
          "11296: static int",
          "11297: is_websocket_protocol(const struct mg_connection *conn)",
          "11298: {",
          "11299:  const char *upgrade, *connection;",
          "11307:  upgrade = mg_get_header(conn, \"Upgrade\");",
          "11308:  if (upgrade == NULL) {",
          "11309:   return 0; /* fail early, don't waste time checking other header",
          "11312:  }",
          "11313:  if (!mg_strcasestr(upgrade, \"websocket\")) {",
          "11314:   return 0;",
          "11315:  }",
          "11317:  connection = mg_get_header(conn, \"Connection\");",
          "11318:  if (connection == NULL) {",
          "11319:   return 0;",
          "11320:  }",
          "11321:  if (!mg_strcasestr(connection, \"upgrade\")) {",
          "11322:   return 0;",
          "11323:  }",
          "11332:  return 1;",
          "11333: }",
          "11337: static int",
          "11338: isbyte(int n)",
          "11339: {",
          "11340:  return (n >= 0) && (n <= 255);",
          "11341: }",
          "11344: static int",
          "11345: parse_net(const char *spec, uint32_t *net, uint32_t *mask)",
          "11346: {",
          "11347:  int n, a, b, c, d, slash = 32, len = 0;",
          "11349:  if (((sscanf(spec, \"%d.%d.%d.%d/%d%n\", &a, &b, &c, &d, &slash, &n) == 5)",
          "11350:       || (sscanf(spec, \"%d.%d.%d.%d%n\", &a, &b, &c, &d, &n) == 4))",
          "11351:      && isbyte(a) && isbyte(b) && isbyte(c) && isbyte(d) && (slash >= 0)",
          "11352:      && (slash < 33)) {",
          "11353:   len = n;",
          "11355:          | (uint32_t)d;",
          "11357:  }",
          "11359:  return len;",
          "11360: }",
          "11363: static int",
          "11364: set_throttle(const char *spec, uint32_t remote_ip, const char *uri)",
          "11365: {",
          "11366:  int throttle = 0;",
          "11367:  struct vec vec, val;",
          "11368:  uint32_t net, mask;",
          "11369:  char mult;",
          "11370:  double v;",
          "11372:  while ((spec = next_option(spec, &vec, &val)) != NULL) {",
          "11373:   mult = ',';",
          "11374:   if ((val.ptr == NULL) || (sscanf(val.ptr, \"%lf%c\", &v, &mult) < 1)",
          "11375:       || (v < 0) || ((lowercase(&mult) != 'k')",
          "11376:                      && (lowercase(&mult) != 'm') && (mult != ','))) {",
          "11377:    continue;",
          "11378:   }",
          "11379:   v *= (lowercase(&mult) == 'k')",
          "11380:            ? 1024",
          "11381:            : ((lowercase(&mult) == 'm') ? 1048576 : 1);",
          "11382:   if (vec.len == 1 && vec.ptr[0] == '*') {",
          "11383:    throttle = (int)v;",
          "11384:   } else if (parse_net(vec.ptr, &net, &mask) > 0) {",
          "11385:    if ((remote_ip & mask) == net) {",
          "11388:   } else if (match_prefix(vec.ptr, vec.len, uri) > 0) {",
          "11389:    throttle = (int)v;",
          "11391:  }",
          "11393:  return throttle;",
          "11394: }",
          "11397: static uint32_t",
          "11398: get_remote_ip(const struct mg_connection *conn)",
          "11399: {",
          "11400:  if (!conn) {",
          "11401:   return 0;",
          "11403:  return ntohl(*(const uint32_t *)&conn->client.rsa.sin.sin_addr);",
          "11404: }",
          "",
          "[Added Lines]",
          "10986:   header[0] = 0x80u | (unsigned char)((unsigned)opcode & 0xf);",
          "10993:   if (dataLen < 126) {",
          "10995:    header[1] = (unsigned char)dataLen;",
          "10996:    headerLen = 2;",
          "10997:   } else if (dataLen <= 0xFFFF) {",
          "10999:    uint16_t len = htons((uint16_t)dataLen);",
          "11000:    header[1] = 126;",
          "11001:    memcpy(header + 2, &len, 2);",
          "11002:    headerLen = 4;",
          "11003:   } else {",
          "11005:    uint32_t len1 = htonl((uint32_t)((uint64_t)dataLen >> 32));",
          "11006:    uint32_t len2 = htonl((uint32_t)(dataLen & 0xFFFFFFFFu));",
          "11007:    header[1] = 127;",
          "11008:    memcpy(header + 2, &len1, 4);",
          "11009:    memcpy(header + 6, &len2, 4);",
          "11010:    headerLen = 10;",
          "11011:   }",
          "11013:   if (masking_key) {",
          "11015:    header[1] |= 0x80;",
          "11016:    memcpy(header + headerLen, &masking_key, 4);",
          "11017:    headerLen += 4;",
          "11018:   }",
          "11032:   (void)mg_lock_connection(conn);",
          "11034:   retval = mg_write(conn, header, headerLen);",
          "11035:   if (dataLen > 0) {",
          "11036:    retval = mg_write(conn, data, dataLen);",
          "11037:   }",
          "11040:   mg_unlock_connection(conn);",
          "11042:   return retval;",
          "11043:  }",
          "11045:  int mg_websocket_write(struct mg_connection * conn,",
          "11046:                         int opcode,",
          "11047:                         const char *data,",
          "11048:                         size_t dataLen)",
          "11049:  {",
          "11050:   return mg_websocket_write_exec(conn, opcode, data, dataLen, 0);",
          "11051:  }",
          "11054:  static void mask_data(const char *in,",
          "11055:                        size_t in_len,",
          "11056:                        uint32_t masking_key,",
          "11057:                        char *out)",
          "11058:  {",
          "11059:   size_t i = 0;",
          "11061:   i = 0;",
          "11062:   if ((in_len > 3) && ((ptrdiff_t)in % 4) == 0) {",
          "11064:    while (i < (in_len - 3)) {",
          "11067:     i += 4;",
          "11068:    }",
          "11070:   if (i != in_len) {",
          "11072:    while (i < in_len) {",
          "11075:         ^ *(((uint8_t *)&masking_key) + (i % 4));",
          "11076:     i++;",
          "11077:    }",
          "11082:  int mg_websocket_client_write(struct mg_connection * conn,",
          "11083:                                int opcode,",
          "11084:                                const char *data,",
          "11085:                                size_t dataLen)",
          "11086:  {",
          "11087:   int retval = -1;",
          "11088:   char *masked_data =",
          "11089:       (char *)mg_malloc_ctx(((dataLen + 7) / 4) * 4, conn->ctx);",
          "11090:   uint32_t masking_key = (uint32_t)get_random();",
          "11092:   if (masked_data == NULL) {",
          "11094:    mg_cry(conn,",
          "11095:           \"Cannot allocate buffer for masked websocket response: \"",
          "11096:           \"Out of memory\");",
          "11097:    return -1;",
          "11098:   }",
          "11100:   mask_data(data, dataLen, masking_key, masked_data);",
          "11102:   retval = mg_websocket_write_exec(",
          "11103:       conn, opcode, masked_data, dataLen, masking_key);",
          "11104:   mg_free(masked_data);",
          "11106:   return retval;",
          "11107:  }",
          "11110:  static void handle_websocket_request(",
          "11111:      struct mg_connection * conn,",
          "11112:      const char *path,",
          "11113:      int is_callback_resource,",
          "11114:      struct mg_websocket_subprotocols *subprotocols,",
          "11115:      mg_websocket_connect_handler ws_connect_handler,",
          "11116:      mg_websocket_ready_handler ws_ready_handler,",
          "11117:      mg_websocket_data_handler ws_data_handler,",
          "11118:      mg_websocket_close_handler ws_close_handler,",
          "11119:      void *cbData)",
          "11120:  {",
          "11121:   const char *websock_key = mg_get_header(conn, \"Sec-WebSocket-Key\");",
          "11122:   const char *version = mg_get_header(conn, \"Sec-WebSocket-Version\");",
          "11123:   int lua_websock = 0;",
          "11126:   (void)path;",
          "11131:   if (!websock_key) {",
          "11138:    const char *key1 = mg_get_header(conn, \"Sec-WebSocket-Key1\");",
          "11139:    const char *key2 = mg_get_header(conn, \"Sec-WebSocket-Key2\");",
          "11140:    char key3[8];",
          "11142:    if ((key1 != NULL) && (key2 != NULL)) {",
          "11144:     conn->content_len = 8;",
          "11145:     if (8 == mg_read(conn, key3, 8)) {",
          "11147:      mg_send_http_error(conn,",
          "11148:                         426,",
          "11149:                         \"%s\",",
          "11150:                         \"Protocol upgrade to RFC 6455 required\");",
          "11151:      return;",
          "11152:     }",
          "11155:    mg_send_http_error(conn, 400, \"%s\", \"Malformed websocket request\");",
          "11156:    return;",
          "11161:   if ((version == NULL) || (strcmp(version, \"13\") != 0)) {",
          "11163:    mg_send_http_error(conn, 426, \"%s\", \"Protocol upgrade required\");",
          "11164:    return;",
          "11165:   }",
          "11171:   if (is_callback_resource) {",
          "11173:    const char *protocols[64]; // max 64 headers",
          "11174:    int nbSubprotocolHeader = get_req_headers(&conn->request_info,",
          "11175:                                              \"Sec-WebSocket-Protocol\",",
          "11176:                                              protocols,",
          "11177:                                              64);",
          "11178:    if ((nbSubprotocolHeader > 0) && subprotocols) {",
          "11179:     int cnt = 0;",
          "11180:     int idx;",
          "11181:     unsigned long len;",
          "11182:     const char *sep, *curSubProtocol,",
          "11188:      const char *protocol = protocols[cnt];",
          "11190:      do {",
          "11191:       sep = strchr(protocol, ',');",
          "11192:       curSubProtocol = protocol;",
          "11193:       len = sep ? (unsigned long)(sep - protocol)",
          "11194:                 : (unsigned long)strlen(protocol);",
          "11195:       while (sep && isspace(*++sep))",
          "11196:        ; // ignore leading whitespaces",
          "11197:       protocol = sep;",
          "11200:       for (idx = 0; idx < subprotocols->nb_subprotocols;",
          "11201:            idx++) {",
          "11202:        if ((strlen(subprotocols->subprotocols[idx]) == len)",
          "11203:            && (strncmp(curSubProtocol,",
          "11204:                        subprotocols->subprotocols[idx],",
          "11205:                        len) == 0)) {",
          "11206:         acceptedWebSocketSubprotocol =",
          "11207:             subprotocols->subprotocols[idx];",
          "11208:         break;",
          "11209:        }",
          "11211:      } while (sep && !acceptedWebSocketSubprotocol);",
          "11212:     } while (++cnt < nbSubprotocolHeader",
          "11213:              && !acceptedWebSocketSubprotocol);",
          "11215:     conn->request_info.acceptedWebSocketSubprotocol =",
          "11216:         acceptedWebSocketSubprotocol;",
          "11217:    } else if (nbSubprotocolHeader > 0) {",
          "11219:     const char *protocol = protocols[0];",
          "11224:     const char *sep = strrchr(protocol, ',');",
          "11225:     if (sep == NULL) {",
          "11227:      conn->request_info.acceptedWebSocketSubprotocol = protocol;",
          "11228:     } else {",
          "11237:      while (isspace(*++sep)) {",
          "11240:      conn->request_info.acceptedWebSocketSubprotocol = sep;",
          "11244:    if ((ws_connect_handler != NULL)",
          "11245:        && (ws_connect_handler(conn, cbData) != 0)) {",
          "11251:     return;",
          "11252:    }",
          "11256:   else {",
          "11258:    if (conn->ctx->config[LUA_WEBSOCKET_EXTENSIONS]) {",
          "11259:     lua_websock = match_prefix(",
          "11260:         conn->ctx->config[LUA_WEBSOCKET_EXTENSIONS],",
          "11261:         strlen(conn->ctx->config[LUA_WEBSOCKET_EXTENSIONS]),",
          "11262:         path);",
          "11263:    }",
          "11265:    if (lua_websock) {",
          "11267:     conn->lua_websocket_state = lua_websocket_new(path, conn);",
          "11268:     if (!conn->lua_websocket_state) {",
          "11270:      return;",
          "11271:     }",
          "11277:   if (!is_callback_resource && !lua_websock) {",
          "11282:    mg_send_http_error(conn, 404, \"%s\", \"Not found\");",
          "11283:    return;",
          "11287:   if (!send_websocket_handshake(conn, websock_key)) {",
          "11288:    mg_send_http_error(conn, 500, \"%s\", \"Websocket handshake failed\");",
          "11293:   if (is_callback_resource) {",
          "11294:    if (ws_ready_handler != NULL) {",
          "11295:     ws_ready_handler(conn, cbData);",
          "11296:    }",
          "11297: #if defined(USE_LUA)",
          "11298:   } else if (lua_websock) {",
          "11299:    if (!lua_websocket_ready(conn, conn->lua_websocket_state)) {",
          "11301:     return;",
          "11302:    }",
          "11304:   }",
          "11307:   if (is_callback_resource) {",
          "11308:    read_websocket(conn, ws_data_handler, cbData);",
          "11310:   } else if (lua_websock) {",
          "11311:    read_websocket(conn, lua_websocket_data, conn->lua_websocket_state);",
          "11313:   }",
          "11316:   if (ws_close_handler) {",
          "11317:    ws_close_handler(conn, cbData);",
          "11318:   }",
          "11322:  static int is_websocket_protocol(const struct mg_connection *conn)",
          "11323:  {",
          "11324:   const char *upgrade, *connection;",
          "11332:   upgrade = mg_get_header(conn, \"Upgrade\");",
          "11333:   if (upgrade == NULL) {",
          "11334:    return 0; /* fail early, don't waste time checking other header",
          "11337:   }",
          "11338:   if (!mg_strcasestr(upgrade, \"websocket\")) {",
          "11339:    return 0;",
          "11340:   }",
          "11342:   connection = mg_get_header(conn, \"Connection\");",
          "11343:   if (connection == NULL) {",
          "11344:    return 0;",
          "11345:   }",
          "11346:   if (!mg_strcasestr(connection, \"upgrade\")) {",
          "11347:    return 0;",
          "11348:   }",
          "11357:   return 1;",
          "11358:  }",
          "11362:  static int isbyte(int n)",
          "11363:  {",
          "11364:   return (n >= 0) && (n <= 255);",
          "11365:  }",
          "11368:  static int parse_net(const char *spec, uint32_t *net, uint32_t *mask)",
          "11369:  {",
          "11370:   int n, a, b, c, d, slash = 32, len = 0;",
          "11372:   if (((sscanf(spec, \"%d.%d.%d.%d/%d%n\", &a, &b, &c, &d, &slash, &n) == 5)",
          "11373:        || (sscanf(spec, \"%d.%d.%d.%d%n\", &a, &b, &c, &d, &n) == 4))",
          "11374:       && isbyte(a) && isbyte(b) && isbyte(c) && isbyte(d) && (slash >= 0)",
          "11375:       && (slash < 33)) {",
          "11376:    len = n;",
          "11378:           | ((uint32_t)c << 8) | (uint32_t)d;",
          "11380:   }",
          "11382:   return len;",
          "11383:  }",
          "11386:  static int set_throttle(const char *spec,",
          "11387:                          uint32_t remote_ip,",
          "11388:                          const char *uri)",
          "11389:  {",
          "11390:   int throttle = 0;",
          "11391:   struct vec vec, val;",
          "11392:   uint32_t net, mask;",
          "11393:   char mult;",
          "11394:   double v;",
          "11396:   while ((spec = next_option(spec, &vec, &val)) != NULL) {",
          "11397:    mult = ',';",
          "11398:    if ((val.ptr == NULL) || (sscanf(val.ptr, \"%lf%c\", &v, &mult) < 1)",
          "11399:        || (v < 0) || ((lowercase(&mult) != 'k')",
          "11400:                       && (lowercase(&mult) != 'm') && (mult != ','))) {",
          "11401:     continue;",
          "11402:    }",
          "11403:    v *= (lowercase(&mult) == 'k')",
          "11404:             ? 1024",
          "11405:             : ((lowercase(&mult) == 'm') ? 1048576 : 1);",
          "11406:    if (vec.len == 1 && vec.ptr[0] == '*') {",
          "11407:     throttle = (int)v;",
          "11408:    } else if (parse_net(vec.ptr, &net, &mask) > 0) {",
          "11409:     if ((remote_ip & mask) == net) {",
          "11410:      throttle = (int)v;",
          "11411:     }",
          "11412:    } else if (match_prefix(vec.ptr, vec.len, uri) > 0) {",
          "11417:   return throttle;",
          "11418:  }",
          "11421:  static uint32_t get_remote_ip(const struct mg_connection *conn)",
          "11422:  {",
          "11423:   if (!conn) {",
          "11424:    return 0;",
          "11425:   }",
          "11426:   return ntohl(*(const uint32_t *)&conn->client.rsa.sin.sin_addr);",
          "",
          "---------------",
          "--- Hunk 49 ---",
          "[Context before]",
          "11411: #if defined(MG_LEGACY_INTERFACE)",
          "11502:  }",
          "11506: #endif",
          "11517:   }",
          "11518:  }",
          "11546:   }",
          "11554: #if defined(USE_IPV6)",
          "11672:     return;",
          "11673:    }",
          "11852:      }",
          "11856:     }",
          "11857:    }",
          "11876:      }",
          "11880:     }",
          "11881:    }",
          "11899:      }",
          "11903:     }",
          "11904:    }",
          "11908:  }",
          "11928: #if defined(USE_WEBSOCKET) && defined(MG_LEGACY_INTERFACE)",
          "11936:  }",
          "11948:  }",
          "11962:  }",
          "11966: #endif",
          "12058:    return;",
          "12059:   }",
          "12124:    }",
          "12129:   }",
          "12138: #if defined(USE_WEBSOCKET)",
          "12140: #else",
          "12141:  handler_type = REQUEST_HANDLER;",
          "12196: #if defined(NO_FILES)",
          "12198: #else",
          "12199:   if (conn->ctx->config[DOCUMENT_ROOT] == NULL) {",
          "12200: #endif",
          "12210: #if !defined(NO_FILES)",
          "12218: #endif",
          "12227:   }",
          "12281: #if defined(USE_WEBSOCKET)",
          "12291: #endif",
          "12292:   }",
          "12297: #if defined(USE_WEBSOCKET)",
          "12312:    } else {",
          "12317: #if defined(MG_LEGACY_INTERFACE)",
          "12328: #else",
          "12329:    mg_send_http_error(conn, 404, \"%s\", \"Not found\");",
          "12330: #endif",
          "12334: #endif",
          "12336: #if defined(NO_FILES)",
          "12342: #else",
          "",
          "[Removed Lines]",
          "11417: struct mg_upload_user_data {",
          "11418:  struct mg_connection *conn;",
          "11419:  const char *destination_dir;",
          "11420:  int num_uploaded_files;",
          "11421: };",
          "11425: static int",
          "11426: mg_upload_field_found(const char *key,",
          "11427:                       const char *filename,",
          "11428:                       char *path,",
          "11429:                       size_t pathlen,",
          "11430:                       void *user_data)",
          "11431: {",
          "11432:  int truncated = 0;",
          "11433:  struct mg_upload_user_data *fud = (struct mg_upload_user_data *)user_data;",
          "11434:  (void)key;",
          "11436:  if (!filename) {",
          "11437:   mg_cry(fud->conn, \"%s: No filename set\", __func__);",
          "11438:   return FORM_FIELD_STORAGE_ABORT;",
          "11439:  }",
          "11440:  mg_snprintf(fud->conn,",
          "11441:              &truncated,",
          "11442:              path,",
          "11443:              pathlen - 1,",
          "11444:              \"%s/%s\",",
          "11445:              fud->destination_dir,",
          "11446:              filename);",
          "11447:  if (!truncated) {",
          "11448:   mg_cry(fud->conn, \"%s: File path too long\", __func__);",
          "11449:   return FORM_FIELD_STORAGE_ABORT;",
          "11450:  }",
          "11451:  return FORM_FIELD_STORAGE_STORE;",
          "11452: }",
          "11456: static int",
          "11457: mg_upload_field_get(const char *key,",
          "11458:                     const char *value,",
          "11459:                     size_t value_size,",
          "11460:                     void *user_data)",
          "11461: {",
          "11463:  (void)key;",
          "11464:  (void)value;",
          "11465:  (void)value_size;",
          "11466:  (void)user_data;",
          "11468:  return 0;",
          "11469: }",
          "11473: static int",
          "11474: mg_upload_field_stored(const char *path, long long file_size, void *user_data)",
          "11475: {",
          "11476:  struct mg_upload_user_data *fud = (struct mg_upload_user_data *)user_data;",
          "11477:  (void)file_size;",
          "11479:  fud->num_uploaded_files++;",
          "11480:  fud->conn->ctx->callbacks.upload(fud->conn, path);",
          "11482:  return 0;",
          "11483: }",
          "11487: int",
          "11488: mg_upload(struct mg_connection *conn, const char *destination_dir)",
          "11489: {",
          "11490:  struct mg_upload_user_data fud = {conn, destination_dir, 0};",
          "11491:  struct mg_form_data_handler fdh = {mg_upload_field_found,",
          "11492:                                     mg_upload_field_get,",
          "11493:                                     mg_upload_field_stored,",
          "11494:                                     0};",
          "11495:  int ret;",
          "11497:  fdh.user_data = (void *)&fud;",
          "11498:  ret = mg_handle_form_request(conn, &fdh);",
          "11500:  if (ret < 0) {",
          "11501:   mg_cry(conn, \"%s: Error while parsing the request\", __func__);",
          "11504:  return fud.num_uploaded_files;",
          "11505: }",
          "11509: static int",
          "11510: get_first_ssl_listener_index(const struct mg_context *ctx)",
          "11511: {",
          "11512:  unsigned int i;",
          "11513:  int idx = -1;",
          "11514:  if (ctx) {",
          "11515:   for (i = 0; ((idx == -1) && (i < ctx->num_listening_sockets)); i++) {",
          "11516:    idx = ctx->listening_sockets[i].is_ssl ? ((int)(i)) : -1;",
          "11519:  return idx;",
          "11520: }",
          "11523: static void",
          "11524: redirect_to_https_port(struct mg_connection *conn, int ssl_index)",
          "11525: {",
          "11526:  char host[1025];",
          "11527:  const char *host_header;",
          "11528:  size_t hostlen;",
          "11530:  host_header = mg_get_header(conn, \"Host\");",
          "11531:  hostlen = sizeof(host);",
          "11532:  if (host_header != NULL) {",
          "11533:   char *pos;",
          "11535:   mg_strlcpy(host, host_header, hostlen);",
          "11536:   host[hostlen - 1] = '\\0';",
          "11537:   pos = strchr(host, ':');",
          "11538:   if (pos != NULL) {",
          "11540:   }",
          "11541:  } else {",
          "11544:   if (conn) {",
          "11545:    sockaddr_to_string(host, hostlen, &conn->client.lsa);",
          "11547:  }",
          "11550:  if (conn) {",
          "11551:   mg_printf(conn,",
          "11552:             \"HTTP/1.1 302 Found\\r\\nLocation: https://%s:%d%s%s%s\\r\\n\\r\\n\",",
          "11553:             host,",
          "11555:             (conn->ctx->listening_sockets[ssl_index].lsa.sa.sa_family",
          "11556:              == AF_INET6)",
          "11557:                 ? (int)ntohs(conn->ctx->listening_sockets[ssl_index]",
          "11558:                                  .lsa.sin6.sin6_port)",
          "11559:                 :",
          "11560: #endif",
          "11561:                 (int)ntohs(conn->ctx->listening_sockets[ssl_index]",
          "11562:                                .lsa.sin.sin_port),",
          "11563:             conn->request_info.local_uri,",
          "11564:             (conn->request_info.query_string == NULL) ? \"\" : \"?\",",
          "11565:             (conn->request_info.query_string == NULL)",
          "11566:                 ? \"\"",
          "11567:                 : conn->request_info.query_string);",
          "11568:  }",
          "11569: }",
          "11572: static void",
          "11573: mg_set_handler_type(struct mg_context *ctx,",
          "11574:                     const char *uri,",
          "11575:                     int handler_type,",
          "11576:                     int is_delete_request,",
          "11577:                     mg_request_handler handler,",
          "11578:                     struct mg_websocket_subprotocols *subprotocols,",
          "11579:                     mg_websocket_connect_handler connect_handler,",
          "11580:                     mg_websocket_ready_handler ready_handler,",
          "11581:                     mg_websocket_data_handler data_handler,",
          "11582:                     mg_websocket_close_handler close_handler,",
          "11583:                     mg_authorization_handler auth_handler,",
          "11584:                     void *cbdata)",
          "11585: {",
          "11586:  struct mg_handler_info *tmp_rh, **lastref;",
          "11587:  size_t urilen = strlen(uri);",
          "11589:  if (handler_type == WEBSOCKET_HANDLER) {",
          "11596:   if (handler != NULL) {",
          "11597:    return;",
          "11598:   }",
          "11599:   if (!is_delete_request && (connect_handler == NULL)",
          "11600:       && (ready_handler == NULL) && (data_handler == NULL)",
          "11601:       && (close_handler == NULL)) {",
          "11602:    return;",
          "11603:   }",
          "11604:   if (auth_handler != NULL) {",
          "11605:    return;",
          "11606:   }",
          "11607:  } else if (handler_type == REQUEST_HANDLER) {",
          "11613:   if ((connect_handler != NULL) || (ready_handler != NULL)",
          "11614:       || (data_handler != NULL) || (close_handler != NULL)) {",
          "11615:    return;",
          "11616:   }",
          "11617:   if (!is_delete_request && (handler == NULL)) {",
          "11618:    return;",
          "11619:   }",
          "11620:   if (auth_handler != NULL) {",
          "11621:    return;",
          "11622:   }",
          "11628:   if (handler != NULL) {",
          "11629:    return;",
          "11630:   }",
          "11631:   if ((connect_handler != NULL) || (ready_handler != NULL)",
          "11632:       || (data_handler != NULL) || (close_handler != NULL)) {",
          "11633:    return;",
          "11634:   }",
          "11635:   if (!is_delete_request && (auth_handler == NULL)) {",
          "11636:    return;",
          "11637:   }",
          "11638:  }",
          "11640:  if (!ctx) {",
          "11641:   return;",
          "11642:  }",
          "11644:  mg_lock_context(ctx);",
          "11647:  lastref = &(ctx->handlers);",
          "11648:  for (tmp_rh = ctx->handlers; tmp_rh != NULL; tmp_rh = tmp_rh->next) {",
          "11649:   if (tmp_rh->handler_type == handler_type) {",
          "11650:    if ((urilen == tmp_rh->uri_len) && !strcmp(tmp_rh->uri, uri)) {",
          "11651:     if (!is_delete_request) {",
          "11653:      if (handler_type == REQUEST_HANDLER) {",
          "11654:       tmp_rh->handler = handler;",
          "11655:      } else if (handler_type == WEBSOCKET_HANDLER) {",
          "11656:       tmp_rh->subprotocols = subprotocols;",
          "11657:       tmp_rh->connect_handler = connect_handler;",
          "11658:       tmp_rh->ready_handler = ready_handler;",
          "11659:       tmp_rh->data_handler = data_handler;",
          "11660:       tmp_rh->close_handler = close_handler;",
          "11662:       tmp_rh->auth_handler = auth_handler;",
          "11663:      }",
          "11664:      tmp_rh->cbdata = cbdata;",
          "11665:     } else {",
          "11668:      mg_free(tmp_rh->uri);",
          "11669:      mg_free(tmp_rh);",
          "11670:     }",
          "11671:     mg_unlock_context(ctx);",
          "11674:   }",
          "11675:   lastref = &(tmp_rh->next);",
          "11676:  }",
          "11678:  if (is_delete_request) {",
          "11681:   mg_unlock_context(ctx);",
          "11682:   return;",
          "11683:  }",
          "11685:  tmp_rh =",
          "11686:      (struct mg_handler_info *)mg_calloc_ctx(sizeof(struct mg_handler_info),",
          "11687:                                              1,",
          "11688:                                              ctx);",
          "11689:  if (tmp_rh == NULL) {",
          "11690:   mg_unlock_context(ctx);",
          "11691:   mg_cry(fc(ctx), \"%s\", \"Cannot create new request handler struct, OOM\");",
          "11692:   return;",
          "11693:  }",
          "11694:  tmp_rh->uri = mg_strdup(uri);",
          "11695:  if (!tmp_rh->uri) {",
          "11696:   mg_unlock_context(ctx);",
          "11697:   mg_free(tmp_rh);",
          "11698:   mg_cry(fc(ctx), \"%s\", \"Cannot create new request handler struct, OOM\");",
          "11699:   return;",
          "11700:  }",
          "11701:  tmp_rh->uri_len = urilen;",
          "11702:  if (handler_type == REQUEST_HANDLER) {",
          "11703:   tmp_rh->handler = handler;",
          "11704:  } else if (handler_type == WEBSOCKET_HANDLER) {",
          "11705:   tmp_rh->subprotocols = subprotocols;",
          "11706:   tmp_rh->connect_handler = connect_handler;",
          "11707:   tmp_rh->ready_handler = ready_handler;",
          "11708:   tmp_rh->data_handler = data_handler;",
          "11709:   tmp_rh->close_handler = close_handler;",
          "11711:   tmp_rh->auth_handler = auth_handler;",
          "11712:  }",
          "11713:  tmp_rh->cbdata = cbdata;",
          "11714:  tmp_rh->handler_type = handler_type;",
          "11715:  tmp_rh->next = NULL;",
          "11718:  mg_unlock_context(ctx);",
          "11719: }",
          "11722: void",
          "11723: mg_set_request_handler(struct mg_context *ctx,",
          "11724:                        const char *uri,",
          "11725:                        mg_request_handler handler,",
          "11726:                        void *cbdata)",
          "11727: {",
          "11728:  mg_set_handler_type(ctx,",
          "11729:                      uri,",
          "11730:                      REQUEST_HANDLER,",
          "11731:                      handler == NULL,",
          "11732:                      handler,",
          "11733:                      NULL,",
          "11734:                      NULL,",
          "11735:                      NULL,",
          "11736:                      NULL,",
          "11737:                      NULL,",
          "11738:                      NULL,",
          "11739:                      cbdata);",
          "11740: }",
          "11743: void",
          "11744: mg_set_websocket_handler(struct mg_context *ctx,",
          "11745:                          const char *uri,",
          "11746:                          mg_websocket_connect_handler connect_handler,",
          "11747:                          mg_websocket_ready_handler ready_handler,",
          "11748:                          mg_websocket_data_handler data_handler,",
          "11749:                          mg_websocket_close_handler close_handler,",
          "11750:                          void *cbdata)",
          "11751: {",
          "11752:  mg_set_websocket_handler_with_subprotocols(ctx,",
          "11753:                                             uri,",
          "11754:                                             NULL,",
          "11755:                                             connect_handler,",
          "11756:                                             ready_handler,",
          "11757:                                             data_handler,",
          "11758:                                             close_handler,",
          "11759:                                             cbdata);",
          "11760: }",
          "11763: void",
          "11764: mg_set_websocket_handler_with_subprotocols(",
          "11765:     struct mg_context *ctx,",
          "11766:     const char *uri,",
          "11767:     struct mg_websocket_subprotocols *subprotocols,",
          "11768:     mg_websocket_connect_handler connect_handler,",
          "11769:     mg_websocket_ready_handler ready_handler,",
          "11770:     mg_websocket_data_handler data_handler,",
          "11771:     mg_websocket_close_handler close_handler,",
          "11772:     void *cbdata)",
          "11773: {",
          "11774:  int is_delete_request = (connect_handler == NULL) && (ready_handler == NULL)",
          "11775:                          && (data_handler == NULL)",
          "11776:                          && (close_handler == NULL);",
          "11777:  mg_set_handler_type(ctx,",
          "11778:                      uri,",
          "11779:                      WEBSOCKET_HANDLER,",
          "11780:                      is_delete_request,",
          "11781:                      NULL,",
          "11782:                      subprotocols,",
          "11783:                      connect_handler,",
          "11784:                      ready_handler,",
          "11785:                      data_handler,",
          "11786:                      close_handler,",
          "11787:                      NULL,",
          "11788:                      cbdata);",
          "11789: }",
          "11792: void",
          "11793: mg_set_auth_handler(struct mg_context *ctx,",
          "11794:                     const char *uri,",
          "11795:                     mg_request_handler handler,",
          "11796:                     void *cbdata)",
          "11797: {",
          "11798:  mg_set_handler_type(ctx,",
          "11799:                      uri,",
          "11800:                      AUTH_HANDLER,",
          "11801:                      handler == NULL,",
          "11802:                      NULL,",
          "11803:                      NULL,",
          "11804:                      NULL,",
          "11805:                      NULL,",
          "11806:                      NULL,",
          "11807:                      NULL,",
          "11808:                      handler,",
          "11809:                      cbdata);",
          "11810: }",
          "11813: static int",
          "11814: get_request_handler(struct mg_connection *conn,",
          "11815:                     int handler_type,",
          "11816:                     mg_request_handler *handler,",
          "11817:                     struct mg_websocket_subprotocols **subprotocols,",
          "11818:                     mg_websocket_connect_handler *connect_handler,",
          "11819:                     mg_websocket_ready_handler *ready_handler,",
          "11820:                     mg_websocket_data_handler *data_handler,",
          "11821:                     mg_websocket_close_handler *close_handler,",
          "11822:                     mg_authorization_handler *auth_handler,",
          "11823:                     void **cbdata)",
          "11824: {",
          "11825:  const struct mg_request_info *request_info = mg_get_request_info(conn);",
          "11826:  if (request_info) {",
          "11827:   const char *uri = request_info->local_uri;",
          "11828:   size_t urilen = strlen(uri);",
          "11829:   struct mg_handler_info *tmp_rh;",
          "11831:   if (!conn || !conn->ctx) {",
          "11832:    return 0;",
          "11833:   }",
          "11835:   mg_lock_context(conn->ctx);",
          "11838:   for (tmp_rh = conn->ctx->handlers; tmp_rh != NULL;",
          "11839:        tmp_rh = tmp_rh->next) {",
          "11840:    if (tmp_rh->handler_type == handler_type) {",
          "11841:     if ((urilen == tmp_rh->uri_len) && !strcmp(tmp_rh->uri, uri)) {",
          "11842:      if (handler_type == WEBSOCKET_HANDLER) {",
          "11848:      } else if (handler_type == REQUEST_HANDLER) {",
          "11854:      mg_unlock_context(conn->ctx);",
          "11855:      return 1;",
          "11858:   }",
          "11861:   for (tmp_rh = conn->ctx->handlers; tmp_rh != NULL;",
          "11862:        tmp_rh = tmp_rh->next) {",
          "11863:    if (tmp_rh->handler_type == handler_type) {",
          "11864:     if ((tmp_rh->uri_len < urilen) && (uri[tmp_rh->uri_len] == '/')",
          "11865:         && (memcmp(tmp_rh->uri, uri, tmp_rh->uri_len) == 0)) {",
          "11866:      if (handler_type == WEBSOCKET_HANDLER) {",
          "11872:      } else if (handler_type == REQUEST_HANDLER) {",
          "11878:      mg_unlock_context(conn->ctx);",
          "11879:      return 1;",
          "11882:   }",
          "11885:   for (tmp_rh = conn->ctx->handlers; tmp_rh != NULL;",
          "11886:        tmp_rh = tmp_rh->next) {",
          "11887:    if (tmp_rh->handler_type == handler_type) {",
          "11888:     if (match_prefix(tmp_rh->uri, tmp_rh->uri_len, uri) > 0) {",
          "11889:      if (handler_type == WEBSOCKET_HANDLER) {",
          "11895:      } else if (handler_type == REQUEST_HANDLER) {",
          "11901:      mg_unlock_context(conn->ctx);",
          "11902:      return 1;",
          "11905:   }",
          "11907:   mg_unlock_context(conn->ctx);",
          "11910: }",
          "11917: static int",
          "11918: is_in_script_path(const struct mg_connection *conn, const char *path)",
          "11919: {",
          "11922:  (void)conn;",
          "11923:  (void)path;",
          "11924:  return 1;",
          "11925: }",
          "11929: static int",
          "11930: deprecated_websocket_connect_wrapper(const struct mg_connection *conn,",
          "11931:                                      void *cbdata)",
          "11932: {",
          "11933:  struct mg_callbacks *pcallbacks = (struct mg_callbacks *)cbdata;",
          "11934:  if (pcallbacks->websocket_connect) {",
          "11935:   return pcallbacks->websocket_connect(conn);",
          "11938:  return 0;",
          "11939: }",
          "11942: static void",
          "11943: deprecated_websocket_ready_wrapper(struct mg_connection *conn, void *cbdata)",
          "11944: {",
          "11945:  struct mg_callbacks *pcallbacks = (struct mg_callbacks *)cbdata;",
          "11946:  if (pcallbacks->websocket_ready) {",
          "11947:   pcallbacks->websocket_ready(conn);",
          "11949: }",
          "11952: static int",
          "11953: deprecated_websocket_data_wrapper(struct mg_connection *conn,",
          "11954:                                   int bits,",
          "11955:                                   char *data,",
          "11956:                                   size_t len,",
          "11957:                                   void *cbdata)",
          "11958: {",
          "11959:  struct mg_callbacks *pcallbacks = (struct mg_callbacks *)cbdata;",
          "11960:  if (pcallbacks->websocket_data) {",
          "11961:   return pcallbacks->websocket_data(conn, bits, data, len);",
          "11964:  return 1;",
          "11965: }",
          "11973: static void",
          "11974: handle_request(struct mg_connection *conn)",
          "11975: {",
          "11976:  struct mg_request_info *ri = &conn->request_info;",
          "11977:  char path[PATH_MAX];",
          "11978:  int uri_len, ssl_index;",
          "11979:  int is_found = 0, is_script_resource = 0, is_websocket_request = 0,",
          "11980:      is_put_or_delete_request = 0, is_callback_resource = 0;",
          "11981:  int i;",
          "11982:  struct mg_file file = STRUCT_FILE_INITIALIZER;",
          "11983:  mg_request_handler callback_handler = NULL;",
          "11984:  struct mg_websocket_subprotocols *subprotocols;",
          "11985:  mg_websocket_connect_handler ws_connect_handler = NULL;",
          "11986:  mg_websocket_ready_handler ws_ready_handler = NULL;",
          "11987:  mg_websocket_data_handler ws_data_handler = NULL;",
          "11988:  mg_websocket_close_handler ws_close_handler = NULL;",
          "11989:  void *callback_data = NULL;",
          "11990:  mg_authorization_handler auth_handler = NULL;",
          "11991:  void *auth_callback_data = NULL;",
          "11992:  int handler_type;",
          "11993:  time_t curtime = time(NULL);",
          "11994:  char date[64];",
          "11996:  path[0] = 0;",
          "12000:  if ((conn->request_info.query_string = strchr(ri->request_uri, '?'))",
          "12001:      != NULL) {",
          "12003:  }",
          "12006:  if (!conn->client.is_ssl && conn->client.ssl_redir) {",
          "12007:   ssl_index = get_first_ssl_listener_index(conn->ctx);",
          "12008:   if (ssl_index >= 0) {",
          "12009:    redirect_to_https_port(conn, ssl_index);",
          "12010:   } else {",
          "12013:    mg_send_http_error(conn,",
          "12014:                       503,",
          "12015:                       \"%s\",",
          "12016:                       \"Error: SSL forward not configured properly\");",
          "12017:    mg_cry(conn, \"Can not redirect to SSL, no SSL port available\");",
          "12018:   }",
          "12019:   return;",
          "12020:  }",
          "12021:  uri_len = (int)strlen(ri->local_uri);",
          "12024:  if (should_decode_url(conn)) {",
          "12025:   mg_url_decode(",
          "12026:       ri->local_uri, uri_len, (char *)ri->local_uri, uri_len + 1, 0);",
          "12027:  }",
          "12031:  remove_double_dots_and_double_slashes((char *)ri->local_uri);",
          "12034:  uri_len = (int)strlen(ri->local_uri);",
          "12035:  DEBUG_TRACE(\"URL: %s\", ri->local_uri);",
          "12038:  conn->throttle = set_throttle(conn->ctx->config[THROTTLE],",
          "12039:                                get_remote_ip(conn),",
          "12040:                                ri->local_uri);",
          "12043:  if (conn->ctx->callbacks.begin_request != NULL) {",
          "12047:   i = conn->ctx->callbacks.begin_request(conn);",
          "12048:   if (i > 0) {",
          "12051:    conn->status_code = i;",
          "12052:    discard_unread_request_data(conn);",
          "12053:    return;",
          "12054:   } else if (i == 0) {",
          "12056:   } else {",
          "12060:  }",
          "12068:  if (!strcmp(ri->request_method, \"OPTIONS\")) {",
          "12072:   const char *cors_meth_cfg =",
          "12073:       conn->ctx->config[ACCESS_CONTROL_ALLOW_METHODS];",
          "12074:   const char *cors_orig_cfg =",
          "12075:       conn->ctx->config[ACCESS_CONTROL_ALLOW_ORIGIN];",
          "12076:   const char *cors_origin =",
          "12077:       get_header(ri->http_headers, ri->num_headers, \"Origin\");",
          "12078:   const char *cors_acrm = get_header(ri->http_headers,",
          "12079:                                      ri->num_headers,",
          "12080:                                      \"Access-Control-Request-Method\");",
          "12085:   if ((cors_meth_cfg != NULL) && (*cors_meth_cfg != 0)",
          "12086:       && (cors_orig_cfg != NULL) && (*cors_orig_cfg != 0)",
          "12087:       && (cors_origin != NULL) && (cors_acrm != NULL)) {",
          "12090:    const char *cors_acrh =",
          "12091:        get_header(ri->http_headers,",
          "12092:                   ri->num_headers,",
          "12093:                   \"Access-Control-Request-Headers\");",
          "12095:    gmt_time_string(date, sizeof(date), &curtime);",
          "12096:    mg_printf(conn,",
          "12097:              \"HTTP/1.1 200 OK\\r\\n\"",
          "12098:              \"Date: %s\\r\\n\"",
          "12099:              \"Access-Control-Allow-Origin: %s\\r\\n\"",
          "12100:              \"Access-Control-Allow-Methods: %s\\r\\n\"",
          "12101:              \"Content-Length: 0\\r\\n\"",
          "12102:              \"Connection: %s\\r\\n\",",
          "12103:              date,",
          "12104:              cors_orig_cfg,",
          "12105:              ((cors_meth_cfg[0] == '*') ? cors_acrm : cors_meth_cfg),",
          "12106:              suggest_connection_header(conn));",
          "12108:    if (cors_acrh != NULL) {",
          "12110:     const char *cors_hdr_cfg =",
          "12111:         conn->ctx->config[ACCESS_CONTROL_ALLOW_HEADERS];",
          "12113:     if ((cors_hdr_cfg != NULL) && (*cors_hdr_cfg != 0)) {",
          "12119:      mg_printf(conn,",
          "12120:                \"Access-Control-Allow-Headers: %s\\r\\n\",",
          "12121:                ((cors_hdr_cfg[0] == '*') ? cors_acrh",
          "12122:                                          : cors_hdr_cfg));",
          "12123:     }",
          "12125:    mg_printf(conn, \"Access-Control-Max-Age: 60\\r\\n\");",
          "12127:    mg_printf(conn, \"\\r\\n\");",
          "12128:    return;",
          "12130:  }",
          "12137:  is_websocket_request = is_websocket_protocol(conn);",
          "12139:  handler_type = is_websocket_request ? WEBSOCKET_HANDLER : REQUEST_HANDLER;",
          "12144:  if (get_request_handler(conn,",
          "12145:                          handler_type,",
          "12146:                          &callback_handler,",
          "12147:                          &subprotocols,",
          "12148:                          &ws_connect_handler,",
          "12149:                          &ws_ready_handler,",
          "12150:                          &ws_data_handler,",
          "12151:                          &ws_close_handler,",
          "12152:                          NULL,",
          "12153:                          &callback_data)) {",
          "12158:   is_callback_resource = 1;",
          "12159:   is_script_resource = 1;",
          "12160:   is_put_or_delete_request = is_put_or_delete_method(conn);",
          "12161:  } else {",
          "12162:  no_callback_resource:",
          "12166:   is_callback_resource = 0;",
          "12167:   interpret_uri(conn,",
          "12168:                 path,",
          "12169:                 sizeof(path),",
          "12170:                 &file.stat,",
          "12171:                 &is_found,",
          "12172:                 &is_script_resource,",
          "12173:                 &is_websocket_request,",
          "12174:                 &is_put_or_delete_request);",
          "12175:  }",
          "12179:  if (get_request_handler(conn,",
          "12180:                          AUTH_HANDLER,",
          "12181:                          NULL,",
          "12182:                          NULL,",
          "12183:                          NULL,",
          "12184:                          NULL,",
          "12185:                          NULL,",
          "12186:                          NULL,",
          "12187:                          &auth_handler,",
          "12188:                          &auth_callback_data)) {",
          "12189:   if (!auth_handler(conn, auth_callback_data)) {",
          "12190:    return;",
          "12191:   }",
          "12192:  } else if (is_put_or_delete_request && !is_script_resource",
          "12193:             && !is_callback_resource) {",
          "12197:   if (1) {",
          "12203:    mg_send_http_error(conn,",
          "12204:                       405,",
          "12205:                       \"%s method not allowed\",",
          "12206:                       conn->request_info.request_method);",
          "12207:    return;",
          "12208:   }",
          "12214:   if (!is_authorized_for_put(conn)) {",
          "12215:    send_authorization_request(conn);",
          "12216:    return;",
          "12217:   }",
          "12220:  } else {",
          "12224:   if (!check_authorization(conn, path)) {",
          "12225:    send_authorization_request(conn);",
          "12226:    return;",
          "12228:  }",
          "12233:  if (is_callback_resource) {",
          "12234:   if (!is_websocket_request) {",
          "12235:    i = callback_handler(conn, callback_data);",
          "12236:    if (i > 0) {",
          "12240:     conn->status_code = i;",
          "12241:     discard_unread_request_data(conn);",
          "12242:    } else {",
          "12259:     interpret_uri(conn,",
          "12260:                   path,",
          "12261:                   sizeof(path),",
          "12262:                   &file.stat,",
          "12263:                   &is_found,",
          "12264:                   &is_script_resource,",
          "12265:                   &is_websocket_request,",
          "12266:                   &is_put_or_delete_request);",
          "12267:     callback_handler = NULL;",
          "12278:     goto no_callback_resource;",
          "12279:    }",
          "12280:   } else {",
          "12282:    handle_websocket_request(conn,",
          "12283:                             path,",
          "12284:                             is_callback_resource,",
          "12285:                             subprotocols,",
          "12286:                             ws_connect_handler,",
          "12287:                             ws_ready_handler,",
          "12288:                             ws_data_handler,",
          "12289:                             ws_close_handler,",
          "12290:                             callback_data);",
          "12293:   return;",
          "12294:  }",
          "12298:  if (is_websocket_request) {",
          "12299:   if (is_script_resource) {",
          "12301:    if (is_in_script_path(conn, path)) {",
          "12303:     handle_websocket_request(conn,",
          "12304:                              path,",
          "12305:                              0 /* Lua Script */,",
          "12306:                              NULL,",
          "12307:                              NULL,",
          "12308:                              NULL,",
          "12309:                              NULL,",
          "12310:                              NULL,",
          "12311:                              &conn->ctx->callbacks);",
          "12314:     mg_send_http_error(conn, 403, \"%s\", \"Forbidden\");",
          "12315:    }",
          "12316:   } else {",
          "12318:    handle_websocket_request(",
          "12319:        conn,",
          "12320:        path,",
          "12321:        !is_script_resource /* could be deprecated global callback */,",
          "12322:        NULL,",
          "12323:        deprecated_websocket_connect_wrapper,",
          "12324:        deprecated_websocket_ready_wrapper,",
          "12325:        deprecated_websocket_data_wrapper,",
          "12326:        NULL,",
          "12327:        &conn->ctx->callbacks);",
          "12331:   }",
          "12332:   return;",
          "12333:  } else",
          "12340:   mg_send_http_error(conn, 404, \"%s\", \"Not Found\");",
          "",
          "[Added Lines]",
          "11440:  struct mg_upload_user_data {",
          "11441:   struct mg_connection *conn;",
          "11442:   const char *destination_dir;",
          "11443:   int num_uploaded_files;",
          "11444:  };",
          "11448:  static int mg_upload_field_found(const char *key,",
          "11449:                                   const char *filename,",
          "11450:                                   char *path,",
          "11451:                                   size_t pathlen,",
          "11452:                                   void *user_data)",
          "11453:  {",
          "11454:   int truncated = 0;",
          "11455:   struct mg_upload_user_data *fud =",
          "11456:       (struct mg_upload_user_data *)user_data;",
          "11457:   (void)key;",
          "11459:   if (!filename) {",
          "11460:    mg_cry(fud->conn, \"%s: No filename set\", __func__);",
          "11461:    return FORM_FIELD_STORAGE_ABORT;",
          "11462:   }",
          "11463:   mg_snprintf(fud->conn,",
          "11464:               &truncated,",
          "11465:               path,",
          "11466:               pathlen - 1,",
          "11467:               \"%s/%s\",",
          "11468:               fud->destination_dir,",
          "11469:               filename);",
          "11470:   if (!truncated) {",
          "11471:    mg_cry(fud->conn, \"%s: File path too long\", __func__);",
          "11472:    return FORM_FIELD_STORAGE_ABORT;",
          "11473:   }",
          "11474:   return FORM_FIELD_STORAGE_STORE;",
          "11475:  }",
          "11479:  static int mg_upload_field_get(const char *key,",
          "11480:                                 const char *value,",
          "11481:                                 size_t value_size,",
          "11482:                                 void *user_data)",
          "11483:  {",
          "11485:   (void)key;",
          "11486:   (void)value;",
          "11487:   (void)value_size;",
          "11488:   (void)user_data;",
          "11490:   return 0;",
          "11491:  }",
          "11495:  static int mg_upload_field_stored(const char *path,",
          "11496:                                    long long file_size,",
          "11497:                                    void *user_data)",
          "11498:  {",
          "11499:   struct mg_upload_user_data *fud =",
          "11500:       (struct mg_upload_user_data *)user_data;",
          "11501:   (void)file_size;",
          "11503:   fud->num_uploaded_files++;",
          "11504:   fud->conn->ctx->callbacks.upload(fud->conn, path);",
          "11506:   return 0;",
          "11507:  }",
          "11511:  int mg_upload(struct mg_connection * conn, const char *destination_dir)",
          "11512:  {",
          "11513:   struct mg_upload_user_data fud = {conn, destination_dir, 0};",
          "11514:   struct mg_form_data_handler fdh = {mg_upload_field_found,",
          "11515:                                      mg_upload_field_get,",
          "11516:                                      mg_upload_field_stored,",
          "11517:                                      0};",
          "11518:   int ret;",
          "11520:   fdh.user_data = (void *)&fud;",
          "11521:   ret = mg_handle_form_request(conn, &fdh);",
          "11523:   if (ret < 0) {",
          "11524:    mg_cry(conn, \"%s: Error while parsing the request\", __func__);",
          "11525:   }",
          "11527:   return fud.num_uploaded_files;",
          "11532:  static int get_first_ssl_listener_index(const struct mg_context *ctx)",
          "11533:  {",
          "11534:   unsigned int i;",
          "11535:   int idx = -1;",
          "11536:   if (ctx) {",
          "11537:    for (i = 0; ((idx == -1) && (i < ctx->num_listening_sockets));",
          "11538:         i++) {",
          "11539:     idx = ctx->listening_sockets[i].is_ssl ? ((int)(i)) : -1;",
          "11540:    }",
          "11542:   return idx;",
          "11546:  static void redirect_to_https_port(struct mg_connection * conn,",
          "11547:                                     int ssl_index)",
          "11548:  {",
          "11549:   char host[1025];",
          "11550:   const char *host_header;",
          "11551:   size_t hostlen;",
          "11553:   host_header = mg_get_header(conn, \"Host\");",
          "11554:   hostlen = sizeof(host);",
          "11555:   if (host_header != NULL) {",
          "11556:    char *pos;",
          "11558:    mg_strlcpy(host, host_header, hostlen);",
          "11559:    host[hostlen - 1] = '\\0';",
          "11560:    pos = strchr(host, ':');",
          "11561:    if (pos != NULL) {",
          "11563:    }",
          "11564:   } else {",
          "11567:    if (conn) {",
          "11568:     sockaddr_to_string(host, hostlen, &conn->client.lsa);",
          "11569:    }",
          "11573:   if (conn) {",
          "11574:    mg_printf(",
          "11575:        conn,",
          "11576:        \"HTTP/1.1 302 Found\\r\\nLocation: https://%s:%d%s%s%s\\r\\n\\r\\n\",",
          "11577:        host,",
          "11579:        (conn->ctx->listening_sockets[ssl_index].lsa.sa.sa_family",
          "11580:         == AF_INET6)",
          "11581:            ? (int)ntohs(conn->ctx->listening_sockets[ssl_index]",
          "11582:                             .lsa.sin6.sin6_port)",
          "11583:            :",
          "11584: #endif",
          "11585:            (int)ntohs(conn->ctx->listening_sockets[ssl_index]",
          "11586:                           .lsa.sin.sin_port),",
          "11587:        conn->request_info.local_uri,",
          "11588:        (conn->request_info.query_string == NULL) ? \"\" : \"?\",",
          "11589:        (conn->request_info.query_string == NULL)",
          "11590:            ? \"\"",
          "11591:            : conn->request_info.query_string);",
          "11592:   }",
          "11593:  }",
          "11596:  static void mg_set_handler_type(",
          "11597:      struct mg_context * ctx,",
          "11598:      const char *uri,",
          "11599:      int handler_type,",
          "11600:      int is_delete_request,",
          "11601:      mg_request_handler handler,",
          "11602:      struct mg_websocket_subprotocols *subprotocols,",
          "11603:      mg_websocket_connect_handler connect_handler,",
          "11604:      mg_websocket_ready_handler ready_handler,",
          "11605:      mg_websocket_data_handler data_handler,",
          "11606:      mg_websocket_close_handler close_handler,",
          "11607:      mg_authorization_handler auth_handler,",
          "11608:      void *cbdata)",
          "11609:  {",
          "11610:   struct mg_handler_info *tmp_rh, **lastref;",
          "11611:   size_t urilen = strlen(uri);",
          "11613:   if (handler_type == WEBSOCKET_HANDLER) {",
          "11620:    if (handler != NULL) {",
          "11623:    if (!is_delete_request && (connect_handler == NULL)",
          "11624:        && (ready_handler == NULL) && (data_handler == NULL)",
          "11625:        && (close_handler == NULL)) {",
          "11626:     return;",
          "11627:    }",
          "11628:    if (auth_handler != NULL) {",
          "11629:     return;",
          "11630:    }",
          "11631:   } else if (handler_type == REQUEST_HANDLER) {",
          "11637:    if ((connect_handler != NULL) || (ready_handler != NULL)",
          "11638:        || (data_handler != NULL) || (close_handler != NULL)) {",
          "11639:     return;",
          "11640:    }",
          "11641:    if (!is_delete_request && (handler == NULL)) {",
          "11642:     return;",
          "11643:    }",
          "11644:    if (auth_handler != NULL) {",
          "11645:     return;",
          "11646:    }",
          "11652:    if (handler != NULL) {",
          "11653:     return;",
          "11654:    }",
          "11655:    if ((connect_handler != NULL) || (ready_handler != NULL)",
          "11656:        || (data_handler != NULL) || (close_handler != NULL)) {",
          "11657:     return;",
          "11658:    }",
          "11659:    if (!is_delete_request && (auth_handler == NULL)) {",
          "11660:     return;",
          "11661:    }",
          "11662:   }",
          "11664:   if (!ctx) {",
          "11665:    return;",
          "11666:   }",
          "11668:   mg_lock_context(ctx);",
          "11671:   lastref = &(ctx->handlers);",
          "11672:   for (tmp_rh = ctx->handlers; tmp_rh != NULL; tmp_rh = tmp_rh->next) {",
          "11673:    if (tmp_rh->handler_type == handler_type) {",
          "11674:     if ((urilen == tmp_rh->uri_len) && !strcmp(tmp_rh->uri, uri)) {",
          "11675:      if (!is_delete_request) {",
          "11677:       if (handler_type == REQUEST_HANDLER) {",
          "11678:        tmp_rh->handler = handler;",
          "11679:       } else if (handler_type == WEBSOCKET_HANDLER) {",
          "11680:        tmp_rh->subprotocols = subprotocols;",
          "11681:        tmp_rh->connect_handler = connect_handler;",
          "11682:        tmp_rh->ready_handler = ready_handler;",
          "11683:        tmp_rh->data_handler = data_handler;",
          "11684:        tmp_rh->close_handler = close_handler;",
          "11686:        tmp_rh->auth_handler = auth_handler;",
          "11687:       }",
          "11688:       tmp_rh->cbdata = cbdata;",
          "11689:      } else {",
          "11692:       mg_free(tmp_rh->uri);",
          "11693:       mg_free(tmp_rh);",
          "11694:      }",
          "11695:      mg_unlock_context(ctx);",
          "11696:      return;",
          "11697:     }",
          "11698:    }",
          "11699:    lastref = &(tmp_rh->next);",
          "11700:   }",
          "11702:   if (is_delete_request) {",
          "11705:    mg_unlock_context(ctx);",
          "11706:    return;",
          "11707:   }",
          "11709:   tmp_rh = (struct mg_handler_info *)",
          "11710:       mg_calloc_ctx(sizeof(struct mg_handler_info), 1, ctx);",
          "11711:   if (tmp_rh == NULL) {",
          "11712:    mg_unlock_context(ctx);",
          "11713:    mg_cry(fc(ctx),",
          "11714:           \"%s\",",
          "11715:           \"Cannot create new request handler struct, OOM\");",
          "11716:    return;",
          "11717:   }",
          "11718:   tmp_rh->uri = mg_strdup(uri);",
          "11719:   if (!tmp_rh->uri) {",
          "11720:    mg_unlock_context(ctx);",
          "11721:    mg_free(tmp_rh);",
          "11722:    mg_cry(fc(ctx),",
          "11723:           \"%s\",",
          "11724:           \"Cannot create new request handler struct, OOM\");",
          "11725:    return;",
          "11726:   }",
          "11727:   tmp_rh->uri_len = urilen;",
          "11728:   if (handler_type == REQUEST_HANDLER) {",
          "11729:    tmp_rh->handler = handler;",
          "11730:   } else if (handler_type == WEBSOCKET_HANDLER) {",
          "11731:    tmp_rh->subprotocols = subprotocols;",
          "11732:    tmp_rh->connect_handler = connect_handler;",
          "11733:    tmp_rh->ready_handler = ready_handler;",
          "11734:    tmp_rh->data_handler = data_handler;",
          "11735:    tmp_rh->close_handler = close_handler;",
          "11737:    tmp_rh->auth_handler = auth_handler;",
          "11738:   }",
          "11739:   tmp_rh->cbdata = cbdata;",
          "11740:   tmp_rh->handler_type = handler_type;",
          "11741:   tmp_rh->next = NULL;",
          "11744:   mg_unlock_context(ctx);",
          "11745:  }",
          "11748:  void mg_set_request_handler(struct mg_context * ctx,",
          "11749:                              const char *uri,",
          "11750:                              mg_request_handler handler,",
          "11751:                              void *cbdata)",
          "11752:  {",
          "11753:   mg_set_handler_type(ctx,",
          "11754:                       uri,",
          "11755:                       REQUEST_HANDLER,",
          "11756:                       handler == NULL,",
          "11757:                       handler,",
          "11758:                       NULL,",
          "11759:                       NULL,",
          "11760:                       NULL,",
          "11761:                       NULL,",
          "11762:                       NULL,",
          "11763:                       NULL,",
          "11764:                       cbdata);",
          "11765:  }",
          "11768:  void mg_set_websocket_handler(struct mg_context * ctx,",
          "11769:                                const char *uri,",
          "11770:                                mg_websocket_connect_handler connect_handler,",
          "11771:                                mg_websocket_ready_handler ready_handler,",
          "11772:                                mg_websocket_data_handler data_handler,",
          "11773:                                mg_websocket_close_handler close_handler,",
          "11774:                                void *cbdata)",
          "11775:  {",
          "11776:   mg_set_websocket_handler_with_subprotocols(ctx,",
          "11777:                                              uri,",
          "11778:                                              NULL,",
          "11779:                                              connect_handler,",
          "11780:                                              ready_handler,",
          "11781:                                              data_handler,",
          "11782:                                              close_handler,",
          "11783:                                              cbdata);",
          "11784:  }",
          "11787:  void mg_set_websocket_handler_with_subprotocols(",
          "11788:      struct mg_context * ctx,",
          "11789:      const char *uri,",
          "11790:      struct mg_websocket_subprotocols *subprotocols,",
          "11791:      mg_websocket_connect_handler connect_handler,",
          "11792:      mg_websocket_ready_handler ready_handler,",
          "11793:      mg_websocket_data_handler data_handler,",
          "11794:      mg_websocket_close_handler close_handler,",
          "11795:      void *cbdata)",
          "11796:  {",
          "11797:   int is_delete_request =",
          "11798:       (connect_handler == NULL) && (ready_handler == NULL)",
          "11799:       && (data_handler == NULL) && (close_handler == NULL);",
          "11800:   mg_set_handler_type(ctx,",
          "11801:                       uri,",
          "11802:                       WEBSOCKET_HANDLER,",
          "11803:                       is_delete_request,",
          "11804:                       NULL,",
          "11805:                       subprotocols,",
          "11806:                       connect_handler,",
          "11807:                       ready_handler,",
          "11808:                       data_handler,",
          "11809:                       close_handler,",
          "11810:                       NULL,",
          "11811:                       cbdata);",
          "11812:  }",
          "11815:  void mg_set_auth_handler(struct mg_context * ctx,",
          "11816:                           const char *uri,",
          "11817:                           mg_request_handler handler,",
          "11818:                           void *cbdata)",
          "11819:  {",
          "11820:   mg_set_handler_type(ctx,",
          "11821:                       uri,",
          "11822:                       AUTH_HANDLER,",
          "11823:                       handler == NULL,",
          "11824:                       NULL,",
          "11825:                       NULL,",
          "11826:                       NULL,",
          "11827:                       NULL,",
          "11828:                       NULL,",
          "11829:                       NULL,",
          "11830:                       handler,",
          "11831:                       cbdata);",
          "11832:  }",
          "11835:  static int get_request_handler(",
          "11836:      struct mg_connection * conn,",
          "11837:      int handler_type,",
          "11838:      mg_request_handler *handler,",
          "11839:      struct mg_websocket_subprotocols **subprotocols,",
          "11840:      mg_websocket_connect_handler *connect_handler,",
          "11841:      mg_websocket_ready_handler *ready_handler,",
          "11842:      mg_websocket_data_handler *data_handler,",
          "11843:      mg_websocket_close_handler *close_handler,",
          "11844:      mg_authorization_handler *auth_handler,",
          "11845:      void **cbdata)",
          "11846:  {",
          "11847:   const struct mg_request_info *request_info = mg_get_request_info(conn);",
          "11848:   if (request_info) {",
          "11849:    const char *uri = request_info->local_uri;",
          "11850:    size_t urilen = strlen(uri);",
          "11851:    struct mg_handler_info *tmp_rh;",
          "11853:    if (!conn || !conn->ctx) {",
          "11854:     return 0;",
          "11855:    }",
          "11857:    mg_lock_context(conn->ctx);",
          "11860:    for (tmp_rh = conn->ctx->handlers; tmp_rh != NULL;",
          "11861:         tmp_rh = tmp_rh->next) {",
          "11862:     if (tmp_rh->handler_type == handler_type) {",
          "11863:      if ((urilen == tmp_rh->uri_len)",
          "11864:          && !strcmp(tmp_rh->uri, uri)) {",
          "11865:       if (handler_type == WEBSOCKET_HANDLER) {",
          "11871:       } else if (handler_type == REQUEST_HANDLER) {",
          "11875:       }",
          "11877:       mg_unlock_context(conn->ctx);",
          "11878:       return 1;",
          "11884:    for (tmp_rh = conn->ctx->handlers; tmp_rh != NULL;",
          "11885:         tmp_rh = tmp_rh->next) {",
          "11886:     if (tmp_rh->handler_type == handler_type) {",
          "11887:      if ((tmp_rh->uri_len < urilen)",
          "11888:          && (uri[tmp_rh->uri_len] == '/')",
          "11889:          && (memcmp(tmp_rh->uri, uri, tmp_rh->uri_len) == 0)) {",
          "11890:       if (handler_type == WEBSOCKET_HANDLER) {",
          "11896:       } else if (handler_type == REQUEST_HANDLER) {",
          "11900:       }",
          "11902:       mg_unlock_context(conn->ctx);",
          "11903:       return 1;",
          "11909:    for (tmp_rh = conn->ctx->handlers; tmp_rh != NULL;",
          "11910:         tmp_rh = tmp_rh->next) {",
          "11911:     if (tmp_rh->handler_type == handler_type) {",
          "11912:      if (match_prefix(tmp_rh->uri, tmp_rh->uri_len, uri) > 0) {",
          "11913:       if (handler_type == WEBSOCKET_HANDLER) {",
          "11919:       } else if (handler_type == REQUEST_HANDLER) {",
          "11923:       }",
          "11925:       mg_unlock_context(conn->ctx);",
          "11926:       return 1;",
          "11931:    mg_unlock_context(conn->ctx);",
          "11932:   }",
          "11941:  static int is_in_script_path(const struct mg_connection *conn,",
          "11942:                               const char *path)",
          "11943:  {",
          "11946:   (void)conn;",
          "11947:   (void)path;",
          "11948:   return 1;",
          "11949:  }",
          "11953:  static int deprecated_websocket_connect_wrapper(",
          "11954:      const struct mg_connection *conn, void *cbdata)",
          "11955:  {",
          "11956:   struct mg_callbacks *pcallbacks = (struct mg_callbacks *)cbdata;",
          "11957:   if (pcallbacks->websocket_connect) {",
          "11958:    return pcallbacks->websocket_connect(conn);",
          "11959:   }",
          "11961:   return 0;",
          "11965:  static void deprecated_websocket_ready_wrapper(struct mg_connection * conn,",
          "11966:                                                 void *cbdata)",
          "11967:  {",
          "11968:   struct mg_callbacks *pcallbacks = (struct mg_callbacks *)cbdata;",
          "11969:   if (pcallbacks->websocket_ready) {",
          "11970:    pcallbacks->websocket_ready(conn);",
          "11971:   }",
          "11975:  static int deprecated_websocket_data_wrapper(struct mg_connection * conn,",
          "11976:                                               int bits,",
          "11977:                                               char *data,",
          "11978:                                               size_t len,",
          "11979:                                               void *cbdata)",
          "11980:  {",
          "11981:   struct mg_callbacks *pcallbacks = (struct mg_callbacks *)cbdata;",
          "11982:   if (pcallbacks->websocket_data) {",
          "11983:    return pcallbacks->websocket_data(conn, bits, data, len);",
          "11984:   }",
          "11986:   return 1;",
          "11995:  static void handle_request(struct mg_connection * conn)",
          "11996:  {",
          "11997:   struct mg_request_info *ri = &conn->request_info;",
          "11998:   char path[PATH_MAX];",
          "11999:   int uri_len, ssl_index;",
          "12000:   int is_found = 0, is_script_resource = 0, is_websocket_request = 0,",
          "12001:       is_put_or_delete_request = 0, is_callback_resource = 0;",
          "12002:   int i;",
          "12003:   struct mg_file file = STRUCT_FILE_INITIALIZER;",
          "12004:   mg_request_handler callback_handler = NULL;",
          "12005:   struct mg_websocket_subprotocols *subprotocols;",
          "12006:   mg_websocket_connect_handler ws_connect_handler = NULL;",
          "12007:   mg_websocket_ready_handler ws_ready_handler = NULL;",
          "12008:   mg_websocket_data_handler ws_data_handler = NULL;",
          "12009:   mg_websocket_close_handler ws_close_handler = NULL;",
          "12010:   void *callback_data = NULL;",
          "12011:   mg_authorization_handler auth_handler = NULL;",
          "12012:   void *auth_callback_data = NULL;",
          "12013:   int handler_type;",
          "12014:   time_t curtime = time(NULL);",
          "12015:   char date[64];",
          "12017:   path[0] = 0;",
          "12021:   if ((conn->request_info.query_string = strchr(ri->request_uri, '?'))",
          "12022:       != NULL) {",
          "12024:   }",
          "12027:   if (!conn->client.is_ssl && conn->client.ssl_redir) {",
          "12028:    ssl_index = get_first_ssl_listener_index(conn->ctx);",
          "12029:    if (ssl_index >= 0) {",
          "12030:     redirect_to_https_port(conn, ssl_index);",
          "12031:    } else {",
          "12034:     mg_send_http_error(",
          "12035:         conn,",
          "12036:         503,",
          "12037:         \"%s\",",
          "12038:         \"Error: SSL forward not configured properly\");",
          "12039:     mg_cry(conn, \"Can not redirect to SSL, no SSL port available\");",
          "12040:    }",
          "12043:   uri_len = (int)strlen(ri->local_uri);",
          "12046:   if (should_decode_url(conn)) {",
          "12047:    mg_url_decode(",
          "12048:        ri->local_uri, uri_len, (char *)ri->local_uri, uri_len + 1, 0);",
          "12049:   }",
          "12053:   remove_double_dots_and_double_slashes((char *)ri->local_uri);",
          "12056:   uri_len = (int)strlen(ri->local_uri);",
          "12057:   DEBUG_TRACE(\"URL: %s\", ri->local_uri);",
          "12060:   conn->throttle = set_throttle(conn->ctx->config[THROTTLE],",
          "12061:                                 get_remote_ip(conn),",
          "12062:                                 ri->local_uri);",
          "12065:   if (conn->ctx->callbacks.begin_request != NULL) {",
          "12069:    i = conn->ctx->callbacks.begin_request(conn);",
          "12070:    if (i > 0) {",
          "12073:     conn->status_code = i;",
          "12074:     discard_unread_request_data(conn);",
          "12075:     return;",
          "12076:    } else if (i == 0) {",
          "12078:    } else {",
          "12080:     return;",
          "12082:   }",
          "12090:   if (!strcmp(ri->request_method, \"OPTIONS\")) {",
          "12094:    const char *cors_meth_cfg =",
          "12095:        conn->ctx->config[ACCESS_CONTROL_ALLOW_METHODS];",
          "12096:    const char *cors_orig_cfg =",
          "12097:        conn->ctx->config[ACCESS_CONTROL_ALLOW_ORIGIN];",
          "12098:    const char *cors_origin =",
          "12099:        get_header(ri->http_headers, ri->num_headers, \"Origin\");",
          "12100:    const char *cors_acrm = get_header(ri->http_headers,",
          "12101:                                       ri->num_headers,",
          "12102:                                       \"Access-Control-Request-Method\");",
          "12107:    if ((cors_meth_cfg != NULL) && (*cors_meth_cfg != 0)",
          "12108:        && (cors_orig_cfg != NULL) && (*cors_orig_cfg != 0)",
          "12109:        && (cors_origin != NULL) && (cors_acrm != NULL)) {",
          "12113:     const char *cors_acrh =",
          "12114:         get_header(ri->http_headers,",
          "12115:                    ri->num_headers,",
          "12116:                    \"Access-Control-Request-Headers\");",
          "12118:     gmt_time_string(date, sizeof(date), &curtime);",
          "12119:     mg_printf(conn,",
          "12120:               \"HTTP/1.1 200 OK\\r\\n\"",
          "12121:               \"Date: %s\\r\\n\"",
          "12122:               \"Access-Control-Allow-Origin: %s\\r\\n\"",
          "12123:               \"Access-Control-Allow-Methods: %s\\r\\n\"",
          "12124:               \"Content-Length: 0\\r\\n\"",
          "12125:               \"Connection: %s\\r\\n\",",
          "12126:               date,",
          "12127:               cors_orig_cfg,",
          "12128:               ((cors_meth_cfg[0] == '*') ? cors_acrm",
          "12129:                                          : cors_meth_cfg),",
          "12130:               suggest_connection_header(conn));",
          "12132:     if (cors_acrh != NULL) {",
          "12134:      const char *cors_hdr_cfg =",
          "12135:          conn->ctx->config[ACCESS_CONTROL_ALLOW_HEADERS];",
          "12137:      if ((cors_hdr_cfg != NULL) && (*cors_hdr_cfg != 0)) {",
          "12143:       mg_printf(conn,",
          "12144:                 \"Access-Control-Allow-Headers: %s\\r\\n\",",
          "12145:                 ((cors_hdr_cfg[0] == '*') ? cors_acrh",
          "12146:                                           : cors_hdr_cfg));",
          "12147:      }",
          "12148:     }",
          "12149:     mg_printf(conn, \"Access-Control-Max-Age: 60\\r\\n\");",
          "12151:     mg_printf(conn, \"\\r\\n\");",
          "12152:     return;",
          "12153:    }",
          "12161:   is_websocket_request = is_websocket_protocol(conn);",
          "12163:   handler_type =",
          "12164:       is_websocket_request ? WEBSOCKET_HANDLER : REQUEST_HANDLER;",
          "12169:   if (get_request_handler(conn,",
          "12170:                           handler_type,",
          "12171:                           &callback_handler,",
          "12172:                           &subprotocols,",
          "12173:                           &ws_connect_handler,",
          "12174:                           &ws_ready_handler,",
          "12175:                           &ws_data_handler,",
          "12176:                           &ws_close_handler,",
          "12177:                           NULL,",
          "12178:                           &callback_data)) {",
          "12183:    is_callback_resource = 1;",
          "12184:    is_script_resource = 1;",
          "12185:    is_put_or_delete_request = is_put_or_delete_method(conn);",
          "12186:   } else {",
          "12187:   no_callback_resource:",
          "12191:    is_callback_resource = 0;",
          "12192:    interpret_uri(conn,",
          "12193:                  path,",
          "12194:                  sizeof(path),",
          "12195:                  &file.stat,",
          "12196:                  &is_found,",
          "12197:                  &is_script_resource,",
          "12198:                  &is_websocket_request,",
          "12199:                  &is_put_or_delete_request);",
          "12200:   }",
          "12204:   if (get_request_handler(conn,",
          "12205:                           AUTH_HANDLER,",
          "12206:                           NULL,",
          "12207:                           NULL,",
          "12208:                           NULL,",
          "12209:                           NULL,",
          "12210:                           NULL,",
          "12211:                           NULL,",
          "12212:                           &auth_handler,",
          "12213:                           &auth_callback_data)) {",
          "12214:    if (!auth_handler(conn, auth_callback_data)) {",
          "12215:     return;",
          "12216:    }",
          "12217:   } else if (is_put_or_delete_request && !is_script_resource",
          "12218:              && !is_callback_resource) {",
          "12222:    if (1) {",
          "12228:     mg_send_http_error(conn,",
          "12229:                        405,",
          "12230:                        \"%s method not allowed\",",
          "12231:                        conn->request_info.request_method);",
          "12232:     return;",
          "12233:    }",
          "12239:    if (!is_authorized_for_put(conn)) {",
          "12240:     send_authorization_request(conn);",
          "12241:     return;",
          "12242:    }",
          "12245:   } else {",
          "12249:    if (!check_authorization(conn, path)) {",
          "12250:     send_authorization_request(conn);",
          "12251:     return;",
          "12252:    }",
          "12258:   if (is_callback_resource) {",
          "12259:    if (!is_websocket_request) {",
          "12260:     i = callback_handler(conn, callback_data);",
          "12261:     if (i > 0) {",
          "12265:      conn->status_code = i;",
          "12266:      discard_unread_request_data(conn);",
          "12267:     } else {",
          "12285:      interpret_uri(conn,",
          "12286:                    path,",
          "12287:                    sizeof(path),",
          "12288:                    &file.stat,",
          "12289:                    &is_found,",
          "12290:                    &is_script_resource,",
          "12291:                    &is_websocket_request,",
          "12292:                    &is_put_or_delete_request);",
          "12293:      callback_handler = NULL;",
          "12304:      goto no_callback_resource;",
          "12305:     }",
          "12306:    } else {",
          "12308:     handle_websocket_request(conn,",
          "12309:                              path,",
          "12310:                              is_callback_resource,",
          "12311:                              subprotocols,",
          "12312:                              ws_connect_handler,",
          "12313:                              ws_ready_handler,",
          "12314:                              ws_data_handler,",
          "12315:                              ws_close_handler,",
          "12316:                              callback_data);",
          "12318:    }",
          "12319:    return;",
          "12324:   if (is_websocket_request) {",
          "12325:    if (is_script_resource) {",
          "12327:     if (is_in_script_path(conn, path)) {",
          "12329:      handle_websocket_request(conn,",
          "12330:                               path,",
          "12331:                               0 /* Lua Script */,",
          "12332:                               NULL,",
          "12333:                               NULL,",
          "12334:                               NULL,",
          "12335:                               NULL,",
          "12336:                               NULL,",
          "12337:                               &conn->ctx->callbacks);",
          "12338:     } else {",
          "12340:      mg_send_http_error(conn, 403, \"%s\", \"Forbidden\");",
          "12341:     }",
          "12344:     handle_websocket_request(",
          "12345:         conn,",
          "12346:         path,",
          "12347:         !is_script_resource /* could be deprecated global callback */,",
          "12348:         NULL,",
          "12349:         deprecated_websocket_connect_wrapper,",
          "12350:         deprecated_websocket_ready_wrapper,",
          "12351:         deprecated_websocket_data_wrapper,",
          "12352:         NULL,",
          "12353:         &conn->ctx->callbacks);",
          "12357:    }",
          "12358:    return;",
          "12359:   } else",
          "12366:    mg_send_http_error(conn, 404, \"%s\", \"Not Found\");",
          "",
          "---------------",
          "--- Hunk 50 ---",
          "[Context before]",
          "12460: #endif",
          "12474: #ifdef USE_LUA",
          "12501: #endif",
          "12502: #if defined(USE_DUKTAPE)",
          "12514: #endif",
          "12515: #if !defined(NO_CGI)",
          "12536: #if !defined(NO_CACHING)",
          "12554:  }",
          "12587: #if defined(USE_IPV6)",
          "12611: #if defined(USE_IPV6)",
          "12620: #endif",
          "12629: #if defined(USE_IPV6)",
          "12634: #else",
          "12636:   so->lsa.sin.sin_port = htons((uint16_t)port);",
          "12638: #endif",
          "12664: #if defined(USE_IPV6)",
          "12678: #endif",
          "12679:   }",
          "12689:   return 0;",
          "12690:  }",
          "12712: #if defined(USE_IPV6)",
          "12714: #endif",
          "12749: #if !defined(NO_SSL)",
          "12758: #endif",
          "12767: #ifdef _WIN32",
          "12788: #else",
          "12789:   if (setsockopt(so.sock,",
          "12790:                  SOL_SOCKET,",
          "",
          "[Removed Lines]",
          "12461: }",
          "12464: static void",
          "12465: handle_file_based_request(struct mg_connection *conn,",
          "12466:                           const char *path,",
          "12467:                           struct mg_file *file)",
          "12468: {",
          "12469:  if (!conn || !conn->ctx) {",
          "12470:   return;",
          "12471:  }",
          "12473:  if (0) {",
          "12475:  } else if (match_prefix(conn->ctx->config[LUA_SERVER_PAGE_EXTENSIONS],",
          "12476:                          strlen(",
          "12477:                              conn->ctx->config[LUA_SERVER_PAGE_EXTENSIONS]),",
          "12478:                          path) > 0) {",
          "12479:   if (is_in_script_path(conn, path)) {",
          "12483:    handle_lsp_request(conn, path, file, NULL);",
          "12484:   } else {",
          "12486:    mg_send_http_error(conn, 403, \"%s\", \"Forbidden\");",
          "12487:   }",
          "12489:  } else if (match_prefix(conn->ctx->config[LUA_SCRIPT_EXTENSIONS],",
          "12490:                          strlen(conn->ctx->config[LUA_SCRIPT_EXTENSIONS]),",
          "12491:                          path) > 0) {",
          "12492:   if (is_in_script_path(conn, path)) {",
          "12496:    mg_exec_lua_script(conn, path, NULL);",
          "12497:   } else {",
          "12499:    mg_send_http_error(conn, 403, \"%s\", \"Forbidden\");",
          "12500:   }",
          "12503:  } else if (match_prefix(conn->ctx->config[DUKTAPE_SCRIPT_EXTENSIONS],",
          "12504:                          strlen(",
          "12505:                              conn->ctx->config[DUKTAPE_SCRIPT_EXTENSIONS]),",
          "12506:                          path) > 0) {",
          "12507:   if (is_in_script_path(conn, path)) {",
          "12509:    mg_exec_duktape_script(conn, path);",
          "12510:   } else {",
          "12512:    mg_send_http_error(conn, 403, \"%s\", \"Forbidden\");",
          "12513:   }",
          "12516:  } else if (match_prefix(conn->ctx->config[CGI_EXTENSIONS],",
          "12517:                          strlen(conn->ctx->config[CGI_EXTENSIONS]),",
          "12518:                          path) > 0) {",
          "12519:   if (is_in_script_path(conn, path)) {",
          "12521:    handle_cgi_request(conn, path);",
          "12522:   } else {",
          "12524:    mg_send_http_error(conn, 403, \"%s\", \"Forbidden\");",
          "12525:   }",
          "12527:  } else if (match_prefix(conn->ctx->config[SSI_EXTENSIONS],",
          "12528:                          strlen(conn->ctx->config[SSI_EXTENSIONS]),",
          "12529:                          path) > 0) {",
          "12530:   if (is_in_script_path(conn, path)) {",
          "12531:    handle_ssi_file_request(conn, path, file);",
          "12532:   } else {",
          "12534:    mg_send_http_error(conn, 403, \"%s\", \"Forbidden\");",
          "12535:   }",
          "12537:  } else if ((!conn->in_error_handler)",
          "12538:             && is_not_modified(conn, &file->stat)) {",
          "12540:   handle_not_modified_static_file_request(conn, file);",
          "12542:  } else {",
          "12543:   handle_static_file_request(conn, path, file, NULL, NULL);",
          "12544:  }",
          "12545: }",
          "12548: static void",
          "12549: close_all_listening_sockets(struct mg_context *ctx)",
          "12550: {",
          "12551:  unsigned int i;",
          "12552:  if (!ctx) {",
          "12553:   return;",
          "12556:  for (i = 0; i < ctx->num_listening_sockets; i++) {",
          "12557:   closesocket(ctx->listening_sockets[i].sock);",
          "12558:   ctx->listening_sockets[i].sock = INVALID_SOCKET;",
          "12559:  }",
          "12560:  mg_free(ctx->listening_sockets);",
          "12561:  ctx->listening_sockets = NULL;",
          "12562:  mg_free(ctx->listening_socket_fds);",
          "12563:  ctx->listening_socket_fds = NULL;",
          "12564: }",
          "12581: static int",
          "12582: parse_port_string(const struct vec *vec, struct socket *so, int *ip_version)",
          "12583: {",
          "12584:  unsigned int a, b, c, d, port;",
          "12585:  int ch, len;",
          "12586:  char *cb;",
          "12588:  char buf[100] = {0};",
          "12589: #endif",
          "12594:  memset(so, 0, sizeof(*so));",
          "12595:  so->lsa.sin.sin_family = AF_INET;",
          "12599:  port = 0;",
          "12600:  len = 0;",
          "12603:  if (sscanf(vec->ptr, \"%u.%u.%u.%u:%u%n\", &a, &b, &c, &d, &port, &len)",
          "12604:      == 5) {",
          "12606:   so->lsa.sin.sin_addr.s_addr =",
          "12607:       htonl((a << 24) | (b << 16) | (c << 8) | d);",
          "12608:   so->lsa.sin.sin_port = htons((uint16_t)port);",
          "12612:  } else if (sscanf(vec->ptr, \"[%49[^]]]:%u%n\", buf, &port, &len) == 2",
          "12613:             && mg_inet_pton(",
          "12614:                    AF_INET6, buf, &so->lsa.sin6, sizeof(so->lsa.sin6))) {",
          "12618:   so->lsa.sin6.sin6_port = htons((uint16_t)port);",
          "12622:  } else if ((vec->ptr[0] == '+')",
          "12623:             && (sscanf(vec->ptr + 1, \"%u%n\", &port, &len) == 1)) {",
          "12627:   len++;",
          "12631:   so->lsa.sin6.sin6_family = AF_INET6;",
          "12632:   so->lsa.sin6.sin6_port = htons((uint16_t)port);",
          "12640:  } else if (sscanf(vec->ptr, \"%u%n\", &port, &len) == 1) {",
          "12642:   so->lsa.sin.sin_port = htons((uint16_t)port);",
          "12645:  } else if ((cb = strchr(vec->ptr, ':')) != NULL) {",
          "12653:   if (mg_inet_pton(",
          "12654:           AF_INET, vec->ptr, &so->lsa.sin, sizeof(so->lsa.sin))) {",
          "12655:    if (sscanf(cb + 1, \"%u%n\", &port, &len) == 1) {",
          "12657:     so->lsa.sin.sin_family = AF_INET;",
          "12658:     so->lsa.sin.sin_port = htons((uint16_t)port);",
          "12659:     len += (int)(cb - vec->ptr) + 1;",
          "12660:    } else {",
          "12661:     port = 0;",
          "12662:     len = 0;",
          "12663:    }",
          "12665:   } else if (mg_inet_pton(AF_INET6,",
          "12666:                           vec->ptr,",
          "12667:                           &so->lsa.sin6,",
          "12668:                           sizeof(so->lsa.sin6))) {",
          "12669:    if (sscanf(cb + 1, \"%u%n\", &port, &len) == 1) {",
          "12671:     so->lsa.sin6.sin6_family = AF_INET6;",
          "12672:     so->lsa.sin.sin_port = htons((uint16_t)port);",
          "12673:     len += (int)(cb - vec->ptr) + 1;",
          "12674:    } else {",
          "12675:     port = 0;",
          "12676:     len = 0;",
          "12677:    }",
          "12681:  } else {",
          "12683:  }",
          "12687:  if ((len < 0) && ((unsigned)len > (unsigned)vec->len)) {",
          "12692:  so->is_ssl = (ch == 's');",
          "12693:  so->ssl_redir = (ch == 'r');",
          "12696:  if (is_valid_port(port)",
          "12697:      && ((ch == '\\0') || (ch == 's') || (ch == 'r') || (ch == ','))) {",
          "12698:   return 1;",
          "12699:  }",
          "12703:  return 0;",
          "12704: }",
          "12707: static int",
          "12708: set_ports_option(struct mg_context *ctx)",
          "12709: {",
          "12710:  const char *list;",
          "12711:  int on = 1;",
          "12713:  int off = 0;",
          "12715:  struct vec vec;",
          "12716:  struct socket so, *ptr;",
          "12718:  struct pollfd *pfd;",
          "12719:  union usa usa;",
          "12720:  socklen_t len;",
          "12721:  int ip_version;",
          "12723:  int portsTotal = 0;",
          "12724:  int portsOk = 0;",
          "12726:  if (!ctx) {",
          "12727:   return 0;",
          "12728:  }",
          "12730:  memset(&so, 0, sizeof(so));",
          "12731:  memset(&usa, 0, sizeof(usa));",
          "12732:  len = sizeof(usa);",
          "12733:  list = ctx->config[LISTENING_PORTS];",
          "12735:  while ((list = next_option(list, &vec, NULL)) != NULL) {",
          "12737:   portsTotal++;",
          "12739:   if (!parse_port_string(&vec, &so, &ip_version)) {",
          "12740:    mg_cry(fc(ctx),",
          "12741:           \"%.*s: invalid port spec (entry %i). Expecting list of: %s\",",
          "12742:           (int)vec.len,",
          "12743:           vec.ptr,",
          "12744:           portsTotal,",
          "12745:           \"[IP_ADDRESS:]PORT[s|r]\");",
          "12746:    continue;",
          "12747:   }",
          "12750:   if (so.is_ssl && ctx->ssl_ctx == NULL) {",
          "12752:    mg_cry(fc(ctx),",
          "12753:           \"Cannot add SSL socket (entry %i). Is -ssl_certificate \"",
          "12754:           \"option set?\",",
          "12755:           portsTotal);",
          "12756:    continue;",
          "12757:   }",
          "12760:   if ((so.sock = socket(so.lsa.sa.sa_family, SOCK_STREAM, 6))",
          "12761:       == INVALID_SOCKET) {",
          "12763:    mg_cry(fc(ctx), \"cannot create socket (entry %i)\", portsTotal);",
          "12764:    continue;",
          "12765:   }",
          "12777:   if (setsockopt(so.sock,",
          "12778:                  SOL_SOCKET,",
          "12779:                  SO_EXCLUSIVEADDRUSE,",
          "12780:                  (SOCK_OPT_TYPE)&on,",
          "12781:                  sizeof(on)) != 0) {",
          "12784:    mg_cry(fc(ctx),",
          "12785:           \"cannot set socket option SO_EXCLUSIVEADDRUSE (entry %i)\",",
          "12786:           portsTotal);",
          "12787:   }",
          "",
          "[Added Lines]",
          "12487:  }",
          "12490:  static void handle_file_based_request(struct mg_connection * conn,",
          "12491:                                        const char *path,",
          "12492:                                        struct mg_file *file)",
          "12493:  {",
          "12494:   if (!conn || !conn->ctx) {",
          "12495:    return;",
          "12496:   }",
          "12498:   if (0) {",
          "12500:   } else if (match_prefix(",
          "12501:                  conn->ctx->config[LUA_SERVER_PAGE_EXTENSIONS],",
          "12502:                  strlen(conn->ctx->config[LUA_SERVER_PAGE_EXTENSIONS]),",
          "12503:                  path) > 0) {",
          "12504:    if (is_in_script_path(conn, path)) {",
          "12509:     handle_lsp_request(conn, path, file, NULL);",
          "12510:    } else {",
          "12512:     mg_send_http_error(conn, 403, \"%s\", \"Forbidden\");",
          "12513:    }",
          "12515:   } else if (match_prefix(conn->ctx->config[LUA_SCRIPT_EXTENSIONS],",
          "12516:                           strlen(",
          "12517:                               conn->ctx->config[LUA_SCRIPT_EXTENSIONS]),",
          "12518:                           path) > 0) {",
          "12519:    if (is_in_script_path(conn, path)) {",
          "12524:     mg_exec_lua_script(conn, path, NULL);",
          "12525:    } else {",
          "12527:     mg_send_http_error(conn, 403, \"%s\", \"Forbidden\");",
          "12528:    }",
          "12531:   } else if (match_prefix(",
          "12532:                  conn->ctx->config[DUKTAPE_SCRIPT_EXTENSIONS],",
          "12533:                  strlen(conn->ctx->config[DUKTAPE_SCRIPT_EXTENSIONS]),",
          "12534:                  path) > 0) {",
          "12535:    if (is_in_script_path(conn, path)) {",
          "12537:     mg_exec_duktape_script(conn, path);",
          "12538:    } else {",
          "12540:     mg_send_http_error(conn, 403, \"%s\", \"Forbidden\");",
          "12541:    }",
          "12544:   } else if (match_prefix(conn->ctx->config[CGI_EXTENSIONS],",
          "12545:                           strlen(conn->ctx->config[CGI_EXTENSIONS]),",
          "12546:                           path) > 0) {",
          "12547:    if (is_in_script_path(conn, path)) {",
          "12549:     handle_cgi_request(conn, path);",
          "12550:    } else {",
          "12552:     mg_send_http_error(conn, 403, \"%s\", \"Forbidden\");",
          "12553:    }",
          "12555:   } else if (match_prefix(conn->ctx->config[SSI_EXTENSIONS],",
          "12556:                           strlen(conn->ctx->config[SSI_EXTENSIONS]),",
          "12557:                           path) > 0) {",
          "12558:    if (is_in_script_path(conn, path)) {",
          "12559:     handle_ssi_file_request(conn, path, file);",
          "12560:    } else {",
          "12562:     mg_send_http_error(conn, 403, \"%s\", \"Forbidden\");",
          "12563:    }",
          "12565:   } else if ((!conn->in_error_handler)",
          "12566:              && is_not_modified(conn, &file->stat)) {",
          "12568:    handle_not_modified_static_file_request(conn, file);",
          "12570:   } else {",
          "12571:    handle_static_file_request(conn, path, file, NULL, NULL);",
          "12572:   }",
          "12576:  static void close_all_listening_sockets(struct mg_context * ctx)",
          "12577:  {",
          "12578:   unsigned int i;",
          "12579:   if (!ctx) {",
          "12580:    return;",
          "12581:   }",
          "12583:   for (i = 0; i < ctx->num_listening_sockets; i++) {",
          "12584:    closesocket(ctx->listening_sockets[i].sock);",
          "12585:    ctx->listening_sockets[i].sock = INVALID_SOCKET;",
          "12586:   }",
          "12587:   mg_free(ctx->listening_sockets);",
          "12588:   ctx->listening_sockets = NULL;",
          "12589:   mg_free(ctx->listening_socket_fds);",
          "12590:   ctx->listening_socket_fds = NULL;",
          "12591:  }",
          "12608:  static int parse_port_string(const struct vec *vec,",
          "12609:                               struct socket *so,",
          "12610:                               int *ip_version)",
          "12611:  {",
          "12612:   unsigned int a, b, c, d, port;",
          "12613:   int ch, len;",
          "12614:   char *cb;",
          "12616:   char buf[100] = {0};",
          "12617: #endif",
          "12622:   memset(so, 0, sizeof(*so));",
          "12623:   so->lsa.sin.sin_family = AF_INET;",
          "12627:   port = 0;",
          "12628:   len = 0;",
          "12631:   if (sscanf(vec->ptr, \"%u.%u.%u.%u:%u%n\", &a, &b, &c, &d, &port, &len)",
          "12632:       == 5) {",
          "12634:    so->lsa.sin.sin_addr.s_addr =",
          "12635:        htonl((a << 24) | (b << 16) | (c << 8) | d);",
          "12636:    so->lsa.sin.sin_port = htons((uint16_t)port);",
          "12640:   } else if (sscanf(vec->ptr, \"[%49[^]]]:%u%n\", buf, &port, &len) == 2",
          "12641:              && mg_inet_pton(",
          "12642:                     AF_INET6, buf, &so->lsa.sin6, sizeof(so->lsa.sin6))) {",
          "12646:    so->lsa.sin6.sin6_port = htons((uint16_t)port);",
          "12650:   } else if ((vec->ptr[0] == '+')",
          "12651:              && (sscanf(vec->ptr + 1, \"%u%n\", &port, &len) == 1)) {",
          "12655:    len++;",
          "12659:    so->lsa.sin6.sin6_family = AF_INET6;",
          "12660:    so->lsa.sin6.sin6_port = htons((uint16_t)port);",
          "12668:   } else if (sscanf(vec->ptr, \"%u%n\", &port, &len) == 1) {",
          "12670:    so->lsa.sin.sin_port = htons((uint16_t)port);",
          "12673:   } else if ((cb = strchr(vec->ptr, ':')) != NULL) {",
          "12681:    if (mg_inet_pton(",
          "12682:            AF_INET, vec->ptr, &so->lsa.sin, sizeof(so->lsa.sin))) {",
          "12683:     if (sscanf(cb + 1, \"%u%n\", &port, &len) == 1) {",
          "12685:      so->lsa.sin.sin_family = AF_INET;",
          "12686:      so->lsa.sin.sin_port = htons((uint16_t)port);",
          "12687:      len += (int)(cb - vec->ptr) + 1;",
          "12688:     } else {",
          "12689:      port = 0;",
          "12690:      len = 0;",
          "12691:     }",
          "12693:    } else if (mg_inet_pton(AF_INET6,",
          "12694:                            vec->ptr,",
          "12695:                            &so->lsa.sin6,",
          "12696:                            sizeof(so->lsa.sin6))) {",
          "12697:     if (sscanf(cb + 1, \"%u%n\", &port, &len) == 1) {",
          "12699:      so->lsa.sin6.sin6_family = AF_INET6;",
          "12700:      so->lsa.sin.sin_port = htons((uint16_t)port);",
          "12701:      len += (int)(cb - vec->ptr) + 1;",
          "12702:     } else {",
          "12703:      port = 0;",
          "12704:      len = 0;",
          "12705:     }",
          "12707:    }",
          "12709:   } else {",
          "12715:   if ((len < 0) && ((unsigned)len > (unsigned)vec->len)) {",
          "12717:    return 0;",
          "12718:   }",
          "12720:   so->is_ssl = (ch == 's');",
          "12721:   so->ssl_redir = (ch == 'r');",
          "12724:   if (is_valid_port(port)",
          "12725:       && ((ch == '\\0') || (ch == 's') || (ch == 'r') || (ch == ','))) {",
          "12726:    return 1;",
          "12727:   }",
          "12735:  static int set_ports_option(struct mg_context * ctx)",
          "12736:  {",
          "12737:   const char *list;",
          "12738:   int on = 1;",
          "12740:   int off = 0;",
          "12742:   struct vec vec;",
          "12743:   struct socket so, *ptr;",
          "12745:   struct pollfd *pfd;",
          "12746:   union usa usa;",
          "12747:   socklen_t len;",
          "12748:   int ip_version;",
          "12750:   int portsTotal = 0;",
          "12751:   int portsOk = 0;",
          "12753:   if (!ctx) {",
          "12754:    return 0;",
          "12755:   }",
          "12757:   memset(&so, 0, sizeof(so));",
          "12758:   memset(&usa, 0, sizeof(usa));",
          "12759:   len = sizeof(usa);",
          "12760:   list = ctx->config[LISTENING_PORTS];",
          "12762:   while ((list = next_option(list, &vec, NULL)) != NULL) {",
          "12764:    portsTotal++;",
          "12766:    if (!parse_port_string(&vec, &so, &ip_version)) {",
          "12767:     mg_cry(",
          "12768:         fc(ctx),",
          "12769:         \"%.*s: invalid port spec (entry %i). Expecting list of: %s\",",
          "12770:         (int)vec.len,",
          "12771:         vec.ptr,",
          "12772:         portsTotal,",
          "12773:         \"[IP_ADDRESS:]PORT[s|r]\");",
          "12774:     continue;",
          "12775:    }",
          "12778:    if (so.is_ssl && ctx->ssl_ctx == NULL) {",
          "12780:     mg_cry(fc(ctx),",
          "12781:            \"Cannot add SSL socket (entry %i). Is -ssl_certificate \"",
          "12782:            \"option set?\",",
          "12783:            portsTotal);",
          "12784:     continue;",
          "12785:    }",
          "12788:    if ((so.sock = socket(so.lsa.sa.sa_family, SOCK_STREAM, 6))",
          "12789:        == INVALID_SOCKET) {",
          "12791:     mg_cry(fc(ctx), \"cannot create socket (entry %i)\", portsTotal);",
          "12792:     continue;",
          "12793:    }",
          "12805:    if (setsockopt(so.sock,",
          "12806:                   SOL_SOCKET,",
          "12807:                   SO_EXCLUSIVEADDRUSE,",
          "12808:                   (SOCK_OPT_TYPE)&on,",
          "12809:                   sizeof(on)) != 0) {",
          "12812:     mg_cry(",
          "12813:         fc(ctx),",
          "12814:         \"cannot set socket option SO_EXCLUSIVEADDRUSE (entry %i)\",",
          "12815:         portsTotal);",
          "12816:    }",
          "",
          "---------------",
          "--- Hunk 51 ---",
          "[Context before]",
          "12799:   }",
          "12800: #endif",
          "12803: #if defined(USE_IPV6)",
          "12816:     }",
          "12818: #else",
          "12819:    mg_cry(fc(ctx), \"IPv6 not available\");",
          "12820:    closesocket(so.sock);",
          "12821:    so.sock = INVALID_SOCKET;",
          "12822:    continue;",
          "12823: #endif",
          "12830:     mg_cry(fc(ctx),",
          "12832:            (int)vec.len,",
          "12833:            vec.ptr,",
          "12834:            (int)ERRNO,",
          "",
          "[Removed Lines]",
          "12802:   if (ip_version > 4) {",
          "12804:    if (ip_version == 6) {",
          "12805:     if (so.lsa.sa.sa_family == AF_INET6",
          "12806:         && setsockopt(so.sock,",
          "12807:                       IPPROTO_IPV6,",
          "12808:                       IPV6_V6ONLY,",
          "12809:                       (void *)&off,",
          "12810:                       sizeof(off)) != 0) {",
          "12813:      mg_cry(fc(ctx),",
          "12814:             \"cannot set socket option IPV6_V6ONLY (entry %i)\",",
          "12815:             portsTotal);",
          "12817:    }",
          "12824:   }",
          "12826:   if (so.lsa.sa.sa_family == AF_INET) {",
          "12828:    len = sizeof(so.lsa.sin);",
          "12829:    if (bind(so.sock, &so.lsa.sa, len) != 0) {",
          "12831:            \"cannot bind to %.*s: %d (%s)\",",
          "",
          "[Added Lines]",
          "12831:    if (ip_version > 4) {",
          "12833:     if (ip_version == 6) {",
          "12834:      if (so.lsa.sa.sa_family == AF_INET6",
          "12835:          && setsockopt(so.sock,",
          "12836:                        IPPROTO_IPV6,",
          "12837:                        IPV6_V6ONLY,",
          "12838:                        (void *)&off,",
          "12839:                        sizeof(off)) != 0) {",
          "12842:       mg_cry(",
          "12843:           fc(ctx),",
          "12844:           \"cannot set socket option IPV6_V6ONLY (entry %i)\",",
          "12845:           portsTotal);",
          "12846:      }",
          "12854:    }",
          "12856:    if (so.lsa.sa.sa_family == AF_INET) {",
          "12858:     len = sizeof(so.lsa.sin);",
          "12859:     if (bind(so.sock, &so.lsa.sa, len) != 0) {",
          "12860:      mg_cry(fc(ctx),",
          "12861:             \"cannot bind to %.*s: %d (%s)\",",
          "12862:             (int)vec.len,",
          "12863:             vec.ptr,",
          "12864:             (int)ERRNO,",
          "12865:             strerror(errno));",
          "12866:      closesocket(so.sock);",
          "12867:      so.sock = INVALID_SOCKET;",
          "12868:      continue;",
          "12869:     }",
          "12870:    }",
          "12871: #if defined(USE_IPV6)",
          "12872:    else if (so.lsa.sa.sa_family == AF_INET6) {",
          "12874:     len = sizeof(so.lsa.sin6);",
          "12875:     if (bind(so.sock, &so.lsa.sa, len) != 0) {",
          "12876:      mg_cry(fc(ctx),",
          "12877:             \"cannot bind to IPv6 %.*s: %d (%s)\",",
          "12878:             (int)vec.len,",
          "12879:             vec.ptr,",
          "12880:             (int)ERRNO,",
          "12881:             strerror(errno));",
          "12882:      closesocket(so.sock);",
          "12883:      so.sock = INVALID_SOCKET;",
          "12884:      continue;",
          "12885:     }",
          "12886:    }",
          "12887: #endif",
          "12888:    else {",
          "12889:     mg_cry(fc(ctx),",
          "12890:            \"cannot bind: address family not supported (entry %i)\",",
          "12891:            portsTotal);",
          "12892:     closesocket(so.sock);",
          "12893:     so.sock = INVALID_SOCKET;",
          "12894:     continue;",
          "12895:    }",
          "12897:    if (listen(so.sock, SOMAXCONN) != 0) {",
          "12900:            \"cannot listen to %.*s: %d (%s)\",",
          "",
          "---------------",
          "--- Hunk 52 ---",
          "[Context before]",
          "12837:     so.sock = INVALID_SOCKET;",
          "12838:     continue;",
          "12839:    }",
          "12846:     mg_cry(fc(ctx),",
          "12848:            (int)vec.len,",
          "12849:            vec.ptr,",
          "12851:            strerror(errno));",
          "12852:     closesocket(so.sock);",
          "12853:     so.sock = INVALID_SOCKET;",
          "12854:     continue;",
          "12855:    }",
          "12896: #if defined(USE_IPV6)",
          "12900: #endif",
          "12928:   }",
          "12941:  }",
          "12956:  }",
          "12982:    fi.access.fp = NULL;",
          "12983:   }",
          "13038:   }",
          "13042:   }",
          "13047:   }",
          "13048:  }",
          "13080:    }",
          "13084:  }",
          "13089: #if !defined(_WIN32)",
          "13121:     success = 1;",
          "13122:    }",
          "13126:  }",
          "13142:   }",
          "13143:  }",
          "13148: #if !defined(NO_SSL)",
          "13198:    }",
          "13215:    }",
          "13221:    }",
          "13223:   }",
          "13233: #ifdef OPENSSL_API_1_1",
          "13234: #else",
          "13235: static pthread_mutex_t *ssl_mutexes;",
          "13260:   }",
          "13276: #ifndef OPENSSL_API_1_1",
          "13278: #endif",
          "13298:      break;",
          "13299:     }",
          "13308:    } else {",
          "13311:     break;",
          "13312:    }",
          "13317:   }",
          "13325: #ifndef OPENSSL_API_1_1",
          "13327: #endif",
          "13361:   }",
          "13364:  }",
          "13450:  }",
          "13454: #ifdef OPENSSL_API_1_1",
          "",
          "[Removed Lines]",
          "12840:   }",
          "12841: #if defined(USE_IPV6)",
          "12842:   else if (so.lsa.sa.sa_family == AF_INET6) {",
          "12844:    len = sizeof(so.lsa.sin6);",
          "12845:    if (bind(so.sock, &so.lsa.sa, len) != 0) {",
          "12847:            \"cannot bind to IPv6 %.*s: %d (%s)\",",
          "12850:            (int)ERRNO,",
          "12856:   }",
          "12857: #endif",
          "12858:   else {",
          "12859:    mg_cry(fc(ctx),",
          "12860:           \"cannot bind: address family not supported (entry %i)\",",
          "12861:           portsTotal);",
          "12862:    closesocket(so.sock);",
          "12863:    so.sock = INVALID_SOCKET;",
          "12864:    continue;",
          "12865:   }",
          "12867:   if (listen(so.sock, SOMAXCONN) != 0) {",
          "12869:    mg_cry(fc(ctx),",
          "12870:           \"cannot listen to %.*s: %d (%s)\",",
          "12871:           (int)vec.len,",
          "12872:           vec.ptr,",
          "12873:           (int)ERRNO,",
          "12874:           strerror(errno));",
          "12875:    closesocket(so.sock);",
          "12876:    so.sock = INVALID_SOCKET;",
          "12877:    continue;",
          "12878:   }",
          "12880:   if ((getsockname(so.sock, &(usa.sa), &len) != 0)",
          "12881:       || (usa.sa.sa_family != so.lsa.sa.sa_family)) {",
          "12883:    int err = (int)ERRNO;",
          "12884:    mg_cry(fc(ctx),",
          "12885:           \"call to getsockname failed %.*s: %d (%s)\",",
          "12886:           (int)vec.len,",
          "12887:           vec.ptr,",
          "12888:           err,",
          "12889:           strerror(errno));",
          "12890:    closesocket(so.sock);",
          "12891:    so.sock = INVALID_SOCKET;",
          "12892:    continue;",
          "12893:   }",
          "12897:   if (so.lsa.sa.sa_family == AF_INET6) {",
          "12898:    so.lsa.sin6.sin6_port = usa.sin6.sin6_port;",
          "12899:   } else",
          "12901:   {",
          "12902:    so.lsa.sin.sin_port = usa.sin.sin_port;",
          "12903:   }",
          "12905:   if ((ptr = (struct socket *)",
          "12906:            mg_realloc_ctx(ctx->listening_sockets,",
          "12907:                           (ctx->num_listening_sockets + 1)",
          "12909:                           ctx)) == NULL) {",
          "12911:    mg_cry(fc(ctx), \"%s\", \"Out of memory\");",
          "12912:    closesocket(so.sock);",
          "12913:    so.sock = INVALID_SOCKET;",
          "12914:    continue;",
          "12915:   }",
          "12917:   if ((pfd = (struct pollfd *)",
          "12918:            mg_realloc_ctx(ctx->listening_socket_fds,",
          "12919:                           (ctx->num_listening_sockets + 1)",
          "12921:                           ctx)) == NULL) {",
          "12923:    mg_cry(fc(ctx), \"%s\", \"Out of memory\");",
          "12924:    closesocket(so.sock);",
          "12925:    so.sock = INVALID_SOCKET;",
          "12926:    mg_free(ptr);",
          "12927:    continue;",
          "12930:   set_close_on_exec(so.sock, fc(ctx));",
          "12931:   ctx->listening_sockets = ptr;",
          "12932:   ctx->listening_sockets[ctx->num_listening_sockets] = so;",
          "12933:   ctx->listening_socket_fds = pfd;",
          "12934:   ctx->num_listening_sockets++;",
          "12935:   portsOk++;",
          "12936:  }",
          "12938:  if (portsOk != portsTotal) {",
          "12939:   close_all_listening_sockets(ctx);",
          "12940:   portsOk = 0;",
          "12943:  return portsOk;",
          "12944: }",
          "12947: static const char *",
          "12948: header_val(const struct mg_connection *conn, const char *header)",
          "12949: {",
          "12950:  const char *header_value;",
          "12952:  if ((header_value = mg_get_header(conn, header)) == NULL) {",
          "12953:   return \"-\";",
          "12954:  } else {",
          "12955:   return header_value;",
          "12957: }",
          "12960: static void",
          "12961: log_access(const struct mg_connection *conn)",
          "12962: {",
          "12963:  const struct mg_request_info *ri;",
          "12964:  struct mg_file fi;",
          "12965:  char date[64], src_addr[IP_ADDR_STR_LEN];",
          "12966:  struct tm *tm;",
          "12968:  const char *referer;",
          "12969:  const char *user_agent;",
          "12971:  char buf[4096];",
          "12973:  if (!conn || !conn->ctx) {",
          "12974:   return;",
          "12975:  }",
          "12977:  if (conn->ctx->config[ACCESS_LOG_FILE] != NULL) {",
          "12978:   if (mg_fopen(conn,",
          "12979:                conn->ctx->config[ACCESS_LOG_FILE],",
          "12980:                MG_FOPEN_MODE_APPEND,",
          "12981:                &fi) == 0) {",
          "12984:  } else {",
          "12985:   fi.access.fp = NULL;",
          "12986:  }",
          "12990:  if ((fi.access.fp == NULL) && (conn->ctx->callbacks.log_access == NULL)) {",
          "12991:   return;",
          "12992:  }",
          "12994:  tm = localtime(&conn->conn_birth_time);",
          "12995:  if (tm != NULL) {",
          "12996:   strftime(date, sizeof(date), \"%d/%b/%Y:%H:%M:%S %z\", tm);",
          "12997:  } else {",
          "12998:   mg_strlcpy(date, \"01/Jan/1970:00:00:00 +0000\", sizeof(date));",
          "12999:   date[sizeof(date) - 1] = '\\0';",
          "13000:  }",
          "13002:  ri = &conn->request_info;",
          "13004:  sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);",
          "13005:  referer = header_val(conn, \"Referer\");",
          "13006:  user_agent = header_val(conn, \"User-Agent\");",
          "13008:  mg_snprintf(conn,",
          "13010:              buf,",
          "13011:              sizeof(buf),",
          "13012:              \"%s - %s [%s] \\\"%s %s%s%s HTTP/%s\\\" %d %\" INT64_FMT \" %s %s\",",
          "13013:              src_addr,",
          "13014:              (ri->remote_user == NULL) ? \"-\" : ri->remote_user,",
          "13015:              date,",
          "13016:              ri->request_method ? ri->request_method : \"-\",",
          "13017:              ri->request_uri ? ri->request_uri : \"-\",",
          "13018:              ri->query_string ? \"?\" : \"\",",
          "13019:              ri->query_string ? ri->query_string : \"\",",
          "13020:              ri->http_version,",
          "13021:              conn->status_code,",
          "13022:              conn->num_bytes_sent,",
          "13023:              referer,",
          "13024:              user_agent);",
          "13026:  if (conn->ctx->callbacks.log_access) {",
          "13027:   conn->ctx->callbacks.log_access(conn, buf);",
          "13028:  }",
          "13030:  if (fi.access.fp) {",
          "13031:   int ok = 1;",
          "13032:   flockfile(fi.access.fp);",
          "13033:   if (fprintf(fi.access.fp, \"%s\\n\", buf) < 1) {",
          "13034:    ok = 0;",
          "13035:   }",
          "13036:   if (fflush(fi.access.fp) != 0) {",
          "13037:    ok = 0;",
          "13039:   funlockfile(fi.access.fp);",
          "13040:   if (mg_fclose(&fi.access) != 0) {",
          "13041:    ok = 0;",
          "13043:   if (!ok) {",
          "13044:    mg_cry(conn,",
          "13045:           \"Error writing log file %s\",",
          "13046:           conn->ctx->config[ACCESS_LOG_FILE]);",
          "13049: }",
          "13055: static int",
          "13056: check_acl(struct mg_context *ctx, uint32_t remote_ip)",
          "13057: {",
          "13058:  int allowed, flag;",
          "13059:  uint32_t net, mask;",
          "13060:  struct vec vec;",
          "13062:  if (ctx) {",
          "13063:   const char *list = ctx->config[ACCESS_CONTROL_LIST];",
          "13066:   allowed = (list == NULL) ? '+' : '-';",
          "13068:   while ((list = next_option(list, &vec, NULL)) != NULL) {",
          "13069:    flag = vec.ptr[0];",
          "13070:    if ((flag != '+' && flag != '-')",
          "13071:        || (parse_net(&vec.ptr[1], &net, &mask) == 0)) {",
          "13072:     mg_cry(fc(ctx),",
          "13073:            \"%s: subnet must be [+|-]x.x.x.x[/x]\",",
          "13074:            __func__);",
          "13075:     return -1;",
          "13076:    }",
          "13078:    if (net == (remote_ip & mask)) {",
          "13079:     allowed = flag;",
          "13081:   }",
          "13083:   return allowed == '+';",
          "13085:  return -1;",
          "13086: }",
          "13090: static int",
          "13091: set_uid_option(struct mg_context *ctx)",
          "13092: {",
          "13093:  struct passwd *pw;",
          "13094:  if (ctx) {",
          "13095:   const char *uid = ctx->config[RUN_AS_USER];",
          "13096:   int success = 0;",
          "13098:   if (uid == NULL) {",
          "13099:    success = 1;",
          "13100:   } else {",
          "13101:    if ((pw = getpwnam(uid)) == NULL) {",
          "13102:     mg_cry(fc(ctx), \"%s: unknown user [%s]\", __func__, uid);",
          "13103:    } else if (setgid(pw->pw_gid) == -1) {",
          "13104:     mg_cry(fc(ctx),",
          "13105:            \"%s: setgid(%s): %s\",",
          "13106:            __func__,",
          "13107:            uid,",
          "13108:            strerror(errno));",
          "13109:    } else if (setgroups(0, NULL)) {",
          "13110:     mg_cry(fc(ctx),",
          "13111:            \"%s: setgroups(): %s\",",
          "13112:            __func__,",
          "13113:            strerror(errno));",
          "13114:    } else if (setuid(pw->pw_uid) == -1) {",
          "13115:     mg_cry(fc(ctx),",
          "13116:            \"%s: setuid(%s): %s\",",
          "13117:            __func__,",
          "13118:            uid,",
          "13119:            strerror(errno));",
          "13120:    } else {",
          "13123:   }",
          "13125:   return success;",
          "13127:  return 0;",
          "13128: }",
          "13132: static void",
          "13133: tls_dtor(void *key)",
          "13134: {",
          "13135:  struct mg_workerTLS *tls = (struct mg_workerTLS *)key;",
          "13138:  if (tls) {",
          "13139:   if (tls->is_master == 2) {",
          "13141:    mg_free(tls);",
          "13144:  pthread_setspecific(sTlsKey, NULL);",
          "13145: }",
          "13150: static int",
          "13151: ssl_use_pem_file(struct mg_context *ctx, const char *pem, const char *chain);",
          "13152: static const char *ssl_error(void);",
          "13155: static int",
          "13156: refresh_trust(struct mg_connection *conn)",
          "13157: {",
          "13158:  static int reload_lock = 0;",
          "13159:  static long int data_check = 0;",
          "13160:  volatile int *p_reload_lock = (volatile int *)&reload_lock;",
          "13162:  struct stat cert_buf;",
          "13163:  long int t;",
          "13164:  const char *pem;",
          "13165:  const char *chain;",
          "13166:  int should_verify_peer;",
          "13168:  if ((pem = conn->ctx->config[SSL_CERTIFICATE]) == NULL) {",
          "13171:   return 0;",
          "13172:  }",
          "13173:  chain = conn->ctx->config[SSL_CERTIFICATE_CHAIN];",
          "13174:  if (chain == NULL) {",
          "13176:   chain = pem;",
          "13177:  }",
          "13178:  if (*chain == 0) {",
          "13179:   chain = NULL;",
          "13180:  }",
          "13182:  t = data_check;",
          "13183:  if (stat(pem, &cert_buf) != -1) {",
          "13184:   t = (long int)cert_buf.st_mtime;",
          "13185:  }",
          "13187:  if (data_check != t) {",
          "13188:   data_check = t;",
          "13190:   should_verify_peer = 0;",
          "13191:   if (conn->ctx->config[SSL_DO_VERIFY_PEER] != NULL) {",
          "13192:    if (mg_strcasecmp(conn->ctx->config[SSL_DO_VERIFY_PEER], \"yes\")",
          "13193:        == 0) {",
          "13194:     should_verify_peer = 1;",
          "13195:    } else if (mg_strcasecmp(conn->ctx->config[SSL_DO_VERIFY_PEER],",
          "13196:                             \"optional\") == 0) {",
          "13197:     should_verify_peer = 1;",
          "13199:   }",
          "13201:   if (should_verify_peer) {",
          "13202:    char *ca_path = conn->ctx->config[SSL_CA_PATH];",
          "13203:    char *ca_file = conn->ctx->config[SSL_CA_FILE];",
          "13204:    if (SSL_CTX_load_verify_locations(conn->ctx->ssl_ctx,",
          "13205:                                      ca_file,",
          "13206:                                      ca_path) != 1) {",
          "13207:     mg_cry(fc(conn->ctx),",
          "13208:            \"SSL_CTX_load_verify_locations error: %s \"",
          "13209:            \"ssl_verify_peer requires setting \"",
          "13210:            \"either ssl_ca_path or ssl_ca_file. Is any of them \"",
          "13211:            \"present in \"",
          "13212:            \"the .conf file?\",",
          "13213:            ssl_error());",
          "13214:     return 0;",
          "13216:   }",
          "13218:   if (1 == mg_atomic_inc(p_reload_lock)) {",
          "13219:    if (ssl_use_pem_file(conn->ctx, pem, chain) == 0) {",
          "13220:     return 0;",
          "13224:  }",
          "13226:  while (*p_reload_lock) {",
          "13227:   sleep(1);",
          "13228:  }",
          "13230:  return 1;",
          "13231: }",
          "13238: static int",
          "13239: sslize(struct mg_connection *conn,",
          "13240:        SSL_CTX *s,",
          "13241:        int (*func)(SSL *),",
          "13242:        volatile int *stop_server)",
          "13243: {",
          "13244:  int ret, err;",
          "13245:  int short_trust;",
          "13246:  unsigned i;",
          "13248:  if (!conn) {",
          "13249:   return 0;",
          "13250:  }",
          "13252:  short_trust =",
          "13253:      (conn->ctx->config[SSL_SHORT_TRUST] != NULL)",
          "13254:      && (mg_strcasecmp(conn->ctx->config[SSL_SHORT_TRUST], \"yes\") == 0);",
          "13256:  if (short_trust) {",
          "13257:   int trust_ret = refresh_trust(conn);",
          "13258:   if (!trust_ret) {",
          "13259:    return trust_ret;",
          "13261:  }",
          "13263:  conn->ssl = SSL_new(s);",
          "13264:  if (conn->ssl == NULL) {",
          "13265:   return 0;",
          "13266:  }",
          "13268:  ret = SSL_set_fd(conn->ssl, conn->client.sock);",
          "13269:  if (ret != 1) {",
          "13270:   err = SSL_get_error(conn->ssl, ret);",
          "13272:   SSL_free(conn->ssl);",
          "13273:   conn->ssl = NULL;",
          "13277:   ERR_remove_state(0);",
          "13279:   return 0;",
          "13280:  }",
          "13285:  for (i = 16; i <= 1024; i *= 2) {",
          "13286:   ret = func(conn->ssl);",
          "13287:   if (ret != 1) {",
          "13288:    err = SSL_get_error(conn->ssl, ret);",
          "13289:    if ((err == SSL_ERROR_WANT_CONNECT)",
          "13290:        || (err == SSL_ERROR_WANT_ACCEPT)",
          "13291:        || (err == SSL_ERROR_WANT_READ)",
          "13292:        || (err == SSL_ERROR_WANT_WRITE)) {",
          "13296:     if (*stop_server) {",
          "13300:     mg_sleep(i);",
          "13302:    } else if (err == SSL_ERROR_SYSCALL) {",
          "13304:     err = errno;",
          "13306:     (void)err;",
          "13307:     break;",
          "13314:   } else {",
          "13316:    break;",
          "13318:  }",
          "13320:  if (ret != 1) {",
          "13321:   SSL_free(conn->ssl);",
          "13322:   conn->ssl = NULL;",
          "13326:   ERR_remove_state(0);",
          "13328:   return 0;",
          "13329:  }",
          "13331:  return 1;",
          "13332: }",
          "13336: static const char *",
          "13337: ssl_error(void)",
          "13338: {",
          "13339:  unsigned long err;",
          "13340:  err = ERR_get_error();",
          "13341:  return ((err == 0) ? \"\" : ERR_error_string(err, NULL));",
          "13342: }",
          "13345: static int",
          "13346: hexdump2string(void *mem, int memlen, char *buf, int buflen)",
          "13347: {",
          "13348:  int i;",
          "13349:  const char hexdigit[] = \"0123456789abcdef\";",
          "13351:  if ((memlen <= 0) || (buflen <= 0)) {",
          "13352:   return 0;",
          "13353:  }",
          "13354:  if (buflen < (3 * memlen)) {",
          "13355:   return 0;",
          "13356:  }",
          "13358:  for (i = 0; i < memlen; i++) {",
          "13359:   if (i > 0) {",
          "13360:    buf[3 * i - 1] = ' ';",
          "13362:   buf[3 * i] = hexdigit[(((uint8_t *)mem)[i] >> 4) & 0xF];",
          "13363:   buf[3 * i + 1] = hexdigit[((uint8_t *)mem)[i] & 0xF];",
          "13365:  buf[3 * memlen - 1] = 0;",
          "13367:  return 1;",
          "13368: }",
          "13371: static void",
          "13372: ssl_get_client_cert_info(struct mg_connection *conn)",
          "13373: {",
          "13374:  X509 *cert = SSL_get_peer_certificate(conn->ssl);",
          "13375:  if (cert) {",
          "13376:   char str_subject[1024];",
          "13377:   char str_issuer[1024];",
          "13378:   char str_finger[1024];",
          "13379:   unsigned char buf[256];",
          "13380:   char *str_serial = NULL;",
          "13381:   unsigned int ulen;",
          "13382:   int ilen;",
          "13383:   unsigned char *tmp_buf;",
          "13384:   unsigned char *tmp_p;",
          "13387:   const EVP_MD *digest = EVP_get_digestbyname(\"sha1\");",
          "13390:   X509_NAME *subj = X509_get_subject_name(cert);",
          "13391:   X509_NAME *iss = X509_get_issuer_name(cert);",
          "13394:   ASN1_INTEGER *serial = X509_get_serialNumber(cert);",
          "13397:   BIGNUM *serial_bn = ASN1_INTEGER_to_BN(serial, NULL);",
          "13398:   str_serial = BN_bn2hex(serial_bn);",
          "13399:   BN_free(serial_bn);",
          "13402:   (void)X509_NAME_oneline(subj, str_subject, (int)sizeof(str_subject));",
          "13403:   (void)X509_NAME_oneline(iss, str_issuer, (int)sizeof(str_issuer));",
          "13406:   ulen = 0;",
          "13410:   ilen = i2d_X509((void *)cert, NULL);",
          "13411:   tmp_buf =",
          "13412:       (ilen > 0)",
          "13413:           ? (unsigned char *)mg_malloc_ctx((unsigned)ilen + 1, conn->ctx)",
          "13414:           : NULL;",
          "13415:   if (tmp_buf) {",
          "13416:    tmp_p = tmp_buf;",
          "13417:    (void)i2d_X509((void *)cert, &tmp_p);",
          "13418:    if (!EVP_Digest(",
          "13419:            tmp_buf, (unsigned)ilen, buf, &ulen, digest, NULL)) {",
          "13420:     ulen = 0;",
          "13421:    }",
          "13422:    mg_free(tmp_buf);",
          "13423:   }",
          "13425:   if (!hexdump2string(",
          "13426:           buf, (int)ulen, str_finger, (int)sizeof(str_finger))) {",
          "13428:   }",
          "13430:   conn->request_info.client_cert =",
          "13431:       (struct client_cert *)mg_malloc_ctx(sizeof(struct client_cert),",
          "13432:                                           conn->ctx);",
          "13433:   if (conn->request_info.client_cert) {",
          "13434:    conn->request_info.client_cert->subject = mg_strdup(str_subject);",
          "13435:    conn->request_info.client_cert->issuer = mg_strdup(str_issuer);",
          "13436:    conn->request_info.client_cert->serial = mg_strdup(str_serial);",
          "13437:    conn->request_info.client_cert->finger = mg_strdup(str_finger);",
          "13438:   } else {",
          "13439:    mg_cry(",
          "13440:        conn,",
          "13441:        \"Out of memory: Cannot allocate memory for client certificate\");",
          "13442:   }",
          "13446:   OPENSSL_free(str_serial);",
          "13449:   X509_free(cert);",
          "13451: }",
          "",
          "[Added Lines]",
          "12910:    if ((getsockname(so.sock, &(usa.sa), &len) != 0)",
          "12911:        || (usa.sa.sa_family != so.lsa.sa.sa_family)) {",
          "12913:     int err = (int)ERRNO;",
          "12915:            \"call to getsockname failed %.*s: %d (%s)\",",
          "12918:            err,",
          "12927:    if (so.lsa.sa.sa_family == AF_INET6) {",
          "12928:     so.lsa.sin6.sin6_port = usa.sin6.sin6_port;",
          "12929:    } else",
          "12931:    {",
          "12932:     so.lsa.sin.sin_port = usa.sin.sin_port;",
          "12933:    }",
          "12935:    if ((ptr = (struct socket *)",
          "12936:             mg_realloc_ctx(ctx->listening_sockets,",
          "12937:                            (ctx->num_listening_sockets + 1)",
          "12939:                            ctx)) == NULL) {",
          "12941:     mg_cry(fc(ctx), \"%s\", \"Out of memory\");",
          "12942:     closesocket(so.sock);",
          "12943:     so.sock = INVALID_SOCKET;",
          "12944:     continue;",
          "12945:    }",
          "12947:    if ((pfd = (struct pollfd *)",
          "12948:             mg_realloc_ctx(ctx->listening_socket_fds,",
          "12949:                            (ctx->num_listening_sockets + 1)",
          "12951:                            ctx)) == NULL) {",
          "12953:     mg_cry(fc(ctx), \"%s\", \"Out of memory\");",
          "12954:     closesocket(so.sock);",
          "12955:     so.sock = INVALID_SOCKET;",
          "12956:     mg_free(ptr);",
          "12957:     continue;",
          "12958:    }",
          "12960:    set_close_on_exec(so.sock, fc(ctx));",
          "12961:    ctx->listening_sockets = ptr;",
          "12962:    ctx->listening_sockets[ctx->num_listening_sockets] = so;",
          "12963:    ctx->listening_socket_fds = pfd;",
          "12964:    ctx->num_listening_sockets++;",
          "12965:    portsOk++;",
          "12968:   if (portsOk != portsTotal) {",
          "12969:    close_all_listening_sockets(ctx);",
          "12970:    portsOk = 0;",
          "12971:   }",
          "12973:   return portsOk;",
          "12977:  static const char *header_val(const struct mg_connection *conn,",
          "12978:                                const char *header)",
          "12979:  {",
          "12980:   const char *header_value;",
          "12982:   if ((header_value = mg_get_header(conn, header)) == NULL) {",
          "12983:    return \"-\";",
          "12984:   } else {",
          "12985:    return header_value;",
          "12986:   }",
          "12990:  static void log_access(const struct mg_connection *conn)",
          "12991:  {",
          "12992:   const struct mg_request_info *ri;",
          "12993:   struct mg_file fi;",
          "12994:   char date[64], src_addr[IP_ADDR_STR_LEN];",
          "12995:   struct tm *tm;",
          "12997:   const char *referer;",
          "12998:   const char *user_agent;",
          "13000:   char buf[4096];",
          "13002:   if (!conn || !conn->ctx) {",
          "13003:    return;",
          "13004:   }",
          "13006:   if (conn->ctx->config[ACCESS_LOG_FILE] != NULL) {",
          "13007:    if (mg_fopen(conn,",
          "13008:                 conn->ctx->config[ACCESS_LOG_FILE],",
          "13009:                 MG_FOPEN_MODE_APPEND,",
          "13010:                 &fi) == 0) {",
          "13011:     fi.access.fp = NULL;",
          "13012:    }",
          "13013:   } else {",
          "13019:   if ((fi.access.fp == NULL)",
          "13020:       && (conn->ctx->callbacks.log_access == NULL)) {",
          "13021:    return;",
          "13024:   tm = localtime(&conn->conn_birth_time);",
          "13025:   if (tm != NULL) {",
          "13026:    strftime(date, sizeof(date), \"%d/%b/%Y:%H:%M:%S %z\", tm);",
          "13027:   } else {",
          "13028:    mg_strlcpy(date, \"01/Jan/1970:00:00:00 +0000\", sizeof(date));",
          "13029:    date[sizeof(date) - 1] = '\\0';",
          "13032:   ri = &conn->request_info;",
          "13034:   sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);",
          "13035:   referer = header_val(conn, \"Referer\");",
          "13036:   user_agent = header_val(conn, \"User-Agent\");",
          "13038:   mg_snprintf(conn,",
          "13040:               buf,",
          "13041:               sizeof(buf),",
          "13042:               \"%s - %s [%s] \\\"%s %s%s%s HTTP/%s\\\" %d %\" INT64_FMT",
          "13043:               \" %s %s\",",
          "13044:               src_addr,",
          "13045:               (ri->remote_user == NULL) ? \"-\" : ri->remote_user,",
          "13046:               date,",
          "13047:               ri->request_method ? ri->request_method : \"-\",",
          "13048:               ri->request_uri ? ri->request_uri : \"-\",",
          "13049:               ri->query_string ? \"?\" : \"\",",
          "13050:               ri->query_string ? ri->query_string : \"\",",
          "13051:               ri->http_version,",
          "13052:               conn->status_code,",
          "13053:               conn->num_bytes_sent,",
          "13054:               referer,",
          "13055:               user_agent);",
          "13057:   if (conn->ctx->callbacks.log_access) {",
          "13058:    conn->ctx->callbacks.log_access(conn, buf);",
          "13059:   }",
          "13061:   if (fi.access.fp) {",
          "13062:    int ok = 1;",
          "13063:    flockfile(fi.access.fp);",
          "13064:    if (fprintf(fi.access.fp, \"%s\\n\", buf) < 1) {",
          "13065:     ok = 0;",
          "13066:    }",
          "13067:    if (fflush(fi.access.fp) != 0) {",
          "13068:     ok = 0;",
          "13069:    }",
          "13070:    funlockfile(fi.access.fp);",
          "13071:    if (mg_fclose(&fi.access) != 0) {",
          "13072:     ok = 0;",
          "13073:    }",
          "13074:    if (!ok) {",
          "13075:     mg_cry(conn,",
          "13076:            \"Error writing log file %s\",",
          "13077:            conn->ctx->config[ACCESS_LOG_FILE]);",
          "13078:    }",
          "13086:  static int check_acl(struct mg_context * ctx, uint32_t remote_ip)",
          "13087:  {",
          "13088:   int allowed, flag;",
          "13089:   uint32_t net, mask;",
          "13090:   struct vec vec;",
          "13092:   if (ctx) {",
          "13093:    const char *list = ctx->config[ACCESS_CONTROL_LIST];",
          "13096:    allowed = (list == NULL) ? '+' : '-';",
          "13098:    while ((list = next_option(list, &vec, NULL)) != NULL) {",
          "13099:     flag = vec.ptr[0];",
          "13100:     if ((flag != '+' && flag != '-')",
          "13101:         || (parse_net(&vec.ptr[1], &net, &mask) == 0)) {",
          "13102:      mg_cry(fc(ctx),",
          "13103:             \"%s: subnet must be [+|-]x.x.x.x[/x]\",",
          "13104:             __func__);",
          "13105:      return -1;",
          "13106:     }",
          "13108:     if (net == (remote_ip & mask)) {",
          "13109:      allowed = flag;",
          "13110:     }",
          "13113:    return allowed == '+';",
          "13114:   }",
          "13115:   return -1;",
          "13120:  static int set_uid_option(struct mg_context * ctx)",
          "13121:  {",
          "13122:   struct passwd *pw;",
          "13123:   if (ctx) {",
          "13124:    const char *uid = ctx->config[RUN_AS_USER];",
          "13125:    int success = 0;",
          "13127:    if (uid == NULL) {",
          "13129:    } else {",
          "13130:     if ((pw = getpwnam(uid)) == NULL) {",
          "13131:      mg_cry(fc(ctx), \"%s: unknown user [%s]\", __func__, uid);",
          "13132:     } else if (setgid(pw->pw_gid) == -1) {",
          "13133:      mg_cry(fc(ctx),",
          "13134:             \"%s: setgid(%s): %s\",",
          "13135:             __func__,",
          "13136:             uid,",
          "13137:             strerror(errno));",
          "13138:     } else if (setgroups(0, NULL)) {",
          "13139:      mg_cry(fc(ctx),",
          "13140:             \"%s: setgroups(): %s\",",
          "13141:             __func__,",
          "13142:             strerror(errno));",
          "13143:     } else if (setuid(pw->pw_uid) == -1) {",
          "13144:      mg_cry(fc(ctx),",
          "13145:             \"%s: setuid(%s): %s\",",
          "13146:             __func__,",
          "13147:             uid,",
          "13148:             strerror(errno));",
          "13149:     } else {",
          "13150:      success = 1;",
          "13151:     }",
          "13154:    return success;",
          "13155:   }",
          "13156:   return 0;",
          "13161:  static void tls_dtor(void *key)",
          "13162:  {",
          "13163:   struct mg_workerTLS *tls = (struct mg_workerTLS *)key;",
          "13166:   if (tls) {",
          "13167:    if (tls->is_master == 2) {",
          "13169:     mg_free(tls);",
          "13170:    }",
          "13172:   pthread_setspecific(sTlsKey, NULL);",
          "13178:  static int ssl_use_pem_file(struct mg_context * ctx,",
          "13179:                              const char *pem,",
          "13180:                              const char *chain);",
          "13181:  static const char *ssl_error(void);",
          "13184:  static int refresh_trust(struct mg_connection * conn)",
          "13185:  {",
          "13186:   static int reload_lock = 0;",
          "13187:   static long int data_check = 0;",
          "13188:   volatile int *p_reload_lock = (volatile int *)&reload_lock;",
          "13190:   struct stat cert_buf;",
          "13191:   long int t;",
          "13192:   const char *pem;",
          "13193:   const char *chain;",
          "13194:   int should_verify_peer;",
          "13196:   if ((pem = conn->ctx->config[SSL_CERTIFICATE]) == NULL) {",
          "13199:    return 0;",
          "13200:   }",
          "13201:   chain = conn->ctx->config[SSL_CERTIFICATE_CHAIN];",
          "13202:   if (chain == NULL) {",
          "13204:    chain = pem;",
          "13205:   }",
          "13206:   if (*chain == 0) {",
          "13207:    chain = NULL;",
          "13208:   }",
          "13210:   t = data_check;",
          "13211:   if (stat(pem, &cert_buf) != -1) {",
          "13212:    t = (long int)cert_buf.st_mtime;",
          "13213:   }",
          "13215:   if (data_check != t) {",
          "13216:    data_check = t;",
          "13218:    should_verify_peer = 0;",
          "13219:    if (conn->ctx->config[SSL_DO_VERIFY_PEER] != NULL) {",
          "13220:     if (mg_strcasecmp(conn->ctx->config[SSL_DO_VERIFY_PEER], \"yes\")",
          "13221:         == 0) {",
          "13222:      should_verify_peer = 1;",
          "13223:     } else if (mg_strcasecmp(conn->ctx->config[SSL_DO_VERIFY_PEER],",
          "13224:                              \"optional\") == 0) {",
          "13225:      should_verify_peer = 1;",
          "13226:     }",
          "13229:    if (should_verify_peer) {",
          "13230:     char *ca_path = conn->ctx->config[SSL_CA_PATH];",
          "13231:     char *ca_file = conn->ctx->config[SSL_CA_FILE];",
          "13232:     if (SSL_CTX_load_verify_locations(conn->ctx->ssl_ctx,",
          "13233:                                       ca_file,",
          "13234:                                       ca_path) != 1) {",
          "13235:      mg_cry(fc(conn->ctx),",
          "13236:             \"SSL_CTX_load_verify_locations error: %s \"",
          "13237:             \"ssl_verify_peer requires setting \"",
          "13238:             \"either ssl_ca_path or ssl_ca_file. Is any of them \"",
          "13239:             \"present in \"",
          "13240:             \"the .conf file?\",",
          "13241:             ssl_error());",
          "13242:      return 0;",
          "13243:     }",
          "13246:    if (1 == mg_atomic_inc(p_reload_lock)) {",
          "13247:     if (ssl_use_pem_file(conn->ctx, pem, chain) == 0) {",
          "13248:      return 0;",
          "13249:     }",
          "13254:   while (*p_reload_lock) {",
          "13255:    sleep(1);",
          "13256:   }",
          "13258:   return 1;",
          "13259:  }",
          "13266:  static int sslize(struct mg_connection * conn,",
          "13267:                    SSL_CTX * s,",
          "13268:                    int (*func)(SSL *),",
          "13269:                    volatile int *stop_server)",
          "13270:  {",
          "13271:   int ret, err;",
          "13272:   int short_trust;",
          "13273:   unsigned i;",
          "13275:   if (!conn) {",
          "13276:    return 0;",
          "13277:   }",
          "13279:   short_trust =",
          "13280:       (conn->ctx->config[SSL_SHORT_TRUST] != NULL)",
          "13281:       && (mg_strcasecmp(conn->ctx->config[SSL_SHORT_TRUST], \"yes\") == 0);",
          "13283:   if (short_trust) {",
          "13284:    int trust_ret = refresh_trust(conn);",
          "13285:    if (!trust_ret) {",
          "13286:     return trust_ret;",
          "13287:    }",
          "13290:   conn->ssl = SSL_new(s);",
          "13291:   if (conn->ssl == NULL) {",
          "13292:    return 0;",
          "13293:   }",
          "13295:   ret = SSL_set_fd(conn->ssl, conn->client.sock);",
          "13296:   if (ret != 1) {",
          "13297:    err = SSL_get_error(conn->ssl, ret);",
          "13299:    SSL_free(conn->ssl);",
          "13300:    conn->ssl = NULL;",
          "13304:    ERR_remove_state(0);",
          "13306:    return 0;",
          "13307:   }",
          "13312:   for (i = 16; i <= 1024; i *= 2) {",
          "13313:    ret = func(conn->ssl);",
          "13314:    if (ret != 1) {",
          "13315:     err = SSL_get_error(conn->ssl, ret);",
          "13316:     if ((err == SSL_ERROR_WANT_CONNECT)",
          "13317:         || (err == SSL_ERROR_WANT_ACCEPT)",
          "13318:         || (err == SSL_ERROR_WANT_READ)",
          "13319:         || (err == SSL_ERROR_WANT_WRITE)) {",
          "13323:      if (*stop_server) {",
          "13325:       break;",
          "13326:      }",
          "13327:      mg_sleep(i);",
          "13329:     } else if (err == SSL_ERROR_SYSCALL) {",
          "13331:      err = errno;",
          "13333:      (void)err;",
          "13334:      break;",
          "13335:     } else {",
          "13347:   if (ret != 1) {",
          "13348:    SSL_free(conn->ssl);",
          "13349:    conn->ssl = NULL;",
          "13353:    ERR_remove_state(0);",
          "13355:    return 0;",
          "13356:   }",
          "13358:   return 1;",
          "13359:  }",
          "13363:  static const char *ssl_error(void)",
          "13364:  {",
          "13365:   unsigned long err;",
          "13366:   err = ERR_get_error();",
          "13367:   return ((err == 0) ? \"\" : ERR_error_string(err, NULL));",
          "13368:  }",
          "13371:  static int hexdump2string(void *mem, int memlen, char *buf, int buflen)",
          "13372:  {",
          "13373:   int i;",
          "13374:   const char hexdigit[] = \"0123456789abcdef\";",
          "13376:   if ((memlen <= 0) || (buflen <= 0)) {",
          "13377:    return 0;",
          "13378:   }",
          "13379:   if (buflen < (3 * memlen)) {",
          "13380:    return 0;",
          "13381:   }",
          "13383:   for (i = 0; i < memlen; i++) {",
          "13384:    if (i > 0) {",
          "13385:     buf[3 * i - 1] = ' ';",
          "13386:    }",
          "13387:    buf[3 * i] = hexdigit[(((uint8_t *)mem)[i] >> 4) & 0xF];",
          "13388:    buf[3 * i + 1] = hexdigit[((uint8_t *)mem)[i] & 0xF];",
          "13390:   buf[3 * memlen - 1] = 0;",
          "13392:   return 1;",
          "13396:  static void ssl_get_client_cert_info(struct mg_connection * conn)",
          "13397:  {",
          "13398:   X509 *cert = SSL_get_peer_certificate(conn->ssl);",
          "13399:   if (cert) {",
          "13400:    char str_subject[1024];",
          "13401:    char str_issuer[1024];",
          "13402:    char str_finger[1024];",
          "13403:    unsigned char buf[256];",
          "13404:    char *str_serial = NULL;",
          "13405:    unsigned int ulen;",
          "13406:    int ilen;",
          "13407:    unsigned char *tmp_buf;",
          "13408:    unsigned char *tmp_p;",
          "13411:    const EVP_MD *digest = EVP_get_digestbyname(\"sha1\");",
          "13414:    X509_NAME *subj = X509_get_subject_name(cert);",
          "13415:    X509_NAME *iss = X509_get_issuer_name(cert);",
          "13418:    ASN1_INTEGER *serial = X509_get_serialNumber(cert);",
          "13421:    BIGNUM *serial_bn = ASN1_INTEGER_to_BN(serial, NULL);",
          "13422:    str_serial = BN_bn2hex(serial_bn);",
          "13423:    BN_free(serial_bn);",
          "13426:    (void)X509_NAME_oneline(subj,",
          "13427:                            str_subject,",
          "13428:                            (int)sizeof(str_subject));",
          "13429:    (void)X509_NAME_oneline(iss, str_issuer, (int)sizeof(str_issuer));",
          "13432:    ulen = 0;",
          "13436:    ilen = i2d_X509((void *)cert, NULL);",
          "13437:    tmp_buf = (ilen > 0)",
          "13438:                  ? (unsigned char *)mg_malloc_ctx((unsigned)ilen + 1,",
          "13439:                                                   conn->ctx)",
          "13440:                  : NULL;",
          "13441:    if (tmp_buf) {",
          "13442:     tmp_p = tmp_buf;",
          "13443:     (void)i2d_X509((void *)cert, &tmp_p);",
          "13444:     if (!EVP_Digest(",
          "13445:             tmp_buf, (unsigned)ilen, buf, &ulen, digest, NULL)) {",
          "13446:      ulen = 0;",
          "13447:     }",
          "13448:     mg_free(tmp_buf);",
          "13449:    }",
          "13451:    if (!hexdump2string(",
          "13452:            buf, (int)ulen, str_finger, (int)sizeof(str_finger))) {",
          "13454:    }",
          "13456:    conn->request_info.client_cert =",
          "13457:        (struct client_cert *)mg_malloc_ctx(sizeof(struct client_cert),",
          "13458:                                            conn->ctx);",
          "13459:    if (conn->request_info.client_cert) {",
          "13460:     conn->request_info.client_cert->subject =",
          "13461:         mg_strdup(str_subject);",
          "13462:     conn->request_info.client_cert->issuer = mg_strdup(str_issuer);",
          "13463:     conn->request_info.client_cert->serial = mg_strdup(str_serial);",
          "13464:     conn->request_info.client_cert->finger = mg_strdup(str_finger);",
          "13465:    } else {",
          "13466:     mg_cry(conn,",
          "13467:            \"Out of memory: Cannot allocate memory for client \"",
          "13468:            \"certificate\");",
          "13469:    }",
          "13473:    OPENSSL_free(str_serial);",
          "13476:    X509_free(cert);",
          "13477:   }",
          "",
          "---------------",
          "--- Hunk 53 ---",
          "[Context before]",
          "13472: #if !defined(NO_SSL_DL)",
          "13498: #ifdef _WIN32",
          "13501: #else",
          "13521:      mg_snprintf(NULL,",
          "13522:                  &truncated,",
          "13526:                  fp->name);",
          "13530:      }",
          "13531:     }",
          "13532:    }",
          "13537:   }",
          "13555: #if defined(SSL_ALREADY_INITIALIZED)",
          "13557: #else",
          "13559: #endif",
          "13565: #ifdef OPENSSL_API_1_1",
          "13570: #if !defined(NO_SSL_DL)",
          "13573:   if (!cryptolib_dll_handle) {",
          "13575:   }",
          "13584:  int i;",
          "",
          "[Removed Lines]",
          "13473: static void *",
          "13474: load_dll(char *ebuf, size_t ebuf_len, const char *dll_name, struct ssl_func *sw)",
          "13475: {",
          "13476:  union {",
          "13477:   void *p;",
          "13478:   void (*fp)(void);",
          "13479:  } u;",
          "13480:  void *dll_handle;",
          "13481:  struct ssl_func *fp;",
          "13482:  int ok;",
          "13483:  int truncated = 0;",
          "13485:  if ((dll_handle = dlopen(dll_name, RTLD_LAZY)) == NULL) {",
          "13486:   mg_snprintf(NULL,",
          "13488:               ebuf,",
          "13489:               ebuf_len,",
          "13490:               \"%s: cannot load %s\",",
          "13491:               __func__,",
          "13492:               dll_name);",
          "13493:   return NULL;",
          "13494:  }",
          "13496:  ok = 1;",
          "13497:  for (fp = sw; fp->name != NULL; fp++) {",
          "13500:   u.fp = (void (*)(void))dlsym(dll_handle, fp->name);",
          "13505:   u.p = dlsym(dll_handle, fp->name);",
          "13507:   if (u.fp == NULL) {",
          "13508:    if (ok) {",
          "13509:     mg_snprintf(NULL,",
          "13510:                 &truncated,",
          "13511:                 ebuf,",
          "13512:                 ebuf_len,",
          "13513:                 \"%s: %s: cannot find %s\",",
          "13514:                 __func__,",
          "13515:                 dll_name,",
          "13516:                 fp->name);",
          "13517:     ok = 0;",
          "13518:    } else {",
          "13519:     size_t cur_len = strlen(ebuf);",
          "13520:     if (!truncated) {",
          "13523:                  ebuf + cur_len,",
          "13524:                  ebuf_len - cur_len - 3,",
          "13525:                  \", %s\",",
          "13527:      if (truncated) {",
          "13529:       strcat(ebuf, \"...\");",
          "13535:   } else {",
          "13536:    fp->ptr = u.fp;",
          "13538:  }",
          "13540:  if (!ok) {",
          "13541:   (void)dlclose(dll_handle);",
          "13542:   return NULL;",
          "13543:  }",
          "13545:  return dll_handle;",
          "13546: }",
          "13562: static int",
          "13563: initialize_ssl(char *ebuf, size_t ebuf_len)",
          "13564: {",
          "13566:  if (ebuf_len > 0) {",
          "13567:   ebuf[0] = 0;",
          "13568:  }",
          "13571:  if (!cryptolib_dll_handle) {",
          "13572:   cryptolib_dll_handle = load_dll(ebuf, ebuf_len, CRYPTO_LIB, crypto_sw);",
          "13574:    return 0;",
          "13576:  }",
          "13579:  if (mg_atomic_inc(&cryptolib_users) > 1) {",
          "13580:   return 1;",
          "13581:  }",
          "",
          "[Added Lines]",
          "13500:  static void *load_dll(char *ebuf,",
          "13501:                        size_t ebuf_len,",
          "13502:                        const char *dll_name,",
          "13503:                        struct ssl_func *sw)",
          "13504:  {",
          "13505:   union {",
          "13506:    void *p;",
          "13507:    void (*fp)(void);",
          "13508:   } u;",
          "13509:   void *dll_handle;",
          "13510:   struct ssl_func *fp;",
          "13511:   int ok;",
          "13512:   int truncated = 0;",
          "13514:   if ((dll_handle = dlopen(dll_name, RTLD_LAZY)) == NULL) {",
          "13515:    mg_snprintf(NULL,",
          "13517:                ebuf,",
          "13518:                ebuf_len,",
          "13519:                \"%s: cannot load %s\",",
          "13520:                __func__,",
          "13521:                dll_name);",
          "13522:    return NULL;",
          "13523:   }",
          "13525:   ok = 1;",
          "13526:   for (fp = sw; fp->name != NULL; fp++) {",
          "13529:    u.fp = (void (*)(void))dlsym(dll_handle, fp->name);",
          "13534:    u.p = dlsym(dll_handle, fp->name);",
          "13536:    if (u.fp == NULL) {",
          "13537:     if (ok) {",
          "13540:                  ebuf,",
          "13541:                  ebuf_len,",
          "13542:                  \"%s: %s: cannot find %s\",",
          "13543:                  __func__,",
          "13544:                  dll_name,",
          "13546:      ok = 0;",
          "13547:     } else {",
          "13548:      size_t cur_len = strlen(ebuf);",
          "13549:      if (!truncated) {",
          "13550:       mg_snprintf(NULL,",
          "13551:                   &truncated,",
          "13552:                   ebuf + cur_len,",
          "13553:                   ebuf_len - cur_len - 3,",
          "13554:                   \", %s\",",
          "13555:                   fp->name);",
          "13556:       if (truncated) {",
          "13558:        strcat(ebuf, \"...\");",
          "13559:       }",
          "13564:    } else {",
          "13565:     fp->ptr = u.fp;",
          "13569:   if (!ok) {",
          "13570:    (void)dlclose(dll_handle);",
          "13571:    return NULL;",
          "13572:   }",
          "13574:   return dll_handle;",
          "13575:  }",
          "13591:  static int initialize_ssl(char *ebuf, size_t ebuf_len)",
          "13592:  {",
          "13594:   if (ebuf_len > 0) {",
          "13595:    ebuf[0] = 0;",
          "13596:   }",
          "13600:    cryptolib_dll_handle =",
          "13601:        load_dll(ebuf, ebuf_len, CRYPTO_LIB, crypto_sw);",
          "13602:    if (!cryptolib_dll_handle) {",
          "13603:     return 0;",
          "13604:    }",
          "13608:   if (mg_atomic_inc(&cryptolib_users) > 1) {",
          "13609:    return 1;",
          "13610:   }",
          "",
          "---------------",
          "--- Hunk 54 ---",
          "[Context before]",
          "13632:  CRYPTO_set_id_callback(&mg_current_thread_id);",
          "13649:  }",
          "13679:    mg_cry(fc(ctx),",
          "13681:           __func__,",
          "13682:           pem,",
          "13683:           ssl_error());",
          "13684:    return 0;",
          "13685:   }",
          "13686:  }",
          "13691: #ifdef OPENSSL_API_1_1",
          "13706: #else",
          "13707: static long",
          "13708: ssl_get_protocol(int version_id)",
          "",
          "[Removed Lines]",
          "13635:  return 1;",
          "13636: }",
          "13639: static int",
          "13640: ssl_use_pem_file(struct mg_context *ctx, const char *pem, const char *chain)",
          "13641: {",
          "13642:  if (SSL_CTX_use_certificate_file(ctx->ssl_ctx, pem, 1) == 0) {",
          "13643:   mg_cry(fc(ctx),",
          "13644:          \"%s: cannot open certificate file %s: %s\",",
          "13645:          __func__,",
          "13646:          pem,",
          "13647:          ssl_error());",
          "13648:   return 0;",
          "13652:  if (SSL_CTX_use_PrivateKey_file(ctx->ssl_ctx, pem, 1) == 0) {",
          "13653:   mg_cry(fc(ctx),",
          "13654:          \"%s: cannot open private key file %s: %s\",",
          "13655:          __func__,",
          "13656:          pem,",
          "13657:          ssl_error());",
          "13658:   return 0;",
          "13659:  }",
          "13661:  if (SSL_CTX_check_private_key(ctx->ssl_ctx) == 0) {",
          "13662:   mg_cry(fc(ctx),",
          "13663:          \"%s: certificate and private key do not match: %s\",",
          "13664:          __func__,",
          "13665:          pem);",
          "13666:   return 0;",
          "13667:  }",
          "13677:  if (chain) {",
          "13678:   if (SSL_CTX_use_certificate_chain_file(ctx->ssl_ctx, chain) == 0) {",
          "13680:           \"%s: cannot use certificate chain file %s: %s\",",
          "13687:  return 1;",
          "13688: }",
          "13692: static unsigned long",
          "13693: ssl_get_protocol(int version_id)",
          "13694: {",
          "13695:  long unsigned ret = SSL_OP_ALL;",
          "13696:  if (version_id > 0)",
          "13697:   ret |= SSL_OP_NO_SSLv2;",
          "13698:  if (version_id > 1)",
          "13699:   ret |= SSL_OP_NO_SSLv3;",
          "13700:  if (version_id > 2)",
          "13701:   ret |= SSL_OP_NO_TLSv1;",
          "13702:  if (version_id > 3)",
          "13703:   ret |= SSL_OP_NO_TLSv1_1;",
          "13704:  return ret;",
          "13705: }",
          "",
          "[Added Lines]",
          "13664:   return 1;",
          "13668:  static int ssl_use_pem_file(struct mg_context * ctx,",
          "13669:                              const char *pem,",
          "13670:                              const char *chain)",
          "13671:  {",
          "13672:   if (SSL_CTX_use_certificate_file(ctx->ssl_ctx, pem, 1) == 0) {",
          "13673:    mg_cry(fc(ctx),",
          "13674:           \"%s: cannot open certificate file %s: %s\",",
          "13675:           __func__,",
          "13676:           pem,",
          "13677:           ssl_error());",
          "13678:    return 0;",
          "13679:   }",
          "13682:   if (SSL_CTX_use_PrivateKey_file(ctx->ssl_ctx, pem, 1) == 0) {",
          "13684:           \"%s: cannot open private key file %s: %s\",",
          "13691:   if (SSL_CTX_check_private_key(ctx->ssl_ctx) == 0) {",
          "13692:    mg_cry(fc(ctx),",
          "13693:           \"%s: certificate and private key do not match: %s\",",
          "13694:           __func__,",
          "13695:           pem);",
          "13696:    return 0;",
          "13697:   }",
          "13707:   if (chain) {",
          "13708:    if (SSL_CTX_use_certificate_chain_file(ctx->ssl_ctx, chain) == 0) {",
          "13709:     mg_cry(fc(ctx),",
          "13710:            \"%s: cannot use certificate chain file %s: %s\",",
          "13711:            __func__,",
          "13712:            pem,",
          "13713:            ssl_error());",
          "13714:     return 0;",
          "13715:    }",
          "13716:   }",
          "13717:   return 1;",
          "13722:  static unsigned long ssl_get_protocol(int version_id)",
          "13723:  {",
          "13724:   long unsigned ret = SSL_OP_ALL;",
          "13725:   if (version_id > 0)",
          "13726:    ret |= SSL_OP_NO_SSLv2;",
          "13727:   if (version_id > 1)",
          "13728:    ret |= SSL_OP_NO_SSLv3;",
          "13729:   if (version_id > 2)",
          "13730:    ret |= SSL_OP_NO_TLSv1;",
          "13731:   if (version_id > 3)",
          "13732:    ret |= SSL_OP_NO_TLSv1_1;",
          "13733:   return ret;",
          "13734:  }",
          "",
          "---------------",
          "--- Hunk 55 ---",
          "[Context before]",
          "13718:   ret |= SSL_OP_NO_TLSv1_1;",
          "13719:  return ret;",
          "13720: }",
          "13770:    mg_cry(fc(ctx), \"%s\", ebuf);",
          "13771:    return 0;",
          "13772:   }",
          "13776: #ifdef OPENSSL_API_1_1",
          "13787: #else",
          "13789:  SSL_library_init();",
          "",
          "[Removed Lines]",
          "13725: static int",
          "13726: set_ssl_option(struct mg_context *ctx)",
          "13727: {",
          "13728:  const char *pem;",
          "13729:  const char *chain;",
          "13730:  int callback_ret;",
          "13731:  int should_verify_peer;",
          "13732:  int peer_certificate_optional;",
          "13733:  const char *ca_path;",
          "13734:  const char *ca_file;",
          "13735:  int use_default_verify_paths;",
          "13736:  int verify_depth;",
          "13737:  time_t now_rt = time(NULL);",
          "13738:  struct timespec now_mt;",
          "13739:  md5_byte_t ssl_context_id[16];",
          "13740:  md5_state_t md5state;",
          "13741:  int protocol_ver;",
          "13742:  char ebuf[128];",
          "13746:  if (!ctx) {",
          "13747:   return 0;",
          "13748:  }",
          "13749:  if ((pem = ctx->config[SSL_CERTIFICATE]) == NULL",
          "13750:      && ctx->callbacks.init_ssl == NULL) {",
          "13751:   return 1;",
          "13752:  }",
          "13753:  chain = ctx->config[SSL_CERTIFICATE_CHAIN];",
          "13754:  if (chain == NULL) {",
          "13755:   chain = pem;",
          "13756:  }",
          "13757:  if ((chain != NULL) && (*chain == 0)) {",
          "13758:   chain = NULL;",
          "13759:  }",
          "13761:  if (!initialize_ssl(ebuf, sizeof(ebuf))) {",
          "13762:   mg_cry(fc(ctx), \"%s\", ebuf);",
          "13763:   return 0;",
          "13764:  }",
          "13766: #if !defined(NO_SSL_DL)",
          "13767:  if (!ssllib_dll_handle) {",
          "13768:   ssllib_dll_handle = load_dll(ebuf, sizeof(ebuf), SSL_LIB, ssl_sw);",
          "13769:   if (!ssllib_dll_handle) {",
          "13773:  }",
          "13778:  OPENSSL_init_ssl(0, NULL);",
          "13779:  OPENSSL_init_ssl(OPENSSL_INIT_LOAD_SSL_STRINGS",
          "13780:                       | OPENSSL_INIT_LOAD_CRYPTO_STRINGS,",
          "13781:                   NULL);",
          "13783:  if ((ctx->ssl_ctx = SSL_CTX_new(TLS_server_method())) == NULL) {",
          "13784:   mg_cry(fc(ctx), \"SSL_CTX_new (server) error: %s\", ssl_error());",
          "13785:   return 0;",
          "13786:  }",
          "",
          "[Added Lines]",
          "13754:  static int set_ssl_option(struct mg_context * ctx)",
          "13755:  {",
          "13756:   const char *pem;",
          "13757:   const char *chain;",
          "13758:   int callback_ret;",
          "13759:   int should_verify_peer;",
          "13760:   int peer_certificate_optional;",
          "13761:   const char *ca_path;",
          "13762:   const char *ca_file;",
          "13763:   int use_default_verify_paths;",
          "13764:   int verify_depth;",
          "13765:   time_t now_rt = time(NULL);",
          "13766:   struct timespec now_mt;",
          "13767:   md5_byte_t ssl_context_id[16];",
          "13768:   md5_state_t md5state;",
          "13769:   int protocol_ver;",
          "13770:   char ebuf[128];",
          "13774:   if (!ctx) {",
          "13775:    return 0;",
          "13776:   }",
          "13777:   if ((pem = ctx->config[SSL_CERTIFICATE]) == NULL",
          "13778:       && ctx->callbacks.init_ssl == NULL) {",
          "13779:    return 1;",
          "13780:   }",
          "13781:   chain = ctx->config[SSL_CERTIFICATE_CHAIN];",
          "13782:   if (chain == NULL) {",
          "13783:    chain = pem;",
          "13784:   }",
          "13785:   if ((chain != NULL) && (*chain == 0)) {",
          "13786:    chain = NULL;",
          "13787:   }",
          "13789:   if (!initialize_ssl(ebuf, sizeof(ebuf))) {",
          "13794: #if !defined(NO_SSL_DL)",
          "13795:   if (!ssllib_dll_handle) {",
          "13796:    ssllib_dll_handle = load_dll(ebuf, sizeof(ebuf), SSL_LIB, ssl_sw);",
          "13797:    if (!ssllib_dll_handle) {",
          "13798:     mg_cry(fc(ctx), \"%s\", ebuf);",
          "13799:     return 0;",
          "13800:    }",
          "13801:   }",
          "13806:   OPENSSL_init_ssl(0, NULL);",
          "13807:   OPENSSL_init_ssl(OPENSSL_INIT_LOAD_SSL_STRINGS",
          "13808:                        | OPENSSL_INIT_LOAD_CRYPTO_STRINGS,",
          "13809:                    NULL);",
          "13811:   if ((ctx->ssl_ctx = SSL_CTX_new(TLS_server_method())) == NULL) {",
          "13812:    mg_cry(fc(ctx), \"SSL_CTX_new (server) error: %s\", ssl_error());",
          "13813:    return 0;",
          "13814:   }",
          "",
          "---------------",
          "--- Hunk 56 ---",
          "[Context before]",
          "13795:  }",
          "13805: #if !defined(NO_SSL_DL)",
          "13825:   }",
          "13847:   }",
          "13864:   }",
          "13906:   }",
          "13913:   }",
          "13923: #ifdef OPENSSL_API_1_1",
          "13932: #else",
          "13933:  int i;",
          "",
          "[Removed Lines]",
          "13798:  SSL_CTX_clear_options(ctx->ssl_ctx,",
          "13799:                        SSL_OP_NO_SSLv2 | SSL_OP_NO_SSLv3 | SSL_OP_NO_TLSv1",
          "13800:                            | SSL_OP_NO_TLSv1_1);",
          "13801:  protocol_ver = atoi(ctx->config[SSL_PROTOCOL_VERSION]);",
          "13802:  SSL_CTX_set_options(ctx->ssl_ctx, ssl_get_protocol(protocol_ver));",
          "13803:  SSL_CTX_set_options(ctx->ssl_ctx, SSL_OP_SINGLE_DH_USE);",
          "13804:  SSL_CTX_set_options(ctx->ssl_ctx, SSL_OP_CIPHER_SERVER_PREFERENCE);",
          "13806:  SSL_CTX_set_ecdh_auto(ctx->ssl_ctx, 1);",
          "13810:  callback_ret =",
          "13811:      (ctx->callbacks.init_ssl == NULL)",
          "13812:          ? 0",
          "13813:          : (ctx->callbacks.init_ssl(ctx->ssl_ctx, ctx->user_data));",
          "13818:  if (callback_ret < 0) {",
          "13819:   mg_cry(fc(ctx), \"SSL callback returned error: %i\", callback_ret);",
          "13820:   return 0;",
          "13821:  }",
          "13822:  if (callback_ret > 0) {",
          "13823:   if (pem != NULL) {",
          "13824:    (void)SSL_CTX_use_certificate_chain_file(ctx->ssl_ctx, pem);",
          "13826:   return 1;",
          "13827:  }",
          "13830:  md5_init(&md5state);",
          "13831:  md5_append(&md5state, (const md5_byte_t *)&now_rt, sizeof(now_rt));",
          "13832:  clock_gettime(CLOCK_MONOTONIC, &now_mt);",
          "13833:  md5_append(&md5state, (const md5_byte_t *)&now_mt, sizeof(now_mt));",
          "13834:  md5_append(&md5state,",
          "13835:             (const md5_byte_t *)ctx->config[LISTENING_PORTS],",
          "13836:             strlen(ctx->config[LISTENING_PORTS]));",
          "13837:  md5_append(&md5state, (const md5_byte_t *)ctx, sizeof(*ctx));",
          "13838:  md5_finish(&md5state, ssl_context_id);",
          "13840:  SSL_CTX_set_session_id_context(ctx->ssl_ctx,",
          "13841:                                 (const unsigned char *)&ssl_context_id,",
          "13842:                                 sizeof(ssl_context_id));",
          "13844:  if (pem != NULL) {",
          "13845:   if (!ssl_use_pem_file(ctx, pem, chain)) {",
          "13846:    return 0;",
          "13848:  }",
          "13852:  should_verify_peer = 0;",
          "13853:  peer_certificate_optional = 0;",
          "13854:  if (ctx->config[SSL_DO_VERIFY_PEER] != NULL) {",
          "13855:   if (mg_strcasecmp(ctx->config[SSL_DO_VERIFY_PEER], \"yes\") == 0) {",
          "13857:    should_verify_peer = 1;",
          "13858:    peer_certificate_optional = 0;",
          "13859:   } else if (mg_strcasecmp(ctx->config[SSL_DO_VERIFY_PEER], \"optional\")",
          "13860:              == 0) {",
          "13862:    should_verify_peer = 1;",
          "13863:    peer_certificate_optional = 1;",
          "13865:  }",
          "13867:  use_default_verify_paths =",
          "13868:      (ctx->config[SSL_DEFAULT_VERIFY_PATHS] != NULL)",
          "13869:      && (mg_strcasecmp(ctx->config[SSL_DEFAULT_VERIFY_PATHS], \"yes\") == 0);",
          "13871:  if (should_verify_peer) {",
          "13872:   ca_path = ctx->config[SSL_CA_PATH];",
          "13873:   ca_file = ctx->config[SSL_CA_FILE];",
          "13874:   if (SSL_CTX_load_verify_locations(ctx->ssl_ctx, ca_file, ca_path)",
          "13875:       != 1) {",
          "13876:    mg_cry(fc(ctx),",
          "13877:           \"SSL_CTX_load_verify_locations error: %s \"",
          "13878:           \"ssl_verify_peer requires setting \"",
          "13879:           \"either ssl_ca_path or ssl_ca_file. Is any of them \"",
          "13880:           \"present in \"",
          "13881:           \"the .conf file?\",",
          "13882:           ssl_error());",
          "13883:    return 0;",
          "13884:   }",
          "13886:   if (peer_certificate_optional) {",
          "13887:    SSL_CTX_set_verify(ctx->ssl_ctx, SSL_VERIFY_PEER, NULL);",
          "13888:   } else {",
          "13889:    SSL_CTX_set_verify(ctx->ssl_ctx,",
          "13890:                       SSL_VERIFY_PEER",
          "13891:                           | SSL_VERIFY_FAIL_IF_NO_PEER_CERT,",
          "13892:                       NULL);",
          "13893:   }",
          "13895:   if (use_default_verify_paths",
          "13896:       && (SSL_CTX_set_default_verify_paths(ctx->ssl_ctx) != 1)) {",
          "13897:    mg_cry(fc(ctx),",
          "13898:           \"SSL_CTX_set_default_verify_paths error: %s\",",
          "13899:           ssl_error());",
          "13900:    return 0;",
          "13901:   }",
          "13903:   if (ctx->config[SSL_VERIFY_DEPTH]) {",
          "13904:    verify_depth = atoi(ctx->config[SSL_VERIFY_DEPTH]);",
          "13905:    SSL_CTX_set_verify_depth(ctx->ssl_ctx, verify_depth);",
          "13907:  }",
          "13909:  if (ctx->config[SSL_CIPHER_LIST] != NULL) {",
          "13910:   if (SSL_CTX_set_cipher_list(ctx->ssl_ctx, ctx->config[SSL_CIPHER_LIST])",
          "13911:       != 1) {",
          "13912:    mg_cry(fc(ctx), \"SSL_CTX_set_cipher_list error: %s\", ssl_error());",
          "13914:  }",
          "13916:  return 1;",
          "13917: }",
          "13920: static void",
          "13921: uninitialize_ssl(void)",
          "13922: {",
          "13925:  if (mg_atomic_dec(&cryptolib_users) == 0) {",
          "13931:   CONF_modules_unload(1);",
          "",
          "[Added Lines]",
          "13826:   SSL_CTX_clear_options(ctx->ssl_ctx,",
          "13827:                         SSL_OP_NO_SSLv2 | SSL_OP_NO_SSLv3",
          "13828:                             | SSL_OP_NO_TLSv1 | SSL_OP_NO_TLSv1_1);",
          "13829:   protocol_ver = atoi(ctx->config[SSL_PROTOCOL_VERSION]);",
          "13830:   SSL_CTX_set_options(ctx->ssl_ctx, ssl_get_protocol(protocol_ver));",
          "13831:   SSL_CTX_set_options(ctx->ssl_ctx, SSL_OP_SINGLE_DH_USE);",
          "13832:   SSL_CTX_set_options(ctx->ssl_ctx, SSL_OP_CIPHER_SERVER_PREFERENCE);",
          "13834:   SSL_CTX_set_ecdh_auto(ctx->ssl_ctx, 1);",
          "13838:   callback_ret =",
          "13839:       (ctx->callbacks.init_ssl == NULL)",
          "13840:           ? 0",
          "13841:           : (ctx->callbacks.init_ssl(ctx->ssl_ctx, ctx->user_data));",
          "13846:   if (callback_ret < 0) {",
          "13847:    mg_cry(fc(ctx), \"SSL callback returned error: %i\", callback_ret);",
          "13848:    return 0;",
          "13849:   }",
          "13850:   if (callback_ret > 0) {",
          "13851:    if (pem != NULL) {",
          "13852:     (void)SSL_CTX_use_certificate_chain_file(ctx->ssl_ctx, pem);",
          "13853:    }",
          "13854:    return 1;",
          "13858:   md5_init(&md5state);",
          "13859:   md5_append(&md5state, (const md5_byte_t *)&now_rt, sizeof(now_rt));",
          "13860:   clock_gettime(CLOCK_MONOTONIC, &now_mt);",
          "13861:   md5_append(&md5state, (const md5_byte_t *)&now_mt, sizeof(now_mt));",
          "13862:   md5_append(&md5state,",
          "13863:              (const md5_byte_t *)ctx->config[LISTENING_PORTS],",
          "13864:              strlen(ctx->config[LISTENING_PORTS]));",
          "13865:   md5_append(&md5state, (const md5_byte_t *)ctx, sizeof(*ctx));",
          "13866:   md5_finish(&md5state, ssl_context_id);",
          "13868:   SSL_CTX_set_session_id_context(ctx->ssl_ctx,",
          "13869:                                  (const unsigned char *)&ssl_context_id,",
          "13870:                                  sizeof(ssl_context_id));",
          "13872:   if (pem != NULL) {",
          "13873:    if (!ssl_use_pem_file(ctx, pem, chain)) {",
          "13874:     return 0;",
          "13875:    }",
          "13880:   should_verify_peer = 0;",
          "13881:   peer_certificate_optional = 0;",
          "13882:   if (ctx->config[SSL_DO_VERIFY_PEER] != NULL) {",
          "13883:    if (mg_strcasecmp(ctx->config[SSL_DO_VERIFY_PEER], \"yes\") == 0) {",
          "13885:     should_verify_peer = 1;",
          "13886:     peer_certificate_optional = 0;",
          "13887:    } else if (mg_strcasecmp(ctx->config[SSL_DO_VERIFY_PEER],",
          "13888:                             \"optional\") == 0) {",
          "13890:     should_verify_peer = 1;",
          "13891:     peer_certificate_optional = 1;",
          "13892:    }",
          "13895:   use_default_verify_paths =",
          "13896:       (ctx->config[SSL_DEFAULT_VERIFY_PATHS] != NULL)",
          "13897:       && (mg_strcasecmp(ctx->config[SSL_DEFAULT_VERIFY_PATHS], \"yes\")",
          "13898:           == 0);",
          "13900:   if (should_verify_peer) {",
          "13901:    ca_path = ctx->config[SSL_CA_PATH];",
          "13902:    ca_file = ctx->config[SSL_CA_FILE];",
          "13903:    if (SSL_CTX_load_verify_locations(ctx->ssl_ctx, ca_file, ca_path)",
          "13904:        != 1) {",
          "13905:     mg_cry(fc(ctx),",
          "13906:            \"SSL_CTX_load_verify_locations error: %s \"",
          "13907:            \"ssl_verify_peer requires setting \"",
          "13908:            \"either ssl_ca_path or ssl_ca_file. Is any of them \"",
          "13909:            \"present in \"",
          "13910:            \"the .conf file?\",",
          "13911:            ssl_error());",
          "13912:     return 0;",
          "13913:    }",
          "13915:    if (peer_certificate_optional) {",
          "13916:     SSL_CTX_set_verify(ctx->ssl_ctx, SSL_VERIFY_PEER, NULL);",
          "13917:    } else {",
          "13918:     SSL_CTX_set_verify(ctx->ssl_ctx,",
          "13919:                        SSL_VERIFY_PEER",
          "13920:                            | SSL_VERIFY_FAIL_IF_NO_PEER_CERT,",
          "13921:                        NULL);",
          "13922:    }",
          "13924:    if (use_default_verify_paths",
          "13925:        && (SSL_CTX_set_default_verify_paths(ctx->ssl_ctx) != 1)) {",
          "13926:     mg_cry(fc(ctx),",
          "13927:            \"SSL_CTX_set_default_verify_paths error: %s\",",
          "13928:            ssl_error());",
          "13929:     return 0;",
          "13930:    }",
          "13932:    if (ctx->config[SSL_VERIFY_DEPTH]) {",
          "13933:     verify_depth = atoi(ctx->config[SSL_VERIFY_DEPTH]);",
          "13934:     SSL_CTX_set_verify_depth(ctx->ssl_ctx, verify_depth);",
          "13935:    }",
          "13938:   if (ctx->config[SSL_CIPHER_LIST] != NULL) {",
          "13939:    if (SSL_CTX_set_cipher_list(ctx->ssl_ctx,",
          "13940:                                ctx->config[SSL_CIPHER_LIST]) != 1) {",
          "13941:     mg_cry(fc(ctx),",
          "13942:            \"SSL_CTX_set_cipher_list error: %s\",",
          "13943:            ssl_error());",
          "13944:    }",
          "13947:   return 1;",
          "13948:  }",
          "13951:  static void uninitialize_ssl(void)",
          "13952:  {",
          "13955:   if (mg_atomic_dec(&cryptolib_users) == 0) {",
          "13961:    CONF_modules_unload(1);",
          "",
          "---------------",
          "--- Hunk 57 ---",
          "[Context before]",
          "13953:   mg_free(ssl_mutexes);",
          "13954:   ssl_mutexes = NULL;",
          "13956:  }",
          "13970:   }",
          "13972:  }",
          "14013: #if defined(MG_LEGACY_INTERFACE)",
          "14016: #endif",
          "14020: #if 0",
          "",
          "[Removed Lines]",
          "13957: }",
          "13961: static int",
          "13962: set_gpass_option(struct mg_context *ctx)",
          "13963: {",
          "13964:  if (ctx) {",
          "13965:   struct mg_file file = STRUCT_FILE_INITIALIZER;",
          "13966:   const char *path = ctx->config[GLOBAL_PASSWORDS_FILE];",
          "13967:   if ((path != NULL) && !mg_stat(fc(ctx), path, &file.stat)) {",
          "13968:    mg_cry(fc(ctx), \"Cannot open %s: %s\", path, strerror(ERRNO));",
          "13969:    return 0;",
          "13971:   return 1;",
          "13973:  return 0;",
          "13974: }",
          "13977: static int",
          "13978: set_acl_option(struct mg_context *ctx)",
          "13979: {",
          "13980:  return check_acl(ctx, (uint32_t)0x7f000001UL) != -1;",
          "13981: }",
          "13984: static void",
          "13985: reset_per_request_attributes(struct mg_connection *conn)",
          "13986: {",
          "13987:  if (!conn) {",
          "13988:   return;",
          "13989:  }",
          "13992:  conn->path_info = NULL;",
          "13993:  conn->num_bytes_sent = conn->consumed_content = 0;",
          "13994:  conn->status_code = -1;",
          "13995:  conn->is_chunked = 0;",
          "13996:  conn->must_close = 0;",
          "13997:  conn->request_len = 0;",
          "13998:  conn->throttle = 0;",
          "13999:  conn->data_len = 0;",
          "14000:  conn->chunk_remainder = 0;",
          "14002:  conn->response_info.content_length = conn->request_info.content_length = -1;",
          "14003:  conn->response_info.http_version = conn->request_info.http_version = NULL;",
          "14004:  conn->response_info.num_headers = conn->request_info.num_headers = 0;",
          "14005:  conn->response_info.status_text = NULL;",
          "14006:  conn->response_info.status_code = 0;",
          "14008:  conn->request_info.remote_user = NULL;",
          "14009:  conn->request_info.request_method = NULL;",
          "14010:  conn->request_info.request_uri = NULL;",
          "14011:  conn->request_info.local_uri = NULL;",
          "14015:  conn->request_info.uri = NULL;",
          "14017: }",
          "",
          "[Added Lines]",
          "13986:   }",
          "13991:  static int set_gpass_option(struct mg_context * ctx)",
          "13992:  {",
          "13993:   if (ctx) {",
          "13994:    struct mg_file file = STRUCT_FILE_INITIALIZER;",
          "13995:    const char *path = ctx->config[GLOBAL_PASSWORDS_FILE];",
          "13996:    if ((path != NULL) && !mg_stat(fc(ctx), path, &file.stat)) {",
          "13997:     mg_cry(fc(ctx), \"Cannot open %s: %s\", path, strerror(ERRNO));",
          "13998:     return 0;",
          "13999:    }",
          "14000:    return 1;",
          "14002:   return 0;",
          "14006:  static int set_acl_option(struct mg_context * ctx)",
          "14007:  {",
          "14008:   return check_acl(ctx, (uint32_t)0x7f000001UL) != -1;",
          "14009:  }",
          "14012:  static void reset_per_request_attributes(struct mg_connection * conn)",
          "14013:  {",
          "14014:   if (!conn) {",
          "14015:    return;",
          "14016:   }",
          "14019:   conn->path_info = NULL;",
          "14020:   conn->num_bytes_sent = conn->consumed_content = 0;",
          "14021:   conn->status_code = -1;",
          "14022:   conn->is_chunked = 0;",
          "14023:   conn->must_close = 0;",
          "14024:   conn->request_len = 0;",
          "14025:   conn->throttle = 0;",
          "14026:   conn->data_len = 0;",
          "14027:   conn->chunk_remainder = 0;",
          "14029:   conn->response_info.content_length = conn->request_info.content_length =",
          "14030:       -1;",
          "14031:   conn->response_info.http_version = conn->request_info.http_version =",
          "14032:       NULL;",
          "14033:   conn->response_info.num_headers = conn->request_info.num_headers = 0;",
          "14034:   conn->response_info.status_text = NULL;",
          "14035:   conn->response_info.status_code = 0;",
          "14037:   conn->request_info.remote_user = NULL;",
          "14038:   conn->request_info.request_method = NULL;",
          "14039:   conn->request_info.request_uri = NULL;",
          "14040:   conn->request_info.local_uri = NULL;",
          "14044:   conn->request_info.uri = NULL;",
          "14046:  }",
          "",
          "---------------",
          "--- Hunk 58 ---",
          "[Context before]",
          "14066: #endif",
          "14079:  }",
          "14088: #if defined(_WIN32)",
          "14091: #endif",
          "14110: #if defined(_WIN32)",
          "14131: #if defined(_MSC_VER)",
          "14132: #pragma warning(push)",
          "14133: #pragma warning(disable : 4244)",
          "14134: #endif",
          "14136: #if defined(_MSC_VER)",
          "14137: #pragma warning(pop)",
          "14138: #endif",
          "14168:    mg_cry(conn,",
          "14170:           __func__,",
          "14173:           strerror(ERRNO));",
          "14174:   }",
          "14190: #if defined(USE_LUA) && defined(USE_WEBSOCKET)",
          "14195: #endif",
          "14212: #ifndef NO_SSL",
          "14220: #ifndef OPENSSL_API_1_1",
          "14222: #endif",
          "14225: #endif",
          "14238: #if defined(USE_WEBSOCKET)",
          "14246: #if defined(USE_WEBSOCKET)",
          "14264:    }",
          "14265:   }",
          "14271: #ifndef NO_SSL",
          "14275: #endif",
          "14277: #if defined(USE_WEBSOCKET)",
          "14287: #else",
          "14289:   mg_free(conn);",
          "14290:  }",
          "14333: #ifndef NO_SSL",
          "14334: #ifdef OPENSSL_API_1_1",
          "14346: #else",
          "14347:  if (use_ssl",
          "14348:      && (conn->client_ssl_ctx = SSL_CTX_new(SSLv23_client_method()))",
          "",
          "[Removed Lines]",
          "14069: static int",
          "14070: set_tcp_nodelay(SOCKET sock, int nodelay_on)",
          "14071: {",
          "14072:  if (setsockopt(sock,",
          "14073:                 IPPROTO_TCP,",
          "14074:                 TCP_NODELAY,",
          "14075:                 (SOCK_OPT_TYPE)&nodelay_on,",
          "14076:                 sizeof(nodelay_on)) != 0) {",
          "14078:   return 1;",
          "14081:  return 0;",
          "14082: }",
          "14085: static void",
          "14086: close_socket_gracefully(struct mg_connection *conn)",
          "14087: {",
          "14089:  char buf[MG_BUF_LEN];",
          "14090:  int n;",
          "14092:  struct linger linger;",
          "14093:  int error_code = 0;",
          "14094:  int linger_timeout = -2;",
          "14095:  socklen_t opt_len = sizeof(error_code);",
          "14097:  if (!conn) {",
          "14098:   return;",
          "14099:  }",
          "14104:  set_blocking_mode(conn->client.sock, 1);",
          "14107:  shutdown(conn->client.sock, SHUTDOWN_WR);",
          "14117:  do {",
          "14118:   n = pull_inner(NULL, conn, buf, sizeof(buf), /* Timeout in s: */ 1.0);",
          "14119:  } while (n > 0);",
          "14120: #endif",
          "14122:  if (conn->ctx->config[LINGER_TIMEOUT]) {",
          "14123:   linger_timeout = atoi(conn->ctx->config[LINGER_TIMEOUT]);",
          "14124:  }",
          "14127:  if (linger_timeout >= 0) {",
          "14130:   linger.l_onoff = 1;",
          "14135:   linger.l_linger = (linger_timeout + 999) / 1000;",
          "14139:  } else {",
          "14140:   linger.l_onoff = 0;",
          "14141:   linger.l_linger = 0;",
          "14142:  }",
          "14144:  if (linger_timeout < -1) {",
          "14146:  } else if (getsockopt(conn->client.sock,",
          "14147:                        SOL_SOCKET,",
          "14148:                        SO_ERROR,",
          "14149:                        (char *)&error_code,",
          "14150:                        &opt_len) != 0) {",
          "14154:   mg_cry(conn,",
          "14155:          \"%s: getsockopt(SOL_SOCKET SO_ERROR) failed: %s\",",
          "14156:          __func__,",
          "14157:          strerror(ERRNO));",
          "14158:  } else if (error_code == ECONNRESET) {",
          "14160:  } else {",
          "14163:   if (setsockopt(conn->client.sock,",
          "14164:                  SOL_SOCKET,",
          "14165:                  SO_LINGER,",
          "14166:                  (char *)&linger,",
          "14167:                  sizeof(linger)) != 0) {",
          "14169:           \"%s: setsockopt(SOL_SOCKET SO_LINGER(%i,%i)) failed: %s\",",
          "14171:           linger.l_onoff,",
          "14172:           linger.l_linger,",
          "14175:  }",
          "14178:  closesocket(conn->client.sock);",
          "14179:  conn->client.sock = INVALID_SOCKET;",
          "14180: }",
          "14183: static void",
          "14184: close_connection(struct mg_connection *conn)",
          "14185: {",
          "14186:  if (!conn || !conn->ctx) {",
          "14187:   return;",
          "14188:  }",
          "14191:  if (conn->lua_websocket_state) {",
          "14192:   lua_websocket_close(conn, conn->lua_websocket_state);",
          "14193:   conn->lua_websocket_state = NULL;",
          "14194:  }",
          "14198:  if ((conn->ctx->callbacks.connection_close != NULL)",
          "14199:      && (conn->ctx->context_type == 1)) {",
          "14200:   conn->ctx->callbacks.connection_close(conn);",
          "14201:  }",
          "14206:  mg_set_user_connection_data(conn, NULL);",
          "14208:  mg_lock_connection(conn);",
          "14210:  conn->must_close = 1;",
          "14213:  if (conn->ssl != NULL) {",
          "14216:   SSL_shutdown(conn->ssl);",
          "14217:   SSL_free(conn->ssl);",
          "14221:   ERR_remove_state(0);",
          "14223:   conn->ssl = NULL;",
          "14224:  }",
          "14226:  if (conn->client.sock != INVALID_SOCKET) {",
          "14227:   close_socket_gracefully(conn);",
          "14228:   conn->client.sock = INVALID_SOCKET;",
          "14229:  }",
          "14231:  mg_unlock_connection(conn);",
          "14232: }",
          "14235: void",
          "14236: mg_close_connection(struct mg_connection *conn)",
          "14237: {",
          "14239:  struct mg_context *client_ctx = NULL;",
          "14242:  if (conn == NULL) {",
          "14243:   return;",
          "14244:  }",
          "14247:  if (conn->ctx->context_type == 2) {",
          "14248:   unsigned int i;",
          "14251:   client_ctx = conn->ctx;",
          "14254:   conn->ctx->stop_flag = 1;",
          "14261:   for (i = 0; i < client_ctx->cfg_worker_threads; i++) {",
          "14262:    if (client_ctx->worker_threadids[i] != 0) {",
          "14263:     mg_join_thread(client_ctx->worker_threadids[i]);",
          "14266:  }",
          "14269:  close_connection(conn);",
          "14272:  if (conn->client_ssl_ctx != NULL) {",
          "14273:   SSL_CTX_free((SSL_CTX *)conn->client_ssl_ctx);",
          "14274:  }",
          "14278:  if (client_ctx != NULL) {",
          "14280:   mg_free(client_ctx->worker_threadids);",
          "14281:   mg_free(client_ctx);",
          "14282:   (void)pthread_mutex_destroy(&conn->mutex);",
          "14283:   mg_free(conn);",
          "14285:   mg_free(conn);",
          "14286:  }",
          "14292: }",
          "14295: static struct mg_context common_client_context;",
          "14298: static struct mg_connection *",
          "14299: mg_connect_client_impl(const struct mg_client_options *client_options,",
          "14300:                        int use_ssl,",
          "14301:                        char *ebuf,",
          "14302:                        size_t ebuf_len)",
          "14303: {",
          "14304:  struct mg_connection *conn = NULL;",
          "14305:  SOCKET sock;",
          "14306:  union usa sa;",
          "14307:  unsigned max_req_size =",
          "14308:      (unsigned)atoi(config_options[MAX_REQUEST_SIZE].default_value);",
          "14310:  if (!connect_socket(&common_client_context,",
          "14311:                      client_options->host,",
          "14312:                      client_options->port,",
          "14313:                      use_ssl,",
          "14314:                      ebuf,",
          "14315:                      ebuf_len,",
          "14316:                      &sock,",
          "14317:                      &sa)) {",
          "14318:   return NULL;",
          "14319:  }",
          "14320:  if ((conn = (struct mg_connection *)mg_calloc_ctx(",
          "14321:           1, sizeof(*conn) + max_req_size, &common_client_context))",
          "14322:      == NULL) {",
          "14323:   mg_snprintf(NULL,",
          "14325:               ebuf,",
          "14326:               ebuf_len,",
          "14327:               \"calloc(): %s\",",
          "14328:               strerror(ERRNO));",
          "14329:   closesocket(sock);",
          "14330:   return NULL;",
          "14331:  }",
          "14335:  if (use_ssl",
          "14336:      && (conn->client_ssl_ctx = SSL_CTX_new(TLS_client_method())) == NULL) {",
          "14337:   mg_snprintf(NULL,",
          "14339:               ebuf,",
          "14340:               ebuf_len,",
          "14341:               \"SSL_CTX_new error\");",
          "14342:   closesocket(sock);",
          "14343:   mg_free(conn);",
          "14344:   return NULL;",
          "14345:  }",
          "",
          "[Added Lines]",
          "14098:  static int set_tcp_nodelay(SOCKET sock, int nodelay_on)",
          "14099:  {",
          "14100:   if (setsockopt(sock,",
          "14101:                  IPPROTO_TCP,",
          "14102:                  TCP_NODELAY,",
          "14103:                  (SOCK_OPT_TYPE)&nodelay_on,",
          "14104:                  sizeof(nodelay_on)) != 0) {",
          "14106:    return 1;",
          "14107:   }",
          "14109:   return 0;",
          "14113:  static void close_socket_gracefully(struct mg_connection * conn)",
          "14114:  {",
          "14116:   char buf[MG_BUF_LEN];",
          "14117:   int n;",
          "14119:   struct linger linger;",
          "14120:   int error_code = 0;",
          "14121:   int linger_timeout = -2;",
          "14122:   socklen_t opt_len = sizeof(error_code);",
          "14124:   if (!conn) {",
          "14125:    return;",
          "14126:   }",
          "14131:   set_blocking_mode(conn->client.sock, 1);",
          "14134:   shutdown(conn->client.sock, SHUTDOWN_WR);",
          "14144:   do {",
          "14145:    n = pull_inner(",
          "14146:        NULL, conn, buf, sizeof(buf), /* Timeout in s: */ 1.0);",
          "14147:   } while (n > 0);",
          "14148: #endif",
          "14150:   if (conn->ctx->config[LINGER_TIMEOUT]) {",
          "14151:    linger_timeout = atoi(conn->ctx->config[LINGER_TIMEOUT]);",
          "14152:   }",
          "14155:   if (linger_timeout >= 0) {",
          "14158:    linger.l_onoff = 1;",
          "14163:    linger.l_linger = (linger_timeout + 999) / 1000;",
          "14167:   } else {",
          "14168:    linger.l_onoff = 0;",
          "14169:    linger.l_linger = 0;",
          "14170:   }",
          "14172:   if (linger_timeout < -1) {",
          "14174:   } else if (getsockopt(conn->client.sock,",
          "14175:                         SOL_SOCKET,",
          "14176:                         SO_ERROR,",
          "14177:                         (char *)&error_code,",
          "14178:                         &opt_len) != 0) {",
          "14183:           \"%s: getsockopt(SOL_SOCKET SO_ERROR) failed: %s\",",
          "14186:   } else if (error_code == ECONNRESET) {",
          "14189:   } else {",
          "14192:    if (setsockopt(conn->client.sock,",
          "14193:                   SOL_SOCKET,",
          "14194:                   SO_LINGER,",
          "14195:                   (char *)&linger,",
          "14196:                   sizeof(linger)) != 0) {",
          "14197:     mg_cry(conn,",
          "14198:            \"%s: setsockopt(SOL_SOCKET SO_LINGER(%i,%i)) failed: %s\",",
          "14199:            __func__,",
          "14200:            linger.l_onoff,",
          "14201:            linger.l_linger,",
          "14202:            strerror(ERRNO));",
          "14203:    }",
          "14207:   closesocket(conn->client.sock);",
          "14208:   conn->client.sock = INVALID_SOCKET;",
          "14209:  }",
          "14212:  static void close_connection(struct mg_connection * conn)",
          "14213:  {",
          "14214:   if (!conn || !conn->ctx) {",
          "14215:    return;",
          "14216:   }",
          "14219:   if (conn->lua_websocket_state) {",
          "14220:    lua_websocket_close(conn, conn->lua_websocket_state);",
          "14221:    conn->lua_websocket_state = NULL;",
          "14222:   }",
          "14226:   if ((conn->ctx->callbacks.connection_close != NULL)",
          "14227:       && (conn->ctx->context_type == 1)) {",
          "14228:    conn->ctx->callbacks.connection_close(conn);",
          "14229:   }",
          "14234:   mg_set_user_connection_data(conn, NULL);",
          "14236:   mg_lock_connection(conn);",
          "14238:   conn->must_close = 1;",
          "14241:   if (conn->ssl != NULL) {",
          "14244:    SSL_shutdown(conn->ssl);",
          "14245:    SSL_free(conn->ssl);",
          "14249:    ERR_remove_state(0);",
          "14251:    conn->ssl = NULL;",
          "14252:   }",
          "14254:   if (conn->client.sock != INVALID_SOCKET) {",
          "14255:    close_socket_gracefully(conn);",
          "14256:    conn->client.sock = INVALID_SOCKET;",
          "14257:   }",
          "14259:   mg_unlock_connection(conn);",
          "14260:  }",
          "14263:  void mg_close_connection(struct mg_connection * conn)",
          "14264:  {",
          "14266:   struct mg_context *client_ctx = NULL;",
          "14269:   if (conn == NULL) {",
          "14270:    return;",
          "14271:   }",
          "14274:   if (conn->ctx->context_type == 2) {",
          "14275:    unsigned int i;",
          "14278:    client_ctx = conn->ctx;",
          "14281:    conn->ctx->stop_flag = 1;",
          "14289:    for (i = 0; i < client_ctx->cfg_worker_threads; i++) {",
          "14290:     if (client_ctx->worker_threadids[i] != 0) {",
          "14291:      mg_join_thread(client_ctx->worker_threadids[i]);",
          "14292:     }",
          "14297:   close_connection(conn);",
          "14300:   if (conn->client_ssl_ctx != NULL) {",
          "14301:    SSL_CTX_free((SSL_CTX *)conn->client_ssl_ctx);",
          "14302:   }",
          "14306:   if (client_ctx != NULL) {",
          "14308:    mg_free(client_ctx->worker_threadids);",
          "14309:    mg_free(client_ctx);",
          "14310:    (void)pthread_mutex_destroy(&conn->mutex);",
          "14311:    mg_free(conn);",
          "14313:    mg_free(conn);",
          "14314:   }",
          "14320:  }",
          "14323:  static struct mg_context common_client_context;",
          "14326:  static struct mg_connection *mg_connect_client_impl(",
          "14327:      const struct mg_client_options *client_options,",
          "14328:      int use_ssl,",
          "14329:      char *ebuf,",
          "14330:      size_t ebuf_len)",
          "14331:  {",
          "14332:   struct mg_connection *conn = NULL;",
          "14333:   SOCKET sock;",
          "14334:   union usa sa;",
          "14335:   unsigned max_req_size =",
          "14336:       (unsigned)atoi(config_options[MAX_REQUEST_SIZE].default_value);",
          "14338:   if (!connect_socket(&common_client_context,",
          "14339:                       client_options->host,",
          "14340:                       client_options->port,",
          "14341:                       use_ssl,",
          "14342:                       ebuf,",
          "14343:                       ebuf_len,",
          "14344:                       &sock,",
          "14345:                       &sa)) {",
          "14346:    return NULL;",
          "14347:   }",
          "14348:   if ((conn = (struct mg_connection *)mg_calloc_ctx(",
          "14349:            1, sizeof(*conn) + max_req_size, &common_client_context))",
          "14350:       == NULL) {",
          "14351:    mg_snprintf(NULL,",
          "14353:                ebuf,",
          "14354:                ebuf_len,",
          "14355:                \"calloc(): %s\",",
          "14356:                strerror(ERRNO));",
          "14357:    closesocket(sock);",
          "14358:    return NULL;",
          "14359:   }",
          "14363:   if (use_ssl",
          "14364:       && (conn->client_ssl_ctx = SSL_CTX_new(TLS_client_method()))",
          "14365:              == NULL) {",
          "14366:    mg_snprintf(NULL,",
          "14368:                ebuf,",
          "14369:                ebuf_len,",
          "14370:                \"SSL_CTX_new error\");",
          "14371:    closesocket(sock);",
          "14372:    mg_free(conn);",
          "14373:    return NULL;",
          "14374:   }",
          "",
          "---------------",
          "--- Hunk 59 ---",
          "[Context before]",
          "14363: #ifdef USE_IPV6",
          "14370: #else",
          "14371:  socklen_t len = sizeof(conn->client.rsa.sin);",
          "14372:  struct sockaddr *psa = (struct sockaddr *)&(conn->client.rsa.sin);",
          "14373: #endif",
          "14403:     mg_snprintf(NULL,",
          "14405:                 ebuf,",
          "14406:                 ebuf_len,",
          "14408:     SSL_CTX_free(conn->client_ssl_ctx);",
          "14409:     closesocket(sock);",
          "14410:     mg_free(conn);",
          "14411:     return NULL;",
          "14412:    }",
          "14413:   }",
          "14439: #endif",
          "14509:  }",
          "14548:  }",
          "14561:     return 0;",
          "14562:    }",
          "14570:     return 0;",
          "14571:    }",
          "14574:   }",
          "14628:     port = strtoul(portbegin + 1, &portend, 10);",
          "14629:     if ((portend != hostend) || (port <= 0)",
          "14630:         || !is_valid_port(port)) {",
          "14631:      return 0;",
          "14632:     }",
          "14634:    }",
          "14637:   }",
          "14642:   return 0;",
          "14643:  }",
          "14651:    return 0;",
          "14652:   }",
          "14658:    return 0;",
          "14659:   }",
          "14682:    }",
          "14687:     return 0;",
          "14688:    }",
          "14694:     return 0;",
          "14695:    }",
          "14696:   }",
          "14708:  }",
          "14755:    mg_snprintf(conn,",
          "14757:                ebuf,",
          "14758:                ebuf_len,",
          "14759:                \"%s\",",
          "14765:    mg_snprintf(conn,",
          "14767:                ebuf,",
          "14768:                ebuf_len,",
          "14769:                \"%s\",",
          "14772:   }",
          "14785:  }",
          "14807:    mg_snprintf(conn,",
          "14809:                ebuf,",
          "14810:                ebuf_len,",
          "14811:                \"%s\",",
          "14812:                \"Bad request\");",
          "14814:    return 0;",
          "14815:   }",
          "14833:  }",
          "14859:  }",
          "14869:    mg_snprintf(conn,",
          "14871:                ebuf,",
          "14872:                ebuf_len,",
          "14873:                \"%s\",",
          "14877:   }",
          "14939: #if defined(MG_LEGACY_INTERFACE)",
          "14943: #endif",
          "14987: #if defined(MG_LEGACY_INTERFACE)",
          "14991: #endif",
          "14993:   }",
          "15015: #if defined(USE_WEBSOCKET)",
          "15016: #ifdef _WIN32",
          "15018: #else",
          "15019: static void *",
          "15020: websocket_client_thread(void *data)",
          "15021: #endif",
          "15033:   }",
          "15050: #ifdef _WIN32",
          "15052: #else",
          "15053:  return NULL;",
          "15054: #endif",
          "15056: #endif",
          "15073: #if defined(USE_WEBSOCKET)",
          "15135:   }",
          "15176: #else",
          "",
          "[Removed Lines]",
          "14364:  socklen_t len = (sa.sa.sa_family == AF_INET)",
          "14365:                      ? sizeof(conn->client.rsa.sin)",
          "14366:                      : sizeof(conn->client.rsa.sin6);",
          "14367:  struct sockaddr *psa = (sa.sa.sa_family == AF_INET)",
          "14368:                             ? (struct sockaddr *)&(conn->client.rsa.sin)",
          "14369:                             : (struct sockaddr *)&(conn->client.rsa.sin6);",
          "14375:  conn->buf_size = (int)max_req_size;",
          "14376:  conn->buf = (char *)(conn + 1);",
          "14377:  conn->ctx = &common_client_context;",
          "14378:  conn->client.sock = sock;",
          "14379:  conn->client.lsa = sa;",
          "14381:  if (getsockname(sock, psa, &len) != 0) {",
          "14382:   mg_cry(conn, \"%s: getsockname() failed: %s\", __func__, strerror(ERRNO));",
          "14383:  }",
          "14385:  conn->client.is_ssl = use_ssl ? 1 : 0;",
          "14386:  (void)pthread_mutex_init(&conn->mutex, &pthread_mutex_attr);",
          "14388: #ifndef NO_SSL",
          "14389:  if (use_ssl) {",
          "14390:   common_client_context.ssl_ctx = conn->client_ssl_ctx;",
          "14399:   if (client_options->client_cert) {",
          "14400:    if (!ssl_use_pem_file(&common_client_context,",
          "14401:                          client_options->client_cert,",
          "14402:                          NULL)) {",
          "14407:                 \"Can not use SSL client certificate\");",
          "14415:   if (client_options->server_cert) {",
          "14416:    SSL_CTX_load_verify_locations(conn->client_ssl_ctx,",
          "14417:                                  client_options->server_cert,",
          "14418:                                  NULL);",
          "14419:    SSL_CTX_set_verify(conn->client_ssl_ctx, SSL_VERIFY_PEER, NULL);",
          "14420:   } else {",
          "14421:    SSL_CTX_set_verify(conn->client_ssl_ctx, SSL_VERIFY_NONE, NULL);",
          "14422:   }",
          "14424:   if (!sslize(conn,",
          "14425:               conn->client_ssl_ctx,",
          "14426:               SSL_connect,",
          "14427:               &(conn->ctx->stop_flag))) {",
          "14428:    mg_snprintf(NULL,",
          "14430:                ebuf,",
          "14431:                ebuf_len,",
          "14432:                \"SSL connection error\");",
          "14433:    SSL_CTX_free(conn->client_ssl_ctx);",
          "14434:    closesocket(sock);",
          "14435:    mg_free(conn);",
          "14436:    return NULL;",
          "14437:   }",
          "14438:  }",
          "14441:  set_blocking_mode(sock, 0);",
          "14443:  return conn;",
          "14444: }",
          "14447: CIVETWEB_API struct mg_connection *",
          "14448: mg_connect_client_secure(const struct mg_client_options *client_options,",
          "14449:                          char *error_buffer,",
          "14450:                          size_t error_buffer_size)",
          "14451: {",
          "14452:  return mg_connect_client_impl(client_options,",
          "14453:                                1,",
          "14454:                                error_buffer,",
          "14455:                                error_buffer_size);",
          "14456: }",
          "14459: struct mg_connection *",
          "14460: mg_connect_client(const char *host,",
          "14461:                   int port,",
          "14462:                   int use_ssl,",
          "14463:                   char *error_buffer,",
          "14464:                   size_t error_buffer_size)",
          "14465: {",
          "14466:  struct mg_client_options opts;",
          "14467:  memset(&opts, 0, sizeof(opts));",
          "14468:  opts.host = host;",
          "14469:  opts.port = port;",
          "14470:  return mg_connect_client_impl(&opts,",
          "14471:                                use_ssl,",
          "14472:                                error_buffer,",
          "14473:                                error_buffer_size);",
          "14474: }",
          "14477: static const struct {",
          "14478:  const char *proto;",
          "14479:  size_t proto_len;",
          "14480:  unsigned default_port;",
          "14481: } abs_uri_protocols[] = {{\"http://\", 7, 80},",
          "14482:                          {\"https://\", 8, 443},",
          "14483:                          {\"ws://\", 5, 80},",
          "14484:                          {\"wss://\", 6, 443},",
          "14485:                          {NULL, 0, 0}};",
          "14494: static int",
          "14495: get_uri_type(const char *uri)",
          "14496: {",
          "14497:  int i;",
          "14498:  const char *hostend, *portbegin;",
          "14499:  char *portend;",
          "14500:  unsigned long port;",
          "14506:  if ((uri[0] == '*') && (uri[1] == '\\0')) {",
          "14508:   return 1;",
          "14517:  for (i = 0; uri[i] != 0; i++) {",
          "14518:   if (uri[i] < 33) {",
          "14520:    return 0;",
          "14521:   }",
          "14522:   if (uri[i] > 126) {",
          "14524:    return 0;",
          "14525:   } else {",
          "14526:    switch (uri[i]) {",
          "14536:     return 0;",
          "14537:    default:",
          "14539:     break;",
          "14540:    }",
          "14541:   }",
          "14542:  }",
          "14545:  if (uri[0] == '/') {",
          "14547:   return 2;",
          "14554:  for (i = 0; abs_uri_protocols[i].proto != NULL; i++) {",
          "14555:   if (mg_strncasecmp(uri,",
          "14556:                      abs_uri_protocols[i].proto,",
          "14557:                      abs_uri_protocols[i].proto_len) == 0) {",
          "14559:    hostend = strchr(uri + abs_uri_protocols[i].proto_len, '/');",
          "14560:    if (!hostend) {",
          "14563:    portbegin = strchr(uri + abs_uri_protocols[i].proto_len, ':');",
          "14564:    if (!portbegin) {",
          "14565:     return 3;",
          "14566:    }",
          "14568:    port = strtoul(portbegin + 1, &portend, 10);",
          "14569:    if ((portend != hostend) || (port <= 0) || !is_valid_port(port)) {",
          "14573:    return 4;",
          "14575:  }",
          "14577:  return 0;",
          "14578: }",
          "14582: static const char *",
          "14583: get_rel_url_at_current_server(const char *uri, const struct mg_connection *conn)",
          "14584: {",
          "14585:  const char *server_domain;",
          "14586:  size_t server_domain_len;",
          "14587:  size_t request_domain_len = 0;",
          "14588:  unsigned long port = 0;",
          "14589:  int i, auth_domain_check_enabled;",
          "14590:  const char *hostbegin = NULL;",
          "14591:  const char *hostend = NULL;",
          "14592:  const char *portbegin;",
          "14593:  char *portend;",
          "14595:  auth_domain_check_enabled =",
          "14596:      !strcmp(conn->ctx->config[ENABLE_AUTH_DOMAIN_CHECK], \"yes\");",
          "14598:  if (!auth_domain_check_enabled) {",
          "14599:   return 0;",
          "14600:  }",
          "14602:  server_domain = conn->ctx->config[AUTHENTICATION_DOMAIN];",
          "14603:  if (!server_domain) {",
          "14604:   return 0;",
          "14605:  }",
          "14606:  server_domain_len = strlen(server_domain);",
          "14607:  if (!server_domain_len) {",
          "14608:   return 0;",
          "14609:  }",
          "14613:  for (i = 0; abs_uri_protocols[i].proto != NULL; i++) {",
          "14614:   if (mg_strncasecmp(uri,",
          "14615:                      abs_uri_protocols[i].proto,",
          "14616:                      abs_uri_protocols[i].proto_len) == 0) {",
          "14618:    hostbegin = uri + abs_uri_protocols[i].proto_len;",
          "14619:    hostend = strchr(hostbegin, '/');",
          "14620:    if (!hostend) {",
          "14621:     return 0;",
          "14622:    }",
          "14623:    portbegin = strchr(hostbegin, ':');",
          "14624:    if ((!portbegin) || (portbegin > hostend)) {",
          "14625:     port = abs_uri_protocols[i].default_port;",
          "14626:     request_domain_len = (size_t)(hostend - hostbegin);",
          "14627:    } else {",
          "14633:     request_domain_len = (size_t)(portbegin - hostbegin);",
          "14636:    break;",
          "14638:  }",
          "14640:  if (!port) {",
          "14647: #if defined(USE_IPV6)",
          "14648:  if (conn->client.lsa.sa.sa_family == AF_INET6) {",
          "14649:   if (ntohs(conn->client.lsa.sin6.sin6_port) != port) {",
          "14653:  } else",
          "14654: #endif",
          "14655:  {",
          "14656:   if (ntohs(conn->client.lsa.sin.sin_port) != port) {",
          "14660:  }",
          "14669:  if (auth_domain_check_enabled) {",
          "14670:   if ((request_domain_len == server_domain_len)",
          "14671:       && (!memcmp(server_domain, hostbegin, server_domain_len))) {",
          "14673:   } else {",
          "14674:    if (request_domain_len < (server_domain_len + 2)) {",
          "14681:     return 0;",
          "14683:    if (hostbegin[request_domain_len - server_domain_len - 1] != '.') {",
          "14689:    if (0 != memcmp(server_domain,",
          "14690:                    hostbegin + request_domain_len - server_domain_len,",
          "14691:                    server_domain_len)) {",
          "14697:  }",
          "14699:  return hostend;",
          "14700: }",
          "14703: static int",
          "14704: get_message(struct mg_connection *conn, char *ebuf, size_t ebuf_len, int *err)",
          "14705: {",
          "14706:  if (ebuf_len > 0) {",
          "14707:   ebuf[0] = '\\0';",
          "14711:  reset_per_request_attributes(conn);",
          "14713:  if (!conn) {",
          "14714:   mg_snprintf(conn,",
          "14716:               ebuf,",
          "14717:               ebuf_len,",
          "14718:               \"%s\",",
          "14719:               \"Internal error\");",
          "14721:   return 0;",
          "14722:  }",
          "14725:  clock_gettime(CLOCK_MONOTONIC, &(conn->req_time));",
          "14727:  conn->request_len =",
          "14728:      read_message(NULL, conn, conn->buf, conn->buf_size, &conn->data_len);",
          "14731:  if ((conn->request_len >= 0) && (conn->data_len < conn->request_len)) {",
          "14732:   mg_snprintf(conn,",
          "14734:               ebuf,",
          "14735:               ebuf_len,",
          "14736:               \"%s\",",
          "14737:               \"Invalid message size\");",
          "14739:   return 0;",
          "14740:  }",
          "14742:  if ((conn->request_len == 0) && (conn->data_len == conn->buf_size)) {",
          "14743:   mg_snprintf(conn,",
          "14745:               ebuf,",
          "14746:               ebuf_len,",
          "14747:               \"%s\",",
          "14748:               \"Message too large\");",
          "14750:   return 0;",
          "14751:  }",
          "14753:  if (conn->request_len <= 0) {",
          "14754:   if (conn->data_len > 0) {",
          "14760:                \"Malformed message\");",
          "14762:   } else {",
          "14764:    conn->must_close = 1;",
          "14770:                \"No data received\");",
          "14773:   return 0;",
          "14774:  }",
          "14775:  return 1;",
          "14776: }",
          "14779: static int",
          "14780: get_request(struct mg_connection *conn, char *ebuf, size_t ebuf_len, int *err)",
          "14781: {",
          "14782:  const char *cl;",
          "14783:  if (!get_message(conn, ebuf, ebuf_len, err)) {",
          "14784:   return 0;",
          "14787:  if (parse_http_request(conn->buf, conn->buf_size, &conn->request_info)",
          "14788:      <= 0) {",
          "14789:   mg_snprintf(conn,",
          "14791:               ebuf,",
          "14792:               ebuf_len,",
          "14793:               \"%s\",",
          "14794:               \"Bad request\");",
          "14796:   return 0;",
          "14797:  }",
          "14800:  if ((cl = get_header(conn->request_info.http_headers,",
          "14801:                       conn->request_info.num_headers,",
          "14802:                       \"Content-Length\")) != NULL) {",
          "14804:   char *endptr = NULL;",
          "14805:   conn->content_len = strtoll(cl, &endptr, 10);",
          "14806:   if (endptr == cl) {",
          "14817:   conn->request_info.content_length = conn->content_len;",
          "14818:  } else if ((cl = get_header(conn->request_info.http_headers,",
          "14819:                              conn->request_info.num_headers,",
          "14820:                              \"Transfer-Encoding\")) != NULL",
          "14821:             && !mg_strcasecmp(cl, \"chunked\")) {",
          "14822:   conn->is_chunked = 1;",
          "14823:  } else if (!mg_strcasecmp(conn->request_info.request_method, \"POST\")",
          "14824:             || !mg_strcasecmp(conn->request_info.request_method, \"PUT\")) {",
          "14826:   conn->content_len = -1;",
          "14827:  } else if (!mg_strncasecmp(conn->request_info.request_method, \"HTTP/\", 5)) {",
          "14829:   conn->content_len = -1;",
          "14830:  } else {",
          "14832:   conn->content_len = 0;",
          "14836:  return 1;",
          "14837: }",
          "14841: static int",
          "14842: get_response(struct mg_connection *conn, char *ebuf, size_t ebuf_len, int *err)",
          "14843: {",
          "14844:  const char *cl;",
          "14845:  if (!get_message(conn, ebuf, ebuf_len, err)) {",
          "14846:   return 0;",
          "14847:  }",
          "14849:  if (parse_http_response(conn->buf, conn->buf_size, &conn->response_info)",
          "14850:      <= 0) {",
          "14851:   mg_snprintf(conn,",
          "14853:               ebuf,",
          "14854:               ebuf_len,",
          "14855:               \"%s\",",
          "14856:               \"Bad response\");",
          "14858:   return 0;",
          "14862:  if ((cl = get_header(conn->response_info.http_headers,",
          "14863:                       conn->response_info.num_headers,",
          "14864:                       \"Content-Length\")) != NULL) {",
          "14866:   char *endptr = NULL;",
          "14867:   conn->content_len = strtoll(cl, &endptr, 10);",
          "14868:   if (endptr == cl) {",
          "14874:                \"Bad request\");",
          "14876:    return 0;",
          "14879:   conn->response_info.content_length = conn->content_len;",
          "14882:   conn->request_info.content_length = conn->content_len;",
          "14884:  } else if ((cl = get_header(conn->response_info.http_headers,",
          "14885:                              conn->response_info.num_headers,",
          "14886:                              \"Transfer-Encoding\")) != NULL",
          "14887:             && !mg_strcasecmp(cl, \"chunked\")) {",
          "14888:   conn->is_chunked = 1;",
          "14889:  } else {",
          "14890:   conn->content_len = -1;",
          "14891:  }",
          "14895:  return 1;",
          "14896: }",
          "14899: int",
          "14900: mg_get_response(struct mg_connection *conn,",
          "14901:                 char *ebuf,",
          "14902:                 size_t ebuf_len,",
          "14903:                 int timeout)",
          "14904: {",
          "14905:  if (ebuf_len > 0) {",
          "14906:   ebuf[0] = '\\0';",
          "14907:  }",
          "14909:  if (!conn) {",
          "14910:   mg_snprintf(conn,",
          "14912:               ebuf,",
          "14913:               ebuf_len,",
          "14914:               \"%s\",",
          "14915:               \"Parameter error\");",
          "14916:   return -1;",
          "14917:  }",
          "14920:  int err, ret;",
          "14921:  struct mg_context *octx = conn->ctx;",
          "14922:  struct mg_context rctx = *(conn->ctx);",
          "14925:  if (timeout >= 0) {",
          "14926:   mg_snprintf(conn, NULL, txt, sizeof(txt), \"%i\", timeout);",
          "14927:   rctx.config[REQUEST_TIMEOUT] = txt;",
          "14929:   set_sock_timeout(conn->client.sock, timeout);",
          "14931:  } else {",
          "14932:   rctx.config[REQUEST_TIMEOUT] = NULL;",
          "14933:  }",
          "14935:  conn->ctx = &rctx;",
          "14936:  ret = get_response(conn, ebuf, ebuf_len, &err);",
          "14937:  conn->ctx = octx;",
          "14942:  conn->request_info.uri = conn->request_info.request_uri;",
          "14944:  conn->request_info.local_uri = conn->request_info.request_uri;",
          "14948:  return (ret == 0) ? -1 : +1;",
          "14949: }",
          "14952: struct mg_connection *",
          "14953: mg_download(const char *host,",
          "14954:             int port,",
          "14955:             int use_ssl,",
          "14956:             char *ebuf,",
          "14957:             size_t ebuf_len,",
          "14958:             const char *fmt,",
          "14959:             ...)",
          "14960: {",
          "14961:  struct mg_connection *conn;",
          "14962:  va_list ap;",
          "14963:  int i;",
          "14964:  int reqerr;",
          "14966:  if (ebuf_len > 0) {",
          "14967:   ebuf[0] = '\\0';",
          "14968:  }",
          "14970:  va_start(ap, fmt);",
          "14973:  conn = mg_connect_client(host, port, use_ssl, ebuf, ebuf_len);",
          "14975:  if (conn != NULL) {",
          "14976:   i = mg_vprintf(conn, fmt, ap);",
          "14977:   if (i <= 0) {",
          "14978:    mg_snprintf(conn,",
          "14980:                ebuf,",
          "14981:                ebuf_len,",
          "14982:                \"%s\",",
          "14983:                \"Error sending request\");",
          "14984:   } else {",
          "14985:    get_response(conn, ebuf, ebuf_len, &reqerr);",
          "14990:    conn->request_info.uri = conn->request_info.request_uri;",
          "14992:    conn->request_info.local_uri = conn->request_info.request_uri;",
          "14994:  }",
          "14997:  if ((ebuf[0] != '\\0') && (conn != NULL)) {",
          "14998:   mg_close_connection(conn);",
          "14999:   conn = NULL;",
          "15000:  }",
          "15002:  va_end(ap);",
          "15003:  return conn;",
          "15004: }",
          "15007: struct websocket_client_thread_data {",
          "15008:  struct mg_connection *conn;",
          "15009:  mg_websocket_data_handler data_handler;",
          "15010:  mg_websocket_close_handler close_handler;",
          "15011:  void *callback_data;",
          "15012: };",
          "15017: static unsigned __stdcall websocket_client_thread(void *data)",
          "15022: {",
          "15023:  struct websocket_client_thread_data *cdata =",
          "15024:      (struct websocket_client_thread_data *)data;",
          "15026:  mg_set_thread_name(\"ws-clnt\");",
          "15028:  if (cdata->conn->ctx) {",
          "15029:   if (cdata->conn->ctx->callbacks.init_thread) {",
          "15032:    cdata->conn->ctx->callbacks.init_thread(cdata->conn->ctx, 3);",
          "15034:  }",
          "15036:  read_websocket(cdata->conn, cdata->data_handler, cdata->callback_data);",
          "15038:  DEBUG_TRACE(\"%s\", \"Websocket client thread exited\\n\");",
          "15040:  if (cdata->close_handler != NULL) {",
          "15041:   cdata->close_handler(cdata->conn, cdata->callback_data);",
          "15042:  }",
          "15046:  cdata->conn->ctx->stop_flag = 2;",
          "15048:  mg_free((void *)cdata);",
          "15051:  return 0;",
          "15055: }",
          "15059: struct mg_connection *",
          "15060: mg_connect_websocket_client(const char *host,",
          "15061:                             int port,",
          "15062:                             int use_ssl,",
          "15063:                             char *error_buffer,",
          "15064:                             size_t error_buffer_size,",
          "15065:                             const char *path,",
          "15066:                             const char *origin,",
          "15067:                             mg_websocket_data_handler data_func,",
          "15068:                             mg_websocket_close_handler close_func,",
          "15069:                             void *user_data)",
          "15070: {",
          "15071:  struct mg_connection *conn = NULL;",
          "15074:  struct mg_context *newctx = NULL;",
          "15075:  struct websocket_client_thread_data *thread_data;",
          "15076:  static const char *magic = \"x3JJHMbDL1EzLkh9GBhXDw==\";",
          "15077:  static const char *handshake_req;",
          "15079:  if (origin != NULL) {",
          "15080:   handshake_req = \"GET %s HTTP/1.1\\r\\n\"",
          "15081:                   \"Host: %s\\r\\n\"",
          "15082:                   \"Upgrade: websocket\\r\\n\"",
          "15083:                   \"Connection: Upgrade\\r\\n\"",
          "15084:                   \"Sec-WebSocket-Key: %s\\r\\n\"",
          "15085:                   \"Sec-WebSocket-Version: 13\\r\\n\"",
          "15086:                   \"Origin: %s\\r\\n\"",
          "15087:                   \"\\r\\n\";",
          "15088:  } else {",
          "15089:   handshake_req = \"GET %s HTTP/1.1\\r\\n\"",
          "15090:                   \"Host: %s\\r\\n\"",
          "15091:                   \"Upgrade: websocket\\r\\n\"",
          "15092:                   \"Connection: Upgrade\\r\\n\"",
          "15093:                   \"Sec-WebSocket-Key: %s\\r\\n\"",
          "15094:                   \"Sec-WebSocket-Version: 13\\r\\n\"",
          "15095:                   \"\\r\\n\";",
          "15096:  }",
          "15099:  conn = mg_download(host,",
          "15100:                     port,",
          "15101:                     use_ssl,",
          "15102:                     error_buffer,",
          "15103:                     error_buffer_size,",
          "15104:                     handshake_req,",
          "15105:                     path,",
          "15106:                     host,",
          "15107:                     magic,",
          "15108:                     origin);",
          "15111:  if (conn == NULL) {",
          "15112:   if (!*error_buffer) {",
          "15114:    mg_snprintf(conn,",
          "15116:                error_buffer,",
          "15117:                error_buffer_size,",
          "15118:                \"Unexpected error\");",
          "15119:   }",
          "15120:   return NULL;",
          "15121:  }",
          "15123:  if (conn->response_info.status_code != 101) {",
          "15128:   if (!*error_buffer) {",
          "15130:    mg_snprintf(conn,",
          "15132:                error_buffer,",
          "15133:                error_buffer_size,",
          "15134:                \"Unexpected server reply\");",
          "15137:   DEBUG_TRACE(\"Websocket client connect error: %s\\r\\n\", error_buffer);",
          "15138:   mg_free(conn);",
          "15139:   return conn;",
          "15140:  }",
          "15144:  newctx = (struct mg_context *)mg_malloc(sizeof(struct mg_context));",
          "15145:  memcpy(newctx, conn->ctx, sizeof(struct mg_context));",
          "15146:  newctx->user_data = user_data;",
          "15149:  newctx->worker_threadids =",
          "15150:      (pthread_t *)mg_calloc_ctx(newctx->cfg_worker_threads,",
          "15151:                                 sizeof(pthread_t),",
          "15152:                                 newctx);",
          "15153:  conn->ctx = newctx;",
          "15154:  thread_data = (struct websocket_client_thread_data *)",
          "15155:      mg_calloc_ctx(sizeof(struct websocket_client_thread_data), 1, newctx);",
          "15156:  thread_data->conn = conn;",
          "15157:  thread_data->data_handler = data_func;",
          "15158:  thread_data->close_handler = close_func;",
          "15159:  thread_data->callback_data = user_data;",
          "15164:  if (mg_start_thread_with_id(websocket_client_thread,",
          "15165:                              (void *)thread_data,",
          "15166:                              newctx->worker_threadids) != 0) {",
          "15167:   mg_free((void *)thread_data);",
          "15168:   mg_free((void *)newctx->worker_threadids);",
          "15169:   mg_free((void *)newctx);",
          "15170:   mg_free((void *)conn);",
          "15171:   conn = NULL;",
          "15172:   DEBUG_TRACE(\"%s\",",
          "15173:               \"Websocket client connect thread could not be started\\r\\n\");",
          "15174:  }",
          "",
          "[Added Lines]",
          "14393:   socklen_t len = (sa.sa.sa_family == AF_INET)",
          "14394:                       ? sizeof(conn->client.rsa.sin)",
          "14395:                       : sizeof(conn->client.rsa.sin6);",
          "14396:   struct sockaddr *psa =",
          "14397:       (sa.sa.sa_family == AF_INET)",
          "14398:           ? (struct sockaddr *)&(conn->client.rsa.sin)",
          "14399:           : (struct sockaddr *)&(conn->client.rsa.sin6);",
          "14405:   conn->buf_size = (int)max_req_size;",
          "14406:   conn->buf = (char *)(conn + 1);",
          "14407:   conn->ctx = &common_client_context;",
          "14408:   conn->client.sock = sock;",
          "14409:   conn->client.lsa = sa;",
          "14411:   if (getsockname(sock, psa, &len) != 0) {",
          "14412:    mg_cry(conn,",
          "14413:           \"%s: getsockname() failed: %s\",",
          "14414:           __func__,",
          "14415:           strerror(ERRNO));",
          "14416:   }",
          "14418:   conn->client.is_ssl = use_ssl ? 1 : 0;",
          "14419:   (void)pthread_mutex_init(&conn->mutex, &pthread_mutex_attr);",
          "14421: #ifndef NO_SSL",
          "14422:   if (use_ssl) {",
          "14423:    common_client_context.ssl_ctx = conn->client_ssl_ctx;",
          "14432:    if (client_options->client_cert) {",
          "14433:     if (!ssl_use_pem_file(&common_client_context,",
          "14434:                           client_options->client_cert,",
          "14435:                           NULL)) {",
          "14436:      mg_snprintf(NULL,",
          "14438:                  ebuf,",
          "14439:                  ebuf_len,",
          "14440:                  \"Can not use SSL client certificate\");",
          "14441:      SSL_CTX_free(conn->client_ssl_ctx);",
          "14442:      closesocket(sock);",
          "14443:      mg_free(conn);",
          "14444:      return NULL;",
          "14445:     }",
          "14446:    }",
          "14448:    if (client_options->server_cert) {",
          "14449:     SSL_CTX_load_verify_locations(conn->client_ssl_ctx,",
          "14450:                                   client_options->server_cert,",
          "14451:                                   NULL);",
          "14452:     SSL_CTX_set_verify(conn->client_ssl_ctx, SSL_VERIFY_PEER, NULL);",
          "14453:    } else {",
          "14454:     SSL_CTX_set_verify(conn->client_ssl_ctx, SSL_VERIFY_NONE, NULL);",
          "14455:    }",
          "14457:    if (!sslize(conn,",
          "14458:                conn->client_ssl_ctx,",
          "14459:                SSL_connect,",
          "14460:                &(conn->ctx->stop_flag))) {",
          "14465:                 \"SSL connection error\");",
          "14474:   set_blocking_mode(sock, 0);",
          "14476:   return conn;",
          "14480:  CIVETWEB_API struct mg_connection *mg_connect_client_secure(",
          "14481:      const struct mg_client_options *client_options,",
          "14482:      char *error_buffer,",
          "14483:      size_t error_buffer_size)",
          "14484:  {",
          "14485:   return mg_connect_client_impl(client_options,",
          "14486:                                 1,",
          "14487:                                 error_buffer,",
          "14488:                                 error_buffer_size);",
          "14492:  struct mg_connection *mg_connect_client(const char *host,",
          "14493:                                          int port,",
          "14494:                                          int use_ssl,",
          "14495:                                          char *error_buffer,",
          "14496:                                          size_t error_buffer_size)",
          "14497:  {",
          "14498:   struct mg_client_options opts;",
          "14499:   memset(&opts, 0, sizeof(opts));",
          "14500:   opts.host = host;",
          "14501:   opts.port = port;",
          "14502:   return mg_connect_client_impl(&opts,",
          "14503:                                 use_ssl,",
          "14504:                                 error_buffer,",
          "14505:                                 error_buffer_size);",
          "14506:  }",
          "14509:  static const struct {",
          "14510:   const char *proto;",
          "14511:   size_t proto_len;",
          "14512:   unsigned default_port;",
          "14513:  } abs_uri_protocols[] = {{\"http://\", 7, 80},",
          "14514:                           {\"https://\", 8, 443},",
          "14515:                           {\"ws://\", 5, 80},",
          "14516:                           {\"wss://\", 6, 443},",
          "14517:                           {NULL, 0, 0}};",
          "14526:  static int get_uri_type(const char *uri)",
          "14527:  {",
          "14528:   int i;",
          "14529:   const char *hostend, *portbegin;",
          "14530:   char *portend;",
          "14531:   unsigned long port;",
          "14537:   if ((uri[0] == '*') && (uri[1] == '\\0')) {",
          "14539:    return 1;",
          "14540:   }",
          "14548:   for (i = 0; uri[i] != 0; i++) {",
          "14549:    if (uri[i] < 33) {",
          "14553:    if (uri[i] > 126) {",
          "14556:    } else {",
          "14557:     switch (uri[i]) {",
          "14567:      return 0;",
          "14568:     default:",
          "14570:      break;",
          "14571:     }",
          "14576:   if (uri[0] == '/') {",
          "14578:    return 2;",
          "14579:   }",
          "14585:   for (i = 0; abs_uri_protocols[i].proto != NULL; i++) {",
          "14586:    if (mg_strncasecmp(uri,",
          "14587:                       abs_uri_protocols[i].proto,",
          "14588:                       abs_uri_protocols[i].proto_len) == 0) {",
          "14590:     hostend = strchr(uri + abs_uri_protocols[i].proto_len, '/');",
          "14591:     if (!hostend) {",
          "14592:      return 0;",
          "14593:     }",
          "14594:     portbegin = strchr(uri + abs_uri_protocols[i].proto_len, ':');",
          "14595:     if (!portbegin) {",
          "14596:      return 3;",
          "14597:     }",
          "14605:     return 4;",
          "14614:  static const char *get_rel_url_at_current_server(",
          "14615:      const char *uri, const struct mg_connection *conn)",
          "14616:  {",
          "14617:   const char *server_domain;",
          "14618:   size_t server_domain_len;",
          "14619:   size_t request_domain_len = 0;",
          "14620:   unsigned long port = 0;",
          "14621:   int i, auth_domain_check_enabled;",
          "14622:   const char *hostbegin = NULL;",
          "14623:   const char *hostend = NULL;",
          "14624:   const char *portbegin;",
          "14625:   char *portend;",
          "14627:   auth_domain_check_enabled =",
          "14628:       !strcmp(conn->ctx->config[ENABLE_AUTH_DOMAIN_CHECK], \"yes\");",
          "14630:   if (!auth_domain_check_enabled) {",
          "14634:   server_domain = conn->ctx->config[AUTHENTICATION_DOMAIN];",
          "14635:   if (!server_domain) {",
          "14636:    return 0;",
          "14637:   }",
          "14638:   server_domain_len = strlen(server_domain);",
          "14639:   if (!server_domain_len) {",
          "14645:   for (i = 0; abs_uri_protocols[i].proto != NULL; i++) {",
          "14646:    if (mg_strncasecmp(uri,",
          "14647:                       abs_uri_protocols[i].proto,",
          "14648:                       abs_uri_protocols[i].proto_len) == 0) {",
          "14650:     hostbegin = uri + abs_uri_protocols[i].proto_len;",
          "14651:     hostend = strchr(hostbegin, '/');",
          "14652:     if (!hostend) {",
          "14653:      return 0;",
          "14654:     }",
          "14655:     portbegin = strchr(hostbegin, ':');",
          "14656:     if ((!portbegin) || (portbegin > hostend)) {",
          "14657:      port = abs_uri_protocols[i].default_port;",
          "14658:      request_domain_len = (size_t)(hostend - hostbegin);",
          "14659:     } else {",
          "14660:      port = strtoul(portbegin + 1, &portend, 10);",
          "14661:      if ((portend != hostend) || (port <= 0)",
          "14662:          || !is_valid_port(port)) {",
          "14663:       return 0;",
          "14664:      }",
          "14665:      request_domain_len = (size_t)(portbegin - hostbegin);",
          "14666:     }",
          "14668:     break;",
          "14670:   }",
          "14672:   if (!port) {",
          "14674:    return 0;",
          "14675:   }",
          "14679: #if defined(USE_IPV6)",
          "14680:   if (conn->client.lsa.sa.sa_family == AF_INET6) {",
          "14681:    if (ntohs(conn->client.lsa.sin6.sin6_port) != port) {",
          "14685:   } else",
          "14686: #endif",
          "14687:   {",
          "14688:    if (ntohs(conn->client.lsa.sin.sin_port) != port) {",
          "14702:   if (auth_domain_check_enabled) {",
          "14703:    if ((request_domain_len == server_domain_len)",
          "14704:        && (!memcmp(server_domain, hostbegin, server_domain_len))) {",
          "14706:    } else {",
          "14707:     if (request_domain_len < (server_domain_len + 2)) {",
          "14715:      return 0;",
          "14716:     }",
          "14717:     if (hostbegin[request_domain_len - server_domain_len - 1]",
          "14718:         != '.') {",
          "14722:      return 0;",
          "14723:     }",
          "14724:     if (0 != memcmp(server_domain,",
          "14725:                     hostbegin + request_domain_len",
          "14726:                         - server_domain_len,",
          "14727:                     server_domain_len)) {",
          "14730:      return 0;",
          "14731:     }",
          "14732:    }",
          "14733:   }",
          "14735:   return hostend;",
          "14739:  static int get_message(struct mg_connection * conn,",
          "14740:                         char *ebuf,",
          "14741:                         size_t ebuf_len,",
          "14742:                         int *err)",
          "14743:  {",
          "14744:   if (ebuf_len > 0) {",
          "14745:    ebuf[0] = '\\0';",
          "14746:   }",
          "14749:   reset_per_request_attributes(conn);",
          "14751:   if (!conn) {",
          "14757:                \"Internal error\");",
          "14759:    return 0;",
          "14760:   }",
          "14763:   clock_gettime(CLOCK_MONOTONIC, &(conn->req_time));",
          "14765:   conn->request_len = read_message(",
          "14766:       NULL, conn, conn->buf, conn->buf_size, &conn->data_len);",
          "14769:   if ((conn->request_len >= 0) && (conn->data_len < conn->request_len)) {",
          "14775:                \"Invalid message size\");",
          "14777:    return 0;",
          "14780:   if ((conn->request_len == 0) && (conn->data_len == conn->buf_size)) {",
          "14781:    mg_snprintf(conn,",
          "14783:                ebuf,",
          "14784:                ebuf_len,",
          "14785:                \"%s\",",
          "14786:                \"Message too large\");",
          "14788:    return 0;",
          "14789:   }",
          "14791:   if (conn->request_len <= 0) {",
          "14792:    if (conn->data_len > 0) {",
          "14793:     mg_snprintf(conn,",
          "14795:                 ebuf,",
          "14796:                 ebuf_len,",
          "14797:                 \"%s\",",
          "14798:                 \"Malformed message\");",
          "14800:    } else {",
          "14802:     conn->must_close = 1;",
          "14803:     mg_snprintf(conn,",
          "14805:                 ebuf,",
          "14806:                 ebuf_len,",
          "14807:                 \"%s\",",
          "14808:                 \"No data received\");",
          "14810:    }",
          "14811:    return 0;",
          "14812:   }",
          "14813:   return 1;",
          "14817:  static int get_request(struct mg_connection * conn,",
          "14818:                         char *ebuf,",
          "14819:                         size_t ebuf_len,",
          "14820:                         int *err)",
          "14821:  {",
          "14822:   const char *cl;",
          "14823:   if (!get_message(conn, ebuf, ebuf_len, err)) {",
          "14824:    return 0;",
          "14825:   }",
          "14827:   if (parse_http_request(conn->buf, conn->buf_size, &conn->request_info)",
          "14828:       <= 0) {",
          "14840:   if ((cl = get_header(conn->request_info.http_headers,",
          "14841:                        conn->request_info.num_headers,",
          "14842:                        \"Content-Length\")) != NULL) {",
          "14844:    char *endptr = NULL;",
          "14845:    conn->content_len = strtoll(cl, &endptr, 10);",
          "14846:    if (endptr == cl) {",
          "14847:     mg_snprintf(conn,",
          "14849:                 ebuf,",
          "14850:                 ebuf_len,",
          "14851:                 \"%s\",",
          "14852:                 \"Bad request\");",
          "14854:     return 0;",
          "14855:    }",
          "14857:    conn->request_info.content_length = conn->content_len;",
          "14858:   } else if ((cl = get_header(conn->request_info.http_headers,",
          "14859:                               conn->request_info.num_headers,",
          "14860:                               \"Transfer-Encoding\")) != NULL",
          "14861:              && !mg_strcasecmp(cl, \"chunked\")) {",
          "14862:    conn->is_chunked = 1;",
          "14863:   } else if (!mg_strcasecmp(conn->request_info.request_method, \"POST\")",
          "14864:              || !mg_strcasecmp(conn->request_info.request_method,",
          "14865:                                \"PUT\")) {",
          "14867:    conn->content_len = -1;",
          "14868:   } else if (!mg_strncasecmp(conn->request_info.request_method,",
          "14869:                              \"HTTP/\",",
          "14870:                              5)) {",
          "14872:    conn->content_len = -1;",
          "14873:   } else {",
          "14875:    conn->content_len = 0;",
          "14876:   }",
          "14879:   return 1;",
          "14884:  static int get_response(struct mg_connection * conn,",
          "14885:                          char *ebuf,",
          "14886:                          size_t ebuf_len,",
          "14887:                          int *err)",
          "14888:  {",
          "14889:   const char *cl;",
          "14890:   if (!get_message(conn, ebuf, ebuf_len, err)) {",
          "14891:    return 0;",
          "14892:   }",
          "14894:   if (parse_http_response(conn->buf, conn->buf_size, &conn->response_info)",
          "14895:       <= 0) {",
          "14896:    mg_snprintf(conn,",
          "14898:                ebuf,",
          "14899:                ebuf_len,",
          "14900:                \"%s\",",
          "14901:                \"Bad response\");",
          "14903:    return 0;",
          "14904:   }",
          "14907:   if ((cl = get_header(conn->response_info.http_headers,",
          "14908:                        conn->response_info.num_headers,",
          "14909:                        \"Content-Length\")) != NULL) {",
          "14911:    char *endptr = NULL;",
          "14912:    conn->content_len = strtoll(cl, &endptr, 10);",
          "14913:    if (endptr == cl) {",
          "14914:     mg_snprintf(conn,",
          "14916:                 ebuf,",
          "14917:                 ebuf_len,",
          "14918:                 \"%s\",",
          "14919:                 \"Bad request\");",
          "14921:     return 0;",
          "14922:    }",
          "14924:    conn->response_info.content_length = conn->content_len;",
          "14927:    conn->request_info.content_length = conn->content_len;",
          "14929:   } else if ((cl = get_header(conn->response_info.http_headers,",
          "14930:                               conn->response_info.num_headers,",
          "14931:                               \"Transfer-Encoding\")) != NULL",
          "14932:              && !mg_strcasecmp(cl, \"chunked\")) {",
          "14933:    conn->is_chunked = 1;",
          "14934:   } else {",
          "14935:    conn->content_len = -1;",
          "14936:   }",
          "14940:   return 1;",
          "14944:  int mg_get_response(struct mg_connection * conn,",
          "14945:                      char *ebuf,",
          "14946:                      size_t ebuf_len,",
          "14947:                      int timeout)",
          "14948:  {",
          "14949:   if (ebuf_len > 0) {",
          "14950:    ebuf[0] = '\\0';",
          "14951:   }",
          "14953:   if (!conn) {",
          "14959:                \"Parameter error\");",
          "14960:    return -1;",
          "14964:   int err, ret;",
          "14965:   struct mg_context *octx = conn->ctx;",
          "14966:   struct mg_context rctx = *(conn->ctx);",
          "14969:   if (timeout >= 0) {",
          "14970:    mg_snprintf(conn, NULL, txt, sizeof(txt), \"%i\", timeout);",
          "14971:    rctx.config[REQUEST_TIMEOUT] = txt;",
          "14973:    set_sock_timeout(conn->client.sock, timeout);",
          "14975:   } else {",
          "14976:    rctx.config[REQUEST_TIMEOUT] = NULL;",
          "14977:   }",
          "14979:   conn->ctx = &rctx;",
          "14980:   ret = get_response(conn, ebuf, ebuf_len, &err);",
          "14981:   conn->ctx = octx;",
          "14986:   conn->request_info.uri = conn->request_info.request_uri;",
          "14988:   conn->request_info.local_uri = conn->request_info.request_uri;",
          "14992:   return (ret == 0) ? -1 : +1;",
          "14993:  }",
          "14996:  struct mg_connection *mg_download(const char *host,",
          "14997:                                    int port,",
          "14998:                                    int use_ssl,",
          "14999:                                    char *ebuf,",
          "15000:                                    size_t ebuf_len,",
          "15001:                                    const char *fmt,",
          "15002:                                    ...)",
          "15003:  {",
          "15004:   struct mg_connection *conn;",
          "15005:   va_list ap;",
          "15006:   int i;",
          "15007:   int reqerr;",
          "15009:   if (ebuf_len > 0) {",
          "15010:    ebuf[0] = '\\0';",
          "15011:   }",
          "15013:   va_start(ap, fmt);",
          "15016:   conn = mg_connect_client(host, port, use_ssl, ebuf, ebuf_len);",
          "15018:   if (conn != NULL) {",
          "15019:    i = mg_vprintf(conn, fmt, ap);",
          "15020:    if (i <= 0) {",
          "15021:     mg_snprintf(conn,",
          "15023:                 ebuf,",
          "15024:                 ebuf_len,",
          "15025:                 \"%s\",",
          "15026:                 \"Error sending request\");",
          "15027:    } else {",
          "15028:     get_response(conn, ebuf, ebuf_len, &reqerr);",
          "15033:     conn->request_info.uri = conn->request_info.request_uri;",
          "15035:     conn->request_info.local_uri = conn->request_info.request_uri;",
          "15036:    }",
          "15040:   if ((ebuf[0] != '\\0') && (conn != NULL)) {",
          "15041:    mg_close_connection(conn);",
          "15042:    conn = NULL;",
          "15043:   }",
          "15045:   va_end(ap);",
          "15046:   return conn;",
          "15047:  }",
          "15050:  struct websocket_client_thread_data {",
          "15051:   struct mg_connection *conn;",
          "15052:   mg_websocket_data_handler data_handler;",
          "15053:   mg_websocket_close_handler close_handler;",
          "15054:   void *callback_data;",
          "15055:  };",
          "15060:  static unsigned __stdcall websocket_client_thread(void *data)",
          "15065:  {",
          "15066:   struct websocket_client_thread_data *cdata =",
          "15067:       (struct websocket_client_thread_data *)data;",
          "15069:   mg_set_thread_name(\"ws-clnt\");",
          "15071:   if (cdata->conn->ctx) {",
          "15072:    if (cdata->conn->ctx->callbacks.init_thread) {",
          "15075:     cdata->conn->ctx->callbacks.init_thread(cdata->conn->ctx, 3);",
          "15076:    }",
          "15079:   read_websocket(cdata->conn, cdata->data_handler, cdata->callback_data);",
          "15081:   DEBUG_TRACE(\"%s\", \"Websocket client thread exited\\n\");",
          "15083:   if (cdata->close_handler != NULL) {",
          "15084:    cdata->close_handler(cdata->conn, cdata->callback_data);",
          "15085:   }",
          "15089:   cdata->conn->ctx->stop_flag = 2;",
          "15091:   mg_free((void *)cdata);",
          "15094:   return 0;",
          "15098:  }",
          "15102:  struct mg_connection *mg_connect_websocket_client(",
          "15103:      const char *host,",
          "15104:      int port,",
          "15105:      int use_ssl,",
          "15106:      char *error_buffer,",
          "15107:      size_t error_buffer_size,",
          "15108:      const char *path,",
          "15109:      const char *origin,",
          "15110:      mg_websocket_data_handler data_func,",
          "15111:      mg_websocket_close_handler close_func,",
          "15112:      void *user_data)",
          "15113:  {",
          "15114:   struct mg_connection *conn = NULL;",
          "15117:   struct mg_context *newctx = NULL;",
          "15118:   struct websocket_client_thread_data *thread_data;",
          "15119:   static const char *magic = \"x3JJHMbDL1EzLkh9GBhXDw==\";",
          "15120:   static const char *handshake_req;",
          "15122:   if (origin != NULL) {",
          "15123:    handshake_req = \"GET %s HTTP/1.1\\r\\n\"",
          "15124:                    \"Host: %s\\r\\n\"",
          "15125:                    \"Upgrade: websocket\\r\\n\"",
          "15126:                    \"Connection: Upgrade\\r\\n\"",
          "15127:                    \"Sec-WebSocket-Key: %s\\r\\n\"",
          "15128:                    \"Sec-WebSocket-Version: 13\\r\\n\"",
          "15129:                    \"Origin: %s\\r\\n\"",
          "15130:                    \"\\r\\n\";",
          "15131:   } else {",
          "15132:    handshake_req = \"GET %s HTTP/1.1\\r\\n\"",
          "15133:                    \"Host: %s\\r\\n\"",
          "15134:                    \"Upgrade: websocket\\r\\n\"",
          "15135:                    \"Connection: Upgrade\\r\\n\"",
          "15136:                    \"Sec-WebSocket-Key: %s\\r\\n\"",
          "15137:                    \"Sec-WebSocket-Version: 13\\r\\n\"",
          "15138:                    \"\\r\\n\";",
          "15139:   }",
          "15142:   conn = mg_download(host,",
          "15143:                      port,",
          "15144:                      use_ssl,",
          "15145:                      error_buffer,",
          "15146:                      error_buffer_size,",
          "15147:                      handshake_req,",
          "15148:                      path,",
          "15149:                      host,",
          "15150:                      magic,",
          "15151:                      origin);",
          "15154:   if (conn == NULL) {",
          "15155:    if (!*error_buffer) {",
          "15157:     mg_snprintf(conn,",
          "15159:                 error_buffer,",
          "15160:                 error_buffer_size,",
          "15161:                 \"Unexpected error\");",
          "15162:    }",
          "15163:    return NULL;",
          "15166:   if (conn->response_info.status_code != 101) {",
          "15171:    if (!*error_buffer) {",
          "15173:     mg_snprintf(conn,",
          "15175:                 error_buffer,",
          "15176:                 error_buffer_size,",
          "15177:                 \"Unexpected server reply\");",
          "15178:    }",
          "15180:    DEBUG_TRACE(\"Websocket client connect error: %s\\r\\n\", error_buffer);",
          "15181:    mg_free(conn);",
          "15182:    return conn;",
          "15183:   }",
          "15187:   newctx = (struct mg_context *)mg_malloc(sizeof(struct mg_context));",
          "15188:   memcpy(newctx, conn->ctx, sizeof(struct mg_context));",
          "15189:   newctx->user_data = user_data;",
          "15192:   newctx->worker_threadids =",
          "15193:       (pthread_t *)mg_calloc_ctx(newctx->cfg_worker_threads,",
          "15194:                                  sizeof(pthread_t),",
          "15195:                                  newctx);",
          "15196:   conn->ctx = newctx;",
          "15197:   thread_data = (struct websocket_client_thread_data *)mg_calloc_ctx(",
          "15198:       sizeof(struct websocket_client_thread_data), 1, newctx);",
          "15199:   thread_data->conn = conn;",
          "15200:   thread_data->data_handler = data_func;",
          "15201:   thread_data->close_handler = close_func;",
          "15202:   thread_data->callback_data = user_data;",
          "15207:   if (mg_start_thread_with_id(websocket_client_thread,",
          "15208:                               (void *)thread_data,",
          "15209:                               newctx->worker_threadids) != 0) {",
          "15210:    mg_free((void *)thread_data);",
          "15211:    mg_free((void *)newctx->worker_threadids);",
          "15212:    mg_free((void *)newctx);",
          "15213:    mg_free((void *)conn);",
          "15214:    conn = NULL;",
          "15215:    DEBUG_TRACE(",
          "15216:        \"%s\",",
          "15217:        \"Websocket client connect thread could not be started\\r\\n\");",
          "15218:   }",
          "",
          "---------------",
          "--- Hunk 60 ---",
          "[Context before]",
          "15187:  (void)close_func;",
          "15188: #endif",
          "15204: #if defined(USE_SERVER_STATS)",
          "15212: #endif",
          "15266:      }",
          "15269:      mg_snprintf(conn,",
          "15271:                  ebuf,",
          "15272:                  sizeof(ebuf),",
          "15277:     }",
          "15279: #if defined(MG_LEGACY_INTERFACE)",
          "15282: #endif",
          "15298:      }",
          "15300:     } else {",
          "15302:      conn->must_close = 1;",
          "15303:     }",
          "15360: #if defined(USE_SERVER_STATS)",
          "15363: #endif",
          "15364:  }",
          "15368: #if defined(ALTERNATIVE_QUEUE)",
          "15383:    }",
          "15384:   }",
          "15387:  }",
          "",
          "[Removed Lines]",
          "15190:  return conn;",
          "15191: }",
          "15194: static void",
          "15195: process_new_connection(struct mg_connection *conn)",
          "15196: {",
          "15197:  if (conn && conn->ctx) {",
          "15198:   struct mg_request_info *ri = &conn->request_info;",
          "15199:   int keep_alive_enabled, keep_alive, discard_len;",
          "15200:   char ebuf[100];",
          "15201:   const char *hostend;",
          "15202:   int reqerr, uri_type;",
          "15205:   int mcon = mg_atomic_inc(&(conn->ctx->active_connections));",
          "15206:   mg_atomic_add(&(conn->ctx->total_connections), 1);",
          "15207:   if (mcon > (conn->ctx->max_connections)) {",
          "15210:    conn->ctx->max_connections = mcon;",
          "15211:   }",
          "15214:   keep_alive_enabled =",
          "15215:       !strcmp(conn->ctx->config[ENABLE_KEEP_ALIVE], \"yes\");",
          "15219:   conn->data_len = 0;",
          "15220:   conn->handled_requests = 0;",
          "15221:   do {",
          "15223:    DEBUG_TRACE(\"calling get_request (%i times for this connection)\",",
          "15224:                conn->handled_requests + 1);",
          "15226:    if (!get_request(conn, ebuf, sizeof(ebuf), &reqerr)) {",
          "15230:     if (reqerr > 0) {",
          "15232:      mg_send_http_error(conn, reqerr, \"%s\", ebuf);",
          "15233:     }",
          "15234:    } else if (strcmp(ri->http_version, \"1.0\")",
          "15235:               && strcmp(ri->http_version, \"1.1\")) {",
          "15236:     mg_snprintf(conn,",
          "15238:                 ebuf,",
          "15239:                 sizeof(ebuf),",
          "15240:                 \"Bad HTTP version: [%s]\",",
          "15241:                 ri->http_version);",
          "15242:     mg_send_http_error(conn, 505, \"%s\", ebuf);",
          "15243:    }",
          "15245:    if (ebuf[0] == '\\0') {",
          "15246:     uri_type = get_uri_type(conn->request_info.request_uri);",
          "15247:     switch (uri_type) {",
          "15248:     case 1:",
          "15250:      conn->request_info.local_uri = NULL;",
          "15251:      break;",
          "15252:     case 2:",
          "15254:      conn->request_info.local_uri =",
          "15255:          conn->request_info.request_uri;",
          "15256:      break;",
          "15257:     case 3:",
          "15258:     case 4:",
          "15260:      hostend = get_rel_url_at_current_server(",
          "15261:          conn->request_info.request_uri, conn);",
          "15262:      if (hostend) {",
          "15263:       conn->request_info.local_uri = hostend;",
          "15264:      } else {",
          "15265:       conn->request_info.local_uri = NULL;",
          "15267:      break;",
          "15268:     default:",
          "15273:                  \"Invalid URI\");",
          "15274:      mg_send_http_error(conn, 400, \"%s\", ebuf);",
          "15275:      conn->request_info.local_uri = NULL;",
          "15276:      break;",
          "15281:     conn->request_info.uri = conn->request_info.local_uri;",
          "15283:    }",
          "15285:    DEBUG_TRACE(\"http: %s, error: %s\",",
          "15286:                (ri->http_version ? ri->http_version : \"none\"),",
          "15287:                (ebuf[0] ? ebuf : \"none\"));",
          "15289:    if (ebuf[0] == '\\0') {",
          "15290:     if (conn->request_info.local_uri) {",
          "15292:      handle_request(conn);",
          "15293:      DEBUG_TRACE(\"%s\", \"handle_request done\");",
          "15294:      if (conn->ctx->callbacks.end_request != NULL) {",
          "15295:       conn->ctx->callbacks.end_request(conn,",
          "15296:                                        conn->status_code);",
          "15297:       DEBUG_TRACE(\"%s\", \"end_request callback done\");",
          "15299:      log_access(conn);",
          "15304:    } else {",
          "15305:     conn->must_close = 1;",
          "15306:    }",
          "15308:    if (ri->remote_user != NULL) {",
          "15309:     mg_free((void *)ri->remote_user);",
          "15312:     ri->remote_user = NULL;",
          "15313:    }",
          "15322:    keep_alive = (conn->ctx->stop_flag == 0) && keep_alive_enabled",
          "15323:                 && (conn->content_len >= 0) && should_keep_alive(conn);",
          "15327:    discard_len = ((conn->content_len >= 0) && (conn->request_len > 0)",
          "15328:                   && ((conn->request_len + conn->content_len)",
          "15329:                       < (int64_t)conn->data_len))",
          "15330:                      ? (int)(conn->request_len + conn->content_len)",
          "15331:                      : conn->data_len;",
          "15333:    if (discard_len < 0) {",
          "15334:     DEBUG_TRACE(\"internal error: discard_len = %li\",",
          "15335:                 (long int)discard_len);",
          "15336:     break;",
          "15337:    }",
          "15338:    conn->data_len -= discard_len;",
          "15339:    if (conn->data_len > 0) {",
          "15340:     DEBUG_TRACE(\"discard_len = %lu\", (long unsigned)discard_len);",
          "15341:     memmove(conn->buf,",
          "15342:             conn->buf + discard_len,",
          "15343:             (size_t)conn->data_len);",
          "15344:    }",
          "15349:    if ((conn->data_len < 0) || (conn->data_len > conn->buf_size)) {",
          "15350:     DEBUG_TRACE(\"internal error: data_len = %li, buf_size = %li\",",
          "15351:                 (long int)conn->data_len,",
          "15352:                 (long int)conn->buf_size);",
          "15353:     break;",
          "15354:    }",
          "15356:    conn->handled_requests++;",
          "15358:   } while (keep_alive);",
          "15361:   mg_atomic_add(&(conn->ctx->total_requests), conn->handled_requests);",
          "15362:   mg_atomic_dec(&(conn->ctx->active_connections));",
          "15365: }",
          "15370: static void",
          "15371: produce_socket(struct mg_context *ctx, const struct socket *sp)",
          "15372: {",
          "15373:  unsigned int i;",
          "15375:  for (;;) {",
          "15376:   for (i = 0; i < ctx->cfg_worker_threads; i++) {",
          "15378:    if (ctx->client_socks[i].in_use == 0) {",
          "15379:     ctx->client_socks[i] = *sp;",
          "15380:     ctx->client_socks[i].in_use = 1;",
          "15381:     event_signal(ctx->client_wait_events[i]);",
          "15382:     return;",
          "15386:   mg_sleep(1);",
          "15388: }",
          "15391: static int",
          "15392: consume_socket(struct mg_context *ctx, struct socket *sp, int thread_index)",
          "15393: {",
          "15394:  DEBUG_TRACE(\"%s\", \"going idle\");",
          "15395:  ctx->client_socks[thread_index].in_use = 0;",
          "15396:  event_wait(ctx->client_wait_events[thread_index]);",
          "15398:  DEBUG_TRACE(\"grabbed socket %d, going busy\", sp ? sp->sock : -1);",
          "15400:  return !ctx->stop_flag;",
          "15401: }",
          "",
          "[Added Lines]",
          "15234:   return conn;",
          "15235:  }",
          "15238:  static void process_new_connection(struct mg_connection * conn)",
          "15239:  {",
          "15240:   if (conn && conn->ctx) {",
          "15241:    struct mg_request_info *ri = &conn->request_info;",
          "15242:    int keep_alive_enabled, keep_alive, discard_len;",
          "15243:    char ebuf[100];",
          "15244:    const char *hostend;",
          "15245:    int reqerr, uri_type;",
          "15248:    int mcon = mg_atomic_inc(&(conn->ctx->active_connections));",
          "15249:    mg_atomic_add(&(conn->ctx->total_connections), 1);",
          "15250:    if (mcon > (conn->ctx->max_connections)) {",
          "15253:     conn->ctx->max_connections = mcon;",
          "15254:    }",
          "15257:    keep_alive_enabled =",
          "15258:        !strcmp(conn->ctx->config[ENABLE_KEEP_ALIVE], \"yes\");",
          "15262:    conn->data_len = 0;",
          "15263:    conn->handled_requests = 0;",
          "15264:    do {",
          "15266:     DEBUG_TRACE(",
          "15267:         \"calling get_request (%i times for this connection)\",",
          "15268:         conn->handled_requests + 1);",
          "15270:     if (!get_request(conn, ebuf, sizeof(ebuf), &reqerr)) {",
          "15274:      if (reqerr > 0) {",
          "15276:       mg_send_http_error(conn, reqerr, \"%s\", ebuf);",
          "15278:     } else if (strcmp(ri->http_version, \"1.0\")",
          "15279:                && strcmp(ri->http_version, \"1.1\")) {",
          "15284:                  \"Bad HTTP version: [%s]\",",
          "15285:                  ri->http_version);",
          "15286:      mg_send_http_error(conn, 505, \"%s\", ebuf);",
          "15289:     if (ebuf[0] == '\\0') {",
          "15290:      uri_type = get_uri_type(conn->request_info.request_uri);",
          "15291:      switch (uri_type) {",
          "15292:      case 1:",
          "15294:       conn->request_info.local_uri = NULL;",
          "15295:       break;",
          "15296:      case 2:",
          "15298:       conn->request_info.local_uri =",
          "15299:           conn->request_info.request_uri;",
          "15300:       break;",
          "15301:      case 3:",
          "15302:      case 4:",
          "15304:       hostend = get_rel_url_at_current_server(",
          "15305:           conn->request_info.request_uri, conn);",
          "15306:       if (hostend) {",
          "15307:        conn->request_info.local_uri = hostend;",
          "15308:       } else {",
          "15309:        conn->request_info.local_uri = NULL;",
          "15310:       }",
          "15311:       break;",
          "15312:      default:",
          "15313:       mg_snprintf(conn,",
          "15315:                   ebuf,",
          "15316:                   sizeof(ebuf),",
          "15317:                   \"Invalid URI\");",
          "15318:       mg_send_http_error(conn, 400, \"%s\", ebuf);",
          "15319:       conn->request_info.local_uri = NULL;",
          "15320:       break;",
          "15321:      }",
          "15325:      conn->request_info.uri = conn->request_info.local_uri;",
          "15327:     }",
          "15329:     DEBUG_TRACE(\"http: %s, error: %s\",",
          "15330:                 (ri->http_version ? ri->http_version : \"none\"),",
          "15331:                 (ebuf[0] ? ebuf : \"none\"));",
          "15333:     if (ebuf[0] == '\\0') {",
          "15334:      if (conn->request_info.local_uri) {",
          "15336:       handle_request(conn);",
          "15337:       DEBUG_TRACE(\"%s\", \"handle_request done\");",
          "15338:       if (conn->ctx->callbacks.end_request != NULL) {",
          "15339:        conn->ctx->callbacks.end_request(conn,",
          "15340:                                         conn->status_code);",
          "15341:        DEBUG_TRACE(\"%s\", \"end_request callback done\");",
          "15342:       }",
          "15343:       log_access(conn);",
          "15344:      } else {",
          "15346:       conn->must_close = 1;",
          "15352:     if (ri->remote_user != NULL) {",
          "15353:      mg_free((void *)ri->remote_user);",
          "15356:      ri->remote_user = NULL;",
          "15357:     }",
          "15366:     keep_alive = (conn->ctx->stop_flag == 0) && keep_alive_enabled",
          "15367:                  && (conn->content_len >= 0)",
          "15368:                  && should_keep_alive(conn);",
          "15372:     discard_len =",
          "15373:         ((conn->content_len >= 0) && (conn->request_len > 0)",
          "15374:          && ((conn->request_len + conn->content_len)",
          "15375:              < (int64_t)conn->data_len))",
          "15376:             ? (int)(conn->request_len + conn->content_len)",
          "15377:             : conn->data_len;",
          "15379:     if (discard_len < 0) {",
          "15380:      DEBUG_TRACE(\"internal error: discard_len = %li\",",
          "15381:                  (long int)discard_len);",
          "15382:      break;",
          "15383:     }",
          "15384:     conn->data_len -= discard_len;",
          "15385:     if (conn->data_len > 0) {",
          "15386:      DEBUG_TRACE(\"discard_len = %lu\",",
          "15387:                  (long unsigned)discard_len);",
          "15388:      memmove(conn->buf,",
          "15389:              conn->buf + discard_len,",
          "15390:              (size_t)conn->data_len);",
          "15391:     }",
          "15396:     if ((conn->data_len < 0) || (conn->data_len > conn->buf_size)) {",
          "15397:      DEBUG_TRACE(",
          "15398:          \"internal error: data_len = %li, buf_size = %li\",",
          "15399:          (long int)conn->data_len,",
          "15400:          (long int)conn->buf_size);",
          "15401:      break;",
          "15402:     }",
          "15404:     conn->handled_requests++;",
          "15406:    } while (keep_alive);",
          "15409:    mg_atomic_add(&(conn->ctx->total_requests), conn->handled_requests);",
          "15410:    mg_atomic_dec(&(conn->ctx->active_connections));",
          "15412:   }",
          "15418:  static void produce_socket(struct mg_context * ctx, const struct socket *sp)",
          "15419:  {",
          "15420:   unsigned int i;",
          "15422:   for (;;) {",
          "15423:    for (i = 0; i < ctx->cfg_worker_threads; i++) {",
          "15425:     if (ctx->client_socks[i].in_use == 0) {",
          "15426:      ctx->client_socks[i] = *sp;",
          "15427:      ctx->client_socks[i].in_use = 1;",
          "15428:      event_signal(ctx->client_wait_events[i]);",
          "15429:      return;",
          "15430:     }",
          "15433:    mg_sleep(1);",
          "15438:  static int consume_socket(struct mg_context * ctx,",
          "15439:                            struct socket * sp,",
          "15440:                            int thread_index)",
          "15441:  {",
          "15442:   DEBUG_TRACE(\"%s\", \"going idle\");",
          "15443:   ctx->client_socks[thread_index].in_use = 0;",
          "15444:   event_wait(ctx->client_wait_events[thread_index]);",
          "15446:   DEBUG_TRACE(\"grabbed socket %d, going busy\", sp ? sp->sock : -1);",
          "15448:   return !ctx->stop_flag;",
          "15449:  }",
          "",
          "---------------",
          "--- Hunk 61 ---",
          "[Context before]",
          "15486: #if defined(MG_LEGACY_INTERFACE)",
          "15488: #endif",
          "15494: #if defined(_WIN32) && !defined(__SYMBIAN32__)",
          "15496: #endif",
          "15547: #if defined(USE_IPV6)",
          "15552: #endif",
          "15565: #if defined(MG_LEGACY_INTERFACE)",
          "15569: #endif",
          "15574: #ifndef NO_SSL",
          "15598:     }",
          "15600: #endif",
          "15617: #if defined(_WIN32) && !defined(__SYMBIAN32__)",
          "15619: #endif",
          "15633: #ifdef _WIN32",
          "15642: #else",
          "15643: static void *",
          "15644: worker_thread(void *thread_func_param)",
          "",
          "[Removed Lines]",
          "15474: struct worker_thread_args {",
          "15475:  struct mg_context *ctx;",
          "15476:  int index;",
          "15477: };",
          "15480: static void *",
          "15481: worker_thread_run(struct worker_thread_args *thread_args)",
          "15482: {",
          "15483:  struct mg_context *ctx = thread_args->ctx;",
          "15484:  struct mg_connection *conn;",
          "15485:  struct mg_workerTLS tls;",
          "15487:  uint32_t addr;",
          "15490:  mg_set_thread_name(\"worker\");",
          "15492:  tls.is_master = 0;",
          "15493:  tls.thread_idx = (unsigned)mg_atomic_inc(&thread_idx_max);",
          "15495:  tls.pthread_cond_helper_mutex = CreateEvent(NULL, FALSE, FALSE, NULL);",
          "15499:  pthread_setspecific(sTlsKey, &tls);",
          "15501:  if (ctx->callbacks.init_thread) {",
          "15503:   ctx->callbacks.init_thread(ctx, 1);",
          "15504:  }",
          "15507:  if (((int)thread_args->index < 0)",
          "15508:      || ((unsigned)thread_args->index",
          "15509:          >= (unsigned)ctx->cfg_worker_threads)) {",
          "15510:   mg_cry(fc(ctx),",
          "15511:          \"Internal error: Invalid worker index %i\",",
          "15512:          (int)thread_args->index);",
          "15513:   return NULL;",
          "15514:  }",
          "15515:  conn = ctx->worker_connections + thread_args->index;",
          "15520:  conn->buf = (char *)mg_malloc_ctx(ctx->max_request_size, conn->ctx);",
          "15521:  if (conn->buf == NULL) {",
          "15522:   mg_cry(fc(ctx),",
          "15523:          \"Out of memory: Cannot allocate buffer for worker %i\",",
          "15524:          (int)thread_args->index);",
          "15525:   return NULL;",
          "15526:  }",
          "15527:  conn->buf_size = (int)ctx->max_request_size;",
          "15529:  conn->ctx = ctx;",
          "15530:  conn->thread_index = thread_args->index;",
          "15531:  conn->request_info.user_data = ctx->user_data;",
          "15535:  (void)pthread_mutex_init(&conn->mutex, &pthread_mutex_attr);",
          "15540:  while (consume_socket(ctx, &conn->client, conn->thread_index)) {",
          "15541:   conn->conn_birth_time = time(NULL);",
          "15548:   if (conn->client.rsa.sa.sa_family == AF_INET6) {",
          "15549:    conn->request_info.remote_port =",
          "15550:        ntohs(conn->client.rsa.sin6.sin6_port);",
          "15551:   } else",
          "15553:   {",
          "15554:    conn->request_info.remote_port =",
          "15555:        ntohs(conn->client.rsa.sin.sin_port);",
          "15556:   }",
          "15558:   sockaddr_to_string(conn->request_info.remote_addr,",
          "15559:                      sizeof(conn->request_info.remote_addr),",
          "15560:                      &conn->client.rsa);",
          "15562:   DEBUG_TRACE(\"Start processing connection from %s\",",
          "15563:               conn->request_info.remote_addr);",
          "15567:   addr = ntohl(conn->client.rsa.sin.sin_addr.s_addr);",
          "15568:   memcpy(&conn->request_info.remote_ip, &addr, 4);",
          "15571:   conn->request_info.is_ssl = conn->client.is_ssl;",
          "15573:   if (conn->client.is_ssl) {",
          "15576:    if (sslize(conn,",
          "15577:               conn->ctx->ssl_ctx,",
          "15578:               SSL_accept,",
          "15579:               &(conn->ctx->stop_flag))) {",
          "15581:     ssl_get_client_cert_info(conn);",
          "15584:     process_new_connection(conn);",
          "15587:     if (conn->request_info.client_cert) {",
          "15588:      mg_free((void *)(conn->request_info.client_cert->subject));",
          "15589:      mg_free((void *)(conn->request_info.client_cert->issuer));",
          "15590:      mg_free((void *)(conn->request_info.client_cert->serial));",
          "15591:      mg_free((void *)(conn->request_info.client_cert->finger));",
          "15592:      conn->request_info.client_cert->subject = 0;",
          "15593:      conn->request_info.client_cert->issuer = 0;",
          "15594:      conn->request_info.client_cert->serial = 0;",
          "15595:      conn->request_info.client_cert->finger = 0;",
          "15596:      mg_free(conn->request_info.client_cert);",
          "15597:      conn->request_info.client_cert = 0;",
          "15599:    }",
          "15601:   } else {",
          "15603:    process_new_connection(conn);",
          "15604:   }",
          "15606:   DEBUG_TRACE(\"Done processing connection from %s (%f sec)\",",
          "15607:               conn->request_info.remote_addr,",
          "15608:               difftime(time(NULL), conn->conn_birth_time));",
          "15610:   close_connection(conn);",
          "15612:   DEBUG_TRACE(\"%s\", \"Connection closed\");",
          "15613:  }",
          "15616:  pthread_setspecific(sTlsKey, NULL);",
          "15618:  CloseHandle(tls.pthread_cond_helper_mutex);",
          "15620:  pthread_mutex_destroy(&conn->mutex);",
          "15623:  conn->buf_size = 0;",
          "15624:  mg_free(conn->buf);",
          "15625:  conn->buf = NULL;",
          "15627:  DEBUG_TRACE(\"%s\", \"exiting\");",
          "15628:  return NULL;",
          "15629: }",
          "15634: static unsigned __stdcall worker_thread(void *thread_func_param)",
          "15635: {",
          "15636:  struct worker_thread_args *pwta =",
          "15637:      (struct worker_thread_args *)thread_func_param;",
          "15638:  worker_thread_run(pwta);",
          "15639:  mg_free(thread_func_param);",
          "15640:  return 0;",
          "15641: }",
          "",
          "[Added Lines]",
          "15522:  struct worker_thread_args {",
          "15523:   struct mg_context *ctx;",
          "15524:   int index;",
          "15525:  };",
          "15528:  static void *worker_thread_run(struct worker_thread_args * thread_args)",
          "15529:  {",
          "15530:   struct mg_context *ctx = thread_args->ctx;",
          "15531:   struct mg_connection *conn;",
          "15532:   struct mg_workerTLS tls;",
          "15534:   uint32_t addr;",
          "15537:   mg_set_thread_name(\"worker\");",
          "15539:   tls.is_master = 0;",
          "15540:   tls.thread_idx = (unsigned)mg_atomic_inc(&thread_idx_max);",
          "15542:   tls.pthread_cond_helper_mutex = CreateEvent(NULL, FALSE, FALSE, NULL);",
          "15546:   pthread_setspecific(sTlsKey, &tls);",
          "15548:   if (ctx->callbacks.init_thread) {",
          "15550:    ctx->callbacks.init_thread(ctx, 1);",
          "15551:   }",
          "15554:   if (((int)thread_args->index < 0)",
          "15555:       || ((unsigned)thread_args->index",
          "15556:           >= (unsigned)ctx->cfg_worker_threads)) {",
          "15557:    mg_cry(fc(ctx),",
          "15558:           \"Internal error: Invalid worker index %i\",",
          "15559:           (int)thread_args->index);",
          "15560:    return NULL;",
          "15561:   }",
          "15562:   conn = ctx->worker_connections + thread_args->index;",
          "15567:   conn->buf = (char *)mg_malloc_ctx(ctx->max_request_size, conn->ctx);",
          "15568:   if (conn->buf == NULL) {",
          "15569:    mg_cry(fc(ctx),",
          "15570:           \"Out of memory: Cannot allocate buffer for worker %i\",",
          "15571:           (int)thread_args->index);",
          "15572:    return NULL;",
          "15573:   }",
          "15574:   conn->buf_size = (int)ctx->max_request_size;",
          "15576:   conn->ctx = ctx;",
          "15577:   conn->thread_index = thread_args->index;",
          "15578:   conn->request_info.user_data = ctx->user_data;",
          "15582:   (void)pthread_mutex_init(&conn->mutex, &pthread_mutex_attr);",
          "15587:   while (consume_socket(ctx, &conn->client, conn->thread_index)) {",
          "15588:    conn->conn_birth_time = time(NULL);",
          "15595:    if (conn->client.rsa.sa.sa_family == AF_INET6) {",
          "15596:     conn->request_info.remote_port =",
          "15597:         ntohs(conn->client.rsa.sin6.sin6_port);",
          "15598:    } else",
          "15600:    {",
          "15601:     conn->request_info.remote_port =",
          "15602:         ntohs(conn->client.rsa.sin.sin_port);",
          "15603:    }",
          "15605:    sockaddr_to_string(conn->request_info.remote_addr,",
          "15606:                       sizeof(conn->request_info.remote_addr),",
          "15607:                       &conn->client.rsa);",
          "15609:    DEBUG_TRACE(\"Start processing connection from %s\",",
          "15610:                conn->request_info.remote_addr);",
          "15614:    addr = ntohl(conn->client.rsa.sin.sin_addr.s_addr);",
          "15615:    memcpy(&conn->request_info.remote_ip, &addr, 4);",
          "15618:    conn->request_info.is_ssl = conn->client.is_ssl;",
          "15620:    if (conn->client.is_ssl) {",
          "15623:     if (sslize(conn,",
          "15624:                conn->ctx->ssl_ctx,",
          "15625:                SSL_accept,",
          "15626:                &(conn->ctx->stop_flag))) {",
          "15628:      ssl_get_client_cert_info(conn);",
          "15631:      process_new_connection(conn);",
          "15634:      if (conn->request_info.client_cert) {",
          "15635:       mg_free(",
          "15636:           (void *)(conn->request_info.client_cert->subject));",
          "15637:       mg_free(",
          "15638:           (void *)(conn->request_info.client_cert->issuer));",
          "15639:       mg_free(",
          "15640:           (void *)(conn->request_info.client_cert->serial));",
          "15641:       mg_free(",
          "15642:           (void *)(conn->request_info.client_cert->finger));",
          "15643:       conn->request_info.client_cert->subject = 0;",
          "15644:       conn->request_info.client_cert->issuer = 0;",
          "15645:       conn->request_info.client_cert->serial = 0;",
          "15646:       conn->request_info.client_cert->finger = 0;",
          "15647:       mg_free(conn->request_info.client_cert);",
          "15648:       conn->request_info.client_cert = 0;",
          "15649:      }",
          "15652:    } else {",
          "15654:     process_new_connection(conn);",
          "15655:    }",
          "15657:    DEBUG_TRACE(\"Done processing connection from %s (%f sec)\",",
          "15658:                conn->request_info.remote_addr,",
          "15659:                difftime(time(NULL), conn->conn_birth_time));",
          "15661:    close_connection(conn);",
          "15663:    DEBUG_TRACE(\"%s\", \"Connection closed\");",
          "15664:   }",
          "15667:   pthread_setspecific(sTlsKey, NULL);",
          "15669:   CloseHandle(tls.pthread_cond_helper_mutex);",
          "15671:   pthread_mutex_destroy(&conn->mutex);",
          "15674:   conn->buf_size = 0;",
          "15675:   mg_free(conn->buf);",
          "15676:   conn->buf = NULL;",
          "15678:   DEBUG_TRACE(\"%s\", \"exiting\");",
          "15679:   return NULL;",
          "15680:  }",
          "15685:  static unsigned __stdcall worker_thread(void *thread_func_param)",
          "15686:  {",
          "15687:   struct worker_thread_args *pwta =",
          "15688:       (struct worker_thread_args *)thread_func_param;",
          "15689:   worker_thread_run(pwta);",
          "15690:   mg_free(thread_func_param);",
          "15691:   return 0;",
          "15692:  }",
          "",
          "---------------",
          "--- Hunk 62 ---",
          "[Context before]",
          "15684:   }",
          "15698:    mg_cry(fc(ctx),",
          "15700:           __func__,",
          "15714:     mg_cry(fc(ctx),",
          "15716:            __func__,",
          "15717:            strerror(ERRNO));",
          "15718:    }",
          "15729:  }",
          "15749: #if defined(_WIN32)",
          "15751: #elif defined(USE_MASTER_THREAD_PRIORITY)",
          "15752:  int min_prio = sched_get_priority_min(SCHED_RR);",
          "15753:  int max_prio = sched_get_priority_max(SCHED_RR);",
          "",
          "[Removed Lines]",
          "15655: static void",
          "15656: accept_new_connection(const struct socket *listener, struct mg_context *ctx)",
          "15657: {",
          "15658:  struct socket so;",
          "15659:  char src_addr[IP_ADDR_STR_LEN];",
          "15660:  socklen_t len = sizeof(so.rsa);",
          "15661:  int on = 1;",
          "15663:  if (!listener) {",
          "15664:   return;",
          "15665:  }",
          "15667:  if ((so.sock = accept(listener->sock, &so.rsa.sa, &len))",
          "15668:      == INVALID_SOCKET) {",
          "15669:  } else if (!check_acl(ctx, ntohl(*(uint32_t *)&so.rsa.sin.sin_addr))) {",
          "15670:   sockaddr_to_string(src_addr, sizeof(src_addr), &so.rsa);",
          "15671:   mg_cry(fc(ctx), \"%s: %s is not allowed to connect\", __func__, src_addr);",
          "15672:   closesocket(so.sock);",
          "15673:  } else {",
          "15675:   DEBUG_TRACE(\"Accepted socket %d\", (int)so.sock);",
          "15676:   set_close_on_exec(so.sock, fc(ctx));",
          "15677:   so.is_ssl = listener->is_ssl;",
          "15678:   so.ssl_redir = listener->ssl_redir;",
          "15679:   if (getsockname(so.sock, &so.lsa.sa, &len) != 0) {",
          "15680:    mg_cry(fc(ctx),",
          "15681:           \"%s: getsockname() failed: %s\",",
          "15682:           __func__,",
          "15683:           strerror(ERRNO));",
          "15693:   if (setsockopt(so.sock,",
          "15694:                  SOL_SOCKET,",
          "15695:                  SO_KEEPALIVE,",
          "15696:                  (SOCK_OPT_TYPE)&on,",
          "15697:                  sizeof(on)) != 0) {",
          "15699:           \"%s: setsockopt(SOL_SOCKET SO_KEEPALIVE) failed: %s\",",
          "15701:           strerror(ERRNO));",
          "15702:   }",
          "15711:   if ((ctx != NULL) && (ctx->config[CONFIG_TCP_NODELAY] != NULL)",
          "15712:       && (!strcmp(ctx->config[CONFIG_TCP_NODELAY], \"1\"))) {",
          "15713:    if (set_tcp_nodelay(so.sock, 1) != 0) {",
          "15715:            \"%s: setsockopt(IPPROTO_TCP TCP_NODELAY) failed: %s\",",
          "15719:   }",
          "15725:   set_blocking_mode(so.sock, 0);",
          "15727:   so.in_use = 0;",
          "15728:   produce_socket(ctx, &so);",
          "15730: }",
          "15733: static void",
          "15734: master_thread_run(void *thread_func_param)",
          "15735: {",
          "15736:  struct mg_context *ctx = (struct mg_context *)thread_func_param;",
          "15737:  struct mg_workerTLS tls;",
          "15738:  struct pollfd *pfd;",
          "15739:  unsigned int i;",
          "15740:  unsigned int workerthreadcount;",
          "15742:  if (!ctx) {",
          "15743:   return;",
          "15744:  }",
          "15746:  mg_set_thread_name(\"master\");",
          "15750:  SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_ABOVE_NORMAL);",
          "",
          "[Added Lines]",
          "15706:  static void accept_new_connection(const struct socket *listener,",
          "15707:                                    struct mg_context *ctx)",
          "15708:  {",
          "15709:   struct socket so;",
          "15710:   char src_addr[IP_ADDR_STR_LEN];",
          "15711:   socklen_t len = sizeof(so.rsa);",
          "15712:   int on = 1;",
          "15714:   if (!listener) {",
          "15715:    return;",
          "15718:   if ((so.sock = accept(listener->sock, &so.rsa.sa, &len))",
          "15719:       == INVALID_SOCKET) {",
          "15720:   } else if (!check_acl(ctx, ntohl(*(uint32_t *)&so.rsa.sin.sin_addr))) {",
          "15721:    sockaddr_to_string(src_addr, sizeof(src_addr), &so.rsa);",
          "15723:           \"%s: %s is not allowed to connect\",",
          "15725:           src_addr);",
          "15726:    closesocket(so.sock);",
          "15727:   } else {",
          "15729:    DEBUG_TRACE(\"Accepted socket %d\", (int)so.sock);",
          "15730:    set_close_on_exec(so.sock, fc(ctx));",
          "15731:    so.is_ssl = listener->is_ssl;",
          "15732:    so.ssl_redir = listener->ssl_redir;",
          "15733:    if (getsockname(so.sock, &so.lsa.sa, &len) != 0) {",
          "15734:     mg_cry(fc(ctx),",
          "15735:            \"%s: getsockname() failed: %s\",",
          "15736:            __func__,",
          "15737:            strerror(ERRNO));",
          "15738:    }",
          "15747:    if (setsockopt(so.sock,",
          "15748:                   SOL_SOCKET,",
          "15749:                   SO_KEEPALIVE,",
          "15750:                   (SOCK_OPT_TYPE)&on,",
          "15751:                   sizeof(on)) != 0) {",
          "15753:            \"%s: setsockopt(SOL_SOCKET SO_KEEPALIVE) failed: %s\",",
          "15765:    if ((ctx != NULL) && (ctx->config[CONFIG_TCP_NODELAY] != NULL)",
          "15766:        && (!strcmp(ctx->config[CONFIG_TCP_NODELAY], \"1\"))) {",
          "15767:     if (set_tcp_nodelay(so.sock, 1) != 0) {",
          "15768:      mg_cry(fc(ctx),",
          "15769:             \"%s: setsockopt(IPPROTO_TCP TCP_NODELAY) failed: %s\",",
          "15770:             __func__,",
          "15771:             strerror(ERRNO));",
          "15772:     }",
          "15773:    }",
          "15779:    set_blocking_mode(so.sock, 0);",
          "15781:    so.in_use = 0;",
          "15782:    produce_socket(ctx, &so);",
          "15783:   }",
          "15787:  static void master_thread_run(void *thread_func_param)",
          "15788:  {",
          "15789:   struct mg_context *ctx = (struct mg_context *)thread_func_param;",
          "15790:   struct mg_workerTLS tls;",
          "15791:   struct pollfd *pfd;",
          "15792:   unsigned int i;",
          "15793:   unsigned int workerthreadcount;",
          "15795:   if (!ctx) {",
          "15796:    return;",
          "15797:   }",
          "15799:   mg_set_thread_name(\"master\");",
          "15803:   SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_ABOVE_NORMAL);",
          "",
          "---------------",
          "--- Hunk 63 ---",
          "[Context before]",
          "15764: #if defined(_WIN32) && !defined(__SYMBIAN32__)",
          "15766: #endif",
          "15784:   }",
          "15787:    for (i = 0; i < ctx->num_listening_sockets; i++) {",
          "15795:     }",
          "15796:    }",
          "15797:   }",
          "15808: #if defined(ALTERNATIVE_QUEUE)",
          "15815:   }",
          "15817: #else",
          "15818:  pthread_cond_broadcast(&ctx->sq_full);",
          "15819: #endif",
          "15827:   }",
          "15830: #if defined(USE_LUA)",
          "15836: #endif",
          "15840: #if defined(_WIN32) && !defined(__SYMBIAN32__)",
          "15842: #endif",
          "15853: #ifdef _WIN32",
          "15859: #else",
          "15860: static void *",
          "15861: master_thread(void *thread_func_param)",
          "",
          "[Removed Lines]",
          "15765:  tls.pthread_cond_helper_mutex = CreateEvent(NULL, FALSE, FALSE, NULL);",
          "15767:  tls.is_master = 1;",
          "15768:  pthread_setspecific(sTlsKey, &tls);",
          "15770:  if (ctx->callbacks.init_thread) {",
          "15772:   ctx->callbacks.init_thread(ctx, 0);",
          "15773:  }",
          "15776:  ctx->start_time = time(NULL);",
          "15779:  pfd = ctx->listening_socket_fds;",
          "15780:  while (ctx->stop_flag == 0) {",
          "15781:   for (i = 0; i < ctx->num_listening_sockets; i++) {",
          "15782:    pfd[i].fd = ctx->listening_sockets[i].sock;",
          "15783:    pfd[i].events = POLLIN;",
          "15786:   if (poll(pfd, ctx->num_listening_sockets, 200) > 0) {",
          "15793:     if ((ctx->stop_flag == 0) && (pfd[i].revents & POLLIN)) {",
          "15794:      accept_new_connection(&ctx->listening_sockets[i], ctx);",
          "15798:  }",
          "15801:  DEBUG_TRACE(\"%s\", \"stopping workers\");",
          "15804:  close_all_listening_sockets(ctx);",
          "15807:  (void)pthread_mutex_lock(&ctx->thread_mutex);",
          "15809:  for (i = 0; i < ctx->cfg_worker_threads; i++) {",
          "15810:   event_signal(ctx->client_wait_events[i]);",
          "15813:   if (ctx->client_socks[i].in_use) {",
          "15814:    shutdown(ctx->client_socks[i].sock, SHUTDOWN_BOTH);",
          "15816:  }",
          "15820:  (void)pthread_mutex_unlock(&ctx->thread_mutex);",
          "15823:  workerthreadcount = ctx->cfg_worker_threads;",
          "15824:  for (i = 0; i < workerthreadcount; i++) {",
          "15825:   if (ctx->worker_threadids[i] != 0) {",
          "15826:    mg_join_thread(ctx->worker_threadids[i]);",
          "15828:  }",
          "15832:  if (ctx->lua_background_state) {",
          "15833:   lua_close((lua_State *)ctx->lua_background_state);",
          "15834:   ctx->lua_background_state = 0;",
          "15835:  }",
          "15838:  DEBUG_TRACE(\"%s\", \"exiting\");",
          "15841:  CloseHandle(tls.pthread_cond_helper_mutex);",
          "15843:  pthread_setspecific(sTlsKey, NULL);",
          "15848:  ctx->stop_flag = 2;",
          "15849: }",
          "15854: static unsigned __stdcall master_thread(void *thread_func_param)",
          "15855: {",
          "15856:  master_thread_run(thread_func_param);",
          "15857:  return 0;",
          "15858: }",
          "",
          "[Added Lines]",
          "15818:   tls.pthread_cond_helper_mutex = CreateEvent(NULL, FALSE, FALSE, NULL);",
          "15820:   tls.is_master = 1;",
          "15821:   pthread_setspecific(sTlsKey, &tls);",
          "15823:   if (ctx->callbacks.init_thread) {",
          "15825:    ctx->callbacks.init_thread(ctx, 0);",
          "15829:   ctx->start_time = time(NULL);",
          "15832:   pfd = ctx->listening_socket_fds;",
          "15833:   while (ctx->stop_flag == 0) {",
          "15835:     pfd[i].fd = ctx->listening_sockets[i].sock;",
          "15836:     pfd[i].events = POLLIN;",
          "15837:    }",
          "15839:    if (poll(pfd, ctx->num_listening_sockets, 200) > 0) {",
          "15840:     for (i = 0; i < ctx->num_listening_sockets; i++) {",
          "15846:      if ((ctx->stop_flag == 0) && (pfd[i].revents & POLLIN)) {",
          "15847:       accept_new_connection(&ctx->listening_sockets[i], ctx);",
          "15848:      }",
          "15854:   DEBUG_TRACE(\"%s\", \"stopping workers\");",
          "15857:   close_all_listening_sockets(ctx);",
          "15860:   (void)pthread_mutex_lock(&ctx->thread_mutex);",
          "15862:   for (i = 0; i < ctx->cfg_worker_threads; i++) {",
          "15863:    event_signal(ctx->client_wait_events[i]);",
          "15866:    if (ctx->client_socks[i].in_use) {",
          "15867:     shutdown(ctx->client_socks[i].sock, SHUTDOWN_BOTH);",
          "15868:    }",
          "15873:   (void)pthread_mutex_unlock(&ctx->thread_mutex);",
          "15876:   workerthreadcount = ctx->cfg_worker_threads;",
          "15877:   for (i = 0; i < workerthreadcount; i++) {",
          "15878:    if (ctx->worker_threadids[i] != 0) {",
          "15879:     mg_join_thread(ctx->worker_threadids[i]);",
          "15880:    }",
          "15885:   if (ctx->lua_background_state) {",
          "15886:    lua_close((lua_State *)ctx->lua_background_state);",
          "15887:    ctx->lua_background_state = 0;",
          "15888:   }",
          "15891:   DEBUG_TRACE(\"%s\", \"exiting\");",
          "15894:   CloseHandle(tls.pthread_cond_helper_mutex);",
          "15896:   pthread_setspecific(sTlsKey, NULL);",
          "15901:   ctx->stop_flag = 2;",
          "15902:  }",
          "15907:  static unsigned __stdcall master_thread(void *thread_func_param)",
          "15908:  {",
          "15909:   master_thread_run(thread_func_param);",
          "15910:   return 0;",
          "15911:  }",
          "",
          "---------------",
          "--- Hunk 64 ---",
          "[Context before]",
          "15887: #if defined(ALTERNATIVE_QUEUE)",
          "15893: #else",
          "15894:  (void)pthread_cond_destroy(&ctx->sq_empty);",
          "15895:  (void)pthread_cond_destroy(&ctx->sq_full);",
          "15896: #endif",
          "15901: #if defined(USE_TIMERS)",
          "15903: #endif",
          "15908: #if defined(_MSC_VER)",
          "15909: #pragma warning(suppress : 6001)",
          "15910: #endif",
          "15912:   }",
          "15923: #ifndef NO_SSL",
          "15976: #if defined(_WIN32) && !defined(__SYMBIAN32__)",
          "15985: #if defined(_WIN32)",
          "15986: #if !defined(__SYMBIAN32__)",
          "15987: #if defined(_WIN32_WCE)",
          "15989: #else",
          "15997: #ifdef _MSC_VER",
          "15998: #pragma warning(push)",
          "16000: #pragma warning(disable : 4996)",
          "16001: #endif",
          "16003: #ifdef _MSC_VER",
          "16004: #pragma warning(pop)",
          "16005: #endif",
          "16021: #endif",
          "16022: #else",
          "",
          "[Removed Lines]",
          "15869: static void",
          "15870: free_context(struct mg_context *ctx)",
          "15871: {",
          "15872:  int i;",
          "15873:  struct mg_handler_info *tmp_rh;",
          "15875:  if (ctx == NULL) {",
          "15876:   return;",
          "15877:  }",
          "15879:  if (ctx->callbacks.exit_context) {",
          "15880:   ctx->callbacks.exit_context(ctx);",
          "15881:  }",
          "15886:  (void)pthread_mutex_destroy(&ctx->thread_mutex);",
          "15888:  mg_free(ctx->client_socks);",
          "15889:  for (i = 0; (unsigned)i < ctx->cfg_worker_threads; i++) {",
          "15890:   event_destroy(ctx->client_wait_events[i]);",
          "15891:  }",
          "15892:  mg_free(ctx->client_wait_events);",
          "15899:  (void)pthread_mutex_destroy(&ctx->nonce_mutex);",
          "15902:  timers_exit(ctx);",
          "15906:  for (i = 0; i < NUM_OPTIONS; i++) {",
          "15907:   if (ctx->config[i] != NULL) {",
          "15911:    mg_free(ctx->config[i]);",
          "15913:  }",
          "15916:  while (ctx->handlers) {",
          "15917:   tmp_rh = ctx->handlers;",
          "15918:   ctx->handlers = tmp_rh->next;",
          "15919:   mg_free(tmp_rh->uri);",
          "15920:   mg_free(tmp_rh);",
          "15921:  }",
          "15925:  if (ctx->ssl_ctx != NULL) {",
          "15926:   SSL_CTX_free(ctx->ssl_ctx);",
          "15927:  }",
          "15931:  if (ctx->worker_threadids != NULL) {",
          "15932:   mg_free(ctx->worker_threadids);",
          "15933:  }",
          "15936:  if (ctx->worker_connections != NULL) {",
          "15937:   mg_free(ctx->worker_connections);",
          "15938:  }",
          "15941:  mg_free(ctx->systemName);",
          "15944:  mg_free(ctx);",
          "15945: }",
          "15948: void",
          "15949: mg_stop(struct mg_context *ctx)",
          "15950: {",
          "15951:  pthread_t mt;",
          "15952:  if (!ctx) {",
          "15953:   return;",
          "15954:  }",
          "15958:  mt = ctx->masterthreadid;",
          "15959:  if (mt == 0) {",
          "15960:   return;",
          "15961:  }",
          "15963:  ctx->masterthreadid = 0;",
          "15966:  ctx->stop_flag = 1;",
          "15969:  while (ctx->stop_flag != 2) {",
          "15970:   (void)mg_sleep(10);",
          "15971:  }",
          "15973:  mg_join_thread(mt);",
          "15974:  free_context(ctx);",
          "15977:  (void)WSACleanup();",
          "15979: }",
          "15982: static void",
          "15983: get_system_name(char **sysName)",
          "15984: {",
          "15990:  char name[128];",
          "15991:  DWORD dwVersion = 0;",
          "15992:  DWORD dwMajorVersion = 0;",
          "15993:  DWORD dwMinorVersion = 0;",
          "15994:  DWORD dwBuild = 0;",
          "15995:  BOOL wowRet, isWoW = FALSE;",
          "16002:  dwVersion = GetVersion();",
          "16007:  dwMajorVersion = (DWORD)(LOBYTE(LOWORD(dwVersion)));",
          "16008:  dwMinorVersion = (DWORD)(HIBYTE(LOWORD(dwVersion)));",
          "16009:  dwBuild = ((dwVersion < 0x80000000) ? (DWORD)(HIWORD(dwVersion)) : 0);",
          "16010:  (void)dwBuild;",
          "16012:  wowRet = IsWow64Process(GetCurrentProcess(), &isWoW);",
          "16014:  sprintf(name,",
          "16015:          \"Windows %u.%u%s\",",
          "16016:          (unsigned)dwMajorVersion,",
          "16017:          (unsigned)dwMinorVersion,",
          "16018:          (wowRet ? (isWoW ? \" (WoW64)\" : \"\") : \" (?)\"));",
          "",
          "[Added Lines]",
          "15922:  static void free_context(struct mg_context * ctx)",
          "15923:  {",
          "15924:   int i;",
          "15925:   struct mg_handler_info *tmp_rh;",
          "15927:   if (ctx == NULL) {",
          "15928:    return;",
          "15929:   }",
          "15931:   if (ctx->callbacks.exit_context) {",
          "15932:    ctx->callbacks.exit_context(ctx);",
          "15933:   }",
          "15938:   (void)pthread_mutex_destroy(&ctx->thread_mutex);",
          "15940:   mg_free(ctx->client_socks);",
          "15941:   for (i = 0; (unsigned)i < ctx->cfg_worker_threads; i++) {",
          "15942:    event_destroy(ctx->client_wait_events[i]);",
          "15943:   }",
          "15944:   mg_free(ctx->client_wait_events);",
          "15951:   (void)pthread_mutex_destroy(&ctx->nonce_mutex);",
          "15954:   timers_exit(ctx);",
          "15958:   for (i = 0; i < NUM_OPTIONS; i++) {",
          "15959:    if (ctx->config[i] != NULL) {",
          "15963:     mg_free(ctx->config[i]);",
          "15964:    }",
          "15968:   while (ctx->handlers) {",
          "15969:    tmp_rh = ctx->handlers;",
          "15970:    ctx->handlers = tmp_rh->next;",
          "15971:    mg_free(tmp_rh->uri);",
          "15972:    mg_free(tmp_rh);",
          "15973:   }",
          "15977:   if (ctx->ssl_ctx != NULL) {",
          "15978:    SSL_CTX_free(ctx->ssl_ctx);",
          "15979:   }",
          "15983:   if (ctx->worker_threadids != NULL) {",
          "15984:    mg_free(ctx->worker_threadids);",
          "15985:   }",
          "15988:   if (ctx->worker_connections != NULL) {",
          "15989:    mg_free(ctx->worker_connections);",
          "15990:   }",
          "15993:   mg_free(ctx->systemName);",
          "15996:   mg_free(ctx);",
          "15997:  }",
          "16000:  void mg_stop(struct mg_context * ctx)",
          "16001:  {",
          "16002:   pthread_t mt;",
          "16003:   if (!ctx) {",
          "16004:    return;",
          "16005:   }",
          "16009:   mt = ctx->masterthreadid;",
          "16010:   if (mt == 0) {",
          "16011:    return;",
          "16012:   }",
          "16014:   ctx->masterthreadid = 0;",
          "16017:   ctx->stop_flag = 1;",
          "16020:   while (ctx->stop_flag != 2) {",
          "16021:    (void)mg_sleep(10);",
          "16022:   }",
          "16024:   mg_join_thread(mt);",
          "16025:   free_context(ctx);",
          "16028:   (void)WSACleanup();",
          "16030:  }",
          "16033:  static void get_system_name(char **sysName)",
          "16034:  {",
          "16040:   char name[128];",
          "16041:   DWORD dwVersion = 0;",
          "16042:   DWORD dwMajorVersion = 0;",
          "16043:   DWORD dwMinorVersion = 0;",
          "16044:   DWORD dwBuild = 0;",
          "16045:   BOOL wowRet, isWoW = FALSE;",
          "16052:   dwVersion = GetVersion();",
          "16057:   dwMajorVersion = (DWORD)(LOBYTE(LOWORD(dwVersion)));",
          "16058:   dwMinorVersion = (DWORD)(HIBYTE(LOWORD(dwVersion)));",
          "16059:   dwBuild = ((dwVersion < 0x80000000) ? (DWORD)(HIWORD(dwVersion)) : 0);",
          "16060:   (void)dwBuild;",
          "16062:   wowRet = IsWow64Process(GetCurrentProcess(), &isWoW);",
          "16064:   sprintf(name,",
          "16065:           \"Windows %u.%u%s\",",
          "16066:           (unsigned)dwMajorVersion,",
          "16067:           (unsigned)dwMinorVersion,",
          "16068:           (wowRet ? (isWoW ? \" (WoW64)\" : \"\") : \" (?)\"));",
          "",
          "---------------",
          "--- Hunk 65 ---",
          "[Context before]",
          "16028:  uname(&name);",
          "16030: #endif",
          "16048: #if defined(_WIN32) && !defined(__SYMBIAN32__)",
          "16070: #if defined(_WIN32) && !defined(__SYMBIAN32__)",
          "16072: #endif",
          "16076: #if !defined(ALTERNATIVE_QUEUE)",
          "16098: #if defined(USE_LUA) && defined(USE_WEBSOCKET)",
          "16100: #endif",
          "16105:    free_context(ctx);",
          "16106:    pthread_setspecific(sTlsKey, NULL);",
          "16107:    return NULL;",
          "16110:    free_context(ctx);",
          "16111:    pthread_setspecific(sTlsKey, NULL);",
          "16112:    return NULL;",
          "16113:   }",
          "16127:   }",
          "16156: #if defined(NO_FILES)",
          "16163: #endif",
          "16167: #if defined(USE_LUA)",
          "16178:   }",
          "16183: #endif",
          "16188: #if !defined(NO_SSL)",
          "16190: #endif",
          "16192: #if !defined(_WIN32)",
          "16194: #endif",
          "16201: #if !defined(_WIN32) && !defined(__SYMBIAN32__)",
          "16229: #if defined(ALTERNATIVE_QUEUE)",
          "16261:    mg_free(ctx->client_socks);",
          "16262:    mg_free(ctx->worker_threadids);",
          "16263:    free_context(ctx);",
          "16264:    pthread_setspecific(sTlsKey, NULL);",
          "16265:    return NULL;",
          "16266:   }",
          "16268: #endif",
          "16271: #if defined(USE_TIMERS)",
          "16278: #endif",
          "16297:   }",
          "16307:    }",
          "16321:    }",
          "16323:   }",
          "16339: #if !defined(NO_FILES)",
          "16341: #endif",
          "16342: #if !defined(NO_SSL)",
          "16344: #endif",
          "16345: #if !defined(NO_CGI)",
          "16347: #endif",
          "16348: #if defined(USE_IPV6)",
          "16350: #endif",
          "16351: #if defined(USE_WEBSOCKET)",
          "16353: #endif",
          "16354: #if defined(USE_LUA)",
          "16356: #endif",
          "16357: #if defined(USE_DUKTAPE)",
          "16359: #endif",
          "16360: #if !defined(NO_CACHING)",
          "16362: #endif",
          "16363: #if defined(USE_SERVER_STATS)",
          "16365: #endif",
          "16369: #if defined(MG_LEGACY_INTERFACE)",
          "16371: #endif",
          "16372: #if defined(MEMORY_DEBUGGING)",
          "16374: #endif",
          "16375: #if defined(USE_TIMERS)",
          "16377: #endif",
          "16378: #if !defined(NO_NONCE_CHECK)",
          "16380: #endif",
          "16381: #if !defined(NO_POPEN)",
          "16383: #endif",
          "16397: #if defined(_WIN32)",
          "16399: #else",
          "16400:  const char *eol = \"\\n\";",
          "16401: #endif",
          "16423:   }",
          "16428: #if defined(_WIN32)",
          "16429: #if !defined(__SYMBIAN32__)",
          "16437: #ifdef _MSC_VER",
          "16438: #pragma warning(push)",
          "16440: #pragma warning(disable : 4996)",
          "16441: #endif",
          "16443: #ifdef _MSC_VER",
          "16444: #pragma warning(pop)",
          "16445: #endif",
          "16477: #else",
          "16478:   mg_snprintf(NULL, NULL, block, sizeof(block), \"%s - Symbian%s\", eol);",
          "",
          "[Removed Lines]",
          "16031: }",
          "16034: struct mg_context *",
          "16035: mg_start(const struct mg_callbacks *callbacks,",
          "16036:          void *user_data,",
          "16037:          const char **options)",
          "16038: {",
          "16039:  struct mg_context *ctx;",
          "16040:  const char *name, *value, *default_value;",
          "16041:  int idx, ok, workerthreadcount;",
          "16042:  unsigned int i;",
          "16043:  int itmp;",
          "16044:  void (*exit_callback)(const struct mg_context *ctx) = 0;",
          "16046:  struct mg_workerTLS tls;",
          "16049:  WSADATA data;",
          "16050:  WSAStartup(MAKEWORD(2, 2), &data);",
          "16054:  if ((ctx = (struct mg_context *)mg_calloc(1, sizeof(*ctx))) == NULL) {",
          "16055:   return NULL;",
          "16056:  }",
          "16059:  ctx->auth_nonce_mask =",
          "16060:      (uint64_t)get_random() ^ (uint64_t)(ptrdiff_t)(options);",
          "16062:  if (mg_init_library_called == 0) {",
          "16065:   mg_init_library(0);",
          "16066:  }",
          "16068:  tls.is_master = -1;",
          "16069:  tls.thread_idx = (unsigned)mg_atomic_inc(&thread_idx_max);",
          "16071:  tls.pthread_cond_helper_mutex = NULL;",
          "16073:  pthread_setspecific(sTlsKey, &tls);",
          "16075:  ok = 0 == pthread_mutex_init(&ctx->thread_mutex, &pthread_mutex_attr);",
          "16077:  ok &= 0 == pthread_cond_init(&ctx->sq_empty, NULL);",
          "16078:  ok &= 0 == pthread_cond_init(&ctx->sq_full, NULL);",
          "16079: #endif",
          "16080:  ok &= 0 == pthread_mutex_init(&ctx->nonce_mutex, &pthread_mutex_attr);",
          "16081:  if (!ok) {",
          "16084:   mg_cry(fc(ctx), \"Cannot initialize thread synchronization objects\");",
          "16085:   mg_free(ctx);",
          "16086:   pthread_setspecific(sTlsKey, NULL);",
          "16087:   return NULL;",
          "16088:  }",
          "16090:  if (callbacks) {",
          "16091:   ctx->callbacks = *callbacks;",
          "16092:   exit_callback = callbacks->exit_context;",
          "16093:   ctx->callbacks.exit_context = 0;",
          "16094:  }",
          "16095:  ctx->user_data = user_data;",
          "16096:  ctx->handlers = NULL;",
          "16099:  ctx->shared_lua_websockets = 0;",
          "16102:  while (options && (name = *options++) != NULL) {",
          "16103:   if ((idx = get_option_index(name)) == -1) {",
          "16104:    mg_cry(fc(ctx), \"Invalid option: %s\", name);",
          "16108:   } else if ((value = *options++) == NULL) {",
          "16109:    mg_cry(fc(ctx), \"%s: option value cannot be NULL\", name);",
          "16114:   if (ctx->config[idx] != NULL) {",
          "16115:    mg_cry(fc(ctx), \"warning: %s: duplicate option\", name);",
          "16116:    mg_free(ctx->config[idx]);",
          "16117:   }",
          "16118:   ctx->config[idx] = mg_strdup(value);",
          "16119:   DEBUG_TRACE(\"[%s] -> [%s]\", name, value);",
          "16120:  }",
          "16123:  for (i = 0; config_options[i].name != NULL; i++) {",
          "16124:   default_value = config_options[i].default_value;",
          "16125:   if ((ctx->config[i] == NULL) && (default_value != NULL)) {",
          "16126:    ctx->config[i] = mg_strdup(default_value);",
          "16128:  }",
          "16130:  itmp = atoi(ctx->config[MAX_REQUEST_SIZE]);",
          "16132:  if (itmp < 1024) {",
          "16133:   mg_cry(fc(ctx), \"max_request_size too small\");",
          "16134:   free_context(ctx);",
          "16135:   pthread_setspecific(sTlsKey, NULL);",
          "16136:   return NULL;",
          "16137:  }",
          "16138:  ctx->max_request_size = (unsigned)itmp;",
          "16140:  workerthreadcount = atoi(ctx->config[NUM_THREADS]);",
          "16142:  if (workerthreadcount > MAX_WORKER_THREADS) {",
          "16143:   mg_cry(fc(ctx), \"Too many worker threads\");",
          "16144:   free_context(ctx);",
          "16145:   pthread_setspecific(sTlsKey, NULL);",
          "16146:   return NULL;",
          "16147:  }",
          "16149:  if (workerthreadcount <= 0) {",
          "16150:   mg_cry(fc(ctx), \"Invalid number of worker threads\");",
          "16151:   free_context(ctx);",
          "16152:   pthread_setspecific(sTlsKey, NULL);",
          "16153:   return NULL;",
          "16154:  }",
          "16157:  if (ctx->config[DOCUMENT_ROOT] != NULL) {",
          "16158:   mg_cry(fc(ctx), \"%s\", \"Document root must not be set\");",
          "16159:   free_context(ctx);",
          "16160:   pthread_setspecific(sTlsKey, NULL);",
          "16161:   return NULL;",
          "16162:  }",
          "16165:  get_system_name(&ctx->systemName);",
          "16169:  if (ctx->config[LUA_BACKGROUND_SCRIPT] != NULL) {",
          "16170:   char ebuf[256];",
          "16171:   void *state = (void *)mg_prepare_lua_context_script(",
          "16172:       ctx->config[LUA_BACKGROUND_SCRIPT], ctx, ebuf, sizeof(ebuf));",
          "16173:   if (!state) {",
          "16174:    mg_cry(fc(ctx), \"lua_background_script error: %s\", ebuf);",
          "16175:    free_context(ctx);",
          "16176:    pthread_setspecific(sTlsKey, NULL);",
          "16177:    return NULL;",
          "16179:   ctx->lua_background_state = state;",
          "16180:  } else {",
          "16181:   ctx->lua_background_state = 0;",
          "16182:  }",
          "16187:  if (!set_gpass_option(ctx) ||",
          "16189:      !set_ssl_option(ctx) ||",
          "16191:      !set_ports_option(ctx) ||",
          "16193:      !set_uid_option(ctx) ||",
          "16195:      !set_acl_option(ctx)) {",
          "16196:   free_context(ctx);",
          "16197:   pthread_setspecific(sTlsKey, NULL);",
          "16198:   return NULL;",
          "16199:  }",
          "16204:  (void)signal(SIGPIPE, SIG_IGN);",
          "16207:  ctx->cfg_worker_threads = ((unsigned int)(workerthreadcount));",
          "16208:  ctx->worker_threadids = (pthread_t *)mg_calloc_ctx(ctx->cfg_worker_threads,",
          "16209:                                                     sizeof(pthread_t),",
          "16210:                                                     ctx);",
          "16211:  if (ctx->worker_threadids == NULL) {",
          "16212:   mg_cry(fc(ctx), \"Not enough memory for worker thread ID array\");",
          "16213:   free_context(ctx);",
          "16214:   pthread_setspecific(sTlsKey, NULL);",
          "16215:   return NULL;",
          "16216:  }",
          "16217:  ctx->worker_connections =",
          "16218:      (struct mg_connection *)mg_calloc_ctx(ctx->cfg_worker_threads,",
          "16219:                                            sizeof(struct mg_connection),",
          "16220:                                            ctx);",
          "16221:  if (ctx->worker_connections == NULL) {",
          "16222:   mg_cry(fc(ctx), \"Not enough memory for worker thread connection array\");",
          "16223:   free_context(ctx);",
          "16224:   pthread_setspecific(sTlsKey, NULL);",
          "16225:   return NULL;",
          "16226:  }",
          "16230:  ctx->client_wait_events = mg_calloc_ctx(sizeof(ctx->client_wait_events[0]),",
          "16231:                                          ctx->cfg_worker_threads,",
          "16232:                                          ctx);",
          "16233:  if (ctx->client_wait_events == NULL) {",
          "16234:   mg_cry(fc(ctx), \"Not enough memory for worker event array\");",
          "16235:   mg_free(ctx->worker_threadids);",
          "16236:   free_context(ctx);",
          "16237:   pthread_setspecific(sTlsKey, NULL);",
          "16238:   return NULL;",
          "16239:  }",
          "16241:  ctx->client_socks = mg_calloc_ctx(sizeof(ctx->client_socks[0]),",
          "16242:                                    ctx->cfg_worker_threads,",
          "16243:                                    ctx);",
          "16244:  if (ctx->client_wait_events == NULL) {",
          "16245:   mg_cry(fc(ctx), \"Not enough memory for worker socket array\");",
          "16246:   mg_free(ctx->client_socks);",
          "16247:   mg_free(ctx->worker_threadids);",
          "16248:   free_context(ctx);",
          "16249:   pthread_setspecific(sTlsKey, NULL);",
          "16250:   return NULL;",
          "16251:  }",
          "16253:  for (i = 0; (unsigned)i < ctx->cfg_worker_threads; i++) {",
          "16254:   ctx->client_wait_events[i] = event_create();",
          "16255:   if (ctx->client_wait_events[i] == 0) {",
          "16256:    mg_cry(fc(ctx), \"Error creating worker event %i\", i);",
          "16257:    while (i > 0) {",
          "16258:     i--;",
          "16259:     event_destroy(ctx->client_wait_events[i]);",
          "16260:    }",
          "16267:  }",
          "16272:  if (timers_init(ctx) != 0) {",
          "16273:   mg_cry(fc(ctx), \"Error creating timers\");",
          "16274:   free_context(ctx);",
          "16275:   pthread_setspecific(sTlsKey, NULL);",
          "16276:   return NULL;",
          "16277:  }",
          "16281:  if (ctx->callbacks.init_context) {",
          "16282:   ctx->callbacks.init_context(ctx);",
          "16283:  }",
          "16284:  ctx->callbacks.exit_context = exit_callback;",
          "16288:  mg_start_thread_with_id(master_thread, ctx, &ctx->masterthreadid);",
          "16291:  for (i = 0; i < ctx->cfg_worker_threads; i++) {",
          "16292:   struct worker_thread_args *wta = (struct worker_thread_args *)",
          "16293:       mg_malloc_ctx(sizeof(struct worker_thread_args), ctx);",
          "16294:   if (wta) {",
          "16295:    wta->ctx = ctx;",
          "16296:    wta->index = (int)i;",
          "16299:   if ((wta == NULL)",
          "16300:       || (mg_start_thread_with_id(worker_thread,",
          "16301:                                   wta,",
          "16302:                                   &ctx->worker_threadids[i]) != 0)) {",
          "16305:    if (wta != NULL) {",
          "16306:     mg_free(wta);",
          "16309:    if (i > 0) {",
          "16310:     mg_cry(fc(ctx),",
          "16311:            \"Cannot start worker thread %i: error %ld\",",
          "16312:            i + 1,",
          "16313:            (long)ERRNO);",
          "16314:    } else {",
          "16315:     mg_cry(fc(ctx),",
          "16316:            \"Cannot create threads: error %ld\",",
          "16317:            (long)ERRNO);",
          "16318:     free_context(ctx);",
          "16319:     pthread_setspecific(sTlsKey, NULL);",
          "16320:     return NULL;",
          "16322:    break;",
          "16324:  }",
          "16326:  pthread_setspecific(sTlsKey, NULL);",
          "16327:  return ctx;",
          "16328: }",
          "16332: unsigned",
          "16333: mg_check_feature(unsigned feature)",
          "16334: {",
          "16335:  static const unsigned feature_set = 0",
          "16340:                                      | 0x0001u",
          "16343:                                      | 0x0002u",
          "16346:                                      | 0x0004u",
          "16349:                                      | 0x0008u",
          "16352:                                      | 0x0010u",
          "16355:                                      | 0x0020u",
          "16358:                                      | 0x0040u",
          "16361:                                      | 0x0080u",
          "16364:                                      | 0x0100u",
          "16370:                                      | 0x8000u",
          "16373:                                      | 0x0100u",
          "16376:                                      | 0x0200u",
          "16379:                                      | 0x0400u",
          "16382:                                      | 0x0800u",
          "16384:      ;",
          "16385:  return (feature & feature_set);",
          "16386: }",
          "16391: static int",
          "16392: mg_get_system_info_impl(char *buffer, int buflen)",
          "16393: {",
          "16394:  char block[256];",
          "16395:  int system_info_length = 0;",
          "16398:  const char *eol = \"\\r\\n\";",
          "16403:  if (buffer == NULL) {",
          "16407:   buflen = 0;",
          "16408:  }",
          "16411:  {",
          "16412:   const char *version = mg_version();",
          "16413:   mg_snprintf(NULL,",
          "16414:               NULL,",
          "16415:               block,",
          "16416:               sizeof(block),",
          "16417:               \"Server Version: %s%s\",",
          "16418:               version,",
          "16419:               eol);",
          "16420:   system_info_length += (int)strlen(block);",
          "16421:   if (system_info_length < buflen) {",
          "16422:    strcat(buffer, block);",
          "16424:  }",
          "16427:  {",
          "16430:   DWORD dwVersion = 0;",
          "16431:   DWORD dwMajorVersion = 0;",
          "16432:   DWORD dwMinorVersion = 0;",
          "16433:   SYSTEM_INFO si;",
          "16435:   GetSystemInfo(&si);",
          "16442:   dwVersion = GetVersion();",
          "16447:   dwMajorVersion = (DWORD)(LOBYTE(LOWORD(dwVersion)));",
          "16448:   dwMinorVersion = (DWORD)(HIBYTE(LOWORD(dwVersion)));",
          "16450:   mg_snprintf(NULL,",
          "16451:               NULL,",
          "16452:               block,",
          "16453:               sizeof(block),",
          "16454:               \"Windows %u.%u%s\",",
          "16455:               (unsigned)dwMajorVersion,",
          "16456:               (unsigned)dwMinorVersion,",
          "16457:               eol);",
          "16458:   system_info_length += (int)strlen(block);",
          "16459:   if (system_info_length < buflen) {",
          "16460:    strcat(buffer, block);",
          "16461:   }",
          "16463:   mg_snprintf(NULL,",
          "16464:               NULL,",
          "16465:               block,",
          "16466:               sizeof(block),",
          "16467:               \"CPU: type %u, cores %u, mask %x%s\",",
          "16468:               (unsigned)si.wProcessorArchitecture,",
          "16469:               (unsigned)si.dwNumberOfProcessors,",
          "16470:               (unsigned)si.dwActiveProcessorMask,",
          "16471:               eol);",
          "16472:   system_info_length += (int)strlen(block);",
          "16473:   if (system_info_length < buflen) {",
          "16474:    strcat(buffer, block);",
          "16475:   }",
          "",
          "[Added Lines]",
          "16081:  }",
          "16084:  struct mg_context *mg_start(const struct mg_callbacks *callbacks,",
          "16085:                              void *user_data,",
          "16086:                              const char **options)",
          "16087:  {",
          "16088:   struct mg_context *ctx;",
          "16089:   const char *name, *value, *default_value;",
          "16090:   int idx, ok, workerthreadcount;",
          "16091:   unsigned int i;",
          "16092:   int itmp;",
          "16093:   void (*exit_callback)(const struct mg_context *ctx) = 0;",
          "16095:   struct mg_workerTLS tls;",
          "16098:   WSADATA data;",
          "16099:   WSAStartup(MAKEWORD(2, 2), &data);",
          "16103:   if ((ctx = (struct mg_context *)mg_calloc(1, sizeof(*ctx))) == NULL) {",
          "16104:    return NULL;",
          "16105:   }",
          "16108:   ctx->auth_nonce_mask =",
          "16109:       (uint64_t)get_random() ^ (uint64_t)(ptrdiff_t)(options);",
          "16111:   if (mg_init_library_called == 0) {",
          "16114:    mg_init_library(0);",
          "16115:   }",
          "16117:   tls.is_master = -1;",
          "16118:   tls.thread_idx = (unsigned)mg_atomic_inc(&thread_idx_max);",
          "16120:   tls.pthread_cond_helper_mutex = NULL;",
          "16122:   pthread_setspecific(sTlsKey, &tls);",
          "16124:   ok = 0 == pthread_mutex_init(&ctx->thread_mutex, &pthread_mutex_attr);",
          "16126:   ok &= 0 == pthread_cond_init(&ctx->sq_empty, NULL);",
          "16127:   ok &= 0 == pthread_cond_init(&ctx->sq_full, NULL);",
          "16128: #endif",
          "16129:   ok &= 0 == pthread_mutex_init(&ctx->nonce_mutex, &pthread_mutex_attr);",
          "16130:   if (!ok) {",
          "16133:    mg_cry(fc(ctx), \"Cannot initialize thread synchronization objects\");",
          "16134:    mg_free(ctx);",
          "16135:    pthread_setspecific(sTlsKey, NULL);",
          "16136:    return NULL;",
          "16137:   }",
          "16139:   if (callbacks) {",
          "16140:    ctx->callbacks = *callbacks;",
          "16141:    exit_callback = callbacks->exit_context;",
          "16142:    ctx->callbacks.exit_context = 0;",
          "16143:   }",
          "16144:   ctx->user_data = user_data;",
          "16145:   ctx->handlers = NULL;",
          "16148:   ctx->shared_lua_websockets = 0;",
          "16151:   while (options && (name = *options++) != NULL) {",
          "16152:    if ((idx = get_option_index(name)) == -1) {",
          "16153:     mg_cry(fc(ctx), \"Invalid option: %s\", name);",
          "16154:     free_context(ctx);",
          "16155:     pthread_setspecific(sTlsKey, NULL);",
          "16156:     return NULL;",
          "16157:    } else if ((value = *options++) == NULL) {",
          "16158:     mg_cry(fc(ctx), \"%s: option value cannot be NULL\", name);",
          "16159:     free_context(ctx);",
          "16160:     pthread_setspecific(sTlsKey, NULL);",
          "16161:     return NULL;",
          "16162:    }",
          "16163:    if (ctx->config[idx] != NULL) {",
          "16164:     mg_cry(fc(ctx), \"warning: %s: duplicate option\", name);",
          "16165:     mg_free(ctx->config[idx]);",
          "16166:    }",
          "16167:    ctx->config[idx] = mg_strdup(value);",
          "16168:    DEBUG_TRACE(\"[%s] -> [%s]\", name, value);",
          "16169:   }",
          "16172:   for (i = 0; config_options[i].name != NULL; i++) {",
          "16173:    default_value = config_options[i].default_value;",
          "16174:    if ((ctx->config[i] == NULL) && (default_value != NULL)) {",
          "16175:     ctx->config[i] = mg_strdup(default_value);",
          "16176:    }",
          "16177:   }",
          "16179:   itmp = atoi(ctx->config[MAX_REQUEST_SIZE]);",
          "16181:   if (itmp < 1024) {",
          "16182:    mg_cry(fc(ctx), \"max_request_size too small\");",
          "16186:   }",
          "16187:   ctx->max_request_size = (unsigned)itmp;",
          "16189:   workerthreadcount = atoi(ctx->config[NUM_THREADS]);",
          "16191:   if (workerthreadcount > MAX_WORKER_THREADS) {",
          "16192:    mg_cry(fc(ctx), \"Too many worker threads\");",
          "16198:   if (workerthreadcount <= 0) {",
          "16199:    mg_cry(fc(ctx), \"Invalid number of worker threads\");",
          "16200:    free_context(ctx);",
          "16201:    pthread_setspecific(sTlsKey, NULL);",
          "16202:    return NULL;",
          "16206:   if (ctx->config[DOCUMENT_ROOT] != NULL) {",
          "16207:    mg_cry(fc(ctx), \"%s\", \"Document root must not be set\");",
          "16208:    free_context(ctx);",
          "16209:    pthread_setspecific(sTlsKey, NULL);",
          "16210:    return NULL;",
          "16211:   }",
          "16214:   get_system_name(&ctx->systemName);",
          "16218:   if (ctx->config[LUA_BACKGROUND_SCRIPT] != NULL) {",
          "16219:    char ebuf[256];",
          "16220:    void *state = (void *)mg_prepare_lua_context_script(",
          "16221:        ctx->config[LUA_BACKGROUND_SCRIPT], ctx, ebuf, sizeof(ebuf));",
          "16222:    if (!state) {",
          "16223:     mg_cry(fc(ctx), \"lua_background_script error: %s\", ebuf);",
          "16224:     free_context(ctx);",
          "16225:     pthread_setspecific(sTlsKey, NULL);",
          "16226:     return NULL;",
          "16227:    }",
          "16228:    ctx->lua_background_state = state;",
          "16229:   } else {",
          "16230:    ctx->lua_background_state = 0;",
          "16236:   if (!set_gpass_option(ctx) ||",
          "16238:       !set_ssl_option(ctx) ||",
          "16240:       !set_ports_option(ctx) ||",
          "16242:       !set_uid_option(ctx) ||",
          "16244:       !set_acl_option(ctx)) {",
          "16245:    free_context(ctx);",
          "16246:    pthread_setspecific(sTlsKey, NULL);",
          "16247:    return NULL;",
          "16248:   }",
          "16253:   (void)signal(SIGPIPE, SIG_IGN);",
          "16256:   ctx->cfg_worker_threads = ((unsigned int)(workerthreadcount));",
          "16257:   ctx->worker_threadids =",
          "16258:       (pthread_t *)mg_calloc_ctx(ctx->cfg_worker_threads,",
          "16259:                                  sizeof(pthread_t),",
          "16260:                                  ctx);",
          "16261:   if (ctx->worker_threadids == NULL) {",
          "16262:    mg_cry(fc(ctx), \"Not enough memory for worker thread ID array\");",
          "16263:    free_context(ctx);",
          "16264:    pthread_setspecific(sTlsKey, NULL);",
          "16265:    return NULL;",
          "16266:   }",
          "16267:   ctx->worker_connections =",
          "16268:       (struct mg_connection *)mg_calloc_ctx(ctx->cfg_worker_threads,",
          "16269:                                             sizeof(struct mg_connection),",
          "16270:                                             ctx);",
          "16271:   if (ctx->worker_connections == NULL) {",
          "16272:    mg_cry(fc(ctx),",
          "16273:           \"Not enough memory for worker thread connection array\");",
          "16274:    free_context(ctx);",
          "16275:    pthread_setspecific(sTlsKey, NULL);",
          "16276:    return NULL;",
          "16277:   }",
          "16281:   ctx->client_wait_events =",
          "16282:       mg_calloc_ctx(sizeof(ctx->client_wait_events[0]),",
          "16283:                     ctx->cfg_worker_threads,",
          "16284:                     ctx);",
          "16285:   if (ctx->client_wait_events == NULL) {",
          "16286:    mg_cry(fc(ctx), \"Not enough memory for worker event array\");",
          "16287:    mg_free(ctx->worker_threadids);",
          "16288:    free_context(ctx);",
          "16289:    pthread_setspecific(sTlsKey, NULL);",
          "16290:    return NULL;",
          "16291:   }",
          "16293:   ctx->client_socks = mg_calloc_ctx(sizeof(ctx->client_socks[0]),",
          "16294:                                     ctx->cfg_worker_threads,",
          "16295:                                     ctx);",
          "16296:   if (ctx->client_wait_events == NULL) {",
          "16297:    mg_cry(fc(ctx), \"Not enough memory for worker socket array\");",
          "16305:   for (i = 0; (unsigned)i < ctx->cfg_worker_threads; i++) {",
          "16306:    ctx->client_wait_events[i] = event_create();",
          "16307:    if (ctx->client_wait_events[i] == 0) {",
          "16308:     mg_cry(fc(ctx), \"Error creating worker event %i\", i);",
          "16309:     while (i > 0) {",
          "16310:      i--;",
          "16311:      event_destroy(ctx->client_wait_events[i]);",
          "16312:     }",
          "16313:     mg_free(ctx->client_socks);",
          "16314:     mg_free(ctx->worker_threadids);",
          "16315:     free_context(ctx);",
          "16316:     pthread_setspecific(sTlsKey, NULL);",
          "16317:     return NULL;",
          "16318:    }",
          "16319:   }",
          "16324:   if (timers_init(ctx) != 0) {",
          "16325:    mg_cry(fc(ctx), \"Error creating timers\");",
          "16326:    free_context(ctx);",
          "16327:    pthread_setspecific(sTlsKey, NULL);",
          "16328:    return NULL;",
          "16329:   }",
          "16333:   if (ctx->callbacks.init_context) {",
          "16334:    ctx->callbacks.init_context(ctx);",
          "16336:   ctx->callbacks.exit_context = exit_callback;",
          "16340:   mg_start_thread_with_id(master_thread, ctx, &ctx->masterthreadid);",
          "16343:   for (i = 0; i < ctx->cfg_worker_threads; i++) {",
          "16344:    struct worker_thread_args *wta = (struct worker_thread_args *)",
          "16345:        mg_malloc_ctx(sizeof(struct worker_thread_args), ctx);",
          "16346:    if (wta) {",
          "16347:     wta->ctx = ctx;",
          "16348:     wta->index = (int)i;",
          "16351:    if ((wta == NULL)",
          "16352:        || (mg_start_thread_with_id(worker_thread,",
          "16353:                                    wta,",
          "16354:                                    &ctx->worker_threadids[i]) != 0)) {",
          "16357:     if (wta != NULL) {",
          "16358:      mg_free(wta);",
          "16359:     }",
          "16361:     if (i > 0) {",
          "16362:      mg_cry(fc(ctx),",
          "16363:             \"Cannot start worker thread %i: error %ld\",",
          "16364:             i + 1,",
          "16365:             (long)ERRNO);",
          "16366:     } else {",
          "16367:      mg_cry(fc(ctx),",
          "16368:             \"Cannot create threads: error %ld\",",
          "16369:             (long)ERRNO);",
          "16370:      free_context(ctx);",
          "16371:      pthread_setspecific(sTlsKey, NULL);",
          "16372:      return NULL;",
          "16373:     }",
          "16374:     break;",
          "16378:   pthread_setspecific(sTlsKey, NULL);",
          "16379:   return ctx;",
          "16380:  }",
          "16384:  unsigned mg_check_feature(unsigned feature)",
          "16385:  {",
          "16386:   static const unsigned feature_set = 0",
          "16391:                                       | 0x0001u",
          "16394:                                       | 0x0002u",
          "16397:                                       | 0x0004u",
          "16400:                                       | 0x0008u",
          "16403:                                       | 0x0010u",
          "16406:                                       | 0x0020u",
          "16409:                                       | 0x0040u",
          "16412:                                       | 0x0080u",
          "16415:                                       | 0x0100u",
          "16421:                                       | 0x8000u",
          "16424:                                       | 0x0100u",
          "16427:                                       | 0x0200u",
          "16430:                                       | 0x0400u",
          "16433:                                       | 0x0800u",
          "16435:       ;",
          "16436:   return (feature & feature_set);",
          "16437:  }",
          "16442:  static int mg_get_system_info_impl(char *buffer, int buflen)",
          "16443:  {",
          "16444:   char block[256];",
          "16445:   int system_info_length = 0;",
          "16448:   const char *eol = \"\\r\\n\";",
          "16453:   if (buffer == NULL) {",
          "16457:    buflen = 0;",
          "16458:   }",
          "16461:   {",
          "16462:    const char *version = mg_version();",
          "16463:    mg_snprintf(NULL,",
          "16464:                NULL,",
          "16465:                block,",
          "16466:                sizeof(block),",
          "16467:                \"Server Version: %s%s\",",
          "16468:                version,",
          "16469:                eol);",
          "16470:    system_info_length += (int)strlen(block);",
          "16471:    if (system_info_length < buflen) {",
          "16472:     strcat(buffer, block);",
          "16473:    }",
          "16477:   {",
          "16480:    DWORD dwVersion = 0;",
          "16481:    DWORD dwMajorVersion = 0;",
          "16482:    DWORD dwMinorVersion = 0;",
          "16483:    SYSTEM_INFO si;",
          "16485:    GetSystemInfo(&si);",
          "16492:    dwVersion = GetVersion();",
          "16497:    dwMajorVersion = (DWORD)(LOBYTE(LOWORD(dwVersion)));",
          "16498:    dwMinorVersion = (DWORD)(HIBYTE(LOWORD(dwVersion)));",
          "16500:    mg_snprintf(NULL,",
          "16501:                NULL,",
          "16502:                block,",
          "16503:                sizeof(block),",
          "16504:                \"Windows %u.%u%s\",",
          "16505:                (unsigned)dwMajorVersion,",
          "16506:                (unsigned)dwMinorVersion,",
          "16507:                eol);",
          "16508:    system_info_length += (int)strlen(block);",
          "16509:    if (system_info_length < buflen) {",
          "16510:     strcat(buffer, block);",
          "16511:    }",
          "16513:    mg_snprintf(NULL,",
          "16514:                NULL,",
          "16515:                block,",
          "16516:                sizeof(block),",
          "16517:                \"CPU: type %u, cores %u, mask %x%s\",",
          "16518:                (unsigned)si.wProcessorArchitecture,",
          "16519:                (unsigned)si.dwNumberOfProcessors,",
          "16520:                (unsigned)si.dwActiveProcessorMask,",
          "16521:                eol);",
          "16522:    system_info_length += (int)strlen(block);",
          "16523:    if (system_info_length < buflen) {",
          "16524:     strcat(buffer, block);",
          "16525:    }",
          "",
          "---------------",
          "--- Hunk 66 ---",
          "[Context before]",
          "16501:    strcat(buffer, block);",
          "16502:   }",
          "16503: #endif",
          "16527:   }",
          "16529: #ifdef USE_LUA",
          "16542: #endif",
          "16543: #if defined(USE_DUKTAPE)",
          "16557: #endif",
          "16567:   }",
          "16574: #if defined(_MSC_VER)",
          "16587: #elif defined(__MINGW64__)",
          "16588:   mg_snprintf(NULL,",
          "16589:               NULL,",
          "",
          "[Removed Lines]",
          "16504:  }",
          "16507:  {",
          "16508:   mg_snprintf(NULL,",
          "16509:               NULL,",
          "16510:               block,",
          "16511:               sizeof(block),",
          "16512:               \"Features: %X%s%s%s%s%s%s%s%s%s%s\",",
          "16513:               mg_check_feature(0xFFFFFFFFu),",
          "16514:               eol,",
          "16515:               mg_check_feature(1) ? \" Files\" : \"\",",
          "16516:               mg_check_feature(2) ? \" HTTPS\" : \"\",",
          "16517:               mg_check_feature(4) ? \" CGI\" : \"\",",
          "16518:               mg_check_feature(8) ? \" IPv6\" : \"\",",
          "16519:               mg_check_feature(16) ? \" WebSockets\" : \"\",",
          "16520:               mg_check_feature(32) ? \" Lua\" : \"\",",
          "16521:               mg_check_feature(64) ? \" JavaScript\" : \"\",",
          "16522:               mg_check_feature(128) ? \" Cache\" : \"\",",
          "16523:               eol);",
          "16524:   system_info_length += (int)strlen(block);",
          "16525:   if (system_info_length < buflen) {",
          "16526:    strcat(buffer, block);",
          "16530:   mg_snprintf(NULL,",
          "16531:               NULL,",
          "16532:               block,",
          "16533:               sizeof(block),",
          "16534:               \"Lua Version: %u (%s)%s\",",
          "16535:               (unsigned)LUA_VERSION_NUM,",
          "16536:               LUA_RELEASE,",
          "16537:               eol);",
          "16538:   system_info_length += (int)strlen(block);",
          "16539:   if (system_info_length < buflen) {",
          "16540:    strcat(buffer, block);",
          "16541:   }",
          "16544:   mg_snprintf(NULL,",
          "16545:               NULL,",
          "16546:               block,",
          "16547:               sizeof(block),",
          "16548:               \"JavaScript: Duktape %u.%u.%u%s\",",
          "16549:               (unsigned)DUK_VERSION / 10000,",
          "16550:               ((unsigned)DUK_VERSION / 100) % 100,",
          "16551:               (unsigned)DUK_VERSION % 100,",
          "16552:               eol);",
          "16553:   system_info_length += (int)strlen(block);",
          "16554:   if (system_info_length < buflen) {",
          "16555:    strcat(buffer, block);",
          "16556:   }",
          "16558:  }",
          "16561:  {",
          "16562:   mg_snprintf(",
          "16563:       NULL, NULL, block, sizeof(block), \"Build: %s%s\", __DATE__, eol);",
          "16564:   system_info_length += (int)strlen(block);",
          "16565:   if (system_info_length < buflen) {",
          "16566:    strcat(buffer, block);",
          "16568:  }",
          "16573:  {",
          "16575:   mg_snprintf(NULL,",
          "16576:               NULL,",
          "16577:               block,",
          "16578:               sizeof(block),",
          "16579:               \"MSC: %u (%u)%s\",",
          "16580:               (unsigned)_MSC_VER,",
          "16581:               (unsigned)_MSC_FULL_VER,",
          "16582:               eol);",
          "16583:   system_info_length += (int)strlen(block);",
          "16584:   if (system_info_length < buflen) {",
          "16585:    strcat(buffer, block);",
          "16586:   }",
          "",
          "[Added Lines]",
          "16557:   {",
          "16558:    mg_snprintf(NULL,",
          "16559:                NULL,",
          "16560:                block,",
          "16561:                sizeof(block),",
          "16562:                \"Features: %X%s%s%s%s%s%s%s%s%s%s\",",
          "16563:                mg_check_feature(0xFFFFFFFFu),",
          "16564:                eol,",
          "16565:                mg_check_feature(1) ? \" Files\" : \"\",",
          "16566:                mg_check_feature(2) ? \" HTTPS\" : \"\",",
          "16567:                mg_check_feature(4) ? \" CGI\" : \"\",",
          "16568:                mg_check_feature(8) ? \" IPv6\" : \"\",",
          "16569:                mg_check_feature(16) ? \" WebSockets\" : \"\",",
          "16570:                mg_check_feature(32) ? \" Lua\" : \"\",",
          "16571:                mg_check_feature(64) ? \" JavaScript\" : \"\",",
          "16572:                mg_check_feature(128) ? \" Cache\" : \"\",",
          "16573:                eol);",
          "16574:    system_info_length += (int)strlen(block);",
          "16575:    if (system_info_length < buflen) {",
          "16576:     strcat(buffer, block);",
          "16577:    }",
          "16580:    mg_snprintf(NULL,",
          "16581:                NULL,",
          "16582:                block,",
          "16583:                sizeof(block),",
          "16584:                \"Lua Version: %u (%s)%s\",",
          "16585:                (unsigned)LUA_VERSION_NUM,",
          "16586:                LUA_RELEASE,",
          "16587:                eol);",
          "16588:    system_info_length += (int)strlen(block);",
          "16589:    if (system_info_length < buflen) {",
          "16590:     strcat(buffer, block);",
          "16591:    }",
          "16594:    mg_snprintf(NULL,",
          "16595:                NULL,",
          "16596:                block,",
          "16597:                sizeof(block),",
          "16598:                \"JavaScript: Duktape %u.%u.%u%s\",",
          "16599:                (unsigned)DUK_VERSION / 10000,",
          "16600:                ((unsigned)DUK_VERSION / 100) % 100,",
          "16601:                (unsigned)DUK_VERSION % 100,",
          "16602:                eol);",
          "16603:    system_info_length += (int)strlen(block);",
          "16604:    if (system_info_length < buflen) {",
          "16605:     strcat(buffer, block);",
          "16606:    }",
          "16608:   }",
          "16611:   {",
          "16612:    mg_snprintf(",
          "16613:        NULL, NULL, block, sizeof(block), \"Build: %s%s\", __DATE__, eol);",
          "16614:    system_info_length += (int)strlen(block);",
          "16615:    if (system_info_length < buflen) {",
          "16616:     strcat(buffer, block);",
          "16617:    }",
          "16623:   {",
          "16625:    mg_snprintf(NULL,",
          "16626:                NULL,",
          "16627:                block,",
          "16628:                sizeof(block),",
          "16629:                \"MSC: %u (%u)%s\",",
          "16630:                (unsigned)_MSC_VER,",
          "16631:                (unsigned)_MSC_FULL_VER,",
          "16632:                eol);",
          "16633:    system_info_length += (int)strlen(block);",
          "16634:    if (system_info_length < buflen) {",
          "16635:     strcat(buffer, block);",
          "16636:    }",
          "",
          "---------------",
          "--- Hunk 67 ---",
          "[Context before]",
          "16694:    strcat(buffer, block);",
          "16695:   }",
          "16696: #endif",
          "16724:   }",
          "16731: #if defined(USE_SERVER_STATS)",
          "16741: #if defined(_WIN32)",
          "16743: #else",
          "16744:  const char *eol = \"\\n\";",
          "16745: #endif",
          "16782:   context_info_length += (int)strlen(block);",
          "16784:    strcat(buffer, block);",
          "16785:   }",
          "16812:   }",
          "16832:   }",
          "16868:   }",
          "16877:   }",
          "16882: #endif",
          "16896:  }",
          "16905: #if defined(USE_SERVER_STATS)",
          "16913: #else",
          "16914:  (void)ctx;",
          "16915:  if ((buffer != NULL) && (buflen > 0)) {",
          "",
          "[Removed Lines]",
          "16697:  }",
          "16701:  {",
          "16702:   mg_snprintf(NULL,",
          "16703:               NULL,",
          "16704:               block,",
          "16705:               sizeof(block),",
          "16706:               \"Data model: int:%u/%u/%u/%u, float:%u/%u/%u, char:%u/%u, \"",
          "16707:               \"ptr:%u, size:%u, time:%u%s\",",
          "16708:               (unsigned)sizeof(short),",
          "16709:               (unsigned)sizeof(int),",
          "16710:               (unsigned)sizeof(long),",
          "16711:               (unsigned)sizeof(long long),",
          "16712:               (unsigned)sizeof(float),",
          "16713:               (unsigned)sizeof(double),",
          "16714:               (unsigned)sizeof(long double),",
          "16715:               (unsigned)sizeof(char),",
          "16716:               (unsigned)sizeof(wchar_t),",
          "16717:               (unsigned)sizeof(void *),",
          "16718:               (unsigned)sizeof(size_t),",
          "16719:               (unsigned)sizeof(time_t),",
          "16720:               eol);",
          "16721:   system_info_length += (int)strlen(block);",
          "16722:   if (system_info_length < buflen) {",
          "16723:    strcat(buffer, block);",
          "16725:  }",
          "16727:  return system_info_length;",
          "16728: }",
          "16734: static int",
          "16735: mg_get_context_info_impl(const struct mg_context *ctx, char *buffer, int buflen)",
          "16737: {",
          "16738:  char block[256];",
          "16739:  int context_info_length = 0;",
          "16742:  const char *eol = \"\\r\\n\";",
          "16746:  struct mg_memory_stat *ms = get_memory_stat((struct mg_context *)ctx);",
          "16748:  const char *eoobj = \"}\";",
          "16749:  int reserved_len = (int)strlen(eoobj) + (int)strlen(eol);",
          "16751:  if ((buffer == NULL) || (buflen < 10)) {",
          "16752:   buflen = 0;",
          "16753:  }",
          "16755:  mg_snprintf(NULL, NULL, block, sizeof(block), \"{%s\", eol);",
          "16756:  context_info_length += (int)strlen(block);",
          "16757:  if (context_info_length < buflen) {",
          "16758:   strcat(buffer, block);",
          "16759:  }",
          "16762:  if (ms) {",
          "16763:   mg_snprintf(NULL,",
          "16764:               NULL,",
          "16765:               block,",
          "16766:               sizeof(block),",
          "16767:               \"\\\"memory\\\" : {%s\"",
          "16768:               \"\\\"blocks\\\" : %i,%s\"",
          "16769:               \"\\\"used\\\" : %\" INT64_FMT \",%s\"",
          "16770:               \"\\\"maxUsed\\\" : %\" INT64_FMT \"%s\"",
          "16771:               \"}%s%s\",",
          "16772:               eol,",
          "16773:               ms->blockCount,",
          "16774:               eol,",
          "16775:               ms->totalMemUsed,",
          "16776:               eol,",
          "16777:               ms->maxMemUsed,",
          "16778:               eol,",
          "16779:               (ctx ? \",\" : \"\"),",
          "16780:               eol);",
          "16783:   if (context_info_length + reserved_len < buflen) {",
          "16786:  }",
          "16790:  if (ctx) {",
          "16791:   mg_snprintf(NULL,",
          "16792:               NULL,",
          "16793:               block,",
          "16794:               sizeof(block),",
          "16795:               \"\\\"connections\\\" : {%s\"",
          "16796:               \"\\\"active\\\" : %i,%s\"",
          "16797:               \"\\\"maxActive\\\" : %i,%s\"",
          "16798:               \"\\\"total\\\" : %\" INT64_FMT \"%s\"",
          "16799:               \"},%s\",",
          "16800:               eol,",
          "16801:               ctx->active_connections,",
          "16802:               eol,",
          "16803:               ctx->max_connections,",
          "16804:               eol,",
          "16805:               ctx->total_connections,",
          "16806:               eol,",
          "16807:               eol);",
          "16809:   context_info_length += (int)strlen(block);",
          "16810:   if (context_info_length + reserved_len < buflen) {",
          "16811:    strcat(buffer, block);",
          "16813:  }",
          "16816:  if (ctx) {",
          "16817:   mg_snprintf(NULL,",
          "16818:               NULL,",
          "16819:               block,",
          "16820:               sizeof(block),",
          "16821:               \"\\\"requests\\\" : {%s\"",
          "16822:               \"\\\"total\\\" : %\" INT64_FMT \"%s\"",
          "16823:               \"},%s\",",
          "16824:               eol,",
          "16825:               ctx->total_requests,",
          "16826:               eol,",
          "16827:               eol);",
          "16829:   context_info_length += (int)strlen(block);",
          "16830:   if (context_info_length + reserved_len < buflen) {",
          "16831:    strcat(buffer, block);",
          "16833:  }",
          "16836:  if (ctx) {",
          "16837:   char start_time_str[64] = {0};",
          "16838:   char now_str[64] = {0};",
          "16839:   time_t start_time = ctx->start_time;",
          "16840:   time_t now = time(NULL);",
          "16842:   gmt_time_string(start_time_str,",
          "16843:                   sizeof(start_time_str) - 1,",
          "16844:                   &start_time);",
          "16845:   gmt_time_string(now_str, sizeof(now_str) - 1, &now);",
          "16847:   mg_snprintf(NULL,",
          "16848:               NULL,",
          "16849:               block,",
          "16850:               sizeof(block),",
          "16851:               \"\\\"time\\\" : {%s\"",
          "16852:               \"\\\"uptime\\\" : %.0f,%s\"",
          "16853:               \"\\\"start\\\" : \\\"%s\\\",%s\"",
          "16854:               \"\\\"now\\\" : \\\"%s\\\"%s\"",
          "16855:               \"}%s\",",
          "16856:               eol,",
          "16857:               difftime(now, start_time),",
          "16858:               eol,",
          "16859:               start_time_str,",
          "16860:               eol,",
          "16861:               now_str,",
          "16862:               eol,",
          "16863:               eol);",
          "16865:   context_info_length += (int)strlen(block);",
          "16866:   if (context_info_length + reserved_len < buflen) {",
          "16867:    strcat(buffer, block);",
          "16869:  }",
          "16872:  if ((buflen > 0) && buffer && buffer[0]) {",
          "16873:   if (context_info_length < buflen) {",
          "16874:    strcat(buffer, eoobj);",
          "16875:    strcat(buffer, eol);",
          "16876:    context_info_length += reserved_len;",
          "16878:  }",
          "16880:  return context_info_length;",
          "16881: }",
          "16887: int",
          "16888: mg_get_system_info(char *buffer, int buflen)",
          "16889: {",
          "16890:  if ((buffer == NULL) || (buflen < 1)) {",
          "16891:   return mg_get_system_info_impl(NULL, 0);",
          "16892:  } else {",
          "16894:   buffer[0] = 0;",
          "16895:   return mg_get_system_info_impl(buffer, buflen);",
          "16897: }",
          "16902: int",
          "16903: mg_get_context_info(const struct mg_context *ctx, char *buffer, int buflen)",
          "16904: {",
          "16906:  if ((buffer == NULL) || (buflen < 1)) {",
          "16907:   return mg_get_context_info_impl(ctx, NULL, 0);",
          "16908:  } else {",
          "16910:   buffer[0] = 0;",
          "16911:   return mg_get_context_info_impl(ctx, buffer, buflen);",
          "16912:  }",
          "",
          "[Added Lines]",
          "16747:   }",
          "16751:   {",
          "16752:    mg_snprintf(",
          "16753:        NULL,",
          "16754:        NULL,",
          "16755:        block,",
          "16756:        sizeof(block),",
          "16757:        \"Data model: int:%u/%u/%u/%u, float:%u/%u/%u, char:%u/%u, \"",
          "16758:        \"ptr:%u, size:%u, time:%u%s\",",
          "16759:        (unsigned)sizeof(short),",
          "16760:        (unsigned)sizeof(int),",
          "16761:        (unsigned)sizeof(long),",
          "16762:        (unsigned)sizeof(long long),",
          "16763:        (unsigned)sizeof(float),",
          "16764:        (unsigned)sizeof(double),",
          "16765:        (unsigned)sizeof(long double),",
          "16766:        (unsigned)sizeof(char),",
          "16767:        (unsigned)sizeof(wchar_t),",
          "16768:        (unsigned)sizeof(void *),",
          "16769:        (unsigned)sizeof(size_t),",
          "16770:        (unsigned)sizeof(time_t),",
          "16771:        eol);",
          "16772:    system_info_length += (int)strlen(block);",
          "16773:    if (system_info_length < buflen) {",
          "16774:     strcat(buffer, block);",
          "16775:    }",
          "16778:   return system_info_length;",
          "16779:  }",
          "16785:  static int mg_get_context_info_impl(const struct mg_context *ctx,",
          "16786:                                      char *buffer,",
          "16787:                                      int buflen)",
          "16789:  {",
          "16790:   char block[256];",
          "16791:   int context_info_length = 0;",
          "16794:   const char *eol = \"\\r\\n\";",
          "16798:   struct mg_memory_stat *ms = get_memory_stat((struct mg_context *)ctx);",
          "16800:   const char *eoobj = \"}\";",
          "16801:   int reserved_len = (int)strlen(eoobj) + (int)strlen(eol);",
          "16803:   if ((buffer == NULL) || (buflen < 10)) {",
          "16804:    buflen = 0;",
          "16805:   }",
          "16807:   mg_snprintf(NULL, NULL, block, sizeof(block), \"{%s\", eol);",
          "16809:   if (context_info_length < buflen) {",
          "16814:   if (ms) {",
          "16815:    mg_snprintf(NULL,",
          "16816:                NULL,",
          "16817:                block,",
          "16818:                sizeof(block),",
          "16819:                \"\\\"memory\\\" : {%s\"",
          "16820:                \"\\\"blocks\\\" : %i,%s\"",
          "16821:                \"\\\"used\\\" : %\" INT64_FMT \",%s\"",
          "16822:                \"\\\"maxUsed\\\" : %\" INT64_FMT \"%s\"",
          "16823:                \"}%s%s\",",
          "16824:                eol,",
          "16825:                ms->blockCount,",
          "16826:                eol,",
          "16827:                ms->totalMemUsed,",
          "16828:                eol,",
          "16829:                ms->maxMemUsed,",
          "16830:                eol,",
          "16831:                (ctx ? \",\" : \"\"),",
          "16832:                eol);",
          "16834:    context_info_length += (int)strlen(block);",
          "16835:    if (context_info_length + reserved_len < buflen) {",
          "16836:     strcat(buffer, block);",
          "16837:    }",
          "16842:   if (ctx) {",
          "16843:    mg_snprintf(NULL,",
          "16844:                NULL,",
          "16845:                block,",
          "16846:                sizeof(block),",
          "16847:                \"\\\"connections\\\" : {%s\"",
          "16848:                \"\\\"active\\\" : %i,%s\"",
          "16849:                \"\\\"maxActive\\\" : %i,%s\"",
          "16850:                \"\\\"total\\\" : %\" INT64_FMT \"%s\"",
          "16851:                \"},%s\",",
          "16852:                eol,",
          "16853:                ctx->active_connections,",
          "16854:                eol,",
          "16855:                ctx->max_connections,",
          "16856:                eol,",
          "16857:                ctx->total_connections,",
          "16858:                eol,",
          "16859:                eol);",
          "16861:    context_info_length += (int)strlen(block);",
          "16862:    if (context_info_length + reserved_len < buflen) {",
          "16863:     strcat(buffer, block);",
          "16864:    }",
          "16868:   if (ctx) {",
          "16869:    mg_snprintf(NULL,",
          "16870:                NULL,",
          "16871:                block,",
          "16872:                sizeof(block),",
          "16873:                \"\\\"requests\\\" : {%s\"",
          "16874:                \"\\\"total\\\" : %\" INT64_FMT \"%s\"",
          "16875:                \"},%s\",",
          "16876:                eol,",
          "16877:                ctx->total_requests,",
          "16878:                eol,",
          "16879:                eol);",
          "16881:    context_info_length += (int)strlen(block);",
          "16882:    if (context_info_length + reserved_len < buflen) {",
          "16883:     strcat(buffer, block);",
          "16884:    }",
          "16885:   }",
          "16888:   if (ctx) {",
          "16889:    char start_time_str[64] = {0};",
          "16890:    char now_str[64] = {0};",
          "16891:    time_t start_time = ctx->start_time;",
          "16892:    time_t now = time(NULL);",
          "16894:    gmt_time_string(start_time_str,",
          "16895:                    sizeof(start_time_str) - 1,",
          "16896:                    &start_time);",
          "16897:    gmt_time_string(now_str, sizeof(now_str) - 1, &now);",
          "16899:    mg_snprintf(NULL,",
          "16900:                NULL,",
          "16901:                block,",
          "16902:                sizeof(block),",
          "16903:                \"\\\"time\\\" : {%s\"",
          "16904:                \"\\\"uptime\\\" : %.0f,%s\"",
          "16905:                \"\\\"start\\\" : \\\"%s\\\",%s\"",
          "16906:                \"\\\"now\\\" : \\\"%s\\\"%s\"",
          "16907:                \"}%s\",",
          "16908:                eol,",
          "16909:                difftime(now, start_time),",
          "16910:                eol,",
          "16911:                start_time_str,",
          "16912:                eol,",
          "16913:                now_str,",
          "16914:                eol,",
          "16915:                eol);",
          "16917:    context_info_length += (int)strlen(block);",
          "16918:    if (context_info_length + reserved_len < buflen) {",
          "16919:     strcat(buffer, block);",
          "16920:    }",
          "16924:   if ((buflen > 0) && buffer && buffer[0]) {",
          "16925:    if (context_info_length < buflen) {",
          "16926:     strcat(buffer, eoobj);",
          "16927:     strcat(buffer, eol);",
          "16928:     context_info_length += reserved_len;",
          "16929:    }",
          "16932:   return context_info_length;",
          "16933:  }",
          "16939:  int mg_get_system_info(char *buffer, int buflen)",
          "16940:  {",
          "16941:   if ((buffer == NULL) || (buflen < 1)) {",
          "16942:    return mg_get_system_info_impl(NULL, 0);",
          "16943:   } else {",
          "16945:    buffer[0] = 0;",
          "16946:    return mg_get_system_info_impl(buffer, buflen);",
          "16947:   }",
          "16953:  int mg_get_context_info(const struct mg_context *ctx,",
          "16954:                          char *buffer,",
          "16955:                          int buflen)",
          "16956:  {",
          "16958:   if ((buffer == NULL) || (buflen < 1)) {",
          "16959:    return mg_get_context_info_impl(ctx, NULL, 0);",
          "16960:   } else {",
          "16962:    buffer[0] = 0;",
          "16963:    return mg_get_context_info_impl(ctx, buffer, buflen);",
          "16964:   }",
          "",
          "---------------",
          "--- Hunk 68 ---",
          "[Context before]",
          "16917:  }",
          "16918:  return 0;",
          "16919: #endif",
          "16928: #if !defined(NO_SSL)",
          "16930: #endif",
          "16939:   }",
          "16951: #if defined(_WIN32) && !defined(__SYMBIAN32__)",
          "16954: #if !defined(_WIN32)",
          "16957: #endif",
          "16959: #if defined(USE_LUA)",
          "16961: #endif",
          "16965: #if !defined(NO_SSL)",
          "16970:    } else {",
          "16974:    }",
          "16977:   }",
          "16979: #endif",
          "16983: #if defined(_WIN32) && !defined(__SYMBIAN32__)",
          "17010: #if defined(_WIN32) && !defined(__SYMBIAN32__)",
          "17013: #if !defined(NO_SSL)",
          "17018: #endif",
          "17020: #if defined(_WIN32) && !defined(__SYMBIAN32__)",
          "17023: #if !defined(_WIN32)",
          "17025: #endif",
          "17029: #if defined(USE_LUA)",
          "17031: #endif",
          "17033:   mg_global_unlock();",
          "17035:   return 1;",
          "17036:  }",
          "",
          "[Removed Lines]",
          "16920: }",
          "16925: unsigned",
          "16926: mg_init_library(unsigned features)",
          "16927: {",
          "16929:  char ebuf[128];",
          "16932:  unsigned features_to_init = mg_check_feature(features & 0xFFu);",
          "16933:  unsigned features_inited = features_to_init;",
          "16935:  if (mg_init_library_called <= 0) {",
          "16937:   if (0 != pthread_mutex_init(&global_lock_mutex, NULL)) {",
          "16938:    return 0;",
          "16940:  }",
          "16942:  mg_global_lock();",
          "16944:  if (mg_init_library_called <= 0) {",
          "16945:   if (0 != pthread_key_create(&sTlsKey, tls_dtor)) {",
          "16948:    return 0;",
          "16949:   }",
          "16952:   InitializeCriticalSection(&global_log_file_lock);",
          "16955:   pthread_mutexattr_init(&pthread_mutex_attr);",
          "16956:   pthread_mutexattr_settype(&pthread_mutex_attr, PTHREAD_MUTEX_RECURSIVE);",
          "16960:   lua_init_optional_libraries();",
          "16962:  }",
          "16966:  if (features_to_init & 2) {",
          "16967:   if (!mg_ssl_initialized) {",
          "16968:    if (initialize_ssl(ebuf, sizeof(ebuf))) {",
          "16969:     mg_ssl_initialized = 1;",
          "16971:     (void)ebuf;",
          "16973:     features_inited &= ~(2u);",
          "16975:   } else {",
          "16978:  }",
          "16982:  if (mg_init_library_called <= 0) {",
          "16984:   WSADATA data;",
          "16985:   WSAStartup(MAKEWORD(2, 2), &data);",
          "16987:   mg_init_library_called = 1;",
          "16988:  } else {",
          "16989:   mg_init_library_called++;",
          "16990:  }",
          "16992:  mg_global_unlock();",
          "16994:  return features_inited;",
          "16995: }",
          "16999: unsigned",
          "17000: mg_exit_library(void)",
          "17001: {",
          "17002:  if (mg_init_library_called <= 0) {",
          "17003:   return 0;",
          "17004:  }",
          "17006:  mg_global_lock();",
          "17008:  mg_init_library_called--;",
          "17009:  if (mg_init_library_called == 0) {",
          "17011:   (void)WSACleanup();",
          "17014:   if (mg_ssl_initialized) {",
          "17015:    uninitialize_ssl();",
          "17016:    mg_ssl_initialized = 0;",
          "17017:   }",
          "17021:   (void)DeleteCriticalSection(&global_log_file_lock);",
          "17024:   (void)pthread_mutexattr_destroy(&pthread_mutex_attr);",
          "17027:   (void)pthread_key_delete(sTlsKey);",
          "17030:   lua_exit_optional_libraries();",
          "17034:   (void)pthread_mutex_destroy(&global_lock_mutex);",
          "17038:  mg_global_unlock();",
          "17039:  return 1;",
          "17040: }",
          "",
          "[Added Lines]",
          "16972:  }",
          "16977:  unsigned mg_init_library(unsigned features)",
          "16978:  {",
          "16980:   char ebuf[128];",
          "16983:   unsigned features_to_init = mg_check_feature(features & 0xFFu);",
          "16984:   unsigned features_inited = features_to_init;",
          "16986:   if (mg_init_library_called <= 0) {",
          "16988:    if (0 != pthread_mutex_init(&global_lock_mutex, NULL)) {",
          "16989:     return 0;",
          "16990:    }",
          "16993:   mg_global_lock();",
          "16995:   if (mg_init_library_called <= 0) {",
          "16996:    if (0 != pthread_key_create(&sTlsKey, tls_dtor)) {",
          "16999:     return 0;",
          "17000:    }",
          "17003:    InitializeCriticalSection(&global_log_file_lock);",
          "17006:    pthread_mutexattr_init(&pthread_mutex_attr);",
          "17007:    pthread_mutexattr_settype(&pthread_mutex_attr,",
          "17008:                              PTHREAD_MUTEX_RECURSIVE);",
          "17012:    lua_init_optional_libraries();",
          "17014:   }",
          "17018:   if (features_to_init & 2) {",
          "17019:    if (!mg_ssl_initialized) {",
          "17020:     if (initialize_ssl(ebuf, sizeof(ebuf))) {",
          "17021:      mg_ssl_initialized = 1;",
          "17022:     } else {",
          "17023:      (void)ebuf;",
          "17025:      features_inited &= ~(2u);",
          "17026:     }",
          "17034:   if (mg_init_library_called <= 0) {",
          "17036:    WSADATA data;",
          "17037:    WSAStartup(MAKEWORD(2, 2), &data);",
          "17039:    mg_init_library_called = 1;",
          "17040:   } else {",
          "17041:    mg_init_library_called++;",
          "17042:   }",
          "17044:   mg_global_unlock();",
          "17046:   return features_inited;",
          "17047:  }",
          "17051:  unsigned mg_exit_library(void)",
          "17052:  {",
          "17053:   if (mg_init_library_called <= 0) {",
          "17054:    return 0;",
          "17055:   }",
          "17057:   mg_global_lock();",
          "17059:   mg_init_library_called--;",
          "17060:   if (mg_init_library_called == 0) {",
          "17062:    (void)WSACleanup();",
          "17065:    if (mg_ssl_initialized) {",
          "17066:     uninitialize_ssl();",
          "17067:     mg_ssl_initialized = 0;",
          "17068:    }",
          "17072:    (void)DeleteCriticalSection(&global_log_file_lock);",
          "17075:    (void)pthread_mutexattr_destroy(&pthread_mutex_attr);",
          "17078:    (void)pthread_key_delete(sTlsKey);",
          "17081:    lua_exit_optional_libraries();",
          "17084:    mg_global_unlock();",
          "17085:    (void)pthread_mutex_destroy(&global_lock_mutex);",
          "17086:    return 1;",
          "17087:   }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "50b3d7e3ab3ad8f19c44a1eb2037ff3c4c4d8c45",
      "candidate_info": {
        "commit_hash": "50b3d7e3ab3ad8f19c44a1eb2037ff3c4c4d8c45",
        "repo": "civetweb/civetweb",
        "commit_url": "https://github.com/civetweb/civetweb/commit/50b3d7e3ab3ad8f19c44a1eb2037ff3c4c4d8c45",
        "files": [
          "src/civetweb.c"
        ],
        "message": "Rewrite send_ssi_file to improve code clarity",
        "before_after_code_files": [
          "src/civetweb.c||src/civetweb.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/civetweb.c||src/civetweb.c"
          ],
          "candidate": [
            "src/civetweb.c||src/civetweb.c"
          ]
        }
      },
      "candidate_diff": {
        "src/civetweb.c||src/civetweb.c": [
          "File: src/civetweb.c -> src/civetweb.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "9852:               int include_level)",
          "9853: {",
          "9854:  char buf[MG_BUF_LEN];",
          "9857:  if (include_level > 10) {",
          "9858:   mg_cry(conn, \"SSI #include level is too deep (%s)\", path);",
          "9859:   return;",
          "9860:  }",
          "9863:  while ((ch = mg_fgetc(filep, offset++)) != EOF) {",
          "9878: #if !defined(NO_POPEN)",
          "9882:     } else {",
          "9888:     }",
          "9889:    }",
          "9907:   } else {",
          "9912:    }",
          "9913:   }",
          "9914:  }",
          "",
          "[Removed Lines]",
          "9855:  int ch, offset, len, in_ssi_tag;",
          "9862:  in_ssi_tag = len = offset = 0;",
          "9864:   if (in_ssi_tag && (ch == '>')) {",
          "9865:    in_ssi_tag = 0;",
          "9866:    buf[len++] = (char)ch;",
          "9867:    buf[len] = '\\0';",
          "9869:    if (len > (int)sizeof(buf)) {",
          "9870:     break;",
          "9871:    }",
          "9872:    if ((len < 6) || (memcmp(buf, \"<!--#\", 5) != 0)) {",
          "9874:     (void)mg_write(conn, buf, (size_t)len);",
          "9875:    } else {",
          "9876:     if (!memcmp(buf + 5, \"include\", 7)) {",
          "9877:      do_ssi_include(conn, path, buf + 12, include_level);",
          "9879:     } else if (!memcmp(buf + 5, \"exec\", 4)) {",
          "9880:      do_ssi_exec(conn, buf + 9);",
          "9883:      mg_cry(conn,",
          "9884:             \"%s: unknown SSI \"",
          "9885:             \"command: \\\"%s\\\"\",",
          "9886:             path,",
          "9887:             buf);",
          "9890:    len = 0;",
          "9891:   } else if (in_ssi_tag) {",
          "9892:    if ((len == 5) && (memcmp(buf, \"<!--#\", 5) != 0)) {",
          "9894:     in_ssi_tag = 0;",
          "9895:    } else if (len == ((int)sizeof(buf) - 2)) {",
          "9896:     mg_cry(conn, \"%s: SSI tag is too large\", path);",
          "9897:     len = 0;",
          "9898:    }",
          "9899:    buf[len++] = (char)(ch & 0xff);",
          "9900:   } else if (ch == '<') {",
          "9901:    in_ssi_tag = 1;",
          "9902:    if (len > 0) {",
          "9903:     mg_write(conn, buf, (size_t)len);",
          "9904:    }",
          "9905:    len = 0;",
          "9906:    buf[len++] = (char)(ch & 0xff);",
          "9908:    buf[len++] = (char)(ch & 0xff);",
          "9909:    if (len == (int)sizeof(buf)) {",
          "9910:     mg_write(conn, buf, (size_t)len);",
          "9911:     len = 0;",
          "",
          "[Added Lines]",
          "9855:  int ch, offset, len, in_tag, in_ssi_tag;",
          "9862:  in_tag = in_ssi_tag = len = offset = 0;",
          "9867:   if (in_tag) {",
          "9870:    if (ch == '>') {",
          "9872:     buf[len++] = '>';",
          "9874:     if (in_ssi_tag) {",
          "9876:      buf[len] = 0;",
          "9878:      if (!memcmp(buf + 5, \"include\", 7)) {",
          "9879:       do_ssi_include(conn, path, buf + 12, include_level + 1);",
          "9881:      } else if (!memcmp(buf + 5, \"exec\", 4)) {",
          "9882:       do_ssi_exec(conn, buf + 9);",
          "9884:      } else {",
          "9885:       mg_cry(conn,",
          "9886:              \"%s: unknown SSI \"",
          "9887:              \"command: \\\"%s\\\"\",",
          "9888:              path,",
          "9889:              buf);",
          "9890:      }",
          "9891:      len = 0;",
          "9892:      in_ssi_tag = in_tag = 0;",
          "9897:      (void)mg_write(conn, buf, (size_t)len);",
          "9898:      len = 0;",
          "9899:      in_tag = 0;",
          "9900:     }",
          "9902:    } else {",
          "9904:     buf[len++] = (char)(ch & 0xff);",
          "9906:     if ((len == 5) && !memcmp(buf, \"<!--#\", 5)) {",
          "9908:      in_ssi_tag = 1;",
          "9909:     }",
          "9911:     if ((len + 2) > (int)sizeof(buf)) {",
          "9913:      mg_cry(conn, \"%s: tag is too large\", path);",
          "9914:      len = 0;",
          "9915:      return;",
          "9922:    if (ch == '<') {",
          "9924:     in_tag = 1;",
          "9926:     (void)mg_write(conn, buf, (size_t)len);",
          "9928:     len = 1;",
          "9929:     buf[0] = '<';",
          "9931:    } else {",
          "9934:     buf[len++] = (char)(ch & 0xff);",
          "9936:     if (len == (int)sizeof(buf)) {",
          "9937:      mg_write(conn, buf, (size_t)len);",
          "9938:      len = 0;",
          "9939:     }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b9310773c7e59e0da968f1e33b654b87981322b3",
      "candidate_info": {
        "commit_hash": "b9310773c7e59e0da968f1e33b654b87981322b3",
        "repo": "civetweb/civetweb",
        "commit_url": "https://github.com/civetweb/civetweb/commit/b9310773c7e59e0da968f1e33b654b87981322b3",
        "files": [
          "src/civetweb.c"
        ],
        "message": "Avoid data type warning",
        "before_after_code_files": [
          "src/civetweb.c||src/civetweb.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/civetweb.c||src/civetweb.c"
          ],
          "candidate": [
            "src/civetweb.c||src/civetweb.c"
          ]
        }
      },
      "candidate_diff": {
        "src/civetweb.c||src/civetweb.c": [
          "File: src/civetweb.c -> src/civetweb.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "9866:    if (len > (int)sizeof(buf)) {",
          "9867:     break;",
          "9868:    }",
          "9871:     (void)mg_write(conn, buf, (size_t)len);",
          "9872:    } else {",
          "",
          "[Removed Lines]",
          "9869:    if (len < 6 || memcmp(buf, \"<!--#\", 5) != 0) {",
          "",
          "[Added Lines]",
          "9869:             if ((len < 6) || (memcmp(buf, \"<!--#\", 5) != 0)) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "10618:      sep = strchr(protocol, ',');",
          "10619:      curSubProtocol = protocol;",
          "10620:      len = sep ? (unsigned long)(sep - protocol)",
          "10622:      while (sep && isspace(*++sep))",
          "10623:       ; // ignore leading whitespaces",
          "10624:      protocol = sep;",
          "",
          "[Removed Lines]",
          "10621:                : strlen(protocol);",
          "",
          "[Added Lines]",
          "10621:                               : (unsigned long)strlen(protocol);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "baaea000caaffdd18a152859116eccc626bde10a",
      "candidate_info": {
        "commit_hash": "baaea000caaffdd18a152859116eccc626bde10a",
        "repo": "civetweb/civetweb",
        "commit_url": "https://github.com/civetweb/civetweb/commit/baaea000caaffdd18a152859116eccc626bde10a",
        "files": [
          "src/civetweb.c"
        ],
        "message": "Add some () to improve readability",
        "before_after_code_files": [
          "src/civetweb.c||src/civetweb.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/civetweb.c||src/civetweb.c"
          ],
          "candidate": [
            "src/civetweb.c||src/civetweb.c"
          ]
        }
      },
      "candidate_diff": {
        "src/civetweb.c||src/civetweb.c": [
          "File: src/civetweb.c -> src/civetweb.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3280:   end = (int)val->len - 1;",
          "3282:    end--;",
          "3283:   val->len = (size_t)(end + 1);",
          "",
          "[Removed Lines]",
          "3281:   while (end >= 0 && (val->ptr[end] == ' ' || val->ptr[end] == '\\t'))",
          "",
          "[Added Lines]",
          "3281:   while (end >= 0 && ((val->ptr[end] == ' ') || (val->ptr[end] == '\\t')))",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3339:                                         str);",
          "3340:  }",
          "3344:    continue;",
          "3345:   } else if (pattern[i] == '$') {",
          "3346:    return (str[j] == '\\0') ? j : -1;",
          "",
          "[Removed Lines]",
          "3342:  for (i = 0, j = 0; i < pattern_len; i++, j++) {",
          "3343:   if (pattern[i] == '?' && str[j] != '\\0') {",
          "",
          "[Added Lines]",
          "3342:  for (i = 0, j = 0; (i < pattern_len); i++, j++) {",
          "3343:   if ((pattern[i] == '?') && (str[j] != '\\0')) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3376:  if (conn != NULL) {",
          "3377:   const char *http_version = conn->request_info.http_version;",
          "3378:   const char *header = mg_get_header(conn, \"Connection\");",
          "3380:       || mg_strcasecmp(conn->ctx->config[ENABLE_KEEP_ALIVE], \"yes\") != 0",
          "3381:       || (header != NULL && !header_has_option(header, \"keep-alive\"))",
          "3382:       || (header == NULL && http_version",
          "",
          "[Removed Lines]",
          "3379:   if (conn->must_close || conn->status_code == 401",
          "",
          "[Added Lines]",
          "3379:   if (conn->must_close || (conn->status_code == 401)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "3692:  }",
          "3694:  conn->status_code = status;",
          "3696:      || conn->ctx->callbacks.http_error(conn, status)) {",
          "3697:   if (!conn->in_error_handler) {",
          "",
          "[Removed Lines]",
          "3695:  if (conn->in_error_handler || conn->ctx->callbacks.http_error == NULL",
          "",
          "[Added Lines]",
          "3695:  if (conn->in_error_handler || (conn->ctx->callbacks.http_error == NULL)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "3741:      tstr = strchr(error_page_file_ext, '.');",
          "3743:      while (tstr) {",
          "3745:            i++)",
          "3746:        buf[len + i - 1] = tstr[i];",
          "3747:       buf[len + i - 1] = 0;",
          "",
          "[Removed Lines]",
          "3744:       for (i = 1; i < 32 && tstr[i] != 0 && tstr[i] != ',';",
          "",
          "[Added Lines]",
          "3744:       for (i = 1;",
          "3745:            (i < 32) && (tstr[i] != 0) && (tstr[i] != ',');",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "3766:   gmt_time_string(date, sizeof(date), &curtime);",
          "3771:   conn->must_close = 1;",
          "3772:   mg_printf(conn, \"HTTP/1.1 %d %s\\r\\n\", status, status_text);",
          "",
          "[Removed Lines]",
          "3769:   has_body = (status > 199 && status != 204 && status != 304);",
          "",
          "[Added Lines]",
          "3770:   has_body = ((status > 199) && (status != 204) && (status != 304));",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "4030:   if ((path[i] == '\\\\') && (i > 0)) {",
          "4032:     (void)memmove(path + i + 1, path + i + 2, strlen(path + i + 1));",
          "4033:    }",
          "4034:   }",
          "",
          "[Removed Lines]",
          "4031:    while (path[i + 1] == '\\\\' || path[i + 1] == '/') {",
          "",
          "[Added Lines]",
          "4032:    while ((path[i + 1] == '\\\\') || (path[i + 1] == '/')) {",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "4045:   diff = tolower(*s1) - tolower(*s2);",
          "4046:   s1++;",
          "4047:   s2++;",
          "4050:  return diff;",
          "4051: }",
          "",
          "[Removed Lines]",
          "4048:  } while (diff == 0 && s1[-1] != '\\0');",
          "",
          "[Added Lines]",
          "4049:  } while ((diff == 0) && (s1[-1] != '\\0'));",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "4503: trim_trailing_whitespaces(char *s)",
          "4504: {",
          "4505:  char *e = s + strlen(s) - 1;",
          "4508:  }",
          "4509: }",
          "",
          "[Removed Lines]",
          "4506:  while (e > s && isspace(*(unsigned char *)e)) {",
          "",
          "[Added Lines]",
          "4507:  while ((e > s) && isspace(*(unsigned char *)e)) {",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "4592:    buf[sizeof(buf) - 1] = '\\0';",
          "4593:   }",
          "4596:    trim_trailing_whitespaces(buf + 2);",
          "4597:   } else {",
          "4598:    buf[2] = '\\0';",
          "",
          "[Removed Lines]",
          "4595:   if (buf[0] == '#' && buf[1] == '!') {",
          "",
          "[Added Lines]",
          "4596:   if ((buf[0] == '#') && (buf[1] == '!')) {",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "5049:    return -1;",
          "5050:   }",
          "5054:    return n;",
          "5055:   }",
          "",
          "[Removed Lines]",
          "5052:   if ((n > 0) || (n == 0 && len == 0)) {",
          "",
          "[Added Lines]",
          "5053:   if ((n > 0) || ((n == 0) && (len == 0))) {",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "5100:   timeout = atoi(ctx->config[REQUEST_TIMEOUT]) / 1000.0;",
          "5101:  }",
          "5104:   n = push(ctx, fp, sock, ssl, buf + nwritten, (int)len, timeout);",
          "5105:   if (n < 0) {",
          "5106:    if (nwritten == 0) {",
          "",
          "[Removed Lines]",
          "5103:  while (len > 0 && ctx->stop_flag == 0) {",
          "",
          "[Added Lines]",
          "5104:  while ((len > 0) && (ctx->stop_flag == 0)) {",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "5255:   return -2;",
          "5256:  }",
          "5260:   return nread;",
          "5261:  }",
          "",
          "[Removed Lines]",
          "5258:  if ((nread > 0) || (nread == 0 && len == 0)) {",
          "",
          "[Added Lines]",
          "5259:  if ((nread > 0) || ((nread == 0) && (len == 0))) {",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "5287:   if (err == EAGAIN || err == EWOULDBLOCK || err == EINTR) {",
          "",
          "[Added Lines]",
          "5288:   if ((err == EAGAIN) || (err == EWOULDBLOCK) || (err == EINTR)) {",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "5323:   timeout_ns = (uint64_t)(timeout * 1.0E9);",
          "5324:  }",
          "5327:   n = pull_inner(fp, conn, buf + nread, len, timeout);",
          "5328:   if (n == -2) {",
          "5329:    if (nread == 0) {",
          "",
          "[Removed Lines]",
          "5326:  while (len > 0 && conn->ctx->stop_flag == 0) {",
          "",
          "[Added Lines]",
          "5327:  while ((len > 0) && (conn->ctx->stop_flag == 0)) {",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "5412:   conn->content_len = INT64_MAX;",
          "5413:   conn->must_close = 1;",
          "5414:  }",
          "",
          "[Removed Lines]",
          "5411:  if (conn->consumed_content == 0 && conn->content_len == -1) {",
          "",
          "[Added Lines]",
          "5412:  if ((conn->consumed_content) == 0 && (conn->content_len == -1)) {",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "5528:     for (i = 0; i < ((int)sizeof(lenbuf) - 1); i++) {",
          "5529:      lenbuf[i] = mg_getc(conn);",
          "5531:       continue;",
          "5532:      }",
          "5534:       lenbuf[i + 1] = 0;",
          "5535:       chunkSize = strtoul(lenbuf, &end, 16);",
          "5536:       if (chunkSize == 0) {",
          "",
          "[Removed Lines]",
          "5530:      if (i > 0 && lenbuf[i] == '\\r' && lenbuf[i - 1] != '\\r') {",
          "5533:      if (i > 1 && lenbuf[i] == '\\n' && lenbuf[i - 1] == '\\r') {",
          "",
          "[Added Lines]",
          "5531:      if ((i > 0) && (lenbuf[i] == '\\r')",
          "5532:          && (lenbuf[i - 1] != '\\r')) {",
          "5535:      if ((i > 1) && (lenbuf[i] == '\\n')",
          "5536:          && (lenbuf[i - 1] == '\\r')) {",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "5589:                         (int64_t)allowed)) == allowed) {",
          "5590:    buf = (const char *)buf + total;",
          "5591:    conn->last_throttle_bytes += total;",
          "5593:     allowed = (conn->throttle > ((int64_t)len - total))",
          "5594:                   ? (int64_t)len - total",
          "5595:                   : conn->throttle;",
          "",
          "[Removed Lines]",
          "5592:    while (total < (int64_t)len && conn->ctx->stop_flag == 0) {",
          "",
          "[Added Lines]",
          "5595:    while ((total < (int64_t)len) && (conn->ctx->stop_flag == 0)) {",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "5760:  if ((len = alloc_vprintf(&buf, mem, sizeof(mem), fmt, ap)) > 0) {",
          "5761:   len = mg_write(conn, buf, (size_t)len);",
          "5762:  }",
          "5764:   mg_free(buf);",
          "5765:  }",
          "",
          "[Removed Lines]",
          "5763:  if (buf != mem && buf != NULL) {",
          "",
          "[Added Lines]",
          "5766:  if ((buf != mem) && (buf != NULL)) {",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "5793: #define HEXTOI(x) (isdigit(x) ? (x - '0') : (x - 'W'))",
          "5795:  for (i = j = 0; (i < src_len) && (j < (dst_len - 1)); i++, j++) {",
          "5797:       && isxdigit(*(const unsigned char *)(src + i + 1))",
          "5798:       && isxdigit(*(const unsigned char *)(src + i + 2))) {",
          "5799:    a = tolower(*(const unsigned char *)(src + i + 1));",
          "5800:    b = tolower(*(const unsigned char *)(src + i + 2));",
          "5801:    dst[j] = (char)((HEXTOI(a) << 4) | HEXTOI(b));",
          "5802:    i += 2;",
          "5804:    dst[j] = ' ';",
          "5805:   } else {",
          "5806:    dst[j] = src[i];",
          "",
          "[Removed Lines]",
          "5796:   if (i < src_len - 2 && src[i] == '%'",
          "5803:   } else if (is_form_url_encoded && src[i] == '+') {",
          "",
          "[Added Lines]",
          "5799:   if ((i < src_len - 2) && (src[i] == '%')",
          "5806:   } else if (is_form_url_encoded && (src[i] == '+')) {",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "5836:  size_t name_len;",
          "5837:  int len;",
          "5840:   len = -2;",
          "5842:   len = -1;",
          "5843:   dst[0] = '\\0';",
          "5844:  } else {",
          "",
          "[Removed Lines]",
          "5839:  if (dst == NULL || dst_len == 0) {",
          "5841:  } else if (data == NULL || name == NULL || data_len == 0) {",
          "",
          "[Added Lines]",
          "5842:  if ((dst == NULL) || (dst_len == 0)) {",
          "5844:  } else if ((data == NULL) || (name == NULL) || (data_len == 0)) {",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "5851:   for (p = data; p + name_len < e; p++) {",
          "5853:        && !mg_strncasecmp(name, p, name_len) && 0 == occurrence--) {",
          "5855:     p += name_len + 1;",
          "",
          "[Removed Lines]",
          "5852:    if ((p == data || p[-1] == '&') && p[name_len] == '='",
          "",
          "[Added Lines]",
          "5855:    if (((p == data) || (p[-1] == '&')) && (p[name_len] == '=')",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "5891:  const char *s, *p, *end;",
          "5892:  int name_len, len = -1;",
          "5895:   return -2;",
          "5896:  }",
          "5898:  dst[0] = '\\0';",
          "5900:   return -1;",
          "5901:  }",
          "",
          "[Removed Lines]",
          "5894:  if (dst == NULL || dst_size == 0) {",
          "5899:  if (var_name == NULL || (s = cookie_header) == NULL) {",
          "",
          "[Added Lines]",
          "5897:  if ((dst == NULL) || (dst_size == 0)) {",
          "5902:  if ((var_name == NULL) || ((s = cookie_header) == NULL)) {",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "5913:     if (p[-1] == ';') {",
          "5914:      p--;",
          "5915:     }",
          "5917:      s++;",
          "5918:      p--;",
          "5919:     }",
          "",
          "[Removed Lines]",
          "5916:     if (*s == '\"' && p[-1] == '\"' && p > s + 1) {",
          "",
          "[Added Lines]",
          "5919:     if ((*s == '\"') && (p[-1] == '\"') && (p > s + 1)) {",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "5965: static unsigned char",
          "5966: b64reverse(char letter)",
          "5967: {",
          "5969:   return letter - 'A';",
          "5970:  }",
          "5972:   return letter - 'a' + 26;",
          "5973:  }",
          "5975:   return letter - '0' + 52;",
          "5976:  }",
          "5977:  if (letter == '+') {",
          "",
          "[Removed Lines]",
          "5968:  if (letter >= 'A' && letter <= 'Z') {",
          "5971:  if (letter >= 'a' && letter <= 'z') {",
          "5974:  if (letter >= '0' && letter <= '9') {",
          "",
          "[Added Lines]",
          "5971:  if ((letter >= 'A') && (letter <= 'Z')) {",
          "5974:  if ((letter >= 'a') && (letter <= 'z')) {",
          "5977:  if ((letter >= '0') && (letter <= '9')) {",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "6034: {",
          "6035:  if (conn) {",
          "6036:   const char *s = conn->request_info.request_method;",
          "6039:  }",
          "6040:  return 0;",
          "6041: }",
          "",
          "[Removed Lines]",
          "6037:   return s != NULL && (!strcmp(s, \"PUT\") || !strcmp(s, \"DELETE\")",
          "6038:                        || !strcmp(s, \"MKCOL\") || !strcmp(s, \"PATCH\"));",
          "",
          "[Added Lines]",
          "6040:   return (s != NULL) && (!strcmp(s, \"PUT\") || !strcmp(s, \"DELETE\")",
          "6041:                          || !strcmp(s, \"MKCOL\") || !strcmp(s, \"PATCH\"));",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "6099:   n--;",
          "6100:  }",
          "6101:  path[n] = '/';",
          "",
          "[Removed Lines]",
          "6098:  while (n > 0 && path[n - 1] == '/') {",
          "",
          "[Added Lines]",
          "6101:  while ((n > 0) && (path[n - 1] == '/')) {",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "6105:  while ((list = next_option(list, &filename_vec, NULL)) != NULL) {",
          "6108:    continue;",
          "6109:   }",
          "",
          "[Removed Lines]",
          "6107:   if (filename_vec.len > path_len - (n + 2)) {",
          "",
          "[Added Lines]",
          "6110:   if (filename_vec.len > (path_len - (n + 2))) {",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "6404:  const char *s, *e;",
          "6405:  int len = 0;",
          "6411:    len = -1;",
          "6412:    break; /* [i_a] abort scan as soon as one malformed character is",
          "6416:    len = (int)(s - buf) + 2;",
          "6418:    len = (int)(s - buf) + 3;",
          "6419:   }",
          "",
          "[Removed Lines]",
          "6407:  for (s = buf, e = s + buflen - 1; len <= 0 && s < e; s++)",
          "6409:   if (!isprint(*(const unsigned char *)s) && *s != '\\r' && *s != '\\n'",
          "6410:       && *(const unsigned char *)s < 128) {",
          "6415:   } else if (s[0] == '\\n' && s[1] == '\\n') {",
          "6417:   } else if (s[0] == '\\n' && &s[1] < e && s[1] == '\\r' && s[2] == '\\n') {",
          "",
          "[Added Lines]",
          "6410:  for (s = buf, e = s + buflen - 1; (len <= 0) && (s < e); s++)",
          "6412:   if (!isprint(*(const unsigned char *)s) && (*s != '\\r') && (*s != '\\n')",
          "6413:       && (*(const unsigned char *)s < 128)) {",
          "6418:   } else if ((s[0] == '\\n') && (s[1] == '\\n')) {",
          "6420:   } else if ((s[0] == '\\n') && (&s[1] < e) && (s[1] == '\\r')",
          "6421:              && (s[2] == '\\n')) {",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "6510:  while (*s != '\\0') {",
          "6514:    while (s[0] != '\\0') {",
          "6516:      s++;",
          "6518:      s += 2;",
          "6519:     } else {",
          "6520:      break;",
          "",
          "[Removed Lines]",
          "6512:   if (s[-1] == '/' || s[-1] == '\\\\') {",
          "6515:     if (s[0] == '/' || s[0] == '\\\\') {",
          "6517:     } else if (s[0] == '.' && s[1] == '.') {",
          "",
          "[Added Lines]",
          "6516:   if ((s[-1] == '/') || (s[-1] == '\\\\')) {",
          "6519:     if ((s[0] == '/') || (s[0] == '\\\\')) {",
          "6521:     } else if ((s[0] == '.') && (s[1] == '.')) {",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "6638:  for (i = 0; builtin_mime_types[i].extension != NULL; i++) {",
          "6639:   ext = path + (path_len - builtin_mime_types[i].ext_len);",
          "6642:    return builtin_mime_types[i].mime_type;",
          "6643:   }",
          "6644:  }",
          "",
          "[Removed Lines]",
          "6640:   if (path_len > builtin_mime_types[i].ext_len",
          "6641:       && mg_strcasecmp(ext, builtin_mime_types[i].extension) == 0) {",
          "",
          "[Added Lines]",
          "6644:   if ((path_len > builtin_mime_types[i].ext_len)",
          "6645:       && (mg_strcasecmp(ext, builtin_mime_types[i].extension) == 0)) {",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "6659:  path_len = strlen(path);",
          "6662:   if (vec != NULL) {",
          "6663:    memset(vec, '\\0', sizeof(struct vec));",
          "6664:   }",
          "",
          "[Removed Lines]",
          "6661:  if (ctx == NULL || vec == NULL) {",
          "",
          "[Added Lines]",
          "6665:  if ((ctx == NULL) || (vec == NULL)) {",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "6734:  char ha2[32 + 1], expected_response[32 + 1];",
          "6740:   return 0;",
          "6741:  }",
          "",
          "[Removed Lines]",
          "6737:  if (method == NULL || nonce == NULL || nc == NULL || cnonce == NULL",
          "6738:      || qop == NULL",
          "6739:      || response == NULL) {",
          "",
          "[Added Lines]",
          "6741:  if ((method == NULL) || (nonce == NULL) || (nc == NULL) || (cnonce == NULL)",
          "6742:      || (qop == NULL) || (response == NULL)) {",
          "",
          "---------------",
          "--- Hunk 34 ---",
          "[Context before]",
          "6771:                const char *path,",
          "6772:                struct mg_file *filep)",
          "6773: {",
          "6775:   char name[PATH_MAX];",
          "6776:   const char *p, *e, *gpass = conn->ctx->config[GLOBAL_PASSWORDS_FILE];",
          "6777:   int truncated;",
          "",
          "[Removed Lines]",
          "6774:  if (conn != NULL && conn->ctx != NULL) {",
          "",
          "[Added Lines]",
          "6777:  if ((conn != NULL) && (conn->ctx != NULL)) {",
          "",
          "---------------",
          "--- Hunk 35 ---",
          "[Context before]",
          "6858:  }",
          "6860:  (void)memset(ah, 0, sizeof(*ah));",
          "6862:      || mg_strncasecmp(auth_header, \"Digest \", 7) != 0) {",
          "6863:   return 0;",
          "6864:  }",
          "",
          "[Removed Lines]",
          "6861:  if ((auth_header = mg_get_header(conn, \"Authorization\")) == NULL",
          "",
          "[Added Lines]",
          "6864:  if (((auth_header = mg_get_header(conn, \"Authorization\")) == NULL)",
          "",
          "---------------",
          "--- Hunk 36 ---",
          "[Context before]",
          "6964:   return NULL;",
          "6965:  }",
          "6968:   memend = (const char *)&filep->access.membuf[filep->stat.size];",
          "6970:   eof = (char *)memchr(*p, '\\n', (size_t)(memend - *p));",
          "",
          "[Removed Lines]",
          "6967:  if (filep->access.membuf != NULL && *p != NULL) {",
          "",
          "[Added Lines]",
          "6970:  if ((filep->access.membuf != NULL) && (*p != NULL)) {",
          "",
          "---------------",
          "--- Hunk 37 ---",
          "[Context before]",
          "7018:  struct mg_file fp;",
          "7019:  size_t l;",
          "7022:   return 0;",
          "7023:  }",
          "",
          "[Removed Lines]",
          "7021:  if (!filep || !workdata || 0 == depth) {",
          "",
          "[Added Lines]",
          "7024:  if (!filep || !workdata || (0 == depth)) {",
          "",
          "---------------",
          "--- Hunk 38 ---",
          "[Context before]",
          "7264:  fp = fp2 = NULL;",
          "7268:   pass = NULL;",
          "7269:  }",
          "7273:   return 0;",
          "7274:  }",
          "",
          "[Removed Lines]",
          "7267:  if (pass != NULL && pass[0] == '\\0') {",
          "7272:  if (fname == NULL || domain == NULL || user == NULL) {",
          "",
          "[Added Lines]",
          "7270:  if ((pass != NULL) && (pass[0] == '\\0')) {",
          "7275:  if ((fname == NULL) || (domain == NULL) || (user == NULL)) {",
          "",
          "---------------",
          "--- Hunk 39 ---",
          "[Context before]",
          "7288:   if (iscntrl(user[i])) {",
          "7289:    return 0;",
          "7290:   }",
          "",
          "[Removed Lines]",
          "7287:  for (i = 0; i < 255 && user[i] != 0; i++) {",
          "",
          "[Added Lines]",
          "7290:  for (i = 0; ((i < 255) && (user[i] != 0)); i++) {",
          "",
          "---------------",
          "--- Hunk 40 ---",
          "[Context before]",
          "7292:  if (user[i]) {",
          "7293:   return 0;",
          "7294:  }",
          "7296:   if (iscntrl(domain[i])) {",
          "7297:    return 0;",
          "7298:   }",
          "",
          "[Removed Lines]",
          "7295:  for (i = 0; i < 255 && domain[i] != 0; i++) {",
          "",
          "[Added Lines]",
          "7298:  for (i = 0; ((i < 255) && (domain[i] != 0)); i++) {",
          "",
          "---------------",
          "--- Hunk 41 ---",
          "[Context before]",
          "7344:  }",
          "7348:   mg_md5(ha1, user, \":\", domain, \":\", pass, NULL);",
          "7349:   fprintf(fp2, \"%s:%s:%s\\n\", user, domain, ha1);",
          "7350:  }",
          "",
          "[Removed Lines]",
          "7347:  if (!found && pass != NULL) {",
          "",
          "[Added Lines]",
          "7350:  if (!found && (pass != NULL)) {",
          "",
          "---------------",
          "--- Hunk 42 ---",
          "[Context before]",
          "7434:   return 0;",
          "7435:  }",
          "7438:   mg_snprintf(NULL,",
          "7440:               ebuf,",
          "",
          "[Removed Lines]",
          "7437:  if (port <= 0 || !is_valid_port((unsigned)port)) {",
          "",
          "[Added Lines]",
          "7440:  if ((port <= 0) || !is_valid_port((unsigned)port)) {",
          "",
          "---------------",
          "--- Hunk 43 ---",
          "[Context before]",
          "7574:  char *pos = dst;",
          "7575:  const char *end = dst + dst_len - 1;",
          "7578:   if (isalnum(*(const unsigned char *)src)",
          "7581:   } else if (pos + 2 < end) {",
          "7582:    pos[0] = '%';",
          "",
          "[Removed Lines]",
          "7577:  for (; *src != '\\0' && pos < end; src++, pos++) {",
          "7579:       || strchr(dont_escape, *(const unsigned char *)src) != NULL) {",
          "",
          "[Added Lines]",
          "7580:  for (; ((*src != '\\0') && (pos < end)); src++, pos++) {",
          "7582:       || (strchr(dont_escape, *(const unsigned char *)src) != NULL)) {",
          "",
          "---------------",
          "--- Hunk 44 ---",
          "[Context before]",
          "7720:  if (conn && conn->ctx) {",
          "7721:   const char *pw_pattern = \"**\" PASSWORDS_FILE_NAME \"$\";",
          "7722:   const char *pattern = conn->ctx->config[HIDE_FILES];",
          "7726:  }",
          "7727:  return 0;",
          "7728: }",
          "",
          "[Removed Lines]",
          "7723:   return match_prefix(pw_pattern, strlen(pw_pattern), path) > 0",
          "7724:          || (pattern != NULL",
          "7725:              && match_prefix(pattern, strlen(pattern), path) > 0);",
          "",
          "[Added Lines]",
          "7726:   return (match_prefix(pw_pattern, strlen(pw_pattern), path) > 0)",
          "7727:          || ((pattern != NULL)",
          "7728:              && (match_prefix(pattern, strlen(pattern), path) > 0));",
          "",
          "---------------",
          "--- Hunk 45 ---",
          "[Context before]",
          "7876: {",
          "7877:  struct dir_scan_data *dsd = (struct dir_scan_data *)data;",
          "7880:   dsd->arr_size *= 2;",
          "7881:   dsd->entries =",
          "7882:       (struct de *)realloc2(dsd->entries,",
          "",
          "[Removed Lines]",
          "7879:  if (dsd->entries == NULL || dsd->num_entries >= dsd->arr_size) {",
          "",
          "[Added Lines]",
          "7882:  if ((dsd->entries == NULL) || (dsd->num_entries >= dsd->arr_size)) {",
          "",
          "---------------",
          "--- Hunk 46 ---",
          "[Context before]",
          "8094: static void",
          "8095: construct_etag(char *buf, size_t buf_len, const struct mg_file_stat *filestat)",
          "8096: {",
          "8098:   mg_snprintf(NULL,",
          "8100:               buf,",
          "",
          "[Removed Lines]",
          "8097:  if (filestat != NULL && buf != NULL) {",
          "",
          "[Added Lines]",
          "8100:  if ((filestat != NULL) && (buf != NULL)) {",
          "",
          "---------------",
          "--- Hunk 47 ---",
          "[Context before]",
          "8142:  const char *encoding = \"\";",
          "8143:  const char *cors1, *cors2, *cors3;",
          "8146:   return;",
          "8147:  }",
          "",
          "[Removed Lines]",
          "8145:  if (conn == NULL || conn->ctx == NULL || filep == NULL) {",
          "",
          "[Added Lines]",
          "8148:  if ((conn == NULL) || (conn->ctx == NULL) || (filep == NULL)) {",
          "",
          "---------------",
          "--- Hunk 48 ---",
          "[Context before]",
          "8196:  r1 = r2 = 0;",
          "8197:  hdr = mg_get_header(conn, \"Range\");",
          "8202:   if (filep->stat.is_gzipped) {",
          "",
          "[Removed Lines]",
          "8198:  if (hdr != NULL && (n = parse_range_header(hdr, &r1, &r2)) > 0 && r1 >= 0",
          "8199:      && r2 >= 0) {",
          "",
          "[Added Lines]",
          "8201:  if ((hdr != NULL) && ((n = parse_range_header(hdr, &r1, &r2)) > 0)",
          "8202:      && (r1 >= 0) && (r2 >= 0)) {",
          "",
          "---------------",
          "--- Hunk 49 ---",
          "[Context before]",
          "8298:  char date[64], lm[64], etag[64];",
          "8299:  time_t curtime = time(NULL);",
          "8302:   return;",
          "8303:  }",
          "8304:  conn->status_code = 304;",
          "",
          "[Removed Lines]",
          "8301:  if (conn == NULL || filep == NULL) {",
          "",
          "[Added Lines]",
          "8304:  if ((conn == NULL) || (filep == NULL)) {",
          "",
          "---------------",
          "--- Hunk 50 ---",
          "[Context before]",
          "8609:   buf[request_length - 1] = '\\0';",
          "8613:    buf++;",
          "8614:   }",
          "8615:   start_line = skip(&buf, \"\\r\\n\");",
          "",
          "[Removed Lines]",
          "8612:   while (*buf != '\\0' && isspace(*(unsigned char *)buf)) {",
          "",
          "[Added Lines]",
          "8615:   while ((*buf != '\\0') && isspace(*(unsigned char *)buf)) {",
          "",
          "---------------",
          "--- Hunk 51 ---",
          "[Context before]",
          "8731:  const char *inm = mg_get_header(conn, \"If-None-Match\");",
          "8732:  construct_etag(etag, sizeof(etag), filestat);",
          "8735:         || ((ims != NULL)",
          "8736:             && (filestat->last_modified <= parse_date_string(ims)));",
          "8737: }",
          "",
          "[Removed Lines]",
          "8734:  return (inm != NULL && !mg_strcasecmp(etag, inm))",
          "",
          "[Added Lines]",
          "8737:  return ((inm != NULL) && !mg_strcasecmp(etag, inm))",
          "",
          "---------------",
          "--- Hunk 52 ---",
          "[Context before]",
          "8762:   return 0;",
          "8763:  }",
          "8767:   mg_send_http_error(conn,",
          "8768:                      411,",
          "",
          "[Removed Lines]",
          "8765:  if (conn->content_len == -1 && !conn->is_chunked) {",
          "",
          "[Added Lines]",
          "8768:  if ((conn->content_len == -1) && !conn->is_chunked) {",
          "",
          "---------------",
          "--- Hunk 53 ---",
          "[Context before]",
          "8946:  char *p, src_addr[IP_ADDR_STR_LEN], http_var_name[128];",
          "8947:  int i, truncated, uri_len;",
          "8950:   return -1;",
          "8951:  }",
          "",
          "[Removed Lines]",
          "8949:  if (conn == NULL || prog == NULL || env == NULL) {",
          "",
          "[Added Lines]",
          "8952:  if ((conn == NULL) || (prog == NULL) || (env == NULL)) {",
          "",
          "---------------",
          "--- Hunk 54 ---",
          "[Context before]",
          "9178:   p = (char *)prog;",
          "9179:  }",
          "9182:   status = strerror(ERRNO);",
          "9183:   mg_cry(conn,",
          "9184:          \"Error: CGI program \\\"%s\\\": Can not create CGI pipes: %s\",",
          "",
          "[Removed Lines]",
          "9181:  if (pipe(fdin) != 0 || pipe(fdout) != 0 || pipe(fderr) != 0) {",
          "",
          "[Added Lines]",
          "9184:  if ((pipe(fdin) != 0) || (pipe(fdout) != 0) || (pipe(fderr) != 0)) {",
          "",
          "---------------",
          "--- Hunk 55 ---",
          "[Context before]",
          "9614:  fclose_on_exec(&file.access, conn);",
          "9615:  range = mg_get_header(conn, \"Content-Range\");",
          "9616:  r1 = r2 = 0;",
          "9619:   fseeko(file.access.fp, r1, SEEK_SET);",
          "9620:  }",
          "",
          "[Removed Lines]",
          "9617:  if (range != NULL && parse_range_header(range, &r1, &r2) > 0) {",
          "",
          "[Added Lines]",
          "9620:  if ((range != NULL) && parse_range_header(range, &r1, &r2) > 0) {",
          "",
          "---------------",
          "--- Hunk 56 ---",
          "[Context before]",
          "9754:   (void)",
          "9755:       mg_snprintf(conn, &truncated, path, sizeof(path), \"%s\", file_name);",
          "9760:   file_name[511] = 0;",
          "9761:   (void)mg_snprintf(conn, &truncated, path, sizeof(path), \"%s\", ssi);",
          "",
          "[Removed Lines]",
          "9757:  } else if (sscanf(tag, \" file=\\\"%511[^\\\"]\\\"\", file_name) == 1",
          "9758:             || sscanf(tag, \" \\\"%511[^\\\"]\\\"\", file_name) == 1) {",
          "",
          "[Added Lines]",
          "9760:  } else if ((sscanf(tag, \" file=\\\"%511[^\\\"]\\\"\", file_name) == 1)",
          "9761:             || (sscanf(tag, \" \\\"%511[^\\\"]\\\"\", file_name) == 1)) {",
          "",
          "---------------",
          "--- Hunk 57 ---",
          "[Context before]",
          "9831:  if (filep == NULL) {",
          "9832:   return EOF;",
          "9833:  }",
          "9836:   return ((const unsigned char *)filep->access.membuf)[offset];",
          "9837:  } else if (filep->access.fp != NULL) {",
          "9838:   return fgetc(filep->access.fp);",
          "",
          "[Removed Lines]",
          "9834:  if (filep->access.membuf != NULL && offset >= 0",
          "9835:      && ((unsigned int)(offset)) < filep->stat.size) {",
          "",
          "[Added Lines]",
          "9837:  if ((filep->access.membuf != NULL) && (offset >= 0)",
          "9838:      && (((unsigned int)(offset)) < filep->stat.size)) {",
          "",
          "---------------",
          "--- Hunk 58 ---",
          "[Context before]",
          "9857:  }",
          "9859:  in_ssi_tag = len = offset = 0;",
          "9862:    in_ssi_tag = 0;",
          "9863:    buf[len++] = (char)ch;",
          "9864:    buf[len] = '\\0';",
          "",
          "[Removed Lines]",
          "9860:  while ((ch = mg_fgetc(filep, offset)) != EOF) {",
          "9861:   if (in_ssi_tag && ch == '>') {",
          "",
          "[Added Lines]",
          "9863:  while ((ch = mg_fgetc(filep, offset++)) != EOF) {",
          "9864:   if (in_ssi_tag && (ch == '>')) {",
          "",
          "---------------",
          "--- Hunk 59 ---",
          "[Context before]",
          "9866:    if (len > (int)sizeof(buf)) {",
          "9867:     break;",
          "9868:    }",
          "9871:     (void)mg_write(conn, buf, (size_t)len);",
          "9872:    } else {",
          "",
          "[Removed Lines]",
          "9869:             if ((len < 6) || (memcmp(buf, \"<!--#\", 5) != 0)) {",
          "",
          "[Added Lines]",
          "9872:    if ((len < 6) || (memcmp(buf, \"<!--#\", 5) != 0)) {",
          "",
          "---------------",
          "--- Hunk 60 ---",
          "[Context before]",
          "9886:    }",
          "9887:    len = 0;",
          "9888:   } else if (in_ssi_tag) {",
          "9891:     in_ssi_tag = 0;",
          "9893:     mg_cry(conn, \"%s: SSI tag is too large\", path);",
          "9894:     len = 0;",
          "9895:    }",
          "",
          "[Removed Lines]",
          "9889:    if (len == 5 && memcmp(buf, \"<!--#\", 5) != 0) {",
          "9892:    } else if (len == (int)sizeof(buf) - 2) {",
          "",
          "[Added Lines]",
          "9892:    if ((len == 5) && (memcmp(buf, \"<!--#\", 5) != 0)) {",
          "9895:    } else if (len == ((int)sizeof(buf) - 2)) {",
          "",
          "---------------",
          "--- Hunk 61 ---",
          "[Context before]",
          "9926:  time_t curtime = time(NULL);",
          "9927:  const char *cors1, *cors2, *cors3;",
          "9930:   return;",
          "9931:  }",
          "",
          "[Removed Lines]",
          "9929:  if (conn == NULL || path == NULL || filep == NULL) {",
          "",
          "[Added Lines]",
          "9932:  if ((conn == NULL) || (path == NULL) || (filep == NULL)) {",
          "",
          "---------------",
          "--- Hunk 62 ---",
          "[Context before]",
          "10010: {",
          "10011:  char mtime[64];",
          "10014:   return;",
          "10015:  }",
          "",
          "[Removed Lines]",
          "10013:  if (conn == NULL || uri == NULL || filep == NULL) {",
          "",
          "[Added Lines]",
          "10016:  if ((conn == NULL) || (uri == NULL) || (filep == NULL)) {",
          "",
          "---------------",
          "--- Hunk 63 ---",
          "[Context before]",
          "10109:  if (filep && filep->is_directory",
          "10110:      && !mg_strcasecmp(conn->ctx->config[ENABLE_DIRECTORY_LISTING], \"yes\")",
          "10112:   scan_directory(conn, path, conn, &print_dav_dir_entry);",
          "10113:  }",
          "",
          "[Removed Lines]",
          "10111:      && (depth == NULL || strcmp(depth, \"0\") != 0)) {",
          "",
          "[Added Lines]",
          "10114:      && ((depth == NULL) || (strcmp(depth, \"0\") != 0))) {",
          "",
          "---------------",
          "--- Hunk 64 ---",
          "[Context before]",
          "10272:    }",
          "10273:   }",
          "10277:    data = mem;",
          "10278:    if (data_len > sizeof(mem)) {",
          "",
          "[Removed Lines]",
          "10275:   if (header_len > 0 && body_len >= header_len) {",
          "",
          "[Added Lines]",
          "10278:   if ((header_len > 0) && (body_len >= header_len)) {",
          "",
          "---------------",
          "--- Hunk 65 ---",
          "[Context before]",
          "10590:   mg_send_http_error(conn, 426, \"%s\", \"Protocol upgrade required\");",
          "10591:   return;",
          "",
          "[Removed Lines]",
          "10588:  if (version == NULL || strcmp(version, \"13\") != 0) {",
          "",
          "[Added Lines]",
          "10591:  if ((version == NULL) || (strcmp(version, \"13\") != 0)) {",
          "",
          "---------------",
          "--- Hunk 66 ---",
          "[Context before]",
          "10602:                                         \"Sec-WebSocket-Protocol\",",
          "10603:                                         protocols,",
          "10604:                                         64);",
          "10606:    int cnt = 0;",
          "10607:    int idx;",
          "10608:    unsigned long len;",
          "",
          "[Removed Lines]",
          "10605:   if (nbSubprotocolHeader > 0 && subprotocols) {",
          "",
          "[Added Lines]",
          "10608:   if ((nbSubprotocolHeader > 0) && subprotocols) {",
          "",
          "---------------",
          "--- Hunk 67 ---",
          "[Context before]",
          "10618:      sep = strchr(protocol, ',');",
          "10619:      curSubProtocol = protocol;",
          "10620:      len = sep ? (unsigned long)(sep - protocol)",
          "10622:      while (sep && isspace(*++sep))",
          "10623:       ; // ignore leading whitespaces",
          "10624:      protocol = sep;",
          "",
          "[Removed Lines]",
          "10621:                               : (unsigned long)strlen(protocol);",
          "",
          "[Added Lines]",
          "10624:                : (unsigned long)strlen(protocol);",
          "",
          "---------------",
          "--- Hunk 68 ---",
          "[Context before]",
          "10666:    }",
          "10667:   }",
          "",
          "[Removed Lines]",
          "10669:   if (ws_connect_handler != NULL",
          "10670:       && ws_connect_handler(conn, cbData) != 0) {",
          "",
          "[Added Lines]",
          "10672:   if ((ws_connect_handler != NULL)",
          "10673:       && (ws_connect_handler(conn, cbData) != 0)) {",
          "",
          "---------------",
          "--- Hunk 69 ---",
          "[Context before]",
          "10789: static int",
          "10790: isbyte(int n)",
          "10791: {",
          "10793: }",
          "",
          "[Removed Lines]",
          "10792:  return n >= 0 && n <= 255;",
          "",
          "[Added Lines]",
          "10795:  return (n >= 0) && (n <= 255);",
          "",
          "---------------",
          "--- Hunk 70 ---",
          "[Context before]",
          "10798: {",
          "10799:  int n, a, b, c, d, slash = 32, len = 0;",
          "10805:   len = n;",
          "10807:          | (uint32_t)d;",
          "",
          "[Removed Lines]",
          "10801:  if ((sscanf(spec, \"%d.%d.%d.%d/%d%n\", &a, &b, &c, &d, &slash, &n) == 5",
          "10802:       || sscanf(spec, \"%d.%d.%d.%d%n\", &a, &b, &c, &d, &n) == 4) && isbyte(a)",
          "10803:      && isbyte(b) && isbyte(c) && isbyte(d) && slash >= 0",
          "10804:      && slash < 33) {",
          "",
          "[Added Lines]",
          "10804:  if (((sscanf(spec, \"%d.%d.%d.%d/%d%n\", &a, &b, &c, &d, &slash, &n) == 5)",
          "10805:       || (sscanf(spec, \"%d.%d.%d.%d%n\", &a, &b, &c, &d, &n) == 4))",
          "10806:      && isbyte(a) && isbyte(b) && isbyte(c) && isbyte(d) && (slash >= 0)",
          "10807:      && (slash < 33)) {",
          "",
          "---------------",
          "--- Hunk 71 ---",
          "[Context before]",
          "10964:  unsigned int i;",
          "10965:  int idx = -1;",
          "10966:  if (ctx) {",
          "10968:    idx = ctx->listening_sockets[i].is_ssl ? ((int)(i)) : -1;",
          "10969:   }",
          "10970:  }",
          "",
          "[Removed Lines]",
          "10967:   for (i = 0; idx == -1 && i < ctx->num_listening_sockets; i++) {",
          "",
          "[Added Lines]",
          "10970:   for (i = 0; ((idx == -1) && (i < ctx->num_listening_sockets)); i++) {",
          "",
          "---------------",
          "--- Hunk 72 ---",
          "[Context before]",
          "11048:   if (handler != NULL) {",
          "11049:    return;",
          "11050:   }",
          "11055:    return;",
          "11056:   }",
          "11057:   if (auth_handler != NULL) {",
          "",
          "[Removed Lines]",
          "11051:   if (!is_delete_request && connect_handler == NULL",
          "11052:       && ready_handler == NULL",
          "11053:       && data_handler == NULL",
          "11054:       && close_handler == NULL) {",
          "",
          "[Added Lines]",
          "11054:   if (!is_delete_request && (connect_handler == NULL)",
          "11055:       && (ready_handler == NULL) && (data_handler == NULL)",
          "11056:       && (close_handler == NULL)) {",
          "",
          "---------------",
          "--- Hunk 73 ---",
          "[Context before]",
          "11069:    return;",
          "11070:   }",
          "11071:   if (!is_delete_request && (handler == NULL)) {",
          "",
          "[Removed Lines]",
          "11066:   if (connect_handler != NULL || ready_handler != NULL",
          "11067:       || data_handler != NULL",
          "11068:       || close_handler != NULL) {",
          "",
          "[Added Lines]",
          "11068:   if ((connect_handler != NULL) || (ready_handler != NULL)",
          "11069:       || (data_handler != NULL) || (close_handler != NULL)) {",
          "",
          "---------------",
          "--- Hunk 74 ---",
          "[Context before]",
          "11082:   if (handler != NULL) {",
          "11083:    return;",
          "11084:   }",
          "11088:    return;",
          "11089:   }",
          "11090:   if (!is_delete_request && (auth_handler == NULL)) {",
          "",
          "[Removed Lines]",
          "11085:   if (connect_handler != NULL || ready_handler != NULL",
          "11086:       || data_handler != NULL",
          "11087:       || close_handler != NULL) {",
          "",
          "[Added Lines]",
          "11086:   if ((connect_handler != NULL) || (ready_handler != NULL)",
          "11087:       || (data_handler != NULL) || (close_handler != NULL)) {",
          "",
          "---------------",
          "--- Hunk 75 ---",
          "[Context before]",
          "11102:  lastref = &(ctx->handlers);",
          "11103:  for (tmp_rh = ctx->handlers; tmp_rh != NULL; tmp_rh = tmp_rh->next) {",
          "11104:   if (tmp_rh->handler_type == handler_type) {",
          "11106:     if (!is_delete_request) {",
          "11108:      if (handler_type == REQUEST_HANDLER) {",
          "",
          "[Removed Lines]",
          "11105:    if (urilen == tmp_rh->uri_len && !strcmp(tmp_rh->uri, uri)) {",
          "",
          "[Added Lines]",
          "11105:    if ((urilen == tmp_rh->uri_len) && !strcmp(tmp_rh->uri, uri)) {",
          "",
          "---------------",
          "--- Hunk 76 ---",
          "[Context before]",
          "11293:   for (tmp_rh = conn->ctx->handlers; tmp_rh != NULL;",
          "11294:        tmp_rh = tmp_rh->next) {",
          "11295:    if (tmp_rh->handler_type == handler_type) {",
          "11297:      if (handler_type == WEBSOCKET_HANDLER) {",
          "",
          "[Removed Lines]",
          "11296:     if (urilen == tmp_rh->uri_len && !strcmp(tmp_rh->uri, uri)) {",
          "",
          "[Added Lines]",
          "11296:     if ((urilen == tmp_rh->uri_len) && !strcmp(tmp_rh->uri, uri)) {",
          "",
          "---------------",
          "--- Hunk 77 ---",
          "[Context before]",
          "11316:   for (tmp_rh = conn->ctx->handlers; tmp_rh != NULL;",
          "11317:        tmp_rh = tmp_rh->next) {",
          "11318:    if (tmp_rh->handler_type == handler_type) {",
          "11321:      if (handler_type == WEBSOCKET_HANDLER) {",
          "",
          "[Removed Lines]",
          "11319:     if (tmp_rh->uri_len < urilen && uri[tmp_rh->uri_len] == '/'",
          "11320:         && memcmp(tmp_rh->uri, uri, tmp_rh->uri_len) == 0) {",
          "",
          "[Added Lines]",
          "11319:     if ((tmp_rh->uri_len < urilen) && (uri[tmp_rh->uri_len] == '/')",
          "11320:         && (memcmp(tmp_rh->uri, uri, tmp_rh->uri_len) == 0)) {",
          "",
          "---------------",
          "--- Hunk 78 ---",
          "[Context before]",
          "11873:   return;",
          "11874:  }",
          "11878:   mg_send_http_error(conn,",
          "11879:                      405,",
          "11880:                      \"%s method not allowed\",",
          "",
          "[Removed Lines]",
          "11876:  if (0 != strcmp(ri->request_method, \"GET\")",
          "11877:      && 0 != strcmp(ri->request_method, \"HEAD\")) {",
          "",
          "[Added Lines]",
          "11876:  if ((0 != strcmp(ri->request_method, \"GET\"))",
          "11877:      && (0 != strcmp(ri->request_method, \"HEAD\"))) {",
          "",
          "---------------",
          "--- Hunk 79 ---",
          "[Context before]",
          "12146:  if (is_valid_port(port)",
          "12148:   return 1;",
          "12149:  }",
          "",
          "[Removed Lines]",
          "12147:      && (ch == '\\0' || ch == 's' || ch == 'r' || ch == ',')) {",
          "",
          "[Added Lines]",
          "12147:      && ((ch == '\\0') || (ch == 's') || (ch == 'r') || (ch == ','))) {",
          "",
          "---------------",
          "--- Hunk 80 ---",
          "[Context before]",
          "12327:    continue;",
          "12328:   }",
          "12333:    int err = (int)ERRNO;",
          "12334:    mg_cry(fc(ctx),",
          "",
          "[Removed Lines]",
          "12330:   if (getsockname(so.sock, &(usa.sa), &len) != 0",
          "12331:       || usa.sa.sa_family != so.lsa.sa.sa_family) {",
          "",
          "[Added Lines]",
          "12330:   if ((getsockname(so.sock, &(usa.sa), &len) != 0)",
          "12331:       || (usa.sa.sa_family != so.lsa.sa.sa_family)) {",
          "",
          "---------------",
          "--- Hunk 81 ---",
          "[Context before]",
          "12518:   while ((list = next_option(list, &vec, NULL)) != NULL) {",
          "12519:    flag = vec.ptr[0];",
          "12520:    if ((flag != '+' && flag != '-')",
          "12522:     mg_cry(fc(ctx),",
          "12523:            \"%s: subnet must be [+|-]x.x.x.x[/x]\",",
          "12524:            __func__);",
          "",
          "[Removed Lines]",
          "12521:        || parse_net(&vec.ptr[1], &net, &mask) == 0) {",
          "",
          "[Added Lines]",
          "12521:        || (parse_net(&vec.ptr[1], &net, &mask) == 0)) {",
          "",
          "---------------",
          "--- Hunk 82 ---",
          "[Context before]",
          "12797:  int i;",
          "12798:  const char hexdigit[] = \"0123456789abcdef\";",
          "12801:   return 0;",
          "12802:  }",
          "12803:  if (buflen < (3 * memlen)) {",
          "",
          "[Removed Lines]",
          "12800:  if (memlen <= 0 || buflen <= 0) {",
          "",
          "[Added Lines]",
          "12800:  if ((memlen <= 0) || (buflen <= 0)) {",
          "",
          "---------------",
          "--- Hunk 83 ---",
          "[Context before]",
          "13340:   }",
          "13342:   if (use_default_verify_paths",
          "13344:    mg_cry(fc(ctx),",
          "13345:           \"SSL_CTX_set_default_verify_paths error: %s\",",
          "13346:           ssl_error());",
          "",
          "[Removed Lines]",
          "13343:       && SSL_CTX_set_default_verify_paths(ctx->ssl_ctx) != 1) {",
          "",
          "[Added Lines]",
          "13343:       && (SSL_CTX_set_default_verify_paths(ctx->ssl_ctx) != 1)) {",
          "",
          "---------------",
          "--- Hunk 84 ---",
          "[Context before]",
          "13411:  if (ctx) {",
          "13412:   struct mg_file file = STRUCT_FILE_INITIALIZER;",
          "13413:   const char *path = ctx->config[GLOBAL_PASSWORDS_FILE];",
          "13415:    mg_cry(fc(ctx), \"Cannot open %s: %s\", path, strerror(ERRNO));",
          "13416:    return 0;",
          "13417:   }",
          "",
          "[Removed Lines]",
          "13414:   if (path != NULL && !mg_stat(fc(ctx), path, &file.stat)) {",
          "",
          "[Added Lines]",
          "13414:   if ((path != NULL) && !mg_stat(fc(ctx), path, &file.stat)) {",
          "",
          "---------------",
          "--- Hunk 85 ---",
          "[Context before]",
          "13941:   return 1;",
          "13942:  }",
          "",
          "[Removed Lines]",
          "13939:  if (uri[0] == '*' && uri[1] == '\\0') {",
          "",
          "[Added Lines]",
          "13939:  if ((uri[0] == '*') && (uri[1] == '\\0')) {",
          "",
          "---------------",
          "--- Hunk 86 ---",
          "[Context before]",
          "14163:      read_request(NULL, conn, conn->buf, conn->buf_size, &conn->data_len);",
          "14167:   mg_snprintf(conn,",
          "14169:               ebuf,",
          "",
          "[Removed Lines]",
          "14166:  if (conn->request_len >= 0 && conn->data_len < conn->request_len) {",
          "",
          "[Added Lines]",
          "14166:  if ((conn->request_len >= 0) && (conn->data_len < conn->request_len)) {",
          "",
          "---------------",
          "--- Hunk 87 ---",
          "[Context before]",
          "14174:   return 0;",
          "14175:  }",
          "14178:   mg_snprintf(conn,",
          "14180:               ebuf,",
          "",
          "[Removed Lines]",
          "14177:  if (conn->request_len == 0 && conn->data_len == conn->buf_size) {",
          "",
          "[Added Lines]",
          "14177:  if ((conn->request_len == 0) && (conn->data_len == conn->buf_size)) {",
          "",
          "---------------",
          "--- Hunk 88 ---",
          "[Context before]",
          "14454:                     origin);",
          "14458:   if (!*error_buffer) {",
          "",
          "[Removed Lines]",
          "14457:  if (conn == NULL || (strcmp(conn->request_info.request_uri, \"101\") != 0)) {",
          "",
          "[Added Lines]",
          "14457:  if ((conn == NULL)",
          "14458:      || (strcmp(conn->request_info.request_uri, \"101\") != 0)) {",
          "",
          "---------------",
          "--- Hunk 89 ---",
          "[Context before]",
          "14747:  DEBUG_TRACE(\"%s\", \"going idle\");",
          "14751:   pthread_cond_wait(&ctx->sq_full, &ctx->thread_mutex);",
          "14752:  }",
          "",
          "[Removed Lines]",
          "14750:  while (ctx->sq_head == ctx->sq_tail && ctx->stop_flag == 0) {",
          "",
          "[Added Lines]",
          "14751:  while ((ctx->sq_head == ctx->sq_tail) && (ctx->stop_flag == 0)) {",
          "",
          "---------------",
          "--- Hunk 90 ---",
          "[Context before]",
          "14785:  (void)pthread_mutex_lock(&ctx->thread_mutex);",
          "14790:   (void)pthread_cond_wait(&ctx->sq_empty, &ctx->thread_mutex);",
          "14791:  }",
          "",
          "[Removed Lines]",
          "14788:  while (ctx->stop_flag == 0",
          "14789:         && ctx->sq_head - ctx->sq_tail >= QUEUE_SIZE(ctx)) {",
          "",
          "[Added Lines]",
          "14789:  while ((ctx->stop_flag == 0)",
          "14790:         && (ctx->sq_head - ctx->sq_tail >= QUEUE_SIZE(ctx))) {",
          "",
          "---------------",
          "--- Hunk 91 ---",
          "[Context before]",
          "15127:      accept_new_connection(&ctx->listening_sockets[i], ctx);",
          "15128:     }",
          "15129:    }",
          "",
          "[Removed Lines]",
          "15126:     if (ctx->stop_flag == 0 && (pfd[i].revents & POLLIN)) {",
          "",
          "[Added Lines]",
          "15127:     if ((ctx->stop_flag == 0) && (pfd[i].revents & POLLIN)) {",
          "",
          "---------------",
          "--- Hunk 92 ---",
          "[Context before]",
          "15508:  for (i = 0; config_options[i].name != NULL; i++) {",
          "15509:   default_value = config_options[i].default_value;",
          "15511:    ctx->config[i] = mg_strdup(default_value);",
          "15512:   }",
          "15513:  }",
          "",
          "[Removed Lines]",
          "15510:   if (ctx->config[i] == NULL && default_value != NULL) {",
          "",
          "[Added Lines]",
          "15511:   if ((ctx->config[i] == NULL) && (default_value != NULL)) {",
          "",
          "---------------"
        ]
      }
    }
  ]
}
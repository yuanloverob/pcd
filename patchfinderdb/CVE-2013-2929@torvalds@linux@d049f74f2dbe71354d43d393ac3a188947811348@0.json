{
  "cve_id": "CVE-2013-2929",
  "cve_desc": "The Linux kernel before 3.12.2 does not properly use the get_dumpable function, which allows local users to bypass intended ptrace restrictions or obtain sensitive information from IA64 scratch registers via a crafted application, related to kernel/ptrace.c and arch/ia64/include/asm/processor.h.",
  "repo": "torvalds/linux",
  "patch_hash": "d049f74f2dbe71354d43d393ac3a188947811348",
  "patch_info": {
    "commit_hash": "d049f74f2dbe71354d43d393ac3a188947811348",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/d049f74f2dbe71354d43d393ac3a188947811348",
    "files": [
      "arch/ia64/include/asm/processor.h",
      "fs/exec.c",
      "include/linux/binfmts.h",
      "include/linux/sched.h",
      "kernel/ptrace.c"
    ],
    "message": "exec/ptrace: fix get_dumpable() incorrect tests\n\nThe get_dumpable() return value is not boolean.  Most users of the\nfunction actually want to be testing for non-SUID_DUMP_USER(1) rather than\nSUID_DUMP_DISABLE(0).  The SUID_DUMP_ROOT(2) is also considered a\nprotected state.  Almost all places did this correctly, excepting the two\nplaces fixed in this patch.\n\nWrong logic:\n    if (dumpable == SUID_DUMP_DISABLE) { /* be protective */ }\n        or\n    if (dumpable == 0) { /* be protective */ }\n        or\n    if (!dumpable) { /* be protective */ }\n\nCorrect logic:\n    if (dumpable != SUID_DUMP_USER) { /* be protective */ }\n        or\n    if (dumpable != 1) { /* be protective */ }\n\nWithout this patch, if the system had set the sysctl fs/suid_dumpable=2, a\nuser was able to ptrace attach to processes that had dropped privileges to\nthat user.  (This may have been partially mitigated if Yama was enabled.)\n\nThe macros have been moved into the file that declares get/set_dumpable(),\nwhich means things like the ia64 code can see them too.\n\nCVE-2013-2929\n\nReported-by: Vasily Kulikov <segoon@openwall.com>\nSigned-off-by: Kees Cook <keescook@chromium.org>\nCc: \"Luck, Tony\" <tony.luck@intel.com>\nCc: Oleg Nesterov <oleg@redhat.com>\nCc: \"Eric W. Biederman\" <ebiederm@xmission.com>\nCc: <stable@vger.kernel.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
    "before_after_code_files": [
      "arch/ia64/include/asm/processor.h||arch/ia64/include/asm/processor.h",
      "fs/exec.c||fs/exec.c",
      "include/linux/binfmts.h||include/linux/binfmts.h",
      "include/linux/sched.h||include/linux/sched.h",
      "kernel/ptrace.c||kernel/ptrace.c"
    ]
  },
  "patch_diff": {
    "arch/ia64/include/asm/processor.h||arch/ia64/include/asm/processor.h": [
      "File: arch/ia64/include/asm/processor.h -> arch/ia64/include/asm/processor.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "319:  regs->loadrs = 0;         \\",
      "320:  regs->r8 = get_dumpable(current->mm); /* set \"don't zap registers\" flag */  \\",
      "321:  regs->r12 = new_sp - 16; /* allocate 16 byte scratch area */   \\",
      "",
      "[Removed Lines]",
      "322:  if (unlikely(!get_dumpable(current->mm))) {       \\",
      "",
      "[Added Lines]",
      "322:  if (unlikely(get_dumpable(current->mm) != SUID_DUMP_USER)) { \\",
      "",
      "---------------"
    ],
    "fs/exec.c||fs/exec.c": [
      "File: fs/exec.c -> fs/exec.c"
    ],
    "include/linux/binfmts.h||include/linux/binfmts.h": [
      "File: include/linux/binfmts.h -> include/linux/binfmts.h"
    ],
    "include/linux/sched.h||include/linux/sched.h": [
      "File: include/linux/sched.h -> include/linux/sched.h"
    ],
    "kernel/ptrace.c||kernel/ptrace.c": [
      "File: kernel/ptrace.c -> kernel/ptrace.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "257:  if (task->mm)",
      "258:   dumpable = get_dumpable(task->mm);",
      "259:  rcu_read_lock();",
      "261:   rcu_read_unlock();",
      "262:   return -EPERM;",
      "263:  }",
      "",
      "[Removed Lines]",
      "260:  if (!dumpable && !ptrace_has_cap(__task_cred(task)->user_ns, mode)) {",
      "",
      "[Added Lines]",
      "260:  if (dumpable != SUID_DUMP_USER &&",
      "261:      !ptrace_has_cap(__task_cred(task)->user_ns, mode)) {",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "4c44aaafa8108f584831850ab48a975e971db2de",
      "candidate_info": {
        "commit_hash": "4c44aaafa8108f584831850ab48a975e971db2de",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/4c44aaafa8108f584831850ab48a975e971db2de",
        "files": [
          "include/linux/cred.h",
          "kernel/ptrace.c",
          "kernel/sched/core.c",
          "security/yama/yama_lsm.c"
        ],
        "message": "userns: Kill task_user_ns\n\nThe task_user_ns function hides the fact that it is getting the user\nnamespace from struct cred on the task.  struct cred may go away as\nsoon as the rcu lock is released.  This leads to a race where we\ncan dereference a stale user namespace pointer.\n\nTo make it obvious a struct cred is involved kill task_user_ns.\n\nTo kill the race modify the users of task_user_ns to only\nreference the user namespace while the rcu lock is held.\n\nCc: Kees Cook <keescook@chromium.org>\nCc: James Morris <james.l.morris@oracle.com>\nAcked-by: Kees Cook <keescook@chromium.org>\nAcked-by: Serge Hallyn <serge.hallyn@canonical.com>\nSigned-off-by: \"Eric W. Biederman\" <ebiederm@xmission.com>",
        "before_after_code_files": [
          "include/linux/cred.h||include/linux/cred.h",
          "kernel/ptrace.c||kernel/ptrace.c",
          "kernel/sched/core.c||kernel/sched/core.c",
          "security/yama/yama_lsm.c||security/yama/yama_lsm.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "kernel/ptrace.c||kernel/ptrace.c"
          ],
          "candidate": [
            "kernel/ptrace.c||kernel/ptrace.c"
          ]
        }
      },
      "candidate_diff": {
        "include/linux/cred.h||include/linux/cred.h": [
          "File: include/linux/cred.h -> include/linux/cred.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "357: extern struct user_namespace init_user_ns;",
          "358: #ifdef CONFIG_USER_NS",
          "359: #define current_user_ns() (current_cred_xxx(user_ns))",
          "361: #else",
          "362: #define current_user_ns() (&init_user_ns)",
          "364: #endif",
          "",
          "[Removed Lines]",
          "360: #define task_user_ns(task) (task_cred_xxx((task), user_ns))",
          "363: #define task_user_ns(task) (&init_user_ns)",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "kernel/ptrace.c||kernel/ptrace.c": [
          "File: kernel/ptrace.c -> kernel/ptrace.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "215:  smp_rmb();",
          "216:  if (task->mm)",
          "217:   dumpable = get_dumpable(task->mm);",
          "219:   return -EPERM;",
          "221:  return security_ptrace_access_check(task, mode);",
          "222: }",
          "",
          "[Removed Lines]",
          "218:  if (!dumpable  && !ptrace_has_cap(task_user_ns(task), mode))",
          "",
          "[Added Lines]",
          "218:  rcu_read_lock();",
          "219:  if (!dumpable && !ptrace_has_cap(__task_cred(task)->user_ns, mode)) {",
          "220:   rcu_read_unlock();",
          "222:  }",
          "223:  rcu_read_unlock();",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "281:  if (seize)",
          "282:   flags |= PT_SEIZED;",
          "284:   flags |= PT_PTRACE_CAP;",
          "285:  task->ptrace = flags;",
          "287:  __ptrace_link(task, current);",
          "",
          "[Removed Lines]",
          "283:  if (ns_capable(task_user_ns(task), CAP_SYS_PTRACE))",
          "",
          "[Added Lines]",
          "287:  rcu_read_lock();",
          "288:  if (ns_capable(__task_cred(task)->user_ns, CAP_SYS_PTRACE))",
          "290:  rcu_read_unlock();",
          "",
          "---------------"
        ],
        "kernel/sched/core.c||kernel/sched/core.c": [
          "File: kernel/sched/core.c -> kernel/sched/core.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4029:   goto out_free_cpus_allowed;",
          "4030:  }",
          "4031:  retval = -EPERM;",
          "4035:  retval = security_task_setscheduler(p);",
          "4036:  if (retval)",
          "",
          "[Removed Lines]",
          "4032:  if (!check_same_owner(p) && !ns_capable(task_user_ns(p), CAP_SYS_NICE))",
          "4033:   goto out_unlock;",
          "",
          "[Added Lines]",
          "4032:  if (!check_same_owner(p)) {",
          "4033:   rcu_read_lock();",
          "4034:   if (!ns_capable(__task_cred(p)->user_ns, CAP_SYS_NICE)) {",
          "4035:    rcu_read_unlock();",
          "4036:    goto out_unlock;",
          "4037:   }",
          "4038:   rcu_read_unlock();",
          "4039:  }",
          "",
          "---------------"
        ],
        "security/yama/yama_lsm.c||security/yama/yama_lsm.c": [
          "File: security/yama/yama_lsm.c -> security/yama/yama_lsm.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "263:    break;",
          "264:   case YAMA_SCOPE_RELATIONAL:",
          "265:    if (!task_is_descendant(current, child) &&",
          "266:        !ptracer_exception_found(current, child) &&",
          "268:     rc = -EPERM;",
          "269:    break;",
          "270:   case YAMA_SCOPE_CAPABILITY:",
          "272:     rc = -EPERM;",
          "273:    break;",
          "274:   case YAMA_SCOPE_NO_ATTACH:",
          "275:   default:",
          "",
          "[Removed Lines]",
          "267:        !ns_capable(task_user_ns(child), CAP_SYS_PTRACE))",
          "271:    if (!ns_capable(task_user_ns(child), CAP_SYS_PTRACE))",
          "",
          "[Added Lines]",
          "265:    rcu_read_lock();",
          "268:        !ns_capable(__task_cred(child)->user_ns, CAP_SYS_PTRACE))",
          "270:    rcu_read_unlock();",
          "273:    rcu_read_lock();",
          "274:    if (!ns_capable(__task_cred(child)->user_ns, CAP_SYS_PTRACE))",
          "276:    rcu_read_unlock();",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "308:  switch (ptrace_scope) {",
          "309:  case YAMA_SCOPE_CAPABILITY:",
          "311:    rc = -EPERM;",
          "312:   break;",
          "313:  case YAMA_SCOPE_NO_ATTACH:",
          "314:   rc = -EPERM;",
          "",
          "[Removed Lines]",
          "310:   if (!ns_capable(task_user_ns(parent), CAP_SYS_PTRACE))",
          "",
          "[Added Lines]",
          "314:   rcu_read_lock();",
          "315:   if (!ns_capable(__task_cred(parent)->user_ns, CAP_SYS_PTRACE))",
          "317:   rcu_read_unlock();",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2019-11599",
  "cve_desc": "The coredump implementation in the Linux kernel before 5.0.10 does not use locking or other mechanisms to prevent vma layout or vma flags changes while it runs, which allows local users to obtain sensitive information, cause a denial of service, or possibly have unspecified other impact by triggering a race condition with mmget_not_zero or get_task_mm calls. This is related to fs/userfaultfd.c, mm/mmap.c, fs/proc/task_mmu.c, and drivers/infiniband/core/uverbs_main.c.",
  "repo": "torvalds/linux",
  "patch_hash": "04f5866e41fb70690e28397487d8bd8eea7d712a",
  "patch_info": {
    "commit_hash": "04f5866e41fb70690e28397487d8bd8eea7d712a",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/04f5866e41fb70690e28397487d8bd8eea7d712a",
    "files": [
      "drivers/infiniband/core/uverbs_main.c",
      "fs/proc/task_mmu.c",
      "fs/userfaultfd.c",
      "include/linux/sched/mm.h",
      "mm/mmap.c"
    ],
    "message": "coredump: fix race condition between mmget_not_zero()/get_task_mm() and core dumping\n\nThe core dumping code has always run without holding the mmap_sem for\nwriting, despite that is the only way to ensure that the entire vma\nlayout will not change from under it.  Only using some signal\nserialization on the processes belonging to the mm is not nearly enough.\nThis was pointed out earlier.  For example in Hugh's post from Jul 2017:\n\n  https://lkml.kernel.org/r/alpine.LSU.2.11.1707191716030.2055@eggly.anvils\n\n  \"Not strictly relevant here, but a related note: I was very surprised\n   to discover, only quite recently, how handle_mm_fault() may be called\n   without down_read(mmap_sem) - when core dumping. That seems a\n   misguided optimization to me, which would also be nice to correct\"\n\nIn particular because the growsdown and growsup can move the\nvm_start/vm_end the various loops the core dump does around the vma will\nnot be consistent if page faults can happen concurrently.\n\nPretty much all users calling mmget_not_zero()/get_task_mm() and then\ntaking the mmap_sem had the potential to introduce unexpected side\neffects in the core dumping code.\n\nAdding mmap_sem for writing around the ->core_dump invocation is a\nviable long term fix, but it requires removing all copy user and page\nfaults and to replace them with get_dump_page() for all binary formats\nwhich is not suitable as a short term fix.\n\nFor the time being this solution manually covers the places that can\nconfuse the core dump either by altering the vma layout or the vma flags\nwhile it runs.  Once ->core_dump runs under mmap_sem for writing the\nfunction mmget_still_valid() can be dropped.\n\nAllowing mmap_sem protected sections to run in parallel with the\ncoredump provides some minor parallelism advantage to the swapoff code\n(which seems to be safe enough by never mangling any vma field and can\nkeep doing swapins in parallel to the core dumping) and to some other\ncorner case.\n\nIn order to facilitate the backporting I added \"Fixes: 86039bd3b4e6\"\nhowever the side effect of this same race condition in /proc/pid/mem\nshould be reproducible since before 2.6.12-rc2 so I couldn't add any\nother \"Fixes:\" because there's no hash beyond the git genesis commit.\n\nBecause find_extend_vma() is the only location outside of the process\ncontext that could modify the \"mm\" structures under mmap_sem for\nreading, by adding the mmget_still_valid() check to it, all other cases\nthat take the mmap_sem for reading don't need the new check after\nmmget_not_zero()/get_task_mm().  The expand_stack() in page fault\ncontext also doesn't need the new check, because all tasks under core\ndumping are frozen.\n\nLink: http://lkml.kernel.org/r/20190325224949.11068-1-aarcange@redhat.com\nFixes: 86039bd3b4e6 (\"userfaultfd: add new syscall to provide memory externalization\")\nSigned-off-by: Andrea Arcangeli <aarcange@redhat.com>\nReported-by: Jann Horn <jannh@google.com>\nSuggested-by: Oleg Nesterov <oleg@redhat.com>\nAcked-by: Peter Xu <peterx@redhat.com>\nReviewed-by: Mike Rapoport <rppt@linux.ibm.com>\nReviewed-by: Oleg Nesterov <oleg@redhat.com>\nReviewed-by: Jann Horn <jannh@google.com>\nAcked-by: Jason Gunthorpe <jgg@mellanox.com>\nAcked-by: Michal Hocko <mhocko@suse.com>\nCc: <stable@vger.kernel.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
    "before_after_code_files": [
      "drivers/infiniband/core/uverbs_main.c||drivers/infiniband/core/uverbs_main.c",
      "fs/proc/task_mmu.c||fs/proc/task_mmu.c",
      "fs/userfaultfd.c||fs/userfaultfd.c",
      "include/linux/sched/mm.h||include/linux/sched/mm.h",
      "mm/mmap.c||mm/mmap.c"
    ]
  },
  "patch_diff": {
    "drivers/infiniband/core/uverbs_main.c||drivers/infiniband/core/uverbs_main.c": [
      "File: drivers/infiniband/core/uverbs_main.c -> drivers/infiniband/core/uverbs_main.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "995:   down_write(&mm->mmap_sem);",
      "996:   mutex_lock(&ufile->umap_lock);",
      "997:   list_for_each_entry_safe (priv, next_priv, &ufile->umaps,",
      "998:        list) {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "996:   if (!mmget_still_valid(mm))",
      "997:    goto skip_mm;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1007:    vma->vm_flags &= ~(VM_SHARED | VM_MAYSHARE);",
      "1008:   }",
      "1009:   mutex_unlock(&ufile->umap_lock);",
      "1010:   up_write(&mm->mmap_sem);",
      "1011:   mmput(mm);",
      "1012:  }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1012:  skip_mm:",
      "",
      "---------------"
    ],
    "fs/proc/task_mmu.c||fs/proc/task_mmu.c": [
      "File: fs/proc/task_mmu.c -> fs/proc/task_mmu.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1143:      count = -EINTR;",
      "1144:      goto out_mm;",
      "1145:     }",
      "1146:     for (vma = mm->mmap; vma; vma = vma->vm_next) {",
      "1147:      vma->vm_flags &= ~VM_SOFTDIRTY;",
      "1148:      vma_set_page_prot(vma);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1151:     if (!mmget_still_valid(mm)) {",
      "1161:      up_write(&mm->mmap_sem);",
      "1162:      goto out_mm;",
      "1163:     }",
      "",
      "---------------"
    ],
    "fs/userfaultfd.c||fs/userfaultfd.c": [
      "File: fs/userfaultfd.c -> fs/userfaultfd.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "631:   down_write(&mm->mmap_sem);",
      "632:   for (vma = mm->mmap; vma; vma = vma->vm_next)",
      "633:    if (vma->vm_userfaultfd_ctx.ctx == release_new_ctx) {",
      "634:     vma->vm_userfaultfd_ctx = NULL_VM_UFFD_CTX;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "633:   VM_WARN_ON(!mmget_still_valid(mm));",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "885:  down_write(&mm->mmap_sem);",
      "886:  prev = NULL;",
      "887:  for (vma = mm->mmap; vma; vma = vma->vm_next) {",
      "888:   cond_resched();",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "888:  if (!mmget_still_valid(mm))",
      "889:   goto skip_mm;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "905:   vma->vm_flags = new_flags;",
      "906:   vma->vm_userfaultfd_ctx = NULL_VM_UFFD_CTX;",
      "907:  }",
      "908:  up_write(&mm->mmap_sem);",
      "909:  mmput(mm);",
      "910: wakeup:",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "912: skip_mm:",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "1333:   goto out;",
      "1335:  down_write(&mm->mmap_sem);",
      "1336:  vma = find_vma_prev(mm, start, &prev);",
      "1337:  if (!vma)",
      "1338:   goto out_unlock;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1341:  if (!mmget_still_valid(mm))",
      "1342:   goto out_unlock;",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "1520:   goto out;",
      "1522:  down_write(&mm->mmap_sem);",
      "1523:  vma = find_vma_prev(mm, start, &prev);",
      "1524:  if (!vma)",
      "1525:   goto out_unlock;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1530:  if (!mmget_still_valid(mm))",
      "1531:   goto out_unlock;",
      "",
      "---------------"
    ],
    "include/linux/sched/mm.h||include/linux/sched/mm.h": [
      "File: include/linux/sched/mm.h -> include/linux/sched/mm.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "49:   __mmdrop(mm);",
      "50: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "68: static inline bool mmget_still_valid(struct mm_struct *mm)",
      "69: {",
      "70:  return likely(!mm->core_state);",
      "71: }",
      "",
      "---------------"
    ],
    "mm/mmap.c||mm/mmap.c": [
      "File: mm/mmap.c -> mm/mmap.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "45: #include <linux/moduleparam.h>",
      "46: #include <linux/pkeys.h>",
      "47: #include <linux/oom.h>",
      "49: #include <linux/uaccess.h>",
      "50: #include <asm/cacheflush.h>",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "48: #include <linux/sched/mm.h>",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "2525:  vma = find_vma_prev(mm, addr, &prev);",
      "2526:  if (vma && (vma->vm_start <= addr))",
      "2527:   return vma;",
      "2529:   return NULL;",
      "2530:  if (prev->vm_flags & VM_LOCKED)",
      "2531:   populate_vma_page_range(prev, addr, prev->vm_end, NULL);",
      "",
      "[Removed Lines]",
      "2528:  if (!prev || expand_stack(prev, addr))",
      "",
      "[Added Lines]",
      "2530:  if (!prev || !mmget_still_valid(mm) || expand_stack(prev, addr))",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "2551:   return vma;",
      "2552:  if (!(vma->vm_flags & VM_GROWSDOWN))",
      "2553:   return NULL;",
      "2554:  start = vma->vm_start;",
      "2555:  if (expand_stack(vma, addr))",
      "2556:   return NULL;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2557:  if (!mmget_still_valid(mm))",
      "2558:   return NULL;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "46d0b24c5ee10a15dfb25e20642f5a5ed59c5003",
      "candidate_info": {
        "commit_hash": "46d0b24c5ee10a15dfb25e20642f5a5ed59c5003",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/46d0b24c5ee10a15dfb25e20642f5a5ed59c5003",
        "files": [
          "fs/userfaultfd.c"
        ],
        "message": "userfaultfd_release: always remove uffd flags and clear vm_userfaultfd_ctx\n\nuserfaultfd_release() should clear vm_flags/vm_userfaultfd_ctx even if\nmm->core_state != NULL.\n\nOtherwise a page fault can see userfaultfd_missing() == T and use an\nalready freed userfaultfd_ctx.\n\nLink: http://lkml.kernel.org/r/20190820160237.GB4983@redhat.com\nFixes: 04f5866e41fb (\"coredump: fix race condition between mmget_not_zero()/get_task_mm() and core dumping\")\nSigned-off-by: Oleg Nesterov <oleg@redhat.com>\nReported-by: Kefeng Wang <wangkefeng.wang@huawei.com>\nReviewed-by: Andrea Arcangeli <aarcange@redhat.com>\nTested-by: Kefeng Wang <wangkefeng.wang@huawei.com>\nCc: Peter Xu <peterx@redhat.com>\nCc: Mike Rapoport <rppt@linux.ibm.com>\nCc: Jann Horn <jannh@google.com>\nCc: Jason Gunthorpe <jgg@mellanox.com>\nCc: Michal Hocko <mhocko@suse.com>\nCc: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>\nCc: <stable@vger.kernel.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "fs/userfaultfd.c||fs/userfaultfd.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/userfaultfd.c||fs/userfaultfd.c"
          ],
          "candidate": [
            "fs/userfaultfd.c||fs/userfaultfd.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/userfaultfd.c||fs/userfaultfd.c": [
          "File: fs/userfaultfd.c -> fs/userfaultfd.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "881:  struct userfaultfd_wake_range range = { .len = 0, };",
          "882:  unsigned long new_flags;",
          "884:  WRITE_ONCE(ctx->released, true);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "883:  bool still_valid;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "897:  down_write(&mm->mmap_sem);",
          "900:  prev = NULL;",
          "901:  for (vma = mm->mmap; vma; vma = vma->vm_next) {",
          "902:   cond_resched();",
          "",
          "[Removed Lines]",
          "898:  if (!mmget_still_valid(mm))",
          "899:   goto skip_mm;",
          "",
          "[Added Lines]",
          "899:  still_valid = mmget_still_valid(mm);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "907:    continue;",
          "908:   }",
          "909:   new_flags = vma->vm_flags & ~(VM_UFFD_MISSING | VM_UFFD_WP);",
          "919:   vma->vm_flags = new_flags;",
          "920:   vma->vm_userfaultfd_ctx = NULL_VM_UFFD_CTX;",
          "921:  }",
          "923:  up_write(&mm->mmap_sem);",
          "924:  mmput(mm);",
          "925: wakeup:",
          "",
          "[Removed Lines]",
          "910:   prev = vma_merge(mm, prev, vma->vm_start, vma->vm_end,",
          "911:      new_flags, vma->anon_vma,",
          "912:      vma->vm_file, vma->vm_pgoff,",
          "913:      vma_policy(vma),",
          "914:      NULL_VM_UFFD_CTX);",
          "915:   if (prev)",
          "916:    vma = prev;",
          "917:   else",
          "918:    prev = vma;",
          "922: skip_mm:",
          "",
          "[Added Lines]",
          "910:   if (still_valid) {",
          "911:    prev = vma_merge(mm, prev, vma->vm_start, vma->vm_end,",
          "912:       new_flags, vma->anon_vma,",
          "913:       vma->vm_file, vma->vm_pgoff,",
          "914:       vma_policy(vma),",
          "915:       NULL_VM_UFFD_CTX);",
          "916:    if (prev)",
          "917:     vma = prev;",
          "918:    else",
          "919:     prev = vma;",
          "920:   }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
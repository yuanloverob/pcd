{
  "cve_id": "CVE-2019-17113",
  "cve_desc": "In libopenmpt before 0.3.19 and 0.4.x before 0.4.9, ModPlug_InstrumentName and ModPlug_SampleName in libopenmpt_modplug.c do not restrict the lengths of libmodplug output-buffer strings in the C API, leading to a buffer overflow.",
  "repo": "OpenMPT/openmpt",
  "patch_hash": "927688ddab43c2b203569de79407a899e734fabe",
  "patch_info": {
    "commit_hash": "927688ddab43c2b203569de79407a899e734fabe",
    "repo": "OpenMPT/openmpt",
    "commit_url": "https://github.com/OpenMPT/openmpt/commit/927688ddab43c2b203569de79407a899e734fabe",
    "files": [
      "libopenmpt/libopenmpt_modplug.c"
    ],
    "message": "[Fix] libmodplug: C API: Limit the length of strings copied to the output buffer of ModPlug_InstrumentName() and ModPlug_SampleName() to 32 bytes (including terminating null) as is done by original libmodplug. This avoids potential buffer overflows in software relying on this limit instead of querying the required buffer size beforehand. libopenmpt can return strings longer than 32 bytes here beacuse the internal limit of 32 bytes applies to strings encoded in arbitrary character encodings but the API returns them converted to UTF-8, which can be longer. (reported by Antonio Morales Maldonado of Semmle Security Research Team)\n\ngit-svn-id: https://source.openmpt.org/svn/openmpt/trunk/OpenMPT@12127 56274372-70c3-4bfc-bfc3-4c3a0b034d27",
    "before_after_code_files": [
      "libopenmpt/libopenmpt_modplug.c||libopenmpt/libopenmpt_modplug.c"
    ]
  },
  "patch_diff": {
    "libopenmpt/libopenmpt_modplug.c||libopenmpt/libopenmpt_modplug.c": [
      "File: libopenmpt/libopenmpt_modplug.c -> libopenmpt/libopenmpt_modplug.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "478: LIBOPENMPT_MODPLUG_API unsigned int ModPlug_SampleName(ModPlugFile* file, unsigned int qual, char* buff)",
      "479: {",
      "480:  const char* str;",
      "483:  if(!file) return 0;",
      "484:  str = openmpt_module_get_sample_name(file->mod,qual-1);",
      "494:  }",
      "496:  if(buff){",
      "499:  }",
      "502: }",
      "504: LIBOPENMPT_MODPLUG_API unsigned int ModPlug_InstrumentName(ModPlugFile* file, unsigned int qual, char* buff)",
      "505: {",
      "506:  const char* str;",
      "509:  if(!file) return 0;",
      "510:  str = openmpt_module_get_instrument_name(file->mod,qual-1);",
      "520:  }",
      "522:  if(buff){",
      "525:  }",
      "528: }",
      "530: LIBOPENMPT_MODPLUG_API ModPlugNote* ModPlug_GetPattern(ModPlugFile* file, int pattern, unsigned int* numrows)",
      "",
      "[Removed Lines]",
      "481:  unsigned int retval;",
      "482:  size_t tmpretval;",
      "485:  if(!str){",
      "486:   if(buff){",
      "488:   }",
      "489:   return 0;",
      "490:  }",
      "491:  tmpretval = strlen(str);",
      "492:  if(tmpretval>=INT_MAX){",
      "493:   tmpretval = INT_MAX-1;",
      "495:  retval = (int)tmpretval;",
      "497:   memcpy(buff,str,retval+1);",
      "498:   buff[retval] = '\\0';",
      "500:  openmpt_free_string(str);",
      "501:  return retval;",
      "507:  unsigned int retval;",
      "508:  size_t tmpretval;",
      "511:  if(!str){",
      "512:   if(buff){",
      "514:   }",
      "515:   return 0;",
      "516:  }",
      "517:  tmpretval = strlen(str);",
      "518:  if(tmpretval>=INT_MAX){",
      "519:   tmpretval = INT_MAX-1;",
      "521:  retval = (int)tmpretval;",
      "523:   memcpy(buff,str,retval+1);",
      "524:   buff[retval] = '\\0';",
      "526:  openmpt_free_string(str);",
      "527:  return retval;",
      "",
      "[Added Lines]",
      "481:  char buf[32];",
      "484:  memset(buf,0,32);",
      "485:  if(str){",
      "486:   strncpy(buf,str,31);",
      "487:   openmpt_free_string(str);",
      "490:   strncpy(buff,buf,32);",
      "492:  return (unsigned int)strlen(buf);",
      "498:  char buf[32];",
      "501:  memset(buf,0,32);",
      "502:  if(str){",
      "503:   strncpy(buf,str,31);",
      "504:   openmpt_free_string(str);",
      "507:   strncpy(buff,buf,32);",
      "509:  return (unsigned int)strlen(buf);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "56c7fb2ab127ad0d14ba43e2839ea93cb2ab61dc",
      "candidate_info": {
        "commit_hash": "56c7fb2ab127ad0d14ba43e2839ea93cb2ab61dc",
        "repo": "OpenMPT/openmpt",
        "commit_url": "https://github.com/OpenMPT/openmpt/commit/56c7fb2ab127ad0d14ba43e2839ea93cb2ab61dc",
        "files": [
          "libopenmpt/libopenmpt_modplug.c"
        ],
        "message": "Merged revision(s) 12127 from trunk/OpenMPT: [Fix] libmodplug: C API: Limit the length of strings copied to the output buffer of ModPlug_InstrumentName() and ModPlug_SampleName() to 32 bytes (including terminating null) as is done by original libmodplug. This avoids potential buffer overflows in software relying on this limit instead of querying the required buffer size beforehand. libopenmpt can return strings longer than 32 bytes here beacuse the internal limit of 32 bytes applies to strings encoded in arbitrary character encodings but the API returns them converted to UTF-8, which can be longer. (reported by Antonio Morales Maldonado of Semmle Security Research Team) ........\n\ngit-svn-id: https://source.openmpt.org/svn/openmpt/branches/OpenMPT-1.27@12131 56274372-70c3-4bfc-bfc3-4c3a0b034d27",
        "before_after_code_files": [
          "libopenmpt/libopenmpt_modplug.c||libopenmpt/libopenmpt_modplug.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_olp_changes": 1,
        "olp_code_files": {
          "patch": [
            "libopenmpt/libopenmpt_modplug.c||libopenmpt/libopenmpt_modplug.c"
          ],
          "candidate": [
            "libopenmpt/libopenmpt_modplug.c||libopenmpt/libopenmpt_modplug.c"
          ]
        }
      },
      "candidate_diff": {
        "libopenmpt/libopenmpt_modplug.c||libopenmpt/libopenmpt_modplug.c": [
          "File: libopenmpt/libopenmpt_modplug.c -> libopenmpt/libopenmpt_modplug.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "481: LIBOPENMPT_MODPLUG_API unsigned int ModPlug_SampleName(ModPlugFile* file, unsigned int qual, char* buff)",
          "482: {",
          "483:  const char* str;",
          "486:  if(!file) return 0;",
          "487:  str = openmpt_module_get_sample_name(file->mod,qual-1);",
          "497:  }",
          "499:  if(buff){",
          "502:  }",
          "505: }",
          "507: LIBOPENMPT_MODPLUG_API unsigned int ModPlug_InstrumentName(ModPlugFile* file, unsigned int qual, char* buff)",
          "508: {",
          "509:  const char* str;",
          "512:  if(!file) return 0;",
          "513:  str = openmpt_module_get_instrument_name(file->mod,qual-1);",
          "523:  }",
          "525:  if(buff){",
          "528:  }",
          "531: }",
          "533: LIBOPENMPT_MODPLUG_API ModPlugNote* ModPlug_GetPattern(ModPlugFile* file, int pattern, unsigned int* numrows)",
          "",
          "[Removed Lines]",
          "484:  unsigned int retval;",
          "485:  size_t tmpretval;",
          "488:  if(!str){",
          "489:   if(buff){",
          "491:   }",
          "492:   return 0;",
          "493:  }",
          "494:  tmpretval = strlen(str);",
          "495:  if(tmpretval>=INT_MAX){",
          "496:   tmpretval = INT_MAX-1;",
          "498:  retval = (int)tmpretval;",
          "500:   memcpy(buff,str,retval+1);",
          "501:   buff[retval] = '\\0';",
          "503:  openmpt_free_string(str);",
          "504:  return retval;",
          "510:  unsigned int retval;",
          "511:  size_t tmpretval;",
          "514:  if(!str){",
          "515:   if(buff){",
          "517:   }",
          "518:   return 0;",
          "519:  }",
          "520:  tmpretval = strlen(str);",
          "521:  if(tmpretval>=INT_MAX){",
          "522:   tmpretval = INT_MAX-1;",
          "524:  retval = (int)tmpretval;",
          "526:   memcpy(buff,str,retval+1);",
          "527:   buff[retval] = '\\0';",
          "529:  openmpt_free_string(str);",
          "530:  return retval;",
          "",
          "[Added Lines]",
          "484:  char buf[32];",
          "487:  memset(buf,0,32);",
          "488:  if(str){",
          "489:   strncpy(buf,str,31);",
          "490:   openmpt_free_string(str);",
          "493:   strncpy(buff,buf,32);",
          "495:  return (unsigned int)strlen(buf);",
          "501:  char buf[32];",
          "504:  memset(buf,0,32);",
          "505:  if(str){",
          "506:   strncpy(buf,str,31);",
          "507:   openmpt_free_string(str);",
          "510:   strncpy(buff,buf,32);",
          "512:  return (unsigned int)strlen(buf);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "3a5fc13295a9861c867111535742772d0954e3d3",
      "candidate_info": {
        "commit_hash": "3a5fc13295a9861c867111535742772d0954e3d3",
        "repo": "OpenMPT/openmpt",
        "commit_url": "https://github.com/OpenMPT/openmpt/commit/3a5fc13295a9861c867111535742772d0954e3d3",
        "files": [
          "libopenmpt/libopenmpt_modplug.c"
        ],
        "message": "Merged revision(s) 12127 from trunk/OpenMPT: [Fix] libmodplug: C API: Limit the length of strings copied to the output buffer of ModPlug_InstrumentName() and ModPlug_SampleName() to 32 bytes (including terminating null) as is done by original libmodplug. This avoids potential buffer overflows in software relying on this limit instead of querying the required buffer size beforehand. libopenmpt can return strings longer than 32 bytes here beacuse the internal limit of 32 bytes applies to strings encoded in arbitrary character encodings but the API returns them converted to UTF-8, which can be longer. (reported by Antonio Morales Maldonado of Semmle Security Research Team) ........\n\ngit-svn-id: https://source.openmpt.org/svn/openmpt/branches/OpenMPT-1.28@12129 56274372-70c3-4bfc-bfc3-4c3a0b034d27",
        "before_after_code_files": [
          "libopenmpt/libopenmpt_modplug.c||libopenmpt/libopenmpt_modplug.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_olp_changes": 1,
        "olp_code_files": {
          "patch": [
            "libopenmpt/libopenmpt_modplug.c||libopenmpt/libopenmpt_modplug.c"
          ],
          "candidate": [
            "libopenmpt/libopenmpt_modplug.c||libopenmpt/libopenmpt_modplug.c"
          ]
        }
      },
      "candidate_diff": {
        "libopenmpt/libopenmpt_modplug.c||libopenmpt/libopenmpt_modplug.c": [
          "File: libopenmpt/libopenmpt_modplug.c -> libopenmpt/libopenmpt_modplug.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "478: LIBOPENMPT_MODPLUG_API unsigned int ModPlug_SampleName(ModPlugFile* file, unsigned int qual, char* buff)",
          "479: {",
          "480:  const char* str;",
          "483:  if(!file) return 0;",
          "484:  str = openmpt_module_get_sample_name(file->mod,qual-1);",
          "494:  }",
          "496:  if(buff){",
          "499:  }",
          "502: }",
          "504: LIBOPENMPT_MODPLUG_API unsigned int ModPlug_InstrumentName(ModPlugFile* file, unsigned int qual, char* buff)",
          "505: {",
          "506:  const char* str;",
          "509:  if(!file) return 0;",
          "510:  str = openmpt_module_get_instrument_name(file->mod,qual-1);",
          "520:  }",
          "522:  if(buff){",
          "525:  }",
          "528: }",
          "530: LIBOPENMPT_MODPLUG_API ModPlugNote* ModPlug_GetPattern(ModPlugFile* file, int pattern, unsigned int* numrows)",
          "",
          "[Removed Lines]",
          "481:  unsigned int retval;",
          "482:  size_t tmpretval;",
          "485:  if(!str){",
          "486:   if(buff){",
          "488:   }",
          "489:   return 0;",
          "490:  }",
          "491:  tmpretval = strlen(str);",
          "492:  if(tmpretval>=INT_MAX){",
          "493:   tmpretval = INT_MAX-1;",
          "495:  retval = (int)tmpretval;",
          "497:   memcpy(buff,str,retval+1);",
          "498:   buff[retval] = '\\0';",
          "500:  openmpt_free_string(str);",
          "501:  return retval;",
          "507:  unsigned int retval;",
          "508:  size_t tmpretval;",
          "511:  if(!str){",
          "512:   if(buff){",
          "514:   }",
          "515:   return 0;",
          "516:  }",
          "517:  tmpretval = strlen(str);",
          "518:  if(tmpretval>=INT_MAX){",
          "519:   tmpretval = INT_MAX-1;",
          "521:  retval = (int)tmpretval;",
          "523:   memcpy(buff,str,retval+1);",
          "524:   buff[retval] = '\\0';",
          "526:  openmpt_free_string(str);",
          "527:  return retval;",
          "",
          "[Added Lines]",
          "481:  char buf[32];",
          "484:  memset(buf,0,32);",
          "485:  if(str){",
          "486:   strncpy(buf,str,31);",
          "487:   openmpt_free_string(str);",
          "490:   strncpy(buff,buf,32);",
          "492:  return (unsigned int)strlen(buf);",
          "498:  char buf[32];",
          "501:  memset(buf,0,32);",
          "502:  if(str){",
          "503:   strncpy(buf,str,31);",
          "504:   openmpt_free_string(str);",
          "507:   strncpy(buff,buf,32);",
          "509:  return (unsigned int)strlen(buf);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2007-6761",
  "cve_desc": "drivers/media/video/videobuf-vmalloc.c in the Linux kernel before 2.6.24 does not initialize videobuf_mapping data structures, which allows local users to trigger an incorrect count value and videobuf leak via unspecified vectors, a different vulnerability than CVE-2010-5321.",
  "repo": "torvalds/linux",
  "patch_hash": "0b29669c065f60501e7289e1950fa2a618962358",
  "patch_info": {
    "commit_hash": "0b29669c065f60501e7289e1950fa2a618962358",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/0b29669c065f60501e7289e1950fa2a618962358",
    "files": [
      "drivers/media/video/videobuf-vmalloc.c"
    ],
    "message": "V4L/DVB (6751): V4L: Memory leak!  Fix count in videobuf-vmalloc mmap\n\nThis is pretty serious bug.  map->count is never initialized after the\ncall to kmalloc making the count start at some random trash value.  The\nend result is leaking videobufs.\n\nAlso, fix up the debug statements to print unsigned values.\n\nPushed to http://ifup.org/hg/v4l-dvb too\n\nSigned-off-by: Brandon Philips <bphilips@suse.de>\nSigned-off-by: Mauro Carvalho Chehab <mchehab@infradead.org>",
    "before_after_code_files": [
      "drivers/media/video/videobuf-vmalloc.c||drivers/media/video/videobuf-vmalloc.c"
    ]
  },
  "patch_diff": {
    "drivers/media/video/videobuf-vmalloc.c||drivers/media/video/videobuf-vmalloc.c": [
      "File: drivers/media/video/videobuf-vmalloc.c -> drivers/media/video/videobuf-vmalloc.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "51: {",
      "52:  struct videobuf_mapping *map = vma->vm_private_data;",
      "55:   map->count,vma->vm_start,vma->vm_end);",
      "57:  map->count++;",
      "",
      "[Removed Lines]",
      "54:  dprintk(2,\"vm_open %p [count=%d,vma=%08lx-%08lx]\\n\",map,",
      "",
      "[Added Lines]",
      "54:  dprintk(2,\"vm_open %p [count=%u,vma=%08lx-%08lx]\\n\",map,",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "64:  struct videobuf_queue *q = map->q;",
      "65:  int i;",
      "68:   map->count,vma->vm_start,vma->vm_end);",
      "70:  map->count--;",
      "",
      "[Removed Lines]",
      "67:  dprintk(2,\"vm_close %p [count=%d,vma=%08lx-%08lx]\\n\",map,",
      "",
      "[Added Lines]",
      "67:  dprintk(2,\"vm_close %p [count=%u,vma=%08lx-%08lx]\\n\",map,",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "221:  }",
      "225:  if (NULL == map)",
      "226:   return -ENOMEM;",
      "",
      "[Removed Lines]",
      "224:  map = q->bufs[first]->map = kmalloc(sizeof(struct videobuf_mapping),GFP_KERNEL);",
      "",
      "[Added Lines]",
      "224:  map = q->bufs[first]->map = kzalloc(sizeof(struct videobuf_mapping),GFP_KERNEL);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "87b9ad070cf76c0f1e8cf836f7eb86e9ac94e34a",
      "candidate_info": {
        "commit_hash": "87b9ad070cf76c0f1e8cf836f7eb86e9ac94e34a",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/87b9ad070cf76c0f1e8cf836f7eb86e9ac94e34a",
        "files": [
          "drivers/media/Kconfig",
          "drivers/media/video/Kconfig",
          "drivers/media/video/Makefile",
          "drivers/media/video/videobuf-vmalloc.c",
          "include/media/videobuf-vmalloc.h"
        ],
        "message": "V4L/DVB (6254): Add videobuf-vmalloc\n\nAdds a newer videobuf-vmalloc module. This module uses the same\nvideobuf controls, but implements memory allocation based on vmalloc\nmethods.\n\nWith this method, an USB driver can use video-buf, without needing to\nrequest memory from the DMA-safe area.\n\nSigned-off-by: Mauro Carvalho Chehab <mchehab@infradead.org>",
        "before_after_code_files": [
          "drivers/media/video/videobuf-vmalloc.c||drivers/media/video/videobuf-vmalloc.c",
          "include/media/videobuf-vmalloc.h||include/media/videobuf-vmalloc.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "drivers/media/video/videobuf-vmalloc.c||drivers/media/video/videobuf-vmalloc.c"
          ],
          "candidate": [
            "drivers/media/video/videobuf-vmalloc.c||drivers/media/video/videobuf-vmalloc.c"
          ]
        }
      },
      "candidate_diff": {
        "drivers/media/video/videobuf-vmalloc.c||drivers/media/video/videobuf-vmalloc.c": [
          "File: drivers/media/video/videobuf-vmalloc.c -> drivers/media/video/videobuf-vmalloc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "16: #include <linux/init.h>",
          "17: #include <linux/module.h>",
          "18: #include <linux/moduleparam.h>",
          "19: #include <linux/slab.h>",
          "20: #include <linux/interrupt.h>",
          "22: #include <linux/pci.h>",
          "23: #include <linux/vmalloc.h>",
          "24: #include <linux/pagemap.h>",
          "25: #include <asm/page.h>",
          "26: #include <asm/pgtable.h>",
          "28: #include <media/videobuf-vmalloc.h>",
          "30: #define MAGIC_DMABUF   0x17760309",
          "31: #define MAGIC_VMAL_MEM 0x18221223",
          "33: #define MAGIC_CHECK(is,should) if (unlikely((is) != (should))) \\",
          "34:  { printk(KERN_ERR \"magic mismatch: %x (expected %x)\\n\",is,should); BUG(); }",
          "36: static int debug = 0;",
          "37: module_param(debug, int, 0644);",
          "39: MODULE_DESCRIPTION(\"helper module to manage video4linux vmalloc buffers\");",
          "40: MODULE_AUTHOR(\"Mauro Carvalho Chehab <mchehab@infradead.org>\");",
          "41: MODULE_LICENSE(\"GPL\");",
          "43: #define dprintk(level, fmt, arg...) if (debug >= level) \\",
          "44:  printk(KERN_DEBUG \"vbuf-sg: \" fmt , ## arg)",
          "49: static void",
          "50: videobuf_vm_open(struct vm_area_struct *vma)",
          "51: {",
          "52:  struct videobuf_mapping *map = vma->vm_private_data;",
          "54:  dprintk(2,\"vm_open %p [count=%d,vma=%08lx-%08lx]\\n\",map,",
          "55:   map->count,vma->vm_start,vma->vm_end);",
          "57:  map->count++;",
          "58: }",
          "60: static void",
          "61: videobuf_vm_close(struct vm_area_struct *vma)",
          "62: {",
          "63:  struct videobuf_mapping *map = vma->vm_private_data;",
          "64:  struct videobuf_queue *q = map->q;",
          "65:  struct videbuf_vmalloc_memory *mem;",
          "66:  int i;",
          "68:  dprintk(2,\"vm_close %p [count=%d,vma=%08lx-%08lx]\\n\",map,",
          "69:   map->count,vma->vm_start,vma->vm_end);",
          "71:  map->count--;",
          "72:  if (0 == map->count) {",
          "73:   dprintk(1,\"munmap %p q=%p\\n\",map,q);",
          "74:   mutex_lock(&q->lock);",
          "75:   for (i = 0; i < VIDEO_MAX_FRAME; i++) {",
          "76:    if (NULL == q->bufs[i])",
          "77:     continue;",
          "78:    mem=q->bufs[i]->priv;",
          "80:    if (!mem)",
          "81:     continue;",
          "83:    MAGIC_CHECK(mem->magic,MAGIC_VMAL_MEM);",
          "85:    if (mem->map != map)",
          "86:     continue;",
          "87:    mem->map   = NULL;",
          "88:    q->bufs[i]->baddr = 0;",
          "89:    q->ops->buf_release(q,q->bufs[i]);",
          "90:   }",
          "91:   mutex_unlock(&q->lock);",
          "92:   kfree(map);",
          "93:  }",
          "94:  return;",
          "95: }",
          "97: static struct vm_operations_struct videobuf_vm_ops =",
          "98: {",
          "99:  .open     = videobuf_vm_open,",
          "100:  .close    = videobuf_vm_close,",
          "101: };",
          "108:  struct video_buffer",
          "109:  struct <driver>_buffer (cx88_buffer, saa7134_buf, ...)",
          "110:  struct videobuf_pci_sg_memory",
          "113: static void *__videobuf_alloc(size_t size)",
          "114: {",
          "115:  struct videbuf_vmalloc_memory *mem;",
          "116:  struct videobuf_buffer *vb;",
          "118:  vb = kzalloc(size+sizeof(*mem),GFP_KERNEL);",
          "120:  mem = vb->priv = ((char *)vb)+size;",
          "121:  mem->magic=MAGIC_VMAL_MEM;",
          "123:  dprintk(1,\"%s: allocated at %p(%ld+%ld) & %p(%ld)\\n\",",
          "124:   __FUNCTION__,vb,(long)sizeof(*vb),(long)size-sizeof(*vb),",
          "125:   mem,(long)sizeof(*mem));",
          "127:  return vb;",
          "128: }",
          "130: static int __videobuf_iolock (struct videobuf_queue* q,",
          "131:          struct videobuf_buffer *vb,",
          "132:          struct v4l2_framebuffer *fbuf)",
          "133: {",
          "134:  int pages;",
          "136:  struct videbuf_vmalloc_memory *mem=vb->priv;",
          "139:  BUG_ON(!mem);",
          "141:  MAGIC_CHECK(mem->magic,MAGIC_VMAL_MEM);",
          "144:  pages = PAGE_ALIGN(vb->size) >> PAGE_SHIFT;",
          "147:  if ((vb->memory != V4L2_MEMORY_MMAP) &&",
          "148:     (vb->memory != V4L2_MEMORY_USERPTR) ) {",
          "149:   printk(KERN_ERR \"Method currently unsupported.\\n\");",
          "150:   return -EINVAL;",
          "151:  }",
          "154:  mem->vmalloc=vmalloc_user (PAGE_ALIGN(vb->size));",
          "155:  if (NULL == mem->vmalloc) {",
          "156:   dprintk(1,\"vmalloc (%d pages) failed\\n\",pages);",
          "157:   return -ENOMEM;",
          "158:  }",
          "160:  dprintk(1,\"vmalloc is at addr 0x%08lx, size=%d\\n\",",
          "161:     (unsigned long)mem->vmalloc,",
          "162:     pages << PAGE_SHIFT);",
          "165:     the mmap() call",
          "167:  if (mem->vma) {",
          "168:   int retval=remap_vmalloc_range(mem->vma, mem->vmalloc,0);",
          "169:   kfree(mem->vma);",
          "170:   mem->vma=NULL;",
          "171:   if (retval<0) {",
          "172:    dprintk(1,\"mmap app bug: remap_vmalloc_range area %p error %d\\n\",",
          "173:     mem->vmalloc,retval);",
          "174:    return retval;",
          "175:   }",
          "176:  }",
          "178:  return 0;",
          "179: }",
          "181: static int __videobuf_sync(struct videobuf_queue *q,",
          "182:       struct videobuf_buffer *buf)",
          "183: {",
          "184:  return 0;",
          "185: }",
          "187: static int __videobuf_mmap_free(struct videobuf_queue *q)",
          "188: {",
          "189:  unsigned int i;",
          "191:  for (i = 0; i < VIDEO_MAX_FRAME; i++) {",
          "192:   if (q->bufs[i]) {",
          "193:    struct videbuf_vmalloc_memory *mem=q->bufs[i]->priv;",
          "194:    if (mem && mem->map)",
          "195:     return -EBUSY;",
          "196:   }",
          "197:  }",
          "199:  return 0;",
          "200: }",
          "202: static int __videobuf_mmap_mapper(struct videobuf_queue *q,",
          "203:     struct vm_area_struct *vma)",
          "204: {",
          "205:  struct videbuf_vmalloc_memory *mem;",
          "206:  struct videobuf_mapping *map;",
          "207:  unsigned int first;",
          "208:  int retval;",
          "209:  unsigned long offset = vma->vm_pgoff << PAGE_SHIFT;",
          "211:  if (! (vma->vm_flags & VM_WRITE) || ! (vma->vm_flags & VM_SHARED))",
          "212:   return -EINVAL;",
          "215:  for (first = 0; first < VIDEO_MAX_FRAME; first++) {",
          "216:   if (NULL == q->bufs[first])",
          "217:    continue;",
          "219:   if (V4L2_MEMORY_MMAP != q->bufs[first]->memory)",
          "220:    continue;",
          "221:   if (q->bufs[first]->boff == offset)",
          "222:    break;",
          "223:  }",
          "224:  if (VIDEO_MAX_FRAME == first) {",
          "225:   dprintk(1,\"mmap app bug: offset invalid [offset=0x%lx]\\n\",",
          "226:    (vma->vm_pgoff << PAGE_SHIFT));",
          "227:   return -EINVAL;",
          "228:  }",
          "229:  mem=q->bufs[first]->priv;",
          "230:  BUG_ON (!mem);",
          "231:  MAGIC_CHECK(mem->magic,MAGIC_VMAL_MEM);",
          "234:  map = mem->map = kmalloc(sizeof(struct videobuf_mapping),GFP_KERNEL);",
          "235:  if (NULL == map)",
          "236:   return -ENOMEM;",
          "238:  map->start = vma->vm_start;",
          "239:  map->end   = vma->vm_end;",
          "240:  map->q     = q;",
          "242:  q->bufs[first]->baddr = vma->vm_start;",
          "244:  vma->vm_ops          = &videobuf_vm_ops;",
          "245:  vma->vm_flags       |= VM_DONTEXPAND | VM_RESERVED;",
          "246:  vma->vm_private_data = map;",
          "249:  retval=remap_vmalloc_range(vma, mem->vmalloc,0);",
          "250:  if (retval<0) {",
          "251:   dprintk(1,\"mmap: postponing remap_vmalloc_range\\n\");",
          "252:   mem->vma=kmalloc(sizeof(*vma),GFP_KERNEL);",
          "253:   if (!mem->vma) {",
          "254:    kfree(map);",
          "255:    mem->map=NULL;",
          "256:    return -ENOMEM;",
          "257:   }",
          "258:   memcpy(mem->vma,vma,sizeof(*vma));",
          "259:  }",
          "261:  dprintk(1,\"mmap %p: q=%p %08lx-%08lx (%lx) pgoff %08lx buf %d\\n\",",
          "262:   map,q,vma->vm_start,vma->vm_end,",
          "263:   (long int) q->bufs[first]->bsize,",
          "264:   vma->vm_pgoff,first);",
          "266:  videobuf_vm_open(vma);",
          "268:  return (0);",
          "269: }",
          "271: static int __videobuf_is_mmapped (struct videobuf_buffer *buf)",
          "272: {",
          "273:  struct videbuf_vmalloc_memory *mem=buf->priv;",
          "274:  BUG_ON (!mem);",
          "275:  MAGIC_CHECK(mem->magic,MAGIC_VMAL_MEM);",
          "277:  return (mem->map)?1:0;",
          "278: }",
          "280: static int __videobuf_copy_to_user ( struct videobuf_queue *q,",
          "281:     char __user *data, size_t count,",
          "282:     int nonblocking )",
          "283: {",
          "284:  struct videbuf_vmalloc_memory *mem=q->read_buf->priv;",
          "285:  BUG_ON (!mem);",
          "286:  MAGIC_CHECK(mem->magic,MAGIC_VMAL_MEM);",
          "288:  BUG_ON (!mem->vmalloc);",
          "291:  if (count > q->read_buf->size - q->read_off)",
          "292:   count = q->read_buf->size - q->read_off;",
          "294:  if (copy_to_user(data, mem->vmalloc+q->read_off, count))",
          "295:   return -EFAULT;",
          "297:  return count;",
          "298: }",
          "300: static int __videobuf_copy_stream ( struct videobuf_queue *q,",
          "301:     char __user *data, size_t count, size_t pos,",
          "302:     int vbihack, int nonblocking )",
          "303: {",
          "304:  unsigned int  *fc;",
          "305:  struct videbuf_vmalloc_memory *mem=q->read_buf->priv;",
          "306:  BUG_ON (!mem);",
          "307:  MAGIC_CHECK(mem->magic,MAGIC_VMAL_MEM);",
          "309:  if (vbihack) {",
          "314:   fc  = (unsigned int*)mem->vmalloc;",
          "315:   fc += (q->read_buf->size>>2) -1;",
          "317:   dprintk(1,\"vbihack: %d\\n\",*fc);",
          "318:  }",
          "321:  count = __videobuf_copy_to_user (q,data,count,nonblocking);",
          "323:  if ( (count==-EFAULT) && (0 == pos) )",
          "324:   return -EFAULT;",
          "326:  return count;",
          "327: }",
          "329: static struct videobuf_qtype_ops qops = {",
          "330:  .magic        = MAGIC_QTYPE_OPS,",
          "332:  .alloc        = __videobuf_alloc,",
          "333:  .iolock       = __videobuf_iolock,",
          "334:  .sync         = __videobuf_sync,",
          "335:  .mmap_free    = __videobuf_mmap_free,",
          "336:  .mmap_mapper  = __videobuf_mmap_mapper,",
          "337:  .is_mmapped   = __videobuf_is_mmapped,",
          "338:  .copy_to_user = __videobuf_copy_to_user,",
          "339:  .copy_stream  = __videobuf_copy_stream,",
          "340: };",
          "342: void videobuf_queue_vmalloc_init(struct videobuf_queue* q,",
          "343:     struct videobuf_queue_ops *ops,",
          "344:     void *dev,",
          "345:     spinlock_t *irqlock,",
          "346:     enum v4l2_buf_type type,",
          "347:     enum v4l2_field field,",
          "348:     unsigned int msize,",
          "349:     void *priv)",
          "350: {",
          "351:  videobuf_queue_init(q, ops, dev, irqlock, type, field, msize, priv);",
          "352:  q->int_ops=&qops;",
          "353: }",
          "355: EXPORT_SYMBOL_GPL(videobuf_queue_vmalloc_init);",
          "357: void *videobuf_to_vmalloc (struct videobuf_buffer *buf)",
          "358: {",
          "359:  struct videbuf_vmalloc_memory *mem=buf->priv;",
          "360:  BUG_ON (!mem);",
          "361:  MAGIC_CHECK(mem->magic,MAGIC_VMAL_MEM);",
          "363:  return mem->vmalloc;",
          "364: }",
          "365: EXPORT_SYMBOL_GPL(videobuf_to_vmalloc);",
          "367: void videobuf_vmalloc_free (struct videobuf_buffer *buf)",
          "368: {",
          "369:  struct videbuf_vmalloc_memory *mem=buf->priv;",
          "370:  BUG_ON (!mem);",
          "372:  MAGIC_CHECK(mem->magic,MAGIC_VMAL_MEM);",
          "374:  vfree(mem->vmalloc);",
          "376:  return;",
          "377: }",
          "378: EXPORT_SYMBOL_GPL(videobuf_vmalloc_free);",
          "",
          "---------------"
        ],
        "include/media/videobuf-vmalloc.h||include/media/videobuf-vmalloc.h": [
          "File: include/media/videobuf-vmalloc.h -> include/media/videobuf-vmalloc.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "16: #include <media/videobuf-core.h>",
          "20: struct videbuf_vmalloc_memory",
          "21: {",
          "22:  u32                 magic;",
          "25:  struct videobuf_mapping *map;",
          "27:  void                *vmalloc;",
          "30:  struct vm_area_struct *vma;",
          "31: };",
          "33: void videobuf_queue_vmalloc_init(struct videobuf_queue* q,",
          "34:     struct videobuf_queue_ops *ops,",
          "35:     void *dev,",
          "36:     spinlock_t *irqlock,",
          "37:     enum v4l2_buf_type type,",
          "38:     enum v4l2_field field,",
          "39:     unsigned int msize,",
          "40:     void *priv);",
          "42: void *videobuf_to_vmalloc (struct videobuf_buffer *buf);",
          "44: void videobuf_vmalloc_free (struct videobuf_buffer *buf);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "968ced78a53509a996708a14e8b9269d1dc6a61c",
      "candidate_info": {
        "commit_hash": "968ced78a53509a996708a14e8b9269d1dc6a61c",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/968ced78a53509a996708a14e8b9269d1dc6a61c",
        "files": [
          "drivers/media/video/videobuf-core.c",
          "drivers/media/video/videobuf-vmalloc.c"
        ],
        "message": "V4L/DVB (7552): videbuf-vmalloc: Corrects mmap code\n\nThere were some bugs on videobuf-vmalloc.\n\nBasically, remap were called with a wrong parameter. Due to that, a later remap\nwere needed, generating the need of some hacks on videobuf-vmalloc and\nvideobuf-core.\n\nThis patch fixes the remap and removes the hacks.\n\nTODO:\n\n- V4L2_MEMORY_USERPTR is not implemented yet. This method should be\n  properly implemented, in order to work with a few userspace applications.\n\n- The driver also doesn't implement V4L2_MEMORY_OVERLAY. This method is used\n  only by a few applications, and are becaming obsolete, due to the increment\n  of cpu performance. So, most apps prefer to retrieve data to an internal\n  buffer, doing some processing like de-interlacing.\n\nSigned-off-by: Mauro Carvalho Chehab <mchehab@infradead.org>",
        "before_after_code_files": [
          "drivers/media/video/videobuf-core.c||drivers/media/video/videobuf-core.c",
          "drivers/media/video/videobuf-vmalloc.c||drivers/media/video/videobuf-vmalloc.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "drivers/media/video/videobuf-vmalloc.c||drivers/media/video/videobuf-vmalloc.c"
          ],
          "candidate": [
            "drivers/media/video/videobuf-vmalloc.c||drivers/media/video/videobuf-vmalloc.c"
          ]
        }
      },
      "candidate_diff": {
        "drivers/media/video/videobuf-core.c||drivers/media/video/videobuf-core.c": [
          "File: drivers/media/video/videobuf-core.c -> drivers/media/video/videobuf-core.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "91:  MAGIC_CHECK(vb->magic, MAGIC_BUFFER);",
          "92:  MAGIC_CHECK(q->int_ops->magic, MAGIC_QTYPE_OPS);",
          "108:  return CALL(q, iolock, q, vb, fbuf);",
          "109: }",
          "",
          "[Removed Lines]",
          "95:     since mmap_mapper() method should be called before _iolock.",
          "96:     On some cases, the mmap_mapper() is called only after scheduling.",
          "98:  if (vb->memory == V4L2_MEMORY_MMAP) {",
          "99:   wait_event_timeout(vb->done, q->is_mmapped,",
          "100:        msecs_to_jiffies(100));",
          "101:   if (!q->is_mmapped) {",
          "102:    printk(KERN_ERR",
          "103:           \"Error: mmap_mapper() never called!\\n\");",
          "104:    return -EINVAL;",
          "105:   }",
          "106:  }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "drivers/media/video/videobuf-vmalloc.c||drivers/media/video/videobuf-vmalloc.c": [
          "File: drivers/media/video/videobuf-vmalloc.c -> drivers/media/video/videobuf-vmalloc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "124:          struct videobuf_buffer *vb,",
          "125:          struct v4l2_framebuffer *fbuf)",
          "126: {",
          "130:  BUG_ON(!mem);",
          "165:   }",
          "166:  }",
          "168:  return 0;",
          "",
          "[Removed Lines]",
          "127:  int pages;",
          "128:  struct videobuf_vmalloc_memory *mem=vb->priv;",
          "132:  MAGIC_CHECK(mem->magic,MAGIC_VMAL_MEM);",
          "134:  pages = PAGE_ALIGN(vb->size) >> PAGE_SHIFT;",
          "137:  if ((vb->memory != V4L2_MEMORY_MMAP) &&",
          "138:     (vb->memory != V4L2_MEMORY_USERPTR) ) {",
          "139:   printk(KERN_ERR \"Method currently unsupported.\\n\");",
          "140:   return -EINVAL;",
          "141:  }",
          "144:  mem->vmalloc=vmalloc_user (PAGE_ALIGN(vb->size));",
          "145:  if (NULL == mem->vmalloc) {",
          "146:   printk(KERN_ERR \"vmalloc (%d pages) failed\\n\",pages);",
          "147:   return -ENOMEM;",
          "148:  }",
          "150:  dprintk(1,\"vmalloc is at addr 0x%08lx, size=%d\\n\",",
          "151:     (unsigned long)mem->vmalloc,",
          "152:     pages << PAGE_SHIFT);",
          "155:     the mmap() call",
          "157:  if (mem->vma) {",
          "158:   int retval=remap_vmalloc_range(mem->vma, mem->vmalloc,0);",
          "159:   kfree(mem->vma);",
          "160:   mem->vma=NULL;",
          "161:   if (retval<0) {",
          "162:    dprintk(1,\"mmap app bug: remap_vmalloc_range area %p error %d\\n\",",
          "163:     mem->vmalloc,retval);",
          "164:    return retval;",
          "",
          "[Added Lines]",
          "127:  struct videobuf_vmalloc_memory *mem = vb->priv;",
          "131:  MAGIC_CHECK(mem->magic, MAGIC_VMAL_MEM);",
          "133:  switch (vb->memory) {",
          "134:  case V4L2_MEMORY_MMAP:",
          "135:   dprintk(1, \"%s memory method MMAP\\n\", __func__);",
          "138:   if (!mem->vmalloc) {",
          "139:    printk(KERN_ERR \"memory is not alloced/mmapped.\\n\");",
          "140:    return -EINVAL;",
          "141:   }",
          "142:   break;",
          "143:  case V4L2_MEMORY_USERPTR:",
          "144:  {",
          "145:   int pages = PAGE_ALIGN(vb->size);",
          "147:   dprintk(1, \"%s memory method USERPTR\\n\", __func__);",
          "149: #if 1",
          "150:   if (vb->baddr) {",
          "151:    printk(KERN_ERR \"USERPTR is currently not supported\\n\");",
          "152:    return -EINVAL;",
          "153:   }",
          "154: #endif",
          "157:      read() method.",
          "160:   mem->vmalloc = vmalloc_user(pages);",
          "161:   if (!mem->vmalloc) {",
          "162:    printk(KERN_ERR \"vmalloc (%d pages) failed\\n\", pages);",
          "163:    return -ENOMEM;",
          "165:   dprintk(1, \"vmalloc is at addr %p (%d pages)\\n\",",
          "166:    mem->vmalloc, pages);",
          "168: #if 0",
          "169:   int rc;",
          "171:      there's no need to remap, since data will be copied to user",
          "173:   if (!vb->baddr)",
          "174:    return 0;",
          "177:      The code bellow won't work, since mem->vma = NULL",
          "180:   rc = remap_vmalloc_range(mem->vma, (void *)vb->baddr, 0);",
          "181:   if (rc < 0) {",
          "182:    printk(KERN_ERR \"mmap: remap failed with error %d. \", rc);",
          "183:    return -ENOMEM;",
          "184:   }",
          "185: #endif",
          "187:   break;",
          "188:  }",
          "189:  case V4L2_MEMORY_OVERLAY:",
          "190:  default:",
          "191:   dprintk(1, \"%s memory method OVERLAY/unknown\\n\", __func__);",
          "194:   printk(KERN_ERR \"Memory method currently unsupported.\\n\");",
          "195:   return -EINVAL;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "178: {",
          "179:  unsigned int i;",
          "181:  for (i = 0; i < VIDEO_MAX_FRAME; i++) {",
          "182:   if (q->bufs[i]) {",
          "183:    if (q->bufs[i]->map)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "211:  dprintk(1, \"%s\\n\", __func__);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "194:  struct videobuf_vmalloc_memory *mem;",
          "195:  struct videobuf_mapping *map;",
          "196:  unsigned int first;",
          "198:  unsigned long offset = vma->vm_pgoff << PAGE_SHIFT;",
          "201:   return -EINVAL;",
          "",
          "[Removed Lines]",
          "197:  int retval;",
          "200:  if (! (vma->vm_flags & VM_WRITE) || ! (vma->vm_flags & VM_SHARED))",
          "",
          "[Added Lines]",
          "228:  int retval, pages;",
          "231:  dprintk(1, \"%s\\n\", __func__);",
          "232:  if (!(vma->vm_flags & VM_WRITE) || !(vma->vm_flags & VM_SHARED))",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "217:  }",
          "221:  if (NULL == map)",
          "222:   return -ENOMEM;",
          "224:  map->start = vma->vm_start;",
          "225:  map->end   = vma->vm_end;",
          "226:  map->q     = q;",
          "228:  q->bufs[first]->baddr = vma->vm_start;",
          "250:  }",
          "252:  dprintk(1,\"mmap %p: q=%p %08lx-%08lx (%lx) pgoff %08lx buf %d\\n\",",
          "254:   (long int) q->bufs[first]->bsize,",
          "257:  videobuf_vm_open(vma);",
          "260: }",
          "262: static int __videobuf_copy_to_user ( struct videobuf_queue *q,",
          "",
          "[Removed Lines]",
          "220:  map = q->bufs[first]->map = kzalloc(sizeof(struct videobuf_mapping),GFP_KERNEL);",
          "230:  vma->vm_ops          = &videobuf_vm_ops;",
          "231:  vma->vm_flags       |= VM_DONTEXPAND | VM_RESERVED;",
          "232:  vma->vm_private_data = map;",
          "234:  mem=q->bufs[first]->priv;",
          "235:  BUG_ON (!mem);",
          "236:  MAGIC_CHECK(mem->magic,MAGIC_VMAL_MEM);",
          "239:  retval=remap_vmalloc_range(vma, mem->vmalloc,0);",
          "240:  if (retval<0) {",
          "241:   dprintk(1,\"mmap: postponing remap_vmalloc_range\\n\");",
          "243:   mem->vma=kmalloc(sizeof(*vma),GFP_KERNEL);",
          "244:   if (!mem->vma) {",
          "245:    kfree(map);",
          "246:    q->bufs[first]->map=NULL;",
          "247:    return -ENOMEM;",
          "248:   }",
          "249:   memcpy(mem->vma,vma,sizeof(*vma));",
          "253:   map,q,vma->vm_start,vma->vm_end,",
          "255:   vma->vm_pgoff,first);",
          "259:  return (0);",
          "",
          "[Added Lines]",
          "252:  map = kzalloc(sizeof(struct videobuf_mapping), GFP_KERNEL);",
          "256:  q->bufs[first]->map = map;",
          "263:  mem = q->bufs[first]->priv;",
          "264:  BUG_ON(!mem);",
          "265:  MAGIC_CHECK(mem->magic, MAGIC_VMAL_MEM);",
          "267:  pages = PAGE_ALIGN(vma->vm_end - vma->vm_start);",
          "268:  mem->vmalloc = vmalloc_user(pages);",
          "269:  if (!mem->vmalloc) {",
          "270:   printk(KERN_ERR \"vmalloc (%d pages) failed\\n\", pages);",
          "271:   goto error;",
          "272:  }",
          "273:  dprintk(1, \"vmalloc is at addr %p (%d pages)\\n\",",
          "274:   mem->vmalloc, pages);",
          "277:  retval = remap_vmalloc_range(vma, mem->vmalloc, 0);",
          "278:  if (retval < 0) {",
          "279:   printk(KERN_ERR \"mmap: remap failed with error %d. \", retval);",
          "280:   vfree(mem->vmalloc);",
          "281:   goto error;",
          "284:  vma->vm_ops          = &videobuf_vm_ops;",
          "285:  vma->vm_flags       |= VM_DONTEXPAND | VM_RESERVED;",
          "286:  vma->vm_private_data = map;",
          "289:   map, q, vma->vm_start, vma->vm_end,",
          "291:   vma->vm_pgoff, first);",
          "295:  return 0;",
          "297: error:",
          "298:  mem = NULL;",
          "299:  kfree(map);",
          "300:  return -ENOMEM;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "348: void videobuf_vmalloc_free (struct videobuf_buffer *buf)",
          "349: {",
          "355:  vfree(mem->vmalloc);",
          "358:  return;",
          "359: }",
          "",
          "[Removed Lines]",
          "350:  struct videobuf_vmalloc_memory *mem=buf->priv;",
          "351:  BUG_ON (!mem);",
          "353:  MAGIC_CHECK(mem->magic,MAGIC_VMAL_MEM);",
          "356:  mem->vmalloc=NULL;",
          "",
          "[Added Lines]",
          "391:  struct videobuf_vmalloc_memory *mem = buf->priv;",
          "393:  if (!mem)",
          "394:   return;",
          "396:  MAGIC_CHECK(mem->magic, MAGIC_VMAL_MEM);",
          "399:  mem->vmalloc = NULL;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "851c0c96b2212f48fe51afc1589541b5eae3a544",
      "candidate_info": {
        "commit_hash": "851c0c96b2212f48fe51afc1589541b5eae3a544",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/851c0c96b2212f48fe51afc1589541b5eae3a544",
        "files": [
          "drivers/media/video/videobuf-core.c",
          "drivers/media/video/videobuf-dma-sg.c",
          "drivers/media/video/videobuf-vmalloc.c",
          "include/media/videobuf-core.h",
          "include/media/videobuf-dma-sg.h",
          "include/media/videobuf-vmalloc.h"
        ],
        "message": "V4L/DVB (6266): videobuf cleanup: mmap check is common to all videobuf. Make it at core\n\nSigned-off-by: Mauro Carvalho Chehab <mchehab@infradead.org>\nhttp://thread.gmane.org/gmane.comp.video.video4linux/34978/focus=34981\nReviewed-by: Ricardo Cerqueira <v4l@cerqueira.org>",
        "before_after_code_files": [
          "drivers/media/video/videobuf-core.c||drivers/media/video/videobuf-core.c",
          "drivers/media/video/videobuf-dma-sg.c||drivers/media/video/videobuf-dma-sg.c",
          "drivers/media/video/videobuf-vmalloc.c||drivers/media/video/videobuf-vmalloc.c",
          "include/media/videobuf-core.h||include/media/videobuf-core.h",
          "include/media/videobuf-dma-sg.h||include/media/videobuf-dma-sg.h",
          "include/media/videobuf-vmalloc.h||include/media/videobuf-vmalloc.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "drivers/media/video/videobuf-vmalloc.c||drivers/media/video/videobuf-vmalloc.c"
          ],
          "candidate": [
            "drivers/media/video/videobuf-vmalloc.c||drivers/media/video/videobuf-vmalloc.c"
          ]
        }
      },
      "candidate_diff": {
        "drivers/media/video/videobuf-core.c||drivers/media/video/videobuf-core.c": [
          "File: drivers/media/video/videobuf-core.c -> drivers/media/video/videobuf-core.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "149:  for (i = 0; i < VIDEO_MAX_FRAME; i++) {",
          "150:   if (NULL == q->bufs[i])",
          "151:    continue;",
          "153:    dprintk(1,\"busy: buffer #%d mapped\\n\",i);",
          "154:    return 1;",
          "155:   }",
          "",
          "[Removed Lines]",
          "152:   if (CALL(q,is_mmapped,q->bufs[i])) {",
          "",
          "[Added Lines]",
          "152:   if (q->bufs[i]->map) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "238:  }",
          "240:  b->flags    = 0;",
          "242:   b->flags |= V4L2_BUF_FLAG_MAPPED;",
          "244:  switch (vb->state) {",
          "",
          "[Removed Lines]",
          "241:  if (CALL(q,is_mmapped,vb))",
          "",
          "[Added Lines]",
          "241:  if (vb->map)",
          "",
          "---------------"
        ],
        "drivers/media/video/videobuf-dma-sg.c||drivers/media/video/videobuf-dma-sg.c": [
          "File: drivers/media/video/videobuf-dma-sg.c -> drivers/media/video/videobuf-dma-sg.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "375:    MAGIC_CHECK(mem->magic,MAGIC_SG_MEM);",
          "378:     continue;",
          "380:    q->bufs[i]->baddr = 0;",
          "381:    q->ops->buf_release(q,q->bufs[i]);",
          "382:   }",
          "",
          "[Removed Lines]",
          "377:    if (mem->map != map)",
          "379:    mem->map   = NULL;",
          "",
          "[Added Lines]",
          "377:    if (q->bufs[i]->map != map)",
          "379:    q->bufs[i]->map   = NULL;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "521:  for (i = 0; i < VIDEO_MAX_FRAME; i++) {",
          "522:   if (q->bufs[i]) {",
          "525:     return -EBUSY;",
          "526:   }",
          "527:  }",
          "",
          "[Removed Lines]",
          "523:    struct videbuf_pci_sg_memory *mem=q->bufs[i]->priv;",
          "524:    if (mem && mem->map)",
          "",
          "[Added Lines]",
          "523:    if (q->bufs[i]->map)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "572:    continue;",
          "573:   if (V4L2_MEMORY_MMAP != q->bufs[last]->memory)",
          "574:    continue;",
          "577:    retval = -EBUSY;",
          "578:    goto done;",
          "579:   }",
          "",
          "[Removed Lines]",
          "575:   mem=q->bufs[last]->priv;",
          "576:   if (mem->map) {",
          "",
          "[Added Lines]",
          "574:   if (q->bufs[last]->map) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "593:  if (NULL == map)",
          "594:   goto done;",
          "595:  for (size = 0, i = first; i <= last; size += q->bufs[i++]->bsize) {",
          "598:   q->bufs[i]->baddr = vma->vm_start + size;",
          "599:  }",
          "600:  map->count    = 1;",
          "",
          "[Removed Lines]",
          "596:   mem=q->bufs[i]->priv;",
          "597:   mem->map   = map;",
          "",
          "[Added Lines]",
          "594:   q->bufs[i]->map   = map;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "613:  return retval;",
          "614: }",
          "626: static int __videobuf_copy_to_user ( struct videobuf_queue *q,",
          "627:     char __user *data, size_t count,",
          "628:     int nonblocking )",
          "",
          "[Removed Lines]",
          "616: static int __videobuf_is_mmapped (struct videobuf_buffer *buf)",
          "617: {",
          "618:  struct videbuf_pci_sg_memory *mem=buf->priv;",
          "620:  BUG_ON (!mem);",
          "621:  MAGIC_CHECK(mem->magic,MAGIC_SG_MEM);",
          "623:  return (mem->map)?1:0;",
          "624: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "678:  .sync         = __videobuf_sync,",
          "679:  .mmap_free    = __videobuf_mmap_free,",
          "680:  .mmap_mapper  = __videobuf_mmap_mapper,",
          "682:  .copy_to_user = __videobuf_copy_to_user,",
          "683:  .copy_stream  = __videobuf_copy_stream,",
          "684: };",
          "",
          "[Removed Lines]",
          "681:  .is_mmapped   = __videobuf_is_mmapped,",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "drivers/media/video/videobuf-vmalloc.c||drivers/media/video/videobuf-vmalloc.c": [
          "File: drivers/media/video/videobuf-vmalloc.c -> drivers/media/video/videobuf-vmalloc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "62: {",
          "63:  struct videobuf_mapping *map = vma->vm_private_data;",
          "64:  struct videobuf_queue *q = map->q;",
          "66:  int i;",
          "68:  dprintk(2,\"vm_close %p [count=%d,vma=%08lx-%08lx]\\n\",map,",
          "",
          "[Removed Lines]",
          "65:  struct videbuf_vmalloc_memory *mem;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "75:   for (i = 0; i < VIDEO_MAX_FRAME; i++) {",
          "76:    if (NULL == q->bufs[i])",
          "77:     continue;",
          "86:     continue;",
          "88:    q->ops->buf_release(q,q->bufs[i]);",
          "91:    q->bufs[i]->baddr = 0;",
          "92:   }",
          "93:   mutex_unlock(&q->lock);",
          "",
          "[Removed Lines]",
          "78:    mem=q->bufs[i]->priv;",
          "80:    if (!mem)",
          "81:     continue;",
          "83:    MAGIC_CHECK(mem->magic,MAGIC_VMAL_MEM);",
          "85:    if (mem->map != map)",
          "90:    mem->map   = NULL;",
          "",
          "[Added Lines]",
          "78:    if (q->bufs[i]->map != map)",
          "83:    q->bufs[i]->map   = NULL;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "192:  for (i = 0; i < VIDEO_MAX_FRAME; i++) {",
          "193:   if (q->bufs[i]) {",
          "196:     return -EBUSY;",
          "197:   }",
          "198:  }",
          "",
          "[Removed Lines]",
          "194:    struct videbuf_vmalloc_memory *mem=q->bufs[i]->priv;",
          "195:    if (mem && mem->map)",
          "",
          "[Added Lines]",
          "187:    if (q->bufs[i]->map)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "227:    (vma->vm_pgoff << PAGE_SHIFT));",
          "228:   return -EINVAL;",
          "229:  }",
          "236:  if (NULL == map)",
          "237:   return -ENOMEM;",
          "",
          "[Removed Lines]",
          "230:  mem=q->bufs[first]->priv;",
          "231:  BUG_ON (!mem);",
          "232:  MAGIC_CHECK(mem->magic,MAGIC_VMAL_MEM);",
          "235:  map = mem->map = kmalloc(sizeof(struct videobuf_mapping),GFP_KERNEL);",
          "",
          "[Added Lines]",
          "224:  map = q->bufs[first]->map = kmalloc(sizeof(struct videobuf_mapping),GFP_KERNEL);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "246:  vma->vm_flags       |= VM_DONTEXPAND | VM_RESERVED;",
          "247:  vma->vm_private_data = map;",
          "250:  retval=remap_vmalloc_range(vma, mem->vmalloc,0);",
          "251:  if (retval<0) {",
          "252:   dprintk(1,\"mmap: postponing remap_vmalloc_range\\n\");",
          "253:   mem->vma=kmalloc(sizeof(*vma),GFP_KERNEL);",
          "254:   if (!mem->vma) {",
          "255:    kfree(map);",
          "257:    return -ENOMEM;",
          "258:   }",
          "259:   memcpy(mem->vma,vma,sizeof(*vma));",
          "",
          "[Removed Lines]",
          "256:    mem->map=NULL;",
          "",
          "[Added Lines]",
          "238:  mem=q->bufs[first]->priv;",
          "239:  BUG_ON (!mem);",
          "240:  MAGIC_CHECK(mem->magic,MAGIC_VMAL_MEM);",
          "250:    q->bufs[first]->map=NULL;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "269:  return (0);",
          "270: }",
          "281: static int __videobuf_copy_to_user ( struct videobuf_queue *q,",
          "282:     char __user *data, size_t count,",
          "283:     int nonblocking )",
          "",
          "[Removed Lines]",
          "272: static int __videobuf_is_mmapped (struct videobuf_buffer *buf)",
          "273: {",
          "274:  struct videbuf_vmalloc_memory *mem=buf->priv;",
          "275:  BUG_ON (!mem);",
          "276:  MAGIC_CHECK(mem->magic,MAGIC_VMAL_MEM);",
          "278:  return (mem->map)?1:0;",
          "279: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "335:  .sync         = __videobuf_sync,",
          "336:  .mmap_free    = __videobuf_mmap_free,",
          "337:  .mmap_mapper  = __videobuf_mmap_mapper,",
          "339:  .copy_to_user = __videobuf_copy_to_user,",
          "340:  .copy_stream  = __videobuf_copy_stream,",
          "341: };",
          "",
          "[Removed Lines]",
          "338:  .is_mmapped   = __videobuf_is_mmapped,",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "include/media/videobuf-core.h||include/media/videobuf-core.h": [
          "File: include/media/videobuf-core.h -> include/media/videobuf-core.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "98:  unsigned long           baddr;",
          "101:  int   privsize;",
          "102:  void                    *priv;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "101:  struct videobuf_mapping *map;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "143:  int (*mmap_free) (struct videobuf_queue *q);",
          "144:  int (*mmap_mapper) (struct videobuf_queue *q,",
          "145:     struct vm_area_struct *vma);",
          "147: };",
          "149: struct videobuf_queue {",
          "",
          "[Removed Lines]",
          "146:  int (*is_mmapped) (struct videobuf_buffer *buf);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "include/media/videobuf-dma-sg.h||include/media/videobuf-dma-sg.h": [
          "File: include/media/videobuf-dma-sg.h -> include/media/videobuf-dma-sg.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "86:  u32                 magic;",
          "90:  struct videobuf_dmabuf  dma;",
          "91: };",
          "",
          "[Removed Lines]",
          "89:  struct videobuf_mapping *map;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "include/media/videobuf-vmalloc.h||include/media/videobuf-vmalloc.h": [
          "File: include/media/videobuf-vmalloc.h -> include/media/videobuf-vmalloc.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "21: {",
          "22:  u32                 magic;",
          "27:  void                *vmalloc;",
          "",
          "[Removed Lines]",
          "25:  struct videobuf_mapping *map;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "aaea56afc31345e7b0456ebb01586ba627ecd0f8",
      "candidate_info": {
        "commit_hash": "aaea56afc31345e7b0456ebb01586ba627ecd0f8",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/aaea56afc31345e7b0456ebb01586ba627ecd0f8",
        "files": [
          "drivers/media/video/videobuf-vmalloc.c"
        ],
        "message": "V4L/DVB (7553): videobuf-vmalloc: fix STREAMOFF/STREAMON\n\nThere were a small bug on videobuf-vmalloc that were preventing STREAMOFF to\nwork. The issue is that vmalloc'ed mmaped memory should only be freed after\nbeing sure that there aren't any mmap usage. Otherwise, the memory remap will\nstop working, and the userspace won't receive any frames.\n\nThis bug were affecting some userspace applications, like tvtime.\n\nAfter this patch, tvtime started to work again with the drivers that use\nvideobuf-vmalloc.\n\nSigned-off-by: Mauro Carvalho Chehab <mchehab@infradead.org>",
        "before_after_code_files": [
          "drivers/media/video/videobuf-vmalloc.c||drivers/media/video/videobuf-vmalloc.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "drivers/media/video/videobuf-vmalloc.c||drivers/media/video/videobuf-vmalloc.c"
          ],
          "candidate": [
            "drivers/media/video/videobuf-vmalloc.c||drivers/media/video/videobuf-vmalloc.c"
          ]
        }
      },
      "candidate_diff": {
        "drivers/media/video/videobuf-vmalloc.c||drivers/media/video/videobuf-vmalloc.c": [
          "File: drivers/media/video/videobuf-vmalloc.c -> drivers/media/video/videobuf-vmalloc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "57:  map->count++;",
          "58: }",
          "62: {",
          "63:  struct videobuf_mapping *map = vma->vm_private_data;",
          "64:  struct videobuf_queue *q = map->q;",
          "65:  int i;",
          "70:  map->count--;",
          "71:  if (0 == map->count) {",
          "73:   mutex_lock(&q->vb_lock);",
          "74:   for (i = 0; i < VIDEO_MAX_FRAME; i++) {",
          "75:    if (NULL == q->bufs[i])",
          "",
          "[Removed Lines]",
          "60: static void",
          "61: videobuf_vm_close(struct vm_area_struct *vma)",
          "67:  dprintk(2,\"vm_close %p [count=%u,vma=%08lx-%08lx]\\n\",map,",
          "68:   map->count,vma->vm_start,vma->vm_end);",
          "72:   dprintk(1,\"munmap %p q=%p\\n\",map,q);",
          "",
          "[Added Lines]",
          "60: static void videobuf_vm_close(struct vm_area_struct *vma)",
          "66:  dprintk(2,\"vm_close %p [count=%u,vma=%08lx-%08lx]\\n\", map,",
          "67:   map->count, vma->vm_start, vma->vm_end);",
          "71:   struct videobuf_vmalloc_memory *mem;",
          "73:   dprintk(1, \"munmap %p q=%p\\n\", map, q);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "78:    if (q->bufs[i]->map != map)",
          "79:     continue;",
          "81:    q->bufs[i]->map   = NULL;",
          "82:    q->bufs[i]->baddr = 0;",
          "83:   }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "82:    mem = q->bufs[i]->priv;",
          "83:    if (mem) {",
          "85:        allocated memory and this memory is mmapped.",
          "86:        In this case, memory should be freed,",
          "87:        in order to do memory unmap.",
          "89:     MAGIC_CHECK(mem->magic, MAGIC_VMAL_MEM);",
          "90:     vfree(mem->vmalloc);",
          "91:     mem->vmalloc = NULL;",
          "92:    }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "390: {",
          "391:  struct videobuf_vmalloc_memory *mem = buf->priv;",
          "393:  if (!mem)",
          "394:   return;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "407:     would be released, while still needed. In this case, the memory",
          "408:     release should happen inside videobuf_vm_close().",
          "409:     So, it should free memory only if the memory were allocated for",
          "410:     read() operation.",
          "412:  if ((buf->memory != V4L2_MEMORY_USERPTR) || (buf->baddr == 0))",
          "413:   return;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
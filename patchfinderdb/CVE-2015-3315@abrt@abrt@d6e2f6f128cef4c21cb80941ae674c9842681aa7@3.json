{
  "cve_id": "CVE-2015-3315",
  "cve_desc": "Automatic Bug Reporting Tool (ABRT) allows local users to read, change the ownership of, or have other unspecified impact on arbitrary files via a symlink attack on (1) /var/tmp/abrt/*/maps, (2) /tmp/jvm-*/hs_error.log, (3) /proc/*/exe, (4) /etc/os-release in a chroot, or (5) an unspecified root directory related to librpm.",
  "repo": "abrt/abrt",
  "patch_hash": "d6e2f6f128cef4c21cb80941ae674c9842681aa7",
  "patch_info": {
    "commit_hash": "d6e2f6f128cef4c21cb80941ae674c9842681aa7",
    "repo": "abrt/abrt",
    "commit_url": "https://github.com/abrt/abrt/commit/d6e2f6f128cef4c21cb80941ae674c9842681aa7",
    "files": [
      "src/hooks/abrt-hook-ccpp.c"
    ],
    "message": "ccpp: open file for dump_fd_info with O_EXCL\n\nTo avoid possible races.\n\nRelated: #1211835\n\nSigned-off-by: Jakub Filak <jfilak@redhat.com>",
    "before_after_code_files": [
      "src/hooks/abrt-hook-ccpp.c||src/hooks/abrt-hook-ccpp.c"
    ]
  },
  "patch_diff": {
    "src/hooks/abrt-hook-ccpp.c||src/hooks/abrt-hook-ccpp.c": [
      "File: src/hooks/abrt-hook-ccpp.c -> src/hooks/abrt-hook-ccpp.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "400: static bool dump_fd_info(const char *dest_filename, char *source_filename, int source_base_ofs, uid_t uid, gid_t gid)",
      "401: {",
      "403:     if (!fp)",
      "404:         return false;",
      "",
      "[Removed Lines]",
      "402:     FILE *fp = fopen(dest_filename, \"w\");",
      "",
      "[Added Lines]",
      "402:     FILE *fp = fopen(dest_filename, \"wx\");",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "806bb07571b698d90169c3b73cb65cd09c900284",
      "candidate_info": {
        "commit_hash": "806bb07571b698d90169c3b73cb65cd09c900284",
        "repo": "abrt/abrt",
        "commit_url": "https://github.com/abrt/abrt/commit/806bb07571b698d90169c3b73cb65cd09c900284",
        "files": [
          "src/hooks/abrt-hook-ccpp.c"
        ],
        "message": "ccpp: do not use value of /proc/PID/cwd for chdir\n\nAvoid symlink resolutions.\n\nThis issue was discovered by Florian Weimer of Red Hat Product Security.\n\nSigned-off-by: Jakub Filak <jfilak@redhat.com>",
        "before_after_code_files": [
          "src/hooks/abrt-hook-ccpp.c||src/hooks/abrt-hook-ccpp.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/abrt/abrt/pull/950"
        ],
        "olp_code_files": {
          "patch": [
            "src/hooks/abrt-hook-ccpp.c||src/hooks/abrt-hook-ccpp.c"
          ],
          "candidate": [
            "src/hooks/abrt-hook-ccpp.c||src/hooks/abrt-hook-ccpp.c"
          ]
        }
      },
      "candidate_diff": {
        "src/hooks/abrt-hook-ccpp.c||src/hooks/abrt-hook-ccpp.c": [
          "File: src/hooks/abrt-hook-ccpp.c -> src/hooks/abrt-hook-ccpp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "146: static char *user_pwd;",
          "147: static char *proc_pid_status;",
          "148: static struct dump_dir *dd;",
          "149: static int user_core_fd = -1;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "147: static DIR *proc_cwd;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "164: static const char percent_specifiers[] = \"%scpugteh\";",
          "165: static char *core_basename = (char*) \"core\";",
          "174: static char* get_executable(pid_t pid, int *fd_p)",
          "175: {",
          "",
          "[Removed Lines]",
          "171: static char *full_core_basename;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "198:     return executable;",
          "199: }",
          "201: static char* get_cwd(pid_t pid)",
          "202: {",
          "203:     char buf[sizeof(\"/proc/%lu/cwd\") + sizeof(long)*3];",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "195: static DIR *open_cwd(pid_t pid)",
          "196: {",
          "197:     char buf[sizeof(\"/proc/%lu/cwd\") + sizeof(long)*3];",
          "198:     sprintf(buf, \"/proc/%lu/cwd\", (long)pid);",
          "200:     DIR *cwd = opendir(buf);",
          "201:     if (cwd == NULL)",
          "202:         perror_msg(\"Can't open process's CWD for CompatCore\");",
          "204:     return cwd;",
          "205: }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "269: static int open_user_core(uid_t uid, uid_t fsuid, pid_t pid, char **percent_values)",
          "270: {",
          "276:         return -1;",
          "279:     struct passwd* pw = getpwuid(uid);",
          "280:     gid_t gid = pw ? pw->pw_gid : uid;",
          "",
          "[Removed Lines]",
          "271:     errno = 0;",
          "272:     if (user_pwd == NULL",
          "273:      || chdir(user_pwd) != 0",
          "274:     ) {",
          "275:         perror_msg(\"Can't cd to '%s'\", user_pwd);",
          "277:     }",
          "",
          "[Added Lines]",
          "277:     proc_cwd = open_cwd(pid);",
          "278:     if (proc_cwd == NULL)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "337:         }",
          "338:     }",
          "342:     {",
          "349:     }",
          "",
          "[Removed Lines]",
          "340:     full_core_basename = core_basename;",
          "341:     if (core_basename[0] != '/')",
          "343:         if (g_need_nonrelative)",
          "344:         {",
          "345:             error_msg(\"Current suid_dumpable policy prevents from saving core dumps according to relative core_pattern\");",
          "346:             return -1;",
          "347:         }",
          "348:         core_basename = concat_path_file(user_pwd, core_basename);",
          "",
          "[Added Lines]",
          "342:     if (g_need_nonrelative && core_basename[0] != '/')",
          "344:         error_msg(\"Current suid_dumpable policy prevents from saving core dumps according to relative core_pattern\");",
          "345:         return -1;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "391:      || sb.st_uid != fsuid",
          "392:     ) {",
          "393:         if (user_core_fd < 0)",
          "395:         else",
          "397:         return -1;",
          "398:     }",
          "399:     if (ftruncate(user_core_fd, 0) != 0) {",
          "403:         return -1;",
          "404:     }",
          "",
          "[Removed Lines]",
          "394:             perror_msg(\"Can't open '%s'\", full_core_basename);",
          "396:             perror_msg(\"'%s' is not a regular file with link count 1 owned by UID(%d)\", full_core_basename, fsuid);",
          "401:         perror_msg(\"Can't truncate '%s' to size 0\", full_core_basename);",
          "402:         unlink(core_basename);",
          "",
          "[Added Lines]",
          "391:             perror_msg(\"Can't open '%s' at '%s'\", core_basename, user_pwd);",
          "393:             perror_msg(\"'%s' at '%s' is not a regular file with link count 1 owned by UID(%d)\", core_basename, user_pwd, fsuid);",
          "398:         perror_msg(\"Can't truncate '%s' at '%s' to size 0\", core_basename, user_pwd);",
          "399:         unlinkat(dirfd(proc_cwd), core_basename, /*unlink file*/0);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "466:     if (dd)",
          "467:         dd_delete(dd);",
          "468:     if (user_core_fd >= 0)",
          "473:     errno = sv_errno;",
          "474:     perror_msg_and_die(\"Can't open '%s'\", filename);",
          "475: }",
          "",
          "[Removed Lines]",
          "469:     {",
          "470:         xchdir(user_pwd);",
          "471:         unlink(core_basename);",
          "472:     }",
          "",
          "[Added Lines]",
          "466:         unlinkat(dirfd(proc_cwd), core_basename, /*unlink file*/0);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "573:                         (long)pid, executable);",
          "574:     }",
          "577:     log_notice(\"user_pwd:'%s'\", user_pwd);",
          "579:     sprintf(path, \"/proc/%lu/status\", (long)pid);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "571:     user_pwd = get_cwd(pid);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "672:             error_msg_and_die(\"Error saving '%s'\", path);",
          "673:         }",
          "674:         log(\"Saved core dump of pid %lu (%s) to %s (%llu bytes)\", (long)pid, executable, path, (long long)core_size);",
          "675:         return 0;",
          "676:     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "670:         if (proc_cwd != NULL)",
          "671:             closedir(proc_cwd);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "791:             unlink(path);",
          "792:             dd_delete(dd);",
          "793:             if (user_core_fd >= 0)",
          "800:             error_msg_and_die(\"Error writing '%s'\", path);",
          "",
          "[Removed Lines]",
          "794:             {",
          "795:                 xchdir(user_pwd);",
          "796:                 unlink(core_basename);",
          "797:             }",
          "",
          "[Added Lines]",
          "791:                 unlinkat(dirfd(proc_cwd), core_basename, /*unlink file*/0);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "807:             )",
          "808:         ) {",
          "812:         }",
          "",
          "[Removed Lines]",
          "810:             xchdir(user_pwd);",
          "811:             unlink(core_basename);",
          "",
          "[Added Lines]",
          "804:             unlinkat(dirfd(proc_cwd), core_basename, /*unlink file*/0);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "879:         }",
          "881:         free(rootdir);",
          "882:         return 0;",
          "883:     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "875:         if (proc_cwd != NULL)",
          "876:             closedir(proc_cwd);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "890:         if (fsync(user_core_fd) != 0 || close(user_core_fd) != 0 || core_size < 0)",
          "891:         {",
          "896:             return 1;",
          "897:         }",
          "898:         if (ulimit_c == 0 || core_size > ulimit_c)",
          "899:         {",
          "902:             return 1;",
          "903:         }",
          "905:     }",
          "907:     return 0;",
          "908: }",
          "",
          "[Removed Lines]",
          "893:             perror_msg(\"Error writing '%s'\", full_core_basename);",
          "894:             xchdir(user_pwd);",
          "895:             unlink(core_basename);",
          "900:             xchdir(user_pwd);",
          "901:             unlink(core_basename);",
          "904:         log(\"Saved core dump of pid %lu to %s (%llu bytes)\", (long)pid, full_core_basename, (long long)core_size);",
          "",
          "[Added Lines]",
          "888:             perror_msg(\"Error writing '%s' at '%s'\", core_basename, user_pwd);",
          "889:             unlinkat(dirfd(proc_cwd), core_basename, /*unlink file*/0);",
          "890:             if (proc_cwd != NULL)",
          "891:                 closedir(proc_cwd);",
          "896:             unlinkat(dirfd(proc_cwd), core_basename, /*unlink file*/0);",
          "897:             if (proc_cwd != NULL)",
          "898:                 closedir(proc_cwd);",
          "901:         log(\"Saved core dump of pid %lu to %s at %s (%llu bytes)\", (long)pid, core_basename, user_pwd, (long long)core_size);",
          "904:     if (proc_cwd != NULL)",
          "905:         closedir(proc_cwd);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "2f0a18b499b9b0e1afbdab8a8bb31d38f2acc6d8",
      "candidate_info": {
        "commit_hash": "2f0a18b499b9b0e1afbdab8a8bb31d38f2acc6d8",
        "repo": "abrt/abrt",
        "commit_url": "https://github.com/abrt/abrt/commit/2f0a18b499b9b0e1afbdab8a8bb31d38f2acc6d8",
        "files": [
          "configure.ac",
          "src/hooks/Makefile.am",
          "src/hooks/abrt-hook-ccpp.c"
        ],
        "message": "ccpp: emulate selinux for creation of compat cores\n\nThis issue was discovered by Florian Weimer of Red Hat Product Security.\n\nhttp://article.gmane.org/gmane.comp.security.selinux/21842\n\nv2: use the _raw interface and do the preparation steps as root\nv3: don't fail if SELinux is disabled\n    https://github.com/abrt/abrt/commit/c4f06d4198658c82550e93bb2617b96022c06cf4#commitcomment-11021276\n\nSigned-off-by: Jakub Filak <jfilak@redhat.com>",
        "before_after_code_files": [
          "configure.ac||configure.ac",
          "src/hooks/Makefile.am||src/hooks/Makefile.am",
          "src/hooks/abrt-hook-ccpp.c||src/hooks/abrt-hook-ccpp.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/abrt/abrt/pull/950"
        ],
        "olp_code_files": {
          "patch": [
            "src/hooks/abrt-hook-ccpp.c||src/hooks/abrt-hook-ccpp.c"
          ],
          "candidate": [
            "src/hooks/abrt-hook-ccpp.c||src/hooks/abrt-hook-ccpp.c"
          ]
        }
      },
      "candidate_diff": {
        "configure.ac||configure.ac": [
          "File: configure.ac -> configure.ac",
          "--- Hunk 1 ---",
          "[Context before]",
          "106: PKG_CHECK_MODULES([POLKIT], [polkit-gobject-1])",
          "107: PKG_CHECK_MODULES([GIO], [gio-2.0])",
          "108: PKG_CHECK_MODULES([SATYR], [satyr])",
          "110: PKG_PROG_PKG_CONFIG",
          "111: AC_ARG_WITH([systemdsystemunitdir],",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "109: PKG_CHECK_MODULES([LIBSELINUX], [libselinux])",
          "",
          "---------------"
        ],
        "src/hooks/Makefile.am||src/hooks/Makefile.am": [
          "File: src/hooks/Makefile.am -> src/hooks/Makefile.am",
          "--- Hunk 1 ---",
          "[Context before]",
          "33:     -DDEFAULT_DUMP_DIR_MODE=$(DEFAULT_DUMP_DIR_MODE) \\",
          "34:     $(GLIB_CFLAGS) \\",
          "35:     $(LIBREPORT_CFLAGS) \\",
          "36:     -D_GNU_SOURCE",
          "37: abrt_hook_ccpp_LDADD = \\",
          "38:     ../lib/libabrt.la \\",
          "41: # abrt-merge-pstoreoops",
          "42: abrt_merge_pstoreoops_SOURCES = \\",
          "",
          "[Removed Lines]",
          "39:     $(LIBREPORT_LIBS)",
          "",
          "[Added Lines]",
          "36:     $(LIBSELINUX_CFLAGS) \\",
          "40:     $(LIBREPORT_LIBS) \\",
          "41:     $(LIBSELINUX_LIBS)",
          "",
          "---------------"
        ],
        "src/hooks/abrt-hook-ccpp.c||src/hooks/abrt-hook-ccpp.c": [
          "File: src/hooks/abrt-hook-ccpp.c -> src/hooks/abrt-hook-ccpp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "21: #include <sys/utsname.h>",
          "22: #include \"libabrt.h\"",
          "24: #define  DUMP_SUID_UNSAFE 1",
          "25: #define  DUMP_SUID_SAFE 2",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "23: #include <selinux/selinux.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "286:     return suid_dump_policy;",
          "287: }",
          "289: static int open_user_core(uid_t uid, uid_t fsuid, pid_t pid, char **percent_values)",
          "290: {",
          "291:     proc_cwd = open_cwd(pid);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "297: static int compute_selinux_con_for_new_file(pid_t pid, int dir_fd, security_context_t *newcon)",
          "298: {",
          "299:     security_context_t srccon;",
          "300:     security_context_t dstcon;",
          "302:     const int r = is_selinux_enabled();",
          "303:     if (r == 0)",
          "304:     {",
          "306:         return 1;",
          "307:     }",
          "308:     else if (r == -1)",
          "309:     {",
          "310:         perror_msg(\"Couldn't get state of SELinux\");",
          "311:         return -1;",
          "312:     }",
          "313:     else if (r != 1)",
          "314:         error_msg_and_die(\"Unexpected SELinux return value: %d\", r);",
          "317:     if (getpidcon_raw(pid, &srccon) < 0)",
          "318:     {",
          "319:         perror_msg(\"getpidcon_raw(%d)\", pid);",
          "320:         return -1;",
          "321:     }",
          "323:     if (fgetfilecon_raw(dir_fd, &dstcon) < 0)",
          "324:     {",
          "325:         perror_msg(\"getfilecon_raw(%s)\", user_pwd);",
          "326:         return -1;",
          "327:     }",
          "329:     if (security_compute_create_raw(srccon, dstcon, string_to_security_class(\"file\"), newcon) < 0)",
          "330:     {",
          "331:         perror_msg(\"security_compute_create_raw(%s, %s, 'file')\", srccon, dstcon);",
          "332:         return -1;",
          "333:     }",
          "335:     return 0;",
          "336: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "295:     errno = 0;",
          "297:     xsetegid(get_fsgid());",
          "298:     xseteuid(fsuid);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "347:     security_context_t newcon;",
          "348:     if (compute_selinux_con_for_new_file(pid, dirfd(proc_cwd), &newcon) < 0)",
          "349:     {",
          "350:         log_notice(\"Not going to create a user core due to SELinux errors\");",
          "351:         return -1;",
          "352:     }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "391:     struct stat sb;",
          "392:     errno = 0;",
          "395:     xsetegid(0);",
          "396:     xseteuid(0);",
          "397:     if (user_core_fd < 0",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "450:     if (newcon != NULL && setfscreatecon_raw(newcon) < 0)",
          "451:     {",
          "452:         perror_msg(\"setfscreatecon_raw(%s)\", newcon);",
          "453:         return -1;",
          "454:     }",
          "461:     if (newcon != NULL && setfscreatecon_raw(NULL) < 0)",
          "462:     {",
          "463:         error_msg(\"setfscreatecon_raw(NULL)\");",
          "464:         goto user_core_fail;",
          "465:     }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "404:             perror_msg(\"Can't open '%s' at '%s'\", core_basename, user_pwd);",
          "405:         else",
          "406:             perror_msg(\"'%s' at '%s' is not a regular file with link count 1 owned by UID(%d)\", core_basename, user_pwd, fsuid);",
          "408:     }",
          "409:     if (ftruncate(user_core_fd, 0) != 0) {",
          "411:         perror_msg(\"Can't truncate '%s' at '%s' to size 0\", core_basename, user_pwd);",
          "414:     }",
          "416:     return user_core_fd;",
          "417: }",
          "419: static bool dump_fd_info(const char *dest_filename, char *source_filename, int source_base_ofs, uid_t uid, gid_t gid)",
          "",
          "[Removed Lines]",
          "407:         return -1;",
          "412:         unlinkat(dirfd(proc_cwd), core_basename, /*unlink file*/0);",
          "413:         return -1;",
          "",
          "[Added Lines]",
          "479:         goto user_core_fail;",
          "484:         goto user_core_fail;",
          "489: user_core_fail:",
          "490:     if (user_core_fd >= 0)",
          "491:     {",
          "492:         close(user_core_fd);",
          "493:         unlinkat(dirfd(proc_cwd), core_basename, /*unlink file*/0);",
          "494:     }",
          "495:     return -1;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "c796c76341ee846cfb897ed645bac211d7d0a932",
      "candidate_info": {
        "commit_hash": "c796c76341ee846cfb897ed645bac211d7d0a932",
        "repo": "abrt/abrt",
        "commit_url": "https://github.com/abrt/abrt/commit/c796c76341ee846cfb897ed645bac211d7d0a932",
        "files": [
          "src/daemon/abrt-server.c"
        ],
        "message": "daemon: use libreport's function checking file name\n\nMove the functions to libreport because we need the same functionality\nthere too.\n\nRelated: #1214451\n\nSigned-off-by: Jakub Filak <jfilak@redhat.com>",
        "before_after_code_files": [
          "src/daemon/abrt-server.c||src/daemon/abrt-server.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/abrt/abrt/pull/950"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/daemon/abrt-server.c||src/daemon/abrt-server.c": [
          "File: src/daemon/abrt-server.c -> src/daemon/abrt-server.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "476:     exit(0);",
          "477: }",
          "495: static gboolean key_value_ok(gchar *key, gchar *value)",
          "496: {",
          "497:     char *i;",
          "",
          "[Removed Lines]",
          "480: static gboolean printable_str(const char *str)",
          "481: {",
          "482:     do {",
          "483:         if ((unsigned char)(*str) < ' ' || *str == 0x7f)",
          "484:             return FALSE;",
          "485:         str++;",
          "486:     } while (*str);",
          "487:     return TRUE;",
          "488: }",
          "490: static gboolean is_correct_filename(const char *value)",
          "491: {",
          "492:     return printable_str(value) && !strchr(value, '/') && !strchr(value, '.');",
          "493: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "510:      || strcmp(key, FILENAME_TYPE) == 0",
          "511:     )",
          "512:     {",
          "514:         {",
          "515:             error_msg(\"Value of '%s' ('%s') is not a valid directory name\",",
          "516:                       key, value);",
          "",
          "[Removed Lines]",
          "513:         if (!is_correct_filename(value))",
          "",
          "[Added Lines]",
          "497:         if (!str_is_correct_filename(value))",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "6e811d78e2719988ae291181f5b133af32ce62d8",
      "candidate_info": {
        "commit_hash": "6e811d78e2719988ae291181f5b133af32ce62d8",
        "repo": "abrt/abrt",
        "commit_url": "https://github.com/abrt/abrt/commit/6e811d78e2719988ae291181f5b133af32ce62d8",
        "files": [
          "src/dbus/abrt-dbus.c"
        ],
        "message": "dbus: process only valid sub-directories of the dump location\n\nMust have correct rights and must be a direct sub-directory of the dump\nlocation.\n\nThis issue was discovered by Florian Weimer of Red Hat Product Security.\n\nRelated: #1214451\n\nSigned-off-by: Jakub Filak <jfilak@redhat.com>",
        "before_after_code_files": [
          "src/dbus/abrt-dbus.c||src/dbus/abrt-dbus.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/abrt/abrt/pull/950"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/dbus/abrt-dbus.c||src/dbus/abrt-dbus.c": [
          "File: src/dbus/abrt-dbus.c -> src/dbus/abrt-dbus.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "132:     return caller_uid;",
          "133: }",
          "136: {",
          "138: #if 0",
          "147:         return false;",
          "148:     }",
          "149: #endif",
          "",
          "[Removed Lines]",
          "135: static bool allowed_problem_dir(const char *dir_name)",
          "139:     unsigned len = strlen(g_settings_dump_location);",
          "142:     if (strncmp(dir_name, g_settings_dump_location, len) != 0",
          "143:      || (dir_name[len] != '/' && dir_name[len] != '\\0')",
          "145:      || strstr(dir_name + len, \"/.\")",
          "146:     ) {",
          "",
          "[Added Lines]",
          "135: bool allowed_problem_dir(const char *dir_name)",
          "137:     if (!dir_is_in_dump_location(dir_name))",
          "138:     {",
          "139:         error_msg(\"Bad problem directory name '%s', should start with: '%s'\", dir_name, g_settings_dump_location);",
          "140:         return false;",
          "141:     }",
          "160:     if (!dir_has_correct_permissions(dir_name))",
          "161:     {",
          "162:         error_msg(\"Problem directory '%s' isn't owned by root:abrt or others are not restricted from access\", dir_name);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b7f8bd20b7fb5b72f003ae3fa647c1d75f4218b7",
      "candidate_info": {
        "commit_hash": "b7f8bd20b7fb5b72f003ae3fa647c1d75f4218b7",
        "repo": "abrt/abrt",
        "commit_url": "https://github.com/abrt/abrt/commit/b7f8bd20b7fb5b72f003ae3fa647c1d75f4218b7",
        "files": [
          "src/daemon/abrt-server.c",
          "src/include/libabrt.h",
          "src/lib/hooklib.c",
          "tests/Makefile.am",
          "tests/hooklib.at",
          "tests/testsuite.at"
        ],
        "message": "lib: add functions validating dump dir\n\nMove the code from abrt-server to shared library and fix the condition\nvalidating dump dir's path.\n\nAs of now, abrt is allowed to process only direct sub-directories of the\ndump locations.\n\nSigned-off-by: Jakub Filak <jfilak@redhat.com>",
        "before_after_code_files": [
          "src/daemon/abrt-server.c||src/daemon/abrt-server.c",
          "src/include/libabrt.h||src/include/libabrt.h",
          "src/lib/hooklib.c||src/lib/hooklib.c",
          "tests/Makefile.am||tests/Makefile.am",
          "tests/hooklib.at||tests/hooklib.at",
          "tests/testsuite.at||tests/testsuite.at"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/abrt/abrt/pull/950"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/daemon/abrt-server.c||src/daemon/abrt-server.c": [
          "File: src/daemon/abrt-server.c -> src/daemon/abrt-server.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "76: static uid_t client_uid = (uid_t)-1L;",
          "94: static int delete_path(const char *dump_dir_name)",
          "95: {",
          "",
          "[Removed Lines]",
          "79: static bool dir_is_in_dump_location(const char *dump_dir_name)",
          "80: {",
          "81:     unsigned len = strlen(g_settings_dump_location);",
          "83:     if (strncmp(dump_dir_name, g_settings_dump_location, len) == 0",
          "84:      && dump_dir_name[len] == '/'",
          "86:      && !strstr(dump_dir_name + len, \"/.\")",
          "87:     ) {",
          "88:         return 1;",
          "89:     }",
          "90:     return 0;",
          "91: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "100:         error_msg(\"Bad problem directory name '%s', should start with: '%s'\", dump_dir_name, g_settings_dump_location);",
          "102:     }",
          "103:     if (!dump_dir_accessible_by_uid(dump_dir_name, client_uid))",
          "104:     {",
          "105:         if (errno == ENOTDIR)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "89:     if (!dir_has_correct_permissions(dump_dir_name))",
          "90:     {",
          "91:         error_msg(\"Problem directory '%s' isn't owned by root:abrt or others are not restricted from access\", dump_dir_name);",
          "93:     }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "154:         error_msg(\"Bad problem directory name '%s', should start with: '%s'\", dirname, g_settings_dump_location);",
          "156:     }",
          "157:     if (g_settings_privatereports)",
          "158:     {",
          "177:         struct dump_dir *dd = dd_opendir(dirname, DD_OPEN_READONLY);",
          "178:         const bool complete = dd && problem_dump_dir_is_complete(dd);",
          "179:         dd_close(dd);",
          "",
          "[Removed Lines]",
          "159:         struct stat statbuf;",
          "160:         if (lstat(dirname, &statbuf) != 0 || !S_ISDIR(statbuf.st_mode))",
          "161:         {",
          "162:             error_msg(\"Path '%s' isn't directory\", dirname);",
          "164:         }",
          "166:         struct group *gr = getgrnam(\"abrt\");",
          "167:         if (!gr)",
          "168:         {",
          "169:             error_msg(\"Group 'abrt' does not exist\");",
          "170:             return 500;",
          "171:         }",
          "172:         if (statbuf.st_uid != 0 || !(statbuf.st_gid == 0 || statbuf.st_gid == gr->gr_gid) || statbuf.st_mode & 07)",
          "173:         {",
          "174:             error_msg(\"Problem directory '%s' isn't owned by root:abrt or others are not restricted from access\", dirname);",
          "175:             return 403;",
          "176:         }",
          "",
          "[Added Lines]",
          "148:     if (!dir_has_correct_permissions(dirname))",
          "149:     {",
          "150:         error_msg(\"Problem directory '%s' isn't owned by root:abrt or others are not restricted from access\", dirname);",
          "152:     }",
          "",
          "---------------"
        ],
        "src/include/libabrt.h||src/include/libabrt.h": [
          "File: src/include/libabrt.h -> src/include/libabrt.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "47: #define get_backtrace abrt_get_backtrace",
          "48: char *get_backtrace(const char *dump_dir_name, unsigned timeout_sec, const char *debuginfo_dirs);",
          "51: #define g_settings_nMaxCrashReportsSize abrt_g_settings_nMaxCrashReportsSize",
          "52: extern unsigned int  g_settings_nMaxCrashReportsSize;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "50: #define dir_is_in_dump_location abrt_dir_is_in_dump_location",
          "51: bool dir_is_in_dump_location(const char *dir_name);",
          "52: #define dir_has_correct_permissions abrt_dir_has_correct_permissions",
          "53: bool dir_has_correct_permissions(const char *dir_name);",
          "",
          "---------------"
        ],
        "src/lib/hooklib.c||src/lib/hooklib.c": [
          "File: src/lib/hooklib.c -> src/lib/hooklib.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "427:     log_info(\"problem id: '%s'\", problem_id);",
          "428:     return problem_id;",
          "429: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "431: bool dir_is_in_dump_location(const char *dir_name)",
          "432: {",
          "433:     unsigned len = strlen(g_settings_dump_location);",
          "436:     if (strncmp(dir_name, g_settings_dump_location, len) != 0)",
          "437:     {",
          "438:         log_debug(\"Bad parent directory: '%s' not in '%s'\", g_settings_dump_location, dir_name);",
          "439:         return false;",
          "440:     }",
          "443:     const char *base_name = dir_name + len;",
          "444:     while (*base_name && *base_name == '/')",
          "445:         ++base_name;",
          "447:     if (*(base_name - 1) != '/' || !str_is_correct_filename(base_name))",
          "448:     {",
          "449:         log_debug(\"Invalid dump directory name: '%s'\", base_name);",
          "450:         return false;",
          "451:     }",
          "454:     struct stat sb;",
          "455:     if (lstat(dir_name, &sb) < 0)",
          "456:     {",
          "457:         VERB2 perror_msg(\"stat('%s')\", dir_name);",
          "458:         return errno== ENOENT;",
          "459:     }",
          "461:     return S_ISDIR(sb.st_mode);",
          "462: }",
          "464: bool dir_has_correct_permissions(const char *dir_name)",
          "465: {",
          "466:     if (g_settings_privatereports)",
          "467:     {",
          "468:         struct stat statbuf;",
          "469:         if (lstat(dir_name, &statbuf) != 0 || !S_ISDIR(statbuf.st_mode))",
          "470:         {",
          "471:             error_msg(\"Path '%s' isn't directory\", dir_name);",
          "472:             return false;",
          "473:         }",
          "475:         struct group *gr = getgrnam(\"abrt\");",
          "476:         if (!gr)",
          "477:         {",
          "478:             error_msg(\"Group 'abrt' does not exist\");",
          "479:             return false;",
          "480:         }",
          "481:         if (statbuf.st_uid != 0 || !(statbuf.st_gid == 0 || statbuf.st_gid == gr->gr_gid) || statbuf.st_mode & 07)",
          "482:             return false;",
          "483:     }",
          "484:     return true;",
          "485: }",
          "",
          "---------------"
        ],
        "tests/Makefile.am||tests/Makefile.am": [
          "File: tests/Makefile.am -> tests/Makefile.am",
          "--- Hunk 1 ---",
          "[Context before]",
          "29:   testsuite.at \\",
          "30:   pyhook.at \\",
          "31:   koops-parser.at \\",
          "34: EXTRA_DIST += $(TESTSUITE_AT)",
          "35: TESTSUITE = $(srcdir)/testsuite",
          "",
          "[Removed Lines]",
          "32:   ignored_problems.at",
          "",
          "[Added Lines]",
          "32:   ignored_problems.at \\",
          "33:   hooklib.at",
          "",
          "---------------"
        ],
        "tests/hooklib.at||tests/hooklib.at": [
          "File: tests/hooklib.at -> tests/hooklib.at",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: # -*- Autotest -*-",
          "3: AT_BANNER([hooklib])",
          "5: AT_TESTFUN([dir_is_in_dump_location],",
          "6: [[",
          "7: #include \"libabrt.h\"",
          "8: #include <assert.h>",
          "10: void test(char *name, bool expected)",
          "11: {",
          "12:     if (dir_is_in_dump_location(name) != expected)",
          "13:     {",
          "14:         fprintf(stderr, \"Bad: %s\", name);",
          "15:         abort();",
          "16:     }",
          "18:     free(name);",
          "19: }",
          "21: int main(void)",
          "22: {",
          "23:     g_verbose = 3;",
          "24:     load_abrt_conf();",
          "26:     g_verbose = 3;",
          "28:     char *name;",
          "30:     assert(dir_is_in_dump_location(\"/\") == false);",
          "32:     asprintf(&name, \"%s\", g_settings_dump_location);",
          "33:     test(name, false);",
          "35:     asprintf(&name, \"%s..evil\", g_settings_dump_location);",
          "36:     test(name, false);",
          "38:     asprintf(&name, \"%s/\", g_settings_dump_location);",
          "39:     test(name, false);",
          "41:     asprintf(&name, \"%s///\", g_settings_dump_location);",
          "42:     test(name, false);",
          "44:     asprintf(&name, \"%s/.\", g_settings_dump_location);",
          "45:     test(name, false);",
          "47:     asprintf(&name, \"%s///.\", g_settings_dump_location);",
          "48:     test(name, false);",
          "50:     asprintf(&name, \"%s/./\", g_settings_dump_location);",
          "51:     test(name, false);",
          "53:     asprintf(&name, \"%s/.///\", g_settings_dump_location);",
          "54:     test(name, false);",
          "56:     asprintf(&name, \"%s/..\", g_settings_dump_location);",
          "57:     test(name, false);",
          "59:     asprintf(&name, \"%s///..\", g_settings_dump_location);",
          "60:     test(name, false);",
          "62:     asprintf(&name, \"%s/../\", g_settings_dump_location);",
          "63:     test(name, false);",
          "65:     asprintf(&name, \"%s/..///\", g_settings_dump_location);",
          "66:     test(name, false);",
          "68:     asprintf(&name, \"%s/good/../../../evil\", g_settings_dump_location);",
          "69:     test(name, false);",
          "71:     asprintf(&name, \"%s/good..still\", g_settings_dump_location);",
          "72:     test(name, true);",
          "74:     asprintf(&name, \"%s/good.new\", g_settings_dump_location);",
          "75:     test(name, true);",
          "77:     asprintf(&name, \"%s/.meta\", g_settings_dump_location);",
          "78:     test(name, true);",
          "80:     asprintf(&name, \"%s/..data\", g_settings_dump_location);",
          "81:     test(name, true);",
          "83:     return 0;",
          "84: }",
          "85: ]])",
          "",
          "---------------"
        ],
        "tests/testsuite.at||tests/testsuite.at": [
          "File: tests/testsuite.at -> tests/testsuite.at",
          "--- Hunk 1 ---",
          "[Context before]",
          "4: m4_include([koops-parser.at])",
          "5: m4_include([pyhook.at])",
          "6: m4_include([ignored_problems.at])",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "7: m4_include([hooklib.at])",
          "",
          "---------------"
        ]
      }
    }
  ]
}
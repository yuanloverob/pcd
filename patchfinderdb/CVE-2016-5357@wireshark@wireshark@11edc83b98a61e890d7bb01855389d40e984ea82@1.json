{
  "cve_id": "CVE-2016-5357",
  "cve_desc": "wiretap/netscreen.c in the NetScreen file parser in Wireshark 1.12.x before 1.12.12 and 2.x before 2.0.4 mishandles sscanf unsigned-integer processing, which allows remote attackers to cause a denial of service (application crash) via a crafted file.",
  "repo": "wireshark/wireshark",
  "patch_hash": "11edc83b98a61e890d7bb01855389d40e984ea82",
  "patch_info": {
    "commit_hash": "11edc83b98a61e890d7bb01855389d40e984ea82",
    "repo": "wireshark/wireshark",
    "commit_url": "https://github.com/wireshark/wireshark/commit/11edc83b98a61e890d7bb01855389d40e984ea82",
    "files": [
      "wiretap/netscreen.c"
    ],
    "message": "Don't treat the packet length as unsigned.\n\nThe scanf family of functions are as annoyingly bad at handling unsigned\nnumbers as strtoul() is - both of them are perfectly willing to accept a\nvalue beginning with a negative sign as an unsigned value.  When using\nstrtoul(), you can compensate for this by explicitly checking for a '-'\nas the first character of the string, but you can't do that with\nsscanf().\n\nSo revert to having pkt_len be signed, and scanning it with %d, but\ncheck for a negative value and fail if we see a negative value.\n\nBug: 12396\nChange-Id: I54fe8f61f42c32b5ef33da633ece51bbcda8c95f\nReviewed-on: https://code.wireshark.org/review/15220\nReviewed-by: Guy Harris <guy@alum.mit.edu>",
    "before_after_code_files": [
      "wiretap/netscreen.c||wiretap/netscreen.c"
    ]
  },
  "patch_diff": {
    "wiretap/netscreen.c||wiretap/netscreen.c": [
      "File: wiretap/netscreen.c -> wiretap/netscreen.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "263: parse_netscreen_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer* buf,",
      "264:     char *line, int *err, gchar **err_info)",
      "265: {",
      "266:  int  sec;",
      "267:  int  dsec;",
      "268:  char  cap_int[NETSCREEN_MAX_INT_NAME_LENGTH];",
      "269:  char  direction[2];",
      "271:  char  cap_src[13];",
      "272:  char  cap_dst[13];",
      "273:  guint8  *pd;",
      "274:  gchar  *p;",
      "275:  int  n, i = 0;",
      "277:  gchar  dststr[13];",
      "279:  phdr->rec_type = REC_TYPE_PACKET;",
      "280:  phdr->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;",
      "283:      &sec, &dsec, cap_int, direction, &pkt_len, cap_src, cap_dst) < 5) {",
      "286:   return -1;",
      "287:  }",
      "288:  if (pkt_len > WTAP_MAX_PACKET_SIZE) {",
      "",
      "[Removed Lines]",
      "270:  guint  pkt_len;",
      "276:  guint  offset = 0;",
      "282:  if (sscanf(line, \"%9d.%9d: %15[a-z0-9/:.-](%1[io]) len=%9u:%12s->%12s/\",",
      "",
      "[Added Lines]",
      "266:  int  pkt_len;",
      "276:  int  offset = 0;",
      "282:  if (sscanf(line, \"%9d.%9d: %15[a-z0-9/:.-](%1[io]) len=%9d:%12s->%12s/\",",
      "288:  if (pkt_len < 0) {",
      "291:   return FALSE;",
      "292:  }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "2916518b76dd4bdad50fc5ecc9790b741aa2dd08",
      "candidate_info": {
        "commit_hash": "2916518b76dd4bdad50fc5ecc9790b741aa2dd08",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/2916518b76dd4bdad50fc5ecc9790b741aa2dd08",
        "files": [
          "wiretap/netscreen.c"
        ],
        "message": "Don't treat the packet length as unsigned.\n\nThe scanf family of functions are as annoyingly bad at handling unsigned\nnumbers as strtoul() is - both of them are perfectly willing to accept a\nvalue beginning with a negative sign as an unsigned value.  When using\nstrtoul(), you can compensate for this by explicitly checking for a '-'\nas the first character of the string, but you can't do that with\nsscanf().\n\nSo revert to having pkt_len be signed, and scanning it with %d, but\ncheck for a negative value and fail if we see a negative value.\n\nBug: 12396\nChange-Id: I54fe8f61f42c32b5ef33da633ece51bbcda8c95f\nReviewed-on: https://code.wireshark.org/review/15220\nReviewed-by: Guy Harris <guy@alum.mit.edu>\n(cherry picked from commit 11edc83b98a61e890d7bb01855389d40e984ea82)\nReviewed-on: https://code.wireshark.org/review/15221",
        "before_after_code_files": [
          "wiretap/netscreen.c||wiretap/netscreen.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "wiretap/netscreen.c||wiretap/netscreen.c"
          ],
          "candidate": [
            "wiretap/netscreen.c||wiretap/netscreen.c"
          ]
        }
      },
      "candidate_diff": {
        "wiretap/netscreen.c||wiretap/netscreen.c": [
          "File: wiretap/netscreen.c -> wiretap/netscreen.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "263: parse_netscreen_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer* buf,",
          "264:     char *line, int *err, gchar **err_info)",
          "265: {",
          "266:  int  sec;",
          "267:  int  dsec;",
          "268:  char  cap_int[NETSCREEN_MAX_INT_NAME_LENGTH];",
          "269:  char  direction[2];",
          "271:  char  cap_src[13];",
          "272:  char  cap_dst[13];",
          "273:  guint8  *pd;",
          "274:  gchar  *p;",
          "275:  int  n, i = 0;",
          "277:  gchar  dststr[13];",
          "279:  phdr->rec_type = REC_TYPE_PACKET;",
          "280:  phdr->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;",
          "283:      &sec, &dsec, cap_int, direction, &pkt_len, cap_src, cap_dst) < 5) {",
          "286:   return -1;",
          "287:  }",
          "288:  if (pkt_len > WTAP_MAX_PACKET_SIZE) {",
          "",
          "[Removed Lines]",
          "270:  guint  pkt_len;",
          "276:  guint  offset = 0;",
          "282:  if (sscanf(line, \"%9d.%9d: %15[a-z0-9/:.-](%1[io]) len=%9u:%12s->%12s/\",",
          "",
          "[Added Lines]",
          "266:  int  pkt_len;",
          "276:  int  offset = 0;",
          "282:  if (sscanf(line, \"%9d.%9d: %15[a-z0-9/:.-](%1[io]) len=%9d:%12s->%12s/\",",
          "288:  if (pkt_len < 0) {",
          "291:   return FALSE;",
          "292:  }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "6a140eca7b78b230f1f90a739a32257476513c78",
      "candidate_info": {
        "commit_hash": "6a140eca7b78b230f1f90a739a32257476513c78",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/6a140eca7b78b230f1f90a739a32257476513c78",
        "files": [
          "wiretap/netscreen.c",
          "wiretap/netscreen.h"
        ],
        "message": "Fix packet length handling.\n\nTreat the packet length as unsigned - it shouldn't be negative in the\nfile.  If it is, that'll probably cause the sscanf to fail, so we'll\nreport the file as bad.\n\nCheck it against WTAP_MAX_PACKET_SIZE to make sure we don't try to\nallocate a huge amount of memory, just as we do in other file readers.\n\nUse the now-validated packet size as the length in\nws_buffer_assure_space(), so we are certain to have enough space, and\ndon't allocate too much space.\n\nMerge the header and packet data parsing routines while we're at it.\n\nBug: 12396\nChange-Id: I7f981f9cdcbea7ecdeb88bfff2f12d875de2244f\nReviewed-on: https://code.wireshark.org/review/15176\nReviewed-by: Guy Harris <guy@alum.mit.edu>",
        "before_after_code_files": [
          "wiretap/netscreen.c||wiretap/netscreen.c",
          "wiretap/netscreen.h||wiretap/netscreen.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "wiretap/netscreen.c||wiretap/netscreen.c"
          ],
          "candidate": [
            "wiretap/netscreen.c||wiretap/netscreen.c"
          ]
        }
      },
      "candidate_diff": {
        "wiretap/netscreen.c||wiretap/netscreen.c": [
          "File: wiretap/netscreen.c -> wiretap/netscreen.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "69: static gboolean netscreen_seek_read(wtap *wth, gint64 seek_off,",
          "70:  struct wtap_pkthdr *phdr, Buffer *buf,",
          "71:  int *err, gchar **err_info);",
          "78: static int parse_single_hex_dump_line(char* rec, guint8 *buf,",
          "79:  guint byte_offset);",
          "",
          "[Removed Lines]",
          "72: static int parse_netscreen_rec_hdr(struct wtap_pkthdr *phdr, const char *line,",
          "73:  char *cap_int, gboolean *cap_dir, char *cap_dst,",
          "74:  int *err, gchar **err_info);",
          "75: static gboolean parse_netscreen_hex_dump(FILE_T fh, int pkt_len,",
          "76:  const char *cap_int, const char *cap_dst, struct wtap_pkthdr *phdr,",
          "77:  Buffer* buf, int *err, gchar **err_info);",
          "",
          "[Added Lines]",
          "72: static gboolean parse_netscreen_packet(FILE_T fh, struct wtap_pkthdr *phdr,",
          "73:  Buffer* buf, char *line, int *err, gchar **err_info);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "191:     gint64 *data_offset)",
          "192: {",
          "193:  gint64  offset;",
          "195:  char  line[NETSCREEN_LINE_LENGTH];",
          "201:  offset = netscreen_seek_next_packet(wth, err, err_info, line);",
          "202:  if (offset < 0)",
          "203:   return FALSE;",
          "215:   return FALSE;",
          "",
          "[Removed Lines]",
          "194:  int  pkt_len;",
          "196:  char  cap_int[NETSCREEN_MAX_INT_NAME_LENGTH];",
          "197:  gboolean cap_dir;",
          "198:  char  cap_dst[13];",
          "206:  pkt_len = parse_netscreen_rec_hdr(&wth->phdr, line, cap_int, &cap_dir,",
          "207:      cap_dst, err, err_info);",
          "208:  if (pkt_len == -1)",
          "209:   return FALSE;",
          "213:  if (!parse_netscreen_hex_dump(wth->fh, pkt_len, cap_int,",
          "214:      cap_dst, &wth->phdr, wth->frame_buffer, err, err_info))",
          "",
          "[Added Lines]",
          "198:  if (!parse_netscreen_packet(wth->fh, &wth->phdr,",
          "199:      wth->frame_buffer, line, err, err_info))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "239:  struct wtap_pkthdr *phdr, Buffer *buf,",
          "240:  int *err, gchar **err_info)",
          "241: {",
          "243:  char  line[NETSCREEN_LINE_LENGTH];",
          "248:  if (file_seek(wth->random_fh, seek_off, SEEK_SET, err) == -1) {",
          "249:   return FALSE;",
          "",
          "[Removed Lines]",
          "242:  int  pkt_len;",
          "244:  char  cap_int[NETSCREEN_MAX_INT_NAME_LENGTH];",
          "245:  gboolean cap_dir;",
          "246:  char  cap_dst[13];",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "257:   return FALSE;",
          "258:  }",
          "269: }",
          "",
          "[Removed Lines]",
          "260:  pkt_len = parse_netscreen_rec_hdr(phdr, line, cap_int, &cap_dir,",
          "261:      cap_dst, err, err_info);",
          "262:  if (pkt_len == -1)",
          "263:   return FALSE;",
          "265:  if (!parse_netscreen_hex_dump(wth->random_fh, pkt_len, cap_int,",
          "266:      cap_dst, phdr, buf, err, err_info))",
          "267:   return FALSE;",
          "268:  return TRUE;",
          "",
          "[Added Lines]",
          "241:  return parse_netscreen_packet(wth->random_fh, phdr, buf, line,",
          "242:      err, err_info);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "291: {",
          "297:  phdr->rec_type = REC_TYPE_PACKET;",
          "298:  phdr->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;",
          "301:      &sec, &dsec, cap_int, direction, &pkt_len, cap_src, cap_dst) < 5) {",
          "304:   return -1;",
          "305:  }",
          "309:  phdr->ts.secs  = sec;",
          "310:  phdr->ts.nsecs = dsec * 100000000;",
          "311:  phdr->len = pkt_len;",
          "331:  pd = ws_buffer_start_ptr(buf);",
          "333:  while(1) {",
          "",
          "[Removed Lines]",
          "288: static int",
          "289: parse_netscreen_rec_hdr(struct wtap_pkthdr *phdr, const char *line, char *cap_int,",
          "290:     gboolean *cap_dir, char *cap_dst, int *err, gchar **err_info)",
          "292:  int sec;",
          "293:  int dsec, pkt_len;",
          "294:  char direction[2];",
          "295:  char cap_src[13];",
          "300:  if (sscanf(line, \"%9d.%9d: %15[a-z0-9/:.-](%1[io]) len=%9d:%12s->%12s/\",",
          "313:  return pkt_len;",
          "314: }",
          "318: static gboolean",
          "319: parse_netscreen_hex_dump(FILE_T fh, int pkt_len, const char *cap_int,",
          "320:     const char *cap_dst, struct wtap_pkthdr *phdr, Buffer* buf,",
          "321:     int *err, gchar **err_info)",
          "322: {",
          "323:  guint8 *pd;",
          "324:  gchar line[NETSCREEN_LINE_LENGTH];",
          "325:  gchar *p;",
          "326:  int n, i = 0, offset = 0;",
          "327:  gchar dststr[13];",
          "330:  ws_buffer_assure_space(buf, NETSCREEN_MAX_PACKET_LEN);",
          "",
          "[Added Lines]",
          "262: static gboolean",
          "263: parse_netscreen_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer* buf,",
          "264:     char *line, int *err, gchar **err_info)",
          "266:  int  sec;",
          "267:  int  dsec;",
          "268:  char  cap_int[NETSCREEN_MAX_INT_NAME_LENGTH];",
          "269:  char  direction[2];",
          "270:  guint  pkt_len;",
          "271:  char  cap_src[13];",
          "272:  char  cap_dst[13];",
          "273:  guint8  *pd;",
          "274:  gchar  *p;",
          "275:  int  n, i = 0;",
          "276:  guint  offset = 0;",
          "277:  gchar  dststr[13];",
          "282:  if (sscanf(line, \"%9d.%9d: %15[a-z0-9/:.-](%1[io]) len=%9u:%12s->%12s/\",",
          "288:  if (pkt_len > WTAP_MAX_PACKET_SIZE) {",
          "295:       pkt_len, WTAP_MAX_PACKET_SIZE);",
          "296:   return FALSE;",
          "297:  }",
          "309:  ws_buffer_assure_space(buf, pkt_len);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "379:    return FALSE;",
          "",
          "[Removed Lines]",
          "376:   if(n == -1) {",
          "",
          "[Added Lines]",
          "355:   if (n == -1) {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "391:    return FALSE;",
          "",
          "[Removed Lines]",
          "388:   if(offset > pkt_len) {",
          "",
          "[Added Lines]",
          "367:   if (offset > pkt_len) {",
          "",
          "---------------"
        ],
        "wiretap/netscreen.h||wiretap/netscreen.h": [
          "File: wiretap/netscreen.h -> wiretap/netscreen.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "46: #define NETSCREEN_INGRESS  FALSE",
          "47: #define NETSCREEN_EGRESS  TRUE",
          "52: wtap_open_return_val netscreen_open(wtap *wth, int *err, gchar **err_info);",
          "54: #endif",
          "",
          "[Removed Lines]",
          "50: #define NETSCREEN_MAX_PACKET_LEN 65536",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "1635420a4a024ac500f650bee338e389279d0704",
      "candidate_info": {
        "commit_hash": "1635420a4a024ac500f650bee338e389279d0704",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/1635420a4a024ac500f650bee338e389279d0704",
        "files": [
          "wiretap/cosine.c"
        ],
        "message": "Don't treat the packet length as unsigned.\n\nThe scanf family of functions are as annoyingly bad at handling unsigned\nnumbers as strtoul() is - both of them are perfectly willing to accept a\nvalue beginning with a negative sign as an unsigned value.  When using\nstrtoul(), you can compensate for this by explicitly checking for a '-'\nas the first character of the string, but you can't do that with\nsscanf().\n\nSo revert to having pkt_len be signed, and scanning it with %d, but\ncheck for a negative value and fail if we see a negative value.\n\nBug: 12395\nChange-Id: I43b458a73b0934e9a5c2c89d34eac5a8f21a7455\nReviewed-on: https://code.wireshark.org/review/15223\nReviewed-by: Guy Harris <guy@alum.mit.edu>\n(cherry picked from commit a66628e425db725df1ac52a3c573a03357060ddd)\nReviewed-on: https://code.wireshark.org/review/15225",
        "before_after_code_files": [
          "wiretap/cosine.c||wiretap/cosine.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_message": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "wiretap/cosine.c||wiretap/cosine.c": [
          "File: wiretap/cosine.c -> wiretap/cosine.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "332: {",
          "333:  union wtap_pseudo_header *pseudo_header = &phdr->pseudo_header;",
          "334:  int num_items_scanned;",
          "337:  int pro, off, pri, rm, error;",
          "338:  guint code1, code2;",
          "339:  char if_name[COSINE_MAX_IF_NAME_LEN] = \"\", direction[6] = \"\";",
          "",
          "[Removed Lines]",
          "335:  int yy, mm, dd, hr, min, sec, csec;",
          "336:  guint pkt_len;",
          "",
          "[Added Lines]",
          "335:  int yy, mm, dd, hr, min, sec, csec, pkt_len;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "345:      &yy, &mm, &dd, &hr, &min, &sec, &csec) == 7) {",
          "347:   num_items_scanned = sscanf(line,",
          "349:    &yy, &mm, &dd, &hr, &min, &sec, &csec,",
          "350:        direction, if_name, &pkt_len,",
          "351:        &pro, &off, &pri, &rm, &error,",
          "",
          "[Removed Lines]",
          "348:      \"%4d-%2d-%2d,%2d:%2d:%2d.%9d: %5s (%127[A-Za-z0-9/:]), Length:%9u, Pro:%9d, Off:%9d, Pri:%9d, RM:%9d, Err:%9d [%8x, %8x]\",",
          "",
          "[Added Lines]",
          "347:      \"%4d-%2d-%2d,%2d:%2d:%2d.%9d: %5s (%127[A-Za-z0-9/:]), Length:%9d, Pro:%9d, Off:%9d, Pri:%9d, RM:%9d, Err:%9d [%8x, %8x]\",",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "359:  } else {",
          "361:   num_items_scanned = sscanf(line,",
          "363:        direction, if_name, &pkt_len,",
          "364:        &pro, &off, &pri, &rm, &error,",
          "365:        &code1, &code2);",
          "",
          "[Removed Lines]",
          "362:      \"%5s (%127[A-Za-z0-9/:]), Length:%9u, Pro:%9d, Off:%9d, Pri:%9d, RM:%9d, Err:%9d [%8x, %8x]\",",
          "",
          "[Added Lines]",
          "361:      \"%5s (%127[A-Za-z0-9/:]), Length:%9d, Pro:%9d, Off:%9d, Pri:%9d, RM:%9d, Err:%9d [%8x, %8x]\",",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "371:   }",
          "372:   yy = mm = dd = hr = min = sec = csec = 0;",
          "373:  }",
          "374:  if (pkt_len > WTAP_MAX_PACKET_SIZE) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "373:  if (pkt_len < 0) {",
          "376:   return FALSE;",
          "377:  }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "edbed5a120e878725ed3ba31484045ee7e817e58",
      "candidate_info": {
        "commit_hash": "edbed5a120e878725ed3ba31484045ee7e817e58",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/edbed5a120e878725ed3ba31484045ee7e817e58",
        "files": [
          "wiretap/toshiba.c"
        ],
        "message": "Don't treat the packet length as unsigned.\n\nThe scanf family of functions are as annoyingly bad at handling unsigned\nnumbers as strtoul() is - both of them are perfectly willing to accept a\nvalue beginning with a negative sign as an unsigned value.  When using\nstrtoul(), you can compensate for this by explicitly checking for a '-'\nas the first character of the string, but you can't do that with\nsscanf().\n\nSo revert to having pkt_len be signed, and scanning it with %d, but\ncheck for a negative value and fail if we see a negative value.\n\nBug: 12394\nChange-Id: I4b19b95f2e1ffc96dac5c91bff6698c246f52007\nReviewed-on: https://code.wireshark.org/review/15230\nReviewed-by: Guy Harris <guy@alum.mit.edu>\n(cherry picked from commit 3270dfac43da861c714df76513456b46765ff47f)\nReviewed-on: https://code.wireshark.org/review/15232",
        "before_after_code_files": [
          "wiretap/toshiba.c||wiretap/toshiba.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_message": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "wiretap/toshiba.c||wiretap/toshiba.c": [
          "File: wiretap/toshiba.c -> wiretap/toshiba.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "250:  union wtap_pseudo_header *pseudo_header = &phdr->pseudo_header;",
          "251:  char line[TOSHIBA_LINE_LENGTH];",
          "252:  int num_items_scanned;",
          "255:  char channel[10], direction[10];",
          "256:  int i, hex_lines;",
          "257:  guint8 *pd;",
          "",
          "[Removed Lines]",
          "253:  guint pkt_len;",
          "254:  int pktnum, hr, min, sec, csec;",
          "",
          "[Added Lines]",
          "253:  int pkt_len, pktnum, hr, min, sec, csec;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "304:  } while (strcmp(line, \"OFFSET 0001-0203\") != 0);",
          "307:  if (num_items_scanned != 1) {",
          "310:   return FALSE;",
          "311:  }",
          "312:  if (pkt_len > WTAP_MAX_PACKET_SIZE) {",
          "",
          "[Removed Lines]",
          "306:  num_items_scanned = sscanf(line+64, \"LEN=%9u\", &pkt_len);",
          "",
          "[Added Lines]",
          "305:  num_items_scanned = sscanf(line+64, \"LEN=%9d\", &pkt_len);",
          "311:  if (pkt_len < 0) {",
          "314:   return FALSE;",
          "315:  }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "e499daadd34ae8c8598b99b8718a41ea47a3fa1e",
      "candidate_info": {
        "commit_hash": "e499daadd34ae8c8598b99b8718a41ea47a3fa1e",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/e499daadd34ae8c8598b99b8718a41ea47a3fa1e",
        "files": [
          "wiretap/dbs-etherwatch.c"
        ],
        "message": "Don't treat the packet length as unsigned.\n\nThe scanf family of functions are as annoyingly bad at handling unsigned\nnumbers as strtoul() is - both of them are perfectly willing to accept a\nvalue beginning with a negative sign as an unsigned value.  When using\nstrtoul(), you can compensate for this by explicitly checking for a '-'\nas the first character of the string, but you can't do that with\nsscanf().\n\nSo revert to having pkt_len be signed, and scanning it with %d, but\ncheck for a negative value and fail if we see a negative value.\n\nChange-Id: I6450d468504e942df72342176a0e145e5ac3db5f\nReviewed-on: https://code.wireshark.org/review/15216\nReviewed-by: Guy Harris <guy@alum.mit.edu>\n(cherry picked from commit 29c78db2a80a93653f32e4fd2f00b9b550432c43)\nReviewed-on: https://code.wireshark.org/review/15217",
        "before_after_code_files": [
          "wiretap/dbs-etherwatch.c||wiretap/dbs-etherwatch.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "diff_branch_message": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "wiretap/dbs-etherwatch.c||wiretap/dbs-etherwatch.c": [
          "File: wiretap/dbs-etherwatch.c -> wiretap/dbs-etherwatch.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "273:     guint8 *pd;",
          "274:     char    line[DBS_ETHERWATCH_LINE_LENGTH];",
          "275:     int num_items_scanned;",
          "278:     int length_pos, length_from, length;",
          "279:     struct tm tm;",
          "280:     char mon[4] = \"xxx\";",
          "281:     gchar *p;",
          "282:     static const gchar months[] = \"JANFEBMARAPRMAYJUNJULAUGSEPOCTNOVDEC\";",
          "286:     ws_buffer_assure_space(buf, DBS_ETHERWATCH_MAX_ETHERNET_PACKET_LEN);",
          "",
          "[Removed Lines]",
          "276:     int eth_hdr_len, csec;",
          "277:     guint pkt_len;",
          "283:     guint count, line_count;",
          "",
          "[Added Lines]",
          "276:     int eth_hdr_len, pkt_len, csec;",
          "282:     int count, line_count;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "351:     }",
          "353:     num_items_scanned = sscanf(line + LENGTH_POS,",
          "355:                 &pkt_len,",
          "356:                 &tm.tm_mday, mon,",
          "357:                 &tm.tm_year, &tm.tm_hour, &tm.tm_min,",
          "",
          "[Removed Lines]",
          "354:                 \"%9u byte buffer at %2d-%3s-%4d %2d:%2d:%2d.%9d\",",
          "",
          "[Added Lines]",
          "353:                 \"%9d byte buffer at %2d-%3s-%4d %2d:%2d:%2d.%9d\",",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "363:         return FALSE;",
          "364:     }",
          "367:     if(strncmp(&line[ETH_II_CHECK_POS], ETH_II_CHECK_STR,",
          "368:         strlen(ETH_II_CHECK_STR)) == 0) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "365:     if (pkt_len < 0) {",
          "368:         return FALSE;",
          "369:     }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
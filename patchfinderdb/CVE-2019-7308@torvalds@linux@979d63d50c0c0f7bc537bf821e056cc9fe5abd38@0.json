{
  "cve_id": "CVE-2019-7308",
  "cve_desc": "kernel/bpf/verifier.c in the Linux kernel before 4.20.6 performs undesirable out-of-bounds speculation on pointer arithmetic in various cases, including cases of different branches with different state or limits to sanitize, leading to side-channel attacks.",
  "repo": "torvalds/linux",
  "patch_hash": "979d63d50c0c0f7bc537bf821e056cc9fe5abd38",
  "patch_info": {
    "commit_hash": "979d63d50c0c0f7bc537bf821e056cc9fe5abd38",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/979d63d50c0c0f7bc537bf821e056cc9fe5abd38",
    "files": [
      "include/linux/bpf_verifier.h",
      "kernel/bpf/verifier.c"
    ],
    "message": "bpf: prevent out of bounds speculation on pointer arithmetic\n\nJann reported that the original commit back in b2157399cc98\n(\"bpf: prevent out-of-bounds speculation\") was not sufficient\nto stop CPU from speculating out of bounds memory access:\nWhile b2157399cc98 only focussed on masking array map access\nfor unprivileged users for tail calls and data access such\nthat the user provided index gets sanitized from BPF program\nand syscall side, there is still a more generic form affected\nfrom BPF programs that applies to most maps that hold user\ndata in relation to dynamic map access when dealing with\nunknown scalars or \"slow\" known scalars as access offset, for\nexample:\n\n  - Load a map value pointer into R6\n  - Load an index into R7\n  - Do a slow computation (e.g. with a memory dependency) that\n    loads a limit into R8 (e.g. load the limit from a map for\n    high latency, then mask it to make the verifier happy)\n  - Exit if R7 >= R8 (mispredicted branch)\n  - Load R0 = R6[R7]\n  - Load R0 = R6[R0]\n\nFor unknown scalars there are two options in the BPF verifier\nwhere we could derive knowledge from in order to guarantee\nsafe access to the memory: i) While </>/<=/>= variants won't\nallow to derive any lower or upper bounds from the unknown\nscalar where it would be safe to add it to the map value\npointer, it is possible through ==/!= test however. ii) another\noption is to transform the unknown scalar into a known scalar,\nfor example, through ALU ops combination such as R &= <imm>\nfollowed by R |= <imm> or any similar combination where the\noriginal information from the unknown scalar would be destroyed\nentirely leaving R with a constant. The initial slow load still\nprecedes the latter ALU ops on that register, so the CPU\nexecutes speculatively from that point. Once we have the known\nscalar, any compare operation would work then. A third option\nonly involving registers with known scalars could be crafted\nas described in [0] where a CPU port (e.g. Slow Int unit)\nwould be filled with many dependent computations such that\nthe subsequent condition depending on its outcome has to wait\nfor evaluation on its execution port and thereby executing\nspeculatively if the speculated code can be scheduled on a\ndifferent execution port, or any other form of mistraining\nas described in [1], for example. Given this is not limited\nto only unknown scalars, not only map but also stack access\nis affected since both is accessible for unprivileged users\nand could potentially be used for out of bounds access under\nspeculation.\n\nIn order to prevent any of these cases, the verifier is now\nsanitizing pointer arithmetic on the offset such that any\nout of bounds speculation would be masked in a way where the\npointer arithmetic result in the destination register will\nstay unchanged, meaning offset masked into zero similar as\nin array_index_nospec() case. With regards to implementation,\nthere are three options that were considered: i) new insn\nfor sanitation, ii) push/pop insn and sanitation as inlined\nBPF, iii) reuse of ax register and sanitation as inlined BPF.\n\nOption i) has the downside that we end up using from reserved\nbits in the opcode space, but also that we would require\neach JIT to emit masking as native arch opcodes meaning\nmitigation would have slow adoption till everyone implements\nit eventually which is counter-productive. Option ii) and iii)\nhave both in common that a temporary register is needed in\norder to implement the sanitation as inlined BPF since we\nare not allowed to modify the source register. While a push /\npop insn in ii) would be useful to have in any case, it\nrequires once again that every JIT needs to implement it\nfirst. While possible, amount of changes needed would also\nbe unsuitable for a -stable patch. Therefore, the path which\nhas fewer changes, less BPF instructions for the mitigation\nand does not require anything to be changed in the JITs is\noption iii) which this work is pursuing. The ax register is\nalready mapped to a register in all JITs (modulo arm32 where\nit's mapped to stack as various other BPF registers there)\nand used in constant blinding for JITs-only so far. It can\nbe reused for verifier rewrites under certain constraints.\nThe interpreter's tmp \"register\" has therefore been remapped\ninto extending the register set with hidden ax register and\nreusing that for a number of instructions that needed the\nprior temporary variable internally (e.g. div, mod). This\nallows for zero increase in stack space usage in the interpreter,\nand enables (restricted) generic use in rewrites otherwise as\nlong as such a patchlet does not make use of these instructions.\nThe sanitation mask is dynamic and relative to the offset the\nmap value or stack pointer currently holds.\n\nThere are various cases that need to be taken under consideration\nfor the masking, e.g. such operation could look as follows:\nptr += val or val += ptr or ptr -= val. Thus, the value to be\nsanitized could reside either in source or in destination\nregister, and the limit is different depending on whether\nthe ALU op is addition or subtraction and depending on the\ncurrent known and bounded offset. The limit is derived as\nfollows: limit := max_value_size - (smin_value + off). For\nsubtraction: limit := umax_value + off. This holds because\nwe do not allow any pointer arithmetic that would\ntemporarily go out of bounds or would have an unknown\nvalue with mixed signed bounds where it is unclear at\nverification time whether the actual runtime value would\nbe either negative or positive. For example, we have a\nderived map pointer value with constant offset and bounded\none, so limit based on smin_value works because the verifier\nrequires that statically analyzed arithmetic on the pointer\nmust be in bounds, and thus it checks if resulting\nsmin_value + off and umax_value + off is still within map\nvalue bounds at time of arithmetic in addition to time of\naccess. Similarly, for the case of stack access we derive\nthe limit as follows: MAX_BPF_STACK + off for subtraction\nand -off for the case of addition where off := ptr_reg->off +\nptr_reg->var_off.value. Subtraction is a special case for\nthe masking which can be in form of ptr += -val, ptr -= -val,\nor ptr -= val. In the first two cases where we know that\nthe value is negative, we need to temporarily negate the\nvalue in order to do the sanitation on a positive value\nwhere we later swap the ALU op, and restore original source\nregister if the value was in source.\n\nThe sanitation of pointer arithmetic alone is still not fully\nsufficient as is, since a scenario like the following could\nhappen ...\n\n  PTR += 0x1000 (e.g. K-based imm)\n  PTR -= BIG_NUMBER_WITH_SLOW_COMPARISON\n  PTR += 0x1000\n  PTR -= BIG_NUMBER_WITH_SLOW_COMPARISON\n  [...]\n\n... which under speculation could end up as ...\n\n  PTR += 0x1000\n  PTR -= 0 [ truncated by mitigation ]\n  PTR += 0x1000\n  PTR -= 0 [ truncated by mitigation ]\n  [...]\n\n... and therefore still access out of bounds. To prevent such\ncase, the verifier is also analyzing safety for potential out\nof bounds access under speculative execution. Meaning, it is\nalso simulating pointer access under truncation. We therefore\n\"branch off\" and push the current verification state after the\nALU operation with known 0 to the verification stack for later\nanalysis. Given the current path analysis succeeded it is\nlikely that the one under speculation can be pruned. In any\ncase, it is also subject to existing complexity limits and\ntherefore anything beyond this point will be rejected. In\nterms of pruning, it needs to be ensured that the verification\nstate from speculative execution simulation must never prune\na non-speculative execution path, therefore, we mark verifier\nstate accordingly at the time of push_stack(). If verifier\ndetects out of bounds access under speculative execution from\none of the possible paths that includes a truncation, it will\nreject such program.\n\nGiven we mask every reg-based pointer arithmetic for\nunprivileged programs, we've been looking into how it could\naffect real-world programs in terms of size increase. As the\nmajority of programs are targeted for privileged-only use\ncase, we've unconditionally enabled masking (with its alu\nrestrictions on top of it) for privileged programs for the\nsake of testing in order to check i) whether they get rejected\nin its current form, and ii) by how much the number of\ninstructions and size will increase. We've tested this by\nusing Katran, Cilium and test_l4lb from the kernel selftests.\nFor Katran we've evaluated balancer_kern.o, Cilium bpf_lxc.o\nand an older test object bpf_lxc_opt_-DUNKNOWN.o and l4lb\nwe've used test_l4lb.o as well as test_l4lb_noinline.o. We\nfound that none of the programs got rejected by the verifier\nwith this change, and that impact is rather minimal to none.\nbalancer_kern.o had 13,904 bytes (1,738 insns) xlated and\n7,797 bytes JITed before and after the change. Most complex\nprogram in bpf_lxc.o had 30,544 bytes (3,817 insns) xlated\nand 18,538 bytes JITed before and after and none of the other\ntail call programs in bpf_lxc.o had any changes either. For\nthe older bpf_lxc_opt_-DUNKNOWN.o object we found a small\nincrease from 20,616 bytes (2,576 insns) and 12,536 bytes JITed\nbefore to 20,664 bytes (2,582 insns) and 12,558 bytes JITed\nafter the change. Other programs from that object file had\nsimilar small increase. Both test_l4lb.o had no change and\nremained at 6,544 bytes (817 insns) xlated and 3,401 bytes\nJITed and for test_l4lb_noinline.o constant at 5,080 bytes\n(634 insns) xlated and 3,313 bytes JITed. This can be explained\nin that LLVM typically optimizes stack based pointer arithmetic\nby using K-based operations and that use of dynamic map access\nis not overly frequent. However, in future we may decide to\noptimize the algorithm further under known guarantees from\nbranch and value speculation. Latter seems also unclear in\nterms of prediction heuristics that today's CPUs apply as well\nas whether there could be collisions in e.g. the predictor's\nValue History/Pattern Table for triggering out of bounds access,\nthus masking is performed unconditionally at this point but could\nbe subject to relaxation later on. We were generally also\nbrainstorming various other approaches for mitigation, but the\nblocker was always lack of available registers at runtime and/or\noverhead for runtime tracking of limits belonging to a specific\npointer. Thus, we found this to be minimally intrusive under\ngiven constraints.\n\nWith that in place, a simple example with sanitized access on\nunprivileged load at post-verification time looks as follows:\n\n  # bpftool prog dump xlated id 282\n  [...]\n  28: (79) r1 = *(u64 *)(r7 +0)\n  29: (79) r2 = *(u64 *)(r7 +8)\n  30: (57) r1 &= 15\n  31: (79) r3 = *(u64 *)(r0 +4608)\n  32: (57) r3 &= 1\n  33: (47) r3 |= 1\n  34: (2d) if r2 > r3 goto pc+19\n  35: (b4) (u32) r11 = (u32) 20479  |\n  36: (1f) r11 -= r2                | Dynamic sanitation for pointer\n  37: (4f) r11 |= r2                | arithmetic with registers\n  38: (87) r11 = -r11               | containing bounded or known\n  39: (c7) r11 s>>= 63              | scalars in order to prevent\n  40: (5f) r11 &= r2                | out of bounds speculation.\n  41: (0f) r4 += r11                |\n  42: (71) r4 = *(u8 *)(r4 +0)\n  43: (6f) r4 <<= r1\n  [...]\n\nFor the case where the scalar sits in the destination register\nas opposed to the source register, the following code is emitted\nfor the above example:\n\n  [...]\n  16: (b4) (u32) r11 = (u32) 20479\n  17: (1f) r11 -= r2\n  18: (4f) r11 |= r2\n  19: (87) r11 = -r11\n  20: (c7) r11 s>>= 63\n  21: (5f) r2 &= r11\n  22: (0f) r2 += r0\n  23: (61) r0 = *(u32 *)(r2 +0)\n  [...]\n\nJIT blinding example with non-conflicting use of r10:\n\n  [...]\n   d5:\tje     0x0000000000000106    _\n   d7:\tmov    0x0(%rax),%edi       |\n   da:\tmov    $0xf153246,%r10d     | Index load from map value and\n   e0:\txor    $0xf153259,%r10      | (const blinded) mask with 0x1f.\n   e7:\tand    %r10,%rdi            |_\n   ea:\tmov    $0x2f,%r10d          |\n   f0:\tsub    %rdi,%r10            | Sanitized addition. Both use r10\n   f3:\tor     %rdi,%r10            | but do not interfere with each\n   f6:\tneg    %r10                 | other. (Neither do these instructions\n   f9:\tsar    $0x3f,%r10           | interfere with the use of ax as temp\n   fd:\tand    %r10,%rdi            | in interpreter.)\n  100:\tadd    %rax,%rdi            |_\n  103:\tmov    0x0(%rdi),%eax\n [...]\n\nTested that it fixes Jann's reproducer, and also checked that test_verifier\nand test_progs suite with interpreter, JIT and JIT with hardening enabled\non x86-64 and arm64 runs successfully.\n\n  [0] Speculose: Analyzing the Security Implications of Speculative\n      Execution in CPUs, Giorgi Maisuradze and Christian Rossow,\n      https://arxiv.org/pdf/1801.04084.pdf\n\n  [1] A Systematic Evaluation of Transient Execution Attacks and\n      Defenses, Claudio Canella, Jo Van Bulck, Michael Schwarz,\n      Moritz Lipp, Benjamin von Berg, Philipp Ortner, Frank Piessens,\n      Dmitry Evtyushkin, Daniel Gruss,\n      https://arxiv.org/pdf/1811.05441.pdf\n\nFixes: b2157399cc98 (\"bpf: prevent out-of-bounds speculation\")\nReported-by: Jann Horn <jannh@google.com>\nSigned-off-by: Daniel Borkmann <daniel@iogearbox.net>\nAcked-by: Alexei Starovoitov <ast@kernel.org>\nSigned-off-by: Alexei Starovoitov <ast@kernel.org>",
    "before_after_code_files": [
      "include/linux/bpf_verifier.h||include/linux/bpf_verifier.h",
      "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
    ]
  },
  "patch_diff": {
    "include/linux/bpf_verifier.h||include/linux/bpf_verifier.h": [
      "File: include/linux/bpf_verifier.h -> include/linux/bpf_verifier.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "149:  struct bpf_func_state *frame[MAX_CALL_FRAMES];",
      "150:  u32 curframe;",
      "151: };",
      "153: #define bpf_get_spilled_reg(slot, frame)    \\",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "151:  bool speculative;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "167:  struct bpf_verifier_state_list *next;",
      "168: };",
      "170: struct bpf_insn_aux_data {",
      "171:  union {",
      "175:  };",
      "179: };",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "172: #define BPF_ALU_SANITIZE_SRC  1U",
      "173: #define BPF_ALU_SANITIZE_DST  2U",
      "174: #define BPF_ALU_NEG_VALUE  (1U << 2)",
      "175: #define BPF_ALU_SANITIZE  (BPF_ALU_SANITIZE_SRC | \\",
      "176:       BPF_ALU_SANITIZE_DST)",
      "",
      "---------------"
    ],
    "kernel/bpf/verifier.c||kernel/bpf/verifier.c": [
      "File: kernel/bpf/verifier.c -> kernel/bpf/verifier.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "710:   free_func_state(dst_state->frame[i]);",
      "711:   dst_state->frame[i] = NULL;",
      "712:  }",
      "713:  dst_state->curframe = src->curframe;",
      "714:  for (i = 0; i <= src->curframe; i++) {",
      "715:   dst = dst_state->frame[i];",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "713:  dst_state->speculative = src->speculative;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "754: }",
      "756: static struct bpf_verifier_state *push_stack(struct bpf_verifier_env *env,",
      "758: {",
      "759:  struct bpf_verifier_state *cur = env->cur_state;",
      "760:  struct bpf_verifier_stack_elem *elem;",
      "",
      "[Removed Lines]",
      "757:           int insn_idx, int prev_insn_idx)",
      "",
      "[Added Lines]",
      "758:           int insn_idx, int prev_insn_idx,",
      "759:           bool speculative)",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "772:  err = copy_verifier_state(&elem->st, cur);",
      "773:  if (err)",
      "774:   goto err;",
      "775:  if (env->stack_size > BPF_COMPLEXITY_LIMIT_STACK) {",
      "776:   verbose(env, \"BPF program is too complex\\n\");",
      "777:   goto err;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "777:  elem->st.speculative |= speculative;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "3067:  return true;",
      "3068: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "3073: static struct bpf_insn_aux_data *cur_aux(struct bpf_verifier_env *env)",
      "3074: {",
      "3075:  return &env->insn_aux_data[env->insn_idx];",
      "3076: }",
      "3078: static int retrieve_ptr_limit(const struct bpf_reg_state *ptr_reg,",
      "3079:          u32 *ptr_limit, u8 opcode, bool off_is_neg)",
      "3080: {",
      "3081:  bool mask_to_left = (opcode == BPF_ADD &&  off_is_neg) ||",
      "3082:        (opcode == BPF_SUB && !off_is_neg);",
      "3083:  u32 off;",
      "3085:  switch (ptr_reg->type) {",
      "3086:  case PTR_TO_STACK:",
      "3087:   off = ptr_reg->off + ptr_reg->var_off.value;",
      "3088:   if (mask_to_left)",
      "3090:   else",
      "3092:   return 0;",
      "3093:  case PTR_TO_MAP_VALUE:",
      "3094:   if (mask_to_left) {",
      "3096:   } else {",
      "3097:    off = ptr_reg->smin_value + ptr_reg->off;",
      "3099:   }",
      "3100:   return 0;",
      "3101:  default:",
      "3102:   return -EINVAL;",
      "3103:  }",
      "3104: }",
      "3106: static int sanitize_ptr_alu(struct bpf_verifier_env *env,",
      "3107:        struct bpf_insn *insn,",
      "3108:        const struct bpf_reg_state *ptr_reg,",
      "3109:        struct bpf_reg_state *dst_reg,",
      "3110:        bool off_is_neg)",
      "3111: {",
      "3112:  struct bpf_verifier_state *vstate = env->cur_state;",
      "3113:  struct bpf_insn_aux_data *aux = cur_aux(env);",
      "3114:  bool ptr_is_dst_reg = ptr_reg == dst_reg;",
      "3115:  u8 opcode = BPF_OP(insn->code);",
      "3116:  u32 alu_state, alu_limit;",
      "3117:  struct bpf_reg_state tmp;",
      "3118:  bool ret;",
      "3120:  if (env->allow_ptr_leaks || BPF_SRC(insn->code) == BPF_K)",
      "3121:   return 0;",
      "3127:  if (vstate->speculative)",
      "3128:   goto do_sim;",
      "3130:  alu_state  = off_is_neg ? BPF_ALU_NEG_VALUE : 0;",
      "3131:  alu_state |= ptr_is_dst_reg ?",
      "3132:        BPF_ALU_SANITIZE_SRC : BPF_ALU_SANITIZE_DST;",
      "3134:  if (retrieve_ptr_limit(ptr_reg, &alu_limit, opcode, off_is_neg))",
      "3135:   return 0;",
      "3140:  if (aux->alu_state &&",
      "3141:      (aux->alu_state != alu_state ||",
      "3142:       aux->alu_limit != alu_limit))",
      "3143:   return -EACCES;",
      "3146:  aux->alu_state = alu_state;",
      "3147:  aux->alu_limit = alu_limit;",
      "3149: do_sim:",
      "3159:  if (!ptr_is_dst_reg) {",
      "3160:   tmp = *dst_reg;",
      "3162:  }",
      "3163:  ret = push_stack(env, env->insn_idx + 1, env->insn_idx, true);",
      "3164:  if (!ptr_is_dst_reg)",
      "3166:  return !ret ? -EFAULT : 0;",
      "3167: }",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "3087:      umin_ptr = ptr_reg->umin_value, umax_ptr = ptr_reg->umax_value;",
      "3088:  u32 dst = insn->dst_reg, src = insn->src_reg;",
      "3089:  u8 opcode = BPF_OP(insn->code);",
      "3091:  dst_reg = &regs[dst];",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "3189:  int ret;",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "3143:  switch (opcode) {",
      "3144:  case BPF_ADD:",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "3245:   ret = sanitize_ptr_alu(env, insn, ptr_reg, dst_reg, smin_val < 0);",
      "3246:   if (ret < 0) {",
      "3247:    verbose(env, \"R%d tried to add from different maps or paths\\n\", dst);",
      "3248:    return ret;",
      "3249:   }",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "3192:   }",
      "3193:   break;",
      "3194:  case BPF_SUB:",
      "3195:   if (dst_reg == off_reg) {",
      "3197:    verbose(env, \"R%d tried to subtract pointer from scalar\\n\",",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "3300:   ret = sanitize_ptr_alu(env, insn, ptr_reg, dst_reg, smin_val < 0);",
      "3301:   if (ret < 0) {",
      "3302:    verbose(env, \"R%d tried to sub from different maps or paths\\n\", dst);",
      "3303:    return ret;",
      "3304:   }",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "4389:   }",
      "4390:  }",
      "4393:  if (!other_branch)",
      "4394:   return -EFAULT;",
      "4395:  other_branch_regs = other_branch->frame[other_branch->curframe]->regs;",
      "",
      "[Removed Lines]",
      "4392:  other_branch = push_stack(env, *insn_idx + insn->off + 1, *insn_idx);",
      "",
      "[Added Lines]",
      "4502:  other_branch = push_stack(env, *insn_idx + insn->off + 1, *insn_idx,",
      "4503:       false);",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "5499:  if (old->curframe != cur->curframe)",
      "5500:   return false;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "5616:  if (old->speculative && !cur->speculative)",
      "5617:   return false;",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "5700:  if (!state)",
      "5701:   return -ENOMEM;",
      "5702:  state->curframe = 0;",
      "5703:  state->frame[0] = kzalloc(sizeof(struct bpf_func_state), GFP_KERNEL);",
      "5704:  if (!state->frame[0]) {",
      "5705:   kfree(state);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "5820:  state->speculative = false;",
      "",
      "---------------",
      "--- Hunk 11 ---",
      "[Context before]",
      "5740:    if (env->log.level) {",
      "5741:     if (do_print_state)",
      "5744:     else",
      "5745:      verbose(env, \"%d: safe\\n\", env->insn_idx);",
      "5746:    }",
      "",
      "[Removed Lines]",
      "5742:      verbose(env, \"\\nfrom %d to %d: safe\\n\",",
      "5743:       env->prev_insn_idx, env->insn_idx);",
      "",
      "[Added Lines]",
      "5860:      verbose(env, \"\\nfrom %d to %d%s: safe\\n\",",
      "5861:       env->prev_insn_idx, env->insn_idx,",
      "5862:       env->cur_state->speculative ?",
      "5863:       \" (speculative execution)\" : \"\");",
      "",
      "---------------",
      "--- Hunk 12 ---",
      "[Context before]",
      "5757:    if (env->log.level > 1)",
      "5758:     verbose(env, \"%d:\", env->insn_idx);",
      "5759:    else",
      "5762:    print_verifier_state(env, state->frame[state->curframe]);",
      "5763:    do_print_state = false;",
      "5764:   }",
      "",
      "[Removed Lines]",
      "5760:     verbose(env, \"\\nfrom %d to %d:\",",
      "5761:      env->prev_insn_idx, env->insn_idx);",
      "",
      "[Added Lines]",
      "5880:     verbose(env, \"\\nfrom %d to %d%s:\",",
      "5881:      env->prev_insn_idx, env->insn_idx,",
      "5882:      env->cur_state->speculative ?",
      "5883:      \" (speculative execution)\" : \"\");",
      "",
      "---------------",
      "--- Hunk 13 ---",
      "[Context before]",
      "6750:    continue;",
      "6751:   }",
      "6753:   if (insn->code != (BPF_JMP | BPF_CALL))",
      "6754:    continue;",
      "6755:   if (insn->src_reg == BPF_PSEUDO_CALL)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "6875:   if (insn->code == (BPF_ALU64 | BPF_ADD | BPF_X) ||",
      "6876:       insn->code == (BPF_ALU64 | BPF_SUB | BPF_X)) {",
      "6877:    const u8 code_add = BPF_ALU64 | BPF_ADD | BPF_X;",
      "6878:    const u8 code_sub = BPF_ALU64 | BPF_SUB | BPF_X;",
      "6879:    struct bpf_insn insn_buf[16];",
      "6880:    struct bpf_insn *patch = &insn_buf[0];",
      "6881:    bool issrc, isneg;",
      "6882:    u32 off_reg;",
      "6884:    aux = &env->insn_aux_data[i + delta];",
      "6885:    if (!aux->alu_state)",
      "6886:     continue;",
      "6888:    isneg = aux->alu_state & BPF_ALU_NEG_VALUE;",
      "6889:    issrc = (aux->alu_state & BPF_ALU_SANITIZE) ==",
      "6890:     BPF_ALU_SANITIZE_SRC;",
      "6892:    off_reg = issrc ? insn->src_reg : insn->dst_reg;",
      "6893:    if (isneg)",
      "6900:    if (issrc) {",
      "6902:         off_reg);",
      "6903:     insn->src_reg = BPF_REG_AX;",
      "6904:    } else {",
      "6906:         BPF_REG_AX);",
      "6907:    }",
      "6908:    if (isneg)",
      "6909:     insn->code = insn->code == code_add ?",
      "6910:           code_sub : code_add;",
      "6912:    if (issrc && isneg)",
      "6914:    cnt = patch - insn_buf;",
      "6916:    new_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);",
      "6917:    if (!new_prog)",
      "6918:     return -ENOMEM;",
      "6920:    delta    += cnt - 1;",
      "6921:    env->prog = prog = new_prog;",
      "6922:    insn      = new_prog->insnsi + i + delta;",
      "6923:    continue;",
      "6924:   }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "0803278b0b4d8eeb2b461fb698785df65a725d9e",
      "candidate_info": {
        "commit_hash": "0803278b0b4d8eeb2b461fb698785df65a725d9e",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/0803278b0b4d8eeb2b461fb698785df65a725d9e",
        "files": [
          "kernel/bpf/verifier.c"
        ],
        "message": "bpf: do not restore dst_reg when cur_state is freed\n\nSyzkaller hit 'KASAN: use-after-free Write in sanitize_ptr_alu' bug.\n\nCall trace:\n\n  dump_stack+0xbf/0x12e\n  print_address_description+0x6a/0x280\n  kasan_report+0x237/0x360\n  sanitize_ptr_alu+0x85a/0x8d0\n  adjust_ptr_min_max_vals+0x8f2/0x1ca0\n  adjust_reg_min_max_vals+0x8ed/0x22e0\n  do_check+0x1ca6/0x5d00\n  bpf_check+0x9ca/0x2570\n  bpf_prog_load+0xc91/0x1030\n  __se_sys_bpf+0x61e/0x1f00\n  do_syscall_64+0xc8/0x550\n  entry_SYSCALL_64_after_hwframe+0x49/0xbe\n\nFault injection trace:\n\n \u00a0kfree+0xea/0x290\n \u00a0free_func_state+0x4a/0x60\n \u00a0free_verifier_state+0x61/0xe0\n \u00a0push_stack+0x216/0x2f0\t          <- inject failslab\n \u00a0sanitize_ptr_alu+0x2b1/0x8d0\n \u00a0adjust_ptr_min_max_vals+0x8f2/0x1ca0\n \u00a0adjust_reg_min_max_vals+0x8ed/0x22e0\n \u00a0do_check+0x1ca6/0x5d00\n \u00a0bpf_check+0x9ca/0x2570\n \u00a0bpf_prog_load+0xc91/0x1030\n \u00a0__se_sys_bpf+0x61e/0x1f00\n \u00a0do_syscall_64+0xc8/0x550\n \u00a0entry_SYSCALL_64_after_hwframe+0x49/0xbe\n\nWhen kzalloc() fails in push_stack(), free_verifier_state() will free\ncurrent verifier state. As push_stack() returns, dst_reg was restored\nif ptr_is_dst_reg is false. However, as member of the cur_state,\ndst_reg is also freed, and error occurs when dereferencing dst_reg.\nSimply fix it by testing ret of push_stack() before restoring dst_reg.\n\nFixes: 979d63d50c0c (\"bpf: prevent out of bounds speculation on pointer arithmetic\")\nSigned-off-by: Xu Yu <xuyu@linux.alibaba.com>\nSigned-off-by: Daniel Borkmann <daniel@iogearbox.net>",
        "before_after_code_files": [
          "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
          ],
          "candidate": [
            "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
          ]
        }
      },
      "candidate_diff": {
        "kernel/bpf/verifier.c||kernel/bpf/verifier.c": [
          "File: kernel/bpf/verifier.c -> kernel/bpf/verifier.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3382:  }",
          "3383:  ret = push_stack(env, env->insn_idx + 1, env->insn_idx, true);",
          "3386:  return !ret ? -EFAULT : 0;",
          "3387: }",
          "",
          "[Removed Lines]",
          "3384:  if (!ptr_is_dst_reg)",
          "",
          "[Added Lines]",
          "3384:  if (!ptr_is_dst_reg && ret)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "d3bd7413e0ca40b60cf60d4003246d067cafdeda",
      "candidate_info": {
        "commit_hash": "d3bd7413e0ca40b60cf60d4003246d067cafdeda",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/d3bd7413e0ca40b60cf60d4003246d067cafdeda",
        "files": [
          "include/linux/bpf_verifier.h",
          "kernel/bpf/verifier.c"
        ],
        "message": "bpf: fix sanitation of alu op with pointer / scalar type from different paths\n\nWhile 979d63d50c0c (\"bpf: prevent out of bounds speculation on pointer\narithmetic\") took care of rejecting alu op on pointer when e.g. pointer\ncame from two different map values with different map properties such as\nvalue size, Jann reported that a case was not covered yet when a given\nalu op is used in both \"ptr_reg += reg\" and \"numeric_reg += reg\" from\ndifferent branches where we would incorrectly try to sanitize based\non the pointer's limit. Catch this corner case and reject the program\ninstead.\n\nFixes: 979d63d50c0c (\"bpf: prevent out of bounds speculation on pointer arithmetic\")\nReported-by: Jann Horn <jannh@google.com>\nSigned-off-by: Daniel Borkmann <daniel@iogearbox.net>\nAcked-by: Alexei Starovoitov <ast@kernel.org>\nSigned-off-by: Alexei Starovoitov <ast@kernel.org>",
        "before_after_code_files": [
          "include/linux/bpf_verifier.h||include/linux/bpf_verifier.h",
          "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "include/linux/bpf_verifier.h||include/linux/bpf_verifier.h",
            "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
          ],
          "candidate": [
            "include/linux/bpf_verifier.h||include/linux/bpf_verifier.h",
            "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
          ]
        }
      },
      "candidate_diff": {
        "include/linux/bpf_verifier.h||include/linux/bpf_verifier.h": [
          "File: include/linux/bpf_verifier.h -> include/linux/bpf_verifier.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "172: #define BPF_ALU_SANITIZE_SRC  1U",
          "173: #define BPF_ALU_SANITIZE_DST  2U",
          "174: #define BPF_ALU_NEG_VALUE  (1U << 2)",
          "175: #define BPF_ALU_SANITIZE  (BPF_ALU_SANITIZE_SRC | \\",
          "176:       BPF_ALU_SANITIZE_DST)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "175: #define BPF_ALU_NON_POINTER  (1U << 3)",
          "",
          "---------------"
        ],
        "kernel/bpf/verifier.c||kernel/bpf/verifier.c": [
          "File: kernel/bpf/verifier.c -> kernel/bpf/verifier.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3103:  }",
          "3104: }",
          "3106: static int sanitize_ptr_alu(struct bpf_verifier_env *env,",
          "3107:        struct bpf_insn *insn,",
          "3108:        const struct bpf_reg_state *ptr_reg,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3106: static bool can_skip_alu_sanitation(const struct bpf_verifier_env *env,",
          "3107:         const struct bpf_insn *insn)",
          "3108: {",
          "3109:  return env->allow_ptr_leaks || BPF_SRC(insn->code) == BPF_K;",
          "3110: }",
          "3112: static int update_alu_sanitation_state(struct bpf_insn_aux_data *aux,",
          "3113:            u32 alu_state, u32 alu_limit)",
          "3114: {",
          "3118:  if (aux->alu_state &&",
          "3119:      (aux->alu_state != alu_state ||",
          "3120:       aux->alu_limit != alu_limit))",
          "3121:   return -EACCES;",
          "3124:  aux->alu_state = alu_state;",
          "3125:  aux->alu_limit = alu_limit;",
          "3126:  return 0;",
          "3127: }",
          "3129: static int sanitize_val_alu(struct bpf_verifier_env *env,",
          "3130:        struct bpf_insn *insn)",
          "3131: {",
          "3132:  struct bpf_insn_aux_data *aux = cur_aux(env);",
          "3134:  if (can_skip_alu_sanitation(env, insn))",
          "3135:   return 0;",
          "3137:  return update_alu_sanitation_state(aux, BPF_ALU_NON_POINTER, 0);",
          "3138: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3117:  struct bpf_reg_state tmp;",
          "3118:  bool ret;",
          "3121:   return 0;",
          "",
          "[Removed Lines]",
          "3120:  if (env->allow_ptr_leaks || BPF_SRC(insn->code) == BPF_K)",
          "",
          "[Added Lines]",
          "3154:  if (can_skip_alu_sanitation(env, insn))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3134:  if (retrieve_ptr_limit(ptr_reg, &alu_limit, opcode, off_is_neg))",
          "3135:   return 0;",
          "3143:   return -EACCES;",
          "3149: do_sim:",
          "",
          "[Removed Lines]",
          "3140:  if (aux->alu_state &&",
          "3141:      (aux->alu_state != alu_state ||",
          "3142:       aux->alu_limit != alu_limit))",
          "3146:  aux->alu_state = alu_state;",
          "3147:  aux->alu_limit = alu_limit;",
          "",
          "[Added Lines]",
          "3170:  if (update_alu_sanitation_state(aux, alu_state, alu_limit))",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "3418:  s64 smin_val, smax_val;",
          "3419:  u64 umin_val, umax_val;",
          "3420:  u64 insn_bitness = (BPF_CLASS(insn->code) == BPF_ALU64) ? 64 : 32;",
          "3422:  if (insn_bitness == 32) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3444:  u32 dst = insn->dst_reg;",
          "3445:  int ret;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "3453:  switch (opcode) {",
          "3454:  case BPF_ADD:",
          "3455:   if (signed_add_overflows(dst_reg->smin_value, smin_val) ||",
          "3456:       signed_add_overflows(dst_reg->smax_value, smax_val)) {",
          "3457:    dst_reg->smin_value = S64_MIN;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3480:   ret = sanitize_val_alu(env, insn);",
          "3481:   if (ret < 0) {",
          "3482:    verbose(env, \"R%d tried to add from different pointers or scalars\\n\", dst);",
          "3483:    return ret;",
          "3484:   }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "3471:   dst_reg->var_off = tnum_add(dst_reg->var_off, src_reg.var_off);",
          "3472:   break;",
          "3473:  case BPF_SUB:",
          "3474:   if (signed_sub_overflows(dst_reg->smin_value, smax_val) ||",
          "3475:       signed_sub_overflows(dst_reg->smax_value, smin_val)) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3504:   ret = sanitize_val_alu(env, insn);",
          "3505:   if (ret < 0) {",
          "3506:    verbose(env, \"R%d tried to sub from different pointers or scalars\\n\", dst);",
          "3507:    return ret;",
          "3508:   }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "7640ead939247e91e84b7ec6ec001f30193cc7df",
      "candidate_info": {
        "commit_hash": "7640ead939247e91e84b7ec6ec001f30193cc7df",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/7640ead939247e91e84b7ec6ec001f30193cc7df",
        "files": [
          "kernel/bpf/verifier.c",
          "tools/testing/selftests/bpf/test_verifier.c"
        ],
        "message": "bpf: verifier: make sure callees don't prune with caller differences\n\nCurrently for liveness and state pruning the register parentage\nchains don't include states of the callee.  This makes some sense\nas the callee can't access those registers.  However, this means\nthat READs done after the callee returns will not propagate into\nthe states of the callee.  Callee will then perform pruning\ndisregarding differences in caller state.\n\nExample:\n\n   0: (85) call bpf_user_rnd_u32\n   1: (b7) r8 = 0\n   2: (55) if r0 != 0x0 goto pc+1\n   3: (b7) r8 = 1\n   4: (bf) r1 = r8\n   5: (85) call pc+4\n   6: (15) if r8 == 0x1 goto pc+1\n   7: (05) *(u64 *)(r9 - 8) = r3\n   8: (b7) r0 = 0\n   9: (95) exit\n\n   10: (15) if r1 == 0x0 goto pc+0\n   11: (95) exit\n\nHere we acquire unknown state with call to get_random() [1].  Then\nwe store this random state in r8 (either 0 or 1) [1 - 3], and make\na call on line 5.  Callee does nothing but a trivial conditional\njump (to create a pruning point).  Upon return caller checks the\nstate of r8 and either performs an unsafe read or not.\n\nVerifier will first explore the path with r8 == 1, creating a pruning\npoint at [11].  The parentage chain for r8 will include only callers\nstates so once verifier reaches [6] it will mark liveness only on states\nin the caller, and not [11].  Now when verifier walks the paths with\nr8 == 0 it will reach [11] and since REG_LIVE_READ on r8 was not\npropagated there it will prune the walk entirely (stop walking\nthe entire program, not just the callee).  Since [6] was never walked\nwith r8 == 0, [7] will be considered dead and replaced with \"goto -1\"\ncausing hang at runtime.\n\nThis patch weaves the callee's explored states onto the callers\nparentage chain.  Rough parentage for r8 would have looked like this\nbefore:\n\n[0] [1] [2] [3] [4] [5]   [10]      [11]      [6]      [7]\n     |           |      ,---|----.    |        |        |\n  sl0:         sl0:    / sl0:     \\ sl0:      sl0:     sl0:\n  fr0: r8 <-- fr0: r8<+--fr0: r8   `fr0: r8  ,fr0: r8<-fr0: r8\n                       \\ fr1: r8 <- fr1: r8 /\n                        \\__________________/\n\nafter:\n\n[0] [1] [2] [3] [4] [5]   [10]      [11]      [6]      [7]\n     |           |          |         |        |        |\n   sl0:         sl0:      sl0:       sl0:      sl0:     sl0:\n   fr0: r8 <-- fr0: r8 <- fr0: r8 <- fr0: r8 <-fr0: r8<-fr0: r8\n                          fr1: r8 <- fr1: r8\n\nNow the mark from instruction 6 will travel through callees states.\n\nNote that we don't have to connect r0 because its overwritten by\ncallees state on return and r1 - r5 because those are not alive\nany more once a call is made.\n\nv2:\n - don't connect the callees registers twice (Alexei: suggestion & code)\n - add more details to the comment (Ed & Alexei)\nv1: don't unnecessarily link caller saved regs (Jiong)\n\nFixes: f4d7e40a5b71 (\"bpf: introduce function calls (verification)\")\nReported-by: David Beckett <david.beckett@netronome.com>\nSigned-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>\nReviewed-by: Jiong Wang <jiong.wang@netronome.com>\nReviewed-by: Edward Cree <ecree@solarflare.com>\nSigned-off-by: Alexei Starovoitov <ast@kernel.org>",
        "before_after_code_files": [
          "kernel/bpf/verifier.c||kernel/bpf/verifier.c",
          "tools/testing/selftests/bpf/test_verifier.c||tools/testing/selftests/bpf/test_verifier.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
          ],
          "candidate": [
            "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
          ]
        }
      },
      "candidate_diff": {
        "kernel/bpf/verifier.c||kernel/bpf/verifier.c": [
          "File: kernel/bpf/verifier.c -> kernel/bpf/verifier.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "5102:  }",
          "5103:  new_sl->next = env->explored_states[insn_idx];",
          "5104:  env->explored_states[insn_idx] = new_sl;",
          "",
          "[Removed Lines]",
          "5106:  for (i = 0; i < BPF_REG_FP; i++)",
          "5107:   cur_regs(env)[i].parent = &new->frame[new->curframe]->regs[i];",
          "",
          "[Added Lines]",
          "5112:  for (j = 0; j <= cur->curframe; j++)",
          "5113:   for (i = j < cur->curframe ? BPF_REG_6 : 0; i < BPF_REG_FP; i++)",
          "5114:    cur->frame[j]->regs[i].parent = &new->frame[j]->regs[i];",
          "",
          "---------------"
        ],
        "tools/testing/selftests/bpf/test_verifier.c||tools/testing/selftests/bpf/test_verifier.c": [
          "File: tools/testing/selftests/bpf/test_verifier.c -> tools/testing/selftests/bpf/test_verifier.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "13915:   .result_unpriv = REJECT,",
          "13916:   .result = ACCEPT,",
          "13917:  },",
          "13918: };",
          "13920: static int probe_filter_length(const struct bpf_insn *fp)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "13918:  {",
          "13919:   \"calls: cross frame pruning\",",
          "13920:   .insns = {",
          "13926:    BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0,",
          "13927:          BPF_FUNC_get_prandom_u32),",
          "13928:    BPF_MOV64_IMM(BPF_REG_8, 0),",
          "13929:    BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),",
          "13930:    BPF_MOV64_IMM(BPF_REG_8, 1),",
          "13931:    BPF_MOV64_REG(BPF_REG_1, BPF_REG_8),",
          "13932:    BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 1, 0, 4),",
          "13933:    BPF_JMP_IMM(BPF_JEQ, BPF_REG_8, 1, 1),",
          "13934:    BPF_LDX_MEM(BPF_B, BPF_REG_9, BPF_REG_1, 0),",
          "13935:    BPF_MOV64_IMM(BPF_REG_0, 0),",
          "13936:    BPF_EXIT_INSN(),",
          "13937:    BPF_JMP_IMM(BPF_JEQ, BPF_REG_1, 0, 0),",
          "13938:    BPF_EXIT_INSN(),",
          "13939:   },",
          "13940:   .prog_type = BPF_PROG_TYPE_SOCKET_FILTER,",
          "13941:   .errstr_unpriv = \"function calls to other bpf functions are allowed for root only\",",
          "13942:   .result_unpriv = REJECT,",
          "13943:   .errstr = \"!read_ok\",",
          "13944:   .result = REJECT,",
          "13945:  },",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "3612af783cf52c74a031a2f11b82247b2599d3cd",
      "candidate_info": {
        "commit_hash": "3612af783cf52c74a031a2f11b82247b2599d3cd",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/3612af783cf52c74a031a2f11b82247b2599d3cd",
        "files": [
          "kernel/bpf/verifier.c"
        ],
        "message": "bpf: fix sanitation rewrite in case of non-pointers\n\nMarek reported that he saw an issue with the below snippet in that\ntiming measurements where off when loaded as unpriv while results\nwere reasonable when loaded as privileged:\n\n    [...]\n    uint64_t a = bpf_ktime_get_ns();\n    uint64_t b = bpf_ktime_get_ns();\n    uint64_t delta = b - a;\n    if ((int64_t)delta > 0) {\n    [...]\n\nTurns out there is a bug where a corner case is missing in the fix\nd3bd7413e0ca (\"bpf: fix sanitation of alu op with pointer / scalar\ntype from different paths\"), namely fixup_bpf_calls() only checks\nwhether aux has a non-zero alu_state, but it also needs to test for\nthe case of BPF_ALU_NON_POINTER since in both occasions we need to\nskip the masking rewrite (as there is nothing to mask).\n\nFixes: d3bd7413e0ca (\"bpf: fix sanitation of alu op with pointer / scalar type from different paths\")\nReported-by: Marek Majkowski <marek@cloudflare.com>\nReported-by: Arthur Fabre <afabre@cloudflare.com>\nSigned-off-by: Daniel Borkmann <daniel@iogearbox.net>\nLink: https://lore.kernel.org/netdev/CAJPywTJqP34cK20iLM5YmUMz9KXQOdu1-+BZrGMAGgLuBWz7fg@mail.gmail.com/T/\nAcked-by: Song Liu <songliubraving@fb.com>\nSigned-off-by: Alexei Starovoitov <ast@kernel.org>",
        "before_after_code_files": [
          "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
          ],
          "candidate": [
            "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
          ]
        }
      },
      "candidate_diff": {
        "kernel/bpf/verifier.c||kernel/bpf/verifier.c": [
          "File: kernel/bpf/verifier.c -> kernel/bpf/verifier.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "6920:    u32 off_reg;",
          "6922:    aux = &env->insn_aux_data[i + delta];",
          "6924:     continue;",
          "6926:    isneg = aux->alu_state & BPF_ALU_NEG_VALUE;",
          "",
          "[Removed Lines]",
          "6923:    if (!aux->alu_state)",
          "",
          "[Added Lines]",
          "6923:    if (!aux->alu_state ||",
          "6924:        aux->alu_state == BPF_ALU_NON_POINTER)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "679c782de14bd48c19dd74cd1af20a2bc05dd936",
      "candidate_info": {
        "commit_hash": "679c782de14bd48c19dd74cd1af20a2bc05dd936",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/679c782de14bd48c19dd74cd1af20a2bc05dd936",
        "files": [
          "include/linux/bpf_verifier.h",
          "kernel/bpf/verifier.c"
        ],
        "message": "bpf/verifier: per-register parent pointers\n\nBy giving each register its own liveness chain, we elide the skip_callee()\n logic.  Instead, each register's parent is the state it inherits from;\n both check_func_call() and prepare_func_exit() automatically connect\n reg states to the correct chain since when they copy the reg state across\n (r1-r5 into the callee as args, and r0 out as the return value) they also\n copy the parent pointer.\n\nSigned-off-by: Edward Cree <ecree@solarflare.com>\nSigned-off-by: Alexei Starovoitov <ast@kernel.org>",
        "before_after_code_files": [
          "include/linux/bpf_verifier.h||include/linux/bpf_verifier.h",
          "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "include/linux/bpf_verifier.h||include/linux/bpf_verifier.h",
            "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
          ],
          "candidate": [
            "include/linux/bpf_verifier.h||include/linux/bpf_verifier.h",
            "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
          ]
        }
      },
      "candidate_diff": {
        "include/linux/bpf_verifier.h||include/linux/bpf_verifier.h": [
          "File: include/linux/bpf_verifier.h -> include/linux/bpf_verifier.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "86:  u32 frameno;",
          "88:  enum bpf_reg_liveness live;",
          "89: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "80:  struct bpf_reg_state *parent;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "108: struct bpf_func_state {",
          "109:  struct bpf_reg_state regs[MAX_BPF_REG];",
          "112:  int callsite;",
          "",
          "[Removed Lines]",
          "110:  struct bpf_verifier_state *parent;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "129: struct bpf_verifier_state {",
          "131:  struct bpf_func_state *frame[MAX_CALL_FRAMES];",
          "133:  u32 curframe;",
          "134: };",
          "",
          "[Removed Lines]",
          "132:  struct bpf_verifier_state *parent;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "kernel/bpf/verifier.c||kernel/bpf/verifier.c": [
          "File: kernel/bpf/verifier.c -> kernel/bpf/verifier.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "466:   dst_state->frame[i] = NULL;",
          "467:  }",
          "468:  dst_state->curframe = src->curframe;",
          "470:  for (i = 0; i <= src->curframe; i++) {",
          "471:   dst = dst_state->frame[i];",
          "472:   if (!dst) {",
          "",
          "[Removed Lines]",
          "469:  dst_state->parent = src->parent;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "732:  for (i = 0; i < MAX_BPF_REG; i++) {",
          "733:   mark_reg_not_init(env, regs, i);",
          "734:   regs[i].live = REG_LIVE_NONE;",
          "735:  }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "734:   regs[i].parent = NULL;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "876:  return 0;",
          "877: }",
          "927: static int mark_reg_read(struct bpf_verifier_env *env,",
          "931: {",
          "938:  while (parent) {",
          "941:    break;",
          "947:   state = parent;",
          "948:   parent = state->parent;",
          "949:   writes = true;",
          "",
          "[Removed Lines]",
          "879: static",
          "880: struct bpf_verifier_state *skip_callee(struct bpf_verifier_env *env,",
          "881:            const struct bpf_verifier_state *state,",
          "882:            struct bpf_verifier_state *parent,",
          "883:            u32 regno)",
          "884: {",
          "885:  struct bpf_verifier_state *tmp = NULL;",
          "896:  if (parent->curframe == state->curframe ||",
          "897:      (parent->curframe < state->curframe &&",
          "898:       regno >= BPF_REG_1 && regno <= BPF_REG_5) ||",
          "899:      (parent->curframe > state->curframe &&",
          "900:         regno == BPF_REG_0))",
          "901:   return parent;",
          "903:  if (parent->curframe > state->curframe &&",
          "904:      regno >= BPF_REG_6) {",
          "909:   tmp = parent;",
          "910:   while (tmp && tmp->curframe != state->curframe) {",
          "911:    tmp = tmp->parent;",
          "912:   }",
          "913:   if (!tmp)",
          "914:    goto bug;",
          "915:   parent = tmp;",
          "916:  } else {",
          "917:   goto bug;",
          "918:  }",
          "919:  return parent;",
          "920: bug:",
          "921:  verbose(env, \"verifier bug regno %d tmp %p\\n\", regno, tmp);",
          "922:  verbose(env, \"regno %d parent frame %d current frame %d\\n\",",
          "923:   regno, parent->curframe, state->curframe);",
          "924:  return NULL;",
          "925: }",
          "928:     const struct bpf_verifier_state *state,",
          "929:     struct bpf_verifier_state *parent,",
          "930:     u32 regno)",
          "934:  if (regno == BPF_REG_FP)",
          "936:   return 0;",
          "940:   if (writes && state->frame[state->curframe]->regs[regno].live & REG_LIVE_WRITTEN)",
          "942:   parent = skip_callee(env, state, parent, regno);",
          "943:   if (!parent)",
          "944:    return -EFAULT;",
          "946:   parent->frame[parent->curframe]->regs[regno].live |= REG_LIVE_READ;",
          "",
          "[Added Lines]",
          "883:     const struct bpf_reg_state *state,",
          "884:     struct bpf_reg_state *parent)",
          "890:   if (writes && state->live & REG_LIVE_WRITTEN)",
          "893:   parent->live |= REG_LIVE_READ;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "969:    verbose(env, \"R%d !read_ok\\n\", regno);",
          "970:    return -EACCES;",
          "971:   }",
          "973:  } else {",
          "975:   if (regno == BPF_REG_FP) {",
          "",
          "[Removed Lines]",
          "972:   return mark_reg_read(env, vstate, vstate->parent, regno);",
          "",
          "[Added Lines]",
          "920:   if (regno != BPF_REG_FP)",
          "921:    return mark_reg_read(env, &regs[regno],",
          "922:           regs[regno].parent);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1080:  } else {",
          "1081:   u8 type = STACK_MISC;",
          "",
          "[Removed Lines]",
          "1084:   state->stack[spi].spilled_ptr = (struct bpf_reg_state) {};",
          "",
          "[Added Lines]",
          "1034:   state->stack[spi].spilled_ptr.type = NOT_INIT;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1106:  return 0;",
          "1107: }",
          "1164: static int check_stack_read(struct bpf_verifier_env *env,",
          "1165:        struct bpf_func_state *reg_state /* func where register points to */,",
          "1166:        int off, int size, int value_regno)",
          "",
          "[Removed Lines]",
          "1137: static void mark_stack_slot_read(struct bpf_verifier_env *env,",
          "1138:      const struct bpf_verifier_state *state,",
          "1139:      struct bpf_verifier_state *parent,",
          "1140:      int slot, int frameno)",
          "1141: {",
          "1144:  while (parent) {",
          "1145:   if (parent->frame[frameno]->allocated_stack <= slot * BPF_REG_SIZE)",
          "1152:    break;",
          "1154:   if (writes && state->frame[frameno]->stack[slot].spilled_ptr.live & REG_LIVE_WRITTEN)",
          "1155:    break;",
          "1157:   parent->frame[frameno]->stack[slot].spilled_ptr.live |= REG_LIVE_READ;",
          "1158:   state = parent;",
          "1159:   parent = state->parent;",
          "1160:   writes = true;",
          "1161:  }",
          "1162: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1199:    state->regs[value_regno].live |= REG_LIVE_WRITTEN;",
          "1200:   }",
          "1203:   return 0;",
          "1204:  } else {",
          "1205:   int zeros = 0;",
          "",
          "[Removed Lines]",
          "1201:   mark_stack_slot_read(env, vstate, vstate->parent, spi,",
          "1202:          reg_state->frameno);",
          "",
          "[Added Lines]",
          "1096:   mark_reg_read(env, &reg_state->stack[spi].spilled_ptr,",
          "1097:          reg_state->stack[spi].spilled_ptr.parent);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1215:     off, i, size);",
          "1216:    return -EACCES;",
          "1217:   }",
          "1220:   if (value_regno >= 0) {",
          "1221:    if (zeros == size) {",
          "",
          "[Removed Lines]",
          "1218:   mark_stack_slot_read(env, vstate, vstate->parent, spi,",
          "1219:          reg_state->frameno);",
          "",
          "[Added Lines]",
          "1113:   mark_reg_read(env, &reg_state->stack[spi].spilled_ptr,",
          "1114:          reg_state->stack[spi].spilled_ptr.parent);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1913:  }",
          "1914:  return update_stack_depth(env, state, off);",
          "1915: }",
          "",
          "[Removed Lines]",
          "1911:   mark_stack_slot_read(env, env->cur_state, env->cur_state->parent,",
          "1912:          spi, state->frameno);",
          "",
          "[Added Lines]",
          "1806:   mark_reg_read(env, &state->stack[spi].spilled_ptr,",
          "1807:          state->stack[spi].spilled_ptr.parent);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "4371:   return true;",
          "4375:  if (rold->type == PTR_TO_STACK)",
          "",
          "[Removed Lines]",
          "4373:  equal = memcmp(rold, rcur, offsetof(struct bpf_reg_state, frameno)) == 0;",
          "",
          "[Added Lines]",
          "4270:  equal = memcmp(rold, rcur, offsetof(struct bpf_reg_state, parent)) == 0;",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "4624:   if (vparent->frame[vparent->curframe]->regs[i].live & REG_LIVE_READ)",
          "4625:    continue;",
          "4626:   if (vstate->frame[vstate->curframe]->regs[i].live & REG_LIVE_READ) {",
          "4628:    if (err)",
          "4629:     return err;",
          "4630:   }",
          "",
          "[Removed Lines]",
          "4627:    err = mark_reg_read(env, vstate, vparent, i);",
          "",
          "[Added Lines]",
          "4524:    err = mark_reg_read(env, &vstate->frame[vstate->curframe]->regs[i],",
          "4525:          &vparent->frame[vstate->curframe]->regs[i]);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "4639:    if (parent->stack[i].spilled_ptr.live & REG_LIVE_READ)",
          "4640:     continue;",
          "4641:    if (state->stack[i].spilled_ptr.live & REG_LIVE_READ)",
          "4643:   }",
          "4644:  }",
          "4645:  return err;",
          "",
          "[Removed Lines]",
          "4642:     mark_stack_slot_read(env, vstate, vparent, i, frame);",
          "",
          "[Added Lines]",
          "4540:     mark_reg_read(env, &state->stack[i].spilled_ptr,",
          "4541:            &parent->stack[i].spilled_ptr);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "4649: {",
          "4650:  struct bpf_verifier_state_list *new_sl;",
          "4651:  struct bpf_verifier_state_list *sl;",
          "4653:  int i, j, err;",
          "4655:  sl = env->explored_states[insn_idx];",
          "",
          "[Removed Lines]",
          "4652:  struct bpf_verifier_state *cur = env->cur_state;",
          "",
          "[Added Lines]",
          "4551:  struct bpf_verifier_state *cur = env->cur_state, *new;",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "4691:   return -ENOMEM;",
          "4695:  if (err) {",
          "4697:   kfree(new_sl);",
          "4698:   return err;",
          "4699:  }",
          "4700:  new_sl->next = env->explored_states[insn_idx];",
          "4701:  env->explored_states[insn_idx] = new_sl;",
          "",
          "[Removed Lines]",
          "4694:  err = copy_verifier_state(&new_sl->state, cur);",
          "4696:   free_verifier_state(&new_sl->state, false);",
          "4703:  cur->parent = &new_sl->state;",
          "",
          "[Added Lines]",
          "4593:  new = &new_sl->state;",
          "4594:  err = copy_verifier_state(new, cur);",
          "4596:   free_verifier_state(new, false);",
          "4603:  for (i = 0; i < BPF_REG_FP; i++)",
          "4604:   cur_regs(env)[i].parent = &new->frame[new->curframe]->regs[i];",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "4714:  for (j = 0; j <= cur->curframe; j++) {",
          "4715:   struct bpf_func_state *frame = cur->frame[j];",
          "4718:    frame->stack[i].spilled_ptr.live = REG_LIVE_NONE;",
          "4719:  }",
          "4720:  return 0;",
          "4721: }",
          "",
          "[Removed Lines]",
          "4717:   for (i = 0; i < frame->allocated_stack / BPF_REG_SIZE; i++)",
          "",
          "[Added Lines]",
          "4617:   struct bpf_func_state *newframe = new->frame[j];",
          "4619:   for (i = 0; i < frame->allocated_stack / BPF_REG_SIZE; i++) {",
          "4621:    frame->stack[i].spilled_ptr.parent =",
          "4622:       &newframe->stack[i].spilled_ptr;",
          "4623:   }",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "4734:  if (!state)",
          "4735:   return -ENOMEM;",
          "4736:  state->curframe = 0;",
          "4738:  state->frame[0] = kzalloc(sizeof(struct bpf_func_state), GFP_KERNEL);",
          "4739:  if (!state->frame[0]) {",
          "4740:   kfree(state);",
          "",
          "[Removed Lines]",
          "4737:  state->parent = NULL;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    }
  ]
}